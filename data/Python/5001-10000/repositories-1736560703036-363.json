{
  "metadata": {
    "timestamp": 1736560703036,
    "page": 363,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "hugsy/gef",
      "stars": 7128,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.3583984375,
          "content": "# https://github.com/editorconfig/editorconfig/wiki/EditorConfig-Properties\n\nroot = true\n\n[*]\nend_of_line = lf\ninsert_final_newline = true\ncharset = utf-8\ntrim_trailing_whitespace = true\ninsert_final_newline = true\n\n[*.py]\nindent_style = space\nindent_size = 4\n\n[Makefile]\nindent_style = tab\n\n[*.yml]\nindent_style = space\nindent_size = 2\n\n[*.md]\nmax_line_length = 100\n"
        },
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.07421875,
          "content": "# https://help.github.com/articles/dealing-with-line-endings/\n* text eol=lf\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.1767578125,
          "content": "*.out\n*.pyc\nTAGS\n__pycache__\ntests/*.pyc\ntests/pylint.html\ntests/pylint.txt\ntests/pylint3.html\n.vscode\n_build\ndebug.log\n.pytest_cache\n.coverage\nhtmlcov\n.benchmarks\nsite/\nuntracked/\n"
        },
        {
          "name": ".pre-commit-config.yaml",
          "type": "blob",
          "size": 0.6220703125,
          "content": "default_stages: [pre-commit, pre-push]\nfail_fast: false\nrepos:\n  - repo: https://github.com/pre-commit/pre-commit-hooks\n    rev: v4.4.0\n    hooks:\n    - id: end-of-file-fixer\n    - id: trailing-whitespace\n\n  - repo: https://github.com/pycqa/pylint\n    rev: v3.0.0a6\n    hooks:\n    - id: pylint\n\n  - repo: https://github.com/igorshubovych/markdownlint-cli\n    rev: v0.35.0\n    hooks:\n    - id: markdownlint-docker\n      args:\n        - --config=docs/.markdownlint.yaml\n        - --ignore=docs/api/gef.md\n        - --ignore=docs/obsolete/docs/index.md\n        - --ignore=docs/index.md\n        - --ignore=README.md\n        - \"docs/**/*.md\"\n"
        },
        {
          "name": ".pylintrc",
          "type": "blob",
          "size": 28.244140625,
          "content": "[MASTER]\n\n# A comma-separated list of package or module names from where C extensions may\n# be loaded. Extensions are loading into the active Python interpreter and may\n# run arbitrary code.\nextension-pkg-allow-list=\n\n# A comma-separated list of package or module names from where C extensions may\n# be loaded. Extensions are loading into the active Python interpreter and may\n# run arbitrary code. (This is an alternative name to extension-pkg-allow-list\n# for backward compatibility.)\nextension-pkg-whitelist=\n\n# Return non-zero exit code if any of these messages/categories are detected,\n# even if score is above --fail-under value. Syntax same as enable. Messages\n# specified are enabled, while categories only check already-enabled messages.\nfail-on=\n\n# Specify a score threshold to be exceeded before program exits with error.\nfail-under=10.0\n\n# Files or directories to be skipped. They should be base names, not paths.\nignore=CVS\n\n# Add files or directories matching the regex patterns to the ignore-list. The\n# regex matches against paths and can be in Posix or Windows format.\nignore-paths=\n\n# Files or directories matching the regex patterns are skipped. The regex\n# matches against base names, not paths.\nignore-patterns=\n\n# Python code to execute, usually for sys.path manipulation such as\n# pygtk.require().\n#init-hook=\n\n# Use multiple processes to speed up Pylint. Specifying 0 will auto-detect the\n# number of processors available to use.\njobs=0\n\n# Control the amount of potential inferred values when inferring a single\n# object. This can help the performance when dealing with large functions or\n# complex, nested conditions.\nlimit-inference-results=100\n\n# List of plugins (as comma separated values of python module names) to load,\n# usually to register additional checkers.\nload-plugins=\n\n# Pickle collected data for later comparisons.\npersistent=yes\n\n# Minimum Python version to use for version dependent checks. Will default to\n# the version used to run pylint.\npy-version=3.10\n\n# When enabled, pylint would attempt to guess common misconfiguration and emit\n# user-friendly hints instead of false-positive error messages.\nsuggestion-mode=yes\n\n# Allow loading of arbitrary C extensions. Extensions are imported into the\n# active Python interpreter and may run arbitrary code.\nunsafe-load-any-extension=no\n\n\n[MESSAGES CONTROL]\n\n# Only show warnings with the listed confidence levels. Leave empty to show\n# all. Valid levels: HIGH, INFERENCE, INFERENCE_FAILURE, UNDEFINED.\nconfidence=\n\n# Disable the message, report, category or checker with the given id(s). You\n# can either give multiple identifiers separated by comma (,) or put this\n# option multiple times (only on the command line, not in the configuration\n# file where it should appear only once). You can also use \"--disable=all\" to\n# disable everything first and then reenable specific checks. For example, if\n# you want to run only the similarities checker, you can use \"--disable=all\n# --enable=similarities\". If you want to run only the classes checker, but have\n# no Warning level messages displayed, use \"--disable=all --enable=classes\n# --disable=W\".\n; disable=invalid-name,\n;         disallowed-name,\n;         empty-docstring,\n;         missing-module-docstring,\n;         missing-class-docstring,\n;         missing-function-docstring,\n;         unidiomatic-typecheck,\n;         non-ascii-name,\n;         consider-using-enumerate,\n;         consider-iterating-dictionary,\n;         bad-classmethod-argument,\n;         bad-mcs-method-argument,\n;         bad-mcs-classmethod-argument,\n;         single-string-used-for-slots,\n;         consider-using-dict-items,\n;         use-maxsplit-arg,\n;         use-sequence-for-iteration,\n;         too-many-lines,\n;         missing-final-newline,\n;         trailing-newlines,\n;         superfluous-parens,\n;         mixed-line-endings,\n;         unexpected-line-ending-format,\n;         wrong-spelling-in-comment,\n;         wrong-spelling-in-docstring,\n;         invalid-characters-in-docstring,\n;         multiple-imports,\n;         wrong-import-order,\n;         ungrouped-imports,\n;         wrong-import-position,\n;         useless-import-alias,\n;         import-outside-toplevel,\n;         use-implicit-booleaness-not-len,\n;         use-implicit-booleaness-not-comparison,\n;         raw-checker-failed,\n;         bad-inline-option,\n;         locally-disabled,\n;         file-ignored,\n;         suppressed-message,\n;         useless-suppression,\n;         deprecated-pragma,\n;         use-symbolic-message-instead,\n;         c-extension-no-member,\n;         literal-comparison,\n;         comparison-with-itself,\n;         no-self-use,\n;         no-classmethod-decorator,\n;         no-staticmethod-decorator,\n;         useless-object-inheritance,\n;         property-with-parameters,\n;         cyclic-import,\n;         consider-using-from-import,\n;         duplicate-code,\n;         too-many-ancestors,\n;         too-many-instance-attributes,\n;         too-few-public-methods,\n;         too-many-public-methods,\n;         too-many-return-statements,\n;         too-many-branches,\n;         too-many-arguments,\n;         too-many-locals,\n;         too-many-statements,\n;         too-many-boolean-expressions,\n;         consider-merging-isinstance,\n;         too-many-nested-blocks,\n;         simplifiable-if-statement,\n;         redefined-argument-from-local,\n;         no-else-return,\n;         consider-using-ternary,\n;         trailing-comma-tuple,\n;         stop-iteration-return,\n;         simplify-boolean-expression,\n;         inconsistent-return-statements,\n;         useless-return,\n;         consider-swap-variables,\n;         consider-using-join,\n;         consider-using-in,\n;         consider-using-get,\n;         chained-comparison,\n;         consider-using-dict-comprehension,\n;         consider-using-set-comprehension,\n;         simplifiable-if-expression,\n;         no-else-raise,\n;         unnecessary-comprehension,\n;         consider-using-sys-exit,\n;         no-else-break,\n;         no-else-continue,\n;         super-with-arguments,\n;         simplifiable-condition,\n;         condition-evals-to-constant,\n;         consider-using-generator,\n;         use-a-generator,\n;         consider-using-min-builtin,\n;         consider-using-max-builtin,\n;         consider-using-with,\n;         unnecessary-dict-index-lookup,\n;         use-list-literal,\n;         use-dict-literal,\n;         pointless-statement,\n;         pointless-string-statement,\n;         expression-not-assigned,\n;         unnecessary-pass,\n;         unnecessary-lambda,\n;         assign-to-new-keyword,\n;         useless-else-on-loop,\n;         exec-used,\n;         eval-used,\n;         confusing-with-statement,\n;         using-constant-test,\n;         missing-parentheses-for-call-in-test,\n;         self-assigning-variable,\n;         redeclared-assigned-name,\n;         assert-on-string-literal,\n;         comparison-with-callable,\n;         lost-exception,\n;         nan-comparison,\n;         assert-on-tuple,\n;         attribute-defined-outside-init,\n;         bad-staticmethod-argument,\n;         protected-access,\n;         arguments-differ,\n;         signature-differs,\n;         abstract-method,\n;         super-init-not-called,\n;         no-init,\n;         non-parent-init-called,\n;         useless-super-delegation,\n;         invalid-overridden-method,\n;         arguments-renamed,\n;         unused-private-member,\n;         overridden-final-method,\n;         subclassed-final-class,\n;         bad-indentation,\n;         wildcard-import,\n;         deprecated-module,\n;         reimported,\n;         import-self,\n;         preferred-module,\n;         misplaced-future,\n;         fixme,\n;         global-variable-undefined,\n;         global-statement,\n;         global-at-module-level,\n;         unused-argument,\n;         unused-wildcard-import,\n;         redefined-outer-name,\n;         redefined-builtin,\n;         undefined-loop-variable,\n;         unbalanced-tuple-unpacking,\n;         cell-var-from-loop,\n;         possibly-unused-variable,\n;         self-cls-assignment,\n;         bare-except,\n;         broad-except,\n;         duplicate-except,\n;         try-except-raise,\n;         raise-missing-from,\n;         raising-format-tuple,\n;         wrong-exception-operation,\n;         keyword-arg-before-vararg,\n;         arguments-out-of-order,\n;         non-str-assignment-to-dunder-name,\n;         isinstance-second-argument-not-valid-type,\n;         logging-not-lazy,\n;         logging-format-interpolation,\n;         logging-fstring-interpolation,\n;         bad-format-string-key,\n;         unused-format-string-key,\n;         missing-format-argument-key,\n;         unused-format-string-argument,\n;         format-combined-specification,\n;         missing-format-attribute,\n;         invalid-format-index,\n;         duplicate-string-formatting-argument,\n;         f-string-without-interpolation,\n;         useless-with-lock\n\n# Enable the message, report, category or checker with the given id(s). You can\n# either give multiple identifier separated by comma (,) or put this option\n# multiple time (only on the command line, not in the configuration file where\n# it should appear only once). See also the \"--disable\" option for examples.\n; enable=unneeded-not,\n;         format-string-without-interpolation,\n;         anomalous-unicode-escape-in-string,\n;         implicit-str-concat,\n;         inconsistent-quotes,\n;         redundant-u-string-prefix,\n;         boolean-datetime,\n;         redundant-unittest-assert,\n;         deprecated-method,\n;         bad-thread-instantiation,\n;         shallow-copy-environ,\n;         invalid-envvar-default,\n;         subprocess-popen-preexec-fn,\n;         subprocess-run-check,\n;         deprecated-argument,\n;         deprecated-class,\n;         deprecated-decorator,\n;         unspecified-encoding,\n;         forgotten-debug-statement,\n;         using-f-string-in-unsupported-version,\n;         using-final-decorator-in-unsupported-version,\n;        singleton-comparison,\n;        consider-using-f-string,\n;        line-too-long,\n;        trailing-whitespace,\n;        multiple-statements,\n;        syntax-error,\n;        unrecognized-inline-option,\n;        bad-option-value,\n;        bad-plugin-value,\n;        bad-configuration-section,\n;        init-is-generator,\n;        return-in-init,\n;        function-redefined,\n;        not-in-loop,\n;        return-outside-function,\n;        yield-outside-function,\n;        return-arg-in-generator,\n;        nonexistent-operator,\n;        duplicate-argument-name,\n;        abstract-class-instantiated,\n;        bad-reversed-sequence,\n;        too-many-star-expressions,\n;        invalid-star-assignment-target,\n;        star-needs-assignment-target,\n;        nonlocal-and-global,\n;        continue-in-finally,\n;        nonlocal-without-binding,\n;        used-prior-global-declaration,\n;        misplaced-format-function,\n;        method-hidden,\n;        access-member-before-definition,\n;        no-method-argument,\n;        no-self-argument,\n;        invalid-slots-object,\n;        assigning-non-slot,\n;        invalid-slots,\n;        inherit-non-class,\n;        inconsistent-mro,\n;        duplicate-bases,\n;        class-variable-slots-conflict,\n;        invalid-class-object,\n;        non-iterator-returned,\n;        unexpected-special-method-signature,\n;        invalid-length-returned,\n;        invalid-bool-returned,\n;        invalid-index-returned,\n;        invalid-repr-returned,\n;        invalid-str-returned,\n;        invalid-bytes-returned,\n;        invalid-hash-returned,\n;        invalid-length-hint-returned,\n;        invalid-format-returned,\n;        invalid-getnewargs-returned,\n;        invalid-getnewargs-ex-returned,\n;        import-error,\n;        relative-beyond-top-level,\n;        used-before-assignment,\n;        undefined-variable,\n;        undefined-all-variable,\n;        invalid-all-object,\n;        invalid-all-format,\n;        no-name-in-module,\n;        unpacking-non-sequence,\n;        bad-except-order,\n;        raising-bad-type,\n;        bad-exception-context,\n;        misplaced-bare-raise,\n;        raising-non-exception,\n;        notimplemented-raised,\n;        catching-non-exception,\n;        bad-super-call,\n;        no-member,\n;        not-callable,\n;        assignment-from-no-return,\n;        no-value-for-parameter,\n;        too-many-function-args,\n;        unexpected-keyword-arg,\n;        redundant-keyword-arg,\n;        missing-kwoa,\n;        invalid-sequence-index,\n;        invalid-slice-index,\n;        assignment-from-none,\n;        not-context-manager,\n;        invalid-unary-operand-type,\n;        unsupported-binary-operation,\n;        repeated-keyword,\n;        not-an-iterable,\n;        not-a-mapping,\n;        unsupported-membership-test,\n;        unsubscriptable-object,\n;        unsupported-assignment-operation,\n;        unsupported-delete-operation,\n;        invalid-metaclass,\n;        unhashable-dict-key,\n;        dict-iter-missing-items,\n;        await-outside-async,\n;        logging-unsupported-format,\n;        logging-format-truncated,\n;        logging-too-many-args,\n;        logging-too-few-args,\n;        bad-format-character,\n;        truncated-format-string,\n;        mixed-format-string,\n;        format-needs-mapping,\n;        missing-format-string-key,\n;        too-many-format-args,\n;        too-few-format-args,\n;        bad-string-format-type,\n;        bad-str-strip-call,\n;        invalid-envvar-value,\n;        yield-inside-async-function,\n;        not-async-context-manager,\n;        fatal,\n;        astroid-error,\n;        parse-error,\n;        config-parse-error,\n;        method-check-failed,\n;        unreachable,\n;        dangerous-default-value,\n;        duplicate-key,\n;        unnecessary-semicolon,\n;        global-variable-not-assigned,\n;        unused-import,\n;        unused-variable,\n;        binary-op-exception,\n;        bad-format-string,\n;        anomalous-backslash-in-string,\n;        bad-open-mode\n\nenable =\n      F,\n      E,\n      anomalous-backslash-in-string,\n      bad-format-string,\n      bad-open-mode,\n      consider-using-f-string,\n      dangerous-default-value,\n      duplicate-key,\n      global-variable-not-assigned\n      line-too-long,\n      singleton-comparison,\n      trailing-whitespace,\n      unnecessary-semicolon,\n      unneeded-not,\n      unreachable,\n      unused-import,\n      unused-variable,\n      binary-op-exception\ndisable = all\n\n[REPORTS]\n\n# Python expression which should return a score less than or equal to 10. You\n# have access to the variables 'error', 'warning', 'refactor', and 'convention'\n# which contain the number of messages in each category, as well as 'statement'\n# which is the total number of statements analyzed. This score is used by the\n# global evaluation report (RP0004).\nevaluation=10.0 - ((float(5 * error + warning + refactor + convention) / statement) * 10)\n\n# Template used to display messages. This is a python new-style format string\n# used to format the message information. See doc for all details.\n#msg-template=\n\n# Set the output format. Available formats are text, parseable, colorized, json\n# and msvs (visual studio). You can also give a reporter class, e.g.\n# mypackage.mymodule.MyReporterClass.\noutput-format=text\n\n# Tells whether to display a full report or only the messages.\nreports=no\n\n# Activate the evaluation score.\nscore=yes\n\n\n[REFACTORING]\n\n# Maximum number of nested blocks for function / method body\nmax-nested-blocks=5\n\n# Complete name of functions that never returns. When checking for\n# inconsistent-return-statements if a never returning function is called then\n# it will be considered as an explicit return statement and no message will be\n# printed.\nnever-returning-functions=sys.exit,argparse.parse_error\n\n\n[FORMAT]\n\n# Expected format of line ending, e.g. empty (any line ending), LF or CRLF.\nexpected-line-ending-format=LF\n\n# Regexp for a line that is allowed to be longer than the limit.\nignore-long-lines=^\\s*(# )?<?https?://\\S+>?$\n\n# Number of spaces of indent required inside a hanging or continued line.\nindent-after-paren=4\n\n# String used as indentation unit. This is usually \"    \" (4 spaces) or \"\\t\" (1\n# tab).\nindent-string='    '\n\n# Maximum number of characters on a single line.\nmax-line-length=200\n\n# Maximum number of lines in a module.\nmax-module-lines=15000\n\n# Allow the body of a class to be on the same line as the declaration if body\n# contains single statement.\nsingle-line-class-stmt=no\n\n# Allow the body of an if to be on the same line as the test if there is no\n# else.\nsingle-line-if-stmt=no\n\n\n[SPELLING]\n\n# Limits count of emitted suggestions for spelling mistakes.\nmax-spelling-suggestions=4\n\n# Spelling dictionary name. Available dictionaries: none. To make it work,\n# install the 'python-enchant' package.\nspelling-dict=\n\n# List of comma separated words that should be considered directives if they\n# appear and the beginning of a comment and should not be checked.\nspelling-ignore-comment-directives=fmt: on,fmt: off,noqa:,noqa,nosec,isort:skip,mypy:\n\n# List of comma separated words that should not be checked.\nspelling-ignore-words=\n\n# A path to a file that contains the private dictionary; one word per line.\nspelling-private-dict-file=\n\n# Tells whether to store unknown words to the private dictionary (see the\n# --spelling-private-dict-file option) instead of raising a message.\nspelling-store-unknown-words=no\n\n\n[LOGGING]\n\n# The type of string formatting that logging methods do. `old` means using %\n# formatting, `new` is for `{}` formatting.\nlogging-format-style=old\n\n# Logging modules to check that the string format arguments are in logging\n# function parameter format.\nlogging-modules=logging\n\n\n[VARIABLES]\n\n# List of additional names supposed to be defined in builtins. Remember that\n# you should avoid defining new builtins when possible.\nadditional-builtins=\n\n# Tells whether unused global variables should be treated as a violation.\nallow-global-unused-variables=yes\n\n# List of names allowed to shadow builtins\nallowed-redefined-builtins=\n\n# List of strings which can identify a callback function by name. A callback\n# name must start or end with one of those strings.\ncallbacks=cb_,\n          _cb\n\n# A regular expression matching the name of dummy variables (i.e. expected to\n# not be used).\ndummy-variables-rgx=_+$|(_[a-zA-Z0-9_]*[a-zA-Z0-9]+?$)|dummy|^ignored_|^unused_\n\n# Argument names that match this expression will be ignored. Default to name\n# with leading underscore.\nignored-argument-names=_.*|^ignored_|^unused_\n\n# Tells whether we should check for unused import in __init__ files.\ninit-import=no\n\n# List of qualified module names which can have objects that can redefine\n# builtins.\nredefining-builtins-modules=six.moves,past.builtins,future.builtins,builtins,io\n\n\n[SIMILARITIES]\n\n# Comments are removed from the similarity computation\nignore-comments=yes\n\n# Docstrings are removed from the similarity computation\nignore-docstrings=yes\n\n# Imports are removed from the similarity computation\nignore-imports=no\n\n# Signatures are removed from the similarity computation\nignore-signatures=no\n\n# Minimum lines number of a similarity.\nmin-similarity-lines=4\n\n\n[MISCELLANEOUS]\n\n# List of note tags to take in consideration, separated by a comma.\nnotes=FIXME,\n      XXX,\n      TODO\n\n# Regular expression of note tags to take in consideration.\n#notes-rgx=\n\n\n[BASIC]\n\n# Naming style matching correct argument names.\nargument-naming-style=snake_case\n\n# Regular expression matching correct argument names. Overrides argument-\n# naming-style.\n#argument-rgx=\n\n# Naming style matching correct attribute names.\nattr-naming-style=snake_case\n\n# Regular expression matching correct attribute names. Overrides attr-naming-\n# style.\n#attr-rgx=\n\n# Bad variable names which should always be refused, separated by a comma.\nbad-names=foo,\n          bar,\n          baz,\n          toto,\n          tutu,\n          tata\n\n# Bad variable names regexes, separated by a comma. If names match any regex,\n# they will always be refused\nbad-names-rgxs=\n\n# Naming style matching correct class attribute names.\nclass-attribute-naming-style=any\n\n# Regular expression matching correct class attribute names. Overrides class-\n# attribute-naming-style.\n#class-attribute-rgx=\n\n# Naming style matching correct class constant names.\nclass-const-naming-style=UPPER_CASE\n\n# Regular expression matching correct class constant names. Overrides class-\n# const-naming-style.\n#class-const-rgx=\n\n# Naming style matching correct class names.\nclass-naming-style=PascalCase\n\n# Regular expression matching correct class names. Overrides class-naming-\n# style.\n#class-rgx=\n\n# Naming style matching correct constant names.\nconst-naming-style=UPPER_CASE\n\n# Regular expression matching correct constant names. Overrides const-naming-\n# style.\n#const-rgx=\n\n# Minimum line length for functions/classes that require docstrings, shorter\n# ones are exempt.\ndocstring-min-length=-1\n\n# Naming style matching correct function names.\nfunction-naming-style=snake_case\n\n# Regular expression matching correct function names. Overrides function-\n# naming-style.\n#function-rgx=\n\n# Good variable names which should always be accepted, separated by a comma.\ngood-names=i,\n           j,\n           k,\n           ex,\n           Run,\n           _\n\n# Good variable names regexes, separated by a comma. If names match any regex,\n# they will always be accepted\ngood-names-rgxs=\n\n# Include a hint for the correct naming format with invalid-name.\ninclude-naming-hint=no\n\n# Naming style matching correct inline iteration names.\ninlinevar-naming-style=any\n\n# Regular expression matching correct inline iteration names. Overrides\n# inlinevar-naming-style.\n#inlinevar-rgx=\n\n# Naming style matching correct method names.\nmethod-naming-style=snake_case\n\n# Regular expression matching correct method names. Overrides method-naming-\n# style.\n#method-rgx=\n\n# Naming style matching correct module names.\nmodule-naming-style=snake_case\n\n# Regular expression matching correct module names. Overrides module-naming-\n# style.\n#module-rgx=\n\n# Colon-delimited sets of names that determine each other's naming style when\n# the name regexes allow several styles.\nname-group=\n\n# Regular expression which should only match function or class names that do\n# not require a docstring.\nno-docstring-rgx=^_\n\n# List of decorators that produce properties, such as abc.abstractproperty. Add\n# to this list to register other decorators that produce valid properties.\n# These decorators are taken in consideration only for invalid-name.\nproperty-classes=abc.abstractproperty\n\n# Naming style matching correct variable names.\nvariable-naming-style=snake_case\n\n# Regular expression matching correct variable names. Overrides variable-\n# naming-style.\n#variable-rgx=\n\n\n[STRING]\n\n# This flag controls whether inconsistent-quotes generates a warning when the\n# character used as a quote delimiter is used inconsistently within a module.\ncheck-quote-consistency=no\n\n# This flag controls whether the implicit-str-concat should generate a warning\n# on implicit string concatenation in sequences defined over several lines.\ncheck-str-concat-over-line-jumps=no\n\n\n[TYPECHECK]\n\n# List of decorators that produce context managers, such as\n# contextlib.contextmanager. Add to this list to register other decorators that\n# produce valid context managers.\ncontextmanager-decorators=contextlib.contextmanager\n\n# List of members which are set dynamically and missed by pylint inference\n# system, and so shouldn't trigger E1101 when accessed. Python regular\n# expressions are accepted.\ngenerated-members=\n\n# Tells whether missing members accessed in mixin class should be ignored. A\n# class is considered mixin if its name matches the mixin-class-rgx option.\nignore-mixin-members=yes\n\n# Tells whether to warn about missing members when the owner of the attribute\n# is inferred to be None.\nignore-none=yes\n\n# This flag controls whether pylint should warn about no-member and similar\n# checks whenever an opaque object is returned when inferring. The inference\n# can return multiple potential results while evaluating a Python object, but\n# some branches might not be evaluated, which results in partial inference. In\n# that case, it might be useful to still emit no-member and other checks for\n# the rest of the inferred objects.\nignore-on-opaque-inference=yes\n\n# List of class names for which member attributes should not be checked (useful\n# for classes with dynamically set attributes). This supports the use of\n# qualified names.\nignored-classes=optparse.Values,thread._local,_thread._local\n\n# List of module names for which member attributes should not be checked\n# (useful for modules/projects where namespaces are manipulated during runtime\n# and thus existing member attributes cannot be deduced by static analysis). It\n# supports qualified module names, as well as Unix pattern matching.\nignored-modules=\n\n# Show a hint with possible names when a member name was not found. The aspect\n# of finding the hint is based on edit distance.\nmissing-member-hint=yes\n\n# The minimum edit distance a name should have in order to be considered a\n# similar match for a missing member name.\nmissing-member-hint-distance=1\n\n# The total number of similar names that should be taken in consideration when\n# showing a hint for a missing member.\nmissing-member-max-choices=1\n\n# Regex pattern to define which classes are considered mixins ignore-mixin-\n# members is set to 'yes'\nmixin-class-rgx=.*[Mm]ixin\n\n# List of decorators that change the signature of a decorated function.\nsignature-mutators=\n\n\n[IMPORTS]\n\n# List of modules that can be imported at any level, not just the top level\n# one.\nallow-any-import-level=\n\n# Allow wildcard imports from modules that define __all__.\nallow-wildcard-with-all=no\n\n# Analyse import fallback blocks. This can be used to support both Python 2 and\n# 3 compatible code, which means that the block might have code that exists\n# only in one or another interpreter, leading to false positives when analysed.\nanalyse-fallback-blocks=no\n\n# Deprecated modules which should not be used, separated by a comma.\ndeprecated-modules=\n\n# Output a graph (.gv or any supported image format) of external dependencies\n# to the given file (report RP0402 must not be disabled).\next-import-graph=\n\n# Output a graph (.gv or any supported image format) of all (i.e. internal and\n# external) dependencies to the given file (report RP0402 must not be\n# disabled).\nimport-graph=\n\n# Output a graph (.gv or any supported image format) of internal dependencies\n# to the given file (report RP0402 must not be disabled).\nint-import-graph=\n\n# Force import order to recognize a module as part of the standard\n# compatibility libraries.\nknown-standard-library=\n\n# Force import order to recognize a module as part of a third party library.\nknown-third-party=enchant\n\n# Couples of modules and preferred modules, separated by a comma.\npreferred-modules=\n\n\n[DESIGN]\n\n# List of regular expressions of class ancestor names to ignore when counting\n# public methods (see R0903)\nexclude-too-few-public-methods=\n\n# List of qualified class names to ignore when counting class parents (see\n# R0901)\nignored-parents=\n\n# Maximum number of arguments for function / method.\nmax-args=5\n\n# Maximum number of attributes for a class (see R0902).\nmax-attributes=7\n\n# Maximum number of boolean expressions in an if statement (see R0916).\nmax-bool-expr=5\n\n# Maximum number of branch for function / method body.\nmax-branches=12\n\n# Maximum number of locals for function / method body.\nmax-locals=15\n\n# Maximum number of parents for a class (see R0901).\nmax-parents=7\n\n# Maximum number of public methods for a class (see R0904).\nmax-public-methods=20\n\n# Maximum number of return / yield for function / method body.\nmax-returns=6\n\n# Maximum number of statements in function / method body.\nmax-statements=50\n\n# Minimum number of public methods for a class (see R0903).\nmin-public-methods=2\n\n\n[CLASSES]\n\n# Warn about protected attribute access inside special methods\ncheck-protected-access-in-special-methods=no\n\n# List of method names used to declare (i.e. assign) instance attributes.\ndefining-attr-methods=__init__,\n                      __new__,\n                      setUp,\n                      __post_init__\n\n# List of member names, which should be excluded from the protected access\n# warning.\nexclude-protected=_asdict,\n                  _fields,\n                  _replace,\n                  _source,\n                  _make\n\n# List of valid names for the first argument in a class method.\nvalid-classmethod-first-arg=cls\n\n# List of valid names for the first argument in a metaclass class method.\nvalid-metaclass-classmethod-first-arg=cls\n\n\n[EXCEPTIONS]\n\n# Exceptions that will emit a warning when being caught. Defaults to\n# \"BaseException, Exception\".\novergeneral-exceptions=BaseException,\n                       Exception\n"
        },
        {
          "name": ".python-version",
          "type": "blob",
          "size": 0.0078125,
          "content": "3.10.14\n"
        },
        {
          "name": ".readthedocs.yml",
          "type": "blob",
          "size": 0.2060546875,
          "content": "version: 2\n\nmkdocs:\n  configuration: docs/obsolete/mkdocs.yml\n  fail_on_warning: false\n\nformats: all\n\nbuild:\n  image: latest\n\npython:\n  version: 3.7\n  install:\n    - requirements: docs/obsolete/requirements.txt\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0595703125,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2013-2024 crazy rabbidz\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 4.6005859375,
          "content": "<p align=\"center\">\n  <img src=\"https://i.imgur.com/o0L8lPN.png\" alt=\"logo\"/>\n</p>\n\n<p align=\"center\">\n    <a href=\"https://discord.gg/hSbqxxBgRX\"><img alt=\"Discord\" src=\"https://img.shields.io/badge/Discord-BlahCats-yellow\"></a>\n  <a href=\"https://hugsy.github.io/gef\"><img alt=\"Docs\" src=\"https://img.shields.io/badge/Docs-gh--pages-brightgreen\"></a>\n  <a title=\"Use the IDs: gef/gef-demo\" href=\"https://demo.gef.blah.cat\"><img alt=\"Try GEF\" src=\"https://img.shields.io/badge/Demo-Try%20GEF%20Live-blue\"></a>\n</p>\n\n`GEF` (pronounced ʤɛf - \"Jeff\") is a set of commands for x86/64, ARM, MIPS, PowerPC and SPARC to\nassist exploit developers and reverse-engineers when using old school GDB. It provides additional\nfeatures to GDB using the Python API to assist during the process of dynamic analysis and exploit\ndevelopment. Application developers will also benefit from it, as GEF lifts a great part of regular\nGDB obscurity, avoiding repeating traditional commands, or bringing out the relevant information\nfrom the debugging runtime.\n\n## Instant Setup\n\nSimply make sure you have [GDB 10.0 or higher](https://www.gnu.org/s/gdb) compiled with Python3.10+\nbindings, then:\n\n```bash\n# via the install script\n## using curl\n$ bash -c \"$(curl -fsSL https://gef.blah.cat/sh)\"\n\n## using wget\n$ bash -c \"$(wget https://gef.blah.cat/sh -O -)\"\n\n# or manually\n$ wget -O ~/.gdbinit-gef.py -q https://gef.blah.cat/py\n$ echo source ~/.gdbinit-gef.py >> ~/.gdbinit\n\n# or alternatively from inside gdb directly\n$ gdb -q\n(gdb) pi import urllib.request as u, tempfile as t; g=t.NamedTemporaryFile(suffix='-gef.py'); open(g.name, 'wb+').write(u.urlopen('https://tinyurl.com/gef-main').read()); gdb.execute('source %s' % g.name)\n```\n\nYou can immediately see that GEF is correctly installed by launching GDB:\n\n![gef-context](https://i.imgur.com/E3EuQPs.png)\n\nA few of `GEF` features include:\n\n*  **One** single GDB script\n*  Entirely **architecture agnostic**, **NO** dependencies: `GEF` is battery-included and [is\n  installable instantly](https://hugsy.github.io/gef/#setup)\n*  **Fast** limiting the number of dependencies and optimizing code to make the commands as fast as\n  possible\n*  Provides a great variety of commands to drastically change your experience in GDB.\n*  [**Easily** extensible](https://hugsy.github.io/gef/api/) to create other commands by providing\nd more comprehensible layout to GDB Python API.\n*  Full Python3 support ([Python2 support was\n  dropped](https://github.com/hugsy/gef/releases/tag/2020.03) - see\n  [`gef-legacy`](https://github.com/hugsy/gef-legacy)).\n*  Built around an architecture abstraction layer, so all commands work in any GDB-supported\n  architecture such as x86-32/64, ARMv5/6/7, AARCH64, SPARC, MIPS, PowerPC, etc.\n* Suited for real-life apps debugging, exploit development, just as much as CTF\n* And a lot more commands contributed by the community available on\n  [GEF-Extras](https://github.com/hugsy/gef-extras) !!\n\nCheck out the [Screenshot page](docs/screenshots.md) for more or [try it\nonline](https://demo.gef.blah.cat) (user:`gef`/password:`gef-demo`)\n\n## Documentation\n\nUnlike other GDB plugins, GEF has an extensive and up-to-date\n[documentation](https://hugsy.github.io/gef/). Users are recommended to refer to it as it may help\nthem in their attempts to use GEF. In particular, new users should navigate through it (see the\n[FAQ](https://hugsy.github.io/gef/faq/) for common installation problems), and the problem persists,\ntry to reach out for help on the Discord channel or submit an issue.\n\n## Current status\n\n| Documentation |License | Compatibility | CI Tests (`main`) |\n|:---:|:---:|:---|--|\n| [![Documentation](https://github.com/hugsy/gef/actions/workflows/generate-docs.yml/badge.svg)](https://github.com/hugsy/gef/actions/workflows/generate-docs.yml) | [![MIT](https://img.shields.io/packagist/l/doctrine/orm.svg?maxAge=2592000?style=plastic)](https://github.com/hugsy/gef/blob/main/LICENSE) | [![Python 3](https://img.shields.io/badge/Python-3-green.svg)](https://github.com/hugsy/gef/) | [![CI Test for GEF](https://github.com/hugsy/gef/actions/workflows/run-tests.yml/badge.svg)](https://github.com/hugsy/gef/actions/workflows/run-tests.yml) |\n\n## Contribute\n\nTo get involved, refer to the [Contribution\ndocumentation](https://hugsy.github.io/gef/#contribution) and the\n[guidelines](https://github.com/hugsy/gef/blob/main/.github/CONTRIBUTING.md) to start.\n\n## Sponsors\n\nAnother way to contribute to keeping the project alive is by sponsoring it! Check out [the\nsponsoring documentation](https://hugsy.github.io/gef/#sponsors) for details so you can be part of\nthe list of those [awesome sponsors](https://github.com/sponsors/hugsy).\n\n## Happy Hacking 🍻\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "gef.py",
          "type": "blob",
          "size": 422.13671875,
          "content": "#######################################################################################\n# GEF - Multi-Architecture GDB Enhanced Features for Exploiters & Reverse-Engineers\n#\n# by  @_hugsy_\n#######################################################################################\n#\n# GEF is a kick-ass set of commands for X86, ARM, MIPS, PowerPC and SPARC to\n# make GDB cool again for exploit dev. It is aimed to be used mostly by exploit\n# devs and reversers, to provides additional features to GDB using the Python\n# API to assist during the process of dynamic analysis.\n#\n# GEF fully relies on GDB API and other Linux-specific sources of information\n# (such as /proc/<pid>). As a consequence, some of the features might not work\n# on custom or hardened systems such as GrSec.\n#\n# Since January 2020, GEF solely support GDB compiled with Python3 and was tested on\n#   * x86-32 & x86-64\n#   * arm v5,v6,v7\n#   * aarch64 (armv8)\n#   * mips & mips64\n#   * powerpc & powerpc64\n#   * sparc & sparc64(v9)\n#\n# For GEF with Python2 (only) support was moved to the GEF-Legacy\n# (https://github.com/hugsy/gef-legacy)\n#\n# To start: in gdb, type `source /path/to/gef.py`\n#\n#######################################################################################\n#\n# gef is distributed under the MIT License (MIT)\n# Copyright (c) 2013-2024 crazy rabbidz\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in all\n# copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n# SOFTWARE.\n\nimport abc\nimport argparse\nimport ast\nimport atexit\nimport binascii\nimport codecs\nimport collections\nimport configparser\nimport ctypes\nimport enum\nimport functools\nimport hashlib\nimport importlib\nimport importlib.util\nimport inspect\nimport itertools\nimport os\nimport pathlib\nimport platform\nimport re\nimport shutil\nimport socket\nimport string\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport warnings\nfrom functools import lru_cache\nfrom io import StringIO, TextIOWrapper\nfrom types import ModuleType\nfrom typing import (Any, ByteString, Callable, Generator, Iterable, Iterator,\n                    NoReturn, Sequence, Type, TypeVar, cast)\nfrom urllib.request import urlopen\n\n\nGEF_DEFAULT_BRANCH                     = \"main\"\nGEF_EXTRAS_DEFAULT_BRANCH              = \"main\"\n\ndef http_get(url: str) -> bytes | None:\n    \"\"\"Basic HTTP wrapper for GET request. Return the body of the page if HTTP code is OK,\n    otherwise return None.\"\"\"\n    try:\n        http = urlopen(url)\n        return http.read() if http.getcode() == 200 else None\n    except Exception:\n        return None\n\n\ndef update_gef(argv: list[str]) -> int:\n    \"\"\"Obsolete. Use `gef.sh`.\"\"\"\n    return -1\n\n\ntry:\n    import gdb  # type:ignore\nexcept ImportError:\n    if len(sys.argv) >= 2 and sys.argv[1].lower() in (\"--update\", \"--upgrade\"):\n        print(\"[-] `update_gef` is obsolete. Use the `gef.sh` script to update gef from the command line.\")\n    print(\"[-] gef cannot run as standalone\")\n    sys.exit(1)\n\n\nGDB_MIN_VERSION: tuple[int, int]       = (10, 0)\nPYTHON_MIN_VERSION: tuple[int, int]    = (3, 10)\nPYTHON_VERSION: tuple[int, int]        = sys.version_info[0:2]\nGDB_VERSION: tuple[int, int]           = tuple(map(int, re.search(r\"(\\d+)[^\\d]+(\\d+)\", gdb.VERSION).groups())) # type:ignore\n\nDEFAULT_PAGE_ALIGN_SHIFT               = 12\nDEFAULT_PAGE_SIZE                      = 1 << DEFAULT_PAGE_ALIGN_SHIFT\n\nGEF_RC                                 = (pathlib.Path(os.getenv(\"GEF_RC\", \"\")).absolute()\n                                          if os.getenv(\"GEF_RC\")\n                                          else pathlib.Path().home() / \".gef.rc\")\nGEF_TEMP_DIR                           = pathlib.Path(tempfile.gettempdir())/ \"gef\"\nGEF_MAX_STRING_LENGTH                  = 50\n\nLIBC_HEAP_MAIN_ARENA_DEFAULT_NAME      = \"main_arena\"\nANSI_SPLIT_RE                          = r\"(\\033\\[[\\d;]*m)\"\n\nLEFT_ARROW                             = \" ← \"\nRIGHT_ARROW                            = \" → \"\nDOWN_ARROW                             = \"↳\"\nHORIZONTAL_LINE                        = \"─\"\nVERTICAL_LINE                          = \"│\"\nCROSS                                  = \"✘ \"\nTICK                                   = \"✓ \"\nBP_GLYPH                               = \"●\"\nGEF_PROMPT                             = \"gef➤  \"\nGEF_PROMPT_ON                          = f\"\\001\\033[1;32m\\002{GEF_PROMPT}\\001\\033[0m\\002\"\nGEF_PROMPT_OFF                         = f\"\\001\\033[1;31m\\002{GEF_PROMPT}\\001\\033[0m\\002\"\n\n__registered_commands__ : set[Type[\"GenericCommand\"]]                               = set()\n__registered_functions__ : set[Type[\"GenericFunction\"]]                             = set()\n__registered_architectures__ : dict[\"Elf.Abi | str\", Type[\"Architecture\"]]          = {}\n__registered_file_formats__ : set[ Type[\"FileFormat\"] ]                             = set()\n\nGefMemoryMapProvider = Callable[[], Generator[\"Section\", None, None]]\n\n\ndef reset_all_caches() -> None:\n    \"\"\"Free all caches. If an object is cached, it will have a callable attribute `cache_clear`\n    which will be invoked to purge the function cache.\"\"\"\n\n    for mod in dir(sys.modules[\"__main__\"]):\n        obj = getattr(sys.modules[\"__main__\"], mod)\n        if hasattr(obj, \"cache_clear\"):\n            obj.cache_clear()\n\n    gef.reset_caches()\n    return\n\n\ndef reset() -> None:\n    global gef\n\n    arch = None\n    if \"gef\" in locals().keys():\n        reset_all_caches()\n        arch = gef.arch\n        del gef\n\n    gef = Gef()\n    gef.setup()\n\n    if arch:\n        gef.arch = arch\n    return\n\n\ndef highlight_text(text: str) -> str:\n    \"\"\"\n    Highlight text using `gef.ui.highlight_table` { match -> color } settings.\n\n    If RegEx is enabled it will create a match group around all items in the\n    `gef.ui.highlight_table` and wrap the specified color in the `gef.ui.highlight_table`\n    around those matches.\n\n    If RegEx is disabled, split by ANSI codes and 'colorify' each match found\n    within the specified string.\n    \"\"\"\n    global gef\n\n    if not gef.ui.highlight_table:\n        return text\n\n    if gef.config[\"highlight.regex\"]:\n        for match, color in gef.ui.highlight_table.items():\n            text = re.sub(\"(\" + match + \")\", Color.colorify(\"\\\\1\", color), text)\n        return text\n\n    ansiSplit = re.split(ANSI_SPLIT_RE, text)\n\n    for match, color in gef.ui.highlight_table.items():\n        for index, val in enumerate(ansiSplit):\n            found = val.find(match)\n            if found > -1:\n                ansiSplit[index] = val.replace(match, Color.colorify(match, color))\n                break\n        text = \"\".join(ansiSplit)\n        ansiSplit = re.split(ANSI_SPLIT_RE, text)\n\n    return \"\".join(ansiSplit)\n\n\ndef gef_print(*args: str, end=\"\\n\", sep=\" \", **kwargs: Any) -> None:\n    \"\"\"Wrapper around print(), using string buffering feature.\"\"\"\n    parts = [highlight_text(a) for a in args]\n    if buffer_output() and gef.ui.stream_buffer and not is_debug():\n        gef.ui.stream_buffer.write(sep.join(parts) + end)\n        return\n\n    print(*parts, sep=sep, end=end, **kwargs)\n    return\n\n\ndef bufferize(f: Callable) -> Callable:\n    \"\"\"Store the content to be printed for a function in memory, and flush it on function exit.\"\"\"\n\n    @functools.wraps(f)\n    def wrapper(*args: Any, **kwargs: Any) -> Any:\n        global gef\n\n        if gef.ui.stream_buffer:\n            return f(*args, **kwargs)\n\n        gef.ui.stream_buffer = StringIO()\n        try:\n            rv = f(*args, **kwargs)\n        finally:\n            redirect = gef.config[\"context.redirect\"]\n            if redirect.startswith(\"/dev/pts/\"):\n                if not gef.ui.redirect_fd:\n                    # if the FD has never been open, open it\n                    fd = open(redirect, \"wt\")\n                    gef.ui.redirect_fd = fd\n                elif redirect != gef.ui.redirect_fd.name:\n                    # if the user has changed the redirect setting during runtime, update the state\n                    gef.ui.redirect_fd.close()\n                    fd = open(redirect, \"wt\")\n                    gef.ui.redirect_fd = fd\n                else:\n                    # otherwise, keep using it\n                    fd = gef.ui.redirect_fd\n            else:\n                fd = sys.stdout\n                gef.ui.redirect_fd = None\n\n            if gef.ui.redirect_fd and fd.closed:\n                # if the tty was closed, revert back to stdout\n                fd = sys.stdout\n                gef.ui.redirect_fd = None\n                gef.config[\"context.redirect\"] = \"\"\n\n            fd.write(gef.ui.stream_buffer.getvalue())\n            fd.flush()\n            gef.ui.stream_buffer = None\n        return rv\n\n    return wrapper\n\n\nclass ValidationError(Exception): pass\n\n#\n# Helpers\n#\n\nclass ObsoleteException(Exception): pass\n\nclass AlreadyRegisteredException(Exception): pass\n\ndef p8(x: int, s: bool = False, e: \"Endianness | None\" = None) -> bytes:\n    \"\"\"Pack one byte respecting the current architecture endianness.\"\"\"\n    endian = e or gef.arch.endianness\n    return struct.pack(f\"{endian}B\", x) if not s else struct.pack(f\"{endian:s}b\", x)\n\n\ndef p16(x: int, s: bool = False, e: \"Endianness | None\" = None) -> bytes:\n    \"\"\"Pack one word respecting the current architecture endianness.\"\"\"\n    endian = e or gef.arch.endianness\n    return struct.pack(f\"{endian}H\", x) if not s else struct.pack(f\"{endian:s}h\", x)\n\n\ndef p32(x: int, s: bool = False, e: \"Endianness | None\" = None) -> bytes:\n    \"\"\"Pack one dword respecting the current architecture endianness.\"\"\"\n    endian = e or gef.arch.endianness\n    return struct.pack(f\"{endian}I\", x) if not s else struct.pack(f\"{endian:s}i\", x)\n\n\ndef p64(x: int, s: bool = False, e: \"Endianness | None\" = None) -> bytes:\n    \"\"\"Pack one qword respecting the current architecture endianness.\"\"\"\n    endian = e or gef.arch.endianness\n    return struct.pack(f\"{endian}Q\", x) if not s else struct.pack(f\"{endian:s}q\", x)\n\n\ndef u8(x: bytes, s: bool = False, e: \"Endianness | None\" = None) -> int:\n    \"\"\"Unpack one byte respecting the current architecture endianness.\"\"\"\n    endian = e or gef.arch.endianness\n    return struct.unpack(f\"{endian}B\", x)[0] if not s else struct.unpack(f\"{endian:s}b\", x)[0]\n\n\ndef u16(x: bytes, s: bool = False, e: \"Endianness | None\" = None) -> int:\n    \"\"\"Unpack one word respecting the current architecture endianness.\"\"\"\n    endian = e or gef.arch.endianness\n    return struct.unpack(f\"{endian}H\", x)[0] if not s else struct.unpack(f\"{endian:s}h\", x)[0]\n\n\ndef u32(x: bytes, s: bool = False, e: \"Endianness | None\" = None) -> int:\n    \"\"\"Unpack one dword respecting the current architecture endianness.\"\"\"\n    endian = e or gef.arch.endianness\n    return struct.unpack(f\"{endian}I\", x)[0] if not s else struct.unpack(f\"{endian:s}i\", x)[0]\n\n\ndef u64(x: bytes, s: bool = False, e: \"Endianness | None\" = None) -> int:\n    \"\"\"Unpack one qword respecting the current architecture endianness.\"\"\"\n    endian = e or gef.arch.endianness\n    return struct.unpack(f\"{endian}Q\", x)[0] if not s else struct.unpack(f\"{endian:s}q\", x)[0]\n\n\ndef is_ascii_string(address: int) -> bool:\n    \"\"\"Helper function to determine if the buffer pointed by `address` is an ASCII string (in GDB)\"\"\"\n    try:\n        return gef.memory.read_ascii_string(address) is not None\n    except Exception:\n        return False\n\n\ndef is_alive() -> bool:\n    \"\"\"Check if GDB is running.\"\"\"\n    try:\n        return gdb.selected_inferior().pid > 0\n    except Exception:\n        return False\n\n\ndef calling_function() -> str | None:\n    \"\"\"Return the name of the calling function\"\"\"\n    try:\n        stack_info = traceback.extract_stack()[-3]\n        return stack_info.name\n    except Exception as e:\n        dbg(f\"traceback failed with {str(e)}\")\n        return None\n\n\n#\n# Decorators\n#\ndef only_if_gdb_running(f: Callable) -> Callable:\n    \"\"\"Decorator wrapper to check if GDB is running.\"\"\"\n    @functools.wraps(f)\n    def wrapper(*args: Any, **kwargs: Any) -> Any:\n        if is_alive():\n            return f(*args, **kwargs)\n        else:\n            warn(\"No debugging session active\")\n\n    return wrapper\n\n\ndef only_if_gdb_target_local(f: Callable) -> Callable:\n    \"\"\"Decorator wrapper to check if GDB is running locally (target not remote).\"\"\"\n\n    @functools.wraps(f)\n    def wrapper(*args: Any, **kwargs: Any) -> Any:\n        if not is_remote_debug():\n            return f(*args, **kwargs)\n        else:\n            warn(\"This command cannot work for remote sessions.\")\n\n    return wrapper\n\n\ndef deprecated(solution: str = \"\") -> Callable:\n    \"\"\"Decorator to add a warning when a command is obsolete and will be removed.\"\"\"\n    def decorator(f: Callable) -> Callable:\n        @functools.wraps(f)\n        def wrapper(*args: Any, **kwargs: Any) -> Any:\n            caller = inspect.stack()[1]\n            caller_file = pathlib.Path(caller.filename)\n            caller_loc = caller.lineno\n            msg = f\"{caller_file.name}:L{caller_loc} '{f.__name__}' is deprecated and will be removed in a feature release. \"\n            if not gef:\n                print(msg)\n            elif gef.config[\"gef.show_deprecation_warnings\"] is True:\n                if solution:\n                    msg += solution\n                warn(msg)\n            return f(*args, **kwargs)\n\n        if not wrapper.__doc__:\n            wrapper.__doc__ = \"\"\n        wrapper.__doc__ += f\"\\r\\n`{f.__name__}` is **DEPRECATED** and will be removed in the future.\\r\\n{solution}\"\n        return wrapper\n    return decorator\n\n\ndef experimental_feature(f: Callable) -> Callable:\n    \"\"\"Decorator to add a warning when a feature is experimental.\"\"\"\n\n    @functools.wraps(f)\n    def wrapper(*args: Any, **kwargs: Any) -> Any:\n        warn(\"This feature is under development, expect bugs and unstability...\")\n        return f(*args, **kwargs)\n\n    return wrapper\n\n\ndef only_if_events_supported(event_type: str) -> Callable:\n    \"\"\"Checks if GDB supports events without crashing.\"\"\"\n    def wrap(f: Callable) -> Callable:\n        def wrapped_f(*args: Any, **kwargs: Any) -> Any:\n            if getattr(gdb, \"events\") and getattr(gdb.events, event_type):\n                return f(*args, **kwargs)\n            warn(\"GDB events cannot be set\")\n        return wrapped_f\n    return wrap\n\n\nclass classproperty(property):\n    \"\"\"Make the attribute a `classproperty`.\"\"\"\n    def __get__(self, cls, owner):\n        assert self.fget\n        return classmethod(self.fget).__get__(None, owner)()\n\n\ndef FakeExit(*args: Any, **kwargs: Any) -> NoReturn:\n    raise RuntimeWarning\n\n\nsys.exit = FakeExit\n\n\ndef parse_arguments(required_arguments: dict[str | tuple[str, str], Any],\n                    optional_arguments: dict[str | tuple[str, str], Any]) -> Callable:\n    \"\"\"Argument parsing decorator.\"\"\"\n\n    def int_wrapper(x: str) -> int: return int(x, 0)\n\n    def decorator(f: Callable) -> Callable | None:\n        def wrapper(*args: Any, **kwargs: Any) -> Callable:\n            parser = argparse.ArgumentParser(prog=args[0]._cmdline_, add_help=True)\n            for argname in required_arguments:\n                argvalue = required_arguments[argname]\n                argtype = type(argvalue)\n                if argtype is int:\n                    argtype = int_wrapper\n\n                argname_is_list = not isinstance(argname, str)\n                assert not argname_is_list and isinstance(argname, str)\n                if not argname_is_list and argname.startswith(\"-\"):\n                    # optional args\n                    if argtype is bool:\n                        parser.add_argument(argname, action=\"store_true\" if argvalue else \"store_false\")\n                    else:\n                        parser.add_argument(argname, type=argtype, required=True, default=argvalue)\n                else:\n                    if argtype in (list, tuple):\n                        nargs = \"*\"\n                        argtype = type(argvalue[0])\n                    else:\n                        nargs = \"?\"\n                    # positional args\n                    parser.add_argument(argname, type=argtype, default=argvalue, nargs=nargs)\n\n            for argname in optional_arguments:\n                if isinstance(argname, str) and not argname.startswith(\"-\"):\n                    # refuse positional arguments\n                    continue\n                argvalue = optional_arguments[argname]\n                argtype = type(argvalue)\n                if isinstance(argname, str):\n                    argname = [argname,]\n                if argtype is int:\n                    argtype = int_wrapper\n                elif argtype is bool:\n                    parser.add_argument(*argname, action=\"store_false\" if argvalue else \"store_true\")\n                    continue\n                elif argtype in (list, tuple):\n                    parser.add_argument(*argname, type=type(argvalue[0]),\n                                        default=[], action=\"append\")\n                    continue\n                parser.add_argument(*argname, type=argtype, default=argvalue)\n\n            parsed_args = parser.parse_args(*(args[1:]))\n            kwargs[\"arguments\"] = parsed_args\n            return f(*args, **kwargs)\n        return wrapper\n    return decorator\n\n\nclass Color:\n    \"\"\"Used to colorify terminal output.\"\"\"\n\n    ### Special chars:\n    # \\001      ->  Tell the readline library that we start a special sequence\n    #               which won't be displayed (takes no column in the output)\n    # \\002      ->  Tell the readline library that we end a special sequence\n    #               started with \\001\n    # \\033      ->  Start an ANSI escape code for displaying colors\n    colors = {\n        \"normal\"         : \"\\001\\033[0m\\002\",\n        \"gray\"           : \"\\001\\033[1;38;5;240m\\002\",\n        \"light_gray\"     : \"\\001\\033[0;37m\\002\",\n        \"red\"            : \"\\001\\033[31m\\002\",\n        \"green\"          : \"\\001\\033[32m\\002\",\n        \"yellow\"         : \"\\001\\033[33m\\002\",\n        \"blue\"           : \"\\001\\033[34m\\002\",\n        \"pink\"           : \"\\001\\033[35m\\002\",\n        \"cyan\"           : \"\\001\\033[36m\\002\",\n        \"bold\"           : \"\\001\\033[1m\\002\",\n        \"underline\"      : \"\\001\\033[4m\\002\",\n        \"underline_off\"  : \"\\001\\033[24m\\002\",\n        \"highlight\"      : \"\\001\\033[3m\\002\",\n        \"highlight_off\"  : \"\\001\\033[23m\\002\",\n        \"blink\"          : \"\\001\\033[5m\\002\",\n        \"blink_off\"      : \"\\001\\033[25m\\002\",\n    }\n\n    @staticmethod\n    def redify(msg: str) -> str:        return Color.colorify(msg, \"red\")\n    @staticmethod\n    def greenify(msg: str) -> str:      return Color.colorify(msg, \"green\")\n    @staticmethod\n    def blueify(msg: str) -> str:       return Color.colorify(msg, \"blue\")\n    @staticmethod\n    def yellowify(msg: str) -> str:     return Color.colorify(msg, \"yellow\")\n    @staticmethod\n    def grayify(msg: str) -> str:       return Color.colorify(msg, \"gray\")\n    @staticmethod\n    def light_grayify(msg: str) -> str: return Color.colorify(msg, \"light_gray\")\n    @staticmethod\n    def pinkify(msg: str) -> str:       return Color.colorify(msg, \"pink\")\n    @staticmethod\n    def cyanify(msg: str) -> str:       return Color.colorify(msg, \"cyan\")\n    @staticmethod\n    def boldify(msg: str) -> str:       return Color.colorify(msg, \"bold\")\n    @staticmethod\n    def underlinify(msg: str) -> str:   return Color.colorify(msg, \"underline\")\n    @staticmethod\n    def highlightify(msg: str) -> str:  return Color.colorify(msg, \"highlight\")\n    @staticmethod\n    def blinkify(msg: str) -> str:      return Color.colorify(msg, \"blink\")\n\n    @staticmethod\n    def colorify(text: str, attrs: str) -> str:\n        \"\"\"Color text according to the given attributes.\"\"\"\n        if gef.config[\"gef.disable_color\"] is True: return text\n\n        colors = Color.colors\n        msg = [colors[attr] for attr in attrs.split() if attr in colors]\n        msg.append(str(text))\n        if colors[\"highlight\"] in msg:   msg.append(colors[\"highlight_off\"])\n        if colors[\"underline\"] in msg:   msg.append(colors[\"underline_off\"])\n        if colors[\"blink\"] in msg:       msg.append(colors[\"blink_off\"])\n        msg.append(colors[\"normal\"])\n        return \"\".join(msg)\n\n\nclass Address:\n    \"\"\"GEF representation of memory addresses.\"\"\"\n    def __init__(self, **kwargs: Any) -> None:\n        self.value: int = kwargs.get(\"value\", 0)\n        self.section: \"Section\" = kwargs.get(\"section\", None)\n        self.info: \"Zone\" = kwargs.get(\"info\", None)\n        return\n\n    def __str__(self) -> str:\n        value = format_address(self.value)\n        code_color = gef.config[\"theme.address_code\"]\n        stack_color = gef.config[\"theme.address_stack\"]\n        heap_color = gef.config[\"theme.address_heap\"]\n        if self.is_in_text_segment():\n            return Color.colorify(value, code_color)\n        if self.is_in_heap_segment():\n            return Color.colorify(value, heap_color)\n        if self.is_in_stack_segment():\n            return Color.colorify(value, stack_color)\n        return value\n\n    def __int__(self) -> int:\n        return self.value\n\n    def is_in_text_segment(self) -> bool:\n        return (hasattr(self.info, \"name\") and \".text\" in self.info.name) or \\\n            (hasattr(self.section, \"path\") and get_filepath() == self.section.path and self.section.is_executable())\n\n    def is_in_stack_segment(self) -> bool:\n        return hasattr(self.section, \"path\") and \"[stack]\" == self.section.path\n\n    def is_in_heap_segment(self) -> bool:\n        return hasattr(self.section, \"path\") and \"[heap]\" == self.section.path\n\n    def dereference(self) -> int | None:\n        addr = align_address(int(self.value))\n        derefed = dereference(addr)\n        return None if derefed is None else int(derefed)\n\n    @property\n    def valid(self) -> bool:\n        return any(map(lambda x: x.page_start <= self.value < x.page_end, gef.memory.maps))\n\n\nclass Permission(enum.Flag):\n    \"\"\"GEF representation of Linux permission.\"\"\"\n    NONE      = 0\n    EXECUTE   = 1\n    WRITE     = 2\n    READ      = 4\n    ALL       = 7\n\n    def __str__(self) -> str:\n        perm_str = \"\"\n        perm_str += \"r\" if self & Permission.READ else \"-\"\n        perm_str += \"w\" if self & Permission.WRITE else \"-\"\n        perm_str += \"x\" if self & Permission.EXECUTE else \"-\"\n        return perm_str\n\n    @classmethod\n    def from_info_sections(cls, *args: str) -> \"Permission\":\n        perm = cls(0)\n        for arg in args:\n            if \"READONLY\" in arg: perm |= Permission.READ\n            if \"DATA\" in arg: perm |= Permission.WRITE\n            if \"CODE\" in arg: perm |= Permission.EXECUTE\n        return perm\n\n    @classmethod\n    def from_process_maps(cls, perm_str: str) -> \"Permission\":\n        perm = cls(0)\n        if perm_str[0] == \"r\": perm |= Permission.READ\n        if perm_str[1] == \"w\": perm |= Permission.WRITE\n        if perm_str[2] == \"x\": perm |= Permission.EXECUTE\n        return perm\n\n    @classmethod\n    def from_monitor_info_mem(cls, perm_str: str) -> \"Permission\":\n        perm = cls(0)\n        # perm_str[0] shows if this is a user page, which\n        # we don't track\n        if perm_str[1] == \"r\": perm |= Permission.READ\n        if perm_str[2] == \"w\": perm |= Permission.WRITE\n        return perm\n\n    @classmethod\n    def from_info_mem(cls, perm_str: str) -> \"Permission\":\n        perm = cls(0)\n        if \"r\" in perm_str: perm |= Permission.READ\n        if \"w\" in perm_str: perm |= Permission.WRITE\n        if \"x\" in perm_str: perm |= Permission.EXECUTE\n        return perm\n\n\nclass Section:\n    \"\"\"GEF representation of process memory sections.\"\"\"\n\n    def __init__(self, **kwargs: Any) -> None:\n        self.page_start: int = kwargs.get(\"page_start\", 0)\n        self.page_end: int = kwargs.get(\"page_end\", 0)\n        self.offset: int = kwargs.get(\"offset\", 0)\n        self.permission: Permission = kwargs.get(\"permission\", Permission(0))\n        self.inode: int = kwargs.get(\"inode\", 0)\n        self.path: str = kwargs.get(\"path\", \"\")\n        return\n\n    def is_readable(self) -> bool:\n        return (self.permission & Permission.READ) != 0\n\n    def is_writable(self) -> bool:\n        return (self.permission & Permission.WRITE) != 0\n\n    def is_executable(self) -> bool:\n        return (self.permission & Permission.EXECUTE) != 0\n\n    @property\n    def size(self) -> int:\n        if self.page_end is None or self.page_start is None:\n            raise AttributeError\n        return self.page_end - self.page_start\n\n    def _search_for_realpath_without_versions(self, path: pathlib.Path) -> str | None:\n        \"\"\"Given a path, search for a file that exists without numeric suffixes.\"\"\"\n\n        # Match the path string against a regex that will remove a suffix\n        # consisting of a dot followed by numbers.\n        candidate = re.match(r\"^(.*)\\.(\\d*)$\", str(path))\n        while candidate:\n            candidate = candidate.group(1)\n            # If the prefix from the regex match is a file, return that path.\n            if pathlib.Path(candidate).is_file():\n                return candidate\n            # Otherwise, try to match again.\n            candidate = re.match(r\"^(.*)\\.(\\d*)$\", candidate)\n        return None\n\n    def _search_for_realpath(self) -> str | None:\n        \"\"\"This function is a workaround for gdb bug #23764\n\n        path might be wrong for remote sessions, so try a simple search for files\n        that aren't found at the path indicated, which should be canonical.\n        \"\"\"\n\n        assert gef.session.remote\n        remote_path = pathlib.Path(self.path)\n        # First, try the canonical path in the remote session root.\n        candidate1 = gef.session.remote.root / remote_path.relative_to(remote_path.anchor)\n        if candidate1.is_file():\n            return str(candidate1)\n        # Also try that path without version suffixes.\n        candidate = self._search_for_realpath_without_versions(candidate1)\n        if candidate:\n            return candidate\n\n        # On some systems, /lib(64) might be a symlink to /usr/lib(64), so try removing\n        # the /usr prefix.\n        if self.path.startswith(\"/usr\"):\n            candidate = gef.session.remote.root / remote_path.relative_to(\"/usr\")\n            if candidate.is_file():\n                return str(candidate)\n            # Also try that path without version suffixes.\n            candidate = self._search_for_realpath_without_versions(candidate)\n            if candidate:\n                return candidate\n\n        # Base case, return the original realpath\n        return str(candidate1)\n\n    @property\n    def realpath(self) -> str:\n        # when in a `gef-remote` session, realpath returns the path to the binary on the local disk, not remote\n        if gef.session.remote is None:\n            return self.path\n        default = self._search_for_realpath()\n        if default:\n            return default\n        raise FileNotFoundError\n\n    def __str__(self) -> str:\n        return (f\"Section(start={self.page_start:#x}, end={self.page_end:#x}, \"\n                f\"perm={self.permission!s})\")\n\n    def __repr__(self) -> str:\n        return str(self)\n\n    def __eq__(self, other: \"Section\") -> bool:\n        return other and \\\n            self.page_start == other.page_start and \\\n            self.size == other.size and \\\n            self.permission == other.permission and \\\n            self.path == other.path\n\n    def overlaps(self, other: \"Section\") -> bool:\n        return max(self.page_start, other.page_start) <= min(self.page_end, other.page_end)\n\n    def contains(self, addr: int) -> bool:\n        return addr in range(self.page_start, self.page_end)\n\n\nZone = collections.namedtuple(\"Zone\", [\"name\", \"zone_start\", \"zone_end\", \"filename\"])\n\n\nclass Endianness(enum.Enum):\n    LITTLE_ENDIAN     = 1\n    BIG_ENDIAN        = 2\n\n    def __str__(self) -> str:\n        return \"<\" if self == Endianness.LITTLE_ENDIAN else \">\"\n\n    def __repr__(self) -> str:\n        return self.name\n\n    def __int__(self) -> int:\n        return self.value\n\n\nclass FileFormatSection:\n    misc: Any\n\n\nclass FileFormat:\n    name: str\n    path: pathlib.Path\n    entry_point: int\n    checksec: dict[str, bool]\n    sections: list[FileFormatSection]\n\n    def __init__(self, path: str | pathlib.Path) -> None:\n        raise NotImplementedError\n\n    def __init_subclass__(cls: Type[\"FileFormat\"], **kwargs):\n        global __registered_file_formats__\n        super().__init_subclass__(**kwargs)\n        required_attributes = (\"name\", \"entry_point\", \"is_valid\", \"checksec\",)\n        for attr in required_attributes:\n            if not hasattr(cls, attr):\n                raise NotImplementedError(f\"File format '{cls.__name__}' is invalid: missing attribute '{attr}'\")\n        __registered_file_formats__.add(cls)\n        return\n\n    @classmethod\n    def is_valid(cls, _: pathlib.Path) -> bool:\n        raise NotImplementedError\n\n    def __str__(self) -> str:\n        return f\"{self.name}('{self.path.absolute()}', entry @ {self.entry_point:#x})\"\n\n\nclass Elf(FileFormat):\n    \"\"\"Basic ELF parsing.\n    Ref:\n    - http://www.skyfree.org/linux/references/ELF_Format.pdf\n    - https://refspecs.linuxfoundation.org/elf/elfspec_ppc.pdf\n    - https://refspecs.linuxfoundation.org/ELF/ppc64/PPC-elf64abi.html\n    \"\"\"\n    class Class(enum.Enum):\n        ELF_32_BITS       = 0x01\n        ELF_64_BITS       = 0x02\n\n    ELF_MAGIC         = 0x7f454c46\n\n    class Abi(enum.Enum):\n        X86_64            = 0x3e\n        X86_32            = 0x03\n        ARM               = 0x28\n        MIPS              = 0x08\n        POWERPC           = 0x14\n        POWERPC64         = 0x15\n        SPARC             = 0x02\n        SPARC64           = 0x2b\n        AARCH64           = 0xb7\n        RISCV             = 0xf3\n        IA64              = 0x32\n        M68K              = 0x04\n\n    class Type(enum.Enum):\n        ET_RELOC          = 1\n        ET_EXEC           = 2\n        ET_DYN            = 3\n        ET_CORE           = 4\n\n    class OsAbi(enum.Enum):\n        SYSTEMV     = 0x00\n        HPUX        = 0x01\n        NETBSD      = 0x02\n        LINUX       = 0x03\n        SOLARIS     = 0x06\n        AIX         = 0x07\n        IRIX        = 0x08\n        FREEBSD     = 0x09\n        OPENBSD     = 0x0C\n\n    e_magic: int                = ELF_MAGIC\n    e_class: \"Elf.Class\"        = Class.ELF_32_BITS\n    e_endianness: Endianness    = Endianness.LITTLE_ENDIAN\n    e_eiversion: int\n    e_osabi: \"Elf.OsAbi\"\n    e_abiversion: int\n    e_pad: bytes\n    e_type: \"Elf.Type\"          = Type.ET_EXEC\n    e_machine: Abi              = Abi.X86_32\n    e_version: int\n    e_entry: int\n    e_phoff: int\n    e_shoff: int\n    e_flags: int\n    e_ehsize: int\n    e_phentsize: int\n    e_phnum: int\n    e_shentsize: int\n    e_shnum: int\n    e_shstrndx: int\n\n    path: pathlib.Path\n    phdrs : list[\"Phdr\"]\n    shdrs : list[\"Shdr\"]\n    name: str = \"ELF\"\n\n    __checksec : dict[str, bool]\n\n    def __init__(self, path: str | pathlib.Path) -> None:\n        \"\"\"Instantiate an ELF object. A valid ELF must be provided, or an exception will be thrown.\"\"\"\n\n        if isinstance(path, str):\n            self.path = pathlib.Path(path).expanduser()\n        elif isinstance(path, pathlib.Path):\n            self.path = path\n        else:\n            raise TypeError\n\n        if not self.path.exists():\n            raise FileNotFoundError(f\"'{self.path}' not found/readable, most gef features will not work\")\n\n        self.__checksec = {}\n\n        with self.path.open(\"rb\") as self.fd:\n            # off 0x0\n            self.e_magic, e_class, e_endianness, self.e_eiversion = self.read_and_unpack(\">IBBB\")\n            if self.e_magic != Elf.ELF_MAGIC:\n                # The ELF is corrupted, GDB won't handle it, no point going further\n                raise RuntimeError(\"Not a valid ELF file (magic)\")\n\n            self.e_class, self.e_endianness = Elf.Class(e_class), Endianness(e_endianness)\n\n            if self.e_endianness != gef.arch.endianness:\n                warn(\"Unexpected endianness for architecture\")\n\n            endian = self.e_endianness\n\n            # off 0x7\n            e_osabi, self.e_abiversion = self.read_and_unpack(f\"{endian}BB\")\n            self.e_osabi = Elf.OsAbi(e_osabi)\n\n            # off 0x9\n            self.e_pad = self.read(7)\n\n            # off 0x10\n            e_type, e_machine, self.e_version = self.read_and_unpack(f\"{endian}HHI\")\n            self.e_type, self.e_machine = Elf.Type(e_type), Elf.Abi(e_machine)\n\n            # off 0x18\n            if self.e_class == Elf.Class.ELF_64_BITS:\n                self.e_entry, self.e_phoff, self.e_shoff = self.read_and_unpack(f\"{endian}QQQ\")\n            else:\n                self.e_entry, self.e_phoff, self.e_shoff = self.read_and_unpack(f\"{endian}III\")\n\n            self.e_flags, self.e_ehsize, self.e_phentsize, self.e_phnum = self.read_and_unpack(f\"{endian}IHHH\")\n            self.e_shentsize, self.e_shnum, self.e_shstrndx = self.read_and_unpack(f\"{endian}HHH\")\n\n            self.phdrs = []\n            for i in range(self.e_phnum):\n                self.phdrs.append(Phdr(self, self.e_phoff + self.e_phentsize * i))\n\n            self.shdrs = []\n            for i in range(self.e_shnum):\n                self.shdrs.append(Shdr(self, self.e_shoff + self.e_shentsize * i))\n        return\n\n    def read(self, size: int) -> bytes:\n        return self.fd.read(size)\n\n    def read_and_unpack(self, fmt: str) -> tuple[Any, ...]:\n        size = struct.calcsize(fmt)\n        data = self.fd.read(size)\n        return struct.unpack(fmt, data)\n\n    def seek(self, off: int) -> None:\n        self.fd.seek(off, 0)\n\n    def __str__(self) -> str:\n        return f\"ELF('{self.path.absolute()}', {self.e_class.name}, {self.e_machine.name})\"\n\n    def __repr__(self) -> str:\n        return f\"ELF('{self.path.absolute()}', {self.e_class.name}, {self.e_machine.name})\"\n\n    @property\n    def entry_point(self) -> int:\n        return self.e_entry\n\n    @classmethod\n    def is_valid(cls, path: pathlib.Path) -> bool:\n        return u32(path.open(\"rb\").read(4), e = Endianness.BIG_ENDIAN) == Elf.ELF_MAGIC\n\n    @property\n    def checksec(self) -> dict[str, bool]:\n        \"\"\"Check the security property of the ELF binary. The following properties are:\n        - Canary\n        - NX\n        - PIE\n        - Fortify\n        - Partial/Full RelRO.\n        Return a dict() with the different keys mentioned above, and the boolean\n        associated whether the protection was found.\"\"\"\n        if not self.__checksec:\n            def __check_security_property(opt: str, filename: str, pattern: str) -> bool:\n                cmd   = [readelf,]\n                cmd  += opt.split()\n                cmd  += [filename,]\n                lines = gef_execute_external(cmd, as_list=True)\n                for line in lines:\n                    if re.search(pattern, line):\n                        return True\n                return False\n\n            abspath = str(self.path.absolute())\n            readelf = gef.session.constants[\"readelf\"]\n            self.__checksec[\"Canary\"] = __check_security_property(\"-rs\", abspath, r\"__stack_chk_fail\") is True\n            has_gnu_stack = __check_security_property(\"-W -l\", abspath, r\"GNU_STACK\") is True\n            if has_gnu_stack:\n                self.__checksec[\"NX\"] = __check_security_property(\"-W -l\", abspath, r\"GNU_STACK.*RWE\") is False\n            else:\n                self.__checksec[\"NX\"] = False\n            self.__checksec[\"PIE\"] = __check_security_property(\"-h\", abspath, r\":.*EXEC\") is False\n            self.__checksec[\"Fortify\"] = __check_security_property(\"-s\", abspath, r\"_chk@GLIBC\") is True\n            self.__checksec[\"Partial RelRO\"] = __check_security_property(\"-l\", abspath, r\"GNU_RELRO\") is True\n            self.__checksec[\"Full RelRO\"] = self.__checksec[\"Partial RelRO\"] and __check_security_property(\"-d\", abspath, r\"BIND_NOW\") is True\n        return self.__checksec\n\n    @classproperty\n    @deprecated(\"use `Elf.Abi.X86_64`\")\n    def X86_64(cls) -> int: return Elf.Abi.X86_64.value # pylint: disable=no-self-argument\n\n    @classproperty\n    @deprecated(\"use `Elf.Abi.X86_32`\")\n    def X86_32(cls) -> int : return Elf.Abi.X86_32.value # pylint: disable=no-self-argument\n\n    @classproperty\n    @deprecated(\"use `Elf.Abi.ARM`\")\n    def ARM(cls) -> int : return Elf.Abi.ARM.value # pylint: disable=no-self-argument\n\n    @classproperty\n    @deprecated(\"use `Elf.Abi.MIPS`\")\n    def MIPS(cls) -> int : return Elf.Abi.MIPS.value # pylint: disable=no-self-argument\n\n    @classproperty\n    @deprecated(\"use `Elf.Abi.POWERPC`\")\n    def POWERPC(cls) -> int : return Elf.Abi.POWERPC.value # pylint: disable=no-self-argument\n\n    @classproperty\n    @deprecated(\"use `Elf.Abi.POWERPC64`\")\n    def POWERPC64(cls) -> int : return Elf.Abi.POWERPC64.value # pylint: disable=no-self-argument\n\n    @classproperty\n    @deprecated(\"use `Elf.Abi.SPARC`\")\n    def SPARC(cls) -> int : return Elf.Abi.SPARC.value # pylint: disable=no-self-argument\n\n    @classproperty\n    @deprecated(\"use `Elf.Abi.SPARC64`\")\n    def SPARC64(cls) -> int : return Elf.Abi.SPARC64.value # pylint: disable=no-self-argument\n\n    @classproperty\n    @deprecated(\"use `Elf.Abi.AARCH64`\")\n    def AARCH64(cls) -> int : return Elf.Abi.AARCH64.value  # pylint: disable=no-self-argument\n\n    @classproperty\n    @deprecated(\"use `Elf.Abi.RISCV`\")\n    def RISCV(cls) -> int : return Elf.Abi.RISCV.value # pylint: disable=no-self-argument\n\n\nclass Phdr:\n    class Type(enum.IntEnum):\n        PT_NULL         = 0\n        PT_LOAD         = 1\n        PT_DYNAMIC      = 2\n        PT_INTERP       = 3\n        PT_NOTE         = 4\n        PT_SHLIB        = 5\n        PT_PHDR         = 6\n        PT_TLS          = 7\n        PT_LOOS         = 0x60000000\n        PT_GNU_EH_FRAME = 0x6474e550\n        PT_GNU_STACK    = 0x6474e551\n        PT_GNU_RELRO    = 0x6474e552\n        PT_GNU_PROPERTY = 0x6474e553\n        PT_LOSUNW       = 0x6ffffffa\n        PT_SUNWBSS      = 0x6ffffffa\n        PT_SUNWSTACK    = 0x6ffffffb\n        PT_HISUNW       = PT_HIOS         = 0x6fffffff\n        PT_LOPROC       = 0x70000000\n        PT_ARM_EIDX     = 0x70000001\n        PT_MIPS_ABIFLAGS= 0x70000003\n        PT_HIPROC       = 0x7fffffff\n        UNKNOWN_PHDR    = 0xffffffff\n\n        @classmethod\n        def _missing_(cls, _:int) -> \"Phdr.Type\":\n            return cls.UNKNOWN_PHDR\n\n    class Flags(enum.IntFlag):\n        PF_X            = 1\n        PF_W            = 2\n        PF_R            = 4\n\n    p_type: \"Phdr.Type\"\n    p_flags: \"Phdr.Flags\"\n    p_offset: int\n    p_vaddr: int\n    p_paddr: int\n    p_filesz: int\n    p_memsz: int\n    p_align: int\n\n    def __init__(self, elf: Elf, off: int) -> None:\n        if not elf:\n            return\n        elf.seek(off)\n        self.offset = off\n        endian = elf.e_endianness\n        if elf.e_class == Elf.Class.ELF_64_BITS:\n            p_type, p_flags, self.p_offset = elf.read_and_unpack(f\"{endian}IIQ\")\n            self.p_vaddr, self.p_paddr = elf.read_and_unpack(f\"{endian}QQ\")\n            self.p_filesz, self.p_memsz, self.p_align = elf.read_and_unpack(f\"{endian}QQQ\")\n        else:\n            p_type, self.p_offset = elf.read_and_unpack(f\"{endian}II\")\n            self.p_vaddr, self.p_paddr = elf.read_and_unpack(f\"{endian}II\")\n            self.p_filesz, self.p_memsz, p_flags, self.p_align = elf.read_and_unpack(f\"{endian}IIII\")\n\n        self.p_type, self.p_flags = Phdr.Type(p_type), Phdr.Flags(p_flags)\n        return\n\n    def __str__(self) -> str:\n        return (f\"Phdr(offset={self.offset}, type={self.p_type.name}, flags={self.p_flags.name}, \"\n\t            f\"vaddr={self.p_vaddr}, paddr={self.p_paddr}, filesz={self.p_filesz}, \"\n\t            f\"memsz={self.p_memsz}, align={self.p_align})\")\n\n\nclass Shdr:\n    class Type(enum.IntEnum):\n        SHT_NULL             = 0\n        SHT_PROGBITS         = 1\n        SHT_SYMTAB           = 2\n        SHT_STRTAB           = 3\n        SHT_RELA             = 4\n        SHT_HASH             = 5\n        SHT_DYNAMIC          = 6\n        SHT_NOTE             = 7\n        SHT_NOBITS           = 8\n        SHT_REL              = 9\n        SHT_SHLIB            = 10\n        SHT_DYNSYM           = 11\n        SHT_NUM\t             = 12\n        SHT_INIT_ARRAY       = 14\n        SHT_FINI_ARRAY       = 15\n        SHT_PREINIT_ARRAY    = 16\n        SHT_GROUP            = 17\n        SHT_SYMTAB_SHNDX     = 18\n        SHT_LOOS             = 0x60000000\n        SHT_GNU_ATTRIBUTES   = 0x6ffffff5\n        SHT_GNU_HASH         = 0x6ffffff6\n        SHT_GNU_LIBLIST      = 0x6ffffff7\n        SHT_CHECKSUM         = 0x6ffffff8\n        SHT_LOSUNW           = 0x6ffffffa\n        SHT_SUNW_move        = 0x6ffffffa\n        SHT_SUNW_COMDAT      = 0x6ffffffb\n        SHT_SUNW_syminfo     = 0x6ffffffc\n        SHT_GNU_verdef       = 0x6ffffffd\n        SHT_GNU_verneed      = 0x6ffffffe\n        SHT_GNU_versym       = 0x6fffffff\n        SHT_LOPROC           = 0x70000000\n        SHT_ARM_EXIDX        = 0x70000001\n        SHT_X86_64_UNWIND    = 0x70000001\n        SHT_ARM_ATTRIBUTES   = 0x70000003\n        SHT_MIPS_OPTIONS     = 0x7000000d\n        DT_MIPS_INTERFACE    = 0x7000002a\n        SHT_HIPROC           = 0x7fffffff\n        SHT_LOUSER           = 0x80000000\n        SHT_HIUSER           = 0x8fffffff\n        UNKNOWN_SHDR         = 0xffffffff\n\n        @classmethod\n        def _missing_(cls, _:int) -> \"Shdr.Type\":\n            return cls.UNKNOWN_SHDR\n\n    class Flags(enum.IntFlag):\n        WRITE            = 1\n        ALLOC            = 2\n        EXECINSTR        = 4\n        MERGE            = 0x10\n        STRINGS          = 0x20\n        INFO_LINK        = 0x40\n        LINK_ORDER       = 0x80\n        OS_NONCONFORMING = 0x100\n        GROUP            = 0x200\n        TLS              = 0x400\n        COMPRESSED       = 0x800\n        RELA_LIVEPATCH   = 0x00100000\n        RO_AFTER_INIT    = 0x00200000\n        ORDERED          = 0x40000000\n        EXCLUDE          = 0x80000000\n        UNKNOWN_FLAG     = 0xffffffff\n\n        @classmethod\n        def _missing_(cls, _:int):\n            return cls.UNKNOWN_FLAG\n\n    sh_name: int\n    sh_type: \"Shdr.Type\"\n    sh_flags: \"Shdr.Flags\"\n    sh_addr: int\n    sh_offset: int\n    sh_size: int\n    sh_link: int\n    sh_info: int\n    sh_addralign: int\n    sh_entsize: int\n    name: str\n\n    def __init__(self, elf: Elf | None, off: int) -> None:\n        if elf is None:\n            return\n        elf.seek(off)\n        endian = elf.e_endianness\n        if elf.e_class == Elf.Class.ELF_64_BITS:\n            self.sh_name, sh_type, sh_flags = elf.read_and_unpack(f\"{endian}IIQ\")\n            self.sh_addr, self.sh_offset = elf.read_and_unpack(f\"{endian}QQ\")\n            self.sh_size, self.sh_link, self.sh_info = elf.read_and_unpack(f\"{endian}QII\")\n            self.sh_addralign, self.sh_entsize = elf.read_and_unpack(f\"{endian}QQ\")\n        else:\n            self.sh_name, sh_type, sh_flags = elf.read_and_unpack(f\"{endian}III\")\n            self.sh_addr, self.sh_offset = elf.read_and_unpack(f\"{endian}II\")\n            self.sh_size, self.sh_link, self.sh_info = elf.read_and_unpack(f\"{endian}III\")\n            self.sh_addralign, self.sh_entsize = elf.read_and_unpack(f\"{endian}II\")\n\n        self.sh_type = Shdr.Type(sh_type)\n        self.sh_flags = Shdr.Flags(sh_flags)\n        stroff = elf.e_shoff + elf.e_shentsize * elf.e_shstrndx\n\n        if elf.e_class == Elf.Class.ELF_64_BITS:\n            elf.seek(stroff + 16 + 8)\n            offset = u64(elf.read(8))\n        else:\n            elf.seek(stroff + 12 + 4)\n            offset = u32(elf.read(4))\n        elf.seek(offset + self.sh_name)\n        self.name = \"\"\n        while True:\n            c = u8(elf.read(1))\n            if c == 0:\n                break\n            self.name += chr(c)\n        return\n\n    def __str__(self) -> str:\n        return (f\"Shdr(name={self.name}, type={self.sh_type.name}, flags={self.sh_flags.name}, \"\n\t            f\"addr={self.sh_addr:#x}, offset={self.sh_offset}, size={self.sh_size}, link={self.sh_link}, \"\n\t            f\"info={self.sh_info}, addralign={self.sh_addralign}, entsize={self.sh_entsize})\")\n\n\nclass Instruction:\n    \"\"\"GEF representation of a CPU instruction.\"\"\"\n\n    def __init__(self, address: int, location: str, mnemo: str, operands: list[str], opcodes: bytes) -> None:\n        self.address, self.location, self.mnemonic, self.operands, self.opcodes = \\\n            address, location, mnemo, operands, opcodes\n        return\n\n    # Allow formatting an instruction with {:o} to show opcodes.\n    # The number of bytes to display can be configured, e.g. {:4o} to only show 4 bytes of the opcodes\n    def __format__(self, format_spec: str) -> str:\n        if len(format_spec) == 0 or format_spec[-1] != \"o\":\n            return str(self)\n\n        if format_spec == \"o\":\n            opcodes_len = len(self.opcodes)\n        else:\n            opcodes_len = int(format_spec[:-1])\n\n        opcodes_text = \"\".join(f\"{b:02x}\" for b in self.opcodes[:opcodes_len])\n        if opcodes_len < len(self.opcodes):\n            opcodes_text += \"...\"\n        return (f\"{self.address:#10x} {opcodes_text:{opcodes_len * 2 + 3:d}s} {self.location:16} \"\n                f\"{self.mnemonic:6} {', '.join(self.operands)}\")\n\n    def __str__(self) -> str:\n        return f\"{self.address:#10x} {self.location:16} {self.mnemonic:6} {', '.join(self.operands)}\"\n\n    def is_valid(self) -> bool:\n        return \"(bad)\" not in self.mnemonic\n\n    def size(self) -> int:\n        return len(self.opcodes)\n\n    def next(self) -> \"Instruction\":\n        address = self.address + self.size()\n        return gef_get_instruction_at(address)\n\n\n@deprecated(\"Use GefHeapManager.find_main_arena_addr()\")\ndef search_for_main_arena() -> int:\n    return GefHeapManager.find_main_arena_addr()\n\nclass GlibcHeapInfo:\n    \"\"\"Glibc heap_info struct\"\"\"\n\n    @staticmethod\n    def heap_info_t() -> Type[ctypes.Structure]:\n        assert gef.libc.version\n        class heap_info_cls(ctypes.Structure):\n            pass\n        pointer = ctypes.c_uint64 if gef.arch.ptrsize == 8 else ctypes.c_uint32\n        pad_size = -5 * gef.arch.ptrsize & (gef.heap.malloc_alignment - 1)\n        fields = [\n            (\"ar_ptr\", ctypes.POINTER(GlibcArena.malloc_state_t())),\n            (\"prev\", ctypes.POINTER(heap_info_cls)),\n            (\"size\", pointer)\n        ]\n        if gef.libc.version >= (2, 5):\n            fields += [\n                (\"mprotect_size\", pointer)\n            ]\n            pad_size = -6 * gef.arch.ptrsize & (gef.heap.malloc_alignment - 1)\n        if gef.libc.version >= (2, 34):\n            fields += [\n                (\"pagesize\", pointer)\n            ]\n            pad_size = -3 * gef.arch.ptrsize & (gef.heap.malloc_alignment - 1)\n        fields += [\n            (\"pad\", ctypes.c_uint8*pad_size)\n        ]\n        heap_info_cls._fields_ = fields\n        return heap_info_cls\n\n    def __init__(self, addr: str |  int) -> None:\n        self.__address : int = parse_address(f\"&{addr}\") if isinstance(addr, str) else addr\n        self.reset()\n        return\n\n    def reset(self):\n        self._sizeof = ctypes.sizeof(GlibcHeapInfo.heap_info_t())\n        self._data = gef.memory.read(self.__address, ctypes.sizeof(GlibcHeapInfo.heap_info_t()))\n        self._heap_info = GlibcHeapInfo.heap_info_t().from_buffer_copy(self._data)\n        return\n\n    def __getattr__(self, item: Any) -> Any:\n        if item in dir(self._heap_info):\n            return ctypes.cast(getattr(self._heap_info, item), ctypes.c_void_p).value\n        return getattr(self, item)\n\n    def __abs__(self) -> int:\n        return self.__address\n\n    def __int__(self) -> int:\n        return self.__address\n\n    @property\n    def address(self) -> int:\n        return self.__address\n\n    @property\n    def sizeof(self) -> int:\n        return self._sizeof\n\n    @property\n    def addr(self) -> int:\n        return int(self)\n\n    @property\n    def heap_start(self) -> int:\n        # check special case: first heap of non-main-arena\n        if self.ar_ptr - self.address < 0x60:\n            # the first heap of a non-main-arena starts with a `heap_info`\n            # struct, which should fit easily into 0x60 bytes throughout\n            # all architectures and glibc versions. If this check succeeds\n            # then we are currently looking at such a \"first heap\"\n            arena = GlibcArena(f\"*{self.ar_ptr:#x}\")\n            heap_addr = arena.heap_addr()\n            if heap_addr:\n                return heap_addr\n            else:\n                err(f\"Cannot find heap address for arena {self.ar_ptr:#x}\")\n                return 0\n        return self.address + self.sizeof\n\n    @property\n    def heap_end(self) -> int:\n        return self.address + self.size\n\n\nclass GlibcArena:\n    \"\"\"Glibc arena class\"\"\"\n\n    NFASTBINS = 10\n    NBINS = 128\n    NSMALLBINS = 64\n    BINMAPSHIFT = 5\n    BITSPERMAP = 1 << BINMAPSHIFT\n    BINMAPSIZE = NBINS // BITSPERMAP\n\n    @staticmethod\n    def malloc_state_t() -> Type[ctypes.Structure]:\n        pointer = ctypes.c_uint64 if gef and gef.arch.ptrsize == 8 else ctypes.c_uint32\n        fields = [\n            (\"mutex\", ctypes.c_uint32),\n            (\"flags\", ctypes.c_uint32),\n        ]\n        if gef and gef.libc.version and gef.libc.version >= (2, 27):\n            # https://elixir.bootlin.com/glibc/glibc-2.27/source/malloc/malloc.c#L1684\n            fields += [\n                (\"have_fastchunks\", ctypes.c_uint32),\n                (\"UNUSED_c\", ctypes.c_uint32), # padding to align to 0x10\n            ]\n        fields += [\n            (\"fastbinsY\", GlibcArena.NFASTBINS * pointer),\n            (\"top\", pointer),\n            (\"last_remainder\", pointer),\n            (\"bins\", (GlibcArena.NBINS * 2 - 2) * pointer),\n            (\"binmap\", GlibcArena.BINMAPSIZE * ctypes.c_uint32),\n            (\"next\", pointer),\n            (\"next_free\", pointer)\n        ]\n        if gef and gef.libc.version and gef.libc.version >= (2, 23):\n            # https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/malloc.c#L1719\n            fields += [\n                (\"attached_threads\", pointer)\n            ]\n        fields += [\n            (\"system_mem\", pointer),\n            (\"max_system_mem\", pointer),\n        ]\n        class malloc_state_cls(ctypes.Structure):\n            _fields_ = fields\n        return malloc_state_cls\n\n    def __init__(self, addr: str) -> None:\n        try:\n            self.__address : int = parse_address(f\"&{addr}\")\n        except gdb.error:\n            self.__address : int = GefHeapManager.find_main_arena_addr()\n            # if `find_main_arena_addr` throws `gdb.error` on symbol lookup:\n            # it means the session is not started, so just propagate the exception\n        self.reset()\n        return\n\n    def reset(self):\n        self._sizeof = ctypes.sizeof(GlibcArena.malloc_state_t())\n        self._data = gef.memory.read(self.__address, ctypes.sizeof(GlibcArena.malloc_state_t()))\n        self.__arena = GlibcArena.malloc_state_t().from_buffer_copy(self._data)\n        return\n\n    def __abs__(self) -> int:\n        return self.__address\n\n    def __int__(self) -> int:\n        return self.__address\n\n    def __iter__(self) -> Generator[\"GlibcArena\", None, None]:\n        assert gef.heap.main_arena\n        main_arena = int(gef.heap.main_arena)\n\n        current_arena = self\n        yield current_arena\n\n        while True:\n            if current_arena.next == 0 or current_arena.next == main_arena:\n                break\n\n            current_arena = GlibcArena(f\"*{current_arena.next:#x} \")\n            yield current_arena\n        return\n\n    def __eq__(self, other: \"GlibcArena\") -> bool:\n        return self.__address == int(other)\n\n    def __str__(self) -> str:\n        properties = f\"base={self.__address:#x}, top={self.top:#x}, \" \\\n                f\"last_remainder={self.last_remainder:#x}, next={self.next:#x}, \" \\\n                f\"mem={self.system_mem}, mempeak={self.max_system_mem}\"\n        return (f\"{Color.colorify('Arena', 'blue bold underline')}({properties})\")\n\n    def __repr__(self) -> str:\n        return f\"GlibcArena(address={self.__address:#x}, size={self._sizeof})\"\n\n    @property\n    def address(self) -> int:\n        return self.__address\n\n    @property\n    def sizeof(self) -> int:\n        return self._sizeof\n\n    @property\n    def addr(self) -> int:\n        return int(self)\n\n    @property\n    def top(self) -> int:\n        return self.__arena.top\n\n    @property\n    def last_remainder(self) -> int:\n        return self.__arena.last_remainder\n\n    @property\n    def fastbinsY(self) -> ctypes.Array:\n        return self.__arena.fastbinsY\n\n    @property\n    def bins(self) -> ctypes.Array:\n        return self.__arena.bins\n\n    @property\n    def binmap(self) -> ctypes.Array:\n        return self.__arena.binmap\n\n    @property\n    def next(self) -> int:\n        return self.__arena.next\n\n    @property\n    def next_free(self) -> int:\n        return self.__arena.next_free\n\n    @property\n    def attached_threads(self) -> int:\n        return self.__arena.attached_threads\n\n    @property\n    def system_mem(self) -> int:\n        return self.__arena.system_mem\n\n    @property\n    def max_system_mem(self) -> int:\n        return self.__arena.max_system_mem\n\n    def fastbin(self, i: int) -> \"GlibcFastChunk | None\":\n        \"\"\"Return head chunk in fastbinsY[i].\"\"\"\n        addr = int(self.fastbinsY[i])\n        if addr == 0:\n            return None\n        return GlibcFastChunk(addr + 2 * gef.arch.ptrsize)\n\n    def bin(self, i: int) -> tuple[int, int]:\n        idx = i * 2\n        fd = int(self.bins[idx])\n        bk = int(self.bins[idx + 1])\n        return fd, bk\n\n    def bin_at(self, i) -> int:\n        header_sz = 2 * gef.arch.ptrsize\n        offset = ctypes.addressof(self.__arena.bins) - ctypes.addressof(self.__arena)\n        return self.__address + offset + (i-1) * 2 * gef.arch.ptrsize + header_sz\n\n    def is_main_arena(self) -> bool:\n        return gef.heap.main_arena is not None and int(self) == int(gef.heap.main_arena)\n\n    def heap_addr(self, allow_unaligned: bool = False) -> int | None:\n        if self.is_main_arena():\n            heap_section = gef.heap.base_address\n            if not heap_section:\n                return None\n            return heap_section\n        _addr = int(self) + self.sizeof\n        if allow_unaligned:\n            return _addr\n        return gef.heap.malloc_align_address(_addr)\n\n    def get_heap_info_list(self) -> list[GlibcHeapInfo] | None:\n        if self.is_main_arena():\n            return None\n        heap_addr = self.get_heap_for_ptr(self.top)\n        heap_infos = [GlibcHeapInfo(heap_addr)]\n        while heap_infos[-1].prev is not None:\n            prev = int(heap_infos[-1].prev)\n            heap_info = GlibcHeapInfo(prev)\n            heap_infos.append(heap_info)\n        return heap_infos[::-1]\n\n    @staticmethod\n    def get_heap_for_ptr(ptr: int) -> int:\n        \"\"\"Find the corresponding heap for a given pointer (int).\n        See https://github.com/bminor/glibc/blob/glibc-2.34/malloc/arena.c#L129\"\"\"\n        if is_32bit():\n            default_mmap_threshold_max = 512 * 1024\n        else:  # 64bit\n            val = cached_lookup_type(\"long\")\n            sz = val.sizeof if val else gef.arch.ptrsize\n            default_mmap_threshold_max = 4 * 1024 * 1024 * sz\n        heap_max_size = 2 * default_mmap_threshold_max\n        return ptr & ~(heap_max_size - 1)\n\n    @staticmethod\n    def verify(addr: int) -> bool:\n        \"\"\"Verify that the address matches a possible valid GlibcArena\"\"\"\n        try:\n            test_arena = GlibcArena(f\"*{addr:#x}\")\n            cur_arena = GlibcArena(f\"*{test_arena.next:#x}\")\n            while cur_arena != test_arena:\n                if cur_arena == 0:\n                    return False\n                cur_arena = GlibcArena(f\"*{cur_arena.next:#x}\")\n        except Exception as e:\n            dbg(f\"GlibcArena.verify({addr:#x}) failed: {str(e)}\")\n            return False\n        return True\n\n\nclass GlibcChunk:\n    \"\"\"Glibc chunk class. The default behavior (from_base=False) is to interpret the data starting at the memory\n    address pointed to as the chunk data. Setting from_base to True instead treats that data as the chunk header.\n    Ref:  https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/.\"\"\"\n\n    class ChunkFlags(enum.IntFlag):\n        PREV_INUSE = 1\n        IS_MMAPPED = 2\n        NON_MAIN_ARENA = 4\n\n        def __str__(self) -> str:\n            return \" | \".join([\n                Color.greenify(\"PREV_INUSE\") if self.value & self.PREV_INUSE else Color.redify(\"PREV_INUSE\"),\n                Color.greenify(\"IS_MMAPPED\") if self.value & self.IS_MMAPPED else Color.redify(\"IS_MMAPPED\"),\n                Color.greenify(\"NON_MAIN_ARENA\") if self.value & self.NON_MAIN_ARENA else Color.redify(\"NON_MAIN_ARENA\")\n            ])\n\n    @staticmethod\n    def malloc_chunk_t() -> Type[ctypes.Structure]:\n        pointer = ctypes.c_uint64 if gef and gef.arch.ptrsize == 8 else ctypes.c_uint32\n        class malloc_chunk_cls(ctypes.Structure):\n            pass\n\n        malloc_chunk_cls._fields_ = [\n            (\"prev_size\", pointer),\n            (\"size\", pointer),\n            (\"fd\", pointer),\n            (\"bk\", pointer),\n            (\"fd_nextsize\", ctypes.POINTER(malloc_chunk_cls)),\n            (\"bk_nextsize\", ctypes.POINTER(malloc_chunk_cls)),\n        ]\n        return malloc_chunk_cls\n\n    def __init__(self, addr: int, from_base: bool = False, allow_unaligned: bool = True) -> None:\n        ptrsize = gef.arch.ptrsize\n        self.data_address = addr + 2 * ptrsize if from_base else addr\n        self.base_address = addr if from_base else addr - 2 * ptrsize\n        if not allow_unaligned:\n            self.data_address = gef.heap.malloc_align_address(self.data_address)\n        self.size_addr = int(self.data_address - ptrsize)\n        self.prev_size_addr = self.base_address\n        self.reset()\n        return\n\n    def reset(self):\n        self._sizeof = ctypes.sizeof(GlibcChunk.malloc_chunk_t())\n        self._data = gef.memory.read(\n            self.base_address, ctypes.sizeof(GlibcChunk.malloc_chunk_t()))\n        self._chunk = GlibcChunk.malloc_chunk_t().from_buffer_copy(self._data)\n        return\n\n    @property\n    def prev_size(self) -> int:\n        return self._chunk.prev_size\n\n    @property\n    def size(self) -> int:\n        return self._chunk.size & (~0x07)\n\n    @property\n    def flags(self) -> ChunkFlags:\n        return GlibcChunk.ChunkFlags(self._chunk.size & 0x07)\n\n    @property\n    def fd(self) -> int:\n        return self._chunk.fd\n\n    @property\n    def bk(self) -> int:\n        return self._chunk.bk\n\n    @property\n    def fd_nextsize(self) -> int:\n        return self._chunk.fd_nextsize\n\n    @property\n    def bk_nextsize(self) -> int:\n        return self._chunk.bk_nextsize\n\n    def get_usable_size(self) -> int:\n        # https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L4537\n        ptrsz = gef.arch.ptrsize\n        cursz = self.size\n        if cursz == 0: return cursz\n        if self.has_m_bit(): return cursz - 2 * ptrsz\n        return cursz - ptrsz\n\n    @property\n    def usable_size(self) -> int:\n        return self.get_usable_size()\n\n    def get_prev_chunk_size(self) -> int:\n        return gef.memory.read_integer(self.prev_size_addr)\n\n    def __iter__(self) -> Generator[\"GlibcChunk\", None, None]:\n        assert gef.heap.main_arena\n        current_chunk = self\n        top = gef.heap.main_arena.top\n\n        while True:\n            yield current_chunk\n\n            if current_chunk.base_address == top:\n                break\n\n            if current_chunk.size == 0:\n                break\n\n            next_chunk_addr = current_chunk.get_next_chunk_addr()\n\n            if not Address(value=next_chunk_addr).valid:\n                break\n\n            next_chunk = current_chunk.get_next_chunk()\n            if next_chunk is None:\n                break\n\n            current_chunk = next_chunk\n        return\n\n    def get_next_chunk(self, allow_unaligned: bool = False) -> \"GlibcChunk\":\n        addr = self.get_next_chunk_addr()\n        return GlibcChunk(addr, allow_unaligned=allow_unaligned)\n\n    def get_next_chunk_addr(self) -> int:\n        return self.data_address + self.size\n\n    def has_p_bit(self) -> bool:\n        return bool(self.flags & GlibcChunk.ChunkFlags.PREV_INUSE)\n\n    def has_m_bit(self) -> bool:\n        return bool(self.flags & GlibcChunk.ChunkFlags.IS_MMAPPED)\n\n    def has_n_bit(self) -> bool:\n        return bool(self.flags & GlibcChunk.ChunkFlags.NON_MAIN_ARENA)\n\n    def is_used(self) -> bool:\n        \"\"\"Check if the current block is used by:\n        - checking the M bit is true\n        - or checking that next chunk PREV_INUSE flag is true\"\"\"\n        if self.has_m_bit():\n            return True\n\n        next_chunk = self.get_next_chunk()\n        return True if next_chunk.has_p_bit() else False\n\n    def __str_sizes(self) -> str:\n        msg = []\n        failed = False\n\n        try:\n            msg.append(f\"Chunk size: {self.size:d} ({self.size:#x})\")\n            msg.append(f\"Usable size: {self.usable_size:d} ({self.usable_size:#x})\")\n            failed = True\n        except gdb.MemoryError:\n            msg.append(f\"Chunk size: Cannot read at {self.size_addr:#x} (corrupted?)\")\n\n        try:\n            prev_chunk_sz = self.get_prev_chunk_size()\n            msg.append(f\"Previous chunk size: {prev_chunk_sz:d} ({prev_chunk_sz:#x})\")\n            failed = True\n        except gdb.MemoryError:\n            msg.append(f\"Previous chunk size: Cannot read at {self.base_address:#x} (corrupted?)\")\n\n        if failed:\n            msg.append(str(self.flags))\n\n        return \"\\n\".join(msg)\n\n    def _str_pointers(self) -> str:\n        fwd = self.data_address\n        bkw = self.data_address + gef.arch.ptrsize\n\n        msg = []\n        try:\n            msg.append(f\"Forward pointer: {self.fd:#x}\")\n        except gdb.MemoryError:\n            msg.append(f\"Forward pointer: {fwd:#x} (corrupted?)\")\n\n        try:\n            msg.append(f\"Backward pointer: {self.bk:#x}\")\n        except gdb.MemoryError:\n            msg.append(f\"Backward pointer: {bkw:#x} (corrupted?)\")\n\n        return \"\\n\".join(msg)\n\n    def __str__(self) -> str:\n        return (f\"{Color.colorify('Chunk', 'yellow bold underline')}(addr={self.data_address:#x}, \"\n                f\"size={self.size:#x}, flags={self.flags!s})\")\n\n    def psprint(self) -> str:\n        msg = [\n            str(self),\n            self.__str_sizes(),\n        ]\n        if not self.is_used():\n            msg.append(f\"\\n\\n{self._str_pointers()}\")\n        return \"\\n\".join(msg) + \"\\n\"\n\n    def resolve_type(self) -> str:\n        ptr_data = gef.memory.read_integer(self.data_address)\n        if ptr_data != 0:\n            sym = gdb_get_location_from_symbol(ptr_data)\n            if sym is not None and \"vtable for\" in sym[0]:\n                return sym[0].replace(\"vtable for \", \"\")\n\n        return \"\"\n\n\nclass GlibcFastChunk(GlibcChunk):\n\n    @property\n    def fd(self) -> int:\n        assert(gef and gef.libc.version)\n        if gef.libc.version < (2, 32):\n            return self._chunk.fd\n        return self.reveal_ptr(self.data_address)\n\n    def protect_ptr(self, pos: int, pointer: int) -> int:\n        \"\"\"https://elixir.bootlin.com/glibc/glibc-2.32/source/malloc/malloc.c#L339\"\"\"\n        assert(gef and gef.libc.version)\n        if gef.libc.version < (2, 32):\n            return pointer\n        return (pos >> 12) ^ pointer\n\n    def reveal_ptr(self, pointer: int) -> int:\n        \"\"\"https://elixir.bootlin.com/glibc/glibc-2.32/source/malloc/malloc.c#L341\"\"\"\n        assert(gef and gef.libc.version)\n        if gef.libc.version < (2, 32):\n            return pointer\n        return gef.memory.read_integer(pointer) ^ (pointer >> 12)\n\nclass GlibcTcacheChunk(GlibcFastChunk):\n    pass\n\n@deprecated(\"Use GefLibcManager.find_libc_version()\")\ndef get_libc_version() -> tuple[int, ...]:\n    return GefLibcManager.find_libc_version()\n\ndef titlify(text: str, color: str | None = None, msg_color: str | None = None) -> str:\n    \"\"\"Print a centered title.\"\"\"\n    _, cols = get_terminal_size()\n    nb = (cols - len(text) - 2) // 2\n    line_color = color or gef.config[\"theme.default_title_line\"]\n    text_color = msg_color or gef.config[\"theme.default_title_message\"]\n\n    msg = [Color.colorify(f\"{HORIZONTAL_LINE * nb} \", line_color),\n           Color.colorify(text, text_color),\n           Color.colorify(f\" {HORIZONTAL_LINE * nb}\", line_color)]\n    return \"\".join(msg)\n\n\ndef dbg(msg: str) -> None:\n    if gef.config[\"gef.debug\"] is True:\n        gef_print(f\"{Color.colorify('[=]', 'bold cyan')} {msg}\")\n    return\n\n\ndef err(msg: str) -> None:\n    gef_print(f\"{Color.colorify('[!]', 'bold red')} {msg}\")\n    return\n\n\ndef warn(msg: str) -> None:\n    gef_print(f\"{Color.colorify('[*]', 'bold yellow')} {msg}\")\n    return\n\n\ndef ok(msg: str) -> None:\n    gef_print(f\"{Color.colorify('[+]', 'bold green')} {msg}\")\n    return\n\n\ndef info(msg: str) -> None:\n    gef_print(f\"{Color.colorify('[+]', 'bold blue')} {msg}\")\n    return\n\n\ndef push_context_message(level: str, message: str) -> None:\n    \"\"\"Push the message to be displayed the next time the context is invoked.\"\"\"\n    if level not in (\"error\", \"warn\", \"ok\", \"info\"):\n        err(f\"Invalid level '{level}', discarding message\")\n        return\n    gef.ui.context_messages.append((level, message))\n    return\n\n\ndef show_last_exception() -> None:\n    \"\"\"Display the last Python exception.\"\"\"\n\n    def _show_code_line(fname: str, idx: int) -> str:\n        fpath = pathlib.Path(os.path.expanduser(os.path.expandvars(fname)))\n        _data = fpath.read_text().splitlines()\n        return _data[idx - 1] if 0 < idx < len(_data) else \"\"\n\n    gef_print(\"\")\n    exc_type, exc_value, exc_traceback = sys.exc_info()\n    exc_name = exc_type.__name__ if exc_type else \"Unknown\"\n    gef_print(\" Exception raised \".center(80, HORIZONTAL_LINE))\n    gef_print(f\"{Color.colorify(exc_name, 'bold underline red')}: {exc_value}\")\n    gef_print(\" Detailed stacktrace \".center(80, HORIZONTAL_LINE))\n\n    for fs in traceback.extract_tb(exc_traceback)[::-1]:\n        filename, lineno, method, code = fs\n\n        if not code or not code.strip():\n            code = _show_code_line(filename, lineno)\n\n        gef_print(f\"\"\"{DOWN_ARROW} File \"{Color.yellowify(filename)}\", line {lineno:d}, in {Color.greenify(method)}()\"\"\")\n        gef_print(f\"   {RIGHT_ARROW}    {code}\")\n\n    gef_print(\" Version \".center(80, HORIZONTAL_LINE))\n    gdb.execute(\"version full\")\n    gef_print(\" Last 10 GDB commands \".center(80, HORIZONTAL_LINE))\n    gdb.execute(\"show commands\")\n    gef_print(\" Runtime environment \".center(80, HORIZONTAL_LINE))\n    gef_print(f\"* GDB: {gdb.VERSION}\")\n    gef_print(f\"* Python: {sys.version_info.major:d}.{sys.version_info.minor:d}.{sys.version_info.micro:d} - {sys.version_info.releaselevel}\")\n    gef_print(f\"* OS: {platform.system()} - {platform.release()} ({platform.machine()})\")\n\n    try:\n        lsb_release = which(\"lsb_release\")\n        gdb.execute(f\"!'{lsb_release}' -a\")\n    except FileNotFoundError:\n        pass\n\n    gef_print(HORIZONTAL_LINE*80)\n    gef_print(\"\")\n    return\n\n\ndef gef_pystring(x: bytes) -> str:\n    \"\"\"Returns a sanitized version as string of the bytes list given in input.\"\"\"\n    res = str(x, encoding=\"utf-8\")\n    substs = [(\"\\n\", \"\\\\n\"), (\"\\r\", \"\\\\r\"), (\"\\t\", \"\\\\t\"), (\"\\v\", \"\\\\v\"), (\"\\b\", \"\\\\b\"), ]\n    for _x, _y in substs: res = res.replace(_x, _y)\n    return res\n\n\ndef gef_pybytes(x: str) -> bytes:\n    \"\"\"Returns an immutable bytes list from the string given as input.\"\"\"\n    return bytes(str(x), encoding=\"utf-8\")\n\n\n@lru_cache()\ndef which(program: str) -> pathlib.Path:\n    \"\"\"Locate a command on the filesystem.\"\"\"\n    res = shutil.which(program)\n    if not res:\n        raise FileNotFoundError(f\"Missing file `{program}`\")\n    return pathlib.Path(res)\n\n\ndef style_byte(b: int, color: bool = True) -> str:\n    style = {\n        \"nonprintable\": \"yellow\",\n        \"printable\": \"white\",\n        \"00\": \"gray\",\n        \"0a\": \"blue\",\n        \"ff\": \"green\",\n    }\n    sbyte = f\"{b:02x}\"\n    if not color or gef.config[\"highlight.regex\"]:\n        return sbyte\n\n    if sbyte in style:\n        st = style[sbyte]\n    elif chr(b) in (string.ascii_letters + string.digits + string.punctuation + \" \"):\n        st = style.get(\"printable\")\n    else:\n        st = style.get(\"nonprintable\")\n    if st:\n        sbyte = Color.colorify(sbyte, st)\n    return sbyte\n\n\ndef hexdump(source: ByteString, length: int = 0x10, separator: str = \".\", show_raw: bool = False, show_symbol: bool = True, base: int = 0x00) -> str:\n    \"\"\"Return the hexdump of `src` argument.\n    @param source *MUST* be of type bytes or bytearray\n    @param length is the length of items per line\n    @param separator is the default character to use if one byte is not printable\n    @param show_raw if True, do not add the line nor the text translation\n    @param base is the start address of the block being hexdump\n    @return a string with the hexdump\"\"\"\n    result = []\n    align = gef.arch.ptrsize * 2 + 2 if is_alive() else 18\n\n    for i in range(0, len(source), length):\n        chunk = bytearray(source[i : i + length])\n        hexa = \" \".join([style_byte(b, color=not show_raw) for b in chunk])\n\n        if show_raw:\n            result.append(hexa)\n            continue\n\n        text = \"\".join([chr(b) if 0x20 <= b < 0x7F else separator for b in chunk])\n        if show_symbol:\n            sym = gdb_get_location_from_symbol(base + i)\n            sym = f\"<{sym[0]:s}+{sym[1]:04x}>\" if sym else \"\"\n        else:\n            sym = \"\"\n\n        result.append(f\"{base + i:#0{align}x} {sym}    {hexa:<{3 * length}}    {text}\")\n    return \"\\n\".join(result)\n\n\ndef is_debug() -> bool:\n    \"\"\"Check if debug mode is enabled.\"\"\"\n    return gef.config[\"gef.debug\"] is True\n\n\ndef buffer_output() -> bool:\n    \"\"\"Check if output should be buffered until command completion.\"\"\"\n    return gef.config[\"gef.buffer\"] is True\n\n\ndef hide_context() -> bool:\n    \"\"\"Helper function to hide the context pane.\"\"\"\n    gef.ui.context_hidden = True\n    return True\n\n\ndef unhide_context() -> bool:\n    \"\"\"Helper function to unhide the context pane.\"\"\"\n    gef.ui.context_hidden = False\n    return True\n\n\nclass DisableContextOutputContext:\n    def __enter__(self) -> None:\n        hide_context()\n        return\n\n    def __exit__(self, *exc: Any) -> None:\n        unhide_context()\n        return\n\n\nclass RedirectOutputContext:\n    def __init__(self, to_file: str = \"/dev/null\") -> None:\n        if \" \" in to_file: raise ValueError(\"Target filepath cannot contain spaces\")\n        self.redirection_target_file = to_file\n        return\n\n    def __enter__(self) -> None:\n        \"\"\"Redirect all GDB output to `to_file` parameter. By default, `to_file` redirects to `/dev/null`.\"\"\"\n        gdb.execute(\"set logging overwrite\")\n        gdb.execute(f\"set logging file {self.redirection_target_file}\")\n        gdb.execute(\"set logging redirect on\")\n\n        if GDB_VERSION >= (12, 0):\n            gdb.execute(\"set logging enabled on\")\n        else:\n            gdb.execute(\"set logging on\")\n        return\n\n    def __exit__(self, *exc: Any) -> None:\n        \"\"\"Disable the output redirection, if any.\"\"\"\n        if GDB_VERSION >= (12, 0):\n            gdb.execute(\"set logging enabled off\")\n        else:\n            gdb.execute(\"set logging off\")\n        gdb.execute(\"set logging redirect off\")\n        return\n\n\ndef enable_redirect_output(to_file: str = \"/dev/null\") -> None:\n    \"\"\"Redirect all GDB output to `to_file` parameter. By default, `to_file` redirects to `/dev/null`.\"\"\"\n    if \" \" in to_file: raise ValueError(\"Target filepath cannot contain spaces\")\n    gdb.execute(\"set logging overwrite\")\n    gdb.execute(f\"set logging file {to_file}\")\n    gdb.execute(\"set logging redirect on\")\n\n    if GDB_VERSION >= (12, 0):\n        gdb.execute(\"set logging enabled on\")\n    else:\n        gdb.execute(\"set logging on\")\n    return\n\n\ndef disable_redirect_output() -> None:\n    \"\"\"Disable the output redirection, if any.\"\"\"\n    if GDB_VERSION >= (12, 0):\n        gdb.execute(\"set logging enabled off\")\n    else:\n        gdb.execute(\"set logging off\")\n    gdb.execute(\"set logging redirect off\")\n    return\n\n@deprecated(\"use `pathlib.Path(...).mkdir()`\")\ndef gef_makedirs(path: str, mode: int = 0o755) -> pathlib.Path:\n    \"\"\"Recursive mkdir() creation. If successful, return the absolute path of the directory created.\"\"\"\n    fpath = pathlib.Path(path)\n    if not fpath.is_dir():\n        fpath.mkdir(mode=mode, exist_ok=True, parents=True)\n    return fpath.absolute()\n\n\n@lru_cache()\ndef gdb_lookup_symbol(sym: str) -> tuple[gdb.Symtab_and_line, ...] | None:\n    \"\"\"Fetch the proper symbol or None if not defined.\"\"\"\n    try:\n        res = gdb.decode_line(sym)[1] # pylint: disable=E1136\n        return res\n    except gdb.error:\n        return None\n\n@lru_cache(maxsize=512)\ndef gdb_get_location_from_symbol(address: int) -> tuple[str, int] | None:\n    \"\"\"Retrieve the location of the `address` argument from the symbol table.\n    Return a tuple with the name and offset if found, None otherwise.\"\"\"\n    # this is horrible, ugly hack and shitty perf...\n    # find a *clean* way to get gdb.Location from an address\n    sym = str(gdb.execute(f\"info symbol {address:#x}\", to_string=True))\n    if sym.startswith(\"No symbol matches\"):\n        return None\n\n    # gdb outputs symbols with format: \"<symbol_name> + <offset> in section <section_name> of <file>\",\n    # here, we are only interested in symbol name and offset.\n    i = sym.find(\" in section \")\n    sym = sym[:i].split(\" + \")\n    name, offset = sym[0], 0\n    if len(sym) == 2 and sym[1].isdigit():\n        offset = int(sym[1])\n    return name, offset\n\n\ndef gdb_disassemble(start_pc: int, **kwargs: int) -> Generator[Instruction, None, None]:\n    \"\"\"Disassemble instructions from `start_pc` (Integer). Accepts the following named\n    parameters:\n    - `end_pc` (Integer) only instructions whose start address fall in the interval from\n      start_pc to end_pc are returned.\n    - `count` (Integer) list at most this many disassembled instructions\n    If `end_pc` and `count` are not provided, the function will behave as if `count=1`.\n    Return an iterator of Instruction objects\n    \"\"\"\n    frame = gdb.selected_frame()\n    arch = frame.architecture()\n\n    for insn in arch.disassemble(start_pc, **kwargs):\n        assert isinstance(insn[\"addr\"], int)\n        assert isinstance(insn[\"length\"], int)\n        assert isinstance(insn[\"asm\"], str)\n        address = insn[\"addr\"]\n        asm = insn[\"asm\"].rstrip().split(None, 1)\n        if len(asm) > 1:\n            mnemo, operands = asm\n            operands = operands.split(\",\")\n        else:\n            mnemo, operands = asm[0], []\n\n        loc = gdb_get_location_from_symbol(address)\n        location = f\"<{loc[0]}+{loc[1]:04x}>\" if loc else \"\"\n\n        opcodes = gef.memory.read(insn[\"addr\"], insn[\"length\"])\n\n        yield Instruction(address, location, mnemo, operands, opcodes)\n\n\ndef gdb_get_nth_previous_instruction_address(addr: int, n: int) -> int | None:\n    \"\"\"Return the address (Integer) of the `n`-th instruction before `addr`.\"\"\"\n    # fixed-length ABI\n    if gef.arch.instruction_length:\n        return max(0, addr - n * gef.arch.instruction_length)\n\n    # variable-length ABI\n    cur_insn_addr = gef_current_instruction(addr).address\n\n    # we try to find a good set of previous instructions by \"guessing\" disassembling backwards\n    # the 15 comes from the longest instruction valid size\n    for i in range(15 * n, 0, -1):\n        try:\n            insns = list(gdb_disassemble(addr - i, end_pc=cur_insn_addr))\n        except gdb.MemoryError:\n            # this is because we can hit an unmapped page trying to read backward\n            break\n\n        # 1. check that the disassembled instructions list size can satisfy\n        if len(insns) < n + 1:  # we expect the current instruction plus the n before it\n            continue\n\n        # If the list of instructions is longer than what we need, then we\n        # could get lucky and already have more than what we need, so slice down\n        insns = insns[-n - 1 :]\n\n        # 2. check that the sequence ends with the current address\n        if insns[-1].address != cur_insn_addr:\n            continue\n\n        # 3. check all instructions are valid\n        if all(insn.is_valid() for insn in insns):\n            return insns[0].address\n\n    return None\n\n\n@deprecated(solution=\"Use `gef_instruction_n().address`\")\ndef gdb_get_nth_next_instruction_address(addr: int, n: int) -> int:\n    \"\"\"Return the address of the `n`-th instruction after `addr`. \"\"\"\n    return gef_instruction_n(addr, n).address\n\n\ndef gef_instruction_n(addr: int, n: int) -> Instruction:\n    \"\"\"Return the `n`-th instruction after `addr` as an Instruction object. Note that `n` is treated as\n    an positive index, starting from 0 (current instruction address)\"\"\"\n    return list(gdb_disassemble(addr, count=n + 1))[n]\n\n\ndef gef_get_instruction_at(addr: int) -> Instruction:\n    \"\"\"Return the full Instruction found at the specified address.\"\"\"\n    insn = next(gef_disassemble(addr, 1))\n    return insn\n\n\ndef gef_current_instruction(addr: int) -> Instruction:\n    \"\"\"Return the current instruction as an Instruction object.\"\"\"\n    return gef_instruction_n(addr, 0)\n\n\ndef gef_next_instruction(addr: int) -> Instruction:\n    \"\"\"Return the next instruction as an Instruction object.\"\"\"\n    return gef_instruction_n(addr, 1)\n\n\ndef gef_disassemble(addr: int, nb_insn: int, nb_prev: int = 0) -> Generator[Instruction, None, None]:\n    \"\"\"Disassemble `nb_insn` instructions after `addr` and `nb_prev` before `addr`.\n    Return an iterator of Instruction objects.\"\"\"\n    nb_insn = max(1, nb_insn)\n\n    if nb_prev:\n        try:\n            start_addr = gdb_get_nth_previous_instruction_address(addr, nb_prev)\n            if start_addr:\n                    for insn in gdb_disassemble(start_addr, count=nb_prev):\n                        if insn.address == addr: break\n                        yield insn\n        except gdb.MemoryError:\n            # If the address pointing to the previous instruction(s) is not mapped, simply skip them\n            pass\n\n    for insn in gdb_disassemble(addr, count=nb_insn):\n        yield insn\n\n\ndef gef_execute_external(command: Sequence[str], as_list: bool = False, **kwargs: Any) -> str |  list[str]:\n    \"\"\"Execute an external command and return the result.\"\"\"\n    res = subprocess.check_output(command, stderr=subprocess.STDOUT, shell=kwargs.get(\"shell\", False))\n    return [gef_pystring(_) for _ in res.splitlines()] if as_list else gef_pystring(res)\n\n\ndef gef_execute_gdb_script(commands: str) -> None:\n    \"\"\"Execute the parameter `source` as GDB command. This is done by writing `commands` to\n    a temporary file, which is then executed via GDB `source` command. The tempfile is then deleted.\"\"\"\n    fd, fname = tempfile.mkstemp(suffix=\".gdb\", prefix=\"gef_\")\n    with os.fdopen(fd, \"w\") as f:\n        f.write(commands)\n        f.flush()\n\n    fname = pathlib.Path(fname)\n    if fname.is_file() and os.access(fname, os.R_OK):\n        gdb.execute(f\"source {fname}\")\n        fname.unlink()\n    return\n\n\n@deprecated(\"Use Elf(fname).checksec()\")\ndef checksec(filename: str) -> dict[str, bool]:\n    return Elf(filename).checksec\n\n\n@deprecated(\"Use `gef.arch` instead\")\ndef get_arch() -> str:\n    \"\"\"Return the binary's architecture.\"\"\"\n    if is_alive():\n        arch = gdb.selected_frame().architecture()\n        return arch.name()\n\n    arch_str = (gdb.execute(\"show architecture\", to_string=True) or \"\").strip()\n    pat = \"The target architecture is set automatically (currently \"\n    if arch_str.startswith(pat):\n        arch_str = arch_str[len(pat):].rstrip(\")\")\n        return arch_str\n\n    pat = \"The target architecture is assumed to be \"\n    if arch_str.startswith(pat):\n        return arch_str[len(pat):]\n\n    pat = \"The target architecture is set to \"\n    if arch_str.startswith(pat):\n        # GDB version >= 10.1\n        if '\"auto\"' in arch_str:\n            return re.findall(r\"currently \\\"(.+)\\\"\", arch_str)[0]\n        return re.findall(r\"\\\"(.+)\\\"\", arch_str)[0]\n\n    # Unknown, we throw an exception to be safe\n    raise RuntimeError(f\"Unknown architecture: {arch_str}\")\n\n\n@deprecated(\"Use `gef.binary.entry_point` instead\")\ndef get_entry_point() -> int | None:\n    \"\"\"Return the binary entry point.\"\"\"\n    return gef.binary.entry_point if gef.binary else None\n\n\ndef is_pie(fpath: str) -> bool:\n    return Elf(fpath).checksec[\"PIE\"]\n\n\n@deprecated(\"Prefer `gef.arch.endianness == Endianness.BIG_ENDIAN`\")\ndef is_big_endian() -> bool:\n    return gef.arch.endianness == Endianness.BIG_ENDIAN\n\n\n@deprecated(\"gef.arch.endianness == Endianness.LITTLE_ENDIAN\")\ndef is_little_endian() -> bool:\n    return gef.arch.endianness == Endianness.LITTLE_ENDIAN\n\n\ndef flags_to_human(reg_value: int, value_table: dict[int, str]) -> str:\n    \"\"\"Return a human readable string showing the flag states.\"\"\"\n    flags = []\n    for bit_index, name in value_table.items():\n        flags.append(Color.boldify(name.upper()) if reg_value & (1<<bit_index) != 0 else name.lower())\n    return f\"[{' '.join(flags)}]\"\n\n\n@lru_cache()\ndef get_section_base_address(name: str) -> int | None:\n    section = process_lookup_path(name)\n    return section.page_start if section else None\n\n\n@lru_cache()\ndef get_zone_base_address(name: str) -> int | None:\n    zone = file_lookup_name_path(name, get_filepath())\n    return zone.zone_start if zone else None\n\n\n#\n# Architecture classes\n#\n\n@deprecated(\"Using the decorator `register_architecture` is unnecessary\")\ndef register_architecture(cls: Type[\"Architecture\"]) -> Type[\"Architecture\"]:\n    return cls\n\nclass ArchitectureBase:\n    \"\"\"Class decorator for declaring an architecture to GEF.\"\"\"\n    aliases: tuple[str | Elf.Abi, ...] = ()\n\n    def __init_subclass__(cls: Type[\"ArchitectureBase\"], **kwargs):\n        global __registered_architectures__\n        super().__init_subclass__(**kwargs)\n        for key in getattr(cls, \"aliases\"):\n            if issubclass(cls, Architecture):\n                if isinstance(key, str):\n                    __registered_architectures__[key.lower()] = cls\n                else:\n                    __registered_architectures__[key] = cls\n        return\n\n\nclass Architecture(ArchitectureBase):\n    \"\"\"Generic metaclass for the architecture supported by GEF.\"\"\"\n\n    # Mandatory defined attributes by inheriting classes\n    arch: str\n    mode: str\n    all_registers: tuple[str, ...]\n    nop_insn: bytes\n    return_register: str\n    flag_register: str | None\n    instruction_length: int | None\n    flags_table: dict[int, str]\n    syscall_register: str | None\n    syscall_instructions: tuple[str, ...]\n    function_parameters: tuple[str, ...]\n\n    # Optionally defined attributes\n    _ptrsize: int | None = None\n    _endianness: Endianness | None = None\n    special_registers: tuple[()] |  tuple[str, ...] = ()\n    maps: GefMemoryMapProvider | None = None\n\n    def __init_subclass__(cls, **kwargs):\n        super().__init_subclass__(**kwargs)\n        attributes = (\"arch\", \"mode\", \"aliases\", \"all_registers\", \"nop_insn\",\n             \"return_register\", \"flag_register\", \"instruction_length\", \"flags_table\",\n             \"function_parameters\",)\n        if not all(map(lambda x: hasattr(cls, x), attributes)):\n            raise NotImplementedError\n\n    def __str__(self) -> str:\n        return f\"Architecture({self.arch}, {self.mode or 'None'}, {repr(self.endianness)})\"\n\n    def __repr__(self) -> str:\n        return self.__str__()\n\n    @staticmethod\n    def supports_gdb_arch(gdb_arch: str) -> bool | None:\n        \"\"\"If implemented by a child `Architecture`, this function dictates if the current class\n        supports the loaded ELF file (which can be accessed via `gef.binary`). This callback\n        function will override any assumption made by GEF to determine the architecture.\"\"\"\n        return None\n\n    def flag_register_to_human(self, val: int | None = None) -> str:\n        raise NotImplementedError\n\n    def is_call(self, insn: Instruction) -> bool:\n        raise NotImplementedError\n\n    def is_ret(self, insn: Instruction) -> bool:\n        raise NotImplementedError\n\n    def is_conditional_branch(self, insn: Instruction) -> bool:\n        raise NotImplementedError\n\n    def is_branch_taken(self, insn: Instruction) -> tuple[bool, str]:\n        raise NotImplementedError\n\n    def get_ra(self, insn: Instruction, frame: \"gdb.Frame\") -> int | None:\n        raise NotImplementedError\n\n    def canary_address(self) -> int:\n        raise NotImplementedError\n\n    @classmethod\n    def mprotect_asm(cls, addr: int, size: int, perm: Permission) -> str:\n        raise NotImplementedError\n\n    def reset_caches(self) -> None:\n        self.__get_register_for_selected_frame.cache_clear()\n        return\n\n    def __get_register(self, regname: str) -> int:\n        \"\"\"Return a register's value.\"\"\"\n        curframe = gdb.selected_frame()\n        key = curframe.pc() ^ int(curframe.read_register('sp')) # todo: check when/if gdb.Frame implements `level()`\n        return self.__get_register_for_selected_frame(regname, int(key))\n\n    @lru_cache()\n    def __get_register_for_selected_frame(self, regname: str, hash_key: int) -> int:\n        # 1st chance\n        try:\n            return parse_address(regname)\n        except gdb.error:\n            pass\n\n        # 2nd chance - if an exception, propagate it\n        regname = regname.lstrip(\"$\")\n        value = gdb.selected_frame().read_register(regname)\n        return int(value)\n\n    def register(self, name: str) -> int:\n        if not is_alive():\n            raise gdb.error(\"No debugging session active\")\n        return self.__get_register(name)\n\n    @property\n    def registers(self) -> Generator[str, None, None]:\n        yield from self.all_registers\n\n    @property\n    def pc(self) -> int:\n        return self.register(\"$pc\")\n\n    @property\n    def sp(self) -> int:\n        return self.register(\"$sp\")\n\n    @property\n    def fp(self) -> int:\n        return self.register(\"$fp\")\n\n    @property\n    def ptrsize(self) -> int:\n        if not self._ptrsize:\n            res = cached_lookup_type(\"size_t\")\n            if res is not None:\n                self._ptrsize = res.sizeof\n            else:\n                self._ptrsize = gdb.parse_and_eval(\"$pc\").type.sizeof\n        return self._ptrsize\n\n    @property\n    def endianness(self) -> Endianness:\n        if not self._endianness:\n            output = (gdb.execute(\"show endian\", to_string=True) or \"\").strip().lower()\n            if \"little endian\" in output:\n                self._endianness = Endianness.LITTLE_ENDIAN\n            elif \"big endian\" in output:\n                self._endianness = Endianness.BIG_ENDIAN\n            else:\n                raise OSError(f\"No valid endianness found in '{output}'\")\n        return self._endianness\n\n    def get_ith_parameter(self, i: int, in_func: bool = True) -> tuple[str, int | None]:\n        \"\"\"Retrieves the correct parameter used for the current function call.\"\"\"\n        reg = self.function_parameters[i]\n        val = self.register(reg)\n        key = reg\n        return key, val\n\n\nclass GenericArchitecture(Architecture):\n    arch = \"Generic\"\n    mode = \"\"\n    aliases = (\"GenericArchitecture\",)\n    all_registers = ()\n    instruction_length = 0\n    return_register = \"\"\n    function_parameters = ()\n    syscall_register = \"\"\n    syscall_instructions = ()\n    nop_insn = b\"\"\n    flag_register = None\n    flags_table = {}\n\n\nclass RISCV(Architecture):\n    arch = \"RISCV\"\n    mode = \"RISCV\"\n    aliases = (\"RISCV\", Elf.Abi.RISCV)\n    all_registers = (\"$zero\", \"$ra\", \"$sp\", \"$gp\", \"$tp\", \"$t0\", \"$t1\",\n                     \"$t2\", \"$fp\", \"$s1\", \"$a0\", \"$a1\", \"$a2\", \"$a3\",\n                     \"$a4\", \"$a5\", \"$a6\", \"$a7\", \"$s2\", \"$s3\", \"$s4\",\n                     \"$s5\", \"$s6\", \"$s7\", \"$s8\", \"$s9\", \"$s10\", \"$s11\",\n                     \"$t3\", \"$t4\", \"$t5\", \"$t6\",)\n    return_register = \"$a0\"\n    function_parameters = (\"$a0\", \"$a1\", \"$a2\", \"$a3\", \"$a4\", \"$a5\", \"$a6\", \"$a7\")\n    syscall_register = \"$a7\"\n    syscall_instructions = (\"ecall\",)\n    nop_insn = b\"\\x00\\x00\\x00\\x13\"\n    # RISC-V has no flags registers\n    flag_register = None\n    flags_table = {}\n\n    @property\n    def instruction_length(self) -> int:\n        return 4\n\n    def is_call(self, insn: Instruction) -> bool:\n        return insn.mnemonic == \"call\"\n\n    def is_ret(self, insn: Instruction) -> bool:\n        mnemo = insn.mnemonic\n        if mnemo == \"ret\":\n            return True\n        elif (mnemo == \"jalr\" and insn.operands[0] == \"zero\" and\n              insn.operands[1] == \"ra\" and insn.operands[2] == 0):\n            return True\n        elif (mnemo == \"c.jalr\" and insn.operands[0] == \"ra\"):\n            return True\n        return False\n\n    @classmethod\n    def mprotect_asm(cls, addr: int, size: int, perm: Permission) -> str:\n        raise OSError(f\"Architecture {cls.arch} not supported yet\")\n\n    @property\n    def ptrsize(self) -> int:\n        if self._ptrsize is not None:\n            return self._ptrsize\n        if is_alive():\n            self._ptrsize = gdb.parse_and_eval(\"$pc\").type.sizeof\n            return self._ptrsize\n        return 4\n\n    def is_conditional_branch(self, insn: Instruction) -> bool:\n        return insn.mnemonic.startswith(\"b\")\n\n    def is_branch_taken(self, insn: Instruction) -> tuple[bool, str]:\n        def long_to_twos_complement(v: int) -> int:\n            \"\"\"Convert a python long value to its two's complement.\"\"\"\n            if is_32bit():\n                if v & 0x80000000:\n                    return v - 0x100000000\n            elif is_64bit():\n                if v & 0x8000000000000000:\n                    return v - 0x10000000000000000\n            else:\n                raise OSError(\"RISC-V: ELF file is not ELF32 or ELF64. This is not currently supported\")\n            return v\n\n        mnemo = insn.mnemonic\n        condition = mnemo[1:]\n\n        if condition.endswith(\"z\"):\n            # r2 is the zero register if we are comparing to 0\n            rs1 = gef.arch.register(insn.operands[0])\n            rs2 = gef.arch.register(\"$zero\")\n            condition = condition[:-1]\n        elif len(insn.operands) > 2:\n            # r2 is populated with the second operand\n            rs1 = gef.arch.register(insn.operands[0])\n            rs2 = gef.arch.register(insn.operands[1])\n        else:\n            raise OSError(f\"RISC-V: Failed to get rs1 and rs2 for instruction: `{insn}`\")\n\n        # If the conditional operation is not unsigned, convert the python long into\n        # its two's complement\n        if not condition.endswith(\"u\"):\n            rs2 = long_to_twos_complement(rs2)\n            rs1 = long_to_twos_complement(rs1)\n        else:\n            condition = condition[:-1]\n\n        if condition == \"eq\":\n            if rs1 == rs2: taken, reason = True, f\"{rs1}={rs2}\"\n            else: taken, reason = False, f\"{rs1}!={rs2}\"\n        elif condition == \"ne\":\n            if rs1 != rs2: taken, reason = True, f\"{rs1}!={rs2}\"\n            else: taken, reason = False, f\"{rs1}={rs2}\"\n        elif condition == \"lt\":\n            if rs1 < rs2: taken, reason = True, f\"{rs1}<{rs2}\"\n            else: taken, reason = False, f\"{rs1}>={rs2}\"\n        elif condition == \"le\":\n            if rs1 <= rs2: taken, reason = True, f\"{rs1}<={rs2}\"\n            else: taken, reason = False, f\"{rs1}>{rs2}\"\n        elif condition == \"ge\":\n            if rs1 >= rs2: taken, reason = True, f\"{rs1}>={rs2}\"\n            else: taken, reason = False, f\"{rs1}<{rs2}\"\n        else:\n            raise OSError(f\"RISC-V: Conditional instruction `{insn}` not supported yet\")\n\n        return taken, reason\n\n    def get_ra(self, insn: Instruction, frame: \"gdb.Frame\") -> int | None:\n        ra = None\n        if self.is_ret(insn):\n            ra = gef.arch.register(\"$ra\")\n        else:\n            older = frame.older()\n            if older:\n                ra = to_unsigned_long(older.pc())\n        return ra\n\n    def flag_register_to_human(self, val: int | None = None) -> str:\n        # RISC-V has no flags registers, return an empty string to\n        # preserve the Architecture API\n        return \"\"\n\nclass ARM(Architecture):\n    aliases = (\"ARM\", Elf.Abi.ARM)\n    arch = \"ARM\"\n    all_registers = (\"$r0\", \"$r1\", \"$r2\", \"$r3\", \"$r4\", \"$r5\", \"$r6\",\n                     \"$r7\", \"$r8\", \"$r9\", \"$r10\", \"$r11\", \"$r12\", \"$sp\",\n                     \"$lr\", \"$pc\", \"$cpsr\",)\n\n    nop_insn = b\"\\x00\\xf0\\x20\\xe3\" # hint #0\n    return_register = \"$r0\"\n    flag_register: str = \"$cpsr\"\n    flags_table = {\n        31: \"negative\",\n        30: \"zero\",\n        29: \"carry\",\n        28: \"overflow\",\n        7: \"interrupt\",\n        6: \"fast\",\n        5: \"thumb\",\n    }\n    function_parameters = (\"$r0\", \"$r1\", \"$r2\", \"$r3\")\n    syscall_register = \"$r7\"\n    syscall_instructions = (\"swi 0x0\", \"swi NR\")\n    _endianness = Endianness.LITTLE_ENDIAN\n\n    def is_thumb(self) -> bool:\n        \"\"\"Determine if the machine is currently in THUMB mode.\"\"\"\n        return is_alive() and (self.cpsr & (1 << 5) == 1)\n\n    @property\n    def pc(self) -> int | None:\n        pc = gef.arch.register(\"$pc\")\n        if self.is_thumb():\n            pc += 1\n        return pc\n\n    @property\n    def cpsr(self) -> int:\n        if not is_alive():\n            raise RuntimeError(\"Cannot get CPSR, program not started?\")\n        return gef.arch.register(self.flag_register)\n\n    @property\n    def mode(self) -> str:\n        return \"THUMB\" if self.is_thumb() else \"ARM\"\n\n    @property\n    def instruction_length(self) -> int | None:\n        # Thumb instructions have variable-length (2 or 4-byte)\n        return None if self.is_thumb() else 4\n\n    @property\n    def ptrsize(self) -> int:\n        return 4\n\n    def is_call(self, insn: Instruction) -> bool:\n        mnemo = insn.mnemonic\n        call_mnemos = {\"bl\", \"blx\"}\n        return mnemo in call_mnemos\n\n    def is_ret(self, insn: Instruction) -> bool:\n        pop_mnemos = {\"pop\"}\n        branch_mnemos = {\"bl\", \"bx\"}\n        write_mnemos = {\"ldr\", \"add\"}\n        if insn.mnemonic in pop_mnemos:\n            return insn.operands[-1] == \" pc}\"\n        if insn.mnemonic in branch_mnemos:\n            return insn.operands[-1] == \"lr\"\n        if insn.mnemonic in write_mnemos:\n            return insn.operands[0] == \"pc\"\n        return False\n\n    def flag_register_to_human(self, val: int | None = None) -> str:\n        # https://www.botskool.com/user-pages/tutorials/electronics/arm-7-tutorial-part-1\n        if val is None:\n            reg = self.flag_register\n            val = gef.arch.register(reg)\n        return flags_to_human(val, self.flags_table)\n\n    def is_conditional_branch(self, insn: Instruction) -> bool:\n        conditions = {\"eq\", \"ne\", \"lt\", \"le\", \"gt\", \"ge\", \"vs\", \"vc\", \"mi\", \"pl\", \"hi\", \"ls\", \"cc\", \"cs\"}\n        return insn.mnemonic[-2:] in conditions\n\n    def is_branch_taken(self, insn: Instruction) -> tuple[bool, str]:\n        mnemo = insn.mnemonic\n        # ref: https://www.davespace.co.uk/arm/introduction-to-arm/conditional.html\n        flags = dict((self.flags_table[k], k) for k in self.flags_table)\n        val = gef.arch.register(self.flag_register)\n        taken, reason = False, \"\"\n\n        if mnemo.endswith(\"eq\"): taken, reason = bool(val&(1<<flags[\"zero\"])), \"Z\"\n        elif mnemo.endswith(\"ne\"): taken, reason = not bool(val&(1<<flags[\"zero\"])), \"!Z\"\n        elif mnemo.endswith(\"lt\"):\n            taken, reason = bool(val&(1<<flags[\"negative\"])) != bool(val&(1<<flags[\"overflow\"])), \"N!=V\"\n        elif mnemo.endswith(\"le\"):\n            taken, reason = bool(val&(1<<flags[\"zero\"])) or \\\n                bool(val&(1<<flags[\"negative\"])) != bool(val&(1<<flags[\"overflow\"])), \"Z || N!=V\"\n        elif mnemo.endswith(\"gt\"):\n            taken, reason = bool(val&(1<<flags[\"zero\"])) == 0 and \\\n                bool(val&(1<<flags[\"negative\"])) == bool(val&(1<<flags[\"overflow\"])), \"!Z && N==V\"\n        elif mnemo.endswith(\"ge\"):\n            taken, reason = bool(val&(1<<flags[\"negative\"])) == bool(val&(1<<flags[\"overflow\"])), \"N==V\"\n        elif mnemo.endswith(\"vs\"): taken, reason = bool(val&(1<<flags[\"overflow\"])), \"V\"\n        elif mnemo.endswith(\"vc\"): taken, reason = not val&(1<<flags[\"overflow\"]), \"!V\"\n        elif mnemo.endswith(\"mi\"):\n            taken, reason = bool(val&(1<<flags[\"negative\"])), \"N\"\n        elif mnemo.endswith(\"pl\"):\n            taken, reason = not val&(1<<flags[\"negative\"]), \"N==0\"\n        elif mnemo.endswith(\"hi\"):\n            taken, reason = bool(val&(1<<flags[\"carry\"])) and not bool(val&(1<<flags[\"zero\"])), \"C && !Z\"\n        elif mnemo.endswith(\"ls\"):\n            taken, reason = not val&(1<<flags[\"carry\"]) or bool(val&(1<<flags[\"zero\"])), \"!C || Z\"\n        elif mnemo.endswith(\"cs\"): taken, reason = bool(val&(1<<flags[\"carry\"])), \"C\"\n        elif mnemo.endswith(\"cc\"): taken, reason = not val&(1<<flags[\"carry\"]), \"!C\"\n        return taken, reason\n\n    def get_ra(self, insn: Instruction, frame: \"gdb.Frame\") -> int | None:\n        if not self.is_ret(insn):\n            older = frame.older()\n            if not older:\n                return None\n            return int(older.pc())\n\n        # If it's a pop, we have to peek into the stack, otherwise use lr\n        if insn.mnemonic == \"pop\":\n            ra_addr = gef.arch.sp + (len(insn.operands)-1) * self.ptrsize\n            if not ra_addr:\n                return None\n            ra = dereference(ra_addr)\n            if ra is None:\n                return None\n            return to_unsigned_long(ra)\n        elif insn.mnemonic == \"ldr\":\n            ra = dereference(gef.arch.sp)\n            if ra is None:\n                return None\n            return to_unsigned_long(ra)\n        else:  # 'bx lr' or 'add pc, lr, #0'\n            return gef.arch.register(\"$lr\")\n\n    @classmethod\n    def mprotect_asm(cls, addr: int, size: int, perm: Permission) -> str:\n        _NR_mprotect = 125\n        insns = [\n            \"push {r0-r2, r7}\",\n            f\"mov r1, {addr & 0xffff:d}\",\n            f\"mov r0, {(addr & 0xffff0000) >> 16:d}\",\n            \"lsl r0, r0, 16\",\n            \"add r0, r0, r1\",\n            f\"mov r1, {size & 0xffff:d}\",\n            f\"mov r2, {perm.value & 0xff:d}\",\n            f\"mov r7, {_NR_mprotect:d}\",\n            \"svc 0\",\n            \"pop {r0-r2, r7}\",\n        ]\n        return \"; \".join(insns)\n\n\nclass AARCH64(ARM):\n    aliases = (\"ARM64\", \"AARCH64\", Elf.Abi.AARCH64)\n    arch = \"ARM64\"\n    mode: str = \"\"\n\n    all_registers = (\n        \"$x0\", \"$x1\", \"$x2\", \"$x3\", \"$x4\", \"$x5\", \"$x6\", \"$x7\",\n        \"$x8\", \"$x9\", \"$x10\", \"$x11\", \"$x12\", \"$x13\", \"$x14\",\"$x15\",\n        \"$x16\", \"$x17\", \"$x18\", \"$x19\", \"$x20\", \"$x21\", \"$x22\", \"$x23\",\n        \"$x24\", \"$x25\", \"$x26\", \"$x27\", \"$x28\", \"$x29\", \"$x30\", \"$sp\",\n        \"$pc\", \"$cpsr\", \"$fpsr\", \"$fpcr\",)\n    return_register = \"$x0\"\n    flag_register = \"$cpsr\"\n    flags_table = {\n        31: \"negative\",\n        30: \"zero\",\n        29: \"carry\",\n        28: \"overflow\",\n        7: \"interrupt\",\n        9: \"endian\",\n        6: \"fast\",\n        5: \"t32\",\n        4: \"m[4]\",\n    }\n    nop_insn = b\"\\x1f\\x20\\x03\\xd5\" # hint #0\n    function_parameters = (\"$x0\", \"$x1\", \"$x2\", \"$x3\", \"$x4\", \"$x5\", \"$x6\", \"$x7\",)\n    syscall_register = \"$x8\"\n    syscall_instructions = (\"svc $x0\",)\n\n    def is_call(self, insn: Instruction) -> bool:\n        mnemo = insn.mnemonic\n        call_mnemos = {\"bl\", \"blr\"}\n        return mnemo in call_mnemos\n\n    def flag_register_to_human(self, val: int | None = None) -> str:\n        # https://events.linuxfoundation.org/sites/events/files/slides/KoreaLinuxForum-2014.pdf\n        reg = self.flag_register\n        if not val:\n            val = gef.arch.register(reg)\n        return flags_to_human(val, self.flags_table)\n\n    def is_aarch32(self) -> bool:\n        \"\"\"Determine if the CPU is currently in AARCH32 mode from runtime.\"\"\"\n        return (self.cpsr & (1 << 4) != 0) and (self.cpsr & (1 << 5) == 0)\n\n    def is_thumb32(self) -> bool:\n        \"\"\"Determine if the CPU is currently in THUMB32 mode from runtime.\"\"\"\n        return (self.cpsr & (1 << 4) == 1) and (self.cpsr & (1 << 5) == 1)\n\n    @property\n    def ptrsize(self) -> int:\n        \"\"\"Determine the size of pointer from the current CPU mode\"\"\"\n        if not is_alive():\n            return 8\n        if self.is_aarch32():\n            return 4\n        if self.is_thumb32():\n            return 2\n        return 8\n\n    @classmethod\n    def mprotect_asm(cls, addr: int, size: int, perm: Permission) -> str:\n        _NR_mprotect = 226\n        insns = [\n            \"str x8, [sp, -16]!\",\n            \"str x0, [sp, -16]!\",\n            \"str x1, [sp, -16]!\",\n            \"str x2, [sp, -16]!\",\n            f\"mov x8, {_NR_mprotect:d}\",\n            f\"movz x0, {addr & 0xFFFF:#x}\",\n            f\"movk x0, {(addr >> 16) & 0xFFFF:#x}, lsl 16\",\n            f\"movk x0, {(addr >> 32) & 0xFFFF:#x}, lsl 32\",\n            f\"movk x0, {(addr >> 48) & 0xFFFF:#x}, lsl 48\",\n            f\"movz x1, {size & 0xFFFF:#x}\",\n            f\"movk x1, {(size >> 16) & 0xFFFF:#x}, lsl 16\",\n            f\"mov x2, {perm.value:d}\",\n            \"svc 0\",\n            \"ldr x2, [sp], 16\",\n            \"ldr x1, [sp], 16\",\n            \"ldr x0, [sp], 16\",\n            \"ldr x8, [sp], 16\",\n        ]\n        return \"; \".join(insns)\n\n    def is_conditional_branch(self, insn: Instruction) -> bool:\n        # https://www.element14.com/community/servlet/JiveServlet/previewBody/41836-102-1-229511/ARM.Reference_Manual.pdf\n        # sect. 5.1.1\n        mnemo = insn.mnemonic\n        branch_mnemos = {\"cbnz\", \"cbz\", \"tbnz\", \"tbz\"}\n        return mnemo.startswith(\"b.\") or mnemo in branch_mnemos\n\n    def is_branch_taken(self, insn: Instruction) -> tuple[bool, str]:\n        mnemo, operands = insn.mnemonic, insn.operands\n        taken, reason = False, \"\"\n\n        if mnemo in {\"cbnz\", \"cbz\", \"tbnz\", \"tbz\"}:\n            reg = f\"${operands[0]}\"\n            op = gef.arch.register(reg)\n            if mnemo == \"cbnz\":\n                if op!=0: taken, reason = True, f\"{reg}!=0\"\n                else: taken, reason = False, f\"{reg}==0\"\n            elif mnemo == \"cbz\":\n                if op == 0: taken, reason = True, f\"{reg}==0\"\n                else: taken, reason = False, f\"{reg}!=0\"\n            elif mnemo == \"tbnz\":\n                # operands[1] has one or more white spaces in front, then a #, then the number\n                # so we need to eliminate them\n                i = int(operands[1].strip().lstrip(\"#\"))\n                if (op & 1<<i) != 0: taken, reason = True, f\"{reg}&1<<{i}!=0\"\n                else: taken, reason = False, f\"{reg}&1<<{i}==0\"\n            elif mnemo == \"tbz\":\n                # operands[1] has one or more white spaces in front, then a #, then the number\n                # so we need to eliminate them\n                i = int(operands[1].strip().lstrip(\"#\"))\n                if (op & 1<<i) == 0: taken, reason = True, f\"{reg}&1<<{i}==0\"\n                else: taken, reason = False, f\"{reg}&1<<{i}!=0\"\n\n        if not reason:\n            taken, reason = super().is_branch_taken(insn)\n        return taken, reason\n\n\nclass X86(Architecture):\n    aliases = (\"X86\", Elf.Abi.X86_32)\n    arch = \"X86\"\n    mode = \"32\"\n\n    nop_insn = b\"\\x90\"\n    flag_register: str = \"$eflags\"\n    special_registers = (\"$cs\", \"$ss\", \"$ds\", \"$es\", \"$fs\", \"$gs\", )\n    gpr_registers = (\"$eax\", \"$ebx\", \"$ecx\", \"$edx\", \"$esp\", \"$ebp\", \"$esi\", \"$edi\", \"$eip\", )\n    all_registers = gpr_registers + ( flag_register,) + special_registers\n    instruction_length = None\n    return_register = \"$eax\"\n    function_parameters = (\"$esp\", )\n    flags_table = {\n        6: \"zero\",\n        0: \"carry\",\n        2: \"parity\",\n        4: \"adjust\",\n        7: \"sign\",\n        8: \"trap\",\n        9: \"interrupt\",\n        10: \"direction\",\n        11: \"overflow\",\n        16: \"resume\",\n        17: \"virtualx86\",\n        21: \"identification\",\n    }\n    syscall_register = \"$eax\"\n    syscall_instructions = (\"sysenter\", \"int 0x80\")\n    _ptrsize = 4\n    _endianness = Endianness.LITTLE_ENDIAN\n\n    def flag_register_to_human(self, val: int | None = None) -> str:\n        reg = self.flag_register\n        if val is None:\n            val = gef.arch.register(reg)\n        return flags_to_human(val, self.flags_table)\n\n    def is_call(self, insn: Instruction) -> bool:\n        mnemo = insn.mnemonic\n        call_mnemos = {\"call\", \"callq\"}\n        return mnemo in call_mnemos\n\n    def is_ret(self, insn: Instruction) -> bool:\n        return insn.mnemonic == \"ret\"\n\n    def is_conditional_branch(self, insn: Instruction) -> bool:\n        mnemo = insn.mnemonic\n        branch_mnemos = {\n            \"ja\", \"jnbe\", \"jae\", \"jnb\", \"jnc\", \"jb\", \"jc\", \"jnae\", \"jbe\", \"jna\",\n            \"jcxz\", \"jecxz\", \"jrcxz\", \"je\", \"jz\", \"jg\", \"jnle\", \"jge\", \"jnl\",\n            \"jl\", \"jnge\", \"jle\", \"jng\", \"jne\", \"jnz\", \"jno\", \"jnp\", \"jpo\", \"jns\",\n            \"jo\", \"jp\", \"jpe\", \"js\"\n        }\n        return mnemo in branch_mnemos\n\n    def is_branch_taken(self, insn: Instruction) -> tuple[bool, str]:\n        mnemo = insn.mnemonic\n        # all kudos to fG! (https://github.com/gdbinit/Gdbinit/blob/master/gdbinit#L1654)\n        flags = dict((self.flags_table[k], k) for k in self.flags_table)\n        val = gef.arch.register(self.flag_register)\n\n        taken, reason = False, \"\"\n\n        if mnemo in (\"ja\", \"jnbe\"):\n            taken, reason = not val&(1<<flags[\"carry\"]) and not bool(val&(1<<flags[\"zero\"])), \"!C && !Z\"\n        elif mnemo in (\"jae\", \"jnb\", \"jnc\"):\n            taken, reason = not val&(1<<flags[\"carry\"]), \"!C\"\n        elif mnemo in (\"jb\", \"jc\", \"jnae\"):\n            taken, reason = bool(val&(1<<flags[\"carry\"])) != 0, \"C\"\n        elif mnemo in (\"jbe\", \"jna\"):\n            taken, reason = bool(val&(1<<flags[\"carry\"])) or bool(val&(1<<flags[\"zero\"])), \"C || Z\"\n        elif mnemo in (\"jcxz\", \"jecxz\", \"jrcxz\"):\n            cx = gef.arch.register(\"$rcx\") if is_x86_64() else gef.arch.register(\"$ecx\")\n            taken, reason = cx == 0, \"!$CX\"\n        elif mnemo in (\"je\", \"jz\"):\n            taken, reason = bool(val&(1<<flags[\"zero\"])), \"Z\"\n        elif mnemo in (\"jne\", \"jnz\"):\n            taken, reason = not bool(val&(1<<flags[\"zero\"])), \"!Z\"\n        elif mnemo in (\"jg\", \"jnle\"):\n            taken, reason = not bool(val&(1<<flags[\"zero\"])) and bool(val&(1<<flags[\"overflow\"])) == bool(val&(1<<flags[\"sign\"])), \"!Z && S==O\"\n        elif mnemo in (\"jge\", \"jnl\"):\n            taken, reason = bool(val&(1<<flags[\"sign\"])) == bool(val&(1<<flags[\"overflow\"])), \"S==O\"\n        elif mnemo in (\"jl\", \"jnge\"):\n            taken, reason = bool(val&(1<<flags[\"overflow\"]) != val&(1<<flags[\"sign\"])), \"S!=O\"\n        elif mnemo in (\"jle\", \"jng\"):\n            taken, reason = bool(val&(1<<flags[\"zero\"])) or bool(val&(1<<flags[\"overflow\"])) != bool(val&(1<<flags[\"sign\"])), \"Z || S!=O\"\n        elif mnemo in (\"jo\",):\n            taken, reason = bool(val&(1<<flags[\"overflow\"])), \"O\"\n        elif mnemo in (\"jno\",):\n            taken, reason = not val&(1<<flags[\"overflow\"]), \"!O\"\n        elif mnemo in (\"jpe\", \"jp\"):\n            taken, reason = bool(val&(1<<flags[\"parity\"])), \"P\"\n        elif mnemo in (\"jnp\", \"jpo\"):\n            taken, reason = not val&(1<<flags[\"parity\"]), \"!P\"\n        elif mnemo in (\"js\",):\n            taken, reason = bool(val&(1<<flags[\"sign\"])) != 0, \"S\"\n        elif mnemo in (\"jns\",):\n            taken, reason = not val&(1<<flags[\"sign\"]), \"!S\"\n        return taken, reason\n\n    def get_ra(self, insn: Instruction, frame: \"gdb.Frame\") -> int | None:\n        ra = None\n        if self.is_ret(insn):\n            ra = dereference(gef.arch.sp)\n        else:\n            older = frame.older()\n            if older:\n                ra = older.pc()\n        if ra is None:\n            return None\n        return to_unsigned_long(ra)\n\n    @classmethod\n    def mprotect_asm(cls, addr: int, size: int, perm: Permission) -> str:\n        _NR_mprotect = 125\n        insns = [\n            \"pushad\",\n            \"pushfd\",\n            f\"mov eax, {_NR_mprotect:d}\",\n            f\"mov ebx, {addr:d}\",\n            f\"mov ecx, {size:d}\",\n            f\"mov edx, {perm.value:d}\",\n            \"int 0x80\",\n            \"popfd\",\n            \"popad\",\n        ]\n        return \"; \".join(insns)\n\n    def get_ith_parameter(self, i: int, in_func: bool = True) -> tuple[str, int | None]:\n        if in_func:\n            i += 1  # Account for RA being at the top of the stack\n        sp = gef.arch.sp\n        sz = gef.arch.ptrsize\n        loc = sp + (i * sz)\n        val = gef.memory.read_integer(loc)\n        key = f\"[sp + {i * sz:#x}]\"\n        return key, val\n\n\nclass X86_64(X86):\n    aliases = (\"X86_64\", Elf.Abi.X86_64, \"i386:x86-64\")\n    arch = \"X86\"\n    mode = \"64\"\n\n    gpr_registers = (\n        \"$rax\", \"$rbx\", \"$rcx\", \"$rdx\", \"$rsp\", \"$rbp\", \"$rsi\", \"$rdi\", \"$rip\",\n        \"$r8\", \"$r9\", \"$r10\", \"$r11\", \"$r12\", \"$r13\", \"$r14\", \"$r15\", )\n    all_registers = gpr_registers + ( X86.flag_register, ) + X86.special_registers\n    return_register = \"$rax\"\n    function_parameters = [\"$rdi\", \"$rsi\", \"$rdx\", \"$rcx\", \"$r8\", \"$r9\"]\n    syscall_register = \"$rax\"\n    syscall_instructions = [\"syscall\"]\n    # We don't want to inherit x86's stack based param getter\n    get_ith_parameter = Architecture.get_ith_parameter\n    _ptrsize = 8\n\n    @classmethod\n    def mprotect_asm(cls, addr: int, size: int, perm: Permission) -> str:\n        _NR_mprotect = 10\n        insns = [\n            \"pushfq\",\n            \"push rax\",\n            \"push rdi\",\n            \"push rsi\",\n            \"push rdx\",\n            \"push rcx\",\n            \"push r11\",\n            f\"mov rax, {_NR_mprotect:d}\",\n            f\"mov rdi, {addr:d}\",\n            f\"mov rsi, {size:d}\",\n            f\"mov rdx, {perm.value:d}\",\n            \"syscall\",\n            \"pop r11\",\n            \"pop rcx\",\n            \"pop rdx\",\n            \"pop rsi\",\n            \"pop rdi\",\n            \"pop rax\",\n            \"popfq\",\n        ]\n        return \"; \".join(insns)\n\n    def canary_address(self) -> int:\n        return self.register(\"fs_base\") + 0x28\n\nclass PowerPC(Architecture):\n    aliases = (\"PowerPC\", Elf.Abi.POWERPC, \"PPC\")\n    arch = \"PPC\"\n    mode = \"PPC32\"\n\n    all_registers = (\n        \"$r0\", \"$r1\", \"$r2\", \"$r3\", \"$r4\", \"$r5\", \"$r6\", \"$r7\",\n        \"$r8\", \"$r9\", \"$r10\", \"$r11\", \"$r12\", \"$r13\", \"$r14\", \"$r15\",\n        \"$r16\", \"$r17\", \"$r18\", \"$r19\", \"$r20\", \"$r21\", \"$r22\", \"$r23\",\n        \"$r24\", \"$r25\", \"$r26\", \"$r27\", \"$r28\", \"$r29\", \"$r30\", \"$r31\",\n        \"$pc\", \"$msr\", \"$cr\", \"$lr\", \"$ctr\", \"$xer\", \"$trap\",)\n    instruction_length = 4\n    nop_insn = b\"\\x60\\x00\\x00\\x00\" # https://developer.ibm.com/articles/l-ppc/\n    return_register = \"$r0\"\n    flag_register: str = \"$cr\"\n    flags_table = {\n        3: \"negative[0]\",\n        2: \"positive[0]\",\n        1: \"equal[0]\",\n        0: \"overflow[0]\",\n        # cr7\n        31: \"less[7]\",\n        30: \"greater[7]\",\n        29: \"equal[7]\",\n        28: \"overflow[7]\",\n    }\n    function_parameters = (\"$i0\", \"$i1\", \"$i2\", \"$i3\", \"$i4\", \"$i5\")\n    syscall_register = \"$r0\"\n    syscall_instructions = (\"sc\",)\n    _ptrsize = 4\n\n\n    def flag_register_to_human(self, val: int | None = None) -> str:\n        # https://www.cebix.net/downloads/bebox/pem32b.pdf (% 2.1.3)\n        if val is None:\n            reg = self.flag_register\n            val = gef.arch.register(reg)\n        return flags_to_human(val, self.flags_table)\n\n    def is_call(self, insn: Instruction) -> bool:\n        return False\n\n    def is_ret(self, insn: Instruction) -> bool:\n        return insn.mnemonic == \"blr\"\n\n    def is_conditional_branch(self, insn: Instruction) -> bool:\n        mnemo = insn.mnemonic\n        branch_mnemos = {\"beq\", \"bne\", \"ble\", \"blt\", \"bgt\", \"bge\"}\n        return mnemo in branch_mnemos\n\n    def is_branch_taken(self, insn: Instruction) -> tuple[bool, str]:\n        mnemo = insn.mnemonic\n        flags = dict((self.flags_table[k], k) for k in self.flags_table)\n        val = gef.arch.register(self.flag_register)\n        taken, reason = False, \"\"\n        if mnemo == \"beq\":   taken, reason = bool(val&(1<<flags[\"equal[7]\"])), \"E\"\n        elif mnemo == \"bne\": taken, reason = val&(1<<flags[\"equal[7]\"]) == 0, \"!E\"\n        elif mnemo == \"ble\": taken, reason = bool(val&(1<<flags[\"equal[7]\"])) or bool(val&(1<<flags[\"less[7]\"])), \"E || L\"\n        elif mnemo == \"blt\": taken, reason = bool(val&(1<<flags[\"less[7]\"])), \"L\"\n        elif mnemo == \"bge\": taken, reason = bool(val&(1<<flags[\"equal[7]\"])) or bool(val&(1<<flags[\"greater[7]\"])), \"E || G\"\n        elif mnemo == \"bgt\": taken, reason = bool(val&(1<<flags[\"greater[7]\"])), \"G\"\n        return taken, reason\n\n    def get_ra(self, insn: Instruction, frame: \"gdb.Frame\") -> int | None:\n        ra = None\n        if self.is_ret(insn):\n            ra = gef.arch.register(\"$lr\")\n        else:\n            older = frame.older()\n            if older:\n                ra = to_unsigned_long(older.pc())\n        return ra\n\n    @classmethod\n    def mprotect_asm(cls, addr: int, size: int, perm: Permission) -> str:\n        # Ref: https://developer.ibm.com/articles/l-ppc/\n        _NR_mprotect = 125\n        insns = [\n            \"addi 1, 1, -16\",  # 1 = r1 = sp\n            \"stw 0, 0(1)\",\n            \"stw 3, 4(1)\",  # r0 = syscall_code | r3, r4, r5 = args\n            \"stw 4, 8(1)\",\n            \"stw 5, 12(1)\",\n            f\"li 0, {_NR_mprotect:d}\",\n            f\"lis 3, {addr:#x}@h\",\n            f\"ori 3, 3, {addr:#x}@l\",\n            f\"lis 4, {size:#x}@h\",\n            f\"ori 4, 4, {size:#x}@l\",\n            f\"li 5, {perm.value:d}\",\n            \"sc\",\n            \"lwz 0, 0(1)\",\n            \"lwz 3, 4(1)\",\n            \"lwz 4, 8(1)\",\n            \"lwz 5, 12(1)\",\n            \"addi 1, 1, 16\",\n        ]\n        return \";\".join(insns)\n\n\nclass PowerPC64(PowerPC):\n    aliases = (\"PowerPC64\", Elf.Abi.POWERPC64, \"PPC64\")\n    arch = \"PPC\"\n    mode = \"PPC64\"\n    _ptrsize = 8\n\n\nclass SPARC(Architecture):\n    \"\"\" Refs:\n    - https://www.cse.scu.edu/~atkinson/teaching/sp05/259/sparc.pdf\n    \"\"\"\n    aliases = (\"SPARC\", Elf.Abi.SPARC)\n    arch = \"SPARC\"\n    mode = \"\"\n\n    all_registers = (\n        \"$g0\", \"$g1\", \"$g2\", \"$g3\", \"$g4\", \"$g5\", \"$g6\", \"$g7\",\n        \"$o0\", \"$o1\", \"$o2\", \"$o3\", \"$o4\", \"$o5\", \"$o7\",\n        \"$l0\", \"$l1\", \"$l2\", \"$l3\", \"$l4\", \"$l5\", \"$l6\", \"$l7\",\n        \"$i0\", \"$i1\", \"$i2\", \"$i3\", \"$i4\", \"$i5\", \"$i7\",\n        \"$pc\", \"$npc\", \"$sp \", \"$fp \", \"$psr\",)\n    instruction_length = 4\n    nop_insn = b\"\\x00\\x00\\x00\\x00\"  # sethi 0, %g0\n    return_register = \"$i0\"\n    flag_register: str = \"$psr\"\n    flags_table = {\n        23: \"negative\",\n        22: \"zero\",\n        21: \"overflow\",\n        20: \"carry\",\n        7: \"supervisor\",\n        5: \"trap\",\n    }\n    function_parameters = (\"$o0 \", \"$o1 \", \"$o2 \", \"$o3 \", \"$o4 \", \"$o5 \", \"$o7 \",)\n    syscall_register = \"%g1\"\n    syscall_instructions = (\"t 0x10\",)\n\n    def flag_register_to_human(self, val: int | None = None) -> str:\n        # https://www.gaisler.com/doc/sparcv8.pdf\n        reg = self.flag_register\n        if val is None:\n            val = gef.arch.register(reg)\n        return flags_to_human(val, self.flags_table)\n\n    def is_call(self, insn: Instruction) -> bool:\n        return False\n\n    def is_ret(self, insn: Instruction) -> bool:\n        return insn.mnemonic == \"ret\"\n\n    def is_conditional_branch(self, insn: Instruction) -> bool:\n        mnemo = insn.mnemonic\n        # http://moss.csc.ncsu.edu/~mueller/codeopt/codeopt00/notes/condbranch.html\n        branch_mnemos = {\n            \"be\", \"bne\", \"bg\", \"bge\", \"bgeu\", \"bgu\", \"bl\", \"ble\", \"blu\", \"bleu\",\n            \"bneg\", \"bpos\", \"bvs\", \"bvc\", \"bcs\", \"bcc\"\n        }\n        return mnemo in branch_mnemos\n\n    def is_branch_taken(self, insn: Instruction) -> tuple[bool, str]:\n        mnemo = insn.mnemonic\n        flags = dict((self.flags_table[k], k) for k in self.flags_table)\n        val = gef.arch.register(self.flag_register)\n        taken, reason = False, \"\"\n\n        if mnemo == \"be\": taken, reason = bool(val&(1<<flags[\"zero\"])), \"Z\"\n        elif mnemo == \"bne\": taken, reason = bool(val&(1<<flags[\"zero\"])) == 0, \"!Z\"\n        elif mnemo == \"bg\": taken, reason = bool(val&(1<<flags[\"zero\"])) == 0 and (val&(1<<flags[\"negative\"]) == 0 or val&(1<<flags[\"overflow\"]) == 0), \"!Z && (!N || !O)\"\n        elif mnemo == \"bge\": taken, reason = val&(1<<flags[\"negative\"]) == 0 or val&(1<<flags[\"overflow\"]) == 0, \"!N || !O\"\n        elif mnemo == \"bgu\": taken, reason = val&(1<<flags[\"carry\"]) == 0 and val&(1<<flags[\"zero\"]) == 0, \"!C && !Z\"\n        elif mnemo == \"bgeu\": taken, reason = val&(1<<flags[\"carry\"]) == 0, \"!C\"\n        elif mnemo == \"bl\": taken, reason = bool(val&(1<<flags[\"negative\"])) and bool(val&(1<<flags[\"overflow\"])), \"N && O\"\n        elif mnemo == \"blu\": taken, reason = bool(val&(1<<flags[\"carry\"])), \"C\"\n        elif mnemo == \"ble\": taken, reason = bool(val&(1<<flags[\"zero\"])) or bool(val&(1<<flags[\"negative\"]) or val&(1<<flags[\"overflow\"])), \"Z || (N || O)\"\n        elif mnemo == \"bleu\": taken, reason = bool(val&(1<<flags[\"carry\"])) or bool(val&(1<<flags[\"zero\"])), \"C || Z\"\n        elif mnemo == \"bneg\": taken, reason = bool(val&(1<<flags[\"negative\"])), \"N\"\n        elif mnemo == \"bpos\": taken, reason = val&(1<<flags[\"negative\"]) == 0, \"!N\"\n        elif mnemo == \"bvs\": taken, reason = bool(val&(1<<flags[\"overflow\"])), \"O\"\n        elif mnemo == \"bvc\": taken, reason = val&(1<<flags[\"overflow\"]) == 0, \"!O\"\n        elif mnemo == \"bcs\": taken, reason = bool(val&(1<<flags[\"carry\"])), \"C\"\n        elif mnemo == \"bcc\": taken, reason = val&(1<<flags[\"carry\"]) == 0, \"!C\"\n        return taken, reason\n\n    def get_ra(self, insn: Instruction, frame: \"gdb.Frame\") -> int | None:\n        ra = None\n        if self.is_ret(insn):\n            ra = gef.arch.register(\"$o7\")\n        else:\n            older = frame.older()\n            if older:\n                ra = to_unsigned_long(older.pc())\n        return ra\n\n    @classmethod\n    def mprotect_asm(cls, addr: int, size: int, perm: Permission) -> str:\n        hi = (addr & 0xffff0000) >> 16\n        lo = (addr & 0x0000ffff)\n        _NR_mprotect = 125\n        insns = [\"add %sp, -16, %sp\",\n                 \"st %g1, [ %sp ]\", \"st %o0, [ %sp + 4 ]\",\n                 \"st %o1, [ %sp + 8 ]\", \"st %o2, [ %sp + 12 ]\",\n                 f\"sethi  %hi({hi}), %o0\",\n                 f\"or  %o0, {lo}, %o0\",\n                 \"clr  %o1\",\n                 \"clr  %o2\",\n                 f\"mov  {_NR_mprotect}, %g1\",\n                 \"t 0x10\",\n                 \"ld [ %sp ], %g1\", \"ld [ %sp + 4 ], %o0\",\n                 \"ld [ %sp + 8 ], %o1\", \"ld [ %sp + 12 ], %o2\",\n                 \"add %sp, 16, %sp\",]\n        return \"; \".join(insns)\n\n\nclass SPARC64(SPARC):\n    \"\"\"Refs:\n    - http://math-atlas.sourceforge.net/devel/assembly/abi_sysV_sparc.pdf\n    - https://cr.yp.to/2005-590/sparcv9.pdf\n    \"\"\"\n    aliases = (\"SPARC64\", Elf.Abi.SPARC64)\n    arch = \"SPARC\"\n    mode = \"V9\"\n\n    all_registers = [\n        \"$g0\", \"$g1\", \"$g2\", \"$g3\", \"$g4\", \"$g5\", \"$g6\", \"$g7\",\n        \"$o0\", \"$o1\", \"$o2\", \"$o3\", \"$o4\", \"$o5\", \"$o7\",\n        \"$l0\", \"$l1\", \"$l2\", \"$l3\", \"$l4\", \"$l5\", \"$l6\", \"$l7\",\n        \"$i0\", \"$i1\", \"$i2\", \"$i3\", \"$i4\", \"$i5\", \"$i7\",\n        \"$pc\", \"$npc\", \"$sp\", \"$fp\", \"$state\", ]\n\n    flag_register = \"$state\"  # sparcv9.pdf, 5.1.5.1 (ccr)\n    flags_table = {\n        35: \"negative\",\n        34: \"zero\",\n        33: \"overflow\",\n        32: \"carry\",\n    }\n\n    syscall_instructions = [\"t 0x6d\"]\n\n    @classmethod\n    def mprotect_asm(cls, addr: int, size: int, perm: Permission) -> str:\n        hi = (addr & 0xffff0000) >> 16\n        lo = (addr & 0x0000ffff)\n        _NR_mprotect = 125\n        insns = [\"add %sp, -16, %sp\",\n                 \"st %g1, [ %sp ]\", \"st %o0, [ %sp + 4 ]\",\n                 \"st %o1, [ %sp + 8 ]\", \"st %o2, [ %sp + 12 ]\",\n                 f\"sethi  %hi({hi}), %o0\",\n                 f\"or  %o0, {lo}, %o0\",\n                 \"clr  %o1\",\n                 \"clr  %o2\",\n                 f\"mov  {_NR_mprotect}, %g1\",\n                 \"t 0x6d\",\n                 \"ld [ %sp ], %g1\", \"ld [ %sp + 4 ], %o0\",\n                 \"ld [ %sp + 8 ], %o1\", \"ld [ %sp + 12 ], %o2\",\n                 \"add %sp, 16, %sp\",]\n        return \"; \".join(insns)\n\n\nclass MIPS(Architecture):\n    aliases = (\"MIPS\", Elf.Abi.MIPS)\n    arch = \"MIPS\"\n    mode = \"MIPS32\"\n\n    # https://vhouten.home.xs4all.nl/mipsel/r3000-isa.html\n    all_registers = (\n        \"$zero\", \"$at\", \"$v0\", \"$v1\", \"$a0\", \"$a1\", \"$a2\", \"$a3\",\n        \"$t0\", \"$t1\", \"$t2\", \"$t3\", \"$t4\", \"$t5\", \"$t6\", \"$t7\",\n        \"$s0\", \"$s1\", \"$s2\", \"$s3\", \"$s4\", \"$s5\", \"$s6\", \"$s7\",\n        \"$t8\", \"$t9\", \"$k0\", \"$k1\", \"$s8\", \"$pc\", \"$sp\", \"$hi\",\n        \"$lo\", \"$fir\", \"$ra\", \"$gp\", )\n    instruction_length = 4\n    _ptrsize = 4\n    nop_insn = b\"\\x00\\x00\\x00\\x00\"  # sll $0,$0,0\n    return_register = \"$v0\"\n    flag_register = \"$fcsr\"\n    flags_table = {}\n    function_parameters = (\"$a0\", \"$a1\", \"$a2\", \"$a3\")\n    syscall_register = \"$v0\"\n    syscall_instructions = (\"syscall\",)\n\n    def flag_register_to_human(self, val: int | None = None) -> str:\n        return Color.colorify(\"No flag register\", \"yellow underline\")\n\n    def is_call(self, insn: Instruction) -> bool:\n        return False\n\n    def is_ret(self, insn: Instruction) -> bool:\n        return insn.mnemonic == \"jr\" and insn.operands[0] == \"ra\"\n\n    def is_conditional_branch(self, insn: Instruction) -> bool:\n        mnemo = insn.mnemonic\n        branch_mnemos = {\"beq\", \"bne\", \"beqz\", \"bnez\", \"bgtz\", \"bgez\", \"bltz\", \"blez\"}\n        return mnemo in branch_mnemos\n\n    def is_branch_taken(self, insn: Instruction) -> tuple[bool, str]:\n        mnemo, ops = insn.mnemonic, insn.operands\n        taken, reason = False, \"\"\n\n        if mnemo == \"beq\":\n            taken, reason = gef.arch.register(ops[0]) == gef.arch.register(ops[1]), f\"{ops[0]} == {ops[1]}\"\n        elif mnemo == \"bne\":\n            taken, reason = gef.arch.register(ops[0]) != gef.arch.register(ops[1]), f\"{ops[0]} != {ops[1]}\"\n        elif mnemo == \"beqz\":\n            taken, reason = gef.arch.register(ops[0]) == 0, f\"{ops[0]} == 0\"\n        elif mnemo == \"bnez\":\n            taken, reason = gef.arch.register(ops[0]) != 0, f\"{ops[0]} != 0\"\n        elif mnemo == \"bgtz\":\n            taken, reason = gef.arch.register(ops[0]) > 0, f\"{ops[0]} > 0\"\n        elif mnemo == \"bgez\":\n            taken, reason = gef.arch.register(ops[0]) >= 0, f\"{ops[0]} >= 0\"\n        elif mnemo == \"bltz\":\n            taken, reason = gef.arch.register(ops[0]) < 0, f\"{ops[0]} < 0\"\n        elif mnemo == \"blez\":\n            taken, reason = gef.arch.register(ops[0]) <= 0, f\"{ops[0]} <= 0\"\n        return taken, reason\n\n    def get_ra(self, insn: Instruction, frame: \"gdb.Frame\") -> int | None:\n        ra = None\n        if self.is_ret(insn):\n            ra = gef.arch.register(\"$ra\")\n        else:\n            older = frame.older()\n            if older:\n                ra = to_unsigned_long(older.pc())\n        return ra\n\n    @classmethod\n    def mprotect_asm(cls, addr: int, size: int, perm: Permission) -> str:\n        _NR_mprotect = 4125\n        insns = [\"addi $sp, $sp, -16\",\n                 \"sw $v0, 0($sp)\", \"sw $a0, 4($sp)\",\n                 \"sw $a3, 8($sp)\", \"sw $a3, 12($sp)\",\n                 f\"li $v0, {_NR_mprotect:d}\",\n                 f\"li $a0, {addr:d}\",\n                 f\"li $a1, {size:d}\",\n                 f\"li $a2, {perm.value:d}\",\n                 \"syscall\",\n                 \"lw $v0, 0($sp)\", \"lw $a1, 4($sp)\",\n                 \"lw $a3, 8($sp)\", \"lw $a3, 12($sp)\",\n                 \"addi $sp, $sp, 16\",]\n        return \"; \".join(insns)\n\n\nclass MIPS64(MIPS):\n    aliases = (\"MIPS64\",)\n    arch = \"MIPS\"\n    mode = \"MIPS64\"\n    _ptrsize = 8\n\n    @staticmethod\n    def supports_gdb_arch(gdb_arch: str) -> bool | None:\n        if not gef.binary or not isinstance(gef.binary, Elf):\n            return False\n        return gdb_arch.startswith(\"mips\") and gef.binary.e_class == Elf.Class.ELF_64_BITS\n\n\ndef copy_to_clipboard(data: bytes) -> None:\n    \"\"\"Helper function to submit data to the clipboard\"\"\"\n    if sys.platform == \"linux\":\n        xclip = which(\"xclip\")\n        prog = [xclip, \"-selection\", \"clipboard\", \"-i\"]\n    elif sys.platform == \"darwin\":\n        pbcopy = which(\"pbcopy\")\n        prog = [pbcopy]\n    else:\n        raise NotImplementedError(\"copy: Unsupported OS\")\n\n    with subprocess.Popen(prog, stdin=subprocess.PIPE) as p:\n        assert p.stdin\n        p.stdin.write(data)\n        p.stdin.close()\n        p.wait()\n    return\n\n\ndef use_stdtype() -> str:\n    if is_32bit(): return \"uint32_t\"\n    elif is_64bit(): return \"uint64_t\"\n    return \"uint16_t\"\n\n\ndef use_default_type() -> str:\n    if is_32bit(): return \"unsigned int\"\n    elif is_64bit(): return \"unsigned long\"\n    return \"unsigned short\"\n\n\ndef use_golang_type() -> str:\n    if is_32bit(): return \"uint32\"\n    elif is_64bit(): return \"uint64\"\n    return \"uint16\"\n\n\ndef use_rust_type() -> str:\n    if is_32bit(): return \"u32\"\n    elif is_64bit(): return \"u64\"\n    return \"u16\"\n\n\ndef to_unsigned_long(v: gdb.Value) -> int:\n    \"\"\"Cast a gdb.Value to unsigned long.\"\"\"\n    mask = (1 << (gef.arch.ptrsize*8)) - 1\n    return int(v.cast(gdb.Value(mask).type)) & mask\n\n\ndef get_path_from_info_proc() -> str | None:\n    for x in (gdb.execute(\"info proc\", to_string=True) or \"\").splitlines():\n        if x.startswith(\"exe = \"):\n            return x.split(\" = \")[1].replace(\"'\", \"\")\n    return None\n\n\n@deprecated(\"Use `gef.session.os`\")\ndef get_os() -> str:\n    return gef.session.os\n\n\n@lru_cache()\ndef is_qemu() -> bool:\n    if not is_remote_debug():\n        return False\n    response = gdb.execute(\"maintenance packet Qqemu.sstepbits\", to_string=True, from_tty=False) or \"\"\n    return \"ENABLE=\" in response\n\n\n@lru_cache()\ndef is_qemu_usermode() -> bool:\n    if not is_qemu():\n        return False\n    response = gdb.execute(\"maintenance packet qOffsets\", to_string=True, from_tty=False) or \"\"\n    return \"Text=\" in response\n\n\n@lru_cache()\ndef is_qemu_system() -> bool:\n    if not is_qemu():\n        return False\n    response = gdb.execute(\"maintenance packet qOffsets\", to_string=True, from_tty=False) or \"\"\n    return \"received: \\\"\\\"\" in response\n\n\ndef is_target_coredump() -> bool:\n    global gef\n    if gef.session.coredump_mode is not None:\n        return gef.session.coredump_mode\n    lines = (gdb.execute(\"maintenance info section\", to_string=True) or \"\").splitlines()\n    is_coredump_mode = any(map(lambda line: line.startswith(\"Core file: \"), lines))\n    gef.session.coredump_mode = is_coredump_mode\n    return is_coredump_mode\n\n\ndef get_filepath() -> str | None:\n    \"\"\"Return the local absolute path of the file currently debugged.\"\"\"\n    if gef.session.remote:\n        return str(gef.session.remote.lfile.absolute())\n    if gef.session.file:\n        return str(gef.session.file.absolute())\n    return None\n\n\ndef get_function_length(sym: str) -> int:\n    \"\"\"Attempt to get the length of the raw bytes of a function.\"\"\"\n    dis = (gdb.execute(f\"disassemble '{sym}'\", to_string=True) or \"\").splitlines()\n    start_addr = int(dis[1].split()[0], 16)\n    end_addr = int(dis[-2].split()[0], 16)\n    return end_addr - start_addr\n\n\n@lru_cache()\ndef get_info_files() -> list[Zone]:\n    \"\"\"Retrieve all the files loaded by debuggee.\"\"\"\n    lines = (gdb.execute(\"info files\", to_string=True) or \"\").splitlines()\n    infos = []\n    for line in lines:\n        line = line.strip()\n        if not line:\n            break\n\n        if not line.startswith(\"0x\"):\n            continue\n\n        blobs = [x.strip() for x in line.split(\" \")]\n        addr_start = int(blobs[0], 16)\n        addr_end = int(blobs[2], 16)\n        section_name = blobs[4]\n\n        if len(blobs) == 7:\n            filename = blobs[6]\n        else:\n            filename = get_filepath()\n\n        infos.append(Zone(section_name, addr_start, addr_end, filename))\n    return infos\n\n\ndef process_lookup_address(address: int) -> Section | None:\n    \"\"\"Look up for an address in memory.\n    Return an Address object if found, None otherwise.\"\"\"\n    if not is_alive():\n        err(\"Process is not running\")\n        return None\n\n    if is_x86():\n        if is_in_x86_kernel(address):\n            return None\n\n    for sect in gef.memory.maps:\n        if sect.page_start <= address < sect.page_end:\n            return sect\n\n    return None\n\n\n@lru_cache()\ndef process_lookup_path(name: str, perm: Permission = Permission.ALL) -> Section | None:\n    \"\"\"Look up for a path in the process memory mapping.\n    Return a Section object if found, None otherwise.\"\"\"\n    if not is_alive():\n        err(\"Process is not running\")\n        return None\n\n    matches: dict[str, Section] = dict()\n    for sect in gef.memory.maps:\n        filename = pathlib.Path(sect.path).name\n\n        if name in filename and sect.permission & perm:\n            if sect.path not in matches.keys():\n                matches[sect.path] = sect\n\n    matches_count = len(matches)\n\n    if matches_count == 0:\n        return None\n\n    if matches_count > 1:\n        warn(f\"{matches_count} matches! You should probably refine your search!\")\n\n        for x in matches.keys():\n            warn(f\"- '{x}'\")\n\n        warn(\"Returning the first match\")\n\n    return list(matches.values())[0]\n\n\n@lru_cache()\ndef file_lookup_name_path(name: str, path: str) -> Zone | None:\n    \"\"\"Look up a file by name and path.\n    Return a Zone object if found, None otherwise.\"\"\"\n    for xfile in get_info_files():\n        if path == xfile.filename and name == xfile.name:\n            return xfile\n    return None\n\n\n@lru_cache()\ndef file_lookup_address(address: int) -> Zone | None:\n    \"\"\"Look up for a file by its address.\n    Return a Zone object if found, None otherwise.\"\"\"\n    for info in get_info_files():\n        if info.zone_start <= address < info.zone_end:\n            return info\n    return None\n\n\n@lru_cache()\ndef lookup_address(address: int) -> Address:\n    \"\"\"Try to find the address in the process address space.\n    Return an Address object, with validity flag set based on success.\"\"\"\n    sect = process_lookup_address(address)\n    info = file_lookup_address(address)\n    if sect is None and info is None:\n        # i.e. there is no info on this address\n        return Address(value=address, valid=False)\n    return Address(value=address, section=sect, info=info)\n\n\ndef xor(data: ByteString, key: str) -> bytearray:\n    \"\"\"Return `data` xor-ed with `key`.\"\"\"\n    key_raw = binascii.unhexlify(key.lstrip(\"0x\"))\n    return bytearray(x ^ y for x, y in zip(data, itertools.cycle(key_raw)))\n\n\ndef is_hex(pattern: str) -> bool:\n    \"\"\"Return whether provided string is a hexadecimal value.\"\"\"\n    if not pattern.lower().startswith(\"0x\"):\n        return False\n    return len(pattern) % 2 == 0 and all(c in string.hexdigits for c in pattern[2:])\n\n\ndef continue_handler(_: \"gdb.ContinueEvent\") -> None:\n    \"\"\"GDB event handler for new object continue cases.\"\"\"\n    return\n\n\ndef hook_stop_handler(_: \"gdb.StopEvent\") -> None:\n    \"\"\"GDB event handler for stop cases.\"\"\"\n    reset_all_caches()\n    gdb.execute(\"context\")\n    return\n\n\ndef new_objfile_handler(evt: \"gdb.NewObjFileEvent | None\") -> None:\n    \"\"\"GDB event handler for new object file cases.\"\"\"\n    reset_all_caches()\n    progspace = gdb.current_progspace()\n    if evt:\n        path = evt.new_objfile.filename or \"\"\n    elif progspace:\n        path = progspace.filename\n    else:\n        raise RuntimeError(\"Cannot determine file path\")\n    try:\n        if gef.session.root and path.startswith(\"target:\"):\n            # If the process is in a container, replace the \"target:\" prefix\n            # with the actual root directory of the process.\n            path = path.replace(\"target:\", str(gef.session.root), 1)\n        target = pathlib.Path(path)\n        FileFormatClasses = list(filter(lambda fmtcls: fmtcls.is_valid(target), __registered_file_formats__))\n        GuessedFileFormatClass : Type[FileFormat] = FileFormatClasses.pop() if len(FileFormatClasses) else Elf\n        binary = GuessedFileFormatClass(target)\n        if not gef.binary:\n            gef.binary = binary\n            reset_architecture()\n        else:\n            gef.session.modules.append(binary)\n    except FileNotFoundError as fne:\n        # Linux automatically maps the vDSO into our process, and GDB\n        # will give us the string 'system-supplied DSO' as a path.\n        # This is normal, so we shouldn't warn the user about it\n        if \"system-supplied DSO\" not in path:\n            warn(f\"Failed to find objfile or not a valid file format: {str(fne)}\")\n    except RuntimeError as re:\n        warn(f\"Not a valid file format: {str(re)}\")\n    return\n\n\ndef exit_handler(_: \"gdb.ExitedEvent\") -> None:\n    \"\"\"GDB event handler for exit cases.\"\"\"\n    global gef\n    # flush the caches\n    reset_all_caches()\n\n    # disconnect properly the remote session\n    gef.session.qemu_mode = False\n    if gef.session.remote:\n        gef.session.remote.close()\n        del gef.session.remote\n        gef.session.remote = None\n        gef.session.remote_initializing = False\n\n    # if `autosave_breakpoints_file` setting is configured, save the breakpoints to disk\n    setting = (gef.config[\"gef.autosave_breakpoints_file\"] or \"\").strip()\n    if not setting:\n        return\n\n    bkp_fpath = pathlib.Path(setting).expanduser().absolute()\n    if bkp_fpath.exists():\n        warn(f\"{bkp_fpath} exists, content will be overwritten\")\n\n    with bkp_fpath.open(\"w\") as fd:\n        for bp in list(gdb.breakpoints()):\n            if not bp.enabled or not bp.is_valid:\n                continue\n            fd.write(f\"{'t' if bp.temporary else ''}break {bp.location}\\n\")\n    return\n\n\ndef memchanged_handler(_: \"gdb.MemoryChangedEvent\") -> None:\n    \"\"\"GDB event handler for mem changes cases.\"\"\"\n    reset_all_caches()\n    return\n\n\ndef regchanged_handler(_: \"gdb.RegisterChangedEvent\") -> None:\n    \"\"\"GDB event handler for reg changes cases.\"\"\"\n    reset_all_caches()\n    return\n\n\ndef get_terminal_size() -> tuple[int, int]:\n    \"\"\"Return the current terminal size.\"\"\"\n    if is_debug():\n        return 600, 100\n\n    if platform.system() == \"Windows\":\n        from ctypes import create_string_buffer, windll # type: ignore\n        hStdErr = -12\n        herr = windll.kernel32.GetStdHandle(hStdErr)\n        csbi = create_string_buffer(22)\n        res = windll.kernel32.GetConsoleScreenBufferInfo(herr, csbi)\n        if res:\n            _, _, _, _, _, left, top, right, bottom, _, _ = struct.unpack(\"hhhhHhhhhhh\", csbi.raw)\n            tty_columns = right - left + 1\n            tty_rows = bottom - top + 1\n            return tty_rows, tty_columns\n        else:\n            return 600, 100\n    else:\n        import fcntl\n        import termios\n        try:\n            tty_rows, tty_columns = struct.unpack(\"hh\", fcntl.ioctl(1, termios.TIOCGWINSZ, \"1234\")) # type: ignore\n            return tty_rows, tty_columns\n        except OSError:\n            return 600, 100\n\n\n@lru_cache()\ndef is_64bit() -> bool:\n    \"\"\"Checks if current target is 64bit.\"\"\"\n    return gef.arch.ptrsize == 8\n\n\n@lru_cache()\ndef is_32bit() -> bool:\n    \"\"\"Checks if current target is 32bit.\"\"\"\n    return gef.arch.ptrsize == 4\n\n\n@lru_cache()\ndef is_x86_64() -> bool:\n    \"\"\"Checks if current target is x86-64\"\"\"\n    return Elf.Abi.X86_64 in gef.arch.aliases\n\n\n@lru_cache()\ndef is_x86_32():\n    \"\"\"Checks if current target is an x86-32\"\"\"\n    return Elf.Abi.X86_32 in gef.arch.aliases\n\n\n@lru_cache()\ndef is_x86() -> bool:\n    return is_x86_32() or is_x86_64()\n\n\n@lru_cache()\ndef is_arch(arch: Elf.Abi) -> bool:\n    return arch in gef.arch.aliases\n\n\ndef reset_architecture(arch: str | None = None) -> None:\n    \"\"\"Sets the current architecture.\n    If an architecture is explicitly specified by parameter, try to use that one. If this fails, an `OSError`\n    exception will occur.\n    If no architecture is specified, then GEF will attempt to determine automatically based on the current\n    ELF target. If this fails, an `OSError` exception will occur.\n    \"\"\"\n    global gef\n    arches = __registered_architectures__\n\n    # check if the architecture is forced by parameter\n    if arch:\n        try:\n            gef.arch = arches[arch.lower()]()\n            gef.arch_reason = \"The architecture has been set manually\"\n        except KeyError:\n            raise OSError(f\"Specified arch {arch.upper()} is not supported\")\n        return\n\n    # check for bin running\n    if is_alive():\n        gdb_arch = gdb.selected_frame().architecture().name()\n        preciser_arch = next((a for a in arches.values() if a.supports_gdb_arch(gdb_arch)), None)\n        if preciser_arch:\n            gef.arch = preciser_arch()\n            gef.arch_reason = \"The architecture has been detected by GDB\"\n            return\n\n    # last resort, use the info from elf header to find it from the known architectures\n    if gef.binary and isinstance(gef.binary, Elf):\n        try:\n            gef.arch = arches[gef.binary.e_machine]()\n            gef.arch_reason = \"The architecture has been detected via the ELF headers\"\n        except KeyError:\n            raise OSError(f\"CPU type is currently not supported: {gef.binary.e_machine}\")\n        return\n\n    warn(\"Did not find any way to guess the correct architecture :(\")\n\n\n@lru_cache()\ndef cached_lookup_type(_type: str) -> gdb.Type | None:\n    try:\n        return gdb.lookup_type(_type).strip_typedefs()\n    except RuntimeError:\n        return None\n\n\n@deprecated(\"Use `gef.arch.ptrsize` instead\")\ndef get_memory_alignment(in_bits: bool = False) -> int:\n    \"\"\"Try to determine the size of a pointer on this system.\n    First, try to parse it out of the ELF header.\n    Next, use the size of `size_t`.\n    Finally, try the size of $pc.\n    If `in_bits` is set to True, the result is returned in bits, otherwise in\n    bytes.\"\"\"\n    res = cached_lookup_type(\"size_t\")\n    if res is not None:\n        return res.sizeof if not in_bits else res.sizeof * 8\n\n    try:\n        return gdb.parse_and_eval(\"$pc\").type.sizeof\n    except Exception:\n        pass\n\n    raise OSError(\"GEF is running under an unsupported mode\")\n\n\ndef clear_screen(tty: str = \"\") -> None:\n    \"\"\"Clear the screen.\"\"\"\n    clean_sequence = \"\\x1b[H\\x1b[J\"\n    if tty:\n        pathlib.Path(tty).write_text(clean_sequence)\n    else:\n        sys.stdout.write(clean_sequence)\n\n    return\n\n\ndef format_address(addr: int) -> str:\n    \"\"\"Format the address according to its size.\"\"\"\n    memalign_size = gef.arch.ptrsize\n    addr = align_address(addr)\n    return f\"0x{addr:016x}\" if memalign_size == 8 else f\"0x{addr:08x}\"\n\n\ndef format_address_spaces(addr: int, left: bool = True) -> str:\n    \"\"\"Format the address according to its size, but with spaces instead of zeroes.\"\"\"\n    width = gef.arch.ptrsize * 2 + 2\n    addr = align_address(addr)\n\n    if not left:\n        return f\"{addr:#x}\".rjust(width)\n\n    return f\"{addr:#x}\".ljust(width)\n\n\ndef align_address(address: int) -> int:\n    \"\"\"Align the provided address to the process's native length.\"\"\"\n    return address & 0xFFFFFFFFFFFFFFFF if gef.arch.ptrsize == 8 else address & 0xFFFFFFFF\n\n\ndef align_address_to_size(address: int, align: int) -> int:\n    \"\"\"Align the address to the given size.\"\"\"\n    return address + ((align - (address % align)) % align)\n\n\ndef align_address_to_page(address: int) -> int:\n    \"\"\"Align the address to a page.\"\"\"\n    a = align_address(address) >> DEFAULT_PAGE_ALIGN_SHIFT\n    return a << DEFAULT_PAGE_ALIGN_SHIFT\n\n\ndef parse_address(address: str) -> int:\n    \"\"\"Parse an address and return it as an Integer.\"\"\"\n    if is_hex(address):\n        return int(address, 16)\n    return int(gdb.parse_and_eval(address))\n\n\ndef is_in_x86_kernel(address: int) -> bool:\n    address = align_address(address)\n    memalign = gef.arch.ptrsize*8 - 1\n    return (address >> memalign) == 0xF\n\n\ndef is_remote_debug() -> bool:\n    \"\"\"\"Return True is the current debugging session is running through GDB remote session.\"\"\"\n    return gef.session.remote_initializing or gef.session.remote is not None\n\n\ndef de_bruijn(alphabet: bytes, n: int) -> Generator[int, None, None]:\n    \"\"\"De Bruijn sequence for alphabet and subsequences of length n (for compat. w/ pwnlib).\"\"\"\n    k = len(alphabet)\n    a = [0] * k * n\n\n    def db(t: int, p: int) -> Generator[int, None, None]:\n        if t > n:\n            if n % p == 0:\n                for j in range(1, p + 1):\n                    yield alphabet[a[j]]\n        else:\n            a[t] = a[t - p]\n            yield from db(t + 1, p)\n\n            for j in range(a[t - p] + 1, k):\n                a[t] = j\n                yield from db(t + 1, t)\n\n    return db(1, 1)\n\n\ndef generate_cyclic_pattern(length: int, cycle: int = 4) -> bytearray:\n    \"\"\"Create a `length` byte bytearray of a de Bruijn cyclic pattern.\"\"\"\n    charset = bytearray(b\"abcdefghijklmnopqrstuvwxyz\")\n    return bytearray(itertools.islice(de_bruijn(charset, cycle), length))\n\n\ndef safe_parse_and_eval(value: str) -> \"gdb.Value | None\":\n    \"\"\"GEF wrapper for gdb.parse_and_eval(): this function returns None instead of raising\n    gdb.error if the eval failed.\"\"\"\n    try:\n        return gdb.parse_and_eval(value)\n    except gdb.error as e:\n        dbg(f\"gdb.parse_and_eval() failed, reason: {str(e)}\")\n    return None\n\n\n@lru_cache()\ndef dereference(addr: int) -> \"gdb.Value | None\":\n    \"\"\"GEF wrapper for gdb dereference function.\"\"\"\n    try:\n        ulong_t = cached_lookup_type(use_stdtype()) or \\\n                  cached_lookup_type(use_default_type()) or \\\n                  cached_lookup_type(use_golang_type()) or \\\n                  cached_lookup_type(use_rust_type())\n        if not ulong_t:\n            raise gdb.MemoryError(\"Failed to determine unsigned long type\")\n        unsigned_long_type = ulong_t.pointer()\n        res = gdb.Value(addr).cast(unsigned_long_type).dereference()\n        # GDB does lazy fetch by default so we need to force access to the value\n        res.fetch_lazy()\n        return res\n    except gdb.MemoryError as e:\n        dbg(str(e))\n    return None\n\n\ndef gef_convenience(value: str |  bytes) -> str:\n    \"\"\"Defines a new convenience value.\"\"\"\n    global gef\n    var_name = f\"$_gef{gef.session.convenience_vars_index:d}\"\n    gef.session.convenience_vars_index += 1\n    if isinstance(value, str):\n        gdb.execute(f\"\"\"set {var_name} = \"{value}\" \"\"\")\n    elif isinstance(value, bytes):\n        value_as_array = \"{\" + \", \".join([f\"0x{b:02x}\" for b in value]) + \"}\"\n        gdb.execute(f\"\"\"set {var_name} = {value_as_array} \"\"\")\n    else:\n        raise TypeError\n    return var_name\n\n\ndef parse_string_range(s: str) -> Iterator[int]:\n    \"\"\"Parses an address range (e.g. 0x400000-0x401000)\"\"\"\n    addrs = s.split(\"-\")\n    return map(lambda x: int(x, 16), addrs)\n\n\n@lru_cache()\ndef is_syscall(instruction: Instruction | int) -> bool:\n    \"\"\"Checks whether an instruction or address points to a system call.\"\"\"\n    if isinstance(instruction, int):\n        instruction = gef_current_instruction(instruction)\n    insn_str = instruction.mnemonic\n    if len(instruction.operands):\n        insn_str += f\" {', '.join(instruction.operands)}\"\n    return insn_str in gef.arch.syscall_instructions\n\n\n#\n# Deprecated API\n#\n\n@deprecated(\"Use `gef.session.pie_breakpoints[num]`\")\ndef gef_get_pie_breakpoint(num: int) -> \"PieVirtualBreakpoint\":\n    return gef.session.pie_breakpoints[num]\n\n\n@deprecated(\"Use `str(gef.arch.endianness)` instead\")\ndef endian_str() -> str:\n    return str(gef.arch.endianness)\n\n\n@deprecated(\"Use `gef.config[key]`\")\ndef get_gef_setting(name: str) -> Any:\n    return gef.config[name]\n\n\n@deprecated(\"Use `gef.config[key] = value`\")\ndef set_gef_setting(name: str, value: Any) -> None:\n    gef.config[name] = value\n    return\n\n\n@deprecated(\"Use `gef.session.pagesize`\")\ndef gef_getpagesize() -> int:\n    return gef.session.pagesize\n\n\n@deprecated(\"Use `gef.session.canary`\")\ndef gef_read_canary() -> tuple[int, int] | None:\n    return gef.session.canary\n\n\n@deprecated(\"Use `gef.session.pid`\")\ndef get_pid() -> int:\n    return gef.session.pid\n\n\n@deprecated(\"Use `gef.session.file.name`\")\ndef get_filename() -> str:\n    assert gef.session.file\n    return gef.session.file.name\n\n\n@deprecated(\"Use `gef.heap.main_arena`\")\ndef get_glibc_arena() -> GlibcArena | None:\n    return gef.heap.main_arena\n\n\n@deprecated(\"Use `gef.arch.register(regname)`\")\ndef get_register(regname) -> int | None:\n    return gef.arch.register(regname)\n\n\n@deprecated(\"Use `gef.memory.maps`\")\ndef get_process_maps() -> list[Section]:\n    return gef.memory.maps\n\n\n@deprecated(\"Use `reset_architecture`\")\ndef set_arch(arch: str | None = None, _: str | None = None) -> None:\n    return reset_architecture(arch)\n\n#\n# GDB event hooking\n#\n\n@only_if_events_supported(\"cont\")\ndef gef_on_continue_hook(func: Callable[[\"gdb.ContinueEvent\"], None]) -> None:\n    gdb.events.cont.connect(func)\n\n\n@only_if_events_supported(\"cont\")\ndef gef_on_continue_unhook(func: Callable[[\"gdb.ThreadEvent\"], None]) -> None:\n    gdb.events.cont.disconnect(func)\n\n\n@only_if_events_supported(\"stop\")\ndef gef_on_stop_hook(func: Callable[[\"gdb.StopEvent\"], None]) -> None:\n    gdb.events.stop.connect(func)\n\n\n@only_if_events_supported(\"stop\")\ndef gef_on_stop_unhook(func: Callable[[\"gdb.StopEvent\"], None]) -> None:\n    gdb.events.stop.disconnect(func)\n\n\n@only_if_events_supported(\"exited\")\ndef gef_on_exit_hook(func: Callable[[\"gdb.ExitedEvent\"], None]) -> None:\n    gdb.events.exited.connect(func)\n\n\n@only_if_events_supported(\"exited\")\ndef gef_on_exit_unhook(func: Callable[[\"gdb.ExitedEvent\"], None]) -> None:\n    gdb.events.exited.disconnect(func)\n\n\n@only_if_events_supported(\"new_objfile\")\ndef gef_on_new_hook(func: Callable[[\"gdb.NewObjFileEvent\"], None]) -> None:\n    gdb.events.new_objfile.connect(func)\n\n\n@only_if_events_supported(\"new_objfile\")\ndef gef_on_new_unhook(func: Callable[[\"gdb.NewObjFileEvent\"], None]) -> None:\n    gdb.events.new_objfile.disconnect(func)\n\n\n@only_if_events_supported(\"clear_objfiles\")\ndef gef_on_unload_objfile_hook(func: Callable[[\"gdb.ClearObjFilesEvent\"], None]) -> None:\n    gdb.events.clear_objfiles.connect(func)\n\n\n@only_if_events_supported(\"clear_objfiles\")\ndef gef_on_unload_objfile_unhook(func: Callable[[\"gdb.ClearObjFilesEvent\"], None]) -> None:\n    gdb.events.clear_objfiles.disconnect(func)\n\n\n@only_if_events_supported(\"memory_changed\")\ndef gef_on_memchanged_hook(func: Callable[[\"gdb.MemoryChangedEvent\"], None]) -> None:\n    gdb.events.memory_changed.connect(func)\n\n\n@only_if_events_supported(\"memory_changed\")\ndef gef_on_memchanged_unhook(func: Callable[[\"gdb.MemoryChangedEvent\"], None]) -> None:\n    gdb.events.memory_changed.disconnect(func)\n\n\n@only_if_events_supported(\"register_changed\")\ndef gef_on_regchanged_hook(func: Callable[[\"gdb.RegisterChangedEvent\"], None]) -> None:\n    gdb.events.register_changed.connect(func)\n\n\n@only_if_events_supported(\"register_changed\")\ndef gef_on_regchanged_unhook(func: Callable[[\"gdb.RegisterChangedEvent\"], None]) -> None:\n    gdb.events.register_changed.disconnect(func)\n\n\n#\n# Virtual breakpoints\n#\n\nclass PieVirtualBreakpoint:\n    \"\"\"PIE virtual breakpoint (not real breakpoint).\"\"\"\n\n    def __init__(self, set_func: Callable[[int], str], vbp_num: int, addr: int) -> None:\n        # set_func(base): given a base address return a\n        # \"set breakpoint\" gdb command string\n        self.set_func = set_func\n        self.vbp_num = vbp_num\n        # breakpoint num, 0 represents not instantiated yet\n        self.bp_num = 0\n        self.bp_addr = 0\n        # this address might be a symbol, just to know where to break\n        if isinstance(addr, int):\n            self.addr: int |  str = hex(addr)\n        else:\n            self.addr = addr\n        return\n\n    def instantiate(self, base: int) -> None:\n        if self.bp_num:\n            self.destroy()\n\n        try:\n            res = gdb.execute(self.set_func(base), to_string=True) or \"\"\n            if not res: return\n        except gdb.error as e:\n            err(str(e))\n            return\n\n        if \"Breakpoint\" not in res:\n            err(res)\n            return\n\n        res_list = res.split()\n        self.bp_num = res_list[1]\n        self.bp_addr = res_list[3]\n        return\n\n    def destroy(self) -> None:\n        if not self.bp_num:\n            err(\"Destroy PIE breakpoint not even set\")\n            return\n        gdb.execute(f\"delete {self.bp_num}\")\n        self.bp_num = 0\n        return\n\n\n#\n# Breakpoints\n#\n\nclass FormatStringBreakpoint(gdb.Breakpoint):\n    \"\"\"Inspect stack for format string.\"\"\"\n    def __init__(self, spec: str, num_args: int) -> None:\n        super().__init__(spec, type=gdb.BP_BREAKPOINT, internal=False)\n        self.num_args = num_args\n        self.enabled = True\n        return\n\n    def stop(self) -> bool:\n        reset_all_caches()\n        msg = []\n        ptr, addr = gef.arch.get_ith_parameter(self.num_args)\n        addr = lookup_address(addr)\n\n        if not addr.valid:\n            return False\n\n        if addr.section.is_writable():\n            content = gef.memory.read_cstring(addr.value)\n            name = addr.info.name if addr.info else addr.section.path\n            msg.append(Color.colorify(\"Format string helper\", \"yellow bold\"))\n            msg.append(f\"Possible insecure format string: {self.location}('{ptr}' {RIGHT_ARROW} {addr.value:#x}: '{content}')\")\n            msg.append(f\"Reason: Call to '{self.location}()' with format string argument in position \"\n                       f\"#{self.num_args:d} is in page {addr.section.page_start:#x} ({name}) that has write permission\")\n            push_context_message(\"warn\", \"\\n\".join(msg))\n            return True\n\n        return False\n\n\nclass StubBreakpoint(gdb.Breakpoint):\n    \"\"\"Create a breakpoint to permanently disable a call (fork/alarm/signal/etc.).\"\"\"\n\n    def __init__(self, func: str, retval: int | None) -> None:\n        super().__init__(func, gdb.BP_BREAKPOINT, internal=False)\n        self.func = func\n        self.retval = retval\n\n        m = f\"All calls to '{self.func}' will be skipped\"\n        if self.retval is not None:\n            m += f\" (with return value set to {self.retval:#x})\"\n        info(m)\n        return\n\n    def stop(self) -> bool:\n        size = \"long\" if gef.arch.ptrsize == 8 else \"int\"\n        gdb.execute(f\"return (unsigned {size}){self.retval:#x}\")\n        ok(f\"Ignoring call to '{self.func}' \"\n           f\"(setting return value to {self.retval:#x})\")\n        return False\n\n\nclass ChangePermissionBreakpoint(gdb.Breakpoint):\n    \"\"\"When hit, this temporary breakpoint will restore the original code, and position\n    $pc correctly.\"\"\"\n\n    def __init__(self, loc: str, code: ByteString, pc: int) -> None:\n        super().__init__(loc, gdb.BP_BREAKPOINT, internal=False)\n        self.original_code = code\n        self.original_pc = pc\n        return\n\n    def stop(self) -> bool:\n        info(\"Restoring original context\")\n        gef.memory.write(self.original_pc, self.original_code, len(self.original_code))\n        info(\"Restoring $pc\")\n        gdb.execute(f\"set $pc = {self.original_pc:#x}\")\n        return True\n\n\nclass TraceMallocBreakpoint(gdb.Breakpoint):\n    \"\"\"Track allocations done with malloc() or calloc().\"\"\"\n\n    def __init__(self, name: str) -> None:\n        super().__init__(name, gdb.BP_BREAKPOINT, internal=True)\n        self.silent = True\n        self.name = name\n        return\n\n    def stop(self) -> bool:\n        reset_all_caches()\n        _, size = gef.arch.get_ith_parameter(0)\n        assert size\n        self.retbp = TraceMallocRetBreakpoint(size, self.name)\n        return False\n\n\nclass TraceMallocRetBreakpoint(gdb.FinishBreakpoint):\n    \"\"\"Internal temporary breakpoint to retrieve the return value of malloc().\"\"\"\n\n    def __init__(self, size: int, name: str) -> None:\n        super().__init__(gdb.newest_frame(), internal=True)\n        self.size = size\n        self.name = name\n        self.silent = True\n        return\n\n    def stop(self) -> bool:\n        if self.return_value:\n            loc = int(self.return_value)\n        else:\n            loc = parse_address(gef.arch.return_register)\n\n        size = self.size\n        ok(f\"{Color.colorify('Heap-Analysis', 'yellow bold')} - {self.name}({size})={loc:#x}\")\n        check_heap_overlap = gef.config[\"heap-analysis-helper.check_heap_overlap\"]\n\n        # pop from free-ed list if it was in it\n        if gef.session.heap_freed_chunks:\n            idx = 0\n            for item in gef.session.heap_freed_chunks:\n                addr = item[0]\n                if addr == loc:\n                    gef.session.heap_freed_chunks.remove(item)\n                    continue\n                idx += 1\n\n        # pop from uaf watchlist\n        if gef.session.heap_uaf_watchpoints:\n            idx = 0\n            for wp in gef.session.heap_uaf_watchpoints:\n                wp_addr = wp.address\n                if loc <= wp_addr < loc + size:\n                    gef.session.heap_uaf_watchpoints.remove(wp)\n                    wp.enabled = False\n                    continue\n                idx += 1\n\n        item = (loc, size)\n\n        if check_heap_overlap:\n            # seek all the currently allocated chunks, read their effective size and check for overlap\n            msg = []\n            align = gef.arch.ptrsize\n            for chunk_addr, _ in gef.session.heap_allocated_chunks:\n                current_chunk = GlibcChunk(chunk_addr)\n                current_chunk_size = current_chunk.size\n\n                if chunk_addr <= loc < chunk_addr + current_chunk_size:\n                    offset = loc - chunk_addr - 2*align\n                    if offset < 0: continue # false positive, discard\n\n                    msg.append(Color.colorify(\"Heap-Analysis\", \"yellow bold\"))\n                    msg.append(\"Possible heap overlap detected\")\n                    msg.append(f\"Reason {RIGHT_ARROW} new allocated chunk {loc:#x} (of size {size:d}) overlaps in-used chunk {chunk_addr:#x} (of size {current_chunk_size:#x})\")\n                    msg.append(f\"Writing {offset:d} bytes from {chunk_addr:#x} will reach chunk {loc:#x}\")\n                    msg.append(f\"Payload example for chunk {chunk_addr:#x} (to overwrite {loc:#x} headers):\")\n                    msg.append(f\"  data = 'A'*{offset:d} + 'B'*{align:d} + 'C'*{align:d}\")\n                    push_context_message(\"warn\", \"\\n\".join(msg))\n                    return True\n\n        # add it to alloc-ed list\n        gef.session.heap_allocated_chunks.append(item)\n        return False\n\n\nclass TraceReallocBreakpoint(gdb.Breakpoint):\n    \"\"\"Track re-allocations done with realloc().\"\"\"\n\n    def __init__(self) -> None:\n        super().__init__(\"__libc_realloc\", gdb.BP_BREAKPOINT, internal=True)\n        self.silent = True\n        return\n\n    def stop(self) -> bool:\n        _, ptr = gef.arch.get_ith_parameter(0)\n        _, size = gef.arch.get_ith_parameter(1)\n        assert ptr is not None and size is not None\n        self.retbp = TraceReallocRetBreakpoint(ptr, size)\n        return False\n\n\nclass TraceReallocRetBreakpoint(gdb.FinishBreakpoint):\n    \"\"\"Internal temporary breakpoint to retrieve the return value of realloc().\"\"\"\n\n    def __init__(self, ptr: int, size: int) -> None:\n        super().__init__(gdb.newest_frame(), internal=True)\n        self.ptr = ptr\n        self.size = size\n        self.silent = True\n        return\n\n    def stop(self) -> bool:\n        if self.return_value:\n            newloc = int(self.return_value)\n        else:\n            newloc = parse_address(gef.arch.return_register)\n\n        title = Color.colorify(\"Heap-Analysis\", \"yellow bold\")\n        if newloc != self:\n            loc = Color.colorify(f\"{newloc:#x}\", \"green\")\n            ok(f\"{title} - realloc({self.ptr:#x}, {self.size})={loc}\")\n        else:\n            loc = Color.colorify(f\"{newloc:#x}\", \"red\")\n            ok(f\"{title} - realloc({self.ptr:#x}, {self.size})={loc}\")\n\n        item = (newloc, self.size)\n\n        try:\n            # check if item was in alloc-ed list\n            idx = [x for x, y in gef.session.heap_allocated_chunks].index(self.ptr)\n            # if so pop it out\n            item = gef.session.heap_allocated_chunks.pop(idx)\n        except ValueError:\n            if is_debug():\n                warn(f\"Chunk {self.ptr:#x} was not in tracking list\")\n        finally:\n            # add new item to alloc-ed list\n            gef.session.heap_allocated_chunks.append(item)\n\n        return False\n\n\nclass TraceFreeBreakpoint(gdb.Breakpoint):\n    \"\"\"Track calls to free() and attempts to detect inconsistencies.\"\"\"\n\n    def __init__(self) -> None:\n        super().__init__(\"__libc_free\", gdb.BP_BREAKPOINT, internal=True)\n        self.silent = True\n        return\n\n    def stop(self) -> bool:\n        reset_all_caches()\n        _, addr = gef.arch.get_ith_parameter(0)\n        msg = []\n        check_free_null = gef.config[\"heap-analysis-helper.check_free_null\"]\n        check_double_free = gef.config[\"heap-analysis-helper.check_double_free\"]\n        check_weird_free = gef.config[\"heap-analysis-helper.check_weird_free\"]\n        check_uaf = gef.config[\"heap-analysis-helper.check_uaf\"]\n\n        ok(f\"{Color.colorify('Heap-Analysis', 'yellow bold')} - free({addr:#x})\")\n        if not addr:\n            if check_free_null:\n                msg.append(Color.colorify(\"Heap-Analysis\", \"yellow bold\"))\n                msg.append(f\"Attempting to free(NULL) at {gef.arch.pc:#x}\")\n                msg.append(\"Reason: if NULL page is allocatable, this can lead to code execution.\")\n                push_context_message(\"warn\", \"\\n\".join(msg))\n                return True\n            return False\n\n        if addr in [x for (x, _) in gef.session.heap_freed_chunks]:\n            if check_double_free:\n                msg.append(Color.colorify(\"Heap-Analysis\", \"yellow bold\"))\n                msg.append(f\"Double-free detected {RIGHT_ARROW} free({addr:#x}) is called at {gef.arch.pc:#x} but is already in the free-ed list\")\n                msg.append(\"Execution will likely crash...\")\n                push_context_message(\"warn\", \"\\n\".join(msg))\n                return True\n            return False\n\n        # if here, no error\n        # 1. move alloc-ed item to free list\n        try:\n            # pop from alloc-ed list\n            idx = [x for x, y in gef.session.heap_allocated_chunks].index(addr)\n            item = gef.session.heap_allocated_chunks.pop(idx)\n\n        except ValueError:\n            if check_weird_free:\n                msg.append(Color.colorify(\"Heap-Analysis\", \"yellow bold\"))\n                msg.append(\"Heap inconsistency detected:\")\n                msg.append(f\"Attempting to free an unknown value: {addr:#x}\")\n                push_context_message(\"warn\", \"\\n\".join(msg))\n                return True\n            return False\n\n        # 2. add it to free-ed list\n        gef.session.heap_freed_chunks.append(item)\n\n        self.retbp = None\n        if check_uaf:\n            # 3. (opt.) add a watchpoint on pointer\n            self.retbp = TraceFreeRetBreakpoint(addr)\n        return False\n\n\nclass TraceFreeRetBreakpoint(gdb.FinishBreakpoint):\n    \"\"\"Internal temporary breakpoint to track free()d values.\"\"\"\n\n    def __init__(self, addr: int) -> None:\n        super().__init__(gdb.newest_frame(), internal=True)\n        self.silent = True\n        self.addr = addr\n        return\n\n    def stop(self) -> bool:\n        reset_all_caches()\n        wp = UafWatchpoint(self.addr)\n        gef.session.heap_uaf_watchpoints.append(wp)\n        return False\n\n\nclass UafWatchpoint(gdb.Breakpoint):\n    \"\"\"Custom watchpoints set TraceFreeBreakpoint() to monitor free()d pointers being used.\"\"\"\n\n    def __init__(self, addr: int) -> None:\n        super().__init__(f\"*{addr:#x}\", gdb.BP_WATCHPOINT, internal=True)\n        self.address = addr\n        self.silent = True\n        self.enabled = True\n        return\n\n    def stop(self) -> bool:\n        \"\"\"If this method is triggered, we likely have a UaF. Break the execution and report it.\"\"\"\n        reset_all_caches()\n        frame = gdb.selected_frame()\n        if frame.name() in (\"_int_malloc\", \"malloc_consolidate\", \"__libc_calloc\", ):\n            return False\n\n        # software watchpoints stop after the next statement (see\n        # https://sourceware.org/gdb/onlinedocs/gdb/Set-Watchpoints.html)\n        pc = gdb_get_nth_previous_instruction_address(gef.arch.pc, 2)\n        assert pc\n        insn = gef_current_instruction(pc)\n        msg = []\n        msg.append(Color.colorify(\"Heap-Analysis\", \"yellow bold\"))\n        msg.append(f\"Possible Use-after-Free in '{get_filepath()}': \"\n                   f\"pointer {self.address:#x} was freed, but is attempted to be used at {pc:#x}\")\n        msg.append(f\"{insn.address:#x}   {insn.mnemonic} {Color.yellowify(', '.join(insn.operands))}\")\n        push_context_message(\"warn\", \"\\n\".join(msg))\n        return True\n\n\nclass EntryBreakBreakpoint(gdb.Breakpoint):\n    \"\"\"Breakpoint used internally to stop execution at the most convenient entry point.\"\"\"\n\n    def __init__(self, location: str) -> None:\n        super().__init__(location, gdb.BP_BREAKPOINT, internal=True, temporary=True)\n        self.silent = True\n        return\n\n    def stop(self) -> bool:\n        reset_all_caches()\n        return True\n\n\nclass NamedBreakpoint(gdb.Breakpoint):\n    \"\"\"Breakpoint which shows a specified name, when hit.\"\"\"\n\n    def __init__(self, location: str, name: str) -> None:\n        super().__init__(spec=location, type=gdb.BP_BREAKPOINT, internal=False, temporary=False)\n        self.name = name\n        self.loc = location\n        return\n\n    def stop(self) -> bool:\n        reset_all_caches()\n        push_context_message(\"info\", f\"Hit breakpoint {self.loc} ({Color.colorify(self.name, 'red bold')})\")\n        return True\n\n\nclass JustSilentStopBreakpoint(gdb.Breakpoint):\n    \"\"\"When hit, this temporary breakpoint stop the execution.\"\"\"\n\n    def __init__(self, loc: str) -> None:\n        super().__init__(loc, gdb.BP_BREAKPOINT, temporary=True)\n        self.silent = True\n        return\n\n\n#\n# Context Panes\n#\n\ndef register_external_context_pane(pane_name: str, display_pane_function: Callable[[], None], pane_title_function: Callable[[], str | None], condition : Callable[[], bool] | None = None) -> None:\n    \"\"\"\n    Registering function for new GEF Context View.\n    pane_name: a string that has no spaces (used in settings)\n    display_pane_function: a function that uses gef_print() to print strings\n    pane_title_function: a function that returns a string or None, which will be displayed as the title.\n    If None, no title line is displayed.\n    condition: an optional callback: if not None, the callback will be executed first. If it returns true,\n      then only the pane title and content will displayed. Otherwise, it's simply skipped.\n\n    Example usage for a simple text to show when we hit a syscall:\n    def only_syscall(): return gef_current_instruction(gef.arch.pc).is_syscall()\n    def display_pane():\n      gef_print(\"Wow, I am a context pane!\")\n    def pane_title():\n      return \"example:pane\"\n    register_external_context_pane(\"example_pane\", display_pane, pane_title, only_syscall)\n    \"\"\"\n    gef.gdb.add_context_pane(pane_name, display_pane_function, pane_title_function, condition)\n    return\n\ndef register_external_context_layout_mapping(current_pane_name: str, display_pane_function: Callable[[], None], pane_title_function: Callable[[], str | None], condition : Callable[[], bool] | None = None) -> None:\n    gef.gdb.add_context_layout_mapping(current_pane_name, display_pane_function, pane_title_function, condition)\n    return\n\n\n#\n# Commands\n#\n@deprecated(\"Use `register()`, and inherit from `GenericCommand` instead\")\ndef register_external_command(cls: Type[\"GenericCommand\"]) -> Type[\"GenericCommand\"]:\n    \"\"\"Registering function for new GEF (sub-)command to GDB.\"\"\"\n    return cls\n\n@deprecated(\"Use `register()`, and inherit from `GenericCommand` instead\")\ndef register_command(cls: Type[\"GenericCommand\"]) -> Type[\"GenericCommand\"]:\n    \"\"\"Decorator for registering new GEF (sub-)command to GDB.\"\"\"\n    return cls\n\n@deprecated(\"\")\ndef register_priority_command(cls: Type[\"GenericCommand\"]) -> Type[\"GenericCommand\"]:\n    \"\"\"Decorator for registering new command with priority, meaning that it must\n    loaded before the other generic commands.\"\"\"\n    return cls\n\n\nValidCommandType = TypeVar(\"ValidCommandType\", bound=\"GenericCommand\")\nValidFunctionType = TypeVar(\"ValidFunctionType\", bound=\"GenericFunction\")\n\ndef register(cls: Type[\"ValidCommandType\"] |  Type[\"ValidFunctionType\"]) -> Type[\"ValidCommandType\"] |  Type[\"ValidFunctionType\"]:\n    global __registered_commands__, __registered_functions__\n    if issubclass(cls, GenericCommand):\n        assert hasattr(cls, \"_cmdline_\")\n        assert hasattr(cls, \"do_invoke\")\n        if any(map(lambda x: x._cmdline_ == cls._cmdline_, __registered_commands__)):\n            raise AlreadyRegisteredException(cls._cmdline_)\n        __registered_commands__.add(cls)\n        return cls\n\n    if issubclass(cls, GenericFunction):\n        assert hasattr(cls, \"_function_\")\n        assert hasattr(cls, \"invoke\")\n        if any(map(lambda x: x._function_ == cls._function_, __registered_functions__)):\n            raise AlreadyRegisteredException(cls._function_)\n        __registered_functions__.add(cls)\n        return cls\n\n    raise TypeError(f\"`{cls.__class__}` is an illegal class for `register`\")\n\n\nclass GenericCommand(gdb.Command):\n    \"\"\"This is an abstract class for invoking commands, should not be instantiated.\"\"\"\n\n    _cmdline_: str\n    _syntax_: str\n    _example_: str | list[str] = \"\"\n    _aliases_: list[str] = []\n\n    def __init_subclass__(cls, **kwargs):\n        super().__init_subclass__(**kwargs)\n        attributes = (\"_cmdline_\", \"_syntax_\", )\n        if not all(map(lambda x: hasattr(cls, x), attributes)):\n            raise NotImplementedError\n\n    def __init__(self, *args: Any, **kwargs: Any) -> None:\n        self.pre_load()\n        syntax = Color.yellowify(\"\\nSyntax: \") + self._syntax_\n        example = Color.yellowify(\"\\nExamples: \\n\\t\")\n        if isinstance(self._example_, list):\n            example += \"\\n\\t\".join(self._example_)\n        elif isinstance(self._example_, str):\n            example += self._example_\n        self.__doc__ = (self.__doc__ or \"\").replace(\" \"*4, \"\") + syntax + example\n        self.repeat = False\n        self.repeat_count = 0\n        self.__last_command = None\n        command_type = kwargs.setdefault(\"command\", gdb.COMMAND_USER)\n        complete_type = kwargs.setdefault(\"complete\", -1) # -1=allow user-defined `complete()`\n        prefix = kwargs.setdefault(\"prefix\", False)\n        super().__init__(name=self._cmdline_, command_class=command_type,\n                         completer_class=complete_type, prefix=prefix)\n        self.post_load()\n        return\n\n    def invoke(self, args: str, from_tty: bool) -> None:\n        try:\n            argv = gdb.string_to_argv(args)\n            self.__set_repeat_count(argv, from_tty)\n            bufferize(self.do_invoke)(argv)\n        except Exception as e:\n            # Note: since we are intercepting cleaning exceptions here, commands preferably should avoid\n            # catching generic Exception, but rather specific ones. This is allows a much cleaner use.\n            if is_debug():\n                show_last_exception()\n                if gef.config[\"gef.propagate_debug_exception\"] is True:\n                    raise\n            else:\n                err(f\"Command '{self._cmdline_}' failed to execute properly, reason: {e}\")\n        return\n\n    def usage(self) -> None:\n        err(f\"Syntax\\n{self._syntax_}\")\n        return\n\n    def do_invoke(self, argv: list[str]) -> None:\n        raise NotImplementedError\n\n    def pre_load(self) -> None:\n        return\n\n    def post_load(self) -> None:\n        return\n\n    def __get_setting_name(self, name: str) -> str:\n        clsname = self.__class__._cmdline_.replace(\" \", \"-\")\n        return f\"{clsname}.{name}\"\n\n    def __iter__(self) -> Generator[str, None, None]:\n        for key in gef.config.keys():\n            if key.startswith(self._cmdline_):\n                yield key.replace(f\"{self._cmdline_}.\", \"\", 1)\n\n    @property\n    def settings(self) -> list[str]:\n        \"\"\"Return the list of settings for this command.\"\"\"\n        return list(iter(self))\n\n    @deprecated(\"Use `self[setting_name]` instead\")\n    def get_setting(self, name: str) -> Any:\n        return self.__getitem__(name)\n\n    def __getitem__(self, name: str) -> Any:\n        key = self.__get_setting_name(name)\n        return gef.config[key]\n\n    @deprecated(\"Use `setting_name in self` instead\")\n    def has_setting(self, name: str) -> bool:\n        return self.__contains__(name)\n\n    def __contains__(self, name: str) -> bool:\n        return self.__get_setting_name(name) in gef.config\n\n    @deprecated(\"Use `self[setting_name] = value` instead\")\n    def add_setting(self, name: str, value: tuple[Any, type, str], description: str = \"\") -> None:\n        return self.__setitem__(name, (value, description))\n\n    def __setitem__(self, name: str, value: \"GefSetting | tuple[Any, str]\") -> None:\n        # make sure settings are always associated to the root command (which derives from GenericCommand)\n        if \"GenericCommand\" not in [x.__name__ for x in self.__class__.__bases__]:\n            return\n        key = self.__get_setting_name(name)\n        if key in gef.config:\n            # If the setting already exists, update the entry\n            setting = gef.config.raw_entry(key)\n            setting.value = value\n            return\n\n        # otherwise create it\n        if isinstance(value, GefSetting):\n            gef.config[key] = value\n        else:\n            if len(value) == 1:\n                gef.config[key] = GefSetting(value[0])\n            elif len(value) == 2:\n                gef.config[key] = GefSetting(value[0], description=value[1])\n        return\n\n    @deprecated(\"Use `del self[setting_name]` instead\")\n    def del_setting(self, name: str) -> None:\n        return self.__delitem__(name)\n\n    def __delitem__(self, name: str) -> None:\n        del gef.config[self.__get_setting_name(name)]\n        return\n\n    def __set_repeat_count(self, argv: list[str], from_tty: bool) -> None:\n        if not from_tty:\n            self.repeat = False\n            self.repeat_count = 0\n            return\n\n        command = (gdb.execute(\"show commands\", to_string=True) or \"\").strip().split(\"\\n\")[-1]\n        self.repeat = self.__last_command == command\n        self.repeat_count = self.repeat_count + 1 if self.repeat else 0\n        self.__last_command = command\n        return\n\n\n@register\nclass ArchCommand(GenericCommand):\n    \"\"\"Manage the current loaded architecture.\"\"\"\n\n    _cmdline_ = \"arch\"\n    _syntax_ = f\"{_cmdline_} (list|get|set) ...\"\n    _example_ = f\"{_cmdline_} set X86\"\n\n    def __init__(self) -> None:\n        super().__init__(prefix=True)\n        return\n\n    def do_invoke(self, argv: list[str]) -> None:\n        if not argv:\n            self.usage()\n        return\n\n@register\nclass ArchGetCommand(GenericCommand):\n    \"\"\"Get the current loaded architecture.\"\"\"\n\n    _cmdline_ = \"arch get\"\n    _syntax_ = f\"{_cmdline_}\"\n    _example_ = f\"{_cmdline_}\"\n\n    def do_invoke(self, args: list[str]) -> None:\n        gef_print(f\"{Color.greenify('Arch')}: {gef.arch}\")\n        gef_print(f\"{Color.greenify('Reason')}: {gef.arch_reason}\")\n\n\n@register\nclass ArchSetCommand(GenericCommand):\n    \"\"\"Set the current loaded architecture.\"\"\"\n\n    _cmdline_ = \"arch set\"\n    _syntax_ = f\"{_cmdline_} <arch>\"\n    _example_ = f\"{_cmdline_} X86\"\n\n    def do_invoke(self, args: list[str]) -> None:\n        reset_architecture(args[0] if args else None)\n\n    def complete(self, text: str, word: str) -> list[str]:\n        return sorted(x for x in __registered_architectures__.keys() if\n                       isinstance(x, str) and x.lower().startswith(text.lower().strip()))\n\n@register\nclass ArchListCommand(GenericCommand):\n    \"\"\"List the available architectures.\"\"\"\n\n    _cmdline_ = \"arch list\"\n    _syntax_ = f\"{_cmdline_}\"\n    _example_ = f\"{_cmdline_}\"\n\n    def do_invoke(self, args: list[str]) -> None:\n        gef_print(Color.greenify(\"Available architectures:\"))\n        for arch in sorted(set(__registered_architectures__.values()), key=lambda x: x.arch):\n            if arch is GenericArchitecture:\n                continue\n\n            gef_print(' ' + Color.yellowify(str(arch())))\n            for alias in arch.aliases:\n                if isinstance(alias, str):\n                    gef_print(f\"  {alias}\")\n\n\n@register\nclass VersionCommand(GenericCommand):\n    \"\"\"Display GEF version info.\"\"\"\n\n    _cmdline_ = \"version\"\n    _syntax_ = f\"{_cmdline_}\"\n    _example_ = f\"{_cmdline_}\"\n\n    def do_invoke(self, argv: list[str]) -> None:\n        gef_fpath = pathlib.Path(inspect.stack()[0][1]).expanduser().absolute()\n        gef_dir = gef_fpath.parent\n        gef_hash = hashlib.sha256(gef_fpath.read_bytes()).hexdigest()\n\n        try:\n            git = which(\"git\")\n        except:\n            git = None\n\n        if git:\n            if (gef_dir / \".git\").is_dir():\n                ver = subprocess.check_output(\"git log --format='%H' -n 1 HEAD\", cwd=gef_dir, shell=True).decode(\"utf8\").strip()\n                extra = \"dirty\" if len(subprocess.check_output(\"git ls-files -m\", cwd=gef_dir, shell=True).decode(\"utf8\").strip()) else \"clean\"\n                gef_print(f\"GEF: rev:{ver} (Git - {extra})\")\n            else:\n                gef_blob_hash = subprocess.check_output(f\"git hash-object {gef_fpath}\", shell=True).decode().strip()\n                gef_print(\"GEF: (Standalone)\")\n                gef_print(f\"Blob Hash({gef_fpath}): {gef_blob_hash}\")\n        gef_print(f\"SHA256({gef_fpath}): {gef_hash}\")\n        gef_print(f\"GDB: {gdb.VERSION}\")\n        py_ver = f\"{sys.version_info.major:d}.{sys.version_info.minor:d}\"\n        gef_print(f\"GDB-Python: {py_ver}\")\n\n        if \"full\" in argv:\n            gef_print(f\"Loaded commands: {', '.join(gef.gdb.loaded_command_names)}\")\n        return\n\n\n@register\nclass PrintFormatCommand(GenericCommand):\n    \"\"\"Print bytes format in commonly used formats, such as literals in high level languages.\"\"\"\n\n    valid_formats = (\"py\", \"c\", \"js\", \"asm\", \"hex\", \"bytearray\")\n    valid_bitness = (8, 16, 32, 64)\n\n    _cmdline_ = \"print-format\"\n    _aliases_ = [\"pf\",]\n    _syntax_  = (f\"{_cmdline_} [--lang LANG] [--bitlen SIZE] [(--length,-l) LENGTH] [--clip] LOCATION\"\n                 f\"\\t--lang LANG specifies the output format for programming language (available: {valid_formats!s}, default 'py').\"\n                 f\"\\t--bitlen SIZE specifies size of bit (possible values: {valid_bitness!s}, default is 8).\"\n                 \"\\t--length LENGTH specifies length of array (default is 256).\"\n                 \"\\t--clip The output data will be copied to clipboard\"\n                 \"\\tLOCATION specifies where the address of bytes is stored.\")\n    _example_ = f\"{_cmdline_} --lang py -l 16 $rsp\"\n\n    def __init__(self) -> None:\n        super().__init__(complete=gdb.COMPLETE_LOCATION)\n        self[\"max_size_preview\"] = (10, \"max size preview of bytes\")\n        return\n\n    @property\n    def format_matrix(self) -> dict[int, tuple[str, str, str]]:\n        # `gef.arch.endianness` is a runtime property, should not be defined as a class property\n        return {\n            8:  (f\"{gef.arch.endianness}B\", \"char\", \"db\"),\n            16: (f\"{gef.arch.endianness}H\", \"short\", \"dw\"),\n            32: (f\"{gef.arch.endianness}I\", \"int\", \"dd\"),\n            64: (f\"{gef.arch.endianness}Q\", \"long long\", \"dq\"),\n        }\n\n    @only_if_gdb_running\n    @parse_arguments({\"location\": \"$pc\", }, {(\"--length\", \"-l\"): 256, \"--bitlen\": 0, \"--lang\": \"py\", \"--clip\": False,})\n    def do_invoke(self, _: list[str], **kwargs: Any) -> None:\n        \"\"\"Default value for print-format command.\"\"\"\n        args: argparse.Namespace = kwargs[\"arguments\"]\n        args.bitlen = args.bitlen or gef.arch.ptrsize * 2\n\n        valid_bitlens = self.format_matrix.keys()\n        if args.bitlen not in valid_bitlens:\n            err(f\"Size of bit must be in: {valid_bitlens!s}\")\n            return\n\n        if args.lang not in self.valid_formats:\n            err(f\"Language must be in: {self.valid_formats!s}\")\n            return\n\n        start_addr = parse_address(args.location)\n        size = int(args.bitlen / 8)\n        end_addr = start_addr + args.length * size\n        fmt = self.format_matrix[args.bitlen][0]\n        data = []\n\n        if args.lang != \"bytearray\":\n            for addr in range(start_addr, end_addr, size):\n                value = struct.unpack(fmt, gef.memory.read(addr, size))[0]\n                data += [value]\n            sdata = \", \".join(map(hex, data))\n        else:\n            sdata = \"\"\n\n        if args.lang == \"bytearray\":\n            data = gef.memory.read(start_addr, args.length)\n            preview = str(data[0:self[\"max_size_preview\"]])\n            out = f\"Saved data {preview}... in '{gef_convenience(data)}'\"\n        elif args.lang == \"py\":\n            out = f\"buf = [{sdata}]\"\n        elif args.lang == \"c\":\n            c_type = self.format_matrix[args.bitlen][1]\n            out = f\"unsigned {c_type} buf[{args.length}] = {{{sdata}}};\"\n        elif args.lang == \"js\":\n            out = f\"var buf = [{sdata}]\"\n        elif args.lang == \"asm\":\n            asm_type = self.format_matrix[args.bitlen][2]\n            out = f\"buf {asm_type} {sdata}\"\n        elif args.lang == \"hex\":\n            out = gef.memory.read(start_addr, end_addr-start_addr).hex()\n        else:\n            raise ValueError(f\"Invalid format: {args.lang}\")\n\n        if args.clip:\n            if copy_to_clipboard(gef_pybytes(out)):\n                info(\"Copied to clipboard\")\n            else:\n                warn(\"There's a problem while copying\")\n\n        gef_print(out)\n        return\n\n\n@register\nclass PieCommand(GenericCommand):\n    \"\"\"PIE breakpoint support.\"\"\"\n\n    _cmdline_ = \"pie\"\n    _syntax_ = f\"{_cmdline_} (breakpoint|info|delete|run|attach|remote)\"\n\n    def __init__(self) -> None:\n        super().__init__(prefix=True)\n        return\n\n    def do_invoke(self, argv: list[str]) -> None:\n        if not argv:\n            self.usage()\n        return\n\n\n@register\nclass PieBreakpointCommand(GenericCommand):\n    \"\"\"Set a PIE breakpoint at an offset from the target binaries base address.\"\"\"\n\n    _cmdline_ = \"pie breakpoint\"\n    _syntax_ = f\"{_cmdline_} OFFSET\"\n\n    @parse_arguments({\"offset\": \"\"}, {})\n    def do_invoke(self, _: list[str], **kwargs: Any) -> None:\n        args : argparse.Namespace = kwargs[\"arguments\"]\n        if not args.offset:\n            self.usage()\n            return\n\n        addr = parse_address(args.offset)\n        self.set_pie_breakpoint(lambda base: f\"b *{base + addr}\", addr)\n\n        # When the process is already on, set real breakpoints immediately\n        if is_alive():\n            vmmap = gef.memory.maps\n            base_address = [x.page_start for x in vmmap if x.path == get_filepath()][0]\n            for bp_ins in gef.session.pie_breakpoints.values():\n                bp_ins.instantiate(base_address)\n        return\n\n    @staticmethod\n    def set_pie_breakpoint(set_func: Callable[[int], str], addr: int) -> None:\n        gef.session.pie_breakpoints[gef.session.pie_counter] = PieVirtualBreakpoint(set_func, gef.session.pie_counter, addr)\n        gef.session.pie_counter += 1\n        return\n\n\n@register\nclass PieInfoCommand(GenericCommand):\n    \"\"\"Display breakpoint info.\"\"\"\n\n    _cmdline_ = \"pie info\"\n    _syntax_ = f\"{_cmdline_} BREAKPOINT\"\n\n    @parse_arguments({\"breakpoints\": [-1,]}, {})\n    def do_invoke(self, _: list[str], **kwargs: Any) -> None:\n        args : argparse.Namespace = kwargs[\"arguments\"]\n        if args.breakpoints[0] == -1:\n            # No breakpoint info needed\n            bps = gef.session.pie_breakpoints.values()\n        else:\n            bps = [gef.session.pie_breakpoints[x]\n                   for x in args.breakpoints\n                   if x in gef.session.pie_breakpoints]\n\n        lines = [f\"{'VNum':6s}  {'Num':6s}  {'Addr':18s}\"]\n        lines += [\n            f\"{x.vbp_num:6d}  {str(x.bp_num) if x.bp_num else 'N/A':6s}  {x.addr:18s}\" for x in bps\n        ]\n        gef_print(\"\\n\".join(lines))\n        return\n\n\n@register\nclass PieDeleteCommand(GenericCommand):\n    \"\"\"Delete a PIE breakpoint.\"\"\"\n\n    _cmdline_ = \"pie delete\"\n    _syntax_ = f\"{_cmdline_} [BREAKPOINT]\"\n\n    @parse_arguments({\"breakpoints\": [-1,]}, {})\n    def do_invoke(self, _: list[str], **kwargs: Any) -> None:\n        global gef\n        args : argparse.Namespace = kwargs[\"arguments\"]\n        if args.breakpoints[0] == -1:\n            # no arg, delete all\n            to_delete = list(gef.session.pie_breakpoints.values())\n            self.delete_bp(to_delete)\n        else:\n            self.delete_bp([gef.session.pie_breakpoints[x]\n                            for x in args.breakpoints\n                            if x in gef.session.pie_breakpoints])\n        return\n\n\n    @staticmethod\n    def delete_bp(breakpoints: list[PieVirtualBreakpoint]) -> None:\n        global gef\n        for bp in breakpoints:\n            # delete current real breakpoints if exists\n            if bp.bp_num:\n                gdb.execute(f\"delete {bp.bp_num}\")\n            # delete virtual breakpoints\n            del gef.session.pie_breakpoints[bp.vbp_num]\n        return\n\n\n@register\nclass PieRunCommand(GenericCommand):\n    \"\"\"Run process with PIE breakpoint support.\"\"\"\n\n    _cmdline_ = \"pie run\"\n    _syntax_ = _cmdline_\n\n    def do_invoke(self, argv: list[str]) -> None:\n        global gef\n        fpath = get_filepath()\n        if not fpath:\n            warn(\"No executable to debug, use `file` to load a binary\")\n            return\n\n        if not os.access(fpath, os.X_OK):\n            warn(f\"The file '{fpath}' is not executable.\")\n            return\n\n        if is_alive():\n            warn(\"gdb is already running. Restart process.\")\n\n        # get base address\n        gdb.execute(\"set stop-on-solib-events 1\")\n        hide_context()\n        gdb.execute(f\"run {' '.join(argv)}\")\n        unhide_context()\n        gdb.execute(\"set stop-on-solib-events 0\")\n        vmmap = gef.memory.maps\n        base_address = [x.page_start for x in vmmap if x.path == get_filepath()][0]\n        info(f\"base address {hex(base_address)}\")\n\n        # modify all breakpoints\n        for bp_ins in gef.session.pie_breakpoints.values():\n            bp_ins.instantiate(base_address)\n\n        try:\n            gdb.execute(\"continue\")\n        except gdb.error as e:\n            err(str(e))\n            gdb.execute(\"kill\")\n        return\n\n\n@register\nclass PieAttachCommand(GenericCommand):\n    \"\"\"Do attach with PIE breakpoint support.\"\"\"\n\n    _cmdline_ = \"pie attach\"\n    _syntax_ = f\"{_cmdline_} PID\"\n\n    def do_invoke(self, argv: list[str]) -> None:\n        try:\n            gdb.execute(f\"attach {' '.join(argv)}\", to_string=True)\n        except gdb.error as e:\n            err(str(e))\n            return\n        # after attach, we are stopped so that we can\n        # get base address to modify our breakpoint\n        vmmap = gef.memory.maps\n        base_address = [x.page_start for x in vmmap if x.path == get_filepath()][0]\n\n        for bp_ins in gef.session.pie_breakpoints.values():\n            bp_ins.instantiate(base_address)\n        gdb.execute(\"context\")\n        return\n\n\n@register\nclass PieRemoteCommand(GenericCommand):\n    \"\"\"Attach to a remote connection with PIE breakpoint support.\"\"\"\n\n    _cmdline_ = \"pie remote\"\n    _syntax_ = f\"{_cmdline_} REMOTE\"\n\n    def do_invoke(self, argv: list[str]) -> None:\n        try:\n            gdb.execute(f\"gef-remote {' '.join(argv)}\")\n        except gdb.error as e:\n            err(str(e))\n            return\n        # after remote attach, we are stopped so that we can\n        # get base address to modify our breakpoint\n        vmmap = gef.memory.maps\n        base_address = [x.page_start for x in vmmap if x.realpath == get_filepath()][0]\n\n        for bp_ins in gef.session.pie_breakpoints.values():\n            bp_ins.instantiate(base_address)\n        gdb.execute(\"context\")\n        return\n\n\n@register\nclass SmartEvalCommand(GenericCommand):\n    \"\"\"SmartEval: Smart eval (vague approach to mimic WinDBG `?`).\"\"\"\n\n    _cmdline_ = \"$\"\n    _syntax_  = f\"{_cmdline_} EXPR\\n{_cmdline_} ADDRESS1 ADDRESS2\"\n    _example_ = (f\"\\n{_cmdline_} $pc+1\"\n                 f\"\\n{_cmdline_} 0x00007ffff7a10000 0x00007ffff7bce000\")\n\n    def do_invoke(self, argv: list[str]) -> None:\n        argc = len(argv)\n        if argc == 1:\n            self.evaluate(argv)\n            return\n\n        if argc == 2:\n            self.distance(argv)\n        return\n\n    def evaluate(self, expr: list[str]) -> None:\n        def show_as_int(i: int) -> None:\n            off = gef.arch.ptrsize*8\n            def comp2_x(x: Any) -> str: return f\"{(x + (1 << off)) % (1 << off):x}\"\n            def comp2_b(x: Any) -> str: return f\"{(x + (1 << off)) % (1 << off):b}\"\n\n            try:\n                s_i = comp2_x(res)\n                s_i = s_i.rjust(len(s_i)+1, \"0\") if len(s_i)%2 else s_i\n                gef_print(f\"{i:d}\")\n                gef_print(\"0x\" + comp2_x(res))\n                gef_print(\"0b\" + comp2_b(res))\n                gef_print(f\"{binascii.unhexlify(s_i)}\")\n                gef_print(f\"{binascii.unhexlify(s_i)[::-1]}\")\n            except Exception:\n                pass\n            return\n\n        parsed_expr = []\n        for xp in expr:\n            try:\n                xp = gdb.parse_and_eval(xp)\n                xp = int(xp)\n                parsed_expr.append(f\"{xp:d}\")\n            except gdb.error:\n                parsed_expr.append(str(xp))\n\n        try:\n            res = eval(\" \".join(parsed_expr))\n            if isinstance(res, int):\n                show_as_int(res)\n            else:\n                gef_print(f\"{res}\")\n        except SyntaxError:\n            gef_print(\" \".join(parsed_expr))\n        return\n\n    def distance(self, args: list[str]) -> None:\n        try:\n            x = int(args[0], 16) if is_hex(args[0]) else int(args[0])\n            y = int(args[1], 16) if is_hex(args[1]) else int(args[1])\n            gef_print(f\"{abs(x - y)}\")\n        except ValueError:\n            warn(f\"Distance requires 2 numbers: {self._cmdline_} 0 0xffff\")\n        return\n\n\n@register\nclass CanaryCommand(GenericCommand):\n    \"\"\"Shows the canary value of the current process.\"\"\"\n\n    _cmdline_ = \"canary\"\n    _syntax_ = _cmdline_\n\n    @only_if_gdb_running\n    def do_invoke(self, argv: list[str]) -> None:\n        self.dont_repeat()\n\n        fname = get_filepath()\n        assert fname\n        has_canary = Elf(fname).checksec[\"Canary\"]\n        if not has_canary:\n            warn(\"This binary was not compiled with SSP.\")\n            return\n\n        res = gef.session.canary\n        if not res:\n            err(\"Failed to get the canary\")\n            return\n\n        canary, location = res\n        info(f\"The canary of process {gef.session.pid} is at {location:#x}, value is {canary:#x}\")\n        return\n\n\n@register\nclass ProcessStatusCommand(GenericCommand):\n    \"\"\"Extends the info given by GDB `info proc`, by giving an exhaustive description of the\n    process status (file descriptors, ancestor, descendants, etc.).\"\"\"\n\n    _cmdline_ = \"process-status\"\n    _syntax_  = _cmdline_\n    _aliases_ = [\"status\", ]\n\n    def __init__(self) -> None:\n        super().__init__(complete=gdb.COMPLETE_NONE)\n        return\n\n    @only_if_gdb_running\n    @only_if_gdb_target_local\n    def do_invoke(self, argv: list[str]) -> None:\n        self.show_info_proc()\n        self.show_ancestor()\n        self.show_descendants()\n        self.show_fds()\n        self.show_connections()\n        return\n\n    def get_state_of(self, pid: int) -> dict[str, str]:\n        res = {}\n        with open(f\"/proc/{pid}/status\", \"r\") as f:\n            file = f.readlines()\n        for line in file:\n            key, value = line.split(\":\", 1)\n            res[key.strip()] = value.strip()\n        return res\n\n    def get_cmdline_of(self, pid: int) -> str:\n        with open(f\"/proc/{pid}/cmdline\", \"r\") as f:\n            return f.read().replace(\"\\x00\", \"\\x20\").strip()\n\n    def get_process_path_of(self, pid: int) -> str:\n        return os.readlink(f\"/proc/{pid}/exe\")\n\n    def get_children_pids(self, pid: int) -> list[int]:\n        cmd = [gef.session.constants[\"ps\"], \"-o\", \"pid\", \"--ppid\", f\"{pid}\", \"--noheaders\"]\n        try:\n            return [int(x) for x in gef_execute_external(cmd, as_list=True)]\n        except Exception:\n            return []\n\n    def show_info_proc(self) -> None:\n        info(\"Process Information\")\n        pid = gef.session.pid\n        cmdline = self.get_cmdline_of(pid)\n        gef_print(f\"\\tPID {RIGHT_ARROW} {pid}\",\n                  f\"\\tExecutable {RIGHT_ARROW} {self.get_process_path_of(pid)}\",\n                  f\"\\tCommand line {RIGHT_ARROW} '{cmdline}'\", sep=\"\\n\")\n        return\n\n    def show_ancestor(self) -> None:\n        info(\"Parent Process Information\")\n        ppid = int(self.get_state_of(gef.session.pid)[\"PPid\"])\n        state = self.get_state_of(ppid)\n        cmdline = self.get_cmdline_of(ppid)\n        gef_print(f\"\\tParent PID {RIGHT_ARROW} {state['Pid']}\",\n                  f\"\\tCommand line {RIGHT_ARROW} '{cmdline}'\", sep=\"\\n\")\n        return\n\n    def show_descendants(self) -> None:\n        info(\"Children Process Information\")\n        children = self.get_children_pids(gef.session.pid)\n        if not children:\n            gef_print(\"\\tNo child process\")\n            return\n\n        for child_pid in children:\n            state = self.get_state_of(child_pid)\n            pid = int(state[\"Pid\"])\n            gef_print(f\"\\tPID {RIGHT_ARROW} {pid} (Name: '{self.get_process_path_of(pid)}',\"\n                      f\" CmdLine: '{self.get_cmdline_of(pid)}')\")\n            return\n\n    def show_fds(self) -> None:\n        pid = gef.session.pid\n        path = f\"/proc/{pid:d}/fd\"\n\n        info(\"File Descriptors:\")\n        items = os.listdir(path)\n        if not items:\n            gef_print(\"\\tNo FD opened\")\n            return\n\n        for fname in items:\n            fullpath = os.path.join(path, fname)\n            if os.path.islink(fullpath):\n                gef_print(f\"\\t{fullpath} {RIGHT_ARROW} {os.readlink(fullpath)}\")\n        return\n\n    def list_sockets(self, pid: int) -> list[int]:\n        sockets = []\n        path = f\"/proc/{pid:d}/fd\"\n        items = os.listdir(path)\n        for fname in items:\n            fullpath = os.path.join(path, fname)\n            if os.path.islink(fullpath) and os.readlink(fullpath).startswith(\"socket:\"):\n                p = os.readlink(fullpath).replace(\"socket:\", \"\")[1:-1]\n                sockets.append(int(p))\n        return sockets\n\n    def parse_ip_port(self, addr: str) -> tuple[str, int]:\n        ip, port = addr.split(\":\")\n        return socket.inet_ntoa(struct.pack(\"<I\", int(ip, 16))), int(port, 16)\n\n    def show_connections(self) -> None:\n        # https://github.com/torvalds/linux/blob/v4.7/include/net/tcp_states.h#L16\n        tcp_states_str = {\n            0x01: \"TCP_ESTABLISHED\",\n            0x02: \"TCP_SYN_SENT\",\n            0x03: \"TCP_SYN_RECV\",\n            0x04: \"TCP_FIN_WAIT1\",\n            0x05: \"TCP_FIN_WAIT2\",\n            0x06: \"TCP_TIME_WAIT\",\n            0x07: \"TCP_CLOSE\",\n            0x08: \"TCP_CLOSE_WAIT\",\n            0x09: \"TCP_LAST_ACK\",\n            0x0A: \"TCP_LISTEN\",\n            0x0B: \"TCP_CLOSING\",\n            0x0C: \"TCP_NEW_SYN_RECV\",\n        }\n\n        udp_states_str = {\n            0x07: \"UDP_LISTEN\",\n        }\n\n        info(\"Network Connections\")\n        pid = gef.session.pid\n        sockets = self.list_sockets(pid)\n        if not sockets:\n            gef_print(\"\\tNo open connections\")\n            return\n\n        entries = dict()\n        with open(f\"/proc/{pid:d}/net/tcp\", \"r\") as tcp:\n            entries[\"TCP\"] = [x.split() for x in tcp.readlines()[1:]]\n        with open(f\"/proc/{pid:d}/net/udp\", \"r\") as udp:\n            entries[\"UDP\"] = [x.split() for x in udp.readlines()[1:]]\n\n        for proto in entries:\n            for entry in entries[proto]:\n                local, remote, state = entry[1:4]\n                inode = int(entry[9])\n                if inode in sockets:\n                    local = self.parse_ip_port(local)\n                    remote = self.parse_ip_port(remote)\n                    state = int(state, 16)\n                    state_str = tcp_states_str[state] if proto == \"TCP\" else udp_states_str[state]\n\n                    gef_print(f\"\\t{local[0]}:{local[1]} {RIGHT_ARROW} {remote[0]}:{remote[1]} ({state_str})\")\n        return\n\n\n@register\nclass GefThemeCommand(GenericCommand):\n    \"\"\"Customize GEF appearance.\"\"\"\n\n    _cmdline_ = \"theme\"\n    _syntax_ = f\"{_cmdline_} [KEY [VALUE]]\"\n    _example_ = (f\"{_cmdline_} address_stack green\")\n\n    def __init__(self) -> None:\n        super().__init__(self._cmdline_)\n        self[\"context_title_line\"] = (\"gray\", \"Color of the borders in context window\")\n        self[\"context_title_message\"] = (\"cyan\", \"Color of the title in context window\")\n        self[\"default_title_line\"] = (\"gray\", \"Default color of borders\")\n        self[\"default_title_message\"] = (\"cyan\", \"Default color of title\")\n        self[\"table_heading\"] = (\"blue\", \"Color of the column headings to tables (e.g. vmmap)\")\n        self[\"old_context\"] = (\"gray\", \"Color to use to show things such as code that is not immediately relevant\")\n        self[\"disassemble_current_instruction\"] = (\"green\", \"Color to use to highlight the current $pc when disassembling\")\n        self[\"dereference_string\"] = (\"yellow\", \"Color of dereferenced string\")\n        self[\"dereference_code\"] = (\"gray\", \"Color of dereferenced code\")\n        self[\"dereference_base_address\"] = (\"cyan\", \"Color of dereferenced address\")\n        self[\"dereference_register_value\"] = (\"bold blue\", \"Color of dereferenced register\")\n        self[\"registers_register_name\"] = (\"blue\", \"Color of the register name in the register window\")\n        self[\"registers_value_changed\"] = (\"bold red\", \"Color of the changed register in the register window\")\n        self[\"address_stack\"] = (\"pink\", \"Color to use when a stack address is found\")\n        self[\"address_heap\"] = (\"green\", \"Color to use when a heap address is found\")\n        self[\"address_code\"] = (\"red\", \"Color to use when a code address is found\")\n        self[\"source_current_line\"] = (\"green\", \"Color to use for the current code line in the source window\")\n        return\n\n    def do_invoke(self, args: list[str]) -> None:\n        self.dont_repeat()\n        argc = len(args)\n\n        if argc == 0:\n            for key in self.settings:\n                setting = self[key]\n                value = Color.colorify(setting, setting)\n                gef_print(f\"{key:40s}: {value}\")\n            return\n\n        setting_name = args[0]\n        if setting_name not in self:\n            err(\"Invalid key\")\n            return\n\n        if argc == 1:\n            value = self[setting_name]\n            gef_print(f\"{setting_name:40s}: {Color.colorify(value, value)}\")\n            return\n\n        colors = (color for color in args[1:] if color in Color.colors)\n        self[setting_name] = \" \".join(colors) # type: ignore // this is valid since we overwrote __setitem__()\n\n\nclass ExternalStructureManager:\n    class Structure:\n        def __init__(self, manager: \"ExternalStructureManager\", mod_path: pathlib.Path, struct_name: str) -> None:\n            self.manager = manager\n            self.module_path = mod_path\n            self.name = struct_name\n            self.class_type = self.__get_structure_class()\n            # if the symbol points to a class factory method and not a class\n            if not hasattr(self.class_type, \"_fields_\") and callable(self.class_type):\n                self.class_type = self.class_type(gef)\n            return\n\n        def __str__(self) -> str:\n            return self.name\n\n        def pprint(self) -> None:\n            res: list[str] = []\n            for _name, _type in self.class_type._fields_: # type: ignore\n                size = ctypes.sizeof(_type)\n                name = Color.colorify(_name, gef.config[\"pcustom.structure_name\"])\n                type = Color.colorify(_type.__name__, gef.config[\"pcustom.structure_type\"])\n                size = Color.colorify(hex(size), gef.config[\"pcustom.structure_size\"])\n                offset = Color.boldify(f\"{getattr(self.class_type, _name).offset:04x}\")\n                res.append(f\"{offset}   {name:32s}   {type:16s}  /* size={size} */\")\n            gef_print(\"\\n\".join(res))\n            return\n\n        def __get_structure_class(self) -> Type[ctypes.Structure]:\n            \"\"\"Returns a tuple of (class, instance) if modname!classname exists\"\"\"\n            fpath = self.module_path\n            spec = importlib.util.spec_from_file_location(fpath.stem, fpath)\n            assert spec and spec.loader, \"Failed to determine module specification\"\n            module = importlib.util.module_from_spec(spec)\n            sys.modules[fpath.stem] = module\n            spec.loader.exec_module(module)\n            _class = getattr(module, self.name)\n            return _class\n\n        def apply_at(self, address: int, max_depth: int, depth: int = 0) -> None:\n            \"\"\"Apply (recursively if possible) the structure format to the given address.\"\"\"\n            if depth >= max_depth:\n                warn(\"maximum recursion level reached\")\n                return\n\n            # read the data at the specified address\n            assert isinstance(self.class_type, type)\n            _structure = self.class_type()\n            _sizeof_structure = ctypes.sizeof(_structure)\n\n            try:\n                data = gef.memory.read(address, _sizeof_structure)\n            except gdb.MemoryError:\n                err(f\"{' ' * depth}Cannot read memory {address:#x}\")\n                return\n\n            # deserialize the data\n            length = min(len(data), _sizeof_structure)\n            ctypes.memmove(ctypes.addressof(_structure), data, length)\n\n            # pretty print all the fields (and call recursively if possible)\n            ptrsize = gef.arch.ptrsize\n            unpack = u32 if ptrsize == 4 else u64\n            for field in _structure._fields_:\n                assert len(field) == 2\n                _name, _type = field\n                _value = getattr(_structure, _name)\n                _offset = getattr(self.class_type, _name).offset\n\n                if ((ptrsize == 4 and _type is ctypes.c_uint32)\n                    or (ptrsize == 8 and _type is ctypes.c_uint64)\n                    or (ptrsize == ctypes.sizeof(ctypes.c_void_p) and _type is ctypes.c_void_p)):\n                    # try to dereference pointers\n                    _value = RIGHT_ARROW.join(dereference_from(_value))\n\n                line = f\"{'  ' * depth}\"\n                line += f\"{address:#x}+{_offset:#04x} {_name} : \".ljust(40)\n                line += f\"{_value} ({_type.__name__})\"\n                parsed_value = self.__get_ctypes_value(_structure, _name, _value)\n                if parsed_value:\n                    line += f\"{RIGHT_ARROW} {parsed_value}\"\n                gef_print(line)\n\n                if issubclass(_type, ctypes.Structure):\n                    self.apply_at(address + _offset, max_depth, depth + 1)\n                elif _type.__name__.startswith(\"LP_\"):\n                    # Pointer to a structure of a different type\n                    __sub_type_name = _type.__name__.lstrip(\"LP_\")\n                    result = self.manager.find(__sub_type_name)\n                    if result:\n                        _, __structure = result\n                        __address = unpack(gef.memory.read(address + _offset, ptrsize))\n                        __structure.apply_at(__address, max_depth, depth + 1)\n            return\n\n        def __get_ctypes_value(self, struct, item, value) -> str:\n            if not hasattr(struct, \"_values_\"): return \"\"\n            default = \"\"\n            for name, values in struct._values_:\n                if name != item: continue\n                if callable(values):\n                    return str(values(value))\n                try:\n                    for val, desc in values:\n                        if value == val: return desc\n                        if val is None: default = desc\n                except Exception as e:\n                    err(f\"Error parsing '{name}': {e}\")\n            return default\n\n    class Module(dict):\n        def __init__(self, manager: \"ExternalStructureManager\", path: pathlib.Path) -> None:\n            self.manager = manager\n            self.path = path\n            self.name = path.stem\n            self.raw = self.__load()\n\n            for entry in self:\n                structure = ExternalStructureManager.Structure(manager, self.path, entry)\n                self[structure.name] = structure\n            return\n\n        def __load(self) -> ModuleType:\n            \"\"\"Load a custom module, and return it.\"\"\"\n            fpath = self.path\n            spec = importlib.util.spec_from_file_location(fpath.stem, fpath)\n            assert spec and spec.loader\n            module = importlib.util.module_from_spec(spec)\n            sys.modules[fpath.stem] = module\n            spec.loader.exec_module(module)\n            return module\n\n        def __str__(self) -> str:\n            return self.name\n\n        def __iter__(self) -> Generator[str, None, None]:\n            _invalid = {\"BigEndianStructure\", \"LittleEndianStructure\", \"Structure\"}\n            for x in dir(self.raw):\n                if x in _invalid: continue\n                _attr = getattr(self.raw, x)\n\n                # if it's a ctypes.Structure class, add it\n                if inspect.isclass(_attr) and issubclass(_attr, ctypes.Structure):\n                    yield x\n                    continue\n\n                # also accept class factory functions\n                if callable(_attr) and _attr.__module__ == self.name and x.endswith(\"_t\"):\n                    yield x\n                    continue\n            return\n\n    class Modules(dict):\n        def __init__(self, manager: \"ExternalStructureManager\") -> None:\n            self.manager: \"ExternalStructureManager\" = manager\n            self.root: pathlib.Path = manager.path\n\n            for entry in self.root.iterdir():\n                if not entry.is_file(): continue\n                if entry.suffix != \".py\": continue\n                if entry.name == \"__init__.py\": continue\n                module = ExternalStructureManager.Module(manager, entry)\n                self[module.name] = module\n            return\n\n        def __contains__(self, structure_name: str) -> bool:\n            \"\"\"Return True if the structure name is found in any of the modules\"\"\"\n            for module in self.values():\n                if structure_name in module:\n                    return True\n            return False\n\n    def __init__(self) -> None:\n        self.clear_caches()\n        return\n\n    def clear_caches(self) -> None:\n        self._path = None\n        self._modules = None\n        return\n\n    @property\n    def modules(self) -> \"ExternalStructureManager.Modules\":\n        if not self._modules:\n            self._modules = ExternalStructureManager.Modules(self)\n        return self._modules\n\n    @property\n    def path(self) -> pathlib.Path:\n        if not self._path:\n            self._path = gef.config[\"pcustom.struct_path\"].expanduser().absolute()\n        return self._path\n\n    @property\n    def structures(self) -> Generator[tuple[\"ExternalStructureManager.Module\", \"ExternalStructureManager.Structure\"], None, None]:\n        for module in self.modules.values():\n            for structure in module.values():\n                yield module, structure\n        return\n\n    @lru_cache()\n    def find(self, structure_name: str) -> tuple[\"ExternalStructureManager.Module\", \"ExternalStructureManager.Structure\"] | None:\n        \"\"\"Return the module and structure for the given structure name; `None` if the structure name was not found.\"\"\"\n        for module in self.modules.values():\n            if structure_name in module:\n                return module, module[structure_name]\n        return None\n\n\n@register\nclass PCustomCommand(GenericCommand):\n    \"\"\"Dump user defined structure.\n    This command attempts to reproduce WinDBG awesome `dt` command for GDB and allows\n    to apply structures (from symbols or custom) directly to an address.\n    Custom structures can be defined in pure Python using ctypes, and should be stored\n    in a specific directory, whose path must be stored in the `pcustom.struct_path`\n    configuration setting.\"\"\"\n\n    _cmdline_ = \"pcustom\"\n    _syntax_  = f\"{_cmdline_} [list|edit <StructureName>|show <StructureName>]|<StructureName> 0xADDRESS]\"\n\n    def __init__(self) -> None:\n        global gef\n        super().__init__(prefix=True)\n        self[\"max_depth\"] = (4, \"Maximum level of recursion supported\")\n        self[\"structure_name\"] = (\"bold blue\", \"Color of the structure name\")\n        self[\"structure_type\"] = (\"bold red\", \"Color of the attribute type\")\n        self[\"structure_size\"] = (\"green\", \"Color of the attribute size\")\n        gef.config[f\"{self._cmdline_}.struct_path\"] = GefSetting( gef.config[\"gef.tempdir\"] / \"structs\", pathlib.Path,\n                                                       \"Path to store/load the structure ctypes files\",\n                                                       hooks={\"on_write\": [GefSetting.create_folder_tree,]})\n        return\n\n    @parse_arguments({\"type\": \"\", \"address\": \"\"}, {})\n    def do_invoke(self, *_: Any, **kwargs: dict[str, Any]) -> None:\n        args = cast(argparse.Namespace, kwargs[\"arguments\"])\n        if not args.type:\n            gdb.execute(\"pcustom list\")\n            return\n\n        structname = self.explode_type(args.type)[1]\n\n        if not args.address:\n            gdb.execute(f\"pcustom show {structname}\")\n            return\n\n        if not is_alive():\n            err(\"Session is not active\")\n            return\n\n        manager = ExternalStructureManager()\n        address = parse_address(args.address)\n        result = manager.find(structname)\n        if not result:\n            err(f\"No structure named '{structname}' found\")\n            return\n\n        structure = result[1]\n        structure.apply_at(address, self[\"max_depth\"])\n        return\n\n    def explode_type(self, arg: str) -> tuple[str, str]:\n        modname, structname = arg.split(\":\", 1) if \":\" in arg else (arg, arg)\n        structname = structname.split(\".\", 1)[0] if \".\" in structname else structname\n        return modname, structname\n\n\n@register\nclass PCustomListCommand(PCustomCommand):\n    \"\"\"PCustom: list available structures\"\"\"\n\n    _cmdline_ = \"pcustom list\"\n    _syntax_ = f\"{_cmdline_}\"\n\n    def __init__(self) -> None:\n        super().__init__()\n        return\n\n    def do_invoke(self, _: list[str]) -> None:\n        \"\"\"Dump the list of all the structures and their respective.\"\"\"\n        manager = ExternalStructureManager()\n        info(f\"Listing custom structures from '{manager.path}'\")\n        struct_color = gef.config[\"pcustom.structure_type\"]\n        filename_color = gef.config[\"pcustom.structure_name\"]\n        for module in manager.modules.values():\n            __modules = \", \".join([Color.colorify(str(structure), struct_color) for structure in module.values()])\n            __filename = Color.colorify(str(module.path), filename_color)\n            gef_print(f\"{RIGHT_ARROW} {__filename} ({__modules})\")\n        return\n\n\n@register\nclass PCustomShowCommand(PCustomCommand):\n    \"\"\"PCustom: show the content of a given structure\"\"\"\n\n    _cmdline_ = \"pcustom show\"\n    _syntax_ = f\"{_cmdline_} StructureName\"\n    _aliases_ = [\"pcustom create\", \"pcustom update\"]\n\n    def __init__(self) -> None:\n        super().__init__()\n        return\n\n    def do_invoke(self, argv: list[str]) -> None:\n        if len(argv) == 0:\n            self.usage()\n            return\n\n        _, structname = self.explode_type(argv[0])\n        manager = ExternalStructureManager()\n        result = manager.find(structname)\n        if result:\n            _, structure = result\n            structure.pprint()\n        else:\n            err(f\"No structure named '{structname}' found\")\n        return\n\n\n@register\nclass PCustomEditCommand(PCustomCommand):\n    \"\"\"PCustom: edit the content of a given structure\"\"\"\n\n    _cmdline_ = \"pcustom edit\"\n    _syntax_ = f\"{_cmdline_} StructureName\"\n    __aliases__ = [\"pcustom create\", \"pcustom new\", \"pcustom update\"]\n\n    def __init__(self) -> None:\n        super().__init__()\n        return\n\n    def do_invoke(self, argv: list[str]) -> None:\n        if len(argv) == 0:\n            self.usage()\n            return\n\n        modname, structname = self.explode_type(argv[0])\n        self.__create_or_edit_structure(modname, structname)\n        return\n\n    def __create_or_edit_structure(self, mod_name: str, struct_name: str) -> int:\n        path = gef.config[\"pcustom.struct_path\"].expanduser() / f\"{mod_name}.py\"\n        if path.is_file():\n            info(f\"Editing '{path}'\")\n        else:\n            ok(f\"Creating '{path}' from template\")\n            self.__create_template(struct_name, path)\n\n        cmd = (os.getenv(\"EDITOR\") or \"nano\").split()\n        cmd.append(str(path.absolute()))\n        return subprocess.call(cmd)\n\n    def __create_template(self, structname: str, fpath: pathlib.Path) -> None:\n        template = f\"\"\"from ctypes import *\n\nclass {structname}(Structure):\n    _fields_ = []\n\n    _values_ = []\n\"\"\"\n        with fpath.open(\"w\") as f:\n            f.write(template)\n        return\n\n\n@register\nclass ChangeFdCommand(GenericCommand):\n    \"\"\"ChangeFdCommand: redirect file descriptor during runtime.\"\"\"\n\n    _cmdline_ = \"hijack-fd\"\n    _syntax_ = f\"{_cmdline_} FD_NUM NEW_OUTPUT\"\n    _example_ = f\"{_cmdline_} 2 /tmp/stderr_output.txt\"\n\n    @only_if_gdb_running\n    @only_if_gdb_target_local\n    def do_invoke(self, argv: list[str]) -> None:\n        if len(argv) != 2:\n            self.usage()\n            return\n\n        if not os.access(f\"/proc/{gef.session.pid:d}/fd/{argv[0]}\", os.R_OK):\n            self.usage()\n            return\n\n        old_fd = int(argv[0])\n        new_output = argv[1]\n\n        if \":\" in new_output:\n            address = socket.gethostbyname(new_output.split(\":\")[0])\n            port = int(new_output.split(\":\")[1])\n\n            AF_INET = 2\n            SOCK_STREAM = 1\n            res = gdb.execute(f\"call (int)socket({AF_INET}, {SOCK_STREAM}, 0)\", to_string=True) or \"\"\n            new_fd = self.get_fd_from_result(res)\n\n            # fill in memory with sockaddr_in struct contents\n            # we will do this in the stack, since connect() wants a pointer to a struct\n            vmmap = gef.memory.maps\n            stack_addr = [entry.page_start for entry in vmmap if entry.path == \"[stack]\"][0]\n            original_contents = gef.memory.read(stack_addr, 8)\n\n            gef.memory.write(stack_addr, b\"\\x02\\x00\", 2)\n            gef.memory.write(stack_addr + 0x2, struct.pack(\"<H\", socket.htons(port)), 2)\n            gef.memory.write(stack_addr + 0x4, socket.inet_aton(address), 4)\n\n            info(f\"Trying to connect to {new_output}\")\n            res = gdb.execute(f\"\"\"call (int)connect({new_fd}, {stack_addr}, {16})\"\"\", to_string=True)\n            if res is None:\n                err(\"Call to `connect` failed\")\n                return\n\n            # recover stack state\n            gef.memory.write(stack_addr, original_contents, 8)\n\n            res = self.get_fd_from_result(res)\n            if res == -1:\n                err(f\"Failed to connect to {address}:{port}\")\n                return\n\n            info(f\"Connected to {new_output}\")\n        else:\n            res = gdb.execute(f\"\"\"call (int)open(\"{new_output}\", 66, 0666)\"\"\", to_string=True)\n            if res is None:\n                err(\"Call to `open` failed\")\n                return\n            new_fd = self.get_fd_from_result(res)\n\n        info(f\"Opened '{new_output}' as fd #{new_fd:d}\")\n        gdb.execute(f\"\"\"call (int)dup2({new_fd:d}, {old_fd:d})\"\"\", to_string=True)\n        info(f\"Duplicated fd #{new_fd:d}{RIGHT_ARROW}#{old_fd:d}\")\n        gdb.execute(f\"\"\"call (int)close({new_fd:d})\"\"\", to_string=True)\n        info(f\"Closed extra fd #{new_fd:d}\")\n        ok(\"Success\")\n        return\n\n    def get_fd_from_result(self, res: str) -> int:\n        # Output example: $1 = 3\n        res = gdb.execute(f\"p/d {int(res.split()[2], 0)}\", to_string=True) or \"\"\n        return int(res.split()[2], 0)\n\n\n@register\nclass ScanSectionCommand(GenericCommand):\n    \"\"\"Search for addresses that are located in a memory mapping (haystack) that belonging\n    to another (needle).\"\"\"\n\n    _cmdline_ = \"scan\"\n    _syntax_  = f\"{_cmdline_} HAYSTACK NEEDLE\"\n    _aliases_ = [\"lookup\",]\n    _example_ = f\"\\n{_cmdline_} stack libc\"\n\n    @only_if_gdb_running\n    def do_invoke(self, argv: list[str]) -> None:\n        if len(argv) != 2:\n            self.usage()\n            return\n\n        haystack = argv[0]\n        needle = argv[1]\n\n        info(f\"Searching for addresses in '{Color.yellowify(haystack)}' \"\n             f\"that point to '{Color.yellowify(needle)}'\")\n\n        fpath = get_filepath() or \"\"\n\n        if haystack == \"binary\":\n            haystack = fpath\n\n        if needle == \"binary\":\n            needle = fpath\n\n        needle_sections = []\n        haystack_sections = []\n\n        if \"0x\" in haystack:\n            start, end = parse_string_range(haystack)\n            haystack_sections.append((start, end, \"\"))\n\n        if \"0x\" in needle:\n            start, end = parse_string_range(needle)\n            needle_sections.append((start, end))\n\n        for sect in gef.memory.maps:\n            if sect.path is None:\n                continue\n            if haystack in sect.path:\n                haystack_sections.append((sect.page_start, sect.page_end, os.path.basename(sect.path)))\n            if needle in sect.path:\n                needle_sections.append((sect.page_start, sect.page_end))\n\n        step = gef.arch.ptrsize\n        unpack = u32 if step == 4 else u64\n\n        dereference_cmd = gef.gdb.commands[\"dereference\"]\n        assert isinstance(dereference_cmd, DereferenceCommand)\n\n        for hstart, hend, hname in haystack_sections:\n            try:\n                mem = gef.memory.read(hstart, hend - hstart)\n            except gdb.MemoryError:\n                continue\n\n            for i in range(0, len(mem), step):\n                target = unpack(mem[i:i+step])\n                for nstart, nend in needle_sections:\n                    if target >= nstart and target < nend:\n                        deref = dereference_cmd.pprint_dereferenced(hstart, int(i / step))\n                        if hname != \"\":\n                            name = Color.colorify(hname, \"yellow\")\n                            gef_print(f\"{name}: {deref}\")\n                        else:\n                            gef_print(f\" {deref}\")\n\n        return\n\n\n@register\nclass SearchPatternCommand(GenericCommand):\n    \"\"\"SearchPatternCommand: search a pattern in memory. If given an hex value (starting with 0x)\n    the command will also try to look for upwards cross-references to this address.\"\"\"\n\n    _cmdline_ = \"search-pattern\"\n    _syntax_ = f\"{_cmdline_} PATTERN [little|big] [section]\"\n    _aliases_ = [\"grep\", \"xref\"]\n    _example_ = [f\"{_cmdline_} AAAAAAAA\",\n                 f\"{_cmdline_} 0x555555554000 little stack\",\n                 f\"{_cmdline_} AAAA 0x600000-0x601000\",\n                 f\"{_cmdline_} --regex 0x401000 0x401500 ([\\\\\\\\x20-\\\\\\\\x7E]{{2,}})(?=\\\\\\\\x00)   <-- It matches null-end-printable(from x20-x7e) C strings (min size 2 bytes)\"]\n\n    def __init__(self) -> None:\n        super().__init__()\n        self[\"max_size_preview\"] = (10, \"max size preview of bytes\")\n        self[\"nr_pages_chunk\"] = (0x400, \"number of pages readed for each memory read chunk\")\n        return\n\n    def print_section(self, section: Section) -> None:\n        title = \"In \"\n        if section.path:\n            title += f\"'{Color.blueify(section.path)}'\"\n\n        title += f\"({section.page_start:#x}-{section.page_end:#x})\"\n        title += f\", permission={section.permission}\"\n        ok(title)\n        return\n\n    def print_loc(self, loc: tuple[int, int, str]) -> None:\n        gef_print(f\"\"\"  {loc[0]:#x} - {loc[1]:#x} {RIGHT_ARROW}  \"{Color.pinkify(loc[2])}\" \"\"\")\n        return\n\n    def search_pattern_by_address(self, pattern: str, start_address: int, end_address: int) -> list[tuple[int, int, str]]:\n        \"\"\"Search a pattern within a range defined by arguments.\"\"\"\n        _pattern = gef_pybytes(pattern)\n        step = self[\"nr_pages_chunk\"] * gef.session.pagesize\n        locations = []\n\n        for chunk_addr in range(start_address, end_address, step):\n            if chunk_addr + step > end_address:\n                chunk_size = end_address - chunk_addr\n            else:\n                chunk_size = step\n\n            try:\n                mem = gef.memory.read(chunk_addr, chunk_size)\n            except gdb.MemoryError:\n                return []\n\n            for match in re.finditer(_pattern, mem):\n                start = chunk_addr + match.start()\n                ustr = \"\"\n                if is_ascii_string(start):\n                    ustr = gef.memory.read_ascii_string(start) or \"\"\n                    end = start + len(ustr)\n                else:\n                    ustr = gef_pystring(_pattern) + \"[...]\"\n                    end = start + len(_pattern)\n                locations.append((start, end, ustr))\n\n            del mem\n\n        return locations\n\n    def search_binpattern_by_address(self, binpattern: bytes, start_address: int, end_address: int) -> list[tuple[int, int, str]]:\n        \"\"\"Search a binary pattern within a range defined by arguments.\"\"\"\n\n        step = self[\"nr_pages_chunk\"] * gef.session.pagesize\n        locations = []\n\n        for chunk_addr in range(start_address, end_address, step):\n            if chunk_addr + step > end_address:\n                chunk_size = end_address - chunk_addr\n            else:\n                chunk_size = step\n\n            try:\n                mem = gef.memory.read(chunk_addr, chunk_size)\n            except gdb.MemoryError:\n                return []\n            preview_size = self[\"max_size_preview\"]\n            preview = \"\"\n            for match in re.finditer(binpattern, mem):\n                start = chunk_addr + match.start()\n                preview = str(mem[slice(*match.span())][0:preview_size]) + \"...\"\n                size_match = match.span()[1] - match.span()[0]\n                if size_match > 0:\n                    size_match -= 1\n                end = start + size_match\n                locations.append((start, end, preview))\n\n            del mem\n\n        return locations\n\n    def search_pattern(self, pattern: str, section_name: str) -> None:\n        \"\"\"Search a pattern within the whole userland memory.\"\"\"\n        for section in gef.memory.maps:\n            if not section.permission & Permission.READ: continue\n            if section.path == \"[vvar]\": continue\n            if section_name not in section.path: continue\n\n            start = section.page_start\n            end = section.page_end - 1\n            old_section = None\n\n            for loc in self.search_pattern_by_address(pattern, start, end):\n                addr_loc_start = lookup_address(loc[0])\n                if addr_loc_start and addr_loc_start.section:\n                    if old_section != addr_loc_start.section:\n                        self.print_section(addr_loc_start.section)\n                        old_section = addr_loc_start.section\n\n                self.print_loc(loc)\n        return\n\n    @only_if_gdb_running\n    def do_invoke(self, argv: list[str]) -> None:\n        argc = len(argv)\n        if argc < 1:\n            self.usage()\n            return\n\n        if argc > 3 and argv[0].startswith(\"--regex\"):\n            pattern = ' '.join(argv[3:])\n            pattern = ast.literal_eval(\"b'\" + pattern + \"'\")\n\n            addr_start = parse_address(argv[1])\n            addr_end = parse_address(argv[2])\n\n            for loc in self.search_binpattern_by_address(pattern, addr_start, addr_end):\n                self.print_loc(loc)\n\n            return\n\n        pattern = argv[0]\n        endian = gef.arch.endianness\n\n        if argc >= 2:\n            if argv[1].lower() == \"big\": endian = Endianness.BIG_ENDIAN\n            elif argv[1].lower() == \"little\": endian = Endianness.LITTLE_ENDIAN\n\n        if is_hex(pattern):\n            if endian == Endianness.BIG_ENDIAN:\n                pattern = \"\".join([\"\\\\x\" + pattern[i:i + 2] for i in range(2, len(pattern), 2)])\n            else:\n                pattern = \"\".join([\"\\\\x\" + pattern[i:i + 2] for i in range(len(pattern) - 2, 0, -2)])\n\n        if argc == 3:\n            info(f\"Searching '{Color.yellowify(pattern)}' in {argv[2]}\")\n\n            if \"0x\" in argv[2]:\n                start, end = parse_string_range(argv[2])\n\n                loc = lookup_address(start)\n                if loc.valid:\n                    self.print_section(loc.section)\n\n                for loc in self.search_pattern_by_address(pattern, start, end):\n                    self.print_loc(loc)\n            else:\n                section_name = argv[2]\n                if section_name == \"binary\":\n                    section_name = get_filepath() or \"\"\n\n                self.search_pattern(pattern, section_name)\n        else:\n            info(f\"Searching '{Color.yellowify(pattern)}' in memory\")\n            self.search_pattern(pattern, \"\")\n        return\n\n\n@register\nclass FlagsCommand(GenericCommand):\n    \"\"\"Edit flags in a human friendly way.\"\"\"\n\n    _cmdline_ = \"edit-flags\"\n    _syntax_  = f\"{_cmdline_} [(+|-|~)FLAGNAME ...]\"\n    _aliases_ = [\"flags\",]\n    _example_ = (f\"\\n{_cmdline_}\"\n                 f\"\\n{_cmdline_} +zero # sets ZERO flag\")\n\n    def do_invoke(self, argv: list[str]) -> None:\n        if not gef.arch.flag_register:\n            warn(f\"The architecture {gef.arch.arch}:{gef.arch.mode} doesn't have flag register.\")\n            return\n\n        for flag in argv:\n            if len(flag) < 2:\n                continue\n\n            action = flag[0]\n            name = flag[1:].lower()\n\n            if action not in (\"+\", \"-\", \"~\"):\n                err(f\"Invalid action for flag '{flag}'\")\n                continue\n\n            if name not in gef.arch.flags_table.values():\n                err(f\"Invalid flag name '{flag[1:]}'\")\n                continue\n\n            for off in gef.arch.flags_table:\n                if gef.arch.flags_table[off] != name:\n                    continue\n                old_flag = gef.arch.register(gef.arch.flag_register)\n                if action == \"+\":\n                    new_flags = old_flag | (1 << off)\n                elif action == \"-\":\n                    new_flags = old_flag & ~(1 << off)\n                else:\n                    new_flags = old_flag ^ (1 << off)\n\n                gdb.execute(f\"set ({gef.arch.flag_register}) = {new_flags:#x}\")\n\n        gef_print(gef.arch.flag_register_to_human())\n        return\n\n\n@register\nclass RemoteCommand(GenericCommand):\n    \"\"\"GDB `target remote` command on steroids. This command will use the remote procfs to create\n    a local copy of the execution environment, including the target binary and its libraries\n    in the local temporary directory (the value by default is in `gef.config.tempdir`). Additionally, it\n    will fetch all the /proc/PID/maps and loads all its information. If procfs is not available remotely, the command\n    will likely fail. You can however still use the limited command provided by GDB `target remote`.\"\"\"\n\n    _cmdline_ = \"gef-remote\"\n    _syntax_  = f\"{_cmdline_} [OPTIONS] TARGET\"\n    _example_  = [f\"{_cmdline_} localhost 1234\",\n                  f\"{_cmdline_} --pid 6789 localhost 1234\",\n                  f\"{_cmdline_} --qemu-user --qemu-binary /bin/debugme localhost 4444 \"]\n\n    def __init__(self) -> None:\n        super().__init__(prefix=False)\n        return\n\n    @parse_arguments({\"host\": \"\", \"port\": 0}, {\"--pid\": -1, \"--qemu-user\": False, \"--qemu-binary\": \"\"})\n    def do_invoke(self, _: list[str], **kwargs: Any) -> None:\n        if gef.session.remote is not None:\n            err(\"You already are in remote session. Close it first before opening a new one...\")\n            return\n\n        # argument check\n        args : argparse.Namespace = kwargs[\"arguments\"]\n        if not args.host or not args.port:\n            err(\"Missing parameters\")\n            return\n\n        # qemu-user support\n        qemu_binary: pathlib.Path | None = None\n        if args.qemu_user:\n            try:\n                qemu_binary = pathlib.Path(args.qemu_binary).expanduser().absolute() if args.qemu_binary else gef.session.file\n                if not qemu_binary or not qemu_binary.exists():\n                    raise FileNotFoundError(f\"{qemu_binary} does not exist\")\n            except Exception as e:\n                err(f\"Failed to initialize qemu-user mode, reason: {str(e)}\")\n                return\n\n        # Try to establish the remote session, throw on error\n        # Set `.remote_initializing` to True here - `GefRemoteSessionManager` invokes code which\n        # calls `is_remote_debug` which checks if `remote_initializing` is True or `.remote` is None\n        # This prevents some spurious errors being thrown during startup\n        gef.session.remote_initializing = True\n        session = GefRemoteSessionManager(args.host, args.port, args.pid, qemu_binary)\n\n        dbg(f\"[remote] initializing remote session with {session.target} under {session.root}\")\n        if not session.connect(args.pid) or not session.setup():\n            gef.session.remote = None\n            gef.session.remote_initializing = False\n            raise EnvironmentError(\"Failed to setup remote target\")\n\n        gef.session.remote_initializing = False\n        gef.session.remote = session\n        reset_all_caches()\n        gdb.execute(\"context\")\n        return\n\n\n@register\nclass SkipiCommand(GenericCommand):\n    \"\"\"Skip N instruction(s) execution\"\"\"\n\n    _cmdline_ = \"skipi\"\n    _syntax_  = (f\"{_cmdline_} [LOCATION] [--n NUM_INSTRUCTIONS]\"\n                \"\\n\\tLOCATION\\taddress/symbol from where to skip\"\n                 \"\\t--n NUM_INSTRUCTIONS\\tSkip the specified number of instructions instead of the default 1.\")\n\n    _example_ = [f\"{_cmdline_}\",\n                 f\"{_cmdline_} --n 3\",\n                 f\"{_cmdline_} 0x69696969\",\n                 f\"{_cmdline_} 0x69696969 --n 6\",]\n\n    def __init__(self) -> None:\n        super().__init__(complete=gdb.COMPLETE_LOCATION)\n        return\n\n    @only_if_gdb_running\n    @parse_arguments({\"address\": \"$pc\"}, {\"--n\": 1})\n    def do_invoke(self, _: list[str], **kwargs: Any) -> None:\n        args : argparse.Namespace = kwargs[\"arguments\"]\n        address = parse_address(args.address)\n        num_instructions = args.n\n\n        last_insn = gef_instruction_n(address, num_instructions-1)\n        total_bytes = (last_insn.address - address) + last_insn.size()\n        target_addr  = address + total_bytes\n\n        info(f\"skipping {num_instructions} instructions ({total_bytes} bytes) from {address:#x} to {target_addr:#x}\")\n        gdb.execute(f\"set $pc = {target_addr:#x}\")\n        return\n\n\n@register\nclass StepoverCommand(GenericCommand):\n    \"\"\"Breaks on the instruction immediately following this one. Ex: Step over call instruction\"\"\"\n\n    _cmdline_ = \"stepover\"\n    _syntax_  = (f\"{_cmdline_}\"\n                \"\\n\\tBreaks on the instruction immediately following this one. Ex: Step over call instruction.\")\n    _aliases_ = [\"so\",]\n    _example_ = [f\"{_cmdline_}\",]\n\n    def __init__(self) -> None:\n        super().__init__(complete=gdb.COMPLETE_LOCATION)\n        return\n\n    @only_if_gdb_running\n    def do_invoke(self, _: list[str]) -> None:\n        target_addr = gef_next_instruction(parse_address(\"$pc\")).address\n        JustSilentStopBreakpoint(\"\".join([\"*\",  str(target_addr)]))\n        gdb.execute(\"continue\")\n        return\n\n\n@register\nclass NopCommand(GenericCommand):\n    \"\"\"Patch the instruction(s) pointed by parameters with NOP. Note: this command is architecture\n    aware.\"\"\"\n\n    _cmdline_ = \"nop\"\n    _syntax_  = (f\"{_cmdline_} [LOCATION] [--i ITEMS] [--f] [--n] [--b]\"\n                 \"\\n\\tLOCATION\\taddress/symbol to patch (by default this command replaces whole instructions)\"\n                 \"\\t--i ITEMS\\tnumber of items to insert (default 1)\"\n                 \"\\t--f\\tForce patch even when the selected settings could overwrite partial instructions\"\n                 \"\\t--n\\tInstead of replacing whole instructions, insert ITEMS nop instructions, no matter how many instructions it overwrites\"\n                 \"\\t--b\\tInstead of replacing whole instructions, fill ITEMS bytes with nops\")\n    _example_ = [f\"{_cmdline_}\",\n                 f\"{_cmdline_} $pc+3\",\n                 f\"{_cmdline_} --i 2 $pc+3\",\n                 f\"{_cmdline_} --b\",\n                 f\"{_cmdline_} --b $pc+3\",\n                 f\"{_cmdline_} --f --b --i 2 $pc+3\"\n                 f\"{_cmdline_} --n --i 2 $pc+3\",]\n\n    def __init__(self) -> None:\n        super().__init__(complete=gdb.COMPLETE_LOCATION)\n        return\n\n    @only_if_gdb_running\n    @parse_arguments({\"address\": \"$pc\"}, {\"--i\": 1, \"--b\": False, \"--f\": False, \"--n\": False})\n    def do_invoke(self, _: list[str], **kwargs: Any) -> None:\n        args : argparse.Namespace = kwargs[\"arguments\"]\n        address = parse_address(args.address)\n        nop = gef.arch.nop_insn\n        num_items = int(args.i) or 1\n        fill_bytes = bool(args.b)\n        fill_nops = bool(args.n)\n        force_flag = bool(args.f) or False\n\n        if fill_nops and fill_bytes:\n            err(\"--b and --n cannot be specified at the same time.\")\n            return\n\n        total_bytes = 0\n        if fill_bytes:\n            total_bytes = num_items\n        elif fill_nops:\n            total_bytes = num_items * len(nop)\n        else:\n            try:\n                last_insn = gef_instruction_n(address, num_items-1)\n                last_addr = last_insn.address\n            except Exception as e:\n                err(f\"Cannot patch instruction at {address:#x} reaching unmapped area, reason: {e}\")\n                return\n            total_bytes = (last_addr - address) + gef_get_instruction_at(last_addr).size()\n\n        if len(nop) > total_bytes or total_bytes % len(nop):\n            warn(f\"Patching {total_bytes} bytes at {address:#x} will result in LAST-NOP \"\n                 f\"(byte nr {total_bytes % len(nop):#x}) broken and may cause a crash or \"\n                 \"break disassembly.\")\n            if not force_flag:\n                warn(\"Use --f (force) to ignore this warning.\")\n                return\n\n        target_end_address = address + total_bytes\n        curr_ins = gef_current_instruction(address)\n        while curr_ins.address + curr_ins.size() < target_end_address:\n            if not Address(value=curr_ins.address + 1).valid:\n                err(f\"Cannot patch instruction at {address:#x}: reaching unmapped area\")\n                return\n            curr_ins = gef_next_instruction(curr_ins.address)\n\n        final_ins_end_addr = curr_ins.address + curr_ins.size()\n\n        if final_ins_end_addr != target_end_address:\n            warn(f\"Patching {total_bytes} bytes at {address:#x} will result in LAST-INSTRUCTION \"\n                 f\"({curr_ins.address:#x}) being partial overwritten and may cause a crash or \"\n                 \"break disassembly.\")\n            if not force_flag:\n                warn(\"Use --f (force) to ignore this warning.\")\n                return\n\n        nops = bytearray(nop * total_bytes)\n        end_address = Address(value=address + total_bytes - 1)\n        if not end_address.valid:\n            err(f\"Cannot patch instruction at {address:#x}: reaching unmapped \"\n                f\"area: {end_address:#x}\")\n            return\n\n        ok(f\"Patching {total_bytes} bytes from {address:#x}\")\n        gef.memory.write(address, nops, total_bytes)\n\n        return\n\n\n@register\nclass StubCommand(GenericCommand):\n    \"\"\"Stub out the specified function. This function is useful when needing to skip one\n    function to be called and disrupt your runtime flow (ex. fork).\"\"\"\n\n    _cmdline_ = \"stub\"\n    _syntax_  = (f\"{_cmdline_} [--retval RETVAL] [address]\"\n                 \"\\taddress\\taddress/symbol to stub out\"\n                 \"\\t--retval RETVAL\\tSet the return value\")\n    _example_ = f\"{_cmdline_} --retval 0 fork\"\n\n    def __init__(self) -> None:\n        super().__init__(complete=gdb.COMPLETE_LOCATION)\n        return\n\n    @only_if_gdb_running\n    @parse_arguments({\"address\": \"\"}, {(\"-r\", \"--retval\"): 0})\n    def do_invoke(self, _: list[str], **kwargs: Any) -> None:\n        args : argparse.Namespace = kwargs[\"arguments\"]\n        loc = args.address if args.address else f\"*{gef.arch.pc:#x}\"\n        StubBreakpoint(loc, args.retval)\n        return\n\n\n@register\nclass GlibcHeapCommand(GenericCommand):\n    \"\"\"Base command to get information about the Glibc heap structure.\"\"\"\n\n    _cmdline_ = \"heap\"\n    _syntax_  = f\"{_cmdline_} (chunk|chunks|bins|arenas|set-arena)\"\n\n    def __init__(self) -> None:\n        super().__init__(prefix=True)\n        return\n\n    @only_if_gdb_running\n    def do_invoke(self, _: list[str]) -> None:\n        self.usage()\n        return\n\n\n@register\nclass GlibcHeapSetArenaCommand(GenericCommand):\n    \"\"\"Set the address of the main_arena or the currently selected arena.\"\"\"\n\n    _cmdline_ = \"heap set-arena\"\n    _syntax_  = f\"{_cmdline_} [address|&symbol]\"\n    _example_ = f\"{_cmdline_} 0x001337001337\"\n\n    def __init__(self) -> None:\n        super().__init__(complete=gdb.COMPLETE_LOCATION)\n        return\n\n    @only_if_gdb_running\n    @parse_arguments({\"addr\": \"\"}, {\"--reset\": False})\n    def do_invoke(self, _: list[str], **kwargs: Any) -> None:\n        global gef\n\n        args: argparse.Namespace = kwargs[\"arguments\"]\n\n        if args.reset:\n            gef.heap.reset_caches()\n            return\n\n        if not args.addr:\n            ok(f\"Current arena set to: '{gef.heap.selected_arena}'\")\n            return\n\n        try:\n            new_arena_address = parse_address(args.addr)\n        except gdb.error:\n            err(\"Invalid symbol for arena\")\n            return\n\n        new_arena = GlibcArena( f\"*{new_arena_address:#x}\")\n        if new_arena in gef.heap.arenas:\n            # if entered arena is in arena list then just select it\n            gef.heap.selected_arena = new_arena\n        else:\n            # otherwise set the main arena to the entered arena\n            gef.heap.main_arena = new_arena\n        return\n\n\n@register\nclass GlibcHeapArenaCommand(GenericCommand):\n    \"\"\"Display information on a heap chunk.\"\"\"\n\n    _cmdline_ = \"heap arenas\"\n    _syntax_  = _cmdline_\n\n    @only_if_gdb_running\n    def do_invoke(self, _: list[str]) -> None:\n        for arena in gef.heap.arenas:\n            gef_print(str(arena))\n        return\n\n\n@register\nclass GlibcHeapChunkCommand(GenericCommand):\n    \"\"\"Display information on a heap chunk.\n    See https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L1123.\"\"\"\n\n    _cmdline_ = \"heap chunk\"\n    _syntax_  = f\"{_cmdline_} [-h] [--allow-unaligned] [--number] address\"\n\n    def __init__(self) -> None:\n        super().__init__(complete=gdb.COMPLETE_LOCATION)\n        return\n\n    @parse_arguments({\"address\": \"\"}, {\"--allow-unaligned\": False, \"--number\": 1})\n    @only_if_gdb_running\n    def do_invoke(self, _: list[str], **kwargs: Any) -> None:\n        args : argparse.Namespace = kwargs[\"arguments\"]\n        if not args.address:\n            err(\"Missing chunk address\")\n            self.usage()\n            return\n\n        addr = parse_address(args.address)\n        current_chunk = GlibcChunk(addr, allow_unaligned=args.allow_unaligned)\n\n        if args.number > 1:\n            for _i in range(args.number):\n                if current_chunk.size == 0:\n                    break\n\n                gef_print(str(current_chunk))\n                next_chunk_addr = current_chunk.get_next_chunk_addr()\n                if not Address(value=next_chunk_addr).valid:\n                    break\n\n                next_chunk = current_chunk.get_next_chunk()\n                if next_chunk is None:\n                    break\n\n                current_chunk = next_chunk\n        else:\n            gef_print(current_chunk.psprint())\n        return\n\n\nclass GlibcHeapChunkSummary:\n    def __init__(self, desc = \"\"):\n        self.desc = desc\n        self.count = 0\n        self.total_bytes = 0\n\n    def process_chunk(self, chunk: GlibcChunk) -> None:\n        self.count += 1\n        self.total_bytes += chunk.size\n\n\nclass GlibcHeapArenaSummary:\n    def __init__(self, resolve_type = False) -> None:\n        self.resolve_symbol = resolve_type\n        self.size_distribution = {}\n        self.flag_distribution = {\n            \"PREV_INUSE\": GlibcHeapChunkSummary(),\n            \"IS_MMAPPED\": GlibcHeapChunkSummary(),\n            \"NON_MAIN_ARENA\": GlibcHeapChunkSummary()\n        }\n\n    def process_chunk(self, chunk: GlibcChunk) -> None:\n        chunk_type = \"\" if not self.resolve_symbol else chunk.resolve_type()\n\n        per_size_summary = self.size_distribution.get((chunk.size, chunk_type), None)\n        if per_size_summary is None:\n            per_size_summary = GlibcHeapChunkSummary(desc=chunk_type)\n            self.size_distribution[(chunk.size, chunk_type)] = per_size_summary\n        per_size_summary.process_chunk(chunk)\n\n        if chunk.has_p_bit():\n            self.flag_distribution[\"PREV_INUSE\"].process_chunk(chunk)\n        if chunk.has_m_bit():\n            self.flag_distribution[\"IS_MAPPED\"].process_chunk(chunk)\n        if chunk.has_n_bit():\n            self.flag_distribution[\"NON_MAIN_ARENA\"].process_chunk(chunk)\n\n    def print(self) -> None:\n        gef_print(\"== Chunk distribution by size ==\")\n        gef_print(f\"{'ChunkBytes':<10s}\\t{'Count':<10s}\\t{'TotalBytes':15s}\\t{'Description':s}\")\n        for chunk_info, chunk_summary in sorted(self.size_distribution.items(), key=lambda x: x[1].total_bytes, reverse=True):\n            gef_print(f\"{chunk_info[0]:<10d}\\t{chunk_summary.count:<10d}\\t{chunk_summary.total_bytes:<15d}\\t{chunk_summary.desc:s}\")\n\n        gef_print(\"\\n== Chunk distribution by flag ==\")\n        gef_print(f\"{'Flag':<15s}\\t{'TotalCount':<10s}\\t{'TotalBytes':s}\")\n        for chunk_flag, chunk_summary in self.flag_distribution.items():\n            gef_print(f\"{chunk_flag:<15s}\\t{chunk_summary.count:<10d}\\t{chunk_summary.total_bytes:<d}\")\n\nclass GlibcHeapWalkContext:\n    def __init__(self, print_arena: bool = False, allow_unaligned: bool = False, min_size: int = 0, max_size: int = 0, count: int = -1, resolve_type: bool = False, summary: bool = False) -> None:\n        self.print_arena = print_arena\n        self.allow_unaligned = allow_unaligned\n        self.min_size = min_size\n        self.max_size = max_size\n        self.remaining_chunk_count = count\n        self.summary = summary\n        self.resolve_type = resolve_type\n\n@register\nclass GlibcHeapChunksCommand(GenericCommand):\n    \"\"\"Display all heap chunks for the current arena. As an optional argument\n    the base address of a different arena can be passed\"\"\"\n\n    _cmdline_ = \"heap chunks\"\n    _syntax_  = f\"{_cmdline_} [-h] [--all] [--allow-unaligned] [--summary] [--min-size MIN_SIZE] [--max-size MAX_SIZE] [--count COUNT] [--resolve] [arena_address]\"\n    _example_ = (f\"\\n{_cmdline_}\"\n                 f\"\\n{_cmdline_} 0x555555775000\")\n\n    def __init__(self) -> None:\n        super().__init__(complete=gdb.COMPLETE_LOCATION)\n        self[\"peek_nb_byte\"] = (16, \"Hexdump N first byte(s) inside the chunk data (0 to disable)\")\n        return\n\n    @parse_arguments({\"arena_address\": \"\"}, {(\"--all\", \"-a\"): False, \"--allow-unaligned\": False, \"--min-size\": 0, \"--max-size\": 0, (\"--count\", \"-n\"): -1, (\"--summary\", \"-s\"): False, \"--resolve\": False})\n    @only_if_gdb_running\n    def do_invoke(self, _: list[str], **kwargs: Any) -> None:\n        args = kwargs[\"arguments\"]\n        ctx = GlibcHeapWalkContext(print_arena=args.all, allow_unaligned=args.allow_unaligned, min_size=args.min_size, max_size=args.max_size, count=args.count, resolve_type=args.resolve, summary=args.summary)\n        if args.all or not args.arena_address:\n            for arena in gef.heap.arenas:\n                self.dump_chunks_arena(arena, ctx)\n                if not args.all:\n                    return\n        try:\n            arena_addr = parse_address(args.arena_address)\n            arena = GlibcArena(f\"*{arena_addr:#x}\")\n            self.dump_chunks_arena(arena, ctx)\n        except gdb.error:\n            err(\"Invalid arena\")\n            return\n\n    def dump_chunks_arena(self, arena: GlibcArena, ctx: GlibcHeapWalkContext) -> None:\n        heap_addr = arena.heap_addr(allow_unaligned=ctx.allow_unaligned)\n        if heap_addr is None:\n            err(\"Could not find heap for arena\")\n            return\n        if ctx.print_arena:\n            gef_print(str(arena))\n        if arena.is_main_arena():\n            heap_end = arena.top + GlibcChunk(arena.top, from_base=True).size\n            self.dump_chunks_heap(heap_addr, heap_end, arena, ctx)\n        else:\n            heap_info_structs = arena.get_heap_info_list() or []\n            for heap_info in heap_info_structs:\n                if not self.dump_chunks_heap(heap_info.heap_start, heap_info.heap_end, arena, ctx):\n                    break\n        return\n\n    def dump_chunks_heap(self, start: int, end: int, arena: GlibcArena, ctx: GlibcHeapWalkContext) -> bool:\n        nb = self[\"peek_nb_byte\"]\n        chunk_iterator = GlibcChunk(start, from_base=True, allow_unaligned=ctx.allow_unaligned)\n        heap_summary = GlibcHeapArenaSummary(resolve_type=ctx.resolve_type)\n        for chunk in chunk_iterator:\n            heap_corrupted = chunk.base_address > end\n            should_process = self.should_process_chunk(chunk, ctx)\n\n            if not ctx.summary and chunk.base_address == arena.top:\n                if should_process:\n                    gef_print(\n                        f\"{chunk!s} {LEFT_ARROW} {Color.greenify('top chunk')}\")\n                break\n\n            if heap_corrupted:\n                err(\"Corrupted heap, cannot continue.\")\n                return False\n\n            if not should_process:\n                continue\n\n            if ctx.remaining_chunk_count == 0:\n                break\n\n            if ctx.summary:\n                heap_summary.process_chunk(chunk)\n            else:\n                line = str(chunk)\n                if nb:\n                    line += f\"\\n    [{hexdump(gef.memory.read(chunk.data_address, nb), nb, base=chunk.data_address)}]\"\n                gef_print(line)\n\n            ctx.remaining_chunk_count -= 1\n\n        if ctx.summary:\n            heap_summary.print()\n\n        return True\n\n    def should_process_chunk(self, chunk: GlibcChunk, ctx: GlibcHeapWalkContext) -> bool:\n        if chunk.size < ctx.min_size:\n            return False\n\n        if 0 < ctx.max_size < chunk.size:\n            return False\n\n        return True\n\n\n@register\nclass GlibcHeapBinsCommand(GenericCommand):\n    \"\"\"Display information on the bins on an arena (default: main_arena).\n    See https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L1123.\"\"\"\n\n    _bin_types_ = (\"tcache\", \"fast\", \"unsorted\", \"small\", \"large\")\n    _cmdline_ = \"heap bins\"\n    _syntax_ = f\"{_cmdline_} [{'|'.join(_bin_types_)}]\"\n\n    def __init__(self) -> None:\n        super().__init__(prefix=True, complete=gdb.COMPLETE_LOCATION)\n        return\n\n    @only_if_gdb_running\n    def do_invoke(self, argv: list[str]) -> None:\n        if not argv:\n            for bin_t in self._bin_types_:\n                gdb.execute(f\"heap bins {bin_t}\")\n            return\n\n        bin_t = argv[0]\n        if bin_t not in self._bin_types_:\n            self.usage()\n            return\n\n        gdb.execute(f\"heap bins {bin_t}\")\n        return\n\n    def pprint_bin(self, arena_addr: str, index: int, _type: str = \"\") -> int:\n        arena = GlibcArena(arena_addr)\n\n        fd, bk = arena.bin(index)\n        if (fd, bk) == (0x00, 0x00):\n            warn(\"Invalid backward and forward bin pointers(fw==bk==NULL)\")\n            return -1\n\n        if _type == \"tcache\":\n            chunkClass = GlibcTcacheChunk\n        elif _type == \"fast\":\n            chunkClass = GlibcFastChunk\n        else:\n            chunkClass = GlibcChunk\n\n        nb_chunk = 0\n        head = chunkClass(bk, from_base=True).fd\n        if fd == head:\n            return nb_chunk\n\n        ok(f\"{_type}bins[{index:d}]: fw={fd:#x}, bk={bk:#x}\")\n\n        m = []\n        while fd != head:\n            chunk = chunkClass(fd, from_base=True)\n            m.append(f\"{RIGHT_ARROW}  {chunk!s}\")\n            fd = chunk.fd\n            nb_chunk += 1\n\n        if m:\n            gef_print(\"  \".join(m))\n        return nb_chunk\n\n\n@register\nclass GlibcHeapTcachebinsCommand(GenericCommand):\n    \"\"\"Display information on the Tcachebins on an arena (default: main_arena).\n    See https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=d5c3fafc4307c9b7a4c7d5cb381fcdbfad340bcc.\"\"\"\n\n    _cmdline_ = \"heap bins tcache\"\n    _syntax_  = f\"{_cmdline_} [all] [thread_ids...]\"\n\n    TCACHE_MAX_BINS = 0x40\n\n    def __init__(self) -> None:\n        super().__init__(complete=gdb.COMPLETE_LOCATION)\n        return\n\n    @only_if_gdb_running\n    def do_invoke(self, argv: list[str]) -> None:\n        # Determine if we are using libc with tcache built in (2.26+)\n        if gef.libc.version and gef.libc.version < (2, 26):\n            info(\"No Tcache in this version of libc\")\n            return\n\n        current_thread = gdb.selected_thread()\n        if current_thread is None:\n            err(\"Couldn't find current thread\")\n            return\n\n        # As a nicety, we want to display threads in ascending order by gdb number\n        threads = sorted(gdb.selected_inferior().threads(), key=lambda t: t.num)\n        if argv:\n            if \"all\" in argv:\n                tids = [t.num for t in threads]\n            else:\n                tids = self.check_thread_ids([int(a) for a in argv])\n        else:\n            tids = [current_thread.num]\n\n        for thread in threads:\n            if thread.num not in tids:\n                continue\n\n            thread.switch()\n\n            tcache_addr = self.find_tcache()\n            if tcache_addr == 0:\n                info(f\"Uninitialized tcache for thread {thread.num:d}\")\n                continue\n\n            gef_print(titlify(f\"Tcachebins for thread {thread.num:d}\"))\n            tcache_empty = True\n            for i in range(self.TCACHE_MAX_BINS):\n                chunk, count = self.tcachebin(tcache_addr, i)\n                chunks = set()\n                msg = []\n                chunk_size = 0\n\n                # Only print the entry if there are valid chunks. Don't trust count\n                while True:\n                    if chunk is None:\n                        break\n\n                    try:\n                        msg.append(f\"{LEFT_ARROW} {chunk!s} \")\n                        if not chunk_size:\n                            chunk_size = chunk.usable_size\n\n                        if chunk.data_address in chunks:\n                            msg.append(f\"{RIGHT_ARROW} [loop detected]\")\n                            break\n\n                        chunks.add(chunk.data_address)\n\n                        next_chunk = chunk.fd\n                        if next_chunk == 0:\n                            break\n\n                        chunk = GlibcTcacheChunk(next_chunk)\n                    except gdb.MemoryError:\n                        msg.append(f\"{LEFT_ARROW} [Corrupted chunk at {chunk.data_address:#x}]\")\n                        break\n\n                if msg:\n                    tcache_empty = False\n                    tidx = gef.heap.csize2tidx(chunk_size)\n                    size = gef.heap.tidx2size(tidx)\n                    count = len(chunks)\n                    gef_print(f\"Tcachebins[idx={tidx:d}, size={size:#x}, count={count}]\", end=\"\")\n                    gef_print(\"\".join(msg))\n\n            if tcache_empty:\n                gef_print(\"All tcachebins are empty\")\n\n        current_thread.switch()\n        return\n\n    def find_tcache(self) -> int:\n        \"\"\"Return the location of the current thread's tcache.\"\"\"\n        try:\n            # For multithreaded binaries, the tcache symbol (in thread local\n            # storage) will give us the correct address.\n            tcache_addr = parse_address(\"(void *) tcache\")\n        except gdb.error:\n            # In binaries not linked with pthread (and therefore there is only\n            # one thread), we can't use the tcache symbol, but we can guess the\n            # correct address because the tcache is consistently the first\n            # allocation in the main arena.\n            heap_base = gef.heap.base_address\n            if heap_base is None:\n                err(\"No heap section\")\n                return 0x0\n            tcache_addr = heap_base + 0x10\n        return tcache_addr\n\n    def check_thread_ids(self, tids: list[int]) -> list[int]:\n        \"\"\"Return the subset of tids that are currently valid.\"\"\"\n        existing_tids = set(t.num for t in gdb.selected_inferior().threads())\n        return list(set(tids) & existing_tids)\n\n    def tcachebin(self, tcache_base: int, i: int) -> tuple[GlibcTcacheChunk | None, int]:\n        \"\"\"Return the head chunk in tcache[i] and the number of chunks in the bin.\"\"\"\n        if i >= self.TCACHE_MAX_BINS:\n            err(\"Incorrect index value, index value must be between 0 and \"\n                f\"{self.TCACHE_MAX_BINS}-1, given {i}\"\n            )\n            return None, 0\n\n        tcache_chunk = GlibcTcacheChunk(tcache_base)\n\n        # Glibc changed the size of the tcache in version 2.30; this fix has\n        # been backported inconsistently between distributions. We detect the\n        # difference by checking the size of the allocated chunk for the\n        # tcache.\n        # Minimum usable size of allocated tcache chunk = ?\n        #   For new tcache:\n        #   TCACHE_MAX_BINS * _2_ + TCACHE_MAX_BINS * ptrsize\n        #   For old tcache:\n        #   TCACHE_MAX_BINS * _1_ + TCACHE_MAX_BINS * ptrsize\n        new_tcache_min_size = (\n                self.TCACHE_MAX_BINS * 2 +\n                self.TCACHE_MAX_BINS * gef.arch.ptrsize)\n\n        if tcache_chunk.usable_size < new_tcache_min_size:\n            tcache_count_size = 1\n            count = ord(gef.memory.read(tcache_base + tcache_count_size*i, 1))\n        else:\n            tcache_count_size = 2\n            count = u16(gef.memory.read(tcache_base + tcache_count_size*i, 2))\n\n        chunk = dereference(tcache_base + tcache_count_size*self.TCACHE_MAX_BINS + i*gef.arch.ptrsize)\n        chunk = GlibcTcacheChunk(int(chunk)) if chunk else None\n        return chunk, count\n\n\n@register\nclass GlibcHeapFastbinsYCommand(GenericCommand):\n    \"\"\"Display information on the fastbinsY on an arena (default: main_arena).\n    See https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L1123.\"\"\"\n\n    _cmdline_ = \"heap bins fast\"\n    _syntax_  = f\"{_cmdline_} [ARENA_ADDRESS]\"\n\n    def __init__(self) -> None:\n        super().__init__(complete=gdb.COMPLETE_LOCATION)\n        return\n\n    @parse_arguments({\"arena_address\": \"\"}, {})\n    @only_if_gdb_running\n    def do_invoke(self, *_: Any, **kwargs: Any) -> None:\n        def fastbin_index(sz: int) -> int:\n            return (sz >> 4) - 2 if SIZE_SZ == 8 else (sz >> 3) - 2\n\n        args : argparse.Namespace = kwargs[\"arguments\"]\n        if not gef.heap.main_arena:\n            err(\"Heap not initialized\")\n            return\n\n        SIZE_SZ = gef.arch.ptrsize\n        MAX_FAST_SIZE = 80 * SIZE_SZ // 4\n        NFASTBINS = fastbin_index(MAX_FAST_SIZE) - 1\n\n        arena = GlibcArena(f\"*{args.arena_address}\") if args.arena_address else gef.heap.selected_arena\n        if arena is None:\n            err(\"Invalid Glibc arena\")\n            return\n\n        gef_print(titlify(f\"Fastbins for arena at {arena.addr:#x}\"))\n        for i in range(NFASTBINS):\n            gef_print(f\"Fastbins[idx={i:d}, size={(i+2)*SIZE_SZ*2:#x}] \", end=\"\")\n            chunk = arena.fastbin(i)\n            chunks = set()\n\n            while True:\n                if chunk is None:\n                    gef_print(\"0x00\", end=\"\")\n                    break\n\n                try:\n                    gef_print(f\"{LEFT_ARROW} {chunk!s} \", end=\"\")\n                    if chunk.data_address in chunks:\n                        gef_print(f\"{RIGHT_ARROW} [loop detected]\", end=\"\")\n                        break\n\n                    if fastbin_index(chunk.size) != i:\n                        gef_print(\"[incorrect fastbin_index] \", end=\"\")\n\n                    chunks.add(chunk.data_address)\n\n                    next_chunk = chunk.fd\n                    if next_chunk == 0:\n                        break\n\n                    chunk = GlibcFastChunk(next_chunk, from_base=True)\n                except gdb.MemoryError:\n                    gef_print(f\"{LEFT_ARROW} [Corrupted chunk at {chunk.data_address:#x}]\", end=\"\")\n                    break\n            gef_print()\n        return\n\n\n@register\nclass GlibcHeapUnsortedBinsCommand(GenericCommand):\n    \"\"\"Display information on the Unsorted Bins of an arena (default: main_arena).\n    See: https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L1689.\"\"\"\n\n    _cmdline_ = \"heap bins unsorted\"\n    _syntax_  = f\"{_cmdline_} [ARENA_ADDRESS]\"\n\n    def __init__(self) -> None:\n        super().__init__(complete=gdb.COMPLETE_LOCATION)\n        return\n\n    @parse_arguments({\"arena_address\": \"\"}, {})\n    @only_if_gdb_running\n    def do_invoke(self, *_: Any, **kwargs: Any) -> None:\n        args : argparse.Namespace = kwargs[\"arguments\"]\n        if not gef.heap.main_arena or not gef.heap.selected_arena:\n            err(\"Heap not initialized\")\n            return\n\n        arena_addr = args.arena_address if args.arena_address else f\"{gef.heap.selected_arena.addr:#x}\"\n        gef_print(titlify(f\"Unsorted Bin for arena at {arena_addr}\"))\n        heap_bins_cmd = gef.gdb.commands[\"heap bins\"]\n        assert isinstance(heap_bins_cmd, GlibcHeapBinsCommand)\n        nb_chunk = heap_bins_cmd.pprint_bin(f\"*{arena_addr}\", 0, \"unsorted_\")\n        if nb_chunk >= 0:\n            info(f\"Found {nb_chunk:d} chunks in unsorted bin.\")\n        return\n\n\n@register\nclass GlibcHeapSmallBinsCommand(GenericCommand):\n    \"\"\"Convenience command for viewing small bins.\"\"\"\n\n    _cmdline_ = \"heap bins small\"\n    _syntax_  = f\"{_cmdline_} [ARENA_ADDRESS]\"\n\n    def __init__(self) -> None:\n        super().__init__(complete=gdb.COMPLETE_LOCATION)\n        return\n\n    @parse_arguments({\"arena_address\": \"\"}, {})\n    @only_if_gdb_running\n    def do_invoke(self, *_: Any, **kwargs: Any) -> None:\n        args : argparse.Namespace = kwargs[\"arguments\"]\n        if not gef.heap.main_arena or not gef.heap.selected_arena:\n            err(\"Heap not initialized\")\n            return\n\n        arena_address = args.arena_address or f\"{gef.heap.selected_arena.address:#x}\"\n        gef_print(titlify(f\"Small Bins for arena at {arena_address}\"))\n        bins: dict[int, int] = {}\n        heap_bins_cmd = gef.gdb.commands[\"heap bins\"]\n        assert isinstance (heap_bins_cmd, GlibcHeapBinsCommand)\n        for i in range(1, 63):\n            nb_chunk = heap_bins_cmd.pprint_bin(f\"*{arena_address}\", i, \"small_\")\n            if nb_chunk < 0:\n                break\n            if nb_chunk > 0:\n                bins[i] = nb_chunk\n        info(f\"Found {sum(list(bins.values())):d} chunks in {len(bins):d} small non-empty bins.\")\n        return\n\n\n@register\nclass GlibcHeapLargeBinsCommand(GenericCommand):\n    \"\"\"Convenience command for viewing large bins.\"\"\"\n\n    _cmdline_ = \"heap bins large\"\n    _syntax_  = f\"{_cmdline_} [ARENA_ADDRESS]\"\n\n    def __init__(self) -> None:\n        super().__init__(complete=gdb.COMPLETE_LOCATION)\n        return\n\n    @parse_arguments({\"arena_address\": \"\"}, {})\n    @only_if_gdb_running\n    def do_invoke(self, *_: Any, **kwargs: Any) -> None:\n        args : argparse.Namespace = kwargs[\"arguments\"]\n        if not gef.heap.main_arena or not gef.heap.selected_arena:\n            err(\"Heap not initialized\")\n            return\n\n        arena_addr = args.arena_address if args.arena_address else f\"{gef.heap.selected_arena.addr:#x}\"\n        gef_print(titlify(f\"Large Bins for arena at {arena_addr}\"))\n        bins = {}\n        heap_bins_cmd = gef.gdb.commands[\"heap bins\"]\n        assert isinstance(heap_bins_cmd, GlibcHeapBinsCommand)\n        for i in range(63, 126):\n            nb_chunk = heap_bins_cmd.pprint_bin(f\"*{arena_addr}\", i, \"large_\")\n            if nb_chunk < 0:\n                break\n            if nb_chunk > 0:\n                bins[i] = nb_chunk\n        info(f\"Found {sum(bins.values()):d} chunks in {len(bins):d} large non-empty bins.\")\n        return\n\n\n@register\nclass DetailRegistersCommand(GenericCommand):\n    \"\"\"Display full details on one, many or all registers value from current architecture.\"\"\"\n\n    _cmdline_ = \"registers\"\n    _syntax_  = f\"{_cmdline_} [[Register1][Register2] ... [RegisterN]]\"\n    _example_ = (f\"\\n{_cmdline_}\"\n                 f\"\\n{_cmdline_} $eax $eip $esp\")\n\n    @only_if_gdb_running\n    @parse_arguments({\"registers\": [\"\"]}, {})\n    def do_invoke(self, _: list[str], **kwargs: Any) -> None:\n        unchanged_color = gef.config[\"theme.registers_register_name\"]\n        changed_color = gef.config[\"theme.registers_value_changed\"]\n        string_color = gef.config[\"theme.dereference_string\"]\n        regs = gef.arch.all_registers\n\n        args : argparse.Namespace = kwargs[\"arguments\"]\n        if args.registers and args.registers[0]:\n            all_regs = set(gef.arch.all_registers)\n            regs = [reg for reg in args.registers if reg in all_regs]\n            invalid_regs = [reg for reg in args.registers if reg not in all_regs]\n            if invalid_regs:\n                err(f\"invalid registers for architecture: {', '.join(invalid_regs)}\")\n\n        memsize = gef.arch.ptrsize\n        endian = str(gef.arch.endianness)\n        charset = string.printable\n        widest = max(map(len, gef.arch.all_registers))\n        special_line = \"\"\n\n        for regname in regs:\n            reg = gdb.parse_and_eval(regname)\n            if reg.type.code == gdb.TYPE_CODE_VOID:\n                continue\n\n            padreg = regname.ljust(widest, \" \")\n\n            if str(reg) == \"<unavailable>\":\n                gef_print(f\"{Color.colorify(padreg, unchanged_color)}: \"\n                          f\"{Color.colorify('no value', 'yellow underline')}\")\n                continue\n\n            value = align_address(int(reg))\n            ctx_cmd = gef.gdb.commands[\"context\"]\n            assert isinstance(ctx_cmd, ContextCommand)\n            old_value = ctx_cmd.old_registers.get(regname, 0)\n            if value == old_value:\n                color = unchanged_color\n            else:\n                color = changed_color\n\n            # Special (e.g. segment) registers go on their own line\n            if regname in gef.arch.special_registers:\n                special_line += f\"{Color.colorify(regname, color)}: \"\n                special_line += f\"{gef.arch.register(regname):#04x} \"\n                continue\n\n            line = f\"{Color.colorify(padreg, color)}: \"\n\n            if regname == gef.arch.flag_register:\n                line += gef.arch.flag_register_to_human()\n                gef_print(line)\n                continue\n\n            addr = lookup_address(align_address(int(value)))\n            if addr.valid:\n                line += str(addr)\n            else:\n                line += format_address_spaces(value)\n            addrs = dereference_from(value)\n\n            if len(addrs) > 1:\n                sep = f\" {RIGHT_ARROW} \"\n                line += sep\n                line += sep.join(addrs[1:])\n\n            # check to see if reg value is ascii\n            try:\n                fmt = f\"{endian}{'I' if memsize == 4 else 'Q'}\"\n                last_addr = int(addrs[-1], 16)\n                val = gef_pystring(struct.pack(fmt, last_addr))\n                if all([_ in charset for _ in val]):\n                    line += f\" (\\\"{Color.colorify(val, string_color)}\\\"?)\"\n            except ValueError:\n                pass\n\n            gef_print(line)\n\n        if special_line:\n            gef_print(special_line)\n        return\n\n\n@register\nclass ShellcodeCommand(GenericCommand):\n    \"\"\"ShellcodeCommand uses @JonathanSalwan simple-yet-awesome shellcode API to\n    download shellcodes.\"\"\"\n\n    _cmdline_ = \"shellcode\"\n    _syntax_  = f\"{_cmdline_} (search|get)\"\n\n    def __init__(self) -> None:\n        super().__init__(prefix=True)\n        return\n\n    def do_invoke(self, _: list[str]) -> None:\n        err(\"Missing sub-command (search|get)\")\n        self.usage()\n        return\n\n\n@register\nclass ShellcodeSearchCommand(GenericCommand):\n    \"\"\"Search pattern in shell-storm's shellcode database.\"\"\"\n\n    _cmdline_ = \"shellcode search\"\n    _syntax_  = f\"{_cmdline_} PATTERN1 PATTERN2\"\n    _aliases_ = [\"sc-search\",]\n\n    api_base = \"http://shell-storm.org\"\n    search_url = f\"{api_base}/api/?s=\"\n\n    def do_invoke(self, argv: list[str]) -> None:\n        if not argv:\n            err(\"Missing pattern to search\")\n            self.usage()\n            return\n\n        # API : http://shell-storm.org/shellcode/\n        args = \"*\".join(argv)\n\n        res = http_get(self.search_url + args)\n        if res is None:\n            err(\"Could not query search page\")\n            return\n\n        ret = gef_pystring(res)\n\n        # format: [author, OS/arch, cmd, id, link]\n        lines = ret.split(\"\\\\n\")\n        refs = [line.split(\"::::\") for line in lines]\n\n        if refs:\n            info(\"Showing matching shellcodes\")\n            info(\"\\t\".join([\"Id\", \"Platform\", \"Description\"]))\n            for ref in refs:\n                try:\n                    _, arch, cmd, sid, _ = ref\n                    gef_print(\"\\t\".join([sid, arch, cmd]))\n                except ValueError:\n                    continue\n\n            info(\"Use `shellcode get <id>` to fetch shellcode\")\n        return\n\n\n@register\nclass ShellcodeGetCommand(GenericCommand):\n    \"\"\"Download shellcode from shell-storm's shellcode database.\"\"\"\n\n    _cmdline_ = \"shellcode get\"\n    _syntax_  = f\"{_cmdline_} SHELLCODE_ID\"\n    _aliases_ = [\"sc-get\",]\n\n    api_base = \"http://shell-storm.org\"\n    get_url = f\"{api_base}/shellcode/files/shellcode-{{:d}}.html\"\n\n    def do_invoke(self, argv: list[str]) -> None:\n        if len(argv) != 1:\n            err(\"Missing ID to download\")\n            self.usage()\n            return\n\n        if not argv[0].isdigit():\n            err(\"ID is not a number\")\n            self.usage()\n            return\n\n        self.get_shellcode(int(argv[0]))\n        return\n\n    def get_shellcode(self, sid: int) -> None:\n        info(f\"Downloading shellcode id={sid}\")\n        res = http_get(self.get_url.format(sid))\n        if res is None:\n            err(f\"Failed to fetch shellcode #{sid}\")\n            return\n\n        ok(\"Downloaded, written to disk...\")\n        with tempfile.NamedTemporaryFile(prefix=\"sc-\", suffix=\".txt\", mode='w+b', delete=False, dir=gef.config[\"gef.tempdir\"]) as fd:\n            shellcode = res.split(b\"<pre>\")[1].split(b\"</pre>\")[0]\n            shellcode = shellcode.replace(b\"&quot;\", b'\"')\n            fd.write(shellcode)\n            ok(f\"Shellcode written to '{fd.name}'\")\n        return\n\n\n@register\nclass ProcessListingCommand(GenericCommand):\n    \"\"\"List and filter process. If a PATTERN is given as argument, results shown will be grepped\n    by this pattern.\"\"\"\n\n    _cmdline_ = \"process-search\"\n    _syntax_  = f\"{_cmdline_} [-h] [--attach] [--smart-scan] [REGEX_PATTERN]\"\n    _aliases_ = [\"ps\"]\n    _example_ = f\"{_cmdline_} gdb.*\"\n\n    def __init__(self) -> None:\n        super().__init__(complete=gdb.COMPLETE_LOCATION)\n        self[\"ps_command\"] = (f\"{gef.session.constants['ps']} auxww\", \"`ps` command to get process information\")\n        return\n\n    @parse_arguments({\"pattern\": \"\"}, {\"--attach\": False, \"--smart-scan\": False})\n    def do_invoke(self, _: list, **kwargs: Any) -> None:\n        args : argparse.Namespace = kwargs[\"arguments\"]\n        do_attach = args.attach\n        smart_scan = args.smart_scan\n        pattern = args.pattern\n        pattern = re.compile(\"^.*$\") if not args else re.compile(pattern)\n\n        for process in self.get_processes():\n            pid = int(process[\"pid\"])\n            command = process[\"command\"]\n\n            if not re.search(pattern, command):\n                continue\n\n            if smart_scan:\n                if command.startswith(\"[\") and command.endswith(\"]\"): continue\n                if command.startswith(\"socat \"): continue\n                if command.startswith(\"grep \"): continue\n                if command.startswith(\"gdb \"): continue\n\n            if args and do_attach:\n                ok(f\"Attaching to process='{process['command']}' pid={pid:d}\")\n                gdb.execute(f\"attach {pid:d}\")\n                return None\n\n            line = [process[i] for i in (\"pid\", \"user\", \"cpu\", \"mem\", \"tty\", \"command\")]\n            gef_print(\"\\t\\t\".join(line))\n\n        return None\n\n    def get_processes(self) -> Generator[dict[str, str], None, None]:\n        output = gef_execute_external(self[\"ps_command\"].split(), True)\n        names = [x.lower().replace(\"%\", \"\") for x in output[0].split()]\n\n        for line in output[1:]:\n            fields = line.split()\n            t = {}\n\n            for i, name in enumerate(names):\n                if i == len(names) - 1:\n                    t[name] = \" \".join(fields[i:])\n                else:\n                    t[name] = fields[i]\n\n            yield t\n\n        return\n\n\n@register\nclass ElfInfoCommand(GenericCommand):\n    \"\"\"Display a limited subset of ELF header information. If no argument is provided, the command will\n    show information about the current ELF being debugged.\"\"\"\n\n    _cmdline_ = \"elf-info\"\n    _syntax_  = f\"{_cmdline_} [FILE]\"\n    _example_  = f\"{_cmdline_} /bin/ls\"\n\n    def __init__(self) -> None:\n        super().__init__(complete=gdb.COMPLETE_LOCATION)\n        return\n\n    @parse_arguments({}, {\"--filename\": \"\"})\n    def do_invoke(self, _: list[str], **kwargs: Any) -> None:\n        args : argparse.Namespace = kwargs[\"arguments\"]\n\n        if is_qemu_system():\n            err(\"Unsupported\")\n            return\n\n        filename = args.filename or get_filepath()\n        if filename is None:\n            return\n\n        try:\n            elf = Elf(filename)\n        except ValueError:\n            err(f\"`{filename}` is an invalid value for ELF file\")\n            return\n\n        data = [\n            (\"Magic\", f\"{hexdump(struct.pack('>I', elf.e_magic), show_raw=True)}\"),\n            (\"Class\", f\"{elf.e_class.value:#x} - {elf.e_class.name}\"),\n            (\"Endianness\", f\"{elf.e_endianness.value:#x} - {Endianness(elf.e_endianness).name}\"),\n            (\"Version\", f\"{elf.e_eiversion:#x}\"),\n            (\"OS ABI\", f\"{elf.e_osabi.value:#x} - {elf.e_osabi.name if elf.e_osabi else ''}\"),\n            (\"ABI Version\", f\"{elf.e_abiversion:#x}\"),\n            (\"Type\", f\"{elf.e_type.value:#x} - {elf.e_type.name}\"),\n            (\"Machine\", f\"{elf.e_machine.value:#x} - {elf.e_machine.name}\"),\n            (\"Program Header Table\", f\"{format_address(elf.e_phoff)}\"),\n            (\"Section Header Table\", f\"{format_address(elf.e_shoff)}\"),\n            (\"Header Table\", f\"{format_address(elf.e_phoff)}\"),\n            (\"ELF Version\", f\"{elf.e_version:#x}\"),\n            (\"Header size\", f\"{elf.e_ehsize} ({elf.e_ehsize:#x})\"),\n            (\"Entry point\", f\"{format_address(elf.e_entry)}\"),\n        ]\n\n        for title, content in data:\n            gef_print(f\"{Color.boldify(f'{title:<22}')}: {content}\")\n\n        gef_print(\"\")\n        gef_print(titlify(\"Program Header\"))\n\n        gef_print(f\"  [{'#':>2s}] {'Type':12s} {'Offset':>8s} {'Virtaddr':>10s} {'Physaddr':>10s}\"\n                  f\" {'FileSiz':>8s} {'MemSiz':>8s} {'Flags':5s} {'Align':>8s}\")\n\n        for i, p in enumerate(elf.phdrs):\n            p_type = p.p_type.name if p.p_type else \"\"\n            p_flags = str(p.p_flags.name).lstrip(\"Flag.\") if p.p_flags else \"???\"\n\n            gef_print(f\"  [{i:2d}] {p_type:12s} {p.p_offset:#8x} {p.p_vaddr:#10x} {p.p_paddr:#10x}\"\n                      f\" {p.p_filesz:#8x} {p.p_memsz:#8x} {p_flags:5s} {p.p_align:#8x}\")\n\n        gef_print(\"\")\n        gef_print(titlify(\"Section Header\"))\n        gef_print(f\"  [{'#':>2s}] {'Name':20s} {'Type':>15s} {'Address':>10s} {'Offset':>8s}\"\n                  f\" {'Size':>8s} {'EntSiz':>8s} {'Flags':5s} {'Link':4s} {'Info':4s} {'Align':>8s}\")\n\n        for i, s in enumerate(elf.shdrs):\n            sh_type = s.sh_type.name if s.sh_type else \"UNKN\"\n            sh_flags = str(s.sh_flags).lstrip(\"Flags.\") if s.sh_flags else \"UNKN\"\n\n            gef_print(f\"  [{i:2d}] {s.name:20s} {sh_type:>15s} {s.sh_addr:#10x} {s.sh_offset:#8x} \"\n                      f\"{s.sh_size:#8x} {s.sh_entsize:#8x} {sh_flags:5s} {s.sh_link:#4x} {s.sh_info:#4x} {s.sh_addralign:#8x}\")\n        return\n\n\n@register\nclass EntryPointBreakCommand(GenericCommand):\n    \"\"\"Tries to find best entry point and sets a temporary breakpoint on it. The command will test for\n    well-known symbols for entry points, such as `main`, `_main`, `__libc_start_main`, etc. defined by\n    the setting `entrypoint_symbols`.\"\"\"\n\n    _cmdline_ = \"entry-break\"\n    _syntax_  = _cmdline_\n    _aliases_ = [\"start\",]\n\n    def __init__(self) -> None:\n        super().__init__()\n        self[\"entrypoint_symbols\"] = (\"main _main __libc_start_main __uClibc_main start _start\", \"Possible symbols for entry points\")\n        return\n\n    def do_invoke(self, argv: list[str]) -> None:\n        fpath = get_filepath()\n        if fpath is None:\n            warn(\"No executable to debug, use `file` to load a binary\")\n            return\n\n        if not os.access(fpath, os.X_OK):\n            warn(f\"The file '{fpath}' is not executable.\")\n            return\n\n        if is_alive() and not gef.session.qemu_mode:\n            warn(\"gdb is already running\")\n            return\n\n        bp = None\n        entrypoints = self[\"entrypoint_symbols\"].split()\n\n        for sym in entrypoints:\n            try:\n                value = parse_address(sym)\n                info(f\"Breaking at '{value:#x}'\")\n                bp = EntryBreakBreakpoint(sym)\n                gdb.execute(f\"run {' '.join(argv)}\")\n                return\n\n            except gdb.error as gdb_error:\n                if 'The \"remote\" target does not support \"run\".' in str(gdb_error):\n                    # this case can happen when doing remote debugging\n                    gdb.execute(\"continue\")\n                    return\n                continue\n\n        # if here, clear the breakpoint if any set\n        if bp:\n            bp.delete()\n\n        assert gef.binary\n        # break at entry point\n        entry = gef.binary.entry_point\n\n        if is_pie(fpath):\n            self.set_init_tbreak_pie(entry, argv)\n            gdb.execute(\"continue\")\n            return\n\n        self.set_init_tbreak(entry)\n        gdb.execute(f\"run {' '.join(argv)}\")\n        return\n\n    def set_init_tbreak(self, addr: int) -> EntryBreakBreakpoint:\n        info(f\"Breaking at entry-point: {addr:#x}\")\n        bp = EntryBreakBreakpoint(f\"*{addr:#x}\")\n        return bp\n\n    def set_init_tbreak_pie(self, addr: int, argv: list[str]) -> EntryBreakBreakpoint:\n        warn(\"PIC binary detected, retrieving text base address\")\n        gdb.execute(\"set stop-on-solib-events 1\")\n        hide_context()\n        gdb.execute(f\"run {' '.join(argv)}\")\n        unhide_context()\n        gdb.execute(\"set stop-on-solib-events 0\")\n        vmmap = gef.memory.maps\n        base_address = [x.page_start for x in vmmap if x.path == get_filepath()][0]\n        return self.set_init_tbreak(base_address + addr)\n\n\n@register\nclass NamedBreakpointCommand(GenericCommand):\n    \"\"\"Sets a breakpoint and assigns a name to it, which will be shown, when it's hit.\"\"\"\n\n    _cmdline_ = \"name-break\"\n    _syntax_  = f\"{_cmdline_} name [address]\"\n    _aliases_ = [\"nb\",]\n    _example  = f\"{_cmdline_} main *0x4008a9\"\n\n    def __init__(self) -> None:\n        super().__init__()\n        return\n\n    @parse_arguments({\"name\": \"\", \"address\": \"*$pc\"}, {})\n    def do_invoke(self, _: list[str], **kwargs: Any) -> None:\n        args : argparse.Namespace = kwargs[\"arguments\"]\n        if not args.name:\n            err(\"Missing name for breakpoint\")\n            self.usage()\n            return\n\n        NamedBreakpoint(args.address, args.name)\n        return\n\n\n@register\nclass ContextCommand(GenericCommand):\n    \"\"\"Displays a comprehensive and modular summary of runtime context. Unless setting `enable` is\n    set to False, this command will be spawned automatically every time GDB hits a breakpoint, a\n    watchpoint, or any kind of interrupt. By default, it will show panes that contain the register\n    states, the stack, and the disassembly code around $pc.\"\"\"\n\n    _cmdline_ = \"context\"\n    _syntax_  = f\"{_cmdline_} [legend|regs|stack|code|args|memory|source|trace|threads|extra]\"\n    _aliases_ = [\"ctx\",]\n\n    old_registers: dict[str, int | None] = {}\n\n    def __init__(self) -> None:\n        super().__init__()\n        self[\"enable\"] = (True, \"Enable/disable printing the context when breaking\")\n        self[\"show_source_code_variable_values\"] = (True, \"Show extra PC context info in the source code\")\n        self[\"show_full_source_file_name_max_len\"] = (30, \"Show full source path name, if less than this value\")\n        self[\"show_basename_source_file_name_max_len\"] = (20, \"Show the source basename in full, if less than this value\")\n        self[\"show_prefix_source_path_name_len\"] = (10, \"When truncating source path, show this many path prefix characters\")\n        self[\"show_stack_raw\"] = (False, \"Show the stack pane as raw hexdump (no dereference)\")\n        self[\"show_registers_raw\"] = (False, \"Show the registers pane with raw values (no dereference)\")\n        self[\"show_opcodes_size\"] = (0, \"Number of bytes of opcodes to display next to the disassembly\")\n        self[\"peek_calls\"] = (True, \"Peek into calls\")\n        self[\"peek_ret\"] = (True, \"Peek at return address\")\n        self[\"nb_lines_stack\"] = (8, \"Number of line in the stack pane\")\n        self[\"grow_stack_down\"] = (False, \"Order of stack downward starts at largest down to stack pointer\")\n        self[\"nb_lines_backtrace\"] = (10, \"Number of line in the backtrace pane\")\n        self[\"nb_lines_backtrace_before\"] = (2, \"Number of line in the backtrace pane before selected frame\")\n        self[\"nb_lines_threads\"] = (-1, \"Number of line in the threads pane\")\n        self[\"nb_lines_code\"] = (6, \"Number of instruction after $pc\")\n        self[\"nb_lines_code_prev\"] = (3, \"Number of instruction before $pc\")\n        self[\"ignore_registers\"] = (\"\", \"Space-separated list of registers not to display (e.g. '$cs $ds $gs')\")\n        self[\"clear_screen\"] = (True, \"Clear the screen before printing the context\")\n        self[\"layout\"] = (\"legend regs stack code args source memory threads trace extra\", \"Change the order/presence of the context sections\")\n        self[\"redirect\"] = (\"\", \"Redirect the context information to another TTY\")\n        self[\"libc_args\"] = (False, \"[DEPRECATED - Unused] Show libc function call args description\")\n        self[\"libc_args_path\"] = (\"\", \"[DEPRECATED - Unused] Path to libc function call args json files, provided via gef-extras\")\n\n        self.layout_mapping: dict[str, tuple[Callable, Callable | None, Callable | None]] = {\n            \"legend\": (self.show_legend, None, None),\n            \"regs\": (self.context_regs, None, None),\n            \"stack\": (self.context_stack, None, None),\n            \"code\": (self.context_code, None, None),\n            \"args\": (self.context_args, None, None),\n            \"memory\": (self.context_memory, None, None),\n            \"source\": (self.context_source, None, None),\n            \"trace\": (self.context_trace, None, None),\n            \"threads\": (self.context_threads, None, None),\n            \"extra\": (self.context_additional_information, None, None),\n        }\n\n        self.instruction_iterator = gef_disassemble\n        return\n\n    def post_load(self) -> None:\n        gef_on_continue_hook(self.update_registers)\n        gef_on_continue_hook(self.empty_extra_messages)\n        return\n\n    def show_legend(self) -> None:\n        if gef.config[\"gef.disable_color\"] is True:\n            return\n        changed_register_title = Color.colorify(\"Modified register\", gef.config[\"theme.registers_value_changed\"])\n        code_title = Color.colorify(\"Code\", gef.config[\"theme.address_code\"])\n        heap_title = Color.colorify(\"Heap\", gef.config[\"theme.address_heap\"])\n        stack_title = Color.colorify(\"Stack\", gef.config[\"theme.address_stack\"])\n        str_title = Color.colorify(\"String\", gef.config[\"theme.dereference_string\"])\n        gef_print(f\"[ Legend: {changed_register_title} | {code_title} | {heap_title} | {stack_title} | {str_title} ]\")\n        return\n\n    @only_if_gdb_running\n    def do_invoke(self, argv: list[str]) -> None:\n        if not self[\"enable\"] or gef.ui.context_hidden:\n            return\n\n        if not all(_ in self.layout_mapping for _ in argv):\n            self.usage()\n            return\n\n        if len(argv) > 0:\n            current_layout = argv\n        else:\n            current_layout = self[\"layout\"].strip().split()\n\n        if not current_layout:\n            return\n\n        self.tty_rows, self.tty_columns = get_terminal_size()\n\n        redirect = self[\"redirect\"]\n        if redirect and os.access(redirect, os.W_OK):\n            enable_redirect_output(to_file=redirect)\n\n        if self[\"clear_screen\"] and len(argv) == 0:\n            clear_screen(redirect)\n\n        for section in current_layout:\n            if section[0] == \"-\":\n                continue\n\n            try:\n                display_pane_function, pane_title_function, condition = self.layout_mapping[section]\n                if condition:\n                    if not condition():\n                        continue\n                if pane_title_function:\n                    self.context_title(pane_title_function())\n                display_pane_function()\n            except gdb.MemoryError as e:\n                # a MemoryError will happen when $pc is corrupted (invalid address)\n                err(str(e))\n            except IndexError:\n                # the `section` is not present, just skip\n                pass\n\n        self.context_title(\"\")\n\n        if redirect and os.access(redirect, os.W_OK):\n            disable_redirect_output()\n        return\n\n    def context_title(self, m: str | None) -> None:\n        # allow for not displaying a title line\n        if m is None:\n            return\n\n        line_color = gef.config[\"theme.context_title_line\"]\n        msg_color = gef.config[\"theme.context_title_message\"]\n\n        # print an empty line in case of \"\"\n        if not m:\n            gef_print(Color.colorify(HORIZONTAL_LINE * self.tty_columns, line_color))\n            return\n\n        trail_len = len(m) + 6\n        title = \"\"\n        width = max(self.tty_columns - trail_len, 0)\n        padd = HORIZONTAL_LINE\n        title += Color.colorify(f\"{'':{padd}<{width}} \", line_color)\n        title += Color.colorify(m, msg_color)\n        title += Color.colorify(f\" {'':{padd}<4}\", line_color)\n        gef_print(title)\n        return\n\n    def context_regs(self) -> None:\n        self.context_title(\"registers\")\n        ignored_registers = set(self[\"ignore_registers\"].split())\n\n        # Defer to DetailRegisters by default\n        if self[\"show_registers_raw\"] is False:\n            regs = [reg for reg in gef.arch.all_registers if reg not in ignored_registers]\n            printable_registers = \" \".join(regs)\n            gdb.execute(f\"registers {printable_registers}\")\n            return\n\n        widest = curlen = max(map(len, gef.arch.all_registers))\n        curlen += 5\n        curlen += gef.arch.ptrsize * 2\n        nb = get_terminal_size()[1] // curlen\n        i = 1\n        line = \"\"\n        changed_color = gef.config[\"theme.registers_value_changed\"]\n        regname_color = gef.config[\"theme.registers_register_name\"]\n\n        for reg in gef.arch.all_registers:\n            if reg in ignored_registers:\n                continue\n\n            try:\n                r = gdb.parse_and_eval(reg)\n                if r.type.code == gdb.TYPE_CODE_VOID:\n                    continue\n\n                new_value_type_flag = r.type.code == gdb.TYPE_CODE_FLAGS\n                new_value = int(r)\n\n            except (gdb.MemoryError, gdb.error):\n                # If this exception is triggered, it means that the current register\n                # is corrupted. Just use the register \"raw\" value (not eval-ed)\n                new_value = gef.arch.register(reg)\n                new_value_type_flag = False\n\n            except Exception:\n                new_value = 0\n                new_value_type_flag = False\n\n            old_value = self.old_registers.get(reg, 0)\n\n            padreg = reg.ljust(widest, \" \")\n            value = align_address(new_value)\n            old_value = align_address(old_value or 0)\n            if value == old_value:\n                line += f\"{Color.colorify(padreg, regname_color)}: \"\n            else:\n                line += f\"{Color.colorify(padreg, changed_color)}: \"\n            if new_value_type_flag:\n                line += f\"{format_address_spaces(value)} \"\n            else:\n                addr = lookup_address(align_address(int(value)))\n                if addr.valid:\n                    line += f\"{addr!s} \"\n                else:\n                    line += f\"{format_address_spaces(value)} \"\n\n            if i % nb == 0:\n                gef_print(line)\n                line = \"\"\n            i += 1\n\n        if line:\n            gef_print(line)\n\n        gef_print(f\"Flags: {gef.arch.flag_register_to_human()}\")\n        return\n\n    def context_stack(self) -> None:\n        self.context_title(\"stack\")\n\n        show_raw = self[\"show_stack_raw\"]\n        nb_lines = self[\"nb_lines_stack\"]\n\n        try:\n            sp = gef.arch.sp\n            if show_raw is True:\n                mem = gef.memory.read(sp, 0x10 * nb_lines)\n                gef_print(hexdump(mem, base=sp))\n            else:\n                gdb.execute(f\"dereference -l {nb_lines:d} {sp:#x}\")\n\n        except gdb.MemoryError:\n            err(\"Cannot read memory from $SP (corrupted stack pointer?)\")\n\n        return\n\n    def addr_has_breakpoint(self, address: int, bp_locations: list[str]) -> bool:\n        return any(hex(address) in b for b in bp_locations)\n\n    def context_code(self) -> None:\n        nb_insn = self[\"nb_lines_code\"]\n        nb_insn_prev = self[\"nb_lines_code_prev\"]\n        show_opcodes_size = \"show_opcodes_size\" in self and self[\"show_opcodes_size\"]\n        past_insns_color = gef.config[\"theme.old_context\"]\n        cur_insn_color = gef.config[\"theme.disassemble_current_instruction\"]\n        pc = gef.arch.pc\n        breakpoints = gdb.breakpoints() or []\n        # breakpoint.locations was introduced in gdb 13.1\n        if len(breakpoints) and hasattr(breakpoints[-1], \"locations\"):\n            bp_locations = [hex(location.address) for b in breakpoints for location in b.locations if location is not None] # type: ignore\n        else:\n            # location relies on the user setting the breakpoints with \"b *{hex(address)}\"\n            bp_locations = [b.location for b in breakpoints if b.location and b.location.startswith(\"*\")]\n\n        frame = gdb.selected_frame()\n        arch_name = f\"{gef.arch.arch.lower()}:{gef.arch.mode}\"\n\n        self.context_title(f\"code:{arch_name}\")\n\n        try:\n\n\n            for insn in self.instruction_iterator(pc, nb_insn, nb_prev=nb_insn_prev):\n                line = []\n                is_taken  = False\n                target    = None\n                bp_prefix = Color.redify(BP_GLYPH) if self.addr_has_breakpoint(insn.address, bp_locations) else \" \"\n\n                if show_opcodes_size == 0:\n                    text = str(insn)\n                else:\n                    insn_fmt = f\"{{:{show_opcodes_size}o}}\"\n                    text = insn_fmt.format(insn)\n\n                if insn.address < pc:\n                    line += f\"{bp_prefix}  {Color.colorify(text, past_insns_color)}\"\n\n                elif insn.address == pc:\n                    line += f\"{bp_prefix}{Color.colorify(f'{RIGHT_ARROW[1:]}{text}', cur_insn_color)}\"\n\n                    if gef.arch.is_conditional_branch(insn):\n                        is_taken, reason = gef.arch.is_branch_taken(insn)\n                        if is_taken:\n                            target = insn.operands[-1].split()[0]\n                            reason = f\"[Reason: {reason}]\" if reason else \"\"\n                            line += Color.colorify(f\"\\tTAKEN {reason}\", \"bold green\")\n                        else:\n                            reason = f\"[Reason: !({reason})]\" if reason else \"\"\n                            line += Color.colorify(f\"\\tNOT taken {reason}\", \"bold red\")\n                    elif gef.arch.is_call(insn) and self[\"peek_calls\"] is True:\n                        target = insn.operands[-1].split()[0]\n                    elif gef.arch.is_ret(insn) and self[\"peek_ret\"] is True:\n                        target = gef.arch.get_ra(insn, frame)\n\n                else:\n                    line += f\"{bp_prefix}  {text}\"\n\n                gef_print(\"\".join(line))\n\n                if target:\n                    try:\n                        address = int(target, 0) if isinstance(target, str) else target\n                    except ValueError:\n                        # If the operand isn't an address right now we can't parse it\n                        continue\n                    for i, tinsn in enumerate(self.instruction_iterator(address, nb_insn)):\n                        text= f\"   {DOWN_ARROW if i == 0 else ' '}  {tinsn!s}\"\n                        gef_print(text)\n                    break\n\n        except gdb.MemoryError:\n            err(\"Cannot disassemble from $PC\")\n        return\n\n    def context_args(self) -> None:\n        insn = gef_current_instruction(gef.arch.pc)\n        if not gef.arch.is_call(insn):\n            return\n\n        self.size2type = {\n            1: \"BYTE\",\n            2: \"WORD\",\n            4: \"DWORD\",\n            8: \"QWORD\",\n        }\n\n        if insn.operands[-1].startswith(self.size2type[gef.arch.ptrsize]+\" PTR\"):\n            target = \"*\" + insn.operands[-1].split()[-1]\n        elif \"$\"+insn.operands[0] in gef.arch.all_registers:\n            target = f\"*{gef.arch.register('$' + insn.operands[0]):#x}\"\n        else:\n            # is there a symbol?\n            ops = \" \".join(insn.operands)\n            if \"<\" in ops and \">\" in ops:\n                # extract it\n                target = re.sub(r\".*<([^\\(> ]*).*\", r\"\\1\", ops)\n            else:\n                # it's an address, just use as is\n                target = re.sub(r\".*(0x[a-fA-F0-9]*).*\", r\"\\1\", ops)\n\n        sym = gdb.lookup_global_symbol(target)\n        if sym is None:\n            self.print_guessed_arguments(target)\n            return\n\n        if sym.type and sym.type.code != gdb.TYPE_CODE_FUNC:\n            err(f\"Symbol '{target}' is not a function: type={sym.type.code}\")\n            return\n\n        self.print_arguments_from_symbol(target, sym)\n        return\n\n    def print_arguments_from_symbol(self, function_name: str, symbol: \"gdb.Symbol\") -> None:\n        \"\"\"If symbols were found, parse them and print the argument adequately.\"\"\"\n        args = []\n        fields = symbol.type.fields() if symbol.type else []\n        for i, f in enumerate(fields):\n            if not f.type:\n                continue\n            _value = gef.arch.get_ith_parameter(i, in_func=False)[1]\n            _value = RIGHT_ARROW.join(dereference_from(_value))\n            _name = f.name or f\"var_{i}\"\n            _type = f.type.name or self.size2type[f.type.sizeof]\n            args.append(f\"{_type} {_name} = {_value}\")\n\n        self.context_title(\"arguments\")\n\n        if not args:\n            gef_print(f\"{function_name} (<void>)\")\n            return\n\n        gef_print(f\"{function_name} (\\n   \"+\",\\n   \".join(args)+\"\\n)\")\n        return\n\n    def print_guessed_arguments(self, function_name: str) -> None:\n        \"\"\"When no symbol, read the current basic block and look for \"interesting\" instructions.\"\"\"\n\n        def __get_current_block_start_address() -> int | None:\n            pc = gef.arch.pc\n            try:\n                block = gdb.block_for_pc(pc)\n                block_start = block.start if block else gdb_get_nth_previous_instruction_address(pc, 5)\n            except RuntimeError:\n                block_start = gdb_get_nth_previous_instruction_address(pc, 5)\n            return block_start\n\n        parameter_set = set()\n        pc = gef.arch.pc\n        block_start = __get_current_block_start_address()\n        if not block_start:\n            return\n\n        function_parameters = gef.arch.function_parameters\n        arg_key_color = gef.config[\"theme.registers_register_name\"]\n\n        for insn in self.instruction_iterator(block_start, pc - block_start):\n            if not insn.operands:\n                continue\n\n            if is_x86_32():\n                if insn.mnemonic == \"push\":\n                    parameter_set.add(insn.operands[0])\n            else:\n                op = \"$\" + insn.operands[0]\n                if op in function_parameters:\n                    parameter_set.add(op)\n\n                if is_x86_64():\n                    # also consider extended registers\n                    extended_registers = {\"$rdi\": [\"$edi\", \"$di\"],\n                                          \"$rsi\": [\"$esi\", \"$si\"],\n                                          \"$rdx\": [\"$edx\", \"$dx\"],\n                                          \"$rcx\": [\"$ecx\", \"$cx\"],\n                                         }\n                    for exreg in extended_registers:\n                        if op in extended_registers[exreg]:\n                            parameter_set.add(exreg)\n\n        if is_x86_32():\n            nb_argument = len(parameter_set)\n        else:\n            nb_argument = max([function_parameters.index(p)+1 for p in parameter_set], default=0)\n\n        args = []\n        for i in range(nb_argument):\n            _key, _values = gef.arch.get_ith_parameter(i, in_func=False)\n            _values = RIGHT_ARROW.join(dereference_from(_values))\n            args.append(f\"{Color.colorify(_key, arg_key_color)} = {_values}\")\n\n        self.context_title(\"arguments (guessed)\")\n        gef_print(f\"{function_name} (\")\n        if args:\n            gef_print(\"   \" + \",\\n   \".join(args))\n        gef_print(\")\")\n        return\n\n    def line_has_breakpoint(self, file_name: str, line_number: int, bp_locations: list[str]) -> bool:\n        filename_line = f\"{file_name}:{line_number}\"\n        return any(filename_line in loc for loc in bp_locations)\n\n    def context_source(self) -> None:\n        try:\n            pc = gef.arch.pc\n            symtabline = gdb.find_pc_line(pc)\n            symtab = symtabline.symtab\n            # we subtract one because the line number returned by gdb start at 1\n            line_num = symtabline.line - 1\n            if not symtab.is_valid():\n                return\n\n            fpath = pathlib.Path(symtab.fullname())\n            lines = [curline.rstrip() for curline in fpath.read_text().splitlines()]\n\n        except Exception:\n            return\n\n        file_base_name = os.path.basename(symtab.filename)\n        breakpoints = gdb.breakpoints() or []\n        bp_locations = [b.location for b in breakpoints if b.location and file_base_name in b.location]\n        past_lines_color = gef.config[\"theme.old_context\"]\n\n        show_full_path_max = self[\"show_full_source_file_name_max_len\"]\n        show_basename_path_max = self[\"show_basename_source_file_name_max_len\"]\n\n        nb_line = self[\"nb_lines_code\"]\n        fn = symtab.filename\n        if len(fn) > show_full_path_max:\n            base = os.path.basename(fn)\n            if len(base) > show_basename_path_max:\n                base = base[-show_basename_path_max:]\n            fn = fn[:15] + \"[...]\" + base\n        title = f\"source:{fn}+{line_num + 1}\"\n        cur_line_color = gef.config[\"theme.source_current_line\"]\n        self.context_title(title)\n        show_extra_info = self[\"show_source_code_variable_values\"]\n\n        for i in range(line_num - nb_line + 1, line_num + nb_line):\n            if i < 0:\n                continue\n\n            bp_prefix = Color.redify(BP_GLYPH) if self.line_has_breakpoint(file_base_name, i + 1, bp_locations) else \" \"\n\n            if i < line_num:\n                gef_print(\"{}{}\".format(bp_prefix, Color.colorify(f\"  {i + 1:4d}\\t {lines[i]}\", past_lines_color)))\n\n            if i == line_num:\n                prefix = f\"{bp_prefix}{RIGHT_ARROW[1:]}{i + 1:4d}\\t \"\n                leading = len(lines[i]) - len(lines[i].lstrip())\n                if show_extra_info:\n                    extra_info = self.get_pc_context_info(pc, lines[i])\n                    if extra_info:\n                        gef_print(f\"{' ' * (len(prefix) + leading)}{extra_info}\")\n                gef_print(Color.colorify(f\"{prefix}{lines[i]}\", cur_line_color))\n\n            if i > line_num:\n                try:\n                    gef_print(f\"{bp_prefix}  {i + 1:4d}\\t {lines[i]}\")\n                except IndexError:\n                    break\n        return\n\n    def get_pc_context_info(self, pc: int, line: str) -> str:\n        try:\n            current_block = gdb.block_for_pc(pc)\n            if not current_block or not current_block.is_valid(): return \"\"\n            m = collections.OrderedDict()\n            while current_block and not current_block.is_static:\n                for sym in list(current_block):\n                    symbol = sym.name\n                    if not sym.is_function and re.search(fr\"\\W{symbol}\\W\", line):\n                        val = gdb.parse_and_eval(symbol)\n                        if val.type.code in (gdb.TYPE_CODE_PTR, gdb.TYPE_CODE_ARRAY):\n                            addr = int(val.address)\n                            addrs = dereference_from(addr)\n                            if len(addrs) > 2:\n                                addrs = [addrs[0], \"[...]\", addrs[-1]]\n\n                            f = f\" {RIGHT_ARROW} \"\n                            val = f.join(addrs)\n                        elif val.type.code == gdb.TYPE_CODE_INT:\n                            val = hex(int(val))\n                        else:\n                            continue\n\n                        if symbol not in m:\n                            m[symbol] = val\n                current_block = current_block.superblock\n\n            if m:\n                return \"// \" + \", \".join([f\"{Color.yellowify(a)}={b}\" for a, b in m.items()])\n        except Exception:\n            pass\n        return \"\"\n\n    def context_trace(self) -> None:\n        self.context_title(\"trace\")\n\n        nb_backtrace = self[\"nb_lines_backtrace\"]\n        if nb_backtrace <= 0:\n            return\n\n        # backward compat for gdb (gdb < 7.10)\n        if not hasattr(gdb, \"FrameDecorator\"):\n            gdb.execute(f\"backtrace {nb_backtrace:d}\")\n            return\n\n        orig_frame: gdb.Frame = gdb.selected_frame()\n        current_frame: gdb.Frame = gdb.newest_frame()\n        frames = [current_frame,]\n        while current_frame != orig_frame and current_frame:\n            current_frame = current_frame.older()\n            if not current_frame: break\n            frames.append(current_frame)\n\n        nb_backtrace_before = self[\"nb_lines_backtrace_before\"]\n        level = max(len(frames) - nb_backtrace_before - 1, 0)\n        current_frame: gdb.Frame = frames[level]\n\n        while current_frame:\n            current_frame.select()\n            if not current_frame.is_valid():\n                continue\n\n            pc = int(current_frame.pc())\n            name = current_frame.name()\n            items = []\n            items.append(f\"{pc:#x}\")\n            if name:\n                frame_args = gdb.FrameDecorator.FrameDecorator(current_frame).frame_args() or [] # type: ignore\n                symstr= \", \".join([f\"{Color.yellowify(x.sym)}={x.sym.value(current_frame)!s}\" for x in frame_args])\n                m = f\"{Color.greenify(name)}({symstr})\"\n                items.append(m)\n            else:\n                try:\n                    insn = next(gef_disassemble(int(pc), 1))\n                except gdb.MemoryError:\n                    break\n\n                # check if the gdb symbol table may know the address\n                sym_found = gdb_get_location_from_symbol(pc)\n                symbol = \"\"\n                if sym_found:\n                    sym_name, offset = sym_found\n                    symbol = f\" <{sym_name}+{offset:x}> \"\n\n                items.append(Color.redify(f\"{symbol}{insn.mnemonic} {', '.join(insn.operands)}\"))\n\n            title = Color.colorify(f\"#{level}\", \"bold green\" if current_frame == orig_frame else \"bold pink\")\n            gef_print(f\"[{title}] {RIGHT_ARROW.join(items)}\")\n            older = current_frame.older()\n            level += 1\n            nb_backtrace -= 1\n            if nb_backtrace == 0:\n                break\n            if not older:\n                break\n            current_frame = older\n\n        orig_frame.select()\n        return\n\n    def context_threads(self) -> None:\n        def reason() -> str:\n            res = gdb.execute(\"info program\", to_string=True)\n            if not res:\n                return \"NOT RUNNING\"\n\n            for line in res.splitlines():\n                line = line.strip()\n                if line.startswith(\"It stopped with signal \"):\n                    return line.replace(\"It stopped with signal \", \"\").split(\",\", 1)[0]\n                if line == \"The program being debugged is not being run.\":\n                    return \"NOT RUNNING\"\n                if line == \"It stopped at a breakpoint that has since been deleted.\":\n                    return \"TEMPORARY BREAKPOINT\"\n                if line.startswith(\"It stopped at breakpoint \"):\n                    return \"BREAKPOINT\"\n                if line == \"It stopped after being stepped.\":\n                    return \"SINGLE STEP\"\n\n            return \"STOPPED\"\n\n        self.context_title(\"threads\")\n\n        threads = gdb.selected_inferior().threads()[::-1]\n        idx = self[\"nb_lines_threads\"]\n        if idx > 0:\n            threads = threads[0:idx]\n\n        if idx == 0:\n            return\n\n        if not threads:\n            err(\"No thread selected\")\n            return\n\n        selected_thread = gdb.selected_thread()\n        selected_frame = gdb.selected_frame()\n\n        for i, thread in enumerate(threads):\n            line = f\"[{Color.colorify(f'#{i:d}', 'bold green' if thread == selected_thread else 'bold pink')}] Id {thread.num:d}, \"\n            if thread.name:\n                line += f\"\"\"Name: \"{thread.name}\", \"\"\"\n            if thread.is_running():\n                line += Color.colorify(\"running\", \"bold green\")\n            elif thread.is_stopped():\n                line += Color.colorify(\"stopped\", \"bold red\")\n                thread.switch()\n                frame = gdb.selected_frame()\n                frame_name = frame.name()\n\n                # check if the gdb symbol table may know the address\n                if not frame_name:\n                    sym_found = gdb_get_location_from_symbol(int(frame.pc()))\n                    if sym_found:\n                        sym_name, offset = sym_found\n                        frame_name = f\"<{sym_name}+{offset:x}>\"\n\n                line += (f\" {Color.colorify(f'{frame.pc():#x}', 'blue')} in \"\n                         f\"{Color.colorify(frame_name or '??', 'bold yellow')} (), \"\n                         f\"reason: {Color.colorify(reason(), 'bold pink')}\")\n            elif thread.is_exited():\n                line += Color.colorify(\"exited\", \"bold yellow\")\n            gef_print(line)\n            i += 1\n\n        selected_thread.switch()\n        selected_frame.select()\n        return\n\n    def context_additional_information(self) -> None:\n        if not gef.ui.context_messages:\n            return\n\n        self.context_title(\"extra\")\n        for level, text in gef.ui.context_messages:\n            if level == \"error\": err(text)\n            elif level == \"warn\": warn(text)\n            elif level == \"success\": ok(text)\n            else: info(text)\n        return\n\n    def context_memory(self) -> None:\n        for address, opt in sorted(gef.ui.watches.items()):\n            sz, fmt = opt[0:2]\n            self.context_title(f\"memory:{address:#x}\")\n            if fmt == \"pointers\":\n                gdb.execute(f\"dereference -l {sz:d} {address:#x}\")\n            else:\n                gdb.execute(f\"hexdump {fmt} -s {sz:d} {address:#x}\")\n\n    @classmethod\n    def update_registers(cls, _) -> None:\n        for reg in gef.arch.all_registers:\n            try:\n                cls.old_registers[reg] = gef.arch.register(reg)\n            except Exception:\n                cls.old_registers[reg] = 0\n        return\n\n    def empty_extra_messages(self, _) -> None:\n        gef.ui.context_messages.clear()\n        return\n\n\n@register\nclass MemoryCommand(GenericCommand):\n    \"\"\"Add or remove address ranges to the memory view.\"\"\"\n    _cmdline_ = \"memory\"\n    _syntax_  = f\"{_cmdline_} (watch|unwatch|reset|list)\"\n\n    def __init__(self) -> None:\n        super().__init__(prefix=True)\n        return\n\n    @only_if_gdb_running\n    def do_invoke(self, argv: list[str]) -> None:\n        self.usage()\n        return\n\n\n@register\nclass MemoryWatchCommand(GenericCommand):\n    \"\"\"Adds address ranges to the memory view.\"\"\"\n    _cmdline_ = \"memory watch\"\n    _syntax_  = f\"{_cmdline_} ADDRESS [SIZE] [(qword|dword|word|byte|pointers)]\"\n    _example_ = (f\"\\n{_cmdline_} 0x603000 0x100 byte\"\n                 f\"\\n{_cmdline_} $sp\")\n\n    def __init__(self) -> None:\n        super().__init__(complete=gdb.COMPLETE_LOCATION)\n        return\n\n    @only_if_gdb_running\n    def do_invoke(self, argv: list[str]) -> None:\n        if len(argv) not in (1, 2, 3):\n            self.usage()\n            return\n\n        address = parse_address(argv[0])\n        size    = parse_address(argv[1]) if len(argv) > 1 else 0x10\n        group   = \"byte\"\n\n        if len(argv) == 3:\n            group = argv[2].lower()\n            if group not in (\"qword\", \"dword\", \"word\", \"byte\", \"pointers\"):\n                warn(f\"Unexpected grouping '{group}'\")\n                self.usage()\n                return\n        else:\n            if gef.arch.ptrsize == 4:\n                group = \"dword\"\n            elif gef.arch.ptrsize == 8:\n                group = \"qword\"\n\n        gef.ui.watches[address] = (size, group)\n        ok(f\"Adding memwatch to {address:#x}\")\n        return\n\n\n@register\nclass MemoryUnwatchCommand(GenericCommand):\n    \"\"\"Removes address ranges to the memory view.\"\"\"\n    _cmdline_ = \"memory unwatch\"\n    _syntax_  = f\"{_cmdline_} ADDRESS\"\n    _example_ = (f\"\\n{_cmdline_} 0x603000\"\n                 f\"\\n{_cmdline_} $sp\")\n\n    def __init__(self) -> None:\n        super().__init__(complete=gdb.COMPLETE_LOCATION)\n        return\n\n    @only_if_gdb_running\n    def do_invoke(self, argv: list[str]) -> None:\n        if not argv:\n            self.usage()\n            return\n\n        address = parse_address(argv[0])\n        res = gef.ui.watches.pop(address, None)\n        if not res:\n            warn(f\"You weren't watching {address:#x}\")\n        else:\n            ok(f\"Removed memwatch of {address:#x}\")\n        return\n\n\n@register\nclass MemoryWatchResetCommand(GenericCommand):\n    \"\"\"Removes all watchpoints.\"\"\"\n    _cmdline_ = \"memory reset\"\n    _syntax_  = f\"{_cmdline_}\"\n\n    @only_if_gdb_running\n    def do_invoke(self, _: list[str]) -> None:\n        gef.ui.watches.clear()\n        ok(\"Memory watches cleared\")\n        return\n\n\n@register\nclass MemoryWatchListCommand(GenericCommand):\n    \"\"\"Lists all watchpoints to display in context layout.\"\"\"\n    _cmdline_ = \"memory list\"\n    _syntax_  = f\"{_cmdline_}\"\n\n    @only_if_gdb_running\n    def do_invoke(self, _: list[str]) -> None:\n        if not gef.ui.watches:\n            info(\"No memory watches\")\n            return\n\n        info(\"Memory watches:\")\n        for address, opt in sorted(gef.ui.watches.items()):\n            gef_print(f\"- {address:#x} ({opt[0]}, {opt[1]})\")\n        return\n\n\n@register\nclass HexdumpCommand(GenericCommand):\n    \"\"\"Display SIZE lines of hexdump from the memory location pointed by LOCATION.\"\"\"\n\n    _cmdline_ = \"hexdump\"\n    _syntax_  = f\"{_cmdline_} (qword|dword|word|byte) [LOCATION] [--size SIZE] [--reverse]\"\n    _example_ = f\"{_cmdline_} byte $rsp --size 16 --reverse\"\n\n    def __init__(self) -> None:\n        super().__init__(complete=gdb.COMPLETE_LOCATION, prefix=True)\n        self[\"always_show_ascii\"] = (False, \"If true, hexdump will always display the ASCII dump\")\n        self.format: str | None = None\n        self.__last_target = \"$sp\"\n        return\n\n    @only_if_gdb_running\n    @parse_arguments({\"address\": \"\",}, {(\"--reverse\", \"-r\"): False, (\"--size\", \"-s\"): 0})\n    def do_invoke(self, _: list[str], **kwargs: Any) -> None:\n        valid_formats = [\"byte\", \"word\", \"dword\", \"qword\"]\n        if not self.format or self.format not in valid_formats:\n            err(\"Invalid command\")\n            return\n\n        args : argparse.Namespace = kwargs[\"arguments\"]\n        target = args.address or self.__last_target\n        start_addr = parse_address(target)\n        read_from = align_address(start_addr)\n\n        if self.format == \"byte\":\n            read_len = args.size or 0x40\n            read_from += self.repeat_count * read_len\n            mem = gef.memory.read(read_from, read_len)\n            lines = hexdump(mem, base=read_from).splitlines()\n        else:\n            read_len = args.size or 0x10\n            lines = self._hexdump(read_from, read_len, self.format, self.repeat_count * read_len)\n\n        if args.reverse:\n            lines.reverse()\n\n        self.__last_target = target\n        gef_print(\"\\n\".join(lines))\n        return\n\n    def _hexdump(self, start_addr: int, length: int, arrange_as: str, offset: int = 0) -> list[str]:\n        endianness = gef.arch.endianness\n\n        base_address_color = gef.config[\"theme.dereference_base_address\"]\n        show_ascii = gef.config[\"hexdump.always_show_ascii\"]\n\n        formats = {\n            \"qword\": (\"Q\", 8),\n            \"dword\": (\"I\", 4),\n            \"word\": (\"H\", 2),\n        }\n\n        formatter, width = formats[arrange_as]\n        fmt_str = f\"{{base}}{VERTICAL_LINE}+{{offset:#06x}}   {{sym}}{{val:#0{width*2+2}x}}   {{text}}\"\n        fmt_pack = f\"{endianness!s}{formatter}\"\n        lines = []\n\n        i = 0\n        text = \"\"\n        while i < length:\n            cur_addr = start_addr + (i + offset) * width\n            sym = gdb_get_location_from_symbol(cur_addr)\n            sym = f\"<{sym[0]:s}+{sym[1]:04x}> \" if sym else \"\"\n            mem = gef.memory.read(cur_addr, width)\n            val = struct.unpack(fmt_pack, mem)[0]\n            if show_ascii:\n                text = \"\".join([chr(b) if 0x20 <= b < 0x7F else \".\" for b in mem])\n            lines.append(fmt_str.format(base=Color.colorify(format_address(cur_addr), base_address_color),\n                                        offset=(i + offset) * width, sym=sym, val=val, text=text))\n            i += 1\n\n        return lines\n\n\n@register\nclass HexdumpQwordCommand(HexdumpCommand):\n    \"\"\"Display SIZE lines of hexdump as QWORD from the memory location pointed by ADDRESS.\"\"\"\n\n    _cmdline_ = \"hexdump qword\"\n    _syntax_  = f\"{_cmdline_} [ADDRESS] [--size SIZE] [--reverse]\"\n    _example_ = f\"{_cmdline_} qword $rsp -s 16 --reverse\"\n\n    def __init__(self) -> None:\n        super().__init__()\n        self.format = \"qword\"\n        return\n\n\n@register\nclass HexdumpDwordCommand(HexdumpCommand):\n    \"\"\"Display SIZE lines of hexdump as DWORD from the memory location pointed by ADDRESS.\"\"\"\n\n    _cmdline_ = \"hexdump dword\"\n    _syntax_  = f\"{_cmdline_} [ADDRESS] [--size SIZE] [--reverse]\"\n    _example_ = f\"{_cmdline_} $esp -s 16 --reverse\"\n\n    def __init__(self) -> None:\n        super().__init__()\n        self.format = \"dword\"\n        return\n\n\n@register\nclass HexdumpWordCommand(HexdumpCommand):\n    \"\"\"Display SIZE lines of hexdump as WORD from the memory location pointed by ADDRESS.\"\"\"\n\n    _cmdline_ = \"hexdump word\"\n    _syntax_  = f\"{_cmdline_} [ADDRESS] [--size SIZE] [--reverse]\"\n    _example_ = f\"{_cmdline_} $esp -s 16 --reverse\"\n\n    def __init__(self) -> None:\n        super().__init__()\n        self.format = \"word\"\n        return\n\n\n@register\nclass HexdumpByteCommand(HexdumpCommand):\n    \"\"\"Display SIZE lines of hexdump as BYTE from the memory location pointed by ADDRESS.\"\"\"\n\n    _cmdline_ = \"hexdump byte\"\n    _syntax_  = f\"{_cmdline_} [ADDRESS] [--size SIZE] [--reverse]\"\n    _example_ = f\"{_cmdline_} $rsp -s 16\"\n\n    def __init__(self) -> None:\n        super().__init__()\n        self.format = \"byte\"\n        return\n\n\n@register\nclass PatchCommand(GenericCommand):\n    \"\"\"Write specified values to the specified address.\"\"\"\n\n    _cmdline_ = \"patch\"\n    _syntax_  = (f\"{_cmdline_} (qword|dword|word|byte) LOCATION VALUES\\n\"\n                 f\"{_cmdline_} string LOCATION \\\"double-escaped string\\\"\")\n    SUPPORTED_SIZES = {\n        \"qword\": (8, \"Q\"),\n        \"dword\": (4, \"L\"),\n        \"word\": (2, \"H\"),\n        \"byte\": (1, \"B\"),\n    }\n\n    def __init__(self) -> None:\n        super().__init__(prefix=True, complete=gdb.COMPLETE_LOCATION)\n        self.format: str | None = None\n        return\n\n    @only_if_gdb_running\n    @parse_arguments({\"location\": \"\", \"values\": [\"\", ]}, {})\n    def do_invoke(self, _: list[str], **kwargs: Any) -> None:\n        args : argparse.Namespace = kwargs[\"arguments\"]\n        if not self.format or self.format not in self.SUPPORTED_SIZES:\n            self.usage()\n            return\n\n        if not args.location or not args.values:\n            self.usage()\n            return\n\n        addr = align_address(parse_address(args.location))\n        size, fcode = self.SUPPORTED_SIZES[self.format]\n        values = args.values\n\n        if size == 1:\n            if values[0].startswith(\"$_gef\"):\n                var_name = values[0]\n                try:\n                    values = str(gdb.parse_and_eval(var_name)).lstrip(\"{\").rstrip(\"}\").replace(\",\",\"\").split(\" \")\n                except Exception:\n                    gef_print(f\"Bad variable specified, check value with command: p {var_name}\")\n                    return\n\n        d = str(gef.arch.endianness)\n        for value in values:\n            value = parse_address(value) & ((1 << size * 8) - 1)\n            vstr = struct.pack(d + fcode, value)\n            gef.memory.write(addr, vstr, length=size)\n            addr += size\n        return\n\n\n@register\nclass PatchQwordCommand(PatchCommand):\n    \"\"\"Write specified QWORD to the specified address.\"\"\"\n\n    _cmdline_ = \"patch qword\"\n    _syntax_  = f\"{_cmdline_} LOCATION QWORD1 [QWORD2 [QWORD3..]]\"\n    _example_ = f\"{_cmdline_} $rip 0x4141414141414141\"\n\n    def __init__(self) -> None:\n        super().__init__()\n        self.format = \"qword\"\n        return\n\n\n@register\nclass PatchDwordCommand(PatchCommand):\n    \"\"\"Write specified DWORD to the specified address.\"\"\"\n\n    _cmdline_ = \"patch dword\"\n    _syntax_  = f\"{_cmdline_} LOCATION DWORD1 [DWORD2 [DWORD3..]]\"\n    _example_ = f\"{_cmdline_} $rip 0x41414141\"\n\n    def __init__(self) -> None:\n        super().__init__()\n        self.format = \"dword\"\n        return\n\n\n@register\nclass PatchWordCommand(PatchCommand):\n    \"\"\"Write specified WORD to the specified address.\"\"\"\n\n    _cmdline_ = \"patch word\"\n    _syntax_  = f\"{_cmdline_} LOCATION WORD1 [WORD2 [WORD3..]]\"\n    _example_ = f\"{_cmdline_} $rip 0x4141\"\n\n    def __init__(self) -> None:\n        super().__init__()\n        self.format = \"word\"\n        return\n\n\n@register\nclass PatchByteCommand(PatchCommand):\n    \"\"\"Write specified BYTE to the specified address.\"\"\"\n\n    _cmdline_ = \"patch byte\"\n    _syntax_  = f\"{_cmdline_} LOCATION BYTE1 [BYTE2 [BYTE3..]]\"\n    _example_ = f\"{_cmdline_} $pc 0x41 0x41 0x41 0x41 0x41\"\n\n    def __init__(self) -> None:\n        super().__init__()\n        self.format = \"byte\"\n        return\n\n\n@register\nclass PatchStringCommand(GenericCommand):\n    \"\"\"Write specified string to the specified memory location pointed by ADDRESS.\"\"\"\n\n    _cmdline_ = \"patch string\"\n    _syntax_  = f\"{_cmdline_} ADDRESS \\\"double backslash-escaped string\\\"\"\n    _example_ = [\n        f\"{_cmdline_} $sp \\\"GEFROCKS\\\"\",\n        f\"{_cmdline_} $sp \\\"\\\\\\\\x41\\\\\\\\x41\\\\\\\\x41\\\\\\\\x41\\\"\"\n    ]\n\n    @only_if_gdb_running\n    def do_invoke(self, argv: list[str]) -> None:\n        argc = len(argv)\n        if argc != 2:\n            self.usage()\n            return\n\n        location, msg = argv[0:2]\n        addr = align_address(parse_address(location))\n\n        try:\n            msg_as_bytes = codecs.escape_decode(msg, \"utf-8\")[0]\n            gef.memory.write(addr, msg_as_bytes, len(msg_as_bytes)) # type: ignore\n        except (binascii.Error, gdb.error):\n            err(f\"Could not decode '\\\\xXX' encoded string \\\"{msg}\\\"\")\n        return\n\n\n@lru_cache()\ndef dereference_from(address: int) -> list[str]:\n    if not is_alive():\n        return [format_address(address),]\n\n    code_color = gef.config[\"theme.dereference_code\"]\n    string_color = gef.config[\"theme.dereference_string\"]\n    max_recursion = gef.config[\"dereference.max_recursion\"] or 10\n    addr = lookup_address(align_address(address))\n    msg = [format_address(addr.value),]\n    seen_addrs = set()\n\n    while addr.section and max_recursion:\n        if addr.value in seen_addrs:\n            msg.append(\"[loop detected]\")\n            break\n        seen_addrs.add(addr.value)\n\n        max_recursion -= 1\n\n        # Is this value a pointer or a value?\n        # -- If it's a pointer, dereference\n        deref = addr.dereference()\n        if deref is None:\n            # if here, dereferencing addr has triggered a MemoryError, no need to go further\n            msg.append(str(addr))\n            break\n\n        new_addr = lookup_address(deref)\n        if new_addr.valid:\n            addr = new_addr\n            msg.append(str(addr))\n            continue\n\n        # -- Otherwise try to parse the value\n        if addr.section:\n            if addr.section.is_executable() and addr.is_in_text_segment() and not is_ascii_string(addr.value):\n                insn = gef_current_instruction(addr.value)\n                insn_str = f\"{insn.location} {insn.mnemonic} {', '.join(insn.operands)}\"\n                msg.append(Color.colorify(insn_str, code_color))\n                break\n\n            elif addr.section.permission & Permission.READ:\n                if is_ascii_string(addr.value):\n                    s = gef.memory.read_cstring(addr.value)\n                    if len(s) < gef.arch.ptrsize:\n                        txt = f'{format_address(deref)} (\"{Color.colorify(s, string_color)}\"?)'\n                    elif len(s) > GEF_MAX_STRING_LENGTH:\n                        txt = Color.colorify(f'\"{s[:GEF_MAX_STRING_LENGTH]}[...]\"', string_color)\n                    else:\n                        txt = Color.colorify(f'\"{s}\"', string_color)\n\n                    msg.append(txt)\n                    break\n\n        # if not able to parse cleanly, simply display and break\n        msg.append(format_address(deref))\n        break\n\n    return msg\n\n\n@register\nclass DereferenceCommand(GenericCommand):\n    \"\"\"Dereference recursively from an address and display information. This acts like WinDBG `dps`\n    command.\"\"\"\n\n    _cmdline_ = \"dereference\"\n    _syntax_  = f\"{_cmdline_} [-h] [--length LENGTH] [--reference REFERENCE] [address]\"\n    _aliases_ = [\"telescope\", ]\n    _example_ = f\"{_cmdline_} --length 20 --reference $sp+0x10 $sp\"\n\n    def __init__(self) -> None:\n        super().__init__(complete=gdb.COMPLETE_LOCATION)\n        self[\"max_recursion\"] = (7, \"Maximum level of pointer recursion\")\n        return\n\n    @staticmethod\n    def pprint_dereferenced(addr: int, idx: int, base_offset: int = 0) -> str:\n        base_address_color = gef.config[\"theme.dereference_base_address\"]\n        registers_color = gef.config[\"theme.dereference_register_value\"]\n\n        sep = f\" {RIGHT_ARROW} \"\n        memalign = gef.arch.ptrsize\n\n        offset = idx * memalign\n        current_address = align_address(addr + offset)\n        addrs = dereference_from(current_address)\n        addr_l = format_address(int(addrs[0], 16))\n        ma = (memalign*2 + 2)\n        line = (\n            f\"{Color.colorify(addr_l, base_address_color)}{VERTICAL_LINE}\"\n            f\"{base_offset+offset:+#07x}: {sep.join(addrs[1:]):{ma}s}\"\n        )\n\n        register_hints = []\n\n        for regname in gef.arch.all_registers:\n            regvalue = gef.arch.register(regname)\n            if current_address == regvalue:\n                register_hints.append(regname)\n\n        if register_hints:\n            m = f\"\\t{LEFT_ARROW}{', '.join(list(register_hints))}\"\n            line += Color.colorify(m, registers_color)\n\n        offset += memalign\n        return line\n\n    @only_if_gdb_running\n    @parse_arguments({\"address\": \"$sp\"}, {(\"-r\", \"--reference\"): \"\", (\"-l\", \"--length\"): 10})\n    def do_invoke(self, _: list[str], **kwargs: Any) -> None:\n        args : argparse.Namespace = kwargs[\"arguments\"]\n        nb = args.length\n\n        target = args.address\n        target_addr = parse_address(target)\n\n        reference = args.reference or target\n        ref_addr = parse_address(reference)\n\n        if process_lookup_address(target_addr) is None:\n            err(f\"Unmapped address: '{target}'\")\n            return\n\n        if process_lookup_address(ref_addr) is None:\n            err(f\"Unmapped address: '{reference}'\")\n            return\n\n        if gef.config[\"context.grow_stack_down\"] is True:\n            insnum_step = -1\n            if nb > 0:\n                from_insnum = nb * (self.repeat_count + 1) - 1\n                to_insnum = self.repeat_count * nb - 1\n            else:\n                from_insnum = self.repeat_count * nb\n                to_insnum = nb * (self.repeat_count + 1)\n        else:\n            insnum_step = 1\n            if nb > 0:\n                from_insnum = self.repeat_count * nb\n                to_insnum = nb * (self.repeat_count + 1)\n            else:\n                from_insnum = nb * (self.repeat_count + 1) + 1\n                to_insnum = (self.repeat_count * nb) + 1\n\n        start_address = align_address(target_addr)\n        base_offset = start_address - align_address(ref_addr)\n\n        dereference_cmd = gef.gdb.commands[\"dereference\"]\n        assert isinstance(dereference_cmd, DereferenceCommand)\n        for i in range(from_insnum, to_insnum, insnum_step):\n            gef_print(dereference_cmd.pprint_dereferenced(start_address, i, base_offset))\n\n        return\n\n\n@register\nclass ASLRCommand(GenericCommand):\n    \"\"\"View/modify the ASLR setting of GDB. By default, GDB will disable ASLR when it starts the process. (i.e. not\n    attached). This command allows to change that setting.\"\"\"\n\n    _cmdline_ = \"aslr\"\n    _syntax_  = f\"{_cmdline_} [(on|off)]\"\n\n    def do_invoke(self, argv: list[str]) -> None:\n        argc = len(argv)\n\n        if argc == 0:\n            ret = gdb.execute(\"show disable-randomization\", to_string=True) or \"\"\n            i = ret.find(\"virtual address space is \")\n            if i < 0:\n                return\n\n            msg = \"ASLR is currently \"\n            if ret[i + 25:].strip() == \"on.\":\n                msg += Color.redify(\"disabled\")\n            else:\n                msg += Color.greenify(\"enabled\")\n\n            gef_print(msg)\n            return\n\n        elif argc == 1:\n            if argv[0] == \"on\":\n                info(\"Enabling ASLR\")\n                gdb.execute(\"set disable-randomization off\")\n                return\n            elif argv[0] == \"off\":\n                info(\"Disabling ASLR\")\n                gdb.execute(\"set disable-randomization on\")\n                return\n\n            warn(\"Invalid command\")\n\n        self.usage()\n        return\n\n\n@register\nclass ResetCacheCommand(GenericCommand):\n    \"\"\"Reset cache of all stored data. This command is here for debugging and test purposes, GEF\n    handles properly the cache reset under \"normal\" scenario.\"\"\"\n\n    _cmdline_ = \"reset-cache\"\n    _syntax_  = _cmdline_\n\n    def do_invoke(self, _: list[str]) -> None:\n        reset_all_caches()\n        return\n\n\n@register\nclass VMMapCommand(GenericCommand):\n    \"\"\"Display a comprehensive layout of the virtual memory mapping. If a filter argument, GEF will\n    filter out the mapping whose pathname do not match that filter.\"\"\"\n\n    _cmdline_ = \"vmmap\"\n    _syntax_  = f\"{_cmdline_} [FILTER]\"\n    _example_ = f\"{_cmdline_} libc\"\n\n    @only_if_gdb_running\n    @parse_arguments({\"unknown_types\": [\"\"]}, {(\"--addr\", \"-a\"): [\"\"], (\"--name\", \"-n\"): [\"\"]})\n    def do_invoke(self, _: list[str], **kwargs: Any) -> None:\n        args : argparse.Namespace = kwargs[\"arguments\"]\n        vmmap = gef.memory.maps\n        if not vmmap:\n            err(\"No address mapping information found\")\n            return\n\n        addrs: dict[str, int] = {x: parse_address(x) for x in args.addr}\n        names: list[str] = [x for x in args.name]\n\n        for arg in args.unknown_types:\n            if not arg:\n                continue\n\n            if self.is_integer(arg):\n                addr = int(arg, 0)\n            else:\n                addr = safe_parse_and_eval(arg)\n\n            if addr is None:\n                names.append(arg)\n                warn(f\"`{arg}` has no type specified. We guessed it was a name filter.\")\n            else:\n                addrs[arg] = int(addr)\n                warn(f\"`{arg}` has no type specified. We guessed it was an address filter.\")\n            warn(\"You can use --name or --addr before the filter value for specifying its type manually.\")\n            gef_print()\n\n        if not gef.config[\"gef.disable_color\"]:\n            self.show_legend()\n\n        color = gef.config[\"theme.table_heading\"]\n\n        headers = [\"Start\", \"End\", \"Offset\", \"Perm\", \"Path\"]\n        gef_print(Color.colorify(\"{:<{w}s}{:<{w}s}{:<{w}s}{:<4s} {:s}\".format(*headers, w=gef.arch.ptrsize*2+3), color))\n\n        last_printed_filter = None\n\n        for entry in vmmap:\n            names_filter = [f\"name = '{x}'\" for x in names if x in entry.path]\n            addrs_filter = [f\"addr = {self.format_addr_filter(arg, addr)}\" for arg, addr in addrs.items()\n                if entry.page_start <= addr < entry.page_end]\n            filter_content = f\"[{' & '.join([*names_filter, *addrs_filter])}]\"\n\n            if not names and not addrs:\n                self.print_entry(entry)\n\n            elif names_filter or addrs_filter:\n                if filter_content != last_printed_filter:\n                    gef_print() # skip a line between different filters\n                    gef_print(Color.greenify(filter_content))\n                    last_printed_filter = filter_content\n                self.print_entry(entry)\n\n        gef_print()\n        return\n\n    def format_addr_filter(self, arg: str, addr: int):\n        return f\"`{arg}`\" if self.is_integer(arg) else f\"`{arg}` ({addr:#x})\"\n\n    def print_entry(self, entry: Section) -> None:\n        line_color = \"\"\n        if entry.path == \"[stack]\":\n            line_color = gef.config[\"theme.address_stack\"]\n        elif entry.path == \"[heap]\":\n            line_color = gef.config[\"theme.address_heap\"]\n        elif entry.permission & Permission.READ and entry.permission & Permission.EXECUTE:\n            line_color = gef.config[\"theme.address_code\"]\n\n        line_parts = [\n            Color.colorify(format_address(entry.page_start), line_color),\n            Color.colorify(format_address(entry.page_end), line_color),\n            Color.colorify(format_address(entry.offset), line_color),\n        ]\n        if entry.permission == Permission.ALL:\n            line_parts.append(Color.colorify(str(entry.permission), \"underline \" + line_color))\n        else:\n            line_parts.append(Color.colorify(str(entry.permission), line_color))\n\n        line_parts.append(Color.colorify(entry.path, line_color))\n        line = \" \".join(line_parts)\n\n        gef_print(line)\n        return\n\n    def show_legend(self) -> None:\n        code_title = Color.colorify(\"Code\", gef.config[\"theme.address_code\"])\n        stack_title = Color.colorify(\"Stack\", gef.config[\"theme.address_stack\"])\n        heap_title = Color.colorify(\"Heap\", gef.config[\"theme.address_heap\"])\n        gef_print(f\"[ Legend:  {code_title} | {stack_title} | {heap_title} ]\")\n        return\n\n    def is_integer(self, n: str) -> bool:\n        try:\n            int(n, 0)\n        except ValueError:\n            return False\n        return True\n\n\n@register\nclass XFilesCommand(GenericCommand):\n    \"\"\"Shows all libraries (and sections) loaded by binary. This command extends the GDB command\n    `info files`, by retrieving more information from extra sources, and providing a better\n    display. If an argument FILE is given, the output will grep information related to only that file.\n    If an argument name is also given, the output will grep to the name within FILE.\"\"\"\n\n    _cmdline_ = \"xfiles\"\n    _syntax_  = f\"{_cmdline_} [FILE [NAME]]\"\n    _example_ = f\"\\n{_cmdline_} libc\\n{_cmdline_} libc IO_vtables\"\n\n    @only_if_gdb_running\n    def do_invoke(self, argv: list[str]) -> None:\n        color = gef.config[\"theme.table_heading\"]\n        headers = [\"Start\", \"End\", \"Name\", \"File\"]\n        gef_print(Color.colorify(\"{:<{w}s}{:<{w}s}{:<21s} {:s}\".format(*headers, w=gef.arch.ptrsize*2+3), color))\n\n        filter_by_file = argv[0] if argv and argv[0] else None\n        filter_by_name = argv[1] if len(argv) > 1 and argv[1] else None\n\n        for xfile in get_info_files():\n            if filter_by_file:\n                if filter_by_file not in xfile.filename:\n                    continue\n                if filter_by_name and filter_by_name not in xfile.name:\n                    continue\n\n            line_parts = [\n                format_address(xfile.zone_start),\n                format_address(xfile.zone_end),\n                f\"{xfile.name:<21s}\",\n                xfile.filename,\n            ]\n            gef_print(\" \".join(line_parts))\n        return\n\n\n@register\nclass XAddressInfoCommand(GenericCommand):\n    \"\"\"Retrieve and display runtime information for the location(s) given as parameter.\"\"\"\n\n    _cmdline_ = \"xinfo\"\n    _syntax_  = f\"{_cmdline_} LOCATION\"\n    _example_ = f\"{_cmdline_} $pc\"\n\n    def __init__(self) -> None:\n        super().__init__(complete=gdb.COMPLETE_LOCATION)\n        return\n\n    @only_if_gdb_running\n    def do_invoke(self, argv: list[str]) -> None:\n        if not argv:\n            err(\"At least one valid address must be specified\")\n            self.usage()\n            return\n\n        for sym in argv:\n            try:\n                addr = align_address(parse_address(sym))\n                gef_print(titlify(f\"xinfo: {addr:#x}\"))\n                self.infos(addr)\n\n            except gdb.error as gdb_err:\n                err(f\"{gdb_err}\")\n        return\n\n    def infos(self, address: int) -> None:\n        addr = lookup_address(address)\n        if not addr.valid:\n            warn(f\"Cannot reach {address:#x} in memory space\")\n            return\n\n        sect = addr.section\n        info = addr.info\n\n        if sect:\n            gef_print(f\"Page: {format_address(sect.page_start)} {RIGHT_ARROW} \"\n                      f\"{format_address(sect.page_end)} (size={sect.page_end-sect.page_start:#x})\"\n                      f\"\\nPermissions: {sect.permission}\"\n                      f\"\\nPathname: {sect.path}\"\n                      f\"\\nOffset (from page): {addr.value-sect.page_start:#x}\"\n                      f\"\\nInode: {sect.inode}\")\n\n        if info:\n            gef_print(f\"Segment: {info.name} \"\n                      f\"({format_address(info.zone_start)}-{format_address(info.zone_end)})\"\n                      f\"\\nOffset (from segment): {addr.value-info.zone_start:#x}\")\n\n        sym = gdb_get_location_from_symbol(address)\n        if sym:\n            name, offset = sym\n            msg = f\"Symbol: {name}\"\n            if offset:\n                msg += f\"+{offset:d}\"\n            gef_print(msg)\n\n        return\n\n\n@register\nclass XorMemoryCommand(GenericCommand):\n    \"\"\"XOR a block of memory. The command allows to simply display the result, or patch it\n    runtime at runtime.\"\"\"\n\n    _cmdline_ = \"xor-memory\"\n    _syntax_  = f\"{_cmdline_} (display|patch) ADDRESS SIZE KEY\"\n\n    def __init__(self) -> None:\n        super().__init__(prefix=True)\n        return\n\n    def do_invoke(self, _: list[str]) -> None:\n        self.usage()\n        return\n\n\n@register\nclass XorMemoryDisplayCommand(GenericCommand):\n    \"\"\"Display a block of memory pointed by ADDRESS by xor-ing each byte with KEY. The key must be\n    provided in hexadecimal format.\"\"\"\n\n    _cmdline_ = \"xor-memory display\"\n    _syntax_  = f\"{_cmdline_} ADDRESS SIZE KEY\"\n    _example_ = f\"{_cmdline_} $sp 16 41414141\"\n\n    @only_if_gdb_running\n    def do_invoke(self, argv: list[str]) -> None:\n        if len(argv) != 3:\n            self.usage()\n            return\n\n        address = parse_address(argv[0])\n        length = int(argv[1], 0)\n        key = argv[2]\n        block = gef.memory.read(address, length)\n        info(f\"Displaying XOR-ing {address:#x}-{address + len(block):#x} with {key!r}\")\n\n        gef_print(titlify(\"Original block\"))\n        gef_print(hexdump(block, base=address))\n\n        gef_print(titlify(\"XOR-ed block\"))\n        gef_print(hexdump(xor(block, key), base=address))\n        return\n\n\n@register\nclass XorMemoryPatchCommand(GenericCommand):\n    \"\"\"Patch a block of memory pointed by ADDRESS by xor-ing each byte with KEY. The key must be\n    provided in hexadecimal format.\"\"\"\n\n    _cmdline_ = \"xor-memory patch\"\n    _syntax_  = f\"{_cmdline_} ADDRESS SIZE KEY\"\n    _example_ = f\"{_cmdline_} $sp 16 41414141\"\n\n    @only_if_gdb_running\n    def do_invoke(self, argv: list[str]) -> None:\n        if len(argv) != 3:\n            self.usage()\n            return\n\n        address = parse_address(argv[0])\n        length = int(argv[1], 0)\n        key = argv[2]\n        block = gef.memory.read(address, length)\n        info(f\"Patching XOR-ing {address:#x}-{address + len(block):#x} with {key!r}\")\n        xored_block = xor(block, key)\n        gef.memory.write(address, xored_block, length)\n        return\n\n\n@register\nclass TraceRunCommand(GenericCommand):\n    \"\"\"Create a runtime trace of all instructions executed from $pc to LOCATION specified. The\n    trace is stored in a text file that can be next imported in IDA Pro to visualize the runtime\n    path.\"\"\"\n\n    _cmdline_ = \"trace-run\"\n    _syntax_  = f\"{_cmdline_} LOCATION [MAX_CALL_DEPTH]\"\n    _example_ = f\"{_cmdline_} 0x555555554610\"\n\n    def __init__(self) -> None:\n        super().__init__(self._cmdline_, complete=gdb.COMPLETE_LOCATION)\n        self[\"max_tracing_recursion\"] = (1, \"Maximum depth of tracing\")\n        self[\"tracefile_prefix\"] = (\"./gef-trace-\", \"Specify the tracing output file prefix\")\n        return\n\n    @only_if_gdb_running\n    def do_invoke(self, argv: list[str]) -> None:\n        if len(argv) not in (1, 2):\n            self.usage()\n            return\n\n        if len(argv) == 2 and argv[1].isdigit():\n            depth = int(argv[1])\n        else:\n            depth = 1\n\n        try:\n            loc_start   = gef.arch.pc\n            loc_end     = parse_address(argv[0])\n        except gdb.error as e:\n            err(f\"Invalid location: {e}\")\n            return\n\n        self.trace(loc_start, loc_end, depth)\n        return\n\n    def get_frames_size(self) -> int:\n        n = 0\n        f = gdb.newest_frame()\n        while f:\n            n += 1\n            f = f.older()\n        return n\n\n    def trace(self, loc_start: int, loc_end: int, depth: int) -> None:\n        info(f\"Tracing from {loc_start:#x} to {loc_end:#x} (max depth={depth:d})\")\n        logfile = f\"{self['tracefile_prefix']}{loc_start:#x}-{loc_end:#x}.txt\"\n        with RedirectOutputContext(to_file=logfile):\n            hide_context()\n            self.start_tracing(loc_start, loc_end, depth)\n            unhide_context()\n        ok(f\"Done, logfile stored as '{logfile}'\")\n        info(\"Hint: import logfile with `ida_color_gdb_trace.py` script in IDA to visualize path\")\n        return\n\n    def start_tracing(self, loc_start: int, loc_end: int, depth: int) -> None:\n        loc_cur = loc_start\n        frame_count_init = self.get_frames_size()\n\n        gef_print(\"#\",\n                  f\"# Execution tracing of {get_filepath()}\",\n                  f\"# Start address: {format_address(loc_start)}\",\n                  f\"# End address: {format_address(loc_end)}\",\n                  f\"# Recursion level: {depth:d}\",\n                  \"# automatically generated by gef.py\",\n                  \"#\\n\", sep=\"\\n\")\n\n        while loc_cur != loc_end:\n            try:\n                delta = self.get_frames_size() - frame_count_init\n\n                if delta <= depth:\n                    gdb.execute(\"stepi\")\n                else:\n                    gdb.execute(\"finish\")\n\n                loc_cur = gef.arch.pc\n                gdb.flush()\n\n            except gdb.error as e:\n                gef_print(\"#\",\n                          f\"# Execution interrupted at address {format_address(loc_cur)}\",\n                          f\"# Exception: {e}\",\n                          \"#\\n\", sep=\"\\n\")\n                break\n\n        return\n\n\n@register\nclass PatternCommand(GenericCommand):\n    \"\"\"Generate or Search a De Bruijn Sequence of unique substrings of length N\n    and a total length of LENGTH. The default value of N is set to match the\n    currently loaded architecture.\"\"\"\n\n    _cmdline_ = \"pattern\"\n    _syntax_  = f\"{_cmdline_} (create|search) ARGS\"\n\n    def __init__(self) -> None:\n        super().__init__(prefix=True)\n        self[\"length\"] = (1024, \"Default length of a cyclic buffer to generate\")\n        return\n\n    def do_invoke(self, _: list[str]) -> None:\n        self.usage()\n        return\n\n\n@register\nclass PatternCreateCommand(GenericCommand):\n    \"\"\"Generate a De Bruijn Sequence of unique substrings of length N and a\n    total length of LENGTH. The default value of N is set to match the currently\n    loaded architecture.\"\"\"\n\n    _cmdline_ = \"pattern create\"\n    _syntax_  = f\"{_cmdline_} [-h] [-n N] [length]\"\n    _example_ = [\n        f\"{_cmdline_} 4096\",\n        f\"{_cmdline_} -n 4 128\"\n    ]\n\n    @parse_arguments({\"length\": 0}, {\"-n\": 0,})\n    def do_invoke(self, _: list[str], **kwargs: Any) -> None:\n        args : argparse.Namespace = kwargs[\"arguments\"]\n        length = args.length or gef.config[\"pattern.length\"]\n        n = args.n or gef.arch.ptrsize\n        info(f\"Generating a pattern of {length:d} bytes (n={n:d})\")\n        pattern_str = gef_pystring(generate_cyclic_pattern(length, n))\n        gef_print(pattern_str)\n        ok(f\"Saved as '{gef_convenience(pattern_str)}'\")\n        return\n\n\n@register\nclass PatternSearchCommand(GenericCommand):\n    \"\"\"Search a De Bruijn Sequence of unique substrings of length N and a\n    maximum total length of MAX_LENGTH. The default value of N is set to match\n    the currently loaded architecture. The PATTERN argument can be a GDB symbol\n    (such as a register name), a string or a hexadecimal value\"\"\"\n\n    _cmdline_ = \"pattern search\"\n    _syntax_  = f\"{_cmdline_} [-h] [-n N] [--max-length MAX_LENGTH] [pattern]\"\n    _example_ = [f\"{_cmdline_} $pc\",\n                 f\"{_cmdline_} 0x61616164\",\n                 f\"{_cmdline_} aaab\"]\n    _aliases_ = [\"pattern offset\"]\n\n    @only_if_gdb_running\n    @parse_arguments({\"pattern\": \"\"}, {(\"--period\", \"-n\"): 0, (\"--max-length\", \"-l\"): 0})\n    def do_invoke(self, _: list[str], **kwargs: Any) -> None:\n        args = kwargs[\"arguments\"]\n        if not args.pattern:\n            warn(\"No pattern provided\")\n            return\n\n        max_length = args.max_length or gef.config[\"pattern.length\"]\n        n = args.period or gef.arch.ptrsize\n        if n not in (2, 4, 8) or n > gef.arch.ptrsize:\n            err(\"Incorrect value for period\")\n            return\n        self.search(args.pattern, max_length, n)\n        return\n\n    def search(self, pattern: str, size: int, period: int) -> None:\n        pattern_be, pattern_le = None, None\n\n        # 1. check if it's a symbol (like \"$sp\" or \"0x1337\")\n        symbol = safe_parse_and_eval(pattern)\n        if symbol:\n            addr = int(abs(to_unsigned_long(symbol)))\n            dereferenced_value = dereference(addr)\n            if dereferenced_value:\n                addr = int(abs(to_unsigned_long(dereferenced_value)))\n            mask = (1<<(8 * period))-1\n            addr &= mask\n            pattern_le = addr.to_bytes(period, 'little')\n            pattern_be = addr.to_bytes(period, 'big')\n        else:\n            # 2. assume it's a plain string\n            pattern_be = gef_pybytes(pattern)\n            pattern_le = gef_pybytes(pattern[::-1])\n\n        info(f\"Searching for '{pattern_le.hex()}'/'{pattern_be.hex()}' with period={period}\")\n        cyclic_pattern = generate_cyclic_pattern(size, period)\n        off = cyclic_pattern.find(pattern_le)\n        if off >= 0:\n            ok(f\"Found at offset {off:d} (little-endian search) \"\n               f\"{Color.colorify('likely', 'bold red') if gef.arch.endianness == Endianness.LITTLE_ENDIAN else ''}\")\n            return\n\n        off = cyclic_pattern.find(pattern_be)\n        if off >= 0:\n            ok(f\"Found at offset {off:d} (big-endian search) \"\n               f\"{Color.colorify('likely', 'bold green') if gef.arch.endianness == Endianness.BIG_ENDIAN else ''}\")\n            return\n\n        err(f\"Pattern '{pattern}' not found\")\n        return\n\n\n@register\nclass ChecksecCommand(GenericCommand):\n    \"\"\"Checksec the security properties of the current executable or passed as argument. The\n    command checks for the following protections:\n    - PIE\n    - NX\n    - RelRO\n    - Glibc Stack Canaries\n    - Fortify Source\"\"\"\n\n    _cmdline_ = \"checksec\"\n    _syntax_  = f\"{_cmdline_} [FILENAME]\"\n    _example_ = f\"{_cmdline_} /bin/ls\"\n\n    def __init__(self) -> None:\n        super().__init__(complete=gdb.COMPLETE_FILENAME)\n        return\n\n    def do_invoke(self, argv: list[str]) -> None:\n        argc = len(argv)\n\n        if argc == 0:\n            filename = get_filepath()\n            if filename is None:\n                warn(\"No executable/library specified\")\n                return\n        elif argc == 1:\n            filename = os.path.realpath(os.path.expanduser(argv[0]))\n            if not os.access(filename, os.R_OK):\n                err(\"Invalid filename\")\n                return\n        else:\n            self.usage()\n            return\n\n        info(f\"{self._cmdline_} for '{filename}'\")\n        self.print_security_properties(filename)\n        return\n\n    def print_security_properties(self, filename: str) -> None:\n        sec = Elf(filename).checksec\n        for prop in sec:\n            if prop in (\"Partial RelRO\", \"Full RelRO\"): continue\n            val = sec[prop]\n            msg = Color.greenify(Color.boldify(TICK)) if val is True else Color.redify(Color.boldify(CROSS))\n            if val and prop == \"Canary\" and is_alive():\n                canary = gef.session.canary[0] if gef.session.canary else 0\n                msg += f\"(value: {canary:#x})\"\n\n            gef_print(f\"{prop:<30s}: {msg}\")\n\n        if sec[\"Full RelRO\"]:\n            gef_print(f\"{'RelRO':<30s}: {Color.greenify('Full')}\")\n        elif sec[\"Partial RelRO\"]:\n            gef_print(f\"{'RelRO':<30s}: {Color.yellowify('Partial')}\")\n        else:\n            gef_print(f\"{'RelRO':<30s}: {Color.redify(Color.boldify(CROSS))}\")\n        return\n\n\n@register\nclass GotCommand(GenericCommand):\n    \"\"\"Display current status of the got inside the process.\"\"\"\n\n    _cmdline_ = \"got\"\n    _syntax_ = f\"{_cmdline_} [FUNCTION_NAME ...] \"\n    _example_ = \"got read printf exit\"\n\n    def __init__(self):\n        super().__init__()\n        self[\"function_resolved\"] = (\"green\",\n                                     \"Line color of the got command output for resolved function\")\n        self[\"function_not_resolved\"] = (\"yellow\",\n                                         \"Line color of the got command output for unresolved function\")\n        return\n\n    def build_line(self, name: str, color: str, address_val: int, got_address: int) -> str:\n        line = f\"[{hex(address_val)}] \"\n        line += Color.colorify(f\"{name} {RIGHT_ARROW} {hex(got_address)}\", color)\n        return line\n\n    @only_if_gdb_running\n    @parse_arguments({\"symbols\": [\"\"]}, {\"--all\": False})\n    def do_invoke(self, _: list[str], **kwargs: Any) -> None:\n        args : argparse.Namespace = kwargs[\"arguments\"]\n        vmmap = gef.memory.maps\n        mapfiles = [mapfile for mapfile in vmmap if\n                    (args.all or mapfile.path == str(gef.session.file)) and\n                    pathlib.Path(mapfile.realpath).is_file() and\n                    mapfile.permission & Permission.EXECUTE]\n        for mapfile in mapfiles:\n            self.print_got_for(mapfile.path, mapfile.realpath, args.symbols)\n\n    def print_got_for(self, file: str, realpath: str, argv: list[str]) -> None:\n        readelf = gef.session.constants[\"readelf\"]\n\n        elf_file = realpath\n        elf_virtual_path = file\n\n        func_names_filter = argv if argv else []\n        vmmap = gef.memory.maps\n        base_address = min(x.page_start for x in vmmap if x.path == elf_virtual_path)\n        end_address = max(x.page_end for x in vmmap if x.path == elf_virtual_path)\n\n        # get the checksec output.\n        checksec_status = Elf(elf_file).checksec\n        relro_status = \"Full RelRO\"\n        full_relro = checksec_status[\"Full RelRO\"]\n        pie = checksec_status[\"PIE\"]  # if pie we will have offset instead of abs address.\n\n        if not full_relro:\n            relro_status = \"Partial RelRO\"\n            partial_relro = checksec_status[\"Partial RelRO\"]\n\n            if not partial_relro:\n                relro_status = \"No RelRO\"\n\n        # retrieve jump slots using readelf\n        lines = gef_execute_external([readelf, \"--wide\", \"--relocs\", elf_file], as_list=True)\n        jmpslots = [line for line in lines if \"JUMP\" in line]\n\n        gef_print(f\"{titlify(file)}\\n\\nGOT protection: {relro_status} | GOT functions: {len(jmpslots)}\\n \")\n\n        for line in jmpslots:\n            address, _, _, _, name = line.split()[:5]\n\n            # if we have a filter let's skip the entries that are not requested.\n            if func_names_filter:\n                if not any(map(lambda x: x in name, func_names_filter)):\n                    continue\n\n            address_val = int(address, 16)\n\n            # address_val is an offset from the base_address if we have PIE.\n            if pie or is_remote_debug():\n                address_val = base_address + address_val\n\n            # read the address of the function.\n            got_address = gef.memory.read_integer(address_val)\n\n            # for the swag: different colors if the function has been resolved or not.\n            if base_address < got_address < end_address:\n                color = self[\"function_not_resolved\"]\n            else:\n                color = self[\"function_resolved\"]\n\n            line = self.build_line(name, color, address_val, got_address)\n            gef_print(line)\n        return\n\n\n@register\nclass HighlightCommand(GenericCommand):\n    \"\"\"Highlight user-defined text matches in GEF output universally.\"\"\"\n    _cmdline_ = \"highlight\"\n    _syntax_ = f\"{_cmdline_} (add|remove|list|clear)\"\n    _aliases_ = [\"hl\"]\n\n    def __init__(self) -> None:\n        super().__init__(prefix=True)\n        self[\"regex\"] = (False, \"Enable regex highlighting\")\n\n    def do_invoke(self, _: list[str]) -> None:\n        return self.usage()\n\n\n@register\nclass HighlightListCommand(GenericCommand):\n    \"\"\"Show the current highlight table with matches to colors.\"\"\"\n    _cmdline_ = \"highlight list\"\n    _aliases_ = [\"highlight ls\", \"hll\"]\n    _syntax_ = _cmdline_\n\n    def print_highlight_table(self) -> None:\n        if not gef.ui.highlight_table:\n            err(\"no matches found\")\n            return\n\n        left_pad = max(map(len, gef.ui.highlight_table.keys()))\n        for match, color in sorted(gef.ui.highlight_table.items()):\n            print(f\"{Color.colorify(match.ljust(left_pad), color)} {VERTICAL_LINE} \"\n                  f\"{Color.colorify(color, color)}\")\n        return\n\n    def do_invoke(self, _: list[str]) -> None:\n        return self.print_highlight_table()\n\n\n@register\nclass HighlightClearCommand(GenericCommand):\n    \"\"\"Clear the highlight table, remove all matches.\"\"\"\n    _cmdline_ = \"highlight clear\"\n    _aliases_ = [\"hlc\"]\n    _syntax_ = _cmdline_\n\n    def do_invoke(self, _: list[str]) -> None:\n        return gef.ui.highlight_table.clear()\n\n\n@register\nclass HighlightAddCommand(GenericCommand):\n    \"\"\"Add a match to the highlight table.\"\"\"\n    _cmdline_ = \"highlight add\"\n    _syntax_ = f\"{_cmdline_} MATCH COLOR\"\n    _aliases_ = [\"highlight set\", \"hla\"]\n    _example_ = f\"{_cmdline_} 41414141 yellow\"\n\n    def do_invoke(self, argv: list[str]) -> None:\n        if len(argv) < 2:\n            return self.usage()\n\n        match, color = argv\n        gef.ui.highlight_table[match] = color\n        return\n\n\n@register\nclass HighlightRemoveCommand(GenericCommand):\n    \"\"\"Remove a match in the highlight table.\"\"\"\n    _cmdline_ = \"highlight remove\"\n    _syntax_ = f\"{_cmdline_} MATCH\"\n    _aliases_ = [\n        \"highlight delete\",\n        \"highlight del\",\n        \"highlight unset\",\n        \"highlight rm\",\n        \"hlr\",\n    ]\n    _example_ = f\"{_cmdline_} remove 41414141\"\n\n    def do_invoke(self, argv: list[str]) -> None:\n        if not argv:\n            return self.usage()\n\n        gef.ui.highlight_table.pop(argv[0], None)\n        return\n\n\n@register\nclass FormatStringSearchCommand(GenericCommand):\n    \"\"\"Exploitable format-string helper: this command will set up specific breakpoints\n    at well-known dangerous functions (printf, snprintf, etc.), and check if the pointer\n    holding the format string is writable, and therefore susceptible to format string\n    attacks if an attacker can control its content.\"\"\"\n    _cmdline_ = \"format-string-helper\"\n    _syntax_ = _cmdline_\n    _aliases_ = [\"fmtstr-helper\",]\n\n    def do_invoke(self, _: list[str]) -> None:\n        dangerous_functions = {\n            \"printf\": 0,\n            \"sprintf\": 1,\n            \"fprintf\": 1,\n            \"snprintf\": 2,\n            \"vsnprintf\": 2,\n        }\n\n        nb_installed_breaks = 0\n\n        with RedirectOutputContext(to_file=\"/dev/null\"):\n            for function_name in dangerous_functions:\n                argument_number = dangerous_functions[function_name]\n                FormatStringBreakpoint(function_name, argument_number)\n                nb_installed_breaks += 1\n\n        ok(f\"Enabled {nb_installed_breaks} FormatString \"\n           f\"breakpoint{'s' if nb_installed_breaks > 1 else ''}\")\n        return\n\n\n@register\nclass HeapAnalysisCommand(GenericCommand):\n    \"\"\"Heap vulnerability analysis helper: this command aims to track dynamic heap allocation\n    done through malloc()/free() to provide some insights on possible heap vulnerabilities. The\n    following vulnerabilities are checked:\n    - NULL free\n    - Use-after-Free\n    - Double Free\n    - Heap overlap\"\"\"\n    _cmdline_ = \"heap-analysis-helper\"\n    _syntax_ = _cmdline_\n\n    def __init__(self) -> None:\n        super().__init__(complete=gdb.COMPLETE_NONE)\n        self[\"check_free_null\"] = (False, \"Break execution when a free(NULL) is encountered\")\n        self[\"check_double_free\"] = (True, \"Break execution when a double free is encountered\")\n        self[\"check_weird_free\"] = (True, \"Break execution when free() is called against a non-tracked pointer\")\n        self[\"check_uaf\"] = (True, \"Break execution when a possible Use-after-Free condition is found\")\n        self[\"check_heap_overlap\"] = (True, \"Break execution when a possible overlap in allocation is found\")\n\n        self.bp_malloc = None\n        self.bp_calloc = None\n        self.bp_free = None\n        self.bp_realloc = None\n        return\n\n    @only_if_gdb_running\n    @experimental_feature\n    def do_invoke(self, argv: list[str]) -> None:\n        if not argv:\n            self.setup()\n            return\n\n        if argv[0] == \"show\":\n            self.dump_tracked_allocations()\n        return\n\n    def setup(self) -> None:\n        ok(\"Tracking malloc() & calloc()\")\n        self.bp_malloc = TraceMallocBreakpoint(\"__libc_malloc\")\n        self.bp_calloc = TraceMallocBreakpoint(\"__libc_calloc\")\n        ok(\"Tracking free()\")\n        self.bp_free = TraceFreeBreakpoint()\n        ok(\"Tracking realloc()\")\n        self.bp_realloc = TraceReallocBreakpoint()\n\n        ok(\"Disabling hardware watchpoints (this may increase the latency)\")\n        gdb.execute(\"set can-use-hw-watchpoints 0\")\n\n        info(\"Dynamic breakpoints correctly setup, \"\n             \"GEF will break execution if a possible vulnerability is found.\")\n        warn(f\"{Color.colorify('Note', 'bold underline yellow')}: \"\n             \"The heap analysis slows down the execution noticeably.\")\n\n        # when inferior quits, we need to clean everything for a next execution\n        gef_on_exit_hook(self.clean)\n        return\n\n    def dump_tracked_allocations(self) -> None:\n        global gef\n\n        if gef.session.heap_allocated_chunks:\n            ok(\"Tracked as in-use chunks:\")\n            for addr, sz in gef.session.heap_allocated_chunks:\n                gef_print(f\"{CROSS} malloc({sz:d}) = {addr:#x}\")\n        else:\n            ok(\"No malloc() chunk tracked\")\n\n        if gef.session.heap_freed_chunks:\n            ok(\"Tracked as free-ed chunks:\")\n            for addr, sz in gef.session.heap_freed_chunks:\n                gef_print(f\"{TICK}  free({sz:d}) = {addr:#x}\")\n        else:\n            ok(\"No free() chunk tracked\")\n        return\n\n    def clean(self, _: \"gdb.ExitedEvent\") -> None:\n        global gef\n\n        ok(f\"{Color.colorify('Heap-Analysis', 'yellow bold')} - Cleaning up\")\n        for bp in [self.bp_malloc, self.bp_calloc, self.bp_free, self.bp_realloc]:\n            if hasattr(bp, \"retbp\") and bp.retbp:\n                try:\n                    bp.retbp.delete()\n                except RuntimeError:\n                    # in some cases, gdb was found failing to correctly remove the retbp\n                    # but they can be safely ignored since the debugging session is over\n                    pass\n\n            bp.delete()\n\n        for wp in gef.session.heap_uaf_watchpoints:\n            wp.delete()\n\n        gef.session.heap_allocated_chunks = []\n        gef.session.heap_freed_chunks = []\n        gef.session.heap_uaf_watchpoints = []\n\n        ok(f\"{Color.colorify('Heap-Analysis', 'yellow bold')} - Re-enabling hardware watchpoints\")\n        gdb.execute(\"set can-use-hw-watchpoints 1\")\n\n        gef_on_exit_unhook(self.clean)\n        return\n\n\n#\n# GDB Function declaration\n#\n@deprecated(\"\")\ndef register_function(cls: Type[\"GenericFunction\"]) -> Type[\"GenericFunction\"]:\n    \"\"\"Decorator for registering a new convenience function to GDB.\"\"\"\n    return cls\n\n\nclass GenericFunction(gdb.Function):\n    \"\"\"This is an abstract class for invoking convenience functions, should not be instantiated.\"\"\"\n\n    _function_ : str\n    _syntax_: str = \"\"\n    _example_ : str = \"\"\n\n    def __init__(self) -> None:\n        super().__init__(self._function_)\n\n    def invoke(self, *args: Any) -> int:\n        if not is_alive():\n            raise gdb.GdbError(\"No debugging session active\")\n        return self.do_invoke(args)\n\n    def arg_to_long(self, args: Any, index: int, default: int = 0) -> int:\n        try:\n            addr = args[index]\n            return int(addr) if addr.address is None else int(addr.address)\n        except IndexError:\n            return default\n\n    def do_invoke(self, args: Any) -> int:\n        raise NotImplementedError\n\n\n@register\nclass StackOffsetFunction(GenericFunction):\n    \"\"\"Return the current stack base address plus an optional offset.\"\"\"\n    _function_ = \"_stack\"\n    _syntax_   = f\"${_function_}()\"\n\n    def do_invoke(self, args: list) -> int:\n        base = get_section_base_address(\"[stack]\")\n        if not base:\n            raise gdb.GdbError(\"Stack not found\")\n\n        return self.arg_to_long(args, 0) + base\n\n\n@register\nclass HeapBaseFunction(GenericFunction):\n    \"\"\"Return the current heap base address plus an optional offset.\"\"\"\n    _function_ = \"_heap\"\n    _syntax_   = f\"${_function_}()\"\n\n    def do_invoke(self, args: list[str]) -> int:\n        base = gef.heap.base_address\n        if not base:\n            base = get_section_base_address(\"[heap]\")\n            if not base:\n                raise gdb.GdbError(\"Heap not found\")\n        return self.arg_to_long(args, 0) + base\n\n\n@register\nclass SectionBaseFunction(GenericFunction):\n    \"\"\"Return the matching file's base address plus an optional offset.\n    Defaults to current file. Note that quotes need to be escaped\"\"\"\n    _function_ = \"_base\"\n    _syntax_   = \"$_base([filepath])\"\n    _example_  = \"p $_base(\\\\\\\"/usr/lib/ld-2.33.so\\\\\\\")\"\n\n    def do_invoke(self, args: list) -> int:\n        addr = 0\n        try:\n            name = args[0].string()\n        except IndexError:\n            assert gef.session.file\n            name = gef.session.file.name\n        except gdb.error:\n            err(f\"Invalid arg: {args[0]}\")\n            return 0\n\n        try:\n            base = get_section_base_address(name)\n            if base:\n                addr = int(base)\n        except TypeError:\n            err(f\"Cannot find section {name}\")\n            return 0\n        return addr\n\n\n@register\nclass BssBaseFunction(GenericFunction):\n    \"\"\"Return the current bss base address plus the given offset.\"\"\"\n    _function_ = \"_bss\"\n    _syntax_   = f\"${_function_}([OFFSET])\"\n    _example_ = \"deref $_bss(0x20)\"\n\n    def do_invoke(self, args: list) -> int:\n        base = get_zone_base_address(\".bss\")\n        if not base:\n            raise gdb.GdbError(\"BSS not found\")\n        return self.arg_to_long(args, 0) + base\n\n\n@register\nclass GotBaseFunction(GenericFunction):\n    \"\"\"Return the current GOT base address plus the given offset.\"\"\"\n    _function_ = \"_got\"\n    _syntax_   = f\"${_function_}([OFFSET])\"\n    _example_ = \"deref $_got(0x20)\"\n\n    def do_invoke(self, args: list) -> int:\n        base = get_zone_base_address(\".got\")\n        if not base:\n            raise gdb.GdbError(\"GOT not found\")\n        return base + self.arg_to_long(args, 0)\n\n\n@register\nclass GefFunctionsCommand(GenericCommand):\n    \"\"\"List the convenience functions provided by GEF.\"\"\"\n    _cmdline_ = \"functions\"\n    _syntax_ = _cmdline_\n\n    def __init__(self) -> None:\n        super().__init__()\n        self.docs = []\n        self.should_refresh = True\n        return\n\n    def __add__(self, function: GenericFunction):\n        \"\"\"Add function to documentation.\"\"\"\n        doc = getattr(function, \"__doc__\", \"\").lstrip()\n        if not hasattr(function, \"_syntax_\"):\n            raise ValueError(\"Function is invalid\")\n        syntax = getattr(function, \"_syntax_\").lstrip()\n        msg = f\"{Color.colorify(syntax, 'bold cyan')}\\n {doc}\"\n        example = getattr(function, \"_example_\", \"\").strip()\n        if example:\n            msg += f\"\\n {Color.yellowify('Example:')} {example}\"\n        self.docs.append(msg)\n        return self\n\n    def __radd__(self, function: GenericFunction):\n        return self.__add__(function)\n\n    def __str__(self) -> str:\n        if self.should_refresh:\n            self.__rebuild()\n        return self.__doc__ or \"\"\n\n    def __rebuild(self) -> None:\n        \"\"\"Rebuild the documentation for functions.\"\"\"\n        for function in gef.gdb.functions.values():\n            self += function\n\n        self.command_size = len(gef.gdb.commands)\n        _, cols = get_terminal_size()\n        separator = HORIZONTAL_LINE*cols\n        self.__doc__ = f\"\\n{separator}\\n\".join(sorted(self.docs))\n        self.should_refresh = False\n        return\n\n    def do_invoke(self, argv) -> None:\n        self.dont_repeat()\n        gef_print(titlify(\"GEF - Convenience Functions\"))\n        gef_print(\"These functions can be used as arguments to other \"\n                  \"commands to dynamically calculate values\\n\")\n        gef_print(str(self))\n        return\n\n\n#\n# GEF internal command classes\n#\nclass GefCommand(gdb.Command):\n    \"\"\"GEF main command: view all new commands by typing `gef`.\"\"\"\n\n    _cmdline_ = \"gef\"\n    _syntax_  = f\"{_cmdline_} (missing|config|save|restore|set|run)\"\n\n    def __init__(self) -> None:\n        super().__init__(self._cmdline_, gdb.COMMAND_SUPPORT, gdb.COMPLETE_NONE, True)\n        gef.config[\"gef.follow_child\"] = GefSetting(True, bool, \"Automatically set GDB to follow child when forking\")\n        gef.config[\"gef.readline_compat\"] = GefSetting(False, bool, \"Workaround for readline SOH/ETX issue (SEGV)\")\n        gef.config[\"gef.debug\"] = GefSetting(False, bool, \"Enable debug mode for gef\")\n        gef.config[\"gef.autosave_breakpoints_file\"] = GefSetting(\"\", str, \"Automatically save and restore breakpoints\")\n        gef.config[\"gef.disable_target_remote_overwrite\"] = GefSetting(False, bool, \"Disable the overwrite of `target remote`\")\n        plugins_dir = GefSetting(\"\", str, \"Autoload additional GEF commands from external directory\", hooks={\"on_write\": [GefSetting.no_spaces, ]})\n        plugins_dir.add_hook(\"on_changed\", [lambda _, new_val: GefSetting.must_exist(new_val), lambda _, new_val: self.load_extra_plugins(new_val), ])\n        gef.config[\"gef.extra_plugins_dir\"] = plugins_dir\n        gef.config[\"gef.disable_color\"] = GefSetting(False, bool, \"Disable all colors in GEF\")\n        gef.config[\"gef.tempdir\"] = GefSetting(GEF_TEMP_DIR, pathlib.Path, \"Directory to use for temporary/cache content\", hooks={\"on_write\": [GefSetting.no_spaces, GefSetting.create_folder_tree]})\n        gef.config[\"gef.show_deprecation_warnings\"] = GefSetting(True, bool, \"Toggle the display of the `deprecated` warnings\")\n        gef.config[\"gef.buffer\"] = GefSetting(True, bool, \"Internally buffer command output until completion\")\n        gef.config[\"gef.bruteforce_main_arena\"] = GefSetting(False, bool, \"Allow bruteforcing main_arena symbol if everything else fails\")\n        gef.config[\"gef.libc_version\"] = GefSetting(\"\", str, \"Specify libc version when auto-detection fails\")\n        gef.config[\"gef.main_arena_offset\"] = GefSetting(\"\", str, \"Offset from libc base address to main_arena symbol (int or hex). Set to empty string to disable.\")\n        gef.config[\"gef.propagate_debug_exception\"] = GefSetting(False, bool, \"If true, when debug mode is enabled, Python exceptions will be propagated all the way.\")\n\n        self.commands : dict[str, GenericCommand] = {}\n        self.functions : dict[str, GenericFunction] = {}\n        self.missing: dict[str, Exception] = {}\n        return\n\n    @property\n    @deprecated()\n    def loaded_commands(self) -> list[tuple[str, Type[GenericCommand], Any]]:\n        raise ObsoleteException(\"Obsolete loaded_commands\")\n\n    @property\n    @deprecated()\n    def loaded_functions(self) -> list[Type[GenericFunction]]:\n        raise ObsoleteException(\"Obsolete loaded_functions\")\n\n    @property\n    @deprecated()\n    def missing_commands(self) -> dict[str, Exception]:\n        raise ObsoleteException(\"Obsolete missing_commands\")\n\n    def setup(self) -> None:\n        self.load()\n\n        GefHelpCommand()\n        GefConfigCommand()\n        GefSaveCommand()\n        GefMissingCommand()\n        GefSetCommand()\n        GefRunCommand()\n        GefInstallExtraScriptCommand()\n\n        # At this point, commands (incl. extras) are loaded with default settings.\n        # Load custom settings from config file if any\n        GefRestoreCommand()\n        return\n\n    def load_extra_plugins(self, extra_plugins_dir: pathlib.Path | None = None) -> int:\n        \"\"\"Load the plugins from the gef-extras setting. Returns the number of new plugins added.\"\"\"\n        def load_plugin(fpath: pathlib.Path) -> bool:\n            try:\n                dbg(f\"Loading '{fpath}'\")\n                gdb.execute(f\"source {fpath}\")\n            except AlreadyRegisteredException:\n                pass\n            except Exception as e:\n                warn(f\"Exception while loading {fpath}: {str(e)}\")\n                return False\n            return True\n\n        def load_plugins_from_directory(plugin_directory: pathlib.Path):\n            nb_added = -1\n            nb_initial = len(__registered_commands__)\n            start_time = time.perf_counter()\n            for entry in plugin_directory.glob(\"**/*.py\"):\n                load_plugin(entry)\n\n            try:\n                nb_added = len(__registered_commands__) - nb_initial\n                if nb_added > 0:\n                    self.load()\n                    nb_failed = len(__registered_commands__) - len(self.commands)\n                    load_time = time.perf_counter() - start_time\n                    ok(f\"{Color.colorify(str(nb_added), 'bold green')} extra commands added \" \\\n                       f\"in {load_time:.2f} seconds\")\n                    if nb_failed != 0:\n                        warn(f\"{Color.colorify(str(nb_failed), 'bold light_gray')} extra commands/functions failed to be added. \"\n                        \"Check `gef missing` to know why\")\n            except gdb.error as e:\n                err(f\"failed: {e}\")\n            return nb_added\n\n        directory = extra_plugins_dir or gef.config[\"gef.extra_plugins_dir\"]\n        if not directory:\n            return 0\n        directory = pathlib.Path(directory).expanduser().absolute()\n        if not directory.exists():\n            return 0\n        dbg(f\"Loading extra plugins from directory={directory}\")\n        return load_plugins_from_directory(directory)\n\n    @property\n    def loaded_command_names(self) -> Iterable[str]:\n        print(\"obsolete loaded_command_names\")\n        return self.commands.keys()\n\n    def invoke(self, args: Any, from_tty: bool) -> None:\n        self.dont_repeat()\n        gdb.execute(\"gef help\")\n        return\n\n    def add_context_layout_mapping(self, current_pane_name: str, display_pane_function: Callable, pane_title_function: Callable, condition: Callable | None) -> None:\n        \"\"\"Add a new context layout mapping.\"\"\"\n        context = self.commands[\"context\"]\n        assert isinstance(context, ContextCommand)\n\n        # overload the printing of pane title\n        context.layout_mapping[current_pane_name] = (display_pane_function, pane_title_function, condition)\n\n    def add_context_pane(self, pane_name: str, display_pane_function: Callable, pane_title_function: Callable, condition: Callable | None) -> None:\n        \"\"\"Add a new context pane to ContextCommand.\"\"\"\n        # assure users can toggle the new context\n        corrected_settings_name: str = pane_name.replace(\" \", \"_\")\n        if corrected_settings_name in gef.config[\"context.layout\"]:\n            warn(f\"Duplicate name for `{pane_name}` (`{corrected_settings_name}`), skipping\")\n            return\n\n        gef.config[\"context.layout\"] += f\" {corrected_settings_name}\"\n        self.add_context_layout_mapping(corrected_settings_name, display_pane_function, pane_title_function, condition)\n\n    def load(self) -> None:\n        \"\"\"Load all the commands and functions defined by GEF into GDB.\"\"\"\n        current_commands = set(self.commands.keys())\n        new_commands = set(x._cmdline_ for x in __registered_commands__) - current_commands\n        current_functions = set(self.functions.keys())\n        new_functions = set(x._function_ for x in __registered_functions__) - current_functions\n        self.missing.clear()\n        self.__load_time_ms = time.time()* 1000\n\n        # load all new functions\n        for name in sorted(new_functions):\n            for function_cls in __registered_functions__:\n                if function_cls._function_ == name:\n                    assert issubclass(function_cls, GenericFunction)\n                    self.functions[name] = function_cls()\n                    break\n\n        # load all new commands\n        for name in sorted(new_commands):\n            try:\n                for command_cls in __registered_commands__:\n                    if command_cls._cmdline_ == name:\n                        assert issubclass(command_cls, GenericCommand)\n                        command_instance = command_cls()\n\n                        # create the aliases if any\n                        if hasattr(command_instance, \"_aliases_\"):\n                            aliases = getattr(command_instance, \"_aliases_\")\n                            for alias in aliases:\n                                GefAlias(alias, name)\n\n                        self.commands[name] = command_instance\n                        break\n\n            except Exception as reason:\n                self.missing[name] = reason\n\n        self.__load_time_ms = (time.time()* 1000) - self.__load_time_ms\n        return\n\n\n    def show_banner(self) -> None:\n        gef_print(f\"{Color.greenify('GEF')} for {gef.session.os} ready, \"\n                  f\"type `{Color.colorify('gef', 'underline yellow')}' to start, \"\n                  f\"`{Color.colorify('gef config', 'underline pink')}' to configure\")\n\n        ver = f\"{sys.version_info.major:d}.{sys.version_info.minor:d}\"\n        gef_print(f\"{Color.colorify(str(len(self.commands)), 'bold green')} commands loaded \"\n                    f\"and {Color.colorify(str(len(self.functions)), 'bold blue')} functions added for \"\n                    f\"GDB {Color.colorify(gdb.VERSION, 'bold yellow')} in {self.__load_time_ms:.2f}ms \"\n                    f\"using Python engine {Color.colorify(ver, 'bold red')}\")\n\n        nb_missing = len(self.missing)\n        if nb_missing:\n                warn(f\"{Color.colorify(str(nb_missing), 'bold red')} \"\n                    f\"command{'s' if nb_missing > 1 else ''} could not be loaded, \"\n                    f\"run `{Color.colorify('gef missing', 'underline pink')}` to know why.\")\n        return\n\n\nclass GefHelpCommand(gdb.Command):\n    \"\"\"GEF help sub-command.\"\"\"\n    _cmdline_ = \"gef help\"\n    _syntax_  = _cmdline_\n\n    def __init__(self) -> None:\n        super().__init__(self._cmdline_, gdb.COMMAND_SUPPORT, gdb.COMPLETE_NONE, False)\n        self.docs = []\n        self.should_refresh = True\n        self.command_size = 0\n        return\n\n    def invoke(self, args: Any, from_tty: bool) -> None:\n        self.dont_repeat()\n        gef_print(titlify(\"GEF - GDB Enhanced Features\"))\n        gef_print(str(self))\n        return\n\n    def __rebuild(self) -> None:\n        \"\"\"Rebuild the documentation.\"\"\"\n        for name, cmd in gef.gdb.commands.items():\n            self += (name, cmd)\n\n        self.command_size = len(gef.gdb.commands)\n        _, cols = get_terminal_size()\n        separator = HORIZONTAL_LINE*cols\n        self.__doc__ = f\"\\n{separator}\\n\".join(sorted(self.docs))\n        self.should_refresh = False\n        return\n\n    def __add__(self, command: tuple[str, GenericCommand]):\n        \"\"\"Add command to GEF documentation.\"\"\"\n        cmd, class_obj = command\n        if \" \" in cmd:\n            # do not print subcommands in gef help\n            return self\n        doc = getattr(class_obj, \"__doc__\", \"\").lstrip()\n        aliases = f\"Aliases: {', '.join(class_obj._aliases_)}\" if hasattr(class_obj, \"_aliases_\") else \"\"\n        msg = f\"{Color.colorify(cmd, 'bold red')}\\n{doc}\\n{aliases}\"\n        self.docs.append(msg)\n        return self\n\n    def __radd__(self, command: tuple[str, GenericCommand]):\n        return self.__add__(command)\n\n    def __str__(self) -> str:\n        \"\"\"Lazily regenerate the `gef help` object if it was modified\"\"\"\n        # quick check in case the docs have changed\n        if self.should_refresh or self.command_size != len(gef.gdb.commands):\n            self.__rebuild()\n        return self.__doc__ or \"\"\n\n\nclass GefConfigCommand(gdb.Command):\n    \"\"\"GEF configuration sub-command\n    This command will help set/view GEF settings for the current debugging session.\n    It is possible to make those changes permanent by running `gef save` (refer\n    to this command help), and/or restore previously saved settings by running\n    `gef restore` (refer help).\n    \"\"\"\n    _cmdline_ = \"gef config\"\n    _syntax_  = f\"{_cmdline_} [setting_name] [setting_value]\"\n\n    def __init__(self) -> None:\n        super().__init__(self._cmdline_, gdb.COMMAND_NONE, prefix=False)\n        return\n\n    def invoke(self, args: str, from_tty: bool) -> None:\n        self.dont_repeat()\n        argv = gdb.string_to_argv(args)\n        argc = len(argv)\n\n        if not (0 <= argc <= 2):\n            err(\"Invalid number of arguments\")\n            return\n\n        if argc == 0:\n            gef_print(titlify(\"GEF configuration settings\"))\n            self.print_settings()\n            return\n\n        if argc == 1:\n            prefix = argv[0]\n            names = [x for x in gef.config.keys() if x.startswith(prefix)]\n            if names:\n                if len(names) == 1:\n                    gef_print(titlify(f\"GEF configuration setting: {names[0]}\"))\n                    self.print_setting(names[0], verbose=True)\n                else:\n                    gef_print(titlify(f\"GEF configuration settings matching '{argv[0]}'\"))\n                    for name in names: self.print_setting(name)\n            return\n\n        if not is_debug():\n            try:\n                self.set_setting(argv)\n            except (ValueError, KeyError) as e:\n                err(str(e))\n        else:\n            # Let exceptions (if any) propagate\n            self.set_setting(argv)\n        return\n\n    def print_setting(self, plugin_name: str, verbose: bool = False) -> None:\n        res = gef.config.raw_entry(plugin_name)\n        string_color = gef.config[\"theme.dereference_string\"]\n        misc_color = gef.config[\"theme.dereference_base_address\"]\n\n        if not res:\n            return\n\n        _setting = Color.colorify(plugin_name, \"green\")\n        _type = res.type.__name__\n        if _type == \"str\":\n            _value = f'\"{Color.colorify(res.value, string_color)}\"'\n        else:\n            _value = Color.colorify(res.value, misc_color)\n\n        gef_print(f\"{_setting} ({_type}) = {_value}\")\n\n        if verbose:\n            gef_print(Color.colorify(\"\\nDescription:\", \"bold underline\"))\n            gef_print(f\"\\t{res.description}\")\n        return\n\n    def print_settings(self) -> None:\n        for x in sorted(gef.config):\n            self.print_setting(x)\n        return\n\n    def set_setting(self, argv: list[str]) -> bool:\n        global gef\n        key, new_value = argv\n\n        if \".\" not in key:\n            err(\"Invalid command format\")\n            return False\n\n        loaded_commands = list( gef.gdb.commands.keys()) + [\"gef\"]\n        plugin_name = key.split(\".\", 1)[0]\n        if plugin_name not in loaded_commands:\n            err(f\"Unknown plugin '{plugin_name}'\")\n            return False\n\n        if key not in gef.config:\n            dbg(f\"'{key}' is not a valid configuration setting\")\n            return False\n\n        _type = gef.config.raw_entry(key).type\n\n        # Attempt to parse specific values for known types\n        if _type is bool:\n            if new_value.upper() in (\"TRUE\", \"T\", \"1\"):\n                _newval = True\n            elif new_value.upper() in (\"FALSE\", \"F\", \"0\"):\n                _newval = False\n            else:\n                raise ValueError(f\"Cannot parse '{new_value}' as bool\")\n        else:\n            _newval = _type(new_value)\n\n        gef.config[key] = _newval\n\n        reset_all_caches()\n        return True\n\n    def complete(self, text: str, word: str) -> list[str]:\n        settings = sorted(gef.config)\n\n        if text == \"\":\n            # no prefix: example: `gef config TAB`\n            return [s for s in settings if word in s]\n\n        if \".\" not in text:\n            # if looking for possible prefix\n            return [s for s in settings if s.startswith(text.strip())]\n\n        # finally, look for possible values for given prefix\n        return [s.split(\".\", 1)[1] for s in settings if s.startswith(text.strip())]\n\n\nclass GefSaveCommand(gdb.Command):\n    \"\"\"GEF save sub-command.\n    Saves the current configuration of GEF to disk (by default in file '~/.gef.rc').\"\"\"\n    _cmdline_ = \"gef save\"\n    _syntax_  = _cmdline_\n\n    def __init__(self) -> None:\n        super().__init__(self._cmdline_, gdb.COMMAND_SUPPORT, gdb.COMPLETE_NONE, False)\n        return\n\n    def invoke(self, args: Any, from_tty: bool) -> None:\n        self.dont_repeat()\n        cfg = configparser.RawConfigParser()\n        old_sect = None\n\n        # save the configuration\n        for key in sorted(gef.config):\n            sect, optname = key.split(\".\", 1)\n            value = gef.config[key]\n\n            if old_sect != sect:\n                cfg.add_section(sect)\n                old_sect = sect\n\n            cfg.set(sect, optname, value)\n\n        # save the aliases\n        cfg.add_section(\"aliases\")\n        for alias in gef.session.aliases:\n            cfg.set(\"aliases\", alias.alias, alias.command)\n\n        with GEF_RC.open(\"w\") as fd:\n            cfg.write(fd)\n\n        ok(f\"Configuration saved to '{GEF_RC}'\")\n        return\n\n\nclass GefRestoreCommand(gdb.Command):\n    \"\"\"GEF restore sub-command.\n    Loads settings from file '~/.gef.rc' and apply them to the configuration of GEF.\"\"\"\n    _cmdline_ = \"gef restore\"\n    _syntax_  = _cmdline_\n\n    def __init__(self) -> None:\n        super().__init__(self._cmdline_, gdb.COMMAND_SUPPORT, gdb.COMPLETE_NONE, False)\n        self.reload(True)\n        return\n\n    def invoke(self, args: str, from_tty: bool) -> None:\n        self.dont_repeat()\n        if GEF_RC.is_file():\n            quiet = (args.lower() == \"quiet\")\n            self.reload(quiet)\n        return\n\n    def reload(self, quiet: bool):\n        cfg = configparser.ConfigParser()\n        cfg.read(GEF_RC)\n\n        for section in cfg.sections():\n            if section == \"aliases\":\n                # load the aliases\n                for key in cfg.options(section):\n                    try:\n                        GefAlias(key, cfg.get(section, key))\n                    except Exception as e:\n                        dbg(f\"GefAlias() raised exception {e}\")\n                continue\n\n            # load the other options\n            for optname in cfg.options(section):\n                key = f\"{section}.{optname}\"\n                try:\n                    setting = gef.config.raw_entry(key)\n                except Exception:\n                    continue\n                new_value = cfg.get(section, optname)\n                if setting.type is bool:\n                    new_value = True if new_value.upper() in (\"TRUE\", \"T\", \"1\") else False\n                setting.value = setting.type(new_value)\n\n        if not quiet:\n            ok(f\"Configuration from '{Color.colorify(str(GEF_RC), 'bold blue')}' restored\")\n        return\n\n\nclass GefMissingCommand(gdb.Command):\n    \"\"\"GEF missing sub-command\n    Display the GEF commands that could not be loaded, along with the reason of why\n    they could not be loaded.\n    \"\"\"\n    _cmdline_ = \"gef missing\"\n    _syntax_  = _cmdline_\n\n    def __init__(self) -> None:\n        super().__init__(self._cmdline_, gdb.COMMAND_SUPPORT, gdb.COMPLETE_NONE, False)\n        return\n\n    def invoke(self, args: Any, from_tty: bool) -> None:\n        self.dont_repeat()\n        missing_commands: dict[str, Exception] = gef.gdb.missing\n        if not missing_commands:\n            ok(\"No missing command\")\n            return\n\n        for cmd, exc in missing_commands.items():\n            warn(f\"Missing `{cmd}`: reason: {str(exc)})\")\n        return\n\n\nclass GefSetCommand(gdb.Command):\n    \"\"\"Override GDB set commands with the context from GEF.\"\"\"\n    _cmdline_ = \"gef set\"\n    _syntax_  = f\"{_cmdline_} [GDB_SET_ARGUMENTS]\"\n\n    def __init__(self) -> None:\n        super().__init__(self._cmdline_, gdb.COMMAND_SUPPORT, gdb.COMPLETE_SYMBOL, False)\n        return\n\n    def invoke(self, args: Any, from_tty: bool) -> None:\n        self.dont_repeat()\n        args = args.split()\n        cmd = [\"set\", args[0],]\n        for p in args[1:]:\n            if p.startswith(\"$_gef\"):\n                c = gdb.parse_and_eval(p)\n                cmd.append(c.string())\n            else:\n                cmd.append(p)\n\n        gdb.execute(\" \".join(cmd))\n        return\n\n\nclass GefRunCommand(gdb.Command):\n    \"\"\"Override GDB run commands with the context from GEF.\n    Simple wrapper for GDB run command to use arguments set from `gef set args`.\"\"\"\n    _cmdline_ = \"gef run\"\n    _syntax_  = f\"{_cmdline_} [GDB_RUN_ARGUMENTS]\"\n\n    def __init__(self) -> None:\n        super().__init__(self._cmdline_, gdb.COMMAND_SUPPORT, gdb.COMPLETE_FILENAME, False)\n        return\n\n    def invoke(self, args: Any, from_tty: bool) -> None:\n        self.dont_repeat()\n        if is_alive():\n            gdb.execute(\"continue\")\n            return\n\n        argv = args.split()\n        gdb.execute(f\"gef set args {' '.join(argv)}\")\n        gdb.execute(\"run\")\n        return\n\n\nclass GefAlias(gdb.Command):\n    \"\"\"Simple aliasing wrapper because GDB doesn't do what it should.\"\"\"\n\n    def __init__(self, alias: str, command: str, completer_class: int = gdb.COMPLETE_NONE, command_class: int = gdb.COMMAND_NONE) -> None:\n        p = command.split()\n        if not p:\n            return\n\n        if any(x for x in gef.session.aliases if x.alias == alias):\n            return\n\n        self.command = command\n        self.alias = alias\n        c = command.split()[0]\n        r = self.lookup_command(c)\n        self.__doc__ = f\"Alias for '{Color.greenify(command)}'\"\n        if r is not None:\n            _instance = r[1]\n            self.__doc__ += f\": {_instance.__doc__}\"\n\n            if hasattr(_instance,  \"complete\"):\n                self.complete = _instance.complete\n\n        super().__init__(alias, command_class, completer_class=completer_class)\n        gef.session.aliases.append(self)\n        return\n\n    def __repr__(self) -> str:\n        return f\"GefAlias(from={self.alias}, to={self.command})\"\n\n    def __str__(self) -> str:\n        return f\"GefAlias(from={self.alias}, to={self.command})\"\n\n    def invoke(self, args: Any, from_tty: bool) -> None:\n        gdb.execute(f\"{self.command} {args}\", from_tty=from_tty)\n        return\n\n    def lookup_command(self, cmd: str) -> tuple[str, GenericCommand] | None:\n        global gef\n        for _name, _instance in gef.gdb.commands.items():\n            if cmd == _name:\n                return _name, _instance\n\n        return None\n\n\n@register\nclass AliasesCommand(GenericCommand):\n    \"\"\"Base command to add, remove, or list aliases.\"\"\"\n\n    _cmdline_ = \"aliases\"\n    _syntax_  = f\"{_cmdline_} (add|rm|ls)\"\n\n    def __init__(self) -> None:\n        super().__init__(prefix=True)\n        return\n\n    def do_invoke(self, _: list[str]) -> None:\n        self.usage()\n        return\n\n\n@register\nclass AliasesAddCommand(AliasesCommand):\n    \"\"\"Command to add aliases.\"\"\"\n\n    _cmdline_ = \"aliases add\"\n    _syntax_  = f\"{_cmdline_} [ALIAS] [COMMAND]\"\n    _example_ = f\"{_cmdline_} scope telescope\"\n\n    def __init__(self) -> None:\n        super().__init__()\n        return\n\n    def do_invoke(self, argv: list[str]) -> None:\n        if len(argv) < 2:\n            self.usage()\n            return\n        GefAlias(argv[0], \" \".join(argv[1:]))\n        return\n\n\n@register\nclass AliasesRmCommand(AliasesCommand):\n    \"\"\"Command to remove aliases.\"\"\"\n\n    _cmdline_ = \"aliases rm\"\n    _syntax_ = f\"{_cmdline_} [ALIAS]\"\n\n    def __init__(self) -> None:\n        super().__init__()\n        return\n\n    def do_invoke(self, argv: list[str]) -> None:\n        global gef\n        if len(argv) != 1:\n            self.usage()\n            return\n        try:\n            alias_to_remove = next(filter(lambda x: x.alias == argv[0], gef.session.aliases))\n            gef.session.aliases.remove(alias_to_remove)\n        except (ValueError, StopIteration):\n            err(f\"{argv[0]} not found in aliases.\")\n            return\n        gef_print(\"You must reload GEF for alias removals to apply.\")\n        return\n\n\n@register\nclass AliasesListCommand(AliasesCommand):\n    \"\"\"Command to list aliases.\"\"\"\n\n    _cmdline_ = \"aliases ls\"\n    _syntax_ = _cmdline_\n\n    def __init__(self) -> None:\n        super().__init__()\n        return\n\n    def do_invoke(self, _: list[str]) -> None:\n        ok(\"Aliases defined:\")\n        for a in gef.session.aliases:\n            gef_print(f\"{a.alias:30s} {RIGHT_ARROW} {a.command}\")\n        return\n\n\nclass GefTmuxSetup(gdb.Command):\n    \"\"\"Setup a comfortable tmux debugging environment.\"\"\"\n\n    def __init__(self) -> None:\n        super().__init__(\"tmux-setup\", gdb.COMMAND_NONE, gdb.COMPLETE_NONE)\n        GefAlias(\"screen-setup\", \"tmux-setup\")\n        return\n\n    def invoke(self, args: Any, from_tty: bool) -> None:\n        self.dont_repeat()\n\n        tmux = os.getenv(\"TMUX\")\n        if tmux:\n            self.tmux_setup()\n            return\n\n        screen = os.getenv(\"TERM\")\n        if screen is not None and screen == \"screen\":\n            self.screen_setup()\n            return\n\n        warn(\"Not in a tmux/screen session\")\n        return\n\n    def tmux_setup(self) -> None:\n        \"\"\"Prepare the tmux environment by vertically splitting the current pane, and\n        forcing the context to be redirected there.\"\"\"\n        tmux = which(\"tmux\")\n        ok(\"tmux session found, splitting window...\")\n\n        pane, pty = subprocess.check_output([tmux, \"splitw\", \"-h\", '-F#{session_name}:#{window_index}.#{pane_index}-#{pane_tty}', \"-P\"]).decode().strip().split(\"-\")\n        atexit.register(lambda : subprocess.run([tmux, \"kill-pane\", \"-t\", pane]))\n        # clear the screen and let it wait for input forever\n        gdb.execute(f\"!'{tmux}' send-keys -t {pane} 'clear ; cat' C-m\")\n        gdb.execute(f\"!'{tmux}' select-pane -L\")\n\n        ok(f\"Setting `context.redirect` to '{pty}'...\")\n        gdb.execute(f\"gef config context.redirect {pty}\")\n        ok(\"Done!\")\n        return\n\n    def screen_setup(self) -> None:\n        \"\"\"Hackish equivalent of the tmux_setup() function for screen.\"\"\"\n        screen = which(\"screen\")\n        sty = os.getenv(\"STY\")\n        ok(\"screen session found, splitting window...\")\n        fd_script, script_path = tempfile.mkstemp()\n        fd_tty, tty_path = tempfile.mkstemp()\n        os.close(fd_tty)\n\n        with os.fdopen(fd_script, \"w\") as f:\n            f.write(\"startup_message off\\n\")\n            f.write(\"split -v\\n\")\n            f.write(\"focus right\\n\")\n            f.write(f\"screen bash -c 'tty > {tty_path}; clear; cat'\\n\")\n            f.write(\"focus left\\n\")\n\n        gdb.execute(f\"!'{screen}' -r '{sty}' -m -d -X source {script_path}\")\n        # artificial delay to make sure `tty_path` is populated\n        time.sleep(0.25)\n        with open(tty_path, \"r\") as f:\n            pty = f.read().strip()\n        ok(f\"Setting `context.redirect` to '{pty}'...\")\n        gdb.execute(f\"gef config context.redirect {pty}\")\n        ok(\"Done!\")\n        os.unlink(script_path)\n        os.unlink(tty_path)\n        return\n\n\nclass GefInstallExtraScriptCommand(gdb.Command):\n    \"\"\"`gef install` command: installs one or more scripts from the `gef-extras` script repo. Note that the command\n    doesn't check for external dependencies the script(s) might require.\"\"\"\n    _cmdline_ = \"gef install\"\n    _syntax_  = f\"{_cmdline_} SCRIPTNAME [SCRIPTNAME [SCRIPTNAME...]]\"\n\n    def __init__(self) -> None:\n        super().__init__(self._cmdline_, gdb.COMMAND_SUPPORT, gdb.COMPLETE_NONE, False)\n        self.branch = gef.config.get(\"gef.extras_default_branch\", GEF_EXTRAS_DEFAULT_BRANCH)\n        return\n\n    def invoke(self, argv: str, from_tty: bool) -> None:\n        self.dont_repeat()\n        if not argv:\n            err(\"No script name provided\")\n            return\n\n        args = argv.split()\n\n        if \"--list\" in args or \"-l\" in args:\n            subprocess.run([\"xdg-open\", f\"https://github.com/hugsy/gef-extras/{self.branch}/\"])\n            return\n\n        self.dirpath = gef.config[\"gef.tempdir\"].expanduser().absolute()\n        if not self.dirpath.is_dir():\n            err(\"'gef.tempdir' is not a valid directory\")\n            return\n\n        for script in args:\n            script = script.lower()\n            if not self.__install_extras_script(script):\n                warn(f\"Failed to install '{script}', skipping...\")\n        return\n\n\n    def __install_extras_script(self, script: str) -> bool:\n        fpath = self.dirpath / f\"{script}.py\"\n        if not fpath.exists():\n            url = f\"https://raw.githubusercontent.com/hugsy/gef-extras/{self.branch}/scripts/{script}.py\"\n            info(f\"Searching for '{script}.py' in `gef-extras@{self.branch}`...\")\n            data = http_get(url)\n            if not data:\n                warn(\"Not found\")\n                return False\n\n            with fpath.open(\"wb\") as fd:\n                fd.write(data)\n                fd.flush()\n\n        old_command_set = set(gef.gdb.commands)\n        gdb.execute(f\"source {fpath}\")\n        new_command_set = set(gef.gdb.commands)\n        new_commands = [f\"`{c[0]}`\" for c in (new_command_set - old_command_set)]\n        ok(f\"Installed file '{fpath}', new command(s) available: {', '.join(new_commands)}\")\n        return True\n\n\n#\n# GEF internal  classes\n#\n\ndef __gef_prompt__(current_prompt: Callable[[Callable], str]) -> str:\n    \"\"\"GEF custom prompt function.\"\"\"\n    if gef.config[\"gef.readline_compat\"] is True: return GEF_PROMPT\n    if gef.config[\"gef.disable_color\"] is True: return GEF_PROMPT\n    prompt = gef.session.remote.mode.prompt_string() if gef.session.remote else \"\"\n    prompt += \"(core) \" if is_target_coredump() else \"\"\n    prompt += GEF_PROMPT_ON if is_alive() else GEF_PROMPT_OFF\n    return prompt\n\n\nclass GefManager(metaclass=abc.ABCMeta):\n    def reset_caches(self) -> None:\n        \"\"\"Reset the LRU-cached attributes\"\"\"\n        for attr in dir(self):\n            try:\n                obj = getattr(self, attr)\n                if not hasattr(obj, \"cache_clear\"):\n                    continue\n                obj.cache_clear()\n            except Exception:\n                # we're resetting the cache here, we don't care if (or which) exception triggers\n                continue\n        return\n\n\nclass GefMemoryManager(GefManager):\n    \"\"\"Class that manages memory access for gef.\"\"\"\n    def __init__(self) -> None:\n        self.reset_caches()\n        return\n\n    def reset_caches(self) -> None:\n        super().reset_caches()\n        self.__maps: list[Section] | None = None\n        return\n\n    def write(self, address: int, buffer: ByteString, length: int | None = None) -> None:\n        \"\"\"Write `buffer` at address `address`.\"\"\"\n        length = length or len(buffer)\n        gdb.selected_inferior().write_memory(address, buffer, length)\n\n    def read(self, addr: int, length: int = 0x10) -> bytes:\n        \"\"\"Return a `length` long byte array with the copy of the process memory at `addr`.\"\"\"\n        return gdb.selected_inferior().read_memory(addr, length).tobytes()\n\n    def read_integer(self, addr: int) -> int:\n        \"\"\"Return an integer read from memory.\"\"\"\n        sz = gef.arch.ptrsize\n        mem = self.read(addr, sz)\n        unpack = u32 if sz == 4 else u64\n        return unpack(mem)\n\n    def read_cstring(self,\n                     address: int,\n                     max_length: int = GEF_MAX_STRING_LENGTH,\n                     encoding: str | None = None) -> str:\n        \"\"\"Return a C-string read from memory.\"\"\"\n        encoding = encoding or \"unicode-escape\"\n        length = min(address | (DEFAULT_PAGE_SIZE-1), max_length+1)\n\n        try:\n            res_bytes = self.read(address, length)\n        except gdb.error:\n            current_address = address\n            res_bytes = b\"\"\n            while len(res_bytes) < length:\n                try:\n                    # Calculate how many bytes there are until next page\n                    next_page = current_address + DEFAULT_PAGE_SIZE\n                    page_mask = ~(DEFAULT_PAGE_SIZE - 1)\n                    size = (next_page & page_mask) - current_address\n\n                    # Read until the end of the current page\n                    res_bytes += self.read(current_address, size)\n\n                    current_address += size\n                except gdb.error:\n                    if not res_bytes:\n                        err(f\"Can't read memory at '{address:#x}'\")\n                        return \"\"\n                    break\n        try:\n            with warnings.catch_warnings():\n                # ignore DeprecationWarnings (see #735)\n                warnings.simplefilter(\"ignore\")\n                res = res_bytes.decode(encoding, \"strict\")\n        except UnicodeDecodeError:\n            # latin-1 as fallback due to its single-byte to glyph mapping\n            res = res_bytes.decode(\"latin-1\", \"replace\")\n\n        res = res.split(\"\\x00\", 1)[0]\n        ustr = res.replace(\"\\n\", \"\\\\n\").replace(\"\\r\", \"\\\\r\").replace(\"\\t\", \"\\\\t\")\n        if max_length and len(res) > max_length:\n            return f\"{ustr[:max_length]}[...]\"\n        return ustr\n\n    def read_ascii_string(self, address: int) -> str | None:\n        \"\"\"Read an ASCII string from memory\"\"\"\n        cstr = self.read_cstring(address)\n        if isinstance(cstr, str) and cstr and all(x in string.printable for x in cstr):\n            return cstr\n        return None\n\n    @property\n    def maps(self) -> list[Section]:\n        if not self.__maps:\n            maps = self.__parse_maps()\n            if not maps:\n                raise RuntimeError(\"Failed to determine memory layout\")\n            self.__maps = maps\n        return self.__maps\n\n    def __parse_maps(self) -> list[Section] | None:\n        \"\"\"Return the mapped memory sections. If the current arch has its maps\n        method defined, then defer to that to generated maps, otherwise, try to\n        figure it out from procfs, then info sections, then monitor info\n        mem.\"\"\"\n        if gef.arch.maps is not None:\n            return list(gef.arch.maps())\n\n        # Coredumps are the only case where `maintenance info sections` collected more\n        # info than `info proc sections`.so use this unconditionally. See #1154\n\n        if is_target_coredump():\n            return list(self.parse_gdb_maintenance_info_sections())\n\n        try:\n            return list(self.parse_gdb_info_proc_maps())\n        except Exception:\n            pass\n\n        try:\n            return list(self.parse_procfs_maps())\n        except Exception:\n            pass\n\n        try:\n            return list(self.parse_monitor_info_mem())\n        except Exception:\n            pass\n\n        raise RuntimeError(\"Failed to get memory layout\")\n\n    @staticmethod\n    def parse_procfs_maps() -> Generator[Section, None, None]:\n        \"\"\"Get the memory mapping from procfs.\"\"\"\n        procfs_mapfile = gef.session.maps\n        if not procfs_mapfile:\n            is_remote = gef.session.remote is not None\n            raise FileNotFoundError(f\"Missing {'remote ' if is_remote else ''}procfs map file\")\n\n        with procfs_mapfile.open(\"r\") as fd:\n            for line in fd:\n                line = line.strip()\n                addr, perm, off, _, rest = line.split(\" \", 4)\n                rest = rest.split(\" \", 1)\n                if len(rest) == 1:\n                    inode = rest[0]\n                    pathname = \"\"\n                else:\n                    inode = rest[0]\n                    pathname = rest[1].lstrip()\n\n                addr_start, addr_end = parse_string_range(addr)\n                off = int(off, 16)\n                perm = Permission.from_process_maps(perm)\n                inode = int(inode)\n                yield Section(page_start=addr_start,\n                              page_end=addr_end,\n                              offset=off,\n                              permission=perm,\n                              inode=inode,\n                              path=pathname)\n        return\n\n    @staticmethod\n    def parse_gdb_info_proc_maps() -> Generator[Section, None, None]:\n        \"\"\"Get the memory mapping from GDB's command `info proc mappings`.\"\"\"\n        if GDB_VERSION < (11, 0):\n            raise AttributeError(\"Disregarding old format\")\n\n        output = (gdb.execute(\"info proc mappings\", to_string=True) or \"\")\n        if not output:\n            raise AttributeError\n\n        start_idx = output.find(\"Start Addr\")\n        if start_idx == -1:\n            raise AttributeError\n\n        output = output[start_idx:]\n        lines = output.splitlines()\n        if len(lines) < 2:\n            raise AttributeError\n\n        # The function assumes the following output format (as of GDB 11+) for `info proc mappings`:\n        # - live process (incl. remote)\n        # ```\n        #           Start Addr           End Addr       Size     Offset  Perms  objfile\n        #       0x555555554000     0x555555558000     0x4000        0x0  r--p   /usr/bin/ls\n        #       0x555555558000     0x55555556c000    0x14000     0x4000  r-xp   /usr/bin/ls\n        # [...]\n        # ```\n        # or\n        # - coredump & rr\n        # ```\n        #          Start Addr           End Addr       Size     Offset objfile\n        #      0x555555554000     0x555555558000     0x4000        0x0 /usr/bin/ls\n        #      0x555555558000     0x55555556c000    0x14000     0x4000 /usr/bin/ls\n        # ```\n        # In the latter case the 'Perms' header is missing, so mock the Permission to `rwx` so\n        # `dereference` will still work.\n\n        mock_permission = all(map(lambda x: x.strip() != \"Perms\", lines[0].split()))\n        for line in lines[1:]:\n            if not line:\n                break\n\n            parts = [x.strip() for x in line.split()]\n            addr_start, addr_end, _, offset = [int(x, 16) for x in parts[0:4]]\n            if mock_permission:\n                perm = Permission(7)\n                path = \" \".join(parts[4:]) if len(parts) >= 4 else \"\"\n            else:\n                perm = Permission.from_process_maps(parts[4])\n                path = \" \".join(parts[5:]) if len(parts) >= 5 else \"\"\n            yield Section(\n                page_start=addr_start,\n                page_end=addr_end,\n                offset=offset,\n                permission=perm,\n                path=path,\n            )\n        return\n\n    @staticmethod\n    def parse_monitor_info_mem() -> Generator[Section, None, None]:\n        \"\"\"Get the memory mapping from GDB's command `monitor info mem`\n        This can raise an exception, which the memory manager takes to mean\n        that this method does not work to get a map.\n        \"\"\"\n        stream = StringIO(gdb.execute(\"monitor info mem\", to_string=True))\n\n        for line in stream:\n            try:\n                ranges, off, perms = line.split()\n                off = int(off, 16)\n                start, end = [int(s, 16) for s in ranges.split(\"-\")]\n            except ValueError:\n                continue\n\n            perm = Permission.from_monitor_info_mem(perms)\n            yield Section(page_start=start,\n                          page_end=end,\n                          offset=off,\n                          permission=perm)\n\n    @staticmethod\n    def parse_gdb_maintenance_info_sections() -> Generator[Section, None, None]:\n        \"\"\"Get the memory mapping from GDB's command `maintenance info sections` (limited info). In some cases (i.e. coredumps),\n        the memory info collected by `info proc sections` is insufficient.\"\"\"\n        stream = StringIO(gdb.execute(\"maintenance info sections\", to_string=True))\n\n        for line in stream:\n            if not line:\n                break\n\n            try:\n                parts = line.split()\n                addr_start, addr_end = [int(x, 16) for x in parts[1].split(\"->\")]\n                off = int(parts[3][:-1], 16)\n                path = parts[4]\n                perm = Permission.NONE\n                if \"DATA\" in parts[5:]:\n                    perm |= Permission.READ | Permission.WRITE\n                if \"CODE\" in parts[5:]:\n                    perm |= Permission.READ | Permission.EXECUTE\n                yield Section(\n                    page_start=addr_start,\n                    page_end=addr_end,\n                    offset=off,\n                    permission=perm,\n                    path=path,\n                )\n\n            except IndexError:\n                continue\n            except ValueError:\n                continue\n\n    @staticmethod\n    def parse_info_mem():\n        \"\"\"Get the memory mapping from GDB's command `info mem`. This can be\n        provided by certain gdbserver implementations.\"\"\"\n        for line in StringIO(gdb.execute(\"info mem\", to_string=True)):\n            # Using memory regions provided by the target.\n            # Num Enb Low Addr   High Addr  Attrs\n            # 0   y   0x10000000 0x10200000 flash blocksize 0x1000 nocache\n            # 1   y   0x20000000 0x20042000 rw nocache\n            _, en, start, end, *attrs = line.split()\n            if en != \"y\":\n                continue\n\n            if \"flash\" in attrs:\n                perm = Permission.from_info_mem(\"r\")\n            else:\n                perm = Permission.from_info_mem(\"rw\")\n            yield Section(page_start=int(start, 0),\n                          page_end=int(end, 0),\n                          permission=perm)\n\n    def append(self, section: Section):\n        if not self.maps:\n            raise AttributeError(\"No mapping defined\")\n        if not isinstance(section, Section):\n            raise TypeError(\"section has an invalid type\")\n\n        assert self.__maps\n        for s in self.__maps:\n            if section.overlaps(s):\n                raise RuntimeError(f\"{section} overlaps {s}\")\n        self.__maps.append(section)\n        return self\n\n    def __iadd__(self, section: Section):\n        return self.append(section)\n\n\nclass GefHeapManager(GefManager):\n    \"\"\"Class managing session heap.\"\"\"\n    def __init__(self) -> None:\n        self.reset_caches()\n        return\n\n    def reset_caches(self) -> None:\n        self.__libc_main_arena: GlibcArena | None = None\n        self.__libc_selected_arena: GlibcArena | None = None\n        self.__heap_base = None\n        return\n\n    @property\n    def main_arena(self) -> GlibcArena | None:\n        if not self.__libc_main_arena:\n            try:\n                __main_arena_addr = GefHeapManager.find_main_arena_addr()\n                self.__libc_main_arena = GlibcArena(f\"*{__main_arena_addr:#x}\")\n                # the initialization of `main_arena` also defined `selected_arena`, so\n                # by default, `main_arena` == `selected_arena`\n                self.selected_arena = self.__libc_main_arena\n            except Exception:\n                # the search for arena can fail when the session is not started\n                pass\n        return self.__libc_main_arena\n\n    @main_arena.setter\n    def main_arena(self, value: GlibcArena) -> None:\n        self.__libc_main_arena = value\n        return\n\n    @staticmethod\n    @lru_cache()\n    def find_main_arena_addr() -> int:\n        assert gef.libc.version\n        \"\"\"A helper function to find the glibc `main_arena` address, either from\n        symbol, from its offset from `__malloc_hook` or by brute force.\"\"\"\n        # Before anything else, use libc offset from config if available\n        if gef.config[\"gef.main_arena_offset\"]:\n            try:\n                libc_base = get_section_base_address(\"libc\")\n                offset: int = gef.config[\"gef.main_arena_offset\"]\n                if libc_base:\n                    dbg(f\"Using main_arena_offset={offset:#x} from config\")\n                    addr = libc_base + offset\n\n                    # Verify the found address before returning\n                    if GlibcArena.verify(addr):\n                        return addr\n            except gdb.error:\n                pass\n\n        # First, try to find `main_arena` symbol directly\n        try:\n            return parse_address(f\"&{LIBC_HEAP_MAIN_ARENA_DEFAULT_NAME}\")\n        except gdb.error:\n            pass\n\n        # Second, try to find it by offset from `__malloc_hook`\n        if gef.libc.version < (2, 34):\n            try:\n                malloc_hook_addr = parse_address(\"(void *)&__malloc_hook\")\n\n                struct_size = ctypes.sizeof(GlibcArena.malloc_state_t())\n\n                if is_x86():\n                    addr = align_address_to_size(malloc_hook_addr + gef.arch.ptrsize, 0x20)\n                elif is_arch(Elf.Abi.AARCH64):\n                    addr = malloc_hook_addr - gef.arch.ptrsize*2 - struct_size\n                elif is_arch(Elf.Abi.ARM):\n                    addr = malloc_hook_addr - gef.arch.ptrsize - struct_size\n                else:\n                    addr = None\n\n                # Verify the found address before returning\n                if addr and GlibcArena.verify(addr):\n                    return addr\n\n            except gdb.error:\n                pass\n\n        # Last resort, try to find it via brute force if enabled in settings\n        if gef.config[\"gef.bruteforce_main_arena\"]:\n            alignment = 0x8\n            try:\n                dbg(\"Trying to bruteforce main_arena address\")\n                # setup search_range for `main_arena` to `.data` of glibc\n                def search_filter(zone: Zone) -> bool:\n                    return \"libc\" in pathlib.Path(zone.filename).name and zone.name == \".data\"\n\n                for dotdata in list(filter(search_filter, get_info_files())):\n                    search_range = range(dotdata.zone_start, dotdata.zone_end, alignment)\n                    # find first possible candidate\n                    for addr in search_range:\n                        if GlibcArena.verify(addr):\n                            dbg(f\"Found candidate at {addr:#x}\")\n                            return addr\n                    dbg(\"Bruteforce not successful\")\n            except Exception:\n                pass\n\n        # Nothing helped\n        err_msg = f\"Cannot find main_arena for {gef.arch.arch}. You might want to set a manually found libc offset \"\n        if not gef.config[\"gef.bruteforce_main_arena\"]:\n            err_msg += \"or allow bruteforcing \"\n        err_msg += \"through the GEF config.\"\n        raise OSError(err_msg)\n\n    @property\n    def selected_arena(self) -> GlibcArena | None:\n        if not self.__libc_selected_arena:\n            # `selected_arena` must default to `main_arena`\n            self.__libc_selected_arena = self.main_arena\n        return self.__libc_selected_arena\n\n    @selected_arena.setter\n    def selected_arena(self, value: GlibcArena) -> None:\n        self.__libc_selected_arena = value\n        return\n\n    @property\n    def arenas(self) -> list | Iterator[GlibcArena]:\n        if not self.main_arena:\n            return []\n        return iter(self.main_arena)\n\n    @property\n    def base_address(self) -> int | None:\n        if not self.__heap_base:\n            base = 0\n            try:\n                base = parse_address(\"mp_->sbrk_base\")\n                base = self.malloc_align_address(base)\n            except gdb.error:\n                # missing symbol, try again\n                base = 0\n            if not base:\n                base = get_section_base_address(\"[heap]\")\n            self.__heap_base = base\n        return self.__heap_base\n\n    @property\n    def chunks(self) -> list | Iterator:\n        if not self.base_address:\n            return []\n        return iter(GlibcChunk(self.base_address, from_base=True))\n\n    @property\n    def min_chunk_size(self) -> int:\n        return 4 * gef.arch.ptrsize\n\n    @property\n    def malloc_alignment(self) -> int:\n        assert gef.libc.version\n        __default_malloc_alignment = 0x10\n        if gef.libc.version >= (2, 26) and is_x86_32():\n            # Special case introduced in Glibc 2.26:\n            # https://elixir.bootlin.com/glibc/glibc-2.26/source/sysdeps/i386/malloc-alignment.h#L22\n            return __default_malloc_alignment\n        # Generic case:\n        # https://elixir.bootlin.com/glibc/glibc-2.26/source/sysdeps/generic/malloc-alignment.h#L22\n        return 2 * gef.arch.ptrsize\n\n    def csize2tidx(self, size: int) -> int:\n        return abs((size - self.min_chunk_size + self.malloc_alignment - 1)) // self.malloc_alignment\n\n    def tidx2size(self, idx: int) -> int:\n        return idx * self.malloc_alignment + self.min_chunk_size\n\n    def malloc_align_address(self, address: int) -> int:\n        \"\"\"Align addresses according to glibc's MALLOC_ALIGNMENT. See also Issue #689 on Github\"\"\"\n        def ceil(n: float) -> int:\n            return int(-1 * n // 1 * -1)\n        malloc_alignment = self.malloc_alignment\n        return malloc_alignment * ceil((address / malloc_alignment))\n\n\nclass GefSetting:\n    \"\"\"Basic class for storing gef settings as objects\"\"\"\n\n    def __init__(self, value: Any, cls: type | None = None, description: str | None = None, hooks: dict[str, list[Callable]] | None = None)  -> None:\n        self.value = value\n        self.type = cls or type(value)\n        self.description = description or \"\"\n        self.hooks: dict[str, list[Callable]] = collections.defaultdict(list)\n        if not hooks:\n            hooks = {\"on_read\": [], \"on_write\": [], \"on_changed\": []}\n\n        for access, funcs in hooks.items():\n            self.add_hook(access, funcs)\n        return\n\n    def __str__(self) -> str:\n        return f\"Setting(type={self.type.__name__}, value='{self.value}', desc='{self.description[:10]}...', \" \\\n                f\"read_hooks={len(self.hooks['on_read'])}, write_hooks={len(self.hooks['on_write'])}, \"\\\n                f\"changed_hooks={len(self.hooks['on_changed'])})\"\n\n    def add_hook(self, access: str, funcs: list[Callable]):\n        if access not in (\"on_read\", \"on_write\", \"on_changed\"):\n            raise ValueError(\"invalid access type\")\n        for func in funcs:\n            if not callable(func):\n                raise ValueError(\"hook is not callable\")\n            self.hooks[access].append(func)\n        return self\n\n    @staticmethod\n    def no_spaces(value: pathlib.Path):\n        if \" \" in str(value):\n            raise ValidationError(\"setting cannot contain spaces\")\n\n    @staticmethod\n    def must_exist(value: pathlib.Path):\n        if not value or not pathlib.Path(value).expanduser().absolute().exists():\n            raise ValidationError(\"specified path must exist\")\n\n    @staticmethod\n    def create_folder_tree(value: pathlib.Path):\n        value.mkdir(0o755, exist_ok=True, parents=True)\n\n\nclass GefSettingsManager(dict):\n    \"\"\"\n    GefSettings acts as a dict where the global settings are stored and can be read, written or deleted as any other dict.\n    For instance, to read a specific command setting: `gef.config[mycommand.mysetting]`\n    \"\"\"\n    def __getitem__(self, name: str) -> Any:\n        setting : GefSetting = super().__getitem__(name)\n        self.__invoke_read_hooks(setting)\n        return setting.value\n\n    def __setitem__(self, name: str, value: Any) -> None:\n        # check if the key exists\n        if super().__contains__(name):\n            # if so, update its value directly\n            setting = super().__getitem__(name)\n            if not isinstance(setting, GefSetting): raise TypeError\n            new_value = setting.type(value)\n            dbg(f\"in __invoke_changed_hooks(\\\"{name}\\\"), setting.value={setting.value} -> new_value={new_value}, changing={bool(setting.value != new_value)}\")\n            self.__invoke_changed_hooks(setting, new_value)\n            self.__invoke_write_hooks(setting, new_value)\n            setting.value = new_value\n            return\n\n        # if not, assert `value` is a GefSetting, then insert it\n        if not isinstance(value, GefSetting): raise TypeError(\"Invalid argument\")\n        if not value.type: raise TypeError(\"Invalid type\")\n        if not value.description: raise AttributeError(\"Invalid description\")\n        setting = value\n        value = setting.value\n        self.__invoke_write_hooks(setting, value)\n        super().__setitem__(name, setting)\n        return\n\n    def __delitem__(self, name: str) -> None:\n        return super().__delitem__(name)\n\n    def raw_entry(self, name: str) -> GefSetting:\n        return super().__getitem__(name)\n\n    def __invoke_read_hooks(self, setting: GefSetting) -> None:\n        for callback in setting.hooks[\"on_read\"]:\n            callback()\n        return\n\n    def __invoke_changed_hooks(self, setting: GefSetting, new_value: Any) -> None:\n        old_value = setting.value\n        if old_value == new_value:\n            return\n        for callback in setting.hooks[\"on_changed\"]:\n            callback(old_value, new_value)\n\n    def __invoke_write_hooks(self, setting: GefSetting, new_value: Any) -> None:\n        for callback in setting.hooks[\"on_write\"]:\n            callback(new_value)\n\n\nclass GefSessionManager(GefManager):\n    \"\"\"Class managing the runtime properties of GEF. \"\"\"\n    def __init__(self) -> None:\n        self.reset_caches()\n        self.remote: \"GefRemoteSessionManager | None\" = None\n        self.remote_initializing: bool = False\n        self.qemu_mode: bool = False\n        self.coredump_mode: bool | None = None\n        self.convenience_vars_index: int = 0\n        self.heap_allocated_chunks: list[tuple[int, int]] = []\n        self.heap_freed_chunks: list[tuple[int, int]] = []\n        self.heap_uaf_watchpoints: list[UafWatchpoint] = []\n        self.pie_breakpoints: dict[int, PieVirtualBreakpoint] = {}\n        self.pie_counter: int = 1\n        self.aliases: list[GefAlias] = []\n        self.modules: list[FileFormat] = []\n        self.constants = {} # a dict for runtime constants (like 3rd party file paths)\n        for constant in (\"python3\", \"readelf\", \"nm\", \"file\", \"ps\"):\n            self.constants[constant] = which(constant)\n        return\n\n    def reset_caches(self) -> None:\n        super().reset_caches()\n        self._auxiliary_vector = None\n        self._pagesize = None\n        self._os = None\n        self._pid = None\n        self._file = None\n        self._maps: pathlib.Path | None = None\n        self._root: pathlib.Path | None = None\n        return\n\n    def __str__(self) -> str:\n        _type = \"Local\" if self.remote is None else f\"Remote/{self.remote.mode}\"\n        return f\"Session(type={_type}, pid={self.pid or 'Not running'}, os='{self.os}')\"\n\n    def __repr__(self) -> str:\n        return str(self)\n\n    @property\n    def auxiliary_vector(self) -> dict[str, int] | None:\n        if not is_alive():\n            return None\n        if is_qemu_system():\n            return None\n        if not self._auxiliary_vector:\n            auxiliary_vector = {}\n            auxv_info = gdb.execute(\"info auxv\", to_string=True) or \"\"\n            if not auxv_info or \"failed\" in auxv_info:\n                err(\"Failed to query auxiliary variables\")\n                return None\n            for line in auxv_info.splitlines():\n                line = line.split('\"')[0].strip()  # remove the ending string (if any)\n                line = line.split()  # split the string by whitespace(s)\n                if len(line) < 4:\n                    continue\n                __av_type = line[1]\n                __av_value = line[-1]\n                auxiliary_vector[__av_type] = int(__av_value, base=0)\n            self._auxiliary_vector = auxiliary_vector\n        return self._auxiliary_vector\n\n    @property\n    def os(self) -> str:\n        \"\"\"Return the current OS.\"\"\"\n        if not self._os:\n            self._os = platform.system().lower()\n        return self._os\n\n    @property\n    def pid(self) -> int:\n        \"\"\"Return the PID of the target process.\"\"\"\n        if not self._pid:\n            pid = gdb.selected_inferior().pid if not self.qemu_mode else gdb.selected_thread().ptid[1]\n            if not pid:\n                raise RuntimeError(\"cannot retrieve PID for target process\")\n            self._pid = pid\n        return self._pid\n\n    @property\n    def file(self) -> pathlib.Path | None:\n        \"\"\"Return a Path object of the target process.\"\"\"\n        if self.remote is not None:\n            return self.remote.file\n        progspace = gdb.current_progspace()\n        assert progspace\n        fpath: str = progspace.filename\n        if fpath and not self._file:\n            self._file = pathlib.Path(fpath).expanduser()\n        return self._file\n\n    @property\n    def cwd(self) -> pathlib.Path | None:\n        if self.remote is not None:\n            return self.remote.root\n        return self.file.parent if self.file else None\n\n    @property\n    def pagesize(self) -> int:\n        \"\"\"Get the system page size\"\"\"\n        auxval = self.auxiliary_vector\n        if not auxval:\n            return DEFAULT_PAGE_SIZE\n        self._pagesize = auxval[\"AT_PAGESZ\"]\n        return self._pagesize\n\n    @property\n    def canary(self) -> tuple[int, int] | None:\n        \"\"\"Return a tuple of the canary address and value, read from the canonical\n        location if supported by the architecture. Otherwise, read from the auxiliary\n        vector.\"\"\"\n        try:\n            canary_location = gef.arch.canary_address()\n            canary = gef.memory.read_integer(canary_location)\n        except (NotImplementedError, gdb.error):\n            # Fall back to `AT_RANDOM`, which is the original source\n            # of the canary value but not the canonical location\n            return self.original_canary\n        return canary, canary_location\n\n    @property\n    def original_canary(self) -> tuple[int, int] | None:\n        \"\"\"Return a tuple of the initial canary address and value, read from the\n        auxiliary vector.\"\"\"\n        auxval = self.auxiliary_vector\n        if not auxval:\n            return None\n        canary_location = auxval[\"AT_RANDOM\"]\n        canary = gef.memory.read_integer(canary_location)\n        canary &= ~0xFF\n        return canary, canary_location\n\n    @property\n    def maps(self) -> pathlib.Path | None:\n        \"\"\"Returns the Path to the procfs entry for the memory mapping.\"\"\"\n        if not is_alive():\n            return None\n        if not self._maps:\n            if self.remote is not None:\n                self._maps = self.remote.maps\n            else:\n                self._maps = pathlib.Path(f\"/proc/{self.pid}/maps\")\n        return self._maps\n\n    @property\n    def root(self) -> pathlib.Path | None:\n        \"\"\"Returns the path to the process's root directory.\"\"\"\n        if not is_alive():\n            return None\n        if not self._root:\n            self._root = pathlib.Path(f\"/proc/{self.pid}/root\")\n        return self._root\n\n\nclass GefRemoteSessionManager(GefSessionManager):\n    \"\"\"Class for managing remote sessions with GEF. It will create a temporary environment\n    designed to clone the remote one.\"\"\"\n\n    class RemoteMode(enum.IntEnum):\n        GDBSERVER = 0\n        QEMU = 1\n        RR = 2\n\n        def __str__(self):\n            return self.name\n\n        def __repr__(self):\n            return f\"RemoteMode = {str(self)} ({int(self)})\"\n\n        def prompt_string(self) -> str:\n            match self:\n                case GefRemoteSessionManager.RemoteMode.QEMU:\n                    return Color.boldify(\"(qemu) \")\n                case GefRemoteSessionManager.RemoteMode.RR:\n                    return Color.boldify(\"(rr) \")\n                case GefRemoteSessionManager.RemoteMode.GDBSERVER:\n                    return Color.boldify(\"(remote) \")\n            raise AttributeError(\"Unknown value\")\n\n    def __init__(self, host: str, port: int, pid: int =-1, qemu: pathlib.Path | None = None) -> None:\n        super().__init__()\n        self.__host = host\n        self.__port = port\n        self.__local_root_fd = tempfile.TemporaryDirectory()\n        self.__local_root_path = pathlib.Path(self.__local_root_fd.name)\n        self.__qemu = qemu\n        if pid > 0:\n            self._pid = pid\n\n        if self.__qemu is not None:\n            self._mode = GefRemoteSessionManager.RemoteMode.QEMU\n        elif os.environ.get(\"GDB_UNDER_RR\", None) == \"1\":\n            self._mode =  GefRemoteSessionManager.RemoteMode.RR\n        else:\n            self._mode =  GefRemoteSessionManager.RemoteMode.GDBSERVER\n\n    def close(self) -> None:\n        self.__local_root_fd.cleanup()\n        try:\n            gef_on_new_unhook(self.remote_objfile_event_handler)\n            gef_on_new_hook(new_objfile_handler)\n        except Exception as e:\n            warn(f\"Exception while restoring local context: {str(e)}\")\n            raise\n\n    def __str__(self) -> str:\n        return f\"RemoteSession(target='{self.target}', local='{self.root}', pid={self.pid}, mode={self.mode})\"\n\n    def __repr__(self) -> str:\n        return str(self)\n\n    @property\n    def target(self) -> str:\n        return f\"{self.__host}:{self.__port}\"\n\n    @property\n    def root(self) -> pathlib.Path:\n        return self.__local_root_path.absolute()\n\n    @property\n    def file(self) -> pathlib.Path:\n        \"\"\"Path to the file being debugged as seen by the remote endpoint.\"\"\"\n        if not self._file:\n            progspace = gdb.current_progspace()\n            if not progspace:\n                raise RuntimeError(\"No session started\")\n            filename = progspace.filename\n            if not filename:\n                raise RuntimeError(\"No session started\")\n            start_idx = len(\"target:\") if filename.startswith(\"target:\") else 0\n            self._file = pathlib.Path(progspace.filename[start_idx:])\n        return self._file\n\n    @property\n    def lfile(self) -> pathlib.Path:\n        \"\"\"Local path to the file being debugged.\"\"\"\n        return self.root / str(self.file).lstrip(\"/\")\n\n    @property\n    def maps(self) -> pathlib.Path:\n        if not self._maps:\n            self._maps = self.root / f\"proc/{self.pid}/maps\"\n        return self._maps\n\n    @property\n    def mode(self) -> RemoteMode:\n        return self._mode\n\n    def sync(self, src: str, dst: str | None = None) -> bool:\n        \"\"\"Copy the `src` into the temporary chroot. If `dst` is provided, that path will be\n        used instead of `src`.\"\"\"\n        if not dst:\n            dst = src\n        tgt = self.root / dst.lstrip(\"/\")\n        if tgt.exists():\n            return True\n        tgt.parent.mkdir(parents=True, exist_ok=True)\n        dbg(f\"[remote] downloading '{src}' -> '{tgt}'\")\n        gdb.execute(f\"remote get '{src}' '{tgt.absolute()}'\")\n        return tgt.exists()\n\n    def connect(self, pid: int) -> bool:\n        \"\"\"Connect to remote target. If in extended mode, also attach to the given PID.\"\"\"\n        # before anything, register our new hook to download files from the remote target\n        dbg(\"[remote] Installing new objfile handlers\")\n        try:\n            gef_on_new_unhook(new_objfile_handler)\n        except SystemError:\n            # the default objfile handler might already have been removed, ignore failure\n            pass\n\n        gef_on_new_hook(self.remote_objfile_event_handler)\n\n        # then attempt to connect\n        is_extended_mode = (pid > -1)\n        dbg(f\"[remote] Enabling extended remote: {bool(is_extended_mode)}\")\n        try:\n            with DisableContextOutputContext():\n                cmd = f\"target {'extended-' if is_extended_mode else ''}remote {self.target}\"\n                dbg(f\"[remote] Executing '{cmd}'\")\n                gdb.execute(cmd)\n                if is_extended_mode:\n                    gdb.execute(f\"attach {pid:d}\")\n            return True\n        except Exception as e:\n            err(f\"Failed to connect to {self.target}: {e}\")\n\n        # a failure will trigger the cleanup, deleting our hook anyway\n        return False\n\n    def setup(self) -> bool:\n        # setup remote adequately depending on remote or qemu mode\n        match self.mode:\n            case GefRemoteSessionManager.RemoteMode.QEMU:\n                dbg(f\"Setting up as qemu session, target={self.__qemu}\")\n                self.__setup_qemu()\n            case GefRemoteSessionManager.RemoteMode.RR:\n                dbg(\"Setting up as rr session\")\n                self.__setup_rr()\n            case GefRemoteSessionManager.RemoteMode.GDBSERVER:\n                dbg(\"Setting up as remote session\")\n                self.__setup_remote()\n            case _:\n                raise ValueError\n\n        # refresh gef to consider the binary\n        reset_all_caches()\n        gef.binary = Elf(self.lfile)\n        reset_architecture()\n        return True\n\n    def __setup_qemu(self) -> bool:\n        # setup emulated file in the chroot\n        assert self.__qemu\n        target = self.root / str(self.__qemu.parent).lstrip(\"/\")\n        target.mkdir(parents=True, exist_ok=False)\n        shutil.copy2(self.__qemu, target)\n        self._file = self.__qemu\n        assert self.lfile.exists()\n\n        # create a procfs\n        procfs = self.root / f\"proc/{self.pid}/\"\n        procfs.mkdir(parents=True, exist_ok=True)\n\n        ## /proc/pid/cmdline\n        cmdline = procfs / \"cmdline\"\n        if not cmdline.exists():\n            with cmdline.open(\"w\") as fd:\n                fd.write(\"\")\n\n        ## /proc/pid/environ\n        environ = procfs / \"environ\"\n        if not environ.exists():\n            with environ.open(\"wb\") as fd:\n                fd.write(b\"PATH=/bin\\x00HOME=/tmp\\x00\")\n\n        ## /proc/pid/maps\n        maps = procfs / \"maps\"\n        if not maps.exists():\n            with maps.open(\"w\") as fd:\n                fname = self.file.absolute()\n                mem_range = \"00000000-ffffffff\" if is_32bit() else \"0000000000000000-ffffffffffffffff\"\n                fd.write(f\"{mem_range} rwxp 00000000 00:00 0                    {fname}\\n\")\n        return True\n\n    def __setup_remote(self) -> bool:\n        # get the file\n        fpath = f\"/proc/{self.pid}/exe\"\n        if not self.sync(fpath, str(self.file)):\n            err(f\"'{fpath}' could not be fetched on the remote system.\")\n            return False\n\n        # pseudo procfs\n        for _file in (\"maps\", \"environ\", \"cmdline\"):\n            fpath = f\"/proc/{self.pid}/{_file}\"\n            if not self.sync(fpath):\n                err(f\"'{fpath}' could not be fetched on the remote system.\")\n                return False\n\n        return True\n\n    def __setup_rr(self) -> bool:\n        #\n        # Simply override the local root path, the binary must exist\n        # on the host.\n        #\n        self.__local_root_path = pathlib.Path(\"/\")\n        return True\n\n    def remote_objfile_event_handler(self, evt: \"gdb.NewObjFileEvent\") -> None:\n        dbg(f\"[remote] in remote_objfile_handler({evt.new_objfile.filename if evt else 'None'}))\")\n        if not evt or not evt.new_objfile.filename:\n            return\n        if not evt.new_objfile.filename.startswith(\"target:\") and not evt.new_objfile.filename.startswith(\"/\"):\n            warn(f\"[remote] skipping '{evt.new_objfile.filename}'\")\n            return\n        if evt.new_objfile.filename.startswith(\"target:\"):\n            src: str = evt.new_objfile.filename[len(\"target:\"):]\n            if not self.sync(src):\n                raise FileNotFoundError(f\"Failed to sync '{src}'\")\n        return\n\n\nclass GefUiManager(GefManager):\n    \"\"\"Class managing UI settings.\"\"\"\n    def __init__(self) -> None:\n        self.redirect_fd : TextIOWrapper | None = None\n        self.context_hidden = False\n        self.stream_buffer : StringIO | None = None\n        self.highlight_table: dict[str, str] = {}\n        self.watches: dict[int, tuple[int, str]] = {}\n        self.context_messages: list[tuple[str, str]] = []\n        return\n\n\nclass GefLibcManager(GefManager):\n    \"\"\"Class managing everything libc-related (except heap).\"\"\"\n    PATTERN_LIBC_VERSION_MEMORY = re.compile(rb\"glibc (\\d+)\\.(\\d+)\")\n    PATTERN_LIBC_VERSION_FILENAME = re.compile(r\"libc6?[-_](\\d+)\\.(\\d+)\\.so\")\n\n    def __init__(self) -> None:\n        self._version : tuple[int, int] | None = None\n        self._patch: int | None = None\n        self._release: str | None = None\n        return\n\n    def __str__(self) -> str:\n        return f\"Libc(version='{self.version}')\"\n\n    @property\n    def version(self) -> tuple[int, int] | None:\n        if not is_alive():\n            return None\n\n        if not self._version:\n            self._version = GefLibcManager.find_libc_version()\n\n        # Whenever auto-detection fails, try use the user-provided version.\n        if self._version == (0, 0):\n            if gef.config[\"gef.libc_version\"]:\n                ver = [int(v) for v in gef.config[\"gef.libc_version\"].split(\".\", 1)]\n                assert len(ver) >= 2\n                self._version = ver[0], ver[1]\n\n        return self._version\n\n    @staticmethod\n    @lru_cache()\n    def find_libc_version() -> tuple[int, int]:\n        \"\"\"Attempt to determine the libc version. This operation can be long.\"\"\"\n        libc_sections = (m for m in gef.memory.maps if \"libc\" in m.path and m.permission & Permission.READ)\n        for section in libc_sections:\n            # Try to determine from the filepath\n            match = re.search(GefLibcManager.PATTERN_LIBC_VERSION_FILENAME, section.path)\n            if match:\n                return int(match.group(1)), int(match.group(2))\n\n            # Try to determine from memory\n            try:\n                mem = gef.memory.read(section.page_start, section.size)\n                match = re.search(GefLibcManager.PATTERN_LIBC_VERSION_MEMORY, mem)\n                if match:\n                    return int(match.group(1)), int(match.group(2))\n            except gdb.MemoryError:\n                continue\n\n        return 0, 0\n\n\nclass Gef:\n    \"\"\"The GEF root class, which serves as a entrypoint for all the debugging session attributes (architecture,\n    memory, settings, etc.).\"\"\"\n    binary: FileFormat | None\n    arch: Architecture\n    config : GefSettingsManager\n    ui: GefUiManager\n    libc: GefLibcManager\n    memory : GefMemoryManager\n    heap : GefHeapManager\n    session : GefSessionManager\n    gdb: GefCommand\n\n    def __init__(self) -> None:\n        self.binary: FileFormat | None = None\n        self.arch: Architecture = GenericArchitecture() # see PR #516, will be reset by `new_objfile_handler`\n        self.arch_reason: str = \"This is the default architecture\"\n        self.config = GefSettingsManager()\n        self.ui = GefUiManager()\n        self.libc = GefLibcManager()\n        return\n\n    def __str__(self) -> str:\n        return f\"Gef(binary='{self.binary or 'None'}', arch={self.arch})\"\n\n    def reinitialize_managers(self) -> None:\n        \"\"\"Reinitialize the managers. Avoid calling this function directly, using `pi reset()` is preferred\"\"\"\n        self.memory = GefMemoryManager()\n        self.heap = GefHeapManager()\n        self.session = GefSessionManager()\n        return\n\n    def setup(self) -> None:\n        \"\"\"Setup initialize the runtime setup, which may require for the `gef` to be not None.\"\"\"\n        self.reinitialize_managers()\n        self.gdb = GefCommand()\n        self.gdb.setup()\n        gdb.execute(f\"save gdb-index '{self.config['gef.tempdir']}'\")\n        return\n\n    def reset_caches(self) -> None:\n        \"\"\"Recursively clean the cache of all the managers. Avoid calling this function directly, using `reset-cache`\n        is preferred\"\"\"\n        for mgr in (self.memory, self.heap, self.session, self.arch):\n            mgr.reset_caches()\n        return\n\n\ndef target_remote_posthook():\n    if gef.session.remote_initializing:\n        return\n\n    gef.session.remote = GefRemoteSessionManager(\"\", 0)\n    if not gef.session.remote.setup():\n        raise EnvironmentError(f\"Failed to create a proper environment for {gef.session.remote}\")\n\nif __name__ == \"__main__\":\n    if sys.version_info[0] == 2:\n        err(\"GEF has dropped Python2 support for GDB when it reached EOL on 2020/01/01.\")\n        err(\"If you require GEF for GDB+Python2, use https://github.com/hugsy/gef-legacy.\")\n        exit(1)\n\n    if GDB_VERSION < GDB_MIN_VERSION or PYTHON_VERSION < PYTHON_MIN_VERSION:\n        err(\"You're using an old version of GDB. GEF will not work correctly. \"\n            f\"Consider updating to GDB {'.'.join(map(str, GDB_MIN_VERSION))} or higher \"\n            f\"(with Python {'.'.join(map(str, PYTHON_MIN_VERSION))} or higher).\")\n        exit(1)\n\n    # setup config\n    gdb_initial_settings = (\n        \"set confirm off\",\n        \"set verbose off\",\n        \"set pagination off\",\n        \"set print elements 0\",\n        \"set history save on\",\n        f\"set history filename {os.getenv('GDBHISTFILE', '~/.gdb_history')}\",\n        \"set output-radix 0x10\",\n        \"set print pretty on\",\n        \"set disassembly-flavor intel\",\n        \"handle SIGALRM print nopass\",\n    )\n    for cmd in gdb_initial_settings:\n        try:\n            gdb.execute(cmd)\n        except gdb.error:\n            pass\n\n    # load GEF, set up the managers and load the plugins, functions,\n    gef = Gef()\n    reset()\n    assert isinstance(gef, Gef)\n    gef.gdb.load()\n    gef.gdb.show_banner()\n\n    # load config\n    if gef.gdb.load_extra_plugins():\n        # reload settings\n        gdb.execute(\"gef restore\")\n\n    # setup gdb prompt\n    gdb.prompt_hook = __gef_prompt__\n\n    # gdb events configuration\n    gef_on_continue_hook(continue_handler)\n    gef_on_stop_hook(hook_stop_handler)\n    gef_on_new_hook(new_objfile_handler)\n    gef_on_exit_hook(exit_handler)\n    gef_on_memchanged_hook(memchanged_handler)\n    gef_on_regchanged_hook(regchanged_handler)\n\n    progspace = gdb.current_progspace()\n    if progspace and progspace.filename:\n        # if here, we are sourcing gef from a gdb session already attached, force call to new_objfile (see issue #278)\n        new_objfile_handler(None)\n\n    GefTmuxSetup()\n\n    if GDB_VERSION > (9, 0):\n        disable_tr_overwrite_setting = \"gef.disable_target_remote_overwrite\"\n\n        if not gef.config[disable_tr_overwrite_setting]:\n            warnmsg = (\"Using `target remote` with GEF should work in most cases, \"\n                       \"but use `gef-remote` if you can. You can disable the \"\n                       \"overwrite of the `target remote` command by toggling \"\n                       f\"`{disable_tr_overwrite_setting}` in the config.\")\n            hook = f\"\"\"\n                define target hookpost-{{}}\n                pi target_remote_posthook()\n                context\n                pi if calling_function() != \"connect\": warn(\"{warnmsg}\")\n                end\n            \"\"\"\n\n            # Register a post-hook for `target remote` that initialize the remote session\n            gdb.execute(hook.format(\"remote\"))\n            gdb.execute(hook.format(\"extended-remote\"))\n        else:\n            errmsg = (\"Using `target remote` does not work, use `gef-remote` \"\n                      f\"instead. You can toggle `{disable_tr_overwrite_setting}` \"\n                      \"if this is not desired.\")\n            hook = f\"\"\"pi if calling_function() != \"connect\": err(\"{errmsg}\")\"\"\"\n            gdb.execute(f\"define target hook-remote\\n{hook}\\nend\")\n            gdb.execute(f\"define target hook-extended-remote\\n{hook}\\nend\")\n\n    # restore saved breakpoints (if any)\n    bkp_fpath = pathlib.Path(gef.config[\"gef.autosave_breakpoints_file\"]).expanduser().absolute()\n    if bkp_fpath.is_file():\n        gdb.execute(f\"source {bkp_fpath}\")\n\n    # Add a `source` post hook to force gef to recheck the registered plugins and\n    # eventually load the missing one(s)\n    gdb.execute(\"define hookpost-source\\npi gef.gdb.load()\\nend\")\n"
        },
        {
          "name": "mkdocs.yml",
          "type": "blob",
          "size": 2.3984375,
          "content": "site_name: GEF - GDB Enhanced Features documentation\ntheme:\n  name: material\n  font:\n    text: Roboto\n    code: Roboto Mono\n  features:\n    - navigation.instant\n    - navigation.tabs\n\n\nnav:\n- Home: index.md\n- Showroom: screenshots.md\n- Setup:\n  - Installation: install.md\n  - Configuration: config.md\n  - Compatibility: compat.md\n- FAQ: faq.md\n- Hacking GEF:\n  - Testing: testing.md\n  - Write extensions: api.md\n  - API: api/gef.md\n  - Debugging: debugging.md\n  - Coverage: https://hugsy.github.io/gef/coverage/\n- Commands:\n  - aliases: commands/aliases.md\n  - arch: commands/arch.md\n  - aslr: commands/aslr.md\n  - canary: commands/canary.md\n  - checksec: commands/checksec.md\n  - config: commands/config.md\n  - context: commands/context.md\n  - dereference: commands/dereference.md\n  - edit-flags: commands/edit-flags.md\n  - elf-info: commands/elf-info.md\n  - entry-break: commands/entry-break.md\n  - eval: commands/eval.md\n  - format-string-helper: commands/format-string-helper.md\n  - functions: commands/functions.md\n  - gef: commands/gef.md\n  - gef-remote: commands/gef-remote.md\n  - got: commands/got.md\n  - heap-analysis-helper: commands/heap-analysis-helper.md\n  - heap: commands/heap.md\n  - help: commands/help.md\n  - hexdump: commands/hexdump.md\n  - highlight: commands/highlight.md\n  - hijack-fd: commands/hijack-fd.md\n  - memory: commands/memory.md\n  - name-break: commands/name-break.md\n  - nop: commands/nop.md\n  - patch: commands/patch.md\n  - pattern: commands/pattern.md\n  - pcustom: commands/pcustom.md\n  - pie: commands/pie.md\n  - print-format: commands/print-format.md\n  - process-search: commands/process-search.md\n  - process-status: commands/process-status.md\n  - registers: commands/registers.md\n  - reset-cache: commands/reset-cache.md\n  - scan: commands/scan.md\n  - search-pattern: commands/search-pattern.md\n  - shellcode: commands/shellcode.md\n  - stub: commands/stub.md\n  - stepover: commands/stepover.md\n  - skipi: commands/skipi.md\n  - theme: commands/theme.md\n  - tmux-setup: commands/tmux-setup.md\n  - trace-run: commands/trace-run.md\n  - version: commands/version.md\n  - vmmap: commands/vmmap.md\n  - xfiles: commands/xfiles.md\n  - xinfo: commands/xinfo.md\n  - xor-memory: commands/xor-memory.md\n- Functions:\n  - base: functions/base.md\n  - bss: functions/bss.md\n  - got: functions/got.md\n  - heap: functions/heap.md\n  - stack: functions/stack.md\n- GEF-Extras: https://hugsy.github.io/gef-extras/\n- Deprecated: deprecated.md\n"
        },
        {
          "name": "ruff.toml",
          "type": "blob",
          "size": 0.04296875,
          "content": "[lint.per-file-ignores]\n\"gef.py\" = [\"E701\"]\n"
        },
        {
          "name": "scripts",
          "type": "tree",
          "content": null
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}