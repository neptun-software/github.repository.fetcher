{
  "metadata": {
    "timestamp": 1736560994505,
    "page": 751,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjc2MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "liuwons/wxBot",
      "stars": 5356,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.7939453125,
          "content": "# Byte-compiled / optimized / DLL files\n__pycache__/\n*.py[cod]\n*$py.class\n\n# C extensions\n*.so\n\n# Distribution / packaging\n.Python\nenv/\nbuild/\ndevelop-eggs/\ndist/\ndownloads/\neggs/\n.eggs/\nlib/\nlib64/\nparts/\nsdist/\nvar/\n*.egg-info/\n.installed.cfg\n*.egg\n\n# PyInstaller\n#  Usually these files are written by a python script from a template\n#  before PyInstaller builds the exe, so as to inject date/other infos into it.\n*.manifest\n*.spec\n\n# Installer logs\npip-log.txt\npip-delete-this-directory.txt\n\n# Unit test / coverage reports\nhtmlcov/\n.tox/\n.coverage\n.coverage.*\n.cache\nnosetests.xml\ncoverage.xml\n*,cover\n.hypothesis/\n\n# Translations\n*.mo\n*.pot\n\n# Django stuff:\n*.log\n\n# Sphinx documentation\ndocs/_build/\n\n# PyBuilder\ntarget/\n\n#Ipython Notebook\n.ipynb_checkpoints\n\n\n*.json\n.idea/\n\nqr.png\n/*.jpg\n*.ini\n*.un~\n/temp\n"
        },
        {
          "name": "CHANGES.md",
          "type": "blob",
          "size": 0.4150390625,
          "content": "# Change Log\n\n\n# V0.1\n\n时间： 2016-06-05\n\n初始版本。\n\n***wxbot.py*** 已经实现了基本的群聊、单聊接口。\n\n***test.py*** 实现了一个功能最基础的机器人，对所有好友的文本消息回复 *hi* ，并不断向好友 *tb* 发送 *schedule* 。\n\n***bot.py*** 利用 ***wxBot*** 和 ***图灵机器人*** 实现了一个群聊机器人。对好友以及群聊中@自己的消息进行回复。\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 11.0908203125,
          "content": "                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"{}\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright {yyyy} {name of copyright owner}\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 0.029296875,
          "content": "\n**本项目已停止维护**\n"
        },
        {
          "name": "__init__.py",
          "type": "blob",
          "size": 0,
          "content": ""
        },
        {
          "name": "bot.py",
          "type": "blob",
          "size": 4.2314453125,
          "content": "#!/usr/bin/env python\n# coding: utf-8\n\nfrom wxbot import *\nimport ConfigParser\nimport json\n\n\nclass TulingWXBot(WXBot):\n    def __init__(self):\n        WXBot.__init__(self)\n\n        self.tuling_key = \"\"\n        self.robot_switch = True\n\n        try:\n            cf = ConfigParser.ConfigParser()\n            cf.read('conf.ini')\n            self.tuling_key = cf.get('main', 'key')\n        except Exception:\n            pass\n        print 'tuling_key:', self.tuling_key\n\n    def tuling_auto_reply(self, uid, msg):\n        if self.tuling_key:\n            url = \"http://www.tuling123.com/openapi/api\"\n            user_id = uid.replace('@', '')[:30]\n            body = {'key': self.tuling_key, 'info': msg.encode('utf8'), 'userid': user_id}\n            r = requests.post(url, data=body)\n            respond = json.loads(r.text)\n            result = ''\n            if respond['code'] == 100000:\n                result = respond['text'].replace('<br>', '  ')\n                result = result.replace(u'\\xa0', u' ')\n            elif respond['code'] == 200000:\n                result = respond['url']\n            elif respond['code'] == 302000:\n                for k in respond['list']:\n                    result = result + u\"【\" + k['source'] + u\"】 \" +\\\n                        k['article'] + \"\\t\" + k['detailurl'] + \"\\n\"\n            else:\n                result = respond['text'].replace('<br>', '  ')\n                result = result.replace(u'\\xa0', u' ')\n\n            print '    ROBOT:', result\n            return result\n        else:\n            return u\"知道啦\"\n\n    def auto_switch(self, msg):\n        msg_data = msg['content']['data']\n        stop_cmd = [u'退下', u'走开', u'关闭', u'关掉', u'休息', u'滚开']\n        start_cmd = [u'出来', u'启动', u'工作']\n        if self.robot_switch:\n            for i in stop_cmd:\n                if i == msg_data:\n                    self.robot_switch = False\n                    self.send_msg_by_uid(u'[Robot]' + u'机器人已关闭！', msg['to_user_id'])\n        else:\n            for i in start_cmd:\n                if i == msg_data:\n                    self.robot_switch = True\n                    self.send_msg_by_uid(u'[Robot]' + u'机器人已开启！', msg['to_user_id'])\n\n    def handle_msg_all(self, msg):\n        if not self.robot_switch and msg['msg_type_id'] != 1:\n            return\n        if msg['msg_type_id'] == 1 and msg['content']['type'] == 0:  # reply to self\n            self.auto_switch(msg)\n        elif msg['msg_type_id'] == 4 and msg['content']['type'] == 0:  # text message from contact\n            self.send_msg_by_uid(self.tuling_auto_reply(msg['user']['id'], msg['content']['data']), msg['user']['id'])\n        elif msg['msg_type_id'] == 3 and msg['content']['type'] == 0:  # group text message\n            if 'detail' in msg['content']:\n                my_names = self.get_group_member_name(msg['user']['id'], self.my_account['UserName'])\n                if my_names is None:\n                    my_names = {}\n                if 'NickName' in self.my_account and self.my_account['NickName']:\n                    my_names['nickname2'] = self.my_account['NickName']\n                if 'RemarkName' in self.my_account and self.my_account['RemarkName']:\n                    my_names['remark_name2'] = self.my_account['RemarkName']\n\n                is_at_me = False\n                for detail in msg['content']['detail']:\n                    if detail['type'] == 'at':\n                        for k in my_names:\n                            if my_names[k] and my_names[k] == detail['value']:\n                                is_at_me = True\n                                break\n                if is_at_me:\n                    src_name = msg['content']['user']['name']\n                    reply = 'to ' + src_name + ': '\n                    if msg['content']['type'] == 0:  # text message\n                        reply += self.tuling_auto_reply(msg['content']['user']['id'], msg['content']['desc'])\n                    else:\n                        reply += u\"对不起，只认字，其他杂七杂八的我都不认识，,,Ծ‸Ծ,,\"\n                    self.send_msg_by_uid(reply, msg['user']['id'])\n\n\ndef main():\n    bot = TulingWXBot()\n    bot.DEBUG = True\n    bot.conf['qr'] = 'png'\n\n    bot.run()\n\n\nif __name__ == '__main__':\n    main()\n\n"
        },
        {
          "name": "img",
          "type": "tree",
          "content": null
        },
        {
          "name": "test.py",
          "type": "blob",
          "size": 0.607421875,
          "content": "#!/usr/bin/env python\n# coding: utf-8\n#\n\nfrom wxbot import *\n\n\nclass MyWXBot(WXBot):\n    def handle_msg_all(self, msg):\n        if msg['msg_type_id'] == 4 and msg['content']['type'] == 0:\n            self.send_msg_by_uid(u'hi', msg['user']['id'])\n            #self.send_img_msg_by_uid(\"img/1.png\", msg['user']['id'])\n            #self.send_file_msg_by_uid(\"img/1.png\", msg['user']['id'])\n'''\n    def schedule(self):\n        self.send_msg(u'张三', u'测试')\n        time.sleep(1)\n'''\n\n\ndef main():\n    bot = MyWXBot()\n    bot.DEBUG = True\n    bot.conf['qr'] = 'png'\n    bot.run()\n\n\nif __name__ == '__main__':\n    main()\n"
        },
        {
          "name": "wxbot.py",
          "type": "blob",
          "size": 60.6396484375,
          "content": "#!/usr/bin/env python\n# coding: utf-8\n\nimport os\nimport sys\nimport traceback\nimport webbrowser\nimport pyqrcode\nimport requests\nimport mimetypes\nimport json\nimport xml.dom.minidom\nimport urllib\nimport time\nimport re\nimport random\nfrom traceback import format_exc\nfrom requests.exceptions import ConnectionError, ReadTimeout\nimport HTMLParser\n\nUNKONWN = 'unkonwn'\nSUCCESS = '200'\nSCANED = '201'\nTIMEOUT = '408'\n\ndef map_username_batch(user_name):\n    return {\"UserName\": user_name, \"EncryChatRoomId\": \"\"}\n\n\ndef show_image(file_path):\n    \"\"\"\n    跨平台显示图片文件\n    :param file_path: 图片文件路径\n    \"\"\"\n    if sys.version_info >= (3, 3):\n        from shlex import quote\n    else:\n        from pipes import quote\n\n    if sys.platform == \"darwin\":\n        command = \"open -a /Applications/Preview.app %s&\" % quote(file_path)\n        os.system(command)\n    else:\n        webbrowser.open(os.path.join(os.getcwd(),'temp',file_path))\n\n\nclass SafeSession(requests.Session):\n    def request(self, method, url, params=None, data=None, headers=None, cookies=None, files=None, auth=None,\n                timeout=None, allow_redirects=True, proxies=None, hooks=None, stream=None, verify=None, cert=None,\n                json=None):\n        for i in range(3):\n            try:\n                return super(SafeSession, self).request(method, url, params, data, headers, cookies, files, auth,\n                                                        timeout,\n                                                        allow_redirects, proxies, hooks, stream, verify, cert, json)\n            except Exception as e:\n                print e.message, traceback.format_exc()\n                continue\n\n        #重试3次以后再加一次，抛出异常\n        try:\n            return super(SafeSession, self).request(method, url, params, data, headers, cookies, files, auth,\n                                                    timeout,\n                                                    allow_redirects, proxies, hooks, stream, verify, cert, json)\n        except Exception as e:\n            raise e\n\n\nclass WXBot:\n    \"\"\"WXBot功能类\"\"\"\n\n    def __init__(self):\n        self.DEBUG = False\n        self.uuid = ''\n        self.base_uri = ''\n        self.base_host = ''\n        self.redirect_uri = ''\n        self.uin = ''\n        self.sid = ''\n        self.skey = ''\n        self.pass_ticket = ''\n        self.device_id = 'e' + repr(random.random())[2:17]\n        self.base_request = {}\n        self.sync_key_str = ''\n        self.sync_key = []\n        self.sync_host = ''\n\n        status = 'wait4login'    #表示机器人状态，供WEBAPI读取，WxbotManage使用\n        bot_conf = {} #机器人配置，在webapi初始化的时候传入，后续也可修改，WxbotManage使用\n\n        self.batch_count = 50    #一次拉取50个联系人的信息\n        self.full_user_name_list = []    #直接获取不到通讯录时，获取的username列表\n        self.wxid_list = []   #获取到的wxid的列表\n        self.cursor = 0   #拉取联系人信息的游标\n        self.is_big_contact = False  #通讯录人数过多，无法直接获取\n        #文件缓存目录\n        self.temp_pwd  =  os.path.join(os.getcwd(),'temp')\n        if os.path.exists(self.temp_pwd) == False:\n            os.makedirs(self.temp_pwd)\n\n        self.session = SafeSession()\n        self.session.headers.update({'User-Agent': 'Mozilla/5.0 (X11; Linux i686; U;) Gecko/20070322 Kazehakase/0.4.5'})\n        self.conf = {'qr': 'png'}\n\n        self.my_account = {}  # 当前账户\n\n        # 所有相关账号: 联系人, 公众号, 群组, 特殊账号\n        self.member_list = []\n\n        # 所有群组的成员, {'group_id1': [member1, member2, ...], ...}\n        self.group_members = {}\n\n        # 所有账户, {'group_member':{'id':{'type':'group_member', 'info':{}}, ...}, 'normal_member':{'id':{}, ...}}\n        self.account_info = {'group_member': {}, 'normal_member': {}}\n\n        self.contact_list = []  # 联系人列表\n        self.public_list = []  # 公众账号列表\n        self.group_list = []  # 群聊列表\n        self.special_list = []  # 特殊账号列表\n        self.encry_chat_room_id_list = []  # 存储群聊的EncryChatRoomId，获取群内成员头像时需要用到\n\n        self.file_index = 0\n\n    #在未传入bot_conf的情况下尝试载入本地配置文件，WxbotManage使用\n    def load_conf(self,bot_conf):\n        try:\n            if bot_conf == {}:\n                with open(os.path.join(self.temp_pwd,'bot_conf.json')) as f:\n                    self.bot_conf= json.loads(f.read())\n        except:\n            self.bot_conf = {}\n\n    #保存配置文件，WxbotManage使用\n    def save_conf(self):\n        with open(os.path.join(self.temp_pwd,'bot_conf.json'), 'w') as f:\n            f.write(json.dumps(self.bot_conf))\n\n\n    @staticmethod\n    def to_unicode(string, encoding='utf-8'):\n        \"\"\"\n        将字符串转换为Unicode\n        :param string: 待转换字符串\n        :param encoding: 字符串解码方式\n        :return: 转换后的Unicode字符串\n        \"\"\"\n        if isinstance(string, str):\n            return string.decode(encoding)\n        elif isinstance(string, unicode):\n            return string\n        else:\n            raise Exception('Unknown Type')\n\n    def get_contact(self):\n        \"\"\"获取当前账户的所有相关账号(包括联系人、公众号、群聊、特殊账号)\"\"\"\n        dic_list = []\n        url = self.base_uri + '/webwxgetcontact?seq=0&pass_ticket=%s&skey=%s&r=%s' \\\n                              % (self.pass_ticket, self.skey, int(time.time()))\n\n        #如果通讯录联系人过多，这里会直接获取失败\n        try:\n            r = self.session.post(url, data='{}', timeout=180)\n        except Exception as e:\n            return False\n        r.encoding = 'utf-8'\n        dic = json.loads(r.text)\n        dic_list.append(dic)\n\n        while int(dic[\"Seq\"]) != 0:\n            print \"[INFO] Geting contacts. Get %s contacts for now\" % dic[\"MemberCount\"]\n            url = self.base_uri + '/webwxgetcontact?seq=%s&pass_ticket=%s&skey=%s&r=%s' \\\n                      % (dic[\"Seq\"], self.pass_ticket, self.skey, int(time.time()))\n            r = self.session.post(url, data='{}', timeout=180)\n            r.encoding = 'utf-8'\n            dic = json.loads(r.text)\n            dic_list.append(dic)\n\n        if self.DEBUG:\n            with open(os.path.join(self.temp_pwd,'contacts.json'), 'w') as f:\n                f.write(json.dumps(dic_list))\n\n        self.member_list = []\n        for dic in dic_list:\n            self.member_list.extend(dic['MemberList'])\n\n        special_users = ['newsapp', 'fmessage', 'filehelper', 'weibo', 'qqmail',\n                         'fmessage', 'tmessage', 'qmessage', 'qqsync', 'floatbottle',\n                         'lbsapp', 'shakeapp', 'medianote', 'qqfriend', 'readerapp',\n                         'blogapp', 'facebookapp', 'masssendapp', 'meishiapp',\n                         'feedsapp', 'voip', 'blogappweixin', 'weixin', 'brandsessionholder',\n                         'weixinreminder', 'wxid_novlwrv3lqwv11', 'gh_22b87fa7cb3c',\n                         'officialaccounts', 'notification_messages', 'wxid_novlwrv3lqwv11',\n                         'gh_22b87fa7cb3c', 'wxitil', 'userexperience_alarm', 'notification_messages']\n\n        self.contact_list = []\n        self.public_list = []\n        self.special_list = []\n        self.group_list = []\n\n        for contact in self.member_list:\n            if contact['VerifyFlag'] & 8 != 0:  # 公众号\n                self.public_list.append(contact)\n                self.account_info['normal_member'][contact['UserName']] = {'type': 'public', 'info': contact}\n            elif contact['UserName'] in special_users:  # 特殊账户\n                self.special_list.append(contact)\n                self.account_info['normal_member'][contact['UserName']] = {'type': 'special', 'info': contact}\n            elif contact['UserName'].find('@@') != -1:  # 群聊\n                self.group_list.append(contact)\n                self.account_info['normal_member'][contact['UserName']] = {'type': 'group', 'info': contact}\n            elif contact['UserName'] == self.my_account['UserName']:  # 自己\n                self.account_info['normal_member'][contact['UserName']] = {'type': 'self', 'info': contact}\n            else:\n                self.contact_list.append(contact)\n                self.account_info['normal_member'][contact['UserName']] = {'type': 'contact', 'info': contact}\n\n        self.batch_get_group_members()\n\n        for group in self.group_members:\n            for member in self.group_members[group]:\n                if member['UserName'] not in self.account_info:\n                    self.account_info['group_member'][member['UserName']] = \\\n                        {'type': 'group_member', 'info': member, 'group': group}\n\n        if self.DEBUG:\n            with open(os.path.join(self.temp_pwd,'contact_list.json'), 'w') as f:\n                f.write(json.dumps(self.contact_list))\n            with open(os.path.join(self.temp_pwd,'special_list.json'), 'w') as f:\n                f.write(json.dumps(self.special_list))\n            with open(os.path.join(self.temp_pwd,'group_list.json'), 'w') as f:\n                f.write(json.dumps(self.group_list))\n            with open(os.path.join(self.temp_pwd,'public_list.json'), 'w') as f:\n                f.write(json.dumps(self.public_list))\n            with open(os.path.join(self.temp_pwd,'member_list.json'), 'w') as f:\n                f.write(json.dumps(self.member_list))\n            with open(os.path.join(self.temp_pwd,'group_users.json'), 'w') as f:\n                f.write(json.dumps(self.group_members))\n            with open(os.path.join(self.temp_pwd,'account_info.json'), 'w') as f:\n                f.write(json.dumps(self.account_info))\n        return True\n\n\n    def get_big_contact(self):\n        total_len = len(self.full_user_name_list)\n        user_info_list = []\n\n        #一次拉取50个联系人的信息，包括所有的群聊，公众号，好友\n        while self.cursor < total_len:\n            cur_batch = self.full_user_name_list[self.cursor:(self.cursor+self.batch_count)]\n            self.cursor += self.batch_count\n            cur_batch = map(map_username_batch, cur_batch)\n            user_info_list += self.batch_get_contact(cur_batch)\n            print \"[INFO] Get batch contacts\"\n\n        self.member_list = user_info_list\n        special_users = ['newsapp', 'filehelper', 'weibo', 'qqmail',\n                 'fmessage', 'tmessage', 'qmessage', 'qqsync', 'floatbottle',\n                 'lbsapp', 'shakeapp', 'medianote', 'qqfriend', 'readerapp',\n                 'blogapp', 'facebookapp', 'masssendapp', 'meishiapp',\n                 'feedsapp', 'voip', 'blogappweixin', 'weixin', 'brandsessionholder',\n                 'weixinreminder', 'wxid_novlwrv3lqwv11',\n                 'officialaccounts',\n                 'gh_22b87fa7cb3c', 'wxitil', 'userexperience_alarm', 'notification_messages', 'notifymessage']\n\n        self.contact_list = []\n        self.public_list = []\n        self.special_list = []\n        self.group_list = []\n        for i, contact in enumerate(self.member_list):\n            if contact['VerifyFlag'] & 8 != 0:  # 公众号\n                self.public_list.append(contact)\n                self.account_info['normal_member'][contact['UserName']] = {'type': 'public', 'info': contact}\n            elif contact['UserName'] in special_users or self.wxid_list[i] in special_users:  # 特殊账户\n                self.special_list.append(contact)\n                self.account_info['normal_member'][contact['UserName']] = {'type': 'special', 'info': contact}\n            elif contact['UserName'].find('@@') != -1:  # 群聊\n                self.group_list.append(contact)\n                self.account_info['normal_member'][contact['UserName']] = {'type': 'group', 'info': contact}\n            elif contact['UserName'] == self.my_account['UserName']:  # 自己\n                self.account_info['normal_member'][contact['UserName']] = {'type': 'self', 'info': contact}\n            else:\n                self.contact_list.append(contact)\n                self.account_info['normal_member'][contact['UserName']] = {'type': 'contact', 'info': contact}\n        group_members = {}\n        encry_chat_room_id = {}\n        for group in self.group_list:\n            gid = group['UserName']\n            members = group['MemberList']\n            group_members[gid] = members\n            encry_chat_room_id[gid] = group['EncryChatRoomId']\n        self.group_members = group_members\n        self.encry_chat_room_id_list = encry_chat_room_id\n\n        for group in self.group_members:\n            for member in self.group_members[group]:\n                if member['UserName'] not in self.account_info:\n                    self.account_info['group_member'][member['UserName']] = \\\n                        {'type': 'group_member', 'info': member, 'group': group}\n\n        if self.DEBUG:\n            with open(os.path.join(self.temp_pwd,'contact_list.json'), 'w') as f:\n                f.write(json.dumps(self.contact_list))\n            with open(os.path.join(self.temp_pwd,'special_list.json'), 'w') as f:\n                f.write(json.dumps(self.special_list))\n            with open(os.path.join(self.temp_pwd,'group_list.json'), 'w') as f:\n                f.write(json.dumps(self.group_list))\n            with open(os.path.join(self.temp_pwd,'public_list.json'), 'w') as f:\n                f.write(json.dumps(self.public_list))\n            with open(os.path.join(self.temp_pwd,'member_list.json'), 'w') as f:\n                f.write(json.dumps(self.member_list))\n            with open(os.path.join(self.temp_pwd,'group_users.json'), 'w') as f:\n                f.write(json.dumps(self.group_members))\n            with open(os.path.join(self.temp_pwd,'account_info.json'), 'w') as f:\n                f.write(json.dumps(self.account_info))\n        print '[INFO] Get %d contacts' % len(self.contact_list)\n        print '[INFO] Start to process messages .'\n        return True\n\n\n\n    def batch_get_contact(self, cur_batch):\n        \"\"\"批量获取成员信息\"\"\"\n        url = self.base_uri + '/webwxbatchgetcontact?type=ex&r=%s&pass_ticket=%s' % (int(time.time()), self.pass_ticket)\n        params = {\n            'BaseRequest': self.base_request,\n            \"Count\": len(cur_batch),\n            \"List\": cur_batch\n        }\n        r = self.session.post(url, data=json.dumps(params))\n        r.encoding = 'utf-8'\n        dic = json.loads(r.text)\n        #print dic['ContactList']\n        return dic['ContactList']\n\n\n    def batch_get_group_members(self):\n        \"\"\"批量获取所有群聊成员信息\"\"\"\n        url = self.base_uri + '/webwxbatchgetcontact?type=ex&r=%s&pass_ticket=%s' % (int(time.time()), self.pass_ticket)\n        params = {\n            'BaseRequest': self.base_request,\n            \"Count\": len(self.group_list),\n            \"List\": [{\"UserName\": group['UserName'], \"EncryChatRoomId\": \"\"} for group in self.group_list]\n        }\n        r = self.session.post(url, data=json.dumps(params))\n        r.encoding = 'utf-8'\n        dic = json.loads(r.text)\n        group_members = {}\n        encry_chat_room_id = {}\n        for group in dic['ContactList']:\n            gid = group['UserName']\n            members = group['MemberList']\n            group_members[gid] = members\n            encry_chat_room_id[gid] = group['EncryChatRoomId']\n        self.group_members = group_members\n        self.encry_chat_room_id_list = encry_chat_room_id\n\n    def get_group_member_name(self, gid, uid):\n        \"\"\"\n        获取群聊中指定成员的名称信息\n        :param gid: 群id\n        :param uid: 群聊成员id\n        :return: 名称信息，类似 {\"display_name\": \"test_user\", \"nickname\": \"test\", \"remark_name\": \"for_test\" }\n        \"\"\"\n        if gid not in self.group_members:\n            return None\n        group = self.group_members[gid]\n        for member in group:\n            if member['UserName'] == uid:\n                names = {}\n                if 'RemarkName' in member and member['RemarkName']:\n                    names['remark_name'] = member['RemarkName']\n                if 'NickName' in member and member['NickName']:\n                    names['nickname'] = member['NickName']\n                if 'DisplayName' in member and member['DisplayName']:\n                    names['display_name'] = member['DisplayName']\n                return names\n        return None\n\n    def get_contact_info(self, uid):\n        return self.account_info['normal_member'].get(uid)\n\n\n    def get_group_member_info(self, uid):\n        return self.account_info['group_member'].get(uid)\n\n    def get_contact_name(self, uid):\n        info = self.get_contact_info(uid)\n        if info is None:\n            return None\n        info = info['info']\n        name = {}\n        if 'RemarkName' in info and info['RemarkName']:\n            name['remark_name'] = info['RemarkName']\n        if 'NickName' in info and info['NickName']:\n            name['nickname'] = info['NickName']\n        if 'DisplayName' in info and info['DisplayName']:\n            name['display_name'] = info['DisplayName']\n        if len(name) == 0:\n            return None\n        else:\n            return name\n\n    @staticmethod\n    def get_contact_prefer_name(name):\n        if name is None:\n            return None\n        if 'remark_name' in name:\n            return name['remark_name']\n        if 'nickname' in name:\n            return name['nickname']\n        if 'display_name' in name:\n            return name['display_name']\n        return None\n\n    @staticmethod\n    def get_group_member_prefer_name(name):\n        if name is None:\n            return None\n        if 'remark_name' in name:\n            return name['remark_name']\n        if 'display_name' in name:\n            return name['display_name']\n        if 'nickname' in name:\n            return name['nickname']\n        return None\n\n    def get_user_type(self, wx_user_id):\n        \"\"\"\n        获取特定账号与自己的关系\n        :param wx_user_id: 账号id:\n        :return: 与当前账号的关系\n        \"\"\"\n        for account in self.contact_list:\n            if wx_user_id == account['UserName']:\n                return 'contact'\n        for account in self.public_list:\n            if wx_user_id == account['UserName']:\n                return 'public'\n        for account in self.special_list:\n            if wx_user_id == account['UserName']:\n                return 'special'\n        for account in self.group_list:\n            if wx_user_id == account['UserName']:\n                return 'group'\n        for group in self.group_members:\n            for member in self.group_members[group]:\n                if member['UserName'] == wx_user_id:\n                    return 'group_member'\n        return 'unknown'\n\n    def is_contact(self, uid):\n        for account in self.contact_list:\n            if uid == account['UserName']:\n                return True\n        return False\n\n    def is_public(self, uid):\n        for account in self.public_list:\n            if uid == account['UserName']:\n                return True\n        return False\n\n    def is_special(self, uid):\n        for account in self.special_list:\n            if uid == account['UserName']:\n                return True\n        return False\n\n    def handle_msg_all(self, msg):\n        \"\"\"\n        处理所有消息，请子类化后覆盖此函数\n        msg:\n            msg_id  ->  消息id\n            msg_type_id  ->  消息类型id\n            user  ->  发送消息的账号id\n            content  ->  消息内容\n        :param msg: 收到的消息\n        \"\"\"\n        pass\n\n    @staticmethod\n    def proc_at_info(msg):\n        if not msg:\n            return '', []\n        segs = msg.split(u'\\u2005')\n        str_msg_all = ''\n        str_msg = ''\n        infos = []\n        if len(segs) > 1:\n            for i in range(0, len(segs) - 1):\n                segs[i] += u'\\u2005'\n                pm = re.search(u'@.*\\u2005', segs[i]).group()\n                if pm:\n                    name = pm[1:-1]\n                    string = segs[i].replace(pm, '')\n                    str_msg_all += string + '@' + name + ' '\n                    str_msg += string\n                    if string:\n                        infos.append({'type': 'str', 'value': string})\n                    infos.append({'type': 'at', 'value': name})\n                else:\n                    infos.append({'type': 'str', 'value': segs[i]})\n                    str_msg_all += segs[i]\n                    str_msg += segs[i]\n            str_msg_all += segs[-1]\n            str_msg += segs[-1]\n            infos.append({'type': 'str', 'value': segs[-1]})\n        else:\n            infos.append({'type': 'str', 'value': segs[-1]})\n            str_msg_all = msg\n            str_msg = msg\n        return str_msg_all.replace(u'\\u2005', ''), str_msg.replace(u'\\u2005', ''), infos\n\n    def extract_msg_content(self, msg_type_id, msg):\n        \"\"\"\n        content_type_id:\n            0 -> Text\n            1 -> Location\n            3 -> Image\n            4 -> Voice\n            5 -> Recommend\n            6 -> Animation\n            7 -> Share\n            8 -> Video\n            9 -> VideoCall\n            10 -> Redraw\n            11 -> Empty\n            99 -> Unknown\n        :param msg_type_id: 消息类型id\n        :param msg: 消息结构体\n        :return: 解析的消息\n        \"\"\"\n        mtype = msg['MsgType']\n        content = HTMLParser.HTMLParser().unescape(msg['Content'])\n        msg_id = msg['MsgId']\n\n        msg_content = {}\n        if msg_type_id == 0:\n            return {'type': 11, 'data': ''}\n        elif msg_type_id == 2:  # File Helper\n            return {'type': 0, 'data': content.replace('<br/>', '\\n')}\n        elif msg_type_id == 3:  # 群聊\n            sp = content.find('<br/>')\n            uid = content[:sp]\n            content = content[sp:]\n            content = content.replace('<br/>', '')\n            uid = uid[:-1]\n            name = self.get_contact_prefer_name(self.get_contact_name(uid))\n            if not name:\n                name = self.get_group_member_prefer_name(self.get_group_member_name(msg['FromUserName'], uid))\n            if not name:\n                name = 'unknown'\n            msg_content['user'] = {'id': uid, 'name': name}\n        else:  # Self, Contact, Special, Public, Unknown\n            pass\n\n        msg_prefix = (msg_content['user']['name'] + ':') if 'user' in msg_content else ''\n\n        if mtype == 1:\n            if content.find('http://weixin.qq.com/cgi-bin/redirectforward?args=') != -1:\n                r = self.session.get(content)\n                r.encoding = 'gbk'\n                data = r.text\n                pos = self.search_content('title', data, 'xml')\n                msg_content['type'] = 1\n                msg_content['data'] = pos\n                msg_content['detail'] = data\n                if self.DEBUG:\n                    print '    %s[Location] %s ' % (msg_prefix, pos)\n            else:\n                msg_content['type'] = 0\n                if msg_type_id == 3 or (msg_type_id == 1 and msg['ToUserName'][:2] == '@@'):  # Group text message\n                    msg_infos = self.proc_at_info(content)\n                    str_msg_all = msg_infos[0]\n                    str_msg = msg_infos[1]\n                    detail = msg_infos[2]\n                    msg_content['data'] = str_msg_all\n                    msg_content['detail'] = detail\n                    msg_content['desc'] = str_msg\n                else:\n                    msg_content['data'] = content\n                if self.DEBUG:\n                    try:\n                        print '    %s[Text] %s' % (msg_prefix, msg_content['data'])\n                    except UnicodeEncodeError:\n                        print '    %s[Text] (illegal text).' % msg_prefix\n        elif mtype == 3:\n            msg_content['type'] = 3\n            msg_content['data'] = self.get_msg_img_url(msg_id)\n            msg_content['img'] = self.session.get(msg_content['data']).content.encode('hex')\n            if self.DEBUG:\n                image = self.get_msg_img(msg_id)\n                print '    %s[Image] %s' % (msg_prefix, image)\n        elif mtype == 34:\n            msg_content['type'] = 4\n            msg_content['data'] = self.get_voice_url(msg_id)\n            msg_content['voice'] = self.session.get(msg_content['data']).content.encode('hex')\n            if self.DEBUG:\n                voice = self.get_voice(msg_id)\n                print '    %s[Voice] %s' % (msg_prefix, voice)\n        elif mtype == 37:\n            msg_content['type'] = 37\n            msg_content['data'] = msg['RecommendInfo']\n            if self.DEBUG:\n                print '    %s[useradd] %s' % (msg_prefix,msg['RecommendInfo']['NickName'])\n        elif mtype == 42:\n            msg_content['type'] = 5\n            info = msg['RecommendInfo']\n            msg_content['data'] = {'nickname': info['NickName'],\n                                   'alias': info['Alias'],\n                                   'province': info['Province'],\n                                   'city': info['City'],\n                                   'gender': ['unknown', 'male', 'female'][info['Sex']]}\n            if self.DEBUG:\n                print '    %s[Recommend]' % msg_prefix\n                print '    -----------------------------'\n                print '    | NickName: %s' % info['NickName']\n                print '    | Alias: %s' % info['Alias']\n                print '    | Local: %s %s' % (info['Province'], info['City'])\n                print '    | Gender: %s' % ['unknown', 'male', 'female'][info['Sex']]\n                print '    -----------------------------'\n        elif mtype == 47:\n            msg_content['type'] = 6\n            msg_content['data'] = self.search_content('cdnurl', content)\n            if self.DEBUG:\n                print '    %s[Animation] %s' % (msg_prefix, msg_content['data'])\n        elif mtype == 49:\n            msg_content['type'] = 7\n            if msg['AppMsgType'] == 3:\n                app_msg_type = 'music'\n            elif msg['AppMsgType'] == 5:\n                app_msg_type = 'link'\n            elif msg['AppMsgType'] == 7:\n                app_msg_type = 'weibo'\n            else:\n                app_msg_type = 'unknown'\n            msg_content['data'] = {'type': app_msg_type,\n                                   'title': msg['FileName'],\n                                   'desc': self.search_content('des', content, 'xml'),\n                                   'url': msg['Url'],\n                                   'from': self.search_content('appname', content, 'xml'),\n                                   'content': msg.get('Content')  # 有的公众号会发一次性3 4条链接一个大图,如果只url那只能获取第一条,content里面有所有的链接\n                                   }\n            if self.DEBUG:\n                print '    %s[Share] %s' % (msg_prefix, app_msg_type)\n                print '    --------------------------'\n                print '    | title: %s' % msg['FileName']\n                print '    | desc: %s' % self.search_content('des', content, 'xml')\n                print '    | link: %s' % msg['Url']\n                print '    | from: %s' % self.search_content('appname', content, 'xml')\n                print '    | content: %s' % (msg.get('content')[:20] if msg.get('content') else \"unknown\")\n                print '    --------------------------'\n\n        elif mtype == 62:\n            msg_content['type'] = 8\n            msg_content['data'] = content\n            if self.DEBUG:\n                print '    %s[Video] Please check on mobiles' % msg_prefix\n        elif mtype == 53:\n            msg_content['type'] = 9\n            msg_content['data'] = content\n            if self.DEBUG:\n                print '    %s[Video Call]' % msg_prefix\n        elif mtype == 10002:\n            msg_content['type'] = 10\n            msg_content['data'] = content\n            if self.DEBUG:\n                print '    %s[Redraw]' % msg_prefix\n        elif mtype == 10000:  # unknown, maybe red packet, or group invite\n            msg_content['type'] = 12\n            msg_content['data'] = msg['Content']\n            if self.DEBUG:\n                print '    [Unknown]'\n        elif mtype == 43:\n            msg_content['type'] = 13\n            msg_content['data'] = self.get_video_url(msg_id)\n            if self.DEBUG:\n                print '    %s[video] %s' % (msg_prefix, msg_content['data'])\n        else:\n            msg_content['type'] = 99\n            msg_content['data'] = content\n            if self.DEBUG:\n                print '    %s[Unknown]' % msg_prefix\n        return msg_content\n\n    def handle_msg(self, r):\n        \"\"\"\n        处理原始微信消息的内部函数\n        msg_type_id:\n            0 -> Init\n            1 -> Self\n            2 -> FileHelper\n            3 -> Group\n            4 -> Contact\n            5 -> Public\n            6 -> Special\n            99 -> Unknown\n        :param r: 原始微信消息\n        \"\"\"\n        for msg in r['AddMsgList']:\n            user = {'id': msg['FromUserName'], 'name': 'unknown'}\n            if msg['MsgType'] == 51 and msg['StatusNotifyCode'] == 4:  # init message\n                msg_type_id = 0\n                user['name'] = 'system'\n                #会获取所有联系人的username 和 wxid，但是会收到3次这个消息，只取第一次\n                if self.is_big_contact and len(self.full_user_name_list) == 0:\n                    self.full_user_name_list = msg['StatusNotifyUserName'].split(\",\")\n                    self.wxid_list = re.search(r\"username&gt;(.*?)&lt;/username\", msg[\"Content\"]).group(1).split(\",\")\n                    with open(os.path.join(self.temp_pwd,'UserName.txt'), 'w') as f:\n                        f.write(msg['StatusNotifyUserName'])\n                    with open(os.path.join(self.temp_pwd,'wxid.txt'), 'w') as f:\n                        f.write(json.dumps(self.wxid_list))\n                    print \"[INFO] Contact list is too big. Now start to fetch member list .\"\n                    #self.get_big_contact()\n\n            elif msg['MsgType'] == 37:  # friend request\n                msg_type_id = 37\n                pass\n                # content = msg['Content']\n                # username = content[content.index('fromusername='): content.index('encryptusername')]\n                # username = username[username.index('\"') + 1: username.rindex('\"')]\n                # print u'[Friend Request]'\n                # print u'       Nickname：' + msg['RecommendInfo']['NickName']\n                # print u'       附加消息：'+msg['RecommendInfo']['Content']\n                # # print u'Ticket：'+msg['RecommendInfo']['Ticket'] # Ticket添加好友时要用\n                # print u'       微信号：'+username #未设置微信号的 腾讯会自动生成一段微信ID 但是无法通过搜索 搜索到此人\n            elif msg['FromUserName'] == self.my_account['UserName']:  # Self\n                msg_type_id = 1\n                user['name'] = 'self'\n            elif msg['ToUserName'] == 'filehelper':  # File Helper\n                msg_type_id = 2\n                user['name'] = 'file_helper'\n            elif msg['FromUserName'][:2] == '@@':  # Group\n                msg_type_id = 3\n                user['name'] = self.get_contact_prefer_name(self.get_contact_name(user['id']))\n            elif self.is_contact(msg['FromUserName']):  # Contact\n                msg_type_id = 4\n                user['name'] = self.get_contact_prefer_name(self.get_contact_name(user['id']))\n            elif self.is_public(msg['FromUserName']):  # Public\n                msg_type_id = 5\n                user['name'] = self.get_contact_prefer_name(self.get_contact_name(user['id']))\n            elif self.is_special(msg['FromUserName']):  # Special\n                msg_type_id = 6\n                user['name'] = self.get_contact_prefer_name(self.get_contact_name(user['id']))\n            else:\n                msg_type_id = 99\n                user['name'] = 'unknown'\n            if not user['name']:\n                user['name'] = 'unknown'\n            user['name'] = HTMLParser.HTMLParser().unescape(user['name'])\n\n            if self.DEBUG and msg_type_id != 0:\n                print u'[MSG] %s:' % user['name']\n            content = self.extract_msg_content(msg_type_id, msg)\n            message = {'msg_type_id': msg_type_id,\n                       'msg_id': msg['MsgId'],\n                       'content': content,\n                       'to_user_id': msg['ToUserName'],\n                       'user': user}\n            self.handle_msg_all(message)\n\n    def schedule(self):\n        \"\"\"\n        做任务型事情的函数，如果需要，可以在子类中覆盖此函数\n        此函数在处理消息的间隙被调用，请不要长时间阻塞此函数\n        \"\"\"\n        pass\n\n    def proc_msg(self):\n        self.test_sync_check()\n        self.status = 'loginsuccess'  #WxbotManage使用\n        while True:\n            if self.status == 'wait4loginout':  #WxbotManage使用\n                return \n            check_time = time.time()\n            try:\n                [retcode, selector] = self.sync_check()\n                # print '[DEBUG] sync_check:', retcode, selector\n                if retcode == '1100':  # 从微信客户端上登出\n                    break\n                elif retcode == '1101':  # 从其它设备上登了网页微信\n                    break\n                elif retcode == '0':\n                    if selector == '2':  # 有新消息\n                        r = self.sync()\n                        if r is not None:\n                            self.handle_msg(r)\n                    elif selector == '3':  # 未知\n                        r = self.sync()\n                        if r is not None:\n                            self.handle_msg(r)\n                    elif selector == '4':  # 通讯录更新\n                        r = self.sync()\n                        if r is not None:\n                            self.get_contact()\n                    elif selector == '6':  # 可能是红包\n                        r = self.sync()\n                        if r is not None:\n                            self.handle_msg(r)\n                    elif selector == '7':  # 在手机上操作了微信\n                        r = self.sync()\n                        if r is not None:\n                            self.handle_msg(r)\n                    elif selector == '0':  # 无事件\n                        pass\n                    else:\n                        print '[DEBUG] sync_check:', retcode, selector\n                        r = self.sync()\n                        if r is not None:\n                            self.handle_msg(r)\n                else:\n                    print '[DEBUG] sync_check:', retcode, selector\n                    time.sleep(10)\n                self.schedule()\n            except:\n                print '[ERROR] Except in proc_msg'\n                print format_exc()\n            check_time = time.time() - check_time\n            if check_time < 0.8:\n                time.sleep(1 - check_time)\n\n    def apply_useradd_requests(self,RecommendInfo):\n        url = self.base_uri + '/webwxverifyuser?r='+str(int(time.time()))+'&lang=zh_CN'\n        params = {\n            \"BaseRequest\": self.base_request,\n            \"Opcode\": 3,\n            \"VerifyUserListSize\": 1,\n            \"VerifyUserList\": [\n                {\n                    \"Value\": RecommendInfo['UserName'],\n                    \"VerifyUserTicket\": RecommendInfo['Ticket']             }\n            ],\n            \"VerifyContent\": \"\",\n            \"SceneListCount\": 1,\n            \"SceneList\": [\n                33\n            ],\n            \"skey\": self.skey\n        }\n        headers = {'content-type': 'application/json; charset=UTF-8'}\n        data = json.dumps(params, ensure_ascii=False).encode('utf8')\n        try:\n            r = self.session.post(url, data=data, headers=headers)\n        except (ConnectionError, ReadTimeout):\n            return False\n        dic = r.json()\n        return dic['BaseResponse']['Ret'] == 0\n\n    def add_groupuser_to_friend_by_uid(self,uid,VerifyContent):\n        \"\"\"\n        主动向群内人员打招呼，提交添加好友请求\n        uid-群内人员得uid   VerifyContent-好友招呼内容\n        慎用此接口！封号后果自负！慎用此接口！封号后果自负！慎用此接口！封号后果自负！\n        \"\"\"\n        if self.is_contact(uid):\n            return True\n        url = self.base_uri + '/webwxverifyuser?r='+str(int(time.time()))+'&lang=zh_CN'\n        params ={\n            \"BaseRequest\": self.base_request,\n            \"Opcode\": 2,\n            \"VerifyUserListSize\": 1,\n            \"VerifyUserList\": [\n                {\n                    \"Value\": uid,\n                    \"VerifyUserTicket\": \"\"\n                }\n            ],\n            \"VerifyContent\": VerifyContent,\n            \"SceneListCount\": 1,\n            \"SceneList\": [\n                33\n            ],\n            \"skey\": self.skey\n        }\n        headers = {'content-type': 'application/json; charset=UTF-8'}\n        data = json.dumps(params, ensure_ascii=False).encode('utf8')\n        try:\n            r = self.session.post(url, data=data, headers=headers)\n        except (ConnectionError, ReadTimeout):\n            return False\n        dic = r.json()\n        return dic['BaseResponse']['Ret'] == 0\n\n    def add_friend_to_group(self,uid,group_name):\n        \"\"\"\n        将好友加入到群聊中\n        \"\"\"\n        gid = ''\n        #通过群名获取群id,群没保存到通讯录中的话无法添加哦\n        for group in self.group_list:\n            if group['NickName'] == group_name:\n                gid = group['UserName']\n        if gid == '':\n            return False\n        #获取群成员数量并判断邀请方式\n        group_num=len(self.group_members[gid])\n        print '[DEBUG] group_name:%s group_num:%s' % (group_name,group_num)\n        #通过群id判断uid是否在群中\n        for user in self.group_members[gid]:\n            if user['UserName'] == uid:\n                #已经在群里面了,不用加了\n                return True\n        if group_num<=100:\n            url = self.base_uri + '/webwxupdatechatroom?fun=addmember&pass_ticket=%s' % self.pass_ticket\n            params ={\n                \"AddMemberList\": uid,\n                \"ChatRoomName\": gid,\n                \"BaseRequest\": self.base_request\n            }\n        else:\n            url = self.base_uri + '/webwxupdatechatroom?fun=invitemember'\n            params ={\n                \"InviteMemberList\": uid,\n                \"ChatRoomName\": gid,\n                \"BaseRequest\": self.base_request\n            }\n        headers = {'content-type': 'application/json; charset=UTF-8'}\n        data = json.dumps(params, ensure_ascii=False).encode('utf8')\n        try:\n            r = self.session.post(url, data=data, headers=headers)\n        except (ConnectionError, ReadTimeout):\n            return False\n        dic = r.json()\n        return dic['BaseResponse']['Ret'] == 0\n\n    def invite_friend_to_group(self,uid,group_name):\n        \"\"\"\n        将好友加入到群中。对人数多的群，需要调用此方法。\n        拉人时，可以先尝试使用add_friend_to_group方法，当调用失败(Ret=1)时，再尝试调用此方法。\n        \"\"\"\n        gid = ''\n        # 通过群名获取群id,群没保存到通讯录中的话无法添加哦\n        for group in self.group_list:\n            if group['NickName'] == group_name:\n                gid = group['UserName']\n        if gid == '':\n            return False\n        # 通过群id判断uid是否在群中\n        for user in self.group_members[gid]:\n            if user['UserName'] == uid:\n                # 已经在群里面了,不用加了\n                return True\n        url = self.base_uri + '/webwxupdatechatroom?fun=invitemember&pass_ticket=%s' % self.pass_ticket\n        params = {\n            \"InviteMemberList\": uid,\n            \"ChatRoomName\": gid,\n            \"BaseRequest\": self.base_request\n        }\n        headers = {'content-type': 'application/json; charset=UTF-8'}\n        data = json.dumps(params, ensure_ascii=False).encode('utf8')\n        try:\n            r = self.session.post(url, data=data, headers=headers)\n        except (ConnectionError, ReadTimeout):\n            return False\n        dic = r.json()\n        return dic['BaseResponse']['Ret'] == 0\n\n    def delete_user_from_group(self,uname,gid):\n        \"\"\"\n        将群用户从群中剔除，只有群管理员有权限\n        \"\"\"\n        uid = \"\"\n        for user in self.group_members[gid]:\n            if user['NickName'] == uname:\n                uid = user['UserName']\n        if uid == \"\":\n            return False\n        url = self.base_uri + '/webwxupdatechatroom?fun=delmember&pass_ticket=%s' % self.pass_ticket\n        params ={\n            \"DelMemberList\": uid,\n            \"ChatRoomName\": gid,\n            \"BaseRequest\": self.base_request\n        }\n        headers = {'content-type': 'application/json; charset=UTF-8'}\n        data = json.dumps(params, ensure_ascii=False).encode('utf8')\n        try:\n            r = self.session.post(url, data=data, headers=headers)\n        except (ConnectionError, ReadTimeout):\n            return False\n        dic = r.json()\n        return dic['BaseResponse']['Ret'] == 0\n\n    def set_group_name(self,gid,gname):\n        \"\"\"\n        设置群聊名称\n        \"\"\"\n        url = self.base_uri + '/webwxupdatechatroom?fun=modtopic&pass_ticket=%s' % self.pass_ticket\n        params ={\n            \"NewTopic\": gname,\n            \"ChatRoomName\": gid,\n            \"BaseRequest\": self.base_request\n        }\n        headers = {'content-type': 'application/json; charset=UTF-8'}\n        data = json.dumps(params, ensure_ascii=False).encode('utf8')\n        try:\n            r = self.session.post(url, data=data, headers=headers)\n        except (ConnectionError, ReadTimeout):\n            return False\n        dic = r.json()\n        return dic['BaseResponse']['Ret'] == 0\n\n    def send_msg_by_uid(self, word, dst='filehelper'):\n        url = self.base_uri + '/webwxsendmsg?pass_ticket=%s' % self.pass_ticket\n        msg_id = str(int(time.time() * 1000)) + str(random.random())[:5].replace('.', '')\n        word = self.to_unicode(word)\n        params = {\n            'BaseRequest': self.base_request,\n            'Msg': {\n                \"Type\": 1,\n                \"Content\": word,\n                \"FromUserName\": self.my_account['UserName'],\n                \"ToUserName\": dst,\n                \"LocalID\": msg_id,\n                \"ClientMsgId\": msg_id\n            }\n        }\n        headers = {'content-type': 'application/json; charset=UTF-8'}\n        data = json.dumps(params, ensure_ascii=False).encode('utf8')\n        try:\n            r = self.session.post(url, data=data, headers=headers)\n        except (ConnectionError, ReadTimeout):\n            return False\n        dic = r.json()\n        return dic['BaseResponse']['Ret'] == 0\n\n    def upload_media(self, fpath, is_img=False):\n        if not os.path.exists(fpath):\n            print '[ERROR] File not exists.'\n            return None\n        url_1 = 'https://file.'+self.base_host+'/cgi-bin/mmwebwx-bin/webwxuploadmedia?f=json'\n        url_2 = 'https://file2.'+self.base_host+'/cgi-bin/mmwebwx-bin/webwxuploadmedia?f=json'\n        flen = str(os.path.getsize(fpath))\n        ftype = mimetypes.guess_type(fpath)[0] or 'application/octet-stream'\n        files = {\n                'id': (None, 'WU_FILE_%s' % str(self.file_index)),\n                'name': (None, os.path.basename(fpath)),\n                'type': (None, ftype),\n                'lastModifiedDate': (None, time.strftime('%m/%d/%Y, %H:%M:%S GMT+0800 (CST)')),\n                'size': (None, flen),\n                'mediatype': (None, 'pic' if is_img else 'doc'),\n                'uploadmediarequest': (None, json.dumps({\n                    'BaseRequest': self.base_request,\n                    'ClientMediaId': int(time.time()),\n                    'TotalLen': flen,\n                    'StartPos': 0,\n                    'DataLen': flen,\n                    'MediaType': 4,\n                    })),\n                'webwx_data_ticket': (None, self.session.cookies['webwx_data_ticket']),\n                'pass_ticket': (None, self.pass_ticket),\n                'filename': (os.path.basename(fpath), open(fpath, 'rb'),ftype.split('/')[1]),\n                }\n        self.file_index += 1\n        try:\n            r = self.session.post(url_1, files=files)\n            if json.loads(r.text)['BaseResponse']['Ret'] != 0:\n                # 当file返回值不为0时则为上传失败，尝试第二服务器上传\n                r = self.session.post(url_2, files=files)\n            if json.loads(r.text)['BaseResponse']['Ret'] != 0:\n                print '[ERROR] Upload media failure.'\n                return None\n            mid = json.loads(r.text)['MediaId']\n            return mid\n        except Exception,e:\n            return None\n\n    def send_file_msg_by_uid(self, fpath, uid):\n        mid = self.upload_media(fpath)\n        if mid is None or not mid:\n            return False\n        url = self.base_uri + '/webwxsendappmsg?fun=async&f=json&pass_ticket=' + self.pass_ticket\n        msg_id = str(int(time.time() * 1000)) + str(random.random())[:5].replace('.', '')\n        data = {\n                'BaseRequest': self.base_request,\n                'Msg': {\n                    'Type': 6,\n                    'Content': (\"<appmsg appid='wxeb7ec651dd0aefa9' sdkver=''><title>%s</title><des></des><action></action><type>6</type><content></content><url></url><lowurl></lowurl><appattach><totallen>%s</totallen><attachid>%s</attachid><fileext>%s</fileext></appattach><extinfo></extinfo></appmsg>\" % (os.path.basename(fpath).encode('utf-8'), str(os.path.getsize(fpath)), mid, fpath.split('.')[-1])).encode('utf8'),\n                    'FromUserName': self.my_account['UserName'],\n                    'ToUserName': uid,\n                    'LocalID': msg_id,\n                    'ClientMsgId': msg_id, }, }\n        try:\n            r = self.session.post(url, data=json.dumps(data))\n            res = json.loads(r.text)\n            if res['BaseResponse']['Ret'] == 0:\n                return True\n            else:\n                return False\n        except Exception,e:\n            return False\n\n    def send_img_msg_by_uid(self, fpath, uid):\n        mid = self.upload_media(fpath, is_img=True)\n        if mid is None:\n            return False\n        url = self.base_uri + '/webwxsendmsgimg?fun=async&f=json'\n        data = {\n                'BaseRequest': self.base_request,\n                'Msg': {\n                    'Type': 3,\n                    'MediaId': mid,\n                    'FromUserName': self.my_account['UserName'],\n                    'ToUserName': uid,\n                    'LocalID': str(time.time() * 1e7),\n                    'ClientMsgId': str(time.time() * 1e7), }, }\n        if fpath[-4:] == '.gif':\n            url = self.base_uri + '/webwxsendemoticon?fun=sys'\n            data['Msg']['Type'] = 47\n            data['Msg']['EmojiFlag'] = 2\n        try:\n            r = self.session.post(url, data=json.dumps(data))\n            res = json.loads(r.text)\n            if res['BaseResponse']['Ret'] == 0:\n                return True\n            else:\n                return False\n        except Exception,e:\n            return False\n\n    def get_user_id(self, name):\n        if name == '':\n            return None\n        name = self.to_unicode(name)\n        for contact in self.contact_list:\n            if 'RemarkName' in contact and contact['RemarkName'] == name:\n                return contact['UserName']\n            elif 'NickName' in contact and contact['NickName'] == name:\n                return contact['UserName']\n            elif 'DisplayName' in contact and contact['DisplayName'] == name:\n                return contact['UserName']\n        for group in self.group_list:\n            if 'RemarkName' in group and group['RemarkName'] == name:\n                return group['UserName']\n            if 'NickName' in group and group['NickName'] == name:\n                return group['UserName']\n            if 'DisplayName' in group and group['DisplayName'] == name:\n                return group['UserName']\n\n        return ''\n\n    def send_msg(self, name, word, isfile=False):\n        uid = self.get_user_id(name)\n        if uid is not None:\n            if isfile:\n                with open(word, 'r') as f:\n                    result = True\n                    for line in f.readlines():\n                        line = line.replace('\\n', '')\n                        print '-> ' + name + ': ' + line\n                        if self.send_msg_by_uid(line, uid):\n                            pass\n                        else:\n                            result = False\n                        time.sleep(1)\n                    return result\n            else:\n                word = self.to_unicode(word)\n                if self.send_msg_by_uid(word, uid):\n                    return True\n                else:\n                    return False\n        else:\n            if self.DEBUG:\n                print '[ERROR] This user does not exist .'\n            return True\n\n    @staticmethod\n    def search_content(key, content, fmat='attr'):\n        if fmat == 'attr':\n            pm = re.search(key + '\\s?=\\s?\"([^\"<]+)\"', content)\n            if pm:\n                return pm.group(1)\n        elif fmat == 'xml':\n            pm = re.search('<{0}>([^<]+)</{0}>'.format(key), content)\n            if pm:\n                return pm.group(1)\n        return 'unknown'\n\n    def run(self):\n        try:\n            self.get_uuid()\n            self.gen_qr_code(os.path.join(self.temp_pwd,'wxqr.png'))\n            print '[INFO] Please use WeChat to scan the QR code .'\n\n            result = self.wait4login()\n            if result != SUCCESS:\n                print '[ERROR] Web WeChat login failed. failed code=%s' % (result,)\n                self.status = 'loginout'\n                return\n\n            if self.login():\n                print '[INFO] Web WeChat login succeed .'\n            else:\n                print '[ERROR] Web WeChat login failed .'\n                self.status = 'loginout'\n                return\n\n            if self.init():\n                print '[INFO] Web WeChat init succeed .'\n            else:\n                print '[INFO] Web WeChat init failed'\n                self.status = 'loginout'\n                return\n            self.status_notify()\n            if self.get_contact():\n                print '[INFO] Get %d contacts' % len(self.contact_list)\n                print '[INFO] Start to process messages .'\n            self.proc_msg()\n            self.status = 'loginout'\n        except Exception,e:\n            print '[ERROR] Web WeChat run failed --> %s'%(e)\n            self.status = 'loginout'\n\n\n    def get_uuid(self):\n        url = 'https://login.weixin.qq.com/jslogin'\n        params = {\n            'appid': 'wx782c26e4c19acffb',\n            'fun': 'new',\n            'lang': 'zh_CN',\n            '_': int(time.time()) * 1000 + random.randint(1, 999),\n        }\n        r = self.session.get(url, params=params)\n        r.encoding = 'utf-8'\n        data = r.text\n        regx = r'window.QRLogin.code = (\\d+); window.QRLogin.uuid = \"(\\S+?)\"'\n        pm = re.search(regx, data)\n        if pm:\n            code = pm.group(1)\n            self.uuid = pm.group(2)\n            return code == '200'\n        return False\n\n    def gen_qr_code(self, qr_file_path):\n        string = 'https://login.weixin.qq.com/l/' + self.uuid\n        qr = pyqrcode.create(string)\n        if self.conf['qr'] == 'png':\n            qr.png(qr_file_path, scale=8)\n            show_image(qr_file_path)\n            # img = Image.open(qr_file_path)\n            # img.show()\n        elif self.conf['qr'] == 'tty':\n            print(qr.terminal(quiet_zone=1))\n\n    def do_request(self, url):\n        r = self.session.get(url)\n        r.encoding = 'utf-8'\n        data = r.text\n        param = re.search(r'window.code=(\\d+);', data)\n        code = param.group(1)\n        return code, data\n\n    def wait4login(self):\n        \"\"\"\n        http comet:\n        tip=1, 等待用户扫描二维码,\n               201: scaned\n               408: timeout\n        tip=0, 等待用户确认登录,\n               200: confirmed\n        \"\"\"\n        LOGIN_TEMPLATE = 'https://login.weixin.qq.com/cgi-bin/mmwebwx-bin/login?tip=%s&uuid=%s&_=%s'\n        tip = 1\n\n        try_later_secs = 1\n        MAX_RETRY_TIMES = 10\n\n        code = UNKONWN\n\n        retry_time = MAX_RETRY_TIMES\n        while retry_time > 0:\n            url = LOGIN_TEMPLATE % (tip, self.uuid, int(time.time()))\n            code, data = self.do_request(url)\n            if code == SCANED:\n                print '[INFO] Please confirm to login .'\n                tip = 0\n            elif code == SUCCESS:  # 确认登录成功\n                param = re.search(r'window.redirect_uri=\"(\\S+?)\";', data)\n                redirect_uri = param.group(1) + '&fun=new'\n                self.redirect_uri = redirect_uri\n                self.base_uri = redirect_uri[:redirect_uri.rfind('/')]\n                temp_host = self.base_uri[8:]\n                self.base_host = temp_host[:temp_host.find(\"/\")]\n                return code\n            elif code == TIMEOUT:\n                print '[ERROR] WeChat login timeout. retry in %s secs later...' % (try_later_secs,)\n\n                tip = 1  # 重置\n                retry_time -= 1\n                time.sleep(try_later_secs)\n            else:\n                print ('[ERROR] WeChat login exception return_code=%s. retry in %s secs later...' %\n                       (code, try_later_secs))\n                tip = 1\n                retry_time -= 1\n                time.sleep(try_later_secs)\n\n        return code\n\n    def login(self):\n        if len(self.redirect_uri) < 4:\n            print '[ERROR] Login failed due to network problem, please try again.'\n            return False\n        r = self.session.get(self.redirect_uri)\n        r.encoding = 'utf-8'\n        data = r.text\n        doc = xml.dom.minidom.parseString(data)\n        root = doc.documentElement\n\n        for node in root.childNodes:\n            if node.nodeName == 'skey':\n                self.skey = node.childNodes[0].data\n            elif node.nodeName == 'wxsid':\n                self.sid = node.childNodes[0].data\n            elif node.nodeName == 'wxuin':\n                self.uin = node.childNodes[0].data\n            elif node.nodeName == 'pass_ticket':\n                self.pass_ticket = node.childNodes[0].data\n\n        if '' in (self.skey, self.sid, self.uin, self.pass_ticket):\n            return False\n\n        self.base_request = {\n            'Uin': self.uin,\n            'Sid': self.sid,\n            'Skey': self.skey,\n            'DeviceID': self.device_id,\n        }\n        return True\n\n    def init(self):\n        url = self.base_uri + '/webwxinit?r=%i&lang=en_US&pass_ticket=%s' % (int(time.time()), self.pass_ticket)\n        params = {\n            'BaseRequest': self.base_request\n        }\n        r = self.session.post(url, data=json.dumps(params))\n        r.encoding = 'utf-8'\n        dic = json.loads(r.text)\n        self.sync_key = dic['SyncKey']\n        self.my_account = dic['User']\n        self.sync_key_str = '|'.join([str(keyVal['Key']) + '_' + str(keyVal['Val'])\n                                      for keyVal in self.sync_key['List']])\n        return dic['BaseResponse']['Ret'] == 0\n\n    def status_notify(self):\n        url = self.base_uri + '/webwxstatusnotify?lang=zh_CN&pass_ticket=%s' % self.pass_ticket\n        self.base_request['Uin'] = int(self.base_request['Uin'])\n        params = {\n            'BaseRequest': self.base_request,\n            \"Code\": 3,\n            \"FromUserName\": self.my_account['UserName'],\n            \"ToUserName\": self.my_account['UserName'],\n            \"ClientMsgId\": int(time.time())\n        }\n        r = self.session.post(url, data=json.dumps(params))\n        r.encoding = 'utf-8'\n        dic = json.loads(r.text)\n        return dic['BaseResponse']['Ret'] == 0\n\n    def test_sync_check(self):\n        for host1 in ['webpush.', 'webpush2.']:\n            self.sync_host = host1+self.base_host\n            try:\n                retcode = self.sync_check()[0]\n            except:\n                retcode = -1\n            if retcode == '0':\n                return True\n        return False\n\n    def sync_check(self):\n        params = {\n            'r': int(time.time()),\n            'sid': self.sid,\n            'uin': self.uin,\n            'skey': self.skey,\n            'deviceid': self.device_id,\n            'synckey': self.sync_key_str,\n            '_': int(time.time()),\n        }\n        url = 'https://' + self.sync_host + '/cgi-bin/mmwebwx-bin/synccheck?' + urllib.urlencode(params)\n        try:\n            r = self.session.get(url, timeout=60)\n            r.encoding = 'utf-8'\n            data = r.text\n            pm = re.search(r'window.synccheck=\\{retcode:\"(\\d+)\",selector:\"(\\d+)\"\\}', data)\n            retcode = pm.group(1)\n            selector = pm.group(2)\n            return [retcode, selector]\n        except:\n            return [-1, -1]\n\n    def sync(self):\n        url = self.base_uri + '/webwxsync?sid=%s&skey=%s&lang=en_US&pass_ticket=%s' \\\n                              % (self.sid, self.skey, self.pass_ticket)\n        params = {\n            'BaseRequest': self.base_request,\n            'SyncKey': self.sync_key,\n            'rr': ~int(time.time())\n        }\n        try:\n            r = self.session.post(url, data=json.dumps(params), timeout=60)\n            r.encoding = 'utf-8'\n            dic = json.loads(r.text)\n            if dic['BaseResponse']['Ret'] == 0:\n                self.sync_key = dic['SyncCheckKey']\n                self.sync_key_str = '|'.join([str(keyVal['Key']) + '_' + str(keyVal['Val'])\n                                              for keyVal in self.sync_key['List']])\n            return dic\n        except:\n            return None\n\n    def get_icon(self, uid, gid=None):\n        \"\"\"\n        获取联系人或者群聊成员头像\n        :param uid: 联系人id\n        :param gid: 群id，如果为非None获取群中成员头像，如果为None则获取联系人头像\n        \"\"\"\n        if gid is None:\n            url = self.base_uri + '/webwxgeticon?username=%s&skey=%s' % (uid, self.skey)\n        else:\n            url = self.base_uri + '/webwxgeticon?username=%s&skey=%s&chatroomid=%s' % (\n            uid, self.skey, self.encry_chat_room_id_list[gid])\n        r = self.session.get(url)\n        data = r.content\n        fn = 'icon_' + uid + '.jpg'\n        with open(os.path.join(self.temp_pwd,fn), 'wb') as f:\n            f.write(data)\n        return fn\n\n    def get_head_img(self, uid):\n        \"\"\"\n        获取群头像\n        :param uid: 群uid\n        \"\"\"\n        url = self.base_uri + '/webwxgetheadimg?username=%s&skey=%s' % (uid, self.skey)\n        r = self.session.get(url)\n        data = r.content\n        fn = 'head_' + uid + '.jpg'\n        with open(os.path.join(self.temp_pwd,fn), 'wb') as f:\n            f.write(data)\n        return fn\n\n    def get_msg_img_url(self, msgid):\n        return self.base_uri + '/webwxgetmsgimg?MsgID=%s&skey=%s' % (msgid, self.skey)\n\n    def get_msg_img(self, msgid):\n        \"\"\"\n        获取图片消息，下载图片到本地\n        :param msgid: 消息id\n        :return: 保存的本地图片文件路径\n        \"\"\"\n        url = self.base_uri + '/webwxgetmsgimg?MsgID=%s&skey=%s' % (msgid, self.skey)\n        r = self.session.get(url)\n        data = r.content\n        fn = 'img_' + msgid + '.jpg'\n        with open(os.path.join(self.temp_pwd,fn), 'wb') as f:\n            f.write(data)\n        return fn\n\n    def get_voice_url(self, msgid):\n        return self.base_uri + '/webwxgetvoice?msgid=%s&skey=%s' % (msgid, self.skey)\n\n    def get_voice(self, msgid):\n        \"\"\"\n        获取语音消息，下载语音到本地\n        :param msgid: 语音消息id\n        :return: 保存的本地语音文件路径\n        \"\"\"\n        url = self.base_uri + '/webwxgetvoice?msgid=%s&skey=%s' % (msgid, self.skey)\n        r = self.session.get(url)\n        data = r.content\n        fn = 'voice_' + msgid + '.mp3'\n        with open(os.path.join(self.temp_pwd,fn), 'wb') as f:\n            f.write(data)\n        return fn\n\n    def get_video_url(self, msgid):\n        return self.base_uri + '/webwxgetvideo?msgid=%s&skey=%s' % (msgid, self.skey)\n\n    def get_video(self, msgid):\n        \"\"\"\n        获取视频消息，下载视频到本地\n        :param msgid: 视频消息id\n        :return: 保存的本地视频文件路径\n        \"\"\"\n        url = self.base_uri + '/webwxgetvideo?msgid=%s&skey=%s' % (msgid, self.skey)\n        headers = {'Range': 'bytes=0-'}\n        r = self.session.get(url, headers=headers)\n        data = r.content\n        fn = 'video_' + msgid + '.mp4'\n        with open(os.path.join(self.temp_pwd,fn), 'wb') as f:\n            f.write(data)\n        return fn\n\n    def set_remarkname(self,uid,remarkname):#设置联系人的备注名\n        url = self.base_uri + '/webwxoplog?lang=zh_CN&pass_ticket=%s' \\\n                              % (self.pass_ticket)\n        remarkname = self.to_unicode(remarkname)\n        params = {\n            'BaseRequest': self.base_request,\n            'CmdId': 2,\n            'RemarkName': remarkname,\n            'UserName': uid\n        }\n        try:\n            r = self.session.post(url, data=json.dumps(params), timeout=60)\n            r.encoding = 'utf-8'\n            dic = json.loads(r.text)\n            return dic['BaseResponse']['ErrMsg']\n        except:\n            return None\n"
        }
      ]
    }
  ]
}