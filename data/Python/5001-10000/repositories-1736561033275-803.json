{
  "metadata": {
    "timestamp": 1736561033275,
    "page": 803,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjgxMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "containers/podman-compose",
      "stars": 5184,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".codespellignore",
          "type": "blob",
          "size": 0.0087890625,
          "content": "assertIn\n"
        },
        {
          "name": ".codespellrc",
          "type": "blob",
          "size": 0.1279296875,
          "content": "[codespell]\nskip = .git,*.pdf,*.svg,requirements.txt,test-requirements.txt\n# poped - loved variable name\nignore-words-list = poped\n"
        },
        {
          "name": ".coveragerc",
          "type": "blob",
          "size": 0.0205078125,
          "content": "[run] \nparallel=True\n"
        },
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.26171875,
          "content": "root = true\n\n[*]\nindent_style = space\nindent_size = tab\ntab_width = 4\nend_of_line = lf\ncharset = utf-8\ntrim_trailing_whitespace = true\ninsert_final_newline = true\nmax_line_length = 100\n\n[*.{yml,yaml}]\nindent_style = space\nindent_size = 2\n\n[*.py]\nindent_style = space\n\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 1.228515625,
          "content": "# Byte-compiled / optimized / DLL files\n__pycache__/\n*.py[cod]\n*$py.class\n\n# C extensions\n*.so\n\n# Distribution / packaging\n.Python\nbuild/\ndevelop-eggs/\ndist/\ndownloads/\neggs/\n.eggs/\nlib/\nlib64/\nparts/\nsdist/\nvar/\nwheels/\n.idea/\n*.egg-info/\n.installed.cfg\n*.egg\nMANIFEST\n\n# PyInstaller\n#  Usually these files are written by a python script from a template\n#  before PyInstaller builds the exe, so as to inject date/other infos into it.\n*.manifest\n*.spec\n\n# Installer logs\npip-log.txt\npip-delete-this-directory.txt\n\n# Unit test / coverage reports\nhtmlcov/\n.tox/\n.coverage\n.coverage.*\n.cache\nnosetests.xml\ncoverage.xml\n*.cover\n.hypothesis/\n.pytest_cache/\ntest-compose.yaml\ntest-compose-?.yaml\n\n# Translations\n*.mo\n*.pot\n\n# Django stuff:\n*.log\nlocal_settings.py\ndb.sqlite3\n\n# Flask stuff:\ninstance/\n.webassets-cache\n\n# Scrapy stuff:\n.scrapy\n\n# Sphinx documentation\ndocs/_build/\n\n# PyBuilder\ntarget/\n\n# Jupyter Notebook\n.ipynb_checkpoints\n\n# pyenv\n.python-version\n\n# celery beat schedule file\ncelerybeat-schedule\n\n# SageMath parsed files\n*.sage.py\n\n# Environments\n.env\n.venv\nenv/\nvenv/\nENV/\nenv.bak/\nvenv.bak/\n\n# Spyder project settings\n.spyderproject\n.spyproject\n\n# Rope project settings\n.ropeproject\n\n# mkdocs documentation\n/site\n\n# mypy\n.mypy_cache/\n\n\n.vscode\n"
        },
        {
          "name": ".pre-commit-config.yaml",
          "type": "blob",
          "size": 1.0048828125,
          "content": "repos:\n  - repo: https://github.com/psf/black\n    rev: 23.3.0\n    hooks:\n      - id: black\n        # It is recommended to specify the latest version of Python\n        # supported by your project here, or alternatively use\n        # pre-commit's default_language_version, see\n        # https://pre-commit.com/#top_level-default_language_version\n        language_version: python3.10\n        types: [python]\n        args: [\n          \"--check\",  # Don't apply changes automatically\n        ]\n  - repo: https://github.com/pycqa/flake8\n    rev: 6.0.0\n    hooks:\n      - id: flake8\n        types: [python]\n  - repo: local\n    hooks:\n      - id: pylint\n        name: pylint\n        entry: pylint\n        language: system\n        types: [python]\n        args:\n          [\n            \"-rn\", # Only display messages\n            \"-sn\", # Don't display the score\n            \"--rcfile=.pylintrc\", # Link to your config file\n          ]\n  - repo: https://github.com/codespell-project/codespell\n    rev: v2.2.5\n    hooks:\n    - id: codespell\n"
        },
        {
          "name": ".pylintrc",
          "type": "blob",
          "size": 0.9765625,
          "content": "[MESSAGES CONTROL]\n# C0111 missing-docstring: missing-class-docstring, missing-function-docstring, missing-method-docstring, missing-module-docstrin\n# consider-using-with: we need it for color formatter pipe\ndisable=too-many-lines,too-many-branches,too-many-locals,too-many-statements,too-many-arguments,too-many-instance-attributes,fixme,multiple-statements,missing-docstring,line-too-long,consider-using-f-string,consider-using-with,unnecessary-lambda-assignment\n# allow _ for ignored variables\n# allow generic names like a,b,c and i,j,k,l,m,n and x,y,z\n# allow k,v for key/value\n# allow e for exceptions, it for iterator, ix for index\n# allow ip for ip address\n# allow w,h for width, height\n# allow op for operation/operator/opcode\n# allow t, t0, t1, t2, and t3 for time\n# allow dt for delta time\n# allow db for database\n# allow ls for list\n# allow p for pipe\n# allow ex for examples, exists ..etc\ngood-names=_,a,b,c,dt,db,e,f,fn,fd,i,j,k,v,kv,kw,l,m,n,ls,t,t0,t1,t2,t3,w,h,x,y,z,it,ix,ip,op,p,ex\n"
        },
        {
          "name": "CODE-OF-CONDUCT.md",
          "type": "blob",
          "size": 0.2001953125,
          "content": "## The Podman Compose Project Community Code of Conduct\n\nThe Podman Compose project follows the [Containers Community Code of Conduct](https://github.com/containers/common/blob/master/CODE-OF-CONDUCT.md).\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 4.220703125,
          "content": "# Contributing to podman-compose\n\n## Who can contribute?\n\n- Users that found a bug,\n- Users that want to propose new functionalities or enhancements,\n- Users that want to help other users to troubleshoot their environments,\n- Developers that want to fix bugs,\n- Developers that want to implement new functionalities or enhancements.\n\n## Development environment setup\n\nNote: Some steps are OPTIONAL but all are RECOMMENDED.\n\n1. Fork the project repository and clone it:\n\n   ```shell\n   $ git clone https://github.com/USERNAME/podman-compose.git\n   $ cd podman-compose\n   ```\n\n2. (OPTIONAL) Create a Python virtual environment. Example using\n   [virtualenv wrapper](https://virtualenvwrapper.readthedocs.io/en/latest/):\n\n    ```shell\n    $ mkvirtualenv podman-compose\n    ```\n\n3. Install the project runtime and development requirements:\n\n   ```shell\n   $ pip install '.[devel]'\n   ```\n\n4. (OPTIONAL) Install `pre-commit` git hook scripts\n   (https://pre-commit.com/#3-install-the-git-hook-scripts):\n\n   ```shell\n   $ pre-commit install\n   ```\n\n5. Create a new branch, develop and add tests when possible.\n6. Run linting and testing before committing code. Ensure all the hooks are passing.\n\n   ```shell\n   $ pre-commit run --all-files\n   ```\n\n7. Run code coverage:\n\n    ```shell\n    $ coverage run --source podman_compose -m unittest discover tests/unit\n    $ python3 -m unittest discover tests/integration\n    $ coverage combine\n    $ coverage report\n    $ coverage html\n    ```\n\n8. Commit your code to your fork's branch.\n   - Make sure you include a `Signed-off-by` message in your commits.\n     Read [this guide](https://github.com/containers/common/blob/main/CONTRIBUTING.md#sign-your-prs)\n     to learn how to sign your commits.\n   - In the commit message, reference the Issue ID that your code fixes and a brief description of\n     the changes.\n     Example: `Fixes #516: Allow empty network`\n9. Open a pull request to `containers/podman-compose` and wait for a maintainer to review your work.\n\n## Adding new commands\n\nTo add a command, you need to add a function that is decorated with `@cmd_run`.\n\nThe decorated function must be declared `async` and should accept two arguments: The compose\ninstance and the command-specific arguments (resulted from the Python's `argparse` package).\n\nIn this function, you can run Podman (e.g. `await compose.podman.run(['inspect', 'something'])`),\naccess `compose.pods`, `compose.containers` etc.\n\nHere is an example:\n\n```python\n@cmd_run(podman_compose, 'build', 'build images defined in the stack')\nasync def compose_build(compose, args):\n    await compose.podman.run(['build', 'something'])\n```\n\n## Command arguments parsing\n\nTo add arguments to be parsed by a command, you need to add a function that is decorated with\n`@cmd_parse` which accepts the compose instance and the command's name (as a string list or as a\nsingle string).\n\nThe decorated function should accept a single argument: An instance of `argparse`.\n\nIn this function, you can call `parser.add_argument()` to add a new argument to the command.\n\nNote you can add such a function multiple times.\n\nHere is an example:\n\n```python\n@cmd_parse(podman_compose, 'build')\ndef compose_build_parse(parser):\n    parser.add_argument(\"--pull\",\n        help=\"attempt to pull a newer version of the image\", action='store_true')\n    parser.add_argument(\"--pull-always\",\n        help=\"Attempt to pull a newer version of the image, \"\n             \"raise an error even if the image is present locally.\",\n        action='store_true')\n```\n\nNOTE: `@cmd_parse` should be after `@cmd_run`.\n\n## Calling a command from another one\n\nIf you need to call `podman-compose down` from `podman-compose up`, do something like:\n\n```python\n@cmd_run(podman_compose, 'up', 'up desc')\nasync def compose_up(compose, args):\n    await compose.commands['down'](compose, args)\n    # or\n    await compose.commands['down'](argparse.Namespace(foo=123))\n```\n\n## Missing Commands (help needed)\n\n```\n  bundle             Generate a Docker bundle from the Compose file\n  create             Create services\n  events             Receive real time events from containers\n  images             List images\n  rm                 Remove stopped containers\n  scale              Set number of containers for a service\n  top                Display the running processes\n```\n"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 0.6669921875,
          "content": "# Use a base image with necessary build tools\nFROM python:3.11-slim AS builder\n\n# Install required packages for building\nRUN apt-get update && apt-get install -y \\\n    gcc \\\n    musl-dev \\\n    build-essential \\\n    python3-dev \\\n    && apt-get clean \\\n    && rm -rf /var/lib/apt/lists/*\n\n# Set the working directory\nWORKDIR /app\n\n# Copy the application code\nCOPY . .\n\n# Install PyInstaller\nRUN pip install pyinstaller\nRUN pip install -r requirements.txt\n\n# Create a binary with PyInstaller\nRUN pyinstaller --onefile --clean podman_compose.py\n\n# Create /result dir in case it is not mounted\nRUN mkdir -p /result\n\n# Export binary\nRUN cp /app/dist/podman_compose /result/podman-compose\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 17.66796875,
          "content": "                    GNU GENERAL PUBLIC LICENSE\n                       Version 2, June 1991\n\n Copyright (C) 1989, 1991 Free Software Foundation, Inc.,\n 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n                            Preamble\n\n  The licenses for most software are designed to take away your\nfreedom to share and change it.  By contrast, the GNU General Public\nLicense is intended to guarantee your freedom to share and change free\nsoftware--to make sure the software is free for all its users.  This\nGeneral Public License applies to most of the Free Software\nFoundation's software and to any other program whose authors commit to\nusing it.  (Some other Free Software Foundation software is covered by\nthe GNU Lesser General Public License instead.)  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthis service if you wish), that you receive source code or can get it\nif you want it, that you can change the software or use pieces of it\nin new free programs; and that you know you can do these things.\n\n  To protect your rights, we need to make restrictions that forbid\nanyone to deny you these rights or to ask you to surrender the rights.\nThese restrictions translate to certain responsibilities for you if you\ndistribute copies of the software, or if you modify it.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must give the recipients all the rights that\nyou have.  You must make sure that they, too, receive or can get the\nsource code.  And you must show them these terms so they know their\nrights.\n\n  We protect your rights with two steps: (1) copyright the software, and\n(2) offer you this license which gives you legal permission to copy,\ndistribute and/or modify the software.\n\n  Also, for each author's protection and ours, we want to make certain\nthat everyone understands that there is no warranty for this free\nsoftware.  If the software is modified by someone else and passed on, we\nwant its recipients to know that what they have is not the original, so\nthat any problems introduced by others will not reflect on the original\nauthors' reputations.\n\n  Finally, any free program is threatened constantly by software\npatents.  We wish to avoid the danger that redistributors of a free\nprogram will individually obtain patent licenses, in effect making the\nprogram proprietary.  To prevent this, we have made it clear that any\npatent must be licensed for everyone's free use or not licensed at all.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n                    GNU GENERAL PUBLIC LICENSE\n   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\n\n  0. This License applies to any program or other work which contains\na notice placed by the copyright holder saying it may be distributed\nunder the terms of this General Public License.  The \"Program\", below,\nrefers to any such program or work, and a \"work based on the Program\"\nmeans either the Program or any derivative work under copyright law:\nthat is to say, a work containing the Program or a portion of it,\neither verbatim or with modifications and/or translated into another\nlanguage.  (Hereinafter, translation is included without limitation in\nthe term \"modification\".)  Each licensee is addressed as \"you\".\n\nActivities other than copying, distribution and modification are not\ncovered by this License; they are outside its scope.  The act of\nrunning the Program is not restricted, and the output from the Program\nis covered only if its contents constitute a work based on the\nProgram (independent of having been made by running the Program).\nWhether that is true depends on what the Program does.\n\n  1. You may copy and distribute verbatim copies of the Program's\nsource code as you receive it, in any medium, provided that you\nconspicuously and appropriately publish on each copy an appropriate\ncopyright notice and disclaimer of warranty; keep intact all the\nnotices that refer to this License and to the absence of any warranty;\nand give any other recipients of the Program a copy of this License\nalong with the Program.\n\nYou may charge a fee for the physical act of transferring a copy, and\nyou may at your option offer warranty protection in exchange for a fee.\n\n  2. You may modify your copy or copies of the Program or any portion\nof it, thus forming a work based on the Program, and copy and\ndistribute such modifications or work under the terms of Section 1\nabove, provided that you also meet all of these conditions:\n\n    a) You must cause the modified files to carry prominent notices\n    stating that you changed the files and the date of any change.\n\n    b) You must cause any work that you distribute or publish, that in\n    whole or in part contains or is derived from the Program or any\n    part thereof, to be licensed as a whole at no charge to all third\n    parties under the terms of this License.\n\n    c) If the modified program normally reads commands interactively\n    when run, you must cause it, when started running for such\n    interactive use in the most ordinary way, to print or display an\n    announcement including an appropriate copyright notice and a\n    notice that there is no warranty (or else, saying that you provide\n    a warranty) and that users may redistribute the program under\n    these conditions, and telling the user how to view a copy of this\n    License.  (Exception: if the Program itself is interactive but\n    does not normally print such an announcement, your work based on\n    the Program is not required to print an announcement.)\n\nThese requirements apply to the modified work as a whole.  If\nidentifiable sections of that work are not derived from the Program,\nand can be reasonably considered independent and separate works in\nthemselves, then this License, and its terms, do not apply to those\nsections when you distribute them as separate works.  But when you\ndistribute the same sections as part of a whole which is a work based\non the Program, the distribution of the whole must be on the terms of\nthis License, whose permissions for other licensees extend to the\nentire whole, and thus to each and every part regardless of who wrote it.\n\nThus, it is not the intent of this section to claim rights or contest\nyour rights to work written entirely by you; rather, the intent is to\nexercise the right to control the distribution of derivative or\ncollective works based on the Program.\n\nIn addition, mere aggregation of another work not based on the Program\nwith the Program (or with a work based on the Program) on a volume of\na storage or distribution medium does not bring the other work under\nthe scope of this License.\n\n  3. You may copy and distribute the Program (or a work based on it,\nunder Section 2) in object code or executable form under the terms of\nSections 1 and 2 above provided that you also do one of the following:\n\n    a) Accompany it with the complete corresponding machine-readable\n    source code, which must be distributed under the terms of Sections\n    1 and 2 above on a medium customarily used for software interchange; or,\n\n    b) Accompany it with a written offer, valid for at least three\n    years, to give any third party, for a charge no more than your\n    cost of physically performing source distribution, a complete\n    machine-readable copy of the corresponding source code, to be\n    distributed under the terms of Sections 1 and 2 above on a medium\n    customarily used for software interchange; or,\n\n    c) Accompany it with the information you received as to the offer\n    to distribute corresponding source code.  (This alternative is\n    allowed only for noncommercial distribution and only if you\n    received the program in object code or executable form with such\n    an offer, in accord with Subsection b above.)\n\nThe source code for a work means the preferred form of the work for\nmaking modifications to it.  For an executable work, complete source\ncode means all the source code for all modules it contains, plus any\nassociated interface definition files, plus the scripts used to\ncontrol compilation and installation of the executable.  However, as a\nspecial exception, the source code distributed need not include\nanything that is normally distributed (in either source or binary\nform) with the major components (compiler, kernel, and so on) of the\noperating system on which the executable runs, unless that component\nitself accompanies the executable.\n\nIf distribution of executable or object code is made by offering\naccess to copy from a designated place, then offering equivalent\naccess to copy the source code from the same place counts as\ndistribution of the source code, even though third parties are not\ncompelled to copy the source along with the object code.\n\n  4. You may not copy, modify, sublicense, or distribute the Program\nexcept as expressly provided under this License.  Any attempt\notherwise to copy, modify, sublicense or distribute the Program is\nvoid, and will automatically terminate your rights under this License.\nHowever, parties who have received copies, or rights, from you under\nthis License will not have their licenses terminated so long as such\nparties remain in full compliance.\n\n  5. You are not required to accept this License, since you have not\nsigned it.  However, nothing else grants you permission to modify or\ndistribute the Program or its derivative works.  These actions are\nprohibited by law if you do not accept this License.  Therefore, by\nmodifying or distributing the Program (or any work based on the\nProgram), you indicate your acceptance of this License to do so, and\nall its terms and conditions for copying, distributing or modifying\nthe Program or works based on it.\n\n  6. Each time you redistribute the Program (or any work based on the\nProgram), the recipient automatically receives a license from the\noriginal licensor to copy, distribute or modify the Program subject to\nthese terms and conditions.  You may not impose any further\nrestrictions on the recipients' exercise of the rights granted herein.\nYou are not responsible for enforcing compliance by third parties to\nthis License.\n\n  7. If, as a consequence of a court judgment or allegation of patent\ninfringement or for any other reason (not limited to patent issues),\nconditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot\ndistribute so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you\nmay not distribute the Program at all.  For example, if a patent\nlicense would not permit royalty-free redistribution of the Program by\nall those who receive copies directly or indirectly through you, then\nthe only way you could satisfy both it and this License would be to\nrefrain entirely from distribution of the Program.\n\nIf any portion of this section is held invalid or unenforceable under\nany particular circumstance, the balance of the section is intended to\napply and the section as a whole is intended to apply in other\ncircumstances.\n\nIt is not the purpose of this section to induce you to infringe any\npatents or other property right claims or to contest validity of any\nsuch claims; this section has the sole purpose of protecting the\nintegrity of the free software distribution system, which is\nimplemented by public license practices.  Many people have made\ngenerous contributions to the wide range of software distributed\nthrough that system in reliance on consistent application of that\nsystem; it is up to the author/donor to decide if he or she is willing\nto distribute software through any other system and a licensee cannot\nimpose that choice.\n\nThis section is intended to make thoroughly clear what is believed to\nbe a consequence of the rest of this License.\n\n  8. If the distribution and/or use of the Program is restricted in\ncertain countries either by patents or by copyrighted interfaces, the\noriginal copyright holder who places the Program under this License\nmay add an explicit geographical distribution limitation excluding\nthose countries, so that distribution is permitted only in or among\ncountries not thus excluded.  In such case, this License incorporates\nthe limitation as if written in the body of this License.\n\n  9. The Free Software Foundation may publish revised and/or new versions\nof the General Public License from time to time.  Such new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\nEach version is given a distinguishing version number.  If the Program\nspecifies a version number of this License which applies to it and \"any\nlater version\", you have the option of following the terms and conditions\neither of that version or of any later version published by the Free\nSoftware Foundation.  If the Program does not specify a version number of\nthis License, you may choose any version ever published by the Free Software\nFoundation.\n\n  10. If you wish to incorporate parts of the Program into other free\nprograms whose distribution conditions are different, write to the author\nto ask for permission.  For software which is copyrighted by the Free\nSoftware Foundation, write to the Free Software Foundation; we sometimes\nmake exceptions for this.  Our decision will be guided by the two goals\nof preserving the free status of all derivatives of our free software and\nof promoting the sharing and reuse of software generally.\n\n                            NO WARRANTY\n\n  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY\nFOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN\nOTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES\nPROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED\nOR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS\nTO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE\nPROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,\nREPAIR OR CORRECTION.\n\n  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR\nREDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,\nINCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING\nOUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED\nTO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY\nYOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER\nPROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGES.\n\n                     END OF TERMS AND CONDITIONS\n\n            How to Apply These Terms to Your New Programs\n\n  If you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these terms.\n\n  To do so, attach the following notices to the program.  It is safest\nto attach them to the start of each source file to most effectively\nconvey the exclusion of warranty; and each file should have at least\nthe \"copyright\" line and a pointer to where the full notice is found.\n\n    <one line to give the program's name and a brief idea of what it does.>\n    Copyright (C) <year>  <name of author>\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\nAlso add information on how to contact you by electronic and paper mail.\n\nIf the program is interactive, make it output a short notice like this\nwhen it starts in an interactive mode:\n\n    Gnomovision version 69, Copyright (C) year name of author\n    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n    This is free software, and you are welcome to redistribute it\n    under certain conditions; type `show c' for details.\n\nThe hypothetical commands `show w' and `show c' should show the appropriate\nparts of the General Public License.  Of course, the commands you use may\nbe called something other than `show w' and `show c'; they could even be\nmouse-clicks or menu items--whatever suits your program.\n\nYou should also get your employer (if you work as a programmer) or your\nschool, if any, to sign a \"copyright disclaimer\" for the program, if\nnecessary.  Here is a sample; alter the names:\n\n  Yoyodyne, Inc., hereby disclaims all copyright interest in the program\n  `Gnomovision' (which makes passes at compilers) written by James Hacker.\n\n  <signature of Ty Coon>, 1 April 1989\n  Ty Coon, President of Vice\n\nThis General Public License does not permit incorporating your program into\nproprietary programs.  If your program is a subroutine library, you may\nconsider it more useful to permit linking proprietary applications with the\nlibrary.  If this is what you want to do, use the GNU Lesser General\nPublic License instead of this License.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 4.744140625,
          "content": "# Podman Compose\n## [![Tests](https://github.com/containers/podman-compose/actions/workflows/test.yml/badge.svg)](https://github.com/containers/podman-compose/actions/workflows/test.yml)\n\nAn implementation of [Compose Spec](https://compose-spec.io/) with [Podman](https://podman.io/) backend.\nThis project focuses on:\n\n* rootless\n* daemon-less process model, we directly execute podman, no running daemon.\n\nThis project only depends on:\n\n* `podman`\n* [podman dnsname plugin](https://github.com/containers/dnsname): It is usually found in\n  the `podman-plugins` or `podman-dnsname` distro packages, those packages are not pulled\n  by default and you need to install them. This allows containers to be able to resolve\n  each other if they are on the same CNI network. This is not necessary when podman is using\n  netavark as a network backend.\n* Python3\n* [PyYAML](https://pyyaml.org/)\n* [python-dotenv](https://pypi.org/project/python-dotenv/)\n\nAnd it's formed as a single Python file script that you can drop into your PATH and run.\n\n## References:\n\n* [spec.md](https://github.com/compose-spec/compose-spec/blob/master/spec.md)\n* [docker-compose compose-file-v3](https://docs.docker.com/compose/compose-file/compose-file-v3/)\n* [docker-compose compose-file-v2](https://docs.docker.com/compose/compose-file/compose-file-v2/)\n\n## Alternatives\n\nAs in [this article](https://fedoramagazine.org/use-docker-compose-with-podman-to-orchestrate-containers-on-fedora/) you can setup a `podman.socket` and use unmodified `docker-compose` that talks to that socket but in this case you lose the process-model (ex. `docker-compose build` will send a possibly large context tarball to the daemon)\n\nFor production-like single-machine containerized environment consider\n\n- [k3s](https://k3s.io) | [k3s github](https://github.com/rancher/k3s)\n- [MiniKube](https://minikube.sigs.k8s.io/)\n\nFor the real thing (multi-node clusters) check any production\nOpenShift/Kubernetes distribution like [OKD](https://www.okd.io/).\n\n## Versions\n\nIf you have legacy version of `podman` (before 3.1.0) you might need to stick with legacy `podman-compose` `0.1.x` branch.\nThe legacy branch 0.1.x uses mappings and workarounds to compensate for rootless limitations.\n\nModern podman versions (>=3.4) do not have those limitations, and thus you can use latest and stable 1.x branch.\n\nIf you are upgrading from `podman-compose` version `0.1.x` then we no longer have global option `-t` to set mapping type\nlike `hostnet`. If you desire that behavior, pass it the standard way like `network_mode: host` in the YAML.\n\n\n## Installation\n\n### Pip\n\nInstall the latest stable version from PyPI:\n\n```bash\npip3 install podman-compose\n```\n\npass `--user` to install inside regular user home without being root.\n\nOr latest development version from GitHub:\n\n```bash\npip3 install https://github.com/containers/podman-compose/archive/main.tar.gz\n```\n\n### Homebrew\n\n```bash\nbrew install podman-compose\n```\n\n### Generate binary using docker/podman locally\nThis script will download the repo, generate the binary using [this Dockerfile](https://github.com/containers/podman-compose/blob/main/Dockerfile), and place the binary in the directory where you called this script.\n```bash\nsh -c \"$(curl -sSL https://raw.githubusercontent.com/containers/podman-compose/main/scripts/download_and_build_podman-compose.sh)\"\n```\n\n### Manual\n\n```bash\ncurl -o /usr/local/bin/podman-compose https://raw.githubusercontent.com/containers/podman-compose/main/podman_compose.py\nchmod +x /usr/local/bin/podman-compose\n```\n\nor inside your home\n\n```bash\ncurl -o ~/.local/bin/podman-compose https://raw.githubusercontent.com/containers/podman-compose/main/podman_compose.py\nchmod +x ~/.local/bin/podman-compose\n```\n\nor install from Fedora (starting from f31) repositories:\n\n```bash\nsudo dnf install podman-compose\n```\n\n## Basic Usage\n\nWe have included fully functional sample stacks inside `examples/` directory.\nYou can get more examples from [awesome-compose](https://github.com/docker/awesome-compose).\n\nA quick example would be\n\n```bash\ncd examples/busybox\npodman-compose --help\npodman-compose up --help\npodman-compose up\n```\n\nA more rich example can be found in [examples/awx3](examples/awx3)\nwhich have\n\n- A Postgres Database\n- RabbitMQ server\n- MemCached server\n- a django web server\n- a django tasks\n\n\nWhen testing the `AWX3` example, if you got errors, just wait for db migrations to end.\nThere is also AWX 17.1.0\n\n## Tests\n\nInside `tests/` directory we have many useless docker-compose stacks\nthat are meant to test as many cases as we can to make sure we are compatible\n\n### Unit tests with unittest\nrun a unittest with following command\n\n```shell\npython3 -m unittest discover tests/unit\n```\n\n# Contributing guide\n\nIf you are a user or a developer and want to contribute please check the [CONTRIBUTING](CONTRIBUTING.md) section\n"
        },
        {
          "name": "RELEASING.md",
          "type": "blob",
          "size": 1.2578125,
          "content": "Creating a release\n==================\n\nThis file contains instructions for maintainers on how to release new versions of podman-compose.\n\nStep 1: Initialize variables for subsequent steps\n-------------------------------------------------\n\n```\nexport VERSION=1.2.3\n```\n\nStep 2: Release notes PR\n------------------------\n\nOpen a new branch (e.g. `release`) and run the following:\n\n```\n./scripts/make_release_notes.sh $VERSION\n```\n\nThis collects the release notes using the `towncrier` tool and then commits the result.\nThis step is done as a PR so that CI can check for spelling errors and similar issues.\n\nCertain file names are not properly supported by the `towncrier` tool and it ignores them.\nCheck `newsfragments` directory for any forgotten release notes\n\nStep 3: Merge the release notes PR\n----------------------------------\n\nStep 4: Perform actual release\n------------------------------\n\nPull the merge commit created on the `main` branch during the step 2.\nThen run:\n\n```\n./scripts/make_release.sh $VERSION\n```\n\nThis will create release commit, tag and push everything.\n\nStep 5: Create a release on Github\n----------------------------------\n\nThe release notes must be added manually by drafting a release on the GitHub UI at\nhttps://github.com/containers/podman-compose/releases.\n"
        },
        {
          "name": "SECURITY.md",
          "type": "blob",
          "size": 0.2470703125,
          "content": "## Security and Disclosure Information Policy for the Podman Compose Project\n\nThe Podman Compose Project follows the [Security and Disclosure Information Policy](https://github.com/containers/common/blob/master/SECURITY.md) for the Containers Projects.\n"
        },
        {
          "name": "completion",
          "type": "tree",
          "content": null
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "newsfragments",
          "type": "tree",
          "content": null
        },
        {
          "name": "podman_compose.py",
          "type": "blob",
          "size": 128.5439453125,
          "content": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n# SPDX-License-Identifier: GPL-2.0\n# https://docs.docker.com/compose/compose-file/#service-configuration-reference\n# https://docs.docker.com/samples/\n# https://docs.docker.com/compose/gettingstarted/\n# https://docs.docker.com/compose/django/\n# https://docs.docker.com/compose/wordpress/\n# TODO: podman pod logs --color -n -f pod_testlogs\nfrom __future__ import annotations\n\nimport argparse\nimport asyncio.exceptions\nimport asyncio.subprocess\nimport getpass\nimport glob\nimport hashlib\nimport itertools\nimport json\nimport logging\nimport os\nimport random\nimport re\nimport shlex\nimport signal\nimport subprocess\nimport sys\nfrom asyncio import Task\nfrom enum import Enum\n\ntry:\n    from shlex import quote as cmd_quote\nexcept ImportError:\n    from pipes import quote as cmd_quote  # pylint: disable=deprecated-module\n\n# import fnmatch\n# fnmatch.fnmatchcase(env, \"*_HOST\")\n\nimport yaml\nfrom dotenv import dotenv_values\n\n__version__ = \"1.3.0\"\n\nscript = os.path.realpath(sys.argv[0])\n\n# helper functions\n\n\ndef is_list(list_object):\n    return (\n        not isinstance(list_object, str)\n        and not isinstance(list_object, dict)\n        and hasattr(list_object, \"__iter__\")\n    )\n\n\n# identity filter\ndef filteri(a):\n    return filter(lambda i: i, a)\n\n\ndef try_int(i, fallback=None):\n    try:\n        return int(i)\n    except ValueError:\n        pass\n    except TypeError:\n        pass\n    return fallback\n\n\ndef try_float(i, fallback=None):\n    try:\n        return float(i)\n    except ValueError:\n        pass\n    except TypeError:\n        pass\n    return fallback\n\n\nlog = logging.getLogger(__name__)\n\n\ndir_re = re.compile(r\"^[~/\\.]\")\npropagation_re = re.compile(\n    \"^(?:z|Z|O|U|r?shared|r?slave|r?private|r?unbindable|r?bind|(?:no)?(?:exec|dev|suid))$\"\n)\nnorm_re = re.compile(\"[^-_a-z0-9]\")\nnum_split_re = re.compile(r\"(\\d+|\\D+)\")\n\nPODMAN_CMDS = (\n    \"pull\",\n    \"push\",\n    \"build\",\n    \"inspect\",\n    \"run\",\n    \"start\",\n    \"stop\",\n    \"rm\",\n    \"volume\",\n)\n\nt_re = re.compile(r\"^(?:(\\d+)[m:])?(?:(\\d+(?:\\.\\d+)?)s?)?$\")\nSTOP_GRACE_PERIOD = \"10\"\n\n\ndef str_to_seconds(txt):\n    if not txt:\n        return None\n    if isinstance(txt, (int, float)):\n        return txt\n    match = t_re.match(txt.strip())\n    if not match:\n        return None\n    mins, sec = match[1], match[2]\n    mins = int(mins) if mins else 0\n    sec = float(sec) if sec else 0\n    # \"podman stop\" takes only int\n    # Error: invalid argument \"3.0\" for \"-t, --time\" flag: strconv.ParseUint: parsing \"3.0\":\n    # invalid syntax\n    return int(mins * 60.0 + sec)\n\n\ndef ver_as_list(a):\n    return [try_int(i, i) for i in num_split_re.findall(a)]\n\n\ndef strverscmp_lt(a, b):\n    a_ls = ver_as_list(a or \"\")\n    b_ls = ver_as_list(b or \"\")\n    return a_ls < b_ls\n\n\ndef parse_short_mount(mount_str, basedir):\n    mount_a = mount_str.split(\":\")\n    mount_opt_dict = {}\n    mount_opt = None\n    if len(mount_a) == 1:\n        # Anonymous: Just specify a path and let the engine creates the volume\n        # - /var/lib/mysql\n        mount_src, mount_dst = None, mount_str\n    elif len(mount_a) == 2:\n        mount_src, mount_dst = mount_a\n        # dest must start with / like /foo:/var/lib/mysql\n        # otherwise it's option like /var/lib/mysql:rw\n        if not mount_dst.startswith(\"/\"):\n            mount_dst, mount_opt = mount_a\n            mount_src = None\n    elif len(mount_a) == 3:\n        mount_src, mount_dst, mount_opt = mount_a\n    else:\n        raise ValueError(\"could not parse mount \" + mount_str)\n    if mount_src and dir_re.match(mount_src):\n        # Specify an absolute path mapping\n        # - /opt/data:/var/lib/mysql\n        # Path on the host, relative to the Compose file\n        # - ./cache:/tmp/cache\n        # User-relative path\n        # - ~/configs:/etc/configs/:ro\n        mount_type = \"bind\"\n        if os.name != 'nt' or (os.name == 'nt' and \".sock\" not in mount_src):\n            mount_src = os.path.abspath(os.path.join(basedir, os.path.expanduser(mount_src)))\n    else:\n        # Named volume\n        # - datavolume:/var/lib/mysql\n        mount_type = \"volume\"\n    mount_opts = filteri((mount_opt or \"\").split(\",\"))\n    propagation_opts = []\n    for opt in mount_opts:\n        if opt == \"ro\":\n            mount_opt_dict[\"read_only\"] = True\n        elif opt == \"rw\":\n            mount_opt_dict[\"read_only\"] = False\n        elif opt in (\"consistent\", \"delegated\", \"cached\"):\n            mount_opt_dict[\"consistency\"] = opt\n        elif propagation_re.match(opt):\n            propagation_opts.append(opt)\n        else:\n            # TODO: ignore\n            raise ValueError(\"unknown mount option \" + opt)\n    mount_opt_dict[\"bind\"] = {\"propagation\": \",\".join(propagation_opts)}\n    return {\n        \"type\": mount_type,\n        \"source\": mount_src,\n        \"target\": mount_dst,\n        **mount_opt_dict,\n    }\n\n\n# NOTE: if a named volume is used but not defined it\n# gives ERROR: Named volume \"abc\" is used in service \"xyz\"\n#   but no declaration was found in the volumes section.\n# unless it's anonymous-volume\n\n\ndef fix_mount_dict(compose, mount_dict, srv_name):\n    \"\"\"\n    in-place fix mount dictionary to:\n    - define _vol to be the corresponding top-level volume\n    - if name is missing it would be source prefixed with project\n    - if no source it would be generated\n    \"\"\"\n    # if already applied nothing todo\n    if \"_vol\" in mount_dict:\n        return mount_dict\n    if mount_dict[\"type\"] == \"volume\":\n        vols = compose.vols\n        source = mount_dict.get(\"source\")\n        vol = (vols.get(source, {}) or {}) if source else {}\n        name = vol.get(\"name\")\n        mount_dict[\"_vol\"] = vol\n        # handle anonymous or implied volume\n        if not source:\n            # missing source\n            vol[\"name\"] = \"_\".join([\n                compose.project_name,\n                srv_name,\n                hashlib.sha256(mount_dict[\"target\"].encode(\"utf-8\")).hexdigest(),\n            ])\n        elif not name:\n            external = vol.get(\"external\")\n            if isinstance(external, dict):\n                vol[\"name\"] = external.get(\"name\", f\"{source}\")\n            elif external:\n                vol[\"name\"] = f\"{source}\"\n            else:\n                vol[\"name\"] = f\"{compose.project_name}_{source}\"\n    return mount_dict\n\n\n# docker and docker-compose support subset of bash variable substitution\n# https://docs.docker.com/compose/compose-file/#variable-substitution\n# https://docs.docker.com/compose/env-file/\n# https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html\n# $VARIABLE\n# ${VARIABLE}\n# ${VARIABLE:-default} default if not set or empty\n# ${VARIABLE-default} default if not set\n# ${VARIABLE:?err} raise error if not set or empty\n# ${VARIABLE?err} raise error if not set\n# $$ means $\n\nvar_re = re.compile(\n    r\"\"\"\n    \\$(?:\n        (?P<escaped>\\$) |\n        (?P<named>[_a-zA-Z][_a-zA-Z0-9]*) |\n        (?:{\n            (?P<braced>[_a-zA-Z][_a-zA-Z0-9]*)\n            (?:(?P<empty>:)?(?:\n                (?:-(?P<default>[^}]*)) |\n                (?:\\?(?P<err>[^}]*))\n            ))?\n        })\n    )\n\"\"\",\n    re.VERBOSE,\n)\n\n\ndef rec_subs(value, subs_dict):\n    \"\"\"\n    do bash-like substitution in value and if list of dictionary do that recursively\n    \"\"\"\n    if isinstance(value, dict):\n        if 'environment' in value and isinstance(value['environment'], dict):\n            # Load service's environment variables\n            subs_dict = subs_dict.copy()\n            svc_envs = {k: v for k, v in value['environment'].items() if k not in subs_dict}\n            # we need to add `svc_envs` to the `subs_dict` so that it can evaluate the\n            # service environment that reference to another service environment.\n            subs_dict.update(svc_envs)\n            svc_envs = rec_subs(svc_envs, subs_dict)\n            subs_dict.update(svc_envs)\n\n        value = {k: rec_subs(v, subs_dict) for k, v in value.items()}\n    elif isinstance(value, str):\n\n        def convert(m):\n            if m.group(\"escaped\") is not None:\n                return \"$\"\n            name = m.group(\"named\") or m.group(\"braced\")\n            value = subs_dict.get(name)\n            if value == \"\" and m.group(\"empty\"):\n                value = None\n            if value is not None:\n                return str(value)\n            if m.group(\"err\") is not None:\n                raise RuntimeError(m.group(\"err\"))\n            return m.group(\"default\") or \"\"\n\n        value = var_re.sub(convert, value)\n    elif hasattr(value, \"__iter__\"):\n        value = [rec_subs(i, subs_dict) for i in value]\n    return value\n\n\ndef norm_as_list(src):\n    \"\"\"\n    given a dictionary {key1:value1, key2: None} or list\n    return a list of [\"key1=value1\", \"key2\"]\n    \"\"\"\n    dst: list[str]\n    if src is None:\n        dst = []\n    elif isinstance(src, dict):\n        dst = [(f\"{k}={v}\" if v is not None else k) for k, v in src.items()]\n    elif is_list(src):\n        dst = list(src)\n    else:\n        dst = [src]\n    return dst\n\n\ndef norm_as_dict(src):\n    \"\"\"\n    given a list [\"key1=value1\", \"key2\"]\n    return a dictionary {key1:value1, key2: None}\n    \"\"\"\n    if src is None:\n        dst = {}\n    elif isinstance(src, dict):\n        dst = dict(src)\n    elif is_list(src):\n        dst = [i.split(\"=\", 1) for i in src if i]\n        dst = [(a if len(a) == 2 else (a[0], None)) for a in dst]\n        dst = dict(dst)\n    elif isinstance(src, str):\n        key, value = src.split(\"=\", 1) if \"=\" in src else (src, None)\n        dst = {key: value}\n    else:\n        raise ValueError(\"dictionary or iterable is expected\")\n    return dst\n\n\ndef norm_ulimit(inner_value):\n    if isinstance(inner_value, dict):\n        if not inner_value.keys() & {\"soft\", \"hard\"}:\n            raise ValueError(\"expected at least one soft or hard limit\")\n        soft = inner_value.get(\"soft\", inner_value.get(\"hard\"))\n        hard = inner_value.get(\"hard\", inner_value.get(\"soft\"))\n        return f\"{soft}:{hard}\"\n    if is_list(inner_value):\n        return norm_ulimit(norm_as_dict(inner_value))\n    # if int or string return as is\n    return inner_value\n\n\ndef default_network_name_for_project(compose, net, is_ext):\n    if is_ext:\n        return net\n\n    default_net_name_compat = compose.x_podman.get(\"default_net_name_compat\", False)\n    if default_net_name_compat is True:\n        return f\"{compose.project_name.replace('-', '')}_{net}\"\n    return f\"{compose.project_name}_{net}\"\n\n\n# def tr_identity(project_name, given_containers):\n#    pod_name = f'pod_{project_name}'\n#    pod = dict(name=pod_name)\n#    containers = []\n#    for cnt in given_containers:\n#        containers.append(dict(cnt, pod=pod_name))\n#    return [pod], containers\n\n\ndef transform(args, project_name, given_containers):\n    if not args.in_pod_bool:\n        pod_name = None\n        pods = []\n    else:\n        pod_name = f\"pod_{project_name}\"\n        pod = {\"name\": pod_name}\n        pods = [pod]\n    containers = []\n    for cnt in given_containers:\n        containers.append(dict(cnt, pod=pod_name))\n    return pods, containers\n\n\nasync def assert_volume(compose, mount_dict):\n    \"\"\"\n    inspect volume to get directory\n    create volume if needed\n    \"\"\"\n    vol = mount_dict.get(\"_vol\")\n    if mount_dict[\"type\"] == \"bind\":\n        basedir = os.path.realpath(compose.dirname)\n        mount_src = mount_dict[\"source\"]\n        mount_src = os.path.realpath(os.path.join(basedir, os.path.expanduser(mount_src)))\n        if not os.path.exists(mount_src):\n            try:\n                os.makedirs(mount_src, exist_ok=True)\n            except OSError:\n                pass\n        return\n    if mount_dict[\"type\"] != \"volume\" or not vol or not vol.get(\"name\"):\n        return\n    vol_name = vol[\"name\"]\n    is_ext = vol.get(\"external\")\n    log.debug(\"podman volume inspect %s || podman volume create %s\", vol_name, vol_name)\n    # TODO: might move to using \"volume list\"\n    # podman volume list --format '{{.Name}}\\t{{.MountPoint}}' \\\n    #     -f 'label=io.podman.compose.project=HERE'\n    try:\n        _ = (await compose.podman.output([], \"volume\", [\"inspect\", vol_name])).decode(\"utf-8\")\n    except subprocess.CalledProcessError as e:\n        if is_ext:\n            raise RuntimeError(f\"External volume [{vol_name}] does not exists\") from e\n        labels = vol.get(\"labels\", [])\n        args = [\n            \"create\",\n            \"--label\",\n            f\"io.podman.compose.project={compose.project_name}\",\n            \"--label\",\n            f\"com.docker.compose.project={compose.project_name}\",\n        ]\n        for item in norm_as_list(labels):\n            args.extend([\"--label\", item])\n        driver = vol.get(\"driver\")\n        if driver:\n            args.extend([\"--driver\", driver])\n        driver_opts = vol.get(\"driver_opts\", {})\n        for opt, value in driver_opts.items():\n            args.extend([\"--opt\", f\"{opt}={value}\"])\n        args.append(vol_name)\n        await compose.podman.output([], \"volume\", args)\n        _ = (await compose.podman.output([], \"volume\", [\"inspect\", vol_name])).decode(\"utf-8\")\n\n\ndef mount_desc_to_mount_args(compose, mount_desc, srv_name, cnt_name):  # pylint: disable=unused-argument\n    mount_type = mount_desc.get(\"type\")\n    vol = mount_desc.get(\"_vol\") if mount_type == \"volume\" else None\n    source = vol[\"name\"] if vol else mount_desc.get(\"source\")\n    target = mount_desc[\"target\"]\n    opts = []\n    if mount_desc.get(mount_type, None):\n        # TODO: we might need to add mount_dict[mount_type][\"propagation\"] = \"z\"\n        mount_prop = mount_desc.get(mount_type, {}).get(\"propagation\")\n        if mount_prop:\n            opts.append(f\"{mount_type}-propagation={mount_prop}\")\n    if mount_desc.get(\"read_only\", False):\n        opts.append(\"ro\")\n    if mount_type == \"tmpfs\":\n        tmpfs_opts = mount_desc.get(\"tmpfs\", {})\n        tmpfs_size = tmpfs_opts.get(\"size\")\n        if tmpfs_size:\n            opts.append(f\"tmpfs-size={tmpfs_size}\")\n        tmpfs_mode = tmpfs_opts.get(\"mode\")\n        if tmpfs_mode:\n            opts.append(f\"tmpfs-mode={tmpfs_mode}\")\n    if mount_type == \"bind\":\n        bind_opts = mount_desc.get(\"bind\", {})\n        selinux = bind_opts.get(\"selinux\")\n        if selinux is not None:\n            opts.append(selinux)\n    opts = \",\".join(opts)\n    if mount_type == \"bind\":\n        return f\"type=bind,source={source},destination={target},{opts}\".rstrip(\",\")\n    if mount_type == \"volume\":\n        return f\"type=volume,source={source},destination={target},{opts}\".rstrip(\",\")\n    if mount_type == \"tmpfs\":\n        return f\"type=tmpfs,destination={target},{opts}\".rstrip(\",\")\n    raise ValueError(\"unknown mount type:\" + mount_type)\n\n\ndef ulimit_to_ulimit_args(ulimit, podman_args):\n    if ulimit is not None:\n        # ulimit can be a single value, i.e. ulimit: host\n        if isinstance(ulimit, str):\n            podman_args.extend([\"--ulimit\", ulimit])\n        # or a dictionary or list:\n        else:\n            ulimit = norm_as_dict(ulimit)\n            ulimit = [\n                \"{}={}\".format(ulimit_key, norm_ulimit(inner_value))\n                for ulimit_key, inner_value in ulimit.items()\n            ]\n            for i in ulimit:\n                podman_args.extend([\"--ulimit\", i])\n\n\ndef container_to_ulimit_args(cnt, podman_args):\n    ulimit_to_ulimit_args(cnt.get(\"ulimits\", []), podman_args)\n\n\ndef container_to_ulimit_build_args(cnt, podman_args):\n    build = cnt.get(\"build\")\n\n    if build is not None:\n        ulimit_to_ulimit_args(build.get(\"ulimits\", []), podman_args)\n\n\ndef mount_desc_to_volume_args(compose, mount_desc, srv_name, cnt_name):  # pylint: disable=unused-argument\n    mount_type = mount_desc[\"type\"]\n    if mount_type not in (\"bind\", \"volume\"):\n        raise ValueError(\"unknown mount type:\" + mount_type)\n    vol = mount_desc.get(\"_vol\") if mount_type == \"volume\" else None\n    source = vol[\"name\"] if vol else mount_desc.get(\"source\")\n    if not source:\n        raise ValueError(f\"missing mount source for {mount_type} on {srv_name}\")\n    target = mount_desc[\"target\"]\n    opts = []\n\n    propagations = set(filteri(mount_desc.get(mount_type, {}).get(\"propagation\", \"\").split(\",\")))\n    if mount_type != \"bind\":\n        propagations.update(filteri(mount_desc.get(\"bind\", {}).get(\"propagation\", \"\").split(\",\")))\n    opts.extend(propagations)\n    # --volume, -v[=[[SOURCE-VOLUME|HOST-DIR:]CONTAINER-DIR[:OPTIONS]]]\n    # [rw|ro]\n    # [z|Z]\n    # [[r]shared|[r]slave|[r]private]|[r]unbindable\n    # [[r]bind]\n    # [noexec|exec]\n    # [nodev|dev]\n    # [nosuid|suid]\n    # [O]\n    # [U]\n    read_only = mount_desc.get(\"read_only\")\n    if read_only is not None:\n        opts.append(\"ro\" if read_only else \"rw\")\n    if mount_type == \"bind\":\n        bind_opts = mount_desc.get(\"bind\", {})\n        selinux = bind_opts.get(\"selinux\")\n        if selinux is not None:\n            opts.append(selinux)\n\n    args = f\"{source}:{target}\"\n    if opts:\n        args += \":\" + \",\".join(opts)\n    return args\n\n\ndef get_mnt_dict(compose, cnt, volume):\n    srv_name = cnt[\"_service\"]\n    basedir = compose.dirname\n    if isinstance(volume, str):\n        volume = parse_short_mount(volume, basedir)\n    return fix_mount_dict(compose, volume, srv_name)\n\n\nasync def get_mount_args(compose, cnt, volume):\n    volume = get_mnt_dict(compose, cnt, volume)\n    srv_name = cnt[\"_service\"]\n    mount_type = volume[\"type\"]\n    await assert_volume(compose, volume)\n    if compose.prefer_volume_over_mount:\n        if mount_type == \"tmpfs\":\n            # TODO: --tmpfs /tmp:rw,size=787448k,mode=1777\n            args = volume[\"target\"]\n            tmpfs_opts = volume.get(\"tmpfs\", {})\n            opts = []\n            size = tmpfs_opts.get(\"size\")\n            if size:\n                opts.append(f\"size={size}\")\n            mode = tmpfs_opts.get(\"mode\")\n            if mode:\n                opts.append(f\"mode={mode}\")\n            if opts:\n                args += \":\" + \",\".join(opts)\n            return [\"--tmpfs\", args]\n        args = mount_desc_to_volume_args(compose, volume, srv_name, cnt[\"name\"])\n        return [\"-v\", args]\n    args = mount_desc_to_mount_args(compose, volume, srv_name, cnt[\"name\"])\n    return [\"--mount\", args]\n\n\ndef get_secret_args(compose, cnt, secret, podman_is_building=False):\n    \"\"\"\n    podman_is_building: True if we are preparing arguments for an invocation of \"podman build\"\n                        False if we are preparing for something else like \"podman run\"\n    \"\"\"\n    secret_name = secret if isinstance(secret, str) else secret.get(\"source\")\n    if not secret_name or secret_name not in compose.declared_secrets.keys():\n        raise ValueError(f'ERROR: undeclared secret: \"{secret}\", service: {cnt[\"_service\"]}')\n    declared_secret = compose.declared_secrets[secret_name]\n\n    source_file = declared_secret.get(\"file\")\n    dest_file = \"\"\n    secret_opts = \"\"\n\n    secret_target = None\n    secret_uid = None\n    secret_gid = None\n    secret_mode = None\n    secret_type = None\n    if isinstance(secret, dict):\n        secret_target = secret.get(\"target\")\n        secret_uid = secret.get(\"uid\")\n        secret_gid = secret.get(\"gid\")\n        secret_mode = secret.get(\"mode\")\n        secret_type = secret.get(\"type\")\n\n    if source_file:\n        # assemble path for source file first, because we need it for all cases\n        basedir = compose.dirname\n        source_file = os.path.realpath(os.path.join(basedir, os.path.expanduser(source_file)))\n\n        if podman_is_building:\n            # pass file secrets to \"podman build\" with param --secret\n            if not secret_target:\n                secret_id = secret_name\n            elif \"/\" in secret_target:\n                raise ValueError(\n                    f'ERROR: Build secret \"{secret_name}\" has invalid target \"{secret_target}\". '\n                    + \"(Expected plain filename without directory as target.)\"\n                )\n            else:\n                secret_id = secret_target\n            volume_ref = [\"--secret\", f\"id={secret_id},src={source_file}\"]\n        else:\n            # pass file secrets to \"podman run\" as volumes\n            if not secret_target:\n                dest_file = \"/run/secrets/{}\".format(secret_name)\n            elif not secret_target.startswith(\"/\"):\n                sec = secret_target if secret_target else secret_name\n                dest_file = f\"/run/secrets/{sec}\"\n            else:\n                dest_file = secret_target\n            volume_ref = [\"--volume\", f\"{source_file}:{dest_file}:ro,rprivate,rbind\"]\n\n        if secret_uid or secret_gid or secret_mode:\n            sec = secret_target if secret_target else secret_name\n            log.warning(\n                \"WARNING: Service %s uses secret %s with uid, gid, or mode.\"\n                + \" These fields are not supported by this implementation of the Compose file\",\n                cnt[\"_service\"],\n                sec,\n            )\n        return volume_ref\n    # v3.5 and up added external flag, earlier the spec\n    # only required a name to be specified.\n    # docker-compose does not support external secrets outside of swarm mode.\n    # However accessing these via podman is trivial\n    # since these commands are directly translated to\n    # podman-create commands, albeit we can only support a 1:1 mapping\n    # at the moment\n    if declared_secret.get(\"external\", False) or declared_secret.get(\"name\"):\n        secret_opts += f\",uid={secret_uid}\" if secret_uid else \"\"\n        secret_opts += f\",gid={secret_gid}\" if secret_gid else \"\"\n        secret_opts += f\",mode={secret_mode}\" if secret_mode else \"\"\n        secret_opts += f\",type={secret_type}\" if secret_type else \"\"\n        secret_opts += f\",target={secret_target}\" if secret_target and secret_type == \"env\" else \"\"\n        # The target option is only valid for type=env,\n        # which in an ideal world would work\n        # for type=mount as well.\n        # having a custom name for the external secret\n        # has the same problem as well\n        ext_name = declared_secret.get(\"name\")\n        err_str = (\n            'ERROR: Custom name/target reference \"{}\" '\n            'for mounted external secret \"{}\" is not supported'\n        )\n        if ext_name and ext_name != secret_name:\n            raise ValueError(err_str.format(secret_name, ext_name))\n        if secret_target and secret_target != secret_name and secret_type != 'env':\n            raise ValueError(err_str.format(secret_target, secret_name))\n        if secret_target and secret_type != 'env':\n            log.warning(\n                'WARNING: Service \"%s\" uses target: \"%s\" for secret: \"%s\".'\n                + \" That is un-supported and a no-op and is ignored.\",\n                cnt[\"_service\"],\n                secret_target,\n                secret_name,\n            )\n        return [\"--secret\", \"{}{}\".format(secret_name, secret_opts)]\n\n    raise ValueError(\n        'ERROR: unparsable secret: \"{}\", service: \"{}\"'.format(secret_name, cnt[\"_service\"])\n    )\n\n\ndef container_to_res_args(cnt, podman_args):\n    container_to_cpu_res_args(cnt, podman_args)\n    container_to_gpu_res_args(cnt, podman_args)\n\n\ndef container_to_gpu_res_args(cnt, podman_args):\n    # https://docs.docker.com/compose/gpu-support/\n    # https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/latest/cdi-support.html\n\n    deploy = cnt.get(\"deploy\", {})\n    res = deploy.get(\"resources\", {})\n    reservations = res.get(\"reservations\", {})\n    devices = reservations.get(\"devices\", [])\n    gpu_on = False\n    for device in devices:\n        driver = device.get(\"driver\")\n        if driver is None:\n            continue\n\n        capabilities = device.get(\"capabilities\")\n        if capabilities is None:\n            continue\n\n        if driver != \"nvidia\" or \"gpu\" not in capabilities:\n            continue\n\n        count = device.get(\"count\", \"all\")\n        device_ids = device.get(\"device_ids\", \"all\")\n        if device_ids != \"all\" and len(device_ids) > 0:\n            for device_id in device_ids:\n                podman_args.extend((\n                    \"--device\",\n                    f\"nvidia.com/gpu={device_id}\",\n                ))\n            gpu_on = True\n            continue\n\n        if count != \"all\":\n            for device_id in range(count):\n                podman_args.extend((\n                    \"--device\",\n                    f\"nvidia.com/gpu={device_id}\",\n                ))\n            gpu_on = True\n            continue\n\n        podman_args.extend((\n            \"--device\",\n            \"nvidia.com/gpu=all\",\n        ))\n        gpu_on = True\n\n    if gpu_on:\n        podman_args.append(\"--security-opt=label=disable\")\n\n\ndef container_to_cpu_res_args(cnt, podman_args):\n    # v2: https://docs.docker.com/compose/compose-file/compose-file-v2/#cpu-and-other-resources\n    # cpus, cpu_shares, mem_limit, mem_reservation\n    cpus_limit_v2 = try_float(cnt.get(\"cpus\"), None)\n    cpu_shares_v2 = try_int(cnt.get(\"cpu_shares\"), None)\n    mem_limit_v2 = cnt.get(\"mem_limit\")\n    mem_res_v2 = cnt.get(\"mem_reservation\")\n    # v3: https://docs.docker.com/compose/compose-file/compose-file-v3/#resources\n    # spec: https://github.com/compose-spec/compose-spec/blob/master/deploy.md#resources\n    # deploy.resources.{limits,reservations}.{cpus, memory}\n    deploy = cnt.get(\"deploy\", {})\n    res = deploy.get(\"resources\", {})\n    limits = res.get(\"limits\", {})\n    cpus_limit_v3 = try_float(limits.get(\"cpus\"), None)\n    mem_limit_v3 = limits.get(\"memory\")\n    reservations = res.get(\"reservations\", {})\n    # cpus_res_v3 = try_float(reservations.get('cpus', None), None)\n    mem_res_v3 = reservations.get(\"memory\")\n    # add args\n    cpus = cpus_limit_v3 or cpus_limit_v2\n    if cpus:\n        podman_args.extend((\n            \"--cpus\",\n            str(cpus),\n        ))\n    if cpu_shares_v2:\n        podman_args.extend((\n            \"--cpu-shares\",\n            str(cpu_shares_v2),\n        ))\n    mem = mem_limit_v3 or mem_limit_v2\n    if mem:\n        podman_args.extend((\n            \"-m\",\n            str(mem).lower(),\n        ))\n    mem_res = mem_res_v3 or mem_res_v2\n    if mem_res:\n        podman_args.extend((\n            \"--memory-reservation\",\n            str(mem_res).lower(),\n        ))\n\n\ndef port_dict_to_str(port_desc):\n    # NOTE: `mode: host|ingress` is ignored\n    cnt_port = port_desc.get(\"target\")\n    published = port_desc.get(\"published\", \"\")\n    host_ip = port_desc.get(\"host_ip\")\n    protocol = port_desc.get(\"protocol\", \"tcp\")\n    if not cnt_port:\n        raise ValueError(\"target container port must be specified\")\n    if host_ip:\n        ret = f\"{host_ip}:{published}:{cnt_port}\"\n    else:\n        ret = f\"{published}:{cnt_port}\" if published else f\"{cnt_port}\"\n    if protocol != \"tcp\":\n        ret += f\"/{protocol}\"\n    return ret\n\n\ndef norm_ports(ports_in):\n    if not ports_in:\n        ports_in = []\n    if isinstance(ports_in, str):\n        ports_in = [ports_in]\n    ports_out = []\n    for port in ports_in:\n        if isinstance(port, dict):\n            port = port_dict_to_str(port)\n        elif isinstance(port, int):\n            port = str(port)\n        elif not isinstance(port, str):\n            raise TypeError(\"port should be either string or dict\")\n        ports_out.append(port)\n    return ports_out\n\n\ndef get_network_create_args(net_desc, proj_name, net_name):\n    args = [\n        \"create\",\n        \"--label\",\n        f\"io.podman.compose.project={proj_name}\",\n        \"--label\",\n        f\"com.docker.compose.project={proj_name}\",\n    ]\n    # TODO: add more options here, like dns, ipv6, etc.\n    labels = net_desc.get(\"labels\", [])\n    for item in norm_as_list(labels):\n        args.extend([\"--label\", item])\n    if net_desc.get(\"internal\"):\n        args.append(\"--internal\")\n    driver = net_desc.get(\"driver\")\n    if driver:\n        args.extend((\"--driver\", driver))\n    driver_opts = net_desc.get(\"driver_opts\", {})\n    for key, value in driver_opts.items():\n        args.extend((\"--opt\", f\"{key}={value}\"))\n    ipam = net_desc.get(\"ipam\", {})\n    ipam_driver = ipam.get(\"driver\")\n    if ipam_driver and ipam_driver != \"default\":\n        args.extend((\"--ipam-driver\", ipam_driver))\n    ipam_config_ls = ipam.get(\"config\", [])\n    if net_desc.get(\"enable_ipv6\"):\n        args.append(\"--ipv6\")\n\n    if isinstance(ipam_config_ls, dict):\n        ipam_config_ls = [ipam_config_ls]\n    for ipam_config in ipam_config_ls:\n        subnet = ipam_config.get(\"subnet\")\n        ip_range = ipam_config.get(\"ip_range\")\n        gateway = ipam_config.get(\"gateway\")\n        if subnet:\n            args.extend((\"--subnet\", subnet))\n        if ip_range:\n            args.extend((\"--ip-range\", ip_range))\n        if gateway:\n            args.extend((\"--gateway\", gateway))\n    args.append(net_name)\n\n    return args\n\n\nasync def assert_cnt_nets(compose, cnt):\n    \"\"\"\n    create missing networks\n    \"\"\"\n    net = cnt.get(\"network_mode\")\n    if net:\n        return\n\n    cnt_nets = cnt.get(\"networks\")\n    if cnt_nets and isinstance(cnt_nets, dict):\n        cnt_nets = list(cnt_nets.keys())\n    cnt_nets = norm_as_list(cnt_nets or compose.default_net)\n    for net in cnt_nets:\n        net_desc = compose.networks[net] or {}\n        is_ext = net_desc.get(\"external\")\n        ext_desc = is_ext if isinstance(is_ext, dict) else {}\n        default_net_name = default_network_name_for_project(compose, net, is_ext)\n        net_name = ext_desc.get(\"name\") or net_desc.get(\"name\") or default_net_name\n        try:\n            await compose.podman.output([], \"network\", [\"exists\", net_name])\n        except subprocess.CalledProcessError as e:\n            if is_ext:\n                raise RuntimeError(f\"External network [{net_name}] does not exists\") from e\n            args = get_network_create_args(net_desc, compose.project_name, net_name)\n            await compose.podman.output([], \"network\", args)\n            await compose.podman.output([], \"network\", [\"exists\", net_name])\n\n\ndef get_net_args_from_network_mode(compose, cnt):\n    net_args = []\n    net = cnt.get(\"network_mode\")\n    service_name = cnt[\"service_name\"]\n\n    if \"networks\" in cnt:\n        raise ValueError(\n            f\"networks and network_mode must not be present in the same service [{service_name}]\"\n        )\n\n    if net == \"none\":\n        net_args.append(\"--network=none\")\n    elif net == \"host\":\n        net_args.append(f\"--network={net}\")\n    elif net.startswith(\"slirp4netns\"):  # Note: podman-specific network mode\n        net_args.append(f\"--network={net}\")\n    elif net == \"private\":  # Note: podman-specific network mode\n        net_args.append(\"--network=private\")\n    elif net.startswith(\"pasta\"):  # Note: podman-specific network mode\n        net_args.append(f\"--network={net}\")\n    elif net.startswith(\"ns:\"):  # Note: podman-specific network mode\n        net_args.append(f\"--network={net}\")\n    elif net.startswith(\"service:\"):\n        other_srv = net.split(\":\", 1)[1].strip()\n        other_cnt = compose.container_names_by_service[other_srv][0]\n        net_args.append(f\"--network=container:{other_cnt}\")\n    elif net.startswith(\"container:\"):\n        other_cnt = net.split(\":\", 1)[1].strip()\n        net_args.append(f\"--network=container:{other_cnt}\")\n    elif net.startswith(\"bridge\"):\n        aliases_on_container = [service_name]\n        if cnt.get(\"_aliases\"):\n            aliases_on_container.extend(cnt.get(\"_aliases\"))\n        net_options = [f\"alias={alias}\" for alias in aliases_on_container]\n        mac_address = cnt.get(\"mac_address\")\n        if mac_address:\n            net_options.append(f\"mac={mac_address}\")\n\n        net = f\"{net},\" if \":\" in net else f\"{net}:\"\n        net_args.append(f\"--network={net}{','.join(net_options)}\")\n    else:\n        log.fatal(\"unknown network_mode [%s]\", net)\n        sys.exit(1)\n\n    return net_args\n\n\ndef get_net_args(compose, cnt):\n    net = cnt.get(\"network_mode\")\n    if net:\n        return get_net_args_from_network_mode(compose, cnt)\n\n    return get_net_args_from_networks(compose, cnt)\n\n\ndef get_net_args_from_networks(compose, cnt):\n    net_args = []\n    mac_address = cnt.get(\"mac_address\")\n    service_name = cnt[\"service_name\"]\n\n    aliases_on_container = [service_name]\n    aliases_on_container.extend(cnt.get(\"_aliases\", []))\n\n    multiple_nets = cnt.get(\"networks\", {})\n    if not multiple_nets:\n        if not compose.default_net:\n            # The bridge mode in podman is using the `podman` network.\n            # It seems weird, but we should keep this behavior to avoid\n            # breaking changes.\n            net_options = [f\"alias={alias}\" for alias in aliases_on_container]\n            if mac_address:\n                net_options.append(f\"mac={mac_address}\")\n            net_args.append(f\"--network=bridge:{','.join(net_options)}\")\n            return net_args\n\n        multiple_nets = {compose.default_net: {}}\n\n    # networks can be specified as a dict with config per network or as a plain list without\n    # config.  Support both cases by converting the plain list to a dict with empty config.\n    if is_list(multiple_nets):\n        multiple_nets = {net: {} for net in multiple_nets}\n    else:\n        multiple_nets = {net: net_config or {} for net, net_config in multiple_nets.items()}\n\n    # if a mac_address was specified on the container level, we need to check that it is not\n    # specified on the network level as well\n    if mac_address is not None:\n        for net_config in multiple_nets.values():\n            network_mac = net_config.get(\"mac_address\", net_config.get(\"x-podman.mac_address\"))\n            if network_mac is not None:\n                raise RuntimeError(\n                    f\"conflicting mac addresses {mac_address} and {network_mac}:\"\n                    \"specifying mac_address on both container and network level \"\n                    \"is not supported\"\n                )\n\n    for net_, net_config_ in multiple_nets.items():\n        net_desc = compose.networks.get(net_) or {}\n        is_ext = net_desc.get(\"external\")\n        ext_desc = is_ext if isinstance(is_ext, str) else {}\n        default_net_name = default_network_name_for_project(compose, net_, is_ext)\n        net_name = ext_desc.get(\"name\") or net_desc.get(\"name\") or default_net_name\n\n        ipv4 = net_config_.get(\"ipv4_address\")\n        ipv6 = net_config_.get(\"ipv6_address\")\n        # Note: mac_address is supported by compose spec now, and x-podman.mac_address\n        # is only for backward compatibility\n        # https://github.com/compose-spec/compose-spec/blob/main/05-services.md#mac_address\n        mac = net_config_.get(\"mac_address\", net_config_.get(\"x-podman.mac_address\"))\n        aliases_on_net = norm_as_list(net_config_.get(\"aliases\", []))\n\n        # if a mac_address was specified on the container level, apply it to the first network\n        # This works for Python > 3.6, because dict insert ordering is preserved, so we are\n        # sure that the first network we encounter here is also the first one specified by\n        # the user\n        if mac is None and mac_address is not None:\n            mac = mac_address\n            mac_address = None\n\n        net_options = []\n        if ipv4:\n            net_options.append(f\"ip={ipv4}\")\n        if ipv6:\n            net_options.append(f\"ip6={ipv6}\")\n        if mac:\n            net_options.append(f\"mac={mac}\")\n\n        # Container level service aliases\n        net_options.extend([f\"alias={alias}\" for alias in aliases_on_container])\n        # network level service aliases\n        if aliases_on_net:\n            net_options.extend([f\"alias={alias}\" for alias in aliases_on_net])\n\n        if net_options:\n            net_args.append(f\"--network={net_name}:\" + \",\".join(net_options))\n        else:\n            net_args.append(f\"--network={net_name}\")\n\n    return net_args\n\n\nasync def container_to_args(compose, cnt, detached=True):\n    # TODO: double check -e , --add-host, -v, --read-only\n    dirname = compose.dirname\n    pod = cnt.get(\"pod\", \"\")\n    name = cnt[\"name\"]\n    podman_args = [f\"--name={name}\"]\n\n    if detached:\n        podman_args.append(\"-d\")\n\n    if pod:\n        podman_args.append(f\"--pod={pod}\")\n    deps = []\n    for dep_srv in cnt.get(\"_deps\", []):\n        deps.extend(compose.container_names_by_service.get(dep_srv.name, []))\n    if deps:\n        deps_csv = \",\".join(deps)\n        podman_args.append(f\"--requires={deps_csv}\")\n    sec = norm_as_list(cnt.get(\"security_opt\"))\n    for sec_item in sec:\n        podman_args.extend([\"--security-opt\", sec_item])\n    ann = norm_as_list(cnt.get(\"annotations\"))\n    for a in ann:\n        podman_args.extend([\"--annotation\", a])\n    if cnt.get(\"read_only\"):\n        podman_args.append(\"--read-only\")\n    if cnt.get(\"http_proxy\") is False:\n        podman_args.append(\"--http-proxy=false\")\n    for i in cnt.get(\"labels\", []):\n        podman_args.extend([\"--label\", i])\n    for c in cnt.get(\"cap_add\", []):\n        podman_args.extend([\"--cap-add\", c])\n    for c in cnt.get(\"cap_drop\", []):\n        podman_args.extend([\"--cap-drop\", c])\n    for item in cnt.get(\"group_add\", []):\n        podman_args.extend([\"--group-add\", item])\n    for item in cnt.get(\"devices\", []):\n        podman_args.extend([\"--device\", item])\n    for item in cnt.get(\"device_cgroup_rules\", []):\n        podman_args.extend([\"--device-cgroup-rule\", item])\n    for item in norm_as_list(cnt.get(\"dns\")):\n        podman_args.extend([\"--dns\", item])\n    for item in norm_as_list(cnt.get(\"dns_opt\")):\n        podman_args.extend([\"--dns-opt\", item])\n    for item in norm_as_list(cnt.get(\"dns_search\")):\n        podman_args.extend([\"--dns-search\", item])\n    env_file = cnt.get(\"env_file\", [])\n    if isinstance(env_file, (dict, str)):\n        env_file = [env_file]\n    for i in env_file:\n        if isinstance(i, str):\n            i = {\"path\": i}\n        path = i[\"path\"]\n        required = i.get(\"required\", True)\n        i = os.path.realpath(os.path.join(dirname, path))\n        if not os.path.exists(i):\n            if not required:\n                continue\n            raise ValueError(\"Env file at {} does not exist\".format(i))\n        dotenv_dict = {}\n        dotenv_dict = dotenv_to_dict(i)\n        env = norm_as_list(dotenv_dict)\n        for e in env:\n            podman_args.extend([\"-e\", e])\n    env = norm_as_list(cnt.get(\"environment\", {}))\n    for e in env:\n        podman_args.extend([\"-e\", e])\n    tmpfs_ls = cnt.get(\"tmpfs\", [])\n    if isinstance(tmpfs_ls, str):\n        tmpfs_ls = [tmpfs_ls]\n    for i in tmpfs_ls:\n        podman_args.extend([\"--tmpfs\", i])\n    for volume in cnt.get(\"volumes\", []):\n        podman_args.extend(await get_mount_args(compose, cnt, volume))\n\n    await assert_cnt_nets(compose, cnt)\n    podman_args.extend(get_net_args(compose, cnt))\n\n    log_config = cnt.get(\"logging\")\n    if log_config is not None:\n        podman_args.append(f'--log-driver={log_config.get(\"driver\", \"k8s-file\")}')\n        log_opts = log_config.get(\"options\", {})\n        podman_args += [f\"--log-opt={name}={value}\" for name, value in log_opts.items()]\n    for secret in cnt.get(\"secrets\", []):\n        podman_args.extend(get_secret_args(compose, cnt, secret))\n    for i in cnt.get(\"extra_hosts\", []):\n        podman_args.extend([\"--add-host\", i])\n    for i in cnt.get(\"expose\", []):\n        podman_args.extend([\"--expose\", i])\n    if cnt.get(\"publishall\"):\n        podman_args.append(\"-P\")\n    ports = cnt.get(\"ports\", [])\n    if isinstance(ports, str):\n        ports = [ports]\n    for port in ports:\n        if isinstance(port, dict):\n            port = port_dict_to_str(port)\n        elif not isinstance(port, str):\n            raise TypeError(\"port should be either string or dict\")\n        podman_args.extend([\"-p\", port])\n\n    userns_mode = cnt.get(\"userns_mode\")\n    if userns_mode is not None:\n        podman_args.extend([\"--userns\", userns_mode])\n\n    user = cnt.get(\"user\")\n    if user is not None:\n        podman_args.extend([\"-u\", user])\n    if cnt.get(\"working_dir\") is not None:\n        podman_args.extend([\"-w\", cnt[\"working_dir\"]])\n    if cnt.get(\"hostname\"):\n        podman_args.extend([\"--hostname\", cnt[\"hostname\"]])\n    if cnt.get(\"shm_size\"):\n        podman_args.extend([\"--shm-size\", str(cnt[\"shm_size\"])])\n    if cnt.get(\"stdin_open\"):\n        podman_args.append(\"-i\")\n    if cnt.get(\"stop_signal\"):\n        podman_args.extend([\"--stop-signal\", cnt[\"stop_signal\"]])\n\n    sysctls = cnt.get(\"sysctls\")\n    if sysctls is not None:\n        if isinstance(sysctls, dict):\n            for sysctl, value in sysctls.items():\n                podman_args.extend([\"--sysctl\", \"{}={}\".format(sysctl, value)])\n        elif isinstance(sysctls, list):\n            for i in sysctls:\n                podman_args.extend([\"--sysctl\", i])\n        else:\n            raise TypeError(\"sysctls should be either dict or list\")\n\n    if cnt.get(\"tty\"):\n        podman_args.append(\"--tty\")\n    if cnt.get(\"privileged\"):\n        podman_args.append(\"--privileged\")\n    if cnt.get(\"pid\"):\n        podman_args.extend([\"--pid\", cnt[\"pid\"]])\n    pull_policy = cnt.get(\"pull_policy\")\n    if pull_policy is not None and pull_policy != \"build\":\n        podman_args.extend([\"--pull\", pull_policy])\n    if cnt.get(\"restart\") is not None:\n        podman_args.extend([\"--restart\", cnt[\"restart\"]])\n    container_to_ulimit_args(cnt, podman_args)\n    container_to_res_args(cnt, podman_args)\n    # currently podman shipped by fedora does not package this\n    if cnt.get(\"init\"):\n        podman_args.append(\"--init\")\n    if cnt.get(\"init-path\"):\n        podman_args.extend([\"--init-path\", cnt[\"init-path\"]])\n    entrypoint = cnt.get(\"entrypoint\")\n    if entrypoint is not None:\n        if isinstance(entrypoint, str):\n            entrypoint = shlex.split(entrypoint)\n        podman_args.extend([\"--entrypoint\", json.dumps(entrypoint)])\n    platform = cnt.get(\"platform\")\n    if platform is not None:\n        podman_args.extend([\"--platform\", platform])\n    if cnt.get(\"runtime\"):\n        podman_args.extend([\"--runtime\", cnt[\"runtime\"]])\n\n    # WIP: healthchecks are still work in progress\n    healthcheck = cnt.get(\"healthcheck\", {})\n    if not isinstance(healthcheck, dict):\n        raise ValueError(\"'healthcheck' must be a key-value mapping\")\n    healthcheck_disable = healthcheck.get(\"disable\", False)\n    healthcheck_test = healthcheck.get(\"test\")\n    if healthcheck_disable:\n        healthcheck_test = [\"NONE\"]\n    if healthcheck_test:\n        # If it's a string, it's equivalent to specifying CMD-SHELL\n        if isinstance(healthcheck_test, str):\n            # podman does not add shell to handle command with whitespace\n            podman_args.extend([\n                \"--healthcheck-command\",\n                \"/bin/sh -c \" + cmd_quote(healthcheck_test),\n            ])\n        elif is_list(healthcheck_test):\n            healthcheck_test = healthcheck_test.copy()\n            # If it's a list, first item is either NONE, CMD or CMD-SHELL.\n            healthcheck_type = healthcheck_test.pop(0)\n            if healthcheck_type == \"NONE\":\n                podman_args.append(\"--no-healthcheck\")\n            elif healthcheck_type == \"CMD\":\n                cmd_q = \"' '\".join([cmd_quote(i) for i in healthcheck_test])\n                podman_args.extend([\"--healthcheck-command\", \"/bin/sh -c \" + cmd_q])\n            elif healthcheck_type == \"CMD-SHELL\":\n                if len(healthcheck_test) != 1:\n                    raise ValueError(\"'CMD_SHELL' takes a single string after it\")\n                cmd_q = cmd_quote(healthcheck_test[0])\n                podman_args.extend([\"--healthcheck-command\", \"/bin/sh -c \" + cmd_q])\n            else:\n                raise ValueError(\n                    f\"unknown healthcheck test type [{healthcheck_type}],\\\n                     expecting NONE, CMD or CMD-SHELL.\"\n                )\n        else:\n            raise ValueError(\"'healthcheck.test' either a string or a list\")\n\n    # interval, timeout and start_period are specified as durations.\n    if \"interval\" in healthcheck:\n        podman_args.extend([\"--healthcheck-interval\", healthcheck[\"interval\"]])\n    if \"timeout\" in healthcheck:\n        podman_args.extend([\"--healthcheck-timeout\", healthcheck[\"timeout\"]])\n    if \"start_period\" in healthcheck:\n        podman_args.extend([\"--healthcheck-start-period\", healthcheck[\"start_period\"]])\n\n    # convert other parameters to string\n    if \"retries\" in healthcheck:\n        podman_args.extend([\"--healthcheck-retries\", str(healthcheck[\"retries\"])])\n\n    # handle podman extension\n    if 'x-podman' in cnt:\n        raise ValueError(\n            'Configuration under x-podman has been migrated to x-podman.uidmaps and '\n            'x-podman.gidmaps fields'\n        )\n\n    rootfs_mode = False\n    for uidmap in cnt.get('x-podman.uidmaps', []):\n        podman_args.extend([\"--uidmap\", uidmap])\n    for gidmap in cnt.get('x-podman.gidmaps', []):\n        podman_args.extend([\"--gidmap\", gidmap])\n    if cnt.get(\"x-podman.no_hosts\", False):\n        podman_args.extend([\"--no-hosts\"])\n    rootfs = cnt.get('x-podman.rootfs')\n    if rootfs is not None:\n        rootfs_mode = True\n        podman_args.extend([\"--rootfs\", rootfs])\n        log.warning(\"WARNING: x-podman.rootfs and image both specified, image field ignored\")\n\n    if not rootfs_mode:\n        podman_args.append(cnt[\"image\"])  # command, ..etc.\n    command = cnt.get(\"command\")\n    if command is not None:\n        if isinstance(command, str):\n            podman_args.extend(shlex.split(command))\n        else:\n            podman_args.extend([str(i) for i in command])\n    return podman_args\n\n\nclass ServiceDependencyCondition(Enum):\n    CONFIGURED = \"configured\"\n    CREATED = \"created\"\n    EXITED = \"exited\"\n    HEALTHY = \"healthy\"\n    INITIALIZED = \"initialized\"\n    PAUSED = \"paused\"\n    REMOVING = \"removing\"\n    RUNNING = \"running\"\n    STOPPED = \"stopped\"\n    STOPPING = \"stopping\"\n    UNHEALTHY = \"unhealthy\"\n\n    @classmethod\n    def from_value(cls, value):\n        # Check if the value exists in the enum\n        for member in cls:\n            if member.value == value:\n                return member\n\n        # Check if this is a value coming from  reference\n        docker_to_podman_cond = {\n            \"service_healthy\": ServiceDependencyCondition.HEALTHY,\n            \"service_started\": ServiceDependencyCondition.RUNNING,\n            \"service_completed_successfully\": ServiceDependencyCondition.STOPPED,\n        }\n        try:\n            return docker_to_podman_cond[value]\n        except KeyError:\n            raise ValueError(f\"Value '{value}' is not a valid condition for a service dependency\")  # pylint: disable=raise-missing-from\n\n\nclass ServiceDependency:\n    def __init__(self, name, condition):\n        self._name = name\n        self._condition = ServiceDependencyCondition.from_value(condition)\n\n    @property\n    def name(self):\n        return self._name\n\n    @property\n    def condition(self):\n        return self._condition\n\n    def __hash__(self):\n        # Compute hash based on the frozenset of items to ensure order does not matter\n        return hash(('name', self._name) + ('condition', self._condition))\n\n    def __eq__(self, other):\n        # Compare equality based on dictionary content\n        if isinstance(other, ServiceDependency):\n            return self._name == other.name and self._condition == other.condition\n        return False\n\n\ndef rec_deps(services, service_name, start_point=None):\n    \"\"\"\n    return all dependencies of service_name recursively\n    \"\"\"\n    if not start_point:\n        start_point = service_name\n    deps = services[service_name][\"_deps\"]\n    for dep_name in deps.copy():\n        # avoid A depens on A\n        if dep_name.name == service_name:\n            continue\n        dep_srv = services.get(dep_name.name)\n        if not dep_srv:\n            continue\n        # NOTE: avoid creating loops, A->B->A\n        if any(start_point == x.name for x in dep_srv[\"_deps\"]):\n            continue\n        new_deps = rec_deps(services, dep_name.name, start_point)\n        deps.update(new_deps)\n    return deps\n\n\ndef flat_deps(services, with_extends=False):\n    \"\"\"\n    create dependencies \"_deps\" or update it recursively for all services\n    \"\"\"\n    for name, srv in services.items():\n        # parse dependencies for each service\n        deps = set()\n        srv[\"_deps\"] = deps\n        # TODO: manage properly the dependencies coming from base services when extended\n        if with_extends:\n            ext = srv.get(\"extends\", {}).get(\"service\")\n            if ext:\n                if ext != name:\n                    deps.add(ServiceDependency(ext, \"service_started\"))\n                continue\n\n        # the compose file has been normalized. depends_on, if exists, can only be a dictionary\n        # the normalization adds a \"service_started\" condition by default\n        deps_ls = srv.get(\"depends_on\", {})\n        deps_ls = [ServiceDependency(k, v[\"condition\"]) for k, v in deps_ls.items()]\n        deps.update(deps_ls)\n        # parse link to get service name and remove alias\n        links_ls = srv.get(\"links\", [])\n        if not is_list(links_ls):\n            links_ls = [links_ls]\n        deps.update([ServiceDependency(c.split(\":\")[0], \"service_started\") for c in links_ls])\n        for c in links_ls:\n            if \":\" in c:\n                dep_name, dep_alias = c.split(\":\")\n                if \"_aliases\" not in services[dep_name]:\n                    services[dep_name][\"_aliases\"] = set()\n                services[dep_name][\"_aliases\"].add(dep_alias)\n\n    # expand the dependencies on each service\n    for name, srv in services.items():\n        rec_deps(services, name)\n\n\nasync def wait_with_timeout(coro, timeout):\n    \"\"\"\n    Asynchronously waits for the given coroutine to complete with a timeout.\n\n    Args:\n        coro: The coroutine to wait for.\n        timeout (int or float): The maximum number of seconds to wait for.\n\n    Raises:\n        TimeoutError: If the coroutine does not complete within the specified timeout.\n    \"\"\"\n    try:\n        return await asyncio.wait_for(coro, timeout)\n    except asyncio.TimeoutError as exc:\n        raise TimeoutError from exc\n\n\n###################\n# podman and compose classes\n###################\n\n\nclass Podman:\n    def __init__(\n        self,\n        compose,\n        podman_path=\"podman\",\n        dry_run=False,\n        semaphore: asyncio.Semaphore = asyncio.Semaphore(sys.maxsize),\n    ):\n        self.compose = compose\n        self.podman_path = podman_path\n        self.dry_run = dry_run\n        self.semaphore = semaphore\n\n    async def output(self, podman_args, cmd=\"\", cmd_args=None):\n        async with self.semaphore:\n            cmd_args = cmd_args or []\n            xargs = self.compose.get_podman_args(cmd) if cmd else []\n            cmd_ls = [self.podman_path, *podman_args, cmd] + xargs + cmd_args\n            log.info(str(cmd_ls))\n            p = await asyncio.create_subprocess_exec(\n                *cmd_ls, stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.PIPE\n            )\n\n            stdout_data, stderr_data = await p.communicate()\n            if p.returncode == 0:\n                return stdout_data\n\n            raise subprocess.CalledProcessError(p.returncode, \" \".join(cmd_ls), stderr_data)\n\n    async def _readchunk(self, reader):\n        try:\n            return await reader.readuntil(b\"\\n\")\n        except asyncio.exceptions.IncompleteReadError as e:\n            return e.partial\n        except asyncio.exceptions.LimitOverrunError as e:\n            return await reader.read(e.consumed)\n\n    async def _format_stream(self, reader, sink, log_formatter):\n        line_ongoing = False\n\n        def _formatted_print_with_nl(s):\n            if line_ongoing:\n                print(s, file=sink, end=\"\\n\")\n            else:\n                print(log_formatter, s, file=sink, end=\"\\n\")\n\n        def _formatted_print_without_nl(s):\n            if line_ongoing:\n                print(s, file=sink, end=\"\")\n            else:\n                print(log_formatter, s, file=sink, end=\"\")\n\n        while not reader.at_eof():\n            chunk = await self._readchunk(reader)\n            parts = chunk.split(b\"\\n\")\n\n            # Iff parts ends with '', the last part is a incomplete line;\n            # The rest are complete lines\n\n            for i, part in enumerate(parts):\n                if i < len(parts) - 1:\n                    _formatted_print_with_nl(part.decode())\n                    line_ongoing = False\n                elif len(part) > 0:\n                    _formatted_print_without_nl(part.decode())\n                    line_ongoing = True\n        if line_ongoing:\n            print(file=sink, end=\"\\n\")  # End the unfinished line\n\n    def exec(\n        self,\n        podman_args,\n        cmd=\"\",\n        cmd_args=None,\n    ):\n        cmd_args = list(map(str, cmd_args or []))\n        xargs = self.compose.get_podman_args(cmd) if cmd else []\n        cmd_ls = [self.podman_path, *podman_args, cmd] + xargs + cmd_args\n        log.info(\" \".join([str(i) for i in cmd_ls]))\n        os.execlp(self.podman_path, *cmd_ls)\n\n    async def run(  # pylint: disable=dangerous-default-value\n        self,\n        podman_args,\n        cmd=\"\",\n        cmd_args=None,\n        log_formatter=None,\n        *,\n        # Intentionally mutable default argument to hold references to tasks\n        task_reference=set(),\n    ) -> int:\n        async with self.semaphore:\n            cmd_args = list(map(str, cmd_args or []))\n            xargs = self.compose.get_podman_args(cmd) if cmd else []\n            cmd_ls = [self.podman_path, *podman_args, cmd] + xargs + cmd_args\n            log.info(\" \".join([str(i) for i in cmd_ls]))\n            if self.dry_run:\n                return None\n\n            if log_formatter is not None:\n                p = await asyncio.create_subprocess_exec(\n                    *cmd_ls, stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.PIPE\n                )  # pylint: disable=consider-using-with\n\n                # This is hacky to make the tasks not get garbage collected\n                # https://github.com/python/cpython/issues/91887\n                out_t = asyncio.create_task(\n                    self._format_stream(p.stdout, sys.stdout, log_formatter)\n                )\n                task_reference.add(out_t)\n                out_t.add_done_callback(task_reference.discard)\n\n                err_t = asyncio.create_task(\n                    self._format_stream(p.stderr, sys.stdout, log_formatter)\n                )\n                task_reference.add(err_t)\n                err_t.add_done_callback(task_reference.discard)\n\n            else:\n                p = await asyncio.create_subprocess_exec(*cmd_ls)  # pylint: disable=consider-using-with\n\n            try:\n                exit_code = await p.wait()\n            except asyncio.CancelledError:\n                log.info(\"Sending termination signal\")\n                p.terminate()\n                try:\n                    exit_code = await wait_with_timeout(p.wait(), 10)\n                except TimeoutError:\n                    log.warning(\"container did not shut down after 10 seconds, killing\")\n                    p.kill()\n                    exit_code = await p.wait()\n\n            log.info(\"exit code: %s\", exit_code)\n            return exit_code\n\n    async def network_ls(self):\n        output = (\n            await self.output(\n                [],\n                \"network\",\n                [\n                    \"ls\",\n                    \"--noheading\",\n                    \"--filter\",\n                    f\"label=io.podman.compose.project={self.compose.project_name}\",\n                    \"--format\",\n                    \"{{.Name}}\",\n                ],\n            )\n        ).decode()\n        networks = output.splitlines()\n        return networks\n\n    async def volume_ls(self):\n        output = (\n            await self.output(\n                [],\n                \"volume\",\n                [\n                    \"ls\",\n                    \"--noheading\",\n                    \"--filter\",\n                    f\"label=io.podman.compose.project={self.compose.project_name}\",\n                    \"--format\",\n                    \"{{.Name}}\",\n                ],\n            )\n        ).decode(\"utf-8\")\n        volumes = output.splitlines()\n        return volumes\n\n\ndef normalize_service(service, sub_dir=\"\"):\n    if \"build\" in service:\n        build = service[\"build\"]\n        if isinstance(build, str):\n            service[\"build\"] = {\"context\": build}\n    if sub_dir and \"build\" in service:\n        build = service[\"build\"]\n        context = build.get(\"context\", \"\")\n        if context or sub_dir:\n            if context.startswith(\"./\"):\n                context = context[2:]\n            if sub_dir:\n                context = os.path.join(sub_dir, context)\n            context = context.rstrip(\"/\")\n            if not context:\n                context = \".\"\n            service[\"build\"][\"context\"] = context\n    if \"build\" in service and \"additional_contexts\" in service[\"build\"]:\n        if isinstance(build[\"additional_contexts\"], dict):\n            new_additional_contexts = []\n            for k, v in build[\"additional_contexts\"].items():\n                new_additional_contexts.append(f\"{k}={v}\")\n            build[\"additional_contexts\"] = new_additional_contexts\n    for key in (\"command\", \"entrypoint\"):\n        if key in service:\n            if isinstance(service[key], str):\n                service[key] = shlex.split(service[key])\n    for key in (\"env_file\", \"security_opt\", \"volumes\"):\n        if key not in service:\n            continue\n        if isinstance(service[key], str):\n            service[key] = [service[key]]\n    if \"security_opt\" in service:\n        sec_ls = service[\"security_opt\"]\n        for ix, item in enumerate(sec_ls):\n            if item in (\"seccomp:unconfined\", \"apparmor:unconfined\"):\n                sec_ls[ix] = item.replace(\":\", \"=\")\n    for key in (\"environment\", \"labels\"):\n        if key not in service:\n            continue\n        service[key] = norm_as_dict(service[key])\n    if \"extends\" in service:\n        extends = service[\"extends\"]\n        if isinstance(extends, str):\n            extends = {\"service\": extends}\n            service[\"extends\"] = extends\n    if \"depends_on\" in service:\n        # deps should become a dictionary of dependencies\n        deps = service[\"depends_on\"]\n        if isinstance(deps, str):\n            deps = {deps: {}}\n        elif is_list(deps):\n            deps = {x: {} for x in deps}\n\n        # the dependency service_started is set by default\n        # unless requested otherwise.\n        for k, v in deps.items():\n            v.setdefault('condition', 'service_started')\n        service[\"depends_on\"] = deps\n    return service\n\n\ndef normalize(compose):\n    \"\"\"\n    convert compose dict of some keys from string or dicts into arrays\n    \"\"\"\n    services = compose.get(\"services\", {})\n    for service in services.values():\n        normalize_service(service)\n    return compose\n\n\ndef normalize_service_final(service: dict, project_dir: str) -> dict:\n    if \"build\" in service:\n        build = service[\"build\"]\n        context = build if isinstance(build, str) else build.get(\"context\", \".\")\n        context = os.path.normpath(os.path.join(project_dir, context))\n        if not isinstance(service[\"build\"], dict):\n            service[\"build\"] = {}\n        service[\"build\"][\"context\"] = context\n    return service\n\n\ndef normalize_final(compose: dict, project_dir: str) -> dict:\n    services = compose.get(\"services\", {})\n    for service in services.values():\n        normalize_service_final(service, project_dir)\n    return compose\n\n\ndef clone(value):\n    return value.copy() if is_list(value) or isinstance(value, dict) else value\n\n\ndef rec_merge_one(target, source):\n    \"\"\"\n    update target from source recursively\n    \"\"\"\n    done = set()\n    for key, value in source.items():\n        if key in target:\n            continue\n        target[key] = clone(value)\n        done.add(key)\n    for key, value in target.items():\n        if key in done:\n            continue\n        if key not in source:\n            continue\n        value2 = source[key]\n        if key in (\"command\", \"entrypoint\"):\n            target[key] = clone(value2)\n            continue\n        if not isinstance(value2, type(value)):\n            value_type = type(value)\n            value2_type = type(value2)\n            raise ValueError(f\"can't merge value of [{key}] of type {value_type} and {value2_type}\")\n        if is_list(value2):\n            if key == \"volumes\":\n                # clean duplicate mount targets\n                pts = {v.split(\":\", 2)[1] for v in value2 if \":\" in v}\n                del_ls = [\n                    ix for (ix, v) in enumerate(value) if \":\" in v and v.split(\":\", 2)[1] in pts\n                ]\n                for ix in reversed(del_ls):\n                    del value[ix]\n                value.extend(value2)\n            else:\n                value.extend(value2)\n        elif isinstance(value2, dict):\n            rec_merge_one(value, value2)\n        else:\n            target[key] = value2\n    return target\n\n\ndef rec_merge(target, *sources):\n    \"\"\"\n    update target recursively from sources\n    \"\"\"\n    for source in sources:\n        ret = rec_merge_one(target, source)\n    return ret\n\n\ndef resolve_extends(services, service_names, environ):\n    for name in service_names:\n        service = services[name]\n        ext = service.get(\"extends\", {})\n        if isinstance(ext, str):\n            ext = {\"service\": ext}\n        from_service_name = ext.get(\"service\")\n        if not from_service_name:\n            continue\n        filename = ext.get(\"file\")\n        if filename:\n            if filename.startswith(\"./\"):\n                filename = filename[2:]\n            with open(filename, \"r\", encoding=\"utf-8\") as f:\n                content = yaml.safe_load(f) or {}\n            if \"services\" in content:\n                content = content[\"services\"]\n            subdirectory = os.path.dirname(filename)\n            content = rec_subs(content, environ)\n            from_service = content.get(from_service_name, {}) or {}\n            normalize_service(from_service, subdirectory)\n        else:\n            from_service = services.get(from_service_name, {}).copy()\n            del from_service[\"_deps\"]\n            try:\n                del from_service[\"extends\"]\n            except KeyError:\n                pass\n        new_service = rec_merge({}, from_service, service)\n        services[name] = new_service\n\n\ndef dotenv_to_dict(dotenv_path):\n    if not os.path.isfile(dotenv_path):\n        return {}\n    return dotenv_values(dotenv_path)\n\n\nCOMPOSE_DEFAULT_LS = [\n    \"compose.yaml\",\n    \"compose.yml\",\n    \"compose.override.yaml\",\n    \"compose.override.yml\",\n    \"podman-compose.yaml\",\n    \"podman-compose.yml\",\n    \"docker-compose.yml\",\n    \"docker-compose.yaml\",\n    \"docker-compose.override.yml\",\n    \"docker-compose.override.yaml\",\n    \"container-compose.yml\",\n    \"container-compose.yaml\",\n    \"container-compose.override.yml\",\n    \"container-compose.override.yaml\",\n]\n\n\nclass PodmanCompose:\n    def __init__(self):\n        self.podman: Podman\n        self.podman_version = None\n        self.environ = {}\n        self.exit_code = None\n        self.commands = {}\n        self.global_args = argparse.Namespace()\n        self.project_name = None\n        self.dirname = None\n        self.pods = None\n        self.containers = []\n        self.vols = None\n        self.networks = {}\n        self.default_net = \"default\"\n        self.declared_secrets = None\n        self.container_names_by_service = None\n        self.container_by_name = None\n        self.services = None\n        self.all_services = set()\n        self.prefer_volume_over_mount = True\n        self.x_podman = {}\n        self.merged_yaml = None\n        self.yaml_hash = \"\"\n        self.console_colors = [\n            \"\\x1b[1;32m\",\n            \"\\x1b[1;33m\",\n            \"\\x1b[1;34m\",\n            \"\\x1b[1;35m\",\n            \"\\x1b[1;36m\",\n        ]\n\n    def assert_services(self, services):\n        if isinstance(services, str):\n            services = [services]\n        given = set(services or [])\n        missing = given - self.all_services\n        if missing:\n            missing_csv = \",\".join(missing)\n            log.warning(\"missing services [%s]\", missing_csv)\n            sys.exit(1)\n\n    def get_podman_args(self, cmd):\n        xargs = []\n        for args in self.global_args.podman_args:\n            xargs.extend(shlex.split(args))\n        cmd_norm = cmd if cmd != \"create\" else \"run\"\n        cmd_args = self.global_args.__dict__.get(f\"podman_{cmd_norm}_args\", [])\n        for args in cmd_args:\n            xargs.extend(shlex.split(args))\n        return xargs\n\n    async def run(self, argv=None):\n        log.info(\"podman-compose version: %s\", __version__)\n        args = self._parse_args(argv)\n        podman_path = args.podman_path\n        if podman_path != \"podman\":\n            if os.path.isfile(podman_path) and os.access(podman_path, os.X_OK):\n                podman_path = os.path.realpath(podman_path)\n            else:\n                # this also works if podman hasn't been installed now\n                if args.dry_run is False:\n                    log.fatal(\"Binary %s has not been found.\", podman_path)\n                    sys.exit(1)\n        self.podman = Podman(self, podman_path, args.dry_run, asyncio.Semaphore(args.parallel))\n\n        if not args.dry_run:\n            # just to make sure podman is running\n            try:\n                self.podman_version = (await self.podman.output([\"--version\"], \"\", [])).decode(\n                    \"utf-8\"\n                ).strip() or \"\"\n                self.podman_version = (self.podman_version.split() or [\"\"])[-1]\n            except subprocess.CalledProcessError:\n                self.podman_version = None\n            if not self.podman_version:\n                log.fatal(\"it seems that you do not have `podman` installed\")\n                sys.exit(1)\n            log.info(\"using podman version: %s\", self.podman_version)\n        cmd_name = args.command\n        compose_required = cmd_name != \"version\" and (\n            cmd_name != \"systemd\" or args.action != \"create-unit\"\n        )\n        if compose_required:\n            self._parse_compose_file()\n        cmd = self.commands[cmd_name]\n        retcode = await cmd(self, args)\n        if isinstance(retcode, int):\n            sys.exit(retcode)\n\n    def resolve_in_pod(self):\n        if self.global_args.in_pod_bool is None:\n            self.global_args.in_pod_bool = self.x_podman.get(\"in_pod\", True)\n        # otherwise use `in_pod` value provided by command line\n        return self.global_args.in_pod_bool\n\n    def _parse_compose_file(self):\n        args = self.global_args\n        # cmd = args.command\n        dirname = os.environ.get(\"COMPOSE_PROJECT_DIR\")\n        if dirname and os.path.isdir(dirname):\n            os.chdir(dirname)\n        pathsep = os.environ.get(\"COMPOSE_PATH_SEPARATOR\", os.pathsep)\n        if not args.file:\n            default_str = os.environ.get(\"COMPOSE_FILE\")\n            if default_str:\n                default_ls = default_str.split(pathsep)\n            else:\n                default_ls = COMPOSE_DEFAULT_LS\n            args.file = list(filter(os.path.exists, default_ls))\n        files = args.file\n        if not files:\n            log.fatal(\n                \"no compose.yaml, docker-compose.yml or container-compose.yml file found, \"\n                \"pass files with -f\"\n            )\n            sys.exit(-1)\n        ex = map(lambda x: x == '-' or os.path.exists(x), files)\n        missing = [fn0 for ex0, fn0 in zip(ex, files) if not ex0]\n        if missing:\n            log.fatal(\"missing files: %s\", missing)\n            sys.exit(1)\n        # make absolute\n        relative_files = files\n        filename = files[0]\n        project_name = args.project_name\n        # no_ansi = args.no_ansi\n        # no_cleanup = args.no_cleanup\n        # dry_run = args.dry_run\n        # host_env = None\n        dirname = os.path.realpath(os.path.dirname(filename))\n        dir_basename = os.path.basename(dirname)\n        self.dirname = dirname\n\n        # env-file is relative to the CWD\n        dotenv_dict = {}\n        if args.env_file:\n            # Load .env from the Compose file's directory to preserve\n            # behavior prior to 1.1.0 and to match with Docker Compose (v2).\n            if \".env\" == args.env_file:\n                project_dotenv_file = os.path.realpath(os.path.join(dirname, \".env\"))\n                if os.path.exists(project_dotenv_file):\n                    dotenv_dict.update(dotenv_to_dict(project_dotenv_file))\n            dotenv_path = os.path.realpath(args.env_file)\n            dotenv_dict.update(dotenv_to_dict(dotenv_path))\n\n        # TODO: remove next line\n        os.chdir(dirname)\n\n        os.environ.update({\n            key: value for key, value in dotenv_dict.items() if key.startswith(\"PODMAN_\")\n        })\n        self.environ = dotenv_dict\n        self.environ.update(dict(os.environ))\n        # see: https://docs.docker.com/compose/reference/envvars/\n        # see: https://docs.docker.com/compose/env-file/\n        self.environ.update({\n            \"COMPOSE_PROJECT_DIR\": dirname,\n            \"COMPOSE_FILE\": pathsep.join(relative_files),\n            \"COMPOSE_PATH_SEPARATOR\": pathsep,\n        })\n\n        if args and 'env' in args and args.env:\n            env_vars = norm_as_dict(args.env)\n            self.environ.update(env_vars)\n\n        compose = {}\n        # Iterate over files primitively to allow appending to files in-loop\n        files_iter = iter(files)\n\n        while True:\n            try:\n                filename = next(files_iter)\n            except StopIteration:\n                break\n\n            if filename.strip().split('/')[-1] == '-':\n                content = yaml.safe_load(sys.stdin)\n            else:\n                with open(filename, \"r\", encoding=\"utf-8\") as f:\n                    content = yaml.safe_load(f)\n                # log(filename, json.dumps(content, indent = 2))\n            if not isinstance(content, dict):\n                sys.stderr.write(\n                    \"Compose file does not contain a top level object: %s\\n\" % filename\n                )\n                sys.exit(1)\n            content = normalize(content)\n            # log(filename, json.dumps(content, indent = 2))\n            content = rec_subs(content, self.environ)\n            rec_merge(compose, content)\n            # If `include` is used, append included files to files\n            include = compose.get(\"include\")\n            if include:\n                files.extend(include)\n                # As compose obj is updated and tested with every loop, not deleting `include`\n                # from it, results in it being tested again and again, original values for\n                # `include` be appended to `files`, and, included files be processed for ever.\n                # Solution is to remove 'include' key from compose obj. This doesn't break\n                # having `include` present and correctly processed in included files\n                del compose[\"include\"]\n        resolved_services = self._resolve_profiles(compose.get(\"services\", {}), set(args.profile))\n        compose[\"services\"] = resolved_services\n        if not getattr(args, \"no_normalize\", None):\n            compose = normalize_final(compose, self.dirname)\n        self.merged_yaml = yaml.safe_dump(compose)\n        merged_json_b = json.dumps(compose, separators=(\",\", \":\")).encode(\"utf-8\")\n        self.yaml_hash = hashlib.sha256(merged_json_b).hexdigest()\n        compose[\"_dirname\"] = dirname\n        # debug mode\n        if len(files) > 1:\n            log.debug(\" ** merged:\\n%s\", json.dumps(compose, indent=2))\n        # ver = compose.get('version')\n\n        if not project_name:\n            project_name = compose.get(\"name\")\n            if project_name is None:\n                # More strict then actually needed for simplicity:\n                # podman requires [a-zA-Z0-9][a-zA-Z0-9_.-]*\n                project_name = self.environ.get(\"COMPOSE_PROJECT_NAME\", dir_basename.lower())\n                project_name = norm_re.sub(\"\", project_name)\n                if not project_name:\n                    raise RuntimeError(f\"Project name [{dir_basename}] normalized to empty\")\n\n        self.project_name = project_name\n        self.environ.update({\"COMPOSE_PROJECT_NAME\": self.project_name})\n\n        services = compose.get(\"services\")\n        if services is None:\n            services = {}\n            log.warning(\"WARNING: No services defined\")\n        # include services with no profile defined or the selected profiles\n        services = self._resolve_profiles(services, set(args.profile))\n\n        # NOTE: maybe add \"extends.service\" to _deps at this stage\n        flat_deps(services, with_extends=True)\n        service_names = sorted([(len(srv[\"_deps\"]), name) for name, srv in services.items()])\n        service_names = [name for _, name in service_names]\n        resolve_extends(services, service_names, self.environ)\n        flat_deps(services)\n        service_names = sorted([(len(srv[\"_deps\"]), name) for name, srv in services.items()])\n        service_names = [name for _, name in service_names]\n        nets = compose.get(\"networks\", {})\n        if not nets:\n            nets[\"default\"] = None\n\n        self.networks = nets\n        if compose.get(\"x-podman\", {}).get(\"default_net_behavior_compat\", False):\n            # If there is no network_mode and networks in service,\n            # docker-compose will create default network named '<project_name>_default'\n            # and add the service to the default network.\n            # So we always set `default_net = 'default'` for compatibility\n            if \"default\" not in self.networks:\n                self.networks[\"default\"] = None\n        else:\n            if len(self.networks) == 1:\n                self.default_net = list(nets.keys())[0]\n            elif \"default\" in nets:\n                self.default_net = \"default\"\n            else:\n                self.default_net = None\n\n        allnets = set()\n        for name, srv in services.items():\n            srv_nets = srv.get(\"networks\", self.default_net)\n            srv_nets = (\n                list(srv_nets.keys()) if isinstance(srv_nets, dict) else norm_as_list(srv_nets)\n            )\n            allnets.update(srv_nets)\n        given_nets = set(nets.keys())\n        missing_nets = allnets - given_nets\n        unused_nets = given_nets - allnets - set([\"default\"])\n        if len(unused_nets):\n            unused_nets_str = \",\".join(unused_nets)\n            log.warning(\"WARNING: unused networks: %s\", unused_nets_str)\n        if len(missing_nets):\n            missing_nets_str = \",\".join(missing_nets)\n            raise RuntimeError(f\"missing networks: {missing_nets_str}\")\n        # volumes: [...]\n        self.vols = compose.get(\"volumes\", {})\n        podman_compose_labels = [\n            \"io.podman.compose.config-hash=\" + self.yaml_hash,\n            \"io.podman.compose.project=\" + project_name,\n            \"io.podman.compose.version=\" + __version__,\n            f\"PODMAN_SYSTEMD_UNIT=podman-compose@{project_name}.service\",\n            \"com.docker.compose.project=\" + project_name,\n            \"com.docker.compose.project.working_dir=\" + dirname,\n            \"com.docker.compose.project.config_files=\" + \",\".join(relative_files),\n        ]\n        # other top-levels:\n        # networks: {driver: ...}\n        # configs: {...}\n        self.declared_secrets = compose.get(\"secrets\", {})\n        given_containers = []\n        container_names_by_service = {}\n        self.services = services\n        for service_name, service_desc in services.items():\n            replicas = try_int(service_desc.get(\"deploy\", {}).get(\"replicas\"), fallback=1)\n\n            container_names_by_service[service_name] = []\n            for num in range(1, replicas + 1):\n                name0 = f\"{project_name}_{service_name}_{num}\"\n                if num == 1:\n                    name = service_desc.get(\"container_name\", name0)\n                else:\n                    name = name0\n                container_names_by_service[service_name].append(name)\n                # log(service_name,service_desc)\n                cnt = {\n                    \"name\": name,\n                    \"num\": num,\n                    \"service_name\": service_name,\n                    **service_desc,\n                }\n                x_podman = service_desc.get(\"x-podman\")\n                rootfs_mode = x_podman is not None and x_podman.get(\"rootfs\") is not None\n                if \"image\" not in cnt and not rootfs_mode:\n                    cnt[\"image\"] = f\"{project_name}_{service_name}\"\n                labels = norm_as_list(cnt.get(\"labels\"))\n                cnt[\"ports\"] = norm_ports(cnt.get(\"ports\"))\n                labels.extend(podman_compose_labels)\n                labels.extend([\n                    f\"com.docker.compose.container-number={num}\",\n                    \"com.docker.compose.service=\" + service_name,\n                ])\n                cnt[\"labels\"] = labels\n                cnt[\"_service\"] = service_name\n                cnt[\"_project\"] = project_name\n                given_containers.append(cnt)\n                volumes = cnt.get(\"volumes\", [])\n                for volume in volumes:\n                    mnt_dict = get_mnt_dict(self, cnt, volume)\n                    if (\n                        mnt_dict.get(\"type\") == \"volume\"\n                        and mnt_dict[\"source\"]\n                        and mnt_dict[\"source\"] not in self.vols\n                    ):\n                        vol_name = mnt_dict[\"source\"]\n                        raise RuntimeError(f\"volume [{vol_name}] not defined in top level\")\n        self.container_names_by_service = container_names_by_service\n        self.all_services = set(container_names_by_service.keys())\n        container_by_name = {c[\"name\"]: c for c in given_containers}\n        # log(\"deps:\", [(c[\"name\"], c[\"_deps\"]) for c in given_containers])\n        given_containers = list(container_by_name.values())\n        given_containers.sort(key=lambda c: len(c.get(\"_deps\", [])))\n        # log(\"sorted:\", [c[\"name\"] for c in given_containers])\n\n        self.x_podman = compose.get(\"x-podman\", {})\n\n        args.in_pod_bool = self.resolve_in_pod()\n        pods, containers = transform(args, project_name, given_containers)\n        self.pods = pods\n        self.containers = containers\n        self.container_by_name = {c[\"name\"]: c for c in containers}\n\n    def _resolve_profiles(self, defined_services, requested_profiles=None):\n        \"\"\"\n        Returns a service dictionary (key = service name, value = service config) compatible with\n        the requested_profiles list.\n\n        The returned service dictionary contains all services which do not include/reference a\n        profile in addition to services that match the requested_profiles.\n\n        :param defined_services: The service dictionary\n        :param requested_profiles: The profiles requested using the --profile arg.\n        \"\"\"\n        if requested_profiles is None:\n            requested_profiles = set()\n\n        services = {}\n\n        for name, config in defined_services.items():\n            service_profiles = set(config.get(\"profiles\", []))\n            if not service_profiles or requested_profiles.intersection(service_profiles):\n                services[name] = config\n        return services\n\n    def _parse_args(self, argv=None):\n        parser = argparse.ArgumentParser(formatter_class=argparse.RawTextHelpFormatter)\n        self._init_global_parser(parser)\n        subparsers = parser.add_subparsers(title=\"command\", dest=\"command\")\n        subparser = subparsers.add_parser(\"help\", help=\"show help\")\n        for cmd_name, cmd in self.commands.items():\n            subparser = subparsers.add_parser(cmd_name, help=cmd.desc)  # pylint: disable=protected-access\n            for cmd_parser in cmd._parse_args:  # pylint: disable=protected-access\n                cmd_parser(subparser)\n        self.global_args = parser.parse_args(argv)\n        if self.global_args.in_pod is not None and self.global_args.in_pod.lower() not in (\n            '',\n            'true',\n            '1',\n            'false',\n            '0',\n        ):\n            raise ValueError(\n                f'Invalid --in-pod value: \\'{self.global_args.in_pod}\\'. '\n                'It must be set to either of: empty value, true, 1, false, 0'\n            )\n\n        if self.global_args.in_pod == '' or self.global_args.in_pod is None:\n            self.global_args.in_pod_bool = None\n        else:\n            self.global_args.in_pod_bool = self.global_args.in_pod.lower() in ('true', '1')\n\n        if self.global_args.version:\n            self.global_args.command = \"version\"\n        if not self.global_args.command or self.global_args.command == \"help\":\n            parser.print_help()\n            sys.exit(-1)\n\n        logging.basicConfig(level=(\"DEBUG\" if self.global_args.verbose else \"WARN\"))\n        return self.global_args\n\n    @staticmethod\n    def _init_global_parser(parser):\n        parser.add_argument(\"-v\", \"--version\", help=\"show version\", action=\"store_true\")\n        parser.add_argument(\n            \"--in-pod\",\n            help=\"pod creation\",\n            metavar=\"in_pod\",\n            type=str,\n            default=None,\n        )\n        parser.add_argument(\n            \"--pod-args\",\n            help=\"custom arguments to be passed to `podman pod`\",\n            metavar=\"pod_args\",\n            type=str,\n            default=\"--infra=false --share=\",\n        )\n        parser.add_argument(\n            \"--env-file\",\n            help=\"Specify an alternate environment file\",\n            metavar=\"env_file\",\n            type=str,\n            default=\".env\",\n        )\n        parser.add_argument(\n            \"-f\",\n            \"--file\",\n            help=\"Specify an compose file (default: docker-compose.yml) or '-' to read from stdin.\",\n            metavar=\"file\",\n            action=\"append\",\n            default=[],\n        )\n        parser.add_argument(\n            \"--profile\",\n            help=\"Specify a profile to enable\",\n            metavar=\"profile\",\n            action=\"append\",\n            default=[],\n        )\n        parser.add_argument(\n            \"-p\",\n            \"--project-name\",\n            help=\"Specify an alternate project name (default: directory name)\",\n            type=str,\n            default=None,\n        )\n        parser.add_argument(\n            \"--podman-path\",\n            help=\"Specify an alternate path to podman (default: use location in $PATH variable)\",\n            type=str,\n            default=\"podman\",\n        )\n        parser.add_argument(\n            \"--podman-args\",\n            help=\"custom global arguments to be passed to `podman`\",\n            metavar=\"args\",\n            action=\"append\",\n            default=[],\n        )\n        for podman_cmd in PODMAN_CMDS:\n            parser.add_argument(\n                f\"--podman-{podman_cmd}-args\",\n                help=f\"custom arguments to be passed to `podman {podman_cmd}`\",\n                metavar=\"args\",\n                action=\"append\",\n                default=[],\n            )\n        parser.add_argument(\n            \"--no-ansi\",\n            help=\"Do not print ANSI control characters\",\n            action=\"store_true\",\n        )\n        parser.add_argument(\n            \"--no-cleanup\",\n            help=\"Do not stop and remove existing pod & containers\",\n            action=\"store_true\",\n        )\n        parser.add_argument(\n            \"--dry-run\",\n            help=\"No action; perform a simulation of commands\",\n            action=\"store_true\",\n        )\n        parser.add_argument(\n            \"--parallel\", type=int, default=os.environ.get(\"COMPOSE_PARALLEL_LIMIT\", sys.maxsize)\n        )\n        parser.add_argument(\n            \"--verbose\",\n            help=\"Print debugging output\",\n            action=\"store_true\",\n        )\n\n\npodman_compose = PodmanCompose()\n\n\n###################\n# decorators to add commands and parse options\n###################\nclass PodmanComposeError(Exception):\n    pass\n\n\nclass cmd_run:  # pylint: disable=invalid-name,too-few-public-methods\n    def __init__(self, compose, cmd_name, cmd_desc=None):\n        self.compose = compose\n        self.cmd_name = cmd_name\n        self.cmd_desc = cmd_desc\n\n    def __call__(self, func):\n        def wrapped(*args, **kw):\n            return func(*args, **kw)\n\n        if not asyncio.iscoroutinefunction(func):\n            raise PodmanComposeError(\"Command must be async\")\n        wrapped._compose = self.compose\n        # Trim extra indentation at start of multiline docstrings.\n        wrapped.desc = self.cmd_desc or re.sub(r\"^\\s+\", \"\", func.__doc__)\n        wrapped._parse_args = []\n        self.compose.commands[self.cmd_name] = wrapped\n        return wrapped\n\n\nclass cmd_parse:  # pylint: disable=invalid-name,too-few-public-methods\n    def __init__(self, compose, cmd_names):\n        self.compose = compose\n        self.cmd_names = cmd_names if is_list(cmd_names) else [cmd_names]\n\n    def __call__(self, func):\n        def wrapped(*args, **kw):\n            return func(*args, **kw)\n\n        for cmd_name in self.cmd_names:\n            self.compose.commands[cmd_name]._parse_args.append(wrapped)\n        return wrapped\n\n\n###################\n# actual commands\n###################\n\n\n@cmd_run(podman_compose, \"version\", \"show version\")\nasync def compose_version(compose, args):\n    if getattr(args, \"short\", False):\n        print(__version__)\n        return\n    if getattr(args, \"format\", \"pretty\") == \"json\":\n        res = {\"version\": __version__}\n        print(json.dumps(res))\n        return\n    print(\"podman-compose version\", __version__)\n    await compose.podman.run([\"--version\"], \"\", [])\n\n\ndef is_local(container: dict) -> bool:\n    \"\"\"Test if a container is local, i.e. if it is\n    * prefixed with localhost/\n    * has a build section and is not prefixed\n    \"\"\"\n    return (\n        \"/\" not in container[\"image\"]\n        if \"build\" in container\n        else container[\"image\"].startswith(\"localhost/\")\n    )\n\n\n@cmd_run(podman_compose, \"wait\", \"wait running containers to stop\")\nasync def compose_wait(compose, args):  # pylint: disable=unused-argument\n    containers = [cnt[\"name\"] for cnt in compose.containers]\n    cmd_args = [\"--\"]\n    cmd_args.extend(containers)\n    await compose.podman.exec([], \"wait\", cmd_args)\n\n\n@cmd_run(podman_compose, \"systemd\")\nasync def compose_systemd(compose, args):\n    \"\"\"\n    create systemd unit file and register its compose stacks\n\n    When first installed type `sudo podman-compose systemd -a create-unit`\n    later you can add a compose stack by running `podman-compose systemd -a register`\n    then you can start/stop your stack with `systemctl --user start podman-compose@<PROJ>`\n    \"\"\"\n    stacks_dir = \".config/containers/compose/projects\"\n    if args.action == \"register\":\n        proj_name = compose.project_name\n        fn = os.path.expanduser(f\"~/{stacks_dir}/{proj_name}.env\")\n        os.makedirs(os.path.dirname(fn), exist_ok=True)\n        log.debug(\"writing [%s]: ...\", fn)\n        with open(fn, \"w\", encoding=\"utf-8\") as f:\n            for k, v in compose.environ.items():\n                if k.startswith(\"COMPOSE_\") or k.startswith(\"PODMAN_\"):\n                    f.write(f\"{k}={v}\\n\")\n        log.debug(\"writing [%s]: done.\", fn)\n        log.info(\"\\n\\ncreating the pod without starting it: ...\\n\\n\")\n        username = getpass.getuser()\n        print(\n            f\"\"\"\nyou can use systemd commands like enable, start, stop, status, cat\nall without `sudo` like this:\n\n\\t\\tsystemctl --user enable --now 'podman-compose@{proj_name}'\n\\t\\tsystemctl --user status 'podman-compose@{proj_name}'\n\\t\\tjournalctl --user -xeu 'podman-compose@{proj_name}'\n\nand for that to work outside a session\nyou might need to run the following command *once*\n\n\\t\\tsudo loginctl enable-linger '{username}'\n\nyou can use podman commands like:\n\n\\t\\tpodman pod ps\n\\t\\tpodman pod stats 'pod_{proj_name}'\n\\t\\tpodman pod logs --tail=10 -f 'pod_{proj_name}'\n\"\"\"\n        )\n    elif args.action in (\"list\", \"ls\"):\n        ls = glob.glob(os.path.expanduser(f\"~/{stacks_dir}/*.env\"))\n        for i in ls:\n            print(os.path.basename(i[:-4]))\n    elif args.action == \"create-unit\":\n        fn = \"/etc/systemd/user/podman-compose@.service\"\n        out = f\"\"\"\\\n# {fn}\n\n[Unit]\nDescription=%i rootless pod (podman-compose)\n\n[Service]\nType=simple\nEnvironmentFile=%h/{stacks_dir}/%i.env\nExecStartPre=-{script} up --no-start\nExecStartPre=/usr/bin/podman pod start pod_%i\nExecStart={script} wait\nExecStop=/usr/bin/podman pod stop pod_%i\n\n[Install]\nWantedBy=default.target\n\"\"\"\n        if os.access(os.path.dirname(fn), os.W_OK):\n            log.debug(\"writing [%s]: ...\", fn)\n            with open(fn, \"w\", encoding=\"utf-8\") as f:\n                f.write(out)\n            log.debug(\"writing [%s]: done.\", fn)\n            print(\n                \"\"\"\nwhile in your project type `podman-compose systemd -a register`\n\"\"\"\n            )\n        else:\n            print(out)\n            log.warning(\"Could not write to [%s], use 'sudo'\", fn)\n\n\n@cmd_run(podman_compose, \"pull\", \"pull stack images\")\nasync def compose_pull(compose, args):\n    img_containers = [cnt for cnt in compose.containers if \"image\" in cnt]\n    if args.services:\n        services = set(args.services)\n        img_containers = [cnt for cnt in img_containers if cnt[\"_service\"] in services]\n    images = {cnt[\"image\"] for cnt in img_containers}\n    if not args.force_local:\n        local_images = {cnt[\"image\"] for cnt in img_containers if is_local(cnt)}\n        images -= local_images\n\n    await asyncio.gather(*[compose.podman.run([], \"pull\", [image]) for image in images])\n\n\n@cmd_run(podman_compose, \"push\", \"push stack images\")\nasync def compose_push(compose, args):\n    services = set(args.services)\n    for cnt in compose.containers:\n        if \"build\" not in cnt:\n            continue\n        if services and cnt[\"_service\"] not in services:\n            continue\n        await compose.podman.run([], \"push\", [cnt[\"image\"]])\n\n\ndef container_to_build_args(compose, cnt, args, path_exists):\n    build_desc = cnt[\"build\"]\n    if not hasattr(build_desc, \"items\"):\n        build_desc = {\"context\": build_desc}\n    ctx = build_desc.get(\"context\", \".\")\n    dockerfile = build_desc.get(\"dockerfile\")\n    if dockerfile:\n        dockerfile = os.path.join(ctx, dockerfile)\n    else:\n        dockerfile_alts = [\n            \"Containerfile\",\n            \"ContainerFile\",\n            \"containerfile\",\n            \"Dockerfile\",\n            \"DockerFile\",\n            \"dockerfile\",\n        ]\n        for dockerfile in dockerfile_alts:\n            dockerfile = os.path.join(ctx, dockerfile)\n            if path_exists(dockerfile):\n                break\n    if not path_exists(dockerfile):\n        raise OSError(\"Dockerfile not found in \" + ctx)\n    build_args = [\"-f\", dockerfile, \"-t\", cnt[\"image\"]]\n    if \"platform\" in cnt:\n        build_args.extend([\"--platform\", cnt[\"platform\"]])\n    for secret in build_desc.get(\"secrets\", []):\n        build_args.extend(get_secret_args(compose, cnt, secret, podman_is_building=True))\n    for tag in build_desc.get(\"tags\", []):\n        build_args.extend([\"-t\", tag])\n    labels = build_desc.get(\"labels\", [])\n    if isinstance(labels, dict):\n        labels = [f\"{k}={v}\" for (k, v) in labels.items()]\n    for label in labels:\n        build_args.extend([\"--label\", label])\n    for additional_ctx in build_desc.get(\"additional_contexts\", {}):\n        build_args.extend([f\"--build-context={additional_ctx}\"])\n    if \"target\" in build_desc:\n        build_args.extend([\"--target\", build_desc[\"target\"]])\n    for agent_or_key in norm_as_list(build_desc.get(\"ssh\", {})):\n        build_args.extend([\"--ssh\", agent_or_key])\n    container_to_ulimit_build_args(cnt, build_args)\n    if getattr(args, \"no_cache\", None):\n        build_args.append(\"--no-cache\")\n    if getattr(args, \"pull_always\", None):\n        build_args.append(\"--pull-always\")\n    elif getattr(args, \"pull\", None):\n        build_args.append(\"--pull\")\n    args_list = norm_as_list(build_desc.get(\"args\", {}))\n    for build_arg in args_list + args.build_arg:\n        build_args.extend((\n            \"--build-arg\",\n            build_arg,\n        ))\n    for cache_img in build_desc.get(\"cache_from\", []):\n        build_args.extend([\"--cache-from\", cache_img])\n    for cache_img in build_desc.get(\"cache_to\", []):\n        build_args.extend([\"--cache-to\", cache_img])\n    build_args.append(ctx)\n    return build_args\n\n\nasync def build_one(compose, args, cnt):\n    if \"build\" not in cnt:\n        return None\n    if getattr(args, \"if_not_exists\", None):\n        try:\n            img_id = await compose.podman.output(\n                [], \"inspect\", [\"-t\", \"image\", \"-f\", \"{{.Id}}\", cnt[\"image\"]]\n            )\n        except subprocess.CalledProcessError:\n            img_id = None\n        if img_id:\n            return None\n\n    build_args = container_to_build_args(compose, cnt, args, os.path.exists)\n    status = await compose.podman.run([], \"build\", build_args)\n    return status\n\n\n@cmd_run(podman_compose, \"build\", \"build stack images\")\nasync def compose_build(compose, args):\n    tasks = []\n\n    if args.services:\n        container_names_by_service = compose.container_names_by_service\n        compose.assert_services(args.services)\n        for service in args.services:\n            cnt = compose.container_by_name[container_names_by_service[service][0]]\n            tasks.append(asyncio.create_task(build_one(compose, args, cnt)))\n\n    else:\n        for cnt in compose.containers:\n            tasks.append(asyncio.create_task(build_one(compose, args, cnt)))\n\n    status = 0\n    for t in asyncio.as_completed(tasks):\n        s = await t\n        if s is not None:\n            status = s\n\n    return status\n\n\nasync def pod_exists(compose, name):\n    exit_code = await compose.podman.run([], \"pod\", [\"exists\", name])\n    return exit_code == 0\n\n\nasync def create_pods(compose, args):  # pylint: disable=unused-argument\n    for pod in compose.pods:\n        if await pod_exists(compose, pod[\"name\"]):\n            continue\n\n        podman_args = [\n            \"create\",\n            \"--name=\" + pod[\"name\"],\n        ]\n        if args.pod_args:\n            podman_args.extend(shlex.split(args.pod_args))\n        # if compose.podman_version and not strverscmp_lt(compose.podman_version, \"3.4.0\"):\n        #    podman_args.append(\"--infra-name={}_infra\".format(pod[\"name\"]))\n        ports = pod.get(\"ports\", [])\n        if isinstance(ports, str):\n            ports = [ports]\n        for i in ports:\n            podman_args.extend([\"-p\", str(i)])\n        await compose.podman.run([], \"pod\", podman_args)\n\n\ndef get_excluded(compose, args):\n    excluded = set()\n    if args.services:\n        excluded = set(compose.services)\n        for service in args.services:\n            excluded -= set(x.name for x in compose.services[service][\"_deps\"])\n            excluded.discard(service)\n    log.debug(\"** excluding: %s\", excluded)\n    return excluded\n\n\nasync def check_dep_conditions(compose: PodmanCompose, deps: set) -> None:\n    \"\"\"Enforce that all specified conditions in deps are met\"\"\"\n    if not deps:\n        return\n\n    for condition in ServiceDependencyCondition:\n        deps_cd = []\n        for d in deps:\n            if d.condition == condition:\n                deps_cd.extend(compose.container_names_by_service[d.name])\n\n        if deps_cd:\n            # podman wait will return always with a rc -1.\n            while True:\n                try:\n                    await compose.podman.output(\n                        [], \"wait\", [f\"--condition={condition.value}\"] + deps_cd\n                    )\n                    log.debug(\n                        \"dependencies for condition %s have been fulfilled on containers %s\",\n                        condition.value,\n                        ', '.join(deps_cd),\n                    )\n                    break\n                except subprocess.CalledProcessError as _exc:\n                    output = list(\n                        ((_exc.stdout or b\"\") + (_exc.stderr or b\"\")).decode().split('\\n')\n                    )\n                    log.debug(\n                        'Podman wait returned an error (%d) when executing \"%s\": %s',\n                        _exc.returncode,\n                        _exc.cmd,\n                        output,\n                    )\n                await asyncio.sleep(1)\n\n\nasync def run_container(\n    compose: PodmanCompose, name: str, deps: set, command: tuple, log_formatter: str = None\n):\n    \"\"\"runs a container after waiting for its dependencies to be fulfilled\"\"\"\n\n    # wait for the dependencies to be fulfilled\n    if \"start\" in command:\n        log.debug(\"Checking dependencies prior to container %s start\", name)\n        await check_dep_conditions(compose, deps)\n\n    # start the container\n    log.debug(\"Starting task for container %s\", name)\n    return await compose.podman.run(*command, log_formatter=log_formatter)\n\n\n@cmd_run(podman_compose, \"up\", \"Create and start the entire stack or some of its services\")\nasync def compose_up(compose: PodmanCompose, args):\n    excluded = get_excluded(compose, args)\n    if not args.no_build:\n        # `podman build` does not cache, so don't always build\n        build_args = argparse.Namespace(if_not_exists=(not args.build), **args.__dict__)\n        if await compose.commands[\"build\"](compose, build_args) != 0:\n            log.error(\"Build command failed\")\n\n    hashes = (\n        (\n            await compose.podman.output(\n                [],\n                \"ps\",\n                [\n                    \"--filter\",\n                    f\"label=io.podman.compose.project={compose.project_name}\",\n                    \"-a\",\n                    \"--format\",\n                    '{{ index .Labels \"io.podman.compose.config-hash\"}}',\n                ],\n            )\n        )\n        .decode(\"utf-8\")\n        .splitlines()\n    )\n    diff_hashes = [i for i in hashes if i and i != compose.yaml_hash]\n    if args.force_recreate or len(diff_hashes):\n        log.info(\"recreating: ...\")\n        down_args = argparse.Namespace(**dict(args.__dict__, volumes=False))\n        await compose.commands[\"down\"](compose, down_args)\n        log.info(\"recreating: done\\n\\n\")\n    # args.no_recreate disables check for changes (which is not implemented)\n\n    podman_command = \"run\" if args.detach and not args.no_start else \"create\"\n\n    await create_pods(compose, args)\n    for cnt in compose.containers:\n        if cnt[\"_service\"] in excluded:\n            log.debug(\"** skipping: %s\", cnt[\"name\"])\n            continue\n        podman_args = await container_to_args(compose, cnt, detached=args.detach)\n        subproc = await compose.podman.run([], podman_command, podman_args)\n        if podman_command == \"run\" and subproc is not None:\n            await run_container(compose, cnt[\"name\"], cnt[\"_deps\"], ([], \"start\", [cnt[\"name\"]]))\n    if args.no_start or args.detach or args.dry_run:\n        return\n    # TODO: handle already existing\n    # TODO: if error creating do not enter loop\n    # TODO: colors if sys.stdout.isatty()\n    exit_code_from = args.__dict__.get(\"exit_code_from\")\n    if exit_code_from:\n        args.abort_on_container_exit = True\n\n    max_service_length = 0\n    for cnt in compose.containers:\n        curr_length = len(cnt[\"_service\"])\n        max_service_length = curr_length if curr_length > max_service_length else max_service_length\n\n    tasks = set()\n\n    loop = asyncio.get_event_loop()\n    loop.add_signal_handler(signal.SIGINT, lambda: [t.cancel(\"User exit\") for t in tasks])\n\n    for i, cnt in enumerate(compose.containers):\n        # Add colored service prefix to output by piping output through sed\n        color_idx = i % len(compose.console_colors)\n        color = compose.console_colors[color_idx]\n        space_suffix = \" \" * (max_service_length - len(cnt[\"_service\"]) + 1)\n        log_formatter = \"{}[{}]{}|\\x1b[0m\".format(color, cnt[\"_service\"], space_suffix)\n        if cnt[\"_service\"] in excluded:\n            log.debug(\"** skipping: %s\", cnt[\"name\"])\n            continue\n\n        tasks.add(\n            asyncio.create_task(\n                run_container(\n                    compose,\n                    cnt[\"name\"],\n                    cnt[\"_deps\"],\n                    ([], \"start\", [\"-a\", cnt[\"name\"]]),\n                    log_formatter=log_formatter,\n                ),\n                name=cnt[\"_service\"],\n            )\n        )\n\n    def _task_cancelled(task: Task) -> bool:\n        if task.cancelled():\n            return True\n        # Task.cancelling() is new in python 3.11\n        if sys.version_info >= (3, 11) and task.cancelling():\n            return True\n        return False\n\n    exit_code = 0\n    exiting = False\n    while tasks:\n        done, tasks = await asyncio.wait(tasks, return_when=asyncio.FIRST_COMPLETED)\n        if args.abort_on_container_exit:\n            if not exiting:\n                # If 2 containers exit at the exact same time, the cancellation of the other ones\n                # cause the status to overwrite. Sleeping for 1 seems to fix this and make it match\n                # docker-compose\n                await asyncio.sleep(1)\n                for t in tasks:\n                    if not _task_cancelled(t):\n                        t.cancel()\n            t: Task\n            exiting = True\n            for t in done:\n                if t.get_name() == exit_code_from:\n                    exit_code = t.result()\n\n    return exit_code\n\n\ndef get_volume_names(compose, cnt):\n    basedir = compose.dirname\n    srv_name = cnt[\"_service\"]\n    ls = []\n    for volume in cnt.get(\"volumes\", []):\n        if isinstance(volume, str):\n            volume = parse_short_mount(volume, basedir)\n        volume = fix_mount_dict(compose, volume, srv_name)\n        mount_type = volume[\"type\"]\n        if mount_type != \"volume\":\n            continue\n        volume_name = volume.get(\"_vol\", {}).get(\"name\")\n        ls.append(volume_name)\n    return ls\n\n\n@cmd_run(podman_compose, \"down\", \"tear down entire stack\")\nasync def compose_down(compose: PodmanCompose, args):\n    excluded = get_excluded(compose, args)\n    podman_args = []\n    timeout_global = getattr(args, \"timeout\", None)\n    containers = list(reversed(compose.containers))\n\n    down_tasks = []\n\n    for cnt in containers:\n        if cnt[\"_service\"] in excluded:\n            continue\n        podman_stop_args = [*podman_args]\n        timeout = timeout_global\n        if timeout is None:\n            timeout_str = cnt.get(\"stop_grace_period\", STOP_GRACE_PERIOD)\n            timeout = str_to_seconds(timeout_str)\n        if timeout is not None:\n            podman_stop_args.extend([\"-t\", str(timeout)])\n        down_tasks.append(\n            asyncio.create_task(\n                compose.podman.run([], \"stop\", [*podman_stop_args, cnt[\"name\"]]), name=cnt[\"name\"]\n            )\n        )\n    await asyncio.gather(*down_tasks)\n    for cnt in containers:\n        if cnt[\"_service\"] in excluded:\n            continue\n        await compose.podman.run([], \"rm\", [cnt[\"name\"]])\n    if args.remove_orphans:\n        names = (\n            (\n                await compose.podman.output(\n                    [],\n                    \"ps\",\n                    [\n                        \"--filter\",\n                        f\"label=io.podman.compose.project={compose.project_name}\",\n                        \"-a\",\n                        \"--format\",\n                        \"{{ .Names }}\",\n                    ],\n                )\n            )\n            .decode(\"utf-8\")\n            .splitlines()\n        )\n        for name in names:\n            await compose.podman.run([], \"stop\", [*podman_args, name])\n        for name in names:\n            await compose.podman.run([], \"rm\", [name])\n    if args.volumes:\n        vol_names_to_keep = set()\n        for cnt in containers:\n            if cnt[\"_service\"] not in excluded:\n                continue\n            vol_names_to_keep.update(get_volume_names(compose, cnt))\n        log.debug(\"keep %s\", vol_names_to_keep)\n        for volume_name in await compose.podman.volume_ls():\n            if volume_name in vol_names_to_keep:\n                continue\n            await compose.podman.run([], \"volume\", [\"rm\", volume_name])\n\n    if excluded:\n        return\n    for pod in compose.pods:\n        await compose.podman.run([], \"pod\", [\"rm\", pod[\"name\"]])\n    for network in await compose.podman.network_ls():\n        await compose.podman.run([], \"network\", [\"rm\", network])\n\n\n@cmd_run(podman_compose, \"ps\", \"show status of containers\")\nasync def compose_ps(compose, args):\n    ps_args = [\"-a\", \"--filter\", f\"label=io.podman.compose.project={compose.project_name}\"]\n    if args.quiet is True:\n        ps_args.extend([\"--format\", \"{{.ID}}\"])\n    elif args.format:\n        ps_args.extend([\"--format\", args.format])\n\n    await compose.podman.run(\n        [],\n        \"ps\",\n        ps_args,\n    )\n\n\n@cmd_run(\n    podman_compose,\n    \"run\",\n    \"create a container similar to a service to run a one-off command\",\n)\nasync def compose_run(compose, args):\n    await create_pods(compose, args)\n    compose.assert_services(args.service)\n    container_names = compose.container_names_by_service[args.service]\n    container_name = container_names[0]\n    cnt = dict(compose.container_by_name[container_name])\n    deps = cnt[\"_deps\"]\n    if deps and not args.no_deps:\n        up_args = argparse.Namespace(\n            **dict(\n                args.__dict__,\n                detach=True,\n                services=[x.name for x in deps],\n                # defaults\n                no_build=False,\n                build=None,\n                force_recreate=False,\n                no_start=False,\n                no_cache=False,\n                build_arg=[],\n                parallel=1,\n                remove_orphans=True,\n            )\n        )\n        await compose.commands[\"up\"](compose, up_args)\n\n    build_args = argparse.Namespace(\n        services=[args.service], if_not_exists=(not args.build), build_arg=[], **args.__dict__\n    )\n    await compose.commands[\"build\"](compose, build_args)\n\n    compose_run_update_container_from_args(compose, cnt, args)\n    # run podman\n    podman_args = await container_to_args(compose, cnt, args.detach)\n    if not args.detach:\n        podman_args.insert(1, \"-i\")\n        if args.rm:\n            podman_args.insert(1, \"--rm\")\n    p = await compose.podman.run([], \"run\", podman_args)\n    sys.exit(p)\n\n\ndef compose_run_update_container_from_args(compose, cnt, args):\n    # adjust one-off container options\n    name0 = \"{}_{}_tmp{}\".format(compose.project_name, args.service, random.randrange(0, 65536))\n    cnt[\"name\"] = args.name or name0\n    if args.entrypoint:\n        cnt[\"entrypoint\"] = args.entrypoint\n    if args.user:\n        cnt[\"user\"] = args.user\n    if args.workdir:\n        cnt[\"working_dir\"] = args.workdir\n    env = dict(cnt.get(\"environment\", {}))\n    if args.env:\n        additional_env_vars = dict(map(lambda each: each.split(\"=\", maxsplit=1), args.env))\n        env.update(additional_env_vars)\n        cnt[\"environment\"] = env\n    if not args.service_ports:\n        for k in (\"expose\", \"publishall\", \"ports\"):\n            try:\n                del cnt[k]\n            except KeyError:\n                pass\n    if args.publish:\n        ports = cnt.get(\"ports\", [])\n        ports.extend(norm_ports(args.publish))\n        cnt[\"ports\"] = ports\n    if args.volume:\n        # TODO: handle volumes\n        volumes = clone(cnt.get(\"volumes\", []))\n        volumes.extend(args.volume)\n        cnt[\"volumes\"] = volumes\n    cnt[\"tty\"] = not args.T\n    if args.cnt_command is not None and len(args.cnt_command) > 0:\n        cnt[\"command\"] = args.cnt_command\n    # can't restart and --rm\n    if args.rm and \"restart\" in cnt:\n        del cnt[\"restart\"]\n\n\n@cmd_run(podman_compose, \"exec\", \"execute a command in a running container\")\nasync def compose_exec(compose, args):\n    compose.assert_services(args.service)\n    container_names = compose.container_names_by_service[args.service]\n    container_name = container_names[args.index - 1]\n    cnt = compose.container_by_name[container_name]\n    podman_args = compose_exec_args(cnt, container_name, args)\n    p = await compose.podman.run([], \"exec\", podman_args)\n    sys.exit(p)\n\n\ndef compose_exec_args(cnt, container_name, args):\n    podman_args = [\"--interactive\"]\n    if args.privileged:\n        podman_args += [\"--privileged\"]\n    if args.user:\n        podman_args += [\"--user\", args.user]\n    if args.workdir:\n        podman_args += [\"--workdir\", args.workdir]\n    if not args.T:\n        podman_args += [\"--tty\"]\n    env = dict(cnt.get(\"environment\", {}))\n    if args.env:\n        additional_env_vars = dict(\n            map(lambda each: each.split(\"=\", maxsplit=1) if \"=\" in each else (each, None), args.env)\n        )\n        env.update(additional_env_vars)\n    for name, value in env.items():\n        podman_args += [\"--env\", f\"{name}\" if value is None else f\"{name}={value}\"]\n    podman_args += [container_name]\n    if args.cnt_command is not None and len(args.cnt_command) > 0:\n        podman_args += args.cnt_command\n    return podman_args\n\n\nasync def transfer_service_status(compose, args, action):\n    # TODO: handle dependencies, handle creations\n    container_names_by_service = compose.container_names_by_service\n    if not args.services:\n        args.services = container_names_by_service.keys()\n    compose.assert_services(args.services)\n    targets = []\n    for service in args.services:\n        if service not in container_names_by_service:\n            raise ValueError(\"unknown service: \" + service)\n        targets.extend(container_names_by_service[service])\n    if action in [\"stop\", \"restart\"]:\n        targets = list(reversed(targets))\n    timeout_global = getattr(args, \"timeout\", None)\n    tasks = []\n    for target in targets:\n        podman_args = []\n        if action != \"start\":\n            timeout = timeout_global\n            if timeout is None:\n                timeout_str = compose.container_by_name[target].get(\n                    \"stop_grace_period\", STOP_GRACE_PERIOD\n                )\n                timeout = str_to_seconds(timeout_str)\n            if timeout is not None:\n                podman_args.extend([\"-t\", str(timeout)])\n        tasks.append(asyncio.create_task(compose.podman.run([], action, podman_args + [target])))\n    await asyncio.gather(*tasks)\n\n\n@cmd_run(podman_compose, \"start\", \"start specific services\")\nasync def compose_start(compose, args):\n    await transfer_service_status(compose, args, \"start\")\n\n\n@cmd_run(podman_compose, \"stop\", \"stop specific services\")\nasync def compose_stop(compose, args):\n    await transfer_service_status(compose, args, \"stop\")\n\n\n@cmd_run(podman_compose, \"restart\", \"restart specific services\")\nasync def compose_restart(compose, args):\n    await transfer_service_status(compose, args, \"restart\")\n\n\n@cmd_run(podman_compose, \"logs\", \"show logs from services\")\nasync def compose_logs(compose, args):\n    container_names_by_service = compose.container_names_by_service\n    if not args.services and not args.latest:\n        args.services = container_names_by_service.keys()\n    compose.assert_services(args.services)\n    targets = []\n    for service in args.services:\n        targets.extend(container_names_by_service[service])\n    podman_args = []\n    if args.follow:\n        podman_args.append(\"-f\")\n    if args.latest:\n        podman_args.append(\"-l\")\n    if args.names:\n        podman_args.append(\"-n\")\n    if args.since:\n        podman_args.extend([\"--since\", args.since])\n    # the default value is to print all logs which is in podman = 0 and not\n    # needed to be passed\n    if args.tail and args.tail != \"all\":\n        podman_args.extend([\"--tail\", args.tail])\n    if args.timestamps:\n        podman_args.append(\"-t\")\n    if args.until:\n        podman_args.extend([\"--until\", args.until])\n    for target in targets:\n        podman_args.append(target)\n    await compose.podman.run([], \"logs\", podman_args)\n\n\n@cmd_run(podman_compose, \"config\", \"displays the compose file\")\nasync def compose_config(compose, args):\n    if args.services:\n        for service in compose.services:\n            print(service)\n        return\n    print(compose.merged_yaml)\n\n\n@cmd_run(podman_compose, \"port\", \"Prints the public port for a port binding.\")\nasync def compose_port(compose, args):\n    # TODO - deal with pod index\n    compose.assert_services(args.service)\n    containers = compose.container_names_by_service[args.service]\n    container_ports = list(\n        itertools.chain(*(compose.container_by_name[c][\"ports\"] for c in containers))\n    )\n\n    def _published_target(port_string):\n        published, target = port_string.split(\":\")[-2:]\n        return int(published), int(target)\n\n    select_udp = args.protocol == \"udp\"\n    published, target = None, None\n    for p in container_ports:\n        is_udp = p[-4:] == \"/udp\"\n\n        if select_udp and is_udp:\n            published, target = _published_target(p[-4:])\n        if not select_udp and not is_udp:\n            published, target = _published_target(p)\n\n        if target == args.private_port:\n            print(published)\n            return\n\n\n@cmd_run(podman_compose, \"pause\", \"Pause all running containers\")\nasync def compose_pause(compose, args):\n    container_names_by_service = compose.container_names_by_service\n    if not args.services:\n        args.services = container_names_by_service.keys()\n    targets = []\n    for service in args.services:\n        targets.extend(container_names_by_service[service])\n    await compose.podman.run([], \"pause\", targets)\n\n\n@cmd_run(podman_compose, \"unpause\", \"Unpause all running containers\")\nasync def compose_unpause(compose, args):\n    container_names_by_service = compose.container_names_by_service\n    if not args.services:\n        args.services = container_names_by_service.keys()\n    targets = []\n    for service in args.services:\n        targets.extend(container_names_by_service[service])\n    await compose.podman.run([], \"unpause\", targets)\n\n\n@cmd_run(podman_compose, \"kill\", \"Kill one or more running containers with a specific signal\")\nasync def compose_kill(compose, args):\n    # to ensure that the user did not execute the command by mistake\n    if not args.services and not args.all:\n        log.fatal(\n            \"Error: you must provide at least one service name or use (--all) to kill all services\"\n        )\n        sys.exit()\n\n    container_names_by_service = compose.container_names_by_service\n    podman_args = []\n\n    if args.signal:\n        podman_args.extend([\"--signal\", args.signal])\n\n    if args.all is True:\n        services = container_names_by_service.keys()\n        targets = []\n        for service in services:\n            targets.extend(container_names_by_service[service])\n        for target in targets:\n            podman_args.append(target)\n        await compose.podman.run([], \"kill\", podman_args)\n    elif args.services:\n        targets = []\n        for service in args.services:\n            targets.extend(container_names_by_service[service])\n        for target in targets:\n            podman_args.append(target)\n        await compose.podman.run([], \"kill\", podman_args)\n\n\n@cmd_run(\n    podman_compose,\n    \"stats\",\n    \"Display percentage of CPU, memory, network I/O, block I/O and PIDs for services.\",\n)\nasync def compose_stats(compose, args):\n    container_names_by_service = compose.container_names_by_service\n    if not args.services:\n        args.services = container_names_by_service.keys()\n    targets = []\n    podman_args = []\n    if args.interval:\n        podman_args.extend([\"--interval\", args.interval])\n    if args.format:\n        podman_args.extend([\"--format\", args.format])\n    if args.no_reset:\n        podman_args.append(\"--no-reset\")\n    if args.no_stream:\n        podman_args.append(\"--no-stream\")\n\n    for service in args.services:\n        targets.extend(container_names_by_service[service])\n    for target in targets:\n        podman_args.append(target)\n\n    try:\n        await compose.podman.run([], \"stats\", podman_args)\n    except KeyboardInterrupt:\n        pass\n\n\n@cmd_run(podman_compose, \"images\", \"List images used by the created containers\")\nasync def compose_images(compose, args):\n    img_containers = [cnt for cnt in compose.containers if \"image\" in cnt]\n    data = []\n    if args.quiet is True:\n        for img in img_containers:\n            name = img[\"name\"]\n            output = await compose.podman.output([], \"images\", [\"--quiet\", img[\"image\"]])\n            data.append(output.decode(\"utf-8\").split())\n    else:\n        data.append([\"CONTAINER\", \"REPOSITORY\", \"TAG\", \"IMAGE ID\", \"SIZE\", \"\"])\n        for img in img_containers:\n            name = img[\"name\"]\n            output = await compose.podman.output(\n                [],\n                \"images\",\n                [\n                    \"--format\",\n                    \"table \" + name + \" {{.Repository}} {{.Tag}} {{.ID}} {{.Size}}\",\n                    \"-n\",\n                    img[\"image\"],\n                ],\n            )\n            data.append(output.decode(\"utf-8\").split())\n\n    # Determine the maximum length of each column\n    column_widths = [max(map(len, column)) for column in zip(*data)]\n\n    # Print each row\n    for row in data:\n        # Format each cell using the maximum column width\n        formatted_row = [cell.ljust(width) for cell, width in zip(row, column_widths)]\n        formatted_row[-2:] = [\"\".join(formatted_row[-2:]).strip()]\n        print(\"\\t\".join(formatted_row))\n\n\n###################\n# command arguments parsing\n###################\n\n\n@cmd_parse(podman_compose, \"version\")\ndef compose_version_parse(parser):\n    parser.add_argument(\n        \"-f\",\n        \"--format\",\n        choices=[\"pretty\", \"json\"],\n        default=\"pretty\",\n        help=\"Format the output\",\n    )\n    parser.add_argument(\n        \"--short\",\n        action=\"store_true\",\n        help=\"Shows only Podman Compose's version number\",\n    )\n\n\n@cmd_parse(podman_compose, \"up\")\ndef compose_up_parse(parser):\n    parser.add_argument(\n        \"-d\",\n        \"--detach\",\n        action=\"store_true\",\n        help=\"Detached mode: Run container in the background, print new container name. \\\n            Incompatible with --abort-on-container-exit.\",\n    )\n    parser.add_argument(\"--no-color\", action=\"store_true\", help=\"Produce monochrome output.\")\n    parser.add_argument(\n        \"--quiet-pull\",\n        action=\"store_true\",\n        help=\"Pull without printing progress information.\",\n    )\n    parser.add_argument(\"--no-deps\", action=\"store_true\", help=\"Don't start linked services.\")\n    parser.add_argument(\n        \"--force-recreate\",\n        action=\"store_true\",\n        help=\"Recreate containers even if their configuration and image haven't changed.\",\n    )\n    parser.add_argument(\n        \"--always-recreate-deps\",\n        action=\"store_true\",\n        help=\"Recreate dependent containers. Incompatible with --no-recreate.\",\n    )\n    parser.add_argument(\n        \"--no-recreate\",\n        action=\"store_true\",\n        help=\"If containers already exist, don't recreate them. Incompatible with --force-recreate \"\n        \"and -V.\",\n    )\n    parser.add_argument(\n        \"--no-build\",\n        action=\"store_true\",\n        help=\"Don't build an image, even if it's missing.\",\n    )\n    parser.add_argument(\n        \"--no-start\",\n        action=\"store_true\",\n        help=\"Don't start the services after creating them.\",\n    )\n    parser.add_argument(\n        \"--build\", action=\"store_true\", help=\"Build images before starting containers.\"\n    )\n    parser.add_argument(\n        \"--abort-on-container-exit\",\n        action=\"store_true\",\n        help=\"Stops all containers if any container was stopped. Incompatible with -d.\",\n    )\n    parser.add_argument(\n        \"-t\",\n        \"--timeout\",\n        type=int,\n        default=None,\n        help=\"Use this timeout in seconds for container shutdown when attached or when containers \"\n        \"are already running. (default: 10)\",\n    )\n    parser.add_argument(\n        \"-V\",\n        \"--renew-anon-volumes\",\n        action=\"store_true\",\n        help=\"Recreate anonymous volumes instead of retrieving data from the previous containers.\",\n    )\n    parser.add_argument(\n        \"--remove-orphans\",\n        action=\"store_true\",\n        help=\"Remove containers for services not defined in the Compose file.\",\n    )\n    parser.add_argument(\n        \"--scale\",\n        metavar=\"SERVICE=NUM\",\n        action=\"append\",\n        help=\"Scale SERVICE to NUM instances. Overrides the `scale` setting in the Compose file if \"\n        \"present.\",\n    )\n    parser.add_argument(\n        \"--exit-code-from\",\n        metavar=\"SERVICE\",\n        type=str,\n        default=None,\n        help=\"Return the exit code of the selected service container. \"\n        \"Implies --abort-on-container-exit.\",\n    )\n\n\n@cmd_parse(podman_compose, \"down\")\ndef compose_down_parse(parser):\n    parser.add_argument(\n        \"-v\",\n        \"--volumes\",\n        action=\"store_true\",\n        default=False,\n        help=\"Remove named volumes declared in the `volumes` section of the Compose file and \"\n        \"anonymous volumes attached to containers.\",\n    )\n    parser.add_argument(\n        \"--remove-orphans\",\n        action=\"store_true\",\n        help=\"Remove containers for services not defined in the Compose file.\",\n    )\n\n\n@cmd_parse(podman_compose, \"run\")\ndef compose_run_parse(parser):\n    parser.add_argument(\n        \"--build\", action=\"store_true\", help=\"Build images before starting containers.\"\n    )\n    parser.add_argument(\n        \"-d\",\n        \"--detach\",\n        action=\"store_true\",\n        help=\"Detached mode: Run container in the background, print new container name.\",\n    )\n    parser.add_argument(\"--name\", type=str, default=None, help=\"Assign a name to the container\")\n    parser.add_argument(\n        \"--entrypoint\",\n        type=str,\n        default=None,\n        help=\"Override the entrypoint of the image.\",\n    )\n    parser.add_argument(\n        \"-e\",\n        \"--env\",\n        metavar=\"KEY=VAL\",\n        action=\"append\",\n        help=\"Set an environment variable (can be used multiple times)\",\n    )\n    parser.add_argument(\n        \"-l\",\n        \"--label\",\n        metavar=\"KEY=VAL\",\n        action=\"append\",\n        help=\"Add or override a label (can be used multiple times)\",\n    )\n    parser.add_argument(\n        \"-u\", \"--user\", type=str, default=None, help=\"Run as specified username or uid\"\n    )\n    parser.add_argument(\"--no-deps\", action=\"store_true\", help=\"Don't start linked services\")\n    parser.add_argument(\n        \"--rm\",\n        action=\"store_true\",\n        help=\"Remove container after run. Ignored in detached mode.\",\n    )\n    parser.add_argument(\n        \"-p\",\n        \"--publish\",\n        action=\"append\",\n        help=\"Publish a container's port(s) to the host (can be used multiple times)\",\n    )\n    parser.add_argument(\n        \"--service-ports\",\n        action=\"store_true\",\n        help=\"Run command with the service's ports enabled and mapped to the host.\",\n    )\n    parser.add_argument(\n        \"-v\",\n        \"--volume\",\n        action=\"append\",\n        help=\"Bind mount a volume (can be used multiple times)\",\n    )\n    parser.add_argument(\n        \"-T\",\n        action=\"store_true\",\n        help=\"Disable pseudo-tty allocation. By default `podman-compose run` allocates a TTY.\",\n    )\n    parser.add_argument(\n        \"-w\",\n        \"--workdir\",\n        type=str,\n        default=None,\n        help=\"Working directory inside the container\",\n    )\n    parser.add_argument(\"service\", metavar=\"service\", nargs=None, help=\"service name\")\n    parser.add_argument(\n        \"cnt_command\",\n        metavar=\"command\",\n        nargs=argparse.REMAINDER,\n        help=\"command and its arguments\",\n    )\n\n\n@cmd_parse(podman_compose, \"exec\")\ndef compose_exec_parse(parser):\n    parser.add_argument(\n        \"-d\",\n        \"--detach\",\n        action=\"store_true\",\n        help=\"Detached mode: Run container in the background, print new container name.\",\n    )\n    parser.add_argument(\n        \"--privileged\",\n        action=\"store_true\",\n        default=False,\n        help=\"Give the process extended Linux capabilities inside the container\",\n    )\n    parser.add_argument(\n        \"-u\", \"--user\", type=str, default=None, help=\"Run as specified username or uid\"\n    )\n    parser.add_argument(\n        \"-T\",\n        action=\"store_true\",\n        help=\"Disable pseudo-tty allocation. By default `podman-compose run` allocates a TTY.\",\n    )\n    parser.add_argument(\n        \"--index\",\n        type=int,\n        default=1,\n        help=\"Index of the container if there are multiple instances of a service\",\n    )\n    parser.add_argument(\n        \"-e\",\n        \"--env\",\n        metavar=\"KEY=VAL\",\n        action=\"append\",\n        help=\"Set an environment variable (can be used multiple times)\",\n    )\n    parser.add_argument(\n        \"-w\",\n        \"--workdir\",\n        type=str,\n        default=None,\n        help=\"Working directory inside the container\",\n    )\n    parser.add_argument(\"service\", metavar=\"service\", nargs=None, help=\"service name\")\n    parser.add_argument(\n        \"cnt_command\",\n        metavar=\"command\",\n        nargs=argparse.REMAINDER,\n        help=\"command and its arguments\",\n    )\n\n\n@cmd_parse(podman_compose, [\"down\", \"stop\", \"restart\"])\ndef compose_parse_timeout(parser):\n    parser.add_argument(\n        \"-t\",\n        \"--timeout\",\n        help=\"Specify a shutdown timeout in seconds. \",\n        type=int,\n        default=None,\n    )\n\n\n@cmd_parse(podman_compose, [\"logs\"])\ndef compose_logs_parse(parser):\n    parser.add_argument(\n        \"-f\",\n        \"--follow\",\n        action=\"store_true\",\n        help=\"Follow log output. The default is false\",\n    )\n    parser.add_argument(\n        \"-l\",\n        \"--latest\",\n        action=\"store_true\",\n        help=\"Act on the latest container podman is aware of\",\n    )\n    parser.add_argument(\n        \"-n\",\n        \"--names\",\n        action=\"store_true\",\n        help=\"Output the container name in the log\",\n    )\n    parser.add_argument(\"--since\", help=\"Show logs since TIMESTAMP\", type=str, default=None)\n    parser.add_argument(\"-t\", \"--timestamps\", action=\"store_true\", help=\"Show timestamps.\")\n    parser.add_argument(\n        \"--tail\",\n        help=\"Number of lines to show from the end of the logs for each container.\",\n        type=str,\n        default=\"all\",\n    )\n    parser.add_argument(\"--until\", help=\"Show logs until TIMESTAMP\", type=str, default=None)\n    parser.add_argument(\n        \"services\", metavar=\"services\", nargs=\"*\", default=None, help=\"service names\"\n    )\n\n\n@cmd_parse(podman_compose, \"systemd\")\ndef compose_systemd_parse(parser):\n    parser.add_argument(\n        \"-a\",\n        \"--action\",\n        choices=[\"register\", \"create-unit\", \"list\", \"ls\"],\n        default=\"register\",\n        help=\"create systemd unit file or register compose stack to it\",\n    )\n\n\n@cmd_parse(podman_compose, \"pull\")\ndef compose_pull_parse(parser):\n    parser.add_argument(\n        \"--force-local\",\n        action=\"store_true\",\n        default=False,\n        help=\"Also pull unprefixed images for services which have a build section\",\n    )\n    parser.add_argument(\"services\", metavar=\"services\", nargs=\"*\", help=\"services to pull\")\n\n\n@cmd_parse(podman_compose, \"push\")\ndef compose_push_parse(parser):\n    parser.add_argument(\n        \"--ignore-push-failures\",\n        action=\"store_true\",\n        help=\"Push what it can and ignores images with push failures. (not implemented)\",\n    )\n    parser.add_argument(\"services\", metavar=\"services\", nargs=\"*\", help=\"services to push\")\n\n\n@cmd_parse(podman_compose, \"ps\")\ndef compose_ps_parse(parser):\n    parser.add_argument(\"-q\", \"--quiet\", help=\"Only display container IDs\", action=\"store_true\")\n\n\n@cmd_parse(podman_compose, [\"build\", \"up\"])\ndef compose_build_up_parse(parser):\n    parser.add_argument(\n        \"--pull\",\n        help=\"attempt to pull a newer version of the image\",\n        action=\"store_true\",\n    )\n    parser.add_argument(\n        \"--pull-always\",\n        help=\"attempt to pull a newer version of the image, Raise an error even if the image is \"\n        \"present locally.\",\n        action=\"store_true\",\n    )\n    parser.add_argument(\n        \"--build-arg\",\n        metavar=\"key=val\",\n        action=\"append\",\n        default=[],\n        help=\"Set build-time variables for services.\",\n    )\n    parser.add_argument(\n        \"--no-cache\",\n        help=\"Do not use cache when building the image.\",\n        action=\"store_true\",\n    )\n\n\n@cmd_parse(podman_compose, [\"build\", \"up\", \"down\", \"start\", \"stop\", \"restart\"])\ndef compose_build_parse(parser):\n    parser.add_argument(\n        \"services\",\n        metavar=\"services\",\n        nargs=\"*\",\n        default=None,\n        help=\"affected services\",\n    )\n\n\n@cmd_parse(podman_compose, \"config\")\ndef compose_config_parse(parser):\n    parser.add_argument(\n        \"--no-normalize\", help=\"Don't normalize compose model.\", action=\"store_true\"\n    )\n    parser.add_argument(\n        \"--services\", help=\"Print the service names, one per line.\", action=\"store_true\"\n    )\n\n\n@cmd_parse(podman_compose, \"port\")\ndef compose_port_parse(parser):\n    parser.add_argument(\n        \"--index\",\n        type=int,\n        default=1,\n        help=\"index of the container if there are multiple instances of a service\",\n    )\n    parser.add_argument(\n        \"--protocol\",\n        choices=[\"tcp\", \"udp\"],\n        default=\"tcp\",\n        help=\"tcp or udp\",\n    )\n    parser.add_argument(\"service\", metavar=\"service\", nargs=None, help=\"service name\")\n    parser.add_argument(\n        \"private_port\",\n        metavar=\"private_port\",\n        nargs=None,\n        type=int,\n        help=\"private port\",\n    )\n\n\n@cmd_parse(podman_compose, [\"pause\", \"unpause\"])\ndef compose_pause_unpause_parse(parser):\n    parser.add_argument(\n        \"services\", metavar=\"services\", nargs=\"*\", default=None, help=\"service names\"\n    )\n\n\n@cmd_parse(podman_compose, [\"kill\"])\ndef compose_kill_parse(parser):\n    parser.add_argument(\n        \"services\", metavar=\"services\", nargs=\"*\", default=None, help=\"service names\"\n    )\n    parser.add_argument(\n        \"-s\",\n        \"--signal\",\n        type=str,\n        help=\"Signal to send to the container (default 'KILL')\",\n    )\n    parser.add_argument(\n        \"-a\",\n        \"--all\",\n        help=\"Signal all running containers\",\n        action=\"store_true\",\n    )\n\n\n@cmd_parse(podman_compose, \"images\")\ndef compose_images_parse(parser):\n    parser.add_argument(\"-q\", \"--quiet\", help=\"Only display images IDs\", action=\"store_true\")\n\n\n@cmd_parse(podman_compose, [\"stats\"])\ndef compose_stats_parse(parser):\n    parser.add_argument(\n        \"services\", metavar=\"services\", nargs=\"*\", default=None, help=\"service names\"\n    )\n    parser.add_argument(\n        \"-i\",\n        \"--interval\",\n        type=int,\n        help=\"Time in seconds between stats reports (default 5)\",\n    )\n    parser.add_argument(\n        \"--no-reset\",\n        help=\"Disable resetting the screen between intervals\",\n        action=\"store_true\",\n    )\n    parser.add_argument(\n        \"--no-stream\",\n        help=\"Disable streaming stats and only pull the first result\",\n        action=\"store_true\",\n    )\n\n\n@cmd_parse(podman_compose, [\"ps\", \"stats\"])\ndef compose_format_parse(parser):\n    parser.add_argument(\n        \"-f\",\n        \"--format\",\n        type=str,\n        help=\"Pretty-print container statistics to JSON or using a Go template\",\n    )\n\n\nasync def async_main():\n    await podman_compose.run()\n\n\ndef main():\n    asyncio.run(async_main())\n\n\nif __name__ == \"__main__\":\n    main()\n"
        },
        {
          "name": "pyproject.toml",
          "type": "blob",
          "size": 1.2119140625,
          "content": "[tool.ruff]\nline-length = 100\ntarget-version = \"py38\"\n\n[tool.ruff.lint]\nselect = [\"W\", \"E\", \"F\", \"I\"]\nignore = [\n]\n\n[tool.ruff.lint.isort]\nforce-single-line = true\n\n[tool.ruff.format]\npreview = true # needed for quote-style\nquote-style = \"preserve\"\n\n[tool.towncrier]\n    package = \"podman_compose\"\n    package_dir = \"master\"\n    directory = \"newsfragments\"\n    filename = \"docs/Changelog-new.md\"\n    template = \"scripts/Changelog-template.jinja\"\n    title_format = \"Version {version} ({project_date})\"\n    [[tool.towncrier.section]]\n        path = \"\"\n\n    [[tool.towncrier.type]]\n        directory = \"feature\"\n        name = \"Features\"\n        showcontent = true\n\n    [[tool.towncrier.type]]\n        directory = \"change\"\n        name = \"Changes\"\n        showcontent = true\n\n    [[tool.towncrier.type]]\n        directory = \"bugfix\"\n        name = \"Bug fixes\"\n        showcontent = true\n\n    [[tool.towncrier.type]]\n        directory = \"doc\"\n        name = \"Improved Documentation\"\n        showcontent = true\n\n    [[tool.towncrier.type]]\n        directory = \"removal\"\n        name = \"Deprecations and Removals\"\n        showcontent = true\n\n    [[tool.towncrier.type]]\n        directory = \"misc\"\n        name = \"Misc\"\n        showcontent = true\n"
        },
        {
          "name": "requirements.txt",
          "type": "blob",
          "size": 0.2275390625,
          "content": "# The order of packages is significant, because pip processes them in the order\n# of appearance. Changing the order has an impact on the overall integration\n# process, which may cause wedges in the gate later.\n\npyyaml\npython-dotenv\n\n"
        },
        {
          "name": "scripts",
          "type": "tree",
          "content": null
        },
        {
          "name": "setup.cfg",
          "type": "blob",
          "size": 0.146484375,
          "content": "[bdist_wheel]\nuniversal = 1\n\n[metadata]\nversion = attr: podman_compose.__version__\n\n[flake8]\n# The GitHub editor is 127 chars wide\nmax-line-length=127"
        },
        {
          "name": "setup.py",
          "type": "blob",
          "size": 1.60546875,
          "content": "# SPDX-License-Identifier: GPL-2.0\n\nimport os\n\nfrom setuptools import setup\n\ntry:\n    README = open(os.path.join(os.path.dirname(__file__), \"README.md\"), encoding=\"utf-8\").read()\nexcept:  # noqa: E722 # pylint: disable=bare-except\n    README = \"\"\n\nsetup(\n    name=\"podman-compose\",\n    description=\"A script to run docker-compose.yml using podman\",\n    long_description=README,\n    long_description_content_type=\"text/markdown\",\n    classifiers=[\n        \"Programming Language :: Python\",\n        \"Programming Language :: Python :: 3\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n        \"Programming Language :: Python :: 3.11\",\n        \"Programming Language :: Python :: 3.12\",\n        \"Programming Language :: Python :: 3.13\",\n        \"Intended Audience :: Developers\",\n        \"Operating System :: OS Independent\",\n        \"Development Status :: 3 - Alpha\",\n        \"Topic :: Software Development :: Build Tools\",\n        \"License :: OSI Approved :: GNU General Public License v2 (GPLv2)\",\n    ],\n    keywords=\"podman, podman-compose\",\n    author=\"Muayyad Alsadi\",\n    author_email=\"alsadi@gmail.com\",\n    url=\"https://github.com/containers/podman-compose\",\n    py_modules=[\"podman_compose\"],\n    entry_points={\"console_scripts\": [\"podman-compose = podman_compose:main\"]},\n    include_package_data=True,\n    license=\"GPL-2.0-only\",\n    install_requires=[\n        \"pyyaml\",\n        \"python-dotenv\",\n    ],\n    extras_require={\"devel\": [\"ruff\", \"pre-commit\", \"coverage\", \"parameterized\"]},\n    # test_suite='tests',\n    # tests_require=[\n    #     'coverage',\n    #     'tox',\n    # ]\n)\n"
        },
        {
          "name": "test-requirements.txt",
          "type": "blob",
          "size": 0.705078125,
          "content": "-e .\ncoverage==7.4.3\nparameterized==0.9.0\npytest==8.0.2\ntox==4.13.0\nruff==0.3.1\npylint==3.1.0\n\n# The packages below are transitive dependencies of the packages above and are included here\n# to make testing reproducible.\n# To refresh, create a new virtualenv and do:\n#  pip install -r requirements.txt -r test-requirements.txt\n#  pip freeze > test-requirements.txt\n# and edit test-requirements.txt to add this comment\n\nastroid==3.1.0\ncachetools==5.3.3\nchardet==5.2.0\ncolorama==0.4.6\ndill==0.3.8\ndistlib==0.3.8\nfilelock==3.13.1\niniconfig==2.0.0\nisort==5.13.2\nmccabe==0.7.0\npackaging==23.2\nplatformdirs==4.2.0\npluggy==1.4.0\npyproject-api==1.6.1\npython-dotenv==1.0.1\nPyYAML==6.0.1\nrequests\ntomlkit==0.12.4\nvirtualenv==20.25.1\n"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}