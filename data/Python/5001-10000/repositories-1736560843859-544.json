{
  "metadata": {
    "timestamp": 1736560843859,
    "page": 544,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjU1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "pymupdf/PyMuPDF",
      "stars": 6190,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.0126953125,
          "content": "*.pdf binary\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.052734375,
          "content": "*.pyc\n*.so\n*.o\n*.swp\nbuild/\ndemo/README.rst\ndocs/build"
        },
        {
          "name": ".python-version",
          "type": "blob",
          "size": 0.0048828125,
          "content": "3.12\n"
        },
        {
          "name": ".readthedocs.yaml",
          "type": "blob",
          "size": 0.716796875,
          "content": "# .readthedocs.yaml\r\n# Read the Docs configuration file\r\n# See https://docs.readthedocs.io/en/stable/config-file/v2.html for details\r\n\r\n# Required\r\nversion: 2\r\n\r\n# Set the version of Python and other tools you might need\r\nbuild:\r\n  os: ubuntu-20.04\r\n  tools:\r\n    python: \"3.9\"\r\n    # You can also specify other tool versions:\r\n    # nodejs: \"16\"\r\n    # rust: \"1.55\"\r\n    # golang: \"1.17\"\r\n\r\n# Build documentation in the docs/ directory with Sphinx\r\nsphinx:\r\n   configuration: docs/conf.py\r\n\r\n# If using Sphinx, optionally build your docs in additional formats such as PDF\r\nformats:\r\n   - pdf\r\n\r\n# Optionally declare the Python requirements required to build your docs\r\npython:\r\n   install:\r\n   - requirements: docs/requirements.txt\r\n"
        },
        {
          "name": ".vs",
          "type": "tree",
          "content": null
        },
        {
          "name": "COPYING",
          "type": "blob",
          "size": 33.7109375,
          "content": "                    GNU AFFERO GENERAL PUBLIC LICENSE\n                       Version 3, 19 November 2007\n\n Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n                            Preamble\n\n  The GNU Affero General Public License is a free, copyleft license for\nsoftware and other kinds of works, specifically designed to ensure\ncooperation with the community in the case of network server software.\n\n  The licenses for most software and other practical works are designed\nto take away your freedom to share and change the works.  By contrast,\nour General Public Licenses are intended to guarantee your freedom to\nshare and change all versions of a program--to make sure it remains free\nsoftware for all its users.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthem if you wish), that you receive source code or can get it if you\nwant it, that you can change the software or use pieces of it in new\nfree programs, and that you know you can do these things.\n\n  Developers that use our General Public Licenses protect your rights\nwith two steps: (1) assert copyright on the software, and (2) offer\nyou this License which gives you legal permission to copy, distribute\nand/or modify the software.\n\n  A secondary benefit of defending all users' freedom is that\nimprovements made in alternate versions of the program, if they\nreceive widespread use, become available for other developers to\nincorporate.  Many developers of free software are heartened and\nencouraged by the resulting cooperation.  However, in the case of\nsoftware used on network servers, this result may fail to come about.\nThe GNU General Public License permits making a modified version and\nletting the public access it on a server without ever releasing its\nsource code to the public.\n\n  The GNU Affero General Public License is designed specifically to\nensure that, in such cases, the modified source code becomes available\nto the community.  It requires the operator of a network server to\nprovide the source code of the modified version running there to the\nusers of that server.  Therefore, public use of a modified version, on\na publicly accessible server, gives the public access to the source\ncode of the modified version.\n\n  An older license, called the Affero General Public License and\npublished by Affero, was designed to accomplish similar goals.  This is\na different license, not a version of the Affero GPL, but Affero has\nreleased a new version of the Affero GPL which permits relicensing under\nthis license.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n                       TERMS AND CONDITIONS\n\n  0. Definitions.\n\n  \"This License\" refers to version 3 of the GNU Affero General Public License.\n\n  \"Copyright\" also means copyright-like laws that apply to other kinds of\nworks, such as semiconductor masks.\n\n  \"The Program\" refers to any copyrightable work licensed under this\nLicense.  Each licensee is addressed as \"you\".  \"Licensees\" and\n\"recipients\" may be individuals or organizations.\n\n  To \"modify\" a work means to copy from or adapt all or part of the work\nin a fashion requiring copyright permission, other than the making of an\nexact copy.  The resulting work is called a \"modified version\" of the\nearlier work or a work \"based on\" the earlier work.\n\n  A \"covered work\" means either the unmodified Program or a work based\non the Program.\n\n  To \"propagate\" a work means to do anything with it that, without\npermission, would make you directly or secondarily liable for\ninfringement under applicable copyright law, except executing it on a\ncomputer or modifying a private copy.  Propagation includes copying,\ndistribution (with or without modification), making available to the\npublic, and in some countries other activities as well.\n\n  To \"convey\" a work means any kind of propagation that enables other\nparties to make or receive copies.  Mere interaction with a user through\na computer network, with no transfer of a copy, is not conveying.\n\n  An interactive user interface displays \"Appropriate Legal Notices\"\nto the extent that it includes a convenient and prominently visible\nfeature that (1) displays an appropriate copyright notice, and (2)\ntells the user that there is no warranty for the work (except to the\nextent that warranties are provided), that licensees may convey the\nwork under this License, and how to view a copy of this License.  If\nthe interface presents a list of user commands or options, such as a\nmenu, a prominent item in the list meets this criterion.\n\n  1. Source Code.\n\n  The \"source code\" for a work means the preferred form of the work\nfor making modifications to it.  \"Object code\" means any non-source\nform of a work.\n\n  A \"Standard Interface\" means an interface that either is an official\nstandard defined by a recognized standards body, or, in the case of\ninterfaces specified for a particular programming language, one that\nis widely used among developers working in that language.\n\n  The \"System Libraries\" of an executable work include anything, other\nthan the work as a whole, that (a) is included in the normal form of\npackaging a Major Component, but which is not part of that Major\nComponent, and (b) serves only to enable use of the work with that\nMajor Component, or to implement a Standard Interface for which an\nimplementation is available to the public in source code form.  A\n\"Major Component\", in this context, means a major essential component\n(kernel, window system, and so on) of the specific operating system\n(if any) on which the executable work runs, or a compiler used to\nproduce the work, or an object code interpreter used to run it.\n\n  The \"Corresponding Source\" for a work in object code form means all\nthe source code needed to generate, install, and (for an executable\nwork) run the object code and to modify the work, including scripts to\ncontrol those activities.  However, it does not include the work's\nSystem Libraries, or general-purpose tools or generally available free\nprograms which are used unmodified in performing those activities but\nwhich are not part of the work.  For example, Corresponding Source\nincludes interface definition files associated with source files for\nthe work, and the source code for shared libraries and dynamically\nlinked subprograms that the work is specifically designed to require,\nsuch as by intimate data communication or control flow between those\nsubprograms and other parts of the work.\n\n  The Corresponding Source need not include anything that users\ncan regenerate automatically from other parts of the Corresponding\nSource.\n\n  The Corresponding Source for a work in source code form is that\nsame work.\n\n  2. Basic Permissions.\n\n  All rights granted under this License are granted for the term of\ncopyright on the Program, and are irrevocable provided the stated\nconditions are met.  This License explicitly affirms your unlimited\npermission to run the unmodified Program.  The output from running a\ncovered work is covered by this License only if the output, given its\ncontent, constitutes a covered work.  This License acknowledges your\nrights of fair use or other equivalent, as provided by copyright law.\n\n  You may make, run and propagate covered works that you do not\nconvey, without conditions so long as your license otherwise remains\nin force.  You may convey covered works to others for the sole purpose\nof having them make modifications exclusively for you, or provide you\nwith facilities for running those works, provided that you comply with\nthe terms of this License in conveying all material for which you do\nnot control copyright.  Those thus making or running the covered works\nfor you must do so exclusively on your behalf, under your direction\nand control, on terms that prohibit them from making any copies of\nyour copyrighted material outside their relationship with you.\n\n  Conveying under any other circumstances is permitted solely under\nthe conditions stated below.  Sublicensing is not allowed; section 10\nmakes it unnecessary.\n\n  3. Protecting Users' Legal Rights From Anti-Circumvention Law.\n\n  No covered work shall be deemed part of an effective technological\nmeasure under any applicable law fulfilling obligations under article\n11 of the WIPO copyright treaty adopted on 20 December 1996, or\nsimilar laws prohibiting or restricting circumvention of such\nmeasures.\n\n  When you convey a covered work, you waive any legal power to forbid\ncircumvention of technological measures to the extent such circumvention\nis effected by exercising rights under this License with respect to\nthe covered work, and you disclaim any intention to limit operation or\nmodification of the work as a means of enforcing, against the work's\nusers, your or third parties' legal rights to forbid circumvention of\ntechnological measures.\n\n  4. Conveying Verbatim Copies.\n\n  You may convey verbatim copies of the Program's source code as you\nreceive it, in any medium, provided that you conspicuously and\nappropriately publish on each copy an appropriate copyright notice;\nkeep intact all notices stating that this License and any\nnon-permissive terms added in accord with section 7 apply to the code;\nkeep intact all notices of the absence of any warranty; and give all\nrecipients a copy of this License along with the Program.\n\n  You may charge any price or no price for each copy that you convey,\nand you may offer support or warranty protection for a fee.\n\n  5. Conveying Modified Source Versions.\n\n  You may convey a work based on the Program, or the modifications to\nproduce it from the Program, in the form of source code under the\nterms of section 4, provided that you also meet all of these conditions:\n\n    a) The work must carry prominent notices stating that you modified\n    it, and giving a relevant date.\n\n    b) The work must carry prominent notices stating that it is\n    released under this License and any conditions added under section\n    7.  This requirement modifies the requirement in section 4 to\n    \"keep intact all notices\".\n\n    c) You must license the entire work, as a whole, under this\n    License to anyone who comes into possession of a copy.  This\n    License will therefore apply, along with any applicable section 7\n    additional terms, to the whole of the work, and all its parts,\n    regardless of how they are packaged.  This License gives no\n    permission to license the work in any other way, but it does not\n    invalidate such permission if you have separately received it.\n\n    d) If the work has interactive user interfaces, each must display\n    Appropriate Legal Notices; however, if the Program has interactive\n    interfaces that do not display Appropriate Legal Notices, your\n    work need not make them do so.\n\n  A compilation of a covered work with other separate and independent\nworks, which are not by their nature extensions of the covered work,\nand which are not combined with it such as to form a larger program,\nin or on a volume of a storage or distribution medium, is called an\n\"aggregate\" if the compilation and its resulting copyright are not\nused to limit the access or legal rights of the compilation's users\nbeyond what the individual works permit.  Inclusion of a covered work\nin an aggregate does not cause this License to apply to the other\nparts of the aggregate.\n\n  6. Conveying Non-Source Forms.\n\n  You may convey a covered work in object code form under the terms\nof sections 4 and 5, provided that you also convey the\nmachine-readable Corresponding Source under the terms of this License,\nin one of these ways:\n\n    a) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by the\n    Corresponding Source fixed on a durable physical medium\n    customarily used for software interchange.\n\n    b) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by a\n    written offer, valid for at least three years and valid for as\n    long as you offer spare parts or customer support for that product\n    model, to give anyone who possesses the object code either (1) a\n    copy of the Corresponding Source for all the software in the\n    product that is covered by this License, on a durable physical\n    medium customarily used for software interchange, for a price no\n    more than your reasonable cost of physically performing this\n    conveying of source, or (2) access to copy the\n    Corresponding Source from a network server at no charge.\n\n    c) Convey individual copies of the object code with a copy of the\n    written offer to provide the Corresponding Source.  This\n    alternative is allowed only occasionally and noncommercially, and\n    only if you received the object code with such an offer, in accord\n    with subsection 6b.\n\n    d) Convey the object code by offering access from a designated\n    place (gratis or for a charge), and offer equivalent access to the\n    Corresponding Source in the same way through the same place at no\n    further charge.  You need not require recipients to copy the\n    Corresponding Source along with the object code.  If the place to\n    copy the object code is a network server, the Corresponding Source\n    may be on a different server (operated by you or a third party)\n    that supports equivalent copying facilities, provided you maintain\n    clear directions next to the object code saying where to find the\n    Corresponding Source.  Regardless of what server hosts the\n    Corresponding Source, you remain obligated to ensure that it is\n    available for as long as needed to satisfy these requirements.\n\n    e) Convey the object code using peer-to-peer transmission, provided\n    you inform other peers where the object code and Corresponding\n    Source of the work are being offered to the general public at no\n    charge under subsection 6d.\n\n  A separable portion of the object code, whose source code is excluded\nfrom the Corresponding Source as a System Library, need not be\nincluded in conveying the object code work.\n\n  A \"User Product\" is either (1) a \"consumer product\", which means any\ntangible personal property which is normally used for personal, family,\nor household purposes, or (2) anything designed or sold for incorporation\ninto a dwelling.  In determining whether a product is a consumer product,\ndoubtful cases shall be resolved in favor of coverage.  For a particular\nproduct received by a particular user, \"normally used\" refers to a\ntypical or common use of that class of product, regardless of the status\nof the particular user or of the way in which the particular user\nactually uses, or expects or is expected to use, the product.  A product\nis a consumer product regardless of whether the product has substantial\ncommercial, industrial or non-consumer uses, unless such uses represent\nthe only significant mode of use of the product.\n\n  \"Installation Information\" for a User Product means any methods,\nprocedures, authorization keys, or other information required to install\nand execute modified versions of a covered work in that User Product from\na modified version of its Corresponding Source.  The information must\nsuffice to ensure that the continued functioning of the modified object\ncode is in no case prevented or interfered with solely because\nmodification has been made.\n\n  If you convey an object code work under this section in, or with, or\nspecifically for use in, a User Product, and the conveying occurs as\npart of a transaction in which the right of possession and use of the\nUser Product is transferred to the recipient in perpetuity or for a\nfixed term (regardless of how the transaction is characterized), the\nCorresponding Source conveyed under this section must be accompanied\nby the Installation Information.  But this requirement does not apply\nif neither you nor any third party retains the ability to install\nmodified object code on the User Product (for example, the work has\nbeen installed in ROM).\n\n  The requirement to provide Installation Information does not include a\nrequirement to continue to provide support service, warranty, or updates\nfor a work that has been modified or installed by the recipient, or for\nthe User Product in which it has been modified or installed.  Access to a\nnetwork may be denied when the modification itself materially and\nadversely affects the operation of the network or violates the rules and\nprotocols for communication across the network.\n\n  Corresponding Source conveyed, and Installation Information provided,\nin accord with this section must be in a format that is publicly\ndocumented (and with an implementation available to the public in\nsource code form), and must require no special password or key for\nunpacking, reading or copying.\n\n  7. Additional Terms.\n\n  \"Additional permissions\" are terms that supplement the terms of this\nLicense by making exceptions from one or more of its conditions.\nAdditional permissions that are applicable to the entire Program shall\nbe treated as though they were included in this License, to the extent\nthat they are valid under applicable law.  If additional permissions\napply only to part of the Program, that part may be used separately\nunder those permissions, but the entire Program remains governed by\nthis License without regard to the additional permissions.\n\n  When you convey a copy of a covered work, you may at your option\nremove any additional permissions from that copy, or from any part of\nit.  (Additional permissions may be written to require their own\nremoval in certain cases when you modify the work.)  You may place\nadditional permissions on material, added by you to a covered work,\nfor which you have or can give appropriate copyright permission.\n\n  Notwithstanding any other provision of this License, for material you\nadd to a covered work, you may (if authorized by the copyright holders of\nthat material) supplement the terms of this License with terms:\n\n    a) Disclaiming warranty or limiting liability differently from the\n    terms of sections 15 and 16 of this License; or\n\n    b) Requiring preservation of specified reasonable legal notices or\n    author attributions in that material or in the Appropriate Legal\n    Notices displayed by works containing it; or\n\n    c) Prohibiting misrepresentation of the origin of that material, or\n    requiring that modified versions of such material be marked in\n    reasonable ways as different from the original version; or\n\n    d) Limiting the use for publicity purposes of names of licensors or\n    authors of the material; or\n\n    e) Declining to grant rights under trademark law for use of some\n    trade names, trademarks, or service marks; or\n\n    f) Requiring indemnification of licensors and authors of that\n    material by anyone who conveys the material (or modified versions of\n    it) with contractual assumptions of liability to the recipient, for\n    any liability that these contractual assumptions directly impose on\n    those licensors and authors.\n\n  All other non-permissive additional terms are considered \"further\nrestrictions\" within the meaning of section 10.  If the Program as you\nreceived it, or any part of it, contains a notice stating that it is\ngoverned by this License along with a term that is a further\nrestriction, you may remove that term.  If a license document contains\na further restriction but permits relicensing or conveying under this\nLicense, you may add to a covered work material governed by the terms\nof that license document, provided that the further restriction does\nnot survive such relicensing or conveying.\n\n  If you add terms to a covered work in accord with this section, you\nmust place, in the relevant source files, a statement of the\nadditional terms that apply to those files, or a notice indicating\nwhere to find the applicable terms.\n\n  Additional terms, permissive or non-permissive, may be stated in the\nform of a separately written license, or stated as exceptions;\nthe above requirements apply either way.\n\n  8. Termination.\n\n  You may not propagate or modify a covered work except as expressly\nprovided under this License.  Any attempt otherwise to propagate or\nmodify it is void, and will automatically terminate your rights under\nthis License (including any patent licenses granted under the third\nparagraph of section 11).\n\n  However, if you cease all violation of this License, then your\nlicense from a particular copyright holder is reinstated (a)\nprovisionally, unless and until the copyright holder explicitly and\nfinally terminates your license, and (b) permanently, if the copyright\nholder fails to notify you of the violation by some reasonable means\nprior to 60 days after the cessation.\n\n  Moreover, your license from a particular copyright holder is\nreinstated permanently if the copyright holder notifies you of the\nviolation by some reasonable means, this is the first time you have\nreceived notice of violation of this License (for any work) from that\ncopyright holder, and you cure the violation prior to 30 days after\nyour receipt of the notice.\n\n  Termination of your rights under this section does not terminate the\nlicenses of parties who have received copies or rights from you under\nthis License.  If your rights have been terminated and not permanently\nreinstated, you do not qualify to receive new licenses for the same\nmaterial under section 10.\n\n  9. Acceptance Not Required for Having Copies.\n\n  You are not required to accept this License in order to receive or\nrun a copy of the Program.  Ancillary propagation of a covered work\noccurring solely as a consequence of using peer-to-peer transmission\nto receive a copy likewise does not require acceptance.  However,\nnothing other than this License grants you permission to propagate or\nmodify any covered work.  These actions infringe copyright if you do\nnot accept this License.  Therefore, by modifying or propagating a\ncovered work, you indicate your acceptance of this License to do so.\n\n  10. Automatic Licensing of Downstream Recipients.\n\n  Each time you convey a covered work, the recipient automatically\nreceives a license from the original licensors, to run, modify and\npropagate that work, subject to this License.  You are not responsible\nfor enforcing compliance by third parties with this License.\n\n  An \"entity transaction\" is a transaction transferring control of an\norganization, or substantially all assets of one, or subdividing an\norganization, or merging organizations.  If propagation of a covered\nwork results from an entity transaction, each party to that\ntransaction who receives a copy of the work also receives whatever\nlicenses to the work the party's predecessor in interest had or could\ngive under the previous paragraph, plus a right to possession of the\nCorresponding Source of the work from the predecessor in interest, if\nthe predecessor has it or can get it with reasonable efforts.\n\n  You may not impose any further restrictions on the exercise of the\nrights granted or affirmed under this License.  For example, you may\nnot impose a license fee, royalty, or other charge for exercise of\nrights granted under this License, and you may not initiate litigation\n(including a cross-claim or counterclaim in a lawsuit) alleging that\nany patent claim is infringed by making, using, selling, offering for\nsale, or importing the Program or any portion of it.\n\n  11. Patents.\n\n  A \"contributor\" is a copyright holder who authorizes use under this\nLicense of the Program or a work on which the Program is based.  The\nwork thus licensed is called the contributor's \"contributor version\".\n\n  A contributor's \"essential patent claims\" are all patent claims\nowned or controlled by the contributor, whether already acquired or\nhereafter acquired, that would be infringed by some manner, permitted\nby this License, of making, using, or selling its contributor version,\nbut do not include claims that would be infringed only as a\nconsequence of further modification of the contributor version.  For\npurposes of this definition, \"control\" includes the right to grant\npatent sublicenses in a manner consistent with the requirements of\nthis License.\n\n  Each contributor grants you a non-exclusive, worldwide, royalty-free\npatent license under the contributor's essential patent claims, to\nmake, use, sell, offer for sale, import and otherwise run, modify and\npropagate the contents of its contributor version.\n\n  In the following three paragraphs, a \"patent license\" is any express\nagreement or commitment, however denominated, not to enforce a patent\n(such as an express permission to practice a patent or covenant not to\nsue for patent infringement).  To \"grant\" such a patent license to a\nparty means to make such an agreement or commitment not to enforce a\npatent against the party.\n\n  If you convey a covered work, knowingly relying on a patent license,\nand the Corresponding Source of the work is not available for anyone\nto copy, free of charge and under the terms of this License, through a\npublicly available network server or other readily accessible means,\nthen you must either (1) cause the Corresponding Source to be so\navailable, or (2) arrange to deprive yourself of the benefit of the\npatent license for this particular work, or (3) arrange, in a manner\nconsistent with the requirements of this License, to extend the patent\nlicense to downstream recipients.  \"Knowingly relying\" means you have\nactual knowledge that, but for the patent license, your conveying the\ncovered work in a country, or your recipient's use of the covered work\nin a country, would infringe one or more identifiable patents in that\ncountry that you have reason to believe are valid.\n\n  If, pursuant to or in connection with a single transaction or\narrangement, you convey, or propagate by procuring conveyance of, a\ncovered work, and grant a patent license to some of the parties\nreceiving the covered work authorizing them to use, propagate, modify\nor convey a specific copy of the covered work, then the patent license\nyou grant is automatically extended to all recipients of the covered\nwork and works based on it.\n\n  A patent license is \"discriminatory\" if it does not include within\nthe scope of its coverage, prohibits the exercise of, or is\nconditioned on the non-exercise of one or more of the rights that are\nspecifically granted under this License.  You may not convey a covered\nwork if you are a party to an arrangement with a third party that is\nin the business of distributing software, under which you make payment\nto the third party based on the extent of your activity of conveying\nthe work, and under which the third party grants, to any of the\nparties who would receive the covered work from you, a discriminatory\npatent license (a) in connection with copies of the covered work\nconveyed by you (or copies made from those copies), or (b) primarily\nfor and in connection with specific products or compilations that\ncontain the covered work, unless you entered into that arrangement,\nor that patent license was granted, prior to 28 March 2007.\n\n  Nothing in this License shall be construed as excluding or limiting\nany implied license or other defenses to infringement that may\notherwise be available to you under applicable patent law.\n\n  12. No Surrender of Others' Freedom.\n\n  If conditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot convey a\ncovered work so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you may\nnot convey it at all.  For example, if you agree to terms that obligate you\nto collect a royalty for further conveying from those to whom you convey\nthe Program, the only way you could satisfy both those terms and this\nLicense would be to refrain entirely from conveying the Program.\n\n  13. Remote Network Interaction; Use with the GNU General Public License.\n\n  Notwithstanding any other provision of this License, if you modify the\nProgram, your modified version must prominently offer all users\ninteracting with it remotely through a computer network (if your version\nsupports such interaction) an opportunity to receive the Corresponding\nSource of your version by providing access to the Corresponding Source\nfrom a network server at no charge, through some standard or customary\nmeans of facilitating copying of software.  This Corresponding Source\nshall include the Corresponding Source for any work covered by version 3\nof the GNU General Public License that is incorporated pursuant to the\nfollowing paragraph.\n\n  Notwithstanding any other provision of this License, you have\npermission to link or combine any covered work with a work licensed\nunder version 3 of the GNU General Public License into a single\ncombined work, and to convey the resulting work.  The terms of this\nLicense will continue to apply to the part which is the covered work,\nbut the work with which it is combined will remain governed by version\n3 of the GNU General Public License.\n\n  14. Revised Versions of this License.\n\n  The Free Software Foundation may publish revised and/or new versions of\nthe GNU Affero General Public License from time to time.  Such new versions\nwill be similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\n  Each version is given a distinguishing version number.  If the\nProgram specifies that a certain numbered version of the GNU Affero General\nPublic License \"or any later version\" applies to it, you have the\noption of following the terms and conditions either of that numbered\nversion or of any later version published by the Free Software\nFoundation.  If the Program does not specify a version number of the\nGNU Affero General Public License, you may choose any version ever published\nby the Free Software Foundation.\n\n  If the Program specifies that a proxy can decide which future\nversions of the GNU Affero General Public License can be used, that proxy's\npublic statement of acceptance of a version permanently authorizes you\nto choose that version for the Program.\n\n  Later license versions may give you additional or different\npermissions.  However, no additional obligations are imposed on any\nauthor or copyright holder as a result of your choosing to follow a\nlater version.\n\n  15. Disclaimer of Warranty.\n\n  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY\nAPPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT\nHOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY\nOF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,\nTHE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\nPURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM\nIS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF\nALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n\n  16. Limitation of Liability.\n\n  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS\nTHE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY\nGENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE\nUSE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF\nDATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD\nPARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),\nEVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF\nSUCH DAMAGES.\n\n  17. Interpretation of Sections 15 and 16.\n\n  If the disclaimer of warranty and limitation of liability provided\nabove cannot be given local legal effect according to their terms,\nreviewing courts shall apply local law that most closely approximates\nan absolute waiver of all civil liability in connection with the\nProgram, unless a warranty or assumption of liability accompanies a\ncopy of the Program in return for a fee.\n\n                     END OF TERMS AND CONDITIONS\n\n            How to Apply These Terms to Your New Programs\n\n  If you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these terms.\n\n  To do so, attach the following notices to the program.  It is safest\nto attach them to the start of each source file to most effectively\nstate the exclusion of warranty; and each file should have at least\nthe \"copyright\" line and a pointer to where the full notice is found.\n\n    <one line to give the program's name and a brief idea of what it does.>\n    Copyright (C) <year>  <name of author>\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nAlso add information on how to contact you by electronic and paper mail.\n\n  If your software can interact with users remotely through a computer\nnetwork, you should also make sure that it provides a way for users to\nget its source.  For example, if your program is a web application, its\ninterface could display a \"Source\" link that leads users to an archive\nof the code.  There are many ways you could offer source, and different\nsolutions will be better for different programs; see section 13 for the\nspecific requirements.\n\n  You should also get your employer (if you work as a programmer) or school,\nif any, to sign a \"copyright disclaimer\" for the program, if necessary.\nFor more information on this, and how to apply and follow the GNU AGPL, see\n<http://www.gnu.org/licenses/>.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 2.1123046875,
          "content": "# PyMuPDF\n\n**PyMuPDF** is a high performance **Python** library for data extraction, analysis, conversion & manipulation of [PDF (and other) documents](https://pymupdf.readthedocs.io/en/latest/the-basics.html#supported-file-types).\n\n# Community\nJoin us on **Discord** here: [#pymupdf](https://discord.gg/TSpYGBW4eq)\n\n\n# Installation\n\n**PyMuPDF** requires **Python 3.9 or later**, install using **pip** with:\n\n`pip install PyMuPDF`\n\nThere are **no mandatory** external dependencies. However, some [optional features](#pymupdf-optional-features) become available only if additional packages are installed.\n\nYou can also try without installing by visiting [PyMuPDF.io](https://pymupdf.io/#examples).\n\n\n# Usage\n\nBasic usage is as follows:\n\n```python\nimport pymupdf # imports the pymupdf library\ndoc = pymupdf.open(\"example.pdf\") # open a document\nfor page in doc: # iterate the document pages\n  text = page.get_text() # get plain text encoded as UTF-8\n\n```\n\n\n# Documentation\n\nFull documentation can be found on [pymupdf.readthedocs.io](https://pymupdf.readthedocs.io).\n\n\n\n# <a id=\"pymupdf-optional-features\"></a>Optional Features\n\n* [fontTools](https://pypi.org/project/fonttools/) for creating font subsets.\n* [pymupdf-fonts](https://pypi.org/project/pymupdf-fonts/) contains some nice fonts for your text output.\n* [Tesseract-OCR](https://github.com/tesseract-ocr/tesseract) for optical character recognition in images and document pages.\n\n\n\n# About\n\n**PyMuPDF** adds **Python** bindings and abstractions to [MuPDF](https://mupdf.com/), a lightweight **PDF**, **XPS**, and **eBook** viewer, renderer, and toolkit. Both **PyMuPDF** and **MuPDF** are maintained and developed by [Artifex Software, Inc](https://artifex.com).\n\n**PyMuPDF** was originally written by [Jorj X. McKie](mailto:jorj.x.mckie@outlook.de).\n\n\n# License and Copyright\n\n**PyMuPDF** is available under [open-source AGPL](https://www.gnu.org/licenses/agpl-3.0.html) and commercial license agreements. If you determine you cannot meet the requirements of the **AGPL**, please contact [Artifex](https://artifex.com/contact/pymupdf-inquiry.php) for more information regarding a commercial license.\n\n\n\n\n"
        },
        {
          "name": "READMEb.md",
          "type": "blob",
          "size": 0.2763671875,
          "content": "# PyMuPDFb\n\nThis wheel contains [MuPDF](https://mupdf.readthedocs.io/) shared libraries for\nuse by [PyMuPDF](https://pymupdf.readthedocs.io/).\n\nThis wheel is shared by PyMuPDF wheels that are specific to different Python\nversions, significantly reducing the total size of a release.\n"
        },
        {
          "name": "READMEd.md",
          "type": "blob",
          "size": 0.15234375,
          "content": "# PyMuPDFd\n\nThis wheel contains [MuPDF](https://mupdf.readthedocs.io/) build-time files\nthat were used to build [PyMuPDF](https://pymupdf.readthedocs.io/).\n"
        },
        {
          "name": "changes.txt",
          "type": "blob",
          "size": 162.22265625,
          "content": "Change Log\n==========\n\n\n**Changes in version 1.25.1 (2024-12-11)**\n\n* Use MuPDF-1.25.2.\n\n* Fixed issues:\n\n  * **Fixed** `4125 <https://github.com/pymupdf/PyMuPDF/issues/4125>`_: memory leak while convert Pixmap's colorspace\n  * **Fixed** `4034 <https://github.com/pymupdf/PyMuPDF/issues/4034>`_: Possible regression in pdf cleaning during save.\n\n\n**Changes in version 1.25.0 (2024-12-05)**\n\n* Use MuPDF-1.25.1.\n\n* Fixed issues:\n\n  * **Fixed** `4026 <https://github.com/pymupdf/PyMuPDF/issues/4026>`_: page.get_text('blocks') output two piece of very similar text with different bbox\n  * **Fixed** `4004 <https://github.com/pymupdf/PyMuPDF/issues/4004>`_: Segmentation Fault When Updating PDF Form Field Value\n  * **Fixed** `3751 <https://github.com/pymupdf/PyMuPDF/issues/3751>`_: apply_redactions causes part of the page content to be hidden / transparent\n\n\n**Changes in version 1.24.14 (2024-11-19)**\n\n* Use MuPDF-1.24.11.\n\n* Fixed issues:\n\n  * **Fixed** `3448 <https://github.com/pymupdf/PyMuPDF/issues/3448>`_: get_pixmap function removes the table and leaves just the content behind\n  * **Fixed** `3758 <https://github.com/pymupdf/PyMuPDF/issues/3758>`_: Got \"malloc(): unaligned tcache chunk detected Aborted (core dumped)\" while using add_redact_annot/apply_redactions\n  * **Fixed** `3813 <https://github.com/pymupdf/PyMuPDF/issues/3813>`_: Stories: Ordered list count broken with nested unordered list\n  * **Fixed** `3933 <https://github.com/pymupdf/PyMuPDF/issues/3933>`_: font.valid_codepoints() - malfunction\n  * **Fixed** `4018 <https://github.com/pymupdf/PyMuPDF/issues/4018>`_: PyMuPDF hangs when iterating over zero page PDF pages backwards\n  * **Fixed** `4043 <https://github.com/pymupdf/PyMuPDF/issues/4043>`_: fullcopypage bug\n  * **Fixed** `4047 <https://github.com/pymupdf/PyMuPDF/issues/4047>`_: Segmentation Fault in add_redact_annot\n  * **Fixed** `4050 <https://github.com/pymupdf/PyMuPDF/issues/4050>`_: Content of dict returned by doc.embfile_info() does not fit to documentation\n\n* Other:\n\n  * Ensure that words from `Page.get_text()` never contain RTL/LTR char mixtures.\n  * Fix building with system MuPDF.\n  * Add dot product for points and vectors.\n\n\n**Changes in version 1.24.13 (2024-10-29)**\n\n* Fixed issues:\n\n  * **Fixed** `3848 <https://github.com/pymupdf/PyMuPDF/issues/3848>`_:  Piximap program crash\n  * **Fixed** `3950 <https://github.com/pymupdf/PyMuPDF/issues/3950>`_:  Unable to consistently extract field labels from PDFs\n  * **Fixed** `3981 <https://github.com/pymupdf/PyMuPDF/issues/3981>`_:  PyMuPDF 1.24.12 with pyinstaller throws error.\n  * **Fixed** `3994 <https://github.com/pymupdf/PyMuPDF/issues/3994>`_:  pix.color_topusage raise Segmentation fault (core dumped)\n\n\n**Changes in version 1.24.12 (2024-10-21)**\n\n* Fixed issues:\n\n  * **Fixed** `3914 <https://github.com/pymupdf/PyMuPDF/issues/3914>`_:  Ability to print MuPDF errors to logging instead of stdout\n  * **Fixed** `3916 <https://github.com/pymupdf/PyMuPDF/issues/3916>`_:  insert_htmlbox error: int too large to convert to float\n  * **Fixed** `3950 <https://github.com/pymupdf/PyMuPDF/issues/3950>`_:  Unable to consistently extract field labels from PDFs\n\n* Supported Python versions are now 3.9-3.13.\n\n  * Dropped support for Python-3.8 because end-of-life.\n  * Added support for Python-3.13 because now released.\n  * See: https://devguide.python.org/versions/\n\n\n**Changes in version 1.24.11 (2024-10-03)**\n\n* Use MuPDF-1.24.10.\n\n* Fixed issues:\n\n  * **Fixed** `3624 <https://github.com/pymupdf/PyMuPDF/issues/3624>`_: Pdf file transform to image have a black block\n  * **Fixed** `3859 <https://github.com/pymupdf/PyMuPDF/issues/3859>`_: doc.need_appearances() fails with \"AttributeError: module 'pymupdf.mupdf' has no attribute 'PDF_TRUE' \"\n  * **Fixed** `3863 <https://github.com/pymupdf/PyMuPDF/issues/3863>`_: apply_redactions() does not work as expected\n  * **Fixed** `3905 <https://github.com/pymupdf/PyMuPDF/issues/3905>`_: open stream can raise a FzErrorFormat error instead of FileDataError\n\n* Wheels now use the Python Stable ABI:\n\n  * There is one PyMuPDF wheel for each platform.\n  * Each wheel works with all supported Python versions.\n  * Each wheel is built using the oldest supported Python version (currently 3.8).\n  * There is no PyMuPDFb wheel.\n\n* Other:\n\n  * Improvements to get_text_words() with sort=True.\n  * Tests now always get the latest versions of required Python packages.\n  * Removed dependency on setuptools.\n  * Added item to PyMuPDF-1.24.10 changes below - fix of #3630.\n\n\n**Changes in version 1.24.10 (2024-09-02)**\n\n* Use MuPDF-1.24.9.\n\n* Fixed issues:\n\n  * **Fixed** `3450 <https://github.com/pymupdf/PyMuPDF/issues/3450>`_: get_pixmap function takes too long to process\n  * **Fixed** `3569 <https://github.com/pymupdf/PyMuPDF/issues/3569>`_: Invalid OCGs not ignored by SVG image creation\n  * **Fixed** `3603 <https://github.com/pymupdf/PyMuPDF/issues/3603>`_: ObjStm compression and PDF linearization doesn't work together\n  * **Fixed** `3650 <https://github.com/pymupdf/PyMuPDF/issues/3650>`_: Linebreak inserted between each letter\n  * **Fixed** `3661 <https://github.com/pymupdf/PyMuPDF/issues/3661>`_: Update Document to check the /XYZ len\n  * **Fixed** `3698 <https://github.com/pymupdf/PyMuPDF/issues/3698>`_: documentation issue - old code in the annotations documentation\n  * **Fixed** `3705 <https://github.com/pymupdf/PyMuPDF/issues/3705>`_: Document.select() behaves weirdly in some particular kind of pdf files\n  * **Fixed** `3706 <https://github.com/pymupdf/PyMuPDF/issues/3706>`_: extend Document.__getitem__ type annotation to reflect that the method also accepts slices\n  * **Fixed** `3727 <https://github.com/pymupdf/PyMuPDF/issues/3727>`_: Method get_pixmap() make the program exit without any exceptions or messages\n  * **Fixed** `3767 <https://github.com/pymupdf/PyMuPDF/issues/3767>`_: Cannot get Tessdata with Tesseract-OCR 5\n  * **Fixed** `3773 <https://github.com/pymupdf/PyMuPDF/issues/3773>`_: Link.set_border gives TypeError: '<' not supported between instances of 'NoneType' and 'int'\n  * **Fixed** `3774 <https://github.com/pymupdf/PyMuPDF/issues/3774>`_: fitz.__version__` does not work anymore\n  * **Fixed** `3789 <https://github.com/pymupdf/PyMuPDF/issues/3789>`_: ValueError: not enough values to unpack (expected 3, got 2) is thrown when call insert_pdf\n  * **Fixed** `3820 <https://github.com/pymupdf/PyMuPDF/issues/3820>`_: class improves namedDest handling\n\n  * **Fixed** `3630 <https://github.com/pymupdf/PyMuPDF/issues/3630>`_: page.apply_redactions gives unwanted black rectangle\n\n* Other:\n\n  * Object streams and linearization cannot be used together; attempting to do\n    so will raise an exception. (#3603)\n  * Fixed handling of non-existing /Contents object.\n\n \n**Changes in version 1.24.9 (2024-07-24)**\n\n* Use MuPDF-1.24.8.\n\n\n**Changes in version 1.24.8 (2024-07-22)**\n\n* Fixed issues:\n\n  * **Fixed** `3636 <https://github.com/pymupdf/PyMuPDF/issues/3636>`_: API documentation for the open function is not obvious to find.\n  * **Fixed** `3654 <https://github.com/pymupdf/PyMuPDF/issues/3654>`_: docx parsing was broken in 1.24.7\n  * **Fixed** `3677 <https://github.com/pymupdf/PyMuPDF/issues/3677>`_: Unable to extract subset font name using the newer versions of PyMuPDF : 1.24.6 and 1.24.7.\n  * **Fixed** `3687 <https://github.com/pymupdf/PyMuPDF/issues/3687>`_: Page.get_text results in AssertionError for epub files\n\nOther:\n\n* Fixed various spelling mistakes spotted by codespell.\n* Improved how we modify MuPDF's default configuration on Windows.\n* Make text search to work with ligatures.\n\n\n**Changes in version 1.24.7 (2024-06-26)**\n\n* Fixed issues:\n\n  * **Fixed** `3615 <https://github.com/pymupdf/PyMuPDF/issues/3615>`_: Document.pagemode or Document.pagelayout crashes for epub files\n  * **Fixed** `3616 <https://github.com/pymupdf/PyMuPDF/issues/3616>`_: not last version reported\n\n\n**Changes in version 1.24.6 (2024-06-25)**\n\n* Use MuPDF-1.24.4\n\n* Fixed issues:\n\n  * **Fixed** `3599 <https://github.com/pymupdf/PyMuPDF/issues/3599>`_: Story.fit_width() has a weird line\n  * **Fixed** `3594 <https://github.com/pymupdf/PyMuPDF/issues/3594>`_: Garbled extraction for Amazon Sustainability Report\n  * **Fixed** `3591 <https://github.com/pymupdf/PyMuPDF/issues/3591>`_: 'width' in Page.get_drawings() returns width equal as 0\n  * **Fixed** `3561 <https://github.com/pymupdf/PyMuPDF/issues/3561>`_: ZeroDivisionError: float division by zero with page.apply_redactions()\n  * **Fixed** `3559 <https://github.com/pymupdf/PyMuPDF/issues/3559>`_: SegFault 11 when empty H1 H2 H3 H4 etc element is used in insert_htmlbox\n  * **Fixed** `3539 <https://github.com/pymupdf/PyMuPDF/issues/3539>`_: Add dotted gridline detection to table recognition\n  * **Fixed** `3519 <https://github.com/pymupdf/PyMuPDF/issues/3519>`_: get_toc(simple=False) AttributeError: 'Outline' object has no attribute 'rect'\n  * **Fixed** `3510 <https://github.com/pymupdf/PyMuPDF/issues/3510>`_: page.get_label() gets wrong label on the first page of doc\n  * **Fixed** `3494 <https://github.com/pymupdf/PyMuPDF/issues/3494>`_: 1.24.2/1.24.3: spurious characters introduced when using subset_fonts and insert_pdf\n  * **Fixed** `3470 <https://github.com/pymupdf/PyMuPDF/issues/3470>`_: subset_fonts error exit without exception/warning\n  * **Fixed** `3400 <https://github.com/pymupdf/PyMuPDF/issues/3400>`_: set_toc alters link coordinates for some rotated pages on pymupdf 1.24.2\n  * **Fixed** `3347 <https://github.com/pymupdf/PyMuPDF/issues/3347>`_: Incorrect links to points on pages having different heights\n  * **Fixed** `3237 <https://github.com/pymupdf/PyMuPDF/issues/3237>`_: Set_metadata() does not work\n  * **Fixed** `3493 <https://github.com/pymupdf/PyMuPDF/discussions/3493>`_: Isolate PyMuPDF from other libraries; issues when PyMuPDF is loaded with other libraries like GdkPixbuf\n\n* Other:\n\n  * Fixed concurrent use of PyMuPDF caused by use of constant temporary filenames.\n  \n  * Add musllinux x86_64 wheels to release.\n\n  * Added clearer version information:\n    \n    * `pymupdf.pymupdf_version`.\n    * `pymupdf.mupdf_version`.\n    * `pymupdf.pymupdf_date`.\n\n\n**Changes in version 1.24.5 (2024-05-30)**\n\n* Fixed issues:\n\n  * **Fixed** `3479 <https://github.com/pymupdf/PyMuPDF/issues/3479>`_: regression: fill_textbox: IndexError: pop from empty list\n  * **Fixed** `3488 <https://github.com/pymupdf/PyMuPDF/issues/3488>`_: set_toc method error\n\n* Other:\n\n  * Some more fixes to use MuPDF floating formatting.\n  * Removed/disabled some unnecessary diagnostics.\n  * Fixed utils.do_links() crash.\n  * Experimental new functions `pymupdf.apply_pages()` and `pymupdf.get_text()`.\n  * Addresses wrong label generation for label styles \"a\" and \"A\".\n\n\n**Changes in version 1.24.4 (2024-05-16)**\n\n  * **Fixed** `3418 <https://github.com/pymupdf/PyMuPDF/issues/3418>`_: Re-introduced bug, text align add_redact_annot\n  * **Fixed** `3472 <https://github.com/pymupdf/PyMuPDF/issues/3472>`_: insert_pdf gives SystemError\n\n* Other:\n\n  * Fixed sysinstall test failing to remove all of prior installation before\n    new install.\n  * Fixed `utils.do_links()` crash.\n  * Correct `TextPage` creation Code.\n  * Unified various diagnostics.\n  * Fix bug in `page_merge()`.\n\n\n**Changes in version 1.24.3 (2024-05-09)**\n\n*\n  The Python module is now called `pymupdf`. `fitz` is still supported for\n  backwards compatibility.\n\n* Use MuPDF-1.24.2.\n\n* Fixed issues:\n\n  * **Fixed** `3357 <https://github.com/pymupdf/PyMuPDF/issues/3357>`_: PyMuPDF==1.24.0 will hanging when using page.get_text(\"text\")\n  * **Fixed** `3376 <https://github.com/pymupdf/PyMuPDF/issues/3376>`_: Redacting results are not as expected in 1.24.x.\n  * **Fixed** `3379 <https://github.com/pymupdf/PyMuPDF/issues/3379>`_: Documentation mismatch for get_text_blocks return value order.\n  * **Fixed** `3381 <https://github.com/pymupdf/PyMuPDF/issues/3381>`_: Contents stream contains floats in scientific notation\n  * **Fixed** `3402 <https://github.com/pymupdf/PyMuPDF/issues/3402>`_: Cannot add Widgets containing inter-field-calculation JavaScript\n  * **Fixed** `3414 <https://github.com/pymupdf/PyMuPDF/issues/3414>`_: missing attribute set_dpi()\n  * **Fixed** `3430 <https://github.com/pymupdf/PyMuPDF/issues/3430>`_: page.get_text() cause process freeze with certain pdf on v1.24.2\n\n* Other:\n\n  * New/modified methods:\n\n    * `Page.remove_rotation()`: new, set page rotation to zero while keeping appearance.\n\n  * Fixed some problems when checking for PDF properties.\n  * Fixed pip builds from sdist\n    (see discussion `3360 <https://github.com/pymupdf/PyMuPDF/discussions/3360>`_:\n    Alpine linux docker build failing \"No matching distribution found for pymupdfb==1.24.1\").\n\n\n**Changes in version 1.24.2 (2024-04-17)**\n\n* Removed obsolete classic implementation from releases\n  (previously available as module `fitz_old`).\n\n* Fixed issues:\n\n  * **Fixed** `3331 <https://github.com/pymupdf/PyMuPDF/issues/3331>`_: Document.pages() is incorrectly type-hinted\n  * **Fixed** `3354 <https://github.com/pymupdf/PyMuPDF/issues/3354>`_: PyMuPDF==1.24.1: AttributeError: property 'metadata' of 'Document' object has no setter\n\n* Other:\n\n  * New/modified methods:\n  \n    * `Document.bake()`: new, make annotations / fields permanent content.\n    * `Page.cluster_drawings()`: new, identifies drawing items\n      (i.e. vector graphics or line-art)\n      that belong together based on their geometrical vicinity.\n    * `Page.apply_redactions()`: added new parameter `text`.\n    * `Document.subset_fonts()`: use MuPDF's `pdf_subset_fonts()` instead of PyMuPDF code.\n    \n  * The `Document` class now supports page numbers specified as slices.\n  * Avoid causing MuPDF warnings.\n\n\n**Changes in version 1.24.1 (2024-04-02)**\n\n* Fixed issues:\n\n  * **Fixed** `3278 <https://github.com/pymupdf/PyMuPDF/issues/3278>`_: apply_redactions moves some unredacted text\n  * **Fixed** `3301 <https://github.com/pymupdf/PyMuPDF/issues/3301>`_: Be more permissive when classifying links as kind LINK_URI\n  * **Fixed** `3306 <https://github.com/pymupdf/PyMuPDF/issues/3306>`_: Text containing capital 'ET' not appearing as annotation\n\n* Other:\n\n  * Use MuPDF-1.24.1.\n  * Support ObjStm Compression.\n    Methods `Document.save()`, `Document.ez_save()` and `Document.write()`\n    now support new parameters `use_objstm`, compression_effort` and\n    `preserve_metadata`.\n\n\n**Changes in version 1.24.0 (2024-03-21)**\n\n* Fixed issues:\n\n  * **Fixed** `3281 <https://github.com/pymupdf/PyMuPDF/issues/3281>`_: Preparing metadata (pyproject.toml) did not run successfully\n  * **Fixed** `3279 <https://github.com/pymupdf/PyMuPDF/issues/3279>`_: PyMuPDF no longer builds in Alpine Linux\n  * **Fixed** `3257 <https://github.com/pymupdf/PyMuPDF/issues/3257>`_: apply_redactions() deleting text outside of annoted box\n  * **Fixed** `3216 <https://github.com/pymupdf/PyMuPDF/issues/3216>`_: AttributeError: 'Annot' object has no attribute '__del__'\n  * **Fixed** `3207 <https://github.com/pymupdf/PyMuPDF/issues/3207>`_: get_drawings's items is missing line from h path operator\n  * **Fixed** `3201 <https://github.com/pymupdf/PyMuPDF/issues/3201>`_: Memory leaks when merging PDFs\n  * **Fixed** `3197 <https://github.com/pymupdf/PyMuPDF/issues/3197>`_: page.get_text() returns hexadecimal text for some characters\n  * **Fixed** `3196 <https://github.com/pymupdf/PyMuPDF/issues/3196>`_: Remove text not working in 1.23.25 version vs 1.20.2\n  * **Fixed** `3172 <https://github.com/pymupdf/PyMuPDF/issues/3172>`_: PDF's 45 lines dissapearing in png conversion\n  * **Fixed** `3135 <https://github.com/pymupdf/PyMuPDF/issues/3135>`_: Do not log warnings to stdout\n  * **Fixed** `3125 <https://github.com/pymupdf/PyMuPDF/issues/3125>`_: get_pixmap method stuck on one page and runs forever\n  * **Fixed** `2964 <https://github.com/pymupdf/PyMuPDF/issues/2964>`_: There is an issue with the image generated by the page.get_pixmap() function\n\n* Other:\n\n  * Use MuPDF-1.24.0.\n  * Add support for redacting vector graphics.\n  * Several fixes for table module\n    \n    * Add new method for outputting the table as a markdown string.\n    \n    * Address errors in computing the table header object:\n    \n      We now allow None as the cell value, because this will be resolved where\n      needed (e.g. in the pandas DataFrame).\n\n      We previously tried to enforce rect-like tuples in all header cell\n      bboxes, however this fails for tables with all-None columns.  This fix\n      enables this and constructs an empty string in the corresponding cell\n      string.\n\n      We now correctly include start / stop points of lines in the bbox of the\n      clustered graphic.  We previously joined the line's rectangle - which had\n      no effect because this is always empty.\n\n  * Improved exception text if we fail to open document.\n  * Fixed build with new libclang 18.\n  \n\n**Changes in version 1.23.26 (2024-02-29)**\n\n* Fixed issues:\n\n  * **Fixed** `3199 <https://github.com/pymupdf/PyMuPDF/issues/3199>`_: Add entry_points to setuptools configuration to provide command-line console scripts\n  * **Fixed** `3209 <https://github.com/pymupdf/PyMuPDF/issues/3209>`_: Empty vertices in ink annotation\n\n* Other:\n\n  * Improvements to table detection:\n  \n    * Improved check for empty tables, fixes bugs when determining table headers.\n    * Improved computation of enveloping vector graphic rectangles.\n    * Ignore more meaningless \"pseudo\" tables\n\n  * Install command-line 'pymupdf' command that runs fitz/__main__.py.\n  * Don't overwrite MuPDF's config.h when building on non-Windows.\n  * Fix `Story` constructor's `archive` arg to match docs - now accepts a single `Archive` constructor arg.\n  * Do not include MuPDF source in sdist; will be downloaded automatically when building.\n\n\n**Changes in version 1.23.25 (2024-02-20)**\n\n* Fixed issues:\n\n  * **Fixed** `3182 <https://github.com/pymupdf/PyMuPDF/issues/3182>`_: Pixmap.invert_irect argument type error\n  * **Fixed** `3186 <https://github.com/pymupdf/PyMuPDF/issues/3186>`_: extractText() extracts broken text from pdf\n  * **Fixed** `3191 <https://github.com/pymupdf/PyMuPDF/issues/3191>`_: Error on .find_tables()\n\n* Other:\n\n  * When building, be able to specify python-config directly, with environment\n    variable `PIPCL_PYTHON_CONFIG`.\n\n\n**Changes in version 1.23.24 (2024-02-19)**\n\n* Fixed issues:\n\n  * **Fixed** `3148 <https://github.com/pymupdf/PyMuPDF/issues/3148>`_: Table extraction - vertical text not handled correctly\n  * **Fixed** `3179 <https://github.com/pymupdf/PyMuPDF/issues/3179>`_: Table Detection: Incorrect Separation of Vector Graphics Clusters\n  * **Fixed** `3180 <https://github.com/pymupdf/PyMuPDF/issues/3180>`_: Cannot show optional content group: AttributeError: module 'fitz.mupdf' has no attribute 'pdf_array_push_drop'\n\n* Other:\n\n  * Be able to test system install using `sudo pip install` instead of a venv.\n\n\n**Changes in version 1.23.23 (2024-02-18)**\n\n* Fixed issues:\n\n  * **Fixed** `3126 <https://github.com/pymupdf/PyMuPDF/issues/3126>`_: Initialising Archive with a pathlib.Path fails.\n  * **Fixed** `3131 <https://github.com/pymupdf/PyMuPDF/issues/3131>`_: Calling the next attribute of an Annot raises a \"No attribute .parent\" warning\n  * **Fixed** `3134 <https://github.com/pymupdf/PyMuPDF/issues/3134>`_: Using an IRect as clip parameter in Page.get_pixmap no longer works since 1.23.9\n  * **Fixed** `3140 <https://github.com/pymupdf/PyMuPDF/issues/3140>`_: PDF document stays in use after closing\n  * **Fixed** `3150 <https://github.com/pymupdf/PyMuPDF/issues/3150>`_: doc.select() hangs on this doc.\n  * **Fixed** `3163 <https://github.com/pymupdf/PyMuPDF/issues/3163>`_: AssertionError on using fitz.IRect\n  * **Fixed** `3177 <https://github.com/pymupdf/PyMuPDF/issues/3177>`_: fitz.Pixmap(None, pix) Unrecognised args for constructing Pixmap\n\n* Other:\n\n  *\n    Improved `Document.select() by using new MuPDF function\n    `pdf_rearrange_pages()`. This is a more complete (and faster)\n    implementation of what needs to be done here in that not only pages will\n    be rearranged, but also consequential changes will be made to the table\n    of contents, links to removed pages and affected entries in the Optional\n    Content definitions.\n  * `TextWriter.appendv()`: added `small_caps` arg.\n  * Fixed some valgrind errors with MuPDF master.\n  * Fixed `Document.insert_image()` when build with MuPDF master.\n\n\n**Changes in version 1.23.22 (2024-02-12)**\n\n* Fixed issues:\n\n  * **Fixed** `3143 <https://github.com/pymupdf/PyMuPDF/issues/3143>`_: Difference in decoding of OCGs names between doc.get_ocgs() and page.get_drawings()\n\n  * **Fixed** `3139 <https://github.com/pymupdf/PyMuPDF/issues/3139>`_: Pixmap resizing needs positional arg \"clip\" - even if None.\n\n* Other:\n\n  * Removed the use of MuPDF function `fz_image_size()` from PyMuPDF.\n\n\n**Changes in version 1.23.21 (2024-02-01)**\n\n* Fixed issues:\n\n* Other:\n\n  * Fixed bug in set_xml_metadata(), PR `3112 https://github.com/pymupdf/PyMuPDF/pull/3112>`_: Fix pdf_add_stream metadata error\n  * Fixed lack of `.parent` member in `TextPage` from `Annot.get_textpage()`.\n  * Fixed bug in `Page.add_widget()`.\n\n\n**Changes in version 1.23.20 (2024-01-29)**\n\n* Bug fixes:\n\n  * **Fixed** `3100 <https://github.com/pymupdf/PyMuPDF/issues/3100>`_: Wrong internal property accessed in get_xml_metadata\n\n* Other:\n\n  * Significantly improved speed of `Document.get_toc()`.\n\n\n**Changes in version 1.23.19 (2024-01-25)**\n\n* Bug fixes:\n\n  * **Fixed** `3087 <https://github.com/pymupdf/PyMuPDF/issues/3087>`_: Exception in insert_image with mask specified\n  * **Fixed** `3094 <https://github.com/pymupdf/PyMuPDF/issues/3094>`_: TypeError: '<' not supported between instances of 'FzLocation' and 'int' in doc.delete_pages\n\n* Other:\n\n  * When finding tables:\n  \n    * Allow addition of user-defined \"virtual\" vector graphics when finding tables.\n    * Confirm that the enveloping bboxes of vector graphics are inside the clip rectangle.\n    * Avoid slow finding of rectangle intersections.\n\n  * Added `Font.bbox` property.\n\n\n**Changes in version 1.23.18 (2024-01-23)**\n\n* Bug fixes:\n\n  * **Fixed** `3081 <https://github.com/pymupdf/PyMuPDF/issues/3081>`_: doc.close() not closing the document\n\n* Other:\n\n  * Reduced size of sdist to fit on pypi.org (by reducing size of two test files).\n  * Fix `Annot.file_info()` if no `Desc` item.\n\n\n**Changes in version 1.23.17 (2024-01-22)**\n\n* Bug fixes:\n\n  * **Fixed** `3062 <https://github.com/pymupdf/PyMuPDF/issues/3062>`_: page_rotation_reset does not return page to original rotation\n  * **Fixed** `3070 <https://github.com/pymupdf/PyMuPDF/issues/3070>`_: update_link(): AttributeError: 'Page' object has no attribute 'super'\n\n* Other:\n\n  * Fixed bug in `Page.links()` (PR #3075).\n  * Fixed bug in `Page.get_bboxlog()` with layers.\n  * Add support for timeouts in scripts/ and tests/run_compound.py.\n\n\n**Changes in version 1.23.16 (2024-01-18)**\n\n* Bug fixes:\n\n  * **Fixed** `3058 <https://github.com/pymupdf/PyMuPDF/issues/3058>`_: Pixmap created from CMYK JPEG delivers RGB format\n\n* Other:\n\n  * In table detection strategy \"lines_strict\", exclude fill-only vector graphics.\n  * Fixed sysinstall test failure.\n  * In documentation, update feature matrix with item about text writing.\n\n\n**Changes in version 1.23.15 (2024-01-16)**\n\n* Bug fixes:\n\n  * **Fixed** `3050 <https://github.com/pymupdf/PyMuPDF/issues/3050>`_: python3.9 pix.set_pixel has something wrong in c.append( ord(i))\n\n* Other:\n\n  * Improved docs for Page.find_tables().\n\n\n**Changes in version 1.23.14 (2024-01-15)**\n\n* Bug fixes:\n\n  * **Fixed** `3038 <https://github.com/pymupdf/PyMuPDF/issues/3038>`_: JM_pixmap_from_display_list > Assertion Error : Checking for wrong type\n  * **Fixed** `3039 <https://github.com/pymupdf/PyMuPDF/issues/3039>`_: Issue with doc.close() not closing the document in PyMuPDF\n\n* Other:\n\n  * Ensure valid \"re\" rectangles in `Page.get_drawings()` with derotated pages.\n\n\n**Changes in version 1.23.13 (2024-01-15)**\n\n* Bug fixes:\n\n  * **Fixed** `2979 <https://github.com/pymupdf/PyMuPDF/issues/2979>`_: list index out of range in to_pandas()\n  * **Fixed** `3001 <https://github.com/pymupdf/PyMuPDF/issues/3001>`_: Calling find_tables() on one document alters the bounding boxes of a subsequent document\n\n* Other:\n\n  * Fixed `Rect.height` and `Rect.width` to never return negative values.\n  * Fixed `TextPage.extractIMGINFO()`'s returned `dictkey_yres` value.\n\n\n**Changes in version 1.23.12 (2024-01-12)**\n\n* * **Fixed** `3027 <https://github.com/pymupdf/PyMuPDF/issues/3027>`_: Page.get_text throws Attribute Error for 'parent'\n\n\n**Changes in version 1.23.11 (2024-01-12)**\n\n* Fixed some Pixmap construction bugs.\n* Fixed Pixmap.yres().\n\n\n**Changes in version 1.23.10 (2024-01-12)**\n\n* Bug fixes:\n\n  * **Fixed** `3020 <https://github.com/pymupdf/PyMuPDF/issues/3020>`_: Can't resize a PixMap\n\n* Other:\n\n  * Fixed Page.delete_image().\n\n\n**Changes in version 1.23.9 (2024-01-11)**\n\n* Default to new \"rebased\" implementation.\n\n  * The old \"classic\" implementation is available with `import fitz_old as fitz`.\n  * For more information about why we are changing to the rebased implementation,\n    see: https://github.com/pymupdf/PyMuPDF/discussions/2680\n\n* Use MuPDF-1.23.9.\n\n* Bug fixes (rebased implementation only):\n\n  * **Fixed** `2911 <https://github.com/pymupdf/PyMuPDF/issues/2911>`_: Page.derotation_matrix returns a tuple instead of a Matrix with rebased implementation\n  * **Fixed** `2919 <https://github.com/pymupdf/PyMuPDF/issues/2919>`_: Rebased version: KeyError in resolve_names when merging pdfs\n  * **Fixed** `2922 <https://github.com/pymupdf/PyMuPDF/issues/2922>`_: New feature that allows inserting named-destination links doesn't work\n  * **Fixed** `2943 <https://github.com/pymupdf/PyMuPDF/issues/2943>`_: ZeroDivisionError: float division by zero when use apply_redactions()\n  * **Fixed** `2950 <https://github.com/pymupdf/PyMuPDF/issues/2950>`_: Shelling out to pip during tests is problematic\n  * **Fixed** `2954 <https://github.com/pymupdf/PyMuPDF/issues/2954>`_: Replacement unicode character in text extraction\n  * **Fixed** `2957 <https://github.com/pymupdf/PyMuPDF/issues/2957>`_: apply_redactions() moving text\n  * **Fixed** `2961 <https://github.com/pymupdf/PyMuPDF/issues/2961>`_: Passing a string as a page number raises IndexError instead of TypeError.\n  * **Fixed** `2969 <https://github.com/pymupdf/PyMuPDF/issues/2969>`_: annot.next throws AttributeError\n  * **Fixed** `2978 <https://github.com/pymupdf/PyMuPDF/issues/2978>`_: 1.23.9rc1: module 'fitz.mupdf' has no attribute 'fz_copy_pixmap_rect'\n\n  * **Fixed** `2907 <https://github.com/pymupdf/PyMuPDF/issues/2907>`_: segfault trying to call clean_contents on certain pdfs with python 3.12\n  * **Fixed** `2905 <https://github.com/pymupdf/PyMuPDF/issues/2905>`_: SystemError: <built-in function TextPage_extractIMGINFO> returned a result with an exception set\n  * **Fixed** `2742 <https://github.com/pymupdf/PyMuPDF/issues/2742>`_: Segmentation Fault when inserting three (but not two) copies of the same source page into one destination page\n\n* Other:\n\n  * Add optional setting of opacity to `Page.insert_htmlbox()`.\n  * Fixed issue with add_redact_annot() mentioned in #2934.\n  * Fixed `Page.rotation()` to return 0 for non-PDF documents instead of raising an exception.\n  * Fixed internal quad detection to cope with any Python sequence.\n  * Fixed rebased `fitz.pymupdf_version_tuple` - was previously set to mupdf version.\n  * Improved support for Linux system installs, including adding regular testing on Github.\n  * Add missing `flake8` to `scripts/gh_release.py:test_packages`.\n  * Use newly public functions in MuPDF-1.23.8.\n  * Improved `scripts/test.py` to help investigation of MuPDF issues.\n\n\n**Changes in version 1.23.8 (2023-12-19)**\n\n* Bug fixes (rebased implementation only):\n\n  * **Fixed** `2634 <https://github.com/pymupdf/PyMuPDF/issues/2634>`_: get_toc and set_toc do not behave consistently for rotated pages\n  * **Fixed** `2861 <https://github.com/pymupdf/PyMuPDF/issues/2861>`_: AttributeError in getLinkDict during PDF Merge\n  * **Fixed** `2871 <https://github.com/pymupdf/PyMuPDF/issues/2871>`_: KeyError in getLinkDict during PDF merge\n  * **Fixed** `2886 <https://github.com/pymupdf/PyMuPDF/issues/2886>`_: Error in Skeleton for Named Link Destinations\n\n* Bug fixes (rebased and classic implementations):\n  \n  * **Fixed** `2885 <https://github.com/pymupdf/PyMuPDF/issues/2885>`_: pymupdf find tables too slow\n\n* Other:\n\n  * Rebased implementation:\n  \n    * `Page.insert_htmlbox()`: new, much more powerful alternative to `Page.insert_textbox()` or `TextWriter.fill_textbox()`, using `Story`.\n    * `Story.fit*()`: new methods for fitting a Story into an expanded rect.\n    * `Story.write_with_links()`: add support for external links.\n    * `Document.language()`: fixed to use MuPDF's new `mupdf.fz_string_from_text_language2()`.\n    * `Document.subset_fonts()` - fixed.\n    * Fixed internal `Archive._add_treeitem()` method.\n    * Fixed `fitz_new.__doc__` to contain PyMuPDF and Python version information, and OS name.\n    * Removed use of `(*args, **kwargs)` in API, we now specify keyword args explicitly.\n    * Work with new MuPDF Python exception classes.\n\n  * Fixed bug where `button_states()` returns None when `/AP` points to an indirect object.\n  * Fixed pillow test to not ignore all errors, and install pillow when testing.\n  * Added test for `fitz.css_for_pymupdf_font()` (uses package `pymupdf-fonts`).\n  * Simplified Github Actions test specifications.\n  * Updated `tests/README.md`.\n\n\n**Changes in version 1.23.7 (2023-11-30)**\n\n* Bug fixes in rebased implementation, not fixed in classic implementation:\n\n  * **Fixed** `2232 <https://github.com/pymupdf/PyMuPDF/issues/2232>`_: Geometry helper classes should support keyword arguments\n  * **Fixed** `2788 <https://github.com/pymupdf/PyMuPDF/issues/2788>`_: Problem with get_toc in pymupdf 1.23.6\n  * **Fixed** `2791 <https://github.com/pymupdf/PyMuPDF/issues/2791>`_: Experiencing small memory leak in save()\n\n* Bug fixes (rebased and classic implementations):\n\n  * **Fixed** `2736 <https://github.com/pymupdf/PyMuPDF/issues/2736>`_: Failure when set cropbox with mediabox negative value\n  * **Fixed** `2749 <https://github.com/pymupdf/PyMuPDF/issues/2749>`_: RuntimeError: cycle in structure tree\n  * **Fixed** `2753 <https://github.com/pymupdf/PyMuPDF/issues/2753>`_: Story.write_with_links will ignore everything after the first \"page break\" in the HTML.\n  * **Fixed** `2812 <https://github.com/pymupdf/PyMuPDF/issues/2812>`_: find_tables on landscape page generates reversed text\n  * **Fixed** `2829 <https://github.com/pymupdf/PyMuPDF/issues/2829>`_: [cannot create /Annot for kind] is still printed despite #2345 is closed.\n  * **Fixed** `2841 <https://github.com/pymupdf/PyMuPDF/issues/2841>`_: Unexpected KeyError when using scrub with fitz_new\n\n* Use MuPDF-1.23.7.\n\n* Other:\n\n  * Rebased implementation:\n  \n    * Added flake8 code checking to test suite, and made various fixes.\n    * Disable diagnostics during Document constructor to match classic implementation.\n  \n  * Additional fix to `2553 <https://github.com/pymupdf/PyMuPDF/issues/2553>`_: Invalid characters in versions >= 1.22\n  * Fixed `MuPDF Bug 707324 <https://bugs.ghostscript.com/show_bug.cgi?id=707324>`_: Story: HTML table row background color repeated incorrectly\n  * Added `scripts/test.py`, for simple build+test of PyMuPDF git checkout.\n  * Added `fitz.pymupdf_version_tuple`, e.g. `(1, 23, 6)`.\n  * Restored mistakenly-reverted fix for `2345 <https://github.com/pymupdf/PyMuPDF/issues/2345>`_: Turn off print statements in utils.py\n  * Include any trailing `... repeated <N> times...` text in warnings returned by `mupdf_warnings()` (rebased only).\n  \n\n\n**Changes in version 1.23.6 (2023-11-06)**\n\n* Bug fixes:\n\n  * **Fixed** `2553 <https://github.com/pymupdf/PyMuPDF/issues/2553>`_: Invalid characters in versions >= 1.22\n  * **Fixed** `2608 <https://github.com/pymupdf/PyMuPDF/issues/2608>`_: Incorrect utf32 text extraction (high & low surrogates are split)\n  * **Fixed** `2710 <https://github.com/pymupdf/PyMuPDF/issues/2710>`_: page.rect and text location wrong / differing from older version\n  * **Fixed** `2774 <https://github.com/pymupdf/PyMuPDF/issues/2774>`_: wrong encoding for \"\\?\" character when sort=True\n  * **Fixed** `2775 <https://github.com/pymupdf/PyMuPDF/issues/2775>`_: fitz_new does not work with python3.10 or earlier\n  * **Fixed** `2777 <https://github.com/pymupdf/PyMuPDF/issues/2777>`_: With fitz_new, wrong type for Page.mediabox\n\n* Other:\n\n  * Use MuPDF-1.23.5.\n  * Added Document.resolve_names() (rebased implementation only).\n\n\n**Changes in version 1.23.5 (2023-10-11)**\n\n* Bug fixes:\n\n  * **Fixed** `2341 <https://github.com/pymupdf/PyMuPDF/issues/2341>`_: Handling negative values in the zoom section for LINK_GOTO in linkDest\n  * **Fixed** `2522 <https://github.com/pymupdf/PyMuPDF/issues/2522>`_: Typo in set_layer() - NameError: name 'f' is not defined\n  * **Fixed** `2548 <https://github.com/pymupdf/PyMuPDF/issues/2548>`_: Fitz freezes on some PDFs when calling the fitz.Page.get_text_blocks method.\n  * **Fixed** `2596 <https://github.com/pymupdf/PyMuPDF/issues/2596>`_: save(garbage=3) breaks get_pixmap() with side effect\n  * **Fixed** `2635 <https://github.com/pymupdf/PyMuPDF/issues/2635>`_: \"clean=True\" makes objects invisible in the pdf\n  * **Fixed** `2637 <https://github.com/pymupdf/PyMuPDF/issues/2637>`_: Page.insert_textbox incorrectly handles the last word if it starts a new line\n  * **Fixed** `2699 <https://github.com/pymupdf/PyMuPDF/issues/2699>`_: extract paragraph with below table\n  * **Fixed** `2703 <https://github.com/pymupdf/PyMuPDF/issues/2703>`_: Wrong fontsize calculation in corner cases (\"page.get_texttrace()\")\n  * **Fixed** `2710 <https://github.com/pymupdf/PyMuPDF/issues/2710>`_: page.rect and text location wrong / differing from older version\n  * **Fixed** `2723 <https://github.com/pymupdf/PyMuPDF/issues/2723>`_: When will a Python 3.12 wheel be available?\n  * **Fixed** `2730 <https://github.com/pymupdf/PyMuPDF/issues/2730>`_: persistent get_text() formatting\n\n* Other:\n\n  * Use MuPDF-1.23.4.\n  * Fix optimisation flags with system installs.\n  * Fixed the problem that the clip parameter does not take effect during table recognition\n  * Support Pillow mode \"RGBa\"\n  * Support extra word delimiters\n  * Support checking valid PDF name objects\n\n\n**Changes in version 1.23.4 (2023-09-26)**\n\n* Improved build instructions.\n* Fixed Tesseract in rebased implementation.\n* Improvements to build/install with system MuPDF.\n* Fixed Pyodide builds.\n* Fixed rebased bug in _insert_image().\n\n* Bug fixes:\n\n  * **Fixed** `2556 <https://github.com/pymupdf/PyMuPDF/issues/2556>`_: Segmentation fault at caling get_cdrawings(extended=True)\n  * **Fixed** `2637 <https://github.com/pymupdf/PyMuPDF/issues/2637>`_: Page.insert_textbox incorrectly handles the last word if it starts a new line\n  * **Fixed** `2683 <https://github.com/pymupdf/PyMuPDF/issues/2683>`_: Windows sdist build failure - non-quoting of path and using UNIX which command\n  * **Fixed** `2691 <https://github.com/pymupdf/PyMuPDF/issues/2691>`_: Page.get_textpage_ocr() bug in rebased fitz_new version\n  * **Fixed** `2692 <https://github.com/pymupdf/PyMuPDF/issues/2692>`_: Page.get_pixmap(clip=Rect()) bug in rebased fitz_new version\n\n\n**Changes in version 1.23.3 (2023-08-31)**\n\n* Fixed use of Tesseract for OCR.\n\n\n**Changes in version 1.23.2 (2023-08-28)**\n\n* **Fixed** `#2613 <https://github.com/pymupdf/PyMuPDF/issues/2613>`_: release 1.23.0 not MacOS-arm64 compatible\n\n\n**Changes in version 1.23.1 (2023-08-24)**\n\n* Updated README and package summary description.\n\n*\n  Fixed a problem on some Linux installations with Python-3.10\n  (and possibly earlier versions) where `import fitz` failed with\n  `ImportError: libcrypt.so.2: cannot open shared object file: No such\n  file or directory`.\n\n*\n  Fixed `incompatible architecture` error on MacOS arm64.\n\n*\n  Fixed installation warning from Poetry about missing entry in wheels'\n  RECORD files.\n\n\n**Changes in version 1.23.0 (2023-08-22)**\n\n* Add method `find_tables()` to the `Page` object.\n\n  This allows locating tables on any supported document page, and\n  extracting table content by cell.\n\n* New \"rebased\" implementation of PyMuPDF.\n\n  The rebased implementation is available as Python module\n  `fitz_new`. It can be used as a drop-in replacement with `import\n  fitz_new as fitz`.\n\n*\n  Python-independent MuPDF libraries are now in a second wheel called\n  `PyMuPDFb` that will be automatically installed by pip.\n\n  This is to save space on pypi.org - a full release only needs one\n  `PyMuPDFb` wheel for each OS.\n\n* Bug fixes:\n\n  * **Fixed** `#2542 <https://github.com/pymupdf/PyMuPDF/issues/2542>`_: fitz.utils.scrub AttributeError Annot object has no attribute fileUpd inside\n  * **Fixed** `#2533 <https://github.com/pymupdf/PyMuPDF/issues/2533>`_: get_texttrace returned a incorrect character bbox\n  * **Fixed** `#2537 <https://github.com/pymupdf/PyMuPDF/issues/2537>`_: Validation when setting a grouped RadioButton throws a RuntimeError: path to 'V' has indirects\n\n* Other changes:\n\n  * Dropped support for Python-3.7.\n\n  * Fix for wrong page / annot `/Contents` cleaning.\n    \n    We need to set `pdf_filter_options::no_update` to zero.\n\n  * Added new function get_tessdata().\n\n  * Cope with problem `/Annot` arrays.\n  \n    When copying page annotations in method Document.insert_pdf we\n    previously did not check the validity of members of the `/Annots`\n    array.  For faulty members (like null or non-dictionary items) this\n    could cause unnecessary exceptions. This fix implements more checks\n    and skips such array items.\n\n  * Additional annotation type checks.\n\n    We did not previously check for annotation type when getting /\n    setting annotation border properties. This is now checked in\n    accordance with MuPDF.\n\n  * Increase fault tolerance.\n    \n    Avoid exceptions in method `insert_pdf()` when source pages contains\n    invalid items in the `/Annots` array.\n\n  * Return empty border dict for applicable annots.\n    \n    We previously were returning a non-empty border dictionary even for\n    non-applicable annotation types.  We now return the empty dictionary\n    `{}` in these cases. This requires some corresponding changes in the\n    annotation `.update()` method, namely for dashes and border width.\n\n  * Restrict `set_rect` to applicable annot types.\n\n    We were insufficiently excluding non-applicable annotation types\n    from `set_rect()` method.  We now let MuPDF catch unsupported\n    annotations and return `False` in these cases.\n\n  * Wrong fontsize computation in `page.get_texttrace()`.\n    \n    When computing the font size we were using the final text\n    transformation matrix, where we should have taken `span->trm`\n    instead.  This is corrected here.\n\n  * Updates to cope with changes to latest MuPDF.\n  \n    `pdf_lookup_anchor()` has been removed.\n\n  * Update fill_textbox to better respect rect.width\n\n    The function norm_words in fill_textbox had a bug in its last\n    loop, appending n+1 characters when actually measuring width of n\n    characters.  It led to a bug in fill_texbox when you tried to write\n    a single word mostly composed of \"wide\" letters (M,m, W, w...),\n    causing the written text to exceed the given rect.\n\n    The fix was just to replace n+1 by n.\n\n  * Add `script_focus` and `script_blur` options to widget.\n\n\n\n**Changes in version 1.22.5 (2023-06-21)**\n\n* This release uses ``MuPDF-1.22.2``.\n\n* Bug fixes:\n\n  * **Fixed** `#2365 <https://github.com/pymupdf/PyMuPDF/issues/2365>`_: Incorrect dictionary values for type \"fs\" drawings.\n  * **Fixed** `#2391 <https://github.com/pymupdf/PyMuPDF/issues/2391>`_: Check box automatically uncheck when we update same checkbox more than 1 times.\n  * **Fixed** `#2400 <https://github.com/pymupdf/PyMuPDF/issues/2400>`_: Gaps within text of same line not filled with spaces.\n  * **Fixed** `#2404 <https://github.com/pymupdf/PyMuPDF/issues/2404>`_: Blacklining an image in PDF won't remove underlying content in version 1.22.X.\n  * **Fixed** `#2430 <https://github.com/pymupdf/PyMuPDF/issues/2430>`_: Incorrectly reducing ref count of Py_None.\n  * **Fixed** `#2450 <https://github.com/pymupdf/PyMuPDF/issues/2450>`_: Empty fill color and fill opacity for paths with fill and stroke operations with 1.22.*\n  * **Fixed** `#2462 <https://github.com/pymupdf/PyMuPDF/issues/2462>`_: Error at \"get_drawing(extended=True )\"\n  * **Fixed** `#2468 <https://github.com/pymupdf/PyMuPDF/issues/2468>`_: Decode error when trying to get drawings  \n  * **Fixed** `#2710 <https://github.com/pymupdf/PyMuPDF/issues/2710>`_: page.rect and text location wrong / differing from older version\n  * **Fixed** `#2723 <https://github.com/pymupdf/PyMuPDF/issues/2723>`_: When will a Python 3.12 wheel be available?\n\n* New features:\n\n  * **Changed** Annotations now support \"cloudy\" borders.\n    The :attr:`Annot.border` property has the new item `clouds`,\n    and method :meth:`Annot.set_border` supports the corresponding `clouds` argument.\n\n  * **Changed** Radio button widgets in the same RB group\n    are now consistently updated **if the group is defined in the standard way**.\n\n  * **Added** Support for the `/Locked` key in PDF Optional Content.\n    This array inside the catalog entry `/OCProperties` can now be extracted and set.\n\n  * **Added** Support for new parameter `tessdata` in OCR functions.\n    New function :meth:`get_tessdata` locates the language support folder if Tesseract is installed.\n\n\n\n**Changes in version 1.22.3 (2023-05-10)**\n\n* This release uses ``MuPDF-1.22.0``.\n\n* Bug fixes:\n\n  * **Fixed** `#2333 <https://github.com/pymupdf/PyMuPDF/issues/2333>`_: Unable to set any of button radio group in form\n\n\n**Changes in version 1.22.2 (2023-04-26)**\n\n* This release uses ``MuPDF-1.22.0``.\n\n* Bug fixes:\n\n  * **Fixed** `#2369 <https://github.com/pymupdf/PyMuPDF/issues/2369>`_: Image extraction bugs with newer versions\n\n\n**Changes in version 1.22.1 (2023-04-18)**\n\n* This release uses ``MuPDF-1.22.0``.\n\n* Bug fixes:\n\n  * **Fixed** `#2345 <https://github.com/pymupdf/PyMuPDF/issues/2345>`_: Turn off print statements in utils.py\n  * **Fixed** `#2348 <https://github.com/pymupdf/PyMuPDF/issues/2348>`_: extract_image returns an extension \"flate\" instead of \"png\"\n  * **Fixed** `#2350 <https://github.com/pymupdf/PyMuPDF/issues/2350>`_: Can not make widget (checkbox) to read-only by adding flags PDF_FIELD_IS_READ_ONLY\n  * **Fixed** `#2355 <https://github.com/pymupdf/PyMuPDF/issues/2355>`_: 1.22.0 error when using get_toc (AttributeError: 'SwigPyObject' object has no attribute)\n\n\n**Changes in version 1.22.0 (2023-04-14)**\n\n* This release uses ``MuPDF-1.22.0``.\n\n* Behavioural changes:\n\n  * Text extraction now includes glyphs that overlap with clip rect; previously\n    they were included only if they were entirely contained within the clip\n    rect.\n\n* Bug fixes:\n\n  * **Fixed** `#1763 <https://github.com/pymupdf/PyMuPDF/issues/1763>`_: Interactive(smartform) form PDF calculation not working in pymupdf\n  * **Fixed** `#1995 <https://github.com/pymupdf/PyMuPDF/issues/1995>`_: RuntimeError: image is too high for a long paged pdf file when trying\n  * **Fixed** `#2093 <https://github.com/pymupdf/PyMuPDF/issues/2093>`_: Image in pdf changes color after applying redactions\n  * **Fixed** `#2108 <https://github.com/pymupdf/PyMuPDF/issues/2108>`_: Redaction removing more text than expected\n  * **Fixed** `#2141 <https://github.com/pymupdf/PyMuPDF/issues/2141>`_: Failed to read JPX header when trying to get blocks\n  * **Fixed** `#2144 <https://github.com/pymupdf/PyMuPDF/issues/2144>`_: Replace image throws an error\n  * **Fixed** `#2146 <https://github.com/pymupdf/PyMuPDF/issues/2146>`_: Wrong Handling of Reference Count of \"None\" Object\n  * **Fixed** `#2161 <https://github.com/pymupdf/PyMuPDF/issues/2161>`_: Support adding images as pages directly\n  * **Fixed** `#2168 <https://github.com/pymupdf/PyMuPDF/issues/2168>`_: ``page.add_highlight_annot(start=pointa, stop=pointb)`` not working\n  * **Fixed** `#2173 <https://github.com/pymupdf/PyMuPDF/issues/2173>`_: Double free of ``Colorspace`` used in ``Pixmap``\n  * **Fixed** `#2179 <https://github.com/pymupdf/PyMuPDF/issues/2179>`_: Incorrect documentation for ``pixmap.tint_with()``\n  * **Fixed** `#2208 <https://github.com/pymupdf/PyMuPDF/issues/2208>`_: Pushbutton widget appears as check box\n  * **Fixed** `#2210 <https://github.com/pymupdf/PyMuPDF/issues/2210>`_: ``apply_redactions()`` move pdf text to right after redaction\n  * **Fixed** `#2220 <https://github.com/pymupdf/PyMuPDF/issues/2220>`_: ``Page.delete_image()`` | object has no attribute ``is_image``\n  * **Fixed** `#2228 <https://github.com/pymupdf/PyMuPDF/issues/2228>`_: open some pdf cost too much time\n  * **Fixed** `#2238 <https://github.com/pymupdf/PyMuPDF/issues/2238>`_: Bug - can not extract data from file in the newest version 1.21.1\n  * **Fixed** `#2242 <https://github.com/pymupdf/PyMuPDF/issues/2242>`_: Python quits silently in ``Story.element_positions()`` if callback function prototype is wrong\n  * **Fixed** `#2246 <https://github.com/pymupdf/PyMuPDF/issues/2246>`_: TextWriter write text in a wrong position\n  * **Fixed** `#2248 <https://github.com/pymupdf/PyMuPDF/issues/2248>`_: After redacting the content, the position of the remaining text changes\n  * **Fixed** `#2250 <https://github.com/pymupdf/PyMuPDF/issues/2250>`_: docs: unclear or broken link in page.rst\n  * **Fixed** `#2251 <https://github.com/pymupdf/PyMuPDF/issues/2251>`_: mupdf_display_errors does not apply to Pixmap when loading broken image\n  * **Fixed** `#2270 <https://github.com/pymupdf/PyMuPDF/issues/2270>`_: ``Annot.get_text(\"words\")`` - doesn't return the first line of words\n  * **Fixed** `#2275 <https://github.com/pymupdf/PyMuPDF/issues/2275>`_: insert_image: document that rotations are counterclockwise\n  * **Fixed** `#2278 <https://github.com/pymupdf/PyMuPDF/issues/2278>`_: Can not make widget (checkbox) to read-only by adding flags PDF_FIELD_IS_READ_ONLY\n  * **Fixed** `#2290 <https://github.com/pymupdf/PyMuPDF/issues/2290>`_: Different image format/data from Page.get_text(\"dict\") and Fitz.get_page_images()\n  * **Fixed** `#2293 <https://github.com/pymupdf/PyMuPDF/issues/2293>`_: 68 failed tests when installing from sdist on my box\n  * **Fixed** `#2300 <https://github.com/pymupdf/PyMuPDF/issues/2300>`_: Too much recursion in tree (parents), makes program terminate\n  * **Fixed** `#2322 <https://github.com/pymupdf/PyMuPDF/issues/2322>`_: add_highlight_annot using clip generates \"A Number is Out of Range\" error in PDF\n\n* Other:\n\n  * Add key \"/AS (Yes)\" to the underlying annot object of a selected button form field.\n\n  * Remove unused ``Document`` methods ``has_xref_streams()`` and\n    ``has_old_style_xrefs()`` as MuPDF equivalents have been removed.\n\n  * Add new ``Document`` methods and properties for getting/setting\n    ``/PageMode``, ``/PageLayout`` and ``/MarkInfo``.\n\n  * New ``Document`` property ``version_count``, which contains the number of\n    incremental saves plus one.\n\n  * New ``Document`` property ``is_fast_webaccess`` which tells whether the\n    document is linearized.\n\n  * ``DocumentWriter`` is now a context manager.\n\n  * Add support for ``Pixmap`` JPEG output.\n\n  * Add support for drawing rectangles with rounded corners.\n\n  * ``get_drawings()``: added optional ``extended`` arg.\n\n  * Fixed issue where trace devices' state was not being initialised\n    correctly; data returned from things like ``fitz.Page.get_texttrace()``\n    might be slightly altered, e.g. ``linewidth`` values.\n\n  * Output warning to ``stderr`` if it looks like we are being used with\n    current directory containing an invalid ``fitz/`` directory, because\n    this can break import of ``fitz`` module. For example this happens\n    if one attempts to use ``fitz`` when current directory is a PyMuPDF\n    checkout.\n\n* Documentation:\n\n  * General rework:\n\n    * Introduces a new home page and new table of contents.\n    * Structural update to include new About section.\n    * Comparison & performance graphing.\n    * Includes performance methodology in appendix.\n    * Updates conf.py to understand single back-ticks as code.\n    * Converts double back-ticks to single back-ticks.\n    * Removes redundant files.\n\n  * Improve ``insert_file()`` documentation.\n\n  * ``get_bboxlog()``: aded optional ``layers`` to ``get_bboxlog()``.\n  * ``Page.get_texttrace()``: add new dictionary key ``layer``, name of Optional Content Group.\n\n  * Mention use of Python venv in installation documentation.\n\n  * Added missing fix for #2057 to release 1.21.1's changelog.\n\n  * Fixes many links to the PyMuPDF-Utilities repo scripts.\n\n  * Avoid duplication of ``changes.txt`` and ``docs/changes.rst``.\n\n* Build\n\n  * Added ``pyproject.toml`` file to improve builds using pip etc.\n\n\n\n**Changes in Version 1.21.1 (2022-12-13)**\n\n* This release uses ``MuPDF-1.21.1``.\n\n* Bug fixes:\n\n  * **Fixed** `#2110 <https://github.com/pymupdf/PyMuPDF/issues/2110>`_: Fully embedded font is extracted only partially if it occupies more than one object\n  * **Fixed** `#2094 <https://github.com/pymupdf/PyMuPDF/issues/2094>`_: Rectangle Detection Logic\n  * **Fixed** `#2088 <https://github.com/pymupdf/PyMuPDF/issues/2088>`_: Destination point not set for named links in toc\n  * **Fixed** `#2087 <https://github.com/pymupdf/PyMuPDF/issues/2087>`_: Image with Filter \"[/FlateDecode/JPXDecode]\" not extracted\n  * **Fixed** `#2086 <https://github.com/pymupdf/PyMuPDF/issues/2086>`_: Document.save() owner_pw & user_pw has buffer overflow bug\n  * **Fixed** `#2076 <https://github.com/pymupdf/PyMuPDF/issues/2076>`_: Segfault in fitz.py\n  * **Fixed** `#2057 <https://github.com/pymupdf/PyMuPDF/issues/2057>`_: Document.save garbage parameter not working in PyMuPDF 1.21.0\n  * **Fixed** `#2051 <https://github.com/pymupdf/PyMuPDF/issues/2051>`_: Missing DPI Parameter\n  * **Fixed** `#2048 <https://github.com/pymupdf/PyMuPDF/issues/2048>`_: Invalid size of TextPage and bbox with newest version 1.21.0\n  * **Fixed** `#2045 <https://github.com/pymupdf/PyMuPDF/issues/2045>`_: SystemError: <built-in function Page_get_texttrace> returned a result with an error set\n  * **Fixed** `#2039 <https://github.com/pymupdf/PyMuPDF/issues/2039>`_: 1.21.0 fails to build against system libmupdf\n  * **Fixed** `#2036 <https://github.com/pymupdf/PyMuPDF/issues/2036>`_: Archive::Archive defined twice\n\n* Other\n\n  * Swallow \"&zoom=nan\" in link uri strings.\n  * Add new Page utility methods ``Page.replace_image()`` and ``Page.delete_image()``.\n\n* Documentation:\n\n  * `#2040 <https://github.com/pymupdf/PyMuPDF/issues/2040>`_: Added note about test failure with non-default build of MuPDF, to ``tests/README.md``.\n  * `#2037 <https://github.com/pymupdf/PyMuPDF/issues/2037>`_: In ``docs/installation.rst``, mention incompatibility with chocolatey.org on Windows.\n  * `#2061 <https://github.com/pymupdf/PyMuPDF/issues/2061>`_: Fixed description of ``Annot.file_info``.\n  * `#2065 <https://github.com/pymupdf/PyMuPDF/issues/2065>`_: Show how to insert internal PDF link.\n  * Improved description of building from source without an sdist.\n  * Added information about running tests.\n  * `#2084 <https://github.com/pymupdf/PyMuPDF/issues/2084>`_: Fixed broken link to PyMuPDF-Utilities.\n\n\n**Changes in Version 1.21.0 (2022-11-8)**\n\n* This release uses ``MuPDF-1.21.0``.\n\n* New feature: Stories.\n\n* Added wheels for Python-3.11.\n\n* Bug fixes:\n\n  * **Fixed** `#1701 <https://github.com/pymupdf/PyMuPDF/issues/1701>`_: Broken custom image insertion.\n  * **Fixed** `#1854 <https://github.com/pymupdf/PyMuPDF/issues/1854>`_: `Document.delete_pages()` declines keyword arguments.\n  * **Fixed** `#1868 <https://github.com/pymupdf/PyMuPDF/issues/1868>`_: Access Violation Error at `page.apply_redactions()`.\n  * **Fixed** `#1909 <https://github.com/pymupdf/PyMuPDF/issues/1909>`_: Adding text with `fontname=\"Helvetica\"` can silently fail.\n  * **Fixed** `#1913 <https://github.com/pymupdf/PyMuPDF/issues/1913>`_: `draw_rect()`: does not respect width if color is not specified.\n  * **Fixed** `#1917 <https://github.com/pymupdf/PyMuPDF/issues/1917>`_: `subset_fonts()`: make it possible to silence the stdout.\n  * **Fixed** `#1936 <https://github.com/pymupdf/PyMuPDF/issues/1936>`_: Rectangle detection can be incorrect producing wrong output.\n  * **Fixed** `#1945 <https://github.com/pymupdf/PyMuPDF/issues/1945>`_: Segmentation fault when saving with `clean=True`.\n  * **Fixed** `#1965 <https://github.com/pymupdf/PyMuPDF/issues/1965>`_: `pdfocr_save()` Hard Crash.\n  * **Fixed** `#1971 <https://github.com/pymupdf/PyMuPDF/issues/1971>`_: Segmentation fault when using `get_drawings()`.\n  * **Fixed** `#1946 <https://github.com/pymupdf/PyMuPDF/issues/1946>`_: `block_no` and `block_type` switched in `get_text()` docs.\n  * **Fixed** `#2013 <https://github.com/pymupdf/PyMuPDF/issues/2013>`_: AttributeError: 'Widget' object has no attribute '_annot' in delete widget.\n\n* Misc changes to core code:\n\n  * Fixed various compiler warnings and a sequence-point bug.\n  * Added support for Memento builds.\n  * Fixed leaks detected by Memento in test suite.\n  * Fixed handling of exceptions in set_name() and set_rect().\n  * Allow build with latest MuPDF, for regular testing of PyMuPDF master.\n  * Cope with new MuPDF exceptions when setting rect for some Annot types.\n  * Reduced cosmetic differences between MuPDF's config.h and PyMuPDF's _config.h.\n  * Cope with various changes to MuPDF API.\n\n* Other:\n\n  * Fixed various broken links and typos in docs.\n  * Mention install of `swig-python` on MacOS for #875.\n  * Added (untested) wheels for macos-arm64.\n  \n\n\n\n**Changes in Version 1.20.2**\n\n* This release uses ``MuPDF-1.20.3``.\n\n* **Fixed** `#1787 <https://github.com/pymupdf/PyMuPDF/issues/1787>`_.\n  Fix linking issues on Unix systems.\n\n* **Fixed** `#1824 <https://github.com/pymupdf/PyMuPDF/issues/1824>`_.\n  SegFault when applying redactions overlapping a transparent image. (Fixed\n  in ``MuPDF-1.20.3``.)\n\n* Improvements to documentation:\n\n  * Improved information about building from source in ``docs/installation.rst``.\n  * Clarified memory allocation setting ``JM_MEMORY` in ``docs/tools.rst``.\n  * Fixed link to PDF Reference manual in ``docs/app3.rst``.\n  * Fixed building of html documentation on OpenBSD.\n  * Moved old ``docs/faq.rst`` into separate ``docs/recipes-*`` files.\n\n* Removed some unused files and directories:\n\n  * ``installation/``\n  * ``docs/wheelnames.txt``\n\n\n**Changes in Version 1.20.1**\n\n* **Fixed** `#1724 <https://github.com/pymupdf/PyMuPDF/issues/1724>`_.\n  Fix for building on FreeBSD.\n\n* **Fixed** `#1771 <https://github.com/pymupdf/PyMuPDF/issues/1771>`_.\n  `linkDest()` had a broken call to `re.match()`, introduced in 1.20.0.\n\n* **Fixed** `#1751 <https://github.com/pymupdf/PyMuPDF/issues/1751>`_.\n  `get_drawings()` and `get_cdrawings()` previously always returned with `closePath=False`.\n\n* **Fixed** `#1645 <https://github.com/pymupdf/PyMuPDF/issues/1645>`_.\n  Default FreeText annotation text color is now black.\n\n* Improvements to sphinx-generated documentation:\n\n  * Use readthedocs theme with enhancements.\n  * Renamed the `.txt` files to have `.rst` suffixes.\n\n------\n\n**Changes in Version 1.20.0**\n\nThis release uses ``MuPDF-1.20.0``, released 2022-06-15.\n\n* Cope with new MuPDF link uri format, changed from ``#<int>,<int>,<int>`` to ``#page=<int>&zoom=<float>,<float>,<float>``.\n\n * In ``tests/test_insertpdf.py``, use new reference output ``joined-1.20.pdf``. We also check that new output values are approximately the same as the old ones.\n\n* **Fixed** `#1738 <https://github.com/pymupdf/PyMuPDF/issues/1738>`_. Leak of `pdf_graft_map`.\n  Also fixed a SEGV issue that this seemed to expose, caused by incorrect freeing of underlying fz_document.\n\n* **Fixed** `#1733 <https://github.com/pymupdf/PyMuPDF/issues/1733>`_. Fixed ownership of `Annotation.get_pixmap()`.\n\nChanges to build/release process:\n\n* If pip builds from source because an appropriate wheel is not available, we no longer require MuPDF to be pre-installed. Instead the required MuPDF source is embedded in the sdist and automatically built into PyMuPDF.\n\n* Various changes to ``setup.py`` to download the required MuPDF release as required. See comments at start of setup.py for details.\n\n* Added ``.github/workflows/build_wheels.yml`` to control building of wheels on Github.\n\n------\n\n**Changes in Version 1.19.6**\n\n* **Fixed** `#1620 <https://github.com/pymupdf/PyMuPDF/issues/1620>`_. The :ref:`TextPage` created by :meth:`Page.get_textpage` will now be freed correctly (removed memory leak).\n* **Fixed** `#1601 <https://github.com/pymupdf/PyMuPDF/issues/1601>`_. Document open errors should now be more concise and easier to interpret. In the course of this, two PyMuPDF-specific Python exceptions have been **added:**\n\n    - ``EmptyFileError`` -- raised when trying to create a :ref:`Document` (``fitz.open()``) from an empty file or zero-length memory.\n    - ``FileDataError`` -- raised when MuPDF encounters irrecoverable document structure issues.\n\n* **Added** :meth:`Page.load_widget` given a PDF field's xref.\n\n* **Added** Dictionary :attr:`pdfcolor` which provide the about 500 colors defined as PDF color values with the lower case color name as key.\n\n* **Added** algebra functionality to the :ref:`Quad` class. These objects can now also be added and subtracted among themselves, and be multiplied by numbers and matrices.\n\n* **Added** new constants defining the default text extraction flags for more comfortable handling. Their naming convention is like :data:`TEXTFLAGS_WORDS` for ``page.get_text(\"words\")``. See :ref:`text_extraction_flags`.\n\n* **Changed** :meth:`Page.annots` and :meth:`Page.widgets` to detect and prevent reloading the page (illegally) inside the iterator loops via :meth:`Document.reload_page`. Doing this brings down the interpretor. Documented clean ways to do annotation and widget mass updates within properly designed loops.\n\n* **Changed** several internal utility functions to become standalone (\"SWIG inline\") as opposed to be part of the :ref:`Tools` class. This, among other things, increases the performance of geometry object creation.\n\n* **Changed** :meth:`Document.update_stream` to always accept stream updates - whether or not the dictionary object behind the xref already is a stream. Thus the former ``new`` parameter is now ignored and will be removed in v1.20.0.\n\n\n------\n\n**Changes in Version 1.19.5**\n\n* **Fixed** `#1518 <https://github.com/pymupdf/PyMuPDF/issues/1518>`_. A limited \"fix\": in some cases, rectangles and quadrupels were not correctly encoded to support re-drawing by :ref:`Shape`.\n\n* **Fixed** `#1521 <https://github.com/pymupdf/PyMuPDF/issues/1521>`_. This had the same ultimate reason behind issue #1510.\n\n* **Fixed** `#1513 <https://github.com/pymupdf/PyMuPDF/issues/1513>`_. Some Optional Content functions did not support non-ASCII characters.\n\n* **Fixed** `#1510 <https://github.com/pymupdf/PyMuPDF/issues/1510>`_. Support more soft-mask image subtypes.\n\n* **Fixed** `#1507 <https://github.com/pymupdf/PyMuPDF/issues/1507>`_. Immunize against items in the outlines chain, that are ``\"null\"`` objects.\n\n* **Fixed** re-opened `#1417 <https://github.com/pymupdf/PyMuPDF/issues/1417>`_. (\"too many open files\"). This was due to insufficient calls to MuPDF's ``fz_drop_document()``. This also fixes `#1550 <https://github.com/pymupdf/PyMuPDF/issues/1550>`_.\n\n* **Fixed** several undocumented issues in relation to incorrectly setting the text span origin :data:`point_like`.\n\n* **Fixed** undocumented error computing the character bbox in method :meth:`Page.get_texttrace` when text is **flipped** (as opposed to just rotated).\n\n* **Added** items to the dictionary returned by :meth:`image_properties`: ``orientation`` and ``transform`` report the natural image orientation (EXIF data).\n\n* **Added** method :meth:`Document.xref_copy`. It will make a given target PDF object an exact copy of a source object.\n\n\n------\n\n**Changes in Version 1.19.4**\n\n\n* **Fixed** `#1505 <https://github.com/pymupdf/PyMuPDF/issues/1505>`_. Immunize against circular outline items.\n\n* **Fixed** `#1484 <https://github.com/pymupdf/PyMuPDF/issues/1484>`_. Correct CropBox coordinates are now returned in all situations.\n\n* **Fixed** `#1479 <https://github.com/pymupdf/PyMuPDF/issues/1479>`_.\n\n* **Fixed** `#1474 <https://github.com/pymupdf/PyMuPDF/issues/1474>`_. TextPage objects are now properly deleted again.\n\n* **Added** :ref:`Page` methods and attributes for PDF ``/ArtBox``, ``/BleedBox``, ``/TrimBox``.\n\n* **Added** global attribute :attr:`TESSDATA_PREFIX` for easy checking of OCR support.\n\n* **Changed** :meth:`Document.xref_set_key` such that dictionary keys will physically be removed if set to value ``\"null\"``.\n\n* **Changed** :meth:`Document.extract_font` to optionally return a dictionary (instead of a tuple).\n\n------\n\n**Changes in Version 1.19.3**\n\nThis patch version implements minor improvements for :ref:`Pixmap` and also some important fixes.\n\n* **Fixed** `#1351 <https://github.com/pymupdf/PyMuPDF/discussions/1351>`_. Reverted code that introduced the memory growth in v1.18.15.\n\n* **Fixed** `#1417 <https://github.com/pymupdf/PyMuPDF/discussions/1417>`_. Developped circumvention for growth of open file handles using :meth:`Document.insert_pdf`.\n\n* **Fixed** `#1418 <https://github.com/pymupdf/PyMuPDF/discussions/1418>`_. Developped circumvention for memory growth using :meth:`Document.insert_pdf`.\n\n* **Fixed** `#1430 <https://github.com/pymupdf/PyMuPDF/discussions/1430>`_. Developped circumvention for mass pixmap generations of document pages.\n\n* **Fixed** `#1433 <https://github.com/pymupdf/PyMuPDF/discussions/1433>`_. Solves a bbox error for some Type 3 font in PyMuPDF text processing.\n\n* **Added** :meth:`Pixmap.color_topusage` to determine the share of the most frequently used color. Solves `#1397 <https://github.com/pymupdf/PyMuPDF/discussions/1397>`_.\n\n* **Added** :meth:`Pixmap.warp` which makes a new pixmap from a given arbitrary convex quad inside the pixmap.\n\n* **Added** :attr:`Annot.irt_xref` and :meth:`Annot.set_irt_xref` to inquire or set the `/IRT` (\"In Responde To\") property of an annotation. Implements `#1450 <https://github.com/pymupdf/PyMuPDF/discussions/1450>`_.\n\n* **Added** :meth:`Rect.torect` and :meth:`IRect.torect` which compute a matrix that transforms to a given other rectangle.\n\n* **Changed** :meth:`Pixmap.color_count` to also return the count of each color.\n* **Changed** :meth:`Page.get_texttrace` to also return correct span and character bboxes if ``span[\"dir\"] != (1, 0)``.\n\n------\n\n**Changes in Version 1.19.2**\n\nThis patch version implements minor improvements for :meth:`Page.get_drawings` and also some important fixes.\n\n* **Fixed** `#1388 <https://github.com/pymupdf/PyMuPDF/discussions/1388>`_. Fixed intermittent memory corruption when insert or updating annotations.\n\n* **Fixed** `#1375 <https://github.com/pymupdf/PyMuPDF/discussions/1375>`_. Inconsistencies between line numbers as returned by the \"words\" and the \"dict\" options of :meth:`Page.get_text` have been corrected.\n\n* **Fixed** `#1364 <https://github.com/pymupdf/PyMuPDF/issues/1342>`_. The check for being a ``\"rawdict\"`` span in :meth:`recover_span_quad` now works correctly.\n\n* **Fixed** `#1342 <https://github.com/pymupdf/PyMuPDF/issues/1364>`_. Corrected the check for rectangle infiniteness in :meth:`Page.show_pdf_page`.\n\n* **Changed** :meth:`Page.get_drawings`, :meth:`Page.get_cdrawings` to return an indicator on the area orientation covered by a rectangle. This implements `#1355 <https://github.com/pymupdf/PyMuPDF/issues/1355>`_. Also, the recognition rate for rectangles and quads has been significantly improved.\n\n* **Changed** all text search and extraction methods to set the new ``flags`` option ``TEXT_MEDIABOX_CLIP`` to ON by default. That bit causes the automatic suppression of all characters that are completely outside a page's mediabox (in as far as that notion is supported for a document type). This eliminates the need for using ``clip=page.rect`` or similar for omitting text outside the visible area.\n\n* **Added** parameter ``\"dpi\"`` to :meth:`Page.get_pixmap` and :meth:`Annot.get_pixmap`. When given, parameter ``\"matrix\"`` is ignored, and a :ref:`Pixmap` with the desired dots per inch is created.\n\n* **Added** attributes :attr:`Pixmap.is_monochrome` and :attr:`Pixmap.is_unicolor` allowing fast checks of pixmap properties. Addresses `#1397 <https://github.com/pymupdf/PyMuPDF/discussions/1397>`_.\n\n* **Added** method :meth:`Pixmap.color_count` to determine the unique colors in the pixmap.\n\n* **Added** boolean parameter ``\"compress\"`` to PDF document method :meth:`Document.update_stream`. Addresses / enables solution for `#1408 <https://github.com/pymupdf/PyMuPDF/discussions/1408>`_.\n\n------\n\n**Changes in Version 1.19.1**\n\nThis is the first patch version to support MuPDF v1.19.0. Apart from one bug fix, it includes important improvements for OCR support and the option to **sort extracted text** to the standard reading order \"from top-left to bottom-right\".\n\n* **Fixed** `#1328 <https://github.com/pymupdf/PyMuPDF/issues/1328>`_. \"words\" text extraction again returns correct ``(x0, y0)`` coordinates.\n\n* **Changed** :meth:`Page.get_textpage_ocr`: it now supports parameter ``dpi`` to control OCR quality. It is also possible to choose whether the **full page** should be OCRed or **only the images displayed** by the page.\n\n* **Changed** :meth:`Page.get_drawings` and :meth:`Page.get_cdrawings` to automatically convert colors to RGB color tuples. Implements `#1332 <https://github.com/pymupdf/PyMuPDF/discussions/1332>`_. Similar change was applied to :meth:`Page.get_texttrace`.\n\n* **Changed** :meth:`Page.get_text` to support a parameter ``sort``. If set to ``True`` the output is conveniently sorted.\n\n\n------\n\n**Changes in Version 1.19.0**\n\nThis is the first version supporting MuPDF 1.19.*, published 2021-10-05. It introduces many new features compared to the previous version 1.18.*.\n\nPyMuPDF has now picked up integrated Tesseract OCR support, which was already present in MuPDF v1.18.0.\n\n* Supported images can be OCRed via their :ref:`Pixmap` which results in a 1-page PDF with a text layer.\n* All supported document pages (i.e. not only PDFs), can be OCRed using specialized text extraction methods. The result is a mixture of standard and OCR text (depending on which part of the page was deemed to require OCRing) that can be searched and extracted without restrictions.\n* All this requires an independent installation of Tesseract. MuPDF actually (only) needs the location of Tesseract's ``\"tessdata\"`` folder, where its language support data are stored. This location must be available as environment variable ``TESSDATA_PREFIX``.\n\nA new MuPDF feature is **journalling PDF updates**, which is also supported by this PyMuPDF version. Changes may be logged, rolled back or replayed, allowing to implement a whole new level of control over PDF document integrity -- similar to functions present in modern database systems.\n\nA third feature (unrelated to the new MuPDF version) includes the ability to detect when page **objects cover or hide each other**. It is now e.g. possible to see that text is covered by a drawing or an image.\n\n* **Changed** terminology and meaning of important geometry concepts: Rectangles are now characterized as *finite*, *valid* or *empty*, while the definitions of these terms have also changed. Rectangles specifically are now thought of being \"open\": not all corners and sides are considered part of the retangle. Please do read the :ref:`Rect` section for details.\n\n* **Added** new parameter `\"no_new_id\"` to :meth:`Document.save` / :meth:`Document.tobytes` methods. Use it to suppress updating the second item of the document ``/ID`` which in PDF indicates that the original file has been updated. If the PDF has no ``/ID`` at all yet, then no new one will be created either.\n\n* **Added** a **journalling facility** for PDF updates. This allows logging changes, undoing or redoing them, or saving the journal for later use. Refer to :meth:`Document.journal_enable` and friends.\n\n* **Added** new :ref:`Pixmap` methods :meth:`Pixmap.pdfocr_save` and :meth:`Pixmap.pdfocr_tobytes`, which generate a 1-page PDF containing the pixmap as PNG image with OCR text layer.\n\n* **Added** :meth:`Page.get_textpage_ocr` which executes optical character recognition for the page, then extracts the results and stores them together with \"normal\" page content in a :ref:`TextPage`. Use or reuse this object in subsequent text extractions and text searches to avoid multiple efforts. The existing text search and text extraction methods have been extended to support a separately created textpage -- see next item.\n\n* **Added** a new parameter ``textpage`` to text extraction and text search methods. This allows reuse of a previously created :ref:`TextPage` and thus achieves significant runtime benefits -- which is especially important for the new OCR features. But \"normal\" text extractions can definitely also benefit.\n\n* **Added** :meth:`Page.get_texttrace`, a technical method delivering low-level text character properties. It was present before as a private method, but the author felt it now is mature enough to be officially available. It specifically includes a \"sequence number\" which indicates the page appearance build operation that painted the text.\n\n* **Added** :meth:`Page.get_bboxlog` which delivers the list of rectangles of page objects like text, images or drawings. Its significance lies in its sequence: rectangles intersecting areas with a lower index are covering or hiding them.\n\n* **Changed** methods :meth:`Page.get_drawings` and :meth:`Page.get_cdrawings` to include a \"sequence number\" indicating the page appearance build operation that created the drawing.\n\n* **Fixed** `#1311 <https://github.com/pymupdf/PyMuPDF/issues/1311>`_. Field values in comboboxes should now be handled correctly.\n* **Fixed** `#1290 <https://github.com/pymupdf/PyMuPDF/issues/1290>`_. Error was caused by incorrect rectangle emptiness check, which is fixed due to new geometry logic of this version.\n* **Fixed** `#1286 <https://github.com/pymupdf/PyMuPDF/issues/1286>`_. Text alignment for redact annotations is working again.\n* **Fixed** `#1287 <https://github.com/pymupdf/PyMuPDF/issues/1287>`_. Infinite loop issue for non-Windows systems when applying some redactions has been resolved.\n* **Fixed** `#1284 <https://github.com/pymupdf/PyMuPDF/issues/1284>`_. Text layout destruction after applying redactions in some cases has been resolved.\n\n------\n\n**Changes in Version 1.18.18 / 1.18.19**\n\n* **Fixed** issue `#1266 <https://github.com/pymupdf/PyMuPDF/issues/1266>`_. Failure to set :attr:`Pixmap.samples` in important cases, was hotfixed in a new version 1.18.19.\n\n* **Fixed** issue `#1257 <https://github.com/pymupdf/PyMuPDF/issues/1257>`_. Removing the read-only flag from PDF fields is now possible.\n\n* **Fixed** issue `#1252 <https://github.com/pymupdf/PyMuPDF/issues/1252>`_. Now correctly specifying the ``zoom`` value for PDF link annotations.\n\n* **Fixed** issue `#1244 <https://github.com/pymupdf/PyMuPDF/issues/1244>`_. Now correctly computing the transform matrix in :meth:`Page.get_image__bbox`.\n\n* **Fixed** issue `#1241 <https://github.com/pymupdf/PyMuPDF/issues/1241>`_. Prevent returning artifact characters in :meth:`Page.get_textbox`, which happened in certain constellations.\n\n* **Fixed** issue `#1234 <https://github.com/pymupdf/PyMuPDF/issues/1234>`_. Avoid creating infinite rectangles in corner cases -- :meth:`Page.get_drawings`, :meth:`Page.get_cdrawings`.\n\n* **Added** test data and test scripts to the source PyPI source distribution.\n\n------\n\n**Changes in Version 1.18.17**\n\nFocus of this version are major performance improvements of selected functions.\n\n* **Fixed** issue `#1199 <https://github.com/pymupdf/PyMuPDF/issues/1199>`_. Using a non-existing page number in :meth:`Document.get_page_images` and friends will no longer lead to segfaults.\n\n* **Changed** :meth:`Page.get_drawings` to now differentiate between \"stroke\", \"fill\" and combined paths. Paths containing more than one rectangle (i.e. \"re\" items) are now supported. Extracting \"clipped\" paths is now available as an option.\n\n* **Added** :meth:`Page.get_cdrawings`, performance-optimized version of :meth:`Page.get_drawings`.\n\n* **Added** :attr:`Pixmap.samples_mv`, *memoryview* of a pixmap's pixel area. Does not copy and thus always accesses the current state of that area.\n\n* **Added** :attr:`Pixmap.samples_ptr`, Python \"pointer\" to a pixmap's pixel area. Allows much faster creation (factor 800+) of Qt images.\n\n\n\n------\n\n**Changes in Version 1.18.16**\n\n* **Fixed** issue `#1184 <https://github.com/pymupdf/PyMuPDF/issues/1184>`_. Existing PDF widget fonts in a PDF are now accepted (i.e. not forcedly changed to a Base-14 font).\n\n* **Fixed** issue `#1154 <https://github.com/pymupdf/PyMuPDF/issues/1154>`_. Text search hits should now be correct when ``clip`` is specified.\n\n* **Fixed** issue `#1152 <https://github.com/pymupdf/PyMuPDF/issues/1152>`_.\n\n* **Fixed** issue `#1146 <https://github.com/pymupdf/PyMuPDF/issues/1146>`_.\n\n* **Added** :attr:`Link.flags` and :meth:`Link.set_flags` to the :ref:`Link` class. Implements enhancement requests `#1187 <https://github.com/pymupdf/PyMuPDF/issues/1187>`_.\n\n* **Added** option to *simulate* :meth:`TextWriter.fill_textbox` output for predicting the number of lines, that a given text would occupy in the textbox.\n\n* **Added** text output support as subcommand `gettext` to the ``fitz`` CLI module. Most importantly, original **physical text layout** reproduction is now supported.\n\n\n------\n\n**Changes in Version 1.18.15**\n\n* **Fixed** issue `#1088 <https://github.com/pymupdf/PyMuPDF/issues/1088>`_. Removing an annotation's fill color should now work again both ways, using the ``fill_color=[]`` argument in :meth:`Annot.update` as well as ``fill=[]`` in :meth:`Annot.set_colors`.\n\n* **Fixed** issue `#1081 <https://github.com/pymupdf/PyMuPDF/issues/1081>`_. :meth:`Document.subset_fonts`: fixed an error which created wrong character widths for some fonts.\n\n* **Fixed** issue `#1078 <https://github.com/pymupdf/PyMuPDF/issues/1078>`_. :meth:`Page.get_text` and other methods related to text extraction: changed the default value of the :ref:`TextPage` ``flags`` parameter. All whitespace and :data:`ligatures` are now preserved.\n\n* **Fixed** issue `#1085 <https://github.com/pymupdf/PyMuPDF/issues/1085>`_. The old *snake_cased* alias of ``fitz.detTextlength`` is now defined correctly.\n\n* **Changed** :meth:`Document.subset_fonts` will now correctly prefix font subsets with an appropriate six letter uppercase tag, complying with the PDF specification.\n\n* **Added** new method :meth:`Widget.button_states` which returns the possible values that a button-type field can have when being set to \"on\" or \"off\".\n\n* **Added** support of text with **Small Capital** letters to the :ref:`Font` and :ref:`TextWriter` classes. This is reflected by an additional bool parameter ``small_caps`` in various of their methods.\n\n\n------\n\n**Changes in Version 1.18.14**\n\n* **Finished** implementing new, \"snake_cased\" names for methods and properties, that were \"camelCased\" and awkward in many aspects. At the end of this documentation, there is section :ref:`Deprecated` with more background and a mapping of old to new names.\n\n* **Fixed** issue `#1053 <https://github.com/pymupdf/PyMuPDF/issues/1053>`_. :meth:`Page.insert_image`: when given, include image mask in the hash computation.\n\n* **Fixed** issue `#1043 <https://github.com/pymupdf/PyMuPDF/issues/1043>`_. Added ``Pixmap.getPNGdata`` to the aliases of :meth:`Pixmap.tobytes`.\n\n* **Fixed** an internal error when computing the enveloping rectangle of drawn paths as returned by :meth:`Page.get_drawings`.\n\n* **Fixed** an internal error occasionally causing loops when outputting text via :meth:`TextWriter.fill_textbox`.\n\n* **Added** :meth:`Font.char_lengths`, which returns a tuple of character widths of a string.\n\n* **Added** more ways to specify pages in :meth:`Document.delete_pages`. Now a sequence (list, tuple or range) can be specified, and the Python ``del`` statement can be used. In the latter case, Python ``slices`` are also accepted.\n\n* **Changed** :meth:`Document.del_toc_item`, which disables a single item of the TOC: previously, the title text was removed. Instead, now the complete item will be shown grayed-out by supporting viewers.\n\n\n------\n\n**Changes in Version 1.18.13**\n\n* **Fixed** issue `#1014 <https://github.com/pymupdf/PyMuPDF/issues/1014>`_.\n* **Fixed** an internal memory leak when computing image bboxes -- :meth:`Page.get_image_bbox`.\n* **Added** support for low-level access and modification of the PDF trailer. Applies to :meth:`Document.xref_get_keys`, :meth:`Document.xref_get_key`, and :meth:`Document.xref_set_key`.\n* **Added** documentation for maintaining private entries in PDF metadata.\n* **Added** documentation for handling transparent image insertions, :meth:`Page.insert_image`.\n* **Added** :meth:`Page.get_image_rects`, an improved version of :meth:`Page.get_image_bbox`.\n* **Changed** :meth:`Document.delete_pages` to support various ways of specifying pages to delete. Implements `#1042 <https://github.com/pymupdf/PyMuPDF/issues/1042>`_.\n* **Changed** :meth:`Page.insert_image` to also accept the xref of an existing image in the file. This allows \"copying\" images between pages, and extremely fast mutiple insertions.\n* **Changed** :meth:`Page.insert_image` to also accept the integer parameter ``alpha``. To be used for performance improvements.\n* **Changed** :meth:`Pixmap.set_alpha` to support new parameters for pre-multiplying colors with their alpha values and setting a specific color to fully transparent (e.g. white).\n* **Changed** :meth:`Document.embfile_add` to automatically set creation and modification date-time. Correspondingly, :meth:`Document.embfile_upd` automatically maintains modification date-time (``/ModDate`` PDF key), and :meth:`Document.embfile_info` correspondingly reports these data. In addition, the embedded file's associated \"collection item\" is included via its :data:`xref`. This supports the development of PDF portfolio applications.\n\n------\n\n**Changes in Version 1.18.11 / 1.18.12**\n\n* **Fixed** issue `#972 <https://github.com/pymupdf/PyMuPDF/issues/972>`_. Improved layout of source distribution material.\n* **Fixed** issue `#962 <https://github.com/pymupdf/PyMuPDF/issues/962>`_. Stabilized Linux distribution detection for generating PyMuPDF from sources.\n* **Added:** :meth:`Page.get_xobjects` delivers the result of :meth:`Document.get_page_xobjects`.\n* **Added:** :meth:`Page.get_image_info` delivers meta information for all images shown on the page.\n* **Added:** :meth:`Tools.mupdf_display_warnings` allows setting on / off the display of MuPDF-generated warnings. The default is off.\n* **Added:** :meth:`Document.ez_save` convenience alias of :meth:`Document.save` with some different defaults.\n* **Changed:** Image extractions of document pages now also contain the image's **transformation matrix**. This concerns :meth:`Page.get_image_bbox` and the DICT, JSON, RAWDICT, and RAWJSON variants of :meth:`Page.get_text`.\n\n\n------\n\n**Changes in Version 1.18.10**\n\n* **Fixed** issue `#941 <https://github.com/pymupdf/PyMuPDF/issues/941>`_. Added old aliases for :meth:`DisplayList.get_pixmap` and :meth:`DisplayList.get_textpage`.\n* **Fixed** issue `#929 <https://github.com/pymupdf/PyMuPDF/issues/929>`_. Stabilized removal of JavaScript objects with :meth:`Document.scrub`.\n* **Fixed** issue `#927 <https://github.com/pymupdf/PyMuPDF/issues/927>`_. Removed a loop in the reworked :meth:`TextWriter.fill_textbox`.\n* **Changed** :meth:`Document.xref_get_keys` and :meth:`Document.xref_get_key` to also allow accessing the PDF trailer dictionary. This can be done by using `-1` as the xref number argument.\n* **Added** a number of functions for reconstructing the quads for text lines, spans and characters extracted by :meth:`Page.get_text` options \"dict\" and \"rawdict\". See :meth:`recover_quad` and friends.\n* **Added** :meth:`Tools.unset_quad_corrections` to suppress character quad corrections (occasionally required for erroneous fonts).\n\n------\n\n**Changes in Version 1.18.9**\n\n\n* **Fixed** issue `#888 <https://github.com/pymupdf/PyMuPDF/issues/888>`_. Removed ambiguous statements concerning PyMuPDF's license, which is now clearly stated to be GNU AGPL V3.\n* **Fixed** issue `#895 <https://github.com/pymupdf/PyMuPDF/issues/895>`_.\n* **Fixed** issue `#896 <https://github.com/pymupdf/PyMuPDF/issues/896>`_. Since v1.17.6 PyMuPDF suppresses the font subset tags and only reports the base fontname in text extraction outputs \"dict\" / \"json\" / \"rawdict\" / \"rawjson\". Now a new global parameter can request the old behaviour, :meth:`Tools.set_subset_fontnames`.\n* **Fixed** issue `#885 <https://github.com/pymupdf/PyMuPDF/issues/885>`_. Pixmap creation now also works with filenames given as ``pathlib.Paths``.\n* **Changed** :meth:`Document.subset_fonts`: Text is **not rewritten** any more and should therefore **retain all its origial properties** -- like being hidden or being controlled by Optional Content mechanisms.\n* **Changed** :ref:`TextWriter` output to also accept text in right to left mode (Arabian, Hebrew): :meth:`TextWriter.fill_textbox`, :meth:`TextWriter.append`. These methods now accept a new boolean parameter `right_to_left`, which is *False* by default. Implements `#897 <https://github.com/pymupdf/PyMuPDF/issues/897>`_.\n* **Changed** :meth:`TextWriter.fill_textbox` to return all lines of text, that did not fit in the given rectangle. Also changed the default of the ``warn`` parameter to no longer print a warning message in overflow situations.\n* **Added** a utility function :meth:`recover_quad`, which computes the quadrilateral of a span. This function can be used for correctly marking text extracted with the \"dict\" or \"rawdict\" options of :meth:`Page.get_text`.\n\n------\n\n**Changes in Version 1.18.8**\n\n\nThis is a bug fix version only. We are publishing early because of the potentially widely used functions.\n\n* **Fixed** issue `#881 <https://github.com/pymupdf/PyMuPDF/issues/881>`_. Fixed a memory leak in :meth:`Page.insert_image` when inserting images from files or memory.\n* **Fixed** issue `#878 <https://github.com/pymupdf/PyMuPDF/issues/878>`_. ``pathlib.Path`` objects should now correctly handle file path hierarchies.\n\n\n------\n\n**Changes in Version 1.18.7**\n\n\n* **Added** an experimental :meth:`Document.subset_fonts` which reduces the size of eligible fonts based on their use by text in the PDF. Implements `#855 <https://github.com/pymupdf/PyMuPDF/discussions/855>`_.\n* **Implemented** request `#870 <https://github.com/pymupdf/PyMuPDF/pull/870>`_: :meth:`Document.convert_to_pdf` now also supports PDF documents.\n* **Renamed** ``Document.write`` to :meth:`Document.tobytes` for greater clarity. But the deprecated name remains available for some time.\n* **Implemented** request `#843 <https://github.com/pymupdf/PyMuPDF/Discussions/843>`_: :meth:`Document.tobytes` now supports linearized PDF output. :meth:`Document.save` now also supports writing to Python **file objects**. In addition, the open function now also supports Python file objects.\n* **Fixed** issue `#844 <https://github.com/pymupdf/PyMuPDF/issues/844>`_.\n* **Fixed** issue `#838 <https://github.com/pymupdf/PyMuPDF/issues/838>`_.\n* **Fixed** issue `#823 <https://github.com/pymupdf/PyMuPDF/issues/823>`_. More logic for better support of OCRed text output (Tesseract, ABBYY).\n* **Fixed** issue `#818 <https://github.com/pymupdf/PyMuPDF/issues/818>`_.\n* **Fixed** issue `#814 <https://github.com/pymupdf/PyMuPDF/issues/814>`_.\n* **Added** :meth:`Document.get_page_labels` which returns a list of page label definitions of a PDF.\n* **Added** :meth:`Document.has_annots` and :meth:`Document.has_links` to check whether these object types are present anywhere in a PDF.\n* **Added** expert low-level functions to simplify inquiry and modification of PDF object sources: :meth:`Document.xref_get_keys` lists the keys of object :data:`xref`, :meth:`Document.xref_get_key` returns type and content of a key, and :meth:`Document.xref_set_key` modifies the key's value.\n* **Added** parameter ``thumbnails`` to :meth:`Document.scrub` to also allow removing page thumbnail images.\n* **Improved** documentation for how to add valid text marker annotations for non-horizontal text.\n\nWe continued the process of renaming methods and properties from *\"mixedCase\"* to *\"snake_case\"*. Documentation usually mentions the new names only, but old, deprecated names remain available for some time.\n\n\n\n------\n\n**Changes in Version 1.18.6**\n\n* **Fixed** issue `#812 <https://github.com/pymupdf/PyMuPDF/issues/812>`_.\n* **Fixed** issue `#793 <https://github.com/pymupdf/PyMuPDF/issues/793>`_. Invalid document metadata previously prevented opening some documents at all. This error has been removed.\n* **Fixed** issue `#792 <https://github.com/pymupdf/PyMuPDF/issues/792>`_. Text search and text extraction will make no rectangle containment checks at all if the default ``clip=None`` is used.\n* **Fixed** issue `#785 <https://github.com/pymupdf/PyMuPDF/issues/785>`_.\n* **Fixed** issue `#780 <https://github.com/pymupdf/PyMuPDF/issues/780>`_. Corrected a parameter check error.\n* **Fixed** issue `#779 <https://github.com/pymupdf/PyMuPDF/issues/779>`_. Fixed typo\n* **Added** an option to set the desired line height for text boxes. Implements `#804 <https://github.com/pymupdf/PyMuPDF/issues/804>`_.\n* **Changed** text position retrieval to better cope with Tesseract's glyphless font. Implements `#803 <https://github.com/pymupdf/PyMuPDF/issues/803>`_.\n* **Added** an option to choose the prefix of new annotations, fields and links for providing unique annotation ids. Implements request `#807 <https://github.com/pymupdf/PyMuPDF/issues/807>`_.\n* **Added** getting and setting color and text properties for Table of Contents items for PDFs. Implements `#779 <https://github.com/pymupdf/PyMuPDF/issues/779>`_.\n* **Added** PDF page label handling: :meth:`Page.get_label()` returns the page label, :meth:`Document.get_page_numbers` return all page numbers having a specified label, and :meth:`Document.set_page_labels` adds or updates a PDF's page label definition.\n\n\n\n.. note::\n   This version introduces **Python type hinting**. The goal is to provide each parameter and the return value of all functions and methods with type information. This still is work in progress although the majority of functions has already been handled.\n\n\n------\n\n**Changes in Version 1.18.5**\n\nApart from several fixes, this version also focusses on several minor, but important feature improvements. Among the latter is a more precise computation of proper line heights and insertion points for writing / inserting text. As opposed to using font-agnostic constants, these values are now taken from the font's properties.\n\nAlso note that this is the first version which does no longer provide pregenerated wheels for Python versions older than 3.6. PIP also discontinues support for these by end of this year 2020.\n\n* **Fixed** issue `#771 <https://github.com/pymupdf/PyMuPDF/issues/771>`_. By using \"small glyph heights\" option, the full page text can be extracted.\n* **Fixed** issue `#768 <https://github.com/pymupdf/PyMuPDF/issues/768>`_.\n* **Fixed** issue `#750 <https://github.com/pymupdf/PyMuPDF/issues/750>`_.\n* **Fixed** issue `#739 <https://github.com/pymupdf/PyMuPDF/issues/739>`_. The \"dict\", \"rawdict\" and corresponding JSON output variants now have two new *span* keys: ``\"ascender\"`` and ``\"descender\"``. These floats represent special font properties which can be used to compute bboxes of spans or characters of **exactly fontsize height** (as opposed to the default line height). An example algorithm is shown in section \"Span Dictionary\" `here <https://pymupdf.readthedocs.io/en/latest/textpage.html#dictionary-structure-of-extractdict-and-extractrawdict>`_. Also improved the detection and correction of ill-specified ascender / descender values encountered in some fonts.\n* **Added** a new, experimental :meth:`Tools.set_small_glyph_heights` -- also in response to issue `#739 <https://github.com/pymupdf/PyMuPDF/issues/739>`_. This method sets or unsets a global parameter to **always compute bboxes with fontsize height**. If \"on\", text searching and all text extractions will returned rectangles, bboxes and quads with a smaller height.\n* **Fixed** issue `#728 <https://github.com/pymupdf/PyMuPDF/issues/728>`_.\n* **Changed** fill color logic of 'Polyline' annotations: this parameter now only pertains to line end symbols -- the annotation itself can no longer have a fill color. Also addresses issue `#727 <https://github.com/pymupdf/PyMuPDF/issues/727>`_.\n* **Changed** :meth:`Page.getImageBbox` to also compute the bbox if the image is contained in an XObject.\n* **Changed** :meth:`Shape.insertTextbox`, resp. :meth:`Page.insertTextbox`, resp. :meth:`TextWriter.fillTextbox` to respect font's properties \"ascender\" / \"descender\" when computing line height and insertion point. This should no longer lead to line overlaps for multi-line output. These methods used to ignore font specifics and used constant values instead.\n\n\n------\n\n**Changes in Version 1.18.4**\n\nThis version adds several features to support PDF Optional Content. Among other things, this includes OCMDs (Optional Content Membership Dictionaries) with the full scope of *\"visibility expressions\"* (PDF key ``/VE``), text insertions (including the :ref:`TextWriter` class) and drawings.\n\n* **Fixed** issue `#727 <https://github.com/pymupdf/PyMuPDF/issues/727>`_. Freetext annotations now support an uncolored rectangle when ``fill_color=None``.\n* **Fixed** issue `#726 <https://github.com/pymupdf/PyMuPDF/issues/726>`_. UTF-8 encoding errors are now handled for HTML / XML :meth:`Page.getText` output.\n* **Fixed** issue `#724 <https://github.com/pymupdf/PyMuPDF/issues/724>`_. Empty values are no longer stored in the PDF /Info metadata dictionary.\n* **Added** new methods :meth:`Document.set_oc` and :meth:`Document.get_oc` to set or get optional content references for **existing** image and form XObjects. These methods are similar to the same-named methods of :ref:`Annot`.\n* **Added** :meth:`Document.set_ocmd`, :meth:`Document.get_ocmd` for handling OCMDs.\n* **Added** **Optional Content** support for text insertion and drawing.\n* **Added** new method :meth:`Page.deleteWidget`, which deletes a form field from a page. This is analogous to deleting annotations.\n* **Added** support for Popup annotations. This includes defining the Popup rectangle and setting the Popup to open or closed. Methods / attributes :meth:`Annot.set_popup`, :meth:`Annot.set_open`, :attr:`Annot.has_popup`, :attr:`Annot.is_open`, :attr:`Annot.popup_rect`, :attr:`Annot.popup_xref`.\n\nOther changes:\n\n* The **naming of methods and attributes** in PyMuPDF is far from being satisfactory: we have *CamelCases*, *mixedCases* and *lower_case_with_underscores* all over the place. With the :ref:`Annot` as the first candidate, we have started an activity to clean this up step by step, converting to lower case with underscores for methods and attributes while keeping UPPERCASE for the constants.\n\n   - Old names will remain available to prevent code breaks, but they will no longer be mentioned in the documentation.\n   - New methods and attributes of all classes will be named according to the new standard.\n\n------\n\n**Changes in Version 1.18.3**\n\nAs a major new feature, this version introduces support for PDF's **Optional Content** concept.\n\n* **Fixed** issue `#714 <https://github.com/pymupdf/PyMuPDF/issues/714>`_.\n* **Fixed** issue `#711 <https://github.com/pymupdf/PyMuPDF/issues/711>`_.\n* **Fixed** issue `#707 <https://github.com/pymupdf/PyMuPDF/issues/707>`_: if a PDF user password, but no owner password is supplied nor present, then the user password is also used as the owner password.\n* **Fixed** ``expand`` and ``deflate`` parameters of methods :meth:`Document.save` and :meth:`Document.write`. Individual image and font compression should now finally work. Addresses issue `#713 <https://github.com/pymupdf/PyMuPDF/issues/713>`_.\n* **Added** a support of PDF optional content. This includes several new :ref:`Document` methods for inquiring and setting optional content status and adding optional content configurations and groups. In addition, images, form XObjects and annotations now can be bound to optional content specifications. **Resolved** issue `#709 <https://github.com/pymupdf/PyMuPDF/issues/709>`_.\n\n\n\n------\n\n**Changes in Version 1.18.2**\n\nThis version contains some interesting improvements for text searching: any number of search hits is now returned and the **hit_max** parameter was removed. The new **clip** parameter in addition allows to restrict the search area. Searching now detects hyphenations at line breaks and accordingly finds hyphenated words.\n\n* **Fixed** issue `#575 <https://github.com/pymupdf/PyMuPDF/issues/575>`_: if using ``quads=False`` in text searching, then overlapping rectangles on the same line are joined. Previously, parts of the search string, which belonged to different \"marked content\" items, each generated their own rectangle -- just as if occurring on separate lines.\n* **Added** :attr:`Document.isRepaired`, which is true if the PDF was repaired on open.\n* **Added** :meth:`Document.setXmlMetadata` which either updates or creates PDF XML metadata. Implements issue `#691 <https://github.com/pymupdf/PyMuPDF/issues/691>`_.\n* **Added** :meth:`Document.getXmlMetadata` returns PDF XML metadata.\n* **Changed** creation of PDF documents: they will now always carry a PDF identification (``/ID`` field) in the document trailer. Implements issue `#691 <https://github.com/pymupdf/PyMuPDF/issues/691>`_.\n* **Changed** :meth:`Page.searchFor`: a new parameter ``clip`` is accepted to restrict the search to this rectangle. Correspondingly, the attribute :attr:`TextPage.rect` is now respected by :meth:`TextPage.search`.\n* **Changed** parameter ``hit_max`` in :meth:`Page.searchFor` and :meth:`TextPage.search` is now obsolete: methods will return all hits.\n* **Changed** character **selection criteria** in :meth:`Page.getText`: a character is now considered to be part of a ``clip`` if its bbox is fully contained. Before this, a non-empty intersection was sufficient.\n* **Changed** :meth:`Document.scrub` to support a new option `redact_images`. This addresses issue `#697 <https://github.com/pymupdf/PyMuPDF/issues/697>`_.\n\n\n------\n\n**Changes in Version 1.18.1**\n\n* **Fixed** issue `#692 <https://github.com/pymupdf/PyMuPDF/issues/692>`_. PyMuPDF now detects and recovers from more cyclic resource dependencies in PDF pages and for the first time reports them in the MuPDF warnings store.\n* **Fixed** issue `#686 <https://github.com/pymupdf/PyMuPDF/issues/686>`_.\n* **Added** opacity options for the :ref:`Shape` class: Stroke and fill colors can now be set to some transparency value. This means that all :ref:`Page` draw methods, methods :meth:`Page.insertText`, :meth:`Page.insertTextbox`, :meth:`Shape.finish`, :meth:`Shape.insertText`, and :meth:`Shape.insertTextbox` support two new parameters: *stroke_opacity* and *fill_opacity*.\n* **Added** new parameter ``mask`` to :meth:`Page.insertImage` for optionally providing an external image mask. Resolves issue `#685 <https://github.com/pymupdf/PyMuPDF/issues/685>`_.\n* **Added** :meth:`Annot.soundGet` for extracting the sound of an audio annotation.\n\n------\n\n**Changes in Version 1.18.0**\n\nThis is the first PyMuPDF version supporting MuPDF v1.18. The focus here is on extending PyMuPDF's own functionality -- apart from bug fixing. Subsequent PyMuPDF patches may address features new in MuPDF.\n\n* **Fixed** issue `#519 <https://github.com/pymupdf/PyMuPDF/issues/519>`_. This upstream bug occurred occasionally for some pages only and seems to be fixed now: page layout should no longer be ruined in these cases.\n\n* **Fixed** issue `#675 <https://github.com/pymupdf/PyMuPDF/issues/675>`_.\n\n  - Unsuccessful storage allocations should now always lead to exceptions (circumvention of an upstream bug intermittently crashing the interpreter).\n  - :ref:`Pixmap` size is now based on ``size_t`` instead of ``int`` in C and should be correct even for extremely large pixmaps.\n\n* **Fixed** issue `#668 <https://github.com/pymupdf/PyMuPDF/issues/668>`_. Specification of dashes for PDF drawing insertion should now correctly reflect the PDF spec.\n* **Fixed** issue `#669 <https://github.com/pymupdf/PyMuPDF/issues/669>`_. A major source of memory leakage in :meth:`Page.insert_pdf` has been removed.\n* **Added** keyword *\"images\"* to :meth:`Page.apply_redactions` for fine-controlling the handling of images.\n* **Added** :meth:`Annot.getText` and :meth:`Annot.getTextbox`, which offer the same functionality as the :ref:`Page` versions.\n* **Added** key *\"number\"* to the block dictionaries of :meth:`Page.getText` / :meth:`Annot.getText` for options \"dict\" and \"rawdict\".\n* **Added** :meth:`glyph_name_to_unicode` and :meth:`unicode_to_glyph_name`. Both functions do not really connect to a specific font and are now independently available, too. The data are now based on the `Adobe Glyph List <https://github.com/adobe-type-tools/agl-aglfn/blob/master/glyphlist.txt>`_.\n* **Added** convenience functions :meth:`adobe_glyph_names` and :meth:`adobe_glyph_unicodes` which return the respective available data.\n* **Added** :meth:`Page.getDrawings` which returns details of drawing operations on a document page. Works for all document types.\n* Improved performance of :meth:`Document.insert_pdf`. Multiple object copies are now also suppressed across multiple separate insertions from the same source. This saves time, memory and target file size. Previously this mechanism was only active within each single method execution. The feature can also be suppressed with the new method bool parameter *final=1*, which is the default.\n* For PNG images created from pixmaps, the resolution (dpi) is now automatically set from the respective :attr:`Pixmap.xres` and :attr:`Pixmap.yres` values.\n\n\n------\n\n**Changes in Version 1.17.7**\n\n* **Fixed** issue `#651 <https://github.com/pymupdf/PyMuPDF/issues/651>`_. An upstream bug causing interpreter crashes in corner case redaction processings was fixed by backporting MuPDF changes from their development repo.\n* **Fixed** issue `#645 <https://github.com/pymupdf/PyMuPDF/issues/645>`_. Pixmap top-left coordinates can be set (again) by their own method, :meth:`Pixmap.set_origin`.\n* **Fixed** issue `#622 <https://github.com/pymupdf/PyMuPDF/issues/622>`_. :meth:`Page.insertImage` again accepts a :data:`rect_like` parameter.\n* **Added** severeal new methods to improve and speed-up table of contents (TOC) handling. Among other things, TOC items can now changed or deleted individually -- without always replacing the complete TOC. Furthermore, access to some PDF page attributes is now possible without first **loading** the page. This has a very significant impact on the performance of TOC manipulation.\n* **Added** an option to :meth:`Document.insert_pdf` which allows displaying progress messages. Adresses `#640 <https://github.com/pymupdf/PyMuPDF/issues/640>`_.\n* **Added** :meth:`Page.getTextbox` which extracts text contained in a rectangle. In many cases, this should obsolete writing your own script for this type of thing.\n* **Added** new ``clip`` parameter to :meth:`Page.getText` to simplify and speed up text extraction of page sub areas.\n* **Added** :meth:`TextWriter.appendv` to add text in **vertical write mode**. Addresses issue `#653 <https://github.com/pymupdf/PyMuPDF/issues/653>`_\n\n\n------\n\n**Changes in Version 1.17.6**\n\n* **Fixed** issue `#605 <https://github.com/pymupdf/PyMuPDF/issues/605>`_\n* **Fixed** issue `#600 <https://github.com/pymupdf/PyMuPDF/issues/600>`_ -- text should now be correctly positioned also for pages with a CropBox smaller than MediaBox.\n* **Added** text span dictionary key ``origin`` which contains the lower left coordinate of the first character in that span.\n* **Added** attribute :attr:`Font.buffer`, a *bytes* copy of the font file.\n* **Added** parameter *sanitize* to :meth:`Page.cleanContents`. Allows switching of sanitization, so only syntax cleaning will be done.\n\n------\n\n**Changes in Version 1.17.5**\n\n* **Fixed** issue `#561 <https://github.com/pymupdf/PyMuPDF/issues/561>`_ -- second go: certain :ref:`TextWriter` usages with many alternating fonts did not work correctly.\n* **Fixed** issue `#566 <https://github.com/pymupdf/PyMuPDF/issues/566>`_.\n* **Fixed** issue `#568 <https://github.com/pymupdf/PyMuPDF/issues/568>`_.\n* **Fixed** -- opacity is now correctly taken from the :ref:`TextWriter` object, if not given in :meth:`TextWriter.writeText`.\n* **Added** a new global attribute :attr:`fitz_fontdescriptors`. Contains information about usable fonts from repository `pymupdf-fonts <https://github.com/pymupdf/pymupdf-fonts>`_.\n* **Added** :meth:`Font.valid_codepoints` which returns an array of unicode codepoints for which the font has a glyph.\n* **Added** option ``text_as_path`` to :meth:`Page.getSVGimage`. this implements `#580 <https://github.com/pymupdf/PyMuPDF/issues/580>`_. Generates much smaller SVG files with parseable text if set to *False*.\n\n\n------\n\n**Changes in Version 1.17.4**\n\n* **Fixed** issue `#561 <https://github.com/pymupdf/PyMuPDF/issues/561>`_. Handling of more than 10 :ref:`Font` objects on one page should now work correctly.\n* **Fixed** issue `#562 <https://github.com/pymupdf/PyMuPDF/issues/562>`_. Annotation pixmaps are no longer derived from the page pixmap, thus avoiding unintended inclusion of page content.\n* **Fixed** issue `#559 <https://github.com/pymupdf/PyMuPDF/issues/559>`_. This **MuPDF** bug is being temporarily fixed with a pre-version of MuPDF's next release.\n* **Added** utility function :meth:`repair_mono_font` for correcting displayed character spacing for some mono-spaced fonts.\n* **Added** utility method :meth:`Document.need_appearances` for fine-controlling Form PDF behavior. Addresses issue `#563 <https://github.com/pymupdf/PyMuPDF/issues/563>`_.\n* **Added** utility function :meth:`sRGB_to_pdf` to recover the PDF color triple for a given color integer in sRGB format.\n* **Added** utility function :meth:`sRGB_to_rgb` to recover the (R, G, B) color triple for a given color integer in sRGB format.\n* **Added** utility function :meth:`make_table` which delivers table cells for a given rectangle and desired numbers of columns and rows.\n* **Added** support for optional fonts in repository `pymupdf-fonts <https://github.com/pymupdf/pymupdf-fonts>`_.\n\n------\n\n**Changes in Version 1.17.3**\n\n* **Fixed** an undocumented issue, which prevented fully cleaning a PDF page when using :meth:`Page.cleanContents`.\n* **Fixed** issue `#540 <https://github.com/pymupdf/PyMuPDF/issues/540>`_. Text extraction for EPUB should again work correctly.\n* **Fixed** issue `#548 <https://github.com/pymupdf/PyMuPDF/issues/548>`_. Documentation now includes ``LINK_NAMED``.\n* **Added** new parameter to control start of text in :meth:`TextWriter.fillTextbox`. Implements `#549 <https://github.com/pymupdf/PyMuPDF/issues/549>`_.\n* **Changed** documentation of :meth:`Page.add_redact_annot` to explain the usage of non-builtin fonts.\n\n------\n\n**Changes in Version 1.17.2**\n\n* **Fixed** issue `#533 <https://github.com/pymupdf/PyMuPDF/issues/533>`_.\n* **Added** options to modify 'Redact' annotation appearance. Implements `#535 <https://github.com/pymupdf/PyMuPDF/issues/535>`_.\n\n\n------\n\n**Changes in Version 1.17.1**\n\n* **Fixed** issue `#520 <https://github.com/pymupdf/PyMuPDF/issues/520>`_.\n* **Fixed** issue `#525 <https://github.com/pymupdf/PyMuPDF/issues/525>`_. Vertices for 'Ink' annots should now be correct.\n* **Fixed** issue `#524 <https://github.com/pymupdf/PyMuPDF/issues/524>`_. It is now possible to query and set rotation for applicable annotation types.\n\nAlso significantly improved inline documentation for better support of interactive help.\n\n------\n\n**Changes in Version 1.17.0**\n\nThis version is based on MuPDF v1.17. Following are highlights of new and changed features:\n\n* **Added** extended language support for annotations and widgets: a mixture of Latin, Greece, Russian, Chinese, Japanese and Korean characters can now be used in 'FreeText' annotations and text widgets. No special arrangement is required to use it.\n\n* Faster page access is implemented for documents supporting a \"chapter\" structure. This applies to EPUB documents currently. This comes with several new :ref:`Document` methods and changes for :meth:`Document.loadPage` and the \"indexed\" page access *doc[n]*: In addition to specifying a page number as before, a tuple *(chaper, pno)* can be specified to identify the desired page.\n\n* **Changed:** Improved support of redaction annotations: images overlapped by redactions are **permanantly modified** by erasing the overlap areas. Also links are removed if overlapped by redactions. This is now fully in sync with PDF specifications.\n\nOther changes:\n\n* **Changed** :meth:`TextWriter.writeText` to support the *\"morph\"* parameter.\n* **Added** methods :meth:`Rect.morph`, :meth:`IRect.morph`, and :meth:`Quad.morph`, which return a new :ref:`Quad`.\n* **Changed** :meth:`Page.add_freetext_annot` to support text alignment via a new *\"align\"* parameter.\n* **Fixed** issue `#508 <https://github.com/pymupdf/PyMuPDF/issues/508>`_. Improved image rectangle calculation to hopefully deliver correct values in most if not all cases.\n* **Fixed** issue `#502 <https://github.com/pymupdf/PyMuPDF/issues/502>`_.\n* **Fixed** issue `#500 <https://github.com/pymupdf/PyMuPDF/issues/500>`_. :meth:`Document.convertToPDF` should no longer cause memory leaks.\n* **Fixed** issue `#496 <https://github.com/pymupdf/PyMuPDF/issues/496>`_. Annotations and widgets / fields are now added or modified using the coordinates of the **unrotated page**. This behavior is now in sync with other methods modifying PDF pages.\n* **Added** :attr:`Page.rotationMatrix` and :attr:`Page.derotationMatrix` to support coordinate transformations between the rotated and the original versions of a PDF page.\n\nPotential code breaking changes:\n\n* The private method ``Page._getTransformation()`` has been removed. Use the public :attr:`Page.transformationMattrix` instead.\n\n\n------\n\n**Changes in Version 1.16.18**\n\nThis version introduces several new features around PDF text output. The motivation is to simplify this task, while at the same time offering extending features.\n\nOne major achievement is using MuPDF's capabilities to dynamically choosing fallback fonts whenever a character cannot be found in the current one. This seemlessly works for Base-14 fonts in combination with CJK fonts (China, Japan, Korea). So a text may contain **any combination of characters** from the Latin, Greek, Russian, Chinese, Japanese and Korean languages.\n\n* **Fixed** issue `#493 <https://github.com/pymupdf/PyMuPDF/issues/493>`_. ``Pixmap(doc, xref)`` should now again correctly resemble the loaded image object.\n* **Fixed** issue `#488 <https://github.com/pymupdf/PyMuPDF/issues/488>`_. Widget names are now modifiable.\n* **Added** new class :ref:`Font` which represents a font.\n* **Added** new class :ref:`TextWriter` which serves as a container for text to be written on a page.\n* **Added** :meth:`Page.writeText` to write one or more :ref:`TextWriter` objects to the page.\n\n\n------\n\n**Changes in Version 1.16.17**\n\n\n* **Fixed** issue `#479 <https://github.com/pymupdf/PyMuPDF/issues/479>`_. PyMuPDF should now more correctly report image resolutions. This applies to both, images (either from images files or extracted from PDF documents) and pixmaps created from images.\n* **Added** :meth:`Pixmap.set_dpi` which sets the image resolution in x and y directions.\n\n------\n\n**Changes in Version 1.16.16**\n\n\n* **Fixed** issue `#477 <https://github.com/pymupdf/PyMuPDF/issues/477>`_.\n* **Fixed** issue `#476 <https://github.com/pymupdf/PyMuPDF/issues/476>`_.\n* **Changed** annotation line end symbol coloring and fixed an error coloring the interior of 'Polyline' /'Polygon' annotations.\n\n------\n\n**Changes in Version 1.16.14**\n\n\n* **Changed** text marker annotations to accept parameters beyond just quadrilaterals such that now **text lines between two given points can be marked**.\n\n* **Added** :meth:`Document.scrub` which **removes potentially sensitive data** from a PDF. Implements `#453 <https://github.com/pymupdf/PyMuPDF/issues/453>`_.\n\n* **Added** :meth:`Annot.blendMode` which returns the **blend mode** of annotations.\n\n* **Added** :meth:`Annot.setBlendMode` to set the annotation's blend mode. This resolves issue `#416 <https://github.com/pymupdf/PyMuPDF/issues/416>`_.\n* **Changed** :meth:`Annot.update` to accept additional parameters for setting blend mode and opacity.\n* **Added** advanced graphics features to **control the anti-aliasing values**, :meth:`Tools.set_aa_level`. Resolves `#467 <https://github.com/pymupdf/PyMuPDF/issues/467>`_\n\n* **Fixed** issue `#474 <https://github.com/pymupdf/PyMuPDF/issues/474>`_.\n* **Fixed** issue `#466 <https://github.com/pymupdf/PyMuPDF/issues/466>`_.\n\n\n\n------\n\n**Changes in Version 1.16.13**\n\n\n* **Added** :meth:`Document.getPageXObjectList` which returns a list of **Form XObjects** of the page.\n* **Added** :meth:`Page.setMediaBox` for changing the physical PDF page size.\n* **Added** :ref:`Page` methods which have been internal before: :meth:`Page.cleanContents` (= :meth:`Page._cleanContents`), :meth:`Page.getContents` (= :meth:`Page._getContents`), :meth:`Page.getTransformation` (= :meth:`Page._getTransformation`).\n\n\n\n------\n\n**Changes in Version 1.16.12**\n\n* **Fixed** issue `#447 <https://github.com/pymupdf/PyMuPDF/issues/447>`_\n* **Fixed** issue `#461 <https://github.com/pymupdf/PyMuPDF/issues/461>`_.\n* **Fixed** issue `#397 <https://github.com/pymupdf/PyMuPDF/issues/397>`_.\n* **Fixed** issue `#463 <https://github.com/pymupdf/PyMuPDF/issues/463>`_.\n* **Added** JavaScript support to PDF form fields, thereby fixing `#454 <https://github.com/pymupdf/PyMuPDF/issues/454>`_.\n* **Added** a new annotation method :meth:`Annot.delete_responses`, which removes 'Popup' and response annotations referring to the current one. Mainly serves data protection purposes.\n* **Added** a new form field method :meth:`Widget.reset`, which resets the field value to its default.\n* **Changed** and extended handling of redactions: images and XObjects are removed if *contained* in a redaction rectangle. Any partial only overlaps will just be covered by the redaction background color. Now an *overlay* text can be specified to be inserted in the rectangle area to **take the place the deleted original** text. This resolves `#434 <https://github.com/pymupdf/PyMuPDF/issues/434>`_.\n\n------\n\n**Changes in Version 1.16.11**\n\n* **Added** Support for redaction annotations via method :meth:`Page.add_redact_annot` and :meth:`Page.apply_redactions`.\n* **Fixed** issue #426 (\"PolygonAnnotation in 1.16.10 version\").\n* **Fixed** documentation only issues `#443 <https://github.com/pymupdf/PyMuPDF/issues/443>`_ and `#444 <https://github.com/pymupdf/PyMuPDF/issues/444>`_.\n\n------\n\n**Changes in Version 1.16.10**\n\n* **Fixed** issue #421 (\"annot.set_rect(rect) has no effect on text Annotation\")\n* **Fixed** issue #417 (\"Strange behavior for page.deleteAnnot on 1.16.9 compare to 1.13.20\")\n* **Fixed** issue #415 (\"Annot.setOpacity throws mupdf warnings\")\n* **Changed** all \"add annotation / widget\" methods to store a unique name in the */NM* PDF key.\n* **Changed** :meth:`Annot.setInfo` to also accept direct parameters in addition to a dictionary.\n* **Changed** :attr:`Annot.info` to now also show the annotation's unique id (*/NM* PDF key) if present.\n* **Added** :meth:`Page.annot_names` which returns a list of all annotation names (*/NM* keys).\n* **Added** :meth:`Page.load_annot` which loads an annotation given its unique id (*/NM* key).\n* **Added** :meth:`Document.reload_page` which provides a new copy of a page after finishing any pending updates to it.\n\n\n------\n\n**Changes in Version 1.16.9**\n\n* **Fixed** #412 (\"Feature Request: Allow controlling whether TOC entries should be collapsed\")\n* **Fixed** #411 (\"Seg Fault with page.firstWidget\")\n* **Fixed** #407 (\"Annot.setOpacity trouble\")\n* **Changed** methods :meth:`Annot.setBorder`, :meth:`Annot.setColors`, :meth:`Link.setBorder`, and :meth:`Link.setColors` to also accept direct parameters, and not just cumbersome dictionaries.\n\n------\n\n**Changes in Version 1.16.8**\n\n* **Added** several new methods to the :ref:`Document` class, which make dealing with PDF low-level structures easier. I also decided to provide them as \"normal\" methods (as opposed to private ones starting with an underscore \"_\"). These are :meth:`Document.xrefObject`, :meth:`Document.xrefStream`, :meth:`Document.xrefStreamRaw`, :meth:`Document.PDFTrailer`, :meth:`Document.PDFCatalog`, :meth:`Document.metadataXML`, :meth:`Document.updateObject`, :meth:`Document.updateStream`.\n* **Added** :meth:`Tools.mupdf_disply_errors` which sets the display of mupdf errors on *sys.stderr*.\n* **Added** a commandline facility. This a major new feature: you can now invoke several utility functions via *\"python -m fitz ...\"*. It should obsolete the need for many of the most trivial scripts. Please refer to :ref:`Module`.\n\n\n------\n\n**Changes in Version 1.16.7**\n\nMinor changes to better synchronize the binary image streams of :ref:`TextPage` image blocks and :meth:`Document.extractImage` images.\n\n* **Fixed** issue #394 (\"PyMuPDF Segfaults when using TOOLS.mupdf_warnings()\").\n* **Changed** redirection of MuPDF error messages: apart from writing them to Python *sys.stderr*, they are now also stored with the MuPDF warnings.\n* **Changed** :meth:`Tools.mupdf_warnings` to automatically empty the store (if not deactivated via a parameter).\n* **Changed** :meth:`Page.getImageBbox` to return an **infinite rectangle** if the image could not be located on the page -- instead of raising an exception.\n\n\n------\n\n**Changes in Version 1.16.6**\n\n* **Fixed** issue #390 (\"Incomplete deletion of annotations\").\n* **Changed** :meth:`Page.searchFor` / :meth:`Document.searchPageFor` to also support the *flags* parameter, which controls the data included in a :ref:`TextPage`.\n* **Changed** :meth:`Document.getPageImageList`, :meth:`Document.getPageFontList` and their :ref:`Page` counterparts to support a new parameter *full*. If true, the returned items will contain the :data:`xref` of the *Form XObject* where the font or image is referenced.\n\n------\n\n**Changes in Version 1.16.5**\n\nMore performance improvements for text extraction.\n\n* **Fixed** second part of issue #381 (see item in v1.16.4).\n* **Added** :meth:`Page.getTextPage`, so it is no longer required to create an intermediate display list for text extractions. Page level wrappers for text extraction and text searching are now based on this, which should improve performance by ca. 5%.\n\n------\n\n**Changes in Version 1.16.4**\n\n\n* **Fixed** issue #381 (\"TextPage.extractDICT ... failed ... after upgrading ... to 1.16.3\")\n* **Added** method :meth:`Document.pages` which delivers a generator iterator over a page range.\n* **Added** method :meth:`Page.links` which delivers a generator iterator over the links of a page.\n* **Added** method :meth:`Page.annots` which delivers a generator iterator over the annotations of a page.\n* **Added** method :meth:`Page.widgets` which delivers a generator iterator over the form fields of a page.\n* **Changed** :attr:`Document.is_form_pdf` to now contain the number of widgets, and *False* if not a PDF or this number is zero.\n\n\n------\n\n**Changes in Version 1.16.3**\n\nMinor changes compared to version 1.16.2. The code of the \"dict\" and \"rawdict\" variants of :meth:`Page.getText` has been ported to C which has greatly improved their performance. This improvement is mostly noticeable with text-oriented documents, where they now should execute almost two times faster.\n\n* **Fixed** issue #369 (\"mupdf: cmsCreateTransform failed\") by removing ICC colorspace support.\n* **Changed** :meth:`Page.getText` to accept additional keywords \"blocks\" and \"words\". These will deliver the results of :meth:`Page.getTextBlocks` and :meth:`Page.getTextWords`, respectively. So all text extraction methods are now available via a uniform API. Correspondingly, there are now new methods :meth:`TextPage.extractBLOCKS` and :meth:`TextPage.extractWords`.\n* **Changed** :meth:`Page.getText` to default bit indicator *TEXT_INHIBIT_SPACES* to **off**. Insertion of additional spaces is **not suppressed** by default.\n\n------\n\n**Changes in Version 1.16.2**\n\n* **Changed** text extraction methods of :ref:`Page` to allow detail control of the amount of extracted data.\n* **Added** :meth:`planish_line` which maps a given line (defined as a pair of points) to the x-axis.\n* **Fixed** an issue (w/o Github number) which brought down the interpreter when encountering certain non-UTF-8 encodable characters while using :meth:`Page.getText` with te \"dict\" option.\n* **Fixed** issue #362 (\"Memory Leak with getText('rawDICT')\").\n\n------\n\n**Changes in Version 1.16.1**\n\n* **Added** property :attr:`Quad.is_convex` which checks whether a line is contained in the quad if it connects two points of it.\n* **Changed** :meth:`Document.insert_pdf` to now allow dropping or including links and annotations independently during the copy. Fixes issue #352 (\"Corrupt PDF data and ...\"), which seemed to intermittently occur when using the method for some problematic PDF files.\n* **Fixed** a bug which, in matrix division using the syntax *\"m1/m2\"*, caused matrix *\"m1\"* to be **replaced** by the result instead of delivering a new matrix.\n* **Fixed** issue #354 (\"SyntaxWarning with Python 3.8\"). We now always use *\"==\"* for literals (instead of the *\"is\"* Python keyword).\n* **Fixed** issue #353 (\"mupdf version check\"), to no longer refuse the import when there are only patch level deviations from MuPDF.\n\n\n\n------\n\n**Changes in Version 1.16.0**\n\nThis major new version of MuPDF comes with several nice new or changed features. Some of them imply programming API changes, however. This is a synopsis of what has changed:\n\n* PDF document encryption and decryption is now **fully supported**. This includes setting **permissions**, **passwords** (user and owner passwords) and the desired encryption method.\n* In response to the new encryption features, PyMuPDF returns an integer (ie. a combination of bits) for document permissions, and no longer a dictionary.\n* Redirection of MuPDF errors and warnings is now natively supported. PyMuPDF redirects error messages from MuPDF to *sys.stderr* and no longer buffers them. Warnings continue to be buffered and will not be displayed. Functions exist to access and reset the warnings buffer.\n* Annotations are now **only supported for PDF**.\n* Annotations and widgets (form fields) are now **separate object chains** on a page (although widgets technically still **are** PDF annotations). This means, that you will **never encounter widgets** when using :attr:`Page.firstAnnot` or :meth:`Annot.next`. You must use :attr:`Page.firstWidget` and :meth:`Widget.next` to access form fields.\n* As part of MuPDF's changes regarding widgets, only the following four fonts are supported, when **adding** or **changing** form fields: **Courier, Helvetica, Times-Roman** and **ZapfDingBats**.\n\nList of change details:\n\n* **Added** :meth:`Document.can_save_incrementally` which checks conditions that are preventing use of option *incremental=True* of :meth:`Document.save`.\n* **Added** :attr:`Page.firstWidget` which points to the first field on a page.\n* **Added** :meth:`Page.getImageBbox` which returns the rectangle occupied by an image shown on the page.\n* **Added** :meth:`Annot.setName` which lets you change the (icon) name field.\n* **Added** outputting the text color in :meth:`Page.getText`: the *\"dict\"*, *\"rawdict\"* and *\"xml\"* options now also show the color in sRGB format.\n* **Changed** :attr:`Document.permissions` to now contain an integer of bool indicators -- was a dictionary before.\n* **Changed** :meth:`Document.save`, :meth:`Document.write`, which now fully support password-based decryption and encryption of PDF files.\n* **Changed the names of all Python constants** related to annotations and widgets. Please make sure to consult the **Constants and Enumerations** chapter if your script is dealing with these two classes. This decision goes back to the dropped support for non-PDF annotations. The **old names** (starting with \"ANNOT_*\" or \"WIDGET_*\") will be available as deprecated synonyms.\n* **Changed** font support for widgets: only *Cour* (Courier), *Helv* (Helvetica, default), *TiRo* (Times-Roman) and *ZaDb* (ZapfDingBats) are accepted when **adding or changing** form fields. Only the plain versions are possible -- not their italic or bold variations. **Reading** widgets, however will show its original font.\n* **Changed** the name of the warnings buffer to :meth:`Tools.mupdf_warnings` and the function to empty this buffer is now called :meth:`Tools.reset_mupdf_warnings`.\n* **Changed** :meth:`Page.getPixmap`, :meth:`Document.get_page_pixmap`: a new bool argument *annots* can now be used to **suppress the rendering of annotations** on the page.\n* **Changed** :meth:`Page.add_file_annot` and :meth:`Page.add_text_annot` to enable setting an icon.\n* **Removed** widget-related methods and attributes from the :ref:`Annot` object.\n* **Removed** :ref:`Document` attributes *openErrCode*, *openErrMsg*, and :ref:`Tools` attributes / methods *stderr*, *reset_stderr*, *stdout*, and *reset_stdout*.\n* **Removed** **thirdparty zlib** dependency in PyMuPDF: there are now compression functions available in MuPDF. Source installers of PyMuPDF may now omit this extra installation step.\n\n**No version published for MuPDF v1.15.0**\n\n\n------\n\n**Changes in Version 1.14.20 / 1.14.21**\n\n* **Changed** text marker annotations to support multiple rectangles / quadrilaterals. This fixes issue #341 (\"Question : How to addhighlight so that a string spread across more than a line is covered by one highlight?\") and similar (#285).\n* **Fixed** issue #331 (\"Importing PyMuPDF changes warning filtering behaviour globally\").\n\n\n------\n\n**Changes in Version 1.14.19**\n\n* **Fixed** issue #319 (\"InsertText function error when use custom font\").\n* **Added** new method :meth:`Document.get_sigflags` which returns information on whether a PDF is signed. Resolves issue #326 (\"How to detect signature in a form pdf?\").\n\n\n------\n\n**Changes in Version 1.14.17**\n\n* **Added** :meth:`Document.fullcopyPage` to make full page copies within a PDF (not just copied references as :meth:`Document.copyPage` does).\n* **Changed** :meth:`Page.getPixmap`, :meth:`Document.get_page_pixmap` now use *alpha=False* as default.\n* **Changed** text extraction: the span dictionary now (again) contains its rectangle under the *bbox* key.\n* **Changed** :meth:`Document.movePage` and :meth:`Document.copyPage` to use direct functions instead of wrapping :meth:`Document.select` -- similar to :meth:`Document.delete_page` in v1.14.16.\n\n------\n\n**Changes in Version 1.14.16**\n\n* **Changed** :ref:`Document` methods around PDF */EmbeddedFiles* to no longer use MuPDF's \"portfolio\" functions. That support will be dropped in MuPDF v1.15 -- therefore another solution was required.\n* **Changed** :meth:`Document.embfile_Count` to be a function (was an attribute).\n* **Added** new method :meth:`Document.embfile_Names` which returns a list of names of embedded files.\n* **Changed** :meth:`Document.delete_page` and :meth:`Document.delete_pages` to internally no longer use :meth:`Document.select`, but instead use functions to perform the deletion directly. As it has turned out, the :meth:`Document.select` method yields invalid outline trees (tables of content) for very complex PDFs and sophisticated use of annotations.\n\n\n------\n\n**Changes in Version 1.14.15**\n\n* **Fixed** issues #301 (\"Line cap and Line join\"), #300 (\"How to draw a shape without outlines\") and #298 (\"utils.updateRect exception\"). These bugs pertain to drawing shapes with PyMuPDF. Drawing shapes without any border is fully supported. Line cap styles and line line join style are now differentiated and support all possible PDF values (0, 1, 2) instead of just being a bool. The previous parameter *roundCap* is deprecated in favor of *lineCap* and *lineJoin* and will be deleted in the next release.\n* **Fixed** issue #290 (\"Memory Leak with getText('rawDICT')\"). This bug caused memory not being (completely) freed after invoking the \"dict\", \"rawdict\" and \"json\" versions of :meth:`Page.getText`.\n\n\n------\n\n**Changes in Version 1.14.14**\n\n* **Added** new low-level function :meth:`ImageProperties` to determine a number of characteristics for an image.\n* **Added** new low-level function :meth:`Document.is_stream`, which checks whether an object is of stream type.\n* **Changed** low-level functions :meth:`Document._getXrefString` and :meth:`Document._getTrailerString` now by default return object definitions in a formatted form which makes parsing easy.\n\n------\n\n**Changes in Version 1.14.13**\n\n* **Changed** methods working with binary input: while ever supporting bytes and bytearray objects, they now also accept *io.BytesIO* input, using their *getvalue()* method. This pertains to document creation, embedded files, FileAttachment annotations, pixmap creation and others. Fixes issue #274 (\"Segfault when using BytesIO as a stream for insertImage\").\n* **Fixed** issue #278 (\"Is insertImage(keep_proportion=True) broken?\"). Images are now correctly presented when keeping aspect ratio.\n\n\n------\n\n**Changes in Version 1.14.12**\n\n* **Changed** the draw methods of :ref:`Page` and :ref:`Shape` to support not only RGB, but also GRAY and CMYK colorspaces. This solves issue #270 (\"Is there a way to use CMYK color to draw shapes?\"). This change also applies to text insertion methods of :ref:`Shape`, resp. :ref:`Page`.\n* **Fixed** issue #269 (\"AttributeError in Document.insert_page()\"), which occurred when using :meth:`Document.insert_page` with text insertion.\n\n\n------\n\n**Changes in Version 1.14.11**\n\n* **Changed** :meth:`Page.show_pdf_page` to always position the source rectangle centered in the target. This method now also supports **rotation by arbitrary angles**. The argument *reuse_xref* has been deprecated: prevention of duplicates is now **handled internally**.\n* **Changed** :meth:`Page.insertImage` to support rotated display of the image and keeping the aspect ratio. Only rotations by multiples of 90 degrees are supported here.\n* **Fixed** issue #265 (\"TypeError: insertText() got an unexpected keyword argument 'idx'\"). This issue only occurred when using :meth:`Document.insert_page` with also inserting text.\n\n------\n\n**Changes in Version 1.14.10**\n\n* **Changed** :meth:`Page.show_pdf_page` to support rotation of the source rectangle. Fixes #261 (\"Cannot rotate insterted pages\").\n* **Fixed** a bug in :meth:`Page.insertImage` which prevented insertion of multiple images provided as streams.\n\n\n------\n\n**Changes in Version 1.14.9**\n\n* **Added** new low-level method :meth:`Document._getTrailerString`, which returns the trailer object of a PDF. This is much like :meth:`Document._getXrefString` except that the PDF trailer has no / needs no :data:`xref` to identify it.\n* **Added** new parameters for text insertion methods. You can now set stroke and fill colors of glyphs (text characters) independently, as well as the thickness of the glyph border. A new parameter *render_mode* controls the use of these colors, and whether the text should be visible at all.\n* **Fixed** issue #258 (\"Copying image streams to new PDF without size increase\"): For JPX images embedded in a PDF, :meth:`Document.extractImage` will now return them in their original format. Previously, the MuPDF base library was used, which returns them in PNG format (entailing a massive size increase).\n* **Fixed** issue #259 (\"Morphing text to fit inside rect\"). Clarified use of :meth:`get_text_length` and removed extra line breaks for long words.\n\n------\n\n**Changes in Version 1.14.8**\n\n* **Added** :meth:`Pixmap.set_rect` to change the pixel values in a rectangle. This is also an alternative to setting the color of a complete pixmap (:meth:`Pixmap.clear_with`).\n* **Fixed** an image extraction issue with JBIG2 (monochrome) encoded PDF images. The issue occurred in :meth:`Page.getText` (parameters \"dict\" and \"rawdict\") and in :meth:`Document.extractImage` methods.\n* **Fixed** an issue with not correctly clearing a non-alpha :ref:`Pixmap` (:meth:`Pixmap.clear_with`).\n* **Fixed** an issue with not correctly inverting colors of a non-alpha :ref:`Pixmap` (:meth:`Pixmap.invert_irect`).\n\n------\n\n**Changes in Version 1.14.7**\n\n* **Added** :meth:`Pixmap.set_pixel` to change one pixel value.\n* **Added** documentation for image conversion in the :ref:`FAQ`.\n* **Added** new function :meth:`get_text_length` to determine the string length for a given font.\n* **Added** Postscript image output (changed :meth:`Pixmap.save` and :meth:`Pixmap.tobytes`).\n* **Changed** :meth:`Pixmap.save` and :meth:`Pixmap.tobytes` to ensure valid combinations of colorspace, alpha and output format.\n* **Changed** :meth:`Pixmap.save`: the desired format is now inferred from the filename.\n* **Changed** FreeText annotations can now have a transparent background - see :meth:`Annot.update`.\n\n------\n\n**Changes in Version 1.14.5**\n\n* **Changed:** :ref:`Shape` methods now strictly use the transformation matrix of the :ref:`Page` -- instead of \"manually\" calculating locations.\n* **Added** method :meth:`Pixmap.pixel` which returns the pixel value (a list) for given pixel coordinates.\n* **Added** method :meth:`Pixmap.tobytes` which returns a bytes object representing the pixmap in a variety of formats. Previously, this could be done for PNG outputs only (:meth:`Pixmap.tobytes`).\n* **Changed:** output of methods :meth:`Pixmap.save` and (the new) :meth:`Pixmap.tobytes` may now also be PSD (Adobe Photoshop Document).\n* **Added** method :meth:`Shape.drawQuad` which draws a :ref:`Quad`. This actually is a shorthand for a :meth:`Shape.drawPolyline` with the edges of the quad.\n* **Changed** method :meth:`Shape.drawOval`: the argument can now be **either** a rectangle (:data:`rect_like`) **or** a quadrilateral (:data:`quad_like`).\n\n------\n\n**Changes in Version 1.14.4**\n\n* **Fixes** issue #239 \"Annotation coordinate consistency\".\n\n\n------\n\n**Changes in Version 1.14.3**\n\nThis patch version contains minor bug fixes and CJK font output support.\n\n* **Added** support for the four CJK fonts as PyMuPDF generated text output. This pertains to methods :meth:`Page.insertFont`, :meth:`Shape.insertText`, :meth:`Shape.insertTextbox`, and corresponding :ref:`Page` methods. The new fonts are available under \"reserved\" fontnames \"china-t\" (traditional Chinese), \"china-s\" (simplified Chinese), \"japan\" (Japanese), and \"korea\" (Korean).\n* **Added** full support for the built-in fonts 'Symbol' and 'Zapfdingbats'.\n* **Changed:** The 14 standard fonts can now each be referenced by a 4-letter abbreviation.\n\n------\n\n**Changes in Version 1.14.1**\n\nThis patch version contains minor performance improvements.\n\n* **Added** support for :ref:`Document` filenames given as *pathlib* object by using the Python *str()* function.\n\n\n------\n\n**Changes in Version 1.14.0**\n\nTo support MuPDF v1.14.0, massive changes were required in PyMuPDF -- most of them purely technical, with little visibility to developers. But there are also quite a lot of interesting new and improved features. Following are the details:\n\n* **Added** \"ink\" annotation.\n* **Added** \"rubber stamp\" annotation.\n* **Added** \"squiggly\" text marker annotation.\n* **Added** new class :ref:`Quad` (quadrilateral or tetragon) -- which represents a general four-sided shape in the plane. The special subtype of rectangular, non-empty tetragons is used in text marker annotations and as returned objects in text search methods.\n* **Added** a new option \"decrypt\" to :meth:`Document.save` and :meth:`Document.write`. Now you can **keep encryption** when saving a password protected PDF.\n* **Added** suppression and redirection of unsolicited messages issued by the underlying C-library MuPDF. Consult :ref:`RedirectMessages` for details.\n* **Changed:** Changes to annotations now **always require** :meth:`Annot.update` to become effective.\n* **Changed** free text annotations to support the full Latin character set and range of appearance options.\n* **Changed** text searching, :meth:`Page.searchFor`, to optionally return :ref:`Quad` instead :ref:`Rect` objects surrounding each search hit.\n* **Changed** plain text output: we now add a *\\n* to each line if it does not itself end with this character.\n* **Fixed** issue 211 (\"Something wrong in the doc\").\n* **Fixed** issue 213 (\"Rewritten outline is displayed only by mupdf-based applications\").\n* **Fixed** issue 214 (\"PDF decryption GONE!\").\n* **Fixed** issue 215 (\"Formatting of links added with pyMuPDF\").\n* **Fixed** issue 217 (\"extraction through json is failing for my pdf\").\n\nBehind the curtain, we have changed the implementation of geometry objects: they now purely exist in Python and no longer have \"shadow\" twins on the C-level (in MuPDF). This has improved processing speed in that area by more than a factor of two.\n\nBecause of the same reason, most methods involving geometry parameters now also accept the corresponding Python sequence. For example, in method *\"page.show_pdf_page(rect, ...)\"* parameter *rect* may now be any :data:`rect_like` sequence.\n\nWe also invested considerable effort to further extend and improve the :ref:`FAQ` chapter.\n\n\n------\n\n**Changes in Version 1.13.19**\n\nThis version contains some technical / performance improvements and bug fixes.\n\n* **Changed** memory management: for Python 3 builds, Python memory management is exclusively used across all C-level code (i.e. no more native *malloc()* in MuPDF code or PyMuPDF interface code). This leads to improved memory usage profiles and also some runtime improvements: we have seen > 2% shorter runtimes for text extractions and pixmap creations (on Windows machines only to date).\n* **Fixed** an error occurring in Python 2.7, which crashed the interpreter when using :meth:`TextPage.extractRAWDICT` (= *Page.getText(\"rawdict\")*).\n* **Fixed** an error occurring in Python 2.7, when creating link destinations.\n* **Extended** the :ref:`FAQ` chapter with more examples.\n\n------\n\n**Changes in Version 1.13.18**\n\n* **Added** method :meth:`TextPage.extractRAWDICT`, and a corresponding new string parameter \"rawdict\" to method :meth:`Page.getText`. It extracts text and images from a page in Python *dict* form like :meth:`TextPage.extractDICT`, but with the detail level of :meth:`TextPage.extractXML`, which is position information down to each single character.\n\n------\n\n**Changes in Version 1.13.17**\n\n* **Fixed** an error that intermittently caused an exception in :meth:`Page.show_pdf_page`, when pages from many different source PDFs were shown.\n* **Changed** method :meth:`Document.extractImage` to now return more meta information about the extracted imgage. Also, its performance has been greatly improved. Several demo scripts have been changed to make use of this method.\n* **Changed** method :meth:`Document._getXrefStream` to now return *None* if the object is no stream and no longer raise an exception if otherwise.\n* **Added** method :meth:`Document._deleteObject` which deletes a PDF object identified by its :data:`xref`. Only to be used by the experienced PDF expert.\n* **Added** a method :meth:`paper_rect` which returns a :ref:`Rect` for a supplied paper format string. Example: *fitz.paper_rect(\"letter\") = fitz.Rect(0.0, 0.0, 612.0, 792.0)*.\n* **Added** a :ref:`FAQ` chapter to this document.\n\n------\n\n**Changes in Version 1.13.16**\n\n* **Added** support for correctly setting transparency (opacity) for certain annotation types.\n* **Added** a tool property (:attr:`Tools.fitz_config`) showing the configuration of this PyMuPDF version.\n* **Fixed** issue #193 ('insertText(overlay=False) gives \"cannot resize a buffer with shared storage\" error') by avoiding read-only buffers.\n\n------\n\n**Changes in Version 1.13.15**\n\n* **Fixed** issue #189 (\"cannot find builtin CJK font\"), so we are supporting builtin CJK fonts now (CJK = China, Japan, Korea). This should lead to correctly generated pixmaps for documents using these languages. This change has consequences for our binary file size: it will now range between 8 and 10 MB, depending on the OS.\n* **Fixed** issue #191 (\"Jupyter notebook kernel dies after ca. 40 pages\"), which occurred when modifying the contents of an annotation.\n\n------\n\n**Changes in Version 1.13.14**\n\nThis patch version contains several improvements, mainly for annotations.\n\n* **Changed** :attr:`Annot.lineEnds` is now a list of two integers representing the line end symbols. Previously was a *dict* of strings.\n* **Added** support of line end symbols for applicable annotations. PyMuPDF now can generate these annotations including the line end symbols.\n* **Added** :meth:`Annot.setLineEnds` adds line end symbols to applicable annotation types ('Line', 'PolyLine', 'Polygon').\n* **Changed** technical implementation of :meth:`Page.insertImage` and :meth:`Page.show_pdf_page`: they now create there own contents objects, thereby avoiding changes of potentially large streams with consequential compression / decompression efforts and high change volumes with incremental updates.\n\n------\n\n**Changes in Version 1.13.13**\n\nThis patch version contains several improvements for embedded files and file attachment annotations.\n\n* **Added** :meth:`Document.embfile_Upd` which allows changing **file content and metadata** of an embedded file. It supersedes the old method :meth:`Document.embfile_SetInfo` (which will be deleted in a future version). Content is automatically compressed and metadata may be unicode.\n* **Changed** :meth:`Document.embfile_Add` to now automatically compress file content. Accompanying metadata can now be unicode (had to be ASCII in the past).\n* **Changed** :meth:`Document.embfile_Del` to now automatically delete **all entries** having the supplied identifying name. The return code is now an integer count of the removed entries (was *None* previously).\n* **Changed** embedded file methods to now also accept or show the PDF unicode filename as additional parameter *ufilename*.\n* **Added** :meth:`Page.add_file_annot` which adds a new file attachment annotation.\n* **Changed** :meth:`Annot.fileUpd` (file attachment annot) to now also accept the PDF unicode *ufilename* parameter. The description parameter *desc* correctly works with unicode. Furthermore, **all** parameters are optional, so metadata may be changed without also replacing the file content.\n* **Changed** :meth:`Annot.fileInfo` (file attachment annot) to now also show the PDF unicode filename as parameter *ufilename*.\n* **Fixed** issue #180 (\"page.getText(output='dict') return invalid bbox\") to now also work for vertical text.\n* **Fixed** issue #185 (\"Can't render the annotations created by PyMuPDF\"). The issue's cause was the minimalistic MuPDF approach when creating annotations. Several annotation types have no */AP* (\"appearance\") object when created by MuPDF functions. MuPDF, SumatraPDF and hence also PyMuPDF cannot render annotations without such an object. This fix now ensures, that an appearance object is always created together with the annotation itself. We still do not support line end styles.\n\n------\n\n**Changes in Version 1.13.12**\n\n* **Fixed** issue #180 (\"page.getText(output='dict') return invalid bbox\"). Note that this is a circumvention of an MuPDF error, which generates zero-height character rectangles in some cases. When this happens, this fix ensures a bbox height of at least fontsize.\n* **Changed** for ListBox and ComboBox widgets, the attribute list of selectable values has been renamed to :attr:`Widget.choice_values`.\n* **Changed** when adding widgets, any missing of the :ref:`Base-14-Fonts` is automatically added to the PDF. Widget text fonts can now also be chosen from existing widget fonts. Any specified field values are now honored and lead to a field with a preset value.\n* **Added** :meth:`Annot.updateWidget` which allows changing existing form fields -- including the field value.\n\n------\n\n**Changes in Version 1.13.11**\n\nWhile the preceeding patch subversions only contained various fixes, this version again introduces major new features:\n\n* **Added** basic support for PDF widget annotations. You can now add PDF form fields of types Text, CheckBox, ListBox and ComboBox. Where necessary, the PDF is tranformed to a Form PDF with the first added widget.\n* **Fixed** issues #176 (\"wrong file embedding\"), #177 (\"segment fault when invoking page.getText()\")and #179 (\"Segmentation fault using page.getLinks() on encrypted PDF\").\n\n\n------\n\n**Changes in Version 1.13.7**\n\n* **Added** support of variable page sizes for reflowable documents (e-books, HTML, etc.): new parameters *rect* and *fontsize* in :ref:`Document` creation (open), and as a separate method :meth:`Document.layout`.\n* **Added** :ref:`Annot` creation of many annotations types: sticky notes, free text, circle, rectangle, line, polygon, polyline and text markers.\n* **Added** support of annotation transparency (:attr:`Annot.opacity`, :meth:`Annot.setOpacity`).\n* **Changed** :attr:`Annot.vertices`: point coordinates are now grouped as pairs of floats (no longer as separate floats).\n* **Changed** annotation colors dictionary: the two keys are now named *\"stroke\"* (formerly *\"common\"*) and *\"fill\"*.\n* **Added** :attr:`Document.isDirty` which is *True* if a PDF has been changed in this session. Reset to *False* on each :meth:`Document.save` or :meth:`Document.write`.\n\n------\n\n**Changes in Version 1.13.6**\n\n* Fix #173: for memory-resident documents, ensure the stream object will not be garbage-collected by Python before document is closed.\n\n------\n\n**Changes in Version 1.13.5**\n\n* New low-level method :meth:`Page._setContents` defines an object given by its :data:`xref` to serve as the :data:`contents` object.\n* Changed and extended PDF form field support: the attribute *widget_text* has been renamed to :attr:`Annot.widget_value`. Values of all form field types (except signatures) are now supported. A new attribute :attr:`Annot.widget_choices` contains the selectable values of listboxes and comboboxes. All these attributes now contain *None* if no value is present.\n\n------\n\n**Changes in Version 1.13.4**\n\n* :meth:`Document.convertToPDF` now supports page ranges, reverted page sequences and page rotation. If the document already is a PDF, an exception is raised.\n* Fixed a bug (introduced with v1.13.0) that prevented :meth:`Page.insertImage` for transparent images.\n\n------\n\n**Changes in Version 1.13.3**\n\nIntroduces a way to convert **any MuPDF supported document** to a PDF. If you ever wanted PDF versions of your XPS, EPUB, CBZ or FB2 files -- here is a way to do this.\n\n* :meth:`Document.convertToPDF` returns a Python *bytes* object in PDF format. Can be opened like normal in PyMuPDF, or be written to disk with the *\".pdf\"* extension.\n\n------\n\n**Changes in Version 1.13.2**\n\nThe major enhancement is PDF form field support. Form fields are annotations of type *(19, 'Widget')*. There is a new document method to check whether a PDF is a form. The :ref:`Annot` class has new properties describing field details.\n\n* :attr:`Document.is_form_pdf` is true if object type */AcroForm* and at least one form field exists.\n* :attr:`Annot.widget_type`, :attr:`Annot.widget_text` and :attr:`Annot.widget_name` contain the details of a form field (i.e. a \"Widget\" annotation).\n\n------\n\n**Changes in Version 1.13.1**\n\n* :meth:`TextPage.extractDICT` is a new method to extract the contents of a document page (text and images). All document types are supported as with the other :ref:`TextPage` *extract*()* methods. The returned object is a dictionary of nested lists and other dictionaries, and **exactly equal** to the JSON-deserialization of the old :meth:`TextPage.extractJSON`. The difference is that the result is created directly -- no JSON module is used. Because the user needs no JSON module to interpet the information, it should be easier to use, and also have a better performance, because it contains images in their original **binary format** -- they need not be base64-decoded.\n* :meth:`Page.getText` correspondingly supports the new parameter value *\"dict\"* to invoke the above method.\n* :meth:`TextPage.extractJSON` (resp. *Page.getText(\"json\")*) is still supported for convenience, but its use is expected to decline.\n\n------\n\n**Changes in Version 1.13.0**\n\nThis version is based on MuPDF v1.13.0. This release is \"primarily a bug fix release\".\n\nIn PyMuPDF, we are also doing some bug fixes while introducing minor enhancements. There only very minimal changes to the user's API.\n\n* :ref:`Document` construction is more flexible: the new *filetype* parameter allows setting the document type. If specified, any extension in the filename will be ignored. More completely addresses `issue #156 <https://github.com/pymupdf/PyMuPDF/issues/156>`_. As part of this, the documentation has been reworked.\n\n* Changes to :ref:`Pixmap` constructors:\n    - Colorspace conversion no longer allows dropping the alpha channel: source and target **alpha will now always be the same**. We have seen exceptions and even interpreter crashes when using *alpha = 0*.\n    - As a replacement, the simple pixmap copy lets you choose the target alpha.\n\n* :meth:`Document.save` again offers the full garbage collection range 0 thru 4. Because of a bug in :data:`xref` maintenance, we had to temporarily enforce *garbage > 1*. Finally resolves `issue #148 <https://github.com/pymupdf/PyMuPDF/issues/148>`_.\n\n* :meth:`Document.save` now offers to \"prettify\" PDF source via an additional argument.\n* :meth:`Page.insertImage` has the additional *stream* \\-parameter, specifying a memory area holding an image.\n\n* Issue with garbled PNGs on Linux systems has been resolved (`\"Problem writing PNG\" #133) <https://github.com/pymupdf/PyMuPDF/issues/133>`_.\n\n\n------\n\n**Changes in Version 1.12.4**\n\nThis is an extension of 1.12.3.\n\n* Fix of `issue #147 <https://github.com/pymupdf/PyMuPDF/issues/147>`_: methods :meth:`Document.getPageFontlist` and :meth:`Document.getPageImagelist` now also show fonts and images contained in :data:`resources` nested via \"Form XObjects\".\n* Temporary fix of `issue #148 <https://github.com/pymupdf/PyMuPDF/issues/148>`_: Saving to new PDF files will now automatically use *garbage = 2* if a lower value is given. Final fix is to be expected with MuPDF's next version. At that point we will remove this circumvention.\n* Preventive fix of illegally using stencil / image mask pixmaps in some methods.\n* Method :meth:`Document.getPageFontlist` now includes the encoding name for each font in the list.\n* Method :meth:`Document.getPageImagelist` now includes the decode method name for each image in the list.\n\n------\n\n**Changes in Version 1.12.3**\n\nThis is an extension of 1.12.2.\n\n* Many functions now return *None* instead of *0*, if the result has no other meaning than just indicating successful execution (:meth:`Document.close`, :meth:`Document.save`, :meth:`Document.select`, :meth:`Pixmap.save` and many others).\n\n------\n\n**Changes in Version 1.12.2**\n\nThis is an extension of 1.12.1.\n\n* Method :meth:`Page.show_pdf_page` now accepts the new *clip* argument. This specifies an area of the source page to which the display should be restricted.\n\n* New :attr:`Page.CropBox` and :attr:`Page.MediaBox` have been included for convenience.\n\n\n------\n\n**Changes in Version 1.12.1**\n\nThis is an extension of version 1.12.0.\n\n* New method :meth:`Page.show_pdf_page` displays another's PDF page. This is a **vector** image and therefore remains precise across zooming. Both involved documents must be PDF.\n\n* New method :meth:`Page.getSVGimage` creates an SVG image from the page. In contrast to the raster image of a pixmap, this is a vector image format. The return is a unicode text string, which can be saved in a *.svg* file.\n\n* Method :meth:`Page.getTextBlocks` now accepts an additional bool parameter \"images\". If set to true (default is false), image blocks (metadata only) are included in the produced list and thus allow detecting areas with rendered images.\n\n* Minor bug fixes.\n\n* \"text\" result of :meth:`Page.getText` concatenates all lines within a block using a single space character. MuPDF's original uses \"\\\\n\" instead, producing a rather ragged output.\n\n* New properties of :ref:`Page` objects :attr:`Page.MediaBoxSize` and :attr:`Page.CropBoxPosition` provide more information about a page's dimensions. For non-PDF files (and for most PDF files, too) these will be equal to :attr:`Page.rect.bottom_right`, resp. :attr:`Page.rect.top_left`. For example, class :ref:`Shape` makes use of them to correctly position its items.\n\n------\n\n**Changes in Version 1.12.0**\n\nThis version is based on and requires MuPDF v1.12.0. The new MuPDF version contains quite a number of changes -- most of them around text extraction. Some of the changes impact the programmer's API.\n\n* :meth:`Outline.saveText` and :meth:`Outline.saveXML` have been deleted without replacement. You probably haven't used them much anyway. But if you are looking for a replacement: the output of :meth:`Document.get_toc` can easily be used to produce something equivalent.\n\n* Class *TextSheet* does no longer exist.\n\n* Text \"spans\" (one of the hierarchy levels of :ref:`TextPage`) no longer contain positioning information (i.e. no \"bbox\" key). Instead, spans now provide the font information for its text. This impacts our JSON output variant.\n\n* HTML output has improved very much: it now creates valid documents which can be displayed by browsers to produce a similar view as the original document.\n\n* There is a new output format XHTML, which provides text and images in a browser-readable format. The difference to HTML output is, that no effort is made to reproduce the original layout.\n\n* All output formats of :meth:`Page.getText` now support creating complete, valid documents, by wrapping them with appropriate header and trailer information. If you are interested in using the HTML output, please make sure to read :ref:`HTMLQuality`.\n\n* To support finding text positions, we have added special methods that don't need detours like :meth:`TextPage.extractJSON` or :meth:`TextPage.extractXML`: use :meth:`Page.getTextBlocks` or resp. :meth:`Page.getTextWords` to create lists of text blocks or resp. words, which are accompanied by their rectangles. This should be much faster than the standard text extraction methods and also avoids using additional packages for interpreting their output.\n\n\n------\n\n**Changes in Version 1.11.2**\n\nThis is an extension of v1.11.1.\n\n* New :meth:`Page.insertFont` creates a PDF */Font* object and returns its object number.\n\n* New :meth:`Document.extractFont` extracts the content of an embedded font given its object number.\n\n* Methods **FontList(...)** items no longer contain the PDF generation number. This value never had any significance. Instead, the font file extension is included (e.g. \"pfa\" for a \"PostScript Font for ASCII\"), which is more valuable information.\n\n* Fonts other than \"simple fonts\" (Type1) are now also supported.\n\n* New options to change :ref:`Pixmap` size:\n\n    * Method :meth:`Pixmap.shrink` reduces the pixmap proportionally in place.\n\n    * A new :ref:`Pixmap` copy constructor allows scaling via setting target width and height.\n\n\n------\n\n**Changes in Version 1.11.1**\n\nThis is an extension of v1.11.0.\n\n* New class *Shape*. It facilitates and extends the creation of image shapes on PDF pages. It contains multiple methods for creating elementary shapes like lines, rectangles or circles, which can be combined into more complex ones and be given common properties like line width or colors. Combined shapes are handled as a unit and e.g. be \"morphed\" together. The class can accumulate multiple complex shapes and put them all in the page's foreground or background -- thus also reducing the number of updates to the page's :data:`contents` object.\n\n* All *Page* draw methods now use the new *Shape* class.\n\n* Text insertion methods *insertText()* and *insertTextBox()* now support morphing in addition to text rotation. They have become part of the *Shape* class and thus allow text to be freely combined with graphics.\n\n* A new *Pixmap* constructor allows creating pixmap copies with an added alpha channel. A new method also allows directly manipulating alpha values.\n\n* Binary algebraic operations with geometry objects (matrices, rectangles and points) now generally also support lists or tuples as the second operand. You can add a tuple *(x, y)* of numbers to a :ref:`Point`. In this context, such sequences are called \":data:`point_like`\" (resp. :data:`matrix_like`, :data:`rect_like`).\n\n* Geometry objects now fully support in-place operators. For example, *p /= m* replaces point p with *p * 1/m* for a number, or *p * ~m* for a :data:`matrix_like` object *m*. Similarly, if *r* is a rectangle, then *r |= (3, 4)* is the new rectangle that also includes *fitz.Point(3, 4)*, and *r &= (1, 2, 3, 4)* is its intersection with *fitz.Rect(1, 2, 3, 4)*.\n\n------\n\n**Changes in Version 1.11.0**\n\nThis version is based on and requires MuPDF v1.11.\n\nThough MuPDF has declared it as being mostly a bug fix version, one major new feature is indeed contained: support of embedded files -- also called portfolios or collections. We have extended PyMuPDF functionality to embrace this up to an extent just a little beyond the *mutool* utility as follows.\n\n* The *Document* class now support embedded files with several new methods and one new property:\n\n    - *embfile_Info()* returns metadata information about an entry in the list of embedded files. This is more than *mutool* currently provides: it shows all the information that was used to embed the file (not just the entry's name).\n    - *embfile_Get()* retrieves the (decompressed) content of an entry into a *bytes* buffer.\n    - *embfile_Add(...)* inserts new content into the PDF portfolio. We (in contrast to *mutool*) **restrict** this to entries with a **new name** (no duplicate names allowed).\n    - *embfile_Del(...)* deletes an entry from the portfolio (function not offered in MuPDF).\n    - *embfile_SetInfo()* -- changes filename or description of an embedded file.\n    - *embfile_Count* -- contains the number of embedded files.\n\n* Several enhancements deal with streamlining geometry objects. These are not connected to the new MuPDF version and most of them are also reflected in PyMuPDF v1.10.0. Among them are new properties to identify the corners of rectangles by name (e.g. *Rect.bottom_right*) and new methods to deal with set-theoretic questions like *Rect.contains(x)* or *IRect.intersects(x)*. Special effort focussed on supporting more \"Pythonic\" language constructs: *if x in rect ...* is equivalent to *rect.contains(x)*.\n\n* The :ref:`Rect` chapter now has more background on empty amd infinite rectangles and how we handle them. The handling itself was also updated for more consistency in this area.\n\n* We have started basic support for **generation** of PDF content:\n\n    - *Document.insert_page()* adds a new page into a PDF, optionally containing some text.\n    - *Page.insertImage()* places a new image on a PDF page.\n    - *Page.insertText()* puts new text on an existing page\n\n* For **FileAttachment** annotations, content and name of the attached file can extracted and changed.\n\n------\n\n**Changes in Version 1.10.0**\n\n**MuPDF v1.10 Impact**\n\nMuPDF version 1.10 has a significant impact on our bindings. Some of the changes also affect the API -- in other words, **you** as a PyMuPDF user.\n\n* Link destination information has been reduced. Several properties of the *linkDest* class no longer contain valuable information. In fact, this class as a whole has been deleted from MuPDF's library and we in PyMuPDF only maintain it to provide compatibilty to existing code.\n\n* In an effort to minimize memory requirements, several improvements have been built into MuPDF v1.10:\n\n    - A new *config.h* file can be used to de-select unwanted features in the C base code. Using this feature we have been able to reduce the size of our binary *_fitz.o* / *_fitz.pyd* by about 50% (from 9 MB to 4.5 MB). When UPX-ing this, the size goes even further down to a very handy 2.3 MB.\n\n    - The alpha (transparency) channel for pixmaps is now optional. Letting alpha default to *False* significantly reduces pixmap sizes (by 20% -- CMYK, 25% -- RGB, 50% -- GRAY). Many *Pixmap* constructors therefore now accept an *alpha* boolean to control inclusion of this channel. Other pixmap constructors (e.g. those for file and image input) create pixmaps with no alpha alltogether. On the downside, save methods for pixmaps no longer accept a *savealpha* option: this channel will always be saved when present. To minimize code breaks, we have left this parameter in the call patterns -- it will just be ignored.\n\n* *DisplayList* and *TextPage* class constructors now **require the mediabox** of the page they are referring to (i.e. the *page.bound()* rectangle). There is no way to construct this information from other sources, therefore a source code change cannot be avoided in these cases. We assume however, that not many users are actually employing these rather low level classes explixitely. So the impact of that change should be minor.\n\n**Other Changes compared to Version 1.9.3**\n\n* The new :ref:`Document` method *write()* writes an opened PDF to memory (as opposed to a file, like *save()* does).\n* An annotation can now be scaled and moved around on its page. This is done by modifying its rectangle.\n* Annotations can now be deleted. :ref:`Page` contains the new method *deleteAnnot()*.\n* Various annotation attributes can now be modified, e.g. content, dates, title (= author), border, colors.\n* Method *Document.insert_pdf()* now also copies annotations of source pages.\n* The *Pages* class has been deleted. As documents can now be accessed with page numbers as indices (like *doc[n] = doc.loadPage(n)*), and document object can be used as iterators, the benefit of this class was too low to maintain it. See the following comments.\n* *loadPage(n)* / *doc[n]* now accept arbitrary integers to specify a page number, as long as *n < pageCount*. So, e.g. *doc[-500]* is always valid and will load page *(-500) % pageCount*.\n* A document can now also be used as an iterator like this: *for page in doc: ...<do something with \"page\"> ...*. This will yield all pages of *doc* as *page*.\n* The :ref:`Pixmap` method *getSize()* has been replaced with property *size*. As before *Pixmap.size == len(Pixmap)* is true.\n* In response to transparency (alpha) being optional, several new parameters and properties have been added to :ref:`Pixmap` and :ref:`Colorspace` classes to support determining their characteristics.\n* The :ref:`Page` class now contains new properties *firstAnnot* and *firstLink* to provide starting points to the respective class chains, where *firstLink* is just a mnemonic synonym to method *loadLinks()* which continues to exist. Similarly, the new property *rect* is a synonym for method *bound()*, which also continues to exist.\n* :ref:`Pixmap` methods *samplesRGB()* and *samplesAlpha()* have been deleted because pixmaps can now be created without transparency.\n* :ref:`Rect` now has a property *irect* which is a synonym of method *round()*. Likewise, :ref:`IRect` now has property *rect* to deliver a :ref:`Rect` which has the same coordinates as floats values.\n* Document has the new method *searchPageFor()* to search for a text string. It works exactly like the corresponding *Page.searchFor()* with page number as additional parameter.\n\n\n------\n\n**Changes in Version 1.9.3**\n\nThis version is also based on MuPDF v1.9a. Changes compared to version 1.9.2:\n\n* As a major enhancement, annotations are now supported in a similar way as links. Annotations can be displayed (as pixmaps) and their properties can be accessed.\n* In addition to the document *select()* method, some simpler methods can now be used to manipulate a PDF:\n\n    - *copyPage()* copies a page within a document.\n    - *movePage()* is similar, but deletes the original.\n    - *delete_page()* deletes a page\n    - *delete_pages()* deletes a page range\n\n* *rotation* or *setRotation()* access or change a PDF page's rotation, respectively.\n* Available but undocumented before, :ref:`IRect`, :ref:`Rect`, :ref:`Point` and :ref:`Matrix` support the *len()* method and their coordinate properties can be accessed via indices, e.g. *IRect.x1 == IRect[2]*.\n* For convenience, documents now support simple indexing: *doc.loadPage(n) == doc[n]*. The index may however be in range *-pageCount < n < pageCount*, such that *doc[-1]* is the last page of the document.\n\n------\n\n**Changes in Version 1.9.2**\n\nThis version is also based on MuPDF v1.9a. Changes compared to version 1.9.1:\n\n* *fitz.open()* (no parameters) creates a new empty **PDF** document, i.e. if saved afterwards, it must be given a *.pdf* extension.\n* :ref:`Document` now accepts all of the following formats (*Document* and *open* are synonyms):\n\n  - *open()*,\n  - *open(filename)* (equivalent to *open(filename, None)*),\n  - *open(filetype, area)* (equivalent to *open(filetype, stream = area)*).\n\n  Type of memory area *stream* may be *bytes* or *bytearray*. Thus, e.g. *area = open(\"file.pdf\", \"rb\").read()* may be used directly (without first converting it to bytearray).\n* New method *Document.insert_pdf()* (PDFs only) inserts a range of pages from another PDF.\n* *Document* objects doc now support the *len()* function: ``len(doc) == doc.pageCount``.\n* New method *Document.getPageImageList()* creates a list of images used on a page.\n* New method *Document.getPageFontList()* creates a list of fonts referenced by a page.\n* New pixmap constructor *fitz.Pixmap(doc, xref)* creates a pixmap based on an opened PDF document and an :data:`xref` number of the image.\n* New pixmap constructor *fitz.Pixmap(cspace, spix)* creates a pixmap as a copy of another one *spix* with the colorspace converted to *cspace*. This works for all colorspace combinations.\n* Pixmap constructor *fitz.Pixmap(colorspace, width, height, samples)* now allows *samples* to also be *bytes*, not only *bytearray*.\n\n\n------\n\n**Changes in Version 1.9.1**\n\nThis version of PyMuPDF is based on MuPDF library source code version 1.9a published on April 21, 2016.\n\nPlease have a look at MuPDF's website to see which changes and enhancements are contained herein.\n\nChanges in version 1.9.1 compared to version 1.8.0 are the following:\n\n* New methods *get_area()* for both *fitz.Rect* and *fitz.IRect*\n* Pixmaps can now be created directly from files using the new constructor *fitz.Pixmap(filename)*.\n* The Pixmap constructor *fitz.Pixmap(image)* has been extended accordingly.\n* *fitz.Rect* can now be created with all possible combinations of points and coordinates.\n* PyMuPDF classes and methods now all contain  __doc__ strings,  most of them created by SWIG automatically. While the PyMuPDF documentation certainly is more detailed, this feature should help a lot when programming in Python-aware IDEs.\n* A new document method of *getPermits()* returns the permissions associated with the current access to the document (print, edit, annotate, copy), as a Python dictionary.\n* The identity matrix *fitz.Identity* is now **immutable**.\n* The new document method *select(list)* removes all pages from a document that are not contained in the list. Pages can also be duplicated and re-arranged.\n* Various improvements and new members in our demo and examples collections. Perhaps most prominently: *PDF_display* now supports scrolling with the mouse wheel, and there is a new example program *wxTableExtract* which allows to graphically identify and extract table data in documents.\n* *fitz.open()* is now an alias of *fitz.Document()*.\n* New pixmap method *tobytes()* which will return a bytearray formatted as a PNG image of the pixmap.\n* New pixmap method *samplesRGB()* providing a *samples* version with alpha bytes stripped off (RGB colorspaces only).\n* New pixmap method *samplesAlpha()* providing the alpha bytes only of the *samples* area.\n* New iterator *fitz.Pages(doc)* over a document's set of pages.\n* New matrix methods *invert()* (calculate inverted matrix), *concat()* (calculate matrix product), *pretranslate()* (perform a shift operation).\n* New *IRect* methods *intersect()* (intersection with another rectangle), *translate()* (perform a shift operation).\n* New *Rect* methods *intersect()* (intersection with another rectangle), *transform()* (transformation with a matrix), *include_point()* (enlarge rectangle to also contain a point), *include_rect()* (enlarge rectangle to also contain another one).\n* Documented *Point.transform()* (transform a point with a matrix).\n* *Matrix*, *IRect*, *Rect* and *Point* classes now support compact, algebraic formulations for manipulating such objects.\n* Incremental saves for changes are possible now using the call pattern *doc.save(doc.name, incremental=True)*.\n* A PDF's metadata can now be deleted, set or changed by document method *set_metadata()*. Supports incremental saves.\n* A PDF's bookmarks (or table of contents) can now be deleted, set or changed with the entries of a list using document method *set_toc(list)*. Supports incremental saves.\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "pipcl.py",
          "type": "blob",
          "size": 92.8955078125,
          "content": "'''\nPython packaging operations, including PEP-517 support, for use by a `setup.py`\nscript.\n\nThe intention is to take care of as many packaging details as possible so that\nsetup.py contains only project-specific information, while also giving as much\nflexibility as possible.\n\nFor example we provide a function `build_extension()` that can be used to build\na SWIG extension, but we also give access to the located compiler/linker so\nthat a `setup.py` script can take over the details itself.\n\nRun doctests with: `python -m doctest pipcl.py`\n'''\n\nimport base64\nimport glob\nimport hashlib\nimport inspect\nimport io\nimport os\nimport platform\nimport re\nimport shutil\nimport site\nimport subprocess\nimport sys\nimport sysconfig\nimport tarfile\nimport textwrap\nimport time\nimport zipfile\n\nimport wdev\n\n\nclass Package:\n    '''\n    Our constructor takes a definition of a Python package similar to that\n    passed to `distutils.core.setup()` or `setuptools.setup()` (name, version,\n    summary etc) plus callbacks for building, getting a list of sdist\n    filenames, and cleaning.\n\n    We provide methods that can be used to implement a Python package's\n    `setup.py` supporting PEP-517.\n\n    We also support basic command line handling for use\n    with a legacy (pre-PEP-517) pip, as implemented\n    by legacy distutils/setuptools and described in:\n    https://pip.pypa.io/en/stable/reference/build-system/setup-py/\n\n    Here is a `doctest` example of using pipcl to create a SWIG extension\n    module. Requires `swig`.\n\n    Create an empty test directory:\n\n        >>> import os\n        >>> import shutil\n        >>> shutil.rmtree('pipcl_test', ignore_errors=1)\n        >>> os.mkdir('pipcl_test')\n\n    Create a `setup.py` which uses `pipcl` to define an extension module.\n\n        >>> import textwrap\n        >>> with open('pipcl_test/setup.py', 'w') as f:\n        ...     _ = f.write(textwrap.dedent(\"\"\"\n        ...             import sys\n        ...             import pipcl\n        ...\n        ...             def build():\n        ...                 so_leaf = pipcl.build_extension(\n        ...                         name = 'foo',\n        ...                         path_i = 'foo.i',\n        ...                         outdir = 'build',\n        ...                         )\n        ...                 return [\n        ...                         ('build/foo.py', 'foo/__init__.py'),\n        ...                         ('cli.py', 'foo/__main__.py'),\n        ...                         (f'build/{so_leaf}', f'foo/'),\n        ...                         ('README', '$dist-info/'),\n        ...                         (b'Hello world', 'foo/hw.txt'),\n        ...                         ]\n        ...\n        ...             def sdist():\n        ...                 return [\n        ...                         'foo.i',\n        ...                         'bar.i',\n        ...                         'setup.py',\n        ...                         'pipcl.py',\n        ...                         'wdev.py',\n        ...                         'README',\n        ...                         (b'Hello word2', 'hw2.txt'),\n        ...                         ]\n        ...\n        ...             p = pipcl.Package(\n        ...                     name = 'foo',\n        ...                     version = '1.2.3',\n        ...                     fn_build = build,\n        ...                     fn_sdist = sdist,\n        ...                     entry_points = (\n        ...                         { 'console_scripts': [\n        ...                             'foo_cli = foo.__main__:main',\n        ...                             ],\n        ...                         }),\n        ...                     )\n        ...\n        ...             build_wheel = p.build_wheel\n        ...             build_sdist = p.build_sdist\n        ...\n        ...             # Handle old-style setup.py command-line usage:\n        ...             if __name__ == '__main__':\n        ...                 p.handle_argv(sys.argv)\n        ...             \"\"\"))\n\n    Create the files required by the above `setup.py` - the SWIG `.i` input\n    file, the README file, and copies of `pipcl.py` and `wdev.py`.\n\n        >>> with open('pipcl_test/foo.i', 'w') as f:\n        ...     _ = f.write(textwrap.dedent(\"\"\"\n        ...             %include bar.i\n        ...             %{\n        ...             #include <stdio.h>\n        ...             #include <string.h>\n        ...             int bar(const char* text)\n        ...             {\n        ...                 printf(\"bar(): text: %s\\\\\\\\n\", text);\n        ...                 int len = (int) strlen(text);\n        ...                 printf(\"bar(): len=%i\\\\\\\\n\", len);\n        ...                 fflush(stdout);\n        ...                 return len;\n        ...             }\n        ...             %}\n        ...             int bar(const char* text);\n        ...             \"\"\"))\n\n        >>> with open('pipcl_test/bar.i', 'w') as f:\n        ...     _ = f.write( '\\\\n')\n\n        >>> with open('pipcl_test/README', 'w') as f:\n        ...     _ = f.write(textwrap.dedent(\"\"\"\n        ...             This is Foo.\n        ...             \"\"\"))\n\n        >>> with open('pipcl_test/cli.py', 'w') as f:\n        ...     _ = f.write(textwrap.dedent(\"\"\"\n        ...             def main():\n        ...                 print('pipcl_test:main().')\n        ...             if __name__ == '__main__':\n        ...                 main()\n        ...             \"\"\"))\n\n        >>> root = os.path.dirname(__file__)\n        >>> _ = shutil.copy2(f'{root}/pipcl.py', 'pipcl_test/pipcl.py')\n        >>> _ = shutil.copy2(f'{root}/wdev.py', 'pipcl_test/wdev.py')\n\n    Use `setup.py`'s command-line interface to build and install the extension\n    module into root `pipcl_test/install`.\n\n        >>> _ = subprocess.run(\n        ...         f'cd pipcl_test && {sys.executable} setup.py --root install install',\n        ...         shell=1, check=1)\n\n    The actual install directory depends on `sysconfig.get_path('platlib')`:\n\n        >>> if windows():\n        ...     install_dir = 'pipcl_test/install'\n        ... else:\n        ...     install_dir = f'pipcl_test/install/{sysconfig.get_path(\"platlib\").lstrip(os.sep)}'\n        >>> assert os.path.isfile( f'{install_dir}/foo/__init__.py')\n\n    Create a test script which asserts that Python function call `foo.bar(s)`\n    returns the length of `s`, and run it with `PYTHONPATH` set to the install\n    directory:\n\n        >>> with open('pipcl_test/test.py', 'w') as f:\n        ...     _ = f.write(textwrap.dedent(\"\"\"\n        ...             import sys\n        ...             import foo\n        ...             text = 'hello'\n        ...             print(f'test.py: calling foo.bar() with text={text!r}')\n        ...             sys.stdout.flush()\n        ...             l = foo.bar(text)\n        ...             print(f'test.py: foo.bar() returned: {l}')\n        ...             assert l == len(text)\n        ...             \"\"\"))\n        >>> r = subprocess.run(\n        ...         f'{sys.executable} pipcl_test/test.py',\n        ...         shell=1, check=1, text=1,\n        ...         stdout=subprocess.PIPE, stderr=subprocess.STDOUT,\n        ...         env=os.environ | dict(PYTHONPATH=install_dir),\n        ...         )\n        >>> print(r.stdout)\n        test.py: calling foo.bar() with text='hello'\n        bar(): text: hello\n        bar(): len=5\n        test.py: foo.bar() returned: 5\n        <BLANKLINE>\n\n    Check that building sdist and wheel succeeds. For now we don't attempt to\n    check that the sdist and wheel actually work.\n\n        >>> _ = subprocess.run(\n        ...         f'cd pipcl_test && {sys.executable} setup.py sdist',\n        ...         shell=1, check=1)\n\n        >>> _ = subprocess.run(\n        ...         f'cd pipcl_test && {sys.executable} setup.py bdist_wheel',\n        ...         shell=1, check=1)\n\n    Check that rebuild does nothing.\n\n        >>> t0 = os.path.getmtime('pipcl_test/build/foo.py')\n        >>> _ = subprocess.run(\n        ...         f'cd pipcl_test && {sys.executable} setup.py bdist_wheel',\n        ...         shell=1, check=1)\n        >>> t = os.path.getmtime('pipcl_test/build/foo.py')\n        >>> assert t == t0\n\n    Check that touching bar.i forces rebuild.\n\n        >>> os.utime('pipcl_test/bar.i')\n        >>> _ = subprocess.run(\n        ...         f'cd pipcl_test && {sys.executable} setup.py bdist_wheel',\n        ...         shell=1, check=1)\n        >>> t = os.path.getmtime('pipcl_test/build/foo.py')\n        >>> assert t > t0\n\n    Check that touching foo.i.cpp does not run swig, but does recompile/link.\n\n        >>> t0 = time.time()\n        >>> os.utime('pipcl_test/build/foo.i.cpp')\n        >>> _ = subprocess.run(\n        ...         f'cd pipcl_test && {sys.executable} setup.py bdist_wheel',\n        ...         shell=1, check=1)\n        >>> assert os.path.getmtime('pipcl_test/build/foo.py') <= t0\n        >>> so = glob.glob('pipcl_test/build/*.so')\n        >>> assert len(so) == 1\n        >>> so = so[0]\n        >>> assert os.path.getmtime(so) > t0\n\n    Check `entry_points` causes creation of command `foo_cli` when we install\n    from our wheel using pip. [As of 2024-02-24 using pipcl's CLI interface\n    directly with `setup.py install` does not support entry points.]\n\n        >>> print('Creating venv.', file=sys.stderr)\n        >>> _ = subprocess.run(\n        ...         f'cd pipcl_test && {sys.executable} -m venv pylocal',\n        ...         shell=1, check=1)\n\n        >>> print('Installing from wheel into venv using pip.', file=sys.stderr)\n        >>> _ = subprocess.run(\n        ...         f'. pipcl_test/pylocal/bin/activate && pip install pipcl_test/dist/*.whl',\n        ...         shell=1, check=1)\n\n        >>> print('Running foo_cli.', file=sys.stderr)\n        >>> _ = subprocess.run(\n        ...         f'. pipcl_test/pylocal/bin/activate && foo_cli',\n        ...         shell=1, check=1)\n\n    Wheels and sdists\n\n        Wheels:\n            We generate wheels according to:\n            https://packaging.python.org/specifications/binary-distribution-format/\n\n            * `{name}-{version}.dist-info/RECORD` uses sha256 hashes.\n            * We do not generate other `RECORD*` files such as\n              `RECORD.jws` or `RECORD.p7s`.\n            * `{name}-{version}.dist-info/WHEEL` has:\n\n              * `Wheel-Version: 1.0`\n              * `Root-Is-Purelib: false`\n            * No support for signed wheels.\n\n        Sdists:\n            We generate sdist's according to:\n            https://packaging.python.org/specifications/source-distribution-format/\n    '''\n    def __init__(self,\n            name,\n            version,\n            *,\n            platform = None,\n            supported_platform = None,\n            summary = None,\n            description = None,\n            description_content_type = None,\n            keywords = None,\n            home_page = None,\n            download_url = None,\n            author = None,\n            author_email = None,\n            maintainer = None,\n            maintainer_email = None,\n            license = None,\n            classifier = None,\n            requires_dist = None,\n            requires_python = None,\n            requires_external = None,\n            project_url = None,\n            provides_extra = None,\n\n            entry_points = None,\n\n            root = None,\n            fn_build = None,\n            fn_clean = None,\n            fn_sdist = None,\n            tag_python = None,\n            tag_abi = None,\n            tag_platform = None,\n            py_limited_api = None,\n\n            wheel_compression = zipfile.ZIP_DEFLATED,\n            wheel_compresslevel = None,\n            ):\n        '''\n        The initial args before `root` define the package\n        metadata and closely follow the definitions in:\n        https://packaging.python.org/specifications/core-metadata/\n\n        Args:\n\n            name:\n                A string, the name of the Python package.\n            version:\n                A string, the version of the Python package. Also see PEP-440\n                `Version Identification and Dependency Specification`.\n            platform:\n                A string or list of strings.\n            supported_platform:\n                A string or list of strings.\n            summary:\n                A string, short description of the package.\n            description:\n                A string. If contains newlines, a detailed description of the\n                package. Otherwise the path of a file containing the detailed\n                description of the package.\n            description_content_type:\n                A string describing markup of `description` arg. For example\n                `text/markdown; variant=GFM`.\n            keywords:\n                A string containing comma-separated keywords.\n            home_page:\n                URL of home page.\n            download_url:\n                Where this version can be downloaded from.\n            author:\n                Author.\n            author_email:\n                Author email.\n            maintainer:\n                Maintainer.\n            maintainer_email:\n                Maintainer email.\n            license:\n                A string containing the license text. Written into metadata\n                file `COPYING`. Is also written into metadata itself if not\n                multi-line.\n            classifier:\n                A string or list of strings. Also see:\n\n                * https://pypi.org/pypi?%3Aaction=list_classifiers\n                * https://pypi.org/classifiers/\n\n            requires_dist:\n                A string or list of strings. None items are ignored. Also see PEP-508.\n            requires_python:\n                A string or list of strings.\n            requires_external:\n                A string or list of strings.\n            project_url:\n                A string or list of strings, each of the form: `{name}, {url}`.\n            provides_extra:\n                A string or list of strings.\n\n            entry_points:\n                String or dict specifying *.dist-info/entry_points.txt, for\n                example:\n\n                    ```\n                    [console_scripts]\n                    foo_cli = foo.__main__:main\n                    ```\n\n                or:\n\n                    { 'console_scripts': [\n                        'foo_cli = foo.__main__:main',\n                        ],\n                    }\n\n                See: https://packaging.python.org/en/latest/specifications/entry-points/\n\n            root:\n                Root of package, defaults to current directory.\n\n            fn_build:\n                A function taking no args, or a single `config_settings` dict\n                arg (as described in PEP-517), that builds the package.\n\n                Should return a list of items; each item should be a tuple\n                `(from_, to_)`, or a single string `path` which is treated as\n                the tuple `(path, path)`.\n\n                `from_` can be a string or a `bytes`. If a string it should\n                be the path to a file; a relative path is treated as relative\n                to `root`. If a `bytes` it is the contents of the file to be\n                added.\n\n                `to_` identifies what the file should be called within a wheel\n                or when installing. If `to_` ends with `/`, the leaf of `from_`\n                is appended to it (and `from_` must not be a `bytes`).\n\n                Initial `$dist-info/` in `_to` is replaced by\n                `{name}-{version}.dist-info/`; this is useful for license files\n                etc.\n\n                Initial `$data/` in `_to` is replaced by\n                `{name}-{version}.data/`. We do not enforce particular\n                subdirectories, instead it is up to `fn_build()` to specify\n                specific subdirectories such as `purelib`, `headers`,\n                `scripts`, `data` etc.\n\n                If we are building a wheel (e.g. `python setup.py bdist_wheel`,\n                or PEP-517 pip calls `self.build_wheel()`), we add file `from_`\n                to the wheel archive with name `to_`.\n\n                If we are installing (e.g. `install` command in\n                the argv passed to `self.handle_argv()`), then\n                we copy `from_` to `{sitepackages}/{to_}`, where\n                `sitepackages` is the installation directory, the\n                default being `sysconfig.get_path('platlib')` e.g.\n                `myvenv/lib/python3.9/site-packages/`.\n\n            fn_clean:\n                A function taking a single arg `all_` that cleans generated\n                files. `all_` is true iff `--all` is in argv.\n\n                For safety and convenience, can also returns a list of\n                files/directory paths to be deleted. Relative paths are\n                interpreted as relative to `root`. All paths are asserted to be\n                within `root`.\n\n            fn_sdist:\n                A function taking no args, or a single `config_settings` dict\n                arg (as described in PEP517), that returns a list of items to\n                be copied into the sdist. The list should be in the same format\n                as returned by `fn_build`.\n\n                It can be convenient to use `pipcl.git_items()`.\n\n                The specification for sdists requires that the list contains\n                `pyproject.toml`; we enforce this with a diagnostic rather than\n                raising an exception, to allow legacy command-line usage.\n\n            tag_python:\n                First element of wheel tag defined in PEP-425. If None we use\n                `cp{version}`.\n\n                For example if code works with any Python version, one can use\n                'py3'.\n\n            tag_abi:\n                Second element of wheel tag defined in PEP-425. If None we use\n                `none`.\n\n            tag_platform:\n                Third element of wheel tag defined in PEP-425. Default\n                is `os.environ('AUDITWHEEL_PLAT')` if set, otherwise\n                derived from `sysconfig.get_platform()` (was\n                `setuptools.distutils.util.get_platform(), before that\n                `distutils.util.get_platform()` as specified in the PEP), e.g.\n                `openbsd_7_0_amd64`.\n\n                For pure python packages use: `tag_platform=any`\n\n            py_limited_api:\n                If true we build wheels that use the Python Limited API. We use\n                the version of `sys.executable` to define `Py_LIMITED_API` when\n                compiling extensions, and use ABI tag `abi3` in the wheel name\n                if argument `tag_abi` is None.\n\n            wheel_compression:\n                Used as `zipfile.ZipFile()`'s `compression` parameter when\n                creating wheels.\n\n            wheel_compresslevel:\n                Used as `zipfile.ZipFile()`'s `compresslevel` parameter when\n                creating wheels.\n\n        Occurrences of `None` in lists are ignored.\n        '''\n        assert name\n        assert version\n\n        def assert_str( v):\n            if v is not None:\n                assert isinstance( v, str), f'Not a string: {v!r}'\n        def assert_str_or_multi( v):\n            if v is not None:\n                assert isinstance( v, (str, tuple, list)), f'Not a string, tuple or list: {v!r}'\n\n        assert_str( name)\n        assert_str( version)\n        assert_str_or_multi( platform)\n        assert_str_or_multi( supported_platform)\n        assert_str( summary)\n        assert_str( description)\n        assert_str( description_content_type)\n        assert_str( keywords)\n        assert_str( home_page)\n        assert_str( download_url)\n        assert_str( author)\n        assert_str( author_email)\n        assert_str( maintainer)\n        assert_str( maintainer_email)\n        assert_str( license)\n        assert_str_or_multi( classifier)\n        assert_str_or_multi( requires_dist)\n        assert_str( requires_python)\n        assert_str_or_multi( requires_external)\n        assert_str_or_multi( project_url)\n        assert_str_or_multi( provides_extra)\n\n        # https://packaging.python.org/en/latest/specifications/core-metadata/.\n        assert re.match('([A-Z0-9]|[A-Z0-9][A-Z0-9._-]*[A-Z0-9])$', name, re.IGNORECASE), \\\n                f'Bad name: {name!r}'\n\n        _assert_version_pep_440(version)\n\n        # https://packaging.python.org/en/latest/specifications/binary-distribution-format/\n        if tag_python:\n            assert '-' not in tag_python\n        if tag_abi:\n            assert '-' not in tag_abi\n        if tag_platform:\n            assert '-' not in tag_platform\n\n        self.name = name\n        self.version = version\n        self.platform = platform\n        self.supported_platform = supported_platform\n        self.summary = summary\n        self.description = description\n        self.description_content_type = description_content_type\n        self.keywords = keywords\n        self.home_page = home_page\n        self.download_url = download_url\n        self.author = author\n        self.author_email  = author_email\n        self.maintainer = maintainer\n        self.maintainer_email = maintainer_email\n        self.license = license\n        self.classifier = classifier\n        self.requires_dist = requires_dist\n        self.requires_python = requires_python\n        self.requires_external = requires_external\n        self.project_url = project_url\n        self.provides_extra = provides_extra\n        self.entry_points = entry_points\n\n        self.root = os.path.abspath(root if root else os.getcwd())\n        self.fn_build = fn_build\n        self.fn_clean = fn_clean\n        self.fn_sdist = fn_sdist\n        self.tag_python_ = tag_python\n        self.tag_abi_ = tag_abi\n        self.tag_platform_ = tag_platform\n        self.py_limited_api = py_limited_api\n\n        self.wheel_compression = wheel_compression\n        self.wheel_compresslevel = wheel_compresslevel\n\n\n    def build_wheel(self,\n            wheel_directory,\n            config_settings=None,\n            metadata_directory=None,\n            ):\n        '''\n        A PEP-517 `build_wheel()` function.\n\n        Also called by `handle_argv()` to handle the `bdist_wheel` command.\n\n        Returns leafname of generated wheel within `wheel_directory`.\n        '''\n        log2(\n                f' wheel_directory={wheel_directory!r}'\n                f' config_settings={config_settings!r}'\n                f' metadata_directory={metadata_directory!r}'\n                )\n\n        wheel_name = self.wheel_name()\n        path = f'{wheel_directory}/{wheel_name}'\n\n        # Do a build and get list of files to copy into the wheel.\n        #\n        items = list()\n        if self.fn_build:\n            items = self._call_fn_build(config_settings)\n\n        log2(f'Creating wheel: {path}')\n        os.makedirs(wheel_directory, exist_ok=True)\n        record = _Record()\n        with zipfile.ZipFile(path, 'w', self.wheel_compression, self.wheel_compresslevel) as z:\n\n            def add(from_, to_):\n                if isinstance(from_, str):\n                    z.write(from_, to_)\n                    record.add_file(from_, to_)\n                elif isinstance(from_, bytes):\n                    z.writestr(to_, from_)\n                    record.add_content(from_, to_)\n                else:\n                    assert 0\n\n            def add_str(content, to_):\n                add(content.encode('utf8'), to_)\n\n            dist_info_dir = self._dist_info_dir()\n\n            # Add the files returned by fn_build().\n            #\n            for item in items:\n                from_, (to_abs, to_rel) = self._fromto(item)\n                add(from_, to_rel)\n\n            # Add <name>-<version>.dist-info/WHEEL.\n            #\n            add_str(\n                    f'Wheel-Version: 1.0\\n'\n                    f'Generator: pipcl\\n'\n                    f'Root-Is-Purelib: false\\n'\n                    f'Tag: {self.wheel_tag_string()}\\n'\n                    ,\n                    f'{dist_info_dir}/WHEEL',\n                    )\n            # Add <name>-<version>.dist-info/METADATA.\n            #\n            add_str(self._metainfo(), f'{dist_info_dir}/METADATA')\n\n            # Add <name>-<version>.dist-info/COPYING.\n            if self.license:\n                add_str(self.license, f'{dist_info_dir}/COPYING')\n\n            # Add <name>-<version>.dist-info/entry_points.txt.\n            entry_points_text = self._entry_points_text()\n            if entry_points_text:\n                add_str(entry_points_text, f'{dist_info_dir}/entry_points.txt')\n\n            # Update <name>-<version>.dist-info/RECORD. This must be last.\n            #\n            z.writestr(f'{dist_info_dir}/RECORD', record.get(f'{dist_info_dir}/RECORD'))\n\n        st = os.stat(path)\n        log1( f'Have created wheel size={st.st_size}: {path}')\n        if g_verbose >= 2:\n            with zipfile.ZipFile(path, compression=self.wheel_compression) as z:\n                log2(f'Contents are:')\n                for zi in sorted(z.infolist(), key=lambda z: z.filename):\n                    log2(f'    {zi.file_size: 10d} {zi.filename}')\n\n        return os.path.basename(path)\n\n\n    def build_sdist(self,\n            sdist_directory,\n            formats,\n            config_settings=None,\n            ):\n        '''\n        A PEP-517 `build_sdist()` function.\n\n        Also called by `handle_argv()` to handle the `sdist` command.\n\n        Returns leafname of generated archive within `sdist_directory`.\n        '''\n        log2(\n                f' sdist_directory={sdist_directory!r}'\n                f' formats={formats!r}'\n                f' config_settings={config_settings!r}'\n                )\n        if formats and formats != 'gztar':\n            raise Exception( f'Unsupported: formats={formats}')\n        items = list()\n        if self.fn_sdist:\n            if inspect.signature(self.fn_sdist).parameters:\n                items = self.fn_sdist(config_settings)\n            else:\n                items = self.fn_sdist()\n\n        prefix = f'{_normalise(self.name)}-{self.version}'\n        os.makedirs(sdist_directory, exist_ok=True)\n        tarpath = f'{sdist_directory}/{prefix}.tar.gz'\n        log2(f'Creating sdist: {tarpath}')\n\n        with tarfile.open(tarpath, 'w:gz') as tar:\n\n            names_in_tar = list()\n            def check_name(name):\n                if name in names_in_tar:\n                    raise Exception(f'Name specified twice: {name}')\n                names_in_tar.append(name)\n\n            def add(from_, name):\n                check_name(name)\n                if isinstance(from_, str):\n                    log2( f'Adding file: {os.path.relpath(from_)} => {name}')\n                    tar.add( from_, f'{prefix}/{name}', recursive=False)\n                elif isinstance(from_, bytes):\n                    log2( f'Adding: {name}')\n                    ti = tarfile.TarInfo(f'{prefix}/{name}')\n                    ti.size = len(from_)\n                    ti.mtime = time.time()\n                    tar.addfile(ti, io.BytesIO(from_))\n                else:\n                    assert 0\n\n            def add_string(text, name):\n                textb = text.encode('utf8')\n                return add(textb, name)\n\n            found_pyproject_toml = False\n            for item in items:\n                from_, (to_abs, to_rel) = self._fromto(item)\n                if isinstance(from_, bytes):\n                    add(from_, to_rel)\n                else:\n                    if from_.startswith(f'{os.path.abspath(sdist_directory)}/'):\n                        # Source files should not be inside <sdist_directory>.\n                        assert 0, f'Path is inside sdist_directory={sdist_directory}: {from_!r}'\n                    assert os.path.exists(from_), f'Path does not exist: {from_!r}'\n                    assert os.path.isfile(from_), f'Path is not a file: {from_!r}'\n                    if to_rel == 'pyproject.toml':\n                        found_pyproject_toml = True\n                    add(from_, to_rel)\n\n            if not found_pyproject_toml:\n                log0(f'Warning: no pyproject.toml specified.')\n\n            # Always add a PKG-INFO file.\n            add_string(self._metainfo(), 'PKG-INFO')\n\n            if self.license:\n                if 'COPYING' in names_in_tar:\n                    log2(f'Not writing .license because file already in sdist: COPYING')\n                else:\n                    add_string(self.license, 'COPYING')\n\n        log1( f'Have created sdist: {tarpath}')\n        return os.path.basename(tarpath)\n\n    def wheel_tag_string(self):\n        '''\n        Returns <tag_python>-<tag_abi>-<tag_platform>.\n        '''\n        return f'{self.tag_python()}-{self.tag_abi()}-{self.tag_platform()}'\n\n    def tag_python(self):\n        '''\n        Get two-digit python version, e.g. 'cp3.8' for python-3.8.6.\n        '''\n        if self.tag_python_:\n            return self.tag_python_\n        else:\n            return 'cp' + ''.join(platform.python_version().split('.')[:2])\n\n    def tag_abi(self):\n        '''\n        ABI tag.\n        '''\n        if self.tag_abi_:\n            return self.tag_abi_\n        elif self.py_limited_api:\n            return 'abi3'\n        else:\n            return 'none'\n\n    def tag_platform(self):\n        '''\n        Find platform tag used in wheel filename.\n        '''\n        ret = self.tag_platform_\n        log0(f'From self.tag_platform_: {ret=}.')\n        \n        if not ret:\n            # Prefer this to PEP-425. Appears to be undocumented,\n            # but set in manylinux docker images and appears\n            # to be used by cibuildwheel and auditwheel, e.g.\n            # https://github.com/rapidsai/shared-action-workflows/issues/80\n            ret = os.environ.get( 'AUDITWHEEL_PLAT')\n            log0(f'From AUDITWHEEL_PLAT: {ret=}.')\n\n        if not ret:\n            # Notes:\n            #\n            # PEP-425. On Linux gives `linux_x86_64` which is rejected by\n            # pypi.org.\n            #\n            # On local MacOS/arm64 mac-mini have seen sysconfig.get_platform()\n            # unhelpfully return `macosx-10.9-universal2` if `python3` is the\n            # system Python /usr/bin/python3; this happens if we source `.\n            # /etc/profile`.\n            #\n            ret = sysconfig.get_platform()\n            ret = ret.replace('-', '_').replace('.', '_').lower()\n            log0(f'From sysconfig.get_platform(): {ret=}.')\n\n            # We need to patch things on MacOS.\n            #\n            # E.g. `foo-1.2.3-cp311-none-macosx_13_x86_64.whl`\n            # causes `pip` to fail with: `not a supported wheel on this\n            # platform`. We seem to need to add `_0` to the OS version.\n            #\n            m = re.match( '^(macosx_[0-9]+)(_[^0-9].+)$', ret)\n            if m:\n                ret2 = f'{m.group(1)}_0{m.group(2)}'\n                log0(f'After macos patch, changing from {ret!r} to {ret2!r}.')\n                ret = ret2\n\n        log0( f'tag_platform(): returning {ret=}.')\n        return ret\n\n    def wheel_name(self):\n        return f'{_normalise(self.name)}-{self.version}-{self.tag_python()}-{self.tag_abi()}-{self.tag_platform()}.whl'\n\n    def wheel_name_match(self, wheel):\n        '''\n        Returns true if `wheel` matches our wheel. We basically require the\n        name to be the same, except that we accept platform tags that contain\n        extra items (see pep-0600/), for example we return true with:\n\n            self:   foo-cp38-none-manylinux2014_x86_64.whl\n            wheel:  foo-cp38-none-manylinux2014_x86_64.manylinux_2_17_x86_64.whl\n        '''\n        log2(f'{wheel=}')\n        assert wheel.endswith('.whl')\n        wheel2 = wheel[:-len('.whl')]\n        name, version, tag_python, tag_abi, tag_platform = wheel2.split('-')\n        \n        py_limited_api_compatible = False\n        if self.py_limited_api and tag_abi == 'abi3':\n            # Allow lower tag_python number.\n            m = re.match('cp([0-9]+)', tag_python)\n            tag_python_int = int(m.group(1))\n            m = re.match('cp([0-9]+)', self.tag_python())\n            tag_python_int_self = int(m.group(1))\n            if tag_python_int <= tag_python_int_self:\n                # This wheel uses Python stable ABI same or older than ours, so\n                # we can use it.\n                log2(f'py_limited_api; {tag_python=} compatible with {self.tag_python()=}.')\n                py_limited_api_compatible = True\n            \n        log2(f'{_normalise(self.name) == name=}')\n        log2(f'{self.version == version=}')\n        log2(f'{self.tag_python() == tag_python=} {self.tag_python()=} {tag_python=}')\n        log2(f'{py_limited_api_compatible=}')\n        log2(f'{self.tag_abi() == tag_abi=}')\n        log2(f'{self.tag_platform() in tag_platform.split(\".\")=}')\n        log2(f'{self.tag_platform()=}')\n        log2(f'{tag_platform.split(\".\")=}')\n        ret = (1\n                and _normalise(self.name) == name\n                and self.version == version\n                and (self.tag_python() == tag_python or py_limited_api_compatible)\n                and self.tag_abi() == tag_abi\n                and self.tag_platform() in tag_platform.split('.')\n                )\n        log2(f'Returning {ret=}.')\n        return ret\n    \n    def _entry_points_text(self):\n        if self.entry_points:\n            if isinstance(self.entry_points, str):\n                return self.entry_points\n            ret = ''\n            for key, values in self.entry_points.items():\n                ret += f'[{key}]\\n'\n                for value in values:\n                    ret += f'{value}\\n'\n            return ret\n\n    def _call_fn_build( self, config_settings=None):\n        assert self.fn_build\n        log2(f'calling self.fn_build={self.fn_build}')\n        if inspect.signature(self.fn_build).parameters:\n            ret = self.fn_build(config_settings)\n        else:\n            ret = self.fn_build()\n        assert isinstance( ret, (list, tuple)), \\\n                f'Expected list/tuple from {self.fn_build} but got: {ret!r}'\n        return ret\n\n\n    def _argv_clean(self, all_):\n        '''\n        Called by `handle_argv()`.\n        '''\n        if not self.fn_clean:\n            return\n        paths = self.fn_clean(all_)\n        if paths:\n            if isinstance(paths, str):\n                paths = paths,\n            for path in paths:\n                if not os.path.isabs(path):\n                    path = ps.path.join(self.root, path)\n                path = os.path.abspath(path)\n                assert path.startswith(self.root+os.sep), \\\n                        f'path={path!r} does not start with root={self.root+os.sep!r}'\n                log2(f'Removing: {path}')\n                shutil.rmtree(path, ignore_errors=True)\n\n\n    def install(self, record_path=None, root=None):\n        '''\n        Called by `handle_argv()` to handle `install` command..\n        '''\n        log2( f'{record_path=} {root=}')\n\n        # Do a build and get list of files to install.\n        #\n        items = list()\n        if self.fn_build:\n            items = self._call_fn_build( dict())\n\n        root2 = install_dir(root)\n        log2( f'{root2=}')\n\n        log1( f'Installing into: {root2!r}')\n        dist_info_dir = self._dist_info_dir()\n\n        if not record_path:\n            record_path = f'{root2}/{dist_info_dir}/RECORD'\n        record = _Record()\n\n        def add_file(from_, to_abs, to_rel):\n            os.makedirs( os.path.dirname( to_abs), exist_ok=True)\n            if isinstance(from_, bytes):\n                log2(f'Copying content into {to_abs}.')\n                with open(to_abs, 'wb') as f:\n                    f.write(from_)\n                record.add_content(from_, to_rel)\n            else:\n                log0(f'{from_=}')\n                log2(f'Copying from {os.path.relpath(from_, self.root)} to {to_abs}')\n                shutil.copy2( from_, to_abs)\n                record.add_file(from_, to_rel)\n\n        def add_str(content, to_abs, to_rel):\n            log2( f'Writing to: {to_abs}')\n            os.makedirs( os.path.dirname( to_abs), exist_ok=True)\n            with open( to_abs, 'w') as f:\n                f.write( content)\n            record.add_content(content, to_rel)\n\n        for item in items:\n            from_, (to_abs, to_rel) = self._fromto(item)\n            log0(f'{from_=} {to_abs=} {to_rel=}')\n            to_abs2 = f'{root2}/{to_rel}'\n            add_file( from_, to_abs2, to_rel)\n\n        add_str( self._metainfo(), f'{root2}/{dist_info_dir}/METADATA', f'{dist_info_dir}/METADATA')\n\n        if self.license:\n            add_str( self.license, f'{root2}/{dist_info_dir}/COPYING', f'{dist_info_dir}/COPYING')\n\n        entry_points_text = self._entry_points_text()\n        if entry_points_text:\n            add_str(\n                    entry_points_text,\n                    f'{root2}/{dist_info_dir}/entry_points.txt',\n                    f'{dist_info_dir}/entry_points.txt',\n                    )\n\n        log2( f'Writing to: {record_path}')\n        with open(record_path, 'w') as f:\n            f.write(record.get())\n\n        log2(f'Finished.')\n\n\n    def _argv_dist_info(self, root):\n        '''\n        Called by `handle_argv()`. There doesn't seem to be any documentation\n        for `setup.py dist_info`, but it appears to be like `egg_info` except\n        it writes to a slightly different directory.\n        '''\n        if root is None:\n            root = f'{self.name}-{self.version}.dist-info'\n        self._write_info(f'{root}/METADATA')\n        if self.license:\n            with open( f'{root}/COPYING', 'w') as f:\n                f.write( self.license)\n\n\n    def _argv_egg_info(self, egg_base):\n        '''\n        Called by `handle_argv()`.\n        '''\n        if egg_base is None:\n            egg_base = '.'\n        self._write_info(f'{egg_base}/.egg-info')\n\n\n    def _write_info(self, dirpath=None):\n        '''\n        Writes egg/dist info to files in directory `dirpath` or `self.root` if\n        `None`.\n        '''\n        if dirpath is None:\n            dirpath = self.root\n        log2(f'Creating files in directory {dirpath}')\n        os.makedirs(dirpath, exist_ok=True)\n        with open(os.path.join(dirpath, 'PKG-INFO'), 'w') as f:\n            f.write(self._metainfo())\n\n        # These don't seem to be required?\n        #\n        #with open(os.path.join(dirpath, 'SOURCES.txt', 'w') as f:\n        #    pass\n        #with open(os.path.join(dirpath, 'dependency_links.txt', 'w') as f:\n        #    pass\n        #with open(os.path.join(dirpath, 'top_level.txt', 'w') as f:\n        #    f.write(f'{self.name}\\n')\n        #with open(os.path.join(dirpath, 'METADATA', 'w') as f:\n        #    f.write(self._metainfo())\n\n\n    def handle_argv(self, argv):\n        '''\n        Attempt to handles old-style (pre PEP-517) command line passed by\n        old releases of pip to a `setup.py` script, and manual running of\n        `setup.py`.\n\n        This is partial support at best.\n        '''\n        global g_verbose\n        #log2(f'argv: {argv}')\n\n        class ArgsRaise:\n            pass\n\n        class Args:\n            '''\n            Iterates over argv items.\n            '''\n            def __init__( self, argv):\n                self.items = iter( argv)\n            def next( self, eof=ArgsRaise):\n                '''\n                Returns next arg. If no more args, we return <eof> or raise an\n                exception if <eof> is ArgsRaise.\n                '''\n                try:\n                    return next( self.items)\n                except StopIteration:\n                    if eof is ArgsRaise:\n                        raise Exception('Not enough args')\n                    return eof\n\n        command = None\n        opt_all = None\n        opt_dist_dir = 'dist'\n        opt_egg_base = None\n        opt_formats = None\n        opt_install_headers = None\n        opt_record = None\n        opt_root = None\n\n        args = Args(argv[1:])\n\n        while 1:\n            arg = args.next(None)\n            if arg is None:\n                break\n\n            elif arg in ('-h', '--help', '--help-commands'):\n                log0(textwrap.dedent('''\n                        Usage:\n                            [<options>...] <command> [<options>...]\n                        Commands:\n                            bdist_wheel\n                                Creates a wheel called\n                                <dist-dir>/<name>-<version>-<details>.whl, where\n                                <dist-dir> is \"dist\" or as specified by --dist-dir,\n                                and <details> encodes ABI and platform etc.\n                            clean\n                                Cleans build files.\n                            dist_info\n                                Creates files in <name>-<version>.dist-info/ or\n                                directory specified by --egg-base.\n                            egg_info\n                                Creates files in .egg-info/ or directory\n                                directory specified by --egg-base.\n                            install\n                                Builds and installs. Writes installation\n                                information to <record> if --record was\n                                specified.\n                            sdist\n                                Make a source distribution:\n                                    <dist-dir>/<name>-<version>.tar.gz\n                        Options:\n                            --all\n                                Used by \"clean\".\n                            --compile\n                                Ignored.\n                            --dist-dir | -d <dist-dir>\n                                Default is \"dist\".\n                            --egg-base <egg-base>\n                                Used by \"egg_info\".\n                            --formats <formats>\n                                Used by \"sdist\".\n                            --install-headers <directory>\n                                Ignored.\n                            --python-tag <python-tag>\n                                Ignored.\n                            --record <record>\n                                Used by \"install\".\n                            --root <path>\n                                Used by \"install\".\n                            --single-version-externally-managed\n                                Ignored.\n                            --verbose -v\n                                Extra diagnostics.\n                        Other:\n                            windows-vs [-y <year>] [-v <version>] [-g <grade] [--verbose]\n                                Windows only; looks for matching Visual Studio.\n                            windows-python [-v <version>] [--verbose]\n                                Windows only; looks for matching Python.\n                        '''))\n                return\n\n            elif arg in ('bdist_wheel', 'clean', 'dist_info', 'egg_info', 'install', 'sdist'):\n                assert command is None, 'Two commands specified: {command} and {arg}.'\n                command = arg\n\n            elif arg == '--all':                                opt_all = True\n            elif arg == '--compile':                            pass\n            elif arg == '--dist-dir' or arg == '-d':            opt_dist_dir = args.next()\n            elif arg == '--egg-base':                           opt_egg_base = args.next()\n            elif arg == '--formats':                            opt_formats = args.next()\n            elif arg == '--install-headers':                    opt_install_headers = args.next()\n            elif arg == '--python-tag':                         pass\n            elif arg == '--record':                             opt_record = args.next()\n            elif arg == '--root':                               opt_root = args.next()\n            elif arg == '--single-version-externally-managed':  pass\n            elif arg == '--verbose' or arg == '-v':             g_verbose += 1\n\n            elif arg == 'windows-vs':\n                command = arg\n                break\n            elif arg == 'windows-python':\n                command = arg\n                break\n            else:\n               raise Exception(f'Unrecognised arg: {arg}')\n\n        assert command, 'No command specified'\n\n        log1(f'Handling command={command}')\n        if 0:   pass\n        elif command == 'bdist_wheel':  self.build_wheel(opt_dist_dir)\n        elif command == 'clean':        self._argv_clean(opt_all)\n        elif command == 'dist_info':    self._argv_dist_info(opt_egg_base)\n        elif command == 'egg_info':     self._argv_egg_info(opt_egg_base)\n        elif command == 'install':      self.install(opt_record, opt_root)\n        elif command == 'sdist':        self.build_sdist(opt_dist_dir, opt_formats)\n\n        elif command == 'windows-python':\n            version = None\n            while 1:\n                arg = args.next(None)\n                if arg is None:\n                    break\n                elif arg == '-v':\n                    version = args.next()\n                elif arg == '--verbose':\n                    g_verbose += 1\n                else:\n                    assert 0, f'Unrecognised {arg=}'\n            python = wdev.WindowsPython(version=version)\n            print(f'Python is:\\n{python.description_ml(\"    \")}')\n\n        elif command == 'windows-vs':\n            grade = None\n            version = None\n            year = None\n            while 1:\n                arg = args.next(None)\n                if arg is None:\n                    break\n                elif arg == '-g':\n                    grade = args.next()\n                elif arg == '-v':\n                    version = args.next()\n                elif arg == '-y':\n                    year = args.next()\n                elif arg == '--verbose':\n                    g_verbose += 1\n                else:\n                    assert 0, f'Unrecognised {arg=}'\n            vs = wdev.WindowsVS(year=year, grade=grade, version=version)\n            print(f'Visual Studio is:\\n{vs.description_ml(\"    \")}')\n\n        else:\n            assert 0, f'Unrecognised command: {command}'\n\n        log2(f'Finished handling command: {command}')\n\n\n    def __str__(self):\n        return ('{'\n            f'name={self.name!r}'\n            f' version={self.version!r}'\n            f' platform={self.platform!r}'\n            f' supported_platform={self.supported_platform!r}'\n            f' summary={self.summary!r}'\n            f' description={self.description!r}'\n            f' description_content_type={self.description_content_type!r}'\n            f' keywords={self.keywords!r}'\n            f' home_page={self.home_page!r}'\n            f' download_url={self.download_url!r}'\n            f' author={self.author!r}'\n            f' author_email={self.author_email!r}'\n            f' maintainer={self.maintainer!r}'\n            f' maintainer_email={self.maintainer_email!r}'\n            f' license={self.license!r}'\n            f' classifier={self.classifier!r}'\n            f' requires_dist={self.requires_dist!r}'\n            f' requires_python={self.requires_python!r}'\n            f' requires_external={self.requires_external!r}'\n            f' project_url={self.project_url!r}'\n            f' provides_extra={self.provides_extra!r}'\n\n            f' root={self.root!r}'\n            f' fn_build={self.fn_build!r}'\n            f' fn_sdist={self.fn_sdist!r}'\n            f' fn_clean={self.fn_clean!r}'\n            f' tag_python={self.tag_python_!r}'\n            f' tag_abi={self.tag_abi_!r}'\n            f' tag_platform={self.tag_platform_!r}'\n            '}'\n            )\n\n    def _dist_info_dir( self):\n        return f'{_normalise(self.name)}-{self.version}.dist-info'\n\n    def _metainfo(self):\n        '''\n        Returns text for `.egg-info/PKG-INFO` file, or `PKG-INFO` in an sdist\n        `.tar.gz` file, or `...dist-info/METADATA` in a wheel.\n        '''\n        # 2021-04-30: Have been unable to get multiline content working on\n        # test.pypi.org so we currently put the description as the body after\n        # all the other headers.\n        #\n        ret = ['']\n        def add(key, value):\n            if value is None:\n                return\n            if isinstance( value, (tuple, list)):\n                for v in value:\n                    if v is not None:\n                        add( key, v)\n                return\n            if key == 'License' and '\\n' in value:\n                # This is ok because we write `self.license` into\n                # *.dist-info/COPYING.\n                #\n                log1( f'Omitting license because contains newline(s).')\n                return\n            assert '\\n' not in value, f'key={key} value contains newline: {value!r}'\n            if key == 'Project-URL':\n                assert value.count(',') == 1, f'For {key=}, should have one comma in {value!r}.'\n            ret[0] += f'{key}: {value}\\n'\n        #add('Description', self.description)\n        add('Metadata-Version', '2.1')\n\n        # These names are from:\n        # https://packaging.python.org/specifications/core-metadata/\n        #\n        for name in (\n                'Name',\n                'Version',\n                'Platform',\n                'Supported-Platform',\n                'Summary',\n                'Description-Content-Type',\n                'Keywords',\n                'Home-page',\n                'Download-URL',\n                'Author',\n                'Author-email',\n                'Maintainer',\n                'Maintainer-email',\n                'License',\n                'Classifier',\n                'Requires-Dist',\n                'Requires-Python',\n                'Requires-External',\n                'Project-URL',\n                'Provides-Extra',\n                ):\n            identifier = name.lower().replace( '-', '_')\n            add( name, getattr( self, identifier))\n\n        ret = ret[0]\n\n        # Append description as the body\n        if self.description:\n            if '\\n' in self.description:\n                description_text = self.description.strip()\n            else:\n                with open(self.description) as f:\n                    description_text = f.read()\n            ret += '\\n' # Empty line separates headers from body.\n            ret += description_text\n            ret += '\\n'\n        return ret\n\n    def _path_relative_to_root(self, path, assert_within_root=True):\n        '''\n        Returns `(path_abs, path_rel)`, where `path_abs` is absolute path and\n        `path_rel` is relative to `self.root`.\n\n        Interprets `path` as relative to `self.root` if not absolute.\n\n        We use `os.path.realpath()` to resolve any links.\n\n        if `assert_within_root` is true, assert-fails if `path` is not within\n        `self.root`.\n        '''\n        if os.path.isabs(path):\n            p = path\n        else:\n            p = os.path.join(self.root, path)\n        p = os.path.realpath(os.path.abspath(p))\n        if assert_within_root:\n            assert p.startswith(self.root+os.sep) or p == self.root, \\\n                    f'Path not within root={self.root+os.sep!r}: {path=} {p=}'\n        p_rel = os.path.relpath(p, self.root)\n        return p, p_rel\n\n    def _fromto(self, p):\n        '''\n        Returns `(from_, (to_abs, to_rel))`.\n\n        If `p` is a string we convert to `(p, p)`. Otherwise we assert that\n        `p` is a tuple `(from_, to_)` where `from_` is str/bytes and `to_` is\n        str. If `from_` is a bytes it is contents of file to add, otherwise the\n        path of an existing file; non-absolute paths are assumed to be relative\n        to `self.root`. If `to_` is empty or ends with `/`, we append the leaf\n        of `from_` (which must be a str).\n\n        If `to_` starts with `$dist-info/`, we replace this with\n        `self._dist_info_dir()`.\n\n        If `to_` starts with `$data/`, we replace this with\n        `{self.name}-{self.version}.data/`.\n\n        We assert that `to_abs` is `within self.root`.\n\n        `to_rel` is derived from the `to_abs` and is relative to self.root`.\n        '''\n        ret = None\n        if isinstance(p, str):\n            p = p, p\n        assert isinstance(p, tuple) and len(p) == 2\n\n        from_, to_ = p\n        assert isinstance(from_, (str, bytes))\n        assert isinstance(to_, str)\n        if to_.endswith('/') or to_=='':\n            to_ += os.path.basename(from_)\n        prefix = '$dist-info/'\n        if to_.startswith( prefix):\n            to_ = f'{self._dist_info_dir()}/{to_[ len(prefix):]}'\n        prefix = '$data/'\n        if to_.startswith( prefix):\n            to_ = f'{self.name}-{self.version}.data/{to_[ len(prefix):]}'\n        if isinstance(from_, str):\n            from_, _ = self._path_relative_to_root( from_, assert_within_root=False)\n        to_ = self._path_relative_to_root(to_)\n        assert isinstance(from_, (str, bytes))\n        log2(f'returning {from_=} {to_=}')\n        return from_, to_\n\n\ndef build_extension(\n        name,\n        path_i,\n        outdir,\n        builddir=None,\n        includes=None,\n        defines=None,\n        libpaths=None,\n        libs=None,\n        optimise=True,\n        debug=False,\n        compiler_extra='',\n        linker_extra='',\n        swig='swig',\n        cpp=True,\n        prerequisites_swig=None,\n        prerequisites_compile=None,\n        prerequisites_link=None,\n        infer_swig_includes=True,\n        py_limited_api=False,\n        ):\n    '''\n    Builds a Python extension module using SWIG. Works on Windows, Linux, MacOS\n    and OpenBSD.\n\n    On Unix, sets rpath when linking shared libraries.\n\n    Args:\n        name:\n            Name of generated extension module.\n        path_i:\n            Path of input SWIG `.i` file. Internally we use swig to generate a\n            corresponding `.c` or `.cpp` file.\n        outdir:\n            Output directory for generated files:\n\n                * `{outdir}/{name}.py`\n                * `{outdir}/_{name}.so`     # Unix\n                * `{outdir}/_{name}.*.pyd`  # Windows\n            We return the leafname of the `.so` or `.pyd` file.\n        builddir:\n            Where to put intermediate files, for example the .cpp file\n            generated by swig and `.d` dependency files. Default is `outdir`.\n        includes:\n            A string, or a sequence of extra include directories to be prefixed\n            with `-I`.\n        defines:\n            A string, or a sequence of extra preprocessor defines to be\n            prefixed with `-D`.\n        libpaths\n            A string, or a sequence of library paths to be prefixed with\n            `/LIBPATH:` on Windows or `-L` on Unix.\n        libs\n            A string, or a sequence of library names. Each item is prefixed\n            with `-l` on non-Windows.\n        optimise:\n            Whether to use compiler optimisations.\n        debug:\n            Whether to build with debug symbols.\n        compiler_extra:\n            Extra compiler flags. Can be None.\n        linker_extra:\n            Extra linker flags. Can be None.\n        swig:\n            Base swig command.\n        cpp:\n            If true we tell SWIG to generate C++ code instead of C.\n        prerequisites_swig:\n        prerequisites_compile:\n        prerequisites_link:\n\n            [These are mainly for use on Windows. On other systems we\n            automatically generate dynamic dependencies using swig/compile/link\n            commands' `-MD` and `-MF` args.]\n\n            Sequences of extra input files/directories that should force\n            running of swig, compile or link commands if they are newer than\n            any existing generated SWIG `.i` file, compiled object file or\n            shared library file.\n\n            If present, the first occurrence of `True` or `False` forces re-run\n            or no re-run. Any occurrence of None is ignored. If an item is a\n            directory path we look for newest file within the directory tree.\n\n            If not a sequence, we convert into a single-item list.\n\n            prerequisites_swig\n\n                We use swig's -MD and -MF args to generate dynamic dependencies\n                automatically, so this is not usually required.\n\n            prerequisites_compile\n            prerequisites_link\n\n                On non-Windows we use cc's -MF and -MF args to generate dynamic\n                dependencies so this is not usually required.\n        infer_swig_includes:\n            If true, we extract `-I<path>` and `-I <path>` args from\n            `compile_extra` (also `/I` on windows) and use them with swig so\n            that it can see the same header files as C/C++. This is useful\n            when using enviromment variables such as `CC` and `CXX` to set\n            `compile_extra.\n        py_limited_api:\n            If true we build for current Python's limited API / stable ABI.\n\n    Returns the leafname of the generated library file within `outdir`, e.g.\n    `_{name}.so` on Unix or `_{name}.cp311-win_amd64.pyd` on Windows.\n    '''\n    if compiler_extra is None:\n        compiler_extra = ''\n    if linker_extra is None:\n        linker_extra = ''\n    if builddir is None:\n        builddir = outdir\n    includes_text = _flags( includes, '-I')\n    defines_text = _flags( defines, '-D')\n    libpaths_text = _flags( libpaths, '/LIBPATH:', '\"') if windows() else _flags( libpaths, '-L')\n    libs_text = _flags( libs, '' if windows() else '-l')\n    path_cpp = f'{builddir}/{os.path.basename(path_i)}'\n    path_cpp += '.cpp' if cpp else '.c'\n    os.makedirs( outdir, exist_ok=True)\n\n    # Run SWIG.\n\n    if infer_swig_includes:\n        # Extract include flags from `compiler_extra`.\n        swig_includes_extra = ''\n        compiler_extra_items = compiler_extra.split()\n        i = 0\n        while i < len(compiler_extra_items):\n            item = compiler_extra_items[i]\n            # Swig doesn't seem to like a space after `I`.\n            if item == '-I' or (windows() and item == '/I'):\n                swig_includes_extra += f' -I{compiler_extra_items[i+1]}'\n                i += 1\n            elif item.startswith('-I') or (windows() and item.startswith('/I')):\n                swig_includes_extra += f' -I{compiler_extra_items[i][2:]}'\n            i += 1\n        swig_includes_extra = swig_includes_extra.strip()\n    deps_path = f'{path_cpp}.d'\n    prerequisites_swig2 = _get_prerequisites( deps_path)\n    run_if(\n            f'''\n            {swig}\n                -Wall\n                {\"-c++\" if cpp else \"\"}\n                -python\n                -module {name}\n                -outdir {outdir}\n                -o {path_cpp}\n                -MD -MF {deps_path}\n                {includes_text}\n                {swig_includes_extra}\n                {path_i}\n            '''\n            ,\n            path_cpp,\n            path_i,\n            prerequisites_swig,\n            prerequisites_swig2,\n            )\n\n    so_suffix = _so_suffix(use_so_versioning = not py_limited_api)\n    path_so_leaf = f'_{name}{so_suffix}'\n    path_so = f'{outdir}/{path_so_leaf}'\n\n    py_limited_api2 = current_py_limited_api() if py_limited_api else None\n\n    if windows():\n        path_obj = f'{path_so}.obj'\n\n        permissive = '/permissive-'\n        EHsc = '/EHsc'\n        T = '/Tp' if cpp else '/Tc'\n        optimise2 = '/DNDEBUG /O2' if optimise else '/D_DEBUG'\n        debug2 = ''\n        if debug:\n            debug2 = '/Zi'  # Generate .pdb.\n            # debug2 = '/Z7'    # Embed debug info in .obj files.\n        \n        py_limited_api3 = f'/DPy_LIMITED_API={py_limited_api2}' if py_limited_api2 else ''\n\n        # As of 2023-08-23, it looks like VS tools create slightly\n        # .dll's each time, even with identical inputs.\n        #\n        # Some info about this is at:\n        # https://nikhilism.com/post/2020/windows-deterministic-builds/.\n        # E.g. an undocumented linker flag `/Brepro`.\n        #\n\n        command, pythonflags = base_compiler(cpp=cpp)\n        command = f'''\n                {command}\n                    # General:\n                    /c                          # Compiles without linking.\n                    {EHsc}                      # Enable \"Standard C++ exception handling\".\n\n                    #/MD                         # Creates a multithreaded DLL using MSVCRT.lib.\n                    {'/MDd' if debug else '/MD'}\n\n                    # Input/output files:\n                    {T}{path_cpp}               # /Tp specifies C++ source file.\n                    /Fo{path_obj}               # Output file. codespell:ignore\n\n                    # Include paths:\n                    {includes_text}\n                    {pythonflags.includes}      # Include path for Python headers.\n\n                    # Code generation:\n                    {optimise2}\n                    {debug2}\n                    {permissive}                # Set standard-conformance mode.\n\n                    # Diagnostics:\n                    #/FC                         # Display full path of source code files passed to cl.exe in diagnostic text.\n                    /W3                         # Sets which warning level to output. /W3 is IDE default.\n                    /diagnostics:caret          # Controls the format of diagnostic messages.\n                    /nologo                     #\n\n                    {defines_text}\n                    {compiler_extra}\n\n                    {py_limited_api3}\n                '''\n        run_if( command, path_obj, path_cpp, prerequisites_compile)\n\n        command, pythonflags = base_linker(cpp=cpp)\n        debug2 = '/DEBUG' if debug else ''\n        base, _ = os.path.splitext(path_so_leaf)\n        command = f'''\n                {command}\n                    /DLL                    # Builds a DLL.\n                    /EXPORT:PyInit__{name}  # Exports a function.\n                    /IMPLIB:{base}.lib      # Overrides the default import library name.\n                    {libpaths_text}\n                    {pythonflags.ldflags}\n                    /OUT:{path_so}          # Specifies the output file name.\n                    {debug2}\n                    /nologo\n                    {libs_text}\n                    {path_obj}\n                    {linker_extra}\n                '''\n        run_if( command, path_so, path_obj, prerequisites_link)\n\n    else:\n\n        # Not Windows.\n        #\n        command, pythonflags = base_compiler(cpp=cpp)\n\n        # setuptools on Linux seems to use slightly different compile flags:\n        #\n        # -fwrapv -O3 -Wall -O2 -g0 -DPY_CALL_TRAMPOLINE\n        #\n\n        general_flags = ''\n        if debug:\n            general_flags += ' -g'\n        if optimise:\n            general_flags += ' -O2 -DNDEBUG'\n\n        py_limited_api3 = f'-DPy_LIMITED_API={py_limited_api2}' if py_limited_api2 else ''\n\n        if darwin():\n            # MacOS's linker does not like `-z origin`.\n            rpath_flag = \"-Wl,-rpath,@loader_path/\"\n\n            # Avoid `Undefined symbols for ... \"_PyArg_UnpackTuple\" ...'.\n            general_flags += ' -undefined dynamic_lookup'\n        elif pyodide():\n            # Setting `-Wl,-rpath,'$ORIGIN',-z,origin` gives:\n            #   emcc: warning: ignoring unsupported linker flag: `-rpath` [-Wlinkflags]\n            #   wasm-ld: error: unknown -z value: origin\n            #\n            log0(f'pyodide: PEP-3149 suffix untested, so omitting. {_so_suffix()=}.')\n            path_so_leaf = f'_{name}.so'\n            path_so = f'{outdir}/{path_so_leaf}'\n\n            rpath_flag = ''\n        else:\n            rpath_flag = \"-Wl,-rpath,'$ORIGIN',-z,origin\"\n        path_so = f'{outdir}/{path_so_leaf}'\n        # Fun fact - on Linux, if the -L and -l options are before '{path_cpp}'\n        # they seem to be ignored...\n        #\n        prerequisites = list()\n\n        if pyodide():\n            # Looks like pyodide's `cc` can't compile and link in one invocation.\n            prerequisites_compile_path = f'{path_cpp}.o.d'\n            prerequisites += _get_prerequisites( prerequisites_compile_path)\n            command = f'''\n                    {command}\n                        -fPIC\n                        {general_flags.strip()}\n                        {pythonflags.includes}\n                        {includes_text}\n                        {defines_text}\n                        -MD -MF {prerequisites_compile_path}\n                        -c {path_cpp}\n                        -o {path_cpp}.o\n                        {compiler_extra}\n                        {py_limited_api3}\n                    '''\n            prerequisites_link_path = f'{path_cpp}.o.d'\n            prerequisites += _get_prerequisites( prerequisites_link_path)\n            ld, _ = base_linker(cpp=cpp)\n            command += f'''\n                    && {ld}\n                        {path_cpp}.o\n                        -o {path_so}\n                        -MD -MF {prerequisites_link_path}\n                        {rpath_flag}\n                        {libpaths_text}\n                        {libs_text}\n                        {linker_extra}\n                        {pythonflags.ldflags}\n                    '''\n        else:\n            # We use compiler to compile and link in one command.\n            prerequisites_path = f'{path_so}.d'\n            prerequisites = _get_prerequisites(prerequisites_path)\n\n            command = f'''\n                    {command}\n                        -fPIC\n                        -shared\n                        {general_flags.strip()}\n                        {pythonflags.includes}\n                        {includes_text}\n                        {defines_text}\n                        {path_cpp}\n                        -MD -MF {prerequisites_path}\n                        -o {path_so}\n                        {compiler_extra}\n                        {libpaths_text}\n                        {linker_extra}\n                        {pythonflags.ldflags}\n                        {libs_text}\n                        {rpath_flag}\n                        {py_limited_api3}\n                    '''\n        command_was_run = run_if(\n                command,\n                path_so,\n                path_cpp,\n                prerequisites_compile,\n                prerequisites_link,\n                prerequisites,\n                )\n\n        if command_was_run and darwin():\n            # We need to patch up references to shared libraries in `libs`.\n            sublibraries = list()\n            for lib in () if libs is None else libs:\n                for libpath in libpaths:\n                    found = list()\n                    for suffix in '.so', '.dylib':\n                        path = f'{libpath}/lib{os.path.basename(lib)}{suffix}'\n                        if os.path.exists( path):\n                            found.append( path)\n                    if found:\n                        assert len(found) == 1, f'More than one file matches lib={lib!r}: {found}'\n                        sublibraries.append( found[0])\n                        break\n                else:\n                    log2(f'Warning: can not find path of lib={lib!r} in libpaths={libpaths}')\n            macos_patch( path_so, *sublibraries)\n\n        #run(f'ls -l {path_so}', check=0)\n        #run(f'file {path_so}', check=0)\n\n    return path_so_leaf\n\n\n# Functions that might be useful.\n#\n\n\ndef base_compiler(vs=None, pythonflags=None, cpp=False, use_env=True):\n    '''\n    Returns basic compiler command and PythonFlags.\n\n    Args:\n        vs:\n            Windows only. A `wdev.WindowsVS` instance or None to use default\n            `wdev.WindowsVS` instance.\n        pythonflags:\n            A `pipcl.PythonFlags` instance or None to use default\n            `pipcl.PythonFlags` instance.\n        cpp:\n            If true we return C++ compiler command instead of C. On Windows\n            this has no effect - we always return `cl.exe`.\n        use_env:\n            If true we return '$CC' or '$CXX' if the corresponding\n            environmental variable is set (without evaluating with `getenv()`\n            or `os.environ`).\n\n    Returns `(cc, pythonflags)`:\n        cc:\n            C or C++ command. On Windows this is of the form\n            `{vs.vcvars}&&{vs.cl}`; otherwise it is typically `cc` or `c++`.\n        pythonflags:\n            The `pythonflags` arg or a new `pipcl.PythonFlags` instance.\n    '''\n    if not pythonflags:\n        pythonflags = PythonFlags()\n    cc = None\n    if use_env:\n        if cpp:\n            if os.environ.get( 'CXX'):\n                cc = '$CXX'\n        else:\n            if os.environ.get( 'CC'):\n                cc = '$CC'\n    if cc:\n        pass\n    elif windows():\n        if not vs:\n            vs = wdev.WindowsVS()\n        cc = f'\"{vs.vcvars}\"&&\"{vs.cl}\"'\n    elif wasm():\n        cc = 'em++' if cpp else 'emcc'\n    else:\n        cc = 'c++' if cpp else 'cc'\n    cc = macos_add_cross_flags( cc)\n    return cc, pythonflags\n\n\ndef base_linker(vs=None, pythonflags=None, cpp=False, use_env=True):\n    '''\n    Returns basic linker command.\n\n    Args:\n        vs:\n            Windows only. A `wdev.WindowsVS` instance or None to use default\n            `wdev.WindowsVS` instance.\n        pythonflags:\n            A `pipcl.PythonFlags` instance or None to use default\n            `pipcl.PythonFlags` instance.\n        cpp:\n            If true we return C++ linker command instead of C. On Windows this\n            has no effect - we always return `link.exe`.\n        use_env:\n            If true we use `os.environ['LD']` if set.\n\n    Returns `(linker, pythonflags)`:\n        linker:\n            Linker command. On Windows this is of the form\n            `{vs.vcvars}&&{vs.link}`; otherwise it is typically `cc` or `c++`.\n        pythonflags:\n            The `pythonflags` arg or a new `pipcl.PythonFlags` instance.\n    '''\n    if not pythonflags:\n        pythonflags = PythonFlags()\n    linker = None\n    if use_env:\n        if os.environ.get( 'LD'):\n            linker = '$LD'\n    if linker:\n        pass\n    elif windows():\n        if not vs:\n            vs = wdev.WindowsVS()\n        linker = f'\"{vs.vcvars}\"&&\"{vs.link}\"'\n    elif wasm():\n        linker = 'em++' if cpp else 'emcc'\n    else:\n        linker = 'c++' if cpp else 'cc'\n    linker = macos_add_cross_flags( linker)\n    return linker, pythonflags\n\n\ndef git_items( directory, submodules=False):\n    '''\n    Returns list of paths for all files known to git within a `directory`.\n\n    Args:\n        directory:\n            Must be somewhere within a git checkout.\n        submodules:\n            If true we also include git submodules.\n\n    Returns:\n        A list of paths for all files known to git within `directory`. Each\n        path is relative to `directory`. `directory` must be somewhere within a\n        git checkout.\n\n    We run a `git ls-files` command internally.\n\n    This function can be useful for the `fn_sdist()` callback.\n    '''\n    command = 'cd ' + directory + ' && git ls-files'\n    if submodules:\n        command += ' --recurse-submodules'\n    log1(f'Running {command=}')\n    text = subprocess.check_output( command, shell=True)\n    ret = []\n    for path in text.decode('utf8').strip().split( '\\n'):\n        path2 = os.path.join(directory, path)\n        # Sometimes git ls-files seems to list empty/non-existent directories\n        # within submodules.\n        #\n        if not os.path.exists(path2):\n            log2(f'Ignoring git ls-files item that does not exist: {path2}')\n        elif os.path.isdir(path2):\n            log2(f'Ignoring git ls-files item that is actually a directory: {path2}')\n        else:\n            ret.append(path)\n    return ret\n\n\ndef run(\n        command,\n        *,\n        capture=False,\n        check=1,\n        verbose=1,\n        env_extra=None,\n        timeout=None,\n        caller=1,\n        ):\n    '''\n    Runs a command using `subprocess.run()`.\n\n    Args:\n        command:\n            A string, the command to run.\n\n            Multiple lines in `command` are treated as a single command.\n\n            * If a line starts with `#` it is discarded.\n            * If a line contains ` #`, the trailing text is discarded.\n\n            When running the command on Windows, newlines are replaced by\n            spaces; otherwise each line is terminated by a backslash character.\n        capture:\n            If true, we include the command's output in our return value.\n        check:\n            If true we raise an exception on error; otherwise we include the\n            command's returncode in our return value.\n        verbose:\n            If true we show the command.\n        env_extra:\n            None or dict to add to environ.\n        timeout:\n            If not None, timeout in seconds; passed directly to\n            subprocess.run(). Note that on MacOS subprocess.run() seems to\n            leave processes running if timeout expires.\n    Returns:\n        check capture   Return\n        --------------------------\n          false false   returncode\n          false  true   (returncode, output)\n          true  false   None or raise exception\n          true   true   output or raise exception\n    '''\n    env = None\n    if env_extra:\n        env = os.environ.copy()\n        env.update(env_extra)\n    lines = _command_lines( command)\n    nl = '\\n'\n    if verbose:\n        log1( f'Running: {nl.join(lines)}', caller=caller+1)\n    sep = ' ' if windows() else ' \\\\\\n'\n    command2 = sep.join( lines)\n    cp = subprocess.run(\n            command2,\n            shell=True,\n            stdout=subprocess.PIPE if capture else None,\n            stderr=subprocess.STDOUT if capture else None,\n            check=check,\n            encoding='utf8',\n            env=env,\n            timeout=timeout,\n            )\n    if check:\n        return cp.stdout if capture else None\n    else:\n        return (cp.returncode, cp.stdout) if capture else cp.returncode\n\n\ndef darwin():\n    return sys.platform.startswith( 'darwin')\n\ndef windows():\n    return platform.system() == 'Windows'\n\ndef wasm():\n    return os.environ.get( 'OS') in ('wasm', 'wasm-mt')\n\ndef pyodide():\n    return os.environ.get( 'PYODIDE') == '1'\n\ndef linux():\n    return platform.system() == 'Linux'\n\ndef openbsd():\n    return platform.system() == 'OpenBSD'\n\nclass PythonFlags:\n    '''\n    Compile/link flags for the current python, for example the include path\n    needed to get `Python.h`.\n\n    The 'PIPCL_PYTHON_CONFIG' environment variable allows to override\n    the location of the python-config executable.\n\n    Members:\n        .includes:\n            String containing compiler flags for include paths.\n        .ldflags:\n            String containing linker flags for library paths.\n    '''\n    def __init__(self):\n\n        if windows():\n            wp = wdev.WindowsPython()\n            self.includes = f'/I\"{wp.include}\"'\n            self.ldflags = f'/LIBPATH:\"{wp.libs}\"'\n\n        elif pyodide():\n            _include_dir = os.environ[ 'PYO3_CROSS_INCLUDE_DIR']\n            _lib_dir = os.environ[ 'PYO3_CROSS_LIB_DIR']\n            self.includes = f'-I {_include_dir}'\n            self.ldflags = f'-L {_lib_dir}'\n\n        else:\n            python_config = os.environ.get(\"PIPCL_PYTHON_CONFIG\")\n            if not python_config:\n                # We use python-config which appears to work better than pkg-config\n                # because it copes with multiple installed python's, e.g.\n                # manylinux_2014's /opt/python/cp*-cp*/bin/python*.\n                #\n                # But... on non-macos it seems that we should not attempt to specify\n                # libpython on the link command. The manylinux docker containers\n                # don't actually contain libpython.so, and it seems that this\n                # deliberate. And the link command runs ok.\n                #\n                python_exe = os.path.realpath( sys.executable)\n                if darwin():\n                    # Basic install of dev tools with `xcode-select --install` doesn't\n                    # seem to provide a `python3-config` or similar, but there is a\n                    # `python-config.py` accessible via sysconfig.\n                    #\n                    # We try different possibilities and use the last one that\n                    # works.\n                    #\n                    python_config = None\n                    for pc in (\n                            f'python3-config',\n                            f'{sys.executable} {sysconfig.get_config_var(\"srcdir\")}/python-config.py',\n                            f'{python_exe}-config',\n                            ):\n                        e = subprocess.run(\n                                f'{pc} --includes',\n                                shell=1,\n                                stdout=subprocess.DEVNULL,\n                                stderr=subprocess.DEVNULL,\n                                check=0,\n                                ).returncode\n                        log2(f'{e=} from {pc!r}.')\n                        if e == 0:\n                            python_config = pc\n                    assert python_config, f'Cannot find python-config'\n                else:\n                    python_config = f'{python_exe}-config'\n            log2(f'Using {python_config=}.')\n            try:\n                self.includes = run( f'{python_config} --includes', capture=1, verbose=0).strip()\n            except Exception as e:\n                raise Exception('We require python development tools to be installed.') from e\n            self.ldflags = run( f'{python_config} --ldflags', capture=1, verbose=0).strip()\n            if linux():\n                # It seems that with python-3.10 on Linux, we can get an\n                # incorrect -lcrypt flag that on some systems (e.g. WSL)\n                # causes:\n                #\n                #   ImportError: libcrypt.so.2: cannot open shared object file: No such file or directory\n                #\n                ldflags2 = self.ldflags.replace(' -lcrypt ', ' ')\n                if ldflags2 != self.ldflags:\n                    log2(f'### Have removed `-lcrypt` from ldflags: {self.ldflags!r} -> {ldflags2!r}')\n                    self.ldflags = ldflags2\n\n        log2(f'{self.includes=}')\n        log2(f'{self.ldflags=}')\n\n\ndef macos_add_cross_flags(command):\n    '''\n    If running on MacOS and environment variables ARCHFLAGS is set\n    (indicating we are cross-building, e.g. for arm64), returns\n    `command` with extra flags appended. Otherwise returns unchanged\n    `command`.\n    '''\n    if darwin():\n        archflags = os.environ.get( 'ARCHFLAGS')\n        if archflags:\n            command = f'{command} {archflags}'\n            log2(f'Appending ARCHFLAGS to command: {command}')\n            return command\n    return command\n\n\ndef macos_patch( library, *sublibraries):\n    '''\n    If running on MacOS, patches `library` so that all references to items in\n    `sublibraries` are changed to `@rpath/{leafname}`. Does nothing on other\n    platforms.\n\n    library:\n        Path of shared library.\n    sublibraries:\n        List of paths of shared libraries; these have typically been\n        specified with `-l` when `library` was created.\n    '''\n    log2( f'macos_patch(): library={library}  sublibraries={sublibraries}')\n    if not darwin():\n        return\n    if not sublibraries:\n        return\n    subprocess.run( f'otool -L {library}', shell=1, check=1)\n    command = 'install_name_tool'\n    names = []\n    for sublibrary in sublibraries:\n        name = subprocess.run(\n                f'otool -D {sublibrary}',\n                shell=1,\n                check=1,\n                capture_output=1,\n                encoding='utf8',\n                ).stdout.strip()\n        name = name.split('\\n')\n        assert len(name) == 2 and name[0] == f'{sublibrary}:', f'{name=}'\n        name = name[1]\n        # strip trailing so_name.\n        leaf = os.path.basename(name)\n        m = re.match('^(.+[.]((so)|(dylib)))[0-9.]*$', leaf)\n        assert m\n        log2(f'Changing {leaf=} to {m.group(1)}')\n        leaf = m.group(1)\n        command += f' -change {name} @rpath/{leaf}'\n    command += f' {library}'\n    log2( f'Running: {command}')\n    subprocess.run( command, shell=1, check=1)\n    subprocess.run( f'otool -L {library}', shell=1, check=1)\n\n\n# Internal helpers.\n#\n\ndef _command_lines( command):\n    '''\n    Process multiline command by running through `textwrap.dedent()`, removes\n    comments (lines starting with `#` or ` #` until end of line), removes\n    entirely blank lines.\n\n    Returns list of lines.\n    '''\n    command = textwrap.dedent( command)\n    lines = []\n    for line in command.split( '\\n'):\n        if line.startswith( '#'):\n            h = 0\n        else:\n            h = line.find( ' #')\n        if h >= 0:\n            line = line[:h]\n        if line.strip():\n            lines.append(line.rstrip())\n    return lines\n\n\ndef _cpu_name():\n    '''\n    Returns `x32` or `x64` depending on Python build.\n    '''\n    #log(f'sys.maxsize={hex(sys.maxsize)}')\n    return f'x{32 if sys.maxsize == 2**31 - 1 else 64}'\n\n\ndef run_if( command, out, *prerequisites):\n    '''\n    Runs a command only if the output file is not up to date.\n\n    Args:\n        command:\n            The command to run. We write this into a file <out>.cmd so that we\n            know to run a command if the command itself has changed.\n        out:\n            Path of the output file.\n\n        prerequisites:\n            List of prerequisite paths or true/false/None items. If an item\n            is None it is ignored, otherwise if an item is not a string we\n            immediately return it cast to a bool.\n\n    Returns:\n        True if we ran the command, otherwise None.\n\n\n    If the output file does not exist, the command is run:\n\n        >>> verbose(1)\n        1\n        >>> log_line_numbers(0)\n        >>> out = 'run_if_test_out'\n        >>> if os.path.exists( out):\n        ...     os.remove( out)\n        >>> if os.path.exists( f'{out}.cmd'):\n        ...     os.remove( f'{out}.cmd')\n        >>> run_if( f'touch {out}', out)\n        pipcl.py:run_if(): Running command because: File does not exist: 'run_if_test_out'\n        pipcl.py:run_if(): Running: touch run_if_test_out\n        True\n\n    If we repeat, the output file will be up to date so the command is not run:\n\n        >>> run_if( f'touch {out}', out)\n        pipcl.py:run_if(): Not running command because up to date: 'run_if_test_out'\n\n    If we change the command, the command is run:\n\n        >>> run_if( f'touch  {out}', out)\n        pipcl.py:run_if(): Running command because: Command has changed\n        pipcl.py:run_if(): Running: touch  run_if_test_out\n        True\n\n    If we add a prerequisite that is newer than the output, the command is run:\n\n        >>> time.sleep(1)\n        >>> prerequisite = 'run_if_test_prerequisite'\n        >>> run( f'touch {prerequisite}', caller=0)\n        pipcl.py:run(): Running: touch run_if_test_prerequisite\n        >>> run_if( f'touch  {out}', out, prerequisite)\n        pipcl.py:run_if(): Running command because: Prerequisite is new: 'run_if_test_prerequisite'\n        pipcl.py:run_if(): Running: touch  run_if_test_out\n        True\n\n    If we repeat, the output will be newer than the prerequisite, so the\n    command is not run:\n\n        >>> run_if( f'touch  {out}', out, prerequisite)\n        pipcl.py:run_if(): Not running command because up to date: 'run_if_test_out'\n    '''\n    doit = False\n    cmd_path = f'{out}.cmd'\n\n    if not doit:\n        out_mtime = _fs_mtime( out)\n        if out_mtime == 0:\n            doit = f'File does not exist: {out!r}'\n\n    if not doit:\n        if os.path.isfile( cmd_path):\n            with open( cmd_path) as f:\n                cmd = f.read()\n        else:\n            cmd = None\n        if command != cmd:\n            if cmd is None:\n                doit = 'No previous command stored'\n            else:\n                doit = f'Command has changed'\n                if 0:\n                    doit += f': {cmd!r} => {command!r}'\n\n    if not doit:\n        # See whether any prerequisites are newer than target.\n        def _make_prerequisites(p):\n            if isinstance( p, (list, tuple)):\n                return list(p)\n            else:\n                return [p]\n        prerequisites_all = list()\n        for p in prerequisites:\n            prerequisites_all += _make_prerequisites( p)\n        if 0:\n            log2( 'prerequisites_all:')\n            for i in  prerequisites_all:\n                log2( f'    {i!r}')\n        pre_mtime = 0\n        pre_path = None\n        for prerequisite in prerequisites_all:\n            if isinstance( prerequisite, str):\n                mtime = _fs_mtime_newest( prerequisite)\n                if mtime >= pre_mtime:\n                    pre_mtime = mtime\n                    pre_path = prerequisite\n            elif prerequisite is None:\n                pass\n            elif prerequisite:\n                doit = str(prerequisite)\n                break\n        if not doit:\n            if pre_mtime > out_mtime:\n                doit = f'Prerequisite is new: {pre_path!r}'\n\n    if doit:\n        # Remove `cmd_path` before we run the command, so any failure\n        # will force rerun next time.\n        #\n        try:\n            os.remove( cmd_path)\n        except Exception:\n            pass\n        log1( f'Running command because: {doit}')\n\n        run( command)\n\n        # Write the command we ran, into `cmd_path`.\n        with open( cmd_path, 'w') as f:\n            f.write( command)\n        return True\n    else:\n        log1( f'Not running command because up to date: {out!r}')\n\n    if 0:\n        log2( f'out_mtime={time.ctime(out_mtime)} pre_mtime={time.ctime(pre_mtime)}.'\n                f' pre_path={pre_path!r}: returning {ret!r}.'\n                )\n\n\ndef _get_prerequisites(path):\n    '''\n    Returns list of prerequisites from Makefile-style dependency file, e.g.\n    created by `cc -MD -MF <path>`.\n    '''\n    ret = list()\n    if os.path.isfile(path):\n        with open(path) as f:\n            for line in f:\n                for item in line.split():\n                    if item.endswith( (':', '\\\\')):\n                        continue\n                    ret.append( item)\n    return ret\n\n\ndef _fs_mtime_newest( path):\n    '''\n    path:\n        If a file, returns mtime of the file. If a directory, returns mtime of\n        newest file anywhere within directory tree. Otherwise returns 0.\n    '''\n    ret = 0\n    if os.path.isdir( path):\n        for dirpath, dirnames, filenames in os.walk( path):\n            for filename in filenames:\n                path = os.path.join( dirpath, filename)\n                ret = max( ret, _fs_mtime( path))\n    else:\n        ret = _fs_mtime( path)\n    return ret\n\n\ndef _flags( items, prefix='', quote=''):\n    '''\n    Turns sequence into string, prefixing/quoting each item.\n    '''\n    if not items:\n        return ''\n    if isinstance( items, str):\n        items = items,\n    ret = ''\n    for item in items:\n        if ret:\n            ret += ' '\n        ret += f'{prefix}{quote}{item}{quote}'\n    return ret.strip()\n\n\ndef _fs_mtime( filename, default=0):\n    '''\n    Returns mtime of file, or `default` if error - e.g. doesn't exist.\n    '''\n    try:\n        return os.path.getmtime( filename)\n    except OSError:\n        return default\n\n\ndef _normalise(name):\n    # https://packaging.python.org/en/latest/specifications/name-normalization/#name-normalization\n    return re.sub(r\"[-_.]+\", \"-\", name).lower()\n\n\ndef _assert_version_pep_440(version):\n    assert re.match(\n                r'^([1-9][0-9]*!)?(0|[1-9][0-9]*)(\\.(0|[1-9][0-9]*))*((a|b|rc)(0|[1-9][0-9]*))?(\\.post(0|[1-9][0-9]*))?(\\.dev(0|[1-9][0-9]*))?$',\n                version,\n            ), \\\n            f'Bad version: {version!r}.'\n\n\ng_verbose = int(os.environ.get('PIPCL_VERBOSE', '1'))\n\ndef verbose(level=None):\n    '''\n    Sets verbose level if `level` is not None.\n    Returns verbose level.\n    '''\n    global g_verbose\n    if level is not None:\n        g_verbose = level\n    return g_verbose\n\ng_log_line_numbers = True\n\ndef log_line_numbers(yes):\n    '''\n    Sets whether to include line numbers; helps with doctest.\n    '''\n    global g_log_line_numbers\n    g_log_line_numbers = bool(yes)\n\ndef log0(text='', caller=1):\n    _log(text, 0, caller+1)\n\ndef log1(text='', caller=1):\n    _log(text, 1, caller+1)\n\ndef log2(text='', caller=1):\n    _log(text, 2, caller+1)\n\ndef _log(text, level, caller):\n    '''\n    Logs lines with prefix.\n    '''\n    if level <= g_verbose:\n        fr = inspect.stack(context=0)[caller]\n        filename = relpath(fr.filename)\n        for line in text.split('\\n'):\n            if g_log_line_numbers:\n                print(f'{filename}:{fr.lineno}:{fr.function}(): {line}', file=sys.stdout, flush=1)\n            else:\n                print(f'{filename}:{fr.function}(): {line}', file=sys.stdout, flush=1)\n\n\ndef relpath(path, start=None):\n    '''\n    A safe alternative to os.path.relpath(), avoiding an exception on Windows\n    if the drive needs to change - in this case we use os.path.abspath().\n    '''\n    if windows():\n        try:\n            return os.path.relpath(path, start)\n        except ValueError:\n            # os.path.relpath() fails if trying to change drives.\n            return os.path.abspath(path)\n    else:\n        return os.path.relpath(path, start)\n\n\ndef number_sep( s):\n    '''\n    Simple number formatter, adds commas in-between thousands. `s` can be a\n    number or a string. Returns a string.\n\n    >>> number_sep(1)\n    '1'\n    >>> number_sep(12)\n    '12'\n    >>> number_sep(123)\n    '123'\n    >>> number_sep(1234)\n    '1,234'\n    >>> number_sep(12345)\n    '12,345'\n    >>> number_sep(123456)\n    '123,456'\n    >>> number_sep(1234567)\n    '1,234,567'\n    >>> number_sep(-131072)\n    '-131,072'\n    '''\n    if not isinstance( s, str):\n        s = str( s)\n    ret = ''\n    if s.startswith('-'):\n        ret += '-'\n        s = s[1:]\n    c = s.find( '.')\n    if c==-1:   c = len(s)\n    end = s.find('e')\n    if end == -1:   end = s.find('E')\n    if end == -1:   end = len(s)\n    for i in range( end):\n        ret += s[i]\n        if i<c-1 and (c-i-1)%3==0:\n            ret += ','\n        elif i>c and i<end-1 and (i-c)%3==0:\n            ret += ','\n    ret += s[end:]\n    return ret\n\n\ndef _so_suffix(use_so_versioning=True):\n    '''\n    Filename suffix for shared libraries is defined in pep-3149.  The\n    pep claims to only address posix systems, but the recommended\n    sysconfig.get_config_var('EXT_SUFFIX') also seems to give the\n    right string on Windows.\n    \n    If use_so_versioning is false, we return only the last component of\n    the suffix, which removes any version number, for example changing\n    `.cp312-win_amd64.pyd` to `.pyd`.\n    '''\n    # Example values:\n    #   linux:      .cpython-311-x86_64-linux-gnu.so\n    #   macos:      .cpython-311-darwin.so\n    #   openbsd:    .cpython-310.so\n    #   windows     .cp311-win_amd64.pyd\n    #\n    # Only Linux and Windows seem to identify the cpu. For example shared\n    # libraries in numpy-1.25.2-cp311-cp311-macosx_11_0_arm64.whl are called\n    # things like `numpy/core/_simd.cpython-311-darwin.so`.\n    #\n    ret = sysconfig.get_config_var('EXT_SUFFIX')\n    if not use_so_versioning:\n        # Use last component only.\n        ret = os.path.splitext(ret)[1]\n    return ret\n\n\ndef get_soname(path):\n    '''\n    If we are on Linux and `path` is softlink and points to a shared library\n    for which `objdump -p` contains 'SONAME', return the pointee. Otherwise\n    return `path`. Useful if Linux shared libraries have been created with\n    `-Wl,-soname,...`, where we need to embed the versioned library.\n    '''\n    if linux() and os.path.islink(path):\n        path2 = os.path.realpath(path)\n        if subprocess.run(f'objdump -p {path2}|grep SONAME', shell=1, check=0).returncode == 0:\n            return path2\n    elif openbsd():\n        # Return newest .so with version suffix.\n        sos = glob.glob(f'{path}.*')\n        log1(f'{sos=}')\n        sos2 = list()\n        for so in sos:\n            suffix = so[len(path):]\n            if not suffix or re.match('^[.][0-9.]*[0-9]$', suffix):\n                sos2.append(so)\n        sos2.sort(key=lambda p: os.path.getmtime(p))\n        log1(f'{sos2=}')\n        return sos2[-1]\n    return path\n\n\ndef current_py_limited_api():\n    '''\n    Returns value of PyLIMITED_API to build for current Python.\n    '''\n    a, b = map(int, platform.python_version().split('.')[:2])\n    return f'0x{a:02x}{b:02x}0000'\n    \n\ndef install_dir(root=None):\n    '''\n    Returns install directory used by `install()`.\n\n    This will be `sysconfig.get_path('platlib')`, modified by `root` if not\n    None.\n    '''\n    # todo: for pure-python we should use sysconfig.get_path('purelib') ?\n    root2 = sysconfig.get_path('platlib')\n    if root:\n        if windows():\n            # If we are in a venv, `sysconfig.get_path('platlib')`\n            # can be absolute, e.g.\n            # `C:\\\\...\\\\venv-pypackage-3.11.1-64\\\\Lib\\\\site-packages`, so it's\n            # not clear how to append it to `root`. So we just use `root`.\n            return root\n        else:\n            # E.g. if `root` is `install' and `sysconfig.get_path('platlib')`\n            # is `/usr/local/lib/python3.9/site-packages`, we set `root2` to\n            # `install/usr/local/lib/python3.9/site-packages`.\n            #\n            return os.path.join( root, root2.lstrip( os.sep))\n    else:\n        return root2\n\n\nclass _Record:\n    '''\n    Internal - builds up text suitable for writing to a RECORD item, e.g.\n    within a wheel.\n    '''\n    def __init__(self):\n        self.text = ''\n\n    def add_content(self, content, to_, verbose=True):\n        if isinstance(content, str):\n            content = content.encode('utf8')\n\n        # Specification for the line we write is supposed to be in\n        # https://packaging.python.org/en/latest/specifications/binary-distribution-format\n        # but it's not very clear.\n        #\n        h = hashlib.sha256(content)\n        digest = h.digest()\n        digest = base64.urlsafe_b64encode(digest)\n        digest = digest.rstrip(b'=')\n        digest = digest.decode('utf8')\n\n        self.text += f'{to_},sha256={digest},{len(content)}\\n'\n        if verbose:\n            log2(f'Adding {to_}')\n\n    def add_file(self, from_, to_):\n        log1(f'Adding file: {os.path.relpath(from_)} => {to_}')\n        with open(from_, 'rb') as f:\n            content = f.read()\n        self.add_content(content, to_, verbose=False)\n\n    def get(self, record_path=None):\n        '''\n        Returns contents of the RECORD file. If `record_path` is\n        specified we append a final line `<record_path>,,`; this can be\n        used to include the RECORD file itself in the contents, with\n        empty hash and size fields.\n        '''\n        ret = self.text\n        if record_path:\n            ret += f'{record_path},,\\n'\n        return ret\n"
        },
        {
          "name": "pyproject.toml",
          "type": "blob",
          "size": 0.162109375,
          "content": "[build-system]\n# We define required packages in setup.py:get_requires_for_build_wheel().\nrequires = []\n\n# See pep-517.\n#\nbuild-backend = \"setup\"\nbackend-path = [\".\"]\n"
        },
        {
          "name": "pytest.ini",
          "type": "blob",
          "size": 0.04296875,
          "content": "[pytest]\npython_files =\n    tests/test_*.py\n"
        },
        {
          "name": "scripts",
          "type": "tree",
          "content": null
        },
        {
          "name": "setup.py",
          "type": "blob",
          "size": 48.34765625,
          "content": "#! /usr/bin/env python3\n\n'''\nOverview:\n\n    Build script for PyMuPDF, supporting PEP-517 and simple command-line usage.\n\n    We hard-code the URL of the MuPDF .tar.gz file that we require. This\n    generally points to a particular source release on mupdf.com.\n\n    Default behaviour:\n\n        Building an sdist:\n            As of 2024-002-28 we no longer download the MuPDF .tar.gz file and\n            embed it within the sdist. Instead it will be downloaded at build\n            time.\n\n        Building PyMuPDF:\n            We first download the hard-coded mupdf .tar.gz file.\n\n            Then we extract and build MuPDF locally, before building PyMuPDF\n            itself. So PyMuPDF will always be built with the exact MuPDF\n            release that we require.\n\n\nEnvironmental variables:\n\n    If building with system MuPDF (PYMUPDF_SETUP_MUPDF_BUILD is empty string):\n    \n        CFLAGS\n        CXXFLAGS\n        LDFLAGS\n            Added to c, c++, and link commands.\n        \n        PYMUPDF_INCLUDES\n            Colon-separated extra include paths.\n        \n        PYMUPDF_MUPDF_LIB\n            Directory containing MuPDF libraries, (libmupdf.so,\n            libmupdfcpp.so).\n    \n    PYMUPDF_SETUP_DEVENV\n        Location of devenv.com on Windows. If unset we search for it - see\n        wdev.py. if that fails we use just 'devenv.com'.\n\n    PYMUPDF_SETUP_FLAVOUR\n        Control building of separate wheels for PyMuPDF.\n        \n        Must be unset or a combination of 'p', 'b' and 'd'.\n        \n        Default is 'pbd'.\n        \n        'p':\n            Generated wheel contains PyMuPDF code.\n        'b':\n            Generated wheel contains MuPDF libraries; these are independent of\n            the Python version.\n        'd':\n            Generated wheel contains includes and libraries for MuPDF.\n        \n        If 'p' is included, the generated wheel is called PyMuPDF.\n        Otherwise if 'b' is included the generated wheel is called PyMuPDFb.\n        Otherwise if 'd' is included the generated wheel is called PyMuPDFd.\n        \n        For example:\n        \n            'pb': a `PyMuPDF` wheel with PyMuPDF runtime files and MuPDF\n            runtime shared libraries.\n            \n            'b': a `PyMuPDFb` wheel containing MuPDF runtime shared libraries.\n            \n            'pbd' a `PyMuPDF` wheel with PyMuPDF runtime files and MuPDF\n            runtime shared libraries, plus MuPDF build-time files (includes,\n            *.lib files on Windows).\n            \n            'd': a `PyMuPDFd` wheel containing MuPDF build-time files\n            (includes, *.lib files on Windows).\n    \n    PYMUPDF_SETUP_LIBCLANG\n        For internal testing.\n        \n    PYMUPDF_SETUP_MUPDF_BUILD\n        If unset or '-', use internal hard-coded default MuPDF location.\n        Otherwise overrides location of MuPDF when building PyMuPDF:\n            Empty string:\n                Build PyMuPDF with the system MuPDF.\n            A string starting with 'git:':\n                Use `git clone` to get a MuPDF checkout. We use the\n                string in the git clone command; it must contain the git\n                URL from which to clone, and can also contain other `git\n                clone` args, for example:\n                    PYMUPDF_SETUP_MUPDF_BUILD=\"git:--branch master https://github.com/ArtifexSoftware/mupdf.git\"\n            Otherwise:\n                Location of mupdf directory.\n    \n    PYMUPDF_SETUP_MUPDF_BSYMBOLIC\n        If '0' we do not link libmupdf.so with -Bsymbolic.\n    \n    PYMUPDF_SETUP_MUPDF_TESSERACT\n        If '0' we build MuPDF without Tesseract.\n    \n    PYMUPDF_SETUP_MUPDF_BUILD_TYPE\n        Unix only. Controls build type of MuPDF. Supported values are:\n            debug\n            memento\n            release (default)\n\n    PYMUPDF_SETUP_MUPDF_CLEAN\n        Unix only. If '1', we do a clean MuPDF build.\n\n    PYMUPDF_SETUP_MUPDF_REFCHECK_IF\n        Should be preprocessor statement to enable MuPDF reference count\n        checking.\n        \n        As of 2024-09-27, MuPDF default is `#ifndef NDEBUG`.\n\n    PYMUPDF_SETUP_MUPDF_TRACE_IF\n        Should be preprocessor statement to enable MuPDF runtime diagnostics in\n        response to environment variables such as MUPDF_trace.\n        \n        As of 2024-09-27, MuPDF default is `#ifndef NDEBUG`.\n\n    PYMUPDF_SETUP_MUPDF_THIRD\n        If '0' and we are building on Linux with the system MuPDF\n        (i.e. PYMUPDF_SETUP_MUPDF_BUILD=''), then don't link with\n        `-lmupdf-third`.\n    \n    PYMUPDF_SETUP_MUPDF_VS_UPGRADE\n        If '1' we run mupdf `scripts/mupdfwrap.py` with `--vs-upgrade 1` to\n        help Windows builds work with Visual Studio versions newer than 2019.\n\n    PYMUPDF_SETUP_MUPDF_TGZ\n        If set, overrides location of MuPDF .tar.gz file:\n            Empty string:\n                Do not download MuPDF .tar.gz file. Sdist's will not contain\n                MuPDF.\n\n            A string containing '://':\n                The URL from which to download the MuPDF .tar.gz file. Leaf\n                must match mupdf-*.tar.gz.\n\n            Otherwise:\n                The path of local mupdf git checkout. We put all files in this\n                checkout known to git into a local tar archive.\n\n    PYMUPDF_SETUP_MUPDF_OVERWRITE_CONFIG\n        If '0' we do not overwrite MuPDF's include/mupdf/fitz/config.h with\n        PyMuPDF's own configuration file, before building MuPDF.\n    \n    PYMUPDF_SETUP_MUPDF_REBUILD\n        If 0 we do not (re)build mupdf.\n    \n    PYMUPDF_SETUP_PY_LIMITED_API\n        If not '0', we build for current Python's stable ABI.\n    \n    PYMUPDF_SETUP_URL_WHEEL\n        If set, we use an existing wheel instead of building a new wheel.\n        \n        If starts with `http://` or `https://`:\n            If ends with '/', we append our wheel name and download. Otherwise\n            we download directly.\n        \n        If starts with `file://`:\n            If ends with '/' we look for a matching wheel name, `using\n            pipcl.wheel_name_match()` to cope with differing platform tags,\n            for example our `manylinux2014_x86_64` will match with an existing\n            wheel with `manylinux2014_x86_64.manylinux_2_17_x86_64`.\n        \n        Any other prefix is an error.\n\n    WDEV_VS_YEAR\n        If set, we use as Visual Studio year, for example '2019' or '2022'.\n\n    WDEV_VS_GRADE\n        If set, we use as Visual Studio grade, for example 'Community' or\n        'Professional' or 'Enterprise'.\n'''\n\nimport glob\nimport io\nimport os\nimport textwrap\nimport time\nimport platform\nimport re\nimport shlex\nimport shutil\nimport stat\nimport subprocess\nimport sys\nimport tarfile\nimport urllib.request\nimport zipfile\n\nimport pipcl\n\n\n_log_prefix = None\ndef log( text):\n    global _log_prefix\n    if not _log_prefix:\n        # This typically sets _log_prefix to `PyMuPDF/setup.py`.\n        p = os.path.abspath( __file__)\n        p, p1 = os.path.split( p)\n        p, p0 = os.path.split( p)\n        _log_prefix = os.path.join( p0, p1)\n    print(f'{_log_prefix}: {text}', file=sys.stdout)\n    sys.stdout.flush()\n\n\nif 1:\n    # For debugging.\n    log(f'### Starting.')\n    log(f'__name__: {__name__!r}')\n    log(f'platform.platform(): {platform.platform()!r}')\n    log(f'platform.python_version(): {platform.python_version()!r}')\n    log(f'sys.executable: {sys.executable!r}')\n    log(f'CPU bits: {32 if sys.maxsize == 2**31 - 1 else 64} {sys.maxsize=}')\n    log(f'__file__: {__file__!r}')\n    log(f'os.getcwd(): {os.getcwd()!r}')\n    log(f'sys.argv ({len(sys.argv)}):')\n    for i, arg in enumerate(sys.argv):\n        log(f'    {i}: {arg!r}')\n    log(f'os.environ ({len(os.environ)}):')\n    for k in sorted( os.environ.keys()):\n        v = os.environ[ k]\n        log( f'    {k}: {v!r}')\n\n\nPYMUPDF_SETUP_FLAVOUR = os.environ.get( 'PYMUPDF_SETUP_FLAVOUR', 'pbd')\nfor i in PYMUPDF_SETUP_FLAVOUR:\n    assert i in 'pbd', f'Unrecognised flag \"{i} in {PYMUPDF_SETUP_FLAVOUR=}. Should be one of \"p\", \"b\", \"d\"'\n\ng_root = os.path.abspath( f'{__file__}/..')\n\n# Name of file that identifies that we are in a PyMuPDF sdist.\ng_pymupdfb_sdist_marker = 'pymupdfb_sdist'\n\nPYMUPDF_SETUP_PY_LIMITED_API = os.environ.get('PYMUPDF_SETUP_PY_LIMITED_API')\nassert PYMUPDF_SETUP_PY_LIMITED_API in (None, '', '0', '1'), \\\n        f'Should be \"\", \"0\", \"1\" or undefined: {PYMUPDF_SETUP_PY_LIMITED_API=}.'\ng_py_limited_api = (PYMUPDF_SETUP_PY_LIMITED_API != '0')\n\nPYMUPDF_SETUP_URL_WHEEL =  os.environ.get('PYMUPDF_SETUP_URL_WHEEL')\nlog(f'{PYMUPDF_SETUP_URL_WHEEL=}')\n\ndef _fs_remove(path):\n    '''\n    Removes file or directory, without raising exception if it doesn't exist.\n\n    We assert-fail if the path still exists when we return, in case of\n    permission problems etc.\n    '''\n    # First try deleting `path` as a file.\n    try:\n        os.remove( path)\n    except Exception as e:\n        pass\n    \n    if os.path.exists(path):\n        # Try deleting `path` as a directory. Need to use\n        # shutil.rmtree() callback to handle permission problems; see:\n        # https://docs.python.org/3/library/shutil.html#rmtree-example\n        #\n        def error_fn(fn, path, excinfo):\n            # Clear the readonly bit and reattempt the removal.\n            os.chmod(path, stat.S_IWRITE)\n            fn(path)\n        shutil.rmtree( path, onerror=error_fn)\n    \n    assert not os.path.exists( path)\n\n\ndef run(command, check=1):\n    log(f'Running: {command}')\n    return subprocess.run( command, shell=1, check=check)\n\n\ndef _git_get_branch( directory):\n    command = f'cd {directory} && git branch --show-current'\n    log( f'Running: {command}')\n    p = subprocess.run(\n            command,\n            shell=True,\n            check=False,\n            text=True,\n            stdout=subprocess.PIPE,\n            )\n    ret = None\n    if p.returncode == 0:\n        ret = p.stdout.strip()\n        log( f'Have found MuPDF git branch: ret={ret!r}')\n    return ret\n\n\ndef tar_check(path, mode='r:gz', prefix=None, remove=False):\n    '''\n    Checks items in tar file have same <top-directory>, or <prefix> if not None.\n\n    We fail if items in tar file have different top-level directory names.\n\n    path:\n        The tar file.\n    mode:\n        As tarfile.open().\n    prefix:\n        If not None, we fail if tar file's <top-directory> is not <prefix>.\n    \n    Returns the directory name (which will be <prefix> if not None).\n    '''\n    with tarfile.open( path, mode) as t:\n        items = t.getnames()\n        assert items\n        item = items[0]\n        assert not item.startswith('./') and not item.startswith('../')\n        s = item.find('/')\n        if s == -1:\n            prefix_actual = item + '/'\n        else:\n            prefix_actual = item[:s+1]\n        if prefix:\n            assert prefix == prefix_actual, f'{path=} {prefix=} {prefix_actual=}'\n        for item in items[1:]:\n            assert item.startswith( prefix_actual), f'prefix_actual={prefix_actual!r} != item={item!r}'\n    return prefix_actual\n\n\ndef tar_extract(path, mode='r:gz', prefix=None, exists='raise'):\n    '''\n    Extracts tar file into single local directory.\n    \n    We fail if items in tar file have different <top-directory>.\n\n    path:\n        The tar file.\n    mode:\n        As tarfile.open().\n    prefix:\n        If not None, we fail if tar file's <top-directory> is not <prefix>.\n    exists:\n        What to do if <top-directory> already exists:\n            'raise': raise exception.\n            'remove': remove existing file/directory before extracting.\n            'return': return without extracting.\n    \n    Returns the directory name (which will be <prefix> if not None, with '/'\n    appended if not already present).\n    '''\n    prefix_actual = tar_check( path, mode, prefix)\n    if os.path.exists( prefix_actual):\n        if exists == 'raise':\n            raise Exception( f'Path already exists: {prefix_actual!r}')\n        elif exists == 'remove':\n            remove( prefix_actual)\n        elif exists == 'return':\n            log( f'Not extracting {path} because already exists: {prefix_actual}')\n            return prefix_actual\n        else:\n            assert 0, f'Unrecognised exists={exists!r}'\n    assert not os.path.exists( prefix_actual), f'Path already exists: {prefix_actual}'\n    log( f'Extracting {path}')\n    with tarfile.open( path, mode) as t:\n        t.extractall()\n    return prefix_actual\n\n\ndef get_git_id( directory):\n    '''\n    Returns `(sha, comment, diff, branch)`, all items are str or None if not\n    available.\n\n    directory:\n        Root of git checkout.\n    '''\n    sha, comment, diff, branch = '', '', '', ''\n    cp = subprocess.run(\n            f'cd {directory} && (PAGER= git show --pretty=oneline|head -n 1 && git diff)',\n            capture_output=1,\n            shell=1,\n            text=1,\n            )\n    if cp.returncode == 0:\n        sha, _ = cp.stdout.split(' ', 1)\n        comment, diff = _.split('\\n', 1)\n    cp = subprocess.run(\n            f'cd {directory} && git rev-parse --abbrev-ref HEAD',\n            capture_output=1,\n            shell=1,\n            text=1,\n            )\n    if cp.returncode == 0:\n        branch = cp.stdout.strip()\n    log(f'get_git_id(): directory={directory!r} returning branch={branch!r} sha={sha!r} comment={comment!r}')\n    return sha, comment, diff, branch\n\n\nmupdf_tgz = os.path.abspath( f'{__file__}/../mupdf.tgz')\n\ndef get_mupdf_internal(out, location=None, sha=None, local_tgz=None):\n    '''\n    Gets MuPDF as either a .tgz or a local directory.\n    \n    Args:\n        out:\n            Either 'dir' (we return name of local directory containing mupdf) or 'tgz' (we return\n            name of local .tgz file containing mupdf).\n        location:\n            First, if None we set to hard-coded default URL or git location.\n            If starts with 'git:', should be remote git location.\n            Otherwise if containing '://' should be URL for .tgz.\n            Otherwise should path of local mupdf checkout.\n        sha:\n            If not None and we use git clone, we checkout this sha.\n        local_tgz:\n            If not None, must be local .tgz file.\n    Returns:\n        (path, location):\n            `path` is absolute path of local directory or .tgz containing\n            MuPDF, or None if we are to use system MuPDF.\n\n            `location_out` is `location` if not None, else the hard-coded\n            default location.\n                \n    '''\n    log(f'get_mupdf_internal(): {out=} {location=} {sha=}')\n    assert out in ('dir', 'tgz')\n    if location is None:\n        location = f'https://mupdf.com/downloads/archive/mupdf-{version_mupdf}-source.tar.gz'\n        #location = 'git:--branch master https://github.com/ArtifexSoftware/mupdf.git'\n    \n    if location == '':\n        # Use system mupdf.\n        return None, location\n    \n    local_dir = None\n    if local_tgz:\n        assert os.path.isfile(local_tgz)\n    elif location.startswith( 'git:'):\n        location_git = location[4:]\n        local_dir = 'mupdf-git'\n        \n        # Try to update existing checkout.\n        e = run(f'cd {local_dir} && git pull && git submodule update --init', check=False).returncode\n        if e:\n            # No existing git checkout, so do a fresh clone.\n            _fs_remove(local_dir)\n            run(f'git clone --recursive --depth 1 --shallow-submodules {location[4:]} {local_dir}')\n\n        # Show sha of checkout.\n        run( f'cd {local_dir} && git show --pretty=oneline|head -n 1', check=False)\n        if sha:\n            run( f'cd {local_dir} && git checkout {sha}')\n    elif '://' in location:\n        # Download .tgz.\n        local_tgz = os.path.basename( location)\n        suffix = '.tar.gz'\n        assert location.endswith(suffix), f'Unrecognised suffix in remote URL {location=}.'\n        name = local_tgz[:-len(suffix)]\n        log( f'Download {location=} {local_tgz=} {name=}')\n        if os.path.exists(local_tgz):\n            try:\n                tar_check(local_tgz, 'r:gz', prefix=f'{name}/')\n            except Exception as e:\n                log(f'Not using existing file {local_tgz} because invalid tar data: {e}')\n                _fs_remove( local_tgz)\n        if os.path.exists(local_tgz):\n            log(f'Not downloading from {location} because already present: {local_tgz!r}')\n        else:\n            log(f'Downloading from {location=} to {local_tgz=}.')\n            urllib.request.urlretrieve( location, local_tgz + '-')\n            os.rename(local_tgz + '-', local_tgz)\n            assert os.path.exists( local_tgz)\n            tar_check( local_tgz, 'r:gz', prefix=f'{name}/')\n    else:\n        assert os.path.isdir(location), f'Local MuPDF does not exist: {location=}'\n        local_dir = location\n    \n    assert bool(local_dir) != bool(local_tgz)\n    if out == 'dir':\n        if not local_dir:\n            assert local_tgz\n            local_dir = tar_extract( local_tgz, exists='return')\n        return os.path.abspath( local_dir), location\n    elif out == 'tgz':\n        if not local_tgz:\n            # Create .tgz containing git files in `local_dir`.\n            assert local_dir\n            if local_dir.endswith( '/'):\n                local_dir = local_dir[:-1]\n            top = os.path.basename(local_dir)\n            local_tgz = f'{local_dir}.tgz'\n            log( f'Creating .tgz from git files. {top=} {local_dir=} {local_tgz=}')\n            _fs_remove( local_tgz)\n            with tarfile.open( local_tgz, 'w:gz') as f:\n                for name in pipcl.git_items( local_dir, submodules=True):\n                    path = os.path.join( local_dir, name)\n                    if os.path.isfile( path):\n                        path2 = f'{top}/{name}'\n                        log(f'Adding {path=} {path2=}.')\n                        f.add( path, path2, recursive=False)\n        return os.path.abspath( local_tgz), location\n    else:\n        assert 0, f'Unrecognised {out=}'\n            \n        \n\ndef get_mupdf_tgz():\n    '''\n    Creates .tgz file called containing MuPDF source, for inclusion in an\n    sdist.\n    \n    What we do depends on environmental variable PYMUPDF_SETUP_MUPDF_TGZ; see\n    docs at start of this file for details.\n\n    Returns name of top-level directory within the .tgz file.\n    '''\n    name, location = get_mupdf_internal( 'tgz', os.environ.get('PYMUPDF_SETUP_MUPDF_TGZ'))\n    return name, location\n\n\ndef get_mupdf(path=None, sha=None):\n    '''\n    Downloads and/or extracts mupdf and returns (path, location) where `path`\n    is the local mupdf directory and `location` is where it came from.\n\n    Exact behaviour depends on environmental variable\n    PYMUPDF_SETUP_MUPDF_BUILD; see docs at start of this file for details.\n    '''\n    m = os.environ.get('PYMUPDF_SETUP_MUPDF_BUILD')\n    if m == '-':\n        # This allows easy specification in Github actions.\n        m = None\n    if m is None and os.path.isfile(mupdf_tgz):\n        # This makes us use tgz inside sdist.\n        log(f'Using local tgz: {mupdf_tgz=}')\n        return get_mupdf_internal('dir', local_tgz=mupdf_tgz)\n    return get_mupdf_internal('dir', m)\n\n\nlinux = sys.platform.startswith( 'linux') or 'gnu' in sys.platform\nopenbsd = sys.platform.startswith( 'openbsd')\nfreebsd = sys.platform.startswith( 'freebsd')\ndarwin = sys.platform.startswith( 'darwin')\nwindows = platform.system() == 'Windows' or platform.system().startswith('CYGWIN')\nmsys2 = platform.system().startswith('MSYS_NT-')\npyodide = os.environ.get('OS') == 'pyodide'\n\n\ndef build():\n    '''\n    pipcl.py `build_fn()` callback.\n    '''\n    # Download MuPDF.\n    #\n    mupdf_local, mupdf_location = get_mupdf()\n    if mupdf_local:\n        mupdf_version_tuple = get_mupdf_version(mupdf_local)\n    # else we cannot determine version this way and do not use it\n\n    build_type = os.environ.get( 'PYMUPDF_SETUP_MUPDF_BUILD_TYPE', 'release')\n    assert build_type in ('debug', 'memento', 'release'), \\\n            f'Unrecognised build_type={build_type!r}'\n    \n    overwrite_config = os.environ.get('PYMUPDF_SETUP_MUPDF_OVERWRITE_CONFIG', '1') == '1'\n    \n    PYMUPDF_SETUP_MUPDF_REFCHECK_IF = os.environ.get('PYMUPDF_SETUP_MUPDF_REFCHECK_IF')\n    PYMUPDF_SETUP_MUPDF_TRACE_IF = os.environ.get('PYMUPDF_SETUP_MUPDF_TRACE_IF')\n    \n    # Build MuPDF shared libraries.\n    #\n    if windows:\n        mupdf_build_dir = build_mupdf_windows(\n                mupdf_local,\n                build_type,\n                overwrite_config,\n                g_py_limited_api,\n                PYMUPDF_SETUP_MUPDF_REFCHECK_IF,\n                PYMUPDF_SETUP_MUPDF_TRACE_IF,\n                )\n    else:\n        if 'p' not in PYMUPDF_SETUP_FLAVOUR and 'b' not in PYMUPDF_SETUP_FLAVOUR:\n            # We only need MuPDF headers, so no point building MuPDF.\n            log(f'Not building MuPDF because not Windows and {PYMUPDF_SETUP_FLAVOUR=}.')\n            mupdf_build_dir = None\n        else:\n            mupdf_build_dir = build_mupdf_unix(\n                    mupdf_local,\n                    build_type,\n                    overwrite_config,\n                    g_py_limited_api,\n                    PYMUPDF_SETUP_MUPDF_REFCHECK_IF,\n                    PYMUPDF_SETUP_MUPDF_TRACE_IF,\n                    )\n    log( f'build(): mupdf_build_dir={mupdf_build_dir!r}')\n    \n    # Build rebased `extra` module.\n    #\n    if 'p' in PYMUPDF_SETUP_FLAVOUR:\n        path_so_leaf = _build_extension(\n                mupdf_local,\n                mupdf_build_dir,\n                build_type,\n                g_py_limited_api,\n                )\n    else:\n        log(f'Not building extension.')\n        path_so_leaf = None\n    \n    # Generate list of (from, to) items to return to pipcl. What we add depends\n    # on PYMUPDF_SETUP_FLAVOUR.\n    #\n    ret = list()    \n    def add(flavour, from_, to_):\n        assert flavour in 'pbd'\n        if flavour in PYMUPDF_SETUP_FLAVOUR:\n            ret.append((from_, to_))\n    \n    to_dir = 'pymupdf/'\n    to_dir_d = f'{to_dir}/mupdf-devel'\n    \n    # Add implementation files.\n    add('p', f'{g_root}/src/__init__.py', to_dir)\n    add('p', f'{g_root}/src/__main__.py', to_dir)\n    add('p', f'{g_root}/src/pymupdf.py', to_dir)\n    add('p', f'{g_root}/src/table.py', to_dir)\n    add('p', f'{g_root}/src/utils.py', to_dir)\n    add('p', f'{g_root}/src/_apply_pages.py', to_dir)\n    add('p', f'{g_root}/src/build/extra.py', to_dir)\n    if path_so_leaf:\n        add('p', f'{g_root}/src/build/{path_so_leaf}', to_dir)\n\n    # Add support for `fitz` backwards compatibility.\n    add('p', f'{g_root}/src/fitz___init__.py', 'fitz/__init__.py')\n    add('p', f'{g_root}/src/fitz_table.py', 'fitz/table.py')\n    add('p', f'{g_root}/src/fitz_utils.py', 'fitz/utils.py')\n\n    if mupdf_local:\n        # Add MuPDF Python API.\n        add('p', f'{mupdf_build_dir}/mupdf.py', to_dir)\n\n        # Add MuPDF shared libraries.\n        if windows:\n            wp = pipcl.wdev.WindowsPython()\n            add('p', f'{mupdf_build_dir}/_mupdf.pyd', to_dir)\n            add('b', f'{mupdf_build_dir}/mupdfcpp{wp.cpu.windows_suffix}.dll', to_dir)\n\n            # Add Windows .lib files.\n            mupdf_build_dir2 = _windows_lib_directory(mupdf_local, build_type)\n            add('d', f'{mupdf_build_dir2}/mupdfcpp{wp.cpu.windows_suffix}.lib', f'{to_dir_d}/lib/')\n            if mupdf_version_tuple >= (1, 26):\n                # MuPDF-1.25+ language bindings build also builds libmuthreads.\n                add('d', f'{mupdf_build_dir2}/libmuthreads.lib', f'{to_dir_d}/lib/')\n        elif darwin:\n            add('p', f'{mupdf_build_dir}/_mupdf.so', to_dir)\n            add('b', f'{mupdf_build_dir}/libmupdfcpp.so', to_dir)\n            add('b', f'{mupdf_build_dir}/libmupdf.dylib', to_dir)\n            if mupdf_version_tuple >= (1, 25):\n                # MuPDF-1.25+ language bindings build also builds\n                # libmupdf-threads.a.\n                add('d', f'{mupdf_build_dir}/libmupdf-threads.a', f'{to_dir_d}/lib/')\n        elif pyodide:\n            add('p', f'{mupdf_build_dir}/_mupdf.so', to_dir)\n            add('b', f'{mupdf_build_dir}/libmupdfcpp.so', 'PyMuPDF.libs/')\n            add('b', f'{mupdf_build_dir}/libmupdf.so', 'PyMuPDF.libs/')\n        else:\n            add('p', f'{mupdf_build_dir}/_mupdf.so', to_dir)\n            add('b', pipcl.get_soname(f'{mupdf_build_dir}/libmupdfcpp.so'), to_dir)\n            add('b', pipcl.get_soname(f'{mupdf_build_dir}/libmupdf.so'), to_dir)\n            if mupdf_version_tuple >= (1, 25):\n                # MuPDF-1.25+ language bindings build also builds\n                # libmupdf-threads.a.\n                add('d', f'{mupdf_build_dir}/libmupdf-threads.a', f'{to_dir_d}/lib/')\n\n        if 'd' in PYMUPDF_SETUP_FLAVOUR:\n            # Add MuPDF C and C++ headers to `ret_d`. Would prefer to use\n            # pipcl.git_items() but hard-coded mupdf tree is not a git\n            # checkout.\n            #\n            for root in (\n                    f'{mupdf_local}/include',\n                    f'{mupdf_local}/platform/c++/include',\n                    ):\n                for dirpath, dirnames, filenames in os.walk(root):\n                    for filename in filenames:\n                        if not filename.endswith('.h'):\n                            continue\n                        header_abs = os.path.join(dirpath, filename)\n                        assert header_abs.startswith(root)\n                        header_rel = header_abs[len(root)+1:]\n                        add('d', f'{header_abs}', f'{to_dir_d}/include/{header_rel}')\n    \n    # Add a .py file containing location of MuPDF.\n    text = f\"mupdf_location='{mupdf_location}'\\n\"\n    add('p', text.encode(), f'{to_dir}/_build.py')\n    \n    # Add single README file.\n    if 'p' in PYMUPDF_SETUP_FLAVOUR:\n        add('p', f'{g_root}/README.md', '$dist-info/README.md')\n    elif 'b' in PYMUPDF_SETUP_FLAVOUR:\n        add('b', f'{g_root}/READMEb.md', '$dist-info/README.md')\n    elif 'd' in PYMUPDF_SETUP_FLAVOUR:\n        add('d', f'{g_root}/READMEd.md', '$dist-info/README.md')\n    \n    return ret\n\n\ndef env_add(env, name, value, sep=' ', prepend=False, verbose=False):\n    '''\n    Appends/prepends `<value>` to `env[name]`.\n    \n    If `name` is not in `env`, we use os.environ[name] if it exists.\n    '''\n    v = env.get(name)\n    if verbose:\n        log(f'Initally: {name}={v!r}')\n    if v is None:\n        v = os.environ.get(name)\n    if v is None:\n        env[ name] = value\n    else:\n        if prepend:\n            env[ name] =  f'{value}{sep}{v}'\n        else:\n            env[ name] =  f'{v}{sep}{value}'\n    if verbose:\n        log(f'Returning with {name}={env[name]!r}')\n\n\ndef build_mupdf_windows(\n        mupdf_local,\n        build_type,\n        overwrite_config,\n        g_py_limited_api,\n        PYMUPDF_SETUP_MUPDF_REFCHECK_IF,\n        PYMUPDF_SETUP_MUPDF_TRACE_IF,\n        ):\n    \n    assert mupdf_local\n\n    if overwrite_config:\n        mupdf_config_h = f'{mupdf_local}/include/mupdf/fitz/config.h'\n        prefix = '#define TOFU_CJK_EXT 1 /* PyMuPDF override. */\\n'\n        with open(mupdf_config_h) as f:\n            text = f.read()\n        if text.startswith(prefix):\n            print(f'Not modifying {mupdf_config_h} because already has prefix {prefix!r}.')\n        else:\n            print(f'Prefixing {mupdf_config_h} with {prefix!r}.')\n            text = prefix + text\n            st = os.stat(mupdf_config_h)\n            with open(mupdf_config_h, 'w') as f:\n                f.write(text)\n            os.utime(mupdf_config_h, (st.st_atime, st.st_mtime))\n        \n    wp = pipcl.wdev.WindowsPython()\n    tesseract = '' if os.environ.get('PYMUPDF_SETUP_MUPDF_TESSERACT') == '0' else 'tesseract-'\n    windows_build_tail = f'build\\\\shared-{tesseract}{build_type}'\n    if g_py_limited_api:\n        if get_mupdf_version(mupdf_local) >= (1, 24, 11):\n            windows_build_tail += f'-Py_LIMITED_API_{pipcl.current_py_limited_api()}'\n        else:\n            windows_build_tail += f'-Py_LIMITED_API={pipcl.current_py_limited_api()}'\n    windows_build_tail += f'-x{wp.cpu.bits}-py{wp.version}'\n    windows_build_dir = f'{mupdf_local}\\\\{windows_build_tail}'\n    #log( f'Building mupdf.')\n    devenv = os.environ.get('PYMUPDF_SETUP_DEVENV')\n    if not devenv:\n        vs = pipcl.wdev.WindowsVS()\n        devenv = vs.devenv\n    if not devenv:\n        devenv = 'devenv.com'\n        log( f'Cannot find devenv.com in default locations, using: {devenv!r}')\n    command = f'cd \"{mupdf_local}\" && \"{sys.executable}\" ./scripts/mupdfwrap.py'\n    if os.environ.get('PYMUPDF_SETUP_MUPDF_VS_UPGRADE') == '1':\n        command += ' --vs-upgrade 1'\n        \n    # Would like to simply do f'... --devenv {shutil.quote(devenv)}', but\n    # it looks like if `devenv` has spaces then `shutil.quote()` puts it\n    # inside single quotes, which then appear to be ignored when run by\n    # subprocess.run().\n    #\n    # So instead we strip any enclosing quotes and the enclose with\n    # double-quotes.\n    #\n    if len(devenv) >= 2:\n        for q in '\"', \"'\":\n            if devenv.startswith( q) and devenv.endswith( q):\n                devenv = devenv[1:-1]\n    command += f' -d {windows_build_tail}'\n    command += f' -b'\n    if PYMUPDF_SETUP_MUPDF_REFCHECK_IF:\n        command += f' --refcheck-if \"{PYMUPDF_SETUP_MUPDF_REFCHECK_IF}\"'\n    if PYMUPDF_SETUP_MUPDF_TRACE_IF:\n        command += f' --trace-if \"{PYMUPDF_SETUP_MUPDF_TRACE_IF}\"'\n    command += f' --devenv \"{devenv}\"'\n    command += f' all'\n    if os.environ.get( 'PYMUPDF_SETUP_MUPDF_REBUILD') == '0':\n        log( f'PYMUPDF_SETUP_MUPDF_REBUILD is \"0\" so not building MuPDF; would have run: {command}')\n    else:\n        log( f'Building MuPDF by running: {command}')\n        subprocess.run( command, shell=True, check=True)\n        log( f'Finished building mupdf.')\n    \n    return windows_build_dir\n\n\ndef _windows_lib_directory(mupdf_local, build_type):\n    ret = f'{mupdf_local}/platform/win32/'\n    if _cpu_bits() == 64:\n        ret += 'x64/'\n    if build_type == 'release':\n        ret += 'Release/'\n    elif build_type == 'debug':\n        ret += 'Debug/'\n    else:\n        assert 0, f'Unrecognised {build_type=}.'\n    return ret\n\n\ndef _cpu_bits():\n    if sys.maxsize == 2**31 - 1:\n        return 32\n    return 64\n\n\ndef build_mupdf_unix(\n        mupdf_local,\n        build_type,\n        overwrite_config,\n        g_py_limited_api,\n        PYMUPDF_SETUP_MUPDF_REFCHECK_IF,\n        PYMUPDF_SETUP_MUPDF_TRACE_IF,\n        ):\n    '''\n    Builds MuPDF.\n\n    Args:\n        mupdf_local:\n            Path of MuPDF directory or None if we are using system MuPDF.\n    \n    Returns the absolute path of build directory within MuPDF, e.g.\n    `.../mupdf/build/pymupdf-shared-release`, or `None` if we are using the\n    system MuPDF.\n    '''    \n    if not mupdf_local:\n        log( f'Using system mupdf.')\n        return None\n\n    env = dict()\n    if overwrite_config:\n        # By predefining TOFU_CJK_EXT here, we don't need to modify\n        # MuPDF's include/mupdf/fitz/config.h.\n        log( f'Setting XCFLAGS and XCXXFLAGS to predefine TOFU_CJK_EXT.')\n        env_add(env, 'XCFLAGS', '-DTOFU_CJK_EXT')\n        env_add(env, 'XCXXFLAGS', '-DTOFU_CJK_EXT')\n\n    if openbsd or freebsd:\n        env_add(env, 'CXX', 'c++', ' ')\n\n    # Add extra flags for MacOS cross-compilation, where ARCHFLAGS can be\n    # '-arch arm64'.\n    #\n    archflags = os.environ.get( 'ARCHFLAGS')\n    if archflags:\n        env_add(env, 'XCFLAGS', archflags)\n        env_add(env, 'XLIBS', archflags)\n\n    # We specify a build directory path containing 'pymupdf' so that we\n    # coexist with non-PyMuPDF builds (because PyMuPDF builds have a\n    # different config.h).\n    #\n    # We also append further text to try to allow different builds to\n    # work if they reuse the mupdf directory.\n    #\n    # Using platform.machine() (e.g. 'amd64') ensures that different\n    # builds of mupdf on a shared filesystem can coexist. Using\n    # $_PYTHON_HOST_PLATFORM allows cross-compiled cibuildwheel builds\n    # to coexist, e.g. on github.\n    #\n    build_prefix = f'PyMuPDF-'\n    if pyodide:\n        build_prefix += 'pyodide-'\n    else:\n        build_prefix += f'{platform.machine()}-'\n    build_prefix_extra = os.environ.get( '_PYTHON_HOST_PLATFORM')\n    if build_prefix_extra:\n        build_prefix += f'{build_prefix_extra}-'\n    build_prefix += 'shared-'\n    if msys2:\n        # Error in mupdf/scripts/tesseract/endianness.h:\n        # #error \"I don't know what architecture this is!\"\n        log(f'msys2: building MuPDF without tesseract.')\n    elif os.environ.get('PYMUPDF_SETUP_MUPDF_TESSERACT') == '0':\n        log(f'PYMUPDF_SETUP_MUPDF_TESSERACT=0 so building mupdf without tesseract.')\n    else:\n        build_prefix += 'tesseract-'\n    mupdf_version_tuple = get_mupdf_version(mupdf_local)\n    if (\n            linux\n            and os.environ.get('PYMUPDF_SETUP_MUPDF_BSYMBOLIC', '1') == '1'\n            and mupdf_version_tuple >= (1, 24, 3)\n            ):\n        log(f'Appending `bsymbolic-` to MuPDF build path.')\n        build_prefix += 'bsymbolic-'\n    log(f'{g_py_limited_api=}')\n    if g_py_limited_api:\n        if get_mupdf_version(mupdf_local) >= (1, 24, 11):\n            build_prefix += f'Py_LIMITED_API_{pipcl.current_py_limited_api()}-'\n        else:\n            build_prefix += f'Py_LIMITED_API={pipcl.current_py_limited_api()}-'\n    unix_build_dir = f'{mupdf_local}/build/{build_prefix}{build_type}'\n    # We need MuPDF's Python bindings, so we build MuPDF with\n    # `mupdf/scripts/mupdfwrap.py` instead of running `make`.\n    #\n    command = f'cd {mupdf_local} &&'\n    for n, v in env.items():\n        command += f' {n}={shlex.quote(v)}'\n    command += f' {sys.executable} ./scripts/mupdfwrap.py -d build/{build_prefix}{build_type} -b'\n    #command += f' --m-target libs'\n    if PYMUPDF_SETUP_MUPDF_REFCHECK_IF:\n        command += f' --refcheck-if \"{PYMUPDF_SETUP_MUPDF_REFCHECK_IF}\"'\n    if PYMUPDF_SETUP_MUPDF_TRACE_IF:\n        command += f' --trace-if \"{PYMUPDF_SETUP_MUPDF_TRACE_IF}\"'\n    if 'p' in PYMUPDF_SETUP_FLAVOUR:\n        command += ' all'\n    else:\n        command += ' m01'    # No need for C++/Python bindings.\n    command += f' && echo {unix_build_dir}:'\n    command += f' && ls -l {unix_build_dir}'\n\n    if os.environ.get( 'PYMUPDF_SETUP_MUPDF_REBUILD') == '0':\n        log( f'PYMUPDF_SETUP_MUPDF_REBUILD is \"0\" so not building MuPDF; would have run: {command}')\n    else:\n        log( f'Building MuPDF by running: {command}')\n        subprocess.run( command, shell=True, check=True)\n        log( f'Finished building mupdf.')\n    \n    return unix_build_dir\n\n\ndef get_mupdf_version(mupdf_dir):\n    path = f'{mupdf_dir}/include/mupdf/fitz/version.h'\n    with open(path) as f:\n        text = f.read()\n    v0 = re.search('#define FZ_VERSION_MAJOR ([0-9]+)', text)\n    v1 = re.search('#define FZ_VERSION_MINOR ([0-9]+)', text)\n    v2 = re.search('#define FZ_VERSION_PATCH ([0-9]+)', text)\n    assert v0 and v1 and v2, f'Cannot find MuPDF version numbers in {path=}.'\n    v0 = int(v0.group(1))\n    v1 = int(v1.group(1))\n    v2 = int(v2.group(1))\n    return v0, v1, v2\n\ndef _fs_update(text, path):\n    try:\n        with open( path) as f:\n            text0 = f.read()\n    except OSError:\n        text0 = None\n    print(f'path={path!r} text==text0={text==text0!r}')\n    if text != text0:\n        with open( path, 'w') as f:\n            f.write( text)\n    \n\ndef _build_extension( mupdf_local, mupdf_build_dir, build_type, g_py_limited_api):\n    '''\n    Builds Python extension module `_extra`.\n\n    Returns leafname of the generated shared libraries within mupdf_build_dir.\n    '''\n    (compiler_extra, linker_extra, includes, defines, optimise, debug, libpaths, libs, libraries) \\\n        = _extension_flags( mupdf_local, mupdf_build_dir, build_type)\n    log(f'_build_extension(): {g_py_limited_api=} {defines=}')\n    if mupdf_local:\n        includes = (\n                f'{mupdf_local}/platform/c++/include',\n                f'{mupdf_local}/include',\n                )\n    \n    # Build rebased extension module.\n    log('Building PyMuPDF rebased.')\n    compile_extra_cpp = ''\n    if darwin:\n        # Avoids `error: cannot pass object of non-POD type\n        # 'std::nullptr_t' through variadic function; call will abort at\n        # runtime` when compiling `mupdf::pdf_dict_getl(..., nullptr)`.\n        compile_extra_cpp += ' -Wno-non-pod-varargs'\n        # Avoid errors caused by mupdf's C++ bindings' exception classes\n        # not having `nothrow` to match the base exception class.\n        compile_extra_cpp += ' -std=c++14'\n    if windows:\n        wp = pipcl.wdev.WindowsPython()\n        libs = f'mupdfcpp{wp.cpu.windows_suffix}.lib'\n    else:\n        libs = ('mupdf', 'mupdfcpp')\n        libraries = [\n                f'{mupdf_build_dir}/libmupdf.so'\n                f'{mupdf_build_dir}/libmupdfcpp.so'\n                ]\n    \n    path_so_leaf = pipcl.build_extension(\n            name = 'extra',\n            path_i = f'{g_root}/src/extra.i',\n            outdir = f'{g_root}/src/build',\n            includes = includes,\n            defines = defines,\n            libpaths = libpaths,\n            libs = libs,\n            compiler_extra = compiler_extra + compile_extra_cpp,\n            linker_extra = linker_extra,\n            optimise = optimise,\n            debug = debug,\n            prerequisites_swig = None,\n            prerequisites_compile = f'{mupdf_local}/include',\n            prerequisites_link = libraries,\n            py_limited_api = g_py_limited_api,\n            )\n    \n    return path_so_leaf\n\n\ndef _extension_flags( mupdf_local, mupdf_build_dir, build_type):\n    '''\n    Returns various flags to pass to pipcl.build_extension().\n    '''\n    compiler_extra = ''\n    linker_extra = ''\n    if build_type == 'memento':\n        compiler_extra += ' -DMEMENTO'\n    if mupdf_build_dir:\n        mupdf_build_dir_flags = os.path.basename( mupdf_build_dir).split( '-')\n    else:\n        mupdf_build_dir_flags = [build_type]\n    optimise = 'release' in mupdf_build_dir_flags\n    debug = 'debug' in mupdf_build_dir_flags\n    r_extra = ''\n    defines = list()\n    if windows:\n        defines.append('FZ_DLL_CLIENT')\n        wp = pipcl.wdev.WindowsPython()\n        if os.environ.get('PYMUPDF_SETUP_MUPDF_VS_UPGRADE') == '1':\n            # MuPDF C++ build uses a parallel build tree with updated VS files.\n            infix = 'win32-vs-upgrade'\n        else:\n            infix = 'win32'\n        build_type_infix = 'Debug' if debug else 'Release'\n        libpaths = (\n                f'{mupdf_local}\\\\platform\\\\{infix}\\\\{wp.cpu.windows_subdir}{build_type_infix}',\n                f'{mupdf_local}\\\\platform\\\\{infix}\\\\{wp.cpu.windows_subdir}{build_type_infix}Tesseract',\n                )\n        libs = f'mupdfcpp{wp.cpu.windows_suffix}.lib'\n        libraries = f'{mupdf_local}\\\\platform\\\\{infix}\\\\{wp.cpu.windows_subdir}{build_type_infix}\\\\{libs}'\n        compiler_extra = ''\n    else:\n        libs = ['mupdf']\n        compiler_extra += (\n                ' -Wall'\n                ' -Wno-deprecated-declarations'\n                ' -Wno-unused-const-variable'\n                )\n        if mupdf_local:\n            libpaths = (mupdf_build_dir,)\n            libraries = f'{mupdf_build_dir}/{libs[0]}'\n            if openbsd:\n                compiler_extra += ' -Wno-deprecated-declarations'\n        else:\n            libpaths = os.environ.get('PYMUPDF_MUPDF_LIB')\n            libraries = None\n            if libpaths:\n                libpaths = libpaths.split(':')\n    \n    if mupdf_local:\n        includes = (\n                f'{mupdf_local}/include',\n                f'{mupdf_local}/include/mupdf',\n                f'{mupdf_local}/thirdparty/freetype/include',\n                )\n    else:\n        # Use system MuPDF.\n        includes = list()\n        pi = os.environ.get('PYMUPDF_INCLUDES')\n        if pi:\n            includes += pi.split(':')\n        pmi = os.environ.get('PYMUPDF_MUPDF_INCLUDE')\n        if pmi:\n            includes.append(pmi)\n        ldflags = os.environ.get('LDFLAGS')\n        if ldflags:\n            linker_extra += f' {ldflags}'\n        cflags = os.environ.get('CFLAGS')\n        if cflags:\n            compiler_extra += f' {cflags}'\n        cxxflags = os.environ.get('CXXFLAGS')\n        if cxxflags:\n            compiler_extra += f' {cxxflags}'\n\n    return compiler_extra, linker_extra, includes, defines, optimise, debug, libpaths, libs, libraries, \n\n\ndef sdist():\n    ret = list()\n    \n    if PYMUPDF_SETUP_FLAVOUR == 'b':\n        # Create a minimal sdist that will build/install a dummy PyMuPDFb.\n        for p in (\n                'setup.py',\n                'pipcl.py',\n                'wdev.py',\n                'pyproject.toml',\n                ):\n            ret.append(p)\n        ret.append(\n                (\n                    b'This file indicates that we are a PyMuPDFb sdist and should build/install a dummy PyMuPDFb package.\\n',\n                    g_pymupdfb_sdist_marker,\n                    )\n                )\n        return ret\n        \n    for p in pipcl.git_items( g_root):\n        if p.startswith(\n                (\n                    'docs/',\n                    'signatures/',\n                    '.',\n                )\n                ):\n            pass\n        else:\n            ret.append(p)\n    if 0:\n        tgz, mupdf_location = get_mupdf_tgz()\n        if tgz:\n            ret.append((tgz, mupdf_tgz))\n    else:\n        log(f'Not including MuPDF .tgz in sdist.')\n    return ret\n\n\nclassifier = [\n        'Development Status :: 5 - Production/Stable',\n        'Intended Audience :: Developers',\n        'Intended Audience :: Information Technology',\n        'Operating System :: MacOS',\n        'Operating System :: Microsoft :: Windows',\n        'Operating System :: POSIX :: Linux',\n        'Programming Language :: C',\n        'Programming Language :: C++',\n        'Programming Language :: Python :: 3 :: Only',\n        'Programming Language :: Python :: Implementation :: CPython',\n        'Topic :: Utilities',\n        'Topic :: Multimedia :: Graphics',\n        'Topic :: Software Development :: Libraries',\n        ]\n\n# We generate different wheels depending on PYMUPDF_SETUP_FLAVOUR.\n#\n\nversion_p = '1.25.1'\nversion_b = '1.25.1'\nversion_mupdf = '1.25.2'\n\nif os.path.exists(f'{g_root}/{g_pymupdfb_sdist_marker}'):\n    \n    # We are in a PyMuPDFb sdist. We specify a dummy package so that pip builds\n    # from sdists work - pip's build using PyMuPDF's sdist will already create\n    # the required binaries, but pip will still see `requires_dist` set to\n    # 'PyMuPDFb', so will also download and build PyMuPDFb's sdist.\n    #\n    log(f'Specifying dummy PyMuPDFb wheel.')\n    \n    def get_requires_for_build_wheel(config_settings=None):\n        return list()\n    \n    p = pipcl.Package(\n            'PyMuPDFb',\n            version_b,\n            summary = 'Dummy PyMuPDFb wheel',\n            description = '',\n            author = 'Artifex',\n            author_email = 'support@artifex.com',\n            license = 'GNU AFFERO GPL 3.0',\n            tag_python = 'py3',\n            )\n\nelse:\n    # A normal PyMuPDF package.\n    \n    with open( f'{g_root}/README.md', encoding='utf-8') as f:\n        readme_p = f.read()\n\n    with open( f'{g_root}/READMEb.md', encoding='utf-8') as f:\n        readme_b = f.read()\n\n    with open( f'{g_root}/READMEd.md', encoding='utf-8') as f:\n        readme_d = f.read()\n\n    tag_python = None\n    requires_dist = None,\n    entry_points = None\n    \n    if 'p' in PYMUPDF_SETUP_FLAVOUR:\n        version = version_p\n        name = 'PyMuPDF'\n        readme = readme_p\n        summary = 'A high performance Python library for data extraction, analysis, conversion & manipulation of PDF (and other) documents.'\n        if 'b' not in PYMUPDF_SETUP_FLAVOUR:\n            requires_dist = f'PyMuPDFb =={version_b}'\n        # Create a `pymupdf` command.\n        entry_points = textwrap.dedent('''\n                [console_scripts]\n                pymupdf = pymupdf.__main__:main\n                ''')\n    elif 'b' in PYMUPDF_SETUP_FLAVOUR:\n        version = version_b\n        name = 'PyMuPDFb'\n        readme = readme_b\n        summary = 'MuPDF shared libraries for PyMuPDF.'\n        tag_python = 'py3'\n    elif 'd' in PYMUPDF_SETUP_FLAVOUR:\n        version = version_b\n        name = 'PyMuPDFd'\n        readme = readme_d\n        summary = 'MuPDF build-time files for PyMuPDF.'\n        tag_python = 'py3'\n    else:\n        assert 0, f'Unrecognised {PYMUPDF_SETUP_FLAVOUR=}.'\n\n    p = pipcl.Package(\n            name,\n            version,\n            summary = summary,\n            description = readme,\n            description_content_type = 'text/markdown',\n            classifier = classifier,\n            author = 'Artifex',\n            author_email = 'support@artifex.com',\n            requires_dist = requires_dist,\n            requires_python = '>=3.9',\n            license = 'GNU AFFERO GPL 3.0',\n            project_url = [\n                ('Documentation, https://pymupdf.readthedocs.io/'),\n                ('Source, https://github.com/pymupdf/pymupdf'),\n                ('Tracker, https://github.com/pymupdf/PyMuPDF/issues'),\n                ('Changelog, https://pymupdf.readthedocs.io/en/latest/changes.html'),\n                ],\n        \n            entry_points = entry_points,\n        \n            fn_build=build,\n            fn_sdist=sdist,\n        \n            tag_python=tag_python,\n            py_limited_api=g_py_limited_api,\n\n            # 30MB: 9 ZIP_DEFLATED\n            # 28MB: 9 ZIP_BZIP2\n            # 23MB: 9 ZIP_LZMA\n            #wheel_compression = zipfile.ZIP_DEFLATED if (darwin or pyodide) else zipfile.ZIP_LZMA,\n            wheel_compresslevel = 9,\n            )\n\n    def get_requires_for_build_wheel(config_settings=None):\n        '''\n        Adds to pyproject.toml:[build-system]:requires, allowing programmatic\n        control over what packages we require.\n        '''\n        def platform_release_tuple():\n            r = platform.release()\n            r = r.split('.')\n            r = tuple(int(i) for i in r)\n            log(f'platform_release_tuple() returning {r=}.')\n            return r\n            \n        ret = list()\n        libclang = os.environ.get('PYMUPDF_SETUP_LIBCLANG')\n        if libclang:\n            print(f'Overriding to use {libclang=}.')\n            ret.append(libclang)\n        elif openbsd:\n            print(f'OpenBSD: libclang not available via pip; assuming `pkg_add py3-llvm`.')\n        elif darwin and platform.machine() == 'arm64':\n            print(f'MacOS/arm64: forcing use of libclang 16.0.6 because 18.1.1 known to fail with `clang.cindex.TranslationUnitLoadError: Error parsing translation unit.`')\n            ret.append('libclang==16.0.6')\n        elif darwin and platform_release_tuple() < (18,):\n            # There are still of problems when building on old macos.\n            ret.append('libclang==14.0.6')\n        else:\n            ret.append('libclang')\n        if msys2:\n            print(f'msys2: pip install of swig does not build; assuming `pacman -S swig`.')\n        elif openbsd:\n            print(f'OpenBSD: pip install of swig does not build; assuming `pkg_add swig`.')\n        else:\n            ret.append( 'swig')\n        return ret\n\n\nif PYMUPDF_SETUP_URL_WHEEL:\n    def build_wheel(\n            wheel_directory,\n            config_settings=None,\n            metadata_directory=None,\n            p=p,\n            ):\n        '''\n        Instead of building wheel, we look for and copy a wheel from location\n        specified by PYMUPDF_SETUP_URL_WHEEL.\n        '''\n        log(f'{PYMUPDF_SETUP_URL_WHEEL=}')\n        log(f'{p.wheel_name()=}')\n        url = PYMUPDF_SETUP_URL_WHEEL\n        if url.startswith(('http://', 'https://')):\n            leaf = p.wheel_name()\n            out_path = f'{wheel_directory}{leaf}'\n            out_path_temp = out_path + '-'\n            if url.endswith('/'):\n                url += leaf\n            log(f'Downloading from {url=} to {out_path_temp=}.')\n            urllib.request.urlretrieve(url, out_path_temp)\n        elif url.startswith(f'file://'):\n            in_path = url[len('file://'):]\n            log(f'{in_path=}')\n            if in_path.endswith('/'):\n                # Look for matching wheel within this directory.\n                wheels = glob.glob(f'{in_path}*.whl')\n                log(f'{len(wheels)=}')\n                for in_path in wheels:\n                    log(f'{in_path=}')\n                    leaf = os.path.basename(in_path)\n                    if p.wheel_name_match(leaf):\n                        log(f'Match: {in_path=}')\n                        break\n                else:\n                    message = f'Cannot find matching for {p.wheel_name()=} in ({len(wheels)=}):\\n'\n                    wheels_text = ''\n                    for wheel in wheels:\n                        wheels_text += f'    {wheel}\\n'\n                    assert 0, f'Cannot find matching for {p.wheel_name()=} in:\\n{wheels_text}'\n            else:\n                leaf = os.path.basename(in_path)\n            out_path = os.path.join(wheel_directory, leaf)\n            out_path_temp = out_path + '-'\n            log(f'Copying from {in_path=} to {out_path_temp=}.')\n            shutil.copy2(in_path, out_path_temp)\n        else:\n            assert 0, f'Unrecognised prefix in {PYMUPDF_SETUP_URL_WHEEL=}.'\n        \n        log(f'Renaming from:\\n    {out_path_temp}\\nto:\\n    {out_path}.')\n        os.rename(out_path_temp, out_path)\n        return os.path.basename(out_path)\nelse:\n    build_wheel = p.build_wheel\n\nbuild_sdist = p.build_sdist\n\n\nif __name__ == '__main__':\n    p.handle_argv(sys.argv)\n"
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "src_classic",
          "type": "tree",
          "content": null
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "valgrind.supp",
          "type": "blob",
          "size": 0.328125,
          "content": "# Valgrind suppression for false-positives from use of shared-libraries.\n#\n{\n   sharedlibrary-read\n   Memcheck:Addr8\n   fun:strncmp\n   fun:is_dst\n   ...\n   fun:fillin_rpath.isra.0\n   fun:decompose_rpath\n   ...\n   fun:openaux\n   fun:_dl_catch_exception\n   fun:_dl_map_object_deps\n   fun:dl_open_worker_begin\n   fun:_dl_catch_exception\n}\n"
        },
        {
          "name": "wdev.py",
          "type": "blob",
          "size": 13.2236328125,
          "content": "'''\nFinds locations of Windows command-line development tools.\n'''\n\nimport os\nimport platform\nimport glob\nimport re\nimport subprocess\nimport sys\nimport sysconfig\nimport textwrap\n\nimport pipcl\n\nclass WindowsVS:\n    r'''\n    Windows only. Finds locations of Visual Studio command-line tools. Assumes\n    VS2019-style paths.\n\n    Members and example values::\n\n        .year:      2019\n        .grade:     Community\n        .version:   14.28.29910\n        .directory: C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\n        .vcvars:    C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Auxiliary\\Build\\vcvars64.bat\n        .cl:        C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29910\\bin\\Hostx64\\x64\\cl.exe\n        .link:      C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29910\\bin\\Hostx64\\x64\\link.exe\n        .csc:       C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\MSBuild\\Current\\Bin\\Roslyn\\csc.exe\n        .msbuild:   C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\MSBuild\\Current\\Bin\\MSBuild.exe\n        .devenv:    C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\Common7\\IDE\\devenv.com\n\n    `.csc` is C# compiler; will be None if not found.\n    '''\n    def __init__( self, year=None, grade=None, version=None, cpu=None, verbose=False):\n        '''\n        Args:\n            year:\n                None or, for example, `2019`. If None we use environment\n                variable WDEV_VS_YEAR if set.\n            grade:\n                None or, for example, one of:\n\n                * `Community`\n                * `Professional`\n                * `Enterprise`\n\n                If None we use environment variable WDEV_VS_GRADE if set.\n            version:\n                None or, for example: `14.28.29910`. If None we use environment\n                variable WDEV_VS_VERSION if set.\n            cpu:\n                None or a `WindowsCpu` instance.\n        '''\n        def default(value, name):\n            if value is None:\n                name2 = f'WDEV_VS_{name.upper()}'\n                value = os.environ.get(name2)\n                if value is not None:\n                    _log(f'Setting {name} from environment variable {name2}: {value!r}')\n            return value\n        try:\n            year = default(year, 'year')\n            grade = default(grade, 'grade')\n            version = default(version, 'version')\n\n            if not cpu:\n                cpu = WindowsCpu()\n\n            # Find `directory`.\n            #\n            pattern = f'C:\\\\Program Files*\\\\Microsoft Visual Studio\\\\{year if year else \"2*\"}\\\\{grade if grade else \"*\"}'\n            directories = glob.glob( pattern)\n            if verbose:\n                _log( f'Matches for: {pattern=}')\n                _log( f'{directories=}')\n            assert directories, f'No match found for: {pattern}'\n            directories.sort()\n            directory = directories[-1]\n\n            # Find `devenv`.\n            #\n            devenv = f'{directory}\\\\Common7\\\\IDE\\\\devenv.com'\n            assert os.path.isfile( devenv), f'Does not exist: {devenv}'\n\n            # Extract `year` and `grade` from `directory`.\n            #\n            # We use r'...' for regex strings because an extra level of escaping is\n            # required for backslashes.\n            #\n            regex = rf'^C:\\\\Program Files.*\\\\Microsoft Visual Studio\\\\([^\\\\]+)\\\\([^\\\\]+)'\n            m = re.match( regex, directory)\n            assert m, f'No match: {regex=} {directory=}'\n            year2 = m.group(1)\n            grade2 = m.group(2)\n            if year:\n                assert year2 == year\n            else:\n                year = year2\n            if grade:\n                assert grade2 == grade\n            else:\n                grade = grade2\n\n            # Find vcvars.bat.\n            #\n            vcvars = f'{directory}\\\\VC\\\\Auxiliary\\\\Build\\\\vcvars{cpu.bits}.bat'\n            assert os.path.isfile( vcvars), f'No match for: {vcvars}'\n\n            # Find cl.exe.\n            #\n            cl_pattern = f'{directory}\\\\VC\\\\Tools\\\\MSVC\\\\{version if version else \"*\"}\\\\bin\\\\Host{cpu.windows_name}\\\\{cpu.windows_name}\\\\cl.exe'\n            cl_s = glob.glob( cl_pattern)\n            assert cl_s, f'No match for: {cl_pattern}'\n            cl_s.sort()\n            cl = cl_s[ -1]\n\n            # Extract `version` from cl.exe's path.\n            #\n            m = re.search( rf'\\\\VC\\\\Tools\\\\MSVC\\\\([^\\\\]+)\\\\bin\\\\Host{cpu.windows_name}\\\\{cpu.windows_name}\\\\cl.exe$', cl)\n            assert m\n            version2 = m.group(1)\n            if version:\n                assert version2 == version\n            else:\n                version = version2\n            assert version\n\n            # Find link.exe.\n            #\n            link_pattern = f'{directory}\\\\VC\\\\Tools\\\\MSVC\\\\{version}\\\\bin\\\\Host{cpu.windows_name}\\\\{cpu.windows_name}\\\\link.exe'\n            link_s = glob.glob( link_pattern)\n            assert link_s, f'No match for: {link_pattern}'\n            link_s.sort()\n            link = link_s[ -1]\n\n            # Find csc.exe.\n            #\n            csc = None\n            for dirpath, dirnames, filenames in os.walk(directory):\n                for filename in filenames:\n                    if filename == 'csc.exe':\n                        csc = os.path.join(dirpath, filename)\n                        #_log(f'{csc=}')\n                        #break\n\n            # Find MSBuild.exe.\n            #\n            msbuild = None\n            for dirpath, dirnames, filenames in os.walk(directory):\n                for filename in filenames:\n                    if filename == 'MSBuild.exe':\n                        msbuild = os.path.join(dirpath, filename)\n                        #_log(f'{csc=}')\n                        #break\n\n            self.cl = cl\n            self.devenv = devenv\n            self.directory = directory\n            self.grade = grade\n            self.link = link\n            self.csc = csc\n            self.msbuild = msbuild\n            self.vcvars = vcvars\n            self.version = version\n            self.year = year\n            self.cpu = cpu\n        except Exception as e:\n            raise Exception( f'Unable to find Visual Studio') from e\n\n    def description_ml( self, indent=''):\n        '''\n        Return multiline description of `self`.\n        '''\n        ret = textwrap.dedent(f'''\n                year:         {self.year}\n                grade:        {self.grade}\n                version:      {self.version}\n                directory:    {self.directory}\n                vcvars:       {self.vcvars}\n                cl:           {self.cl}\n                link:         {self.link}\n                csc:          {self.csc}\n                msbuild:      {self.msbuild}\n                devenv:       {self.devenv}\n                cpu:          {self.cpu}\n                ''')\n        return textwrap.indent( ret, indent)\n\n    def __repr__( self):\n        return ' '.join( self._description())\n\n\nclass WindowsCpu:\n    '''\n    For Windows only. Paths and names that depend on cpu.\n\n    Members:\n        .bits\n            32 or 64.\n        .windows_subdir\n            Empty string or `x64/`.\n        .windows_name\n            `x86` or `x64`.\n        .windows_config\n            `x64` or `Win32`, e.g. for use in `/Build Release|x64`.\n        .windows_suffix\n            `64` or empty string.\n    '''\n    def __init__(self, name=None):\n        if not name:\n            name = _cpu_name()\n        self.name = name\n        if name == 'x32':\n            self.bits = 32\n            self.windows_subdir = ''\n            self.windows_name = 'x86'\n            self.windows_config = 'Win32'\n            self.windows_suffix = ''\n        elif name == 'x64':\n            self.bits = 64\n            self.windows_subdir = 'x64/'\n            self.windows_name = 'x64'\n            self.windows_config = 'x64'\n            self.windows_suffix = '64'\n        else:\n            assert 0, f'Unrecognised cpu name: {name}'\n\n    def __repr__(self):\n        return self.name\n\n\nclass WindowsPython:\n    '''\n    Windows only. Information about installed Python with specific word size\n    and version. Defaults to the currently-running Python.\n\n    Members:\n\n        .path:\n            Path of python binary.\n        .version:\n            `{major}.{minor}`, e.g. `3.9` or `3.11`. Same as `version` passed\n            to `__init__()` if not None, otherwise the inferred version.\n        .include:\n            Python include path.\n        .cpu:\n            A `WindowsCpu` instance, same as `cpu` passed to `__init__()` if\n            not None, otherwise the inferred cpu.\n\n    We parse the output from `py -0p` to find all available python\n    installations.\n    '''\n\n    def __init__( self, cpu=None, version=None, verbose=True):\n        '''\n        Args:\n\n            cpu:\n                A WindowsCpu instance. If None, we use whatever we are running\n                on.\n            version:\n                Two-digit Python version as a string such as `3.8`. If None we\n                use current Python's version.\n            verbose:\n                If true we show diagnostics.\n        '''\n        if cpu is None:\n            cpu = WindowsCpu(_cpu_name())\n        if version is None:\n            version = '.'.join(platform.python_version().split('.')[:2])\n        _log(f'Looking for Python {version=} {cpu.bits=}.')\n\n        if '.'.join(platform.python_version().split('.')[:2]) == version:\n            # Current python matches, so use it directly. This avoids problems\n            # on Github where experimental python-3.13 was not available via\n            # `py`, and is kept here in case a similar problems happens with\n            # future Python versions.\n            _log(f'{cpu=} {version=}: using {sys.executable=}.')\n            self.path = sys.executable\n            self.version = version\n            self.cpu = cpu\n            self.include = sysconfig.get_path('include')\n\n        else:\n            command = 'py -0p'\n            if verbose:\n                _log(f'{cpu=} {version=}: Running: {command}')\n            text = subprocess.check_output( command, shell=True, text=True)\n            for line in text.split('\\n'):\n                #_log( f'    {line}')\n                if m := re.match( '^ *-V:([0-9.]+)(-32)? ([*])? +(.+)$', line):\n                    version2 = m.group(1)\n                    bits = 32 if m.group(2) else 64\n                    current = m.group(3)\n                    path = m.group(4).strip()\n                elif m := re.match( '^ *-([0-9.]+)-((32)|(64)) +(.+)$', line):\n                    version2 = m.group(1)\n                    bits = int(m.group(2))\n                    path = m.group(5).strip()\n                else:\n                    if verbose:\n                        _log( f'No match for {line=}')\n                    continue\n                if verbose:\n                    _log( f'{version2=} {bits=} {path=} from {line=}.')\n                if bits != cpu.bits or version2 != version:\n                    continue\n                root = os.path.dirname(path)\n                if not os.path.exists(path):\n                    # Sometimes it seems that the specified .../python.exe does not exist,\n                    # and we have to change it to .../python<version>.exe.\n                    #\n                    assert path.endswith('.exe'), f'path={path!r}'\n                    path2 = f'{path[:-4]}{version}.exe'\n                    _log( f'Python {path!r} does not exist; changed to: {path2!r}')\n                    assert os.path.exists( path2)\n                    path = path2\n\n                self.path = path\n                self.version = version\n                self.cpu = cpu\n                command = f'{self.path} -c \"import sysconfig; print(sysconfig.get_path(\\'include\\'))\"'\n                _log(f'Finding Python include path by running {command=}.')\n                self.include = subprocess.check_output(command, shell=True, text=True).strip()\n                _log(f'Python include path is {self.include=}.')\n                #_log( f'pipcl.py:WindowsPython():\\n{self.description_ml(\"    \")}')\n                break\n            else:\n                _log(f'Failed to find python matching cpu={cpu}.')\n                _log(f'Output from {command!r} was:\\n{text}')\n                raise Exception( f'Failed to find python matching cpu={cpu} {version=}.')\n\n        # Oddly there doesn't seem to be a\n        # `sysconfig.get_path('libs')`, but it seems to be next\n        # to `includes`:\n        self.libs = os.path.abspath(f'{self.include}/../libs')\n\n        _log( f'WindowsPython:\\n{self.description_ml(\"    \")}')\n\n    def description_ml(self, indent=''):\n        ret = textwrap.dedent(f'''\n                path:       {self.path}\n                version:    {self.version}\n                cpu:        {self.cpu}\n                include:    {self.include}\n                libs:       {self.libs}\n                ''')\n        return textwrap.indent( ret, indent)\n\n    def __repr__(self):\n        return f'path={self.path!r} version={self.version!r} cpu={self.cpu!r} include={self.include!r} libs={self.libs!r}'\n\n\n# Internal helpers.\n#\n\ndef _cpu_name():\n    '''\n    Returns `x32` or `x64` depending on Python build.\n    '''\n    #log(f'sys.maxsize={hex(sys.maxsize)}')\n    return f'x{32 if sys.maxsize == 2**31 - 1 else 64}'\n\n\n\ndef _log(text='', caller=1):\n    '''\n    Logs lines with prefix.\n    '''\n    pipcl.log1(text, caller+1)\n"
        }
      ]
    }
  ]
}