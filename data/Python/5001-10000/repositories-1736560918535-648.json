{
  "metadata": {
    "timestamp": 1736560918535,
    "page": 648,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjY1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "mesonbuild/meson",
      "stars": 5744,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.306640625,
          "content": "root = true\n\n[*]\ncharset = utf-8\nend_of_line = lf\nindent_style = space\ntrim_trailing_whitespace = true\ninsert_final_newline = true\n\n[*.[ch]]\nindent_size = 4\n\n[*.cpp]\nindent_size = 4\n\n[*.py]\nindent_size = 4\n\n[*.vala]\nindent_size = 4\n\n[*.xml]\nindent_size = 2\n\n[meson.build]\nindent_size = 2\n\n[*.json]\nindent_size = 2\n"
        },
        {
          "name": ".flake8",
          "type": "blob",
          "size": 0.921875,
          "content": "[flake8]\nextend-ignore =\n    # E241: multiple spaces after ':'\n    E241,\n    # E251: unexpected spaces around keyword / parameter equals\n    E251,\n    # E261: at least two spaces before inline comment\n    E261,\n    # E265: block comment should start with '# '\n    E265,\n    # E501: line too long\n    E501,\n    # E302: expected 2 blank lines, found 1\n    E302,\n    # E305: expected 2 blank lines after class or function definition, found 1\n    E305,\n    # E401: multiple imports on one line\n    E401,\n    # E266: too many leading '#' for block comment\n    E266,\n    # E402: module level import not at top of file\n    E402,\n    # E731: do not assign a lambda expression, use a def (too many false positives)\n    E731,\n    # E741: ambiguous variable name 'l'\n    E741,\n    # W504: line break after binary operator\n    W504,\n    # A003: builtin class attribute\n    A003\nper-file-ignores =\n    mesonbuild/mesonlib.py:F401,F403\nmax-line-length = 120\n"
        },
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.2060546875,
          "content": ".gitignore export-ignore\n.gitattributes export-ignore\n* text eol=lf\n*.png binary\n*.icns binary\ndata/shell-completions/bash/meson linguist-language=Shell\ndata/shell-completions/zsh/_meson linguist-language=Shell\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.3642578125,
          "content": ".mypy_cache/\n.pytest_cache/\n/.project\n/.pydevproject\n/.settings\n/.cproject\n/.idea\n/.vscode\n\n__pycache__\n/.coverage/\n/.coveragerc\n/install dir\n/work area\n\n/meson-test-run.txt\n/meson-test-run.xml\n/meson-cross-test-run.txt\n/meson-cross-test-run.xml\n\n.DS_Store\n*~\n*.swp\npackagecache\n/MANIFEST\n/build\n/dist\n/meson.egg-info\n\n/docs/built_docs\n/docs/hotdoc-private*\n\n*.pyc\n/*venv*\n"
        },
        {
          "name": ".mailmap",
          "type": "blob",
          "size": 0.888671875,
          "content": "Alexandre Foley <Alexandre.foley@usherbrooke.ca> AlexandreFoley <alexandre.foley@usherbrooke.ca>\nIgor Gnatenko <i.gnatenko.brain@gmail.com> Igor Gnatenko <ignatenko@redhat.com>\nJussi Pakkanen <jpakkane@gmail.com> Jussi Pakkanen <jpakkane@brash.local>\nJussi Pakkanen <jpakkane@gmail.com> jpakkane <jpakkane@gmail.com>\nLiam Beguin <liambeguin@gmail.com> Liam Beguin <lvb@xiphos.com>\nNirbheek Chauhan <nirbheek@centricular.com> Nirbheek Chauhan <nirbheek.chauhan@gmail.com>\nNicolas Schneider <nioncode+git@gmail.com>  Nicolas Schneider <nioncode+github@gmail.com>\nPatrick Griffis <tingping@tingping.se> TingPing <tingping@tingping.se>\nThibault Saunier <thibault.saunier@osg.samsung.com> Thibault Saunier <saunierthibault@gmail.com>\nThibault Saunier <thibault.saunier@osg.samsung.com> Saunier Thibault <saunierthibault@gmail.com>\nTim-Philipp Müller <tim@centricular.com> Tim-Philipp Müller <tim@centricular.net>\n"
        },
        {
          "name": ".mypy.ini",
          "type": "blob",
          "size": 0.80859375,
          "content": "[mypy]\nstrict_optional               = False\nshow_error_context            = False\nshow_column_numbers           = True\nignore_missing_imports        = False\nimplicit_reexport             = False\n\nfollow_imports                = silent\nwarn_redundant_casts          = True\nwarn_unused_ignores           = True\nwarn_return_any               = True\n# warn_unreachable            = True\ndisallow_untyped_calls        = True\ndisallow_untyped_defs         = True\ndisallow_incomplete_defs      = True\ndisallow_untyped_decorators   = True\nno_implicit_optional          = True\nstrict_equality               = True\ncheck_untyped_defs            = True\n# disallow_any_expr           = True\n# disallow_any_decorated      = True\n# disallow_any_explicit       = True\n# disallow_any_generics       = True\n# disallow_subclassing_any    = True\n"
        },
        {
          "name": ".pylintrc",
          "type": "blob",
          "size": 1.9921875,
          "content": "[MASTER]\njobs=0\nload-plugins=\n    pylint.extensions.bad_builtin,\n    pylint.extensions.set_membership,\n\n[REPORTS]\nscore=no\n\n[MESSAGES CONTROL]\ndisable=\n    abstract-method,\n    arguments-differ,\n    arguments-renamed,\n    attribute-defined-outside-init,\n    broad-except,\n    cell-var-from-loop,\n    consider-using-f-string,\n    consider-using-with,\n    contextmanager-generator-missing-cleanup,\n    cyclic-import,\n    deprecated-decorator,\n    duplicate-code,\n    duplicate-value,\n    exec-used,\n    fixme,\n    import-error,\n    import-outside-toplevel,\n    inconsistent-mro,\n    inconsistent-return-statements,\n    invalid-name,\n    invalid-unary-operand-type,\n    line-too-long,\n    method-cache-max-size-none,\n    missing-class-docstring,\n    missing-function-docstring,\n    missing-module-docstring,\n    multiple-imports,\n    multiple-statements,\n    no-else-break,\n    no-else-continue,\n    no-else-raise,\n    no-else-return,\n    no-member,\n    no-name-in-module,\n    no-self-argument,\n    non-parent-init-called,\n    not-an-iterable,\n    not-callable,\n    pointless-string-statement,\n    possibly-used-before-assignment,\n    protected-access,\n    raise-missing-from,\n    redeclared-assigned-name,\n    redefined-argument-from-local,\n    redefined-builtin,\n    redefined-outer-name,\n    subprocess-run-check,\n    super-init-not-called,\n    too-few-public-methods,\n    too-many-ancestors,\n    too-many-arguments,\n    too-many-boolean-expressions,\n    too-many-branches,\n    too-many-instance-attributes,\n    too-many-lines,\n    too-many-locals,\n    too-many-nested-blocks,\n    too-many-positional-arguments,\n    too-many-public-methods,\n    too-many-return-statements,\n    too-many-statements,\n    typevar-name-incorrect-variance,\n    undefined-loop-variable,\n    unidiomatic-typecheck,\n    unnecessary-dict-index-lookup,\n    unnecessary-lambda-assignment,\n    unsubscriptable-object,\n    unused-argument,\n    unused-variable,\n    used-before-assignment,\n    useless-super-delegation,\n    wrong-import-order,\n    wrong-import-position,\n"
        },
        {
          "name": "CODEOWNERS",
          "type": "blob",
          "size": 0.4150390625,
          "content": "* @jpakkane\n/mesonbuild/modules/pkgconfig.py @xclaesse\n/mesonbuild/modules/cmake.py @mensinda\n/mesonbuild/modules/unstable_external_project.py @xclaesse\n/mesonbuild/modules/unstable_rust.py @dcbaker\n/mesonbuild/modules/unstable_wayland.py @markbolhuis\n/mesonbuild/ast/ @mensinda\n/mesonbuild/cmake/ @mensinda\n/mesonbuild/compilers/ @dcbaker\n/mesonbuild/linkers.py @dcbaker\n/mesonbuild/mtest.py @bonzini\n/docs/refman @mensinda\n"
        },
        {
          "name": "COPYING",
          "type": "blob",
          "size": 11.091796875,
          "content": "\n                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"[]\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright [yyyy] [name of copyright owner]\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "MANIFEST.in",
          "type": "blob",
          "size": 0.33203125,
          "content": "graft test?cases\ngraft manual?tests\ngraft cross\ngraft data\ngraft graphics\ngraft man\ngraft tools\ngraft packaging\ngraft unittests\n\ninclude contributing.md\ninclude COPYING\ninclude README.md\ninclude run_cross_test.py\ninclude run_tests.py\ninclude run_unittests.py\ninclude run_meson_command_tests.py\ninclude run_project_tests.py\ninclude meson.py\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 3.2607421875,
          "content": "<p align=\"center\">\n<img src=\"https://mesonbuild.com/assets/images/meson_logo.png\">\n</p>\nMeson® is a project to create the best possible next-generation\nbuild system.\n\n#### Status\n\n[![PyPI](https://img.shields.io/pypi/v/meson.svg)](https://pypi.python.org/pypi/meson)\n[![Build Status](https://dev.azure.com/jussi0947/jussi/_apis/build/status/mesonbuild.meson)](https://dev.azure.com/jussi0947/jussi/_build/latest?definitionId=1)\n[![Codecov](https://codecov.io/gh/mesonbuild/meson/coverage.svg?branch=master)](https://codecov.io/gh/mesonbuild/meson/branch/master)\n\n#### Dependencies\n\n - [Python](https://python.org) (version 3.7 or newer)\n - [Ninja](https://ninja-build.org) (version 1.8.2 or newer)\n\nLatest Meson version supporting previous Python versions:\n- Python 3.6: **0.61.5**\n- Python 3.5: **0.56.2**\n- Python 3.4: **0.45.1**\n\n#### Installing from source\n\nMeson is available on [PyPi](https://pypi.python.org/pypi/meson), so\nit can be installed with `pip3 install meson`.  The exact command to\ntype to install with `pip` can vary between systems, be sure to use\nthe Python 3 version of `pip`.\n\nIf you wish you can install it locally with the standard Python command:\n\n```console\npython3 -m pip install meson\n```\n\nFor builds using Ninja, Ninja can be downloaded directly from Ninja\n[GitHub release page](https://github.com/ninja-build/ninja/releases)\nor via [PyPi](https://pypi.python.org/pypi/ninja)\n\n```console\npython3 -m pip install ninja\n```\n\nMore on Installing Meson build can be found at the\n[getting meson page](https://mesonbuild.com/Getting-meson.html).\n\n#### Creating a standalone script\n\nMeson can be run as a [Python zip\napp](https://docs.python.org/3/library/zipapp.html). To generate the\nexecutable run the following command:\n\n    ./packaging/create_zipapp.py --outfile meson.pyz --interpreter '/usr/bin/env python3' <source checkout>\n\n#### Running\n\nMeson requires that you have a source directory and a build directory\nand that these two are different. In your source root must exist a\nfile called `meson.build`. To generate the build system run this\ncommand:\n\n`meson setup <source directory> <build directory>`\n\nDepending on how you obtained Meson the command might also be called\n`meson.py` instead of plain `meson`. In the rest of this document we\nare going to use the latter form.\n\nYou can omit either of the two directories, and Meson will substitute\nthe current directory and autodetect what you mean. This allows you to\ndo things like this:\n\n```console\ncd <source root>\nmeson setup builddir\n```\n\nTo compile, cd into your build directory and type `ninja`. To run unit\ntests, type `ninja test`.\n\nMore on running Meson build system commands can be found at the\n[running meson page](https://mesonbuild.com/Running-Meson.html)\nor by typing `meson --help`.\n\n#### Contributing\n\nWe love code contributions. See the [contribution\npage](https://mesonbuild.com/Contributing.html) on the website for\ndetails.\n\n\n#### IRC\n\nThe channel to use is `#mesonbuild` either via Matrix ([web\ninterface][matrix_web]) or [OFTC IRC][oftc_irc].\n\n[matrix_web]: https://app.element.io/#/room/#mesonbuild:matrix.org\n[oftc_irc]: https://www.oftc.net/\n\n#### Further info\n\nMore information about the Meson build system can be found at the\n[project's home page](https://mesonbuild.com).\n\nMeson is a registered trademark of ***Jussi Pakkanen***.\n"
        },
        {
          "name": "azure-pipelines.yml",
          "type": "blob",
          "size": 3.2177734375,
          "content": "# intel oneapi installation is based on the examples at\n# https://github.com/oneapi-src/oneapi-ci\n#\n# and are copyrighted:\n#\n# SPDX-FileCopyrightText: 2020 Intel Corporation\n# SPDX-License-Identifier: MIT\n#\n# The rest of this file contains the standard Meson project copyright:\n#\n# SPDX-License-Identifer: Apache-2.0\n# Copyright 2022 The Meson development team\n\n\nname: $(BuildID)\n\ntrigger:\n  branches:\n    include:\n    - 'master'\n    # Release branches\n    - '1.*'\n  paths:\n    include:\n      - 'mesonbuild'\n      - 'test cases'\n      - 'unittests'\n      - 'azure-pipelines.yml'\n      - 'ci/run.ps1'\n      - 'run_project_tests.py'\n      - 'run_tests.py'\n      - 'run_unittests.py'\npr:\n  autoCancel: true\n  branches:\n    include:\n    - '*'\n  paths:\n    include:\n      - 'mesonbuild'\n      - 'test cases'\n      - 'unittests'\n      - 'azure-pipelines.yml'\n      - 'ci/run.ps1'\n      - 'run_project_tests.py'\n      - 'run_tests.py'\n      - 'run_unittests.py'\n\nvariables:\n  CI: 1\n  SOURCE_VERSION: $(Build.SourceVersion)\n  WINDOWS_HPCKIT_URL: https://registrationcenter-download.intel.com/akdlm/IRC_NAS/18680/w_HPCKit_p_2022.2.0.173_offline.exe\n  WINDOWS_FORTRAN_COMPONENTS: intel.oneapi.win.ifort-compiler\n\njobs:\n\n- job: vs2019\n  timeoutInMinutes: 120\n  pool:\n    vmImage: windows-2019\n\n  strategy:\n    matrix:\n        vc2019x64ninja:\n          arch: x64\n          compiler: msvc2019\n          backend: ninja\n          ifort: true\n        vc2019x64vs:\n          arch: x64\n          compiler: msvc2019\n          backend: vs2019\n          # mysteriously, several tests fail because vs cannot find\n          # executables such as cmd.exe ???\n          ifort: false\n        vc2019arm64ninjacross:\n          arch: arm64\n          compiler: msvc2019\n          backend: ninja\n          extraargs: --cross arm64cl.txt --cross-only\n          # ifort doesn't support arm64\n          ifort: false\n\n  steps:\n  - task: Cache@2\n    inputs:\n      path: C:\\Program Files (x86)\\Intel\\oneAPI\n      key: '\"install\" | \"$(WINDOWS_HPCKIT_URL)\" | \"$(WINDOWS_FORTRAN_COMPONENTS)\" | \"compiler\" | ci/intel-scripts/cache_exclude_windows.sh'\n      cacheHitVar: CACHE_RESTORED\n    condition: eq(variables.ifort, 'true')\n  - script: ci/intel-scripts/install_windows.bat $(WINDOWS_HPCKIT_URL) $(WINDOWS_FORTRAN_COMPONENTS)\n    displayName: install ifort\n    condition: and(ne(variables.CACHE_RESTORED, 'true'), eq(variables.ifort, 'true'))\n  - bash: ci/intel-scripts/cache_exclude_windows.sh\n    displayName: exclude unused files from cache\n    condition: and(ne(variables.CACHE_RESTORED, 'true'), eq(variables.ifort, 'true'))\n  - script: choco install -y nasm\n    displayName: install NASM\n  - task: UsePythonVersion@0\n    inputs:\n      versionSpec: '3.7'\n      addToPath: true\n      architecture: 'x64'\n  - task: BatchScript@1\n    displayName: insert ifort into environment\n    inputs:\n      filename: ci/intel-scripts/activate_windows.bat\n      arguments: vs2019\n      modifyEnvironment: True\n    condition: eq(variables.ifort, 'true')\n  - task: PowerShell@2\n    inputs:\n      targetType: 'filePath'\n      filePath: .\\ci\\run.ps1\n    env:\n      MESON_CI_JOBNAME: azure-$(System.JobName)\n  - task: PowerShell@2\n    displayName: Gathering coverage report\n    inputs:\n      targetType: 'filePath'\n      filePath: .\\ci\\coverage.ps1\n"
        },
        {
          "name": "ci",
          "type": "tree",
          "content": null
        },
        {
          "name": "contributing.md",
          "type": "blob",
          "size": 0.3173828125,
          "content": "## Contributing to the Meson build system\n\nThank you for your interest in participating to the development!\nA large fraction of Meson is contributed by people outside\nthe core team and we are *excited* to see what you do.\n\n**Contribution instructions can be found on the website**\n @ https://mesonbuild.com/Contributing.html\n"
        },
        {
          "name": "cross",
          "type": "tree",
          "content": null
        },
        {
          "name": "data",
          "type": "tree",
          "content": null
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "graphics",
          "type": "tree",
          "content": null
        },
        {
          "name": "man",
          "type": "tree",
          "content": null
        },
        {
          "name": "manual tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "meson.py",
          "type": "blob",
          "size": 0.884765625,
          "content": "#!/usr/bin/env python3\n# SPDX-License-Identifier: Apache-2.0\n# Copyright 2016 The Meson development team\n# Copyright © 2023 Intel Corporation\n\nimport sys\n\n# Check python version before importing anything else, we might have an older\n# Python that would error on f-string syntax for example.\nif sys.version_info < (3, 7):\n    print('Meson works correctly only with python 3.7+.')\n    print('You have python {}.'.format(sys.version))\n    print('Please update your environment')\n    sys.exit(1)\n\nfrom pathlib import Path\n\n# If we're run uninstalled, add the script directory to sys.path to ensure that\n# we always import the correct mesonbuild modules even if PYTHONPATH is mangled\nmeson_exe = Path(sys.argv[0]).resolve()\nif (meson_exe.parent / 'mesonbuild').is_dir():\n    sys.path.insert(0, str(meson_exe.parent))\n\nfrom mesonbuild import mesonmain\n\nif __name__ == '__main__':\n    sys.exit(mesonmain.main())\n"
        },
        {
          "name": "mesonbuild",
          "type": "tree",
          "content": null
        },
        {
          "name": "packaging",
          "type": "tree",
          "content": null
        },
        {
          "name": "pyproject.toml",
          "type": "blob",
          "size": 0.091796875,
          "content": "[build-system]\nrequires = [\"setuptools>=42\", \"wheel\"]\nbuild-backend = \"setuptools.build_meta\"\n"
        },
        {
          "name": "run_cross_test.py",
          "type": "blob",
          "size": 1.6884765625,
          "content": "#!/usr/bin/env python3\n# SPDX-License-Identifier: Apache-2.0\n# Copyright 2013-2016 The Meson development team\n\n'''Runs the basic test suite through a cross compiler.\n\nThis is now just a wrapper around run_project_tests.py with specific arguments\n'''\n\nimport argparse\nimport subprocess\nfrom mesonbuild import mesonlib\nfrom mesonbuild.coredata import version as meson_version\nfrom pathlib import Path\nimport json\nimport os\n\n\ndef runtests(cross_file, failfast, cross_only, test_list, env=None):\n    tests = ['--only'] + test_list\n    if not cross_only:\n        tests.append('native')\n    cmd = mesonlib.python_command + ['run_project_tests.py', '--backend', 'ninja']\n    if failfast:\n        cmd += ['--failfast']\n    cmd += tests\n    cmd += ['--cross-file', cross_file]\n    if cross_only:\n        cmd += ['--native-file', 'cross/none.txt']\n    return subprocess.call(cmd, env=env)\n\ndef main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--failfast', action='store_true')\n    parser.add_argument('--cross-only', action='store_true')\n    parser.add_argument('cross_file')\n    options = parser.parse_args()\n    cf_path = Path(options.cross_file)\n    try:\n        data = json.loads(cf_path.read_text(encoding='utf-8'))\n        real_cf = cf_path.resolve().parent / data['file']\n        assert real_cf.exists()\n        env = os.environ.copy()\n        env.update(data['env'])\n        return runtests(real_cf.as_posix(), options.failfast, options.cross_only, data['tests'], env=env)\n    except Exception:\n        return runtests(options.cross_file, options.failfast, options.cross_only, ['common'])\n\nif __name__ == '__main__':\n    print('Meson build system', meson_version, 'Cross Tests')\n    raise SystemExit(main())\n"
        },
        {
          "name": "run_format_tests.py",
          "type": "blob",
          "size": 2.6962890625,
          "content": "#!/usr/bin/env python3\n# SPDX-License-Identifier: Apache-2.0\n# Copyright 2012-2019 The Meson development team\n\n# some simple checks on the file format of:\n# - python code\n# - code samples in tests\n# - markdown documentation\n#\n# checks are:\n# - no use of tabs\n# - no use of DOS line endings\n\nimport os\nimport re\nfrom pathlib import Path\n\ndef check_file(file: Path) -> None:\n    lines = file.read_bytes().split(b'\\n')\n    tabdetector = re.compile(br' *\\t')\n    for i, line in enumerate(lines):\n        if re.match(tabdetector, line):\n            raise SystemExit(\"File {} contains a tab indent on line {:d}. Only spaces are permitted.\".format(file, i + 1))\n        if line.endswith(b'\\r'):\n            raise SystemExit(\"File {} contains DOS line ending on line {:d}. Only unix-style line endings are permitted.\".format(file, i + 1))\n\ndef check_format() -> None:\n    check_suffixes = {'.c',\n                      '.cpp',\n                      '.cxx',\n                      '.cc',\n                      '.rs',\n                      '.f90',\n                      '.vala',\n                      '.d',\n                      '.s',\n                      '.m',\n                      '.mm',\n                      '.asm',\n                      '.java',\n                      '.txt',\n                      '.py',\n                      '.swift',\n                      '.build',\n                      '.md',\n                      }\n    skip_dirs = {\n        '.dub',                         # external deps are here\n        '.pytest_cache',\n        'meson-logs', 'meson-private',\n        'work area',\n        '.eggs', '_cache',              # e.g. .mypy_cache\n        'venv',                         # virtualenvs have DOS line endings\n        '121 rewrite',                  # we explicitly test for tab in meson.build file\n        '3 editorconfig',\n    }\n    for (root, _, filenames) in os.walk('.'):\n        if any([x in root for x in skip_dirs]):\n            continue\n        for fname in filenames:\n            file = Path(fname)\n            if file.suffix.lower() in check_suffixes:\n                if file.name in ('sitemap.txt', 'meson-test-run.txt'):\n                    continue\n                check_file(root / file)\n\ndef check_symlinks():\n    # Test data must NOT contain symlinks. setup.py\n    # butchers them. If you need symlinks, they need\n    # to be created on the fly.\n    for f in Path('test cases').glob('**/*'):\n        if f.is_symlink():\n            if 'boost symlinks/boost/lib' in str(f):\n                continue\n            raise SystemExit(f'Test data dir contains symlink: {f}.')\n\n\nif __name__ == '__main__':\n    script_dir = os.path.split(__file__)[0]\n    if script_dir != '':\n        os.chdir(script_dir)\n    check_format()\n    check_symlinks()\n"
        },
        {
          "name": "run_meson_command_tests.py",
          "type": "blob",
          "size": 9.201171875,
          "content": "#!/usr/bin/env python3\n# SPDX-License-Identifier: Apache-2.0\n# Copyright 2018 The Meson development team\n\nimport os\nimport tempfile\nimport unittest\nimport subprocess\nimport zipapp\nimport sysconfig\nfrom pathlib import Path\n\nfrom mesonbuild.mesonlib import windows_proof_rmtree, python_command, is_windows\nfrom mesonbuild.coredata import version as meson_version\n\nscheme = None\n\ndef needs_debian_path_hack():\n    try:\n        import setuptools\n        return int(setuptools.__version__.split('.')[0]) < 65\n    except ModuleNotFoundError:\n        return False\n\nif needs_debian_path_hack():\n    # Handle the scheme that Debian patches in the as default\n    # This function was renamed and made public in Python 3.10\n    if hasattr(sysconfig, 'get_default_scheme'):\n        scheme = sysconfig.get_default_scheme()\n    else:\n        scheme = sysconfig._get_default_scheme()\n    if scheme == 'posix_local':\n        scheme = 'posix_prefix'\n\ndef get_pypath():\n    if scheme:\n        pypath = sysconfig.get_path('purelib', scheme=scheme, vars={'base': ''})\n    else:\n        pypath = sysconfig.get_path('purelib', vars={'base': ''})\n    # Ensure that / is the path separator and not \\, then strip /\n    return Path(pypath).as_posix().strip('/')\n\ndef get_pybindir():\n    # 'Scripts' on Windows and 'bin' on other platforms including MSYS\n    if scheme:\n        return sysconfig.get_path('scripts', scheme=scheme, vars={'base': ''}).strip('\\\\/')\n    return sysconfig.get_path('scripts', vars={'base': ''}).strip('\\\\/')\n\nclass CommandTests(unittest.TestCase):\n    '''\n    Test that running meson in various ways works as expected by checking the\n    value of mesonlib.meson_command that was set during configuration.\n    '''\n\n    def setUp(self):\n        super().setUp()\n        self.orig_env = os.environ.copy()\n        self.orig_dir = os.getcwd()\n        os.environ['MESON_COMMAND_TESTS'] = '1'\n        self.tmpdir = Path(tempfile.mkdtemp()).resolve()\n        self.src_root = Path(__file__).resolve().parent\n        self.testdir = str(self.src_root / 'test cases/common/1 trivial')\n        self.meson_args = ['--backend=ninja']\n\n    def tearDown(self):\n        try:\n            windows_proof_rmtree(str(self.tmpdir))\n        except FileNotFoundError:\n            pass\n        os.environ.clear()\n        os.environ.update(self.orig_env)\n        os.chdir(str(self.orig_dir))\n        super().tearDown()\n\n    def _run(self, command, workdir=None, env=None):\n        '''\n        Run a command while printing the stdout, and also return a copy of it\n        '''\n        # If this call hangs CI will just abort. It is very hard to distinguish\n        # between CI issue and test bug in that case. Set timeout and fail loud\n        # instead.\n        p = subprocess.run(command, stdout=subprocess.PIPE,\n                           env=env, text=True,\n                           cwd=workdir, timeout=60 * 5)\n        print(p.stdout)\n        if p.returncode != 0:\n            raise subprocess.CalledProcessError(p.returncode, command)\n        return p.stdout\n\n    def assertMesonCommandIs(self, line, cmd):\n        self.assertTrue(line.startswith('meson_command '), msg=line)\n        self.assertEqual(line, f'meson_command is {cmd!r}')\n\n    def test_meson_uninstalled(self):\n        # This is what the meson command must be for all these cases\n        resolved_meson_command = python_command + [str(self.src_root / 'meson.py')]\n        # Absolute path to meson.py\n        os.chdir('/')\n        builddir = str(self.tmpdir / 'build1')\n        meson_py = str(self.src_root / 'meson.py')\n        meson_setup = [meson_py, 'setup']\n        meson_command = python_command + meson_setup + self.meson_args\n        stdo = self._run(meson_command + [self.testdir, builddir])\n        self.assertMesonCommandIs(stdo.split('\\n')[0], resolved_meson_command)\n        # ./meson.py\n        os.chdir(str(self.src_root))\n        builddir = str(self.tmpdir / 'build2')\n        meson_py = './meson.py'\n        meson_setup = [meson_py, 'setup']\n        meson_command = python_command + meson_setup + self.meson_args\n        stdo = self._run(meson_command + [self.testdir, builddir])\n        self.assertMesonCommandIs(stdo.split('\\n')[0], resolved_meson_command)\n        # Symlink to meson.py\n        if is_windows():\n            # Symlinks require admin perms\n            return\n        os.chdir(str(self.src_root))\n        builddir = str(self.tmpdir / 'build3')\n        # Create a symlink to meson.py in bindir, and add it to PATH\n        bindir = (self.tmpdir / 'bin')\n        bindir.mkdir()\n        (bindir / 'meson').symlink_to(self.src_root / 'meson.py')\n        (bindir / 'python3').symlink_to(python_command[0])\n        os.environ['PATH'] = str(bindir) + os.pathsep + os.environ['PATH']\n        # use our overridden PATH-compatible python\n        path_resolved_meson_command = [str(bindir / 'meson')]\n        # See if it works!\n        meson_py = 'meson'\n        meson_setup = [meson_py, 'setup']\n        meson_command = meson_setup + self.meson_args\n        stdo = self._run(meson_command + [self.testdir, builddir])\n        self.assertMesonCommandIs(stdo.split('\\n')[0], path_resolved_meson_command)\n\n    def test_meson_installed(self):\n        # Install meson\n        prefix = self.tmpdir / 'prefix'\n        pylibdir = prefix / get_pypath()\n        bindir = prefix / get_pybindir()\n        pylibdir.mkdir(parents=True)\n        # XXX: join with empty name so it always ends with os.sep otherwise\n        # distutils complains that prefix isn't contained in PYTHONPATH\n        os.environ['PYTHONPATH'] = os.path.join(str(pylibdir), '')\n        os.environ['PATH'] = str(bindir) + os.pathsep + os.environ['PATH']\n        self._run(python_command + ['setup.py', 'install', '--prefix', str(prefix)])\n        # Fix importlib-metadata by appending all dirs in pylibdir\n        PYTHONPATHS = [pylibdir] + [x for x in pylibdir.iterdir()]\n        PYTHONPATHS = [os.path.join(str(x), '') for x in PYTHONPATHS]\n        os.environ['PYTHONPATH'] = os.pathsep.join(PYTHONPATHS)\n        # Check that all the files were installed correctly\n        self.assertTrue(bindir.is_dir())\n        self.assertTrue(pylibdir.is_dir())\n        # Run `meson`\n        os.chdir('/')\n        resolved_meson_command = [str(bindir / 'meson')]\n        builddir = str(self.tmpdir / 'build1')\n        meson_setup = ['meson', 'setup']\n        meson_command = meson_setup + self.meson_args\n        stdo = self._run(meson_command + [self.testdir, builddir])\n        self.assertMesonCommandIs(stdo.split('\\n')[0], resolved_meson_command)\n        # Run `/path/to/meson`\n        builddir = str(self.tmpdir / 'build2')\n        meson_setup = [str(bindir / 'meson'), 'setup']\n        meson_command = meson_setup + self.meson_args\n        stdo = self._run(meson_command + [self.testdir, builddir])\n        self.assertMesonCommandIs(stdo.split('\\n')[0], resolved_meson_command)\n        # Run `python3 -m mesonbuild.mesonmain`\n        resolved_meson_command = python_command + ['-m', 'mesonbuild.mesonmain']\n        builddir = str(self.tmpdir / 'build3')\n        meson_setup = ['-m', 'mesonbuild.mesonmain', 'setup']\n        meson_command = python_command + meson_setup + self.meson_args\n        stdo = self._run(meson_command + [self.testdir, builddir])\n        self.assertMesonCommandIs(stdo.split('\\n')[0], resolved_meson_command)\n        if is_windows():\n            # Next part requires a shell\n            return\n        # `meson` is a wrapper to `meson.real`\n        resolved_meson_command = [str(bindir / 'meson.real')]\n        builddir = str(self.tmpdir / 'build4')\n        (bindir / 'meson').rename(bindir / 'meson.real')\n        wrapper = (bindir / 'meson')\n        wrapper.write_text('#!/bin/sh\\n\\nmeson.real \"$@\"', encoding='utf-8')\n        wrapper.chmod(0o755)\n        meson_setup = [str(wrapper), 'setup']\n        meson_command = meson_setup + self.meson_args\n        stdo = self._run(meson_command + [self.testdir, builddir])\n        self.assertMesonCommandIs(stdo.split('\\n')[0], resolved_meson_command)\n\n    def test_meson_exe_windows(self):\n        raise unittest.SkipTest('NOT IMPLEMENTED')\n\n    def test_meson_zipapp(self):\n        if is_windows():\n            raise unittest.SkipTest('NOT IMPLEMENTED')\n        source = Path(__file__).resolve().parent\n        target = self.tmpdir / 'meson.pyz'\n        script = source / 'packaging' / 'create_zipapp.py'\n        self._run([script.as_posix(), source, '--outfile', target, '--interpreter', python_command[0]])\n        self._run([target.as_posix(), '--help'])\n\n    def test_meson_runpython(self):\n        meson_command = str(self.src_root / 'meson.py')\n        script_file = str(self.src_root / 'foo.py')\n        test_command = 'import sys; print(sys.argv[1])'\n        env = os.environ.copy()\n        del env['MESON_COMMAND_TESTS']\n        with open(script_file, 'w') as f:\n            f.write('#!/usr/bin/env python3\\n\\n')\n            f.write(f'{test_command}\\n')\n        self.addCleanup(os.remove, script_file)\n\n        for cmd in [['-c', test_command, 'fake argument'], [script_file, 'fake argument']]:\n            pyout = self._run(python_command + cmd)\n            mesonout = self._run(python_command + [meson_command, 'runpython'] + cmd, env=env)\n            self.assertEqual(pyout, mesonout)\n\nif __name__ == '__main__':\n    print('Meson build system', meson_version, 'Command Tests')\n    raise SystemExit(unittest.main(buffer=True))\n"
        },
        {
          "name": "run_mypy.py",
          "type": "blob",
          "size": 5.4013671875,
          "content": "#!/usr/bin/env python3\n# SPDX-License-Identifier: Apache-2.0\n# Copyright © 2024 Intel Corporation\n\nfrom pathlib import Path\nimport argparse\nimport os\nimport subprocess\nimport sys\nimport typing as T\n\nfrom mesonbuild.mesonlib import version_compare\n\nmodules = [\n    # fully typed submodules\n    # 'mesonbuild/ast/',\n    'mesonbuild/cargo/',\n    'mesonbuild/cmake/',\n    'mesonbuild/compilers/',\n    'mesonbuild/dependencies/',\n    'mesonbuild/interpreter/primitives/',\n    'mesonbuild/interpreterbase/',\n    'mesonbuild/linkers/',\n    'mesonbuild/scripts/',\n    'mesonbuild/templates/',\n    'mesonbuild/wrap/',\n\n    # specific files\n    'mesonbuild/ast/introspection.py',\n    'mesonbuild/ast/printer.py',\n    'mesonbuild/ast/postprocess.py',\n    'mesonbuild/ast/visitor.py',\n    'mesonbuild/arglist.py',\n    'mesonbuild/backend/backends.py',\n    'mesonbuild/backend/nonebackend.py',\n    # 'mesonbuild/coredata.py',\n    'mesonbuild/depfile.py',\n    'mesonbuild/envconfig.py',\n    'mesonbuild/interpreter/compiler.py',\n    'mesonbuild/interpreter/mesonmain.py',\n    'mesonbuild/interpreter/interpreterobjects.py',\n    'mesonbuild/interpreter/type_checking.py',\n    'mesonbuild/machinefile.py',\n    'mesonbuild/mcompile.py',\n    'mesonbuild/mdevenv.py',\n    'mesonbuild/utils/core.py',\n    'mesonbuild/utils/platform.py',\n    'mesonbuild/utils/universal.py',\n    'mesonbuild/utils/vsenv.py',\n    'mesonbuild/mconf.py',\n    'mesonbuild/mdist.py',\n    'mesonbuild/mformat.py',\n    'mesonbuild/minit.py',\n    'mesonbuild/minstall.py',\n    'mesonbuild/mintro.py',\n    'mesonbuild/mlog.py',\n    'mesonbuild/msubprojects.py',\n    'mesonbuild/modules/__init__.py',\n    'mesonbuild/modules/cuda.py',\n    'mesonbuild/modules/external_project.py',\n    'mesonbuild/modules/fs.py',\n    'mesonbuild/modules/gnome.py',\n    'mesonbuild/modules/i18n.py',\n    'mesonbuild/modules/icestorm.py',\n    'mesonbuild/modules/java.py',\n    'mesonbuild/modules/keyval.py',\n    'mesonbuild/modules/modtest.py',\n    'mesonbuild/modules/pkgconfig.py',\n    'mesonbuild/modules/_qt.py',\n    'mesonbuild/modules/qt4.py',\n    'mesonbuild/modules/qt5.py',\n    'mesonbuild/modules/qt6.py',\n    'mesonbuild/modules/rust.py',\n    'mesonbuild/modules/simd.py',\n    'mesonbuild/modules/sourceset.py',\n    'mesonbuild/modules/wayland.py',\n    'mesonbuild/modules/windows.py',\n    'mesonbuild/mparser.py',\n    'mesonbuild/msetup.py',\n    'mesonbuild/mtest.py',\n    'mesonbuild/optinterpreter.py',\n    'mesonbuild/programs.py',\n]\nadditional = [\n    'run_mypy.py',\n    'run_project_tests.py',\n    'run_single_test.py',\n    'tools',\n    'docs/genrefman.py',\n    'docs/refman',\n    'unittests/helpers.py',\n]\n\nif os.name == 'posix':\n    modules.append('mesonbuild/utils/posix.py')\nelif os.name == 'nt':\n    modules.append('mesonbuild/utils/win32.py')\n\ndef check_mypy() -> None:\n    try:\n        import mypy\n    except ImportError:\n        print('Failed import mypy')\n        sys.exit(1)\n    from mypy.version import __version__ as mypy_version\n    if not version_compare(mypy_version, '>=0.812'):\n        print('mypy >=0.812 is required, older versions report spurious errors')\n        sys.exit(1)\n\ndef main() -> int:\n    check_mypy()\n\n    root = Path(__file__).absolute().parent\n\n    parser = argparse.ArgumentParser(description='Process some integers.')\n    parser.add_argument('files', nargs='*')\n    parser.add_argument('--mypy', help='path to mypy executable')\n    parser.add_argument('-q', '--quiet', action='store_true', help='do not print informational messages')\n    parser.add_argument('-p', '--pretty', action='store_true', help='pretty print mypy errors')\n    parser.add_argument('-C', '--clear', action='store_true', help='clear the terminal before running mypy')\n    parser.add_argument('--allver', action='store_true', help='Check all supported versions of python')\n\n    opts, args = parser.parse_known_args()\n    if opts.pretty:\n        args.append('--pretty')\n\n    if opts.clear:\n        print('\\x1bc', end='', flush=True)\n\n    to_check = [] # type: T.List[str]\n    additional_to_check = [] # type: T.List[str]\n    if opts.files:\n        for f in opts.files:\n            if f in modules:\n                to_check.append(f)\n            elif any(f.startswith(i) for i in modules):\n                to_check.append(f)\n            elif f in additional:\n                additional_to_check.append(f)\n            elif any(f.startswith(i) for i in additional):\n                additional_to_check.append(f)\n            else:\n                if not opts.quiet:\n                    print(f'skipping {f!r} because it is not yet typed')\n    else:\n        to_check.extend(modules)\n        additional_to_check.extend(additional)\n\n    if to_check:\n        command = [opts.mypy] if opts.mypy else [sys.executable, '-m', 'mypy']\n        if not opts.quiet:\n            print('Running mypy (this can take some time) ...')\n        retcode = subprocess.run(command + args + to_check + additional_to_check, cwd=root).returncode\n        if opts.allver and retcode == 0:\n            for minor in range(7, sys.version_info[1]):\n                if not opts.quiet:\n                    print(f'Checking mypy with python version: 3.{minor}')\n                p = subprocess.run(command + args + to_check + [f'--python-version=3.{minor}'], cwd=root)\n                if p.returncode != 0:\n                    retcode = p.returncode\n        return retcode\n    else:\n        if not opts.quiet:\n            print('nothing to do...')\n        return 0\n\nif __name__ == '__main__':\n    sys.exit(main())\n"
        },
        {
          "name": "run_project_tests.py",
          "type": "blob",
          "size": 66.8408203125,
          "content": "#!/usr/bin/env python3\n# SPDX-License-Identifier: Apache-2.0\n# Copyright 2012-2021 The Meson development team\n\nfrom __future__ import annotations\n\n# Work around some pathlib bugs...\nfrom mesonbuild import _pathlib\nimport sys\nsys.modules['pathlib'] = _pathlib\n\nfrom concurrent.futures import ProcessPoolExecutor, CancelledError\nfrom enum import Enum\nfrom io import StringIO\nfrom pathlib import Path, PurePath\nimport argparse\nimport functools\nimport itertools\nimport json\nimport multiprocessing\nimport os\nimport re\nimport shlex\nimport shutil\nimport signal\nimport subprocess\nimport tempfile\nimport time\nimport typing as T\nimport xml.etree.ElementTree as ET\nimport collections\nimport importlib.util\n\nfrom mesonbuild import build\nfrom mesonbuild import environment\nfrom mesonbuild import compilers\nfrom mesonbuild import mesonlib\nfrom mesonbuild import mlog\nfrom mesonbuild import mtest\nfrom mesonbuild.compilers import compiler_from_language\nfrom mesonbuild.build import ConfigurationData\nfrom mesonbuild.mesonlib import MachineChoice, Popen_safe, TemporaryDirectoryWinProof, setup_vsenv\nfrom mesonbuild.mlog import blue, bold, cyan, green, red, yellow, normal_green\nfrom mesonbuild.coredata import version as meson_version\nfrom mesonbuild.options import backendlist\nfrom mesonbuild.modules.python import PythonExternalProgram\nfrom run_tests import (\n    get_fake_options, run_configure, get_meson_script, get_backend_commands,\n    get_backend_args_for_dir, Backend,\n    guess_backend, handle_meson_skip_test,\n)\n\n\nif T.TYPE_CHECKING:\n    from types import FrameType\n    from mesonbuild.environment import Environment\n    from mesonbuild._typing import Protocol\n    from concurrent.futures import Future\n\n    class CompilerArgumentType(Protocol):\n        cross_file: str\n        native_file: str\n        use_tmpdir: bool\n\n\n    class ArgumentType(CompilerArgumentType):\n\n        \"\"\"Typing information for command line arguments.\"\"\"\n\n        extra_args: T.List[str]\n        backend: str\n        num_workers: int\n        failfast: bool\n        no_unittests: bool\n        only: T.List[str]\n        v: bool\n\nALL_TESTS = ['cmake', 'common', 'native', 'warning-meson', 'failing-meson', 'failing-build', 'failing-test',\n             'keyval', 'platform-osx', 'platform-windows', 'platform-linux',\n             'java', 'C#', 'vala', 'cython', 'rust', 'd', 'objective c', 'objective c++',\n             'fortran', 'swift', 'cuda', 'python3', 'python', 'fpga', 'frameworks', 'nasm', 'wasm', 'wayland',\n             'format',\n             ]\n\n\nclass BuildStep(Enum):\n    configure = 1\n    build = 2\n    test = 3\n    install = 4\n    clean = 5\n    validate = 6\n\nverbose_output = False\n\nclass TestResult(BaseException):\n    def __init__(self, cicmds: T.List[str]) -> None:\n        self.msg    = ''  # empty msg indicates test success\n        self.stdo   = ''\n        self.stde   = ''\n        self.mlog   = ''\n        self.cicmds = cicmds\n        self.conftime:  float = 0\n        self.buildtime: float = 0\n        self.testtime:  float = 0\n\n    def add_step(self, step: BuildStep, stdo: str, stde: str, mlog: str = '', time: float = 0) -> None:\n        self.step = step\n        self.stdo += stdo\n        self.stde += stde\n        self.mlog += mlog\n        if step == BuildStep.configure:\n            self.conftime = time\n        elif step == BuildStep.build:\n            self.buildtime = time\n        elif step == BuildStep.test:\n            self.testtime = time\n\n    def fail(self, msg: str) -> None:\n        self.msg = msg\n\npython = PythonExternalProgram(sys.executable)\npython.sanity()\n\nclass InstalledFile:\n    def __init__(self, raw: T.Dict[str, str]):\n        self.path = raw['file']\n        self.typ = raw['type']\n        self.platform = raw.get('platform', None)\n        self.language = raw.get('language', 'c')\n\n        version = raw.get('version', '')\n        if version:\n            self.version = version.split('.')\n        else:\n            # split on '' will return [''], we want an empty list though\n            self.version = []\n\n    def get_path(self, compiler: str, env: environment.Environment) -> T.Optional[Path]:\n        p = Path(self.path)\n        canonical_compiler = compiler\n        if ((compiler in ['clang-cl', 'intel-cl']) or\n                (env.machines.host.is_windows() and compiler in {'pgi', 'dmd', 'ldc'})):\n            canonical_compiler = 'msvc'\n\n        python_suffix = python.info['suffix']\n        python_limited_suffix = python.info['limited_api_suffix']\n        has_pdb = False\n        if self.language in {'c', 'cpp'}:\n            has_pdb = canonical_compiler == 'msvc'\n        elif self.language == 'd':\n            # dmd's optlink does not generate pdb files\n            has_pdb = env.coredata.compilers.host['d'].linker.id in {'link', 'lld-link'}\n\n        # Abort if the platform does not match\n        matches = {\n            'msvc': canonical_compiler == 'msvc',\n            'gcc': canonical_compiler != 'msvc',\n            'cygwin': env.machines.host.is_cygwin(),\n            '!cygwin': not env.machines.host.is_cygwin(),\n        }.get(self.platform or '', True)\n        if not matches:\n            return None\n\n        # Handle the different types\n        if self.typ in {'py_implib', 'py_limited_implib', 'python_lib', 'python_limited_lib', 'python_file', 'python_bytecode'}:\n            val = p.as_posix()\n            val = val.replace('@PYTHON_PLATLIB@', python.platlib)\n            val = val.replace('@PYTHON_PURELIB@', python.purelib)\n            p = Path(val)\n            if self.typ == 'python_file':\n                return p\n            if self.typ == 'python_lib':\n                return p.with_suffix(python_suffix)\n            if self.typ == 'python_limited_lib':\n                return p.with_suffix(python_limited_suffix)\n            if self.typ == 'py_implib':\n                p = p.with_suffix(python_suffix)\n                if env.machines.host.is_windows() and canonical_compiler == 'msvc':\n                    return p.with_suffix('.lib')\n                elif env.machines.host.is_windows() or env.machines.host.is_cygwin():\n                    return p.with_suffix('.dll.a')\n                else:\n                    return None\n            if self.typ == 'py_limited_implib':\n                p = p.with_suffix(python_limited_suffix)\n                if env.machines.host.is_windows() and canonical_compiler == 'msvc':\n                    return p.with_suffix('.lib')\n                elif env.machines.host.is_windows() or env.machines.host.is_cygwin():\n                    return p.with_suffix('.dll.a')\n                else:\n                    return None\n            if self.typ == 'python_bytecode':\n                return p.parent / importlib.util.cache_from_source(p.name)\n        elif self.typ in {'file', 'dir', 'link'}:\n            return p\n        elif self.typ == 'shared_lib':\n            if env.machines.host.is_windows() or env.machines.host.is_cygwin():\n                # Windows only has foo.dll and foo-X.dll\n                if len(self.version) > 1:\n                    return None\n                if self.version:\n                    p = p.with_name('{}-{}'.format(p.name, self.version[0]))\n                return p.with_suffix('.dll')\n\n            p = p.with_name(f'lib{p.name}')\n            if env.machines.host.is_darwin():\n                # MacOS only has libfoo.dylib and libfoo.X.dylib\n                if len(self.version) > 1:\n                    return None\n\n                # pathlib.Path.with_suffix replaces, not appends\n                suffix = '.dylib'\n                if self.version:\n                    suffix = '.{}{}'.format(self.version[0], suffix)\n            else:\n                # pathlib.Path.with_suffix replaces, not appends\n                suffix = '.so'\n                if self.version:\n                    suffix = '{}.{}'.format(suffix, '.'.join(self.version))\n            return p.with_suffix(suffix)\n        elif self.typ == 'exe':\n            if 'mwcc' in canonical_compiler:\n                return p.with_suffix('.nef')\n            elif env.machines.host.is_windows() or env.machines.host.is_cygwin():\n                return p.with_suffix('.exe')\n        elif self.typ == 'pdb':\n            if self.version:\n                p = p.with_name('{}-{}'.format(p.name, self.version[0]))\n            return p.with_suffix('.pdb') if has_pdb else None\n        elif self.typ in {'implib', 'implibempty'}:\n            if env.machines.host.is_windows() and canonical_compiler == 'msvc':\n                # only MSVC doesn't generate empty implibs\n                if self.typ == 'implibempty' and compiler == 'msvc':\n                    return None\n                return p.parent / (re.sub(r'^lib', '', p.name) + '.lib')\n            elif env.machines.host.is_windows() or env.machines.host.is_cygwin():\n                return p.with_suffix('.dll.a')\n            else:\n                return None\n        elif self.typ == 'expr':\n            return Path(platform_fix_name(p.as_posix(), canonical_compiler, env))\n        else:\n            raise RuntimeError(f'Invalid installed file type {self.typ}')\n\n        return p\n\n    def get_paths(self, compiler: str, env: environment.Environment, installdir: Path) -> T.List[Path]:\n        p = self.get_path(compiler, env)\n        if not p:\n            return []\n        if self.typ == 'dir':\n            abs_p = installdir / p\n            if not abs_p.exists():\n                raise RuntimeError(f'{p} does not exist')\n            if not abs_p.is_dir():\n                raise RuntimeError(f'{p} is not a directory')\n            return [x.relative_to(installdir) for x in abs_p.rglob('*') if x.is_file() or x.is_symlink()]\n        elif self.typ == 'link':\n            abs_p = installdir / p\n            if not abs_p.is_symlink():\n                raise RuntimeError(f'{p} is not a symlink')\n            return [p]\n        else:\n            return [p]\n\n@functools.total_ordering\nclass TestDef:\n    def __init__(self, path: Path, name: T.Optional[str], args: T.List[str], skip: bool = False, skip_category: bool = False):\n        self.category = path.parts[1]\n        self.path = path\n        self.name = name\n        self.args = args\n        self.skip = skip\n        self.env = os.environ.copy()\n        self.installed_files: T.List[InstalledFile] = []\n        self.do_not_set_opts: T.List[str] = []\n        self.stdout: T.List[T.Dict[str, str]] = []\n        self.skip_category = skip_category\n        self.skip_expected = False\n        self.cleanup: T.List[str] = []\n\n        # Always print a stack trace for Meson exceptions\n        self.env['MESON_FORCE_BACKTRACE'] = '1'\n\n    def __repr__(self) -> str:\n        return '<{}: {:<48} [{}: {}] -- {}>'.format(type(self).__name__, str(self.path), self.name, self.args, self.skip)\n\n    def display_name(self) -> mlog.TV_LoggableList:\n        # Remove the redundant 'test cases' part\n        section, id = self.path.parts[1:3]\n        res: mlog.TV_LoggableList = [f'{section}:', bold(id)]\n        if self.name:\n            res += [f'   ({self.name})']\n        return res\n\n    def __lt__(self, other: object) -> bool:\n        if isinstance(other, TestDef):\n            # None is not sortable, so replace it with an empty string\n            s_id = int(self.path.name.split(' ')[0])\n            o_id = int(other.path.name.split(' ')[0])\n            return (s_id, self.path, self.name or '') < (o_id, other.path, other.name or '')\n        return NotImplemented\n\nfailing_testcases: T.List[str] = []\nfailing_logs: T.List[str] = []\nprint_debug = 'MESON_PRINT_TEST_OUTPUT' in os.environ\nunder_ci = 'CI' in os.environ\nraw_ci_jobname = os.environ.get('MESON_CI_JOBNAME', None)\nci_jobname = raw_ci_jobname if raw_ci_jobname != 'thirdparty' else None\ndo_debug = under_ci or print_debug\nno_meson_log_msg = 'No meson-log.txt found.'\n\nhost_c_compiler: T.Optional[str]   = None\ncompiler_id_map: T.Dict[str, str]  = {}\ntool_vers_map:   T.Dict[str, str]  = {}\n\ncompile_commands:   T.List[str]\nclean_commands:     T.List[str]\ntest_commands:      T.List[str]\ninstall_commands:   T.List[str]\nuninstall_commands: T.List[str]\n\nbackend:      'Backend'\nbackend_flags: T.List[str]\n\nstop: bool = False\nis_worker_process: bool = False\n\n# Let's have colors in our CI output\nif under_ci:\n    def _ci_colorize_console() -> bool:\n        return not is_worker_process\n\n    mlog.colorize_console = _ci_colorize_console\n\nclass StopException(Exception):\n    def __init__(self) -> None:\n        super().__init__('Stopped by user')\n\ndef stop_handler(signal: int, frame: T.Optional['FrameType']) -> None:\n    global stop\n    stop = True\nsignal.signal(signal.SIGINT, stop_handler)\nsignal.signal(signal.SIGTERM, stop_handler)\n\ndef setup_commands(optbackend: str) -> None:\n    global do_debug, backend, backend_flags\n    global compile_commands, clean_commands, test_commands, install_commands, uninstall_commands\n    backend, backend_flags = guess_backend(optbackend, shutil.which('msbuild'))\n    compile_commands, clean_commands, test_commands, install_commands, \\\n        uninstall_commands = get_backend_commands(backend, do_debug)\n\n# TODO try to eliminate or at least reduce this function\ndef platform_fix_name(fname: str, canonical_compiler: str, env: environment.Environment) -> str:\n    if '?lib' in fname:\n        if env.machines.host.is_windows() and canonical_compiler == 'msvc':\n            fname = re.sub(r'lib/\\?lib(.*)\\.', r'bin/\\1.', fname)\n            fname = re.sub(r'/\\?lib/', r'/bin/', fname)\n        elif env.machines.host.is_windows():\n            fname = re.sub(r'lib/\\?lib(.*)\\.', r'bin/lib\\1.', fname)\n            fname = re.sub(r'\\?lib(.*)\\.dll$', r'lib\\1.dll', fname)\n            fname = re.sub(r'/\\?lib/', r'/bin/', fname)\n        elif env.machines.host.is_cygwin():\n            fname = re.sub(r'lib/\\?lib(.*)\\.so$', r'bin/cyg\\1.dll', fname)\n            fname = re.sub(r'lib/\\?lib(.*)\\.', r'bin/cyg\\1.', fname)\n            fname = re.sub(r'\\?lib(.*)\\.dll$', r'cyg\\1.dll', fname)\n            fname = re.sub(r'/\\?lib/', r'/bin/', fname)\n        else:\n            fname = re.sub(r'\\?lib', 'lib', fname)\n\n    if fname.endswith('?so'):\n        if env.machines.host.is_windows() and canonical_compiler == 'msvc':\n            fname = re.sub(r'lib/([^/]*)\\?so$', r'bin/\\1.dll', fname)\n            fname = re.sub(r'/(?:lib|)([^/]*?)\\?so$', r'/\\1.dll', fname)\n            return fname\n        elif env.machines.host.is_windows():\n            fname = re.sub(r'lib/([^/]*)\\?so$', r'bin/\\1.dll', fname)\n            fname = re.sub(r'/([^/]*?)\\?so$', r'/\\1.dll', fname)\n            return fname\n        elif env.machines.host.is_cygwin():\n            fname = re.sub(r'lib/([^/]*)\\?so$', r'bin/\\1.dll', fname)\n            fname = re.sub(r'/lib([^/]*?)\\?so$', r'/cyg\\1.dll', fname)\n            fname = re.sub(r'/([^/]*?)\\?so$', r'/\\1.dll', fname)\n            return fname\n        elif env.machines.host.is_darwin():\n            return fname[:-3] + '.dylib'\n        else:\n            return fname[:-3] + '.so'\n\n    return fname\n\ndef validate_install(test: TestDef, installdir: Path, env: environment.Environment) -> str:\n    ret_msg = ''\n    expected_raw: T.List[Path] = []\n    for i in test.installed_files:\n        try:\n            expected_raw += i.get_paths(host_c_compiler, env, installdir)\n        except RuntimeError as err:\n            ret_msg += f'Expected path error: {err}\\n'\n    expected = {x: False for x in expected_raw}\n    found = [x.relative_to(installdir) for x in installdir.rglob('*') if x.is_file() or x.is_symlink()]\n    # Mark all found files as found and detect unexpected files\n    for fname in found:\n        if fname not in expected:\n            ret_msg += f'Extra file {fname} found.\\n'\n            continue\n        expected[fname] = True\n    # Check if expected files were found\n    for p, f in expected.items():\n        if not f:\n            ret_msg += f'Expected file {p} missing.\\n'\n    # List dir content on error\n    if ret_msg != '':\n        ret_msg += '\\nInstall dir contents:\\n'\n        for p in found:\n            ret_msg += f'  - {p}\\n'\n    return ret_msg\n\ndef log_text_file(logfile: T.TextIO, testdir: Path, result: TestResult) -> None:\n    logfile.write('%s\\nstdout\\n\\n---\\n' % testdir.as_posix())\n    logfile.write(result.stdo)\n    logfile.write('\\n\\n---\\n\\nstderr\\n\\n---\\n')\n    logfile.write(result.stde)\n    logfile.write('\\n\\n---\\n\\n')\n    if print_debug:\n        try:\n            print(result.stdo)\n        except UnicodeError:\n            sanitized_out = result.stdo.encode('ascii', errors='replace').decode()\n            print(sanitized_out)\n        try:\n            print(result.stde, file=sys.stderr)\n        except UnicodeError:\n            sanitized_err = result.stde.encode('ascii', errors='replace').decode()\n            print(sanitized_err, file=sys.stderr)\n\n\ndef _run_ci_include(args: T.List[str]) -> str:\n    if not args:\n        return 'At least one parameter required'\n\n    header = f'Included file {args[0]}:'\n    try:\n        return mlog.ci_fold_file(args[0], header, force=True)\n    except Exception:\n        return 'Failed to open {}\\n'.format(args[0])\n\nci_commands = {\n    'ci_include': _run_ci_include\n}\n\ndef run_ci_commands(raw_log: str) -> T.List[str]:\n    res = []\n    for l in raw_log.splitlines():\n        if not l.startswith('!meson_ci!/'):\n            continue\n        cmd = shlex.split(l[11:])\n        if not cmd or cmd[0] not in ci_commands:\n            continue\n        res += ['CI COMMAND {}:\\n{}'.format(cmd[0], ci_commands[cmd[0]](cmd[1:]))]\n    return res\n\nclass OutputMatch:\n    def __init__(self, how: str, expected: str, count: int) -> None:\n        self.how = how\n        self.expected = expected\n        self.count = count\n\n    def match(self, actual: str) -> bool:\n        if self.how == \"re\":\n            return bool(re.match(self.expected, actual))\n        return self.expected == actual\n\ndef _compare_output(expected: T.List[T.Dict[str, str]], output: str, desc: str) -> str:\n    if expected:\n        matches:   T.List[OutputMatch] = []\n        nomatches: T.List[OutputMatch] = []\n        for item in expected:\n            how = item.get('match', 'literal')\n            expected_line = item.get('line')\n            count = int(item.get('count', -1))\n\n            # Simple heuristic to automatically convert path separators for\n            # Windows:\n            #\n            # Any '/' appearing before 'WARNING' or 'ERROR' (i.e. a path in a\n            # filename part of a location) is replaced with '\\' (in a re: '\\\\'\n            # which matches a literal '\\')\n            #\n            # (There should probably be a way to turn this off for more complex\n            # cases which don't fit this)\n            if mesonlib.is_windows():\n                if how != \"re\":\n                    sub = r'\\\\'\n                else:\n                    sub = r'\\\\\\\\'\n                expected_line = re.sub(r'/(?=.*(WARNING|ERROR|DEPRECATION))', sub, expected_line)\n\n            m = OutputMatch(how, expected_line, count)\n            if count == 0:\n                nomatches.append(m)\n            else:\n                matches.append(m)\n\n\n        i = 0\n        for actual in output.splitlines():\n            # Verify this line does not match any unexpected lines (item.count == 0)\n            for match in nomatches:\n                if match.match(actual):\n                    return f'unexpected \"{match.expected}\" found in {desc}'\n            # If we matched all expected lines, continue to verify there are\n            # no unexpected line. If nomatches is empty then we are done already.\n            if i >= len(matches):\n                if not nomatches:\n                    break\n                continue\n            # Check if this line match current expected line\n            match = matches[i]\n            if match.match(actual):\n                if match.count < 0:\n                    # count was not specified, continue with next expected line,\n                    # it does not matter if this line will be matched again or\n                    # not.\n                    i += 1\n                else:\n                    # count was specified (must be >0), continue expecting this\n                    # same line. If count reached 0 we continue with next\n                    # expected line but remember that this one must not match\n                    # anymore.\n                    match.count -= 1\n                    if match.count == 0:\n                        nomatches.append(match)\n                        i += 1\n\n        if i < len(matches):\n            # reached the end of output without finding expected\n            return f'expected \"{matches[i].expected}\" not found in {desc}'\n\n    return ''\n\ndef validate_output(test: TestDef, stdo: str, stde: str) -> str:\n    return _compare_output(test.stdout, stdo, 'stdout')\n\n# There are some class variables and such that cache\n# information. Clear all of these. The better solution\n# would be to change the code so that no state is persisted\n# but that would be a lot of work given that Meson was originally\n# coded to run as a batch process.\ndef clear_internal_caches() -> None:\n    import mesonbuild.interpreterbase\n    from mesonbuild.dependencies.cmake import CMakeDependency\n    from mesonbuild.dependencies.pkgconfig import PkgConfigInterface\n    from mesonbuild.mesonlib import PerMachine\n    mesonbuild.interpreterbase.FeatureNew.feature_registry = {}\n    CMakeDependency.class_cmakeinfo = PerMachine(None, None)\n    PkgConfigInterface.class_impl = PerMachine(False, False)\n    PkgConfigInterface.class_cli_impl = PerMachine(False, False)\n    PkgConfigInterface.pkg_bin_per_machine = PerMachine(None, None)\n\n\ndef run_test_inprocess(testdir: str) -> T.Tuple[int, str, str, str]:\n    old_stdout = sys.stdout\n    sys.stdout = mystdout = StringIO()\n    old_stderr = sys.stderr\n    sys.stderr = mystderr = StringIO()\n    old_cwd = os.getcwd()\n    os.chdir(testdir)\n    test_log_fname = os.path.join('meson-logs', 'testlog.txt')\n    try:\n        returncode_test = mtest.run_with_args(['--no-rebuild'])\n        if os.path.exists(test_log_fname):\n            test_log = _run_ci_include([test_log_fname])\n        else:\n            test_log = ''\n        returncode_benchmark = mtest.run_with_args(['--no-rebuild', '--benchmark', '--logbase', 'benchmarklog'])\n    finally:\n        sys.stdout = old_stdout\n        sys.stderr = old_stderr\n        os.chdir(old_cwd)\n    return max(returncode_test, returncode_benchmark), mystdout.getvalue(), mystderr.getvalue(), test_log\n\n# Build directory name must be the same so Ccache works over\n# consecutive invocations.\ndef create_deterministic_builddir(test: TestDef, use_tmpdir: bool) -> str:\n    import hashlib\n    src_dir = test.path.as_posix()\n    if test.name:\n        src_dir += test.name\n    rel_dirname = 'b ' + hashlib.sha256(src_dir.encode(errors='ignore')).hexdigest()[0:10]\n    abs_pathname = os.path.join(tempfile.gettempdir() if use_tmpdir else os.getcwd(), rel_dirname)\n    if os.path.exists(abs_pathname):\n        mesonlib.windows_proof_rmtree(abs_pathname)\n    os.mkdir(abs_pathname)\n    return abs_pathname\n\ndef format_parameter_file(file_basename: str, test: TestDef, test_build_dir: str) -> Path:\n    confdata = ConfigurationData()\n    confdata.values = {'MESON_TEST_ROOT': (str(test.path.absolute()), 'base directory of current test')}\n\n    template = test.path / (file_basename + '.in')\n    destination = Path(test_build_dir) / file_basename\n    mesonlib.do_conf_file(str(template), str(destination), confdata, 'meson')\n\n    return destination\n\ndef detect_parameter_files(test: TestDef, test_build_dir: str) -> T.Tuple[Path, Path]:\n    nativefile = test.path / 'nativefile.ini'\n    crossfile = test.path / 'crossfile.ini'\n\n    if os.path.exists(str(test.path / 'nativefile.ini.in')):\n        nativefile = format_parameter_file('nativefile.ini', test, test_build_dir)\n\n    if os.path.exists(str(test.path / 'crossfile.ini.in')):\n        crossfile = format_parameter_file('crossfile.ini', test, test_build_dir)\n\n    return nativefile, crossfile\n\n# In previous python versions the global variables are lost in ProcessPoolExecutor.\n# So, we use this tuple to restore some of them\nclass GlobalState(T.NamedTuple):\n    compile_commands:   T.List[str]\n    clean_commands:     T.List[str]\n    test_commands:      T.List[str]\n    install_commands:   T.List[str]\n    uninstall_commands: T.List[str]\n\n    backend:      'Backend'\n    backend_flags: T.List[str]\n\n    host_c_compiler: T.Optional[str]\n\ndef run_test(test: TestDef,\n             extra_args: T.List[str],\n             should_fail: str,\n             use_tmp: bool,\n             state: T.Optional[GlobalState] = None) -> T.Optional[TestResult]:\n    # Unpack the global state\n    global compile_commands, clean_commands, test_commands, install_commands, uninstall_commands, backend, backend_flags, host_c_compiler\n    if state is not None:\n        compile_commands, clean_commands, test_commands, install_commands, uninstall_commands, backend, backend_flags, host_c_compiler = state\n    # Store that this is a worker process\n    global is_worker_process\n    is_worker_process = True\n    # Setup the test environment\n    assert not test.skip, 'Skipped test should not be run'\n    build_dir = create_deterministic_builddir(test, use_tmp)\n    try:\n        with TemporaryDirectoryWinProof(prefix='i ', dir=None if use_tmp else os.getcwd()) as install_dir:\n            try:\n                return _run_test(test, build_dir, install_dir, extra_args, should_fail)\n            except TestResult as r:\n                return r\n            finally:\n                mlog.shutdown() # Close the log file because otherwise Windows wets itself.\n    finally:\n        mesonlib.windows_proof_rmtree(build_dir)\n\ndef _run_test(test: TestDef,\n              test_build_dir: str,\n              install_dir: str,\n              extra_args: T.List[str],\n              should_fail: str) -> TestResult:\n    gen_start = time.time()\n    # Configure in-process\n    gen_args = ['setup']\n    if 'prefix' not in test.do_not_set_opts:\n        gen_args += ['--prefix', 'x:/usr'] if mesonlib.is_windows() else ['--prefix', '/usr']\n    if 'libdir' not in test.do_not_set_opts:\n        gen_args += ['--libdir', 'lib']\n    gen_args += [test.path.as_posix(), test_build_dir] + backend_flags + extra_args\n\n    nativefile, crossfile = detect_parameter_files(test, test_build_dir)\n\n    if nativefile.exists():\n        gen_args.extend(['--native-file', nativefile.as_posix()])\n    if crossfile.exists():\n        gen_args.extend(['--cross-file', crossfile.as_posix()])\n    inprocess, res = run_configure(gen_args, env=test.env, catch_exception=True)\n    returncode, stdo, stde = res\n    cmd = '(inprocess) $ ' if inprocess else '$ '\n    cmd += mesonlib.join_args(gen_args)\n    logfile = os.path.join(test_build_dir, 'meson-logs', 'meson-log.txt')\n    if os.path.exists(logfile):\n        mesonlog = '\\n'.join((cmd, _run_ci_include([logfile])))\n    else:\n        mesonlog = no_meson_log_msg\n    cicmds = run_ci_commands(mesonlog)\n    testresult = TestResult(cicmds)\n    testresult.add_step(BuildStep.configure, '\\n'.join((cmd, stdo)), stde, mesonlog, time.time() - gen_start)\n    output_msg = validate_output(test, stdo, stde)\n    testresult.mlog += output_msg\n    if output_msg:\n        testresult.fail('Unexpected output while configuring.')\n        return testresult\n    if should_fail == 'meson':\n        if returncode == 1:\n            return testresult\n        elif returncode != 0:\n            testresult.fail(f'Test exited with unexpected status {returncode}.')\n            return testresult\n        else:\n            testresult.fail('Test that should have failed succeeded.')\n            return testresult\n    if returncode != 0:\n        testresult.fail('Generating the build system failed.')\n        return testresult\n    builddata = build.load(test_build_dir)\n    dir_args = get_backend_args_for_dir(backend, test_build_dir)\n\n    # Build with subprocess\n    def build_step() -> None:\n        build_start = time.time()\n\n        if backend is Backend.ninja:\n            # FIXME: meson test inprocess does not handle running ninja via StringIO\n            targets = ['all', 'meson-test-prereq', 'meson-benchmark-prereq']\n        else:\n            targets = []\n\n        pc, o, _ = Popen_safe(compile_commands + dir_args + targets, cwd=test_build_dir, stderr=subprocess.STDOUT)\n        testresult.add_step(BuildStep.build, o, '', '', time.time() - build_start)\n        if should_fail == 'build':\n            if pc.returncode != 0:\n                raise testresult\n            testresult.fail('Test that should have failed to build succeeded.')\n            raise testresult\n        if pc.returncode != 0:\n            testresult.fail('Compiling source code failed.')\n            raise testresult\n\n    # Touch the meson.build file to force a regenerate\n    def force_regenerate() -> None:\n        os.utime(str(test.path / 'meson.build'))\n\n    # just test building\n    build_step()\n\n    # test that regeneration works for build step\n    force_regenerate()\n    build_step()  # TBD: assert nothing gets built after the regenerate?\n\n    # test that regeneration works for test step\n    force_regenerate()\n\n    # Test in-process\n    clear_internal_caches()\n    test_start = time.time()\n    (returncode, tstdo, tstde, test_log) = run_test_inprocess(test_build_dir)\n    testresult.add_step(BuildStep.test, tstdo, tstde, test_log, time.time() - test_start)\n    if should_fail == 'test':\n        if returncode != 0:\n            return testresult\n        testresult.fail('Test that should have failed to run unit tests succeeded.')\n        return testresult\n    if returncode != 0:\n        testresult.fail('Running unit tests failed.')\n        return testresult\n\n    # Do installation, if the backend supports it\n    if install_commands:\n        env = test.env.copy()\n        env['DESTDIR'] = install_dir\n        # Install with subprocess\n        pi, o, e = Popen_safe(install_commands, cwd=test_build_dir, env=env)\n        testresult.add_step(BuildStep.install, o, e)\n        if pi.returncode != 0:\n            testresult.fail('Running install failed.')\n            return testresult\n\n    # Clean with subprocess\n    env = test.env.copy()\n    pi, o, e = Popen_safe(clean_commands + dir_args, cwd=test_build_dir, env=env)\n    testresult.add_step(BuildStep.clean, o, e)\n    if pi.returncode != 0:\n        testresult.fail('Running clean failed.')\n        return testresult\n\n    # Validate installed files\n    testresult.add_step(BuildStep.install, '', '')\n    if not install_commands:\n        return testresult\n    install_msg = validate_install(test, Path(install_dir), builddata.environment)\n    if install_msg:\n        testresult.fail('\\n' + install_msg)\n        return testresult\n\n    return testresult\n\n\n# processing of test.json 'skip_*' keys, which can appear at top level, or in\n# matrix:\ndef _skip_keys(test_def: T.Dict) -> T.Tuple[bool, bool]:\n    skip_expected = False\n\n    # Test is expected to skip if MESON_CI_JOBNAME contains any of the list of\n    # substrings\n    if ('expect_skip_on_jobname' in test_def) and (ci_jobname is not None):\n        skip_expected = any(s in ci_jobname for s in test_def['expect_skip_on_jobname'])\n\n    # Test is expected to skip if os matches\n    if 'expect_skip_on_os' in test_def:\n        mesonenv = environment.Environment('', '', get_fake_options('/'))\n        for skip_os in test_def['expect_skip_on_os']:\n            if skip_os.startswith('!'):\n                if mesonenv.machines.host.system != skip_os[1:]:\n                    skip_expected = True\n            else:\n                if mesonenv.machines.host.system == skip_os:\n                    skip_expected = True\n\n    # Skip if environment variable is present\n    skip = False\n    if 'skip_on_env' in test_def:\n        for skip_env_var in test_def['skip_on_env']:\n            if skip_env_var in os.environ:\n                skip = True\n\n    return (skip, skip_expected)\n\n\ndef load_test_json(t: TestDef, stdout_mandatory: bool, skip_category: bool = False) -> T.List[TestDef]:\n    all_tests: T.List[TestDef] = []\n    test_def = {}\n    test_def_file = t.path / 'test.json'\n    if test_def_file.is_file():\n        test_def = json.loads(test_def_file.read_text(encoding='utf-8'))\n\n    # Handle additional environment variables\n    env: T.Dict[str, str] = {}\n    if 'env' in test_def:\n        assert isinstance(test_def['env'], dict)\n        env = test_def['env']\n        for key, val in env.items():\n            val = val.replace('@ROOT@', t.path.resolve().as_posix())\n            val = val.replace('@PATH@', t.env.get('PATH', ''))\n            env[key] = val\n\n    # Handle installed files\n    installed: T.List[InstalledFile] = []\n    if 'installed' in test_def:\n        installed = [InstalledFile(x) for x in test_def['installed']]\n\n    # Handle expected output\n    stdout = test_def.get('stdout', [])\n    if stdout_mandatory and not stdout:\n        raise RuntimeError(f\"{test_def_file} must contain a non-empty stdout key\")\n\n    # Handle the do_not_set_opts list\n    do_not_set_opts: T.List[str] = test_def.get('do_not_set_opts', [])\n\n    (t.skip, t.skip_expected) = _skip_keys(test_def)\n\n    cleanup = test_def.get('cleanup', [])\n\n    # Skip tests if the tool requirements are not met\n    if 'tools' in test_def:\n        assert isinstance(test_def['tools'], dict)\n        for tool, vers_req in test_def['tools'].items():\n            if tool not in tool_vers_map:\n                t.skip = True\n            elif not mesonlib.version_compare(tool_vers_map[tool], vers_req):\n                t.skip = True\n\n    # Skip the matrix code and just update the existing test\n    if 'matrix' not in test_def:\n        t.env.update(env)\n        t.installed_files = installed\n        t.do_not_set_opts = do_not_set_opts\n        t.stdout = stdout\n        t.cleanup = cleanup\n        return [t]\n\n    new_opt_list: T.List[T.List[T.Tuple[str, str, bool, bool]]]\n\n    # 'matrix; entry is present, so build multiple tests from matrix definition\n    opt_list: T.List[T.List[T.Tuple[str, str, bool, bool]]] = []\n    matrix = test_def['matrix']\n    assert \"options\" in matrix\n    for key, val in matrix[\"options\"].items():\n        assert isinstance(val, list)\n        tmp_opts: T.List[T.Tuple[str, str, bool, bool]] = []\n        for i in val:\n            assert isinstance(i, dict)\n            assert \"val\" in i\n\n            (skip, skip_expected) = _skip_keys(i)\n\n            # Only run the test if all compiler ID's match\n            if 'compilers' in i:\n                for lang, id_list in i['compilers'].items():\n                    if lang not in compiler_id_map or compiler_id_map[lang] not in id_list:\n                        skip = True\n                        break\n\n            # Add an empty matrix entry\n            if i['val'] is None:\n                tmp_opts += [(key, None, skip, skip_expected)]\n                continue\n\n            tmp_opts += [(key, i['val'], skip, skip_expected)]\n\n        if opt_list:\n            new_opt_list = []\n            for i in opt_list:\n                for j in tmp_opts:\n                    new_opt_list += [[*i, j]]\n            opt_list = new_opt_list\n        else:\n            opt_list = [[x] for x in tmp_opts]\n\n    # Exclude specific configurations\n    if 'exclude' in matrix:\n        assert isinstance(matrix['exclude'], list)\n        new_opt_list = []\n        for i in opt_list:\n            exclude = False\n            opt_tuple = [(x[0], x[1]) for x in i]\n            for j in matrix['exclude']:\n                ex_list = [(k, v) for k, v in j.items()]\n                if all([x in opt_tuple for x in ex_list]):\n                    exclude = True\n                    break\n\n            if not exclude:\n                new_opt_list += [i]\n\n        opt_list = new_opt_list\n\n    for i in opt_list:\n        name = ' '.join([f'{x[0]}={x[1]}' for x in i if x[1] is not None])\n        opts = [f'-D{x[0]}={x[1]}' for x in i if x[1] is not None]\n        skip = any([x[2] for x in i])\n        skip_expected = any([x[3] for x in i])\n        test = TestDef(t.path, name, opts, skip or t.skip, skip_category)\n        test.env.update(env)\n        test.installed_files = installed\n        test.do_not_set_opts = do_not_set_opts\n        test.stdout = stdout\n        test.skip_expected = skip_expected or t.skip_expected\n        test.cleanup = cleanup\n\n        all_tests.append(test)\n\n    return all_tests\n\n\ndef gather_tests(testdir: Path, stdout_mandatory: bool, only: T.List[str], skip_category: bool) -> T.List[TestDef]:\n    all_tests: T.List[TestDef] = []\n    for t in testdir.iterdir():\n        # Filter non-tests files (dot files, etc)\n        if not t.is_dir() or t.name.startswith('.'):\n            continue\n        if t.name in {'18 includedirxyz'}:\n            continue\n        if only and not any(t.name.startswith(prefix) for prefix in only):\n            continue\n        test_def = TestDef(t, None, [], skip_category=skip_category)\n        all_tests.extend(load_test_json(test_def, stdout_mandatory, skip_category))\n    return sorted(all_tests)\n\n\ndef have_d_compiler() -> bool:\n    if shutil.which(\"ldc2\"):\n        return True\n    elif shutil.which(\"ldc\"):\n        return True\n    elif shutil.which(\"gdc\"):\n        return True\n    elif shutil.which(\"dmd\"):\n        # The Windows installer sometimes produces a DMD install\n        # that exists but segfaults every time the compiler is run.\n        # Don't know why. Don't know how to fix. Skip in this case.\n        cp = subprocess.run(['dmd', '--version'],\n                            capture_output=True)\n        if cp.stdout == b'':\n            return False\n        return True\n    return False\n\ndef have_objc_compiler(use_tmp: bool) -> bool:\n    return have_working_compiler('objc', use_tmp)\n\ndef have_objcpp_compiler(use_tmp: bool) -> bool:\n    return have_working_compiler('objcpp', use_tmp)\n\ndef have_cython_compiler(use_tmp: bool) -> bool:\n    return have_working_compiler('cython', use_tmp)\n\ndef have_working_compiler(lang: str, use_tmp: bool) -> bool:\n    with TemporaryDirectoryWinProof(prefix='b ', dir=None if use_tmp else '.') as build_dir:\n        env = environment.Environment('', build_dir, get_fake_options('/'))\n        try:\n            compiler = compiler_from_language(env, lang, MachineChoice.HOST)\n        except mesonlib.MesonException:\n            return False\n        if not compiler:\n            return False\n        env.coredata.process_compiler_options(lang, compiler, env, '')\n        try:\n            compiler.sanity_check(env.get_scratch_dir(), env)\n        except mesonlib.MesonException:\n            return False\n    return True\n\ndef have_java() -> bool:\n    if shutil.which('javac') and shutil.which('java'):\n        return True\n    return False\n\ndef skip_dont_care(t: TestDef) -> bool:\n    # Everything is optional when not running on CI\n    if ci_jobname is None:\n        return True\n\n    # Non-frameworks test are allowed to determine their own skipping under CI (currently)\n    if not t.category.endswith('frameworks'):\n        return True\n\n    if mesonlib.is_osx() and '6 gettext' in str(t.path):\n        return True\n\n    return False\n\ndef skip_csharp(backend: Backend) -> bool:\n    if backend is not Backend.ninja:\n        return True\n    if not shutil.which('resgen'):\n        return True\n    if shutil.which('mcs'):\n        return False\n    if shutil.which('csc'):\n        # Only support VS2017 for now. Earlier versions fail\n        # under CI in mysterious ways.\n        try:\n            stdo = subprocess.check_output(['csc', '/version'])\n        except subprocess.CalledProcessError:\n            return True\n        # Having incrementing version numbers would be too easy.\n        # Microsoft reset the versioning back to 1.0 (from 4.x)\n        # when they got the Roslyn based compiler. Thus there\n        # is NO WAY to reliably do version number comparisons.\n        # Only support the version that ships with VS2017.\n        return not stdo.startswith(b'2.')\n    return True\n\n# In Azure some setups have a broken rustc that will error out\n# on all compilation attempts.\n\ndef has_broken_rustc() -> bool:\n    dirname = Path('brokenrusttest')\n    if dirname.exists():\n        mesonlib.windows_proof_rmtree(dirname.as_posix())\n    dirname.mkdir()\n    sanity_file = dirname / 'sanity.rs'\n    sanity_file.write_text('fn main() {\\n}\\n', encoding='utf-8')\n    pc = subprocess.run(['rustc', '-o', 'sanity.exe', 'sanity.rs'],\n                        cwd=dirname.as_posix(),\n                        stdout = subprocess.DEVNULL,\n                        stderr = subprocess.DEVNULL)\n    mesonlib.windows_proof_rmtree(dirname.as_posix())\n    return pc.returncode != 0\n\ndef should_skip_rust(backend: Backend) -> bool:\n    if not shutil.which('rustc'):\n        return True\n    if backend is not Backend.ninja:\n        return True\n    if mesonlib.is_windows():\n        if has_broken_rustc():\n            return True\n    return False\n\ndef should_skip_wayland() -> bool:\n    if mesonlib.is_windows() or mesonlib.is_osx():\n        return True\n    if not shutil.which('wayland-scanner'):\n        return True\n    return False\n\ndef detect_tests_to_run(only: T.Dict[str, T.List[str]], use_tmp: bool) -> T.List[T.Tuple[str, T.List[TestDef], bool]]:\n    \"\"\"\n    Parameters\n    ----------\n    only: dict of categories and list of test cases, optional\n        specify names of tests to run\n\n    Returns\n    -------\n    gathered_tests: list of tuple of str, list of TestDef, bool\n        tests to run\n    \"\"\"\n\n    skip_fortran = not(shutil.which('gfortran') or\n                       shutil.which('flang-new') or\n                       shutil.which('flang') or\n                       shutil.which('pgfortran') or\n                       shutil.which('nagfor') or\n                       shutil.which('ifort') or\n                       shutil.which('ifx'))\n\n    skip_cmake = ((os.environ.get('compiler') == 'msvc2015' and under_ci) or\n                  'cmake' not in tool_vers_map or\n                  not mesonlib.version_compare(tool_vers_map['cmake'], '>=3.14'))\n\n    class TestCategory:\n        def __init__(self, category: str, subdir: str, skip: bool = False, stdout_mandatory: bool = False):\n            self.category = category                  # category name\n            self.subdir = subdir                      # subdirectory\n            self.skip = skip                          # skip condition\n            self.stdout_mandatory = stdout_mandatory  # expected stdout is mandatory for tests in this category\n\n    all_tests = [\n        TestCategory('cmake', 'cmake', skip_cmake),\n        TestCategory('common', 'common'),\n        TestCategory('native', 'native'),\n        TestCategory('warning-meson', 'warning', stdout_mandatory=True),\n        TestCategory('failing-meson', 'failing', stdout_mandatory=True),\n        TestCategory('failing-build', 'failing build'),\n        TestCategory('failing-test',  'failing test'),\n        TestCategory('keyval', 'keyval'),\n        TestCategory('platform-osx', 'osx', not mesonlib.is_osx()),\n        TestCategory('platform-windows', 'windows', not mesonlib.is_windows() and not mesonlib.is_cygwin()),\n        TestCategory('platform-linux', 'linuxlike', mesonlib.is_osx() or mesonlib.is_windows()),\n        TestCategory('java', 'java', backend is not Backend.ninja or not have_java()),\n        TestCategory('C#', 'csharp', skip_csharp(backend)),\n        TestCategory('vala', 'vala', backend is not Backend.ninja or not shutil.which(os.environ.get('VALAC', 'valac'))),\n        TestCategory('cython', 'cython', backend is not Backend.ninja or not have_cython_compiler(options.use_tmpdir)),\n        TestCategory('rust', 'rust', should_skip_rust(backend)),\n        TestCategory('d', 'd', backend is not Backend.ninja or not have_d_compiler()),\n        TestCategory('objective c', 'objc', backend not in (Backend.ninja, Backend.xcode) or not have_objc_compiler(options.use_tmpdir)),\n        TestCategory('objective c++', 'objcpp', backend not in (Backend.ninja, Backend.xcode) or not have_objcpp_compiler(options.use_tmpdir)),\n        TestCategory('fortran', 'fortran', skip_fortran or backend != Backend.ninja),\n        TestCategory('swift', 'swift', backend not in (Backend.ninja, Backend.xcode) or not shutil.which('swiftc')),\n        # CUDA tests on Windows: use Ninja backend:  python run_project_tests.py --only cuda --backend ninja\n        TestCategory('cuda', 'cuda', backend not in (Backend.ninja, Backend.xcode) or not shutil.which('nvcc')),\n        TestCategory('python3', 'python3', backend is not Backend.ninja or 'python3' not in sys.executable),\n        TestCategory('python', 'python'),\n        TestCategory('fpga', 'fpga', shutil.which('yosys') is None),\n        TestCategory('frameworks', 'frameworks'),\n        TestCategory('nasm', 'nasm'),\n        TestCategory('wasm', 'wasm', shutil.which('emcc') is None or backend is not Backend.ninja),\n        TestCategory('wayland', 'wayland', should_skip_wayland()),\n        TestCategory('format', 'format'),\n    ]\n\n    categories = [t.category for t in all_tests]\n    assert categories == ALL_TESTS, 'argparse(\"--only\", choices=ALL_TESTS) need to be updated to match all_tests categories'\n\n    if only:\n        for key in only.keys():\n            assert key in categories, f'key `{key}` is not a recognized category'\n        all_tests = [t for t in all_tests if t.category in only.keys()]\n\n    gathered_tests = [(t.category, gather_tests(Path('test cases', t.subdir), t.stdout_mandatory, only[t.category], t.skip), t.skip) for t in all_tests]\n    return gathered_tests\n\ndef run_tests(all_tests: T.List[T.Tuple[str, T.List[TestDef], bool]],\n              log_name_base: str,\n              failfast: bool,\n              extra_args: T.List[str],\n              use_tmp: bool,\n              num_workers: int) -> T.Tuple[int, int, int]:\n    txtname = log_name_base + '.txt'\n    with open(txtname, 'w', encoding='utf-8', errors='ignore') as lf:\n        return _run_tests(all_tests, log_name_base, failfast, extra_args, use_tmp, num_workers, lf)\n\nclass TestStatus(Enum):\n    OK = normal_green(' [SUCCESS] ')\n    SKIP = yellow(' [SKIPPED] ')\n    ERROR = red('  [ERROR]  ')\n    UNEXSKIP = red('[UNEXSKIP] ')\n    UNEXRUN = red(' [UNEXRUN] ')\n    CANCELED = cyan('[CANCELED] ')\n    RUNNING = blue(' [RUNNING] ')  # Should never be actually printed\n    LOG = bold('   [LOG]   ')      # Should never be actually printed\n\ndef default_print(*args: mlog.TV_Loggable, sep: str = ' ') -> None:\n    print(*args, sep=sep)\n\nsafe_print = default_print\n\nclass TestRunFuture:\n    def __init__(self, name: str, testdef: TestDef, future: T.Optional['Future[T.Optional[TestResult]]']) -> None:\n        super().__init__()\n        self.name = name\n        self.testdef = testdef\n        self.future = future\n        self.status = TestStatus.RUNNING if self.future is not None else TestStatus.SKIP\n\n    @property\n    def result(self) -> T.Optional[TestResult]:\n        return self.future.result() if self.future else None\n\n    def log(self) -> None:\n        if verbose_output or self.status.value != TestStatus.OK.value:\n            without_install = '' if install_commands else '(without install)'\n            safe_print(self.status.value, without_install, *self.testdef.display_name())\n\n    def update_log(self, new_status: TestStatus) -> None:\n        self.status = new_status\n        self.log()\n\n    def cancel(self) -> None:\n        if self.future is not None and self.future.cancel():\n            self.status = TestStatus.CANCELED\n\nclass LogRunFuture:\n    def __init__(self, msgs: mlog.TV_LoggableList) -> None:\n        self.msgs = msgs\n        self.status = TestStatus.LOG\n\n    def log(self) -> None:\n        safe_print(*self.msgs, sep='')\n\n    def cancel(self) -> None:\n        pass\n\nRunFutureUnion = T.Union[TestRunFuture, LogRunFuture]\n\ndef _run_tests(all_tests: T.List[T.Tuple[str, T.List[TestDef], bool]],\n               log_name_base: str,\n               failfast: bool,\n               extra_args: T.List[str],\n               use_tmp: bool,\n               num_workers: int,\n               logfile: T.TextIO) -> T.Tuple[int, int, int]:\n    global stop, host_c_compiler\n    xmlname = log_name_base + '.xml'\n    junit_root = ET.Element('testsuites')\n    conf_time:  float = 0\n    build_time: float = 0\n    test_time:  float = 0\n    passing_tests = 0\n    failing_tests = 0\n    skipped_tests = 0\n\n    print(f'\\nRunning tests with {num_workers} workers')\n\n    # Pack the global state\n    state = GlobalState(compile_commands, clean_commands, test_commands, install_commands, uninstall_commands, backend, backend_flags, host_c_compiler)\n    executor = ProcessPoolExecutor(max_workers=num_workers)\n\n    futures: T.List[RunFutureUnion] = []\n\n    # First, collect and start all tests and also queue log messages\n    for name, test_cases, skipped in all_tests:\n        current_suite = ET.SubElement(junit_root, 'testsuite', {'name': name, 'tests': str(len(test_cases))})\n        if skipped:\n            futures += [LogRunFuture(['\\n', bold(f'Not running {name} tests.'), '\\n'])]\n            continue\n        else:\n            futures += [LogRunFuture(['\\n', bold(f'Running {name} tests.'), '\\n'])]\n\n        for t in test_cases:\n            # Jenkins screws us over by automatically sorting test cases by name\n            # and getting it wrong by not doing logical number sorting.\n            (testnum, testbase) = t.path.name.split(' ', 1)\n            testname = '%.3d %s' % (int(testnum), testbase)\n            if t.name:\n                testname += f' ({t.name})'\n            should_fail = ''\n            suite_args = []\n            if name.startswith('failing'):\n                should_fail = name.split('failing-')[1]\n            if name.startswith('warning'):\n                suite_args = ['--fatal-meson-warnings']\n                should_fail = name.split('warning-')[1]\n\n            if skipped or t.skip:\n                futures += [TestRunFuture(testname, t, None)]\n                continue\n            result_future = executor.submit(run_test, t, extra_args + suite_args + t.args, should_fail, use_tmp, state=state)\n            futures += [TestRunFuture(testname, t, result_future)]\n\n    # Ensure we only cancel once\n    tests_canceled = False\n\n    # Optionally enable the tqdm progress bar, but only if there is at least\n    # one LogRunFuture and one TestRunFuture\n    global safe_print\n    futures_iter: T.Iterable[RunFutureUnion] = futures\n    if len(futures) > 2 and sys.stdout.isatty():\n        try:\n            from tqdm import tqdm\n            futures_iter = tqdm(futures, desc='Running tests', unit='test')\n\n            def tqdm_print(*args: mlog.TV_Loggable, sep: str = ' ') -> None:\n                tqdm.write(sep.join([str(x) for x in args]))\n\n            safe_print = tqdm_print\n        except ImportError:\n            pass\n\n    # Wait and handle the test results and print the stored log output\n    for f in futures_iter:\n        # Just a log entry to print something to stdout\n        sys.stdout.flush()\n        if isinstance(f, LogRunFuture):\n            f.log()\n            continue\n\n        # Actual Test run\n        testname = f.name\n        t        = f.testdef\n        try:\n            result = f.result\n        except (CancelledError, KeyboardInterrupt):\n            f.status = TestStatus.CANCELED\n\n        if stop and not tests_canceled:\n            num_running = sum(1 if f2.status is TestStatus.RUNNING  else 0 for f2 in futures)\n            for f2 in futures:\n                f2.cancel()\n            executor.shutdown()\n            num_canceled = sum(1 if f2.status is TestStatus.CANCELED else 0 for f2 in futures)\n            safe_print(f'\\nCanceled {num_canceled} out of {num_running} running tests.')\n            safe_print(f'Finishing the remaining {num_running - num_canceled} tests.\\n')\n            tests_canceled = True\n\n        # Handle canceled tests\n        if f.status is TestStatus.CANCELED:\n            f.log()\n            continue\n\n        # Handle skipped tests\n        if result is None:\n            # skipped due to skipped category skip or 'tools:' or 'skip_on_env:'\n            is_skipped = True\n            skip_reason = 'not run because preconditions were not met'\n            skip_as_expected = True\n        else:\n            # skipped due to test outputting 'MESON_SKIP_TEST'\n            is_skipped, skip_reason = handle_meson_skip_test(result.stdo)\n            if not skip_dont_care(t):\n                skip_as_expected = (is_skipped == t.skip_expected)\n            else:\n                skip_as_expected = True\n\n        if is_skipped:\n            skipped_tests += 1\n\n        if is_skipped and skip_as_expected:\n            f.update_log(TestStatus.SKIP)\n            if not t.skip_category:\n                safe_print(bold('Reason:'), skip_reason)\n            current_test = ET.SubElement(current_suite, 'testcase', {'name': testname, 'classname': t.category})\n            ET.SubElement(current_test, 'skipped', {})\n            continue\n\n        if not skip_as_expected:\n            failing_tests += 1\n            if is_skipped:\n                skip_msg = f'Test asked to be skipped ({skip_reason}), but was not expected to'\n                status = TestStatus.UNEXSKIP\n            else:\n                skip_msg = 'Test ran, but was expected to be skipped'\n                status = TestStatus.UNEXRUN\n            result.msg = f\"{skip_msg} for MESON_CI_JOBNAME '{ci_jobname}'\"\n\n            f.update_log(status)\n            safe_print(bold('Reason:'), result.msg)\n            current_test = ET.SubElement(current_suite, 'testcase', {'name': testname, 'classname': t.category})\n            ET.SubElement(current_test, 'failure', {'message': result.msg})\n            continue\n\n        # Handle Failed tests\n        if result.msg != '':\n            f.update_log(TestStatus.ERROR)\n            safe_print(bold('During:'), result.step.name)\n            safe_print(bold('Reason:'), result.msg)\n            failing_tests += 1\n            # Append a visual separator for the different test cases\n            cols = shutil.get_terminal_size((100, 20)).columns\n            name_str = ' '.join([str(x) for x in f.testdef.display_name()])\n            name_len = len(re.sub(r'\\x1B[^m]+m', '', name_str))  # Do not count escape sequences\n            left_w = (cols // 2) - (name_len // 2) - 1\n            left_w = max(3, left_w)\n            right_w = cols - left_w - name_len - 2\n            right_w = max(3, right_w)\n            failing_testcases.append(name_str)\n            failing_logs.append(f'\\n\\x1b[31m{\"=\"*left_w}\\x1b[0m {name_str} \\x1b[31m{\"=\"*right_w}\\x1b[0m\\n')\n            _during = bold('Failed during:')\n            _reason = bold('Reason:')\n            failing_logs.append(f'{_during} {result.step.name}\\n{_reason} {result.msg}\\n')\n            if result.step == BuildStep.configure and result.mlog != no_meson_log_msg:\n                # For configure failures, instead of printing stdout,\n                # print the meson log if available since it's a superset\n                # of stdout and often has very useful information.\n                failing_logs.append(result.mlog)\n            elif under_ci:\n                # Always print the complete meson log when running in\n                # a CI. This helps debugging issues that only occur in\n                # a hard to reproduce environment\n                failing_logs.append(result.mlog)\n                failing_logs.append(result.stdo)\n            else:\n                failing_logs.append(result.stdo)\n            for cmd_res in result.cicmds:\n                failing_logs.append(cmd_res)\n            failing_logs.append(result.stde)\n            if failfast:\n                safe_print(\"Cancelling the rest of the tests\")\n                for f2 in futures:\n                    f2.cancel()\n        else:\n            f.update_log(TestStatus.OK)\n            passing_tests += 1\n            for cleanup_path in t.cleanup:\n                assert not os.path.isabs(cleanup_path)\n                abspath = t.path / cleanup_path\n                if abspath.is_file():\n                    mesonlib.windows_proof_rm(abspath)\n                else:\n                    mesonlib.windows_proof_rmtree(abspath)\n        conf_time += result.conftime\n        build_time += result.buildtime\n        test_time += result.testtime\n        total_time = conf_time + build_time + test_time\n        log_text_file(logfile, t.path, result)\n        current_test = ET.SubElement(\n            current_suite,\n            'testcase',\n            {'name': testname, 'classname': t.category, 'time': '%.3f' % total_time}\n        )\n        if result.msg != '':\n            ET.SubElement(current_test, 'failure', {'message': result.msg})\n        stdoel = ET.SubElement(current_test, 'system-out')\n        stdoel.text = result.stdo\n        stdeel = ET.SubElement(current_test, 'system-err')\n        stdeel.text = result.stde\n\n    # Reset, just in case\n    safe_print = default_print\n\n    print()\n    print(\"Total configuration time: %.2fs\" % conf_time)\n    print(\"Total build time:         %.2fs\" % build_time)\n    print(\"Total test time:          %.2fs\" % test_time)\n    ET.ElementTree(element=junit_root).write(xmlname, xml_declaration=True, encoding='UTF-8')\n    return passing_tests, failing_tests, skipped_tests\n\ndef check_meson_commands_work(use_tmpdir: bool, extra_args: T.List[str]) -> None:\n    global backend, compile_commands, test_commands, install_commands\n    testdir = PurePath('test cases', 'common', '1 trivial').as_posix()\n    meson_commands = mesonlib.python_command + [get_meson_script()]\n    with TemporaryDirectoryWinProof(prefix='b ', dir=None if use_tmpdir else '.') as build_dir:\n        print('Checking that configuring works...')\n        gen_cmd = meson_commands + ['setup' , testdir, build_dir] + backend_flags + extra_args\n        pc, o, e = Popen_safe(gen_cmd)\n        if pc.returncode != 0:\n            raise RuntimeError(f'Failed to configure {testdir!r}:\\n{e}\\n{o}')\n        print('Checking that introspect works...')\n        pc, o, e = Popen_safe(meson_commands + ['introspect', '--targets'], cwd=build_dir)\n        json.loads(o)\n        if pc.returncode != 0:\n            raise RuntimeError(f'Failed to introspect --targets {testdir!r}:\\n{e}\\n{o}')\n        print('Checking that building works...')\n        dir_args = get_backend_args_for_dir(backend, build_dir)\n        pc, o, e = Popen_safe(compile_commands + dir_args, cwd=build_dir)\n        if pc.returncode != 0:\n            raise RuntimeError(f'Failed to build {testdir!r}:\\n{e}\\n{o}')\n        print('Checking that testing works...')\n        pc, o, e = Popen_safe(test_commands, cwd=build_dir)\n        if pc.returncode != 0:\n            raise RuntimeError(f'Failed to test {testdir!r}:\\n{e}\\n{o}')\n        if install_commands:\n            print('Checking that installing works...')\n            pc, o, e = Popen_safe(install_commands, cwd=build_dir)\n            if pc.returncode != 0:\n                raise RuntimeError(f'Failed to install {testdir!r}:\\n{e}\\n{o}')\n\n\ndef detect_system_compiler(options: 'CompilerArgumentType') -> None:\n    global host_c_compiler, compiler_id_map\n\n    fake_opts = get_fake_options('/')\n    if options.cross_file:\n        fake_opts.cross_file = [options.cross_file]\n    if options.native_file:\n        fake_opts.native_file = [options.native_file]\n\n    env = environment.Environment('', '', fake_opts)\n\n    print_compilers(env, MachineChoice.HOST)\n    if options.cross_file:\n        print_compilers(env, MachineChoice.BUILD)\n\n    for lang in sorted(compilers.all_languages):\n        try:\n            comp = compiler_from_language(env, lang, MachineChoice.HOST)\n            # note compiler id for later use with test.json matrix\n            compiler_id_map[lang] = comp.get_id()\n        except mesonlib.MesonException:\n            comp = None\n\n        # note C compiler for later use by platform_fix_name()\n        if lang == 'c':\n            if comp:\n                host_c_compiler = comp.get_id()\n            else:\n                raise RuntimeError(\"Could not find C compiler.\")\n\n\ndef print_compilers(env: 'Environment', machine: MachineChoice) -> None:\n    print()\n    print(f'{machine.get_lower_case_name()} machine compilers')\n    print()\n    for lang in sorted(compilers.all_languages):\n        try:\n            comp = compiler_from_language(env, lang, machine)\n            details = '{:<10} {} {}'.format('[' + comp.get_id() + ']', ' '.join(comp.get_exelist()), comp.get_version_string())\n        except mesonlib.MesonException:\n            details = '[not found]'\n        print(f'{lang:<7}: {details}')\n\nclass ToolInfo(T.NamedTuple):\n    tool: str\n    args: T.List[str]\n    regex: T.Pattern\n    match_group: int\n\ndef detect_tools(report: bool = True) -> None:\n    tools: T.List[ToolInfo] = [\n        ToolInfo(\n            'ninja',\n            ['--version'],\n            re.compile(r'^([0-9]+(\\.[0-9]+)*(-[a-z0-9]+)?)$'),\n            1,\n        ),\n        ToolInfo(\n            'cmake',\n            ['--version'],\n            re.compile(r'^cmake version ([0-9]+(\\.[0-9]+)*(-[a-z0-9]+)?)$'),\n            1,\n        ),\n        ToolInfo(\n            'hotdoc',\n            ['--version'],\n            re.compile(r'^([0-9]+(\\.[0-9]+)*(-[a-z0-9]+)?)$'),\n            1,\n        ),\n    ]\n\n    def get_version(t: ToolInfo) -> str:\n        exe = shutil.which(t.tool)\n        if not exe:\n            return 'not found'\n\n        args = [t.tool] + t.args\n        pc, o, e = Popen_safe(args)\n        if pc.returncode != 0:\n            return f'{exe} (invalid {t.tool} executable)'\n        for i in o.split('\\n'):\n            i = i.strip('\\n\\r\\t ')\n            m = t.regex.match(i)\n            if m is not None:\n                tool_vers_map[t.tool] = m.group(t.match_group)\n                return '{} ({})'.format(exe, m.group(t.match_group))\n\n        return f'{exe} (unknown)'\n\n    if not report:\n        for tool in tools:\n            get_version(tool)\n        return\n\n    print()\n    print('tools')\n    print()\n\n    max_width = max([len(x.tool) for x in tools] + [7])\n    for tool in tools:\n        print('{0:<{2}}: {1}'.format(tool.tool, get_version(tool), max_width))\n    print()\n\nsymlink_test_dir1 = None\nsymlink_test_dir2 = None\nsymlink_file1 = None\nsymlink_file2 = None\nsymlink_file3 = None\n\ndef scan_test_data_symlinks() -> None:\n    global symlink_test_dir1, symlink_test_dir2, symlink_file1, symlink_file2, symlink_file3\n    tmpdir1 = list(Path('.').glob('test cases/**/*install functions and follow symlinks'))\n    tmpdir2 = list(Path('.').glob('test cases/frameworks/*boost symlinks'))\n    assert len(tmpdir1) == 1\n    assert len(tmpdir2) == 1\n    symlink_test_dir1 = tmpdir1[0]\n    symlink_test_dir2 = tmpdir2[0] / 'boost/include'\n    symlink_file1 = symlink_test_dir1 / 'foo/link1'\n    symlink_file2 = symlink_test_dir1 / 'foo/link2.h'\n    symlink_file3 = symlink_test_dir2 / 'boost'\n\ndef clear_transitive_files() -> None:\n    a = Path('test cases/common')\n    for d in a.glob('*subproject subdir/subprojects/subsubsub*'):\n        if d.is_dir():\n            mesonlib.windows_proof_rmtree(str(d))\n        else:\n            mesonlib.windows_proof_rm(str(d))\n    try:\n        if symlink_file1 is not None:\n            symlink_file1.unlink()\n    except FileNotFoundError:\n        pass\n    try:\n        if symlink_file2 is not None:\n            symlink_file2.unlink()\n    except FileNotFoundError:\n        pass\n    try:\n        if symlink_file3 is not None:\n            symlink_file3.unlink()\n            symlink_test_dir2.rmdir()\n    except FileNotFoundError:\n        pass\n\ndef setup_symlinks() -> None:\n    try:\n        symlink_file1.symlink_to('file1')\n        symlink_file2.symlink_to('file1')\n        symlink_test_dir2.mkdir(parents=True, exist_ok=True)\n        symlink_file3.symlink_to('../Cellar/boost/0.3.0/include/boost')\n    except OSError:\n        print('symlinks are not supported on this system')\n\nif __name__ == '__main__':\n    if under_ci and not raw_ci_jobname:\n        raise SystemExit('Running under CI but $MESON_CI_JOBNAME is not set (set to \"thirdparty\" if you are running outside of the github org)')\n\n    setup_vsenv()\n    try:\n        # This fails in some CI environments for unknown reasons.\n        num_workers = multiprocessing.cpu_count()\n    except Exception as e:\n        print('Could not determine number of CPUs due to the following reason:', str(e))\n        print('Defaulting to using only two processes')\n        num_workers = 2\n\n    if num_workers > 64:\n        # Too much parallelism seems to trigger a potential Python bug:\n        # https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=1004107\n        num_workers = 64\n\n    parser = argparse.ArgumentParser(description=\"Run the test suite of Meson.\")\n    parser.add_argument('extra_args', nargs='*',\n                        help='arguments that are passed directly to Meson (remember to have -- before these).')\n    parser.add_argument('--backend', dest='backend', choices=backendlist)\n    parser.add_argument('-j', dest='num_workers', type=int, default=num_workers,\n                        help=f'Maximum number of parallel tests (default {num_workers})')\n    parser.add_argument('--failfast', action='store_true',\n                        help='Stop running if test case fails')\n    parser.add_argument('--no-unittests', action='store_true',\n                        help='Not used, only here to simplify run_tests.py')\n    parser.add_argument('--only', default=[],\n                        help='name of test(s) to run, in format \"category[/name]\" where category is one of: ' + ', '.join(ALL_TESTS), nargs='+')\n    parser.add_argument('-v', default=False, action='store_true',\n                        help='Verbose mode')\n    parser.add_argument('--cross-file', action='store', help='File describing cross compilation environment.')\n    parser.add_argument('--native-file', action='store', help='File describing native compilation environment.')\n    parser.add_argument('--use-tmpdir', action='store_true', help='Use tmp directory for temporary files.')\n    options = T.cast('ArgumentType', parser.parse_args())\n    verbose_output = options.v\n\n    if options.cross_file:\n        options.extra_args += ['--cross-file', options.cross_file]\n    if options.native_file:\n        options.extra_args += ['--native-file', options.native_file]\n\n    if not mesonlib.is_windows():\n        scan_test_data_symlinks()\n    clear_transitive_files()\n    if not mesonlib.is_windows():\n        setup_symlinks()\n    mesonlib.set_meson_command(get_meson_script())\n\n    print('Meson build system', meson_version, 'Project Tests')\n    print('Using python', sys.version.split('\\n')[0], f'({sys.executable!r})')\n    if 'VSCMD_VER' in os.environ:\n        print('VSCMD version', os.environ['VSCMD_VER'])\n    setup_commands(options.backend)\n    detect_system_compiler(options)\n    detect_tools()\n    script_dir = os.path.split(__file__)[0]\n    if script_dir != '':\n        os.chdir(script_dir)\n    check_meson_commands_work(options.use_tmpdir, options.extra_args)\n    only = collections.defaultdict(list)\n    for i in options.only:\n        try:\n            cat, case = i.split('/')\n            only[cat].append(case)\n        except ValueError:\n            only[i].append('')\n    try:\n        all_tests = detect_tests_to_run(only, options.use_tmpdir)\n        res = run_tests(all_tests, 'meson-test-run', options.failfast, options.extra_args, options.use_tmpdir, options.num_workers)\n        (passing_tests, failing_tests, skipped_tests) = res\n    except StopException:\n        pass\n    if failing_tests > 0:\n        print('\\nMesonlogs of failing tests\\n')\n        for l in failing_logs:\n            try:\n                print(l, '\\n')\n            except UnicodeError:\n                print(l.encode('ascii', errors='replace').decode(), '\\n')\n    print()\n    print('Total passed tests: ', green(str(passing_tests)))\n    print('Total failed tests: ', red(str(failing_tests)))\n    print('Total skipped tests:', yellow(str(skipped_tests)))\n    if failing_tests > 0:\n        print('\\nAll failures:')\n        for c in failing_testcases:\n            print(f'  -> {c}')\n    for name, dirs, _ in all_tests:\n        dir_names = list({x.path.name for x in dirs})\n        for k, g in itertools.groupby(dir_names, key=lambda x: x.split()[0]):\n            tests = list(g)\n            if len(tests) != 1:\n                print('WARNING: The {} suite contains duplicate \"{}\" tests: \"{}\"'.format(name, k, '\", \"'.join(tests)))\n    clear_transitive_files()\n    raise SystemExit(failing_tests)\n"
        },
        {
          "name": "run_single_test.py",
          "type": "blob",
          "size": 4.033203125,
          "content": "#!/usr/bin/env python3\n# SPDX-License-Identifier: Apache-2.0\n# Copyright © 2021-2024 Intel Corporation\n\n\"\"\"Script for running a single project test.\n\nThis script is meant for Meson developers who want to run a single project\ntest, with all of the rules from the test.json file loaded.\n\"\"\"\n\nimport argparse\nimport pathlib\nimport typing as T\n\nfrom mesonbuild import mlog\nfrom mesonbuild.mesonlib import is_windows\nfrom run_tests import handle_meson_skip_test\nfrom run_project_tests import TestDef, load_test_json, run_test, BuildStep\nfrom run_project_tests import setup_commands, detect_system_compiler, detect_tools\nfrom run_project_tests import scan_test_data_symlinks, setup_symlinks, clear_transitive_files\n\nif T.TYPE_CHECKING:\n    from run_project_tests import CompilerArgumentType\n\n    class ArgumentType(CompilerArgumentType):\n\n        \"\"\"Typing information for command line arguments.\"\"\"\n\n        case: pathlib.Path\n        subtests: T.List[int]\n        backend: str\n        extra_args: T.List[str]\n        quick: bool\n\n\ndef main() -> None:\n    parser = argparse.ArgumentParser()\n    parser.add_argument('case', type=pathlib.Path, help='The test case to run')\n    parser.add_argument('extra_args', nargs='*',\n                        help='arguments that are passed directly to Meson (remember to have -- before these).')\n    parser.add_argument('--subtest', type=int, action='append', dest='subtests', help='which subtests to run')\n    parser.add_argument('--backend', action='store', help=\"Which backend to use\")\n    parser.add_argument('--cross-file', action='store', help='File describing cross compilation environment.')\n    parser.add_argument('--native-file', action='store', help='File describing native compilation environment.')\n    parser.add_argument('--use-tmpdir', action='store_true', help='Use tmp directory for temporary files.')\n    parser.add_argument('--quick', action='store_true', help='Skip some compiler and tool checking')\n    args = T.cast('ArgumentType', parser.parse_args())\n\n    if not is_windows():\n        scan_test_data_symlinks()\n        setup_symlinks()\n    setup_commands(args.backend)\n    if not args.quick:\n        detect_system_compiler(args)\n    detect_tools(not args.quick)\n\n    test = TestDef(args.case, args.case.stem, [])\n    tests = load_test_json(test, False)\n    if args.subtests:\n        tests = [t for i, t in enumerate(tests) if i in args.subtests]\n\n    def should_fail(path: pathlib.Path) -> str:\n        dir_ = path.parent.stem\n        # FIXME: warning tets might not be handled correctly still…\n        if dir_.startswith(('failing', 'warning')):\n            if ' ' in dir_:\n                return dir_.split(' ')[1]\n            return 'meson'\n        return ''\n\n    results = [run_test(t, t.args + args.extra_args, should_fail(t.path), args.use_tmpdir) for t in tests]\n    failed = False\n    for test, result in zip(tests, results):\n        if result is None:\n            is_skipped = True\n            skip_reason = 'not run because preconditions were not met'\n        else:\n            is_skipped, skip_reason = handle_meson_skip_test(result.stdo)\n\n        if is_skipped:\n            msg = mlog.yellow('SKIP:')\n        elif result.msg:\n            msg = mlog.red('FAIL:')\n            failed = True\n        else:\n            msg = mlog.green('PASS:')\n        mlog.log(msg, *test.display_name())\n        if skip_reason:\n            mlog.log(mlog.bold('Reason:'), skip_reason)\n        if result is not None and result.msg and 'MESON_SKIP_TEST' not in result.stdo:\n            mlog.log('reason:', result.msg)\n            if result.step is BuildStep.configure:\n                # For configure failures, instead of printing stdout,\n                # print the meson log if available since it's a superset\n                # of stdout and often has very useful information.\n                mlog.log(result.mlog)\n            else:\n                mlog.log(result.stdo)\n            for cmd_res in result.cicmds:\n                mlog.log(cmd_res)\n            mlog.log(result.stde)\n\n    clear_transitive_files()\n    exit(1 if failed else 0)\n\nif __name__ == \"__main__\":\n    main()\n"
        },
        {
          "name": "run_tests.py",
          "type": "blob",
          "size": 15.97265625,
          "content": "#!/usr/bin/env python3\n# SPDX-License-Identifier: Apache-2.0\n# Copyright 2012-2021 The Meson development team\n# Copyright © 2023-2024 Intel Corporation\n\nfrom __future__ import annotations\n\n# Work around some pathlib bugs...\nfrom mesonbuild import _pathlib\nimport sys\nsys.modules['pathlib'] = _pathlib\n\nimport collections\nimport os\nimport time\nimport shutil\nimport subprocess\nimport platform\nimport argparse\nimport traceback\nfrom io import StringIO\nfrom enum import Enum\nfrom glob import glob\nfrom pathlib import Path\nfrom unittest import mock\nimport typing as T\n\nfrom mesonbuild.compilers.c import CCompiler\nfrom mesonbuild.compilers.detect import detect_c_compiler\nfrom mesonbuild.dependencies.pkgconfig import PkgConfigInterface\nfrom mesonbuild import mesonlib\nfrom mesonbuild import mesonmain\nfrom mesonbuild import mtest\nfrom mesonbuild import mlog\nfrom mesonbuild.environment import Environment, detect_ninja, detect_machine_info\nfrom mesonbuild.coredata import version as meson_version\nfrom mesonbuild.options import backendlist\nfrom mesonbuild.mesonlib import setup_vsenv\nfrom mesonbuild.options import OptionKey\n\nif T.TYPE_CHECKING:\n    from mesonbuild.coredata import SharedCMDOptions\n\nNINJA_1_12_OR_NEWER = False\nNINJA_CMD = None\n# If we're on CI, detecting ninja for every subprocess unit test that we run is slow\n# Optimize this by respecting $NINJA and skipping detection, then exporting it on\n# first run.\ntry:\n    NINJA_1_12_OR_NEWER = bool(int(os.environ['NINJA_1_12_OR_NEWER']))\n    NINJA_CMD = [os.environ['NINJA']]\nexcept (KeyError, ValueError):\n    # Look for 1.12, which removes -w dupbuild=err\n    NINJA_CMD = detect_ninja('1.12')\n    if NINJA_CMD is not None:\n        NINJA_1_12_OR_NEWER = True\n    else:\n        NINJA_CMD = detect_ninja()\n\nif NINJA_CMD is not None:\n    os.environ['NINJA_1_12_OR_NEWER'] = str(int(NINJA_1_12_OR_NEWER))\n    os.environ['NINJA'] = NINJA_CMD[0]\nelse:\n    raise RuntimeError('Could not find Ninja.')\n\n# Emulate running meson with -X utf8 by making sure all open() calls have a\n# sane encoding. This should be a python default, but PEP 540 considered it not\n# backwards compatible. Instead, much line noise in diffs to update this, and in\n# python 3.10 we can also make it a warning when absent.\nos.environ['PYTHONWARNDEFAULTENCODING'] = '1'\n# work around https://bugs.python.org/issue34624\nos.environ['MESON_RUNNING_IN_PROJECT_TESTS'] = '1'\n# python 3.11 adds a warning that in 3.15, UTF-8 mode will be default.\n# This is fantastic news, we'd love that. Less fantastic: this warning is silly,\n# we *want* these checks to be affected. Plus, the recommended alternative API\n# would (in addition to warning people when UTF-8 mode removed the problem) also\n# require using a minimum python version of 3.11 (in which the warning was added)\n# or add verbose if/else soup.\nif sys.version_info >= (3, 10):\n    import warnings\n    warnings.filterwarnings('ignore', message=\"UTF-8 Mode affects .*getpreferredencoding\", category=EncodingWarning)\n\ndef guess_backend(backend_str: str, msbuild_exe: str) -> T.Tuple['Backend', T.List[str]]:\n    # Auto-detect backend if unspecified\n    backend_flags = []\n    if backend_str is None:\n        if msbuild_exe is not None and (mesonlib.is_windows() and not _using_intelcl()):\n            backend_str = 'vs' # Meson will auto-detect VS version to use\n        else:\n            backend_str = 'ninja'\n\n    # Set backend arguments for Meson\n    if backend_str.startswith('vs'):\n        backend_flags = ['--backend=' + backend_str]\n        backend = Backend.vs\n    elif backend_str == 'xcode':\n        backend_flags = ['--backend=xcode']\n        backend = Backend.xcode\n    elif backend_str == 'ninja':\n        backend_flags = ['--backend=ninja']\n        backend = Backend.ninja\n    else:\n        raise RuntimeError(f'Unknown backend: {backend_str!r}')\n    return (backend, backend_flags)\n\n\ndef _using_intelcl() -> bool:\n    \"\"\"\n    detect if intending to using Intel-Cl compilers (Intel compilers on Windows)\n    Sufficient evidence of intent is that user is working in the Intel compiler\n    shell environment, otherwise this function returns False\n    \"\"\"\n    if not mesonlib.is_windows():\n        return False\n    # handle where user tried to \"blank\" MKLROOT and left space(s)\n    if not os.environ.get('MKLROOT', '').strip():\n        return False\n    if (os.environ.get('CC') == 'icl' or\n            os.environ.get('CXX') == 'icl' or\n            os.environ.get('FC') == 'ifort'):\n        return True\n    # Intel-Cl users might not have the CC,CXX,FC envvars set,\n    # but because they're in Intel shell, the exe's below are on PATH\n    if shutil.which('icl') or shutil.which('ifort'):\n        return True\n    mlog.warning('It appears you might be intending to use Intel compiler on Windows '\n                 'since non-empty environment variable MKLROOT is set to {} '\n                 'However, Meson cannot find the Intel WIndows compiler executables (icl,ifort).'\n                 'Please try using the Intel shell.'.format(os.environ.get('MKLROOT')))\n    return False\n\n\n# Fake classes and objects for mocking\nclass FakeBuild:\n    def __init__(self, env):\n        self.environment = env\n\nclass FakeCompilerOptions:\n    def __init__(self):\n        self.value = []\n\ndef get_fake_options(prefix: str = '') -> SharedCMDOptions:\n    opts = T.cast('SharedCMDOptions', argparse.Namespace())\n    opts.native_file = []\n    opts.cross_file = None\n    opts.wrap_mode = None\n    opts.prefix = prefix\n    opts.cmd_line_options = {}\n    return opts\n\ndef get_fake_env(sdir: str = '', bdir: T.Optional[str] = None, prefix: str = '',\n                 opts: T.Optional[SharedCMDOptions] = None) -> Environment:\n    if opts is None:\n        opts = get_fake_options(prefix)\n    env = Environment(sdir, bdir, opts)\n    env.coredata.optstore.set_value_object(OptionKey('c_args'),  FakeCompilerOptions())\n    env.machines.host.cpu_family = 'x86_64' # Used on macOS inside find_library\n    # Invalidate cache when using a different Environment object.\n    clear_meson_configure_class_caches()\n    return env\n\ndef get_convincing_fake_env_and_cc(bdir, prefix):\n    '''\n    Return a fake env and C compiler with the fake env\n    machine info properly detected using that compiler.\n    Useful for running compiler checks in the unit tests.\n    '''\n    env = get_fake_env('', bdir, prefix)\n    cc = detect_c_compiler(env, mesonlib.MachineChoice.HOST)\n    # Detect machine info\n    env.machines.host = detect_machine_info({'c':cc})\n    return (env, cc)\n\nBackend = Enum('Backend', 'ninja vs xcode')\n\nif 'MESON_EXE' in os.environ:\n    meson_exe = mesonlib.split_args(os.environ['MESON_EXE'])\nelse:\n    meson_exe = None\n\nif mesonlib.is_windows() or mesonlib.is_cygwin():\n    exe_suffix = '.exe'\nelse:\n    exe_suffix = ''\n\ndef handle_meson_skip_test(out: str) -> T.Tuple[bool, str]:\n    for line in out.splitlines():\n        for prefix in {'Problem encountered', 'Assert failed', 'Failed to configure the CMake subproject'}:\n            if f'{prefix}: MESON_SKIP_TEST' in line:\n                offset = line.index('MESON_SKIP_TEST') + 16\n                reason = line[offset:].strip()\n                return (True, reason)\n    return (False, '')\n\ndef get_meson_script() -> str:\n    '''\n    Guess the meson that corresponds to the `mesonbuild` that has been imported\n    so we can run configure and other commands in-process, since mesonmain.run\n    needs to know the meson_command to use.\n\n    Also used by run_unittests.py to determine what meson to run when not\n    running in-process (which is the default).\n    '''\n    # Is there a meson.py next to the mesonbuild currently in use?\n    mesonbuild_dir = Path(mesonmain.__file__).resolve().parent.parent\n    meson_script = mesonbuild_dir / 'meson.py'\n    if meson_script.is_file():\n        return str(meson_script)\n    # Then if mesonbuild is in PYTHONPATH, meson must be in PATH\n    mlog.warning('Could not find meson.py next to the mesonbuild module. '\n                 'Trying system meson...')\n    meson_cmd = shutil.which('meson')\n    if meson_cmd:\n        return meson_cmd\n    raise RuntimeError(f'Could not find {meson_script!r} or a meson in PATH')\n\ndef get_backend_args_for_dir(backend: Backend, builddir: str) -> T.List[str]:\n    '''\n    Visual Studio backend needs to be given the solution to build\n    '''\n    if backend is Backend.vs:\n        sln_name = glob(os.path.join(builddir, '*.sln'))[0]\n        return [os.path.split(sln_name)[-1]]\n    return []\n\ndef find_vcxproj_with_target(builddir, target):\n    import re, fnmatch\n    t, ext = os.path.splitext(target)\n    if ext:\n        p = fr'<TargetName>{t}</TargetName>\\s*<TargetExt>\\{ext}</TargetExt>'\n    else:\n        p = fr'<TargetName>{t}</TargetName>'\n    for _, _, files in os.walk(builddir):\n        for f in fnmatch.filter(files, '*.vcxproj'):\n            f = os.path.join(builddir, f)\n            with open(f, encoding='utf-8') as o:\n                if re.search(p, o.read(), flags=re.MULTILINE):\n                    return f\n    raise RuntimeError(f'No vcxproj matching {p!r} in {builddir!r}')\n\ndef get_builddir_target_args(backend: Backend, builddir, target):\n    dir_args = []\n    if not target:\n        dir_args = get_backend_args_for_dir(backend, builddir)\n    if target is None:\n        return dir_args\n    if backend is Backend.vs:\n        vcxproj = find_vcxproj_with_target(builddir, target)\n        target_args = [vcxproj]\n    elif backend is Backend.xcode:\n        target_args = ['-target', target]\n    elif backend is Backend.ninja:\n        target_args = [target]\n    else:\n        raise AssertionError(f'Unknown backend: {backend!r}')\n    return target_args + dir_args\n\ndef get_backend_commands(backend: Backend, debug: bool = False) -> \\\n        T.Tuple[T.List[str], T.List[str], T.List[str], T.List[str], T.List[str]]:\n    install_cmd: T.List[str] = []\n    uninstall_cmd: T.List[str] = []\n    clean_cmd: T.List[str]\n    cmd: T.List[str]\n    test_cmd: T.List[str]\n    if backend is Backend.vs:\n        cmd = ['msbuild']\n        clean_cmd = cmd + ['/target:Clean']\n        test_cmd = cmd + ['RUN_TESTS.vcxproj']\n    elif backend is Backend.xcode:\n        cmd = ['xcodebuild']\n        clean_cmd = cmd + ['-alltargets', 'clean']\n        test_cmd = cmd + ['-target', 'RUN_TESTS']\n    elif backend is Backend.ninja:\n        global NINJA_CMD\n        cmd = NINJA_CMD + ['-d', 'explain']\n        if not NINJA_1_12_OR_NEWER:\n            cmd += ['-w', 'dupbuild=err']\n        if debug:\n            cmd += ['-v']\n        clean_cmd = cmd + ['clean']\n        test_cmd = cmd + ['test', 'benchmark']\n        install_cmd = cmd + ['install']\n        uninstall_cmd = cmd + ['uninstall']\n    else:\n        raise AssertionError(f'Unknown backend: {backend!r}')\n    return cmd, clean_cmd, test_cmd, install_cmd, uninstall_cmd\n\ndef run_mtest_inprocess(commandlist: T.List[str]) -> T.Tuple[int, str]:\n    out = StringIO()\n    with mock.patch.object(sys, 'stdout', out), mock.patch.object(sys, 'stderr', out):\n        returncode = mtest.run_with_args(commandlist)\n    return returncode, out.getvalue()\n\ndef clear_meson_configure_class_caches() -> None:\n    CCompiler.find_library_cache.clear()\n    CCompiler.find_framework_cache.clear()\n    PkgConfigInterface.class_impl.assign(False, False)\n    mesonlib.project_meson_versions.clear()\n\ndef run_configure_inprocess(commandlist: T.List[str], env: T.Optional[T.Dict[str, str]] = None, catch_exception: bool = False) -> T.Tuple[int, str, str]:\n    stderr = StringIO()\n    stdout = StringIO()\n    returncode = 0\n    with mock.patch.dict(os.environ, env or {}), mock.patch.object(sys, 'stdout', stdout), mock.patch.object(sys, 'stderr', stderr):\n        try:\n            returncode = mesonmain.run(commandlist, get_meson_script())\n        except Exception:\n            if catch_exception:\n                returncode = 1\n                traceback.print_exc()\n            else:\n                raise\n        finally:\n            clear_meson_configure_class_caches()\n    return returncode, stdout.getvalue(), stderr.getvalue()\n\ndef run_configure_external(full_command: T.List[str], env: T.Optional[T.Dict[str, str]] = None) -> T.Tuple[int, str, str]:\n    pc, o, e = mesonlib.Popen_safe(full_command, env=env)\n    return pc.returncode, o, e\n\ndef run_configure(commandlist: T.List[str], env: T.Optional[T.Dict[str, str]] = None, catch_exception: bool = False) -> T.Tuple[bool, T.Tuple[int, str, str]]:\n    global meson_exe\n    if meson_exe:\n        return (False, run_configure_external(meson_exe + commandlist, env=env))\n    return (True, run_configure_inprocess(commandlist, env=env, catch_exception=catch_exception))\n\ndef print_system_info():\n    print(mlog.bold('System information.'))\n    print('Architecture:', platform.architecture())\n    print('Machine:', platform.machine())\n    print('Platform:', platform.system())\n    print('Processor:', platform.processor())\n    print('System:', platform.system())\n    print('')\n    print(flush=True)\n\ndef subprocess_call(cmd, **kwargs):\n    print(f'$ {mesonlib.join_args(cmd)}')\n    return subprocess.call(cmd, **kwargs)\n\ndef main():\n    print_system_info()\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--backend', default=None, dest='backend',\n                        choices=backendlist)\n    parser.add_argument('--cross', default=[], dest='cross', action='append')\n    parser.add_argument('--cross-only', action='store_true')\n    parser.add_argument('--failfast', action='store_true')\n    parser.add_argument('--no-unittests', action='store_true', default=False)\n    (options, _) = parser.parse_known_args()\n    returncode = 0\n    _, backend_flags = guess_backend(options.backend, shutil.which('msbuild'))\n    no_unittests = options.no_unittests\n    # Running on a developer machine? Be nice!\n    if not mesonlib.is_windows() and not mesonlib.is_haiku() and 'CI' not in os.environ:\n        os.nice(20)\n    # Appveyor sets the `platform` environment variable which completely messes\n    # up building with the vs2010 and vs2015 backends.\n    #\n    # Specifically, MSBuild reads the `platform` environment variable to set\n    # the configured value for the platform (Win32/x64/arm), which breaks x86\n    # builds.\n    #\n    # Appveyor setting this also breaks our 'native build arch' detection for\n    # Windows in environment.py:detect_windows_arch() by overwriting the value\n    # of `platform` set by vcvarsall.bat.\n    #\n    # While building for x86, `platform` should be unset.\n    if 'APPVEYOR' in os.environ and os.environ['arch'] == 'x86':\n        os.environ.pop('platform')\n    # Run tests\n    # Can't pass arguments to unit tests, so set the backend to use in the environment\n    env = os.environ.copy()\n    if not options.cross:\n        cmd = mesonlib.python_command + ['run_meson_command_tests.py', '-v']\n        if options.failfast:\n            cmd += ['--failfast']\n        returncode += subprocess_call(cmd, env=env)\n        if options.failfast and returncode != 0:\n            return returncode\n        if no_unittests:\n            print('Skipping all unit tests.')\n            print(flush=True)\n            returncode = 0\n        else:\n            print(mlog.bold('Running unittests.'))\n            print(flush=True)\n            cmd = mesonlib.python_command + ['run_unittests.py'] + backend_flags\n            if options.failfast:\n                cmd += ['--failfast']\n            returncode += subprocess_call(cmd, env=env)\n            if options.failfast and returncode != 0:\n                return returncode\n        cmd = mesonlib.python_command + ['run_project_tests.py'] + sys.argv[1:]\n        returncode += subprocess_call(cmd, env=env)\n    else:\n        cross_test_args = mesonlib.python_command + ['run_cross_test.py']\n        for cf in options.cross:\n            print(mlog.bold(f'Running {cf} cross tests.'))\n            print(flush=True)\n            cmd = cross_test_args + ['cross/' + cf]\n            if options.failfast:\n                cmd += ['--failfast']\n            if options.cross_only:\n                cmd += ['--cross-only']\n            returncode += subprocess_call(cmd, env=env)\n            if options.failfast and returncode != 0:\n                return returncode\n    return returncode\n\nif __name__ == '__main__':\n    setup_vsenv()\n    print('Meson build system', meson_version, 'Project and Unit Tests')\n    raise SystemExit(main())\n"
        },
        {
          "name": "run_unittests.py",
          "type": "blob",
          "size": 5.333984375,
          "content": "#!/usr/bin/env python3\n# SPDX-License-Identifier: Apache-2.0\n# Copyright 2016-2021 The Meson development team\n\n# Work around some pathlib bugs...\nfrom mesonbuild import _pathlib\nimport sys\nsys.modules['pathlib'] = _pathlib\n\nimport time\nimport subprocess\nimport os\nimport unittest\n\nimport mesonbuild.mlog\nimport mesonbuild.depfile\nimport mesonbuild.dependencies.base\nimport mesonbuild.dependencies.factory\nimport mesonbuild.compilers\nimport mesonbuild.envconfig\nimport mesonbuild.environment\nimport mesonbuild.coredata\nimport mesonbuild.modules.gnome\nfrom mesonbuild.mesonlib import python_command, setup_vsenv\nimport mesonbuild.modules.pkgconfig\n\nfrom unittests.allplatformstests import AllPlatformTests\nfrom unittests.cargotests import CargoVersionTest, CargoCfgTest, CargoLockTest\nfrom unittests.darwintests import DarwinTests\nfrom unittests.failuretests import FailureTests\nfrom unittests.linuxcrosstests import LinuxCrossArmTests, LinuxCrossMingwTests\nfrom unittests.machinefiletests import NativeFileTests, CrossFileTests\nfrom unittests.rewritetests import RewriterTests\nfrom unittests.taptests import TAPParserTests\nfrom unittests.datatests import DataTests\nfrom unittests.internaltests import InternalTests\nfrom unittests.linuxliketests import LinuxlikeTests\nfrom unittests.pythontests import PythonTests\nfrom unittests.subprojectscommandtests import SubprojectsCommandTests\nfrom unittests.windowstests import WindowsTests\nfrom unittests.platformagnostictests import PlatformAgnosticTests\n\ndef unset_envs():\n    # For unit tests we must fully control all command lines\n    # so that there are no unexpected changes coming from the\n    # environment, for example when doing a package build.\n    varnames = ['CPPFLAGS', 'LDFLAGS'] + list(mesonbuild.compilers.compilers.CFLAGS_MAPPING.values())\n    for v in varnames:\n        if v in os.environ:\n            del os.environ[v]\n\ndef convert_args(argv):\n    # If we got passed a list of tests, pass it on\n    pytest_args = ['-v'] if '-v' in argv else []\n    test_list = []\n    for arg in argv:\n        if arg.startswith('-'):\n            if arg in ('-f', '--failfast'):\n                arg = '--exitfirst'\n            pytest_args.append(arg)\n            continue\n        # ClassName.test_name => 'ClassName and test_name'\n        if '.' in arg:\n            arg = ' and '.join(arg.split('.'))\n        test_list.append(arg)\n    if test_list:\n        pytest_args += ['-k', ' or '.join(test_list)]\n    return pytest_args\n\ndef running_single_tests(argv, cases):\n    '''\n    Check whether we only got arguments for running individual tests, not\n    entire testcases, and not all testcases (no test args).\n    '''\n    got_test_arg = False\n    for arg in argv:\n        if arg.startswith('-'):\n            continue\n        for case in cases:\n            if not arg.startswith(case):\n                continue\n            if '.' not in arg:\n                # Got a testcase, done\n                return False\n            got_test_arg = True\n    return got_test_arg\n\ndef setup_backend():\n    filtered = []\n    be = 'ninja'\n    for a in sys.argv:\n        if a.startswith('--backend'):\n            be = a.split('=')[1]\n        else:\n            filtered.append(a)\n    # Since we invoke the tests via unittest or xtest test runner\n    # we need to pass the backend to use to the spawned process via\n    # this side channel. Yes it sucks, but at least is is fully\n    # internal to this file.\n    os.environ['MESON_UNIT_TEST_BACKEND'] = be\n    sys.argv = filtered\n\ndef main():\n    unset_envs()\n    setup_backend()\n    cases = ['InternalTests', 'DataTests', 'AllPlatformTests', 'FailureTests',\n             'PythonTests', 'NativeFileTests', 'RewriterTests', 'CrossFileTests',\n             'TAPParserTests', 'SubprojectsCommandTests', 'PlatformAgnosticTests',\n\n             'LinuxlikeTests', 'LinuxCrossArmTests', 'LinuxCrossMingwTests',\n             'WindowsTests', 'DarwinTests']\n\n    try:\n        import pytest # noqa: F401\n        pytest_args = []\n        try:\n            # Need pytest-xdist for `-n` arg\n            import xdist # noqa: F401\n            # Don't use pytest-xdist when running single unit tests since it wastes\n            # time spawning a lot of processes to distribute tests to in that case.\n            if not running_single_tests(sys.argv, cases):\n                pytest_args += ['-n', 'auto']\n        except ImportError:\n            print('pytest-xdist not found, tests will not be distributed across CPU cores')\n        # Let there be colors!\n        if 'CI' in os.environ:\n            pytest_args += ['--color=yes']\n        pytest_args += ['unittests']\n        pytest_args += convert_args(sys.argv[1:])\n        # Always disable pytest-cov because we use a custom setup\n        try:\n            import pytest_cov # noqa: F401\n            print('Disabling pytest-cov')\n            pytest_args += ['-p' 'no:cov']\n        except ImportError:\n            pass\n        return subprocess.run(python_command + ['-m', 'pytest'] + pytest_args).returncode\n    except ImportError:\n        print('pytest not found, using unittest instead')\n    # Fallback to plain unittest.\n    return unittest.main(defaultTest=cases, buffer=True)\n\nif __name__ == '__main__':\n    setup_vsenv()\n    print('Meson build system', mesonbuild.coredata.version, 'Unit Tests')\n    start = time.monotonic()\n    try:\n        raise SystemExit(main())\n    finally:\n        print('Total time: {:.3f} seconds'.format(time.monotonic() - start))\n"
        },
        {
          "name": "setup.cfg",
          "type": "blob",
          "size": 1.9169921875,
          "content": "[metadata]\nname = meson\nversion = attr: mesonbuild.coredata.version\ndescription = A high performance build system\nauthor = Jussi Pakkanen\nauthor_email = jpakkane@gmail.com\nurl = https://mesonbuild.com\nproject_urls =\n    Source = https://github.com/mesonbuild/meson\nkeywords =\n  meson\n  mesonbuild\n  build system\n  cmake\nlicense = Apache License, Version 2.0\nlicense_files = COPYING\nclassifiers =\n  Development Status :: 5 - Production/Stable\n  Environment :: Console\n  Intended Audience :: Developers\n  License :: OSI Approved :: Apache Software License\n  Natural Language :: English\n  Operating System :: MacOS :: MacOS X\n  Operating System :: Microsoft :: Windows\n  Operating System :: POSIX :: BSD\n  Operating System :: POSIX :: Linux\n  Programming Language :: Python :: 3 :: Only\n  Programming Language :: Python :: 3.7\n  Programming Language :: Python :: 3.8\n  Programming Language :: Python :: 3.9\n  Programming Language :: Python :: 3.10\n  Programming Language :: Python :: 3.11\n  Programming Language :: Python :: 3.12\n  Programming Language :: Python :: 3.13\n  Topic :: Software Development :: Build Tools\nlong_description = Meson is a cross-platform build system designed to be both as fast and as user friendly as possible. It supports many languages and compilers, including GCC, Clang, PGI, Intel, and Visual Studio. Its build definitions are written in a simple non-Turing complete DSL.\n\n[options]\npackages = find:\npython_requires = >= 3.7\n\n[options.entry_points]\nconsole_scripts =\n  meson = mesonbuild.mesonmain:main\n\n[options.extras_require]\nninja =\n  ninja>=1.8.2\nprogress =\n  tqdm\ntyping =\n  mypy\n  typing_extensions; python_version <\"3.8\"\n\n# this must be synced with packaging/hook-mesonbuild.py\n[options.package_data]\nmesonbuild.scripts = cmd_or_ps.ps1\nmesonbuild.cmake.data = *\nmesonbuild.dependencies.data = *\n\n[options.packages.find]\ninclude = mesonbuild, mesonbuild.*\n\n[tool:pytest]\npython_classes =\npython_files =\n    unittests/*tests.py\n"
        },
        {
          "name": "setup.py",
          "type": "blob",
          "size": 0.599609375,
          "content": "#!/usr/bin/env python3\n# SPDX-License-Identifier: Apache-2.0\n# Copyright 2016 The Meson development team\n\n\nimport sys\n\nif sys.version_info < (3, 7):\n    raise SystemExit('ERROR: Tried to install Meson with an unsupported Python version: \\n{}'\n                     '\\nMeson requires Python 3.7.0 or greater'.format(sys.version))\n\nfrom setuptools import setup\n\ndata_files = []\nif sys.platform != 'win32':\n    # Only useful on UNIX-like systems\n    data_files = [('share/man/man1', ['man/meson.1']),\n                  ('share/polkit-1/actions', ['data/com.mesonbuild.install.policy'])]\n\nsetup(data_files=data_files,)\n"
        },
        {
          "name": "skip_ci.py",
          "type": "blob",
          "size": 2.1015625,
          "content": "#!/usr/bin/env python3\n# SPDX-License-Identifier: Apache-2.0\n# Copyright 2018 The Meson development team\n\nimport argparse\nimport os\nimport subprocess\nimport sys\nimport traceback\n\n\ndef check_pr(is_pr_env):\n    if is_pr_env not in os.environ:\n        print(f'This is not pull request: {is_pr_env} is not set')\n        sys.exit()\n    elif os.environ[is_pr_env] == 'false':\n        print(f'This is not pull request: {is_pr_env} is false')\n        sys.exit()\n\n\ndef get_base_branch(base_env):\n    if base_env not in os.environ:\n        print(f'Unable to determine base branch: {base_env} is not set')\n        sys.exit()\n    return os.environ[base_env]\n\n\ndef get_git_files(base):\n    diff = subprocess.check_output(['git', 'diff', '--name-only', base + '...HEAD'])\n    return diff.strip().split(b'\\n')\n\n\ndef is_documentation(filename):\n    return filename.startswith(b'docs/')\n\n\ndef main():\n    try:\n        parser = argparse.ArgumentParser(description='CI Skipper')\n        parser.add_argument('--base-branch-env', required=True,\n                            help='Branch push is targeted to')\n        parser.add_argument('--is-pull-env', required=True,\n                            help='Variable set if it is a PR')\n        parser.add_argument('--base-branch-origin', action='store_true',\n                            help='Base branch reference is only in origin remote')\n        args = parser.parse_args()\n        check_pr(args.is_pull_env)\n        base = get_base_branch(args.base_branch_env)\n        if args.base_branch_origin:\n            base = 'origin/' + base\n        if all(is_documentation(f) for f in get_git_files(base)):\n            print(\"Documentation change, CI skipped.\")\n            sys.exit(1)\n    except Exception:\n        # If this script fails we want build to proceed.\n        # Failure likely means some corner case we did not consider or bug.\n        # Either case this should not prevent CI from running if it is needed,\n        # and we tolerate it if it is run where it is not required.\n        traceback.print_exc()\n        print('There is a BUG in skip_ci.py, exiting.')\n        sys.exit()\n\nif __name__ == '__main__':\n    main()\n"
        },
        {
          "name": "test cases",
          "type": "tree",
          "content": null
        },
        {
          "name": "tools",
          "type": "tree",
          "content": null
        },
        {
          "name": "unittests",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}