{
  "metadata": {
    "timestamp": 1736560677142,
    "page": 328,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjMzMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "luyishisi/Anti-Anti-Spider",
      "stars": 7285,
      "defaultBranch": "master",
      "files": [
        {
          "name": "README.md",
          "type": "blob",
          "size": 3.220703125,
          "content": "## 基于CNN的验证码图片识别\n### 简介\n\t本项目采用alexnet模型和letnet模型，可根据实际需要选择(在train_model.py中的train函数修改即可)95.5%\n### 作者有话说\n\t不知不觉这个git库伴随我从16到到20年，带给我自己最棒的一段人生旅程，\n\t整理了这份文档，希望任何想学习图片识别，玩玩卷积神经网络的同学可以最便捷的上手体验。\n\t请谨慎使用技术，仅支持学习，不支持任何黑灰产相关\n\t可参看：https://www.urlteam.cn/?p=1893 https://www.urlteam.cn/?p=1406\n\t原先的Anti-Anti-Spider 全部内容移动到 原Anti-Anti-Spider 目录下\n\t有何疑问可邮件 543429245@qq.com 咨询\n\t模型文件下载 如果出现无法解压，可以使用：\n\thttps://www.urlteam.cn/%E5%8F%AF%E7%94%A8%E8%AE%AD%E7%BB%83%E9%9B%86%E4%B8%8E%E8%AE%AD%E5%A5%BD%E7%9A%84%E6%A8%A1%E5%9E%8B.zip\n\n#### Alexnet 模型结构\n\n![](src/READMEIMG2.PNG)\n\n根据验证码的复杂度不同，训练的时间也会有较大的不同\n![](src/READMEIMG1.PNG)\n\n###  使用方法\n\t1.开始训练样本前，修改conf/config.json\n\t2.将预处理过的数据集分成验证集和训练集，放到sample目录下\n\t3.运行train_model.py开始训练，训练完成的模型保存至model_result中\n\t4.将训练好的模型放置model_result，运行cnn_models/recognition.py，选定验证码，即可看到模型效果\n### 环境配置\nTensorFlow CPU版本安装：`pip install tensorflow==1.9.0`\nTensorFlow GPU版本安装：`pip install tensorflow-gpu==1.9.0`\nGUP版本的安装比较麻烦，需要安装CUDA和cuDNN才能使tensorflow调动GPU\n下图为TensorFlow，Python，CUDA与cuDNN之间的版本对应关系：\n![](./src/README_IMG0.PNG)\nCUDA与cuDNN安装过程主要有两步：\n\n1. 到官网下载CUDA并安装\n2. 将cuDNN解压，复制到CUDA安装目录下\n这里提供两个文件的链接：\nCUDA：`https://developer.nvidia.com/cuda-toolkit-archive`\ncuDNN：`https://developer.nvidia.com/rdp/cudnn-archive`\n更具体的安装过程度娘可帮你轻松解决(linux,windows这两步的操作方法各不相同)\n### 项目结构\n```\n├─cnn_models\n│  ├─cnn_model.py\t\t# CNN网络类\n│  └─recognition.py\t\t# 验证训练结果\n├─conf\n│  └─config.json\t\t# 配置文件\n├─logs\t\t\t# 模型训练日志\n├─model_result\t# 模型保存地址\n│  └─1040\t\t# 一套训练完成的验证码训练集及对应模型\n├─sample\n│  ├─test\t\t# 训练集（训练集与验证集一般是对总数据集9:1分割）\n│  └─train\t\t# 验证集\n├─src\t\t\t# 配置环境所需的工具，可根据自身情况到网上下载\n├─train_model.py\t\t# 训练程序\n└─verify_sample.py\t\t# 制作数据集（打标签加图片预处理）\n```\n### 图片预处理\n+ 为验证码图片打上标签，如：\n![](./src/1040_2019-10-13_10_1092.jpg)\n命名为1040_2019-10-13_10_1092.jpg，1092为标签，其余为附加信息，可根据自己需要更改，用`_`分割即可\n+ 由于模型输入要求输入必须为227*227，所有需要调整图片形状，verify_sample.py中提供有工具函数\n### 注意事项\n\talexnet输入必须为227*227的图片，所有图片预处理时可通过PIL中的函数线性转换图片形状，或者缩放后粘贴到227*227的背景中。\n"
        },
        {
          "name": "cnn_models",
          "type": "tree",
          "content": null
        },
        {
          "name": "conf",
          "type": "tree",
          "content": null
        },
        {
          "name": "make_sample.py",
          "type": "blob",
          "size": 3.82421875,
          "content": "\"\"\"\n验证图片尺寸和分离测试集（5%）和训练集（95%）\n初始化的时候使用，有新的图片后，可以把图片放在new目录里面使用。\n\"\"\"\n\nimport os\nimport time\nimport datetime\nimport json\nimport random\nimport os.path\nimport shutil\n\nimport pymysql\nfrom PIL import Image\n\n\ndef convertjpg(jpgfile, outdir, width=227, height=227):\n    '''转换图片分辨率'''\n    img=Image.open(jpgfile)\n    try:\n        new_img=img.resize((width,height),Image.BILINEAR)\n        if img.mode == \"P\" or img.mode == \"RGBA\":\n            new_img = new_img.convert('RGB')\n        new_img.save(outdir)\n    except Exception as e:\n        print(\"图片转换失败\",e)\n\ndef spilt_train_test(origin_dir,train_dir,test_dir):\n    '''将样本集分成9：1'''\n    img_list = os.listdir(origin_dir)\n    random.seed(time.time())\n    random.shuffle(img_list)\n    R = int(len(img_list)*0.1)\n    for file_name in img_list[:R]:\n        src = os.path.join(origin_dir, file_name)\n        dst = os.path.join(test_dir, file_name)\n        shutil.move(src, dst)\n    for file_name in img_list[R+1:]:\n        src = os.path.join(origin_dir, file_name)\n        dst = os.path.join(train_dir, file_name)\n        shutil.move(src, dst)\n\n\ndef get_date_list(start=None, end=None):\n    '''获取两日期间日期列表'''\n    data_list = []\n    datestart=datetime.datetime.strptime(start,'%Y-%m-%d')\n    dateend=datetime.datetime.strptime(end,'%Y-%m-%d')\n    while datestart<dateend:\n        datestart+=datetime.timedelta(days=1)\n        data_list.append(datestart.strftime('%Y-%m-%d'))\n    return data_list\n\n\ndef get_label(date,typeid):\n    '''从获取数据库获取标签'''\n    conn = pymysql.connect(host='ip',\n                                 port=3306,\n                                 user='**',\n                                 password='**',\n                                 db='**',\n                                 charset='utf8')\n    cursor = conn.cursor()\n    # sql = \"SELECT result,savedir FROM new_ocr_dir WHERE typeid = '{0}' AND time LIKE '{1}%'\".format(typeid,date)\n    sql = \"SELECT result,savedir FROM new_ocr_dir WHERE typeid = {0} AND time LIKE '{1}%'\".format(typeid, date)\n    result = ()\n    try:\n        cursor.execute(sql)\n        result = cursor.fetchall()\n    except Exception as e:\n        print(\"查询数据库失败：{0}\".format(e))\n    return result\n\n\ndef set_label(label, dir, typid, id, date):\n    '''\n    设置标签并修改图片分辨率\n    :param label: 标签\n    :param dir: 图片原地址\n    :param outdir: 图片新地址\n    '''\n    outdir = \"data/{1}_{2}_{3}_{4}.jpg\".format(typid, date, id, label)\n    convertjpg(dir, outdir, 227, 227)\n    # try:\n    #     with open(dir, 'rb') as f:\n    #         img = f.read()\n    #     with open(\"data/{0}/{1}_{2}_{3}_{4}.jpg\".format(typid, typid, date, id, label), 'wb') as f:\n    #         f.write(img)\n    # except Exception:\n    #     print(label, dir, typid)\n\n\ndef solve_lable_dir(label_dir):\n    '''提取标签和地址'''\n    labels = []\n    dirs = []\n    for per in label_dir:\n        label = json.loads(per[0]).get('result','')\n        dir = per[1][13:]\n        labels.append(label)\n        dirs.append(dir)\n    return labels, dirs\n\n\ndef make_sample():\n    '''选定日期和类别，制作带标签的样本集'''\n    dates = get_date_list('2019-10-12', '2019-12-08')\n    typeids = ['3200','3060','3050','3040','3000','2050','2040','2000','1050','1040']\n    for typeid in typeids:\n        for date in dates:\n            print(date)\n            label_dir = get_label(date, typeid)\n            labels, dirs = solve_lable_dir(label_dir)\n            for i in range(len(labels)):\n                label = labels[i]\n                label = label.replace('|','#')\n                dir = dirs[i]\n                set_label(label, dir, typeid, i, date)\n\n\nif __name__ == '__main__':\n    make_sample()\n    # spilt_train_test('data','train','test')\n"
        },
        {
          "name": "model_result",
          "type": "tree",
          "content": null
        },
        {
          "name": "sample",
          "type": "tree",
          "content": null
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "train_model.py",
          "type": "blob",
          "size": 8.9296875,
          "content": "# encoding:utf-8\n\nimport os\nimport time\nimport json\nimport random\n\n\nfrom PIL import Image\nimport numpy as np\nimport tensorflow as tf\n\nfrom cnn_models.cnn_model import CNN\n\n\nclass train_model(CNN):\n    def __init__(self, train_img_path, verify_img_path, char_set, model_save_dir, cycle_stop, acc_stop, cycle_save,\n                 train_batch_size, test_batch_size):\n\n        self.cycle_stop = cycle_stop  # 循环次数\n        self.acc_stop = acc_stop  # 达到准确率停止\n        self.cycle_save = cycle_save  # 当前循环次数\n        self.train_batch_size = train_batch_size  # 训练批大小\n        self.test_batch_size = test_batch_size  # 测试批大小\n        char_set = [str(i) for i in char_set]\n\n        self.train_img_path = train_img_path\n        self.train_images_list = os.listdir(train_img_path)\n\n        # 打乱文件顺序\n        random.seed(time.time())\n        random.shuffle(self.train_images_list)\n\n        # 验证集文件\n        self.verify_img_path = verify_img_path\n        self.verify_images_list = os.listdir(verify_img_path)\n\n        # 获得图片宽高和字符长度基本信息\n        label, captcha_array = self.gen_captcha_text_image(train_img_path, self.train_images_list[0])\n\n        captcha_shape = captcha_array.shape\n        captcha_shape_len = len(captcha_shape)\n        if captcha_shape_len == 3:\n            image_height, image_width, channel = captcha_shape\n            self.channel = channel\n        elif captcha_shape_len == 2:\n            image_height, image_width = captcha_shape\n        else:\n            raise Exception(\"图片转换为矩阵时出错，请检查图片格式\")\n\n        # 初始化变量\n        super(train_model, self).__init__(image_height, image_width, 4, char_set, model_save_dir)\n\n        # 相关信息打印\n        print(\"-->图片尺寸: {} X {}\".format(image_height, image_width))\n        print(\"-->验证码长度: {}\".format(self.max_captcha))\n        print(\"-->验证码共{}类 {}\".format(self.char_set_len, char_set))\n        print(\"-->使用测试集为 {}\".format(train_img_path))\n        print(\"-->使验证集为 {}\".format(verify_img_path))\n\n        # test model input and output\n        print(\">>> Start model test\")\n        batch_x, batch_y = self.get_train_batch(0, size=100)\n        print(\">>> input batch images shape: {}\".format(batch_x.shape))\n        print(\">>> input batch labels shape: {}\".format(batch_y.shape))\n\n    @staticmethod\n    def gen_captcha_text_image(img_path, img_name):\n        \"\"\"\n        返回一个验证码的array形式和对应的字符串标签\n        :return:tuple (str, numpy.array)\n        \"\"\"\n        # 文件\n        label = img_name.split(\"_\")[-1].replace('.jpg','')\n        # 文件\n        img_file = os.path.join(img_path, img_name)\n        captcha_image = Image.open(img_file)\n        captcha_array = np.array(captcha_image)  # 向量化\n        return label, captcha_array\n\n\n    def get_train_batch(self, n, size=64):\n        batch_x = np.zeros([size, self.image_height * self.image_width])  # 初始化\n        batch_y = np.zeros([size, self.max_captcha * self.char_set_len])  # 初始化\n\n        max_batch = int(len(self.train_images_list) / size)\n        # print(max_batch)\n        if max_batch - 1 < 0:\n            raise Exception(\"训练集图片数量需要大于每批次训练的图片数量\")\n        if n > max_batch - 1:\n            n = n % max_batch\n        s = n * size\n        e = (n + 1) * size\n        this_batch = self.train_images_list[s:e]\n        # print(\"{}:{}\".format(s, e))\n\n        for i, img_name in enumerate(this_batch):\n            label, image_array = self.gen_captcha_text_image(self.train_img_path, img_name)\n            image_array = self.convert2gray(image_array)  # 灰度化图片\n            batch_x[i, :] = image_array.flatten() / 255  # flatten 转为一维\n            batch_y[i, :] = self.text2vec(label)  # 生成 oneHot\n        return batch_x, batch_y\n\n    def get_verify_batch(self, size=50):\n        batch_x = np.zeros([size, self.image_height * self.image_width])  # 初始化\n        batch_y = np.zeros([size, self.max_captcha * self.char_set_len])  # 初始化\n\n        verify_images = []\n        for i in range(size):\n            # TODO:\n            verify_images.append(random.choice(self.train_images_list))\n\n        for i, img_name in enumerate(verify_images):\n            # TODO:\n            label, image_array = self.gen_captcha_text_image(self.train_img_path, img_name)\n            image_array = self.convert2gray(image_array)  # 灰度化图片\n            batch_x[i, :] = image_array.flatten() / 255  # flatten 转为一维\n            batch_y[i, :] = self.text2vec(label)  # 生成 oneHot\n        return batch_x, batch_y\n\n    def train(self):\n        y_pred = self.alexnet_model()\n        # y_pred = self.Letnet_model()\n        print(\">>>input batch predict shape:{}\".format(y_pred.shape))\n        print(\">>>End model test\")\n        # 计算损失函数\n        with tf.name_scope('cost'):\n            cost = tf.reduce_mean(tf.nn.sigmoid_cross_entropy_with_logits(logits=y_pred, labels=self.Y))\n        # 梯度下降法\n        with tf.name_scope('train'):\n            optimizer = tf.train.GradientDescentOptimizer(0.000008).minimize(cost)\n        # 计算准确率\n        predict = tf.reshape(y_pred, [-1, self.max_captcha, self.char_set_len])\n        max_idx_p = tf.argmax(predict, 2)  # 返回在张量轴上具有最大值的索引\n        max_idx_l = tf.argmax(tf.reshape(self.Y, [-1, self.max_captcha, self.char_set_len]), 2)  #\n        # 计算准确率\n        correct_pred = tf.equal(max_idx_p, max_idx_l)\n        with tf.name_scope('char_acc'):\n            accuracy = tf.reduce_mean(tf.cast(correct_pred, tf.float32))\n        with tf.name_scope('image_acc'):\n            accuracy_image_count = tf.reduce_mean(tf.reduce_min(tf.cast(correct_pred, tf.float32), axis=1))\n        init = tf.global_variables_initializer()\n        saver = tf.train.Saver()\n        # 设置模型存储路径\n\n        config = tf.ConfigProto()\n        config.gpu_options.per_process_gpu_memory_fraction = 0.7\n\n        with tf.Session(config=config) as sess:\n            init = tf.global_variables_initializer()\n            sess.run(init)\n            # 导入模型\n            if os.path.exists(self.model_save_dir):\n                try:\n                    saver.restore(sess, self.model_save_dir)\n                except:\n                    print('model文件夹为空')\n\n            tf.summary.FileWriter(\"logs/\", sess.graph)\n            step = 1\n            for i in range(self.cycle_stop):\n                batch_x, batch_y = self.get_train_batch(i, self.train_batch_size)\n\n                # 梯度下降法训练\n                _, cost_ = sess.run([optimizer, cost], feed_dict={self.X: batch_x, self.Y: batch_y, self.keep_prob: 0.75})\n\n                if step % 10 == 0:  # 每10 step计算一次准确率\n                    # 计算精度\n                    batch_x_t, batch_y_t = self.get_verify_batch(64)\n                    acc_char = sess.run(accuracy, feed_dict={self.X: batch_x_t, self.Y: batch_y_t, self.keep_prob: 1.})\n                    acc_img = sess.run(accuracy_image_count, feed_dict={self.X: batch_x_t, self.Y: batch_y_t, self.keep_prob:1.})\n\n                    print (\"Iter:{0}, Minibatch Loss= {1}，\".format(step, cost_) +\n                           \"Accuracy_char= {:.5f}，Accuracy_img = {:.5f}\".format(acc_char, acc_img))\n                    if acc_img > self.acc_stop:\n                        saver.save(sess, self.model_save_dir)\n                        print(\"准确率得到标准，保存模型\")\n                        break\n\n                    if step % 500 == 0:\n                        saver.save(sess, self.model_save_dir)\n                        print('保存模型：{}'.format(step))\n                step += 1\n            saver.save(sess, self.model_save_dir)\n\n            print (\"Optimization Finished!\")\n            # 计算测试精度\n            batch_x_t, batch_y_t = self.get_verify_batch(128)\n            print( \"Testing Accuracy:\",step, sess.run(accuracy, feed_dict={self.X: batch_x_t, self.Y: batch_y_t, self.keep_prob: 1.}))\n\n\ndef main():\n    with open(\"conf/config.json\", 'r') as f:\n        conf = json.load(f)\n    train_image_dir = conf[\"train_image_dir\"]\n    verify_image_dir = conf[\"test_image_dir\"]\n    model_save_dir = conf[\"model_save_dir\"]\n    cycle_stop = conf[\"cycle_stop\"]\n    acc_stop = conf[\"acc_stop\"]\n    cycle_save = conf[\"cycle_save\"]\n    enable_gpu = conf[\"enable_gpu\"]\n    train_batch_size = conf['train_batch_size']\n    test_batch_size = conf['test_batch_size']\n    char_set = conf['char_set']\n\n    if not enable_gpu:\n        # 设置以下环境变量可开启CPU识别\n        os.environ[\"CUDA_DEVICE_ORDER\"] = \"PCI_BUS_ID\"\n        os.environ[\"CUDA_VISIBLE_DEVICES\"] = \"-1\"\n    tm = train_model(train_image_dir, verify_image_dir, char_set, model_save_dir, cycle_stop, acc_stop, cycle_save,\n                    train_batch_size, test_batch_size)\n    tm.train()  # 开始训练模型\n    # tm.recognize_captcha()  # 识别图片示例\n\n\nif __name__ == '__main__':\n    main()"
        },
        {
          "name": "原Anti-Anti-Spider",
          "type": "tree",
          "content": null
        },
        {
          "name": "可用训练集与训好的模型.zip",
          "type": "blob",
          "size": 0.130859375,
          "content": "version https://git-lfs.github.com/spec/v1\noid sha256:26925312687536c823925749b33efe3f6c923a742f546df2d1cc2359d0b8ea17\nsize 255595382\n"
        }
      ]
    }
  ]
}