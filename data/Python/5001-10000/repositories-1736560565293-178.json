{
  "metadata": {
    "timestamp": 1736560565293,
    "page": 178,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "OpenBMB/XAgent",
      "stars": 8282,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".env",
          "type": "blob",
          "size": 0.0888671875,
          "content": "DB_USERNAME=admin\nDB_PASSWORD=xagentmongodb\nDB_COLLECTION=TSM\nCONFIG_FILE=assets/config.yml"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.5712890625,
          "content": "*.egg-info\n\n**/__pycache__\n\nworkspace_cache/\n\nXAgent/logs/\nrunning_records/\n\nXAgentServer/localstorage\nXAgentServer/logs/\nXAgentServer/prod_server_envs.py\n\nXAgentWeb/node_modules\n**/node_modules/\nXAgentWeb/dist\n\n.DS_Store\n.vscode\n.idea\n*_running_records\n\ndata/**\ndata/server.db\nToolServerNode/logs/**\n**/workspace/**\ndownload_tmp_file\nlocal_workspace/**\n!local_workspace/readme.md\nsync.py\nassets/private.yml\nassets/garbage\n**.log\nlog/**\n\nXAgentWeb/src/api/backend.ts\nassets/config.yml\nassets/gpt4_config.yml\nconfig.yml\ngpt4_config.yml\nXAgentWeb/pnpm-lock.yaml\nXAgentWeb/pnpm-lock.yaml\n"
        },
        {
          "name": ".project_hierarchy.json",
          "type": "blob",
          "size": 1793.1328125,
          "content": "{\n    \"run.py\": {\n        \"parse_args\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"parse_args\",\n            \"md_content\": \"\",\n            \"code_start_line\": 9,\n            \"code_end_line\": 38,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"def parse_args() -> argparse.Namespace:\\n    \\\"\\\"\\\"\\n    Parse the command line arguments and return them as an argparse.Namespace object.\\n\\n    Returns:\\n        argparse.Namespace: An object containing command line arguments and their values.\\n    \\\"\\\"\\\"\\n    parser = argparse.ArgumentParser()\\n\\n    parser.add_argument(\\\"--task\\\", type=str, required=True, help=\\\"The task description.\\\")\\n    parser.add_argument(\\\"--upload-files\\\", nargs='+', dest=\\\"upload_files\\\", help=\\\"List of files to upload.\\\")\\n    parser.add_argument(\\\"--model\\\", type=str, help=\\\"Model identifier for the task.\\\")\\n    parser.add_argument(\\\"--record-dir\\\", type=str, dest=\\\"record_dir\\\", help=\\\"Directory to record task execution logs.\\\")\\n    parser.add_argument(\\\"--mode\\\", type=str, default=\\\"auto\\\", help=\\\"Operational mode: 'auto' or 'manual'.\\\")\\n    parser.add_argument(\\\"--quiet\\\", action=\\\"store_true\\\", default=False, help=\\\"Run in quiet mode; minimal output.\\\")\\n    parser.add_argument(\\\"--max-subtask-chain-length\\\", type=int, dest=\\\"max_subtask_chain_length\\\",\\n                        help=\\\"Maximum length of subtask chain.\\\")\\n    parser.add_argument(\\\"--enable-ask-human-for-help\\\", action=\\\"store_true\\\", dest=\\\"enable_ask_human_for_help\\\",\\n                        help=\\\"Flag to enable asking for human assistance.\\\")\\n    parser.add_argument(\\\"--max-plan-refine-chain-length\\\", type=int, dest=\\\"max_plan_refine_chain_length\\\",\\n                        help=\\\"Maximum length of plan refinement chain.\\\")\\n    parser.add_argument(\\\"--max-plan-tree-depth\\\", type=int, dest=\\\"max_plan_tree_depth\\\",\\n                        help=\\\"Maximum depth of the plan tree.\\\")\\n    parser.add_argument(\\\"--max-plan-tree-width\\\", type=int, dest=\\\"max_plan_tree_width\\\",\\n                        help=\\\"Maximum width of the plan tree.\\\")\\n    parser.add_argument(\\\"--max-retry-times\\\", type=int, dest=\\\"max_retry_times\\\", help=\\\"Maximum number of retry attempts.\\\")\\n    parser.add_argument(\\\"--config-file\\\", type=str, default=os.getenv('CONFIG_FILE', 'assets/config.yml'),\\n                        dest=\\\"config_file\\\", help=\\\"Path to the configuration file.\\\")\\n\\n    return parser.parse_args()\\n\",\n            \"name_column\": 4\n        },\n        \"execute_command_line_process\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"execute_command_line_process\",\n            \"md_content\": \"\",\n            \"code_start_line\": 41,\n            \"code_end_line\": 66,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"def execute_command_line_process(args: argparse.Namespace, quiet_mode: bool = False) -> None:\\n    \\\"\\\"\\\"\\n    Execute the command line process based on the parsed arguments. If quiet mode is enabled,\\n    redirect stdout to a file specified by the recorder's record_root_dir.\\n\\n    Args:\\n        args (argparse.Namespace): Parsed command line arguments.\\n        quiet_mode (bool): Whether to run in quiet mode, outputting to a file instead of the terminal.\\n    \\\"\\\"\\\"\\n    args_dict = vars(args)\\n    for key, value in args_dict.items():\\n        if value is not None:\\n            if key == 'model':\\n                ARGS['default_completion_kwargs'] = deepcopy(CONFIG['default_completion_kwargs'])\\n                ARGS['default_completion_kwargs']['model'] = value\\n            else:\\n                ARGS[key] = value\\n\\n    # Redirect stdout to a file if quiet mode is true\\n    if quiet_mode:\\n        from XAgent.running_recorder import recorder\\n        record_file_path = os.path.join(recorder.record_root_dir, \\\"command_line.ansi\\\")\\n        with open(record_file_path, \\\"w\\\", encoding=\\\"utf-8\\\") as file, redirect_stdout(file):\\n            start_command_line(args_dict)\\n    else:\\n        start_command_line(args_dict)\\n\",\n            \"name_column\": 4\n        },\n        \"start_command_line\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"start_command_line\",\n            \"md_content\": \"\",\n            \"code_start_line\": 69,\n            \"code_end_line\": 83,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"def start_command_line(args_dict: dict) -> None:\\n    \\\"\\\"\\\"\\n    Start the command line interface with the provided arguments.\\n\\n    Args:\\n        args_dict (dict): A dictionary of command line arguments.\\n    \\\"\\\"\\\"\\n    param = CommandLineParam(\\n        task=args_dict['task'],\\n        upload_files=args_dict.get('upload_files'),\\n        role=\\\"Assistant\\\",\\n        mode=args_dict[\\\"mode\\\"],\\n    )\\n    cmd = CommandLine(param)\\n    cmd.start()\\n\",\n            \"name_column\": 4\n        }\n    },\n    \"command.py\": {\n        \"get_db\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"get_db\",\n            \"md_content\": \"\",\n            \"code_start_line\": 33,\n            \"code_end_line\": 45,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"def get_db():\\n    \\\"\\\"\\\"\\n    Provide a transactional scope around a series of operations.\\n    \\\"\\\"\\\"\\n    session = SessionLocal()\\n    try:\\n        yield session\\n        session.commit()\\n    except:\\n        session.rollback()\\n        raise\\n    finally:\\n        session.close()\\n\",\n            \"name_column\": 4\n        },\n        \"CommandLineParam\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"CommandLineParam\",\n            \"md_content\": \"\",\n            \"code_start_line\": 48,\n            \"code_end_line\": 85,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"class CommandLineParam:\\n    \\\"\\\"\\\"Command line parameters.\\n    \\n    Attributes:\\n            task: Task description.\\n            role: Role name (default is \\\"Assistant\\\").\\n            plan: List of steps to perform (default is empty list).\\n            upload_files: List of files to upload (default is empty list).\\n            download_files: List of files to download (default is empty list).\\n            record_dir: Directory to store records (default is `None`).\\n            mode: Run mode. Can be \\\"auto\\\" (default is \\\"auto\\\").\\n            max_wait_seconds: Maximum wait time in seconds (default is 600).\\n            description: Description of the interaction (default is \\\"XAgent-Test\\\").\\n            agent: Agent name (default is \\\"XAgent\\\").\\n    \\\"\\\"\\\"\\n    def __init__(self,\\n                 task,\\n                role=\\\"Assistant\\\",\\n                plan=[],\\n                upload_files: List[str] = [],\\n                download_files: List[str] = [],\\n                record_dir: str = None,\\n                mode: str = \\\"auto\\\",\\n                max_wait_seconds: int = 600,\\n                description: str = \\\"XAgent-Test\\\",\\n                agent: str = \\\"XAgent\\\",\\n                ):\\n        self.task = task\\n        self.plan = plan\\n        self.role = role\\n        self.upload_files = upload_files\\n        self.download_files = download_files\\n        self.record_dir = record_dir\\n        # auto is supported only in cmd\\n        self.mode = \\\"auto\\\"\\n        self.max_wait_seconds = max_wait_seconds\\n        self.description = description\\n        self.agent = agent\\n\",\n            \"name_column\": 6\n        },\n        \"CommandLine\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"CommandLine\",\n            \"md_content\": \"\",\n            \"code_start_line\": 88,\n            \"code_end_line\": 290,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"class CommandLine():\\n    \\\"\\\"\\\"\\n    A command-line interface for interacting with XAgentServer.\\n\\n    Attributes:\\n        env: An instance of the XAgentServer environment.\\n        client_id: A unique identifier for the client, generated as a hexadecimal UUID.\\n        date_str: The current date as a string in YYYY-MM-DD format.\\n        log_dir: The directory where the logs are stored.\\n        logger: An instance of the Logger used for logging interactions.\\n        interactionDB: A database interface for interacting with either a persistent\\n            database (SQLite, MySQL, PostgreSQL) or a local storage file, depending\\n            on the configuration of `env`.\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, args: CommandLineParam = None):\\n        \\\"\\\"\\\"\\n        Initialize the CommandLine instance.\\n\\n        Args:\\n            args (CommandLineParam) : parameters.\\n            task is required,\\n            mode options: [\\\"auto\\\"]\\n        \\\"\\\"\\\"\\n\\n        self.args = args\\n        self.client_id = uuid.uuid4().hex\\n        self.date_str = datetime.now().strftime(\\\"%Y-%m-%d\\\")\\n        self.log_dir = os.path.join(os.path.join(XAgentServerEnv.base_dir, \\\"localstorage\\\",\\n                                    \\\"interact_records\\\"), self.date_str, self.client_id)\\n        if not os.path.exists(self.log_dir):\\n            os.makedirs(self.log_dir)\\n\\n        self.logger = Logger(log_dir=self.log_dir, log_file=f\\\"interact.log\\\")\\n\\n        self.logger.typewriter_log(\\n            title=f\\\"XAgentServer is running on cmd mode\\\",\\n            title_color=Fore.RED)\\n        self.logger.info(title=f\\\"XAgentServer log:\\\",\\n                         title_color=Fore.RED, message=f\\\"{self.log_dir}\\\")\\n        self.interrupt = self.args.mode != \\\"auto\\\"\\n        self.init_conv_env()\\n        self.max_wait_seconds = self.args.max_wait_seconds\\n        self.scheduler = AsyncIOScheduler()\\n        self.input = None\\n        if self.interrupt:\\n            self.input = CommandLineInput(\\n                do_interrupt=True,\\n                max_wait_seconds=self.max_wait_seconds,\\n                logger=self.logger)\\n\\n    def init_conv_env(self):\\n        \\\"\\\"\\\"initialize the conversation environment, \\n        Share the same database resource with webui.\\n        If you have initiated a session on the front end but it has not been executed, \\n        this ID will be shared.\\n        \\\"\\\"\\\"\\n        user_id = \\\"guest\\\"\\n        token = \\\"xagent\\\"\\n        description = self.args.description\\n        upload_files = self.args.upload_files\\n        record_dir = self.args.record_dir\\n        agent = self.args.agent\\n        goal = self.args.task\\n        mode = self.args.mode\\n        plan = self.args.plan\\n\\n        with get_db() as db:\\n            interaction = InteractionCRUD.get_ready_interaction(\\n                db=db, user_id=user_id)\\n            self.continue_flag = True\\n            upload_files = upload_files if upload_files else []\\n            file_list = []\\n            for file in upload_files:\\n                file_list.append({\\n                    \\\"uuid\\\": file,\\n                    \\\"name\\\": file\\n                })\\n            if interaction is None:\\n\\n                base = InteractionBase(interaction_id=self.client_id,\\n                                       user_id=user_id,\\n                                       create_time=datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\"),\\n                                       description=description,\\n                                       agent=agent,\\n                                       mode=mode,\\n                                       file_list=file_list,\\n                                       recorder_root_dir=\\\"\\\",\\n                                       status=\\\"ready\\\",\\n                                       message=\\\"ready...\\\",\\n                                       current_step=\\\"-1\\\",\\n                                       update_time=datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\"),\\n                                       call_method=\\\"cmd\\\")\\n                InteractionCRUD.create_interaction(db=db, base=base)\\n            else:\\n                self.client_id = interaction.interaction_id\\n            \\n            parameter = InteractionParameter(\\n                interaction_id=self.client_id,\\n                parameter_id=uuid.uuid4().hex,\\n                args={\\n                    \\\"goal\\\": goal,\\n                    \\\"plan\\\": plan\\n                    },\\n            )\\n            InteractionCRUD.add_parameter(db=db, parameter=parameter)\\n\\n\\n    def run(self):\\n        \\\"\\\"\\\"\\n        Runs the interaction with the XAgentServer with the provided arguments.\\n        \\\"\\\"\\\"\\n\\n        # Create a new raw data to record\\n        with get_db() as db:\\n            InteractionCRUD.insert_raw(db=db, process=XAgentRaw(\\n                interaction_id=self.client_id,\\n                node_id=uuid.uuid4().hex,\\n                status=StatusEnum.RUNNING,\\n                create_time=datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\"),\\n                update_time=datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\"),\\n                current=\\\"\\\",\\n                step=-1,\\n                data=None,\\n                file_list=[],\\n                do_interrupt=self.interrupt,\\n                wait_seconds=0,\\n                ask_for_human_help=False,\\n                is_human=True,\\n                human_data={\\\"goal\\\": self.args.task, \\\"plan\\\": self.args.plan},\\n                human_file_list=self.args.upload_files,\\n                is_send=True,\\n                is_receive=False,\\n                is_deleted=False\\n            ))\\n            redis.set_key(f\\\"{self.client_id}_send\\\", 1)\\n            \\n            parameter = InteractionCRUD.get_init_parameter(\\n                db=db, interaction_id=self.client_id)\\n        \\n        self.task_handler(parameter=parameter)\\n\\n    def task_handler(self, parameter: InteractionParameter):\\n        \\\"\\\"\\\"\\n        define a long task to run interaction\\n\\n        Args:\\n            parameter (InteractionParameter): The parameter of interaction\\n        \\\"\\\"\\\"\\n\\n        try:\\n            current_step = uuid.uuid4().hex\\n            with get_db() as db:\\n                base = InteractionCRUD.get_interaction(db=db,\\n                                                    interaction_id=self.client_id)\\n                InteractionCRUD.update_interaction_status(db=db,\\n                                                        interaction_id=base.interaction_id,\\n                                                        status=\\\"running\\\",\\n                                                        message=\\\"running\\\",\\n                                                        current_step=current_step)\\n\\n            # if mode is not auto, we will interrupt the interaction\\n            # and you can change the wait_seconds\\n            # default 10 min.\\n            interaction = XAgentInteraction(\\n                base=base,\\n                parameter=parameter,\\n                interrupt=base.mode != \\\"auto\\\",\\n                call_method=\\\"cmd\\\")\\n\\n            # Register logger, dbinto interaction\\n            interaction.resister_logger(self.logger)\\n            self.logger.info(\\n                f\\\"Register logger into interaction of {base.interaction_id}, done!\\\")\\n\\n            interaction.register_db(db=db)\\n            self.logger.info(\\n                f\\\"Register db into interaction of {base.interaction_id}, done!\\\")\\n            # Create XAgentServer\\n            server = XAgentServer(logger=self.logger)\\n            self.logger.info(\\n                f\\\"Register logger into XAgentServer of {base.interaction_id}, done!\\\")\\n            self.logger.info(\\n                f\\\"Start a new thread to run interaction of {base.interaction_id}, done!\\\")\\n            # await server.interact(interaction=interaction)\\n            server.interact(interaction=interaction)\\n        except XAgentError as e:\\n            traceback.print_exc()\\n            self.logger.error(\\n                f\\\"Error in task_handler of {self.client_id}: {e}\\\")\\n            with get_db() as db:\\n                InteractionCRUD.insert_error(\\n                    db=db, interaction_id=self.client_id, message=str(e))\\n                redis.set_key(self.client_id + \\\"_send\\\", 1)\\n                InteractionCRUD.update_interaction_status(db=db,\\n                                                        interaction_id=self.client_id,\\n                                                        status=\\\"failed\\\",\\n                                                        message=str(e),\\n                                                        current_step=current_step)\\n        \\n    def start(self):\\n\\n        self.run()\\n\",\n            \"name_column\": 6\n        },\n        \"__init__\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"__init__\",\n            \"md_content\": \"\",\n            \"code_start_line\": 103,\n            \"code_end_line\": 137,\n            \"parent\": \"CommandLine\",\n            \"have_return\": false,\n            \"code_content\": \"    def __init__(self, args: CommandLineParam = None):\\n        \\\"\\\"\\\"\\n        Initialize the CommandLine instance.\\n\\n        Args:\\n            args (CommandLineParam) : parameters.\\n            task is required,\\n            mode options: [\\\"auto\\\"]\\n        \\\"\\\"\\\"\\n\\n        self.args = args\\n        self.client_id = uuid.uuid4().hex\\n        self.date_str = datetime.now().strftime(\\\"%Y-%m-%d\\\")\\n        self.log_dir = os.path.join(os.path.join(XAgentServerEnv.base_dir, \\\"localstorage\\\",\\n                                    \\\"interact_records\\\"), self.date_str, self.client_id)\\n        if not os.path.exists(self.log_dir):\\n            os.makedirs(self.log_dir)\\n\\n        self.logger = Logger(log_dir=self.log_dir, log_file=f\\\"interact.log\\\")\\n\\n        self.logger.typewriter_log(\\n            title=f\\\"XAgentServer is running on cmd mode\\\",\\n            title_color=Fore.RED)\\n        self.logger.info(title=f\\\"XAgentServer log:\\\",\\n                         title_color=Fore.RED, message=f\\\"{self.log_dir}\\\")\\n        self.interrupt = self.args.mode != \\\"auto\\\"\\n        self.init_conv_env()\\n        self.max_wait_seconds = self.args.max_wait_seconds\\n        self.scheduler = AsyncIOScheduler()\\n        self.input = None\\n        if self.interrupt:\\n            self.input = CommandLineInput(\\n                do_interrupt=True,\\n                max_wait_seconds=self.max_wait_seconds,\\n                logger=self.logger)\\n\",\n            \"name_column\": 8\n        },\n        \"init_conv_env\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"init_conv_env\",\n            \"md_content\": \"\",\n            \"code_start_line\": 139,\n            \"code_end_line\": 193,\n            \"parent\": \"CommandLine\",\n            \"have_return\": false,\n            \"code_content\": \"    def init_conv_env(self):\\n        \\\"\\\"\\\"initialize the conversation environment, \\n        Share the same database resource with webui.\\n        If you have initiated a session on the front end but it has not been executed, \\n        this ID will be shared.\\n        \\\"\\\"\\\"\\n        user_id = \\\"guest\\\"\\n        token = \\\"xagent\\\"\\n        description = self.args.description\\n        upload_files = self.args.upload_files\\n        record_dir = self.args.record_dir\\n        agent = self.args.agent\\n        goal = self.args.task\\n        mode = self.args.mode\\n        plan = self.args.plan\\n\\n        with get_db() as db:\\n            interaction = InteractionCRUD.get_ready_interaction(\\n                db=db, user_id=user_id)\\n            self.continue_flag = True\\n            upload_files = upload_files if upload_files else []\\n            file_list = []\\n            for file in upload_files:\\n                file_list.append({\\n                    \\\"uuid\\\": file,\\n                    \\\"name\\\": file\\n                })\\n            if interaction is None:\\n\\n                base = InteractionBase(interaction_id=self.client_id,\\n                                       user_id=user_id,\\n                                       create_time=datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\"),\\n                                       description=description,\\n                                       agent=agent,\\n                                       mode=mode,\\n                                       file_list=file_list,\\n                                       recorder_root_dir=\\\"\\\",\\n                                       status=\\\"ready\\\",\\n                                       message=\\\"ready...\\\",\\n                                       current_step=\\\"-1\\\",\\n                                       update_time=datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\"),\\n                                       call_method=\\\"cmd\\\")\\n                InteractionCRUD.create_interaction(db=db, base=base)\\n            else:\\n                self.client_id = interaction.interaction_id\\n            \\n            parameter = InteractionParameter(\\n                interaction_id=self.client_id,\\n                parameter_id=uuid.uuid4().hex,\\n                args={\\n                    \\\"goal\\\": goal,\\n                    \\\"plan\\\": plan\\n                    },\\n            )\\n            InteractionCRUD.add_parameter(db=db, parameter=parameter)\\n\",\n            \"name_column\": 8\n        },\n        \"run\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"run\",\n            \"md_content\": \"\",\n            \"code_start_line\": 196,\n            \"code_end_line\": 228,\n            \"parent\": \"CommandLine\",\n            \"have_return\": false,\n            \"code_content\": \"    def run(self):\\n        \\\"\\\"\\\"\\n        Runs the interaction with the XAgentServer with the provided arguments.\\n        \\\"\\\"\\\"\\n\\n        # Create a new raw data to record\\n        with get_db() as db:\\n            InteractionCRUD.insert_raw(db=db, process=XAgentRaw(\\n                interaction_id=self.client_id,\\n                node_id=uuid.uuid4().hex,\\n                status=StatusEnum.RUNNING,\\n                create_time=datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\"),\\n                update_time=datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\"),\\n                current=\\\"\\\",\\n                step=-1,\\n                data=None,\\n                file_list=[],\\n                do_interrupt=self.interrupt,\\n                wait_seconds=0,\\n                ask_for_human_help=False,\\n                is_human=True,\\n                human_data={\\\"goal\\\": self.args.task, \\\"plan\\\": self.args.plan},\\n                human_file_list=self.args.upload_files,\\n                is_send=True,\\n                is_receive=False,\\n                is_deleted=False\\n            ))\\n            redis.set_key(f\\\"{self.client_id}_send\\\", 1)\\n            \\n            parameter = InteractionCRUD.get_init_parameter(\\n                db=db, interaction_id=self.client_id)\\n        \\n        self.task_handler(parameter=parameter)\\n\",\n            \"name_column\": 8\n        },\n        \"task_handler\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"task_handler\",\n            \"md_content\": \"\",\n            \"code_start_line\": 230,\n            \"code_end_line\": 286,\n            \"parent\": \"CommandLine\",\n            \"have_return\": false,\n            \"code_content\": \"    def task_handler(self, parameter: InteractionParameter):\\n        \\\"\\\"\\\"\\n        define a long task to run interaction\\n\\n        Args:\\n            parameter (InteractionParameter): The parameter of interaction\\n        \\\"\\\"\\\"\\n\\n        try:\\n            current_step = uuid.uuid4().hex\\n            with get_db() as db:\\n                base = InteractionCRUD.get_interaction(db=db,\\n                                                    interaction_id=self.client_id)\\n                InteractionCRUD.update_interaction_status(db=db,\\n                                                        interaction_id=base.interaction_id,\\n                                                        status=\\\"running\\\",\\n                                                        message=\\\"running\\\",\\n                                                        current_step=current_step)\\n\\n            # if mode is not auto, we will interrupt the interaction\\n            # and you can change the wait_seconds\\n            # default 10 min.\\n            interaction = XAgentInteraction(\\n                base=base,\\n                parameter=parameter,\\n                interrupt=base.mode != \\\"auto\\\",\\n                call_method=\\\"cmd\\\")\\n\\n            # Register logger, dbinto interaction\\n            interaction.resister_logger(self.logger)\\n            self.logger.info(\\n                f\\\"Register logger into interaction of {base.interaction_id}, done!\\\")\\n\\n            interaction.register_db(db=db)\\n            self.logger.info(\\n                f\\\"Register db into interaction of {base.interaction_id}, done!\\\")\\n            # Create XAgentServer\\n            server = XAgentServer(logger=self.logger)\\n            self.logger.info(\\n                f\\\"Register logger into XAgentServer of {base.interaction_id}, done!\\\")\\n            self.logger.info(\\n                f\\\"Start a new thread to run interaction of {base.interaction_id}, done!\\\")\\n            # await server.interact(interaction=interaction)\\n            server.interact(interaction=interaction)\\n        except XAgentError as e:\\n            traceback.print_exc()\\n            self.logger.error(\\n                f\\\"Error in task_handler of {self.client_id}: {e}\\\")\\n            with get_db() as db:\\n                InteractionCRUD.insert_error(\\n                    db=db, interaction_id=self.client_id, message=str(e))\\n                redis.set_key(self.client_id + \\\"_send\\\", 1)\\n                InteractionCRUD.update_interaction_status(db=db,\\n                                                        interaction_id=self.client_id,\\n                                                        status=\\\"failed\\\",\\n                                                        message=str(e),\\n                                                        current_step=current_step)\\n\",\n            \"name_column\": 8\n        },\n        \"start\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"start\",\n            \"md_content\": \"\",\n            \"code_start_line\": 288,\n            \"code_end_line\": 290,\n            \"parent\": \"CommandLine\",\n            \"have_return\": false,\n            \"code_content\": \"    def start(self):\\n\\n        self.run()\\n\",\n            \"name_column\": 8\n        }\n    },\n    \"command_input.py\": {\n        \"timer\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"timer\",\n            \"md_content\": \"\",\n            \"code_start_line\": 12,\n            \"code_end_line\": 30,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"def timer(func):\\n    \\\"\\\"\\\"\\n    Decorator function to time the execution of a function.\\n\\n    Args:\\n        func (Function): The function to be timed.\\n\\n    Returns:\\n        wrapper (Function): The wrapped function with added timing functionality.\\n    \\\"\\\"\\\"\\n    @functools.wraps(func)\\n    def wrapper(*args, **kwargs):\\n        try:\\n            start_time = time.time()\\n            result = func(*args, **kwargs)\\n            end_time = time.time()\\n        except:\\n            pass\\n    return wrapper\\n\",\n            \"name_column\": 4\n        },\n        \"CommandLineInput\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"CommandLineInput\",\n            \"md_content\": \"\",\n            \"code_start_line\": 33,\n            \"code_end_line\": 153,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"class CommandLineInput:\\n    \\\"\\\"\\\"\\n    Class for handling command line input.\\n\\n    This child class extends from BaseInput and implements methods to handle and manage command line input data.\\n\\n    Attributes:\\n        do_interrupt (bool): If True, input will be interrupted.\\n        max_wait_seconds (int): Maximum wait time for input in seconds.\\n    \\\"\\\"\\\"\\n    def __init__(self,\\n                 do_interrupt: bool = False,\\n                 max_wait_seconds: int = 600,\\n                 logger=None):\\n        self.do_interrupt = do_interrupt\\n        self.max_wait_seconds = max_wait_seconds\\n        self.logger = logger\\n\\n    def run(self, input_data):\\n        \\\"\\\"\\\"\\n        Run the command line input method.\\n\\n        Args:\\n            input_data (Any): The original input data to be processed.\\n\\n        Returns:\\n            data (Any): The processed input data.\\n        \\\"\\\"\\\"\\n        if self.do_interrupt:\\n            data = self.interrupt(input_data)\\n        else:\\n            data = input_data\\n        return data\\n    \\n    def get_each_input(self, key, value, res, timeout):\\n        \\\"\\\"\\\"\\n        Returns the input from the command line for a single key-value pair.\\n\\n        Args:\\n            key (str): The key for which to get input.\\n            value (Any): The current value associated with the key.\\n            res (dict): The result dictionary where inputs collected will be stored.\\n            timeout (int): Timeout in seconds for the input.\\n\\n        Returns:\\n            Any: The input data.\\n        \\\"\\\"\\\"\\n        self.logger.typewriter_log(\\n            f\\\"Now, ASK For {key}, Origin Input: {value}\\\",\\n            Fore.RED,\\n            f\\\"\\\"\\n        )\\n        self.logger.typewriter_log(\\n            f\\\"Now, you can modify the current field by entering some information, and then press 'Enter' to continue, if you want to keep the original input, please enter '-1' and then press 'Enter':\\\",\\n            Fore.GREEN\\n        )\\n        temp = inputimeout(prompt=f'You have {timeout} seconds to input:\\\\n', timeout=timeout)\\n        if temp == \\\"-1\\\":\\n            return value\\n        else:\\n            return temp\\n        \\n    def get_input(self, origin_data):\\n        \\\"\\\"\\\"\\n        Get input for all fields of the original data from the command line.\\n\\n        Args:\\n            origin_data (dict): The original data for which to get input.\\n\\n        Returns:\\n            dict: The dictionary with updated inputs.\\n        \\\"\\\"\\\"\\n        self.logger.typewriter_log(\\n                \\\"Next, you can start modifying the original input by typing 'Y/y/yes' or skip this step by typing 'N/n/no' and then press 'Enter' to continue the loop:\\\",\\n                Fore.RED\\n            )\\n        update = inputimeout(prompt=f'You have to make a decision within 60 seconds:\\\\n', timeout=60)\\n        res = {\\\"args\\\": {}}\\n        if update in ['y', 'Y', 'yes']:\\n            execute_time = self.max_wait_seconds\\n            if isinstance(origin_data, dict):\\n                args = origin_data.get(\\\"args\\\", \\\"\\\")\\n                self.logger.typewriter_log(\\n                    f\\\"Next, you will have a total of {self.max_wait_seconds} seconds to modify each option:\\\",\\n                    Fore.RED,\\n                )\\n                for key, value in args.items():\\n                    if key == \\\"done\\\":\\n                        res[key] = False\\n                        continue\\n                    start_time = time.time()\\n                    res[\\\"args\\\"][key] = self.get_each_input(key, value, res, execute_time)\\n                    end_time = time.time()\\n                    execute_time = math.floor(execute_time - (end_time - start_time))\\n            self.logger.info(f\\\"modify the input, receive the data: {res}\\\")\\n        else:\\n            res = origin_data\\n            self.logger.info(\\\"skip this step\\\")\\n        self.logger.info(\\\"continue the loop\\\")\\n        res[\\\"done\\\"] = True\\n        return res\\n    \\n    def interrupt(self, input_data):\\n        \\\"\\\"\\\"\\n        Interrupts the current input process and returns the current data.\\n\\n        Args:\\n            input_data (dict): The original input data.\\n\\n        Returns:\\n            dict: The current data collected so far.\\n\\n        Raises:\\n            XAgentIOTimeoutError: If the input times out.\\n        \\\"\\\"\\\"\\n        try:\\n            data = self.get_input(input_data)\\n            return data\\n        except TimeoutOccurred:\\n            self.logger.error(f\\\"Waiting timemout, close connection!\\\")\\n            raise XAgentTimeoutError(\\\"timeout!\\\")\",\n            \"name_column\": 6\n        },\n        \"wrapper\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"wrapper\",\n            \"md_content\": \"\",\n            \"code_start_line\": 23,\n            \"code_end_line\": 29,\n            \"parent\": \"timer\",\n            \"have_return\": false,\n            \"code_content\": \"    def wrapper(*args, **kwargs):\\n        try:\\n            start_time = time.time()\\n            result = func(*args, **kwargs)\\n            end_time = time.time()\\n        except:\\n            pass\\n\",\n            \"name_column\": 8\n        },\n        \"__init__\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"__init__\",\n            \"md_content\": \"\",\n            \"code_start_line\": 43,\n            \"code_end_line\": 49,\n            \"parent\": \"CommandLineInput\",\n            \"have_return\": false,\n            \"code_content\": \"    def __init__(self,\\n                 do_interrupt: bool = False,\\n                 max_wait_seconds: int = 600,\\n                 logger=None):\\n        self.do_interrupt = do_interrupt\\n        self.max_wait_seconds = max_wait_seconds\\n        self.logger = logger\\n\",\n            \"name_column\": 8\n        },\n        \"run\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"run\",\n            \"md_content\": \"\",\n            \"code_start_line\": 51,\n            \"code_end_line\": 65,\n            \"parent\": \"CommandLineInput\",\n            \"have_return\": true,\n            \"code_content\": \"    def run(self, input_data):\\n        \\\"\\\"\\\"\\n        Run the command line input method.\\n\\n        Args:\\n            input_data (Any): The original input data to be processed.\\n\\n        Returns:\\n            data (Any): The processed input data.\\n        \\\"\\\"\\\"\\n        if self.do_interrupt:\\n            data = self.interrupt(input_data)\\n        else:\\n            data = input_data\\n        return data\\n\",\n            \"name_column\": 8\n        },\n        \"get_each_input\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"get_each_input\",\n            \"md_content\": \"\",\n            \"code_start_line\": 67,\n            \"code_end_line\": 93,\n            \"parent\": \"CommandLineInput\",\n            \"have_return\": true,\n            \"code_content\": \"    def get_each_input(self, key, value, res, timeout):\\n        \\\"\\\"\\\"\\n        Returns the input from the command line for a single key-value pair.\\n\\n        Args:\\n            key (str): The key for which to get input.\\n            value (Any): The current value associated with the key.\\n            res (dict): The result dictionary where inputs collected will be stored.\\n            timeout (int): Timeout in seconds for the input.\\n\\n        Returns:\\n            Any: The input data.\\n        \\\"\\\"\\\"\\n        self.logger.typewriter_log(\\n            f\\\"Now, ASK For {key}, Origin Input: {value}\\\",\\n            Fore.RED,\\n            f\\\"\\\"\\n        )\\n        self.logger.typewriter_log(\\n            f\\\"Now, you can modify the current field by entering some information, and then press 'Enter' to continue, if you want to keep the original input, please enter '-1' and then press 'Enter':\\\",\\n            Fore.GREEN\\n        )\\n        temp = inputimeout(prompt=f'You have {timeout} seconds to input:\\\\n', timeout=timeout)\\n        if temp == \\\"-1\\\":\\n            return value\\n        else:\\n            return temp\\n\",\n            \"name_column\": 8\n        },\n        \"get_input\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"get_input\",\n            \"md_content\": \"\",\n            \"code_start_line\": 95,\n            \"code_end_line\": 133,\n            \"parent\": \"CommandLineInput\",\n            \"have_return\": true,\n            \"code_content\": \"    def get_input(self, origin_data):\\n        \\\"\\\"\\\"\\n        Get input for all fields of the original data from the command line.\\n\\n        Args:\\n            origin_data (dict): The original data for which to get input.\\n\\n        Returns:\\n            dict: The dictionary with updated inputs.\\n        \\\"\\\"\\\"\\n        self.logger.typewriter_log(\\n                \\\"Next, you can start modifying the original input by typing 'Y/y/yes' or skip this step by typing 'N/n/no' and then press 'Enter' to continue the loop:\\\",\\n                Fore.RED\\n            )\\n        update = inputimeout(prompt=f'You have to make a decision within 60 seconds:\\\\n', timeout=60)\\n        res = {\\\"args\\\": {}}\\n        if update in ['y', 'Y', 'yes']:\\n            execute_time = self.max_wait_seconds\\n            if isinstance(origin_data, dict):\\n                args = origin_data.get(\\\"args\\\", \\\"\\\")\\n                self.logger.typewriter_log(\\n                    f\\\"Next, you will have a total of {self.max_wait_seconds} seconds to modify each option:\\\",\\n                    Fore.RED,\\n                )\\n                for key, value in args.items():\\n                    if key == \\\"done\\\":\\n                        res[key] = False\\n                        continue\\n                    start_time = time.time()\\n                    res[\\\"args\\\"][key] = self.get_each_input(key, value, res, execute_time)\\n                    end_time = time.time()\\n                    execute_time = math.floor(execute_time - (end_time - start_time))\\n            self.logger.info(f\\\"modify the input, receive the data: {res}\\\")\\n        else:\\n            res = origin_data\\n            self.logger.info(\\\"skip this step\\\")\\n        self.logger.info(\\\"continue the loop\\\")\\n        res[\\\"done\\\"] = True\\n        return res\\n\",\n            \"name_column\": 8\n        },\n        \"interrupt\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"interrupt\",\n            \"md_content\": \"\",\n            \"code_start_line\": 135,\n            \"code_end_line\": 153,\n            \"parent\": \"CommandLineInput\",\n            \"have_return\": true,\n            \"code_content\": \"    def interrupt(self, input_data):\\n        \\\"\\\"\\\"\\n        Interrupts the current input process and returns the current data.\\n\\n        Args:\\n            input_data (dict): The original input data.\\n\\n        Returns:\\n            dict: The current data collected so far.\\n\\n        Raises:\\n            XAgentIOTimeoutError: If the input times out.\\n        \\\"\\\"\\\"\\n        try:\\n            data = self.get_input(input_data)\\n            return data\\n        except TimeoutOccurred:\\n            self.logger.error(f\\\"Waiting timemout, close connection!\\\")\\n            raise XAgentTimeoutError(\\\"timeout!\\\")\",\n            \"name_column\": 8\n        }\n    },\n    \"setup.py\": {},\n    \"start_server.py\": {},\n    \"ToolServer/ToolServerManager/config.py\": {\n        \"ManagerConfig\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"ManagerConfig\",\n            \"md_content\": \"\",\n            \"code_start_line\": 8,\n            \"code_end_line\": 63,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"class ManagerConfig:\\n    \\\"\\\"\\\"\\n    This class manages configuration settings for the application.\\n    Configuration settings are initially loaded from a yaml file. \\n    However, if an environment variable exists with the same name as a configuration setting, \\n    the value from the environment variable will be used instead.\\n\\n    Attributes:\\n        cfg: A dictionary containing all configuration settings.\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, config_file_path=\\\"./assets/config/manager.yml\\\"):\\n        \\\"\\\"\\\"\\n        Initializes a new instance of the ManagerConfig class.\\n\\n        Args:\\n            config_file_path (str, optional): The path to a yaml file containing configuration settings. \\n            Defaults to \\\"./assets/config.yml\\\".\\n        \\\"\\\"\\\"\\n        self.cfg:Dict = yaml.load(open(config_file_path,\\\"r\\\",encoding=\\\"utf-8\\\").read(), Loader=yaml.FullLoader)\\n        for k in os.environ.keys():\\n            if k in self.cfg:\\n                self.cfg[k] = os.environ[k]  # overwrite the config with environment variables\\n\\n    def __getitem__(self, key):\\n        \\\"\\\"\\\"\\n        Returns the value of a configuration setting.\\n\\n        Args:\\n            key (str): The name of the configuration setting.\\n\\n        Returns:\\n            The value of the configuration setting. \\n        \\\"\\\"\\\"\\n        return self.cfg[key]\\n\\n    def dict(self) -> Dict[str, Any]:\\n        \\\"\\\"\\\"\\n        Returns all configuration settings.\\n\\n        Returns:\\n            A dictionary containing all configuration settings.\\n        \\\"\\\"\\\"\\n        return self.cfg\\n\\n    def update(self, new_config: Dict) -> None:\\n        \\\"\\\"\\\"\\n        Updates configuration settings with the values from another dictionary.\\n\\n        Args:\\n            new_config (Dict): A dictionary containing the configuration settings to be updated.\\n\\n        Returns:\\n            None\\n        \\\"\\\"\\\"\\n        self.cfg.update(new_config)\\n\",\n            \"name_column\": 6\n        },\n        \"__init__\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"__init__\",\n            \"md_content\": \"\",\n            \"code_start_line\": 19,\n            \"code_end_line\": 30,\n            \"parent\": \"ManagerConfig\",\n            \"have_return\": false,\n            \"code_content\": \"    def __init__(self, config_file_path=\\\"./assets/config/manager.yml\\\"):\\n        \\\"\\\"\\\"\\n        Initializes a new instance of the ManagerConfig class.\\n\\n        Args:\\n            config_file_path (str, optional): The path to a yaml file containing configuration settings. \\n            Defaults to \\\"./assets/config.yml\\\".\\n        \\\"\\\"\\\"\\n        self.cfg:Dict = yaml.load(open(config_file_path,\\\"r\\\",encoding=\\\"utf-8\\\").read(), Loader=yaml.FullLoader)\\n        for k in os.environ.keys():\\n            if k in self.cfg:\\n                self.cfg[k] = os.environ[k]  # overwrite the config with environment variables\\n\",\n            \"name_column\": 8\n        },\n        \"__getitem__\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"__getitem__\",\n            \"md_content\": \"\",\n            \"code_start_line\": 32,\n            \"code_end_line\": 42,\n            \"parent\": \"ManagerConfig\",\n            \"have_return\": true,\n            \"code_content\": \"    def __getitem__(self, key):\\n        \\\"\\\"\\\"\\n        Returns the value of a configuration setting.\\n\\n        Args:\\n            key (str): The name of the configuration setting.\\n\\n        Returns:\\n            The value of the configuration setting. \\n        \\\"\\\"\\\"\\n        return self.cfg[key]\\n\",\n            \"name_column\": 8\n        },\n        \"dict\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"dict\",\n            \"md_content\": \"\",\n            \"code_start_line\": 44,\n            \"code_end_line\": 51,\n            \"parent\": \"ManagerConfig\",\n            \"have_return\": true,\n            \"code_content\": \"    def dict(self) -> Dict[str, Any]:\\n        \\\"\\\"\\\"\\n        Returns all configuration settings.\\n\\n        Returns:\\n            A dictionary containing all configuration settings.\\n        \\\"\\\"\\\"\\n        return self.cfg\\n\",\n            \"name_column\": 8\n        },\n        \"update\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"update\",\n            \"md_content\": \"\",\n            \"code_start_line\": 53,\n            \"code_end_line\": 63,\n            \"parent\": \"ManagerConfig\",\n            \"have_return\": false,\n            \"code_content\": \"    def update(self, new_config: Dict) -> None:\\n        \\\"\\\"\\\"\\n        Updates configuration settings with the values from another dictionary.\\n\\n        Args:\\n            new_config (Dict): A dictionary containing the configuration settings to be updated.\\n\\n        Returns:\\n            None\\n        \\\"\\\"\\\"\\n        self.cfg.update(new_config)\\n\",\n            \"name_column\": 8\n        }\n    },\n    \"ToolServer/ToolServerManager/models.py\": {\n        \"ToolServerNode\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"ToolServerNode\",\n            \"md_content\": \"\",\n            \"code_start_line\": 5,\n            \"code_end_line\": 15,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"class ToolServerNode(Document):\\n    \\\"\\\"\\\"\\n    A class that represents a node in the database. \\n    \\\"\\\"\\\"\\n    id: str\\n    short_id: str\\n    status: str\\n    health: str\\n    last_req_time: datetime\\n    ip: str\\n    port: int\\n\",\n            \"name_column\": 6\n        },\n        \"NodeChecker\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"NodeChecker\",\n            \"md_content\": \"\",\n            \"code_start_line\": 17,\n            \"code_end_line\": 20,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"class NodeChecker(Document):\\n    manager_id: str\\n    interval: float\\n    pid: int\",\n            \"name_column\": 6\n        }\n    },\n    \"ToolServer/ToolServerManager/connections.py\": {},\n    \"ToolServer/ToolServerManager/main.py\": {\n        \"startup\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"startup\",\n            \"md_content\": \"\",\n            \"code_start_line\": 19,\n            \"code_end_line\": 53,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"async def startup():\\n    \\\"\\\"\\\"\\n    Event handler triggered on startup of the app. Sets up necessary configurations \\n    like checking and creating table nodes if not exists in databse, creating subprocess \\n    to update node status, and registering path to node. \\n    \\\"\\\"\\\"\\n    \\n    from beanie import init_beanie\\n    await init_beanie(database=db,\\n                      document_models=[ToolServerNode,NodeChecker],)\\n    \\n    # create subprocess to update node status\\n    if CONFIG['builtin_monitor']:\\n        from node_checker import check_nodes_status_loop\\n        \\n        async for checker in NodeChecker.find_all():\\n            if not psutil.pid_exists(checker.pid):\\n                checker.delete()\\n\\n        checker = NodeChecker(\\n            manager_id=MANAGER_ID,\\n            interval=float(CONFIG['node'].get('health_check_interval',1)),\\n            pid=os.getpid()\\n            )\\n        await checker.save()\\n\\n        asyncio.create_task(check_nodes_status_loop())\\n            \\n\\n    # register path to node\\n    for path in CONFIG['redirect_to_node_path']['post']:\\n        app.add_api_route(path, route_to_node, methods=[\\\"POST\\\"])\\n        \\n    for path in CONFIG['redirect_to_node_path']['get']:\\n        app.add_api_route(path, route_to_node, methods=[\\\"GET\\\"])\\n\",\n            \"name_column\": 10\n        },\n        \"shutdown\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"shutdown\",\n            \"md_content\": \"\",\n            \"code_start_line\": 56,\n            \"code_end_line\": 63,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"async def shutdown():\\n    \\\"\\\"\\\"\\n    Event handler on shutdown of the app. Specifically closes the database cursor if \\n    the database type os sqlite3.\\n    \\\"\\\"\\\"\\n    async for checker in NodeChecker.find(NodeChecker.manager_id == MANAGER_ID):\\n        await checker.delete()\\n    db.client.close()\\n\",\n            \"name_column\": 10\n        },\n        \"alive\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"alive\",\n            \"md_content\": \"\",\n            \"code_start_line\": 66,\n            \"code_end_line\": 73,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"async def alive():\\n    \\\"\\\"\\\"\\n    Endpoint to check if the service is running.\\n\\n    Returns:\\n        str: \\\"alive\\\"\\n    \\\"\\\"\\\"\\n    return \\\"alive\\\"\\n\",\n            \"name_column\": 10\n        },\n        \"wait_for_node_startup\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"wait_for_node_startup\",\n            \"md_content\": \"\",\n            \"code_start_line\": 75,\n            \"code_end_line\": 106,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"async def wait_for_node_startup(node_id:str):\\n    \\\"\\\"\\\"\\n    Wait for the startup of node with id node_id. It probes the node status every seconds until \\n    creation_wait_seconds reached.\\n    \\n    Args:\\n        node_id (str): The unique identifier of the node whose startup is to be waited for.\\n\\n    Returns:\\n        bool: True if node has started successfully, False if time out occured before node startup.\\n    \\n    Raises:\\n        HTTPException: If node is not found in the databse.\\n    \\\"\\\"\\\"\\n    MAX_PROBE_TIMES = CONFIG['node']['creation_wait_seconds']\\n    probe_times = 0\\n    while probe_times < MAX_PROBE_TIMES:\\n        node = await ToolServerNode.find_one(ToolServerNode.id == node_id)\\n            \\n        if node is None:\\n            raise HTTPException(status_code=503, detail=\\\"Failed to detect node status! Node not found in db!\\\")\\n        \\n        if CONFIG['node']['health_check']:\\n            if node.health == 'healthy':\\n                return True\\n        else:\\n            if node.status == \\\"running\\\":\\n                return True\\n            \\n        probe_times += 1\\n        await asyncio.sleep(1)\\n    return False\\n\",\n            \"name_column\": 10\n        },\n        \"read_cookie_info\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"read_cookie_info\",\n            \"md_content\": \"\",\n            \"code_start_line\": 109,\n            \"code_end_line\": 150,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"async def read_cookie_info():\\n    \\\"\\\"\\\"\\n    Fetch server version and node info, create docker container and set the response cookies \\n    with the key \\\"node_id\\\" and value as the id of the created container. Also, adds the created \\n    node's details to the databse and waits for the node to startup.\\n\\n    Returns:\\n        JSONResponse: A response object with status, headers and cookies set accordingly.\\n\\n    Raises:\\n        HTTPException: If node creation timeout occurs.\\n    \\\"\\\"\\\"\\n    # append server version info\\n    content = {\\\"message\\\": \\\"add cookie\\\",\\\"version\\\":CONFIG['version']}\\n    response = JSONResponse(content=content)\\n    response.headers[\\\"Server\\\"] = \\\"ToolServerManager/\\\" + CONFIG['version']\\n    \\n    # create a docker container\\n    container = docker_client.containers.run(\\n        device_requests=[docker.types.DeviceRequest(**req) for req in CONFIG['node']['device_requests']] if CONFIG['node']['device_requests'] else None,\\n        **(CONFIG['node']['creation_kwargs']),)\\n    logger.info(\\\"Node created: \\\" + container.id)\\n    response.set_cookie(key=\\\"node_id\\\", value=container.id)\\n    container.reload()\\n    \\n    node = ToolServerNode(\\n        id=container.id,\\n        short_id=container.short_id,\\n        status=container.attrs[\\\"State\\\"][\\\"Status\\\"],\\n        ip=container.attrs[\\\"NetworkSettings\\\"][\\\"Networks\\\"][CONFIG['node']['creation_kwargs']['network']][\\\"IPAddress\\\"],\\n        port=CONFIG['node'].get('port',31942),\\n        last_req_time=datetime.datetime.utcnow(),\\n        health=container.attrs['State']['Health']['Status'] if CONFIG['node']['health_check'] else None\\n    )\\n    await node.insert()\\n\\n    # probe node status every seconds until creation_wait_seconds reached\\n    if await wait_for_node_startup(container.id):\\n        return response\\n    else:\\n        logger.warning(\\\"Node status detection timeout: \\\" + container.id)\\n        raise HTTPException(status_code=503, detail=\\\"Node creation timeout!\\\")\\n\",\n            \"name_column\": 10\n        },\n        \"reconnect_session\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"reconnect_session\",\n            \"md_content\": \"\",\n            \"code_start_line\": 153,\n            \"code_end_line\": 179,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"async def reconnect_session(node_id:str = Cookie(None)):\\n    \\\"\\\"\\\"\\n    Reconnect session of a node. Fetches node info and restarts the node if it exists.\\n\\n    Args:\\n        node_id (str, optional): The unique identifier of the node. Defaults to Cookie(None).\\n\\n    Returns:\\n        str: Success message if node restarts successfully.\\n    \\n    Raises:\\n        HTTPException: If node restart timeout occurs.\\n    \\\"\\\"\\\"\\n    node = await ToolServerNode.find_one(ToolServerNode.id == node_id)\\n    if node is None:\\n        return \\\"invalid node_id: \\\" + str(node_id)\\n    # restart node\\n    container = docker_client.containers.get(node_id)\\n    if container is not None:\\n        container.restart()\\n        logger.info(\\\"Node restarted: \\\" + node_id)\\n    \\n    if await wait_for_node_startup(node_id):\\n        return \\\"Reconnect session: \\\" + str(node_id)\\n    else:\\n        logger.warning(\\\"Node restart timeout: \\\" + node_id)\\n        raise HTTPException(status_code=503, detail=\\\"Node restart timeout!\\\")\\n\",\n            \"name_column\": 10\n        },\n        \"close_session\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"close_session\",\n            \"md_content\": \"\",\n            \"code_start_line\": 182,\n            \"code_end_line\": 200,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"async def close_session(node_id:str = Cookie(None)):\\n    \\\"\\\"\\\"\\n    Close session of a node. Fetches node info and stops the node if it exists and is not already exited.\\n\\n    Args:\\n        node_id (str, optional): The unique identifier of the node. Defaults to Cookie(None).\\n\\n    Returns:\\n        str: Success message if node stops successfully.\\n    \\\"\\\"\\\"\\n    node = await ToolServerNode.find_one(ToolServerNode.id == node_id)\\n    if node is None:\\n        return \\\"invalid node_id: \\\" + str(node_id)\\n    # stop node\\n    container = docker_client.containers.get(node_id)\\n    if container is not None and container.attrs[\\\"State\\\"][\\\"Status\\\"] != \\\"exit\\\":\\n        container.stop()\\n        logger.info(\\\"Node stopped: \\\" + node_id)\\n    return \\\"Close session: \\\" + str(node_id)\\n\",\n            \"name_column\": 10\n        },\n        \"release_session\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"release_session\",\n            \"md_content\": \"\",\n            \"code_start_line\": 203,\n            \"code_end_line\": 226,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"async def release_session(node_id:str = Cookie(None)):\\n    \\\"\\\"\\\"\\n    Release session of a node. Fetches node info and kills the node if it exists and is not already exited. \\n    Also, removes the node.\\n\\n    Args:\\n        node_id (str, optional): The unique identifier of the node. Defaults to Cookie(None).\\n\\n    Returns:\\n        str: Success message if node is successfully killed and removed.\\n    \\\"\\\"\\\"\\n    node = await ToolServerNode.find_one(ToolServerNode.id == node_id)\\n    if node is None:\\n        return \\\"invalid node_id: \\\" + str(node_id)\\n    \\n    # delete node in docker\\n    container = docker_client.containers.get(node_id)\\n    if container is not None:\\n        if container.attrs[\\\"State\\\"][\\\"Status\\\"] != \\\"exited\\\":\\n            container.kill()\\n            logger.info(\\\"Node killed: \\\" + node_id)\\n        container.remove()\\n        logger.info(\\\"Node deleted: \\\" + node_id)\\n    return \\\"Release session: \\\" + str(node_id)\\n\",\n            \"name_column\": 10\n        },\n        \"route_to_node\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"route_to_node\",\n            \"md_content\": \"\",\n            \"code_start_line\": 228,\n            \"code_end_line\": 269,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"async def route_to_node(requset:Request,*,node_id:str = Cookie(None)):\\n    \\\"\\\"\\\"\\n    Routes a request to a specific node. Fetches the node info, checks if it is valid and running. Updates latest \\n    request time in the database and then sends a post request to the node.\\n    \\n    Args:\\n        request (Request): The request object containing all request information.\\n\\n    Returns:\\n        Response: The response object containing all response information received from the node.\\n\\n    Raises:\\n        HTTPException: If node_id is not valid or if the node is not running or not responding.\\n    \\\"\\\"\\\"\\n    # logger.info(\\\"accept node_id:\\\",node_id)\\n    node = await ToolServerNode.find_one(ToolServerNode.id == node_id)\\n    if node is None:\\n        raise HTTPException(status_code=403,detail=\\\"invalid node_id: \\\" + str(node_id)) \\n    \\n    if node.status != \\\"running\\\":\\n        raise HTTPException(status_code=503,detail=\\\"node is not running: \\\" + str(node_id)) \\n\\n    # update latest_req_time in db\\n    node.last_req_time = datetime.datetime.utcnow()\\n    await node.replace()\\n        \\n    #post request to node\\n    method = requset.method\\n    headers = dict(requset.headers)\\n    body = await requset.body()\\n    url = \\\"http://\\\" + node.ip +\\\":\\\"+str(node.port) + requset.url.path\\n    logger.info(\\\"Request to node: \\\" + url)\\n    \\n    async with httpx.AsyncClient(timeout=None) as client:\\n        try:\\n            response = await client.request(method,url,headers=headers,data=body)\\n        except httpx.RequestError:\\n            traceback.print_exc()\\n            raise HTTPException(status_code=503, detail=\\\"node is not responding\\\")\\n    logger.info('Response from node: ' + str(response.status_code))\\n    res = Response(content=response.content, status_code=response.status_code, headers=response.headers)\\n    return res\\n\",\n            \"name_column\": 10\n        }\n    },\n    \"ToolServer/ToolServerManager/node_checker.py\": {\n        \"check_nodes_status\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"check_nodes_status\",\n            \"md_content\": \"\",\n            \"code_start_line\": 11,\n            \"code_end_line\": 54,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"async def check_nodes_status():\\n    \\\"\\\"\\\"\\n    Check the status of all existing nodes from the selected database 'sqlite3' or 'mongodb'.\\n    If a node doesn't exist in Docker, it will be deleted from the database. \\n\\n    Raises:\\n        docker.errors.NotFound: Raised when a Node is not found in Docker\\n        docker.errors.APIError: Raised when it fails to get Node info from Docker\\n    \\\"\\\"\\\"\\n    # Check if each node exists in Docker\\n    async for node in ToolServerNode.find_all():\\n        container = None\\n        try:\\n            container = docker_client.containers.get(node.id)\\n        except docker.errors.NotFound:\\n            # Delete from db if not found in Docker\\n            await node.delete()\\n            logger.info(\\\"Node deleted from db: \\\" + node.id + '(not in docker)')\\n            continue\\n        except docker.errors.APIError:\\n            logger.warning(\\\"Failed to get node info from docker: \\\" + node['node_id'])\\n            continue\\n\\n        if container is not None:\\n            # Update the node state in db\\n            node_status = container.attrs[\\\"State\\\"][\\\"Status\\\"]\\n \\n            if node_status != node.status:\\n                logger.info(f\\\"Node {node.short_id} status updated: \\\" + node.status + \\\" -> \\\" + node_status)\\n            node.status = node_status\\n                \\n            if CONFIG['node']['health_check']:\\n                health = container.attrs['State']['Health']['Status']\\n                if health != node.health:\\n                    logger.info(f\\\"Node {node.short_id} health updated: \\\" + node.health + \\\" -> \\\" + health)\\n                node.health = health\\n                \\n            await node.replace()\\n\\n            # Check if node is running\\n            if node_status == \\\"running\\\":\\n                if datetime.datetime.utcnow() - node.last_req_time >= datetime.timedelta(minutes=CONFIG['node']['idling_close_minutes']):\\n                    container.stop()\\n                    logger.info(\\\"Stopping node: \\\" + node.id + \\\" due to idling time used up\\\")\\n\",\n            \"name_column\": 10\n        },\n        \"check_nodes_status_loop\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"check_nodes_status_loop\",\n            \"md_content\": \"\",\n            \"code_start_line\": 57,\n            \"code_end_line\": 68,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"async def check_nodes_status_loop():\\n    \\\"\\\"\\\"\\n    An infinite loop that checks the status of the nodes and waits 1 second before each iteration.\\n    \\\"\\\"\\\"\\n    logger.info(\\\"Nodes status checker started.\\\")\\n    while True:\\n        try:\\n            await check_nodes_status()\\n        except:\\n            import traceback\\n            traceback.print_exc()\\n        await asyncio.sleep(CONFIG['node'].get('health_check_interval',1))\\n\",\n            \"name_column\": 10\n        }\n    },\n    \"ToolServer/ToolServerNode/config.py\": {\n        \"NodeConfig\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"NodeConfig\",\n            \"md_content\": \"\",\n            \"code_start_line\": 6,\n            \"code_end_line\": 71,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"class NodeConfig:\\n    \\\"\\\"\\\"\\n    A class used to load and manage the configurations defined in a specified configuration file and the environment variables.\\n\\n    Methods\\n    -------\\n    __getitem__(self, key):\\n        Fetches a configuration value for a given key.\\n    dict():\\n        Returns the entire configuration dictionary.\\n    update(new_config: Dict):\\n        Updates the configuration dictionary with new configurations.\\n    \\\"\\\"\\\"\\n    def __init__(self,\\n                 config_file_path=\\\"./assets/config/node.yml\\\",):\\n        \\\"\\\"\\\"\\n        The constructor for NodeConfig class that loads the configuration details.\\n\\n        Args:\\n          config_file_path (str, optional): The path to the configuration file. Defaults to \\\"assets/config.yml\\\".\\n\\n        Raises:\\n          FileNotFoundError: If specified configuration file path could not be located.\\n          yaml.YAMLError: If there are syntax errors in the provided yaml configuration file.\\n        \\\"\\\"\\\"\\n        self.cfg:Dict = yaml.load(open(config_file_path, \\\"r\\\", encoding=\\\"utf-8\\\").read(), Loader=yaml.FullLoader)\\n        \\n        for k in os.environ.keys():\\n            if k in self.cfg:\\n                self.cfg[k] = os.environ[k] # overwrite the config with environment variables\\n\\n    def __getitem__(self, key):\\n        \\\"\\\"\\\"\\n        Fetches a configuration value for a given key.\\n\\n        Args:\\n          key (str): The configuration key to fetch value for.\\n        \\n        Returns:\\n          Any: The value of the requested configuration key.\\n        \\n        Raises:\\n          KeyError: If the given key is not found in the configuration.\\n        \\\"\\\"\\\"\\n        return self.cfg[key]\\n    \\n    def dict(self)-> Dict[str, Any]:\\n        \\\"\\\"\\\"\\n        Returns the entire configuration dictionary.\\n        \\n        Returns:\\n          Dict[str, Any]: The entire configuration dictionary.\\n        \\\"\\\"\\\"\\n        return self.cfg\\n\\n    def update(self, new_config: Dict)-> None:\\n        \\\"\\\"\\\"\\n        Updates the configuration dictionary with new configurations.\\n\\n        Args:\\n          new_config (Dict): The new configurations dictionary to update the existing configurations.\\n\\n        Returns:\\n          None\\n        \\\"\\\"\\\"\\n        self.cfg.update(new_config)\\n\",\n            \"name_column\": 6\n        },\n        \"__init__\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"__init__\",\n            \"md_content\": \"\",\n            \"code_start_line\": 19,\n            \"code_end_line\": 35,\n            \"parent\": \"NodeConfig\",\n            \"have_return\": false,\n            \"code_content\": \"    def __init__(self,\\n                 config_file_path=\\\"./assets/config/node.yml\\\",):\\n        \\\"\\\"\\\"\\n        The constructor for NodeConfig class that loads the configuration details.\\n\\n        Args:\\n          config_file_path (str, optional): The path to the configuration file. Defaults to \\\"assets/config.yml\\\".\\n\\n        Raises:\\n          FileNotFoundError: If specified configuration file path could not be located.\\n          yaml.YAMLError: If there are syntax errors in the provided yaml configuration file.\\n        \\\"\\\"\\\"\\n        self.cfg:Dict = yaml.load(open(config_file_path, \\\"r\\\", encoding=\\\"utf-8\\\").read(), Loader=yaml.FullLoader)\\n        \\n        for k in os.environ.keys():\\n            if k in self.cfg:\\n                self.cfg[k] = os.environ[k] # overwrite the config with environment variables\\n\",\n            \"name_column\": 8\n        },\n        \"__getitem__\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"__getitem__\",\n            \"md_content\": \"\",\n            \"code_start_line\": 37,\n            \"code_end_line\": 50,\n            \"parent\": \"NodeConfig\",\n            \"have_return\": true,\n            \"code_content\": \"    def __getitem__(self, key):\\n        \\\"\\\"\\\"\\n        Fetches a configuration value for a given key.\\n\\n        Args:\\n          key (str): The configuration key to fetch value for.\\n        \\n        Returns:\\n          Any: The value of the requested configuration key.\\n        \\n        Raises:\\n          KeyError: If the given key is not found in the configuration.\\n        \\\"\\\"\\\"\\n        return self.cfg[key]\\n\",\n            \"name_column\": 8\n        },\n        \"dict\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"dict\",\n            \"md_content\": \"\",\n            \"code_start_line\": 52,\n            \"code_end_line\": 59,\n            \"parent\": \"NodeConfig\",\n            \"have_return\": true,\n            \"code_content\": \"    def dict(self)-> Dict[str, Any]:\\n        \\\"\\\"\\\"\\n        Returns the entire configuration dictionary.\\n        \\n        Returns:\\n          Dict[str, Any]: The entire configuration dictionary.\\n        \\\"\\\"\\\"\\n        return self.cfg\\n\",\n            \"name_column\": 8\n        },\n        \"update\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"update\",\n            \"md_content\": \"\",\n            \"code_start_line\": 61,\n            \"code_end_line\": 71,\n            \"parent\": \"NodeConfig\",\n            \"have_return\": false,\n            \"code_content\": \"    def update(self, new_config: Dict)-> None:\\n        \\\"\\\"\\\"\\n        Updates the configuration dictionary with new configurations.\\n\\n        Args:\\n          new_config (Dict): The new configurations dictionary to update the existing configurations.\\n\\n        Returns:\\n          None\\n        \\\"\\\"\\\"\\n        self.cfg.update(new_config)\\n\",\n            \"name_column\": 8\n        }\n    },\n    \"ToolServer/ToolServerNode/main.py\": {\n        \"startup\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"startup\",\n            \"md_content\": \"\",\n            \"code_start_line\": 23,\n            \"code_end_line\": 33,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"def startup():\\n    \\\"\\\"\\\"\\n    Startup function to initialize the required services and variables for the application.\\n    \\\"\\\"\\\"\\n    try:\\n        # start docker service\\n        os.system('service docker start')\\n    except:\\n        pass\\n    app.tool_register = ToolRegister()\\n    app.doc_embeddings, app.id2tool = build_tool_embeddings(app.tool_register.get_all_tools_dict(include_invisible=True))\\n\",\n            \"name_column\": 4\n        },\n        \"root\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"root\",\n            \"md_content\": \"\",\n            \"code_start_line\": 37,\n            \"code_end_line\": 44,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"async def root():\\n    \\\"\\\"\\\"\\n    Root function that returns a message Hello World.\\n    \\n    Returns:\\n        dict: A dictionary containing a welcoming message.\\n    \\\"\\\"\\\"\\n    return {\\\"message\\\": \\\"Hello World\\\"}\\n\",\n            \"name_column\": 10\n        },\n        \"upload_file\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"upload_file\",\n            \"md_content\": \"\",\n            \"code_start_line\": 47,\n            \"code_end_line\": 62,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"async def upload_file(file:UploadFile):\\n    \\\"\\\"\\\"\\n    This function allows the user to upload a file to the work directory defined in configuration file.\\n\\n    Args:\\n        file (fastapi.UploadFile): The file to be uploaded.\\n    \\n    Returns:\\n        dict: A message denoting successful upload of the file.\\n    \\\"\\\"\\\"\\n    upload_file =  file.file.read()\\n    file_name = file.filename\\n    work_directory = CONFIG['filesystem']['work_directory']\\n    with open(os.path.join(work_directory,file_name),'wb') as f:\\n        f.write(upload_file)\\n    return {\\\"message\\\": \\\"Upload Success!\\\"}\\n\",\n            \"name_column\": 10\n        },\n        \"download_file\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"download_file\",\n            \"md_content\": \"\",\n            \"code_start_line\": 65,\n            \"code_end_line\": 83,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"async def download_file(file_path:str=Body(...),file_type:str=Body(default='text/plain')):\\n    \\\"\\\"\\\"\\n    This function downloads a file from the work directory.\\n\\n    Args:\\n        file_path (str): The path of the file to be downloaded.\\n        file_type (str, optional): Type of the file. Defaults to 'text/plain'.\\n    \\n    Returns:\\n        starlette.responses.FileResponse: File response containing the requested file for user to download.\\n    \\\"\\\"\\\"\\n    work_directory = CONFIG['filesystem']['work_directory']\\n    if file_path.startswith(os.path.basename(work_directory)):\\n        file_path = file_path[len(os.path.basename(work_directory))+1:]\\n    response = FileResponse(\\n        path=os.path.join(work_directory,file_path),\\n        filename=os.path.basename(file_path),\\n        )\\n    return response\\n\",\n            \"name_column\": 10\n        },\n        \"download_workspace\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"download_workspace\",\n            \"md_content\": \"\",\n            \"code_start_line\": 86,\n            \"code_end_line\": 105,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"async def download_workspace():\\n    \\\"\\\"\\\"\\n    This function downloads the workspace which is a directory consisting of all the uploaded files. \\n    \\n    Returns:\\n        starlette.responses.FileResponse: File response containing the workspace for the user to download. \\n    \\\"\\\"\\\"\\n    work_directory = CONFIG['filesystem']['work_directory']\\n    zip = zipfile.ZipFile('/tmp/workspace.zip','w',zipfile.ZIP_DEFLATED)\\n    for path,dirs,files in os.walk(work_directory):\\n        fpath= path.replace(work_directory,'')\\n        for file in files:\\n            zip.write(os.path.join(path,file),os.path.join(fpath,file))\\n    \\n    zip.close()\\n    response = FileResponse(\\n        path=os.path.join(work_directory,'/tmp/workspace.zip'),\\n        filename='workspace.zip',\\n        )\\n    return response\\n\",\n            \"name_column\": 10\n        },\n        \"get_workspace_structure\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"get_workspace_structure\",\n            \"md_content\": \"\",\n            \"code_start_line\": 109,\n            \"code_end_line\": 125,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"async def get_workspace_structure():\\n    \\\"\\\"\\\"\\n    This function generates the structure of the workspace directory.\\n    \\n    Returns:\\n        dict: A dictionary depicting the structure of the workspace directory.\\n    \\\"\\\"\\\"\\n    work_directory = CONFIG['filesystem']['work_directory']\\n    def generate_directory_structure(path):\\n        result = {'name':os.path.basename(path)}\\n        if os.path.isdir(path):\\n            result['type'] = 'directory'\\n            result['children'] = [generate_directory_structure(os.path.join(path,child)) for child in os.listdir(path)]\\n        else:\\n            result['type'] = 'file'\\n        return result\\n    return generate_directory_structure(work_directory)\\n\",\n            \"name_column\": 10\n        },\n        \"get_available_tools\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"get_available_tools\",\n            \"md_content\": \"\",\n            \"code_start_line\": 128,\n            \"code_end_line\": 140,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"async def get_available_tools():\\n    \\\"\\\"\\\"\\n    This function returns the available tools and environments registered in the ToolRegister.\\n    \\n    Returns:\\n        dict: A dictionary of available tools, environments and the JSON representation of the tools.\\n    \\\"\\\"\\\"\\n    tool_register:ToolRegister = app.tool_register\\n    return {\\n        \\\"available_envs\\\": tool_register.get_all_envs(),\\n        \\\"available_tools\\\": tool_register.get_all_tools(),\\n        \\\"tools_json\\\": tool_register.get_all_tools_dict(),\\n    }\\n\",\n            \"name_column\": 10\n        },\n        \"retrieving_tools\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"retrieving_tools\",\n            \"md_content\": \"\",\n            \"code_start_line\": 143,\n            \"code_end_line\": 173,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"async def retrieving_tools(question:str=Body(...), top_k:int=Body(default=5)):\\n    \\\"\\\"\\\"\\n    This function retrieves the tool names based on a query question using the ADA retriever.\\n\\n    Args:\\n        question (str): The query question for which tools are to be retrieved.\\n        top_k (int, optional): The number of top similar tools to be retrieved. Defaults to 5.\\n\\n    Returns:\\n        dict: A dictionary with the list of retrieved tools and JSON representations of the tools.\\n\\n    Raises:\\n        HTTPException: If an error occurs during retrieving the tools.\\n    \\\"\\\"\\\"\\n    try:\\n        retrieved_tools = ada_retriever(app.doc_embeddings, app.id2tool, question, top_k)\\n    except Exception as e:\\n        error_report =  traceback.format_exc()\\n        logger.error(error_report)\\n        raise HTTPException(status_code=500, detail=f\\\"Errorhappens when retrieving tools:\\\\n{e}\\\\n\\\\n\\\" + error_report)\\n    \\n    tool_register:ToolRegister = app.tool_register\\n    tools_json = []\\n    for tool_name in retrieved_tools:\\n        if tool_name in tool_register.tools:\\n            tools_json.append(tool_register.get_tool_dict(tool_name))\\n    \\n    return {\\n        \\\"retrieved_tools\\\":retrieved_tools,\\n        \\\"tools_json\\\":tools_json,\\n    }\\n\",\n            \"name_column\": 10\n        },\n        \"get_json_schema_for_tool\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"get_json_schema_for_tool\",\n            \"md_content\": \"\",\n            \"code_start_line\": 177,\n            \"code_end_line\": 199,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"async def get_json_schema_for_tool(tool_names:List[str]=Body(...)):\\n    \\\"\\\"\\\"\\n    This function returns the JSON schema for the given list of tools.\\n\\n    Args:\\n        tool_names (List[str]): List of tool names for which JSON schema is required.\\n\\n    Returns:\\n        dict: JSON schema dictionary for all the available tools and list of error names for missing tools. \\n    \\\"\\\"\\\"\\n    tool_register:ToolRegister = app.tool_register\\n    \\n    error_names = []\\n    tools_json = []\\n    for tool_name in tool_names:\\n        if tool_name not in tool_register.tools:\\n            error_names.append(tool_name)\\n        else:\\n            tools_json.append(tool_register.get_tool_dict(tool_name))\\n    return {\\n        \\\"tools_json\\\": tools_json,\\n        \\\"missing_tools\\\": error_names,\\n    }\\n\",\n            \"name_column\": 10\n        },\n        \"get_json_schema_for_env\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"get_json_schema_for_env\",\n            \"md_content\": \"\",\n            \"code_start_line\": 202,\n            \"code_end_line\": 224,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"async def get_json_schema_for_env(env_names:List[str]=Body(...)):\\n    \\\"\\\"\\\"\\n    This function returns the JSON schema for the given list of tool environments.\\n\\n    Args:\\n        env_names (List[str]): List of environment names for which JSON schema is required.\\n\\n    Returns:\\n        dict: JSON schema dictionary for all the available environments and list of error names for missing environments. \\n    \\\"\\\"\\\"\\n    tool_register:ToolRegister = app.tool_register\\n    \\n    error_names = []\\n    envs_json = []\\n    for env_name in env_names:\\n        if env_name not in tool_register.envs:\\n            error_names.append(env_name)\\n        else:\\n            envs_json.append(tool_register.get_env_dict(env_name))\\n    return {\\n        \\\"envs_json\\\": envs_json,\\n        \\\"missing_envs\\\": error_names,\\n    }\\n\",\n            \"name_column\": 10\n        },\n        \"register_new_tool\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"register_new_tool\",\n            \"md_content\": \"\",\n            \"code_start_line\": 227,\n            \"code_end_line\": 249,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"async def register_new_tool(tool_name:str=Body(...), code:str=Body(...)):\\n    \\\"\\\"\\\"\\n    This function allows the user to register a new tool by providing the tool name and code.\\n\\n    Args:\\n        tool_name (str): The name of the new tool.\\n        code (str): The code for the new tool.\\n\\n    Returns:\\n        dict: A dictionary representing the registered tool.\\n\\n    Raises:\\n        HTTPException: If an error occurs during registering the new tool.\\n    \\\"\\\"\\\"\\n    tool_register:ToolRegister = app.tool_register\\n    try:\\n        tool_dict = tool_register.register_tool(tool_name,code)\\n    except Exception as e:\\n        error_report =  traceback.format_exc()\\n        logger.error(error_report)\\n        raise HTTPException(status_code=406, detail=f\\\"Error happens when registering new tool:\\\\n{e}\\\\n\\\\n\\\" + error_report)\\n    \\n    return tool_dict\\n\",\n            \"name_column\": 10\n        },\n        \"execute_tool\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"execute_tool\",\n            \"md_content\": \"\",\n            \"code_start_line\": 252,\n            \"code_end_line\": 289,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"async def execute_tool(tool_name:str=Body(...), arguments:dict=Body(...), env_name:str=Body(default=None)):\\n    \\\"\\\"\\\"\\n    This function executes a tool with the provided arguments and environment.\\n\\n    Args:\\n        tool_name (str): The name of the tool to be executed.\\n        arguments (dict): The arguments for executing the tool.\\n        env_name (str, optional): The name of the tool environment in which tool is to be executed. Defaults to None.\\n\\n    Returns:\\n        dict: The result of executing the tool is wrapped in a dictionary.\\n\\n    Raises:\\n        HTTPException: If an error occurs during tool execution.\\n    \\\"\\\"\\\"\\n    tool_register:ToolRegister = app.tool_register\\n    \\n    try:\\n        if env_name is not None:\\n            tool = tool_register[env_name,tool_name]\\n        else:\\n            tool = tool_register[tool_name]\\n        result = tool(**arguments)\\n        if isinstance(result,Coroutine):\\n            result = await result\\n        result = wrap_tool_response(result)\\n    except ToolNotFound as e:\\n        raise HTTPException(status_code=404, detail=str(e))\\n    except OutputNotReady as e:\\n        raise HTTPException(status_code=450, detail=e.next_try())\\n    except HTTPException as e:\\n        raise e\\n    except Exception as e:\\n        trace_info = traceback.format_exc()\\n        logger.error(f'Error happens when executing tool {tool_name}! Exception: {e}\\\\n{trace_info}')\\n        raise HTTPException(status_code=500, detail=trace_info)\\n    \\n    return result\\n\",\n            \"name_column\": 10\n        },\n        \"generate_directory_structure\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"generate_directory_structure\",\n            \"md_content\": \"\",\n            \"code_start_line\": 117,\n            \"code_end_line\": 124,\n            \"parent\": \"get_workspace_structure\",\n            \"have_return\": true,\n            \"code_content\": \"    def generate_directory_structure(path):\\n        result = {'name':os.path.basename(path)}\\n        if os.path.isdir(path):\\n            result['type'] = 'directory'\\n            result['children'] = [generate_directory_structure(os.path.join(path,child)) for child in os.listdir(path)]\\n        else:\\n            result['type'] = 'file'\\n        return result\\n\",\n            \"name_column\": 8\n        }\n    },\n    \"ToolServer/ToolServerNode/core/labels.py\": {\n        \"ToolLabels\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"ToolLabels\",\n            \"md_content\": \"\",\n            \"code_start_line\": 5,\n            \"code_end_line\": 70,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"class ToolLabels:\\n    \\\"\\\"\\\"A class representing a tool.\\n\\n    When invoked, this object runs the associated method using parameters defined in the signature.\\n\\n    Attributes:\\n        name (str): The name of the tool.\\n        description (str): Description of the tool.\\n        method (Callable): The function/method that the tool executes.\\n        signature (dict): Argument keys and values needed by the method to execute.\\n        required (list): List of required arguments for the method.\\n        enabled (bool): Flag indicating whether the tool is enabled or not.\\n        disabled_reason (str): Reason for disabling the tool, if applicable.\\n        func_type (str): Type of function for the tool, defaults to 'function'.\\n        visible (bool): Flag indicating whether the tool is visible or not.\\n    \\\"\\\"\\\"\\n\\n    def __init__(\\n        self,\\n        name: str,\\n        description: str,\\n        method: Callable[..., Any],\\n        signature: dict = {},\\n        required: list = [],\\n        enabled: bool = True,\\n        disabled_reason: Optional[str] = None,\\n        func_type: str = 'function',\\n        visible: bool = True,\\n    ):\\n        self.name = name\\n        self.description = description\\n        self.method = method\\n        self.signature = signature\\n        self.required = required\\n        self.enabled = enabled\\n        self.disabled_reason = disabled_reason\\n        self.func_type = func_type\\n        self.visible = visible\\n\\n    def dict(self, name_overwrite: str = '') -> dict:\\n        \\\"\\\"\\\"Returns the tool information as a dictionary.\\n\\n        Args:\\n            name_overwrite (str): Replacement string for tool name, defaults to empty string.\\n\\n        Returns:\\n            dict: Dictionary of tool attributes.\\n        \\\"\\\"\\\"\\n        \\n        return {\\n            \\\"name\\\": self.name if name_overwrite == '' else name_overwrite,\\n            \\\"description\\\": self.description[:1024],\\n            \\\"parameters\\\": {\\n                \\\"type\\\": \\\"object\\\",\\n                \\\"properties\\\": self.signature,\\n                \\\"required\\\": self.required\\n            }\\n        }\\n\\n    def __str__(self) -> str:\\n        \\\"\\\"\\\"Returns the tool information in a formatted string.\\n\\n        Returns:\\n            str: Formatted string containing tool attributes.\\n        \\\"\\\"\\\"\\n        return f\\\"{self.name}: {self.description}, args: {self.signature}\\\"\\n\",\n            \"name_column\": 6\n        },\n        \"EnvLabels\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"EnvLabels\",\n            \"md_content\": \"\",\n            \"code_start_line\": 73,\n            \"code_end_line\": 149,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"class EnvLabels:\\n    \\\"\\\"\\\"A class representing an environment.\\n\\n    Each environment has a set of subtools associated with it. This object manages the collection of tools.\\n\\n    Attributes:\\n        name (str): Name of the environment.\\n        description (str): Description of the environment.\\n        subtools_labels (dict): Collection of tools associated to the environment.\\n        defined_tools (list): List of tool names defined in the environment.\\n        cls (Type): Class that the environment pertains to.\\n        enabled (bool): Flag indicating whether the environment is enabled or not.\\n        disabled_reason (str): Reason for disabling the environment, if applicable.\\n        visible (bool): Flag indicating whether the environment is visible or not.\\n    \\\"\\\"\\\"\\n\\n    def __init__(\\n        self,\\n        name: str,\\n        description: str,\\n        subtools_labels: dict[ToolLabels] = {},\\n        defined_tools:list[str] = [],\\n        cls: Type = None,\\n        enabled: bool = True,\\n        disabled_reason: Optional[str] = None,\\n        visible: bool = True,\\n    ):\\n        self.name = name\\n        self.description = description\\n        self.subtools_labels = subtools_labels\\n        self.defined_tools = defined_tools\\n        self.cls = cls\\n        self.enabled = enabled\\n        self.disabled_reason = disabled_reason\\n        self.visible = visible\\n\\n    def dict(self,\\n             include_invisible=False,\\n             max_show_tools: int = CONFIG['toolregister']['env_max_tools_display']) -> dict:\\n        \\\"\\\"\\\"\\n        Returns the environment's tools as a dictionary.\\n\\n        Args:\\n            include_invisible (bool): If true, includes tools even if they're set as invisible.\\n            max_show_tools (int): Maximum number of tools to display in the output.\\n\\n        Returns:\\n            dict: Dictionary of environment attributes and associated tools.\\n        \\\"\\\"\\\"\\n        \\n        if include_invisible:\\n            tools_name = list(self.subtools_labels.keys())\\n        else:\\n            if CONFIG['toolregister']['parent_tools_visible']:\\n                tools_name = [tool_name for tool_name in self.subtools_labels.keys() if self.subtools_labels[tool_name].visible]\\n            else:\\n                tools_name = self.defined_tools\\n\\n        if max_show_tools != -1 and len(tools_name) > max_show_tools:\\n            # only show first max_show_tools tools\\n            tools_name = tools_name[:max_show_tools]\\n            tools_name.append('...')\\n\\n        return {\\n            \\\"name\\\": self.name,\\n            \\\"description\\\": self.description,\\n            \\\"total_tools\\\": len(self.subtools_labels),\\n            \\\"tools\\\": tools_name,\\n        }\\n\\n    def __str__(self) -> str:\\n        \\\"\\\"\\\"Returns the environment information as a formatted string.\\n\\n        Returns:\\n            str: Formatted string containing environment attributes.\\n        \\\"\\\"\\\"\\n        return f\\\"{self.name}: {self.description}\\\"\",\n            \"name_column\": 6\n        },\n        \"__init__\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"__init__\",\n            \"md_content\": \"\",\n            \"code_start_line\": 89,\n            \"code_end_line\": 107,\n            \"parent\": \"EnvLabels\",\n            \"have_return\": false,\n            \"code_content\": \"    def __init__(\\n        self,\\n        name: str,\\n        description: str,\\n        subtools_labels: dict[ToolLabels] = {},\\n        defined_tools:list[str] = [],\\n        cls: Type = None,\\n        enabled: bool = True,\\n        disabled_reason: Optional[str] = None,\\n        visible: bool = True,\\n    ):\\n        self.name = name\\n        self.description = description\\n        self.subtools_labels = subtools_labels\\n        self.defined_tools = defined_tools\\n        self.cls = cls\\n        self.enabled = enabled\\n        self.disabled_reason = disabled_reason\\n        self.visible = visible\\n\",\n            \"name_column\": 8\n        },\n        \"dict\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"dict\",\n            \"md_content\": \"\",\n            \"code_start_line\": 109,\n            \"code_end_line\": 141,\n            \"parent\": \"EnvLabels\",\n            \"have_return\": true,\n            \"code_content\": \"    def dict(self,\\n             include_invisible=False,\\n             max_show_tools: int = CONFIG['toolregister']['env_max_tools_display']) -> dict:\\n        \\\"\\\"\\\"\\n        Returns the environment's tools as a dictionary.\\n\\n        Args:\\n            include_invisible (bool): If true, includes tools even if they're set as invisible.\\n            max_show_tools (int): Maximum number of tools to display in the output.\\n\\n        Returns:\\n            dict: Dictionary of environment attributes and associated tools.\\n        \\\"\\\"\\\"\\n        \\n        if include_invisible:\\n            tools_name = list(self.subtools_labels.keys())\\n        else:\\n            if CONFIG['toolregister']['parent_tools_visible']:\\n                tools_name = [tool_name for tool_name in self.subtools_labels.keys() if self.subtools_labels[tool_name].visible]\\n            else:\\n                tools_name = self.defined_tools\\n\\n        if max_show_tools != -1 and len(tools_name) > max_show_tools:\\n            # only show first max_show_tools tools\\n            tools_name = tools_name[:max_show_tools]\\n            tools_name.append('...')\\n\\n        return {\\n            \\\"name\\\": self.name,\\n            \\\"description\\\": self.description,\\n            \\\"total_tools\\\": len(self.subtools_labels),\\n            \\\"tools\\\": tools_name,\\n        }\\n\",\n            \"name_column\": 8\n        },\n        \"__str__\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"__str__\",\n            \"md_content\": \"\",\n            \"code_start_line\": 143,\n            \"code_end_line\": 149,\n            \"parent\": \"EnvLabels\",\n            \"have_return\": true,\n            \"code_content\": \"    def __str__(self) -> str:\\n        \\\"\\\"\\\"Returns the environment information as a formatted string.\\n\\n        Returns:\\n            str: Formatted string containing environment attributes.\\n        \\\"\\\"\\\"\\n        return f\\\"{self.name}: {self.description}\\\"\",\n            \"name_column\": 8\n        }\n    },\n    \"ToolServer/ToolServerNode/core/__init__.py\": {},\n    \"ToolServer/ToolServerNode/core/exceptions.py\": {\n        \"OutputNotReady\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"OutputNotReady\",\n            \"md_content\": \"\",\n            \"code_start_line\": 4,\n            \"code_end_line\": 20,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"class OutputNotReady(Exception):\\n    \\\"\\\"\\\"The output is not ready.\\n        \\\"\\\"\\\"\\n    def __init__(self, *args: object,type:str='retry',next_calling:str=None,arguments:dict={}) -> None:\\n        super().__init__(*args)\\n        self.type = type\\n        self.next_calling = next_calling\\n        self.arguments = arguments\\n        \\n    def next_try(self):\\n        \\\"\\\"\\\"Prepare the next try by returning a dictionary\\n           containing type, next calling event and arguments.\\\"\\\"\\\"\\n        return {\\n            \\\"type\\\":self.type,\\n            \\\"next_calling\\\":self.next_calling,\\n            \\\"arguments\\\":self.arguments\\n        }\\n\",\n            \"name_column\": 6\n        },\n        \"ToolNotFound\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"ToolNotFound\",\n            \"md_content\": \"\",\n            \"code_start_line\": 22,\n            \"code_end_line\": 43,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"class ToolNotFound(Exception):\\n    \\\"\\\"\\\"Custom exception class that is raised when the tool is not found.\\n    \\n    Args:\\n        *args (object): Variable length argument list.\\n        tool_name (str): The name of the tool.\\n\\n    Attributes:\\n        tool_name (str): The name of the tool.\\n    \\\"\\\"\\\"\\n    def __init__(self, *args: object,tool_name:str=None) -> None:\\n        super().__init__(*args)\\n        self.tool_name = tool_name\\n        \\n    def __str__(self) -> str:\\n        \\\"\\\"\\\"Returns the formatted exception error message with the name of the tool\\\"\\\"\\\"\\n        s = super().__str__()\\n        if s != '':\\n            s += f'\\\\nThe tool {self.tool_name} is not found!'\\n        else:\\n            s = f'The tool {self.tool_name} is not found!'\\n        return s \\n\",\n            \"name_column\": 6\n        },\n        \"EnvNotFound\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"EnvNotFound\",\n            \"md_content\": \"\",\n            \"code_start_line\": 46,\n            \"code_end_line\": 69,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"class EnvNotFound(Exception):\\n    \\\"\\\"\\\"Custom exception class that is raised when the environment variable is not found.\\n    \\n    Args:\\n        *args (object): Variable length argument list.\\n        env_name (str): The name of the environment variable.\\n\\n    Attributes:\\n        addition_info (tuple): Additional information.\\n        env_name (str): The name of the environment variable.\\n    \\\"\\\"\\\"\\n    def __init__(self, *args: object,env_name:str=None) -> None:\\n        super().__init__(*args)\\n        self.addition_info = args\\n        self.env_name =  env_name\\n        \\n    def __str__(self)->str:\\n        \\\"\\\"\\\"Returns the formatted exception error message with the name of the environment variable\\\"\\\"\\\"\\n        s = super().__str__()\\n        if s != '':\\n            s += f'\\\\nThe env {self.env_name} is not found!'\\n        else:\\n            s = f'The tool {self.env_name} is not found!'\\n        return s \\n\",\n            \"name_column\": 6\n        },\n        \"ToolRegisterError\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"ToolRegisterError\",\n            \"md_content\": \"\",\n            \"code_start_line\": 71,\n            \"code_end_line\": 94,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"class ToolRegisterError(Exception):\\n    \\\"\\\"\\\"Custom exception class that is raised when registering a tool encounters an error.\\n    \\n    Args:\\n        *args (object): Variable length argument list.\\n        tool_name (str): The name of the tool.\\n\\n    Attributes:\\n        addition_info (tuple): Additional information.\\n        tool_name (str): The name of the tool.\\n    \\\"\\\"\\\"\\n    def __init__(self, *args: object,tool_name:str=None) -> None:\\n        super().__init__(*args)\\n        self.addition_info = args\\n        self.tool_name = tool_name\\n        \\n    def __str__(self)->str:\\n        \\\"\\\"\\\"Returns the formatted exception error message with the name of the tool\\\"\\\"\\\"\\n        s = super().__str__()\\n        if s != '':\\n            s += f'\\\\nError happens when registering tool {self.tool_name}!'\\n        else:\\n            s = f'Error happens when registering tool {self.tool_name}!'\\n        return s \\n\",\n            \"name_column\": 6\n        },\n        \"remove_color\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"remove_color\",\n            \"md_content\": \"\",\n            \"code_start_line\": 97,\n            \"code_end_line\": 107,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"def remove_color(text):\\n    \\\"\\\"\\\"Removes ANSI escape sequences i.e. colors, from the text.\\n\\n    Args:\\n        text (str): The text from which color needs to be removed.\\n\\n    Returns:\\n        str: The filtered text with no color.\\n    \\\"\\\"\\\"\\n\\n    return ansi_escape.sub('', text)\\n\",\n            \"name_column\": 4\n        },\n        \"ToolExecutionError\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"ToolExecutionError\",\n            \"md_content\": \"\",\n            \"code_start_line\": 109,\n            \"code_end_line\": 118,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"class ToolExecutionError(HTTPException):\\n    \\\"\\\"\\\"Custom exception class that is raised when the tool execution encounters an error.\\n\\n    Args:\\n        error_msg (str): The error message during tool execution.\\n    \\\"\\\"\\\"\\n    def __init__(self,error_msg:str):\\n        if isinstance(error_msg,str):\\n            error_msg = remove_color(error_msg)\\n        super().__init__(500,error_msg)\",\n            \"name_column\": 6\n        },\n        \"__init__\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"__init__\",\n            \"md_content\": \"\",\n            \"code_start_line\": 115,\n            \"code_end_line\": 118,\n            \"parent\": \"ToolExecutionError\",\n            \"have_return\": false,\n            \"code_content\": \"    def __init__(self,error_msg:str):\\n        if isinstance(error_msg,str):\\n            error_msg = remove_color(error_msg)\\n        super().__init__(500,error_msg)\",\n            \"name_column\": 8\n        },\n        \"next_try\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"next_try\",\n            \"md_content\": \"\",\n            \"code_start_line\": 13,\n            \"code_end_line\": 20,\n            \"parent\": \"OutputNotReady\",\n            \"have_return\": true,\n            \"code_content\": \"    def next_try(self):\\n        \\\"\\\"\\\"Prepare the next try by returning a dictionary\\n           containing type, next calling event and arguments.\\\"\\\"\\\"\\n        return {\\n            \\\"type\\\":self.type,\\n            \\\"next_calling\\\":self.next_calling,\\n            \\\"arguments\\\":self.arguments\\n        }\\n\",\n            \"name_column\": 8\n        },\n        \"__str__\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"__str__\",\n            \"md_content\": \"\",\n            \"code_start_line\": 87,\n            \"code_end_line\": 94,\n            \"parent\": \"ToolRegisterError\",\n            \"have_return\": true,\n            \"code_content\": \"    def __str__(self)->str:\\n        \\\"\\\"\\\"Returns the formatted exception error message with the name of the tool\\\"\\\"\\\"\\n        s = super().__str__()\\n        if s != '':\\n            s += f'\\\\nError happens when registering tool {self.tool_name}!'\\n        else:\\n            s = f'Error happens when registering tool {self.tool_name}!'\\n        return s \\n\",\n            \"name_column\": 8\n        }\n    },\n    \"ToolServer/ToolServerNode/core/base.py\": {\n        \"BaseEnv\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"BaseEnv\",\n            \"md_content\": \"\",\n            \"code_start_line\": 5,\n            \"code_end_line\": 76,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"class BaseEnv:\\n    \\\"\\\"\\\"\\n    BaseEnv class. It helps to handle functions and function names of the classes and subclasses.\\n    This class provides methods to get all functions, defined functions and their names.\\n    It also ensures the configuration updates if necessary.\\n\\n    Attributes:\\n        config(Dict[str, Any], optional): A dictionary containing the configuration. Defaults to an empty dictionary.\\n    \\\"\\\"\\\"\\n    def __init__(self, config: Dict[str, Any] = {}):\\n        \\\"\\\"\\\"Initialize BaseEnv class with specified or default configuration.\\n\\n        Args:\\n            config (Dict[str, Any], optional): A dictionary containing the configuration. Defaults to an empty dictionary.\\n\\n        Notes:\\n            The configuration is deep copied to avoid modifications to the original object.\\n        \\\"\\\"\\\"\\n        self.config = deepcopy(CONFIG)\\n        if isinstance(config, dict):\\n            self.config.update(config)\\n        \\n    @classmethod\\n    def __get_all_func_name__(cls) -> list[str]:\\n        \\\"\\\"\\\"Get all the function names of the class, excluding methods starting with '_' character.\\n\\n        Returns:\\n            list[str]: A list that contains function names.\\n        \\\"\\\"\\\"\\n        return [name for name in dir(cls) \\n        if not str(name).startswith('_') and callable(getattr(cls, name))]\\n\\n\\n    @classmethod\\n    def __get_all_func__(cls) -> list[Callable]:\\n        \\\"\\\"\\\"Get all functions of the class, excluding methods starting with '__' characters.\\n\\n        Returns:\\n            list[Callable]: A list that contains functions.\\n        \\\"\\\"\\\"\\n        func_names = cls.__get_all_func_name__()\\n        return list(map(getattr, [cls]*len(func_names), func_names))\\n\\n    @classmethod\\n    def __get_defined_func__(cls) -> list[Callable]:\\n        \\\"\\\"\\\"Get all the functions of the subclass, excluding methods starting with '_' character.\\n\\n        Returns:\\n            list[Callable]: A list that contains defined functions of the subclass.\\n\\n        Notes:\\n            This method removes the parent class's methods from the functions list to \\n            provide only the functions that are newly defined in the subclass.\\n        \\\"\\\"\\\"\\n        functions = cls.__get_all_func__()\\n        for parent_cls in cls.__bases__:\\n            if not issubclass(parent_cls, BaseEnv):\\n                continue\\n            parent_functions = parent_cls.__get_all_func__()\\n            functions = list(filter(lambda x: x not in parent_functions, functions))\\n    \\n        return functions\\n\\n    @classmethod\\n    def __get_defined_func_name__(cls) -> list[str]:\\n        \\\"\\\"\\\"Get all the function names of the subclass, excluding methods starting with '_' character.\\n\\n        Returns:\\n            list[str]: A list that contains function names of the subclass.\\n        \\\"\\\"\\\"\\n        functions = cls.__get_defined_func__()\\n        return list(map(lambda x: x.__name__, functions))\",\n            \"name_column\": 6\n        },\n        \"__init__\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"__init__\",\n            \"md_content\": \"\",\n            \"code_start_line\": 14,\n            \"code_end_line\": 25,\n            \"parent\": \"BaseEnv\",\n            \"have_return\": false,\n            \"code_content\": \"    def __init__(self, config: Dict[str, Any] = {}):\\n        \\\"\\\"\\\"Initialize BaseEnv class with specified or default configuration.\\n\\n        Args:\\n            config (Dict[str, Any], optional): A dictionary containing the configuration. Defaults to an empty dictionary.\\n\\n        Notes:\\n            The configuration is deep copied to avoid modifications to the original object.\\n        \\\"\\\"\\\"\\n        self.config = deepcopy(CONFIG)\\n        if isinstance(config, dict):\\n            self.config.update(config)\\n\",\n            \"name_column\": 8\n        },\n        \"__get_all_func_name__\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"__get_all_func_name__\",\n            \"md_content\": \"\",\n            \"code_start_line\": 28,\n            \"code_end_line\": 35,\n            \"parent\": \"BaseEnv\",\n            \"have_return\": true,\n            \"code_content\": \"    def __get_all_func_name__(cls) -> list[str]:\\n        \\\"\\\"\\\"Get all the function names of the class, excluding methods starting with '_' character.\\n\\n        Returns:\\n            list[str]: A list that contains function names.\\n        \\\"\\\"\\\"\\n        return [name for name in dir(cls) \\n        if not str(name).startswith('_') and callable(getattr(cls, name))]\\n\",\n            \"name_column\": 8\n        },\n        \"__get_all_func__\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"__get_all_func__\",\n            \"md_content\": \"\",\n            \"code_start_line\": 39,\n            \"code_end_line\": 46,\n            \"parent\": \"BaseEnv\",\n            \"have_return\": true,\n            \"code_content\": \"    def __get_all_func__(cls) -> list[Callable]:\\n        \\\"\\\"\\\"Get all functions of the class, excluding methods starting with '__' characters.\\n\\n        Returns:\\n            list[Callable]: A list that contains functions.\\n        \\\"\\\"\\\"\\n        func_names = cls.__get_all_func_name__()\\n        return list(map(getattr, [cls]*len(func_names), func_names))\\n\",\n            \"name_column\": 8\n        },\n        \"__get_defined_func__\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"__get_defined_func__\",\n            \"md_content\": \"\",\n            \"code_start_line\": 49,\n            \"code_end_line\": 66,\n            \"parent\": \"BaseEnv\",\n            \"have_return\": true,\n            \"code_content\": \"    def __get_defined_func__(cls) -> list[Callable]:\\n        \\\"\\\"\\\"Get all the functions of the subclass, excluding methods starting with '_' character.\\n\\n        Returns:\\n            list[Callable]: A list that contains defined functions of the subclass.\\n\\n        Notes:\\n            This method removes the parent class's methods from the functions list to \\n            provide only the functions that are newly defined in the subclass.\\n        \\\"\\\"\\\"\\n        functions = cls.__get_all_func__()\\n        for parent_cls in cls.__bases__:\\n            if not issubclass(parent_cls, BaseEnv):\\n                continue\\n            parent_functions = parent_cls.__get_all_func__()\\n            functions = list(filter(lambda x: x not in parent_functions, functions))\\n    \\n        return functions\\n\",\n            \"name_column\": 8\n        },\n        \"__get_defined_func_name__\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"__get_defined_func_name__\",\n            \"md_content\": \"\",\n            \"code_start_line\": 69,\n            \"code_end_line\": 76,\n            \"parent\": \"BaseEnv\",\n            \"have_return\": true,\n            \"code_content\": \"    def __get_defined_func_name__(cls) -> list[str]:\\n        \\\"\\\"\\\"Get all the function names of the subclass, excluding methods starting with '_' character.\\n\\n        Returns:\\n            list[str]: A list that contains function names of the subclass.\\n        \\\"\\\"\\\"\\n        functions = cls.__get_defined_func__()\\n        return list(map(lambda x: x.__name__, functions))\",\n            \"name_column\": 8\n        }\n    },\n    \"ToolServer/ToolServerNode/core/tools/shell.py\": {\n        \"async_read_pipe\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"async_read_pipe\",\n            \"md_content\": \"\",\n            \"code_start_line\": 10,\n            \"code_end_line\": 16,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"async def async_read_pipe(pipe: asyncio.StreamReader):\\n    ret = b''\\n    while True:\\n        try:\\n            ret += await asyncio.wait_for(pipe.readline(), timeout=0.01)\\n        except asyncio.TimeoutError:\\n            return ret\\n\",\n            \"name_column\": 10\n        },\n        \"read_exec_proc_display\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"read_exec_proc_display\",\n            \"md_content\": \"\",\n            \"code_start_line\": 17,\n            \"code_end_line\": 23,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"async def read_exec_proc_display(exec_proc: asyncio.subprocess.Process):\\n    display = \\\"\\\"\\n    for pipe, name in zip([exec_proc.stderr,exec_proc.stdout], ['stderr','stdout']):\\n        ret = await async_read_pipe(pipe)\\n        if ret != b'':\\n            display += f'\\\\n{name}:\\\\n'+ ret.decode()\\n    return display\\n\",\n            \"name_column\": 10\n        },\n        \"shell_command_executor\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"shell_command_executor\",\n            \"md_content\": \"\",\n            \"code_start_line\": 26,\n            \"code_end_line\": 109,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"async def shell_command_executor(command: str = '', run_async: bool = False, shell_id: int = None, kill:bool = False):\\n    \\\"\\\"\\\"The shell tool that execute shell command in root privilege, return the output and error. \\n    You can use this tool to install packages, download files, run programs, etc.\\n    Set run_async=True to run the command in a new thread and return instantly if your command is time costly like install packages, host services. \\n    Example:\\n    ```\\n    In: shell_command_executor(command='echo \\\"hello world\\\"')\\n    Out: \\\"hello world\\\"\\n    In: shell_command_executor(command='sleep 10', run_async=True)\\n    Out: {'shell_id': 0} # You can use this id to read the output and error later.\\n    In: shell_command_executor(shell_id=0, kill=True)\\n    Out: \\\"\\\" # The shell 0 will be killed.\\n    ```\\n\\n    :param string? command: The shell command to be executed, must avoid command requiring additional user input. Default is empty string.\\n    :param boolean? run_async: Whether to run the command asynchronously, default is False. If True, call this tool again with shell_id to get the final output and error. \\n    :param integer? shell_id: The id of shell to execute command, default is None, which means running in a new shell. Change this to execute command in the same shell.\\n    :param boolean? kill: If True, kill the shell which runs the command after execution. Default is False. Don't use any other kill command!\\n    \\\"\\\"\\\"\\n    if shell_id is not None:\\n        exec_proc = ALL_SHELLS.get(shell_id, None)\\n        if exec_proc is None:\\n            raise ToolExecutionError(\\n                {'Error': 'Shell not found or has been closed.'})\\n        if exec_proc.returncode is not None:\\n            print(exec_proc.returncode)\\n            ALL_SHELLS.pop(shell_id)\\n            raise ToolExecutionError({'Error': 'Shell has been closed.'})\\n\\n    else:\\n        exec_proc = await asyncio.create_subprocess_shell(\\n            'bash',\\n            stderr=asyncio.subprocess.PIPE,\\n            stdout=asyncio.subprocess.PIPE,\\n            stdin=asyncio.subprocess.PIPE,\\n            cwd=CONFIG['filesystem']['work_directory'])\\n        shell_id = max(ALL_SHELLS.keys(), default=-1) + 1\\n        ALL_SHELLS[shell_id] = exec_proc\\n\\n    if not run_async:\\n        try:\\n            ret = await asyncio.wait_for(exec_proc.communicate(command.encode()), timeout=CONFIG['shell']['timeout'])\\n        except asyncio.TimeoutError:\\n            des = \\\"Timeout while executing command.\\\"\\n            if kill:\\n                des += \\\" Shell has been killed.\\\"\\n                exec_proc.kill()\\n            display = await read_exec_proc_display(exec_proc)\\n            if display != \\\"\\\":\\n                des += \\\" But get some response:\\\" + display\\n                \\n            raise ToolExecutionError(des)\\n            \\n        ALL_SHELLS.pop(shell_id)\\n\\n        result = {\\n            'ReturnCode': exec_proc.returncode,\\n            'display': ''\\n        }\\n        if ret[1] != b'':\\n            result['display'] += f'\\\\nstderr:\\\\n'+ret[1].decode()\\n        if ret[0] != b'':\\n            result['display'] = f'\\\\nstdout:\\\\n'+ret[0].decode()\\n            \\n        if result['ReturnCode'] != 0 and not kill:\\n            raise ToolExecutionError(result)\\n        return result\\n    else:\\n        if command[-1] != '\\\\n':\\n            command += '\\\\n'\\n        exec_proc.stdin.write(command.encode())\\n        await exec_proc.stdin.drain()\\n        await asyncio.sleep(5)\\n        result = {'shell_id': shell_id , 'display':await read_exec_proc_display(exec_proc)}\\n        if result['display'] == \\\"\\\":\\n            await asyncio.sleep(30)\\n            result['display'] = await read_exec_proc_display(exec_proc)\\n        if kill:\\n            exec_proc.kill()\\n            ALL_SHELLS.pop(shell_id)\\n            result['status'] = 'shell thread has been killed'\\n        else:\\n            result['status'] = 'shell still running, no return code'\\n        return result\\n\",\n            \"name_column\": 10\n        }\n    },\n    \"ToolServer/ToolServerNode/core/tools/__init__.py\": {},\n    \"ToolServer/ToolServerNode/core/register/wrapper.py\": {\n        \"generate_tool_labels\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"generate_tool_labels\",\n            \"md_content\": \"\",\n            \"code_start_line\": 14,\n            \"code_end_line\": 83,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"def generate_tool_labels(\\n    name: str = None,\\n    enabled: bool = True,\\n    disabled_reason: Optional[str] = None,\\n    func: Callable[..., Any] = None,\\n    visible:bool = True,\\n)->Union[ToolLabels,None]:\\n    \\\"\\\"\\\"\\n    Generate and return tool labels for the provided function. If the tool is not enabled,\\n    then a debug log message is printed and None is returned.\\n\\n    Args:\\n        name (str, optional): The name of the tool. If it's not specified, the function's name is used.\\n        enabled (bool, optional): Determines if the tool is enabled or not. Defaults to True.\\n        disabled_reason (Optional[str], optional): The reason why the tool is disabled. Defaults to None.\\n        func (Callable[..., Any], optional): The function for which the tool labels are generated. Defaults to None.\\n        visible(bool, optional): The visibility status of the tool. Defaults to True.\\n\\n    Returns:\\n        Union[ToolLabels,None]: A ToolLabels object containing tool information or None if tool is not enabled. \\n    \\\"\\\"\\\"\\n\\n    if not enabled:\\n        if disabled_reason is not None:\\n            logger.debug(f\\\"tool '{func.__name__}' is disabled: {disabled_reason}\\\")\\n        return None\\n\\n    # check if the method have full annotations\\n    auto_signature = {}\\n    func_desc =  docstring_parser.parse(func.__doc__)\\n    required = []\\n    for arg in func_desc.params:\\n        auto_signature[arg.arg_name] = {\\n            'type':arg.type_name,           # TODO support self defined type\\n            'description':arg.description,\\n        }\\n        if arg.default is not None:\\n            auto_signature[arg.arg_name]['default'] = arg.default\\n        if not arg.is_optional:\\n            required.append(arg.arg_name)\\n\\n    # for arg in inspect.getargs(func.__code__).args:\\n    #     if arg in auto_signature:\\n    #         continue\\n    #     if arg in ['self','cls','config','return']:\\n    #         continue\\n    #     # if arg not in func.__annotations__:\\n    #     #     raise SyntaxError(f'Signature is None and the annotation of varable {arg} in func {func.__name__} is not found!')\\n    #     auto_signature[arg] = {\\n    #         'type':'string',\\n    #         'description':''                # TODO try to generate description\\n    #     }\\n\\n    tool_name = func.__name__ if name is None else name\\n    description = ''\\n    if func_desc.short_description is not None:\\n        description = func_desc.short_description\\n    if func_desc.long_description is not None:\\n        description += '\\\\n' + func_desc.long_description\\n\\n    return ToolLabels(\\n        name=tool_name,\\n        description=description,\\n        method=func,\\n        signature=auto_signature,\\n        required=required,\\n        enabled=enabled,\\n        disabled_reason=disabled_reason,\\n        visible=visible,\\n    )\\n\",\n            \"name_column\": 4\n        },\n        \"toolwrapper\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"toolwrapper\",\n            \"md_content\": \"\",\n            \"code_start_line\": 85,\n            \"code_end_line\": 167,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"def toolwrapper(\\n    name: str = None,\\n    enabled: bool = True,\\n    disabled_reason: Optional[str] = None,\\n    parent_tools_visible: bool = CONFIG['toolregister']['parent_tools_visible'],\\n    visible:bool = True,\\n)->Union[Type,Callable[..., Any]]:\\n    \\\"\\\"\\\"The tool decorator for class, used to create tool objects from ordinary class.\\\"\\\"\\\"\\n\\n    def decorator(obj:object)->Union[Type,Callable[..., Any]]:\\n        if inspect.isclass(obj):\\n            cls = obj\\n            cls_name = name if name is not None else cls.__name__\\n            if not issubclass(cls,BaseEnv):\\n                raise Exception(f'The class {cls} is not a subclass of BaseEnv!')\\n            \\n            description = cls.__doc__ if cls.__doc__ is not None else ''\\n            if not visible:\\n                description = 'Note: All tools of this env are invisible during all tools display, please check this env\\\\'s defination to show all tools.\\\\n' + description\\n            \\n            \\n            subtools_labels = {}\\n            if BaseEnv not in cls.__bases__:\\n                direct_parents = [parent.__name__ for parent in cls.__bases__]\\n                if not parent_tools_visible:\\n                    description = f'Note: This env is subclass of {direct_parents}, and all tools of parent envs are inherited and not visible. You can try call parent tools or check this env\\\\'s defination to show them.\\\\n' + description\\n                else:\\n                    description = f'Note: This env is subclass of {direct_parents}, and all tools of parent envs are inherited.\\\\n' + description\\n                for parent in cls.__bases__:\\n                    if hasattr(parent,'env_labels') and isinstance(parent.env_labels,EnvLabels):\\n                        subtools_labels.update(parent.env_labels.subtools_labels)\\n            \\n            cls_func_names = cls.__get_defined_func_name__()            \\n            for func_name in cls_func_names:\\n                origin_func = getattr(cls,func_name)\\n                tool_labels = generate_tool_labels(\\n                    name=func_name,\\n                    enabled=enabled,\\n                    disabled_reason=disabled_reason,\\n                    func=origin_func,\\n                    visible=visible)\\n                if tool_labels is None:\\n                    continue\\n                \\n                # label classmethod, staticmethod and instance method\\n                #check if the function is a classmethod\\n                if inspect.ismethod(origin_func) and not inspect.isfunction(origin_func):\\n                    tool_labels.func_type = 'classmethod'\\n                # check if the function is a staticmethod\\n                if 'self' in inspect.getargs(origin_func.__code__).args:\\n                    tool_labels.func_type = 'instancemethod'\\n                else:   \\n                    tool_labels.func_type = 'staticmethod'\\n                \\n                # tool_labels.dependent_cls = cls\\n                origin_func.tool_labels = tool_labels\\n                subtools_labels[tool_labels.name] = tool_labels\\n            \\n\\n            cls.env_labels = EnvLabels(\\n                name=cls_name,\\n                description=description,\\n                subtools_labels=subtools_labels,\\n                defined_tools=cls_func_names,\\n                cls=cls,\\n                enabled=enabled,\\n                disabled_reason=disabled_reason,\\n                visible=visible\\n            )\\n            return cls\\n        elif inspect.isfunction(obj):\\n            func = obj\\n            tool_labels = generate_tool_labels(\\n                name=name,\\n                enabled=enabled, \\n                disabled_reason=disabled_reason,\\n                func=func,\\n                visible=visible)\\n            func.tool_labels = tool_labels\\n            return func\\n        else:\\n            raise NotImplementedError(f'Object with type {type(obj)} not recognized!')\\n    return decorator\\n\",\n            \"name_column\": 4\n        },\n        \"decorator\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"decorator\",\n            \"md_content\": \"\",\n            \"code_start_line\": 94,\n            \"code_end_line\": 166,\n            \"parent\": \"toolwrapper\",\n            \"have_return\": true,\n            \"code_content\": \"    def decorator(obj:object)->Union[Type,Callable[..., Any]]:\\n        if inspect.isclass(obj):\\n            cls = obj\\n            cls_name = name if name is not None else cls.__name__\\n            if not issubclass(cls,BaseEnv):\\n                raise Exception(f'The class {cls} is not a subclass of BaseEnv!')\\n            \\n            description = cls.__doc__ if cls.__doc__ is not None else ''\\n            if not visible:\\n                description = 'Note: All tools of this env are invisible during all tools display, please check this env\\\\'s defination to show all tools.\\\\n' + description\\n            \\n            \\n            subtools_labels = {}\\n            if BaseEnv not in cls.__bases__:\\n                direct_parents = [parent.__name__ for parent in cls.__bases__]\\n                if not parent_tools_visible:\\n                    description = f'Note: This env is subclass of {direct_parents}, and all tools of parent envs are inherited and not visible. You can try call parent tools or check this env\\\\'s defination to show them.\\\\n' + description\\n                else:\\n                    description = f'Note: This env is subclass of {direct_parents}, and all tools of parent envs are inherited.\\\\n' + description\\n                for parent in cls.__bases__:\\n                    if hasattr(parent,'env_labels') and isinstance(parent.env_labels,EnvLabels):\\n                        subtools_labels.update(parent.env_labels.subtools_labels)\\n            \\n            cls_func_names = cls.__get_defined_func_name__()            \\n            for func_name in cls_func_names:\\n                origin_func = getattr(cls,func_name)\\n                tool_labels = generate_tool_labels(\\n                    name=func_name,\\n                    enabled=enabled,\\n                    disabled_reason=disabled_reason,\\n                    func=origin_func,\\n                    visible=visible)\\n                if tool_labels is None:\\n                    continue\\n                \\n                # label classmethod, staticmethod and instance method\\n                #check if the function is a classmethod\\n                if inspect.ismethod(origin_func) and not inspect.isfunction(origin_func):\\n                    tool_labels.func_type = 'classmethod'\\n                # check if the function is a staticmethod\\n                if 'self' in inspect.getargs(origin_func.__code__).args:\\n                    tool_labels.func_type = 'instancemethod'\\n                else:   \\n                    tool_labels.func_type = 'staticmethod'\\n                \\n                # tool_labels.dependent_cls = cls\\n                origin_func.tool_labels = tool_labels\\n                subtools_labels[tool_labels.name] = tool_labels\\n            \\n\\n            cls.env_labels = EnvLabels(\\n                name=cls_name,\\n                description=description,\\n                subtools_labels=subtools_labels,\\n                defined_tools=cls_func_names,\\n                cls=cls,\\n                enabled=enabled,\\n                disabled_reason=disabled_reason,\\n                visible=visible\\n            )\\n            return cls\\n        elif inspect.isfunction(obj):\\n            func = obj\\n            tool_labels = generate_tool_labels(\\n                name=name,\\n                enabled=enabled, \\n                disabled_reason=disabled_reason,\\n                func=func,\\n                visible=visible)\\n            func.tool_labels = tool_labels\\n            return func\\n        else:\\n            raise NotImplementedError(f'Object with type {type(obj)} not recognized!')\\n\",\n            \"name_column\": 8\n        }\n    },\n    \"ToolServer/ToolServerNode/core/register/register.py\": {\n        \"get_func_name\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"get_func_name\",\n            \"md_content\": \"\",\n            \"code_start_line\": 16,\n            \"code_end_line\": 26,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"def get_func_name(func:Callable,env:BaseEnv=None)->str:\\n    if env is None or not hasattr(env,'env_labels'):\\n        if hasattr(func,'tool_labels'):\\n            return func.tool_labels.name\\n        else:\\n            return func.__name__\\n    else:\\n        if hasattr(func,'tool_labels'):\\n            return env.env_labels.name + '_' + func.tool_labels.name\\n        else:\\n            return env.env_labels.name + '_' + func.__name__\\n\",\n            \"name_column\": 4\n        },\n        \"ToolRegister\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"ToolRegister\",\n            \"md_content\": \"\",\n            \"code_start_line\": 29,\n            \"code_end_line\": 204,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"class ToolRegister:\\n    def __init__(self,\\n                 config:dict = {},\\n                 ):\\n        self.config = deepcopy(CONFIG)\\n        for k in config:\\n            self.config[k] = config[k]\\n        self.toolregister_cfg = self.config['toolregister']\\n        self.tool_creation_doc = open(self.toolregister_cfg['tool_creation_doc']).read()\\n        self.tool_creation_context = {}\\n        self.tool_creation_context_load_code = []\\n        for k in self.toolregister_cfg['tool_creation_context']:\\n            # load\\n            load_code = f\\\"from {self.toolregister_cfg['tool_creation_context'][k]} import {k}\\\"\\n            exec(load_code)\\n            self.tool_creation_context[k] = eval(k)\\n            self.tool_creation_context_load_code.append(load_code)\\n        # load modules\\n        self.tools = {}\\n        self.envs = {}\\n        for module_name in ['core.envs','core.tools']:            \\n            sub_modules = importlib.import_module(module_name).__all__\\n            for module in sub_modules:\\n                for attr_name in dir(module):\\n                    attr = getattr(module,attr_name)\\n                    self.check_and_register(attr)\\n            \\n        # load extensions\\n        if 'enabled_extensions' in self.config.cfg and isinstance(self.config['enabled_extensions'],list):\\n            for extension in self.config['enabled_extensions']:\\n                self.dynamic_extension_load(extension)\\n        \\n        logger.info(f'Loaded {len(self.tools)} tools and {len(self.envs)} envs!')\\n        # print(self.tools)\\n    def check_and_register(self,attr:Any):\\n        if hasattr(attr,'tool_labels') and isinstance(attr.tool_labels,ToolLabels):\\n            tool_name = get_func_name(attr)\\n            if tool_name in self.tools:\\n                logger.warning(f'Tool {tool_name} is replicated! The new one will be replaced!')\\n                return None\\n            \\n            self.tools[tool_name] = attr\\n            logger.info(f'Register tool {tool_name}!')\\n            return attr\\n            \\n        if hasattr(attr,'env_labels') and isinstance(attr.env_labels,EnvLabels):\\n            # attr is a cls, need get instance\\n            if attr.env_labels.name in self.envs:\\n                return\\n            if not issubclass(attr,BaseEnv):\\n                raise Exception(f'The env {attr.env_labels.name} is not a subclass of BaseEnv!')\\n            env = attr(config=self.config.dict())\\n            env_tools = {}\\n            \\n            if self.toolregister_cfg['parent_tools_visible']:\\n                func_names = env.__get_all_func_name__()\\n            else:\\n                func_names = env.__get_defined_func_name__()\\n            \\n            for func_name in func_names:\\n                func = getattr(env,func_name)\\n                if hasattr(func,'tool_labels'):\\n                    env_tools[get_func_name(func,env)] = func\\n            \\n            env_keys = set(env_tools.keys())\\n            tools_keys = set(self.tools.keys())\\n            if env_keys & tools_keys:\\n                logger.warning(f'Env {env.env_labels.name} has tools with same name as other tools! The new one will be ignored!')\\n                for tool_name in env_keys & tools_keys:\\n                    env_tools.pop(tool_name)\\n\\n            self.tools.update(env_tools)\\n            \\n            self.envs[attr.env_labels.name] = env\\n            logger.info(f'Register env {env.env_labels.name} with {len(env_tools)} tools!')\\n            \\n            return env\\n            \\n        return None\\n\\n    def register_tool(self,tool_name:str,code:str)->str:\\n        try:\\n            exec(code,self.tool_creation_context)\\n        except Exception as e:\\n            error_report =  traceback.format_exc()\\n            logger.error(error_report)\\n            raise ToolRegisterError(f'Failed to execute new tool code: {e}\\\\n\\\\n' + error_report,tool_name=tool_name)\\n        \\n        try:\\n            tool_func = eval(tool_name,self.tool_creation_context)\\n        except:\\n            raise ToolRegisterError(f'Failed to find tool, please verify the tool_name!',tool_name=tool_name)\\n        \\n        tool_func = self.check_and_register(tool_func)\\n        if tool_func is None:\\n            raise ToolRegisterError(f'Tool: {tool_name} has no labels or replicated! Ensuring wrap the tool with `@toolwrapper()`.',tool_name=tool_name)\\n        \\n        # write the tool into file under extensions/tools\\n        code = '\\\\n'.join(self.tool_creation_context_load_code) +'\\\\n# Tool Creation Context Load Ended.\\\\n'+ code\\n        tool_file = f'extensions/tools/{tool_name}.py'\\n        with open(tool_file,'w') as f:\\n            f.write(code)\\n        \\n        return self.get_tool_dict(tool_name)\\n    \\n    def dynamic_extension_load(self,extension:str)->bool:\\n        '''Load extension dynamically.\\n        \\n        :param string extension: The load path of the extension.\\n        :return boolean: True if success, False if failed.\\n        '''\\n        try:\\n            module = importlib.import_module(extension)\\n            for attr_name in dir(module):\\n                attr = getattr(module,attr_name)\\n                self.check_and_register(attr)\\n        except Exception as e:\\n            logger.error(f'Failed to load extension {extension}! Exception: {e}')\\n            # logger.error(traceback.format_exc())\\n            return False\\n        \\n        return True\\n        \\n    def get_tool_dict(self,tool_name:str)->dict:\\n        return self[tool_name].tool_labels.dict(name_overwrite=tool_name)\\n    \\n    def get_env_dict(self,env_name:str)->dict:\\n        if env_name not in self.envs:\\n            raise EnvNotFound(env_name=env_name)\\n        return self.envs[env_name].env_labels.dict(include_invisible=True,max_show_tools = -1)\\n    \\n    def get_all_envs(self)->list[dict]:\\n        return [self.envs[env_name].env_labels.dict()  for env_name in self.envs]\\n    \\n    def get_all_tools(self,include_invisible=False)->list[str]:\\n        if include_invisible:\\n            return [tool_name  for tool_name in self.tools]\\n        else:\\n            return [tool_name  for tool_name in self.tools if self.tools[tool_name].tool_labels.visible]\\n    \\n    def get_all_tools_dict(self,include_invisible=False)->list[dict]:\\n        return [self.tools[tool_name].tool_labels.dict(name_overwrite=tool_name)  for tool_name in self.get_all_tools(include_invisible)]\\n    \\n    def __getitem__(self, key)->Callable[..., Any]:\\n        # two stage index, first find env, then find tool\\n        if isinstance(key,str):\\n            if key not in self.tools:\\n                # check if the tool is a env subtool which not visible\\n                try:\\n                    tool_name = key.split('_')\\n                    env_name = tool_name[0]\\n                    tool_name = '_'.join(tool_name[1:])\\n                    return self[env_name,tool_name]\\n                except:\\n                    if self.dynamic_extension_load(f'extensions.tools.{key}') and key in self.tools:\\n                        # try to find tool in unloaded extensions\\n                        return self.tools[key]\\n                    else:\\n                        raise ToolNotFound(tool_name=key)\\n            return self.tools[key]\\n        elif isinstance(key,tuple):\\n            if len(key) != 2:\\n                raise NotImplementedError(f'Key {key} is not valid!')\\n            env_name,tool_name = key\\n            if env_name not in self.envs:\\n                # try to find env in unloaded extensions\\n                if self.dynamic_extension_load(f'extensions.envs.{env_name}') and env_name in self.envs:\\n                    env = self.envs[env_name]\\n                raise EnvNotFound(env_name=env_name)\\n            env = self.envs[env_name]\\n            if tool_name not in env.env_labels.subtools_labels:\\n                raise ToolNotFound(tool_name=env_name+'_'+tool_name)\\n            else:\\n                func = getattr(env,env.env_labels.subtools_labels[tool_name].method.__name__)\\n                return func\\n        raise NotImplementedError(f'Key {key} is not valid!')\",\n            \"name_column\": 6\n        },\n        \"__init__\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"__init__\",\n            \"md_content\": \"\",\n            \"code_start_line\": 30,\n            \"code_end_line\": 61,\n            \"parent\": \"ToolRegister\",\n            \"have_return\": false,\n            \"code_content\": \"    def __init__(self,\\n                 config:dict = {},\\n                 ):\\n        self.config = deepcopy(CONFIG)\\n        for k in config:\\n            self.config[k] = config[k]\\n        self.toolregister_cfg = self.config['toolregister']\\n        self.tool_creation_doc = open(self.toolregister_cfg['tool_creation_doc']).read()\\n        self.tool_creation_context = {}\\n        self.tool_creation_context_load_code = []\\n        for k in self.toolregister_cfg['tool_creation_context']:\\n            # load\\n            load_code = f\\\"from {self.toolregister_cfg['tool_creation_context'][k]} import {k}\\\"\\n            exec(load_code)\\n            self.tool_creation_context[k] = eval(k)\\n            self.tool_creation_context_load_code.append(load_code)\\n        # load modules\\n        self.tools = {}\\n        self.envs = {}\\n        for module_name in ['core.envs','core.tools']:            \\n            sub_modules = importlib.import_module(module_name).__all__\\n            for module in sub_modules:\\n                for attr_name in dir(module):\\n                    attr = getattr(module,attr_name)\\n                    self.check_and_register(attr)\\n            \\n        # load extensions\\n        if 'enabled_extensions' in self.config.cfg and isinstance(self.config['enabled_extensions'],list):\\n            for extension in self.config['enabled_extensions']:\\n                self.dynamic_extension_load(extension)\\n        \\n        logger.info(f'Loaded {len(self.tools)} tools and {len(self.envs)} envs!')\\n\",\n            \"name_column\": 8\n        },\n        \"check_and_register\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"check_and_register\",\n            \"md_content\": \"\",\n            \"code_start_line\": 63,\n            \"code_end_line\": 107,\n            \"parent\": \"ToolRegister\",\n            \"have_return\": true,\n            \"code_content\": \"    def check_and_register(self,attr:Any):\\n        if hasattr(attr,'tool_labels') and isinstance(attr.tool_labels,ToolLabels):\\n            tool_name = get_func_name(attr)\\n            if tool_name in self.tools:\\n                logger.warning(f'Tool {tool_name} is replicated! The new one will be replaced!')\\n                return None\\n            \\n            self.tools[tool_name] = attr\\n            logger.info(f'Register tool {tool_name}!')\\n            return attr\\n            \\n        if hasattr(attr,'env_labels') and isinstance(attr.env_labels,EnvLabels):\\n            # attr is a cls, need get instance\\n            if attr.env_labels.name in self.envs:\\n                return\\n            if not issubclass(attr,BaseEnv):\\n                raise Exception(f'The env {attr.env_labels.name} is not a subclass of BaseEnv!')\\n            env = attr(config=self.config.dict())\\n            env_tools = {}\\n            \\n            if self.toolregister_cfg['parent_tools_visible']:\\n                func_names = env.__get_all_func_name__()\\n            else:\\n                func_names = env.__get_defined_func_name__()\\n            \\n            for func_name in func_names:\\n                func = getattr(env,func_name)\\n                if hasattr(func,'tool_labels'):\\n                    env_tools[get_func_name(func,env)] = func\\n            \\n            env_keys = set(env_tools.keys())\\n            tools_keys = set(self.tools.keys())\\n            if env_keys & tools_keys:\\n                logger.warning(f'Env {env.env_labels.name} has tools with same name as other tools! The new one will be ignored!')\\n                for tool_name in env_keys & tools_keys:\\n                    env_tools.pop(tool_name)\\n\\n            self.tools.update(env_tools)\\n            \\n            self.envs[attr.env_labels.name] = env\\n            logger.info(f'Register env {env.env_labels.name} with {len(env_tools)} tools!')\\n            \\n            return env\\n            \\n        return None\\n\",\n            \"name_column\": 8\n        },\n        \"register_tool\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"register_tool\",\n            \"md_content\": \"\",\n            \"code_start_line\": 109,\n            \"code_end_line\": 132,\n            \"parent\": \"ToolRegister\",\n            \"have_return\": true,\n            \"code_content\": \"    def register_tool(self,tool_name:str,code:str)->str:\\n        try:\\n            exec(code,self.tool_creation_context)\\n        except Exception as e:\\n            error_report =  traceback.format_exc()\\n            logger.error(error_report)\\n            raise ToolRegisterError(f'Failed to execute new tool code: {e}\\\\n\\\\n' + error_report,tool_name=tool_name)\\n        \\n        try:\\n            tool_func = eval(tool_name,self.tool_creation_context)\\n        except:\\n            raise ToolRegisterError(f'Failed to find tool, please verify the tool_name!',tool_name=tool_name)\\n        \\n        tool_func = self.check_and_register(tool_func)\\n        if tool_func is None:\\n            raise ToolRegisterError(f'Tool: {tool_name} has no labels or replicated! Ensuring wrap the tool with `@toolwrapper()`.',tool_name=tool_name)\\n        \\n        # write the tool into file under extensions/tools\\n        code = '\\\\n'.join(self.tool_creation_context_load_code) +'\\\\n# Tool Creation Context Load Ended.\\\\n'+ code\\n        tool_file = f'extensions/tools/{tool_name}.py'\\n        with open(tool_file,'w') as f:\\n            f.write(code)\\n        \\n        return self.get_tool_dict(tool_name)\\n\",\n            \"name_column\": 8\n        },\n        \"dynamic_extension_load\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"dynamic_extension_load\",\n            \"md_content\": \"\",\n            \"code_start_line\": 134,\n            \"code_end_line\": 150,\n            \"parent\": \"ToolRegister\",\n            \"have_return\": true,\n            \"code_content\": \"    def dynamic_extension_load(self,extension:str)->bool:\\n        '''Load extension dynamically.\\n        \\n        :param string extension: The load path of the extension.\\n        :return boolean: True if success, False if failed.\\n        '''\\n        try:\\n            module = importlib.import_module(extension)\\n            for attr_name in dir(module):\\n                attr = getattr(module,attr_name)\\n                self.check_and_register(attr)\\n        except Exception as e:\\n            logger.error(f'Failed to load extension {extension}! Exception: {e}')\\n            # logger.error(traceback.format_exc())\\n            return False\\n        \\n        return True\\n\",\n            \"name_column\": 8\n        },\n        \"get_tool_dict\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"get_tool_dict\",\n            \"md_content\": \"\",\n            \"code_start_line\": 152,\n            \"code_end_line\": 153,\n            \"parent\": \"ToolRegister\",\n            \"have_return\": true,\n            \"code_content\": \"    def get_tool_dict(self,tool_name:str)->dict:\\n        return self[tool_name].tool_labels.dict(name_overwrite=tool_name)\\n\",\n            \"name_column\": 8\n        },\n        \"get_env_dict\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"get_env_dict\",\n            \"md_content\": \"\",\n            \"code_start_line\": 155,\n            \"code_end_line\": 158,\n            \"parent\": \"ToolRegister\",\n            \"have_return\": true,\n            \"code_content\": \"    def get_env_dict(self,env_name:str)->dict:\\n        if env_name not in self.envs:\\n            raise EnvNotFound(env_name=env_name)\\n        return self.envs[env_name].env_labels.dict(include_invisible=True,max_show_tools = -1)\\n\",\n            \"name_column\": 8\n        },\n        \"get_all_envs\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"get_all_envs\",\n            \"md_content\": \"\",\n            \"code_start_line\": 160,\n            \"code_end_line\": 161,\n            \"parent\": \"ToolRegister\",\n            \"have_return\": true,\n            \"code_content\": \"    def get_all_envs(self)->list[dict]:\\n        return [self.envs[env_name].env_labels.dict()  for env_name in self.envs]\\n\",\n            \"name_column\": 8\n        },\n        \"get_all_tools\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"get_all_tools\",\n            \"md_content\": \"\",\n            \"code_start_line\": 163,\n            \"code_end_line\": 167,\n            \"parent\": \"ToolRegister\",\n            \"have_return\": true,\n            \"code_content\": \"    def get_all_tools(self,include_invisible=False)->list[str]:\\n        if include_invisible:\\n            return [tool_name  for tool_name in self.tools]\\n        else:\\n            return [tool_name  for tool_name in self.tools if self.tools[tool_name].tool_labels.visible]\\n\",\n            \"name_column\": 8\n        },\n        \"get_all_tools_dict\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"get_all_tools_dict\",\n            \"md_content\": \"\",\n            \"code_start_line\": 169,\n            \"code_end_line\": 170,\n            \"parent\": \"ToolRegister\",\n            \"have_return\": true,\n            \"code_content\": \"    def get_all_tools_dict(self,include_invisible=False)->list[dict]:\\n        return [self.tools[tool_name].tool_labels.dict(name_overwrite=tool_name)  for tool_name in self.get_all_tools(include_invisible)]\\n\",\n            \"name_column\": 8\n        },\n        \"__getitem__\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"__getitem__\",\n            \"md_content\": \"\",\n            \"code_start_line\": 172,\n            \"code_end_line\": 204,\n            \"parent\": \"ToolRegister\",\n            \"have_return\": true,\n            \"code_content\": \"    def __getitem__(self, key)->Callable[..., Any]:\\n        # two stage index, first find env, then find tool\\n        if isinstance(key,str):\\n            if key not in self.tools:\\n                # check if the tool is a env subtool which not visible\\n                try:\\n                    tool_name = key.split('_')\\n                    env_name = tool_name[0]\\n                    tool_name = '_'.join(tool_name[1:])\\n                    return self[env_name,tool_name]\\n                except:\\n                    if self.dynamic_extension_load(f'extensions.tools.{key}') and key in self.tools:\\n                        # try to find tool in unloaded extensions\\n                        return self.tools[key]\\n                    else:\\n                        raise ToolNotFound(tool_name=key)\\n            return self.tools[key]\\n        elif isinstance(key,tuple):\\n            if len(key) != 2:\\n                raise NotImplementedError(f'Key {key} is not valid!')\\n            env_name,tool_name = key\\n            if env_name not in self.envs:\\n                # try to find env in unloaded extensions\\n                if self.dynamic_extension_load(f'extensions.envs.{env_name}') and env_name in self.envs:\\n                    env = self.envs[env_name]\\n                raise EnvNotFound(env_name=env_name)\\n            env = self.envs[env_name]\\n            if tool_name not in env.env_labels.subtools_labels:\\n                raise ToolNotFound(tool_name=env_name+'_'+tool_name)\\n            else:\\n                func = getattr(env,env.env_labels.subtools_labels[tool_name].method.__name__)\\n                return func\\n        raise NotImplementedError(f'Key {key} is not valid!')\",\n            \"name_column\": 8\n        }\n    },\n    \"ToolServer/ToolServerNode/core/register/__init__.py\": {},\n    \"ToolServer/ToolServerNode/core/envs/web.py\": {\n        \"WebEnv\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"WebEnv\",\n            \"md_content\": \"\",\n            \"code_start_line\": 12,\n            \"code_end_line\": 126,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"class WebEnv(BaseEnv):\\n    \\\"\\\"\\\"Web Environment providing web interface and browsering.\\n    \\\"\\\"\\\"\\n    def __init__(self,config:dict = {}):\\n        super().__init__(config=config)\\n        self.bing_cfg = self.config['bing']\\n        if self.bing_cfg['api_key'] is None:\\n            logger.warning(\\\"Bing API key is not provided, rollback to duckduckgo.\\\")\\n        \\n        self.web_cfg = self.config['web']\\n        self.headers = {\\n            \\\"User-Agent\\\":self.web_cfg['user_agent']\\n        }\\n        self.client = httpx.AsyncClient(headers=self.headers,verify=False,timeout=30.0,http2=True)\\n\\n    def _check_url_valid(self,url:str):\\n        local_prefixes = [\\n            \\\"file:///\\\",\\n            \\\"file://127.0.0.1\\\",\\n            \\\"file://localhost\\\",\\n            \\\"http://localhost\\\",\\n            \\\"https://localhost\\\",\\n            \\\"http://2130706433\\\",\\n            \\\"https://2130706433\\\",\\n            \\\"http://127.0.0.1\\\",\\n            \\\"https://127.0.0.1\\\",\\n            \\\"https://0.0.0.0\\\",\\n            \\\"http://0.0.0.0\\\",\\n            \\\"http://0000\\\",\\n            \\\"https://0000\\\",\\n        ]\\n        if any(url.startswith(prefix) for prefix in local_prefixes):\\n            raise ValueError(f\\\"URL {url} is a local url, blocked!\\\")\\n        if not (url.startswith(\\\"http\\\") or url.startswith(\\\"file\\\")):\\n            raise ValueError(f\\\"URL {url} is not a http or https url, please give a valid url!\\\")\\n        \\n    async def search_and_browse(self, search_query:str,goals_to_browse:str,region:str=None,num_results = 3) -> List[str]:\\n        \\\"\\\"\\\"Search with search tools and browse the website returned by search. Note some websites may not be accessable due to network error.\\n    \\n        :param string search_query: The search query.\\n        :param string goals_to_browse: What's you want to find on the website returned by search. If you need more details, request it in here. Examples: 'What is latest news about deepmind?', 'What is the main idea of this article?'\\n        :param string? region: The region code of the search, default to `en-US`. Available regions: `en-US`, `zh-CN`, `ja-JP`, `de-DE`, `fr-FR`, `en-GB`.\\n        :return string: The results of the search.\\n        \\\"\\\"\\\"\\n        \\n        api_key = self.bing_cfg[\\\"api_key\\\"]\\n        endpoint = self.bing_cfg[\\\"endpoint\\\"]\\n        if region is None:\\n            region = 'en-US'\\n        if api_key is None:\\n            pages = [{\\n                'name':ret['title'],\\n                'snippet':ret['body'],\\n                'url':ret['href']\\n            } for ret in DDGS().text(search_query, region='wt-wt')]\\n            \\n        else:\\n            result = await self.client.get(endpoint,\\n                        headers={'Ocp-Apim-Subscription-Key': api_key},\\n                        params={'q': search_query, 'mkt': region },\\n                        timeout=10)\\n            result.raise_for_status()\\n            result = result.json()\\n            pages = result[\\\"webPages\\\"][\\\"value\\\"]\\n            \\n        search_results = []\\n\\n        for idx in range(min(len(pages),num_results)):\\n            try:\\n                page = await self.browse_website(pages[idx]['url'],goals_to_browse)\\n            except httpx.HTTPStatusError as e:\\n                page = e.response.text\\n            except Exception as e:\\n                page = str(e)\\n                \\n            message = {\\n                'name':pages[idx]['name'],\\n                'snippet':pages[idx]['snippet'],\\n                'page':page\\n            }\\n            search_results.append(message)\\n\\n        return search_results\\n    \\n    async def browse_website(self,url:str,goals_to_browse:str)->str:\\n        \\\"\\\"\\\"Give a http or https url to browse a website and return the summarize text. Note some websites may not be accessable due to network error. This tool only return the content of give url and cannot provide any information need interaction with the website.\\n        \\n        :param string url: The realworld Uniform Resource Locator (web address) to scrape text from. Never provide something like \\\"<URL of the second news article>\\\", give real url!!! Example: 'https://www.deepmind.com/'\\n        :param string goals_to_browse: The goals for browse the given `url` (e.g. what you want to find on webpage.). If you need more details, request it in here.\\n        :return string: The content of the website, with formatted text.\\n        \\\"\\\"\\\"\\n        # self._check_url_valid(url)\\n        res = await self.client.get(url)\\n        if res.status_code in [301,302,307,308]:\\n            res = await self.client.get(res.headers['location'])\\n        else:\\n            res.raise_for_status()\\n        \\n        soup = BeautifulSoup(res.text,\\\"html.parser\\\")\\n        text = soup.get_text()\\n        lines = (line.strip() for line in text.splitlines())\\n        chunks = (phrase.strip() for line in lines for phrase in line.split(\\\"  \\\"))\\n        text = \\\"\\\\n\\\".join(chunk for chunk in chunks if chunk)\\n        \\n        links = soup.find_all('a')\\n        if len(links) > 0:\\n            text += '\\\\n\\\\nLinks:\\\\n'\\n            for link in links:\\n                if link.string != None and link.get('href')!= None:\\n                    # print(''.join(link.string.split()),link.get('href'))\\n                    striped_link_string = link.string.strip()\\n                    if striped_link_string != '' and  link.get('href').startswith('http'):\\n                        text += f\\\"{striped_link_string} ({link.get('href')})\\\\n\\\"\\n        \\n        return text\",\n            \"name_column\": 6\n        },\n        \"__init__\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"__init__\",\n            \"md_content\": \"\",\n            \"code_start_line\": 15,\n            \"code_end_line\": 25,\n            \"parent\": \"WebEnv\",\n            \"have_return\": false,\n            \"code_content\": \"    def __init__(self,config:dict = {}):\\n        super().__init__(config=config)\\n        self.bing_cfg = self.config['bing']\\n        if self.bing_cfg['api_key'] is None:\\n            logger.warning(\\\"Bing API key is not provided, rollback to duckduckgo.\\\")\\n        \\n        self.web_cfg = self.config['web']\\n        self.headers = {\\n            \\\"User-Agent\\\":self.web_cfg['user_agent']\\n        }\\n        self.client = httpx.AsyncClient(headers=self.headers,verify=False,timeout=30.0,http2=True)\\n\",\n            \"name_column\": 8\n        },\n        \"_check_url_valid\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"_check_url_valid\",\n            \"md_content\": \"\",\n            \"code_start_line\": 27,\n            \"code_end_line\": 46,\n            \"parent\": \"WebEnv\",\n            \"have_return\": false,\n            \"code_content\": \"    def _check_url_valid(self,url:str):\\n        local_prefixes = [\\n            \\\"file:///\\\",\\n            \\\"file://127.0.0.1\\\",\\n            \\\"file://localhost\\\",\\n            \\\"http://localhost\\\",\\n            \\\"https://localhost\\\",\\n            \\\"http://2130706433\\\",\\n            \\\"https://2130706433\\\",\\n            \\\"http://127.0.0.1\\\",\\n            \\\"https://127.0.0.1\\\",\\n            \\\"https://0.0.0.0\\\",\\n            \\\"http://0.0.0.0\\\",\\n            \\\"http://0000\\\",\\n            \\\"https://0000\\\",\\n        ]\\n        if any(url.startswith(prefix) for prefix in local_prefixes):\\n            raise ValueError(f\\\"URL {url} is a local url, blocked!\\\")\\n        if not (url.startswith(\\\"http\\\") or url.startswith(\\\"file\\\")):\\n            raise ValueError(f\\\"URL {url} is not a http or https url, please give a valid url!\\\")\\n\",\n            \"name_column\": 8\n        },\n        \"search_and_browse\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"search_and_browse\",\n            \"md_content\": \"\",\n            \"code_start_line\": 48,\n            \"code_end_line\": 94,\n            \"parent\": \"WebEnv\",\n            \"have_return\": true,\n            \"code_content\": \"    async def search_and_browse(self, search_query:str,goals_to_browse:str,region:str=None,num_results = 3) -> List[str]:\\n        \\\"\\\"\\\"Search with search tools and browse the website returned by search. Note some websites may not be accessable due to network error.\\n    \\n        :param string search_query: The search query.\\n        :param string goals_to_browse: What's you want to find on the website returned by search. If you need more details, request it in here. Examples: 'What is latest news about deepmind?', 'What is the main idea of this article?'\\n        :param string? region: The region code of the search, default to `en-US`. Available regions: `en-US`, `zh-CN`, `ja-JP`, `de-DE`, `fr-FR`, `en-GB`.\\n        :return string: The results of the search.\\n        \\\"\\\"\\\"\\n        \\n        api_key = self.bing_cfg[\\\"api_key\\\"]\\n        endpoint = self.bing_cfg[\\\"endpoint\\\"]\\n        if region is None:\\n            region = 'en-US'\\n        if api_key is None:\\n            pages = [{\\n                'name':ret['title'],\\n                'snippet':ret['body'],\\n                'url':ret['href']\\n            } for ret in DDGS().text(search_query, region='wt-wt')]\\n            \\n        else:\\n            result = await self.client.get(endpoint,\\n                        headers={'Ocp-Apim-Subscription-Key': api_key},\\n                        params={'q': search_query, 'mkt': region },\\n                        timeout=10)\\n            result.raise_for_status()\\n            result = result.json()\\n            pages = result[\\\"webPages\\\"][\\\"value\\\"]\\n            \\n        search_results = []\\n\\n        for idx in range(min(len(pages),num_results)):\\n            try:\\n                page = await self.browse_website(pages[idx]['url'],goals_to_browse)\\n            except httpx.HTTPStatusError as e:\\n                page = e.response.text\\n            except Exception as e:\\n                page = str(e)\\n                \\n            message = {\\n                'name':pages[idx]['name'],\\n                'snippet':pages[idx]['snippet'],\\n                'page':page\\n            }\\n            search_results.append(message)\\n\\n        return search_results\\n\",\n            \"name_column\": 14\n        },\n        \"browse_website\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"browse_website\",\n            \"md_content\": \"\",\n            \"code_start_line\": 96,\n            \"code_end_line\": 126,\n            \"parent\": \"WebEnv\",\n            \"have_return\": true,\n            \"code_content\": \"    async def browse_website(self,url:str,goals_to_browse:str)->str:\\n        \\\"\\\"\\\"Give a http or https url to browse a website and return the summarize text. Note some websites may not be accessable due to network error. This tool only return the content of give url and cannot provide any information need interaction with the website.\\n        \\n        :param string url: The realworld Uniform Resource Locator (web address) to scrape text from. Never provide something like \\\"<URL of the second news article>\\\", give real url!!! Example: 'https://www.deepmind.com/'\\n        :param string goals_to_browse: The goals for browse the given `url` (e.g. what you want to find on webpage.). If you need more details, request it in here.\\n        :return string: The content of the website, with formatted text.\\n        \\\"\\\"\\\"\\n        # self._check_url_valid(url)\\n        res = await self.client.get(url)\\n        if res.status_code in [301,302,307,308]:\\n            res = await self.client.get(res.headers['location'])\\n        else:\\n            res.raise_for_status()\\n        \\n        soup = BeautifulSoup(res.text,\\\"html.parser\\\")\\n        text = soup.get_text()\\n        lines = (line.strip() for line in text.splitlines())\\n        chunks = (phrase.strip() for line in lines for phrase in line.split(\\\"  \\\"))\\n        text = \\\"\\\\n\\\".join(chunk for chunk in chunks if chunk)\\n        \\n        links = soup.find_all('a')\\n        if len(links) > 0:\\n            text += '\\\\n\\\\nLinks:\\\\n'\\n            for link in links:\\n                if link.string != None and link.get('href')!= None:\\n                    # print(''.join(link.string.split()),link.get('href'))\\n                    striped_link_string = link.string.strip()\\n                    if striped_link_string != '' and  link.get('href').startswith('http'):\\n                        text += f\\\"{striped_link_string} ({link.get('href')})\\\\n\\\"\\n        \\n        return text\",\n            \"name_column\": 14\n        }\n    },\n    \"ToolServer/ToolServerNode/core/envs/filesystem.py\": {\n        \"FileSystemEnv\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"FileSystemEnv\",\n            \"md_content\": \"\",\n            \"code_start_line\": 10,\n            \"code_end_line\": 206,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"class FileSystemEnv(BaseEnv):\\n    \\\"\\\"\\\"Provide a file system operation environment for Agent.\\n    \\\"\\\"\\\"\\n    def __init__(self, config: Dict[str, Any] = None):\\n        super().__init__(config)\\n        filesystem_config = self.config['filesystem']\\n        \\n        self.ignored_list = filesystem_config[\\\"ignored_list\\\"]\\n        self.work_directory = filesystem_config[\\\"work_directory\\\"]\\n        self.max_entry_nums_for_level = filesystem_config[\\\"max_entry_nums_for_level\\\"]\\n        if not os.path.exists(self.work_directory):\\n            os.mkdir(self.work_directory,mode=0o777)\\n        \\n    def _check_ignorement(self,path:str)->bool:\\n        for pattern in self.ignored_list:\\n            if fnmatch.fnmatch(path,pattern):\\n                return True\\n        return False\\n    \\n    def _is_path_within_workspace(self,path:str)->bool:\\n        common_prefix = os.path.commonprefix([os.path.realpath(path),\\n                                            os.path.realpath(self.work_directory)])\\n        return common_prefix == os.path.realpath(self.work_directory)\\n    \\n    def _is_path_exist(self,path:str)->bool:\\n        \\\"\\\"\\\"Check if the path exists in the workspace.\\n        \\n        :param string path: The path to be checked.\\n        :return bool: `True` if the path exists, else `False`.\\n        \\\"\\\"\\\"\\n\\n        full_path = os.path.join(self.work_directory, path)\\n        if not self._is_path_within_workspace(full_path):\\n            raise ValueError(f\\\"Path {path} is not within workspace.\\\")\\n        return os.path.exists(full_path)\\n\\n    def print_filesys_struture(self,return_root=False)->str:\\n        \\\"\\\"\\\"Return a tree-like structure for all files and folders in the workspace. Use this tool if you are not sure what files are in the workspace.\\n\\n        This function recursively walks through all the directories in the workspace\\n        and return them in a tree-like structure, \\n        displaying all the files under each directory.\\n        \\n        Example:\\n        ```\\n        - root/\\n            - sub_directory1/\\n                - file1.txt\\n                - file2.txt\\n            - sub_directory2/\\n                - file3.txt\\n        ```\\n\\n        :return string: The tree-like structure of the workspace.\\n        \\\"\\\"\\\"\\n        full_repr = ''\\n        if return_root:\\n            full_repr += f'Global Root Work Directory: {self.work_directory}\\\\n'\\n\\n        folder_counts =  defaultdict(lambda: 0)\\n        for root, dirs, files in os.walk(self.work_directory):\\n            if self._check_ignorement(root):\\n                continue\\n            level = root.replace(self.work_directory, '').count(os.sep)\\n            indent = ' ' * 4 * (level)\\n            \\n            folder_counts[root] += 1\\n            if folder_counts[root] > self.max_entry_nums_for_level:\\n                full_repr += f'{indent}`wrapped`\\\\n'\\n            \\n            full_repr += f'{indent}- {os.path.basename(root)}/\\\\n'\\n            \\n            idx = 0\\n            subindent = ' ' * 4 * (level + 1) + '- '\\n            for f in files:\\n                if self._check_ignorement(f):\\n                    continue\\n                \\n                idx += 1\\n                if idx > self.max_entry_nums_for_level:\\n                    full_repr += f'{subindent}`wrapped`\\\\n'\\n                    break\\n                full_repr += f'{subindent}{f}\\\\n'\\n\\n\\n        return full_repr\\n    \\n    def read_from_file(self,filepath:str,line_number:int = 1)->str:\\n        \\\"\\\"\\\"Open and read the textual file content in the workspace, you will see the content of the target file.\\n        Don't use this if the give `filepath` is writen or modified before, the content in `filepath` should be already returned.\\n        \\n        :param string filepath: The path to the file to be opened, always use relative path to the workspace root.\\n        :param integer? line_number: The starting line number of the content to be opened. Defaults to 1.\\n        :return string: The content of the file.\\n        \\\"\\\"\\\"\\n        if not filepath.startswith(self.work_directory):\\n            filepath = filepath.strip('/')\\n            full_path = os.path.join(self.work_directory, filepath)        \\n        else:\\n            full_path = filepath\\n                \\n        if self._check_ignorement(full_path) or not os.path.isfile(full_path):\\n            raise FileNotFoundError(f\\\"File {filepath} not found in workspace.\\\")\\n        if not self._is_path_within_workspace(full_path):\\n            raise ValueError(f\\\"File {filepath} is not within workspace.\\\")\\n        if not os.path.exists(full_path):\\n            raise FileNotFoundError(f\\\"File {filepath} not found in workspace.\\\")\\n\\n        content = ''\\n        with open(full_path, 'r') as f:\\n            lines = f.readlines(int(1e5))\\n            \\n        read_count = 0\\n        if not (abs(line_number) - 1 < len(lines)):\\n            raise ValueError(f\\\"Line number {line_number} is out of range.\\\")\\n        index = line_number if line_number >= 0 else len(lines) + line_number\\n        if index == 0:\\n            index = 1\\n            \\n        if line_number == 0:\\n            indexed_lines = lines\\n        elif line_number > 0:\\n            indexed_lines = lines[line_number-1:]\\n        else:\\n            indexed_lines = lines[line_number:]\\n            \\n        for line in indexed_lines:\\n            content += f'{index}'.rjust(5) + ': '\\n            content += line\\n            read_count += len(line)\\n            index += 1\\n        return content\\n\\n    def write_to_file(self, filepath:str,content:str,truncating:bool = False,line_number:int = None, overwrite:bool = False)->str:\\n        \\\"\\\"\\\"Write or modify the textual file lines based on `content` provided. \\n        Return updated content of the file after modification so no further need to call `read_from_file` for this file. Create file if not exists.\\n        \\n        Example:\\n        ```\\n        In[0]: write_to_file('test.txt', 'Hello World!\\\\\\\\nA new line!')\\n        Out[0]: '1: Hello World!\\\\\\\\n2: A new line!'\\n        In[1]: write_to_file('test.txt', 'Hello World 1!', 2)\\n        Out[1]: '1: Hello World!\\\\\\\\n2: Hello World 1!\\\\\\\\n3: A new line!'\\n        In[2]: write_to_file('test.txt', 'Hello World 2!', 2, overwrite=True)\\n        Out[2]: '1: Hello World!\\\\\\\\n2: Hello World 2!\\\\\\\\n3: A new line!'\\n        ```\\n        \\n        :param string filepath: The path to the file to be modified, always use relative path to the workspace root.\\n        :param boolean? truncating: If `True`, the file will be truncated before writing, else will read current content before writing. Defaults to `False`.\\n        :param integer? line_number: The start line to modified file. Defaults to `None`, which means insert the new content at the end of the file. So do not provide this if you want to append the new content to the file.\\n        :param boolean? overwrite: If `True`, the new content will overwrite content started from `line_number` line. Defaults to `False`, which insert the new content at the `line_number` line.\\n        :param string content: The new content to be replaced with the old content.\\n        \\\"\\\"\\\"\\n        if not filepath.startswith(self.work_directory):\\n            filepath = filepath.strip('/')\\n            full_path = os.path.join(self.work_directory, filepath)\\n        else:\\n            full_path = filepath\\n        if not self._is_path_within_workspace(full_path) or  self._check_ignorement(full_path):\\n            raise ValueError(f\\\"File {filepath} is not within workspace.\\\")\\n        \\n        if not os.path.exists(full_path):\\n            if line_number is None or line_number==0 or line_number == 1:\\n                os.makedirs(os.path.split(full_path)[0],exist_ok=True)\\n                open(full_path, 'w+').close()\\n            else:\\n                raise FileNotFoundError(f\\\"File {filepath} not found in workspace.\\\")\\n        elif not os.path.isfile(full_path):\\n            raise ValueError(f\\\"File {filepath} is not a file.\\\")\\n            \\n        # protential overflow\\n        if truncating:\\n            lines = []\\n        else:\\n            with open(full_path, 'r') as f:\\n                lines = f.readlines()\\n        \\n        \\n        new_lines = content.splitlines(keepends=True)\\n        if line_number is None:\\n            lines.extend(new_lines)\\n        else:\\n            if line_number >= 1:\\n                line_number -= 1\\n            if overwrite:\\n                lines[line_number: line_number+len(new_lines)] = new_lines\\n            else:\\n                lines[line_number: line_number] = new_lines \\n\\n        for idx, _ in enumerate(lines):\\n            if not lines[idx].endswith('\\\\n'):\\n                lines[idx] += '\\\\n'\\n                \\n        with open(full_path, 'w+') as f:\\n            f.writelines(lines)\\n            \\n        return self.read_from_file(filepath)\\n\",\n            \"name_column\": 6\n        },\n        \"__init__\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"__init__\",\n            \"md_content\": \"\",\n            \"code_start_line\": 13,\n            \"code_end_line\": 21,\n            \"parent\": \"FileSystemEnv\",\n            \"have_return\": false,\n            \"code_content\": \"    def __init__(self, config: Dict[str, Any] = None):\\n        super().__init__(config)\\n        filesystem_config = self.config['filesystem']\\n        \\n        self.ignored_list = filesystem_config[\\\"ignored_list\\\"]\\n        self.work_directory = filesystem_config[\\\"work_directory\\\"]\\n        self.max_entry_nums_for_level = filesystem_config[\\\"max_entry_nums_for_level\\\"]\\n        if not os.path.exists(self.work_directory):\\n            os.mkdir(self.work_directory,mode=0o777)\\n\",\n            \"name_column\": 8\n        },\n        \"_check_ignorement\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"_check_ignorement\",\n            \"md_content\": \"\",\n            \"code_start_line\": 23,\n            \"code_end_line\": 27,\n            \"parent\": \"FileSystemEnv\",\n            \"have_return\": true,\n            \"code_content\": \"    def _check_ignorement(self,path:str)->bool:\\n        for pattern in self.ignored_list:\\n            if fnmatch.fnmatch(path,pattern):\\n                return True\\n        return False\\n\",\n            \"name_column\": 8\n        },\n        \"_is_path_within_workspace\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"_is_path_within_workspace\",\n            \"md_content\": \"\",\n            \"code_start_line\": 29,\n            \"code_end_line\": 32,\n            \"parent\": \"FileSystemEnv\",\n            \"have_return\": true,\n            \"code_content\": \"    def _is_path_within_workspace(self,path:str)->bool:\\n        common_prefix = os.path.commonprefix([os.path.realpath(path),\\n                                            os.path.realpath(self.work_directory)])\\n        return common_prefix == os.path.realpath(self.work_directory)\\n\",\n            \"name_column\": 8\n        },\n        \"_is_path_exist\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"_is_path_exist\",\n            \"md_content\": \"\",\n            \"code_start_line\": 34,\n            \"code_end_line\": 44,\n            \"parent\": \"FileSystemEnv\",\n            \"have_return\": true,\n            \"code_content\": \"    def _is_path_exist(self,path:str)->bool:\\n        \\\"\\\"\\\"Check if the path exists in the workspace.\\n        \\n        :param string path: The path to be checked.\\n        :return bool: `True` if the path exists, else `False`.\\n        \\\"\\\"\\\"\\n\\n        full_path = os.path.join(self.work_directory, path)\\n        if not self._is_path_within_workspace(full_path):\\n            raise ValueError(f\\\"Path {path} is not within workspace.\\\")\\n        return os.path.exists(full_path)\\n\",\n            \"name_column\": 8\n        },\n        \"print_filesys_struture\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"print_filesys_struture\",\n            \"md_content\": \"\",\n            \"code_start_line\": 46,\n            \"code_end_line\": 95,\n            \"parent\": \"FileSystemEnv\",\n            \"have_return\": true,\n            \"code_content\": \"    def print_filesys_struture(self,return_root=False)->str:\\n        \\\"\\\"\\\"Return a tree-like structure for all files and folders in the workspace. Use this tool if you are not sure what files are in the workspace.\\n\\n        This function recursively walks through all the directories in the workspace\\n        and return them in a tree-like structure, \\n        displaying all the files under each directory.\\n        \\n        Example:\\n        ```\\n        - root/\\n            - sub_directory1/\\n                - file1.txt\\n                - file2.txt\\n            - sub_directory2/\\n                - file3.txt\\n        ```\\n\\n        :return string: The tree-like structure of the workspace.\\n        \\\"\\\"\\\"\\n        full_repr = ''\\n        if return_root:\\n            full_repr += f'Global Root Work Directory: {self.work_directory}\\\\n'\\n\\n        folder_counts =  defaultdict(lambda: 0)\\n        for root, dirs, files in os.walk(self.work_directory):\\n            if self._check_ignorement(root):\\n                continue\\n            level = root.replace(self.work_directory, '').count(os.sep)\\n            indent = ' ' * 4 * (level)\\n            \\n            folder_counts[root] += 1\\n            if folder_counts[root] > self.max_entry_nums_for_level:\\n                full_repr += f'{indent}`wrapped`\\\\n'\\n            \\n            full_repr += f'{indent}- {os.path.basename(root)}/\\\\n'\\n            \\n            idx = 0\\n            subindent = ' ' * 4 * (level + 1) + '- '\\n            for f in files:\\n                if self._check_ignorement(f):\\n                    continue\\n                \\n                idx += 1\\n                if idx > self.max_entry_nums_for_level:\\n                    full_repr += f'{subindent}`wrapped`\\\\n'\\n                    break\\n                full_repr += f'{subindent}{f}\\\\n'\\n\\n\\n        return full_repr\\n\",\n            \"name_column\": 8\n        },\n        \"read_from_file\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"read_from_file\",\n            \"md_content\": \"\",\n            \"code_start_line\": 97,\n            \"code_end_line\": 141,\n            \"parent\": \"FileSystemEnv\",\n            \"have_return\": true,\n            \"code_content\": \"    def read_from_file(self,filepath:str,line_number:int = 1)->str:\\n        \\\"\\\"\\\"Open and read the textual file content in the workspace, you will see the content of the target file.\\n        Don't use this if the give `filepath` is writen or modified before, the content in `filepath` should be already returned.\\n        \\n        :param string filepath: The path to the file to be opened, always use relative path to the workspace root.\\n        :param integer? line_number: The starting line number of the content to be opened. Defaults to 1.\\n        :return string: The content of the file.\\n        \\\"\\\"\\\"\\n        if not filepath.startswith(self.work_directory):\\n            filepath = filepath.strip('/')\\n            full_path = os.path.join(self.work_directory, filepath)        \\n        else:\\n            full_path = filepath\\n                \\n        if self._check_ignorement(full_path) or not os.path.isfile(full_path):\\n            raise FileNotFoundError(f\\\"File {filepath} not found in workspace.\\\")\\n        if not self._is_path_within_workspace(full_path):\\n            raise ValueError(f\\\"File {filepath} is not within workspace.\\\")\\n        if not os.path.exists(full_path):\\n            raise FileNotFoundError(f\\\"File {filepath} not found in workspace.\\\")\\n\\n        content = ''\\n        with open(full_path, 'r') as f:\\n            lines = f.readlines(int(1e5))\\n            \\n        read_count = 0\\n        if not (abs(line_number) - 1 < len(lines)):\\n            raise ValueError(f\\\"Line number {line_number} is out of range.\\\")\\n        index = line_number if line_number >= 0 else len(lines) + line_number\\n        if index == 0:\\n            index = 1\\n            \\n        if line_number == 0:\\n            indexed_lines = lines\\n        elif line_number > 0:\\n            indexed_lines = lines[line_number-1:]\\n        else:\\n            indexed_lines = lines[line_number:]\\n            \\n        for line in indexed_lines:\\n            content += f'{index}'.rjust(5) + ': '\\n            content += line\\n            read_count += len(line)\\n            index += 1\\n        return content\\n\",\n            \"name_column\": 8\n        },\n        \"write_to_file\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"write_to_file\",\n            \"md_content\": \"\",\n            \"code_start_line\": 143,\n            \"code_end_line\": 206,\n            \"parent\": \"FileSystemEnv\",\n            \"have_return\": true,\n            \"code_content\": \"    def write_to_file(self, filepath:str,content:str,truncating:bool = False,line_number:int = None, overwrite:bool = False)->str:\\n        \\\"\\\"\\\"Write or modify the textual file lines based on `content` provided. \\n        Return updated content of the file after modification so no further need to call `read_from_file` for this file. Create file if not exists.\\n        \\n        Example:\\n        ```\\n        In[0]: write_to_file('test.txt', 'Hello World!\\\\\\\\nA new line!')\\n        Out[0]: '1: Hello World!\\\\\\\\n2: A new line!'\\n        In[1]: write_to_file('test.txt', 'Hello World 1!', 2)\\n        Out[1]: '1: Hello World!\\\\\\\\n2: Hello World 1!\\\\\\\\n3: A new line!'\\n        In[2]: write_to_file('test.txt', 'Hello World 2!', 2, overwrite=True)\\n        Out[2]: '1: Hello World!\\\\\\\\n2: Hello World 2!\\\\\\\\n3: A new line!'\\n        ```\\n        \\n        :param string filepath: The path to the file to be modified, always use relative path to the workspace root.\\n        :param boolean? truncating: If `True`, the file will be truncated before writing, else will read current content before writing. Defaults to `False`.\\n        :param integer? line_number: The start line to modified file. Defaults to `None`, which means insert the new content at the end of the file. So do not provide this if you want to append the new content to the file.\\n        :param boolean? overwrite: If `True`, the new content will overwrite content started from `line_number` line. Defaults to `False`, which insert the new content at the `line_number` line.\\n        :param string content: The new content to be replaced with the old content.\\n        \\\"\\\"\\\"\\n        if not filepath.startswith(self.work_directory):\\n            filepath = filepath.strip('/')\\n            full_path = os.path.join(self.work_directory, filepath)\\n        else:\\n            full_path = filepath\\n        if not self._is_path_within_workspace(full_path) or  self._check_ignorement(full_path):\\n            raise ValueError(f\\\"File {filepath} is not within workspace.\\\")\\n        \\n        if not os.path.exists(full_path):\\n            if line_number is None or line_number==0 or line_number == 1:\\n                os.makedirs(os.path.split(full_path)[0],exist_ok=True)\\n                open(full_path, 'w+').close()\\n            else:\\n                raise FileNotFoundError(f\\\"File {filepath} not found in workspace.\\\")\\n        elif not os.path.isfile(full_path):\\n            raise ValueError(f\\\"File {filepath} is not a file.\\\")\\n            \\n        # protential overflow\\n        if truncating:\\n            lines = []\\n        else:\\n            with open(full_path, 'r') as f:\\n                lines = f.readlines()\\n        \\n        \\n        new_lines = content.splitlines(keepends=True)\\n        if line_number is None:\\n            lines.extend(new_lines)\\n        else:\\n            if line_number >= 1:\\n                line_number -= 1\\n            if overwrite:\\n                lines[line_number: line_number+len(new_lines)] = new_lines\\n            else:\\n                lines[line_number: line_number] = new_lines \\n\\n        for idx, _ in enumerate(lines):\\n            if not lines[idx].endswith('\\\\n'):\\n                lines[idx] += '\\\\n'\\n                \\n        with open(full_path, 'w+') as f:\\n            f.writelines(lines)\\n            \\n        return self.read_from_file(filepath)\\n\",\n            \"name_column\": 8\n        }\n    },\n    \"ToolServer/ToolServerNode/core/envs/__init__.py\": {},\n    \"ToolServer/ToolServerNode/core/envs/pycoding.py\": {\n        \"PythonNotebook\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"PythonNotebook\",\n            \"md_content\": \"\",\n            \"code_start_line\": 16,\n            \"code_end_line\": 178,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"class PythonNotebook(BaseEnv):\\n    \\\"\\\"\\\"Python Notebook Environment. Provide a notebook interface to run python code.\\\"\\\"\\\"\\n    def __init__(self, config: Dict[str, Any] = None):\\n        super().__init__(config)\\n        filesystem_config = self.config['filesystem']\\n        \\n        self.work_directory = filesystem_config[\\\"work_directory\\\"]\\n        \\n        self.nb_cfg = self.config['notebook']\\n        \\n        if not os.path.exists(self.work_directory):\\n            os.mkdir(self.work_directory,mode=0o777)\\n\\n        # make a new notebook\\n        self.nb = nbformat.v4.new_notebook(\\n            metadata = {'kernelspec': {'name': 'python', 'language': 'python', 'display_name': 'python'}})\\n        self.nbc = NotebookClient(self.nb,timeout=self.nb_cfg['timeout'])\\n    \\n    async def _running(self):\\n        if self.nbc.kc is not None:\\n            return await ensure_async(self.nbc.kc.is_alive())\\n        return False\\n    \\n    async def _reset(self):\\n        if await self._running():\\n            await self.nbc._async_cleanup_kernel()\\n        self.nbc.create_kernel_manager()\\n        await self.nbc.async_start_new_kernel(cwd=self.work_directory)\\n        await self.nbc.async_start_new_kernel_client()\\n\\n    @staticmethod\\n    def _fix_escape(problematic_code: str) -> str:\\n        for str_sign in ['\\\"', \\\"'\\\", '\\\"\\\"\\\"', \\\"'''\\\"]:\\n\\n            pattern = rf'{str_sign}(.*?){str_sign}'\\n            in_line_strs = re.findall(pattern, problematic_code, re.DOTALL)\\n            replaced_in_line_strs = []\\n            for in_line_str in in_line_strs:\\n                replaced_in_line_strs.append(in_line_str.replace('\\\\n', '\\\\\\\\n').replace('\\\\r', '\\\\\\\\r').replace('\\\\t', '\\\\\\\\t'))\\n            for original_str, modified_str in zip(in_line_strs, replaced_in_line_strs):\\n                fixed_code = problematic_code.replace(f'{str_sign}' + original_str + f'{str_sign}',\\n                                                            f'{str_sign}' + modified_str + f'{str_sign}')\\n\\n        return fixed_code\\n\\n        \\n    async def execute_cell(self,code:str,cell_index:int=None,reset:bool=False) -> str:\\n        \\\"\\\"\\\"Create or replace a notebook cell and execute it, return the output.\\n        Use this tool to test your idea quickly. Carefully examine the output to make sure it is what you want.\\n        \\n        Example:\\n        ```\\n        In[0]: code='print(\\\"hello world\\\")' # This will create a new cell and execute it.\\n        Out[0]: ['cell_index: 0', 'hello world']\\n        In[1]: code='print(\\\"hello world\\\")',cell_index=0 # This will overwrite the first cell and execute it.\\n        In[2]: code='print(\\\"hello world\\\")',cell_index=-1 # This will overwrite the last cell and execute it.\\n        ```\\n        \\n        :param string code: python code to be executed, make sure it is valid python code with right format. don't provide shell command that started with '!' here.\\n        :param integer? cell_index: the index of the cell to be insert and overwrite `code`, default to `None`, which means append new cell.\\n        :param boolean? reset: whether to reset the kernel before executing the code. Default to `False`.\\n        :return string: execution result.\\n        \\\"\\\"\\\"\\n        # code = self._fix_escape(code)\\n        if reset or not await self._running():\\n            await self._reset()\\n        if cell_index is None or cell_index == len(self.nb.cells) or len(self.nb.cells) == 0:\\n            self.nb.cells.append(nbformat.v4.new_code_cell(code))\\n            cell_index = len(self.nb.cells)-1\\n        else:\\n            self.nb.cells[cell_index] = nbformat.v4.new_code_cell(code)\\n        \\n        try:\\n            await self.nbc.async_execute_cell(self.nb.cells[-1],len(self.nb.cells)-1)\\n        except CellExecutionError as e:\\n            pass\\n        except DeadKernelError as e:\\n            await self._reset()\\n            \\n        nbformat.write(self.nb,os.path.join(self.work_directory,self.nb_cfg['save_name']))\\n        \\n        return self._format_outputs(self.nb.cells[cell_index].outputs,cell_index,reraise=True,return_binary=True)\\n        \\n    def print_notebook(self)->str:\\n        \\\"\\\"\\\"print all notebook cells' content and output.\\n        \\n        :return string: all notebook cells description.\\n        \\\"\\\"\\\"\\n        ret = ''\\n        for i,cell in enumerate(self.nb.cells):\\n            ret += f'= Cell {i} =\\\\n'\\n            if cell['cell_type'] == 'code':\\n                ret += f'{cell[\\\"source\\\"]}\\\\n'\\n                if len(cell['outputs']) != 0:\\n                    ret += f'= Output {i} =\\\\n'\\n                    ret += f'{self._format_outputs(cell[\\\"outputs\\\"])}\\\\n'\\n        return ret\\n    def _format_outputs(self,outputs,cell_index=None,reraise=False,return_binary=False):\\n        ret = None\\n        if len(outputs) == 0:\\n            ret = '' if cell_index is None else f'cell_index: {cell_index}'\\n        elif len(outputs) == 1:\\n            if cell_index is not None:\\n                ret = {\\n                    'type':'composite',\\n                    'data':[\\n                        f'cell_index: {cell_index}',\\n                        self._format_output(outputs[0],cell_index,reraise,return_binary)\\n                    ]\\n                }\\n            else:\\n                ret = self._format_output(outputs[0],cell_index,reraise,return_binary)\\n        else:\\n            ret = {\\n                'type':'composite',\\n                'data':[\\n                    self._format_output(output,cell_index,reraise,return_binary) for output in outputs\\n                ]\\n            }\\n            if cell_index is not None:\\n                ret['data'].insert(0,f'cell_index: {cell_index}')\\n        return ret\\n        \\n    def _format_output(self,output,cell_index=None,reraise=False,return_binary=False):\\n        def format_single_data(data,data_type:str):\\n            if data_type.startswith('image/'):\\n                return {\\n                    'type': 'binary',\\n                    'media_type':data_type,\\n                    'data': data if return_binary else '`Wrapped`'\\n                }\\n            elif data_type.startswith('text/'):\\n                return ''.join(data)\\n            elif data_type.startswith('application/'):\\n                return data\\n            return data\\n            \\n        ret = None\\n        match output['output_type']:\\n            case 'execute_result' | 'display_data':\\n                keys = list(output['data'].keys())\\n                if 'text/html' in keys and 'text/plain' in keys:\\n                    keys.remove('text/html') # remove html\\n                if len(keys) == 1:\\n                    ret = format_single_data(output['data'][keys[0]],keys[0])\\n                elif len(keys) > 1:\\n                    ret = {\\n                        'type': 'composite',\\n                        'data':[]\\n                    }\\n                    for k in keys:\\n                        ret['data'].append(format_single_data(output['data'][k],k))\\n                    \\n            case 'error':\\n                if reraise:\\n                    raise ToolExecutionError(f'cell_index: {cell_index}\\\\n'+'\\\\n'.join(output['traceback']))\\n                else:\\n                    return '\\\\n'.join(output['traceback'])\\n            case 'stream':\\n                ret = output['text']\\n            case _:\\n                ret = output\\n        return ret\\n\",\n            \"name_column\": 6\n        },\n        \"__init__\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"__init__\",\n            \"md_content\": \"\",\n            \"code_start_line\": 18,\n            \"code_end_line\": 32,\n            \"parent\": \"PythonNotebook\",\n            \"have_return\": false,\n            \"code_content\": \"    def __init__(self, config: Dict[str, Any] = None):\\n        super().__init__(config)\\n        filesystem_config = self.config['filesystem']\\n        \\n        self.work_directory = filesystem_config[\\\"work_directory\\\"]\\n        \\n        self.nb_cfg = self.config['notebook']\\n        \\n        if not os.path.exists(self.work_directory):\\n            os.mkdir(self.work_directory,mode=0o777)\\n\\n        # make a new notebook\\n        self.nb = nbformat.v4.new_notebook(\\n            metadata = {'kernelspec': {'name': 'python', 'language': 'python', 'display_name': 'python'}})\\n        self.nbc = NotebookClient(self.nb,timeout=self.nb_cfg['timeout'])\\n\",\n            \"name_column\": 8\n        },\n        \"_running\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"_running\",\n            \"md_content\": \"\",\n            \"code_start_line\": 34,\n            \"code_end_line\": 37,\n            \"parent\": \"PythonNotebook\",\n            \"have_return\": true,\n            \"code_content\": \"    async def _running(self):\\n        if self.nbc.kc is not None:\\n            return await ensure_async(self.nbc.kc.is_alive())\\n        return False\\n\",\n            \"name_column\": 14\n        },\n        \"_reset\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"_reset\",\n            \"md_content\": \"\",\n            \"code_start_line\": 39,\n            \"code_end_line\": 44,\n            \"parent\": \"PythonNotebook\",\n            \"have_return\": false,\n            \"code_content\": \"    async def _reset(self):\\n        if await self._running():\\n            await self.nbc._async_cleanup_kernel()\\n        self.nbc.create_kernel_manager()\\n        await self.nbc.async_start_new_kernel(cwd=self.work_directory)\\n        await self.nbc.async_start_new_kernel_client()\\n\",\n            \"name_column\": 14\n        },\n        \"_fix_escape\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"_fix_escape\",\n            \"md_content\": \"\",\n            \"code_start_line\": 47,\n            \"code_end_line\": 59,\n            \"parent\": \"PythonNotebook\",\n            \"have_return\": true,\n            \"code_content\": \"    def _fix_escape(problematic_code: str) -> str:\\n        for str_sign in ['\\\"', \\\"'\\\", '\\\"\\\"\\\"', \\\"'''\\\"]:\\n\\n            pattern = rf'{str_sign}(.*?){str_sign}'\\n            in_line_strs = re.findall(pattern, problematic_code, re.DOTALL)\\n            replaced_in_line_strs = []\\n            for in_line_str in in_line_strs:\\n                replaced_in_line_strs.append(in_line_str.replace('\\\\n', '\\\\\\\\n').replace('\\\\r', '\\\\\\\\r').replace('\\\\t', '\\\\\\\\t'))\\n            for original_str, modified_str in zip(in_line_strs, replaced_in_line_strs):\\n                fixed_code = problematic_code.replace(f'{str_sign}' + original_str + f'{str_sign}',\\n                                                            f'{str_sign}' + modified_str + f'{str_sign}')\\n\\n        return fixed_code\\n\",\n            \"name_column\": 8\n        },\n        \"execute_cell\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"execute_cell\",\n            \"md_content\": \"\",\n            \"code_start_line\": 62,\n            \"code_end_line\": 97,\n            \"parent\": \"PythonNotebook\",\n            \"have_return\": true,\n            \"code_content\": \"    async def execute_cell(self,code:str,cell_index:int=None,reset:bool=False) -> str:\\n        \\\"\\\"\\\"Create or replace a notebook cell and execute it, return the output.\\n        Use this tool to test your idea quickly. Carefully examine the output to make sure it is what you want.\\n        \\n        Example:\\n        ```\\n        In[0]: code='print(\\\"hello world\\\")' # This will create a new cell and execute it.\\n        Out[0]: ['cell_index: 0', 'hello world']\\n        In[1]: code='print(\\\"hello world\\\")',cell_index=0 # This will overwrite the first cell and execute it.\\n        In[2]: code='print(\\\"hello world\\\")',cell_index=-1 # This will overwrite the last cell and execute it.\\n        ```\\n        \\n        :param string code: python code to be executed, make sure it is valid python code with right format. don't provide shell command that started with '!' here.\\n        :param integer? cell_index: the index of the cell to be insert and overwrite `code`, default to `None`, which means append new cell.\\n        :param boolean? reset: whether to reset the kernel before executing the code. Default to `False`.\\n        :return string: execution result.\\n        \\\"\\\"\\\"\\n        # code = self._fix_escape(code)\\n        if reset or not await self._running():\\n            await self._reset()\\n        if cell_index is None or cell_index == len(self.nb.cells) or len(self.nb.cells) == 0:\\n            self.nb.cells.append(nbformat.v4.new_code_cell(code))\\n            cell_index = len(self.nb.cells)-1\\n        else:\\n            self.nb.cells[cell_index] = nbformat.v4.new_code_cell(code)\\n        \\n        try:\\n            await self.nbc.async_execute_cell(self.nb.cells[-1],len(self.nb.cells)-1)\\n        except CellExecutionError as e:\\n            pass\\n        except DeadKernelError as e:\\n            await self._reset()\\n            \\n        nbformat.write(self.nb,os.path.join(self.work_directory,self.nb_cfg['save_name']))\\n        \\n        return self._format_outputs(self.nb.cells[cell_index].outputs,cell_index,reraise=True,return_binary=True)\\n\",\n            \"name_column\": 14\n        },\n        \"print_notebook\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"print_notebook\",\n            \"md_content\": \"\",\n            \"code_start_line\": 99,\n            \"code_end_line\": 112,\n            \"parent\": \"PythonNotebook\",\n            \"have_return\": true,\n            \"code_content\": \"    def print_notebook(self)->str:\\n        \\\"\\\"\\\"print all notebook cells' content and output.\\n        \\n        :return string: all notebook cells description.\\n        \\\"\\\"\\\"\\n        ret = ''\\n        for i,cell in enumerate(self.nb.cells):\\n            ret += f'= Cell {i} =\\\\n'\\n            if cell['cell_type'] == 'code':\\n                ret += f'{cell[\\\"source\\\"]}\\\\n'\\n                if len(cell['outputs']) != 0:\\n                    ret += f'= Output {i} =\\\\n'\\n                    ret += f'{self._format_outputs(cell[\\\"outputs\\\"])}\\\\n'\\n        return ret\\n\",\n            \"name_column\": 8\n        },\n        \"_format_outputs\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"_format_outputs\",\n            \"md_content\": \"\",\n            \"code_start_line\": 113,\n            \"code_end_line\": 137,\n            \"parent\": \"PythonNotebook\",\n            \"have_return\": true,\n            \"code_content\": \"    def _format_outputs(self,outputs,cell_index=None,reraise=False,return_binary=False):\\n        ret = None\\n        if len(outputs) == 0:\\n            ret = '' if cell_index is None else f'cell_index: {cell_index}'\\n        elif len(outputs) == 1:\\n            if cell_index is not None:\\n                ret = {\\n                    'type':'composite',\\n                    'data':[\\n                        f'cell_index: {cell_index}',\\n                        self._format_output(outputs[0],cell_index,reraise,return_binary)\\n                    ]\\n                }\\n            else:\\n                ret = self._format_output(outputs[0],cell_index,reraise,return_binary)\\n        else:\\n            ret = {\\n                'type':'composite',\\n                'data':[\\n                    self._format_output(output,cell_index,reraise,return_binary) for output in outputs\\n                ]\\n            }\\n            if cell_index is not None:\\n                ret['data'].insert(0,f'cell_index: {cell_index}')\\n        return ret\\n\",\n            \"name_column\": 8\n        },\n        \"_format_output\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"_format_output\",\n            \"md_content\": \"\",\n            \"code_start_line\": 139,\n            \"code_end_line\": 178,\n            \"parent\": \"PythonNotebook\",\n            \"have_return\": true,\n            \"code_content\": \"    def _format_output(self,output,cell_index=None,reraise=False,return_binary=False):\\n        def format_single_data(data,data_type:str):\\n            if data_type.startswith('image/'):\\n                return {\\n                    'type': 'binary',\\n                    'media_type':data_type,\\n                    'data': data if return_binary else '`Wrapped`'\\n                }\\n            elif data_type.startswith('text/'):\\n                return ''.join(data)\\n            elif data_type.startswith('application/'):\\n                return data\\n            return data\\n            \\n        ret = None\\n        match output['output_type']:\\n            case 'execute_result' | 'display_data':\\n                keys = list(output['data'].keys())\\n                if 'text/html' in keys and 'text/plain' in keys:\\n                    keys.remove('text/html') # remove html\\n                if len(keys) == 1:\\n                    ret = format_single_data(output['data'][keys[0]],keys[0])\\n                elif len(keys) > 1:\\n                    ret = {\\n                        'type': 'composite',\\n                        'data':[]\\n                    }\\n                    for k in keys:\\n                        ret['data'].append(format_single_data(output['data'][k],k))\\n                    \\n            case 'error':\\n                if reraise:\\n                    raise ToolExecutionError(f'cell_index: {cell_index}\\\\n'+'\\\\n'.join(output['traceback']))\\n                else:\\n                    return '\\\\n'.join(output['traceback'])\\n            case 'stream':\\n                ret = output['text']\\n            case _:\\n                ret = output\\n        return ret\\n\",\n            \"name_column\": 8\n        },\n        \"format_single_data\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"format_single_data\",\n            \"md_content\": \"\",\n            \"code_start_line\": 140,\n            \"code_end_line\": 151,\n            \"parent\": \"_format_output\",\n            \"have_return\": true,\n            \"code_content\": \"        def format_single_data(data,data_type:str):\\n            if data_type.startswith('image/'):\\n                return {\\n                    'type': 'binary',\\n                    'media_type':data_type,\\n                    'data': data if return_binary else '`Wrapped`'\\n                }\\n            elif data_type.startswith('text/'):\\n                return ''.join(data)\\n            elif data_type.startswith('application/'):\\n                return data\\n            return data\\n\",\n            \"name_column\": 12\n        }\n    },\n    \"ToolServer/ToolServerNode/utils/retriever.py\": {\n        \"standardizing\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"standardizing\",\n            \"md_content\": \"\",\n            \"code_start_line\": 16,\n            \"code_end_line\": 30,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"def standardizing(string: str) -> str:\\n    \\\"\\\"\\\"\\n    Return a standardized string by replacing non-alphanumeric characters with underscores,\\n    reducing multiple underscores to one, and converting all characters to lowercase.\\n\\n    Args:\\n        string: The input string to be standardized.\\n\\n    Returns: \\n        A standardized version of the input string.\\n    \\\"\\\"\\\"\\n    string = STANDARDIZING_PATTERN.sub(\\\"_\\\", string)\\n    string = re.sub(r\\\"(_)\\\\1+\\\",\\\"_\\\", string)\\n    string = string.strip(\\\"_\\\").lower()\\n    return string\\n\",\n            \"name_column\": 4\n        },\n        \"ada_retriever\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"ada_retriever\",\n            \"md_content\": \"\",\n            \"code_start_line\": 32,\n            \"code_end_line\": 59,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"def ada_retriever(doc_embeddings: list, id2tool:dict, question: str, top_k: int=5) -> list:\\n    \\\"\\\"\\\"\\n    Retrieve tools related to the provided question.\\n\\n    Args:\\n        doc_embeddings: The list of document embeddings.\\n        id2tool: A dictionary mapping tool id to tool name.\\n        question: The question for the ADA retriever.\\n        top_k: The number of top tools to return (default is 5).\\n\\n    Returns:\\n        A list of retrieved tools.\\n    \\\"\\\"\\\"\\n    cfg = CONFIG['retriver']\\n    url = cfg['endpoint']\\n    headers = cfg['headers']\\n    payload = {'input':question}\\n    payload.update(cfg['payload'])\\n    \\n    response = requests.post(url, json=payload, headers=headers)\\n    query_embedding = np.array(response.json()['data'][0]['embedding'])\\n\\n    similarities = cosine_similarity([query_embedding], doc_embeddings)\\n\\n    sorted_doc_indices = sorted(range(len(similarities[0])), key=lambda i: similarities[0][i], reverse=True)\\n    retrieved_tools = list(map(lambda doc_id: id2tool[str(doc_id)],sorted_doc_indices[:top_k]))\\n    \\n    return retrieved_tools\\n\",\n            \"name_column\": 4\n        },\n        \"build_tool_embeddings\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"build_tool_embeddings\",\n            \"md_content\": \"\",\n            \"code_start_line\": 61,\n            \"code_end_line\": 147,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"def build_tool_embeddings(tools_json: list[dict]) -> tuple:\\n    \\\"\\\"\\\"\\n    Build tool embeddings.\\n\\n    Args:\\n        tools_json: The list of dictionaries containing tool data.\\n\\n    Returns:\\n        A tuple containing a list of document embeddings and a dictionary\\n        mapping tool id to tool name.\\n    \\\"\\\"\\\"\\n    cfg = CONFIG['retriver']\\n    if os.path.exists(cfg['id2tool_file']) and os.path.exists(cfg['embedding_file']):\\n        id2tool = json.load(open(cfg['id2tool_file'], \\\"r\\\"))\\n        doc_embedings = np.load(cfg['embedding_file'])\\n        if len(id2tool) != len(doc_embedings):\\n            logger.error('Embedding file and id2tool file do not match! Rebuild embeddings!')\\n            id2tool = {}\\n            doc_embedings = []\\n    else:\\n        id2tool = {}\\n        doc_embedings = []\\n\\n    # check embedding file whether need to be updated\\n    # get all current tool names\\n    # tool_names = set(map(lambda tool_json: tool_json['name'], tools_json))\\n    # cached_tool_names = set(id2tool.values())\\n    # if tool_names == cached_tool_names:\\n    #     logger.info('No tools change, use cached embeddings!')\\n    #     return doc_embedings, id2tool\\n    return doc_embedings, id2tool\\n    \\n    # update embeddings\\n    logger.info('Tools change detected, updating embeddings...')\\n    url = cfg['endpoint']\\n    headers = cfg['headers']\\n    \\n    new_id2tool = { str(i):tool_json['name'] for i,tool_json in enumerate(tools_json) }\\n    json.dump(new_id2tool, open(cfg['id2tool_file'], \\\"w\\\"), indent=4)\\n\\n    def get_embedding(tool_json:dict) -> list:\\n        \\\"\\\"\\\"\\n        Get embedding for a certain tool.\\n\\n        Args:\\n            tool_json: The dictionary containing tool data.\\n\\n        Returns:\\n            A list of tool embeddings.\\n        \\\"\\\"\\\"\\n        payload = {'input':json.dumps(tool_json)}\\n        payload.update(cfg['payload'])\\n        try:\\n            response = requests.post(url, json=payload, headers=headers)\\n            response.raise_for_status()\\n        except Exception as e:\\n            logger.error(f'Failed to get embedding for tool {tool_json[\\\"name\\\"]}! Error: {e}')\\n            return [-1.000001] * cfg['embedding_dim']\\n        return response.json()['data'][0]['embedding']\\n    \\n    uncached_tools = list(filter(lambda tool_json: tool_json['name'] not in cached_tool_names, tools_json))\\n    uncached_tools_name = list(map(lambda tool_json: tool_json['name'],uncached_tools))\\n    uncached_doc_embedings = []\\n    with ThreadPoolExecutor(16) as pool:\\n        futures = [pool.submit(get_embedding, tool_json) for tool_json in uncached_tools]\\n        \\n        for future in tqdm.tqdm(futures,ncols=100):\\n            uncached_doc_embedings.append(future.result())\\n    \\n    new_doc_embedings = []\\n    for tool_json in tools_json:\\n        if tool_json['name'] not in cached_tool_names:\\n            new_doc_embedings.append(\\n                uncached_doc_embedings[\\n                    uncached_tools_name.index(tool_json['name'])\\n                    ])\\n        else:\\n            for doc_id in id2tool.keys():\\n                if id2tool[doc_id] == tool_json['name']:\\n                    new_doc_embedings.append(doc_embedings[int(doc_id)])\\n                    break\\n\\n    new_doc_embedings = np.array(new_doc_embedings)\\n    np.save(cfg['embedding_file'], new_doc_embedings)\\n\\n    logger.info('Embeddings updated! New embeddings saved!')\\n    return doc_embedings, new_id2tool\",\n            \"name_column\": 4\n        },\n        \"get_embedding\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"get_embedding\",\n            \"md_content\": \"\",\n            \"code_start_line\": 101,\n            \"code_end_line\": 119,\n            \"parent\": \"build_tool_embeddings\",\n            \"have_return\": true,\n            \"code_content\": \"    def get_embedding(tool_json:dict) -> list:\\n        \\\"\\\"\\\"\\n        Get embedding for a certain tool.\\n\\n        Args:\\n            tool_json: The dictionary containing tool data.\\n\\n        Returns:\\n            A list of tool embeddings.\\n        \\\"\\\"\\\"\\n        payload = {'input':json.dumps(tool_json)}\\n        payload.update(cfg['payload'])\\n        try:\\n            response = requests.post(url, json=payload, headers=headers)\\n            response.raise_for_status()\\n        except Exception as e:\\n            logger.error(f'Failed to get embedding for tool {tool_json[\\\"name\\\"]}! Error: {e}')\\n            return [-1.000001] * cfg['embedding_dim']\\n        return response.json()['data'][0]['embedding']\\n\",\n            \"name_column\": 8\n        }\n    },\n    \"ToolServer/ToolServerNode/utils/__init__.py\": {},\n    \"ToolServer/ToolServerNode/utils/response.py\": {\n        \"is_base64\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"is_base64\",\n            \"md_content\": \"\",\n            \"code_start_line\": 6,\n            \"code_end_line\": 20,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"def is_base64(s:str) -> bool:\\n    \\\"\\\"\\\"\\n    Check if the given string is a base64 sting or not.\\n\\n    Args:\\n        s (str): the string to be checked.\\n\\n    Returns:\\n        bool: Returns True if the given string is a base64 string, False otherwise.\\n    \\\"\\\"\\\"\\n    try:\\n        base64.b64decode(s)\\n        return True\\n    except:\\n        return False\\n\",\n            \"name_column\": 4\n        },\n        \"is_wrapped_response\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"is_wrapped_response\",\n            \"md_content\": \"\",\n            \"code_start_line\": 22,\n            \"code_end_line\": 36,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"def is_wrapped_response(obj:dict) -> bool:\\n    \\\"\\\"\\\"\\n    Check if the dictionary object is a wrapped response.\\n    A dictionary is considered as wrapped response if it has 'type' and 'data' keys,\\n    and value of 'type' key is one of ['simple','composite','binary'].\\n\\n    Args:\\n        obj (dict): the dictionary object to be checked.\\n\\n    Returns:\\n        bool: Returns True if the dictionary is a wrapped response, False otherwise.\\n    \\\"\\\"\\\"\\n    if 'type' in obj and obj['type'] in ['simple','composite','binary'] and 'data' in obj:\\n        return True\\n    return False\\n\",\n            \"name_column\": 4\n        },\n        \"wrap_tool_response\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"wrap_tool_response\",\n            \"md_content\": \"\",\n            \"code_start_line\": 38,\n            \"code_end_line\": 128,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"def wrap_tool_response(obj:Any) -> dict|list|str|int|float|bool:\\n    \\\"\\\"\\\"\\n    Wrap the tool response in a standardized object structure (depending on its type) to allow decoding.\\n    \\n    Format\\n    ======\\n    ```\\n    {\\n        'type': 'simple',       # for single return value like python basic types\\n        'data': obj\\n    },\\n    {\\n        'type': 'binary',       # for single return value like python basic types\\n        'media_type':'image/png',   # or other media types\\n        'name': 'xxx',             # file name of the binary data\\n        'data': obj             # base64 encoded binary data\\n    },\\n    str,int,float,bool,list is directly returned\\n    or\\n    {\\n        'type': 'composite',    # for multiple return values\\n        'data': [\\n            {\\n                'type': 'simple',\\n                'data': obj1\\n            },\\n            {\\n                'type': 'simple',\\n                'data': obj2\\n            }\\n        ]\\n    }\\n    ```\\n    Standardized Structures:\\n    - For simple data types (str, int, float, bool), the object is directly returned.\\n    - For composite types (tuples), data is wrapped in an object with a composite type.\\n    - For binary data, data is base64 encoded and wrapped in an object with a binary type.\\n     \\n\\n    Args:\\n        obj (Any): any Python object that needs to be wrapped.\\n\\n    Returns:\\n        Union[dict, list, str, int, float, bool]: the wrapped response.\\n        \\n    Raises:\\n        logger.warning: raises warning if the type of 'obj' is unknown.\\n    \\\"\\\"\\\"\\n    if isinstance(obj,tuple):\\n        if len(obj) == 0:\\n            ret = {\\n                'type': 'simple',\\n                'data': None\\n            }\\n        elif len(obj) == 1:\\n            ret = {\\n                'type': 'simple',\\n                'data': obj[0]\\n            }\\n        else:\\n            ret = {\\n                'type': 'composite',\\n                'data': []\\n            }\\n            for o in obj:\\n                ret['data'].append(wrap_tool_response(o))\\n    elif isinstance(obj,bytes):\\n        ret = {\\n            'type': 'binary',\\n            'media_type': 'bytes',\\n            'name': None,\\n            'data': base64.b64encode(obj).decode()\\n        }\\n    elif isinstance(obj,(str,int,float,bool,list)) or obj is None:\\n        ret = obj\\n    elif isinstance(obj,dict):\\n        # check if already wrapped\\n        if is_wrapped_response(obj):\\n            ret = obj\\n        else:\\n            ret = {\\n                'type': 'simple',\\n                'data': obj\\n            }\\n    else:\\n        logger.warning(f'Unknown type {type(obj)} in wrap_tool_response')\\n        ret = {\\n            'type': 'simple',\\n            'data': obj\\n        }\\n    return ret\",\n            \"name_column\": 4\n        }\n    },\n    \"ToolServer/ToolServerNode/utils/import_helper.py\": {\n        \"import_all_modules_in_folder\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"import_all_modules_in_folder\",\n            \"md_content\": \"\",\n            \"code_start_line\": 3,\n            \"code_end_line\": 20,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"def import_all_modules_in_folder(file,name):\\n    current_dir = os.path.dirname(file)\\n    all_modules = []\\n    for item in os.listdir(current_dir):\\n        item_path = os.path.join(current_dir, item)\\n        if os.path.isfile(item_path) and item != '__init__.py' and item.endswith('.py'):\\n            module_name = item[:-3]\\n        elif os.path.isdir(item_path) and item != '__pycache__' and os.path.exists(os.path.join(item_path, '__init__.py')) and os.path.isfile(os.path.join(item_path, '__init__.py')):\\n            module_name = item\\n        else:\\n            continue\\n\\n        full_module_path = f\\\"{name}.{module_name}\\\"\\n        # print(module_name,full_module_path)\\n        imported_module = importlib.import_module(full_module_path)\\n        globals()[module_name] = imported_module\\n        all_modules.append(imported_module)\\n    return all_modules\",\n            \"name_column\": 4\n        }\n    },\n    \"ToolServer/ToolServerNode/utils/openai.py\": {\n        \"OpenaiPoolRequest\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"OpenaiPoolRequest\",\n            \"md_content\": \"\",\n            \"code_start_line\": 14,\n            \"code_end_line\": 93,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"class OpenaiPoolRequest:\\n    \\\"\\\"\\\"\\n    Handles all OpenAI requests by dispatching them to the API endpoints.\\n\\n    Attributes:\\n        openai_cfg: Configuration dictionary containing OpenAI parameters.\\n        pool: list of dictionaries, where each dictionary has all the required details of an endpoint.\\n    \\\"\\\"\\\"\\n    def __init__(self,):\\n        \\\"\\\"\\\"\\n        Initializes the OpenaiPoolRequest class by setting the configuration and loading the pool.\\n        \\\"\\\"\\\"\\n        self.openai_cfg = deepcopy(CONFIG['openai'])\\n        \\n        self.pool:List[Dict] = []\\n        \\n        __pool_file = self.openai_cfg['key_pool_json']\\n        if os.environ.get('API_POOL_FILE',None) is not None:\\n            __pool_file = os.environ.get('API_POOL_FILE')\\n        \\n        if os.path.exists(__pool_file):\\n            self.pool = json.load(open(__pool_file))\\n        \\n        if os.environ.get('OPENAI_KEY',None) is not None:\\n            self.pool.append({\\n                'api_key':os.environ.get('OPENAI_KEY'),\\n                'organization':os.environ.get('OPENAI_ORG',None),\\n                'api_type':os.environ.get('OPENAI_TYPE',None),\\n                'api_version':os.environ.get('OPENAI_VER',None)\\n            })\\n        if len(self.pool) == 0:\\n            logger.warning('No openai api key found! Some functions will be disable!')\\n\\n    @retry(wait=wait_random_exponential(multiplier=1, max=10), stop=stop_after_attempt(5),reraise=True)\\n    async def request(self,messages,**kwargs) -> Dict[str, Any]:\\n        \\\"\\\"\\\"\\n        Sends a request to the OpenAI and gets a response.\\n\\n        Args:\\n            messages: Payload to be sent to OpenAI.\\n            kwargs: Optional arguments that the function takes.\\n\\n        Returns:\\n            A dictionary containing the response from the OpenAI.\\n\\n        Raises:\\n            Exception: If the attempt to reach the endpoint exceed limit.\\n        \\\"\\\"\\\"\\n        \\n        chat_args:dict = deepcopy(self.openai_cfg['chat_args'])\\n        chat_args.update(kwargs)\\n\\n        item = random.choice(self.pool)\\n        chat_args['api_key'] = item['api_key']\\n        if 'organization' in item:\\n            chat_args['organization'] = item['organization']\\n        if 'api_type' in item:\\n            chat_args['api_type'] = item['api_type']\\n        if 'api_version' in item:\\n            chat_args['api_version'] = item['api_version']\\n\\n        return await openai.ChatCompletion.acreate(messages=messages,**chat_args)\\n    \\n    async def __call__(self,messages,**kwargs) -> Dict[str, Any]:\\n        \\\"\\\"\\\"\\n        Makes a request to the OpenAI by calling the instance of the class.\\n\\n        Args:\\n            messages: Payload to be sent to OpenAI.\\n            kwargs: Optional arguments that the function takes.\\n\\n        Returns:\\n            A dictionary containing the response from the OpenAI.\\n\\n        Raises:\\n            Exception: If there are no API keys available in the pool.\\n        \\\"\\\"\\\"\\n        if len(self.pool)==0:\\n            raise Exception('No openai api key found! OPENAI_PR Disabled!')\\n        return await self.request(messages,**kwargs)\\n\",\n            \"name_column\": 6\n        },\n        \"__init__\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"__init__\",\n            \"md_content\": \"\",\n            \"code_start_line\": 22,\n            \"code_end_line\": 45,\n            \"parent\": \"OpenaiPoolRequest\",\n            \"have_return\": false,\n            \"code_content\": \"    def __init__(self,):\\n        \\\"\\\"\\\"\\n        Initializes the OpenaiPoolRequest class by setting the configuration and loading the pool.\\n        \\\"\\\"\\\"\\n        self.openai_cfg = deepcopy(CONFIG['openai'])\\n        \\n        self.pool:List[Dict] = []\\n        \\n        __pool_file = self.openai_cfg['key_pool_json']\\n        if os.environ.get('API_POOL_FILE',None) is not None:\\n            __pool_file = os.environ.get('API_POOL_FILE')\\n        \\n        if os.path.exists(__pool_file):\\n            self.pool = json.load(open(__pool_file))\\n        \\n        if os.environ.get('OPENAI_KEY',None) is not None:\\n            self.pool.append({\\n                'api_key':os.environ.get('OPENAI_KEY'),\\n                'organization':os.environ.get('OPENAI_ORG',None),\\n                'api_type':os.environ.get('OPENAI_TYPE',None),\\n                'api_version':os.environ.get('OPENAI_VER',None)\\n            })\\n        if len(self.pool) == 0:\\n            logger.warning('No openai api key found! Some functions will be disable!')\\n\",\n            \"name_column\": 8\n        },\n        \"request\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"request\",\n            \"md_content\": \"\",\n            \"code_start_line\": 48,\n            \"code_end_line\": 75,\n            \"parent\": \"OpenaiPoolRequest\",\n            \"have_return\": true,\n            \"code_content\": \"    async def request(self,messages,**kwargs) -> Dict[str, Any]:\\n        \\\"\\\"\\\"\\n        Sends a request to the OpenAI and gets a response.\\n\\n        Args:\\n            messages: Payload to be sent to OpenAI.\\n            kwargs: Optional arguments that the function takes.\\n\\n        Returns:\\n            A dictionary containing the response from the OpenAI.\\n\\n        Raises:\\n            Exception: If the attempt to reach the endpoint exceed limit.\\n        \\\"\\\"\\\"\\n        \\n        chat_args:dict = deepcopy(self.openai_cfg['chat_args'])\\n        chat_args.update(kwargs)\\n\\n        item = random.choice(self.pool)\\n        chat_args['api_key'] = item['api_key']\\n        if 'organization' in item:\\n            chat_args['organization'] = item['organization']\\n        if 'api_type' in item:\\n            chat_args['api_type'] = item['api_type']\\n        if 'api_version' in item:\\n            chat_args['api_version'] = item['api_version']\\n\\n        return await openai.ChatCompletion.acreate(messages=messages,**chat_args)\\n\",\n            \"name_column\": 14\n        },\n        \"__call__\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"__call__\",\n            \"md_content\": \"\",\n            \"code_start_line\": 77,\n            \"code_end_line\": 93,\n            \"parent\": \"OpenaiPoolRequest\",\n            \"have_return\": true,\n            \"code_content\": \"    async def __call__(self,messages,**kwargs) -> Dict[str, Any]:\\n        \\\"\\\"\\\"\\n        Makes a request to the OpenAI by calling the instance of the class.\\n\\n        Args:\\n            messages: Payload to be sent to OpenAI.\\n            kwargs: Optional arguments that the function takes.\\n\\n        Returns:\\n            A dictionary containing the response from the OpenAI.\\n\\n        Raises:\\n            Exception: If there are no API keys available in the pool.\\n        \\\"\\\"\\\"\\n        if len(self.pool)==0:\\n            raise Exception('No openai api key found! OPENAI_PR Disabled!')\\n        return await self.request(messages,**kwargs)\\n\",\n            \"name_column\": 14\n        }\n    },\n    \"ToolServer/ToolServerNode/extensions/__init__.py\": {},\n    \"ToolServer/ToolServerNode/extensions/tools/code_interpreter.py\": {\n        \"run_interpreter\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"run_interpreter\",\n            \"md_content\": \"\",\n            \"code_start_line\": 11,\n            \"code_end_line\": 47,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"async def run_interpreter(code:str=None,command:str=None,filename:str='code.py'):\\n    \\\"\\\"\\\"The code interpreter tool that runs code and return the output.\\n\\n    The `code` will be written to file `filename` and the `command` will be executed in a shell.\\n    Example:\\n    ```\\n    run_interpreter(code='print(\\\"hello world\\\")',command='python code.py')\\n    ```\\n\\n    :param string? code: The code to be written, default to `None`, which means no code will be written to file.\\n    :param string? command: The shell command to be executed should avoid requiring additional user input, default to `python {filename}`.\\n    :param string? filename: The filename to be written in mode `w`, default to `code.py`.\\n\\n    \\\"\\\"\\\"\\n    if code is not None and code != \\\"\\\" and filename != \\\"\\\":\\n        CODE_FS.write_to_file(filename,code)\\n\\n    if command is None:\\n        command = f'python {filename}'\\n    exec_proc = await asyncio.create_subprocess_shell(\\n        'bash',\\n        stderr=asyncio.subprocess.PIPE,\\n        stdout=asyncio.subprocess.PIPE,\\n        stdin=asyncio.subprocess.PIPE,\\n        cwd=CODE_FS.work_directory)\\n    \\n    ret = await asyncio.wait_for(exec_proc.communicate(command.encode()),timeout=CONFIG['shell']['timeout'])\\n    \\n    result = {\\n        'ReturnCode':exec_proc.returncode,\\n    }\\n    if ret[1]!=b'':\\n        result['Error'] = ret[1].decode()\\n    if ret[0]!=b'':\\n        result['Output'] = ret[0].decode()\\n\\n    return result\\n\",\n            \"name_column\": 10\n        }\n    },\n    \"ToolServer/ToolServerNode/extensions/tools/__init__.py\": {},\n    \"ToolServer/ToolServerNode/extensions/tools/calculator.py\": {\n        \"calculator\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"calculator\",\n            \"md_content\": \"\",\n            \"code_start_line\": 9,\n            \"code_end_line\": 28,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"def calculator(expression:str)->str:\\n    \\\"\\\"\\\"It is a simple calculator, which can execute Python expressions: e.g., \\\"(123 + 234) / 23 * 1.5 - 8\\\".\\n        \\n    :param string expression: The python expression you requested.\\n    :return string: The execution results of the expression.\\n    \\\"\\\"\\\"\\n    globals={}\\n    locals={}\\n    try:\\n        # Wrap the code in an eval() call to return the result\\n        wrapped_code = f\\\"__result__ = eval({repr(expression)}, globals(), locals())\\\"\\n        exec(wrapped_code, globals, locals)\\n        return locals.get('__result__', None)\\n    except Exception as e:\\n        try:\\n        # If eval fails, attempt to exec the code without returning a result\\n            exec(expression, globals, locals)\\n            return \\\"Code executed successfully.\\\"\\n        except Exception as e:\\n            return f\\\"Error: {str(e)}\\\"\\n\",\n            \"name_column\": 4\n        }\n    },\n    \"ToolServer/ToolServerNode/extensions/tools/search.py\": {\n        \"bing_search\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"bing_search\",\n            \"md_content\": \"\",\n            \"code_start_line\": 10,\n            \"code_end_line\": 40,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"def bing_search(query:str,region:str = None)->str|list[str]:\\n    \\\"\\\"\\\"Return 3 most relevant results of a Bing search using the official Bing API. This tool does not provide website details, use other tools to browse website if you need.\\n    \\n    :param string query: The search query.\\n    :param string? region: The region code of the search, default to `en-US`. Available regions: `en-US`, `zh-CN`, `ja-JP`, `en-AU`, `en-CA`, `en-GB`, `de-DE`, `en-IN`, `en-ID`, `es-ES`, `fr-FR`, `it-IT`, `en-MY`, `nl-NL`, `en-NZ`, `en-PH`, `en-SG`, `en-ZA`, `sv-SE`, `tr-TR`.\\n    :return string: The results of the search.\\n    \\\"\\\"\\\"\\n    #     :param int num_results: The number of results to return.\\n    \\n    num_results = 3\\n    endpoint = bing_cfg[\\\"endpoint\\\"]\\n    api_key = bing_cfg[\\\"api_key\\\"]\\n    if region is None:\\n        region = 'en-US'\\n    result = requests.get(endpoint, headers={'Ocp-Apim-Subscription-Key': api_key}, params={'q': query, 'mkt': region }, timeout=10)\\n    result.raise_for_status()\\n    result = result.json()\\n\\n    pages = result[\\\"webPages\\\"][\\\"value\\\"]\\n    search_results = []\\n\\n    for idx in range(min(len(pages),num_results)):\\n        message = {\\n            'url':pages[idx]['url'],\\n            'name':pages[idx]['name'],\\n            'snippet':pages[idx]['snippet']\\n        }\\n        search_results.append(message)\\n\\n    # Return the list of search result\\n    return search_results\",\n            \"name_column\": 4\n        }\n    },\n    \"ToolServer/ToolServerNode/extensions/envs/shell.py\": {\n        \"read_pipe\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"read_pipe\",\n            \"md_content\": \"\",\n            \"code_start_line\": 12,\n            \"code_end_line\": 23,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"def read_pipe(pipe:Union[io.StringIO,io.BytesIO],text=True)->Union[str,bytes]:\\n    \\\"\\\"\\\"Reading the `subprocess.PIPE` when readable.\\n    If `text` is `True`, return str, else return bytes.\\n    \\\"\\\"\\\"\\n    output = '' if text else b''\\n    while True:\\n        ready_fds,_,_ = select.select( [pipe.fileno()],[],[],0.01)\\n        if len(ready_fds) == 0:\\n            break\\n        output += os.read(ready_fds[0],16384).decode() if text else os.read(ready_fds[0],16384)\\n\\n    return output\\n\",\n            \"name_column\": 4\n        },\n        \"ShellEnv\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"ShellEnv\",\n            \"md_content\": \"\",\n            \"code_start_line\": 26,\n            \"code_end_line\": 129,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"class ShellEnv(BaseEnv):\\n    \\\"\\\"\\\"Provide and maintain an interactive shell environment.\\n    \\\"\\\"\\\"\\n    def __init__(self,\\n                 config:Dict[str,Any]):\\n        super().__init__(config)\\n        \\n        if sys.platform.startswith(\\\"linux\\\"):\\n            self.shell_program = \\\"bash\\\"\\n        elif sys.platform.startswith(\\\"darwin\\\"):\\n            self.shell_program = \\\"zsh\\\"\\n        else:\\n            self.shell_program = \\\"powershell\\\"\\n        self.work_directory = self.config['filesystem']['work_directory']\\n        self._restart()\\n\\n    @property\\n    def running(self)->bool:\\n        \\\"\\\"\\\"`True` if shell is running, else `False`\\n        \\\"\\\"\\\"\\n        if hasattr(self,'running_proc') and isinstance(self.running_proc,subprocess.Popen):\\n            if self.running_proc.poll() is None:\\n                return True\\n        return False\\n    \\n    def _restart(self,program:str=None,shell:bool=True):\\n        f\\\"\\\"\\\"Restart the shell.\\n        \\n        :param string? program: The program to be executed in shell, the default is `{self.shell_program}`.\\n        \\\"\\\"\\\"\\n        self._kill()\\n        if program is None:\\n            program = self.shell_program\\n        self.running_proc = subprocess.Popen(\\n            program, # adding more shells support\\n            stdin=subprocess.PIPE,\\n            stdout=subprocess.PIPE,\\n            stderr=subprocess.PIPE,\\n            cwd=self.work_directory,\\n            shell=shell,\\n            text=True\\n        )\\n        self.output_fileno = [self.running_proc.stdout.fileno(),self.running_proc.stderr.fileno()]\\n    \\n    def _terminate(self):\\n        \\\"\\\"\\\"Terminate the shell.\\n        \\\"\\\"\\\"\\n        if self.running:\\n            self.running_proc.terminate()\\n\\n    def _kill(self):\\n        \\\"\\\"\\\"Kill the shell.\\n        \\\"\\\"\\\"\\n        if self.running:\\n            self.running_proc.kill()\\n\\n    def read_stdout(self, probe: bool = False) -> str:\\n        \\\"\\\"\\\"Read the stdout stream of the shell. If stderr is not empty, it will be returned instead.\\n        \\n        Empty string will be returned if both stdout and stderr are empty.\\n        You can use this function to check if the shell has new content to be read for a running process takes a while.\\n        \\n        :param boolean? probe: If `True`, the function will return immediately if no output is ready, else it will raise `OutputNotReady` exception and request to call functions in `next_calling` to get result.\\n        \\\"\\\"\\\"\\n        if not self.running:\\n            raise RuntimeError('Shell is not running!')\\n        \\n        ready_fds,_,_ = select.select(self.output_fileno,[],[],0.01)\\n        if probe and len(ready_fds) == 0 :\\n            raise OutputNotReady('Output is not ready!',next_calling=get_func_name(self.read_stdout,self),arguments={'probe':True})\\n        \\n        error = read_pipe(self.running_proc.stderr)\\n        if error:\\n            return error\\n\\n        return read_pipe(self.running_proc.stdout)\\n    \\n    \\n    def write_stdin(self, content:str) -> str:\\n        \\\"\\\"\\\"Write the stdin stream of the shell and get instant feedback from stderr or stdout.\\n        \\n        Example:\\n        ```\\n        write_stdin('echo \\\"hello world\\\"')\\n        ```\\n        This will execute the command `echo \\\"hello world\\\"` in shell and return the output `hello world`.\\n        \\n        :param string content: The content to be written.\\n        \\\"\\\"\\\"\\n\\n        # removed temporarily, maybe put back later?\\n        # You may need to call `read_stdout` to get further feedback for running process takes a while.\\n        if not self.running:\\n            raise RuntimeError('Shell is not running!')\\n        if not content.endswith(\\\"\\\\n\\\"):\\n            content += \\\"\\\\n\\\"\\n        self.running_proc.stdin.write(content)\\n        self.running_proc.stdin.flush()\\n        \\n        ready_fds,_,_ = select.select(self.output_fileno,[],[],0.01)\\n        if len(ready_fds) == 0:\\n            raise OutputNotReady('Output is not ready!',next_calling=get_func_name(self.read_stdout,self),arguments={'probe':True})\\n        \\n        return 'Instant shell output: ' + self.read_stdout()\\n\",\n            \"name_column\": 6\n        },\n        \"__init__\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"__init__\",\n            \"md_content\": \"\",\n            \"code_start_line\": 29,\n            \"code_end_line\": 40,\n            \"parent\": \"ShellEnv\",\n            \"have_return\": false,\n            \"code_content\": \"    def __init__(self,\\n                 config:Dict[str,Any]):\\n        super().__init__(config)\\n        \\n        if sys.platform.startswith(\\\"linux\\\"):\\n            self.shell_program = \\\"bash\\\"\\n        elif sys.platform.startswith(\\\"darwin\\\"):\\n            self.shell_program = \\\"zsh\\\"\\n        else:\\n            self.shell_program = \\\"powershell\\\"\\n        self.work_directory = self.config['filesystem']['work_directory']\\n        self._restart()\\n\",\n            \"name_column\": 8\n        },\n        \"running\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"running\",\n            \"md_content\": \"\",\n            \"code_start_line\": 43,\n            \"code_end_line\": 49,\n            \"parent\": \"ShellEnv\",\n            \"have_return\": true,\n            \"code_content\": \"    def running(self)->bool:\\n        \\\"\\\"\\\"`True` if shell is running, else `False`\\n        \\\"\\\"\\\"\\n        if hasattr(self,'running_proc') and isinstance(self.running_proc,subprocess.Popen):\\n            if self.running_proc.poll() is None:\\n                return True\\n        return False\\n\",\n            \"name_column\": 8\n        },\n        \"_restart\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"_restart\",\n            \"md_content\": \"\",\n            \"code_start_line\": 51,\n            \"code_end_line\": 68,\n            \"parent\": \"ShellEnv\",\n            \"have_return\": false,\n            \"code_content\": \"    def _restart(self,program:str=None,shell:bool=True):\\n        f\\\"\\\"\\\"Restart the shell.\\n        \\n        :param string? program: The program to be executed in shell, the default is `{self.shell_program}`.\\n        \\\"\\\"\\\"\\n        self._kill()\\n        if program is None:\\n            program = self.shell_program\\n        self.running_proc = subprocess.Popen(\\n            program, # adding more shells support\\n            stdin=subprocess.PIPE,\\n            stdout=subprocess.PIPE,\\n            stderr=subprocess.PIPE,\\n            cwd=self.work_directory,\\n            shell=shell,\\n            text=True\\n        )\\n        self.output_fileno = [self.running_proc.stdout.fileno(),self.running_proc.stderr.fileno()]\\n\",\n            \"name_column\": 8\n        },\n        \"_terminate\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"_terminate\",\n            \"md_content\": \"\",\n            \"code_start_line\": 70,\n            \"code_end_line\": 74,\n            \"parent\": \"ShellEnv\",\n            \"have_return\": false,\n            \"code_content\": \"    def _terminate(self):\\n        \\\"\\\"\\\"Terminate the shell.\\n        \\\"\\\"\\\"\\n        if self.running:\\n            self.running_proc.terminate()\\n\",\n            \"name_column\": 8\n        },\n        \"_kill\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"_kill\",\n            \"md_content\": \"\",\n            \"code_start_line\": 76,\n            \"code_end_line\": 80,\n            \"parent\": \"ShellEnv\",\n            \"have_return\": false,\n            \"code_content\": \"    def _kill(self):\\n        \\\"\\\"\\\"Kill the shell.\\n        \\\"\\\"\\\"\\n        if self.running:\\n            self.running_proc.kill()\\n\",\n            \"name_column\": 8\n        },\n        \"read_stdout\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"read_stdout\",\n            \"md_content\": \"\",\n            \"code_start_line\": 82,\n            \"code_end_line\": 101,\n            \"parent\": \"ShellEnv\",\n            \"have_return\": true,\n            \"code_content\": \"    def read_stdout(self, probe: bool = False) -> str:\\n        \\\"\\\"\\\"Read the stdout stream of the shell. If stderr is not empty, it will be returned instead.\\n        \\n        Empty string will be returned if both stdout and stderr are empty.\\n        You can use this function to check if the shell has new content to be read for a running process takes a while.\\n        \\n        :param boolean? probe: If `True`, the function will return immediately if no output is ready, else it will raise `OutputNotReady` exception and request to call functions in `next_calling` to get result.\\n        \\\"\\\"\\\"\\n        if not self.running:\\n            raise RuntimeError('Shell is not running!')\\n        \\n        ready_fds,_,_ = select.select(self.output_fileno,[],[],0.01)\\n        if probe and len(ready_fds) == 0 :\\n            raise OutputNotReady('Output is not ready!',next_calling=get_func_name(self.read_stdout,self),arguments={'probe':True})\\n        \\n        error = read_pipe(self.running_proc.stderr)\\n        if error:\\n            return error\\n\\n        return read_pipe(self.running_proc.stdout)\\n\",\n            \"name_column\": 8\n        },\n        \"write_stdin\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"write_stdin\",\n            \"md_content\": \"\",\n            \"code_start_line\": 104,\n            \"code_end_line\": 129,\n            \"parent\": \"ShellEnv\",\n            \"have_return\": true,\n            \"code_content\": \"    def write_stdin(self, content:str) -> str:\\n        \\\"\\\"\\\"Write the stdin stream of the shell and get instant feedback from stderr or stdout.\\n        \\n        Example:\\n        ```\\n        write_stdin('echo \\\"hello world\\\"')\\n        ```\\n        This will execute the command `echo \\\"hello world\\\"` in shell and return the output `hello world`.\\n        \\n        :param string content: The content to be written.\\n        \\\"\\\"\\\"\\n\\n        # removed temporarily, maybe put back later?\\n        # You may need to call `read_stdout` to get further feedback for running process takes a while.\\n        if not self.running:\\n            raise RuntimeError('Shell is not running!')\\n        if not content.endswith(\\\"\\\\n\\\"):\\n            content += \\\"\\\\n\\\"\\n        self.running_proc.stdin.write(content)\\n        self.running_proc.stdin.flush()\\n        \\n        ready_fds,_,_ = select.select(self.output_fileno,[],[],0.01)\\n        if len(ready_fds) == 0:\\n            raise OutputNotReady('Output is not ready!',next_calling=get_func_name(self.read_stdout,self),arguments={'probe':True})\\n        \\n        return 'Instant shell output: ' + self.read_stdout()\\n\",\n            \"name_column\": 8\n        }\n    },\n    \"ToolServer/ToolServerNode/extensions/envs/__init__.py\": {},\n    \"ToolServer/ToolServerNode/extensions/envs/rapidapi.py\": {\n        \"generate_arg_doc\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"generate_arg_doc\",\n            \"md_content\": \"\",\n            \"code_start_line\": 14,\n            \"code_end_line\": 32,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"def generate_arg_doc(arg_name,arg_type,arg_desc,arg_default=None,arg_optional=None):\\n    match arg_type:\\n        case 'NUMBER':\\n            arg_type = 'integer'\\n        case 'STRING':\\n            arg_type = 'string'\\n        case 'BOOLEAN':\\n            arg_type = 'boolean'\\n        case 'ARRAY':\\n            arg_type = 'array'\\n        case 'OBJECT':\\n            arg_type = 'object'\\n\\n    if arg_optional:\\n        arg_type += '?'\\n    if arg_default:\\n        return f':param {arg_type} {arg_name}: {arg_desc} defaults to {arg_default}'\\n    else:\\n        return f':param {arg_type} {arg_name}: {arg_desc}'\\n\",\n            \"name_column\": 4\n        },\n        \"convert_rapidapi_desc_to_code\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"convert_rapidapi_desc_to_code\",\n            \"md_content\": \"\",\n            \"code_start_line\": 34,\n            \"code_end_line\": 81,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"def convert_rapidapi_desc_to_code(rapidapi_desc:dict)->list[dict]:\\n    tool_desc = {\\n        'category':rapidapi_desc['category'],\\n        'tool_name':standardizing(rapidapi_desc['tool_name']),\\n    }\\n    api_infos = {}\\n    for api_desc in rapidapi_desc['api_list']:\\n        api_name = standardizing(api_desc['name'])\\n        if api_name in ['from','class','return','false','true','id','and']:\\n            api_name = 'is_'+ api_name\\n        api_info = {'api_name':api_name}\\n        api_info.update(tool_desc)\\n        \\n        api_uri = '_'.join(['rapi',tool_desc['tool_name'],api_name])\\n        \\n        \\n        args_doc = []\\n        \\n        for param in api_desc['required_parameters']:\\n            args_doc.append(generate_arg_doc(\\n                param['name'],\\n                param['type'],\\n                param['description'],\\n                param['default'] if 'default' in param else None,\\n                ))\\n        \\n        for param in api_desc['optional_parameters']:\\n            args_doc.append(generate_arg_doc(\\n                param['name'],\\n                param['type'],\\n                param['description'],\\n                param['default'] if 'default' in param else None,\\n                True))\\n        \\n        args_doc = '\\\\n    '.join(args_doc)\\n        code = f\\\"\\\"\\\"async def {api_uri}(self,*args,**kwargs):\\n    '''{rapidapi_desc['tool_description']}\\n    {api_info['description'] if 'description' in api_info else ''}\\n    \\n\\n    {args_doc}\\n    '''\\n    return await self._request_rapid_api('{api_uri}',kwargs)\\n        \\\"\\\"\\\"\\n        api_info['code'] = code\\n        \\n        api_infos[api_uri] = api_info\\n    return api_infos\\n\",\n            \"name_column\": 4\n        },\n        \"rapid_api_mapper\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"rapid_api_mapper\",\n            \"md_content\": \"\",\n            \"code_start_line\": 83,\n            \"code_end_line\": 103,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"def rapid_api_mapper(cls:Type):\\n    \\\"\\\"\\\"Dynamic adding api functions to RapidAPIENnv.\\\"\\\"\\\"\\n    #reading api list\\n    if not os.path.exists(CONFIG['rapidapi']['api_infos_json']):\\n        try:\\n            api_list = json.load(open(CONFIG['rapidapi']['api_raw_json']))\\n        except:\\n            raise FileNotFoundError(f'Both api_infos_json and api_raw_json are not found! Failed to setup RapidAPIEnv!')\\n        \\n        for rapidapi_desc in api_list:\\n            API_INFOS.update(convert_rapidapi_desc_to_code(rapidapi_desc))\\n        \\n        json.dump(API_INFOS,open(CONFIG['rapidapi']['api_infos_json'],'w'),indent=4)\\n    else:\\n        API_INFOS.update(json.load(open(CONFIG['rapidapi']['api_infos_json'])))\\n    \\n    for api_uri,api_info in API_INFOS.items():\\n        exec(api_info['code'])\\n        setattr(cls,api_uri,eval(api_uri))\\n    \\n    return cls\\n\",\n            \"name_column\": 4\n        },\n        \"RapidAPIEnv\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"RapidAPIEnv\",\n            \"md_content\": \"\",\n            \"code_start_line\": 108,\n            \"code_end_line\": 135,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"class RapidAPIEnv(BaseEnv):\\n    \\\"\\\"\\\"RapidAPI Env delivers rapid api for tool server.\\\"\\\"\\\"\\n    \\n    def __init__(self,config:dict={}):\\n        super().__init__(config=config)\\n        \\n        self.rapidapi_cfg = self.config['rapidapi']\\n        self.api_key = self.rapidapi_cfg['api_key']\\n        self.endpoint = self.rapidapi_cfg['endpoint']\\n        \\n        self.api_infos = deepcopy(API_INFOS)\\n        \\n    async def _request_rapid_api(self,api_uri:str,arguments:dict={}):\\n        api_info = self.api_infos[api_uri]\\n        payload = {\\n            'category':api_info['category'],\\n            'tool_name':api_info['tool_name'],\\n            'api_name':api_info['api_name'],\\n            'tool_input':arguments,\\n            'strip':'truncate',\\n            'toolbench_key':self.api_key\\n        }\\n        async with httpx.AsyncClient() as client:\\n            response = await client.post(self.endpoint,json=payload,headers={'toolbench_key':self.api_key})\\n        \\n        response.raise_for_status()\\n        \\n        return response.json()\\n\",\n            \"name_column\": 6\n        },\n        \"__init__\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"__init__\",\n            \"md_content\": \"\",\n            \"code_start_line\": 111,\n            \"code_end_line\": 118,\n            \"parent\": \"RapidAPIEnv\",\n            \"have_return\": false,\n            \"code_content\": \"    def __init__(self,config:dict={}):\\n        super().__init__(config=config)\\n        \\n        self.rapidapi_cfg = self.config['rapidapi']\\n        self.api_key = self.rapidapi_cfg['api_key']\\n        self.endpoint = self.rapidapi_cfg['endpoint']\\n        \\n        self.api_infos = deepcopy(API_INFOS)\\n\",\n            \"name_column\": 8\n        },\n        \"_request_rapid_api\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"_request_rapid_api\",\n            \"md_content\": \"\",\n            \"code_start_line\": 120,\n            \"code_end_line\": 135,\n            \"parent\": \"RapidAPIEnv\",\n            \"have_return\": true,\n            \"code_content\": \"    async def _request_rapid_api(self,api_uri:str,arguments:dict={}):\\n        api_info = self.api_infos[api_uri]\\n        payload = {\\n            'category':api_info['category'],\\n            'tool_name':api_info['tool_name'],\\n            'api_name':api_info['api_name'],\\n            'tool_input':arguments,\\n            'strip':'truncate',\\n            'toolbench_key':self.api_key\\n        }\\n        async with httpx.AsyncClient() as client:\\n            response = await client.post(self.endpoint,json=payload,headers={'toolbench_key':self.api_key})\\n        \\n        response.raise_for_status()\\n        \\n        return response.json()\\n\",\n            \"name_column\": 14\n        }\n    },\n    \"tests/test_run.py\": {\n        \"mock_argv\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"mock_argv\",\n            \"md_content\": \"**mock_argv**sys.argv\\n\\npytestfixturemonkeypatchsys.argvtest_args\\\"--task\\\", \\\"example_task\\\", \\\"--upload-files\\\", \\\"file1\\\", \\\"file2\\\", \\\"--model\\\", \\\"model1\\\"monkeypatch.setattr()sys.argv'test_script.py'test_args\\n\\n\\n\\n****\\n- pytestpytest.fixture\\n- mock_argv\\n- \",\n            \"code_start_line\": 7,\n            \"code_end_line\": 13,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"def mock_argv(monkeypatch):\\n    \\\"\\\"\\\"\\n    A pytest fixture to mock the command line arguments.\\n    It sets the sys.argv to mimic command line input for testing.\\n    \\\"\\\"\\\"\\n    test_args = [\\\"--task\\\", \\\"example_task\\\", \\\"--upload-files\\\", \\\"file1\\\", \\\"file2\\\", \\\"--model\\\", \\\"model1\\\"]\\n    monkeypatch.setattr(sys, 'argv', ['test_script.py'] + test_args)\\n\",\n            \"name_column\": 4\n        },\n        \"test_parse_args\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"test_parse_args\",\n            \"md_content\": \"**test_parse_args**parse_args\\n\\nparse_argsargsargs\\n\\nargs.task\\\"example_task\\\"args.upload_files[\\\"file1\\\", \\\"file2\\\"]args.model\\\"model1\\\"\\n\\n****\\n- \\n- \",\n            \"code_start_line\": 15,\n            \"code_end_line\": 22,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"def test_parse_args(mock_argv):\\n    \\\"\\\"\\\"\\n    Test to ensure that the parse_args function correctly parses command line arguments.\\n    \\\"\\\"\\\"\\n    args = parse_args()\\n    assert args.task == \\\"example_task\\\", \\\"Task argument did not match.\\\"\\n    assert args.upload_files == [\\\"file1\\\", \\\"file2\\\"], \\\"Upload files argument did not match.\\\"\\n    assert args.model == \\\"model1\\\", \\\"Model argument did not match.\\\"\\n\",\n            \"name_column\": 4\n        },\n        \"test_execute_command_line_process_quiet_mode\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"test_execute_command_line_process_quiet_mode\",\n            \"md_content\": \"**test_execute_command_line_process_quiet_mode**execute_command_line_process'quiet_mode'\\n\\n\\n1. parse_argsargs\\n2. execute_command_line_processargsquiet_modeTrue\\n3. assert_called_oncemock_start_command_line\\n4. \\\"execute_command_line_process called start_command_line in quiet mode.\\\"\\n\\n****\\n- execute_command_line_processquiet_mode\\n- mock_start_command_linestart_command_line\\n- quiet_modeTrueexecute_command_line_processquiet_mode\",\n            \"code_start_line\": 25,\n            \"code_end_line\": 32,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"def test_execute_command_line_process_quiet_mode(mock_start_command_line, mock_argv):\\n    \\\"\\\"\\\"\\n    Test to verify if the execute_command_line_process function correctly handles the 'quiet_mode' argument.\\n    \\\"\\\"\\\"\\n    args = parse_args()\\n    execute_command_line_process(args, quiet_mode=True)\\n    mock_start_command_line.assert_called_once()\\n    print(\\\"execute_command_line_process called start_command_line in quiet mode.\\\")\\n\",\n            \"name_column\": 4\n        },\n        \"test_execute_command_line_process_normal_mode\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"test_execute_command_line_process_normal_mode\",\n            \"md_content\": \"**test_execute_command_line_process_normal_mode**: execute_command_line_process'quiet_mode'\\n\\nexecute_command_line_process'quiet_mode'parse_argsargsexecute_command_line_processargsquiet_mode=Falsemock_start_command_line.assert_called_once()mock_start_command_line\\\"execute_command_line_process called start_command_line in normal mode.\\\"\\n\\n****: \\n- execute_command_line_process'quiet_mode'\\n- execute_command_line_processparse_args\\n- mock_start_command_lineexecute_command_line_processstart_command_line\\n- \\\"execute_command_line_process called start_command_line in normal mode.\\\"execute_command_line_processstart_command_line\",\n            \"code_start_line\": 35,\n            \"code_end_line\": 42,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"def test_execute_command_line_process_normal_mode(mock_start_command_line, mock_argv):\\n    \\\"\\\"\\\"\\n    Test to verify if the execute_command_line_process function behaves correctly without the 'quiet_mode' argument.\\n    \\\"\\\"\\\"\\n    args = parse_args()\\n    execute_command_line_process(args, quiet_mode=False)\\n    mock_start_command_line.assert_called_once()\\n    print(\\\"execute_command_line_process called start_command_line in normal mode.\\\")\\n\",\n            \"name_column\": 4\n        },\n        \"test_start_command_line\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"test_start_command_line\",\n            \"md_content\": \"**test_start_command_line**start_command_lineCommandLineCommandLineParam\\n\\nargsstart_command_lineargsstart_command_line\\n\\nmock_command_linemock_argvmock_command_linecalled_args_\\n\\ncalled_argscalled_param\\n\\ncalled_paramtaskargstaskupload_filesmodeargsupload_filesmode\\n\\nstart_command_lineCommandLineParam\\n\\n****\\n- parse_argsstart_command_line\\n- mock_command_linemock_argv\\n- \",\n            \"code_start_line\": 45,\n            \"code_end_line\": 58,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"def test_start_command_line(mock_command_line, mock_argv):\\n    \\\"\\\"\\\"\\n    Test to ensure the start_command_line function correctly initializes the CommandLine class\\n    with the expected CommandLineParam instance based on the parsed arguments.\\n    \\\"\\\"\\\"\\n    args = parse_args()\\n    start_command_line(vars(args))\\n\\n    called_args, _ = mock_command_line.call_args\\n    called_param = called_args[0]\\n    assert called_param.task == args.task, \\\"CommandLineParam task attribute did not match.\\\"\\n    assert called_param.upload_files == args.upload_files, \\\"CommandLineParam upload_files attribute did not match.\\\"\\n    assert called_param.mode == args.mode, \\\"CommandLineParam mode attribute did not match.\\\"\\n    print(\\\"start_command_line function called with correct CommandLineParam.\\\")\\n\",\n            \"name_column\": 4\n        }\n    },\n    \"tests/__init__.py\": {},\n    \"tests/test_1106_model_openai.py\": {\n        \"test_1106_model_openai\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"test_1106_model_openai\",\n            \"md_content\": \"**test_1106_model_openai**: 1106OpenAI\\n\\nopenai_version\\\"1.0.0\\\"OpenAImock.patchOpenAImodel_dump()choices\\\"finish_reason\\\"\\\"index\\\"\\\"message\\\"chatcompletion_requestmodelpromptassert\\n\\nopenai_version\\\"1.0.0\\\"mock.patchChatCompletionchatcompletion_requestmodelpromptassert\\n\\nopenai_version\\n\\n****: \\n- mock.patchOpenAIChatCompletion\\n- assert\\n\\n****:\\nYour OpenAI version is 1.0.0, Successful test\",\n            \"code_start_line\": 8,\n            \"code_end_line\": 48,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"def test_1106_model_openai():\\n    if openai_version >= \\\"1.0.0\\\":\\n        # Mock the OpenAI client and response\\n        with mock.patch(\\\"openai.OpenAI\\\") as mock_openai:\\n            mock_client = mock_openai.return_value\\n            mock_response = mock_client.chat.completions.create.return_value\\n\\n            # Mock the model_dump() method\\n            mock_model_dump = mock_response.model_dump\\n            mock_model_dump.return_value = {\\n                \\\"choices\\\": [\\n                    {\\n                        \\\"finish_reason\\\": \\\"stop\\\",\\n                        \\\"index\\\": 0,\\n                        \\\"message\\\": {\\\"content\\\": \\\"Hello, World!\\\"},\\n                    }\\n                ]\\n            }\\n\\n            # Call the function\\n            response = chatcompletion_request(\\n                model=\\\"gpt-4-1106-preview\\\", prompt=\\\"Hello, world\\\"\\n            )\\n\\n            # Assert that the response is as expected\\n            assert response[\\\"choices\\\"][0][\\\"finish_reason\\\"] == \\\"stop\\\"\\n            assert response[\\\"choices\\\"][0][\\\"index\\\"] == 0\\n            assert response[\\\"choices\\\"][0][\\\"message\\\"][\\\"content\\\"] == \\\"Hello, World!\\\"\\n\\n    else:\\n        with mock.patch(\\\"openai.ChatCompletion\\\") as mock_create:\\n            mock_response_data = \\\"\\\"\\\"{\\\"choices\\\": [{\\\"finish_reason\\\": \\\"stop\\\", \\\"index\\\": 0, \\\"message\\\": {\\\"content\\\": \\\"Hello, World!\\\"}}]}\\\"\\\"\\\"\\n\\n            mock_create.create.return_value = mock_response_data\\n\\n            response = chatcompletion_request(\\n                model=\\\"gpt-4-1106-preview\\\", prompt=\\\"Hello, world\\\"\\n            )\\n            assert response[\\\"choices\\\"][0][\\\"message\\\"][\\\"content\\\"] == \\\"Hello, World!\\\"\\n\\n    print(f\\\"Your OpenAI version is {openai_version}, Successful test\\\")\\n\",\n            \"name_column\": 4\n        }\n    },\n    \"tests/test_model_alias.py\": {\n        \"test_model_alias\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"test_model_alias\",\n            \"md_content\": \"**test_model_alias**\\n\\nopenai_version\\\"1.0.0\\\"mock.patchOpenAImock_response.model_dump.return_valuemodel_dump()choicesfinish_reasonindexmessagechatcompletion_requestmodelpromptresponseassertresponse\\n\\nopenai_version\\\"1.0.0\\\"mock.patchChatCompletionmock_response_datacreatechatcompletion_requestmodelpromptresponseassertresponse\\n\\nopenai_version\\n\\n****\\n- mockOpenAI\\n- openai_version\\n\\n****\\n```\\nYour OpenAI version is 1.0.0, Successful test\\n```\",\n            \"code_start_line\": 8,\n            \"code_end_line\": 48,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"def test_model_alias():\\n    if openai_version >= \\\"1.0.0\\\":\\n        # Mock the OpenAI client and response\\n        with mock.patch(\\\"openai.OpenAI\\\") as mock_openai:\\n            mock_client = mock_openai.return_value\\n            mock_response = mock_client.chat.completions.create.return_value\\n\\n            # Mock the model_dump() method\\n            mock_model_dump = mock_response.model_dump\\n            mock_model_dump.return_value = {\\n                \\\"choices\\\": [\\n                    {\\n                        \\\"finish_reason\\\": \\\"stop\\\",\\n                        \\\"index\\\": 0,\\n                        \\\"message\\\": {\\\"content\\\": \\\"Hello, World!\\\"},\\n                    }\\n                ]\\n            }\\n\\n            # Call the function\\n            response = chatcompletion_request(\\n                model=\\\"gpt-4-turbo\\\", prompt=\\\"Hello, world\\\"\\n            )\\n\\n            # Assert that the response is as expected\\n            assert response[\\\"choices\\\"][0][\\\"finish_reason\\\"] == \\\"stop\\\"\\n            assert response[\\\"choices\\\"][0][\\\"index\\\"] == 0\\n            assert response[\\\"choices\\\"][0][\\\"message\\\"][\\\"content\\\"] == \\\"Hello, World!\\\"\\n\\n    else:\\n        with mock.patch(\\\"openai.ChatCompletion\\\") as mock_create:\\n            mock_response_data = \\\"\\\"\\\"{\\\"choices\\\": [{\\\"finish_reason\\\": \\\"stop\\\", \\\"index\\\": 0, \\\"message\\\": {\\\"content\\\": \\\"Hello, World!\\\"}}]}\\\"\\\"\\\"\\n\\n            mock_create.create.return_value = mock_response_data\\n\\n            response = chatcompletion_request(\\n                model=\\\"gpt-4-turbo\\\", prompt=\\\"Hello, world\\\"\\n            )\\n            assert response[\\\"choices\\\"][0][\\\"message\\\"][\\\"content\\\"] == \\\"Hello, World!\\\"\\n\\n    print(f\\\"Your OpenAI version is {openai_version}, Successful test\\\")\\n\",\n            \"name_column\": 4\n        }\n    },\n    \"XAgentServer/server.py\": {\n        \"XAgentServer\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"XAgentServer\",\n            \"md_content\": \"\",\n            \"code_start_line\": 20,\n            \"code_end_line\": 109,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"class XAgentServer:\\n    \\\"\\\"\\\"XAgent Server Start Class\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, logger: Logger) -> None:\\n        self.logger: Logger = logger\\n\\n    def interact(self, interaction: XAgentInteraction):\\n        # query = message\\n        \\\"\\\"\\\"\\n        XAgent Server Start Function\\n        \\\"\\\"\\\"\\n        from XAgent.config import CONFIG as config\\n        xagent_core = None\\n        try:\\n            config.reload()\\n            args = {}\\n            # args\\n            args = interaction.parameter.args\\n\\n            self.logger.info(\\n                f\\\"server is running, the start query is {args.get('goal', '')}\\\")\\n            xagent_param = XAgentParam()\\n\\n            # build query\\n            xagent_param.build_query({\\n                \\\"role_name\\\": \\\"Assistant\\\",\\n                \\\"task\\\": args.get(\\\"goal\\\", \\\"\\\"),\\n                \\\"plan\\\": args.get(\\\"plan\\\", [\\\"Pay attention to the language in initial goal, always answer with the same language of the initial goal given.\\\"]),\\n            })\\n            xagent_param.build_config(config)\\n            xagent_core = XAgentCoreComponents()\\n            # build XAgent Core Components\\n            xagent_core.build(xagent_param, interaction=interaction)\\n            json_str = json.dumps(\\n                xagent_param.config.to_dict(), indent=2)\\n            json_str=re.sub(r'\\\"api_key\\\": \\\"(.+?)\\\"', r'\\\"api_key\\\": \\\"**\\\"', json_str)\\n            self.logger.info(json_str)\\n            self.logger.typewriter_log(\\n                \\\"Human-In-The-Loop\\\",\\n                Fore.RED,\\n                str(xagent_param.config.enable_ask_human_for_help),\\n            )\\n\\n            file_list = interaction.base.file_list\\n            for file in file_list:\\n                file_uuid = file.get(\\\"uuid\\\", \\\"\\\")\\n                file_name = file.get(\\\"name\\\", \\\"\\\")\\n                if file_uuid.startswith(\\\"/\\\"):\\n                    file_path = file_uuid\\n                else:\\n                    file_path = os.path.join(XAgentServerEnv.Upload.upload_dir,\\n                                         interaction.base.user_id, file_uuid)\\n\\n                upload_dir = os.path.join(\\n                    xagent_core.base_dir, \\\"upload\\\")\\n                if not os.path.exists(upload_dir):\\n                    os.makedirs(upload_dir)\\n                # workspace\\n                if interaction.call_method == \\\"web\\\":\\n                    shutil.copy(file_path, os.path.join(upload_dir, file_name))\\n                else:\\n                    if os.path.exists(file_path):\\n                        if os.path.samefile(file_path, os.path.join(upload_dir, file_name)):\\n                            # ,\\n                            pass\\n                        else:\\n                            shutil.copy(file_path, os.path.join(upload_dir, file_name))\\n                        # shutil.copy(file_path, os.path.join(upload_dir, file_name))\\n\\n                new_file = os.path.join(upload_dir, file_name)\\n                try:\\n                    xagent_core.toolserver_interface.upload_file(new_file)\\n                except Exception as e:\\n                    self.logger.typewriter_log(\\n                        \\\"Error happens when uploading file\\\",\\n                        Fore.RED,\\n                        f\\\"{new_file}\\\\n{e}\\\",\\n                    )\\n                    raise XAgentUploadFileError(str(e)) from e\\n\\n            task_handler = TaskHandler(xagent_core=xagent_core,\\n                                       xagent_param=xagent_param)\\n            self.logger.info(\\\"Start outer loop async\\\")\\n            task_handler.outer_loop()\\n        except Exception as e:\\n            raise XAgentRunningError(str(e)) from e\\n        finally:\\n            if xagent_core is not None:\\n                xagent_core.close()\\n\",\n            \"name_column\": 6\n        },\n        \"__init__\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"__init__\",\n            \"md_content\": \"\",\n            \"code_start_line\": 24,\n            \"code_end_line\": 25,\n            \"parent\": \"XAgentServer\",\n            \"have_return\": false,\n            \"code_content\": \"    def __init__(self, logger: Logger) -> None:\\n        self.logger: Logger = logger\\n\",\n            \"name_column\": 8\n        },\n        \"interact\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"interact\",\n            \"md_content\": \"\",\n            \"code_start_line\": 27,\n            \"code_end_line\": 109,\n            \"parent\": \"XAgentServer\",\n            \"have_return\": false,\n            \"code_content\": \"    def interact(self, interaction: XAgentInteraction):\\n        # query = message\\n        \\\"\\\"\\\"\\n        XAgent Server Start Function\\n        \\\"\\\"\\\"\\n        from XAgent.config import CONFIG as config\\n        xagent_core = None\\n        try:\\n            config.reload()\\n            args = {}\\n            # args\\n            args = interaction.parameter.args\\n\\n            self.logger.info(\\n                f\\\"server is running, the start query is {args.get('goal', '')}\\\")\\n            xagent_param = XAgentParam()\\n\\n            # build query\\n            xagent_param.build_query({\\n                \\\"role_name\\\": \\\"Assistant\\\",\\n                \\\"task\\\": args.get(\\\"goal\\\", \\\"\\\"),\\n                \\\"plan\\\": args.get(\\\"plan\\\", [\\\"Pay attention to the language in initial goal, always answer with the same language of the initial goal given.\\\"]),\\n            })\\n            xagent_param.build_config(config)\\n            xagent_core = XAgentCoreComponents()\\n            # build XAgent Core Components\\n            xagent_core.build(xagent_param, interaction=interaction)\\n            json_str = json.dumps(\\n                xagent_param.config.to_dict(), indent=2)\\n            json_str=re.sub(r'\\\"api_key\\\": \\\"(.+?)\\\"', r'\\\"api_key\\\": \\\"**\\\"', json_str)\\n            self.logger.info(json_str)\\n            self.logger.typewriter_log(\\n                \\\"Human-In-The-Loop\\\",\\n                Fore.RED,\\n                str(xagent_param.config.enable_ask_human_for_help),\\n            )\\n\\n            file_list = interaction.base.file_list\\n            for file in file_list:\\n                file_uuid = file.get(\\\"uuid\\\", \\\"\\\")\\n                file_name = file.get(\\\"name\\\", \\\"\\\")\\n                if file_uuid.startswith(\\\"/\\\"):\\n                    file_path = file_uuid\\n                else:\\n                    file_path = os.path.join(XAgentServerEnv.Upload.upload_dir,\\n                                         interaction.base.user_id, file_uuid)\\n\\n                upload_dir = os.path.join(\\n                    xagent_core.base_dir, \\\"upload\\\")\\n                if not os.path.exists(upload_dir):\\n                    os.makedirs(upload_dir)\\n                # workspace\\n                if interaction.call_method == \\\"web\\\":\\n                    shutil.copy(file_path, os.path.join(upload_dir, file_name))\\n                else:\\n                    if os.path.exists(file_path):\\n                        if os.path.samefile(file_path, os.path.join(upload_dir, file_name)):\\n                            # ,\\n                            pass\\n                        else:\\n                            shutil.copy(file_path, os.path.join(upload_dir, file_name))\\n                        # shutil.copy(file_path, os.path.join(upload_dir, file_name))\\n\\n                new_file = os.path.join(upload_dir, file_name)\\n                try:\\n                    xagent_core.toolserver_interface.upload_file(new_file)\\n                except Exception as e:\\n                    self.logger.typewriter_log(\\n                        \\\"Error happens when uploading file\\\",\\n                        Fore.RED,\\n                        f\\\"{new_file}\\\\n{e}\\\",\\n                    )\\n                    raise XAgentUploadFileError(str(e)) from e\\n\\n            task_handler = TaskHandler(xagent_core=xagent_core,\\n                                       xagent_param=xagent_param)\\n            self.logger.info(\\\"Start outer loop async\\\")\\n            task_handler.outer_loop()\\n        except Exception as e:\\n            raise XAgentRunningError(str(e)) from e\\n        finally:\\n            if xagent_core is not None:\\n                xagent_core.close()\\n\",\n            \"name_column\": 8\n        }\n    },\n    \"XAgentServer/interaction.py\": {\n        \"XAgentInteraction\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"XAgentInteraction\",\n            \"md_content\": \"\",\n            \"code_start_line\": 27,\n            \"code_end_line\": 302,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"class XAgentInteraction(metaclass=abc.ABCMeta):\\n    \\\"\\\"\\\"\\n    XAgent , : XAgentCE\\n    Attributes:\\n        base: \\n        parameter: \\n        interrupt: \\n        toolserver: \\n        call_method: \\n        wait_seconds: \\n        \\n    Components:\\n        logger: \\n        db: \\n        recorder: \\n        toolserver_interface: \\n        \\n    \\n\\n    \\\"\\\"\\\"\\n\\n    def __init__(\\n        self,\\n        base: InteractionBase,\\n        parameter: InteractionParameter,\\n        interrupt: bool = False,\\n        call_method: str = \\\"web\\\",\\n        wait_seconds: int = 600,\\n    ) -> None:\\n        self.base = base\\n        self.parameter = parameter\\n        # \\n        self.current_step = uuid.uuid4().hex\\n        self.logger = None\\n        self.interrupt = interrupt\\n        self.call_method = call_method\\n        self.wait_seconds = wait_seconds\\n        self.log_dir = os.path.join(\\n            os.path.join(XAgentServerEnv.base_dir,\\n                         \\\"localstorage\\\",\\n                         \\\"interact_records\\\"),\\n            datetime.now().strftime(\\\"%Y-%m-%d\\\"),\\n            self.base.interaction_id)\\n        self.human_data = None\\n        if not os.path.exists(self.log_dir):\\n            os.makedirs(self.log_dir)\\n\\n        self.extract_dir = os.path.join(self.log_dir, \\\"workspace\\\")\\n        if not os.path.exists(self.extract_dir):\\n            os.makedirs(self.extract_dir)\\n\\n        self.db: Session = None\\n        self.toolserver_interface = None\\n\\n    def register_toolserver_interface(self, toolserver_interface: ToolServerInterface):\\n        \\\"\\\"\\\"register tool server interface\\\"\\\"\\\"\\n        self.toolserver_interface = toolserver_interface\\n\\n    def resister_logger(self, logger: Logger):\\n        \\\"\\\"\\\"\\n        logger, id, \\n        \\\"\\\"\\\"\\n\\n        self.logger = logger\\n        self.logger.info(f\\\"init interaction: {self.base.interaction_id}\\\")\\n\\n    def register_db(self, db: Session):\\n        \\\"\\\"\\\"\\n        db\\n\\n        Args:\\n            db: Session\\n        \\\"\\\"\\\"\\n        self.db = db\\n\\n    def insert_data(self,\\n                    data: dict,\\n                    status=\\\"\\\",\\n                    current: str = None,\\n                    is_include_pictures: bool = False,):\\n        \\\"\\\"\\\"\\n        , \\n        \\\"\\\"\\\"\\n        # check alive\\n        alive = redis.get_key(self.base.interaction_id)\\n        if alive == \\\"close\\\":\\n            self.logger.info(\\\"The user terminated this action and exited.\\\")\\n            exit(0)\\n        self.current_step = uuid.uuid4().hex\\n\\n        if status == \\\"inner\\\":\\n            tool_name = data.get(\\\"using_tools\\\", {}).get(\\n                \\\"tool_name\\\", \\\"\\\") if isinstance(data, dict) else \\\"\\\"\\n\\n            if tool_name == \\\"subtask_submit\\\":\\n                status = StatusEnum.SUBMIT\\n\\n        # download workspace files\\n        self.download_files()\\n\\n        file_list = os.listdir(self.extract_dir)\\n\\n        # insert raw\\n        process = XAgentRaw(\\n            node_id=self.current_step,\\n            interaction_id=self.base.interaction_id,\\n            current=current,\\n            step=0,\\n            data=data,\\n            file_list=file_list,\\n            status=status,\\n            do_interrupt=self.interrupt,\\n            wait_seconds=0,\\n            ask_for_human_help=False,\\n            create_time=datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\"),\\n            update_time=datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\"),\\n            is_deleted=False,\\n            is_human=False,\\n            human_data=None,\\n            human_file_list=[],\\n            is_send=self.call_method != 'web',\\n            is_receive=False,\\n            include_pictures=is_include_pictures,\\n        )\\n        if status == StatusEnum.FINISHED:\\n            InteractionCRUD.update_interaction_status(\\n                db=self.db,\\n                interaction_id=self.base.interaction_id,\\n                status=StatusEnum.FINISHED,\\n                message=\\\"finished\\\",\\n                current_step=self.current_step)\\n        else:\\n            InteractionCRUD.update_interaction_status(\\n                db=self.db,\\n                interaction_id=self.base.interaction_id,\\n                status=\\\"running\\\",\\n                message=\\\"running\\\",\\n                current_step=self.current_step)\\n        InteractionCRUD.insert_raw(db=self.db, process=process)\\n        if self.call_method == \\\"web\\\":\\n            redis.set_key(self.base.interaction_id + \\\"_send\\\", 1)\\n        elif self.call_method == \\\"cmd\\\":\\n            # print workspace file list\\n            file_list_str = \\\", \\\".join(file_list) \\n            self.logger.typewriter_log(\\n                title=f\\\"-=-=-=-=-=-=-= {self.base.interaction_id}, {self.current_step}, WORKSPACE FILE LIST -=-=-=-=-=-=-=\\\\n\\\",\\n                title_color=Fore.GREEN,\\n                content=f\\\"[{file_list_str}] in {self.extract_dir}\\\"\\n            )\\n\\n    def download_files(self):\\n        \\\"\\\"\\\"download files\\n\\n        Returns:\\n            Boolean: True or False\\n        \\\"\\\"\\\"\\n        try:\\n            save_path = self.toolserver_interface.download_all_files()\\n\\n            if os.path.exists(save_path):\\n                zip_file = zipfile.ZipFile(save_path)\\n                zip_list = zip_file.namelist()  # \\n                for f in zip_list:\\n                    zip_file.extract(f, self.extract_dir)  # \\n\\n                zip_file.close()\\n            return True\\n        except zipfile.BadZipFile:\\n            return False\\n\\n    def receive(self, can_modify=None):\\n        \\\"\\\"\\\"\\n        \\n        \\\"\\\"\\\"\\n\\n        if self.call_method == \\\"web\\\":\\n            wait = 0\\n            while wait < self.wait_seconds:\\n                human_data = self.get_human_data()\\n                if human_data is not None:\\n                    return human_data\\n                else:\\n                    wait += 2\\n                    time.sleep(2)\\n\\n            raise XAgentTimeoutError(\\\"\\\")\\n        else:\\n            print(can_modify)\\n\\n    def get_human_data(self):\\n        \\\"\\\"\\\"\\n        \\n        \\\"\\\"\\\"\\n        # check alive, ensure the interaction is alive\\n        # if The user terminated this action and exited\\n        alive = redis.get_key(self.base.interaction_id)\\n        if alive == \\\"close\\\":\\n            self.logger.info(\\\"The user terminated this action and exited!\\\")\\n            exit(0)\\n        receive_key = self.base.interaction_id + \\\"_\\\" + self.current_step + \\\"_receive\\\"\\n        is_receive = redis.get_key(receive_key)\\n\\n        if is_receive:\\n            raw = InteractionCRUD.get_raw(\\n                db=self.db, interaction_id=self.base.interaction_id, node_id=self.current_step)\\n\\n            if raw and raw.is_human and raw.is_receive:\\n                redis.delete_key(receive_key)\\n                return raw.human_data\\n\\n        return None\\n\\n    def ask_for_human_help(self, data):\\n        \\\"\\\"\\\"\\n        Execute the tool and ask for human help\\n        \\\"\\\"\\\"\\n\\n        self.current_step = uuid.uuid4().hex\\n        self.download_files()\\n        file_list = os.listdir(self.extract_dir)\\n        # special: ask for human help and do interrupt\\n        # send data\\n        process = XAgentRaw(\\n            node_id=self.current_step,\\n            interaction_id=self.base.interaction_id,\\n            current=self.current_step,\\n            step=0,\\n            data=data,\\n            file_list=file_list,\\n            status=StatusEnum.ASK_FOR_HUMAN_HELP,\\n            do_interrupt=True,\\n            wait_seconds=0,\\n            ask_for_human_help=True,\\n            create_time=datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\"),\\n            update_time=datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\"),\\n            is_deleted=False,\\n            is_human=False,\\n            human_data=None,\\n            human_file_list=[],\\n            is_send=False,\\n            is_receive=False,\\n            include_pictures=False,\\n        )\\n\\n        # insert into mysql\\n        InteractionCRUD.insert_raw(db=self.db, process=process)\\n\\n        # set redis\\n        redis.set_key(self.base.interaction_id + \\\"_send\\\", 1)\\n\\n        # set status\\n\\n        InteractionCRUD.update_interaction_status(\\n            db=self.db,\\n            interaction_id=self.base.interaction_id,\\n            status=StatusEnum.ASK_FOR_HUMAN_HELP,\\n            message=\\\"ask for human help\\\",\\n            current_step=self.current_step)\\n\\n        # check alive\\n        alive = redis.get_key(self.base.interaction_id)\\n        if alive == \\\"close\\\":\\n            self.logger.info(\\\"The user terminated this action and exited!\\\")\\n            exit(0)\\n\\n        # wait for human data\\n        wait = 0\\n        while wait < self.wait_seconds:\\n            human_data = self.get_human_data()\\n            if human_data is not None:\\n                return human_data\\n            else:\\n                wait += 2\\n                time.sleep(2)\\n\\n        raise XAgentTimeoutError(\\\"ASK-For-Human-Data: \\\")\\n\",\n            \"name_column\": 6\n        },\n        \"__init__\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"__init__\",\n            \"md_content\": \"\",\n            \"code_start_line\": 48,\n            \"code_end_line\": 79,\n            \"parent\": \"XAgentInteraction\",\n            \"have_return\": false,\n            \"code_content\": \"    def __init__(\\n        self,\\n        base: InteractionBase,\\n        parameter: InteractionParameter,\\n        interrupt: bool = False,\\n        call_method: str = \\\"web\\\",\\n        wait_seconds: int = 600,\\n    ) -> None:\\n        self.base = base\\n        self.parameter = parameter\\n        # \\n        self.current_step = uuid.uuid4().hex\\n        self.logger = None\\n        self.interrupt = interrupt\\n        self.call_method = call_method\\n        self.wait_seconds = wait_seconds\\n        self.log_dir = os.path.join(\\n            os.path.join(XAgentServerEnv.base_dir,\\n                         \\\"localstorage\\\",\\n                         \\\"interact_records\\\"),\\n            datetime.now().strftime(\\\"%Y-%m-%d\\\"),\\n            self.base.interaction_id)\\n        self.human_data = None\\n        if not os.path.exists(self.log_dir):\\n            os.makedirs(self.log_dir)\\n\\n        self.extract_dir = os.path.join(self.log_dir, \\\"workspace\\\")\\n        if not os.path.exists(self.extract_dir):\\n            os.makedirs(self.extract_dir)\\n\\n        self.db: Session = None\\n        self.toolserver_interface = None\\n\",\n            \"name_column\": 8\n        },\n        \"register_toolserver_interface\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"register_toolserver_interface\",\n            \"md_content\": \"\",\n            \"code_start_line\": 81,\n            \"code_end_line\": 83,\n            \"parent\": \"XAgentInteraction\",\n            \"have_return\": false,\n            \"code_content\": \"    def register_toolserver_interface(self, toolserver_interface: ToolServerInterface):\\n        \\\"\\\"\\\"register tool server interface\\\"\\\"\\\"\\n        self.toolserver_interface = toolserver_interface\\n\",\n            \"name_column\": 8\n        },\n        \"resister_logger\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"resister_logger\",\n            \"md_content\": \"\",\n            \"code_start_line\": 85,\n            \"code_end_line\": 91,\n            \"parent\": \"XAgentInteraction\",\n            \"have_return\": false,\n            \"code_content\": \"    def resister_logger(self, logger: Logger):\\n        \\\"\\\"\\\"\\n        logger, id, \\n        \\\"\\\"\\\"\\n\\n        self.logger = logger\\n        self.logger.info(f\\\"init interaction: {self.base.interaction_id}\\\")\\n\",\n            \"name_column\": 8\n        },\n        \"register_db\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"register_db\",\n            \"md_content\": \"\",\n            \"code_start_line\": 93,\n            \"code_end_line\": 100,\n            \"parent\": \"XAgentInteraction\",\n            \"have_return\": false,\n            \"code_content\": \"    def register_db(self, db: Session):\\n        \\\"\\\"\\\"\\n        db\\n\\n        Args:\\n            db: Session\\n        \\\"\\\"\\\"\\n        self.db = db\\n\",\n            \"name_column\": 8\n        },\n        \"insert_data\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"insert_data\",\n            \"md_content\": \"\",\n            \"code_start_line\": 102,\n            \"code_end_line\": 175,\n            \"parent\": \"XAgentInteraction\",\n            \"have_return\": false,\n            \"code_content\": \"    def insert_data(self,\\n                    data: dict,\\n                    status=\\\"\\\",\\n                    current: str = None,\\n                    is_include_pictures: bool = False,):\\n        \\\"\\\"\\\"\\n        , \\n        \\\"\\\"\\\"\\n        # check alive\\n        alive = redis.get_key(self.base.interaction_id)\\n        if alive == \\\"close\\\":\\n            self.logger.info(\\\"The user terminated this action and exited.\\\")\\n            exit(0)\\n        self.current_step = uuid.uuid4().hex\\n\\n        if status == \\\"inner\\\":\\n            tool_name = data.get(\\\"using_tools\\\", {}).get(\\n                \\\"tool_name\\\", \\\"\\\") if isinstance(data, dict) else \\\"\\\"\\n\\n            if tool_name == \\\"subtask_submit\\\":\\n                status = StatusEnum.SUBMIT\\n\\n        # download workspace files\\n        self.download_files()\\n\\n        file_list = os.listdir(self.extract_dir)\\n\\n        # insert raw\\n        process = XAgentRaw(\\n            node_id=self.current_step,\\n            interaction_id=self.base.interaction_id,\\n            current=current,\\n            step=0,\\n            data=data,\\n            file_list=file_list,\\n            status=status,\\n            do_interrupt=self.interrupt,\\n            wait_seconds=0,\\n            ask_for_human_help=False,\\n            create_time=datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\"),\\n            update_time=datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\"),\\n            is_deleted=False,\\n            is_human=False,\\n            human_data=None,\\n            human_file_list=[],\\n            is_send=self.call_method != 'web',\\n            is_receive=False,\\n            include_pictures=is_include_pictures,\\n        )\\n        if status == StatusEnum.FINISHED:\\n            InteractionCRUD.update_interaction_status(\\n                db=self.db,\\n                interaction_id=self.base.interaction_id,\\n                status=StatusEnum.FINISHED,\\n                message=\\\"finished\\\",\\n                current_step=self.current_step)\\n        else:\\n            InteractionCRUD.update_interaction_status(\\n                db=self.db,\\n                interaction_id=self.base.interaction_id,\\n                status=\\\"running\\\",\\n                message=\\\"running\\\",\\n                current_step=self.current_step)\\n        InteractionCRUD.insert_raw(db=self.db, process=process)\\n        if self.call_method == \\\"web\\\":\\n            redis.set_key(self.base.interaction_id + \\\"_send\\\", 1)\\n        elif self.call_method == \\\"cmd\\\":\\n            # print workspace file list\\n            file_list_str = \\\", \\\".join(file_list) \\n            self.logger.typewriter_log(\\n                title=f\\\"-=-=-=-=-=-=-= {self.base.interaction_id}, {self.current_step}, WORKSPACE FILE LIST -=-=-=-=-=-=-=\\\\n\\\",\\n                title_color=Fore.GREEN,\\n                content=f\\\"[{file_list_str}] in {self.extract_dir}\\\"\\n            )\\n\",\n            \"name_column\": 8\n        },\n        \"download_files\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"download_files\",\n            \"md_content\": \"\",\n            \"code_start_line\": 177,\n            \"code_end_line\": 195,\n            \"parent\": \"XAgentInteraction\",\n            \"have_return\": true,\n            \"code_content\": \"    def download_files(self):\\n        \\\"\\\"\\\"download files\\n\\n        Returns:\\n            Boolean: True or False\\n        \\\"\\\"\\\"\\n        try:\\n            save_path = self.toolserver_interface.download_all_files()\\n\\n            if os.path.exists(save_path):\\n                zip_file = zipfile.ZipFile(save_path)\\n                zip_list = zip_file.namelist()  # \\n                for f in zip_list:\\n                    zip_file.extract(f, self.extract_dir)  # \\n\\n                zip_file.close()\\n            return True\\n        except zipfile.BadZipFile:\\n            return False\\n\",\n            \"name_column\": 8\n        },\n        \"receive\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"receive\",\n            \"md_content\": \"\",\n            \"code_start_line\": 197,\n            \"code_end_line\": 214,\n            \"parent\": \"XAgentInteraction\",\n            \"have_return\": true,\n            \"code_content\": \"    def receive(self, can_modify=None):\\n        \\\"\\\"\\\"\\n        \\n        \\\"\\\"\\\"\\n\\n        if self.call_method == \\\"web\\\":\\n            wait = 0\\n            while wait < self.wait_seconds:\\n                human_data = self.get_human_data()\\n                if human_data is not None:\\n                    return human_data\\n                else:\\n                    wait += 2\\n                    time.sleep(2)\\n\\n            raise XAgentTimeoutError(\\\"\\\")\\n        else:\\n            print(can_modify)\\n\",\n            \"name_column\": 8\n        },\n        \"get_human_data\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"get_human_data\",\n            \"md_content\": \"\",\n            \"code_start_line\": 216,\n            \"code_end_line\": 237,\n            \"parent\": \"XAgentInteraction\",\n            \"have_return\": true,\n            \"code_content\": \"    def get_human_data(self):\\n        \\\"\\\"\\\"\\n        \\n        \\\"\\\"\\\"\\n        # check alive, ensure the interaction is alive\\n        # if The user terminated this action and exited\\n        alive = redis.get_key(self.base.interaction_id)\\n        if alive == \\\"close\\\":\\n            self.logger.info(\\\"The user terminated this action and exited!\\\")\\n            exit(0)\\n        receive_key = self.base.interaction_id + \\\"_\\\" + self.current_step + \\\"_receive\\\"\\n        is_receive = redis.get_key(receive_key)\\n\\n        if is_receive:\\n            raw = InteractionCRUD.get_raw(\\n                db=self.db, interaction_id=self.base.interaction_id, node_id=self.current_step)\\n\\n            if raw and raw.is_human and raw.is_receive:\\n                redis.delete_key(receive_key)\\n                return raw.human_data\\n\\n        return None\\n\",\n            \"name_column\": 8\n        },\n        \"ask_for_human_help\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"ask_for_human_help\",\n            \"md_content\": \"\",\n            \"code_start_line\": 239,\n            \"code_end_line\": 302,\n            \"parent\": \"XAgentInteraction\",\n            \"have_return\": true,\n            \"code_content\": \"    def ask_for_human_help(self, data):\\n        \\\"\\\"\\\"\\n        Execute the tool and ask for human help\\n        \\\"\\\"\\\"\\n\\n        self.current_step = uuid.uuid4().hex\\n        self.download_files()\\n        file_list = os.listdir(self.extract_dir)\\n        # special: ask for human help and do interrupt\\n        # send data\\n        process = XAgentRaw(\\n            node_id=self.current_step,\\n            interaction_id=self.base.interaction_id,\\n            current=self.current_step,\\n            step=0,\\n            data=data,\\n            file_list=file_list,\\n            status=StatusEnum.ASK_FOR_HUMAN_HELP,\\n            do_interrupt=True,\\n            wait_seconds=0,\\n            ask_for_human_help=True,\\n            create_time=datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\"),\\n            update_time=datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\"),\\n            is_deleted=False,\\n            is_human=False,\\n            human_data=None,\\n            human_file_list=[],\\n            is_send=False,\\n            is_receive=False,\\n            include_pictures=False,\\n        )\\n\\n        # insert into mysql\\n        InteractionCRUD.insert_raw(db=self.db, process=process)\\n\\n        # set redis\\n        redis.set_key(self.base.interaction_id + \\\"_send\\\", 1)\\n\\n        # set status\\n\\n        InteractionCRUD.update_interaction_status(\\n            db=self.db,\\n            interaction_id=self.base.interaction_id,\\n            status=StatusEnum.ASK_FOR_HUMAN_HELP,\\n            message=\\\"ask for human help\\\",\\n            current_step=self.current_step)\\n\\n        # check alive\\n        alive = redis.get_key(self.base.interaction_id)\\n        if alive == \\\"close\\\":\\n            self.logger.info(\\\"The user terminated this action and exited!\\\")\\n            exit(0)\\n\\n        # wait for human data\\n        wait = 0\\n        while wait < self.wait_seconds:\\n            human_data = self.get_human_data()\\n            if human_data is not None:\\n                return human_data\\n            else:\\n                wait += 2\\n                time.sleep(2)\\n\\n        raise XAgentTimeoutError(\\\"ASK-For-Human-Data: \\\")\\n\",\n            \"name_column\": 8\n        }\n    },\n    \"XAgentServer/exts/redis_ext.py\": {\n        \"RedisClient\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"RedisClient\",\n            \"md_content\": \"\",\n            \"code_start_line\": 8,\n            \"code_end_line\": 135,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"class RedisClient:\\n    \\\"\\\"\\\"\\n    RedisClient\\n    \\\"\\\"\\\"\\n\\n    def __init__(self):\\n        self.client = Redis(host=os.getenv('REDIS_HOST', XAgentServerEnv.Redis.redis_host),\\n                            port=XAgentServerEnv.Redis.redis_port,\\n                            db=XAgentServerEnv.Redis.redis_db,\\n                            password=XAgentServerEnv.Redis.redis_password)\\n\\n    def set_key(self, key, value, ex=None, px=None, nx=False, xx=False):\\n        \\\"\\\"\\\"redis set key\\n\\n        Args:\\n            key (_type_): _description_\\n            value (_type_): _description_\\n            ex (_type_, optional): _description_. Defaults to None.\\n            px (_type_, optional): _description_. Defaults to None.\\n            nx (bool, optional): _description_. Defaults to False.\\n            xx (bool, optional): _description_. Defaults to False.\\n        \\\"\\\"\\\"\\n        self.client.set(key, value, ex, px, nx, xx)\\n\\n    def get_key(self, key):\\n        \\\"\\\"\\\"redis get key\\n\\n        Args:\\n            key (_type_): _description_\\n\\n        Returns:\\n            _type_: _description_\\n        \\\"\\\"\\\"\\n        value = self.client.get(key)\\n        if value:\\n            return value.decode(\\\"utf-8\\\")\\n        else:\\n            return None\\n\\n    def delete_key(self, key):\\n        \\\"\\\"\\\"redis delete key\\n\\n        Args:\\n            key (_type_): _description_\\n        \\\"\\\"\\\"\\n        self.client.delete(key)\\n\\n    def get_all_keys(self):\\n        \\\"\\\"\\\"redis get all keys\\n\\n        Returns:\\n            _type_: _description_\\n        \\\"\\\"\\\"\\n        return self.client.keys()\\n\\n    def delete_all_keys(self):\\n        \\\"\\\"\\\"redis delete all keys\\n        \\\"\\\"\\\"\\n        self.client.flushdb()\\n\\n    def set_parent_key(self, key, value):\\n        \\\"\\\"\\\"redis set parent key\\n\\n        Args:\\n            key (_type_): _description_\\n            value (_type_): _description_\\n        \\\"\\\"\\\"\\n        self.client.set(key, value)\\n\\n    def get_parent_key(self, key):\\n        \\\"\\\"\\\"redis get parent key\\n\\n        Args:\\n            key (_type_): _description_\\n\\n        Returns:\\n            _type_: _description_\\n        \\\"\\\"\\\"\\n        return self.client.get(key)\\n\\n    def delete_parent_key(self, key):\\n        \\\"\\\"\\\"redis delete parent key\\n\\n        Args:\\n            key (_type_): _description_\\n        \\\"\\\"\\\"\\n        self.client.delete(key)\\n\\n    def set_child_key(self, parent_key, key, value):\\n        \\\"\\\"\\\"redis set child key\\n\\n        Args:\\n            key (_type_): _description_\\n            value (_type_): _description_\\n        \\\"\\\"\\\"\\n        parent = self.client.get(parent_key)\\n        if parent:\\n            parent[key] = value\\n        else:\\n            parent = {key: value}\\n        self.set_key(parent_key, parent)\\n        \\n    def get_child_key(self, key):\\n        \\\"\\\"\\\"redis get child key\\n\\n        Args:\\n            key (_type_): _description_\\n\\n        Returns:\\n            _type_: _description_\\n        \\\"\\\"\\\"\\n        return self.client.get(key)\\n\\n    def delete_child_key(self, key):\\n        \\\"\\\"\\\"redis delete child key\\n\\n        Args:\\n            key (_type_): _description_\\n        \\\"\\\"\\\"\\n        self.client.delete(key)\\n\\n    def get_child_keys(self, parent_key):\\n        \\\"\\\"\\\"\\n\\n        Args:\\n            parent_key (_type_): _description_\\n        \\\"\\\"\\\"\\n        return self.client.keys(parent_key)\\n\",\n            \"name_column\": 6\n        },\n        \"__init__\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"__init__\",\n            \"md_content\": \"\",\n            \"code_start_line\": 13,\n            \"code_end_line\": 17,\n            \"parent\": \"RedisClient\",\n            \"have_return\": false,\n            \"code_content\": \"    def __init__(self):\\n        self.client = Redis(host=os.getenv('REDIS_HOST', XAgentServerEnv.Redis.redis_host),\\n                            port=XAgentServerEnv.Redis.redis_port,\\n                            db=XAgentServerEnv.Redis.redis_db,\\n                            password=XAgentServerEnv.Redis.redis_password)\\n\",\n            \"name_column\": 8\n        },\n        \"set_key\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"set_key\",\n            \"md_content\": \"\",\n            \"code_start_line\": 19,\n            \"code_end_line\": 30,\n            \"parent\": \"RedisClient\",\n            \"have_return\": false,\n            \"code_content\": \"    def set_key(self, key, value, ex=None, px=None, nx=False, xx=False):\\n        \\\"\\\"\\\"redis set key\\n\\n        Args:\\n            key (_type_): _description_\\n            value (_type_): _description_\\n            ex (_type_, optional): _description_. Defaults to None.\\n            px (_type_, optional): _description_. Defaults to None.\\n            nx (bool, optional): _description_. Defaults to False.\\n            xx (bool, optional): _description_. Defaults to False.\\n        \\\"\\\"\\\"\\n        self.client.set(key, value, ex, px, nx, xx)\\n\",\n            \"name_column\": 8\n        },\n        \"get_key\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"get_key\",\n            \"md_content\": \"\",\n            \"code_start_line\": 32,\n            \"code_end_line\": 45,\n            \"parent\": \"RedisClient\",\n            \"have_return\": true,\n            \"code_content\": \"    def get_key(self, key):\\n        \\\"\\\"\\\"redis get key\\n\\n        Args:\\n            key (_type_): _description_\\n\\n        Returns:\\n            _type_: _description_\\n        \\\"\\\"\\\"\\n        value = self.client.get(key)\\n        if value:\\n            return value.decode(\\\"utf-8\\\")\\n        else:\\n            return None\\n\",\n            \"name_column\": 8\n        },\n        \"delete_key\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"delete_key\",\n            \"md_content\": \"\",\n            \"code_start_line\": 47,\n            \"code_end_line\": 53,\n            \"parent\": \"RedisClient\",\n            \"have_return\": false,\n            \"code_content\": \"    def delete_key(self, key):\\n        \\\"\\\"\\\"redis delete key\\n\\n        Args:\\n            key (_type_): _description_\\n        \\\"\\\"\\\"\\n        self.client.delete(key)\\n\",\n            \"name_column\": 8\n        },\n        \"get_all_keys\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"get_all_keys\",\n            \"md_content\": \"\",\n            \"code_start_line\": 55,\n            \"code_end_line\": 61,\n            \"parent\": \"RedisClient\",\n            \"have_return\": true,\n            \"code_content\": \"    def get_all_keys(self):\\n        \\\"\\\"\\\"redis get all keys\\n\\n        Returns:\\n            _type_: _description_\\n        \\\"\\\"\\\"\\n        return self.client.keys()\\n\",\n            \"name_column\": 8\n        },\n        \"delete_all_keys\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"delete_all_keys\",\n            \"md_content\": \"\",\n            \"code_start_line\": 63,\n            \"code_end_line\": 66,\n            \"parent\": \"RedisClient\",\n            \"have_return\": false,\n            \"code_content\": \"    def delete_all_keys(self):\\n        \\\"\\\"\\\"redis delete all keys\\n        \\\"\\\"\\\"\\n        self.client.flushdb()\\n\",\n            \"name_column\": 8\n        },\n        \"set_parent_key\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"set_parent_key\",\n            \"md_content\": \"\",\n            \"code_start_line\": 68,\n            \"code_end_line\": 75,\n            \"parent\": \"RedisClient\",\n            \"have_return\": false,\n            \"code_content\": \"    def set_parent_key(self, key, value):\\n        \\\"\\\"\\\"redis set parent key\\n\\n        Args:\\n            key (_type_): _description_\\n            value (_type_): _description_\\n        \\\"\\\"\\\"\\n        self.client.set(key, value)\\n\",\n            \"name_column\": 8\n        },\n        \"get_parent_key\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"get_parent_key\",\n            \"md_content\": \"\",\n            \"code_start_line\": 77,\n            \"code_end_line\": 86,\n            \"parent\": \"RedisClient\",\n            \"have_return\": true,\n            \"code_content\": \"    def get_parent_key(self, key):\\n        \\\"\\\"\\\"redis get parent key\\n\\n        Args:\\n            key (_type_): _description_\\n\\n        Returns:\\n            _type_: _description_\\n        \\\"\\\"\\\"\\n        return self.client.get(key)\\n\",\n            \"name_column\": 8\n        },\n        \"delete_parent_key\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"delete_parent_key\",\n            \"md_content\": \"\",\n            \"code_start_line\": 88,\n            \"code_end_line\": 94,\n            \"parent\": \"RedisClient\",\n            \"have_return\": false,\n            \"code_content\": \"    def delete_parent_key(self, key):\\n        \\\"\\\"\\\"redis delete parent key\\n\\n        Args:\\n            key (_type_): _description_\\n        \\\"\\\"\\\"\\n        self.client.delete(key)\\n\",\n            \"name_column\": 8\n        },\n        \"set_child_key\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"set_child_key\",\n            \"md_content\": \"\",\n            \"code_start_line\": 96,\n            \"code_end_line\": 108,\n            \"parent\": \"RedisClient\",\n            \"have_return\": false,\n            \"code_content\": \"    def set_child_key(self, parent_key, key, value):\\n        \\\"\\\"\\\"redis set child key\\n\\n        Args:\\n            key (_type_): _description_\\n            value (_type_): _description_\\n        \\\"\\\"\\\"\\n        parent = self.client.get(parent_key)\\n        if parent:\\n            parent[key] = value\\n        else:\\n            parent = {key: value}\\n        self.set_key(parent_key, parent)\\n\",\n            \"name_column\": 8\n        },\n        \"get_child_key\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"get_child_key\",\n            \"md_content\": \"\",\n            \"code_start_line\": 110,\n            \"code_end_line\": 119,\n            \"parent\": \"RedisClient\",\n            \"have_return\": true,\n            \"code_content\": \"    def get_child_key(self, key):\\n        \\\"\\\"\\\"redis get child key\\n\\n        Args:\\n            key (_type_): _description_\\n\\n        Returns:\\n            _type_: _description_\\n        \\\"\\\"\\\"\\n        return self.client.get(key)\\n\",\n            \"name_column\": 8\n        },\n        \"delete_child_key\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"delete_child_key\",\n            \"md_content\": \"\",\n            \"code_start_line\": 121,\n            \"code_end_line\": 127,\n            \"parent\": \"RedisClient\",\n            \"have_return\": false,\n            \"code_content\": \"    def delete_child_key(self, key):\\n        \\\"\\\"\\\"redis delete child key\\n\\n        Args:\\n            key (_type_): _description_\\n        \\\"\\\"\\\"\\n        self.client.delete(key)\\n\",\n            \"name_column\": 8\n        },\n        \"get_child_keys\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"get_child_keys\",\n            \"md_content\": \"\",\n            \"code_start_line\": 129,\n            \"code_end_line\": 135,\n            \"parent\": \"RedisClient\",\n            \"have_return\": true,\n            \"code_content\": \"    def get_child_keys(self, parent_key):\\n        \\\"\\\"\\\"\\n\\n        Args:\\n            parent_key (_type_): _description_\\n        \\\"\\\"\\\"\\n        return self.client.keys(parent_key)\\n\",\n            \"name_column\": 8\n        }\n    },\n    \"XAgentServer/exts/mail_ext.py\": {\n        \"email_content\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"email_content\",\n            \"md_content\": \"\",\n            \"code_start_line\": 5,\n            \"code_end_line\": 22,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"def email_content(user):\\n    html_body = f\\\"\\\"\\\"\\n<body style=\\\"font-family: Arial, sans-serif;background-color: #f5f5f5;margin: 0; padding: 0;\\\">\\n    <div style=\\\"background-color: #ffffff;margin: 0 auto;padding: 20px;border-radius: 10px;box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);\\\">\\n        <h1 style=\\\"font-size: 28px;margin-bottom: 20px;\\\">Hello {user['name']},</h1>\\n        <p style=\\\"font-size: 16px;line-height: 1.5;color: #333333;text-indent:2em;\\\">Welcome to XAgent, your personal assistant! Thanks for signing up for XAgent. There are some information about your account:</p>\\n        <p style=\\\"font-size: 16px;line-height: 1.5;color: #333333;text-indent:2em;\\\">Your XAgent Account: <b>{user[\\\"email\\\"]}</b></p>\\n        <p style=\\\"font-size: 16px;line-height: 1.5;color: #333333;text-indent:2em;\\\">You need to use this token for authentication on subsequent logins: </p>\\n        <p style=\\\"font-size: 16px;line-height: 1.5;color: #333333;text-indent:2em;\\\">You need to use this token for authentication on subsequent logins: </p>\\n        <p style=\\\"font-size: 16px;line-height: 1.5;color: #333333;text-indent:2em;\\\">Token: <b>{user[\\\"token\\\"]}</b></p>\\n        \\n        <p style=\\\"font-size: 16px;line-height: 1.5;color: #333333;text-indent:2em;\\\">Next is an activation link. You need to click on this link to activate your account. After that, you will be able to use XAgent happily:<a href=\\\"{XAgentServerEnv.Email.auth_server}/auth?user_id={user[\\\"user_id\\\"]}&token={user[\\\"token\\\"]}\\\">{XAgentServerEnv.Email.auth_server}/auth?user_id={user[\\\"user_id\\\"]}&token={user[\\\"token\\\"]}</a>! This Verification link will expire in 7 days.</p>\\n        <p>If you have any questions, please contact us at yourxagent@gmail.com .</p>\\n        <p style=\\\"margin-top: 20px;font-size: 14px;color: #999999;text-indent:2em;\\\">Best wishes!</p>\\n        <p style=\\\"margin-top: 20px;font-size: 14px;color: #999999;\\\">XAgent Team</p>\\n    </div>\\n</body>\\\"\\\"\\\"\\n    return html_body\\n\",\n            \"name_column\": 4\n        }\n    },\n    \"XAgentServer/exts/exception_ext.py\": {\n        \"XAgentError\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"XAgentError\",\n            \"md_content\": \"\",\n            \"code_start_line\": 4,\n            \"code_end_line\": 8,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"class XAgentError(Exception):\\n    \\\"\\\"\\\"Base class for exceptions in this module.\\\"\\\"\\\"\\n    def __init__(self, message=\\\"XAgent Error!\\\"):\\n        self.message = message\\n        super().__init__(self.message)\\n\",\n            \"name_column\": 6\n        },\n        \"XAgentTimeoutError\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"XAgentTimeoutError\",\n            \"md_content\": \"\",\n            \"code_start_line\": 11,\n            \"code_end_line\": 20,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"class XAgentTimeoutError(XAgentError):\\n    \\\"\\\"\\\"Exception raised for errors in the input.\\n\\n    Attributes:\\n        message -- explanation of the error\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, message=\\\"XAgentTimeout!\\\"):\\n        self.message = message\\n        super().__init__(self.message)\\n\",\n            \"name_column\": 6\n        },\n        \"XAgentCloseError\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"XAgentCloseError\",\n            \"md_content\": \"\",\n            \"code_start_line\": 23,\n            \"code_end_line\": 32,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"class XAgentCloseError(XAgentError):\\n    \\\"\\\"\\\"Exception raised for errors in the input.\\n\\n    Attributes:\\n        message -- explanation of the error\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, message=\\\"XAgentClose!\\\"):\\n        self.message = message\\n        super().__init__(self.message)\\n\",\n            \"name_column\": 6\n        },\n        \"XAgentWebSocketError\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"XAgentWebSocketError\",\n            \"md_content\": \"\",\n            \"code_start_line\": 34,\n            \"code_end_line\": 43,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"class XAgentWebSocketError(XAgentError):\\n    \\\"\\\"\\\"Exception raised for errors in the input.\\n\\n    Attributes:\\n        message -- explanation of the error\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, message=\\\"XAgentWebSocket Error!\\\"):\\n        self.message = message\\n        super().__init__(self.message)\\n\",\n            \"name_column\": 6\n        },\n        \"XAgentWebSocketTimeoutError\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"XAgentWebSocketTimeoutError\",\n            \"md_content\": \"\",\n            \"code_start_line\": 45,\n            \"code_end_line\": 54,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"class XAgentWebSocketTimeoutError(XAgentWebSocketError):\\n    \\\"\\\"\\\"Exception raised for errors in the input.\\n\\n    Attributes:\\n        message -- explanation of the error\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, message=\\\"XAgentWebSocket Timeout!\\\"):\\n        self.message = message\\n        super().__init__(self.message)\\n\",\n            \"name_column\": 6\n        },\n        \"XAgentWebSocketDisconnectError\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"XAgentWebSocketDisconnectError\",\n            \"md_content\": \"\",\n            \"code_start_line\": 57,\n            \"code_end_line\": 66,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"class XAgentWebSocketDisconnectError(XAgentWebSocketError):\\n    \\\"\\\"\\\"Exception raised for errors in the input.\\n\\n    Attributes:\\n        message -- explanation of the error\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, message=\\\"XAgentWebSocket Disconnect!\\\"):\\n        self.message = message\\n        super().__init__(self.message)\\n\",\n            \"name_column\": 6\n        },\n        \"XAgentWebSocketConnectError\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"XAgentWebSocketConnectError\",\n            \"md_content\": \"\",\n            \"code_start_line\": 69,\n            \"code_end_line\": 78,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"class XAgentWebSocketConnectError(XAgentWebSocketError):\\n    \\\"\\\"\\\"Exception raised for errors in the input.\\n\\n    Attributes:\\n        message -- explanation of the error\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, message=\\\"XAgentWebSocket Connect Error!\\\"):\\n        self.message = message\\n        super().__init__(self.message)\\n\",\n            \"name_column\": 6\n        },\n        \"XAgentWebSocketCloseError\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"XAgentWebSocketCloseError\",\n            \"md_content\": \"\",\n            \"code_start_line\": 81,\n            \"code_end_line\": 90,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"class XAgentWebSocketCloseError(XAgentWebSocketError):\\n    \\\"\\\"\\\"Exception raised for errors in the input.\\n\\n    Attributes:\\n        message -- explanation of the error\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, message=\\\"XAgentWebSocket Close!\\\"):\\n        self.message = message\\n        super().__init__(self.message)\\n\",\n            \"name_column\": 6\n        },\n        \"XAgentWebSocketSendError\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"XAgentWebSocketSendError\",\n            \"md_content\": \"\",\n            \"code_start_line\": 93,\n            \"code_end_line\": 102,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"class XAgentWebSocketSendError(XAgentWebSocketError):\\n    \\\"\\\"\\\"Exception raised for errors in the input.\\n\\n    Attributes:\\n        message -- explanation of the error\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, message=\\\"XAgentWebSocket Send Error!\\\"):\\n        self.message = message\\n        super().__init__(self.message)\\n\",\n            \"name_column\": 6\n        },\n        \"XAgentWebSocketReceiveError\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"XAgentWebSocketReceiveError\",\n            \"md_content\": \"\",\n            \"code_start_line\": 105,\n            \"code_end_line\": 114,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"class XAgentWebSocketReceiveError(XAgentWebSocketError):\\n    \\\"\\\"\\\"Exception raised for errors in the input.\\n\\n    Attributes:\\n        message -- explanation of the error\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, message=\\\"XAgentWebSocket Receive Error!\\\"):\\n        self.message = message\\n        super().__init__(self.message)\\n\",\n            \"name_column\": 6\n        },\n        \"XAgentFileError\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"XAgentFileError\",\n            \"md_content\": \"\",\n            \"code_start_line\": 117,\n            \"code_end_line\": 126,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"class XAgentFileError(XAgentError):\\n    \\\"\\\"\\\"Exception raised for errors in the input.\\n\\n    Attributes:\\n        message -- explanation of the error\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, message=\\\"XAgent File Error!\\\"):\\n        self.message = message\\n        super().__init__(self.message)\\n\",\n            \"name_column\": 6\n        },\n        \"XAgentDownloadFileError\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"XAgentDownloadFileError\",\n            \"md_content\": \"\",\n            \"code_start_line\": 129,\n            \"code_end_line\": 138,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"class XAgentDownloadFileError(XAgentFileError):\\n    \\\"\\\"\\\"Exception raised for errors in the input.\\n\\n    Attributes:\\n        message -- explanation of the error\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, message=\\\"Download File Error!\\\"):\\n        self.message = message\\n        super().__init__(self.message)\\n\",\n            \"name_column\": 6\n        },\n        \"XAgentWorkspaceFileError\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"XAgentWorkspaceFileError\",\n            \"md_content\": \"\",\n            \"code_start_line\": 141,\n            \"code_end_line\": 150,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"class XAgentWorkspaceFileError(XAgentFileError):\\n    \\\"\\\"\\\"Exception raised for errors in the input.\\n\\n    Attributes:\\n        message -- explanation of the error\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, message=\\\"XAgent Workspace File Error!\\\"):\\n        self.message = message\\n        super().__init__(self.message)\\n\",\n            \"name_column\": 6\n        },\n        \"XAgentUploadFileError\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"XAgentUploadFileError\",\n            \"md_content\": \"\",\n            \"code_start_line\": 153,\n            \"code_end_line\": 162,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"class XAgentUploadFileError(XAgentFileError):\\n    \\\"\\\"\\\"Exception raised for errors in the input.\\n\\n    Attributes:\\n        message -- explanation of the error\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, message=\\\"XAgent Workspace Upload File Error!\\\"):\\n        self.message = message\\n        super().__init__(self.message)\\n\",\n            \"name_column\": 6\n        },\n        \"XAgentDBError\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"XAgentDBError\",\n            \"md_content\": \"\",\n            \"code_start_line\": 165,\n            \"code_end_line\": 174,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"class XAgentDBError(XAgentError):\\n    \\\"\\\"\\\"Exception raised because of DB error\\n\\n    Attributes:\\n        message -- explanation of the error\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, message=\\\"XAgent DB Error!\\\"):\\n        self.message = message\\n        super().__init__(self.message)\\n\",\n            \"name_column\": 6\n        },\n        \"XAgentAuthError\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"XAgentAuthError\",\n            \"md_content\": \"\",\n            \"code_start_line\": 177,\n            \"code_end_line\": 186,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"class XAgentAuthError(XAgentError):\\n    \\\"\\\"\\\"Exception raised because of auth error\\n\\n    Attributes:\\n        message -- explanation of the error\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, message=\\\"XAgent Auth Error!\\\"):\\n        self.message = message\\n        super().__init__(self.message)\\n\",\n            \"name_column\": 6\n        },\n        \"XAgentRunningError\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"XAgentRunningError\",\n            \"md_content\": \"\",\n            \"code_start_line\": 189,\n            \"code_end_line\": 198,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"class XAgentRunningError(XAgentError):\\n    \\\"\\\"\\\"Exception raised because of Running error\\n\\n    Attributes:\\n        message -- explanation of the error\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, message=\\\"XAgent Running Error!\\\"):\\n        self.message = message\\n        super().__init__(self.message)\\n\",\n            \"name_column\": 6\n        },\n        \"XAgentWebError\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"XAgentWebError\",\n            \"md_content\": \"\",\n            \"code_start_line\": 201,\n            \"code_end_line\": 210,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"class XAgentWebError(XAgentError):\\n    \\\"\\\"\\\"Exception raised because of Running error\\n\\n    Attributes:\\n        message -- explanation of the error\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, message=\\\"XAgent WEB Error!\\\"):\\n        self.message = message\\n        super().__init__(self.message)\\n\",\n            \"name_column\": 6\n        },\n        \"__init__\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"__init__\",\n            \"md_content\": \"\",\n            \"code_start_line\": 208,\n            \"code_end_line\": 210,\n            \"parent\": \"XAgentWebError\",\n            \"have_return\": false,\n            \"code_content\": \"    def __init__(self, message=\\\"XAgent WEB Error!\\\"):\\n        self.message = message\\n        super().__init__(self.message)\\n\",\n            \"name_column\": 8\n        }\n    },\n    \"XAgentServer/database/models.py\": {\n        \"User\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"User\",\n            \"md_content\": \"\",\n            \"code_start_line\": 6,\n            \"code_end_line\": 22,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"class User(Base):\\n    \\\"\\\"\\\"XAgent Users\\\"\\\"\\\"\\n    __tablename__=\\\"users\\\"\\n\\n    id=Column(Integer,primary_key=True,index=True)\\n    user_id = Column(String(32), unique=True, index=True)\\n    email = Column(String(255), unique=True)\\n    name = Column(String(255))\\n    token = Column(String(255))\\n    available = Column(Boolean, default=True)\\n    is_beta = Column(Boolean, default=False)\\n    deleted = Column(Boolean, default=False)\\n    corporation = Column(Text)\\n    industry = Column(Text)\\n    position = Column(String(255))\\n    create_time = Column(String(255))\\n    update_time = Column(String(255))\\n\",\n            \"name_column\": 6\n        },\n        \"Interaction\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"Interaction\",\n            \"md_content\": \"\",\n            \"code_start_line\": 25,\n            \"code_end_line\": 43,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"class Interaction(Base):\\n    \\\"\\\"\\\"XAgent Interactions\\\"\\\"\\\"\\n    __tablename__ = \\\"interactions\\\"\\n\\n    id = Column(Integer, primary_key=True, index=True)\\n    interaction_id = Column(String(255))\\n    user_id = Column(String(255))\\n    create_time = Column(String(255))\\n    update_time = Column(String(255))\\n    description = Column(Text)\\n    agent = Column(String(255))\\n    mode = Column(String(255))\\n    recorder_root_dir = Column(Text)\\n    file_list = Column(JSON)\\n    status = Column(String(255))\\n    message = Column(Text)\\n    current_step = Column(String(255))\\n    is_deleted = Column(Boolean, default=False)\\n    call_method = Column(String(255), default=\\\"web\\\")\\n\",\n            \"name_column\": 6\n        },\n        \"Parameter\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"Parameter\",\n            \"md_content\": \"\",\n            \"code_start_line\": 46,\n            \"code_end_line\": 53,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"class Parameter(Base):\\n    \\\"\\\"\\\"XAgent Parameters\\\"\\\"\\\"\\n    __tablename__ = \\\"interaction_parameters\\\"\\n\\n    id = Column(Integer, primary_key=True, index=True)\\n    interaction_id = Column(String(32), unique=True, index=True)\\n    parameter_id = Column(String(32))\\n    args = Column(JSON)\\n\",\n            \"name_column\": 6\n        },\n        \"SharedInteraction\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"SharedInteraction\",\n            \"md_content\": \"\",\n            \"code_start_line\": 56,\n            \"code_end_line\": 70,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"class SharedInteraction(Base):\\n    \\\"\\\"\\\"Commnunity Shared Interactions\\\"\\\"\\\"\\n    __tablename__ = \\\"shared_interactions\\\"\\n\\n    id = Column(Integer, primary_key=True, index=True)\\n    interaction_id = Column(String(255))\\n    user_name = Column(String(255))\\n    create_time = Column(String(255))\\n    update_time = Column(String(255))\\n    description = Column(Text)\\n    agent = Column(String(255))\\n    mode = Column(String(255))\\n    is_deleted = Column(Boolean, default=False)\\n    star = Column(Integer, default=0)\\n    is_audit = Column(Boolean, default=False)\\n\",\n            \"name_column\": 6\n        },\n        \"Raw\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"Raw\",\n            \"md_content\": \"\",\n            \"code_start_line\": 73,\n            \"code_end_line\": 115,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"class Raw(Base):\\n    \\\"\\\"\\\"Raw Data\\\"\\\"\\\"\\n    __tablename__ = \\\"raw\\\"\\n    # id/id\\n    id = Column(Integer, primary_key=True, index=True)\\n    # node_id\\n    node_id = Column(String(255))\\n    # id/interaction_id\\n    interaction_id = Column(String(255))\\n    # /current\\n    current = Column(String(128))\\n    # step/step\\n    step = Column(Integer, default=0)\\n    # /agent data\\n    data = Column(JSON)\\n    # workspace/workspace file list\\n    file_list = Column(JSON)\\n    # /status\\n    status = Column(String(20))\\n    # /interrupt or not\\n    do_interrupt = Column(Boolean, default=False)\\n    # /wait seconds\\n    wait_seconds = Column(Integer, default=0)\\n    # /ask for human help or not\\n    ask_for_human_help = Column(Boolean, default=False)\\n    # /create time\\n    create_time = Column(String(255))\\n    # /update time\\n    update_time = Column(String(255))\\n    # /is deleted or not\\n    is_deleted = Column(Boolean, default=False)\\n    # /has human input or not\\n    is_human = Column(Boolean, default=False)\\n    # /human data\\n    human_data = Column(JSON)\\n    # /agent file list\\n    human_file_list = Column(JSON)\\n    # /has send to frontend or not\\n    is_send = Column(Boolean, default=False)\\n    # /has receive message from frontend or not\\n    is_receive = Column(Boolean, default=False)\\n    # png/has png or not\\n    include_pictures = Column(Boolean, default=False)\\n\",\n            \"name_column\": 6\n        },\n        \"RunningRecord\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"RunningRecord\",\n            \"md_content\": \"\",\n            \"code_start_line\": 118,\n            \"code_end_line\": 138,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"class RunningRecord(Base):\\n    \\\"\\\"\\\"Running Record\\\"\\\"\\\"\\n    __tablename__ = \\\"running_record\\\"\\n    # id/id\\n    id = Column(Integer, primary_key=True, index=True)\\n    # record_id/record_id\\n    record_id = Column(String(255))\\n    # /current\\n    current = Column(String(255))\\n    # id/node_id\\n    node_id = Column(String(255))\\n    # /node_type, options: [now_subtask_id, llm_input_pair, tool_server_pair, query, config]\\n    node_type = Column(String(255))\\n    # data/agent data\\n    data = Column(JSON)\\n    # /create time\\n    create_time = Column(String(255))\\n    # /update time\\n    update_time = Column(String(255))\\n    # /is deleted or not\\n    is_deleted = Column(Boolean, default=False)\\n\",\n            \"name_column\": 6\n        }\n    },\n    \"XAgentServer/database/connect.py\": {},\n    \"XAgentServer/database/__init__.py\": {},\n    \"XAgentServer/database/interface/user.py\": {\n        \"UserDBInterface\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"UserDBInterface\",\n            \"md_content\": \"\",\n            \"code_start_line\": 13,\n            \"code_end_line\": 160,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"class UserDBInterface(metaclass=abc.ABCMeta):\\n    \\\"\\\"\\\"User DB Interface\\n\\n    Args:\\n        UserBaseInterface (_type_): _description_\\n        metaclass (_type_, optional): _description_. Defaults to abc.ABCMeta.\\n    \\\"\\\"\\\"\\n\\n    @classmethod\\n    def get_user_list(cls, db: Session) -> list[XAgentUser]:\\n        \\\"\\\"\\\"get all users\\n\\n        Args:\\n            db (Session): db\\n\\n        Returns:\\n            list[XAgentUser]: user list\\n        \\\"\\\"\\\"\\n        users = db.query(User).all()\\n        return [XAgentUser.from_db(user) for user in users]\\n\\n    @classmethod\\n    def get_user(cls,\\n                 db: Session,\\n                 user_id: str | None = None,\\n                 email: str | None = None) -> XAgentUser | None:\\n        \\\"\\\"\\\"get user by user_id or email\\n\\n        Args:\\n            db (Session): db\\n            user_id (str | None, optional): user id. Defaults to None.\\n            email (str | None, optional): email. Defaults to None.\\n\\n        Returns:\\n            XAgentUser | None: user, if user is not exist, return None\\n        \\\"\\\"\\\"\\n        if email is not None:\\n            user = db.query(User).filter(User.email == email,\\n                                         User.deleted.is_(False)).first()\\n        else:\\n            user = db.query(User).filter(\\n                User.user_id == user_id, User.deleted.is_(False)).first()\\n\\n        return XAgentUser.from_db(user) if user else None\\n\\n    @classmethod\\n    def is_exist(cls,\\n                db: Session,\\n                user_id: str | None = None,\\n                email: str | None = None):\\n        \\\"\\\"\\\"user is exist?\\n\\n        Args:\\n            db (Session): db session\\n            user_id (str | None, optional): user id. Defaults to None.\\n            email (str | None, optional): email. Defaults to None.\\n\\n        Returns:\\n            Boolean: True or False\\n        \\\"\\\"\\\"\\n        if not email and not user_id:\\n            return False\\n        if email:\\n            user = db.query(User).filter(User.email == email,\\n                                         User.deleted.is_(False)).first()\\n        else:\\n            user = db.query(User).filter(\\n                User.user_id == user_id, User.deleted.is_(False)).first()\\n        return user is not None\\n\\n    @classmethod\\n    def token_is_exist(cls,\\n                       db: Session,\\n                       user_id: str,\\n                       token: str | None = None):\\n        \\\"\\\"\\\"token is exist?\\n        \\n        Args:\\n            db (Session): db session\\n            user_id (str): user id\\n            token (str | None, optional): token. Defaults to None.\\n            \\n        Returns:\\n            Boolean: True or False\\n        \\\"\\\"\\\"\\n        if not token:\\n            return False\\n\\n        user = db.query(User).filter(User.user_id == user_id,\\n                                     User.token == token, User.deleted.is_(False)).first()\\n        return user is not None\\n\\n    @classmethod\\n    def user_is_valid(cls, db: Session,\\n                      user_id: str | None = None,\\n                      email: str | None = None,\\n                      token: str | None = None):\\n        \\\"\\\"\\\"\\n        user is valid?\\n        \\n        Args:\\n            db (Session): db session\\n            user_id (str | None, optional): user id. Defaults to None.\\n            email (str | None, optional): email. Defaults to None.\\n            token (str | None, optional): token. Defaults to None.\\n            \\n        Returns:\\n            Boolean: True or False\\n        \\\"\\\"\\\"\\n        if email == \\\"\\\":\\n            return False\\n        user = db.query(User).filter(User.user_id == user_id,\\n                                     User.token == token, User.deleted.is_(False)).first()\\n        if user is None:\\n            return False\\n        if token is None:\\n            if user.email == email and user.available:\\n                return True\\n        if user_id is not None:\\n            if user.user_id == user_id and user.token == token and user.available:\\n                return True\\n        if email is not None:\\n            if user.email == email and user.token == token and user.available:\\n                return True\\n        return False\\n\\n    @classmethod\\n    def add_user(cls, db: Session, user_dict: dict):\\n        \\\"\\\"\\\"\\n        add user\\n        \\\"\\\"\\\"\\n        db.add(User(**user_dict))\\n        db.commit()\\n\\n    @classmethod\\n    def update_user(cls, db: Session, user: XAgentUser):\\n        \\\"\\\"\\\"\\n        update user\\n        \\\"\\\"\\\"\\n        db_user = db.query(User).filter(\\n            User.user_id == user.user_id, User.deleted.is_(False)).first()\\n\\n        db_user.available = user.available\\n        db_user.email = user.email\\n        db_user.name = user.name\\n        db_user.token = user.token\\n        db_user.update_time = datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\")\\n        db.commit()\\n\",\n            \"name_column\": 6\n        },\n        \"get_user_list\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"get_user_list\",\n            \"md_content\": \"\",\n            \"code_start_line\": 22,\n            \"code_end_line\": 32,\n            \"parent\": \"UserDBInterface\",\n            \"have_return\": true,\n            \"code_content\": \"    def get_user_list(cls, db: Session) -> list[XAgentUser]:\\n        \\\"\\\"\\\"get all users\\n\\n        Args:\\n            db (Session): db\\n\\n        Returns:\\n            list[XAgentUser]: user list\\n        \\\"\\\"\\\"\\n        users = db.query(User).all()\\n        return [XAgentUser.from_db(user) for user in users]\\n\",\n            \"name_column\": 8\n        },\n        \"get_user\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"get_user\",\n            \"md_content\": \"\",\n            \"code_start_line\": 35,\n            \"code_end_line\": 56,\n            \"parent\": \"UserDBInterface\",\n            \"have_return\": true,\n            \"code_content\": \"    def get_user(cls,\\n                 db: Session,\\n                 user_id: str | None = None,\\n                 email: str | None = None) -> XAgentUser | None:\\n        \\\"\\\"\\\"get user by user_id or email\\n\\n        Args:\\n            db (Session): db\\n            user_id (str | None, optional): user id. Defaults to None.\\n            email (str | None, optional): email. Defaults to None.\\n\\n        Returns:\\n            XAgentUser | None: user, if user is not exist, return None\\n        \\\"\\\"\\\"\\n        if email is not None:\\n            user = db.query(User).filter(User.email == email,\\n                                         User.deleted.is_(False)).first()\\n        else:\\n            user = db.query(User).filter(\\n                User.user_id == user_id, User.deleted.is_(False)).first()\\n\\n        return XAgentUser.from_db(user) if user else None\\n\",\n            \"name_column\": 8\n        },\n        \"is_exist\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"is_exist\",\n            \"md_content\": \"\",\n            \"code_start_line\": 59,\n            \"code_end_line\": 81,\n            \"parent\": \"UserDBInterface\",\n            \"have_return\": true,\n            \"code_content\": \"    def is_exist(cls,\\n                db: Session,\\n                user_id: str | None = None,\\n                email: str | None = None):\\n        \\\"\\\"\\\"user is exist?\\n\\n        Args:\\n            db (Session): db session\\n            user_id (str | None, optional): user id. Defaults to None.\\n            email (str | None, optional): email. Defaults to None.\\n\\n        Returns:\\n            Boolean: True or False\\n        \\\"\\\"\\\"\\n        if not email and not user_id:\\n            return False\\n        if email:\\n            user = db.query(User).filter(User.email == email,\\n                                         User.deleted.is_(False)).first()\\n        else:\\n            user = db.query(User).filter(\\n                User.user_id == user_id, User.deleted.is_(False)).first()\\n        return user is not None\\n\",\n            \"name_column\": 8\n        },\n        \"token_is_exist\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"token_is_exist\",\n            \"md_content\": \"\",\n            \"code_start_line\": 84,\n            \"code_end_line\": 103,\n            \"parent\": \"UserDBInterface\",\n            \"have_return\": true,\n            \"code_content\": \"    def token_is_exist(cls,\\n                       db: Session,\\n                       user_id: str,\\n                       token: str | None = None):\\n        \\\"\\\"\\\"token is exist?\\n        \\n        Args:\\n            db (Session): db session\\n            user_id (str): user id\\n            token (str | None, optional): token. Defaults to None.\\n            \\n        Returns:\\n            Boolean: True or False\\n        \\\"\\\"\\\"\\n        if not token:\\n            return False\\n\\n        user = db.query(User).filter(User.user_id == user_id,\\n                                     User.token == token, User.deleted.is_(False)).first()\\n        return user is not None\\n\",\n            \"name_column\": 8\n        },\n        \"user_is_valid\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"user_is_valid\",\n            \"md_content\": \"\",\n            \"code_start_line\": 106,\n            \"code_end_line\": 137,\n            \"parent\": \"UserDBInterface\",\n            \"have_return\": true,\n            \"code_content\": \"    def user_is_valid(cls, db: Session,\\n                      user_id: str | None = None,\\n                      email: str | None = None,\\n                      token: str | None = None):\\n        \\\"\\\"\\\"\\n        user is valid?\\n        \\n        Args:\\n            db (Session): db session\\n            user_id (str | None, optional): user id. Defaults to None.\\n            email (str | None, optional): email. Defaults to None.\\n            token (str | None, optional): token. Defaults to None.\\n            \\n        Returns:\\n            Boolean: True or False\\n        \\\"\\\"\\\"\\n        if email == \\\"\\\":\\n            return False\\n        user = db.query(User).filter(User.user_id == user_id,\\n                                     User.token == token, User.deleted.is_(False)).first()\\n        if user is None:\\n            return False\\n        if token is None:\\n            if user.email == email and user.available:\\n                return True\\n        if user_id is not None:\\n            if user.user_id == user_id and user.token == token and user.available:\\n                return True\\n        if email is not None:\\n            if user.email == email and user.token == token and user.available:\\n                return True\\n        return False\\n\",\n            \"name_column\": 8\n        },\n        \"add_user\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"add_user\",\n            \"md_content\": \"\",\n            \"code_start_line\": 140,\n            \"code_end_line\": 145,\n            \"parent\": \"UserDBInterface\",\n            \"have_return\": false,\n            \"code_content\": \"    def add_user(cls, db: Session, user_dict: dict):\\n        \\\"\\\"\\\"\\n        add user\\n        \\\"\\\"\\\"\\n        db.add(User(**user_dict))\\n        db.commit()\\n\",\n            \"name_column\": 8\n        },\n        \"update_user\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"update_user\",\n            \"md_content\": \"\",\n            \"code_start_line\": 148,\n            \"code_end_line\": 160,\n            \"parent\": \"UserDBInterface\",\n            \"have_return\": false,\n            \"code_content\": \"    def update_user(cls, db: Session, user: XAgentUser):\\n        \\\"\\\"\\\"\\n        update user\\n        \\\"\\\"\\\"\\n        db_user = db.query(User).filter(\\n            User.user_id == user.user_id, User.deleted.is_(False)).first()\\n\\n        db_user.available = user.available\\n        db_user.email = user.email\\n        db_user.name = user.name\\n        db_user.token = user.token\\n        db_user.update_time = datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\")\\n        db.commit()\\n\",\n            \"name_column\": 8\n        }\n    },\n    \"XAgentServer/database/interface/interaction.py\": {\n        \"InteractionDBInterface\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"InteractionDBInterface\",\n            \"md_content\": \"\",\n            \"code_start_line\": 19,\n            \"code_end_line\": 559,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"class InteractionDBInterface(metaclass=abc.ABCMeta):\\n    \\\"\\\"\\\"Interaction DB Interface\\n    \\\"\\\"\\\"\\n\\n    @classmethod\\n    def search_many_interaction(cls, db: Session) -> list[InteractionBase]:\\n        \\\"\\\"\\\"search many interactions\\n\\n        Args:\\n            db (Session): db session\\n\\n        Returns:\\n            list[InteractionBase]: interaction list\\n        \\\"\\\"\\\"\\n        interactions = db.query(Interaction).all()\\n        return [InteractionBase.from_db(interaction) for interaction in interactions]\\n\\n    @classmethod\\n    def get_interaction(cls,\\n                        db: Session,\\n                        interaction_id: str) -> InteractionBase | None:\\n        \\\"\\\"\\\"get interaction by interaction_id\\n\\n        Args:\\n            db (Session): db session\\n            interaction_id (str): interaction id\\n\\n        Returns:\\n            InteractionBase | None: _description_\\n        \\\"\\\"\\\"\\n        interaction = db.query(Interaction).filter(\\n            Interaction.interaction_id == interaction_id,\\n            Interaction.is_deleted.is_not(True)).first()\\n        return InteractionBase.from_db(interaction) if interaction else None\\n\\n    @classmethod\\n    def get_ready_interaction(cls,\\n                              db: Session,\\n                              user_id: str) -> InteractionBase | None:\\n        \\\"\\\"\\\"get interaction by user_id\\n\\n        Args:\\n            db (Session): db session\\n            user_id (str): user id\\n\\n        Returns:\\n            InteractionBase | None: _description_\\n        \\\"\\\"\\\"\\n        interaction = db.query(Interaction).filter(\\n            Interaction.user_id == user_id,\\n            Interaction.status == 'ready').first()\\n        return InteractionBase.from_db(interaction) if interaction else None\\n\\n    @classmethod\\n    def create_interaction(cls,\\n                           db: Session,\\n                           base: InteractionBase) -> InteractionBase:\\n        \\\"\\\"\\\"\\n        create interaction\\n\\n        Args:\\n            db (Session): db session\\n            base (InteractionBase): interaction base\\n\\n        Returns:\\n            None\\n        \\\"\\\"\\\"\\n        db.add(Interaction(**base.to_dict()))\\n        db.commit()\\n        return None\\n\\n    @classmethod\\n    def add_parameter(cls,\\n                      db: Session,\\n                      parameter: InteractionParameter):\\n        \\\"\\\"\\\"\\n        add parameter for interaction\\n        \\\"\\\"\\\"\\n        db.add(Parameter(**parameter.to_dict()))\\n        db.commit()\\n\\n        return None\\n\\n    @classmethod\\n    def search_interaction_by_user_id(cls,\\n                                      db: Session,\\n                                      user_id: str,\\n                                      page_size: int = 20,\\n                                      page_num: int = 1) -> list[dict]:\\n        \\\"\\\"\\\"\\n        search interaction by user id\\n\\n        Args:\\n            db (Session): db session\\n            user_id (str): user id\\n            page_size (int, optional): page size. Defaults to 20.\\n            page_num (int, optional): page num. Defaults to 1.\\n\\n        Returns:\\n            list[dict]: interaction list\\n        \\\"\\\"\\\"\\n        total = db.query(func.count(Interaction.id)).filter(\\n            Interaction.user_id == user_id, Interaction.is_deleted.is_(False)).scalar()\\n\\n        interaction_list = db.query(Interaction).filter(\\n            Interaction.user_id == user_id,\\n            Interaction.is_deleted.is_(False),\\n            Interaction.status.in_([StatusEnum.FINISHED])).limit(\\n            page_size).offset((page_num - 1) * page_size).all()\\n        data = []\\n        for interaction in interaction_list:\\n            d_ = InteractionBase.from_db(interaction).to_dict(\\n                exclude=[\\\"recorder_root_dir\\\", \\\"is_deleted\\\"])\\n            parameter = cls.get_parameter(\\n                db=db, interaction_id=d_[\\\"interaction_id\\\"])\\n            d_[\\\"parameters\\\"] = [parameter[0]]\\n            data.append(d_)\\n        return {\\n            \\\"total\\\": total,\\n            \\\"rows\\\": data\\n        }\\n\\n    @classmethod\\n    def search_many_shared(cls,\\n                           db: Session,\\n                           page_size: int = 20,\\n                           page_index: int = 1) -> list[dict]:\\n        \\\"\\\"\\\"\\n        search many shared interactions from community\\n\\n        Args:\\n            db (Session): db session\\n            page_size (int, optional): page size. Defaults to 20.\\n            page_index (int, optional): page index. Defaults to 1.\\n\\n        Returns:\\n            list[dict]: interaction list\\n        \\\"\\\"\\\"\\n        total = db.query(func.count(SharedInteraction.id)).filter(\\n            SharedInteraction.is_deleted.is_(False),\\n            SharedInteraction.is_audit.is_(True)).scalar()\\n        interaction_list = db.query(SharedInteraction).filter(\\n            SharedInteraction.is_deleted.is_(False),\\n            SharedInteraction.is_audit.is_(True)).order_by(\\n            SharedInteraction.star.desc()).limit(page_size).offset(\\n                (page_index - 1) * page_size).all()\\n        data = []\\n        for interaction in interaction_list:\\n            d_ = SharedInteractionBase.from_db(interaction).to_dict(\\n                exclude=[\\\"record_dir\\\", \\\"is_deleted\\\"])\\n            parameter = cls.get_parameter(\\n                db=db, interaction_id=d_[\\\"interaction_id\\\"])\\n            d_[\\\"parameters\\\"] = parameter\\n            data.append(d_)\\n        return {\\n            \\\"total\\\": total,\\n            \\\"rows\\\": data\\n        }\\n\\n    @classmethod\\n    def get_shared_interaction(cls,\\n                               db: Session,\\n                               interaction_id: str) -> SharedInteractionBase | None:\\n        \\\"\\\"\\\"\\n        get shared interaction by interaction id\\n\\n        Args:\\n            db (Session): db session\\n            interaction_id (str): interaction id\\n\\n        Returns:\\n\\n            SharedInteractionBase | None: shared interaction\\n        \\\"\\\"\\\"\\n        interaction = db.query(SharedInteraction).filter(\\n            SharedInteraction.interaction_id == interaction_id, SharedInteraction.is_deleted.is_(False)).first()\\n        return SharedInteractionBase.from_db(interaction) if interaction else None\\n\\n    @classmethod\\n    def is_exist(cls,\\n                 db: Session,\\n                 interaction_id: str) -> bool:\\n        \\\"\\\"\\\"\\n        check interaction is exist or not\\n\\n        Args:\\n            db (Session): db session\\n            interaction_id (str): interaction id\\n\\n        Returns:\\n            bool: True or False\\n        \\\"\\\"\\\"\\n        interaction = db.query(Interaction).filter(\\n            Interaction.interaction_id == interaction_id,\\n            Interaction.is_deleted.is_(False)).first()\\n        return interaction is not None\\n\\n    @classmethod\\n    def update_interaction(cls, db: Session, base_data: dict):\\n        \\\"\\\"\\\"\\n        update interaction\\n\\n        Args:\\n            db (Session): db session\\n            base_data (dict): interaction data\\n\\n        Returns:\\n            None\\n        \\\"\\\"\\\"\\n        if \\\"interaction_id\\\" not in base_data:\\n            raise XAgentError(\\\"interaction_id is required\\\")\\n        interaction = db.query(Interaction).filter(\\n            Interaction.interaction_id == base_data[\\\"interaction_id\\\"]).first()\\n        if interaction is None:\\n            raise XAgentError(\\\"interaction is not exist\\\")\\n        for k, v in base_data.items():\\n            if k == \\\"interaction_id\\\":\\n                continue\\n            setattr(interaction, k, v)\\n        interaction.update_time = datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\")\\n        db.commit()\\n\\n    @classmethod\\n    def update_interaction_status(cls,\\n                                  db: Session,\\n                                  interaction_id: str,\\n                                  status: str,\\n                                  message: str,\\n                                  current_step: int):\\n        \\\"\\\"\\\"\\n        update interaction status\\n\\n        Args:\\n            db (Session): db session\\n            interaction_id (str): interaction id\\n            status (str): status\\n            message (str): message\\n            current_step (int): current step\\n\\n        Returns:\\n            None\\n        \\\"\\\"\\\"\\n        db_interaction = db.query(Interaction).filter(\\n            Interaction.interaction_id == interaction_id).first()\\n        if db_interaction is None:\\n            raise XAgentError(\\\"interaction is not exist\\\")\\n\\n        db_interaction.status = status\\n        db_interaction.message = message\\n        db_interaction.current_step = current_step\\n        db_interaction.update_time = datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\")\\n        db.commit()\\n\\n    @classmethod\\n    def update_interaction_parameter(cls,\\n                                     db: Session,\\n                                     interaction_id: str,\\n                                     parameter: InteractionParameter):\\n        \\\"\\\"\\\"\\n        update interaction parameter\\n\\n        Args:\\n            db (Session): db session\\n            interaction_id (str): interaction id\\n            parameter (InteractionParameter): parameter\\n\\n        Returns:\\n            None\\n        \\\"\\\"\\\"\\n        db_parameter = db.query(Parameter).filter(\\n            Parameter.interaction_id == interaction_id,\\n            Parameter.parameter_id == parameter.parameter_id).first()\\n\\n        if db_parameter is None:\\n            db.add(Parameter(**parameter.to_dict()))\\n        db.commit()\\n\\n    @classmethod\\n    def is_running(cls, db: Session, user_id: str):\\n        \\\"\\\"\\\"\\n        check user is only running one interaction\\n\\n        Args:\\n            db (Session): db session\\n            user_id (str): user id\\n\\n        Returns:    \\n            bool: True or False\\n        \\\"\\\"\\\"\\n        interaction = db.query(Interaction).filter(\\n            Interaction.user_id == user_id,\\n            Interaction.status.in_((\\\"running\\\", \\\"waiting\\\"))).first()\\n        return interaction is not None\\n\\n    @classmethod\\n    def get_parameter(cls, db: Session, interaction_id: str) -> list:\\n        \\\"\\\"\\\"\\n        get interaction running parameter\\n\\n        Args:\\n            db (Session): db session\\n            interaction_id (str): interaction id\\n\\n        Returns:\\n            list: parameter list\\n        \\\"\\\"\\\"\\n        raws = db.query(Raw).filter(\\n            Raw.interaction_id == interaction_id,\\n            Raw.is_human.is_(True),\\n            Raw.human_data.is_not(None)).order_by(Raw.step.asc()).all()\\n        return [raw.human_data for raw in raws]\\n\\n    @classmethod\\n    def delete_interaction(cls, db: Session, interaction_id: str):\\n        \\\"\\\"\\\"\\n        delete interaction\\n\\n        Args:\\n            db (Session): db session\\n            interaction_id (str): interaction id\\n\\n        Returns:\\n            None\\n\\n        Raises:\\n            XAgentError: interaction is not exist\\n        \\\"\\\"\\\"\\n        interaction = db.query(Interaction).filter(\\n            Interaction.interaction_id == interaction_id).first()\\n        if interaction is None:\\n            raise XAgentError(\\\"interaction is not exist\\\")\\n        interaction.is_deleted = True\\n        db.commit()\\n\\n    @classmethod\\n    def add_share(cls, db: Session, shared: SharedInteractionBase):\\n        \\\"\\\"\\\"add share interaction\\n\\n        Args:\\n            db (Session): db session\\n            shared (SharedInteractionBase): shared interaction from community\\n        \\\"\\\"\\\"\\n        db.add(SharedInteraction(**shared.to_dict()))\\n\\n    @classmethod\\n    def insert_raw(cls, db: Session, process: XAgentRaw):\\n        \\\"\\\"\\\"\\n        insert an interaction process for recording\\n\\n        Args:\\n            db (Session): db session\\n            process (XAgentRaw): interaction process\\n\\n        Returns:\\n            None\\n\\n        Raises:\\n            XAgentError: interaction is not exist\\n        \\\"\\\"\\\"\\n        interaction = db.query(Interaction).filter(\\n            process.interaction_id == process.interaction_id).first()\\n        exist_process = db.query(Raw).filter(\\n            Raw.interaction_id == process.interaction_id, Raw.is_deleted.is_(False)).order_by(Raw.step.desc()).first()\\n        if interaction is None:\\n            raise XAgentError(\\\"interaction is not exist\\\")\\n\\n        if exist_process is not None:\\n            process.step = exist_process.step + 1\\n        else:\\n            process.step = 0\\n\\n        db.add(Raw(**process.to_dict()))\\n        db.commit()\\n\\n    @classmethod\\n    def search_many_raws(cls, db: Session, interaction_id: str):\\n        \\\"\\\"\\\"search many raws\\n\\n        Args:\\n            db (Session): db session\\n            interaction_id (str): interaction id\\n\\n        Returns:\\n            list[XAgentRaw]: interaction process list\\n        \\\"\\\"\\\"\\n        processes = db.query(Raw).filter(\\n            Raw.interaction_id == interaction_id, Raw.is_deleted.is_(False)).order_by(Raw.step.asc()).all()\\n        return processes\\n\\n    @classmethod\\n    def get_raw(cls, db: Session, interaction_id: str, node_id: str):\\n        \\\"\\\"\\\"\\n        get raw by interaction id and node id\\n        \\\"\\\"\\\"\\n        process = db.query(Raw).filter(\\n            Raw.interaction_id == interaction_id, Raw.node_id == node_id, Raw.is_deleted.is_(False)).first()\\n        return process\\n\\n    @classmethod\\n    def get_next_send(cls, db: Session, interaction_id: str):\\n        \\\"\\\"\\\"\\n        get next send process\\n\\n        Args:\\n            db (Session): db session\\n            interaction_id (str): interaction id\\n\\n        Returns:\\n            XAgentRaw: interaction process\\n        \\\"\\\"\\\"\\n        processes = db.query(Raw).filter(Raw.interaction_id == interaction_id,\\n                                         Raw.is_send.is_(False),\\n                                         Raw.is_deleted.is_(False)).order_by(Raw.step.desc()).all()\\n        return processes\\n\\n    @classmethod\\n    def update_send_flag(cls, db: Session, interaction_id: str, node_id: str):\\n        \\\"\\\"\\\"\\n        update send flag, if send success, update flag\\n        if send flag is True, it means that the process has been sent\\n        and no longer needs to be sent\\n\\n        Args:\\n            db (Session): db session\\n            interaction_id (str): interaction id\\n            node_id (str): node id\\n\\n        Returns:\\n            None\\n\\n        Raises:\\n            XAgentError: process is not exist\\n        \\\"\\\"\\\"\\n        process = db.query(Raw).filter(\\n            Raw.interaction_id == interaction_id, Raw.node_id == node_id).first()\\n        if process is None:\\n            raise XAgentError(\\\"process is not exist\\\")\\n        process.is_send = True\\n        process.update_time = datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\")\\n        db.commit()\\n\\n    @classmethod\\n    def update_receive_flag(cls, db: Session, interaction_id: str, node_id: str):\\n        \\\"\\\"\\\"\\n        update receive flag, if receive success, update flag\\n        if this flag is True, it means that the process has been received from human\\n\\n        Args:\\n            db (Session): db session\\n            interaction_id (str): interaction id\\n            node_id (str): node id\\n\\n        Returns:\\n            None\\n\\n        Raises:\\n            XAgentError: process is not exist\\n        \\\"\\\"\\\"\\n        process = db.query(Raw).filter(\\n            Raw.interaction_id == interaction_id, Raw.node_id == node_id).first()\\n        if process is None:\\n            raise XAgentError(\\\"process is not exist\\\")\\n        process.is_receive = True\\n        process.update_time = datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\")\\n        db.commit()\\n\\n    @classmethod\\n    def update_human_data(cls, db: Session, interaction_id: str, node_id: str, human_data: dict):\\n        \\\"\\\"\\\"\\n        update human data\\n\\n        Args:\\n            db (Session): db session\\n            interaction_id (str): interaction id\\n            node_id (str): node id\\n            human_data (dict): human data\\n\\n        Returns:\\n            None\\n\\n        Raises:\\n            XAgentError: process is not exist\\n        \\\"\\\"\\\"\\n        process = db.query(Raw).filter(\\n            Raw.interaction_id == interaction_id, Raw.node_id == node_id, Raw.is_deleted.is_(False)).first()\\n        if process is None:\\n            raise XAgentError(\\\"process is not exist\\\")\\n        process.is_receive = True\\n        process.is_human = True\\n        process.human_data = human_data\\n        db.commit()\\n\\n    @classmethod\\n    def insert_error(cls, db: Session, interaction_id: str, message: str):\\n        \\\"\\\"\\\"\\n        if interaction is failed, insert error message\\n        this message will be displayed in the interaction list\\n\\n        Args:\\n            db (Session): db session\\n            interaction_id (str): interaction id\\n            message (str): error message\\n\\n        Returns:\\n            None\\n\\n        Raises:\\n            None\\n\\n        \\\"\\\"\\\"\\n        process = Raw(\\n            node_id=uuid.uuid4().hex,\\n            interaction_id=interaction_id,\\n            current=\\\"\\\",\\n            step=0,\\n            data=message,\\n            file_list=[],\\n            status=StatusEnum.FAILED,\\n            create_time=datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\"),\\n            update_time=datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\")\\n        )\\n        db.add(process)\\n        db.commit()\\n\\n    @classmethod\\n    def get_finish_status(cls, db: Session, interaction_id: str):\\n        \\\"\\\"\\\"\\n        get interaction finish status\\n\\n        Args:\\n            db (Session): db session\\n            interaction_id (str): interaction id\\n\\n        Returns:\\n            Boolean: True or False\\n        \\\"\\\"\\\"\\n        process = db.query(Raw).filter(\\n            Raw.interaction_id == interaction_id,\\n            Raw.is_deleted.is_(False),\\n            Raw.status == \\\"finished\\\").first()\\n        return process is not None\\n\",\n            \"name_column\": 6\n        },\n        \"search_many_interaction\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"search_many_interaction\",\n            \"md_content\": \"\",\n            \"code_start_line\": 24,\n            \"code_end_line\": 34,\n            \"parent\": \"InteractionDBInterface\",\n            \"have_return\": true,\n            \"code_content\": \"    def search_many_interaction(cls, db: Session) -> list[InteractionBase]:\\n        \\\"\\\"\\\"search many interactions\\n\\n        Args:\\n            db (Session): db session\\n\\n        Returns:\\n            list[InteractionBase]: interaction list\\n        \\\"\\\"\\\"\\n        interactions = db.query(Interaction).all()\\n        return [InteractionBase.from_db(interaction) for interaction in interactions]\\n\",\n            \"name_column\": 8\n        },\n        \"get_interaction\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"get_interaction\",\n            \"md_content\": \"\",\n            \"code_start_line\": 37,\n            \"code_end_line\": 52,\n            \"parent\": \"InteractionDBInterface\",\n            \"have_return\": true,\n            \"code_content\": \"    def get_interaction(cls,\\n                        db: Session,\\n                        interaction_id: str) -> InteractionBase | None:\\n        \\\"\\\"\\\"get interaction by interaction_id\\n\\n        Args:\\n            db (Session): db session\\n            interaction_id (str): interaction id\\n\\n        Returns:\\n            InteractionBase | None: _description_\\n        \\\"\\\"\\\"\\n        interaction = db.query(Interaction).filter(\\n            Interaction.interaction_id == interaction_id,\\n            Interaction.is_deleted.is_not(True)).first()\\n        return InteractionBase.from_db(interaction) if interaction else None\\n\",\n            \"name_column\": 8\n        },\n        \"get_ready_interaction\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"get_ready_interaction\",\n            \"md_content\": \"\",\n            \"code_start_line\": 55,\n            \"code_end_line\": 70,\n            \"parent\": \"InteractionDBInterface\",\n            \"have_return\": true,\n            \"code_content\": \"    def get_ready_interaction(cls,\\n                              db: Session,\\n                              user_id: str) -> InteractionBase | None:\\n        \\\"\\\"\\\"get interaction by user_id\\n\\n        Args:\\n            db (Session): db session\\n            user_id (str): user id\\n\\n        Returns:\\n            InteractionBase | None: _description_\\n        \\\"\\\"\\\"\\n        interaction = db.query(Interaction).filter(\\n            Interaction.user_id == user_id,\\n            Interaction.status == 'ready').first()\\n        return InteractionBase.from_db(interaction) if interaction else None\\n\",\n            \"name_column\": 8\n        },\n        \"create_interaction\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"create_interaction\",\n            \"md_content\": \"\",\n            \"code_start_line\": 73,\n            \"code_end_line\": 88,\n            \"parent\": \"InteractionDBInterface\",\n            \"have_return\": true,\n            \"code_content\": \"    def create_interaction(cls,\\n                           db: Session,\\n                           base: InteractionBase) -> InteractionBase:\\n        \\\"\\\"\\\"\\n        create interaction\\n\\n        Args:\\n            db (Session): db session\\n            base (InteractionBase): interaction base\\n\\n        Returns:\\n            None\\n        \\\"\\\"\\\"\\n        db.add(Interaction(**base.to_dict()))\\n        db.commit()\\n        return None\\n\",\n            \"name_column\": 8\n        },\n        \"add_parameter\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"add_parameter\",\n            \"md_content\": \"\",\n            \"code_start_line\": 91,\n            \"code_end_line\": 100,\n            \"parent\": \"InteractionDBInterface\",\n            \"have_return\": true,\n            \"code_content\": \"    def add_parameter(cls,\\n                      db: Session,\\n                      parameter: InteractionParameter):\\n        \\\"\\\"\\\"\\n        add parameter for interaction\\n        \\\"\\\"\\\"\\n        db.add(Parameter(**parameter.to_dict()))\\n        db.commit()\\n\\n        return None\\n\",\n            \"name_column\": 8\n        },\n        \"search_interaction_by_user_id\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"search_interaction_by_user_id\",\n            \"md_content\": \"\",\n            \"code_start_line\": 103,\n            \"code_end_line\": 139,\n            \"parent\": \"InteractionDBInterface\",\n            \"have_return\": true,\n            \"code_content\": \"    def search_interaction_by_user_id(cls,\\n                                      db: Session,\\n                                      user_id: str,\\n                                      page_size: int = 20,\\n                                      page_num: int = 1) -> list[dict]:\\n        \\\"\\\"\\\"\\n        search interaction by user id\\n\\n        Args:\\n            db (Session): db session\\n            user_id (str): user id\\n            page_size (int, optional): page size. Defaults to 20.\\n            page_num (int, optional): page num. Defaults to 1.\\n\\n        Returns:\\n            list[dict]: interaction list\\n        \\\"\\\"\\\"\\n        total = db.query(func.count(Interaction.id)).filter(\\n            Interaction.user_id == user_id, Interaction.is_deleted.is_(False)).scalar()\\n\\n        interaction_list = db.query(Interaction).filter(\\n            Interaction.user_id == user_id,\\n            Interaction.is_deleted.is_(False),\\n            Interaction.status.in_([StatusEnum.FINISHED])).limit(\\n            page_size).offset((page_num - 1) * page_size).all()\\n        data = []\\n        for interaction in interaction_list:\\n            d_ = InteractionBase.from_db(interaction).to_dict(\\n                exclude=[\\\"recorder_root_dir\\\", \\\"is_deleted\\\"])\\n            parameter = cls.get_parameter(\\n                db=db, interaction_id=d_[\\\"interaction_id\\\"])\\n            d_[\\\"parameters\\\"] = [parameter[0]]\\n            data.append(d_)\\n        return {\\n            \\\"total\\\": total,\\n            \\\"rows\\\": data\\n        }\\n\",\n            \"name_column\": 8\n        },\n        \"search_many_shared\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"search_many_shared\",\n            \"md_content\": \"\",\n            \"code_start_line\": 142,\n            \"code_end_line\": 176,\n            \"parent\": \"InteractionDBInterface\",\n            \"have_return\": true,\n            \"code_content\": \"    def search_many_shared(cls,\\n                           db: Session,\\n                           page_size: int = 20,\\n                           page_index: int = 1) -> list[dict]:\\n        \\\"\\\"\\\"\\n        search many shared interactions from community\\n\\n        Args:\\n            db (Session): db session\\n            page_size (int, optional): page size. Defaults to 20.\\n            page_index (int, optional): page index. Defaults to 1.\\n\\n        Returns:\\n            list[dict]: interaction list\\n        \\\"\\\"\\\"\\n        total = db.query(func.count(SharedInteraction.id)).filter(\\n            SharedInteraction.is_deleted.is_(False),\\n            SharedInteraction.is_audit.is_(True)).scalar()\\n        interaction_list = db.query(SharedInteraction).filter(\\n            SharedInteraction.is_deleted.is_(False),\\n            SharedInteraction.is_audit.is_(True)).order_by(\\n            SharedInteraction.star.desc()).limit(page_size).offset(\\n                (page_index - 1) * page_size).all()\\n        data = []\\n        for interaction in interaction_list:\\n            d_ = SharedInteractionBase.from_db(interaction).to_dict(\\n                exclude=[\\\"record_dir\\\", \\\"is_deleted\\\"])\\n            parameter = cls.get_parameter(\\n                db=db, interaction_id=d_[\\\"interaction_id\\\"])\\n            d_[\\\"parameters\\\"] = parameter\\n            data.append(d_)\\n        return {\\n            \\\"total\\\": total,\\n            \\\"rows\\\": data\\n        }\\n\",\n            \"name_column\": 8\n        },\n        \"get_shared_interaction\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"get_shared_interaction\",\n            \"md_content\": \"\",\n            \"code_start_line\": 179,\n            \"code_end_line\": 195,\n            \"parent\": \"InteractionDBInterface\",\n            \"have_return\": true,\n            \"code_content\": \"    def get_shared_interaction(cls,\\n                               db: Session,\\n                               interaction_id: str) -> SharedInteractionBase | None:\\n        \\\"\\\"\\\"\\n        get shared interaction by interaction id\\n\\n        Args:\\n            db (Session): db session\\n            interaction_id (str): interaction id\\n\\n        Returns:\\n\\n            SharedInteractionBase | None: shared interaction\\n        \\\"\\\"\\\"\\n        interaction = db.query(SharedInteraction).filter(\\n            SharedInteraction.interaction_id == interaction_id, SharedInteraction.is_deleted.is_(False)).first()\\n        return SharedInteractionBase.from_db(interaction) if interaction else None\\n\",\n            \"name_column\": 8\n        },\n        \"is_exist\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"is_exist\",\n            \"md_content\": \"\",\n            \"code_start_line\": 198,\n            \"code_end_line\": 214,\n            \"parent\": \"InteractionDBInterface\",\n            \"have_return\": true,\n            \"code_content\": \"    def is_exist(cls,\\n                 db: Session,\\n                 interaction_id: str) -> bool:\\n        \\\"\\\"\\\"\\n        check interaction is exist or not\\n\\n        Args:\\n            db (Session): db session\\n            interaction_id (str): interaction id\\n\\n        Returns:\\n            bool: True or False\\n        \\\"\\\"\\\"\\n        interaction = db.query(Interaction).filter(\\n            Interaction.interaction_id == interaction_id,\\n            Interaction.is_deleted.is_(False)).first()\\n        return interaction is not None\\n\",\n            \"name_column\": 8\n        },\n        \"update_interaction\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"update_interaction\",\n            \"md_content\": \"\",\n            \"code_start_line\": 217,\n            \"code_end_line\": 239,\n            \"parent\": \"InteractionDBInterface\",\n            \"have_return\": false,\n            \"code_content\": \"    def update_interaction(cls, db: Session, base_data: dict):\\n        \\\"\\\"\\\"\\n        update interaction\\n\\n        Args:\\n            db (Session): db session\\n            base_data (dict): interaction data\\n\\n        Returns:\\n            None\\n        \\\"\\\"\\\"\\n        if \\\"interaction_id\\\" not in base_data:\\n            raise XAgentError(\\\"interaction_id is required\\\")\\n        interaction = db.query(Interaction).filter(\\n            Interaction.interaction_id == base_data[\\\"interaction_id\\\"]).first()\\n        if interaction is None:\\n            raise XAgentError(\\\"interaction is not exist\\\")\\n        for k, v in base_data.items():\\n            if k == \\\"interaction_id\\\":\\n                continue\\n            setattr(interaction, k, v)\\n        interaction.update_time = datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\")\\n        db.commit()\\n\",\n            \"name_column\": 8\n        },\n        \"update_interaction_status\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"update_interaction_status\",\n            \"md_content\": \"\",\n            \"code_start_line\": 242,\n            \"code_end_line\": 270,\n            \"parent\": \"InteractionDBInterface\",\n            \"have_return\": false,\n            \"code_content\": \"    def update_interaction_status(cls,\\n                                  db: Session,\\n                                  interaction_id: str,\\n                                  status: str,\\n                                  message: str,\\n                                  current_step: int):\\n        \\\"\\\"\\\"\\n        update interaction status\\n\\n        Args:\\n            db (Session): db session\\n            interaction_id (str): interaction id\\n            status (str): status\\n            message (str): message\\n            current_step (int): current step\\n\\n        Returns:\\n            None\\n        \\\"\\\"\\\"\\n        db_interaction = db.query(Interaction).filter(\\n            Interaction.interaction_id == interaction_id).first()\\n        if db_interaction is None:\\n            raise XAgentError(\\\"interaction is not exist\\\")\\n\\n        db_interaction.status = status\\n        db_interaction.message = message\\n        db_interaction.current_step = current_step\\n        db_interaction.update_time = datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\")\\n        db.commit()\\n\",\n            \"name_column\": 8\n        },\n        \"update_interaction_parameter\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"update_interaction_parameter\",\n            \"md_content\": \"\",\n            \"code_start_line\": 273,\n            \"code_end_line\": 294,\n            \"parent\": \"InteractionDBInterface\",\n            \"have_return\": false,\n            \"code_content\": \"    def update_interaction_parameter(cls,\\n                                     db: Session,\\n                                     interaction_id: str,\\n                                     parameter: InteractionParameter):\\n        \\\"\\\"\\\"\\n        update interaction parameter\\n\\n        Args:\\n            db (Session): db session\\n            interaction_id (str): interaction id\\n            parameter (InteractionParameter): parameter\\n\\n        Returns:\\n            None\\n        \\\"\\\"\\\"\\n        db_parameter = db.query(Parameter).filter(\\n            Parameter.interaction_id == interaction_id,\\n            Parameter.parameter_id == parameter.parameter_id).first()\\n\\n        if db_parameter is None:\\n            db.add(Parameter(**parameter.to_dict()))\\n        db.commit()\\n\",\n            \"name_column\": 8\n        },\n        \"is_running\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"is_running\",\n            \"md_content\": \"\",\n            \"code_start_line\": 297,\n            \"code_end_line\": 311,\n            \"parent\": \"InteractionDBInterface\",\n            \"have_return\": true,\n            \"code_content\": \"    def is_running(cls, db: Session, user_id: str):\\n        \\\"\\\"\\\"\\n        check user is only running one interaction\\n\\n        Args:\\n            db (Session): db session\\n            user_id (str): user id\\n\\n        Returns:    \\n            bool: True or False\\n        \\\"\\\"\\\"\\n        interaction = db.query(Interaction).filter(\\n            Interaction.user_id == user_id,\\n            Interaction.status.in_((\\\"running\\\", \\\"waiting\\\"))).first()\\n        return interaction is not None\\n\",\n            \"name_column\": 8\n        },\n        \"get_parameter\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"get_parameter\",\n            \"md_content\": \"\",\n            \"code_start_line\": 314,\n            \"code_end_line\": 329,\n            \"parent\": \"InteractionDBInterface\",\n            \"have_return\": true,\n            \"code_content\": \"    def get_parameter(cls, db: Session, interaction_id: str) -> list:\\n        \\\"\\\"\\\"\\n        get interaction running parameter\\n\\n        Args:\\n            db (Session): db session\\n            interaction_id (str): interaction id\\n\\n        Returns:\\n            list: parameter list\\n        \\\"\\\"\\\"\\n        raws = db.query(Raw).filter(\\n            Raw.interaction_id == interaction_id,\\n            Raw.is_human.is_(True),\\n            Raw.human_data.is_not(None)).order_by(Raw.step.asc()).all()\\n        return [raw.human_data for raw in raws]\\n\",\n            \"name_column\": 8\n        },\n        \"delete_interaction\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"delete_interaction\",\n            \"md_content\": \"\",\n            \"code_start_line\": 332,\n            \"code_end_line\": 351,\n            \"parent\": \"InteractionDBInterface\",\n            \"have_return\": false,\n            \"code_content\": \"    def delete_interaction(cls, db: Session, interaction_id: str):\\n        \\\"\\\"\\\"\\n        delete interaction\\n\\n        Args:\\n            db (Session): db session\\n            interaction_id (str): interaction id\\n\\n        Returns:\\n            None\\n\\n        Raises:\\n            XAgentError: interaction is not exist\\n        \\\"\\\"\\\"\\n        interaction = db.query(Interaction).filter(\\n            Interaction.interaction_id == interaction_id).first()\\n        if interaction is None:\\n            raise XAgentError(\\\"interaction is not exist\\\")\\n        interaction.is_deleted = True\\n        db.commit()\\n\",\n            \"name_column\": 8\n        },\n        \"add_share\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"add_share\",\n            \"md_content\": \"\",\n            \"code_start_line\": 354,\n            \"code_end_line\": 361,\n            \"parent\": \"InteractionDBInterface\",\n            \"have_return\": false,\n            \"code_content\": \"    def add_share(cls, db: Session, shared: SharedInteractionBase):\\n        \\\"\\\"\\\"add share interaction\\n\\n        Args:\\n            db (Session): db session\\n            shared (SharedInteractionBase): shared interaction from community\\n        \\\"\\\"\\\"\\n        db.add(SharedInteraction(**shared.to_dict()))\\n\",\n            \"name_column\": 8\n        },\n        \"insert_raw\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"insert_raw\",\n            \"md_content\": \"\",\n            \"code_start_line\": 364,\n            \"code_end_line\": 391,\n            \"parent\": \"InteractionDBInterface\",\n            \"have_return\": false,\n            \"code_content\": \"    def insert_raw(cls, db: Session, process: XAgentRaw):\\n        \\\"\\\"\\\"\\n        insert an interaction process for recording\\n\\n        Args:\\n            db (Session): db session\\n            process (XAgentRaw): interaction process\\n\\n        Returns:\\n            None\\n\\n        Raises:\\n            XAgentError: interaction is not exist\\n        \\\"\\\"\\\"\\n        interaction = db.query(Interaction).filter(\\n            process.interaction_id == process.interaction_id).first()\\n        exist_process = db.query(Raw).filter(\\n            Raw.interaction_id == process.interaction_id, Raw.is_deleted.is_(False)).order_by(Raw.step.desc()).first()\\n        if interaction is None:\\n            raise XAgentError(\\\"interaction is not exist\\\")\\n\\n        if exist_process is not None:\\n            process.step = exist_process.step + 1\\n        else:\\n            process.step = 0\\n\\n        db.add(Raw(**process.to_dict()))\\n        db.commit()\\n\",\n            \"name_column\": 8\n        },\n        \"search_many_raws\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"search_many_raws\",\n            \"md_content\": \"\",\n            \"code_start_line\": 394,\n            \"code_end_line\": 406,\n            \"parent\": \"InteractionDBInterface\",\n            \"have_return\": true,\n            \"code_content\": \"    def search_many_raws(cls, db: Session, interaction_id: str):\\n        \\\"\\\"\\\"search many raws\\n\\n        Args:\\n            db (Session): db session\\n            interaction_id (str): interaction id\\n\\n        Returns:\\n            list[XAgentRaw]: interaction process list\\n        \\\"\\\"\\\"\\n        processes = db.query(Raw).filter(\\n            Raw.interaction_id == interaction_id, Raw.is_deleted.is_(False)).order_by(Raw.step.asc()).all()\\n        return processes\\n\",\n            \"name_column\": 8\n        },\n        \"get_raw\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"get_raw\",\n            \"md_content\": \"\",\n            \"code_start_line\": 409,\n            \"code_end_line\": 415,\n            \"parent\": \"InteractionDBInterface\",\n            \"have_return\": true,\n            \"code_content\": \"    def get_raw(cls, db: Session, interaction_id: str, node_id: str):\\n        \\\"\\\"\\\"\\n        get raw by interaction id and node id\\n        \\\"\\\"\\\"\\n        process = db.query(Raw).filter(\\n            Raw.interaction_id == interaction_id, Raw.node_id == node_id, Raw.is_deleted.is_(False)).first()\\n        return process\\n\",\n            \"name_column\": 8\n        },\n        \"get_next_send\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"get_next_send\",\n            \"md_content\": \"\",\n            \"code_start_line\": 418,\n            \"code_end_line\": 432,\n            \"parent\": \"InteractionDBInterface\",\n            \"have_return\": true,\n            \"code_content\": \"    def get_next_send(cls, db: Session, interaction_id: str):\\n        \\\"\\\"\\\"\\n        get next send process\\n\\n        Args:\\n            db (Session): db session\\n            interaction_id (str): interaction id\\n\\n        Returns:\\n            XAgentRaw: interaction process\\n        \\\"\\\"\\\"\\n        processes = db.query(Raw).filter(Raw.interaction_id == interaction_id,\\n                                         Raw.is_send.is_(False),\\n                                         Raw.is_deleted.is_(False)).order_by(Raw.step.desc()).all()\\n        return processes\\n\",\n            \"name_column\": 8\n        },\n        \"update_send_flag\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"update_send_flag\",\n            \"md_content\": \"\",\n            \"code_start_line\": 435,\n            \"code_end_line\": 458,\n            \"parent\": \"InteractionDBInterface\",\n            \"have_return\": false,\n            \"code_content\": \"    def update_send_flag(cls, db: Session, interaction_id: str, node_id: str):\\n        \\\"\\\"\\\"\\n        update send flag, if send success, update flag\\n        if send flag is True, it means that the process has been sent\\n        and no longer needs to be sent\\n\\n        Args:\\n            db (Session): db session\\n            interaction_id (str): interaction id\\n            node_id (str): node id\\n\\n        Returns:\\n            None\\n\\n        Raises:\\n            XAgentError: process is not exist\\n        \\\"\\\"\\\"\\n        process = db.query(Raw).filter(\\n            Raw.interaction_id == interaction_id, Raw.node_id == node_id).first()\\n        if process is None:\\n            raise XAgentError(\\\"process is not exist\\\")\\n        process.is_send = True\\n        process.update_time = datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\")\\n        db.commit()\\n\",\n            \"name_column\": 8\n        },\n        \"update_receive_flag\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"update_receive_flag\",\n            \"md_content\": \"\",\n            \"code_start_line\": 461,\n            \"code_end_line\": 483,\n            \"parent\": \"InteractionDBInterface\",\n            \"have_return\": false,\n            \"code_content\": \"    def update_receive_flag(cls, db: Session, interaction_id: str, node_id: str):\\n        \\\"\\\"\\\"\\n        update receive flag, if receive success, update flag\\n        if this flag is True, it means that the process has been received from human\\n\\n        Args:\\n            db (Session): db session\\n            interaction_id (str): interaction id\\n            node_id (str): node id\\n\\n        Returns:\\n            None\\n\\n        Raises:\\n            XAgentError: process is not exist\\n        \\\"\\\"\\\"\\n        process = db.query(Raw).filter(\\n            Raw.interaction_id == interaction_id, Raw.node_id == node_id).first()\\n        if process is None:\\n            raise XAgentError(\\\"process is not exist\\\")\\n        process.is_receive = True\\n        process.update_time = datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\")\\n        db.commit()\\n\",\n            \"name_column\": 8\n        },\n        \"update_human_data\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"update_human_data\",\n            \"md_content\": \"\",\n            \"code_start_line\": 486,\n            \"code_end_line\": 509,\n            \"parent\": \"InteractionDBInterface\",\n            \"have_return\": false,\n            \"code_content\": \"    def update_human_data(cls, db: Session, interaction_id: str, node_id: str, human_data: dict):\\n        \\\"\\\"\\\"\\n        update human data\\n\\n        Args:\\n            db (Session): db session\\n            interaction_id (str): interaction id\\n            node_id (str): node id\\n            human_data (dict): human data\\n\\n        Returns:\\n            None\\n\\n        Raises:\\n            XAgentError: process is not exist\\n        \\\"\\\"\\\"\\n        process = db.query(Raw).filter(\\n            Raw.interaction_id == interaction_id, Raw.node_id == node_id, Raw.is_deleted.is_(False)).first()\\n        if process is None:\\n            raise XAgentError(\\\"process is not exist\\\")\\n        process.is_receive = True\\n        process.is_human = True\\n        process.human_data = human_data\\n        db.commit()\\n\",\n            \"name_column\": 8\n        },\n        \"insert_error\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"insert_error\",\n            \"md_content\": \"\",\n            \"code_start_line\": 512,\n            \"code_end_line\": 541,\n            \"parent\": \"InteractionDBInterface\",\n            \"have_return\": false,\n            \"code_content\": \"    def insert_error(cls, db: Session, interaction_id: str, message: str):\\n        \\\"\\\"\\\"\\n        if interaction is failed, insert error message\\n        this message will be displayed in the interaction list\\n\\n        Args:\\n            db (Session): db session\\n            interaction_id (str): interaction id\\n            message (str): error message\\n\\n        Returns:\\n            None\\n\\n        Raises:\\n            None\\n\\n        \\\"\\\"\\\"\\n        process = Raw(\\n            node_id=uuid.uuid4().hex,\\n            interaction_id=interaction_id,\\n            current=\\\"\\\",\\n            step=0,\\n            data=message,\\n            file_list=[],\\n            status=StatusEnum.FAILED,\\n            create_time=datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\"),\\n            update_time=datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\")\\n        )\\n        db.add(process)\\n        db.commit()\\n\",\n            \"name_column\": 8\n        },\n        \"get_finish_status\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"get_finish_status\",\n            \"md_content\": \"\",\n            \"code_start_line\": 544,\n            \"code_end_line\": 559,\n            \"parent\": \"InteractionDBInterface\",\n            \"have_return\": true,\n            \"code_content\": \"    def get_finish_status(cls, db: Session, interaction_id: str):\\n        \\\"\\\"\\\"\\n        get interaction finish status\\n\\n        Args:\\n            db (Session): db session\\n            interaction_id (str): interaction id\\n\\n        Returns:\\n            Boolean: True or False\\n        \\\"\\\"\\\"\\n        process = db.query(Raw).filter(\\n            Raw.interaction_id == interaction_id,\\n            Raw.is_deleted.is_(False),\\n            Raw.status == \\\"finished\\\").first()\\n        return process is not None\\n\",\n            \"name_column\": 8\n        }\n    },\n    \"XAgentServer/database/interface/recorder.py\": {\n        \"RecordDBInterface\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"RecordDBInterface\",\n            \"md_content\": \"\",\n            \"code_start_line\": 10,\n            \"code_end_line\": 99,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"class RecordDBInterface(metaclass=abc.ABCMeta):\\n    \\\"\\\"\\\"Recorder DB Interface\\n\\n    Args:\\n        RecorderBaseInterface (_type_): _description_\\n        metaclass (_type_, optional): _description_. Defaults to abc.ABCMeta.\\n    \\\"\\\"\\\"\\n\\n    @classmethod\\n    def get_record_list(cls, db: Session, record_id: str) -> list[XAgentRunningRecord]:\\n        \\\"\\\"\\\"get all records\\n\\n        Args:\\n            db (Session): db\\n\\n        Returns:\\n            list[XAgentRunningRecord]: Recorder list\\n        \\\"\\\"\\\"\\n        records = db.query(RunningRecord).filter(\\n            RunningRecord.record_id == record_id).all()\\n        return [XAgentRunningRecord.from_db(Recorder) for Recorder in records]\\n\\n    @classmethod\\n    def get_record(cls,\\n                     db: Session,\\n                     record_id: str | None = None\\n                     ) -> XAgentRunningRecord | None:\\n        \\\"\\\"\\\"get Recorder by Recorder_id or email\\n\\n        Args:\\n            db (Session): db\\n            Recorder_id (str | None, optional): Recorder id. Defaults to None.\\n            email (str | None, optional): email. Defaults to None.\\n\\n        Returns:\\n            XAgentRunningRecord | None: Recorder, if Recorder is not exist, return None\\n        \\\"\\\"\\\"\\n        record = db.query(RunningRecord).filter(RunningRecord.record_id == record_id,\\n                                                  RunningRecord.deleted.is_(False)).first()\\n\\n        return XAgentRunningRecord.from_db(record) if record else None\\n\\n    @classmethod\\n    def insert_record(cls,\\n                      db: Session,\\n                      record: XAgentRunningRecord):\\n        \\\"\\\"\\\"insert Recorder\\n\\n        Args:\\n            db (Session): db\\n            record (XAgentRunningRecord): Recorder\\n        \\\"\\\"\\\"\\n        db_record = RunningRecord(**record.to_dict())\\n        db.add(db_record)\\n        db.commit()\\n        db.refresh(db_record)\\n        return db_record\\n    \\n    @classmethod\\n    def get_record_by_type(cls,\\n                           db: Session,\\n                           record_id: str,\\n                           node_id: str = \\\"\\\",\\n                           node_type: str = \\\"\\\") -> list[XAgentRunningRecord]:\\n        \\\"\\\"\\\"get Recorder by type\\n\\n        Args:\\n            db (Session): db\\n            record_id (str): record id\\n            node_id (str): node id\\n            node_type (str): node type\\n\\n        Returns:\\n            list[XAgentRunningRecord]: Recorder list\\n        \\\"\\\"\\\"\\n\\n        filters = [RunningRecord.deleted.is_(False)]\\n\\n        if record_id:\\n            filters.append(RunningRecord.record_id == record_id)\\n\\n        if node_id:\\n            filters.append(RunningRecord.node_id == node_id)\\n\\n        if node_type:\\n            filters.append(RunningRecord.node_type == node_type)\\n\\n        records = db.query(RunningRecord).filter(*filters).all()\\n\\n        return [XAgentRunningRecord.from_db(Recorder) for Recorder in records]\\n\",\n            \"name_column\": 6\n        },\n        \"get_record_list\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"get_record_list\",\n            \"md_content\": \"\",\n            \"code_start_line\": 19,\n            \"code_end_line\": 30,\n            \"parent\": \"RecordDBInterface\",\n            \"have_return\": true,\n            \"code_content\": \"    def get_record_list(cls, db: Session, record_id: str) -> list[XAgentRunningRecord]:\\n        \\\"\\\"\\\"get all records\\n\\n        Args:\\n            db (Session): db\\n\\n        Returns:\\n            list[XAgentRunningRecord]: Recorder list\\n        \\\"\\\"\\\"\\n        records = db.query(RunningRecord).filter(\\n            RunningRecord.record_id == record_id).all()\\n        return [XAgentRunningRecord.from_db(Recorder) for Recorder in records]\\n\",\n            \"name_column\": 8\n        },\n        \"get_record\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"get_record\",\n            \"md_content\": \"\",\n            \"code_start_line\": 33,\n            \"code_end_line\": 50,\n            \"parent\": \"RecordDBInterface\",\n            \"have_return\": true,\n            \"code_content\": \"    def get_record(cls,\\n                     db: Session,\\n                     record_id: str | None = None\\n                     ) -> XAgentRunningRecord | None:\\n        \\\"\\\"\\\"get Recorder by Recorder_id or email\\n\\n        Args:\\n            db (Session): db\\n            Recorder_id (str | None, optional): Recorder id. Defaults to None.\\n            email (str | None, optional): email. Defaults to None.\\n\\n        Returns:\\n            XAgentRunningRecord | None: Recorder, if Recorder is not exist, return None\\n        \\\"\\\"\\\"\\n        record = db.query(RunningRecord).filter(RunningRecord.record_id == record_id,\\n                                                  RunningRecord.deleted.is_(False)).first()\\n\\n        return XAgentRunningRecord.from_db(record) if record else None\\n\",\n            \"name_column\": 8\n        },\n        \"insert_record\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"insert_record\",\n            \"md_content\": \"\",\n            \"code_start_line\": 53,\n            \"code_end_line\": 66,\n            \"parent\": \"RecordDBInterface\",\n            \"have_return\": true,\n            \"code_content\": \"    def insert_record(cls,\\n                      db: Session,\\n                      record: XAgentRunningRecord):\\n        \\\"\\\"\\\"insert Recorder\\n\\n        Args:\\n            db (Session): db\\n            record (XAgentRunningRecord): Recorder\\n        \\\"\\\"\\\"\\n        db_record = RunningRecord(**record.to_dict())\\n        db.add(db_record)\\n        db.commit()\\n        db.refresh(db_record)\\n        return db_record\\n\",\n            \"name_column\": 8\n        },\n        \"get_record_by_type\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"get_record_by_type\",\n            \"md_content\": \"\",\n            \"code_start_line\": 69,\n            \"code_end_line\": 99,\n            \"parent\": \"RecordDBInterface\",\n            \"have_return\": true,\n            \"code_content\": \"    def get_record_by_type(cls,\\n                           db: Session,\\n                           record_id: str,\\n                           node_id: str = \\\"\\\",\\n                           node_type: str = \\\"\\\") -> list[XAgentRunningRecord]:\\n        \\\"\\\"\\\"get Recorder by type\\n\\n        Args:\\n            db (Session): db\\n            record_id (str): record id\\n            node_id (str): node id\\n            node_type (str): node type\\n\\n        Returns:\\n            list[XAgentRunningRecord]: Recorder list\\n        \\\"\\\"\\\"\\n\\n        filters = [RunningRecord.deleted.is_(False)]\\n\\n        if record_id:\\n            filters.append(RunningRecord.record_id == record_id)\\n\\n        if node_id:\\n            filters.append(RunningRecord.node_id == node_id)\\n\\n        if node_type:\\n            filters.append(RunningRecord.node_type == node_type)\\n\\n        records = db.query(RunningRecord).filter(*filters).all()\\n\\n        return [XAgentRunningRecord.from_db(Recorder) for Recorder in records]\\n\",\n            \"name_column\": 8\n        }\n    },\n    \"XAgentServer/loggers/logs.py\": {\n        \"JsonFileHandler\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"JsonFileHandler\",\n            \"md_content\": \"\",\n            \"code_start_line\": 16,\n            \"code_end_line\": 24,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"class JsonFileHandler(logging.FileHandler):\\n    \\\"\\\"\\\"JsonFileHandler\\\"\\\"\\\"\\n    def __init__(self, filename, mode=\\\"a\\\", encoding=None, delay=False):\\n        super().__init__(filename, mode, encoding, delay)\\n\\n    def emit(self, record):\\n        json_data = json.loads(self.format(record))\\n        with open(self.baseFilename, \\\"w\\\", encoding=\\\"utf-8\\\") as f:\\n            json.dump(json_data, f, ensure_ascii=False, indent=4)\\n\",\n            \"name_column\": 6\n        },\n        \"JsonFormatter\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"JsonFormatter\",\n            \"md_content\": \"\",\n            \"code_start_line\": 27,\n            \"code_end_line\": 30,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"class JsonFormatter(logging.Formatter):\\n    \\\"\\\"\\\"Json Formatter\\\"\\\"\\\"\\n    def format(self, record):\\n        return record.msg\\n\",\n            \"name_column\": 6\n        },\n        \"Logger\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"Logger\",\n            \"md_content\": \"\",\n            \"code_start_line\": 33,\n            \"code_end_line\": 191,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"class Logger(metaclass=abc.ABCMeta):\\n    \\\"\\\"\\\"\\n    Logger that handle titles in different colors.\\n    Outputs logs in console, activity.log, and errors.log\\n    For console handler: simulates typing\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, log_dir: str = None, log_name: str= \\\"\\\", log_file: str = \\\"activity.log\\\", error_file: str = \\\"errors.log\\\"):\\n        \\\"\\\"\\\"init\\\"\\\"\\\"\\n        if not os.path.exists(log_dir):\\n            os.makedirs(log_dir)\\n\\n        # create log directory if it doesn't exist\\n        self.log_name = time.strftime(\\\"%Y-%m-%d\\\", time.localtime()) if not log_name else log_name\\n        self.logger = logging.getLogger(self.log_name)\\n        console_formatter = RecordFormatter(\\\"%(title_color)s %(message)s\\\")\\n\\n        # Create a handler for console which simulate typing\\n        self.typing_console_handler = TypingConsoleHandler()\\n        self.typing_console_handler.setLevel(logging.INFO)\\n        self.typing_console_handler.setFormatter(console_formatter)\\n\\n        # Create a handler for console without typing simulation\\n        self.console_handler = ConsoleHandler()\\n        self.console_handler.setLevel(logging.DEBUG)\\n        self.console_handler.setFormatter(console_formatter)\\n\\n        self.speak_mode = False\\n        self.chat_plugins = []\\n\\n        # Info handler in activity.log\\n        self.file_handler = logging.FileHandler(\\n            os.path.join(log_dir, log_file), \\\"a\\\", \\\"utf-8\\\"\\n        )\\n        self.file_handler.setLevel(logging.DEBUG)\\n        info_formatter = RecordFormatter(\\n            \\\"%(asctime)s [%(threadName)s] %(levelname)s: %(title_color)s %(title)s %(message)s\\\"\\n        )\\n        self.file_handler.setFormatter(info_formatter)\\n\\n        # Error handler error.log\\n        error_handler = logging.FileHandler(\\n            os.path.join(log_dir, error_file), \\\"a\\\", \\\"utf-8\\\"\\n        )\\n        error_handler.setLevel(logging.ERROR)\\n        error_formatter = RecordFormatter(\\n            \\\"%(asctime)s [%(threadName)s] %(levelname)s %(module)s:%(funcName)s:%(lineno)d %(title_color)s %(title)s\\\"\\n            \\\" %(message_no_color)s\\\"\\n        )\\n        error_handler.setFormatter(error_formatter)\\n\\n        # self.typing_logger = logging.getLogger(self.log_name)\\n        # if not self.typing_logger.handlers:\\n        #     self.typing_logger.addHandler(self.typing_console_handler)\\n        #     self.typing_logger.addHandler(self.file_handler)\\n        #     self.typing_logger.addHandler(error_handler)\\n        # self.typing_logger.setLevel(logging.DEBUG)\\n\\n        if self.log_name.endswith(\\\"_INTERACT\\\") or not self.logger.handlers:\\n            # self.logger.addHandler(self.typing_console_handler)\\n            self.logger.addHandler(self.console_handler)\\n            self.logger.addHandler(error_handler)\\n            self.logger.addHandler(self.file_handler)\\n            self.logger.setLevel(logging.DEBUG)\\n    \\n    def typewriter_log(\\n        self, title=\\\"\\\", title_color=\\\"\\\", content=\\\"\\\", speak_text=False, level=logging.INFO\\n    ):\\n        # if speak_text and self.speak_mode:\\n        #     say_text(f\\\"{title}. {content}\\\")\\n\\n        for plugin in self.chat_plugins:\\n            plugin.report(f\\\"{title}. {content}\\\")\\n\\n        if content:\\n            if isinstance(content, list):\\n                content = \\\" \\\".join(content)\\n        else:\\n            content = \\\"\\\"\\n\\n        self.logger.log(\\n            level, content, extra={\\\"title\\\": title, \\\"color\\\": title_color}\\n        )\\n\\n    def debug(\\n        self,\\n        message,\\n        title=\\\"\\\",\\n        title_color=\\\"\\\",\\n    ):\\n        self._log(title, title_color, message, logging.DEBUG)\\n\\n    def info(\\n        self,\\n        message,\\n        title=\\\"\\\",\\n        title_color=\\\"\\\",\\n    ):\\n        self._log(title, title_color, message, logging.INFO)\\n\\n    def warn(\\n        self,\\n        message,\\n        title=\\\"\\\",\\n        title_color=\\\"\\\",\\n    ):\\n        self._log(title, title_color, message, logging.WARN)\\n\\n    def error(self, title, message=\\\"\\\"):\\n        self._log(title, Fore.RED, message, logging.ERROR)\\n\\n    def _log(\\n        self,\\n        title: str = \\\"\\\",\\n        title_color: str = \\\"\\\",\\n        message: str = \\\"\\\",\\n        level=logging.INFO,\\n    ):\\n        if message:\\n            if isinstance(message, list):\\n                message = \\\" \\\".join(message)\\n        self.logger.log(\\n            level, message, extra={\\\"title\\\": str(title), \\\"color\\\": str(title_color)}\\n        )\\n\\n    def set_level(self, level):\\n        self.logger.setLevel(level)\\n        self.typing_logger.setLevel(level)\\n\\n    def double_check(self, additionalText=None):\\n        if not additionalText:\\n            additionalText = (\\n                \\\"Please ensure you've setup and configured everything\\\"\\n                \\\" correctly. Read https://github.com/Torantulino/Auto-GPT#readme to \\\"\\n                \\\"double check. You can also create a github issue or join the discord\\\"\\n                \\\" and ask there!\\\"\\n            )\\n\\n        self.typewriter_log(\\\"DOUBLE CHECK CONFIGURATION\\\", Fore.YELLOW, additionalText)\\n\\n    def log_json(self, data: Any, file_name: str) -> None:\\n        # Define log directory\\n        this_files_dir_path = os.path.dirname(__file__)\\n        log_dir = os.path.join(this_files_dir_path, \\\"../logs\\\")\\n\\n        # Create a handler for JSON files\\n        json_file_path = os.path.join(log_dir, file_name)\\n        json_data_handler = JsonFileHandler(json_file_path)\\n        json_data_handler.setFormatter(JsonFormatter())\\n\\n        # Log the JSON data using the custom file handler\\n        self.json_logger.addHandler(json_data_handler)\\n        self.json_logger.debug(data)\\n        self.json_logger.removeHandler(json_data_handler)\\n\\n    def get_log_directory(self):\\n        this_files_dir_path = os.path.dirname(__file__)\\n        log_dir = os.path.join(this_files_dir_path, \\\"../logs\\\")\\n        return os.path.abspath(log_dir)\\n\",\n            \"name_column\": 6\n        },\n        \"TypingConsoleHandler\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"TypingConsoleHandler\",\n            \"md_content\": \"\",\n            \"code_start_line\": 199,\n            \"code_end_line\": 218,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"class TypingConsoleHandler(logging.StreamHandler):\\n    def emit(self, record):\\n        min_typing_speed = 0.05\\n        max_typing_speed = 0.01\\n\\n        msg = self.format(record)\\n        try:\\n            words = msg.split()\\n            for i, word in enumerate(words):\\n                print(word, end=\\\"\\\", flush=True)\\n                if i < len(words) - 1:\\n                    print(\\\" \\\", end=\\\"\\\", flush=True)\\n                typing_speed = random.uniform(min_typing_speed, max_typing_speed)\\n                time.sleep(typing_speed)\\n                # type faster after each word\\n                min_typing_speed = min_typing_speed * 0.95\\n                max_typing_speed = max_typing_speed * 0.95\\n            print()\\n        except Exception:\\n            self.handleError(record)\\n\",\n            \"name_column\": 6\n        },\n        \"ConsoleHandler\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"ConsoleHandler\",\n            \"md_content\": \"\",\n            \"code_start_line\": 221,\n            \"code_end_line\": 227,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"class ConsoleHandler(logging.StreamHandler):\\n    def emit(self, record) -> None:\\n        msg = self.format(record)\\n        try:\\n            print(msg)\\n        except Exception:\\n            self.handleError(record)\\n\",\n            \"name_column\": 6\n        },\n        \"RecordFormatter\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"RecordFormatter\",\n            \"md_content\": \"\",\n            \"code_start_line\": 230,\n            \"code_end_line\": 254,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"class RecordFormatter(logging.Formatter):\\n    \\\"\\\"\\\"\\n    Allows to handle custom placeholders 'title_color' and 'message_no_color'.\\n    To use this formatter, make sure to pass 'color', 'title' as log extras.\\n    \\\"\\\"\\\"\\n\\n    def format(self, record: LogRecord) -> str:\\n        if hasattr(record, \\\"color\\\"):\\n            record.title_color = (\\n                getattr(record, \\\"color\\\")\\n                + getattr(record, \\\"title\\\", \\\"\\\")\\n                + \\\" \\\"\\n                + Style.RESET_ALL\\n            )\\n        else:\\n            record.title_color = getattr(record, \\\"title\\\", \\\"\\\")\\n\\n        # Add this line to set 'title' to an empty string if it doesn't exist\\n        record.title = getattr(record, \\\"title\\\", \\\"\\\")\\n\\n        if hasattr(record, \\\"msg\\\"):\\n            record.message_no_color = remove_color_codes(getattr(record, \\\"msg\\\"))\\n        else:\\n            record.message_no_color = \\\"\\\"\\n        return super().format(record)\\n\",\n            \"name_column\": 6\n        },\n        \"remove_color_codes\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"remove_color_codes\",\n            \"md_content\": \"\",\n            \"code_start_line\": 257,\n            \"code_end_line\": 259,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"def remove_color_codes(s: str) -> str:\\n    ansi_escape = re.compile(r\\\"\\\\x1B(?:[@-Z\\\\\\\\-_]|\\\\[[0-?]*[ -/]*[@-~])\\\")\\n    return ansi_escape.sub(\\\"\\\", s)\\n\",\n            \"name_column\": 4\n        },\n        \"__init__\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"__init__\",\n            \"md_content\": \"\",\n            \"code_start_line\": 40,\n            \"code_end_line\": 96,\n            \"parent\": \"Logger\",\n            \"have_return\": false,\n            \"code_content\": \"    def __init__(self, log_dir: str = None, log_name: str= \\\"\\\", log_file: str = \\\"activity.log\\\", error_file: str = \\\"errors.log\\\"):\\n        \\\"\\\"\\\"init\\\"\\\"\\\"\\n        if not os.path.exists(log_dir):\\n            os.makedirs(log_dir)\\n\\n        # create log directory if it doesn't exist\\n        self.log_name = time.strftime(\\\"%Y-%m-%d\\\", time.localtime()) if not log_name else log_name\\n        self.logger = logging.getLogger(self.log_name)\\n        console_formatter = RecordFormatter(\\\"%(title_color)s %(message)s\\\")\\n\\n        # Create a handler for console which simulate typing\\n        self.typing_console_handler = TypingConsoleHandler()\\n        self.typing_console_handler.setLevel(logging.INFO)\\n        self.typing_console_handler.setFormatter(console_formatter)\\n\\n        # Create a handler for console without typing simulation\\n        self.console_handler = ConsoleHandler()\\n        self.console_handler.setLevel(logging.DEBUG)\\n        self.console_handler.setFormatter(console_formatter)\\n\\n        self.speak_mode = False\\n        self.chat_plugins = []\\n\\n        # Info handler in activity.log\\n        self.file_handler = logging.FileHandler(\\n            os.path.join(log_dir, log_file), \\\"a\\\", \\\"utf-8\\\"\\n        )\\n        self.file_handler.setLevel(logging.DEBUG)\\n        info_formatter = RecordFormatter(\\n            \\\"%(asctime)s [%(threadName)s] %(levelname)s: %(title_color)s %(title)s %(message)s\\\"\\n        )\\n        self.file_handler.setFormatter(info_formatter)\\n\\n        # Error handler error.log\\n        error_handler = logging.FileHandler(\\n            os.path.join(log_dir, error_file), \\\"a\\\", \\\"utf-8\\\"\\n        )\\n        error_handler.setLevel(logging.ERROR)\\n        error_formatter = RecordFormatter(\\n            \\\"%(asctime)s [%(threadName)s] %(levelname)s %(module)s:%(funcName)s:%(lineno)d %(title_color)s %(title)s\\\"\\n            \\\" %(message_no_color)s\\\"\\n        )\\n        error_handler.setFormatter(error_formatter)\\n\\n        # self.typing_logger = logging.getLogger(self.log_name)\\n        # if not self.typing_logger.handlers:\\n        #     self.typing_logger.addHandler(self.typing_console_handler)\\n        #     self.typing_logger.addHandler(self.file_handler)\\n        #     self.typing_logger.addHandler(error_handler)\\n        # self.typing_logger.setLevel(logging.DEBUG)\\n\\n        if self.log_name.endswith(\\\"_INTERACT\\\") or not self.logger.handlers:\\n            # self.logger.addHandler(self.typing_console_handler)\\n            self.logger.addHandler(self.console_handler)\\n            self.logger.addHandler(error_handler)\\n            self.logger.addHandler(self.file_handler)\\n            self.logger.setLevel(logging.DEBUG)\\n\",\n            \"name_column\": 8\n        },\n        \"emit\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"emit\",\n            \"md_content\": \"\",\n            \"code_start_line\": 222,\n            \"code_end_line\": 227,\n            \"parent\": \"ConsoleHandler\",\n            \"have_return\": false,\n            \"code_content\": \"    def emit(self, record) -> None:\\n        msg = self.format(record)\\n        try:\\n            print(msg)\\n        except Exception:\\n            self.handleError(record)\\n\",\n            \"name_column\": 8\n        },\n        \"format\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"format\",\n            \"md_content\": \"\",\n            \"code_start_line\": 236,\n            \"code_end_line\": 254,\n            \"parent\": \"RecordFormatter\",\n            \"have_return\": true,\n            \"code_content\": \"    def format(self, record: LogRecord) -> str:\\n        if hasattr(record, \\\"color\\\"):\\n            record.title_color = (\\n                getattr(record, \\\"color\\\")\\n                + getattr(record, \\\"title\\\", \\\"\\\")\\n                + \\\" \\\"\\n                + Style.RESET_ALL\\n            )\\n        else:\\n            record.title_color = getattr(record, \\\"title\\\", \\\"\\\")\\n\\n        # Add this line to set 'title' to an empty string if it doesn't exist\\n        record.title = getattr(record, \\\"title\\\", \\\"\\\")\\n\\n        if hasattr(record, \\\"msg\\\"):\\n            record.message_no_color = remove_color_codes(getattr(record, \\\"msg\\\"))\\n        else:\\n            record.message_no_color = \\\"\\\"\\n        return super().format(record)\\n\",\n            \"name_column\": 8\n        },\n        \"typewriter_log\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"typewriter_log\",\n            \"md_content\": \"\",\n            \"code_start_line\": 98,\n            \"code_end_line\": 115,\n            \"parent\": \"Logger\",\n            \"have_return\": false,\n            \"code_content\": \"    def typewriter_log(\\n        self, title=\\\"\\\", title_color=\\\"\\\", content=\\\"\\\", speak_text=False, level=logging.INFO\\n    ):\\n        # if speak_text and self.speak_mode:\\n        #     say_text(f\\\"{title}. {content}\\\")\\n\\n        for plugin in self.chat_plugins:\\n            plugin.report(f\\\"{title}. {content}\\\")\\n\\n        if content:\\n            if isinstance(content, list):\\n                content = \\\" \\\".join(content)\\n        else:\\n            content = \\\"\\\"\\n\\n        self.logger.log(\\n            level, content, extra={\\\"title\\\": title, \\\"color\\\": title_color}\\n        )\\n\",\n            \"name_column\": 8\n        },\n        \"debug\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"debug\",\n            \"md_content\": \"\",\n            \"code_start_line\": 117,\n            \"code_end_line\": 123,\n            \"parent\": \"Logger\",\n            \"have_return\": false,\n            \"code_content\": \"    def debug(\\n        self,\\n        message,\\n        title=\\\"\\\",\\n        title_color=\\\"\\\",\\n    ):\\n        self._log(title, title_color, message, logging.DEBUG)\\n\",\n            \"name_column\": 8\n        },\n        \"info\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"info\",\n            \"md_content\": \"\",\n            \"code_start_line\": 125,\n            \"code_end_line\": 131,\n            \"parent\": \"Logger\",\n            \"have_return\": false,\n            \"code_content\": \"    def info(\\n        self,\\n        message,\\n        title=\\\"\\\",\\n        title_color=\\\"\\\",\\n    ):\\n        self._log(title, title_color, message, logging.INFO)\\n\",\n            \"name_column\": 8\n        },\n        \"warn\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"warn\",\n            \"md_content\": \"\",\n            \"code_start_line\": 133,\n            \"code_end_line\": 139,\n            \"parent\": \"Logger\",\n            \"have_return\": false,\n            \"code_content\": \"    def warn(\\n        self,\\n        message,\\n        title=\\\"\\\",\\n        title_color=\\\"\\\",\\n    ):\\n        self._log(title, title_color, message, logging.WARN)\\n\",\n            \"name_column\": 8\n        },\n        \"error\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"error\",\n            \"md_content\": \"\",\n            \"code_start_line\": 141,\n            \"code_end_line\": 142,\n            \"parent\": \"Logger\",\n            \"have_return\": false,\n            \"code_content\": \"    def error(self, title, message=\\\"\\\"):\\n        self._log(title, Fore.RED, message, logging.ERROR)\\n\",\n            \"name_column\": 8\n        },\n        \"_log\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"_log\",\n            \"md_content\": \"\",\n            \"code_start_line\": 144,\n            \"code_end_line\": 156,\n            \"parent\": \"Logger\",\n            \"have_return\": false,\n            \"code_content\": \"    def _log(\\n        self,\\n        title: str = \\\"\\\",\\n        title_color: str = \\\"\\\",\\n        message: str = \\\"\\\",\\n        level=logging.INFO,\\n    ):\\n        if message:\\n            if isinstance(message, list):\\n                message = \\\" \\\".join(message)\\n        self.logger.log(\\n            level, message, extra={\\\"title\\\": str(title), \\\"color\\\": str(title_color)}\\n        )\\n\",\n            \"name_column\": 8\n        },\n        \"set_level\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"set_level\",\n            \"md_content\": \"\",\n            \"code_start_line\": 158,\n            \"code_end_line\": 160,\n            \"parent\": \"Logger\",\n            \"have_return\": false,\n            \"code_content\": \"    def set_level(self, level):\\n        self.logger.setLevel(level)\\n        self.typing_logger.setLevel(level)\\n\",\n            \"name_column\": 8\n        },\n        \"double_check\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"double_check\",\n            \"md_content\": \"\",\n            \"code_start_line\": 162,\n            \"code_end_line\": 171,\n            \"parent\": \"Logger\",\n            \"have_return\": false,\n            \"code_content\": \"    def double_check(self, additionalText=None):\\n        if not additionalText:\\n            additionalText = (\\n                \\\"Please ensure you've setup and configured everything\\\"\\n                \\\" correctly. Read https://github.com/Torantulino/Auto-GPT#readme to \\\"\\n                \\\"double check. You can also create a github issue or join the discord\\\"\\n                \\\" and ask there!\\\"\\n            )\\n\\n        self.typewriter_log(\\\"DOUBLE CHECK CONFIGURATION\\\", Fore.YELLOW, additionalText)\\n\",\n            \"name_column\": 8\n        },\n        \"log_json\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"log_json\",\n            \"md_content\": \"\",\n            \"code_start_line\": 173,\n            \"code_end_line\": 186,\n            \"parent\": \"Logger\",\n            \"have_return\": false,\n            \"code_content\": \"    def log_json(self, data: Any, file_name: str) -> None:\\n        # Define log directory\\n        this_files_dir_path = os.path.dirname(__file__)\\n        log_dir = os.path.join(this_files_dir_path, \\\"../logs\\\")\\n\\n        # Create a handler for JSON files\\n        json_file_path = os.path.join(log_dir, file_name)\\n        json_data_handler = JsonFileHandler(json_file_path)\\n        json_data_handler.setFormatter(JsonFormatter())\\n\\n        # Log the JSON data using the custom file handler\\n        self.json_logger.addHandler(json_data_handler)\\n        self.json_logger.debug(data)\\n        self.json_logger.removeHandler(json_data_handler)\\n\",\n            \"name_column\": 8\n        },\n        \"get_log_directory\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"get_log_directory\",\n            \"md_content\": \"\",\n            \"code_start_line\": 188,\n            \"code_end_line\": 191,\n            \"parent\": \"Logger\",\n            \"have_return\": true,\n            \"code_content\": \"    def get_log_directory(self):\\n        this_files_dir_path = os.path.dirname(__file__)\\n        log_dir = os.path.join(this_files_dir_path, \\\"../logs\\\")\\n        return os.path.abspath(log_dir)\\n\",\n            \"name_column\": 8\n        }\n    },\n    \"XAgentServer/enums/recorder_type.py\": {\n        \"RecorderTypeEnum\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"RecorderTypeEnum\",\n            \"md_content\": \"\",\n            \"code_start_line\": 4,\n            \"code_end_line\": 20,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"class RecorderTypeEnum:\\n    \\\"\\\"\\\"XAgent Running Recorder Type Enum\\n    \\\"\\\"\\\"\\n    QUERY = \\\"query\\\"\\n    CONFIG = \\\"config\\\"\\n    LLM_INPUT_PAIR = \\\"llm_input_pair\\\"\\n    TOOL_SERVER_PAIR = \\\"tool_server_pair\\\"\\n    NOW_SUBTASK_ID = \\\"now_subtask_id\\\"\\n    TOOL_CALL = \\\"tool_call\\\"\\n    PLAN_REFINE = \\\"plan_refine\\\"\\n    LLM_SERVER_CACHE = \\\"llm_server_cache\\\"\\n    TOOL_SERVER_CACHE = \\\"tool_server_cache\\\"\\n    TOOL_CALL_CACHE = \\\"tool_call_cache\\\"\\n    PLAN_REFINE_CACHE = \\\"plan_refine_cache\\\"\\n    LLM_INTERFACE_ID = \\\"llm_interface_id\\\"\\n    TOOL_SERVER_INTERFACE_ID = \\\"toolserver_interface_id\\\"\\n    TOOL_CALL_ID = \\\"tool_call_id\\\"\\n\",\n            \"name_column\": 6\n        }\n    },\n    \"XAgentServer/enums/status.py\": {\n        \"StatusEnum\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"StatusEnum\",\n            \"md_content\": \"\",\n            \"code_start_line\": 4,\n            \"code_end_line\": 16,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"class StatusEnum:\\n    \\\"\\\"\\\"XAgent Status Enum\\n    \\\"\\\"\\\"\\n    START = \\\"start\\\"\\n    SUBTASK = \\\"subtask\\\"\\n    REFINEMENT = \\\"refinement\\\"\\n    INNER = \\\"inner\\\"\\n    FINISHED = \\\"finished\\\"\\n    FAILED = \\\"failed\\\"\\n    SUBMIT = \\\"subtask_submit\\\"\\n    RUNNING = \\\"running\\\"\\n    ASK_FOR_HUMAN_HELP = \\\"ask_for_human_help\\\"\\n    CLOSED = \\\"closed\\\"\\n\",\n            \"name_column\": 6\n        }\n    },\n    \"XAgentServer/models/user.py\": {\n        \"XAgentUser\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"XAgentUser\",\n            \"md_content\": \"\",\n            \"code_start_line\": 7,\n            \"code_end_line\": 105,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"class XAgentUser(metaclass=abc.ABCMeta):\\n\\n    def __init__(self, \\n                 user_id: str, \\n                 email: str, \\n                 name: str, \\n                 token: str, \\n                 available: bool = True,\\n                 corporation: str = None,\\n                 industry: str = None,\\n                 position: str = None,\\n                 create_time: str = None,\\n                 update_time: str = None,\\n                 deleted: bool = False,\\n                 is_beta: bool = False,):\\n        self.user_id = user_id\\n        self.email = email\\n        self.name = name\\n        self.token = token\\n        self.available = available\\n        self.corporation = corporation\\n        self.industry = industry\\n        self.position = position\\n        self.create_time = create_time\\n        self.update_time = update_time\\n        self.deleted = deleted\\n        self.is_beta = is_beta\\n\\n    def to_dict(self):\\n        return {\\n            \\\"user_id\\\": self.user_id,\\n            \\\"email\\\": self.email,\\n            \\\"name\\\": self.name,\\n            \\\"token\\\": self.token,\\n            \\\"available\\\": self.available,\\n            \\\"corporation\\\": self.corporation,\\n            \\\"industry\\\": self.industry,\\n            \\\"position\\\": self.position,\\n            \\\"create_time\\\": self.create_time,\\n            \\\"update_time\\\": self.update_time,\\n            \\\"deleted\\\": self.deleted,\\n            \\\"is_beta\\\": self.is_beta\\n        }\\n\\n    def to_json(self):\\n        return json.dumps(self.to_dict(), indent=2, ensure_ascii=False)\\n\\n    @staticmethod\\n    def from_dict(user_dict: dict):\\n        return XAgentUser(\\n            user_id=user_dict[\\\"user_id\\\"],\\n            email=user_dict[\\\"email\\\"],\\n            name=user_dict[\\\"name\\\"],\\n            token=user_dict[\\\"token\\\"],\\n            available=user_dict[\\\"available\\\"],\\n            corporation=user_dict[\\\"corporation\\\"],\\n            industry=user_dict[\\\"industry\\\"],\\n            position=user_dict[\\\"position\\\"],\\n            create_time=user_dict[\\\"create_time\\\"],\\n            update_time=user_dict[\\\"update_time\\\"],\\n            deleted=user_dict[\\\"deleted\\\"],\\n            is_beta=user_dict[\\\"is_beta\\\"]\\n        )\\n\\n    @staticmethod\\n    def from_json(user_json: str):\\n        return XAgentUser.from_dict(json.loads(user_json))\\n\\n    def is_available(self):\\n        return self.available\\n    \\n    @staticmethod\\n    def from_db(user: User):\\n        user_id = user.user_id\\n        email = user.email\\n        name = user.name\\n        token = user.token\\n        available = user.available\\n        corporation = user.corporation\\n        industry = user.industry\\n        position = user.position\\n        create_time = user.create_time\\n        update_time = user.update_time\\n        deleted = user.deleted\\n        is_beta = user.is_beta\\n        return XAgentUser(\\n            user_id=user_id,\\n            email=email,\\n            name=name,\\n            token=token,\\n            available=available,\\n            corporation=corporation,\\n            industry=industry,\\n            position=position,\\n            create_time=create_time,\\n            update_time=update_time,\\n            deleted=deleted,\\n            is_beta=is_beta\\n        )\\n\",\n            \"name_column\": 6\n        },\n        \"__init__\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"__init__\",\n            \"md_content\": \"\",\n            \"code_start_line\": 9,\n            \"code_end_line\": 33,\n            \"parent\": \"XAgentUser\",\n            \"have_return\": false,\n            \"code_content\": \"    def __init__(self, \\n                 user_id: str, \\n                 email: str, \\n                 name: str, \\n                 token: str, \\n                 available: bool = True,\\n                 corporation: str = None,\\n                 industry: str = None,\\n                 position: str = None,\\n                 create_time: str = None,\\n                 update_time: str = None,\\n                 deleted: bool = False,\\n                 is_beta: bool = False,):\\n        self.user_id = user_id\\n        self.email = email\\n        self.name = name\\n        self.token = token\\n        self.available = available\\n        self.corporation = corporation\\n        self.industry = industry\\n        self.position = position\\n        self.create_time = create_time\\n        self.update_time = update_time\\n        self.deleted = deleted\\n        self.is_beta = is_beta\\n\",\n            \"name_column\": 8\n        },\n        \"to_dict\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"to_dict\",\n            \"md_content\": \"\",\n            \"code_start_line\": 35,\n            \"code_end_line\": 49,\n            \"parent\": \"XAgentUser\",\n            \"have_return\": true,\n            \"code_content\": \"    def to_dict(self):\\n        return {\\n            \\\"user_id\\\": self.user_id,\\n            \\\"email\\\": self.email,\\n            \\\"name\\\": self.name,\\n            \\\"token\\\": self.token,\\n            \\\"available\\\": self.available,\\n            \\\"corporation\\\": self.corporation,\\n            \\\"industry\\\": self.industry,\\n            \\\"position\\\": self.position,\\n            \\\"create_time\\\": self.create_time,\\n            \\\"update_time\\\": self.update_time,\\n            \\\"deleted\\\": self.deleted,\\n            \\\"is_beta\\\": self.is_beta\\n        }\\n\",\n            \"name_column\": 8\n        },\n        \"to_json\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"to_json\",\n            \"md_content\": \"\",\n            \"code_start_line\": 51,\n            \"code_end_line\": 52,\n            \"parent\": \"XAgentUser\",\n            \"have_return\": true,\n            \"code_content\": \"    def to_json(self):\\n        return json.dumps(self.to_dict(), indent=2, ensure_ascii=False)\\n\",\n            \"name_column\": 8\n        },\n        \"from_dict\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"from_dict\",\n            \"md_content\": \"\",\n            \"code_start_line\": 55,\n            \"code_end_line\": 69,\n            \"parent\": \"XAgentUser\",\n            \"have_return\": true,\n            \"code_content\": \"    def from_dict(user_dict: dict):\\n        return XAgentUser(\\n            user_id=user_dict[\\\"user_id\\\"],\\n            email=user_dict[\\\"email\\\"],\\n            name=user_dict[\\\"name\\\"],\\n            token=user_dict[\\\"token\\\"],\\n            available=user_dict[\\\"available\\\"],\\n            corporation=user_dict[\\\"corporation\\\"],\\n            industry=user_dict[\\\"industry\\\"],\\n            position=user_dict[\\\"position\\\"],\\n            create_time=user_dict[\\\"create_time\\\"],\\n            update_time=user_dict[\\\"update_time\\\"],\\n            deleted=user_dict[\\\"deleted\\\"],\\n            is_beta=user_dict[\\\"is_beta\\\"]\\n        )\\n\",\n            \"name_column\": 8\n        },\n        \"from_json\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"from_json\",\n            \"md_content\": \"\",\n            \"code_start_line\": 72,\n            \"code_end_line\": 73,\n            \"parent\": \"XAgentUser\",\n            \"have_return\": true,\n            \"code_content\": \"    def from_json(user_json: str):\\n        return XAgentUser.from_dict(json.loads(user_json))\\n\",\n            \"name_column\": 8\n        },\n        \"is_available\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"is_available\",\n            \"md_content\": \"\",\n            \"code_start_line\": 75,\n            \"code_end_line\": 76,\n            \"parent\": \"XAgentUser\",\n            \"have_return\": true,\n            \"code_content\": \"    def is_available(self):\\n        return self.available\\n\",\n            \"name_column\": 8\n        },\n        \"from_db\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"from_db\",\n            \"md_content\": \"\",\n            \"code_start_line\": 79,\n            \"code_end_line\": 105,\n            \"parent\": \"XAgentUser\",\n            \"have_return\": true,\n            \"code_content\": \"    def from_db(user: User):\\n        user_id = user.user_id\\n        email = user.email\\n        name = user.name\\n        token = user.token\\n        available = user.available\\n        corporation = user.corporation\\n        industry = user.industry\\n        position = user.position\\n        create_time = user.create_time\\n        update_time = user.update_time\\n        deleted = user.deleted\\n        is_beta = user.is_beta\\n        return XAgentUser(\\n            user_id=user_id,\\n            email=email,\\n            name=name,\\n            token=token,\\n            available=available,\\n            corporation=corporation,\\n            industry=industry,\\n            position=position,\\n            create_time=create_time,\\n            update_time=update_time,\\n            deleted=deleted,\\n            is_beta=is_beta\\n        )\\n\",\n            \"name_column\": 8\n        }\n    },\n    \"XAgentServer/models/interaction.py\": {\n        \"InteractionBase\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"InteractionBase\",\n            \"md_content\": \"\",\n            \"code_start_line\": 8,\n            \"code_end_line\": 86,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"class InteractionBase(metaclass=abc.ABCMeta):\\n    def __init__(self,\\n                interaction_id: str,\\n                user_id: str,\\n                create_time: str,\\n                description: str,\\n                agent: str = \\\"\\\",\\n                mode: str = \\\"\\\",\\n                file_list: list = [],\\n                recorder_root_dir: str = \\\"\\\",\\n                status: str = \\\"\\\",\\n                message: str = \\\"\\\",\\n                current_step: str = \\\"\\\",\\n                update_time: str = \\\"\\\",\\n                is_deleted: bool = False,\\n                call_method: str = \\\"web\\\",\\n                ):\\n        self.interaction_id = interaction_id\\n        self.user_id = user_id\\n        self.create_time = create_time\\n        self.description = description\\n        self.agent = agent\\n        self.mode = mode\\n        self.file_list = file_list\\n        self.recorder_root_dir = recorder_root_dir\\n        self.status = status\\n        self.message = message\\n        self.current_step = current_step\\n        self.update_time = update_time\\n        self.is_deleted = is_deleted\\n        self.call_method = call_method\\n\\n    def to_dict(self, include=None, exclude=None):\\n        data = {\\n            \\\"interaction_id\\\": self.interaction_id,\\n            \\\"user_id\\\": self.user_id,\\n            \\\"create_time\\\": self.create_time,\\n            \\\"description\\\": self.description,\\n            \\\"agent\\\": self.agent,\\n            \\\"mode\\\": self.mode,\\n            \\\"file_list\\\": self.file_list,\\n            \\\"recorder_root_dir\\\": self.recorder_root_dir,\\n            \\\"status\\\": self.status,\\n            \\\"message\\\": self.message,\\n            \\\"current_step\\\": self.current_step,\\n            \\\"update_time\\\": self.update_time,\\n            \\\"is_deleted\\\": self.is_deleted,\\n            \\\"call_method\\\": self.call_method,\\n        }\\n        if include:\\n            data = {k: v for k, v in data.items() if k in include}\\n        if exclude:\\n            data = {k: v for k, v in data.items() if k not in exclude}\\n        return data\\n    \\n    def to_json(self):\\n        return json.dumps(self.to_dict(), indent=2, ensure_ascii=False)\\n    \\n    @classmethod\\n    def from_json(cls, json_data):\\n        return cls(**json_data)\\n    \\n    @classmethod\\n    def from_db(cls, interaction):\\n        return cls(interaction.interaction_id,\\n                    interaction.user_id,\\n                    interaction.create_time,\\n                    interaction.description,\\n                    interaction.agent,\\n                    interaction.mode,\\n                    interaction.file_list,\\n                    interaction.recorder_root_dir,\\n                    interaction.status,\\n                    interaction.message,\\n                    interaction.current_step,\\n                    interaction.update_time,\\n                    interaction.is_deleted,\\n                    interaction.call_method,\\n                    )\\n\",\n            \"name_column\": 6\n        },\n        \"__init__\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"__init__\",\n            \"md_content\": \"\",\n            \"code_start_line\": 9,\n            \"code_end_line\": 38,\n            \"parent\": \"InteractionBase\",\n            \"have_return\": false,\n            \"code_content\": \"    def __init__(self,\\n                interaction_id: str,\\n                user_id: str,\\n                create_time: str,\\n                description: str,\\n                agent: str = \\\"\\\",\\n                mode: str = \\\"\\\",\\n                file_list: list = [],\\n                recorder_root_dir: str = \\\"\\\",\\n                status: str = \\\"\\\",\\n                message: str = \\\"\\\",\\n                current_step: str = \\\"\\\",\\n                update_time: str = \\\"\\\",\\n                is_deleted: bool = False,\\n                call_method: str = \\\"web\\\",\\n                ):\\n        self.interaction_id = interaction_id\\n        self.user_id = user_id\\n        self.create_time = create_time\\n        self.description = description\\n        self.agent = agent\\n        self.mode = mode\\n        self.file_list = file_list\\n        self.recorder_root_dir = recorder_root_dir\\n        self.status = status\\n        self.message = message\\n        self.current_step = current_step\\n        self.update_time = update_time\\n        self.is_deleted = is_deleted\\n        self.call_method = call_method\\n\",\n            \"name_column\": 8\n        },\n        \"to_dict\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"to_dict\",\n            \"md_content\": \"\",\n            \"code_start_line\": 40,\n            \"code_end_line\": 61,\n            \"parent\": \"InteractionBase\",\n            \"have_return\": true,\n            \"code_content\": \"    def to_dict(self, include=None, exclude=None):\\n        data = {\\n            \\\"interaction_id\\\": self.interaction_id,\\n            \\\"user_id\\\": self.user_id,\\n            \\\"create_time\\\": self.create_time,\\n            \\\"description\\\": self.description,\\n            \\\"agent\\\": self.agent,\\n            \\\"mode\\\": self.mode,\\n            \\\"file_list\\\": self.file_list,\\n            \\\"recorder_root_dir\\\": self.recorder_root_dir,\\n            \\\"status\\\": self.status,\\n            \\\"message\\\": self.message,\\n            \\\"current_step\\\": self.current_step,\\n            \\\"update_time\\\": self.update_time,\\n            \\\"is_deleted\\\": self.is_deleted,\\n            \\\"call_method\\\": self.call_method,\\n        }\\n        if include:\\n            data = {k: v for k, v in data.items() if k in include}\\n        if exclude:\\n            data = {k: v for k, v in data.items() if k not in exclude}\\n        return data\\n\",\n            \"name_column\": 8\n        },\n        \"to_json\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"to_json\",\n            \"md_content\": \"\",\n            \"code_start_line\": 63,\n            \"code_end_line\": 64,\n            \"parent\": \"InteractionBase\",\n            \"have_return\": true,\n            \"code_content\": \"    def to_json(self):\\n        return json.dumps(self.to_dict(), indent=2, ensure_ascii=False)\\n\",\n            \"name_column\": 8\n        },\n        \"from_json\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"from_json\",\n            \"md_content\": \"\",\n            \"code_start_line\": 67,\n            \"code_end_line\": 68,\n            \"parent\": \"InteractionBase\",\n            \"have_return\": true,\n            \"code_content\": \"    def from_json(cls, json_data):\\n        return cls(**json_data)\\n\",\n            \"name_column\": 8\n        },\n        \"from_db\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"from_db\",\n            \"md_content\": \"\",\n            \"code_start_line\": 71,\n            \"code_end_line\": 86,\n            \"parent\": \"InteractionBase\",\n            \"have_return\": true,\n            \"code_content\": \"    def from_db(cls, interaction):\\n        return cls(interaction.interaction_id,\\n                    interaction.user_id,\\n                    interaction.create_time,\\n                    interaction.description,\\n                    interaction.agent,\\n                    interaction.mode,\\n                    interaction.file_list,\\n                    interaction.recorder_root_dir,\\n                    interaction.status,\\n                    interaction.message,\\n                    interaction.current_step,\\n                    interaction.update_time,\\n                    interaction.is_deleted,\\n                    interaction.call_method,\\n                    )\\n\",\n            \"name_column\": 8\n        }\n    },\n    \"XAgentServer/models/raw.py\": {\n        \"XAgentRaw\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"XAgentRaw\",\n            \"md_content\": \"\",\n            \"code_start_line\": 6,\n            \"code_end_line\": 110,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"class XAgentRaw(metaclass=abc.ABCMeta):\\n    \\\"\\\"\\\"XAgent Raw Object\\\"\\\"\\\"\\n\\n    def __init__(self, node_id: str,\\n                 interaction_id: str,\\n                 current: str,\\n                 step: int,\\n                 data: dict,\\n                 file_list: list,\\n                 status: str,\\n                 do_interrupt: bool,\\n                 wait_seconds: int,\\n                 ask_for_human_help: bool,\\n                 create_time: str,\\n                 update_time: str,\\n                 is_deleted: bool,\\n                 is_human: bool,\\n                 human_data: dict,\\n                 human_file_list: list,\\n                 is_send: bool,\\n                 is_receive: bool,\\n                 include_pictures: bool = False,):\\n        self.node_id = node_id\\n        self.interaction_id = interaction_id\\n        self.current = current\\n        self.step = step\\n        self.data = data\\n        self.file_list = file_list\\n        self.status = status\\n        self.do_interrupt = do_interrupt\\n        self.wait_seconds = wait_seconds\\n        self.ask_for_human_help = ask_for_human_help\\n        self.create_time = create_time\\n        self.update_time = update_time\\n        self.is_deleted = is_deleted\\n        self.is_human = is_human\\n        self.human_data = human_data\\n        self.human_file_list = human_file_list\\n        self.is_send = is_send\\n        self.is_receive = is_receive\\n        self.include_pictures = include_pictures\\n\\n    def to_dict(self):\\n        \\\"\\\"\\\"XAgent Raw Object to dict\\\"\\\"\\\"\\n        return {\\n            \\\"node_id\\\": self.node_id,\\n            \\\"interaction_id\\\": self.interaction_id,\\n            \\\"current\\\": self.current,\\n            \\\"step\\\": self.step,\\n            \\\"data\\\": self.data,\\n            \\\"file_list\\\": self.file_list,\\n            \\\"status\\\": self.status,\\n            \\\"do_interrupt\\\": self.do_interrupt,\\n            \\\"wait_seconds\\\": self.wait_seconds,\\n            \\\"ask_for_human_help\\\": self.ask_for_human_help,\\n            \\\"create_time\\\": self.create_time,\\n            \\\"update_time\\\": self.update_time,\\n            \\\"is_deleted\\\": self.is_deleted,\\n            \\\"is_human\\\": self.is_human,\\n            \\\"human_data\\\": self.human_data,\\n            \\\"human_file_list\\\": self.human_file_list,\\n            \\\"is_send\\\": self.is_send,\\n            \\\"is_receive\\\": self.is_receive,\\n            \\\"include_pictures\\\": self.include_pictures\\n        }\\n\\n    def to_json(self):\\n        \\\"\\\"\\\"XAgent Raw Object to json\\\"\\\"\\\"\\n        return json.dumps(self.to_dict(), indent=2, ensure_ascii=False)\\n\\n    @classmethod\\n    def from_json(cls, json_data):\\n        \\\"\\\"\\\"XAgent Raw Object from json\\\"\\\"\\\"\\n        return cls(**json_data)\\n\\n    def update(self, update_data: dict):\\n        \\\"\\\"\\\"XAgent Raw Object update\\\"\\\"\\\"\\n        for k, v in update_data.items():\\n            setattr(self, k, v)\\n        return self\\n\\n    @classmethod\\n    def from_db(cls, db_data):\\n        \\\"\\\"\\\"XAgent Raw Object from db\\\"\\\"\\\"\\n        return cls(\\n            node_id=db_data.node_id,\\n            interaction_id=db_data.interaction_id,\\n            current=db_data.current,\\n            step=db_data.step,\\n            data=db_data.data,\\n            file_list=db_data.file_list,\\n            status=db_data.status,\\n            do_interrupt=db_data.do_interrupt,\\n            wait_seconds=db_data.wait_seconds,\\n            ask_for_human_help=db_data.ask_for_human_help,\\n            create_time=db_data.create_time,\\n            update_time=db_data.update_time,\\n            is_deleted=db_data.is_deleted,\\n            is_human=db_data.is_human,\\n            human_data=db_data.human_data,\\n            human_file_list=db_data.human_file_list,\\n            is_send=db_data.is_send,\\n            is_receive=db_data.is_receive,\\n            include_pictures=db_data.include_pictures\\n        )\\n\",\n            \"name_column\": 6\n        },\n        \"__init__\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"__init__\",\n            \"md_content\": \"\",\n            \"code_start_line\": 9,\n            \"code_end_line\": 46,\n            \"parent\": \"XAgentRaw\",\n            \"have_return\": false,\n            \"code_content\": \"    def __init__(self, node_id: str,\\n                 interaction_id: str,\\n                 current: str,\\n                 step: int,\\n                 data: dict,\\n                 file_list: list,\\n                 status: str,\\n                 do_interrupt: bool,\\n                 wait_seconds: int,\\n                 ask_for_human_help: bool,\\n                 create_time: str,\\n                 update_time: str,\\n                 is_deleted: bool,\\n                 is_human: bool,\\n                 human_data: dict,\\n                 human_file_list: list,\\n                 is_send: bool,\\n                 is_receive: bool,\\n                 include_pictures: bool = False,):\\n        self.node_id = node_id\\n        self.interaction_id = interaction_id\\n        self.current = current\\n        self.step = step\\n        self.data = data\\n        self.file_list = file_list\\n        self.status = status\\n        self.do_interrupt = do_interrupt\\n        self.wait_seconds = wait_seconds\\n        self.ask_for_human_help = ask_for_human_help\\n        self.create_time = create_time\\n        self.update_time = update_time\\n        self.is_deleted = is_deleted\\n        self.is_human = is_human\\n        self.human_data = human_data\\n        self.human_file_list = human_file_list\\n        self.is_send = is_send\\n        self.is_receive = is_receive\\n        self.include_pictures = include_pictures\\n\",\n            \"name_column\": 8\n        },\n        \"to_dict\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"to_dict\",\n            \"md_content\": \"\",\n            \"code_start_line\": 48,\n            \"code_end_line\": 70,\n            \"parent\": \"XAgentRaw\",\n            \"have_return\": true,\n            \"code_content\": \"    def to_dict(self):\\n        \\\"\\\"\\\"XAgent Raw Object to dict\\\"\\\"\\\"\\n        return {\\n            \\\"node_id\\\": self.node_id,\\n            \\\"interaction_id\\\": self.interaction_id,\\n            \\\"current\\\": self.current,\\n            \\\"step\\\": self.step,\\n            \\\"data\\\": self.data,\\n            \\\"file_list\\\": self.file_list,\\n            \\\"status\\\": self.status,\\n            \\\"do_interrupt\\\": self.do_interrupt,\\n            \\\"wait_seconds\\\": self.wait_seconds,\\n            \\\"ask_for_human_help\\\": self.ask_for_human_help,\\n            \\\"create_time\\\": self.create_time,\\n            \\\"update_time\\\": self.update_time,\\n            \\\"is_deleted\\\": self.is_deleted,\\n            \\\"is_human\\\": self.is_human,\\n            \\\"human_data\\\": self.human_data,\\n            \\\"human_file_list\\\": self.human_file_list,\\n            \\\"is_send\\\": self.is_send,\\n            \\\"is_receive\\\": self.is_receive,\\n            \\\"include_pictures\\\": self.include_pictures\\n        }\\n\",\n            \"name_column\": 8\n        },\n        \"to_json\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"to_json\",\n            \"md_content\": \"\",\n            \"code_start_line\": 72,\n            \"code_end_line\": 74,\n            \"parent\": \"XAgentRaw\",\n            \"have_return\": true,\n            \"code_content\": \"    def to_json(self):\\n        \\\"\\\"\\\"XAgent Raw Object to json\\\"\\\"\\\"\\n        return json.dumps(self.to_dict(), indent=2, ensure_ascii=False)\\n\",\n            \"name_column\": 8\n        },\n        \"from_json\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"from_json\",\n            \"md_content\": \"\",\n            \"code_start_line\": 77,\n            \"code_end_line\": 79,\n            \"parent\": \"XAgentRaw\",\n            \"have_return\": true,\n            \"code_content\": \"    def from_json(cls, json_data):\\n        \\\"\\\"\\\"XAgent Raw Object from json\\\"\\\"\\\"\\n        return cls(**json_data)\\n\",\n            \"name_column\": 8\n        },\n        \"update\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"update\",\n            \"md_content\": \"\",\n            \"code_start_line\": 81,\n            \"code_end_line\": 85,\n            \"parent\": \"XAgentRaw\",\n            \"have_return\": true,\n            \"code_content\": \"    def update(self, update_data: dict):\\n        \\\"\\\"\\\"XAgent Raw Object update\\\"\\\"\\\"\\n        for k, v in update_data.items():\\n            setattr(self, k, v)\\n        return self\\n\",\n            \"name_column\": 8\n        },\n        \"from_db\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"from_db\",\n            \"md_content\": \"\",\n            \"code_start_line\": 88,\n            \"code_end_line\": 110,\n            \"parent\": \"XAgentRaw\",\n            \"have_return\": true,\n            \"code_content\": \"    def from_db(cls, db_data):\\n        \\\"\\\"\\\"XAgent Raw Object from db\\\"\\\"\\\"\\n        return cls(\\n            node_id=db_data.node_id,\\n            interaction_id=db_data.interaction_id,\\n            current=db_data.current,\\n            step=db_data.step,\\n            data=db_data.data,\\n            file_list=db_data.file_list,\\n            status=db_data.status,\\n            do_interrupt=db_data.do_interrupt,\\n            wait_seconds=db_data.wait_seconds,\\n            ask_for_human_help=db_data.ask_for_human_help,\\n            create_time=db_data.create_time,\\n            update_time=db_data.update_time,\\n            is_deleted=db_data.is_deleted,\\n            is_human=db_data.is_human,\\n            human_data=db_data.human_data,\\n            human_file_list=db_data.human_file_list,\\n            is_send=db_data.is_send,\\n            is_receive=db_data.is_receive,\\n            include_pictures=db_data.include_pictures\\n        )\\n\",\n            \"name_column\": 8\n        }\n    },\n    \"XAgentServer/models/shared_interaction.py\": {\n        \"SharedInteractionBase\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"SharedInteractionBase\",\n            \"md_content\": \"\",\n            \"code_start_line\": 9,\n            \"code_end_line\": 68,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"class SharedInteractionBase(metaclass=abc.ABCMeta):\\n    def __init__(self,\\n                interaction_id: str,\\n                user_name: str,\\n                create_time: str,\\n                update_time: str,\\n                description: str,\\n                agent: str = \\\"\\\",\\n                mode: str = \\\"\\\",\\n                is_deleted: bool = False,\\n                star: int = 0,\\n                is_audit: bool = False\\n                ):\\n        self.interaction_id = interaction_id\\n        self.user_name = user_name\\n        self.create_time = create_time\\n        self.update_time = update_time\\n        self.description = description\\n        self.agent = agent\\n        self.mode = mode\\n        self.is_deleted = is_deleted\\n        self.star = star\\n        self.is_audit = is_audit\\n\\n    def to_dict(self, include=None, exclude=None):\\n        data = {\\n            \\\"interaction_id\\\": self.interaction_id,\\n            \\\"user_name\\\": self.user_name,\\n            \\\"create_time\\\": self.create_time,\\n            \\\"update_time\\\": self.update_time,\\n            \\\"description\\\": self.description,\\n            \\\"agent\\\": self.agent,\\n            \\\"mode\\\": self.mode,\\n            \\\"is_deleted\\\": self.is_deleted,\\n            \\\"star\\\": self.star,\\n            \\\"is_audit\\\": self.is_audit\\n        }\\n        if include:\\n            data = {k: v for k, v in data.items() if k in include}\\n        if exclude:\\n            data = {k: v for k, v in data.items() if k not in exclude}\\n        return data\\n        \\n    \\n    def to_json(self):\\n        return json.dumps(self.to_dict(), indent=2, ensure_ascii=False)\\n    \\n    @classmethod\\n    def from_db(cls, interaction):\\n        return cls(interaction.interaction_id,\\n                   interaction.user_name,\\n                   interaction.create_time,\\n                   interaction.update_time,\\n                   interaction.description,\\n                   interaction.agent,\\n                   interaction.mode,\\n                   interaction.is_deleted,\\n                   interaction.star,\\n                   interaction.is_audit\\n                   )\\n\",\n            \"name_column\": 6\n        },\n        \"__init__\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"__init__\",\n            \"md_content\": \"\",\n            \"code_start_line\": 10,\n            \"code_end_line\": 31,\n            \"parent\": \"SharedInteractionBase\",\n            \"have_return\": false,\n            \"code_content\": \"    def __init__(self,\\n                interaction_id: str,\\n                user_name: str,\\n                create_time: str,\\n                update_time: str,\\n                description: str,\\n                agent: str = \\\"\\\",\\n                mode: str = \\\"\\\",\\n                is_deleted: bool = False,\\n                star: int = 0,\\n                is_audit: bool = False\\n                ):\\n        self.interaction_id = interaction_id\\n        self.user_name = user_name\\n        self.create_time = create_time\\n        self.update_time = update_time\\n        self.description = description\\n        self.agent = agent\\n        self.mode = mode\\n        self.is_deleted = is_deleted\\n        self.star = star\\n        self.is_audit = is_audit\\n\",\n            \"name_column\": 8\n        },\n        \"to_dict\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"to_dict\",\n            \"md_content\": \"\",\n            \"code_start_line\": 33,\n            \"code_end_line\": 50,\n            \"parent\": \"SharedInteractionBase\",\n            \"have_return\": true,\n            \"code_content\": \"    def to_dict(self, include=None, exclude=None):\\n        data = {\\n            \\\"interaction_id\\\": self.interaction_id,\\n            \\\"user_name\\\": self.user_name,\\n            \\\"create_time\\\": self.create_time,\\n            \\\"update_time\\\": self.update_time,\\n            \\\"description\\\": self.description,\\n            \\\"agent\\\": self.agent,\\n            \\\"mode\\\": self.mode,\\n            \\\"is_deleted\\\": self.is_deleted,\\n            \\\"star\\\": self.star,\\n            \\\"is_audit\\\": self.is_audit\\n        }\\n        if include:\\n            data = {k: v for k, v in data.items() if k in include}\\n        if exclude:\\n            data = {k: v for k, v in data.items() if k not in exclude}\\n        return data\\n\",\n            \"name_column\": 8\n        },\n        \"to_json\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"to_json\",\n            \"md_content\": \"\",\n            \"code_start_line\": 53,\n            \"code_end_line\": 54,\n            \"parent\": \"SharedInteractionBase\",\n            \"have_return\": true,\n            \"code_content\": \"    def to_json(self):\\n        return json.dumps(self.to_dict(), indent=2, ensure_ascii=False)\\n\",\n            \"name_column\": 8\n        },\n        \"from_db\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"from_db\",\n            \"md_content\": \"\",\n            \"code_start_line\": 57,\n            \"code_end_line\": 68,\n            \"parent\": \"SharedInteractionBase\",\n            \"have_return\": true,\n            \"code_content\": \"    def from_db(cls, interaction):\\n        return cls(interaction.interaction_id,\\n                   interaction.user_name,\\n                   interaction.create_time,\\n                   interaction.update_time,\\n                   interaction.description,\\n                   interaction.agent,\\n                   interaction.mode,\\n                   interaction.is_deleted,\\n                   interaction.star,\\n                   interaction.is_audit\\n                   )\\n\",\n            \"name_column\": 8\n        }\n    },\n    \"XAgentServer/models/recorder.py\": {\n        \"XAgentRunningRecord\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"XAgentRunningRecord\",\n            \"md_content\": \"\",\n            \"code_start_line\": 7,\n            \"code_end_line\": 67,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"class XAgentRunningRecord(metaclass=abc.ABCMeta):\\n    \\\"\\\"\\\"XAgent Running Recorder\\\"\\\"\\\"\\n    def __init__(self,\\n                 record_id: str,\\n                 current: str,\\n                 node_id: str,\\n                 node_type: str,\\n                 data: dict,\\n                 create_time: str,\\n                 update_time: str,\\n                 is_deleted: bool,\\n                 ):\\n        self.record_id = record_id\\n        self.current = current\\n        self.node_id = node_id\\n        self.node_type = node_type\\n        self.data = data\\n        self.create_time = create_time\\n        self.update_time = update_time\\n        self.is_deleted = is_deleted\\n\\n    def to_dict(self):\\n        \\\"\\\"\\\"XAgent Running Recorder to dict\\\"\\\"\\\"\\n        return {\\n            \\\"record_id\\\": self.record_id,\\n            \\\"current\\\": self.current,\\n            \\\"node_id\\\": self.node_id,\\n            \\\"node_type\\\": self.node_type,\\n            \\\"data\\\": self.data,\\n            \\\"create_time\\\": self.create_time,\\n            \\\"update_time\\\": self.update_time,\\n            \\\"is_deleted\\\": self.is_deleted,\\n        }\\n\\n    @classmethod\\n    def from_db(cls, db: RunningRecord):\\n        \\\"\\\"\\\"From db\\\"\\\"\\\"\\n        return cls(\\n            record_id=db.record_id,\\n            current=db.current,\\n            node_id=db.node_id,\\n            node_type=db.node_type,\\n            data=db.data,\\n            create_time=db.create_time,\\n            update_time=db.update_time,\\n            is_deleted=db.is_deleted,\\n        )\\n\\n    @classmethod\\n    def from_dict(cls, data: dict):\\n        \\\"\\\"\\\"dict to XAgent Running Recorder\\\"\\\"\\\"\\n        return cls(\\n            record_id=data[\\\"record_id\\\"],\\n            current=data[\\\"current\\\"],\\n            node_id=data[\\\"node_id\\\"],\\n            node_type=data[\\\"node_type\\\"],\\n            data=data[\\\"data\\\"],\\n            create_time=data[\\\"create_time\\\"],\\n            update_time=data[\\\"update_time\\\"],\\n            is_deleted=data[\\\"is_deleted\\\"],\\n        )\\n\",\n            \"name_column\": 6\n        },\n        \"__init__\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"__init__\",\n            \"md_content\": \"\",\n            \"code_start_line\": 9,\n            \"code_end_line\": 26,\n            \"parent\": \"XAgentRunningRecord\",\n            \"have_return\": false,\n            \"code_content\": \"    def __init__(self,\\n                 record_id: str,\\n                 current: str,\\n                 node_id: str,\\n                 node_type: str,\\n                 data: dict,\\n                 create_time: str,\\n                 update_time: str,\\n                 is_deleted: bool,\\n                 ):\\n        self.record_id = record_id\\n        self.current = current\\n        self.node_id = node_id\\n        self.node_type = node_type\\n        self.data = data\\n        self.create_time = create_time\\n        self.update_time = update_time\\n        self.is_deleted = is_deleted\\n\",\n            \"name_column\": 8\n        },\n        \"to_dict\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"to_dict\",\n            \"md_content\": \"\",\n            \"code_start_line\": 28,\n            \"code_end_line\": 39,\n            \"parent\": \"XAgentRunningRecord\",\n            \"have_return\": true,\n            \"code_content\": \"    def to_dict(self):\\n        \\\"\\\"\\\"XAgent Running Recorder to dict\\\"\\\"\\\"\\n        return {\\n            \\\"record_id\\\": self.record_id,\\n            \\\"current\\\": self.current,\\n            \\\"node_id\\\": self.node_id,\\n            \\\"node_type\\\": self.node_type,\\n            \\\"data\\\": self.data,\\n            \\\"create_time\\\": self.create_time,\\n            \\\"update_time\\\": self.update_time,\\n            \\\"is_deleted\\\": self.is_deleted,\\n        }\\n\",\n            \"name_column\": 8\n        },\n        \"from_db\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"from_db\",\n            \"md_content\": \"\",\n            \"code_start_line\": 42,\n            \"code_end_line\": 53,\n            \"parent\": \"XAgentRunningRecord\",\n            \"have_return\": true,\n            \"code_content\": \"    def from_db(cls, db: RunningRecord):\\n        \\\"\\\"\\\"From db\\\"\\\"\\\"\\n        return cls(\\n            record_id=db.record_id,\\n            current=db.current,\\n            node_id=db.node_id,\\n            node_type=db.node_type,\\n            data=db.data,\\n            create_time=db.create_time,\\n            update_time=db.update_time,\\n            is_deleted=db.is_deleted,\\n        )\\n\",\n            \"name_column\": 8\n        },\n        \"from_dict\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"from_dict\",\n            \"md_content\": \"\",\n            \"code_start_line\": 56,\n            \"code_end_line\": 67,\n            \"parent\": \"XAgentRunningRecord\",\n            \"have_return\": true,\n            \"code_content\": \"    def from_dict(cls, data: dict):\\n        \\\"\\\"\\\"dict to XAgent Running Recorder\\\"\\\"\\\"\\n        return cls(\\n            record_id=data[\\\"record_id\\\"],\\n            current=data[\\\"current\\\"],\\n            node_id=data[\\\"node_id\\\"],\\n            node_type=data[\\\"node_type\\\"],\\n            data=data[\\\"data\\\"],\\n            create_time=data[\\\"create_time\\\"],\\n            update_time=data[\\\"update_time\\\"],\\n            is_deleted=data[\\\"is_deleted\\\"],\\n        )\\n\",\n            \"name_column\": 8\n        }\n    },\n    \"XAgentServer/models/global_png.py\": {\n        \"add_to_map\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"add_to_map\",\n            \"md_content\": \"\",\n            \"code_start_line\": 4,\n            \"code_end_line\": 5,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"def add_to_map(key, value):\\n    global_map[key] = value\\n\",\n            \"name_column\": 4\n        },\n        \"lookup_in_map\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"lookup_in_map\",\n            \"md_content\": \"\",\n            \"code_start_line\": 8,\n            \"code_end_line\": 9,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"def lookup_in_map(key):\\n    return global_map.get(key)\\n\",\n            \"name_column\": 4\n        }\n    },\n    \"XAgentServer/models/parameter.py\": {\n        \"InteractionParameter\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"InteractionParameter\",\n            \"md_content\": \"\",\n            \"code_start_line\": 6,\n            \"code_end_line\": 39,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"class InteractionParameter(metaclass=abc.ABCMeta):\\n    \\\"\\\"\\\"\\n    \\n    \\\"\\\"\\\"\\n\\n    def __init__(self,\\n                    interaction_id: str,\\n                    parameter_id: str,\\n                    args: Union[str, dict, None] = None\\n                    ):\\n        self.interaction_id = interaction_id\\n        self.args = args\\n        self.parameter_id = parameter_id\\n\\n    def to_dict(self):\\n        return {\\n            \\\"interaction_id\\\": self.interaction_id,\\n            \\\"parameter_id\\\": self.parameter_id,\\n            \\\"args\\\": self.args,\\n        }\\n\\n    def to_json(self):\\n        return json.dumps(self.to_dict(), indent=2, ensure_ascii=False)\\n\\n    @classmethod\\n    def from_json(cls, json_data):\\n        return cls(**json_data)\\n    \\n    @classmethod\\n    def from_db(cls, interaction):\\n        return cls(interaction.interaction_id,\\n                    interaction.parameter_id,\\n                    interaction.args\\n                    )\",\n            \"name_column\": 6\n        },\n        \"__init__\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"__init__\",\n            \"md_content\": \"\",\n            \"code_start_line\": 11,\n            \"code_end_line\": 18,\n            \"parent\": \"InteractionParameter\",\n            \"have_return\": false,\n            \"code_content\": \"    def __init__(self,\\n                    interaction_id: str,\\n                    parameter_id: str,\\n                    args: Union[str, dict, None] = None\\n                    ):\\n        self.interaction_id = interaction_id\\n        self.args = args\\n        self.parameter_id = parameter_id\\n\",\n            \"name_column\": 8\n        },\n        \"to_dict\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"to_dict\",\n            \"md_content\": \"\",\n            \"code_start_line\": 20,\n            \"code_end_line\": 25,\n            \"parent\": \"InteractionParameter\",\n            \"have_return\": true,\n            \"code_content\": \"    def to_dict(self):\\n        return {\\n            \\\"interaction_id\\\": self.interaction_id,\\n            \\\"parameter_id\\\": self.parameter_id,\\n            \\\"args\\\": self.args,\\n        }\\n\",\n            \"name_column\": 8\n        },\n        \"to_json\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"to_json\",\n            \"md_content\": \"\",\n            \"code_start_line\": 27,\n            \"code_end_line\": 28,\n            \"parent\": \"InteractionParameter\",\n            \"have_return\": true,\n            \"code_content\": \"    def to_json(self):\\n        return json.dumps(self.to_dict(), indent=2, ensure_ascii=False)\\n\",\n            \"name_column\": 8\n        },\n        \"from_json\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"from_json\",\n            \"md_content\": \"\",\n            \"code_start_line\": 31,\n            \"code_end_line\": 32,\n            \"parent\": \"InteractionParameter\",\n            \"have_return\": true,\n            \"code_content\": \"    def from_json(cls, json_data):\\n        return cls(**json_data)\\n\",\n            \"name_column\": 8\n        },\n        \"from_db\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"from_db\",\n            \"md_content\": \"\",\n            \"code_start_line\": 35,\n            \"code_end_line\": 39,\n            \"parent\": \"InteractionParameter\",\n            \"have_return\": true,\n            \"code_content\": \"    def from_db(cls, interaction):\\n        return cls(interaction.interaction_id,\\n                    interaction.parameter_id,\\n                    interaction.args\\n                    )\",\n            \"name_column\": 8\n        }\n    },\n    \"XAgentServer/application/global_val.py\": {\n        \"init_yag\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"init_yag\",\n            \"md_content\": \"\",\n            \"code_start_line\": 19,\n            \"code_end_line\": 30,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"def init_yag(logger):\\n    \\\"\\\"\\\"init yagmail service\\n\\n    Args:\\n        logger (_type_): _description_\\n    \\\"\\\"\\\"\\n    global yag\\n    if XAgentServerEnv.Email.send_email:\\n        yag = yagmail.SMTP(user=XAgentServerEnv.Email.email_user,\\n                           password=XAgentServerEnv.Email.email_password,\\n                           host=XAgentServerEnv.Email.email_host)\\n        logger.info(\\\"init yagmail\\\")\\n\",\n            \"name_column\": 4\n        },\n        \"init_executor\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"init_executor\",\n            \"md_content\": \"\",\n            \"code_start_line\": 33,\n            \"code_end_line\": 43,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"def init_executor(logger):\\n    \\\"\\\"\\\"init a thread pool executor\\n\\n    Args:\\n        logger (_type_): _description_\\n    \\\"\\\"\\\"\\n    global executor\\n    logger.typewriter_log(\\n        title=f\\\"init a thread pool executor, max_workers: {XAgentServerEnv.workers}\\\",\\n        title_color=Fore.RED)\\n    executor = ThreadPoolExecutor(max_workers=XAgentServerEnv.workers)\\n\",\n            \"name_column\": 4\n        }\n    },\n    \"XAgentServer/application/__init__.py\": {},\n    \"XAgentServer/application/dependence.py\": {\n        \"enable_logger\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"enable_logger\",\n            \"md_content\": \"\",\n            \"code_start_line\": 10,\n            \"code_end_line\": 18,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"def enable_logger():\\n    \\\"\\\"\\\"logger\\\"\\\"\\\"\\n    if not os.path.exists(os.path.join(XAgentServerEnv.base_dir, \\\"logs\\\")):\\n        os.makedirs(os.path.join(\\n            XAgentServerEnv.base_dir, \\\"logs\\\"))\\n\\n    logger = Logger(log_dir=os.path.join(\\n        XAgentServerEnv.base_dir, \\\"logs\\\"), log_file=\\\"app.log\\\", log_name=\\\"XAgentServerApp\\\")\\n    return logger\\n\",\n            \"name_column\": 4\n        },\n        \"enable_dependence\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"enable_dependence\",\n            \"md_content\": \"\",\n            \"code_start_line\": 21,\n            \"code_end_line\": 30,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"def enable_dependence(logger):\\n    \\\"\\\"\\\"dependence\\\"\\\"\\\"\\n    logger.typewriter_log(\\n        title=\\\"XAgent Service Init Dependence.\\\",\\n        title_color=Fore.RED)\\n    init_yag(logger)\\n    init_executor(logger)\\n    logger.typewriter_log(\\n        title=\\\"XAgent Service Init Dependence: Complete!\\\",\\n        title_color=Fore.RED)\\n\",\n            \"name_column\": 4\n        },\n        \"get_db\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"get_db\",\n            \"md_content\": \"\",\n            \"code_start_line\": 33,\n            \"code_end_line\": 43,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"def get_db():\\n    \\\"\\\"\\\"db\\\"\\\"\\\"\\n    session = SessionLocal()\\n    try:\\n        yield session\\n        session.commit()\\n    except Exception as e:\\n        session.rollback()\\n        raise e\\n    finally:\\n        session.close()\\n\",\n            \"name_column\": 4\n        }\n    },\n    \"XAgentServer/application/main.py\": {\n        \"db_session_middleware\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"db_session_middleware\",\n            \"md_content\": \"\",\n            \"code_start_line\": 20,\n            \"code_end_line\": 58,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"async def db_session_middleware(request: Request, call_next):\\n    \\\"\\\"\\\"\\n    Exception middleware\\n    \\\"\\\"\\\"\\n    # \\n    message = \\\"Internal server error\\\"\\n    response = Response(message, status_code=500)\\n    try:\\n        response = await call_next(request)\\n    except XAgentDBError as error:\\n        traceback.print_exc()\\n        message = \\\"XAgent DB Error.\\\" if XAgentServerEnv.prod else error.message\\n        response = JSONResponse(\\n            status_code=500,\\n            content={\\\"status\\\": \\\"failed\\\", \\\"message\\\": message}\\n        )\\n    except XAgentFileError as error:\\n        traceback.print_exc()\\n        message = \\\"XAgent File Error.\\\" if XAgentServerEnv.prod else error.message\\n        response = JSONResponse(\\n            status_code=500,\\n            content={\\\"status\\\": \\\"failed\\\", \\\"message\\\": message}\\n        )\\n    except XAgentAuthError as error:\\n        traceback.print_exc()\\n        response = JSONResponse(\\n            status_code=401,\\n            content={\\\"status\\\": \\\"failed\\\", \\\"message\\\": error.message}\\n        )\\n    except XAgentError as error:\\n        traceback.print_exc()\\n        message = \\\"XAgent Error.\\\" if XAgentServerEnv.prod else error.message\\n   \\n        response = JSONResponse(\\n            status_code=500,\\n            content={\\\"status\\\": \\\"failed\\\", \\\"message\\\": message}\\n        )\\n\\n    return response\\n\",\n            \"name_column\": 10\n        },\n        \"print_start_message\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"print_start_message\",\n            \"md_content\": \"\",\n            \"code_start_line\": 61,\n            \"code_end_line\": 100,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"async def print_start_message():\\n    \\\"\\\"\\\"\\n    print start message\\n    \\\"\\\"\\\"\\n    logger.typewriter_log(\\n        title=\\\"XAgent Server Dependences:\\\",\\n        title_color=Fore.RED,\\n        content=\\\"\\\"\\\"\\n        Python: 3.10+ \\n        FastAPI: Http server\\n        Websocket: long connect with client\\n        MySQL: save xagent data\\n        SqlAlchemy: ORM with MySQL\\n        Redis: save status of interaction\\n        Threading: run interaction\\n        APScheduler: send data to client and keep alive\\n        FastAPI APIRouter: manage websocket route\\n        XAgentError: XAgentServer.exts.exception_ext\\\"\\\"\\\",\\n        )\\n    logger.typewriter_log(\\n        title=\\\"XAgent Server Version:\\\",\\n        title_color=Fore.RED,\\n        content=\\\"\\\"\\\"\\n        V 1.1.0\\\"\\\"\\\",\\n        )\\n    logger.typewriter_log(\\n        title=\\\"Notes:\\\",\\n        title_color=Fore.RED,\\n        content=\\\"\\\"\\\"\\n        Since V 1.1.0, \\n        Local storage will no longer be supported, replaced by Mysql.\\n        The service depends on Redis and Mysql, \\n        so you need to install Redis and Mysql before using it.\\n        Before you use this service, please ensure that the following services are available:\\n            1. Redis on docker, port: 6379, you can start it by docker, default password: xagent\\n            2. Mysql on docker, port: 3306, you can start it by docker\\n            3. XAgent Tool Server is runnning on port 8080\\n            4. Port 8090 is not occupied\\n        \\\"\\\"\\\",\\n        )\\n\",\n            \"name_column\": 10\n        },\n        \"startup_event\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"startup_event\",\n            \"md_content\": \"\",\n            \"code_start_line\": 103,\n            \"code_end_line\": 110,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"async def startup_event():\\n    \\\"\\\"\\\"start up event\\n    \\\"\\\"\\\"\\n    logger.info(\\\"XAgent Service Startup Param:\\\")\\n    for key, item in XAgentServerEnv.__dict__.items():\\n        if not key.startswith(\\\"__\\\"):\\n            logger.info(f\\\"{' '*10}{key}: {item}\\\")\\n    enable_dependence(logger)\\n\",\n            \"name_column\": 10\n        },\n        \"startup\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"startup\",\n            \"md_content\": \"\",\n            \"code_start_line\": 114,\n            \"code_end_line\": 123,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"async def startup():\\n    \\\"\\\"\\\"\\n    start up event\\n    \\\"\\\"\\\"\\n    await startup_event()\\n    if XAgentServerEnv.default_login:\\n        logger.typewriter_log(\\n            title=\\\"Default user: Guest, token: xagent, you can use it to login\\\",\\n            title_color=Fore.RED)\\n    await print_start_message()\\n\",\n            \"name_column\": 10\n        },\n        \"shutdown\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"shutdown\",\n            \"md_content\": \"\",\n            \"code_start_line\": 127,\n            \"code_end_line\": 131,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"async def shutdown():\\n    \\\"\\\"\\\"\\n    shut down event\\n    \\\"\\\"\\\"\\n    print(\\\"XAgent Service Shutdown!\\\")\\n\",\n            \"name_column\": 10\n        },\n        \"validation_exception_handler\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"validation_exception_handler\",\n            \"md_content\": \"\",\n            \"code_start_line\": 135,\n            \"code_end_line\": 148,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"async def validation_exception_handler(request: Request, exc: RequestValidationError):\\n    \\\"\\\"\\\"handle validation exception\\n\\n    Args:\\n        request (Request): _description_\\n        exc (RequestValidationError): _description_\\n\\n    Returns:\\n        _type_: _description_\\n    \\\"\\\"\\\"\\n    return JSONResponse(\\n        status_code=400,\\n        content={\\\"status\\\": \\\"failed\\\", \\\"message\\\": exc.errors()}\\n    )\\n\",\n            \"name_column\": 10\n        }\n    },\n    \"XAgentServer/application/routers/user.py\": {\n        \"register\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"register\",\n            \"md_content\": \"\",\n            \"code_start_line\": 21,\n            \"code_end_line\": 56,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"async def register(email: str = Form(...),\\n                   name: str = Form(...),\\n                   corporation: str = Form(...),\\n                   position: str = Form(...),\\n                   industry: str = Form(...),\\n                   db: Session = Depends(get_db)) -> ResponseBody:\\n    \\\"\\\"\\\"\\n    register user\\n    \\\"\\\"\\\"\\n    if UserCRUD.is_exist(db=db, email=email):\\n        return ResponseBody(success=False, message=\\\"user is already exist\\\")\\n\\n    token = uuid.uuid4().hex\\n    user = {\\\"user_id\\\": uuid.uuid4().hex, \\\"email\\\": email, \\\"name\\\": name,\\n            \\\"token\\\": token, \\\"available\\\": False, \\\"corporation\\\": corporation,\\n            \\\"position\\\": position, \\\"industry\\\": industry,\\n            \\\"create_time\\\": datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\"),\\n            \\\"update_time\\\": datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\"),\\n            \\\"is_beta\\\": False}\\n    try:\\n\\n        contents = email_content(user)\\n\\n        if XAgentServerEnv.Email.send_email:\\n            from XAgentServer.application.global_val import yag\\n            yag.send(user[\\\"email\\\"], 'XAgent Token Verification', contents)\\n        else:\\n            user[\\\"available\\\"] = True\\n        UserCRUD.add_user(db=db, user_dict=user)\\n    except smtplib.SMTPAuthenticationError:\\n        return ResponseBody(success=False, message=\\\"email send failed!\\\", data=None)\\n\\n    except Exception:\\n        return ResponseBody(success=False, message=\\\"register failed\\\", data=None)\\n\\n    return ResponseBody(data=user, success=True, message=\\\"Register success, we will send a email to you!\\\")\\n\",\n            \"name_column\": 10\n        },\n        \"auth\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"auth\",\n            \"md_content\": \"\",\n            \"code_start_line\": 60,\n            \"code_end_line\": 85,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"async def auth(user_id: str = Query(...),\\n               token: str = Query(...),\\n               db: Session = Depends(get_db)\\n               ) -> ResponseBody:\\n    \\\"\\\"\\\"\\n    user auth\\n    \\\"\\\"\\\"\\n    user = UserCRUD.get_user(db=db, user_id=user_id)\\n    if user is None:\\n        return ResponseBody(success=False, message=\\\"user is not exist\\\")\\n\\n    if user.token != token:\\n        return ResponseBody(success=False, message=\\\"token is not correct\\\")\\n    expired_time = datetime.now() - datetime.strptime(\\n        user.update_time, \\\"%Y-%m-%d %H:%M:%S\\\")\\n    if expired_time.seconds > 60 * 60 * 24 * 7:\\n        return ResponseBody(success=False, message=\\\"token is expired\\\")\\n    if not user.available:\\n\\n        user.available = True\\n        user.update_time = datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\")\\n        UserCRUD.update_user(db=db, user=user)\\n    else:\\n        return ResponseBody(success=False, message=\\\"user is already available!\\\")\\n\\n    return ResponseBody(data=user.to_dict(), success=True, message=\\\"auth success\\\")\\n\",\n            \"name_column\": 10\n        },\n        \"login\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"login\",\n            \"md_content\": \"\",\n            \"code_start_line\": 89,\n            \"code_end_line\": 104,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"async def login(email: str = Form(...),\\n                token: str = Form(...),\\n                db: Session = Depends(get_db)) -> ResponseBody:\\n    \\\"\\\"\\\"\\n    login\\n    \\\"\\\"\\\"\\n    user = UserCRUD.get_user(db=db, email=email)\\n    if user is None:\\n        return ResponseBody(success=False, message=\\\"user is not exist\\\")\\n\\n    if user.token != token:\\n        return ResponseBody(success=False, message=\\\"token is not correct\\\")\\n    if not user.available:\\n        return ResponseBody(success=False, message=\\\"user is not available\\\")\\n\\n    return ResponseBody(data=user.to_dict(), success=True, message=\\\"login success\\\")\\n\",\n            \"name_column\": 10\n        },\n        \"check\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"check\",\n            \"md_content\": \"\",\n            \"code_start_line\": 108,\n            \"code_end_line\": 120,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"async def check(token: str = Form(...), db: Session = Depends(get_db)) -> ResponseBody:\\n    \\\"\\\"\\\"\\n    check token is effective\\n    \\\"\\\"\\\"\\n    if token is None:\\n        return ResponseBody(success=False, message=\\\"token is none\\\")\\n\\n    result = UserCRUD.token_is_exist(db=db, token=token, user_id=None)\\n\\n    if result:\\n        return ResponseBody(data=result, success=True, message=\\\"token is effective\\\")\\n\\n    return ResponseBody(data=result, success=True, message=\\\"token is invalid\\\")\\n\",\n            \"name_column\": 10\n        }\n    },\n    \"XAgentServer/application/routers/__init__.py\": {},\n    \"XAgentServer/application/routers/conv.py\": {\n        \"user_is_available\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"user_is_available\",\n            \"md_content\": \"\",\n            \"code_start_line\": 31,\n            \"code_end_line\": 44,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"def user_is_available(\\n        user_id: str = Form(...),\\n        token: str = Form(...),\\n        db: Session = Depends(get_db)):\\n    \\\"\\\"\\\"\\n    check user is available    \\n    \\\"\\\"\\\"\\n    if user_id == \\\"\\\":\\n        raise XAgentAuthError(\\\"user_id is empty!\\\")\\n    if not UserCRUD.is_exist(db=db, user_id=user_id):\\n        raise XAgentAuthError(\\\"user is not exist!\\\")\\n    if not UserCRUD.user_is_valid(db=db, user_id=user_id, token=token):\\n        raise XAgentAuthError(\\\"user is not available!\\\")\\n    return user_id\\n\",\n            \"name_column\": 4\n        },\n        \"get_all_interactions\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"get_all_interactions\",\n            \"md_content\": \"\",\n            \"code_start_line\": 48,\n            \"code_end_line\": 60,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"async def get_all_interactions(user_id: str = Depends(user_is_available),\\n                               page_size: int = Form(...),\\n                               page_num: int = Form(...),\\n                               db: Session = Depends(get_db)) -> ResponseBody:\\n    \\\"\\\"\\\"\\n    get all interactions by user_id\\n    \\\"\\\"\\\"\\n\\n    data = InteractionCRUD.search_interaction_by_user_id(db=db,\\n                                                         user_id=user_id,\\n                                                         page_size=page_size,\\n                                                         page_num=page_num)\\n    return ResponseBody(data=data, success=True, message=\\\"success\\\")\\n\",\n            \"name_column\": 10\n        },\n        \"init_conv_env\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"init_conv_env\",\n            \"md_content\": \"\",\n            \"code_start_line\": 64,\n            \"code_end_line\": 92,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"def init_conv_env(user_id: str = Depends(user_is_available),\\n                  db: Session = Depends(get_db)):\\n    \\\"\\\"\\\"\\n    initialize conv env\\n    \\\"\\\"\\\"\\n\\n    interaction = InteractionCRUD.get_ready_interaction(db=db, user_id=user_id)\\n\\n    if interaction is None:\\n        interaction_id = uuid.uuid4().hex\\n        base = InteractionBase(interaction_id=interaction_id,\\n                               user_id=user_id,\\n                               create_time=datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\"),\\n                               description=\\\"XAgent\\\",\\n                               agent=\\\"\\\",\\n                               mode=\\\"\\\",\\n                               file_list=[],\\n                               recorder_root_dir=\\\"\\\",\\n                               status=\\\"ready\\\",\\n                               message=\\\"ready...\\\",\\n                               current_step=\\\"-1\\\",\\n                               update_time=datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\")\\n                               )\\n        InteractionCRUD.create_interaction(db=db, base=base)\\n    else:\\n        interaction_id = interaction.interaction_id\\n\\n    return ResponseBody(data={\\\"id\\\": interaction_id,\\n                              \\\"t\\\": str(int(datetime.now().timestamp() * 1000))}, success=True, message=\\\"success\\\")\\n\",\n            \"name_column\": 4\n        },\n        \"get_share_interactions\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"get_share_interactions\",\n            \"md_content\": \"\",\n            \"code_start_line\": 96,\n            \"code_end_line\": 106,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"async def get_share_interactions(user_id: str = Depends(user_is_available),\\n                                 page_size: int = Form(...),\\n                                 page_num: int = Form(...),\\n                                 db: Session = Depends(get_db)) -> ResponseBody:\\n    \\\"\\\"\\\"\\n    get all interactions by user id\\n    \\\"\\\"\\\"\\n\\n    data = InteractionCRUD.search_many_shared(\\n        db=db, page_size=page_size, page_index=page_num)\\n    return ResponseBody(data=data, success=True, message=\\\"success\\\")\\n\",\n            \"name_column\": 10\n        },\n        \"share_interaction\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"share_interaction\",\n            \"md_content\": \"\",\n            \"code_start_line\": 110,\n            \"code_end_line\": 168,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"async def share_interaction(user_id: str = Depends(user_is_available),\\n                            interaction_id: str = Form(...),\\n                            db: Session = Depends(get_db)) -> ResponseBody:\\n    \\\"\\\"\\\"\\n    update_interaction_description\\n    \\\"\\\"\\\"\\n    interaction = InteractionCRUD.get_interaction(db=db,\\n                                                  interaction_id=interaction_id)\\n    if interaction is None:\\n        return ResponseBody(success=False,\\n                            message=f\\\"Don't find any interaction by interaction_id: \\\\\\n                                {interaction_id}, Please check your interaction_id!\\\")\\n\\n    finish_status = InteractionCRUD.get_finish_status(\\n        db=db, interaction_id=interaction_id)\\n    if not finish_status:\\n        return ResponseBody(success=False, message=\\\"interaction is not finish!\\\")\\n    user = UserCRUD.get_user(db=db, user_id=user_id)\\n    user_name = user.name\\n    interaction_dir = os.path.join(XAgentServerEnv.base_dir,\\n                                   \\\"localstorage\\\",\\n                                   \\\"interact_records\\\",\\n                                   interaction.create_time[:10],\\n                                   interaction_id)\\n    workspace_dir = os.path.join(interaction_dir, \\\"workspace\\\")\\n    zip_file = os.path.join(interaction_dir, \\\"workspace.zip\\\")\\n    if not os.path.exists(zip_file):\\n        if os.path.exists(workspace_dir):\\n            files = os.listdir(workspace_dir)\\n            # zip workspace\\n            with zipfile.ZipFile(zip_file, 'w', zipfile.ZIP_DEFLATED) as z:\\n                for f in files:\\n                    file = os.path.join(workspace_dir, f)\\n                    z.write(file, arcname=f)\\n\\n    raws = InteractionCRUD.search_many_raws(\\n        db=db, interaction_id=interaction_id)\\n\\n    share_data = {\\n        \\\"user_id\\\": user_id,\\n        \\\"user_name\\\": user_name,\\n        \\\"token\\\": user.token,\\n        \\\"interaction\\\": json.dumps(interaction.to_dict(), ensure_ascii=False),\\n        \\\"raws\\\": json.dumps([raw.to_dict() for raw in raws], ensure_ascii=False),\\n    }\\n\\n    with open(zip_file, 'rb') as f:\\n        files = {\\\"files\\\": f.read()}\\n    try:\\n        res = requests.post(url=XAgentServerEnv.share_url,\\n                            data=share_data,\\n                            files=files,\\n                            timeout=60)\\n\\n        data = res.json()\\n\\n        return ResponseBody(**data)\\n    except Exception as e:\\n        return ResponseBody(success=False, message=str(e), data=None)\\n\",\n            \"name_column\": 10\n        },\n        \"community\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"community\",\n            \"md_content\": \"\",\n            \"code_start_line\": 172,\n            \"code_end_line\": 250,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"def community(user_id: str = Depends(user_is_available),\\n              user_name: str = Form(...),\\n              interaction: str = Form(...),\\n              raws: str = Form(...),\\n              files: UploadFile = File(...),\\n              db: Session = Depends(get_db)):\\n    \\\"\\\"\\\"\\n    community, this api is runing on x-agent.net\\n    \\\"\\\"\\\"\\n    interaction = json.loads(interaction)\\n    raws = json.loads(raws)\\n    interaction_id = interaction[\\\"interaction_id\\\"]\\n    old_share = InteractionCRUD.get_shared_interaction(\\n        db=db, interaction_id=interaction_id)\\n\\n    # \\n    if old_share:\\n        raise XAgentWebError(\\\"interaction is exist!\\\")\\n\\n    contain_finish = False\\n    for raw in raws:\\n        if raw[\\\"status\\\"] == StatusEnum.FINISHED:\\n            contain_finish = True\\n            break\\n    # finish\\n    if not contain_finish:\\n        raise XAgentWebError(\\\"interaction is not finish!\\\")\\n\\n    interaction_dir = os.path.join(XAgentServerEnv.base_dir,\\n                                   \\\"localstorage\\\",\\n                                   \\\"interact_records\\\",\\n                                   interaction[\\\"create_time\\\"][:10],\\n                                   interaction_id,\\n                                   \\\"workspace\\\")\\n\\n    if not os.path.exists(interaction_dir):\\n        os.makedirs(interaction_dir)\\n\\n    # \\n    with open(os.path.join(interaction_dir, \\\"workspace.zip\\\"), \\\"wb\\\") as f:\\n        f.write(files.file.read())\\n\\n    # \\n    with zipfile.ZipFile(file=os.path.join(interaction_dir, \\\"workspace.zip\\\"), mode=\\\"r\\\") as zip_file:\\n        zip_list = zip_file.namelist()  # \\n        for f in zip_list:\\n            zip_file.extract(f, interaction_dir)  # \\n\\n    # \\n    os.remove(os.path.join(interaction_dir, \\\"workspace.zip\\\"))\\n\\n    base = InteractionBase(**interaction)\\n\\n    share = SharedInteractionBase(\\n        interaction_id=interaction_id,\\n        user_name=user_name,\\n        create_time=interaction[\\\"create_time\\\"],\\n        update_time=interaction[\\\"update_time\\\"],\\n        description=interaction[\\\"description\\\"],\\n        agent=interaction[\\\"agent\\\"],\\n        mode=interaction[\\\"mode\\\"],\\n        is_deleted=False,\\n        star=0,\\n        is_audit=False\\n    )\\n\\n    InteractionCRUD.create_interaction(db=db, base=base)\\n\\n    InteractionCRUD.add_share(db=db, share=share)\\n\\n    for raw in raws:\\n        old_raw = InteractionCRUD.get_raw(db=db,\\n                                          interaction_id=interaction_id,\\n                                          node_id=raw[\\\"node_id\\\"])\\n        if old_raw is None:\\n            xraw = XAgentRaw(**raw)\\n            InteractionCRUD.insert_raw(db=db, process=xraw)\\n\\n    return ResponseBody(data=None, success=True, message=\\\"success\\\")\\n\",\n            \"name_column\": 4\n        },\n        \"delete_interaction\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"delete_interaction\",\n            \"md_content\": \"\",\n            \"code_start_line\": 254,\n            \"code_end_line\": 264,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"async def delete_interaction(user_id: str = Depends(user_is_available),\\n                             interaction_id: str = Form(...),\\n                             db: Session = Depends(get_db)) -> ResponseBody:\\n    \\\"\\\"\\\"\\n    delete\\n    \\\"\\\"\\\"\\n\\n    data = InteractionCRUD.delete_interaction(db=db,\\n                                              interaction_id=interaction_id)\\n\\n    return ResponseBody(data=data, success=True, message=\\\"success\\\")\\n\",\n            \"name_column\": 10\n        },\n        \"update_interaction_parameter\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"update_interaction_parameter\",\n            \"md_content\": \"\",\n            \"code_start_line\": 268,\n            \"code_end_line\": 293,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"async def update_interaction_parameter(user_id: str = Depends(user_is_available),\\n                                       mode: str = Form(...),\\n                                       agent: str = Form(...),\\n                                       file_list: List[str] = Form(...),\\n                                       interaction_id: str = Form(...),\\n                                       db: Session = Depends(get_db)\\n                                       ) -> ResponseBody:\\n    \\\"\\\"\\\"\\n    update parameter\\n\\n    \\\"\\\"\\\"\\n    if interaction_id == \\\"\\\":\\n        return ResponseBody(success=False, message=\\\"interaction_id is empty!\\\")\\n    interaction = InteractionCRUD.get_interaction(db=db,\\n                                                  interaction_id=interaction_id)\\n    if interaction is None:\\n        return ResponseBody(success=False, message=f\\\"Don't find any interaction by interaction_id:\\\\\\n            {interaction_id}, Please check your interaction_id!\\\")\\n    update_data = {\\n        \\\"interaction_id\\\": interaction_id,\\n        \\\"agent\\\": agent,\\n        \\\"mode\\\": mode,\\n        \\\"file_list\\\": [json.loads(l) for l in file_list],\\n    }\\n    InteractionCRUD.update_interaction(db=db, base_data=update_data)\\n    return ResponseBody(data=update_data, success=True, message=\\\"success!\\\")\\n\",\n            \"name_column\": 10\n        },\n        \"update_interaction_description\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"update_interaction_description\",\n            \"md_content\": \"\",\n            \"code_start_line\": 297,\n            \"code_end_line\": 318,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"async def update_interaction_description(user_id: str = Depends(user_is_available),\\n                                         description: str = Form(...),\\n                                         interaction_id: str = Form(...),\\n                                         db: Session = Depends(get_db)\\n                                         ) -> ResponseBody:\\n    \\\"\\\"\\\"\\n    update description\\n\\n    \\\"\\\"\\\"\\n    if interaction_id == \\\"\\\":\\n        return ResponseBody(success=False, message=\\\"interaction_id is empty!\\\")\\n    interaction = InteractionCRUD.get_interaction(db=db,\\n                                                  interaction_id=interaction_id)\\n    if interaction is None:\\n        return ResponseBody(success=False, message=f\\\"Don't find any interaction by interaction_id:\\\\\\n            {interaction_id}, Please check your interaction_id!\\\")\\n    update_data = {\\n        \\\"interaction_id\\\": interaction_id,\\n        \\\"description\\\": description if description else \\\"XAgent\\\",\\n    }\\n    InteractionCRUD.update_interaction(db=db, base_data=update_data)\\n    return ResponseBody(data=update_data, success=True, message=\\\"success!\\\")\\n\",\n            \"name_column\": 10\n        }\n    },\n    \"XAgentServer/application/routers/workspace.py\": {\n        \"user_is_available\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"user_is_available\",\n            \"md_content\": \"\",\n            \"code_start_line\": 24,\n            \"code_end_line\": 38,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"def user_is_available(\\n        user_id: str = Form(...),\\n        token: str = Form(...),\\n        db: Session = Depends(get_db)):\\n    \\\"\\\"\\\"\\n    check user is available    \\n    \\\"\\\"\\\"\\n    if user_id == \\\"\\\":\\n        raise HTTPException(status_code=401, detail=\\\"user_id is empty!\\\")\\n    if not UserCRUD.is_exist(db=db, user_id=user_id):\\n        raise HTTPException(status_code=401, detail=\\\"user is not exist!\\\")\\n    if not UserCRUD.user_is_valid(db=db, user_id=user_id, token=token):\\n        raise HTTPException(\\n            status_code=401, detail=\\\"user is not available!\\\")\\n    return user_id\\n\",\n            \"name_column\": 4\n        },\n        \"create_upload_files\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"create_upload_files\",\n            \"md_content\": \"\",\n            \"code_start_line\": 42,\n            \"code_end_line\": 67,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"async def create_upload_files(files: List[UploadFile] = File(...),\\n                              user_id: str = Depends(user_is_available)) -> ResponseBody:\\n    \\\"\\\"\\\"Upload Files\\\"\\\"\\\"\\n\\n    if len(files) == 0:\\n        return ResponseBody(success=False, message=\\\"files is empty!\\\")\\n    if len(files) > 5:\\n        files = files[:5]\\n\\n    if not os.path.exists(os.path.join(XAgentServerEnv.Upload.upload_dir, user_id)):\\n        os.makedirs(os.path.join(XAgentServerEnv.Upload.upload_dir, user_id))\\n\\n    for f in files:\\n        if f.size > 1024 * 1024 * 1:\\n            return ResponseBody(success=False,\\n                                message=\\\"file size is too large, limit is 1MB for each file!\\\")\\n\\n    file_list = []\\n    for file in files:\\n        file_name = uuid.uuid4().hex + os.path.splitext(file.filename)[-1]\\n        with open(os.path.join(XAgentServerEnv.Upload.upload_dir, user_id, file_name), \\\"wb\\\") as f:\\n            f.write(await file.read())\\n            file_list.append({\\\"uuid\\\": file_name, \\\"name\\\": file.filename})\\n    return ResponseBody(data={\\\"user_id\\\": user_id,\\n                              \\\"file_list\\\": file_list},\\n                        success=True, message=\\\"upload success\\\")\\n\",\n            \"name_column\": 10\n        },\n        \"file\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"file\",\n            \"md_content\": \"\",\n            \"code_start_line\": 71,\n            \"code_end_line\": 139,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"async def file(user_id: str = Depends(user_is_available),\\n               interaction_id: str = Form(...),\\n               db: Session = Depends(get_db),\\n               file_name: str = Form(...)):\\n    \\\"\\\"\\\"\\n    get download file\\n    \\\"\\\"\\\"\\n    interaction = InteractionCRUD.get_interaction(db=db, interaction_id=interaction_id)\\n\\n    if interaction is None:\\n        return ResponseBody(success=False, message=\\\"interaction is not exist!\\\")\\n\\n    time_str = interaction.create_time[:10]\\n\\n    file_path = os.path.join(\\n        XAgentServerEnv.base_dir,\\n        \\\"localstorage/interact_records\\\",\\n        time_str,\\n        interaction_id,\\n        \\\"workspace\\\")\\n    if not os.path.exists(file_path):\\n        return ResponseBody(success=False,\\n                            message=\\\"file is not exist!\\\")\\n\\n    file_suffix = file_name.split(\\\".\\\")[-1]\\n    if file_suffix in [\\\"jpg\\\", \\\"png\\\",\\n                       \\\"jpeg\\\", \\\"gif\\\", \\\"bmp\\\"]:\\n        with open(os.path.join(file_path, file_name), \\\"rb\\\") as f:\\n            data = base64.b64encode(f.read()).decode(\\\"utf-8\\\")\\n        return ResponseBody(\\n            data=f\\\"data:image/{file_suffix};base64,{data}\\\",\\n            success=True,\\n            message=\\\"get file success!\\\"\\n        )\\n\\n    if file_suffix in [\\\"mp4\\\", \\\"avi\\\", \\\"mkv\\\",\\n                       \\\"rmvb\\\", \\\"rm\\\", \\\"flv\\\", \\\"3gp\\\", \\\"wmv\\\"]:\\n        return FileResponse(os.path.join(file_path, file_name),\\n                            media_type=\\\"video/\\\" + file_suffix)\\n\\n    if file_suffix in [\\\"mp3\\\", \\\"wav\\\", \\\"wma\\\",\\n                       \\\"ogg\\\", \\\"aac\\\", \\\"flac\\\", \\\"ape\\\"]:\\n        return FileResponse(os.path.join(file_path, file_name),\\n                            media_type=\\\"audio/\\\" + file_suffix)\\n\\n    if file_suffix in [\\\"pdf\\\", \\\"doc\\\", \\\"docx\\\",\\n                       \\\"xls\\\", \\\"xlsx\\\", \\\"ppt\\\", \\\"pptx\\\"]:\\n        return FileResponse(os.path.join(file_path, file_name),\\n                            media_type=\\\"application/\\\" + file_suffix)\\n\\n    if file_suffix in [\\\"json\\\"]:\\n        with open(os.path.join(file_path, file_name), 'r', encoding=\\\"utf-8\\\") as f:\\n            data = json.load(f)\\n\\n        return ResponseBody(data=json.dumps(data,\\n                                            ensure_ascii=False,\\n                                            indent=4),\\n                            success=True,\\n                            message=\\\"get file success!\\\")\\n\\n    if file_suffix in [\\\"ipynb\\\"]:\\n        return FileResponse(os.path.join(file_path, file_name),\\n                            media_type=\\\"application/\\\" + file_suffix)\\n    \\n    \\n    with open(os.path.join(file_path, file_name), 'r', encoding=\\\"utf-8\\\") as f:\\n        data = f.read()\\n\\n    return ResponseBody(data=data, success=True, message=\\\"get file success!\\\")\\n\",\n            \"name_column\": 10\n        }\n    },\n    \"XAgentServer/application/core/envs.py\": {\n        \"XAgentServerEnv\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"XAgentServerEnv\",\n            \"md_content\": \"\",\n            \"code_start_line\": 11,\n            \"code_end_line\": 90,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"class XAgentServerEnv:\\n    \\\"\\\"\\\"\\n    XAgentServer environment variables\\n    if you change value of the environment variable, you need to restart \\n    the XAgentServer by running the following command:\\n    `python start_server.py`\\n    or start a unicorn server by yourself\\n    \\\"\\\"\\\"\\n    app = \\\"app:app\\\"\\n    prod: bool = config.get(\\\"PROD\\\", \\\"False\\\").lower() == \\\"true\\\"\\n    base_dir = \\\"XAgentServer\\\"\\n    use_redis: bool = False\\n    recorder_root_dir = \\\"running_records\\\"\\n    # you can set default_login with True,\\n    # use the default user \\\"admin\\\" with token \\\"xagent-admin\\\" to login,\\n    default_login: bool = True\\n    # only one XAgentServer can be set to check whether the interaction is running.\\n    check_running: bool = False\\n    host = \\\"0.0.0.0\\\"\\n    port = 8090\\n    debug = True\\n    reload = True\\n    workers = 1\\n    share_url = \\\"https://x-agent.net/api/conv/community\\\"\\n\\n    class DB:\\n        \\\"\\\"\\\"\\n        database config\\n        \\\"\\\"\\\"\\n        use_db = True\\n        db_url = \\\"mysql+pymysql://root:xagent@localhost:3306/xagent\\\"\\n\\n    class Redis:\\n        \\\"\\\"\\\"\\n        redis config\\n        \\\"\\\"\\\"\\n        use_redis = False\\n        redis_url = \\\"redis://localhost\\\"\\n        redis_host = \\\"localhost\\\"\\n        redis_port = 6379\\n        redis_db = 0\\n        redis_password = \\\"xagent\\\"\\n\\n    # if you want to use email to send message,\\n    # you can set send_email to True and set\\n    # email_host,\\n    # email_port,\\n    # email_user,\\n    # email_password,\\n    # auth_server\\n    class Email:\\n        \\\"\\\"\\\"\\n        email config\\n        \\\"\\\"\\\"\\n        send_email = False\\n        email_host = \\\"\\\"\\n        email_port = 465\\n        email_user = \\\"\\\"\\n        email_password = \\\"\\\"\\n        auth_server = \\\"\\\"\\n\\n    # if you want to use upload function,\\n    # you can set upload_dir to the path of the upload directory\\n    # and set upload_allowed_types of the allowed types\\n    class Upload:\\n        \\\"\\\"\\\"\\n        upload config\\n        \\\"\\\"\\\"\\n        upload_dir = \\\"XAgentServer/localstorage/upload\\\"\\n        if not os.path.exists(upload_dir):\\n            os.makedirs(upload_dir)\\n        upload_allowed_types = [\\\"image/png\\\", \\\"image/jpeg\\\",\\n                                \\\"image/gif\\\", \\\"text/plain\\\",\\n                                \\\"application/msword\\\", \\\"pdf\\\",\\n                                \\\"txt\\\", \\\"pptx\\\", \\\"xlsx\\\",\\n                                \\\"doc\\\", \\\"ppt\\\", \\\"xls\\\",\\n                                \\\"zip\\\", \\\"rar\\\", \\\"tar\\\",\\n                                \\\"gz\\\", \\\"7z\\\", \\\"bz2\\\",\\n                                \\\"tgz\\\", \\\"tbz2\\\", \\\"tar.gz\\\",\\n                                \\\"tar.bz2\\\"]\\n\",\n            \"name_column\": 6\n        },\n        \"DB\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"DB\",\n            \"md_content\": \"\",\n            \"code_start_line\": 36,\n            \"code_end_line\": 41,\n            \"parent\": \"XAgentServerEnv\",\n            \"have_return\": false,\n            \"code_content\": \"    class DB:\\n        \\\"\\\"\\\"\\n        database config\\n        \\\"\\\"\\\"\\n        use_db = True\\n        db_url = \\\"mysql+pymysql://root:xagent@localhost:3306/xagent\\\"\\n\",\n            \"name_column\": 10\n        },\n        \"Redis\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"Redis\",\n            \"md_content\": \"\",\n            \"code_start_line\": 43,\n            \"code_end_line\": 52,\n            \"parent\": \"XAgentServerEnv\",\n            \"have_return\": false,\n            \"code_content\": \"    class Redis:\\n        \\\"\\\"\\\"\\n        redis config\\n        \\\"\\\"\\\"\\n        use_redis = False\\n        redis_url = \\\"redis://localhost\\\"\\n        redis_host = \\\"localhost\\\"\\n        redis_port = 6379\\n        redis_db = 0\\n        redis_password = \\\"xagent\\\"\\n\",\n            \"name_column\": 10\n        },\n        \"Email\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"Email\",\n            \"md_content\": \"\",\n            \"code_start_line\": 61,\n            \"code_end_line\": 70,\n            \"parent\": \"XAgentServerEnv\",\n            \"have_return\": false,\n            \"code_content\": \"    class Email:\\n        \\\"\\\"\\\"\\n        email config\\n        \\\"\\\"\\\"\\n        send_email = False\\n        email_host = \\\"\\\"\\n        email_port = 465\\n        email_user = \\\"\\\"\\n        email_password = \\\"\\\"\\n        auth_server = \\\"\\\"\\n\",\n            \"name_column\": 10\n        },\n        \"Upload\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"Upload\",\n            \"md_content\": \"\",\n            \"code_start_line\": 75,\n            \"code_end_line\": 90,\n            \"parent\": \"XAgentServerEnv\",\n            \"have_return\": false,\n            \"code_content\": \"    class Upload:\\n        \\\"\\\"\\\"\\n        upload config\\n        \\\"\\\"\\\"\\n        upload_dir = \\\"XAgentServer/localstorage/upload\\\"\\n        if not os.path.exists(upload_dir):\\n            os.makedirs(upload_dir)\\n        upload_allowed_types = [\\\"image/png\\\", \\\"image/jpeg\\\",\\n                                \\\"image/gif\\\", \\\"text/plain\\\",\\n                                \\\"application/msword\\\", \\\"pdf\\\",\\n                                \\\"txt\\\", \\\"pptx\\\", \\\"xlsx\\\",\\n                                \\\"doc\\\", \\\"ppt\\\", \\\"xls\\\",\\n                                \\\"zip\\\", \\\"rar\\\", \\\"tar\\\",\\n                                \\\"gz\\\", \\\"7z\\\", \\\"bz2\\\",\\n                                \\\"tgz\\\", \\\"tbz2\\\", \\\"tar.gz\\\",\\n                                \\\"tar.bz2\\\"]\\n\",\n            \"name_column\": 10\n        }\n    },\n    \"XAgentServer/application/websockets/replayer.py\": {\n        \"ReplayServer\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"ReplayServer\",\n            \"md_content\": \"\",\n            \"code_start_line\": 29,\n            \"code_end_line\": 195,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"class ReplayServer(WebSocketEndpoint):\\n    \\\"\\\"\\\"Main Websocket Server\\n    Extends:\\n        WebSocketEndpoint\\n    \\n    Description:\\n        In this websocket, we will receive the args from user,\\n        and you can use it to run the interaction.\\n        specifically, the args is a dict, \\n        and it must contain a key named \\\"goal\\\" to tell XAgent what do you want to do.\\n\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, websocket: WebSocket, db: Session = Depends(get_db), client_id: str = \\\"\\\"):\\n        super().__init__(websocket.scope, websocket.receive, websocket.send)\\n        self.db = db\\n        self.client_id: str = client_id\\n        self.websocket = websocket\\n        self.date_str = datetime.now().strftime(\\\"%Y-%m-%d\\\")\\n        self.log_dir = \\\"\\\"\\n        self.logger = None\\n        self.scheduler = AsyncIOScheduler()\\n        \\n    async def dispatch(self) -> None:\\n        \\\"\\\"\\\"_summary_\\n\\n        Raises:\\n            exc: _description_\\n        \\\"\\\"\\\"\\n        websocket = WebSocket(self.scope, receive=self.receive, send=self.send)\\n        close_code = 1000\\n        await self.on_connect(websocket)\\n        try:\\n            while True:\\n                message = await websocket.receive()\\n                if message[\\\"type\\\"] == \\\"websocket.receive\\\":\\n                    data = await self.decode(websocket, message)\\n                    await self.on_receive(websocket, data)\\n                elif message[\\\"type\\\"] == \\\"websocket.disconnect\\\":\\n                    close_code = 1000\\n                    break\\n        except Exception as exc:\\n            close_code = 1011\\n            raise exc\\n        finally:\\n            await self.on_disconnect(websocket, close_code)\\n            if self.scheduler.running:\\n                self.scheduler.shutdown()\\n                self.logger.info(\\\"shutdown scheduler\\\")\\n            if self.db:\\n                self.db.close()\\n                self.logger.info(\\\"close db\\\")\\n            \\n\\n    async def on_connect(self, websocket: WebSocket):\\n        \\\"\\\"\\\"Connect to client\\n\\n        Args:\\n            websocket (WebSocket): A websocket object\\n\\n        Raises:\\n            XAgentWebSocketConnectError: If the user is running, it will raise this error.\\n        \\\"\\\"\\\"\\n\\n        self.log_dir = os.path.join(os.path.join(XAgentServerEnv.base_dir, \\\"localstorage\\\",\\n                                    \\\"interact_records\\\"), self.date_str, self.client_id)\\n        if not os.path.exists(self.log_dir):\\n            os.makedirs(self.log_dir)\\n\\n        self.logger = Logger(\\n            log_dir=self.log_dir, log_file=\\\"replay.log\\\", log_name=f\\\"{self.client_id}_REPLAY\\\")\\n        query_string = self.scope.get(\\\"query_string\\\", b\\\"\\\").decode()\\n        parameters = parse_qs(query_string)\\n        user_id = parameters.get(\\\"user_id\\\", [\\\"\\\"])[0]\\n        token = parameters.get(\\\"token\\\", [\\\"\\\"])[0]\\n        self.logger.typewriter_log(\\n            title=f\\\"Receive connection from {self.client_id}: \\\",\\n            title_color=Fore.RED,\\n            content=f\\\"user_id: {user_id}, token: {token}\\\")\\n        await websocket.accept()\\n        try:\\n            await check_user(db=self.db, user_id=user_id, token=token)\\n            # check running, you can edit it by yourself in envs.py to skip this check\\n            if XAgentServerEnv.check_running:\\n                if InteractionCRUD.is_running(db=self.db, user_id=user_id):\\n                    raise XAgentWebSocketConnectError(\\n                        \\\"You have a running interaction, please wait for it to finish!\\\")\\n        except XAgentWebSocketConnectError as exc:\\n            await websocket.send_text(\\n                WebsocketResponseBody(status=\\\"connect\\\",\\n                                    success=False,\\n                                    message=str(exc),\\n                                    data=None).to_text())\\n            await websocket.close(code=1000)\\n            return\\n        await websocket.send_text(\\n            WebsocketResponseBody(\\n                status=\\\"connect\\\",\\n                success=True,\\n                message=\\\"connect success\\\",\\n                data=None).to_text())\\n\\n    async def on_disconnect(self, websocket: WebSocket, close_code):\\n        \\\"\\\"\\\"When disconnect with client, it will run this function\\n        Override this function to do something when disconnect with client\\n        \\n        Args:\\n            websocket (WebSocket): A websocket object\\n            close_code (_type_): The close code, default is 0\\n        \\\"\\\"\\\"\\n        self.logger.typewriter_log(\\n            title=f\\\"Disconnect with client {self.client_id}: \\\",\\n            title_color=Fore.RED)\\n        \\n\\n    async def on_receive(self, websocket: WebSocket, data: Any):\\n        \\\"\\\"\\\"\\n        When receive data from client, it will run this function\\n        \\n        Args:\\n            websocket (WebSocket): A websocket object\\n            data (any): The data from client\\n        \\\"\\\"\\\"\\n        data = json.loads(data)\\n        self.logger.typewriter_log(\\n            title=f\\\"Receive data from {self.client_id}: \\\",\\n            title_color=Fore.RED,\\n            content=json.dumps(data, indent=4, ensure_ascii=False)\\n        )\\n        if data.get(\\\"type\\\", \\\"\\\") == \\\"ping\\\":\\n            # await self.pong()\\n            pass\\n        elif data.get(\\\"type\\\", \\\"\\\") == \\\"replay\\\":\\n            if not self.scheduler.running:\\n                self.scheduler.add_job(self.pong, \\\"interval\\\", seconds=20)\\n                self.scheduler.add_job(self.send_data, \\\"date\\\", next_run_time=datetime.now())\\n                self.scheduler.start()\\n                 \\n    async def pong(self):\\n        \\\"\\\"\\\"\\n        pong to client for keeping alive\\n        \\\"\\\"\\\"\\n        await self.websocket.send_text(json.dumps({\\\"type\\\": \\\"pong\\\"}, ensure_ascii=False, indent=2))\\n\\n    async def send_data(self):\\n        \\\"\\\"\\\"\\n        send data to client\\n        \\\"\\\"\\\"\\n        \\n        rows = InteractionCRUD.search_many_raws(db=self.db, interaction_id=self.client_id)\\n        for row in rows:\\n            self.logger.typewriter_log(\\n                title=f\\\"Send data to {self.client_id}: \\\",\\n                title_color=Fore.RED,\\n                content=f\\\"Send {row.node_id}data to client, length: {len(json.dumps(row.data))}.\\\"\\n            )\\n            root_dir = os.path.join(XAgentServerEnv.base_dir, \\\"localstorage\\\", \\\"interact_records\\\", row.create_time[:10], row.interaction_id)\\n            await self.websocket.send_text(\\n                WebsocketResponseBody(status=row.status,\\n                                    success=True, message=\\\"success\\\",\\n                                    data=handle_data(row=row, root_dir=root_dir),\\n                                    current=row.current,\\n                                    node_id=row.node_id,\\n                                    workspace_file_list=handle_workspace_filelist(row.file_list)).to_text())\\n            # await asyncio.sleep(random.randint(1, 3))\\n        if self.scheduler.running:\\n            self.scheduler.shutdown()\",\n            \"name_column\": 6\n        },\n        \"__init__\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"__init__\",\n            \"md_content\": \"\",\n            \"code_start_line\": 42,\n            \"code_end_line\": 50,\n            \"parent\": \"ReplayServer\",\n            \"have_return\": false,\n            \"code_content\": \"    def __init__(self, websocket: WebSocket, db: Session = Depends(get_db), client_id: str = \\\"\\\"):\\n        super().__init__(websocket.scope, websocket.receive, websocket.send)\\n        self.db = db\\n        self.client_id: str = client_id\\n        self.websocket = websocket\\n        self.date_str = datetime.now().strftime(\\\"%Y-%m-%d\\\")\\n        self.log_dir = \\\"\\\"\\n        self.logger = None\\n        self.scheduler = AsyncIOScheduler()\\n\",\n            \"name_column\": 8\n        },\n        \"dispatch\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"dispatch\",\n            \"md_content\": \"\",\n            \"code_start_line\": 52,\n            \"code_end_line\": 80,\n            \"parent\": \"ReplayServer\",\n            \"have_return\": false,\n            \"code_content\": \"    async def dispatch(self) -> None:\\n        \\\"\\\"\\\"_summary_\\n\\n        Raises:\\n            exc: _description_\\n        \\\"\\\"\\\"\\n        websocket = WebSocket(self.scope, receive=self.receive, send=self.send)\\n        close_code = 1000\\n        await self.on_connect(websocket)\\n        try:\\n            while True:\\n                message = await websocket.receive()\\n                if message[\\\"type\\\"] == \\\"websocket.receive\\\":\\n                    data = await self.decode(websocket, message)\\n                    await self.on_receive(websocket, data)\\n                elif message[\\\"type\\\"] == \\\"websocket.disconnect\\\":\\n                    close_code = 1000\\n                    break\\n        except Exception as exc:\\n            close_code = 1011\\n            raise exc\\n        finally:\\n            await self.on_disconnect(websocket, close_code)\\n            if self.scheduler.running:\\n                self.scheduler.shutdown()\\n                self.logger.info(\\\"shutdown scheduler\\\")\\n            if self.db:\\n                self.db.close()\\n                self.logger.info(\\\"close db\\\")\\n\",\n            \"name_column\": 14\n        },\n        \"on_connect\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"on_connect\",\n            \"md_content\": \"\",\n            \"code_start_line\": 83,\n            \"code_end_line\": 129,\n            \"parent\": \"ReplayServer\",\n            \"have_return\": true,\n            \"code_content\": \"    async def on_connect(self, websocket: WebSocket):\\n        \\\"\\\"\\\"Connect to client\\n\\n        Args:\\n            websocket (WebSocket): A websocket object\\n\\n        Raises:\\n            XAgentWebSocketConnectError: If the user is running, it will raise this error.\\n        \\\"\\\"\\\"\\n\\n        self.log_dir = os.path.join(os.path.join(XAgentServerEnv.base_dir, \\\"localstorage\\\",\\n                                    \\\"interact_records\\\"), self.date_str, self.client_id)\\n        if not os.path.exists(self.log_dir):\\n            os.makedirs(self.log_dir)\\n\\n        self.logger = Logger(\\n            log_dir=self.log_dir, log_file=\\\"replay.log\\\", log_name=f\\\"{self.client_id}_REPLAY\\\")\\n        query_string = self.scope.get(\\\"query_string\\\", b\\\"\\\").decode()\\n        parameters = parse_qs(query_string)\\n        user_id = parameters.get(\\\"user_id\\\", [\\\"\\\"])[0]\\n        token = parameters.get(\\\"token\\\", [\\\"\\\"])[0]\\n        self.logger.typewriter_log(\\n            title=f\\\"Receive connection from {self.client_id}: \\\",\\n            title_color=Fore.RED,\\n            content=f\\\"user_id: {user_id}, token: {token}\\\")\\n        await websocket.accept()\\n        try:\\n            await check_user(db=self.db, user_id=user_id, token=token)\\n            # check running, you can edit it by yourself in envs.py to skip this check\\n            if XAgentServerEnv.check_running:\\n                if InteractionCRUD.is_running(db=self.db, user_id=user_id):\\n                    raise XAgentWebSocketConnectError(\\n                        \\\"You have a running interaction, please wait for it to finish!\\\")\\n        except XAgentWebSocketConnectError as exc:\\n            await websocket.send_text(\\n                WebsocketResponseBody(status=\\\"connect\\\",\\n                                    success=False,\\n                                    message=str(exc),\\n                                    data=None).to_text())\\n            await websocket.close(code=1000)\\n            return\\n        await websocket.send_text(\\n            WebsocketResponseBody(\\n                status=\\\"connect\\\",\\n                success=True,\\n                message=\\\"connect success\\\",\\n                data=None).to_text())\\n\",\n            \"name_column\": 14\n        },\n        \"on_disconnect\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"on_disconnect\",\n            \"md_content\": \"\",\n            \"code_start_line\": 131,\n            \"code_end_line\": 141,\n            \"parent\": \"ReplayServer\",\n            \"have_return\": false,\n            \"code_content\": \"    async def on_disconnect(self, websocket: WebSocket, close_code):\\n        \\\"\\\"\\\"When disconnect with client, it will run this function\\n        Override this function to do something when disconnect with client\\n        \\n        Args:\\n            websocket (WebSocket): A websocket object\\n            close_code (_type_): The close code, default is 0\\n        \\\"\\\"\\\"\\n        self.logger.typewriter_log(\\n            title=f\\\"Disconnect with client {self.client_id}: \\\",\\n            title_color=Fore.RED)\\n\",\n            \"name_column\": 14\n        },\n        \"on_receive\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"on_receive\",\n            \"md_content\": \"\",\n            \"code_start_line\": 144,\n            \"code_end_line\": 165,\n            \"parent\": \"ReplayServer\",\n            \"have_return\": false,\n            \"code_content\": \"    async def on_receive(self, websocket: WebSocket, data: Any):\\n        \\\"\\\"\\\"\\n        When receive data from client, it will run this function\\n        \\n        Args:\\n            websocket (WebSocket): A websocket object\\n            data (any): The data from client\\n        \\\"\\\"\\\"\\n        data = json.loads(data)\\n        self.logger.typewriter_log(\\n            title=f\\\"Receive data from {self.client_id}: \\\",\\n            title_color=Fore.RED,\\n            content=json.dumps(data, indent=4, ensure_ascii=False)\\n        )\\n        if data.get(\\\"type\\\", \\\"\\\") == \\\"ping\\\":\\n            # await self.pong()\\n            pass\\n        elif data.get(\\\"type\\\", \\\"\\\") == \\\"replay\\\":\\n            if not self.scheduler.running:\\n                self.scheduler.add_job(self.pong, \\\"interval\\\", seconds=20)\\n                self.scheduler.add_job(self.send_data, \\\"date\\\", next_run_time=datetime.now())\\n                self.scheduler.start()\\n\",\n            \"name_column\": 14\n        },\n        \"pong\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"pong\",\n            \"md_content\": \"\",\n            \"code_start_line\": 167,\n            \"code_end_line\": 171,\n            \"parent\": \"ReplayServer\",\n            \"have_return\": false,\n            \"code_content\": \"    async def pong(self):\\n        \\\"\\\"\\\"\\n        pong to client for keeping alive\\n        \\\"\\\"\\\"\\n        await self.websocket.send_text(json.dumps({\\\"type\\\": \\\"pong\\\"}, ensure_ascii=False, indent=2))\\n\",\n            \"name_column\": 14\n        },\n        \"send_data\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"send_data\",\n            \"md_content\": \"\",\n            \"code_start_line\": 173,\n            \"code_end_line\": 195,\n            \"parent\": \"ReplayServer\",\n            \"have_return\": false,\n            \"code_content\": \"    async def send_data(self):\\n        \\\"\\\"\\\"\\n        send data to client\\n        \\\"\\\"\\\"\\n        \\n        rows = InteractionCRUD.search_many_raws(db=self.db, interaction_id=self.client_id)\\n        for row in rows:\\n            self.logger.typewriter_log(\\n                title=f\\\"Send data to {self.client_id}: \\\",\\n                title_color=Fore.RED,\\n                content=f\\\"Send {row.node_id}data to client, length: {len(json.dumps(row.data))}.\\\"\\n            )\\n            root_dir = os.path.join(XAgentServerEnv.base_dir, \\\"localstorage\\\", \\\"interact_records\\\", row.create_time[:10], row.interaction_id)\\n            await self.websocket.send_text(\\n                WebsocketResponseBody(status=row.status,\\n                                    success=True, message=\\\"success\\\",\\n                                    data=handle_data(row=row, root_dir=root_dir),\\n                                    current=row.current,\\n                                    node_id=row.node_id,\\n                                    workspace_file_list=handle_workspace_filelist(row.file_list)).to_text("
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 2.0322265625,
          "content": "# Changelog\n\nAll notable changes to this project will be documented in this file.\n\nThe format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/), and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).\n\n## [1.0.0] - 2023-11-21\n\n### Added\n- Offical release of XAgent Container Images on DockerHub, now you can just download and play XAgent, see our dockerhub [page](https://hub.docker.com/u/xagentteam) for more information.\n- Localhost models [XAgentLlama-7B-preview](https://huggingface.co/XAgentTeam/XAgentLlama-7B-preview), [XAgentLlama-34B-preview](https://huggingface.co/XAgentTeam/XAgentLLaMa-34B-preview) developped for XAgent is now available on HuggingFace, click [here](https://huggingface.co/collections/XAgentTeam/xagentllm-655ae4091c419bb072940e74) to learn more.\n- **XAgentGen** is released to enhance the usability and stability of Localhost models for XAgent. Check out the [XAgentGen](XAgentGen/README.md) for more details.\n- **WebUI** is updated! Now you can browse files in workspace! **History replay** is also available now!\n- Mysql integration for data management, including runtime interactive data and running records.\n- Redis integration for managing the state of components during interaction processes.\n- Docker and initialization for Mysql and Redis included within the project setup.\n- New exception handling processes, with custom exception classes for different runtime errors.\n- Session sharing feature, allowing users to share their sessions with the community.\n\n### Changed\n\n- Removed some global variables, now using `XAgent.core.XAgentCoreComponents` for better modularity and encapsulation.\n- Overhauled the project structure of XAgentServer for improved organization and maintainability.\n\n### Removed\n\n- XAgentIO.\n- Local file storage mode and its support mechanisms.\n\n### Fixed\n\n- Fix various bugs in `XAgentServer` as reported in project issues.\n\n## [0.1.0] - 2023-10-16\n\n- Initial setup and integration of the `Toolserver`, `XAgent`, `XAgentIO`, `XAgentServer`, and `XAgentWeb` components.\n"
        },
        {
          "name": "CODE_OF_CONDUCT.md",
          "type": "blob",
          "size": 5.126953125,
          "content": "# Contributor Covenant Code of Conduct\n\n## Our Pledge\n\nWe as members, contributors, and leaders pledge to make participation in our\ncommunity a harassment-free experience for everyone, regardless of age, body\nsize, visible or invisible disability, ethnicity, sex characteristics, gender\nidentity and expression, level of experience, education, socio-economic status,\nnationality, personal appearance, race, religion, or sexual identity\nand orientation.\n\nWe pledge to act and interact in ways that contribute to an open, welcoming,\ndiverse, inclusive, and healthy community.\n\n## Our Standards\n\nExamples of behavior that contributes to a positive environment for our\ncommunity include:\n\n* Demonstrating empathy and kindness toward other people\n* Being respectful of differing opinions, viewpoints, and experiences\n* Giving and gracefully accepting constructive feedback\n* Accepting responsibility and apologizing to those affected by our mistakes,\n  and learning from the experience\n* Focusing on what is best not just for us as individuals, but for the\n  overall community\n\nExamples of unacceptable behavior include:\n\n* The use of sexualized language or imagery, and sexual attention or\n  advances of any kind\n* Trolling, insulting or derogatory comments, and personal or political attacks\n* Public or private harassment\n* Publishing others' private information, such as a physical or email\n  address, without their explicit permission\n* Other conduct which could reasonably be considered inappropriate in a\n  professional setting\n\n## Enforcement Responsibilities\n\nCommunity leaders are responsible for clarifying and enforcing our standards of\nacceptable behavior and will take appropriate and fair corrective action in\nresponse to any behavior that they deem inappropriate, threatening, offensive,\nor harmful.\n\nCommunity leaders have the right and responsibility to remove, edit, or reject\ncomments, commits, code, wiki edits, issues, and other contributions that are\nnot aligned to this Code of Conduct, and will communicate reasons for moderation\ndecisions when appropriate.\n\n## Scope\n\nThis Code of Conduct applies within all community spaces, and also applies when\nan individual is officially representing the community in public spaces.\nExamples of representing our community include using an official e-mail address,\nposting via an official social media account, or acting as an appointed\nrepresentative at an online or offline event.\n\n## Enforcement\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be\nreported to the community leaders responsible for enforcement at\nthe following e-mail address xagentteam@gmail.com.\nAll complaints will be reviewed and investigated promptly and fairly.\n\nAll community leaders are obligated to respect the privacy and security of the\nreporter of any incident.\n\n## Enforcement Guidelines\n\nCommunity leaders will follow these Community Impact Guidelines in determining\nthe consequences for any action they deem in violation of this Code of Conduct:\n\n### 1. Correction\n\n**Community Impact**: Use of inappropriate language or other behavior deemed\nunprofessional or unwelcome in the community.\n\n**Consequence**: A private, written warning from community leaders, providing\nclarity around the nature of the violation and an explanation of why the\nbehavior was inappropriate. A public apology may be requested.\n\n### 2. Warning\n\n**Community Impact**: A violation through a single incident or series\nof actions.\n\n**Consequence**: A warning with consequences for continued behavior. No\ninteraction with the people involved, including unsolicited interaction with\nthose enforcing the Code of Conduct, for a specified period of time. This\nincludes avoiding interactions in community spaces as well as external channels\nlike social media. Violating these terms may lead to a temporary or\npermanent ban.\n\n### 3. Temporary Ban\n\n**Community Impact**: A serious violation of community standards, including\nsustained inappropriate behavior.\n\n**Consequence**: A temporary ban from any sort of interaction or public\ncommunication with the community for a specified period of time. No public or\nprivate interaction with the people involved, including unsolicited interaction\nwith those enforcing the Code of Conduct, is allowed during this period.\nViolating these terms may lead to a permanent ban.\n\n### 4. Permanent Ban\n\n**Community Impact**: Demonstrating a pattern of violation of community\nstandards, including sustained inappropriate behavior,  harassment of an\nindividual, or aggression toward or disparagement of classes of individuals.\n\n**Consequence**: A permanent ban from any sort of public interaction within\nthe community.\n\n## Attribution\n\nThis Code of Conduct is adapted from the [Contributor Covenant][homepage],\nversion 2.0, available at\nhttps://www.contributor-covenant.org/version/2/0/code_of_conduct.html.\n\nCommunity Impact Guidelines were inspired by [Mozilla's code of conduct\nenforcement ladder](https://github.com/mozilla/diversity).\n\n[homepage]: https://www.contributor-covenant.org\n\nFor answers to common questions about this code of conduct, see the FAQ at\nhttps://www.contributor-covenant.org/faq. Translations are available at\nhttps://www.contributor-covenant.org/translations."
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 2.0927734375,
          "content": "# Contributing to XAgent \n\nWelcome to the XAgent project, where your contributions matter greatly. We're delighted that you're interested in joining our mission to enhance this project.\n\n## How You Can Contribute \n\nYour contributions can take many forms:\n\n- **Reporting Bugs **: Help us identify and address issues (you can go ahead with issues!).\n- **Suggesting Enhancements **: Share your ideas for improving XAgent (by making issues.).\n- **Adding New Features **: Contribute your expertise by introducing exciting new features.\n- **Improving Documentation **: Enhance the clarity and completeness of our documentation.\n- **Providing Support **: Assist other users with their issues.\n\n## Getting Started \n\nTo get started with your contributions, follow these steps:\n\n1. **Fork the [XAgent repository](https://github.com/OpenBMB/XAgent)** by clicking the \"Fork\" button in the top-right corner of the repository page.\n\n2. **Clone your forked repository** to your local machine:\n\n   ```shell\n   git clone https://github.com/YourUsername/XAgent.git\n   ```\n\n3. Create a **new branch** for your changes:\n\n   ```shell\n   git checkout -b feature/your-feature\n   ```\n\n## Making Changes \n\nWith your environment set up, you're ready to make your contributions:\n\n1. Make your changes and **commit them to your branch**:\n\n   ```shell\n   git commit -m \"Your descriptive commit message\"\n   ```\n\n2. **Push your changes** to your forked repository:\n\n   ```shell\n   git push origin feature/your-feature\n   ```\n\n3. Create a **pull request (PR)** by navigating to the [XAgent repository](https://github.com/OpenBMB/XAgent) and clicking the \"New Pull Request\" button.\n\n4. Provide a **descriptive title and details** in the PR, and make sure to **link your PR to any relevant issues**.\n\n5. **Submit the pull request**, and our maintainers will review your changes.\n\n## Code of Conduct \n\nPlease adhere to our [Code of Conduct](LICENSE) while contributing to this project.\n\nWe sincerely appreciate your contributions, and we look forward to working together to make XAgent even better for everyone!\n\nHappy Contributing! \n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 11.0712890625,
          "content": "                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"[]\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright 2023 OpenBMB\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "Markdown_Docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 11.8427734375,
          "content": "<div align= \"center\">\n    <h1> <img src=\"assets/readme/xagent_logo.png\" height=40 align=\"texttop\">XAgent</h1>\n</div>\n\n<div align=\"center\">\n\n[![Twitter](https://img.shields.io/twitter/follow/XAgent?style=social)](https://twitter.com/XAgentTeam) [![Discord](https://img.shields.io/badge/XAgent-Discord-purple?style=flat)](https://discord.gg/zncs5aQkWZ) [![License: Apache 2.0](https://img.shields.io/badge/License-Apache_2.0-green.svg)](https://opensource.org/license/apache-2-0/) ![Welcome](https://img.shields.io/badge/contributions-welcome-brightgreen.svg?style=flat)\n\n</div>\n\n<p align=\"center\">\n    <a>English</a> \n    <a href=\"README_ZH.md\"></a> \n    <a href=\"README_JA.md\"></a>\n</p>\n\n<p align=\"center\">\n  <a href=\"#quickstart\">Tutorial</a> \n  <a href=\"https://www.youtube.com/watch?v=QGkpd-tsFPA\">Demo</a> \n  <a href=\"https://blog.x-agent.net/blog/xagent/\">Blog</a> \n  <a href=\"https://xagent-doc.readthedocs.io/en/latest/\">Documentation</a> \n  <a href=\"#Citation\">Citation</a>\n</p>\n\n\n##  Introduction\n\nXAgent is an open-source experimental Large Language Model (LLM) driven autonomous agent that can automatically solve various tasks. \nIt is designed to be a general-purpose agent that can be applied to a wide range of tasks. XAgent is still in its early stages, and we are working hard to improve it.\n\n Our goal is to create a super-intelligent agent that can solve any given task!\n\nWe welcome diverse forms of collaborations, including full-time and part-time roles and more. If you are interested in the frontiers of agents and want to join us in realizing true autonomous agents, please contact us at xagentteam@gmail.com.\n\n<div align=\"center\">\n    <img src=\"assets/readme/overview.png\" alt=\"Overview of Xagent\" width=\"700\"/>\n    <br/>\n    <figcaption>Overview of XAgent.</figcaption>\n</div>\n\n### <img src=\"assets/readme/xagent_logo.png\" height=30 align=\"texttop\"> XAgent\n\nXAgent is designed with the following features:\n- **Autonomy**: XAgent can automatically solve various tasks without human participation.\n- **Safety**: XAgent is designed to run safely. All actions are constrained inside a docker container. Run it anyway!\n- **Extensibility**: XAgent is designed to be extensible. You can easily add new tools to enhance agent's abilities and even new agents\n- **GUI**: XAgent provides a friendly GUI for users to interact with the agent. You can also use the command line interface to interact with the agent.\n- **Cooperation with Human**: XAgent can collaborate with you to tackle tasks. It not only has the capability to follow your guidance in solving complex tasks on the go but it can also seek your assistance when it encounters challenges.\n\nXAgent is composed of three parts:\n- ** Dispatcher** is responsible for dynamically instantiating and dispatching tasks to different agents. It allows us to add new agents and improve the agents' abilities.\n- ** Planner** is responsible for generating and rectifying plans for tasks. It divides tasks into subtasks and generates milestones for them, allowing agents to solve tasks step by step.\n- ** Actor** is responsible for conducting actions to achieve goals and finish subtasks. The actor utilizes various tools to solve subtasks, and it can also collaborate with humans to solve tasks.\n\n<div align=\"center\">\n    <img src=\"assets/readme/workflow.png\" alt=\"Workflow of Xagent\" width=\"700\"/>\n    <br/>\n    <figcaption>Workflow of XAgent.</figcaption>\n</div>\n\n###  ToolServer\n\nToolServer is the server that provides XAgent with powerful and safe tools to solve tasks. It is a docker container that provides a safe environment for XAgent to run.\nCurrently, ToolServer provides the following tools:\n- ** File Editor** provides a text editing tool to write, read, and modify files.\n- ** Python Notebook** provides an interactive Python notebook that can run Python code to validate ideas, draw figures, etc.\n- ** Web Browser** provides a web browser to search and visit webpages.\n- ** Shell** provides a bash shell tool that can execute any shell commands, even install programs and host services.\n- ** Rapid API** provides a tool to retrieve APIs from Rapid API and call them, which offers a wide range of APIs for XAgent to use. See [ToolBench](https://github.com/OpenBMB/ToolBench) to get more information about the Rapid API collections.\nYou can also easily add new tools to ToolServer to enhance XAgent's abilities.\n\n<div><a id=\"Quickstart\"></a></div>\n\n##  Quickstart\n\n###  Build and Setup ToolServer\n\nToolServer is where XAgent's action takes place. It is a docker container that provides a safe environment for XAgent to run.\nSo you should install `docker` and `docker-compose` first. \nThen, you need to build the ToolServer image. Construct referring to any one of the following methods:\n\n#### Pull the image from docker hub by running the following command:\n\n```bash\ndocker compose up\n```\n\n#### Build an image from local sources by running the following command:\n\n```bash\ndocker compose build\ndocker compose up\n```\nThis will build the image for the ToolServer and start the ToolServer's container. \nIf you want to run the container in the background, please use `docker compose up -d`.\nRefer [here](ToolServer/README.md) for detailed information about our ToolServer.\n\nIf the ToolServer is updated, you have to repull/rebuild the images:\n```bash\ndocker compose pull\n```\nOr\n```bash\ndocker compose build\n```\n\n###  Setup and Run XAgent\n\nAfter setting up ToolServer, you can start to run XAgent.\n- Install requirements (Require Python >= 3.10)\n```bash\npip install -r requirements.txt\n```\n\n- Configure XAgent\n\n1. You should configure XAgent in `assets/config.yml` before running it. \n2. At least one OpenAI key is provided in `assets/config.yml`, which is used to access OpenAI API.\nWe highly recommend using `gpt-4-32k` to run XAgent; `gpt-4` is also OK for most simple tasks.\nIn any case, at least one `gpt-3.5-turbo-16k` API key should be provided as a backup model.\nWe do not test or recommend using `gpt-3.5-turbo` to run XAgent due to minimal context length; you should not try to run XAgent on that.\n3. If you want to change the config_file path for `XAgentServer`, you should modify the `CONFIG_FILE` value in `.env` file and restart the docker container.\n\n\n- Run XAgent\n```bash\npython run.py --task \"put your task here\" --config-file \"assets/config.yml\"\n```\n1. You can use the argument `--upload-files` to select the initial files you want to submit to XAgent.\n\n2. The local workspace for your XAgent is in `local_workspace`, where you can find all the files generated by XAgent throughout the running process. \n\n3. After execution, the entire `workspace` in `ToolServerNode` will be copied to `running_records` for your convenience.\n\n4. Besides, in `running_records`, you can find all the intermediate steps information, e.g., task statuses, LLM's input-output pairs, used tools, etc.\n\n5. You can load from a record to reproduce a former run, just by setting `record_dir` in config(default to `Null`). The record is a system-level recording tied to the code version of XAgent. All running-configquerycode execution statuses (including errors)server behavior will be documented.\n\n6. We have removed all sensitive information (including API keys) from the record so you can safely share it with others. In the near future, we will introduce more granular sharing options highlighting the contributions of humans during execution.\n\n   \n\n- Run XAgent with GUI\nThe container `XAgent-Server` is started with nginx and a web server listening on port `5173`.\nYou could visit `http://localhost:5173` to interact with XAgent by using web UI.\nThe default username and password are `guest` and `xagent`, respectively.\nRefer [here](XAgentServer/README.md) for the detailed information about our GUI Demo.\n\n<div><a id=\"Demo\"></a></div>\n\n##  Demo\n\nHere, we also show some cases of solving tasks by XAgent:\nYou can check our live demo on [XAgent Official Website](https://www.x-agent.net/). We also provide a video demo and showcases of using XAgent here:\n![Demo](assets/readme/demo.gif)\n\n### Case 1. Data Analysis: Demonstrating the Effectiveness of Dual-Loop Mechanism\n\nWe start with a case of aiding users in intricate data analysis. Here, our user submitted an `iris.zip` file to XAgent, seeking assistance in data analysis. XAgent swiftly broke down the task into four sub-tasks: (1) data inspection and comprehension, (2) verification of the system's Python environment for relevant data analysis libraries, (3) crafting data analysis code for data processing and analysis, and (4) compiling an analytical report based on the Python code's execution results.\nHere is a figure drawn by XAgent.\n![Data Statics by XAgent](assets/readme/statistics.png)\n\n\n### Case 2. Recommendation: A New Paradigm of Human-Agent Interaction\n\nEmpowered with the unique capability to actively seek human assistance and collaborate in problem-solving, XAgent continues to redefine the boundaries of human-agent cooperation. As depicted in the screenshot below, a user sought XAgent's aid in recommending some great restaurants for a friendly gathering yet failed to provide specific details. Recognizing the insufficiency of the provided information, XAgent employed the AskForHumanHelp tool, prompting human intervention to elicit the user's preferred location, budget constraints, culinary preferences, and dietary restrictions. Armed with this valuable feedback, XAgent seamlessly generated tailored restaurant recommendations, ensuring a personalized and satisfying experience for the user and their friends.\n\n![Illustration of Ask for Human Help of XAgent](assets/readme/ask_for_human_help.png)\n\n### Case 3. Training Model: A Sophisticated Tool User\n\nXAgent not only tackles mundane tasks but also serves as an invaluable aid in complex tasks such as model training. Here, we show a scenario where a user desires to analyze movie reviews and evaluate the public sentiment surrounding particular films. In response, XAgent promptly initiates the process by downloading the IMDB dataset to train a cutting-edge BERT model (see screenshot below), harnessing the power of deep learning. Armed with this trained BERT model, XAgent seamlessly navigates the intricate nuances of movie reviews, offering insightful predictions regarding the public's perception of various films.\n\n![bert_1](assets/readme/bert_1.png)\n![bert_2](assets/readme/bert_2.png)\n![bert_3](assets/readme/bert_3.png)\n\n###  Evaluation\n\nWe conduct human preference evaluation to evaluate XAgent's performance. We prepare [over 50 real-world complex tasks](assets/tasks.yml) for assessment, which can be categorized into 5 classes: Search and Report, Coding and Developing, Data Analysis, Math, and Life Assistant.\nWe compare the results of XAgent with [AutoGPT](https://github.com/Significant-Gravitas/AutoGPT), which shows a total win of XAgent over AutoGPT. \nAll running records can refer to [here](https://drive.google.com/drive/folders/1I-j6FZDyMRrLTpZ64jeN89emA77AbNfc?usp=drive_link).\n\n![HumanPrefer](assets/readme/agent_comparison.png)\n\nWe report a significant improvement of XAgent over AutoGPT in terms of human preference.\n\nWe also evaluate XAgent on the following benchmarks:\n![Benchmarks](assets/readme/eval_on_dataset.png)\n\n\n<div><a id=\"Blog\"></a></div>\n\n##  Blog\n\nOur blog is available at [here](https://blog.x-agent.net/)!\n\n<div><a id=\"Citation\"></a></div>\n\n##  Our Contributors\n\nA heartfelt thank you to all our contributors. Your efforts make this project grow and thrive. Every contribution, big or small, is invaluable.\n\n![Contributors](https://contrib.rocks/image?repo=OpenBMB/XAgent)\n\n##  Star History\n\n[![Star History Chart](https://api.star-history.com/svg?repos=openbmb/xagent&type=Date)](https://star-history.com/##openbmb/xagent&Date)\n\n## Citation\n\nIf you find our repo useful, please kindly consider citing:\n```angular2\n@misc{xagent2023,\n      title={XAgent: An Autonomous Agent for Complex Task Solving}, \n      author={XAgent Team},\n      year={2023},\n}\n```\n"
        },
        {
          "name": "README_JA.md",
          "type": "blob",
          "size": 15.2421875,
          "content": "<div align= \"center\">\n    <h1> <img src=\"assets/readme/xagent_logo.png\" height=40 align=\"texttop\">XAgent</h1>\n</div>\n\n<div align=\"center\">\n\n[![Twitter](https://img.shields.io/twitter/follow/XAgent?style=social)](https://twitter.com/XAgentTeam) [![Discord](https://img.shields.io/badge/XAgent-Discord-purple?style=flat)](https://discord.gg/zncs5aQkWZ) [![License: Apache 2.0](https://img.shields.io/badge/License-Apache_2.0-green.svg)](https://opensource.org/license/apache-2-0/) ![Welcome](https://img.shields.io/badge/contributions-welcome-brightgreen.svg?style=flat)\n\n</div>\n\n<p align=\"center\">\n    <a href=\"README.md\">English</a> \n    <a href=\"README_ZH.md\"></a> \n    <a></a>\n</p>\n\n<p align=\"center\">\n  <a href=\"#Quickstart\"></a> \n  <a href=\"https://www.youtube.com/watch?v=QGkpd-tsFPA\"></a> \n  <a href=\"https://blog.x-agent.net/blog/xagent/\"></a> \n  <a href=\"https://xagent-doc.readthedocs.io/en/latest/\"></a> \n  <a href=\"#Citation\"></a>\n</p>\n\n##  \n\nXAgent LLM\nXAgent \n\n !\n\nxagentteam@gmail.com \n\n<div align=\"center\">\n    <img src=\"assets/readme/overview.png\" alt=\"Overview of Xagent\" width=\"700\"/>\n    <br/>\n    <figcaption>XAgent </figcaption>\n</div>\n\n### <img src=\"assets/readme/xagent_logo.png\" height=30 align=\"texttop\"> XAgent\n\nXAgent:\n- ****: XAgent\n- ****: XAgent  docker !\n- ****: XAgent \n- **GUI**: XAgent  GUI \n- ****: XAgent XAgent\n\nXAgent  3 :\n- ** Dispatcher** \n- ** Planner** \n- ** Actor** \n\n<div align=\"center\">\n    <img src=\"assets/readme/workflow.png\" alt=\"XAgent\" width=\"700\"/>\n    <br/>\n    <figcaption>XAgent</figcaption>\n</div>\n\n###  ToolServer\n\nToolServer  XAgent XAgent  docker \nToolServer :\n- ** ** \n- ** Python ** Python  Python \n- ** Web **  web \n- ** **  bash \n- ** Rapid API** Rapid API  API XAgent  API Rapid API [ToolBench](https://github.com/OpenBMB/ToolBench) \nToolServer XAgent \n\n<div><a id=\"\"></a></div>\n\n##  \n\n###  ToolServer \n\nToolServer XAgent XAgent  Docker \n `docker`  `docker-compose` \nToolServer ToolServer`2\ndocker hubdocker\n```bash\ndocker compose up\n```\n\n\n```bash\ndocker compose build\ndocker compose up\n```\n\n`docker compose up -d` \nToolServer [](ToolServer/README.md)\n\nToolServer :\n```bash\ndocker compose pull\n```\nOr\n```bash\ndocker compose build\n```\n\n###  XAgent \n\nToolServer XAgent \n-  (Python >= 3.10 )\n```bash\npip install -r requirements.txt\n```\n\n- XAgent \n\n1. XAgent `assets/config.yml`  XAgent \n2. `assets/config.yml` OpenAI API  OpenAI  1 \nXAgent `gpt-4-32k` \n 1  `gpt-3.5-turbo-16k` API \n`gpt-3.5-turbo`  XAgent \n;  XAgent \n3. `XAgentServer` `.env`  `CONFIG_FILE`  docker \n\n\n- XAgent \n```bash\npython run.py --task \"put your task here\" --config-file \"assets/config.yml\"\n```\n1.  `--upload-files` XAgent \n\n2. XAgent  `local_workspace`  XAgent \n\n3. `ToolServerNode`  `workspace`  `running_records` \n\n4. `running_records` LLM \n\n5. config  `record_dir`  `Null` XAgent \n\n6. API \n\n\n\n- GUI  XAgent \n XAgent-Server nginx 5173 \nWeb UI  XAgent http://localhost:5173 \n guest  xagent \nGUI [](XAgentServer/README.md) \n\n<div><a id=\"\"></a></div>\n\n##  \n\nXAgent :\n[XAgent Official Website](https://www.x-agent.net/) XAgent :\n![Demo](assets/readme/demo.gif)\n\n###  1. : \n\n `iris.zip`  XAgent (1)(2) Python (3)(4)Python \nXAgent \n![Data Statics by XAgent](assets/readme/statistics.png)\n\n\n###  2. : \n\n XAgent  XAgent  XAgent AskForHumanHelp XAgent \n\n![Illustration of Ask for Human Help of XAgent](assets/readme/ask_for_human_help.png)\n\n###  3. : \n\nXAgent  XAgent IMDB  BERT XAgent  BERT \n\n![bert_1](assets/readme/bert_1.png)\n![bert_2](assets/readme/bert_2.png)\n![bert_3](assets/readme/bert_3.png)\n\n###  \n\nXAgent  [50 ](assets/tasks.yml)5 :  5 \nXAgent  [AutoGPT](https://github.com/Significant-Gravitas/AutoGPT) XAgent  AutoGPT \n\n\n![HumanPrefer](assets/readme/agent_comparison.png)\n\nAutoGPT  XAgent \n\n XAgent :\n![Benchmarks](assets/readme/eval_on_dataset.png)\n\n\n<div><a id=\"\"></a></div>\n\n##  \n\n[](https://blog.x-agent.net/)!\n\n<div><a id=\"\"></a></div>\n\n##  \n\n\n\n![](https://contrib.rocks/image?repo=OpenBMB/XAgent)\n\n##  Star History\n\n[![Star History Chart](https://api.star-history.com/svg?repos=openbmb/xagent&type=Date)](https://star-history.com/##openbmb/xagent&Date)\n\n## \n\n:\n```angular2\n@misc{xagent2023,\n      title={XAgent: An Autonomous Agent for Complex Task Solving},\n      author={XAgent Team},\n      year={2023},\n}\n```\n"
        },
        {
          "name": "README_ZH.md",
          "type": "blob",
          "size": 10.1513671875,
          "content": "<div align= \"center\">\n    <h1> <img src=\"assets/readme/xagent_logo.png\" height=40 align=\"texttop\">XAgent</h1>\n</div>\n\n<div align=\"center\">\n\n[![Twitter](https://img.shields.io/twitter/follow/XAgent?style=social)](https://twitter.com/XAgentTeam) [![Discord](https://img.shields.io/badge/XAgent-Discord-purple?style=flat)](https://discord.gg/zncs5aQkWZ) [![License: Apache 2.0](https://img.shields.io/badge/License-Apache_2.0-green.svg)](https://opensource.org/license/apache-2-0/) ![Welcome](https://img.shields.io/badge/contributions-welcome-brightgreen.svg?style=flat)\n\n</div>\n\n<p align=\"center\">\n    <a href=\"README.md\">English</a> \n    <a></a> \n    <a href=\"README_JA.md\"></a>\n</p>\n\n<p align=\"center\">\n  <a href=\"#Quickstart\"></a> \n  <a href=\"https://www.youtube.com/watch?v=QGkpd-tsFPA\"></a> \n  <a href=\"https://blog.x-agent.net/blog/xagent/\"></a> \n  <a href=\"https://xagent-doc.readthedocs.io/en/latest/\"></a> \n  <a href=\"#Citation\"></a>\n</p>\n\n\n##  \n\nXAgentLLM\nXAgent\n\n \n\n xagentteam@gmail.com \n\n<div align=\"center\">\n    <img src=\"assets/readme/overview_zh.jpg\" alt=\"XAgent\" width=\"700\"/>\n    <br/>\n    <figcaption>XAgent</figcaption>\n</div>\n\n### <img src=\"assets/readme/xagent_logo.png\" height=30 align=\"texttop\"> XAgent\n\nXAgent\n- ****XAgent\n- ****XAgentdocker\n- ****XAgent\n- **GUI**XAgentGUI\n- ****XAgent\n\nXAgent\n- ** ** \n- ** ** \n- ** ** \n\n<div align=\"center\">\n    <img src=\"assets/readme/workflow.png\" alt=\"XAgent\" width=\"700\"/>\n    <br/>\n    <figcaption>XAgent</figcaption>\n</div>\n\n###  \n\nXAgentdockerXAgent\n\n- ** ** \n- ** Python** PythonPython\n- ** ** \n- ** Shell** bash shellshell\n- ** Rapid API** Rapid APIAPIXAgentAPIRapid API[ToolBench](https://github.com/OpenBMB/ToolBench)\nXAgent\n\n<div><a id=\"Quickstart\"></a></div>\n\n##  \n\n###  \n\nXAgentdockerXAgent\n`docker``docker-compose`\n\n\n#### docker hubdocker\n\n```bash\ndocker compose up\n```\n\n#### \n\n```bash\ndocker compose build\ndocker compose up\n```\n\n`docker compose up -d`\n[ToolServer](ToolServer/README_ZH.md)\n\n\n\n```bash\ndocker compose pull\n```\n\n\n\n```bash\ndocker compose build\n```\n\n###  XAgent\n\nToolServerXAgent\n- Python >= 3.10\n```bash\npip install -r requirements.txt\n```\n- XAgent\n`config.yml`XAgent\n OpenAI keyOpenAI API\n`gpt-4-32k`XAgent`gpt-4`\n`gpt-3.5-turbo-16k` API key\n`gpt-3.5-turbo`XAgentXAgent\n\n- XAgent\n```bash\npython run.py --task \"put your task here\" --config-file \"assets/config.yml\"\n```\n`--upload-files`XAgent\nXAgent`local_workspace`XAgent\n`running_records`LLM\n`ToolServerNode``worksapce`\n\n- GUIXAgent\n`XAgent-Server``5173`XAgentGUI\n`http://localhost:5173`XAgentGUI\n`guest``xagent`\n[XAgentServer](XAgentServer/README_zh.md)\n\n\n<div><a id=\"Demo\"></a></div>\n\n##  \n\nXAgent\n[XAgent](https://www.x-agent.net/)XAgent\n![Demo](assets/readme/demo.gif)\n\n### 1. \n\nXAgent\n`iris.zip`XAgentXAgent\nXAgent412Python34\nXAgent\n\n![Data Statics by XAgent](assets/readme/statistics.png)\n\n### 2. \n\nXAgentXAgentXAgentXAgent\n\n![Illustration of Ask for Human Help of XAgent](assets/readme/ask_for_human_help.png)\n\n### 3. \n\nXAgent XAgent  IMDB  BERT  BERT XAgent \n\n![bert_1](assets/readme/bert_1.png)\n![bert_2](assets/readme/bert_2.png)\n![bert_3](assets/readme/bert_3.png)\n\n###  \n\nXAgent505\n\nXAgent[AutoGPT](https://github.com/Significant-Gravitas/AutoGPT)XAgentAutoGPT\nXAgent\n![HumanPrefer](assets/readme/agent_comparison.png)\nXAgentAutoGPT\n\nXAgent\n![Benchmarks](assets/readme/eval_on_dataset.png)\n\n<div><a id=\"Blog\"></a></div>\n\n##  \n\n[](https://blog.x-agent.net/)\n\n##  \n\n\n\n![](https://contrib.rocks/image?repo=OpenBMB/XAgent)\n\n##  \n\n[![Star History Chart](https://api.star-history.com/svg?repos=openbmb/xagent&type=Date)](https://star-history.com/##openbmb/xagent&Date)\n\n## \n\n\n```angular2\n@misc{xagent2023,\n      title={XAgent: An Autonomous Agent for Complex Task Solving}, \n      author={XAgent Team},\n      year={2023},\n}\n```\n"
        },
        {
          "name": "ToolServer",
          "type": "tree",
          "content": null
        },
        {
          "name": "XAgent",
          "type": "tree",
          "content": null
        },
        {
          "name": "XAgentGen",
          "type": "tree",
          "content": null
        },
        {
          "name": "XAgentServer",
          "type": "tree",
          "content": null
        },
        {
          "name": "XAgentWeb",
          "type": "tree",
          "content": null
        },
        {
          "name": "assets",
          "type": "tree",
          "content": null
        },
        {
          "name": "build_images.sh",
          "type": "blob",
          "size": 1.0400390625,
          "content": "#/bin/bash\ndocker buildx build --push --platform linux/arm64,linux/amd64 -t xagentteam/toolserver-manager:0.2 -f dockerfiles/ToolServerManager/Dockerfile .\ndocker buildx build --push --platform linux/arm64,linux/amd64 -t xagentteam/toolserver-manager -f dockerfiles/ToolServerManager/Dockerfile .\ndocker buildx build --push --platform linux/arm64,linux/amd64 -t xagentteam/toolserver-node:0.2 -f dockerfiles/ToolServerNode/Dockerfile .\ndocker buildx build --push --platform linux/arm64,linux/amd64 -t xagentteam/toolserver-node -f dockerfiles/ToolServerNode/Dockerfile .\ndocker buildx build --push --platform linux/arm64,linux/amd64 -t xagentteam/xagent-server:0.3 -f dockerfiles/XAgentServer/Dockerfile .\ndocker buildx build --push --platform linux/arm64,linux/amd64 -t xagentteam/xagent-server -f dockerfiles/XAgentServer/Dockerfile .\n\ndocker buildx build --push --platform linux/amd64 -t xagentteam/xagentgen:0.1 -f dockerfiles/XAgentGen/Dockerfile .\ndocker buildx build --push --platform linux/amd64 -t xagentteam/xagentgen -f dockerfiles/XAgentGen/Dockerfile ."
        },
        {
          "name": "command.py",
          "type": "blob",
          "size": 11.9541015625,
          "content": "import asyncio\nfrom contextlib import contextmanager\nimport json\nimport os\nimport threading\nimport traceback\nimport uuid\nfrom datetime import datetime\nfrom typing import List\n\nfrom colorama import Fore\n\nfrom apscheduler.schedulers.asyncio import AsyncIOScheduler\nfrom apscheduler.schedulers.blocking import BlockingScheduler\n\n\nfrom XAgentServer.application.core.envs import XAgentServerEnv\nfrom XAgentServer.database.connect import SessionLocal\nfrom XAgentServer.enums.status import StatusEnum\nfrom XAgentServer.exts.exception_ext import XAgentError\nfrom XAgentServer.interaction import XAgentInteraction\nfrom XAgentServer.loggers.logs import Logger\nfrom XAgentServer.models.interaction import InteractionBase\nfrom XAgentServer.models.parameter import InteractionParameter\nfrom XAgentServer.models.raw import XAgentRaw\nfrom XAgentServer.server import XAgentServer\nfrom XAgentServer.application.cruds.interaction import InteractionCRUD\nfrom XAgentServer.application.global_val import redis\nfrom command_input import CommandLineInput\n\n\n@contextmanager\ndef get_db():\n    \"\"\"\n    Provide a transactional scope around a series of operations.\n    \"\"\"\n    session = SessionLocal()\n    try:\n        yield session\n        session.commit()\n    except:\n        session.rollback()\n        raise\n    finally:\n        session.close()\n        \n\nclass CommandLineParam:\n    \"\"\"Command line parameters.\n    \n    Attributes:\n            task: Task description.\n            role: Role name (default is \"Assistant\").\n            plan: List of steps to perform (default is empty list).\n            upload_files: List of files to upload (default is empty list).\n            download_files: List of files to download (default is empty list).\n            record_dir: Directory to store records (default is `None`).\n            mode: Run mode. Can be \"auto\" (default is \"auto\").\n            max_wait_seconds: Maximum wait time in seconds (default is 600).\n            description: Description of the interaction (default is \"XAgent-Test\").\n            agent: Agent name (default is \"XAgent\").\n    \"\"\"\n    def __init__(self,\n                 task,\n                role=\"Assistant\",\n                plan=[],\n                upload_files: List[str] = [],\n                download_files: List[str] = [],\n                record_dir: str = None,\n                mode: str = \"auto\",\n                max_wait_seconds: int = 600,\n                description: str = \"XAgent-Test\",\n                agent: str = \"XAgent\",\n                ):\n        self.task = task\n        self.plan = plan\n        self.role = role\n        self.upload_files = upload_files\n        self.download_files = download_files\n        self.record_dir = record_dir\n        # auto is supported only in cmd\n        self.mode = \"auto\"\n        self.max_wait_seconds = max_wait_seconds\n        self.description = description\n        self.agent = agent\n\n\nclass CommandLine():\n    \"\"\"\n    A command-line interface for interacting with XAgentServer.\n\n    Attributes:\n        env: An instance of the XAgentServer environment.\n        client_id: A unique identifier for the client, generated as a hexadecimal UUID.\n        date_str: The current date as a string in YYYY-MM-DD format.\n        log_dir: The directory where the logs are stored.\n        logger: An instance of the Logger used for logging interactions.\n        interactionDB: A database interface for interacting with either a persistent\n            database (SQLite, MySQL, PostgreSQL) or a local storage file, depending\n            on the configuration of `env`.\n    \"\"\"\n\n    def __init__(self, args: CommandLineParam = None):\n        \"\"\"\n        Initialize the CommandLine instance.\n\n        Args:\n            args (CommandLineParam) : parameters.\n            task is required,\n            mode options: [\"auto\"]\n        \"\"\"\n\n        self.args = args\n        self.client_id = uuid.uuid4().hex\n        self.date_str = datetime.now().strftime(\"%Y-%m-%d\")\n        self.log_dir = os.path.join(os.path.join(XAgentServerEnv.base_dir, \"localstorage\",\n                                    \"interact_records\"), self.date_str, self.client_id)\n        if not os.path.exists(self.log_dir):\n            os.makedirs(self.log_dir)\n\n        self.logger = Logger(log_dir=self.log_dir, log_file=f\"interact.log\")\n\n        self.logger.typewriter_log(\n            title=f\"XAgentServer is running on cmd mode\",\n            title_color=Fore.RED)\n        self.logger.info(title=f\"XAgentServer log:\",\n                         title_color=Fore.RED, message=f\"{self.log_dir}\")\n        self.interrupt = self.args.mode != \"auto\"\n        self.init_conv_env()\n        self.max_wait_seconds = self.args.max_wait_seconds\n        self.scheduler = AsyncIOScheduler()\n        self.input = None\n        if self.interrupt:\n            self.input = CommandLineInput(\n                do_interrupt=True,\n                max_wait_seconds=self.max_wait_seconds,\n                logger=self.logger)\n\n    def init_conv_env(self):\n        \"\"\"initialize the conversation environment, \n        Share the same database resource with webui.\n        If you have initiated a session on the front end but it has not been executed, \n        this ID will be shared.\n        \"\"\"\n        user_id = \"guest\"\n        token = \"xagent\"\n        description = self.args.description\n        upload_files = self.args.upload_files\n        record_dir = self.args.record_dir\n        agent = self.args.agent\n        goal = self.args.task\n        mode = self.args.mode\n        plan = self.args.plan\n\n        with get_db() as db:\n            interaction = InteractionCRUD.get_ready_interaction(\n                db=db, user_id=user_id)\n            self.continue_flag = True\n            upload_files = upload_files if upload_files else []\n            file_list = []\n            for file in upload_files:\n                file_list.append({\n                    \"uuid\": file,\n                    \"name\": file\n                })\n            if interaction is None:\n\n                base = InteractionBase(interaction_id=self.client_id,\n                                       user_id=user_id,\n                                       create_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n                                       description=description,\n                                       agent=agent,\n                                       mode=mode,\n                                       file_list=file_list,\n                                       recorder_root_dir=\"\",\n                                       status=\"ready\",\n                                       message=\"ready...\",\n                                       current_step=\"-1\",\n                                       update_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n                                       call_method=\"cmd\")\n                InteractionCRUD.create_interaction(db=db, base=base)\n            else:\n                self.client_id = interaction.interaction_id\n            \n            parameter = InteractionParameter(\n                interaction_id=self.client_id,\n                parameter_id=uuid.uuid4().hex,\n                args={\n                    \"goal\": goal,\n                    \"plan\": plan\n                    },\n            )\n            InteractionCRUD.add_parameter(db=db, parameter=parameter)\n\n\n    def run(self):\n        \"\"\"\n        Runs the interaction with the XAgentServer with the provided arguments.\n        \"\"\"\n\n        # Create a new raw data to record\n        with get_db() as db:\n            InteractionCRUD.insert_raw(db=db, process=XAgentRaw(\n                interaction_id=self.client_id,\n                node_id=uuid.uuid4().hex,\n                status=StatusEnum.RUNNING,\n                create_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n                update_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n                current=\"\",\n                step=-1,\n                data=None,\n                file_list=[],\n                do_interrupt=self.interrupt,\n                wait_seconds=0,\n                ask_for_human_help=False,\n                is_human=True,\n                human_data={\"goal\": self.args.task, \"plan\": self.args.plan},\n                human_file_list=self.args.upload_files,\n                is_send=True,\n                is_receive=False,\n                is_deleted=False\n            ))\n            redis.set_key(f\"{self.client_id}_send\", 1)\n            \n            parameter = InteractionCRUD.get_init_parameter(\n                db=db, interaction_id=self.client_id)\n        \n        self.task_handler(parameter=parameter)\n\n    def task_handler(self, parameter: InteractionParameter):\n        \"\"\"\n        define a long task to run interaction\n\n        Args:\n            parameter (InteractionParameter): The parameter of interaction\n        \"\"\"\n\n        try:\n            current_step = uuid.uuid4().hex\n            with get_db() as db:\n                base = InteractionCRUD.get_interaction(db=db,\n                                                    interaction_id=self.client_id)\n                InteractionCRUD.update_interaction_status(db=db,\n                                                        interaction_id=base.interaction_id,\n                                                        status=\"running\",\n                                                        message=\"running\",\n                                                        current_step=current_step)\n\n            # if mode is not auto, we will interrupt the interaction\n            # and you can change the wait_seconds\n            # default 10 min.\n            interaction = XAgentInteraction(\n                base=base,\n                parameter=parameter,\n                interrupt=base.mode != \"auto\",\n                call_method=\"cmd\")\n\n            # Register logger, dbinto interaction\n            interaction.resister_logger(self.logger)\n            self.logger.info(\n                f\"Register logger into interaction of {base.interaction_id}, done!\")\n\n            interaction.register_db(db=db)\n            self.logger.info(\n                f\"Register db into interaction of {base.interaction_id}, done!\")\n            # Create XAgentServer\n            server = XAgentServer(logger=self.logger)\n            self.logger.info(\n                f\"Register logger into XAgentServer of {base.interaction_id}, done!\")\n            self.logger.info(\n                f\"Start a new thread to run interaction of {base.interaction_id}, done!\")\n            # await server.interact(interaction=interaction)\n            server.interact(interaction=interaction)\n        except XAgentError as e:\n            traceback.print_exc()\n            self.logger.error(\n                f\"Error in task_handler of {self.client_id}: {e}\")\n            with get_db() as db:\n                InteractionCRUD.insert_error(\n                    db=db, interaction_id=self.client_id, message=str(e))\n                redis.set_key(self.client_id + \"_send\", 1)\n                InteractionCRUD.update_interaction_status(db=db,\n                                                        interaction_id=self.client_id,\n                                                        status=\"failed\",\n                                                        message=str(e),\n                                                        current_step=current_step)\n        \n    def start(self):\n\n        self.run()\n\n\nif __name__ == \"__main__\":\n    import sys\n    args = CommandLineParam()\n    if len(sys.argv) >= 2:\n        print(sys.argv[1])\n        if len(sys.argv) >= 3:\n            original_stdout = sys.stdout\n            from XAgent.running_recorder import recorder\n            sys.stdout = open(os.path.join(\n                recorder.record_root_dir, \"command_line.ansi\"), \"w\", encoding=\"utf-8\")\n\n        args.task = sys.argv[1],\n        args.role=\"Assistant\",\n        args.mode=\"auto\",\n        if len(sys.argv) >= 3:\n            sys.stdout.close()\n            sys.stdout = original_stdout\n\n    else:\n        args.task = \"I will have five friends coming to visit me this weekend, please find and recommend some restaurants for us.\",\n        args.role=\"Assistant\",\n        args.mode=\"auto\",\n        \n    cmd = CommandLine(XAgentServerEnv, args)\n"
        },
        {
          "name": "command_input.py",
          "type": "blob",
          "size": 5.087890625,
          "content": "import asyncio\nimport functools\nimport time\nfrom colorama import Fore\nfrom XAgentServer.exts.exception_ext import XAgentTimeoutError, XAgentCloseError\n\nfrom inputimeout import inputimeout, TimeoutOccurred\nfrom XAgentServer.application.global_val import redis\nimport math\n\n\ndef timer(func):\n    \"\"\"\n    Decorator function to time the execution of a function.\n\n    Args:\n        func (Function): The function to be timed.\n\n    Returns:\n        wrapper (Function): The wrapped function with added timing functionality.\n    \"\"\"\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        try:\n            start_time = time.time()\n            result = func(*args, **kwargs)\n            end_time = time.time()\n        except:\n            pass\n    return wrapper\n\n\nclass CommandLineInput:\n    \"\"\"\n    Class for handling command line input.\n\n    This child class extends from BaseInput and implements methods to handle and manage command line input data.\n\n    Attributes:\n        do_interrupt (bool): If True, input will be interrupted.\n        max_wait_seconds (int): Maximum wait time for input in seconds.\n    \"\"\"\n    def __init__(self,\n                 do_interrupt: bool = False,\n                 max_wait_seconds: int = 600,\n                 logger=None):\n        self.do_interrupt = do_interrupt\n        self.max_wait_seconds = max_wait_seconds\n        self.logger = logger\n\n    def run(self, input_data):\n        \"\"\"\n        Run the command line input method.\n\n        Args:\n            input_data (Any): The original input data to be processed.\n\n        Returns:\n            data (Any): The processed input data.\n        \"\"\"\n        if self.do_interrupt:\n            data = self.interrupt(input_data)\n        else:\n            data = input_data\n        return data\n    \n    def get_each_input(self, key, value, res, timeout):\n        \"\"\"\n        Returns the input from the command line for a single key-value pair.\n\n        Args:\n            key (str): The key for which to get input.\n            value (Any): The current value associated with the key.\n            res (dict): The result dictionary where inputs collected will be stored.\n            timeout (int): Timeout in seconds for the input.\n\n        Returns:\n            Any: The input data.\n        \"\"\"\n        self.logger.typewriter_log(\n            f\"Now, ASK For {key}, Origin Input: {value}\",\n            Fore.RED,\n            f\"\"\n        )\n        self.logger.typewriter_log(\n            f\"Now, you can modify the current field by entering some information, and then press 'Enter' to continue, if you want to keep the original input, please enter '-1' and then press 'Enter':\",\n            Fore.GREEN\n        )\n        temp = inputimeout(prompt=f'You have {timeout} seconds to input:\\n', timeout=timeout)\n        if temp == \"-1\":\n            return value\n        else:\n            return temp\n        \n    def get_input(self, origin_data):\n        \"\"\"\n        Get input for all fields of the original data from the command line.\n\n        Args:\n            origin_data (dict): The original data for which to get input.\n\n        Returns:\n            dict: The dictionary with updated inputs.\n        \"\"\"\n        self.logger.typewriter_log(\n                \"Next, you can start modifying the original input by typing 'Y/y/yes' or skip this step by typing 'N/n/no' and then press 'Enter' to continue the loop:\",\n                Fore.RED\n            )\n        update = inputimeout(prompt=f'You have to make a decision within 60 seconds:\\n', timeout=60)\n        res = {\"args\": {}}\n        if update in ['y', 'Y', 'yes']:\n            execute_time = self.max_wait_seconds\n            if isinstance(origin_data, dict):\n                args = origin_data.get(\"args\", \"\")\n                self.logger.typewriter_log(\n                    f\"Next, you will have a total of {self.max_wait_seconds} seconds to modify each option:\",\n                    Fore.RED,\n                )\n                for key, value in args.items():\n                    if key == \"done\":\n                        res[key] = False\n                        continue\n                    start_time = time.time()\n                    res[\"args\"][key] = self.get_each_input(key, value, res, execute_time)\n                    end_time = time.time()\n                    execute_time = math.floor(execute_time - (end_time - start_time))\n            self.logger.info(f\"modify the input, receive the data: {res}\")\n        else:\n            res = origin_data\n            self.logger.info(\"skip this step\")\n        self.logger.info(\"continue the loop\")\n        res[\"done\"] = True\n        return res\n    \n    def interrupt(self, input_data):\n        \"\"\"\n        Interrupts the current input process and returns the current data.\n\n        Args:\n            input_data (dict): The original input data.\n\n        Returns:\n            dict: The current data collected so far.\n\n        Raises:\n            XAgentIOTimeoutError: If the input times out.\n        \"\"\"\n        try:\n            data = self.get_input(input_data)\n            return data\n        except TimeoutOccurred:\n            self.logger.error(f\"Waiting timemout, close connection!\")\n            raise XAgentTimeoutError(\"timeout!\")"
        },
        {
          "name": "docker-compose.yml",
          "type": "blob",
          "size": 2.6123046875,
          "content": "version: '3'\n\nservices:\n  ToolServerManager:\n    image: xagentteam/toolserver-manager:latest\n    build:\n      context: ./\n      dockerfile: dockerfiles/ToolServerManager/Dockerfile\n    ports:\n      - 8080:8080\n    volumes:\n      - toolserverconfig:/app/assets/config\n      - /var/run/docker.sock:/var/run/docker.sock\n    environment:\n     DB_HOST: db\n     DB_PORT: 27017\n     DB_USERNAME: ${DB_USERNAME}\n     DB_PASSWORD: ${DB_PASSWORD}\n     DB_COLLECTION: ${DB_COLLECTION}\n    depends_on:\n      - db\n    command: [\"--workers\",\"2\",\"-t\",\"600\"]\n\n  # This will create a test node that will never be used by XAgent\n  ToolServerNode:\n    image: xagentteam/toolserver-node:latest\n    build:\n      context: ./\n      dockerfile: dockerfiles/ToolServerNode/Dockerfile\n    volumes:\n      - \"toolserverconfig:/app/assets/config\"\n\n  db:\n    image: mongo\n    volumes:\n      - xagentmongodb:/data/db\n    environment:\n     MONGO_INITDB_ROOT_USERNAME: ${DB_USERNAME}\n     MONGO_INITDB_ROOT_PASSWORD: ${DB_PASSWORD}\n    logging:\n      driver: \"none\"\n\n  XAgentServer:\n    image: xagentteam/xagent-server:latest\n    build:\n      context: ./\n      dockerfile: dockerfiles/XAgentServer/Dockerfile\n    container_name: XAgent-Server\n    env_file:\n      - .env\n    environment:\n      - TOOLSERVER_URL=http://ToolServerManager:8080\n      - MYSQL_DB_URL=mysql+pymysql://root:xagent@xagent-mysql:3306/xagent\n      - REDIS_HOST=xagent-redis\n    volumes:\n      - ./assets:/app/assets:ro\n    ports:\n      - \"5173:5173\"\n      - \"8090:8090\"\n    depends_on:\n      xagent-mysql:\n        condition: service_healthy\n      xagent-redis:\n        condition: service_healthy\n\n  xagent-mysql:\n    image: mysql\n    command:\n      - --default-authentication-plugin=caching_sha2_password\n      - --character-set-server=utf8mb4\n      - --collation-server=utf8mb4_unicode_ci\n    environment:\n      MYSQL_ROOT_PASSWORD: xagent\n    ports:\n      - \"3306:3306\"\n    volumes:\n      - ./XAgentServer/database/sql:/docker-entrypoint-initdb.d\n    healthcheck:\n      # test: [ \"CMD\", \"mysqladmin\",\"ping\", \"-h\", \"localhost\" ]\n      test: [\"CMD-SHELL\", \"mysql -h localhost -u root -pxagent -e 'SELECT 1'\"]\n      #interval: 10s\n      timeout: 20s\n      retries: 20\n\n  xagent-redis:\n    image: redis\n    ports:\n      - \"6379:6379\"\n    command: redis-server --requirepass xagent\n    healthcheck:\n      test: [ \"CMD\", \"redis-cli\", \"ping\" ]\n      interval: 5s\n      timeout: 3s\n      retries: 20\n\n\n\nvolumes:\n  xagentmongodb:\n  toolserverconfig:\n    name: toolserverconfig\n    driver: local\n    driver_opts:\n      type: none\n      device: ./assets/config\n      o: bind\nnetworks:\n  default:\n    name: tool-server-network\n    driver: bridge\n"
        },
        {
          "name": "dockerfiles",
          "type": "tree",
          "content": null
        },
        {
          "name": "local_workspace",
          "type": "tree",
          "content": null
        },
        {
          "name": "requirements.txt",
          "type": "blob",
          "size": 0.29296875,
          "content": "charset_normalizer\ncolorama\nfastapi\njsonschema\nMarkdown\norjson\nPillow\npydantic\nPyYAML\nregex\nRequests\nsetuptools\ntermcolor\ntiktoken\ntqdm\nuvicorn\njson5\nopenai\npython-dotenv\nsqlalchemy\ntenacity\nredis\npymysql\nyagmail\npython-multipart\napscheduler\npinecone-client\nwebsockets\ncryptography\ninputimeout\npytest"
        },
        {
          "name": "run.py",
          "type": "blob",
          "size": 4.025390625,
          "content": "import os\nfrom contextlib import redirect_stdout\nimport argparse\nfrom copy import deepcopy\nfrom XAgent.config import CONFIG, ARGS\nfrom command import CommandLine, CommandLineParam\n\n\ndef parse_args() -> argparse.Namespace:\n    \"\"\"\n    Parse the command line arguments and return them as an argparse.Namespace object.\n\n    Returns:\n        argparse.Namespace: An object containing command line arguments and their values.\n    \"\"\"\n    parser = argparse.ArgumentParser()\n\n    parser.add_argument(\"--task\", type=str, required=True, help=\"The task description.\")\n    parser.add_argument(\"--upload-files\", nargs='+', dest=\"upload_files\", help=\"List of files to upload.\")\n    parser.add_argument(\"--model\", type=str, help=\"Model identifier for the task.\")\n    parser.add_argument(\"--record-dir\", type=str, dest=\"record_dir\", help=\"Directory to record task execution logs.\")\n    parser.add_argument(\"--mode\", type=str, default=\"auto\", help=\"Operational mode: 'auto' or 'manual'.\")\n    parser.add_argument(\"--quiet\", action=\"store_true\", default=False, help=\"Run in quiet mode; minimal output.\")\n    parser.add_argument(\"--max-subtask-chain-length\", type=int, dest=\"max_subtask_chain_length\",\n                        help=\"Maximum length of subtask chain.\")\n    parser.add_argument(\"--enable-ask-human-for-help\", action=\"store_true\", dest=\"enable_ask_human_for_help\",\n                        help=\"Flag to enable asking for human assistance.\")\n    parser.add_argument(\"--max-plan-refine-chain-length\", type=int, dest=\"max_plan_refine_chain_length\",\n                        help=\"Maximum length of plan refinement chain.\")\n    parser.add_argument(\"--max-plan-tree-depth\", type=int, dest=\"max_plan_tree_depth\",\n                        help=\"Maximum depth of the plan tree.\")\n    parser.add_argument(\"--max-plan-tree-width\", type=int, dest=\"max_plan_tree_width\",\n                        help=\"Maximum width of the plan tree.\")\n    parser.add_argument(\"--max-retry-times\", type=int, dest=\"max_retry_times\", help=\"Maximum number of retry attempts.\")\n    parser.add_argument(\"--config-file\", type=str, default=os.getenv('CONFIG_FILE', 'assets/config.yml'),\n                        dest=\"config_file\", help=\"Path to the configuration file.\")\n\n    return parser.parse_args()\n\n\ndef execute_command_line_process(args: argparse.Namespace, quiet_mode: bool = False) -> None:\n    \"\"\"\n    Execute the command line process based on the parsed arguments. If quiet mode is enabled,\n    redirect stdout to a file specified by the recorder's record_root_dir.\n\n    Args:\n        args (argparse.Namespace): Parsed command line arguments.\n        quiet_mode (bool): Whether to run in quiet mode, outputting to a file instead of the terminal.\n    \"\"\"\n    args_dict = vars(args)\n    for key, value in args_dict.items():\n        if value is not None:\n            if key == 'model':\n                ARGS['default_completion_kwargs'] = deepcopy(CONFIG['default_completion_kwargs'])\n                ARGS['default_completion_kwargs']['model'] = value\n            else:\n                ARGS[key] = value\n\n    # Redirect stdout to a file if quiet mode is true\n    if quiet_mode:\n        from XAgent.running_recorder import recorder\n        record_file_path = os.path.join(recorder.record_root_dir, \"command_line.ansi\")\n        with open(record_file_path, \"w\", encoding=\"utf-8\") as file, redirect_stdout(file):\n            start_command_line(args_dict)\n    else:\n        start_command_line(args_dict)\n\n\ndef start_command_line(args_dict: dict) -> None:\n    \"\"\"\n    Start the command line interface with the provided arguments.\n\n    Args:\n        args_dict (dict): A dictionary of command line arguments.\n    \"\"\"\n    param = CommandLineParam(\n        task=args_dict['task'],\n        upload_files=args_dict.get('upload_files'),\n        role=\"Assistant\",\n        mode=args_dict[\"mode\"],\n    )\n    cmd = CommandLine(param)\n    cmd.start()\n\n\nif __name__ == '__main__':\n    args = parse_args()\n    os.environ['CONFIG_FILE'] = args.config_file\n\n    # The quiet_mode argument is passed directly to the function\n    execute_command_line_process(args, quiet_mode=args.quiet)\n"
        },
        {
          "name": "setup.py",
          "type": "blob",
          "size": 0.1796875,
          "content": "#!/usr/bin/env python3\n\n\"\"\"Set up\"\"\"\n\nfrom setuptools import find_packages\nfrom setuptools import setup\n\n\nsetup(\n    name=\"XAgent\",\n    version=\"1.0.0\",\n    packages=find_packages()\n)\n"
        },
        {
          "name": "start_server.py",
          "type": "blob",
          "size": 0.4033203125,
          "content": "\"\"\"Start server\"\"\"\nimport os\nimport uvicorn\n\nfrom XAgentServer.application.core.envs import XAgentServerEnv\n\nif __name__ == \"__main__\":\n    os.system(\"systemctl start nginx\")\n    uvicorn.run(app=\"XAgentServer.application.main:app\",\n                host=XAgentServerEnv.host,\n                port=XAgentServerEnv.port,\n                reload=XAgentServerEnv.reload,\n                workers=XAgentServerEnv.workers)"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}