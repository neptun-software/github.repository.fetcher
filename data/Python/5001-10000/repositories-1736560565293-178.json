{
  "metadata": {
    "timestamp": 1736560565293,
    "page": 178,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "OpenBMB/XAgent",
      "stars": 8282,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".env",
          "type": "blob",
          "size": 0.0888671875,
          "content": "DB_USERNAME=admin\nDB_PASSWORD=xagentmongodb\nDB_COLLECTION=TSM\nCONFIG_FILE=assets/config.yml"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.5712890625,
          "content": "*.egg-info\n\n**/__pycache__\n\nworkspace_cache/\n\nXAgent/logs/\nrunning_records/\n\nXAgentServer/localstorage\nXAgentServer/logs/\nXAgentServer/prod_server_envs.py\n\nXAgentWeb/node_modules\n**/node_modules/\nXAgentWeb/dist\n\n.DS_Store\n.vscode\n.idea\n*_running_records\n\ndata/**\ndata/server.db\nToolServerNode/logs/**\n**/workspace/**\ndownload_tmp_file\nlocal_workspace/**\n!local_workspace/readme.md\nsync.py\nassets/private.yml\nassets/garbage\n**.log\nlog/**\n\nXAgentWeb/src/api/backend.ts\nassets/config.yml\nassets/gpt4_config.yml\nconfig.yml\ngpt4_config.yml\nXAgentWeb/pnpm-lock.yaml\nXAgentWeb/pnpm-lock.yaml\n"
        },
        {
          "name": ".project_hierarchy.json",
          "type": "blob",
          "size": 1793.1328125,
          "content": "{\n    \"run.py\": {\n        \"parse_args\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"parse_args\",\n            \"md_content\": \"\",\n            \"code_start_line\": 9,\n            \"code_end_line\": 38,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"def parse_args() -> argparse.Namespace:\\n    \\\"\\\"\\\"\\n    Parse the command line arguments and return them as an argparse.Namespace object.\\n\\n    Returns:\\n        argparse.Namespace: An object containing command line arguments and their values.\\n    \\\"\\\"\\\"\\n    parser = argparse.ArgumentParser()\\n\\n    parser.add_argument(\\\"--task\\\", type=str, required=True, help=\\\"The task description.\\\")\\n    parser.add_argument(\\\"--upload-files\\\", nargs='+', dest=\\\"upload_files\\\", help=\\\"List of files to upload.\\\")\\n    parser.add_argument(\\\"--model\\\", type=str, help=\\\"Model identifier for the task.\\\")\\n    parser.add_argument(\\\"--record-dir\\\", type=str, dest=\\\"record_dir\\\", help=\\\"Directory to record task execution logs.\\\")\\n    parser.add_argument(\\\"--mode\\\", type=str, default=\\\"auto\\\", help=\\\"Operational mode: 'auto' or 'manual'.\\\")\\n    parser.add_argument(\\\"--quiet\\\", action=\\\"store_true\\\", default=False, help=\\\"Run in quiet mode; minimal output.\\\")\\n    parser.add_argument(\\\"--max-subtask-chain-length\\\", type=int, dest=\\\"max_subtask_chain_length\\\",\\n                        help=\\\"Maximum length of subtask chain.\\\")\\n    parser.add_argument(\\\"--enable-ask-human-for-help\\\", action=\\\"store_true\\\", dest=\\\"enable_ask_human_for_help\\\",\\n                        help=\\\"Flag to enable asking for human assistance.\\\")\\n    parser.add_argument(\\\"--max-plan-refine-chain-length\\\", type=int, dest=\\\"max_plan_refine_chain_length\\\",\\n                        help=\\\"Maximum length of plan refinement chain.\\\")\\n    parser.add_argument(\\\"--max-plan-tree-depth\\\", type=int, dest=\\\"max_plan_tree_depth\\\",\\n                        help=\\\"Maximum depth of the plan tree.\\\")\\n    parser.add_argument(\\\"--max-plan-tree-width\\\", type=int, dest=\\\"max_plan_tree_width\\\",\\n                        help=\\\"Maximum width of the plan tree.\\\")\\n    parser.add_argument(\\\"--max-retry-times\\\", type=int, dest=\\\"max_retry_times\\\", help=\\\"Maximum number of retry attempts.\\\")\\n    parser.add_argument(\\\"--config-file\\\", type=str, default=os.getenv('CONFIG_FILE', 'assets/config.yml'),\\n                        dest=\\\"config_file\\\", help=\\\"Path to the configuration file.\\\")\\n\\n    return parser.parse_args()\\n\",\n            \"name_column\": 4\n        },\n        \"execute_command_line_process\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"execute_command_line_process\",\n            \"md_content\": \"\",\n            \"code_start_line\": 41,\n            \"code_end_line\": 66,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"def execute_command_line_process(args: argparse.Namespace, quiet_mode: bool = False) -> None:\\n    \\\"\\\"\\\"\\n    Execute the command line process based on the parsed arguments. If quiet mode is enabled,\\n    redirect stdout to a file specified by the recorder's record_root_dir.\\n\\n    Args:\\n        args (argparse.Namespace): Parsed command line arguments.\\n        quiet_mode (bool): Whether to run in quiet mode, outputting to a file instead of the terminal.\\n    \\\"\\\"\\\"\\n    args_dict = vars(args)\\n    for key, value in args_dict.items():\\n        if value is not None:\\n            if key == 'model':\\n                ARGS['default_completion_kwargs'] = deepcopy(CONFIG['default_completion_kwargs'])\\n                ARGS['default_completion_kwargs']['model'] = value\\n            else:\\n                ARGS[key] = value\\n\\n    # Redirect stdout to a file if quiet mode is true\\n    if quiet_mode:\\n        from XAgent.running_recorder import recorder\\n        record_file_path = os.path.join(recorder.record_root_dir, \\\"command_line.ansi\\\")\\n        with open(record_file_path, \\\"w\\\", encoding=\\\"utf-8\\\") as file, redirect_stdout(file):\\n            start_command_line(args_dict)\\n    else:\\n        start_command_line(args_dict)\\n\",\n            \"name_column\": 4\n        },\n        \"start_command_line\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"start_command_line\",\n            \"md_content\": \"\",\n            \"code_start_line\": 69,\n            \"code_end_line\": 83,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"def start_command_line(args_dict: dict) -> None:\\n    \\\"\\\"\\\"\\n    Start the command line interface with the provided arguments.\\n\\n    Args:\\n        args_dict (dict): A dictionary of command line arguments.\\n    \\\"\\\"\\\"\\n    param = CommandLineParam(\\n        task=args_dict['task'],\\n        upload_files=args_dict.get('upload_files'),\\n        role=\\\"Assistant\\\",\\n        mode=args_dict[\\\"mode\\\"],\\n    )\\n    cmd = CommandLine(param)\\n    cmd.start()\\n\",\n            \"name_column\": 4\n        }\n    },\n    \"command.py\": {\n        \"get_db\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"get_db\",\n            \"md_content\": \"\",\n            \"code_start_line\": 33,\n            \"code_end_line\": 45,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"def get_db():\\n    \\\"\\\"\\\"\\n    Provide a transactional scope around a series of operations.\\n    \\\"\\\"\\\"\\n    session = SessionLocal()\\n    try:\\n        yield session\\n        session.commit()\\n    except:\\n        session.rollback()\\n        raise\\n    finally:\\n        session.close()\\n\",\n            \"name_column\": 4\n        },\n        \"CommandLineParam\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"CommandLineParam\",\n            \"md_content\": \"\",\n            \"code_start_line\": 48,\n            \"code_end_line\": 85,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"class CommandLineParam:\\n    \\\"\\\"\\\"Command line parameters.\\n    \\n    Attributes:\\n            task: Task description.\\n            role: Role name (default is \\\"Assistant\\\").\\n            plan: List of steps to perform (default is empty list).\\n            upload_files: List of files to upload (default is empty list).\\n            download_files: List of files to download (default is empty list).\\n            record_dir: Directory to store records (default is `None`).\\n            mode: Run mode. Can be \\\"auto\\\" (default is \\\"auto\\\").\\n            max_wait_seconds: Maximum wait time in seconds (default is 600).\\n            description: Description of the interaction (default is \\\"XAgent-Test\\\").\\n            agent: Agent name (default is \\\"XAgent\\\").\\n    \\\"\\\"\\\"\\n    def __init__(self,\\n                 task,\\n                role=\\\"Assistant\\\",\\n                plan=[],\\n                upload_files: List[str] = [],\\n                download_files: List[str] = [],\\n                record_dir: str = None,\\n                mode: str = \\\"auto\\\",\\n                max_wait_seconds: int = 600,\\n                description: str = \\\"XAgent-Test\\\",\\n                agent: str = \\\"XAgent\\\",\\n                ):\\n        self.task = task\\n        self.plan = plan\\n        self.role = role\\n        self.upload_files = upload_files\\n        self.download_files = download_files\\n        self.record_dir = record_dir\\n        # auto is supported only in cmd\\n        self.mode = \\\"auto\\\"\\n        self.max_wait_seconds = max_wait_seconds\\n        self.description = description\\n        self.agent = agent\\n\",\n            \"name_column\": 6\n        },\n        \"CommandLine\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"CommandLine\",\n            \"md_content\": \"\",\n            \"code_start_line\": 88,\n            \"code_end_line\": 290,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"class CommandLine():\\n    \\\"\\\"\\\"\\n    A command-line interface for interacting with XAgentServer.\\n\\n    Attributes:\\n        env: An instance of the XAgentServer environment.\\n        client_id: A unique identifier for the client, generated as a hexadecimal UUID.\\n        date_str: The current date as a string in YYYY-MM-DD format.\\n        log_dir: The directory where the logs are stored.\\n        logger: An instance of the Logger used for logging interactions.\\n        interactionDB: A database interface for interacting with either a persistent\\n            database (SQLite, MySQL, PostgreSQL) or a local storage file, depending\\n            on the configuration of `env`.\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, args: CommandLineParam = None):\\n        \\\"\\\"\\\"\\n        Initialize the CommandLine instance.\\n\\n        Args:\\n            args (CommandLineParam) : parameters.\\n            task is required,\\n            mode options: [\\\"auto\\\"]\\n        \\\"\\\"\\\"\\n\\n        self.args = args\\n        self.client_id = uuid.uuid4().hex\\n        self.date_str = datetime.now().strftime(\\\"%Y-%m-%d\\\")\\n        self.log_dir = os.path.join(os.path.join(XAgentServerEnv.base_dir, \\\"localstorage\\\",\\n                                    \\\"interact_records\\\"), self.date_str, self.client_id)\\n        if not os.path.exists(self.log_dir):\\n            os.makedirs(self.log_dir)\\n\\n        self.logger = Logger(log_dir=self.log_dir, log_file=f\\\"interact.log\\\")\\n\\n        self.logger.typewriter_log(\\n            title=f\\\"XAgentServer is running on cmd mode\\\",\\n            title_color=Fore.RED)\\n        self.logger.info(title=f\\\"XAgentServer log:\\\",\\n                         title_color=Fore.RED, message=f\\\"{self.log_dir}\\\")\\n        self.interrupt = self.args.mode != \\\"auto\\\"\\n        self.init_conv_env()\\n        self.max_wait_seconds = self.args.max_wait_seconds\\n        self.scheduler = AsyncIOScheduler()\\n        self.input = None\\n        if self.interrupt:\\n            self.input = CommandLineInput(\\n                do_interrupt=True,\\n                max_wait_seconds=self.max_wait_seconds,\\n                logger=self.logger)\\n\\n    def init_conv_env(self):\\n        \\\"\\\"\\\"initialize the conversation environment, \\n        Share the same database resource with webui.\\n        If you have initiated a session on the front end but it has not been executed, \\n        this ID will be shared.\\n        \\\"\\\"\\\"\\n        user_id = \\\"guest\\\"\\n        token = \\\"xagent\\\"\\n        description = self.args.description\\n        upload_files = self.args.upload_files\\n        record_dir = self.args.record_dir\\n        agent = self.args.agent\\n        goal = self.args.task\\n        mode = self.args.mode\\n        plan = self.args.plan\\n\\n        with get_db() as db:\\n            interaction = InteractionCRUD.get_ready_interaction(\\n                db=db, user_id=user_id)\\n            self.continue_flag = True\\n            upload_files = upload_files if upload_files else []\\n            file_list = []\\n            for file in upload_files:\\n                file_list.append({\\n                    \\\"uuid\\\": file,\\n                    \\\"name\\\": file\\n                })\\n            if interaction is None:\\n\\n                base = InteractionBase(interaction_id=self.client_id,\\n                                       user_id=user_id,\\n                                       create_time=datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\"),\\n                                       description=description,\\n                                       agent=agent,\\n                                       mode=mode,\\n                                       file_list=file_list,\\n                                       recorder_root_dir=\\\"\\\",\\n                                       status=\\\"ready\\\",\\n                                       message=\\\"ready...\\\",\\n                                       current_step=\\\"-1\\\",\\n                                       update_time=datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\"),\\n                                       call_method=\\\"cmd\\\")\\n                InteractionCRUD.create_interaction(db=db, base=base)\\n            else:\\n                self.client_id = interaction.interaction_id\\n            \\n            parameter = InteractionParameter(\\n                interaction_id=self.client_id,\\n                parameter_id=uuid.uuid4().hex,\\n                args={\\n                    \\\"goal\\\": goal,\\n                    \\\"plan\\\": plan\\n                    },\\n            )\\n            InteractionCRUD.add_parameter(db=db, parameter=parameter)\\n\\n\\n    def run(self):\\n        \\\"\\\"\\\"\\n        Runs the interaction with the XAgentServer with the provided arguments.\\n        \\\"\\\"\\\"\\n\\n        # Create a new raw data to record\\n        with get_db() as db:\\n            InteractionCRUD.insert_raw(db=db, process=XAgentRaw(\\n                interaction_id=self.client_id,\\n                node_id=uuid.uuid4().hex,\\n                status=StatusEnum.RUNNING,\\n                create_time=datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\"),\\n                update_time=datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\"),\\n                current=\\\"\\\",\\n                step=-1,\\n                data=None,\\n                file_list=[],\\n                do_interrupt=self.interrupt,\\n                wait_seconds=0,\\n                ask_for_human_help=False,\\n                is_human=True,\\n                human_data={\\\"goal\\\": self.args.task, \\\"plan\\\": self.args.plan},\\n                human_file_list=self.args.upload_files,\\n                is_send=True,\\n                is_receive=False,\\n                is_deleted=False\\n            ))\\n            redis.set_key(f\\\"{self.client_id}_send\\\", 1)\\n            \\n            parameter = InteractionCRUD.get_init_parameter(\\n                db=db, interaction_id=self.client_id)\\n        \\n        self.task_handler(parameter=parameter)\\n\\n    def task_handler(self, parameter: InteractionParameter):\\n        \\\"\\\"\\\"\\n        define a long task to run interaction\\n\\n        Args:\\n            parameter (InteractionParameter): The parameter of interaction\\n        \\\"\\\"\\\"\\n\\n        try:\\n            current_step = uuid.uuid4().hex\\n            with get_db() as db:\\n                base = InteractionCRUD.get_interaction(db=db,\\n                                                    interaction_id=self.client_id)\\n                InteractionCRUD.update_interaction_status(db=db,\\n                                                        interaction_id=base.interaction_id,\\n                                                        status=\\\"running\\\",\\n                                                        message=\\\"running\\\",\\n                                                        current_step=current_step)\\n\\n            # if mode is not auto, we will interrupt the interaction\\n            # and you can change the wait_seconds\\n            # default 10 min.\\n            interaction = XAgentInteraction(\\n                base=base,\\n                parameter=parameter,\\n                interrupt=base.mode != \\\"auto\\\",\\n                call_method=\\\"cmd\\\")\\n\\n            # Register logger, dbinto interaction\\n            interaction.resister_logger(self.logger)\\n            self.logger.info(\\n                f\\\"Register logger into interaction of {base.interaction_id}, done!\\\")\\n\\n            interaction.register_db(db=db)\\n            self.logger.info(\\n                f\\\"Register db into interaction of {base.interaction_id}, done!\\\")\\n            # Create XAgentServer\\n            server = XAgentServer(logger=self.logger)\\n            self.logger.info(\\n                f\\\"Register logger into XAgentServer of {base.interaction_id}, done!\\\")\\n            self.logger.info(\\n                f\\\"Start a new thread to run interaction of {base.interaction_id}, done!\\\")\\n            # await server.interact(interaction=interaction)\\n            server.interact(interaction=interaction)\\n        except XAgentError as e:\\n            traceback.print_exc()\\n            self.logger.error(\\n                f\\\"Error in task_handler of {self.client_id}: {e}\\\")\\n            with get_db() as db:\\n                InteractionCRUD.insert_error(\\n                    db=db, interaction_id=self.client_id, message=str(e))\\n                redis.set_key(self.client_id + \\\"_send\\\", 1)\\n                InteractionCRUD.update_interaction_status(db=db,\\n                                                        interaction_id=self.client_id,\\n                                                        status=\\\"failed\\\",\\n                                                        message=str(e),\\n                                                        current_step=current_step)\\n        \\n    def start(self):\\n\\n        self.run()\\n\",\n            \"name_column\": 6\n        },\n        \"__init__\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"__init__\",\n            \"md_content\": \"\",\n            \"code_start_line\": 103,\n            \"code_end_line\": 137,\n            \"parent\": \"CommandLine\",\n            \"have_return\": false,\n            \"code_content\": \"    def __init__(self, args: CommandLineParam = None):\\n        \\\"\\\"\\\"\\n        Initialize the CommandLine instance.\\n\\n        Args:\\n            args (CommandLineParam) : parameters.\\n            task is required,\\n            mode options: [\\\"auto\\\"]\\n        \\\"\\\"\\\"\\n\\n        self.args = args\\n        self.client_id = uuid.uuid4().hex\\n        self.date_str = datetime.now().strftime(\\\"%Y-%m-%d\\\")\\n        self.log_dir = os.path.join(os.path.join(XAgentServerEnv.base_dir, \\\"localstorage\\\",\\n                                    \\\"interact_records\\\"), self.date_str, self.client_id)\\n        if not os.path.exists(self.log_dir):\\n            os.makedirs(self.log_dir)\\n\\n        self.logger = Logger(log_dir=self.log_dir, log_file=f\\\"interact.log\\\")\\n\\n        self.logger.typewriter_log(\\n            title=f\\\"XAgentServer is running on cmd mode\\\",\\n            title_color=Fore.RED)\\n        self.logger.info(title=f\\\"XAgentServer log:\\\",\\n                         title_color=Fore.RED, message=f\\\"{self.log_dir}\\\")\\n        self.interrupt = self.args.mode != \\\"auto\\\"\\n        self.init_conv_env()\\n        self.max_wait_seconds = self.args.max_wait_seconds\\n        self.scheduler = AsyncIOScheduler()\\n        self.input = None\\n        if self.interrupt:\\n            self.input = CommandLineInput(\\n                do_interrupt=True,\\n                max_wait_seconds=self.max_wait_seconds,\\n                logger=self.logger)\\n\",\n            \"name_column\": 8\n        },\n        \"init_conv_env\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"init_conv_env\",\n            \"md_content\": \"\",\n            \"code_start_line\": 139,\n            \"code_end_line\": 193,\n            \"parent\": \"CommandLine\",\n            \"have_return\": false,\n            \"code_content\": \"    def init_conv_env(self):\\n        \\\"\\\"\\\"initialize the conversation environment, \\n        Share the same database resource with webui.\\n        If you have initiated a session on the front end but it has not been executed, \\n        this ID will be shared.\\n        \\\"\\\"\\\"\\n        user_id = \\\"guest\\\"\\n        token = \\\"xagent\\\"\\n        description = self.args.description\\n        upload_files = self.args.upload_files\\n        record_dir = self.args.record_dir\\n        agent = self.args.agent\\n        goal = self.args.task\\n        mode = self.args.mode\\n        plan = self.args.plan\\n\\n        with get_db() as db:\\n            interaction = InteractionCRUD.get_ready_interaction(\\n                db=db, user_id=user_id)\\n            self.continue_flag = True\\n            upload_files = upload_files if upload_files else []\\n            file_list = []\\n            for file in upload_files:\\n                file_list.append({\\n                    \\\"uuid\\\": file,\\n                    \\\"name\\\": file\\n                })\\n            if interaction is None:\\n\\n                base = InteractionBase(interaction_id=self.client_id,\\n                                       user_id=user_id,\\n                                       create_time=datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\"),\\n                                       description=description,\\n                                       agent=agent,\\n                                       mode=mode,\\n                                       file_list=file_list,\\n                                       recorder_root_dir=\\\"\\\",\\n                                       status=\\\"ready\\\",\\n                                       message=\\\"ready...\\\",\\n                                       current_step=\\\"-1\\\",\\n                                       update_time=datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\"),\\n                                       call_method=\\\"cmd\\\")\\n                InteractionCRUD.create_interaction(db=db, base=base)\\n            else:\\n                self.client_id = interaction.interaction_id\\n            \\n            parameter = InteractionParameter(\\n                interaction_id=self.client_id,\\n                parameter_id=uuid.uuid4().hex,\\n                args={\\n                    \\\"goal\\\": goal,\\n                    \\\"plan\\\": plan\\n                    },\\n            )\\n            InteractionCRUD.add_parameter(db=db, parameter=parameter)\\n\",\n            \"name_column\": 8\n        },\n        \"run\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"run\",\n            \"md_content\": \"\",\n            \"code_start_line\": 196,\n            \"code_end_line\": 228,\n            \"parent\": \"CommandLine\",\n            \"have_return\": false,\n            \"code_content\": \"    def run(self):\\n        \\\"\\\"\\\"\\n        Runs the interaction with the XAgentServer with the provided arguments.\\n        \\\"\\\"\\\"\\n\\n        # Create a new raw data to record\\n        with get_db() as db:\\n            InteractionCRUD.insert_raw(db=db, process=XAgentRaw(\\n                interaction_id=self.client_id,\\n                node_id=uuid.uuid4().hex,\\n                status=StatusEnum.RUNNING,\\n                create_time=datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\"),\\n                update_time=datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\"),\\n                current=\\\"\\\",\\n                step=-1,\\n                data=None,\\n                file_list=[],\\n                do_interrupt=self.interrupt,\\n                wait_seconds=0,\\n                ask_for_human_help=False,\\n                is_human=True,\\n                human_data={\\\"goal\\\": self.args.task, \\\"plan\\\": self.args.plan},\\n                human_file_list=self.args.upload_files,\\n                is_send=True,\\n                is_receive=False,\\n                is_deleted=False\\n            ))\\n            redis.set_key(f\\\"{self.client_id}_send\\\", 1)\\n            \\n            parameter = InteractionCRUD.get_init_parameter(\\n                db=db, interaction_id=self.client_id)\\n        \\n        self.task_handler(parameter=parameter)\\n\",\n            \"name_column\": 8\n        },\n        \"task_handler\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"task_handler\",\n            \"md_content\": \"\",\n            \"code_start_line\": 230,\n            \"code_end_line\": 286,\n            \"parent\": \"CommandLine\",\n            \"have_return\": false,\n            \"code_content\": \"    def task_handler(self, parameter: InteractionParameter):\\n        \\\"\\\"\\\"\\n        define a long task to run interaction\\n\\n        Args:\\n            parameter (InteractionParameter): The parameter of interaction\\n        \\\"\\\"\\\"\\n\\n        try:\\n            current_step = uuid.uuid4().hex\\n            with get_db() as db:\\n                base = InteractionCRUD.get_interaction(db=db,\\n                                                    interaction_id=self.client_id)\\n                InteractionCRUD.update_interaction_status(db=db,\\n                                                        interaction_id=base.interaction_id,\\n                                                        status=\\\"running\\\",\\n                                                        message=\\\"running\\\",\\n                                                        current_step=current_step)\\n\\n            # if mode is not auto, we will interrupt the interaction\\n            # and you can change the wait_seconds\\n            # default 10 min.\\n            interaction = XAgentInteraction(\\n                base=base,\\n                parameter=parameter,\\n                interrupt=base.mode != \\\"auto\\\",\\n                call_method=\\\"cmd\\\")\\n\\n            # Register logger, dbinto interaction\\n            interaction.resister_logger(self.logger)\\n            self.logger.info(\\n                f\\\"Register logger into interaction of {base.interaction_id}, done!\\\")\\n\\n            interaction.register_db(db=db)\\n            self.logger.info(\\n                f\\\"Register db into interaction of {base.interaction_id}, done!\\\")\\n            # Create XAgentServer\\n            server = XAgentServer(logger=self.logger)\\n            self.logger.info(\\n                f\\\"Register logger into XAgentServer of {base.interaction_id}, done!\\\")\\n            self.logger.info(\\n                f\\\"Start a new thread to run interaction of {base.interaction_id}, done!\\\")\\n            # await server.interact(interaction=interaction)\\n            server.interact(interaction=interaction)\\n        except XAgentError as e:\\n            traceback.print_exc()\\n            self.logger.error(\\n                f\\\"Error in task_handler of {self.client_id}: {e}\\\")\\n            with get_db() as db:\\n                InteractionCRUD.insert_error(\\n                    db=db, interaction_id=self.client_id, message=str(e))\\n                redis.set_key(self.client_id + \\\"_send\\\", 1)\\n                InteractionCRUD.update_interaction_status(db=db,\\n                                                        interaction_id=self.client_id,\\n                                                        status=\\\"failed\\\",\\n                                                        message=str(e),\\n                                                        current_step=current_step)\\n\",\n            \"name_column\": 8\n        },\n        \"start\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"start\",\n            \"md_content\": \"\",\n            \"code_start_line\": 288,\n            \"code_end_line\": 290,\n            \"parent\": \"CommandLine\",\n            \"have_return\": false,\n            \"code_content\": \"    def start(self):\\n\\n        self.run()\\n\",\n            \"name_column\": 8\n        }\n    },\n    \"command_input.py\": {\n        \"timer\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"timer\",\n            \"md_content\": \"\",\n            \"code_start_line\": 12,\n            \"code_end_line\": 30,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"def timer(func):\\n    \\\"\\\"\\\"\\n    Decorator function to time the execution of a function.\\n\\n    Args:\\n        func (Function): The function to be timed.\\n\\n    Returns:\\n        wrapper (Function): The wrapped function with added timing functionality.\\n    \\\"\\\"\\\"\\n    @functools.wraps(func)\\n    def wrapper(*args, **kwargs):\\n        try:\\n            start_time = time.time()\\n            result = func(*args, **kwargs)\\n            end_time = time.time()\\n        except:\\n            pass\\n    return wrapper\\n\",\n            \"name_column\": 4\n        },\n        \"CommandLineInput\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"CommandLineInput\",\n            \"md_content\": \"\",\n            \"code_start_line\": 33,\n            \"code_end_line\": 153,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"class CommandLineInput:\\n    \\\"\\\"\\\"\\n    Class for handling command line input.\\n\\n    This child class extends from BaseInput and implements methods to handle and manage command line input data.\\n\\n    Attributes:\\n        do_interrupt (bool): If True, input will be interrupted.\\n        max_wait_seconds (int): Maximum wait time for input in seconds.\\n    \\\"\\\"\\\"\\n    def __init__(self,\\n                 do_interrupt: bool = False,\\n                 max_wait_seconds: int = 600,\\n                 logger=None):\\n        self.do_interrupt = do_interrupt\\n        self.max_wait_seconds = max_wait_seconds\\n        self.logger = logger\\n\\n    def run(self, input_data):\\n        \\\"\\\"\\\"\\n        Run the command line input method.\\n\\n        Args:\\n            input_data (Any): The original input data to be processed.\\n\\n        Returns:\\n            data (Any): The processed input data.\\n        \\\"\\\"\\\"\\n        if self.do_interrupt:\\n            data = self.interrupt(input_data)\\n        else:\\n            data = input_data\\n        return data\\n    \\n    def get_each_input(self, key, value, res, timeout):\\n        \\\"\\\"\\\"\\n        Returns the input from the command line for a single key-value pair.\\n\\n        Args:\\n            key (str): The key for which to get input.\\n            value (Any): The current value associated with the key.\\n            res (dict): The result dictionary where inputs collected will be stored.\\n            timeout (int): Timeout in seconds for the input.\\n\\n        Returns:\\n            Any: The input data.\\n        \\\"\\\"\\\"\\n        self.logger.typewriter_log(\\n            f\\\"Now, ASK For {key}, Origin Input: {value}\\\",\\n            Fore.RED,\\n            f\\\"\\\"\\n        )\\n        self.logger.typewriter_log(\\n            f\\\"Now, you can modify the current field by entering some information, and then press 'Enter' to continue, if you want to keep the original input, please enter '-1' and then press 'Enter':\\\",\\n            Fore.GREEN\\n        )\\n        temp = inputimeout(prompt=f'You have {timeout} seconds to input:\\\\n', timeout=timeout)\\n        if temp == \\\"-1\\\":\\n            return value\\n        else:\\n            return temp\\n        \\n    def get_input(self, origin_data):\\n        \\\"\\\"\\\"\\n        Get input for all fields of the original data from the command line.\\n\\n        Args:\\n            origin_data (dict): The original data for which to get input.\\n\\n        Returns:\\n            dict: The dictionary with updated inputs.\\n        \\\"\\\"\\\"\\n        self.logger.typewriter_log(\\n                \\\"Next, you can start modifying the original input by typing 'Y/y/yes' or skip this step by typing 'N/n/no' and then press 'Enter' to continue the loop:\\\",\\n                Fore.RED\\n            )\\n        update = inputimeout(prompt=f'You have to make a decision within 60 seconds:\\\\n', timeout=60)\\n        res = {\\\"args\\\": {}}\\n        if update in ['y', 'Y', 'yes']:\\n            execute_time = self.max_wait_seconds\\n            if isinstance(origin_data, dict):\\n                args = origin_data.get(\\\"args\\\", \\\"\\\")\\n                self.logger.typewriter_log(\\n                    f\\\"Next, you will have a total of {self.max_wait_seconds} seconds to modify each option:\\\",\\n                    Fore.RED,\\n                )\\n                for key, value in args.items():\\n                    if key == \\\"done\\\":\\n                        res[key] = False\\n                        continue\\n                    start_time = time.time()\\n                    res[\\\"args\\\"][key] = self.get_each_input(key, value, res, execute_time)\\n                    end_time = time.time()\\n                    execute_time = math.floor(execute_time - (end_time - start_time))\\n            self.logger.info(f\\\"modify the input, receive the data: {res}\\\")\\n        else:\\n            res = origin_data\\n            self.logger.info(\\\"skip this step\\\")\\n        self.logger.info(\\\"continue the loop\\\")\\n        res[\\\"done\\\"] = True\\n        return res\\n    \\n    def interrupt(self, input_data):\\n        \\\"\\\"\\\"\\n        Interrupts the current input process and returns the current data.\\n\\n        Args:\\n            input_data (dict): The original input data.\\n\\n        Returns:\\n            dict: The current data collected so far.\\n\\n        Raises:\\n            XAgentIOTimeoutError: If the input times out.\\n        \\\"\\\"\\\"\\n        try:\\n            data = self.get_input(input_data)\\n            return data\\n        except TimeoutOccurred:\\n            self.logger.error(f\\\"Waiting timemout, close connection!\\\")\\n            raise XAgentTimeoutError(\\\"timeout!\\\")\",\n            \"name_column\": 6\n        },\n        \"wrapper\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"wrapper\",\n            \"md_content\": \"\",\n            \"code_start_line\": 23,\n            \"code_end_line\": 29,\n            \"parent\": \"timer\",\n            \"have_return\": false,\n            \"code_content\": \"    def wrapper(*args, **kwargs):\\n        try:\\n            start_time = time.time()\\n            result = func(*args, **kwargs)\\n            end_time = time.time()\\n        except:\\n            pass\\n\",\n            \"name_column\": 8\n        },\n        \"__init__\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"__init__\",\n            \"md_content\": \"\",\n            \"code_start_line\": 43,\n            \"code_end_line\": 49,\n            \"parent\": \"CommandLineInput\",\n            \"have_return\": false,\n            \"code_content\": \"    def __init__(self,\\n                 do_interrupt: bool = False,\\n                 max_wait_seconds: int = 600,\\n                 logger=None):\\n        self.do_interrupt = do_interrupt\\n        self.max_wait_seconds = max_wait_seconds\\n        self.logger = logger\\n\",\n            \"name_column\": 8\n        },\n        \"run\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"run\",\n            \"md_content\": \"\",\n            \"code_start_line\": 51,\n            \"code_end_line\": 65,\n            \"parent\": \"CommandLineInput\",\n            \"have_return\": true,\n            \"code_content\": \"    def run(self, input_data):\\n        \\\"\\\"\\\"\\n        Run the command line input method.\\n\\n        Args:\\n            input_data (Any): The original input data to be processed.\\n\\n        Returns:\\n            data (Any): The processed input data.\\n        \\\"\\\"\\\"\\n        if self.do_interrupt:\\n            data = self.interrupt(input_data)\\n        else:\\n            data = input_data\\n        return data\\n\",\n            \"name_column\": 8\n        },\n        \"get_each_input\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"get_each_input\",\n            \"md_content\": \"\",\n            \"code_start_line\": 67,\n            \"code_end_line\": 93,\n            \"parent\": \"CommandLineInput\",\n            \"have_return\": true,\n            \"code_content\": \"    def get_each_input(self, key, value, res, timeout):\\n        \\\"\\\"\\\"\\n        Returns the input from the command line for a single key-value pair.\\n\\n        Args:\\n            key (str): The key for which to get input.\\n            value (Any): The current value associated with the key.\\n            res (dict): The result dictionary where inputs collected will be stored.\\n            timeout (int): Timeout in seconds for the input.\\n\\n        Returns:\\n            Any: The input data.\\n        \\\"\\\"\\\"\\n        self.logger.typewriter_log(\\n            f\\\"Now, ASK For {key}, Origin Input: {value}\\\",\\n            Fore.RED,\\n            f\\\"\\\"\\n        )\\n        self.logger.typewriter_log(\\n            f\\\"Now, you can modify the current field by entering some information, and then press 'Enter' to continue, if you want to keep the original input, please enter '-1' and then press 'Enter':\\\",\\n            Fore.GREEN\\n        )\\n        temp = inputimeout(prompt=f'You have {timeout} seconds to input:\\\\n', timeout=timeout)\\n        if temp == \\\"-1\\\":\\n            return value\\n        else:\\n            return temp\\n\",\n            \"name_column\": 8\n        },\n        \"get_input\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"get_input\",\n            \"md_content\": \"\",\n            \"code_start_line\": 95,\n            \"code_end_line\": 133,\n            \"parent\": \"CommandLineInput\",\n            \"have_return\": true,\n            \"code_content\": \"    def get_input(self, origin_data):\\n        \\\"\\\"\\\"\\n        Get input for all fields of the original data from the command line.\\n\\n        Args:\\n            origin_data (dict): The original data for which to get input.\\n\\n        Returns:\\n            dict: The dictionary with updated inputs.\\n        \\\"\\\"\\\"\\n        self.logger.typewriter_log(\\n                \\\"Next, you can start modifying the original input by typing 'Y/y/yes' or skip this step by typing 'N/n/no' and then press 'Enter' to continue the loop:\\\",\\n                Fore.RED\\n            )\\n        update = inputimeout(prompt=f'You have to make a decision within 60 seconds:\\\\n', timeout=60)\\n        res = {\\\"args\\\": {}}\\n        if update in ['y', 'Y', 'yes']:\\n            execute_time = self.max_wait_seconds\\n            if isinstance(origin_data, dict):\\n                args = origin_data.get(\\\"args\\\", \\\"\\\")\\n                self.logger.typewriter_log(\\n                    f\\\"Next, you will have a total of {self.max_wait_seconds} seconds to modify each option:\\\",\\n                    Fore.RED,\\n                )\\n                for key, value in args.items():\\n                    if key == \\\"done\\\":\\n                        res[key] = False\\n                        continue\\n                    start_time = time.time()\\n                    res[\\\"args\\\"][key] = self.get_each_input(key, value, res, execute_time)\\n                    end_time = time.time()\\n                    execute_time = math.floor(execute_time - (end_time - start_time))\\n            self.logger.info(f\\\"modify the input, receive the data: {res}\\\")\\n        else:\\n            res = origin_data\\n            self.logger.info(\\\"skip this step\\\")\\n        self.logger.info(\\\"continue the loop\\\")\\n        res[\\\"done\\\"] = True\\n        return res\\n\",\n            \"name_column\": 8\n        },\n        \"interrupt\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"interrupt\",\n            \"md_content\": \"\",\n            \"code_start_line\": 135,\n            \"code_end_line\": 153,\n            \"parent\": \"CommandLineInput\",\n            \"have_return\": true,\n            \"code_content\": \"    def interrupt(self, input_data):\\n        \\\"\\\"\\\"\\n        Interrupts the current input process and returns the current data.\\n\\n        Args:\\n            input_data (dict): The original input data.\\n\\n        Returns:\\n            dict: The current data collected so far.\\n\\n        Raises:\\n            XAgentIOTimeoutError: If the input times out.\\n        \\\"\\\"\\\"\\n        try:\\n            data = self.get_input(input_data)\\n            return data\\n        except TimeoutOccurred:\\n            self.logger.error(f\\\"Waiting timemout, close connection!\\\")\\n            raise XAgentTimeoutError(\\\"timeout!\\\")\",\n            \"name_column\": 8\n        }\n    },\n    \"setup.py\": {},\n    \"start_server.py\": {},\n    \"ToolServer/ToolServerManager/config.py\": {\n        \"ManagerConfig\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"ManagerConfig\",\n            \"md_content\": \"\",\n            \"code_start_line\": 8,\n            \"code_end_line\": 63,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"class ManagerConfig:\\n    \\\"\\\"\\\"\\n    This class manages configuration settings for the application.\\n    Configuration settings are initially loaded from a yaml file. \\n    However, if an environment variable exists with the same name as a configuration setting, \\n    the value from the environment variable will be used instead.\\n\\n    Attributes:\\n        cfg: A dictionary containing all configuration settings.\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, config_file_path=\\\"./assets/config/manager.yml\\\"):\\n        \\\"\\\"\\\"\\n        Initializes a new instance of the ManagerConfig class.\\n\\n        Args:\\n            config_file_path (str, optional): The path to a yaml file containing configuration settings. \\n            Defaults to \\\"./assets/config.yml\\\".\\n        \\\"\\\"\\\"\\n        self.cfg:Dict = yaml.load(open(config_file_path,\\\"r\\\",encoding=\\\"utf-8\\\").read(), Loader=yaml.FullLoader)\\n        for k in os.environ.keys():\\n            if k in self.cfg:\\n                self.cfg[k] = os.environ[k]  # overwrite the config with environment variables\\n\\n    def __getitem__(self, key):\\n        \\\"\\\"\\\"\\n        Returns the value of a configuration setting.\\n\\n        Args:\\n            key (str): The name of the configuration setting.\\n\\n        Returns:\\n            The value of the configuration setting. \\n        \\\"\\\"\\\"\\n        return self.cfg[key]\\n\\n    def dict(self) -> Dict[str, Any]:\\n        \\\"\\\"\\\"\\n        Returns all configuration settings.\\n\\n        Returns:\\n            A dictionary containing all configuration settings.\\n        \\\"\\\"\\\"\\n        return self.cfg\\n\\n    def update(self, new_config: Dict) -> None:\\n        \\\"\\\"\\\"\\n        Updates configuration settings with the values from another dictionary.\\n\\n        Args:\\n            new_config (Dict): A dictionary containing the configuration settings to be updated.\\n\\n        Returns:\\n            None\\n        \\\"\\\"\\\"\\n        self.cfg.update(new_config)\\n\",\n            \"name_column\": 6\n        },\n        \"__init__\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"__init__\",\n            \"md_content\": \"\",\n            \"code_start_line\": 19,\n            \"code_end_line\": 30,\n            \"parent\": \"ManagerConfig\",\n            \"have_return\": false,\n            \"code_content\": \"    def __init__(self, config_file_path=\\\"./assets/config/manager.yml\\\"):\\n        \\\"\\\"\\\"\\n        Initializes a new instance of the ManagerConfig class.\\n\\n        Args:\\n            config_file_path (str, optional): The path to a yaml file containing configuration settings. \\n            Defaults to \\\"./assets/config.yml\\\".\\n        \\\"\\\"\\\"\\n        self.cfg:Dict = yaml.load(open(config_file_path,\\\"r\\\",encoding=\\\"utf-8\\\").read(), Loader=yaml.FullLoader)\\n        for k in os.environ.keys():\\n            if k in self.cfg:\\n                self.cfg[k] = os.environ[k]  # overwrite the config with environment variables\\n\",\n            \"name_column\": 8\n        },\n        \"__getitem__\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"__getitem__\",\n            \"md_content\": \"\",\n            \"code_start_line\": 32,\n            \"code_end_line\": 42,\n            \"parent\": \"ManagerConfig\",\n            \"have_return\": true,\n            \"code_content\": \"    def __getitem__(self, key):\\n        \\\"\\\"\\\"\\n        Returns the value of a configuration setting.\\n\\n        Args:\\n            key (str): The name of the configuration setting.\\n\\n        Returns:\\n            The value of the configuration setting. \\n        \\\"\\\"\\\"\\n        return self.cfg[key]\\n\",\n            \"name_column\": 8\n        },\n        \"dict\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"dict\",\n            \"md_content\": \"\",\n            \"code_start_line\": 44,\n            \"code_end_line\": 51,\n            \"parent\": \"ManagerConfig\",\n            \"have_return\": true,\n            \"code_content\": \"    def dict(self) -> Dict[str, Any]:\\n        \\\"\\\"\\\"\\n        Returns all configuration settings.\\n\\n        Returns:\\n            A dictionary containing all configuration settings.\\n        \\\"\\\"\\\"\\n        return self.cfg\\n\",\n            \"name_column\": 8\n        },\n        \"update\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"update\",\n            \"md_content\": \"\",\n            \"code_start_line\": 53,\n            \"code_end_line\": 63,\n            \"parent\": \"ManagerConfig\",\n            \"have_return\": false,\n            \"code_content\": \"    def update(self, new_config: Dict) -> None:\\n        \\\"\\\"\\\"\\n        Updates configuration settings with the values from another dictionary.\\n\\n        Args:\\n            new_config (Dict): A dictionary containing the configuration settings to be updated.\\n\\n        Returns:\\n            None\\n        \\\"\\\"\\\"\\n        self.cfg.update(new_config)\\n\",\n            \"name_column\": 8\n        }\n    },\n    \"ToolServer/ToolServerManager/models.py\": {\n        \"ToolServerNode\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"ToolServerNode\",\n            \"md_content\": \"\",\n            \"code_start_line\": 5,\n            \"code_end_line\": 15,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"class ToolServerNode(Document):\\n    \\\"\\\"\\\"\\n    A class that represents a node in the database. \\n    \\\"\\\"\\\"\\n    id: str\\n    short_id: str\\n    status: str\\n    health: str\\n    last_req_time: datetime\\n    ip: str\\n    port: int\\n\",\n            \"name_column\": 6\n        },\n        \"NodeChecker\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"NodeChecker\",\n            \"md_content\": \"\",\n            \"code_start_line\": 17,\n            \"code_end_line\": 20,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"class NodeChecker(Document):\\n    manager_id: str\\n    interval: float\\n    pid: int\",\n            \"name_column\": 6\n        }\n    },\n    \"ToolServer/ToolServerManager/connections.py\": {},\n    \"ToolServer/ToolServerManager/main.py\": {\n        \"startup\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"startup\",\n            \"md_content\": \"\",\n            \"code_start_line\": 19,\n            \"code_end_line\": 53,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"async def startup():\\n    \\\"\\\"\\\"\\n    Event handler triggered on startup of the app. Sets up necessary configurations \\n    like checking and creating table nodes if not exists in databse, creating subprocess \\n    to update node status, and registering path to node. \\n    \\\"\\\"\\\"\\n    \\n    from beanie import init_beanie\\n    await init_beanie(database=db,\\n                      document_models=[ToolServerNode,NodeChecker],)\\n    \\n    # create subprocess to update node status\\n    if CONFIG['builtin_monitor']:\\n        from node_checker import check_nodes_status_loop\\n        \\n        async for checker in NodeChecker.find_all():\\n            if not psutil.pid_exists(checker.pid):\\n                checker.delete()\\n\\n        checker = NodeChecker(\\n            manager_id=MANAGER_ID,\\n            interval=float(CONFIG['node'].get('health_check_interval',1)),\\n            pid=os.getpid()\\n            )\\n        await checker.save()\\n\\n        asyncio.create_task(check_nodes_status_loop())\\n            \\n\\n    # register path to node\\n    for path in CONFIG['redirect_to_node_path']['post']:\\n        app.add_api_route(path, route_to_node, methods=[\\\"POST\\\"])\\n        \\n    for path in CONFIG['redirect_to_node_path']['get']:\\n        app.add_api_route(path, route_to_node, methods=[\\\"GET\\\"])\\n\",\n            \"name_column\": 10\n        },\n        \"shutdown\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"shutdown\",\n            \"md_content\": \"\",\n            \"code_start_line\": 56,\n            \"code_end_line\": 63,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"async def shutdown():\\n    \\\"\\\"\\\"\\n    Event handler on shutdown of the app. Specifically closes the database cursor if \\n    the database type os sqlite3.\\n    \\\"\\\"\\\"\\n    async for checker in NodeChecker.find(NodeChecker.manager_id == MANAGER_ID):\\n        await checker.delete()\\n    db.client.close()\\n\",\n            \"name_column\": 10\n        },\n        \"alive\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"alive\",\n            \"md_content\": \"\",\n            \"code_start_line\": 66,\n            \"code_end_line\": 73,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"async def alive():\\n    \\\"\\\"\\\"\\n    Endpoint to check if the service is running.\\n\\n    Returns:\\n        str: \\\"alive\\\"\\n    \\\"\\\"\\\"\\n    return \\\"alive\\\"\\n\",\n            \"name_column\": 10\n        },\n        \"wait_for_node_startup\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"wait_for_node_startup\",\n            \"md_content\": \"\",\n            \"code_start_line\": 75,\n            \"code_end_line\": 106,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"async def wait_for_node_startup(node_id:str):\\n    \\\"\\\"\\\"\\n    Wait for the startup of node with id node_id. It probes the node status every seconds until \\n    creation_wait_seconds reached.\\n    \\n    Args:\\n        node_id (str): The unique identifier of the node whose startup is to be waited for.\\n\\n    Returns:\\n        bool: True if node has started successfully, False if time out occured before node startup.\\n    \\n    Raises:\\n        HTTPException: If node is not found in the databse.\\n    \\\"\\\"\\\"\\n    MAX_PROBE_TIMES = CONFIG['node']['creation_wait_seconds']\\n    probe_times = 0\\n    while probe_times < MAX_PROBE_TIMES:\\n        node = await ToolServerNode.find_one(ToolServerNode.id == node_id)\\n            \\n        if node is None:\\n            raise HTTPException(status_code=503, detail=\\\"Failed to detect node status! Node not found in db!\\\")\\n        \\n        if CONFIG['node']['health_check']:\\n            if node.health == 'healthy':\\n                return True\\n        else:\\n            if node.status == \\\"running\\\":\\n                return True\\n            \\n        probe_times += 1\\n        await asyncio.sleep(1)\\n    return False\\n\",\n            \"name_column\": 10\n        },\n        \"read_cookie_info\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"read_cookie_info\",\n            \"md_content\": \"\",\n            \"code_start_line\": 109,\n            \"code_end_line\": 150,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"async def read_cookie_info():\\n    \\\"\\\"\\\"\\n    Fetch server version and node info, create docker container and set the response cookies \\n    with the key \\\"node_id\\\" and value as the id of the created container. Also, adds the created \\n    node's details to the databse and waits for the node to startup.\\n\\n    Returns:\\n        JSONResponse: A response object with status, headers and cookies set accordingly.\\n\\n    Raises:\\n        HTTPException: If node creation timeout occurs.\\n    \\\"\\\"\\\"\\n    # append server version info\\n    content = {\\\"message\\\": \\\"add cookie\\\",\\\"version\\\":CONFIG['version']}\\n    response = JSONResponse(content=content)\\n    response.headers[\\\"Server\\\"] = \\\"ToolServerManager/\\\" + CONFIG['version']\\n    \\n    # create a docker container\\n    container = docker_client.containers.run(\\n        device_requests=[docker.types.DeviceRequest(**req) for req in CONFIG['node']['device_requests']] if CONFIG['node']['device_requests'] else None,\\n        **(CONFIG['node']['creation_kwargs']),)\\n    logger.info(\\\"Node created: \\\" + container.id)\\n    response.set_cookie(key=\\\"node_id\\\", value=container.id)\\n    container.reload()\\n    \\n    node = ToolServerNode(\\n        id=container.id,\\n        short_id=container.short_id,\\n        status=container.attrs[\\\"State\\\"][\\\"Status\\\"],\\n        ip=container.attrs[\\\"NetworkSettings\\\"][\\\"Networks\\\"][CONFIG['node']['creation_kwargs']['network']][\\\"IPAddress\\\"],\\n        port=CONFIG['node'].get('port',31942),\\n        last_req_time=datetime.datetime.utcnow(),\\n        health=container.attrs['State']['Health']['Status'] if CONFIG['node']['health_check'] else None\\n    )\\n    await node.insert()\\n\\n    # probe node status every seconds until creation_wait_seconds reached\\n    if await wait_for_node_startup(container.id):\\n        return response\\n    else:\\n        logger.warning(\\\"Node status detection timeout: \\\" + container.id)\\n        raise HTTPException(status_code=503, detail=\\\"Node creation timeout!\\\")\\n\",\n            \"name_column\": 10\n        },\n        \"reconnect_session\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"reconnect_session\",\n            \"md_content\": \"\",\n            \"code_start_line\": 153,\n            \"code_end_line\": 179,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"async def reconnect_session(node_id:str = Cookie(None)):\\n    \\\"\\\"\\\"\\n    Reconnect session of a node. Fetches node info and restarts the node if it exists.\\n\\n    Args:\\n        node_id (str, optional): The unique identifier of the node. Defaults to Cookie(None).\\n\\n    Returns:\\n        str: Success message if node restarts successfully.\\n    \\n    Raises:\\n        HTTPException: If node restart timeout occurs.\\n    \\\"\\\"\\\"\\n    node = await ToolServerNode.find_one(ToolServerNode.id == node_id)\\n    if node is None:\\n        return \\\"invalid node_id: \\\" + str(node_id)\\n    # restart node\\n    container = docker_client.containers.get(node_id)\\n    if container is not None:\\n        container.restart()\\n        logger.info(\\\"Node restarted: \\\" + node_id)\\n    \\n    if await wait_for_node_startup(node_id):\\n        return \\\"Reconnect session: \\\" + str(node_id)\\n    else:\\n        logger.warning(\\\"Node restart timeout: \\\" + node_id)\\n        raise HTTPException(status_code=503, detail=\\\"Node restart timeout!\\\")\\n\",\n            \"name_column\": 10\n        },\n        \"close_session\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"close_session\",\n            \"md_content\": \"\",\n            \"code_start_line\": 182,\n            \"code_end_line\": 200,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"async def close_session(node_id:str = Cookie(None)):\\n    \\\"\\\"\\\"\\n    Close session of a node. Fetches node info and stops the node if it exists and is not already exited.\\n\\n    Args:\\n        node_id (str, optional): The unique identifier of the node. Defaults to Cookie(None).\\n\\n    Returns:\\n        str: Success message if node stops successfully.\\n    \\\"\\\"\\\"\\n    node = await ToolServerNode.find_one(ToolServerNode.id == node_id)\\n    if node is None:\\n        return \\\"invalid node_id: \\\" + str(node_id)\\n    # stop node\\n    container = docker_client.containers.get(node_id)\\n    if container is not None and container.attrs[\\\"State\\\"][\\\"Status\\\"] != \\\"exit\\\":\\n        container.stop()\\n        logger.info(\\\"Node stopped: \\\" + node_id)\\n    return \\\"Close session: \\\" + str(node_id)\\n\",\n            \"name_column\": 10\n        },\n        \"release_session\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"release_session\",\n            \"md_content\": \"\",\n            \"code_start_line\": 203,\n            \"code_end_line\": 226,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"async def release_session(node_id:str = Cookie(None)):\\n    \\\"\\\"\\\"\\n    Release session of a node. Fetches node info and kills the node if it exists and is not already exited. \\n    Also, removes the node.\\n\\n    Args:\\n        node_id (str, optional): The unique identifier of the node. Defaults to Cookie(None).\\n\\n    Returns:\\n        str: Success message if node is successfully killed and removed.\\n    \\\"\\\"\\\"\\n    node = await ToolServerNode.find_one(ToolServerNode.id == node_id)\\n    if node is None:\\n        return \\\"invalid node_id: \\\" + str(node_id)\\n    \\n    # delete node in docker\\n    container = docker_client.containers.get(node_id)\\n    if container is not None:\\n        if container.attrs[\\\"State\\\"][\\\"Status\\\"] != \\\"exited\\\":\\n            container.kill()\\n            logger.info(\\\"Node killed: \\\" + node_id)\\n        container.remove()\\n        logger.info(\\\"Node deleted: \\\" + node_id)\\n    return \\\"Release session: \\\" + str(node_id)\\n\",\n            \"name_column\": 10\n        },\n        \"route_to_node\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"route_to_node\",\n            \"md_content\": \"\",\n            \"code_start_line\": 228,\n            \"code_end_line\": 269,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"async def route_to_node(requset:Request,*,node_id:str = Cookie(None)):\\n    \\\"\\\"\\\"\\n    Routes a request to a specific node. Fetches the node info, checks if it is valid and running. Updates latest \\n    request time in the database and then sends a post request to the node.\\n    \\n    Args:\\n        request (Request): The request object containing all request information.\\n\\n    Returns:\\n        Response: The response object containing all response information received from the node.\\n\\n    Raises:\\n        HTTPException: If node_id is not valid or if the node is not running or not responding.\\n    \\\"\\\"\\\"\\n    # logger.info(\\\"accept node_id:\\\",node_id)\\n    node = await ToolServerNode.find_one(ToolServerNode.id == node_id)\\n    if node is None:\\n        raise HTTPException(status_code=403,detail=\\\"invalid node_id: \\\" + str(node_id)) \\n    \\n    if node.status != \\\"running\\\":\\n        raise HTTPException(status_code=503,detail=\\\"node is not running: \\\" + str(node_id)) \\n\\n    # update latest_req_time in db\\n    node.last_req_time = datetime.datetime.utcnow()\\n    await node.replace()\\n        \\n    #post request to node\\n    method = requset.method\\n    headers = dict(requset.headers)\\n    body = await requset.body()\\n    url = \\\"http://\\\" + node.ip +\\\":\\\"+str(node.port) + requset.url.path\\n    logger.info(\\\"Request to node: \\\" + url)\\n    \\n    async with httpx.AsyncClient(timeout=None) as client:\\n        try:\\n            response = await client.request(method,url,headers=headers,data=body)\\n        except httpx.RequestError:\\n            traceback.print_exc()\\n            raise HTTPException(status_code=503, detail=\\\"node is not responding\\\")\\n    logger.info('Response from node: ' + str(response.status_code))\\n    res = Response(content=response.content, status_code=response.status_code, headers=response.headers)\\n    return res\\n\",\n            \"name_column\": 10\n        }\n    },\n    \"ToolServer/ToolServerManager/node_checker.py\": {\n        \"check_nodes_status\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"check_nodes_status\",\n            \"md_content\": \"\",\n            \"code_start_line\": 11,\n            \"code_end_line\": 54,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"async def check_nodes_status():\\n    \\\"\\\"\\\"\\n    Check the status of all existing nodes from the selected database 'sqlite3' or 'mongodb'.\\n    If a node doesn't exist in Docker, it will be deleted from the database. \\n\\n    Raises:\\n        docker.errors.NotFound: Raised when a Node is not found in Docker\\n        docker.errors.APIError: Raised when it fails to get Node info from Docker\\n    \\\"\\\"\\\"\\n    # Check if each node exists in Docker\\n    async for node in ToolServerNode.find_all():\\n        container = None\\n        try:\\n            container = docker_client.containers.get(node.id)\\n        except docker.errors.NotFound:\\n            # Delete from db if not found in Docker\\n            await node.delete()\\n            logger.info(\\\"Node deleted from db: \\\" + node.id + '(not in docker)')\\n            continue\\n        except docker.errors.APIError:\\n            logger.warning(\\\"Failed to get node info from docker: \\\" + node['node_id'])\\n            continue\\n\\n        if container is not None:\\n            # Update the node state in db\\n            node_status = container.attrs[\\\"State\\\"][\\\"Status\\\"]\\n \\n            if node_status != node.status:\\n                logger.info(f\\\"Node {node.short_id} status updated: \\\" + node.status + \\\" -> \\\" + node_status)\\n            node.status = node_status\\n                \\n            if CONFIG['node']['health_check']:\\n                health = container.attrs['State']['Health']['Status']\\n                if health != node.health:\\n                    logger.info(f\\\"Node {node.short_id} health updated: \\\" + node.health + \\\" -> \\\" + health)\\n                node.health = health\\n                \\n            await node.replace()\\n\\n            # Check if node is running\\n            if node_status == \\\"running\\\":\\n                if datetime.datetime.utcnow() - node.last_req_time >= datetime.timedelta(minutes=CONFIG['node']['idling_close_minutes']):\\n                    container.stop()\\n                    logger.info(\\\"Stopping node: \\\" + node.id + \\\" due to idling time used up\\\")\\n\",\n            \"name_column\": 10\n        },\n        \"check_nodes_status_loop\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"check_nodes_status_loop\",\n            \"md_content\": \"\",\n            \"code_start_line\": 57,\n            \"code_end_line\": 68,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"async def check_nodes_status_loop():\\n    \\\"\\\"\\\"\\n    An infinite loop that checks the status of the nodes and waits 1 second before each iteration.\\n    \\\"\\\"\\\"\\n    logger.info(\\\"Nodes status checker started.\\\")\\n    while True:\\n        try:\\n            await check_nodes_status()\\n        except:\\n            import traceback\\n            traceback.print_exc()\\n        await asyncio.sleep(CONFIG['node'].get('health_check_interval',1))\\n\",\n            \"name_column\": 10\n        }\n    },\n    \"ToolServer/ToolServerNode/config.py\": {\n        \"NodeConfig\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"NodeConfig\",\n            \"md_content\": \"\",\n            \"code_start_line\": 6,\n            \"code_end_line\": 71,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"class NodeConfig:\\n    \\\"\\\"\\\"\\n    A class used to load and manage the configurations defined in a specified configuration file and the environment variables.\\n\\n    Methods\\n    -------\\n    __getitem__(self, key):\\n        Fetches a configuration value for a given key.\\n    dict():\\n        Returns the entire configuration dictionary.\\n    update(new_config: Dict):\\n        Updates the configuration dictionary with new configurations.\\n    \\\"\\\"\\\"\\n    def __init__(self,\\n                 config_file_path=\\\"./assets/config/node.yml\\\",):\\n        \\\"\\\"\\\"\\n        The constructor for NodeConfig class that loads the configuration details.\\n\\n        Args:\\n          config_file_path (str, optional): The path to the configuration file. Defaults to \\\"assets/config.yml\\\".\\n\\n        Raises:\\n          FileNotFoundError: If specified configuration file path could not be located.\\n          yaml.YAMLError: If there are syntax errors in the provided yaml configuration file.\\n        \\\"\\\"\\\"\\n        self.cfg:Dict = yaml.load(open(config_file_path, \\\"r\\\", encoding=\\\"utf-8\\\").read(), Loader=yaml.FullLoader)\\n        \\n        for k in os.environ.keys():\\n            if k in self.cfg:\\n                self.cfg[k] = os.environ[k] # overwrite the config with environment variables\\n\\n    def __getitem__(self, key):\\n        \\\"\\\"\\\"\\n        Fetches a configuration value for a given key.\\n\\n        Args:\\n          key (str): The configuration key to fetch value for.\\n        \\n        Returns:\\n          Any: The value of the requested configuration key.\\n        \\n        Raises:\\n          KeyError: If the given key is not found in the configuration.\\n        \\\"\\\"\\\"\\n        return self.cfg[key]\\n    \\n    def dict(self)-> Dict[str, Any]:\\n        \\\"\\\"\\\"\\n        Returns the entire configuration dictionary.\\n        \\n        Returns:\\n          Dict[str, Any]: The entire configuration dictionary.\\n        \\\"\\\"\\\"\\n        return self.cfg\\n\\n    def update(self, new_config: Dict)-> None:\\n        \\\"\\\"\\\"\\n        Updates the configuration dictionary with new configurations.\\n\\n        Args:\\n          new_config (Dict): The new configurations dictionary to update the existing configurations.\\n\\n        Returns:\\n          None\\n        \\\"\\\"\\\"\\n        self.cfg.update(new_config)\\n\",\n            \"name_column\": 6\n        },\n        \"__init__\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"__init__\",\n            \"md_content\": \"\",\n            \"code_start_line\": 19,\n            \"code_end_line\": 35,\n            \"parent\": \"NodeConfig\",\n            \"have_return\": false,\n            \"code_content\": \"    def __init__(self,\\n                 config_file_path=\\\"./assets/config/node.yml\\\",):\\n        \\\"\\\"\\\"\\n        The constructor for NodeConfig class that loads the configuration details.\\n\\n        Args:\\n          config_file_path (str, optional): The path to the configuration file. Defaults to \\\"assets/config.yml\\\".\\n\\n        Raises:\\n          FileNotFoundError: If specified configuration file path could not be located.\\n          yaml.YAMLError: If there are syntax errors in the provided yaml configuration file.\\n        \\\"\\\"\\\"\\n        self.cfg:Dict = yaml.load(open(config_file_path, \\\"r\\\", encoding=\\\"utf-8\\\").read(), Loader=yaml.FullLoader)\\n        \\n        for k in os.environ.keys():\\n            if k in self.cfg:\\n                self.cfg[k] = os.environ[k] # overwrite the config with environment variables\\n\",\n            \"name_column\": 8\n        },\n        \"__getitem__\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"__getitem__\",\n            \"md_content\": \"\",\n            \"code_start_line\": 37,\n            \"code_end_line\": 50,\n            \"parent\": \"NodeConfig\",\n            \"have_return\": true,\n            \"code_content\": \"    def __getitem__(self, key):\\n        \\\"\\\"\\\"\\n        Fetches a configuration value for a given key.\\n\\n        Args:\\n          key (str): The configuration key to fetch value for.\\n        \\n        Returns:\\n          Any: The value of the requested configuration key.\\n        \\n        Raises:\\n          KeyError: If the given key is not found in the configuration.\\n        \\\"\\\"\\\"\\n        return self.cfg[key]\\n\",\n            \"name_column\": 8\n        },\n        \"dict\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"dict\",\n            \"md_content\": \"\",\n            \"code_start_line\": 52,\n            \"code_end_line\": 59,\n            \"parent\": \"NodeConfig\",\n            \"have_return\": true,\n            \"code_content\": \"    def dict(self)-> Dict[str, Any]:\\n        \\\"\\\"\\\"\\n        Returns the entire configuration dictionary.\\n        \\n        Returns:\\n          Dict[str, Any]: The entire configuration dictionary.\\n        \\\"\\\"\\\"\\n        return self.cfg\\n\",\n            \"name_column\": 8\n        },\n        \"update\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"update\",\n            \"md_content\": \"\",\n            \"code_start_line\": 61,\n            \"code_end_line\": 71,\n            \"parent\": \"NodeConfig\",\n            \"have_return\": false,\n            \"code_content\": \"    def update(self, new_config: Dict)-> None:\\n        \\\"\\\"\\\"\\n        Updates the configuration dictionary with new configurations.\\n\\n        Args:\\n          new_config (Dict): The new configurations dictionary to update the existing configurations.\\n\\n        Returns:\\n          None\\n        \\\"\\\"\\\"\\n        self.cfg.update(new_config)\\n\",\n            \"name_column\": 8\n        }\n    },\n    \"ToolServer/ToolServerNode/main.py\": {\n        \"startup\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"startup\",\n            \"md_content\": \"\",\n            \"code_start_line\": 23,\n            \"code_end_line\": 33,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"def startup():\\n    \\\"\\\"\\\"\\n    Startup function to initialize the required services and variables for the application.\\n    \\\"\\\"\\\"\\n    try:\\n        # start docker service\\n        os.system('service docker start')\\n    except:\\n        pass\\n    app.tool_register = ToolRegister()\\n    app.doc_embeddings, app.id2tool = build_tool_embeddings(app.tool_register.get_all_tools_dict(include_invisible=True))\\n\",\n            \"name_column\": 4\n        },\n        \"root\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"root\",\n            \"md_content\": \"\",\n            \"code_start_line\": 37,\n            \"code_end_line\": 44,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"async def root():\\n    \\\"\\\"\\\"\\n    Root function that returns a message Hello World.\\n    \\n    Returns:\\n        dict: A dictionary containing a welcoming message.\\n    \\\"\\\"\\\"\\n    return {\\\"message\\\": \\\"Hello World\\\"}\\n\",\n            \"name_column\": 10\n        },\n        \"upload_file\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"upload_file\",\n            \"md_content\": \"\",\n            \"code_start_line\": 47,\n            \"code_end_line\": 62,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"async def upload_file(file:UploadFile):\\n    \\\"\\\"\\\"\\n    This function allows the user to upload a file to the work directory defined in configuration file.\\n\\n    Args:\\n        file (fastapi.UploadFile): The file to be uploaded.\\n    \\n    Returns:\\n        dict: A message denoting successful upload of the file.\\n    \\\"\\\"\\\"\\n    upload_file =  file.file.read()\\n    file_name = file.filename\\n    work_directory = CONFIG['filesystem']['work_directory']\\n    with open(os.path.join(work_directory,file_name),'wb') as f:\\n        f.write(upload_file)\\n    return {\\\"message\\\": \\\"Upload Success!\\\"}\\n\",\n            \"name_column\": 10\n        },\n        \"download_file\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"download_file\",\n            \"md_content\": \"\",\n            \"code_start_line\": 65,\n            \"code_end_line\": 83,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"async def download_file(file_path:str=Body(...),file_type:str=Body(default='text/plain')):\\n    \\\"\\\"\\\"\\n    This function downloads a file from the work directory.\\n\\n    Args:\\n        file_path (str): The path of the file to be downloaded.\\n        file_type (str, optional): Type of the file. Defaults to 'text/plain'.\\n    \\n    Returns:\\n        starlette.responses.FileResponse: File response containing the requested file for user to download.\\n    \\\"\\\"\\\"\\n    work_directory = CONFIG['filesystem']['work_directory']\\n    if file_path.startswith(os.path.basename(work_directory)):\\n        file_path = file_path[len(os.path.basename(work_directory))+1:]\\n    response = FileResponse(\\n        path=os.path.join(work_directory,file_path),\\n        filename=os.path.basename(file_path),\\n        )\\n    return response\\n\",\n            \"name_column\": 10\n        },\n        \"download_workspace\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"download_workspace\",\n            \"md_content\": \"\",\n            \"code_start_line\": 86,\n            \"code_end_line\": 105,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"async def download_workspace():\\n    \\\"\\\"\\\"\\n    This function downloads the workspace which is a directory consisting of all the uploaded files. \\n    \\n    Returns:\\n        starlette.responses.FileResponse: File response containing the workspace for the user to download. \\n    \\\"\\\"\\\"\\n    work_directory = CONFIG['filesystem']['work_directory']\\n    zip = zipfile.ZipFile('/tmp/workspace.zip','w',zipfile.ZIP_DEFLATED)\\n    for path,dirs,files in os.walk(work_directory):\\n        fpath= path.replace(work_directory,'')\\n        for file in files:\\n            zip.write(os.path.join(path,file),os.path.join(fpath,file))\\n    \\n    zip.close()\\n    response = FileResponse(\\n        path=os.path.join(work_directory,'/tmp/workspace.zip'),\\n        filename='workspace.zip',\\n        )\\n    return response\\n\",\n            \"name_column\": 10\n        },\n        \"get_workspace_structure\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"get_workspace_structure\",\n            \"md_content\": \"\",\n            \"code_start_line\": 109,\n            \"code_end_line\": 125,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"async def get_workspace_structure():\\n    \\\"\\\"\\\"\\n    This function generates the structure of the workspace directory.\\n    \\n    Returns:\\n        dict: A dictionary depicting the structure of the workspace directory.\\n    \\\"\\\"\\\"\\n    work_directory = CONFIG['filesystem']['work_directory']\\n    def generate_directory_structure(path):\\n        result = {'name':os.path.basename(path)}\\n        if os.path.isdir(path):\\n            result['type'] = 'directory'\\n            result['children'] = [generate_directory_structure(os.path.join(path,child)) for child in os.listdir(path)]\\n        else:\\n            result['type'] = 'file'\\n        return result\\n    return generate_directory_structure(work_directory)\\n\",\n            \"name_column\": 10\n        },\n        \"get_available_tools\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"get_available_tools\",\n            \"md_content\": \"\",\n            \"code_start_line\": 128,\n            \"code_end_line\": 140,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"async def get_available_tools():\\n    \\\"\\\"\\\"\\n    This function returns the available tools and environments registered in the ToolRegister.\\n    \\n    Returns:\\n        dict: A dictionary of available tools, environments and the JSON representation of the tools.\\n    \\\"\\\"\\\"\\n    tool_register:ToolRegister = app.tool_register\\n    return {\\n        \\\"available_envs\\\": tool_register.get_all_envs(),\\n        \\\"available_tools\\\": tool_register.get_all_tools(),\\n        \\\"tools_json\\\": tool_register.get_all_tools_dict(),\\n    }\\n\",\n            \"name_column\": 10\n        },\n        \"retrieving_tools\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"retrieving_tools\",\n            \"md_content\": \"\",\n            \"code_start_line\": 143,\n            \"code_end_line\": 173,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"async def retrieving_tools(question:str=Body(...), top_k:int=Body(default=5)):\\n    \\\"\\\"\\\"\\n    This function retrieves the tool names based on a query question using the ADA retriever.\\n\\n    Args:\\n        question (str): The query question for which tools are to be retrieved.\\n        top_k (int, optional): The number of top similar tools to be retrieved. Defaults to 5.\\n\\n    Returns:\\n        dict: A dictionary with the list of retrieved tools and JSON representations of the tools.\\n\\n    Raises:\\n        HTTPException: If an error occurs during retrieving the tools.\\n    \\\"\\\"\\\"\\n    try:\\n        retrieved_tools = ada_retriever(app.doc_embeddings, app.id2tool, question, top_k)\\n    except Exception as e:\\n        error_report =  traceback.format_exc()\\n        logger.error(error_report)\\n        raise HTTPException(status_code=500, detail=f\\\"Errorhappens when retrieving tools:\\\\n{e}\\\\n\\\\n\\\" + error_report)\\n    \\n    tool_register:ToolRegister = app.tool_register\\n    tools_json = []\\n    for tool_name in retrieved_tools:\\n        if tool_name in tool_register.tools:\\n            tools_json.append(tool_register.get_tool_dict(tool_name))\\n    \\n    return {\\n        \\\"retrieved_tools\\\":retrieved_tools,\\n        \\\"tools_json\\\":tools_json,\\n    }\\n\",\n            \"name_column\": 10\n        },\n        \"get_json_schema_for_tool\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"get_json_schema_for_tool\",\n            \"md_content\": \"\",\n            \"code_start_line\": 177,\n            \"code_end_line\": 199,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"async def get_json_schema_for_tool(tool_names:List[str]=Body(...)):\\n    \\\"\\\"\\\"\\n    This function returns the JSON schema for the given list of tools.\\n\\n    Args:\\n        tool_names (List[str]): List of tool names for which JSON schema is required.\\n\\n    Returns:\\n        dict: JSON schema dictionary for all the available tools and list of error names for missing tools. \\n    \\\"\\\"\\\"\\n    tool_register:ToolRegister = app.tool_register\\n    \\n    error_names = []\\n    tools_json = []\\n    for tool_name in tool_names:\\n        if tool_name not in tool_register.tools:\\n            error_names.append(tool_name)\\n        else:\\n            tools_json.append(tool_register.get_tool_dict(tool_name))\\n    return {\\n        \\\"tools_json\\\": tools_json,\\n        \\\"missing_tools\\\": error_names,\\n    }\\n\",\n            \"name_column\": 10\n        },\n        \"get_json_schema_for_env\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"get_json_schema_for_env\",\n            \"md_content\": \"\",\n            \"code_start_line\": 202,\n            \"code_end_line\": 224,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"async def get_json_schema_for_env(env_names:List[str]=Body(...)):\\n    \\\"\\\"\\\"\\n    This function returns the JSON schema for the given list of tool environments.\\n\\n    Args:\\n        env_names (List[str]): List of environment names for which JSON schema is required.\\n\\n    Returns:\\n        dict: JSON schema dictionary for all the available environments and list of error names for missing environments. \\n    \\\"\\\"\\\"\\n    tool_register:ToolRegister = app.tool_register\\n    \\n    error_names = []\\n    envs_json = []\\n    for env_name in env_names:\\n        if env_name not in tool_register.envs:\\n            error_names.append(env_name)\\n        else:\\n            envs_json.append(tool_register.get_env_dict(env_name))\\n    return {\\n        \\\"envs_json\\\": envs_json,\\n        \\\"missing_envs\\\": error_names,\\n    }\\n\",\n            \"name_column\": 10\n        },\n        \"register_new_tool\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"register_new_tool\",\n            \"md_content\": \"\",\n            \"code_start_line\": 227,\n            \"code_end_line\": 249,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"async def register_new_tool(tool_name:str=Body(...), code:str=Body(...)):\\n    \\\"\\\"\\\"\\n    This function allows the user to register a new tool by providing the tool name and code.\\n\\n    Args:\\n        tool_name (str): The name of the new tool.\\n        code (str): The code for the new tool.\\n\\n    Returns:\\n        dict: A dictionary representing the registered tool.\\n\\n    Raises:\\n        HTTPException: If an error occurs during registering the new tool.\\n    \\\"\\\"\\\"\\n    tool_register:ToolRegister = app.tool_register\\n    try:\\n        tool_dict = tool_register.register_tool(tool_name,code)\\n    except Exception as e:\\n        error_report =  traceback.format_exc()\\n        logger.error(error_report)\\n        raise HTTPException(status_code=406, detail=f\\\"Error happens when registering new tool:\\\\n{e}\\\\n\\\\n\\\" + error_report)\\n    \\n    return tool_dict\\n\",\n            \"name_column\": 10\n        },\n        \"execute_tool\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"execute_tool\",\n            \"md_content\": \"\",\n            \"code_start_line\": 252,\n            \"code_end_line\": 289,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"async def execute_tool(tool_name:str=Body(...), arguments:dict=Body(...), env_name:str=Body(default=None)):\\n    \\\"\\\"\\\"\\n    This function executes a tool with the provided arguments and environment.\\n\\n    Args:\\n        tool_name (str): The name of the tool to be executed.\\n        arguments (dict): The arguments for executing the tool.\\n        env_name (str, optional): The name of the tool environment in which tool is to be executed. Defaults to None.\\n\\n    Returns:\\n        dict: The result of executing the tool is wrapped in a dictionary.\\n\\n    Raises:\\n        HTTPException: If an error occurs during tool execution.\\n    \\\"\\\"\\\"\\n    tool_register:ToolRegister = app.tool_register\\n    \\n    try:\\n        if env_name is not None:\\n            tool = tool_register[env_name,tool_name]\\n        else:\\n            tool = tool_register[tool_name]\\n        result = tool(**arguments)\\n        if isinstance(result,Coroutine):\\n            result = await result\\n        result = wrap_tool_response(result)\\n    except ToolNotFound as e:\\n        raise HTTPException(status_code=404, detail=str(e))\\n    except OutputNotReady as e:\\n        raise HTTPException(status_code=450, detail=e.next_try())\\n    except HTTPException as e:\\n        raise e\\n    except Exception as e:\\n        trace_info = traceback.format_exc()\\n        logger.error(f'Error happens when executing tool {tool_name}! Exception: {e}\\\\n{trace_info}')\\n        raise HTTPException(status_code=500, detail=trace_info)\\n    \\n    return result\\n\",\n            \"name_column\": 10\n        },\n        \"generate_directory_structure\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"generate_directory_structure\",\n            \"md_content\": \"\",\n            \"code_start_line\": 117,\n            \"code_end_line\": 124,\n            \"parent\": \"get_workspace_structure\",\n            \"have_return\": true,\n            \"code_content\": \"    def generate_directory_structure(path):\\n        result = {'name':os.path.basename(path)}\\n        if os.path.isdir(path):\\n            result['type'] = 'directory'\\n            result['children'] = [generate_directory_structure(os.path.join(path,child)) for child in os.listdir(path)]\\n        else:\\n            result['type'] = 'file'\\n        return result\\n\",\n            \"name_column\": 8\n        }\n    },\n    \"ToolServer/ToolServerNode/core/labels.py\": {\n        \"ToolLabels\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"ToolLabels\",\n            \"md_content\": \"\",\n            \"code_start_line\": 5,\n            \"code_end_line\": 70,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"class ToolLabels:\\n    \\\"\\\"\\\"A class representing a tool.\\n\\n    When invoked, this object runs the associated method using parameters defined in the signature.\\n\\n    Attributes:\\n        name (str): The name of the tool.\\n        description (str): Description of the tool.\\n        method (Callable): The function/method that the tool executes.\\n        signature (dict): Argument keys and values needed by the method to execute.\\n        required (list): List of required arguments for the method.\\n        enabled (bool): Flag indicating whether the tool is enabled or not.\\n        disabled_reason (str): Reason for disabling the tool, if applicable.\\n        func_type (str): Type of function for the tool, defaults to 'function'.\\n        visible (bool): Flag indicating whether the tool is visible or not.\\n    \\\"\\\"\\\"\\n\\n    def __init__(\\n        self,\\n        name: str,\\n        description: str,\\n        method: Callable[..., Any],\\n        signature: dict = {},\\n        required: list = [],\\n        enabled: bool = True,\\n        disabled_reason: Optional[str] = None,\\n        func_type: str = 'function',\\n        visible: bool = True,\\n    ):\\n        self.name = name\\n        self.description = description\\n        self.method = method\\n        self.signature = signature\\n        self.required = required\\n        self.enabled = enabled\\n        self.disabled_reason = disabled_reason\\n        self.func_type = func_type\\n        self.visible = visible\\n\\n    def dict(self, name_overwrite: str = '') -> dict:\\n        \\\"\\\"\\\"Returns the tool information as a dictionary.\\n\\n        Args:\\n            name_overwrite (str): Replacement string for tool name, defaults to empty string.\\n\\n        Returns:\\n            dict: Dictionary of tool attributes.\\n        \\\"\\\"\\\"\\n        \\n        return {\\n            \\\"name\\\": self.name if name_overwrite == '' else name_overwrite,\\n            \\\"description\\\": self.description[:1024],\\n            \\\"parameters\\\": {\\n                \\\"type\\\": \\\"object\\\",\\n                \\\"properties\\\": self.signature,\\n                \\\"required\\\": self.required\\n            }\\n        }\\n\\n    def __str__(self) -> str:\\n        \\\"\\\"\\\"Returns the tool information in a formatted string.\\n\\n        Returns:\\n            str: Formatted string containing tool attributes.\\n        \\\"\\\"\\\"\\n        return f\\\"{self.name}: {self.description}, args: {self.signature}\\\"\\n\",\n            \"name_column\": 6\n        },\n        \"EnvLabels\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"EnvLabels\",\n            \"md_content\": \"\",\n            \"code_start_line\": 73,\n            \"code_end_line\": 149,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"class EnvLabels:\\n    \\\"\\\"\\\"A class representing an environment.\\n\\n    Each environment has a set of subtools associated with it. This object manages the collection of tools.\\n\\n    Attributes:\\n        name (str): Name of the environment.\\n        description (str): Description of the environment.\\n        subtools_labels (dict): Collection of tools associated to the environment.\\n        defined_tools (list): List of tool names defined in the environment.\\n        cls (Type): Class that the environment pertains to.\\n        enabled (bool): Flag indicating whether the environment is enabled or not.\\n        disabled_reason (str): Reason for disabling the environment, if applicable.\\n        visible (bool): Flag indicating whether the environment is visible or not.\\n    \\\"\\\"\\\"\\n\\n    def __init__(\\n        self,\\n        name: str,\\n        description: str,\\n        subtools_labels: dict[ToolLabels] = {},\\n        defined_tools:list[str] = [],\\n        cls: Type = None,\\n        enabled: bool = True,\\n        disabled_reason: Optional[str] = None,\\n        visible: bool = True,\\n    ):\\n        self.name = name\\n        self.description = description\\n        self.subtools_labels = subtools_labels\\n        self.defined_tools = defined_tools\\n        self.cls = cls\\n        self.enabled = enabled\\n        self.disabled_reason = disabled_reason\\n        self.visible = visible\\n\\n    def dict(self,\\n             include_invisible=False,\\n             max_show_tools: int = CONFIG['toolregister']['env_max_tools_display']) -> dict:\\n        \\\"\\\"\\\"\\n        Returns the environment's tools as a dictionary.\\n\\n        Args:\\n            include_invisible (bool): If true, includes tools even if they're set as invisible.\\n            max_show_tools (int): Maximum number of tools to display in the output.\\n\\n        Returns:\\n            dict: Dictionary of environment attributes and associated tools.\\n        \\\"\\\"\\\"\\n        \\n        if include_invisible:\\n            tools_name = list(self.subtools_labels.keys())\\n        else:\\n            if CONFIG['toolregister']['parent_tools_visible']:\\n                tools_name = [tool_name for tool_name in self.subtools_labels.keys() if self.subtools_labels[tool_name].visible]\\n            else:\\n                tools_name = self.defined_tools\\n\\n        if max_show_tools != -1 and len(tools_name) > max_show_tools:\\n            # only show first max_show_tools tools\\n            tools_name = tools_name[:max_show_tools]\\n            tools_name.append('...')\\n\\n        return {\\n            \\\"name\\\": self.name,\\n            \\\"description\\\": self.description,\\n            \\\"total_tools\\\": len(self.subtools_labels),\\n            \\\"tools\\\": tools_name,\\n        }\\n\\n    def __str__(self) -> str:\\n        \\\"\\\"\\\"Returns the environment information as a formatted string.\\n\\n        Returns:\\n            str: Formatted string containing environment attributes.\\n        \\\"\\\"\\\"\\n        return f\\\"{self.name}: {self.description}\\\"\",\n            \"name_column\": 6\n        },\n        \"__init__\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"__init__\",\n            \"md_content\": \"\",\n            \"code_start_line\": 89,\n            \"code_end_line\": 107,\n            \"parent\": \"EnvLabels\",\n            \"have_return\": false,\n            \"code_content\": \"    def __init__(\\n        self,\\n        name: str,\\n        description: str,\\n        subtools_labels: dict[ToolLabels] = {},\\n        defined_tools:list[str] = [],\\n        cls: Type = None,\\n        enabled: bool = True,\\n        disabled_reason: Optional[str] = None,\\n        visible: bool = True,\\n    ):\\n        self.name = name\\n        self.description = description\\n        self.subtools_labels = subtools_labels\\n        self.defined_tools = defined_tools\\n        self.cls = cls\\n        self.enabled = enabled\\n        self.disabled_reason = disabled_reason\\n        self.visible = visible\\n\",\n            \"name_column\": 8\n        },\n        \"dict\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"dict\",\n            \"md_content\": \"\",\n            \"code_start_line\": 109,\n            \"code_end_line\": 141,\n            \"parent\": \"EnvLabels\",\n            \"have_return\": true,\n            \"code_content\": \"    def dict(self,\\n             include_invisible=False,\\n             max_show_tools: int = CONFIG['toolregister']['env_max_tools_display']) -> dict:\\n        \\\"\\\"\\\"\\n        Returns the environment's tools as a dictionary.\\n\\n        Args:\\n            include_invisible (bool): If true, includes tools even if they're set as invisible.\\n            max_show_tools (int): Maximum number of tools to display in the output.\\n\\n        Returns:\\n            dict: Dictionary of environment attributes and associated tools.\\n        \\\"\\\"\\\"\\n        \\n        if include_invisible:\\n            tools_name = list(self.subtools_labels.keys())\\n        else:\\n            if CONFIG['toolregister']['parent_tools_visible']:\\n                tools_name = [tool_name for tool_name in self.subtools_labels.keys() if self.subtools_labels[tool_name].visible]\\n            else:\\n                tools_name = self.defined_tools\\n\\n        if max_show_tools != -1 and len(tools_name) > max_show_tools:\\n            # only show first max_show_tools tools\\n            tools_name = tools_name[:max_show_tools]\\n            tools_name.append('...')\\n\\n        return {\\n            \\\"name\\\": self.name,\\n            \\\"description\\\": self.description,\\n            \\\"total_tools\\\": len(self.subtools_labels),\\n            \\\"tools\\\": tools_name,\\n        }\\n\",\n            \"name_column\": 8\n        },\n        \"__str__\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"__str__\",\n            \"md_content\": \"\",\n            \"code_start_line\": 143,\n            \"code_end_line\": 149,\n            \"parent\": \"EnvLabels\",\n            \"have_return\": true,\n            \"code_content\": \"    def __str__(self) -> str:\\n        \\\"\\\"\\\"Returns the environment information as a formatted string.\\n\\n        Returns:\\n            str: Formatted string containing environment attributes.\\n        \\\"\\\"\\\"\\n        return f\\\"{self.name}: {self.description}\\\"\",\n            \"name_column\": 8\n        }\n    },\n    \"ToolServer/ToolServerNode/core/__init__.py\": {},\n    \"ToolServer/ToolServerNode/core/exceptions.py\": {\n        \"OutputNotReady\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"OutputNotReady\",\n            \"md_content\": \"\",\n            \"code_start_line\": 4,\n            \"code_end_line\": 20,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"class OutputNotReady(Exception):\\n    \\\"\\\"\\\"The output is not ready.\\n        \\\"\\\"\\\"\\n    def __init__(self, *args: object,type:str='retry',next_calling:str=None,arguments:dict={}) -> None:\\n        super().__init__(*args)\\n        self.type = type\\n        self.next_calling = next_calling\\n        self.arguments = arguments\\n        \\n    def next_try(self):\\n        \\\"\\\"\\\"Prepare the next try by returning a dictionary\\n           containing type, next calling event and arguments.\\\"\\\"\\\"\\n        return {\\n            \\\"type\\\":self.type,\\n            \\\"next_calling\\\":self.next_calling,\\n            \\\"arguments\\\":self.arguments\\n        }\\n\",\n            \"name_column\": 6\n        },\n        \"ToolNotFound\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"ToolNotFound\",\n            \"md_content\": \"\",\n            \"code_start_line\": 22,\n            \"code_end_line\": 43,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"class ToolNotFound(Exception):\\n    \\\"\\\"\\\"Custom exception class that is raised when the tool is not found.\\n    \\n    Args:\\n        *args (object): Variable length argument list.\\n        tool_name (str): The name of the tool.\\n\\n    Attributes:\\n        tool_name (str): The name of the tool.\\n    \\\"\\\"\\\"\\n    def __init__(self, *args: object,tool_name:str=None) -> None:\\n        super().__init__(*args)\\n        self.tool_name = tool_name\\n        \\n    def __str__(self) -> str:\\n        \\\"\\\"\\\"Returns the formatted exception error message with the name of the tool\\\"\\\"\\\"\\n        s = super().__str__()\\n        if s != '':\\n            s += f'\\\\nThe tool {self.tool_name} is not found!'\\n        else:\\n            s = f'The tool {self.tool_name} is not found!'\\n        return s \\n\",\n            \"name_column\": 6\n        },\n        \"EnvNotFound\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"EnvNotFound\",\n            \"md_content\": \"\",\n            \"code_start_line\": 46,\n            \"code_end_line\": 69,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"class EnvNotFound(Exception):\\n    \\\"\\\"\\\"Custom exception class that is raised when the environment variable is not found.\\n    \\n    Args:\\n        *args (object): Variable length argument list.\\n        env_name (str): The name of the environment variable.\\n\\n    Attributes:\\n        addition_info (tuple): Additional information.\\n        env_name (str): The name of the environment variable.\\n    \\\"\\\"\\\"\\n    def __init__(self, *args: object,env_name:str=None) -> None:\\n        super().__init__(*args)\\n        self.addition_info = args\\n        self.env_name =  env_name\\n        \\n    def __str__(self)->str:\\n        \\\"\\\"\\\"Returns the formatted exception error message with the name of the environment variable\\\"\\\"\\\"\\n        s = super().__str__()\\n        if s != '':\\n            s += f'\\\\nThe env {self.env_name} is not found!'\\n        else:\\n            s = f'The tool {self.env_name} is not found!'\\n        return s \\n\",\n            \"name_column\": 6\n        },\n        \"ToolRegisterError\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"ToolRegisterError\",\n            \"md_content\": \"\",\n            \"code_start_line\": 71,\n            \"code_end_line\": 94,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"class ToolRegisterError(Exception):\\n    \\\"\\\"\\\"Custom exception class that is raised when registering a tool encounters an error.\\n    \\n    Args:\\n        *args (object): Variable length argument list.\\n        tool_name (str): The name of the tool.\\n\\n    Attributes:\\n        addition_info (tuple): Additional information.\\n        tool_name (str): The name of the tool.\\n    \\\"\\\"\\\"\\n    def __init__(self, *args: object,tool_name:str=None) -> None:\\n        super().__init__(*args)\\n        self.addition_info = args\\n        self.tool_name = tool_name\\n        \\n    def __str__(self)->str:\\n        \\\"\\\"\\\"Returns the formatted exception error message with the name of the tool\\\"\\\"\\\"\\n        s = super().__str__()\\n        if s != '':\\n            s += f'\\\\nError happens when registering tool {self.tool_name}!'\\n        else:\\n            s = f'Error happens when registering tool {self.tool_name}!'\\n        return s \\n\",\n            \"name_column\": 6\n        },\n        \"remove_color\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"remove_color\",\n            \"md_content\": \"\",\n            \"code_start_line\": 97,\n            \"code_end_line\": 107,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"def remove_color(text):\\n    \\\"\\\"\\\"Removes ANSI escape sequences i.e. colors, from the text.\\n\\n    Args:\\n        text (str): The text from which color needs to be removed.\\n\\n    Returns:\\n        str: The filtered text with no color.\\n    \\\"\\\"\\\"\\n\\n    return ansi_escape.sub('', text)\\n\",\n            \"name_column\": 4\n        },\n        \"ToolExecutionError\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"ToolExecutionError\",\n            \"md_content\": \"\",\n            \"code_start_line\": 109,\n            \"code_end_line\": 118,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"class ToolExecutionError(HTTPException):\\n    \\\"\\\"\\\"Custom exception class that is raised when the tool execution encounters an error.\\n\\n    Args:\\n        error_msg (str): The error message during tool execution.\\n    \\\"\\\"\\\"\\n    def __init__(self,error_msg:str):\\n        if isinstance(error_msg,str):\\n            error_msg = remove_color(error_msg)\\n        super().__init__(500,error_msg)\",\n            \"name_column\": 6\n        },\n        \"__init__\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"__init__\",\n            \"md_content\": \"\",\n            \"code_start_line\": 115,\n            \"code_end_line\": 118,\n            \"parent\": \"ToolExecutionError\",\n            \"have_return\": false,\n            \"code_content\": \"    def __init__(self,error_msg:str):\\n        if isinstance(error_msg,str):\\n            error_msg = remove_color(error_msg)\\n        super().__init__(500,error_msg)\",\n            \"name_column\": 8\n        },\n        \"next_try\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"next_try\",\n            \"md_content\": \"\",\n            \"code_start_line\": 13,\n            \"code_end_line\": 20,\n            \"parent\": \"OutputNotReady\",\n            \"have_return\": true,\n            \"code_content\": \"    def next_try(self):\\n        \\\"\\\"\\\"Prepare the next try by returning a dictionary\\n           containing type, next calling event and arguments.\\\"\\\"\\\"\\n        return {\\n            \\\"type\\\":self.type,\\n            \\\"next_calling\\\":self.next_calling,\\n            \\\"arguments\\\":self.arguments\\n        }\\n\",\n            \"name_column\": 8\n        },\n        \"__str__\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"__str__\",\n            \"md_content\": \"\",\n            \"code_start_line\": 87,\n            \"code_end_line\": 94,\n            \"parent\": \"ToolRegisterError\",\n            \"have_return\": true,\n            \"code_content\": \"    def __str__(self)->str:\\n        \\\"\\\"\\\"Returns the formatted exception error message with the name of the tool\\\"\\\"\\\"\\n        s = super().__str__()\\n        if s != '':\\n            s += f'\\\\nError happens when registering tool {self.tool_name}!'\\n        else:\\n            s = f'Error happens when registering tool {self.tool_name}!'\\n        return s \\n\",\n            \"name_column\": 8\n        }\n    },\n    \"ToolServer/ToolServerNode/core/base.py\": {\n        \"BaseEnv\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"BaseEnv\",\n            \"md_content\": \"\",\n            \"code_start_line\": 5,\n            \"code_end_line\": 76,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"class BaseEnv:\\n    \\\"\\\"\\\"\\n    BaseEnv class. It helps to handle functions and function names of the classes and subclasses.\\n    This class provides methods to get all functions, defined functions and their names.\\n    It also ensures the configuration updates if necessary.\\n\\n    Attributes:\\n        config(Dict[str, Any], optional): A dictionary containing the configuration. Defaults to an empty dictionary.\\n    \\\"\\\"\\\"\\n    def __init__(self, config: Dict[str, Any] = {}):\\n        \\\"\\\"\\\"Initialize BaseEnv class with specified or default configuration.\\n\\n        Args:\\n            config (Dict[str, Any], optional): A dictionary containing the configuration. Defaults to an empty dictionary.\\n\\n        Notes:\\n            The configuration is deep copied to avoid modifications to the original object.\\n        \\\"\\\"\\\"\\n        self.config = deepcopy(CONFIG)\\n        if isinstance(config, dict):\\n            self.config.update(config)\\n        \\n    @classmethod\\n    def __get_all_func_name__(cls) -> list[str]:\\n        \\\"\\\"\\\"Get all the function names of the class, excluding methods starting with '_' character.\\n\\n        Returns:\\n            list[str]: A list that contains function names.\\n        \\\"\\\"\\\"\\n        return [name for name in dir(cls) \\n        if not str(name).startswith('_') and callable(getattr(cls, name))]\\n\\n\\n    @classmethod\\n    def __get_all_func__(cls) -> list[Callable]:\\n        \\\"\\\"\\\"Get all functions of the class, excluding methods starting with '__' characters.\\n\\n        Returns:\\n            list[Callable]: A list that contains functions.\\n        \\\"\\\"\\\"\\n        func_names = cls.__get_all_func_name__()\\n        return list(map(getattr, [cls]*len(func_names), func_names))\\n\\n    @classmethod\\n    def __get_defined_func__(cls) -> list[Callable]:\\n        \\\"\\\"\\\"Get all the functions of the subclass, excluding methods starting with '_' character.\\n\\n        Returns:\\n            list[Callable]: A list that contains defined functions of the subclass.\\n\\n        Notes:\\n            This method removes the parent class's methods from the functions list to \\n            provide only the functions that are newly defined in the subclass.\\n        \\\"\\\"\\\"\\n        functions = cls.__get_all_func__()\\n        for parent_cls in cls.__bases__:\\n            if not issubclass(parent_cls, BaseEnv):\\n                continue\\n            parent_functions = parent_cls.__get_all_func__()\\n            functions = list(filter(lambda x: x not in parent_functions, functions))\\n    \\n        return functions\\n\\n    @classmethod\\n    def __get_defined_func_name__(cls) -> list[str]:\\n        \\\"\\\"\\\"Get all the function names of the subclass, excluding methods starting with '_' character.\\n\\n        Returns:\\n            list[str]: A list that contains function names of the subclass.\\n        \\\"\\\"\\\"\\n        functions = cls.__get_defined_func__()\\n        return list(map(lambda x: x.__name__, functions))\",\n            \"name_column\": 6\n        },\n        \"__init__\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"__init__\",\n            \"md_content\": \"\",\n            \"code_start_line\": 14,\n            \"code_end_line\": 25,\n            \"parent\": \"BaseEnv\",\n            \"have_return\": false,\n            \"code_content\": \"    def __init__(self, config: Dict[str, Any] = {}):\\n        \\\"\\\"\\\"Initialize BaseEnv class with specified or default configuration.\\n\\n        Args:\\n            config (Dict[str, Any], optional): A dictionary containing the configuration. Defaults to an empty dictionary.\\n\\n        Notes:\\n            The configuration is deep copied to avoid modifications to the original object.\\n        \\\"\\\"\\\"\\n        self.config = deepcopy(CONFIG)\\n        if isinstance(config, dict):\\n            self.config.update(config)\\n\",\n            \"name_column\": 8\n        },\n        \"__get_all_func_name__\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"__get_all_func_name__\",\n            \"md_content\": \"\",\n            \"code_start_line\": 28,\n            \"code_end_line\": 35,\n            \"parent\": \"BaseEnv\",\n            \"have_return\": true,\n            \"code_content\": \"    def __get_all_func_name__(cls) -> list[str]:\\n        \\\"\\\"\\\"Get all the function names of the class, excluding methods starting with '_' character.\\n\\n        Returns:\\n            list[str]: A list that contains function names.\\n        \\\"\\\"\\\"\\n        return [name for name in dir(cls) \\n        if not str(name).startswith('_') and callable(getattr(cls, name))]\\n\",\n            \"name_column\": 8\n        },\n        \"__get_all_func__\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"__get_all_func__\",\n            \"md_content\": \"\",\n            \"code_start_line\": 39,\n            \"code_end_line\": 46,\n            \"parent\": \"BaseEnv\",\n            \"have_return\": true,\n            \"code_content\": \"    def __get_all_func__(cls) -> list[Callable]:\\n        \\\"\\\"\\\"Get all functions of the class, excluding methods starting with '__' characters.\\n\\n        Returns:\\n            list[Callable]: A list that contains functions.\\n        \\\"\\\"\\\"\\n        func_names = cls.__get_all_func_name__()\\n        return list(map(getattr, [cls]*len(func_names), func_names))\\n\",\n            \"name_column\": 8\n        },\n        \"__get_defined_func__\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"__get_defined_func__\",\n            \"md_content\": \"\",\n            \"code_start_line\": 49,\n            \"code_end_line\": 66,\n            \"parent\": \"BaseEnv\",\n            \"have_return\": true,\n            \"code_content\": \"    def __get_defined_func__(cls) -> list[Callable]:\\n        \\\"\\\"\\\"Get all the functions of the subclass, excluding methods starting with '_' character.\\n\\n        Returns:\\n            list[Callable]: A list that contains defined functions of the subclass.\\n\\n        Notes:\\n            This method removes the parent class's methods from the functions list to \\n            provide only the functions that are newly defined in the subclass.\\n        \\\"\\\"\\\"\\n        functions = cls.__get_all_func__()\\n        for parent_cls in cls.__bases__:\\n            if not issubclass(parent_cls, BaseEnv):\\n                continue\\n            parent_functions = parent_cls.__get_all_func__()\\n            functions = list(filter(lambda x: x not in parent_functions, functions))\\n    \\n        return functions\\n\",\n            \"name_column\": 8\n        },\n        \"__get_defined_func_name__\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"__get_defined_func_name__\",\n            \"md_content\": \"\",\n            \"code_start_line\": 69,\n            \"code_end_line\": 76,\n            \"parent\": \"BaseEnv\",\n            \"have_return\": true,\n            \"code_content\": \"    def __get_defined_func_name__(cls) -> list[str]:\\n        \\\"\\\"\\\"Get all the function names of the subclass, excluding methods starting with '_' character.\\n\\n        Returns:\\n            list[str]: A list that contains function names of the subclass.\\n        \\\"\\\"\\\"\\n        functions = cls.__get_defined_func__()\\n        return list(map(lambda x: x.__name__, functions))\",\n            \"name_column\": 8\n        }\n    },\n    \"ToolServer/ToolServerNode/core/tools/shell.py\": {\n        \"async_read_pipe\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"async_read_pipe\",\n            \"md_content\": \"\",\n            \"code_start_line\": 10,\n            \"code_end_line\": 16,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"async def async_read_pipe(pipe: asyncio.StreamReader):\\n    ret = b''\\n    while True:\\n        try:\\n            ret += await asyncio.wait_for(pipe.readline(), timeout=0.01)\\n        except asyncio.TimeoutError:\\n            return ret\\n\",\n            \"name_column\": 10\n        },\n        \"read_exec_proc_display\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"read_exec_proc_display\",\n            \"md_content\": \"\",\n            \"code_start_line\": 17,\n            \"code_end_line\": 23,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"async def read_exec_proc_display(exec_proc: asyncio.subprocess.Process):\\n    display = \\\"\\\"\\n    for pipe, name in zip([exec_proc.stderr,exec_proc.stdout], ['stderr','stdout']):\\n        ret = await async_read_pipe(pipe)\\n        if ret != b'':\\n            display += f'\\\\n{name}:\\\\n'+ ret.decode()\\n    return display\\n\",\n            \"name_column\": 10\n        },\n        \"shell_command_executor\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"shell_command_executor\",\n            \"md_content\": \"\",\n            \"code_start_line\": 26,\n            \"code_end_line\": 109,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"async def shell_command_executor(command: str = '', run_async: bool = False, shell_id: int = None, kill:bool = False):\\n    \\\"\\\"\\\"The shell tool that execute shell command in root privilege, return the output and error. \\n    You can use this tool to install packages, download files, run programs, etc.\\n    Set run_async=True to run the command in a new thread and return instantly if your command is time costly like install packages, host services. \\n    Example:\\n    ```\\n    In: shell_command_executor(command='echo \\\"hello world\\\"')\\n    Out: \\\"hello world\\\"\\n    In: shell_command_executor(command='sleep 10', run_async=True)\\n    Out: {'shell_id': 0} # You can use this id to read the output and error later.\\n    In: shell_command_executor(shell_id=0, kill=True)\\n    Out: \\\"\\\" # The shell 0 will be killed.\\n    ```\\n\\n    :param string? command: The shell command to be executed, must avoid command requiring additional user input. Default is empty string.\\n    :param boolean? run_async: Whether to run the command asynchronously, default is False. If True, call this tool again with shell_id to get the final output and error. \\n    :param integer? shell_id: The id of shell to execute command, default is None, which means running in a new shell. Change this to execute command in the same shell.\\n    :param boolean? kill: If True, kill the shell which runs the command after execution. Default is False. Don't use any other kill command!\\n    \\\"\\\"\\\"\\n    if shell_id is not None:\\n        exec_proc = ALL_SHELLS.get(shell_id, None)\\n        if exec_proc is None:\\n            raise ToolExecutionError(\\n                {'Error': 'Shell not found or has been closed.'})\\n        if exec_proc.returncode is not None:\\n            print(exec_proc.returncode)\\n            ALL_SHELLS.pop(shell_id)\\n            raise ToolExecutionError({'Error': 'Shell has been closed.'})\\n\\n    else:\\n        exec_proc = await asyncio.create_subprocess_shell(\\n            'bash',\\n            stderr=asyncio.subprocess.PIPE,\\n            stdout=asyncio.subprocess.PIPE,\\n            stdin=asyncio.subprocess.PIPE,\\n            cwd=CONFIG['filesystem']['work_directory'])\\n        shell_id = max(ALL_SHELLS.keys(), default=-1) + 1\\n        ALL_SHELLS[shell_id] = exec_proc\\n\\n    if not run_async:\\n        try:\\n            ret = await asyncio.wait_for(exec_proc.communicate(command.encode()), timeout=CONFIG['shell']['timeout'])\\n        except asyncio.TimeoutError:\\n            des = \\\"Timeout while executing command.\\\"\\n            if kill:\\n                des += \\\" Shell has been killed.\\\"\\n                exec_proc.kill()\\n            display = await read_exec_proc_display(exec_proc)\\n            if display != \\\"\\\":\\n                des += \\\" But get some response:\\\" + display\\n                \\n            raise ToolExecutionError(des)\\n            \\n        ALL_SHELLS.pop(shell_id)\\n\\n        result = {\\n            'ReturnCode': exec_proc.returncode,\\n            'display': ''\\n        }\\n        if ret[1] != b'':\\n            result['display'] += f'\\\\nstderr:\\\\n'+ret[1].decode()\\n        if ret[0] != b'':\\n            result['display'] = f'\\\\nstdout:\\\\n'+ret[0].decode()\\n            \\n        if result['ReturnCode'] != 0 and not kill:\\n            raise ToolExecutionError(result)\\n        return result\\n    else:\\n        if command[-1] != '\\\\n':\\n            command += '\\\\n'\\n        exec_proc.stdin.write(command.encode())\\n        await exec_proc.stdin.drain()\\n        await asyncio.sleep(5)\\n        result = {'shell_id': shell_id , 'display':await read_exec_proc_display(exec_proc)}\\n        if result['display'] == \\\"\\\":\\n            await asyncio.sleep(30)\\n            result['display'] = await read_exec_proc_display(exec_proc)\\n        if kill:\\n            exec_proc.kill()\\n            ALL_SHELLS.pop(shell_id)\\n            result['status'] = 'shell thread has been killed'\\n        else:\\n            result['status'] = 'shell still running, no return code'\\n        return result\\n\",\n            \"name_column\": 10\n        }\n    },\n    \"ToolServer/ToolServerNode/core/tools/__init__.py\": {},\n    \"ToolServer/ToolServerNode/core/register/wrapper.py\": {\n        \"generate_tool_labels\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"generate_tool_labels\",\n            \"md_content\": \"\",\n            \"code_start_line\": 14,\n            \"code_end_line\": 83,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"def generate_tool_labels(\\n    name: str = None,\\n    enabled: bool = True,\\n    disabled_reason: Optional[str] = None,\\n    func: Callable[..., Any] = None,\\n    visible:bool = True,\\n)->Union[ToolLabels,None]:\\n    \\\"\\\"\\\"\\n    Generate and return tool labels for the provided function. If the tool is not enabled,\\n    then a debug log message is printed and None is returned.\\n\\n    Args:\\n        name (str, optional): The name of the tool. If it's not specified, the function's name is used.\\n        enabled (bool, optional): Determines if the tool is enabled or not. Defaults to True.\\n        disabled_reason (Optional[str], optional): The reason why the tool is disabled. Defaults to None.\\n        func (Callable[..., Any], optional): The function for which the tool labels are generated. Defaults to None.\\n        visible(bool, optional): The visibility status of the tool. Defaults to True.\\n\\n    Returns:\\n        Union[ToolLabels,None]: A ToolLabels object containing tool information or None if tool is not enabled. \\n    \\\"\\\"\\\"\\n\\n    if not enabled:\\n        if disabled_reason is not None:\\n            logger.debug(f\\\"tool '{func.__name__}' is disabled: {disabled_reason}\\\")\\n        return None\\n\\n    # check if the method have full annotations\\n    auto_signature = {}\\n    func_desc =  docstring_parser.parse(func.__doc__)\\n    required = []\\n    for arg in func_desc.params:\\n        auto_signature[arg.arg_name] = {\\n            'type':arg.type_name,           # TODO support self defined type\\n            'description':arg.description,\\n        }\\n        if arg.default is not None:\\n            auto_signature[arg.arg_name]['default'] = arg.default\\n        if not arg.is_optional:\\n            required.append(arg.arg_name)\\n\\n    # for arg in inspect.getargs(func.__code__).args:\\n    #     if arg in auto_signature:\\n    #         continue\\n    #     if arg in ['self','cls','config','return']:\\n    #         continue\\n    #     # if arg not in func.__annotations__:\\n    #     #     raise SyntaxError(f'Signature is None and the annotation of varable {arg} in func {func.__name__} is not found!')\\n    #     auto_signature[arg] = {\\n    #         'type':'string',\\n    #         'description':''                # TODO try to generate description\\n    #     }\\n\\n    tool_name = func.__name__ if name is None else name\\n    description = ''\\n    if func_desc.short_description is not None:\\n        description = func_desc.short_description\\n    if func_desc.long_description is not None:\\n        description += '\\\\n' + func_desc.long_description\\n\\n    return ToolLabels(\\n        name=tool_name,\\n        description=description,\\n        method=func,\\n        signature=auto_signature,\\n        required=required,\\n        enabled=enabled,\\n        disabled_reason=disabled_reason,\\n        visible=visible,\\n    )\\n\",\n            \"name_column\": 4\n        },\n        \"toolwrapper\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"toolwrapper\",\n            \"md_content\": \"\",\n            \"code_start_line\": 85,\n            \"code_end_line\": 167,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"def toolwrapper(\\n    name: str = None,\\n    enabled: bool = True,\\n    disabled_reason: Optional[str] = None,\\n    parent_tools_visible: bool = CONFIG['toolregister']['parent_tools_visible'],\\n    visible:bool = True,\\n)->Union[Type,Callable[..., Any]]:\\n    \\\"\\\"\\\"The tool decorator for class, used to create tool objects from ordinary class.\\\"\\\"\\\"\\n\\n    def decorator(obj:object)->Union[Type,Callable[..., Any]]:\\n        if inspect.isclass(obj):\\n            cls = obj\\n            cls_name = name if name is not None else cls.__name__\\n            if not issubclass(cls,BaseEnv):\\n                raise Exception(f'The class {cls} is not a subclass of BaseEnv!')\\n            \\n            description = cls.__doc__ if cls.__doc__ is not None else ''\\n            if not visible:\\n                description = 'Note: All tools of this env are invisible during all tools display, please check this env\\\\'s defination to show all tools.\\\\n' + description\\n            \\n            \\n            subtools_labels = {}\\n            if BaseEnv not in cls.__bases__:\\n                direct_parents = [parent.__name__ for parent in cls.__bases__]\\n                if not parent_tools_visible:\\n                    description = f'Note: This env is subclass of {direct_parents}, and all tools of parent envs are inherited and not visible. You can try call parent tools or check this env\\\\'s defination to show them.\\\\n' + description\\n                else:\\n                    description = f'Note: This env is subclass of {direct_parents}, and all tools of parent envs are inherited.\\\\n' + description\\n                for parent in cls.__bases__:\\n                    if hasattr(parent,'env_labels') and isinstance(parent.env_labels,EnvLabels):\\n                        subtools_labels.update(parent.env_labels.subtools_labels)\\n            \\n            cls_func_names = cls.__get_defined_func_name__()            \\n            for func_name in cls_func_names:\\n                origin_func = getattr(cls,func_name)\\n                tool_labels = generate_tool_labels(\\n                    name=func_name,\\n                    enabled=enabled,\\n                    disabled_reason=disabled_reason,\\n                    func=origin_func,\\n                    visible=visible)\\n                if tool_labels is None:\\n                    continue\\n                \\n                # label classmethod, staticmethod and instance method\\n                #check if the function is a classmethod\\n                if inspect.ismethod(origin_func) and not inspect.isfunction(origin_func):\\n                    tool_labels.func_type = 'classmethod'\\n                # check if the function is a staticmethod\\n                if 'self' in inspect.getargs(origin_func.__code__).args:\\n                    tool_labels.func_type = 'instancemethod'\\n                else:   \\n                    tool_labels.func_type = 'staticmethod'\\n                \\n                # tool_labels.dependent_cls = cls\\n                origin_func.tool_labels = tool_labels\\n                subtools_labels[tool_labels.name] = tool_labels\\n            \\n\\n            cls.env_labels = EnvLabels(\\n                name=cls_name,\\n                description=description,\\n                subtools_labels=subtools_labels,\\n                defined_tools=cls_func_names,\\n                cls=cls,\\n                enabled=enabled,\\n                disabled_reason=disabled_reason,\\n                visible=visible\\n            )\\n            return cls\\n        elif inspect.isfunction(obj):\\n            func = obj\\n            tool_labels = generate_tool_labels(\\n                name=name,\\n                enabled=enabled, \\n                disabled_reason=disabled_reason,\\n                func=func,\\n                visible=visible)\\n            func.tool_labels = tool_labels\\n            return func\\n        else:\\n            raise NotImplementedError(f'Object with type {type(obj)} not recognized!')\\n    return decorator\\n\",\n            \"name_column\": 4\n        },\n        \"decorator\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"decorator\",\n            \"md_content\": \"\",\n            \"code_start_line\": 94,\n            \"code_end_line\": 166,\n            \"parent\": \"toolwrapper\",\n            \"have_return\": true,\n            \"code_content\": \"    def decorator(obj:object)->Union[Type,Callable[..., Any]]:\\n        if inspect.isclass(obj):\\n            cls = obj\\n            cls_name = name if name is not None else cls.__name__\\n            if not issubclass(cls,BaseEnv):\\n                raise Exception(f'The class {cls} is not a subclass of BaseEnv!')\\n            \\n            description = cls.__doc__ if cls.__doc__ is not None else ''\\n            if not visible:\\n                description = 'Note: All tools of this env are invisible during all tools display, please check this env\\\\'s defination to show all tools.\\\\n' + description\\n            \\n            \\n            subtools_labels = {}\\n            if BaseEnv not in cls.__bases__:\\n                direct_parents = [parent.__name__ for parent in cls.__bases__]\\n                if not parent_tools_visible:\\n                    description = f'Note: This env is subclass of {direct_parents}, and all tools of parent envs are inherited and not visible. You can try call parent tools or check this env\\\\'s defination to show them.\\\\n' + description\\n                else:\\n                    description = f'Note: This env is subclass of {direct_parents}, and all tools of parent envs are inherited.\\\\n' + description\\n                for parent in cls.__bases__:\\n                    if hasattr(parent,'env_labels') and isinstance(parent.env_labels,EnvLabels):\\n                        subtools_labels.update(parent.env_labels.subtools_labels)\\n            \\n            cls_func_names = cls.__get_defined_func_name__()            \\n            for func_name in cls_func_names:\\n                origin_func = getattr(cls,func_name)\\n                tool_labels = generate_tool_labels(\\n                    name=func_name,\\n                    enabled=enabled,\\n                    disabled_reason=disabled_reason,\\n                    func=origin_func,\\n                    visible=visible)\\n                if tool_labels is None:\\n                    continue\\n                \\n                # label classmethod, staticmethod and instance method\\n                #check if the function is a classmethod\\n                if inspect.ismethod(origin_func) and not inspect.isfunction(origin_func):\\n                    tool_labels.func_type = 'classmethod'\\n                # check if the function is a staticmethod\\n                if 'self' in inspect.getargs(origin_func.__code__).args:\\n                    tool_labels.func_type = 'instancemethod'\\n                else:   \\n                    tool_labels.func_type = 'staticmethod'\\n                \\n                # tool_labels.dependent_cls = cls\\n                origin_func.tool_labels = tool_labels\\n                subtools_labels[tool_labels.name] = tool_labels\\n            \\n\\n            cls.env_labels = EnvLabels(\\n                name=cls_name,\\n                description=description,\\n                subtools_labels=subtools_labels,\\n                defined_tools=cls_func_names,\\n                cls=cls,\\n                enabled=enabled,\\n                disabled_reason=disabled_reason,\\n                visible=visible\\n            )\\n            return cls\\n        elif inspect.isfunction(obj):\\n            func = obj\\n            tool_labels = generate_tool_labels(\\n                name=name,\\n                enabled=enabled, \\n                disabled_reason=disabled_reason,\\n                func=func,\\n                visible=visible)\\n            func.tool_labels = tool_labels\\n            return func\\n        else:\\n            raise NotImplementedError(f'Object with type {type(obj)} not recognized!')\\n\",\n            \"name_column\": 8\n        }\n    },\n    \"ToolServer/ToolServerNode/core/register/register.py\": {\n        \"get_func_name\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"get_func_name\",\n            \"md_content\": \"\",\n            \"code_start_line\": 16,\n            \"code_end_line\": 26,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"def get_func_name(func:Callable,env:BaseEnv=None)->str:\\n    if env is None or not hasattr(env,'env_labels'):\\n        if hasattr(func,'tool_labels'):\\n            return func.tool_labels.name\\n        else:\\n            return func.__name__\\n    else:\\n        if hasattr(func,'tool_labels'):\\n            return env.env_labels.name + '_' + func.tool_labels.name\\n        else:\\n            return env.env_labels.name + '_' + func.__name__\\n\",\n            \"name_column\": 4\n        },\n        \"ToolRegister\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"ToolRegister\",\n            \"md_content\": \"\",\n            \"code_start_line\": 29,\n            \"code_end_line\": 204,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"class ToolRegister:\\n    def __init__(self,\\n                 config:dict = {},\\n                 ):\\n        self.config = deepcopy(CONFIG)\\n        for k in config:\\n            self.config[k] = config[k]\\n        self.toolregister_cfg = self.config['toolregister']\\n        self.tool_creation_doc = open(self.toolregister_cfg['tool_creation_doc']).read()\\n        self.tool_creation_context = {}\\n        self.tool_creation_context_load_code = []\\n        for k in self.toolregister_cfg['tool_creation_context']:\\n            # load\\n            load_code = f\\\"from {self.toolregister_cfg['tool_creation_context'][k]} import {k}\\\"\\n            exec(load_code)\\n            self.tool_creation_context[k] = eval(k)\\n            self.tool_creation_context_load_code.append(load_code)\\n        # load modules\\n        self.tools = {}\\n        self.envs = {}\\n        for module_name in ['core.envs','core.tools']:            \\n            sub_modules = importlib.import_module(module_name).__all__\\n            for module in sub_modules:\\n                for attr_name in dir(module):\\n                    attr = getattr(module,attr_name)\\n                    self.check_and_register(attr)\\n            \\n        # load extensions\\n        if 'enabled_extensions' in self.config.cfg and isinstance(self.config['enabled_extensions'],list):\\n            for extension in self.config['enabled_extensions']:\\n                self.dynamic_extension_load(extension)\\n        \\n        logger.info(f'Loaded {len(self.tools)} tools and {len(self.envs)} envs!')\\n        # print(self.tools)\\n    def check_and_register(self,attr:Any):\\n        if hasattr(attr,'tool_labels') and isinstance(attr.tool_labels,ToolLabels):\\n            tool_name = get_func_name(attr)\\n            if tool_name in self.tools:\\n                logger.warning(f'Tool {tool_name} is replicated! The new one will be replaced!')\\n                return None\\n            \\n            self.tools[tool_name] = attr\\n            logger.info(f'Register tool {tool_name}!')\\n            return attr\\n            \\n        if hasattr(attr,'env_labels') and isinstance(attr.env_labels,EnvLabels):\\n            # attr is a cls, need get instance\\n            if attr.env_labels.name in self.envs:\\n                return\\n            if not issubclass(attr,BaseEnv):\\n                raise Exception(f'The env {attr.env_labels.name} is not a subclass of BaseEnv!')\\n            env = attr(config=self.config.dict())\\n            env_tools = {}\\n            \\n            if self.toolregister_cfg['parent_tools_visible']:\\n                func_names = env.__get_all_func_name__()\\n            else:\\n                func_names = env.__get_defined_func_name__()\\n            \\n            for func_name in func_names:\\n                func = getattr(env,func_name)\\n                if hasattr(func,'tool_labels'):\\n                    env_tools[get_func_name(func,env)] = func\\n            \\n            env_keys = set(env_tools.keys())\\n            tools_keys = set(self.tools.keys())\\n            if env_keys & tools_keys:\\n                logger.warning(f'Env {env.env_labels.name} has tools with same name as other tools! The new one will be ignored!')\\n                for tool_name in env_keys & tools_keys:\\n                    env_tools.pop(tool_name)\\n\\n            self.tools.update(env_tools)\\n            \\n            self.envs[attr.env_labels.name] = env\\n            logger.info(f'Register env {env.env_labels.name} with {len(env_tools)} tools!')\\n            \\n            return env\\n            \\n        return None\\n\\n    def register_tool(self,tool_name:str,code:str)->str:\\n        try:\\n            exec(code,self.tool_creation_context)\\n        except Exception as e:\\n            error_report =  traceback.format_exc()\\n            logger.error(error_report)\\n            raise ToolRegisterError(f'Failed to execute new tool code: {e}\\\\n\\\\n' + error_report,tool_name=tool_name)\\n        \\n        try:\\n            tool_func = eval(tool_name,self.tool_creation_context)\\n        except:\\n            raise ToolRegisterError(f'Failed to find tool, please verify the tool_name!',tool_name=tool_name)\\n        \\n        tool_func = self.check_and_register(tool_func)\\n        if tool_func is None:\\n            raise ToolRegisterError(f'Tool: {tool_name} has no labels or replicated! Ensuring wrap the tool with `@toolwrapper()`.',tool_name=tool_name)\\n        \\n        # write the tool into file under extensions/tools\\n        code = '\\\\n'.join(self.tool_creation_context_load_code) +'\\\\n# Tool Creation Context Load Ended.\\\\n'+ code\\n        tool_file = f'extensions/tools/{tool_name}.py'\\n        with open(tool_file,'w') as f:\\n            f.write(code)\\n        \\n        return self.get_tool_dict(tool_name)\\n    \\n    def dynamic_extension_load(self,extension:str)->bool:\\n        '''Load extension dynamically.\\n        \\n        :param string extension: The load path of the extension.\\n        :return boolean: True if success, False if failed.\\n        '''\\n        try:\\n            module = importlib.import_module(extension)\\n            for attr_name in dir(module):\\n                attr = getattr(module,attr_name)\\n                self.check_and_register(attr)\\n        except Exception as e:\\n            logger.error(f'Failed to load extension {extension}! Exception: {e}')\\n            # logger.error(traceback.format_exc())\\n            return False\\n        \\n        return True\\n        \\n    def get_tool_dict(self,tool_name:str)->dict:\\n        return self[tool_name].tool_labels.dict(name_overwrite=tool_name)\\n    \\n    def get_env_dict(self,env_name:str)->dict:\\n        if env_name not in self.envs:\\n            raise EnvNotFound(env_name=env_name)\\n        return self.envs[env_name].env_labels.dict(include_invisible=True,max_show_tools = -1)\\n    \\n    def get_all_envs(self)->list[dict]:\\n        return [self.envs[env_name].env_labels.dict()  for env_name in self.envs]\\n    \\n    def get_all_tools(self,include_invisible=False)->list[str]:\\n        if include_invisible:\\n            return [tool_name  for tool_name in self.tools]\\n        else:\\n            return [tool_name  for tool_name in self.tools if self.tools[tool_name].tool_labels.visible]\\n    \\n    def get_all_tools_dict(self,include_invisible=False)->list[dict]:\\n        return [self.tools[tool_name].tool_labels.dict(name_overwrite=tool_name)  for tool_name in self.get_all_tools(include_invisible)]\\n    \\n    def __getitem__(self, key)->Callable[..., Any]:\\n        # two stage index, first find env, then find tool\\n        if isinstance(key,str):\\n            if key not in self.tools:\\n                # check if the tool is a env subtool which not visible\\n                try:\\n                    tool_name = key.split('_')\\n                    env_name = tool_name[0]\\n                    tool_name = '_'.join(tool_name[1:])\\n                    return self[env_name,tool_name]\\n                except:\\n                    if self.dynamic_extension_load(f'extensions.tools.{key}') and key in self.tools:\\n                        # try to find tool in unloaded extensions\\n                        return self.tools[key]\\n                    else:\\n                        raise ToolNotFound(tool_name=key)\\n            return self.tools[key]\\n        elif isinstance(key,tuple):\\n            if len(key) != 2:\\n                raise NotImplementedError(f'Key {key} is not valid!')\\n            env_name,tool_name = key\\n            if env_name not in self.envs:\\n                # try to find env in unloaded extensions\\n                if self.dynamic_extension_load(f'extensions.envs.{env_name}') and env_name in self.envs:\\n                    env = self.envs[env_name]\\n                raise EnvNotFound(env_name=env_name)\\n            env = self.envs[env_name]\\n            if tool_name not in env.env_labels.subtools_labels:\\n                raise ToolNotFound(tool_name=env_name+'_'+tool_name)\\n            else:\\n                func = getattr(env,env.env_labels.subtools_labels[tool_name].method.__name__)\\n                return func\\n        raise NotImplementedError(f'Key {key} is not valid!')\",\n            \"name_column\": 6\n        },\n        \"__init__\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"__init__\",\n            \"md_content\": \"\",\n            \"code_start_line\": 30,\n            \"code_end_line\": 61,\n            \"parent\": \"ToolRegister\",\n            \"have_return\": false,\n            \"code_content\": \"    def __init__(self,\\n                 config:dict = {},\\n                 ):\\n        self.config = deepcopy(CONFIG)\\n        for k in config:\\n            self.config[k] = config[k]\\n        self.toolregister_cfg = self.config['toolregister']\\n        self.tool_creation_doc = open(self.toolregister_cfg['tool_creation_doc']).read()\\n        self.tool_creation_context = {}\\n        self.tool_creation_context_load_code = []\\n        for k in self.toolregister_cfg['tool_creation_context']:\\n            # load\\n            load_code = f\\\"from {self.toolregister_cfg['tool_creation_context'][k]} import {k}\\\"\\n            exec(load_code)\\n            self.tool_creation_context[k] = eval(k)\\n            self.tool_creation_context_load_code.append(load_code)\\n        # load modules\\n        self.tools = {}\\n        self.envs = {}\\n        for module_name in ['core.envs','core.tools']:            \\n            sub_modules = importlib.import_module(module_name).__all__\\n            for module in sub_modules:\\n                for attr_name in dir(module):\\n                    attr = getattr(module,attr_name)\\n                    self.check_and_register(attr)\\n            \\n        # load extensions\\n        if 'enabled_extensions' in self.config.cfg and isinstance(self.config['enabled_extensions'],list):\\n            for extension in self.config['enabled_extensions']:\\n                self.dynamic_extension_load(extension)\\n        \\n        logger.info(f'Loaded {len(self.tools)} tools and {len(self.envs)} envs!')\\n\",\n            \"name_column\": 8\n        },\n        \"check_and_register\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"check_and_register\",\n            \"md_content\": \"\",\n            \"code_start_line\": 63,\n            \"code_end_line\": 107,\n            \"parent\": \"ToolRegister\",\n            \"have_return\": true,\n            \"code_content\": \"    def check_and_register(self,attr:Any):\\n        if hasattr(attr,'tool_labels') and isinstance(attr.tool_labels,ToolLabels):\\n            tool_name = get_func_name(attr)\\n            if tool_name in self.tools:\\n                logger.warning(f'Tool {tool_name} is replicated! The new one will be replaced!')\\n                return None\\n            \\n            self.tools[tool_name] = attr\\n            logger.info(f'Register tool {tool_name}!')\\n            return attr\\n            \\n        if hasattr(attr,'env_labels') and isinstance(attr.env_labels,EnvLabels):\\n            # attr is a cls, need get instance\\n            if attr.env_labels.name in self.envs:\\n                return\\n            if not issubclass(attr,BaseEnv):\\n                raise Exception(f'The env {attr.env_labels.name} is not a subclass of BaseEnv!')\\n            env = attr(config=self.config.dict())\\n            env_tools = {}\\n            \\n            if self.toolregister_cfg['parent_tools_visible']:\\n                func_names = env.__get_all_func_name__()\\n            else:\\n                func_names = env.__get_defined_func_name__()\\n            \\n            for func_name in func_names:\\n                func = getattr(env,func_name)\\n                if hasattr(func,'tool_labels'):\\n                    env_tools[get_func_name(func,env)] = func\\n            \\n            env_keys = set(env_tools.keys())\\n            tools_keys = set(self.tools.keys())\\n            if env_keys & tools_keys:\\n                logger.warning(f'Env {env.env_labels.name} has tools with same name as other tools! The new one will be ignored!')\\n                for tool_name in env_keys & tools_keys:\\n                    env_tools.pop(tool_name)\\n\\n            self.tools.update(env_tools)\\n            \\n            self.envs[attr.env_labels.name] = env\\n            logger.info(f'Register env {env.env_labels.name} with {len(env_tools)} tools!')\\n            \\n            return env\\n            \\n        return None\\n\",\n            \"name_column\": 8\n        },\n        \"register_tool\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"register_tool\",\n            \"md_content\": \"\",\n            \"code_start_line\": 109,\n            \"code_end_line\": 132,\n            \"parent\": \"ToolRegister\",\n            \"have_return\": true,\n            \"code_content\": \"    def register_tool(self,tool_name:str,code:str)->str:\\n        try:\\n            exec(code,self.tool_creation_context)\\n        except Exception as e:\\n            error_report =  traceback.format_exc()\\n            logger.error(error_report)\\n            raise ToolRegisterError(f'Failed to execute new tool code: {e}\\\\n\\\\n' + error_report,tool_name=tool_name)\\n        \\n        try:\\n            tool_func = eval(tool_name,self.tool_creation_context)\\n        except:\\n            raise ToolRegisterError(f'Failed to find tool, please verify the tool_name!',tool_name=tool_name)\\n        \\n        tool_func = self.check_and_register(tool_func)\\n        if tool_func is None:\\n            raise ToolRegisterError(f'Tool: {tool_name} has no labels or replicated! Ensuring wrap the tool with `@toolwrapper()`.',tool_name=tool_name)\\n        \\n        # write the tool into file under extensions/tools\\n        code = '\\\\n'.join(self.tool_creation_context_load_code) +'\\\\n# Tool Creation Context Load Ended.\\\\n'+ code\\n        tool_file = f'extensions/tools/{tool_name}.py'\\n        with open(tool_file,'w') as f:\\n            f.write(code)\\n        \\n        return self.get_tool_dict(tool_name)\\n\",\n            \"name_column\": 8\n        },\n        \"dynamic_extension_load\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"dynamic_extension_load\",\n            \"md_content\": \"\",\n            \"code_start_line\": 134,\n            \"code_end_line\": 150,\n            \"parent\": \"ToolRegister\",\n            \"have_return\": true,\n            \"code_content\": \"    def dynamic_extension_load(self,extension:str)->bool:\\n        '''Load extension dynamically.\\n        \\n        :param string extension: The load path of the extension.\\n        :return boolean: True if success, False if failed.\\n        '''\\n        try:\\n            module = importlib.import_module(extension)\\n            for attr_name in dir(module):\\n                attr = getattr(module,attr_name)\\n                self.check_and_register(attr)\\n        except Exception as e:\\n            logger.error(f'Failed to load extension {extension}! Exception: {e}')\\n            # logger.error(traceback.format_exc())\\n            return False\\n        \\n        return True\\n\",\n            \"name_column\": 8\n        },\n        \"get_tool_dict\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"get_tool_dict\",\n            \"md_content\": \"\",\n            \"code_start_line\": 152,\n            \"code_end_line\": 153,\n            \"parent\": \"ToolRegister\",\n            \"have_return\": true,\n            \"code_content\": \"    def get_tool_dict(self,tool_name:str)->dict:\\n        return self[tool_name].tool_labels.dict(name_overwrite=tool_name)\\n\",\n            \"name_column\": 8\n        },\n        \"get_env_dict\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"get_env_dict\",\n            \"md_content\": \"\",\n            \"code_start_line\": 155,\n            \"code_end_line\": 158,\n            \"parent\": \"ToolRegister\",\n            \"have_return\": true,\n            \"code_content\": \"    def get_env_dict(self,env_name:str)->dict:\\n        if env_name not in self.envs:\\n            raise EnvNotFound(env_name=env_name)\\n        return self.envs[env_name].env_labels.dict(include_invisible=True,max_show_tools = -1)\\n\",\n            \"name_column\": 8\n        },\n        \"get_all_envs\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"get_all_envs\",\n            \"md_content\": \"\",\n            \"code_start_line\": 160,\n            \"code_end_line\": 161,\n            \"parent\": \"ToolRegister\",\n            \"have_return\": true,\n            \"code_content\": \"    def get_all_envs(self)->list[dict]:\\n        return [self.envs[env_name].env_labels.dict()  for env_name in self.envs]\\n\",\n            \"name_column\": 8\n        },\n        \"get_all_tools\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"get_all_tools\",\n            \"md_content\": \"\",\n            \"code_start_line\": 163,\n            \"code_end_line\": 167,\n            \"parent\": \"ToolRegister\",\n            \"have_return\": true,\n            \"code_content\": \"    def get_all_tools(self,include_invisible=False)->list[str]:\\n        if include_invisible:\\n            return [tool_name  for tool_name in self.tools]\\n        else:\\n            return [tool_name  for tool_name in self.tools if self.tools[tool_name].tool_labels.visible]\\n\",\n            \"name_column\": 8\n        },\n        \"get_all_tools_dict\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"get_all_tools_dict\",\n            \"md_content\": \"\",\n            \"code_start_line\": 169,\n            \"code_end_line\": 170,\n            \"parent\": \"ToolRegister\",\n            \"have_return\": true,\n            \"code_content\": \"    def get_all_tools_dict(self,include_invisible=False)->list[dict]:\\n        return [self.tools[tool_name].tool_labels.dict(name_overwrite=tool_name)  for tool_name in self.get_all_tools(include_invisible)]\\n\",\n            \"name_column\": 8\n        },\n        \"__getitem__\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"__getitem__\",\n            \"md_content\": \"\",\n            \"code_start_line\": 172,\n            \"code_end_line\": 204,\n            \"parent\": \"ToolRegister\",\n            \"have_return\": true,\n            \"code_content\": \"    def __getitem__(self, key)->Callable[..., Any]:\\n        # two stage index, first find env, then find tool\\n        if isinstance(key,str):\\n            if key not in self.tools:\\n                # check if the tool is a env subtool which not visible\\n                try:\\n                    tool_name = key.split('_')\\n                    env_name = tool_name[0]\\n                    tool_name = '_'.join(tool_name[1:])\\n                    return self[env_name,tool_name]\\n                except:\\n                    if self.dynamic_extension_load(f'extensions.tools.{key}') and key in self.tools:\\n                        # try to find tool in unloaded extensions\\n                        return self.tools[key]\\n                    else:\\n                        raise ToolNotFound(tool_name=key)\\n            return self.tools[key]\\n        elif isinstance(key,tuple):\\n            if len(key) != 2:\\n                raise NotImplementedError(f'Key {key} is not valid!')\\n            env_name,tool_name = key\\n            if env_name not in self.envs:\\n                # try to find env in unloaded extensions\\n                if self.dynamic_extension_load(f'extensions.envs.{env_name}') and env_name in self.envs:\\n                    env = self.envs[env_name]\\n                raise EnvNotFound(env_name=env_name)\\n            env = self.envs[env_name]\\n            if tool_name not in env.env_labels.subtools_labels:\\n                raise ToolNotFound(tool_name=env_name+'_'+tool_name)\\n            else:\\n                func = getattr(env,env.env_labels.subtools_labels[tool_name].method.__name__)\\n                return func\\n        raise NotImplementedError(f'Key {key} is not valid!')\",\n            \"name_column\": 8\n        }\n    },\n    \"ToolServer/ToolServerNode/core/register/__init__.py\": {},\n    \"ToolServer/ToolServerNode/core/envs/web.py\": {\n        \"WebEnv\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"WebEnv\",\n            \"md_content\": \"\",\n            \"code_start_line\": 12,\n            \"code_end_line\": 126,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"class WebEnv(BaseEnv):\\n    \\\"\\\"\\\"Web Environment providing web interface and browsering.\\n    \\\"\\\"\\\"\\n    def __init__(self,config:dict = {}):\\n        super().__init__(config=config)\\n        self.bing_cfg = self.config['bing']\\n        if self.bing_cfg['api_key'] is None:\\n            logger.warning(\\\"Bing API key is not provided, rollback to duckduckgo.\\\")\\n        \\n        self.web_cfg = self.config['web']\\n        self.headers = {\\n            \\\"User-Agent\\\":self.web_cfg['user_agent']\\n        }\\n        self.client = httpx.AsyncClient(headers=self.headers,verify=False,timeout=30.0,http2=True)\\n\\n    def _check_url_valid(self,url:str):\\n        local_prefixes = [\\n            \\\"file:///\\\",\\n            \\\"file://127.0.0.1\\\",\\n            \\\"file://localhost\\\",\\n            \\\"http://localhost\\\",\\n            \\\"https://localhost\\\",\\n            \\\"http://2130706433\\\",\\n            \\\"https://2130706433\\\",\\n            \\\"http://127.0.0.1\\\",\\n            \\\"https://127.0.0.1\\\",\\n            \\\"https://0.0.0.0\\\",\\n            \\\"http://0.0.0.0\\\",\\n            \\\"http://0000\\\",\\n            \\\"https://0000\\\",\\n        ]\\n        if any(url.startswith(prefix) for prefix in local_prefixes):\\n            raise ValueError(f\\\"URL {url} is a local url, blocked!\\\")\\n        if not (url.startswith(\\\"http\\\") or url.startswith(\\\"file\\\")):\\n            raise ValueError(f\\\"URL {url} is not a http or https url, please give a valid url!\\\")\\n        \\n    async def search_and_browse(self, search_query:str,goals_to_browse:str,region:str=None,num_results = 3) -> List[str]:\\n        \\\"\\\"\\\"Search with search tools and browse the website returned by search. Note some websites may not be accessable due to network error.\\n    \\n        :param string search_query: The search query.\\n        :param string goals_to_browse: What's you want to find on the website returned by search. If you need more details, request it in here. Examples: 'What is latest news about deepmind?', 'What is the main idea of this article?'\\n        :param string? region: The region code of the search, default to `en-US`. Available regions: `en-US`, `zh-CN`, `ja-JP`, `de-DE`, `fr-FR`, `en-GB`.\\n        :return string: The results of the search.\\n        \\\"\\\"\\\"\\n        \\n        api_key = self.bing_cfg[\\\"api_key\\\"]\\n        endpoint = self.bing_cfg[\\\"endpoint\\\"]\\n        if region is None:\\n            region = 'en-US'\\n        if api_key is None:\\n            pages = [{\\n                'name':ret['title'],\\n                'snippet':ret['body'],\\n                'url':ret['href']\\n            } for ret in DDGS().text(search_query, region='wt-wt')]\\n            \\n        else:\\n            result = await self.client.get(endpoint,\\n                        headers={'Ocp-Apim-Subscription-Key': api_key},\\n                        params={'q': search_query, 'mkt': region },\\n                        timeout=10)\\n            result.raise_for_status()\\n            result = result.json()\\n            pages = result[\\\"webPages\\\"][\\\"value\\\"]\\n            \\n        search_results = []\\n\\n        for idx in range(min(len(pages),num_results)):\\n            try:\\n                page = await self.browse_website(pages[idx]['url'],goals_to_browse)\\n            except httpx.HTTPStatusError as e:\\n                page = e.response.text\\n            except Exception as e:\\n                page = str(e)\\n                \\n            message = {\\n                'name':pages[idx]['name'],\\n                'snippet':pages[idx]['snippet'],\\n                'page':page\\n            }\\n            search_results.append(message)\\n\\n        return search_results\\n    \\n    async def browse_website(self,url:str,goals_to_browse:str)->str:\\n        \\\"\\\"\\\"Give a http or https url to browse a website and return the summarize text. Note some websites may not be accessable due to network error. This tool only return the content of give url and cannot provide any information need interaction with the website.\\n        \\n        :param string url: The realworld Uniform Resource Locator (web address) to scrape text from. Never provide something like \\\"<URL of the second news article>\\\", give real url!!! Example: 'https://www.deepmind.com/'\\n        :param string goals_to_browse: The goals for browse the given `url` (e.g. what you want to find on webpage.). If you need more details, request it in here.\\n        :return string: The content of the website, with formatted text.\\n        \\\"\\\"\\\"\\n        # self._check_url_valid(url)\\n        res = await self.client.get(url)\\n        if res.status_code in [301,302,307,308]:\\n            res = await self.client.get(res.headers['location'])\\n        else:\\n            res.raise_for_status()\\n        \\n        soup = BeautifulSoup(res.text,\\\"html.parser\\\")\\n        text = soup.get_text()\\n        lines = (line.strip() for line in text.splitlines())\\n        chunks = (phrase.strip() for line in lines for phrase in line.split(\\\"  \\\"))\\n        text = \\\"\\\\n\\\".join(chunk for chunk in chunks if chunk)\\n        \\n        links = soup.find_all('a')\\n        if len(links) > 0:\\n            text += '\\\\n\\\\nLinks:\\\\n'\\n            for link in links:\\n                if link.string != None and link.get('href')!= None:\\n                    # print(''.join(link.string.split()),link.get('href'))\\n                    striped_link_string = link.string.strip()\\n                    if striped_link_string != '' and  link.get('href').startswith('http'):\\n                        text += f\\\"{striped_link_string} ({link.get('href')})\\\\n\\\"\\n        \\n        return text\",\n            \"name_column\": 6\n        },\n        \"__init__\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"__init__\",\n            \"md_content\": \"\",\n            \"code_start_line\": 15,\n            \"code_end_line\": 25,\n            \"parent\": \"WebEnv\",\n            \"have_return\": false,\n            \"code_content\": \"    def __init__(self,config:dict = {}):\\n        super().__init__(config=config)\\n        self.bing_cfg = self.config['bing']\\n        if self.bing_cfg['api_key'] is None:\\n            logger.warning(\\\"Bing API key is not provided, rollback to duckduckgo.\\\")\\n        \\n        self.web_cfg = self.config['web']\\n        self.headers = {\\n            \\\"User-Agent\\\":self.web_cfg['user_agent']\\n        }\\n        self.client = httpx.AsyncClient(headers=self.headers,verify=False,timeout=30.0,http2=True)\\n\",\n            \"name_column\": 8\n        },\n        \"_check_url_valid\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"_check_url_valid\",\n            \"md_content\": \"\",\n            \"code_start_line\": 27,\n            \"code_end_line\": 46,\n            \"parent\": \"WebEnv\",\n            \"have_return\": false,\n            \"code_content\": \"    def _check_url_valid(self,url:str):\\n        local_prefixes = [\\n            \\\"file:///\\\",\\n            \\\"file://127.0.0.1\\\",\\n            \\\"file://localhost\\\",\\n            \\\"http://localhost\\\",\\n            \\\"https://localhost\\\",\\n            \\\"http://2130706433\\\",\\n            \\\"https://2130706433\\\",\\n            \\\"http://127.0.0.1\\\",\\n            \\\"https://127.0.0.1\\\",\\n            \\\"https://0.0.0.0\\\",\\n            \\\"http://0.0.0.0\\\",\\n            \\\"http://0000\\\",\\n            \\\"https://0000\\\",\\n        ]\\n        if any(url.startswith(prefix) for prefix in local_prefixes):\\n            raise ValueError(f\\\"URL {url} is a local url, blocked!\\\")\\n        if not (url.startswith(\\\"http\\\") or url.startswith(\\\"file\\\")):\\n            raise ValueError(f\\\"URL {url} is not a http or https url, please give a valid url!\\\")\\n\",\n            \"name_column\": 8\n        },\n        \"search_and_browse\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"search_and_browse\",\n            \"md_content\": \"\",\n            \"code_start_line\": 48,\n            \"code_end_line\": 94,\n            \"parent\": \"WebEnv\",\n            \"have_return\": true,\n            \"code_content\": \"    async def search_and_browse(self, search_query:str,goals_to_browse:str,region:str=None,num_results = 3) -> List[str]:\\n        \\\"\\\"\\\"Search with search tools and browse the website returned by search. Note some websites may not be accessable due to network error.\\n    \\n        :param string search_query: The search query.\\n        :param string goals_to_browse: What's you want to find on the website returned by search. If you need more details, request it in here. Examples: 'What is latest news about deepmind?', 'What is the main idea of this article?'\\n        :param string? region: The region code of the search, default to `en-US`. Available regions: `en-US`, `zh-CN`, `ja-JP`, `de-DE`, `fr-FR`, `en-GB`.\\n        :return string: The results of the search.\\n        \\\"\\\"\\\"\\n        \\n        api_key = self.bing_cfg[\\\"api_key\\\"]\\n        endpoint = self.bing_cfg[\\\"endpoint\\\"]\\n        if region is None:\\n            region = 'en-US'\\n        if api_key is None:\\n            pages = [{\\n                'name':ret['title'],\\n                'snippet':ret['body'],\\n                'url':ret['href']\\n            } for ret in DDGS().text(search_query, region='wt-wt')]\\n            \\n        else:\\n            result = await self.client.get(endpoint,\\n                        headers={'Ocp-Apim-Subscription-Key': api_key},\\n                        params={'q': search_query, 'mkt': region },\\n                        timeout=10)\\n            result.raise_for_status()\\n            result = result.json()\\n            pages = result[\\\"webPages\\\"][\\\"value\\\"]\\n            \\n        search_results = []\\n\\n        for idx in range(min(len(pages),num_results)):\\n            try:\\n                page = await self.browse_website(pages[idx]['url'],goals_to_browse)\\n            except httpx.HTTPStatusError as e:\\n                page = e.response.text\\n            except Exception as e:\\n                page = str(e)\\n                \\n            message = {\\n                'name':pages[idx]['name'],\\n                'snippet':pages[idx]['snippet'],\\n                'page':page\\n            }\\n            search_results.append(message)\\n\\n        return search_results\\n\",\n            \"name_column\": 14\n        },\n        \"browse_website\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"browse_website\",\n            \"md_content\": \"\",\n            \"code_start_line\": 96,\n            \"code_end_line\": 126,\n            \"parent\": \"WebEnv\",\n            \"have_return\": true,\n            \"code_content\": \"    async def browse_website(self,url:str,goals_to_browse:str)->str:\\n        \\\"\\\"\\\"Give a http or https url to browse a website and return the summarize text. Note some websites may not be accessable due to network error. This tool only return the content of give url and cannot provide any information need interaction with the website.\\n        \\n        :param string url: The realworld Uniform Resource Locator (web address) to scrape text from. Never provide something like \\\"<URL of the second news article>\\\", give real url!!! Example: 'https://www.deepmind.com/'\\n        :param string goals_to_browse: The goals for browse the given `url` (e.g. what you want to find on webpage.). If you need more details, request it in here.\\n        :return string: The content of the website, with formatted text.\\n        \\\"\\\"\\\"\\n        # self._check_url_valid(url)\\n        res = await self.client.get(url)\\n        if res.status_code in [301,302,307,308]:\\n            res = await self.client.get(res.headers['location'])\\n        else:\\n            res.raise_for_status()\\n        \\n        soup = BeautifulSoup(res.text,\\\"html.parser\\\")\\n        text = soup.get_text()\\n        lines = (line.strip() for line in text.splitlines())\\n        chunks = (phrase.strip() for line in lines for phrase in line.split(\\\"  \\\"))\\n        text = \\\"\\\\n\\\".join(chunk for chunk in chunks if chunk)\\n        \\n        links = soup.find_all('a')\\n        if len(links) > 0:\\n            text += '\\\\n\\\\nLinks:\\\\n'\\n            for link in links:\\n                if link.string != None and link.get('href')!= None:\\n                    # print(''.join(link.string.split()),link.get('href'))\\n                    striped_link_string = link.string.strip()\\n                    if striped_link_string != '' and  link.get('href').startswith('http'):\\n                        text += f\\\"{striped_link_string} ({link.get('href')})\\\\n\\\"\\n        \\n        return text\",\n            \"name_column\": 14\n        }\n    },\n    \"ToolServer/ToolServerNode/core/envs/filesystem.py\": {\n        \"FileSystemEnv\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"FileSystemEnv\",\n            \"md_content\": \"\",\n            \"code_start_line\": 10,\n            \"code_end_line\": 206,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"class FileSystemEnv(BaseEnv):\\n    \\\"\\\"\\\"Provide a file system operation environment for Agent.\\n    \\\"\\\"\\\"\\n    def __init__(self, config: Dict[str, Any] = None):\\n        super().__init__(config)\\n        filesystem_config = self.config['filesystem']\\n        \\n        self.ignored_list = filesystem_config[\\\"ignored_list\\\"]\\n        self.work_directory = filesystem_config[\\\"work_directory\\\"]\\n        self.max_entry_nums_for_level = filesystem_config[\\\"max_entry_nums_for_level\\\"]\\n        if not os.path.exists(self.work_directory):\\n            os.mkdir(self.work_directory,mode=0o777)\\n        \\n    def _check_ignorement(self,path:str)->bool:\\n        for pattern in self.ignored_list:\\n            if fnmatch.fnmatch(path,pattern):\\n                return True\\n        return False\\n    \\n    def _is_path_within_workspace(self,path:str)->bool:\\n        common_prefix = os.path.commonprefix([os.path.realpath(path),\\n                                            os.path.realpath(self.work_directory)])\\n        return common_prefix == os.path.realpath(self.work_directory)\\n    \\n    def _is_path_exist(self,path:str)->bool:\\n        \\\"\\\"\\\"Check if the path exists in the workspace.\\n        \\n        :param string path: The path to be checked.\\n        :return bool: `True` if the path exists, else `False`.\\n        \\\"\\\"\\\"\\n\\n        full_path = os.path.join(self.work_directory, path)\\n        if not self._is_path_within_workspace(full_path):\\n            raise ValueError(f\\\"Path {path} is not within workspace.\\\")\\n        return os.path.exists(full_path)\\n\\n    def print_filesys_struture(self,return_root=False)->str:\\n        \\\"\\\"\\\"Return a tree-like structure for all files and folders in the workspace. Use this tool if you are not sure what files are in the workspace.\\n\\n        This function recursively walks through all the directories in the workspace\\n        and return them in a tree-like structure, \\n        displaying all the files under each directory.\\n        \\n        Example:\\n        ```\\n        - root/\\n            - sub_directory1/\\n                - file1.txt\\n                - file2.txt\\n            - sub_directory2/\\n                - file3.txt\\n        ```\\n\\n        :return string: The tree-like structure of the workspace.\\n        \\\"\\\"\\\"\\n        full_repr = ''\\n        if return_root:\\n            full_repr += f'Global Root Work Directory: {self.work_directory}\\\\n'\\n\\n        folder_counts =  defaultdict(lambda: 0)\\n        for root, dirs, files in os.walk(self.work_directory):\\n            if self._check_ignorement(root):\\n                continue\\n            level = root.replace(self.work_directory, '').count(os.sep)\\n            indent = ' ' * 4 * (level)\\n            \\n            folder_counts[root] += 1\\n            if folder_counts[root] > self.max_entry_nums_for_level:\\n                full_repr += f'{indent}`wrapped`\\\\n'\\n            \\n            full_repr += f'{indent}- {os.path.basename(root)}/\\\\n'\\n            \\n            idx = 0\\n            subindent = ' ' * 4 * (level + 1) + '- '\\n            for f in files:\\n                if self._check_ignorement(f):\\n                    continue\\n                \\n                idx += 1\\n                if idx > self.max_entry_nums_for_level:\\n                    full_repr += f'{subindent}`wrapped`\\\\n'\\n                    break\\n                full_repr += f'{subindent}{f}\\\\n'\\n\\n\\n        return full_repr\\n    \\n    def read_from_file(self,filepath:str,line_number:int = 1)->str:\\n        \\\"\\\"\\\"Open and read the textual file content in the workspace, you will see the content of the target file.\\n        Don't use this if the give `filepath` is writen or modified before, the content in `filepath` should be already returned.\\n        \\n        :param string filepath: The path to the file to be opened, always use relative path to the workspace root.\\n        :param integer? line_number: The starting line number of the content to be opened. Defaults to 1.\\n        :return string: The content of the file.\\n        \\\"\\\"\\\"\\n        if not filepath.startswith(self.work_directory):\\n            filepath = filepath.strip('/')\\n            full_path = os.path.join(self.work_directory, filepath)        \\n        else:\\n            full_path = filepath\\n                \\n        if self._check_ignorement(full_path) or not os.path.isfile(full_path):\\n            raise FileNotFoundError(f\\\"File {filepath} not found in workspace.\\\")\\n        if not self._is_path_within_workspace(full_path):\\n            raise ValueError(f\\\"File {filepath} is not within workspace.\\\")\\n        if not os.path.exists(full_path):\\n            raise FileNotFoundError(f\\\"File {filepath} not found in workspace.\\\")\\n\\n        content = ''\\n        with open(full_path, 'r') as f:\\n            lines = f.readlines(int(1e5))\\n            \\n        read_count = 0\\n        if not (abs(line_number) - 1 < len(lines)):\\n            raise ValueError(f\\\"Line number {line_number} is out of range.\\\")\\n        index = line_number if line_number >= 0 else len(lines) + line_number\\n        if index == 0:\\n            index = 1\\n            \\n        if line_number == 0:\\n            indexed_lines = lines\\n        elif line_number > 0:\\n            indexed_lines = lines[line_number-1:]\\n        else:\\n            indexed_lines = lines[line_number:]\\n            \\n        for line in indexed_lines:\\n            content += f'{index}'.rjust(5) + ': '\\n            content += line\\n            read_count += len(line)\\n            index += 1\\n        return content\\n\\n    def write_to_file(self, filepath:str,content:str,truncating:bool = False,line_number:int = None, overwrite:bool = False)->str:\\n        \\\"\\\"\\\"Write or modify the textual file lines based on `content` provided. \\n        Return updated content of the file after modification so no further need to call `read_from_file` for this file. Create file if not exists.\\n        \\n        Example:\\n        ```\\n        In[0]: write_to_file('test.txt', 'Hello World!\\\\\\\\nA new line!')\\n        Out[0]: '1: Hello World!\\\\\\\\n2: A new line!'\\n        In[1]: write_to_file('test.txt', 'Hello World 1!', 2)\\n        Out[1]: '1: Hello World!\\\\\\\\n2: Hello World 1!\\\\\\\\n3: A new line!'\\n        In[2]: write_to_file('test.txt', 'Hello World 2!', 2, overwrite=True)\\n        Out[2]: '1: Hello World!\\\\\\\\n2: Hello World 2!\\\\\\\\n3: A new line!'\\n        ```\\n        \\n        :param string filepath: The path to the file to be modified, always use relative path to the workspace root.\\n        :param boolean? truncating: If `True`, the file will be truncated before writing, else will read current content before writing. Defaults to `False`.\\n        :param integer? line_number: The start line to modified file. Defaults to `None`, which means insert the new content at the end of the file. So do not provide this if you want to append the new content to the file.\\n        :param boolean? overwrite: If `True`, the new content will overwrite content started from `line_number` line. Defaults to `False`, which insert the new content at the `line_number` line.\\n        :param string content: The new content to be replaced with the old content.\\n        \\\"\\\"\\\"\\n        if not filepath.startswith(self.work_directory):\\n            filepath = filepath.strip('/')\\n            full_path = os.path.join(self.work_directory, filepath)\\n        else:\\n            full_path = filepath\\n        if not self._is_path_within_workspace(full_path) or  self._check_ignorement(full_path):\\n            raise ValueError(f\\\"File {filepath} is not within workspace.\\\")\\n        \\n        if not os.path.exists(full_path):\\n            if line_number is None or line_number==0 or line_number == 1:\\n                os.makedirs(os.path.split(full_path)[0],exist_ok=True)\\n                open(full_path, 'w+').close()\\n            else:\\n                raise FileNotFoundError(f\\\"File {filepath} not found in workspace.\\\")\\n        elif not os.path.isfile(full_path):\\n            raise ValueError(f\\\"File {filepath} is not a file.\\\")\\n            \\n        # protential overflow\\n        if truncating:\\n            lines = []\\n        else:\\n            with open(full_path, 'r') as f:\\n                lines = f.readlines()\\n        \\n        \\n        new_lines = content.splitlines(keepends=True)\\n        if line_number is None:\\n            lines.extend(new_lines)\\n        else:\\n            if line_number >= 1:\\n                line_number -= 1\\n            if overwrite:\\n                lines[line_number: line_number+len(new_lines)] = new_lines\\n            else:\\n                lines[line_number: line_number] = new_lines \\n\\n        for idx, _ in enumerate(lines):\\n            if not lines[idx].endswith('\\\\n'):\\n                lines[idx] += '\\\\n'\\n                \\n        with open(full_path, 'w+') as f:\\n            f.writelines(lines)\\n            \\n        return self.read_from_file(filepath)\\n\",\n            \"name_column\": 6\n        },\n        \"__init__\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"__init__\",\n            \"md_content\": \"\",\n            \"code_start_line\": 13,\n            \"code_end_line\": 21,\n            \"parent\": \"FileSystemEnv\",\n            \"have_return\": false,\n            \"code_content\": \"    def __init__(self, config: Dict[str, Any] = None):\\n        super().__init__(config)\\n        filesystem_config = self.config['filesystem']\\n        \\n        self.ignored_list = filesystem_config[\\\"ignored_list\\\"]\\n        self.work_directory = filesystem_config[\\\"work_directory\\\"]\\n        self.max_entry_nums_for_level = filesystem_config[\\\"max_entry_nums_for_level\\\"]\\n        if not os.path.exists(self.work_directory):\\n            os.mkdir(self.work_directory,mode=0o777)\\n\",\n            \"name_column\": 8\n        },\n        \"_check_ignorement\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"_check_ignorement\",\n            \"md_content\": \"\",\n            \"code_start_line\": 23,\n            \"code_end_line\": 27,\n            \"parent\": \"FileSystemEnv\",\n            \"have_return\": true,\n            \"code_content\": \"    def _check_ignorement(self,path:str)->bool:\\n        for pattern in self.ignored_list:\\n            if fnmatch.fnmatch(path,pattern):\\n                return True\\n        return False\\n\",\n            \"name_column\": 8\n        },\n        \"_is_path_within_workspace\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"_is_path_within_workspace\",\n            \"md_content\": \"\",\n            \"code_start_line\": 29,\n            \"code_end_line\": 32,\n            \"parent\": \"FileSystemEnv\",\n            \"have_return\": true,\n            \"code_content\": \"    def _is_path_within_workspace(self,path:str)->bool:\\n        common_prefix = os.path.commonprefix([os.path.realpath(path),\\n                                            os.path.realpath(self.work_directory)])\\n        return common_prefix == os.path.realpath(self.work_directory)\\n\",\n            \"name_column\": 8\n        },\n        \"_is_path_exist\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"_is_path_exist\",\n            \"md_content\": \"\",\n            \"code_start_line\": 34,\n            \"code_end_line\": 44,\n            \"parent\": \"FileSystemEnv\",\n            \"have_return\": true,\n            \"code_content\": \"    def _is_path_exist(self,path:str)->bool:\\n        \\\"\\\"\\\"Check if the path exists in the workspace.\\n        \\n        :param string path: The path to be checked.\\n        :return bool: `True` if the path exists, else `False`.\\n        \\\"\\\"\\\"\\n\\n        full_path = os.path.join(self.work_directory, path)\\n        if not self._is_path_within_workspace(full_path):\\n            raise ValueError(f\\\"Path {path} is not within workspace.\\\")\\n        return os.path.exists(full_path)\\n\",\n            \"name_column\": 8\n        },\n        \"print_filesys_struture\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"print_filesys_struture\",\n            \"md_content\": \"\",\n            \"code_start_line\": 46,\n            \"code_end_line\": 95,\n            \"parent\": \"FileSystemEnv\",\n            \"have_return\": true,\n            \"code_content\": \"    def print_filesys_struture(self,return_root=False)->str:\\n        \\\"\\\"\\\"Return a tree-like structure for all files and folders in the workspace. Use this tool if you are not sure what files are in the workspace.\\n\\n        This function recursively walks through all the directories in the workspace\\n        and return them in a tree-like structure, \\n        displaying all the files under each directory.\\n        \\n        Example:\\n        ```\\n        - root/\\n            - sub_directory1/\\n                - file1.txt\\n                - file2.txt\\n            - sub_directory2/\\n                - file3.txt\\n        ```\\n\\n        :return string: The tree-like structure of the workspace.\\n        \\\"\\\"\\\"\\n        full_repr = ''\\n        if return_root:\\n            full_repr += f'Global Root Work Directory: {self.work_directory}\\\\n'\\n\\n        folder_counts =  defaultdict(lambda: 0)\\n        for root, dirs, files in os.walk(self.work_directory):\\n            if self._check_ignorement(root):\\n                continue\\n            level = root.replace(self.work_directory, '').count(os.sep)\\n            indent = ' ' * 4 * (level)\\n            \\n            folder_counts[root] += 1\\n            if folder_counts[root] > self.max_entry_nums_for_level:\\n                full_repr += f'{indent}`wrapped`\\\\n'\\n            \\n            full_repr += f'{indent}- {os.path.basename(root)}/\\\\n'\\n            \\n            idx = 0\\n            subindent = ' ' * 4 * (level + 1) + '- '\\n            for f in files:\\n                if self._check_ignorement(f):\\n                    continue\\n                \\n                idx += 1\\n                if idx > self.max_entry_nums_for_level:\\n                    full_repr += f'{subindent}`wrapped`\\\\n'\\n                    break\\n                full_repr += f'{subindent}{f}\\\\n'\\n\\n\\n        return full_repr\\n\",\n            \"name_column\": 8\n        },\n        \"read_from_file\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"read_from_file\",\n            \"md_content\": \"\",\n            \"code_start_line\": 97,\n            \"code_end_line\": 141,\n            \"parent\": \"FileSystemEnv\",\n            \"have_return\": true,\n            \"code_content\": \"    def read_from_file(self,filepath:str,line_number:int = 1)->str:\\n        \\\"\\\"\\\"Open and read the textual file content in the workspace, you will see the content of the target file.\\n        Don't use this if the give `filepath` is writen or modified before, the content in `filepath` should be already returned.\\n        \\n        :param string filepath: The path to the file to be opened, always use relative path to the workspace root.\\n        :param integer? line_number: The starting line number of the content to be opened. Defaults to 1.\\n        :return string: The content of the file.\\n        \\\"\\\"\\\"\\n        if not filepath.startswith(self.work_directory):\\n            filepath = filepath.strip('/')\\n            full_path = os.path.join(self.work_directory, filepath)        \\n        else:\\n            full_path = filepath\\n                \\n        if self._check_ignorement(full_path) or not os.path.isfile(full_path):\\n            raise FileNotFoundError(f\\\"File {filepath} not found in workspace.\\\")\\n        if not self._is_path_within_workspace(full_path):\\n            raise ValueError(f\\\"File {filepath} is not within workspace.\\\")\\n        if not os.path.exists(full_path):\\n            raise FileNotFoundError(f\\\"File {filepath} not found in workspace.\\\")\\n\\n        content = ''\\n        with open(full_path, 'r') as f:\\n            lines = f.readlines(int(1e5))\\n            \\n        read_count = 0\\n        if not (abs(line_number) - 1 < len(lines)):\\n            raise ValueError(f\\\"Line number {line_number} is out of range.\\\")\\n        index = line_number if line_number >= 0 else len(lines) + line_number\\n        if index == 0:\\n            index = 1\\n            \\n        if line_number == 0:\\n            indexed_lines = lines\\n        elif line_number > 0:\\n            indexed_lines = lines[line_number-1:]\\n        else:\\n            indexed_lines = lines[line_number:]\\n            \\n        for line in indexed_lines:\\n            content += f'{index}'.rjust(5) + ': '\\n            content += line\\n            read_count += len(line)\\n            index += 1\\n        return content\\n\",\n            \"name_column\": 8\n        },\n        \"write_to_file\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"write_to_file\",\n            \"md_content\": \"\",\n            \"code_start_line\": 143,\n            \"code_end_line\": 206,\n            \"parent\": \"FileSystemEnv\",\n            \"have_return\": true,\n            \"code_content\": \"    def write_to_file(self, filepath:str,content:str,truncating:bool = False,line_number:int = None, overwrite:bool = False)->str:\\n        \\\"\\\"\\\"Write or modify the textual file lines based on `content` provided. \\n        Return updated content of the file after modification so no further need to call `read_from_file` for this file. Create file if not exists.\\n        \\n        Example:\\n        ```\\n        In[0]: write_to_file('test.txt', 'Hello World!\\\\\\\\nA new line!')\\n        Out[0]: '1: Hello World!\\\\\\\\n2: A new line!'\\n        In[1]: write_to_file('test.txt', 'Hello World 1!', 2)\\n        Out[1]: '1: Hello World!\\\\\\\\n2: Hello World 1!\\\\\\\\n3: A new line!'\\n        In[2]: write_to_file('test.txt', 'Hello World 2!', 2, overwrite=True)\\n        Out[2]: '1: Hello World!\\\\\\\\n2: Hello World 2!\\\\\\\\n3: A new line!'\\n        ```\\n        \\n        :param string filepath: The path to the file to be modified, always use relative path to the workspace root.\\n        :param boolean? truncating: If `True`, the file will be truncated before writing, else will read current content before writing. Defaults to `False`.\\n        :param integer? line_number: The start line to modified file. Defaults to `None`, which means insert the new content at the end of the file. So do not provide this if you want to append the new content to the file.\\n        :param boolean? overwrite: If `True`, the new content will overwrite content started from `line_number` line. Defaults to `False`, which insert the new content at the `line_number` line.\\n        :param string content: The new content to be replaced with the old content.\\n        \\\"\\\"\\\"\\n        if not filepath.startswith(self.work_directory):\\n            filepath = filepath.strip('/')\\n            full_path = os.path.join(self.work_directory, filepath)\\n        else:\\n            full_path = filepath\\n        if not self._is_path_within_workspace(full_path) or  self._check_ignorement(full_path):\\n            raise ValueError(f\\\"File {filepath} is not within workspace.\\\")\\n        \\n        if not os.path.exists(full_path):\\n            if line_number is None or line_number==0 or line_number == 1:\\n                os.makedirs(os.path.split(full_path)[0],exist_ok=True)\\n                open(full_path, 'w+').close()\\n            else:\\n                raise FileNotFoundError(f\\\"File {filepath} not found in workspace.\\\")\\n        elif not os.path.isfile(full_path):\\n            raise ValueError(f\\\"File {filepath} is not a file.\\\")\\n            \\n        # protential overflow\\n        if truncating:\\n            lines = []\\n        else:\\n            with open(full_path, 'r') as f:\\n                lines = f.readlines()\\n        \\n        \\n        new_lines = content.splitlines(keepends=True)\\n        if line_number is None:\\n            lines.extend(new_lines)\\n        else:\\n            if line_number >= 1:\\n                line_number -= 1\\n            if overwrite:\\n                lines[line_number: line_number+len(new_lines)] = new_lines\\n            else:\\n                lines[line_number: line_number] = new_lines \\n\\n        for idx, _ in enumerate(lines):\\n            if not lines[idx].endswith('\\\\n'):\\n                lines[idx] += '\\\\n'\\n                \\n        with open(full_path, 'w+') as f:\\n            f.writelines(lines)\\n            \\n        return self.read_from_file(filepath)\\n\",\n            \"name_column\": 8\n        }\n    },\n    \"ToolServer/ToolServerNode/core/envs/__init__.py\": {},\n    \"ToolServer/ToolServerNode/core/envs/pycoding.py\": {\n        \"PythonNotebook\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"PythonNotebook\",\n            \"md_content\": \"\",\n            \"code_start_line\": 16,\n            \"code_end_line\": 178,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"class PythonNotebook(BaseEnv):\\n    \\\"\\\"\\\"Python Notebook Environment. Provide a notebook interface to run python code.\\\"\\\"\\\"\\n    def __init__(self, config: Dict[str, Any] = None):\\n        super().__init__(config)\\n        filesystem_config = self.config['filesystem']\\n        \\n        self.work_directory = filesystem_config[\\\"work_directory\\\"]\\n        \\n        self.nb_cfg = self.config['notebook']\\n        \\n        if not os.path.exists(self.work_directory):\\n            os.mkdir(self.work_directory,mode=0o777)\\n\\n        # make a new notebook\\n        self.nb = nbformat.v4.new_notebook(\\n            metadata = {'kernelspec': {'name': 'python', 'language': 'python', 'display_name': 'python'}})\\n        self.nbc = NotebookClient(self.nb,timeout=self.nb_cfg['timeout'])\\n    \\n    async def _running(self):\\n        if self.nbc.kc is not None:\\n            return await ensure_async(self.nbc.kc.is_alive())\\n        return False\\n    \\n    async def _reset(self):\\n        if await self._running():\\n            await self.nbc._async_cleanup_kernel()\\n        self.nbc.create_kernel_manager()\\n        await self.nbc.async_start_new_kernel(cwd=self.work_directory)\\n        await self.nbc.async_start_new_kernel_client()\\n\\n    @staticmethod\\n    def _fix_escape(problematic_code: str) -> str:\\n        for str_sign in ['\\\"', \\\"'\\\", '\\\"\\\"\\\"', \\\"'''\\\"]:\\n\\n            pattern = rf'{str_sign}(.*?){str_sign}'\\n            in_line_strs = re.findall(pattern, problematic_code, re.DOTALL)\\n            replaced_in_line_strs = []\\n            for in_line_str in in_line_strs:\\n                replaced_in_line_strs.append(in_line_str.replace('\\\\n', '\\\\\\\\n').replace('\\\\r', '\\\\\\\\r').replace('\\\\t', '\\\\\\\\t'))\\n            for original_str, modified_str in zip(in_line_strs, replaced_in_line_strs):\\n                fixed_code = problematic_code.replace(f'{str_sign}' + original_str + f'{str_sign}',\\n                                                            f'{str_sign}' + modified_str + f'{str_sign}')\\n\\n        return fixed_code\\n\\n        \\n    async def execute_cell(self,code:str,cell_index:int=None,reset:bool=False) -> str:\\n        \\\"\\\"\\\"Create or replace a notebook cell and execute it, return the output.\\n        Use this tool to test your idea quickly. Carefully examine the output to make sure it is what you want.\\n        \\n        Example:\\n        ```\\n        In[0]: code='print(\\\"hello world\\\")' # This will create a new cell and execute it.\\n        Out[0]: ['cell_index: 0', 'hello world']\\n        In[1]: code='print(\\\"hello world\\\")',cell_index=0 # This will overwrite the first cell and execute it.\\n        In[2]: code='print(\\\"hello world\\\")',cell_index=-1 # This will overwrite the last cell and execute it.\\n        ```\\n        \\n        :param string code: python code to be executed, make sure it is valid python code with right format. don't provide shell command that started with '!' here.\\n        :param integer? cell_index: the index of the cell to be insert and overwrite `code`, default to `None`, which means append new cell.\\n        :param boolean? reset: whether to reset the kernel before executing the code. Default to `False`.\\n        :return string: execution result.\\n        \\\"\\\"\\\"\\n        # code = self._fix_escape(code)\\n        if reset or not await self._running():\\n            await self._reset()\\n        if cell_index is None or cell_index == len(self.nb.cells) or len(self.nb.cells) == 0:\\n            self.nb.cells.append(nbformat.v4.new_code_cell(code))\\n            cell_index = len(self.nb.cells)-1\\n        else:\\n            self.nb.cells[cell_index] = nbformat.v4.new_code_cell(code)\\n        \\n        try:\\n            await self.nbc.async_execute_cell(self.nb.cells[-1],len(self.nb.cells)-1)\\n        except CellExecutionError as e:\\n            pass\\n        except DeadKernelError as e:\\n            await self._reset()\\n            \\n        nbformat.write(self.nb,os.path.join(self.work_directory,self.nb_cfg['save_name']))\\n        \\n        return self._format_outputs(self.nb.cells[cell_index].outputs,cell_index,reraise=True,return_binary=True)\\n        \\n    def print_notebook(self)->str:\\n        \\\"\\\"\\\"print all notebook cells' content and output.\\n        \\n        :return string: all notebook cells description.\\n        \\\"\\\"\\\"\\n        ret = ''\\n        for i,cell in enumerate(self.nb.cells):\\n            ret += f'= Cell {i} =\\\\n'\\n            if cell['cell_type'] == 'code':\\n                ret += f'{cell[\\\"source\\\"]}\\\\n'\\n                if len(cell['outputs']) != 0:\\n                    ret += f'= Output {i} =\\\\n'\\n                    ret += f'{self._format_outputs(cell[\\\"outputs\\\"])}\\\\n'\\n        return ret\\n    def _format_outputs(self,outputs,cell_index=None,reraise=False,return_binary=False):\\n        ret = None\\n        if len(outputs) == 0:\\n            ret = '' if cell_index is None else f'cell_index: {cell_index}'\\n        elif len(outputs) == 1:\\n            if cell_index is not None:\\n                ret = {\\n                    'type':'composite',\\n                    'data':[\\n                        f'cell_index: {cell_index}',\\n                        self._format_output(outputs[0],cell_index,reraise,return_binary)\\n                    ]\\n                }\\n            else:\\n                ret = self._format_output(outputs[0],cell_index,reraise,return_binary)\\n        else:\\n            ret = {\\n                'type':'composite',\\n                'data':[\\n                    self._format_output(output,cell_index,reraise,return_binary) for output in outputs\\n                ]\\n            }\\n            if cell_index is not None:\\n                ret['data'].insert(0,f'cell_index: {cell_index}')\\n        return ret\\n        \\n    def _format_output(self,output,cell_index=None,reraise=False,return_binary=False):\\n        def format_single_data(data,data_type:str):\\n            if data_type.startswith('image/'):\\n                return {\\n                    'type': 'binary',\\n                    'media_type':data_type,\\n                    'data': data if return_binary else '`Wrapped`'\\n                }\\n            elif data_type.startswith('text/'):\\n                return ''.join(data)\\n            elif data_type.startswith('application/'):\\n                return data\\n            return data\\n            \\n        ret = None\\n        match output['output_type']:\\n            case 'execute_result' | 'display_data':\\n                keys = list(output['data'].keys())\\n                if 'text/html' in keys and 'text/plain' in keys:\\n                    keys.remove('text/html') # remove html\\n                if len(keys) == 1:\\n                    ret = format_single_data(output['data'][keys[0]],keys[0])\\n                elif len(keys) > 1:\\n                    ret = {\\n                        'type': 'composite',\\n                        'data':[]\\n                    }\\n                    for k in keys:\\n                        ret['data'].append(format_single_data(output['data'][k],k))\\n                    \\n            case 'error':\\n                if reraise:\\n                    raise ToolExecutionError(f'cell_index: {cell_index}\\\\n'+'\\\\n'.join(output['traceback']))\\n                else:\\n                    return '\\\\n'.join(output['traceback'])\\n            case 'stream':\\n                ret = output['text']\\n            case _:\\n                ret = output\\n        return ret\\n\",\n            \"name_column\": 6\n        },\n        \"__init__\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"__init__\",\n            \"md_content\": \"\",\n            \"code_start_line\": 18,\n            \"code_end_line\": 32,\n            \"parent\": \"PythonNotebook\",\n            \"have_return\": false,\n            \"code_content\": \"    def __init__(self, config: Dict[str, Any] = None):\\n        super().__init__(config)\\n        filesystem_config = self.config['filesystem']\\n        \\n        self.work_directory = filesystem_config[\\\"work_directory\\\"]\\n        \\n        self.nb_cfg = self.config['notebook']\\n        \\n        if not os.path.exists(self.work_directory):\\n            os.mkdir(self.work_directory,mode=0o777)\\n\\n        # make a new notebook\\n        self.nb = nbformat.v4.new_notebook(\\n            metadata = {'kernelspec': {'name': 'python', 'language': 'python', 'display_name': 'python'}})\\n        self.nbc = NotebookClient(self.nb,timeout=self.nb_cfg['timeout'])\\n\",\n            \"name_column\": 8\n        },\n        \"_running\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"_running\",\n            \"md_content\": \"\",\n            \"code_start_line\": 34,\n            \"code_end_line\": 37,\n            \"parent\": \"PythonNotebook\",\n            \"have_return\": true,\n            \"code_content\": \"    async def _running(self):\\n        if self.nbc.kc is not None:\\n            return await ensure_async(self.nbc.kc.is_alive())\\n        return False\\n\",\n            \"name_column\": 14\n        },\n        \"_reset\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"_reset\",\n            \"md_content\": \"\",\n            \"code_start_line\": 39,\n            \"code_end_line\": 44,\n            \"parent\": \"PythonNotebook\",\n            \"have_return\": false,\n            \"code_content\": \"    async def _reset(self):\\n        if await self._running():\\n            await self.nbc._async_cleanup_kernel()\\n        self.nbc.create_kernel_manager()\\n        await self.nbc.async_start_new_kernel(cwd=self.work_directory)\\n        await self.nbc.async_start_new_kernel_client()\\n\",\n            \"name_column\": 14\n        },\n        \"_fix_escape\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"_fix_escape\",\n            \"md_content\": \"\",\n            \"code_start_line\": 47,\n            \"code_end_line\": 59,\n            \"parent\": \"PythonNotebook\",\n            \"have_return\": true,\n            \"code_content\": \"    def _fix_escape(problematic_code: str) -> str:\\n        for str_sign in ['\\\"', \\\"'\\\", '\\\"\\\"\\\"', \\\"'''\\\"]:\\n\\n            pattern = rf'{str_sign}(.*?){str_sign}'\\n            in_line_strs = re.findall(pattern, problematic_code, re.DOTALL)\\n            replaced_in_line_strs = []\\n            for in_line_str in in_line_strs:\\n                replaced_in_line_strs.append(in_line_str.replace('\\\\n', '\\\\\\\\n').replace('\\\\r', '\\\\\\\\r').replace('\\\\t', '\\\\\\\\t'))\\n            for original_str, modified_str in zip(in_line_strs, replaced_in_line_strs):\\n                fixed_code = problematic_code.replace(f'{str_sign}' + original_str + f'{str_sign}',\\n                                                            f'{str_sign}' + modified_str + f'{str_sign}')\\n\\n        return fixed_code\\n\",\n            \"name_column\": 8\n        },\n        \"execute_cell\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"execute_cell\",\n            \"md_content\": \"\",\n            \"code_start_line\": 62,\n            \"code_end_line\": 97,\n            \"parent\": \"PythonNotebook\",\n            \"have_return\": true,\n            \"code_content\": \"    async def execute_cell(self,code:str,cell_index:int=None,reset:bool=False) -> str:\\n        \\\"\\\"\\\"Create or replace a notebook cell and execute it, return the output.\\n        Use this tool to test your idea quickly. Carefully examine the output to make sure it is what you want.\\n        \\n        Example:\\n        ```\\n        In[0]: code='print(\\\"hello world\\\")' # This will create a new cell and execute it.\\n        Out[0]: ['cell_index: 0', 'hello world']\\n        In[1]: code='print(\\\"hello world\\\")',cell_index=0 # This will overwrite the first cell and execute it.\\n        In[2]: code='print(\\\"hello world\\\")',cell_index=-1 # This will overwrite the last cell and execute it.\\n        ```\\n        \\n        :param string code: python code to be executed, make sure it is valid python code with right format. don't provide shell command that started with '!' here.\\n        :param integer? cell_index: the index of the cell to be insert and overwrite `code`, default to `None`, which means append new cell.\\n        :param boolean? reset: whether to reset the kernel before executing the code. Default to `False`.\\n        :return string: execution result.\\n        \\\"\\\"\\\"\\n        # code = self._fix_escape(code)\\n        if reset or not await self._running():\\n            await self._reset()\\n        if cell_index is None or cell_index == len(self.nb.cells) or len(self.nb.cells) == 0:\\n            self.nb.cells.append(nbformat.v4.new_code_cell(code))\\n            cell_index = len(self.nb.cells)-1\\n        else:\\n            self.nb.cells[cell_index] = nbformat.v4.new_code_cell(code)\\n        \\n        try:\\n            await self.nbc.async_execute_cell(self.nb.cells[-1],len(self.nb.cells)-1)\\n        except CellExecutionError as e:\\n            pass\\n        except DeadKernelError as e:\\n            await self._reset()\\n            \\n        nbformat.write(self.nb,os.path.join(self.work_directory,self.nb_cfg['save_name']))\\n        \\n        return self._format_outputs(self.nb.cells[cell_index].outputs,cell_index,reraise=True,return_binary=True)\\n\",\n            \"name_column\": 14\n        },\n        \"print_notebook\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"print_notebook\",\n            \"md_content\": \"\",\n            \"code_start_line\": 99,\n            \"code_end_line\": 112,\n            \"parent\": \"PythonNotebook\",\n            \"have_return\": true,\n            \"code_content\": \"    def print_notebook(self)->str:\\n        \\\"\\\"\\\"print all notebook cells' content and output.\\n        \\n        :return string: all notebook cells description.\\n        \\\"\\\"\\\"\\n        ret = ''\\n        for i,cell in enumerate(self.nb.cells):\\n            ret += f'= Cell {i} =\\\\n'\\n            if cell['cell_type'] == 'code':\\n                ret += f'{cell[\\\"source\\\"]}\\\\n'\\n                if len(cell['outputs']) != 0:\\n                    ret += f'= Output {i} =\\\\n'\\n                    ret += f'{self._format_outputs(cell[\\\"outputs\\\"])}\\\\n'\\n        return ret\\n\",\n            \"name_column\": 8\n        },\n        \"_format_outputs\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"_format_outputs\",\n            \"md_content\": \"\",\n            \"code_start_line\": 113,\n            \"code_end_line\": 137,\n            \"parent\": \"PythonNotebook\",\n            \"have_return\": true,\n            \"code_content\": \"    def _format_outputs(self,outputs,cell_index=None,reraise=False,return_binary=False):\\n        ret = None\\n        if len(outputs) == 0:\\n            ret = '' if cell_index is None else f'cell_index: {cell_index}'\\n        elif len(outputs) == 1:\\n            if cell_index is not None:\\n                ret = {\\n                    'type':'composite',\\n                    'data':[\\n                        f'cell_index: {cell_index}',\\n                        self._format_output(outputs[0],cell_index,reraise,return_binary)\\n                    ]\\n                }\\n            else:\\n                ret = self._format_output(outputs[0],cell_index,reraise,return_binary)\\n        else:\\n            ret = {\\n                'type':'composite',\\n                'data':[\\n                    self._format_output(output,cell_index,reraise,return_binary) for output in outputs\\n                ]\\n            }\\n            if cell_index is not None:\\n                ret['data'].insert(0,f'cell_index: {cell_index}')\\n        return ret\\n\",\n            \"name_column\": 8\n        },\n        \"_format_output\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"_format_output\",\n            \"md_content\": \"\",\n            \"code_start_line\": 139,\n            \"code_end_line\": 178,\n            \"parent\": \"PythonNotebook\",\n            \"have_return\": true,\n            \"code_content\": \"    def _format_output(self,output,cell_index=None,reraise=False,return_binary=False):\\n        def format_single_data(data,data_type:str):\\n            if data_type.startswith('image/'):\\n                return {\\n                    'type': 'binary',\\n                    'media_type':data_type,\\n                    'data': data if return_binary else '`Wrapped`'\\n                }\\n            elif data_type.startswith('text/'):\\n                return ''.join(data)\\n            elif data_type.startswith('application/'):\\n                return data\\n            return data\\n            \\n        ret = None\\n        match output['output_type']:\\n            case 'execute_result' | 'display_data':\\n                keys = list(output['data'].keys())\\n                if 'text/html' in keys and 'text/plain' in keys:\\n                    keys.remove('text/html') # remove html\\n                if len(keys) == 1:\\n                    ret = format_single_data(output['data'][keys[0]],keys[0])\\n                elif len(keys) > 1:\\n                    ret = {\\n                        'type': 'composite',\\n                        'data':[]\\n                    }\\n                    for k in keys:\\n                        ret['data'].append(format_single_data(output['data'][k],k))\\n                    \\n            case 'error':\\n                if reraise:\\n                    raise ToolExecutionError(f'cell_index: {cell_index}\\\\n'+'\\\\n'.join(output['traceback']))\\n                else:\\n                    return '\\\\n'.join(output['traceback'])\\n            case 'stream':\\n                ret = output['text']\\n            case _:\\n                ret = output\\n        return ret\\n\",\n            \"name_column\": 8\n        },\n        \"format_single_data\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"format_single_data\",\n            \"md_content\": \"\",\n            \"code_start_line\": 140,\n            \"code_end_line\": 151,\n            \"parent\": \"_format_output\",\n            \"have_return\": true,\n            \"code_content\": \"        def format_single_data(data,data_type:str):\\n            if data_type.startswith('image/'):\\n                return {\\n                    'type': 'binary',\\n                    'media_type':data_type,\\n                    'data': data if return_binary else '`Wrapped`'\\n                }\\n            elif data_type.startswith('text/'):\\n                return ''.join(data)\\n            elif data_type.startswith('application/'):\\n                return data\\n            return data\\n\",\n            \"name_column\": 12\n        }\n    },\n    \"ToolServer/ToolServerNode/utils/retriever.py\": {\n        \"standardizing\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"standardizing\",\n            \"md_content\": \"\",\n            \"code_start_line\": 16,\n            \"code_end_line\": 30,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"def standardizing(string: str) -> str:\\n    \\\"\\\"\\\"\\n    Return a standardized string by replacing non-alphanumeric characters with underscores,\\n    reducing multiple underscores to one, and converting all characters to lowercase.\\n\\n    Args:\\n        string: The input string to be standardized.\\n\\n    Returns: \\n        A standardized version of the input string.\\n    \\\"\\\"\\\"\\n    string = STANDARDIZING_PATTERN.sub(\\\"_\\\", string)\\n    string = re.sub(r\\\"(_)\\\\1+\\\",\\\"_\\\", string)\\n    string = string.strip(\\\"_\\\").lower()\\n    return string\\n\",\n            \"name_column\": 4\n        },\n        \"ada_retriever\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"ada_retriever\",\n            \"md_content\": \"\",\n            \"code_start_line\": 32,\n            \"code_end_line\": 59,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"def ada_retriever(doc_embeddings: list, id2tool:dict, question: str, top_k: int=5) -> list:\\n    \\\"\\\"\\\"\\n    Retrieve tools related to the provided question.\\n\\n    Args:\\n        doc_embeddings: The list of document embeddings.\\n        id2tool: A dictionary mapping tool id to tool name.\\n        question: The question for the ADA retriever.\\n        top_k: The number of top tools to return (default is 5).\\n\\n    Returns:\\n        A list of retrieved tools.\\n    \\\"\\\"\\\"\\n    cfg = CONFIG['retriver']\\n    url = cfg['endpoint']\\n    headers = cfg['headers']\\n    payload = {'input':question}\\n    payload.update(cfg['payload'])\\n    \\n    response = requests.post(url, json=payload, headers=headers)\\n    query_embedding = np.array(response.json()['data'][0]['embedding'])\\n\\n    similarities = cosine_similarity([query_embedding], doc_embeddings)\\n\\n    sorted_doc_indices = sorted(range(len(similarities[0])), key=lambda i: similarities[0][i], reverse=True)\\n    retrieved_tools = list(map(lambda doc_id: id2tool[str(doc_id)],sorted_doc_indices[:top_k]))\\n    \\n    return retrieved_tools\\n\",\n            \"name_column\": 4\n        },\n        \"build_tool_embeddings\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"build_tool_embeddings\",\n            \"md_content\": \"\",\n            \"code_start_line\": 61,\n            \"code_end_line\": 147,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"def build_tool_embeddings(tools_json: list[dict]) -> tuple:\\n    \\\"\\\"\\\"\\n    Build tool embeddings.\\n\\n    Args:\\n        tools_json: The list of dictionaries containing tool data.\\n\\n    Returns:\\n        A tuple containing a list of document embeddings and a dictionary\\n        mapping tool id to tool name.\\n    \\\"\\\"\\\"\\n    cfg = CONFIG['retriver']\\n    if os.path.exists(cfg['id2tool_file']) and os.path.exists(cfg['embedding_file']):\\n        id2tool = json.load(open(cfg['id2tool_file'], \\\"r\\\"))\\n        doc_embedings = np.load(cfg['embedding_file'])\\n        if len(id2tool) != len(doc_embedings):\\n            logger.error('Embedding file and id2tool file do not match! Rebuild embeddings!')\\n            id2tool = {}\\n            doc_embedings = []\\n    else:\\n        id2tool = {}\\n        doc_embedings = []\\n\\n    # check embedding file whether need to be updated\\n    # get all current tool names\\n    # tool_names = set(map(lambda tool_json: tool_json['name'], tools_json))\\n    # cached_tool_names = set(id2tool.values())\\n    # if tool_names == cached_tool_names:\\n    #     logger.info('No tools change, use cached embeddings!')\\n    #     return doc_embedings, id2tool\\n    return doc_embedings, id2tool\\n    \\n    # update embeddings\\n    logger.info('Tools change detected, updating embeddings...')\\n    url = cfg['endpoint']\\n    headers = cfg['headers']\\n    \\n    new_id2tool = { str(i):tool_json['name'] for i,tool_json in enumerate(tools_json) }\\n    json.dump(new_id2tool, open(cfg['id2tool_file'], \\\"w\\\"), indent=4)\\n\\n    def get_embedding(tool_json:dict) -> list:\\n        \\\"\\\"\\\"\\n        Get embedding for a certain tool.\\n\\n        Args:\\n            tool_json: The dictionary containing tool data.\\n\\n        Returns:\\n            A list of tool embeddings.\\n        \\\"\\\"\\\"\\n        payload = {'input':json.dumps(tool_json)}\\n        payload.update(cfg['payload'])\\n        try:\\n            response = requests.post(url, json=payload, headers=headers)\\n            response.raise_for_status()\\n        except Exception as e:\\n            logger.error(f'Failed to get embedding for tool {tool_json[\\\"name\\\"]}! Error: {e}')\\n            return [-1.000001] * cfg['embedding_dim']\\n        return response.json()['data'][0]['embedding']\\n    \\n    uncached_tools = list(filter(lambda tool_json: tool_json['name'] not in cached_tool_names, tools_json))\\n    uncached_tools_name = list(map(lambda tool_json: tool_json['name'],uncached_tools))\\n    uncached_doc_embedings = []\\n    with ThreadPoolExecutor(16) as pool:\\n        futures = [pool.submit(get_embedding, tool_json) for tool_json in uncached_tools]\\n        \\n        for future in tqdm.tqdm(futures,ncols=100):\\n            uncached_doc_embedings.append(future.result())\\n    \\n    new_doc_embedings = []\\n    for tool_json in tools_json:\\n        if tool_json['name'] not in cached_tool_names:\\n            new_doc_embedings.append(\\n                uncached_doc_embedings[\\n                    uncached_tools_name.index(tool_json['name'])\\n                    ])\\n        else:\\n            for doc_id in id2tool.keys():\\n                if id2tool[doc_id] == tool_json['name']:\\n                    new_doc_embedings.append(doc_embedings[int(doc_id)])\\n                    break\\n\\n    new_doc_embedings = np.array(new_doc_embedings)\\n    np.save(cfg['embedding_file'], new_doc_embedings)\\n\\n    logger.info('Embeddings updated! New embeddings saved!')\\n    return doc_embedings, new_id2tool\",\n            \"name_column\": 4\n        },\n        \"get_embedding\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"get_embedding\",\n            \"md_content\": \"\",\n            \"code_start_line\": 101,\n            \"code_end_line\": 119,\n            \"parent\": \"build_tool_embeddings\",\n            \"have_return\": true,\n            \"code_content\": \"    def get_embedding(tool_json:dict) -> list:\\n        \\\"\\\"\\\"\\n        Get embedding for a certain tool.\\n\\n        Args:\\n            tool_json: The dictionary containing tool data.\\n\\n        Returns:\\n            A list of tool embeddings.\\n        \\\"\\\"\\\"\\n        payload = {'input':json.dumps(tool_json)}\\n        payload.update(cfg['payload'])\\n        try:\\n            response = requests.post(url, json=payload, headers=headers)\\n            response.raise_for_status()\\n        except Exception as e:\\n            logger.error(f'Failed to get embedding for tool {tool_json[\\\"name\\\"]}! Error: {e}')\\n            return [-1.000001] * cfg['embedding_dim']\\n        return response.json()['data'][0]['embedding']\\n\",\n            \"name_column\": 8\n        }\n    },\n    \"ToolServer/ToolServerNode/utils/__init__.py\": {},\n    \"ToolServer/ToolServerNode/utils/response.py\": {\n        \"is_base64\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"is_base64\",\n            \"md_content\": \"\",\n            \"code_start_line\": 6,\n            \"code_end_line\": 20,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"def is_base64(s:str) -> bool:\\n    \\\"\\\"\\\"\\n    Check if the given string is a base64 sting or not.\\n\\n    Args:\\n        s (str): the string to be checked.\\n\\n    Returns:\\n        bool: Returns True if the given string is a base64 string, False otherwise.\\n    \\\"\\\"\\\"\\n    try:\\n        base64.b64decode(s)\\n        return True\\n    except:\\n        return False\\n\",\n            \"name_column\": 4\n        },\n        \"is_wrapped_response\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"is_wrapped_response\",\n            \"md_content\": \"\",\n            \"code_start_line\": 22,\n            \"code_end_line\": 36,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"def is_wrapped_response(obj:dict) -> bool:\\n    \\\"\\\"\\\"\\n    Check if the dictionary object is a wrapped response.\\n    A dictionary is considered as wrapped response if it has 'type' and 'data' keys,\\n    and value of 'type' key is one of ['simple','composite','binary'].\\n\\n    Args:\\n        obj (dict): the dictionary object to be checked.\\n\\n    Returns:\\n        bool: Returns True if the dictionary is a wrapped response, False otherwise.\\n    \\\"\\\"\\\"\\n    if 'type' in obj and obj['type'] in ['simple','composite','binary'] and 'data' in obj:\\n        return True\\n    return False\\n\",\n            \"name_column\": 4\n        },\n        \"wrap_tool_response\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"wrap_tool_response\",\n            \"md_content\": \"\",\n            \"code_start_line\": 38,\n            \"code_end_line\": 128,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"def wrap_tool_response(obj:Any) -> dict|list|str|int|float|bool:\\n    \\\"\\\"\\\"\\n    Wrap the tool response in a standardized object structure (depending on its type) to allow decoding.\\n    \\n    Format\\n    ======\\n    ```\\n    {\\n        'type': 'simple',       # for single return value like python basic types\\n        'data': obj\\n    },\\n    {\\n        'type': 'binary',       # for single return value like python basic types\\n        'media_type':'image/png',   # or other media types\\n        'name': 'xxx',             # file name of the binary data\\n        'data': obj             # base64 encoded binary data\\n    },\\n    str,int,float,bool,list is directly returned\\n    or\\n    {\\n        'type': 'composite',    # for multiple return values\\n        'data': [\\n            {\\n                'type': 'simple',\\n                'data': obj1\\n            },\\n            {\\n                'type': 'simple',\\n                'data': obj2\\n            }\\n        ]\\n    }\\n    ```\\n    Standardized Structures:\\n    - For simple data types (str, int, float, bool), the object is directly returned.\\n    - For composite types (tuples), data is wrapped in an object with a composite type.\\n    - For binary data, data is base64 encoded and wrapped in an object with a binary type.\\n     \\n\\n    Args:\\n        obj (Any): any Python object that needs to be wrapped.\\n\\n    Returns:\\n        Union[dict, list, str, int, float, bool]: the wrapped response.\\n        \\n    Raises:\\n        logger.warning: raises warning if the type of 'obj' is unknown.\\n    \\\"\\\"\\\"\\n    if isinstance(obj,tuple):\\n        if len(obj) == 0:\\n            ret = {\\n                'type': 'simple',\\n                'data': None\\n            }\\n        elif len(obj) == 1:\\n            ret = {\\n                'type': 'simple',\\n                'data': obj[0]\\n            }\\n        else:\\n            ret = {\\n                'type': 'composite',\\n                'data': []\\n            }\\n            for o in obj:\\n                ret['data'].append(wrap_tool_response(o))\\n    elif isinstance(obj,bytes):\\n        ret = {\\n            'type': 'binary',\\n            'media_type': 'bytes',\\n            'name': None,\\n            'data': base64.b64encode(obj).decode()\\n        }\\n    elif isinstance(obj,(str,int,float,bool,list)) or obj is None:\\n        ret = obj\\n    elif isinstance(obj,dict):\\n        # check if already wrapped\\n        if is_wrapped_response(obj):\\n            ret = obj\\n        else:\\n            ret = {\\n                'type': 'simple',\\n                'data': obj\\n            }\\n    else:\\n        logger.warning(f'Unknown type {type(obj)} in wrap_tool_response')\\n        ret = {\\n            'type': 'simple',\\n            'data': obj\\n        }\\n    return ret\",\n            \"name_column\": 4\n        }\n    },\n    \"ToolServer/ToolServerNode/utils/import_helper.py\": {\n        \"import_all_modules_in_folder\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"import_all_modules_in_folder\",\n            \"md_content\": \"\",\n            \"code_start_line\": 3,\n            \"code_end_line\": 20,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"def import_all_modules_in_folder(file,name):\\n    current_dir = os.path.dirname(file)\\n    all_modules = []\\n    for item in os.listdir(current_dir):\\n        item_path = os.path.join(current_dir, item)\\n        if os.path.isfile(item_path) and item != '__init__.py' and item.endswith('.py'):\\n            module_name = item[:-3]\\n        elif os.path.isdir(item_path) and item != '__pycache__' and os.path.exists(os.path.join(item_path, '__init__.py')) and os.path.isfile(os.path.join(item_path, '__init__.py')):\\n            module_name = item\\n        else:\\n            continue\\n\\n        full_module_path = f\\\"{name}.{module_name}\\\"\\n        # print(module_name,full_module_path)\\n        imported_module = importlib.import_module(full_module_path)\\n        globals()[module_name] = imported_module\\n        all_modules.append(imported_module)\\n    return all_modules\",\n            \"name_column\": 4\n        }\n    },\n    \"ToolServer/ToolServerNode/utils/openai.py\": {\n        \"OpenaiPoolRequest\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"OpenaiPoolRequest\",\n            \"md_content\": \"\",\n            \"code_start_line\": 14,\n            \"code_end_line\": 93,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"class OpenaiPoolRequest:\\n    \\\"\\\"\\\"\\n    Handles all OpenAI requests by dispatching them to the API endpoints.\\n\\n    Attributes:\\n        openai_cfg: Configuration dictionary containing OpenAI parameters.\\n        pool: list of dictionaries, where each dictionary has all the required details of an endpoint.\\n    \\\"\\\"\\\"\\n    def __init__(self,):\\n        \\\"\\\"\\\"\\n        Initializes the OpenaiPoolRequest class by setting the configuration and loading the pool.\\n        \\\"\\\"\\\"\\n        self.openai_cfg = deepcopy(CONFIG['openai'])\\n        \\n        self.pool:List[Dict] = []\\n        \\n        __pool_file = self.openai_cfg['key_pool_json']\\n        if os.environ.get('API_POOL_FILE',None) is not None:\\n            __pool_file = os.environ.get('API_POOL_FILE')\\n        \\n        if os.path.exists(__pool_file):\\n            self.pool = json.load(open(__pool_file))\\n        \\n        if os.environ.get('OPENAI_KEY',None) is not None:\\n            self.pool.append({\\n                'api_key':os.environ.get('OPENAI_KEY'),\\n                'organization':os.environ.get('OPENAI_ORG',None),\\n                'api_type':os.environ.get('OPENAI_TYPE',None),\\n                'api_version':os.environ.get('OPENAI_VER',None)\\n            })\\n        if len(self.pool) == 0:\\n            logger.warning('No openai api key found! Some functions will be disable!')\\n\\n    @retry(wait=wait_random_exponential(multiplier=1, max=10), stop=stop_after_attempt(5),reraise=True)\\n    async def request(self,messages,**kwargs) -> Dict[str, Any]:\\n        \\\"\\\"\\\"\\n        Sends a request to the OpenAI and gets a response.\\n\\n        Args:\\n            messages: Payload to be sent to OpenAI.\\n            kwargs: Optional arguments that the function takes.\\n\\n        Returns:\\n            A dictionary containing the response from the OpenAI.\\n\\n        Raises:\\n            Exception: If the attempt to reach the endpoint exceed limit.\\n        \\\"\\\"\\\"\\n        \\n        chat_args:dict = deepcopy(self.openai_cfg['chat_args'])\\n        chat_args.update(kwargs)\\n\\n        item = random.choice(self.pool)\\n        chat_args['api_key'] = item['api_key']\\n        if 'organization' in item:\\n            chat_args['organization'] = item['organization']\\n        if 'api_type' in item:\\n            chat_args['api_type'] = item['api_type']\\n        if 'api_version' in item:\\n            chat_args['api_version'] = item['api_version']\\n\\n        return await openai.ChatCompletion.acreate(messages=messages,**chat_args)\\n    \\n    async def __call__(self,messages,**kwargs) -> Dict[str, Any]:\\n        \\\"\\\"\\\"\\n        Makes a request to the OpenAI by calling the instance of the class.\\n\\n        Args:\\n            messages: Payload to be sent to OpenAI.\\n            kwargs: Optional arguments that the function takes.\\n\\n        Returns:\\n            A dictionary containing the response from the OpenAI.\\n\\n        Raises:\\n            Exception: If there are no API keys available in the pool.\\n        \\\"\\\"\\\"\\n        if len(self.pool)==0:\\n            raise Exception('No openai api key found! OPENAI_PR Disabled!')\\n        return await self.request(messages,**kwargs)\\n\",\n            \"name_column\": 6\n        },\n        \"__init__\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"__init__\",\n            \"md_content\": \"\",\n            \"code_start_line\": 22,\n            \"code_end_line\": 45,\n            \"parent\": \"OpenaiPoolRequest\",\n            \"have_return\": false,\n            \"code_content\": \"    def __init__(self,):\\n        \\\"\\\"\\\"\\n        Initializes the OpenaiPoolRequest class by setting the configuration and loading the pool.\\n        \\\"\\\"\\\"\\n        self.openai_cfg = deepcopy(CONFIG['openai'])\\n        \\n        self.pool:List[Dict] = []\\n        \\n        __pool_file = self.openai_cfg['key_pool_json']\\n        if os.environ.get('API_POOL_FILE',None) is not None:\\n            __pool_file = os.environ.get('API_POOL_FILE')\\n        \\n        if os.path.exists(__pool_file):\\n            self.pool = json.load(open(__pool_file))\\n        \\n        if os.environ.get('OPENAI_KEY',None) is not None:\\n            self.pool.append({\\n                'api_key':os.environ.get('OPENAI_KEY'),\\n                'organization':os.environ.get('OPENAI_ORG',None),\\n                'api_type':os.environ.get('OPENAI_TYPE',None),\\n                'api_version':os.environ.get('OPENAI_VER',None)\\n            })\\n        if len(self.pool) == 0:\\n            logger.warning('No openai api key found! Some functions will be disable!')\\n\",\n            \"name_column\": 8\n        },\n        \"request\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"request\",\n            \"md_content\": \"\",\n            \"code_start_line\": 48,\n            \"code_end_line\": 75,\n            \"parent\": \"OpenaiPoolRequest\",\n            \"have_return\": true,\n            \"code_content\": \"    async def request(self,messages,**kwargs) -> Dict[str, Any]:\\n        \\\"\\\"\\\"\\n        Sends a request to the OpenAI and gets a response.\\n\\n        Args:\\n            messages: Payload to be sent to OpenAI.\\n            kwargs: Optional arguments that the function takes.\\n\\n        Returns:\\n            A dictionary containing the response from the OpenAI.\\n\\n        Raises:\\n            Exception: If the attempt to reach the endpoint exceed limit.\\n        \\\"\\\"\\\"\\n        \\n        chat_args:dict = deepcopy(self.openai_cfg['chat_args'])\\n        chat_args.update(kwargs)\\n\\n        item = random.choice(self.pool)\\n        chat_args['api_key'] = item['api_key']\\n        if 'organization' in item:\\n            chat_args['organization'] = item['organization']\\n        if 'api_type' in item:\\n            chat_args['api_type'] = item['api_type']\\n        if 'api_version' in item:\\n            chat_args['api_version'] = item['api_version']\\n\\n        return await openai.ChatCompletion.acreate(messages=messages,**chat_args)\\n\",\n            \"name_column\": 14\n        },\n        \"__call__\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"__call__\",\n            \"md_content\": \"\",\n            \"code_start_line\": 77,\n            \"code_end_line\": 93,\n            \"parent\": \"OpenaiPoolRequest\",\n            \"have_return\": true,\n            \"code_content\": \"    async def __call__(self,messages,**kwargs) -> Dict[str, Any]:\\n        \\\"\\\"\\\"\\n        Makes a request to the OpenAI by calling the instance of the class.\\n\\n        Args:\\n            messages: Payload to be sent to OpenAI.\\n            kwargs: Optional arguments that the function takes.\\n\\n        Returns:\\n            A dictionary containing the response from the OpenAI.\\n\\n        Raises:\\n            Exception: If there are no API keys available in the pool.\\n        \\\"\\\"\\\"\\n        if len(self.pool)==0:\\n            raise Exception('No openai api key found! OPENAI_PR Disabled!')\\n        return await self.request(messages,**kwargs)\\n\",\n            \"name_column\": 14\n        }\n    },\n    \"ToolServer/ToolServerNode/extensions/__init__.py\": {},\n    \"ToolServer/ToolServerNode/extensions/tools/code_interpreter.py\": {\n        \"run_interpreter\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"run_interpreter\",\n            \"md_content\": \"\",\n            \"code_start_line\": 11,\n            \"code_end_line\": 47,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"async def run_interpreter(code:str=None,command:str=None,filename:str='code.py'):\\n    \\\"\\\"\\\"The code interpreter tool that runs code and return the output.\\n\\n    The `code` will be written to file `filename` and the `command` will be executed in a shell.\\n    Example:\\n    ```\\n    run_interpreter(code='print(\\\"hello world\\\")',command='python code.py')\\n    ```\\n\\n    :param string? code: The code to be written, default to `None`, which means no code will be written to file.\\n    :param string? command: The shell command to be executed should avoid requiring additional user input, default to `python {filename}`.\\n    :param string? filename: The filename to be written in mode `w`, default to `code.py`.\\n\\n    \\\"\\\"\\\"\\n    if code is not None and code != \\\"\\\" and filename != \\\"\\\":\\n        CODE_FS.write_to_file(filename,code)\\n\\n    if command is None:\\n        command = f'python {filename}'\\n    exec_proc = await asyncio.create_subprocess_shell(\\n        'bash',\\n        stderr=asyncio.subprocess.PIPE,\\n        stdout=asyncio.subprocess.PIPE,\\n        stdin=asyncio.subprocess.PIPE,\\n        cwd=CODE_FS.work_directory)\\n    \\n    ret = await asyncio.wait_for(exec_proc.communicate(command.encode()),timeout=CONFIG['shell']['timeout'])\\n    \\n    result = {\\n        'ReturnCode':exec_proc.returncode,\\n    }\\n    if ret[1]!=b'':\\n        result['Error'] = ret[1].decode()\\n    if ret[0]!=b'':\\n        result['Output'] = ret[0].decode()\\n\\n    return result\\n\",\n            \"name_column\": 10\n        }\n    },\n    \"ToolServer/ToolServerNode/extensions/tools/__init__.py\": {},\n    \"ToolServer/ToolServerNode/extensions/tools/calculator.py\": {\n        \"calculator\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"calculator\",\n            \"md_content\": \"\",\n            \"code_start_line\": 9,\n            \"code_end_line\": 28,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"def calculator(expression:str)->str:\\n    \\\"\\\"\\\"It is a simple calculator, which can execute Python expressions: e.g., \\\"(123 + 234) / 23 * 1.5 - 8\\\".\\n        \\n    :param string expression: The python expression you requested.\\n    :return string: The execution results of the expression.\\n    \\\"\\\"\\\"\\n    globals={}\\n    locals={}\\n    try:\\n        # Wrap the code in an eval() call to return the result\\n        wrapped_code = f\\\"__result__ = eval({repr(expression)}, globals(), locals())\\\"\\n        exec(wrapped_code, globals, locals)\\n        return locals.get('__result__', None)\\n    except Exception as e:\\n        try:\\n        # If eval fails, attempt to exec the code without returning a result\\n            exec(expression, globals, locals)\\n            return \\\"Code executed successfully.\\\"\\n        except Exception as e:\\n            return f\\\"Error: {str(e)}\\\"\\n\",\n            \"name_column\": 4\n        }\n    },\n    \"ToolServer/ToolServerNode/extensions/tools/search.py\": {\n        \"bing_search\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"bing_search\",\n            \"md_content\": \"\",\n            \"code_start_line\": 10,\n            \"code_end_line\": 40,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"def bing_search(query:str,region:str = None)->str|list[str]:\\n    \\\"\\\"\\\"Return 3 most relevant results of a Bing search using the official Bing API. This tool does not provide website details, use other tools to browse website if you need.\\n    \\n    :param string query: The search query.\\n    :param string? region: The region code of the search, default to `en-US`. Available regions: `en-US`, `zh-CN`, `ja-JP`, `en-AU`, `en-CA`, `en-GB`, `de-DE`, `en-IN`, `en-ID`, `es-ES`, `fr-FR`, `it-IT`, `en-MY`, `nl-NL`, `en-NZ`, `en-PH`, `en-SG`, `en-ZA`, `sv-SE`, `tr-TR`.\\n    :return string: The results of the search.\\n    \\\"\\\"\\\"\\n    #     :param int num_results: The number of results to return.\\n    \\n    num_results = 3\\n    endpoint = bing_cfg[\\\"endpoint\\\"]\\n    api_key = bing_cfg[\\\"api_key\\\"]\\n    if region is None:\\n        region = 'en-US'\\n    result = requests.get(endpoint, headers={'Ocp-Apim-Subscription-Key': api_key}, params={'q': query, 'mkt': region }, timeout=10)\\n    result.raise_for_status()\\n    result = result.json()\\n\\n    pages = result[\\\"webPages\\\"][\\\"value\\\"]\\n    search_results = []\\n\\n    for idx in range(min(len(pages),num_results)):\\n        message = {\\n            'url':pages[idx]['url'],\\n            'name':pages[idx]['name'],\\n            'snippet':pages[idx]['snippet']\\n        }\\n        search_results.append(message)\\n\\n    # Return the list of search result\\n    return search_results\",\n            \"name_column\": 4\n        }\n    },\n    \"ToolServer/ToolServerNode/extensions/envs/shell.py\": {\n        \"read_pipe\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"read_pipe\",\n            \"md_content\": \"\",\n            \"code_start_line\": 12,\n            \"code_end_line\": 23,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"def read_pipe(pipe:Union[io.StringIO,io.BytesIO],text=True)->Union[str,bytes]:\\n    \\\"\\\"\\\"Reading the `subprocess.PIPE` when readable.\\n    If `text` is `True`, return str, else return bytes.\\n    \\\"\\\"\\\"\\n    output = '' if text else b''\\n    while True:\\n        ready_fds,_,_ = select.select( [pipe.fileno()],[],[],0.01)\\n        if len(ready_fds) == 0:\\n            break\\n        output += os.read(ready_fds[0],16384).decode() if text else os.read(ready_fds[0],16384)\\n\\n    return output\\n\",\n            \"name_column\": 4\n        },\n        \"ShellEnv\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"ShellEnv\",\n            \"md_content\": \"\",\n            \"code_start_line\": 26,\n            \"code_end_line\": 129,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"class ShellEnv(BaseEnv):\\n    \\\"\\\"\\\"Provide and maintain an interactive shell environment.\\n    \\\"\\\"\\\"\\n    def __init__(self,\\n                 config:Dict[str,Any]):\\n        super().__init__(config)\\n        \\n        if sys.platform.startswith(\\\"linux\\\"):\\n            self.shell_program = \\\"bash\\\"\\n        elif sys.platform.startswith(\\\"darwin\\\"):\\n            self.shell_program = \\\"zsh\\\"\\n        else:\\n            self.shell_program = \\\"powershell\\\"\\n        self.work_directory = self.config['filesystem']['work_directory']\\n        self._restart()\\n\\n    @property\\n    def running(self)->bool:\\n        \\\"\\\"\\\"`True` if shell is running, else `False`\\n        \\\"\\\"\\\"\\n        if hasattr(self,'running_proc') and isinstance(self.running_proc,subprocess.Popen):\\n            if self.running_proc.poll() is None:\\n                return True\\n        return False\\n    \\n    def _restart(self,program:str=None,shell:bool=True):\\n        f\\\"\\\"\\\"Restart the shell.\\n        \\n        :param string? program: The program to be executed in shell, the default is `{self.shell_program}`.\\n        \\\"\\\"\\\"\\n        self._kill()\\n        if program is None:\\n            program = self.shell_program\\n        self.running_proc = subprocess.Popen(\\n            program, # adding more shells support\\n            stdin=subprocess.PIPE,\\n            stdout=subprocess.PIPE,\\n            stderr=subprocess.PIPE,\\n            cwd=self.work_directory,\\n            shell=shell,\\n            text=True\\n        )\\n        self.output_fileno = [self.running_proc.stdout.fileno(),self.running_proc.stderr.fileno()]\\n    \\n    def _terminate(self):\\n        \\\"\\\"\\\"Terminate the shell.\\n        \\\"\\\"\\\"\\n        if self.running:\\n            self.running_proc.terminate()\\n\\n    def _kill(self):\\n        \\\"\\\"\\\"Kill the shell.\\n        \\\"\\\"\\\"\\n        if self.running:\\n            self.running_proc.kill()\\n\\n    def read_stdout(self, probe: bool = False) -> str:\\n        \\\"\\\"\\\"Read the stdout stream of the shell. If stderr is not empty, it will be returned instead.\\n        \\n        Empty string will be returned if both stdout and stderr are empty.\\n        You can use this function to check if the shell has new content to be read for a running process takes a while.\\n        \\n        :param boolean? probe: If `True`, the function will return immediately if no output is ready, else it will raise `OutputNotReady` exception and request to call functions in `next_calling` to get result.\\n        \\\"\\\"\\\"\\n        if not self.running:\\n            raise RuntimeError('Shell is not running!')\\n        \\n        ready_fds,_,_ = select.select(self.output_fileno,[],[],0.01)\\n        if probe and len(ready_fds) == 0 :\\n            raise OutputNotReady('Output is not ready!',next_calling=get_func_name(self.read_stdout,self),arguments={'probe':True})\\n        \\n        error = read_pipe(self.running_proc.stderr)\\n        if error:\\n            return error\\n\\n        return read_pipe(self.running_proc.stdout)\\n    \\n    \\n    def write_stdin(self, content:str) -> str:\\n        \\\"\\\"\\\"Write the stdin stream of the shell and get instant feedback from stderr or stdout.\\n        \\n        Example:\\n        ```\\n        write_stdin('echo \\\"hello world\\\"')\\n        ```\\n        This will execute the command `echo \\\"hello world\\\"` in shell and return the output `hello world`.\\n        \\n        :param string content: The content to be written.\\n        \\\"\\\"\\\"\\n\\n        # removed temporarily, maybe put back later?\\n        # You may need to call `read_stdout` to get further feedback for running process takes a while.\\n        if not self.running:\\n            raise RuntimeError('Shell is not running!')\\n        if not content.endswith(\\\"\\\\n\\\"):\\n            content += \\\"\\\\n\\\"\\n        self.running_proc.stdin.write(content)\\n        self.running_proc.stdin.flush()\\n        \\n        ready_fds,_,_ = select.select(self.output_fileno,[],[],0.01)\\n        if len(ready_fds) == 0:\\n            raise OutputNotReady('Output is not ready!',next_calling=get_func_name(self.read_stdout,self),arguments={'probe':True})\\n        \\n        return 'Instant shell output: ' + self.read_stdout()\\n\",\n            \"name_column\": 6\n        },\n        \"__init__\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"__init__\",\n            \"md_content\": \"\",\n            \"code_start_line\": 29,\n            \"code_end_line\": 40,\n            \"parent\": \"ShellEnv\",\n            \"have_return\": false,\n            \"code_content\": \"    def __init__(self,\\n                 config:Dict[str,Any]):\\n        super().__init__(config)\\n        \\n        if sys.platform.startswith(\\\"linux\\\"):\\n            self.shell_program = \\\"bash\\\"\\n        elif sys.platform.startswith(\\\"darwin\\\"):\\n            self.shell_program = \\\"zsh\\\"\\n        else:\\n            self.shell_program = \\\"powershell\\\"\\n        self.work_directory = self.config['filesystem']['work_directory']\\n        self._restart()\\n\",\n            \"name_column\": 8\n        },\n        \"running\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"running\",\n            \"md_content\": \"\",\n            \"code_start_line\": 43,\n            \"code_end_line\": 49,\n            \"parent\": \"ShellEnv\",\n            \"have_return\": true,\n            \"code_content\": \"    def running(self)->bool:\\n        \\\"\\\"\\\"`True` if shell is running, else `False`\\n        \\\"\\\"\\\"\\n        if hasattr(self,'running_proc') and isinstance(self.running_proc,subprocess.Popen):\\n            if self.running_proc.poll() is None:\\n                return True\\n        return False\\n\",\n            \"name_column\": 8\n        },\n        \"_restart\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"_restart\",\n            \"md_content\": \"\",\n            \"code_start_line\": 51,\n            \"code_end_line\": 68,\n            \"parent\": \"ShellEnv\",\n            \"have_return\": false,\n            \"code_content\": \"    def _restart(self,program:str=None,shell:bool=True):\\n        f\\\"\\\"\\\"Restart the shell.\\n        \\n        :param string? program: The program to be executed in shell, the default is `{self.shell_program}`.\\n        \\\"\\\"\\\"\\n        self._kill()\\n        if program is None:\\n            program = self.shell_program\\n        self.running_proc = subprocess.Popen(\\n            program, # adding more shells support\\n            stdin=subprocess.PIPE,\\n            stdout=subprocess.PIPE,\\n            stderr=subprocess.PIPE,\\n            cwd=self.work_directory,\\n            shell=shell,\\n            text=True\\n        )\\n        self.output_fileno = [self.running_proc.stdout.fileno(),self.running_proc.stderr.fileno()]\\n\",\n            \"name_column\": 8\n        },\n        \"_terminate\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"_terminate\",\n            \"md_content\": \"\",\n            \"code_start_line\": 70,\n            \"code_end_line\": 74,\n            \"parent\": \"ShellEnv\",\n            \"have_return\": false,\n            \"code_content\": \"    def _terminate(self):\\n        \\\"\\\"\\\"Terminate the shell.\\n        \\\"\\\"\\\"\\n        if self.running:\\n            self.running_proc.terminate()\\n\",\n            \"name_column\": 8\n        },\n        \"_kill\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"_kill\",\n            \"md_content\": \"\",\n            \"code_start_line\": 76,\n            \"code_end_line\": 80,\n            \"parent\": \"ShellEnv\",\n            \"have_return\": false,\n            \"code_content\": \"    def _kill(self):\\n        \\\"\\\"\\\"Kill the shell.\\n        \\\"\\\"\\\"\\n        if self.running:\\n            self.running_proc.kill()\\n\",\n            \"name_column\": 8\n        },\n        \"read_stdout\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"read_stdout\",\n            \"md_content\": \"\",\n            \"code_start_line\": 82,\n            \"code_end_line\": 101,\n            \"parent\": \"ShellEnv\",\n            \"have_return\": true,\n            \"code_content\": \"    def read_stdout(self, probe: bool = False) -> str:\\n        \\\"\\\"\\\"Read the stdout stream of the shell. If stderr is not empty, it will be returned instead.\\n        \\n        Empty string will be returned if both stdout and stderr are empty.\\n        You can use this function to check if the shell has new content to be read for a running process takes a while.\\n        \\n        :param boolean? probe: If `True`, the function will return immediately if no output is ready, else it will raise `OutputNotReady` exception and request to call functions in `next_calling` to get result.\\n        \\\"\\\"\\\"\\n        if not self.running:\\n            raise RuntimeError('Shell is not running!')\\n        \\n        ready_fds,_,_ = select.select(self.output_fileno,[],[],0.01)\\n        if probe and len(ready_fds) == 0 :\\n            raise OutputNotReady('Output is not ready!',next_calling=get_func_name(self.read_stdout,self),arguments={'probe':True})\\n        \\n        error = read_pipe(self.running_proc.stderr)\\n        if error:\\n            return error\\n\\n        return read_pipe(self.running_proc.stdout)\\n\",\n            \"name_column\": 8\n        },\n        \"write_stdin\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"write_stdin\",\n            \"md_content\": \"\",\n            \"code_start_line\": 104,\n            \"code_end_line\": 129,\n            \"parent\": \"ShellEnv\",\n            \"have_return\": true,\n            \"code_content\": \"    def write_stdin(self, content:str) -> str:\\n        \\\"\\\"\\\"Write the stdin stream of the shell and get instant feedback from stderr or stdout.\\n        \\n        Example:\\n        ```\\n        write_stdin('echo \\\"hello world\\\"')\\n        ```\\n        This will execute the command `echo \\\"hello world\\\"` in shell and return the output `hello world`.\\n        \\n        :param string content: The content to be written.\\n        \\\"\\\"\\\"\\n\\n        # removed temporarily, maybe put back later?\\n        # You may need to call `read_stdout` to get further feedback for running process takes a while.\\n        if not self.running:\\n            raise RuntimeError('Shell is not running!')\\n        if not content.endswith(\\\"\\\\n\\\"):\\n            content += \\\"\\\\n\\\"\\n        self.running_proc.stdin.write(content)\\n        self.running_proc.stdin.flush()\\n        \\n        ready_fds,_,_ = select.select(self.output_fileno,[],[],0.01)\\n        if len(ready_fds) == 0:\\n            raise OutputNotReady('Output is not ready!',next_calling=get_func_name(self.read_stdout,self),arguments={'probe':True})\\n        \\n        return 'Instant shell output: ' + self.read_stdout()\\n\",\n            \"name_column\": 8\n        }\n    },\n    \"ToolServer/ToolServerNode/extensions/envs/__init__.py\": {},\n    \"ToolServer/ToolServerNode/extensions/envs/rapidapi.py\": {\n        \"generate_arg_doc\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"generate_arg_doc\",\n            \"md_content\": \"\",\n            \"code_start_line\": 14,\n            \"code_end_line\": 32,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"def generate_arg_doc(arg_name,arg_type,arg_desc,arg_default=None,arg_optional=None):\\n    match arg_type:\\n        case 'NUMBER':\\n            arg_type = 'integer'\\n        case 'STRING':\\n            arg_type = 'string'\\n        case 'BOOLEAN':\\n            arg_type = 'boolean'\\n        case 'ARRAY':\\n            arg_type = 'array'\\n        case 'OBJECT':\\n            arg_type = 'object'\\n\\n    if arg_optional:\\n        arg_type += '?'\\n    if arg_default:\\n        return f':param {arg_type} {arg_name}: {arg_desc} defaults to {arg_default}'\\n    else:\\n        return f':param {arg_type} {arg_name}: {arg_desc}'\\n\",\n            \"name_column\": 4\n        },\n        \"convert_rapidapi_desc_to_code\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"convert_rapidapi_desc_to_code\",\n            \"md_content\": \"\",\n            \"code_start_line\": 34,\n            \"code_end_line\": 81,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"def convert_rapidapi_desc_to_code(rapidapi_desc:dict)->list[dict]:\\n    tool_desc = {\\n        'category':rapidapi_desc['category'],\\n        'tool_name':standardizing(rapidapi_desc['tool_name']),\\n    }\\n    api_infos = {}\\n    for api_desc in rapidapi_desc['api_list']:\\n        api_name = standardizing(api_desc['name'])\\n        if api_name in ['from','class','return','false','true','id','and']:\\n            api_name = 'is_'+ api_name\\n        api_info = {'api_name':api_name}\\n        api_info.update(tool_desc)\\n        \\n        api_uri = '_'.join(['rapi',tool_desc['tool_name'],api_name])\\n        \\n        \\n        args_doc = []\\n        \\n        for param in api_desc['required_parameters']:\\n            args_doc.append(generate_arg_doc(\\n                param['name'],\\n                param['type'],\\n                param['description'],\\n                param['default'] if 'default' in param else None,\\n                ))\\n        \\n        for param in api_desc['optional_parameters']:\\n            args_doc.append(generate_arg_doc(\\n                param['name'],\\n                param['type'],\\n                param['description'],\\n                param['default'] if 'default' in param else None,\\n                True))\\n        \\n        args_doc = '\\\\n    '.join(args_doc)\\n        code = f\\\"\\\"\\\"async def {api_uri}(self,*args,**kwargs):\\n    '''{rapidapi_desc['tool_description']}\\n    {api_info['description'] if 'description' in api_info else ''}\\n    \\n\\n    {args_doc}\\n    '''\\n    return await self._request_rapid_api('{api_uri}',kwargs)\\n        \\\"\\\"\\\"\\n        api_info['code'] = code\\n        \\n        api_infos[api_uri] = api_info\\n    return api_infos\\n\",\n            \"name_column\": 4\n        },\n        \"rapid_api_mapper\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"rapid_api_mapper\",\n            \"md_content\": \"\",\n            \"code_start_line\": 83,\n            \"code_end_line\": 103,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"def rapid_api_mapper(cls:Type):\\n    \\\"\\\"\\\"Dynamic adding api functions to RapidAPIENnv.\\\"\\\"\\\"\\n    #reading api list\\n    if not os.path.exists(CONFIG['rapidapi']['api_infos_json']):\\n        try:\\n            api_list = json.load(open(CONFIG['rapidapi']['api_raw_json']))\\n        except:\\n            raise FileNotFoundError(f'Both api_infos_json and api_raw_json are not found! Failed to setup RapidAPIEnv!')\\n        \\n        for rapidapi_desc in api_list:\\n            API_INFOS.update(convert_rapidapi_desc_to_code(rapidapi_desc))\\n        \\n        json.dump(API_INFOS,open(CONFIG['rapidapi']['api_infos_json'],'w'),indent=4)\\n    else:\\n        API_INFOS.update(json.load(open(CONFIG['rapidapi']['api_infos_json'])))\\n    \\n    for api_uri,api_info in API_INFOS.items():\\n        exec(api_info['code'])\\n        setattr(cls,api_uri,eval(api_uri))\\n    \\n    return cls\\n\",\n            \"name_column\": 4\n        },\n        \"RapidAPIEnv\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"RapidAPIEnv\",\n            \"md_content\": \"\",\n            \"code_start_line\": 108,\n            \"code_end_line\": 135,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"class RapidAPIEnv(BaseEnv):\\n    \\\"\\\"\\\"RapidAPI Env delivers rapid api for tool server.\\\"\\\"\\\"\\n    \\n    def __init__(self,config:dict={}):\\n        super().__init__(config=config)\\n        \\n        self.rapidapi_cfg = self.config['rapidapi']\\n        self.api_key = self.rapidapi_cfg['api_key']\\n        self.endpoint = self.rapidapi_cfg['endpoint']\\n        \\n        self.api_infos = deepcopy(API_INFOS)\\n        \\n    async def _request_rapid_api(self,api_uri:str,arguments:dict={}):\\n        api_info = self.api_infos[api_uri]\\n        payload = {\\n            'category':api_info['category'],\\n            'tool_name':api_info['tool_name'],\\n            'api_name':api_info['api_name'],\\n            'tool_input':arguments,\\n            'strip':'truncate',\\n            'toolbench_key':self.api_key\\n        }\\n        async with httpx.AsyncClient() as client:\\n            response = await client.post(self.endpoint,json=payload,headers={'toolbench_key':self.api_key})\\n        \\n        response.raise_for_status()\\n        \\n        return response.json()\\n\",\n            \"name_column\": 6\n        },\n        \"__init__\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"__init__\",\n            \"md_content\": \"\",\n            \"code_start_line\": 111,\n            \"code_end_line\": 118,\n            \"parent\": \"RapidAPIEnv\",\n            \"have_return\": false,\n            \"code_content\": \"    def __init__(self,config:dict={}):\\n        super().__init__(config=config)\\n        \\n        self.rapidapi_cfg = self.config['rapidapi']\\n        self.api_key = self.rapidapi_cfg['api_key']\\n        self.endpoint = self.rapidapi_cfg['endpoint']\\n        \\n        self.api_infos = deepcopy(API_INFOS)\\n\",\n            \"name_column\": 8\n        },\n        \"_request_rapid_api\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"_request_rapid_api\",\n            \"md_content\": \"\",\n            \"code_start_line\": 120,\n            \"code_end_line\": 135,\n            \"parent\": \"RapidAPIEnv\",\n            \"have_return\": true,\n            \"code_content\": \"    async def _request_rapid_api(self,api_uri:str,arguments:dict={}):\\n        api_info = self.api_infos[api_uri]\\n        payload = {\\n            'category':api_info['category'],\\n            'tool_name':api_info['tool_name'],\\n            'api_name':api_info['api_name'],\\n            'tool_input':arguments,\\n            'strip':'truncate',\\n            'toolbench_key':self.api_key\\n        }\\n        async with httpx.AsyncClient() as client:\\n            response = await client.post(self.endpoint,json=payload,headers={'toolbench_key':self.api_key})\\n        \\n        response.raise_for_status()\\n        \\n        return response.json()\\n\",\n            \"name_column\": 14\n        }\n    },\n    \"tests/test_run.py\": {\n        \"mock_argv\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"mock_argv\",\n            \"md_content\": \"**mock_argv函数**：该函数的功能是模拟命令行参数。它将sys.argv设置为模拟命令行输入，以便进行测试。\\n\\n该函数使用了pytest的fixture装饰器，用于在测试中模拟命令行参数。它接受一个monkeypatch参数，用于修改sys.argv的值。在函数内部，首先定义了一个包含测试参数的列表test_args，其中包括了\\\"--task\\\", \\\"example_task\\\", \\\"--upload-files\\\", \\\"file1\\\", \\\"file2\\\", \\\"--model\\\", \\\"model1\\\"等参数。然后使用monkeypatch.setattr()方法将sys.argv设置为包含了'test_script.py'和test_args的列表，以模拟命令行输入。\\n\\n使用该函数可以方便地在测试中模拟命令行参数，以验证代码在不同参数下的行为。\\n\\n**注意**：在使用该函数时，需要注意以下几点：\\n- 需要安装pytest库，并使用pytest.fixture装饰器来使用该函数。\\n- 需要在测试代码中导入mock_argv函数，并将其作为参数传递给测试函数。\\n- 在测试函数中，可以直接使用模拟的命令行参数进行测试。\",\n            \"code_start_line\": 7,\n            \"code_end_line\": 13,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"def mock_argv(monkeypatch):\\n    \\\"\\\"\\\"\\n    A pytest fixture to mock the command line arguments.\\n    It sets the sys.argv to mimic command line input for testing.\\n    \\\"\\\"\\\"\\n    test_args = [\\\"--task\\\", \\\"example_task\\\", \\\"--upload-files\\\", \\\"file1\\\", \\\"file2\\\", \\\"--model\\\", \\\"model1\\\"]\\n    monkeypatch.setattr(sys, 'argv', ['test_script.py'] + test_args)\\n\",\n            \"name_column\": 4\n        },\n        \"test_parse_args\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"test_parse_args\",\n            \"md_content\": \"**test_parse_args函数**：该函数的功能是确保parse_args函数正确解析命令行参数。\\n\\n在这个函数中，首先调用parse_args函数获取命令行参数，并将结果保存在args变量中。然后，使用断言语句对args中的各个参数进行验证，确保它们的值与预期相符。\\n\\n具体来说，使用断言语句验证args.task的值是否为\\\"example_task\\\"，如果不相符则抛出异常并输出错误信息。接着，使用断言语句验证args.upload_files的值是否为[\\\"file1\\\", \\\"file2\\\"]，如果不相符则抛出异常并输出错误信息。最后，使用断言语句验证args.model的值是否为\\\"model1\\\"，如果不相符则抛出异常并输出错误信息。\\n\\n**注意**：使用该函数时需要注意以下几点：\\n- 确保在调用该函数之前，已经正确设置了命令行参数。\\n- 如果断言失败，将会抛出异常并输出错误信息，需要根据错误信息进行相应的调试和修复。\",\n            \"code_start_line\": 15,\n            \"code_end_line\": 22,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"def test_parse_args(mock_argv):\\n    \\\"\\\"\\\"\\n    Test to ensure that the parse_args function correctly parses command line arguments.\\n    \\\"\\\"\\\"\\n    args = parse_args()\\n    assert args.task == \\\"example_task\\\", \\\"Task argument did not match.\\\"\\n    assert args.upload_files == [\\\"file1\\\", \\\"file2\\\"], \\\"Upload files argument did not match.\\\"\\n    assert args.model == \\\"model1\\\", \\\"Model argument did not match.\\\"\\n\",\n            \"name_column\": 4\n        },\n        \"test_execute_command_line_process_quiet_mode\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"test_execute_command_line_process_quiet_mode\",\n            \"md_content\": \"**test_execute_command_line_process_quiet_mode函数**：该函数的功能是测试execute_command_line_process函数是否正确处理'quiet_mode'参数。\\n\\n该函数的代码逻辑如下：\\n1. 首先，通过调用parse_args函数获取命令行参数，并将结果赋值给args变量。\\n2. 然后，调用execute_command_line_process函数，并将args作为参数传入，同时设置quiet_mode为True。\\n3. 接下来，使用assert_called_once断言函数mock_start_command_line被调用了一次。\\n4. 最后，打印\\\"execute_command_line_process called start_command_line in quiet mode.\\\"。\\n\\n**注意**：关于代码使用的一些注意事项：\\n- 该函数主要用于测试execute_command_line_process函数在quiet_mode模式下的行为。\\n- 在测试中，使用了mock_start_command_line函数来模拟start_command_line函数的调用，以便进行断言。\\n- 通过设置quiet_mode为True，测试了execute_command_line_process函数在quiet_mode模式下的正确性。\",\n            \"code_start_line\": 25,\n            \"code_end_line\": 32,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"def test_execute_command_line_process_quiet_mode(mock_start_command_line, mock_argv):\\n    \\\"\\\"\\\"\\n    Test to verify if the execute_command_line_process function correctly handles the 'quiet_mode' argument.\\n    \\\"\\\"\\\"\\n    args = parse_args()\\n    execute_command_line_process(args, quiet_mode=True)\\n    mock_start_command_line.assert_called_once()\\n    print(\\\"execute_command_line_process called start_command_line in quiet mode.\\\")\\n\",\n            \"name_column\": 4\n        },\n        \"test_execute_command_line_process_normal_mode\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"test_execute_command_line_process_normal_mode\",\n            \"md_content\": \"**test_execute_command_line_process_normal_mode函数**: 这个函数的功能是测试execute_command_line_process函数在没有'quiet_mode'参数的情况下是否正确工作。\\n\\n这个函数的作用是测试execute_command_line_process函数在没有'quiet_mode'参数的情况下是否正确工作。首先，它调用parse_args函数来解析命令行参数，并将结果保存在args变量中。然后，它调用execute_command_line_process函数，并将args和quiet_mode=False作为参数传递进去。接下来，它使用mock_start_command_line.assert_called_once()来断言mock_start_command_line函数被调用了一次。最后，它打印出\\\"execute_command_line_process called start_command_line in normal mode.\\\"。\\n\\n**注意**: 关于代码使用的一些注意事项：\\n- 这个函数主要用于测试execute_command_line_process函数在没有'quiet_mode'参数的情况下的行为。\\n- 在调用execute_command_line_process函数之前，需要先调用parse_args函数来解析命令行参数。\\n- 断言mock_start_command_line函数被调用了一次，以确保execute_command_line_process函数正确地调用了start_command_line函数。\\n- 打印出\\\"execute_command_line_process called start_command_line in normal mode.\\\"，用于验证execute_command_line_process函数以正常模式调用了start_command_line函数。\",\n            \"code_start_line\": 35,\n            \"code_end_line\": 42,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"def test_execute_command_line_process_normal_mode(mock_start_command_line, mock_argv):\\n    \\\"\\\"\\\"\\n    Test to verify if the execute_command_line_process function behaves correctly without the 'quiet_mode' argument.\\n    \\\"\\\"\\\"\\n    args = parse_args()\\n    execute_command_line_process(args, quiet_mode=False)\\n    mock_start_command_line.assert_called_once()\\n    print(\\\"execute_command_line_process called start_command_line in normal mode.\\\")\\n\",\n            \"name_column\": 4\n        },\n        \"test_start_command_line\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"test_start_command_line\",\n            \"md_content\": \"**test_start_command_line函数**：该函数的功能是确保start_command_line函数根据解析的参数正确初始化CommandLine类，并使用预期的CommandLineParam实例。\\n\\n该函数首先解析参数args，然后调用start_command_line函数，并将args的变量作为参数传递给start_command_line函数。\\n\\n接下来，函数使用mock_command_line和mock_argv作为参数调用mock_command_line函数，并将返回值赋给called_args和_。\\n\\n然后，函数从called_args中获取第一个元素，并将其赋给called_param。\\n\\n最后，函数使用断言语句来检查called_param的task属性是否与args的task属性相匹配，以及upload_files属性和mode属性是否与args的upload_files属性和mode属性相匹配。如果断言失败，则会抛出异常。\\n\\n最后，函数打印一条消息，表示start_command_line函数被正确调用，并传递了正确的CommandLineParam参数。\\n\\n**注意**：关于代码使用的注意事项：\\n- 该函数依赖于parse_args函数和start_command_line函数的正确实现。\\n- 该函数使用了mock_command_line和mock_argv作为参数，这些参数可能需要根据具体情况进行修改。\\n- 该函数使用了断言语句来检查函数的输出是否符合预期，如果断言失败，则会抛出异常。\",\n            \"code_start_line\": 45,\n            \"code_end_line\": 58,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"def test_start_command_line(mock_command_line, mock_argv):\\n    \\\"\\\"\\\"\\n    Test to ensure the start_command_line function correctly initializes the CommandLine class\\n    with the expected CommandLineParam instance based on the parsed arguments.\\n    \\\"\\\"\\\"\\n    args = parse_args()\\n    start_command_line(vars(args))\\n\\n    called_args, _ = mock_command_line.call_args\\n    called_param = called_args[0]\\n    assert called_param.task == args.task, \\\"CommandLineParam task attribute did not match.\\\"\\n    assert called_param.upload_files == args.upload_files, \\\"CommandLineParam upload_files attribute did not match.\\\"\\n    assert called_param.mode == args.mode, \\\"CommandLineParam mode attribute did not match.\\\"\\n    print(\\\"start_command_line function called with correct CommandLineParam.\\\")\\n\",\n            \"name_column\": 4\n        }\n    },\n    \"tests/__init__.py\": {},\n    \"tests/test_1106_model_openai.py\": {\n        \"test_1106_model_openai\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"test_1106_model_openai\",\n            \"md_content\": \"**test_1106_model_openai函数**: 这个函数的功能是测试1106模型的OpenAI。\\n\\n在这个函数中，首先会检查openai_version的值是否大于等于\\\"1.0.0\\\"。如果是，则会进行OpenAI客户端和响应的模拟。使用mock.patch方法来模拟OpenAI客户端，并返回模拟的客户端和响应。然后，模拟响应的model_dump()方法，将其返回值设置为一个包含一个字典的字典，其中choices列表中包含一个字典，字典中包含了\\\"finish_reason\\\"、\\\"index\\\"和\\\"message\\\"等键值对。接下来，调用chatcompletion_request函数，传入model和prompt参数，获取响应结果。最后，使用assert语句来断言响应结果是否符合预期。\\n\\n如果openai_version的值小于\\\"1.0.0\\\"，则会使用mock.patch方法来模拟ChatCompletion类，并返回模拟的响应数据。然后，调用chatcompletion_request函数，传入model和prompt参数，获取响应结果。最后，使用assert语句来断言响应结果是否符合预期。\\n\\n最后，打印出openai_version的值和测试成功的提示信息。\\n\\n**注意**: \\n- 在测试过程中，使用了mock.patch方法来模拟OpenAI客户端和响应，以及ChatCompletion类和响应数据，以确保测试的独立性和可靠性。\\n- 在测试过程中，使用了assert语句来断言响应结果是否符合预期，以确保测试的准确性。\\n\\n**输出示例**:\\nYour OpenAI version is 1.0.0, Successful test\",\n            \"code_start_line\": 8,\n            \"code_end_line\": 48,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"def test_1106_model_openai():\\n    if openai_version >= \\\"1.0.0\\\":\\n        # Mock the OpenAI client and response\\n        with mock.patch(\\\"openai.OpenAI\\\") as mock_openai:\\n            mock_client = mock_openai.return_value\\n            mock_response = mock_client.chat.completions.create.return_value\\n\\n            # Mock the model_dump() method\\n            mock_model_dump = mock_response.model_dump\\n            mock_model_dump.return_value = {\\n                \\\"choices\\\": [\\n                    {\\n                        \\\"finish_reason\\\": \\\"stop\\\",\\n                        \\\"index\\\": 0,\\n                        \\\"message\\\": {\\\"content\\\": \\\"Hello, World!\\\"},\\n                    }\\n                ]\\n            }\\n\\n            # Call the function\\n            response = chatcompletion_request(\\n                model=\\\"gpt-4-1106-preview\\\", prompt=\\\"Hello, world\\\"\\n            )\\n\\n            # Assert that the response is as expected\\n            assert response[\\\"choices\\\"][0][\\\"finish_reason\\\"] == \\\"stop\\\"\\n            assert response[\\\"choices\\\"][0][\\\"index\\\"] == 0\\n            assert response[\\\"choices\\\"][0][\\\"message\\\"][\\\"content\\\"] == \\\"Hello, World!\\\"\\n\\n    else:\\n        with mock.patch(\\\"openai.ChatCompletion\\\") as mock_create:\\n            mock_response_data = \\\"\\\"\\\"{\\\"choices\\\": [{\\\"finish_reason\\\": \\\"stop\\\", \\\"index\\\": 0, \\\"message\\\": {\\\"content\\\": \\\"Hello, World!\\\"}}]}\\\"\\\"\\\"\\n\\n            mock_create.create.return_value = mock_response_data\\n\\n            response = chatcompletion_request(\\n                model=\\\"gpt-4-1106-preview\\\", prompt=\\\"Hello, world\\\"\\n            )\\n            assert response[\\\"choices\\\"][0][\\\"message\\\"][\\\"content\\\"] == \\\"Hello, World!\\\"\\n\\n    print(f\\\"Your OpenAI version is {openai_version}, Successful test\\\")\\n\",\n            \"name_column\": 4\n        }\n    },\n    \"tests/test_model_alias.py\": {\n        \"test_model_alias\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"test_model_alias\",\n            \"md_content\": \"**test_model_alias函数**：该函数的功能是进行模型别名测试。\\n\\n该函数首先判断openai_version是否大于等于\\\"1.0.0\\\"，如果是，则进入第一个分支。在该分支中，使用mock.patch函数模拟OpenAI客户端和响应。然后，通过mock_response.model_dump.return_value模拟model_dump()方法的返回值，该返回值是一个包含一个字典的字典，其中包含一个choices列表，列表中包含一个字典，字典中包含了finish_reason、index和message等字段。接下来，调用chatcompletion_request函数，并传入model和prompt参数，将返回值赋给response变量。最后，使用assert语句对response进行断言，确保其与预期结果一致。\\n\\n如果openai_version小于\\\"1.0.0\\\"，则进入第二个分支。在该分支中，同样使用mock.patch函数模拟ChatCompletion类的实例化，并通过mock_response_data模拟create方法的返回值。然后，调用chatcompletion_request函数，并传入model和prompt参数，将返回值赋给response变量。最后，使用assert语句对response进行断言，确保其与预期结果一致。\\n\\n最后，打印出openai_version的值以及测试成功的提示信息。\\n\\n**注意**：在使用该函数时需要注意以下几点：\\n- 需要安装mock库来模拟OpenAI客户端和响应。\\n- 需要确保openai_version的值与预期一致，以便进入正确的分支。\\n\\n**输出示例**：模拟代码返回值的可能外观。\\n```\\nYour OpenAI version is 1.0.0, Successful test\\n```\",\n            \"code_start_line\": 8,\n            \"code_end_line\": 48,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"def test_model_alias():\\n    if openai_version >= \\\"1.0.0\\\":\\n        # Mock the OpenAI client and response\\n        with mock.patch(\\\"openai.OpenAI\\\") as mock_openai:\\n            mock_client = mock_openai.return_value\\n            mock_response = mock_client.chat.completions.create.return_value\\n\\n            # Mock the model_dump() method\\n            mock_model_dump = mock_response.model_dump\\n            mock_model_dump.return_value = {\\n                \\\"choices\\\": [\\n                    {\\n                        \\\"finish_reason\\\": \\\"stop\\\",\\n                        \\\"index\\\": 0,\\n                        \\\"message\\\": {\\\"content\\\": \\\"Hello, World!\\\"},\\n                    }\\n                ]\\n            }\\n\\n            # Call the function\\n            response = chatcompletion_request(\\n                model=\\\"gpt-4-turbo\\\", prompt=\\\"Hello, world\\\"\\n            )\\n\\n            # Assert that the response is as expected\\n            assert response[\\\"choices\\\"][0][\\\"finish_reason\\\"] == \\\"stop\\\"\\n            assert response[\\\"choices\\\"][0][\\\"index\\\"] == 0\\n            assert response[\\\"choices\\\"][0][\\\"message\\\"][\\\"content\\\"] == \\\"Hello, World!\\\"\\n\\n    else:\\n        with mock.patch(\\\"openai.ChatCompletion\\\") as mock_create:\\n            mock_response_data = \\\"\\\"\\\"{\\\"choices\\\": [{\\\"finish_reason\\\": \\\"stop\\\", \\\"index\\\": 0, \\\"message\\\": {\\\"content\\\": \\\"Hello, World!\\\"}}]}\\\"\\\"\\\"\\n\\n            mock_create.create.return_value = mock_response_data\\n\\n            response = chatcompletion_request(\\n                model=\\\"gpt-4-turbo\\\", prompt=\\\"Hello, world\\\"\\n            )\\n            assert response[\\\"choices\\\"][0][\\\"message\\\"][\\\"content\\\"] == \\\"Hello, World!\\\"\\n\\n    print(f\\\"Your OpenAI version is {openai_version}, Successful test\\\")\\n\",\n            \"name_column\": 4\n        }\n    },\n    \"XAgentServer/server.py\": {\n        \"XAgentServer\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"XAgentServer\",\n            \"md_content\": \"\",\n            \"code_start_line\": 20,\n            \"code_end_line\": 109,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"class XAgentServer:\\n    \\\"\\\"\\\"XAgent Server Start Class\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, logger: Logger) -> None:\\n        self.logger: Logger = logger\\n\\n    def interact(self, interaction: XAgentInteraction):\\n        # query = message\\n        \\\"\\\"\\\"\\n        XAgent Server Start Function\\n        \\\"\\\"\\\"\\n        from XAgent.config import CONFIG as config\\n        xagent_core = None\\n        try:\\n            config.reload()\\n            args = {}\\n            # args\\n            args = interaction.parameter.args\\n\\n            self.logger.info(\\n                f\\\"server is running, the start query is {args.get('goal', '')}\\\")\\n            xagent_param = XAgentParam()\\n\\n            # build query\\n            xagent_param.build_query({\\n                \\\"role_name\\\": \\\"Assistant\\\",\\n                \\\"task\\\": args.get(\\\"goal\\\", \\\"\\\"),\\n                \\\"plan\\\": args.get(\\\"plan\\\", [\\\"Pay attention to the language in initial goal, always answer with the same language of the initial goal given.\\\"]),\\n            })\\n            xagent_param.build_config(config)\\n            xagent_core = XAgentCoreComponents()\\n            # build XAgent Core Components\\n            xagent_core.build(xagent_param, interaction=interaction)\\n            json_str = json.dumps(\\n                xagent_param.config.to_dict(), indent=2)\\n            json_str=re.sub(r'\\\"api_key\\\": \\\"(.+?)\\\"', r'\\\"api_key\\\": \\\"**\\\"', json_str)\\n            self.logger.info(json_str)\\n            self.logger.typewriter_log(\\n                \\\"Human-In-The-Loop\\\",\\n                Fore.RED,\\n                str(xagent_param.config.enable_ask_human_for_help),\\n            )\\n\\n            file_list = interaction.base.file_list\\n            for file in file_list:\\n                file_uuid = file.get(\\\"uuid\\\", \\\"\\\")\\n                file_name = file.get(\\\"name\\\", \\\"\\\")\\n                if file_uuid.startswith(\\\"/\\\"):\\n                    file_path = file_uuid\\n                else:\\n                    file_path = os.path.join(XAgentServerEnv.Upload.upload_dir,\\n                                         interaction.base.user_id, file_uuid)\\n\\n                upload_dir = os.path.join(\\n                    xagent_core.base_dir, \\\"upload\\\")\\n                if not os.path.exists(upload_dir):\\n                    os.makedirs(upload_dir)\\n                # 拷贝到workspace\\n                if interaction.call_method == \\\"web\\\":\\n                    shutil.copy(file_path, os.path.join(upload_dir, file_name))\\n                else:\\n                    if os.path.exists(file_path):\\n                        if os.path.samefile(file_path, os.path.join(upload_dir, file_name)):\\n                            # 文件路径相同,跳过复制\\n                            pass\\n                        else:\\n                            shutil.copy(file_path, os.path.join(upload_dir, file_name))\\n                        # shutil.copy(file_path, os.path.join(upload_dir, file_name))\\n\\n                new_file = os.path.join(upload_dir, file_name)\\n                try:\\n                    xagent_core.toolserver_interface.upload_file(new_file)\\n                except Exception as e:\\n                    self.logger.typewriter_log(\\n                        \\\"Error happens when uploading file\\\",\\n                        Fore.RED,\\n                        f\\\"{new_file}\\\\n{e}\\\",\\n                    )\\n                    raise XAgentUploadFileError(str(e)) from e\\n\\n            task_handler = TaskHandler(xagent_core=xagent_core,\\n                                       xagent_param=xagent_param)\\n            self.logger.info(\\\"Start outer loop async\\\")\\n            task_handler.outer_loop()\\n        except Exception as e:\\n            raise XAgentRunningError(str(e)) from e\\n        finally:\\n            if xagent_core is not None:\\n                xagent_core.close()\\n\",\n            \"name_column\": 6\n        },\n        \"__init__\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"__init__\",\n            \"md_content\": \"\",\n            \"code_start_line\": 24,\n            \"code_end_line\": 25,\n            \"parent\": \"XAgentServer\",\n            \"have_return\": false,\n            \"code_content\": \"    def __init__(self, logger: Logger) -> None:\\n        self.logger: Logger = logger\\n\",\n            \"name_column\": 8\n        },\n        \"interact\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"interact\",\n            \"md_content\": \"\",\n            \"code_start_line\": 27,\n            \"code_end_line\": 109,\n            \"parent\": \"XAgentServer\",\n            \"have_return\": false,\n            \"code_content\": \"    def interact(self, interaction: XAgentInteraction):\\n        # query = message\\n        \\\"\\\"\\\"\\n        XAgent Server Start Function\\n        \\\"\\\"\\\"\\n        from XAgent.config import CONFIG as config\\n        xagent_core = None\\n        try:\\n            config.reload()\\n            args = {}\\n            # args\\n            args = interaction.parameter.args\\n\\n            self.logger.info(\\n                f\\\"server is running, the start query is {args.get('goal', '')}\\\")\\n            xagent_param = XAgentParam()\\n\\n            # build query\\n            xagent_param.build_query({\\n                \\\"role_name\\\": \\\"Assistant\\\",\\n                \\\"task\\\": args.get(\\\"goal\\\", \\\"\\\"),\\n                \\\"plan\\\": args.get(\\\"plan\\\", [\\\"Pay attention to the language in initial goal, always answer with the same language of the initial goal given.\\\"]),\\n            })\\n            xagent_param.build_config(config)\\n            xagent_core = XAgentCoreComponents()\\n            # build XAgent Core Components\\n            xagent_core.build(xagent_param, interaction=interaction)\\n            json_str = json.dumps(\\n                xagent_param.config.to_dict(), indent=2)\\n            json_str=re.sub(r'\\\"api_key\\\": \\\"(.+?)\\\"', r'\\\"api_key\\\": \\\"**\\\"', json_str)\\n            self.logger.info(json_str)\\n            self.logger.typewriter_log(\\n                \\\"Human-In-The-Loop\\\",\\n                Fore.RED,\\n                str(xagent_param.config.enable_ask_human_for_help),\\n            )\\n\\n            file_list = interaction.base.file_list\\n            for file in file_list:\\n                file_uuid = file.get(\\\"uuid\\\", \\\"\\\")\\n                file_name = file.get(\\\"name\\\", \\\"\\\")\\n                if file_uuid.startswith(\\\"/\\\"):\\n                    file_path = file_uuid\\n                else:\\n                    file_path = os.path.join(XAgentServerEnv.Upload.upload_dir,\\n                                         interaction.base.user_id, file_uuid)\\n\\n                upload_dir = os.path.join(\\n                    xagent_core.base_dir, \\\"upload\\\")\\n                if not os.path.exists(upload_dir):\\n                    os.makedirs(upload_dir)\\n                # 拷贝到workspace\\n                if interaction.call_method == \\\"web\\\":\\n                    shutil.copy(file_path, os.path.join(upload_dir, file_name))\\n                else:\\n                    if os.path.exists(file_path):\\n                        if os.path.samefile(file_path, os.path.join(upload_dir, file_name)):\\n                            # 文件路径相同,跳过复制\\n                            pass\\n                        else:\\n                            shutil.copy(file_path, os.path.join(upload_dir, file_name))\\n                        # shutil.copy(file_path, os.path.join(upload_dir, file_name))\\n\\n                new_file = os.path.join(upload_dir, file_name)\\n                try:\\n                    xagent_core.toolserver_interface.upload_file(new_file)\\n                except Exception as e:\\n                    self.logger.typewriter_log(\\n                        \\\"Error happens when uploading file\\\",\\n                        Fore.RED,\\n                        f\\\"{new_file}\\\\n{e}\\\",\\n                    )\\n                    raise XAgentUploadFileError(str(e)) from e\\n\\n            task_handler = TaskHandler(xagent_core=xagent_core,\\n                                       xagent_param=xagent_param)\\n            self.logger.info(\\\"Start outer loop async\\\")\\n            task_handler.outer_loop()\\n        except Exception as e:\\n            raise XAgentRunningError(str(e)) from e\\n        finally:\\n            if xagent_core is not None:\\n                xagent_core.close()\\n\",\n            \"name_column\": 8\n        }\n    },\n    \"XAgentServer/interaction.py\": {\n        \"XAgentInteraction\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"XAgentInteraction\",\n            \"md_content\": \"\",\n            \"code_start_line\": 27,\n            \"code_end_line\": 302,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"class XAgentInteraction(metaclass=abc.ABCMeta):\\n    \\\"\\\"\\\"\\n    XAgent 核心交互组件集, 引用: XAgentCE\\n    Attributes:\\n        base: 交互基本信息\\n        parameter: 交互参数\\n        interrupt: 是否包含中断\\n        toolserver: 工具服务\\n        call_method: 调用方式\\n        wait_seconds: 等待时间\\n        \\n    Components:\\n        logger: 日志\\n        db: 数据库\\n        recorder: 运行记录\\n        toolserver_interface: 工具服务接口\\n        \\n    组件集中的所有组件全局唯一\\n\\n    \\\"\\\"\\\"\\n\\n    def __init__(\\n        self,\\n        base: InteractionBase,\\n        parameter: InteractionParameter,\\n        interrupt: bool = False,\\n        call_method: str = \\\"web\\\",\\n        wait_seconds: int = 600,\\n    ) -> None:\\n        self.base = base\\n        self.parameter = parameter\\n        # 唯一标识当前的执行步骤\\n        self.current_step = uuid.uuid4().hex\\n        self.logger = None\\n        self.interrupt = interrupt\\n        self.call_method = call_method\\n        self.wait_seconds = wait_seconds\\n        self.log_dir = os.path.join(\\n            os.path.join(XAgentServerEnv.base_dir,\\n                         \\\"localstorage\\\",\\n                         \\\"interact_records\\\"),\\n            datetime.now().strftime(\\\"%Y-%m-%d\\\"),\\n            self.base.interaction_id)\\n        self.human_data = None\\n        if not os.path.exists(self.log_dir):\\n            os.makedirs(self.log_dir)\\n\\n        self.extract_dir = os.path.join(self.log_dir, \\\"workspace\\\")\\n        if not os.path.exists(self.extract_dir):\\n            os.makedirs(self.extract_dir)\\n\\n        self.db: Session = None\\n        self.toolserver_interface = None\\n\\n    def register_toolserver_interface(self, toolserver_interface: ToolServerInterface):\\n        \\\"\\\"\\\"register tool server interface\\\"\\\"\\\"\\n        self.toolserver_interface = toolserver_interface\\n\\n    def resister_logger(self, logger: Logger):\\n        \\\"\\\"\\\"\\n        注册logger, 根据会话id创建日志文件夹, 并创建日志文件\\n        \\\"\\\"\\\"\\n\\n        self.logger = logger\\n        self.logger.info(f\\\"init interaction: {self.base.interaction_id}\\\")\\n\\n    def register_db(self, db: Session):\\n        \\\"\\\"\\\"\\n        注册db\\n\\n        Args:\\n            db: Session对象\\n        \\\"\\\"\\\"\\n        self.db = db\\n\\n    def insert_data(self,\\n                    data: dict,\\n                    status=\\\"\\\",\\n                    current: str = None,\\n                    is_include_pictures: bool = False,):\\n        \\\"\\\"\\\"\\n        更新缓存, 推送数据\\n        \\\"\\\"\\\"\\n        # check alive\\n        alive = redis.get_key(self.base.interaction_id)\\n        if alive == \\\"close\\\":\\n            self.logger.info(\\\"The user terminated this action and exited.\\\")\\n            exit(0)\\n        self.current_step = uuid.uuid4().hex\\n\\n        if status == \\\"inner\\\":\\n            tool_name = data.get(\\\"using_tools\\\", {}).get(\\n                \\\"tool_name\\\", \\\"\\\") if isinstance(data, dict) else \\\"\\\"\\n\\n            if tool_name == \\\"subtask_submit\\\":\\n                status = StatusEnum.SUBMIT\\n\\n        # download workspace files\\n        self.download_files()\\n\\n        file_list = os.listdir(self.extract_dir)\\n\\n        # insert raw\\n        process = XAgentRaw(\\n            node_id=self.current_step,\\n            interaction_id=self.base.interaction_id,\\n            current=current,\\n            step=0,\\n            data=data,\\n            file_list=file_list,\\n            status=status,\\n            do_interrupt=self.interrupt,\\n            wait_seconds=0,\\n            ask_for_human_help=False,\\n            create_time=datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\"),\\n            update_time=datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\"),\\n            is_deleted=False,\\n            is_human=False,\\n            human_data=None,\\n            human_file_list=[],\\n            is_send=self.call_method != 'web',\\n            is_receive=False,\\n            include_pictures=is_include_pictures,\\n        )\\n        if status == StatusEnum.FINISHED:\\n            InteractionCRUD.update_interaction_status(\\n                db=self.db,\\n                interaction_id=self.base.interaction_id,\\n                status=StatusEnum.FINISHED,\\n                message=\\\"finished\\\",\\n                current_step=self.current_step)\\n        else:\\n            InteractionCRUD.update_interaction_status(\\n                db=self.db,\\n                interaction_id=self.base.interaction_id,\\n                status=\\\"running\\\",\\n                message=\\\"running\\\",\\n                current_step=self.current_step)\\n        InteractionCRUD.insert_raw(db=self.db, process=process)\\n        if self.call_method == \\\"web\\\":\\n            redis.set_key(self.base.interaction_id + \\\"_send\\\", 1)\\n        elif self.call_method == \\\"cmd\\\":\\n            # print workspace file list\\n            file_list_str = \\\", \\\".join(file_list) \\n            self.logger.typewriter_log(\\n                title=f\\\"-=-=-=-=-=-=-= {self.base.interaction_id}, {self.current_step}, WORKSPACE FILE LIST -=-=-=-=-=-=-=\\\\n\\\",\\n                title_color=Fore.GREEN,\\n                content=f\\\"[{file_list_str}] in {self.extract_dir}\\\"\\n            )\\n\\n    def download_files(self):\\n        \\\"\\\"\\\"download files\\n\\n        Returns:\\n            Boolean: True or False\\n        \\\"\\\"\\\"\\n        try:\\n            save_path = self.toolserver_interface.download_all_files()\\n\\n            if os.path.exists(save_path):\\n                zip_file = zipfile.ZipFile(save_path)\\n                zip_list = zip_file.namelist()  # 得到压缩包里所有文件\\n                for f in zip_list:\\n                    zip_file.extract(f, self.extract_dir)  # 循环解压文件到指定目录\\n\\n                zip_file.close()\\n            return True\\n        except zipfile.BadZipFile:\\n            return False\\n\\n    def receive(self, can_modify=None):\\n        \\\"\\\"\\\"\\n        接收数据\\n        \\\"\\\"\\\"\\n\\n        if self.call_method == \\\"web\\\":\\n            wait = 0\\n            while wait < self.wait_seconds:\\n                human_data = self.get_human_data()\\n                if human_data is not None:\\n                    return human_data\\n                else:\\n                    wait += 2\\n                    time.sleep(2)\\n\\n            raise XAgentTimeoutError(\\\"等待数据超时，关闭连接\\\")\\n        else:\\n            print(can_modify)\\n\\n    def get_human_data(self):\\n        \\\"\\\"\\\"\\n        获取人类数据\\n        \\\"\\\"\\\"\\n        # check alive, ensure the interaction is alive\\n        # if The user terminated this action and exited\\n        alive = redis.get_key(self.base.interaction_id)\\n        if alive == \\\"close\\\":\\n            self.logger.info(\\\"The user terminated this action and exited!\\\")\\n            exit(0)\\n        receive_key = self.base.interaction_id + \\\"_\\\" + self.current_step + \\\"_receive\\\"\\n        is_receive = redis.get_key(receive_key)\\n\\n        if is_receive:\\n            raw = InteractionCRUD.get_raw(\\n                db=self.db, interaction_id=self.base.interaction_id, node_id=self.current_step)\\n\\n            if raw and raw.is_human and raw.is_receive:\\n                redis.delete_key(receive_key)\\n                return raw.human_data\\n\\n        return None\\n\\n    def ask_for_human_help(self, data):\\n        \\\"\\\"\\\"调用工具时，请求人类帮助\\n        Execute the tool and ask for human help\\n        \\\"\\\"\\\"\\n\\n        self.current_step = uuid.uuid4().hex\\n        self.download_files()\\n        file_list = os.listdir(self.extract_dir)\\n        # special: ask for human help and do interrupt\\n        # send data\\n        process = XAgentRaw(\\n            node_id=self.current_step,\\n            interaction_id=self.base.interaction_id,\\n            current=self.current_step,\\n            step=0,\\n            data=data,\\n            file_list=file_list,\\n            status=StatusEnum.ASK_FOR_HUMAN_HELP,\\n            do_interrupt=True,\\n            wait_seconds=0,\\n            ask_for_human_help=True,\\n            create_time=datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\"),\\n            update_time=datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\"),\\n            is_deleted=False,\\n            is_human=False,\\n            human_data=None,\\n            human_file_list=[],\\n            is_send=False,\\n            is_receive=False,\\n            include_pictures=False,\\n        )\\n\\n        # insert into mysql\\n        InteractionCRUD.insert_raw(db=self.db, process=process)\\n\\n        # set redis\\n        redis.set_key(self.base.interaction_id + \\\"_send\\\", 1)\\n\\n        # set status\\n\\n        InteractionCRUD.update_interaction_status(\\n            db=self.db,\\n            interaction_id=self.base.interaction_id,\\n            status=StatusEnum.ASK_FOR_HUMAN_HELP,\\n            message=\\\"ask for human help\\\",\\n            current_step=self.current_step)\\n\\n        # check alive\\n        alive = redis.get_key(self.base.interaction_id)\\n        if alive == \\\"close\\\":\\n            self.logger.info(\\\"The user terminated this action and exited!\\\")\\n            exit(0)\\n\\n        # wait for human data\\n        wait = 0\\n        while wait < self.wait_seconds:\\n            human_data = self.get_human_data()\\n            if human_data is not None:\\n                return human_data\\n            else:\\n                wait += 2\\n                time.sleep(2)\\n\\n        raise XAgentTimeoutError(\\\"ASK-For-Human-Data: 等待数据超时，关闭连接\\\")\\n\",\n            \"name_column\": 6\n        },\n        \"__init__\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"__init__\",\n            \"md_content\": \"\",\n            \"code_start_line\": 48,\n            \"code_end_line\": 79,\n            \"parent\": \"XAgentInteraction\",\n            \"have_return\": false,\n            \"code_content\": \"    def __init__(\\n        self,\\n        base: InteractionBase,\\n        parameter: InteractionParameter,\\n        interrupt: bool = False,\\n        call_method: str = \\\"web\\\",\\n        wait_seconds: int = 600,\\n    ) -> None:\\n        self.base = base\\n        self.parameter = parameter\\n        # 唯一标识当前的执行步骤\\n        self.current_step = uuid.uuid4().hex\\n        self.logger = None\\n        self.interrupt = interrupt\\n        self.call_method = call_method\\n        self.wait_seconds = wait_seconds\\n        self.log_dir = os.path.join(\\n            os.path.join(XAgentServerEnv.base_dir,\\n                         \\\"localstorage\\\",\\n                         \\\"interact_records\\\"),\\n            datetime.now().strftime(\\\"%Y-%m-%d\\\"),\\n            self.base.interaction_id)\\n        self.human_data = None\\n        if not os.path.exists(self.log_dir):\\n            os.makedirs(self.log_dir)\\n\\n        self.extract_dir = os.path.join(self.log_dir, \\\"workspace\\\")\\n        if not os.path.exists(self.extract_dir):\\n            os.makedirs(self.extract_dir)\\n\\n        self.db: Session = None\\n        self.toolserver_interface = None\\n\",\n            \"name_column\": 8\n        },\n        \"register_toolserver_interface\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"register_toolserver_interface\",\n            \"md_content\": \"\",\n            \"code_start_line\": 81,\n            \"code_end_line\": 83,\n            \"parent\": \"XAgentInteraction\",\n            \"have_return\": false,\n            \"code_content\": \"    def register_toolserver_interface(self, toolserver_interface: ToolServerInterface):\\n        \\\"\\\"\\\"register tool server interface\\\"\\\"\\\"\\n        self.toolserver_interface = toolserver_interface\\n\",\n            \"name_column\": 8\n        },\n        \"resister_logger\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"resister_logger\",\n            \"md_content\": \"\",\n            \"code_start_line\": 85,\n            \"code_end_line\": 91,\n            \"parent\": \"XAgentInteraction\",\n            \"have_return\": false,\n            \"code_content\": \"    def resister_logger(self, logger: Logger):\\n        \\\"\\\"\\\"\\n        注册logger, 根据会话id创建日志文件夹, 并创建日志文件\\n        \\\"\\\"\\\"\\n\\n        self.logger = logger\\n        self.logger.info(f\\\"init interaction: {self.base.interaction_id}\\\")\\n\",\n            \"name_column\": 8\n        },\n        \"register_db\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"register_db\",\n            \"md_content\": \"\",\n            \"code_start_line\": 93,\n            \"code_end_line\": 100,\n            \"parent\": \"XAgentInteraction\",\n            \"have_return\": false,\n            \"code_content\": \"    def register_db(self, db: Session):\\n        \\\"\\\"\\\"\\n        注册db\\n\\n        Args:\\n            db: Session对象\\n        \\\"\\\"\\\"\\n        self.db = db\\n\",\n            \"name_column\": 8\n        },\n        \"insert_data\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"insert_data\",\n            \"md_content\": \"\",\n            \"code_start_line\": 102,\n            \"code_end_line\": 175,\n            \"parent\": \"XAgentInteraction\",\n            \"have_return\": false,\n            \"code_content\": \"    def insert_data(self,\\n                    data: dict,\\n                    status=\\\"\\\",\\n                    current: str = None,\\n                    is_include_pictures: bool = False,):\\n        \\\"\\\"\\\"\\n        更新缓存, 推送数据\\n        \\\"\\\"\\\"\\n        # check alive\\n        alive = redis.get_key(self.base.interaction_id)\\n        if alive == \\\"close\\\":\\n            self.logger.info(\\\"The user terminated this action and exited.\\\")\\n            exit(0)\\n        self.current_step = uuid.uuid4().hex\\n\\n        if status == \\\"inner\\\":\\n            tool_name = data.get(\\\"using_tools\\\", {}).get(\\n                \\\"tool_name\\\", \\\"\\\") if isinstance(data, dict) else \\\"\\\"\\n\\n            if tool_name == \\\"subtask_submit\\\":\\n                status = StatusEnum.SUBMIT\\n\\n        # download workspace files\\n        self.download_files()\\n\\n        file_list = os.listdir(self.extract_dir)\\n\\n        # insert raw\\n        process = XAgentRaw(\\n            node_id=self.current_step,\\n            interaction_id=self.base.interaction_id,\\n            current=current,\\n            step=0,\\n            data=data,\\n            file_list=file_list,\\n            status=status,\\n            do_interrupt=self.interrupt,\\n            wait_seconds=0,\\n            ask_for_human_help=False,\\n            create_time=datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\"),\\n            update_time=datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\"),\\n            is_deleted=False,\\n            is_human=False,\\n            human_data=None,\\n            human_file_list=[],\\n            is_send=self.call_method != 'web',\\n            is_receive=False,\\n            include_pictures=is_include_pictures,\\n        )\\n        if status == StatusEnum.FINISHED:\\n            InteractionCRUD.update_interaction_status(\\n                db=self.db,\\n                interaction_id=self.base.interaction_id,\\n                status=StatusEnum.FINISHED,\\n                message=\\\"finished\\\",\\n                current_step=self.current_step)\\n        else:\\n            InteractionCRUD.update_interaction_status(\\n                db=self.db,\\n                interaction_id=self.base.interaction_id,\\n                status=\\\"running\\\",\\n                message=\\\"running\\\",\\n                current_step=self.current_step)\\n        InteractionCRUD.insert_raw(db=self.db, process=process)\\n        if self.call_method == \\\"web\\\":\\n            redis.set_key(self.base.interaction_id + \\\"_send\\\", 1)\\n        elif self.call_method == \\\"cmd\\\":\\n            # print workspace file list\\n            file_list_str = \\\", \\\".join(file_list) \\n            self.logger.typewriter_log(\\n                title=f\\\"-=-=-=-=-=-=-= {self.base.interaction_id}, {self.current_step}, WORKSPACE FILE LIST -=-=-=-=-=-=-=\\\\n\\\",\\n                title_color=Fore.GREEN,\\n                content=f\\\"[{file_list_str}] in {self.extract_dir}\\\"\\n            )\\n\",\n            \"name_column\": 8\n        },\n        \"download_files\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"download_files\",\n            \"md_content\": \"\",\n            \"code_start_line\": 177,\n            \"code_end_line\": 195,\n            \"parent\": \"XAgentInteraction\",\n            \"have_return\": true,\n            \"code_content\": \"    def download_files(self):\\n        \\\"\\\"\\\"download files\\n\\n        Returns:\\n            Boolean: True or False\\n        \\\"\\\"\\\"\\n        try:\\n            save_path = self.toolserver_interface.download_all_files()\\n\\n            if os.path.exists(save_path):\\n                zip_file = zipfile.ZipFile(save_path)\\n                zip_list = zip_file.namelist()  # 得到压缩包里所有文件\\n                for f in zip_list:\\n                    zip_file.extract(f, self.extract_dir)  # 循环解压文件到指定目录\\n\\n                zip_file.close()\\n            return True\\n        except zipfile.BadZipFile:\\n            return False\\n\",\n            \"name_column\": 8\n        },\n        \"receive\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"receive\",\n            \"md_content\": \"\",\n            \"code_start_line\": 197,\n            \"code_end_line\": 214,\n            \"parent\": \"XAgentInteraction\",\n            \"have_return\": true,\n            \"code_content\": \"    def receive(self, can_modify=None):\\n        \\\"\\\"\\\"\\n        接收数据\\n        \\\"\\\"\\\"\\n\\n        if self.call_method == \\\"web\\\":\\n            wait = 0\\n            while wait < self.wait_seconds:\\n                human_data = self.get_human_data()\\n                if human_data is not None:\\n                    return human_data\\n                else:\\n                    wait += 2\\n                    time.sleep(2)\\n\\n            raise XAgentTimeoutError(\\\"等待数据超时，关闭连接\\\")\\n        else:\\n            print(can_modify)\\n\",\n            \"name_column\": 8\n        },\n        \"get_human_data\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"get_human_data\",\n            \"md_content\": \"\",\n            \"code_start_line\": 216,\n            \"code_end_line\": 237,\n            \"parent\": \"XAgentInteraction\",\n            \"have_return\": true,\n            \"code_content\": \"    def get_human_data(self):\\n        \\\"\\\"\\\"\\n        获取人类数据\\n        \\\"\\\"\\\"\\n        # check alive, ensure the interaction is alive\\n        # if The user terminated this action and exited\\n        alive = redis.get_key(self.base.interaction_id)\\n        if alive == \\\"close\\\":\\n            self.logger.info(\\\"The user terminated this action and exited!\\\")\\n            exit(0)\\n        receive_key = self.base.interaction_id + \\\"_\\\" + self.current_step + \\\"_receive\\\"\\n        is_receive = redis.get_key(receive_key)\\n\\n        if is_receive:\\n            raw = InteractionCRUD.get_raw(\\n                db=self.db, interaction_id=self.base.interaction_id, node_id=self.current_step)\\n\\n            if raw and raw.is_human and raw.is_receive:\\n                redis.delete_key(receive_key)\\n                return raw.human_data\\n\\n        return None\\n\",\n            \"name_column\": 8\n        },\n        \"ask_for_human_help\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"ask_for_human_help\",\n            \"md_content\": \"\",\n            \"code_start_line\": 239,\n            \"code_end_line\": 302,\n            \"parent\": \"XAgentInteraction\",\n            \"have_return\": true,\n            \"code_content\": \"    def ask_for_human_help(self, data):\\n        \\\"\\\"\\\"调用工具时，请求人类帮助\\n        Execute the tool and ask for human help\\n        \\\"\\\"\\\"\\n\\n        self.current_step = uuid.uuid4().hex\\n        self.download_files()\\n        file_list = os.listdir(self.extract_dir)\\n        # special: ask for human help and do interrupt\\n        # send data\\n        process = XAgentRaw(\\n            node_id=self.current_step,\\n            interaction_id=self.base.interaction_id,\\n            current=self.current_step,\\n            step=0,\\n            data=data,\\n            file_list=file_list,\\n            status=StatusEnum.ASK_FOR_HUMAN_HELP,\\n            do_interrupt=True,\\n            wait_seconds=0,\\n            ask_for_human_help=True,\\n            create_time=datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\"),\\n            update_time=datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\"),\\n            is_deleted=False,\\n            is_human=False,\\n            human_data=None,\\n            human_file_list=[],\\n            is_send=False,\\n            is_receive=False,\\n            include_pictures=False,\\n        )\\n\\n        # insert into mysql\\n        InteractionCRUD.insert_raw(db=self.db, process=process)\\n\\n        # set redis\\n        redis.set_key(self.base.interaction_id + \\\"_send\\\", 1)\\n\\n        # set status\\n\\n        InteractionCRUD.update_interaction_status(\\n            db=self.db,\\n            interaction_id=self.base.interaction_id,\\n            status=StatusEnum.ASK_FOR_HUMAN_HELP,\\n            message=\\\"ask for human help\\\",\\n            current_step=self.current_step)\\n\\n        # check alive\\n        alive = redis.get_key(self.base.interaction_id)\\n        if alive == \\\"close\\\":\\n            self.logger.info(\\\"The user terminated this action and exited!\\\")\\n            exit(0)\\n\\n        # wait for human data\\n        wait = 0\\n        while wait < self.wait_seconds:\\n            human_data = self.get_human_data()\\n            if human_data is not None:\\n                return human_data\\n            else:\\n                wait += 2\\n                time.sleep(2)\\n\\n        raise XAgentTimeoutError(\\\"ASK-For-Human-Data: 等待数据超时，关闭连接\\\")\\n\",\n            \"name_column\": 8\n        }\n    },\n    \"XAgentServer/exts/redis_ext.py\": {\n        \"RedisClient\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"RedisClient\",\n            \"md_content\": \"\",\n            \"code_start_line\": 8,\n            \"code_end_line\": 135,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"class RedisClient:\\n    \\\"\\\"\\\"\\n    RedisClient\\n    \\\"\\\"\\\"\\n\\n    def __init__(self):\\n        self.client = Redis(host=os.getenv('REDIS_HOST', XAgentServerEnv.Redis.redis_host),\\n                            port=XAgentServerEnv.Redis.redis_port,\\n                            db=XAgentServerEnv.Redis.redis_db,\\n                            password=XAgentServerEnv.Redis.redis_password)\\n\\n    def set_key(self, key, value, ex=None, px=None, nx=False, xx=False):\\n        \\\"\\\"\\\"redis set key\\n\\n        Args:\\n            key (_type_): _description_\\n            value (_type_): _description_\\n            ex (_type_, optional): _description_. Defaults to None.\\n            px (_type_, optional): _description_. Defaults to None.\\n            nx (bool, optional): _description_. Defaults to False.\\n            xx (bool, optional): _description_. Defaults to False.\\n        \\\"\\\"\\\"\\n        self.client.set(key, value, ex, px, nx, xx)\\n\\n    def get_key(self, key):\\n        \\\"\\\"\\\"redis get key\\n\\n        Args:\\n            key (_type_): _description_\\n\\n        Returns:\\n            _type_: _description_\\n        \\\"\\\"\\\"\\n        value = self.client.get(key)\\n        if value:\\n            return value.decode(\\\"utf-8\\\")\\n        else:\\n            return None\\n\\n    def delete_key(self, key):\\n        \\\"\\\"\\\"redis delete key\\n\\n        Args:\\n            key (_type_): _description_\\n        \\\"\\\"\\\"\\n        self.client.delete(key)\\n\\n    def get_all_keys(self):\\n        \\\"\\\"\\\"redis get all keys\\n\\n        Returns:\\n            _type_: _description_\\n        \\\"\\\"\\\"\\n        return self.client.keys()\\n\\n    def delete_all_keys(self):\\n        \\\"\\\"\\\"redis delete all keys\\n        \\\"\\\"\\\"\\n        self.client.flushdb()\\n\\n    def set_parent_key(self, key, value):\\n        \\\"\\\"\\\"redis set parent key\\n\\n        Args:\\n            key (_type_): _description_\\n            value (_type_): _description_\\n        \\\"\\\"\\\"\\n        self.client.set(key, value)\\n\\n    def get_parent_key(self, key):\\n        \\\"\\\"\\\"redis get parent key\\n\\n        Args:\\n            key (_type_): _description_\\n\\n        Returns:\\n            _type_: _description_\\n        \\\"\\\"\\\"\\n        return self.client.get(key)\\n\\n    def delete_parent_key(self, key):\\n        \\\"\\\"\\\"redis delete parent key\\n\\n        Args:\\n            key (_type_): _description_\\n        \\\"\\\"\\\"\\n        self.client.delete(key)\\n\\n    def set_child_key(self, parent_key, key, value):\\n        \\\"\\\"\\\"redis set child key\\n\\n        Args:\\n            key (_type_): _description_\\n            value (_type_): _description_\\n        \\\"\\\"\\\"\\n        parent = self.client.get(parent_key)\\n        if parent:\\n            parent[key] = value\\n        else:\\n            parent = {key: value}\\n        self.set_key(parent_key, parent)\\n        \\n    def get_child_key(self, key):\\n        \\\"\\\"\\\"redis get child key\\n\\n        Args:\\n            key (_type_): _description_\\n\\n        Returns:\\n            _type_: _description_\\n        \\\"\\\"\\\"\\n        return self.client.get(key)\\n\\n    def delete_child_key(self, key):\\n        \\\"\\\"\\\"redis delete child key\\n\\n        Args:\\n            key (_type_): _description_\\n        \\\"\\\"\\\"\\n        self.client.delete(key)\\n\\n    def get_child_keys(self, parent_key):\\n        \\\"\\\"\\\"\\n\\n        Args:\\n            parent_key (_type_): _description_\\n        \\\"\\\"\\\"\\n        return self.client.keys(parent_key)\\n\",\n            \"name_column\": 6\n        },\n        \"__init__\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"__init__\",\n            \"md_content\": \"\",\n            \"code_start_line\": 13,\n            \"code_end_line\": 17,\n            \"parent\": \"RedisClient\",\n            \"have_return\": false,\n            \"code_content\": \"    def __init__(self):\\n        self.client = Redis(host=os.getenv('REDIS_HOST', XAgentServerEnv.Redis.redis_host),\\n                            port=XAgentServerEnv.Redis.redis_port,\\n                            db=XAgentServerEnv.Redis.redis_db,\\n                            password=XAgentServerEnv.Redis.redis_password)\\n\",\n            \"name_column\": 8\n        },\n        \"set_key\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"set_key\",\n            \"md_content\": \"\",\n            \"code_start_line\": 19,\n            \"code_end_line\": 30,\n            \"parent\": \"RedisClient\",\n            \"have_return\": false,\n            \"code_content\": \"    def set_key(self, key, value, ex=None, px=None, nx=False, xx=False):\\n        \\\"\\\"\\\"redis set key\\n\\n        Args:\\n            key (_type_): _description_\\n            value (_type_): _description_\\n            ex (_type_, optional): _description_. Defaults to None.\\n            px (_type_, optional): _description_. Defaults to None.\\n            nx (bool, optional): _description_. Defaults to False.\\n            xx (bool, optional): _description_. Defaults to False.\\n        \\\"\\\"\\\"\\n        self.client.set(key, value, ex, px, nx, xx)\\n\",\n            \"name_column\": 8\n        },\n        \"get_key\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"get_key\",\n            \"md_content\": \"\",\n            \"code_start_line\": 32,\n            \"code_end_line\": 45,\n            \"parent\": \"RedisClient\",\n            \"have_return\": true,\n            \"code_content\": \"    def get_key(self, key):\\n        \\\"\\\"\\\"redis get key\\n\\n        Args:\\n            key (_type_): _description_\\n\\n        Returns:\\n            _type_: _description_\\n        \\\"\\\"\\\"\\n        value = self.client.get(key)\\n        if value:\\n            return value.decode(\\\"utf-8\\\")\\n        else:\\n            return None\\n\",\n            \"name_column\": 8\n        },\n        \"delete_key\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"delete_key\",\n            \"md_content\": \"\",\n            \"code_start_line\": 47,\n            \"code_end_line\": 53,\n            \"parent\": \"RedisClient\",\n            \"have_return\": false,\n            \"code_content\": \"    def delete_key(self, key):\\n        \\\"\\\"\\\"redis delete key\\n\\n        Args:\\n            key (_type_): _description_\\n        \\\"\\\"\\\"\\n        self.client.delete(key)\\n\",\n            \"name_column\": 8\n        },\n        \"get_all_keys\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"get_all_keys\",\n            \"md_content\": \"\",\n            \"code_start_line\": 55,\n            \"code_end_line\": 61,\n            \"parent\": \"RedisClient\",\n            \"have_return\": true,\n            \"code_content\": \"    def get_all_keys(self):\\n        \\\"\\\"\\\"redis get all keys\\n\\n        Returns:\\n            _type_: _description_\\n        \\\"\\\"\\\"\\n        return self.client.keys()\\n\",\n            \"name_column\": 8\n        },\n        \"delete_all_keys\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"delete_all_keys\",\n            \"md_content\": \"\",\n            \"code_start_line\": 63,\n            \"code_end_line\": 66,\n            \"parent\": \"RedisClient\",\n            \"have_return\": false,\n            \"code_content\": \"    def delete_all_keys(self):\\n        \\\"\\\"\\\"redis delete all keys\\n        \\\"\\\"\\\"\\n        self.client.flushdb()\\n\",\n            \"name_column\": 8\n        },\n        \"set_parent_key\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"set_parent_key\",\n            \"md_content\": \"\",\n            \"code_start_line\": 68,\n            \"code_end_line\": 75,\n            \"parent\": \"RedisClient\",\n            \"have_return\": false,\n            \"code_content\": \"    def set_parent_key(self, key, value):\\n        \\\"\\\"\\\"redis set parent key\\n\\n        Args:\\n            key (_type_): _description_\\n            value (_type_): _description_\\n        \\\"\\\"\\\"\\n        self.client.set(key, value)\\n\",\n            \"name_column\": 8\n        },\n        \"get_parent_key\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"get_parent_key\",\n            \"md_content\": \"\",\n            \"code_start_line\": 77,\n            \"code_end_line\": 86,\n            \"parent\": \"RedisClient\",\n            \"have_return\": true,\n            \"code_content\": \"    def get_parent_key(self, key):\\n        \\\"\\\"\\\"redis get parent key\\n\\n        Args:\\n            key (_type_): _description_\\n\\n        Returns:\\n            _type_: _description_\\n        \\\"\\\"\\\"\\n        return self.client.get(key)\\n\",\n            \"name_column\": 8\n        },\n        \"delete_parent_key\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"delete_parent_key\",\n            \"md_content\": \"\",\n            \"code_start_line\": 88,\n            \"code_end_line\": 94,\n            \"parent\": \"RedisClient\",\n            \"have_return\": false,\n            \"code_content\": \"    def delete_parent_key(self, key):\\n        \\\"\\\"\\\"redis delete parent key\\n\\n        Args:\\n            key (_type_): _description_\\n        \\\"\\\"\\\"\\n        self.client.delete(key)\\n\",\n            \"name_column\": 8\n        },\n        \"set_child_key\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"set_child_key\",\n            \"md_content\": \"\",\n            \"code_start_line\": 96,\n            \"code_end_line\": 108,\n            \"parent\": \"RedisClient\",\n            \"have_return\": false,\n            \"code_content\": \"    def set_child_key(self, parent_key, key, value):\\n        \\\"\\\"\\\"redis set child key\\n\\n        Args:\\n            key (_type_): _description_\\n            value (_type_): _description_\\n        \\\"\\\"\\\"\\n        parent = self.client.get(parent_key)\\n        if parent:\\n            parent[key] = value\\n        else:\\n            parent = {key: value}\\n        self.set_key(parent_key, parent)\\n\",\n            \"name_column\": 8\n        },\n        \"get_child_key\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"get_child_key\",\n            \"md_content\": \"\",\n            \"code_start_line\": 110,\n            \"code_end_line\": 119,\n            \"parent\": \"RedisClient\",\n            \"have_return\": true,\n            \"code_content\": \"    def get_child_key(self, key):\\n        \\\"\\\"\\\"redis get child key\\n\\n        Args:\\n            key (_type_): _description_\\n\\n        Returns:\\n            _type_: _description_\\n        \\\"\\\"\\\"\\n        return self.client.get(key)\\n\",\n            \"name_column\": 8\n        },\n        \"delete_child_key\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"delete_child_key\",\n            \"md_content\": \"\",\n            \"code_start_line\": 121,\n            \"code_end_line\": 127,\n            \"parent\": \"RedisClient\",\n            \"have_return\": false,\n            \"code_content\": \"    def delete_child_key(self, key):\\n        \\\"\\\"\\\"redis delete child key\\n\\n        Args:\\n            key (_type_): _description_\\n        \\\"\\\"\\\"\\n        self.client.delete(key)\\n\",\n            \"name_column\": 8\n        },\n        \"get_child_keys\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"get_child_keys\",\n            \"md_content\": \"\",\n            \"code_start_line\": 129,\n            \"code_end_line\": 135,\n            \"parent\": \"RedisClient\",\n            \"have_return\": true,\n            \"code_content\": \"    def get_child_keys(self, parent_key):\\n        \\\"\\\"\\\"\\n\\n        Args:\\n            parent_key (_type_): _description_\\n        \\\"\\\"\\\"\\n        return self.client.keys(parent_key)\\n\",\n            \"name_column\": 8\n        }\n    },\n    \"XAgentServer/exts/mail_ext.py\": {\n        \"email_content\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"email_content\",\n            \"md_content\": \"\",\n            \"code_start_line\": 5,\n            \"code_end_line\": 22,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"def email_content(user):\\n    html_body = f\\\"\\\"\\\"\\n<body style=\\\"font-family: Arial, sans-serif;background-color: #f5f5f5;margin: 0; padding: 0;\\\">\\n    <div style=\\\"background-color: #ffffff;margin: 0 auto;padding: 20px;border-radius: 10px;box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);\\\">\\n        <h1 style=\\\"font-size: 28px;margin-bottom: 20px;\\\">Hello {user['name']},</h1>\\n        <p style=\\\"font-size: 16px;line-height: 1.5;color: #333333;text-indent:2em;\\\">Welcome to XAgent, your personal assistant! Thanks for signing up for XAgent. There are some information about your account:</p>\\n        <p style=\\\"font-size: 16px;line-height: 1.5;color: #333333;text-indent:2em;\\\">Your XAgent Account: <b>{user[\\\"email\\\"]}</b></p>\\n        <p style=\\\"font-size: 16px;line-height: 1.5;color: #333333;text-indent:2em;\\\">You need to use this token for authentication on subsequent logins: </p>\\n        <p style=\\\"font-size: 16px;line-height: 1.5;color: #333333;text-indent:2em;\\\">You need to use this token for authentication on subsequent logins: </p>\\n        <p style=\\\"font-size: 16px;line-height: 1.5;color: #333333;text-indent:2em;\\\">Token: <b>{user[\\\"token\\\"]}</b></p>\\n        \\n        <p style=\\\"font-size: 16px;line-height: 1.5;color: #333333;text-indent:2em;\\\">Next is an activation link. You need to click on this link to activate your account. After that, you will be able to use XAgent happily:<a href=\\\"{XAgentServerEnv.Email.auth_server}/auth?user_id={user[\\\"user_id\\\"]}&token={user[\\\"token\\\"]}\\\">{XAgentServerEnv.Email.auth_server}/auth?user_id={user[\\\"user_id\\\"]}&token={user[\\\"token\\\"]}</a>! This Verification link will expire in 7 days.</p>\\n        <p>If you have any questions, please contact us at yourxagent@gmail.com .</p>\\n        <p style=\\\"margin-top: 20px;font-size: 14px;color: #999999;text-indent:2em;\\\">Best wishes!</p>\\n        <p style=\\\"margin-top: 20px;font-size: 14px;color: #999999;\\\">XAgent Team</p>\\n    </div>\\n</body>\\\"\\\"\\\"\\n    return html_body\\n\",\n            \"name_column\": 4\n        }\n    },\n    \"XAgentServer/exts/exception_ext.py\": {\n        \"XAgentError\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"XAgentError\",\n            \"md_content\": \"\",\n            \"code_start_line\": 4,\n            \"code_end_line\": 8,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"class XAgentError(Exception):\\n    \\\"\\\"\\\"Base class for exceptions in this module.\\\"\\\"\\\"\\n    def __init__(self, message=\\\"XAgent Error!\\\"):\\n        self.message = message\\n        super().__init__(self.message)\\n\",\n            \"name_column\": 6\n        },\n        \"XAgentTimeoutError\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"XAgentTimeoutError\",\n            \"md_content\": \"\",\n            \"code_start_line\": 11,\n            \"code_end_line\": 20,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"class XAgentTimeoutError(XAgentError):\\n    \\\"\\\"\\\"Exception raised for errors in the input.\\n\\n    Attributes:\\n        message -- explanation of the error\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, message=\\\"XAgentTimeout!\\\"):\\n        self.message = message\\n        super().__init__(self.message)\\n\",\n            \"name_column\": 6\n        },\n        \"XAgentCloseError\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"XAgentCloseError\",\n            \"md_content\": \"\",\n            \"code_start_line\": 23,\n            \"code_end_line\": 32,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"class XAgentCloseError(XAgentError):\\n    \\\"\\\"\\\"Exception raised for errors in the input.\\n\\n    Attributes:\\n        message -- explanation of the error\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, message=\\\"XAgentClose!\\\"):\\n        self.message = message\\n        super().__init__(self.message)\\n\",\n            \"name_column\": 6\n        },\n        \"XAgentWebSocketError\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"XAgentWebSocketError\",\n            \"md_content\": \"\",\n            \"code_start_line\": 34,\n            \"code_end_line\": 43,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"class XAgentWebSocketError(XAgentError):\\n    \\\"\\\"\\\"Exception raised for errors in the input.\\n\\n    Attributes:\\n        message -- explanation of the error\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, message=\\\"XAgentWebSocket Error!\\\"):\\n        self.message = message\\n        super().__init__(self.message)\\n\",\n            \"name_column\": 6\n        },\n        \"XAgentWebSocketTimeoutError\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"XAgentWebSocketTimeoutError\",\n            \"md_content\": \"\",\n            \"code_start_line\": 45,\n            \"code_end_line\": 54,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"class XAgentWebSocketTimeoutError(XAgentWebSocketError):\\n    \\\"\\\"\\\"Exception raised for errors in the input.\\n\\n    Attributes:\\n        message -- explanation of the error\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, message=\\\"XAgentWebSocket Timeout!\\\"):\\n        self.message = message\\n        super().__init__(self.message)\\n\",\n            \"name_column\": 6\n        },\n        \"XAgentWebSocketDisconnectError\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"XAgentWebSocketDisconnectError\",\n            \"md_content\": \"\",\n            \"code_start_line\": 57,\n            \"code_end_line\": 66,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"class XAgentWebSocketDisconnectError(XAgentWebSocketError):\\n    \\\"\\\"\\\"Exception raised for errors in the input.\\n\\n    Attributes:\\n        message -- explanation of the error\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, message=\\\"XAgentWebSocket Disconnect!\\\"):\\n        self.message = message\\n        super().__init__(self.message)\\n\",\n            \"name_column\": 6\n        },\n        \"XAgentWebSocketConnectError\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"XAgentWebSocketConnectError\",\n            \"md_content\": \"\",\n            \"code_start_line\": 69,\n            \"code_end_line\": 78,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"class XAgentWebSocketConnectError(XAgentWebSocketError):\\n    \\\"\\\"\\\"Exception raised for errors in the input.\\n\\n    Attributes:\\n        message -- explanation of the error\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, message=\\\"XAgentWebSocket Connect Error!\\\"):\\n        self.message = message\\n        super().__init__(self.message)\\n\",\n            \"name_column\": 6\n        },\n        \"XAgentWebSocketCloseError\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"XAgentWebSocketCloseError\",\n            \"md_content\": \"\",\n            \"code_start_line\": 81,\n            \"code_end_line\": 90,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"class XAgentWebSocketCloseError(XAgentWebSocketError):\\n    \\\"\\\"\\\"Exception raised for errors in the input.\\n\\n    Attributes:\\n        message -- explanation of the error\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, message=\\\"XAgentWebSocket Close!\\\"):\\n        self.message = message\\n        super().__init__(self.message)\\n\",\n            \"name_column\": 6\n        },\n        \"XAgentWebSocketSendError\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"XAgentWebSocketSendError\",\n            \"md_content\": \"\",\n            \"code_start_line\": 93,\n            \"code_end_line\": 102,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"class XAgentWebSocketSendError(XAgentWebSocketError):\\n    \\\"\\\"\\\"Exception raised for errors in the input.\\n\\n    Attributes:\\n        message -- explanation of the error\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, message=\\\"XAgentWebSocket Send Error!\\\"):\\n        self.message = message\\n        super().__init__(self.message)\\n\",\n            \"name_column\": 6\n        },\n        \"XAgentWebSocketReceiveError\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"XAgentWebSocketReceiveError\",\n            \"md_content\": \"\",\n            \"code_start_line\": 105,\n            \"code_end_line\": 114,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"class XAgentWebSocketReceiveError(XAgentWebSocketError):\\n    \\\"\\\"\\\"Exception raised for errors in the input.\\n\\n    Attributes:\\n        message -- explanation of the error\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, message=\\\"XAgentWebSocket Receive Error!\\\"):\\n        self.message = message\\n        super().__init__(self.message)\\n\",\n            \"name_column\": 6\n        },\n        \"XAgentFileError\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"XAgentFileError\",\n            \"md_content\": \"\",\n            \"code_start_line\": 117,\n            \"code_end_line\": 126,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"class XAgentFileError(XAgentError):\\n    \\\"\\\"\\\"Exception raised for errors in the input.\\n\\n    Attributes:\\n        message -- explanation of the error\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, message=\\\"XAgent File Error!\\\"):\\n        self.message = message\\n        super().__init__(self.message)\\n\",\n            \"name_column\": 6\n        },\n        \"XAgentDownloadFileError\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"XAgentDownloadFileError\",\n            \"md_content\": \"\",\n            \"code_start_line\": 129,\n            \"code_end_line\": 138,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"class XAgentDownloadFileError(XAgentFileError):\\n    \\\"\\\"\\\"Exception raised for errors in the input.\\n\\n    Attributes:\\n        message -- explanation of the error\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, message=\\\"Download File Error!\\\"):\\n        self.message = message\\n        super().__init__(self.message)\\n\",\n            \"name_column\": 6\n        },\n        \"XAgentWorkspaceFileError\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"XAgentWorkspaceFileError\",\n            \"md_content\": \"\",\n            \"code_start_line\": 141,\n            \"code_end_line\": 150,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"class XAgentWorkspaceFileError(XAgentFileError):\\n    \\\"\\\"\\\"Exception raised for errors in the input.\\n\\n    Attributes:\\n        message -- explanation of the error\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, message=\\\"XAgent Workspace File Error!\\\"):\\n        self.message = message\\n        super().__init__(self.message)\\n\",\n            \"name_column\": 6\n        },\n        \"XAgentUploadFileError\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"XAgentUploadFileError\",\n            \"md_content\": \"\",\n            \"code_start_line\": 153,\n            \"code_end_line\": 162,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"class XAgentUploadFileError(XAgentFileError):\\n    \\\"\\\"\\\"Exception raised for errors in the input.\\n\\n    Attributes:\\n        message -- explanation of the error\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, message=\\\"XAgent Workspace Upload File Error!\\\"):\\n        self.message = message\\n        super().__init__(self.message)\\n\",\n            \"name_column\": 6\n        },\n        \"XAgentDBError\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"XAgentDBError\",\n            \"md_content\": \"\",\n            \"code_start_line\": 165,\n            \"code_end_line\": 174,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"class XAgentDBError(XAgentError):\\n    \\\"\\\"\\\"Exception raised because of DB error\\n\\n    Attributes:\\n        message -- explanation of the error\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, message=\\\"XAgent DB Error!\\\"):\\n        self.message = message\\n        super().__init__(self.message)\\n\",\n            \"name_column\": 6\n        },\n        \"XAgentAuthError\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"XAgentAuthError\",\n            \"md_content\": \"\",\n            \"code_start_line\": 177,\n            \"code_end_line\": 186,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"class XAgentAuthError(XAgentError):\\n    \\\"\\\"\\\"Exception raised because of auth error\\n\\n    Attributes:\\n        message -- explanation of the error\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, message=\\\"XAgent Auth Error!\\\"):\\n        self.message = message\\n        super().__init__(self.message)\\n\",\n            \"name_column\": 6\n        },\n        \"XAgentRunningError\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"XAgentRunningError\",\n            \"md_content\": \"\",\n            \"code_start_line\": 189,\n            \"code_end_line\": 198,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"class XAgentRunningError(XAgentError):\\n    \\\"\\\"\\\"Exception raised because of Running error\\n\\n    Attributes:\\n        message -- explanation of the error\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, message=\\\"XAgent Running Error!\\\"):\\n        self.message = message\\n        super().__init__(self.message)\\n\",\n            \"name_column\": 6\n        },\n        \"XAgentWebError\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"XAgentWebError\",\n            \"md_content\": \"\",\n            \"code_start_line\": 201,\n            \"code_end_line\": 210,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"class XAgentWebError(XAgentError):\\n    \\\"\\\"\\\"Exception raised because of Running error\\n\\n    Attributes:\\n        message -- explanation of the error\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, message=\\\"XAgent WEB Error!\\\"):\\n        self.message = message\\n        super().__init__(self.message)\\n\",\n            \"name_column\": 6\n        },\n        \"__init__\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"__init__\",\n            \"md_content\": \"\",\n            \"code_start_line\": 208,\n            \"code_end_line\": 210,\n            \"parent\": \"XAgentWebError\",\n            \"have_return\": false,\n            \"code_content\": \"    def __init__(self, message=\\\"XAgent WEB Error!\\\"):\\n        self.message = message\\n        super().__init__(self.message)\\n\",\n            \"name_column\": 8\n        }\n    },\n    \"XAgentServer/database/models.py\": {\n        \"User\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"User\",\n            \"md_content\": \"\",\n            \"code_start_line\": 6,\n            \"code_end_line\": 22,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"class User(Base):\\n    \\\"\\\"\\\"XAgent Users\\\"\\\"\\\"\\n    __tablename__=\\\"users\\\"\\n\\n    id=Column(Integer,primary_key=True,index=True)\\n    user_id = Column(String(32), unique=True, index=True)\\n    email = Column(String(255), unique=True)\\n    name = Column(String(255))\\n    token = Column(String(255))\\n    available = Column(Boolean, default=True)\\n    is_beta = Column(Boolean, default=False)\\n    deleted = Column(Boolean, default=False)\\n    corporation = Column(Text)\\n    industry = Column(Text)\\n    position = Column(String(255))\\n    create_time = Column(String(255))\\n    update_time = Column(String(255))\\n\",\n            \"name_column\": 6\n        },\n        \"Interaction\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"Interaction\",\n            \"md_content\": \"\",\n            \"code_start_line\": 25,\n            \"code_end_line\": 43,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"class Interaction(Base):\\n    \\\"\\\"\\\"XAgent Interactions\\\"\\\"\\\"\\n    __tablename__ = \\\"interactions\\\"\\n\\n    id = Column(Integer, primary_key=True, index=True)\\n    interaction_id = Column(String(255))\\n    user_id = Column(String(255))\\n    create_time = Column(String(255))\\n    update_time = Column(String(255))\\n    description = Column(Text)\\n    agent = Column(String(255))\\n    mode = Column(String(255))\\n    recorder_root_dir = Column(Text)\\n    file_list = Column(JSON)\\n    status = Column(String(255))\\n    message = Column(Text)\\n    current_step = Column(String(255))\\n    is_deleted = Column(Boolean, default=False)\\n    call_method = Column(String(255), default=\\\"web\\\")\\n\",\n            \"name_column\": 6\n        },\n        \"Parameter\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"Parameter\",\n            \"md_content\": \"\",\n            \"code_start_line\": 46,\n            \"code_end_line\": 53,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"class Parameter(Base):\\n    \\\"\\\"\\\"XAgent Parameters\\\"\\\"\\\"\\n    __tablename__ = \\\"interaction_parameters\\\"\\n\\n    id = Column(Integer, primary_key=True, index=True)\\n    interaction_id = Column(String(32), unique=True, index=True)\\n    parameter_id = Column(String(32))\\n    args = Column(JSON)\\n\",\n            \"name_column\": 6\n        },\n        \"SharedInteraction\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"SharedInteraction\",\n            \"md_content\": \"\",\n            \"code_start_line\": 56,\n            \"code_end_line\": 70,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"class SharedInteraction(Base):\\n    \\\"\\\"\\\"Commnunity Shared Interactions\\\"\\\"\\\"\\n    __tablename__ = \\\"shared_interactions\\\"\\n\\n    id = Column(Integer, primary_key=True, index=True)\\n    interaction_id = Column(String(255))\\n    user_name = Column(String(255))\\n    create_time = Column(String(255))\\n    update_time = Column(String(255))\\n    description = Column(Text)\\n    agent = Column(String(255))\\n    mode = Column(String(255))\\n    is_deleted = Column(Boolean, default=False)\\n    star = Column(Integer, default=0)\\n    is_audit = Column(Boolean, default=False)\\n\",\n            \"name_column\": 6\n        },\n        \"Raw\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"Raw\",\n            \"md_content\": \"\",\n            \"code_start_line\": 73,\n            \"code_end_line\": 115,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"class Raw(Base):\\n    \\\"\\\"\\\"Raw Data\\\"\\\"\\\"\\n    __tablename__ = \\\"raw\\\"\\n    # id/id\\n    id = Column(Integer, primary_key=True, index=True)\\n    # node_id\\n    node_id = Column(String(255))\\n    # 交互id/interaction_id\\n    interaction_id = Column(String(255))\\n    # 当前节点/current\\n    current = Column(String(128))\\n    # step/step\\n    step = Column(Integer, default=0)\\n    # 数据/agent data\\n    data = Column(JSON)\\n    # workspace文件列表/workspace file list\\n    file_list = Column(JSON)\\n    # 状态/status\\n    status = Column(String(20))\\n    # 是否中断/interrupt or not\\n    do_interrupt = Column(Boolean, default=False)\\n    # 已等待时间/wait seconds\\n    wait_seconds = Column(Integer, default=0)\\n    # 是否需要人工干预/ask for human help or not\\n    ask_for_human_help = Column(Boolean, default=False)\\n    # 创建时间/create time\\n    create_time = Column(String(255))\\n    # 更新时间/update time\\n    update_time = Column(String(255))\\n    # 是否删除/is deleted or not\\n    is_deleted = Column(Boolean, default=False)\\n    # 是否人工已经输入/has human input or not\\n    is_human = Column(Boolean, default=False)\\n    # 人工输入数据/human data\\n    human_data = Column(JSON)\\n    # 人工文件列表/agent file list\\n    human_file_list = Column(JSON)\\n    # 是否推送前端/has send to frontend or not\\n    is_send = Column(Boolean, default=False)\\n    # 是否接收前端消息/has receive message from frontend or not\\n    is_receive = Column(Boolean, default=False)\\n    # 是否包含png/has png or not\\n    include_pictures = Column(Boolean, default=False)\\n\",\n            \"name_column\": 6\n        },\n        \"RunningRecord\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"RunningRecord\",\n            \"md_content\": \"\",\n            \"code_start_line\": 118,\n            \"code_end_line\": 138,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"class RunningRecord(Base):\\n    \\\"\\\"\\\"Running Record\\\"\\\"\\\"\\n    __tablename__ = \\\"running_record\\\"\\n    # id/id\\n    id = Column(Integer, primary_key=True, index=True)\\n    # record_id/record_id\\n    record_id = Column(String(255))\\n    # 当前节点/current\\n    current = Column(String(255))\\n    # 节点id/node_id\\n    node_id = Column(String(255))\\n    # 节点类型/node_type, options: [now_subtask_id, llm_input_pair, tool_server_pair, query, config]\\n    node_type = Column(String(255))\\n    # data/agent data\\n    data = Column(JSON)\\n    # 创建时间/create time\\n    create_time = Column(String(255))\\n    # 更新时间/update time\\n    update_time = Column(String(255))\\n    # 是否删除/is deleted or not\\n    is_deleted = Column(Boolean, default=False)\\n\",\n            \"name_column\": 6\n        }\n    },\n    \"XAgentServer/database/connect.py\": {},\n    \"XAgentServer/database/__init__.py\": {},\n    \"XAgentServer/database/interface/user.py\": {\n        \"UserDBInterface\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"UserDBInterface\",\n            \"md_content\": \"\",\n            \"code_start_line\": 13,\n            \"code_end_line\": 160,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"class UserDBInterface(metaclass=abc.ABCMeta):\\n    \\\"\\\"\\\"User DB Interface\\n\\n    Args:\\n        UserBaseInterface (_type_): _description_\\n        metaclass (_type_, optional): _description_. Defaults to abc.ABCMeta.\\n    \\\"\\\"\\\"\\n\\n    @classmethod\\n    def get_user_list(cls, db: Session) -> list[XAgentUser]:\\n        \\\"\\\"\\\"get all users\\n\\n        Args:\\n            db (Session): db\\n\\n        Returns:\\n            list[XAgentUser]: user list\\n        \\\"\\\"\\\"\\n        users = db.query(User).all()\\n        return [XAgentUser.from_db(user) for user in users]\\n\\n    @classmethod\\n    def get_user(cls,\\n                 db: Session,\\n                 user_id: str | None = None,\\n                 email: str | None = None) -> XAgentUser | None:\\n        \\\"\\\"\\\"get user by user_id or email\\n\\n        Args:\\n            db (Session): db\\n            user_id (str | None, optional): user id. Defaults to None.\\n            email (str | None, optional): email. Defaults to None.\\n\\n        Returns:\\n            XAgentUser | None: user, if user is not exist, return None\\n        \\\"\\\"\\\"\\n        if email is not None:\\n            user = db.query(User).filter(User.email == email,\\n                                         User.deleted.is_(False)).first()\\n        else:\\n            user = db.query(User).filter(\\n                User.user_id == user_id, User.deleted.is_(False)).first()\\n\\n        return XAgentUser.from_db(user) if user else None\\n\\n    @classmethod\\n    def is_exist(cls,\\n                db: Session,\\n                user_id: str | None = None,\\n                email: str | None = None):\\n        \\\"\\\"\\\"user is exist?\\n\\n        Args:\\n            db (Session): db session\\n            user_id (str | None, optional): user id. Defaults to None.\\n            email (str | None, optional): email. Defaults to None.\\n\\n        Returns:\\n            Boolean: True or False\\n        \\\"\\\"\\\"\\n        if not email and not user_id:\\n            return False\\n        if email:\\n            user = db.query(User).filter(User.email == email,\\n                                         User.deleted.is_(False)).first()\\n        else:\\n            user = db.query(User).filter(\\n                User.user_id == user_id, User.deleted.is_(False)).first()\\n        return user is not None\\n\\n    @classmethod\\n    def token_is_exist(cls,\\n                       db: Session,\\n                       user_id: str,\\n                       token: str | None = None):\\n        \\\"\\\"\\\"token is exist?\\n        \\n        Args:\\n            db (Session): db session\\n            user_id (str): user id\\n            token (str | None, optional): token. Defaults to None.\\n            \\n        Returns:\\n            Boolean: True or False\\n        \\\"\\\"\\\"\\n        if not token:\\n            return False\\n\\n        user = db.query(User).filter(User.user_id == user_id,\\n                                     User.token == token, User.deleted.is_(False)).first()\\n        return user is not None\\n\\n    @classmethod\\n    def user_is_valid(cls, db: Session,\\n                      user_id: str | None = None,\\n                      email: str | None = None,\\n                      token: str | None = None):\\n        \\\"\\\"\\\"\\n        user is valid?\\n        \\n        Args:\\n            db (Session): db session\\n            user_id (str | None, optional): user id. Defaults to None.\\n            email (str | None, optional): email. Defaults to None.\\n            token (str | None, optional): token. Defaults to None.\\n            \\n        Returns:\\n            Boolean: True or False\\n        \\\"\\\"\\\"\\n        if email == \\\"\\\":\\n            return False\\n        user = db.query(User).filter(User.user_id == user_id,\\n                                     User.token == token, User.deleted.is_(False)).first()\\n        if user is None:\\n            return False\\n        if token is None:\\n            if user.email == email and user.available:\\n                return True\\n        if user_id is not None:\\n            if user.user_id == user_id and user.token == token and user.available:\\n                return True\\n        if email is not None:\\n            if user.email == email and user.token == token and user.available:\\n                return True\\n        return False\\n\\n    @classmethod\\n    def add_user(cls, db: Session, user_dict: dict):\\n        \\\"\\\"\\\"\\n        add user\\n        \\\"\\\"\\\"\\n        db.add(User(**user_dict))\\n        db.commit()\\n\\n    @classmethod\\n    def update_user(cls, db: Session, user: XAgentUser):\\n        \\\"\\\"\\\"\\n        update user\\n        \\\"\\\"\\\"\\n        db_user = db.query(User).filter(\\n            User.user_id == user.user_id, User.deleted.is_(False)).first()\\n\\n        db_user.available = user.available\\n        db_user.email = user.email\\n        db_user.name = user.name\\n        db_user.token = user.token\\n        db_user.update_time = datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\")\\n        db.commit()\\n\",\n            \"name_column\": 6\n        },\n        \"get_user_list\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"get_user_list\",\n            \"md_content\": \"\",\n            \"code_start_line\": 22,\n            \"code_end_line\": 32,\n            \"parent\": \"UserDBInterface\",\n            \"have_return\": true,\n            \"code_content\": \"    def get_user_list(cls, db: Session) -> list[XAgentUser]:\\n        \\\"\\\"\\\"get all users\\n\\n        Args:\\n            db (Session): db\\n\\n        Returns:\\n            list[XAgentUser]: user list\\n        \\\"\\\"\\\"\\n        users = db.query(User).all()\\n        return [XAgentUser.from_db(user) for user in users]\\n\",\n            \"name_column\": 8\n        },\n        \"get_user\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"get_user\",\n            \"md_content\": \"\",\n            \"code_start_line\": 35,\n            \"code_end_line\": 56,\n            \"parent\": \"UserDBInterface\",\n            \"have_return\": true,\n            \"code_content\": \"    def get_user(cls,\\n                 db: Session,\\n                 user_id: str | None = None,\\n                 email: str | None = None) -> XAgentUser | None:\\n        \\\"\\\"\\\"get user by user_id or email\\n\\n        Args:\\n            db (Session): db\\n            user_id (str | None, optional): user id. Defaults to None.\\n            email (str | None, optional): email. Defaults to None.\\n\\n        Returns:\\n            XAgentUser | None: user, if user is not exist, return None\\n        \\\"\\\"\\\"\\n        if email is not None:\\n            user = db.query(User).filter(User.email == email,\\n                                         User.deleted.is_(False)).first()\\n        else:\\n            user = db.query(User).filter(\\n                User.user_id == user_id, User.deleted.is_(False)).first()\\n\\n        return XAgentUser.from_db(user) if user else None\\n\",\n            \"name_column\": 8\n        },\n        \"is_exist\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"is_exist\",\n            \"md_content\": \"\",\n            \"code_start_line\": 59,\n            \"code_end_line\": 81,\n            \"parent\": \"UserDBInterface\",\n            \"have_return\": true,\n            \"code_content\": \"    def is_exist(cls,\\n                db: Session,\\n                user_id: str | None = None,\\n                email: str | None = None):\\n        \\\"\\\"\\\"user is exist?\\n\\n        Args:\\n            db (Session): db session\\n            user_id (str | None, optional): user id. Defaults to None.\\n            email (str | None, optional): email. Defaults to None.\\n\\n        Returns:\\n            Boolean: True or False\\n        \\\"\\\"\\\"\\n        if not email and not user_id:\\n            return False\\n        if email:\\n            user = db.query(User).filter(User.email == email,\\n                                         User.deleted.is_(False)).first()\\n        else:\\n            user = db.query(User).filter(\\n                User.user_id == user_id, User.deleted.is_(False)).first()\\n        return user is not None\\n\",\n            \"name_column\": 8\n        },\n        \"token_is_exist\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"token_is_exist\",\n            \"md_content\": \"\",\n            \"code_start_line\": 84,\n            \"code_end_line\": 103,\n            \"parent\": \"UserDBInterface\",\n            \"have_return\": true,\n            \"code_content\": \"    def token_is_exist(cls,\\n                       db: Session,\\n                       user_id: str,\\n                       token: str | None = None):\\n        \\\"\\\"\\\"token is exist?\\n        \\n        Args:\\n            db (Session): db session\\n            user_id (str): user id\\n            token (str | None, optional): token. Defaults to None.\\n            \\n        Returns:\\n            Boolean: True or False\\n        \\\"\\\"\\\"\\n        if not token:\\n            return False\\n\\n        user = db.query(User).filter(User.user_id == user_id,\\n                                     User.token == token, User.deleted.is_(False)).first()\\n        return user is not None\\n\",\n            \"name_column\": 8\n        },\n        \"user_is_valid\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"user_is_valid\",\n            \"md_content\": \"\",\n            \"code_start_line\": 106,\n            \"code_end_line\": 137,\n            \"parent\": \"UserDBInterface\",\n            \"have_return\": true,\n            \"code_content\": \"    def user_is_valid(cls, db: Session,\\n                      user_id: str | None = None,\\n                      email: str | None = None,\\n                      token: str | None = None):\\n        \\\"\\\"\\\"\\n        user is valid?\\n        \\n        Args:\\n            db (Session): db session\\n            user_id (str | None, optional): user id. Defaults to None.\\n            email (str | None, optional): email. Defaults to None.\\n            token (str | None, optional): token. Defaults to None.\\n            \\n        Returns:\\n            Boolean: True or False\\n        \\\"\\\"\\\"\\n        if email == \\\"\\\":\\n            return False\\n        user = db.query(User).filter(User.user_id == user_id,\\n                                     User.token == token, User.deleted.is_(False)).first()\\n        if user is None:\\n            return False\\n        if token is None:\\n            if user.email == email and user.available:\\n                return True\\n        if user_id is not None:\\n            if user.user_id == user_id and user.token == token and user.available:\\n                return True\\n        if email is not None:\\n            if user.email == email and user.token == token and user.available:\\n                return True\\n        return False\\n\",\n            \"name_column\": 8\n        },\n        \"add_user\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"add_user\",\n            \"md_content\": \"\",\n            \"code_start_line\": 140,\n            \"code_end_line\": 145,\n            \"parent\": \"UserDBInterface\",\n            \"have_return\": false,\n            \"code_content\": \"    def add_user(cls, db: Session, user_dict: dict):\\n        \\\"\\\"\\\"\\n        add user\\n        \\\"\\\"\\\"\\n        db.add(User(**user_dict))\\n        db.commit()\\n\",\n            \"name_column\": 8\n        },\n        \"update_user\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"update_user\",\n            \"md_content\": \"\",\n            \"code_start_line\": 148,\n            \"code_end_line\": 160,\n            \"parent\": \"UserDBInterface\",\n            \"have_return\": false,\n            \"code_content\": \"    def update_user(cls, db: Session, user: XAgentUser):\\n        \\\"\\\"\\\"\\n        update user\\n        \\\"\\\"\\\"\\n        db_user = db.query(User).filter(\\n            User.user_id == user.user_id, User.deleted.is_(False)).first()\\n\\n        db_user.available = user.available\\n        db_user.email = user.email\\n        db_user.name = user.name\\n        db_user.token = user.token\\n        db_user.update_time = datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\")\\n        db.commit()\\n\",\n            \"name_column\": 8\n        }\n    },\n    \"XAgentServer/database/interface/interaction.py\": {\n        \"InteractionDBInterface\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"InteractionDBInterface\",\n            \"md_content\": \"\",\n            \"code_start_line\": 19,\n            \"code_end_line\": 559,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"class InteractionDBInterface(metaclass=abc.ABCMeta):\\n    \\\"\\\"\\\"Interaction DB Interface\\n    \\\"\\\"\\\"\\n\\n    @classmethod\\n    def search_many_interaction(cls, db: Session) -> list[InteractionBase]:\\n        \\\"\\\"\\\"search many interactions\\n\\n        Args:\\n            db (Session): db session\\n\\n        Returns:\\n            list[InteractionBase]: interaction list\\n        \\\"\\\"\\\"\\n        interactions = db.query(Interaction).all()\\n        return [InteractionBase.from_db(interaction) for interaction in interactions]\\n\\n    @classmethod\\n    def get_interaction(cls,\\n                        db: Session,\\n                        interaction_id: str) -> InteractionBase | None:\\n        \\\"\\\"\\\"get interaction by interaction_id\\n\\n        Args:\\n            db (Session): db session\\n            interaction_id (str): interaction id\\n\\n        Returns:\\n            InteractionBase | None: _description_\\n        \\\"\\\"\\\"\\n        interaction = db.query(Interaction).filter(\\n            Interaction.interaction_id == interaction_id,\\n            Interaction.is_deleted.is_not(True)).first()\\n        return InteractionBase.from_db(interaction) if interaction else None\\n\\n    @classmethod\\n    def get_ready_interaction(cls,\\n                              db: Session,\\n                              user_id: str) -> InteractionBase | None:\\n        \\\"\\\"\\\"get interaction by user_id\\n\\n        Args:\\n            db (Session): db session\\n            user_id (str): user id\\n\\n        Returns:\\n            InteractionBase | None: _description_\\n        \\\"\\\"\\\"\\n        interaction = db.query(Interaction).filter(\\n            Interaction.user_id == user_id,\\n            Interaction.status == 'ready').first()\\n        return InteractionBase.from_db(interaction) if interaction else None\\n\\n    @classmethod\\n    def create_interaction(cls,\\n                           db: Session,\\n                           base: InteractionBase) -> InteractionBase:\\n        \\\"\\\"\\\"\\n        create interaction\\n\\n        Args:\\n            db (Session): db session\\n            base (InteractionBase): interaction base\\n\\n        Returns:\\n            None\\n        \\\"\\\"\\\"\\n        db.add(Interaction(**base.to_dict()))\\n        db.commit()\\n        return None\\n\\n    @classmethod\\n    def add_parameter(cls,\\n                      db: Session,\\n                      parameter: InteractionParameter):\\n        \\\"\\\"\\\"\\n        add parameter for interaction\\n        \\\"\\\"\\\"\\n        db.add(Parameter(**parameter.to_dict()))\\n        db.commit()\\n\\n        return None\\n\\n    @classmethod\\n    def search_interaction_by_user_id(cls,\\n                                      db: Session,\\n                                      user_id: str,\\n                                      page_size: int = 20,\\n                                      page_num: int = 1) -> list[dict]:\\n        \\\"\\\"\\\"\\n        search interaction by user id\\n\\n        Args:\\n            db (Session): db session\\n            user_id (str): user id\\n            page_size (int, optional): page size. Defaults to 20.\\n            page_num (int, optional): page num. Defaults to 1.\\n\\n        Returns:\\n            list[dict]: interaction list\\n        \\\"\\\"\\\"\\n        total = db.query(func.count(Interaction.id)).filter(\\n            Interaction.user_id == user_id, Interaction.is_deleted.is_(False)).scalar()\\n\\n        interaction_list = db.query(Interaction).filter(\\n            Interaction.user_id == user_id,\\n            Interaction.is_deleted.is_(False),\\n            Interaction.status.in_([StatusEnum.FINISHED])).limit(\\n            page_size).offset((page_num - 1) * page_size).all()\\n        data = []\\n        for interaction in interaction_list:\\n            d_ = InteractionBase.from_db(interaction).to_dict(\\n                exclude=[\\\"recorder_root_dir\\\", \\\"is_deleted\\\"])\\n            parameter = cls.get_parameter(\\n                db=db, interaction_id=d_[\\\"interaction_id\\\"])\\n            d_[\\\"parameters\\\"] = [parameter[0]]\\n            data.append(d_)\\n        return {\\n            \\\"total\\\": total,\\n            \\\"rows\\\": data\\n        }\\n\\n    @classmethod\\n    def search_many_shared(cls,\\n                           db: Session,\\n                           page_size: int = 20,\\n                           page_index: int = 1) -> list[dict]:\\n        \\\"\\\"\\\"\\n        search many shared interactions from community\\n\\n        Args:\\n            db (Session): db session\\n            page_size (int, optional): page size. Defaults to 20.\\n            page_index (int, optional): page index. Defaults to 1.\\n\\n        Returns:\\n            list[dict]: interaction list\\n        \\\"\\\"\\\"\\n        total = db.query(func.count(SharedInteraction.id)).filter(\\n            SharedInteraction.is_deleted.is_(False),\\n            SharedInteraction.is_audit.is_(True)).scalar()\\n        interaction_list = db.query(SharedInteraction).filter(\\n            SharedInteraction.is_deleted.is_(False),\\n            SharedInteraction.is_audit.is_(True)).order_by(\\n            SharedInteraction.star.desc()).limit(page_size).offset(\\n                (page_index - 1) * page_size).all()\\n        data = []\\n        for interaction in interaction_list:\\n            d_ = SharedInteractionBase.from_db(interaction).to_dict(\\n                exclude=[\\\"record_dir\\\", \\\"is_deleted\\\"])\\n            parameter = cls.get_parameter(\\n                db=db, interaction_id=d_[\\\"interaction_id\\\"])\\n            d_[\\\"parameters\\\"] = parameter\\n            data.append(d_)\\n        return {\\n            \\\"total\\\": total,\\n            \\\"rows\\\": data\\n        }\\n\\n    @classmethod\\n    def get_shared_interaction(cls,\\n                               db: Session,\\n                               interaction_id: str) -> SharedInteractionBase | None:\\n        \\\"\\\"\\\"\\n        get shared interaction by interaction id\\n\\n        Args:\\n            db (Session): db session\\n            interaction_id (str): interaction id\\n\\n        Returns:\\n\\n            SharedInteractionBase | None: shared interaction\\n        \\\"\\\"\\\"\\n        interaction = db.query(SharedInteraction).filter(\\n            SharedInteraction.interaction_id == interaction_id, SharedInteraction.is_deleted.is_(False)).first()\\n        return SharedInteractionBase.from_db(interaction) if interaction else None\\n\\n    @classmethod\\n    def is_exist(cls,\\n                 db: Session,\\n                 interaction_id: str) -> bool:\\n        \\\"\\\"\\\"\\n        check interaction is exist or not\\n\\n        Args:\\n            db (Session): db session\\n            interaction_id (str): interaction id\\n\\n        Returns:\\n            bool: True or False\\n        \\\"\\\"\\\"\\n        interaction = db.query(Interaction).filter(\\n            Interaction.interaction_id == interaction_id,\\n            Interaction.is_deleted.is_(False)).first()\\n        return interaction is not None\\n\\n    @classmethod\\n    def update_interaction(cls, db: Session, base_data: dict):\\n        \\\"\\\"\\\"\\n        update interaction\\n\\n        Args:\\n            db (Session): db session\\n            base_data (dict): interaction data\\n\\n        Returns:\\n            None\\n        \\\"\\\"\\\"\\n        if \\\"interaction_id\\\" not in base_data:\\n            raise XAgentError(\\\"interaction_id is required\\\")\\n        interaction = db.query(Interaction).filter(\\n            Interaction.interaction_id == base_data[\\\"interaction_id\\\"]).first()\\n        if interaction is None:\\n            raise XAgentError(\\\"interaction is not exist\\\")\\n        for k, v in base_data.items():\\n            if k == \\\"interaction_id\\\":\\n                continue\\n            setattr(interaction, k, v)\\n        interaction.update_time = datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\")\\n        db.commit()\\n\\n    @classmethod\\n    def update_interaction_status(cls,\\n                                  db: Session,\\n                                  interaction_id: str,\\n                                  status: str,\\n                                  message: str,\\n                                  current_step: int):\\n        \\\"\\\"\\\"\\n        update interaction status\\n\\n        Args:\\n            db (Session): db session\\n            interaction_id (str): interaction id\\n            status (str): status\\n            message (str): message\\n            current_step (int): current step\\n\\n        Returns:\\n            None\\n        \\\"\\\"\\\"\\n        db_interaction = db.query(Interaction).filter(\\n            Interaction.interaction_id == interaction_id).first()\\n        if db_interaction is None:\\n            raise XAgentError(\\\"interaction is not exist\\\")\\n\\n        db_interaction.status = status\\n        db_interaction.message = message\\n        db_interaction.current_step = current_step\\n        db_interaction.update_time = datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\")\\n        db.commit()\\n\\n    @classmethod\\n    def update_interaction_parameter(cls,\\n                                     db: Session,\\n                                     interaction_id: str,\\n                                     parameter: InteractionParameter):\\n        \\\"\\\"\\\"\\n        update interaction parameter\\n\\n        Args:\\n            db (Session): db session\\n            interaction_id (str): interaction id\\n            parameter (InteractionParameter): parameter\\n\\n        Returns:\\n            None\\n        \\\"\\\"\\\"\\n        db_parameter = db.query(Parameter).filter(\\n            Parameter.interaction_id == interaction_id,\\n            Parameter.parameter_id == parameter.parameter_id).first()\\n\\n        if db_parameter is None:\\n            db.add(Parameter(**parameter.to_dict()))\\n        db.commit()\\n\\n    @classmethod\\n    def is_running(cls, db: Session, user_id: str):\\n        \\\"\\\"\\\"\\n        check user is only running one interaction\\n\\n        Args:\\n            db (Session): db session\\n            user_id (str): user id\\n\\n        Returns:    \\n            bool: True or False\\n        \\\"\\\"\\\"\\n        interaction = db.query(Interaction).filter(\\n            Interaction.user_id == user_id,\\n            Interaction.status.in_((\\\"running\\\", \\\"waiting\\\"))).first()\\n        return interaction is not None\\n\\n    @classmethod\\n    def get_parameter(cls, db: Session, interaction_id: str) -> list:\\n        \\\"\\\"\\\"\\n        get interaction running parameter\\n\\n        Args:\\n            db (Session): db session\\n            interaction_id (str): interaction id\\n\\n        Returns:\\n            list: parameter list\\n        \\\"\\\"\\\"\\n        raws = db.query(Raw).filter(\\n            Raw.interaction_id == interaction_id,\\n            Raw.is_human.is_(True),\\n            Raw.human_data.is_not(None)).order_by(Raw.step.asc()).all()\\n        return [raw.human_data for raw in raws]\\n\\n    @classmethod\\n    def delete_interaction(cls, db: Session, interaction_id: str):\\n        \\\"\\\"\\\"\\n        delete interaction\\n\\n        Args:\\n            db (Session): db session\\n            interaction_id (str): interaction id\\n\\n        Returns:\\n            None\\n\\n        Raises:\\n            XAgentError: interaction is not exist\\n        \\\"\\\"\\\"\\n        interaction = db.query(Interaction).filter(\\n            Interaction.interaction_id == interaction_id).first()\\n        if interaction is None:\\n            raise XAgentError(\\\"interaction is not exist\\\")\\n        interaction.is_deleted = True\\n        db.commit()\\n\\n    @classmethod\\n    def add_share(cls, db: Session, shared: SharedInteractionBase):\\n        \\\"\\\"\\\"add share interaction\\n\\n        Args:\\n            db (Session): db session\\n            shared (SharedInteractionBase): shared interaction from community\\n        \\\"\\\"\\\"\\n        db.add(SharedInteraction(**shared.to_dict()))\\n\\n    @classmethod\\n    def insert_raw(cls, db: Session, process: XAgentRaw):\\n        \\\"\\\"\\\"\\n        insert an interaction process for recording\\n\\n        Args:\\n            db (Session): db session\\n            process (XAgentRaw): interaction process\\n\\n        Returns:\\n            None\\n\\n        Raises:\\n            XAgentError: interaction is not exist\\n        \\\"\\\"\\\"\\n        interaction = db.query(Interaction).filter(\\n            process.interaction_id == process.interaction_id).first()\\n        exist_process = db.query(Raw).filter(\\n            Raw.interaction_id == process.interaction_id, Raw.is_deleted.is_(False)).order_by(Raw.step.desc()).first()\\n        if interaction is None:\\n            raise XAgentError(\\\"interaction is not exist\\\")\\n\\n        if exist_process is not None:\\n            process.step = exist_process.step + 1\\n        else:\\n            process.step = 0\\n\\n        db.add(Raw(**process.to_dict()))\\n        db.commit()\\n\\n    @classmethod\\n    def search_many_raws(cls, db: Session, interaction_id: str):\\n        \\\"\\\"\\\"search many raws\\n\\n        Args:\\n            db (Session): db session\\n            interaction_id (str): interaction id\\n\\n        Returns:\\n            list[XAgentRaw]: interaction process list\\n        \\\"\\\"\\\"\\n        processes = db.query(Raw).filter(\\n            Raw.interaction_id == interaction_id, Raw.is_deleted.is_(False)).order_by(Raw.step.asc()).all()\\n        return processes\\n\\n    @classmethod\\n    def get_raw(cls, db: Session, interaction_id: str, node_id: str):\\n        \\\"\\\"\\\"\\n        get raw by interaction id and node id\\n        \\\"\\\"\\\"\\n        process = db.query(Raw).filter(\\n            Raw.interaction_id == interaction_id, Raw.node_id == node_id, Raw.is_deleted.is_(False)).first()\\n        return process\\n\\n    @classmethod\\n    def get_next_send(cls, db: Session, interaction_id: str):\\n        \\\"\\\"\\\"\\n        get next send process\\n\\n        Args:\\n            db (Session): db session\\n            interaction_id (str): interaction id\\n\\n        Returns:\\n            XAgentRaw: interaction process\\n        \\\"\\\"\\\"\\n        processes = db.query(Raw).filter(Raw.interaction_id == interaction_id,\\n                                         Raw.is_send.is_(False),\\n                                         Raw.is_deleted.is_(False)).order_by(Raw.step.desc()).all()\\n        return processes\\n\\n    @classmethod\\n    def update_send_flag(cls, db: Session, interaction_id: str, node_id: str):\\n        \\\"\\\"\\\"\\n        update send flag, if send success, update flag\\n        if send flag is True, it means that the process has been sent\\n        and no longer needs to be sent\\n\\n        Args:\\n            db (Session): db session\\n            interaction_id (str): interaction id\\n            node_id (str): node id\\n\\n        Returns:\\n            None\\n\\n        Raises:\\n            XAgentError: process is not exist\\n        \\\"\\\"\\\"\\n        process = db.query(Raw).filter(\\n            Raw.interaction_id == interaction_id, Raw.node_id == node_id).first()\\n        if process is None:\\n            raise XAgentError(\\\"process is not exist\\\")\\n        process.is_send = True\\n        process.update_time = datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\")\\n        db.commit()\\n\\n    @classmethod\\n    def update_receive_flag(cls, db: Session, interaction_id: str, node_id: str):\\n        \\\"\\\"\\\"\\n        update receive flag, if receive success, update flag\\n        if this flag is True, it means that the process has been received from human\\n\\n        Args:\\n            db (Session): db session\\n            interaction_id (str): interaction id\\n            node_id (str): node id\\n\\n        Returns:\\n            None\\n\\n        Raises:\\n            XAgentError: process is not exist\\n        \\\"\\\"\\\"\\n        process = db.query(Raw).filter(\\n            Raw.interaction_id == interaction_id, Raw.node_id == node_id).first()\\n        if process is None:\\n            raise XAgentError(\\\"process is not exist\\\")\\n        process.is_receive = True\\n        process.update_time = datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\")\\n        db.commit()\\n\\n    @classmethod\\n    def update_human_data(cls, db: Session, interaction_id: str, node_id: str, human_data: dict):\\n        \\\"\\\"\\\"\\n        update human data\\n\\n        Args:\\n            db (Session): db session\\n            interaction_id (str): interaction id\\n            node_id (str): node id\\n            human_data (dict): human data\\n\\n        Returns:\\n            None\\n\\n        Raises:\\n            XAgentError: process is not exist\\n        \\\"\\\"\\\"\\n        process = db.query(Raw).filter(\\n            Raw.interaction_id == interaction_id, Raw.node_id == node_id, Raw.is_deleted.is_(False)).first()\\n        if process is None:\\n            raise XAgentError(\\\"process is not exist\\\")\\n        process.is_receive = True\\n        process.is_human = True\\n        process.human_data = human_data\\n        db.commit()\\n\\n    @classmethod\\n    def insert_error(cls, db: Session, interaction_id: str, message: str):\\n        \\\"\\\"\\\"\\n        if interaction is failed, insert error message\\n        this message will be displayed in the interaction list\\n\\n        Args:\\n            db (Session): db session\\n            interaction_id (str): interaction id\\n            message (str): error message\\n\\n        Returns:\\n            None\\n\\n        Raises:\\n            None\\n\\n        \\\"\\\"\\\"\\n        process = Raw(\\n            node_id=uuid.uuid4().hex,\\n            interaction_id=interaction_id,\\n            current=\\\"\\\",\\n            step=0,\\n            data=message,\\n            file_list=[],\\n            status=StatusEnum.FAILED,\\n            create_time=datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\"),\\n            update_time=datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\")\\n        )\\n        db.add(process)\\n        db.commit()\\n\\n    @classmethod\\n    def get_finish_status(cls, db: Session, interaction_id: str):\\n        \\\"\\\"\\\"\\n        get interaction finish status\\n\\n        Args:\\n            db (Session): db session\\n            interaction_id (str): interaction id\\n\\n        Returns:\\n            Boolean: True or False\\n        \\\"\\\"\\\"\\n        process = db.query(Raw).filter(\\n            Raw.interaction_id == interaction_id,\\n            Raw.is_deleted.is_(False),\\n            Raw.status == \\\"finished\\\").first()\\n        return process is not None\\n\",\n            \"name_column\": 6\n        },\n        \"search_many_interaction\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"search_many_interaction\",\n            \"md_content\": \"\",\n            \"code_start_line\": 24,\n            \"code_end_line\": 34,\n            \"parent\": \"InteractionDBInterface\",\n            \"have_return\": true,\n            \"code_content\": \"    def search_many_interaction(cls, db: Session) -> list[InteractionBase]:\\n        \\\"\\\"\\\"search many interactions\\n\\n        Args:\\n            db (Session): db session\\n\\n        Returns:\\n            list[InteractionBase]: interaction list\\n        \\\"\\\"\\\"\\n        interactions = db.query(Interaction).all()\\n        return [InteractionBase.from_db(interaction) for interaction in interactions]\\n\",\n            \"name_column\": 8\n        },\n        \"get_interaction\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"get_interaction\",\n            \"md_content\": \"\",\n            \"code_start_line\": 37,\n            \"code_end_line\": 52,\n            \"parent\": \"InteractionDBInterface\",\n            \"have_return\": true,\n            \"code_content\": \"    def get_interaction(cls,\\n                        db: Session,\\n                        interaction_id: str) -> InteractionBase | None:\\n        \\\"\\\"\\\"get interaction by interaction_id\\n\\n        Args:\\n            db (Session): db session\\n            interaction_id (str): interaction id\\n\\n        Returns:\\n            InteractionBase | None: _description_\\n        \\\"\\\"\\\"\\n        interaction = db.query(Interaction).filter(\\n            Interaction.interaction_id == interaction_id,\\n            Interaction.is_deleted.is_not(True)).first()\\n        return InteractionBase.from_db(interaction) if interaction else None\\n\",\n            \"name_column\": 8\n        },\n        \"get_ready_interaction\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"get_ready_interaction\",\n            \"md_content\": \"\",\n            \"code_start_line\": 55,\n            \"code_end_line\": 70,\n            \"parent\": \"InteractionDBInterface\",\n            \"have_return\": true,\n            \"code_content\": \"    def get_ready_interaction(cls,\\n                              db: Session,\\n                              user_id: str) -> InteractionBase | None:\\n        \\\"\\\"\\\"get interaction by user_id\\n\\n        Args:\\n            db (Session): db session\\n            user_id (str): user id\\n\\n        Returns:\\n            InteractionBase | None: _description_\\n        \\\"\\\"\\\"\\n        interaction = db.query(Interaction).filter(\\n            Interaction.user_id == user_id,\\n            Interaction.status == 'ready').first()\\n        return InteractionBase.from_db(interaction) if interaction else None\\n\",\n            \"name_column\": 8\n        },\n        \"create_interaction\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"create_interaction\",\n            \"md_content\": \"\",\n            \"code_start_line\": 73,\n            \"code_end_line\": 88,\n            \"parent\": \"InteractionDBInterface\",\n            \"have_return\": true,\n            \"code_content\": \"    def create_interaction(cls,\\n                           db: Session,\\n                           base: InteractionBase) -> InteractionBase:\\n        \\\"\\\"\\\"\\n        create interaction\\n\\n        Args:\\n            db (Session): db session\\n            base (InteractionBase): interaction base\\n\\n        Returns:\\n            None\\n        \\\"\\\"\\\"\\n        db.add(Interaction(**base.to_dict()))\\n        db.commit()\\n        return None\\n\",\n            \"name_column\": 8\n        },\n        \"add_parameter\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"add_parameter\",\n            \"md_content\": \"\",\n            \"code_start_line\": 91,\n            \"code_end_line\": 100,\n            \"parent\": \"InteractionDBInterface\",\n            \"have_return\": true,\n            \"code_content\": \"    def add_parameter(cls,\\n                      db: Session,\\n                      parameter: InteractionParameter):\\n        \\\"\\\"\\\"\\n        add parameter for interaction\\n        \\\"\\\"\\\"\\n        db.add(Parameter(**parameter.to_dict()))\\n        db.commit()\\n\\n        return None\\n\",\n            \"name_column\": 8\n        },\n        \"search_interaction_by_user_id\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"search_interaction_by_user_id\",\n            \"md_content\": \"\",\n            \"code_start_line\": 103,\n            \"code_end_line\": 139,\n            \"parent\": \"InteractionDBInterface\",\n            \"have_return\": true,\n            \"code_content\": \"    def search_interaction_by_user_id(cls,\\n                                      db: Session,\\n                                      user_id: str,\\n                                      page_size: int = 20,\\n                                      page_num: int = 1) -> list[dict]:\\n        \\\"\\\"\\\"\\n        search interaction by user id\\n\\n        Args:\\n            db (Session): db session\\n            user_id (str): user id\\n            page_size (int, optional): page size. Defaults to 20.\\n            page_num (int, optional): page num. Defaults to 1.\\n\\n        Returns:\\n            list[dict]: interaction list\\n        \\\"\\\"\\\"\\n        total = db.query(func.count(Interaction.id)).filter(\\n            Interaction.user_id == user_id, Interaction.is_deleted.is_(False)).scalar()\\n\\n        interaction_list = db.query(Interaction).filter(\\n            Interaction.user_id == user_id,\\n            Interaction.is_deleted.is_(False),\\n            Interaction.status.in_([StatusEnum.FINISHED])).limit(\\n            page_size).offset((page_num - 1) * page_size).all()\\n        data = []\\n        for interaction in interaction_list:\\n            d_ = InteractionBase.from_db(interaction).to_dict(\\n                exclude=[\\\"recorder_root_dir\\\", \\\"is_deleted\\\"])\\n            parameter = cls.get_parameter(\\n                db=db, interaction_id=d_[\\\"interaction_id\\\"])\\n            d_[\\\"parameters\\\"] = [parameter[0]]\\n            data.append(d_)\\n        return {\\n            \\\"total\\\": total,\\n            \\\"rows\\\": data\\n        }\\n\",\n            \"name_column\": 8\n        },\n        \"search_many_shared\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"search_many_shared\",\n            \"md_content\": \"\",\n            \"code_start_line\": 142,\n            \"code_end_line\": 176,\n            \"parent\": \"InteractionDBInterface\",\n            \"have_return\": true,\n            \"code_content\": \"    def search_many_shared(cls,\\n                           db: Session,\\n                           page_size: int = 20,\\n                           page_index: int = 1) -> list[dict]:\\n        \\\"\\\"\\\"\\n        search many shared interactions from community\\n\\n        Args:\\n            db (Session): db session\\n            page_size (int, optional): page size. Defaults to 20.\\n            page_index (int, optional): page index. Defaults to 1.\\n\\n        Returns:\\n            list[dict]: interaction list\\n        \\\"\\\"\\\"\\n        total = db.query(func.count(SharedInteraction.id)).filter(\\n            SharedInteraction.is_deleted.is_(False),\\n            SharedInteraction.is_audit.is_(True)).scalar()\\n        interaction_list = db.query(SharedInteraction).filter(\\n            SharedInteraction.is_deleted.is_(False),\\n            SharedInteraction.is_audit.is_(True)).order_by(\\n            SharedInteraction.star.desc()).limit(page_size).offset(\\n                (page_index - 1) * page_size).all()\\n        data = []\\n        for interaction in interaction_list:\\n            d_ = SharedInteractionBase.from_db(interaction).to_dict(\\n                exclude=[\\\"record_dir\\\", \\\"is_deleted\\\"])\\n            parameter = cls.get_parameter(\\n                db=db, interaction_id=d_[\\\"interaction_id\\\"])\\n            d_[\\\"parameters\\\"] = parameter\\n            data.append(d_)\\n        return {\\n            \\\"total\\\": total,\\n            \\\"rows\\\": data\\n        }\\n\",\n            \"name_column\": 8\n        },\n        \"get_shared_interaction\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"get_shared_interaction\",\n            \"md_content\": \"\",\n            \"code_start_line\": 179,\n            \"code_end_line\": 195,\n            \"parent\": \"InteractionDBInterface\",\n            \"have_return\": true,\n            \"code_content\": \"    def get_shared_interaction(cls,\\n                               db: Session,\\n                               interaction_id: str) -> SharedInteractionBase | None:\\n        \\\"\\\"\\\"\\n        get shared interaction by interaction id\\n\\n        Args:\\n            db (Session): db session\\n            interaction_id (str): interaction id\\n\\n        Returns:\\n\\n            SharedInteractionBase | None: shared interaction\\n        \\\"\\\"\\\"\\n        interaction = db.query(SharedInteraction).filter(\\n            SharedInteraction.interaction_id == interaction_id, SharedInteraction.is_deleted.is_(False)).first()\\n        return SharedInteractionBase.from_db(interaction) if interaction else None\\n\",\n            \"name_column\": 8\n        },\n        \"is_exist\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"is_exist\",\n            \"md_content\": \"\",\n            \"code_start_line\": 198,\n            \"code_end_line\": 214,\n            \"parent\": \"InteractionDBInterface\",\n            \"have_return\": true,\n            \"code_content\": \"    def is_exist(cls,\\n                 db: Session,\\n                 interaction_id: str) -> bool:\\n        \\\"\\\"\\\"\\n        check interaction is exist or not\\n\\n        Args:\\n            db (Session): db session\\n            interaction_id (str): interaction id\\n\\n        Returns:\\n            bool: True or False\\n        \\\"\\\"\\\"\\n        interaction = db.query(Interaction).filter(\\n            Interaction.interaction_id == interaction_id,\\n            Interaction.is_deleted.is_(False)).first()\\n        return interaction is not None\\n\",\n            \"name_column\": 8\n        },\n        \"update_interaction\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"update_interaction\",\n            \"md_content\": \"\",\n            \"code_start_line\": 217,\n            \"code_end_line\": 239,\n            \"parent\": \"InteractionDBInterface\",\n            \"have_return\": false,\n            \"code_content\": \"    def update_interaction(cls, db: Session, base_data: dict):\\n        \\\"\\\"\\\"\\n        update interaction\\n\\n        Args:\\n            db (Session): db session\\n            base_data (dict): interaction data\\n\\n        Returns:\\n            None\\n        \\\"\\\"\\\"\\n        if \\\"interaction_id\\\" not in base_data:\\n            raise XAgentError(\\\"interaction_id is required\\\")\\n        interaction = db.query(Interaction).filter(\\n            Interaction.interaction_id == base_data[\\\"interaction_id\\\"]).first()\\n        if interaction is None:\\n            raise XAgentError(\\\"interaction is not exist\\\")\\n        for k, v in base_data.items():\\n            if k == \\\"interaction_id\\\":\\n                continue\\n            setattr(interaction, k, v)\\n        interaction.update_time = datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\")\\n        db.commit()\\n\",\n            \"name_column\": 8\n        },\n        \"update_interaction_status\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"update_interaction_status\",\n            \"md_content\": \"\",\n            \"code_start_line\": 242,\n            \"code_end_line\": 270,\n            \"parent\": \"InteractionDBInterface\",\n            \"have_return\": false,\n            \"code_content\": \"    def update_interaction_status(cls,\\n                                  db: Session,\\n                                  interaction_id: str,\\n                                  status: str,\\n                                  message: str,\\n                                  current_step: int):\\n        \\\"\\\"\\\"\\n        update interaction status\\n\\n        Args:\\n            db (Session): db session\\n            interaction_id (str): interaction id\\n            status (str): status\\n            message (str): message\\n            current_step (int): current step\\n\\n        Returns:\\n            None\\n        \\\"\\\"\\\"\\n        db_interaction = db.query(Interaction).filter(\\n            Interaction.interaction_id == interaction_id).first()\\n        if db_interaction is None:\\n            raise XAgentError(\\\"interaction is not exist\\\")\\n\\n        db_interaction.status = status\\n        db_interaction.message = message\\n        db_interaction.current_step = current_step\\n        db_interaction.update_time = datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\")\\n        db.commit()\\n\",\n            \"name_column\": 8\n        },\n        \"update_interaction_parameter\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"update_interaction_parameter\",\n            \"md_content\": \"\",\n            \"code_start_line\": 273,\n            \"code_end_line\": 294,\n            \"parent\": \"InteractionDBInterface\",\n            \"have_return\": false,\n            \"code_content\": \"    def update_interaction_parameter(cls,\\n                                     db: Session,\\n                                     interaction_id: str,\\n                                     parameter: InteractionParameter):\\n        \\\"\\\"\\\"\\n        update interaction parameter\\n\\n        Args:\\n            db (Session): db session\\n            interaction_id (str): interaction id\\n            parameter (InteractionParameter): parameter\\n\\n        Returns:\\n            None\\n        \\\"\\\"\\\"\\n        db_parameter = db.query(Parameter).filter(\\n            Parameter.interaction_id == interaction_id,\\n            Parameter.parameter_id == parameter.parameter_id).first()\\n\\n        if db_parameter is None:\\n            db.add(Parameter(**parameter.to_dict()))\\n        db.commit()\\n\",\n            \"name_column\": 8\n        },\n        \"is_running\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"is_running\",\n            \"md_content\": \"\",\n            \"code_start_line\": 297,\n            \"code_end_line\": 311,\n            \"parent\": \"InteractionDBInterface\",\n            \"have_return\": true,\n            \"code_content\": \"    def is_running(cls, db: Session, user_id: str):\\n        \\\"\\\"\\\"\\n        check user is only running one interaction\\n\\n        Args:\\n            db (Session): db session\\n            user_id (str): user id\\n\\n        Returns:    \\n            bool: True or False\\n        \\\"\\\"\\\"\\n        interaction = db.query(Interaction).filter(\\n            Interaction.user_id == user_id,\\n            Interaction.status.in_((\\\"running\\\", \\\"waiting\\\"))).first()\\n        return interaction is not None\\n\",\n            \"name_column\": 8\n        },\n        \"get_parameter\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"get_parameter\",\n            \"md_content\": \"\",\n            \"code_start_line\": 314,\n            \"code_end_line\": 329,\n            \"parent\": \"InteractionDBInterface\",\n            \"have_return\": true,\n            \"code_content\": \"    def get_parameter(cls, db: Session, interaction_id: str) -> list:\\n        \\\"\\\"\\\"\\n        get interaction running parameter\\n\\n        Args:\\n            db (Session): db session\\n            interaction_id (str): interaction id\\n\\n        Returns:\\n            list: parameter list\\n        \\\"\\\"\\\"\\n        raws = db.query(Raw).filter(\\n            Raw.interaction_id == interaction_id,\\n            Raw.is_human.is_(True),\\n            Raw.human_data.is_not(None)).order_by(Raw.step.asc()).all()\\n        return [raw.human_data for raw in raws]\\n\",\n            \"name_column\": 8\n        },\n        \"delete_interaction\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"delete_interaction\",\n            \"md_content\": \"\",\n            \"code_start_line\": 332,\n            \"code_end_line\": 351,\n            \"parent\": \"InteractionDBInterface\",\n            \"have_return\": false,\n            \"code_content\": \"    def delete_interaction(cls, db: Session, interaction_id: str):\\n        \\\"\\\"\\\"\\n        delete interaction\\n\\n        Args:\\n            db (Session): db session\\n            interaction_id (str): interaction id\\n\\n        Returns:\\n            None\\n\\n        Raises:\\n            XAgentError: interaction is not exist\\n        \\\"\\\"\\\"\\n        interaction = db.query(Interaction).filter(\\n            Interaction.interaction_id == interaction_id).first()\\n        if interaction is None:\\n            raise XAgentError(\\\"interaction is not exist\\\")\\n        interaction.is_deleted = True\\n        db.commit()\\n\",\n            \"name_column\": 8\n        },\n        \"add_share\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"add_share\",\n            \"md_content\": \"\",\n            \"code_start_line\": 354,\n            \"code_end_line\": 361,\n            \"parent\": \"InteractionDBInterface\",\n            \"have_return\": false,\n            \"code_content\": \"    def add_share(cls, db: Session, shared: SharedInteractionBase):\\n        \\\"\\\"\\\"add share interaction\\n\\n        Args:\\n            db (Session): db session\\n            shared (SharedInteractionBase): shared interaction from community\\n        \\\"\\\"\\\"\\n        db.add(SharedInteraction(**shared.to_dict()))\\n\",\n            \"name_column\": 8\n        },\n        \"insert_raw\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"insert_raw\",\n            \"md_content\": \"\",\n            \"code_start_line\": 364,\n            \"code_end_line\": 391,\n            \"parent\": \"InteractionDBInterface\",\n            \"have_return\": false,\n            \"code_content\": \"    def insert_raw(cls, db: Session, process: XAgentRaw):\\n        \\\"\\\"\\\"\\n        insert an interaction process for recording\\n\\n        Args:\\n            db (Session): db session\\n            process (XAgentRaw): interaction process\\n\\n        Returns:\\n            None\\n\\n        Raises:\\n            XAgentError: interaction is not exist\\n        \\\"\\\"\\\"\\n        interaction = db.query(Interaction).filter(\\n            process.interaction_id == process.interaction_id).first()\\n        exist_process = db.query(Raw).filter(\\n            Raw.interaction_id == process.interaction_id, Raw.is_deleted.is_(False)).order_by(Raw.step.desc()).first()\\n        if interaction is None:\\n            raise XAgentError(\\\"interaction is not exist\\\")\\n\\n        if exist_process is not None:\\n            process.step = exist_process.step + 1\\n        else:\\n            process.step = 0\\n\\n        db.add(Raw(**process.to_dict()))\\n        db.commit()\\n\",\n            \"name_column\": 8\n        },\n        \"search_many_raws\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"search_many_raws\",\n            \"md_content\": \"\",\n            \"code_start_line\": 394,\n            \"code_end_line\": 406,\n            \"parent\": \"InteractionDBInterface\",\n            \"have_return\": true,\n            \"code_content\": \"    def search_many_raws(cls, db: Session, interaction_id: str):\\n        \\\"\\\"\\\"search many raws\\n\\n        Args:\\n            db (Session): db session\\n            interaction_id (str): interaction id\\n\\n        Returns:\\n            list[XAgentRaw]: interaction process list\\n        \\\"\\\"\\\"\\n        processes = db.query(Raw).filter(\\n            Raw.interaction_id == interaction_id, Raw.is_deleted.is_(False)).order_by(Raw.step.asc()).all()\\n        return processes\\n\",\n            \"name_column\": 8\n        },\n        \"get_raw\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"get_raw\",\n            \"md_content\": \"\",\n            \"code_start_line\": 409,\n            \"code_end_line\": 415,\n            \"parent\": \"InteractionDBInterface\",\n            \"have_return\": true,\n            \"code_content\": \"    def get_raw(cls, db: Session, interaction_id: str, node_id: str):\\n        \\\"\\\"\\\"\\n        get raw by interaction id and node id\\n        \\\"\\\"\\\"\\n        process = db.query(Raw).filter(\\n            Raw.interaction_id == interaction_id, Raw.node_id == node_id, Raw.is_deleted.is_(False)).first()\\n        return process\\n\",\n            \"name_column\": 8\n        },\n        \"get_next_send\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"get_next_send\",\n            \"md_content\": \"\",\n            \"code_start_line\": 418,\n            \"code_end_line\": 432,\n            \"parent\": \"InteractionDBInterface\",\n            \"have_return\": true,\n            \"code_content\": \"    def get_next_send(cls, db: Session, interaction_id: str):\\n        \\\"\\\"\\\"\\n        get next send process\\n\\n        Args:\\n            db (Session): db session\\n            interaction_id (str): interaction id\\n\\n        Returns:\\n            XAgentRaw: interaction process\\n        \\\"\\\"\\\"\\n        processes = db.query(Raw).filter(Raw.interaction_id == interaction_id,\\n                                         Raw.is_send.is_(False),\\n                                         Raw.is_deleted.is_(False)).order_by(Raw.step.desc()).all()\\n        return processes\\n\",\n            \"name_column\": 8\n        },\n        \"update_send_flag\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"update_send_flag\",\n            \"md_content\": \"\",\n            \"code_start_line\": 435,\n            \"code_end_line\": 458,\n            \"parent\": \"InteractionDBInterface\",\n            \"have_return\": false,\n            \"code_content\": \"    def update_send_flag(cls, db: Session, interaction_id: str, node_id: str):\\n        \\\"\\\"\\\"\\n        update send flag, if send success, update flag\\n        if send flag is True, it means that the process has been sent\\n        and no longer needs to be sent\\n\\n        Args:\\n            db (Session): db session\\n            interaction_id (str): interaction id\\n            node_id (str): node id\\n\\n        Returns:\\n            None\\n\\n        Raises:\\n            XAgentError: process is not exist\\n        \\\"\\\"\\\"\\n        process = db.query(Raw).filter(\\n            Raw.interaction_id == interaction_id, Raw.node_id == node_id).first()\\n        if process is None:\\n            raise XAgentError(\\\"process is not exist\\\")\\n        process.is_send = True\\n        process.update_time = datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\")\\n        db.commit()\\n\",\n            \"name_column\": 8\n        },\n        \"update_receive_flag\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"update_receive_flag\",\n            \"md_content\": \"\",\n            \"code_start_line\": 461,\n            \"code_end_line\": 483,\n            \"parent\": \"InteractionDBInterface\",\n            \"have_return\": false,\n            \"code_content\": \"    def update_receive_flag(cls, db: Session, interaction_id: str, node_id: str):\\n        \\\"\\\"\\\"\\n        update receive flag, if receive success, update flag\\n        if this flag is True, it means that the process has been received from human\\n\\n        Args:\\n            db (Session): db session\\n            interaction_id (str): interaction id\\n            node_id (str): node id\\n\\n        Returns:\\n            None\\n\\n        Raises:\\n            XAgentError: process is not exist\\n        \\\"\\\"\\\"\\n        process = db.query(Raw).filter(\\n            Raw.interaction_id == interaction_id, Raw.node_id == node_id).first()\\n        if process is None:\\n            raise XAgentError(\\\"process is not exist\\\")\\n        process.is_receive = True\\n        process.update_time = datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\")\\n        db.commit()\\n\",\n            \"name_column\": 8\n        },\n        \"update_human_data\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"update_human_data\",\n            \"md_content\": \"\",\n            \"code_start_line\": 486,\n            \"code_end_line\": 509,\n            \"parent\": \"InteractionDBInterface\",\n            \"have_return\": false,\n            \"code_content\": \"    def update_human_data(cls, db: Session, interaction_id: str, node_id: str, human_data: dict):\\n        \\\"\\\"\\\"\\n        update human data\\n\\n        Args:\\n            db (Session): db session\\n            interaction_id (str): interaction id\\n            node_id (str): node id\\n            human_data (dict): human data\\n\\n        Returns:\\n            None\\n\\n        Raises:\\n            XAgentError: process is not exist\\n        \\\"\\\"\\\"\\n        process = db.query(Raw).filter(\\n            Raw.interaction_id == interaction_id, Raw.node_id == node_id, Raw.is_deleted.is_(False)).first()\\n        if process is None:\\n            raise XAgentError(\\\"process is not exist\\\")\\n        process.is_receive = True\\n        process.is_human = True\\n        process.human_data = human_data\\n        db.commit()\\n\",\n            \"name_column\": 8\n        },\n        \"insert_error\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"insert_error\",\n            \"md_content\": \"\",\n            \"code_start_line\": 512,\n            \"code_end_line\": 541,\n            \"parent\": \"InteractionDBInterface\",\n            \"have_return\": false,\n            \"code_content\": \"    def insert_error(cls, db: Session, interaction_id: str, message: str):\\n        \\\"\\\"\\\"\\n        if interaction is failed, insert error message\\n        this message will be displayed in the interaction list\\n\\n        Args:\\n            db (Session): db session\\n            interaction_id (str): interaction id\\n            message (str): error message\\n\\n        Returns:\\n            None\\n\\n        Raises:\\n            None\\n\\n        \\\"\\\"\\\"\\n        process = Raw(\\n            node_id=uuid.uuid4().hex,\\n            interaction_id=interaction_id,\\n            current=\\\"\\\",\\n            step=0,\\n            data=message,\\n            file_list=[],\\n            status=StatusEnum.FAILED,\\n            create_time=datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\"),\\n            update_time=datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\")\\n        )\\n        db.add(process)\\n        db.commit()\\n\",\n            \"name_column\": 8\n        },\n        \"get_finish_status\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"get_finish_status\",\n            \"md_content\": \"\",\n            \"code_start_line\": 544,\n            \"code_end_line\": 559,\n            \"parent\": \"InteractionDBInterface\",\n            \"have_return\": true,\n            \"code_content\": \"    def get_finish_status(cls, db: Session, interaction_id: str):\\n        \\\"\\\"\\\"\\n        get interaction finish status\\n\\n        Args:\\n            db (Session): db session\\n            interaction_id (str): interaction id\\n\\n        Returns:\\n            Boolean: True or False\\n        \\\"\\\"\\\"\\n        process = db.query(Raw).filter(\\n            Raw.interaction_id == interaction_id,\\n            Raw.is_deleted.is_(False),\\n            Raw.status == \\\"finished\\\").first()\\n        return process is not None\\n\",\n            \"name_column\": 8\n        }\n    },\n    \"XAgentServer/database/interface/recorder.py\": {\n        \"RecordDBInterface\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"RecordDBInterface\",\n            \"md_content\": \"\",\n            \"code_start_line\": 10,\n            \"code_end_line\": 99,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"class RecordDBInterface(metaclass=abc.ABCMeta):\\n    \\\"\\\"\\\"Recorder DB Interface\\n\\n    Args:\\n        RecorderBaseInterface (_type_): _description_\\n        metaclass (_type_, optional): _description_. Defaults to abc.ABCMeta.\\n    \\\"\\\"\\\"\\n\\n    @classmethod\\n    def get_record_list(cls, db: Session, record_id: str) -> list[XAgentRunningRecord]:\\n        \\\"\\\"\\\"get all records\\n\\n        Args:\\n            db (Session): db\\n\\n        Returns:\\n            list[XAgentRunningRecord]: Recorder list\\n        \\\"\\\"\\\"\\n        records = db.query(RunningRecord).filter(\\n            RunningRecord.record_id == record_id).all()\\n        return [XAgentRunningRecord.from_db(Recorder) for Recorder in records]\\n\\n    @classmethod\\n    def get_record(cls,\\n                     db: Session,\\n                     record_id: str | None = None\\n                     ) -> XAgentRunningRecord | None:\\n        \\\"\\\"\\\"get Recorder by Recorder_id or email\\n\\n        Args:\\n            db (Session): db\\n            Recorder_id (str | None, optional): Recorder id. Defaults to None.\\n            email (str | None, optional): email. Defaults to None.\\n\\n        Returns:\\n            XAgentRunningRecord | None: Recorder, if Recorder is not exist, return None\\n        \\\"\\\"\\\"\\n        record = db.query(RunningRecord).filter(RunningRecord.record_id == record_id,\\n                                                  RunningRecord.deleted.is_(False)).first()\\n\\n        return XAgentRunningRecord.from_db(record) if record else None\\n\\n    @classmethod\\n    def insert_record(cls,\\n                      db: Session,\\n                      record: XAgentRunningRecord):\\n        \\\"\\\"\\\"insert Recorder\\n\\n        Args:\\n            db (Session): db\\n            record (XAgentRunningRecord): Recorder\\n        \\\"\\\"\\\"\\n        db_record = RunningRecord(**record.to_dict())\\n        db.add(db_record)\\n        db.commit()\\n        db.refresh(db_record)\\n        return db_record\\n    \\n    @classmethod\\n    def get_record_by_type(cls,\\n                           db: Session,\\n                           record_id: str,\\n                           node_id: str = \\\"\\\",\\n                           node_type: str = \\\"\\\") -> list[XAgentRunningRecord]:\\n        \\\"\\\"\\\"get Recorder by type\\n\\n        Args:\\n            db (Session): db\\n            record_id (str): record id\\n            node_id (str): node id\\n            node_type (str): node type\\n\\n        Returns:\\n            list[XAgentRunningRecord]: Recorder list\\n        \\\"\\\"\\\"\\n\\n        filters = [RunningRecord.deleted.is_(False)]\\n\\n        if record_id:\\n            filters.append(RunningRecord.record_id == record_id)\\n\\n        if node_id:\\n            filters.append(RunningRecord.node_id == node_id)\\n\\n        if node_type:\\n            filters.append(RunningRecord.node_type == node_type)\\n\\n        records = db.query(RunningRecord).filter(*filters).all()\\n\\n        return [XAgentRunningRecord.from_db(Recorder) for Recorder in records]\\n\",\n            \"name_column\": 6\n        },\n        \"get_record_list\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"get_record_list\",\n            \"md_content\": \"\",\n            \"code_start_line\": 19,\n            \"code_end_line\": 30,\n            \"parent\": \"RecordDBInterface\",\n            \"have_return\": true,\n            \"code_content\": \"    def get_record_list(cls, db: Session, record_id: str) -> list[XAgentRunningRecord]:\\n        \\\"\\\"\\\"get all records\\n\\n        Args:\\n            db (Session): db\\n\\n        Returns:\\n            list[XAgentRunningRecord]: Recorder list\\n        \\\"\\\"\\\"\\n        records = db.query(RunningRecord).filter(\\n            RunningRecord.record_id == record_id).all()\\n        return [XAgentRunningRecord.from_db(Recorder) for Recorder in records]\\n\",\n            \"name_column\": 8\n        },\n        \"get_record\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"get_record\",\n            \"md_content\": \"\",\n            \"code_start_line\": 33,\n            \"code_end_line\": 50,\n            \"parent\": \"RecordDBInterface\",\n            \"have_return\": true,\n            \"code_content\": \"    def get_record(cls,\\n                     db: Session,\\n                     record_id: str | None = None\\n                     ) -> XAgentRunningRecord | None:\\n        \\\"\\\"\\\"get Recorder by Recorder_id or email\\n\\n        Args:\\n            db (Session): db\\n            Recorder_id (str | None, optional): Recorder id. Defaults to None.\\n            email (str | None, optional): email. Defaults to None.\\n\\n        Returns:\\n            XAgentRunningRecord | None: Recorder, if Recorder is not exist, return None\\n        \\\"\\\"\\\"\\n        record = db.query(RunningRecord).filter(RunningRecord.record_id == record_id,\\n                                                  RunningRecord.deleted.is_(False)).first()\\n\\n        return XAgentRunningRecord.from_db(record) if record else None\\n\",\n            \"name_column\": 8\n        },\n        \"insert_record\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"insert_record\",\n            \"md_content\": \"\",\n            \"code_start_line\": 53,\n            \"code_end_line\": 66,\n            \"parent\": \"RecordDBInterface\",\n            \"have_return\": true,\n            \"code_content\": \"    def insert_record(cls,\\n                      db: Session,\\n                      record: XAgentRunningRecord):\\n        \\\"\\\"\\\"insert Recorder\\n\\n        Args:\\n            db (Session): db\\n            record (XAgentRunningRecord): Recorder\\n        \\\"\\\"\\\"\\n        db_record = RunningRecord(**record.to_dict())\\n        db.add(db_record)\\n        db.commit()\\n        db.refresh(db_record)\\n        return db_record\\n\",\n            \"name_column\": 8\n        },\n        \"get_record_by_type\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"get_record_by_type\",\n            \"md_content\": \"\",\n            \"code_start_line\": 69,\n            \"code_end_line\": 99,\n            \"parent\": \"RecordDBInterface\",\n            \"have_return\": true,\n            \"code_content\": \"    def get_record_by_type(cls,\\n                           db: Session,\\n                           record_id: str,\\n                           node_id: str = \\\"\\\",\\n                           node_type: str = \\\"\\\") -> list[XAgentRunningRecord]:\\n        \\\"\\\"\\\"get Recorder by type\\n\\n        Args:\\n            db (Session): db\\n            record_id (str): record id\\n            node_id (str): node id\\n            node_type (str): node type\\n\\n        Returns:\\n            list[XAgentRunningRecord]: Recorder list\\n        \\\"\\\"\\\"\\n\\n        filters = [RunningRecord.deleted.is_(False)]\\n\\n        if record_id:\\n            filters.append(RunningRecord.record_id == record_id)\\n\\n        if node_id:\\n            filters.append(RunningRecord.node_id == node_id)\\n\\n        if node_type:\\n            filters.append(RunningRecord.node_type == node_type)\\n\\n        records = db.query(RunningRecord).filter(*filters).all()\\n\\n        return [XAgentRunningRecord.from_db(Recorder) for Recorder in records]\\n\",\n            \"name_column\": 8\n        }\n    },\n    \"XAgentServer/loggers/logs.py\": {\n        \"JsonFileHandler\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"JsonFileHandler\",\n            \"md_content\": \"\",\n            \"code_start_line\": 16,\n            \"code_end_line\": 24,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"class JsonFileHandler(logging.FileHandler):\\n    \\\"\\\"\\\"JsonFileHandler\\\"\\\"\\\"\\n    def __init__(self, filename, mode=\\\"a\\\", encoding=None, delay=False):\\n        super().__init__(filename, mode, encoding, delay)\\n\\n    def emit(self, record):\\n        json_data = json.loads(self.format(record))\\n        with open(self.baseFilename, \\\"w\\\", encoding=\\\"utf-8\\\") as f:\\n            json.dump(json_data, f, ensure_ascii=False, indent=4)\\n\",\n            \"name_column\": 6\n        },\n        \"JsonFormatter\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"JsonFormatter\",\n            \"md_content\": \"\",\n            \"code_start_line\": 27,\n            \"code_end_line\": 30,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"class JsonFormatter(logging.Formatter):\\n    \\\"\\\"\\\"Json Formatter\\\"\\\"\\\"\\n    def format(self, record):\\n        return record.msg\\n\",\n            \"name_column\": 6\n        },\n        \"Logger\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"Logger\",\n            \"md_content\": \"\",\n            \"code_start_line\": 33,\n            \"code_end_line\": 191,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"class Logger(metaclass=abc.ABCMeta):\\n    \\\"\\\"\\\"\\n    Logger that handle titles in different colors.\\n    Outputs logs in console, activity.log, and errors.log\\n    For console handler: simulates typing\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, log_dir: str = None, log_name: str= \\\"\\\", log_file: str = \\\"activity.log\\\", error_file: str = \\\"errors.log\\\"):\\n        \\\"\\\"\\\"init\\\"\\\"\\\"\\n        if not os.path.exists(log_dir):\\n            os.makedirs(log_dir)\\n\\n        # create log directory if it doesn't exist\\n        self.log_name = time.strftime(\\\"%Y-%m-%d\\\", time.localtime()) if not log_name else log_name\\n        self.logger = logging.getLogger(self.log_name)\\n        console_formatter = RecordFormatter(\\\"%(title_color)s %(message)s\\\")\\n\\n        # Create a handler for console which simulate typing\\n        self.typing_console_handler = TypingConsoleHandler()\\n        self.typing_console_handler.setLevel(logging.INFO)\\n        self.typing_console_handler.setFormatter(console_formatter)\\n\\n        # Create a handler for console without typing simulation\\n        self.console_handler = ConsoleHandler()\\n        self.console_handler.setLevel(logging.DEBUG)\\n        self.console_handler.setFormatter(console_formatter)\\n\\n        self.speak_mode = False\\n        self.chat_plugins = []\\n\\n        # Info handler in activity.log\\n        self.file_handler = logging.FileHandler(\\n            os.path.join(log_dir, log_file), \\\"a\\\", \\\"utf-8\\\"\\n        )\\n        self.file_handler.setLevel(logging.DEBUG)\\n        info_formatter = RecordFormatter(\\n            \\\"%(asctime)s [%(threadName)s] %(levelname)s: %(title_color)s %(title)s %(message)s\\\"\\n        )\\n        self.file_handler.setFormatter(info_formatter)\\n\\n        # Error handler error.log\\n        error_handler = logging.FileHandler(\\n            os.path.join(log_dir, error_file), \\\"a\\\", \\\"utf-8\\\"\\n        )\\n        error_handler.setLevel(logging.ERROR)\\n        error_formatter = RecordFormatter(\\n            \\\"%(asctime)s [%(threadName)s] %(levelname)s %(module)s:%(funcName)s:%(lineno)d %(title_color)s %(title)s\\\"\\n            \\\" %(message_no_color)s\\\"\\n        )\\n        error_handler.setFormatter(error_formatter)\\n\\n        # self.typing_logger = logging.getLogger(self.log_name)\\n        # if not self.typing_logger.handlers:\\n        #     self.typing_logger.addHandler(self.typing_console_handler)\\n        #     self.typing_logger.addHandler(self.file_handler)\\n        #     self.typing_logger.addHandler(error_handler)\\n        # self.typing_logger.setLevel(logging.DEBUG)\\n\\n        if self.log_name.endswith(\\\"_INTERACT\\\") or not self.logger.handlers:\\n            # self.logger.addHandler(self.typing_console_handler)\\n            self.logger.addHandler(self.console_handler)\\n            self.logger.addHandler(error_handler)\\n            self.logger.addHandler(self.file_handler)\\n            self.logger.setLevel(logging.DEBUG)\\n    \\n    def typewriter_log(\\n        self, title=\\\"\\\", title_color=\\\"\\\", content=\\\"\\\", speak_text=False, level=logging.INFO\\n    ):\\n        # if speak_text and self.speak_mode:\\n        #     say_text(f\\\"{title}. {content}\\\")\\n\\n        for plugin in self.chat_plugins:\\n            plugin.report(f\\\"{title}. {content}\\\")\\n\\n        if content:\\n            if isinstance(content, list):\\n                content = \\\" \\\".join(content)\\n        else:\\n            content = \\\"\\\"\\n\\n        self.logger.log(\\n            level, content, extra={\\\"title\\\": title, \\\"color\\\": title_color}\\n        )\\n\\n    def debug(\\n        self,\\n        message,\\n        title=\\\"\\\",\\n        title_color=\\\"\\\",\\n    ):\\n        self._log(title, title_color, message, logging.DEBUG)\\n\\n    def info(\\n        self,\\n        message,\\n        title=\\\"\\\",\\n        title_color=\\\"\\\",\\n    ):\\n        self._log(title, title_color, message, logging.INFO)\\n\\n    def warn(\\n        self,\\n        message,\\n        title=\\\"\\\",\\n        title_color=\\\"\\\",\\n    ):\\n        self._log(title, title_color, message, logging.WARN)\\n\\n    def error(self, title, message=\\\"\\\"):\\n        self._log(title, Fore.RED, message, logging.ERROR)\\n\\n    def _log(\\n        self,\\n        title: str = \\\"\\\",\\n        title_color: str = \\\"\\\",\\n        message: str = \\\"\\\",\\n        level=logging.INFO,\\n    ):\\n        if message:\\n            if isinstance(message, list):\\n                message = \\\" \\\".join(message)\\n        self.logger.log(\\n            level, message, extra={\\\"title\\\": str(title), \\\"color\\\": str(title_color)}\\n        )\\n\\n    def set_level(self, level):\\n        self.logger.setLevel(level)\\n        self.typing_logger.setLevel(level)\\n\\n    def double_check(self, additionalText=None):\\n        if not additionalText:\\n            additionalText = (\\n                \\\"Please ensure you've setup and configured everything\\\"\\n                \\\" correctly. Read https://github.com/Torantulino/Auto-GPT#readme to \\\"\\n                \\\"double check. You can also create a github issue or join the discord\\\"\\n                \\\" and ask there!\\\"\\n            )\\n\\n        self.typewriter_log(\\\"DOUBLE CHECK CONFIGURATION\\\", Fore.YELLOW, additionalText)\\n\\n    def log_json(self, data: Any, file_name: str) -> None:\\n        # Define log directory\\n        this_files_dir_path = os.path.dirname(__file__)\\n        log_dir = os.path.join(this_files_dir_path, \\\"../logs\\\")\\n\\n        # Create a handler for JSON files\\n        json_file_path = os.path.join(log_dir, file_name)\\n        json_data_handler = JsonFileHandler(json_file_path)\\n        json_data_handler.setFormatter(JsonFormatter())\\n\\n        # Log the JSON data using the custom file handler\\n        self.json_logger.addHandler(json_data_handler)\\n        self.json_logger.debug(data)\\n        self.json_logger.removeHandler(json_data_handler)\\n\\n    def get_log_directory(self):\\n        this_files_dir_path = os.path.dirname(__file__)\\n        log_dir = os.path.join(this_files_dir_path, \\\"../logs\\\")\\n        return os.path.abspath(log_dir)\\n\",\n            \"name_column\": 6\n        },\n        \"TypingConsoleHandler\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"TypingConsoleHandler\",\n            \"md_content\": \"\",\n            \"code_start_line\": 199,\n            \"code_end_line\": 218,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"class TypingConsoleHandler(logging.StreamHandler):\\n    def emit(self, record):\\n        min_typing_speed = 0.05\\n        max_typing_speed = 0.01\\n\\n        msg = self.format(record)\\n        try:\\n            words = msg.split()\\n            for i, word in enumerate(words):\\n                print(word, end=\\\"\\\", flush=True)\\n                if i < len(words) - 1:\\n                    print(\\\" \\\", end=\\\"\\\", flush=True)\\n                typing_speed = random.uniform(min_typing_speed, max_typing_speed)\\n                time.sleep(typing_speed)\\n                # type faster after each word\\n                min_typing_speed = min_typing_speed * 0.95\\n                max_typing_speed = max_typing_speed * 0.95\\n            print()\\n        except Exception:\\n            self.handleError(record)\\n\",\n            \"name_column\": 6\n        },\n        \"ConsoleHandler\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"ConsoleHandler\",\n            \"md_content\": \"\",\n            \"code_start_line\": 221,\n            \"code_end_line\": 227,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"class ConsoleHandler(logging.StreamHandler):\\n    def emit(self, record) -> None:\\n        msg = self.format(record)\\n        try:\\n            print(msg)\\n        except Exception:\\n            self.handleError(record)\\n\",\n            \"name_column\": 6\n        },\n        \"RecordFormatter\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"RecordFormatter\",\n            \"md_content\": \"\",\n            \"code_start_line\": 230,\n            \"code_end_line\": 254,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"class RecordFormatter(logging.Formatter):\\n    \\\"\\\"\\\"\\n    Allows to handle custom placeholders 'title_color' and 'message_no_color'.\\n    To use this formatter, make sure to pass 'color', 'title' as log extras.\\n    \\\"\\\"\\\"\\n\\n    def format(self, record: LogRecord) -> str:\\n        if hasattr(record, \\\"color\\\"):\\n            record.title_color = (\\n                getattr(record, \\\"color\\\")\\n                + getattr(record, \\\"title\\\", \\\"\\\")\\n                + \\\" \\\"\\n                + Style.RESET_ALL\\n            )\\n        else:\\n            record.title_color = getattr(record, \\\"title\\\", \\\"\\\")\\n\\n        # Add this line to set 'title' to an empty string if it doesn't exist\\n        record.title = getattr(record, \\\"title\\\", \\\"\\\")\\n\\n        if hasattr(record, \\\"msg\\\"):\\n            record.message_no_color = remove_color_codes(getattr(record, \\\"msg\\\"))\\n        else:\\n            record.message_no_color = \\\"\\\"\\n        return super().format(record)\\n\",\n            \"name_column\": 6\n        },\n        \"remove_color_codes\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"remove_color_codes\",\n            \"md_content\": \"\",\n            \"code_start_line\": 257,\n            \"code_end_line\": 259,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"def remove_color_codes(s: str) -> str:\\n    ansi_escape = re.compile(r\\\"\\\\x1B(?:[@-Z\\\\\\\\-_]|\\\\[[0-?]*[ -/]*[@-~])\\\")\\n    return ansi_escape.sub(\\\"\\\", s)\\n\",\n            \"name_column\": 4\n        },\n        \"__init__\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"__init__\",\n            \"md_content\": \"\",\n            \"code_start_line\": 40,\n            \"code_end_line\": 96,\n            \"parent\": \"Logger\",\n            \"have_return\": false,\n            \"code_content\": \"    def __init__(self, log_dir: str = None, log_name: str= \\\"\\\", log_file: str = \\\"activity.log\\\", error_file: str = \\\"errors.log\\\"):\\n        \\\"\\\"\\\"init\\\"\\\"\\\"\\n        if not os.path.exists(log_dir):\\n            os.makedirs(log_dir)\\n\\n        # create log directory if it doesn't exist\\n        self.log_name = time.strftime(\\\"%Y-%m-%d\\\", time.localtime()) if not log_name else log_name\\n        self.logger = logging.getLogger(self.log_name)\\n        console_formatter = RecordFormatter(\\\"%(title_color)s %(message)s\\\")\\n\\n        # Create a handler for console which simulate typing\\n        self.typing_console_handler = TypingConsoleHandler()\\n        self.typing_console_handler.setLevel(logging.INFO)\\n        self.typing_console_handler.setFormatter(console_formatter)\\n\\n        # Create a handler for console without typing simulation\\n        self.console_handler = ConsoleHandler()\\n        self.console_handler.setLevel(logging.DEBUG)\\n        self.console_handler.setFormatter(console_formatter)\\n\\n        self.speak_mode = False\\n        self.chat_plugins = []\\n\\n        # Info handler in activity.log\\n        self.file_handler = logging.FileHandler(\\n            os.path.join(log_dir, log_file), \\\"a\\\", \\\"utf-8\\\"\\n        )\\n        self.file_handler.setLevel(logging.DEBUG)\\n        info_formatter = RecordFormatter(\\n            \\\"%(asctime)s [%(threadName)s] %(levelname)s: %(title_color)s %(title)s %(message)s\\\"\\n        )\\n        self.file_handler.setFormatter(info_formatter)\\n\\n        # Error handler error.log\\n        error_handler = logging.FileHandler(\\n            os.path.join(log_dir, error_file), \\\"a\\\", \\\"utf-8\\\"\\n        )\\n        error_handler.setLevel(logging.ERROR)\\n        error_formatter = RecordFormatter(\\n            \\\"%(asctime)s [%(threadName)s] %(levelname)s %(module)s:%(funcName)s:%(lineno)d %(title_color)s %(title)s\\\"\\n            \\\" %(message_no_color)s\\\"\\n        )\\n        error_handler.setFormatter(error_formatter)\\n\\n        # self.typing_logger = logging.getLogger(self.log_name)\\n        # if not self.typing_logger.handlers:\\n        #     self.typing_logger.addHandler(self.typing_console_handler)\\n        #     self.typing_logger.addHandler(self.file_handler)\\n        #     self.typing_logger.addHandler(error_handler)\\n        # self.typing_logger.setLevel(logging.DEBUG)\\n\\n        if self.log_name.endswith(\\\"_INTERACT\\\") or not self.logger.handlers:\\n            # self.logger.addHandler(self.typing_console_handler)\\n            self.logger.addHandler(self.console_handler)\\n            self.logger.addHandler(error_handler)\\n            self.logger.addHandler(self.file_handler)\\n            self.logger.setLevel(logging.DEBUG)\\n\",\n            \"name_column\": 8\n        },\n        \"emit\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"emit\",\n            \"md_content\": \"\",\n            \"code_start_line\": 222,\n            \"code_end_line\": 227,\n            \"parent\": \"ConsoleHandler\",\n            \"have_return\": false,\n            \"code_content\": \"    def emit(self, record) -> None:\\n        msg = self.format(record)\\n        try:\\n            print(msg)\\n        except Exception:\\n            self.handleError(record)\\n\",\n            \"name_column\": 8\n        },\n        \"format\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"format\",\n            \"md_content\": \"\",\n            \"code_start_line\": 236,\n            \"code_end_line\": 254,\n            \"parent\": \"RecordFormatter\",\n            \"have_return\": true,\n            \"code_content\": \"    def format(self, record: LogRecord) -> str:\\n        if hasattr(record, \\\"color\\\"):\\n            record.title_color = (\\n                getattr(record, \\\"color\\\")\\n                + getattr(record, \\\"title\\\", \\\"\\\")\\n                + \\\" \\\"\\n                + Style.RESET_ALL\\n            )\\n        else:\\n            record.title_color = getattr(record, \\\"title\\\", \\\"\\\")\\n\\n        # Add this line to set 'title' to an empty string if it doesn't exist\\n        record.title = getattr(record, \\\"title\\\", \\\"\\\")\\n\\n        if hasattr(record, \\\"msg\\\"):\\n            record.message_no_color = remove_color_codes(getattr(record, \\\"msg\\\"))\\n        else:\\n            record.message_no_color = \\\"\\\"\\n        return super().format(record)\\n\",\n            \"name_column\": 8\n        },\n        \"typewriter_log\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"typewriter_log\",\n            \"md_content\": \"\",\n            \"code_start_line\": 98,\n            \"code_end_line\": 115,\n            \"parent\": \"Logger\",\n            \"have_return\": false,\n            \"code_content\": \"    def typewriter_log(\\n        self, title=\\\"\\\", title_color=\\\"\\\", content=\\\"\\\", speak_text=False, level=logging.INFO\\n    ):\\n        # if speak_text and self.speak_mode:\\n        #     say_text(f\\\"{title}. {content}\\\")\\n\\n        for plugin in self.chat_plugins:\\n            plugin.report(f\\\"{title}. {content}\\\")\\n\\n        if content:\\n            if isinstance(content, list):\\n                content = \\\" \\\".join(content)\\n        else:\\n            content = \\\"\\\"\\n\\n        self.logger.log(\\n            level, content, extra={\\\"title\\\": title, \\\"color\\\": title_color}\\n        )\\n\",\n            \"name_column\": 8\n        },\n        \"debug\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"debug\",\n            \"md_content\": \"\",\n            \"code_start_line\": 117,\n            \"code_end_line\": 123,\n            \"parent\": \"Logger\",\n            \"have_return\": false,\n            \"code_content\": \"    def debug(\\n        self,\\n        message,\\n        title=\\\"\\\",\\n        title_color=\\\"\\\",\\n    ):\\n        self._log(title, title_color, message, logging.DEBUG)\\n\",\n            \"name_column\": 8\n        },\n        \"info\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"info\",\n            \"md_content\": \"\",\n            \"code_start_line\": 125,\n            \"code_end_line\": 131,\n            \"parent\": \"Logger\",\n            \"have_return\": false,\n            \"code_content\": \"    def info(\\n        self,\\n        message,\\n        title=\\\"\\\",\\n        title_color=\\\"\\\",\\n    ):\\n        self._log(title, title_color, message, logging.INFO)\\n\",\n            \"name_column\": 8\n        },\n        \"warn\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"warn\",\n            \"md_content\": \"\",\n            \"code_start_line\": 133,\n            \"code_end_line\": 139,\n            \"parent\": \"Logger\",\n            \"have_return\": false,\n            \"code_content\": \"    def warn(\\n        self,\\n        message,\\n        title=\\\"\\\",\\n        title_color=\\\"\\\",\\n    ):\\n        self._log(title, title_color, message, logging.WARN)\\n\",\n            \"name_column\": 8\n        },\n        \"error\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"error\",\n            \"md_content\": \"\",\n            \"code_start_line\": 141,\n            \"code_end_line\": 142,\n            \"parent\": \"Logger\",\n            \"have_return\": false,\n            \"code_content\": \"    def error(self, title, message=\\\"\\\"):\\n        self._log(title, Fore.RED, message, logging.ERROR)\\n\",\n            \"name_column\": 8\n        },\n        \"_log\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"_log\",\n            \"md_content\": \"\",\n            \"code_start_line\": 144,\n            \"code_end_line\": 156,\n            \"parent\": \"Logger\",\n            \"have_return\": false,\n            \"code_content\": \"    def _log(\\n        self,\\n        title: str = \\\"\\\",\\n        title_color: str = \\\"\\\",\\n        message: str = \\\"\\\",\\n        level=logging.INFO,\\n    ):\\n        if message:\\n            if isinstance(message, list):\\n                message = \\\" \\\".join(message)\\n        self.logger.log(\\n            level, message, extra={\\\"title\\\": str(title), \\\"color\\\": str(title_color)}\\n        )\\n\",\n            \"name_column\": 8\n        },\n        \"set_level\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"set_level\",\n            \"md_content\": \"\",\n            \"code_start_line\": 158,\n            \"code_end_line\": 160,\n            \"parent\": \"Logger\",\n            \"have_return\": false,\n            \"code_content\": \"    def set_level(self, level):\\n        self.logger.setLevel(level)\\n        self.typing_logger.setLevel(level)\\n\",\n            \"name_column\": 8\n        },\n        \"double_check\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"double_check\",\n            \"md_content\": \"\",\n            \"code_start_line\": 162,\n            \"code_end_line\": 171,\n            \"parent\": \"Logger\",\n            \"have_return\": false,\n            \"code_content\": \"    def double_check(self, additionalText=None):\\n        if not additionalText:\\n            additionalText = (\\n                \\\"Please ensure you've setup and configured everything\\\"\\n                \\\" correctly. Read https://github.com/Torantulino/Auto-GPT#readme to \\\"\\n                \\\"double check. You can also create a github issue or join the discord\\\"\\n                \\\" and ask there!\\\"\\n            )\\n\\n        self.typewriter_log(\\\"DOUBLE CHECK CONFIGURATION\\\", Fore.YELLOW, additionalText)\\n\",\n            \"name_column\": 8\n        },\n        \"log_json\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"log_json\",\n            \"md_content\": \"\",\n            \"code_start_line\": 173,\n            \"code_end_line\": 186,\n            \"parent\": \"Logger\",\n            \"have_return\": false,\n            \"code_content\": \"    def log_json(self, data: Any, file_name: str) -> None:\\n        # Define log directory\\n        this_files_dir_path = os.path.dirname(__file__)\\n        log_dir = os.path.join(this_files_dir_path, \\\"../logs\\\")\\n\\n        # Create a handler for JSON files\\n        json_file_path = os.path.join(log_dir, file_name)\\n        json_data_handler = JsonFileHandler(json_file_path)\\n        json_data_handler.setFormatter(JsonFormatter())\\n\\n        # Log the JSON data using the custom file handler\\n        self.json_logger.addHandler(json_data_handler)\\n        self.json_logger.debug(data)\\n        self.json_logger.removeHandler(json_data_handler)\\n\",\n            \"name_column\": 8\n        },\n        \"get_log_directory\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"get_log_directory\",\n            \"md_content\": \"\",\n            \"code_start_line\": 188,\n            \"code_end_line\": 191,\n            \"parent\": \"Logger\",\n            \"have_return\": true,\n            \"code_content\": \"    def get_log_directory(self):\\n        this_files_dir_path = os.path.dirname(__file__)\\n        log_dir = os.path.join(this_files_dir_path, \\\"../logs\\\")\\n        return os.path.abspath(log_dir)\\n\",\n            \"name_column\": 8\n        }\n    },\n    \"XAgentServer/enums/recorder_type.py\": {\n        \"RecorderTypeEnum\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"RecorderTypeEnum\",\n            \"md_content\": \"\",\n            \"code_start_line\": 4,\n            \"code_end_line\": 20,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"class RecorderTypeEnum:\\n    \\\"\\\"\\\"XAgent Running Recorder Type Enum\\n    \\\"\\\"\\\"\\n    QUERY = \\\"query\\\"\\n    CONFIG = \\\"config\\\"\\n    LLM_INPUT_PAIR = \\\"llm_input_pair\\\"\\n    TOOL_SERVER_PAIR = \\\"tool_server_pair\\\"\\n    NOW_SUBTASK_ID = \\\"now_subtask_id\\\"\\n    TOOL_CALL = \\\"tool_call\\\"\\n    PLAN_REFINE = \\\"plan_refine\\\"\\n    LLM_SERVER_CACHE = \\\"llm_server_cache\\\"\\n    TOOL_SERVER_CACHE = \\\"tool_server_cache\\\"\\n    TOOL_CALL_CACHE = \\\"tool_call_cache\\\"\\n    PLAN_REFINE_CACHE = \\\"plan_refine_cache\\\"\\n    LLM_INTERFACE_ID = \\\"llm_interface_id\\\"\\n    TOOL_SERVER_INTERFACE_ID = \\\"toolserver_interface_id\\\"\\n    TOOL_CALL_ID = \\\"tool_call_id\\\"\\n\",\n            \"name_column\": 6\n        }\n    },\n    \"XAgentServer/enums/status.py\": {\n        \"StatusEnum\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"StatusEnum\",\n            \"md_content\": \"\",\n            \"code_start_line\": 4,\n            \"code_end_line\": 16,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"class StatusEnum:\\n    \\\"\\\"\\\"XAgent Status Enum\\n    \\\"\\\"\\\"\\n    START = \\\"start\\\"\\n    SUBTASK = \\\"subtask\\\"\\n    REFINEMENT = \\\"refinement\\\"\\n    INNER = \\\"inner\\\"\\n    FINISHED = \\\"finished\\\"\\n    FAILED = \\\"failed\\\"\\n    SUBMIT = \\\"subtask_submit\\\"\\n    RUNNING = \\\"running\\\"\\n    ASK_FOR_HUMAN_HELP = \\\"ask_for_human_help\\\"\\n    CLOSED = \\\"closed\\\"\\n\",\n            \"name_column\": 6\n        }\n    },\n    \"XAgentServer/models/user.py\": {\n        \"XAgentUser\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"XAgentUser\",\n            \"md_content\": \"\",\n            \"code_start_line\": 7,\n            \"code_end_line\": 105,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"class XAgentUser(metaclass=abc.ABCMeta):\\n\\n    def __init__(self, \\n                 user_id: str, \\n                 email: str, \\n                 name: str, \\n                 token: str, \\n                 available: bool = True,\\n                 corporation: str = None,\\n                 industry: str = None,\\n                 position: str = None,\\n                 create_time: str = None,\\n                 update_time: str = None,\\n                 deleted: bool = False,\\n                 is_beta: bool = False,):\\n        self.user_id = user_id\\n        self.email = email\\n        self.name = name\\n        self.token = token\\n        self.available = available\\n        self.corporation = corporation\\n        self.industry = industry\\n        self.position = position\\n        self.create_time = create_time\\n        self.update_time = update_time\\n        self.deleted = deleted\\n        self.is_beta = is_beta\\n\\n    def to_dict(self):\\n        return {\\n            \\\"user_id\\\": self.user_id,\\n            \\\"email\\\": self.email,\\n            \\\"name\\\": self.name,\\n            \\\"token\\\": self.token,\\n            \\\"available\\\": self.available,\\n            \\\"corporation\\\": self.corporation,\\n            \\\"industry\\\": self.industry,\\n            \\\"position\\\": self.position,\\n            \\\"create_time\\\": self.create_time,\\n            \\\"update_time\\\": self.update_time,\\n            \\\"deleted\\\": self.deleted,\\n            \\\"is_beta\\\": self.is_beta\\n        }\\n\\n    def to_json(self):\\n        return json.dumps(self.to_dict(), indent=2, ensure_ascii=False)\\n\\n    @staticmethod\\n    def from_dict(user_dict: dict):\\n        return XAgentUser(\\n            user_id=user_dict[\\\"user_id\\\"],\\n            email=user_dict[\\\"email\\\"],\\n            name=user_dict[\\\"name\\\"],\\n            token=user_dict[\\\"token\\\"],\\n            available=user_dict[\\\"available\\\"],\\n            corporation=user_dict[\\\"corporation\\\"],\\n            industry=user_dict[\\\"industry\\\"],\\n            position=user_dict[\\\"position\\\"],\\n            create_time=user_dict[\\\"create_time\\\"],\\n            update_time=user_dict[\\\"update_time\\\"],\\n            deleted=user_dict[\\\"deleted\\\"],\\n            is_beta=user_dict[\\\"is_beta\\\"]\\n        )\\n\\n    @staticmethod\\n    def from_json(user_json: str):\\n        return XAgentUser.from_dict(json.loads(user_json))\\n\\n    def is_available(self):\\n        return self.available\\n    \\n    @staticmethod\\n    def from_db(user: User):\\n        user_id = user.user_id\\n        email = user.email\\n        name = user.name\\n        token = user.token\\n        available = user.available\\n        corporation = user.corporation\\n        industry = user.industry\\n        position = user.position\\n        create_time = user.create_time\\n        update_time = user.update_time\\n        deleted = user.deleted\\n        is_beta = user.is_beta\\n        return XAgentUser(\\n            user_id=user_id,\\n            email=email,\\n            name=name,\\n            token=token,\\n            available=available,\\n            corporation=corporation,\\n            industry=industry,\\n            position=position,\\n            create_time=create_time,\\n            update_time=update_time,\\n            deleted=deleted,\\n            is_beta=is_beta\\n        )\\n\",\n            \"name_column\": 6\n        },\n        \"__init__\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"__init__\",\n            \"md_content\": \"\",\n            \"code_start_line\": 9,\n            \"code_end_line\": 33,\n            \"parent\": \"XAgentUser\",\n            \"have_return\": false,\n            \"code_content\": \"    def __init__(self, \\n                 user_id: str, \\n                 email: str, \\n                 name: str, \\n                 token: str, \\n                 available: bool = True,\\n                 corporation: str = None,\\n                 industry: str = None,\\n                 position: str = None,\\n                 create_time: str = None,\\n                 update_time: str = None,\\n                 deleted: bool = False,\\n                 is_beta: bool = False,):\\n        self.user_id = user_id\\n        self.email = email\\n        self.name = name\\n        self.token = token\\n        self.available = available\\n        self.corporation = corporation\\n        self.industry = industry\\n        self.position = position\\n        self.create_time = create_time\\n        self.update_time = update_time\\n        self.deleted = deleted\\n        self.is_beta = is_beta\\n\",\n            \"name_column\": 8\n        },\n        \"to_dict\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"to_dict\",\n            \"md_content\": \"\",\n            \"code_start_line\": 35,\n            \"code_end_line\": 49,\n            \"parent\": \"XAgentUser\",\n            \"have_return\": true,\n            \"code_content\": \"    def to_dict(self):\\n        return {\\n            \\\"user_id\\\": self.user_id,\\n            \\\"email\\\": self.email,\\n            \\\"name\\\": self.name,\\n            \\\"token\\\": self.token,\\n            \\\"available\\\": self.available,\\n            \\\"corporation\\\": self.corporation,\\n            \\\"industry\\\": self.industry,\\n            \\\"position\\\": self.position,\\n            \\\"create_time\\\": self.create_time,\\n            \\\"update_time\\\": self.update_time,\\n            \\\"deleted\\\": self.deleted,\\n            \\\"is_beta\\\": self.is_beta\\n        }\\n\",\n            \"name_column\": 8\n        },\n        \"to_json\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"to_json\",\n            \"md_content\": \"\",\n            \"code_start_line\": 51,\n            \"code_end_line\": 52,\n            \"parent\": \"XAgentUser\",\n            \"have_return\": true,\n            \"code_content\": \"    def to_json(self):\\n        return json.dumps(self.to_dict(), indent=2, ensure_ascii=False)\\n\",\n            \"name_column\": 8\n        },\n        \"from_dict\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"from_dict\",\n            \"md_content\": \"\",\n            \"code_start_line\": 55,\n            \"code_end_line\": 69,\n            \"parent\": \"XAgentUser\",\n            \"have_return\": true,\n            \"code_content\": \"    def from_dict(user_dict: dict):\\n        return XAgentUser(\\n            user_id=user_dict[\\\"user_id\\\"],\\n            email=user_dict[\\\"email\\\"],\\n            name=user_dict[\\\"name\\\"],\\n            token=user_dict[\\\"token\\\"],\\n            available=user_dict[\\\"available\\\"],\\n            corporation=user_dict[\\\"corporation\\\"],\\n            industry=user_dict[\\\"industry\\\"],\\n            position=user_dict[\\\"position\\\"],\\n            create_time=user_dict[\\\"create_time\\\"],\\n            update_time=user_dict[\\\"update_time\\\"],\\n            deleted=user_dict[\\\"deleted\\\"],\\n            is_beta=user_dict[\\\"is_beta\\\"]\\n        )\\n\",\n            \"name_column\": 8\n        },\n        \"from_json\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"from_json\",\n            \"md_content\": \"\",\n            \"code_start_line\": 72,\n            \"code_end_line\": 73,\n            \"parent\": \"XAgentUser\",\n            \"have_return\": true,\n            \"code_content\": \"    def from_json(user_json: str):\\n        return XAgentUser.from_dict(json.loads(user_json))\\n\",\n            \"name_column\": 8\n        },\n        \"is_available\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"is_available\",\n            \"md_content\": \"\",\n            \"code_start_line\": 75,\n            \"code_end_line\": 76,\n            \"parent\": \"XAgentUser\",\n            \"have_return\": true,\n            \"code_content\": \"    def is_available(self):\\n        return self.available\\n\",\n            \"name_column\": 8\n        },\n        \"from_db\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"from_db\",\n            \"md_content\": \"\",\n            \"code_start_line\": 79,\n            \"code_end_line\": 105,\n            \"parent\": \"XAgentUser\",\n            \"have_return\": true,\n            \"code_content\": \"    def from_db(user: User):\\n        user_id = user.user_id\\n        email = user.email\\n        name = user.name\\n        token = user.token\\n        available = user.available\\n        corporation = user.corporation\\n        industry = user.industry\\n        position = user.position\\n        create_time = user.create_time\\n        update_time = user.update_time\\n        deleted = user.deleted\\n        is_beta = user.is_beta\\n        return XAgentUser(\\n            user_id=user_id,\\n            email=email,\\n            name=name,\\n            token=token,\\n            available=available,\\n            corporation=corporation,\\n            industry=industry,\\n            position=position,\\n            create_time=create_time,\\n            update_time=update_time,\\n            deleted=deleted,\\n            is_beta=is_beta\\n        )\\n\",\n            \"name_column\": 8\n        }\n    },\n    \"XAgentServer/models/interaction.py\": {\n        \"InteractionBase\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"InteractionBase\",\n            \"md_content\": \"\",\n            \"code_start_line\": 8,\n            \"code_end_line\": 86,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"class InteractionBase(metaclass=abc.ABCMeta):\\n    def __init__(self,\\n                interaction_id: str,\\n                user_id: str,\\n                create_time: str,\\n                description: str,\\n                agent: str = \\\"\\\",\\n                mode: str = \\\"\\\",\\n                file_list: list = [],\\n                recorder_root_dir: str = \\\"\\\",\\n                status: str = \\\"\\\",\\n                message: str = \\\"\\\",\\n                current_step: str = \\\"\\\",\\n                update_time: str = \\\"\\\",\\n                is_deleted: bool = False,\\n                call_method: str = \\\"web\\\",\\n                ):\\n        self.interaction_id = interaction_id\\n        self.user_id = user_id\\n        self.create_time = create_time\\n        self.description = description\\n        self.agent = agent\\n        self.mode = mode\\n        self.file_list = file_list\\n        self.recorder_root_dir = recorder_root_dir\\n        self.status = status\\n        self.message = message\\n        self.current_step = current_step\\n        self.update_time = update_time\\n        self.is_deleted = is_deleted\\n        self.call_method = call_method\\n\\n    def to_dict(self, include=None, exclude=None):\\n        data = {\\n            \\\"interaction_id\\\": self.interaction_id,\\n            \\\"user_id\\\": self.user_id,\\n            \\\"create_time\\\": self.create_time,\\n            \\\"description\\\": self.description,\\n            \\\"agent\\\": self.agent,\\n            \\\"mode\\\": self.mode,\\n            \\\"file_list\\\": self.file_list,\\n            \\\"recorder_root_dir\\\": self.recorder_root_dir,\\n            \\\"status\\\": self.status,\\n            \\\"message\\\": self.message,\\n            \\\"current_step\\\": self.current_step,\\n            \\\"update_time\\\": self.update_time,\\n            \\\"is_deleted\\\": self.is_deleted,\\n            \\\"call_method\\\": self.call_method,\\n        }\\n        if include:\\n            data = {k: v for k, v in data.items() if k in include}\\n        if exclude:\\n            data = {k: v for k, v in data.items() if k not in exclude}\\n        return data\\n    \\n    def to_json(self):\\n        return json.dumps(self.to_dict(), indent=2, ensure_ascii=False)\\n    \\n    @classmethod\\n    def from_json(cls, json_data):\\n        return cls(**json_data)\\n    \\n    @classmethod\\n    def from_db(cls, interaction):\\n        return cls(interaction.interaction_id,\\n                    interaction.user_id,\\n                    interaction.create_time,\\n                    interaction.description,\\n                    interaction.agent,\\n                    interaction.mode,\\n                    interaction.file_list,\\n                    interaction.recorder_root_dir,\\n                    interaction.status,\\n                    interaction.message,\\n                    interaction.current_step,\\n                    interaction.update_time,\\n                    interaction.is_deleted,\\n                    interaction.call_method,\\n                    )\\n\",\n            \"name_column\": 6\n        },\n        \"__init__\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"__init__\",\n            \"md_content\": \"\",\n            \"code_start_line\": 9,\n            \"code_end_line\": 38,\n            \"parent\": \"InteractionBase\",\n            \"have_return\": false,\n            \"code_content\": \"    def __init__(self,\\n                interaction_id: str,\\n                user_id: str,\\n                create_time: str,\\n                description: str,\\n                agent: str = \\\"\\\",\\n                mode: str = \\\"\\\",\\n                file_list: list = [],\\n                recorder_root_dir: str = \\\"\\\",\\n                status: str = \\\"\\\",\\n                message: str = \\\"\\\",\\n                current_step: str = \\\"\\\",\\n                update_time: str = \\\"\\\",\\n                is_deleted: bool = False,\\n                call_method: str = \\\"web\\\",\\n                ):\\n        self.interaction_id = interaction_id\\n        self.user_id = user_id\\n        self.create_time = create_time\\n        self.description = description\\n        self.agent = agent\\n        self.mode = mode\\n        self.file_list = file_list\\n        self.recorder_root_dir = recorder_root_dir\\n        self.status = status\\n        self.message = message\\n        self.current_step = current_step\\n        self.update_time = update_time\\n        self.is_deleted = is_deleted\\n        self.call_method = call_method\\n\",\n            \"name_column\": 8\n        },\n        \"to_dict\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"to_dict\",\n            \"md_content\": \"\",\n            \"code_start_line\": 40,\n            \"code_end_line\": 61,\n            \"parent\": \"InteractionBase\",\n            \"have_return\": true,\n            \"code_content\": \"    def to_dict(self, include=None, exclude=None):\\n        data = {\\n            \\\"interaction_id\\\": self.interaction_id,\\n            \\\"user_id\\\": self.user_id,\\n            \\\"create_time\\\": self.create_time,\\n            \\\"description\\\": self.description,\\n            \\\"agent\\\": self.agent,\\n            \\\"mode\\\": self.mode,\\n            \\\"file_list\\\": self.file_list,\\n            \\\"recorder_root_dir\\\": self.recorder_root_dir,\\n            \\\"status\\\": self.status,\\n            \\\"message\\\": self.message,\\n            \\\"current_step\\\": self.current_step,\\n            \\\"update_time\\\": self.update_time,\\n            \\\"is_deleted\\\": self.is_deleted,\\n            \\\"call_method\\\": self.call_method,\\n        }\\n        if include:\\n            data = {k: v for k, v in data.items() if k in include}\\n        if exclude:\\n            data = {k: v for k, v in data.items() if k not in exclude}\\n        return data\\n\",\n            \"name_column\": 8\n        },\n        \"to_json\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"to_json\",\n            \"md_content\": \"\",\n            \"code_start_line\": 63,\n            \"code_end_line\": 64,\n            \"parent\": \"InteractionBase\",\n            \"have_return\": true,\n            \"code_content\": \"    def to_json(self):\\n        return json.dumps(self.to_dict(), indent=2, ensure_ascii=False)\\n\",\n            \"name_column\": 8\n        },\n        \"from_json\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"from_json\",\n            \"md_content\": \"\",\n            \"code_start_line\": 67,\n            \"code_end_line\": 68,\n            \"parent\": \"InteractionBase\",\n            \"have_return\": true,\n            \"code_content\": \"    def from_json(cls, json_data):\\n        return cls(**json_data)\\n\",\n            \"name_column\": 8\n        },\n        \"from_db\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"from_db\",\n            \"md_content\": \"\",\n            \"code_start_line\": 71,\n            \"code_end_line\": 86,\n            \"parent\": \"InteractionBase\",\n            \"have_return\": true,\n            \"code_content\": \"    def from_db(cls, interaction):\\n        return cls(interaction.interaction_id,\\n                    interaction.user_id,\\n                    interaction.create_time,\\n                    interaction.description,\\n                    interaction.agent,\\n                    interaction.mode,\\n                    interaction.file_list,\\n                    interaction.recorder_root_dir,\\n                    interaction.status,\\n                    interaction.message,\\n                    interaction.current_step,\\n                    interaction.update_time,\\n                    interaction.is_deleted,\\n                    interaction.call_method,\\n                    )\\n\",\n            \"name_column\": 8\n        }\n    },\n    \"XAgentServer/models/raw.py\": {\n        \"XAgentRaw\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"XAgentRaw\",\n            \"md_content\": \"\",\n            \"code_start_line\": 6,\n            \"code_end_line\": 110,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"class XAgentRaw(metaclass=abc.ABCMeta):\\n    \\\"\\\"\\\"XAgent Raw Object\\\"\\\"\\\"\\n\\n    def __init__(self, node_id: str,\\n                 interaction_id: str,\\n                 current: str,\\n                 step: int,\\n                 data: dict,\\n                 file_list: list,\\n                 status: str,\\n                 do_interrupt: bool,\\n                 wait_seconds: int,\\n                 ask_for_human_help: bool,\\n                 create_time: str,\\n                 update_time: str,\\n                 is_deleted: bool,\\n                 is_human: bool,\\n                 human_data: dict,\\n                 human_file_list: list,\\n                 is_send: bool,\\n                 is_receive: bool,\\n                 include_pictures: bool = False,):\\n        self.node_id = node_id\\n        self.interaction_id = interaction_id\\n        self.current = current\\n        self.step = step\\n        self.data = data\\n        self.file_list = file_list\\n        self.status = status\\n        self.do_interrupt = do_interrupt\\n        self.wait_seconds = wait_seconds\\n        self.ask_for_human_help = ask_for_human_help\\n        self.create_time = create_time\\n        self.update_time = update_time\\n        self.is_deleted = is_deleted\\n        self.is_human = is_human\\n        self.human_data = human_data\\n        self.human_file_list = human_file_list\\n        self.is_send = is_send\\n        self.is_receive = is_receive\\n        self.include_pictures = include_pictures\\n\\n    def to_dict(self):\\n        \\\"\\\"\\\"XAgent Raw Object to dict\\\"\\\"\\\"\\n        return {\\n            \\\"node_id\\\": self.node_id,\\n            \\\"interaction_id\\\": self.interaction_id,\\n            \\\"current\\\": self.current,\\n            \\\"step\\\": self.step,\\n            \\\"data\\\": self.data,\\n            \\\"file_list\\\": self.file_list,\\n            \\\"status\\\": self.status,\\n            \\\"do_interrupt\\\": self.do_interrupt,\\n            \\\"wait_seconds\\\": self.wait_seconds,\\n            \\\"ask_for_human_help\\\": self.ask_for_human_help,\\n            \\\"create_time\\\": self.create_time,\\n            \\\"update_time\\\": self.update_time,\\n            \\\"is_deleted\\\": self.is_deleted,\\n            \\\"is_human\\\": self.is_human,\\n            \\\"human_data\\\": self.human_data,\\n            \\\"human_file_list\\\": self.human_file_list,\\n            \\\"is_send\\\": self.is_send,\\n            \\\"is_receive\\\": self.is_receive,\\n            \\\"include_pictures\\\": self.include_pictures\\n        }\\n\\n    def to_json(self):\\n        \\\"\\\"\\\"XAgent Raw Object to json\\\"\\\"\\\"\\n        return json.dumps(self.to_dict(), indent=2, ensure_ascii=False)\\n\\n    @classmethod\\n    def from_json(cls, json_data):\\n        \\\"\\\"\\\"XAgent Raw Object from json\\\"\\\"\\\"\\n        return cls(**json_data)\\n\\n    def update(self, update_data: dict):\\n        \\\"\\\"\\\"XAgent Raw Object update\\\"\\\"\\\"\\n        for k, v in update_data.items():\\n            setattr(self, k, v)\\n        return self\\n\\n    @classmethod\\n    def from_db(cls, db_data):\\n        \\\"\\\"\\\"XAgent Raw Object from db\\\"\\\"\\\"\\n        return cls(\\n            node_id=db_data.node_id,\\n            interaction_id=db_data.interaction_id,\\n            current=db_data.current,\\n            step=db_data.step,\\n            data=db_data.data,\\n            file_list=db_data.file_list,\\n            status=db_data.status,\\n            do_interrupt=db_data.do_interrupt,\\n            wait_seconds=db_data.wait_seconds,\\n            ask_for_human_help=db_data.ask_for_human_help,\\n            create_time=db_data.create_time,\\n            update_time=db_data.update_time,\\n            is_deleted=db_data.is_deleted,\\n            is_human=db_data.is_human,\\n            human_data=db_data.human_data,\\n            human_file_list=db_data.human_file_list,\\n            is_send=db_data.is_send,\\n            is_receive=db_data.is_receive,\\n            include_pictures=db_data.include_pictures\\n        )\\n\",\n            \"name_column\": 6\n        },\n        \"__init__\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"__init__\",\n            \"md_content\": \"\",\n            \"code_start_line\": 9,\n            \"code_end_line\": 46,\n            \"parent\": \"XAgentRaw\",\n            \"have_return\": false,\n            \"code_content\": \"    def __init__(self, node_id: str,\\n                 interaction_id: str,\\n                 current: str,\\n                 step: int,\\n                 data: dict,\\n                 file_list: list,\\n                 status: str,\\n                 do_interrupt: bool,\\n                 wait_seconds: int,\\n                 ask_for_human_help: bool,\\n                 create_time: str,\\n                 update_time: str,\\n                 is_deleted: bool,\\n                 is_human: bool,\\n                 human_data: dict,\\n                 human_file_list: list,\\n                 is_send: bool,\\n                 is_receive: bool,\\n                 include_pictures: bool = False,):\\n        self.node_id = node_id\\n        self.interaction_id = interaction_id\\n        self.current = current\\n        self.step = step\\n        self.data = data\\n        self.file_list = file_list\\n        self.status = status\\n        self.do_interrupt = do_interrupt\\n        self.wait_seconds = wait_seconds\\n        self.ask_for_human_help = ask_for_human_help\\n        self.create_time = create_time\\n        self.update_time = update_time\\n        self.is_deleted = is_deleted\\n        self.is_human = is_human\\n        self.human_data = human_data\\n        self.human_file_list = human_file_list\\n        self.is_send = is_send\\n        self.is_receive = is_receive\\n        self.include_pictures = include_pictures\\n\",\n            \"name_column\": 8\n        },\n        \"to_dict\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"to_dict\",\n            \"md_content\": \"\",\n            \"code_start_line\": 48,\n            \"code_end_line\": 70,\n            \"parent\": \"XAgentRaw\",\n            \"have_return\": true,\n            \"code_content\": \"    def to_dict(self):\\n        \\\"\\\"\\\"XAgent Raw Object to dict\\\"\\\"\\\"\\n        return {\\n            \\\"node_id\\\": self.node_id,\\n            \\\"interaction_id\\\": self.interaction_id,\\n            \\\"current\\\": self.current,\\n            \\\"step\\\": self.step,\\n            \\\"data\\\": self.data,\\n            \\\"file_list\\\": self.file_list,\\n            \\\"status\\\": self.status,\\n            \\\"do_interrupt\\\": self.do_interrupt,\\n            \\\"wait_seconds\\\": self.wait_seconds,\\n            \\\"ask_for_human_help\\\": self.ask_for_human_help,\\n            \\\"create_time\\\": self.create_time,\\n            \\\"update_time\\\": self.update_time,\\n            \\\"is_deleted\\\": self.is_deleted,\\n            \\\"is_human\\\": self.is_human,\\n            \\\"human_data\\\": self.human_data,\\n            \\\"human_file_list\\\": self.human_file_list,\\n            \\\"is_send\\\": self.is_send,\\n            \\\"is_receive\\\": self.is_receive,\\n            \\\"include_pictures\\\": self.include_pictures\\n        }\\n\",\n            \"name_column\": 8\n        },\n        \"to_json\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"to_json\",\n            \"md_content\": \"\",\n            \"code_start_line\": 72,\n            \"code_end_line\": 74,\n            \"parent\": \"XAgentRaw\",\n            \"have_return\": true,\n            \"code_content\": \"    def to_json(self):\\n        \\\"\\\"\\\"XAgent Raw Object to json\\\"\\\"\\\"\\n        return json.dumps(self.to_dict(), indent=2, ensure_ascii=False)\\n\",\n            \"name_column\": 8\n        },\n        \"from_json\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"from_json\",\n            \"md_content\": \"\",\n            \"code_start_line\": 77,\n            \"code_end_line\": 79,\n            \"parent\": \"XAgentRaw\",\n            \"have_return\": true,\n            \"code_content\": \"    def from_json(cls, json_data):\\n        \\\"\\\"\\\"XAgent Raw Object from json\\\"\\\"\\\"\\n        return cls(**json_data)\\n\",\n            \"name_column\": 8\n        },\n        \"update\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"update\",\n            \"md_content\": \"\",\n            \"code_start_line\": 81,\n            \"code_end_line\": 85,\n            \"parent\": \"XAgentRaw\",\n            \"have_return\": true,\n            \"code_content\": \"    def update(self, update_data: dict):\\n        \\\"\\\"\\\"XAgent Raw Object update\\\"\\\"\\\"\\n        for k, v in update_data.items():\\n            setattr(self, k, v)\\n        return self\\n\",\n            \"name_column\": 8\n        },\n        \"from_db\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"from_db\",\n            \"md_content\": \"\",\n            \"code_start_line\": 88,\n            \"code_end_line\": 110,\n            \"parent\": \"XAgentRaw\",\n            \"have_return\": true,\n            \"code_content\": \"    def from_db(cls, db_data):\\n        \\\"\\\"\\\"XAgent Raw Object from db\\\"\\\"\\\"\\n        return cls(\\n            node_id=db_data.node_id,\\n            interaction_id=db_data.interaction_id,\\n            current=db_data.current,\\n            step=db_data.step,\\n            data=db_data.data,\\n            file_list=db_data.file_list,\\n            status=db_data.status,\\n            do_interrupt=db_data.do_interrupt,\\n            wait_seconds=db_data.wait_seconds,\\n            ask_for_human_help=db_data.ask_for_human_help,\\n            create_time=db_data.create_time,\\n            update_time=db_data.update_time,\\n            is_deleted=db_data.is_deleted,\\n            is_human=db_data.is_human,\\n            human_data=db_data.human_data,\\n            human_file_list=db_data.human_file_list,\\n            is_send=db_data.is_send,\\n            is_receive=db_data.is_receive,\\n            include_pictures=db_data.include_pictures\\n        )\\n\",\n            \"name_column\": 8\n        }\n    },\n    \"XAgentServer/models/shared_interaction.py\": {\n        \"SharedInteractionBase\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"SharedInteractionBase\",\n            \"md_content\": \"\",\n            \"code_start_line\": 9,\n            \"code_end_line\": 68,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"class SharedInteractionBase(metaclass=abc.ABCMeta):\\n    def __init__(self,\\n                interaction_id: str,\\n                user_name: str,\\n                create_time: str,\\n                update_time: str,\\n                description: str,\\n                agent: str = \\\"\\\",\\n                mode: str = \\\"\\\",\\n                is_deleted: bool = False,\\n                star: int = 0,\\n                is_audit: bool = False\\n                ):\\n        self.interaction_id = interaction_id\\n        self.user_name = user_name\\n        self.create_time = create_time\\n        self.update_time = update_time\\n        self.description = description\\n        self.agent = agent\\n        self.mode = mode\\n        self.is_deleted = is_deleted\\n        self.star = star\\n        self.is_audit = is_audit\\n\\n    def to_dict(self, include=None, exclude=None):\\n        data = {\\n            \\\"interaction_id\\\": self.interaction_id,\\n            \\\"user_name\\\": self.user_name,\\n            \\\"create_time\\\": self.create_time,\\n            \\\"update_time\\\": self.update_time,\\n            \\\"description\\\": self.description,\\n            \\\"agent\\\": self.agent,\\n            \\\"mode\\\": self.mode,\\n            \\\"is_deleted\\\": self.is_deleted,\\n            \\\"star\\\": self.star,\\n            \\\"is_audit\\\": self.is_audit\\n        }\\n        if include:\\n            data = {k: v for k, v in data.items() if k in include}\\n        if exclude:\\n            data = {k: v for k, v in data.items() if k not in exclude}\\n        return data\\n        \\n    \\n    def to_json(self):\\n        return json.dumps(self.to_dict(), indent=2, ensure_ascii=False)\\n    \\n    @classmethod\\n    def from_db(cls, interaction):\\n        return cls(interaction.interaction_id,\\n                   interaction.user_name,\\n                   interaction.create_time,\\n                   interaction.update_time,\\n                   interaction.description,\\n                   interaction.agent,\\n                   interaction.mode,\\n                   interaction.is_deleted,\\n                   interaction.star,\\n                   interaction.is_audit\\n                   )\\n\",\n            \"name_column\": 6\n        },\n        \"__init__\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"__init__\",\n            \"md_content\": \"\",\n            \"code_start_line\": 10,\n            \"code_end_line\": 31,\n            \"parent\": \"SharedInteractionBase\",\n            \"have_return\": false,\n            \"code_content\": \"    def __init__(self,\\n                interaction_id: str,\\n                user_name: str,\\n                create_time: str,\\n                update_time: str,\\n                description: str,\\n                agent: str = \\\"\\\",\\n                mode: str = \\\"\\\",\\n                is_deleted: bool = False,\\n                star: int = 0,\\n                is_audit: bool = False\\n                ):\\n        self.interaction_id = interaction_id\\n        self.user_name = user_name\\n        self.create_time = create_time\\n        self.update_time = update_time\\n        self.description = description\\n        self.agent = agent\\n        self.mode = mode\\n        self.is_deleted = is_deleted\\n        self.star = star\\n        self.is_audit = is_audit\\n\",\n            \"name_column\": 8\n        },\n        \"to_dict\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"to_dict\",\n            \"md_content\": \"\",\n            \"code_start_line\": 33,\n            \"code_end_line\": 50,\n            \"parent\": \"SharedInteractionBase\",\n            \"have_return\": true,\n            \"code_content\": \"    def to_dict(self, include=None, exclude=None):\\n        data = {\\n            \\\"interaction_id\\\": self.interaction_id,\\n            \\\"user_name\\\": self.user_name,\\n            \\\"create_time\\\": self.create_time,\\n            \\\"update_time\\\": self.update_time,\\n            \\\"description\\\": self.description,\\n            \\\"agent\\\": self.agent,\\n            \\\"mode\\\": self.mode,\\n            \\\"is_deleted\\\": self.is_deleted,\\n            \\\"star\\\": self.star,\\n            \\\"is_audit\\\": self.is_audit\\n        }\\n        if include:\\n            data = {k: v for k, v in data.items() if k in include}\\n        if exclude:\\n            data = {k: v for k, v in data.items() if k not in exclude}\\n        return data\\n\",\n            \"name_column\": 8\n        },\n        \"to_json\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"to_json\",\n            \"md_content\": \"\",\n            \"code_start_line\": 53,\n            \"code_end_line\": 54,\n            \"parent\": \"SharedInteractionBase\",\n            \"have_return\": true,\n            \"code_content\": \"    def to_json(self):\\n        return json.dumps(self.to_dict(), indent=2, ensure_ascii=False)\\n\",\n            \"name_column\": 8\n        },\n        \"from_db\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"from_db\",\n            \"md_content\": \"\",\n            \"code_start_line\": 57,\n            \"code_end_line\": 68,\n            \"parent\": \"SharedInteractionBase\",\n            \"have_return\": true,\n            \"code_content\": \"    def from_db(cls, interaction):\\n        return cls(interaction.interaction_id,\\n                   interaction.user_name,\\n                   interaction.create_time,\\n                   interaction.update_time,\\n                   interaction.description,\\n                   interaction.agent,\\n                   interaction.mode,\\n                   interaction.is_deleted,\\n                   interaction.star,\\n                   interaction.is_audit\\n                   )\\n\",\n            \"name_column\": 8\n        }\n    },\n    \"XAgentServer/models/recorder.py\": {\n        \"XAgentRunningRecord\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"XAgentRunningRecord\",\n            \"md_content\": \"\",\n            \"code_start_line\": 7,\n            \"code_end_line\": 67,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"class XAgentRunningRecord(metaclass=abc.ABCMeta):\\n    \\\"\\\"\\\"XAgent Running Recorder\\\"\\\"\\\"\\n    def __init__(self,\\n                 record_id: str,\\n                 current: str,\\n                 node_id: str,\\n                 node_type: str,\\n                 data: dict,\\n                 create_time: str,\\n                 update_time: str,\\n                 is_deleted: bool,\\n                 ):\\n        self.record_id = record_id\\n        self.current = current\\n        self.node_id = node_id\\n        self.node_type = node_type\\n        self.data = data\\n        self.create_time = create_time\\n        self.update_time = update_time\\n        self.is_deleted = is_deleted\\n\\n    def to_dict(self):\\n        \\\"\\\"\\\"XAgent Running Recorder to dict\\\"\\\"\\\"\\n        return {\\n            \\\"record_id\\\": self.record_id,\\n            \\\"current\\\": self.current,\\n            \\\"node_id\\\": self.node_id,\\n            \\\"node_type\\\": self.node_type,\\n            \\\"data\\\": self.data,\\n            \\\"create_time\\\": self.create_time,\\n            \\\"update_time\\\": self.update_time,\\n            \\\"is_deleted\\\": self.is_deleted,\\n        }\\n\\n    @classmethod\\n    def from_db(cls, db: RunningRecord):\\n        \\\"\\\"\\\"From db\\\"\\\"\\\"\\n        return cls(\\n            record_id=db.record_id,\\n            current=db.current,\\n            node_id=db.node_id,\\n            node_type=db.node_type,\\n            data=db.data,\\n            create_time=db.create_time,\\n            update_time=db.update_time,\\n            is_deleted=db.is_deleted,\\n        )\\n\\n    @classmethod\\n    def from_dict(cls, data: dict):\\n        \\\"\\\"\\\"dict to XAgent Running Recorder\\\"\\\"\\\"\\n        return cls(\\n            record_id=data[\\\"record_id\\\"],\\n            current=data[\\\"current\\\"],\\n            node_id=data[\\\"node_id\\\"],\\n            node_type=data[\\\"node_type\\\"],\\n            data=data[\\\"data\\\"],\\n            create_time=data[\\\"create_time\\\"],\\n            update_time=data[\\\"update_time\\\"],\\n            is_deleted=data[\\\"is_deleted\\\"],\\n        )\\n\",\n            \"name_column\": 6\n        },\n        \"__init__\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"__init__\",\n            \"md_content\": \"\",\n            \"code_start_line\": 9,\n            \"code_end_line\": 26,\n            \"parent\": \"XAgentRunningRecord\",\n            \"have_return\": false,\n            \"code_content\": \"    def __init__(self,\\n                 record_id: str,\\n                 current: str,\\n                 node_id: str,\\n                 node_type: str,\\n                 data: dict,\\n                 create_time: str,\\n                 update_time: str,\\n                 is_deleted: bool,\\n                 ):\\n        self.record_id = record_id\\n        self.current = current\\n        self.node_id = node_id\\n        self.node_type = node_type\\n        self.data = data\\n        self.create_time = create_time\\n        self.update_time = update_time\\n        self.is_deleted = is_deleted\\n\",\n            \"name_column\": 8\n        },\n        \"to_dict\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"to_dict\",\n            \"md_content\": \"\",\n            \"code_start_line\": 28,\n            \"code_end_line\": 39,\n            \"parent\": \"XAgentRunningRecord\",\n            \"have_return\": true,\n            \"code_content\": \"    def to_dict(self):\\n        \\\"\\\"\\\"XAgent Running Recorder to dict\\\"\\\"\\\"\\n        return {\\n            \\\"record_id\\\": self.record_id,\\n            \\\"current\\\": self.current,\\n            \\\"node_id\\\": self.node_id,\\n            \\\"node_type\\\": self.node_type,\\n            \\\"data\\\": self.data,\\n            \\\"create_time\\\": self.create_time,\\n            \\\"update_time\\\": self.update_time,\\n            \\\"is_deleted\\\": self.is_deleted,\\n        }\\n\",\n            \"name_column\": 8\n        },\n        \"from_db\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"from_db\",\n            \"md_content\": \"\",\n            \"code_start_line\": 42,\n            \"code_end_line\": 53,\n            \"parent\": \"XAgentRunningRecord\",\n            \"have_return\": true,\n            \"code_content\": \"    def from_db(cls, db: RunningRecord):\\n        \\\"\\\"\\\"From db\\\"\\\"\\\"\\n        return cls(\\n            record_id=db.record_id,\\n            current=db.current,\\n            node_id=db.node_id,\\n            node_type=db.node_type,\\n            data=db.data,\\n            create_time=db.create_time,\\n            update_time=db.update_time,\\n            is_deleted=db.is_deleted,\\n        )\\n\",\n            \"name_column\": 8\n        },\n        \"from_dict\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"from_dict\",\n            \"md_content\": \"\",\n            \"code_start_line\": 56,\n            \"code_end_line\": 67,\n            \"parent\": \"XAgentRunningRecord\",\n            \"have_return\": true,\n            \"code_content\": \"    def from_dict(cls, data: dict):\\n        \\\"\\\"\\\"dict to XAgent Running Recorder\\\"\\\"\\\"\\n        return cls(\\n            record_id=data[\\\"record_id\\\"],\\n            current=data[\\\"current\\\"],\\n            node_id=data[\\\"node_id\\\"],\\n            node_type=data[\\\"node_type\\\"],\\n            data=data[\\\"data\\\"],\\n            create_time=data[\\\"create_time\\\"],\\n            update_time=data[\\\"update_time\\\"],\\n            is_deleted=data[\\\"is_deleted\\\"],\\n        )\\n\",\n            \"name_column\": 8\n        }\n    },\n    \"XAgentServer/models/global_png.py\": {\n        \"add_to_map\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"add_to_map\",\n            \"md_content\": \"\",\n            \"code_start_line\": 4,\n            \"code_end_line\": 5,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"def add_to_map(key, value):\\n    global_map[key] = value\\n\",\n            \"name_column\": 4\n        },\n        \"lookup_in_map\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"lookup_in_map\",\n            \"md_content\": \"\",\n            \"code_start_line\": 8,\n            \"code_end_line\": 9,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"def lookup_in_map(key):\\n    return global_map.get(key)\\n\",\n            \"name_column\": 4\n        }\n    },\n    \"XAgentServer/models/parameter.py\": {\n        \"InteractionParameter\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"InteractionParameter\",\n            \"md_content\": \"\",\n            \"code_start_line\": 6,\n            \"code_end_line\": 39,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"class InteractionParameter(metaclass=abc.ABCMeta):\\n    \\\"\\\"\\\"\\n    交互参数\\n    \\\"\\\"\\\"\\n\\n    def __init__(self,\\n                    interaction_id: str,\\n                    parameter_id: str,\\n                    args: Union[str, dict, None] = None\\n                    ):\\n        self.interaction_id = interaction_id\\n        self.args = args\\n        self.parameter_id = parameter_id\\n\\n    def to_dict(self):\\n        return {\\n            \\\"interaction_id\\\": self.interaction_id,\\n            \\\"parameter_id\\\": self.parameter_id,\\n            \\\"args\\\": self.args,\\n        }\\n\\n    def to_json(self):\\n        return json.dumps(self.to_dict(), indent=2, ensure_ascii=False)\\n\\n    @classmethod\\n    def from_json(cls, json_data):\\n        return cls(**json_data)\\n    \\n    @classmethod\\n    def from_db(cls, interaction):\\n        return cls(interaction.interaction_id,\\n                    interaction.parameter_id,\\n                    interaction.args\\n                    )\",\n            \"name_column\": 6\n        },\n        \"__init__\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"__init__\",\n            \"md_content\": \"\",\n            \"code_start_line\": 11,\n            \"code_end_line\": 18,\n            \"parent\": \"InteractionParameter\",\n            \"have_return\": false,\n            \"code_content\": \"    def __init__(self,\\n                    interaction_id: str,\\n                    parameter_id: str,\\n                    args: Union[str, dict, None] = None\\n                    ):\\n        self.interaction_id = interaction_id\\n        self.args = args\\n        self.parameter_id = parameter_id\\n\",\n            \"name_column\": 8\n        },\n        \"to_dict\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"to_dict\",\n            \"md_content\": \"\",\n            \"code_start_line\": 20,\n            \"code_end_line\": 25,\n            \"parent\": \"InteractionParameter\",\n            \"have_return\": true,\n            \"code_content\": \"    def to_dict(self):\\n        return {\\n            \\\"interaction_id\\\": self.interaction_id,\\n            \\\"parameter_id\\\": self.parameter_id,\\n            \\\"args\\\": self.args,\\n        }\\n\",\n            \"name_column\": 8\n        },\n        \"to_json\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"to_json\",\n            \"md_content\": \"\",\n            \"code_start_line\": 27,\n            \"code_end_line\": 28,\n            \"parent\": \"InteractionParameter\",\n            \"have_return\": true,\n            \"code_content\": \"    def to_json(self):\\n        return json.dumps(self.to_dict(), indent=2, ensure_ascii=False)\\n\",\n            \"name_column\": 8\n        },\n        \"from_json\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"from_json\",\n            \"md_content\": \"\",\n            \"code_start_line\": 31,\n            \"code_end_line\": 32,\n            \"parent\": \"InteractionParameter\",\n            \"have_return\": true,\n            \"code_content\": \"    def from_json(cls, json_data):\\n        return cls(**json_data)\\n\",\n            \"name_column\": 8\n        },\n        \"from_db\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"from_db\",\n            \"md_content\": \"\",\n            \"code_start_line\": 35,\n            \"code_end_line\": 39,\n            \"parent\": \"InteractionParameter\",\n            \"have_return\": true,\n            \"code_content\": \"    def from_db(cls, interaction):\\n        return cls(interaction.interaction_id,\\n                    interaction.parameter_id,\\n                    interaction.args\\n                    )\",\n            \"name_column\": 8\n        }\n    },\n    \"XAgentServer/application/global_val.py\": {\n        \"init_yag\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"init_yag\",\n            \"md_content\": \"\",\n            \"code_start_line\": 19,\n            \"code_end_line\": 30,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"def init_yag(logger):\\n    \\\"\\\"\\\"init yagmail service\\n\\n    Args:\\n        logger (_type_): _description_\\n    \\\"\\\"\\\"\\n    global yag\\n    if XAgentServerEnv.Email.send_email:\\n        yag = yagmail.SMTP(user=XAgentServerEnv.Email.email_user,\\n                           password=XAgentServerEnv.Email.email_password,\\n                           host=XAgentServerEnv.Email.email_host)\\n        logger.info(\\\"init yagmail\\\")\\n\",\n            \"name_column\": 4\n        },\n        \"init_executor\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"init_executor\",\n            \"md_content\": \"\",\n            \"code_start_line\": 33,\n            \"code_end_line\": 43,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"def init_executor(logger):\\n    \\\"\\\"\\\"init a thread pool executor\\n\\n    Args:\\n        logger (_type_): _description_\\n    \\\"\\\"\\\"\\n    global executor\\n    logger.typewriter_log(\\n        title=f\\\"init a thread pool executor, max_workers: {XAgentServerEnv.workers}\\\",\\n        title_color=Fore.RED)\\n    executor = ThreadPoolExecutor(max_workers=XAgentServerEnv.workers)\\n\",\n            \"name_column\": 4\n        }\n    },\n    \"XAgentServer/application/__init__.py\": {},\n    \"XAgentServer/application/dependence.py\": {\n        \"enable_logger\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"enable_logger\",\n            \"md_content\": \"\",\n            \"code_start_line\": 10,\n            \"code_end_line\": 18,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"def enable_logger():\\n    \\\"\\\"\\\"logger\\\"\\\"\\\"\\n    if not os.path.exists(os.path.join(XAgentServerEnv.base_dir, \\\"logs\\\")):\\n        os.makedirs(os.path.join(\\n            XAgentServerEnv.base_dir, \\\"logs\\\"))\\n\\n    logger = Logger(log_dir=os.path.join(\\n        XAgentServerEnv.base_dir, \\\"logs\\\"), log_file=\\\"app.log\\\", log_name=\\\"XAgentServerApp\\\")\\n    return logger\\n\",\n            \"name_column\": 4\n        },\n        \"enable_dependence\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"enable_dependence\",\n            \"md_content\": \"\",\n            \"code_start_line\": 21,\n            \"code_end_line\": 30,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"def enable_dependence(logger):\\n    \\\"\\\"\\\"dependence\\\"\\\"\\\"\\n    logger.typewriter_log(\\n        title=\\\"XAgent Service Init Dependence.\\\",\\n        title_color=Fore.RED)\\n    init_yag(logger)\\n    init_executor(logger)\\n    logger.typewriter_log(\\n        title=\\\"XAgent Service Init Dependence: Complete!\\\",\\n        title_color=Fore.RED)\\n\",\n            \"name_column\": 4\n        },\n        \"get_db\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"get_db\",\n            \"md_content\": \"\",\n            \"code_start_line\": 33,\n            \"code_end_line\": 43,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"def get_db():\\n    \\\"\\\"\\\"db\\\"\\\"\\\"\\n    session = SessionLocal()\\n    try:\\n        yield session\\n        session.commit()\\n    except Exception as e:\\n        session.rollback()\\n        raise e\\n    finally:\\n        session.close()\\n\",\n            \"name_column\": 4\n        }\n    },\n    \"XAgentServer/application/main.py\": {\n        \"db_session_middleware\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"db_session_middleware\",\n            \"md_content\": \"\",\n            \"code_start_line\": 20,\n            \"code_end_line\": 58,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"async def db_session_middleware(request: Request, call_next):\\n    \\\"\\\"\\\"\\n    Exception middleware\\n    \\\"\\\"\\\"\\n    # 默认响应\\n    message = \\\"Internal server error\\\"\\n    response = Response(message, status_code=500)\\n    try:\\n        response = await call_next(request)\\n    except XAgentDBError as error:\\n        traceback.print_exc()\\n        message = \\\"XAgent DB Error.\\\" if XAgentServerEnv.prod else error.message\\n        response = JSONResponse(\\n            status_code=500,\\n            content={\\\"status\\\": \\\"failed\\\", \\\"message\\\": message}\\n        )\\n    except XAgentFileError as error:\\n        traceback.print_exc()\\n        message = \\\"XAgent File Error.\\\" if XAgentServerEnv.prod else error.message\\n        response = JSONResponse(\\n            status_code=500,\\n            content={\\\"status\\\": \\\"failed\\\", \\\"message\\\": message}\\n        )\\n    except XAgentAuthError as error:\\n        traceback.print_exc()\\n        response = JSONResponse(\\n            status_code=401,\\n            content={\\\"status\\\": \\\"failed\\\", \\\"message\\\": error.message}\\n        )\\n    except XAgentError as error:\\n        traceback.print_exc()\\n        message = \\\"XAgent Error.\\\" if XAgentServerEnv.prod else error.message\\n   \\n        response = JSONResponse(\\n            status_code=500,\\n            content={\\\"status\\\": \\\"failed\\\", \\\"message\\\": message}\\n        )\\n\\n    return response\\n\",\n            \"name_column\": 10\n        },\n        \"print_start_message\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"print_start_message\",\n            \"md_content\": \"\",\n            \"code_start_line\": 61,\n            \"code_end_line\": 100,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"async def print_start_message():\\n    \\\"\\\"\\\"\\n    print start message\\n    \\\"\\\"\\\"\\n    logger.typewriter_log(\\n        title=\\\"XAgent Server Dependences:\\\",\\n        title_color=Fore.RED,\\n        content=\\\"\\\"\\\"\\n        Python: 3.10+ \\n        FastAPI: Http server\\n        Websocket: long connect with client\\n        MySQL: save xagent data\\n        SqlAlchemy: ORM with MySQL\\n        Redis: save status of interaction\\n        Threading: run interaction\\n        APScheduler: send data to client and keep alive\\n        FastAPI APIRouter: manage websocket route\\n        XAgentError: XAgentServer.exts.exception_ext\\\"\\\"\\\",\\n        )\\n    logger.typewriter_log(\\n        title=\\\"XAgent Server Version:\\\",\\n        title_color=Fore.RED,\\n        content=\\\"\\\"\\\"\\n        V 1.1.0\\\"\\\"\\\",\\n        )\\n    logger.typewriter_log(\\n        title=\\\"Notes:\\\",\\n        title_color=Fore.RED,\\n        content=\\\"\\\"\\\"\\n        Since V 1.1.0, \\n        Local storage will no longer be supported, replaced by Mysql.\\n        The service depends on Redis and Mysql, \\n        so you need to install Redis and Mysql before using it.\\n        Before you use this service, please ensure that the following services are available:\\n            1. Redis on docker, port: 6379, you can start it by docker, default password: xagent\\n            2. Mysql on docker, port: 3306, you can start it by docker\\n            3. XAgent Tool Server is runnning on port 8080\\n            4. Port 8090 is not occupied\\n        \\\"\\\"\\\",\\n        )\\n\",\n            \"name_column\": 10\n        },\n        \"startup_event\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"startup_event\",\n            \"md_content\": \"\",\n            \"code_start_line\": 103,\n            \"code_end_line\": 110,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"async def startup_event():\\n    \\\"\\\"\\\"start up event\\n    \\\"\\\"\\\"\\n    logger.info(\\\"XAgent Service Startup Param:\\\")\\n    for key, item in XAgentServerEnv.__dict__.items():\\n        if not key.startswith(\\\"__\\\"):\\n            logger.info(f\\\"{' '*10}{key}: {item}\\\")\\n    enable_dependence(logger)\\n\",\n            \"name_column\": 10\n        },\n        \"startup\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"startup\",\n            \"md_content\": \"\",\n            \"code_start_line\": 114,\n            \"code_end_line\": 123,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"async def startup():\\n    \\\"\\\"\\\"\\n    start up event\\n    \\\"\\\"\\\"\\n    await startup_event()\\n    if XAgentServerEnv.default_login:\\n        logger.typewriter_log(\\n            title=\\\"Default user: Guest, token: xagent, you can use it to login\\\",\\n            title_color=Fore.RED)\\n    await print_start_message()\\n\",\n            \"name_column\": 10\n        },\n        \"shutdown\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"shutdown\",\n            \"md_content\": \"\",\n            \"code_start_line\": 127,\n            \"code_end_line\": 131,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"async def shutdown():\\n    \\\"\\\"\\\"\\n    shut down event\\n    \\\"\\\"\\\"\\n    print(\\\"XAgent Service Shutdown!\\\")\\n\",\n            \"name_column\": 10\n        },\n        \"validation_exception_handler\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"validation_exception_handler\",\n            \"md_content\": \"\",\n            \"code_start_line\": 135,\n            \"code_end_line\": 148,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"async def validation_exception_handler(request: Request, exc: RequestValidationError):\\n    \\\"\\\"\\\"handle validation exception\\n\\n    Args:\\n        request (Request): _description_\\n        exc (RequestValidationError): _description_\\n\\n    Returns:\\n        _type_: _description_\\n    \\\"\\\"\\\"\\n    return JSONResponse(\\n        status_code=400,\\n        content={\\\"status\\\": \\\"failed\\\", \\\"message\\\": exc.errors()}\\n    )\\n\",\n            \"name_column\": 10\n        }\n    },\n    \"XAgentServer/application/routers/user.py\": {\n        \"register\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"register\",\n            \"md_content\": \"\",\n            \"code_start_line\": 21,\n            \"code_end_line\": 56,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"async def register(email: str = Form(...),\\n                   name: str = Form(...),\\n                   corporation: str = Form(...),\\n                   position: str = Form(...),\\n                   industry: str = Form(...),\\n                   db: Session = Depends(get_db)) -> ResponseBody:\\n    \\\"\\\"\\\"\\n    register user\\n    \\\"\\\"\\\"\\n    if UserCRUD.is_exist(db=db, email=email):\\n        return ResponseBody(success=False, message=\\\"user is already exist\\\")\\n\\n    token = uuid.uuid4().hex\\n    user = {\\\"user_id\\\": uuid.uuid4().hex, \\\"email\\\": email, \\\"name\\\": name,\\n            \\\"token\\\": token, \\\"available\\\": False, \\\"corporation\\\": corporation,\\n            \\\"position\\\": position, \\\"industry\\\": industry,\\n            \\\"create_time\\\": datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\"),\\n            \\\"update_time\\\": datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\"),\\n            \\\"is_beta\\\": False}\\n    try:\\n\\n        contents = email_content(user)\\n\\n        if XAgentServerEnv.Email.send_email:\\n            from XAgentServer.application.global_val import yag\\n            yag.send(user[\\\"email\\\"], 'XAgent Token Verification', contents)\\n        else:\\n            user[\\\"available\\\"] = True\\n        UserCRUD.add_user(db=db, user_dict=user)\\n    except smtplib.SMTPAuthenticationError:\\n        return ResponseBody(success=False, message=\\\"email send failed!\\\", data=None)\\n\\n    except Exception:\\n        return ResponseBody(success=False, message=\\\"register failed\\\", data=None)\\n\\n    return ResponseBody(data=user, success=True, message=\\\"Register success, we will send a email to you!\\\")\\n\",\n            \"name_column\": 10\n        },\n        \"auth\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"auth\",\n            \"md_content\": \"\",\n            \"code_start_line\": 60,\n            \"code_end_line\": 85,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"async def auth(user_id: str = Query(...),\\n               token: str = Query(...),\\n               db: Session = Depends(get_db)\\n               ) -> ResponseBody:\\n    \\\"\\\"\\\"\\n    user auth\\n    \\\"\\\"\\\"\\n    user = UserCRUD.get_user(db=db, user_id=user_id)\\n    if user is None:\\n        return ResponseBody(success=False, message=\\\"user is not exist\\\")\\n\\n    if user.token != token:\\n        return ResponseBody(success=False, message=\\\"token is not correct\\\")\\n    expired_time = datetime.now() - datetime.strptime(\\n        user.update_time, \\\"%Y-%m-%d %H:%M:%S\\\")\\n    if expired_time.seconds > 60 * 60 * 24 * 7:\\n        return ResponseBody(success=False, message=\\\"token is expired\\\")\\n    if not user.available:\\n\\n        user.available = True\\n        user.update_time = datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\")\\n        UserCRUD.update_user(db=db, user=user)\\n    else:\\n        return ResponseBody(success=False, message=\\\"user is already available!\\\")\\n\\n    return ResponseBody(data=user.to_dict(), success=True, message=\\\"auth success\\\")\\n\",\n            \"name_column\": 10\n        },\n        \"login\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"login\",\n            \"md_content\": \"\",\n            \"code_start_line\": 89,\n            \"code_end_line\": 104,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"async def login(email: str = Form(...),\\n                token: str = Form(...),\\n                db: Session = Depends(get_db)) -> ResponseBody:\\n    \\\"\\\"\\\"\\n    login\\n    \\\"\\\"\\\"\\n    user = UserCRUD.get_user(db=db, email=email)\\n    if user is None:\\n        return ResponseBody(success=False, message=\\\"user is not exist\\\")\\n\\n    if user.token != token:\\n        return ResponseBody(success=False, message=\\\"token is not correct\\\")\\n    if not user.available:\\n        return ResponseBody(success=False, message=\\\"user is not available\\\")\\n\\n    return ResponseBody(data=user.to_dict(), success=True, message=\\\"login success\\\")\\n\",\n            \"name_column\": 10\n        },\n        \"check\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"check\",\n            \"md_content\": \"\",\n            \"code_start_line\": 108,\n            \"code_end_line\": 120,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"async def check(token: str = Form(...), db: Session = Depends(get_db)) -> ResponseBody:\\n    \\\"\\\"\\\"\\n    check token is effective\\n    \\\"\\\"\\\"\\n    if token is None:\\n        return ResponseBody(success=False, message=\\\"token is none\\\")\\n\\n    result = UserCRUD.token_is_exist(db=db, token=token, user_id=None)\\n\\n    if result:\\n        return ResponseBody(data=result, success=True, message=\\\"token is effective\\\")\\n\\n    return ResponseBody(data=result, success=True, message=\\\"token is invalid\\\")\\n\",\n            \"name_column\": 10\n        }\n    },\n    \"XAgentServer/application/routers/__init__.py\": {},\n    \"XAgentServer/application/routers/conv.py\": {\n        \"user_is_available\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"user_is_available\",\n            \"md_content\": \"\",\n            \"code_start_line\": 31,\n            \"code_end_line\": 44,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"def user_is_available(\\n        user_id: str = Form(...),\\n        token: str = Form(...),\\n        db: Session = Depends(get_db)):\\n    \\\"\\\"\\\"\\n    check user is available    \\n    \\\"\\\"\\\"\\n    if user_id == \\\"\\\":\\n        raise XAgentAuthError(\\\"user_id is empty!\\\")\\n    if not UserCRUD.is_exist(db=db, user_id=user_id):\\n        raise XAgentAuthError(\\\"user is not exist!\\\")\\n    if not UserCRUD.user_is_valid(db=db, user_id=user_id, token=token):\\n        raise XAgentAuthError(\\\"user is not available!\\\")\\n    return user_id\\n\",\n            \"name_column\": 4\n        },\n        \"get_all_interactions\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"get_all_interactions\",\n            \"md_content\": \"\",\n            \"code_start_line\": 48,\n            \"code_end_line\": 60,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"async def get_all_interactions(user_id: str = Depends(user_is_available),\\n                               page_size: int = Form(...),\\n                               page_num: int = Form(...),\\n                               db: Session = Depends(get_db)) -> ResponseBody:\\n    \\\"\\\"\\\"\\n    get all interactions by user_id\\n    \\\"\\\"\\\"\\n\\n    data = InteractionCRUD.search_interaction_by_user_id(db=db,\\n                                                         user_id=user_id,\\n                                                         page_size=page_size,\\n                                                         page_num=page_num)\\n    return ResponseBody(data=data, success=True, message=\\\"success\\\")\\n\",\n            \"name_column\": 10\n        },\n        \"init_conv_env\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"init_conv_env\",\n            \"md_content\": \"\",\n            \"code_start_line\": 64,\n            \"code_end_line\": 92,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"def init_conv_env(user_id: str = Depends(user_is_available),\\n                  db: Session = Depends(get_db)):\\n    \\\"\\\"\\\"\\n    initialize conv env\\n    \\\"\\\"\\\"\\n\\n    interaction = InteractionCRUD.get_ready_interaction(db=db, user_id=user_id)\\n\\n    if interaction is None:\\n        interaction_id = uuid.uuid4().hex\\n        base = InteractionBase(interaction_id=interaction_id,\\n                               user_id=user_id,\\n                               create_time=datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\"),\\n                               description=\\\"XAgent\\\",\\n                               agent=\\\"\\\",\\n                               mode=\\\"\\\",\\n                               file_list=[],\\n                               recorder_root_dir=\\\"\\\",\\n                               status=\\\"ready\\\",\\n                               message=\\\"ready...\\\",\\n                               current_step=\\\"-1\\\",\\n                               update_time=datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\")\\n                               )\\n        InteractionCRUD.create_interaction(db=db, base=base)\\n    else:\\n        interaction_id = interaction.interaction_id\\n\\n    return ResponseBody(data={\\\"id\\\": interaction_id,\\n                              \\\"t\\\": str(int(datetime.now().timestamp() * 1000))}, success=True, message=\\\"success\\\")\\n\",\n            \"name_column\": 4\n        },\n        \"get_share_interactions\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"get_share_interactions\",\n            \"md_content\": \"\",\n            \"code_start_line\": 96,\n            \"code_end_line\": 106,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"async def get_share_interactions(user_id: str = Depends(user_is_available),\\n                                 page_size: int = Form(...),\\n                                 page_num: int = Form(...),\\n                                 db: Session = Depends(get_db)) -> ResponseBody:\\n    \\\"\\\"\\\"\\n    get all interactions by user id\\n    \\\"\\\"\\\"\\n\\n    data = InteractionCRUD.search_many_shared(\\n        db=db, page_size=page_size, page_index=page_num)\\n    return ResponseBody(data=data, success=True, message=\\\"success\\\")\\n\",\n            \"name_column\": 10\n        },\n        \"share_interaction\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"share_interaction\",\n            \"md_content\": \"\",\n            \"code_start_line\": 110,\n            \"code_end_line\": 168,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"async def share_interaction(user_id: str = Depends(user_is_available),\\n                            interaction_id: str = Form(...),\\n                            db: Session = Depends(get_db)) -> ResponseBody:\\n    \\\"\\\"\\\"\\n    update_interaction_description\\n    \\\"\\\"\\\"\\n    interaction = InteractionCRUD.get_interaction(db=db,\\n                                                  interaction_id=interaction_id)\\n    if interaction is None:\\n        return ResponseBody(success=False,\\n                            message=f\\\"Don't find any interaction by interaction_id: \\\\\\n                                {interaction_id}, Please check your interaction_id!\\\")\\n\\n    finish_status = InteractionCRUD.get_finish_status(\\n        db=db, interaction_id=interaction_id)\\n    if not finish_status:\\n        return ResponseBody(success=False, message=\\\"interaction is not finish!\\\")\\n    user = UserCRUD.get_user(db=db, user_id=user_id)\\n    user_name = user.name\\n    interaction_dir = os.path.join(XAgentServerEnv.base_dir,\\n                                   \\\"localstorage\\\",\\n                                   \\\"interact_records\\\",\\n                                   interaction.create_time[:10],\\n                                   interaction_id)\\n    workspace_dir = os.path.join(interaction_dir, \\\"workspace\\\")\\n    zip_file = os.path.join(interaction_dir, \\\"workspace.zip\\\")\\n    if not os.path.exists(zip_file):\\n        if os.path.exists(workspace_dir):\\n            files = os.listdir(workspace_dir)\\n            # zip workspace\\n            with zipfile.ZipFile(zip_file, 'w', zipfile.ZIP_DEFLATED) as z:\\n                for f in files:\\n                    file = os.path.join(workspace_dir, f)\\n                    z.write(file, arcname=f)\\n\\n    raws = InteractionCRUD.search_many_raws(\\n        db=db, interaction_id=interaction_id)\\n\\n    share_data = {\\n        \\\"user_id\\\": user_id,\\n        \\\"user_name\\\": user_name,\\n        \\\"token\\\": user.token,\\n        \\\"interaction\\\": json.dumps(interaction.to_dict(), ensure_ascii=False),\\n        \\\"raws\\\": json.dumps([raw.to_dict() for raw in raws], ensure_ascii=False),\\n    }\\n\\n    with open(zip_file, 'rb') as f:\\n        files = {\\\"files\\\": f.read()}\\n    try:\\n        res = requests.post(url=XAgentServerEnv.share_url,\\n                            data=share_data,\\n                            files=files,\\n                            timeout=60)\\n\\n        data = res.json()\\n\\n        return ResponseBody(**data)\\n    except Exception as e:\\n        return ResponseBody(success=False, message=str(e), data=None)\\n\",\n            \"name_column\": 10\n        },\n        \"community\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"community\",\n            \"md_content\": \"\",\n            \"code_start_line\": 172,\n            \"code_end_line\": 250,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"def community(user_id: str = Depends(user_is_available),\\n              user_name: str = Form(...),\\n              interaction: str = Form(...),\\n              raws: str = Form(...),\\n              files: UploadFile = File(...),\\n              db: Session = Depends(get_db)):\\n    \\\"\\\"\\\"\\n    community, this api is runing on x-agent.net\\n    \\\"\\\"\\\"\\n    interaction = json.loads(interaction)\\n    raws = json.loads(raws)\\n    interaction_id = interaction[\\\"interaction_id\\\"]\\n    old_share = InteractionCRUD.get_shared_interaction(\\n        db=db, interaction_id=interaction_id)\\n\\n    # 如果已经分享过了，就不再分享了\\n    if old_share:\\n        raise XAgentWebError(\\\"interaction is exist!\\\")\\n\\n    contain_finish = False\\n    for raw in raws:\\n        if raw[\\\"status\\\"] == StatusEnum.FINISHED:\\n            contain_finish = True\\n            break\\n    # 如果没有finish的节点，就不分享了\\n    if not contain_finish:\\n        raise XAgentWebError(\\\"interaction is not finish!\\\")\\n\\n    interaction_dir = os.path.join(XAgentServerEnv.base_dir,\\n                                   \\\"localstorage\\\",\\n                                   \\\"interact_records\\\",\\n                                   interaction[\\\"create_time\\\"][:10],\\n                                   interaction_id,\\n                                   \\\"workspace\\\")\\n\\n    if not os.path.exists(interaction_dir):\\n        os.makedirs(interaction_dir)\\n\\n    # 先暂存文件\\n    with open(os.path.join(interaction_dir, \\\"workspace.zip\\\"), \\\"wb\\\") as f:\\n        f.write(files.file.read())\\n\\n    # 解压文件\\n    with zipfile.ZipFile(file=os.path.join(interaction_dir, \\\"workspace.zip\\\"), mode=\\\"r\\\") as zip_file:\\n        zip_list = zip_file.namelist()  # 得到压缩包里所有文件\\n        for f in zip_list:\\n            zip_file.extract(f, interaction_dir)  # 循环解压文件到指定目录\\n\\n    # 删除压缩包\\n    os.remove(os.path.join(interaction_dir, \\\"workspace.zip\\\"))\\n\\n    base = InteractionBase(**interaction)\\n\\n    share = SharedInteractionBase(\\n        interaction_id=interaction_id,\\n        user_name=user_name,\\n        create_time=interaction[\\\"create_time\\\"],\\n        update_time=interaction[\\\"update_time\\\"],\\n        description=interaction[\\\"description\\\"],\\n        agent=interaction[\\\"agent\\\"],\\n        mode=interaction[\\\"mode\\\"],\\n        is_deleted=False,\\n        star=0,\\n        is_audit=False\\n    )\\n\\n    InteractionCRUD.create_interaction(db=db, base=base)\\n\\n    InteractionCRUD.add_share(db=db, share=share)\\n\\n    for raw in raws:\\n        old_raw = InteractionCRUD.get_raw(db=db,\\n                                          interaction_id=interaction_id,\\n                                          node_id=raw[\\\"node_id\\\"])\\n        if old_raw is None:\\n            xraw = XAgentRaw(**raw)\\n            InteractionCRUD.insert_raw(db=db, process=xraw)\\n\\n    return ResponseBody(data=None, success=True, message=\\\"success\\\")\\n\",\n            \"name_column\": 4\n        },\n        \"delete_interaction\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"delete_interaction\",\n            \"md_content\": \"\",\n            \"code_start_line\": 254,\n            \"code_end_line\": 264,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"async def delete_interaction(user_id: str = Depends(user_is_available),\\n                             interaction_id: str = Form(...),\\n                             db: Session = Depends(get_db)) -> ResponseBody:\\n    \\\"\\\"\\\"\\n    delete\\n    \\\"\\\"\\\"\\n\\n    data = InteractionCRUD.delete_interaction(db=db,\\n                                              interaction_id=interaction_id)\\n\\n    return ResponseBody(data=data, success=True, message=\\\"success\\\")\\n\",\n            \"name_column\": 10\n        },\n        \"update_interaction_parameter\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"update_interaction_parameter\",\n            \"md_content\": \"\",\n            \"code_start_line\": 268,\n            \"code_end_line\": 293,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"async def update_interaction_parameter(user_id: str = Depends(user_is_available),\\n                                       mode: str = Form(...),\\n                                       agent: str = Form(...),\\n                                       file_list: List[str] = Form(...),\\n                                       interaction_id: str = Form(...),\\n                                       db: Session = Depends(get_db)\\n                                       ) -> ResponseBody:\\n    \\\"\\\"\\\"\\n    update parameter\\n\\n    \\\"\\\"\\\"\\n    if interaction_id == \\\"\\\":\\n        return ResponseBody(success=False, message=\\\"interaction_id is empty!\\\")\\n    interaction = InteractionCRUD.get_interaction(db=db,\\n                                                  interaction_id=interaction_id)\\n    if interaction is None:\\n        return ResponseBody(success=False, message=f\\\"Don't find any interaction by interaction_id:\\\\\\n            {interaction_id}, Please check your interaction_id!\\\")\\n    update_data = {\\n        \\\"interaction_id\\\": interaction_id,\\n        \\\"agent\\\": agent,\\n        \\\"mode\\\": mode,\\n        \\\"file_list\\\": [json.loads(l) for l in file_list],\\n    }\\n    InteractionCRUD.update_interaction(db=db, base_data=update_data)\\n    return ResponseBody(data=update_data, success=True, message=\\\"success!\\\")\\n\",\n            \"name_column\": 10\n        },\n        \"update_interaction_description\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"update_interaction_description\",\n            \"md_content\": \"\",\n            \"code_start_line\": 297,\n            \"code_end_line\": 318,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"async def update_interaction_description(user_id: str = Depends(user_is_available),\\n                                         description: str = Form(...),\\n                                         interaction_id: str = Form(...),\\n                                         db: Session = Depends(get_db)\\n                                         ) -> ResponseBody:\\n    \\\"\\\"\\\"\\n    update description\\n\\n    \\\"\\\"\\\"\\n    if interaction_id == \\\"\\\":\\n        return ResponseBody(success=False, message=\\\"interaction_id is empty!\\\")\\n    interaction = InteractionCRUD.get_interaction(db=db,\\n                                                  interaction_id=interaction_id)\\n    if interaction is None:\\n        return ResponseBody(success=False, message=f\\\"Don't find any interaction by interaction_id:\\\\\\n            {interaction_id}, Please check your interaction_id!\\\")\\n    update_data = {\\n        \\\"interaction_id\\\": interaction_id,\\n        \\\"description\\\": description if description else \\\"XAgent\\\",\\n    }\\n    InteractionCRUD.update_interaction(db=db, base_data=update_data)\\n    return ResponseBody(data=update_data, success=True, message=\\\"success!\\\")\\n\",\n            \"name_column\": 10\n        }\n    },\n    \"XAgentServer/application/routers/workspace.py\": {\n        \"user_is_available\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"user_is_available\",\n            \"md_content\": \"\",\n            \"code_start_line\": 24,\n            \"code_end_line\": 38,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"def user_is_available(\\n        user_id: str = Form(...),\\n        token: str = Form(...),\\n        db: Session = Depends(get_db)):\\n    \\\"\\\"\\\"\\n    check user is available    \\n    \\\"\\\"\\\"\\n    if user_id == \\\"\\\":\\n        raise HTTPException(status_code=401, detail=\\\"user_id is empty!\\\")\\n    if not UserCRUD.is_exist(db=db, user_id=user_id):\\n        raise HTTPException(status_code=401, detail=\\\"user is not exist!\\\")\\n    if not UserCRUD.user_is_valid(db=db, user_id=user_id, token=token):\\n        raise HTTPException(\\n            status_code=401, detail=\\\"user is not available!\\\")\\n    return user_id\\n\",\n            \"name_column\": 4\n        },\n        \"create_upload_files\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"create_upload_files\",\n            \"md_content\": \"\",\n            \"code_start_line\": 42,\n            \"code_end_line\": 67,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"async def create_upload_files(files: List[UploadFile] = File(...),\\n                              user_id: str = Depends(user_is_available)) -> ResponseBody:\\n    \\\"\\\"\\\"Upload Files\\\"\\\"\\\"\\n\\n    if len(files) == 0:\\n        return ResponseBody(success=False, message=\\\"files is empty!\\\")\\n    if len(files) > 5:\\n        files = files[:5]\\n\\n    if not os.path.exists(os.path.join(XAgentServerEnv.Upload.upload_dir, user_id)):\\n        os.makedirs(os.path.join(XAgentServerEnv.Upload.upload_dir, user_id))\\n\\n    for f in files:\\n        if f.size > 1024 * 1024 * 1:\\n            return ResponseBody(success=False,\\n                                message=\\\"file size is too large, limit is 1MB for each file!\\\")\\n\\n    file_list = []\\n    for file in files:\\n        file_name = uuid.uuid4().hex + os.path.splitext(file.filename)[-1]\\n        with open(os.path.join(XAgentServerEnv.Upload.upload_dir, user_id, file_name), \\\"wb\\\") as f:\\n            f.write(await file.read())\\n            file_list.append({\\\"uuid\\\": file_name, \\\"name\\\": file.filename})\\n    return ResponseBody(data={\\\"user_id\\\": user_id,\\n                              \\\"file_list\\\": file_list},\\n                        success=True, message=\\\"upload success\\\")\\n\",\n            \"name_column\": 10\n        },\n        \"file\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"file\",\n            \"md_content\": \"\",\n            \"code_start_line\": 71,\n            \"code_end_line\": 139,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"async def file(user_id: str = Depends(user_is_available),\\n               interaction_id: str = Form(...),\\n               db: Session = Depends(get_db),\\n               file_name: str = Form(...)):\\n    \\\"\\\"\\\"\\n    get download file\\n    \\\"\\\"\\\"\\n    interaction = InteractionCRUD.get_interaction(db=db, interaction_id=interaction_id)\\n\\n    if interaction is None:\\n        return ResponseBody(success=False, message=\\\"interaction is not exist!\\\")\\n\\n    time_str = interaction.create_time[:10]\\n\\n    file_path = os.path.join(\\n        XAgentServerEnv.base_dir,\\n        \\\"localstorage/interact_records\\\",\\n        time_str,\\n        interaction_id,\\n        \\\"workspace\\\")\\n    if not os.path.exists(file_path):\\n        return ResponseBody(success=False,\\n                            message=\\\"file is not exist!\\\")\\n\\n    file_suffix = file_name.split(\\\".\\\")[-1]\\n    if file_suffix in [\\\"jpg\\\", \\\"png\\\",\\n                       \\\"jpeg\\\", \\\"gif\\\", \\\"bmp\\\"]:\\n        with open(os.path.join(file_path, file_name), \\\"rb\\\") as f:\\n            data = base64.b64encode(f.read()).decode(\\\"utf-8\\\")\\n        return ResponseBody(\\n            data=f\\\"data:image/{file_suffix};base64,{data}\\\",\\n            success=True,\\n            message=\\\"get file success!\\\"\\n        )\\n\\n    if file_suffix in [\\\"mp4\\\", \\\"avi\\\", \\\"mkv\\\",\\n                       \\\"rmvb\\\", \\\"rm\\\", \\\"flv\\\", \\\"3gp\\\", \\\"wmv\\\"]:\\n        return FileResponse(os.path.join(file_path, file_name),\\n                            media_type=\\\"video/\\\" + file_suffix)\\n\\n    if file_suffix in [\\\"mp3\\\", \\\"wav\\\", \\\"wma\\\",\\n                       \\\"ogg\\\", \\\"aac\\\", \\\"flac\\\", \\\"ape\\\"]:\\n        return FileResponse(os.path.join(file_path, file_name),\\n                            media_type=\\\"audio/\\\" + file_suffix)\\n\\n    if file_suffix in [\\\"pdf\\\", \\\"doc\\\", \\\"docx\\\",\\n                       \\\"xls\\\", \\\"xlsx\\\", \\\"ppt\\\", \\\"pptx\\\"]:\\n        return FileResponse(os.path.join(file_path, file_name),\\n                            media_type=\\\"application/\\\" + file_suffix)\\n\\n    if file_suffix in [\\\"json\\\"]:\\n        with open(os.path.join(file_path, file_name), 'r', encoding=\\\"utf-8\\\") as f:\\n            data = json.load(f)\\n\\n        return ResponseBody(data=json.dumps(data,\\n                                            ensure_ascii=False,\\n                                            indent=4),\\n                            success=True,\\n                            message=\\\"get file success!\\\")\\n\\n    if file_suffix in [\\\"ipynb\\\"]:\\n        return FileResponse(os.path.join(file_path, file_name),\\n                            media_type=\\\"application/\\\" + file_suffix)\\n    \\n    \\n    with open(os.path.join(file_path, file_name), 'r', encoding=\\\"utf-8\\\") as f:\\n        data = f.read()\\n\\n    return ResponseBody(data=data, success=True, message=\\\"get file success!\\\")\\n\",\n            \"name_column\": 10\n        }\n    },\n    \"XAgentServer/application/core/envs.py\": {\n        \"XAgentServerEnv\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"XAgentServerEnv\",\n            \"md_content\": \"\",\n            \"code_start_line\": 11,\n            \"code_end_line\": 90,\n            \"parent\": null,\n            \"have_return\": false,\n            \"code_content\": \"class XAgentServerEnv:\\n    \\\"\\\"\\\"\\n    XAgentServer environment variables\\n    if you change value of the environment variable, you need to restart \\n    the XAgentServer by running the following command:\\n    `python start_server.py`\\n    or start a unicorn server by yourself\\n    \\\"\\\"\\\"\\n    app = \\\"app:app\\\"\\n    prod: bool = config.get(\\\"PROD\\\", \\\"False\\\").lower() == \\\"true\\\"\\n    base_dir = \\\"XAgentServer\\\"\\n    use_redis: bool = False\\n    recorder_root_dir = \\\"running_records\\\"\\n    # you can set default_login with True,\\n    # use the default user \\\"admin\\\" with token \\\"xagent-admin\\\" to login,\\n    default_login: bool = True\\n    # only one XAgentServer can be set to check whether the interaction is running.\\n    check_running: bool = False\\n    host = \\\"0.0.0.0\\\"\\n    port = 8090\\n    debug = True\\n    reload = True\\n    workers = 1\\n    share_url = \\\"https://x-agent.net/api/conv/community\\\"\\n\\n    class DB:\\n        \\\"\\\"\\\"\\n        database config\\n        \\\"\\\"\\\"\\n        use_db = True\\n        db_url = \\\"mysql+pymysql://root:xagent@localhost:3306/xagent\\\"\\n\\n    class Redis:\\n        \\\"\\\"\\\"\\n        redis config\\n        \\\"\\\"\\\"\\n        use_redis = False\\n        redis_url = \\\"redis://localhost\\\"\\n        redis_host = \\\"localhost\\\"\\n        redis_port = 6379\\n        redis_db = 0\\n        redis_password = \\\"xagent\\\"\\n\\n    # if you want to use email to send message,\\n    # you can set send_email to True and set\\n    # email_host,\\n    # email_port,\\n    # email_user,\\n    # email_password,\\n    # auth_server\\n    class Email:\\n        \\\"\\\"\\\"\\n        email config\\n        \\\"\\\"\\\"\\n        send_email = False\\n        email_host = \\\"\\\"\\n        email_port = 465\\n        email_user = \\\"\\\"\\n        email_password = \\\"\\\"\\n        auth_server = \\\"\\\"\\n\\n    # if you want to use upload function,\\n    # you can set upload_dir to the path of the upload directory\\n    # and set upload_allowed_types of the allowed types\\n    class Upload:\\n        \\\"\\\"\\\"\\n        upload config\\n        \\\"\\\"\\\"\\n        upload_dir = \\\"XAgentServer/localstorage/upload\\\"\\n        if not os.path.exists(upload_dir):\\n            os.makedirs(upload_dir)\\n        upload_allowed_types = [\\\"image/png\\\", \\\"image/jpeg\\\",\\n                                \\\"image/gif\\\", \\\"text/plain\\\",\\n                                \\\"application/msword\\\", \\\"pdf\\\",\\n                                \\\"txt\\\", \\\"pptx\\\", \\\"xlsx\\\",\\n                                \\\"doc\\\", \\\"ppt\\\", \\\"xls\\\",\\n                                \\\"zip\\\", \\\"rar\\\", \\\"tar\\\",\\n                                \\\"gz\\\", \\\"7z\\\", \\\"bz2\\\",\\n                                \\\"tgz\\\", \\\"tbz2\\\", \\\"tar.gz\\\",\\n                                \\\"tar.bz2\\\"]\\n\",\n            \"name_column\": 6\n        },\n        \"DB\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"DB\",\n            \"md_content\": \"\",\n            \"code_start_line\": 36,\n            \"code_end_line\": 41,\n            \"parent\": \"XAgentServerEnv\",\n            \"have_return\": false,\n            \"code_content\": \"    class DB:\\n        \\\"\\\"\\\"\\n        database config\\n        \\\"\\\"\\\"\\n        use_db = True\\n        db_url = \\\"mysql+pymysql://root:xagent@localhost:3306/xagent\\\"\\n\",\n            \"name_column\": 10\n        },\n        \"Redis\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"Redis\",\n            \"md_content\": \"\",\n            \"code_start_line\": 43,\n            \"code_end_line\": 52,\n            \"parent\": \"XAgentServerEnv\",\n            \"have_return\": false,\n            \"code_content\": \"    class Redis:\\n        \\\"\\\"\\\"\\n        redis config\\n        \\\"\\\"\\\"\\n        use_redis = False\\n        redis_url = \\\"redis://localhost\\\"\\n        redis_host = \\\"localhost\\\"\\n        redis_port = 6379\\n        redis_db = 0\\n        redis_password = \\\"xagent\\\"\\n\",\n            \"name_column\": 10\n        },\n        \"Email\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"Email\",\n            \"md_content\": \"\",\n            \"code_start_line\": 61,\n            \"code_end_line\": 70,\n            \"parent\": \"XAgentServerEnv\",\n            \"have_return\": false,\n            \"code_content\": \"    class Email:\\n        \\\"\\\"\\\"\\n        email config\\n        \\\"\\\"\\\"\\n        send_email = False\\n        email_host = \\\"\\\"\\n        email_port = 465\\n        email_user = \\\"\\\"\\n        email_password = \\\"\\\"\\n        auth_server = \\\"\\\"\\n\",\n            \"name_column\": 10\n        },\n        \"Upload\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"Upload\",\n            \"md_content\": \"\",\n            \"code_start_line\": 75,\n            \"code_end_line\": 90,\n            \"parent\": \"XAgentServerEnv\",\n            \"have_return\": false,\n            \"code_content\": \"    class Upload:\\n        \\\"\\\"\\\"\\n        upload config\\n        \\\"\\\"\\\"\\n        upload_dir = \\\"XAgentServer/localstorage/upload\\\"\\n        if not os.path.exists(upload_dir):\\n            os.makedirs(upload_dir)\\n        upload_allowed_types = [\\\"image/png\\\", \\\"image/jpeg\\\",\\n                                \\\"image/gif\\\", \\\"text/plain\\\",\\n                                \\\"application/msword\\\", \\\"pdf\\\",\\n                                \\\"txt\\\", \\\"pptx\\\", \\\"xlsx\\\",\\n                                \\\"doc\\\", \\\"ppt\\\", \\\"xls\\\",\\n                                \\\"zip\\\", \\\"rar\\\", \\\"tar\\\",\\n                                \\\"gz\\\", \\\"7z\\\", \\\"bz2\\\",\\n                                \\\"tgz\\\", \\\"tbz2\\\", \\\"tar.gz\\\",\\n                                \\\"tar.bz2\\\"]\\n\",\n            \"name_column\": 10\n        }\n    },\n    \"XAgentServer/application/websockets/replayer.py\": {\n        \"ReplayServer\": {\n            \"type\": \"ClassDef\",\n            \"name\": \"ReplayServer\",\n            \"md_content\": \"\",\n            \"code_start_line\": 29,\n            \"code_end_line\": 195,\n            \"parent\": null,\n            \"have_return\": true,\n            \"code_content\": \"class ReplayServer(WebSocketEndpoint):\\n    \\\"\\\"\\\"Main Websocket Server\\n    Extends:\\n        WebSocketEndpoint\\n    \\n    Description:\\n        In this websocket, we will receive the args from user,\\n        and you can use it to run the interaction.\\n        specifically, the args is a dict, \\n        and it must contain a key named \\\"goal\\\" to tell XAgent what do you want to do.\\n\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, websocket: WebSocket, db: Session = Depends(get_db), client_id: str = \\\"\\\"):\\n        super().__init__(websocket.scope, websocket.receive, websocket.send)\\n        self.db = db\\n        self.client_id: str = client_id\\n        self.websocket = websocket\\n        self.date_str = datetime.now().strftime(\\\"%Y-%m-%d\\\")\\n        self.log_dir = \\\"\\\"\\n        self.logger = None\\n        self.scheduler = AsyncIOScheduler()\\n        \\n    async def dispatch(self) -> None:\\n        \\\"\\\"\\\"_summary_\\n\\n        Raises:\\n            exc: _description_\\n        \\\"\\\"\\\"\\n        websocket = WebSocket(self.scope, receive=self.receive, send=self.send)\\n        close_code = 1000\\n        await self.on_connect(websocket)\\n        try:\\n            while True:\\n                message = await websocket.receive()\\n                if message[\\\"type\\\"] == \\\"websocket.receive\\\":\\n                    data = await self.decode(websocket, message)\\n                    await self.on_receive(websocket, data)\\n                elif message[\\\"type\\\"] == \\\"websocket.disconnect\\\":\\n                    close_code = 1000\\n                    break\\n        except Exception as exc:\\n            close_code = 1011\\n            raise exc\\n        finally:\\n            await self.on_disconnect(websocket, close_code)\\n            if self.scheduler.running:\\n                self.scheduler.shutdown()\\n                self.logger.info(\\\"shutdown scheduler\\\")\\n            if self.db:\\n                self.db.close()\\n                self.logger.info(\\\"close db\\\")\\n            \\n\\n    async def on_connect(self, websocket: WebSocket):\\n        \\\"\\\"\\\"Connect to client\\n\\n        Args:\\n            websocket (WebSocket): A websocket object\\n\\n        Raises:\\n            XAgentWebSocketConnectError: If the user is running, it will raise this error.\\n        \\\"\\\"\\\"\\n\\n        self.log_dir = os.path.join(os.path.join(XAgentServerEnv.base_dir, \\\"localstorage\\\",\\n                                    \\\"interact_records\\\"), self.date_str, self.client_id)\\n        if not os.path.exists(self.log_dir):\\n            os.makedirs(self.log_dir)\\n\\n        self.logger = Logger(\\n            log_dir=self.log_dir, log_file=\\\"replay.log\\\", log_name=f\\\"{self.client_id}_REPLAY\\\")\\n        query_string = self.scope.get(\\\"query_string\\\", b\\\"\\\").decode()\\n        parameters = parse_qs(query_string)\\n        user_id = parameters.get(\\\"user_id\\\", [\\\"\\\"])[0]\\n        token = parameters.get(\\\"token\\\", [\\\"\\\"])[0]\\n        self.logger.typewriter_log(\\n            title=f\\\"Receive connection from {self.client_id}: \\\",\\n            title_color=Fore.RED,\\n            content=f\\\"user_id: {user_id}, token: {token}\\\")\\n        await websocket.accept()\\n        try:\\n            await check_user(db=self.db, user_id=user_id, token=token)\\n            # check running, you can edit it by yourself in envs.py to skip this check\\n            if XAgentServerEnv.check_running:\\n                if InteractionCRUD.is_running(db=self.db, user_id=user_id):\\n                    raise XAgentWebSocketConnectError(\\n                        \\\"You have a running interaction, please wait for it to finish!\\\")\\n        except XAgentWebSocketConnectError as exc:\\n            await websocket.send_text(\\n                WebsocketResponseBody(status=\\\"connect\\\",\\n                                    success=False,\\n                                    message=str(exc),\\n                                    data=None).to_text())\\n            await websocket.close(code=1000)\\n            return\\n        await websocket.send_text(\\n            WebsocketResponseBody(\\n                status=\\\"connect\\\",\\n                success=True,\\n                message=\\\"connect success\\\",\\n                data=None).to_text())\\n\\n    async def on_disconnect(self, websocket: WebSocket, close_code):\\n        \\\"\\\"\\\"When disconnect with client, it will run this function\\n        Override this function to do something when disconnect with client\\n        \\n        Args:\\n            websocket (WebSocket): A websocket object\\n            close_code (_type_): The close code, default is 0\\n        \\\"\\\"\\\"\\n        self.logger.typewriter_log(\\n            title=f\\\"Disconnect with client {self.client_id}: \\\",\\n            title_color=Fore.RED)\\n        \\n\\n    async def on_receive(self, websocket: WebSocket, data: Any):\\n        \\\"\\\"\\\"\\n        When receive data from client, it will run this function\\n        \\n        Args:\\n            websocket (WebSocket): A websocket object\\n            data (any): The data from client\\n        \\\"\\\"\\\"\\n        data = json.loads(data)\\n        self.logger.typewriter_log(\\n            title=f\\\"Receive data from {self.client_id}: \\\",\\n            title_color=Fore.RED,\\n            content=json.dumps(data, indent=4, ensure_ascii=False)\\n        )\\n        if data.get(\\\"type\\\", \\\"\\\") == \\\"ping\\\":\\n            # await self.pong()\\n            pass\\n        elif data.get(\\\"type\\\", \\\"\\\") == \\\"replay\\\":\\n            if not self.scheduler.running:\\n                self.scheduler.add_job(self.pong, \\\"interval\\\", seconds=20)\\n                self.scheduler.add_job(self.send_data, \\\"date\\\", next_run_time=datetime.now())\\n                self.scheduler.start()\\n                 \\n    async def pong(self):\\n        \\\"\\\"\\\"\\n        pong to client for keeping alive\\n        \\\"\\\"\\\"\\n        await self.websocket.send_text(json.dumps({\\\"type\\\": \\\"pong\\\"}, ensure_ascii=False, indent=2))\\n\\n    async def send_data(self):\\n        \\\"\\\"\\\"\\n        send data to client\\n        \\\"\\\"\\\"\\n        \\n        rows = InteractionCRUD.search_many_raws(db=self.db, interaction_id=self.client_id)\\n        for row in rows:\\n            self.logger.typewriter_log(\\n                title=f\\\"Send data to {self.client_id}: \\\",\\n                title_color=Fore.RED,\\n                content=f\\\"Send {row.node_id}data to client, length: {len(json.dumps(row.data))}.\\\"\\n            )\\n            root_dir = os.path.join(XAgentServerEnv.base_dir, \\\"localstorage\\\", \\\"interact_records\\\", row.create_time[:10], row.interaction_id)\\n            await self.websocket.send_text(\\n                WebsocketResponseBody(status=row.status,\\n                                    success=True, message=\\\"success\\\",\\n                                    data=handle_data(row=row, root_dir=root_dir),\\n                                    current=row.current,\\n                                    node_id=row.node_id,\\n                                    workspace_file_list=handle_workspace_filelist(row.file_list)).to_text())\\n            # await asyncio.sleep(random.randint(1, 3))\\n        if self.scheduler.running:\\n            self.scheduler.shutdown()\",\n            \"name_column\": 6\n        },\n        \"__init__\": {\n            \"type\": \"FunctionDef\",\n            \"name\": \"__init__\",\n            \"md_content\": \"\",\n            \"code_start_line\": 42,\n            \"code_end_line\": 50,\n            \"parent\": \"ReplayServer\",\n            \"have_return\": false,\n            \"code_content\": \"    def __init__(self, websocket: WebSocket, db: Session = Depends(get_db), client_id: str = \\\"\\\"):\\n        super().__init__(websocket.scope, websocket.receive, websocket.send)\\n        self.db = db\\n        self.client_id: str = client_id\\n        self.websocket = websocket\\n        self.date_str = datetime.now().strftime(\\\"%Y-%m-%d\\\")\\n        self.log_dir = \\\"\\\"\\n        self.logger = None\\n        self.scheduler = AsyncIOScheduler()\\n\",\n            \"name_column\": 8\n        },\n        \"dispatch\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"dispatch\",\n            \"md_content\": \"\",\n            \"code_start_line\": 52,\n            \"code_end_line\": 80,\n            \"parent\": \"ReplayServer\",\n            \"have_return\": false,\n            \"code_content\": \"    async def dispatch(self) -> None:\\n        \\\"\\\"\\\"_summary_\\n\\n        Raises:\\n            exc: _description_\\n        \\\"\\\"\\\"\\n        websocket = WebSocket(self.scope, receive=self.receive, send=self.send)\\n        close_code = 1000\\n        await self.on_connect(websocket)\\n        try:\\n            while True:\\n                message = await websocket.receive()\\n                if message[\\\"type\\\"] == \\\"websocket.receive\\\":\\n                    data = await self.decode(websocket, message)\\n                    await self.on_receive(websocket, data)\\n                elif message[\\\"type\\\"] == \\\"websocket.disconnect\\\":\\n                    close_code = 1000\\n                    break\\n        except Exception as exc:\\n            close_code = 1011\\n            raise exc\\n        finally:\\n            await self.on_disconnect(websocket, close_code)\\n            if self.scheduler.running:\\n                self.scheduler.shutdown()\\n                self.logger.info(\\\"shutdown scheduler\\\")\\n            if self.db:\\n                self.db.close()\\n                self.logger.info(\\\"close db\\\")\\n\",\n            \"name_column\": 14\n        },\n        \"on_connect\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"on_connect\",\n            \"md_content\": \"\",\n            \"code_start_line\": 83,\n            \"code_end_line\": 129,\n            \"parent\": \"ReplayServer\",\n            \"have_return\": true,\n            \"code_content\": \"    async def on_connect(self, websocket: WebSocket):\\n        \\\"\\\"\\\"Connect to client\\n\\n        Args:\\n            websocket (WebSocket): A websocket object\\n\\n        Raises:\\n            XAgentWebSocketConnectError: If the user is running, it will raise this error.\\n        \\\"\\\"\\\"\\n\\n        self.log_dir = os.path.join(os.path.join(XAgentServerEnv.base_dir, \\\"localstorage\\\",\\n                                    \\\"interact_records\\\"), self.date_str, self.client_id)\\n        if not os.path.exists(self.log_dir):\\n            os.makedirs(self.log_dir)\\n\\n        self.logger = Logger(\\n            log_dir=self.log_dir, log_file=\\\"replay.log\\\", log_name=f\\\"{self.client_id}_REPLAY\\\")\\n        query_string = self.scope.get(\\\"query_string\\\", b\\\"\\\").decode()\\n        parameters = parse_qs(query_string)\\n        user_id = parameters.get(\\\"user_id\\\", [\\\"\\\"])[0]\\n        token = parameters.get(\\\"token\\\", [\\\"\\\"])[0]\\n        self.logger.typewriter_log(\\n            title=f\\\"Receive connection from {self.client_id}: \\\",\\n            title_color=Fore.RED,\\n            content=f\\\"user_id: {user_id}, token: {token}\\\")\\n        await websocket.accept()\\n        try:\\n            await check_user(db=self.db, user_id=user_id, token=token)\\n            # check running, you can edit it by yourself in envs.py to skip this check\\n            if XAgentServerEnv.check_running:\\n                if InteractionCRUD.is_running(db=self.db, user_id=user_id):\\n                    raise XAgentWebSocketConnectError(\\n                        \\\"You have a running interaction, please wait for it to finish!\\\")\\n        except XAgentWebSocketConnectError as exc:\\n            await websocket.send_text(\\n                WebsocketResponseBody(status=\\\"connect\\\",\\n                                    success=False,\\n                                    message=str(exc),\\n                                    data=None).to_text())\\n            await websocket.close(code=1000)\\n            return\\n        await websocket.send_text(\\n            WebsocketResponseBody(\\n                status=\\\"connect\\\",\\n                success=True,\\n                message=\\\"connect success\\\",\\n                data=None).to_text())\\n\",\n            \"name_column\": 14\n        },\n        \"on_disconnect\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"on_disconnect\",\n            \"md_content\": \"\",\n            \"code_start_line\": 131,\n            \"code_end_line\": 141,\n            \"parent\": \"ReplayServer\",\n            \"have_return\": false,\n            \"code_content\": \"    async def on_disconnect(self, websocket: WebSocket, close_code):\\n        \\\"\\\"\\\"When disconnect with client, it will run this function\\n        Override this function to do something when disconnect with client\\n        \\n        Args:\\n            websocket (WebSocket): A websocket object\\n            close_code (_type_): The close code, default is 0\\n        \\\"\\\"\\\"\\n        self.logger.typewriter_log(\\n            title=f\\\"Disconnect with client {self.client_id}: \\\",\\n            title_color=Fore.RED)\\n\",\n            \"name_column\": 14\n        },\n        \"on_receive\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"on_receive\",\n            \"md_content\": \"\",\n            \"code_start_line\": 144,\n            \"code_end_line\": 165,\n            \"parent\": \"ReplayServer\",\n            \"have_return\": false,\n            \"code_content\": \"    async def on_receive(self, websocket: WebSocket, data: Any):\\n        \\\"\\\"\\\"\\n        When receive data from client, it will run this function\\n        \\n        Args:\\n            websocket (WebSocket): A websocket object\\n            data (any): The data from client\\n        \\\"\\\"\\\"\\n        data = json.loads(data)\\n        self.logger.typewriter_log(\\n            title=f\\\"Receive data from {self.client_id}: \\\",\\n            title_color=Fore.RED,\\n            content=json.dumps(data, indent=4, ensure_ascii=False)\\n        )\\n        if data.get(\\\"type\\\", \\\"\\\") == \\\"ping\\\":\\n            # await self.pong()\\n            pass\\n        elif data.get(\\\"type\\\", \\\"\\\") == \\\"replay\\\":\\n            if not self.scheduler.running:\\n                self.scheduler.add_job(self.pong, \\\"interval\\\", seconds=20)\\n                self.scheduler.add_job(self.send_data, \\\"date\\\", next_run_time=datetime.now())\\n                self.scheduler.start()\\n\",\n            \"name_column\": 14\n        },\n        \"pong\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"pong\",\n            \"md_content\": \"\",\n            \"code_start_line\": 167,\n            \"code_end_line\": 171,\n            \"parent\": \"ReplayServer\",\n            \"have_return\": false,\n            \"code_content\": \"    async def pong(self):\\n        \\\"\\\"\\\"\\n        pong to client for keeping alive\\n        \\\"\\\"\\\"\\n        await self.websocket.send_text(json.dumps({\\\"type\\\": \\\"pong\\\"}, ensure_ascii=False, indent=2))\\n\",\n            \"name_column\": 14\n        },\n        \"send_data\": {\n            \"type\": \"AsyncFunctionDef\",\n            \"name\": \"send_data\",\n            \"md_content\": \"\",\n            \"code_start_line\": 173,\n            \"code_end_line\": 195,\n            \"parent\": \"ReplayServer\",\n            \"have_return\": false,\n            \"code_content\": \"    async def send_data(self):\\n        \\\"\\\"\\\"\\n        send data to client\\n        \\\"\\\"\\\"\\n        \\n        rows = InteractionCRUD.search_many_raws(db=self.db, interaction_id=self.client_id)\\n        for row in rows:\\n            self.logger.typewriter_log(\\n                title=f\\\"Send data to {self.client_id}: \\\",\\n                title_color=Fore.RED,\\n                content=f\\\"Send {row.node_id}data to client, length: {len(json.dumps(row.data))}.\\\"\\n            )\\n            root_dir = os.path.join(XAgentServerEnv.base_dir, \\\"localstorage\\\", \\\"interact_records\\\", row.create_time[:10], row.interaction_id)\\n            await self.websocket.send_text(\\n                WebsocketResponseBody(status=row.status,\\n                                    success=True, message=\\\"success\\\",\\n                                    data=handle_data(row=row, root_dir=root_dir),\\n                                    current=row.current,\\n                                    node_id=row.node_id,\\n                                    workspace_file_list=handle_workspace_filelist(row.file_list)).to_text("
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 2.0322265625,
          "content": "# Changelog\n\nAll notable changes to this project will be documented in this file.\n\nThe format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/), and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).\n\n## [1.0.0] - 2023-11-21\n\n### Added\n- Offical release of XAgent Container Images on DockerHub, now you can just download and play XAgent, see our dockerhub [page](https://hub.docker.com/u/xagentteam) for more information.\n- Localhost models [XAgentLlama-7B-preview](https://huggingface.co/XAgentTeam/XAgentLlama-7B-preview), [XAgentLlama-34B-preview](https://huggingface.co/XAgentTeam/XAgentLLaMa-34B-preview) developped for XAgent is now available on HuggingFace, click [here](https://huggingface.co/collections/XAgentTeam/xagentllm-655ae4091c419bb072940e74) to learn more.\n- **XAgentGen** is released to enhance the usability and stability of Localhost models for XAgent. Check out the [XAgentGen](XAgentGen/README.md) for more details.\n- **WebUI** is updated! Now you can browse files in workspace! **History replay** is also available now!\n- Mysql integration for data management, including runtime interactive data and running records.\n- Redis integration for managing the state of components during interaction processes.\n- Docker and initialization for Mysql and Redis included within the project setup.\n- New exception handling processes, with custom exception classes for different runtime errors.\n- Session sharing feature, allowing users to share their sessions with the community.\n\n### Changed\n\n- Removed some global variables, now using `XAgent.core.XAgentCoreComponents` for better modularity and encapsulation.\n- Overhauled the project structure of XAgentServer for improved organization and maintainability.\n\n### Removed\n\n- XAgentIO.\n- Local file storage mode and its support mechanisms.\n\n### Fixed\n\n- Fix various bugs in `XAgentServer` as reported in project issues.\n\n## [0.1.0] - 2023-10-16\n\n- Initial setup and integration of the `Toolserver`, `XAgent`, `XAgentIO`, `XAgentServer`, and `XAgentWeb` components.\n"
        },
        {
          "name": "CODE_OF_CONDUCT.md",
          "type": "blob",
          "size": 5.126953125,
          "content": "# Contributor Covenant Code of Conduct\n\n## Our Pledge\n\nWe as members, contributors, and leaders pledge to make participation in our\ncommunity a harassment-free experience for everyone, regardless of age, body\nsize, visible or invisible disability, ethnicity, sex characteristics, gender\nidentity and expression, level of experience, education, socio-economic status,\nnationality, personal appearance, race, religion, or sexual identity\nand orientation.\n\nWe pledge to act and interact in ways that contribute to an open, welcoming,\ndiverse, inclusive, and healthy community.\n\n## Our Standards\n\nExamples of behavior that contributes to a positive environment for our\ncommunity include:\n\n* Demonstrating empathy and kindness toward other people\n* Being respectful of differing opinions, viewpoints, and experiences\n* Giving and gracefully accepting constructive feedback\n* Accepting responsibility and apologizing to those affected by our mistakes,\n  and learning from the experience\n* Focusing on what is best not just for us as individuals, but for the\n  overall community\n\nExamples of unacceptable behavior include:\n\n* The use of sexualized language or imagery, and sexual attention or\n  advances of any kind\n* Trolling, insulting or derogatory comments, and personal or political attacks\n* Public or private harassment\n* Publishing others' private information, such as a physical or email\n  address, without their explicit permission\n* Other conduct which could reasonably be considered inappropriate in a\n  professional setting\n\n## Enforcement Responsibilities\n\nCommunity leaders are responsible for clarifying and enforcing our standards of\nacceptable behavior and will take appropriate and fair corrective action in\nresponse to any behavior that they deem inappropriate, threatening, offensive,\nor harmful.\n\nCommunity leaders have the right and responsibility to remove, edit, or reject\ncomments, commits, code, wiki edits, issues, and other contributions that are\nnot aligned to this Code of Conduct, and will communicate reasons for moderation\ndecisions when appropriate.\n\n## Scope\n\nThis Code of Conduct applies within all community spaces, and also applies when\nan individual is officially representing the community in public spaces.\nExamples of representing our community include using an official e-mail address,\nposting via an official social media account, or acting as an appointed\nrepresentative at an online or offline event.\n\n## Enforcement\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be\nreported to the community leaders responsible for enforcement at\nthe following e-mail address xagentteam@gmail.com.\nAll complaints will be reviewed and investigated promptly and fairly.\n\nAll community leaders are obligated to respect the privacy and security of the\nreporter of any incident.\n\n## Enforcement Guidelines\n\nCommunity leaders will follow these Community Impact Guidelines in determining\nthe consequences for any action they deem in violation of this Code of Conduct:\n\n### 1. Correction\n\n**Community Impact**: Use of inappropriate language or other behavior deemed\nunprofessional or unwelcome in the community.\n\n**Consequence**: A private, written warning from community leaders, providing\nclarity around the nature of the violation and an explanation of why the\nbehavior was inappropriate. A public apology may be requested.\n\n### 2. Warning\n\n**Community Impact**: A violation through a single incident or series\nof actions.\n\n**Consequence**: A warning with consequences for continued behavior. No\ninteraction with the people involved, including unsolicited interaction with\nthose enforcing the Code of Conduct, for a specified period of time. This\nincludes avoiding interactions in community spaces as well as external channels\nlike social media. Violating these terms may lead to a temporary or\npermanent ban.\n\n### 3. Temporary Ban\n\n**Community Impact**: A serious violation of community standards, including\nsustained inappropriate behavior.\n\n**Consequence**: A temporary ban from any sort of interaction or public\ncommunication with the community for a specified period of time. No public or\nprivate interaction with the people involved, including unsolicited interaction\nwith those enforcing the Code of Conduct, is allowed during this period.\nViolating these terms may lead to a permanent ban.\n\n### 4. Permanent Ban\n\n**Community Impact**: Demonstrating a pattern of violation of community\nstandards, including sustained inappropriate behavior,  harassment of an\nindividual, or aggression toward or disparagement of classes of individuals.\n\n**Consequence**: A permanent ban from any sort of public interaction within\nthe community.\n\n## Attribution\n\nThis Code of Conduct is adapted from the [Contributor Covenant][homepage],\nversion 2.0, available at\nhttps://www.contributor-covenant.org/version/2/0/code_of_conduct.html.\n\nCommunity Impact Guidelines were inspired by [Mozilla's code of conduct\nenforcement ladder](https://github.com/mozilla/diversity).\n\n[homepage]: https://www.contributor-covenant.org\n\nFor answers to common questions about this code of conduct, see the FAQ at\nhttps://www.contributor-covenant.org/faq. Translations are available at\nhttps://www.contributor-covenant.org/translations."
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 2.0927734375,
          "content": "# Contributing to XAgent 🚀\n\nWelcome to the XAgent project, where your contributions matter greatly. We're delighted that you're interested in joining our mission to enhance this project.\n\n## How You Can Contribute 🌟\n\nYour contributions can take many forms:\n\n- **Reporting Bugs 🐞**: Help us identify and address issues (you can go ahead with issues!).\n- **Suggesting Enhancements 🚀**: Share your ideas for improving XAgent (by making issues.).\n- **Adding New Features 💡**: Contribute your expertise by introducing exciting new features.\n- **Improving Documentation 📚**: Enhance the clarity and completeness of our documentation.\n- **Providing Support 👋**: Assist other users with their issues.\n\n## Getting Started 🚀\n\nTo get started with your contributions, follow these steps:\n\n1. **Fork the [XAgent repository](https://github.com/OpenBMB/XAgent)** by clicking the \"Fork\" button in the top-right corner of the repository page.\n\n2. **Clone your forked repository** to your local machine:\n\n   ```shell\n   git clone https://github.com/YourUsername/XAgent.git\n   ```\n\n3. Create a **new branch** for your changes:\n\n   ```shell\n   git checkout -b feature/your-feature\n   ```\n\n## Making Changes 🌈\n\nWith your environment set up, you're ready to make your contributions:\n\n1. Make your changes and **commit them to your branch**:\n\n   ```shell\n   git commit -m \"Your descriptive commit message\"\n   ```\n\n2. **Push your changes** to your forked repository:\n\n   ```shell\n   git push origin feature/your-feature\n   ```\n\n3. Create a **pull request (PR)** by navigating to the [XAgent repository](https://github.com/OpenBMB/XAgent) and clicking the \"New Pull Request\" button.\n\n4. Provide a **descriptive title and details** in the PR, and make sure to **link your PR to any relevant issues**.\n\n5. **Submit the pull request**, and our maintainers will review your changes.\n\n## Code of Conduct 📜\n\nPlease adhere to our [Code of Conduct](LICENSE) while contributing to this project.\n\nWe sincerely appreciate your contributions, and we look forward to working together to make XAgent even better for everyone!\n\nHappy Contributing! 🌟\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 11.0712890625,
          "content": "                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"[]\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright 2023 OpenBMB\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "Markdown_Docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 11.8427734375,
          "content": "<div align= \"center\">\n    <h1> <img src=\"assets/readme/xagent_logo.png\" height=40 align=\"texttop\">XAgent</h1>\n</div>\n\n<div align=\"center\">\n\n[![Twitter](https://img.shields.io/twitter/follow/XAgent?style=social)](https://twitter.com/XAgentTeam) [![Discord](https://img.shields.io/badge/XAgent-Discord-purple?style=flat)](https://discord.gg/zncs5aQkWZ) [![License: Apache 2.0](https://img.shields.io/badge/License-Apache_2.0-green.svg)](https://opensource.org/license/apache-2-0/) ![Welcome](https://img.shields.io/badge/contributions-welcome-brightgreen.svg?style=flat)\n\n</div>\n\n<p align=\"center\">\n    <a>English</a> •\n    <a href=\"README_ZH.md\">中文</a> •\n    <a href=\"README_JA.md\">日本語</a>\n</p>\n\n<p align=\"center\">\n  <a href=\"#quickstart\">Tutorial</a> •\n  <a href=\"https://www.youtube.com/watch?v=QGkpd-tsFPA\">Demo</a> •\n  <a href=\"https://blog.x-agent.net/blog/xagent/\">Blog</a> •\n  <a href=\"https://xagent-doc.readthedocs.io/en/latest/\">Documentation</a> •\n  <a href=\"#Citation\">Citation</a>\n</p>\n\n\n## 📖 Introduction\n\nXAgent is an open-source experimental Large Language Model (LLM) driven autonomous agent that can automatically solve various tasks. \nIt is designed to be a general-purpose agent that can be applied to a wide range of tasks. XAgent is still in its early stages, and we are working hard to improve it.\n\n🏆 Our goal is to create a super-intelligent agent that can solve any given task!\n\nWe welcome diverse forms of collaborations, including full-time and part-time roles and more. If you are interested in the frontiers of agents and want to join us in realizing true autonomous agents, please contact us at xagentteam@gmail.com.\n\n<div align=\"center\">\n    <img src=\"assets/readme/overview.png\" alt=\"Overview of Xagent\" width=\"700\"/>\n    <br/>\n    <figcaption>Overview of XAgent.</figcaption>\n</div>\n\n### <img src=\"assets/readme/xagent_logo.png\" height=30 align=\"texttop\"> XAgent\n\nXAgent is designed with the following features:\n- **Autonomy**: XAgent can automatically solve various tasks without human participation.\n- **Safety**: XAgent is designed to run safely. All actions are constrained inside a docker container. Run it anyway!\n- **Extensibility**: XAgent is designed to be extensible. You can easily add new tools to enhance agent's abilities and even new agents！\n- **GUI**: XAgent provides a friendly GUI for users to interact with the agent. You can also use the command line interface to interact with the agent.\n- **Cooperation with Human**: XAgent can collaborate with you to tackle tasks. It not only has the capability to follow your guidance in solving complex tasks on the go but it can also seek your assistance when it encounters challenges.\n\nXAgent is composed of three parts:\n- **🤖 Dispatcher** is responsible for dynamically instantiating and dispatching tasks to different agents. It allows us to add new agents and improve the agents' abilities.\n- **🧐 Planner** is responsible for generating and rectifying plans for tasks. It divides tasks into subtasks and generates milestones for them, allowing agents to solve tasks step by step.\n- **🦾 Actor** is responsible for conducting actions to achieve goals and finish subtasks. The actor utilizes various tools to solve subtasks, and it can also collaborate with humans to solve tasks.\n\n<div align=\"center\">\n    <img src=\"assets/readme/workflow.png\" alt=\"Workflow of Xagent\" width=\"700\"/>\n    <br/>\n    <figcaption>Workflow of XAgent.</figcaption>\n</div>\n\n### 🧰 ToolServer\n\nToolServer is the server that provides XAgent with powerful and safe tools to solve tasks. It is a docker container that provides a safe environment for XAgent to run.\nCurrently, ToolServer provides the following tools:\n- **📝 File Editor** provides a text editing tool to write, read, and modify files.\n- **📘 Python Notebook** provides an interactive Python notebook that can run Python code to validate ideas, draw figures, etc.\n- **🌏 Web Browser** provides a web browser to search and visit webpages.\n- **🖥️ Shell** provides a bash shell tool that can execute any shell commands, even install programs and host services.\n- **🧩 Rapid API** provides a tool to retrieve APIs from Rapid API and call them, which offers a wide range of APIs for XAgent to use. See [ToolBench](https://github.com/OpenBMB/ToolBench) to get more information about the Rapid API collections.\nYou can also easily add new tools to ToolServer to enhance XAgent's abilities.\n\n<div><a id=\"Quickstart\"></a></div>\n\n## ✨ Quickstart\n\n### 🛠️ Build and Setup ToolServer\n\nToolServer is where XAgent's action takes place. It is a docker container that provides a safe environment for XAgent to run.\nSo you should install `docker` and `docker-compose` first. \nThen, you need to build the ToolServer image. Construct referring to any one of the following methods:\n\n#### Pull the image from docker hub by running the following command:\n\n```bash\ndocker compose up\n```\n\n#### Build an image from local sources by running the following command:\n\n```bash\ndocker compose build\ndocker compose up\n```\nThis will build the image for the ToolServer and start the ToolServer's container. \nIf you want to run the container in the background, please use `docker compose up -d`.\nRefer [here](ToolServer/README.md) for detailed information about our ToolServer.\n\nIf the ToolServer is updated, you have to repull/rebuild the images:\n```bash\ndocker compose pull\n```\nOr\n```bash\ndocker compose build\n```\n\n### 🎮 Setup and Run XAgent\n\nAfter setting up ToolServer, you can start to run XAgent.\n- Install requirements (Require Python >= 3.10)\n```bash\npip install -r requirements.txt\n```\n\n- Configure XAgent\n\n1. You should configure XAgent in `assets/config.yml` before running it. \n2. At least one OpenAI key is provided in `assets/config.yml`, which is used to access OpenAI API.\nWe highly recommend using `gpt-4-32k` to run XAgent; `gpt-4` is also OK for most simple tasks.\nIn any case, at least one `gpt-3.5-turbo-16k` API key should be provided as a backup model.\nWe do not test or recommend using `gpt-3.5-turbo` to run XAgent due to minimal context length; you should not try to run XAgent on that.\n3. If you want to change the config_file path for `XAgentServer`, you should modify the `CONFIG_FILE` value in `.env` file and restart the docker container.\n\n\n- Run XAgent\n```bash\npython run.py --task \"put your task here\" --config-file \"assets/config.yml\"\n```\n1. You can use the argument `--upload-files` to select the initial files you want to submit to XAgent.\n\n2. The local workspace for your XAgent is in `local_workspace`, where you can find all the files generated by XAgent throughout the running process. \n\n3. After execution, the entire `workspace` in `ToolServerNode` will be copied to `running_records` for your convenience.\n\n4. Besides, in `running_records`, you can find all the intermediate steps information, e.g., task statuses, LLM's input-output pairs, used tools, etc.\n\n5. You can load from a record to reproduce a former run, just by setting `record_dir` in config(default to `Null`). The record is a system-level recording tied to the code version of XAgent. All running-config、query、code execution statuses (including errors)、server behavior will be documented.\n\n6. We have removed all sensitive information (including API keys) from the record so you can safely share it with others. In the near future, we will introduce more granular sharing options highlighting the contributions of humans during execution.\n\n   \n\n- Run XAgent with GUI\nThe container `XAgent-Server` is started with nginx and a web server listening on port `5173`.\nYou could visit `http://localhost:5173` to interact with XAgent by using web UI.\nThe default username and password are `guest` and `xagent`, respectively.\nRefer [here](XAgentServer/README.md) for the detailed information about our GUI Demo.\n\n<div><a id=\"Demo\"></a></div>\n\n## 🎬 Demo\n\nHere, we also show some cases of solving tasks by XAgent:\nYou can check our live demo on [XAgent Official Website](https://www.x-agent.net/). We also provide a video demo and showcases of using XAgent here:\n![Demo](assets/readme/demo.gif)\n\n### Case 1. Data Analysis: Demonstrating the Effectiveness of Dual-Loop Mechanism\n\nWe start with a case of aiding users in intricate data analysis. Here, our user submitted an `iris.zip` file to XAgent, seeking assistance in data analysis. XAgent swiftly broke down the task into four sub-tasks: (1) data inspection and comprehension, (2) verification of the system's Python environment for relevant data analysis libraries, (3) crafting data analysis code for data processing and analysis, and (4) compiling an analytical report based on the Python code's execution results.\nHere is a figure drawn by XAgent.\n![Data Statics by XAgent](assets/readme/statistics.png)\n\n\n### Case 2. Recommendation: A New Paradigm of Human-Agent Interaction\n\nEmpowered with the unique capability to actively seek human assistance and collaborate in problem-solving, XAgent continues to redefine the boundaries of human-agent cooperation. As depicted in the screenshot below, a user sought XAgent's aid in recommending some great restaurants for a friendly gathering yet failed to provide specific details. Recognizing the insufficiency of the provided information, XAgent employed the AskForHumanHelp tool, prompting human intervention to elicit the user's preferred location, budget constraints, culinary preferences, and dietary restrictions. Armed with this valuable feedback, XAgent seamlessly generated tailored restaurant recommendations, ensuring a personalized and satisfying experience for the user and their friends.\n\n![Illustration of Ask for Human Help of XAgent](assets/readme/ask_for_human_help.png)\n\n### Case 3. Training Model: A Sophisticated Tool User\n\nXAgent not only tackles mundane tasks but also serves as an invaluable aid in complex tasks such as model training. Here, we show a scenario where a user desires to analyze movie reviews and evaluate the public sentiment surrounding particular films. In response, XAgent promptly initiates the process by downloading the IMDB dataset to train a cutting-edge BERT model (see screenshot below), harnessing the power of deep learning. Armed with this trained BERT model, XAgent seamlessly navigates the intricate nuances of movie reviews, offering insightful predictions regarding the public's perception of various films.\n\n![bert_1](assets/readme/bert_1.png)\n![bert_2](assets/readme/bert_2.png)\n![bert_3](assets/readme/bert_3.png)\n\n### 📊 Evaluation\n\nWe conduct human preference evaluation to evaluate XAgent's performance. We prepare [over 50 real-world complex tasks](assets/tasks.yml) for assessment, which can be categorized into 5 classes: Search and Report, Coding and Developing, Data Analysis, Math, and Life Assistant.\nWe compare the results of XAgent with [AutoGPT](https://github.com/Significant-Gravitas/AutoGPT), which shows a total win of XAgent over AutoGPT. \nAll running records can refer to [here](https://drive.google.com/drive/folders/1I-j6FZDyMRrLTpZ64jeN89emA77AbNfc?usp=drive_link).\n\n![HumanPrefer](assets/readme/agent_comparison.png)\n\nWe report a significant improvement of XAgent over AutoGPT in terms of human preference.\n\nWe also evaluate XAgent on the following benchmarks:\n![Benchmarks](assets/readme/eval_on_dataset.png)\n\n\n<div><a id=\"Blog\"></a></div>\n\n## 🖌️ Blog\n\nOur blog is available at [here](https://blog.x-agent.net/)!\n\n<div><a id=\"Citation\"></a></div>\n\n## 🌟 Our Contributors\n\nA heartfelt thank you to all our contributors. Your efforts make this project grow and thrive. Every contribution, big or small, is invaluable.\n\n![Contributors](https://contrib.rocks/image?repo=OpenBMB/XAgent)\n\n## 🌟 Star History\n\n[![Star History Chart](https://api.star-history.com/svg?repos=openbmb/xagent&type=Date)](https://star-history.com/##openbmb/xagent&Date)\n\n## Citation\n\nIf you find our repo useful, please kindly consider citing:\n```angular2\n@misc{xagent2023,\n      title={XAgent: An Autonomous Agent for Complex Task Solving}, \n      author={XAgent Team},\n      year={2023},\n}\n```\n"
        },
        {
          "name": "README_JA.md",
          "type": "blob",
          "size": 15.2421875,
          "content": "<div align= \"center\">\n    <h1> <img src=\"assets/readme/xagent_logo.png\" height=40 align=\"texttop\">XAgent</h1>\n</div>\n\n<div align=\"center\">\n\n[![Twitter](https://img.shields.io/twitter/follow/XAgent?style=social)](https://twitter.com/XAgentTeam) [![Discord](https://img.shields.io/badge/XAgent-Discord-purple?style=flat)](https://discord.gg/zncs5aQkWZ) [![License: Apache 2.0](https://img.shields.io/badge/License-Apache_2.0-green.svg)](https://opensource.org/license/apache-2-0/) ![Welcome](https://img.shields.io/badge/contributions-welcome-brightgreen.svg?style=flat)\n\n</div>\n\n<p align=\"center\">\n    <a href=\"README.md\">English</a> •\n    <a href=\"README_ZH.md\">中文</a> •\n    <a>日本語</a>\n</p>\n\n<p align=\"center\">\n  <a href=\"#Quickstart\">チュートリアル</a> •\n  <a href=\"https://www.youtube.com/watch?v=QGkpd-tsFPA\">デモ</a> •\n  <a href=\"https://blog.x-agent.net/blog/xagent/\">ブログ</a> •\n  <a href=\"https://xagent-doc.readthedocs.io/en/latest/\">ドキュメント</a> •\n  <a href=\"#Citation\">引用</a>\n</p>\n\n## 📖 はじめに\n\nXAgent は、オープンソースの実験的な大規模言語モデル（LLM）駆動自律エージェントであり、様々なタスクを自動的に解決することができる。\nこれは幅広いタスクに適用できる汎用エージェントとして設計されています。XAgent はまだ初期段階にあり、私たちはその改良に励んでいます。\n\n🏆 私たちの目標は、与えられたタスクを解決できる超知的エージェントを作ることです!\n\nフルタイムでもパートタイムなど、多様な形でのコラボレーションを歓迎します。エージェントのフロンティアに興味があり、私たちと一緒に真の自律型エージェントを実現したい方は、xagentteam@gmail.com までご連絡ください。\n\n<div align=\"center\">\n    <img src=\"assets/readme/overview.png\" alt=\"Overview of Xagent\" width=\"700\"/>\n    <br/>\n    <figcaption>XAgent の概要。</figcaption>\n</div>\n\n### <img src=\"assets/readme/xagent_logo.png\" height=30 align=\"texttop\"> XAgent\n\nXAgentは以下の機能を備えています:\n- **自律性**: XAgentは人間が関与することなく、さまざまなタスクを自動的に解決することができます。\n- **安全性**: XAgent は安全に動作するように設計されています。すべてのアクションは docker コンテナ内で制約されています。とにかく実行しましょう!\n- **拡張性**: XAgent は拡張できるように設計されています。エージェントの能力を向上させる新しいツールや、新しいエージェントを簡単に追加することができます！\n- **GUI**: XAgent は、ユーザがエージェントと対話するためのフレンドリーな GUI を提供します。また、コマンドラインインタフェースを使用してエージェントと対話することもできます。\n- **人間との協調**: XAgent は、あなたと協力してタスクに取り組むことができます。XAgentは、外出先で複雑なタスクを解決する際に、あなたのガイダンスに従うことができるだけでなく、困難に遭遇したときにあなたの支援を求めることもできます。\n\nXAgent は次の 3 つの部分で構成されています:\n- **🤖 Dispatcher** は、タスクを動的にインスタンス化し、さまざまなエージェントにディスパッチします。これにより、新しいエージェントを追加したり、エージェントの能力を向上させたりすることができます。\n- **🧐 Planner** は、タスクの計画を作成し、修正する役割を担う。タスクをサブタスクに分割し、マイルストーンを生成することで、エージェントは段階的にタスクを解決することができます。\n- **🦾 Actor** は、目標を達成し、サブタスクを完了させるためのアクションを実行する責任を負います。アクターはサブタスクを解決するためにさまざまなツールを利用し、人間と協力してタスクを解決することもできます。\n\n<div align=\"center\">\n    <img src=\"assets/readme/workflow.png\" alt=\"XAgentのワークフロー\" width=\"700\"/>\n    <br/>\n    <figcaption>XAgentのワークフロー図。</figcaption>\n</div>\n\n### 🧰 ToolServer\n\nToolServer は、タスクを解決するための強力で安全なツールを XAgent に提供するサーバです。これは、XAgent が実行するための安全な環境を提供する docker コンテナです。\n現在、ToolServer は以下のツールを提供しています:\n- **📝 ファイルエディタ** は、ファイルの書き込み、読み込み、変更を行うためのテキスト編集ツールを提供します。\n- **📘 Python ノートブック** は、Python コードを実行してアイデアを検証したり、図を描いたりできるインタラクティブな Python ノートブックです。\n- **🌏 Web ブラウザ** は、ウェブページを検索したり閲覧したりするための web ブラウザです。\n- **🖥️ シェル** は bash シェルツールを提供し、あらゆるシェルコマンドを実行できます。\n- **🧩 Rapid API** は、Rapid API から API を取得して呼び出すためのツールを提供しており、XAgent が使用できる幅広い API を提供しています。Rapid API コレクションの詳細については、[ToolBench](https://github.com/OpenBMB/ToolBench) を参照してください。\nさらに、ToolServer に新しいツールを簡単に追加して、XAgent の能力を強化することもできます。\n\n<div><a id=\"クイックスタート\"></a></div>\n\n## ✨ クイックスタート\n\n### 🛠️ ToolServer の構築とセットアップ\n\nToolServer は、XAgent の動作が行われる場所です。これは、XAgent が実行するための安全な環境を提供する Docker コンテナになります。\nそのため、まず `docker` と `docker-compose` をインストールする必要があります。\n次に、ToolServerイメージを構築する必要があります。 ToolServer`ディレクトリでは、私たちのサービスのイメージを構築する2つの方法があります：\n以下のコマンドを実行することで、docker hubからイメージを取得し、dockerネットワークを構築することができます：\n```bash\ndocker compose up\n```\nあるいは、以下のコマンドを実行してローカルソースからイメージを構築することもできます：\nバッシュ\n```bash\ndocker compose build\ndocker compose up\n```\nこれによりツールサーバーのイメージが構築され、ツールサーバーのコンテナが起動します。\nコンテナをバックグラウンドで実行したい場合は、`docker compose up -d` を使用してください。\nToolServer の詳細については、[こちら](ToolServer/README.md)を参照してください。\n\nToolServer が更新された場合、イメージを再構築する必要があります:\n```bash\ndocker compose pull\n```\nOr\n```bash\ndocker compose build\n```\n\n### 🎮 XAgent のセットアップと実行\n\nToolServer のセットアップが完了したら、XAgent の実行を開始します。\n- インストール要件 (Python >= 3.10 が必要)\n```bash\npip install -r requirements.txt\n```\n\n- XAgent の設定\n\n1. XAgent を実行する前に、`assets/config.yml` で XAgent を設定する必要があります。\n2. `assets/config.yml` には、OpenAI API にアクセスするための OpenAI キーが最低 1 つ用意されている。\nXAgent を実行するには、`gpt-4-32k` を使用することを強く推奨しています。\nいずれの場合も、バックアップモデルとして少なくとも 1 つの `gpt-3.5-turbo-16k` API キーを提供する必要があります。\n`gpt-3.5-turbo` を使用して XAgent を実行することは、コンテキストの長さが最小になるため、テストも推奨もしません\n; その上で XAgent を実行しようとしてはいけません。\n3. `XAgentServer` の設定ファイルのパスを変更したい場合は、`.env` ファイルの `CONFIG_FILE` の値を変更してから docker コンテナを再起動します。\n\n\n- XAgent の実行\n```bash\npython run.py --task \"put your task here\" --config-file \"assets/config.yml\"\n```\n1. 引数 `--upload-files` を使って、XAgent に送信したい初期ファイルを選択することができます。\n\n2. XAgent のローカルワークスペースは `local_workspace` にあり、実行中のプロセスを通じて XAgent が生成するすべてのファイルを見つけることができます。\n\n3. 実行後、`ToolServerNode` 内の `workspace` 全体が `running_records` にコピーされます。\n\n4. さらに、`running_records` には、タスクのステータス、LLM の入出力ペア、使用したツールなど、すべての中間ステップの情報を見ることができます。\n\n5. config で `record_dir` を設定（デフォルトは `Null`）するだけで、レコードからロードして以前の実行を再現することができる。レコードは XAgent のコードバージョンに関連付けられたシステムレベルの記録です。すべての実行設定、クエリ、コードの実行状態（エラーを含む）、サーバの動作が記録されます。\n\n6. 私たちは記録からすべての機密情報（API キーを含む）を削除しましたので、他の人と安全に共有することができます。近い将来、実行中の人間の貢献を強調する、より詳細な共有オプションを導入する予定です。\n\n\n\n- GUI で XAgent を実行する\nコンテナ XAgent-Server は、nginxとポート 5173 でリッスンしているウェブサーバーと共に起動しています。\nWeb UI を使用して XAgent とやり取りするには、http://localhost:5173 を訪れることができます。\nデフォルトのユーザー名とパスワードはそれぞれ guest と xagent です。\nGUI デモの詳細については、[こちら](XAgentServer/README.md) を参照してください。\n\n<div><a id=\"デモ\"></a></div>\n\n## 🎬 デモ\n\nここでは、XAgent によるタスクの解決事例も紹介する:\n[XAgent Official Website](https://www.x-agent.net/) では、ライブデモをご覧いただけます。また、XAgent を使用したビデオデモやショーケースもこちらでご覧いただけます:\n![Demo](assets/readme/demo.gif)\n\n### ケース 1. データ分析: デュアルループメカニズムの有効性の実証\n\nまず、複雑なデータ分析においてユーザーを支援するケースから始める。ここでは、ユーザがデータ解析の支援を求めて `iris.zip` ファイルを XAgent に送信した。(1)データの検査と理解、(2)システムの Python 環境に関連するデータ分析ライブラリがあるかどうかの検証、(3)データ処理と分析のためのデータ分析コードの作成、(4)Python コードの実行結果に基づく分析レポートのコンパイル。\n以下は、XAgent が作成した図である。\n![Data Statics by XAgent](assets/readme/statistics.png)\n\n\n### ケース 2. レコメンデーション: 人間とエージェントのインタラクションの新しいパラダイム\n\n人間の支援を積極的に求め、問題解決に協力するユニークな機能を備えた XAgent は、人間とエージェントの協力の境界を再定義し続けています。下のスクリーンショットに示されているように、あるユーザが XAgent に、親睦を深める集まりに最適なレストランを紹介するよう助けを求めたが、具体的な情報を提供することができなかった。提供された情報が不十分であることを認識した XAgent は、AskForHumanHelp ツールを使用して、人間の介入を促し、ユーザの好みの場所、予算の制約、料理の好み、食事の制限を引き出した。この貴重なフィードバックをもとに、XAgent はシームレスにカスタマイズされたお勧めのレストランを生成し、ユーザーとその友人にパーソナライズされた満足のいく体験を提供しました。\n\n![Illustration of Ask for Human Help of XAgent](assets/readme/ask_for_human_help.png)\n\n### ケース 3. トレーニングモデル: 洗練されたツールユーザー\n\nXAgent は、平凡なタスクに取り組むだけでなく、モデルのトレーニングのような複雑なタスクにおいても貴重な支援となります。ここでは、あるユーザが映画のレビューを分析し、特定の映画を取り巻く世論の感情を評価したいというシナリオを示します。これに対して XAgent は、IMDB データセットをダウンロードしてプロセスを迅速に開始し、ディープラーニングのパワーを活用して最先端の BERT モデルをトレーニングします（以下のスクリーンショットを参照）。XAgent は、この訓練された BERT モデルによって、映画レビューの複雑なニュアンスをシームレスにナビゲートし、さまざまな映画に対する一般の認識に関する洞察に満ちた予測を提供します。\n\n![bert_1](assets/readme/bert_1.png)\n![bert_2](assets/readme/bert_2.png)\n![bert_3](assets/readme/bert_3.png)\n\n### 📊 評価\n\nXAgent の性能を評価するために、人間の嗜好評価を実施しました。評価のために [50 以上の実世界の複雑なタスク](assets/tasks.yml)を用意し、5 つのクラスに分類します: これらは、「検索とレポート」「コーディングと開発」「データ分析」「数学」「生活支援」の 5 つのクラスに分類されます。\nXAgent と [AutoGPT](https://github.com/Significant-Gravitas/AutoGPT) の結果を比較したところ、XAgent が AutoGPT に完勝しました。\n全ての実行結果は近日公開予定です。\n\n![HumanPrefer](assets/readme/agent_comparison.png)\n\n人間の嗜好の点で、AutoGPT よりも XAgent の方が大幅に優れていることを報告します。\n\nまた、以下のベンチマークで XAgent を評価しました:\n![Benchmarks](assets/readme/eval_on_dataset.png)\n\n\n<div><a id=\"ブログ\"></a></div>\n\n## 🖌️ ブログ\n\nブログは[こちら](https://blog.x-agent.net/)でご覧いただけます!\n\n<div><a id=\"引用\"></a></div>\n\n## 🌟 貢献者の皆さんへ\n\nこのプロジェクトに貢献してくれた皆さん、心から感謝します。皆さんの努力が、このプロジェクトの成長と繁栄を支えています。どんな貢献も、大きくても小さくても、非常に価値があります。\n\n![貢献者](https://contrib.rocks/image?repo=OpenBMB/XAgent)\n\n## 🌟 Star History\n\n[![Star History Chart](https://api.star-history.com/svg?repos=openbmb/xagent&type=Date)](https://star-history.com/##openbmb/xagent&Date)\n\n## 引用\n\nもし私たちのリポジトリが役に立つとお感じになりましたら、ぜひ引用をご検討ください:\n```angular2\n@misc{xagent2023,\n      title={XAgent: An Autonomous Agent for Complex Task Solving},\n      author={XAgent Team},\n      year={2023},\n}\n```\n"
        },
        {
          "name": "README_ZH.md",
          "type": "blob",
          "size": 10.1513671875,
          "content": "<div align= \"center\">\n    <h1> <img src=\"assets/readme/xagent_logo.png\" height=40 align=\"texttop\">XAgent</h1>\n</div>\n\n<div align=\"center\">\n\n[![Twitter](https://img.shields.io/twitter/follow/XAgent?style=social)](https://twitter.com/XAgentTeam) [![Discord](https://img.shields.io/badge/XAgent-Discord-purple?style=flat)](https://discord.gg/zncs5aQkWZ) [![License: Apache 2.0](https://img.shields.io/badge/License-Apache_2.0-green.svg)](https://opensource.org/license/apache-2-0/) ![Welcome](https://img.shields.io/badge/contributions-welcome-brightgreen.svg?style=flat)\n\n</div>\n\n<p align=\"center\">\n    <a href=\"README.md\">English</a> •\n    <a>中文</a> •\n    <a href=\"README_JA.md\">日本語</a>\n</p>\n\n<p align=\"center\">\n  <a href=\"#Quickstart\">教程</a> •\n  <a href=\"https://www.youtube.com/watch?v=QGkpd-tsFPA\">演示</a> •\n  <a href=\"https://blog.x-agent.net/blog/xagent/\">博客</a> •\n  <a href=\"https://xagent-doc.readthedocs.io/en/latest/\">文档</a> •\n  <a href=\"#Citation\">引用</a>\n</p>\n\n\n## 📖 介绍\n\nXAgent是一个开源的基于大型语言模型（LLM）的自主智能体，可以自动解决各种任务。\n它被设计为一个通用的智能体，可以应用于各种任务。目前，XAgent仍处于早期阶段，我们正在努力改进它。\n\n🏆 我们的目标是创建一个可以解决任何给定任务的超级智能智能体！\n\n我们欢迎各种形式的合作，包括全职、兼职等。如果您对智能体的前沿感兴趣，并希望加入我们实现真正的自主智能体，请通过 xagentteam@gmail.com 与我们联系。\n\n<div align=\"center\">\n    <img src=\"assets/readme/overview_zh.jpg\" alt=\"XAgent概述\" width=\"700\"/>\n    <br/>\n    <figcaption>XAgent功能概览</figcaption>\n</div>\n\n### <img src=\"assets/readme/xagent_logo.png\" height=30 align=\"texttop\"> XAgent\n\nXAgent具有以下特点：\n- **自主性**：XAgent可以在没有人类参与的情况下自动解决各种任务。\n- **安全性**：XAgent被设计为安全运行。所有的行为都被限制在一个docker容器内。不用担心你的主机环境受到影响\n- **可扩展性**：XAgent被设计为可扩展的。您可以轻松地添加新的工具来增强智能体的能力，甚至是新的智能体！\n- **GUI**：XAgent为用户提供了友好的GUI来与智能体交互。您也可以使用命令行界面与智能体交互。\n- **与人类的合作**：XAgent可以与您合作解决任务。它不仅有能力在行进中遵循您的指导来解决复杂的任务，而且在遇到挑战时还可以寻求您的帮助。\n\nXAgent由三部分组成：\n- **🤖 调度器** 负责动态实例化和分派任务给不同的智能体。它允许我们添加新的智能体和改进智能体的能力。\n- **🧐 规划器** 负责为任务生成和校正计划。它将任务分解为子任务，并为它们生成里程碑，使智能体能够逐步解决任务。\n- **🦾 行动者** 负责采取行动实现目标和完成子任务。行动者利用各种工具来解决子任务，它也可以与人类合作来解决任务。\n\n<div align=\"center\">\n    <img src=\"assets/readme/workflow.png\" alt=\"XAgent的工作流程\" width=\"700\"/>\n    <br/>\n    <figcaption>XAgent的工作流程图。</figcaption>\n</div>\n\n### 🧰 工具服务器\n\n工具服务器是为XAgent提供强大和安全的工具来解决任务的服务器。它是一个docker容器，为XAgent提供一个安全的运行环境。\n目前，工具服务器提供以下工具：\n- **📝 文件编辑器** 提供一个文本编辑工具，可以写入、读取和修改文件。\n- **📘 Python笔记本** 提供一个交互式的Python笔记本，可以运行Python代码来验证想法、绘制图形等。\n- **🌏 网页浏览器** 提供一个网页浏览器，可以搜索和访问网页。\n- **🖥️ Shell** 提供一个bash shell工具，可以执行任何shell命令，甚至安装程序和托管服务。\n- **🧩 Rapid API** 提供一个从Rapid API检索API并调用它们的工具，为XAgent提供了广泛的API。有关Rapid API集合的更多信息，请参见[ToolBench](https://github.com/OpenBMB/ToolBench)。\n您也可以轻松地向工具服务器添加新的工具，以增强XAgent的能力。\n\n<div><a id=\"Quickstart\"></a></div>\n\n## ✨ 快速开始\n\n### 🛠️ 构建和设置工具服务器\n\n工具服务器是XAgent的行动发生的地方。它是一个docker容器，为XAgent提供一个安全的运行环境。\n因此，您应该首先安装`docker`和`docker-compose`。\n然后，您需要构建工具服务器的镜像，参考以下任一方式构建：\n\n#### 从docker hub拉取镜像构建docker网络\n\n```bash\ndocker compose up\n```\n\n#### 从本地源代码构建镜像：\n\n```bash\ndocker compose build\ndocker compose up\n```\n\n这将构建工具服务器的镜像并启动工具服务器的容器。如果您想在后台运行容器，请相应使用`docker compose up -d`。\n参考[ToolServer](ToolServer/README_ZH.md)获取更多信息。\n\n如果需要更新工具服务器或您想重新构建工具服务器的镜像，请使用以下命令：\n\n```bash\ndocker compose pull\n```\n\n或者\n\n```bash\ndocker compose build\n```\n\n### 🎮 配置并运行XAgent\n\n在启动ToolServer后，您可以配置并运行XAgent。\n- 安装依赖项：（需要Python版本 >= 3.10）\n```bash\npip install -r requirements.txt\n```\n- 配置XAgent\n您需要使用`config.yml`配置XAgent才能运行。\n请提供至少一个 OpenAI key，用于访问OpenAI API。\n我们建议您配置使用`gpt-4-32k`来使用XAgent，`gpt-4`也可以用于大多数简单的任务。\n并且，在任何情况下，至少需要提供一个`gpt-3.5-turbo-16k` API key作为备用模型。\n我们不建议您使用`gpt-3.5-turbo`来运行XAgent，因为它的上下文长度非常有限，您不应该尝试在上面运行XAgent。\n\n- 运行XAgent\n```bash\npython run.py --task \"put your task here\" --config-file \"assets/config.yml\"\n```\n您可以使用参数`--upload-files`来指定提交给XAgent的文件。\n您的XAgent的本地工作空间在`local_workspace`中，您可以在运行过程中找到XAgent生成的所有文件。\n此外，在`running_records`中，您可以找到所有的中间步骤信息，例如任务状态、LLM的输入输出对、使用的工具等。\n在运行结束后，`ToolServerNode`中的完整`worksapce`也将被打包下载到其中。\n\n- 使用GUI运行XAgent\n容器`XAgent-Server`内包含一个监听`5173`端口的网页服务器，用于提供XAgent的GUI。\n您可以在浏览器中打开`http://localhost:5173`来访问XAgent的GUI。\n默认账号和密码是`guest`和`xagent`。\n参考[XAgentServer](XAgentServer/README_zh.md)获取更多信息。\n\n\n<div><a id=\"Demo\"></a></div>\n\n## 🎬 案例\n\n我们提供了一些使用XAgent解决任务的案例：\n你可以在[XAgent官网](https://www.x-agent.net/)上查看我们的在线演示。我们还提供了视频演示和使用XAgent的案例：\n![Demo](assets/readme/demo.gif)\n\n### 案例1. 数据分析：展示双环机制的有效性\n\n在这个案例中，我们将展示XAgent如何使用双环机制来解决数据分析任务。\n我们将使用一个简单的数据集`iris.zip`上传到XAgent，然后让XAgent分析数据集并生成一个报告。\nXAgent将任务分解为4个子任务：（1）数据理解，（2）验证Python环境，（3）编写数据分析代码，（4）编写报告。\n这里是XAgent绘制的一张图：\n\n![Data Statics by XAgent](assets/readme/statistics.png)\n\n### 案例2. 推荐：展示与人类的合作\n\nXAgent拥有独特的能力，可以积极寻求人类协助并共同解决问题，持续重新定义着人类与智能体人合作的界限。如下方截图所示，用户寻求了XAgent的帮助，以推荐一些适合友好聚会的优秀餐厅，但未提供具体细节。识别到提供的信息不足，XAgent利用了“请求人类帮助”工具，促使人类介入以获取用户的偏好位置、预算限制、烹饪偏好以及任何饮食限制。凭借这宝贵的反馈信息，XAgent轻松地生成了定制的餐厅推荐，确保用户及其朋友们获得了个性化和令人满意的体验。\n\n![Illustration of Ask for Human Help of XAgent](assets/readme/ask_for_human_help.png)\n\n### 案例3. 训练模型：高级工具使用者\n\nXAgent 不仅能处理琐碎任务，还可以在复杂任务中提供宝贵的帮助，比如模型训练。在这里，我们展示了一个用户希望分析电影评论并评估特定电影周围公众情感的情景。作为回应，XAgent 迅速启动了下载 IMDB 数据集的过程，以训练一款先进的 BERT 模型（见下方截图），利用深度学习的强大能力。拥有了这个训练有素的 BERT 模型，XAgent 能够轻松地应对电影评论的复杂细节，提供关于公众对各种电影看法的见解性预测。\n\n![bert_1](assets/readme/bert_1.png)\n![bert_2](assets/readme/bert_2.png)\n![bert_3](assets/readme/bert_3.png)\n\n### 📊 评测\n\n我们进行了人类偏好评估，以评估XAgent的性能。我们为评估准备了超过50个现实世界的复杂任务，可以分为5个类别：搜索与报告，编码与开发，数据分析，数学和生活助手。\n\n我们将XAgent的结果与[AutoGPT](https://github.com/Significant-Gravitas/AutoGPT)进行比较，结果显示XAgent完全胜过AutoGPT。\n我们将很快放出XAgent的运行日志。\n![HumanPrefer](assets/readme/agent_comparison.png)\n我们在人类偏好方面报告了XAgent相对于AutoGPT的显著改进。\n\n此外，我们还在以下基准上对XAgent进行了评估：\n![Benchmarks](assets/readme/eval_on_dataset.png)\n\n<div><a id=\"Blog\"></a></div>\n\n## 🖌️ 博客\n\n我们的官方博客在[这里](https://blog.x-agent.net/)！\n\n## 🌟 我们的贡献者\n\n衷心感谢所有贡献者。你们的努力使得这个项目不断成长和进步。无论大小，每一份贡献都是宝贵的。\n\n![贡献者](https://contrib.rocks/image?repo=OpenBMB/XAgent)\n\n## 🌟 星标历史\n\n[![Star History Chart](https://api.star-history.com/svg?repos=openbmb/xagent&type=Date)](https://star-history.com/##openbmb/xagent&Date)\n\n## 引用\n\n如果您发现我们的仓库对您有帮助，请引用我们的论文：\n```angular2\n@misc{xagent2023,\n      title={XAgent: An Autonomous Agent for Complex Task Solving}, \n      author={XAgent Team},\n      year={2023},\n}\n```\n"
        },
        {
          "name": "ToolServer",
          "type": "tree",
          "content": null
        },
        {
          "name": "XAgent",
          "type": "tree",
          "content": null
        },
        {
          "name": "XAgentGen",
          "type": "tree",
          "content": null
        },
        {
          "name": "XAgentServer",
          "type": "tree",
          "content": null
        },
        {
          "name": "XAgentWeb",
          "type": "tree",
          "content": null
        },
        {
          "name": "assets",
          "type": "tree",
          "content": null
        },
        {
          "name": "build_images.sh",
          "type": "blob",
          "size": 1.0400390625,
          "content": "#/bin/bash\ndocker buildx build --push --platform linux/arm64,linux/amd64 -t xagentteam/toolserver-manager:0.2 -f dockerfiles/ToolServerManager/Dockerfile .\ndocker buildx build --push --platform linux/arm64,linux/amd64 -t xagentteam/toolserver-manager -f dockerfiles/ToolServerManager/Dockerfile .\ndocker buildx build --push --platform linux/arm64,linux/amd64 -t xagentteam/toolserver-node:0.2 -f dockerfiles/ToolServerNode/Dockerfile .\ndocker buildx build --push --platform linux/arm64,linux/amd64 -t xagentteam/toolserver-node -f dockerfiles/ToolServerNode/Dockerfile .\ndocker buildx build --push --platform linux/arm64,linux/amd64 -t xagentteam/xagent-server:0.3 -f dockerfiles/XAgentServer/Dockerfile .\ndocker buildx build --push --platform linux/arm64,linux/amd64 -t xagentteam/xagent-server -f dockerfiles/XAgentServer/Dockerfile .\n\ndocker buildx build --push --platform linux/amd64 -t xagentteam/xagentgen:0.1 -f dockerfiles/XAgentGen/Dockerfile .\ndocker buildx build --push --platform linux/amd64 -t xagentteam/xagentgen -f dockerfiles/XAgentGen/Dockerfile ."
        },
        {
          "name": "command.py",
          "type": "blob",
          "size": 11.9541015625,
          "content": "import asyncio\nfrom contextlib import contextmanager\nimport json\nimport os\nimport threading\nimport traceback\nimport uuid\nfrom datetime import datetime\nfrom typing import List\n\nfrom colorama import Fore\n\nfrom apscheduler.schedulers.asyncio import AsyncIOScheduler\nfrom apscheduler.schedulers.blocking import BlockingScheduler\n\n\nfrom XAgentServer.application.core.envs import XAgentServerEnv\nfrom XAgentServer.database.connect import SessionLocal\nfrom XAgentServer.enums.status import StatusEnum\nfrom XAgentServer.exts.exception_ext import XAgentError\nfrom XAgentServer.interaction import XAgentInteraction\nfrom XAgentServer.loggers.logs import Logger\nfrom XAgentServer.models.interaction import InteractionBase\nfrom XAgentServer.models.parameter import InteractionParameter\nfrom XAgentServer.models.raw import XAgentRaw\nfrom XAgentServer.server import XAgentServer\nfrom XAgentServer.application.cruds.interaction import InteractionCRUD\nfrom XAgentServer.application.global_val import redis\nfrom command_input import CommandLineInput\n\n\n@contextmanager\ndef get_db():\n    \"\"\"\n    Provide a transactional scope around a series of operations.\n    \"\"\"\n    session = SessionLocal()\n    try:\n        yield session\n        session.commit()\n    except:\n        session.rollback()\n        raise\n    finally:\n        session.close()\n        \n\nclass CommandLineParam:\n    \"\"\"Command line parameters.\n    \n    Attributes:\n            task: Task description.\n            role: Role name (default is \"Assistant\").\n            plan: List of steps to perform (default is empty list).\n            upload_files: List of files to upload (default is empty list).\n            download_files: List of files to download (default is empty list).\n            record_dir: Directory to store records (default is `None`).\n            mode: Run mode. Can be \"auto\" (default is \"auto\").\n            max_wait_seconds: Maximum wait time in seconds (default is 600).\n            description: Description of the interaction (default is \"XAgent-Test\").\n            agent: Agent name (default is \"XAgent\").\n    \"\"\"\n    def __init__(self,\n                 task,\n                role=\"Assistant\",\n                plan=[],\n                upload_files: List[str] = [],\n                download_files: List[str] = [],\n                record_dir: str = None,\n                mode: str = \"auto\",\n                max_wait_seconds: int = 600,\n                description: str = \"XAgent-Test\",\n                agent: str = \"XAgent\",\n                ):\n        self.task = task\n        self.plan = plan\n        self.role = role\n        self.upload_files = upload_files\n        self.download_files = download_files\n        self.record_dir = record_dir\n        # auto is supported only in cmd\n        self.mode = \"auto\"\n        self.max_wait_seconds = max_wait_seconds\n        self.description = description\n        self.agent = agent\n\n\nclass CommandLine():\n    \"\"\"\n    A command-line interface for interacting with XAgentServer.\n\n    Attributes:\n        env: An instance of the XAgentServer environment.\n        client_id: A unique identifier for the client, generated as a hexadecimal UUID.\n        date_str: The current date as a string in YYYY-MM-DD format.\n        log_dir: The directory where the logs are stored.\n        logger: An instance of the Logger used for logging interactions.\n        interactionDB: A database interface for interacting with either a persistent\n            database (SQLite, MySQL, PostgreSQL) or a local storage file, depending\n            on the configuration of `env`.\n    \"\"\"\n\n    def __init__(self, args: CommandLineParam = None):\n        \"\"\"\n        Initialize the CommandLine instance.\n\n        Args:\n            args (CommandLineParam) : parameters.\n            task is required,\n            mode options: [\"auto\"]\n        \"\"\"\n\n        self.args = args\n        self.client_id = uuid.uuid4().hex\n        self.date_str = datetime.now().strftime(\"%Y-%m-%d\")\n        self.log_dir = os.path.join(os.path.join(XAgentServerEnv.base_dir, \"localstorage\",\n                                    \"interact_records\"), self.date_str, self.client_id)\n        if not os.path.exists(self.log_dir):\n            os.makedirs(self.log_dir)\n\n        self.logger = Logger(log_dir=self.log_dir, log_file=f\"interact.log\")\n\n        self.logger.typewriter_log(\n            title=f\"XAgentServer is running on cmd mode\",\n            title_color=Fore.RED)\n        self.logger.info(title=f\"XAgentServer log:\",\n                         title_color=Fore.RED, message=f\"{self.log_dir}\")\n        self.interrupt = self.args.mode != \"auto\"\n        self.init_conv_env()\n        self.max_wait_seconds = self.args.max_wait_seconds\n        self.scheduler = AsyncIOScheduler()\n        self.input = None\n        if self.interrupt:\n            self.input = CommandLineInput(\n                do_interrupt=True,\n                max_wait_seconds=self.max_wait_seconds,\n                logger=self.logger)\n\n    def init_conv_env(self):\n        \"\"\"initialize the conversation environment, \n        Share the same database resource with webui.\n        If you have initiated a session on the front end but it has not been executed, \n        this ID will be shared.\n        \"\"\"\n        user_id = \"guest\"\n        token = \"xagent\"\n        description = self.args.description\n        upload_files = self.args.upload_files\n        record_dir = self.args.record_dir\n        agent = self.args.agent\n        goal = self.args.task\n        mode = self.args.mode\n        plan = self.args.plan\n\n        with get_db() as db:\n            interaction = InteractionCRUD.get_ready_interaction(\n                db=db, user_id=user_id)\n            self.continue_flag = True\n            upload_files = upload_files if upload_files else []\n            file_list = []\n            for file in upload_files:\n                file_list.append({\n                    \"uuid\": file,\n                    \"name\": file\n                })\n            if interaction is None:\n\n                base = InteractionBase(interaction_id=self.client_id,\n                                       user_id=user_id,\n                                       create_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n                                       description=description,\n                                       agent=agent,\n                                       mode=mode,\n                                       file_list=file_list,\n                                       recorder_root_dir=\"\",\n                                       status=\"ready\",\n                                       message=\"ready...\",\n                                       current_step=\"-1\",\n                                       update_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n                                       call_method=\"cmd\")\n                InteractionCRUD.create_interaction(db=db, base=base)\n            else:\n                self.client_id = interaction.interaction_id\n            \n            parameter = InteractionParameter(\n                interaction_id=self.client_id,\n                parameter_id=uuid.uuid4().hex,\n                args={\n                    \"goal\": goal,\n                    \"plan\": plan\n                    },\n            )\n            InteractionCRUD.add_parameter(db=db, parameter=parameter)\n\n\n    def run(self):\n        \"\"\"\n        Runs the interaction with the XAgentServer with the provided arguments.\n        \"\"\"\n\n        # Create a new raw data to record\n        with get_db() as db:\n            InteractionCRUD.insert_raw(db=db, process=XAgentRaw(\n                interaction_id=self.client_id,\n                node_id=uuid.uuid4().hex,\n                status=StatusEnum.RUNNING,\n                create_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n                update_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n                current=\"\",\n                step=-1,\n                data=None,\n                file_list=[],\n                do_interrupt=self.interrupt,\n                wait_seconds=0,\n                ask_for_human_help=False,\n                is_human=True,\n                human_data={\"goal\": self.args.task, \"plan\": self.args.plan},\n                human_file_list=self.args.upload_files,\n                is_send=True,\n                is_receive=False,\n                is_deleted=False\n            ))\n            redis.set_key(f\"{self.client_id}_send\", 1)\n            \n            parameter = InteractionCRUD.get_init_parameter(\n                db=db, interaction_id=self.client_id)\n        \n        self.task_handler(parameter=parameter)\n\n    def task_handler(self, parameter: InteractionParameter):\n        \"\"\"\n        define a long task to run interaction\n\n        Args:\n            parameter (InteractionParameter): The parameter of interaction\n        \"\"\"\n\n        try:\n            current_step = uuid.uuid4().hex\n            with get_db() as db:\n                base = InteractionCRUD.get_interaction(db=db,\n                                                    interaction_id=self.client_id)\n                InteractionCRUD.update_interaction_status(db=db,\n                                                        interaction_id=base.interaction_id,\n                                                        status=\"running\",\n                                                        message=\"running\",\n                                                        current_step=current_step)\n\n            # if mode is not auto, we will interrupt the interaction\n            # and you can change the wait_seconds\n            # default 10 min.\n            interaction = XAgentInteraction(\n                base=base,\n                parameter=parameter,\n                interrupt=base.mode != \"auto\",\n                call_method=\"cmd\")\n\n            # Register logger, dbinto interaction\n            interaction.resister_logger(self.logger)\n            self.logger.info(\n                f\"Register logger into interaction of {base.interaction_id}, done!\")\n\n            interaction.register_db(db=db)\n            self.logger.info(\n                f\"Register db into interaction of {base.interaction_id}, done!\")\n            # Create XAgentServer\n            server = XAgentServer(logger=self.logger)\n            self.logger.info(\n                f\"Register logger into XAgentServer of {base.interaction_id}, done!\")\n            self.logger.info(\n                f\"Start a new thread to run interaction of {base.interaction_id}, done!\")\n            # await server.interact(interaction=interaction)\n            server.interact(interaction=interaction)\n        except XAgentError as e:\n            traceback.print_exc()\n            self.logger.error(\n                f\"Error in task_handler of {self.client_id}: {e}\")\n            with get_db() as db:\n                InteractionCRUD.insert_error(\n                    db=db, interaction_id=self.client_id, message=str(e))\n                redis.set_key(self.client_id + \"_send\", 1)\n                InteractionCRUD.update_interaction_status(db=db,\n                                                        interaction_id=self.client_id,\n                                                        status=\"failed\",\n                                                        message=str(e),\n                                                        current_step=current_step)\n        \n    def start(self):\n\n        self.run()\n\n\nif __name__ == \"__main__\":\n    import sys\n    args = CommandLineParam()\n    if len(sys.argv) >= 2:\n        print(sys.argv[1])\n        if len(sys.argv) >= 3:\n            original_stdout = sys.stdout\n            from XAgent.running_recorder import recorder\n            sys.stdout = open(os.path.join(\n                recorder.record_root_dir, \"command_line.ansi\"), \"w\", encoding=\"utf-8\")\n\n        args.task = sys.argv[1],\n        args.role=\"Assistant\",\n        args.mode=\"auto\",\n        if len(sys.argv) >= 3:\n            sys.stdout.close()\n            sys.stdout = original_stdout\n\n    else:\n        args.task = \"I will have five friends coming to visit me this weekend, please find and recommend some restaurants for us.\",\n        args.role=\"Assistant\",\n        args.mode=\"auto\",\n        \n    cmd = CommandLine(XAgentServerEnv, args)\n"
        },
        {
          "name": "command_input.py",
          "type": "blob",
          "size": 5.087890625,
          "content": "import asyncio\nimport functools\nimport time\nfrom colorama import Fore\nfrom XAgentServer.exts.exception_ext import XAgentTimeoutError, XAgentCloseError\n\nfrom inputimeout import inputimeout, TimeoutOccurred\nfrom XAgentServer.application.global_val import redis\nimport math\n\n\ndef timer(func):\n    \"\"\"\n    Decorator function to time the execution of a function.\n\n    Args:\n        func (Function): The function to be timed.\n\n    Returns:\n        wrapper (Function): The wrapped function with added timing functionality.\n    \"\"\"\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        try:\n            start_time = time.time()\n            result = func(*args, **kwargs)\n            end_time = time.time()\n        except:\n            pass\n    return wrapper\n\n\nclass CommandLineInput:\n    \"\"\"\n    Class for handling command line input.\n\n    This child class extends from BaseInput and implements methods to handle and manage command line input data.\n\n    Attributes:\n        do_interrupt (bool): If True, input will be interrupted.\n        max_wait_seconds (int): Maximum wait time for input in seconds.\n    \"\"\"\n    def __init__(self,\n                 do_interrupt: bool = False,\n                 max_wait_seconds: int = 600,\n                 logger=None):\n        self.do_interrupt = do_interrupt\n        self.max_wait_seconds = max_wait_seconds\n        self.logger = logger\n\n    def run(self, input_data):\n        \"\"\"\n        Run the command line input method.\n\n        Args:\n            input_data (Any): The original input data to be processed.\n\n        Returns:\n            data (Any): The processed input data.\n        \"\"\"\n        if self.do_interrupt:\n            data = self.interrupt(input_data)\n        else:\n            data = input_data\n        return data\n    \n    def get_each_input(self, key, value, res, timeout):\n        \"\"\"\n        Returns the input from the command line for a single key-value pair.\n\n        Args:\n            key (str): The key for which to get input.\n            value (Any): The current value associated with the key.\n            res (dict): The result dictionary where inputs collected will be stored.\n            timeout (int): Timeout in seconds for the input.\n\n        Returns:\n            Any: The input data.\n        \"\"\"\n        self.logger.typewriter_log(\n            f\"Now, ASK For {key}, Origin Input: {value}\",\n            Fore.RED,\n            f\"\"\n        )\n        self.logger.typewriter_log(\n            f\"Now, you can modify the current field by entering some information, and then press 'Enter' to continue, if you want to keep the original input, please enter '-1' and then press 'Enter':\",\n            Fore.GREEN\n        )\n        temp = inputimeout(prompt=f'You have {timeout} seconds to input:\\n', timeout=timeout)\n        if temp == \"-1\":\n            return value\n        else:\n            return temp\n        \n    def get_input(self, origin_data):\n        \"\"\"\n        Get input for all fields of the original data from the command line.\n\n        Args:\n            origin_data (dict): The original data for which to get input.\n\n        Returns:\n            dict: The dictionary with updated inputs.\n        \"\"\"\n        self.logger.typewriter_log(\n                \"Next, you can start modifying the original input by typing 'Y/y/yes' or skip this step by typing 'N/n/no' and then press 'Enter' to continue the loop:\",\n                Fore.RED\n            )\n        update = inputimeout(prompt=f'You have to make a decision within 60 seconds:\\n', timeout=60)\n        res = {\"args\": {}}\n        if update in ['y', 'Y', 'yes']:\n            execute_time = self.max_wait_seconds\n            if isinstance(origin_data, dict):\n                args = origin_data.get(\"args\", \"\")\n                self.logger.typewriter_log(\n                    f\"Next, you will have a total of {self.max_wait_seconds} seconds to modify each option:\",\n                    Fore.RED,\n                )\n                for key, value in args.items():\n                    if key == \"done\":\n                        res[key] = False\n                        continue\n                    start_time = time.time()\n                    res[\"args\"][key] = self.get_each_input(key, value, res, execute_time)\n                    end_time = time.time()\n                    execute_time = math.floor(execute_time - (end_time - start_time))\n            self.logger.info(f\"modify the input, receive the data: {res}\")\n        else:\n            res = origin_data\n            self.logger.info(\"skip this step\")\n        self.logger.info(\"continue the loop\")\n        res[\"done\"] = True\n        return res\n    \n    def interrupt(self, input_data):\n        \"\"\"\n        Interrupts the current input process and returns the current data.\n\n        Args:\n            input_data (dict): The original input data.\n\n        Returns:\n            dict: The current data collected so far.\n\n        Raises:\n            XAgentIOTimeoutError: If the input times out.\n        \"\"\"\n        try:\n            data = self.get_input(input_data)\n            return data\n        except TimeoutOccurred:\n            self.logger.error(f\"Waiting timemout, close connection!\")\n            raise XAgentTimeoutError(\"timeout!\")"
        },
        {
          "name": "docker-compose.yml",
          "type": "blob",
          "size": 2.6123046875,
          "content": "version: '3'\n\nservices:\n  ToolServerManager:\n    image: xagentteam/toolserver-manager:latest\n    build:\n      context: ./\n      dockerfile: dockerfiles/ToolServerManager/Dockerfile\n    ports:\n      - 8080:8080\n    volumes:\n      - toolserverconfig:/app/assets/config\n      - /var/run/docker.sock:/var/run/docker.sock\n    environment:\n     DB_HOST: db\n     DB_PORT: 27017\n     DB_USERNAME: ${DB_USERNAME}\n     DB_PASSWORD: ${DB_PASSWORD}\n     DB_COLLECTION: ${DB_COLLECTION}\n    depends_on:\n      - db\n    command: [\"--workers\",\"2\",\"-t\",\"600\"]\n\n  # This will create a test node that will never be used by XAgent\n  ToolServerNode:\n    image: xagentteam/toolserver-node:latest\n    build:\n      context: ./\n      dockerfile: dockerfiles/ToolServerNode/Dockerfile\n    volumes:\n      - \"toolserverconfig:/app/assets/config\"\n\n  db:\n    image: mongo\n    volumes:\n      - xagentmongodb:/data/db\n    environment:\n     MONGO_INITDB_ROOT_USERNAME: ${DB_USERNAME}\n     MONGO_INITDB_ROOT_PASSWORD: ${DB_PASSWORD}\n    logging:\n      driver: \"none\"\n\n  XAgentServer:\n    image: xagentteam/xagent-server:latest\n    build:\n      context: ./\n      dockerfile: dockerfiles/XAgentServer/Dockerfile\n    container_name: XAgent-Server\n    env_file:\n      - .env\n    environment:\n      - TOOLSERVER_URL=http://ToolServerManager:8080\n      - MYSQL_DB_URL=mysql+pymysql://root:xagent@xagent-mysql:3306/xagent\n      - REDIS_HOST=xagent-redis\n    volumes:\n      - ./assets:/app/assets:ro\n    ports:\n      - \"5173:5173\"\n      - \"8090:8090\"\n    depends_on:\n      xagent-mysql:\n        condition: service_healthy\n      xagent-redis:\n        condition: service_healthy\n\n  xagent-mysql:\n    image: mysql\n    command:\n      - --default-authentication-plugin=caching_sha2_password\n      - --character-set-server=utf8mb4\n      - --collation-server=utf8mb4_unicode_ci\n    environment:\n      MYSQL_ROOT_PASSWORD: xagent\n    ports:\n      - \"3306:3306\"\n    volumes:\n      - ./XAgentServer/database/sql:/docker-entrypoint-initdb.d\n    healthcheck:\n      # test: [ \"CMD\", \"mysqladmin\",\"ping\", \"-h\", \"localhost\" ]\n      test: [\"CMD-SHELL\", \"mysql -h localhost -u root -pxagent -e 'SELECT 1'\"]\n      #interval: 10s\n      timeout: 20s\n      retries: 20\n\n  xagent-redis:\n    image: redis\n    ports:\n      - \"6379:6379\"\n    command: redis-server --requirepass xagent\n    healthcheck:\n      test: [ \"CMD\", \"redis-cli\", \"ping\" ]\n      interval: 5s\n      timeout: 3s\n      retries: 20\n\n\n\nvolumes:\n  xagentmongodb:\n  toolserverconfig:\n    name: toolserverconfig\n    driver: local\n    driver_opts:\n      type: none\n      device: ./assets/config\n      o: bind\nnetworks:\n  default:\n    name: tool-server-network\n    driver: bridge\n"
        },
        {
          "name": "dockerfiles",
          "type": "tree",
          "content": null
        },
        {
          "name": "local_workspace",
          "type": "tree",
          "content": null
        },
        {
          "name": "requirements.txt",
          "type": "blob",
          "size": 0.29296875,
          "content": "charset_normalizer\ncolorama\nfastapi\njsonschema\nMarkdown\norjson\nPillow\npydantic\nPyYAML\nregex\nRequests\nsetuptools\ntermcolor\ntiktoken\ntqdm\nuvicorn\njson5\nopenai\npython-dotenv\nsqlalchemy\ntenacity\nredis\npymysql\nyagmail\npython-multipart\napscheduler\npinecone-client\nwebsockets\ncryptography\ninputimeout\npytest"
        },
        {
          "name": "run.py",
          "type": "blob",
          "size": 4.025390625,
          "content": "import os\nfrom contextlib import redirect_stdout\nimport argparse\nfrom copy import deepcopy\nfrom XAgent.config import CONFIG, ARGS\nfrom command import CommandLine, CommandLineParam\n\n\ndef parse_args() -> argparse.Namespace:\n    \"\"\"\n    Parse the command line arguments and return them as an argparse.Namespace object.\n\n    Returns:\n        argparse.Namespace: An object containing command line arguments and their values.\n    \"\"\"\n    parser = argparse.ArgumentParser()\n\n    parser.add_argument(\"--task\", type=str, required=True, help=\"The task description.\")\n    parser.add_argument(\"--upload-files\", nargs='+', dest=\"upload_files\", help=\"List of files to upload.\")\n    parser.add_argument(\"--model\", type=str, help=\"Model identifier for the task.\")\n    parser.add_argument(\"--record-dir\", type=str, dest=\"record_dir\", help=\"Directory to record task execution logs.\")\n    parser.add_argument(\"--mode\", type=str, default=\"auto\", help=\"Operational mode: 'auto' or 'manual'.\")\n    parser.add_argument(\"--quiet\", action=\"store_true\", default=False, help=\"Run in quiet mode; minimal output.\")\n    parser.add_argument(\"--max-subtask-chain-length\", type=int, dest=\"max_subtask_chain_length\",\n                        help=\"Maximum length of subtask chain.\")\n    parser.add_argument(\"--enable-ask-human-for-help\", action=\"store_true\", dest=\"enable_ask_human_for_help\",\n                        help=\"Flag to enable asking for human assistance.\")\n    parser.add_argument(\"--max-plan-refine-chain-length\", type=int, dest=\"max_plan_refine_chain_length\",\n                        help=\"Maximum length of plan refinement chain.\")\n    parser.add_argument(\"--max-plan-tree-depth\", type=int, dest=\"max_plan_tree_depth\",\n                        help=\"Maximum depth of the plan tree.\")\n    parser.add_argument(\"--max-plan-tree-width\", type=int, dest=\"max_plan_tree_width\",\n                        help=\"Maximum width of the plan tree.\")\n    parser.add_argument(\"--max-retry-times\", type=int, dest=\"max_retry_times\", help=\"Maximum number of retry attempts.\")\n    parser.add_argument(\"--config-file\", type=str, default=os.getenv('CONFIG_FILE', 'assets/config.yml'),\n                        dest=\"config_file\", help=\"Path to the configuration file.\")\n\n    return parser.parse_args()\n\n\ndef execute_command_line_process(args: argparse.Namespace, quiet_mode: bool = False) -> None:\n    \"\"\"\n    Execute the command line process based on the parsed arguments. If quiet mode is enabled,\n    redirect stdout to a file specified by the recorder's record_root_dir.\n\n    Args:\n        args (argparse.Namespace): Parsed command line arguments.\n        quiet_mode (bool): Whether to run in quiet mode, outputting to a file instead of the terminal.\n    \"\"\"\n    args_dict = vars(args)\n    for key, value in args_dict.items():\n        if value is not None:\n            if key == 'model':\n                ARGS['default_completion_kwargs'] = deepcopy(CONFIG['default_completion_kwargs'])\n                ARGS['default_completion_kwargs']['model'] = value\n            else:\n                ARGS[key] = value\n\n    # Redirect stdout to a file if quiet mode is true\n    if quiet_mode:\n        from XAgent.running_recorder import recorder\n        record_file_path = os.path.join(recorder.record_root_dir, \"command_line.ansi\")\n        with open(record_file_path, \"w\", encoding=\"utf-8\") as file, redirect_stdout(file):\n            start_command_line(args_dict)\n    else:\n        start_command_line(args_dict)\n\n\ndef start_command_line(args_dict: dict) -> None:\n    \"\"\"\n    Start the command line interface with the provided arguments.\n\n    Args:\n        args_dict (dict): A dictionary of command line arguments.\n    \"\"\"\n    param = CommandLineParam(\n        task=args_dict['task'],\n        upload_files=args_dict.get('upload_files'),\n        role=\"Assistant\",\n        mode=args_dict[\"mode\"],\n    )\n    cmd = CommandLine(param)\n    cmd.start()\n\n\nif __name__ == '__main__':\n    args = parse_args()\n    os.environ['CONFIG_FILE'] = args.config_file\n\n    # The quiet_mode argument is passed directly to the function\n    execute_command_line_process(args, quiet_mode=args.quiet)\n"
        },
        {
          "name": "setup.py",
          "type": "blob",
          "size": 0.1796875,
          "content": "#!/usr/bin/env python3\n\n\"\"\"Set up\"\"\"\n\nfrom setuptools import find_packages\nfrom setuptools import setup\n\n\nsetup(\n    name=\"XAgent\",\n    version=\"1.0.0\",\n    packages=find_packages()\n)\n"
        },
        {
          "name": "start_server.py",
          "type": "blob",
          "size": 0.4033203125,
          "content": "\"\"\"Start server\"\"\"\nimport os\nimport uvicorn\n\nfrom XAgentServer.application.core.envs import XAgentServerEnv\n\nif __name__ == \"__main__\":\n    os.system(\"systemctl start nginx\")\n    uvicorn.run(app=\"XAgentServer.application.main:app\",\n                host=XAgentServerEnv.host,\n                port=XAgentServerEnv.port,\n                reload=XAgentServerEnv.reload,\n                workers=XAgentServerEnv.workers)"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}