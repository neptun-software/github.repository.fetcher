{
  "metadata": {
    "timestamp": 1736560723216,
    "page": 394,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "Yelp/dumb-init",
      "stars": 6956,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".dockerignore",
          "type": "blob",
          "size": 0.009765625,
          "content": ".tox\n.git\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.08984375,
          "content": "*.deb\n*.egg-info\n*.gc*\n*.o\n*.py[cod]\n.pytest_cache\n.tox\n__pycache__/\nbuild/\ndist/\ndumb-init\n"
        },
        {
          "name": ".pre-commit-config.yaml",
          "type": "blob",
          "size": 1.17578125,
          "content": "repos:\n-   repo: https://github.com/pre-commit/pre-commit-hooks\n    rev: v4.4.0\n    hooks:\n    -   id: check-added-large-files\n    -   id: check-docstring-first\n    -   id: check-executables-have-shebangs\n    -   id: check-merge-conflict\n    -   id: check-yaml\n    -   id: debug-statements\n    -   id: detect-private-key\n    -   id: double-quote-string-fixer\n    -   id: end-of-file-fixer\n    -   id: name-tests-test\n    -   id: requirements-txt-fixer\n    -   id: trailing-whitespace\n-   repo: https://github.com/pre-commit/mirrors-autopep8\n    rev: v2.0.0\n    hooks:\n    -   id: autopep8\n-   repo: https://github.com/pycqa/flake8\n    rev: 6.0.0\n    hooks:\n    -   id: flake8\n-   repo: https://github.com/asottile/reorder_python_imports\n    rev: v3.9.0\n    hooks:\n    -   id: reorder-python-imports\n        args: ['--py3-plus']\n-   repo: https://github.com/Lucas-C/pre-commit-hooks\n    rev: v1.3.1\n    hooks:\n    -   id: remove-tabs\n-   repo: https://github.com/asottile/pyupgrade\n    rev: v3.3.0\n    hooks:\n    -   id: pyupgrade\n        args: ['--py3-plus']\n-   repo: https://github.com/asottile/add-trailing-comma\n    rev: v2.3.0\n    hooks:\n    -   id: add-trailing-comma\n        args: ['--py36-plus']\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 1.5625,
          "content": "Contributing to dumb-init\n========\n\n`dumb-init` is primarily developed by [Yelp](https://yelp.github.io/), but\ncontributions are welcome from everyone!\n\nCode is reviewed using GitHub pull requests. To make a contribution, you should:\n\n1. Fork the GitHub repository\n2. Push code to a branch on your fork\n3. Create a pull request and wait for it to be reviewed\n\nWe aim to have all dumb-init behavior covered by tests. If you make a change in\nbehavior, please add a test to ensure it doesn't regress. We're also happy to\nhelp with suggestions on testing!\n\n\n## Releasing new versions\n\n`dumb-init` uses [semantic versioning](http://semver.org/). If you're making a\ncontribution, please don't bump the version number yourselfâ€”we'll take care\nof that after merging!\n\nThe process to release a new version is:\n\n1. Update the version in `VERSION` and run `make VERSION.h`\n2. Update the Debian changelog with `dch -v {new version}`.\n3. Update the two `wget` urls in the README to point to the new version.\n4. Commit the changes and tag the commit like `v1.0.0`.\n5. `git push --tags origin master`\n6. Wait for Travis to run, then find and download the binary and Debian\n   packages for all architectures; there will be links printed at the\n   end of the Travis output. Put these into your `dist` directory.\n7. Run `make release`\n8. Run `twine upload --skip-existing dist/*.tar.gz dist/*.whl` to upload the\n   new version to PyPI\n9. Upload the resulting Debian packages, binaries, and sha256sums file (all\n   inside the `dist` directory) to a new [GitHub\n   release](https://github.com/Yelp/dumb-init/releases)\n"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 0.810546875,
          "content": "ARG BASE_IMAGE=debian:buster\nFROM $BASE_IMAGE\n\nLABEL maintainer=\"Chris Kuehl <ckuehl@yelp.com>\"\n\n# Install the bare minimum dependencies necessary for working with Debian\n# packages. Build dependencies should be added under \"Build-Depends\" inside\n# debian/control instead.\nRUN : \\\n    && apt-get update \\\n    && DEBIAN_FRONTEND=noninteractive apt-get install -y --no-install-recommends \\\n        build-essential \\\n        devscripts \\\n        equivs \\\n        lintian \\\n        python3-distutils \\\n        python3-setuptools \\\n        python3-pip \\\n    && apt-get clean \\\n    && rm -rf /var/lib/apt/lists/*\nWORKDIR /tmp/mnt\n\nCOPY debian/control /control\nRUN : \\\n    && apt-get update \\\n    && mk-build-deps --install --tool 'apt-get -y --no-install-recommends' /control \\\n    && apt-get clean \\\n    && rm -rf /var/lib/apt/lists/*\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0517578125,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2015 Yelp, Inc.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "MANIFEST.in",
          "type": "blob",
          "size": 0.052734375,
          "content": "include dumb-init.c\ninclude VERSION\ninclude VERSION.h\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 2.1494140625,
          "content": "SHELL=bash\nCFLAGS=-std=gnu99 -static -s -Wall -Werror -O3\n\nTEST_PACKAGE_DEPS := build-essential python python-pip procps python-dev python-setuptools\n\nDOCKER_RUN_TEST := docker run -v $(PWD):/mnt:ro\nVERSION = $(shell cat VERSION)\n\n.PHONY: build\nbuild: VERSION.h\n\t$(CC) $(CFLAGS) -o dumb-init dumb-init.c\n\nVERSION.h: VERSION\n\techo '// THIS FILE IS AUTOMATICALLY GENERATED' > VERSION.h\n\techo '// Run `make VERSION.h` to update it after modifying VERSION.' >> VERSION.h\n\txxd -i VERSION >> VERSION.h\n\n.PHONY: clean\nclean: clean-tox\n\trm -rf dumb-init dist/ *.deb\n\n.PHONY: clean-tox\nclean-tox:\n\trm -rf .tox\n\n.PHONY: release\nrelease: python-dists\n\tcd dist && \\\n\t\tsha256sum --binary dumb-init_$(VERSION)_amd64.deb dumb-init_$(VERSION)_x86_64 dumb-init_$(VERSION)_ppc64el.deb dumb-init_$(VERSION)_ppc64le dumb-init_$(VERSION)_s390x.deb dumb-init_$(VERSION)_s390x dumb-init_$(VERSION)_arm64.deb dumb-init_$(VERSION)_aarch64 \\\n\t\t> sha256sums\n\n.PHONY: python-dists\npython-dists: python-dists-x86_64 python-dists-aarch64 python-dists-ppc64le python-dists-s390x\n\n.PHONY: python-dists-%\npython-dists-%: VERSION.h\n\tpython setup.py sdist\n\tdocker run \\\n\t\t--user $$(id -u):$$(id -g) \\\n\t\t-v `pwd`/dist:/dist:rw \\\n\t\tquay.io/pypa/manylinux2014_$*:latest \\\n\t\tbash -exc ' \\\n\t\t\t/opt/python/cp38-cp38/bin/pip wheel --wheel-dir /tmp /dist/*.tar.gz && \\\n\t\t\tauditwheel repair --wheel-dir /dist /tmp/*.whl --wheel-dir /dist \\\n\t\t'\n\n.PHONY: builddeb\nbuilddeb:\n\tdebuild --set-envvar=CC=musl-gcc -us -uc -b\n\tmkdir -p dist\n\tmv ../dumb-init_*.deb dist/\n\t# Extract the built binary from the Debian package\n\tdpkg-deb --fsys-tarfile dist/dumb-init_$(VERSION)_$(shell dpkg --print-architecture).deb | \\\n\t\ttar -C dist --strip=3 -xvf - ./usr/bin/dumb-init\n\tmv dist/dumb-init dist/dumb-init_$(VERSION)_$(shell uname -m)\n\n.PHONY: builddeb-docker\nbuilddeb-docker: docker-image\n\tmkdir -p dist\n\tdocker run --init --user $$(id -u):$$(id -g) -v $(PWD):/tmp/mnt dumb-init-build make builddeb\n\n.PHONY: docker-image\ndocker-image:\n\tdocker build $(if $(BASE_IMAGE),--build-arg BASE_IMAGE=$(BASE_IMAGE)) -t dumb-init-build .\n\n.PHONY: test\ntest:\n\ttox\n\ttox -e pre-commit\n\n.PHONY: install-hooks\ninstall-hooks:\n\ttox -e pre-commit -- install -f --install-hooks\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 12.2744140625,
          "content": "dumb-init\n========\n\n[![PyPI version](https://badge.fury.io/py/dumb-init.svg)](https://pypi.python.org/pypi/dumb-init)\n\n\n**dumb-init** is a simple process supervisor and init system designed to run as\nPID 1 inside minimal container environments (such as [Docker][docker]). It is\ndeployed as a small, statically-linked binary written in C.\n\nLightweight containers have popularized the idea of running a single process or\nservice without normal init systems like [systemd][systemd] or\n[sysvinit][sysvinit]. However, omitting an init system often leads to incorrect\nhandling of processes and signals, and can result in problems such as\ncontainers which can't be gracefully stopped, or leaking containers which\nshould have been destroyed.\n\n`dumb-init` enables you to simply prefix your command with `dumb-init`. It acts\nas PID 1 and immediately spawns your command as a child process, taking care to\nproperly handle and forward signals as they are received.\n\n\n## Why you need an init system\n\nNormally, when you launch a Docker container, the process you're executing\nbecomes PID 1, giving it the quirks and responsibilities that come with being\nthe init system for the container.\n\nThere are two common issues this presents:\n\n1. In most cases, signals won't be handled properly.\n\n   The Linux kernel applies special signal handling to processes which run as\n   PID 1.\n\n   When processes are sent a signal on a normal Linux system, the kernel will\n   first check for any custom handlers the process has registered for that\n   signal, and otherwise fall back to default behavior (for example, killing\n   the process on `SIGTERM`).\n\n   However, if the process receiving the signal is PID 1, it gets special\n   treatment by the kernel; if it hasn't registered a handler for the signal,\n   the kernel won't fall back to default behavior, and nothing happens. In\n   other words, if your process doesn't explicitly handle these signals,\n   sending it `SIGTERM` will have no effect at all.\n\n   A common example is CI jobs that do `docker run my-container script`: sending\n   `SIGTERM` to the `docker run` process will typically kill the `docker run` command,\n   but leave the container running in the background.\n\n2. Orphaned zombie processes aren't properly reaped.\n\n   A process becomes a zombie when it exits, and remains a zombie until its\n   parent calls some variation of the `wait()` system call on it. It remains in\n   the process table as a \"defunct\" process. Typically, a parent process will\n   call `wait()` immediately and avoid long-living zombies.\n\n   If a parent exits before its child, the child is \"orphaned\", and is\n   re-parented under PID 1. The init system is thus responsible for\n   `wait()`-ing on orphaned zombie processes.\n\n   Of course, most processes *won't* `wait()` on random processes that happen\n   to become attached to them, so containers often end with dozens of zombies\n   rooted at PID 1.\n\n\n## What `dumb-init` does\n\n`dumb-init` runs as PID 1, acting like a simple init system. It launches a\nsingle process and then proxies all received signals to a session rooted at\nthat child process.\n\nSince your actual process is no longer PID 1, when it receives signals from\n`dumb-init`, the default signal handlers will be applied, and your process will\nbehave as you would expect. If your process dies, `dumb-init` will also die,\ntaking care to clean up any other processes that might still remain.\n\n\n### Session behavior\n\nIn its default mode, `dumb-init` establishes a\n[session](http://man7.org/linux/man-pages/man2/setsid.2.html) rooted at the\nchild, and sends signals to the entire process group. This is useful if you\nhave a poorly-behaving child (such as a shell script) which won't normally\nsignal its children before dying.\n\nThis can actually be useful outside of Docker containers in regular process\nsupervisors like [daemontools][daemontools] or [supervisord][supervisord] for\nsupervising shell scripts. Normally, a signal like `SIGTERM` received by a\nshell isn't forwarded to subprocesses; instead, only the shell process dies.\nWith dumb-init, you can just write shell scripts with dumb-init in the shebang:\n\n    #!/usr/bin/dumb-init /bin/sh\n    my-web-server &  # launch a process in the background\n    my-other-server  # launch another process in the foreground\n\nOrdinarily, a `SIGTERM` sent to the shell would kill the shell but leave those\nprocesses running (both the background and foreground!).  With dumb-init, your\nsubprocesses will receive the same signals your shell does.\n\nIf you'd like for signals to only be sent to the direct child, you can run with\nthe `--single-child` argument, or set the environment variable\n`DUMB_INIT_SETSID=0` when running `dumb-init`. In this mode, dumb-init is\ncompletely transparent; you can even string multiple together (like `dumb-init\ndumb-init echo 'oh, hi'`).\n\n\n### Signal rewriting\n\ndumb-init allows rewriting incoming signals before proxying them. This is\nuseful in cases where you have a Docker supervisor (like Mesos or Kubernetes)\nwhich always sends a standard signal (e.g. SIGTERM). Some apps require a\ndifferent stop signal in order to do graceful cleanup.\n\nFor example, to rewrite the signal SIGTERM (number 15) to SIGQUIT (number 3),\njust add `--rewrite 15:3` on the command line.\n\nTo drop a signal entirely, you can rewrite it to the special number `0`.\n\n\n#### Signal rewriting special case\n\nWhen running in setsid mode, it is not sufficient to forward\n`SIGTSTP`/`SIGTTIN`/`SIGTTOU` in most cases, since if the process has not added\na custom signal handler for these signals, then the kernel will not apply\ndefault signal handling behavior (which would be suspending the process) since\nit is a member of an orphaned process group. For this reason, we set default\nrewrites to `SIGSTOP` from those three signals. You can opt out of this\nbehavior by rewriting the signals back to their original values, if desired.\n\nOne caveat with this feature: for job control signals (`SIGTSTP`, `SIGTTIN`,\n`SIGTTOU`), dumb-init will always suspend itself after receiving the signal,\neven if you rewrite it to something else.\n\n\n## Installing inside Docker containers\n\nYou have a few options for using `dumb-init`:\n\n\n### Option 1: Installing from your distro's package repositories (Debian, Ubuntu, etc.)\n\nMany popular Linux distributions (including Debian (since `stretch`) and Debian\nderivatives such as Ubuntu (since `bionic`)) now contain dumb-init packages in\ntheir official repositories.\n\nOn Debian-based distributions, you can run `apt install dumb-init` to install\ndumb-init, just like you'd install any other package.\n\n*Note:* Most distro-provided versions of dumb-init are not statically-linked,\nunlike the versions we provide (see the other options below). This is normally\nperfectly fine, but means that these versions of dumb-init generally won't work\nwhen copied to other Linux distros, unlike the statically-linked versions we\nprovide.\n\n\n### Option 2: Installing via an internal apt server (Debian/Ubuntu)\n\nIf you have an internal apt server, uploading the `.deb` to your server is the\nrecommended way to use `dumb-init`. In your Dockerfiles, you can simply\n`apt install dumb-init` and it will be available.\n\nDebian packages are available from the [GitHub Releases tab][gh-releases], or\nyou can run `make builddeb` yourself.\n\n\n### Option 3: Installing the `.deb` package manually (Debian/Ubuntu)\n\nIf you don't have an internal apt server, you can use `dpkg -i` to install the\n`.deb` package. You can choose how you get the `.deb` onto your container\n(mounting a directory or `wget`-ing it are some options).\n\nOne possibility is with the following commands in your Dockerfile:\n\n```Dockerfile\nRUN wget https://github.com/Yelp/dumb-init/releases/download/v1.2.5/dumb-init_1.2.5_amd64.deb\nRUN dpkg -i dumb-init_*.deb\n```\n\n\n### Option 4: Downloading the binary directly\n\nSince dumb-init is released as a statically-linked binary, you can usually just\nplop it into your images. Here's an example of doing that in a Dockerfile:\n\n```Dockerfile\nRUN wget -O /usr/local/bin/dumb-init https://github.com/Yelp/dumb-init/releases/download/v1.2.5/dumb-init_1.2.5_x86_64\nRUN chmod +x /usr/local/bin/dumb-init\n```\n\n\n### Option 5: Installing from PyPI\n\nThough `dumb-init` is written entirely in C, we also provide a Python package\nwhich compiles and installs the binary. It can be installed [from\nPyPI](https://pypi.python.org/pypi/dumb-init) using `pip`. You'll want to first\ninstall a C compiler (on Debian/Ubuntu, `apt-get install gcc` is sufficient),\nthen just `pip install dumb-init`.\n\nAs of 1.2.0, the package at PyPI is available as a pre-built wheel archive and does not\nneed to be compiled on common Linux distributions.\n\n\n## Usage\n\nOnce installed inside your Docker container, simply prefix your commands with\n`dumb-init` (and make sure that you're using [the recommended JSON\nsyntax][docker-cmd-json]).\n\nWithin a Dockerfile, it's a good practice to use dumb-init as your container's\nentrypoint. An \"entrypoint\" is a partial command that gets prepended to your\n`CMD` instruction, making it a great fit for dumb-init:\n\n```Dockerfile\n# Runs \"/usr/bin/dumb-init -- /my/script --with --args\"\nENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n\n# or if you use --rewrite or other cli flags\n# ENTRYPOINT [\"dumb-init\", \"--rewrite\", \"2:3\", \"--\"]\n\nCMD [\"/my/script\", \"--with\", \"--args\"]\n```\n\nIf you declare an entrypoint in a base image, any images that descend from it\ndon't need to also declare dumb-init. They can just set a `CMD` as usual.\n\nFor interactive one-off usage, you can just prepend it manually:\n\n    $ docker run my_container dumb-init python -c 'while True: pass'\n\nRunning this same command without `dumb-init` would result in being unable to\nstop the container without `SIGKILL`, but with `dumb-init`, you can send it\nmore humane signals like `SIGTERM`.\n\nIt's important that you use [the JSON syntax][docker-cmd-json] for `CMD` and\n`ENTRYPOINT`. Otherwise, Docker invokes a shell to run your command, resulting\nin the shell as PID 1 instead of dumb-init.\n\n\n### Using a shell for pre-start hooks\n\nOften containers want to do some pre-start work which can't be done during\nbuild time. For example, you might want to template out some config files based\non environment variables.\n\nThe best way to integrate that with dumb-init is like this:\n\n```Dockerfile\nENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\nCMD [\"bash\", \"-c\", \"do-some-pre-start-thing && exec my-server\"]\n```\n\nBy still using dumb-init as the entrypoint, you always have a proper init\nsystem in place.\n\nThe `exec` portion of the bash command is important because it [replaces the\nbash process][exec] with your server, so that the shell only exists momentarily\nat start.\n\n\n## Building dumb-init\n\nBuilding the dumb-init binary requires a working compiler and libc headers and\ndefaults to glibc.\n\n    $ make\n\n\n### Building with musl\n\nStatically compiled dumb-init is over 700KB due to glibc, but musl is now an\noption. On Debian/Ubuntu `apt-get install musl-tools` to install the source and\nwrappers, then just:\n\n    $ CC=musl-gcc make\n\nWhen statically compiled with musl the binary size is around 20KB.\n\n\n### Building the Debian package\n\nWe use the standard Debian conventions for specifying build dependencies (look\nin `debian/control`). An easy way to get started is to `apt-get install\nbuild-essential devscripts equivs`, and then `sudo mk-build-deps -i --remove`\nto install all of the missing build dependencies automatically. You can then\nuse `make builddeb` to build dumb-init Debian packages.\n\nIf you prefer an automated Debian package build using Docker, just run `make\nbuilddeb-docker`. This is easier, but requires you to have Docker running on\nyour machine.\n\n\n## See also\n\n* [Docker and the PID 1 zombie reaping problem (Phusion Blog)](https://blog.phusion.nl/2015/01/20/docker-and-the-pid-1-zombie-reaping-problem/)\n* [Trapping signals in Docker containers (@gchudnov)](https://medium.com/@gchudnov/trapping-signals-in-docker-containers-7a57fdda7d86)\n* [tini](https://github.com/krallin/tini), an alternative to dumb-init\n* [pid1](https://github.com/fpco/pid1), an alternative to dumb-init, written in Haskell\n\n\n[daemontools]: http://cr.yp.to/daemontools.html\n[docker-cmd-json]: https://docs.docker.com/engine/reference/builder/#run\n[docker]: https://www.docker.com/\n[exec]: https://en.wikipedia.org/wiki/Exec_(system_call)\n[gh-releases]: https://github.com/Yelp/dumb-init/releases\n[supervisord]: http://supervisord.org/\n[systemd]: https://wiki.freedesktop.org/www/Software/systemd/\n[sysvinit]: https://wiki.archlinux.org/index.php/SysVinit\n"
        },
        {
          "name": "VERSION",
          "type": "blob",
          "size": 0.005859375,
          "content": "1.2.5\n"
        },
        {
          "name": "VERSION.h",
          "type": "blob",
          "size": 0.1953125,
          "content": "// THIS FILE IS AUTOMATICALLY GENERATED\n// Run `make VERSION.h` to update it after modifying VERSION.\nunsigned char VERSION[] = {\n  0x31, 0x2e, 0x32, 0x2e, 0x35, 0x0a\n};\nunsigned int VERSION_len = 6;\n"
        },
        {
          "name": "ci",
          "type": "tree",
          "content": null
        },
        {
          "name": "circle.yml",
          "type": "blob",
          "size": 0.4599609375,
          "content": "machine:\n    services:\n        - docker\n\ndependencies:\n    # Without overriding, Circle CI infers that it should run `python setup.py\n    # install` on the host, which we don't want (instead we run all our tests\n    # in Docker containers).\n    #\n    # Overriding with an empty list or list with an empty string doesn't seem\n    # to work, so we use a little hackery.\n    override:\n        - /bin/true\n\ntest:\n    override:\n        - ci/circle:\n            parallel: true\n"
        },
        {
          "name": "debian",
          "type": "tree",
          "content": null
        },
        {
          "name": "dumb-init.c",
          "type": "blob",
          "size": 10.8525390625,
          "content": "/*\n * dumb-init is a simple wrapper program designed to run as PID 1 and pass\n * signals to its children.\n *\n * Usage:\n *   ./dumb-init python -c 'while True: pass'\n *\n * To get debug output on stderr, run with '-v'.\n */\n\n#include <assert.h>\n#include <errno.h>\n#include <getopt.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include \"VERSION.h\"\n\n#define PRINTERR(...) do { \\\n    fprintf(stderr, \"[dumb-init] \" __VA_ARGS__); \\\n} while (0)\n\n#define DEBUG(...) do { \\\n    if (debug) { \\\n        PRINTERR(__VA_ARGS__); \\\n    } \\\n} while (0)\n\n// Signals we care about are numbered from 1 to 31, inclusive.\n// (32 and above are real-time signals.)\n// TODO: this is likely not portable outside of Linux, or on strange architectures\n#define MAXSIG 31\n\n// Indices are one-indexed (signal 1 is at index 1). Index zero is unused.\n// User-specified signal rewriting.\nint signal_rewrite[MAXSIG + 1] = {[0 ... MAXSIG] = -1};\n// One-time ignores due to TTY quirks. 0 = no skip, 1 = skip the next-received signal.\nchar signal_temporary_ignores[MAXSIG + 1] = {[0 ... MAXSIG] = 0};\n\npid_t child_pid = -1;\nchar debug = 0;\nchar use_setsid = 1;\n\nint translate_signal(int signum) {\n    if (signum <= 0 || signum > MAXSIG) {\n        return signum;\n    } else {\n        int translated = signal_rewrite[signum];\n        if (translated == -1) {\n            return signum;\n        } else {\n            DEBUG(\"Translating signal %d to %d.\\n\", signum, translated);\n            return translated;\n        }\n    }\n}\n\nvoid forward_signal(int signum) {\n    signum = translate_signal(signum);\n    if (signum != 0) {\n        kill(use_setsid ? -child_pid : child_pid, signum);\n        DEBUG(\"Forwarded signal %d to children.\\n\", signum);\n    } else {\n        DEBUG(\"Not forwarding signal %d to children (ignored).\\n\", signum);\n    }\n}\n\n/*\n * The dumb-init signal handler.\n *\n * The main job of this signal handler is to forward signals along to our child\n * process(es). In setsid mode, this means signaling the entire process group\n * rooted at our child. In non-setsid mode, this is just signaling the primary\n * child.\n *\n * In most cases, simply proxying the received signal is sufficient. If we\n * receive a job control signal, however, we should not only forward it, but\n * also sleep dumb-init itself.\n *\n * This allows users to run foreground processes using dumb-init and to\n * control them using normal shell job control features (e.g. Ctrl-Z to\n * generate a SIGTSTP and suspend the process).\n *\n * The libc manual is useful:\n * https://www.gnu.org/software/libc/manual/html_node/Job-Control-Signals.html\n *\n*/\nvoid handle_signal(int signum) {\n    DEBUG(\"Received signal %d.\\n\", signum);\n\n    if (signal_temporary_ignores[signum] == 1) {\n        DEBUG(\"Ignoring tty hand-off signal %d.\\n\", signum);\n        signal_temporary_ignores[signum] = 0;\n    } else if (signum == SIGCHLD) {\n        int status, exit_status;\n        pid_t killed_pid;\n        while ((killed_pid = waitpid(-1, &status, WNOHANG)) > 0) {\n            if (WIFEXITED(status)) {\n                exit_status = WEXITSTATUS(status);\n                DEBUG(\"A child with PID %d exited with exit status %d.\\n\", killed_pid, exit_status);\n            } else {\n                assert(WIFSIGNALED(status));\n                exit_status = 128 + WTERMSIG(status);\n                DEBUG(\"A child with PID %d was terminated by signal %d.\\n\", killed_pid, exit_status - 128);\n            }\n\n            if (killed_pid == child_pid) {\n                forward_signal(SIGTERM);  // send SIGTERM to any remaining children\n                DEBUG(\"Child exited with status %d. Goodbye.\\n\", exit_status);\n                exit(exit_status);\n            }\n        }\n    } else {\n        forward_signal(signum);\n        if (signum == SIGTSTP || signum == SIGTTOU || signum == SIGTTIN) {\n            DEBUG(\"Suspending self due to TTY signal.\\n\");\n            kill(getpid(), SIGSTOP);\n        }\n    }\n}\n\nvoid print_help(char *argv[]) {\n    fprintf(stderr,\n        \"dumb-init v%.*s\"\n        \"Usage: %s [option] command [[arg] ...]\\n\"\n        \"\\n\"\n        \"dumb-init is a simple process supervisor that forwards signals to children.\\n\"\n        \"It is designed to run as PID1 in minimal container environments.\\n\"\n        \"\\n\"\n        \"Optional arguments:\\n\"\n        \"   -c, --single-child   Run in single-child mode.\\n\"\n        \"                        In this mode, signals are only proxied to the\\n\"\n        \"                        direct child and not any of its descendants.\\n\"\n        \"   -r, --rewrite s:r    Rewrite received signal s to new signal r before proxying.\\n\"\n        \"                        To ignore (not proxy) a signal, rewrite it to 0.\\n\"\n        \"                        This option can be specified multiple times.\\n\"\n        \"   -v, --verbose        Print debugging information to stderr.\\n\"\n        \"   -h, --help           Print this help message and exit.\\n\"\n        \"   -V, --version        Print the current version and exit.\\n\"\n        \"\\n\"\n        \"Full help is available online at https://github.com/Yelp/dumb-init\\n\",\n        VERSION_len, VERSION,\n        argv[0]\n    );\n}\n\nvoid print_rewrite_signum_help() {\n    fprintf(\n        stderr,\n        \"Usage: -r option takes <signum>:<signum>, where <signum> \"\n        \"is between 1 and %d.\\n\"\n        \"This option can be specified multiple times.\\n\"\n        \"Use --help for full usage.\\n\",\n        MAXSIG\n    );\n    exit(1);\n}\n\nvoid parse_rewrite_signum(char *arg) {\n    int signum, replacement;\n    if (\n        sscanf(arg, \"%d:%d\", &signum, &replacement) == 2 &&\n        (signum >= 1 && signum <= MAXSIG) &&\n        (replacement >= 0 && replacement <= MAXSIG)\n    ) {\n        signal_rewrite[signum] = replacement;\n    } else {\n        print_rewrite_signum_help();\n    }\n}\n\nvoid set_rewrite_to_sigstop_if_not_defined(int signum) {\n    if (signal_rewrite[signum] == -1) {\n        signal_rewrite[signum] = SIGSTOP;\n    }\n}\n\nchar **parse_command(int argc, char *argv[]) {\n    int opt;\n    struct option long_options[] = {\n        {\"help\",         no_argument,       NULL, 'h'},\n        {\"single-child\", no_argument,       NULL, 'c'},\n        {\"rewrite\",      required_argument, NULL, 'r'},\n        {\"verbose\",      no_argument,       NULL, 'v'},\n        {\"version\",      no_argument,       NULL, 'V'},\n        {NULL,                     0,       NULL,   0},\n    };\n    while ((opt = getopt_long(argc, argv, \"+hvVcr:\", long_options, NULL)) != -1) {\n        switch (opt) {\n            case 'h':\n                print_help(argv);\n                exit(0);\n            case 'v':\n                debug = 1;\n                break;\n            case 'V':\n                fprintf(stderr, \"dumb-init v%.*s\", VERSION_len, VERSION);\n                exit(0);\n            case 'c':\n                use_setsid = 0;\n                break;\n            case 'r':\n                parse_rewrite_signum(optarg);\n                break;\n            default:\n                exit(1);\n        }\n    }\n\n    if (optind >= argc) {\n        fprintf(\n            stderr,\n            \"Usage: %s [option] program [args]\\n\"\n            \"Try %s --help for full usage.\\n\",\n            argv[0], argv[0]\n        );\n        exit(1);\n    }\n\n    char *debug_env = getenv(\"DUMB_INIT_DEBUG\");\n    if (debug_env && strcmp(debug_env, \"1\") == 0) {\n        debug = 1;\n        DEBUG(\"Running in debug mode.\\n\");\n    }\n\n    char *setsid_env = getenv(\"DUMB_INIT_SETSID\");\n    if (setsid_env && strcmp(setsid_env, \"0\") == 0) {\n        use_setsid = 0;\n        DEBUG(\"Not running in setsid mode.\\n\");\n    }\n\n    if (use_setsid) {\n        set_rewrite_to_sigstop_if_not_defined(SIGTSTP);\n        set_rewrite_to_sigstop_if_not_defined(SIGTTOU);\n        set_rewrite_to_sigstop_if_not_defined(SIGTTIN);\n    }\n\n    return &argv[optind];\n}\n\n// A dummy signal handler used for signals we care about.\n// On the FreeBSD kernel, ignored signals cannot be waited on by `sigwait` (but\n// they can be on Linux). We must provide a dummy handler.\n// https://lists.freebsd.org/pipermail/freebsd-ports/2009-October/057340.html\nvoid dummy(int signum) {}\n\nint main(int argc, char *argv[]) {\n    char **cmd = parse_command(argc, argv);\n    sigset_t all_signals;\n    sigfillset(&all_signals);\n    sigprocmask(SIG_BLOCK, &all_signals, NULL);\n\n    int i = 0;\n    for (i = 1; i <= MAXSIG; i++) {\n        signal(i, dummy);\n    }\n\n    /*\n     * Detach dumb-init from controlling tty, so that the child's session can\n     * attach to it instead.\n     *\n     * We want the child to be able to be the session leader of the TTY so that\n     * it can do normal job control.\n     */\n    if (use_setsid) {\n        if (ioctl(STDIN_FILENO, TIOCNOTTY) == -1) {\n            DEBUG(\n                \"Unable to detach from controlling tty (errno=%d %s).\\n\",\n                errno,\n                strerror(errno)\n            );\n        } else {\n            /*\n             * When the session leader detaches from its controlling tty via\n             * TIOCNOTTY, the kernel sends SIGHUP and SIGCONT to the process\n             * group. We need to be careful not to forward these on to the\n             * dumb-init child so that it doesn't receive a SIGHUP and\n             * terminate itself (#136).\n             */\n            if (getsid(0) == getpid()) {\n                DEBUG(\"Detached from controlling tty, ignoring the first SIGHUP and SIGCONT we receive.\\n\");\n                signal_temporary_ignores[SIGHUP] = 1;\n                signal_temporary_ignores[SIGCONT] = 1;\n            } else {\n                DEBUG(\"Detached from controlling tty, but was not session leader.\\n\");\n            }\n        }\n    }\n\n    child_pid = fork();\n    if (child_pid < 0) {\n        PRINTERR(\"Unable to fork. Exiting.\\n\");\n        return 1;\n    } else if (child_pid == 0) {\n        /* child */\n        sigprocmask(SIG_UNBLOCK, &all_signals, NULL);\n        if (use_setsid) {\n            if (setsid() == -1) {\n                PRINTERR(\n                    \"Unable to setsid (errno=%d %s). Exiting.\\n\",\n                    errno,\n                    strerror(errno)\n                );\n                exit(1);\n            }\n\n            if (ioctl(STDIN_FILENO, TIOCSCTTY, 0) == -1) {\n                DEBUG(\n                    \"Unable to attach to controlling tty (errno=%d %s).\\n\",\n                    errno,\n                    strerror(errno)\n                );\n            }\n            DEBUG(\"setsid complete.\\n\");\n        }\n        execvp(cmd[0], &cmd[0]);\n\n        // if this point is reached, exec failed, so we should exit nonzero\n        PRINTERR(\"%s: %s\\n\", cmd[0], strerror(errno));\n        return 2;\n    } else {\n        /* parent */\n        DEBUG(\"Child spawned with PID %d.\\n\", child_pid);\n        if (chdir(\"/\") == -1) {\n             DEBUG(\"Unable to chdir(\\\"/\\\") (errno=%d %s)\\n\",\n                   errno,\n                   strerror(errno));\n        }\n        for (;;) {\n            int signum;\n            sigwait(&all_signals, &signum);\n            handle_signal(signum);\n        }\n    }\n}\n"
        },
        {
          "name": "pytest.ini",
          "type": "blob",
          "size": 0.021484375,
          "content": "[pytest]\ntimeout = 20\n"
        },
        {
          "name": "requirements-dev.txt",
          "type": "blob",
          "size": 0.212890625,
          "content": "pre-commit>=0.5.0\npytest\n# TODO: This pin is to work around an issue where the system pytest is too old.\n# We should fix this by not depending on the system pytest/python packages at\n# some point.\npytest-timeout<2.0.0\n"
        },
        {
          "name": "setup.py",
          "type": "blob",
          "size": 3.7587890625,
          "content": "import os.path\nimport subprocess\nimport tempfile\n\nfrom distutils.command.build import build as orig_build\nfrom distutils.core import Command\nfrom setuptools import Distribution\nfrom setuptools import Extension\nfrom setuptools import setup\nfrom setuptools.command.install import install as orig_install\n\n\ntry:\n    from wheel.bdist_wheel import bdist_wheel as _bdist_wheel\n\n    class bdist_wheel(_bdist_wheel):\n\n        def finalize_options(self):\n            _bdist_wheel.finalize_options(self)\n            # Mark us as not a pure python package\n            self.root_is_pure = False\n\n        def get_tag(self):\n            python, abi, plat = _bdist_wheel.get_tag(self)\n            # We don't contain any python source\n            python, abi = 'py2.py3', 'none'\n            return python, abi, plat\nexcept ImportError:\n    bdist_wheel = None\n\n\nclass ExeDistribution(Distribution):\n    c_executables = ()\n\n\nclass build(orig_build):\n    sub_commands = orig_build.sub_commands + [\n        ('build_cexe', None),\n    ]\n\n\nclass install(orig_install):\n    sub_commands = orig_install.sub_commands + [\n        ('install_cexe', None),\n    ]\n\n\nclass install_cexe(Command):\n    description = 'install C executables'\n    outfiles = ()\n\n    def initialize_options(self):\n        self.build_dir = self.install_dir = None\n\n    def finalize_options(self):\n        # this initializes attributes based on other commands' attributes\n        self.set_undefined_options('build', ('build_scripts', 'build_dir'))\n        self.set_undefined_options(\n            'install', ('install_scripts', 'install_dir'),\n        )\n\n    def run(self):\n\n        self.outfiles = self.copy_tree(self.build_dir, self.install_dir)\n\n    def get_outputs(self):\n        return self.outfiles\n\n\nclass build_cexe(Command):\n    description = 'build C executables'\n\n    def initialize_options(self):\n        self.build_scripts = None\n        self.build_temp = None\n\n    def finalize_options(self):\n        self.set_undefined_options(\n            'build',\n            ('build_scripts', 'build_scripts'),\n            ('build_temp', 'build_temp'),\n        )\n\n    def run(self):\n        # stolen and simplified from distutils.command.build_ext\n        from distutils.ccompiler import new_compiler\n\n        compiler = new_compiler(verbose=True)\n\n        print('supports -static... ', end='')\n        with tempfile.NamedTemporaryFile(mode='w', suffix='.c') as f:\n            f.write('int main(void){}\\n')\n            f.flush()\n            cmd = compiler.linker_exe + [f.name, '-static', '-o', os.devnull]\n            with open(os.devnull, 'wb') as devnull:\n                if not subprocess.call(cmd, stderr=devnull):\n                    print('yes')\n                    link_args = ['-static']\n                else:\n                    print('no')\n                    link_args = []\n\n        for exe in self.distribution.c_executables:\n            objects = compiler.compile(exe.sources, output_dir=self.build_temp)\n            compiler.link_executable(\n                objects,\n                exe.name,\n                output_dir=self.build_scripts,\n                extra_postargs=link_args,\n            )\n\n    def get_outputs(self):\n        return [\n            os.path.join(self.build_scripts, exe.name)\n            for exe in self.distribution.c_executables\n        ]\n\n\nsetup(\n    name='dumb-init',\n    description='Simple wrapper script which proxies signals to a child',\n    version=open('VERSION').read().strip(),\n    author='Yelp',\n    url='https://github.com/Yelp/dumb-init/',\n    platforms='linux',\n    packages=[],\n    c_executables=[Extension('dumb-init', ['dumb-init.c'])],\n    cmdclass={\n        'bdist_wheel': bdist_wheel,\n        'build': build,\n        'build_cexe': build_cexe,\n        'install': install,\n        'install_cexe': install_cexe,\n    },\n    distclass=ExeDistribution,\n)\n"
        },
        {
          "name": "testing",
          "type": "tree",
          "content": null
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "tox.ini",
          "type": "blob",
          "size": 0.4990234375,
          "content": "[tox]\nenvlist = py38,gcov\n\n[testenv]\ndeps = -r{toxinidir}/requirements-dev.txt\ncommands =\n    pytest\n\n[testenv:gcov]\nskip_install = True\nbasepython = /usr/bin/python3.8\ncommands =\n    {toxinidir}/ci/gcov-build {envbindir}\n    {[testenv]commands}\n    {toxinidir}/ci/gcov-report\n\n[testenv:pre-commit]\nbasepython = /usr/bin/python3.8\ncommands = pre-commit {posargs:run --all-files}\n\n[flake8]\nmax-line-length = 119\n\n[pep8]\n# autopep8 will rewrite lines to be shorter, even though we raised the length\nignore = E501\n"
        }
      ]
    }
  ]
}