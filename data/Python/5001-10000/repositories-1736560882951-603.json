{
  "metadata": {
    "timestamp": 1736560882951,
    "page": 603,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjYxMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "longld/peda",
      "stars": 5928,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.2265625,
          "content": "*.py[co]\n\n# Packages\n*.egg\n*.egg-info\ndist\nbuild\neggs\nparts\nbin\nvar\nsdist\ndevelop-eggs\n.installed.cfg\n\n# Installer logs\npip-log.txt\n\n# Unit test / coverage reports\n.coverage\n.tox\n\n#Translations\n*.mo\n\n#Mr Developer\n.mr.developer.cfg\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 0.1533203125,
          "content": "This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nhttp://creativecommons.org/licenses/by-nc-sa/3.0/\n"
        },
        {
          "name": "README",
          "type": "blob",
          "size": 1.134765625,
          "content": "PEDA - Python Exploit Development Assistance for GDB\n\nVersion: 1.0\n\nRelease: special public release, Black Hat USA 2012\n\n0. Credits\n    - Huy Phan (pdah) for reviewing code\n\n1. Introduction\nPEDA is a Python GDB script with many handy commands to help speed up \nexploit development process on Linux/Unix. It is also a framework for \nwriting custom interactive Python GDB commands.\n\n2. Requirements\n    - PEDA 1.0 is only support Linux\n    - GDB 7.x\n    - Python 2.6+\n    - Utilities: nasm, readelf, objdump\n\n3. Installation\n    - Download\n        $ wget http://ropshell.com/peda/peda.tar.gz\n    - Unpack to HOME directory\n        $ tar zxvf peda.tar.gz\n    - Append a line to ~/.gdbinit to load PEDA when GDB starts\n        $ echo \"source ~/peda/peda.py\" >> ~/.gdbinit\n\n4. Usage\n    - List of available commands:\n        gdb-peda$ peda help\n\n    - Search for some commands:\n        gdb-peda$ apropos <keyword>\n        gdb-peda$ help <keyword>\n\n    - Get usage manual of specific command:\n        gdb-peda$ phelp <command>\n        gdb-peda$ help <command>\n\n    - Get/set config option:\n        gdb-peda$ pshow option\n        gdb-peda$ pset option <name> <value>\n\n\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 1.8935546875,
          "content": "peda\n====\n\nPEDA - Python Exploit Development Assistance for GDB\n\n## Key Features:\n* Enhance the display of gdb: colorize and display disassembly codes, registers, memory information during debugging.\n* Add commands to support debugging and exploit development (for a full list of commands use `peda help`):\n  * `aslr` -- Show/set ASLR setting of GDB\n  * `checksec` -- Check for various security options of binary\n  * `dumpargs` -- Display arguments passed to a function when stopped at a call instruction\n  * `dumprop` -- Dump all ROP gadgets in specific memory range\n  * `elfheader` -- Get headers information from debugged ELF file\n  * `elfsymbol` -- Get non-debugging symbol information from an ELF file\n  * `lookup` -- Search for all addresses/references to addresses which belong to a memory range\n  * `patch` -- Patch memory start at an address with string/hexstring/int\n  * `pattern` -- Generate, search, or write a cyclic pattern to memory\n  * `procinfo` -- Display various info from /proc/pid/\n  * `pshow` -- Show various PEDA options and other settings\n  * `pset` -- Set various PEDA options and other settings\n  * `readelf` -- Get headers information from an ELF file\n  * `ropgadget` -- Get common ROP gadgets of binary or library\n  * `ropsearch` -- Search for ROP gadgets in memory\n  * `searchmem|find` -- Search for a pattern in memory; support regex search\n  * `shellcode` -- Generate or download common shellcodes.\n  * `skeleton` -- Generate python exploit code template\n  * `vmmap` -- Get virtual mapping address ranges of section(s) in debugged process\n  * `xormem` -- XOR a memory region with a key\n\n## Installation\n\n    git clone https://github.com/longld/peda.git ~/peda\n    echo \"source ~/peda/peda.py\" >> ~/.gdbinit\n    echo \"DONE! debug your program with gdb and enjoy\"\n\n## Screenshot\n![start](http://i.imgur.com/P1BF5mp.png)\n\n![pattern arg](http://i.imgur.com/W97OWRC.png)\n\n![patts](http://i.imgur.com/Br24IpC.png)\n"
        },
        {
          "name": "lib",
          "type": "tree",
          "content": null
        },
        {
          "name": "peda.py",
          "type": "blob",
          "size": 194.5703125,
          "content": "#       PEDA - Python Exploit Development Assistance for GDB\n#\n#       Copyright (C) 2012 Long Le Dinh <longld at vnsecurity.net>\n#\n#       License: see LICENSE file for details\n#\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport re\nimport os\nimport sys\nimport shlex\nimport string\nimport time\nimport signal\nimport traceback\nimport codecs\n\n# point to absolute path of peda.py\nPEDAFILE = os.path.abspath(os.path.expanduser(__file__))\nif os.path.islink(PEDAFILE):\n    PEDAFILE = os.readlink(PEDAFILE)\nsys.path.insert(0, os.path.dirname(PEDAFILE) + \"/lib/\")\n\n# Use six library to provide Python 2/3 compatibility\nimport six\nfrom six.moves import range\nfrom six.moves import input\ntry:\n    import six.moves.cPickle as pickle\nexcept ImportError:\n    import pickle\n\n\n\nfrom skeleton import *\nfrom shellcode import *\nfrom utils import *\nimport config\nfrom nasm import *\n\nif sys.version_info.major == 3:\n    from urllib.request import urlopen\n    from urllib.parse import urlencode\n    pyversion = 3\nelse:\n    from urllib import urlopen\n    from urllib import urlencode\n    pyversion = 2\n\nREGISTERS = {\n    8 : [\"al\", \"ah\", \"bl\", \"bh\", \"cl\", \"ch\", \"dl\", \"dh\"],\n    16: [\"ax\", \"bx\", \"cx\", \"dx\"],\n    32: [\"eax\", \"ebx\", \"ecx\", \"edx\", \"esi\", \"edi\", \"ebp\", \"esp\", \"eip\"],\n    64: [\"rax\", \"rbx\", \"rcx\", \"rdx\", \"rsi\", \"rdi\", \"rbp\", \"rsp\", \"rip\",\n         \"r8\", \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\"]\n}\n\n###########################################################################\nclass PEDA(object):\n    \"\"\"\n    Class for actual functions of PEDA commands\n    \"\"\"\n    def __init__(self):\n        self.SAVED_COMMANDS = {} # saved GDB user's commands\n\n\n    ####################################\n    #   GDB Interaction / Misc Utils   #\n    ####################################\n    def execute(self, gdb_command):\n        \"\"\"\n        Wrapper for gdb.execute, catch the exception so it will not stop python script\n\n        Args:\n            - gdb_command (String)\n\n        Returns:\n            - True if execution succeed (Bool)\n        \"\"\"\n        try:\n            gdb.execute(gdb_command)\n            return True\n        except Exception as e:\n            if config.Option.get(\"debug\") == \"on\":\n                msg('Exception (%s): %s' % (gdb_command, e), \"red\")\n                traceback.print_exc()\n            return False\n\n    def execute_redirect(self, gdb_command, silent=False):\n        \"\"\"\n        Execute a gdb command and capture its output\n\n        Args:\n            - gdb_command (String)\n            - silent: discard command's output, redirect to /dev/null (Bool)\n\n        Returns:\n            - output of command (String)\n        \"\"\"\n        result = None\n        #init redirection\n        if silent:\n            logfd = open(os.path.devnull, \"r+\")\n        else:\n            logfd = tmpfile()\n        logname = logfd.name\n        gdb.execute('set logging off') # prevent nested call\n        gdb.execute('set height 0') # disable paging\n        gdb.execute('set logging file %s' % logname)\n        gdb.execute('set logging overwrite on')\n        gdb.execute('set logging redirect on')\n        gdb.execute('set logging on')\n        try:\n            gdb.execute(gdb_command)\n            gdb.flush()\n            gdb.execute('set logging off')\n            if not silent:\n                logfd.flush()\n                result = logfd.read()\n            logfd.close()\n        except Exception as e:\n            gdb.execute('set logging off') #to be sure\n            if config.Option.get(\"debug\") == \"on\":\n                msg('Exception (%s): %s' % (gdb_command, e), \"red\")\n                traceback.print_exc()\n            logfd.close()\n        if config.Option.get(\"verbose\") == \"on\":\n            msg(result)\n        return result\n\n    def parse_and_eval(self, exp):\n        \"\"\"\n        Work around implementation for gdb.parse_and_eval with enhancements\n\n        Args:\n            - exp: expression to evaluate (String)\n\n        Returns:\n            - value of expression\n        \"\"\"\n\n        regs = sum(REGISTERS.values(), [])\n        for r in regs:\n            if \"$\"+r not in exp and \"e\"+r not in exp and \"r\"+r not in exp:\n                exp = exp.replace(r, \"$%s\" % r)\n\n        p = re.compile(\"(.*)\\[(.*)\\]\") # DWORD PTR [esi+eax*1]\n        matches = p.search(exp)\n        if not matches:\n            p = re.compile(\"(.*).s:(0x.*)\") # DWORD PTR ds:0xdeadbeef\n            matches = p.search(exp)\n\n        if matches:\n            mod = \"w\"\n            if \"BYTE\" in matches.group(1):\n                mod = \"b\"\n            elif \"QWORD\" in matches.group(1):\n                mod = \"g\"\n            elif \"DWORD\" in matches.group(1):\n                mod = \"w\"\n            elif \"WORD\" in matches.group(1):\n                mod = \"h\"\n\n            out = self.execute_redirect(\"x/%sx %s\" % (mod, matches.group(2)))\n            if not out:\n                return None\n            else:\n                return out.split(\":\\t\")[-1].strip()\n\n        else:\n            out = self.execute_redirect(\"print %s\" % exp)\n        if not out:\n            return None\n        else:\n            out = gdb.history(0).__str__()\n            out = out.encode('ascii', 'ignore')\n            out = decode_string_escape(out)\n            return out.strip()\n\n    def string_to_argv(self, str):\n        \"\"\"\n        Convert a string to argv list, pre-processing register and variable values\n\n        Args:\n            - str: input string (String)\n\n        Returns:\n            - argv list (List)\n        \"\"\"\n        try:\n            str = str.encode('ascii', 'ignore')\n        except:\n            pass\n        args = list(map(lambda x: decode_string_escape(x), shlex.split(str.decode())))\n        # need more processing here\n        for idx, a in enumerate(args):\n            a = a.strip(\",\")\n            if a.startswith(\"$\"): # try to get register/variable value\n                v = self.parse_and_eval(a)\n                if v != None and v != \"void\":\n                    if v.startswith(\"0x\"): # int\n                        args[idx] = v.split()[0] # workaround for 0xdeadbeef <symbol+x>\n                    else: # string, complex data\n                        args[idx] = v\n            elif a.startswith(\"+\"): # relative value to prev arg\n                adder = to_int(self.parse_and_eval(a[1:]))\n                if adder is not None:\n                    args[idx] = \"%s\" % to_hex(to_int(args[idx-1]) + adder)\n            elif is_math_exp(a):\n                try:\n                    v = eval(\"%s\" % a)\n                    # XXX hack to avoid builtin functions/types\n                    if not isinstance(v, six.string_types + six.integer_types):\n                        continue\n                    args[idx] = \"%s\" % (to_hex(v) if to_int(v) != None else v)\n                except:\n                    pass\n        if config.Option.get(\"verbose\") == \"on\":\n            msg(args)\n        return args\n\n\n    ################################\n    #   GDB User-Defined Helpers   #\n    ################################\n    def save_user_command(self, cmd):\n        \"\"\"\n        Save user-defined command and deactivate it\n\n        Args:\n            - cmd: user-defined command (String)\n\n        Returns:\n            - True if success to save (Bool)\n        \"\"\"\n        commands = self.execute_redirect(\"show user %s\" % cmd)\n        if not commands:\n            return False\n\n        commands = \"\\n\".join(commands.splitlines()[1:])\n        commands = \"define %s\\n\" % cmd + commands + \"end\\n\"\n        self.SAVED_COMMANDS[cmd] = commands\n        tmp = tmpfile()\n        tmp.write(\"define %s\\nend\\n\" % cmd)\n        tmp.flush()\n        result = self.execute(\"source %s\" % tmp.name)\n        tmp.close()\n        return result\n\n    def define_user_command(self, cmd, code):\n        \"\"\"\n        Define a user-defined command, overwrite the old content\n\n        Args:\n            - cmd: user-defined command (String)\n            - code: gdb script code to append (String)\n\n        Returns:\n            - True if success to define (Bool)\n        \"\"\"\n        commands = \"define %s\\n\" % cmd + code + \"\\nend\\n\"\n        tmp = tmpfile(is_binary_file=False)\n        tmp.write(commands)\n        tmp.flush()\n        result = self.execute(\"source %s\" % tmp.name)\n        tmp.close()\n        return result\n\n    def append_user_command(self, cmd, code):\n        \"\"\"\n        Append code to a user-defined command, define new command if not exist\n\n        Args:\n            - cmd: user-defined command (String)\n            - code: gdb script code to append (String)\n\n        Returns:\n            - True if success to append (Bool)\n        \"\"\"\n\n        commands = self.execute_redirect(\"show user %s\" % cmd)\n        if not commands:\n            return self.define_user_command(cmd, code)\n        # else\n        commands = \"\\n\".join(commands.splitlines()[1:])\n        if code in commands:\n            return True\n\n        commands = \"define %s\\n\" % cmd + commands + code + \"\\nend\\n\"\n        tmp = tmpfile()\n        tmp.write(commands)\n        tmp.flush()\n        result = self.execute(\"source %s\" % tmp.name)\n        tmp.close()\n        return result\n\n    def restore_user_command(self, cmd):\n        \"\"\"\n        Restore saved user-defined command\n\n        Args:\n            - cmd: user-defined command (String)\n\n        Returns:\n            - True if success to restore (Bool)\n        \"\"\"\n        if cmd == \"all\":\n            commands = \"\\n\".join(self.SAVED_COMMANDS.values())\n            self.SAVED_COMMANDS = {}\n        else:\n            if cmd not in self.SAVED_COMMANDS:\n                return False\n            else:\n                commands = self.SAVED_COMMANDS[cmd]\n                self.SAVED_COMMANDS.pop(cmd)\n        tmp = tmpfile()\n        tmp.write(commands)\n        tmp.flush()\n        result = self.execute(\"source %s\" % tmp.name)\n        tmp.close()\n\n        return result\n\n    def run_gdbscript_code(self, code):\n        \"\"\"\n        Run basic gdbscript code as it is typed in interactively\n\n        Args:\n            - code: gdbscript code, lines are splitted by \"\\n\" or \";\" (String)\n\n        Returns:\n            - True if success to run (Bool)\n        \"\"\"\n        tmp = tmpfile()\n        tmp.write(code.replace(\";\", \"\\n\"))\n        tmp.flush()\n        result = self.execute(\"source %s\" % tmp.name)\n        tmp.close()\n        return result\n\n    #########################\n    #   Debugging Helpers   #\n    #########################\n    @memoized\n    def is_target_remote(self):\n        \"\"\"\n        Check if current target is remote\n\n        Returns:\n            - True if target is remote (Bool)\n        \"\"\"\n        out = self.execute_redirect(\"info program\")\n        if out and \"serial line\" in out: # remote target\n            return True\n\n        return False\n\n    @memoized\n    def getfile(self):\n        \"\"\"\n        Get exec file of debugged program\n\n        Returns:\n            - full path to executable file (String)\n        \"\"\"\n        result = None\n        out = self.execute_redirect('info files')\n        if out and '\"' in out:\n            p = re.compile(\".*exec file:\\s*`(.*)'\")\n            m = p.search(out)\n            if m:\n                result = m.group(1)\n            else: # stripped file, get symbol file\n                p = re.compile(\"Symbols from \\\"([^\\\"]*)\")\n                m = p.search(out)\n                if m:\n                    result = m.group(1)\n\n        return result\n\n    def get_status(self):\n        \"\"\"\n        Get execution status of debugged program\n\n        Returns:\n            - current status of program (String)\n                STOPPED - not being run\n                BREAKPOINT - breakpoint hit\n                SIGXXX - stopped by signal XXX\n                UNKNOWN - unknown, not implemented\n        \"\"\"\n        status = \"UNKNOWN\"\n        out = self.execute_redirect(\"info program\")\n        for line in out.splitlines():\n            if line.startswith(\"It stopped\"):\n                if \"signal\" in line: # stopped by signal\n                    status = line.split(\"signal\")[1].split(\",\")[0].strip()\n                    break\n                if \"breakpoint\" in line: # breakpoint hit\n                    status = \"BREAKPOINT\"\n                    break\n            if \"not being run\" in line:\n                status = \"STOPPED\"\n                break\n        return status\n\n    @memoized\n    def getpid(self):\n        \"\"\"\n        Get PID of the debugged process\n\n        Returns:\n            - pid (Int)\n        \"\"\"\n\n        out = None\n        status = self.get_status()\n        if not status or status == \"STOPPED\":\n            return None\n        pid = gdb.selected_inferior().pid\n        return int(pid) if pid else None\n\n    def getos(self):\n        \"\"\"\n        Get running OS info\n\n        Returns:\n            - os version (String)\n        \"\"\"\n        # TODO: get remote os by calling uname()\n        return os.uname()[0]\n\n    @memoized\n    def getarch(self):\n        \"\"\"\n        Get architecture of debugged program\n\n        Returns:\n            - tuple of architecture info (arch (String), bits (Int))\n        \"\"\"\n        arch = \"unknown\"\n        bits = 32\n        out = self.execute_redirect('maintenance info sections ?').splitlines()\n        for line in out:\n            if \"file type\" in line:\n                arch = line.split()[-1][:-1]\n                break\n        if \"64\" in arch:\n            bits = 64\n        return (arch, bits)\n\n    def intsize(self):\n        \"\"\"\n        Get dword size of debugged program\n\n        Returns:\n            - size (Int)\n                + intsize = 4/8 for 32/64-bits arch\n        \"\"\"\n\n        (arch, bits) = self.getarch()\n        return bits // 8\n\n    def getregs(self, reglist=None):\n        \"\"\"\n        Get value of some or all registers\n\n        Returns:\n            - dictionary of {regname(String) : value(Int)}\n        \"\"\"\n        if reglist:\n            reglist = reglist.replace(\",\", \" \")\n        else:\n            reglist = \"\"\n        regs = self.execute_redirect(\"info registers %s\" % reglist)\n        if not regs:\n            return None\n\n        result = {}\n        if regs:\n            for r in regs.splitlines():\n                r = r.split()\n                if len(r) > 1 and to_int(r[1]) is not None:\n                    result[r[0]] = to_int(r[1])\n\n        return result\n\n    def getreg(self, register):\n        \"\"\"\n        Get value of a specific register\n\n        Args:\n            - register: register name (String)\n\n        Returns:\n            - register value (Int)\n        \"\"\"\n        r = register.lower()\n        regs = self.execute_redirect(\"info registers %s\" % r)\n        if regs:\n            regs = regs.splitlines()\n            if len(regs) > 1:\n                return None\n            else:\n                result = to_int(regs[0].split()[1])\n                return result\n\n        return None\n\n    def set_breakpoint(self, location, temp=0, hard=0):\n        \"\"\"\n        Wrapper for GDB break command\n            - location: target function or address (String ot Int)\n\n        Returns:\n            - True if can set breakpoint\n        \"\"\"\n        cmd = \"break\"\n        if hard:\n            cmd = \"h\" + cmd\n        if temp:\n            cmd = \"t\" + cmd\n\n        if to_int(location) is not None:\n            return peda.execute(\"%s *0x%x\" % (cmd, to_int(location)))\n        else:\n            return peda.execute(\"%s %s\" % (cmd, location))\n\n    def get_breakpoint(self, num):\n        \"\"\"\n        Get info of a specific breakpoint\n        TODO: support catchpoint, watchpoint\n\n        Args:\n            - num: breakpoint number\n\n        Returns:\n            - tuple (Num(Int), Type(String), Disp(Bool), Enb(Bool), Address(Int), What(String), commands(String))\n        \"\"\"\n        out = self.execute_redirect(\"info breakpoints %d\" % num)\n        if not out or \"No breakpoint\" in out:\n            return None\n\n        lines = out.splitlines()[1:]\n        # breakpoint regex\n        p = re.compile(\"^(\\d*)\\s*(.*breakpoint)\\s*(keep|del)\\s*(y|n)\\s*(0x[^ ]*)\\s*(.*)\")\n        m = p.match(lines[0])\n        if not m:\n            # catchpoint/watchpoint regex\n            p = re.compile(\"^(\\d*)\\s*(.*point)\\s*(keep|del)\\s*(y|n)\\s*(.*)\")\n            m = p.match(lines[0])\n            if not m:\n                return None\n            else:\n                (num, type, disp, enb, what) = m.groups()\n                addr = ''\n        else:\n            (num, type, disp, enb, addr, what) = m.groups()\n\n        disp = True if disp == \"keep\" else False\n        enb = True if enb == \"y\" else False\n        addr = to_int(addr)\n        m = re.match(\"in.*at(.*:\\d*)\", what)\n        if m:\n            what = m.group(1)\n        else:\n            if addr: # breakpoint\n                what = \"\"\n\n        commands = \"\"\n        if len(lines) > 1:\n            for line in lines[1:]:\n                if \"already hit\" in line: continue\n                commands += line + \"\\n\"\n\n        return (num, type, disp, enb, addr, what, commands.rstrip())\n\n    def get_breakpoints(self):\n        \"\"\"\n        Get list of current breakpoints\n\n        Returns:\n            - list of tuple (Num(Int), Type(String), Disp(Bool), Nnb(Bool), Address(Int), commands(String))\n        \"\"\"\n        result = []\n        out = self.execute_redirect(\"info breakpoints\")\n        if not out:\n            return []\n\n        bplist = []\n        for line in out.splitlines():\n            m = re.match(\"^(\\d*).*\", line)\n            if m and to_int(m.group(1)):\n                bplist += [to_int(m.group(1))]\n\n        for num in bplist:\n            r = self.get_breakpoint(num)\n            if r:\n                result += [r]\n        return result\n\n    def save_breakpoints(self, filename):\n        \"\"\"\n        Save current breakpoints to file as a script\n\n        Args:\n            - filename: target file (String)\n\n        Returns:\n            - True if success to save (Bool)\n        \"\"\"\n        # use built-in command for gdb 7.2+\n        result = self.execute_redirect(\"save breakpoints %s\" % filename)\n        if result == '':\n            return True\n\n        bplist = self.get_breakpoints()\n        if not bplist:\n            return False\n\n        try:\n            fd = open(filename, \"w\")\n            for (num, type, disp, enb, addr, what, commands) in bplist:\n                m = re.match(\"(.*)point\", type)\n                if m:\n                    cmd = m.group(1).split()[-1]\n                else:\n                    cmd = \"break\"\n                if \"hw\" in type and cmd == \"break\":\n                    cmd = \"h\" + cmd\n                if \"read\" in type:\n                    cmd = \"r\" + cmd\n                if \"acc\" in type:\n                    cmd = \"a\" + cmd\n\n                if not disp:\n                    cmd = \"t\" + cmd\n                if what:\n                    location = what\n                else:\n                    location = \"*0x%x\" % addr\n                text = \"%s %s\" % (cmd, location)\n                if commands:\n                    if \"stop only\" not in commands:\n                        text += \"\\ncommands\\n%s\\nend\" % commands\n                    else:\n                        text += commands.split(\"stop only\", 1)[1]\n                fd.write(text + \"\\n\")\n            fd.close()\n            return True\n        except:\n            return False\n\n    def get_config_filename(self, name):\n        filename = peda.getfile()\n        if not filename:\n            filename = peda.getpid()\n            if not filename:\n                filename = 'unknown'\n\n        filename = os.path.basename(\"%s\" % filename)\n        tmpl_name = config.Option.get(name)\n        if tmpl_name:\n            return tmpl_name.replace(\"#FILENAME#\", filename)\n        else:\n            return \"peda-%s-%s\" % (name, filename)\n\n    def save_session(self, filename=None):\n        \"\"\"\n        Save current working gdb session to file as a script\n\n        Args:\n            - filename: target file (String)\n\n        Returns:\n            - True if success to save (Bool)\n        \"\"\"\n        session = \"\"\n        if not filename:\n            filename = self.get_config_filename(\"session\")\n\n        # exec-wrapper\n        out = self.execute_redirect(\"show exec-wrapper\")\n        wrapper = out.split('\"')[1]\n        if wrapper:\n            session += \"set exec-wrapper %s\\n\" % wrapper\n\n        try:\n            # save breakpoints\n            self.save_breakpoints(filename)\n            fd = open(filename, \"a+\")\n            fd.write(\"\\n\" + session)\n            fd.close()\n            return True\n        except:\n            return False\n\n    def restore_session(self, filename=None):\n        \"\"\"\n        Restore previous saved working gdb session from file\n\n        Args:\n            - filename: source file (String)\n\n        Returns:\n            - True if success to restore (Bool)\n        \"\"\"\n        if not filename:\n            filename = self.get_config_filename(\"session\")\n\n        # temporarily save and clear breakpoints\n        tmp = tmpfile()\n        self.save_breakpoints(tmp.name)\n        self.execute(\"delete\")\n        result = self.execute(\"source %s\" % filename)\n        if not result:\n            self.execute(\"source %s\" % tmp.name)\n        tmp.close()\n        return result\n\n    @memoized\n    def assemble(self, asmcode, bits=None):\n        \"\"\"\n        Assemble ASM instructions using NASM\n            - asmcode: input ASM instructions, multiple instructions are separated by \";\" (String)\n\n        Returns:\n            - bin code (raw bytes)\n        \"\"\"\n        if bits is None:\n            (arch, bits) = self.getarch()\n        return Nasm.assemble(asmcode, bits)\n\n    def disassemble(self, *arg):\n        \"\"\"\n        Wrapper for disassemble command\n            - arg: args for disassemble command\n\n        Returns:\n            - text code (String)\n        \"\"\"\n        code = \"\"\n        modif = \"\"\n        arg = list(arg)\n        if len(arg) > 1:\n            if \"/\" in arg[0]:\n                modif = arg[0]\n                arg = arg[1:]\n        if len(arg) == 1 and to_int(arg[0]) != None:\n            arg += [to_hex(to_int(arg[0]) + 32)]\n\n        self.execute(\"set disassembly-flavor intel\")\n        out = self.execute_redirect(\"disassemble %s %s\" % (modif, \",\".join(arg)))\n        if not out:\n            return None\n        else:\n            code = out\n\n        return code\n\n    @memoized\n    def prev_inst(self, address, count=1):\n        \"\"\"\n        Get previous instructions at an address\n\n        Args:\n            - address: address to get previous instruction (Int)\n            - count: number of instructions to read (Int)\n\n        Returns:\n            - list of tuple (address(Int), code(String))\n        \"\"\"\n        result = []\n        backward = 64+16*count\n        for i in range(backward):\n            if self.getpid() and not self.is_address(address-backward+i):\n                continue\n\n            code = self.execute_redirect(\"disassemble %s, %s\" % (to_hex(address-backward+i), to_hex(address+1)))\n            if code and (\"%x\" % address) in code:\n                lines = code.strip().splitlines()[1:-1]\n                if len(lines) > count and \"(bad)\" not in \" \".join(lines):\n                    for line in lines[-count-1:-1]:\n                        (addr, code) = line.split(\":\", 1)\n                        addr = re.search(\"(0x[^ ]*)\", addr).group(1)\n                        result += [(to_int(addr), code)]\n                    return result\n        return None\n\n    @memoized\n    def current_inst(self, address):\n        \"\"\"\n        Parse instruction at an address\n\n        Args:\n            - address: address to get next instruction (Int)\n\n        Returns:\n            - tuple of (address(Int), code(String))\n        \"\"\"\n        out = self.execute_redirect(\"x/i 0x%x\" % address)\n        if not out:\n            return None\n\n        (addr, code) = out.split(\":\", 1)\n        addr = re.search(\"(0x[^ ]*)\", addr).group(1)\n        addr = to_int(addr)\n        code = code.strip()\n\n        return (addr, code)\n\n    @memoized\n    def next_inst(self, address, count=1):\n        \"\"\"\n        Get next instructions at an address\n\n        Args:\n            - address: address to get next instruction (Int)\n            - count: number of instructions to read (Int)\n\n        Returns:\n            - - list of tuple (address(Int), code(String))\n        \"\"\"\n        result = []\n        code = self.execute_redirect(\"x/%di 0x%x\" % (count+1, address))\n        if not code:\n            return None\n\n        lines = code.strip().splitlines()\n        for i in range(1, count+1):\n            (addr, code) = lines[i].split(\":\", 1)\n            addr = re.search(\"(0x[^ ]*)\", addr).group(1)\n            result += [(to_int(addr), code)]\n        return result\n\n    @memoized\n    def disassemble_around(self, address, count=8):\n        \"\"\"\n        Disassemble instructions nearby current PC or an address\n\n        Args:\n            - address: start address to disassemble around (Int)\n            - count: number of instructions to disassemble\n\n        Returns:\n            - text code (String)\n        \"\"\"\n        count = min(count, 256)\n        pc = address\n        if pc is None:\n            return None\n\n        # check if address is reachable\n        if not self.execute_redirect(\"x/x 0x%x\" % pc):\n            return None\n\n        prev_code = self.prev_inst(pc, count//2-1)\n        if prev_code:\n            start = prev_code[0][0]\n        else:\n            start = pc\n        if start == pc:\n            count = count//2\n\n        code = self.execute_redirect(\"x/%di 0x%x\" % (count, start))\n        if \"0x%x\" % pc not in code:\n            code = self.execute_redirect(\"x/%di 0x%x\" % (count//2, pc))\n\n        return code.rstrip()\n\n    @memoized\n    def xrefs(self, search=\"\", filename=None):\n        \"\"\"\n        Search for all call references or data access to a function/variable\n\n        Args:\n            - search: function or variable to search for (String)\n            - filename: binary/library to search (String)\n\n        Returns:\n            - list of tuple (address(Int), asm instruction(String))\n        \"\"\"\n        result = []\n        if not filename:\n            filename = self.getfile()\n\n        if not filename:\n            return None\n        vmap = self.get_vmmap(filename)\n        elfbase = vmap[0][0] if vmap else 0\n\n        if to_int(search) is not None:\n            search = \"%x\" % to_int(search)\n\n        search_data = 1\n        if search == \"\":\n            search_data = 0\n\n        out = execute_external_command(\"%s -M intel -z --prefix-address -d '%s' | grep '%s'\" % (config.OBJDUMP, filename, search))\n\n        for line in out.splitlines():\n            if not line: continue\n            addr = to_int(\"0x\" + line.split()[0].strip())\n            if not addr: continue\n\n            # update with runtime values\n            if addr < elfbase:\n                addr += elfbase\n            out = self.execute_redirect(\"x/i 0x%x\" % addr)\n            if out:\n                line = out\n                p = re.compile(\"\\s*(0x[^ ]*).*?:\\s*([^ ]*)\\s*(.*)\")\n            else:\n                p = re.compile(\"(.*?)\\s*<.*?>\\s*([^ ]*)\\s*(.*)\")\n\n            m = p.search(line)\n            if m:\n                (address, opcode, opers) = m.groups()\n                if \"call\" in opcode and search in opers:\n                    result += [(addr, line.strip())]\n                if search_data:\n                     if \"mov\" in opcode and search in opers:\n                         result += [(addr, line.strip())]\n\n        return result\n\n    def _get_function_args_32(self, code, argc=None):\n        \"\"\"\n        Guess the number of arguments passed to a function - i386\n        \"\"\"\n        if not argc:\n            argc = 0\n            p = re.compile(\".*mov.*\\[esp(.*)\\],\")\n            matches = p.findall(code)\n            if matches:\n                l = len(matches)\n                for v in matches:\n                    if v.startswith(\"+\"):\n                        offset = to_int(v[1:])\n                        if offset is not None and (offset//4) > l:\n                            continue\n                    argc += 1\n            else: # try with push style\n                argc = code.count(\"push\")\n\n        argc = min(argc, 6)\n        if argc == 0:\n            return []\n\n        args = []\n        sp = self.getreg(\"sp\")\n        mem = self.dumpmem(sp, sp+4*argc)\n        for i in range(argc):\n            args += [struct.unpack(\"<L\", mem[i*4:(i+1)*4])[0]]\n\n        return args\n\n    def _get_function_args_64(self, code, argc=None):\n        \"\"\"\n        Guess the number of arguments passed to a function - x86_64\n        \"\"\"\n\n        # just retrieve max 6 args\n        arg_order = [\"rdi\", \"rsi\", \"rdx\", \"rcx\", \"r8\", \"r9\"]\n        p = re.compile(\":\\s*([^ ]*)\\s*(.*),\")\n        matches = p.findall(code)\n        regs = [r for (_, r) in matches]\n        p = re.compile((\"di|si|dx|cx|r8|r9\"))\n        m = p.findall(\" \".join(regs))\n        m = list(set(m)) # uniqify\n        argc = 0\n        if \"si\" in m and \"di\" not in m: # dirty fix\n            argc += 1\n        argc += m.count(\"di\")\n        if argc > 0:\n            argc += m.count(\"si\")\n        if argc > 1:\n            argc += m.count(\"dx\")\n        if argc > 2:\n            argc += m.count(\"cx\")\n        if argc > 3:\n            argc += m.count(\"r8\")\n        if argc > 4:\n            argc += m.count(\"r9\")\n\n        if argc == 0:\n            return []\n\n        args = []\n        regs = self.getregs()\n        for i in range(argc):\n            args += [regs[arg_order[i]]]\n\n        return args\n\n    def get_function_args(self, argc=None):\n        \"\"\"\n        Get the guessed arguments passed to a function when stopped at a call instruction\n\n        Args:\n            - argc: force to get specific number of arguments (Int)\n\n        Returns:\n            - list of arguments (List)\n        \"\"\"\n\n        args = []\n        regs = self.getregs()\n        if regs is None:\n            return []\n\n        (arch, bits) = self.getarch()\n        pc = self.getreg(\"pc\")\n        prev_insts = self.prev_inst(pc, 12)\n\n        code = \"\"\n        if not prev_insts:\n            return []\n\n        for (addr, inst) in prev_insts[::-1]:\n            if \"call\" in inst.strip().split()[0]:\n                break\n            code = \"0x%x:%s\\n\" % (addr, inst) + code\n\n        if \"i386\" in arch:\n            args = self._get_function_args_32(code, argc)\n        if \"64\" in arch:\n            args = self._get_function_args_64(code, argc)\n\n        return args\n\n    @memoized\n    def backtrace_depth(self, sp=None):\n        \"\"\"\n        Get number of frames in backtrace\n\n        Args:\n            - sp: stack pointer address, for caching (Int)\n\n        Returns:\n            - depth: number of frames (Int)\n        \"\"\"\n        backtrace = self.execute_redirect(\"backtrace\")\n        return backtrace.count(\"#\")\n\n    def stepuntil(self, inst, mapname=None, depth=None):\n        \"\"\"\n        Step execution until next \"inst\" instruction within a specific memory range\n\n        Args:\n            - inst: the instruction to reach (String)\n            - mapname: name of virtual memory region to check for the instruction (String)\n            - depth: backtrace depth (Int)\n\n        Returns:\n            - tuple of (depth, instruction)\n                + depth: current backtrace depth (Int)\n                + instruction: current instruction (String)\n        \"\"\"\n\n        if not self.getpid():\n            return None\n\n        maxdepth = to_int(config.Option.get(\"tracedepth\"))\n        if not maxdepth:\n            maxdepth = 0xffffffff\n\n        maps = self.get_vmmap()\n        binname = self.getfile()\n        if mapname is None:\n            mapname = binname\n        mapname = mapname.replace(\" \", \"\").split(\",\") + [binname]\n        targetmap = []\n        for m in mapname:\n            targetmap += self.get_vmmap(m)\n        binmap = self.get_vmmap(\"binary\")\n\n        current_instruction = \"\"\n        pc = self.getreg(\"pc\")\n\n        if depth is None:\n            current_depth = self.backtrace_depth(self.getreg(\"sp\"))\n        else:\n            current_depth = depth\n        old_status = self.get_status()\n\n        while True:\n            status = self.get_status()\n            if status != old_status:\n                if \"SIG\" in status and status[3:] not in [\"TRAP\"] and not to_int(status[3:]): # ignore TRAP and numbered signals\n                    current_instruction = \"Interrupted: %s\" % status\n                    call_depth = current_depth\n                    break\n                if \"STOP\" in status:\n                    current_instruction = \"End of execution\"\n                    call_depth = current_depth\n                    break\n\n            call_depth = self.backtrace_depth(self.getreg(\"sp\"))\n            current_instruction = self.execute_redirect(\"x/i $pc\")\n            if not current_instruction:\n                current_instruction = \"End of execution\"\n                break\n\n            p = re.compile(\".*?(0x[^ :]*)\")\n            addr = p.search(current_instruction).group(1)\n            addr = to_int(addr)\n            if addr is None:\n                break\n\n            #p = re.compile(\".*?:\\s*([^ ]*)\")\n            p = re.compile(\".*?:\\s*(.*)\")\n            code = p.match(current_instruction).group(1)\n            found = 0\n            for i in inst.replace(\",\", \" \").split():\n                if re.match(i.strip(), code.strip()):\n                    if self.is_address(addr, targetmap) and addr != pc:\n                        found = 1\n                        break\n            if found != 0:\n                break\n            self.execute_redirect(\"stepi\", silent=True)\n            if not self.is_address(addr, targetmap) or call_depth > maxdepth:\n                self.execute_redirect(\"finish\", silent=True)\n            pc = 0\n\n        return (call_depth - current_depth, current_instruction.strip())\n\n    def get_eflags(self):\n        \"\"\"\n        Get flags value from EFLAGS register\n\n        Returns:\n            - dictionary of named flags\n        \"\"\"\n\n        # Eflags bit masks, source vdb\n        EFLAGS_CF = 1 << 0\n        EFLAGS_PF = 1 << 2\n        EFLAGS_AF = 1 << 4\n        EFLAGS_ZF = 1 << 6\n        EFLAGS_SF = 1 << 7\n        EFLAGS_TF = 1 << 8\n        EFLAGS_IF = 1 << 9\n        EFLAGS_DF = 1 << 10\n        EFLAGS_OF = 1 << 11\n\n        flags = {\"CF\":0, \"PF\":0, \"AF\":0, \"ZF\":0, \"SF\":0, \"TF\":0, \"IF\":0, \"DF\":0, \"OF\":0}\n        eflags = self.getreg(\"eflags\")\n        if not eflags:\n            return None\n        flags[\"CF\"] = bool(eflags & EFLAGS_CF)\n        flags[\"PF\"] = bool(eflags & EFLAGS_PF)\n        flags[\"AF\"] = bool(eflags & EFLAGS_AF)\n        flags[\"ZF\"] = bool(eflags & EFLAGS_ZF)\n        flags[\"SF\"] = bool(eflags & EFLAGS_SF)\n        flags[\"TF\"] = bool(eflags & EFLAGS_TF)\n        flags[\"IF\"] = bool(eflags & EFLAGS_IF)\n        flags[\"DF\"] = bool(eflags & EFLAGS_DF)\n        flags[\"OF\"] = bool(eflags & EFLAGS_OF)\n\n        return flags\n\n    def set_eflags(self, flagname, value):\n        \"\"\"\n        Set/clear/toggle value of a flag register\n\n        Returns:\n            - True if success (Bool)\n        \"\"\"\n\n        # Eflags bit masks, source vdb\n        EFLAGS_CF = 1 << 0\n        EFLAGS_PF = 1 << 2\n        EFLAGS_AF = 1 << 4\n        EFLAGS_ZF = 1 << 6\n        EFLAGS_SF = 1 << 7\n        EFLAGS_TF = 1 << 8\n        EFLAGS_IF = 1 << 9\n        EFLAGS_DF = 1 << 10\n        EFLAGS_OF = 1 << 11\n\n        flags = {\"carry\": \"CF\", \"parity\": \"PF\", \"adjust\": \"AF\", \"zero\": \"ZF\", \"sign\": \"SF\",\n                    \"trap\": \"TF\", \"interrupt\": \"IF\", \"direction\": \"DF\", \"overflow\": \"OF\"}\n\n        flagname = flagname.lower()\n\n        if flagname not in flags:\n            return False\n\n        eflags = self.get_eflags()\n        if not eflags:\n            return False\n\n        # If value doesn't match the current, or we want to toggle, toggle\n        if value is None or eflags[flags[flagname]] != value:\n            reg_eflags = self.getreg(\"eflags\")\n            reg_eflags ^= eval(\"EFLAGS_%s\" % flags[flagname])\n            result = self.execute(\"set $eflags = 0x%x\" % reg_eflags)\n            return result\n\n        return True\n\n    def eval_target(self, inst):\n        \"\"\"\n        Evaluate target address of an instruction, used for jumpto decision\n\n        Args:\n            - inst: ASM instruction text (String)\n\n        Returns:\n            - target address (Int)\n        \"\"\"\n\n        target = None\n        inst = inst.strip()\n        opcode = inst.split(\":\\t\")[-1].split()[0]\n        # this regex includes x86_64 RIP relateive address reference\n        p = re.compile(\".*?:\\s*[^ ]*\\s*(.* PTR ).*(0x[^ ]*)\")\n        m = p.search(inst)\n        if not m:\n            p = re.compile(\".*?:\\s.*\\s(0x[^ ]*|\\w+)\")\n            m = p.search(inst)\n            if m:\n                target = m.group(1)\n                target = self.parse_and_eval(target)\n            else:\n                target = None\n        else:\n            if \"]\" in m.group(2): # e.g DWORD PTR [ebx+0xc]\n                p = re.compile(\".*?:\\s*[^ ]*\\s*(.* PTR ).*\\[(.*)\\]\")\n                m = p.search(inst)\n            target = self.parse_and_eval(\"%s[%s]\" % (m.group(1), m.group(2).strip()))\n\n        return to_int(target)\n\n    def testjump(self, inst=None):\n        \"\"\"\n        Test if jump instruction is taken or not\n\n        Returns:\n            - (status, address of target jumped instruction)\n        \"\"\"\n\n        flags = self.get_eflags()\n        if not flags:\n            return None\n\n        if not inst:\n            pc = self.getreg(\"pc\")\n            inst = self.execute_redirect(\"x/i 0x%x\" % pc)\n            if not inst:\n                return None\n\n        opcode = inst.split(\":\\t\")[-1].split()[0]\n        next_addr = self.eval_target(inst)\n        if next_addr is None:\n            next_addr = 0\n\n        if opcode == \"jmp\":\n            return next_addr\n        if opcode == \"je\" and flags[\"ZF\"]:\n            return next_addr\n        if opcode == \"jne\" and not flags[\"ZF\"]:\n            return next_addr\n        if opcode == \"jg\" and not flags[\"ZF\"] and (flags[\"SF\"] == flags[\"OF\"]):\n            return next_addr\n        if opcode == \"jge\" and (flags[\"SF\"] == flags[\"OF\"]):\n            return next_addr\n        if opcode == \"ja\" and not flags[\"CF\"] and not flags[\"ZF\"]:\n            return next_addr\n        if opcode == \"jae\" and not flags[\"CF\"]:\n            return next_addr\n        if opcode == \"jl\" and (flags[\"SF\"] != flags[\"OF\"]):\n            return next_addr\n        if opcode == \"jle\" and (flags[\"ZF\"] or (flags[\"SF\"] != flags[\"OF\"])):\n            return next_addr\n        if opcode == \"jb\" and flags[\"CF\"]:\n            return next_addr\n        if opcode == \"jbe\" and (flags[\"CF\"] or flags[\"ZF\"]):\n            return next_addr\n        if opcode == \"jo\" and flags[\"OF\"]:\n            return next_addr\n        if opcode == \"jno\" and not flags[\"OF\"]:\n            return next_addr\n        if opcode == \"jz\" and flags[\"ZF\"]:\n            return next_addr\n        if opcode == \"jnz\" and flags[\"OF\"]:\n            return next_addr\n\n        return None\n\n    def take_snapshot(self):\n        \"\"\"\n        Take a snapshot of current process\n        Warning: this is not thread safe, do not use with multithread program\n\n        Returns:\n            - dictionary of snapshot data\n        \"\"\"\n        if not self.getpid():\n            return None\n\n        maps =  self.get_vmmap()\n        if not maps:\n            return None\n\n        snapshot = {}\n        # get registers\n        snapshot[\"reg\"] = self.getregs()\n        # get writable memory regions\n        snapshot[\"mem\"] = {}\n        for (start, end, perm, _) in maps:\n            if \"w\" in perm:\n                snapshot[\"mem\"][start] = self.dumpmem(start, end)\n\n        return snapshot\n\n    def save_snapshot(self, filename=None):\n        \"\"\"\n        Save a snapshot of current process to file\n        Warning: this is not thread safe, do not use with multithread program\n\n        Args:\n            - filename: target file to save snapshot\n\n        Returns:\n            - Bool\n        \"\"\"\n        if not filename:\n            filename = self.get_config_filename(\"snapshot\")\n\n        snapshot = self.take_snapshot()\n        if not snapshot:\n            return False\n        # dump to file\n        fd = open(filename, \"wb\")\n        pickle.dump(snapshot, fd, pickle.HIGHEST_PROTOCOL)\n        fd.close()\n\n        return True\n\n    def give_snapshot(self, snapshot):\n        \"\"\"\n        Restore a saved snapshot of current process\n        Warning: this is not thread safe, do not use with multithread program\n\n        Returns:\n            - Bool\n        \"\"\"\n        if not snapshot or not self.getpid():\n            return False\n\n        # restore memory regions\n        for (addr, buf) in snapshot[\"mem\"].items():\n            self.writemem(addr, buf)\n\n        # restore registers, SP will be the last one\n        for (r, v) in snapshot[\"reg\"].items():\n            self.execute(\"set $%s = 0x%x\" % (r, v))\n            if r.endswith(\"sp\"):\n                sp = v\n        self.execute(\"set $sp = 0x%x\" % sp)\n\n        return True\n\n    def restore_snapshot(self, filename=None):\n        \"\"\"\n        Restore a saved snapshot of current process from file\n        Warning: this is not thread safe, do not use with multithread program\n\n        Args:\n            - file: saved snapshot\n\n        Returns:\n            - Bool\n        \"\"\"\n        if not filename:\n            filename = self.get_config_filename(\"snapshot\")\n\n        fd = open(filename, \"rb\")\n        snapshot = pickle.load(fd)\n        return self.give_snapshot(snapshot)\n\n\n    #########################\n    #   Memory Operations   #\n    #########################\n    @memoized\n    def get_vmmap(self, name=None):\n        \"\"\"\n        Get virtual memory mapping address ranges of debugged process\n\n        Args:\n            - name: name/address of binary/library to get mapping range (String)\n                + name = \"binary\" means debugged program\n                + name = \"all\" means all virtual maps\n\n        Returns:\n            - list of virtual mapping ranges (start(Int), end(Int), permission(String), mapname(String))\n\n        \"\"\"\n        def _get_offline_maps():\n            name = self.getfile()\n            if not name:\n                return None\n            headers = self.elfheader()\n            binmap = []\n            hlist = [x for x in headers.items() if x[1][2] == 'code']\n            hlist = sorted(hlist, key=lambda x:x[1][0])\n            binmap += [(hlist[0][1][0], hlist[-1][1][1], \"rx-p\", name)]\n\n            hlist = [x for x in headers.items() if x[1][2] == 'rodata']\n            hlist = sorted(hlist, key=lambda x:x[1][0])\n            binmap += [(hlist[0][1][0], hlist[-1][1][1], \"r--p\", name)]\n\n            hlist = [x for x in headers.items() if x[1][2] == 'data']\n            hlist = sorted(hlist, key=lambda x:x[1][0])\n            binmap += [(hlist[0][1][0], hlist[-1][1][1], \"rw-p\", name)]\n\n            return binmap\n\n        def _get_allmaps_osx(pid, remote=False):\n            maps = []\n            #_DATA                 00007fff77975000-00007fff77976000 [    4K] rw-/rw- SM=COW  /usr/lib/system/libremovefile.dylib\n            pattern = re.compile(\"([^\\n]*)\\s*  ([0-9a-f][^-\\s]*)-([^\\s]*) \\[.*\\]\\s([^/]*).*  (.*)\")\n\n            if remote: # remote target, not yet supported\n                return maps\n            else: # local target\n                try:  out = execute_external_command(\"/usr/bin/vmmap -w %s\" % self.getpid())\n                except: error_msg(\"could not read vmmap of process\")\n\n            matches = pattern.findall(out)\n            if matches:\n                for (name, start, end, perm, mapname) in matches:\n                    if name.startswith(\"Stack\"):\n                        mapname = \"[stack]\"\n                    start = to_int(\"0x%s\" % start)\n                    end = to_int(\"0x%s\" % end)\n                    if mapname == \"\":\n                        mapname = name.strip()\n                    maps += [(start, end, perm, mapname)]\n            return maps\n\n\n        def _get_allmaps_freebsd(pid, remote=False):\n            maps = []\n            mpath = \"/proc/%s/map\" % pid\n            # 0x8048000 0x8049000 1 0 0xc36afdd0 r-x 1 0 0x1000 COW NC vnode /path/to/file NCH -1\n            pattern = re.compile(\"0x([0-9a-f]*) 0x([0-9a-f]*)(?: [^ ]*){3} ([rwx-]*)(?: [^ ]*){6} ([^ ]*)\")\n\n            if remote: # remote target, not yet supported\n                return maps\n            else: # local target\n                try:  out = open(mpath).read()\n                except: error_msg(\"could not open %s; is procfs mounted?\" % mpath)\n\n            matches = pattern.findall(out)\n            if matches:\n                for (start, end, perm, mapname) in matches:\n                    if start[:2] in [\"bf\", \"7f\", \"ff\"] and \"rw\" in perm:\n                        mapname = \"[stack]\"\n                    start = to_int(\"0x%s\" % start)\n                    end = to_int(\"0x%s\" % end)\n                    if mapname == \"-\":\n                        if start == maps[-1][1] and maps[-1][-1][0] == \"/\":\n                            mapname = maps[-1][-1]\n                        else:\n                            mapname = \"mapped\"\n                    maps += [(start, end, perm, mapname)]\n            return maps\n\n        def _get_allmaps_linux(pid, remote=False):\n            maps = []\n            mpath = \"/proc/%s/maps\" % pid\n            #00400000-0040b000 r-xp 00000000 08:02 538840  /path/to/file\n            pattern = re.compile(\"([0-9a-f]*)-([0-9a-f]*) ([rwxps-]*)(?: [^ ]*){3} *(.*)\")\n\n            if remote: # remote target\n                tmp = tmpfile()\n                self.execute(\"remote get %s %s\" % (mpath, tmp.name))\n                tmp.seek(0)\n                out = tmp.read()\n                tmp.close()\n            else: # local target\n                out = open(mpath).read()\n\n            matches = pattern.findall(out)\n            if matches:\n                for (start, end, perm, mapname) in matches:\n                    start = to_int(\"0x%s\" % start)\n                    end = to_int(\"0x%s\" % end)\n                    if mapname == \"\":\n                        mapname = \"mapped\"\n                    maps += [(start, end, perm, mapname)]\n            return maps\n\n        result = []\n        pid = self.getpid()\n        if not pid: # not running, try to use elfheader()\n            try:\n                return _get_offline_maps()\n            except:\n                return []\n\n        # retrieve all maps\n        os   = self.getos()\n        rmt  = self.is_target_remote()\n        maps = []\n        try:\n            if   os == \"FreeBSD\": maps = _get_allmaps_freebsd(pid, rmt)\n            elif os == \"Linux\"  : maps = _get_allmaps_linux(pid, rmt)\n            elif os == \"Darwin\" : maps = _get_allmaps_osx(pid, rmt)\n        except Exception as e:\n            if config.Option.get(\"debug\") == \"on\":\n                msg(\"Exception: %s\" %e)\n                traceback.print_exc()\n\n        # select maps matched specific name\n        if name == \"binary\":\n            name = self.getfile()\n        if name is None or name == \"all\":\n            name = \"\"\n\n        if to_int(name) is None:\n            for (start, end, perm, mapname) in maps:\n                if name in mapname:\n                    result += [(start, end, perm, mapname)]\n        else:\n            addr = to_int(name)\n            for (start, end, perm, mapname) in maps:\n                if start <= addr and addr < end:\n                    result += [(start, end, perm, mapname)]\n\n        return result\n\n    @memoized\n    def get_vmrange(self, address, maps=None):\n        \"\"\"\n        Get virtual memory mapping range of an address\n\n        Args:\n            - address: target address (Int)\n            - maps: only find in provided maps (List)\n\n        Returns:\n            - tuple of virtual memory info (start, end, perm, mapname)\n        \"\"\"\n        if address is None:\n            return None\n        if maps is None:\n            maps = self.get_vmmap()\n        if maps:\n            for (start, end, perm, mapname) in maps:\n                if start <= address and end > address:\n                    return (start, end, perm, mapname)\n        # failed to get the vmmap\n        else:\n            try:\n                gdb.selected_inferior().read_memory(address, 1)\n                start = address & 0xfffffffffffff000\n                end = start + 0x1000\n                return (start, end, 'rwx', 'unknown')\n            except:\n                return None\n\n\n    @memoized\n    def is_executable(self, address, maps=None):\n        \"\"\"\n        Check if an address is executable\n\n        Args:\n            - address: target address (Int)\n            - maps: only check in provided maps (List)\n\n        Returns:\n            - True if address belongs to an executable address range (Bool)\n        \"\"\"\n        vmrange = self.get_vmrange(address, maps)\n        if vmrange and \"x\" in vmrange[2]:\n            return True\n        else:\n            return False\n\n    @memoized\n    def is_writable(self, address, maps=None):\n        \"\"\"\n        Check if an address is writable\n\n        Args:\n            - address: target address (Int)\n            - maps: only check in provided maps (List)\n\n        Returns:\n            - True if address belongs to a writable address range (Bool)\n        \"\"\"\n        vmrange = self.get_vmrange(address, maps)\n        if vmrange and \"w\" in vmrange[2]:\n            return True\n        else:\n            return False\n\n    @memoized\n    def is_address(self, value, maps=None):\n        \"\"\"\n        Check if a value is a valid address (belongs to a memory region)\n\n        Args:\n            - value (Int)\n            - maps: only check in provided maps (List)\n\n        Returns:\n            - True if value belongs to an address range (Bool)\n        \"\"\"\n        vmrange = self.get_vmrange(value, maps)\n        return vmrange is not None\n\n    @memoized\n    def get_disasm(self, address, count=1):\n        \"\"\"\n        Get the ASM code of instruction at address\n\n        Args:\n            - address: address to read instruction (Int)\n            - count: number of code lines (Int)\n\n        Returns:\n            - asm code (String)\n        \"\"\"\n        code = self.execute_redirect(\"x/%di 0x%x\" % (count, address))\n        if code:\n            return code.rstrip()\n        else:\n            return \"\"\n\n    def dumpmem(self, start, end):\n        \"\"\"\n        Dump process memory from start to end\n\n        Args:\n            - start: start address (Int)\n            - end: end address (Int)\n\n        Returns:\n            - memory content (raw bytes)\n        \"\"\"\n        mem = None\n        logfd = tmpfile(is_binary_file=True)\n        logname = logfd.name\n        out = self.execute_redirect(\"dump memory %s 0x%x 0x%x\" % (logname, start, end))\n        if out is None:\n            return None\n        else:\n            logfd.flush()\n            mem = logfd.read()\n            logfd.close()\n\n        return mem\n\n    def readmem(self, address, size):\n        \"\"\"\n        Read content of memory at an address\n\n        Args:\n            - address: start address to read (Int)\n            - size: bytes to read (Int)\n\n        Returns:\n            - memory content (raw bytes)\n        \"\"\"\n        # try fast dumpmem if it works\n        mem = self.dumpmem(address, address+size)\n        if mem is not None:\n            return mem\n\n        # failed to dump, use slow x/gx way\n        mem = \"\"\n        out = self.execute_redirect(\"x/%dbx 0x%x\" % (size, address))\n        if out:\n            for line in out.splitlines():\n                bytes = line.split(\":\\t\")[-1].split()\n                mem += \"\".join([chr(int(c, 0)) for c in bytes])\n\n        return mem\n\n    def read_int(self, address, intsize=None):\n        \"\"\"\n        Read an interger value from memory\n\n        Args:\n            - address: address to read (Int)\n            - intsize: force read size (Int)\n\n        Returns:\n            - mem value (Int)\n        \"\"\"\n        if not intsize:\n            intsize = self.intsize()\n        value = self.readmem(address, intsize)\n        if value:\n            value = to_int(\"0x\" + codecs.encode(value[::-1], 'hex'))\n            return value\n        else:\n            return None\n\n\n    def read_long(self, address):\n        \"\"\"\n        Read a long long value from memory\n\n        Args:\n            - address: address to read (Int)\n\n        Returns:\n            - mem value (Long Long)\n        \"\"\"\n        return self.read_int(address, 8)\n\n    def writemem(self, address, buf):\n        \"\"\"\n        Write buf to memory start at an address\n\n        Args:\n            - address: start address to write (Int)\n            - buf: data to write (raw bytes)\n\n        Returns:\n            - number of written bytes (Int)\n        \"\"\"\n        out = None\n        if not buf:\n            return 0\n\n        if self.getpid():\n            # try fast restore mem\n            tmp = tmpfile(is_binary_file=True)\n            tmp.write(buf)\n            tmp.flush()\n            out = self.execute_redirect(\"restore %s binary 0x%x\" % (tmp.name, address))\n            tmp.close()\n        if not out: # try the slow way\n            for i in range(len(buf)):\n                if not self.execute(\"set {char}0x%x = 0x%x\" % (address+i, ord(buf[i]))):\n                    return i\n            return i+1\n        elif \"error\" in out: # failed to write the whole buf, find written byte\n            for i in range(0, len(buf), 1):\n                if not self.is_address(address+i):\n                    return i\n        else:\n            return len(buf)\n\n    def write_int(self, address, value, intsize=None):\n        \"\"\"\n        Write an interger value to memory\n\n        Args:\n            - address: address to read (Int)\n            - value: int to write to (Int)\n            - intsize: force write size (Int)\n\n        Returns:\n            - Bool\n        \"\"\"\n        if not intsize:\n            intsize = self.intsize()\n        buf = hex2str(value, intsize).ljust(intsize, \"\\x00\")[:intsize]\n        saved = self.readmem(address, intsize)\n        if not saved:\n            return False\n\n        ret = self.writemem(address, buf)\n        if ret != intsize:\n            self.writemem(address, saved)\n            return False\n        return True\n\n    def write_long(self, address, value):\n        \"\"\"\n        Write a long long value to memory\n\n        Args:\n            - address: address to read (Int)\n            - value: value to write to\n\n        Returns:\n            - Bool\n        \"\"\"\n        return self.write_int(address, value, 8)\n\n    def cmpmem(self, start, end, buf):\n        \"\"\"\n        Compare contents of a memory region with a buffer\n\n        Args:\n            - start: start address (Int)\n            - end: end address (Int)\n            - buf: raw bytes\n\n        Returns:\n            - dictionary of array of diffed bytes in hex (Dictionary)\n            {123: [(\"A\", \"B\"), (\"C\", \"C\"))]}\n        \"\"\"\n        line_len = 32\n        if end < start:\n            (start, end) = (end, start)\n\n        mem = self.dumpmem(start, end)\n        if mem is None:\n            return None\n\n        length = min(len(mem), len(buf))\n        result = {}\n        lineno = 0\n        for i in range(length//line_len):\n            diff = 0\n            bytes_ = []\n            for j in range(line_len):\n                offset = i*line_len+j\n                bytes_ += [(mem[offset:offset + 1], buf[offset:offset + 1])]\n                if mem[offset] != buf[offset]:\n                    diff = 1\n            if diff == 1:\n                result[start+lineno] = bytes_\n            lineno += line_len\n\n        bytes_ = []\n        diff = 0\n        for i in range(length % line_len):\n            offset = lineno+i\n            bytes_ += [(mem[offset:offset + 1], buf[offset:offset + 1])]\n            if mem[offset] != buf[offset]:\n                diff = 1\n        if diff == 1:\n            result[start+lineno] = bytes_\n\n        return result\n\n    def xormem(self, start, end, key):\n        \"\"\"\n        XOR a memory region with a key\n\n        Args:\n            - start: start address (Int)\n            - end: end address (Int)\n            - key: XOR key (String)\n\n        Returns:\n            - xored memory content (raw bytes)\n        \"\"\"\n        mem = self.dumpmem(start, end)\n        if mem is None:\n            return None\n\n        if to_int(key) != None:\n            key = hex2str(to_int(key), self.intsize())\n        mem = list(bytes_iterator(mem))\n        for index, char in enumerate(mem):\n            key_idx = index % len(key)\n            mem[index] = chr(ord(char) ^ ord(key[key_idx]))\n\n        buf = b\"\".join([to_binary_string(x) for x in mem])\n        bytes = self.writemem(start, buf)\n        return buf\n\n    def searchmem(self, start, end, search, mem=None):\n        \"\"\"\n        Search for all instances of a pattern in memory from start to end\n\n        Args:\n            - start: start address (Int)\n            - end: end address (Int)\n            - search: string or python regex pattern (String)\n            - mem: cached mem to not re-read for repeated searches (raw bytes)\n\n        Returns:\n            - list of found result: (address(Int), hex encoded value(String))\n\n        \"\"\"\n\n        result = []\n        if end < start:\n            (start, end) = (end, start)\n\n        if mem is None:\n            mem = self.dumpmem(start, end)\n\n        if not mem:\n            return result\n\n        if isinstance(search, six.string_types) and search.startswith(\"0x\"):\n            # hex number\n            search = search[2:]\n            if len(search) %2 != 0:\n                search = \"0\" + search\n            search = codecs.decode(search, 'hex')[::-1]\n            search = re.escape(search)\n\n        # Convert search to bytes if is not already\n        if not isinstance(search, bytes):\n            search = search.encode('utf-8')\n\n        try:\n            p = re.compile(search)\n        except:\n            search = re.escape(search)\n            p = re.compile(search)\n\n        found = list(p.finditer(mem))\n        for m in found:\n            index = 1\n            if m.start() == m.end() and m.lastindex:\n                index = m.lastindex+1\n            for i in range(0,index):\n                if m.start(i) != m.end(i):\n                    result += [(start + m.start(i), codecs.encode(mem[m.start(i):m.end(i)], 'hex'))]\n\n        return result\n\n    def searchmem_by_range(self, mapname, search):\n        \"\"\"\n        Search for all instances of a pattern in virtual memory ranges\n\n        Args:\n            - search: string or python regex pattern (String)\n            - mapname: name of virtual memory range (String)\n\n        Returns:\n            - list of found result: (address(Int), hex encoded value(String))\n        \"\"\"\n\n        result = []\n        ranges = self.get_vmmap(mapname)\n        if ranges:\n            for (start, end, perm, name) in ranges:\n                if \"r\" in perm:\n                    result += self.searchmem(start, end, search)\n\n        return result\n\n    @memoized\n    def search_reference(self, search, mapname=None):\n        \"\"\"\n        Search for all references to a value in memory ranges\n\n        Args:\n            - search: string or python regex pattern (String)\n            - mapname: name of target virtual memory range (String)\n\n        Returns:\n            - list of found result: (address(int), hex encoded value(String))\n        \"\"\"\n\n        maps = self.get_vmmap()\n        ranges = self.get_vmmap(mapname)\n        result = []\n        search_result = []\n        for (start, end, perm, name) in maps:\n            if \"r\" in perm:\n                search_result += self.searchmem(start, end, search)\n\n        for (start, end, perm, name) in ranges:\n            for (a, v) in search_result:\n                result += self.searchmem(start, end, to_address(a))\n\n        return result\n\n    @memoized\n    def search_address(self, searchfor=\"stack\", belongto=\"binary\"):\n        \"\"\"\n        Search for all valid addresses in memory ranges\n\n        Args:\n            - searchfor: memory region to search for addresses (String)\n            - belongto: memory region that target addresses belong to (String)\n\n        Returns:\n            - list of found result: (address(Int), value(Int))\n        \"\"\"\n\n        result = []\n        maps = self.get_vmmap()\n        if maps is None:\n            return result\n\n        searchfor_ranges = self.get_vmmap(searchfor)\n        belongto_ranges = self.get_vmmap(belongto)\n        step = self.intsize()\n        for (start, end, _, _) in searchfor_ranges[::-1]: # dirty trick, to search in rw-p mem first\n            mem = self.dumpmem(start, end)\n            if not mem:\n                continue\n            for i in range(0, len(mem), step):\n                search = \"0x\" + codecs.encode(mem[i:i+step][::-1], 'hex').decode('utf-8')\n                addr = to_int(search)\n                if self.is_address(addr, belongto_ranges):\n                    result += [(start+i, addr)]\n\n        return result\n\n    @memoized\n    def search_pointer(self, searchfor=\"stack\", belongto=\"binary\"):\n        \"\"\"\n        Search for all valid pointers in memory ranges\n\n        Args:\n            - searchfor: memory region to search for pointers (String)\n            - belongto: memory region that pointed addresses belong to (String)\n\n        Returns:\n            - list of found result: (address(Int), value(Int))\n        \"\"\"\n\n        search_result = []\n        result = []\n        maps = self.get_vmmap()\n        searchfor_ranges = self.get_vmmap(searchfor)\n        belongto_ranges = self.get_vmmap(belongto)\n        step = self.intsize()\n        for (start, end, _, _) in searchfor_ranges[::-1]:\n            mem = self.dumpmem(start, end)\n            if not mem:\n                continue\n            for i in range(0, len(mem), step):\n                search = \"0x\" + codecs.encode(mem[i:i+step][::-1], 'hex').decode('utf-8')\n                addr = to_int(search)\n                if self.is_address(addr):\n                    (v, t, vn) = self.examine_mem_value(addr)\n                    if t != 'value':\n                        if self.is_address(to_int(vn), belongto_ranges):\n                            if (to_int(v), v) not in search_result:\n                                search_result += [(to_int(v), v)]\n\n            for (a, v) in search_result:\n                result += self.searchmem(start, end, to_address(a), mem)\n\n        return result\n\n    @memoized\n    def examine_mem_value(self, value):\n        \"\"\"\n        Examine a value in memory for its type and reference\n\n        Args:\n            - value: value to examine (Int)\n\n        Returns:\n            - tuple of (value(Int), type(String), next_value(Int))\n        \"\"\"\n        def examine_data(value, bits=32):\n            out = self.execute_redirect(\"x/%sx 0x%x\" % (\"g\" if bits == 64 else \"w\", value))\n            if out:\n                v = out.split(\":\\t\")[-1].strip()\n                if is_printable(int2hexstr(to_int(v), bits//8)):\n                    out = self.execute_redirect(\"x/s 0x%x\" % value)\n            return out\n\n        result = (None, None, None)\n        if value is None:\n            return result\n\n        maps = self.get_vmmap()\n        binmap = self.get_vmmap(\"binary\")\n\n        (arch, bits) = self.getarch()\n        if not self.is_address(value): # a value\n            result = (to_hex(value), \"value\", \"\")\n            return result\n        else:\n            (_, _, _, mapname) = self.get_vmrange(value)\n\n        # check for writable first so rwxp mem will be treated as data\n        if self.is_writable(value): # writable data address\n            out = examine_data(value, bits)\n            if out:\n                result = (to_hex(value), \"data\", out.split(\":\", 1)[1].strip())\n\n        elif self.is_executable(value): # code/rodata address\n            if self.is_address(value, binmap):\n                headers = self.elfheader()\n            else:\n                headers = self.elfheader_solib(mapname)\n\n            if headers:\n                headers = sorted(headers.items(), key=lambda x: x[1][1])\n                for (k, (start, end, type)) in headers:\n                    if value >= start and value < end:\n                        if type == \"code\":\n                            out = self.get_disasm(value)\n                            p = re.compile(\".*?0x[^ ]*?\\s(.*)\")\n                            m = p.search(out)\n                            result = (to_hex(value), \"code\", m.group(1))\n                        else: # rodata address\n                            out = examine_data(value, bits)\n                            result = (to_hex(value), \"rodata\", out.split(\":\", 1)[1].strip())\n                        break\n\n                if result[0] is None: # not fall to any header section\n                    out = examine_data(value, bits)\n                    result = (to_hex(value), \"rodata\", out.split(\":\", 1)[1].strip())\n\n            else: # not belong to any lib: [heap], [vdso], [vsyscall], etc\n                out = self.get_disasm(value)\n                if \"(bad)\" in out:\n                    out = examine_data(value, bits)\n                    result = (to_hex(value), \"rodata\", out.split(\":\", 1)[1].strip())\n                else:\n                    p = re.compile(\".*?0x[^ ]*?\\s(.*)\")\n                    m = p.search(out)\n                    result = (to_hex(value), \"code\", m.group(1))\n\n        else: # readonly data address\n            out = examine_data(value, bits)\n            if out:\n                result = (to_hex(value), \"rodata\", out.split(\":\", 1)[1].strip())\n            else:\n                result = (to_hex(value), \"rodata\", \"MemError\")\n\n        return result\n\n    @memoized\n    def examine_mem_reference(self, value, depth=5):\n        \"\"\"\n        Deeply examine a value in memory for its references\n\n        Args:\n            - value: value to examine (Int)\n\n        Returns:\n            - list of tuple of (value(Int), type(String), next_value(Int))\n        \"\"\"\n        result = []\n        if depth <= 0:\n            depth = 0xffffffff\n\n        (v, t, vn) = self.examine_mem_value(value)\n        while vn is not None:\n            if len(result) > depth:\n                _v, _t, _vn = result[-1]\n                result[-1] = (_v, _t, \"--> ...\")\n                break\n\n            result += [(v, t, vn)]\n            if v == vn or to_int(v) == to_int(vn): # point to self\n                break\n            if to_int(vn) is None:\n                break\n            if to_int(vn) in [to_int(v) for (v, _, _) in result]: # point back to previous value\n                break\n            (v, t, vn) = self.examine_mem_value(to_int(vn))\n\n        return result\n\n    @memoized\n    def format_search_result(self, result, display=256):\n        \"\"\"\n        Format the result from various memory search commands\n\n        Args:\n            - result: result of search commands (List)\n            - display: number of items to display\n\n        Returns:\n            - text: formatted text (String)\n        \"\"\"\n\n        text = \"\"\n        if not result:\n            text = \"Not found\"\n        else:\n            maxlen = 0\n            maps = self.get_vmmap()\n            shortmaps = []\n            for (start, end, perm, name) in maps:\n                shortname = os.path.basename(name)\n                if shortname.startswith(\"lib\"):\n                    shortname = shortname.split(\"-\")[0]\n                shortmaps += [(start, end, perm, shortname)]\n\n            count = len(result)\n            if display != 0:\n                count = min(count, display)\n            text += \"Found %d results, display max %d items:\\n\" % (len(result), count)\n            for (addr, v) in result[:count]:\n                vmrange = self.get_vmrange(addr, shortmaps)\n                maxlen = max(maxlen, len(vmrange[3]))\n\n            for (addr, v) in result[:count]:\n                vmrange = self.get_vmrange(addr, shortmaps)\n                chain = self.examine_mem_reference(addr)\n                text += \"%s : %s\" % (vmrange[3].rjust(maxlen), format_reference_chain(chain) + \"\\n\")\n\n        return text\n\n\n    ##########################\n    #     Exploit Helpers    #\n    ##########################\n    @memoized\n    def elfentry(self):\n        \"\"\"\n        Get entry point address of debugged ELF file\n\n        Returns:\n            - entry address (Int)\n        \"\"\"\n        out = self.execute_redirect(\"info files\")\n        p = re.compile(\"Entry point: ([^\\s]*)\")\n        if out:\n            m = p.search(out)\n            if m:\n                return to_int(m.group(1))\n        return None\n\n    @memoized\n    def elfheader(self, name=None):\n        \"\"\"\n        Get headers information of debugged ELF file\n\n        Args:\n            - name: specific header name (String)\n\n        Returns:\n            - dictionary of headers {name(String): (start(Int), end(Int), type(String))}\n        \"\"\"\n        elfinfo = {}\n        elfbase = 0\n        if self.getpid():\n            binmap = self.get_vmmap(\"binary\")\n            elfbase = binmap[0][0] if binmap else 0\n\n        out = self.execute_redirect(\"maintenance info sections\")\n        if not out:\n            return {}\n\n        p = re.compile(\"\\s*(0x[^-]*)->(0x[^ ]*) at (0x[^:]*):\\s*([^ ]*)\\s*(.*)\")\n        matches = p.findall(out)\n\n        for (start, end, offset, hname, attr) in matches:\n            start, end, offset = to_int(start), to_int(end), to_int(offset)\n            # skip unuseful header\n            if start < offset:\n                continue\n            # if PIE binary, update with runtime address\n            if start < elfbase:\n                start += elfbase\n                end += elfbase\n\n            if \"CODE\" in attr:\n                htype = \"code\"\n            elif \"READONLY\" in attr:\n                htype = \"rodata\"\n            else:\n                htype = \"data\"\n\n            elfinfo[hname.strip()] = (start, end, htype)\n\n        result = {}\n        if name is None:\n            result = elfinfo\n        else:\n            if name in elfinfo:\n                result[name] = elfinfo[name]\n            else:\n                for (k, v) in elfinfo.items():\n                    if name in k:\n                        result[k] = v\n        return result\n\n    @memoized\n    def elfsymbols(self, pattern=None):\n        \"\"\"\n        Get all non-debugging symbol information of debugged ELF file\n\n        Returns:\n            - dictionary of (address(Int), symname(String))\n        \"\"\"\n        headers = self.elfheader()\n        if \".plt\" not in headers: # static binary\n            return {}\n\n        binmap = self.get_vmmap(\"binary\")\n        elfbase = binmap[0][0] if binmap else 0\n\n        # get the .dynstr header\n        headers = self.elfheader()\n        if \".dynstr\" not in headers:\n            return {}\n        (start, end, _) = headers[\".dynstr\"]\n        mem = self.dumpmem(start, end)\n        if not mem and self.getfile():\n            fd = open(self.getfile())\n            fd.seek(start, 0)\n            mem = fd.read(end-start)\n            fd.close()\n\n        # Convert names into strings\n        dynstrings = [name.decode('utf-8') for name in mem.split(b\"\\x00\")]\n\n        if pattern:\n            dynstrings = [s for s in dynstrings if re.search(pattern, s)]\n\n        # get symname@plt info\n        symbols = {}\n        for symname in dynstrings:\n            if not symname: continue\n            symname += \"@plt\"\n            out = self.execute_redirect(\"info functions %s\" % symname)\n            if not out: continue\n            m = re.findall(\".*(0x[^ ]*)\\s*%s\" % re.escape(symname), out)\n            for addr in m:\n                addr = to_int(addr)\n                if self.is_address(addr, binmap):\n                    if symname not in symbols:\n                        symbols[symname] = addr\n                        break\n\n        # if PIE binary, update with runtime address\n        for (k, v) in symbols.items():\n            if v < elfbase:\n                symbols[k] = v + elfbase\n\n        return symbols\n\n    @memoized\n    def elfsymbol(self, symname=None):\n        \"\"\"\n        Get non-debugging symbol information of debugged ELF file\n\n        Args:\n            - name: target function name (String), special cases:\n                + \"data\": data transfer functions\n                + \"exec\": exec helper functions\n\n        Returns:\n            - if exact name is not provided: dictionary of tuple (symname, plt_entry)\n            - if exact name is provided: dictionary of tuple (symname, plt_entry, got_entry, reloc_entry)\n        \"\"\"\n        datafuncs = [\"printf\", \"puts\", \"gets\", \"cpy\"]\n        execfuncs = [\"system\", \"exec\", \"mprotect\", \"mmap\", \"syscall\"]\n        result = {}\n        if not symname or symname in [\"data\", \"exec\"]:\n            symbols = self.elfsymbols()\n        else:\n            symbols = self.elfsymbols(symname)\n\n        if not symname:\n            result = symbols\n        else:\n            sname = symname.replace(\"@plt\", \"\") + \"@plt\"\n            if sname in symbols:\n                plt_addr = symbols[sname]\n                result[sname] = plt_addr # plt entry\n                out = self.get_disasm(plt_addr, 2)\n                for line in out.splitlines():\n                    if \"jmp\" in line:\n                        addr = to_int(\"0x\" + line.strip().rsplit(\"0x\")[-1].split()[0])\n                        result[sname.replace(\"@plt\",\"@got\")] = addr # got entry\n                    if \"push\" in line:\n                        addr = to_int(\"0x\" + line.strip().rsplit(\"0x\")[-1])\n                        result[sname.replace(\"@plt\",\"@reloc\")] = addr # reloc offset\n            else:\n                keywords = [symname]\n                if symname == \"data\":\n                    keywords = datafuncs\n                if symname == \"exec\":\n                    keywords = execfuncs\n                for (k, v) in symbols.items():\n                    for f in keywords:\n                        if f in k:\n                            result[k] = v\n\n        return result\n\n    @memoized\n    def main_entry(self):\n        \"\"\"\n        Get address of main function of stripped ELF file\n\n        Returns:\n            - main function address (Int)\n        \"\"\"\n        refs = self.xrefs(\"__libc_start_main@plt\")\n        if refs:\n            inst = self.prev_inst(refs[0][0])\n            if inst:\n                addr = re.search(\".*(0x.*)\", inst[0][1])\n                if addr:\n                    return to_int(addr.group(1))\n        return None\n\n    @memoized\n    def readelf_header(self, filename, name=None):\n        \"\"\"\n        Get headers information of an ELF file using 'readelf'\n\n        Args:\n            - filename: ELF file (String)\n            - name: specific header name (String)\n\n        Returns:\n            - dictionary of headers (name(String), value(Int)) (Dict)\n        \"\"\"\n        elfinfo = {}\n        vmap = self.get_vmmap(filename)\n        elfbase = vmap[0][0] if vmap else 0\n        out = execute_external_command(\"%s -W -S %s\" % (config.READELF, filename))\n        if not out:\n            return {}\n        p = re.compile(\".*\\[.*\\] (\\.[^ ]*) [^0-9]* ([^ ]*) [^ ]* ([^ ]*)(.*)\")\n        matches = p.findall(out)\n        if not matches:\n            return result\n\n        for (hname, start, size, attr) in matches:\n            start, end = to_int(\"0x\"+start), to_int(\"0x\"+start) + to_int(\"0x\"+size)\n            # if PIE binary or DSO, update with runtime address\n            if start < elfbase:\n                start += elfbase\n            if end < elfbase:\n                end += elfbase\n\n            if \"X\" in attr:\n                htype = \"code\"\n            elif \"W\" in attr:\n                htype = \"data\"\n            else:\n                htype = \"rodata\"\n            elfinfo[hname.strip()] = (start, end, htype)\n\n        result = {}\n        if name is None:\n            result = elfinfo\n        else:\n            if name in elfinfo:\n                result[name] = elfinfo[name]\n            else:\n                for (k, v) in elfinfo.items():\n                    if name in k:\n                        result[k] = v\n        return result\n\n    @memoized\n    def elfheader_solib(self, solib=None, name=None):\n        \"\"\"\n        Get headers information of Shared Object Libraries linked to target\n\n        Args:\n            - solib: shared library name (String)\n            - name: specific header name (String)\n\n        Returns:\n            - dictionary of headers {name(String): start(Int), end(Int), type(String))\n        \"\"\"\n        # hardcoded ELF header type\n        header_type = {\"code\": [\".text\", \".fini\", \".init\", \".plt\", \"__libc_freeres_fn\"],\n            \"data\": [\".dynamic\", \".data\", \".ctors\", \".dtors\", \".jrc\", \".got\", \".got.plt\",\n                    \".bss\", \".tdata\", \".tbss\", \".data.rel.ro\", \".fini_array\",\n                    \"__libc_subfreeres\", \"__libc_thread_subfreeres\"]\n        }\n\n        @memoized\n        def _elfheader_solib_all():\n            out = self.execute_redirect(\"info files\")\n            if not out:\n                return None\n\n            p = re.compile(\"[^\\n]*\\s*(0x[^ ]*) - (0x[^ ]*) is (\\.[^ ]*) in (.*)\")\n            soheaders = p.findall(out)\n\n            result = []\n            for (start, end, hname, libname) in soheaders:\n                start, end = to_int(start), to_int(end)\n                result += [(start, end, hname, os.path.realpath(libname))] # tricky, return the realpath version of libraries\n            return result\n\n        elfinfo = {}\n\n        headers = _elfheader_solib_all()\n        if not headers:\n            return {}\n\n        if solib is None:\n            return headers\n\n        vmap = self.get_vmmap(solib)\n        elfbase = vmap[0][0] if vmap else 0\n\n        for (start, end, hname, libname) in headers:\n            if solib in libname:\n                # if PIE binary or DSO, update with runtime address\n                if start < elfbase:\n                    start += elfbase\n                if end < elfbase:\n                    end += elfbase\n                # determine the type\n                htype = \"rodata\"\n                if hname in header_type[\"code\"]:\n                    htype = \"code\"\n                elif hname in header_type[\"data\"]:\n                    htype = \"data\"\n                elfinfo[hname.strip()] = (start, end, htype)\n\n        result = {}\n        if name is None:\n            result = elfinfo\n        else:\n            if name in elfinfo:\n                result[name] = elfinfo[name]\n            else:\n                for (k, v) in elfinfo.items():\n                    if name in k:\n                        result[k] = v\n        return result\n\n    def checksec(self, filename=None):\n        \"\"\"\n        Check for various security options of binary (ref: http://www.trapkit.de/tools/checksec.sh)\n\n        Args:\n            - file: path name of file to check (String)\n\n        Returns:\n            - dictionary of (setting(String), status(Int)) (Dict)\n        \"\"\"\n        result = {}\n        result[\"RELRO\"] = 0\n        result[\"CANARY\"] = 0\n        result[\"NX\"] = 1\n        result[\"PIE\"] = 0\n        result[\"FORTIFY\"] = 0\n\n        if filename is None:\n            filename = self.getfile()\n\n        if not filename:\n            return None\n\n        out =  execute_external_command(\"%s -W -a \\\"%s\\\" 2>&1\" % (config.READELF, filename))\n        if \"Error:\" in out:\n            return None\n\n        for line in out.splitlines():\n            if \"GNU_RELRO\" in line:\n                result[\"RELRO\"] |= 2\n            if \"BIND_NOW\" in line:\n                result[\"RELRO\"] |= 1\n            if \"__stack_chk_fail\" in line:\n                result[\"CANARY\"] = 1\n            if \"GNU_STACK\" in line and \"RWE\" in line:\n                result[\"NX\"] = 0\n            if \"Type:\" in line and \"DYN (\" in line:\n                result[\"PIE\"] = 4 # Dynamic Shared Object\n            if \"(DEBUG)\" in line and result[\"PIE\"] == 4:\n                result[\"PIE\"] = 1\n            if \"_chk@\" in line:\n                result[\"FORTIFY\"] = 1\n\n        if result[\"RELRO\"] == 1:\n            result[\"RELRO\"] = 0 # ? | BIND_NOW + NO GNU_RELRO = NO PROTECTION\n        # result[\"RELRO\"] == 2 # Partial | NO BIND_NOW + GNU_RELRO\n        # result[\"RELRO\"] == 3 # Full | BIND_NOW + GNU_RELRO\n        return result\n\n    def _verify_rop_gadget(self, start, end, depth=5):\n        \"\"\"\n        Verify ROP gadget code from start to end with max number of instructions\n\n        Args:\n            - start: start address (Int)\n            - end: end addres (Int)\n            - depth: number of instructions (Int)\n\n        Returns:\n            - list of valid gadgets (address(Int), asmcode(String))\n        \"\"\"\n\n        result = []\n        valid = 0\n        out = self.execute_redirect(\"disassemble 0x%x, 0x%x\" % (start, end+1))\n        if not out:\n            return []\n\n        code = out.splitlines()[1:-1]\n        for line in code:\n            if \"bad\" in line:\n                return []\n            (addr, code) = line.strip().split(\":\", 1)\n            addr = to_int(addr.split()[0])\n            result += [(addr, \" \".join(code.strip().split()))]\n            if \"ret\" in code:\n                return result\n            if len(result) > depth:\n                break\n\n        return []\n\n    @memoized\n    def search_asm(self, start, end, asmcode, rop=0):\n        \"\"\"\n        Search for ASM instructions in memory\n\n        Args:\n            - start: start address (Int)\n            - end: end address (Int)\n            - asmcode: assembly instruction (String)\n                + multiple instructions are separated by \";\"\n                + wildcard ? supported, will be replaced by registers or multi-bytes\n\n        Returns:\n            - list of (address(Int), hexbyte(String))\n        \"\"\"\n        wildcard = asmcode.count('?')\n        magic_bytes = [\"0x00\", \"0xff\", \"0xdead\", \"0xdeadbeef\", \"0xdeadbeefdeadbeef\"]\n\n        ops = [x for x in asmcode.split(';') if x]\n        def buildcode(code=b\"\", pos=0, depth=0):\n            if depth == wildcard and pos == len(ops):\n                yield code\n                return\n\n            c = ops[pos].count('?')\n            if c > 2: return\n            elif c == 0:\n                asm = self.assemble(ops[pos])\n                if asm:\n                    for code in buildcode(code + asm, pos+1, depth):\n                        yield code\n            else:\n                save = ops[pos]\n                for regs in REGISTERS.values():\n                    for reg in regs:\n                        ops[pos] = save.replace(\"?\", reg, 1)\n                        for asmcode_reg in buildcode(code, pos, depth+1):\n                            yield asmcode_reg\n                for byte in magic_bytes:\n                    ops[pos] = save.replace(\"?\", byte, 1)\n                    for asmcode_mem in buildcode(code, pos, depth+1):\n                        yield asmcode_mem\n                ops[pos] = save\n\n        searches = []\n\n        def decode_hex_escape(str_):\n            \"\"\"Decode string as hex and escape for regex\"\"\"\n            return re.escape(codecs.decode(str_, 'hex'))\n\n        for machine_code in buildcode():\n            search = re.escape(machine_code)\n            search = search.replace(decode_hex_escape(b\"dead\"), b\"..\")\\\n                .replace(decode_hex_escape(b\"beef\"), b\"..\")\\\n                .replace(decode_hex_escape(b\"00\"), b\".\")\\\n                .replace(decode_hex_escape(b\"ff\"), b\".\")\n\n            if rop and 'ret' not in asmcode:\n                search += b\".{0,24}\\\\xc3\"\n            searches.append(search)\n\n        if not searches:\n            warning_msg(\"invalid asmcode: '%s'\" % asmcode)\n            return []\n\n        search = b\"(?=(\" + b\"|\".join(searches) + b\"))\"\n        candidates = self.searchmem(start, end, search)\n\n        if rop:\n            result = {}\n            for (a, v) in candidates:\n                gadget = self._verify_rop_gadget(a, a+len(v)//2 - 1)\n                # gadget format: [(address, asmcode), (address, asmcode), ...]\n                if gadget != []:\n                    blen = gadget[-1][0] - gadget[0][0] + 1\n                    bytes = v[:2*blen]\n                    asmcode_rs = \"; \".join([c for _, c in gadget])\n                    if re.search(re.escape(asmcode).replace(\"\\ \",\".*\").replace(\"\\?\",\".*\"), asmcode_rs)\\\n                        and a not in result:\n                        result[a] = (bytes, asmcode_rs)\n            result = list(result.items())\n        else:\n            result = []\n            for (a, v) in candidates:\n                asmcode = self.execute_redirect(\"disassemble 0x%x, 0x%x\" % (a, a+(len(v)//2)))\n                if asmcode:\n                    asmcode = \"\\n\".join(asmcode.splitlines()[1:-1])\n                    matches = re.findall(\".*:([^\\n]*)\", asmcode)\n                    result += [(a, (v, \";\".join(matches).strip()))]\n\n        return result\n\n    def dumprop(self, start, end, keyword=None, depth=5):\n        \"\"\"\n        Dump unique ROP gadgets in memory\n\n        Args:\n            - start: start address (Int)\n            - end: end address (Int)\n            - keyword: to match start of gadgets (String)\n\n        Returns:\n            - dictionary of (address(Int), asmcode(String))\n        \"\"\"\n\n        EXTRA_WORDS = [\"BYTE \", \" WORD\", \"DWORD \", \"FWORD \", \"QWORD \", \"PTR \", \"FAR \"]\n        result = {}\n        mem = self.dumpmem(start, end)\n        if mem is None:\n            return {}\n\n        if keyword:\n            search = keyword\n        else:\n            search = \"\"\n\n        if len(mem) > 20000: # limit backward depth if searching in large mem\n            depth = 3\n        found = re.finditer(b\"\\xc3\", mem)\n        found = list(found)\n        for m in found:\n            idx = start+m.start()\n            for i in range(1, 24):\n                gadget = self._verify_rop_gadget(idx-i, idx, depth)\n                if gadget != []:\n                    k = \"; \".join([v for (a, v) in gadget])\n                    if k.startswith(search):\n                        for w in EXTRA_WORDS:\n                            k = k.replace(w, \"\")\n                        if k not in result:\n                            result[k] = gadget[0][0]\n        return result\n\n    def common_rop_gadget(self, mapname=None):\n        \"\"\"\n        Get common rop gadgets in binary: ret, popret, pop2ret, pop3ret, add [mem] reg, add reg [mem]\n\n        Returns:\n            - dictionary of (gadget(String), address(Int))\n        \"\"\"\n\n        def _valid_register_opcode(bytes_):\n            if not bytes_:\n                return False\n\n            for c in bytes_iterator(bytes_):\n                if ord(c) not in list(range(0x58, 0x60)):\n                    return False\n            return True\n\n        result = {}\n        if mapname is None:\n            mapname = \"binary\"\n        maps = self.get_vmmap(mapname)\n        if maps is None:\n            return result\n\n        for (start, end, _, _) in maps:\n            if not self.is_executable(start, maps): continue\n\n            mem = self.dumpmem(start, end)\n            found = self.searchmem(start, end, b\"....\\xc3\", mem)\n            for (a, v) in found:\n                v = codecs.decode(v, 'hex')\n                if \"ret\" not in result:\n                    result[\"ret\"] = a+4\n                if \"leaveret\" not in result:\n                    if v[-2] == \"\\xc9\":\n                        result[\"leaveret\"] = a+3\n                if \"popret\" not in result:\n                    if _valid_register_opcode(v[-2:-1]):\n                        result[\"popret\"] = a+3\n                if \"pop2ret\" not in result:\n                    if _valid_register_opcode(v[-3:-1]):\n                        result[\"pop2ret\"] = a+2\n                if \"pop3ret\" not in result:\n                    if _valid_register_opcode(v[-4:-1]):\n                        result[\"pop3ret\"] = a+1\n                if \"pop4ret\" not in result:\n                    if _valid_register_opcode(v[-5:-1]):\n                        result[\"pop4ret\"] = a\n\n            # search for add esp, byte 0xNN\n            found = self.searchmem(start, end, b\"\\x83\\xc4([^\\xc3]){0,24}\\xc3\", mem)\n            # search for add esp, 0xNNNN\n            found += self.searchmem(start, end, b\"\\x81\\xc4([^\\xc3]){0,24}\\xc3\", mem)\n            for (a, v) in found:\n                if v.startswith(b\"81\"):\n                    offset = to_int(\"0x\" + codecs.encode(codecs.decode(v, 'hex')[2:5][::-1], 'hex').decode('utf-8'))\n                elif v.startswith(b\"83\"):\n                    offset = to_int(\"0x\" + v[4:6].decode('utf-8'))\n                gg = self._verify_rop_gadget(a, a+len(v)//2-1)\n                for (_, c) in gg:\n                    if \"pop\" in c:\n                        offset += 4\n                gadget = \"addesp_%d\" % offset\n                if gadget not in result:\n                    result[gadget] = a\n\n        return result\n\n    def search_jmpcall(self, start, end, regname=None):\n        \"\"\"\n        Search memory for jmp/call reg instructions\n\n        Args:\n            - start: start address (Int)\n            - end: end address (Int)\n            - reg: register name (String)\n\n        Returns:\n            - list of (address(Int), instruction(String))\n        \"\"\"\n\n        result = []\n        REG = {0: \"eax\", 1: \"ecx\", 2: \"edx\", 3: \"ebx\", 4: \"esp\", 5: \"ebp\", 6: \"esi\", 7:\"edi\"}\n        P2REG = {0: \"[eax]\", 1: \"[ecx]\", 2: \"[edx]\", 3: \"[ebx]\", 6: \"[esi]\", 7:\"[edi]\"}\n        OPCODE = {0xe: \"jmp\", 0xd: \"call\"}\n        P2OPCODE = {0x1: \"call\", 0x2: \"jmp\"}\n        JMPREG = [b\"\\xff\" + bytes_chr(i) for i in range(0xe0, 0xe8)]\n        JMPREG += [b\"\\xff\" + bytes_chr(i) for i in range(0x20, 0x28)]\n        CALLREG = [b\"\\xff\" + bytes_chr(i) for i in range(0xd0, 0xd8)]\n        CALLREG += [b\"\\xff\" + bytes_chr(i) for i in range(0x10, 0x18)]\n        JMPCALL = JMPREG + CALLREG\n\n        if regname is None:\n            regname = \"\"\n        regname = regname.lower()\n        pattern = re.compile(b'|'.join(JMPCALL).replace(b' ', b'\\ '))\n        mem = self.dumpmem(start, end)\n        found = pattern.finditer(mem)\n        (arch, bits) = self.getarch()\n        for m in list(found):\n            inst = \"\"\n            addr = start + m.start()\n            opcode = codecs.encode(m.group()[1:2], 'hex')\n            type = int(opcode[0:1], 16)\n            reg = int(opcode[1:2], 16)\n            if type in OPCODE:\n                inst = OPCODE[type] + \" \" + REG[reg]\n\n            if type in P2OPCODE and reg in P2REG:\n                inst = P2OPCODE[type] + \" \" + P2REG[reg]\n\n            if inst != \"\" and regname[-2:] in inst.split()[-1]:\n                if bits == 64:\n                    inst = inst.replace(\"e\", \"r\")\n                result += [(addr, inst)]\n\n        return result\n\n    def search_substr(self, start, end, search, mem=None):\n        \"\"\"\n        Search for substrings of a given string/number in memory\n\n        Args:\n            - start: start address (Int)\n            - end: end address (Int)\n            - search: string to search for (String)\n            - mem: cached memory (raw bytes)\n\n        Returns:\n            - list of tuple (substr(String), address(Int))\n        \"\"\"\n        def substr(s1, s2):\n            \"Search for a string in another string\"\n            s1 = to_binary_string(s1)\n            s2 = to_binary_string(s2)\n            i = 1\n            found = 0\n            while i <= len(s1):\n                if s2.find(s1[:i]) != -1:\n                    found = 1\n                    i += 1\n                    if s1[:i-1][-1:] == b\"\\x00\":\n                        break\n                else:\n                    break\n            if found == 1:\n                return i-1\n            else:\n                return -1\n\n        result = []\n        if end < start:\n            start, end = end, start\n\n        if mem is None:\n            mem = self.dumpmem(start, end)\n\n        if search[:2] == \"0x\": # hex number\n            search = search[2:]\n            if len(search) %2 != 0:\n                search = \"0\" + search\n            search = codecs.decode(search, 'hex')[::-1]\n        search = to_binary_string(decode_string_escape(search))\n        while search:\n            l = len(search)\n            i = substr(search, mem)\n            if i != -1:\n                sub = search[:i]\n                addr = start + mem.find(sub)\n                if not check_badchars(addr):\n                    result.append((sub, addr))\n            else:\n                result.append((search, -1))\n                return result\n            search = search[i:]\n        return result\n\n\n    ##############################\n    #   ROP Payload Generation   #\n    ##############################\n    def payload_copybytes(self, target=None, data=None, template=0):\n        \"\"\"\n        Suggest function for ret2plt exploit and generate payload for it\n\n        Args:\n            - target: address to copy data to (Int)\n            - data: (String)\n        Returns:\n            - python code template (String)\n        \"\"\"\n        result = \"\"\n        funcs = [\"strcpy\", \"sprintf\", \"strncpy\", \"snprintf\", \"memcpy\"]\n\n        symbols = self.elfsymbols()\n        transfer = \"\"\n        for f in funcs:\n            if f+\"@plt\" in symbols:\n                transfer = f\n                break\n        if transfer == \"\":\n            warning_msg(\"No copy function available\")\n            return None\n\n        headers = self.elfheader()\n        start = min([v[0] for (k, v) in headers.items() if v[0] > 0])\n        end = max([v[1] for (k, v) in headers.items() if v[2] != \"data\"])\n        symbols = self.elfsymbol(transfer)\n        if not symbols:\n            warning_msg(\"Unable to find symbols\")\n            return None\n\n        plt_func = transfer + \"_plt\"\n        plt_addr = symbols[transfer+\"@plt\"]\n        gadgets = self.common_rop_gadget()\n        function_template = \"\\n\".join([\n            \"popret = 0x%x\" % gadgets[\"popret\"],\n            \"pop2ret = 0x%x\" % gadgets[\"pop2ret\"],\n            \"pop3ret = 0x%x\" % gadgets[\"pop3ret\"],\n            \"def %s_payload(target, bytes):\" % transfer,\n            \"    %s = 0x%x\" % (plt_func, plt_addr),\n            \"    payload = []\",\n            \"    offset = 0\",\n            \"    for (str, addr) in bytes:\",\n            \"\",\n            ])\n        if \"ncp\" in transfer or \"mem\" in transfer: # memcpy() style\n            function_template += \"\\n\".join([\n                \"        payload += [%s, pop3ret, target+offset, addr, len(str)]\" % plt_func,\n                \"        offset += len(str)\",\n                ])\n        elif \"snp\" in transfer: # snprintf()\n            function_template += \"\\n\".join([\n                \"        payload += [%s, pop3ret, target+offset, len(str)+1, addr]\" % plt_func,\n                \"        offset += len(str)\",\n                ])\n        else:\n            function_template += \"\\n\".join([\n            \"        payload += [%s, pop2ret, target+offset, addr]\" % plt_func,\n            \"        offset += len(str)\",\n            ])\n        function_template += \"\\n\".join([\"\",\n            \"    return payload\",\n            \"\",\n            \"payload = []\"\n            ])\n\n        if target is None:\n            if template != 0:\n                return function_template\n            else:\n                return \"\"\n\n        #text = \"\\n_payload = []\\n\"\n        text = \"\\n\"\n        mem = self.dumpmem(start, end)\n        bytes = self.search_substr(start, end, data, mem)\n\n        if to_int(target) is not None:\n            target = to_hex(target)\n        text += \"# %s <= %s\\n\" % (target, repr(data))\n        if not bytes:\n            text += \"***Failed***\\n\"\n        else:\n            text += \"bytes = [\\n\"\n            for (s, a) in bytes:\n                if a != -1:\n                    text += \"    (%s, %s),\\n\" % (repr(s), to_hex(a))\n                else:\n                    text += \"    (%s, ***Failed***),\\n\" % repr(s)\n            text += \"\\n\".join([\n                \"]\",\n                \"payload += %s_payload(%s, bytes)\" % (transfer, target),\n                \"\",\n                ])\n\n        return text\n\n\n###########################################################################\nclass PEDACmd(object):\n    \"\"\"\n    Class for PEDA commands that interact with GDB\n    \"\"\"\n    commands = []\n    def __init__(self):\n        # list of all available commands\n        self.commands = [c for c in dir(self) if callable(getattr(self, c)) and not c.startswith(\"_\")]\n\n    ##################\n    #   Misc Utils   #\n    ##################\n    def _missing_argument(self):\n        \"\"\"\n        Raise exception for missing argument, for internal use\n        \"\"\"\n        text = \"missing argument\"\n        error_msg(text)\n        raise Exception(text)\n\n    def _is_running(self):\n        \"\"\"\n        Check if program is running, for internal use\n        \"\"\"\n        pid = peda.getpid()\n        if pid is None:\n            text = \"not running\"\n            warning_msg(text)\n            return None\n            #raise Exception(text)\n        else:\n            return pid\n\n    def reload(self, *arg):\n        \"\"\"\n        Reload PEDA sources, keep current options untouch\n        Usage:\n            MYNAME [name]\n        \"\"\"\n        (modname,) = normalize_argv(arg, 1)\n        # save current PEDA options\n        saved_opt = config.Option\n        peda_path = os.path.dirname(PEDAFILE) + \"/lib/\"\n        if not modname:\n            modname = \"PEDA\" # just for notification\n            ret = peda.execute(\"source %s\" % PEDAFILE)\n        else:\n            if not modname.endswith(\".py\"):\n                modname = modname + \".py\"\n            filepath = \"%s/%s\" % (peda_path, modname)\n            if os.path.exists(filepath):\n                ret = peda.execute(\"source %s\" % filepath)\n                peda.execute(\"source %s\" % PEDAFILE)\n            else:\n                ret = False\n\n        config.Option = saved_opt\n        if ret:\n            msg(\"%s reloaded!\" % modname, \"blue\")\n        else:\n            msg(\"Failed to reload %s source from: %s\" % (modname, peda_path))\n        return\n\n    def _get_helptext(self, *arg):\n        \"\"\"\n        Get the help text, for internal use by help command and other aliases\n        \"\"\"\n\n        (cmd,) = normalize_argv(arg, 1)\n        helptext = \"\"\n        if cmd is None:\n            helptext = red(\"PEDA\", \"bold\") + blue(\" - Python Exploit Development Assistance for GDB\", \"bold\") + \"\\n\"\n            helptext += \"For latest update, check peda project page: %s\\n\" % green(\"https://github.com/longld/peda/\")\n            helptext += \"List of \\\"peda\\\" subcommands, type the subcommand to invoke it:\\n\"\n            i = 0\n            for cmd in self.commands:\n                if cmd.startswith(\"_\"): continue # skip internal use commands\n                func = getattr(self, cmd)\n                helptext += \"%s -- %s\\n\" % (cmd, green(trim(func.__doc__.strip(\"\\n\").splitlines()[0])))\n            helptext += \"\\nType \\\"help\\\" followed by subcommand for full documentation.\"\n        else:\n            if cmd in self.commands:\n                func = getattr(self, cmd)\n                lines = trim(func.__doc__).splitlines()\n                helptext += green(lines[0]) + \"\\n\"\n                for line in lines[1:]:\n                    if \"Usage:\" in line:\n                        helptext += blue(line) + \"\\n\"\n                    else:\n                        helptext += line + \"\\n\"\n            else:\n                for c in self.commands:\n                    if not c.startswith(\"_\") and cmd in c:\n                        func = getattr(self, c)\n                        helptext += \"%s -- %s\\n\" % (c, green(trim(func.__doc__.strip(\"\\n\").splitlines()[0])))\n\n        return helptext\n\n    def help(self, *arg):\n        \"\"\"\n        Print the usage manual for PEDA commands\n        Usage:\n            MYNAME\n            MYNAME command\n        \"\"\"\n\n        msg(self._get_helptext(*arg))\n\n        return\n    help.options = commands\n\n    def pyhelp(self, *arg):\n        \"\"\"\n        Wrapper for python built-in help\n        Usage:\n            MYNAME (enter interactive help)\n            MYNAME help_request\n        \"\"\"\n        (request,) = normalize_argv(arg, 1)\n        if request is None:\n            help()\n            return\n\n        peda_methods = [\"%s\" % c for c in dir(PEDA) if callable(getattr(PEDA, c)) and \\\n                                not c.startswith(\"_\")]\n\n        if request in peda_methods:\n            request = \"peda.%s\" % request\n        try:\n            if request.lower().startswith(\"peda\"):\n                request = eval(request)\n                help(request)\n                return\n\n            if \".\" in request:\n                module, _, function = request.rpartition('.')\n                if module:\n                    module = module.split(\".\")[0]\n                    __import__(module)\n                    mod = sys.modules[module]\n                    if function:\n                        request = getattr(mod, function)\n                    else:\n                        request = mod\n            else:\n                mod = sys.modules['__main__']\n                request = getattr(mod, request)\n\n            # wrapper for python built-in help\n            help(request)\n        except: # fallback to built-in help\n            try:\n                help(request)\n            except Exception as e:\n                if config.Option.get(\"debug\") == \"on\":\n                    msg('Exception (%s): %s' % ('pyhelp', e), \"red\")\n                    traceback.print_exc()\n                msg(\"no Python documentation found for '%s'\" % request)\n\n        return\n    pyhelp.options = [\"%s\" % c for c in dir(PEDA) if callable(getattr(PEDA, c)) and \\\n                        not c.startswith(\"_\")]\n\n    # show [option | args | env]\n    def show(self, *arg):\n        \"\"\"\n        Show various PEDA options and other settings\n        Usage:\n            MYNAME option [optname]\n            MYNAME (show all options)\n            MYNAME args\n            MYNAME env [envname]\n        \"\"\"\n        # show options\n        def _show_option(name=None):\n            if name is None:\n                name = \"\"\n            filename = peda.getfile()\n            if filename:\n               filename = os.path.basename(filename)\n            else:\n                filename = None\n            for (k, v) in sorted(config.Option.show(name).items()):\n                if filename and isinstance(v, str) and \"#FILENAME#\" in v:\n                    v = v.replace(\"#FILENAME#\", filename)\n                msg(\"%s = %s\" % (k, repr(v)))\n            return\n\n        # show args\n        def _show_arg():\n            arg = peda.execute_redirect(\"show args\")\n            arg = arg.split(\"started is \")[1][1:-3]\n            arg = (peda.string_to_argv(arg))\n            if not arg:\n                msg(\"No argument\")\n            for (i, a) in enumerate(arg):\n                text = \"arg[%d]: %s\" % ((i+1), a if is_printable(a) else to_hexstr(a))\n                msg(text)\n            return\n\n        # show envs\n        def _show_env(name=None):\n            if name is None:\n                name = \"\"\n            env = peda.execute_redirect(\"show env\")\n            for line in env.splitlines():\n                (k, v) = line.split(\"=\", 1)\n                if k.startswith(name):\n                    msg(\"%s = %s\" % (k, v if is_printable(v) else to_hexstr(v)))\n            return\n\n        (opt, name) = normalize_argv(arg, 2)\n\n        if opt is None or opt.startswith(\"opt\"):\n            _show_option(name)\n        elif opt.startswith(\"arg\"):\n            _show_arg()\n        elif opt.startswith(\"env\"):\n            _show_env(name)\n        else:\n            msg(\"Unknown show option: %s\" % opt)\n        return\n    show.options = [\"option\", \"arg\", \"env\"]\n\n    # set [option | arg | env]\n    def set(self, *arg):\n        \"\"\"\n        Set various PEDA options and other settings\n        Usage:\n            MYNAME option name value\n            MYNAME arg string\n            MYNAME env name value\n                support input non-printable chars, e.g MYNAME env EGG \"\\\\x90\"*1000\n        \"\"\"\n        # set options\n        def _set_option(name, value):\n            if name in config.Option.options:\n                config.Option.set(name, value)\n                msg(\"%s = %s\" % (name, repr(value)))\n            else:\n                msg(\"Unknown option: %s\" % name)\n            return\n\n        # set args\n        def _set_arg(*arg):\n            cmd = \"set args\"\n            for a in arg:\n                try:\n                    s = eval('%s' % a)\n                    if isinstance(s, six.integer_types + six.string_types):\n                        a = s\n                except:\n                    pass\n                cmd += \" '%s'\" % a\n            peda.execute(cmd)\n            return\n\n        # set env\n        def _set_env(name, value):\n            env = peda.execute_redirect(\"show env\")\n            cmd = \"set env %s \" % name\n            try:\n                value = eval('%s' % value)\n            except:\n                pass\n            cmd += '%s' % value\n            peda.execute(cmd)\n\n            return\n\n        (opt, name, value) = normalize_argv(arg, 3)\n        if opt is None:\n            self._missing_argument()\n\n        if opt.startswith(\"opt\"):\n            if value is None:\n                self._missing_argument()\n            _set_option(name, value)\n        elif opt.startswith(\"arg\"):\n            _set_arg(*arg[1:])\n        elif opt.startswith(\"env\"):\n            _set_env(name, value)\n        else:\n            msg(\"Unknown set option: %s\" % known_args.opt)\n        return\n    set.options = [\"option\", \"arg\", \"env\"]\n\n    def hexprint(self, *arg):\n        \"\"\"\n        Display hexified of data in memory\n        Usage:\n            MYNAME address (display 16 bytes from address)\n            MYNAME address count\n            MYNAME address /count (display \"count\" lines, 16-bytes each)\n        \"\"\"\n        (address, count) = normalize_argv(arg, 2)\n        if address is None:\n            self._missing_argument()\n\n        if count is None:\n            count = 16\n\n        if not to_int(count) and count.startswith(\"/\"):\n            count = to_int(count[1:])\n            count = count * 16 if count else None\n\n        bytes_ = peda.dumpmem(address, address+count)\n        if bytes_ is None:\n            warning_msg(\"cannot retrieve memory content\")\n        else:\n            hexstr = to_hexstr(bytes_)\n            linelen = 16 # display 16-bytes per line\n            i = 0\n            text = \"\"\n            while hexstr:\n                text += '%s : \"%s\"\\n' % (blue(to_address(address+i*linelen)), hexstr[:linelen*4])\n                hexstr = hexstr[linelen*4:]\n                i += 1\n            pager(text)\n\n        return\n\n    def hexdump(self, *arg):\n        \"\"\"\n        Display hex/ascii dump of data in memory\n        Usage:\n            MYNAME address (dump 16 bytes from address)\n            MYNAME address count\n            MYNAME address /count (dump \"count\" lines, 16-bytes each)\n        \"\"\"\n        def ascii_char(ch):\n            if ord(ch) >= 0x20 and ord(ch) < 0x7e:\n                return chr(ord(ch))  # Ensure we return a str\n            else:\n                return \".\"\n\n        (address, count) = normalize_argv(arg, 2)\n        if address is None:\n            self._missing_argument()\n\n        if count is None:\n            count = 16\n\n        if not to_int(count) and count.startswith(\"/\"):\n            count = to_int(count[1:])\n            count = count * 16 if count else None\n\n        bytes_ = peda.dumpmem(address, address+count)\n        if bytes_ is None:\n            warning_msg(\"cannot retrieve memory content\")\n        else:\n            linelen = 16 # display 16-bytes per line\n            i = 0\n            text = \"\"\n            while bytes_:\n                buf = bytes_[:linelen]\n                hexbytes = \" \".join([\"%02x\" % ord(c) for c in bytes_iterator(buf)])\n                asciibytes = \"\".join([ascii_char(c) for c in bytes_iterator(buf)])\n                text += '%s : %s  %s\\n' % (blue(to_address(address+i*linelen)), hexbytes.ljust(linelen*3), asciibytes)\n                bytes_ = bytes_[linelen:]\n                i += 1\n            pager(text)\n\n        return\n\n    def aslr(self, *arg):\n        \"\"\"\n        Show/set ASLR setting of GDB\n        Usage:\n            MYNAME [on|off]\n        \"\"\"\n        (option,) = normalize_argv(arg, 1)\n        if option is None:\n            out = peda.execute_redirect(\"show disable-randomization\")\n            if not out:\n                warning_msg(\"ASLR setting is unknown or not available\")\n                return\n\n            if \"is off\" in out:\n                msg(\"ASLR is %s\" % green(\"ON\"))\n            if \"is on\" in out:\n                msg(\"ASLR is %s\" % red(\"OFF\"))\n        else:\n            option = option.strip().lower()\n            if option in [\"on\", \"off\"]:\n                peda.execute(\"set disable-randomization %s\" % (\"off\" if option == \"on\" else \"on\"))\n\n        return\n\n    def xprint(self, *arg):\n        \"\"\"\n        Extra support to GDB's print command\n        Usage:\n            MYNAME expression\n        \"\"\"\n        text = \"\"\n        exp = \" \".join(list(arg))\n        m = re.search(\".*\\[(.*)\\]|.*?s:(0x[^ ]*)\", exp)\n        if m:\n            addr = peda.parse_and_eval(m.group(1))\n            if to_int(addr):\n                text += \"[0x%x]: \" % to_int(addr)\n\n        out = peda.parse_and_eval(exp)\n        if to_int(out):\n            chain = peda.examine_mem_reference(to_int(out))\n            text += format_reference_chain(chain)\n        msg(text)\n        return\n\n    def distance(self, *arg):\n        \"\"\"\n        Calculate distance between two addresses\n        Usage:\n            MYNAME address (calculate from current $SP to address)\n            MYNAME address1 address2\n        \"\"\"\n        (start, end) = normalize_argv(arg, 2)\n        if to_int(start) is None or (to_int(end) is None and not self._is_running()):\n            self._missing_argument()\n\n        sp = None\n        if end is None:\n            sp = peda.getreg(\"sp\")\n            end = start\n            start = sp\n\n        dist = end - start\n        text = \"From 0x%x%s to 0x%x: \" % (start, \" (SP)\" if start == sp else \"\",  end)\n        text += \"%d bytes, %d dwords%s\" % (dist, dist//4, \" (+%d bytes)\" % (dist%4) if (dist%4 != 0) else \"\")\n        msg(text)\n\n        return\n\n    def session(self, *arg):\n        \"\"\"\n        Save/restore a working gdb session to file as a script\n        Usage:\n            MYNAME save [filename]\n            MYNAME restore [filename]\n        \"\"\"\n        options = [\"save\", \"restore\", \"autosave\"]\n        (option, filename) = normalize_argv(arg, 2)\n        if option not in options:\n            self._missing_argument()\n\n        if not filename:\n            filename = peda.get_config_filename(\"session\")\n\n        if option == \"save\":\n            if peda.save_session(filename):\n                msg(\"Saved GDB session to file %s\" % filename)\n            else:\n                msg(\"Failed to save GDB session\")\n\n        if option == \"restore\":\n            if peda.restore_session(filename):\n                msg(\"Restored GDB session from file %s\" % filename)\n            else:\n                msg(\"Failed to restore GDB session\")\n\n        if option == \"autosave\":\n            if config.Option.get(\"autosave\") == \"on\":\n                peda.save_session(filename)\n\n        return\n    session.options = [\"save\", \"restore\"]\n\n    #################################\n    #   Debugging Helper Commands   #\n    #################################\n    def procinfo(self, *arg):\n        \"\"\"\n        Display various info from /proc/pid/\n        Usage:\n            MYNAME [pid]\n        \"\"\"\n        options = [\"exe\", \"fd\", \"pid\", \"ppid\", \"uid\", \"gid\"]\n\n        if peda.getos() != \"Linux\":\n            warning_msg(\"this command is only available on Linux\")\n\n        (pid,) = normalize_argv(arg, 1)\n\n        if not pid:\n            pid = peda.getpid()\n\n        if not pid:\n            return\n\n        info = {}\n        try:\n            info[\"exe\"] = os.path.realpath(\"/proc/%d/exe\" % pid)\n        except:\n            warning_msg(\"cannot access /proc/%d/\" % pid)\n            return\n\n        # fd list\n        info[\"fd\"] = {}\n        fdlist = os.listdir(\"/proc/%d/fd\" % pid)\n        for fd in fdlist:\n            rpath = os.readlink(\"/proc/%d/fd/%s\" % (pid, fd))\n            sock = re.search(\"socket:\\[(.*)\\]\", rpath)\n            if sock:\n                spath = execute_external_command(\"netstat -aen | grep %s\" % sock.group(1))\n                if spath:\n                    rpath = spath.strip()\n            info[\"fd\"][to_int(fd)] = rpath\n\n        # uid/gid, pid, ppid\n        info[\"pid\"] = pid\n        status = open(\"/proc/%d/status\" % pid).read()\n        ppid = re.search(\"PPid:\\s*([^\\s]*)\", status).group(1)\n        info[\"ppid\"] = to_int(ppid) if ppid else -1\n        uid = re.search(\"Uid:\\s*([^\\n]*)\", status).group(1)\n        info[\"uid\"] = [to_int(id) for id in uid.split()]\n        gid = re.search(\"Gid:\\s*([^\\n]*)\", status).group(1)\n        info[\"gid\"] = [to_int(id) for id in gid.split()]\n\n        for opt in options:\n            if opt == \"fd\":\n                for (fd, path) in info[opt].items():\n                    msg(\"fd[%d] -> %s\" % (fd, path))\n            else:\n                msg(\"%s = %s\" % (opt, info[opt]))\n        return\n\n    # getfile()\n    def getfile(self):\n        \"\"\"\n        Get exec filename of current debugged process\n        Usage:\n            MYNAME\n        \"\"\"\n        filename = peda.getfile()\n        if filename == None:\n            msg(\"No file specified\")\n        else:\n            msg(filename)\n        return\n\n    # getpid()\n    def getpid(self):\n        \"\"\"\n        Get PID of current debugged process\n        Usage:\n            MYNAME\n        \"\"\"\n        pid = self._is_running()\n        msg(pid)\n        return\n\n    # disassemble()\n    def pdisass(self, *arg):\n        \"\"\"\n        Format output of gdb disassemble command with colors\n        Usage:\n            MYNAME \"args for gdb disassemble command\"\n            MYNAME address /NN: equivalent to \"x/NNi address\"\n        \"\"\"\n        (address, fmt_count) = normalize_argv(arg, 2)\n        if isinstance(fmt_count, str) and fmt_count.startswith(\"/\"):\n            count = to_int(fmt_count[1:])\n            if not count or to_int(address) is None:\n                self._missing_argument()\n            else:\n                code = peda.get_disasm(address, count)\n        else:\n            code = peda.disassemble(*arg)\n        msg(format_disasm_code(code))\n\n        return\n\n    # disassemble_around\n    def nearpc(self, *arg):\n        \"\"\"\n        Disassemble instructions nearby current PC or given address\n        Usage:\n            MYNAME [count]\n            MYNAME address [count]\n                count is maximum 256\n        \"\"\"\n        (address, count) = normalize_argv(arg, 2)\n        address = to_int(address)\n\n        count = to_int(count)\n        if address is not None and address < 0x40000:\n            count = address\n            address = None\n\n        if address is None:\n            address = peda.getreg(\"pc\")\n\n        if count is None:\n            code = peda.disassemble_around(address)\n        else:\n            code = peda.disassemble_around(address, count)\n\n        if code:\n            msg(format_disasm_code(code, address))\n        else:\n            error_msg(\"invalid $pc address or instruction count\")\n        return\n\n    def waitfor(self, *arg):\n        \"\"\"\n        Try to attach to new forked process; mimic \"attach -waitfor\"\n        Usage:\n            MYNAME [cmdname]\n            MYNAME [cmdname] -c (auto continue after attached)\n        \"\"\"\n        (name, opt) = normalize_argv(arg, 2)\n        if name == \"-c\":\n            opt = name\n            name = None\n\n        if name is None:\n            filename = peda.getfile()\n            if filename is None:\n                warning_msg(\"please specify the file to debug or process name to attach\")\n                return\n            else:\n                name = os.path.basename(filename)\n\n        msg(\"Trying to attach to new forked process (%s), Ctrl-C to stop...\" % name)\n        cmd = \"ps axo pid,command | grep %s | grep -v grep\" % name\n        getpids = []\n        out = execute_external_command(cmd)\n        for line in out.splitlines():\n            getpids += [line.split()[0].strip()]\n\n        while True:\n            found = 0\n            out = execute_external_command(cmd)\n            for line in out.splitlines():\n                line = line.split()\n                pid = line[0].strip()\n                cmdname = line[1].strip()\n                if name not in cmdname: continue\n                if pid not in getpids:\n                    found = 1\n                    break\n\n            if found == 1:\n                msg(\"Attching to pid: %s, cmdname: %s\" % (pid, cmdname))\n                if peda.getpid():\n                    peda.execute(\"detach\")\n                out = peda.execute_redirect(\"attach %s\" % pid)\n                msg(out)\n                out = peda.execute_redirect(\"file %s\" % cmdname) # reload symbol file\n                msg(out)\n                if opt == \"-c\":\n                    peda.execute(\"continue\")\n                return\n            time.sleep(0.5)\n        return\n\n    def pltbreak(self, *arg):\n        \"\"\"\n        Set breakpoint at PLT functions match name regex\n        Usage:\n            MYNAME [name]\n        \"\"\"\n        (name,) = normalize_argv(arg, 1)\n        if not name:\n            name = \"\"\n        headers = peda.elfheader()\n        end = headers[\".bss\"]\n        symbols = peda.elfsymbol(name)\n        if len(symbols) == 0:\n            msg(\"File not specified or PLT symbols not found\")\n            return\n        else:\n            # Traverse symbols in order to have more predictable output\n            for symname in sorted(symbols):\n                if \"plt\" not in symname: continue\n                if name in symname:  # fixme(longld) bounds checking?\n                    line = peda.execute_redirect(\"break %s\" % symname)\n                    msg(\"%s (%s)\" % (line.strip(\"\\n\"), symname))\n        return\n\n    def xrefs(self, *arg):\n        \"\"\"\n        Search for all call/data access references to a function/variable\n        Usage:\n            MYNAME pattern\n            MYNAME pattern file/mapname\n        \"\"\"\n        (search, filename) = normalize_argv(arg, 2)\n        if search is None:\n            search = \"\" # search for all call references\n        else:\n            search = arg[0]\n\n        if filename is not None: # get full path to file if mapname is provided\n            vmap = peda.get_vmmap(filename)\n            if vmap:\n                filename = vmap[0][3]\n\n        result = peda.xrefs(search, filename)\n        if result:\n            if search != \"\":\n                msg(\"All references to '%s':\" % search)\n            else:\n                msg(\"All call references\")\n            for (addr, code) in result:\n                msg(\"%s\" % (code))\n        else:\n            msg(\"Not found\")\n        return\n\n    def deactive(self, *arg):\n        \"\"\"\n        Bypass a function by ignoring its execution (eg sleep/alarm)\n        Usage:\n            MYNAME function\n            MYNAME function del (re-active)\n        \"\"\"\n        (function, action) = normalize_argv(arg, 2)\n        if function is None:\n            self._missing_argument()\n\n        if to_int(function):\n            function = \"0x%x\" % function\n\n        bnum = \"$deactive_%s_bnum\" % function\n        if action and \"del\" in action:\n            peda.execute(\"delete %s\" % bnum)\n            peda.execute(\"set %s = \\\"void\\\"\" % bnum)\n            msg(\"'%s' re-activated\" % function)\n            return\n\n        if \"void\" not in peda.execute_redirect(\"p %s\" % bnum):\n            out = peda.execute_redirect(\"info breakpoints %s\" % bnum)\n            if out:\n                msg(\"Already deactivated '%s'\" % function)\n                msg(out)\n                return\n            else:\n                peda.execute(\"set %s = \\\"void\\\"\" % bnum)\n\n        (arch, bits) = peda.getarch()\n        if not function.startswith(\"0x\"): # named function\n            symbol = peda.elfsymbol(function)\n            if not symbol:\n                warning_msg(\"cannot retrieve info of function '%s'\" % function)\n                return\n            peda.execute(\"break *0x%x\" % symbol[function + \"@plt\"])\n\n        else: # addressed function\n            peda.execute(\"break *%s\" % function)\n\n        peda.execute(\"set %s = $bpnum\" % bnum)\n        tmpfd = tmpfile()\n        if \"i386\" in arch:\n            tmpfd.write(\"\\n\".join([\n                \"commands $bpnum\",\n                \"silent\",\n                \"set $eax = 0\",\n                \"return\",\n                \"continue\",\n                \"end\"]))\n        if \"64\" in arch:\n            tmpfd.write(\"\\n\".join([\n                \"commands $bpnum\",\n                \"silent\",\n                \"set $rax = 0\",\n                \"return\",\n                \"continue\",\n                \"end\"]))\n        tmpfd.flush()\n        peda.execute(\"source %s\" % tmpfd.name)\n        tmpfd.close()\n        out = peda.execute_redirect(\"info breakpoints %s\" % bnum)\n        if out:\n            msg(\"'%s' deactivated\" % function)\n            msg(out)\n        return\n\n    def unptrace(self, *arg):\n        \"\"\"\n        Disable anti-ptrace detection\n        Usage:\n            MYNAME\n            MYNAME del\n        \"\"\"\n        (action,) = normalize_argv(arg, 1)\n\n        self.deactive(\"ptrace\", action)\n\n        if not action and \"void\" in peda.execute_redirect(\"p $deactive_ptrace_bnum\"):\n        # cannot deactive vi plt entry, try syscall method\n            msg(\"Try to patch 'ptrace' via syscall\")\n            peda.execute(\"catch syscall ptrace\")\n            peda.execute(\"set $deactive_ptrace_bnum = $bpnum\")\n            tmpfd = tmpfile()\n            (arch, bits) = peda.getarch()\n            if \"i386\" in arch:\n                tmpfd.write(\"\\n\".join([\n                    \"commands $bpnum\",\n                    \"silent\",\n                    \"if (*(int*)($esp+4) == 0 || $ebx == 0)\",\n                    \"    set $eax = 0\",\n                    \"end\",\n                    \"continue\",\n                    \"end\"]))\n            if \"64\" in arch:\n                tmpfd.write(\"\\n\".join([\n                    \"commands $bpnum\",\n                    \"silent\",\n                    \"if ($rdi == 0)\",\n                    \"    set $rax = 0\",\n                    \"end\",\n                    \"continue\",\n                    \"end\"]))\n            tmpfd.flush()\n            peda.execute(\"source %s\" % tmpfd.name)\n            tmpfd.close()\n            out = peda.execute_redirect(\"info breakpoints $deactive_ptrace_bnum\")\n            if out:\n                msg(\"'ptrace' deactivated\")\n                msg(out)\n        return\n\n    # get_function_args()\n    def dumpargs(self, *arg):\n        \"\"\"\n        Display arguments passed to a function when stopped at a call instruction\n        Usage:\n            MYNAME [count]\n                count: force to display \"count args\" instead of guessing\n        \"\"\"\n\n        (count,) = normalize_argv(arg, 1)\n        if not self._is_running():\n            return\n\n        args = peda.get_function_args(count)\n        if args:\n            msg(\"Guessed arguments:\")\n            for (i, a) in enumerate(args):\n                chain = peda.examine_mem_reference(a)\n                msg(\"arg[%d]: %s\" % (i, format_reference_chain(chain)))\n        else:\n            msg(\"No argument\")\n\n        return\n\n    def xuntil(self, *arg):\n        \"\"\"\n        Continue execution until an address or function\n        Usage:\n            MYNAME address | function\n        \"\"\"\n        (address,) = normalize_argv(arg, 1)\n        if to_int(address) is None:\n            peda.execute(\"tbreak %s\" % address)\n        else:\n            peda.execute(\"tbreak *0x%x\" % address)\n        pc = peda.getreg(\"pc\")\n        if pc is None:\n            peda.execute(\"run\")\n        else:\n            peda.execute(\"continue\")\n        return\n\n    def goto(self, *arg):\n        \"\"\"\n        Continue execution at an address\n        Usage:\n            MYNAME address\n        \"\"\"\n        (address,) = normalize_argv(arg, 1)\n        if to_int(address) is None:\n            self._missing_argument()\n\n        peda.execute(\"set $pc = 0x%x\" % address)\n        peda.execute(\"stop\")\n        return\n\n    def skipi(self, *arg):\n        \"\"\"\n        Skip execution of next count instructions\n        Usage:\n            MYNAME [count]\n        \"\"\"\n        (count,) = normalize_argv(arg, 1)\n        if to_int(count) is None:\n            count = 1\n\n        if not self._is_running():\n            return\n\n        next_code = peda.next_inst(peda.getreg(\"pc\"), count)\n        if not next_code:\n            warning_msg(\"failed to get next instructions\")\n            return\n        last_addr = next_code[-1][0]\n        peda.execute(\"set $pc = 0x%x\" % last_addr)\n        peda.execute(\"stop\")\n        return\n\n    def start(self, *arg):\n        \"\"\"\n        Start debugged program and stop at most convenient entry\n        Usage:\n            MYNAME\n        \"\"\"\n        entries = [\"main\"]\n        main_addr = peda.main_entry()\n        if main_addr:\n            entries += [\"*0x%x\" % main_addr]\n        entries += [\"__libc_start_main@plt\"]\n        entries += [\"_start\"]\n        entries += [\"_init\"]\n\n        started = 0\n        for e in entries:\n            out = peda.execute_redirect(\"tbreak %s\" % e)\n            if out and \"breakpoint\" in out:\n                peda.execute(\"run %s\" % ' '.join(arg))\n                started = 1\n                break\n\n        if not started: # try ELF entry point or just \"run\" as the last resort\n            elf_entry = peda.elfentry()\n            if elf_entry:\n                out = peda.execute_redirect(\"tbreak *%s\" % elf_entry)\n\n            peda.execute(\"run\")\n\n        return\n\n    # stepuntil()\n    def stepuntil(self, *arg):\n        \"\"\"\n        Step until a desired instruction in specific memory range\n        Usage:\n            MYNAME \"inst1,inst2\" (step to next inst in binary)\n            MYNAME \"inst1,inst2\" mapname1,mapname2\n        \"\"\"\n        (insts, mapname) = normalize_argv(arg, 2)\n        if insts is None:\n            self._missing_argument()\n\n        if not self._is_running():\n            return\n\n        peda.save_user_command(\"hook-stop\") # disable hook-stop to speedup\n        msg(\"Stepping through, Ctrl-C to stop...\")\n        result = peda.stepuntil(insts, mapname)\n        peda.restore_user_command(\"hook-stop\")\n\n        if result:\n            peda.execute(\"stop\")\n        return\n\n    # wrapper for stepuntil(\"call\")\n    def nextcall(self, *arg):\n        \"\"\"\n        Step until next 'call' instruction in specific memory range\n        Usage:\n            MYNAME [keyword] [mapname1,mapname2]\n        \"\"\"\n        (keyword, mapname) = normalize_argv(arg, 2)\n\n        if keyword:\n            self.stepuntil(\"call.*%s\" % keyword, mapname)\n        else:\n            self.stepuntil(\"call\", mapname)\n        return\n\n    # wrapper for stepuntil(\"j\")\n    def nextjmp(self, *arg):\n        \"\"\"\n        Step until next 'j*' instruction in specific memory range\n        Usage:\n            MYNAME [keyword] [mapname1,mapname2]\n        \"\"\"\n        (keyword, mapname) = normalize_argv(arg, 2)\n\n        if keyword:\n            self.stepuntil(\"j.*%s\" % keyword, mapname)\n        else:\n            self.stepuntil(\"j\", mapname)\n        return\n\n    #stepuntil()\n    def tracecall(self, *arg):\n        \"\"\"\n        Trace function calls made by the program\n        Usage:\n            MYNAME [\"func1,func2\"] [mapname1,mapname2]\n            MYNAME [\"-func1,func2\"] [mapname1,mapname2] (inverse)\n                default is to trace internal calls made by the program\n        \"\"\"\n        (funcs, mapname) = normalize_argv(arg, 2)\n\n        if not self._is_running():\n            return\n\n        if not mapname:\n            mapname = \"binary\"\n\n        fnames = [\"\"]\n        if funcs:\n            if to_int(funcs):\n                funcs = \"0x%x\" % funcs\n            fnames = funcs.replace(\",\", \" \").split()\n        for (idx, fn) in enumerate(fnames):\n            if to_int(fn):\n                fnames[idx] = \"0x%x\" % to_int(fn)\n\n        inverse = 0\n        for (idx, fn) in enumerate(fnames):\n            if fn.startswith(\"-\"): # inverse trace\n                fnames[idx] = fn[1:]\n                inverse = 1\n\n        binname = peda.getfile()\n        logname = peda.get_config_filename(\"tracelog\")\n\n        if mapname is None:\n            mapname = binname\n\n        peda.save_user_command(\"hook-stop\") # disable hook-stop to speedup\n        msg(\"Tracing calls %s '%s', Ctrl-C to stop...\" % (\"match\" if not inverse else \"not match\", \",\".join(fnames)))\n        prev_depth = peda.backtrace_depth(peda.getreg(\"sp\"))\n\n        logfd = open(logname, \"w\")\n        while True:\n            result = peda.stepuntil(\"call\", mapname, prev_depth)\n            if result is None:\n                break\n            (call_depth, code) = result\n            prev_depth += call_depth\n            if not code.startswith(\"=>\"):\n                break\n\n            if not inverse:\n                matched = False\n                for fn in fnames:\n                    fn = fn.strip()\n                    if re.search(fn, code.split(\":\\t\")[-1]):\n                        matched = True\n                        break\n            else:\n                matched = True\n                for fn in fnames:\n                    fn = fn.strip()\n                    if re.search(fn, code.split(\":\\t\")[-1]):\n                        matched = False\n                        break\n\n            if matched:\n                code = format_disasm_code(code)\n                msg(\"%s%s%s\" % (\" \"*(prev_depth-1), \" dep:%02d \" % (prev_depth-1), colorize(code.strip())), teefd=logfd)\n                args = peda.get_function_args()\n                if args:\n                    for (i, a) in enumerate(args):\n                        chain = peda.examine_mem_reference(a)\n                        text = \"%s        |-- arg[%d]: %s\" % (\" \"*(prev_depth-1), i, format_reference_chain(chain))\n                        msg(text, teefd=logfd)\n\n        msg(code, \"red\")\n        peda.restore_user_command(\"hook-stop\")\n        if \"STOP\" not in peda.get_status():\n            peda.execute(\"stop\")\n        logfd.close()\n        msg(\"Saved trace information in file %s, view with 'less -r file'\" % logname)\n        return\n\n    # stepuntil()\n    def traceinst(self, *arg):\n        \"\"\"\n        Trace specific instructions executed by the program\n        Usage:\n            MYNAME [\"inst1,inst2\"] [mapname1,mapname2]\n            MYNAME count (trace execution of next count instrcutions)\n                default is to trace instructions inside the program\n        \"\"\"\n        (insts, mapname) = normalize_argv(arg, 2)\n\n        if not self._is_running():\n            return\n\n        if not mapname:\n            mapname = \"binary\"\n\n        instlist = [\".*\"]\n        count = -1\n        if insts:\n            if to_int(insts):\n                count = insts\n            else:\n                instlist = insts.replace(\",\", \" \").split()\n\n        binname = peda.getfile()\n        logname = peda.get_config_filename(\"tracelog\")\n\n        if mapname is None:\n            mapname = binname\n\n        peda.save_user_command(\"hook-stop\") # disable hook-stop to speedup\n        msg(\"Tracing instructions match '%s', Ctrl-C to stop...\" % (\",\".join(instlist)))\n        prev_depth = peda.backtrace_depth(peda.getreg(\"sp\"))\n        logfd = open(logname, \"w\")\n\n        p = re.compile(\".*?:\\s*[^ ]*\\s*([^,]*),(.*)\")\n        while count:\n            result = peda.stepuntil(\",\".join(instlist), mapname, prev_depth)\n            if result is None:\n                break\n            (call_depth, code) = result\n            prev_depth += call_depth\n            if not code.startswith(\"=>\"):\n                break\n\n            # special case for JUMP inst\n            prev_code = \"\"\n            if re.search(\"j[^m]\", code.split(\":\\t\")[-1].split()[0]):\n                prev_insts = peda.prev_inst(peda.getreg(\"pc\"))\n                if prev_insts:\n                    prev_code = \"0x%x:%s\" % prev_insts[0]\n                    msg(\"%s%s%s\" % (\" \"*(prev_depth-1), \" dep:%02d    \" % (prev_depth-1), prev_code), teefd=logfd)\n\n            text = \"%s%s%s\" % (\" \"*(prev_depth-1), \" dep:%02d \" % (prev_depth-1), code.strip())\n            msg(text, teefd=logfd)\n\n            if re.search(\"call\", code.split(\":\\t\")[-1].split()[0]):\n                args = peda.get_function_args()\n                if args:\n                    for (i, a) in enumerate(args):\n                        chain = peda.examine_mem_reference(a)\n                        text = \"%s        |-- arg[%d]: %s\" % (\" \"*(prev_depth-1), i, format_reference_chain(chain))\n                        msg(text, teefd=logfd)\n\n            # get registers info if any\n            (arch, bits) = peda.getarch()\n            code = code.split(\"#\")[0].strip(\"=>\")\n            if prev_code:\n                m = p.search(prev_code)\n            else:\n                m = p.search(code)\n\n            if m:\n                for op in m.groups():\n                    if op.startswith(\"0x\"): continue\n                    v = to_int(peda.parse_and_eval(op))\n                    chain = peda.examine_mem_reference(v)\n                    text = \"%s        |-- %03s: %s\" % (\" \"*(prev_depth-1), op, format_reference_chain(chain))\n                    msg(text, teefd=logfd)\n\n            count -= 1\n\n        msg(code, \"red\")\n        peda.restore_user_command(\"hook-stop\")\n        logfd.close()\n        msg(\"Saved trace information in file %s, view with 'less -r file'\" % logname)\n        return\n\n    def profile(self, *arg):\n        \"\"\"\n        Simple profiling to count executed instructions in the program\n        Usage:\n            MYNAME count [keyword]\n                default is to count instructions inside the program only\n                count = 0: run until end of execution\n                keyword: only display stats for instructions matched it\n        \"\"\"\n        (count, keyword) = normalize_argv(arg, 2)\n\n        if count is None:\n            self._missing_argument()\n\n        if not self._is_running():\n            return\n\n        if keyword is None or keyword == \"all\":\n            keyword = \"\"\n\n        keyword = keyword.replace(\" \", \"\").split(\",\")\n\n        peda.save_user_command(\"hook-stop\") # disable hook-stop to speedup\n        msg(\"Stepping %s instructions, Ctrl-C to stop...\" % (\"%d\" % count if count else \"all\"))\n\n        if count == 0:\n            count = -1\n        stats = {}\n        total = 0\n        binmap = peda.get_vmmap(\"binary\")\n        try:\n            while count != 0:\n                pc = peda.getreg(\"pc\")\n                if not peda.is_address(pc):\n                    break\n                code = peda.get_disasm(pc)\n                if not code:\n                    break\n                if peda.is_address(pc, binmap):\n                    for k in keyword:\n                        if k in code.split(\":\\t\")[-1]:\n                            code = code.strip(\"=>\").strip()\n                            stats.setdefault(code, 0)\n                            stats[code] += 1\n                            break\n                    peda.execute_redirect(\"stepi\", silent=True)\n                else:\n                    peda.execute_redirect(\"stepi\", silent=True)\n                    peda.execute_redirect(\"finish\", silent=True)\n                count -= 1\n                total += 1\n        except:\n            pass\n\n        peda.restore_user_command(\"hook-stop\")\n        text = \"Executed %d instructions\\n\" % total\n        text += \"%s %s\\n\" % (blue(\"Run-count\", \"bold\"), blue(\"Instruction\", \"bold\"))\n        for (code, count) in sorted(stats.items(), key = lambda x: x[1], reverse=True):\n            text += \"%8d: %s\\n\" % (count, code)\n        pager(text)\n\n        return\n\n    @msg.bufferize\n    def context_register(self, *arg):\n        \"\"\"\n        Display register information of current execution context\n        Usage:\n            MYNAME\n        \"\"\"\n        if not self._is_running():\n            return\n\n        pc = peda.getreg(\"pc\")\n        # display register info\n        msg(\"[%s]\" % \"registers\".center(78, \"-\"), \"blue\")\n        self.xinfo(\"register\")\n\n        return\n\n    @msg.bufferize\n    def context_code(self, *arg):\n        \"\"\"\n        Display nearby disassembly at $PC of current execution context\n        Usage:\n            MYNAME [linecount]\n        \"\"\"\n        (count,) = normalize_argv(arg, 1)\n\n        if count is None:\n            count = 8\n\n        if not self._is_running():\n            return\n\n        pc = peda.getreg(\"pc\")\n        if peda.is_address(pc):\n            inst = peda.get_disasm(pc)\n        else:\n            inst = None\n\n        text = blue(\"[%s]\" % \"code\".center(78, \"-\"))\n        msg(text)\n        if inst: # valid $PC\n            text = \"\"\n            opcode = inst.split(\":\\t\")[-1].split()[0]\n            # stopped at function call\n            if \"call\" in opcode:\n                text += peda.disassemble_around(pc, count)\n                msg(format_disasm_code(text, pc))\n                self.dumpargs()\n            # stopped at jump\n            elif \"j\" in opcode:\n                jumpto = peda.testjump(inst)\n                if jumpto: # JUMP is taken\n                    code = peda.disassemble_around(pc, count)\n                    code = code.splitlines()\n                    pc_idx = 999\n                    for (idx, line) in enumerate(code):\n                        if (\"0x%x\" % pc) in line.split(\":\")[0]:\n                            pc_idx = idx\n                        if idx <= pc_idx:\n                            text += line + \"\\n\"\n                        else:\n                            text += \" | %s\\n\" % line.strip()\n                    text = format_disasm_code(text, pc) + \"\\n\"\n                    text += \" |->\"\n                    code = peda.get_disasm(jumpto, count//2)\n                    if not code:\n                        code = \"   Cannot evaluate jump destination\\n\"\n\n                    code = code.splitlines()\n                    text += red(code[0]) + \"\\n\"\n                    for line in code[1:]:\n                        text += \"       %s\\n\" % line.strip()\n                    text += red(\"JUMP is taken\".rjust(79))\n                else: # JUMP is NOT taken\n                    text += format_disasm_code(peda.disassemble_around(pc, count), pc)\n                    text += \"\\n\" + green(\"JUMP is NOT taken\".rjust(79))\n\n                msg(text.rstrip())\n            # stopped at other instructions\n            else:\n                text += peda.disassemble_around(pc, count)\n                msg(format_disasm_code(text, pc))\n        else: # invalid $PC\n            msg(\"Invalid $PC address: 0x%x\" % pc, \"red\")\n\n        return\n\n    @msg.bufferize\n    def context_stack(self, *arg):\n        \"\"\"\n        Display stack of current execution context\n        Usage:\n            MYNAME [linecount]\n        \"\"\"\n        (count,) = normalize_argv(arg, 1)\n\n        if not self._is_running():\n            return\n\n        text = blue(\"[%s]\" % \"stack\".center(78, \"-\"))\n        msg(text)\n        sp = peda.getreg(\"sp\")\n        if peda.is_address(sp):\n            self.telescope(sp, count)\n        else:\n            msg(\"Invalid $SP address: 0x%x\" % sp, \"red\")\n\n        return\n\n    def context(self, *arg):\n        \"\"\"\n        Display various information of current execution context\n        Usage:\n            MYNAME [reg,code,stack,all] [code/stack length]\n        \"\"\"\n\n        (opt, count) = normalize_argv(arg, 2)\n\n        if to_int(count) is None:\n            count = 8\n        if opt is None:\n            opt = config.Option.get(\"context\")\n        if opt == \"all\":\n            opt = \"register,code,stack\"\n\n        opt = opt.replace(\" \", \"\").split(\",\")\n\n        if not opt:\n            return\n\n        if not self._is_running():\n            return\n\n        clearscr = config.Option.get(\"clearscr\")\n        if clearscr == \"on\":\n            clearscreen()\n\n        status = peda.get_status()\n        # display registers\n        if \"reg\" in opt or \"register\" in opt:\n            self.context_register()\n\n        # display assembly code\n        if \"code\" in opt:\n            self.context_code(count)\n\n        # display stack content, forced in case SIGSEGV\n        if \"stack\" in opt or \"SIGSEGV\" in status:\n            self.context_stack(count)\n        msg(\"[%s]\" % (\"-\"*78), \"blue\")\n        msg(\"Legend: %s, %s, %s, value\" % (red(\"code\"), blue(\"data\"), green(\"rodata\")))\n\n        # display stopped reason\n        if \"SIG\" in status:\n            msg(\"Stopped reason: %s\" % red(status))\n\n        return\n\n    def breakrva(self, *arg):\n        \"\"\"\n        Set breakpoint by Relative Virtual Address (RVA)\n        Usage:\n            MYNAME rva\n            MYNAME rva module_name (e.g binary, shared module name)\n        \"\"\"\n        (rva, module) = normalize_argv(arg, 2)\n        if rva is None or not to_int(rva):\n            self._missing_argument()\n        if module is None:\n            module = 'binary'\n\n        binmap = peda.get_vmmap(module)\n        if len(binmap) == 0:\n            msg(\"No module matches '%s'\" % module)\n        else:\n            base_address = binmap[0][0]\n            peda.set_breakpoint(base_address+rva)\n        return\n\n    #################################\n    #   Memory Operation Commands   #\n    #################################\n    # get_vmmap()\n    def vmmap(self, *arg):\n        \"\"\"\n        Get virtual mapping address ranges of section(s) in debugged process\n        Usage:\n            MYNAME [mapname] (e.g binary, all, libc, stack)\n            MYNAME address (find mapname contains this address)\n            MYNAME (equiv to cat /proc/pid/maps)\n        \"\"\"\n\n        (mapname,) = normalize_argv(arg, 1)\n        if not self._is_running():\n            maps = peda.get_vmmap()\n        elif to_int(mapname) is None:\n            maps = peda.get_vmmap(mapname)\n        else:\n            addr = to_int(mapname)\n            maps = []\n            allmaps = peda.get_vmmap()\n            if allmaps is not None:\n                for (start, end, perm, name) in allmaps:\n                    if addr >= start and addr < end:\n                        maps += [(start, end, perm, name)]\n\n        if maps is not None and len(maps) > 0:\n            l = 10 if peda.intsize() == 4 else 18\n            msg(\"%s %s %s\\t%s\" % (\"Start\".ljust(l, \" \"), \"End\".ljust(l, \" \"), \"Perm\", \"Name\"), \"blue\", \"bold\")\n            for (start, end, perm, name) in maps:\n                color = \"red\" if \"rwx\" in perm else None\n                msg(\"%s %s %s\\t%s\" % (to_address(start).ljust(l, \" \"), to_address(end).ljust(l, \" \"), perm, name), color)\n        else:\n            warning_msg(\"not found or cannot access procfs\")\n        return\n\n    # writemem()\n    def patch(self, *arg):\n        \"\"\"\n        Patch memory start at an address with string/hexstring/int\n        Usage:\n            MYNAME address (multiple lines input)\n            MYNAME address \"string\"\n            MYNAME from_address to_address \"string\"\n            MYNAME (will patch at current $pc)\n        \"\"\"\n\n        (address, data, byte) = normalize_argv(arg, 3)\n        address = to_int(address)\n        end_address = None\n        if address is None:\n            address = peda.getreg(\"pc\")\n\n        if byte is not None and to_int(data) is not None:\n            end_address, data = to_int(data), byte\n            if end_address < address:\n                address, end_address = end_address, address\n\n        if data is None:\n            data = \"\"\n            while True:\n                line = input(\"patch> \")\n                if line.strip() == \"\": continue\n                if line == \"end\":\n                    break\n                user_input = line.strip()\n                if user_input.startswith(\"0x\"):\n                    data += hex2str(user_input)\n                else:\n                    data += eval(\"%s\" % user_input)\n\n        if to_int(data) is not None:\n            data = hex2str(to_int(data), peda.intsize())\n\n        data = to_binary_string(data)\n        data = data.replace(b\"\\\\\\\\\", b\"\\\\\")\n        if end_address:\n            data *= (end_address-address + 1) // len(data)\n        bytes_ = peda.writemem(address, data)\n        if bytes_ >= 0:\n            msg(\"Written %d bytes to 0x%x\" % (bytes_, address))\n        else:\n            warning_msg(\"Failed to patch memory, try 'set write on' first for offline patching\")\n        return\n\n    # dumpmem()\n    def dumpmem(self, *arg):\n        \"\"\"\n        Dump content of a memory region to raw binary file\n        Usage:\n            MYNAME file start end\n            MYNAME file mapname\n        \"\"\"\n        (filename, start, end) = normalize_argv(arg, 3)\n        if end is not None and to_int(end):\n            if end < start:\n                start, end = end, start\n            ret = peda.execute(\"dump memory %s 0x%x 0x%x\" % (filename, start, end))\n            if not ret:\n                warning_msg(\"failed to dump memory\")\n            else:\n                msg(\"Dumped %d bytes to '%s'\" % (end-start, filename))\n        elif start is not None: # dump by mapname\n            maps = peda.get_vmmap(start)\n            if maps:\n                fd = open(filename, \"wb\")\n                count = 0\n                for (start, end, _, _) in maps:\n                    mem = peda.dumpmem(start, end)\n                    if mem is None: # nullify unreadable memory\n                        mem = \"\\x00\"*(end-start)\n                    fd.write(mem)\n                    count += end - start\n                fd.close()\n                msg(\"Dumped %d bytes to '%s'\" % (count, filename))\n            else:\n                warning_msg(\"invalid mapname\")\n        else:\n            self._missing_argument()\n\n        return\n\n    # loadmem()\n    def loadmem(self, *arg):\n        \"\"\"\n        Load contents of a raw binary file to memory\n        Usage:\n            MYNAME file address [size]\n        \"\"\"\n        mem = \"\"\n        (filename, address, size) = normalize_argv(arg, 3)\n        address = to_int(address)\n        size = to_int(size)\n        if filename is not None:\n            try:\n                mem = open(filename, \"rb\").read()\n            except:\n                pass\n            if mem == \"\":\n                error_msg(\"cannot read data or filename is empty\")\n                return\n            if size is not None and size < len(mem):\n                mem = mem[:size]\n            bytes = peda.writemem(address, mem)\n            if bytes > 0:\n                msg(\"Written %d bytes to 0x%x\" % (bytes, address))\n            else:\n                warning_msg(\"failed to load filename to memory\")\n        else:\n            self._missing_argument()\n        return\n\n    # cmpmem()\n    def cmpmem(self, *arg):\n        \"\"\"\n        Compare content of a memory region with a file\n        Usage:\n            MYNAME start end file\n        \"\"\"\n        (start, end, filename) = normalize_argv(arg, 3)\n        if filename is None:\n            self._missing_argument()\n\n        try:\n            buf = open(filename, \"rb\").read()\n        except:\n            error_msg(\"cannot read data from filename %s\" % filename)\n            return\n\n        result = peda.cmpmem(start, end, buf)\n\n        if result is None:\n            warning_msg(\"failed to perform comparison\")\n        elif result == {}:\n            msg(\"mem and filename are identical\")\n        else:\n            msg(\"--- mem: %s -> %s\" % (arg[0], arg[1]), \"green\", \"bold\")\n            msg(\"+++ filename: %s\" % arg[2], \"blue\", \"bold\")\n            for (addr, bytes_) in result.items():\n                msg(\"@@ 0x%x @@\" % addr, \"red\")\n                line_1 = \"- \"\n                line_2 = \"+ \"\n                for (mem_val, file_val) in bytes_:\n                    m_byte = \"%02X \" % ord(mem_val)\n                    f_byte = \"%02X \" % ord(file_val)\n                    if mem_val == file_val:\n                        line_1 += m_byte\n                        line_2 += f_byte\n                    else:\n                        line_1 += green(m_byte)\n                        line_2 += blue(f_byte)\n                msg(line_1)\n                msg(line_2)\n        return\n\n    # xormem()\n    def xormem(self, *arg):\n        \"\"\"\n        XOR a memory region with a key\n        Usage:\n            MYNAME start end key\n        \"\"\"\n        (start, end, key) = normalize_argv(arg, 3)\n        if key is None:\n            self._missing_argument()\n\n        result = peda.xormem(start, end, key)\n        if result is not None:\n            msg(\"XORed data (first 32 bytes):\")\n            msg('\"' + to_hexstr(result[:32]) + '\"')\n        return\n\n    # searchmem(), searchmem_by_range()\n    def searchmem(self, *arg):\n        \"\"\"\n        Search for a pattern in memory; support regex search\n        Usage:\n            MYNAME pattern start end\n            MYNAME pattern mapname\n        \"\"\"\n        (pattern, start, end) = normalize_argv(arg, 3)\n        (pattern, mapname) = normalize_argv(arg, 2)\n        if pattern is None:\n            self._missing_argument()\n\n        pattern = arg[0]\n        result = []\n        if end is None and to_int(mapname):\n            vmrange = peda.get_vmrange(mapname)\n            if vmrange:\n                (start, end, _, _) = vmrange\n\n        if end is None:\n            msg(\"Searching for %s in: %s ranges\" % (repr(pattern), mapname))\n            result = peda.searchmem_by_range(mapname, pattern)\n        else:\n            msg(\"Searching for %s in range: 0x%x - 0x%x\" % (repr(pattern), start, end))\n            result = peda.searchmem(start, end, pattern)\n\n        text = peda.format_search_result(result)\n        pager(text)\n\n        return\n\n    # search_reference()\n    def refsearch(self, *arg):\n        \"\"\"\n        Search for all references to a value in memory ranges\n        Usage:\n            MYNAME value mapname\n            MYNAME value (search in all memory ranges)\n        \"\"\"\n        (search, mapname) = normalize_argv(arg, 2)\n        if search is None:\n            self._missing_argument()\n\n        search = arg[0]\n        if mapname is None:\n            mapname = \"all\"\n        msg(\"Searching for reference to: %s in: %s ranges\" % (repr(search), mapname))\n        result = peda.search_reference(search, mapname)\n\n        text = peda.format_search_result(result)\n        pager(text)\n\n        return\n\n    # search_address(), search_pointer()\n    def lookup(self, *arg):\n        \"\"\"\n        Search for all addresses/references to addresses which belong to a memory range\n        Usage:\n            MYNAME address searchfor belongto\n            MYNAME pointer searchfor belongto\n        \"\"\"\n        (option, searchfor, belongto) = normalize_argv(arg, 3)\n        if option is None:\n            self._missing_argument()\n\n        result = []\n        if searchfor is None:\n            searchfor = \"stack\"\n        if belongto is None:\n            belongto = \"binary\"\n\n        if option == \"pointer\":\n            msg(\"Searching for pointers on: %s pointed to: %s, this may take minutes to complete...\" % (searchfor, belongto))\n            result = peda.search_pointer(searchfor, belongto)\n        if option == \"address\":\n            msg(\"Searching for addresses on: %s belong to: %s, this may take minutes to complete...\" % (searchfor, belongto))\n            result = peda.search_address(searchfor, belongto)\n\n        text = peda.format_search_result(result, 0)\n        pager(text)\n\n        return\n    lookup.options = [\"address\", \"pointer\"]\n\n    # examine_mem_reference()\n    def telescope(self, *arg):\n        \"\"\"\n        Display memory content at an address with smart dereferences\n        Usage:\n            MYNAME [linecount] (analyze at current $SP)\n            MYNAME address [linecount]\n        \"\"\"\n\n        (address, count) = normalize_argv(arg, 2)\n\n        if self._is_running():\n            sp = peda.getreg(\"sp\")\n        else:\n            sp = None\n\n        if count is None:\n            count = 8\n            if address is None:\n                address = sp\n            elif address < 0x1000:\n                count = address\n                address = sp\n\n        if not address:\n            return\n\n        step = peda.intsize()\n        if not peda.is_address(address): # cannot determine address\n            msg(\"Invalid $SP address: 0x%x\" % address, \"red\")\n            return\n            for i in range(count):\n                if not peda.execute(\"x/%sx 0x%x\" % (\"g\" if step == 8 else \"w\", address + i*step)):\n                    break\n            return\n\n        result = []\n        for i in range(count):\n            value = address + i*step\n            if peda.is_address(value):\n                result += [peda.examine_mem_reference(value)]\n            else:\n                result += [None]\n        idx = 0\n        text = \"\"\n        for chain in result:\n            text += \"%04d| \" % (idx)\n            text += format_reference_chain(chain)\n            text += \"\\n\"\n            idx += step\n\n        pager(text)\n\n        return\n\n    def eflags(self, *arg):\n        \"\"\"\n        Display/set/clear/toggle value of eflags register\n        Usage:\n            MYNAME\n            MYNAME [set|clear|toggle] flagname\n        \"\"\"\n        FLAGS = [\"CF\", \"PF\", \"AF\", \"ZF\", \"SF\", \"TF\", \"IF\", \"DF\", \"OF\"]\n        FLAGS_TEXT = [\"Carry\", \"Parity\", \"Adjust\", \"Zero\", \"Sign\", \"Trap\",\n                        \"Interrupt\", \"Direction\", \"Overflow\"]\n\n        (option, flagname) = normalize_argv(arg, 2)\n        if not self._is_running():\n            return\n\n        elif option and not flagname:\n            self._missing_argument()\n\n        elif option is None: # display eflags\n            flags = peda.get_eflags()\n            text = \"\"\n            for (i, f) in enumerate(FLAGS):\n                if flags[f]:\n                    text += \"%s \" % red(FLAGS_TEXT[i].upper(), \"bold\")\n                else:\n                    text += \"%s \" % green(FLAGS_TEXT[i].lower())\n\n            eflags = peda.getreg(\"eflags\")\n            msg(\"%s: 0x%x (%s)\" % (green(\"EFLAGS\"), eflags, text.strip()))\n\n        elif option == \"set\":\n            peda.set_eflags(flagname, True)\n\n        elif option == \"clear\":\n            peda.set_eflags(flagname, False)\n\n        elif option == \"toggle\":\n            peda.set_eflags(flagname, None)\n\n        return\n    eflags.options = [\"set\", \"clear\", \"toggle\"]\n\n    def xinfo(self, *arg):\n        \"\"\"\n        Display detail information of address/registers\n        Usage:\n            MYNAME address\n            MYNAME register [reg1 reg2]\n        \"\"\"\n\n        (address, regname) = normalize_argv(arg, 2)\n        if address is None:\n            self._missing_argument()\n\n        text = \"\"\n        if not self._is_running():\n            return\n\n        def get_reg_text(r, v):\n            text = green(\"%s\" % r.upper().ljust(3)) + \": \"\n            chain = peda.examine_mem_reference(v)\n            text += format_reference_chain(chain)\n            text += \"\\n\"\n            return text\n\n        (arch, bits) = peda.getarch()\n        if str(address).startswith(\"r\"):\n            # Register\n            regs = peda.getregs(\" \".join(arg[1:]))\n            if regname is None:\n                for r in REGISTERS[bits]:\n                    if r in regs:\n                        text += get_reg_text(r, regs[r])\n            else:\n                for (r, v) in sorted(regs.items()):\n                    text += get_reg_text(r, v)\n            if text:\n                msg(text.strip())\n            if regname is None or \"eflags\" in regname:\n                self.eflags()\n            return\n\n        elif to_int(address) is None:\n            warning_msg(\"not a register nor an address\")\n        else:\n            # Address\n            chain = peda.examine_mem_reference(address, depth=0)\n            text += format_reference_chain(chain) + \"\\n\"\n            vmrange = peda.get_vmrange(address)\n            if vmrange:\n                (start, end, perm, name) = vmrange\n                text += \"Virtual memory mapping:\\n\"\n                text += green(\"Start : %s\\n\" % to_address(start))\n                text += green(\"End   : %s\\n\" % to_address(end))\n                text += yellow(\"Offset: 0x%x\\n\" % (address-start))\n                text += red(\"Perm  : %s\\n\" % perm)\n                text += blue(\"Name  : %s\" % name)\n        msg(text)\n\n        return\n    xinfo.options = [\"register\"]\n\n    def strings(self, *arg):\n        \"\"\"\n        Display printable strings in memory\n        Usage:\n            MYNAME start end [minlen]\n            MYNAME mapname [minlen]\n            MYNAME (display all printable strings in binary - slow)\n        \"\"\"\n        (start, end, minlen) = normalize_argv(arg, 3)\n\n        mapname = None\n        if start is None:\n            mapname = \"binary\"\n        elif to_int(start) is None or (end < start):\n            (mapname, minlen) = normalize_argv(arg, 2)\n\n        if minlen is None:\n            minlen = 1\n\n        if mapname:\n            maps = peda.get_vmmap(mapname)\n        else:\n            maps = [(start, end, None, None)]\n\n        if not maps:\n            warning_msg(\"failed to get memory map for %s\" % mapname)\n            return\n\n        text = \"\"\n        regex_pattern = \"[%s]{%d,}\" % (re.escape(string.printable), minlen)\n        p = re.compile(regex_pattern.encode('utf-8'))\n        for (start, end, _, _) in maps:\n            mem = peda.dumpmem(start, end)\n            if not mem: continue\n            found = p.finditer(mem)\n            if not found: continue\n\n            for m in found:\n                text += \"0x%x: %s\\n\" % (start+m.start(), string_repr(mem[m.start():m.end()].strip(), show_quotes=False))\n\n        pager(text)\n        return\n\n    def sgrep(self, *arg):\n        \"\"\"\n        Search for full strings contain the given pattern\n        Usage:\n            MYNAME pattern start end\n            MYNAME pattern mapname\n            MYNAME pattern\n        \"\"\"\n        (pattern,) = normalize_argv(arg, 1)\n\n        if pattern is None:\n            self._missing_argument()\n        arg = list(arg[1:])\n        if not arg:\n            arg = [\"binary\"]\n\n        pattern = \"[^\\x00]*%s[^\\x00]*\" % pattern\n        self.searchmem(pattern, *arg)\n\n        return\n\n\n    ###############################\n    #   Exploit Helper Commands   #\n    ###############################\n    # elfheader()\n    def elfheader(self, *arg):\n        \"\"\"\n        Get headers information from debugged ELF file\n        Usage:\n            MYNAME [header_name]\n        \"\"\"\n\n        (name,) = normalize_argv(arg, 1)\n        result = peda.elfheader(name)\n        if len(result) == 0:\n            warning_msg(\"%s not found, did you specify the FILE to debug?\" % (name if name else \"headers\"))\n        elif len(result) == 1:\n            (k, (start, end, type)) = list(result.items())[0]\n            msg(\"%s: 0x%x - 0x%x (%s)\" % (k, start, end, type))\n        else:\n            for (k, (start, end, type)) in sorted(result.items(), key=lambda x: x[1]):\n                msg(\"%s = 0x%x\" % (k, start))\n        return\n\n    # readelf_header(), elfheader_solib()\n    def readelf(self, *arg):\n        \"\"\"\n        Get headers information from an ELF file\n        Usage:\n            MYNAME mapname [header_name]\n            MYNAME filename [header_name]\n        \"\"\"\n\n        (filename, hname) = normalize_argv(arg, 2)\n        result = {}\n        maps = peda.get_vmmap()\n        if filename is None: # fallback to elfheader()\n            result = peda.elfheader()\n        else:\n            result = peda.elfheader_solib(filename, hname)\n\n        if not result:\n            result = peda.readelf_header(filename, hname)\n        if len(result) == 0:\n            warning_msg(\"%s or %s not found\" % (filename, hname))\n        elif len(result) == 1:\n            (k, (start, end, type)) = list(result.items())[0]\n            msg(\"%s: 0x%x - 0x%x (%s)\" % (k, start, end, type))\n        else:\n            for (k, (start, end, type)) in sorted(result.items(), key=lambda x: x[1]):\n                msg(\"%s = 0x%x\" % (k, start))\n        return\n\n    # elfsymbol()\n    def elfsymbol(self, *arg):\n        \"\"\"\n        Get non-debugging symbol information from an ELF file\n        Usage:\n            MYNAME symbol_name\n        \"\"\"\n        (name,) = normalize_argv(arg, 1)\n        if not peda.getfile():\n            warning_msg(\"please specify a file to debug\")\n            return\n\n        result = peda.elfsymbol(name)\n        if len(result) == 0:\n            msg(\"'%s': no match found\" % (name if name else \"plt symbols\"))\n        else:\n            if (\"%s@got\" % name) not in result:\n                msg(\"Found %d symbols\" % len(result))\n            else:\n                msg(\"Detail symbol info\")\n            for (k, v) in sorted(result.items(), key=lambda x: x[1]):\n                msg(\"%s = %s\" % (k, \"0x%x\" % v if v else repr(v)))\n        return\n\n    # checksec()\n    def checksec(self, *arg):\n        \"\"\"\n        Check for various security options of binary\n        For full features, use http://www.trapkit.de/tools/checksec.sh\n        Usage:\n            MYNAME [file]\n        \"\"\"\n        (filename,) = normalize_argv(arg, 1)\n        colorcodes = {\n            0: red(\"disabled\"),\n            1: green(\"ENABLED\"),\n            2: yellow(\"Partial\"),\n            3: green(\"FULL\"),\n            4: yellow(\"Dynamic Shared Object\"),\n        }\n\n        result = peda.checksec(filename)\n        if result:\n            for (k, v) in sorted(result.items()):\n                msg(\"%s: %s\" % (k.ljust(10), colorcodes[v]))\n        return\n\n    def nxtest(self, *arg):\n        \"\"\"\n        Perform real NX test to see if it is enabled/supported by OS\n        Usage:\n            MYNAME [address]\n        \"\"\"\n        (address,) = normalize_argv(arg, 1)\n\n        exec_wrapper = peda.execute_redirect(\"show exec-wrapper\").split('\"')[1]\n        if exec_wrapper != \"\":\n            peda.execute(\"unset exec-wrapper\")\n\n        if not peda.getpid(): # start program if not running\n            peda.execute(\"start\")\n\n        # set current PC => address, continue\n        pc = peda.getreg(\"pc\")\n        sp = peda.getreg(\"sp\")\n        if not address:\n            address = sp\n        peda.execute(\"set $pc = 0x%x\" % address)\n        # set value at address => 0xcc\n        peda.execute(\"set *0x%x = 0x%x\" % (address, 0xcccccccc))\n        peda.execute(\"set *0x%x = 0x%x\" % (address+4, 0xcccccccc))\n        out = peda.execute_redirect(\"continue\")\n        text = \"NX test at %s: \" % (to_address(address) if address != sp else \"stack\")\n\n        if out:\n            if \"SIGSEGV\" in out:\n                text += red(\"Non-Executable\")\n            elif \"SIGTRAP\" in out:\n                text += green(\"Executable\")\n        else:\n            text += \"Failed to test\"\n\n        msg(text)\n        # restore exec-wrapper\n        if exec_wrapper != \"\":\n            peda.execute(\"set exec-wrapper %s\" % exec_wrapper)\n\n        return\n\n    # search_asm()\n    def asmsearch(self, *arg):\n        \"\"\"\n        Search for ASM instructions in memory\n        Usage:\n            MYNAME \"asmcode\" start end\n            MYNAME \"asmcode\" mapname\n        \"\"\"\n        (asmcode, start, end) = normalize_argv(arg, 3)\n        if asmcode is None:\n            self._missing_argument()\n\n        if not self._is_running():\n            return\n\n        asmcode = arg[0]\n        result = []\n        if end is None:\n            mapname = start\n            if mapname is None:\n                mapname = \"binary\"\n            maps = peda.get_vmmap(mapname)\n            msg(\"Searching for ASM code: %s in: %s ranges\" % (repr(asmcode), mapname))\n            for (start, end, _, _) in maps:\n                if not peda.is_executable(start, maps): continue # skip non-executable page\n                result += peda.search_asm(start, end, asmcode)\n        else:\n            msg(\"Searching for ASM code: %s in range: 0x%x - 0x%x\" % (repr(asmcode), start, end))\n            result = peda.search_asm(start, end, asmcode)\n\n        text = \"Not found\"\n        if result:\n            text = \"\"\n            for (addr, (byte, code)) in result:\n                text += \"%s : (%s)\\t%s\\n\" % (to_address(addr), byte.decode('utf-8'), code)\n        pager(text)\n\n        return\n\n    # search_asm()\n    def ropsearch(self, *arg):\n        \"\"\"\n        Search for ROP gadgets in memory\n            Note: only for simple gadgets, for full ROP search try: http://ropshell.com\n        Usage:\n            MYNAME \"gadget\" start end\n            MYNAME \"gadget\" pagename\n        \"\"\"\n\n        (asmcode, start, end) = normalize_argv(arg, 3)\n        if asmcode is None:\n            self._missing_argument()\n\n        if not self._is_running():\n            return\n\n        asmcode = arg[0]\n        result = []\n        if end is None:\n            if start is None:\n                mapname = \"binary\"\n            else:\n                mapname = start\n            maps = peda.get_vmmap(mapname)\n            msg(\"Searching for ROP gadget: %s in: %s ranges\" % (repr(asmcode), mapname))\n            for (start, end, _, _) in maps:\n                if not peda.is_executable(start, maps): continue # skip non-executable page\n                result += peda.search_asm(start, end, asmcode, rop=1)\n        else:\n            msg(\"Searching for ROP gadget: %s in range: 0x%x - 0x%x\" % (repr(asmcode), start, end))\n            result = peda.search_asm(start, end, asmcode, rop=1)\n\n        result = sorted(result, key=lambda x: len(x[1][0]))\n        text = \"Not found\"\n        if result:\n            text = \"\"\n            for (addr, (byte, code)) in result:\n                text += \"%s : (%s)\\t%s\\n\" % (to_address(addr), byte, code)\n        pager(text)\n\n        return\n\n    # dumprop()\n    def dumprop(self, *arg):\n        \"\"\"\n        Dump all ROP gadgets in specific memory range\n            Note: only for simple gadgets, for full ROP search try: http://ropshell.com\n            Warning: this can be very slow, do not run for big memory range\n        Usage:\n            MYNAME start end [keyword] [depth]\n            MYNAME mapname [keyword]\n                default gadget instruction depth is: 5\n        \"\"\"\n\n        (start, end, keyword, depth) = normalize_argv(arg, 4)\n        filename = peda.getfile()\n        if filename is None:\n            warning_msg(\"please specify a filename to debug\")\n            return\n\n        filename = os.path.basename(filename)\n        mapname = None\n        if start is None:\n            mapname = \"binary\"\n        elif end is None:\n            mapname = start\n        elif to_int(end) is None:\n            mapname = start\n            keyword = end\n\n        if depth is None:\n            depth = 5\n\n        result = {}\n        warning_msg(\"this can be very slow, do not run for large memory range\")\n        if mapname:\n            maps = peda.get_vmmap(mapname)\n            for (start, end, _, _) in maps:\n                if not peda.is_executable(start, maps): continue # skip non-executable page\n                result.update(peda.dumprop(start, end, keyword))\n        else:\n            result.update(peda.dumprop(start, end, keyword))\n\n        text = \"Not found\"\n        if len(result) > 0:\n            text = \"\"\n            outfile = \"%s-rop.txt\" % filename\n            fd = open(outfile, \"w\")\n            msg(\"Writing ROP gadgets to file: %s ...\" % outfile)\n            for (code, addr) in sorted(result.items(), key = lambda x:len(x[0])):\n                text += \"0x%x: %s\\n\" % (addr, code)\n                fd.write(\"0x%x: %s\\n\" % (addr, code))\n            fd.close()\n\n        pager(text)\n        return\n\n    # common_rop_gadget()\n    def ropgadget(self, *arg):\n        \"\"\"\n        Get common ROP gadgets of binary or library\n        Usage:\n            MYNAME [mapname]\n        \"\"\"\n\n        (mapname,) = normalize_argv(arg, 1)\n        result = peda.common_rop_gadget(mapname)\n        if not result:\n            msg(\"Not found\")\n        else:\n            text = \"\"\n            for (k, v) in sorted(result.items(), key=lambda x: len(x[0]) if not x[0].startswith(\"add\") else int(x[0].split(\"_\")[1])):\n                text += \"%s = 0x%x\\n\" % (k, v)\n            pager(text)\n\n        return\n\n    # search_jmpcall()\n    def jmpcall(self, *arg):\n        \"\"\"\n        Search for JMP/CALL instructions in memory\n        Usage:\n            MYNAME (search all JMP/CALL in current binary)\n            MYNAME reg [mapname]\n            MYNAME reg start end\n        \"\"\"\n\n        (reg, start, end) = normalize_argv(arg, 3)\n        result = []\n        if not self._is_running():\n            return\n\n        mapname = None\n        if start is None:\n            mapname = \"binary\"\n        elif end is None:\n            mapname = start\n\n        if mapname:\n            maps = peda.get_vmmap(mapname)\n            for (start, end, _, _) in maps:\n                if not peda.is_executable(start, maps): continue\n                result += peda.search_jmpcall(start, end, reg)\n        else:\n            result = peda.search_jmpcall(start, end, reg)\n\n        if not result:\n            msg(\"Not found\")\n        else:\n            text = \"\"\n            for (a, v) in result:\n                text += \"0x%x : %s\\n\" % (a, v)\n            pager(text)\n\n        return\n\n    # cyclic_pattern()\n    def pattern_create(self, *arg):\n        \"\"\"\n        Generate a cyclic pattern\n        Set \"pattern\" option for basic/extended pattern type\n        Usage:\n            MYNAME size [file]\n        \"\"\"\n\n        (size, filename) = normalize_argv(arg, 2)\n        if size is None:\n            self._missing_argument()\n\n        pattern = cyclic_pattern(size)\n        if filename is not None:\n            open(filename, \"wb\").write(pattern)\n            msg(\"Writing pattern of %d chars to filename \\\"%s\\\"\" % (len(pattern), filename))\n        else:\n            msg(\"'\" + pattern.decode('utf-8') + \"'\")\n\n        return\n\n    # cyclic_pattern()\n    def pattern_offset(self, *arg):\n        \"\"\"\n        Search for offset of a value in cyclic pattern\n        Set \"pattern\" option for basic/extended pattern type\n        Usage:\n            MYNAME value\n        \"\"\"\n\n        (value,) = normalize_argv(arg, 1)\n        if value is None:\n            self._missing_argument()\n\n        pos = cyclic_pattern_offset(value)\n        if pos is None:\n            msg(\"%s not found in pattern buffer\" % value)\n        else:\n            msg(\"%s found at offset: %d\" % (value, pos))\n\n        return\n\n    # cyclic_pattern(), searchmem_*()\n    def pattern_search(self, *arg):\n        \"\"\"\n        Search a cyclic pattern in registers and memory\n        Set \"pattern\" option for basic/extended pattern type\n        Usage:\n            MYNAME\n        \"\"\"\n        def nearby_offset(v):\n            for offset in range(-128, 128, 4):\n                pos = cyclic_pattern_offset(v + offset)\n                if pos is not None:\n                    return (pos, offset)\n            return None\n\n        if not self._is_running():\n            return\n\n        reg_result = {}\n        regs = peda.getregs()\n\n        # search for registers with value in pattern buffer\n        for (r, v) in regs.items():\n            if len(to_hex(v)) < 8: continue\n            res = nearby_offset(v)\n            if res:\n                reg_result[r] = res\n\n        if reg_result:\n            msg(\"Registers contain pattern buffer:\", \"red\")\n            for (r, (p, o)) in reg_result.items():\n                msg(\"%s+%d found at offset: %d\" % (r.upper(), o, p))\n        else:\n            msg(\"No register contains pattern buffer\")\n\n        # search for registers which point to pattern buffer\n        reg_result = {}\n        for (r, v) in regs.items():\n            if not peda.is_address(v): continue\n            chain = peda.examine_mem_reference(v)\n            (v, t, vn) = chain[-1]\n            if not vn: continue\n            o = cyclic_pattern_offset(vn.strip(\"'\").strip('\"')[:4])\n            if o is not None:\n                reg_result[r] = (len(chain), len(vn)-2, o)\n\n        if reg_result:\n            msg(\"Registers point to pattern buffer:\", \"yellow\")\n            for (r, (d, l, o)) in reg_result.items():\n                msg(\"[%s] %s offset %d - size ~%d\" % (r.upper(), \"-->\"*d, o, l))\n        else:\n            msg(\"No register points to pattern buffer\")\n\n        # search for pattern buffer in memory\n        maps = peda.get_vmmap()\n        search_result = []\n        for (start, end, perm, name) in maps:\n            if \"w\" not in perm: continue # only search in writable memory\n            res = cyclic_pattern_search(peda.dumpmem(start, end))\n            for (a, l, o) in res:\n                a += start\n                search_result += [(a, l, o)]\n\n        sp = peda.getreg(\"sp\")\n        if search_result:\n            msg(\"Pattern buffer found at:\", \"green\")\n            for (a, l, o) in search_result:\n                ranges = peda.get_vmrange(a)\n                text = \"%s : offset %4d - size %4d\" % (to_address(a), o, l)\n                if ranges[3] == \"[stack]\":\n                    text += \" ($sp + %s [%d dwords])\" % (to_hex(a-sp), (a-sp)//4)\n                else:\n                    text += \" (%s)\" % ranges[3]\n                msg(text)\n        else:\n            msg(\"Pattern buffer not found in memory\")\n\n        # search for references to pattern buffer in memory\n        ref_result = []\n        for (a, l, o) in search_result:\n            res = peda.searchmem_by_range(\"all\", \"0x%x\" % a)\n            ref_result += [(x[0], a) for x in res]\n        if len(ref_result) > 0:\n            msg(\"References to pattern buffer found at:\", \"blue\")\n            for (a, v) in ref_result:\n                ranges = peda.get_vmrange(a)\n                text = \"%s : %s\" % (to_address(a), to_address(v))\n                if ranges[3] == \"[stack]\":\n                    text += \" ($sp + %s [%d dwords])\" % (to_hex(a-sp), (a-sp)//4)\n                else:\n                    text += \" (%s)\" % ranges[3]\n                msg(text)\n        else:\n            msg(\"Reference to pattern buffer not found in memory\")\n\n        return\n\n    # cyclic_pattern(), writemem()\n    def pattern_patch(self, *arg):\n        \"\"\"\n        Write a cyclic pattern to memory\n        Set \"pattern\" option for basic/extended pattern type\n        Usage:\n            MYNAME address size\n        \"\"\"\n\n        (address, size) = normalize_argv(arg, 2)\n        if size is None:\n            self._missing_argument()\n\n        pattern = cyclic_pattern(size)\n        num_bytes_written = peda.writemem(address, pattern)\n        if num_bytes_written:\n            msg(\"Written %d chars of cyclic pattern to 0x%x\" % (size, address))\n        else:\n            msg(\"Failed to write to memory\")\n\n        return\n\n    # cyclic_pattern()\n    def pattern_arg(self, *arg):\n        \"\"\"\n        Set argument list with cyclic pattern\n        Set \"pattern\" option for basic/extended pattern type\n        Usage:\n            MYNAME size1 [size2,offset2] ...\n        \"\"\"\n\n        if not arg:\n            self._missing_argument()\n\n        arglist = []\n        for a in arg:\n            (size, offset) = (a + \",\").split(\",\")[:2]\n            if offset:\n                offset = to_int(offset)\n            else:\n                offset = 0\n            size = to_int(size)\n            if size is None or offset is None:\n                self._missing_argument()\n\n            # try to generate unique, non-overlapped patterns\n            if arglist and offset == 0:\n                offset = sum(arglist[-1])\n            arglist += [(size, offset)]\n\n        patterns = []\n        for (s, o) in arglist:\n            patterns += [\"\\'%s\\'\" % cyclic_pattern(s, o).decode('utf-8')]\n        peda.execute(\"set arg %s\" % \" \".join(patterns))\n        msg(\"Set %d arguments to program\" % len(patterns))\n\n        return\n\n    # cyclic_pattern()\n    def pattern_env(self, *arg):\n        \"\"\"\n        Set environment variable with a cyclic pattern\n        Set \"pattern\" option for basic/extended pattern type\n        Usage:\n            MYNAME ENVNAME size[,offset]\n        \"\"\"\n\n        (env, size) = normalize_argv(arg, 2)\n        if size is None:\n            self._missing_argument()\n\n        (size, offset) = (arg[1] + \",\").split(\",\")[:2]\n        size = to_int(size)\n        if offset:\n            offset = to_int(offset)\n        else:\n            offset = 0\n        if size is None or offset is None:\n            self._missing_argument()\n\n        peda.execute(\"set env %s %s\" % (env, cyclic_pattern(size, offset).decode('utf-8')))\n        msg(\"Set environment %s = cyclic_pattern(%d, %d)\" % (env, size, offset))\n\n        return\n\n    def pattern(self, *arg):\n        \"\"\"\n        Generate, search, or write a cyclic pattern to memory\n        Set \"pattern\" option for basic/extended pattern type\n        Usage:\n            MYNAME create size [file]\n            MYNAME offset value\n            MYNAME search\n            MYNAME patch address size\n            MYNAME arg size1 [size2,offset2]\n            MYNAME env size[,offset]\n        \"\"\"\n\n        options = [\"create\", \"offset\", \"search\", \"patch\", \"arg\", \"env\"]\n        (opt,) = normalize_argv(arg, 1)\n        if opt is None or opt not in options:\n            self._missing_argument()\n\n        func = getattr(self, \"pattern_%s\" % opt)\n        func(*arg[1:])\n\n        return\n    pattern.options = [\"create\", \"offset\", \"search\", \"patch\", \"arg\", \"env\"]\n\n    def substr(self, *arg):\n        \"\"\"\n        Search for substrings of a given string/number in memory\n        Commonly used for ret2strcpy ROP exploit\n        Usage:\n            MYNAME \"string\" start end\n            MYNAME \"string\" [mapname] (default is search in current binary)\n        \"\"\"\n        (search, start, end) = normalize_argv(arg, 3)\n        if search is None:\n            self._missing_argument()\n\n        result = []\n        search = arg[0]\n        mapname = None\n        if start is None:\n            mapname = \"binary\"\n        elif end is None:\n            mapname = start\n\n        if mapname:\n            msg(\"Searching for sub strings of: %s in: %s ranges\" % (repr(search), mapname))\n            maps = peda.get_vmmap(mapname)\n            for (start, end, perm, _) in maps:\n                if perm == \"---p\":  # skip private range\n                    continue\n                result = peda.search_substr(start, end, search)\n                if result: # return the first found result\n                    break\n        else:\n            msg(\"Searching for sub strings of: %s in range: 0x%x - 0x%x\" % (repr(search), start, end))\n            result = peda.search_substr(start, end, search)\n\n        if result:\n            msg(\"# (address, target_offset), # value (address=0xffffffff means not found)\")\n            offset = 0\n            for (k, v) in result:\n                msg(\"(0x%x, %d), # %s\" % ((0xffffffff if v == -1 else v), offset, string_repr(k)))\n                offset += len(k)\n        else:\n            msg(\"Not found\")\n\n        return\n\n    def assemble(self, *arg):\n        \"\"\"\n        On the fly assemble and execute instructions using NASM\n        Usage:\n            MYNAME [mode] [address]\n                mode: -b16 / -b32 / -b64\n        \"\"\"\n        (mode, address) = normalize_argv(arg, 2)\n\n        exec_mode = 0\n        write_mode = 0\n        if to_int(mode) is not None:\n            address, mode = mode, None\n\n        (arch, bits) = peda.getarch()\n        if mode is None:\n            mode = bits\n        else:\n            mode = to_int(mode[2:])\n            if mode not in [16, 32, 64]:\n                self._missing_argument()\n\n        if self._is_running() and address == peda.getreg(\"pc\"):\n            write_mode = exec_mode = 1\n\n        line = peda.execute_redirect(\"show write\")\n        if line and \"on\" in line.split()[-1]:\n            write_mode = 1\n\n        if address is None or mode != bits:\n            write_mode = exec_mode = 0\n\n        if write_mode:\n            msg(\"Instruction will be written to 0x%x\" % address)\n        else:\n            msg(\"Instructions will be written to stdout\")\n\n        msg(\"Type instructions (NASM syntax), one or more per line separated by \\\";\\\"\")\n        msg(\"End with a line saying just \\\"end\\\"\")\n\n        if not write_mode:\n            address = 0xdeadbeef\n\n        inst_list = []\n        inst_code = b\"\"\n        # fetch instruction loop\n        while True:\n            inst = input(\"iasm|0x%x> \" % address)\n            if inst == \"end\":\n                break\n            if inst == \"\":\n                continue\n            bincode = peda.assemble(inst, mode)\n            size = len(bincode)\n            if size == 0:\n                continue\n            inst_list.append((size, bincode, inst))\n            if write_mode:\n                peda.writemem(address, bincode)\n            # execute assembled code\n            if exec_mode:\n                peda.execute(\"stepi %d\" % (inst.count(\";\")+1))\n\n            address += size\n            inst_code += bincode\n            msg(\"hexify: \\\"%s\\\"\" % to_hexstr(bincode))\n\n        text = Nasm.format_shellcode(b\"\".join([x[1] for x in inst_list]), mode)\n        if text:\n            msg(\"Assembled%s instructions:\" % (\"/Executed\" if exec_mode else \"\"))\n            msg(text)\n            msg(\"hexify: \\\"%s\\\"\" % to_hexstr(inst_code))\n\n        return\n\n\n    ####################################\n    #   Payload/Shellcode Generation   #\n    ####################################\n    def skeleton(self, *arg):\n        \"\"\"\n        Generate python exploit code template\n        Usage:\n            MYNAME type [file]\n                type = argv: local exploit via argument\n                type = env: local exploit via crafted environment (including NULL byte)\n                type = stdin: local exploit via stdin\n                type = remote: remote exploit via TCP socket\n        \"\"\"\n        options = [\"argv\", \"stdin\", \"env\", \"remote\"]\n        (opt, outfile) = normalize_argv(arg, 2)\n        if opt not in options:\n            self._missing_argument()\n\n        pattern = cyclic_pattern(20000).decode('utf-8')\n        if opt == \"argv\":\n            code = ExploitSkeleton().skeleton_local_argv\n        if opt == \"env\":\n            code = ExploitSkeleton().skeleton_local_env\n        if opt == \"stdin\":\n            code = ExploitSkeleton().skeleton_local_stdin\n        if opt == \"remote\":\n            code = ExploitSkeleton().skeleton_remote_tcp\n\n        if outfile:\n            msg(\"Writing skeleton code to file \\\"%s\\\"\" % outfile)\n            open(outfile, \"w\").write(code.strip(\"\\n\"))\n            os.chmod(outfile, 0o755)\n            open(\"pattern.txt\", \"w\").write(pattern)\n        else:\n            msg(code)\n\n        return\n    skeleton.options = [\"argv\", \"stdin\", \"env\", \"remote\"]\n\n    def shellcode(self, *arg):\n        \"\"\"\n        Generate or download common shellcodes.\n        Usage:\n            MYNAME generate [arch/]platform type [port] [host]\n            MYNAME search keyword (use % for any character wildcard)\n            MYNAME display shellcodeId (shellcodeId as appears in search results)\n\t    MYNAME zsc [generate customize shellcode]\n\n            For generate option:\n                default port for bindport shellcode: 16706 (0x4142)\n                default host/port for connect back shellcode: 127.127.127.127/16706\n                supported arch: x86\n        \"\"\"\n        def list_shellcode():\n            \"\"\"\n            List available shellcodes\n            \"\"\"\n            text = \"Available shellcodes:\\n\"\n            for arch in SHELLCODES:\n                for platform in SHELLCODES[arch]:\n                    for sctype in SHELLCODES[arch][platform]:\n                        text += \"    %s/%s %s\\n\" % (arch, platform, sctype)\n            msg(text)\n\n        \"\"\" Multiple variable name for different modes \"\"\"\n        (mode, platform, sctype, port, host) = normalize_argv(arg, 5)\n        (mode, keyword) = normalize_argv(arg, 2)\n        (mode, shellcodeId) = normalize_argv(arg, 2)\n\n        if mode == \"generate\":\n            arch = \"x86\"\n            if platform and \"/\" in platform:\n                (arch, platform) = platform.split(\"/\")\n\n            if platform not in SHELLCODES[arch] or not sctype:\n                list_shellcode()\n                return\n            #dbg_print_vars(arch, platform, sctype, port, host)\n            try:\n                sc = Shellcode(arch, platform).shellcode(sctype, port, host)\n            except Exception as e:\n                self._missing_argument()\n\n            if not sc:\n                msg(\"Unknown shellcode\")\n                return\n\n            hexstr = to_hexstr(sc)\n            linelen = 16 # display 16-bytes per line\n            i = 0\n            text = \"# %s/%s/%s: %d bytes\\n\" % (arch, platform, sctype, len(sc))\n            if sctype in [\"bindport\", \"connect\"]:\n                text += \"# port=%s, host=%s\\n\" % (port if port else '16706', host if host else '127.127.127.127')\n            text += \"shellcode = (\\n\"\n            while hexstr:\n                text += '    \"%s\"\\n' % (hexstr[:linelen*4])\n                hexstr = hexstr[linelen*4:]\n                i += 1\n            text += \")\"\n            msg(text)\n\n        # search shellcodes on shell-storm.org\n        elif mode == \"search\":\n            if keyword is None:\n                self._missing_argument()\n\n            res_dl = Shellcode().search(keyword)\n            if not res_dl:\n                msg(\"Shellcode not found or cannot retrieve the result\")\n                return\n\n            msg(\"Found %d shellcodes\" % len(res_dl))\n            msg(\"%s\\t%s\" %(blue(\"ScId\"), blue(\"Title\")))\n            text = \"\"\n            for data_d in res_dl:\n                text += \"[%s]\\t%s - %s\\n\" %(yellow(data_d['ScId']), data_d['ScArch'], data_d['ScTitle'])\n            pager(text)\n\n        # download shellcodes from shell-storm.org\n        elif mode == \"display\":\n            if to_int(shellcodeId) is None:\n                self._missing_argument()\n\n            res = Shellcode().display(shellcodeId)\n            if not res:\n                msg(\"Shellcode id not found or cannot retrieve the result\")\n                return\n\n            msg(res)\n\t#OWASP ZSC API Z3r0D4y.Com\n        elif mode == \"zsc\":\n            'os lists'\n            oslist = ['linux_x86','linux_x64','linux_arm','linux_mips','freebsd_x86',\n                    'freebsd_x64','windows_x86','windows_x64','osx','solaris_x64','solaris_x86']\n            'functions'\n            joblist = ['exec(\\'/path/file\\')','chmod(\\'/path/file\\',\\'permission number\\')','write(\\'/path/file\\',\\'text to write\\')',\n                    'file_create(\\'/path/file\\',\\'text to write\\')','dir_create(\\'/path/folder\\')','download(\\'url\\',\\'filename\\')',\n                    'download_execute(\\'url\\',\\'filename\\',\\'command to execute\\')','system(\\'command to execute\\')']\n            'encode types'\n            encodelist = ['none','xor_random','xor_yourvalue','add_random','add_yourvalue','sub_random',\n                    'sub_yourvalue','inc','inc_timeyouwant','dec','dec_timeyouwant','mix_all']\n            try:\n                while True:\n                    for os in oslist:\n                        msg('%s %s'%(yellow('[+]'),green(os)))\n                    if pyversion == 2:\n                        os = input('%s'%blue('os:'))\n                    if pyversion == 3:\n                        os = input('%s'%blue('os:'))\n                    if os in oslist: #check if os exist\n                        break\n                    else:\n                        warning_msg(\"Wrong input! Try Again.\")\n                while True:\n                    for job in joblist:\n                        msg('%s %s'%(yellow('[+]'),green(job)))\n                    if pyversion == 2:\n                        job = raw_input('%s'%blue('job:'))\n                    if pyversion == 3:\n                        job = input('%s'%blue('job:'))\n                    if job != '':\n                        break\n                    else:\n                        warning_msg(\"Please enter a function.\")\n                while True:\n                    for encode in encodelist:\n                        msg('%s %s'%(yellow('[+]'),green(encode)))\n                    if pyversion == 2:\n                        encode = raw_input('%s'%blue('encode:'))\n                    if pyversion == 3:\n                        encode = input('%s'%blue('encode:'))\n                    if encode != '':\n                        break\n                    else:\n                        warning_msg(\"Please enter a encode type.\")\n            except (KeyboardInterrupt, SystemExit):\n                warning_msg(\"Aborted by user\")\n            result = Shellcode().zsc(os,job,encode)\n            if result is not None:\n                msg(result)\n            else:\n                pass\n            return\n        else:\n            self._missing_argument()\n\n        return\n    shellcode.options = [\"generate\", \"search\", \"display\",\"zsc\"]\n\n    def gennop(self, *arg):\n        \"\"\"\n        Generate abitrary length NOP sled using given characters\n        Usage:\n            MYNAME size [chars]\n        \"\"\"\n        (size, chars) = normalize_argv(arg, 2)\n        if size is None:\n            self._missing_argument()\n\n        nops = Shellcode.gennop(size, chars)\n        msg(repr(nops))\n\n        return\n\n    def payload(self, *arg):\n        \"\"\"\n        Generate various type of ROP payload using ret2plt\n        Usage:\n            MYNAME copybytes (generate function template for ret2strcpy style payload)\n            MYNAME copybytes dest1 data1 dest2 data2 ...\n        \"\"\"\n        (option,) = normalize_argv(arg, 1)\n        if option is None:\n            self._missing_argument()\n\n        if option == \"copybytes\":\n            result = peda.payload_copybytes(template=1) # function template\n            arg = arg[1:]\n            while len(arg) > 0:\n                (target, data) = normalize_argv(arg, 2)\n                if data is None:\n                    break\n                if to_int(data) is None:\n                    if data[0] == \"[\" and data[-1] == \"]\":\n                        data = eval(data)\n                        data = list2hexstr(data, peda.intsize())\n                else:\n                    data = \"0x%x\" % data\n                result += peda.payload_copybytes(target, data)\n                arg = arg[2:]\n\n        if not result:\n            msg(\"Failed to construct payload\")\n        else:\n            text = \"\"\n            indent = to_int(config.Option.get(\"indent\"))\n            for line in result.splitlines():\n                text += \" \"*indent + line + \"\\n\"\n            msg(text)\n            filename = peda.get_config_filename(\"payload\")\n            open(filename, \"w\").write(text)\n\n        return\n    payload.options = [\"copybytes\"]\n\n    def snapshot(self, *arg):\n        \"\"\"\n        Save/restore process's snapshot to/from file\n        Usage:\n            MYNAME save file\n            MYNAME restore file\n        Warning: this is not thread safe, do not use with multithread program\n        \"\"\"\n        options = [\"save\", \"restore\"]\n        (opt, filename) = normalize_argv(arg, 2)\n        if opt not in options:\n            self._missing_argument()\n\n        if not filename:\n            filename = peda.get_config_filename(\"snapshot\")\n\n        if opt == \"save\":\n            if peda.save_snapshot(filename):\n                msg(\"Saved process's snapshot to filename '%s'\" % filename)\n            else:\n                msg(\"Failed to save process's snapshot\")\n\n        if opt == \"restore\":\n            if peda.restore_snapshot(filename):\n                msg(\"Restored process's snapshot from filename '%s'\" % filename)\n                peda.execute(\"stop\")\n            else:\n                msg(\"Failed to restore process's snapshot\")\n\n        return\n    snapshot.options = [\"save\", \"restore\"]\n\n    def crashdump(self, *arg):\n        \"\"\"\n        Display crashdump info and save to file\n        Usage:\n            MYNAME [reason_text]\n        \"\"\"\n        (reason,) = normalize_argv(arg, 1)\n        if not reason:\n            reason = \"Interactive dump\"\n\n        logname = peda.get_config_filename(\"crashlog\")\n        logfd = open(logname, \"a\")\n        config.Option.set(\"_teefd\", logfd)\n        msg(\"[%s]\" % \"START OF CRASH DUMP\".center(78, \"-\"))\n        msg(\"Timestamp: %s\" % time.ctime())\n        msg(\"Reason: %s\" % red(reason))\n\n        # exploitability\n        pc = peda.getreg(\"pc\")\n        if not peda.is_address(pc):\n            exp = red(\"EXPLOITABLE\")\n        else:\n            exp = \"Unknown\"\n        msg(\"Exploitability: %s\" % exp)\n\n        # registers, code, stack\n        self.context_register()\n        self.context_code(16)\n        self.context_stack()\n\n        # backtrace\n        msg(\"[%s]\" % \"backtrace (innermost 10 frames)\".center(78, \"-\"), \"blue\")\n        msg(peda.execute_redirect(\"backtrace 10\"))\n\n        msg(\"[%s]\\n\" % \"END OF CRASH DUMP\".center(78, \"-\"))\n        config.Option.set(\"_teefd\", \"\")\n        logfd.close()\n\n        return\n\n    def utils(self, *arg):\n        \"\"\"\n        Miscelaneous utilities from utils module\n        Usage:\n            MYNAME command arg\n        \"\"\"\n        (command, carg) = normalize_argv(arg, 2)\n        cmds = [\"int2hexstr\", \"list2hexstr\", \"str2intlist\"]\n        if not command or command not in cmds or not carg:\n            self._missing_argument()\n\n        func = globals()[command]\n        if command == \"int2hexstr\":\n            if to_int(carg) is None:\n                msg(\"Not a number\")\n                return\n            result = func(to_int(carg))\n            result = to_hexstr(result)\n\n        if command == \"list2hexstr\":\n            if to_int(carg) is not None:\n                msg(\"Not a list\")\n                return\n            result = func(eval(\"%s\" % carg))\n            result = to_hexstr(result)\n\n        if command == \"str2intlist\":\n            res = func(carg)\n            result = \"[\"\n            for v in res:\n                result += \"%s, \" % to_hex(v)\n            result = result.rstrip(\", \") + \"]\"\n\n        msg(result)\n        return\n    utils.options = [\"int2hexstr\", \"list2hexstr\", \"str2intlist\"]\n\n###########################################################################\nclass pedaGDBCommand(gdb.Command):\n    \"\"\"\n    Wrapper of gdb.Command for master \"peda\" command\n    \"\"\"\n    def __init__(self, cmdname=\"peda\"):\n        self.cmdname = cmdname\n        self.__doc__ = pedacmd._get_helptext()\n        super(pedaGDBCommand, self).__init__(self.cmdname, gdb.COMMAND_DATA)\n\n    def invoke(self, arg_string, from_tty):\n        # do not repeat command\n        self.dont_repeat()\n        arg = peda.string_to_argv(arg_string)\n        if len(arg) < 1:\n            pedacmd.help()\n        else:\n            cmd = arg[0]\n            if cmd in pedacmd.commands:\n                func = getattr(pedacmd, cmd)\n                try:\n                    # reset memoized cache\n                    reset_cache(sys.modules['__main__'])\n                    func(*arg[1:])\n                except Exception as e:\n                    if config.Option.get(\"debug\") == \"on\":\n                        msg(\"Exception: %s\" %e)\n                        traceback.print_exc()\n                    peda.restore_user_command(\"all\")\n                    pedacmd.help(cmd)\n            else:\n                msg(\"Undefined command: %s. Try \\\"peda help\\\"\" % cmd)\n        return\n\n    def complete(self, text, word):\n        completion = []\n        if text != \"\":\n            cmd = text.split()[0]\n            if cmd in pedacmd.commands:\n                func = getattr(pedacmd, cmd)\n                for opt in func.options:\n                    if word in opt:\n                        completion += [opt]\n            else:\n                for cmd in pedacmd.commands:\n                    if cmd.startswith(text.strip()):\n                        completion += [cmd]\n        else:\n            for cmd in pedacmd.commands:\n                if word in cmd and cmd not in completion:\n                    completion += [cmd]\n        return completion\n\n\n###########################################################################\nclass Alias(gdb.Command):\n    \"\"\"\n    Generic alias, create short command names\n    This doc should be changed dynamically\n    \"\"\"\n    def __init__(self, alias, command, shorttext=1):\n        (cmd, opt) = (command + \" \").split(\" \", 1)\n        if cmd == \"peda\" or cmd == \"pead\":\n            cmd = opt.split(\" \")[0]\n        if not shorttext:\n            self.__doc__ = pedacmd._get_helptext(cmd)\n        else:\n            self.__doc__ = green(\"Alias for '%s'\" % command)\n        self._command = command\n        self._alias = alias\n        super(Alias, self).__init__(alias, gdb.COMMAND_NONE)\n\n    def invoke(self, args, from_tty):\n        self.dont_repeat()\n        gdb.execute(\"%s %s\" %(self._command, args))\n\n    def complete(self, text, word):\n        completion = []\n        cmd = self._command.split(\"peda \")[1]\n        for opt in getattr(pedacmd, cmd).options: # list of command's options\n            if text in opt and opt not in completion:\n                completion += [opt]\n        if completion != []:\n            return completion\n        if cmd in [\"set\", \"show\"] and text.split()[0] in [\"option\"]:\n            opname = [x for x in config.OPTIONS.keys() if x.startswith(word.strip())]\n            if opname != []:\n                completion = opname\n            else:\n                completion = list(config.OPTIONS.keys())\n        return completion\n\n\n###########################################################################\n## INITIALIZATION ##\n# global instances of PEDA() and PEDACmd()\npeda = PEDA()\npedacmd = PEDACmd()\npedacmd.help.__func__.options = pedacmd.commands # XXX HACK\n\n# register \"peda\" command in gdb\npedaGDBCommand()\nAlias(\"pead\", \"peda\") # just for auto correction\n\n# create aliases for subcommands\nfor cmd in pedacmd.commands:\n    func = getattr(pedacmd, cmd)\n    func.__func__.__doc__ = func.__doc__.replace(\"MYNAME\", cmd)\n    if cmd not in [\"help\", \"show\", \"set\"]:\n        Alias(cmd, \"peda %s\" % cmd, 0)\n\n# handle SIGINT / Ctrl-C\ndef sigint_handler(signal, frame):\n    warning_msg(\"Got Ctrl+C / SIGINT!\")\n    gdb.execute(\"set logging off\")\n    peda.restore_user_command(\"all\")\n    raise KeyboardInterrupt\nsignal.signal(signal.SIGINT, sigint_handler)\n\n# custom hooks\npeda.define_user_command(\"hook-stop\",\n    \"peda context\\n\"\n    \"session autosave\"\n    )\n\n# common used shell commands aliases\nshellcmds = [\"man\", \"ls\", \"ps\", \"grep\", \"cat\", \"more\", \"less\", \"pkill\", \"clear\", \"vi\", \"nano\"]\nfor cmd in shellcmds:\n        Alias(cmd, \"shell %s\" % cmd)\n\n# custom command aliases, add any alias you want\nAlias(\"phelp\", \"peda help\")\nAlias(\"pset\", \"peda set\")\nAlias(\"pshow\", \"peda show\")\nAlias(\"pbreak\", \"peda pltbreak\")\nAlias(\"pattc\", \"peda pattern_create\")\nAlias(\"patto\", \"peda pattern_offset\")\nAlias(\"patta\", \"peda pattern_arg\")\nAlias(\"patte\", \"peda pattern_env\")\nAlias(\"patts\", \"peda pattern_search\")\nAlias(\"find\", \"peda searchmem\") # override gdb find command\nAlias(\"ftrace\", \"peda tracecall\")\nAlias(\"itrace\", \"peda traceinst\")\nAlias(\"jtrace\", \"peda traceinst j\")\nAlias(\"stack\", \"peda telescope $sp\")\nAlias(\"viewmem\", \"peda telescope\")\nAlias(\"reg\", \"peda xinfo register\")\nAlias(\"brva\", \"breakrva\")\n\n# misc gdb settings\npeda.execute(\"set confirm off\")\npeda.execute(\"set verbose off\")\npeda.execute(\"set output-radix 0x10\")\npeda.execute(\"set prompt \\001%s\\002\" % red(\"\\002gdb-peda$ \\001\")) # custom prompt\npeda.execute(\"set height 0\") # disable paging\npeda.execute(\"set history expansion on\")\npeda.execute(\"set history save on\") # enable history saving\npeda.execute(\"set disassembly-flavor intel\")\npeda.execute(\"set follow-fork-mode child\")\npeda.execute(\"set backtrace past-main on\")\npeda.execute(\"set step-mode on\")\npeda.execute(\"set print pretty on\")\npeda.execute(\"handle SIGALRM print nopass\") # ignore SIGALRM\npeda.execute(\"handle SIGSEGV stop print nopass\") # catch SIGSEGV\n"
        },
        {
          "name": "python23-compatibility.md",
          "type": "blob",
          "size": 2.029296875,
          "content": "# Overview\n\nPEDA supports Python 2 and Python 3 using the\n[six](https://pypi.python.org/pypi/six) library. To make sure code runs on both\nPython 2 and Python 3, make sure to keep the following in mind. \n\n## Division\n\nFor integer division, use the `//` operator instead of `/`. In Python 3, the `/` operator returns a `float`.\n\nIn Python 3:\n\n```python\n>>> 5 / 2\n2.5\n>>> type(5 / 2)\n<class 'float'>\n```\n\n## Type checking\n\nTo check if something is a string:\n\n```python\nisinstance(obj, six.string_types)\n```\n\nTo check if something is an integer type:\n\n```python\nisinstance(x, six.integer_types)\n```\n\n## Strings\n\nIn Python 2, `bytes` is an alias for `str`. In Python 3, `str` is a unicode\ntype and `bytes` is used for a sequence of arbitrary bytes. Use a leading 'b' to\nsignify that a string is a `bytes` object.\n\n```python\n>>> 'Normal string'\n'Normal string'\n>>> b'arbitrary bytes \\x90\\x90'\nb'arbitrary bytes \\x90\\x90'\n```\n\nTo convert between `str` to `bytes`:\n\n```python\n>>> 'hi there'.encode('utf-8')\nb'hi there'\n>>> b'some string'.decode('utf-8')\n'some string'\n```\n\nDo not mix `bytes` and `str` with each other with basic string functions. The\nfollowing is okay:\n\n```python\n\n>>> \"abc\".replace(\"a\", \"f\")\n'fbc'\n>>> b\"abc\".replace(b\"a\", b\"f\")\nb'fbc'\n```\n\nMixing types in Python 3 will throw an exception:\n\n```python\n>>> b\"abc\".replace(\"a\", \"f\")\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: expected bytes, bytearray or buffer compatible object\n\n```\n\nIn Python 2, indexing into a `str` returns a `str` of length 1. In Python 3, indexing into a `bytes` returns an `int`. This causes a problem when iterating. To solve this, use the `bytes_iterator` from `utils.py`.\n\n```python\n# In Python 2:\n>>> s = b'hello'\n>>> s\n'hello'\n>>> s[0]\n'h'\n\n# In Python 3:\n>>> s = b'hello'\n>>> s\nb'hello'\n>>> s[0]\n104\n\n# Solution:\n>>> for c in bytes_iterator(b'hi'): print(c)\n... \nb'h'\nb'i'\n```\n\n## Encodings\n\nEncode (and decode) strings into hex:\n\n```python\n>>> codecs.encode(b'abcdef', 'hex')\nb'616263646566'\n>>> codecs.decode('616263646566', 'hex')\nb'abcdef'\n```\n"
        }
      ]
    }
  ]
}