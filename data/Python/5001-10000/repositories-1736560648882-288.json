{
  "metadata": {
    "timestamp": 1736560648882,
    "page": 288,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjI5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "vietnh1009/ASCII-generator",
      "stars": 7569,
      "defaultBranch": "master",
      "files": [
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.04296875,
          "content": "MIT License\n\nCopyright (c) 2018 Viet Nguyen\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 3.71875,
          "content": "# [PYTHON] ASCII generator\n\n## [22/11/2024] A thank you to the Chinese community\n\nRecently, this repository has been protected and supported by the Chinese community in relation to a copyright issue. A million thanks to Chinese netizens in particular, and the Chinese community in general\n\n## Introduction\n\nHere is my python source code for ASCII generator. With my code: \n* **Given input image, we could generate ASCII art stored under text format in different languages (.txt)**\n* **Given input image, we could generate ASCII art stored under image formats in different languages (.png, .jpg, ...). In each format, there are 2 options: Black background and white characters, or vice versa**\n* **Given input video, we could generate ASCII art stored under video formats in different languages (.avi, .mp4, ...)**\n* **Video/image outputs could be in grayscale or color format. It is totally up to you**\n\n## Multiple Language Conversion\nWe could generate ASCII art with different alphabets (english, german, french, korean, chinese, japanese, ...). Below are example output:\n<p align=\"center\">\n  <img src=\"demo/english_output.jpg\" width=800><br/>\n  <i>English</i>\n</p>\n\n<p align=\"center\">\n  <img src=\"demo/japanese_output.jpg\" width=800><br/>\n  <i>Japanese (Dragon Ball)</i>\n</p>\n\n<p align=\"center\">\n  <img src=\"demo/german_output.jpg\" width=800><br/>\n  <i>German</i>\n</p>\n\n<p align=\"center\">\n  <img src=\"demo/korean_output.jpg\" width=800><br/>\n  <i>Korean (Dae Jang-geum)</i>\n</p>\n\n<p align=\"center\">\n  <img src=\"demo/french_output.jpg\" width=800><br/>\n  <i>French</i>\n</p>\n\n<p align=\"center\">\n  <img src=\"demo/chinese_output.jpg\" width=800><br/>\n  <i>Chinese (Actress)</i>\n</p>\n\n<p align=\"center\">\n  <img src=\"demo/spanish_output.jpg\" width=800><br/>\n  <i>Spanish</i>\n</p>\n\n<p align=\"center\">\n  <img src=\"demo/russian_output.jpg\" width=800><br/>\n  <i>Russian</i>\n</p>\n\n## Video to video\nBy running the sript **video2video_color.py** or **video2video.py** with different values for *background* and *mode*, we will have different outputs, for example:\n<p align=\"center\">\n  <img src=\"demo/demo_complex_color_160.gif\" width=800><br/>\n  <i>Colored complex-character ASCII output</i>\n</p>\n\n<p align=\"center\">\n  <img src=\"demo/demo_simple_white_150.gif\" width=800><br/>\n  <i>White-background simple-character ASCII output</i>\n</p>\n\n## Image to text\nBy running the sript **img2txt.py** with different values for *mode*, we will have following outputs:\n<p align=\"center\">\n  <img src=\"demo/input.jpg\" width=800><br/>\n  <i>Input image</i>\n</p>\n\n<p align=\"center\">\n  <img src=\"demo/demo_image_simple.png\" width=800><br/>\n  <i>Simple character ASCII output</i>\n</p>\n\n<p align=\"center\">\n  <img src=\"demo/demo_image_complex.png\" width=800><br/>\n  <i>Complex character ASCII output</i>\n</p>\n\n## Image to image\nBy running the sript **img2img_color.py** or **img2img.py** with different values for *background* and *mode*, we will have following outputs:\n<p align=\"center\">\n  <img src=\"demo/input.jpg\" width=800><br/>\n  <i>Input image</i>\n</p>\n\n<p align=\"center\">\n  <img src=\"demo/output_complex_color_200.jpg\" width=800><br/>\n  <i>Colored complex-character ASCII output</i>\n</p>\n\n<p align=\"center\">\n  <img src=\"demo/output_simple_white_200.jpg\" width=800><br/>\n  <i>White-background simple-character ASCII output</i>\n</p>\n\n<p align=\"center\">\n  <img src=\"demo/output_simple_black_200.jpg\" width=800><br/>\n  <i>Black-background simple-character ASCII output</i>\n</p>\n\n<p align=\"center\">\n  <img src=\"demo/output_complex_white_200.jpg\" width=800><br/>\n  <i>White-background complex-character ASCII output</i>\n</p>\n\n<p align=\"center\">\n  <img src=\"demo/output_complex_black_200.jpg\" width=800><br/>\n  <i>Black-background complex-character ASCII output</i>\n</p>\n\n## Requirements\n\n* **python 3.6**\n* **cv2**\n* **PIL** \n* **numpy**\n"
        },
        {
          "name": "alphabets.py",
          "type": "blob",
          "size": 1.888671875,
          "content": "GENERAL = {\n    \"simple\": \"@%#*+=-:. \",\n    \"complex\": \"$@B%8&WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\\|()1{}[]?-_+~<>i!lI;:,\\\"^`'. \"\n}\n# Full list could be found here https://github.com/tsroten/zhon/tree/develop/zhon/cedict\nCHINESE = {\n    \"standard\": \"龘䶑瀰幗獼鑭躙䵹觿䲔釅欄鐮䥯鶒獭鰽襽螻鰱蹦屭繩圇婹歜剛屧磕媿慪像僭堳噞呱棒偁呣塙唑浠唼刻凌咄亟拮俗参坒估这聿布允仫忖玗甴木亪女去凸五圹亐囗弌九人亏产斗丩艹刂彳丬了５丄三亻讠厂丆丨１二宀冖乛一丶、\",\n}\n\nKOREAN = {\n    \"standard\": \"ㄱㄴㄷㄹㅁㅂㅅㅇㅈㅊㅋㅌㅍㅎㅏㅑㅓㅕㅗㅛㅜㅠㅡㅣ\"\n}\n\nJAPANESE = {\n    \"hiragana\": \"あいうえおかきくけこさしすせそたちつてとなにぬねのはひふへほまみむめもやゆよらりるれろわをん\",\n    \"katakana\": \"アイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヲン\"\n}\n\nENGLISH = {\n    \"standard\": \"AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz\"\n}\n\nRUSSIAN = {\n    \"standard\": \"АаБбВвГгДдЕеЁёЖжЗзИиЙйКкЛлМмНнОоПпРрСсТтУуФфХхЦцЧчШшЩщЪъЫыЬьЭэЮюЯя\"\n}\n\nGERMAN = {\n    \"standard\": \"AaÄäBbßCcDdEeFfGgHhIiJjKkLlMmNnOoÖöPpQqRrSsTtUuÜüVvWwXxYyZz\"\n}\n\nFRENCH = {\n    \"standard\": \"AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZzÆæŒœÇçÀàÂâÉéÈèÊêËëÎîÎïÔôÛûÙùŸÿ\"\n}\n\nSPANISH = {\n    \"standard\": \"AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZzÑñáéíóú¡¿\"\n}\n\nITALIAN = {\n    \"standard\": \"AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZzÀÈàèéìòù\"\n}\n\nPORTUGUESE = {\n    \"standard\": \"AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZzàÀáÁâÂãÃçÇéÉêÊíÍóÓôÔõÕúÚ\"\n}\n\nPOLISH = {\n    \"standard\": \"AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpRrSsTtUuWwYyZzĄąĘęÓóŁłŃńŻżŚśĆćŹź\"\n}"
        },
        {
          "name": "data",
          "type": "tree",
          "content": null
        },
        {
          "name": "demo",
          "type": "tree",
          "content": null
        },
        {
          "name": "fonts",
          "type": "tree",
          "content": null
        },
        {
          "name": "img2img.py",
          "type": "blob",
          "size": 2.603515625,
          "content": "\"\"\"\n@author: Viet Nguyen <nhviet1009@gmail.com>\n\"\"\"\nimport argparse\nimport cv2\nimport numpy as np\nfrom PIL import Image, ImageDraw, ImageOps\nfrom utils import get_data\n\n\ndef get_args():\n    parser = argparse.ArgumentParser(\"Image to ASCII\")\n    parser.add_argument(\"--input\", type=str, default=\"data/input.jpg\", help=\"Path to input image\")\n    parser.add_argument(\"--output\", type=str, default=\"data/output.jpg\", help=\"Path to output text file\")\n    parser.add_argument(\"--language\", type=str, default=\"english\")\n    parser.add_argument(\"--mode\", type=str, default=\"standard\")\n    parser.add_argument(\"--background\", type=str, default=\"black\", choices=[\"black\", \"white\"],\n                        help=\"background's color\")\n    parser.add_argument(\"--num_cols\", type=int, default=300, help=\"number of character for output's width\")\n    args = parser.parse_args()\n    return args\n\n\ndef main(opt):\n    if opt.background == \"white\":\n        bg_code = 255\n    else:\n        bg_code = 0\n    char_list, font, sample_character, scale = get_data(opt.language, opt.mode)\n    num_chars = len(char_list)\n    num_cols = opt.num_cols\n    image = cv2.imread(opt.input)\n    image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n    height, width = image.shape\n    cell_width = width / opt.num_cols\n    cell_height = scale * cell_width\n    num_rows = int(height / cell_height)\n    if num_cols > width or num_rows > height:\n        print(\"Too many columns or rows. Use default setting\")\n        cell_width = 6\n        cell_height = 12\n        num_cols = int(width / cell_width)\n        num_rows = int(height / cell_height)\n    char_width, char_height = font.getsize(sample_character)\n    out_width = char_width * num_cols\n    out_height = scale * char_height * num_rows\n    out_image = Image.new(\"L\", (out_width, out_height), bg_code)\n    draw = ImageDraw.Draw(out_image)\n    for i in range(num_rows):\n        line = \"\".join([char_list[min(int(np.mean(image[int(i * cell_height):min(int((i + 1) * cell_height), height),\n                                                  int(j * cell_width):min(int((j + 1) * cell_width),\n                                                                          width)]) / 255 * num_chars), num_chars - 1)]\n                        for j in\n                        range(num_cols)]) + \"\\n\"\n        draw.text((0, i * char_height), line, fill=255 - bg_code, font=font)\n\n    if opt.background == \"white\":\n        cropped_image = ImageOps.invert(out_image).getbbox()\n    else:\n        cropped_image = out_image.getbbox()\n    out_image = out_image.crop(cropped_image)\n    out_image.save(opt.output)\n\n\nif __name__ == '__main__':\n    opt = get_args()\n    main(opt)\n"
        },
        {
          "name": "img2img_color.py",
          "type": "blob",
          "size": 2.826171875,
          "content": "\"\"\"\n@author: Viet Nguyen <nhviet1009@gmail.com>\n\"\"\"\nimport argparse\n\nimport cv2\nimport numpy as np\nfrom PIL import Image, ImageDraw, ImageOps\nfrom utils import get_data\n\n\ndef get_args():\n    parser = argparse.ArgumentParser(\"Image to ASCII\")\n    parser.add_argument(\"--input\", type=str, default=\"data/input.jpg\", help=\"Path to input image\")\n    parser.add_argument(\"--output\", type=str, default=\"data/output.jpg\", help=\"Path to output text file\")\n    parser.add_argument(\"--language\", type=str, default=\"english\")\n    parser.add_argument(\"--mode\", type=str, default=\"standard\")\n    parser.add_argument(\"--background\", type=str, default=\"black\", choices=[\"black\", \"white\"],\n                        help=\"background's color\")\n    parser.add_argument(\"--num_cols\", type=int, default=300, help=\"number of character for output's width\")\n    parser.add_argument(\"--scale\", type=int, default=2, help=\"upsize output\")\n    args = parser.parse_args()\n    return args\n\n\ndef main(opt):\n    if opt.background == \"white\":\n        bg_code = (255, 255, 255)\n    else:\n        bg_code = (0, 0, 0)\n    char_list, font, sample_character, scale = get_data(opt.language, opt.mode)\n    num_chars = len(char_list)\n    num_cols = opt.num_cols\n    image = cv2.imread(opt.input, cv2.IMREAD_COLOR)\n    image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n    height, width, _ = image.shape\n    cell_width = width / opt.num_cols\n    cell_height = scale * cell_width\n    num_rows = int(height / cell_height)\n    if num_cols > width or num_rows > height:\n        print(\"Too many columns or rows. Use default setting\")\n        cell_width = 6\n        cell_height = 12\n        num_cols = int(width / cell_width)\n        num_rows = int(height / cell_height)\n    char_width, char_height = font.getsize(sample_character)\n    out_width = char_width * num_cols\n    out_height = scale * char_height * num_rows\n    out_image = Image.new(\"RGB\", (out_width, out_height), bg_code)\n    draw = ImageDraw.Draw(out_image)\n    for i in range(num_rows):\n        for j in range(num_cols):\n            partial_image = image[int(i * cell_height):min(int((i + 1) * cell_height), height),\n                            int(j * cell_width):min(int((j + 1) * cell_width), width), :]\n            partial_avg_color = np.sum(np.sum(partial_image, axis=0), axis=0) / (cell_height * cell_width)\n            partial_avg_color = tuple(partial_avg_color.astype(np.int32).tolist())\n            char = char_list[min(int(np.mean(partial_image) * num_chars / 255), num_chars - 1)]\n            draw.text((j * char_width, i * char_height), char, fill=partial_avg_color, font=font)\n\n    if opt.background == \"white\":\n        cropped_image = ImageOps.invert(out_image).getbbox()\n    else:\n        cropped_image = out_image.getbbox()\n    out_image = out_image.crop(cropped_image)\n    out_image.save(opt.output)\n\n\nif __name__ == '__main__':\n    opt = get_args()\n    main(opt)\n"
        },
        {
          "name": "img2txt.py",
          "type": "blob",
          "size": 1.9296875,
          "content": "\"\"\"\n@author: Viet Nguyen <nhviet1009@gmail.com>\n\"\"\"\nimport argparse\n\nimport cv2\nimport numpy as np\n\n\ndef get_args():\n    parser = argparse.ArgumentParser(\"Image to ASCII\")\n    parser.add_argument(\"--input\", type=str, default=\"data/input.jpg\", help=\"Path to input image\")\n    parser.add_argument(\"--output\", type=str, default=\"data/output.txt\", help=\"Path to output text file\")\n    parser.add_argument(\"--mode\", type=str, default=\"complex\", choices=[\"simple\", \"complex\"],\n                        help=\"10 or 70 different characters\")\n    parser.add_argument(\"--num_cols\", type=int, default=150, help=\"number of character for output's width\")\n    args = parser.parse_args()\n    return args\n\n\ndef main(opt):\n    if opt.mode == \"simple\":\n        CHAR_LIST = '@%#*+=-:. '\n    else:\n        CHAR_LIST = \"$@B%8&WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\\|()1{}[]?-_+~<>i!lI;:,\\\"^`'. \"\n    num_chars = len(CHAR_LIST)\n    num_cols = opt.num_cols\n    image = cv2.imread(opt.input)\n    image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n    height, width = image.shape\n    cell_width = width / opt.num_cols\n    cell_height = 2 * cell_width\n    num_rows = int(height / cell_height)\n    if num_cols > width or num_rows > height:\n        print(\"Too many columns or rows. Use default setting\")\n        cell_width = 6\n        cell_height = 12\n        num_cols = int(width / cell_width)\n        num_rows = int(height / cell_height)\n\n    output_file = open(opt.output, 'w')\n    for i in range(num_rows):\n        for j in range(num_cols):\n            output_file.write(\n                CHAR_LIST[min(int(np.mean(image[int(i * cell_height):min(int((i + 1) * cell_height), height),\n                                          int(j * cell_width):min(int((j + 1) * cell_width),\n                                                                  width)]) * num_chars / 255), num_chars - 1)])\n        output_file.write(\"\\n\")\n    output_file.close()\n\n\nif __name__ == '__main__':\n    opt = get_args()\n    main(opt)\n"
        },
        {
          "name": "utils.py",
          "type": "blob",
          "size": 4.5322265625,
          "content": "import numpy as np\nfrom PIL import Image, ImageFont, ImageDraw, ImageOps\n\n\ndef sort_chars(char_list, font, language):\n    if language == \"chinese\":\n        char_width, char_height = font.getsize(\"制\")\n    elif language == \"korean\":\n        char_width, char_height = font.getsize(\"ㅊ\")\n    elif language == \"japanese\":\n        char_width, char_height = font.getsize(\"あ\")\n    elif language in [\"english\", \"german\", \"french\", \"spanish\", \"italian\", \"portuguese\", \"polish\"]:\n        char_width, char_height = font.getsize(\"A\")\n    elif language == \"russian\":\n        char_width, char_height = font.getsize(\"A\")\n    num_chars = min(len(char_list), 100)\n    out_width = char_width * len(char_list)\n    out_height = char_height\n    out_image = Image.new(\"L\", (out_width, out_height), 255)\n    draw = ImageDraw.Draw(out_image)\n    draw.text((0, 0), char_list, fill=0, font=font)\n    cropped_image = ImageOps.invert(out_image).getbbox()\n    out_image = out_image.crop(cropped_image)\n    brightness = [np.mean(np.array(out_image)[:, 10 * i:10 * (i + 1)]) for i in range(len(char_list))]\n    char_list = list(char_list)\n    zipped_lists = zip(brightness, char_list)\n    zipped_lists = sorted(zipped_lists)\n    result = \"\"\n    counter = 0\n    incremental_step = (zipped_lists[-1][0] - zipped_lists[0][0]) / num_chars\n    current_value = zipped_lists[0][0]\n    for value, char in zipped_lists:\n        if value >= current_value:\n            result += char\n            counter += 1\n            current_value += incremental_step\n        if counter == num_chars:\n            break\n    if result[-1] != zipped_lists[-1][1]:\n        result += zipped_lists[-1][1]\n    return result\n\n\ndef get_data(language, mode):\n    if language == \"general\":\n        from alphabets import GENERAL as character\n        font = ImageFont.truetype(\"fonts/DejaVuSansMono-Bold.ttf\", size=20)\n        sample_character = \"A\"\n        scale = 2\n    elif language == \"english\":\n        from alphabets import ENGLISH as character\n        font = ImageFont.truetype(\"fonts/DejaVuSansMono-Bold.ttf\", size=20)\n        sample_character = \"A\"\n        scale = 2\n    elif language == \"german\":\n        from alphabets import GERMAN as character\n        font = ImageFont.truetype(\"fonts/DejaVuSansMono-Bold.ttf\", size=20)\n        sample_character = \"A\"\n        scale = 2\n    elif language == \"french\":\n        from alphabets import FRENCH as character\n        font = ImageFont.truetype(\"fonts/DejaVuSansMono-Bold.ttf\", size=20)\n        sample_character = \"A\"\n        scale = 2\n    elif language == \"italian\":\n        from alphabets import ITALIAN as character\n        font = ImageFont.truetype(\"fonts/DejaVuSansMono-Bold.ttf\", size=20)\n        sample_character = \"A\"\n        scale = 2\n    elif language == \"polish\":\n        from alphabets import POLISH as character\n        font = ImageFont.truetype(\"fonts/DejaVuSansMono-Bold.ttf\", size=20)\n        sample_character = \"A\"\n        scale = 2\n    elif language == \"portuguese\":\n        from alphabets import PORTUGUESE as character\n        font = ImageFont.truetype(\"fonts/DejaVuSansMono-Bold.ttf\", size=20)\n        sample_character = \"A\"\n        scale = 2\n    elif language == \"spanish\":\n        from alphabets import SPANISH as character\n        font = ImageFont.truetype(\"fonts/DejaVuSansMono-Bold.ttf\", size=20)\n        sample_character = \"A\"\n        scale = 2\n    elif language == \"russian\":\n        from alphabets import RUSSIAN as character\n        font = ImageFont.truetype(\"fonts/DejaVuSansMono-Bold.ttf\", size=20)\n        sample_character = \"Ш\"\n        scale = 2\n    elif language == \"chinese\":\n        from alphabets import CHINESE as character\n        font = ImageFont.truetype(\"fonts/simsun.ttc\", size=10)\n        sample_character = \"制\"\n        scale = 1\n    elif language == \"korean\":\n        from alphabets import KOREAN as character\n        font = ImageFont.truetype(\"fonts/arial-unicode.ttf\", size=10)\n        sample_character = \"ㅊ\"\n        scale = 1\n    elif language == \"japanese\":\n        from alphabets import JAPANESE as character\n        font = ImageFont.truetype(\"fonts/arial-unicode.ttf\", size=10)\n        sample_character = \"お\"\n        scale = 1\n    else:\n        print(\"Invalid language\")\n        return None, None, None, None\n    try:\n        if len(character) > 1:\n            char_list = character[mode]\n        else:\n            char_list = character[\"standard\"]\n    except:\n        print(\"Invalid mode for {}\".format(language))\n        return None, None, None, None\n    if language != \"general\":\n        char_list = sort_chars(char_list, font, language)\n\n    return char_list, font, sample_character, scale\n"
        },
        {
          "name": "video2video.py",
          "type": "blob",
          "size": 3.84375,
          "content": "\"\"\"\n@author: Viet Nguyen <nhviet1009@gmail.com>\n\"\"\"\nimport argparse\n\nimport cv2\nimport numpy as np\nfrom PIL import Image, ImageFont, ImageDraw, ImageOps\n\n\ndef get_args():\n    parser = argparse.ArgumentParser(\"Image to ASCII\")\n    parser.add_argument(\"--input\", type=str, default=\"data/input.mp4\", help=\"Path to input video\")\n    parser.add_argument(\"--output\", type=str, default=\"data/output.mp4\", help=\"Path to output video\")\n    parser.add_argument(\"--mode\", type=str, default=\"simple\", choices=[\"simple\", \"complex\"],\n                        help=\"10 or 70 different characters\")\n    parser.add_argument(\"--background\", type=str, default=\"white\", choices=[\"black\", \"white\"],\n                        help=\"background's color\")\n    parser.add_argument(\"--num_cols\", type=int, default=100, help=\"number of character for output's width\")\n    parser.add_argument(\"--scale\", type=int, default=1, help=\"upsize output\")\n    parser.add_argument(\"--fps\", type=int, default=0, help=\"frame per second\")\n    parser.add_argument(\"--overlay_ratio\", type=float, default=0.2, help=\"Overlay width ratio\")\n    args = parser.parse_args()\n    return args\n\n\ndef main(opt):\n    if opt.mode == \"simple\":\n        CHAR_LIST = '@%#*+=-:. '\n    else:\n        CHAR_LIST = \"$@B%8&WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\\|()1{}[]?-_+~<>i!lI;:,\\\"^`'. \"\n    if opt.background == \"white\":\n        bg_code = 255\n    else:\n        bg_code = 0\n    font = ImageFont.truetype(\"fonts/DejaVuSansMono-Bold.ttf\", size=int(10 * opt.scale))\n    cap = cv2.VideoCapture(opt.input)\n    if opt.fps == 0:\n        fps = int(cap.get(cv2.CAP_PROP_FPS))\n    else:\n        fps = opt.fps\n    num_chars = len(CHAR_LIST)\n    num_cols = opt.num_cols\n    while cap.isOpened():\n        flag, frame = cap.read()\n        if flag:\n            image = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)\n        else:\n            break\n        height, width = image.shape\n        cell_width = width / opt.num_cols\n        cell_height = 2 * cell_width\n        num_rows = int(height / cell_height)\n        if num_cols > width or num_rows > height:\n            print(\"Too many columns or rows. Use default setting\")\n            cell_width = 6\n            cell_height = 12\n            num_cols = int(width / cell_width)\n            num_rows = int(height / cell_height)\n        char_width, char_height = font.getsize(\"A\")\n        out_width = char_width * num_cols\n        out_height = 2 * char_height * num_rows\n        out_image = Image.new(\"L\", (out_width, out_height), bg_code)\n        draw = ImageDraw.Draw(out_image)\n        for i in range(num_rows):\n            line = \"\".join([CHAR_LIST[min(int(np.mean(\n                image[int(i * cell_height):min(int((i + 1) * cell_height), height),\n                int(j * cell_width):min(int((j + 1) * cell_width), width)]) * num_chars / 255), num_chars - 1)] for j in\n                            range(num_cols)]) + \"\\n\"\n            draw.text((0, i * char_height), line, fill=255 - bg_code, font=font)\n\n        if opt.background == \"white\":\n            cropped_image = ImageOps.invert(out_image).getbbox()\n        else:\n            cropped_image = out_image.getbbox()\n        out_image = out_image.crop(cropped_image)\n        out_image = cv2.cvtColor(np.array(out_image), cv2.COLOR_GRAY2BGR)\n        out_image = np.array(out_image)\n        try:\n            out\n        except:\n            out = cv2.VideoWriter(opt.output, cv2.VideoWriter_fourcc(*\"XVID\"), fps,\n                                  ((out_image.shape[1], out_image.shape[0])))\n\n        if opt.overlay_ratio:\n            height, width, _ = out_image.shape\n            overlay = cv2.resize(frame, (int(width * opt.overlay_ratio), int(height * opt.overlay_ratio)))\n            out_image[height - int(height * opt.overlay_ratio):, width - int(width * opt.overlay_ratio):, :] = overlay\n        out.write(out_image)\n    cap.release()\n    out.release()\n\n\nif __name__ == '__main__':\n    opt = get_args()\n    main(opt)\n"
        },
        {
          "name": "video2video_color.py",
          "type": "blob",
          "size": 3.99609375,
          "content": "\"\"\"\n@author: Viet Nguyen <nhviet1009@gmail.com>\n\"\"\"\nimport argparse\n\nimport cv2\nimport numpy as np\nfrom PIL import Image, ImageFont, ImageDraw, ImageOps\n\n\ndef get_args():\n    parser = argparse.ArgumentParser(\"Image to ASCII\")\n    parser.add_argument(\"--input\", type=str, default=\"data/input.mp4\", help=\"Path to input video\")\n    parser.add_argument(\"--output\", type=str, default=\"data/output.mp4\", help=\"Path to output video\")\n    parser.add_argument(\"--mode\", type=str, default=\"complex\", choices=[\"simple\", \"complex\"],\n                        help=\"10 or 70 different characters\")\n    parser.add_argument(\"--background\", type=str, default=\"black\", choices=[\"black\", \"white\"],\n                        help=\"background's color\")\n    parser.add_argument(\"--num_cols\", type=int, default=100, help=\"number of character for output's width\")\n    parser.add_argument(\"--scale\", type=int, default=1, help=\"upsize output\")\n    parser.add_argument(\"--fps\", type=int, default=0, help=\"frame per second\")\n    parser.add_argument(\"--overlay_ratio\", type=float, default=0.2, help=\"Overlay width ratio\")\n    args = parser.parse_args()\n    return args\n\n\ndef main(opt):\n    if opt.mode == \"simple\":\n        CHAR_LIST = '@%#*+=-:. '\n    else:\n        CHAR_LIST = \"$@B%8&WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\\|()1{}[]?-_+~<>i!lI;:,\\\"^`'. \"\n    if opt.background == \"white\":\n        bg_code = (255, 255, 255)\n    else:\n        bg_code = (0, 0, 0)\n    font = ImageFont.truetype(\"fonts/DejaVuSansMono-Bold.ttf\", size=int(10 * opt.scale))\n    cap = cv2.VideoCapture(opt.input)\n    if opt.fps == 0:\n        fps = int(cap.get(cv2.CAP_PROP_FPS))\n    else:\n        fps = opt.fps\n    num_chars = len(CHAR_LIST)\n    num_cols = opt.num_cols\n    while cap.isOpened():\n        flag, frame = cap.read()\n        if flag:\n            image = frame\n        else:\n            break\n        height, width, _ = image.shape\n        cell_width = width / opt.num_cols\n        cell_height = 2 * cell_width\n        num_rows = int(height / cell_height)\n        if num_cols > width or num_rows > height:\n            print(\"Too many columns or rows. Use default setting\")\n            cell_width = 6\n            cell_height = 12\n            num_cols = int(width / cell_width)\n            num_rows = int(height / cell_height)\n        char_width, char_height = font.getsize(\"A\")\n        out_width = char_width * num_cols\n        out_height = 2 * char_height * num_rows\n        out_image = Image.new(\"RGB\", (out_width, out_height), bg_code)\n        draw = ImageDraw.Draw(out_image)\n        for i in range(num_rows):\n            for j in range(num_cols):\n                partial_image = image[int(i * cell_height):min(int((i + 1) * cell_height), height),\n                                int(j * cell_width):min(int((j + 1) * cell_width), width), :]\n                partial_avg_color = np.sum(np.sum(partial_image, axis=0), axis=0) / (cell_height * cell_width)\n                partial_avg_color = tuple(partial_avg_color.astype(np.int32).tolist())\n                char = CHAR_LIST[min(int(np.mean(partial_image) * num_chars / 255), num_chars - 1)]\n                draw.text((j * char_width, i * char_height), char, fill=partial_avg_color, font=font)\n\n        if opt.background == \"white\":\n            cropped_image = ImageOps.invert(out_image).getbbox()\n        else:\n            cropped_image = out_image.getbbox()\n        out_image = out_image.crop(cropped_image)\n        out_image = np.array(out_image)\n        try:\n            out\n        except:\n            out = cv2.VideoWriter(opt.output, cv2.VideoWriter_fourcc(*\"XVID\"), fps,\n                                  ((out_image.shape[1], out_image.shape[0])))\n\n        if opt.overlay_ratio:\n            height, width, _ = out_image.shape\n            overlay = cv2.resize(frame, (int(width * opt.overlay_ratio), int(height * opt.overlay_ratio)))\n            out_image[height - int(height * opt.overlay_ratio):, width - int(width * opt.overlay_ratio):, :] = overlay\n        out.write(out_image)\n    cap.release()\n    out.release()\n\n\nif __name__ == '__main__':\n    opt = get_args()\n    main(opt)\n"
        }
      ]
    }
  ]
}