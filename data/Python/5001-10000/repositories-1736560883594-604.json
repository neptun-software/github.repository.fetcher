{
  "metadata": {
    "timestamp": 1736560883594,
    "page": 604,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjYxMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "piku/piku",
      "stars": 5921,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.69140625,
          "content": ".DS_Store\n.zip\n# Byte-compiled / optimized / DLL files\n__pycache__/\n*.py[cod]\n\n# C extensions\n*.so\n\n# Distribution / packaging\n.Python\nenv/\nbuild/\ndevelop-eggs/\ndist/\ndownloads/\neggs/\nlib/\nlib64/\nparts/\nsdist/\nvar/\n*.egg-info/\n.installed.cfg\n*.egg\n\n# PyInstaller\n#  Usually these files are written by a python script from a template\n#  before PyInstaller builds the exe, so as to inject date/other infos into it.\n*.manifest\n*.spec\n\n# Installer logs\npip-log.txt\npip-delete-this-directory.txt\n\n# Unit test / coverage reports\nhtmlcov/\n.tox/\n.coverage\n.cache\nnosetests.xml\ncoverage.xml\n\n# Translations\n*.mo\n*.pot\n\n# Django stuff:\n*.log\n\n# Sphinx documentation\ndocs/_build/\n\n# PyBuilder\ntarget/\n\n# IntelliJ\n.idea/"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 1.3544921875,
          "content": "# Contributing\n\n`piku` is a stable project, but we welcome contributions that:\n\n* Help us move beyond Python 3.8+ (which is the current target due to Linux LTS distribution alignment)\n* Help us do better automated testing\n* Improve documentation (some docs are a bit old by now)\n* Help us deploy `piku` in various Linux distributions and environments (check the sister repositories in the project)\n* Provide sample deployments of common applications (again, check the sister repositories in the project)\n* Allow us to better support more language runtimes\n* Allow us to support different web servers or process supervisors (Caddy springs to mind as a popular alternative for small VPSes)\n\n## Code Size / Style\n\nBy its very nature, `piku` is a very small program. By today's standards of all-encompassing solutions this may seem strange, but it would benefit from being kept that way.\n\n- Small and focused PRs. Please don't include changes that don't address the subject of your PR.\n- Follow the style of importing functions directly e.g. `from os.path import abspath`\n- Follow `PEP8`.\n\nSo please keep that in mind when contributing.\n\nFor instance, if your runtime or framework needs additional setup, it might be better to contribute an utility script to run in a `release` entry in the `Procfile` rather than patching `piku.py`--but do hack at it if that is the best way to achieve it.\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.05078125,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2016 Rui Carmo\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 5.9443359375,
          "content": "![piku logo](./img/logo.png)\n\n`piku`, inspired by `dokku`, allows you do `git push` deployments to your own servers, no matter how small they are.\n\n## Demo\n\n[![asciicast](https://asciinema.org/a/Ar31IoTkzsZmWWvlJll6p7haS.svg)](https://asciinema.org/a/Ar31IoTkzsZmWWvlJll6p7haS)\n\n[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\n\n### Documentation: [Install](#install) | [Using](#workflow) | [Procfile](https://piku.github.io/configuration/procfile.html) | [ENV](https://piku.github.io/configuration/env.html) | [Examples](https://piku.github.io/community/examples.html) | [Roadmap](https://github.com/orgs/piku/projects/2) | [Contributing](https://piku.github.io/community/contributing.html) | [LinuxConf Talk](https://www.youtube.com/watch?v=ec-GoDukHWk) | [Fast Web App Tutorial](https://github.com/piku/webapp-tutorial) | [Discussion Forum](https://github.com/piku/piku/discussions)\n\n## [Install](https://piku.github.io/install)\n\nTL;DR:\n\n```bash\ncurl https://piku.github.io/get | sh\n```\n\nThere are also [other installation methods](https://piku.github.io/install) available, including [`cloud-init`](https://github.com/piku/cloud-init) and [manual installation](https://piku.github.io/install).\n\n## Project Activity\n\n**`piku` is considered STABLE**. It is actively maintained, but \"actively\" here means the feature set is pretty much done, so it is only updated when new language runtimes are added or reproducible bugs crop up.\n\nIt currently requires Python 3.7 or above, since even though 3.8+ is now the baseline Python 3 version in Ubuntu LTS 20.04 and Debian 11 has already moved on to 3.9, there are no substantial differences between those versions.\n\n## Motivation\n\nWe wanted an Heroku/CloudFoundry-like way to deploy stuff on a few `ARM` boards, but since `dokku` didn't work on `ARM` at the time and even `docker` can be overkill sometimes, a simpler solution was needed.\n\n`piku` is currently able to deploy, manage and independently scale multiple applications per host on both ARM and Intel architectures, and works on any cloud provider (as well as bare metal) that can run Python, `nginx` and `uwsgi`.\n\n## Workflow\n\n`piku` supports a Heroku-like workflow:\n\n* Create a `git` SSH remote pointing to your `piku` server with the app name as repo name:\n  `git remote add piku piku@yourserver:appname`.\n* Push your code: `git push piku master` (or if you want to push a different branch than the current one use `git push piku release-branch-name`).\n* `piku` determines the runtime and installs the dependencies for your app (building whatever's required).\n   * For Python, it segregates each app's dependencies into a `virtualenv`.\n   * For Go, it defines a separate `GOPATH` for each app.\n   * For Node, it installs whatever is in `package.json` into `node_modules`.\n   * For Java, it builds your app depending on either `pom.xml` or `build.gradle` file.\n   * For Clojure, it can use either `leiningen` or the Clojure CLI and a `deps.edn` file.\n   * For Ruby, it does `bundle install` of your gems in an isolated folder.\n* It then looks at a [`Procfile`](https://piku.github.io/configuration/procfile.html) and starts the relevant workers using `uwsgi` as a generic process manager.\n* You can optionally also specify a `release` worker which is run once when the app is deployed.\n* You can then remotely change application settings (`config:set`) or scale up/down worker processes (`ps:scale`).\n* You can also bake application and `nginx` settings into an [`ENV`](https://piku.github.io/configuration/env.html) file.\nYou can also deploy a `gh-pages` style static site using a `static` worker type, with the root path as the argument, and run a `release` task to do some processing on the server after `git push`.\n\n### Virtual Hosts and SSL\n\n`piku` has full virtual host support - i.e., you can host multiple apps on the same VPS and use DNS aliases to access them via different hostnames. \n\n`piku`  will also set up either a private certificate or obtain one via [Let's Encrypt](https://letsencrypt.org/) to enable SSL.\n\nIf you are on a LAN and are accessing `piku` from macOS/iOS/Linux clients, you can try using [`piku/avahi-aliases`](https://github.com/piku/avahi-aliases) to announce different hosts for the same IP address via Avahi/mDNS/Bonjour.\n\n### Caching and Static Paths\n\nBesides static sites, `piku` also supports directly mapping specific URL prefixes to filesystem paths (to serve static assets) or caching back-end responses (to remove load from applications).\n\nThese features are configured by setting appropriate values in the [`ENV`](https://piku.github.io/configuration/env.html) file.\n\n### Supported Platforms\n\n`piku` is intended to work in any POSIX-like environment where you have Python, `nginx`, `uwsgi` and SSH: it has been deployed on Linux, FreeBSD, [Cygwin][cygwin] and the [Windows Subsystem for Linux][wsl].\n\nAs a baseline, it began its development on an original 256MB Raspberry Pi Model B, and still runs reliably on it.\n\nBut its main use is as a micro-PaaS to run applications on cloud servers with both Intel and ARM CPUs, with Debian and Ubuntu Linux as target platforms.\n\n### Supported Runtimes\n\n`piku` currently supports apps written in Python, Node, Clojure, Java and a few other languages (like Go) in the works.\n\nBut as a general rule, if it can be invoked from a shell, it can be run inside `piku`.\n\n### Core values\n\n * Run on low end devices.\n * Accessible to hobbyists and K-12 schools.\n * ~1500 lines readable code.\n * Functional code style.\n * Few (single?) dependencies\n * [12 factor app](https://12factor.net).\n * Simplify user experience.\n * Cover 80% of common use cases.\n * Sensible defaults for all features.\n * Leverage distro packages in Raspbian/Debian/Ubuntu (Alpine and RHEL support is WIP)\n * Leverage standard tooling (`git`, `ssh`, `uwsgi`, `nginx`).\n * Preserve backwards compatibility where possible\n\n[raspi-cluster]: https://github.com/rcarmo/raspi-cluster\n[cygwin]: http://www.cygwin.com\n[wsl]: https://en.wikipedia.org/wiki/Windows_Subsystem_for_Linux\n"
        },
        {
          "name": "binary",
          "type": "tree",
          "content": null
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "img",
          "type": "tree",
          "content": null
        },
        {
          "name": "legacy",
          "type": "tree",
          "content": null
        },
        {
          "name": "nginx.default.dist",
          "type": "blob",
          "size": 0.599609375,
          "content": "server {\n\tlisten 80 default_server;\n\tlisten [::]:80 default_server;\n\n\t# SSL configuration\n\t#\n\t# listen 443 ssl default_server;\n\t# listen [::]:443 ssl default_server;\n\t#\n\t# Self signed certs generated by the ssl-cert package\n\t# Don't use them in a production server!\n\t#\n\t# include snippets/snakeoil.conf;\n\n\troot /var/www/html;\n\n\t# Add index.php to the list if you are using PHP\n\tindex index.html index.htm;\n\n\tserver_name _;\n\n\tlocation / {\n\t\t# First attempt to serve request as file, then\n\t\t# as directory, then fall back to displaying a 404.\n\t\ttry_files $uri $uri/ =404;\n\t}\n}\ninclude /home/piku/.piku/nginx/*.conf;\n"
        },
        {
          "name": "piku",
          "type": "blob",
          "size": 2.6220703125,
          "content": "#!/bin/sh\n\n# TODO: support config locations:\n# ./.piku-server\n# ~/.piku-server\n# git config --get remote.piku.url\n# git config --get remote.paas.url\n\nif grep -q WSL /proc/version 2>/dev/null\nthen\n  # On WSL, use the Windows ssh.exe to benefit from 1Password integration\n  SSH=\"ssh.exe\"\nelse\n  SSH=\"ssh\"\nfi\n\nremote_name=\"piku\"\nif [ \"$1\" = \"--remote\" ] || [ \"$1\" = \"-r\" ]\nthen\n  shift\n  remote_name=\"$1\"\n  shift\nfi\n\ngitremote=$(git config --get remote.\"$remote_name\".url)\nremote=${gitremote:-\"${PIKU_SERVER}:${PIKU_APP}\"}\n\ngithome=\"https://raw.githubusercontent.com/piku/piku/master/\"\n\nout() { printf \"%s\\n\" \"$*\" >&2; }\n\nif [ \"$1\" = \"init\" ]\nthen\n  if [ -f \"ENV\" ]\n  then\n    echo \"ENV file already exists.\"\n  else\n    curl -s \"${githome}examples/ENV\" > ENV && echo \"Wrote ./ENV file.\"\n  fi\n  if [ -f \"Procfile\" ]\n  then\n    echo \"Procfile already exists.\"\n  else\n    curl -s \"${githome}examples/Procfile\" > Procfile && echo \"Wrote ./Procfile.\"\n  fi\n  if [ \"$gitremote\" = \"\" ]\n  then\n    echo \"Now set up your piku remote for this app:\"\n    echo \"git remote add piku piku@HOSTNAME:APPNAME\"\n  fi\n  exit\nfi\n\nout \"Piku remote operator.\"\n\nif [ \"$remote\" = \"\" ] || [ \"$remote\" = \":\" ]\nthen\n  out\n  out \"Error: no piku server configured.\"\n  out \"Use PIKU_SERVER=piku@MYSERVER.NET or configure a git remote called 'piku'.\"\n  out\nelse\n  server=$(echo \"$remote\" | cut -f1 -d\":\" 2>/dev/null)\n  app=$(echo \"$remote\" | cut -f2 -d\":\" 2>/dev/null)\n  # gather SSH flags\n  while [ \"${1#\\-}\"x != \"${1}x\" ];\n  do\n    sshflags=\"${sshflags} ${1}\"\n    shift\n  done\n  # check the Piku command to be run\n  cmd=\"$1\"\n  out \"Server: $server\"\n  out \"App: $app\"\n  out\n  case \"$cmd\" in\n    \"\"|help)\n      command $SSH -o LogLevel=QUIET ${sshflags:+${sshflags}} \"$server\" \"$@\" | grep -v \"INTERNAL\"\n      echo \"  shell             Local command to start an SSH session in the remote.\"\n      echo \"  init              Local command to download an example ENV and Procfile.\"\n      echo \"  download          Local command to scp down a remote file. args: REMOTE-FILE(s) LOCAL-PATH\"\n      echo \"                    Remote file path is relative to the app folder.\"\n      ;;\n    apps|setup|setup:ssh|update)\n      # shellcheck disable=SC2029 # caused by the final \"$@\", expanded on the client side\n      command $SSH ${sshflags:+${sshflags}} \"$server\" \"$@\"\n      ;;\n    shell)\n      $SSH -t \"$server\" run \"$app\" bash\n      ;;\n    download)\n      scp \"$server:~/.piku/apps/${app}/${2}\" \"${3:-'.'}\"\n      ;;\n    *)\n      shift # remove cmd arg\n      # shellcheck disable=SC2029 # caused by the final \"$@\", expanded on the client side\n      command $SSH ${sshflags:+${sshflags}} \"$server\" \"$cmd\" \"$app\" \"$@\"\n      ;;\n  esac\nfi\n"
        },
        {
          "name": "piku-nginx.path",
          "type": "blob",
          "size": 0.15234375,
          "content": "[Unit]\nDescription=Monitor .piku/nginx for changes\n\n[Path]\nPathChanged=/home/piku/.piku/nginx\nUnit=piku-nginx.service\n\n[Install]\nWantedBy=multi-user.target\n"
        },
        {
          "name": "piku-nginx.service",
          "type": "blob",
          "size": 0.1591796875,
          "content": "[Unit]\nDescription=Restarts NGINX when .piku/nginx changes.\n\n[Service]\nType=simple\nExecStart=/usr/bin/systemctl reload nginx\n\n[Install]\nWantedBy=multi-user.target\n"
        },
        {
          "name": "piku.py",
          "type": "blob",
          "size": 67.158203125,
          "content": "#!/usr/bin/env python3\n\n\"Piku Micro-PaaS\"\n\ntry:\n    from sys import version_info\n    assert version_info >= (3, 7)\nexcept AssertionError:\n    exit(\"Piku requires Python 3.7 or above\")\n\nfrom importlib import import_module\nfrom collections import defaultdict, deque\nfrom fcntl import fcntl, F_SETFL, F_GETFL\nfrom glob import glob\nfrom json import loads\nfrom multiprocessing import cpu_count\nfrom os import chmod, getgid, getuid, symlink, unlink, remove, stat, listdir, environ, makedirs, O_NONBLOCK\nfrom os.path import abspath, basename, dirname, exists, getmtime, join, realpath, splitext, isdir\nfrom pwd import getpwuid\nfrom grp import getgrgid\nfrom re import sub, match\nfrom shutil import copyfile, rmtree, which\nfrom socket import socket, AF_INET, SOCK_STREAM\nfrom stat import S_IRUSR, S_IWUSR, S_IXUSR\nfrom subprocess import call, check_output, Popen, STDOUT\nfrom sys import argv, stdin, stdout, stderr, version_info, exit, path as sys_path\nfrom tempfile import NamedTemporaryFile\nfrom time import sleep\nfrom traceback import format_exc\nfrom urllib.request import urlopen\n\nfrom click import argument, group, secho as echo, pass_context, CommandCollection\n\n# === Make sure we can access all system and user binaries ===\n\nif 'sbin' not in environ['PATH']:\n    environ['PATH'] = \"/usr/local/sbin:/usr/sbin:/sbin:\" + environ['PATH']\nif '.local' not in environ['PATH']:\n    environ['PATH'] = environ['HOME'] + \"/.local/bin:\" + environ['PATH']\n\n# === Globals - all tweakable settings are here ===\n\nPIKU_RAW_SOURCE_URL = \"https://raw.githubusercontent.com/piku/piku/master/piku.py\"\nPIKU_ROOT = environ.get('PIKU_ROOT', join(environ['HOME'], '.piku'))\nPIKU_BIN = join(environ['HOME'], 'bin')\nPIKU_SCRIPT = realpath(__file__)\nPIKU_PLUGIN_ROOT = abspath(join(PIKU_ROOT, \"plugins\"))\nAPP_ROOT = abspath(join(PIKU_ROOT, \"apps\"))\nDATA_ROOT = abspath(join(PIKU_ROOT, \"data\"))\nENV_ROOT = abspath(join(PIKU_ROOT, \"envs\"))\nGIT_ROOT = abspath(join(PIKU_ROOT, \"repos\"))\nLOG_ROOT = abspath(join(PIKU_ROOT, \"logs\"))\nNGINX_ROOT = abspath(join(PIKU_ROOT, \"nginx\"))\nCACHE_ROOT = abspath(join(PIKU_ROOT, \"cache\"))\nUWSGI_AVAILABLE = abspath(join(PIKU_ROOT, \"uwsgi-available\"))\nUWSGI_ENABLED = abspath(join(PIKU_ROOT, \"uwsgi-enabled\"))\nUWSGI_ROOT = abspath(join(PIKU_ROOT, \"uwsgi\"))\nUWSGI_LOG_MAXSIZE = '1048576'\nACME_ROOT = environ.get('ACME_ROOT', join(environ['HOME'], '.acme.sh'))\nACME_WWW = abspath(join(PIKU_ROOT, \"acme\"))\nACME_ROOT_CA = environ.get('ACME_ROOT_CA', 'letsencrypt.org')\n\n# === Make sure we can access piku user-installed binaries === #\n\nif PIKU_BIN not in environ['PATH']:\n    environ['PATH'] = PIKU_BIN + \":\" + environ['PATH']\n\n# pylint: disable=anomalous-backslash-in-string\nNGINX_TEMPLATE = \"\"\"\n$PIKU_INTERNAL_PROXY_CACHE_PATH\nupstream $APP {\n  server $NGINX_SOCKET;\n}\nserver {\n  listen              $NGINX_IPV6_ADDRESS:80;\n  listen              $NGINX_IPV4_ADDRESS:80;\n\n  location ^~ /.well-known/acme-challenge {\n    allow all;\n    root ${ACME_WWW};\n  }\n$PIKU_INTERNAL_NGINX_COMMON\n}\n\"\"\"\n\nNGINX_HTTPS_ONLY_TEMPLATE = \"\"\"\n$PIKU_INTERNAL_PROXY_CACHE_PATH\nupstream $APP {\n  server $NGINX_SOCKET;\n}\nserver {\n  listen              $NGINX_IPV6_ADDRESS:80;\n  listen              $NGINX_IPV4_ADDRESS:80;\n  server_name         $NGINX_SERVER_NAME;\n\n  location ^~ /.well-known/acme-challenge {\n    allow all;\n    root ${ACME_WWW};\n  }\n\n  location / {\n    return 301 https://$server_name$request_uri;\n  }\n}\n\nserver {\n$PIKU_INTERNAL_NGINX_COMMON\n}\n\"\"\"\n# pylint: enable=anomalous-backslash-in-string\n\nNGINX_COMMON_FRAGMENT = r\"\"\"\n  listen              $NGINX_IPV6_ADDRESS:$NGINX_SSL;\n  listen              $NGINX_IPV4_ADDRESS:$NGINX_SSL;\n  ssl_certificate     $NGINX_ROOT/$APP.crt;\n  ssl_certificate_key $NGINX_ROOT/$APP.key;\n  server_name         $NGINX_SERVER_NAME;\n  # These are not required under systemd - enable for debugging only\n  # access_log        $LOG_ROOT/$APP/access.log;\n  # error_log         $LOG_ROOT/$APP/error.log;\n\n  # Enable gzip compression\n  gzip on;\n  gzip_proxied any;\n  gzip_types text/plain text/xml text/css text/javascript text/js application/x-javascript application/javascript application/json application/xml+rss application/atom+xml image/svg+xml;\n  gzip_comp_level 7;\n  gzip_min_length 2048;\n  gzip_vary on;\n  gzip_disable \"MSIE [1-6]\\.(?!.*SV1)\";\n  # set a custom header for requests\n  add_header X-Deployed-By Piku;\n\n  $PIKU_INTERNAL_NGINX_CUSTOM_CLAUSES\n  $PIKU_INTERNAL_NGINX_STATIC_MAPPINGS\n  $PIKU_INTERNAL_NGINX_CACHE_MAPPINGS\n  $PIKU_INTERNAL_NGINX_BLOCK_GIT\n  $PIKU_INTERNAL_NGINX_PORTMAP\n\"\"\"\n\nNGINX_PORTMAP_FRAGMENT = \"\"\"\n  location    / {\n    $PIKU_INTERNAL_NGINX_UWSGI_SETTINGS\n    proxy_http_version 1.1;\n    proxy_set_header Upgrade $http_upgrade;\n    proxy_set_header Connection \"upgrade\";\n    proxy_set_header Host $host;\n    proxy_set_header X-Forwarded-Proto $scheme;\n    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n    proxy_set_header X-Remote-Address $remote_addr;\n    proxy_set_header X-Forwarded-Port $server_port;\n    proxy_set_header X-Request-Start $msec;\n    $NGINX_ACL\n  }\n\"\"\"\n\nNGINX_ACME_FIRSTRUN_TEMPLATE = \"\"\"\nserver {\n  listen              $NGINX_IPV6_ADDRESS:80;\n  listen              $NGINX_IPV4_ADDRESS:80;\n  server_name         $NGINX_SERVER_NAME;\n  location ^~ /.well-known/acme-challenge {\n    allow all;\n    root ${ACME_WWW};\n  }\n}\n\"\"\"\n\nPIKU_INTERNAL_NGINX_STATIC_MAPPING = \"\"\"\n  location $static_url {\n      sendfile on;\n      sendfile_max_chunk 1m;\n      tcp_nopush on;\n      directio 8m;\n      aio threads;\n      alias $static_path;\n      try_files $uri $uri.html $uri/ $catch_all =404;\n  }\n\"\"\"\n\nPIKU_INTERNAL_PROXY_CACHE_PATH = \"\"\"\nuwsgi_cache_path $cache_path levels=1:2 keys_zone=$app:20m inactive=$cache_time_expiry max_size=$cache_size use_temp_path=off;\n\"\"\"\n\nPIKU_INTERNAL_NGINX_CACHE_MAPPING = \"\"\"\n    location ~* ^/($cache_prefixes) {\n        uwsgi_cache $APP;\n        uwsgi_cache_min_uses 1;\n        uwsgi_cache_key $host$uri;\n        uwsgi_cache_valid 200 304 $cache_time_content;\n        uwsgi_cache_valid 301 307 $cache_time_redirects;\n        uwsgi_cache_valid 500 502 503 504 0s;\n        uwsgi_cache_valid any $cache_time_any;\n        uwsgi_hide_header Cache-Control;\n        add_header Cache-Control \"public, max-age=$cache_time_control\";\n        add_header X-Cache $upstream_cache_status;\n        $PIKU_INTERNAL_NGINX_UWSGI_SETTINGS\n    }\n\"\"\"\n\nPIKU_INTERNAL_NGINX_UWSGI_SETTINGS = \"\"\"\n    uwsgi_pass $APP;\n    uwsgi_param QUERY_STRING $query_string;\n    uwsgi_param REQUEST_METHOD $request_method;\n    uwsgi_param CONTENT_TYPE $content_type;\n    uwsgi_param CONTENT_LENGTH $content_length;\n    uwsgi_param REQUEST_URI $request_uri;\n    uwsgi_param PATH_INFO $document_uri;\n    uwsgi_param DOCUMENT_ROOT $document_root;\n    uwsgi_param SERVER_PROTOCOL $server_protocol;\n    uwsgi_param X_FORWARDED_FOR $proxy_add_x_forwarded_for;\n    uwsgi_param REMOTE_ADDR $remote_addr;\n    uwsgi_param REMOTE_PORT $remote_port;\n    uwsgi_param SERVER_ADDR $server_addr;\n    uwsgi_param SERVER_PORT $server_port;\n    uwsgi_param SERVER_NAME $server_name;\n\"\"\"\n\nCRON_REGEXP = r\"^((?:(?:\\*\\/)?\\d+)|\\*) ((?:(?:\\*\\/)?\\d+)|\\*) ((?:(?:\\*\\/)?\\d+)|\\*) ((?:(?:\\*\\/)?\\d+)|\\*) ((?:(?:\\*\\/)?\\d+)|\\*) (.*)$\"\n\n# === Utility functions ===\n\n\ndef sanitize_app_name(app):\n    \"\"\"Sanitize the app name and build matching path\"\"\"\n\n    app = \"\".join(c for c in app if c.isalnum() or c in ('.', '_', '-')).rstrip().lstrip('/')\n    return app\n\n\ndef exit_if_invalid(app):\n    \"\"\"Utility function for error checking upon command startup.\"\"\"\n\n    app = sanitize_app_name(app)\n    if not exists(join(APP_ROOT, app)):\n        echo(\"Error: app '{}' not found.\".format(app), fg='red')\n        exit(1)\n    return app\n\n\ndef get_free_port(address=\"\"):\n    \"\"\"Find a free TCP port (entirely at random)\"\"\"\n\n    s = socket(AF_INET, SOCK_STREAM)\n    s.bind((address, 0))  # lgtm [py/bind-socket-all-network-interfaces]\n    port = s.getsockname()[1]\n    s.close()\n    return port\n\n\ndef get_boolean(value):\n    \"\"\"Convert a boolean-ish string to a boolean.\"\"\"\n\n    return value.lower() in ['1', 'on', 'true', 'enabled', 'yes', 'y']\n\n\ndef write_config(filename, bag, separator='='):\n    \"\"\"Helper for writing out config files\"\"\"\n\n    with open(filename, 'w') as h:\n        # pylint: disable=unused-variable\n        for k, v in bag.items():\n            h.write('{k:s}{separator:s}{v}\\n'.format(**locals()))\n\n\ndef setup_authorized_keys(ssh_fingerprint, script_path, pubkey):\n    \"\"\"Sets up an authorized_keys file to redirect SSH commands\"\"\"\n\n    authorized_keys = join(environ['HOME'], '.ssh', 'authorized_keys')\n    if not exists(dirname(authorized_keys)):\n        makedirs(dirname(authorized_keys))\n    # Restrict features and force all SSH commands to go through our script\n    with open(authorized_keys, 'a') as h:\n        h.write(\"\"\"command=\"FINGERPRINT={ssh_fingerprint:s} NAME=default {script_path:s} $SSH_ORIGINAL_COMMAND\",no-agent-forwarding,no-user-rc,no-X11-forwarding,no-port-forwarding {pubkey:s}\\n\"\"\".format(**locals()))\n    chmod(dirname(authorized_keys), S_IRUSR | S_IWUSR | S_IXUSR)\n    chmod(authorized_keys, S_IRUSR | S_IWUSR)\n\n\ndef parse_procfile(filename):\n    \"\"\"Parses a Procfile and returns the worker types. Only one worker of each type is allowed.\"\"\"\n\n    workers = {}\n    if not exists(filename):\n        return None\n\n    with open(filename, 'r') as procfile:\n        for line_number, line in enumerate(procfile):\n            line = line.strip()\n            if line.startswith(\"#\") or not line:\n                continue\n            try:\n                kind, command = map(lambda x: x.strip(), line.split(\":\", 1))\n                # Check for cron patterns\n                if kind.startswith(\"cron\"):\n                    limits = [59, 24, 31, 12, 7]\n                    res = match(CRON_REGEXP, command)\n                    if res:\n                        matches = res.groups()\n                        for i in range(len(limits)):\n                            if int(matches[i].replace(\"*/\", \"\").replace(\"*\", \"1\")) > limits[i]:\n                                raise ValueError\n                workers[kind] = command\n            except Exception:\n                echo(\"Warning: misformatted Procfile entry '{}' at line {}\".format(line, line_number), fg='yellow')\n    if len(workers) == 0:\n        return {}\n    # WSGI trumps regular web workers\n    if 'wsgi' in workers or 'jwsgi' in workers or 'rwsgi' in workers:\n        if 'web' in workers:\n            echo(\"Warning: found both 'wsgi' and 'web' workers, disabling 'web'\", fg='yellow')\n            del workers['web']\n    return workers\n\n\ndef expandvars(buffer, env, default=None, skip_escaped=False):\n    \"\"\"expand shell-style environment variables in a buffer\"\"\"\n\n    def replace_var(match):\n        return env.get(match.group(2) or match.group(1), match.group(0) if default is None else default)\n\n    pattern = (r'(?<!\\\\)' if skip_escaped else '') + r'\\$(\\w+|\\{([^}]*)\\})'\n    return sub(pattern, replace_var, buffer)\n\n\ndef command_output(cmd):\n    \"\"\"executes a command and grabs its output, if any\"\"\"\n    try:\n        env = environ\n        return str(check_output(cmd, stderr=STDOUT, env=env, shell=True))\n    except Exception:\n        return \"\"\n\n\ndef parse_settings(filename, env={}):\n    \"\"\"Parses a settings file and returns a dict with environment variables\"\"\"\n\n    if not exists(filename):\n        return {}\n\n    with open(filename, 'r') as settings:\n        for line in settings:\n            if line[0] == '#' or len(line.strip()) == 0:  # ignore comments and newlines\n                continue\n            try:\n                k, v = map(lambda x: x.strip(), line.split(\"=\", 1))\n                env[k] = expandvars(v, env)\n            except Exception:\n                echo(\"Error: malformed setting '{}', ignoring file.\".format(line), fg='red')\n                return {}\n    return env\n\n\ndef check_requirements(binaries):\n    \"\"\"Checks if all the binaries exist and are executable\"\"\"\n\n    echo(\"-----> Checking requirements: {}\".format(binaries), fg='green')\n    requirements = list(map(which, binaries))\n    echo(str(requirements))\n\n    if None in requirements:\n        return False\n    return True\n\n\ndef found_app(kind):\n    \"\"\"Helper function to output app detected\"\"\"\n    echo(\"-----> {} app detected.\".format(kind), fg='green')\n    return True\n\n\ndef do_deploy(app, deltas={}, newrev=None):\n    \"\"\"Deploy an app by resetting the work directory\"\"\"\n\n    app_path = join(APP_ROOT, app)\n    procfile = join(app_path, 'Procfile')\n    log_path = join(LOG_ROOT, app)\n\n    env = {'GIT_WORK_DIR': app_path}\n    if exists(app_path):\n        echo(\"-----> Deploying app '{}'\".format(app), fg='green')\n        call('git fetch --quiet', cwd=app_path, env=env, shell=True)\n        if newrev:\n            call('git reset --hard {}'.format(newrev), cwd=app_path, env=env, shell=True)\n        call('git submodule init', cwd=app_path, env=env, shell=True)\n        call('git submodule update', cwd=app_path, env=env, shell=True)\n        if not exists(log_path):\n            makedirs(log_path)\n        workers = parse_procfile(procfile)\n        if workers and len(workers) > 0:\n            settings = {}\n            if \"preflight\" in workers:\n                echo(\"-----> Running preflight.\", fg='green')\n                retval = call(workers[\"preflight\"], cwd=app_path, env=settings, shell=True)\n                if retval:\n                    echo(\"-----> Exiting due to preflight command error value: {}\".format(retval))\n                    exit(retval)\n                workers.pop(\"preflight\", None)\n            if exists(join(app_path, 'requirements.txt')) and found_app(\"Python\"):\n                settings.update(deploy_python(app, deltas))\n            elif exists(join(app_path, 'pyproject.toml')) and which('poetry') and found_app(\"Python\"):\n                settings.update(deploy_python_with_poetry(app, deltas))\n            elif exists(join(app_path, 'Gemfile')) and found_app(\"Ruby Application\") and check_requirements(['ruby', 'gem', 'bundle']):\n                settings.update(deploy_ruby(app, deltas))\n            elif exists(join(app_path, 'package.json')) and found_app(\"Node\") and (\n                    check_requirements(['nodejs', 'npm']) or check_requirements(['node', 'npm']) or check_requirements(['nodeenv'])):\n                settings.update(deploy_node(app, deltas))\n            elif exists(join(app_path, 'pom.xml')) and found_app(\"Java Maven\") and check_requirements(['java', 'mvn']):\n                settings.update(deploy_java_maven(app, deltas))\n            elif exists(join(app_path, 'build.gradle')) and found_app(\"Java Gradle\") and check_requirements(['java', 'gradle']):\n                settings.update(deploy_java_gradle(app, deltas))\n            elif (exists(join(app_path, 'Godeps')) or exists(join(app_path, 'go.mod')) or len(glob(join(app_path, '*.go')))) and found_app(\"Go\") and check_requirements(['go']):\n                settings.update(deploy_go(app, deltas))\n            elif exists(join(app_path, 'deps.edn')) and found_app(\"Clojure CLI\") and check_requirements(['java', 'clojure']):\n                settings.update(deploy_clojure_cli(app, deltas))\n            elif exists(join(app_path, 'project.clj')) and found_app(\"Clojure Lein\") and check_requirements(['java', 'lein']):\n                settings.update(deploy_clojure_leiningen(app, deltas))\n            elif 'php' in workers:\n                if check_requirements(['uwsgi_php']):\n                    echo(\"-----> PHP app detected.\", fg='green')\n                    settings.update(deploy_identity(app, deltas))\n                else:\n                    echo(\"-----> PHP app detected but uwsgi-plugin-php was not found\", fg='red')\n            elif exists(join(app_path, 'Cargo.toml')) and exists(join(app_path, 'rust-toolchain.toml')) and found_app(\"Rust\") and check_requirements(['rustc', 'cargo']):\n                settings.update(deploy_rust(app, deltas))\n            elif 'release' in workers and 'web' in workers:\n                echo(\"-----> Generic app detected.\", fg='green')\n                settings.update(deploy_identity(app, deltas))\n            elif 'static' in workers:\n                echo(\"-----> Static app detected.\", fg='green')\n                settings.update(deploy_identity(app, deltas))\n            else:\n                echo(\"-----> Could not detect runtime!\", fg='red')\n            # TODO: detect other runtimes\n            if \"release\" in workers:\n                echo(\"-----> Releasing\", fg='green')\n                retval = call(workers[\"release\"], cwd=app_path, env=settings, shell=True)\n                if retval:\n                    echo(\"-----> Exiting due to release command error value: {}\".format(retval))\n                    exit(retval)\n                workers.pop(\"release\", None)\n        else:\n            echo(\"Error: Invalid Procfile for app '{}'.\".format(app), fg='red')\n    else:\n        echo(\"Error: app '{}' not found.\".format(app), fg='red')\n\n\ndef deploy_java_gradle(app, deltas={}):\n    \"\"\"Deploy a Java application using Gradle\"\"\"\n    java_path = join(ENV_ROOT, app)\n    build_path = join(APP_ROOT, app, 'build')\n    env_file = join(APP_ROOT, app, 'ENV')\n\n    env = {\n        'VIRTUAL_ENV': java_path,\n        \"PATH\": ':'.join([join(java_path, \"bin\"), join(app, \".bin\"), environ['PATH']])\n    }\n\n    if exists(env_file):\n        env.update(parse_settings(env_file, env))\n\n    if not exists(java_path):\n        makedirs(java_path)\n\n    if not exists(build_path):\n        echo(\"-----> Building Java Application\")\n        call('gradle build', cwd=join(APP_ROOT, app), env=env, shell=True)\n\n    else:\n        echo(\"-----> Removing previous builds\")\n        echo(\"-----> Rebuilding Java Application\")\n        call('gradle clean build', cwd=join(APP_ROOT, app), env=env, shell=True)\n\n    return spawn_app(app, deltas)\n\n\ndef deploy_java_maven(app, deltas={}):\n    \"\"\"Deploy a Java application using Maven\"\"\"\n    # TODO: Use jenv to isolate Java Application environments\n\n    java_path = join(ENV_ROOT, app)\n    target_path = join(APP_ROOT, app, 'target')\n    env_file = join(APP_ROOT, app, 'ENV')\n\n    env = {\n        'VIRTUAL_ENV': java_path,\n        \"PATH\": ':'.join([join(java_path, \"bin\"), join(app, \".bin\"), environ['PATH']])\n    }\n\n    if exists(env_file):\n        env.update(parse_settings(env_file, env))\n\n    if not exists(java_path):\n        makedirs(java_path)\n\n    if not exists(target_path):\n        echo(\"-----> Building Java Application\")\n        call('mvn package', cwd=join(APP_ROOT, app), env=env, shell=True)\n\n    else:\n        echo(\"-----> Removing previous builds\")\n        echo(\"-----> Rebuilding Java Application\")\n        call('mvn clean package', cwd=join(APP_ROOT, app), env=env, shell=True)\n\n    return spawn_app(app, deltas)\n\n\ndef deploy_clojure_cli(app, deltas={}):\n    \"\"\"Deploy a Clojure Application\"\"\"\n\n    virtual = join(ENV_ROOT, app)\n    target_path = join(APP_ROOT, app, 'target')\n    env_file = join(APP_ROOT, app, 'ENV')\n\n    if not exists(target_path):\n        makedirs(virtual)\n    env = {\n        'VIRTUAL_ENV': virtual,\n        \"PATH\": ':'.join([join(virtual, \"bin\"), join(app, \".bin\"), environ['PATH']]),\n        \"CLJ_CONFIG\": environ.get('CLJ_CONFIG', join(environ['HOME'], '.clojure')),\n    }\n    if exists(env_file):\n        env.update(parse_settings(env_file, env))\n    echo(\"-----> Building Clojure Application\")\n    call('clojure -T:build release', cwd=join(APP_ROOT, app), env=env, shell=True)\n\n    return spawn_app(app, deltas)\n\n\ndef deploy_clojure_leiningen(app, deltas={}):\n    \"\"\"Deploy a Clojure Application\"\"\"\n\n    virtual = join(ENV_ROOT, app)\n    target_path = join(APP_ROOT, app, 'target')\n    env_file = join(APP_ROOT, app, 'ENV')\n\n    if not exists(target_path):\n        makedirs(virtual)\n    env = {\n        'VIRTUAL_ENV': virtual,\n        \"PATH\": ':'.join([join(virtual, \"bin\"), join(app, \".bin\"), environ['PATH']]),\n        \"LEIN_HOME\": environ.get('LEIN_HOME', join(environ['HOME'], '.lein')),\n    }\n    if exists(env_file):\n        env.update(parse_settings(env_file, env))\n    echo(\"-----> Building Clojure Application\")\n    call('lein clean', cwd=join(APP_ROOT, app), env=env, shell=True)\n    call('lein uberjar', cwd=join(APP_ROOT, app), env=env, shell=True)\n\n    return spawn_app(app, deltas)\n\n\ndef deploy_ruby(app, deltas={}):\n    \"\"\"Deploy a Ruby Application\"\"\"\n\n    virtual = join(ENV_ROOT, app)\n    env_file = join(APP_ROOT, app, 'ENV')\n\n    env = {\n        'VIRTUAL_ENV': virtual,\n        \"PATH\": ':'.join([join(virtual, \"bin\"), join(app, \".bin\"), environ['PATH']]),\n    }\n    if exists(env_file):\n        env.update(parse_settings(env_file, env))\n\n    if not exists(virtual):\n        echo(\"-----> Building Ruby Application\")\n        makedirs(virtual)\n        call('bundle config set --local path $VIRTUAL_ENV', cwd=join(APP_ROOT, app), env=env, shell=True)\n    else:\n        echo(\"------> Rebuilding Ruby Application\")\n\n    call('bundle install', cwd=join(APP_ROOT, app), env=env, shell=True)\n\n    return spawn_app(app, deltas)\n\n\ndef deploy_go(app, deltas={}):\n    \"\"\"Deploy a Go application\"\"\"\n\n    go_path = join(ENV_ROOT, app)\n    deps = join(APP_ROOT, app, 'Godeps')\n    go_mod = join(APP_ROOT, app, 'go.mod')\n\n    first_time = False\n    if not exists(go_path):\n        echo(\"-----> Creating GOPATH for '{}'\".format(app), fg='green')\n        makedirs(go_path)\n        # copy across a pre-built GOPATH to save provisioning time\n        call('cp -a $HOME/gopath {}'.format(app), cwd=ENV_ROOT, shell=True)\n        first_time = True\n\n    if exists(deps):\n        if first_time or getmtime(deps) > getmtime(go_path):\n            echo(\"-----> Running godep for '{}'\".format(app), fg='green')\n            env = {\n                'GOPATH': '$HOME/gopath',\n                'GOROOT': '$HOME/go',\n                'PATH': '$PATH:$HOME/go/bin',\n                'GO15VENDOREXPERIMENT': '1'\n            }\n            call('godep update ...', cwd=join(APP_ROOT, app), env=env, shell=True)\n\n    if exists(go_mod):\n        echo(\"-----> Running go mod tidy for '{}'\".format(app), fg='green')\n        call('go mod tidy', cwd=join(APP_ROOT, app), shell=True)\n\n    return spawn_app(app, deltas)\n\n\ndef deploy_rust(app, deltas={}):\n    \"\"\"Deploy a Rust application\"\"\"\n\n    app_path = join(APP_ROOT, app)\n    echo(\"-----> Running cargo build for '{}'\".format(app), fg='green')\n    call('cargo build', cwd=app_path, shell=True)\n    return spawn_app(app, deltas)\n\n\ndef deploy_node(app, deltas={}):\n    \"\"\"Deploy a Node application\"\"\"\n\n    virtualenv_path = join(ENV_ROOT, app)\n    node_path = join(ENV_ROOT, app, \"node_modules\")\n    node_modules_symlink = join(APP_ROOT, app, \"node_modules\")\n    npm_prefix = abspath(join(node_path, \"..\"))\n    env_file = join(APP_ROOT, app, 'ENV')\n    deps = join(APP_ROOT, app, 'package.json')\n\n    first_time = False\n    if not exists(node_path):\n        echo(\"-----> Creating node_modules for '{}'\".format(app), fg='green')\n        makedirs(node_path)\n        first_time = True\n\n    env = {\n        'VIRTUAL_ENV': virtualenv_path,\n        'NODE_PATH': node_path,\n        'NPM_CONFIG_PREFIX': npm_prefix,\n        \"PATH\": ':'.join([join(virtualenv_path, \"bin\"), join(node_path, \".bin\"), environ['PATH']])\n    }\n    if exists(env_file):\n        env.update(parse_settings(env_file, env))\n\n    package_manager_command = env.get(\"NODE_PACKAGE_MANAGER\", \"npm --package-lock=false\")\n    package_manager = package_manager_command.split(\" \")[0]\n\n    # include node binaries on our path\n    environ[\"PATH\"] = env[\"PATH\"]\n\n    version = env.get(\"NODE_VERSION\")\n    node_binary = join(virtualenv_path, \"bin\", \"node\")\n    installed = check_output(\"{} -v\".format(node_binary), cwd=join(APP_ROOT, app), env=env, shell=True).decode(\"utf8\").rstrip(\n        \"\\n\") if exists(node_binary) else \"\"\n\n    if version and check_requirements(['nodeenv']):\n        if not installed.endswith(version):\n            started = glob(join(UWSGI_ENABLED, '{}*.ini'.format(app)))\n            if installed and len(started):\n                echo(\"Warning: Can't update node with app running. Stop the app & retry.\", fg='yellow')\n            else:\n                echo(\"-----> Installing node version '{NODE_VERSION:s}' using nodeenv\".format(**env), fg='green')\n                call(\"nodeenv --prebuilt --node={NODE_VERSION:s} --clean-src --force {VIRTUAL_ENV:s}\".format(**env),\n                     cwd=virtualenv_path, env=env, shell=True)\n        else:\n            echo(\"-----> Node is installed at {}.\".format(version))\n\n    if exists(deps) and check_requirements(['npm']):\n        if first_time or getmtime(deps) > getmtime(node_path):\n            copyfile(join(APP_ROOT, app, 'package.json'), join(ENV_ROOT, app, 'package.json'))\n            if not exists(node_modules_symlink):\n                symlink(node_path, node_modules_symlink)\n            if package_manager != \"npm\":\n                echo(\"-----> Installing package manager {} with npm\".format(package_manager))\n                call(\"npm install -g {}\".format(package_manager), cwd=join(APP_ROOT, app), env=env, shell=True)\n            echo(\"-----> Running {} for '{}'\".format(package_manager_command, app), fg='green')\n            call('{} install --prefix {}'.format(package_manager_command, npm_prefix), cwd=join(APP_ROOT, app), env=env, shell=True)\n    return spawn_app(app, deltas)\n\n\ndef deploy_python(app, deltas={}):\n    \"\"\"Deploy a Python application\"\"\"\n\n    virtualenv_path = join(ENV_ROOT, app)\n    requirements = join(APP_ROOT, app, 'requirements.txt')\n    env_file = join(APP_ROOT, app, 'ENV')\n    # Set unbuffered output and readable UTF-8 mapping\n    env = {\n        'PYTHONUNBUFFERED': '1',\n        'PYTHONIOENCODING': 'UTF_8:replace'\n    }\n    if exists(env_file):\n        env.update(parse_settings(env_file, env))\n\n    # TODO: improve version parsing\n    # pylint: disable=unused-variable\n    version = int(env.get(\"PYTHON_VERSION\", \"3\"))\n\n    first_time = False\n    if not exists(join(virtualenv_path, \"bin\", \"activate\")):\n        echo(\"-----> Creating virtualenv for '{}'\".format(app), fg='green')\n        try:\n            makedirs(virtualenv_path)\n        except FileExistsError:\n            echo(\"-----> Env dir already exists: '{}'\".format(app), fg='yellow')\n        call('virtualenv --python=python{version:d} {app:s}'.format(**locals()), cwd=ENV_ROOT, shell=True)\n        first_time = True\n\n    activation_script = join(virtualenv_path, 'bin', 'activate_this.py')\n    exec(open(activation_script).read(), dict(__file__=activation_script))\n\n    if first_time or getmtime(requirements) > getmtime(virtualenv_path):\n        echo(\"-----> Running pip for '{}'\".format(app), fg='green')\n        call('pip install -r {}'.format(requirements), cwd=virtualenv_path, shell=True)\n    return spawn_app(app, deltas)\n\n\ndef deploy_python_with_poetry(app, deltas={}):\n    \"\"\"Deploy a Python application using Poetry\"\"\"\n\n    echo(\"=====> Starting EXPERIMENTAL poetry deployment for '{}'\".format(app), fg='red')\n    virtualenv_path = join(ENV_ROOT, app)\n    requirements = join(APP_ROOT, app, 'pyproject.toml')\n    env_file = join(APP_ROOT, app, 'ENV')\n    symlink_path = join(APP_ROOT, app, '.venv')\n    if not exists(symlink_path):\n        echo(\"-----> Creating .venv symlink '{}'\".format(app), fg='green')\n        symlink(virtualenv_path, symlink_path, target_is_directory=True)\n    # Set unbuffered output and readable UTF-8 mapping\n    env = {\n        **environ,\n        'POETRY_VIRTUALENVS_IN_PROJECT': '1',\n        'PYTHONUNBUFFERED': '1',\n        'PYTHONIOENCODING': 'UTF_8:replace'\n    }\n    if exists(env_file):\n        env.update(parse_settings(env_file, env))\n\n    first_time = False\n    if not exists(join(virtualenv_path, \"bin\", \"activate\")):\n        echo(\"-----> Creating virtualenv for '{}'\".format(app), fg='green')\n        try:\n            makedirs(virtualenv_path)\n        except FileExistsError:\n            echo(\"-----> Env dir already exists: '{}'\".format(app), fg='yellow')\n        first_time = True\n\n    if first_time or getmtime(requirements) > getmtime(virtualenv_path):\n        echo(\"-----> Running poetry for '{}'\".format(app), fg='green')\n        call('poetry install', cwd=join(APP_ROOT, app), env=env, shell=True)\n\n    return spawn_app(app, deltas)\n\n\ndef deploy_identity(app, deltas={}):\n    env_path = join(ENV_ROOT, app)\n    if not exists(env_path):\n        makedirs(env_path)\n    return spawn_app(app, deltas)\n\n\ndef spawn_app(app, deltas={}):\n    \"\"\"Create all workers for an app\"\"\"\n\n    # pylint: disable=unused-variable\n    app_path = join(APP_ROOT, app)\n    procfile = join(app_path, 'Procfile')\n    workers = parse_procfile(procfile)\n    workers.pop(\"preflight\", None)\n    workers.pop(\"release\", None)\n    ordinals = defaultdict(lambda: 1)\n    worker_count = {k: 1 for k in workers.keys()}\n\n    # the Python virtualenv\n    virtualenv_path = join(ENV_ROOT, app)\n    # Settings shipped with the app\n    env_file = join(APP_ROOT, app, 'ENV')\n    # Custom overrides\n    settings = join(ENV_ROOT, app, 'ENV')\n    # Live settings\n    live = join(ENV_ROOT, app, 'LIVE_ENV')\n    # Scaling\n    scaling = join(ENV_ROOT, app, 'SCALING')\n\n    # Bootstrap environment\n    env = {\n        'APP': app,\n        'LOG_ROOT': LOG_ROOT,\n        'DATA_ROOT': join(DATA_ROOT, app),\n        'HOME': environ['HOME'],\n        'USER': environ['USER'],\n        'PATH': ':'.join([join(virtualenv_path, 'bin'), environ['PATH']]),\n        'PWD': dirname(env_file),\n        'VIRTUAL_ENV': virtualenv_path,\n    }\n\n    safe_defaults = {\n        'NGINX_IPV4_ADDRESS': '0.0.0.0',\n        'NGINX_IPV6_ADDRESS': '[::]',\n        'BIND_ADDRESS': '127.0.0.1',\n    }\n\n    # add node path if present\n    node_path = join(virtualenv_path, \"node_modules\")\n    if exists(node_path):\n        env[\"NODE_PATH\"] = node_path\n        env[\"PATH\"] = ':'.join([join(node_path, \".bin\"), env['PATH']])\n\n    # Load environment variables shipped with repo (if any)\n    if exists(env_file):\n        env.update(parse_settings(env_file, env))\n\n    # Override with custom settings (if any)\n    if exists(settings):\n        env.update(parse_settings(settings, env))  # lgtm [py/modification-of-default-value]\n\n    if 'web' in workers or 'wsgi' in workers or 'jwsgi' in workers or 'static' in workers or 'rwsgi' in workers or 'php' in workers:\n        # Pick a port if none defined\n        if 'PORT' not in env:\n            env['PORT'] = str(get_free_port())\n            echo(\"-----> picking free port {PORT}\".format(**env))\n\n        if get_boolean(env.get('DISABLE_IPV6', 'false')):\n            safe_defaults.pop('NGINX_IPV6_ADDRESS', None)\n            echo(\"-----> nginx will NOT use IPv6\".format(**locals()))\n\n        # Safe defaults for addressing\n        for k, v in safe_defaults.items():\n            if k not in env:\n                echo(\"-----> nginx {k:s} will be set to {v}\".format(**locals()))\n                env[k] = v\n\n        # Set up nginx if we have NGINX_SERVER_NAME set\n        if 'NGINX_SERVER_NAME' in env:\n            # Hack to get around ClickCommand\n            env['NGINX_SERVER_NAME'] = env['NGINX_SERVER_NAME'].split(',')\n            env['NGINX_SERVER_NAME'] = ' '.join(env['NGINX_SERVER_NAME'])\n\n            nginx = command_output(\"nginx -V\")\n            nginx_ssl = \"443 ssl\"\n            if \"--with-http_v2_module\" in nginx:\n                nginx_ssl += \" http2\"\n            elif \"--with-http_spdy_module\" in nginx and \"nginx/1.6.2\" not in nginx:  # avoid Raspbian bug\n                nginx_ssl += \" spdy\"\n            nginx_conf = join(NGINX_ROOT, \"{}.conf\".format(app))\n\n            env.update({  # lgtm [py/modification-of-default-value]\n                'NGINX_SSL': nginx_ssl,\n                'NGINX_ROOT': NGINX_ROOT,\n                'ACME_WWW': ACME_WWW,\n            })\n\n            # default to reverse proxying to the TCP port we picked\n            env['PIKU_INTERNAL_NGINX_UWSGI_SETTINGS'] = 'proxy_pass http://{BIND_ADDRESS:s}:{PORT:s};'.format(**env)\n            if 'wsgi' in workers or 'jwsgi' in workers:\n                sock = join(NGINX_ROOT, \"{}.sock\".format(app))\n                env['PIKU_INTERNAL_NGINX_UWSGI_SETTINGS'] = expandvars(PIKU_INTERNAL_NGINX_UWSGI_SETTINGS, env)\n                env['NGINX_SOCKET'] = env['BIND_ADDRESS'] = \"unix://\" + sock\n                if 'PORT' in env:\n                    del env['PORT']\n            else:\n                env['NGINX_SOCKET'] = \"{BIND_ADDRESS:s}:{PORT:s}\".format(**env)\n                echo(\"-----> nginx will look for app '{}' on {}\".format(app, env['NGINX_SOCKET']))\n\n            domains = env['NGINX_SERVER_NAME'].split()\n            domain = domains[0]\n            issuefile = join(ACME_ROOT, domain, \"issued-\" + \"-\".join(domains))\n            key, crt = [join(NGINX_ROOT, \"{}.{}\".format(app, x)) for x in ['key', 'crt']]\n            if exists(join(ACME_ROOT, \"acme.sh\")):\n                acme = ACME_ROOT\n                www = ACME_WWW\n                root_ca = ACME_ROOT_CA\n                # if this is the first run there will be no nginx conf yet\n                # create a basic conf stub just to serve the acme auth\n                if not exists(nginx_conf):\n                    echo(\"-----> writing temporary nginx conf\")\n                    buffer = expandvars(NGINX_ACME_FIRSTRUN_TEMPLATE, env)\n                    with open(nginx_conf, \"w\") as h:\n                        h.write(buffer)\n                if not exists(key) or not exists(issuefile):\n                    echo(\"-----> getting letsencrypt certificate\")\n                    certlist = \" \".join([\"-d {}\".format(d) for d in domains])\n                    call('{acme:s}/acme.sh --issue {certlist:s} -w {www:s} --server {root_ca:s}'.format(**locals()), shell=True)\n                    call('{acme:s}/acme.sh --install-cert {certlist:s} --key-file {key:s} --fullchain-file {crt:s}'.format(\n                        **locals()), shell=True)\n                    if exists(join(ACME_ROOT, domain)) and not exists(join(ACME_WWW, app)):\n                        symlink(join(ACME_ROOT, domain), join(ACME_WWW, app))\n                    try:\n                        symlink(\"/dev/null\", issuefile)\n                    except Exception:\n                        pass\n                else:\n                    echo(\"-----> letsencrypt certificate already installed\")\n\n            # fall back to creating self-signed certificate if acme failed\n            if not exists(key) or stat(crt).st_size == 0:\n                echo(\"-----> generating self-signed certificate\")\n                call(\n                    'openssl req -new -newkey rsa:4096 -days 365 -nodes -x509 -subj \"/C=US/ST=NY/L=New York/O=Piku/OU=Self-Signed/CN={domain:s}\" -keyout {key:s} -out {crt:s}'.format(\n                        **locals()), shell=True)\n\n            # restrict access to server from CloudFlare IP addresses\n            acl = []\n            if get_boolean(env.get('NGINX_CLOUDFLARE_ACL', 'false')):\n                try:\n                    cf = loads(urlopen('https://api.cloudflare.com/client/v4/ips').read().decode(\"utf-8\"))\n                    if cf['success'] is True:\n                        for i in cf['result']['ipv4_cidrs']:\n                            acl.append(\"allow {};\".format(i))\n                        if get_boolean(env.get('DISABLE_IPV6', 'false')):\n                            for i in cf['result']['ipv6_cidrs']:\n                                acl.append(\"allow {};\".format(i))\n                        # allow access from controlling machine\n                        if 'SSH_CLIENT' in environ:\n                            remote_ip = environ['SSH_CLIENT'].split()[0]\n                            echo(\"-----> nginx ACL will include your IP ({})\".format(remote_ip))\n                            acl.append(\"allow {};\".format(remote_ip))\n                        acl.extend([\"allow 127.0.0.1;\", \"deny all;\"])\n                except Exception:\n                    cf = defaultdict()\n                    echo(\"-----> Could not retrieve CloudFlare IP ranges: {}\".format(format_exc()), fg=\"red\")\n\n            env['NGINX_ACL'] = \" \".join(acl)\n\n            env['PIKU_INTERNAL_NGINX_BLOCK_GIT'] = \"\" if env.get('NGINX_ALLOW_GIT_FOLDERS') else r\"location ~ /\\.git { deny all; }\"\n\n            env['PIKU_INTERNAL_PROXY_CACHE_PATH'] = ''\n            env['PIKU_INTERNAL_NGINX_CACHE_MAPPINGS'] = ''\n\n            # Get a mapping of /prefix1,/prefix2\n            default_cache_path = join(CACHE_ROOT, app)\n            if not exists(default_cache_path):\n                makedirs(default_cache_path)\n            try:\n                cache_size = int(env.get('NGINX_CACHE_SIZE', '1'))\n            except Exception:\n                echo(\"=====> Invalid cache size, defaulting to 1GB\")\n                cache_size = 1\n            cache_size = str(cache_size) + \"g\"\n            try:\n                cache_time_control = int(env.get('NGINX_CACHE_CONTROL', '3600'))\n            except Exception:\n                echo(\"=====> Invalid time for cache control, defaulting to 3600s\")\n                cache_time_control = 3600\n            cache_time_control = str(cache_time_control)\n            try:\n                cache_time_content = int(env.get('NGINX_CACHE_TIME', '3600'))\n            except Exception:\n                echo(\"=====> Invalid cache time for content, defaulting to 3600s\")\n                cache_time_content = 3600\n            cache_time_content = str(cache_time_content) + \"s\"\n            try:\n                cache_time_redirects = int(env.get('NGINX_CACHE_REDIRECTS', '3600'))\n            except Exception:\n                echo(\"=====> Invalid cache time for redirects, defaulting to 3600s\")\n                cache_time_redirects = 3600\n            cache_time_redirects = str(cache_time_redirects) + \"s\"\n            try:\n                cache_time_any = int(env.get('NGINX_CACHE_ANY', '3600'))\n            except Exception:\n                echo(\"=====> Invalid cache expiry fallback, defaulting to 3600s\")\n                cache_time_any = 3600\n            cache_time_any = str(cache_time_any) + \"s\"\n            try:\n                cache_time_expiry = int(env.get('NGINX_CACHE_EXPIRY', '86400'))\n            except Exception:\n                echo(\"=====> Invalid cache expiry, defaulting to 86400s\")\n                cache_time_expiry = 86400\n            cache_time_expiry = str(cache_time_expiry) + \"s\"\n            cache_prefixes = env.get('NGINX_CACHE_PREFIXES', '')\n            cache_path = env.get('NGINX_CACHE_PATH', default_cache_path)\n            if not exists(cache_path):\n                echo(\"=====> Cache path {} does not exist, using default {}, be aware of disk usage.\".format(cache_path, default_cache_path))\n                cache_path = env.get(default_cache_path)\n            if len(cache_prefixes):\n                prefixes = []  # this will turn into part of /(path1|path2|path3)\n                try:\n                    items = cache_prefixes.split(',')\n                    for item in items:\n                        if item[0] == '/':\n                            prefixes.append(item[1:])\n                        else:\n                            prefixes.append(item)\n                    cache_prefixes = \"|\".join(prefixes)\n                    echo(\"-----> nginx will cache /({}) prefixes up to {} or {} of disk space, with the following timings:\".format(cache_prefixes, cache_time_expiry, cache_size))\n                    echo(\"-----> nginx will cache content for {}.\".format(cache_time_content))\n                    echo(\"-----> nginx will cache redirects for {}.\".format(cache_time_redirects))\n                    echo(\"-----> nginx will cache everything else for {}.\".format(cache_time_any))\n                    echo(\"-----> nginx will send caching headers asking for {} seconds of public caching.\".format(cache_time_control))\n                    env['PIKU_INTERNAL_PROXY_CACHE_PATH'] = expandvars(\n                        PIKU_INTERNAL_PROXY_CACHE_PATH, locals())\n                    env['PIKU_INTERNAL_NGINX_CACHE_MAPPINGS'] = expandvars(\n                        PIKU_INTERNAL_NGINX_CACHE_MAPPING, locals())\n                    env['PIKU_INTERNAL_NGINX_CACHE_MAPPINGS'] = expandvars(\n                        env['PIKU_INTERNAL_NGINX_CACHE_MAPPINGS'], env)\n                except Exception as e:\n                    echo(\"Error {} in cache path spec: should be /prefix1:[,/prefix2], ignoring.\".format(e))\n                    env['PIKU_INTERNAL_NGINX_CACHE_MAPPINGS'] = ''\n\n            env['PIKU_INTERNAL_NGINX_STATIC_MAPPINGS'] = ''\n\n            # Get a mapping of /prefix1:path1,/prefix2:path2\n            static_paths = env.get('NGINX_STATIC_PATHS', '')\n            # prepend static worker path if present\n            if 'static' in workers:\n                stripped = workers['static'].strip(\"/\").rstrip(\"/\")\n                static_paths = (\"/\" if stripped[0:1] == \":\" else \"/:\") + (stripped if stripped else \".\") + \"/\" + (\",\" if static_paths else \"\") + static_paths\n            if len(static_paths):\n                try:\n                    # pylint: disable=unused-variable\n                    catch_all = env.get('NGINX_CATCH_ALL', '')\n                    items = static_paths.split(',')\n                    for item in items:\n                        static_url, static_path = item.split(':')\n                        if static_path[0] != '/':\n                            static_path = join(app_path, static_path).rstrip(\"/\") + \"/\"\n                        echo(\"-----> nginx will map {} to {}.\".format(static_url, static_path))\n                        env['PIKU_INTERNAL_NGINX_STATIC_MAPPINGS'] = env['PIKU_INTERNAL_NGINX_STATIC_MAPPINGS'] + expandvars(\n                            PIKU_INTERNAL_NGINX_STATIC_MAPPING, locals())\n                except Exception as e:\n                    echo(\"Error {} in static path spec: should be /prefix1:path1[,/prefix2:path2], ignoring.\".format(e))\n                    env['PIKU_INTERNAL_NGINX_STATIC_MAPPINGS'] = ''\n\n            env['PIKU_INTERNAL_NGINX_CUSTOM_CLAUSES'] = expandvars(open(join(app_path, env[\"NGINX_INCLUDE_FILE\"])).read(), env) if env.get(\"NGINX_INCLUDE_FILE\") else \"\"\n            env['PIKU_INTERNAL_NGINX_PORTMAP'] = \"\"\n            if 'web' in workers or 'wsgi' in workers or 'jwsgi' in workers or 'rwsgi' in workers or 'php' in workers:\n                env['PIKU_INTERNAL_NGINX_PORTMAP'] = expandvars(NGINX_PORTMAP_FRAGMENT, env)\n            env['PIKU_INTERNAL_NGINX_COMMON'] = expandvars(NGINX_COMMON_FRAGMENT, env)\n\n            echo(\"-----> nginx will map app '{}' to hostname(s) '{}'\".format(app, env['NGINX_SERVER_NAME']))\n            if get_boolean(env.get('NGINX_HTTPS_ONLY', 'false')):\n                buffer = expandvars(NGINX_HTTPS_ONLY_TEMPLATE, env)\n                echo(\"-----> nginx will redirect all requests to hostname(s) '{}' to HTTPS\".format(env['NGINX_SERVER_NAME']))\n            else:\n                buffer = expandvars(NGINX_TEMPLATE, env)\n\n            # remove all references to IPv6 listeners (for enviroments where it's disabled)\n            if get_boolean(env.get('DISABLE_IPV6', 'false')):\n                buffer = '\\n'.join([line for line in buffer.split('\\n') if 'NGINX_IPV6' not in line])\n            # change any unecessary uWSGI specific directives to standard proxy ones\n            if 'wsgi' not in workers and 'jwsgi' not in workers:\n                buffer = buffer.replace(\"uwsgi_\", \"proxy_\")\n\n            # map Cloudflare connecting IP to REMOTE_ADDR\n            if get_boolean(env.get('NGINX_CLOUDFLARE_ACL', 'false')):\n                buffer = buffer.replace(\"REMOTE_ADDR $remote_addr\", \"REMOTE_ADDR $http_cf_connecting_ip\")\n\n            with open(nginx_conf, \"w\") as h:\n                h.write(buffer)\n            # prevent broken config from breaking other deploys\n            try:\n                nginx_config_test = str(check_output(r\"nginx -t 2>&1 | grep -E '{}\\.conf:[0-9]+$'\".format(app), env=environ, shell=True))\n            except Exception:\n                nginx_config_test = None\n            if nginx_config_test:\n                echo(\"Error: [nginx config] {}\".format(nginx_config_test), fg='red')\n                echo(\"Warning: removing broken nginx config.\", fg='yellow')\n                unlink(nginx_conf)\n\n    # Configured worker count\n    if exists(scaling):\n        worker_count.update({k: int(v) for k, v in parse_procfile(scaling).items() if k in workers})\n\n    to_create = {}\n    to_destroy = {}\n    for k, v in worker_count.items():\n        to_create[k] = range(1, worker_count[k] + 1)\n        if k in deltas and deltas[k]:\n            to_create[k] = range(1, worker_count[k] + deltas[k] + 1)\n            if deltas[k] < 0:\n                to_destroy[k] = range(worker_count[k], worker_count[k] + deltas[k], -1)\n            worker_count[k] = worker_count[k] + deltas[k]\n\n    # Cleanup env\n    for k, v in list(env.items()):\n        if k.startswith('PIKU_INTERNAL_'):\n            del env[k]\n\n    # Save current settings\n    write_config(live, env)\n    write_config(scaling, worker_count, ':')\n\n    if get_boolean(env.get('PIKU_AUTO_RESTART', 'true')):\n        config = glob(join(UWSGI_ENABLED, '{}*.ini'.format(app)))\n        if len(config):\n            echo(\"-----> Removing uwsgi configs to trigger auto-restart.\")\n            for c in config:\n                remove(c)\n\n    # Create new workers\n    for k, v in to_create.items():\n        for w in v:\n            enabled = join(UWSGI_ENABLED, '{app:s}_{k:s}.{w:d}.ini'.format(**locals()))\n            if not exists(enabled):\n                echo(\"-----> spawning '{app:s}:{k:s}.{w:d}'\".format(**locals()), fg='green')\n                spawn_worker(app, k, workers[k], env, w)\n\n    # Remove unnecessary workers (leave logfiles)\n    for k, v in to_destroy.items():\n        for w in v:  # lgtm [py/unused-loop-variable]\n            enabled = join(UWSGI_ENABLED, '{app:s}_{k:s}.{w:d}.ini'.format(**locals()))\n            if exists(enabled):\n                echo(\"-----> terminating '{app:s}:{k:s}.{w:d}'\".format(**locals()), fg='yellow')\n                unlink(enabled)\n\n    return env\n\n\ndef spawn_worker(app, kind, command, env, ordinal=1):\n    \"\"\"Set up and deploy a single worker of a given kind\"\"\"\n\n    # pylint: disable=unused-variable\n    env['PROC_TYPE'] = kind\n    env_path = join(ENV_ROOT, app)\n    available = join(UWSGI_AVAILABLE, '{app:s}_{kind:s}.{ordinal:d}.ini'.format(**locals()))\n    enabled = join(UWSGI_ENABLED, '{app:s}_{kind:s}.{ordinal:d}.ini'.format(**locals()))\n    log_file = join(LOG_ROOT, app, kind)\n\n    settings = [\n        ('chdir', join(APP_ROOT, app)),\n        ('uid', getpwuid(getuid()).pw_name),\n        ('gid', getgrgid(getgid()).gr_name),\n        ('master', 'true'),\n        ('project', app),\n        ('max-requests', env.get('UWSGI_MAX_REQUESTS', '1024')),\n        ('listen', env.get('UWSGI_LISTEN', '16')),\n        ('processes', env.get('UWSGI_PROCESSES', '1')),\n        ('procname-prefix', '{app:s}:{kind:s}:'.format(**locals())),\n        ('enable-threads', env.get('UWSGI_ENABLE_THREADS', 'true').lower()),\n        ('log-x-forwarded-for', env.get('UWSGI_LOG_X_FORWARDED_FOR', 'false').lower()),\n        ('log-maxsize', env.get('UWSGI_LOG_MAXSIZE', UWSGI_LOG_MAXSIZE)),\n        ('logfile-chown', '%s:%s' % (getpwuid(getuid()).pw_name, getgrgid(getgid()).gr_name)),\n        ('logfile-chmod', '640'),\n        ('logto2', '{log_file:s}.{ordinal:d}.log'.format(**locals())),\n        ('log-backupname', '{log_file:s}.{ordinal:d}.log.old'.format(**locals())),\n    ]\n\n    # only add virtualenv to uwsgi if it's a real virtualenv\n    if exists(join(env_path, \"bin\", \"activate_this.py\")):\n        settings.append(('virtualenv', env_path))\n\n    if 'UWSGI_IDLE' in env:\n        try:\n            idle_timeout = int(env['UWSGI_IDLE'])\n            settings.extend([\n                ('idle', str(idle_timeout)),\n                ('cheap', 'True'),\n                ('die-on-idle', 'True')\n            ])\n            echo(\"-----> uwsgi will start workers on demand and kill them after {}s of inactivity\".format(idle_timeout), fg='yellow')\n        except Exception:\n            echo(\"Error: malformed setting 'UWSGI_IDLE', ignoring it.\".format(), fg='red')\n            pass\n\n    if kind.startswith(\"cron\"):\n        settings.extend([\n            ['cron', command.replace(\"*/\", \"-\").replace(\"*\", \"-1\")],\n        ])\n\n    if kind == 'jwsgi':\n        settings.extend([\n            ('module', command),\n            ('threads', env.get('UWSGI_THREADS', '4')),\n            ('plugin', 'jvm'),\n            ('plugin', 'jwsgi')\n        ])\n\n    # could not come up with a better kind for ruby, web would work but that means loading the rack plugin in web.\n    if kind == 'rwsgi':\n        settings.extend([\n            ('module', command),\n            ('threads', env.get('UWSGI_THREADS', '4')),\n            ('plugin', 'rack'),\n            ('plugin', 'rbrequire'),\n            ('plugin', 'post-buffering')\n        ])\n\n    python_version = int(env.get('PYTHON_VERSION', '3'))\n\n    if kind == 'wsgi':\n        settings.extend([\n            ('module', command),\n            ('threads', env.get('UWSGI_THREADS', '4')),\n        ])\n\n        if python_version == 2:\n            settings.extend([\n                ('plugin', 'python'),\n            ])\n            if 'UWSGI_GEVENT' in env:\n                settings.extend([\n                    ('plugin', 'gevent_python'),\n                    ('gevent', env['UWSGI_GEVENT']),\n                ])\n            elif 'UWSGI_ASYNCIO' in env:\n                try:\n                    tasks = int(env['UWSGI_ASYNCIO'])\n                    settings.extend([\n                        ('plugin', 'asyncio_python'),\n                        ('async', tasks),\n                    ])\n                    echo(\"-----> uwsgi will support {} async tasks\".format(tasks), fg='yellow')\n                except ValueError:\n                    echo(\"Error: malformed setting 'UWSGI_ASYNCIO', ignoring it.\".format(), fg='red')\n\n        elif python_version == 3:\n            settings.extend([\n                ('plugin', 'python3'),\n            ])\n            if 'UWSGI_ASYNCIO' in env:\n                try:\n                    tasks = int(env['UWSGI_ASYNCIO'])\n                    settings.extend([\n                        ('plugin', 'asyncio_python3'),\n                        ('async', tasks),\n                    ])\n                    echo(\"-----> uwsgi will support {} async tasks\".format(tasks), fg='yellow')\n                except ValueError:\n                    echo(\"Error: malformed setting 'UWSGI_ASYNCIO', ignoring it.\".format(), fg='red')\n\n        # If running under nginx, don't expose a port at all\n        if 'NGINX_SERVER_NAME' in env:\n            sock = join(NGINX_ROOT, \"{}.sock\".format(app))\n            echo(\"-----> nginx will talk to uWSGI via {}\".format(sock), fg='yellow')\n            settings.extend([\n                ('socket', sock),\n                ('chmod-socket', '664'),\n            ])\n        else:\n            echo(\"-----> nginx will talk to uWSGI via {BIND_ADDRESS:s}:{PORT:s}\".format(**env), fg='yellow')\n            settings.extend([\n                ('http', '{BIND_ADDRESS:s}:{PORT:s}'.format(**env)),\n                ('http-use-socket', '{BIND_ADDRESS:s}:{PORT:s}'.format(**env)),\n                ('http-socket', '{BIND_ADDRESS:s}:{PORT:s}'.format(**env)),\n            ])\n    elif kind == 'php':\n        docroot = join(APP_ROOT, app, command.strip(\"/\").rstrip(\"/\"))\n        settings.extend([\n            ('plugin', 'http,0:php'),\n            ('http', ':{}'.format(env['PORT'])),\n            ('check-static', docroot),\n            ('static-skip-ext', '.php'),\n            ('static-skip-ext', '.inc'),\n            ('static-index', 'index.html'),\n            ('php-docroot', docroot),\n            ('php-allowed-ext', '.php'),\n            ('php-index', 'index.php')\n        ])\n    elif kind == 'web':\n        echo(\"-----> nginx will talk to the 'web' process via {BIND_ADDRESS:s}:{PORT:s}\".format(**env), fg='yellow')\n        settings.append(('attach-daemon', command))\n    elif kind == 'static':\n        echo(\"-----> nginx serving static files only\".format(**env), fg='yellow')\n    elif kind.startswith(\"cron\"):\n        echo(\"-----> uwsgi scheduled cron for {command}\".format(**locals()), fg='yellow')\n    else:\n        settings.append(('attach-daemon', command))\n\n    if kind in ['wsgi', 'web']:\n        settings.append(('log-format',\n                         '%%(addr) - %%(user) [%%(ltime)] \"%%(method) %%(uri) %%(proto)\" %%(status) %%(size) \"%%(referer)\" \"%%(uagent)\" %%(msecs)ms'))\n\n    # remove unnecessary variables from the env in nginx.ini\n    for k in ['NGINX_ACL']:\n        if k in env:\n            del env[k]\n\n    # insert user defined uwsgi settings if set\n    settings += parse_settings(join(APP_ROOT, app, env.get(\"UWSGI_INCLUDE_FILE\"))).items() if env.get(\"UWSGI_INCLUDE_FILE\") else []\n\n    for k, v in env.items():\n        settings.append(('env', '{k:s}={v}'.format(**locals())))\n\n    if kind != 'static':\n        with open(available, 'w') as h:\n            h.write('[uwsgi]\\n')\n            for k, v in settings:\n                h.write(\"{k:s} = {v}\\n\".format(**locals()))\n\n        copyfile(available, enabled)\n\n\ndef do_stop(app):\n    config = glob(join(UWSGI_ENABLED, '{}*.ini'.format(app)))\n\n    if len(config) > 0:\n        echo(\"Stopping app '{}'...\".format(app), fg='yellow')\n        for c in config:\n            remove(c)\n    else:\n        echo(\"Error: app '{}' not deployed!\".format(app), fg='red')  # TODO app could be already stopped. Need to able to tell the difference.\n\n\ndef do_restart(app):\n    \"\"\"Restarts a deployed app\"\"\"\n    # This must work even if the app is stopped when called. At the end, the app should be running.\n    echo(\"restarting app '{}'...\".format(app), fg='yellow')\n    do_stop(app)\n    spawn_app(app)\n\n\ndef multi_tail(app, filenames, catch_up=20):\n    \"\"\"Tails multiple log files\"\"\"\n\n    # Seek helper\n    def peek(handle):\n        where = handle.tell()\n        line = handle.readline()\n        if not line:\n            handle.seek(where)\n            return None\n        return line\n\n    inodes = {}\n    files = {}\n    prefixes = {}\n\n    # Set up current state for each log file\n    for f in filenames:\n        prefixes[f] = splitext(basename(f))[0]\n        files[f] = open(f, \"rt\", encoding=\"utf-8\", errors=\"ignore\")\n        inodes[f] = stat(f).st_ino\n        files[f].seek(0, 2)\n\n    longest = max(map(len, prefixes.values()))\n\n    # Grab a little history (if any)\n    for f in filenames:\n        for line in deque(open(f, \"rt\", encoding=\"utf-8\", errors=\"ignore\"), catch_up):\n            yield \"{} | {}\".format(prefixes[f].ljust(longest), line)\n\n    while True:\n        updated = False\n        # Check for updates on every file\n        for f in filenames:\n            line = peek(files[f])\n            if line:\n                updated = True\n                yield \"{} | {}\".format(prefixes[f].ljust(longest), line)\n\n        if not updated:\n            sleep(1)\n            # Check if logs rotated\n            for f in filenames:\n                if exists(f):\n                    if stat(f).st_ino != inodes[f]:\n                        files[f] = open(f)\n                        inodes[f] = stat(f).st_ino\n                else:\n                    filenames.remove(f)\n\n\n# === CLI commands ===\n\nCONTEXT_SETTINGS = dict(help_option_names=['-h', '--help'])\n\n\n@group(context_settings=CONTEXT_SETTINGS)\ndef piku():\n    \"\"\"The smallest PaaS you've ever seen\"\"\"\n    pass\n\n\npiku.rc = getattr(piku, \"result_callback\", None) or getattr(piku, \"resultcallback\", None)\n\n\n@piku.rc()\ndef cleanup(ctx):\n    \"\"\"Callback from command execution -- add debugging to taste\"\"\"\n    pass\n\n# --- User commands ---\n\n\n@piku.command(\"apps\")\ndef cmd_apps():\n    \"\"\"List apps, e.g.: piku apps\"\"\"\n    apps = listdir(APP_ROOT)\n    if not apps:\n        echo(\"There are no applications deployed.\")\n        return\n\n    for a in apps:\n        running = len(glob(join(UWSGI_ENABLED, '{}*.ini'.format(a)))) != 0\n        echo(('*' if running else ' ') + a, fg='green')\n\n\n@piku.command(\"config\")\n@argument('app')\ndef cmd_config(app):\n    \"\"\"Show config, e.g.: piku config <app>\"\"\"\n\n    app = exit_if_invalid(app)\n\n    config_file = join(ENV_ROOT, app, 'ENV')\n    if exists(config_file):\n        echo(open(config_file).read().strip(), fg='white')\n    else:\n        echo(\"Warning: app '{}' not deployed, no config found.\".format(app), fg='yellow')\n\n\n@piku.command(\"config:get\")\n@argument('app')\n@argument('setting')\ndef cmd_config_get(app, setting):\n    \"\"\"e.g.: piku config:get <app> FOO\"\"\"\n\n    app = exit_if_invalid(app)\n\n    config_file = join(ENV_ROOT, app, 'ENV')\n    if exists(config_file):\n        env = parse_settings(config_file)\n        if setting in env:\n            echo(\"{}\".format(env[setting]), fg='white')\n    else:\n        echo(\"Warning: no active configuration for '{}'\".format(app))\n\n\n@piku.command(\"config:set\")\n@argument('app')\n@argument('settings', nargs=-1)\ndef cmd_config_set(app, settings):\n    \"\"\"e.g.: piku config:set <app> FOO=bar BAZ=quux\"\"\"\n\n    app = exit_if_invalid(app)\n\n    config_file = join(ENV_ROOT, app, 'ENV')\n    env = parse_settings(config_file)\n    for s in settings:\n        try:\n            k, v = map(lambda x: x.strip(), s.split(\"=\", 1))\n            env[k] = v\n            echo(\"Setting {k:s}={v} for '{app:s}'\".format(**locals()), fg='white')\n        except Exception:\n            echo(\"Error: malformed setting '{}'\".format(s), fg='red')\n            return\n    write_config(config_file, env)\n    do_deploy(app)\n\n\n@piku.command(\"config:unset\")\n@argument('app')\n@argument('settings', nargs=-1)\ndef cmd_config_unset(app, settings):\n    \"\"\"e.g.: piku config:unset <app> FOO\"\"\"\n\n    app = exit_if_invalid(app)\n\n    config_file = join(ENV_ROOT, app, 'ENV')\n    env = parse_settings(config_file)\n    for s in settings:\n        if s in env:\n            del env[s]\n            echo(\"Unsetting {} for '{}'\".format(s, app), fg='white')\n    write_config(config_file, env)\n    do_deploy(app)\n\n\n@piku.command(\"config:live\")\n@argument('app')\ndef cmd_config_live(app):\n    \"\"\"e.g.: piku config:live <app>\"\"\"\n\n    app = exit_if_invalid(app)\n\n    live_config = join(ENV_ROOT, app, 'LIVE_ENV')\n    if exists(live_config):\n        echo(open(live_config).read().strip(), fg='white')\n    else:\n        echo(\"Warning: app '{}' not deployed, no config found.\".format(app), fg='yellow')\n\n\n@piku.command(\"deploy\")\n@argument('app')\ndef cmd_deploy(app):\n    \"\"\"e.g.: piku deploy <app>\"\"\"\n\n    app = exit_if_invalid(app)\n    do_deploy(app)\n\n\n@piku.command(\"destroy\")\n@argument('app')\ndef cmd_destroy(app):\n    \"\"\"e.g.: piku destroy <app>\"\"\"\n\n    app = exit_if_invalid(app)\n\n    # leave DATA_ROOT, since apps may create hard to reproduce data,\n    # and CACHE_ROOT, since `nginx` will set permissions to protect it\n    for p in [join(x, app) for x in [APP_ROOT, GIT_ROOT, ENV_ROOT, LOG_ROOT]]:\n        if exists(p):\n            echo(\"--> Removing folder '{}'\".format(p), fg='yellow')\n            rmtree(p)\n\n    for p in [join(x, '{}*.ini'.format(app)) for x in [UWSGI_AVAILABLE, UWSGI_ENABLED]]:\n        g = glob(p)\n        if len(g) > 0:\n            for f in g:\n                echo(\"--> Removing file '{}'\".format(f), fg='yellow')\n                remove(f)\n\n    nginx_files = [join(NGINX_ROOT, \"{}.{}\".format(app, x)) for x in ['conf', 'sock', 'key', 'crt']]\n    for f in nginx_files:\n        if exists(f):\n            echo(\"--> Removing file '{}'\".format(f), fg='yellow')\n            remove(f)\n\n    acme_link = join(ACME_WWW, app)\n    acme_certs = realpath(acme_link)\n    if exists(acme_certs):\n        echo(\"--> Removing folder '{}'\".format(acme_certs), fg='yellow')\n        rmtree(acme_certs)\n        echo(\"--> Removing file '{}'\".format(acme_link), fg='yellow')\n        unlink(acme_link)\n\n    # These come last to make sure they're visible\n    for p in [join(x, app) for x in [DATA_ROOT, CACHE_ROOT]]:\n        if exists(p):\n            echo(\"==> Preserving folder '{}'\".format(p), fg='red')\n\n\n@piku.command(\"logs\")\n@argument('app')\n@argument('process', nargs=1, default='*')\ndef cmd_logs(app, process):\n    \"\"\"Tail running logs, e.g: piku logs <app> [<process>]\"\"\"\n\n    app = exit_if_invalid(app)\n\n    logfiles = glob(join(LOG_ROOT, app, process + '.*.log'))\n    if len(logfiles) > 0:\n        for line in multi_tail(app, logfiles):\n            echo(line.strip(), fg='white')\n    else:\n        echo(\"No logs found for app '{}'.\".format(app), fg='yellow')\n\n\n@piku.command(\"ps\")\n@argument('app')\ndef cmd_ps(app):\n    \"\"\"Show process count, e.g: piku ps <app>\"\"\"\n\n    app = exit_if_invalid(app)\n\n    config_file = join(ENV_ROOT, app, 'SCALING')\n    if exists(config_file):\n        echo(open(config_file).read().strip(), fg='white')\n    else:\n        echo(\"Error: no workers found for app '{}'.\".format(app), fg='red')\n\n\n@piku.command(\"ps:scale\")\n@argument('app')\n@argument('settings', nargs=-1)\ndef cmd_ps_scale(app, settings):\n    \"\"\"e.g.: piku ps:scale <app> <proc>=<count>\"\"\"\n\n    app = exit_if_invalid(app)\n\n    config_file = join(ENV_ROOT, app, 'SCALING')\n    worker_count = {k: int(v) for k, v in parse_procfile(config_file).items()}\n    deltas = {}\n    for s in settings:\n        try:\n            k, v = map(lambda x: x.strip(), s.split(\"=\", 1))\n            c = int(v)  # check for integer value\n            if c < 0:\n                echo(\"Error: cannot scale type '{}' below 0\".format(k), fg='red')\n                return\n            if k not in worker_count:\n                echo(\"Error: worker type '{}' not present in '{}'\".format(k, app), fg='red')\n                return\n            deltas[k] = c - worker_count[k]\n        except Exception:\n            echo(\"Error: malformed setting '{}'\".format(s), fg='red')\n            return\n    do_deploy(app, deltas)\n\n\n@piku.command(\"run\")\n@argument('app')\n@argument('cmd', nargs=-1)\ndef cmd_run(app, cmd):\n    \"\"\"e.g.: piku run <app> ls -- -al\"\"\"\n\n    app = exit_if_invalid(app)\n\n    config_file = join(ENV_ROOT, app, 'LIVE_ENV')\n    environ.update(parse_settings(config_file))\n    for f in [stdout, stderr]:\n        fl = fcntl(f, F_GETFL)\n        fcntl(f, F_SETFL, fl | O_NONBLOCK)\n    p = Popen(' '.join(cmd), stdin=stdin, stdout=stdout, stderr=stderr, env=environ, cwd=join(APP_ROOT, app), shell=True)\n    p.communicate()\n\n\n@piku.command(\"restart\")\n@argument('app')\ndef cmd_restart(app):\n    \"\"\"Restart an app: piku restart <app>\"\"\"\n\n    app = exit_if_invalid(app)\n\n    do_restart(app)\n\n\n@piku.command(\"setup\")\ndef cmd_setup():\n    \"\"\"Initialize environment\"\"\"\n\n    echo(\"Running in Python {}\".format(\".\".join(map(str, version_info))))\n\n    # Create required paths\n    for p in [APP_ROOT, CACHE_ROOT, DATA_ROOT, GIT_ROOT, ENV_ROOT, UWSGI_ROOT, UWSGI_AVAILABLE, UWSGI_ENABLED, LOG_ROOT, NGINX_ROOT]:\n        if not exists(p):\n            echo(\"Creating '{}'.\".format(p), fg='green')\n            makedirs(p)\n\n    # Set up the uWSGI emperor config\n    settings = [\n        ('chdir', UWSGI_ROOT),\n        ('emperor', UWSGI_ENABLED),\n        ('log-maxsize', UWSGI_LOG_MAXSIZE),\n        ('logto', join(UWSGI_ROOT, 'uwsgi.log')),\n        ('log-backupname', join(UWSGI_ROOT, 'uwsgi.old.log')),\n        ('socket', join(UWSGI_ROOT, 'uwsgi.sock')),\n        ('uid', getpwuid(getuid()).pw_name),\n        ('gid', getgrgid(getgid()).gr_name),\n        ('enable-threads', 'true'),\n        ('threads', '{}'.format(cpu_count() * 2)),\n    ]\n    with open(join(UWSGI_ROOT, 'uwsgi.ini'), 'w') as h:\n        h.write('[uwsgi]\\n')\n        # pylint: disable=unused-variable\n        for k, v in settings:\n            h.write(\"{k:s} = {v}\\n\".format(**locals()))\n\n    # mark this script as executable (in case we were invoked via interpreter)\n    if not (stat(PIKU_SCRIPT).st_mode & S_IXUSR):\n        echo(\"Setting '{}' as executable.\".format(PIKU_SCRIPT), fg='yellow')\n        chmod(PIKU_SCRIPT, stat(PIKU_SCRIPT).st_mode | S_IXUSR)\n\n\n@piku.command(\"setup:ssh\")\n@argument('public_key_file')\ndef cmd_setup_ssh(public_key_file):\n    \"\"\"Set up a new SSH key (use - for stdin)\"\"\"\n\n    def add_helper(key_file):\n        if exists(key_file):\n            try:\n                fingerprint = str(check_output('ssh-keygen -lf ' + key_file, shell=True)).split(' ', 4)[1]\n                key = open(key_file, 'r').read().strip()\n                echo(\"Adding key '{}'.\".format(fingerprint), fg='white')\n                setup_authorized_keys(fingerprint, PIKU_SCRIPT, key)\n            except Exception:\n                echo(\"Error: invalid public key file '{}': {}\".format(key_file, format_exc()), fg='red')\n        elif public_key_file == '-':\n            buffer = \"\".join(stdin.readlines())\n            with NamedTemporaryFile(mode=\"w\") as f:\n                f.write(buffer)\n                f.flush()\n                add_helper(f.name)\n        else:\n            echo(\"Error: public key file '{}' not found.\".format(key_file), fg='red')\n\n    add_helper(public_key_file)\n\n\n@piku.command(\"stop\")\n@argument('app')\ndef cmd_stop(app):\n    \"\"\"Stop an app, e.g: piku stop <app>\"\"\"\n    app = exit_if_invalid(app)\n    do_stop(app)\n\n\n# --- Internal commands ---\n\n@piku.command(\"git-hook\")\n@argument('app')\ndef cmd_git_hook(app):\n    \"\"\"INTERNAL: Post-receive git hook\"\"\"\n\n    app = sanitize_app_name(app)\n    repo_path = join(GIT_ROOT, app)\n    app_path = join(APP_ROOT, app)\n    data_path = join(DATA_ROOT, app)\n\n    for line in stdin:\n        # pylint: disable=unused-variable\n        oldrev, newrev, refname = line.strip().split(\" \")\n        # Handle pushes\n        if not exists(app_path):\n            echo(\"-----> Creating app '{}'\".format(app), fg='green')\n            makedirs(app_path)\n            # The data directory may already exist, since this may be a full redeployment (we never delete data since it may be expensive to recreate)\n            if not exists(data_path):\n                makedirs(data_path)\n            call(\"git clone --quiet {} {}\".format(repo_path, app), cwd=APP_ROOT, shell=True)\n        do_deploy(app, newrev=newrev)\n\n\n@piku.command(\"git-receive-pack\")\n@argument('app')\ndef cmd_git_receive_pack(app):\n    \"\"\"INTERNAL: Handle git pushes for an app\"\"\"\n\n    app = sanitize_app_name(app)\n    hook_path = join(GIT_ROOT, app, 'hooks', 'post-receive')\n    env = globals()\n    env.update(locals())\n\n    if not exists(hook_path):\n        makedirs(dirname(hook_path))\n        # Initialize the repository with a hook to this script\n        call(\"git init --quiet --bare \" + app, cwd=GIT_ROOT, shell=True)\n        with open(hook_path, 'w') as h:\n            h.write(\"\"\"#!/usr/bin/env bash\nset -e; set -o pipefail;\ncat | PIKU_ROOT=\"{PIKU_ROOT:s}\" {PIKU_SCRIPT:s} git-hook {app:s}\"\"\".format(**env))\n        # Make the hook executable by our user\n        chmod(hook_path, stat(hook_path).st_mode | S_IXUSR)\n    # Handle the actual receive. We'll be called with 'git-hook' after it happens\n    call('git-shell -c \"{}\" '.format(argv[1] + \" '{}'\".format(app)), cwd=GIT_ROOT, shell=True)\n\n\n@piku.command(\"git-upload-pack\")\n@argument('app')\ndef cmd_git_upload_pack(app):\n    \"\"\"INTERNAL: Handle git upload pack for an app\"\"\"\n    app = sanitize_app_name(app)\n    env = globals()\n    env.update(locals())\n    # Handle the actual receive. We'll be called with 'git-hook' after it happens\n    call('git-shell -c \"{}\" '.format(argv[1] + \" '{}'\".format(app)), cwd=GIT_ROOT, shell=True)\n\n\n@piku.command(\"scp\", context_settings=dict(ignore_unknown_options=True, allow_extra_args=True))\n@pass_context\ndef cmd_scp(ctx):\n    \"\"\"Simple wrapper to allow scp to work.\"\"\"\n    call(\" \".join([\"scp\"] + ctx.args), cwd=GIT_ROOT, shell=True)\n\n\ndef _get_plugin_commands(path):\n    sys_path.append(abspath(path))\n\n    cli_commands = []\n    if isdir(path):\n        for item in listdir(path):\n            module_path = join(path, item)\n            if isdir(module_path):\n                try:\n                    module = import_module(item)\n                except Exception:\n                    module = None\n                if hasattr(module, 'cli_commands'):\n                    cli_commands.append(module.cli_commands())\n\n    return cli_commands\n\n\n@piku.command(\"help\")\n@pass_context\ndef cmd_help(ctx):\n    \"\"\"display help for piku\"\"\"\n    echo(ctx.parent.get_help())\n\n\n@piku.command(\"update\")\ndef cmd_update():\n    \"\"\"Update the piku cli\"\"\"\n    echo(\"Updating piku...\")\n\n    with NamedTemporaryFile(mode=\"w\") as f:\n        tempfile = f.name\n        cmd = \"\"\"curl -sL -w %{{http_code}} {} -o {}\"\"\".format(PIKU_RAW_SOURCE_URL, tempfile)\n        response = check_output(cmd.split(' '), stderr=STDOUT)\n        http_code = response.decode('utf8').strip()\n        if http_code == \"200\":\n            copyfile(tempfile, PIKU_SCRIPT)\n            echo(\"Update successful.\")\n        else:\n            echo(\"Error updating piku - please check if {} is accessible from this machine.\".format(PIKU_RAW_SOURCE_URL))\n    echo(\"Done.\")\n\n\nif __name__ == '__main__':\n    cli_commands = _get_plugin_commands(path=PIKU_PLUGIN_ROOT)\n    cli_commands.append(piku)\n    cli = CommandCollection(sources=cli_commands)\n    cli()\n"
        },
        {
          "name": "requirements.txt",
          "type": "blob",
          "size": 0.12109375,
          "content": "# THIS FILE IS ONLY USED FOR AUTOMATED TESTS - PIKU DOES NOT RELY ON THESE AS PIP INSTALLED PACKAGES\nclick\nuwsgi\nvirtualenv\n"
        },
        {
          "name": "uwsgi-piku.dist",
          "type": "blob",
          "size": 4.01171875,
          "content": "#!/usr/bin/env bash\n\n### BEGIN INIT INFO\n# Provides:          uwsgi\n# Required-Start:    $all\n# Required-Stop:     $all\n# Default-Start:     2 3 4 5\n# Default-Stop:      0 1 6\n# Short-Description: starts the uwsgi app server\n# Description:       starts uwsgi app server using start-stop-daemon\n### END INIT INFO\n\n# Based on https://github.com/pharaujo/uwsgi-init-script\n\nset -e\n\nVERSION=$(basename $0)\nPIKU_USER=piku\n\nPATH=/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin\nDAEMON=/usr/local/bin/$VERSION\nPIKU_ROOT=/home/$PIKU_USER/.piku\nRUN=$PIKU_ROOT/uwsgi\nENABLED_CONFIGS_DIR=$PIKU_ROOT/uwsgi-enabled\nAVAILABLE_CONFIGS_DIR=$PIKU_ROOT/uwsgi-available\nOWNER=$PIKU_USER\nNAME=$VERSION\nDESC=$VERSION\nOP=$1\nCORES=`grep -c ^processor /proc/cpuinfo`\nTHREADS=`echo \"$CORES * 4\" | bc`\n\n[[ -x $DAEMON ]] || exit 0\n[[ -d $RUN ]] || mkdir $RUN && chown $OWNER $RUN\n\nDAEMON_OPTS=\"\"\n\n# Include uwsgi defaults if available\nif [[ -f /etc/default/$VERSION ]]; then\n    . /etc/default/$VERSION\nfi\n\ndo_pid_check()\n{\n    local PIDFILE=$1\n    [[ -f $PIDFILE ]] || return 0\n    local PID=$(cat $PIDFILE)\n    for p in $(pgrep $VERSION); do\n        [[ $p == $PID ]] && return 1\n    done\n    return 0\n}\n\n\ndo_start()\n{\n    local PIDFILE=$RUN/$VERSION.pid\n    set -o noglob\n    local START_OPTS=\" \\\n        --ini $RUN/uwsgi.ini \\\n        --daemonize $RUN/uwsgi.log \\\n        --pidfile $PIDFILE\"\n    if do_pid_check $PIDFILE; then\n        sudo -u $OWNER -i $VERSION $DAEMON_OPTS $START_OPTS\n    else\n        echo \"Already running!\"\n    fi\n}\n\nsend_sig()\n{\n    local PIDFILE=$RUN/$VERSION.pid\n    set +e\n    [[ -f $PIDFILE ]] && kill $1 $(cat $PIDFILE) > /dev/null 2>&1\n    set -e\n}\n\nwait_and_clean_pidfile()\n{\n    local PIDFILE=$RUN/$VERSION.pid\n    until do_pid_check $PIDFILE; do\n        echo -n \"\";\n    done\n    rm -f $PIDFILE\n}\n\ndo_stop()\n{\n    send_sig -3\n    wait_and_clean_pidfile\n}\n\ndo_reload()\n{\n    send_sig -1\n}\n\ndo_force_reload()\n{\n    send_sig -15\n}\n\nget_status()\n{\n    local PIDFILE=$RUN/$VERSION.pid\n    if kill -0 $(cat $PIDFILE) > /dev/null 2>&1; then\n        echo \"$VERSION is running\"\n    else\n        echo \"$VERSION is not started\"\n    fi\n}\n\nenable_configs()\n{\n    local configs\n\n    if [[ $# -eq 0 || ${1,,} = 'all' ]]; then\n        configs=$(diff $AVAILABLE_CONFIGS_DIR $ENABLED_CONFIGS_DIR \\\n            | grep $AVAILABLE_CONFIGS_DIR \\\n            | sed -re 's#.+: (.+)$#\\1#')\n    else\n        configs=$@\n    fi\n\n    for c in $configs; do\n        echo -n \"Enabling $c...\"\n        [[ -f $ENABLED_CONFIGS_DIR/$c ]] && echo \"Skipped\" && continue\n        [[ -f $AVAILABLE_CONFIGS_DIR/$c ]] && \\\n            ln -s $AVAILABLE_CONFIGS_DIR/$c $ENABLED_CONFIGS_DIR && \\\n            echo \"Done\" && \\\n            continue\n        echo \"Error\"\n    done\n}\n\ndisable_configs()\n{\n    local configs\n    if [[ $# -eq 0 || ${1,,} = 'all' ]]; then\n        configs=$(find $ENABLED_CONFIGS_DIR -type l -exec basename {} \\;)\n    else\n        configs=$@\n    fi\n\n    for c in $configs; do\n        local config_path=\"$ENABLED_CONFIGS_DIR/$c\"\n        echo -n \"Disabling $c...\"\n        [[ ! -L $config_path ]] && echo \"Skipped\" && continue\n        [[ -f $config_path ]] && rm $config_path && echo \"Done\" && continue\n        echo \"Error\"\n    done\n}\n\ncase \"$OP\" in\n    start)\n        echo \"Starting $DESC: \"\n        do_start\n        echo \"$NAME.\"\n        ;;\n    stop)\n        echo -n \"Stopping $DESC: \"\n        do_stop\n        echo \"$NAME.\"\n        ;;\n    reload)\n        echo -n \"Reloading $DESC: \"\n        do_reload\n        echo \"$NAME.\"\n        ;;\n    force-reload)\n        echo -n \"Force-reloading $DESC: \"\n        do_force_reload\n        echo \"$NAME.\"\n       ;;\n    restart)\n        echo  \"Restarting $DESC: \"\n        do_stop\n        sleep 1\n        do_start\n        echo \"$NAME.\"\n        ;;\n    status)\n        get_status\n        ;;\n    enable)\n        shift\n        enable_configs $@\n        ;;\n    disable)\n        shift\n        disable_configs $@\n        ;;\n    *)\n        N=/etc/init.d/$NAME\n        echo \"Usage: $N {start|stop|restart|reload|force-reload|status\"\n            \"|enable|disable}\">&2\n        exit 1\n        ;;\nesac\nexit 0\n\n\n"
        },
        {
          "name": "uwsgi-piku.service",
          "type": "blob",
          "size": 0.3115234375,
          "content": "[Unit]\nDescription=Piku uWSGI Emperor\nAfter=syslog.target\n\n[Service]\nExecStart=/usr/local/bin/uwsgi-piku --ini /home/piku/.piku/uwsgi/uwsgi.ini\nUser=piku\nGroup=www-data\nRuntimeDirectory=uwsgi-piku\nRestart=always\nKillSignal=SIGQUIT\nType=notify\nStandardError=syslog\nNotifyAccess=all\n\n[Install]\nWantedBy=multi-user.target\n"
        }
      ]
    }
  ]
}