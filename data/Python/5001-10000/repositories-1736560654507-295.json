{
  "metadata": {
    "timestamp": 1736560654507,
    "page": 295,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjMwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "Morizeyao/GPT2-Chinese",
      "stars": 7501,
      "defaultBranch": "old_gpt_2_chinese_before_2021_4_22",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.150390625,
          "content": "__pycache__/\n.DS_Store\ncache/.DS_Store\n.idea/workspace.xml\n.idea/misc.xml\n.idea/GPT2-Chinese.iml\ndata/\n.samples.txt\n.idea/modules.xml\n.idea/vcs.xml\n.idea\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0400390625,
          "content": "MIT License\n\nCopyright (c) 2019 Zeyao Du\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 15.3759765625,
          "content": "# GPT2-Chinese\n\n## Description\n\n- Chinese version of GPT2 training code, using BERT tokenizer or BPE tokenizer. It is based on the extremely awesome repository from HuggingFace team [Transformers](https://github.com/huggingface/transformers). Can write poems, news, novels, or train general language models. Support char level, word level and BPE level. Support large training corpus.\n- 中文的GPT2训练代码，使用BERT的Tokenizer或Sentencepiece的BPE model（感谢[kangzhonghua](https://github.com/kangzhonghua)的贡献，实现BPE模式需要略微修改train.py的代码）。可以写诗，新闻，小说，或是训练通用语言模型。支持字为单位或是分词模式或是BPE模式（需要略微修改train.py的代码）。支持大语料训练。\n\n## UPDATE 04.11.2024\n\n- 非常感谢各位对本项目的关注。ChatGPT发布以来本项目也重新引起了一些注意。项目本身是我自学Pytorch的练手项目，我也无意做长期的维护更新。如果大家对大模型LLM感兴趣的话，可以邮件我(ned1991@gmail.com)加群沟通，或是在Issue中进行讨论。\n\n## UPDATE 02.06.2021\n\n- 本项目新增了[通用中文GPT-2预训练模型](https://github.com/Morizeyao/GPT2-Chinese#%E6%A8%A1%E5%9E%8B%E5%88%86%E4%BA%AB)、[通用中文GPT-2预训练小模型](https://github.com/Morizeyao/GPT2-Chinese#%E6%A8%A1%E5%9E%8B%E5%88%86%E4%BA%AB)、[中文歌词GPT-2预训练模型](https://github.com/Morizeyao/GPT2-Chinese#%E6%A8%A1%E5%9E%8B%E5%88%86%E4%BA%AB)和[文言文GPT-2预训练模型](https://github.com/Morizeyao/GPT2-Chinese#%E6%A8%A1%E5%9E%8B%E5%88%86%E4%BA%AB)。模型由UER-py项目训练得到，欢迎大家使用。\n此外，模型上传到了Huggingface Model Hub中。更多模型的细节请参考[gpt2-chinese-cluecorpussmall](https://huggingface.co/uer/gpt2-chinese-cluecorpussmall)、[gpt2-distil-chinese-cluecorpussmall](https://huggingface.co/uer/gpt2-distil-chinese-cluecorpussmall)、[gpt2-chinese-lyric](https://huggingface.co/uer/gpt2-chinese-lyric)和[gpt2-chinese-ancient](https://huggingface.co/uer/gpt2-chinese-ancient)。\n  \n  在使用所有模型进行生成时，需要在输入的文本前加入一个起始符，如：若要输入“最美的不是下雨天，是曾与你躲过雨的屋檐”，正确的格式为“[CLS]最美的不是下雨天，是曾与你躲过雨的屋檐”。\n\n\n## UPDATE 11.03.2020\n\n- 本项目新增了[古诗词GPT-2预训练模型](https://github.com/Morizeyao/GPT2-Chinese#%E6%A8%A1%E5%9E%8B%E5%88%86%E4%BA%AB)和[对联GPT-2预训练模型](https://github.com/Morizeyao/GPT2-Chinese#%E6%A8%A1%E5%9E%8B%E5%88%86%E4%BA%AB)。模型由UER-py项目训练得到，欢迎大家使用。\n此外，模型上传到了Huggingface Model Hub中。更多模型的细节请参考[gpt2-chinese-poem](https://huggingface.co/uer/gpt2-chinese-poem)和[gpt2-chinese-couplet](https://huggingface.co/uer/gpt2-chinese-couplet)。\n  \n  在使用古诗词模型进行生成时，需要在输入的文本前加入一个起始符，如：若要输入“梅山如积翠，”，正确的格式为“[CLS]梅山如积翠，”。\n  \n  对联模型训练时使用的语料格式为“上联-下联”，在使用对联模型进行生成时，需要在输入的文本前加入一个起始符，如：若要输入“丹枫江冷人初去-”，正确的格式为“[CLS]丹枫江冷人初去-”。\n\n## NEWS 08.11.2020\n\n- [CDial-GPT](https://github.com/thu-coai/CDial-GPT)(可用本代码载入)已发布。本项目包含一个经过严格清洗的大规模放开域中文对话数据集，本项目还包含在此数据集上训练的GPT对话预训练模型，以及生成样例，欢迎大家参观。\n\n## NEWS 12.9.2019\n\n- 新项目[GPT2-chitchat](https://github.com/yangjianxin1/GPT2-chitchat)已发布，部分基于本项目代码。包含训练GPT2对话模型的代码与与训练模型，以及生成样例，欢迎大家参观。\n\n## NEWS 12.7.2019\n\n- 新项目[Decoders-Chinese-TF2.0](https://github.com/Morizeyao/Decoders-Chinese-TF2.0)同样支持GPT2的中文训练，在使用上更加简单，不易产生各种问题。目前还在测试阶段，欢迎大家提出意见。\n\n## NEWS 11.9\n\n- [GPT2-ML](https://github.com/imcaspar/gpt2-ml)（与本项目无任何直接关联）已发布，包含1.5B中文GPT2模型。大家如有兴趣或需要可将其转换为本项目支持的Pytorch格式进行进一步训练或生成测试。\n\n## UPDATE 10.25\n\n- 本项目第一个预训练模型已公布，为散文生成模型，具体可查看README模型分享部分。\n\n## 项目状态\n\n- 在本项目公布时，中文的GPT2资源几乎为零，而现在情况已有所不同。其次项目功能已经基本稳定，因此目前本项目暂已停止更新。我写下这些代码的初衷是练习Pytorch的使用，即使后期做了一些填坑工作，难免还是有很多不成熟的地方，也请谅解。\n\n## 使用方法\n\n- 在项目根目录建立data文件夹。将训练语料以train.json为名放入data目录中。**train.json里是一个json列表，列表的每个元素都分别是一篇要训练的文章的文本内容（而不是文件链接）**。\n- 运行train.py文件，勾选 --raw ，会自动预处理数据。\n- 预处理完成之后，会自动执行训练。\n\n### 生成文本\n\n``` bash\npython ./generate.py --length=50 --nsamples=4 --prefix=xxx --fast_pattern --save_samples --save_samples_path=/mnt/xx\n```\n- **--fast_pattern** (由[LeeCP8](https://github.com/LeeCP8)贡献）：如果生成的length参数比较小，速度基本无差别，我个人测试length=250时，快了2秒，所以如果不添加--fast_pattern，那么默认不采用fast_pattern方式。\n- **--save_samples**：默认将输出样本直接打印到控制台，传递此参数，将保存在根目录下的**samples.txt**。\n- **--save_samples_path**：可自行指定保存的目录，默认可递归创建多级目录，不可以传递文件名称，文件名称默认为**samples.txt**。\n\n## 文件结构\n\n- generate.py 与 train.py 分别是生成与训练的脚本。\n- train_single.py 是 train.py的延伸，可以用于一个很大的单独元素列表（如训练一本斗破苍穹书）。\n- eval.py 用于评估生成模型的ppl分值。\n- generate_texts.py 是 generate.py 的延伸，可以以一个列表的起始关键词分别生成若干个句子并输出到文件中。\n- train.json 是训练样本的格式范例，可供参考。\n- cache 文件夹内包含若干BERT词表，make_vocab.py 是一个协助在一个train.json语料文件上建立词表的脚本。 vocab.txt 是原始BERT词表， vocab_all.txt 额外添加了古文词， vocab_small.txt 是小词表。\n- tokenizations 文件夹内是可以选用的三种tokenizer，包括默认的Bert Tokenizer，分词版Bert Tokenizer以及BPE Tokenizer。 \n- scripts 内包含了样例训练与生成脚本\n\n## 注意\n\n- 本项目使用Bert的tokenizer处理中文字符。\n- 如果不使用分词版的tokenizer，不需要自己事先分词，tokenizer会帮你分。\n- 如果使用分词版的tokenizer，最好先使用cache文件夹内的make_vocab.py文件建立针对你的语料的词表。\n- 模型需自行运算。各位如果完成了预训练的话欢迎进行交流。\n- 如果你的内存非常大或者语料较小的话，可以改掉train.py内build files内的对应代码，不做拆分直接预处理语料。\n- 若使用BPE Tokenizer，需自己建立中文词表\n\n## 语料\n\n- 可以从[这里](https://github.com/brightmart/nlp_chinese_corpus)与[这里](http://thuctc.thunlp.org/#获取链接)下载。\n- 斗破苍穹语料可以从[这里](https://github.com/GaoPeng97/transformer-xl-chinese/tree/master/data/doupo)下载。\n\n## FP16与Gradient Accumulation支持\n\n- 我在train.py文件中加入了fp16与gradient accumulation支持，如果你安装了apex并且知道fp16是什么的话，可以修改变量fp16=True来启用。但是目前fp16可能不收敛，原因不明。\n\n## 联系作者\n\n- Mail：ned1991@gmail.com\n\n## Citing\n\n```\n@misc{GPT2-Chinese,\n  author = {Zeyao Du},\n  title = {GPT2-Chinese: Tools for training GPT2 model in Chinese language},\n  year = {2019},\n  publisher = {GitHub},\n  journal = {GitHub repository},\n  howpublished = {\\url{https://github.com/Morizeyao/GPT2-Chinese}},\n}\n```\n\n## 模型分享\n|  模型名称 |   模型介绍|   分享者|  链接地址1 |  链接地址2 |\n| :----------- | :----------- | :----------- | :----------- | ------------ |\n| 散文模型  | 使用130MB的名家散文、情感散文和散文诗歌训练所得 。  |  [hughqiu](https://github.com/hughqiu \"hughqiu\") | [百度网盘【fpyu】](https://pan.baidu.com/s/1nbrW5iw34GRhoTin8uU2tQ)   | [GDrive](https://drive.google.com/drive/folders/1rJC4niJKMVwixUQkuL9k5teLRnEYTmUf?usp=sharing \"GDrive\") |\n| 诗词模型 | 使用180MB的约80万首古诗词训练所得。 | [hhou435](https://github.com/hhou435) | [百度网盘【7fev】](https://pan.baidu.com/s/1Hy0OQ5xZcTLer9MQZW8o3g) | [GDrive](https://drive.google.com/drive/folders/1Z6nF1nrgTkrZcRLHedQHXb4_M9I7yQPN?usp=sharing) |\n| 对联模型 | 使用40MB的约70万条对联训练所得。 | [hhou435](https://github.com/hhou435) | [百度网盘【i5n0】](https://pan.baidu.com/s/1j9yVQwjlXZq58wOyXK4lcg) | [GDrive](https://drive.google.com/drive/folders/1ZnsvS7oHRVueNKj_SeEhiQt86aze3ojj?usp=sharing) |\n| 通用中文模型 | 使用[CLUECorpusSmall](https://github.com/CLUEbenchmark/CLUECorpus2020/)语料训练所得。 | [hhou435](https://github.com/hhou435) | [百度网盘【n3s8】](https://pan.baidu.com/s/16x0hfBCekWju75xPeyyRfA) | [GDrive](https://drive.google.com/drive/folders/1dLEANs5z4pWS0pzrak6Q2H2Nq4iYsMsf?usp=sharing) |\n| 通用中文小模型 | 使用[CLUECorpusSmall](https://github.com/CLUEbenchmark/CLUECorpus2020/)语料训练所得。 | [hhou435](https://github.com/hhou435)           | [百度网盘【rpjk】](https://pan.baidu.com/s/1AiSm2GWhbGNxvhrcUlDXNA) | [GDrive](https://drive.google.com/drive/folders/1eerX1N8n_eFlnQ4xpxZ4iU2-Mx83pXFp?usp=sharing) |\n| 中文歌词模型   | 使用140MB的约15万首中文歌词训练所得。                        | [hhou435](https://github.com/hhou435)           | [百度网盘【0qnn】](https://pan.baidu.com/s/19x0d0bPGCWHi9L4Pu0pSiw) | [GDrive](https://drive.google.com/drive/folders/1RFq4NoQ3phCJjrhKtu2Xbn6z0krcN9TM?usp=sharing) |\n| 文言文模型 | 使用1.8GB的约300万篇文言文训练所得。 | [hhou435](https://github.com/hhou435) | [百度网盘【ek2z】](https://pan.baidu.com/s/1X3Um9HketnlGYZubY9gnew) | [GDrive](https://drive.google.com/drive/folders/1dtHTRn3fX7g8cPCCaJEXA2tmrIcImR6t?usp=sharing) |\n\n此处为热情大方的git友训练所得的模型文件，公开给所有朋友使用，同时也欢迎各位伙伴将自己训练完毕的模型公开于此处。\n\n\n## Demo\n\n- 由用户[JamesHujy](https://github.com/JamesHujy)根据本仓库改版代码训练得到的模型作为律诗与绝句后台，新版[九歌诗歌生成器](https://jiuge.thunlp.cn/lvshi.html)已经上线。\n- 由[leemengtaiwan](https://github.com/leemengtaiwan)贡献，提供[文章直觀介紹 GPT-2 以及如何視覺化自注意力機制](https://leemeng.tw/gpt2-language-model-generate-chinese-jing-yong-novels.html)。另提供 [Colab 筆記本與模型](https://colab.research.google.com/drive/1MaT8-HUHfZkdCra0OqZEIr0IFCq0MJBx)供任何使用者一鍵生成新樣例。\n\n## 生成样例\n\n-以下为文学散文的生成样例，由[hughqiu](https://github.com/hughqiu \"hughqiu\")贡献，模型已经分享于模型分享列表。语料130MB，Batch size 16，10层深度下训练10轮所得。\n![avatar](sample/散文1.png)\n![avatar](sample/散文2.png)\n![avatar](sample/散文3.png)\n\n- 下为斗破苍穹的生成样例，使用约50M参数的GPT2以32Batch Size在16MB斗破苍穹小说内容上训练得到。此处[SEP]表示换行。\n\n![avatar](sample/doupo.jpeg)\n\n- 下为古诗词的生成样例，由用户[JamesHujy](https://github.com/JamesHujy)运算并贡献。\n\n![avatar](sample/poem_1.png)\n![avatar](sample/poem_2.png)\n\n- 下为古诗限定了生成体裁后的生成样例，由用户[JamesHujy](https://github.com/JamesHujy)运算并贡献。\n\n![avatar](sample/律诗绝句.png)\n![avatar](sample/浣溪沙_江城子.png)\n![avatar](sample/蝶恋花_满江红.png)\n\n- 下为生成剧本的样例文本，由用户[chiangandy](https://github.com/chiangandy)运算并贡献\n\n[starttext]爱情游戏剧情讲述了钢琴父女明致怀萌的爱情、个有着努力的热情以及现实为人生的价值观众，获得一系列爱情的故事。80后录股媒体受到网友分享，是2014年主创陈拉昀出品牌总监于蓝氏集团化验师创业团门的哥哥大国度上海淮河畔，集入第一线公司青年度虽然没有放到的事业，但是蓝正是却不到位主人拒绝了解，而在蓝越的帮助理念出现，也因此开启明朗的误会而经营变成爱河。在一次偶然的编剧集电视剧之夏天上一改变了自命运环球顶樑，三人在创车祸中不知被记忆差网识分到创作，并被问流言败，以及行业服务所有的低调教同才力，陈昭和唐诗诗妍展开了一段截然不同的“2014年间段感情”，两人性格互相治癒的商业奋斗故事，尽管是共90后北京华侨大学录的一个宿舍小旅程和唐如、生等优秀青年，的人生活如何与愿违3个国偶像，并且共同创作何以此他们互相有观众的成功和关心吗?[endtext]\n\n[starttext]学习爱情主要讲述了两对方小曼，经过啼笑皆非的考验，终于选择了三个孩子，携手共同创业来四个孩子，在大城市里创业的成功商。两家内事业的加入了北京城市，经过了一次元城市融风雨故、差异后得到异的他们，最终收获了梦想的真正属于自己的爱情。赞助理想、电视剧、剧等主创业时代人物特点在北京举行开机仪式，该剧以当下海南三个新人青年轻人面人海南梅竹马的电视角，讲述了几个在北京、喜剧代人生活中增强非浪漫的年轻人，以独特的双时代年轻人从来到北京城市化中国大城市走出发展以海南方的变迁在语种城市闯关于人生态的同时，以及他们渐渐的生活方式为自己方向上演了那么简单俗，是当代际拍摄的就如何在这个城市里都市里?那么平静的城市就是城市的风格特张嘉和支持工作打造，而这是一点就要打造出机场话剧组会。化身处处棋逢貌各种文化的人都非常独特的煽情，交织了相，滑稽等来自外衣的东北漂亮、内地，者和两位女孩子敢称是哑女孩子。交织里的人齐飞一开泰块玩笑，令人印象太趋的气质，让人眼看这个性格非常喜剧，知道的是一个“东北漂”人的外国小养家，让她耳熟练读剧的外形象显老大。之后齐飞、表示爱朗的齐飞、范儿、楚月子、白天杰。两代人的生活里友情似乎没有结合、精彩表态的开朗和丽丽丽。[endtext]\n\n- 下為金庸武俠小說的生成樣例，由[leemengtaiwan](https://github.com/leemengtaiwan)贡献。模型大小約 82M，語料 50 MB，Batch size 16。提供[文章直觀介紹 GPT-2 以及如何視覺化自注意力機制](https://leemeng.tw/gpt2-language-model-generate-chinese-jing-yong-novels.html)。另提供 [Colab 筆記本與模型](https://colab.research.google.com/drive/1MaT8-HUHfZkdCra0OqZEIr0IFCq0MJBx)供任何使用者一鍵生成新樣例。\n\n![avatar](sample/金庸_天龍八部.jpg)\n![avatar](sample/金庸_倚天屠龍記.jpg)\n![avatar](sample/金庸_鹿鼎記.jpg)\n![avatar](sample/金庸_神鵰俠侶.jpg)\n\n\n\n"
        },
        {
          "name": "README_EN.md",
          "type": "blob",
          "size": 7.9189453125,
          "content": "# GPT2-Chinese\n\n## Description\n\n- Chinese version of GPT2 training code, using BERT tokenizer or BPE tokenizer. from HuggingFace team [Transformers](https://github.com/huggingface/transformers). Can write poems, news, novels, or train general language models. Can write poems, news, novels, or train general language models. Support char level, word level and BPE level. training corpus.\n- Chinese GPT2 training code, using BERT's Tokenizer or Sentencepiece's BPE model (thanks to [kangzhonghua](https://github.com/kangzhonghua) for the contribution, the implementation of the BPE model requires a slight modification of train.py). (Code). You can write poems, news, novels, or train common language models. Support for word units or parts of words or BPE mode (need to modify the code of train.py slightly). Supports large corpus training.\n\n## NEWS 08.11.2020\n\n- [CDial-GPT](https://github.com/thu-coai/CDial-GPT) (which can be loaded with this code) has been released. This project contains a rigorously cleaned Chinese dialogue dataset in a large scale liberalized domain, and a pre-trained GPT model trained on this dataset, as well as generated samples.\n\n## NEWS 12.9.2019.\n\n- A new project [GPT2-chitchat](https://github.com/yangjianxin1/GPT2-chitchat) has been released, based in part on the code of this project. It contains code for training the GPT2 conversational model with and with the training model, as well as generating samples, which you are welcome to visit.\n\n## NEWS 12.7.2019.\n\n- The new project [Decoders-Chinese-TF2.0](https://github.com/Morizeyao/Decoders-Chinese-TF2.0) also supports Chinese training of GPT2, which is easier to use and less likely to cause problems. It is still in the testing stage, so we welcome your comments.\n\n## NEWS 11.9\n\n- [GPT2-ML](https://github.com/imcaspar/gpt2-ml) (not directly related to this project) has been released, including 1.5B Chinese GPT2 model. It contains a 1.5B Chinese GPT2 model. It can be converted to the Pytorch format supported by this project for further training or test generation if you are interested.\n\n## UPDATE 10.25\n\n- The first pre-trained model of this project has been released, it is a prose generation model, please see the README model sharing section.\n\n## Project Status\n\n- When this project was announced, the Chinese GPT2 resources were almost zero, but the situation is different now. Secondly, the functionality of the project has been stabilized, so the project has been stopped for the time being. The purpose of this code is to practice using Pytorch, even if I have to fill in some holes later, there are still a lot of immature places, please understand.\n\n## Usage\n\n- Create a data folder in the project root directory. Put the training corpus into the data directory under the name train.json. **train.json is a json list, each element of the list is the text of an article to be trained (rather than a link to a file)**.\n- Run the train.py file, check --raw, it will automatically preprocess the data.\n- When the preprocessing is complete, the training will be executed automatically.\n\n### Generate text\n\n``` bash\npython . /generate.py --length=50 --nsamples=4 --prefix=xxx --fast_pattern --save_samples --save_samples_path=/mnt/xx\n```\n- **--fast_pattern** (contributed by [LeeCP8](https://github.com/LeeCP8)): If the generated length parameter is relatively small, the speed is basically no difference, my personal test length = 250, faster by 2 seconds, so if you do not add--fast_pattern then fast_pattern is not used by default.\n- **--save_samples**: Default is to print the output samples directly to the console, pass this parameter, it will be saved in the root directory **samples.txt**.\n- **--save_samples_path**: you can specify the directory to be saved, the default is recursive creation of multi-level directories, you can not pass the file name, the default file name is **samples.txt**.\n\n## File structure\n\n- generate.py and train.py are generation and training scripts, respectively.\n- train_single.py is an extension of train.py and can be used for a large list of individual elements (e.g. training a DouDouQiongQiong book).\n- eval.py is used to evaluate the ppl score of the generated model.\n- generate_texts.py is an extension of generate.py that generates several sentences starting with a list of keywords and outputs them to a file.\n- train.json is an example of the format of the training samples that is available for reference.\n- The cache folder contains several BERT vocabularies. make_vocab.py is a script that assists in building vocabularies on a train.json corpus file. vocab.txt is the original BERT vocabulary, vocab_all.txt is an additional archaic word, vocab_small.txt is a small vocabulary.\n- The tokenizations folder contains the three tokenizers you can choose from: the default Bert Tokenizer, the split-word version of the Bert Tokenizer, and the BPE Tokenizer. \n- The scripts contain sample training and generation scripts.\n\n## Attention.\n\n- This project uses Bert's tokenizer to handle Chinese characters.\n- If you don't use the word-splitting version of the tokenizer, you don't need to split the words yourself, the tokenizer will do it for you.\n- If you use the word splitting version of the tokenizer, you should use the make_vocab.py file in the cache folder to create a word list for your corpus.\n- The model needs to be calculated by yourself. If you have finished the pre-training, please feel free to talk to us.\n- If your memory is very big or the corpus is small, you can change the corresponding code in the build files in train.py and preprocess the corpus without splitting it.\n- If you use BPE Tokenizer, you need to build your own Chinese word list.\n\n## Language\n\n- It can be downloaded from [here](https://github.com/brightmart/nlp_chinese_corpus) and [here](http://thuctc.thunlp.org/#获取链接).\n- The DoD language can be downloaded from [here](https://github.com/GaoPeng97/transformer-xl-chinese/tree/master/data/doupo).\n\n## FP16 with Gradient Accumulation Support\n\n- I've added fp16 and gradient accumulation support in the train.py file, and if you have apex installed and know what fp16 is, you can modify the variable fp16=True to enable it. But currently fp16 may not converge, for reasons unknown.\n\n## Contact the author\n\n- Mail: ned1991@gmail.com\n\n## Citing\n\n```\n@misc{GPT2-Chinese,\n  author = {Zeyao Du},\n  title = {GPT2-Chinese: Tools for training GPT2 model in Chinese language},\n  year = {2019},\n  publisher = {GitHub},\n  journal = {GitHub repository},\n  howpublished = {\\url{https://github.com/Morizeyao/GPT2-Chinese}},\n}\n```\n\n## Model sharing\n| Model Name | Model Description | Shareholder | Link Address1 | Link Address2 | Link Address2\n| The first is that the number of people in the world who have been in the hospital for more than a year has been increasing.\n| Prose Model | Using 130MB of famous prose, emotional prose and prose poetry training results .  | [hughqiu](https://github.com/hughqiu \"hughqiu\") | [Baidu.com [fpyu](https://pan.baidu.com/s/1nbrW5iw34GRhoTin8uU2tQ) | [GDrive](https) ://drive.google.com/drive/folders/1rJC4niJKMVwixUQkuL9k5teLRnEYTmUf?usp=sharing \"gDrive\") |\n\n\n\nThis is the training model file of a warm and generous git user, it's open for all friends to use, and all partners are welcome to open their own training models here.\n\n\n## Demo\n\n- By user [JamesHujy](https://github.com/JamesHujy), trained on the model obtained from the code revision of this repository as a rhythm and stanza background, a new version of the [Nine Song Poetry Generator](https://jiuge.thunlp.cn/lvshi.html) is now available.\n- Contributed by [leemengtaiwan](https://github.com/leemengtaiwan) to provide an [article intuitive introduction to GPT-2 and how to visualize the self-attention mechanism](https://leemeng.tw/gpt2-language-model-) generate-english-jing-yong-novels.html). Colab notebooks and models are also available (https://colab.research.google.com/drive/1MaT8-HUHfZkdCra0OqZEIr0IFCq0MJBx) for any user to generate new samples with a single click.\n\nTranslated with www.DeepL.com/Translator (free version)"
        },
        {
          "name": "cache",
          "type": "tree",
          "content": null
        },
        {
          "name": "config",
          "type": "tree",
          "content": null
        },
        {
          "name": "eval.py",
          "type": "blob",
          "size": 7.6884765625,
          "content": "import transformers\nimport torch\nimport os\nimport json\nimport random\nimport numpy as np\nimport argparse\nfrom datetime import datetime\nfrom tqdm import tqdm\nfrom torch.nn import DataParallel\n\n\ndef build_files(data_path, tokenized_data_path, num_pieces, full_tokenizer, min_length):\n    if not os.path.exists(tokenized_data_path):\n        os.mkdir(tokenized_data_path)\n    with open(data_path, 'r', encoding='utf8') as f:\n        print('reading lines')\n        lines = json.load(f)\n        lines = [line.replace('\\n', ' [SEP] ') for line in lines]  # 用[SEP]表示换行, 段落之间使用SEP表示段落结束\n        all_len = len(lines)\n    for i in tqdm(range(num_pieces)):\n        sublines = lines[all_len // num_pieces * i: all_len // num_pieces * (i + 1)]\n        if i == num_pieces - 1:\n            sublines.extend(lines[all_len // num_pieces * (i + 1):])  # 把尾部例子添加到最后一个piece\n        sublines = [full_tokenizer.tokenize(line) for line in sublines if\n                    len(line) > min_length]  # 只考虑长度超过min_length的句子\n        sublines = [full_tokenizer.convert_tokens_to_ids(line) for line in sublines]\n        full_line = []\n        for subline in sublines:\n            full_line.append(full_tokenizer.convert_tokens_to_ids('[MASK]'))  # 文章开头添加MASK表示文章开始\n            full_line.extend(subline)\n            full_line.append(full_tokenizer.convert_tokens_to_ids('[CLS]'))  # 文章之间添加CLS表示文章结束\n        with open(tokenized_data_path + 'tokenized_train_{}.txt'.format(i), 'w') as f:\n            for id in full_line:\n                f.write(str(id) + ' ')\n    print('finish')\n\n\ndef main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--device', default='0,1,2,3', type=str, required=False, help='设置使用哪些显卡')\n    parser.add_argument('--model_config', default='config/model_config_small.json', type=str, required=False,\n                        help='选择模型参数')\n    parser.add_argument('--tokenizer_path', default='cache/vocab_small.txt', type=str, required=False, help='选择词库')\n    parser.add_argument('--raw_data_path', default='data/eval.json', type=str, required=False, help='原始语料')\n    parser.add_argument('--tokenized_data_path', default='data/tokenized_eval/', type=str, required=False,\n                        help='tokenized语料存放位置')\n    parser.add_argument('--raw', action='store_true', help='是否先做tokenize')\n    parser.add_argument('--batch_size', default=8, type=int, required=False, help='batch size')\n    parser.add_argument('--log_step', default=1, type=int, required=False, help='多少步汇报一次')\n    parser.add_argument('--stride', default=768, type=int, required=False, help='取数据的窗口步长')\n    parser.add_argument('--num_pieces', default=100, type=int, required=False, help='将训练语料分成多少份')\n    parser.add_argument('--min_length', default=128, type=int, required=False, help='最短收录文章长度')\n    parser.add_argument('--pretrained_model', default='', type=str, required=False, help='模型起点路径')\n    parser.add_argument('--output_dir', default='eval_result/', type=str, required=False, help='结果输出路径')\n\n    args = parser.parse_args()\n    print('args:\\n' + args.__repr__())\n\n    # if args.no_wordpiece:\n    #     from tokenizations import tokenization_bert_without_wordpiece as tokenization_bert\n    # else:\n    from tokenizations import tokenization_bert\n\n    os.environ[\"CUDA_VISIBLE_DEVICES\"] = args.device  # 此处设置程序使用哪些显卡\n\n    model_config = transformers.modeling_gpt2.GPT2Config.from_json_file(args.model_config)\n    print('config:\\n' + model_config.to_json_string())\n\n    n_ctx = model_config.n_ctx\n    full_tokenizer = tokenization_bert.BertTokenizer(vocab_file=args.tokenizer_path)\n    full_tokenizer.max_len = n_ctx\n    device = 'cuda' if torch.cuda.is_available() else 'cpu'\n    print('using device:', device)\n\n    raw_data_path = args.raw_data_path\n    tokenized_data_path = args.tokenized_data_path\n    raw = args.raw  # 选择是否从零开始构建数据集\n    batch_size = args.batch_size\n    log_step = args.log_step\n    stride = args.stride\n    num_pieces = args.num_pieces\n    min_length = args.min_length\n    output_dir = args.output_dir\n\n    if not os.path.exists(output_dir):\n        os.mkdir(output_dir)\n\n    if raw:\n        print('building files')\n        build_files(data_path=raw_data_path, tokenized_data_path=tokenized_data_path, num_pieces=num_pieces,\n                    full_tokenizer=full_tokenizer, min_length=min_length)\n        print('files built')\n\n    if not args.pretrained_model:\n        print('you need to specify a trained model.')\n        exit(1)\n    else:\n        model = transformers.modeling_gpt2.GPT2LMHeadModel.from_pretrained(args.pretrained_model)\n    model.eval()\n    model.to(device)\n\n    num_parameters = 0\n    parameters = model.parameters()\n    for parameter in parameters:\n        num_parameters += parameter.numel()\n    print('number of parameters: {}'.format(num_parameters))\n\n    multi_gpu = False\n    full_len = 0\n    print('calculating total steps')\n    for i in tqdm(range(num_pieces)):\n        with open(tokenized_data_path + 'tokenized_train_{}.txt'.format(i), 'r') as f:\n            full_len += len([int(item) for item in f.read().strip().split()])\n\n    if torch.cuda.device_count() > 1:\n        print(\"Let's use\", torch.cuda.device_count(), \"GPUs!\")\n        model = DataParallel(model)\n        multi_gpu = True\n    print('starting training')\n    overall_step = 0\n\n    total_loss = 0\n    total_steps = 0\n    #  eval\n    now = datetime.now()\n    print('time: {}'.format(now))\n    piece_num = 0\n    for i in range(num_pieces):\n        with open(tokenized_data_path + 'tokenized_train_{}.txt'.format(i), 'r') as f:\n            line = f.read().strip()\n        tokens = line.split()\n        tokens = [int(token) for token in tokens]\n        start_point = 0\n        samples = []\n        while start_point < len(tokens) - n_ctx:\n            samples.append(tokens[start_point: start_point + n_ctx])\n            start_point += stride\n        start_point -= stride\n        last = tokens[start_point + n_ctx:]\n        last.extend([full_tokenizer.convert_tokens_to_ids(['[PAD]']) * (n_ctx - len(last))])\n        random.shuffle(samples)\n        for step in range(len(samples) // batch_size):  # drop last\n\n            #  prepare data\n            batch = samples[step * batch_size: (step + 1) * batch_size]\n            batch_labels = []\n            batch_inputs = []\n            for ids in batch:\n                int_ids_for_labels = [int(x) for x in ids]\n                int_ids_for_inputs = [int(x) for x in ids]\n                batch_labels.append(int_ids_for_labels)\n                batch_inputs.append(int_ids_for_inputs)\n            batch_labels = torch.tensor(batch_labels).long().to(device)\n            batch_inputs = torch.tensor(batch_inputs).long().to(device)\n\n            #  forward pass\n            outputs = model.forward(input_ids=batch_inputs, labels=batch_labels)\n            loss, logits = outputs[:2]\n\n            #  get loss\n            if multi_gpu:\n                loss = loss.mean()\n            total_loss += loss\n            total_steps += 1\n\n            if (overall_step + 1) % log_step == 0:\n                print('now time: {}:{}. Step {} of piece {}, ppl {}'.format(\n                    datetime.now().hour,\n                    datetime.now().minute,\n                    (step + 1),\n                    piece_num,\n                    torch.exp(loss)))\n        piece_num += 1\n\n    if not os.path.exists(args.output_dir):\n        os.mkdir(args.output_dir)\n    else:\n        with open(args.output_dir + 'result.txt', 'w') as f:\n            f.write(np.exp(total_loss / total_steps))\n\n\nif __name__ == '__main__':\n    main()\n"
        },
        {
          "name": "generate.py",
          "type": "blob",
          "size": 10.296875,
          "content": "import torch\nimport torch.nn.functional as F\nimport os\nimport argparse\nfrom tqdm import trange\nfrom transformers import GPT2LMHeadModel\n\n\ndef is_word(word):\n    for item in list(word):\n        if item not in 'qwertyuiopasdfghjklzxcvbnm':\n            return False\n    return True\n\n\ndef _is_chinese_char(char):\n    \"\"\"Checks whether CP is the codepoint of a CJK character.\"\"\"\n    # This defines a \"chinese character\" as anything in the CJK Unicode block:\n    #   https://en.wikipedia.org/wiki/CJK_Unified_Ideographs_(Unicode_block)\n    #\n    # Note that the CJK Unicode block is NOT all Japanese and Korean characters,\n    # despite its name. The modern Korean Hangul alphabet is a different block,\n    # as is Japanese Hiragana and Katakana. Those alphabets are used to write\n    # space-separated words, so they are not treated specially and handled\n    # like the all of the other languages.\n    cp = ord(char)\n    if ((cp >= 0x4E00 and cp <= 0x9FFF) or  #\n            (cp >= 0x3400 and cp <= 0x4DBF) or  #\n            (cp >= 0x20000 and cp <= 0x2A6DF) or  #\n            (cp >= 0x2A700 and cp <= 0x2B73F) or  #\n            (cp >= 0x2B740 and cp <= 0x2B81F) or  #\n            (cp >= 0x2B820 and cp <= 0x2CEAF) or\n            (cp >= 0xF900 and cp <= 0xFAFF) or  #\n            (cp >= 0x2F800 and cp <= 0x2FA1F)):  #\n        return True\n\n    return False\n\n\ndef top_k_top_p_filtering(logits, top_k=0, top_p=0.0, filter_value=-float('Inf')):\n    \"\"\" Filter a distribution of logits using top-k and/or nucleus (top-p) filtering\n        Args:\n            logits: logits distribution shape (vocabulary size)\n            top_k > 0: keep only top k tokens with highest probability (top-k filtering).\n            top_p > 0.0: keep the top tokens with cumulative probability >= top_p (nucleus filtering).\n                Nucleus filtering is described in Holtzman et al. (http://arxiv.org/abs/1904.09751)\n        From: https://gist.github.com/thomwolf/1a5a29f6962089e871b94cbd09daf317\n    \"\"\"\n    assert logits.dim() == 1  # batch size 1 for now - could be updated for more but the code would be less clear\n    top_k = min(top_k, logits.size(-1))  # Safety check\n    if top_k > 0:\n        # Remove all tokens with a probability less than the last token of the top-k\n        indices_to_remove = logits < torch.topk(logits, top_k)[0][..., -1, None]\n        logits[indices_to_remove] = filter_value\n\n    if top_p > 0.0:\n        sorted_logits, sorted_indices = torch.sort(logits, descending=True)\n        cumulative_probs = torch.cumsum(F.softmax(sorted_logits, dim=-1), dim=-1)\n\n        # Remove tokens with cumulative probability above the threshold\n        sorted_indices_to_remove = cumulative_probs > top_p\n        # Shift the indices to the right to keep also the first token above the threshold\n        sorted_indices_to_remove[..., 1:] = sorted_indices_to_remove[..., :-1].clone()\n        sorted_indices_to_remove[..., 0] = 0\n\n        indices_to_remove = sorted_indices[sorted_indices_to_remove]\n        logits[indices_to_remove] = filter_value\n    return logits\n\n\ndef sample_sequence(model, context, length, n_ctx, tokenizer, temperature=1.0, top_k=30, top_p=0.0, repitition_penalty=1.0,\n                    device='cpu'):\n    context = torch.tensor(context, dtype=torch.long, device=device)\n    context = context.unsqueeze(0)\n    generated = context\n    with torch.no_grad():\n        for _ in trange(length):\n            inputs = {'input_ids': generated[0][-(n_ctx - 1):].unsqueeze(0)}\n            outputs = model(\n                **inputs)  # Note: we could also use 'past' with GPT-2/Transfo-XL/XLNet (cached hidden-states)\n            next_token_logits = outputs[0][0, -1, :]\n            for id in set(generated):\n                next_token_logits[id] /= repitition_penalty\n            next_token_logits = next_token_logits / temperature\n            next_token_logits[tokenizer.convert_tokens_to_ids('[UNK]')] = -float('Inf')\n            filtered_logits = top_k_top_p_filtering(next_token_logits, top_k=top_k, top_p=top_p)\n            next_token = torch.multinomial(F.softmax(filtered_logits, dim=-1), num_samples=1)\n            generated = torch.cat((generated, next_token.unsqueeze(0)), dim=1)\n    return generated.tolist()[0]\n\n\ndef fast_sample_sequence(model, context, length, temperature=1.0, top_k=30, top_p=0.0, device='cpu'):\n    inputs = torch.LongTensor(context).view(1, -1).to(device)\n    if len(context) > 1:\n        _, past = model(inputs[:, :-1], None)[:2]\n        prev = inputs[:, -1].view(1, -1)\n    else:\n        past = None\n        prev = inputs\n    generate = [] + context\n    with torch.no_grad():\n        for i in trange(length):\n            output = model(prev, past=past)\n            output, past = output[:2]\n            output = output[-1].squeeze(0) / temperature\n            filtered_logits = top_k_top_p_filtering(output, top_k=top_k, top_p=top_p)\n            next_token = torch.multinomial(torch.softmax(filtered_logits, dim=-1), num_samples=1)\n            generate.append(next_token.item())\n            prev = next_token.view(1, 1)\n    return generate\n\n\n# 通过命令行参数--fast_pattern，指定模式\ndef generate(n_ctx, model, context, length, tokenizer, temperature=1, top_k=0, top_p=0.0, repitition_penalty=1.0, device='cpu',\n             is_fast_pattern=False):\n    if is_fast_pattern:\n        return fast_sample_sequence(model, context, length, temperature=temperature, top_k=top_k, top_p=top_p,\n                                    device=device)\n    else:\n        return sample_sequence(model, context, length, n_ctx, tokenizer=tokenizer, temperature=temperature, top_k=top_k, top_p=top_p,\n                               repitition_penalty=repitition_penalty, device=device)\n\n\ndef main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--device', default='0,1,2,3', type=str, required=False, help='生成设备')\n    parser.add_argument('--length', default=-1, type=int, required=False, help='生成长度')\n    parser.add_argument('--batch_size', default=1, type=int, required=False, help='生成的batch size')\n    parser.add_argument('--nsamples', default=10, type=int, required=False, help='生成几个样本')\n    parser.add_argument('--temperature', default=1, type=float, required=False, help='生成温度')\n    parser.add_argument('--topk', default=8, type=int, required=False, help='最高几选一')\n    parser.add_argument('--topp', default=0, type=float, required=False, help='最高积累概率')\n    parser.add_argument('--model_config', default='config/model_config_small.json', type=str, required=False,\n                        help='模型参数')\n    parser.add_argument('--tokenizer_path', default='cache/vocab_small.txt', type=str, required=False, help='词表路径')\n    parser.add_argument('--model_path', default='model/final_model', type=str, required=False, help='模型路径')\n    parser.add_argument('--prefix', default='萧炎', type=str, required=False, help='生成文章的开头')\n    parser.add_argument('--no_wordpiece', action='store_true', help='不做word piece切词')\n    parser.add_argument('--segment', action='store_true', help='中文以词为单位')\n    parser.add_argument('--fast_pattern', action='store_true', help='采用更加快的方式生成文本')\n    parser.add_argument('--save_samples', action='store_true', help='保存产生的样本')\n    parser.add_argument('--save_samples_path', default='.', type=str, required=False, help=\"保存样本的路径\")\n    parser.add_argument('--repetition_penalty', default=1.0, type=float, required=False)\n\n    args = parser.parse_args()\n    print('args:\\n' + args.__repr__())\n\n    if args.segment:\n        from tokenizations import tokenization_bert_word_level as tokenization_bert\n    else:\n        from tokenizations import tokenization_bert\n\n    os.environ[\"CUDA_VISIBLE_DEVICES\"] = args.device  # 此处设置程序使用哪些显卡\n    length = args.length\n    batch_size = args.batch_size\n    nsamples = args.nsamples\n    temperature = args.temperature\n    topk = args.topk\n    topp = args.topp\n    repetition_penalty = args.repetition_penalty\n\n    device = \"cuda\" if torch.cuda.is_available() else \"cpu\"\n\n    tokenizer = tokenization_bert.BertTokenizer(vocab_file=args.tokenizer_path)\n    model = GPT2LMHeadModel.from_pretrained(args.model_path)\n    model.to(device)\n    model.eval()\n\n    n_ctx = model.config.n_ctx\n\n    if length == -1:\n        length = model.config.n_ctx\n    if args.save_samples:\n        if not os.path.exists(args.save_samples_path):\n            os.makedirs(args.save_samples_path)\n        samples_file = open(args.save_samples_path + '/samples.txt', 'w', encoding='utf8')\n    while True:\n        raw_text = args.prefix\n        context_tokens = tokenizer.convert_tokens_to_ids(tokenizer.tokenize(raw_text))\n        generated = 0\n        for _ in range(nsamples // batch_size):\n            out = generate(\n                n_ctx=n_ctx,\n                model=model,\n                context=context_tokens,\n                length=length,\n                is_fast_pattern=args.fast_pattern, tokenizer=tokenizer,\n                temperature=temperature, top_k=topk, top_p=topp, repitition_penalty=repetition_penalty, device=device\n            )\n            for i in range(batch_size):\n                generated += 1\n                text = tokenizer.convert_ids_to_tokens(out)\n                for i, item in enumerate(text[:-1]):  # 确保英文前后有空格\n                    if is_word(item) and is_word(text[i + 1]):\n                        text[i] = item + ' '\n                for i, item in enumerate(text):\n                    if item == '[MASK]':\n                        text[i] = ''\n                    elif item == '[CLS]':\n                        text[i] = '\\n\\n'\n                    elif item == '[SEP]':\n                        text[i] = '\\n'\n                info = \"=\" * 40 + \" SAMPLE \" + str(generated) + \" \" + \"=\" * 40 + \"\\n\"\n                print(info)\n                text = ''.join(text).replace('##', '').strip()\n                print(text)\n                if args.save_samples:\n                    samples_file.write(info)\n                    samples_file.write(text)\n                    samples_file.write('\\n')\n                    samples_file.write('=' * 90)\n                    samples_file.write('\\n' * 2)\n        print(\"=\" * 80)\n        if generated == nsamples:\n            # close file when finish writing.\n            if args.save_samples:\n                samples_file.close()\n            break\n\n\nif __name__ == '__main__':\n    main()\n"
        },
        {
          "name": "generate_texts.py",
          "type": "blob",
          "size": 8.7392578125,
          "content": "import torch\nimport torch.nn.functional as F\nimport os\nimport argparse\nfrom tqdm import trange\nfrom transformers import GPT2LMHeadModel\n\nos.environ[\"CUDA_VISIBLE_DEVICES\"] = \"0,1,2,3\"  # 此处设置程序使用哪些显卡\n\n\ndef is_word(word):\n    for item in list(word):\n        if item not in 'qwertyuiopasdfghjklzxcvbnm':\n            return False\n    return True\n\n\ndef _is_chinese_char(char):\n    \"\"\"Checks whether CP is the codepoint of a CJK character.\"\"\"\n    # This defines a \"chinese character\" as anything in the CJK Unicode block:\n    #   https://en.wikipedia.org/wiki/CJK_Unified_Ideographs_(Unicode_block)\n    #\n    # Note that the CJK Unicode block is NOT all Japanese and Korean characters,\n    # despite its name. The modern Korean Hangul alphabet is a different block,\n    # as is Japanese Hiragana and Katakana. Those alphabets are used to write\n    # space-separated words, so they are not treated specially and handled\n    # like the all of the other languages.\n    cp = ord(char)\n    if ((cp >= 0x4E00 and cp <= 0x9FFF) or  #\n            (cp >= 0x3400 and cp <= 0x4DBF) or  #\n            (cp >= 0x20000 and cp <= 0x2A6DF) or  #\n            (cp >= 0x2A700 and cp <= 0x2B73F) or  #\n            (cp >= 0x2B740 and cp <= 0x2B81F) or  #\n            (cp >= 0x2B820 and cp <= 0x2CEAF) or\n            (cp >= 0xF900 and cp <= 0xFAFF) or  #\n            (cp >= 0x2F800 and cp <= 0x2FA1F)):  #\n        return True\n\n    return False\n\n\ndef top_k_top_p_filtering(logits, top_k=0, top_p=0.0, filter_value=-float('Inf')):\n    \"\"\" Filter a distribution of logits using top-k and/or nucleus (top-p) filtering\n        Args:\n            logits: logits distribution shape (vocabulary size)\n            top_k > 0: keep only top k tokens with highest probability (top-k filtering).\n            top_p > 0.0: keep the top tokens with cumulative probability >= top_p (nucleus filtering).\n                Nucleus filtering is described in Holtzman et al. (http://arxiv.org/abs/1904.09751)\n        From: https://gist.github.com/thomwolf/1a5a29f6962089e871b94cbd09daf317\n    \"\"\"\n    assert logits.dim() == 1  # batch size 1 for now - could be updated for more but the code would be less clear\n    top_k = min(top_k, logits.size(-1))  # Safety check\n    if top_k > 0:\n        # Remove all tokens with a probability less than the last token of the top-k\n        indices_to_remove = logits < torch.topk(logits, top_k)[0][..., -1, None]\n        logits[indices_to_remove] = filter_value\n\n    if top_p > 0.0:\n        sorted_logits, sorted_indices = torch.sort(logits, descending=True)\n        cumulative_probs = torch.cumsum(F.softmax(sorted_logits, dim=-1), dim=-1)\n\n        # Remove tokens with cumulative probability above the threshold\n        sorted_indices_to_remove = cumulative_probs > top_p\n        # Shift the indices to the right to keep also the first token above the threshold\n        sorted_indices_to_remove[..., 1:] = sorted_indices_to_remove[..., :-1].clone()\n        sorted_indices_to_remove[..., 0] = 0\n\n        indices_to_remove = sorted_indices[sorted_indices_to_remove]\n        logits[indices_to_remove] = filter_value\n    return logits\n\n\ndef sample_sequence(model, context, length, n_ctx, tokenizer, temperature=1.0, top_k=30, top_p=0.0, repitition_penalty=1.0,\n                    device='cpu'):\n    context = torch.tensor(context, dtype=torch.long, device=device)\n    context = context.unsqueeze(0)\n    generated = context\n    with torch.no_grad():\n        for _ in trange(length):\n            inputs = {'input_ids': generated[0][-(n_ctx - 1):].unsqueeze(0)}\n            outputs = model(\n                **inputs)  # Note: we could also use 'past' with GPT-2/Transfo-XL/XLNet (cached hidden-states)\n            next_token_logits = outputs[0][0, -1, :]\n            for id in set(generated):\n                next_token_logits[id] /= repitition_penalty\n            next_token_logits = next_token_logits / temperature\n            next_token_logits[tokenizer.convert_tokens_to_ids('[UNK]')] = -float('Inf')\n            filtered_logits = top_k_top_p_filtering(next_token_logits, top_k=top_k, top_p=top_p)\n            next_token = torch.multinomial(F.softmax(filtered_logits, dim=-1), num_samples=1)\n            generated = torch.cat((generated, next_token.unsqueeze(0)), dim=1)\n    return generated\n\n\ndef main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--device', default='0,1,2,3', type=str, required=False, help='设置使用哪些显卡')\n    parser.add_argument('--length', default=-1, type=int, required=False, help='生成长度')\n    parser.add_argument('--temperature', default=1, type=float, required=False, help='生成温度，越高越随机')\n    parser.add_argument('--topk', default=8, type=int, required=False, help='生成的时候最高几选一')\n    parser.add_argument('--topp', default=0, type=float, required=False, help='生成的时候积累概率最高多少')\n    parser.add_argument('--model_config', default='config/model_config_small.json', type=str, required=False,\n                        help='模型参数路径')\n    parser.add_argument('--tokenizer_path', default='cache/vocab_small.txt', type=str, required=False, help='词表路径')\n    parser.add_argument('--model_path', default='model/final_model', type=str, required=False, help='模型路径')\n    parser.add_argument('--save_path', default='generated/', type=str, required=False, help='存放生成的文件的路径')\n    parser.add_argument('--articles_per_title', default=5, type=int, required=False, help='每个标题生成多少篇文章')\n    parser.add_argument('--titles', default='萧炎', type=str, required=False, help='标题列表，是一个字符串，用空格分开')\n    parser.add_argument('--titles_file', default='', type=str, required=False,\n                        help='标题列表文件，文件中每行一个标题。如果这个选项有值则titles无效')\n    parser.add_argument('--no_wordpiece', action='store_true', help='不做word piece切词')\n    parser.add_argument('--segment', action='store_true', help='中文以词为单位')\n    parser.add_argument('--repetition_penalty', default=1.0, type=float, required=False)\n\n    args = parser.parse_args()\n    print('args:\\n' + args.__repr__())\n\n    if args.segment:\n        from tokenizations import tokenization_bert_word_level as tokenization_bert\n    else:\n        from tokenizations import tokenization_bert\n\n    os.environ[\"CUDA_VISIBLE_DEVICES\"] = args.device  # 此处设置程序使用哪些显卡\n    length = args.length\n    temperature = args.temperature\n    topk = args.topk\n    topp = args.topp\n    repetition_penalty = args.repetition_penalty\n\n    titles = args.titles.split()  # 列表，里面每个元素是一个生成的标题\n    if args.titles_file:\n        with open(args.titles_file, 'r') as f:\n            titles = [line.strip('\\n') for line in f.readlines()]\n    articles_per_title = args.articles_per_title  # 这里定义一个标题生成多少篇文章\n    save_path = args.save_path  # 设置存到哪\n\n    device = \"cuda\" if torch.cuda.is_available() else \"cpu\"\n\n    tokenizer = tokenization_bert.BertTokenizer(vocab_file=args.tokenizer_path)\n    model = GPT2LMHeadModel.from_pretrained(args.model_path)\n    model.to(device)\n    model.eval()\n\n    n_ctx = model.config.n_ctx\n\n    if not os.path.exists(save_path):\n        os.mkdir(save_path)\n    if length == -1:\n        length = model.config.n_ctx\n\n    for i, title in enumerate(titles):\n        for j in range(articles_per_title):\n            with open(save_path + str(i) + '-' + str(j) + '.txt', 'w') as f:\n                context_tokens = tokenizer.convert_tokens_to_ids(tokenizer.tokenize(title))\n                generated = 0\n                out = sample_sequence(\n                    n_ctx=n_ctx,\n                    model=model, length=length,\n                    context=context_tokens, tokenizer=tokenizer,\n                    temperature=temperature, top_k=topk, top_p=topp, repitition_penalty=repetition_penalty,\n                    device=device\n                )\n                out = out.tolist()[0]\n\n                generated += 1\n                text = tokenizer.convert_ids_to_tokens(out)\n\n                for i, item in enumerate(text[:-1]):  # 确保英文前后有空格\n                    if is_word(item) and is_word(text[i + 1]):\n                        text[i] = item + ' '\n\n                for i, item in enumerate(text):\n                    if item == '[MASK]':\n                        text[i] = ''\n                    if item == '[CLS]' or item == '[SEP]':\n                        text[i] = '\\n'\n\n                print(\"=\" * 40 + \" SAMPLE \" + str(generated) + \" \" + \"=\" * 40)\n                text = ''.join(text).replace('##', '').strip()\n                # text = ''.join(text.split('\\n')[:-1])\n                print(text)\n                f.write(text + '\\n')\n                print(\"=\" * 80)\n\n\nif __name__ == '__main__':\n    main()\n"
        },
        {
          "name": "requirements.txt",
          "type": "blob",
          "size": 0.07421875,
          "content": "transformers==2.1.1\ntorch\nnumpy\ntqdm\nsklearn\nkeras\ntb-nightly\nfuture\nthulac\n"
        },
        {
          "name": "sample",
          "type": "tree",
          "content": null
        },
        {
          "name": "scripts",
          "type": "tree",
          "content": null
        },
        {
          "name": "tokenizations",
          "type": "tree",
          "content": null
        },
        {
          "name": "train.json",
          "type": "blob",
          "size": 0.08203125,
          "content": "[\"第一篇文章的正文\", \"第二篇文章的正文\", \"第三篇文章的正文\"]"
        },
        {
          "name": "train.py",
          "type": "blob",
          "size": 12.078125,
          "content": "import transformers\nimport torch\nimport os\nimport json\nimport random\nimport numpy as np\nimport argparse\nfrom torch.utils.tensorboard import SummaryWriter\nfrom datetime import datetime\nfrom tqdm import tqdm\nfrom torch.nn import DataParallel\nfrom tokenizations.bpe_tokenizer import get_encoder\n\n\ndef build_files(data_path, tokenized_data_path, num_pieces, full_tokenizer, min_length):\n    with open(data_path, 'r', encoding='utf8') as f:\n        print('reading lines')\n        lines = json.load(f)\n        lines = [line.replace('\\n', ' [SEP] ') for line in lines]  # 用[SEP]表示换行, 段落之间使用SEP表示段落结束\n    all_len = len(lines)\n    if not os.path.exists(tokenized_data_path):\n        os.mkdir(tokenized_data_path)\n    for i in tqdm(range(num_pieces)):\n        sublines = lines[all_len // num_pieces * i: all_len // num_pieces * (i + 1)]\n        if i == num_pieces - 1:\n            sublines.extend(lines[all_len // num_pieces * (i + 1):])  # 把尾部例子添加到最后一个piece\n        sublines = [full_tokenizer.tokenize(line) for line in sublines if\n                    len(line) > min_length]  # 只考虑长度超过min_length的句子\n        sublines = [full_tokenizer.convert_tokens_to_ids(line) for line in sublines]\n        full_line = []\n        for subline in sublines:\n            full_line.append(full_tokenizer.convert_tokens_to_ids('[MASK]'))  # 文章开头添加MASK表示文章开始\n            full_line.extend(subline)\n            full_line.append(full_tokenizer.convert_tokens_to_ids('[CLS]'))  # 文章之间添加CLS表示文章结束\n        with open(tokenized_data_path + 'tokenized_train_{}.txt'.format(i), 'w') as f:\n            for id in full_line:\n                f.write(str(id) + ' ')\n    print('finish')\n\n\ndef main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--device', default='0,1,2,3', type=str, required=False, help='设置使用哪些显卡')\n    parser.add_argument('--model_config', default='config/model_config_small.json', type=str, required=False,\n                        help='选择模型参数')\n    parser.add_argument('--tokenizer_path', default='cache/vocab_small.txt', type=str, required=False, help='选择词库')\n    parser.add_argument('--raw_data_path', default='data/train.json', type=str, required=False, help='原始训练语料')\n    parser.add_argument('--tokenized_data_path', default='data/tokenized/', type=str, required=False,\n                        help='tokenized语料存放位置')\n    parser.add_argument('--raw', action='store_true', help='是否先做tokenize')\n    parser.add_argument('--epochs', default=5, type=int, required=False, help='训练循环')\n    parser.add_argument('--batch_size', default=8, type=int, required=False, help='训练batch size')\n    parser.add_argument('--lr', default=1.5e-4, type=float, required=False, help='学习率')\n    parser.add_argument('--warmup_steps', default=2000, type=int, required=False, help='warm up步数')\n    parser.add_argument('--log_step', default=1, type=int, required=False, help='多少步汇报一次loss，设置为gradient accumulation的整数倍')\n    parser.add_argument('--stride', default=768, type=int, required=False, help='训练时取训练数据的窗口步长')\n    parser.add_argument('--gradient_accumulation', default=1, type=int, required=False, help='梯度积累')\n    parser.add_argument('--fp16', action='store_true', help='混合精度')\n    parser.add_argument('--fp16_opt_level', default='O1', type=str, required=False)\n    parser.add_argument('--max_grad_norm', default=1.0, type=float, required=False)\n    parser.add_argument('--num_pieces', default=100, type=int, required=False, help='将训练语料分成多少份')\n    parser.add_argument('--min_length', default=128, type=int, required=False, help='最短收录文章长度')\n    parser.add_argument('--output_dir', default='model/', type=str, required=False, help='模型输出路径')\n    parser.add_argument('--pretrained_model', default='', type=str, required=False, help='模型训练起点路径')\n    parser.add_argument('--writer_dir', default='tensorboard_summary/', type=str, required=False, help='Tensorboard路径')\n    parser.add_argument('--segment', action='store_true', help='中文以词为单位')\n    parser.add_argument('--bpe_token', action='store_true', help='subword')\n    parser.add_argument('--encoder_json', default=\"tokenizations/encoder.json\", type=str, help=\"encoder.json\")\n    parser.add_argument('--vocab_bpe', default=\"tokenizations/vocab.bpe\", type=str, help=\"vocab.bpe\")\n\n    args = parser.parse_args()\n    print('args:\\n' + args.__repr__())\n\n    if args.segment:\n        from tokenizations import tokenization_bert_word_level as tokenization_bert\n    else:\n        from tokenizations import tokenization_bert\n\n    os.environ[\"CUDA_VISIBLE_DEVICES\"] = args.device  # 此处设置程序使用哪些显卡\n\n    model_config = transformers.modeling_gpt2.GPT2Config.from_json_file(args.model_config)\n    print('config:\\n' + model_config.to_json_string())\n\n    n_ctx = model_config.n_ctx\n    if args.bpe_token:\n        full_tokenizer = get_encoder(args.encoder_json, args.vocab_bpe)\n    else:\n        full_tokenizer = tokenization_bert.BertTokenizer(vocab_file=args.tokenizer_path)\n    full_tokenizer.max_len = 999999\n    device = 'cuda' if torch.cuda.is_available() else 'cpu'\n    print('using device:', device)\n\n    raw_data_path = args.raw_data_path\n    tokenized_data_path = args.tokenized_data_path\n    raw = args.raw  # 选择是否从零开始构建数据集\n    epochs = args.epochs\n    batch_size = args.batch_size\n    lr = args.lr\n    warmup_steps = args.warmup_steps\n    log_step = args.log_step\n    stride = args.stride\n    gradient_accumulation = args.gradient_accumulation\n    fp16 = args.fp16  # 不支持半精度的显卡请勿打开\n    fp16_opt_level = args.fp16_opt_level\n    max_grad_norm = args.max_grad_norm\n    num_pieces = args.num_pieces\n    min_length = args.min_length\n    output_dir = args.output_dir\n    tb_writer = SummaryWriter(log_dir=args.writer_dir)\n    assert log_step % gradient_accumulation == 0\n\n    if not os.path.exists(output_dir):\n        os.mkdir(output_dir)\n\n    if raw:\n        print('building files')\n        build_files(data_path=raw_data_path, tokenized_data_path=tokenized_data_path, num_pieces=num_pieces,\n                    full_tokenizer=full_tokenizer, min_length=min_length)\n        print('files built')\n\n    if not args.pretrained_model:\n        model = transformers.modeling_gpt2.GPT2LMHeadModel(config=model_config)\n    else:\n        model = transformers.modeling_gpt2.GPT2LMHeadModel.from_pretrained(args.pretrained_model)\n    model.train()\n    model.to(device)\n\n    num_parameters = 0\n    parameters = model.parameters()\n    for parameter in parameters:\n        num_parameters += parameter.numel()\n    print('number of parameters: {}'.format(num_parameters))\n\n    multi_gpu = False\n    full_len = 0\n    print('calculating total steps')\n    for i in tqdm(range(num_pieces)):\n        with open(tokenized_data_path + 'tokenized_train_{}.txt'.format(i), 'r') as f:\n            full_len += len([int(item) for item in f.read().strip().split()])\n    total_steps = int(full_len / stride * epochs / batch_size / gradient_accumulation)\n    print('total steps = {}'.format(total_steps))\n\n    optimizer = transformers.AdamW(model.parameters(), lr=lr, correct_bias=True)\n    scheduler = transformers.WarmupLinearSchedule(optimizer, warmup_steps=warmup_steps,\n                                                          t_total=total_steps)\n    if fp16:\n        try:\n            from apex import amp\n        except ImportError:\n            raise ImportError(\"Please install apex from https://www.github.com/nvidia/apex to use fp16 training.\")\n        model, optimizer = amp.initialize(model, optimizer, opt_level=fp16_opt_level)\n\n    if torch.cuda.device_count() > 1:\n        print(\"Let's use\", torch.cuda.device_count(), \"GPUs!\")\n        model = DataParallel(model, device_ids=[int(i) for i in args.device.split(',')])\n        multi_gpu = True\n    print('starting training')\n    overall_step = 0\n    running_loss = 0\n    for epoch in range(epochs):\n        print('epoch {}'.format(epoch + 1))\n        now = datetime.now()\n        print('time: {}'.format(now))\n        x = np.linspace(0, num_pieces - 1, num_pieces, dtype=np.int32)\n        random.shuffle(x)\n        piece_num = 0\n        for i in x:\n            with open(tokenized_data_path + 'tokenized_train_{}.txt'.format(i), 'r') as f:\n                line = f.read().strip()\n            tokens = line.split()\n            tokens = [int(token) for token in tokens]\n            start_point = 0\n            samples = []\n            while start_point < len(tokens) - n_ctx:\n                samples.append(tokens[start_point: start_point + n_ctx])\n                start_point += stride\n            if start_point < len(tokens):\n                samples.append(tokens[len(tokens)-n_ctx:])\n            random.shuffle(samples)\n            for step in range(len(samples) // batch_size):  # drop last\n\n                #  prepare data\n                batch = samples[step * batch_size: (step + 1) * batch_size]\n                batch_inputs = []\n                for ids in batch:\n                    int_ids = [int(x) for x in ids]\n                    batch_inputs.append(int_ids)\n                batch_inputs = torch.tensor(batch_inputs).long().to(device)\n\n                #  forward pass\n                outputs = model.forward(input_ids=batch_inputs, labels=batch_inputs)\n                loss, logits = outputs[:2]\n\n                #  get loss\n                if multi_gpu:\n                    loss = loss.mean()\n                if gradient_accumulation > 1:\n                    loss = loss / gradient_accumulation\n\n                #  loss backward\n                if fp16:\n                    with amp.scale_loss(loss, optimizer) as scaled_loss:\n                        scaled_loss.backward()\n                        torch.nn.utils.clip_grad_norm_(amp.master_params(optimizer), max_grad_norm)\n                else:\n                    loss.backward()\n                    torch.nn.utils.clip_grad_norm_(model.parameters(), max_grad_norm)\n\n                #  optimizer step\n                if (overall_step + 1) % gradient_accumulation == 0:\n                    running_loss += loss.item()\n                    optimizer.step()\n                    optimizer.zero_grad()\n                    scheduler.step()\n                if (overall_step + 1) % log_step == 0:\n                    tb_writer.add_scalar('loss', loss.item() * gradient_accumulation, overall_step)\n                    print('now time: {}:{}. Step {} of piece {} of epoch {}, loss {}'.format(\n                        datetime.now().hour,\n                        datetime.now().minute,\n                        step + 1,\n                        piece_num,\n                        epoch + 1,\n                        running_loss * gradient_accumulation / (log_step / gradient_accumulation)))\n                    running_loss = 0\n                overall_step += 1\n            piece_num += 1\n\n        print('saving model for epoch {}'.format(epoch + 1))\n        if not os.path.exists(output_dir + 'model_epoch{}'.format(epoch + 1)):\n            os.mkdir(output_dir + 'model_epoch{}'.format(epoch + 1))\n        model_to_save = model.module if hasattr(model, 'module') else model\n        model_to_save.save_pretrained(output_dir + 'model_epoch{}'.format(epoch + 1))\n        # torch.save(scheduler.state_dict(), output_dir + 'model_epoch{}/scheduler.pt'.format(epoch + 1))\n        # torch.save(optimizer.state_dict(), output_dir + 'model_epoch{}/optimizer.pt'.format(epoch + 1))\n        print('epoch {} finished'.format(epoch + 1))\n\n        then = datetime.now()\n        print('time: {}'.format(then))\n        print('time for one epoch: {}'.format(then - now))\n\n    print('training finished')\n    if not os.path.exists(output_dir + 'final_model'):\n        os.mkdir(output_dir + 'final_model')\n    model_to_save = model.module if hasattr(model, 'module') else model\n    model_to_save.save_pretrained(output_dir + 'final_model')\n    # torch.save(scheduler.state_dict(), output_dir + 'final_model/scheduler.pt')\n    # torch.save(optimizer.state_dict(), output_dir + 'final_model/optimizer.pt')\n\n\nif __name__ == '__main__':\n    main()\n"
        },
        {
          "name": "train_single.py",
          "type": "blob",
          "size": 10.4482421875,
          "content": "import transformers\nimport torch\nimport os\nimport json\nimport random\nimport argparse\nimport numpy as np\nfrom datetime import datetime\nfrom torch.nn import DataParallel\nfrom tqdm import tqdm\n\n'''\n如果训练材料是全部堆在一起不分篇章的话用这个文件\n'''\n\n\ndef build_files(raw_data_path, tokenized_data_path, full_tokenizer, num_pieces):\n    with open(raw_data_path, 'r', encoding='utf8') as f:\n        print('reading lines')\n        lines = json.load(f)\n        lines = [line.replace('\\n', ' [SEP] ') for line in lines]  # 用[SEP]表示换行, 段落之间使用SEP表示段落结束\n    single = ''.join(lines)\n    len_single = len(single)\n    if not os.path.exists(tokenized_data_path):\n        os.mkdir(tokenized_data_path)\n    for i in tqdm(range(num_pieces)):\n        single_ids = full_tokenizer.convert_tokens_to_ids(\n            full_tokenizer.tokenize(single[len_single // num_pieces * i: len_single // num_pieces * (i + 1)]))\n        with open(tokenized_data_path + 'tokenized_train_{}.txt'.format(i), 'w') as f:\n            for id in single_ids[:-1]:\n                f.write(str(id) + ' ')\n            f.write(str(single_ids[-1]))\n            f.write('\\n')\n\n    print('finish')\n\n\ndef main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--device', default='0,1,2,3', type=str, required=False, help='设置使用哪些显卡')\n    parser.add_argument('--model_config', default='config/model_config_small.json', type=str, required=False,\n                        help='选择模型参数')\n    parser.add_argument('--tokenizer_path', default='cache/vocab_small.txt', type=str, required=False, help='选择词库')\n    parser.add_argument('--raw_data_path', default='data/train.json', type=str, required=False, help='原始训练语料')\n    parser.add_argument('--tokenized_data_path', default='data/tokenized/', type=str, required=False,\n                        help='tokenized语料存放位置')\n    parser.add_argument('--raw', action='store_true', help='是否先做tokenize')\n    parser.add_argument('--epochs', default=5, type=int, required=False, help='训练循环')\n    parser.add_argument('--batch_size', default=8, type=int, required=False, help='训练batch size')\n    parser.add_argument('--lr', default=1.5e-4, type=float, required=False, help='学习率')\n    parser.add_argument('--warmup_steps', default=2000, type=int, required=False, help='warm up步数')\n    parser.add_argument('--log_step', default=1, type=int, required=False, help='多少步汇报一次loss')\n    parser.add_argument('--stride', default=768, type=int, required=False, help='训练时取训练数据的窗口步长')\n    parser.add_argument('--gradient_accumulation', default=1, type=int, required=False, help='梯度积累')\n    parser.add_argument('--fp16', action='store_true', help='混合精度')\n    parser.add_argument('--fp16_opt_level', default='O1', type=str, required=False)\n    parser.add_argument('--max_grad_norm', default=1.0, type=float, required=False)\n    parser.add_argument('--num_pieces', default=100, type=int, required=False, help='将训练语料分成多少份')\n    parser.add_argument('--output_dir', default='model/', type=str, required=False, help='模型输出路径')\n    parser.add_argument('--pretrained_model', default='', type=str, required=False, help='模型训练起点路径')\n    parser.add_argument('--segment', action='store_true', help='中文以词为单位')\n\n    args = parser.parse_args()\n    print('args:\\n' + args.__repr__())\n\n    if args.segment:\n        from tokenizations import tokenization_bert_word_level as tokenization_bert\n    else:\n        from tokenizations import tokenization_bert\n\n    os.environ[\"CUDA_VISIBLE_DEVICES\"] = args.device  # 此处设置程序使用哪些显卡\n    model_config = transformers.modeling_gpt2.GPT2Config.from_json_file(args.model_config)\n    print('config:\\n' + model_config.to_json_string())\n\n    n_ctx = model_config.n_ctx\n    full_tokenizer = tokenization_bert.BertTokenizer(vocab_file=args.tokenizer_path)\n    full_tokenizer.max_len = 999999\n    device = 'cuda' if torch.cuda.is_available() else 'cpu'\n    print('using device:', device)\n\n    raw_data_path = args.raw_data_path\n    tokenized_data_path = args.tokenized_data_path\n    raw = args.raw  # 选择是否从零开始构建数据集\n    epochs = args.epochs\n    batch_size = args.batch_size\n    lr = args.lr\n    warmup_steps = args.warmup_steps\n    log_step = args.log_step\n    stride = args.stride\n    gradient_accumulation = args.gradient_accumulation\n    fp16 = args.fp16  # 不支持半精度的显卡请勿打开\n    fp16_opt_level = args.fp16_opt_level\n    max_grad_norm = args.max_grad_norm\n    num_pieces = args.num_pieces\n    output_dir = args.output_dir\n\n    if raw:\n        print('building files')\n        build_files(raw_data_path=raw_data_path, tokenized_data_path=tokenized_data_path, full_tokenizer=full_tokenizer,\n                    num_pieces=num_pieces)\n        print('files built')\n\n    if not args.pretrained_model:\n        model = transformers.modeling_gpt2.GPT2LMHeadModel(config=model_config)\n    else:\n        model = transformers.modeling_gpt2.GPT2LMHeadModel.from_pretrained(args.pretrained_model)\n    model.train()\n    model.to(device)\n    multi_gpu = False\n    full_len = 0\n    print('calculating total steps')\n    for i in tqdm(range(num_pieces)):\n        with open(tokenized_data_path + 'tokenized_train_{}.txt'.format(i), 'r') as f:\n            full_len += len([int(item) for item in f.read().strip().split()])\n    total_steps = int(full_len / stride * epochs / batch_size / gradient_accumulation)\n    print('total steps = {}'.format(total_steps))\n\n    optimizer = transformers.AdamW(model.parameters(), lr=lr, correct_bias=True)\n    scheduler = transformers.WarmupLinearSchedule(optimizer, warmup_steps=warmup_steps,\n                                                          t_total=total_steps)\n    if fp16:\n        try:\n            from apex import amp\n        except ImportError:\n            raise ImportError(\"Please install apex from https://www.github.com/nvidia/apex to use fp16 training.\")\n        model, optimizer = amp.initialize(model, optimizer, opt_level=fp16_opt_level)\n\n    if torch.cuda.device_count() > 1:\n        print(\"Let's use\", torch.cuda.device_count(), \"GPUs!\")\n        model = DataParallel(model)\n        multi_gpu = True\n    print('starting training')\n    running_loss = 0\n    for epoch in range(epochs):\n        print('epoch {}'.format(epoch + 1))\n        now = datetime.now()\n        print('time: {}'.format(now))\n        x = np.linspace(0, num_pieces - 1, num_pieces, dtype=np.int32)\n        random.shuffle(x)\n        piece_num = 0\n        for i in x:\n            with open(tokenized_data_path + 'tokenized_train_{}.txt'.format(i), 'r') as f:\n                line = f.read().strip()\n            tokens = line.split()\n            tokens = [int(token) for token in tokens]\n            start_point = 0\n            samples = []\n            while start_point < len(tokens) - n_ctx:\n                samples.append(tokens[start_point: start_point + n_ctx])\n                start_point += stride\n            if start_point < len(tokens):\n                samples.append(tokens[len(tokens)-n_ctx:])\n            random.shuffle(samples)\n            for step in range(len(samples) // batch_size):\n\n                #  prepare data\n                batch = samples[step * batch_size: (step + 1) * batch_size]\n                batch_labels = []\n                batch_inputs = []\n                for ids in batch:\n                    int_ids_for_labels = [int(x) for x in ids]\n                    int_ids_for_inputs = [int(x) for x in ids]\n                    batch_labels.append(int_ids_for_labels)\n                    batch_inputs.append(int_ids_for_inputs)\n                batch_labels = torch.tensor(batch_labels).long().to(device)\n                batch_inputs = torch.tensor(batch_inputs).long().to(device)\n\n                #  forward pass\n                outputs = model.forward(input_ids=batch_inputs, labels=batch_labels)\n                loss, logits = outputs[:2]\n\n                #  get loss\n                if multi_gpu:\n                    loss = loss.mean()\n                if gradient_accumulation > 1:\n                    loss = loss / gradient_accumulation\n\n                #  loss backward\n                if fp16:\n                    with amp.scale_loss(loss, optimizer) as scaled_loss:\n                        scaled_loss.backward()\n                        torch.nn.utils.clip_grad_norm_(amp.master_params(optimizer), max_grad_norm)\n                else:\n                    loss.backward()\n                    torch.nn.utils.clip_grad_norm_(model.parameters(), max_grad_norm)\n\n                #  optimizer step\n                if (step + 1) % gradient_accumulation == 0:\n                    running_loss += loss.item()\n                    optimizer.step()\n                    optimizer.zero_grad()\n                    scheduler.step()\n                if (step + 1) % log_step == 0:\n                    print('now time: {}:{}. Step {} of piece {} of epoch {}, loss {}'.format(\n                        datetime.now().hour,\n                        datetime.now().minute,\n                        (step + 1) // gradient_accumulation,\n                        piece_num,\n                        epoch + 1,\n                        running_loss / log_step))\n                    running_loss = 0\n            piece_num += 1\n\n        print('saving model for epoch {}'.format(epoch + 1))\n        if not os.path.exists(output_dir + 'model_epoch{}'.format(epoch + 1)):\n            os.mkdir(output_dir + 'model_epoch{}'.format(epoch + 1))\n        model_to_save = model.module if hasattr(model, 'module') else model\n        model_to_save.save_pretrained(output_dir + 'model_epoch{}'.format(epoch + 1))\n        # torch.save(scheduler.state_dict(), output_dir + 'model_epoch{}/scheduler.pt'.format(epoch + 1))\n        # torch.save(optimizer.state_dict(), output_dir + 'model_epoch{}/optimizer.pt'.format(epoch + 1))\n        print('epoch {} finished'.format(epoch + 1))\n\n        then = datetime.now()\n        print('time: {}'.format(then))\n        print('time for one epoch: {}'.format(then - now))\n\n    print('training finished')\n    if not os.path.exists(output_dir + 'final_model'):\n        os.mkdir(output_dir + 'final_model')\n    model_to_save = model.module if hasattr(model, 'module') else model\n    model_to_save.save_pretrained(output_dir + 'final_model')\n    # torch.save(scheduler.state_dict(), output_dir + 'final_model/scheduler.pt')\n    # torch.save(optimizer.state_dict(), output_dir + 'final_model/optimizer.pt')\n\n\nif __name__ == '__main__':\n    main()\n"
        }
      ]
    }
  ]
}