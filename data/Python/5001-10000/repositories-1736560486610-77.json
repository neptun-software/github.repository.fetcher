{
  "metadata": {
    "timestamp": 1736560486610,
    "page": 77,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjgw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "facebook/chisel",
      "stars": 9135,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.005859375,
          "content": "*.pyc\n"
        },
        {
          "name": "CODE_OF_CONDUCT.md",
          "type": "blob",
          "size": 0.2353515625,
          "content": "# Code of Conduct\nFacebook has adopted a Code of Conduct that we expect project participants to adhere to. Please [read the full text](https://code.fb.com/codeofconduct) so that you can understand what actions will and will not be tolerated."
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 1.9755859375,
          "content": "# Contributing to Chisel\nWe want to make contributing to this project as easy and transparent as\npossible.\n\n## Pull Requests\nWe actively welcome your pull requests.\n\n1. Fork the repo and create your branch from `master`. \n2. If you've added code that should be tested, add tests\n3. If you've changed APIs, update the documentation. \n4. Ensure the test suite passes. \n5. Make sure your code lints. \n6. If you haven't already, complete the Contributor License Agreement (\"CLA\").\n\n## Contributor License Agreement (\"CLA\")\nIn order to accept your pull request, we need you to submit a CLA. You only need\nto do this once to work on any of Facebook's open source projects.\n\nComplete your CLA here: <https://developers.facebook.com/opensource/cla>\n\n## Issues  \nWe use GitHub issues to track public bugs. Please ensure your description is\nclear and has sufficient instructions to be able to reproduce the issue.\n\nFacebook has a [bounty program](https://www.facebook.com/whitehat/) for the safe\ndisclosure of security bugs. In those cases, please go through the process\noutlined on that page and do not file a public issue.\n\n## Updating Chisel in Brew (for maintainers)\nMost users have Chisel installed via Homebrew. In order to update the version they'll receive when using `brew install` or `brew update`, we have to make some manual changes.\n\n1. Create a new release in the GitHub web interface.\n2. Download the `tar.gz` for that release and run `shasum -a 256 <path>`.\n3. Copy the URL for the `.tar.gz` on the release page.\n\nRun:\n```\nbrew bump-formula-pr --strict chisel \\\n--url=<GitHub .tar.gz URL> \\\n--sha256=<output of shasum>\n```\n\nMore docs on the process are available on the [Homebrew site](https://docs.brew.sh/How-To-Open-a-Homebrew-Pull-Request).\n\nExample PRs:\n- [Bump to 2.0.1](https://github.com/Homebrew/homebrew-core/pull/59799)\n- [Bump to 2.0.0](https://github.com/Homebrew/homebrew-core/pull/50571)\n\n## License\nBy contributing to Chisel, you agree that your contributions will be licensed\nunder its MIT license.\n\n"
        },
        {
          "name": "Chisel",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0595703125,
          "content": "MIT License\n\nCopyright (c) Facebook, Inc. and its affiliates.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE."
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 6.0927734375,
          "content": "<a href=\"https://opensource.facebook.com/support-ukraine\">\n  <img src=\"https://img.shields.io/badge/Support-Ukraine-FFD500?style=flat&labelColor=005BBB\" alt=\"Support Ukraine - Help Provide Humanitarian Aid to Ukraine.\" />\n</a>\n\n# Chisel\n`Chisel` is a collection of `LLDB` commands to assist in the debugging of iOS apps.\n\n[[Installation](#installation) &bull; [Commands](#commands) &bull; [Custom Commands](#custom-commands) &bull; [Development Workflow](#development-workflow) [Contributing](#contributing) &bull; [License](#license)]\n\nFor a comprehensive overview of LLDB, and how Chisel complements it, read Ari Grant's [Dancing in the Debugger â€” A Waltz with LLDB](http://www.objc.io/issue-19/lldb-debugging.html) in issue 19 of [objc.io](http://www.objc.io/).\n\n## Installation\n\n```shell\nbrew update\nbrew install chisel\n```\n\nif `.lldbinit` file doesn't exist you can create it & open it by tapping on the terminal\n\n ```shell\n touch .lldbinit\n open .lldbinit\n```\n\nThen add the following line to your `~/.lldbinit` file.\n\n```Python\n# ~/.lldbinit\n...\ncommand script import /usr/local/opt/chisel/libexec/fbchisellldb.py\n```\n\n* Note that if you are installing on an M1 Mac, the path above should be `/opt/homebrew/opt/chisel/libexec/fbchisellldb.py` instead.\n\nAlternatively, download chisel and add the following line to your _~/.lldbinit_ file.\n\n```Python\n# ~/.lldbinit\n...\ncommand script import /path/to/fbchisellldb.py\n\n```\n\nThe commands will be available the next time `Xcode` starts.\n\n## Commands\nThere are many commands; here's a few:\n*(Compatibility with iOS/Mac indicated at right)*\n\n|Command          |Description     |iOS    |OS X   |\n|-----------------|----------------|-------|-------|\n|pviews           |Print the recursive view description for the key window.|Yes|Yes|\n|pvc              |Print the recursive view controller description for the key window.|Yes|No|\n|visualize        |Open a `UIImage`, `CGImageRef`, `UIView`, `CALayer`, `NSData` (of an image), `UIColor`, `CIColor`, `CIImage`, `CGColorRef` or `CVPixelBuffer` in Preview.app on your Mac.|Yes|No|\n|fv               |Find a view in the hierarchy whose class name matches the provided regex.|Yes|No|\n|fvc              |Find a view controller in the hierarchy whose class name matches the provided regex.|Yes|No|\n|show/hide        |Show or hide the given view or layer. You don't even have to continue the process to see the changes!|Yes|Yes|\n|mask/unmask      |Overlay a view or layer with a transparent rectangle to visualize where it is.|Yes|No|\n|border/unborder  |Add a border to a view or layer to visualize where it is.|Yes|Yes|\n|caflush          |Flush the render server (equivalent to a \"repaint\" if no animations are in-flight).|Yes|Yes|\n|bmessage         |Set a symbolic breakpoint on the method of a class or the method of an instance without worrying which class in the hierarchy actually implements the method.|Yes|Yes|\n|wivar            |Set a watchpoint on an instance variable of an object.|Yes|Yes|\n|presponder       |Print the responder chain starting from the given object.|Yes|Yes|\n|...              |... and many more!|\n\nTo see the list of **all** of the commands execute the help command in `LLDB` or go to the [Wiki](https://github.com/facebook/chisel/wiki).\n\n```Python\n(lldb) help\nThe following is a list of built-in, permanent debugger commands:\n...\n\nThe following is a list of your current user-defined commands:\n...\n```\n\nThe bottom list contains all the commands sourced from `Chisel`.\n\nYou can also inspect a specific command by passing its name as an argument to the help command (as with all other `LLDB` commands).\n\n```\n(lldb) help border\nDraws a border around <viewOrLayer>. Color and width can be optionally provided.\n\nArguments:\n  <viewOrLayer>; Type: UIView*; The view to border.\n\nOptions:\n  --color/-c <color>; Type: string; A color name such as 'red', 'green', 'magenta', etc.\n  --width/-w <width>; Type: CGFloat; Desired width of border.\n\nSyntax: border [--color=color] [--width=width] <viewOrLayer>\n```\n\nAll of the commands provided by `Chisel` come with verbose help. Be sure to read it when in doubt!\n\n## Custom Commands\nYou can add local, custom commands. Here's a contrived example.\n\n```python\n#!/usr/bin/python\n# Example file with custom commands, located at /magical/commands/example.py\n\nimport lldb\nimport fbchisellldbbase as fb\n\ndef lldbcommands():\n  return [ PrintKeyWindowLevel() ]\n\nclass PrintKeyWindowLevel(fb.FBCommand):\n  def name(self):\n    return 'pkeywinlevel'\n\n  def description(self):\n    return 'An incredibly contrived command that prints the window level of the key window.'\n\n  def run(self, arguments, options):\n    # It's a good habit to explicitly cast the type of all return\n    # values and arguments. LLDB can't always find them on its own.\n    lldb.debugger.HandleCommand('p (CGFloat)[(id)[(id)[UIApplication sharedApplication] keyWindow] windowLevel]')\n```\n\nThen all that's left is to source the commands in lldbinit. `Chisel` has a python function just for this, _loadCommandsInDirectory_ in the _fbobjclldb.py_ module.\n\n```Python\n# ~/.lldbinit\n...\ncommand script import /path/to/fbobjclldb.py\nscript fbobjclldb.loadCommandsInDirectory('/magical/commands/')\n\n```\n\nThere's also builtin support to make it super easy to specify the arguments and options that a command takes. See the _border_ and _pinvocation_ commands for example use.\n\n## Development Workflow\nDeveloping commands, whether for local use or contributing to `Chisel` directly, both follow the same workflow. Create a command as described in the [Custom Commands](#custom-commands) section and then\n\n1. Start `LLDB`\n2. Reach a breakpoint (or simply pause execution via the pause button in `Xcode`'s debug bar or `process interrupt` if attached directly)\n3. Execute `command source ~/.lldbinit` in LLDB to source the commands\n4. Run the command you are working on\n5. Modify the command\n6. Optionally run `script reload(modulename)`\n7. Repeat steps 3-6 until the command becomes a source of happiness\n\n## Contributing\nPlease contribute any generic commands that you make. If it helps you then it will likely help many others! :D See `CONTRIBUTING.md` to learn how to contribute.\n\n## License\n`Chisel` is MIT-licensed. See `LICENSE`.\n"
        },
        {
          "name": "commands",
          "type": "tree",
          "content": null
        },
        {
          "name": "fbchisellldb.py",
          "type": "blob",
          "size": 6.654296875,
          "content": "#!/usr/bin/python\n\n# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport imp\nimport os\nfrom contextlib import redirect_stderr, redirect_stdout\nfrom optparse import OptionParser\n\nimport lldb\n\n\ndef __lldb_init_module(debugger, dict):\n    filePath = os.path.realpath(__file__)\n    lldbHelperDir = os.path.dirname(filePath)\n\n    commandsDirectory = os.path.join(lldbHelperDir, \"commands\")\n    loadCommandsInDirectory(commandsDirectory)\n\n\ndef loadCommandsInDirectory(commandsDirectory):\n    for file in os.listdir(commandsDirectory):\n        fileName, fileExtension = os.path.splitext(file)\n        if fileExtension == \".py\":\n            module = imp.load_source(fileName, os.path.join(commandsDirectory, file))\n\n            if hasattr(module, \"lldbinit\"):\n                module.lldbinit()\n\n            if hasattr(module, \"lldbcommands\"):\n                module._loadedFunctions = {}\n                for command in module.lldbcommands():\n                    loadCommand(\n                        module, command, commandsDirectory, fileName, fileExtension\n                    )\n\n\ndef loadCommand(module, command, directory, filename, extension):\n    func = makeRunCommand(command, os.path.join(directory, filename + extension))\n    name = command.name()\n    helpText = (\n        command.description().strip().splitlines()[0]\n    )  # first line of description\n\n    key = filename + \"_\" + name\n\n    module._loadedFunctions[key] = func\n\n    functionName = \"__\" + key\n\n    lldb.debugger.HandleCommand(\n        \"script \"\n        + functionName\n        + \" = sys.modules['\"\n        + module.__name__\n        + \"']._loadedFunctions['\"\n        + key\n        + \"']\"\n    )\n    lldb.debugger.HandleCommand(\n        'command script add --help \"{help}\" --function {function} {name}'.format(\n            help=helpText.replace('\"', '\\\\\"'),  # escape quotes\n            function=functionName,\n            name=name,\n        )\n    )\n\n\ndef makeRunCommand(command, filename):\n    def runCommand(debugger, input, exe_ctx, result, _):\n        # lldb assumes that any output meant for the user is written\n        # to the result object. By redirecting stdout here, we can\n        # use methods like print (or parse_args) in the command logic\n        # as if they are writing to stdout, but write to result\n        # instead. lldb will handle displaying it to the user.\n        with redirect_stdout(result), redirect_stderr(result):\n            command.result = result\n            command.context = exe_ctx\n            splitInput = command.lex(input)\n\n            # OptionParser will throw in the case where you want just one\n            # big long argument and no options and you enter something\n            # that starts with '-' in the argument. e.g.:\n            #     somecommand -[SomeClass someSelector:]\n            # This solves that problem by prepending a '--' so that\n            # OptionParser does the right thing.\n            options = command.options()\n            if len(options) == 0:\n                if \"--\" not in splitInput:\n                    splitInput.insert(0, \"--\")\n\n            parser = optionParserForCommand(command)\n            (options, args) = parser.parse_args(splitInput)\n\n            # When there are more args than the command has declared, assume\n            # the initial args form an expression and combine them into a single arg.\n            if len(args) > len(command.args()):\n                overhead = len(args) - len(command.args())\n                head = args[: overhead + 1]  # Take N+1 and reduce to 1.\n                args = [\" \".join(head)] + args[-overhead:]\n\n            if validateArgsForCommand(args, command):\n                command.run(args, options)\n\n    runCommand.__doc__ = helpForCommand(command, filename)\n    return runCommand\n\n\ndef validateArgsForCommand(args, command):\n    if len(args) < len(command.args()):\n        defaultArgs = [arg.default for arg in command.args()]\n        defaultArgsToAppend = defaultArgs[len(args) :]\n\n        index = len(args)\n        for defaultArg in defaultArgsToAppend:\n            if not defaultArg:\n                arg = command.args()[index]\n                print(\"Whoops! You are missing the <\" + arg.argName + \"> argument.\")\n                print(\"\\nUsage: \" + usageForCommand(command))\n                return\n            index += 1\n\n        args.extend(defaultArgsToAppend)\n    return True\n\n\ndef optionParserForCommand(command):\n    parser = OptionParser()\n\n    for argument in command.options():\n        if argument.boolean:\n            parser.add_option(\n                argument.shortName,\n                argument.longName,\n                dest=argument.argName,\n                help=argument.help,\n                action=(\"store_false\" if argument.default else \"store_true\"),\n            )\n        else:\n            parser.add_option(\n                argument.shortName,\n                argument.longName,\n                dest=argument.argName,\n                help=argument.help,\n                default=argument.default,\n            )\n\n    return parser\n\n\ndef helpForCommand(command, filename):\n    help = command.description()\n\n    argSyntax = \"\"\n    optionSyntax = \"\"\n\n    if command.args():\n        help += \"\\n\\nArguments:\"\n        for arg in command.args():\n            help += \"\\n  <\" + arg.argName + \">; \"\n            if arg.argType:\n                help += \"Type: \" + arg.argType + \"; \"\n            help += arg.help\n            argSyntax += \" <\" + arg.argName + \">\"\n\n    if command.options():\n        help += \"\\n\\nOptions:\"\n        for option in command.options():\n            if option.longName and option.shortName:\n                optionFlag = option.longName + \"/\" + option.shortName\n            elif option.longName:\n                optionFlag = option.longName\n            else:\n                optionFlag = option.shortName\n\n            help += \"\\n  \" + optionFlag + \" \"\n\n            if not option.boolean:\n                help += \"<\" + option.argName + \">; Type: \" + option.argType\n\n            help += \"; \" + option.help\n\n            optionSyntax += \" [{name}{arg}]\".format(\n                name=(option.longName or option.shortName),\n                arg=(\"\" if option.boolean else (\"=\" + option.argName)),\n            )\n\n    help += \"\\n\\nSyntax: \" + command.name() + optionSyntax + argSyntax\n\n    help += \"\\n\\nThis command is implemented as %s in %s.\" % (\n        command.__class__.__name__,\n        filename,\n    )\n\n    return help\n\n\ndef usageForCommand(command):\n    usage = command.name()\n    for arg in command.args():\n        if arg.default:\n            usage += \" [\" + arg.argName + \"]\"\n        else:\n            usage += \" \" + arg.argName\n\n    return usage\n"
        },
        {
          "name": "fbchisellldbbase.py",
          "type": "blob",
          "size": 7.01171875,
          "content": "#!/usr/bin/python\n\n# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport json\nimport shlex\n\nimport lldb\n\n\nclass FBCommandArgument:  # noqa B903\n    def __init__(\n        self, short=\"\", long=\"\", arg=\"\", type=\"\", help=\"\", default=\"\", boolean=False\n    ):\n        self.shortName = short\n        self.longName = long\n        self.argName = arg\n        self.argType = type\n        self.help = help\n        self.default = default\n        self.boolean = boolean\n\n\nclass FBCommand:\n    def name(self):\n        return None\n\n    def options(self):\n        return []\n\n    def args(self):\n        return []\n\n    def description(self):\n        return \"\"\n\n    def lex(self, commandLine):\n        return shlex.split(commandLine)\n\n    def run(self, arguments, option):\n        pass\n\n\ndef isSuccess(error):\n    # When evaluating a `void` expression, the returned value will indicate an\n    # error. This error is named: kNoResult. This error value does *not* mean\n    # there was a problem. This logic follows what the builtin `expression`\n    # command does. See: https://git.io/vwpjl (UserExpression.h)\n    kNoResult = 0x1001\n    return error.success or error.value == kNoResult\n\n\ndef importModule(frame, module):\n    options = lldb.SBExpressionOptions()\n    options.SetLanguage(lldb.eLanguageTypeObjC)\n    value = frame.EvaluateExpression(\"@import \" + module, options)\n    return isSuccess(value.error)\n\n\n# evaluates expression in Objective-C++ context, so it will work even for\n# Swift projects\ndef evaluateExpressionValue(\n    expression,\n    printErrors=True,\n    language=lldb.eLanguageTypeObjC_plus_plus,\n    tryAllThreads=False,\n):\n    frame = (\n        lldb.debugger.GetSelectedTarget()\n        .GetProcess()\n        .GetSelectedThread()\n        .GetSelectedFrame()\n    )\n    options = lldb.SBExpressionOptions()\n    options.SetLanguage(language)\n\n    # Allow evaluation that contains a @throw/@catch.\n    #   By default, ObjC @throw will cause evaluation to be aborted. At the time\n    #   of a @throw, it's not known if the exception will be handled by a @catch.\n    #   An exception that's caught, should not cause evaluation to fail.\n    options.SetTrapExceptions(False)\n\n    # Give evaluation more time.\n    options.SetTimeoutInMicroSeconds(5000000)  # 5s\n\n    # Most Chisel commands are not multithreaded.\n    options.SetTryAllThreads(tryAllThreads)\n\n    value = frame.EvaluateExpression(expression, options)\n    error = value.GetError()\n\n    # Retry if the error could be resolved by first importing UIKit.\n    if (\n        error.type == lldb.eErrorTypeExpression\n        and error.value == lldb.eExpressionParseError\n        and importModule(frame, \"UIKit\")\n    ):\n        value = frame.EvaluateExpression(expression, options)\n        error = value.GetError()\n\n    if printErrors and not isSuccess(error):\n        print(error)\n\n    return value\n\n\ndef evaluateInputExpression(expression, printErrors=True):\n    # HACK\n    if expression.startswith(\"(id)\"):\n        return evaluateExpressionValue(expression, printErrors=printErrors).GetValue()\n\n    frame = (\n        lldb.debugger.GetSelectedTarget()\n        .GetProcess()\n        .GetSelectedThread()\n        .GetSelectedFrame()\n    )\n    options = lldb.SBExpressionOptions()\n    options.SetTrapExceptions(False)\n    value = frame.EvaluateExpression(expression, options)\n    error = value.GetError()\n\n    if printErrors and error.Fail():\n        print(error)\n\n    return value.GetValue()\n\n\ndef evaluateIntegerExpression(expression, printErrors=True):\n    output = evaluateExpression(\"(int)(\" + expression + \")\", printErrors).replace(\n        \"'\", \"\"\n    )\n    if output.startswith(\"\\\\x\"):  # Booleans may display as \\x01 (Hex)\n        output = output[2:]\n    elif output.startswith(\"\\\\\"):  # Or as \\0 (Dec)\n        output = output[1:]\n    return int(output, 0)\n\n\ndef evaluateBooleanExpression(expression, printErrors=True):\n    return (\n        int(evaluateIntegerExpression(\"(BOOL)(\" + expression + \")\", printErrors)) != 0\n    )\n\n\ndef evaluateExpression(expression, printErrors=True):\n    return evaluateExpressionValue(expression, printErrors=printErrors).GetValue()\n\n\ndef describeObject(expression, printErrors=True):\n    return evaluateExpressionValue(\n        \"(id)(\" + expression + \")\", printErrors\n    ).GetObjectDescription()\n\n\ndef evaluateEffect(expression, printErrors=True):\n    evaluateExpressionValue(\"(void)(\" + expression + \")\", printErrors=printErrors)\n\n\ndef evaluateObjectExpression(expression, printErrors=True):\n    return evaluateExpression(\"(id)(\" + expression + \")\", printErrors)\n\n\ndef evaluateCStringExpression(expression, printErrors=True):\n    ret = evaluateExpression(expression, printErrors)\n\n    process = lldb.debugger.GetSelectedTarget().GetProcess()\n    error = lldb.SBError()\n    ret = process.ReadCStringFromMemory(int(ret, 16), 256, error)\n    if error.Success():\n        return ret\n    else:\n        if printErrors:\n            print(error)\n        return None\n\n\nRETURN_MACRO = \"\"\"\n#define IS_JSON_OBJ(obj)\\\n    (obj != nil && ((bool)[NSJSONSerialization isValidJSONObject:obj] ||\\\n    (bool)[obj isKindOfClass:[NSString class]] ||\\\n    (bool)[obj isKindOfClass:[NSNumber class]]))\n#define RETURN(ret) ({\\\n    if (!IS_JSON_OBJ(ret)) {\\\n        (void)[NSException raise:@\"Invalid RETURN argument\" format:@\"\"];\\\n    }\\\n    NSDictionary *__dict = @{@\"return\":ret};\\\n    NSData *__data = (id)[NSJSONSerialization dataWithJSONObject:__dict options:0 error:NULL];\\\n    NSString *__str = (id)[[NSString alloc] initWithData:__data encoding:4];\\\n    (char *)[__str UTF8String];})\n#define RETURNCString(ret)\\\n    ({NSString *___cstring_ret = [NSString stringWithUTF8String:ret];\\\n    RETURN(___cstring_ret);})\n\"\"\"\n\n\ndef check_expr(expr):\n    return expr.strip().split(\";\")[-2].find(\"RETURN\") != -1\n\n\n# evaluate a batch of Objective-C expressions, the last expression\n# must contain a RETURN marco and it will automatic transform the\n# Objective-C object to Python object\n# Example:\n#       >>> fbchisellldbbase.evaluate('NSString *str = @\"hello world\"; RETURN(@{@\"key\": str});')\n#       {u'key': u'hello world'}\ndef evaluate(expr):\n    if not check_expr(expr):\n        raise Exception(\n            \"Invalid Expression, the last expression not include a RETURN family marco\"\n        )\n\n    command = \"({\" + RETURN_MACRO + \"\\n\" + expr + \"})\"\n    ret = evaluateExpressionValue(command, printErrors=True)\n    if not ret.GetError().Success():\n        print(ret.GetError())\n        return None\n    else:\n        process = lldb.debugger.GetSelectedTarget().GetProcess()\n        error = lldb.SBError()\n        ret = process.ReadCStringFromMemory(int(ret.GetValue(), 16), 2**20, error)\n        if not error.Success():\n            print(error)\n            return None\n        else:\n            ret = json.loads(ret)\n            return ret[\"return\"]\n\n\ndef currentLanguage():\n    return (\n        lldb.debugger.GetSelectedTarget()\n        .GetProcess()\n        .GetSelectedThread()\n        .GetSelectedFrame()\n        .GetCompileUnit()\n        .GetLanguage()\n    )\n"
        },
        {
          "name": "fbchisellldbinputhelpers.py",
          "type": "blob",
          "size": 1.068359375,
          "content": "#!/usr/bin/python\n\n# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport lldb\n\n\nclass FBInputHandler:\n    def __init__(self, debugger, callback):\n        self.debugger = debugger\n        self.callback = callback\n        self.inputReader = lldb.SBInputReader()\n        self.inputReader.Initialize(\n            debugger,\n            self.handleInput,\n            lldb.eInputReaderGranularityLine,\n            None,\n            None,  # prompt\n            True,  # echo\n        )\n\n    def isValid(self):\n        return not self.inputReader.IsDone()\n\n    def start(self):\n        self.debugger.PushInputReader(self.inputReader)\n\n    def stop(self):\n        self.inputReader.SetIsDone(True)\n\n    def handleInput(self, inputReader, notification, bytes):\n        if notification == lldb.eInputReaderGotToken:\n            self.callback(bytes)\n        elif notification == lldb.eInputReaderInterrupt:\n            self.stop()\n\n        return len(bytes)\n"
        },
        {
          "name": "fbchisellldbobjcruntimehelpers.py",
          "type": "blob",
          "size": 3.4267578125,
          "content": "#!/usr/bin/python\n\n# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport re\n\nimport fbchisellldbbase as fb\nimport lldb\n\n\ndef objc_getClass(className):\n    command = '(void*)objc_getClass(\"{}\")'.format(className)\n    value = fb.evaluateExpression(command)\n    return value\n\n\ndef object_getClass(object):\n    command = \"(void*)object_getClass((id){})\".format(object)\n    value = fb.evaluateExpression(command)\n    return value\n\n\ndef class_getName(klass):\n    command = \"(const char*)class_getName((Class){})\".format(klass)\n    value = fb.evaluateExpressionValue(command).GetSummary().strip('\"')\n    return value\n\n\ndef class_getSuperclass(klass):\n    command = \"(void*)class_getSuperclass((Class){})\".format(klass)\n    value = fb.evaluateExpression(command)\n    return value\n\n\ndef class_isMetaClass(klass):\n    command = \"class_isMetaClass((Class){})\".format(klass)\n    return fb.evaluateBooleanExpression(command)\n\n\ndef class_getInstanceMethod(klass, selector):\n    command = \"(void*)class_getInstanceMethod((Class){}, @selector({}))\".format(\n        klass, selector\n    )\n    value = fb.evaluateExpression(command)\n    return value\n\n\ndef currentArch():\n    targetTriple = lldb.debugger.GetSelectedTarget().GetTriple()\n    arch = targetTriple.split(\"-\")[0]\n    if arch == \"x86_64h\":\n        arch = \"x86_64\"\n    return arch\n\n\ndef functionPreambleExpressionForSelf():\n    import re\n\n    arch = currentArch()\n    expressionForSelf = None\n    if arch == \"i386\":\n        expressionForSelf = \"*(id*)($esp+4)\"\n    elif arch == \"x86_64\":\n        expressionForSelf = \"(id)$rdi\"\n    elif arch == \"arm64\":\n        expressionForSelf = \"(id)$x0\"\n    elif re.match(r\"^armv.*$\", arch):\n        expressionForSelf = \"(id)$r0\"\n    return expressionForSelf\n\n\ndef functionPreambleExpressionForObjectParameterAtIndex(parameterIndex):\n    arch = currentArch()\n    expresssion = None\n    if arch == \"i386\":\n        expresssion = \"*(id*)($esp + \" + str(12 + parameterIndex * 4) + \")\"\n    elif arch == \"x86_64\":\n        if parameterIndex > 3:\n            raise Exception(\n                \"Current implementation can not return object at index greater than 3 for x86_64\"\n            )\n        registersList = [\"rdx\", \"rcx\", \"r8\", \"r9\"]\n        expresssion = \"(id)$\" + registersList[parameterIndex]\n    elif arch == \"arm64\":\n        if parameterIndex > 5:\n            raise Exception(\n                \"Current implementation can not return object at index greater than 5 for arm64\"\n            )\n        expresssion = \"(id)$x\" + str(parameterIndex + 2)\n    elif re.match(r\"^armv.*$\", arch):\n        if parameterIndex > 1:\n            raise Exception(\n                \"Current implementation can not return object at index greater than 1 for arm32\"\n            )\n        expresssion = \"(id)$r\" + str(parameterIndex + 2)\n    return expresssion\n\n\ndef isMacintoshArch():\n    arch = currentArch()\n    if not arch == \"x86_64\":\n        return False\n\n    nsClassName = \"NSApplication\"\n    command = '(void*)objc_getClass(\"{}\")'.format(nsClassName)\n\n    return fb.evaluateBooleanExpression(command + \"!= nil\")\n\n\ndef isIOSSimulator():\n    return (\n        fb.evaluateExpressionValue(\"(id)[[UIDevice currentDevice] model]\")\n        .GetObjectDescription()\n        .lower()\n        .find(\"simulator\")\n        >= 0\n    )\n\n\ndef isIOSDevice():\n    return not isMacintoshArch() and not isIOSSimulator()\n"
        },
        {
          "name": "fbchisellldbobjecthelpers.py",
          "type": "blob",
          "size": 0.541015625,
          "content": "#!/usr/bin/python\n\n# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport fbchisellldbbase as fb\n\n\ndef isKindOfClass(obj, className):\n    isKindOfClassStr = \"[(id)\" + obj + \" isKindOfClass:[{} class]]\"\n    return fb.evaluateBooleanExpression(isKindOfClassStr.format(className))\n\n\ndef className(obj):\n    return fb.evaluateExpressionValue(\n        \"(id)[(\" + obj + \") class]\"\n    ).GetObjectDescription()\n"
        },
        {
          "name": "fbchisellldbviewcontrollerhelpers.py",
          "type": "blob",
          "size": 4.21875,
          "content": "#!/usr/bin/python\n\n# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport fbchisellldbbase as fb\nimport fbchisellldbobjcruntimehelpers as runtimeHelpers\n\n\ndef presentViewController(viewController):\n    vc = \"(%s)\" % (viewController)\n\n    if fb.evaluateBooleanExpression(\n        \"%s != nil && ((BOOL)[(id)%s isKindOfClass:(Class)[UIViewController class]])\"\n        % (vc, vc)\n    ):\n        notPresented = fb.evaluateBooleanExpression(\n            \"[%s presentingViewController] == nil\" % vc\n        )\n\n        if notPresented:\n            fb.evaluateEffect(\n                \"[[[[UIApplication sharedApplication] keyWindow] rootViewController] presentViewController:%s animated:YES completion:nil]\"\n                % vc\n            )\n        else:\n            raise Exception(\"Argument is already presented\")\n    else:\n        raise Exception(\"Argument must be a UIViewController\")\n\n\ndef dismissViewController(viewController):\n    vc = \"(%s)\" % (viewController)\n\n    if fb.evaluateBooleanExpression(\n        \"%s != nil && ((BOOL)[(id)%s isKindOfClass:(Class)[UIViewController class]])\"\n        % (vc, vc)\n    ):\n        isPresented = fb.evaluateBooleanExpression(\n            \"[%s presentingViewController] != nil\" % vc\n        )\n\n        if isPresented:\n            fb.evaluateEffect(\n                \"[(UIViewController *)%s dismissViewControllerAnimated:YES completion:nil]\"\n                % vc\n            )\n        else:\n            raise Exception(\"Argument must be presented\")\n    else:\n        raise Exception(\"Argument must be a UIViewController\")\n\n\ndef viewControllerRecursiveDescription(vc):\n    return _recursiveViewControllerDescriptionWithPrefixAndChildPrefix(\n        fb.evaluateObjectExpression(vc), \"\", \"\", \"\"\n    )\n\n\ndef _viewControllerDescription(viewController):\n    vc = \"(%s)\" % (viewController)\n\n    if fb.evaluateBooleanExpression(\"[(id)%s isViewLoaded]\" % (vc)):\n        result = fb.evaluateExpressionValue(\n            '(id)[[NSString alloc] initWithFormat:@\"<%%@: %%p; view = <%%@; %%p>; frame = (%%g, %%g; %%g, %%g)>\", (id)NSStringFromClass((id)[(id)%s class]), %s, (id)[(id)[(id)%s view] class], (id)[(id)%s view], ((CGRect)[(id)[(id)%s view] frame]).origin.x, ((CGRect)[(id)[(id)%s view] frame]).origin.y, ((CGRect)[(id)[(id)%s view] frame]).size.width, ((CGRect)[(id)[(id)%s view] frame]).size.height]'\n            % (vc, vc, vc, vc, vc, vc, vc, vc)\n        )\n    else:\n        result = fb.evaluateExpressionValue(\n            '(id)[[NSString alloc] initWithFormat:@\"<%%@: %%p; view not loaded>\", (id)NSStringFromClass((id)[(id)%s class]), %s]'\n            % (vc, vc)\n        )\n\n    if result.GetError() is not None and str(result.GetError()) != \"success\":\n        return \"[Error getting description.]\"\n    else:\n        return result.GetObjectDescription()\n\n\ndef _recursiveViewControllerDescriptionWithPrefixAndChildPrefix(\n    vc, string, prefix, childPrefix\n):\n    isMac = runtimeHelpers.isMacintoshArch()\n\n    s = \"%s%s%s\\n\" % (\n        prefix,\n        \"\" if prefix == \"\" else \" \",\n        _viewControllerDescription(vc),\n    )\n\n    nextPrefix = childPrefix + \"   |\"\n\n    numChildViewControllers = fb.evaluateIntegerExpression(\n        \"(int)[(id)[%s childViewControllers] count]\" % (vc)\n    )\n\n    for i in range(0, numChildViewControllers):\n        viewController = fb.evaluateExpression(\n            \"(id)[(id)[%s childViewControllers] objectAtIndex:%d]\" % (vc, i)\n        )\n        s += _recursiveViewControllerDescriptionWithPrefixAndChildPrefix(\n            viewController, string, nextPrefix, nextPrefix\n        )\n\n    if not isMac:\n        isModal = fb.evaluateBooleanExpression(\n            \"%s != nil && ((id)[(id)[(id)%s presentedViewController] presentingViewController]) == %s\"\n            % (vc, vc, vc)\n        )\n\n        if isModal:\n            modalVC = fb.evaluateObjectExpression(\n                \"(id)[(id)%s presentedViewController]\" % (vc)\n            )\n            s += _recursiveViewControllerDescriptionWithPrefixAndChildPrefix(\n                modalVC, string, childPrefix + \"  *M\", nextPrefix\n            )\n            s += \"\\n// '*M' means the view controller is presented modally.\"\n\n    return string + s\n"
        },
        {
          "name": "fbchisellldbviewhelpers.py",
          "type": "blob",
          "size": 4.9404296875,
          "content": "#!/usr/bin/python\n\n# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport fbchisellldbbase as fb\nimport fbchisellldbobjcruntimehelpers as runtimeHelpers\n\n\ndef flushCoreAnimationTransaction():\n    fb.evaluateEffect(\"[CATransaction flush]\")\n\n\ndef setViewHidden(object, hidden):\n    fb.evaluateEffect(\"[{} setHidden:{}]\".format(object, int(hidden)))\n    flushCoreAnimationTransaction()\n\n\ndef maskView(viewOrLayer, color, alpha):\n    unmaskView(viewOrLayer)\n    window = fb.evaluateExpression(\n        \"(UIWindow *)[[UIApplication sharedApplication] keyWindow]\"\n    )\n    origin = convertPoint(0, 0, viewOrLayer, window)\n    size = fb.evaluateExpressionValue(\n        \"(CGSize)((CGRect)[(id)%s frame]).size\" % viewOrLayer\n    )\n\n    rectExpr = \"(CGRect){{%s, %s}, {%s, %s}}\" % (\n        origin.GetChildMemberWithName(\"x\").GetValue(),\n        origin.GetChildMemberWithName(\"y\").GetValue(),\n        size.GetChildMemberWithName(\"width\").GetValue(),\n        size.GetChildMemberWithName(\"height\").GetValue(),\n    )\n    mask = fb.evaluateExpression(\"(id)[[UIView alloc] initWithFrame:%s]\" % rectExpr)\n\n    fb.evaluateEffect(\"[%s setTag:(NSInteger)%s]\" % (mask, viewOrLayer))\n    fb.evaluateEffect(\"[%s setBackgroundColor:[UIColor %sColor]]\" % (mask, color))\n    fb.evaluateEffect(\"[%s setAlpha:(CGFloat)%s]\" % (mask, alpha))\n    fb.evaluateEffect(\"[%s addSubview:%s]\" % (window, mask))\n    flushCoreAnimationTransaction()\n\n\ndef unmaskView(viewOrLayer):\n    window = fb.evaluateExpression(\n        \"(UIWindow *)[[UIApplication sharedApplication] keyWindow]\"\n    )\n    mask = fb.evaluateExpression(\n        \"(UIView *)[%s viewWithTag:(NSInteger)%s]\" % (window, viewOrLayer)\n    )\n    fb.evaluateEffect(\"[%s removeFromSuperview]\" % mask)\n    flushCoreAnimationTransaction()\n\n\ndef convertPoint(x, y, fromViewOrLayer, toViewOrLayer):\n    fromLayer = convertToLayer(fromViewOrLayer)\n    toLayer = convertToLayer(toViewOrLayer)\n    return fb.evaluateExpressionValue(\n        \"(CGPoint)[%s convertPoint:(CGPoint){ .x = %s, .y = %s } toLayer:(CALayer *)%s]\"\n        % (fromLayer, x, y, toLayer)\n    )\n\n\ndef convertToLayer(viewOrLayer):\n    if fb.evaluateBooleanExpression(\n        \"[(id)%s isKindOfClass:(Class)[CALayer class]]\" % viewOrLayer\n    ):\n        return viewOrLayer\n    elif fb.evaluateBooleanExpression(\n        \"[(id)%s respondsToSelector:(SEL)@selector(layer)]\" % viewOrLayer\n    ):\n        return fb.evaluateExpression(\"(CALayer *)[%s layer]\" % viewOrLayer)\n    else:\n        raise Exception(\"Argument must be a CALayer, UIView, or NSView.\")\n\n\ndef isUIView(obj):\n    return not runtimeHelpers.isMacintoshArch() and fb.evaluateBooleanExpression(\n        \"[(id)%s isKindOfClass:(Class)[UIView class]]\" % obj\n    )\n\n\ndef isNSView(obj):\n    return runtimeHelpers.isMacintoshArch() and fb.evaluateBooleanExpression(\n        \"[(id)%s isKindOfClass:(Class)[NSView class]]\" % obj\n    )\n\n\ndef isView(obj):\n    return isUIView(obj) or isNSView(obj)\n\n\n# Generates a BFS of the views tree starting at the given view as root.\n# Yields a tuple of the current view in the tree and its level (view, level)\ndef subviewsOfView(view):\n    views = [(view, 0)]\n    yield views[0]\n    while views:\n        (view, level) = views.pop(0)\n        subviews = fb.evaluateExpression(\"(id)[%s subviews]\" % view)\n        subviewsCount = int(fb.evaluateExpression(\"(int)[(id)%s count]\" % subviews))\n        for i in range(subviewsCount):\n            subview = fb.evaluateExpression(\"(id)[%s objectAtIndex:%i]\" % (subviews, i))\n            views.append((subview, level + 1))\n            yield (subview, level + 1)\n\n\ndef upwardsRecursiveDescription(view, maxDepth=0):\n    if not fb.evaluateBooleanExpression(\n        \"[(id)%s isKindOfClass:(Class)[UIView class]]\" % view\n    ) and not fb.evaluateBooleanExpression(\n        \"[(id)%s isKindOfClass:(Class)[NSView class]]\" % view\n    ):\n        return None\n\n    currentView = view\n    recursiveDescription = []\n    depth = 0\n\n    while currentView and (maxDepth <= 0 or depth <= maxDepth):\n        depth += 1\n\n        viewDescription = fb.evaluateExpressionValue(\n            \"(id)[%s debugDescription]\" % (currentView)\n        ).GetObjectDescription()\n        currentView = fb.evaluateExpression(\"(void*)[%s superview]\" % (currentView))\n        try:\n            if int(currentView, 0) == 0:\n                currentView = None\n        except Exception:\n            currentView = None\n\n        if viewDescription:\n            recursiveDescription.insert(0, viewDescription)\n\n    if not len(viewDescription):\n        return None\n\n    currentPrefix = \"\"\n    builder = \"\"\n    for viewDescription in recursiveDescription:\n        builder += currentPrefix + viewDescription + \"\\n\"\n        currentPrefix += \"   | \"\n\n    return builder\n\n\ndef slowAnimation(speed=1):\n    fb.evaluateEffect(\n        '[[[UIApplication sharedApplication] windows] setValue:@(%s) forKeyPath:@\"layer.speed\"]'\n        % speed\n    )\n"
        },
        {
          "name": "fblldb.py",
          "type": "blob",
          "size": 0.0146484375,
          "content": "fbchisellldb.py"
        }
      ]
    }
  ]
}