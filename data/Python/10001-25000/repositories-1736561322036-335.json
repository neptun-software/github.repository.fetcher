{
  "metadata": {
    "timestamp": 1736561322036,
    "page": 335,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM0MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "cyrus-and/gdb-dashboard",
      "stars": 11367,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gdbinit",
          "type": "blob",
          "size": 91.732421875,
          "content": "python\n\n# GDB dashboard - Modular visual interface for GDB in Python.\n#\n# https://github.com/cyrus-and/gdb-dashboard\n\n# License ----------------------------------------------------------------------\n\n# Copyright (c) 2015-2024 Andrea Cardaci <cyrus.and@gmail.com>\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in all\n# copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n# SOFTWARE.\n\n# Imports ----------------------------------------------------------------------\n\nimport ast\nimport io\nimport itertools\nimport math\nimport os\nimport re\nimport struct\nimport traceback\n\n# Common attributes ------------------------------------------------------------\n\nclass R():\n\n    @staticmethod\n    def attributes():\n        return {\n            # miscellaneous\n            'ansi': {\n                'doc': 'Control the ANSI output of the dashboard.',\n                'default': True,\n                'type': bool\n            },\n            'syntax_highlighting': {\n                'doc': '''Pygments style to use for syntax highlighting.\n\nUsing an empty string (or a name not in the list) disables this feature. The\nlist of all the available styles can be obtained with (from GDB itself):\n\n    python from pygments.styles import *\n    python for style in get_all_styles(): print(style)''',\n                'default': 'monokai'\n            },\n            'discard_scrollback': {\n                'doc': '''Discard the scrollback buffer at each redraw.\n\nThis makes scrolling less confusing by discarding the previously printed\ndashboards but only works with certain terminals.''',\n                'default': True,\n                'type': bool\n            },\n            # values formatting\n            'compact_values': {\n                'doc': 'Display complex objects in a single line.',\n                'default': True,\n                'type': bool\n            },\n            'max_value_length': {\n                'doc': 'Maximum length of displayed values before truncation.',\n                'default': 100,\n                'type': int\n            },\n            'value_truncation_string': {\n                'doc': 'String to use to mark value truncation.',\n                'default': '…',\n            },\n            'dereference': {\n                'doc': 'Annotate pointers with the pointed value.',\n                'default': True,\n                'type': bool\n            },\n            # prompt\n            'prompt': {\n                'doc': '''GDB prompt.\n\nThis value is used as a Python format string where `{status}` is expanded with\nthe substitution of either `prompt_running` or `prompt_not_running` attributes,\naccording to the target program status. The resulting string must be a valid GDB\nprompt, see the command `python print(gdb.prompt.prompt_help())`''',\n                'default': '{status}'\n            },\n            'prompt_running': {\n                'doc': '''Define the value of `{status}` when the target program is running.\n\nSee the `prompt` attribute. This value is used as a Python format string where\n`{pid}` is expanded with the process identifier of the target program.''',\n                'default': r'\\[\\e[1;35m\\]>>>\\[\\e[0m\\]'\n            },\n            'prompt_not_running': {\n                'doc': '''Define the value of `{status}` when the target program is running.\n\nSee the `prompt` attribute. This value is used as a Python format string.''',\n                'default': r'\\[\\e[90m\\]>>>\\[\\e[0m\\]'\n            },\n            # divider\n            'omit_divider': {\n                'doc': 'Omit the divider in external outputs when only one module is displayed.',\n                'default': False,\n                'type': bool\n            },\n            'divider_fill_char_primary': {\n                'doc': 'Filler around the label for primary dividers',\n                'default': '─'\n            },\n            'divider_fill_char_secondary': {\n                'doc': 'Filler around the label for secondary dividers',\n                'default': '─'\n            },\n            'divider_fill_style_primary': {\n                'doc': 'Style for `divider_fill_char_primary`',\n                'default': '36'\n            },\n            'divider_fill_style_secondary': {\n                'doc': 'Style for `divider_fill_char_secondary`',\n                'default': '90'\n            },\n            'divider_label_style_on_primary': {\n                'doc': 'Label style for non-empty primary dividers',\n                'default': '1;33'\n            },\n            'divider_label_style_on_secondary': {\n                'doc': 'Label style for non-empty secondary dividers',\n                'default': '1;37'\n            },\n            'divider_label_style_off_primary': {\n                'doc': 'Label style for empty primary dividers',\n                'default': '33'\n            },\n            'divider_label_style_off_secondary': {\n                'doc': 'Label style for empty secondary dividers',\n                'default': '90'\n            },\n            'divider_label_skip': {\n                'doc': 'Gap between the aligning border and the label.',\n                'default': 3,\n                'type': int,\n                'check': check_ge_zero\n            },\n            'divider_label_margin': {\n                'doc': 'Number of spaces around the label.',\n                'default': 1,\n                'type': int,\n                'check': check_ge_zero\n            },\n            'divider_label_align_right': {\n                'doc': 'Label alignment flag.',\n                'default': False,\n                'type': bool\n            },\n            # common styles\n            'style_selected_1': {\n                'default': '1;32'\n            },\n            'style_selected_2': {\n                'default': '32'\n            },\n            'style_low': {\n                'default': '90'\n            },\n            'style_high': {\n                'default': '1;37'\n            },\n            'style_error': {\n                'default': '31'\n            },\n            'style_critical': {\n                'default': '0;41'\n            }\n        }\n\n# Common -----------------------------------------------------------------------\n\nclass Beautifier():\n\n    def __init__(self, hint, tab_size=4):\n        self.tab_spaces = ' ' * tab_size if tab_size else None\n        self.active = False\n        if not R.ansi or not R.syntax_highlighting:\n            return\n        # attempt to set up Pygments\n        try:\n            import pygments\n            from pygments.lexers import GasLexer, NasmLexer\n            from pygments.formatters import Terminal256Formatter\n            if hint == 'att':\n                self.lexer = GasLexer()\n            elif hint == 'intel':\n                self.lexer = NasmLexer()\n            else:\n                from pygments.lexers import get_lexer_for_filename\n                self.lexer = get_lexer_for_filename(hint, stripnl=False)\n            self.formatter = Terminal256Formatter(style=R.syntax_highlighting)\n            self.active = True\n        except ImportError:\n            # Pygments not available\n            pass\n        except pygments.util.ClassNotFound:\n            # no lexer for this file or invalid style\n            pass\n\n    def process(self, source):\n        # convert tabs if requested\n        if self.tab_spaces:\n            source = source.replace('\\t', self.tab_spaces)\n        if self.active:\n            import pygments\n            source = pygments.highlight(source, self.lexer, self.formatter)\n        return source.rstrip('\\n')\n\ndef run(command):\n    return gdb.execute(command, to_string=True)\n\ndef ansi(string, style):\n    if R.ansi:\n        return '\\x1b[{}m{}\\x1b[0m'.format(style, string)\n    else:\n        return string\n\ndef divider(width, label='', primary=False, active=True):\n    if primary:\n        divider_fill_style = R.divider_fill_style_primary\n        divider_fill_char = R.divider_fill_char_primary\n        divider_label_style_on = R.divider_label_style_on_primary\n        divider_label_style_off = R.divider_label_style_off_primary\n    else:\n        divider_fill_style = R.divider_fill_style_secondary\n        divider_fill_char = R.divider_fill_char_secondary\n        divider_label_style_on = R.divider_label_style_on_secondary\n        divider_label_style_off = R.divider_label_style_off_secondary\n    if label:\n        if active:\n            divider_label_style = divider_label_style_on\n        else:\n            divider_label_style = divider_label_style_off\n        skip = R.divider_label_skip\n        margin = R.divider_label_margin\n        before = ansi(divider_fill_char * skip, divider_fill_style)\n        middle = ansi(label, divider_label_style)\n        after_length = width - len(label) - skip - 2 * margin\n        after = ansi(divider_fill_char * after_length, divider_fill_style)\n        if R.divider_label_align_right:\n            before, after = after, before\n        return ''.join([before, ' ' * margin, middle, ' ' * margin, after])\n    else:\n        return ansi(divider_fill_char * width, divider_fill_style)\n\ndef check_gt_zero(x):\n    return x > 0\n\ndef check_ge_zero(x):\n    return x >= 0\n\ndef to_unsigned(value, size=8):\n    # values from GDB can be used transparently but are not suitable for\n    # being printed as unsigned integers, so a conversion is needed\n    mask = (2 ** (size * 8)) - 1\n    return int(value.cast(gdb.Value(mask).type)) & mask\n\ndef to_string(value):\n    # attempt to convert an inferior value to string; OK when (Python 3 ||\n    # simple ASCII); otherwise (Python 2.7 && not ASCII) encode the string as\n    # utf8\n    try:\n        value_string = str(value)\n    except UnicodeEncodeError:\n        value_string = unicode(value).encode('utf8')\n    except gdb.error as e:\n        value_string = ansi(e, R.style_error)\n    return value_string\n\ndef format_address(address):\n    pointer_size = gdb.parse_and_eval('$pc').type.sizeof\n    return ('0x{{:0{}x}}').format(pointer_size * 2).format(address)\n\ndef format_value(value, compact=None):\n    # format references as referenced values\n    # (TYPE_CODE_RVALUE_REF is not supported by old GDB)\n    if value.type.code in (getattr(gdb, 'TYPE_CODE_REF', None),\n                           getattr(gdb, 'TYPE_CODE_RVALUE_REF', None)):\n        try:\n            value = value.referenced_value()\n        except gdb.error as e:\n            return ansi(e, R.style_error)\n    # format the value\n    out = to_string(value)\n    # dereference up to the actual value if requested\n    if R.dereference and value.type.code == gdb.TYPE_CODE_PTR:\n        while value.type.code == gdb.TYPE_CODE_PTR:\n            try:\n                value = value.dereference()\n            except gdb.error as e:\n                break\n        else:\n            formatted = to_string(value)\n            out += '{} {}'.format(ansi(':', R.style_low), formatted)\n    # compact the value\n    if compact is not None and compact or R.compact_values:\n        out = re.sub(r'$\\s*', '', out, flags=re.MULTILINE)\n    # truncate the value\n    if R.max_value_length > 0 and len(out) > R.max_value_length:\n        out = out[0:R.max_value_length] + ansi(R.value_truncation_string, R.style_critical)\n    return out\n\n# XXX parsing the output of `info breakpoints` is apparently the best option\n# right now, see: https://sourceware.org/bugzilla/show_bug.cgi?id=18385\n# XXX GDB version 7.11 (quire recent) does not have the pending field, so\n# fall back to the parsed information\ndef fetch_breakpoints(watchpoints=False, pending=False):\n    # fetch breakpoints addresses\n    parsed_breakpoints = dict()\n    catch_what_regex = re.compile(r'([^,]+\".*\")?[^,]*')\n    for line in run('info breakpoints').split('\\n'):\n        # just keep numbered lines\n        if not line or not line[0].isdigit():\n            continue\n        # extract breakpoint number, address and pending status\n        fields = line.split()\n        number = int(fields[0].split('.')[0])\n        try:\n            if len(fields) >= 5 and fields[1] == 'breakpoint':\n                # multiple breakpoints have no address yet\n                is_pending = fields[4] == '<PENDING>'\n                is_multiple = fields[4] == '<MULTIPLE>'\n                address = None if is_multiple or is_pending else int(fields[4], 16)\n                is_enabled = fields[3] == 'y'\n                address_info = address, is_enabled\n                parsed_breakpoints[number] = [address_info], is_pending, ''\n            elif len(fields) >= 5 and fields[1] == 'catchpoint':\n                # only take before comma, but ignore commas in quotes\n                what = catch_what_regex.search(' '.join(fields[4:])).group(0).strip()\n                parsed_breakpoints[number] = [], False, what\n            elif len(fields) >= 3 and number in parsed_breakpoints:\n                # add this address to the list of multiple locations\n                address = int(fields[2], 16)\n                is_enabled = fields[1] == 'y'\n                address_info = address, is_enabled\n                parsed_breakpoints[number][0].append(address_info)\n            else:\n                # watchpoints\n                parsed_breakpoints[number] = [], False, ''\n        except ValueError:\n            pass\n    # fetch breakpoints from the API and complement with address and source\n    # information\n    breakpoints = []\n    # XXX in older versions gdb.breakpoints() returns None\n    for gdb_breakpoint in gdb.breakpoints() or []:\n        # skip internal breakpoints\n        if gdb_breakpoint.number < 0:\n            continue\n        addresses, is_pending, what = parsed_breakpoints[gdb_breakpoint.number]\n        is_pending = getattr(gdb_breakpoint, 'pending', is_pending)\n        if not pending and is_pending:\n            continue\n        if not watchpoints and gdb_breakpoint.type != gdb.BP_BREAKPOINT:\n            continue\n        # add useful fields to the object\n        breakpoint = dict()\n        breakpoint['number'] = gdb_breakpoint.number\n        breakpoint['type'] = gdb_breakpoint.type\n        breakpoint['enabled'] = gdb_breakpoint.enabled\n        breakpoint['location'] = gdb_breakpoint.location\n        breakpoint['expression'] = gdb_breakpoint.expression\n        breakpoint['condition'] = gdb_breakpoint.condition\n        breakpoint['temporary'] = gdb_breakpoint.temporary\n        breakpoint['hit_count'] = gdb_breakpoint.hit_count\n        breakpoint['pending'] = is_pending\n        breakpoint['what'] = what\n        # add addresses and source information\n        breakpoint['addresses'] = []\n        for address, is_enabled in addresses:\n            if address:\n                sal = gdb.find_pc_line(address)\n            breakpoint['addresses'].append({\n                'address': address,\n                'enabled': is_enabled,\n                'file_name': sal.symtab.filename if address and sal.symtab else None,\n                'file_line': sal.line if address else None\n            })\n        breakpoints.append(breakpoint)\n    return breakpoints\n\n# Dashboard --------------------------------------------------------------------\n\nclass Dashboard(gdb.Command):\n    '''Redisplay the dashboard.'''\n\n    def __init__(self):\n        gdb.Command.__init__(self, 'dashboard', gdb.COMMAND_USER, gdb.COMPLETE_NONE, True)\n        # setup subcommands\n        Dashboard.ConfigurationCommand(self)\n        Dashboard.OutputCommand(self)\n        Dashboard.EnabledCommand(self)\n        Dashboard.LayoutCommand(self)\n        # setup style commands\n        Dashboard.StyleCommand(self, 'dashboard', R, R.attributes())\n        # main terminal\n        self.output = None\n        # used to inhibit redisplays during init parsing\n        self.inhibited = None\n        # enabled by default\n        self.enabled = None\n        self.enable()\n\n    def on_continue(self, _):\n        # try to contain the GDB messages in a specified area unless the\n        # dashboard is printed to a separate file (dashboard -output ...)\n        # or there are no modules to display in the main terminal\n        enabled_modules = list(filter(lambda m: not m.output and m.enabled, self.modules))\n        if self.is_running() and not self.output and len(enabled_modules) > 0:\n            width, _ = Dashboard.get_term_size()\n            gdb.write(Dashboard.clear_screen())\n            gdb.write(divider(width, 'Output/messages', True))\n            gdb.write('\\n')\n            gdb.flush()\n\n    def on_stop(self, _):\n        if self.is_running():\n            self.render(clear_screen=False)\n\n    def on_exit(self, _):\n        if not self.is_running():\n            return\n        # collect all the outputs\n        outputs = set()\n        outputs.add(self.output)\n        outputs.update(module.output for module in self.modules)\n        outputs.remove(None)\n        # reset the terminal status\n        for output in outputs:\n            try:\n                with open(output, 'w') as fs:\n                    fs.write(Dashboard.reset_terminal())\n            except:\n                # skip cleanup for invalid outputs\n                pass\n\n    def enable(self):\n        if self.enabled:\n            return\n        self.enabled = True\n        # setup events\n        gdb.events.cont.connect(self.on_continue)\n        gdb.events.stop.connect(self.on_stop)\n        gdb.events.exited.connect(self.on_exit)\n\n    def disable(self):\n        if not self.enabled:\n            return\n        self.enabled = False\n        # setup events\n        gdb.events.cont.disconnect(self.on_continue)\n        gdb.events.stop.disconnect(self.on_stop)\n        gdb.events.exited.disconnect(self.on_exit)\n\n    def load_modules(self, modules):\n        self.modules = []\n        for module in modules:\n            info = Dashboard.ModuleInfo(self, module)\n            self.modules.append(info)\n\n    def redisplay(self, style_changed=False):\n        # manually redisplay the dashboard\n        if self.is_running() and not self.inhibited:\n            self.render(True, style_changed)\n\n    def inferior_pid(self):\n        return gdb.selected_inferior().pid\n\n    def is_running(self):\n        return self.inferior_pid() != 0\n\n    def render(self, clear_screen, style_changed=False):\n        # fetch module content and info\n        all_disabled = True\n        display_map = dict()\n        for module in self.modules:\n            # fall back to the global value\n            output = module.output or self.output\n            # add the instance or None if disabled\n            if module.enabled:\n                all_disabled = False\n                instance = module.instance\n            else:\n                instance = None\n            display_map.setdefault(output, []).append(instance)\n        # process each display info\n        for output, instances in display_map.items():\n            try:\n                buf = ''\n                # use GDB stream by default\n                fs = None\n                if output:\n                    fs = open(output, 'w')\n                    fd = fs.fileno()\n                    fs.write(Dashboard.setup_terminal())\n                else:\n                    fs = gdb\n                    fd = 1  # stdout\n                # get the terminal size (default main terminal if either the\n                # output is not a file)\n                try:\n                    width, height = Dashboard.get_term_size(fd)\n                except:\n                    width, height = Dashboard.get_term_size()\n                # clear the \"screen\" if requested for the main terminal,\n                # auxiliary terminals are always cleared\n                if fs is not gdb or clear_screen:\n                    buf += Dashboard.clear_screen()\n                # show message if all the modules in this output are disabled\n                if not any(instances):\n                    # skip the main terminal\n                    if fs is gdb:\n                        continue\n                    # write the error message\n                    buf += divider(width, 'Warning', True)\n                    buf += '\\n'\n                    if self.modules:\n                        buf += 'No module to display (see `dashboard -layout`)'\n                    else:\n                        buf += 'No module loaded'\n                    buf += '\\n'\n                    fs.write(buf)\n                    continue\n                # process all the modules for that output\n                for n, instance in enumerate(instances, 1):\n                    # skip disabled modules\n                    if not instance:\n                        continue\n                    try:\n                        # ask the module to generate the content\n                        lines = instance.lines(width, height, style_changed)\n                    except Exception as e:\n                        # allow to continue on exceptions in modules\n                        stacktrace = traceback.format_exc().strip()\n                        lines = [ansi(stacktrace, R.style_error)]\n                    # create the divider if needed\n                    div = []\n                    if not R.omit_divider or len(instances) > 1 or fs is gdb:\n                        div = [divider(width, instance.label(), True, lines)]\n                    # write the data\n                    buf += '\\n'.join(div + lines)\n                    # write the newline for all but last unless main terminal\n                    if n != len(instances) or fs is gdb:\n                        buf += '\\n'\n                # write the final newline and the terminator only if it is the\n                # main terminal to allow the prompt to display correctly (unless\n                # there are no modules to display)\n                if fs is gdb and not all_disabled:\n                    buf += divider(width, primary=True)\n                    buf += '\\n'\n                fs.write(buf)\n            except Exception as e:\n                cause = traceback.format_exc().strip()\n                Dashboard.err('Cannot write the dashboard\\n{}'.format(cause))\n            finally:\n                # don't close gdb stream\n                if fs and fs is not gdb:\n                    fs.close()\n\n# Utility methods --------------------------------------------------------------\n\n    @staticmethod\n    def start():\n        # save the instance for customization convenience\n        global dashboard\n        # initialize the dashboard\n        dashboard = Dashboard()\n        Dashboard.set_custom_prompt(dashboard)\n        # parse Python inits, load modules then parse GDB inits\n        dashboard.inhibited = True\n        Dashboard.parse_inits(True)\n        modules = Dashboard.get_modules()\n        dashboard.load_modules(modules)\n        Dashboard.parse_inits(False)\n        dashboard.inhibited = False\n        # GDB overrides\n        run('set pagination off')\n        # display if possible (program running and not explicitly disabled by\n        # some configuration file)\n        if dashboard.enabled:\n            dashboard.redisplay()\n\n    @staticmethod\n    def get_term_size(fd=1):  # defaults to the main terminal\n        try:\n            if sys.platform == 'win32':\n                import curses\n                # XXX always neglects the fd parameter\n                height, width = curses.initscr().getmaxyx()\n                curses.endwin()\n                return int(width), int(height)\n            else:\n                import termios\n                import fcntl\n                # first 2 shorts (4 byte) of struct winsize\n                raw = fcntl.ioctl(fd, termios.TIOCGWINSZ, ' ' * 4)\n                height, width = struct.unpack('hh', raw)\n                return int(width), int(height)\n        except (ImportError, OSError):\n            # this happens when no curses library is found on windows or when\n            # the terminal is not properly configured\n            return 80, 24  # hardcoded fallback value\n\n    @staticmethod\n    def set_custom_prompt(dashboard):\n        def custom_prompt(_):\n            # render thread status indicator\n            if dashboard.is_running():\n                pid = dashboard.inferior_pid()\n                status = R.prompt_running.format(pid=pid)\n            else:\n                status = R.prompt_not_running\n            # build prompt\n            prompt = R.prompt.format(status=status)\n            prompt = gdb.prompt.substitute_prompt(prompt)\n            return prompt + ' '  # force trailing space\n        gdb.prompt_hook = custom_prompt\n\n    @staticmethod\n    def parse_inits(python):\n        # paths where the .gdbinit.d directory might be\n        search_paths = [\n            '/etc/gdb-dashboard',\n            '{}/gdb-dashboard'.format(os.getenv('XDG_CONFIG_HOME', '~/.config')),\n            '~/Library/Preferences/gdb-dashboard',\n            '~/.gdbinit.d'\n        ]\n        # expand the tilde and walk the paths\n        inits_dirs = (os.walk(os.path.expanduser(path)) for path in search_paths)\n        # process all the init files in order\n        for root, dirs, files in itertools.chain.from_iterable(inits_dirs):\n            dirs.sort()\n            # skipping dotfiles\n            for init in sorted(file for file in files if not file.startswith('.')):\n                path = os.path.join(root, init)\n                _, ext = os.path.splitext(path)\n                # either load Python files or GDB\n                if python == (ext == '.py'):\n                    gdb.execute('source ' + path)\n\n    @staticmethod\n    def get_modules():\n        # scan the scope for modules\n        modules = []\n        for name in globals():\n            obj = globals()[name]\n            try:\n                if issubclass(obj, Dashboard.Module):\n                    modules.append(obj)\n            except TypeError:\n                continue\n        # sort modules alphabetically\n        modules.sort(key=lambda x: x.__name__)\n        return modules\n\n    @staticmethod\n    def create_command(name, invoke, doc, is_prefix, complete=None):\n        if callable(complete):\n            Class = type('', (gdb.Command,), {\n                '__doc__': doc,\n                'invoke': invoke,\n                'complete': complete\n            })\n            Class(name, gdb.COMMAND_USER, prefix=is_prefix)\n        else:\n            Class = type('', (gdb.Command,), {\n                '__doc__': doc,\n                'invoke': invoke\n            })\n            Class(name, gdb.COMMAND_USER, complete or gdb.COMPLETE_NONE, is_prefix)\n\n    @staticmethod\n    def err(string):\n        print(ansi(string, R.style_error))\n\n    @staticmethod\n    def complete(word, candidates):\n        return filter(lambda candidate: candidate.startswith(word), candidates)\n\n    @staticmethod\n    def parse_arg(arg):\n        # encode unicode GDB command arguments as utf8 in Python 2.7\n        if type(arg) is not str:\n            arg = arg.encode('utf8')\n        return arg\n\n    @staticmethod\n    def clear_screen():\n        # ANSI: move the cursor to top-left corner and clear the screen\n        # (optionally also clear the scrollback buffer if supported by the\n        # terminal)\n        return '\\x1b[H\\x1b[2J' + ('\\x1b[3J' if R.discard_scrollback else '')\n\n    @staticmethod\n    def setup_terminal():\n        # ANSI: enable alternative screen buffer and hide cursor\n        return '\\x1b[?1049h\\x1b[?25l'\n\n    @staticmethod\n    def reset_terminal():\n        # ANSI: disable alternative screen buffer and show cursor\n        return '\\x1b[?1049l\\x1b[?25h'\n\n# Module descriptor ------------------------------------------------------------\n\n    class ModuleInfo:\n\n        def __init__(self, dashboard, module):\n            self.name = module.__name__.lower()  # from class to module name\n            self.enabled = True\n            self.output = None  # value from the dashboard by default\n            self.instance = module()\n            self.doc = self.instance.__doc__ or '(no documentation)'\n            self.prefix = 'dashboard {}'.format(self.name)\n            # add GDB commands\n            self.add_main_command(dashboard)\n            self.add_output_command(dashboard)\n            self.add_style_command(dashboard)\n            self.add_subcommands(dashboard)\n\n        def add_main_command(self, dashboard):\n            module = self\n            def invoke(self, arg, from_tty, info=self):\n                arg = Dashboard.parse_arg(arg)\n                if arg == '':\n                    info.enabled ^= True\n                    if dashboard.is_running():\n                        dashboard.redisplay()\n                    else:\n                        status = 'enabled' if info.enabled else 'disabled'\n                        print('{} module {}'.format(module.name, status))\n                else:\n                    Dashboard.err('Wrong argument \"{}\"'.format(arg))\n            doc_brief = 'Configure the {} module, with no arguments toggles its visibility.'.format(self.name)\n            doc = '{}\\n\\n{}'.format(doc_brief, self.doc)\n            Dashboard.create_command(self.prefix, invoke, doc, True)\n\n        def add_output_command(self, dashboard):\n            Dashboard.OutputCommand(dashboard, self.prefix, self)\n\n        def add_style_command(self, dashboard):\n            Dashboard.StyleCommand(dashboard, self.prefix, self.instance, self.instance.attributes())\n\n        def add_subcommands(self, dashboard):\n            for name, command in self.instance.commands().items():\n                self.add_subcommand(dashboard, name, command)\n\n        def add_subcommand(self, dashboard, name, command):\n            action = command['action']\n            doc = command['doc']\n            complete = command.get('complete')\n            def invoke(self, arg, from_tty, info=self):\n                arg = Dashboard.parse_arg(arg)\n                if info.enabled:\n                    try:\n                        action(arg)\n                    except Exception as e:\n                        Dashboard.err(e)\n                        return\n                    # don't catch redisplay errors\n                    dashboard.redisplay()\n                else:\n                    Dashboard.err('Module disabled')\n            prefix = '{} {}'.format(self.prefix, name)\n            Dashboard.create_command(prefix, invoke, doc, False, complete)\n\n# GDB commands -----------------------------------------------------------------\n\n    # handler for the `dashboard` command itself\n    def invoke(self, arg, from_tty):\n        arg = Dashboard.parse_arg(arg)\n        # show messages for checks in redisplay\n        if arg != '':\n            Dashboard.err('Wrong argument \"{}\"'.format(arg))\n        elif not self.is_running():\n            Dashboard.err('Is the target program running?')\n        else:\n            self.redisplay()\n\n    class ConfigurationCommand(gdb.Command):\n        '''Dump or save the dashboard configuration.\n\nWith an optional argument the configuration will be written to the specified\nfile.\n\nThis command allows to configure the dashboard live then make the changes\npermanent, for example:\n\n    dashboard -configuration ~/.gdbinit.d/init\n\nAt startup the `~/.gdbinit.d/` directory tree is walked and files are evaluated\nin alphabetical order but giving priority to Python files. This is where user\nconfiguration files must be placed.'''\n\n        def __init__(self, dashboard):\n            gdb.Command.__init__(self, 'dashboard -configuration',\n                                 gdb.COMMAND_USER, gdb.COMPLETE_FILENAME)\n            self.dashboard = dashboard\n\n        def invoke(self, arg, from_tty):\n            arg = Dashboard.parse_arg(arg)\n            if arg:\n                with open(os.path.expanduser(arg), 'w') as fs:\n                    fs.write('# auto generated by GDB dashboard\\n\\n')\n                    self.dump(fs)\n            self.dump(gdb)\n\n        def dump(self, fs):\n            # dump layout\n            self.dump_layout(fs)\n            # dump styles\n            self.dump_style(fs, R)\n            for module in self.dashboard.modules:\n                self.dump_style(fs, module.instance, module.prefix)\n            # dump outputs\n            self.dump_output(fs, self.dashboard)\n            for module in self.dashboard.modules:\n                self.dump_output(fs, module, module.prefix)\n\n        def dump_layout(self, fs):\n            layout = ['dashboard -layout']\n            for module in self.dashboard.modules:\n                mark = '' if module.enabled else '!'\n                layout.append('{}{}'.format(mark, module.name))\n            fs.write(' '.join(layout))\n            fs.write('\\n')\n\n        def dump_style(self, fs, obj, prefix='dashboard'):\n            attributes = getattr(obj, 'attributes', lambda: dict())()\n            for name, attribute in attributes.items():\n                real_name = attribute.get('name', name)\n                default = attribute.get('default')\n                value = getattr(obj, real_name)\n                if value != default:\n                    fs.write('{} -style {} {!r}\\n'.format(prefix, name, value))\n\n        def dump_output(self, fs, obj, prefix='dashboard'):\n            output = getattr(obj, 'output')\n            if output:\n                fs.write('{} -output {}\\n'.format(prefix, output))\n\n    class OutputCommand(gdb.Command):\n        '''Set the output file/TTY for the whole dashboard or single modules.\n\nThe dashboard/module will be written to the specified file, which will be\ncreated if it does not exist. If the specified file identifies a terminal then\nits geometry will be used, otherwise it falls back to the geometry of the main\nGDB terminal.\n\nWhen invoked without argument on the dashboard, the output/messages and modules\nwhich do not specify an output themselves will be printed on standard output\n(default).\n\nWhen invoked without argument on a module, it will be printed where the\ndashboard will be printed.\n\nAn overview of all the outputs can be obtained with the `dashboard -layout`\ncommand.'''\n\n        def __init__(self, dashboard, prefix=None, obj=None):\n            if not prefix:\n                prefix = 'dashboard'\n            if not obj:\n                obj = dashboard\n            prefix = prefix + ' -output'\n            gdb.Command.__init__(self, prefix, gdb.COMMAND_USER, gdb.COMPLETE_FILENAME)\n            self.dashboard = dashboard\n            self.obj = obj  # None means the dashboard itself\n\n        def invoke(self, arg, from_tty):\n            arg = Dashboard.parse_arg(arg)\n            # reset the terminal status\n            if self.obj.output:\n                try:\n                    with open(self.obj.output, 'w') as fs:\n                        fs.write(Dashboard.reset_terminal())\n                except:\n                    # just do nothing if the file is not writable\n                    pass\n            # set or open the output file\n            if arg == '':\n                self.obj.output = None\n            else:\n                self.obj.output = arg\n            # redisplay the dashboard in the new output\n            self.dashboard.redisplay()\n\n    class EnabledCommand(gdb.Command):\n        '''Enable or disable the dashboard.\n\nThe current status is printed if no argument is present.'''\n\n        def __init__(self, dashboard):\n            gdb.Command.__init__(self, 'dashboard -enabled', gdb.COMMAND_USER)\n            self.dashboard = dashboard\n\n        def invoke(self, arg, from_tty):\n            arg = Dashboard.parse_arg(arg)\n            if arg == '':\n                status = 'enabled' if self.dashboard.enabled else 'disabled'\n                print('The dashboard is {}'.format(status))\n            elif arg == 'on':\n                self.dashboard.enable()\n                self.dashboard.redisplay()\n            elif arg == 'off':\n                self.dashboard.disable()\n            else:\n                msg = 'Wrong argument \"{}\"; expecting \"on\" or \"off\"'\n                Dashboard.err(msg.format(arg))\n\n        def complete(self, text, word):\n            return Dashboard.complete(word, ['on', 'off'])\n\n    class LayoutCommand(gdb.Command):\n        '''Set or show the dashboard layout.\n\nAccepts a space-separated list of directive. Each directive is in the form\n\"[!]<module>\". Modules in the list are placed in the dashboard in the same order\nas they appear and those prefixed by \"!\" are disabled by default. Omitted\nmodules are hidden and placed at the bottom in alphabetical order.\n\nWithout arguments the current layout is shown where the first line uses the same\nform expected by the input while the remaining depict the current status of\noutput files.\n\nPassing `!` as a single argument resets the dashboard original layout.'''\n\n        def __init__(self, dashboard):\n            gdb.Command.__init__(self, 'dashboard -layout', gdb.COMMAND_USER)\n            self.dashboard = dashboard\n\n        def invoke(self, arg, from_tty):\n            arg = Dashboard.parse_arg(arg)\n            directives = str(arg).split()\n            if directives:\n                # apply the layout\n                if directives == ['!']:\n                    self.reset()\n                else:\n                    if not self.layout(directives):\n                        return  # in case of errors\n                # redisplay or otherwise notify\n                if from_tty:\n                    if self.dashboard.is_running():\n                        self.dashboard.redisplay()\n                    else:\n                        self.show()\n            else:\n                self.show()\n\n        def reset(self):\n            modules = self.dashboard.modules\n            modules.sort(key=lambda module: module.name)\n            for module in modules:\n                module.enabled = True\n\n        def show(self):\n            global_str = 'Dashboard'\n            default = '(default TTY)'\n            max_name_len = max(len(module.name) for module in self.dashboard.modules)\n            max_name_len = max(max_name_len, len(global_str))\n            fmt = '{{}}{{:{}s}}{{}}'.format(max_name_len + 2)\n            print((fmt + '\\n').format(' ', global_str, self.dashboard.output or default))\n            for module in self.dashboard.modules:\n                mark = ' ' if module.enabled else '!'\n                style = R.style_high if module.enabled else R.style_low\n                line = fmt.format(mark, module.name, module.output or default)\n                print(ansi(line, style))\n\n        def layout(self, directives):\n            modules = self.dashboard.modules\n            # parse and check directives\n            parsed_directives = []\n            selected_modules = set()\n            for directive in directives:\n                enabled = (directive[0] != '!')\n                name = directive[not enabled:]\n                if name in selected_modules:\n                    Dashboard.err('Module \"{}\" already set'.format(name))\n                    return False\n                if next((False for module in modules if module.name == name), True):\n                    Dashboard.err('Cannot find module \"{}\"'.format(name))\n                    return False\n                parsed_directives.append((name, enabled))\n                selected_modules.add(name)\n            # reset visibility\n            for module in modules:\n                module.enabled = False\n            # move and enable the selected modules on top\n            last = 0\n            for name, enabled in parsed_directives:\n                todo = enumerate(modules[last:], start=last)\n                index = next(index for index, module in todo if name == module.name)\n                modules[index].enabled = enabled\n                modules.insert(last, modules.pop(index))\n                last += 1\n            return True\n\n        def complete(self, text, word):\n            all_modules = (m.name for m in self.dashboard.modules)\n            return Dashboard.complete(word, all_modules)\n\n    class StyleCommand(gdb.Command):\n        '''Access the stylable attributes.\n\nWithout arguments print all the stylable attributes.\n\nWhen only the name is specified show the current value.\n\nWith name and value set the stylable attribute. Values are parsed as Python\nliterals and converted to the proper type. '''\n\n        def __init__(self, dashboard, prefix, obj, attributes):\n            self.prefix = prefix + ' -style'\n            gdb.Command.__init__(self, self.prefix, gdb.COMMAND_USER, gdb.COMPLETE_NONE, True)\n            self.dashboard = dashboard\n            self.obj = obj\n            self.attributes = attributes\n            self.add_styles()\n\n        def add_styles(self):\n            this = self\n            for name, attribute in self.attributes.items():\n                # fetch fields\n                attr_name = attribute.get('name', name)\n                attr_type = attribute.get('type', str)\n                attr_check = attribute.get('check', lambda _: True)\n                attr_default = attribute['default']\n                # set the default value (coerced to the type)\n                value = attr_type(attr_default)\n                setattr(self.obj, attr_name, value)\n                # create the command\n                def invoke(self, arg, from_tty,\n                           name=name,\n                           attr_name=attr_name,\n                           attr_type=attr_type,\n                           attr_check=attr_check):\n                    new_value = Dashboard.parse_arg(arg)\n                    if new_value == '':\n                        # print the current value\n                        value = getattr(this.obj, attr_name)\n                        print('{} = {!r}'.format(name, value))\n                    else:\n                        try:\n                            # convert and check the new value\n                            parsed = ast.literal_eval(new_value)\n                            value = attr_type(parsed)\n                            if not attr_check(value):\n                                msg = 'Invalid value \"{}\" for \"{}\"'\n                                raise Exception(msg.format(new_value, name))\n                        except Exception as e:\n                            Dashboard.err(e)\n                        else:\n                            # set and redisplay\n                            setattr(this.obj, attr_name, value)\n                            this.dashboard.redisplay(True)\n                prefix = self.prefix + ' ' + name\n                doc = attribute.get('doc', 'This style is self-documenting')\n                Dashboard.create_command(prefix, invoke, doc, False)\n\n        def invoke(self, arg, from_tty):\n            # an argument here means that the provided attribute is invalid\n            if arg:\n                Dashboard.err('Invalid argument \"{}\"'.format(arg))\n                return\n            # print all the pairs\n            for name, attribute in self.attributes.items():\n                attr_name = attribute.get('name', name)\n                value = getattr(self.obj, attr_name)\n                print('{} = {!r}'.format(name, value))\n\n# Base module ------------------------------------------------------------------\n\n    # just a tag\n    class Module():\n        '''Base class for GDB dashboard modules.\n\n        Modules are instantiated once at initialization time and kept during the\n        whole the GDB session.\n\n        The name of a module is automatically obtained by the class name.\n\n        Optionally, a module may include a description which will appear in the\n        GDB help system by specifying a Python docstring for the class. By\n        convention the first line should contain a brief description.'''\n\n        def label(self):\n            '''Return the module label which will appear in the divider.'''\n            pass\n\n        def lines(self, term_width, term_height, style_changed):\n            '''Return a list of strings which will form the module content.\n\n            When a module is temporarily unable to produce its content, it\n            should return an empty list; its divider will then use the styles\n            with the \"off\" qualifier.\n\n            term_width and term_height are the dimension of the terminal where\n            this module will be displayed. If `style_changed` is `True` then\n            some attributes have changed since the last time so the\n            implementation may want to update its status.'''\n            pass\n\n        def attributes(self):\n            '''Return the dictionary of available attributes.\n\n            The key is the attribute name and the value is another dictionary\n            with items:\n\n            - `default` is the initial value for this attribute;\n\n            - `doc` is the optional documentation of this attribute which will\n              appear in the GDB help system;\n\n            - `name` is the name of the attribute of the Python object (defaults\n              to the key value);\n\n            - `type` is the Python type of this attribute defaulting to the\n              `str` type, it is used to coerce the value passed as an argument\n              to the proper type, or raise an exception;\n\n            - `check` is an optional control callback which accept the coerced\n              value and returns `True` if the value satisfies the constraint and\n              `False` otherwise.\n\n            Those attributes can be accessed from the implementation using\n            instance variables named `name`.'''\n            return {}\n\n        def commands(self):\n            '''Return the dictionary of available commands.\n\n            The key is the attribute name and the value is another dictionary\n            with items:\n\n            - `action` is the callback to be executed which accepts the raw\n              input string from the GDB prompt, exceptions in these functions\n              will be shown automatically to the user;\n\n            - `doc` is the documentation of this command which will appear in\n              the GDB help system;\n\n            - `completion` is the optional completion policy, one of the\n              `gdb.COMPLETE_*` constants defined in the GDB reference manual\n              (https://sourceware.org/gdb/onlinedocs/gdb/Commands-In-Python.html).'''\n            return {}\n\n# Default modules --------------------------------------------------------------\n\nclass Source(Dashboard.Module):\n    '''Show the program source code, if available.'''\n\n    def __init__(self):\n        self.file_name = None\n        self.source_lines = []\n        self.ts = None\n        self.highlighted = False\n        self.offset = 0\n\n    def label(self):\n        label = 'Source'\n        if self.show_path and self.file_name:\n            label += ': {}'.format(self.file_name)\n        return label\n\n    def lines(self, term_width, term_height, style_changed):\n        # skip if the current thread is not stopped\n        if not gdb.selected_thread().is_stopped():\n            return []\n        # try to fetch the current line (skip if no line information)\n        sal = gdb.selected_frame().find_sal()\n        current_line = sal.line\n        if current_line == 0:\n            self.file_name = None\n            return []\n        # try to lookup the source file\n        candidates = [\n            sal.symtab.fullname(),\n            sal.symtab.filename,\n            # XXX GDB also uses absolute filename but it is harder to implement\n            # properly and IMHO useless\n            os.path.basename(sal.symtab.filename)]\n        for candidate in candidates:\n            file_name = candidate\n            ts = None\n            try:\n                ts = os.path.getmtime(file_name)\n                break\n            except:\n                # try another or delay error check to open()\n                continue\n        # style changed, different file name or file modified in the meanwhile\n        if style_changed or file_name != self.file_name or ts and ts > self.ts:\n            try:\n                # reload the source file if changed\n                with io.open(file_name, errors='replace') as source_file:\n                    highlighter = Beautifier(file_name, self.tab_size)\n                    self.highlighted = highlighter.active\n                    source = highlighter.process(source_file.read())\n                    self.source_lines = source.split('\\n')\n                # store file name and timestamp only if success to have\n                # persistent errors\n                self.file_name = file_name\n                self.ts = ts\n            except IOError as e:\n                msg = 'Cannot display \"{}\"'.format(file_name)\n                return [ansi(msg, R.style_error)]\n        # compute the line range\n        height = self.height or (term_height - 1)\n        start = current_line - 1 - int(height / 2) + self.offset\n        end = start + height\n        # extra at start\n        extra_start = 0\n        if start < 0:\n            extra_start = min(-start, height)\n            start = 0\n        # extra at end\n        extra_end = 0\n        if end > len(self.source_lines):\n            extra_end = min(end - len(self.source_lines), height)\n            end = len(self.source_lines)\n        else:\n            end = max(end, 0)\n        # return the source code listing\n        breakpoints = fetch_breakpoints()\n        out = []\n        number_format = '{{:>{}}}'.format(len(str(end)))\n        for number, line in enumerate(self.source_lines[start:end], start + 1):\n            # properly handle UTF-8 source files\n            line = to_string(line)\n            if int(number) == current_line:\n                # the current line has a different style without ANSI\n                if R.ansi:\n                    if self.highlighted and not self.highlight_line:\n                        line_format = '{}' + ansi(number_format, R.style_selected_1) + '  {}'\n                    else:\n                        line_format = '{}' + ansi(number_format + '  {}', R.style_selected_1)\n                else:\n                    # just show a plain text indicator\n                    line_format = '{}' + number_format + '> {}'\n            else:\n                line_format = '{}' + ansi(number_format, R.style_low) + '  {}'\n            # check for breakpoint presence\n            enabled = None\n            for breakpoint in breakpoints:\n                addresses = breakpoint['addresses']\n                is_root_enabled = addresses[0]['enabled']\n                for address in addresses:\n                    # note, despite the lookup path always use the relative\n                    # (sal.symtab.filename) file name to match source files with\n                    # breakpoints\n                    if address['file_line'] == number and address['file_name'] == sal.symtab.filename:\n                        enabled = enabled or (address['enabled'] and is_root_enabled)\n            if enabled is None:\n                breakpoint = ' '\n            else:\n                breakpoint = ansi('!', R.style_critical) if enabled else ansi('-', R.style_low)\n            out.append(line_format.format(breakpoint, number, line.rstrip('\\n')))\n        # return the output along with scroll indicators\n        if len(out) <= height:\n            extra = [ansi('~', R.style_low)]\n            return extra_start * extra + out + extra_end * extra\n        else:\n            return out\n\n    def commands(self):\n        return {\n            'scroll': {\n                'action': self.scroll,\n                'doc': 'Scroll by relative steps or reset if invoked without argument.'\n            }\n        }\n\n    def attributes(self):\n        return {\n            'height': {\n                'doc': '''Height of the module.\n\nA value of 0 uses the whole height.''',\n                'default': 10,\n                'type': int,\n                'check': check_ge_zero\n            },\n            'tab-size': {\n                'doc': 'Number of spaces used to display the tab character.',\n                'default': 4,\n                'name': 'tab_size',\n                'type': int,\n                'check': check_gt_zero\n            },\n            'path': {\n                'doc': 'Path visibility flag in the module label.',\n                'default': False,\n                'name': 'show_path',\n                'type': bool\n            },\n            'highlight-line': {\n                'doc': 'Decide whether the whole current line should be highlighted.',\n                'default': False,\n                'name': 'highlight_line',\n                'type': bool\n            }\n        }\n\n    def scroll(self, arg):\n        if arg:\n            self.offset += int(arg)\n        else:\n            self.offset = 0\n\nclass Assembly(Dashboard.Module):\n    '''Show the disassembled code surrounding the program counter.\n\nThe instructions constituting the current statement are marked, if available.'''\n\n    def __init__(self):\n        self.offset = 0\n        self.cache_key = None\n        self.cache_asm = None\n\n    def label(self):\n        return 'Assembly'\n\n    def lines(self, term_width, term_height, style_changed):\n        # skip if the current thread is not stopped\n        if not gdb.selected_thread().is_stopped():\n            return []\n        # flush the cache if the style is changed\n        if style_changed:\n            self.cache_key = None\n        # prepare the highlighter\n        try:\n            flavor = gdb.parameter('disassembly-flavor')\n        except:\n            flavor = 'att'  # not always defined (see #36)\n        highlighter = Beautifier(flavor, tab_size=None)\n        # fetch the assembly code\n        line_info = None\n        frame = gdb.selected_frame()  # PC is here\n        height = self.height or (term_height - 1)\n        try:\n            # disassemble the current block\n            asm_start, asm_end = self.fetch_function_boundaries()\n            asm = self.fetch_asm(asm_start, asm_end, False, highlighter)\n            # find the location of the PC\n            pc_index = next(index for index, instr in enumerate(asm)\n                            if instr['addr'] == frame.pc())\n            # compute the instruction range\n            start = pc_index - int(height / 2) + self.offset\n            end = start + height\n            # extra at start\n            extra_start = 0\n            if start < 0:\n                extra_start = min(-start, height)\n                start = 0\n            # extra at end\n            extra_end = 0\n            if end > len(asm):\n                extra_end = min(end - len(asm), height)\n                end = len(asm)\n            else:\n                end = max(end, 0)\n            # fetch actual interval\n            asm = asm[start:end]\n            # if there are line information then use it, it may be that\n            # line_info is not None but line_info.last is None\n            line_info = gdb.find_pc_line(frame.pc())\n            line_info = line_info if line_info.last else None\n        except (gdb.error, RuntimeError, StopIteration):\n            # if it is not possible (stripped binary or the PC is not present in\n            # the output of `disassemble` as per issue #31) start from PC\n            try:\n                extra_start = 0\n                extra_end = 0\n                # allow to scroll down nevertheless\n                clamped_offset = min(self.offset, 0)\n                asm = self.fetch_asm(frame.pc(), height - clamped_offset, True, highlighter)\n                asm = asm[-clamped_offset:]\n            except gdb.error as e:\n                msg = '{}'.format(e)\n                return [ansi(msg, R.style_error)]\n        # fetch function start if available (e.g., not with @plt)\n        func_start = None\n        if self.show_function and frame.function():\n            func_start = to_unsigned(frame.function().value())\n        # compute the maximum offset size\n        if asm and func_start:\n            max_offset = max(len(str(abs(asm[0]['addr'] - func_start))),\n                             len(str(abs(asm[-1]['addr'] - func_start))))\n        # return the machine code\n        breakpoints = fetch_breakpoints()\n        max_length = max(instr['length'] for instr in asm) if asm else 0\n        inferior = gdb.selected_inferior()\n        out = []\n        for index, instr in enumerate(asm):\n            addr = instr['addr']\n            length = instr['length']\n            text = instr['asm']\n            addr_str = format_address(addr)\n            if self.show_opcodes:\n                # fetch and format opcode\n                region = inferior.read_memory(addr, length)\n                opcodes = (' '.join('{:02x}'.format(ord(byte)) for byte in region))\n                opcodes += (max_length - len(region)) * 3 * ' ' + '  '\n            else:\n                opcodes = ''\n            # compute the offset if available\n            if self.show_function:\n                if func_start:\n                    offset = '{:+d}'.format(addr - func_start)\n                    offset = offset.ljust(max_offset + 1)  # sign\n                    func_info = '{}{}'.format(frame.function(), offset)\n                else:\n                    func_info = '?'\n            else:\n                func_info = ''\n            format_string = '{}{}{}{}{}{}'\n            indicator = '  '\n            text = ' ' + text\n            if addr == frame.pc():\n                if not R.ansi:\n                    indicator = '> '\n                addr_str = ansi(addr_str, R.style_selected_1)\n                indicator = ansi(indicator, R.style_selected_1)\n                opcodes = ansi(opcodes, R.style_selected_1)\n                func_info = ansi(func_info, R.style_selected_1)\n                if not highlighter.active or self.highlight_line:\n                    text = ansi(text, R.style_selected_1)\n            elif line_info and line_info.pc <= addr < line_info.last:\n                if not R.ansi:\n                    indicator = ': '\n                addr_str = ansi(addr_str, R.style_selected_2)\n                indicator = ansi(indicator, R.style_selected_2)\n                opcodes = ansi(opcodes, R.style_selected_2)\n                func_info = ansi(func_info, R.style_selected_2)\n                if not highlighter.active or self.highlight_line:\n                    text = ansi(text, R.style_selected_2)\n            else:\n                addr_str = ansi(addr_str, R.style_low)\n                func_info = ansi(func_info, R.style_low)\n            # check for breakpoint presence\n            enabled = None\n            for breakpoint in breakpoints:\n                addresses = breakpoint['addresses']\n                is_root_enabled = addresses[0]['enabled']\n                for address in addresses:\n                    if address['address'] == addr:\n                        enabled = enabled or (address['enabled'] and is_root_enabled)\n            if enabled is None:\n                breakpoint = ' '\n            else:\n                breakpoint = ansi('!', R.style_critical) if enabled else ansi('-', R.style_low)\n            out.append(format_string.format(breakpoint, addr_str, indicator, opcodes, func_info, text))\n        # return the output along with scroll indicators\n        if len(out) <= height:\n            extra = [ansi('~', R.style_low)]\n            return extra_start * extra + out + extra_end * extra\n        else:\n            return out\n\n    def commands(self):\n        return {\n            'scroll': {\n                'action': self.scroll,\n                'doc': 'Scroll by relative steps or reset if invoked without argument.'\n            }\n        }\n\n    def attributes(self):\n        return {\n            'height': {\n                'doc': '''Height of the module.\n\nA value of 0 uses the whole height.''',\n                'default': 10,\n                'type': int,\n                'check': check_ge_zero\n            },\n            'opcodes': {\n                'doc': 'Opcodes visibility flag.',\n                'default': False,\n                'name': 'show_opcodes',\n                'type': bool\n            },\n            'function': {\n                'doc': 'Function information visibility flag.',\n                'default': True,\n                'name': 'show_function',\n                'type': bool\n            },\n            'highlight-line': {\n                'doc': 'Decide whether the whole current line should be highlighted.',\n                'default': False,\n                'name': 'highlight_line',\n                'type': bool\n            }\n        }\n\n    def scroll(self, arg):\n        if arg:\n            self.offset += int(arg)\n        else:\n            self.offset = 0\n\n    def fetch_function_boundaries(self):\n        frame = gdb.selected_frame()\n        # parse the output of the disassemble GDB command to find the function\n        # boundaries, this should handle cases in which a function spans\n        # multiple discontinuous blocks\n        disassemble = run('disassemble')\n        for block_start, block_end in re.findall(r'Address range 0x([0-9a-f]+) to 0x([0-9a-f]+):', disassemble):\n            block_start = int(block_start, 16)\n            block_end = int(block_end, 16)\n            if block_start <= frame.pc() < block_end:\n                return block_start, block_end - 1 # need to be inclusive\n        # if function information is available then try to obtain the\n        # boundaries by looking at the superblocks\n        block = frame.block()\n        if frame.function():\n            while block and (not block.function or block.function.name != frame.function().name):\n                block = block.superblock\n            block = block or frame.block()\n        return block.start, block.end - 1\n\n    def fetch_asm(self, start, end_or_count, relative, highlighter):\n        # fetch asm from cache or disassemble\n        if self.cache_key == (start, end_or_count):\n            asm = self.cache_asm\n        else:\n            kwargs = {\n                'start_pc': start,\n                'count' if relative else 'end_pc': end_or_count\n            }\n            asm = gdb.selected_frame().architecture().disassemble(**kwargs)\n            self.cache_key = (start, end_or_count)\n            self.cache_asm = asm\n            # syntax highlight the cached entry\n            for instr in asm:\n                instr['asm'] = highlighter.process(instr['asm'])\n        return asm\n\nclass Variables(Dashboard.Module):\n    '''Show arguments and locals of the selected frame.'''\n\n    def label(self):\n        return 'Variables'\n\n    def lines(self, term_width, term_height, style_changed):\n        return Variables.format_frame(\n            gdb.selected_frame(), self.show_arguments, self.show_locals, self.compact, self.align, self.sort)\n\n    def attributes(self):\n        return {\n            'arguments': {\n                'doc': 'Frame arguments visibility flag.',\n                'default': True,\n                'name': 'show_arguments',\n                'type': bool\n            },\n            'locals': {\n                'doc': 'Frame locals visibility flag.',\n                'default': True,\n                'name': 'show_locals',\n                'type': bool\n            },\n            'compact': {\n                'doc': 'Single-line display flag.',\n                'default': True,\n                'type': bool\n            },\n            'align': {\n                'doc': 'Align variables in column flag (only if not compact).',\n                'default': False,\n                'type': bool\n            },\n            'sort': {\n                'doc': 'Sort variables by name.',\n                'default': False,\n                'type': bool\n            }\n        }\n\n    @staticmethod\n    def format_frame(frame, show_arguments, show_locals, compact, align, sort):\n        out = []\n        # fetch frame arguments and locals\n        decorator = gdb.FrameDecorator.FrameDecorator(frame)\n        separator = ansi(', ', R.style_low)\n        if show_arguments:\n            def prefix(line):\n                return Stack.format_line('arg', line)\n            frame_args = decorator.frame_args()\n            args_lines = Variables.fetch(frame, frame_args, compact, align, sort)\n            if args_lines:\n                if compact:\n                    args_line = separator.join(args_lines)\n                    single_line = prefix(args_line)\n                    out.append(single_line)\n                else:\n                    out.extend(map(prefix, args_lines))\n        if show_locals:\n            def prefix(line):\n                return Stack.format_line('loc', line)\n            frame_locals = decorator.frame_locals()\n            locals_lines = Variables.fetch(frame, frame_locals, compact, align, sort)\n            if locals_lines:\n                if compact:\n                    locals_line = separator.join(locals_lines)\n                    single_line = prefix(locals_line)\n                    out.append(single_line)\n                else:\n                    out.extend(map(prefix, locals_lines))\n        return out\n\n    @staticmethod\n    def fetch(frame, data, compact, align, sort):\n        lines = []\n        name_width = 0\n        if align and not compact:\n            name_width = max(len(str(elem.sym)) for elem in data) if data else 0\n        for elem in data or []:\n            name = ansi(elem.sym, R.style_high) + ' ' * (name_width - len(str(elem.sym)))\n            equal = ansi('=', R.style_low)\n            value = format_value(elem.sym.value(frame), compact)\n            lines.append('{} {} {}'.format(name, equal, value))\n        if sort:\n            lines.sort()\n        return lines\n\nclass Stack(Dashboard.Module):\n    '''Show the current stack trace including the function name and the file location, if available.\n\nOptionally list the frame arguments and locals too.'''\n\n    def label(self):\n        return 'Stack'\n\n    def lines(self, term_width, term_height, style_changed):\n        # skip if the current thread is not stopped\n        if not gdb.selected_thread().is_stopped():\n            return []\n        # find the selected frame level (XXX Frame.level() is a recent addition)\n        start_level = 0\n        frame = gdb.newest_frame()\n        while frame:\n            if frame == gdb.selected_frame():\n                break\n            frame = frame.older()\n            start_level += 1\n        # gather the frames\n        more = False\n        frames = [gdb.selected_frame()]\n        going_down = True\n        while True:\n            # stack frames limit reached\n            if len(frames) == self.limit:\n                more = True\n                break\n            # zigzag the frames starting from the selected one\n            if going_down:\n                frame = frames[-1].older()\n                if frame:\n                    frames.append(frame)\n                else:\n                    frame = frames[0].newer()\n                    if frame:\n                        frames.insert(0, frame)\n                        start_level -= 1\n                    else:\n                        break\n            else:\n                frame = frames[0].newer()\n                if frame:\n                    frames.insert(0, frame)\n                    start_level -= 1\n                else:\n                    frame = frames[-1].older()\n                    if frame:\n                        frames.append(frame)\n                    else:\n                        break\n            # switch direction\n            going_down = not going_down\n        # format the output\n        lines = []\n        for number, frame in enumerate(frames, start=start_level):\n            selected = frame == gdb.selected_frame()\n            lines.extend(self.get_frame_lines(number, frame, selected))\n        # add the placeholder\n        if more:\n            lines.append('[{}]'.format(ansi('+', R.style_selected_2)))\n        return lines\n\n    def attributes(self):\n        return {\n            'limit': {\n                'doc': 'Maximum number of displayed frames (0 means no limit).',\n                'default': 10,\n                'type': int,\n                'check': check_ge_zero\n            },\n            'arguments': {\n                'doc': 'Frame arguments visibility flag.',\n                'default': False,\n                'name': 'show_arguments',\n                'type': bool\n            },\n            'locals': {\n                'doc': 'Frame locals visibility flag.',\n                'default': False,\n                'name': 'show_locals',\n                'type': bool\n            },\n            'compact': {\n                'doc': 'Single-line display flag.',\n                'default': False,\n                'type': bool\n            },\n            'align': {\n                'doc': 'Align variables in column flag (only if not compact).',\n                'default': False,\n                'type': bool\n            },\n            'sort': {\n                'doc': 'Sort variables by name.',\n                'default': False,\n                'type': bool\n            }\n        }\n\n    def get_frame_lines(self, number, frame, selected=False):\n        # fetch frame info\n        style = R.style_selected_1 if selected else R.style_selected_2\n        frame_id = ansi(str(number), style)\n        info = Stack.get_pc_line(frame, style)\n        frame_lines = []\n        frame_lines.append('[{}] {}'.format(frame_id, info))\n        # add frame arguments and locals\n        variables = Variables.format_frame(\n            frame, self.show_arguments, self.show_locals, self.compact, self.align, self.sort)\n        frame_lines.extend(variables)\n        return frame_lines\n\n    @staticmethod\n    def format_line(prefix, line):\n        prefix = ansi(prefix, R.style_low)\n        return '{} {}'.format(prefix, line)\n\n    @staticmethod\n    def get_pc_line(frame, style):\n        frame_pc = ansi(format_address(frame.pc()), style)\n        info = 'from {}'.format(frame_pc)\n        # if a frame function symbol is available then use it to fetch the\n        # current function name and address, otherwise fall back relying on the\n        # frame name\n        if frame.function():\n            name = ansi(frame.function(), style)\n            func_start = to_unsigned(frame.function().value())\n            offset = ansi(str(frame.pc() - func_start), style)\n            info += ' in {}+{}'.format(name, offset)\n        elif frame.name():\n            name = ansi(frame.name(), style)\n            info += ' in {}'.format(name)\n        sal = frame.find_sal()\n        if sal and sal.symtab:\n            file_name = ansi(sal.symtab.filename, style)\n            file_line = ansi(str(sal.line), style)\n            info += ' at {}:{}'.format(file_name, file_line)\n        return info\n\nclass History(Dashboard.Module):\n    '''List the last entries of the value history.'''\n\n    def label(self):\n        return 'History'\n\n    def lines(self, term_width, term_height, style_changed):\n        out = []\n        # fetch last entries\n        for i in range(-self.limit + 1, 1):\n            try:\n                value = format_value(gdb.history(i))\n                value_id = ansi('$${}', R.style_high).format(abs(i))\n                equal = ansi('=', R.style_low)\n                line = '{} {} {}'.format(value_id, equal, value)\n                out.append(line)\n            except gdb.error:\n                continue\n        return out\n\n    def attributes(self):\n        return {\n            'limit': {\n                'doc': 'Maximum number of values to show.',\n                'default': 3,\n                'type': int,\n                'check': check_gt_zero\n            }\n        }\n\nclass Memory(Dashboard.Module):\n    '''Allow to inspect memory regions.'''\n\n    DEFAULT_LENGTH = 16\n\n    class Region():\n        def __init__(self, expression, length, module):\n            self.expression = expression\n            self.length = length\n            self.module = module\n            self.original = None\n            self.latest = None\n\n        def reset(self):\n            self.original = None\n            self.latest = None\n\n        def format(self, per_line):\n            # fetch the memory content\n            try:\n                address = Memory.parse_as_address(self.expression)\n                inferior = gdb.selected_inferior()\n                memory = inferior.read_memory(address, self.length)\n                # set the original memory snapshot if needed\n                if not self.original:\n                    self.original = memory\n            except gdb.error as e:\n                msg = 'Cannot access {} bytes starting at {}: {}'\n                msg = msg.format(self.length, self.expression, e)\n                return [ansi(msg, R.style_error)]\n            # format the memory content\n            out = []\n            for i in range(0, len(memory), per_line):\n                region = memory[i:i + per_line]\n                pad = per_line - len(region)\n                address_str = format_address(address + i)\n                # compute changes\n                hexa = []\n                text = []\n                for j in range(len(region)):\n                    rel = i + j\n                    byte = memory[rel]\n                    hexa_byte = '{:02x}'.format(ord(byte))\n                    text_byte = self.module.format_byte(byte)\n                    # differences against the latest have the highest priority\n                    if self.latest and memory[rel] != self.latest[rel]:\n                        hexa_byte = ansi(hexa_byte, R.style_selected_1)\n                        text_byte = ansi(text_byte, R.style_selected_1)\n                    # cumulative changes if enabled\n                    elif self.module.cumulative and memory[rel] != self.original[rel]:\n                        hexa_byte = ansi(hexa_byte, R.style_selected_2)\n                        text_byte = ansi(text_byte, R.style_selected_2)\n                    # format the text differently for clarity\n                    else:\n                        text_byte = ansi(text_byte, R.style_high)\n                    hexa.append(hexa_byte)\n                    text.append(text_byte)\n                # output the formatted line\n                hexa_placeholder = ' {}'.format(self.module.placeholder[0] * 2)\n                text_placeholder = self.module.placeholder[0]\n                out.append('{}  {}{}  {}{}'.format(\n                    ansi(address_str, R.style_low),\n                    ' '.join(hexa), ansi(pad * hexa_placeholder, R.style_low),\n                    ''.join(text), ansi(pad * text_placeholder, R.style_low)))\n            # update the latest memory snapshot\n            self.latest = memory\n            return out\n\n    def __init__(self):\n        self.table = {}\n\n    def label(self):\n        return 'Memory'\n\n    def lines(self, term_width, term_height, style_changed):\n        out = []\n        for expression, region in self.table.items():\n            out.append(divider(term_width, expression))\n            out.extend(region.format(self.get_per_line(term_width)))\n        return out\n\n    def commands(self):\n        return {\n            'watch': {\n                'action': self.watch,\n                'doc': '''Watch a memory region by expression and length.\n\nThe length defaults to 16 bytes.''',\n                'complete': gdb.COMPLETE_EXPRESSION\n            },\n            'unwatch': {\n                'action': self.unwatch,\n                'doc': 'Stop watching a memory region by expression.',\n                'complete': gdb.COMPLETE_EXPRESSION\n            },\n            'clear': {\n                'action': self.clear,\n                'doc': 'Clear all the watched regions.'\n            }\n        }\n\n    def attributes(self):\n        return {\n            'cumulative': {\n                'doc': 'Highlight changes cumulatively, watch again to reset.',\n                'default': False,\n                'type': bool\n            },\n            'full': {\n                'doc': 'Take the whole horizontal space.',\n                'default': False,\n                'type': bool\n            },\n            'placeholder': {\n                'doc': 'Placeholder used for missing items and unprintable characters.',\n                'default': '·'\n            }\n        }\n\n    def watch(self, arg):\n        if arg:\n            expression, _, length_str = arg.partition(' ')\n            length = Memory.parse_as_address(length_str) if length_str else Memory.DEFAULT_LENGTH\n            # keep the length when the memory is watched to reset the changes\n            region = self.table.get(expression)\n            if region and not length_str:\n                region.reset()\n            else:\n                self.table[expression] = Memory.Region(expression, length, self)\n        else:\n            raise Exception('Specify a memory location')\n\n    def unwatch(self, arg):\n        if arg:\n            try:\n                del self.table[arg]\n            except KeyError:\n                raise Exception('Memory expression not watched')\n        else:\n            raise Exception('Specify a matched memory expression')\n\n    def clear(self, arg):\n        self.table.clear()\n\n    def format_byte(self, byte):\n        # `type(byte) is bytes` in Python 3\n        if 0x20 < ord(byte) < 0x7f:\n            return chr(ord(byte))\n        else:\n            return self.placeholder[0]\n\n    def get_per_line(self, term_width):\n        if self.full:\n            padding = 3  # two double spaces separator (one is part of below)\n            elem_size = 4 # HH + 1 space + T\n            address_length = gdb.parse_and_eval('$pc').type.sizeof * 2 + 2  # 0x\n            return max(int((term_width - address_length - padding) / elem_size), 1)\n        else:\n            return Memory.DEFAULT_LENGTH\n\n    @staticmethod\n    def parse_as_address(expression):\n        value = gdb.parse_and_eval(expression)\n        return to_unsigned(value)\n\nclass Registers(Dashboard.Module):\n    '''Show the CPU registers and their values.'''\n\n    def __init__(self):\n        self.table = {}\n\n    def label(self):\n        return 'Registers'\n\n    def lines(self, term_width, term_height, style_changed):\n        # skip if the current thread is not stopped\n        if not gdb.selected_thread().is_stopped():\n            return []\n        # obtain the registers to display\n        if style_changed:\n            self.table = {}\n        if self.register_list:\n            register_list = self.register_list.split()\n        else:\n            register_list = Registers.fetch_register_list()\n        # fetch registers status\n        registers = []\n        for name in register_list:\n            # exclude registers with a dot '.' or parse_and_eval() will fail\n            if '.' in name:\n                continue\n            value = gdb.parse_and_eval('${}'.format(name))\n            string_value = Registers.format_value(value)\n            # exclude unavailable registers (see #255)\n            if string_value == '<unavailable>':\n                continue\n            changed = self.table and (self.table.get(name, '') != string_value)\n            self.table[name] = string_value\n            registers.append((name, string_value, changed))\n        # handle the empty register list\n        if not registers:\n            msg = 'No registers to show (check the \"dashboard registers -style list\" attribute)'\n            return [ansi(msg, R.style_error)]\n        # compute lengths considering an extra space between and around the\n        # entries (hence the +2 and term_width - 1)\n        max_name = max(len(name) for name, _, _ in registers)\n        max_value = max(len(value) for _, value, _ in registers)\n        max_width = max_name + max_value + 2\n        columns = min(int((term_width - 1) / max_width) or 1, len(registers))\n        rows = int(math.ceil(float(len(registers)) / columns))\n        # build the registers matrix\n        if self.column_major:\n            matrix = list(registers[i:i + rows] for i in range(0, len(registers), rows))\n        else:\n            matrix = list(registers[i::columns] for i in range(columns))\n        # compute the lengths column wise\n        max_names_column = list(max(len(name) for name, _, _ in column) for column in matrix)\n        max_values_column = list(max(len(value) for _, value, _ in column) for column in matrix)\n        line_length = sum(max_names_column) + columns + sum(max_values_column)\n        extra = term_width - line_length\n        # compute padding as if there were one more column\n        base_padding = int(extra / (columns + 1))\n        padding_column = [base_padding] * columns\n        # distribute the remainder among columns giving the precedence to\n        # internal padding\n        rest = extra % (columns + 1)\n        while rest:\n            padding_column[rest % columns] += 1\n            rest -= 1\n        # format the registers\n        out = [''] * rows\n        for i, column in enumerate(matrix):\n            max_name = max_names_column[i]\n            max_value = max_values_column[i]\n            for j, (name, value, changed) in enumerate(column):\n                name = ' ' * (max_name - len(name)) + ansi(name, R.style_low)\n                style = R.style_selected_1 if changed else ''\n                value = ansi(value, style) + ' ' * (max_value - len(value))\n                padding = ' ' * padding_column[i]\n                item = '{}{} {}'.format(padding, name, value)\n                out[j] += item\n        return out\n\n    def attributes(self):\n        return {\n            'column-major': {\n                'doc': 'Show registers in columns instead of rows.',\n                'default': False,\n                'name': 'column_major',\n                'type': bool\n            },\n            'list': {\n                'doc': '''String of space-separated register names to display.\n\nThe empty list (default) causes to show all the available registers. For\narchitectures different from x86 setting this attribute might be mandatory.''',\n                'default': '',\n                'name': 'register_list',\n            }\n        }\n\n    @staticmethod\n    def format_value(value):\n        try:\n            if value.type.code in [gdb.TYPE_CODE_INT, gdb.TYPE_CODE_PTR]:\n                int_value = to_unsigned(value, value.type.sizeof)\n                value_format = '0x{{:0{}x}}'.format(2 * value.type.sizeof)\n                return value_format.format(int_value)\n        except (gdb.error, ValueError):\n            # convert to unsigned but preserve code and flags information\n            pass\n        return str(value)\n\n    @staticmethod\n    def fetch_register_list(*match_groups):\n        names = []\n        for line in run('maintenance print register-groups').split('\\n'):\n            fields = line.split()\n            if len(fields) != 7:\n                continue\n            name, _, _, _, _, _, groups = fields\n            if not re.match(r'\\w', name):\n                continue\n            for group in groups.split(','):\n                if group in (match_groups or ('general',)):\n                    names.append(name)\n                    break\n        return names\n\nclass Threads(Dashboard.Module):\n    '''List the currently available threads.'''\n\n    def label(self):\n        return 'Threads'\n\n    def lines(self, term_width, term_height, style_changed):\n        out = []\n        selected_thread = gdb.selected_thread()\n        # do not restore the selected frame if the thread is not stopped\n        restore_frame = gdb.selected_thread().is_stopped()\n        if restore_frame:\n            selected_frame = gdb.selected_frame()\n        # fetch the thread list\n        threads = []\n        for inferior in gdb.inferiors():\n            if self.all_inferiors or inferior == gdb.selected_inferior():\n                threads += gdb.Inferior.threads(inferior)\n        for thread in threads:\n            # skip running threads if requested\n            if self.skip_running and thread.is_running():\n                continue\n            is_selected = (thread.ptid == selected_thread.ptid)\n            style = R.style_selected_1 if is_selected else R.style_selected_2\n            if self.all_inferiors:\n                number = '{}.{}'.format(thread.inferior.num, thread.num)\n            else:\n                number = str(thread.num)\n            number = ansi(number, style)\n            tid = ansi(str(thread.ptid[1] or thread.ptid[2]), style)\n            info = '[{}] id {}'.format(number, tid)\n            if thread.name:\n                info += ' name {}'.format(ansi(thread.name, style))\n            # switch thread to fetch info (unless is running in non-stop mode)\n            try:\n                thread.switch()\n                frame = gdb.newest_frame()\n                info += ' ' + Stack.get_pc_line(frame, style)\n            except gdb.error:\n                info += ' (running)'\n            out.append(info)\n        # restore thread and frame\n        selected_thread.switch()\n        if restore_frame:\n            selected_frame.select()\n        return out\n\n    def attributes(self):\n        return {\n            'skip-running': {\n                'doc': 'Skip running threads.',\n                'default': False,\n                'name': 'skip_running',\n                'type': bool\n            },\n            'all-inferiors': {\n                'doc': 'Show threads from all inferiors.',\n                'default': False,\n                'name': 'all_inferiors',\n                'type': bool\n            },\n        }\n\nclass Expressions(Dashboard.Module):\n    '''Watch user expressions.'''\n\n    def __init__(self):\n        self.table = []\n\n    def label(self):\n        return 'Expressions'\n\n    def lines(self, term_width, term_height, style_changed):\n        out = []\n        label_width = 0\n        if self.align:\n            label_width = max(len(expression) for expression in self.table) if self.table else 0\n        default_radix = Expressions.get_default_radix()\n        for number, expression in enumerate(self.table, start=1):\n            label = expression\n            match = re.match(r'^/(\\d+) +(.+)$', expression)\n            try:\n                if match:\n                    radix, expression = match.groups()\n                    run('set output-radix {}'.format(radix))\n                value = format_value(gdb.parse_and_eval(expression))\n            except gdb.error as e:\n                value = ansi(e, R.style_error)\n            finally:\n                if match:\n                    run('set output-radix {}'.format(default_radix))\n            number = ansi(str(number), R.style_selected_2)\n            label = ansi(expression, R.style_high) + ' ' * (label_width - len(expression))\n            equal = ansi('=', R.style_low)\n            out.append('[{}] {} {} {}'.format(number, label, equal, value))\n        return out\n\n    def commands(self):\n        return {\n            'watch': {\n                'action': self.watch,\n                'doc': 'Watch an expression using the format `[/<radix>] <expression>`.',\n                'complete': gdb.COMPLETE_EXPRESSION\n            },\n            'unwatch': {\n                'action': self.unwatch,\n                'doc': 'Stop watching an expression by index.'\n            },\n            'clear': {\n                'action': self.clear,\n                'doc': 'Clear all the watched expressions.'\n            }\n        }\n\n    def attributes(self):\n        return {\n            'align': {\n                'doc': 'Align variables in column flag.',\n                'default': False,\n                'type': bool\n            }\n        }\n\n    def watch(self, arg):\n        if arg:\n            if arg not in self.table:\n                self.table.append(arg)\n            else:\n                raise Exception('Expression already watched')\n        else:\n            raise Exception('Specify an expression')\n\n    def unwatch(self, arg):\n        if arg:\n            try:\n                number = int(arg) - 1\n            except:\n                number = -1\n            if 0 <= number < len(self.table):\n                self.table.pop(number)\n            else:\n                raise Exception('Expression not watched')\n        else:\n            raise Exception('Specify an expression')\n\n    def clear(self, arg):\n        self.table.clear()\n\n    @staticmethod\n    def get_default_radix():\n        try:\n            return gdb.parameter('output-radix')\n        except RuntimeError:\n            # XXX this is a fix for GDB <8.1.x see #161\n            message = run('show output-radix')\n            match = re.match(r'^Default output radix for printing of values is (\\d+)\\.$', message)\n            return match.groups()[0] if match else 10  # fallback\n\n# XXX workaround to support BP_BREAKPOINT in older GDB versions\nsetattr(gdb, 'BP_CATCHPOINT', getattr(gdb, 'BP_CATCHPOINT', 26))\n\nclass Breakpoints(Dashboard.Module):\n    '''Display the breakpoints list.'''\n\n    NAMES = {\n        gdb.BP_BREAKPOINT: 'break',\n        gdb.BP_WATCHPOINT: 'watch',\n        gdb.BP_HARDWARE_WATCHPOINT: 'write watch',\n        gdb.BP_READ_WATCHPOINT: 'read watch',\n        gdb.BP_ACCESS_WATCHPOINT: 'access watch',\n        gdb.BP_CATCHPOINT: 'catch'\n    }\n\n    def label(self):\n        return 'Breakpoints'\n\n    def lines(self, term_width, term_height, style_changed):\n        out = []\n        breakpoints = fetch_breakpoints(watchpoints=True, pending=self.show_pending)\n        for breakpoint in breakpoints:\n            sub_lines = []\n            # format common information\n            style = R.style_selected_1 if breakpoint['enabled'] else R.style_selected_2\n            number = ansi(breakpoint['number'], style)\n            bp_type = ansi(Breakpoints.NAMES[breakpoint['type']], style)\n            if breakpoint['temporary']:\n                bp_type = bp_type + ' {}'.format(ansi('once', style))\n            if not R.ansi and breakpoint['enabled']:\n                bp_type = 'disabled ' + bp_type\n            line = '[{}] {}'.format(number, bp_type)\n            if breakpoint['type'] == gdb.BP_BREAKPOINT:\n                for i, address in enumerate(breakpoint['addresses']):\n                    addr = address['address']\n                    if i == 0 and addr:\n                        # this is a regular breakpoint\n                        line += ' at {}'.format(ansi(format_address(addr), style))\n                        # format source information\n                        file_name = address.get('file_name')\n                        file_line = address.get('file_line')\n                        if file_name and file_line:\n                            file_name = ansi(file_name, style)\n                            file_line = ansi(file_line, style)\n                            line += ' in {}:{}'.format(file_name, file_line)\n                    elif i > 0:\n                        # this is a sub breakpoint\n                        sub_style = R.style_selected_1 if address['enabled'] else R.style_selected_2\n                        sub_number = ansi('{}.{}'.format(breakpoint['number'], i), sub_style)\n                        sub_line = '[{}]'.format(sub_number)\n                        sub_line += ' at {}'.format(ansi(format_address(addr), sub_style))\n                        # format source information\n                        file_name = address.get('file_name')\n                        file_line = address.get('file_line')\n                        if file_name and file_line:\n                            file_name = ansi(file_name, sub_style)\n                            file_line = ansi(file_line, sub_style)\n                            sub_line += ' in {}:{}'.format(file_name, file_line)\n                        sub_lines += [sub_line]\n                # format user location\n                location = breakpoint['location']\n                line += ' for {}'.format(ansi(location, style))\n            elif breakpoint['type'] == gdb.BP_CATCHPOINT:\n                what = breakpoint['what']\n                line += ' {}'.format(ansi(what, style))\n            else:\n                # format user expression\n                expression = breakpoint['expression']\n                line += ' for {}'.format(ansi(expression, style))\n            # format condition\n            condition = breakpoint['condition']\n            if condition:\n                line += ' if {}'.format(ansi(condition, style))\n            # format hit count\n            hit_count = breakpoint['hit_count']\n            if hit_count:\n                word = 'time{}'.format('s' if hit_count > 1 else '')\n                line += ' hit {} {}'.format(ansi(breakpoint['hit_count'], style), word)\n            # append the main line and possibly sub breakpoints\n            out.append(line)\n            out.extend(sub_lines)\n        return out\n\n    def attributes(self):\n        return {\n            'pending': {\n                'doc': 'Also show pending breakpoints.',\n                'default': True,\n                'name': 'show_pending',\n                'type': bool\n            }\n        }\n\n# XXX traceback line numbers in this Python block must be increased by 1\nend\n\n# Better GDB defaults ----------------------------------------------------------\n\nset history save\nset verbose off\nset print pretty on\nset print array off\nset print array-indexes on\nset python print-stack full\n\n# Start ------------------------------------------------------------------------\n\npython Dashboard.start()\n\n# File variables ---------------------------------------------------------------\n\n# vim: filetype=python\n# Local Variables:\n# mode: python\n# End:\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0595703125,
          "content": "Copyright (c) 2015-2024 Andrea Cardaci <cyrus.and@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 1.259765625,
          "content": "# GDB dashboard\n\nGDB dashboard is a standalone `.gdbinit` file written using the [Python API][] that enables a modular interface showing relevant information about the program being debugged. Its main goal is to reduce the number of GDB commands needed to inspect the status of current program thus allowing the developer to primarily focus on the control flow.\n\n![Screenshot](https://raw.githubusercontent.com/wiki/cyrus-and/gdb-dashboard/Screenshot.png)\n\n[Python API]: https://sourceware.org/gdb/onlinedocs/gdb/Python-API.html\n\n## Quickstart\n\nJust place [`.gdbinit`][] in your home directory, for example with:\n\n```\nwget -P ~ https://github.com/cyrus-and/gdb-dashboard/raw/master/.gdbinit\n```\n\nOptionally install [Pygments][] to enable syntax highlighting:\n\n```\npip install pygments\n```\n\nThen debug as usual, the dashboard will appear automatically every time the inferior program stops.\n\nKeep in mind that no GDB command has been redefined, instead all the features are available via the main `dashboard` command (see `help dashboard`).\n\nHead to the [wiki][] to learn how to perform the most important tasks.\n\n[`.gdbinit`]: https://raw.githubusercontent.com/cyrus-and/gdb-dashboard/master/.gdbinit\n[Pygments]: http://pygments.org/\n[wiki]: https://github.com/cyrus-and/gdb-dashboard/wiki\n"
        }
      ]
    }
  ]
}