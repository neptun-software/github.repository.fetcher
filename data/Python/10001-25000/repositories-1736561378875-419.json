{
  "metadata": {
    "timestamp": 1736561378875,
    "page": 419,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "TheR1D/shell_gpt",
      "stars": 10077,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".devcontainer",
          "type": "tree",
          "content": null
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 2.4677734375,
          "content": "# Contributing to ShellGPT\nThank you for considering contributing to ShellGPT! To ensure a smooth and enjoyable experience for everyone, please follow the steps outlined below.\n\n## Find an Issue to Work On\n- First, browse the existing issues to find one that interests you. If you find an issue you'd like to work on, assign it to yourself and leave a comment expressing your interest.\n- If you have a new feature idea that doesn't have an existing issue, please create a discussion in the \"ideas\" category using GitHub Discussions. Gather feedback from the community, and if you receive approval from at least a couple of people, create an issue and assign it to yourself.\n- If there is an urgent issue, such as a critical bug causing the app to crash, create a pull request immediately.\n\n## Development\nShellGPT is written with strict types, so you'll need to define types. The project uses several linting and testing tools: ruff, mypy, isort, black, and pytest.\n\n### Virtual Environment\nCreate and activate a virtual environment using Python venv:\n\n```shell\npython -m venv env && source ./env/bin/activate\n```\n\n### Install Dependencies\nInstall the necessary dependencies, including development and test dependencies:\n\n```shell\npip install -e .\"[dev,test]\"\n```\n\n### Start Coding\nWith your environment set up and the issue assigned, you can start working on your solution. Get to know the existing codebase and adhere to the project's coding style and conventions. Write clean, modular, and maintainable code to facilitate understanding and review. Commit your changes frequently to document your progress.\n\n### Testing\n**This is a crucial step.** Any changes that implement a new feature or modify existing features should include tests. **Unverified code will not be merged.** These tests should call `sgpt` with defined arguments, capture the output, and verify that the feature works as expected. Refer to the `tests` folder for examples.\n\n### Pull Request\nBefore creating a pull request, run `scripts/lint.sh` and `scripts/tests.sh` to ensure all linters and tests pass. In your pull request, provide a high-level description of your changes and detailed instructions for testing them, including any necessary commands.\n\n### Code Review\nAfter submitting your pull request, be patient and receptive to feedback from reviewers. Address any concerns they raise and collaborate to refine the code. Together, we can enhance the ShellGPT project.\n\nThank you once again for your contribution! We're excited to have you join us."
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 0.28125,
          "content": "FROM python:3-slim\n\nENV SHELL_INTERACTION=false\nENV PRETTIFY_MARKDOWN=false\nENV OS_NAME=auto\nENV SHELL_NAME=auto\n\nWORKDIR /app\nCOPY . /app\n\nRUN apt-get update && apt-get install -y gcc\nRUN pip install --no-cache /app && mkdir -p /tmp/shell_gpt\n\nVOLUME /tmp/shell_gpt\n\nENTRYPOINT [\"sgpt\"]\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.046875,
          "content": "MIT License\n\nCopyright (c) 2023 Farkhod Sadykov\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 26.2626953125,
          "content": "# ShellGPT\nA command-line productivity tool powered by AI large language models (LLM). This command-line tool offers streamlined generation of **shell commands, code snippets, documentation**, eliminating the need for external resources (like Google search). Supports Linux, macOS, Windows and compatible with all major Shells like PowerShell, CMD, Bash, Zsh, etc.\n\nhttps://github.com/TheR1D/shell_gpt/assets/16740832/9197283c-db6a-4b46-bfea-3eb776dd9093\n\n## Installation\n```shell\npip install shell-gpt\n```\nBy default, ShellGPT uses OpenAI's API and GPT-4 model. You'll need an API key, you can generate one [here](https://beta.openai.com/account/api-keys). You will be prompted for your key which will then be stored in `~/.config/shell_gpt/.sgptrc`. OpenAI API is not free of charge, please refer to the [OpenAI pricing](https://openai.com/pricing) for more information.\n\n> [!TIP]\n> Alternatively, you can use locally hosted open source models which are available for free. To use local models, you will need to run your own LLM backend server such as [Ollama](https://github.com/ollama/ollama). To set up ShellGPT with Ollama, please follow this comprehensive [guide](https://github.com/TheR1D/shell_gpt/wiki/Ollama).\n>\n> **❗️Note that ShellGPT is not optimized for local models and may not work as expected.**\n\n## Usage\n**ShellGPT** is designed to quickly analyse and retrieve information. It's useful for straightforward requests ranging from technical configurations to general knowledge.\n```shell\nsgpt \"What is the fibonacci sequence\"\n# -> The Fibonacci sequence is a series of numbers where each number ...\n```\n\nShellGPT accepts prompt from both stdin and command line argument. Whether you prefer piping input through the terminal or specifying it directly as arguments, `sgpt` got you covered. For example, you can easily generate a git commit message based on a diff:\n```shell\ngit diff | sgpt \"Generate git commit message, for my changes\"\n# -> Added main feature details into README.md\n```\n\nYou can analyze logs from various sources by passing them using stdin, along with a prompt. For instance, we can use it to quickly analyze logs, identify errors and get suggestions for possible solutions:\n```shell\ndocker logs -n 20 my_app | sgpt \"check logs, find errors, provide possible solutions\"\n```\n```text\nError Detected: Connection timeout at line 7.\nPossible Solution: Check network connectivity and firewall settings.\nError Detected: Memory allocation failed at line 12.\nPossible Solution: Consider increasing memory allocation or optimizing application memory usage.\n```\n\nYou can also use all kind of redirection operators to pass input:\n```shell\nsgpt \"summarise\" < document.txt\n# -> The document discusses the impact...\nsgpt << EOF\nWhat is the best way to lear Golang?\nProvide simple hello world example.\nEOF\n# -> The best way to learn Golang...\nsgpt <<< \"What is the best way to learn shell redirects?\"\n# -> The best way to learn shell redirects is through...\n```\n\n\n### Shell commands\nHave you ever found yourself forgetting common shell commands, such as `find`, and needing to look up the syntax online? With `--shell` or shortcut `-s` option, you can quickly generate and execute the commands you need right in the terminal.\n```shell\nsgpt --shell \"find all json files in current folder\"\n# -> find . -type f -name \"*.json\"\n# -> [E]xecute, [D]escribe, [A]bort: e\n```\n\nShell GPT is aware of OS and `$SHELL` you are using, it will provide shell command for specific system you have. For instance, if you ask `sgpt` to update your system, it will return a command based on your OS. Here's an example using macOS:\n```shell\nsgpt -s \"update my system\"\n# -> sudo softwareupdate -i -a\n# -> [E]xecute, [D]escribe, [A]bort: e\n```\n\nThe same prompt, when used on Ubuntu, will generate a different suggestion:\n```shell\nsgpt -s \"update my system\"\n# -> sudo apt update && sudo apt upgrade -y\n# -> [E]xecute, [D]escribe, [A]bort: e\n```\n\nLet's try it with Docker:\n```shell\nsgpt -s \"start nginx container, mount ./index.html\"\n# -> docker run -d -p 80:80 -v $(pwd)/index.html:/usr/share/nginx/html/index.html nginx\n# -> [E]xecute, [D]escribe, [A]bort: e\n```\n\nWe can still use pipes to pass input to `sgpt` and generate shell commands:\n```shell\nsgpt -s \"POST localhost with\" < data.json\n# -> curl -X POST -H \"Content-Type: application/json\" -d '{\"a\": 1, \"b\": 2}' http://localhost\n# -> [E]xecute, [D]escribe, [A]bort: e\n```\n\nApplying additional shell magic in our prompt, in this example passing file names to `ffmpeg`:\n```shell\nls\n# -> 1.mp4 2.mp4 3.mp4\nsgpt -s \"ffmpeg combine $(ls -m) into one video file without audio.\"\n# -> ffmpeg -i 1.mp4 -i 2.mp4 -i 3.mp4 -filter_complex \"[0:v] [1:v] [2:v] concat=n=3:v=1 [v]\" -map \"[v]\" out.mp4\n# -> [E]xecute, [D]escribe, [A]bort: e\n```\n\nIf you would like to pass generated shell command using pipe, you can use `--no-interaction` option. This will disable interactive mode and will print generated command to stdout. In this example we are using `pbcopy` to copy generated command to clipboard:\n```shell\nsgpt -s \"find all json files in current folder\" --no-interaction | pbcopy\n```\n\n\n### Shell integration\nThis is a **very handy feature**, which allows you to use `sgpt` shell completions directly in your terminal, without the need to type `sgpt` with prompt and arguments. Shell integration enables the use of ShellGPT with hotkeys in your terminal, supported by both Bash and ZSH shells. This feature puts `sgpt` completions directly into terminal buffer (input line), allowing for immediate editing of suggested commands.\n\nhttps://github.com/TheR1D/shell_gpt/assets/16740832/bead0dab-0dd9-436d-88b7-6abfb2c556c1\n\nTo install shell integration, run `sgpt --install-integration` and restart your terminal to apply changes. This will add few lines to your `.bashrc` or `.zshrc` file. After that, you can use `Ctrl+l` (by default) to invoke ShellGPT. When you press `Ctrl+l` it will replace you current input line (buffer) with suggested command. You can then edit it and just press `Enter` to execute.\n\n### Generating code\nBy using the `--code` or `-c` parameter, you can specifically request pure code output, for instance:\n```shell\nsgpt --code \"solve fizz buzz problem using python\"\n```\n\n```python\nfor i in range(1, 101):\n    if i % 3 == 0 and i % 5 == 0:\n        print(\"FizzBuzz\")\n    elif i % 3 == 0:\n        print(\"Fizz\")\n    elif i % 5 == 0:\n        print(\"Buzz\")\n    else:\n        print(i)\n```\nSince it is valid python code, we can redirect the output to a file:  \n```shell\nsgpt --code \"solve classic fizz buzz problem using Python\" > fizz_buzz.py\npython fizz_buzz.py\n# 1\n# 2\n# Fizz\n# 4\n# Buzz\n# ...\n```\n\nWe can also use pipes to pass input:\n```shell\ncat fizz_buzz.py | sgpt --code \"Generate comments for each line of my code\"\n```\n```python\n# Loop through numbers 1 to 100\nfor i in range(1, 101):\n    # Check if number is divisible by both 3 and 5\n    if i % 3 == 0 and i % 5 == 0:\n        # Print \"FizzBuzz\" if number is divisible by both 3 and 5\n        print(\"FizzBuzz\")\n    # Check if number is divisible by 3\n    elif i % 3 == 0:\n        # Print \"Fizz\" if number is divisible by 3\n        print(\"Fizz\")\n    # Check if number is divisible by 5\n    elif i % 5 == 0:\n        # Print \"Buzz\" if number is divisible by 5\n        print(\"Buzz\")\n    # If number is not divisible by 3 or 5, print the number itself\n    else:\n        print(i)\n```\n\n### Chat Mode \nOften it is important to preserve and recall a conversation. `sgpt` creates conversational dialogue with each LLM completion requested. The dialogue can develop one-by-one (chat mode) or interactively, in a REPL loop (REPL mode). Both ways rely on the same underlying object, called a chat session. The session is located at the [configurable](#runtime-configuration-file) `CHAT_CACHE_PATH`.\n\nTo start a conversation, use the `--chat` option followed by a unique session name and a prompt.\n```shell\nsgpt --chat conversation_1 \"please remember my favorite number: 4\"\n# -> I will remember that your favorite number is 4.\nsgpt --chat conversation_1 \"what would be my favorite number + 4?\"\n# -> Your favorite number is 4, so if we add 4 to it, the result would be 8.\n```\n\nYou can use chat sessions to iteratively improve GPT suggestions by providing additional details.  It is possible to use `--code` or `--shell` options to initiate `--chat`:\n```shell\nsgpt --chat conversation_2 --code \"make a request to localhost using python\"\n```\n```python\nimport requests\n\nresponse = requests.get('http://localhost')\nprint(response.text)\n```\n\nLet's ask LLM to add caching to our request:\n```shell\nsgpt --chat conversation_2 --code \"add caching\"\n```\n```python\nimport requests\nfrom cachecontrol import CacheControl\n\nsess = requests.session()\ncached_sess = CacheControl(sess)\n\nresponse = cached_sess.get('http://localhost')\nprint(response.text)\n```\n\nSame applies for shell commands:\n```shell\nsgpt --chat conversation_3 --shell \"what is in current folder\"\n# -> ls\nsgpt --chat conversation_3 \"Sort by name\"\n# -> ls | sort\nsgpt --chat conversation_3 \"Concatenate them using FFMPEG\"\n# -> ffmpeg -i \"concat:$(ls | sort | tr '\\n' '|')\" -codec copy output.mp4\nsgpt --chat conversation_3 \"Convert the resulting file into an MP3\"\n# -> ffmpeg -i output.mp4 -vn -acodec libmp3lame -ac 2 -ab 160k -ar 48000 final_output.mp3\n```\n\nTo list all the sessions from either conversational mode, use the `--list-chats` or `-lc` option:  \n```shell\nsgpt --list-chats\n# .../shell_gpt/chat_cache/conversation_1  \n# .../shell_gpt/chat_cache/conversation_2\n```\n\nTo show all the messages related to a specific conversation, use the `--show-chat` option followed by the session name:\n```shell\nsgpt --show-chat conversation_1\n# user: please remember my favorite number: 4\n# assistant: I will remember that your favorite number is 4.\n# user: what would be my favorite number + 4?\n# assistant: Your favorite number is 4, so if we add 4 to it, the result would be 8.\n```\n\n### REPL Mode  \nThere is very handy REPL (read–eval–print loop) mode, which allows you to interactively chat with GPT models. To start a chat session in REPL mode, use the `--repl` option followed by a unique session name. You can also use \"temp\" as a session name to start a temporary REPL session. Note that `--chat` and `--repl` are using same underlying object, so you can use `--chat` to start a chat session and then pick it up with `--repl` to continue the conversation in REPL mode.\n\n<p align=\"center\">\n  <img src=\"https://s10.gifyu.com/images/repl-demo.gif\" alt=\"gif\">\n</p>\n\n```text\nsgpt --repl temp\nEntering REPL mode, press Ctrl+C to exit.\n>>> What is REPL?\nREPL stands for Read-Eval-Print Loop. It is a programming environment ...\n>>> How can I use Python with REPL?\nTo use Python with REPL, you can simply open a terminal or command prompt ...\n```\n\nREPL mode can work with `--shell` and `--code` options, which makes it very handy for interactive shell commands and code generation:\n```text\nsgpt --repl temp --shell\nEntering shell REPL mode, type [e] to execute commands or press Ctrl+C to exit.\n>>> What is in current folder?\nls\n>>> Show file sizes\nls -lh\n>>> Sort them by file sizes\nls -lhS\n>>> e (enter just e to execute commands, or d to describe them)\n```\n\nTo provide multiline prompt use triple quotes `\"\"\"`:\n```text\nsgpt --repl temp\nEntering REPL mode, press Ctrl+C to exit.\n>>> \"\"\"\n... Explain following code:\n... import random\n... print(random.randint(1, 10))\n... \"\"\"\nIt is a Python script that uses the random module to generate and print a random integer.\n```\n\nYou can also enter REPL mode with initial prompt by passing it as an argument or stdin or even both:\n```shell\nsgpt --repl temp < my_app.py\n```\n```text\nEntering REPL mode, press Ctrl+C to exit.\n──────────────────────────────────── Input ────────────────────────────────────\nname = input(\"What is your name?\")\nprint(f\"Hello {name}\")\n───────────────────────────────────────────────────────────────────────────────\n>>> What is this code about?\nThe snippet of code you've provided is written in Python. It prompts the user...\n>>> Follow up questions...\n```\n\n### Function calling  \n[Function calls](https://platform.openai.com/docs/guides/function-calling) is a powerful feature OpenAI provides. It allows LLM to execute functions in your system, which can be used to accomplish a variety of tasks. To install [default functions](https://github.com/TheR1D/shell_gpt/tree/main/sgpt/llm_functions/) run:\n```shell\nsgpt --install-functions\n```\n\nShellGPT has a convenient way to define functions and use them. In order to create your custom function, navigate to `~/.config/shell_gpt/functions` and create a new .py file with the function name. Inside this file, you can define your function using the following syntax:\n```python\n# execute_shell_command.py\nimport subprocess\nfrom pydantic import Field\nfrom instructor import OpenAISchema\n\n\nclass Function(OpenAISchema):\n    \"\"\"\n    Executes a shell command and returns the output (result).\n    \"\"\"\n    shell_command: str = Field(..., example=\"ls -la\", descriptions=\"Shell command to execute.\")\n\n    class Config:\n        title = \"execute_shell_command\"\n\n    @classmethod\n    def execute(cls, shell_command: str) -> str:\n        result = subprocess.run(shell_command.split(), capture_output=True, text=True)\n        return f\"Exit code: {result.returncode}, Output:\\n{result.stdout}\"\n```\n\nThe docstring comment inside the class will be passed to OpenAI API as a description for the function, along with the `title` attribute and parameters descriptions. The `execute` function will be called if LLM decides to use your function. In this case we are allowing LLM to execute any Shell commands in our system. Since we are returning the output of the command, LLM will be able to analyze it and decide if it is a good fit for the prompt. Here is an example how the function might be executed by LLM:\n```shell\nsgpt \"What are the files in /tmp folder?\"\n# -> @FunctionCall execute_shell_command(shell_command=\"ls /tmp\")\n# -> The /tmp folder contains the following files and directories:\n# -> test.txt\n# -> test.json\n```\n\nNote that if for some reason the function (execute_shell_command) will return an error, LLM might try to accomplish the task based on the output. Let's say we don't have installed `jq` in our system, and we ask LLM to parse JSON file:\n```shell\nsgpt \"parse /tmp/test.json file using jq and return only email value\"\n# -> @FunctionCall execute_shell_command(shell_command=\"jq -r '.email' /tmp/test.json\")\n# -> It appears that jq is not installed on the system. Let me try to install it using brew.\n# -> @FunctionCall execute_shell_command(shell_command=\"brew install jq\")\n# -> jq has been successfully installed. Let me try to parse the file again.\n# -> @FunctionCall execute_shell_command(shell_command=\"jq -r '.email' /tmp/test.json\")\n# -> The email value in /tmp/test.json is johndoe@example.\n```\n\nIt is also possible to chain multiple function calls in the prompt:\n```shell\nsgpt \"Play music and open hacker news\"\n# -> @FunctionCall play_music()\n# -> @FunctionCall open_url(url=\"https://news.ycombinator.com\")\n# -> Music is now playing, and Hacker News has been opened in your browser. Enjoy!\n```\n\nThis is just a simple example of how you can use function calls. It is truly a powerful feature that can be used to accomplish a variety of complex tasks. We have dedicated [category](https://github.com/TheR1D/shell_gpt/discussions/categories/functions) in GitHub Discussions for sharing and discussing functions. \nLLM might execute destructive commands, so please use it at your own risk❗️\n\n### Roles\nShellGPT allows you to create custom roles, which can be utilized to generate code, shell commands, or to fulfill your specific needs. To create a new role, use the `--create-role` option followed by the role name. You will be prompted to provide a description for the role, along with other details. This will create a JSON file in `~/.config/shell_gpt/roles` with the role name. Inside this directory, you can also edit default `sgpt` roles, such as **shell**, **code**, and **default**. Use the `--list-roles` option to list all available roles, and the `--show-role` option to display the details of a specific role. Here's an example of a custom role:\n```shell\nsgpt --create-role json_generator\n# Enter role description: Provide only valid json as response.\nsgpt --role json_generator \"random: user, password, email, address\"\n```\n```json\n{\n  \"user\": \"JohnDoe\",\n  \"password\": \"p@ssw0rd\",\n  \"email\": \"johndoe@example.com\",\n  \"address\": {\n    \"street\": \"123 Main St\",\n    \"city\": \"Anytown\",\n    \"state\": \"CA\",\n    \"zip\": \"12345\"\n  }\n}\n```\n\nIf the description of the role contains the words \"APPLY MARKDOWN\" (case sensitive), then chats will be displayed using markdown formatting.\n\n### Request cache\nControl cache using `--cache` (default) and `--no-cache` options. This caching applies for all `sgpt` requests to OpenAI API:\n```shell\nsgpt \"what are the colors of a rainbow\"\n# -> The colors of a rainbow are red, orange, yellow, green, blue, indigo, and violet.\n```\nNext time, same exact query will get results from local cache instantly. Note that `sgpt \"what are the colors of a rainbow\" --temperature 0.5` will make a new request, since we didn't provide `--temperature` (same applies to `--top-probability`) on previous request.\n\nThis is just some examples of what we can do using OpenAI GPT models, I'm sure you will find it useful for your specific use cases.\n\n### Runtime configuration file\nYou can setup some parameters in runtime configuration file `~/.config/shell_gpt/.sgptrc`:\n```text\n# API key, also it is possible to define OPENAI_API_KEY env.\nOPENAI_API_KEY=your_api_key\n# Base URL of the backend server. If \"default\" URL will be resolved based on --model.\nAPI_BASE_URL=default\n# Max amount of cached message per chat session.\nCHAT_CACHE_LENGTH=100\n# Chat cache folder.\nCHAT_CACHE_PATH=/tmp/shell_gpt/chat_cache\n# Request cache length (amount).\nCACHE_LENGTH=100\n# Request cache folder.\nCACHE_PATH=/tmp/shell_gpt/cache\n# Request timeout in seconds.\nREQUEST_TIMEOUT=60\n# Default OpenAI model to use.\nDEFAULT_MODEL=gpt-4o\n# Default color for shell and code completions.\nDEFAULT_COLOR=magenta\n# When in --shell mode, default to \"Y\" for no input.\nDEFAULT_EXECUTE_SHELL_CMD=false\n# Disable streaming of responses\nDISABLE_STREAMING=false\n# The pygment theme to view markdown (default/describe role).\nCODE_THEME=default\n# Path to a directory with functions.\nOPENAI_FUNCTIONS_PATH=/Users/user/.config/shell_gpt/functions\n# Print output of functions when LLM uses them.\nSHOW_FUNCTIONS_OUTPUT=false\n# Allows LLM to use functions.\nOPENAI_USE_FUNCTIONS=true\n# Enforce LiteLLM usage (for local LLMs).\nUSE_LITELLM=false\n```\nPossible options for `DEFAULT_COLOR`: black, red, green, yellow, blue, magenta, cyan, white, bright_black, bright_red, bright_green, bright_yellow, bright_blue, bright_magenta, bright_cyan, bright_white.\nPossible options for `CODE_THEME`: https://pygments.org/styles/\n\n### Full list of arguments\n```text\n╭─ Arguments ──────────────────────────────────────────────────────────────────────────────────────────────╮\n│   prompt      [PROMPT]  The prompt to generate completions for.                                          │\n╰──────────────────────────────────────────────────────────────────────────────────────────────────────────╯\n╭─ Options ────────────────────────────────────────────────────────────────────────────────────────────────╮\n│ --model            TEXT                       Large language model to use. [default: gpt-4o]             │\n│ --temperature      FLOAT RANGE [0.0<=x<=2.0]  Randomness of generated output. [default: 0.0]             │\n│ --top-p            FLOAT RANGE [0.0<=x<=1.0]  Limits highest probable tokens (words). [default: 1.0]     │\n│ --md             --no-md                      Prettify markdown output. [default: md]                    │\n│ --editor                                      Open $EDITOR to provide a prompt. [default: no-editor]     │\n│ --cache                                       Cache completion results. [default: cache]                 │\n│ --version                                     Show version.                                              │\n│ --help                                        Show this message and exit.                                │\n╰──────────────────────────────────────────────────────────────────────────────────────────────────────────╯\n╭─ Assistance Options ─────────────────────────────────────────────────────────────────────────────────────╮\n│ --shell           -s                      Generate and execute shell commands.                           │\n│ --interaction         --no-interaction    Interactive mode for --shell option. [default: interaction]    │\n│ --describe-shell  -d                      Describe a shell command.                                      │\n│ --code            -c                      Generate only code.                                            │\n│ --functions           --no-functions      Allow function calls. [default: functions]                     │\n╰──────────────────────────────────────────────────────────────────────────────────────────────────────────╯\n╭─ Chat Options ───────────────────────────────────────────────────────────────────────────────────────────╮\n│ --chat                 TEXT  Follow conversation with id, use \"temp\" for quick session. [default: None]  │\n│ --repl                 TEXT  Start a REPL (Read–eval–print loop) session. [default: None]                │\n│ --show-chat            TEXT  Show all messages from provided chat id. [default: None]                    │\n│ --list-chats  -lc            List all existing chat ids.                                                 │\n╰──────────────────────────────────────────────────────────────────────────────────────────────────────────╯\n╭─ Role Options ───────────────────────────────────────────────────────────────────────────────────────────╮\n│ --role                  TEXT  System role for GPT model. [default: None]                                 │\n│ --create-role           TEXT  Create role. [default: None]                                               │\n│ --show-role             TEXT  Show role. [default: None]                                                 │\n│ --list-roles   -lr            List roles.                                                                │\n╰──────────────────────────────────────────────────────────────────────────────────────────────────────────╯\n```\n\n## Docker\nRun the container using the `OPENAI_API_KEY` environment variable, and a docker volume to store cache. Consider to set the environment variables `OS_NAME` and `SHELL_NAME` according to your preferences.\n```shell\ndocker run --rm \\\n           --env OPENAI_API_KEY=api_key \\\n           --env OS_NAME=$(uname -s) \\\n           --env SHELL_NAME=$(echo $SHELL) \\\n           --volume gpt-cache:/tmp/shell_gpt \\\n       ghcr.io/ther1d/shell_gpt -s \"update my system\"\n```\n\nExample of a conversation, using an alias and the `OPENAI_API_KEY` environment variable:\n```shell\nalias sgpt=\"docker run --rm --volume gpt-cache:/tmp/shell_gpt --env OPENAI_API_KEY --env OS_NAME=$(uname -s) --env SHELL_NAME=$(echo $SHELL) ghcr.io/ther1d/shell_gpt\"\nexport OPENAI_API_KEY=\"your OPENAI API key\"\nsgpt --chat rainbow \"what are the colors of a rainbow\"\nsgpt --chat rainbow \"inverse the list of your last answer\"\nsgpt --chat rainbow \"translate your last answer in french\"\n```\n\nYou also can use the provided `Dockerfile` to build your own image:\n```shell\ndocker build -t sgpt .\n```\n\n### Docker + Ollama\n\nIf you want to send your requests to an Ollama instance and run ShellGPT inside a Docker container, you need to adjust the Dockerfile and build the container yourself: the litellm package is needed and env variables need to be set correctly.\n\nExample Dockerfile:\n```\nFROM python:3-slim\n\nENV DEFAULT_MODEL=ollama/mistral:7b-instruct-v0.2-q4_K_M\nENV API_BASE_URL=http://10.10.10.10:11434\nENV USE_LITELLM=true\nENV OPENAI_API_KEY=bad_key\nENV SHELL_INTERACTION=false\nENV PRETTIFY_MARKDOWN=false\nENV OS_NAME=\"Arch Linux\"\nENV SHELL_NAME=auto\n\nWORKDIR /app\nCOPY . /app\n\nRUN apt-get update && apt-get install -y gcc\nRUN pip install --no-cache /app[litellm] && mkdir -p /tmp/shell_gpt\n\nVOLUME /tmp/shell_gpt\n\nENTRYPOINT [\"sgpt\"]\n```\n\n\n## Additional documentation\n* [Azure integration](https://github.com/TheR1D/shell_gpt/wiki/Azure)\n* [Ollama integration](https://github.com/TheR1D/shell_gpt/wiki/Ollama)\n"
        },
        {
          "name": "pyproject.toml",
          "type": "blob",
          "size": 2.7412109375,
          "content": "[build-system]\nrequires = [\"hatchling\"]\nbuild-backend = \"hatchling.build\"\n\n[project]\nname = \"shell_gpt\"\ndescription = \"A command-line productivity tool powered by large language models, will help you accomplish your tasks faster and more efficiently.\"\nkeywords = [\"shell\", \"gpt\", \"openai\", \"ollama\", \"cli\", \"productivity\", \"cheet-sheet\"]\nreadme = \"README.md\"\nlicense = \"MIT\"\nrequires-python = \">=3.6\"\nauthors = [{ name = \"Farkhod Sadykov\", email = \"farkhod@sadykov.dev\" }]\ndynamic = [\"version\"]\nclassifiers = [\n    \"Operating System :: OS Independent\",\n    \"Topic :: Software Development\",\n    \"License :: OSI Approved :: MIT License\",\n    \"Intended Audience :: Information Technology\",\n    \"Intended Audience :: System Administrators\",\n    \"Intended Audience :: Developers\",\n    \"Programming Language :: Python :: 3\",\n    \"Programming Language :: Python :: 3 :: Only\",\n    \"Programming Language :: Python :: 3.6\",\n    \"Programming Language :: Python :: 3.7\",\n    \"Programming Language :: Python :: 3.8\",\n    \"Programming Language :: Python :: 3.9\",\n    \"Programming Language :: Python :: 3.10\",\n    \"Programming Language :: Python :: 3.11\",\n]\ndependencies = [\n    \"openai >= 1.34.0, < 2.0.0\",\n    \"typer >= 0.7.0, < 1.0.0\",\n    \"click >= 7.1.1, < 9.0.0\",\n    \"rich >= 13.1.0, < 14.0.0\",\n    \"distro >= 1.8.0, < 2.0.0\",\n    \"instructor >= 0.4.5, < 1.0.0\",\n    'pyreadline3 >= 3.4.1, < 4.0.0; sys_platform == \"win32\"',\n]\n\n[project.optional-dependencies]\nlitellm = [\n    \"litellm == 1.42.5\"\n]\ntest = [\n    \"pytest >= 7.2.2, < 8.0.0\",\n    \"requests-mock[fixture] >= 1.10.0, < 2.0.0\",\n    \"isort >= 5.12.0, < 6.0.0\",\n    \"black == 23.1.0\",\n    \"mypy == 1.1.1\",\n    \"types-requests == 2.28.11.17\",\n    \"codespell  >= 2.2.5, < 3.0.0\"\n]\ndev = [\n    \"ruff == 0.0.256\",\n    \"pre-commit >= 3.1.1, < 4.0.0\",\n]\n\n[project.scripts]\nsgpt = \"sgpt:cli\"\n\n[project.urls]\nhomepage = \"https://github.com/ther1d/shell_gpt\"\nrepository = \"https://github.com/ther1d/shell_gpt\"\ndocumentation = \"https://github.com/TheR1D/shell_gpt/blob/main/README.md\"\n\n[tool.hatch.version]\npath = \"sgpt/__version__.py\"\n\n[tool.hatch.build.targets.wheel]\nonly-include = [\"sgpt\"]\n\n[tool.hatch.build.targets.sdist]\nonly-include = [\n    \"sgpt\",\n    \"tests\",\n    \"README.md\",\n    \"LICENSE\",\n    \"pyproject.toml\",\n]\n\n[tool.isort]\nprofile = \"black\"\nskip =  \"__init__.py\"\n\n[tool.mypy]\nstrict = true\nexclude = [\"llm_functions\"]\n\n[tool.ruff]\nselect = [\n    \"E\",  # pycodestyle errors.\n    \"W\",  # pycodestyle warnings.\n    \"F\",  # pyflakes.\n    \"C\",  # flake8-comprehensions.\n    \"B\",  # flake8-bugbear.\n]\nignore = [\n    \"E501\",  # line too long, handled by black.\n    \"C901\",  # too complex.\n    \"B008\",  # do not perform function calls in argument defaults.\n    \"E731\",  # do not assign a lambda expression, use a def.\n]\n\n[tool.codespell]\nskip = '.git,venv'\n"
        },
        {
          "name": "scripts",
          "type": "tree",
          "content": null
        },
        {
          "name": "sgpt",
          "type": "tree",
          "content": null
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}