{
  "metadata": {
    "timestamp": 1736561088017,
    "page": 18,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjIw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "unclecode/crawl4ai",
      "stars": 23804,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".env.txt",
          "type": "blob",
          "size": 0.1357421875,
          "content": "GROQ_API_KEY = \"YOUR_GROQ_API\"\nOPENAI_API_KEY = \"YOUR_OPENAI_API\"\nANTHROPIC_API_KEY = \"YOUR_ANTHROPIC_API\"\n# You can add more API keys here"
        },
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.3232421875,
          "content": "# Documentation\n*.html linguist-documentation\ndocs/* linguist-documentation\ndocs/examples/* linguist-documentation\ndocs/md_v2/* linguist-documentation\n\n# Explicitly mark Python as the main language\n*.py linguist-detectable=true\n*.py linguist-language=Python\n\n# Exclude HTML from language statistics\n*.html linguist-detectable=false"
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 3.8173828125,
          "content": "# Byte-compiled / optimized / DLL files\n__pycache__/\n*.py[cod]\n*$py.class\n\n# C extensions\n*.so\n\n# Distribution / packaging\n.Python\nbuild/\ndevelop-eggs/\ndist/\ndownloads/\neggs/\n.eggs/\nlib/\nlib64/\nparts/\nsdist/\nvar/\nwheels/\nshare/python-wheels/\n*.egg-info/\n.installed.cfg\n*.egg\nMANIFEST\n\n# PyInstaller\n#  Usually these files are written by a python script from a template\n#  before PyInstaller builds the exe, so as to inject date/other infos into it.\n*.manifest\n*.spec\n\n# Installer logs\npip-log.txt\npip-delete-this-directory.txt\n\n# Unit test / coverage reports\nhtmlcov/\n.tox/\n.nox/\n.coverage\n.coverage.*\n.cache\nnosetests.xml\ncoverage.xml\n*.cover\n*.py,cover\n.hypothesis/\n.pytest_cache/\ncover/\n\n# Translations\n*.mo\n*.pot\n\n# Django stuff:\n*.log\nlocal_settings.py\ndb.sqlite3\ndb.sqlite3-journal\n\n# Flask stuff:\ninstance/\n.webassets-cache\n\n# Scrapy stuff:\n.scrapy\n\n# Sphinx documentation\ndocs/_build/\n\n# PyBuilder\n.pybuilder/\ntarget/\n\n# Jupyter Notebook\n.ipynb_checkpoints\n\n# IPython\nprofile_default/\nipython_config.py\n\n# pyenv\n#   For a library or package, you might want to ignore these files since the code is\n#   intended to run in multiple environments; otherwise, check them in:\n# .python-version\n\n# pipenv\n#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.\n#   However, in case of collaboration, if having platform-specific dependencies or dependencies\n#   having no cross-platform support, pipenv may install dependencies that don't work, or not\n#   install all needed dependencies.\n#Pipfile.lock\n\n# poetry\n#   Similar to Pipfile.lock, it is generally recommended to include poetry.lock in version control.\n#   This is especially recommended for binary packages to ensure reproducibility, and is more\n#   commonly ignored for libraries.\n#   https://python-poetry.org/docs/basic-usage/#commit-your-poetrylock-file-to-version-control\n#poetry.lock\n\n# pdm\n#   Similar to Pipfile.lock, it is generally recommended to include pdm.lock in version control.\n#pdm.lock\n#   pdm stores project-wide configurations in .pdm.toml, but it is recommended to not include it\n#   in version control.\n#   https://pdm.fming.dev/latest/usage/project/#working-with-version-control\n.pdm.toml\n.pdm-python\n.pdm-build/\n\n# PEP 582; used by e.g. github.com/David-OConnor/pyflow and github.com/pdm-project/pdm\n__pypackages__/\n\n# Celery stuff\ncelerybeat-schedule\ncelerybeat.pid\n\n# SageMath parsed files\n*.sage.py\n\n# Environments\n.env\n.venv\nenv/\nvenv/\nENV/\nenv.bak/\nvenv.bak/\n\n# Spyder project settings\n.spyderproject\n.spyproject\n\n# Rope project settings\n.ropeproject\n\n# mkdocs documentation\n/site\n\n# mypy\n.mypy_cache/\n.dmypy.json\ndmypy.json\n\n# Pyre type checker\n.pyre/\n\n# pytype static type analyzer\n.pytype/\n\n# Cython debug symbols\ncython_debug/\n\n# PyCharm\n#  JetBrains specific template is maintained in a separate JetBrains.gitignore that can\n#  be found at https://github.com/github/gitignore/blob/main/Global/JetBrains.gitignore\n#  and can be added to the global gitignore or merged into this file.  For a more nuclear\n#  option (not recommended) you can uncomment the following to ignore the entire idea folder.\n#.idea/\n\nCrawl4AI.egg-info/\nCrawl4AI.egg-info/*\ncrawler_data.db\n.vscode/\n.tests/\n.test_pads/\ntest_pad.py\ntest_pad*.py\n.data/\nCrawl4AI.egg-info/\n\nrequirements0.txt\na.txt\n\n*.sh\n.idea\ndocs/examples/.chainlit/\ndocs/examples/.chainlit/*\n.chainlit/config.toml\n.chainlit/translations/en-US.json\n\nlocal/\n.files/\n\na.txt\n.lambda_function.py\nec2*\n\nupdate_changelog.sh\n\n.DS_Store\ndocs/.DS_Store\ntmp/\ntest_env/\n**/.DS_Store\n**/.DS_Store\n\ntodo.md\ntodo_executor.md\ngit_changes.py\ngit_changes.md\npypi_build.sh\ngit_issues.py\ngit_issues.md\n\n.next/\n.tests/\n# .issues/\n.docs/\n.issues/\n.gitboss/\ntodo_executor.md\nprotect-all-except-feature.sh\nmanage-collab.sh\npublish.sh\ncombine.sh\ncombined_output.txt\n.local\n.scripts\ntree.md\ntree.md\n.scripts\n.local\n.do\n/plans\nplans/\n\n# Codeium\n.codeiumignore\ntodo/"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 48.04296875,
          "content": "# Changelog\n\nAll notable changes to Crawl4AI will be documented in this file.\n\nThe format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),\nand this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).\n\n---\n\n## [0.4.267] - 2025 - 01 - 06\n\n### Added\n- **Windows Event Loop Configuration**: Introduced a utility function `configure_windows_event_loop` to resolve `NotImplementedError` for asyncio subprocesses on Windows. ([#utils.py](crawl4ai/utils.py), [#tutorials/async-webcrawler-basics.md](docs/md_v3/tutorials/async-webcrawler-basics.md))\n- **`page_need_scroll` Method**: Added a method to determine if a page requires scrolling before taking actions in `AsyncPlaywrightCrawlerStrategy`. ([#async_crawler_strategy.py](crawl4ai/async_crawler_strategy.py))\n\n### Changed\n- **Version Bump**: Updated the version from `0.4.246` to `0.4.247`. ([#__version__.py](crawl4ai/__version__.py))\n- **Improved Scrolling Logic**: Enhanced scrolling methods in `AsyncPlaywrightCrawlerStrategy` by adding a `scroll_delay` parameter for better control. ([#async_crawler_strategy.py](crawl4ai/async_crawler_strategy.py))\n- **Markdown Generation Example**: Updated the `hello_world.py` example to reflect the latest API changes and better illustrate features. ([#examples/hello_world.py](docs/examples/hello_world.py))\n- **Documentation Update**: \n  - Added Windows-specific instructions for handling asyncio event loops. ([#async-webcrawler-basics.md](docs/md_v3/tutorials/async-webcrawler-basics.md))\n\n### Removed\n- **Legacy Markdown Generation Code**: Removed outdated and unused code for markdown generation in `content_scraping_strategy.py`. ([#content_scraping_strategy.py](crawl4ai/content_scraping_strategy.py))\n\n### Fixed\n- **Page Closing to Prevent Memory Leaks**:\n  - **Description**: Added a `finally` block to ensure pages are closed when no `session_id` is provided.\n  - **Impact**: Prevents memory leaks caused by lingering pages after a crawl.\n  - **File**: [`async_crawler_strategy.py`](crawl4ai/async_crawler_strategy.py)\n  - **Code**:\n    ```python\n    finally:\n        # If no session_id is given we should close the page\n        if not config.session_id:\n            await page.close()\n    ```\n- **Multiple Element Selection**: Modified `_get_elements` in `JsonCssExtractionStrategy` to return all matching elements instead of just the first one, ensuring comprehensive extraction. ([#extraction_strategy.py](crawl4ai/extraction_strategy.py))\n- **Error Handling in Scrolling**: Added robust error handling to ensure scrolling proceeds safely even if a configuration is missing. ([#async_crawler_strategy.py](crawl4ai/async_crawler_strategy.py))\n\n### Other\n- **Git Ignore Update**: Added `/plans` to `.gitignore` for better development environment consistency. ([#.gitignore](.gitignore))\n\n\n## [0.4.24] - 2024-12-31\n\n### Added\n- **Browser and SSL Handling**\n  - SSL certificate validation options in extraction strategies\n  - Custom certificate paths support\n  - Configurable certificate validation skipping\n  - Enhanced response status code handling with retry logic\n\n- **Content Processing**\n  - New content filtering system with regex support\n  - Advanced chunking strategies for large content\n  - Memory-efficient parallel processing\n  - Configurable chunk size optimization\n\n- **JSON Extraction**\n  - Complex JSONPath expression support\n  - JSON-CSS and Microdata extraction\n  - RDFa parsing capabilities\n  - Advanced data transformation pipeline\n\n- **Field Types**\n  - New field types: `computed`, `conditional`, `aggregate`, `template`\n  - Field inheritance system\n  - Reusable field definitions\n  - Custom validation rules\n\n### Changed\n- **Performance**\n  - Optimized selector compilation with caching\n  - Improved HTML parsing efficiency\n  - Enhanced memory management for large documents\n  - Batch processing optimizations\n\n- **Error Handling**\n  - More detailed error messages and categorization\n  - Enhanced debugging capabilities\n  - Improved performance metrics tracking\n  - Better error recovery mechanisms\n\n### Deprecated\n- Old field computation method using `eval`\n- Direct browser manipulation without proper SSL handling\n- Simple text-based content filtering\n\n### Removed\n- Legacy extraction patterns without proper error handling\n- Unsafe eval-based field computation\n- Direct DOM manipulation without sanitization\n\n### Fixed\n- Memory leaks in large document processing\n- SSL certificate validation issues\n- Incorrect handling of nested JSON structures\n- Performance bottlenecks in parallel processing\n\n### Security\n- Improved input validation and sanitization\n- Safe expression evaluation system\n- Enhanced resource protection\n- Rate limiting implementation\n\n## [0.4.1] - 2024-12-08\n\n### **File: `crawl4ai/async_crawler_strategy.py`**\n\n#### **New Parameters and Attributes Added**\n- **`text_mode` (boolean)**: Enables text-only mode, disables images, JavaScript, and GPU-related features for faster, minimal rendering.\n- **`light_mode` (boolean)**: Optimizes the browser by disabling unnecessary background processes and features for efficiency.\n- **`viewport_width` and `viewport_height`**: Dynamically adjusts based on `text_mode` mode (default values: 800x600 for `text_mode`, 1920x1080 otherwise).\n- **`extra_args`**: Adds browser-specific flags for `text_mode` mode.\n- **`adjust_viewport_to_content`**: Dynamically adjusts the viewport to the content size for accurate rendering.\n\n#### **Browser Context Adjustments**\n- Added **`viewport` adjustments**: Dynamically computed based on `text_mode` or custom configuration.\n- Enhanced support for `light_mode` and `text_mode` by adding specific browser arguments to reduce resource consumption.\n\n#### **Dynamic Content Handling**\n- **Full Page Scan Feature**:\n  - Scrolls through the entire page while dynamically detecting content changes.\n  - Ensures scrolling stops when no new dynamic content is loaded.\n\n#### **Session Management**\n- Added **`create_session`** method:\n  - Creates a new browser session and assigns a unique ID.\n  - Supports persistent and non-persistent contexts with full compatibility for cookies, headers, and proxies.\n\n#### **Improved Content Loading and Adjustment**\n- **`adjust_viewport_to_content`**:\n  - Automatically adjusts viewport to match content dimensions.\n  - Includes scaling via Chrome DevTools Protocol (CDP).\n- Enhanced content loading:\n  - Waits for images to load and ensures network activity is idle before proceeding.\n\n#### **Error Handling and Logging**\n- Improved error handling and detailed logging for:\n  - Viewport adjustment (`adjust_viewport_to_content`).\n  - Full page scanning (`scan_full_page`).\n  - Dynamic content loading.\n\n#### **Refactoring and Cleanup**\n- Removed hardcoded viewport dimensions in multiple places, replaced with dynamic values (`self.viewport_width`, `self.viewport_height`).\n- Removed commented-out and unused code for better readability.\n- Added default value for `delay_before_return_html` parameter.\n\n#### **Optimizations**\n- Reduced resource usage in `light_mode` by disabling unnecessary browser features such as extensions, background timers, and sync.\n- Improved compatibility for different browser types (`chrome`, `firefox`, `webkit`).\n\n---\n\n### **File: `docs/examples/quickstart_async.py`**\n\n#### **Schema Adjustment**\n- Changed schema reference for `LLMExtractionStrategy`:\n  - **Old**: `OpenAIModelFee.schema()`\n  - **New**: `OpenAIModelFee.model_json_schema()`\n  - This likely ensures better compatibility with the `OpenAIModelFee` class and its JSON schema.\n\n#### **Documentation Comments Updated**\n- Improved extraction instruction for schema-based LLM strategies.\n\n---\n\n### **New Features Added**\n1. **Text-Only Mode**:\n   - Focuses on minimal resource usage by disabling non-essential browser features.\n2. **Light Mode**:\n   - Optimizes browser for performance by disabling background tasks and unnecessary services.\n3. **Full Page Scanning**:\n   - Ensures the entire content of a page is crawled, including dynamic elements loaded during scrolling.\n4. **Dynamic Viewport Adjustment**:\n   - Automatically resizes the viewport to match content dimensions, improving compatibility and rendering accuracy.\n5. **Session Management**:\n   - Simplifies session handling with better support for persistent and non-persistent contexts.\n\n---\n\n### **Bug Fixes**\n- Fixed potential viewport mismatches by ensuring consistent use of `self.viewport_width` and `self.viewport_height` throughout the code.\n- Improved robustness of dynamic content loading to avoid timeouts and failed evaluations.\n\n\n\n\n\n\n\n## [0.3.75] December 1, 2024\n\n### PruningContentFilter\n\n#### 1. Introduced PruningContentFilter (Dec 01, 2024) (Dec 01, 2024)\nA new content filtering strategy that removes less relevant nodes based on metrics like text and link density.\n\n**Affected Files:**\n- `crawl4ai/content_filter_strategy.py`: Enhancement of content filtering capabilities.\n```diff\nImplemented effective pruning algorithm with comprehensive scoring.\n```\n- `README.md`: Improved documentation regarding new features.\n```diff\nUpdated to include usage and explanation for the PruningContentFilter.\n```\n- `docs/md_v2/basic/content_filtering.md`: Expanded documentation for users.\n```diff\nAdded detailed section explaining the PruningContentFilter.\n```\n\n#### 2. Added Unit Tests for PruningContentFilter (Dec 01, 2024) (Dec 01, 2024)\nComprehensive tests added to ensure correct functionality of PruningContentFilter\n\n**Affected Files:**\n- `tests/async/test_content_filter_prune.py`: Increased test coverage for content filtering strategies.\n```diff\nCreated test cases for various scenarios using the PruningContentFilter.\n```\n\n### Development Updates\n\n#### 3. Enhanced BM25ContentFilter tests (Dec 01, 2024) (Dec 01, 2024)\nExtended testing to cover additional edge cases and performance metrics.\n\n**Affected Files:**\n- `tests/async/test_content_filter_bm25.py`: Improved reliability and performance assurance.\n```diff\nAdded tests for new extraction scenarios including malformed HTML.\n```\n\n### Infrastructure & Documentation\n\n#### 4. Updated Examples (Dec 01, 2024) (Dec 01, 2024)\nAltered examples in documentation to promote the use of PruningContentFilter alongside existing strategies.\n\n**Affected Files:**\n- `docs/examples/quickstart_async.py`: Enhanced usability and clarity for new users.\n- Revised example to illustrate usage of PruningContentFilter.\n\n## [0.3.746] November 29, 2024\n\n### Major Features\n1. Enhanced Docker Support (Nov 29, 2024)\n   - Improved GPU support in Docker images.\n   - Dockerfile refactored for better platform-specific installations.\n   - Introduced new Docker commands for different platforms:\n     - `basic-amd64`, `all-amd64`, `gpu-amd64` for AMD64.\n     - `basic-arm64`, `all-arm64`, `gpu-arm64` for ARM64.\n\n### Infrastructure & Documentation\n- Enhanced README.md to improve user guidance and installation instructions.\n- Added installation instructions for Playwright setup in README.\n- Created and updated examples in `docs/examples/quickstart_async.py` to be more useful and user-friendly.\n- Updated `requirements.txt` with a new `pydantic` dependency.\n- Bumped version number in `crawl4ai/__version__.py` to 0.3.746.\n\n### Breaking Changes\n- Streamlined application structure:\n  - Removed static pages and related code from `main.py` which might affect existing deployments relying on static content.\n\n### Development Updates\n- Developed `post_install` method in `crawl4ai/install.py` to streamline post-installation setup tasks.\n- Refined migration processes in `crawl4ai/migrations.py` with enhanced logging for better error visibility.\n- Updated `docker-compose.yml` to support local and hub services for different architectures, enhancing build and deploy capabilities.\n- Refactored example test cases in `docs/examples/docker_example.py` to facilitate comprehensive testing.\n\n### README.md\nUpdated README with new docker commands and setup instructions.\nEnhanced installation instructions and guidance.\n\n### crawl4ai/install.py\nAdded post-install script functionality.\nIntroduced `post_install` method for automation of post-installation tasks.\n\n### crawl4ai/migrations.py\nImproved migration logging.\nRefined migration processes and added better logging.\n\n### docker-compose.yml\nRefactored docker-compose for better service management.\nUpdated to define services for different platforms and versions.\n\n### requirements.txt\nUpdated dependencies.\nAdded `pydantic` to requirements file.\n\n### crawler/__version__.py\nUpdated version number.\nBumped version number to 0.3.746.\n\n### docs/examples/quickstart_async.py\nEnhanced example scripts.\nUncommented example usage in async guide for user functionality.\n\n### main.py\nRefactored code to improve maintainability.\nStreamlined app structure by removing static pages code.\n\n## [0.3.743] November 27, 2024\n\nEnhance features and documentation\n- Updated version to 0.3.743\n- Improved ManagedBrowser configuration with dynamic host/port\n- Implemented fast HTML formatting in web crawler\n- Enhanced markdown generation with a new generator class\n- Improved sanitization and utility functions\n- Added contributor details and pull request acknowledgments\n- Updated documentation for clearer usage scenarios\n- Adjusted tests to reflect class name changes\n\n### CONTRIBUTORS.md\nAdded new contributors and pull request details.\nUpdated community contributions and acknowledged pull requests.\n\n### crawl4ai/__version__.py\nVersion update.\nBumped version to 0.3.743.\n\n### crawl4ai/async_crawler_strategy.py\nImproved ManagedBrowser configuration.\nEnhanced browser initialization with configurable host and debugging port; improved hook execution.\n\n### crawl4ai/async_webcrawler.py\nOptimized HTML processing.\nImplemented 'fast_format_html' for optimized HTML formatting; applied it when 'prettiify' is enabled.\n\n### crawl4ai/content_scraping_strategy.py\nEnhanced markdown generation strategy.\nUpdated to use DefaultMarkdownGenerator and improved markdown generation with filters option.\n\n### crawl4ai/markdown_generation_strategy.py\nRefactored markdown generation class.\nRenamed DefaultMarkdownGenerationStrategy to DefaultMarkdownGenerator; added content filter handling.\n\n### crawl4ai/utils.py\nEnhanced utility functions.\nImproved input sanitization and enhanced HTML formatting method.\n\n### docs/md_v2/advanced/hooks-auth.md\nImproved documentation for hooks.\nUpdated code examples to include cookies in crawler strategy initialization.\n\n### tests/async/test_markdown_genertor.py\nRefactored tests to match class renaming.\nUpdated tests to use renamed DefaultMarkdownGenerator class.\n\n## [0.3.74] November 17, 2024\n\nThis changelog details the updates and changes introduced in Crawl4AI version 0.3.74. It's designed to inform developers about new features, modifications to existing components, removals, and other important information.\n\n### 1. File Download Processing\n\n- Users can now specify download folders using the `downloads_path` parameter in the `AsyncWebCrawler` constructor or the `arun` method. If not specified, downloads are saved to a \"downloads\" folder within the `.crawl4ai` directory.\n- File download tracking is integrated into the `CrawlResult` object.  Successfully downloaded files are listed in the `downloaded_files` attribute, providing their paths.\n- Added `accept_downloads` parameter to the crawler strategies (defaults to `False`). If set to True you can add JS code and `wait_for` parameter for file download.\n\n**Example:**\n\n```python\nimport asyncio\nimport os\nfrom pathlib import Path\nfrom crawl4ai import AsyncWebCrawler\n\nasync def download_example():\n    downloads_path = os.path.join(Path.home(), \".crawl4ai\", \"downloads\")\n    os.makedirs(downloads_path, exist_ok=True)\n\n    async with AsyncWebCrawler(\n        accept_downloads=True, \n        downloads_path=downloads_path, \n        verbose=True\n    ) as crawler:\n        result = await crawler.arun(\n            url=\"https://www.python.org/downloads/\",\n            js_code=\"\"\"\n                const downloadLink = document.querySelector('a[href$=\".exe\"]');\n                if (downloadLink) { downloadLink.click(); }\n            \"\"\",\n            wait_for=5 # To ensure download has started\n        )\n\n        if result.downloaded_files:\n            print(\"Downloaded files:\")\n            for file in result.downloaded_files:\n                print(f\"- {file}\")\n\nasyncio.run(download_example())\n\n```\n\n### 2. Refined Content Filtering\n\n- Introduced the `RelevanceContentFilter` strategy (and its implementation `BM25ContentFilter`) for extracting relevant content from web pages, replacing Fit Markdown and other content cleaning strategy. This new strategy leverages the BM25 algorithm to identify chunks of text relevant to the page's title, description, keywords, or a user-provided query.\n- The `fit_markdown` flag in the content scraper is used to filter content based on title, meta description, and keywords.\n\n**Example:**\n\n```python\nfrom crawl4ai import AsyncWebCrawler\nfrom crawl4ai.content_filter_strategy import BM25ContentFilter\n\nasync def filter_content(url, query):\n    async with AsyncWebCrawler() as crawler:\n        content_filter = BM25ContentFilter(user_query=query)\n        result = await crawler.arun(url=url, extraction_strategy=content_filter, fit_markdown=True)\n        print(result.extracted_content)  # Or result.fit_markdown for the markdown version\n        print(result.fit_html) # Or result.fit_html to show HTML with only the filtered content\n\nasyncio.run(filter_content(\"https://en.wikipedia.org/wiki/Apple\", \"fruit nutrition health\"))\n```\n\n### 3. Raw HTML and Local File Support\n\n- Added support for crawling local files and raw HTML content directly.\n- Use the `file://` prefix for local file paths.\n- Use the `raw:` prefix for raw HTML strings.\n\n**Example:**\n\n```python\nasync def crawl_local_or_raw(crawler, content, content_type):\n    prefix = \"file://\" if content_type == \"local\" else \"raw:\"\n    url = f\"{prefix}{content}\"\n    result = await crawler.arun(url=url)\n    if result.success:\n        print(f\"Markdown Content from {content_type.title()} Source:\")\n        print(result.markdown)\n\n# Example usage with local file and raw HTML\nasync def main():\n    async with AsyncWebCrawler() as crawler:\n        # Local File\n        await crawl_local_or_raw(\n            crawler, os.path.abspath('tests/async/sample_wikipedia.html'), \"local\"\n        )\n        # Raw HTML\n        await crawl_raw_html(crawler, \"<h1>Raw Test</h1><p>This is raw HTML.</p>\")\n        \n\nasyncio.run(main())\n```\n\n### 4. Browser Management\n\n- New asynchronous crawler strategy implemented using Playwright.\n- `ManagedBrowser` class introduced for improved browser session handling, offering features like persistent browser sessions between requests (using  `session_id`  parameter) and browser process monitoring.\n- Updated to tf-playwright-stealth for enhanced stealth capabilities.\n- Added `use_managed_browser`, `use_persistent_context`, and `chrome_channel` parameters to AsyncPlaywrightCrawlerStrategy.\n\n\n**Example:**\n```python\nasync def browser_management_demo():\n    user_data_dir = os.path.join(Path.home(), \".crawl4ai\", \"user-data-dir\")\n    os.makedirs(user_data_dir, exist_ok=True)  # Ensure directory exists\n    async with AsyncWebCrawler(\n        use_managed_browser=True,\n        user_data_dir=user_data_dir,\n        use_persistent_context=True,\n        verbose=True\n    ) as crawler:\n        result1 = await crawler.arun(\n            url=\"https://example.com\", session_id=\"my_session\"\n        )\n        result2 = await crawler.arun(\n            url=\"https://example.com/anotherpage\", session_id=\"my_session\"\n        )\n\nasyncio.run(browser_management_demo())\n```\n\n\n### 5. API Server & Cache Improvements\n\n- Added CORS support to API server.\n- Implemented static file serving.\n- Enhanced root redirect functionality.\n- Cache database updated to store response headers and downloaded files information. It utilizes a file system approach to manage large content efficiently.\n- New, more efficient caching database built using xxhash and file system approach.\n- Introduced `CacheMode` enum (`ENABLED`, `DISABLED`, `READ_ONLY`, `WRITE_ONLY`, `BYPASS`) and `always_bypass_cache` parameter in AsyncWebCrawler for fine-grained cache control. This replaces `bypass_cache`, `no_cache_read`, `no_cache_write`, and `always_by_pass_cache`.\n\n\n### ðŸ—‘ï¸ Removals\n\n- Removed deprecated: `crawl4ai/content_cleaning_strategy.py`.\n- Removed internal class ContentCleaningStrategy\n- Removed legacy cache control flags:  `bypass_cache`,  `disable_cache`,  `no_cache_read`,  `no_cache_write`, and `always_by_pass_cache`.  These have been superseded by  `cache_mode`.\n\n\n### âš™ï¸ Other Changes\n\n- Moved version file to `crawl4ai/__version__.py`.\n- Added `crawl4ai/cache_context.py`.\n- Added `crawl4ai/version_manager.py`.\n- Added `crawl4ai/migrations.py`.\n- Added `crawl4ai-migrate` entry point.\n- Added config `NEED_MIGRATION` and `SHOW_DEPRECATION_WARNINGS`.\n- API server now requires an API token for authentication, configurable with the `CRAWL4AI_API_TOKEN` environment variable.  This enhances API security.\n- Added synchronous crawl endpoint `/crawl_sync` for immediate result retrieval, and direct crawl endpoint `/crawl_direct` bypassing the task queue.\n\n\n### âš ï¸ Deprecation Notices\n\n- The synchronous version of `WebCrawler` is being phased out.  While still available via `crawl4ai[sync]`, it will eventually be removed. Transition to `AsyncWebCrawler` is strongly recommended. Boolean cache control flags in `arun` are also deprecated, migrate to using the `cache_mode` parameter.  See examples in the \"New Features\" section above for correct usage.\n\n\n### ðŸ› Bug Fixes\n\n- Resolved issue with browser context closing unexpectedly in Docker. This significantly improves stability, particularly within containerized environments. \n- Fixed memory leaks associated with incorrect asynchronous cleanup by removing the `__del__` method and ensuring the browser context is closed explicitly using context managers.\n- Improved error handling in `WebScrapingStrategy`. More detailed error messages and suggestions for debugging will minimize frustration when running into unexpected issues.\n- Fixed issue with incorrect text parsing in specific HTML structures.\n\n\n### Example of migrating to the new CacheMode:\n\n**Old way:**\n\n```python\ncrawler = AsyncWebCrawler(always_by_pass_cache=True)\nresult = await crawler.arun(url=\"https://example.com\", bypass_cache=True)\n```\n\n**New way:**\n\n```python\nfrom crawl4ai import CacheMode\n\ncrawler = AsyncWebCrawler(always_bypass_cache=True)\nresult = await crawler.arun(url=\"https://example.com\", cache_mode=CacheMode.BYPASS)\n```\n\n\n## [0.3.74] - November 13, 2024\n\n1. **File Download Processing** (Nov 14, 2024)\n   - Added capability for users to specify download folders\n   - Implemented file download tracking in crowd result object\n   - Created new file: `tests/async/test_async_doanloader.py`\n\n2. **Content Filtering Improvements** (Nov 14, 2024)\n   - Introduced Relevance Content Filter as an improvement over Fit Markdown\n   - Implemented BM25 algorithm for content relevance matching\n   - Added new file: `crawl4ai/content_filter_strategy.py`\n   - Removed deprecated: `crawl4ai/content_cleaning_strategy.py`\n\n3. **Local File and Raw HTML Support** (Nov 13, 2024)\n   - Added support for processing local files\n   - Implemented raw HTML input handling in AsyncWebCrawler\n   - Enhanced `crawl4ai/async_webcrawler.py` with significant performance improvements\n\n4. **Browser Management Enhancements** (Nov 12, 2024)\n   - Implemented new async crawler strategy using Playwright\n   - Introduced ManagedBrowser for better browser session handling\n   - Added support for persistent browser sessions\n   - Updated from playwright_stealth to tf-playwright-stealth\n\n5. **API Server Component**\n   - Added CORS support\n   - Implemented static file serving\n   - Enhanced root redirect functionality\n\n\n\n## [0.3.731] - November 13, 2024\n\n### Added\n- Support for raw HTML and local file crawling via URL prefixes ('raw:', 'file://')\n- Browser process monitoring for managed browser instances\n- Screenshot capability for raw HTML and local file content\n- Response headers storage in cache database\n- New `fit_markdown` flag for optional markdown generation\n\n### Changed\n- Switched HTML parser from 'html.parser' to 'lxml' for ~4x performance improvement \n- Optimized BeautifulSoup text conversion and element selection\n- Pre-compiled regular expressions for better performance\n- Improved metadata extraction efficiency\n- Response headers now stored alongside HTML in cache\n\n### Removed\n- `__del__` method from AsyncPlaywrightCrawlerStrategy to prevent async cleanup issues\n\n### Fixed \n- Issue #256: Added support for crawling raw HTML content\n- Issue #253: Implemented file:// protocol handling\n- Missing response headers in cached results\n- Memory leaks from improper async cleanup\n\n## [v0.3.731] - 2024-11-13 Changelog for Issue 256 Fix\n- Fixed: Browser context unexpectedly closing in Docker environment during crawl operations.\n- Removed: __del__ method from AsyncPlaywrightCrawlerStrategy to prevent unreliable asynchronous cleanup, ensuring - browser context is closed explicitly within context managers.\n- Added: Monitoring for ManagedBrowser subprocess to detect and log unexpected terminations.\n- Updated: Dockerfile configurations to expose debugging port (9222) and allocate additional shared memory for improved browser stability.\n- Improved: Error handling and resource cleanup processes for browser lifecycle management within the Docker environment.\n\n## [v0.3.73] - 2024-11-05\n\n### Major Features\n- **New Doctor Feature**\n  - Added comprehensive system diagnostics tool\n  - Available through package hub and CLI\n  - Provides automated troubleshooting and system health checks\n  - Includes detailed reporting of configuration issues\n\n- **Dockerized API Server**\n  - Released complete Docker implementation for API server\n  - Added comprehensive documentation for Docker deployment\n  - Implemented container communication protocols\n  - Added environment configuration guides\n\n- **Managed Browser Integration**\n  - Added support for user-controlled browser instances\n  - Implemented `ManagedBrowser` class for better browser lifecycle management\n  - Added ability to connect to existing Chrome DevTools Protocol (CDP) endpoints\n  - Introduced user data directory support for persistent browser profiles\n\n- **Enhanced HTML Processing**\n  - Added HTML tag preservation feature during markdown conversion\n  - Introduced configurable tag preservation system\n  - Improved pre-tag and code block handling\n  - Added support for nested preserved tags with attribute retention\n\n### Improvements\n- **Browser Handling**\n  - Added flag to ignore body visibility for problematic pages\n  - Improved browser process cleanup and management\n  - Enhanced temporary directory handling for browser profiles\n  - Added configurable browser launch arguments\n\n- **Database Management**\n  - Implemented connection pooling for better performance\n  - Added retry logic for database operations\n  - Improved error handling and logging\n  - Enhanced cleanup procedures for database connections\n\n- **Resource Management**\n  - Added memory and CPU monitoring\n  - Implemented dynamic task slot allocation based on system resources\n  - Added configurable cleanup intervals\n\n### Technical Improvements\n- **Code Structure**\n  - Moved version management to dedicated _version.py file\n  - Improved error handling throughout the codebase\n  - Enhanced logging system with better error reporting\n  - Reorganized core components for better maintainability\n\n### Bug Fixes\n- Fixed issues with browser process termination\n- Improved handling of connection timeouts\n- Enhanced error recovery in database operations\n- Fixed memory leaks in long-running processes\n\n### Dependencies\n- Updated Playwright to v1.47\n- Updated core dependencies with more flexible version constraints\n- Added new development dependencies for testing\n\n### Breaking Changes\n- Changed default browser handling behavior\n- Modified database connection management approach\n- Updated API response structure for better consistency\n\n### Migration Guide\nWhen upgrading to v0.3.73, be aware of the following changes:\n\n1. Docker Deployment:\n   - Review Docker documentation for new deployment options\n   - Update environment configurations as needed\n   - Check container communication settings\n\n2. If using custom browser management:\n   - Update browser initialization code to use new ManagedBrowser class\n   - Review browser cleanup procedures\n\n3. For database operations:\n   - Check custom database queries for compatibility with new connection pooling\n   - Update error handling to work with new retry logic\n\n4. Using the Doctor:\n   - Run doctor command for system diagnostics: `crawl4ai doctor`\n   - Review generated reports for potential issues\n   - Follow recommended fixes for any identified problems\n\n\n## [v0.3.73] - 2024-11-04\nThis commit introduces several key enhancements, including improved error handling and robust database operations in `async_database.py`, which now features a connection pool and retry logic for better reliability. Updates to the README.md provide clearer instructions and a better user experience with links to documentation sections. The `.gitignore` file has been refined to include additional directories, while the async web crawler now utilizes a managed browser for more efficient crawling. Furthermore, multiple dependency updates and introduction of the `CustomHTML2Text` class enhance text extraction capabilities.\n\n## [v0.3.73] - 2024-10-24\n\n### Added\n- preserve_tags: Added support for preserving specific HTML tags during markdown conversion.\n- Smart overlay removal system in AsyncPlaywrightCrawlerStrategy:\n  - Automatic removal of popups, modals, and cookie notices\n  - Detection and removal of fixed/sticky position elements\n  - Cleaning of empty block elements\n  - Configurable via `remove_overlay_elements` parameter\n- Enhanced screenshot capabilities:\n  - Added `screenshot_wait_for` parameter to control timing\n  - Improved screenshot handling with existing page context\n  - Better error handling with fallback error images\n- New URL normalization utilities:\n  - `normalize_url` function for consistent URL formatting\n  - `is_external_url` function for better link classification\n- Custom base directory support for cache storage:\n  - New `base_directory` parameter in AsyncWebCrawler\n  - Allows specifying alternative locations for `.crawl4ai` folder\n\n### Enhanced\n- Link handling improvements:\n  - Better duplicate link detection\n  - Enhanced internal/external link classification\n  - Improved handling of special URL protocols\n  - Support for anchor links and protocol-relative URLs\n- Configuration refinements:\n  - Streamlined social media domain list\n  - More focused external content filtering\n- LLM extraction strategy:\n  - Added support for separate API base URL via `api_base` parameter\n  - Better handling of base URLs in configuration\n\n### Fixed\n- Screenshot functionality:\n  - Resolved issues with screenshot timing and context\n  - Improved error handling and recovery\n- Link processing:\n  - Fixed URL normalization edge cases\n  - Better handling of invalid URLs\n  - Improved error messages for link processing failures\n\n### Developer Notes\n- The overlay removal system uses advanced JavaScript injection for better compatibility\n- URL normalization handles special cases like mailto:, tel:, and protocol-relative URLs\n- Screenshot system now reuses existing page context for better performance\n- Link processing maintains separate dictionaries for internal and external links to ensure uniqueness\n\n## [v0.3.72] - 2024-10-22\n\n### Added\n- New `ContentCleaningStrategy` class:\n  - Smart content extraction based on text density and element scoring\n  - Automatic removal of boilerplate content\n  - DOM tree analysis for better content identification\n  - Configurable thresholds for content detection\n- Advanced proxy support:\n  - Added `proxy_config` option for authenticated proxy connections\n  - Support for username/password in proxy configuration\n- New content output formats:\n  - `fit_markdown`: Optimized markdown output with main content focus\n  - `fit_html`: Clean HTML with only essential content\n\n### Enhanced\n- Image source detection:\n  - Support for multiple image source attributes (`src`, `data-src`, `srcset`, etc.)\n  - Automatic fallback through potential source attributes\n  - Smart handling of srcset attribute\n- External content handling:\n  - Made external link exclusion optional (disabled by default)\n  - Improved detection and handling of social media links\n  - Better control over external image filtering\n\n### Fixed\n- Image extraction reliability with multiple source attribute checks\n- External link and image handling logic for better accuracy\n\n### Developer Notes\n- The new `ContentCleaningStrategy` uses configurable thresholds for customization\n- Proxy configuration now supports more complex authentication scenarios\n- Content extraction process now provides both regular and optimized outputs\n\n## [v0.3.72] - 2024-10-20\n\n### Fixed\n- Added support for parsing Base64 encoded images in WebScrapingStrategy\n\n### Added\n- Forked and integrated a customized version of the html2text library for more control over Markdown generation\n- New configuration options for controlling external content:\n  - Ability to exclude all external links\n  - Option to specify domains to exclude (default includes major social media platforms)\n  - Control over excluding external images\n\n### Changed\n- Improved Markdown generation process:\n  - Added fine-grained control over character escaping in Markdown output\n  - Enhanced handling of code blocks and pre-formatted text\n- Updated `AsyncPlaywrightCrawlerStrategy.close()` method to use a shorter sleep time (0.5 seconds instead of 500)\n- Enhanced flexibility in `CosineStrategy` with a more generic `load_HF_embedding_model` function\n\n### Improved\n- Optimized content scraping and processing for better efficiency\n- Enhanced error handling and logging in various components\n\n### Developer Notes\n- The customized html2text library is now located within the crawl4ai package\n- New configuration options are available in the `config.py` file for external content handling\n- The `WebScrapingStrategy` class has been updated to accommodate new external content exclusion options\n\n## [v0.3.71] - 2024-10-19\n\n### Added\n- New chunking strategies:\n  - `OverlappingWindowChunking`: Allows for overlapping chunks of text, useful for maintaining context between chunks.\n  - Enhanced `SlidingWindowChunking`: Improved to handle edge cases and last chunks more effectively.\n\n### Changed\n- Updated `CHUNK_TOKEN_THRESHOLD` in config to 2048 tokens (2^11) for better compatibility with most LLM models.\n- Improved `AsyncPlaywrightCrawlerStrategy.close()` method to use a shorter sleep time (0.5 seconds instead of 500), significantly reducing wait time when closing the crawler.\n- Enhanced flexibility in `CosineStrategy`:\n  - Now uses a more generic `load_HF_embedding_model` function, allowing for easier swapping of embedding models.\n- Updated `JsonCssExtractionStrategy` and `JsonXPathExtractionStrategy` for better JSON-based extraction.\n\n### Fixed\n- Addressed potential issues with the sliding window chunking strategy to ensure all text is properly chunked.\n\n### Developer Notes\n- Added more comprehensive docstrings to chunking strategies for better code documentation.\n- Removed hardcoded device setting in `CosineStrategy`, now using the automatically detected device.\n- Added a new example in `quickstart_async.py` for generating a knowledge graph from crawled content.\n\nThese updates aim to provide more flexibility in text processing, improve performance, and enhance the overall capabilities of the crawl4ai library. The new chunking strategies, in particular, offer more options for handling large texts in various scenarios.\n\n## [v0.3.71] - 2024-10-18\n\n### Changes\n1. **Version Update**:\n   - Updated version number from 0.3.7 to 0.3.71.\n\n2. **Crawler Enhancements**:\n   - Added `sleep_on_close` option to AsyncPlaywrightCrawlerStrategy for delayed browser closure.\n   - Improved context creation with additional options:\n     - Enabled `accept_downloads` and `java_script_enabled`.\n     - Added a cookie to enable cookies by default.\n\n3. **Error Handling Improvements**:\n   - Enhanced error messages in AsyncWebCrawler's `arun` method.\n   - Updated error reporting format for better visibility and consistency.\n\n4. **Performance Optimization**:\n   - Commented out automatic page and context closure in `crawl` method to potentially improve performance in certain scenarios.\n\n### Documentation\n- Updated quickstart notebook:\n  - Changed installation command to use the released package instead of GitHub repository.\n  - Updated kernel display name.\n\n### Developer Notes\n- Minor code refactoring and cleanup.\n\n## [v0.3.7] - 2024-10-17\n\n### New Features\n1. **Enhanced Browser Stealth**: \n   - Implemented `playwright_stealth` for improved bot detection avoidance.\n   - Added `StealthConfig` for fine-tuned control over stealth parameters.\n\n2. **User Simulation**:\n   - New `simulate_user` option to mimic human-like interactions (mouse movements, clicks, keyboard presses).\n\n3. **Navigator Override**:\n   - Added `override_navigator` option to modify navigator properties, further improving bot detection evasion.\n\n4. **Improved iframe Handling**:\n   - New `process_iframes` parameter to extract and integrate iframe content into the main page.\n\n5. **Flexible Browser Selection**:\n   - Support for choosing between Chromium, Firefox, and WebKit browsers.\n\n6. **Include Links in Markdown**:\n    - Added support for including links in Markdown content, by definin g a new flag `include_links_on_markdown` in `crawl` method.   \n\n### Improvements\n1. **Better Error Handling**:\n   - Enhanced error reporting in WebScrapingStrategy with detailed error messages and suggestions.\n   - Added console message and error logging for better debugging.\n\n2. **Image Processing Enhancements**:\n   - Improved image dimension updating and filtering logic.\n\n3. **Crawling Flexibility**:\n   - Added support for custom viewport sizes.\n   - Implemented delayed content retrieval with `delay_before_return_html` parameter.\n\n4. **Performance Optimization**:\n   - Adjusted default semaphore count for parallel crawling.\n\n### Bug Fixes\n- Fixed an issue where the HTML content could be empty after processing.\n\n### Examples\n- Added new example `crawl_with_user_simulation()` demonstrating the use of user simulation and navigator override features.\n\n### Developer Notes\n- Refactored code for better maintainability and readability.\n- Updated browser launch arguments for improved compatibility and performance.\n\n## [v0.3.6] - 2024-10-12 \n\n### 1. Improved Crawling Control\n- **New Hook**: Added `before_retrieve_html` hook in `AsyncPlaywrightCrawlerStrategy`.\n- **Delayed HTML Retrieval**: Introduced `delay_before_return_html` parameter to allow waiting before retrieving HTML content.\n  - Useful for pages with delayed content loading.\n- **Flexible Timeout**: `smart_wait` function now uses `page_timeout` (default 60 seconds) instead of a fixed 30-second timeout.\n  - Provides better handling for slow-loading pages.\n- **How to use**: Set `page_timeout=your_desired_timeout` (in milliseconds) when calling `crawler.arun()`.\n\n### 2. Browser Type Selection\n- Added support for different browser types (Chromium, Firefox, WebKit).\n- Users can now specify the browser type when initializing AsyncWebCrawler.\n- **How to use**: Set `browser_type=\"firefox\"` or `browser_type=\"webkit\"` when initializing AsyncWebCrawler.\n\n### 3. Screenshot Capture\n- Added ability to capture screenshots during crawling.\n- Useful for debugging and content verification.\n- **How to use**: Set `screenshot=True` when calling `crawler.arun()`.\n\n### 4. Enhanced LLM Extraction Strategy\n- Added support for multiple LLM providers (OpenAI, Hugging Face, Ollama).\n- **Custom Arguments**: Added support for passing extra arguments to LLM providers via `extra_args` parameter.\n- **Custom Headers**: Users can now pass custom headers to the extraction strategy.\n- **How to use**: Specify the desired provider and custom arguments when using `LLMExtractionStrategy`.\n\n### 5. iframe Content Extraction\n- New feature to process and extract content from iframes.\n- **How to use**: Set `process_iframes=True` in the crawl method.\n\n### 6. Delayed Content Retrieval\n- Introduced `get_delayed_content` method in `AsyncCrawlResponse`.\n- Allows retrieval of content after a specified delay, useful for dynamically loaded content.\n- **How to use**: Access `result.get_delayed_content(delay_in_seconds)` after crawling.\n\n### Improvements and Optimizations\n\n#### 1. AsyncWebCrawler Enhancements\n- **Flexible Initialization**: Now accepts arbitrary keyword arguments, passed directly to the crawler strategy.\n- Allows for more customized setups.\n\n#### 2. Image Processing Optimization\n- Enhanced image handling in WebScrapingStrategy.\n- Added filtering for small, invisible, or irrelevant images.\n- Improved image scoring system for better content relevance.\n- Implemented JavaScript-based image dimension updating for more accurate representation.\n\n#### 3. Database Schema Auto-updates\n- Automatic database schema updates ensure compatibility with the latest version.\n\n#### 4. Enhanced Error Handling and Logging\n- Improved error messages and logging for easier debugging.\n\n#### 5. Content Extraction Refinements\n- Refined HTML sanitization process.\n- Improved handling of base64 encoded images.\n- Enhanced Markdown conversion process.\n- Optimized content extraction algorithms.\n\n#### 6. Utility Function Enhancements\n- `perform_completion_with_backoff` function now supports additional arguments for more customized API calls to LLM providers.\n\n### Bug Fixes\n- Fixed an issue where image tags were being prematurely removed during content extraction.\n\n### Examples and Documentation\n- Updated `quickstart_async.py` with examples of:\n  - Using custom headers in LLM extraction.\n  - Different LLM provider usage (OpenAI, Hugging Face, Ollama).\n  - Custom browser type usage.\n\n### Developer Notes\n- Refactored code for better maintainability, flexibility, and performance.\n- Enhanced type hinting throughout the codebase for improved development experience.\n- Expanded error handling for more robust operation.\n\nThese updates significantly enhance the flexibility, accuracy, and robustness of crawl4ai, providing users with more control and options for their web crawling and content extraction tasks.\n\n## [v0.3.5] - 2024-09-02\n\nEnhance AsyncWebCrawler with smart waiting and screenshot capabilities\n\n- Implement smart_wait function in AsyncPlaywrightCrawlerStrategy\n- Add screenshot support to AsyncCrawlResponse and AsyncWebCrawler\n- Improve error handling and timeout management in crawling process\n- Fix typo in CrawlResult model (responser_headers -> response_headers)\n\n## [v0.2.77] - 2024-08-04\n\nSignificant improvements in text processing and performance:\n\n- ðŸš€ **Dependency reduction**: Removed dependency on spaCy model for text chunk labeling in cosine extraction strategy.\n- ðŸ¤– **Transformer upgrade**: Implemented text sequence classification using a transformer model for labeling text chunks.\n- âš¡ **Performance enhancement**: Improved model loading speed due to removal of spaCy dependency.\n- ðŸ”§ **Future-proofing**: Laid groundwork for potential complete removal of spaCy dependency in future versions.\n\nThese changes address issue #68 and provide a foundation for faster, more efficient text processing in Crawl4AI.\n\n## [v0.2.76] - 2024-08-02\n\nMajor improvements in functionality, performance, and cross-platform compatibility! ðŸš€\n\n- ðŸ³ **Docker enhancements**: Significantly improved Dockerfile for easy installation on Linux, Mac, and Windows.\n- ðŸŒ **Official Docker Hub image**: Launched our first official image on Docker Hub for streamlined deployment.\n- ðŸ”§ **Selenium upgrade**: Removed dependency on ChromeDriver, now using Selenium's built-in capabilities for better compatibility.\n- ðŸ–¼ï¸ **Image description**: Implemented ability to generate textual descriptions for extracted images from web pages.\n- âš¡ **Performance boost**: Various improvements to enhance overall speed and performance.\n\nA big shoutout to our amazing community contributors:\n- [@aravindkarnam](https://github.com/aravindkarnam) for developing the textual description extraction feature.\n- [@FractalMind](https://github.com/FractalMind) for creating the first official Docker Hub image and fixing Dockerfile errors.\n- [@ketonkss4](https://github.com/ketonkss4) for identifying Selenium's new capabilities, helping us reduce dependencies.\n\nYour contributions are driving Crawl4AI forward! ðŸ™Œ\n\n## [v0.2.75] - 2024-07-19\n\nMinor improvements for a more maintainable codebase:\n\n- ðŸ”„ Fixed typos in `chunking_strategy.py` and `crawler_strategy.py` to improve code readability\n- ðŸ”„ Removed `.test_pads/` directory from `.gitignore` to keep our repository clean and organized\n\nThese changes may seem small, but they contribute to a more stable and sustainable codebase. By fixing typos and updating our `.gitignore` settings, we're ensuring that our code is easier to maintain and scale in the long run.\n\n## [v0.2.74] - 2024-07-08\nA slew of exciting updates to improve the crawler's stability and robustness! ðŸŽ‰\n\n- ðŸ’» **UTF encoding fix**: Resolved the Windows \\\"charmap\\\" error by adding UTF encoding.\n- ðŸ›¡ï¸ **Error handling**: Implemented MaxRetryError exception handling in LocalSeleniumCrawlerStrategy.\n- ðŸ§¹ **Input sanitization**: Improved input sanitization and handled encoding issues in LLMExtractionStrategy.\n- ðŸš® **Database cleanup**: Removed existing database file and initialized a new one.\n\n\n## [v0.2.73] - 2024-07-03\n\nðŸ’¡ In this release, we've bumped the version to v0.2.73 and refreshed our documentation to ensure you have the best experience with our project.\n\n* Supporting website need \"with-head\" mode to crawl the website with head.\n* Fixing the installation issues for setup.py and dockerfile.\n* Resolve multiple issues.\n\n## [v0.2.72] - 2024-06-30\n\nThis release brings exciting updates and improvements to our project! ðŸŽ‰\n\n* ðŸ“š **Documentation Updates**: Our documentation has been revamped to reflect the latest changes and additions.\n* ðŸš€ **New Modes in setup.py**: We've added support for three new modes in setup.py: default, torch, and transformers. This enhances the project's flexibility and usability.\n* ðŸ³ **Docker File Updates**: The Docker file has been updated to ensure seamless compatibility with the new modes and improvements.\n* ðŸ•·ï¸ **Temporary Solution for Headless Crawling**: We've implemented a temporary solution to overcome issues with crawling websites in headless mode.\n\nThese changes aim to improve the overall user experience, provide more flexibility, and enhance the project's performance. We're thrilled to share these updates with you and look forward to continuing to evolve and improve our project!\n\n## [0.2.71] - 2024-06-26\n\n**Improved Error Handling and Performance** ðŸš§\n\n* ðŸš« Refactored `crawler_strategy.py` to handle exceptions and provide better error messages, making it more robust and reliable.\n* ðŸ’» Optimized the `get_content_of_website_optimized` function in `utils.py` for improved performance, reducing potential bottlenecks.\n* ðŸ’» Updated `utils.py` with the latest changes, ensuring consistency and accuracy.\n* ðŸš« Migrated to `ChromeDriverManager` to resolve Chrome driver download issues, providing a smoother user experience.\n\nThese changes focus on refining the existing codebase, resulting in a more stable, efficient, and user-friendly experience. With these improvements, you can expect fewer errors and better performance in the crawler strategy and utility functions.\n\n## [0.2.71] - 2024-06-25\n### Fixed\n- Speed up twice the extraction function.\n\n\n## [0.2.6] - 2024-06-22\n### Fixed\n- Fix issue #19: Update Dockerfile to ensure compatibility across multiple platforms.\n\n## [0.2.5] - 2024-06-18\n### Added\n- Added five important hooks to the crawler:\n  - on_driver_created: Called when the driver is ready for initializations.\n  - before_get_url: Called right before Selenium fetches the URL.\n  - after_get_url: Called after Selenium fetches the URL.\n  - before_return_html: Called when the data is parsed and ready.\n  - on_user_agent_updated: Called when the user changes the user_agent, causing the driver to reinitialize.\n- Added an example in `quickstart.py` in the example folder under the docs.\n- Enhancement issue #24: Replaced inline HTML tags (e.g., DEL, INS, SUB, ABBR) with textual format for better context handling in LLM.\n- Maintaining the semantic context of inline tags (e.g., abbreviation, DEL, INS) for improved LLM-friendliness.\n- Updated Dockerfile to ensure compatibility across multiple platforms (Hopefully!).\n\n## [v0.2.4] - 2024-06-17\n### Fixed\n- Fix issue #22: Use MD5 hash for caching HTML files to handle long URLs\n"
        },
        {
          "name": "CODE_OF_CONDUCT.md",
          "type": "blob",
          "size": 5.345703125,
          "content": "# Crawl4AI Code of Conduct\n\n## Our Pledge\n\nWe as members, contributors, and leaders pledge to make participation in our\ncommunity a harassment-free experience for everyone, regardless of age, body\nsize, visible or invisible disability, ethnicity, sex characteristics, gender\nidentity and expression, level of experience, education, socio-economic status,\nnationality, personal appearance, race, caste, color, religion, or sexual\nidentity and orientation.\n\nWe pledge to act and interact in ways that contribute to an open, welcoming,\ndiverse, inclusive, and healthy community.\n\n## Our Standards\n\nExamples of behavior that contributes to a positive environment for our\ncommunity include:\n\n* Demonstrating empathy and kindness toward other people\n* Being respectful of differing opinions, viewpoints, and experiences\n* Giving and gracefully accepting constructive feedback\n* Accepting responsibility and apologizing to those affected by our mistakes,\n  and learning from the experience\n* Focusing on what is best not just for us as individuals, but for the overall\n  community\n\nExamples of unacceptable behavior include:\n\n* The use of sexualized language or imagery, and sexual attention or advances of\n  any kind\n* Trolling, insulting or derogatory comments, and personal or political attacks\n* Public or private harassment\n* Publishing others' private information, such as a physical or email address,\n  without their explicit permission\n* Other conduct which could reasonably be considered inappropriate in a\n  professional setting\n\n## Enforcement Responsibilities\n\nCommunity leaders are responsible for clarifying and enforcing our standards of\nacceptable behavior and will take appropriate and fair corrective action in\nresponse to any behavior that they deem inappropriate, threatening, offensive,\nor harmful.\n\nCommunity leaders have the right and responsibility to remove, edit, or reject\ncomments, commits, code, wiki edits, issues, and other contributions that are\nnot aligned to this Code of Conduct, and will communicate reasons for moderation\ndecisions when appropriate.\n\n## Scope\n\nThis Code of Conduct applies within all community spaces, and also applies when\nan individual is officially representing the community in public spaces.\nExamples of representing our community include using an official email address,\nposting via an official social media account, or acting as an appointed\nrepresentative at an online or offline event.\n\n## Enforcement\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be\nreported to the community leaders responsible for enforcement at\nunclecode@crawl4ai.com. All complaints will be reviewed and investigated promptly and fairly.\n\nAll community leaders are obligated to respect the privacy and security of the\nreporter of any incident.\n\n## Enforcement Guidelines\n\nCommunity leaders will follow these Community Impact Guidelines in determining\nthe consequences for any action they deem in violation of this Code of Conduct:\n\n### 1. Correction\n\n**Community Impact**: Use of inappropriate language or other behavior deemed\nunprofessional or unwelcome in the community.\n\n**Consequence**: A private, written warning from community leaders, providing\nclarity around the nature of the violation and an explanation of why the\nbehavior was inappropriate. A public apology may be requested.\n\n### 2. Warning\n\n**Community Impact**: A violation through a single incident or series of\nactions.\n\n**Consequence**: A warning with consequences for continued behavior. No\ninteraction with the people involved, including unsolicited interaction with\nthose enforcing the Code of Conduct, for a specified period of time. This\nincludes avoiding interactions in community spaces as well as external channels\nlike social media. Violating these terms may lead to a temporary or permanent\nban.\n\n### 3. Temporary Ban\n\n**Community Impact**: A serious violation of community standards, including\nsustained inappropriate behavior.\n\n**Consequence**: A temporary ban from any sort of interaction or public\ncommunication with the community for a specified period of time. No public or\nprivate interaction with the people involved, including unsolicited interaction\nwith those enforcing the Code of Conduct, is allowed during this period.\nViolating these terms may lead to a permanent ban.\n\n### 4. Permanent Ban\n\n**Community Impact**: Demonstrating a pattern of violation of community\nstandards, including sustained inappropriate behavior, harassment of an\nindividual, or aggression toward or disparagement of classes of individuals.\n\n**Consequence**: A permanent ban from any sort of public interaction within the\ncommunity.\n\n## Attribution\n\nThis Code of Conduct is adapted from the [Contributor Covenant][homepage],\nversion 2.1, available at\n[https://www.contributor-covenant.org/version/2/1/code_of_conduct.html][v2.1].\n\nCommunity Impact Guidelines were inspired by\n[Mozilla's code of conduct enforcement ladder][Mozilla CoC].\n\nFor answers to common questions about this code of conduct, see the FAQ at\n[https://www.contributor-covenant.org/faq][FAQ]. Translations are available at\n[https://www.contributor-covenant.org/translations][translations].\n\n[homepage]: https://www.contributor-covenant.org\n[v2.1]: https://www.contributor-covenant.org/version/2/1/code_of_conduct.html\n[Mozilla CoC]: https://github.com/mozilla/diversity\n[FAQ]: https://www.contributor-covenant.org/faq\n[translations]: https://www.contributor-covenant.org/translations\n"
        },
        {
          "name": "CONTRIBUTORS.md",
          "type": "blob",
          "size": 2.2607421875,
          "content": "# Contributors to Crawl4AI\n\nWe would like to thank the following people for their contributions to Crawl4AI:\n\n## Core Team\n\n- [Unclecode](https://github.com/unclecode) - Project Creator and Main Developer\n- [Nasrin](https://github.com/ntohidi) - Project Manager and Developer\n- [Aravind Karnam](https://github.com/aravindkarnam) - Developer\n\n## Community Contributors\n\n- [aadityakanjolia4](https://github.com/aadityakanjolia4) - Fix for `CustomHTML2Text` is not defined.\n- [FractalMind](https://github.com/FractalMind) - Created the first official Docker Hub image and fixed Dockerfile errors\n- [ketonkss4](https://github.com/ketonkss4) - Identified Selenium's new capabilities, helping reduce dependencies\n- [jonymusky](https://github.com/jonymusky) - Javascript execution documentation, and wait_for\n- [datehoer](https://github.com/datehoer) - Add browser prxy support\n\n## Pull Requests\n\n- [dvschuyl](https://github.com/dvschuyl) - AsyncPlaywrightCrawlerStrategy page-evaluate context destroyed by navigation [#304](https://github.com/unclecode/crawl4ai/pull/304)\n- [nelzomal](https://github.com/nelzomal) - Enhance development installation instructions [#286](https://github.com/unclecode/crawl4ai/pull/286)\n- [HamzaFarhan](https://github.com/HamzaFarhan) - Handled the cases where markdown_with_citations, references_markdown, and filtered_html might not be defined [#293](https://github.com/unclecode/crawl4ai/pull/293)\n- [NanmiCoder](https://github.com/NanmiCoder) - fix: crawler strategy exception handling and fixes [#271](https://github.com/unclecode/crawl4ai/pull/271)\n- [paulokuong](https://github.com/paulokuong) - fix: RAWL4_AI_BASE_DIRECTORY should be Path object instead of string [#298](https://github.com/unclecode/crawl4ai/pull/298)\n\n\n## Other Contributors\n\n- [Gokhan](https://github.com/gkhngyk) \n- [Shiv Kumar](https://github.com/shivkumar0757)\n- [QIN2DIM](https://github.com/QIN2DIM)\n\n## Acknowledgements\n\nWe also want to thank all the users who have reported bugs, suggested features, or helped in any other way to make Crawl4AI better.\n\n---\n\nIf you've contributed to Crawl4AI and your name isn't on this list, please [open a pull request](https://github.com/unclecode/crawl4ai/pulls) with your name, link, and contribution, and we'll review it promptly.\n\nThank you all for your contributions!"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 3.345703125,
          "content": "# syntax=docker/dockerfile:1.4\n\nARG TARGETPLATFORM\nARG BUILDPLATFORM\n\n# Other build arguments\nARG PYTHON_VERSION=3.10\n\n# Base stage with system dependencies\nFROM python:${PYTHON_VERSION}-slim as base\n\n# Declare ARG variables again within the build stage\nARG INSTALL_TYPE=all\nARG ENABLE_GPU=false\n\n# Platform-specific labels\nLABEL maintainer=\"unclecode\"\nLABEL description=\"ðŸ”¥ðŸ•·ï¸ Crawl4AI: Open-source LLM Friendly Web Crawler & scraper\"\nLABEL version=\"1.0\"\n\n# Environment setup\nENV PYTHONUNBUFFERED=1 \\\n    PYTHONDONTWRITEBYTECODE=1 \\\n    PIP_NO_CACHE_DIR=1 \\\n    PIP_DISABLE_PIP_VERSION_CHECK=1 \\\n    PIP_DEFAULT_TIMEOUT=100 \\\n    DEBIAN_FRONTEND=noninteractive\n\n# Install system dependencies\nRUN apt-get update && apt-get install -y --no-install-recommends \\\n    build-essential \\\n    curl \\\n    wget \\\n    gnupg \\\n    git \\\n    cmake \\\n    pkg-config \\\n    python3-dev \\\n    libjpeg-dev \\\n    libpng-dev \\\n    && rm -rf /var/lib/apt/lists/*\n\n# Playwright system dependencies for Linux\nRUN apt-get update && apt-get install -y --no-install-recommends \\\n    libglib2.0-0 \\\n    libnss3 \\\n    libnspr4 \\\n    libatk1.0-0 \\\n    libatk-bridge2.0-0 \\\n    libcups2 \\\n    libdrm2 \\\n    libdbus-1-3 \\\n    libxcb1 \\\n    libxkbcommon0 \\\n    libx11-6 \\\n    libxcomposite1 \\\n    libxdamage1 \\\n    libxext6 \\\n    libxfixes3 \\\n    libxrandr2 \\\n    libgbm1 \\\n    libpango-1.0-0 \\\n    libcairo2 \\\n    libasound2 \\\n    libatspi2.0-0 \\\n    && rm -rf /var/lib/apt/lists/*\n\n# GPU support if enabled and architecture is supported\nRUN if [ \"$ENABLE_GPU\" = \"true\" ] && [ \"$TARGETPLATFORM\" = \"linux/amd64\" ] ; then \\\n    apt-get update && apt-get install -y --no-install-recommends \\\n    nvidia-cuda-toolkit \\\n    && rm -rf /var/lib/apt/lists/* ; \\\nelse \\\n    echo \"Skipping NVIDIA CUDA Toolkit installation (unsupported platform or GPU disabled)\"; \\\nfi\n\n# Create and set working directory\nWORKDIR /app\n\n# Copy the entire project\nCOPY . .\n\n# Install base requirements\nRUN pip install --no-cache-dir -r requirements.txt\n\n# Install required library for FastAPI\nRUN pip install fastapi uvicorn psutil\n\n# Install ML dependencies first for better layer caching\nRUN if [ \"$INSTALL_TYPE\" = \"all\" ] ; then \\\n        pip install --no-cache-dir \\\n            torch \\\n            torchvision \\\n            torchaudio \\\n            scikit-learn \\\n            nltk \\\n            transformers \\\n            tokenizers && \\\n        python -m nltk.downloader punkt stopwords ; \\\n    fi\n\n# Install the package\nRUN if [ \"$INSTALL_TYPE\" = \"all\" ] ; then \\\n        pip install \".[all]\" && \\\n        python -m crawl4ai.model_loader ; \\\n    elif [ \"$INSTALL_TYPE\" = \"torch\" ] ; then \\\n        pip install \".[torch]\" ; \\\n    elif [ \"$INSTALL_TYPE\" = \"transformer\" ] ; then \\\n        pip install \".[transformer]\" && \\\n        python -m crawl4ai.model_loader ; \\\n    else \\\n        pip install \".\" ; \\\n    fi\n\n    # Install MkDocs and required plugins\nRUN pip install --no-cache-dir \\\n    mkdocs \\\n    mkdocs-material \\\n    mkdocs-terminal \\\n    pymdown-extensions\n\n# Build MkDocs documentation\nRUN mkdocs build\n\n# Install Playwright and browsers\nRUN if [ \"$TARGETPLATFORM\" = \"linux/amd64\" ]; then \\\n    playwright install chromium; \\\n    elif [ \"$TARGETPLATFORM\" = \"linux/arm64\" ]; then \\\n    playwright install chromium; \\\n    fi\n\n# Expose port\nEXPOSE 8000 11235 9222 8080\n\n# Start the FastAPI server\nCMD [\"uvicorn\", \"main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"11235\"]"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 8.9208984375,
          "content": "Apache License\nVersion 2.0, January 2004\nhttp://www.apache.org/licenses/\n\nTERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n1. Definitions.\n\n\"License\" shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document.\n\n\"Licensor\" shall mean the copyright owner or entity authorized by the copyright owner that is granting the License.\n\n\"Legal Entity\" shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, \"control\" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity.\n\n\"You\" (or \"Your\") shall mean an individual or Legal Entity exercising permissions granted by this License.\n\n\"Source\" form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files.\n\n\"Object\" form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types.\n\n\"Work\" shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below).\n\n\"Derivative Works\" shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof.\n\n\"Contribution\" shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, \"submitted\" means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \"Not a Contribution.\"\n\n\"Contributor\" shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work.\n\n2. Grant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form.\n\n3. Grant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed.\n\n4. Redistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions:\n\nYou must give any other recipients of the Work or Derivative Works a copy of this License; and\nYou must cause any modified files to carry prominent notices stating that You changed the files; and\nYou must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and\nIf the Work includes a \"NOTICE\" text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License.\nYou may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License.\n\n5. Submission of Contributions. Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions.\n\n6. Trademarks. This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file.\n\n7. Disclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License.\n\n8. Limitation of Liability. In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages.\n\n9. Accepting Warranty or Additional Liability. While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability.\n\nEND OF TERMS AND CONDITIONS"
        },
        {
          "name": "MANIFEST.in",
          "type": "blob",
          "size": 0.0654296875,
          "content": "include requirements.txt\nrecursive-include crawl4ai/js_snippet *.js"
        },
        {
          "name": "MISSION.md",
          "type": "blob",
          "size": 4.224609375,
          "content": "# Mission\n\n![Mission Diagram](./docs/assets/pitch-dark.svg)\n\n### 1. The Data Capitalization Opportunity\n\nWe live in an unprecedented era of digital wealth creation. Every day, individuals and enterprises generate massive amounts of valuable digital footprints across various platforms, social media channels, messenger apps, and cloud services. While people can interact with their data within these platforms, there's an immense untapped opportunity to transform this data into true capital assets. Just as physical property became a foundational element of wealth creation, personal and enterprise data has the potential to become a new form of capital on balance sheets.\n\nFor individuals, this represents an opportunity to transform their digital activities into valuable assets. For enterprises, their internal communications, team discussions, and collaborative documents contain rich insights that could be structured and valued as intellectual capital. This wealth of information represents an unprecedented opportunity for value creation in the digital age.\n\n### 2. The Potential of Authentic Data\n\nWhile synthetic data has played a crucial role in AI development, there's an enormous untapped potential in the authentic data generated by individuals and organizations. Every message, document, and interaction contains unique insights and patterns that could enhance AI development. The challenge isn't a lack of data - it's that most authentic human-generated data remains inaccessible for productive use.\n\nBy enabling willing participation in data sharing, we can unlock this vast reservoir of authentic human knowledge. This represents an opportunity to enhance AI development with diverse, real-world data that reflects the full spectrum of human experience and knowledge.\n\n## Our Pathway to Data Democracy\n\n### 1. Open-Source Foundation\n\nOur first step is creating an open-source data extraction engine that empowers developers and innovators to build tools for data structuring and organization. This foundation ensures transparency, security, and community-driven development. By making these tools openly available, we enable the technical infrastructure needed for true data ownership and capitalization.\n\n### 2. Data Capitalization Platform\n\nBuilding on this open-source foundation, we're developing a platform that helps individuals and enterprises transform their digital footprints into structured, valuable assets. This platform will provide the tools and frameworks needed to organize, understand, and value personal and organizational data as true capital assets.\n\n### 3. Creating a Data Marketplace\n\nThe final piece is establishing a marketplace where individuals and organizations can willingly share their data assets. This creates opportunities for:\n- Individuals to earn equity, revenue, or other forms of value from their data\n- Enterprises to access diverse, high-quality data for AI development\n- Researchers to work with authentic human-generated data\n- Startups to build innovative solutions using real-world data\n\n## Economic Vision: A Shared Data Economy\n\nWe envision a future where data becomes a fundamental asset class in a thriving shared economy. This transformation will democratize AI development by enabling willing participation in data sharing, ensuring that the benefits of AI advancement flow back to data creators. Just as property rights revolutionized economic systems, establishing data as a capital asset will create new opportunities for wealth creation and economic participation.\n\nThis shared data economy will:\n- Enable individuals to capitalize on their digital footprints\n- Create new revenue streams for data creators\n- Provide AI developers with access to diverse, authentic data\n- Foster innovation through broader access to real-world data\n- Ensure more equitable distribution of AI's economic benefits\n\nOur vision is to facilitate this transformation from the ground up - starting with open-source tools, progressing to data capitalization platforms, and ultimately creating a thriving marketplace where data becomes a true asset class in a shared economy. This approach ensures that the future of AI is built on a foundation of authentic human knowledge, with benefits flowing back to the individuals and organizations who create and share their valuable data."
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 22.580078125,
          "content": "# ðŸš€ðŸ¤– Crawl4AI: Open-source LLM Friendly Web Crawler & Scraper.\n\n<div align=\"center\">\n\n<a href=\"https://trendshift.io/repositories/11716\" target=\"_blank\"><img src=\"https://trendshift.io/api/badge/repositories/11716\" alt=\"unclecode%2Fcrawl4ai | Trendshift\" style=\"width: 250px; height: 55px;\" width=\"250\" height=\"55\"/></a>\n\n[![GitHub Stars](https://img.shields.io/github/stars/unclecode/crawl4ai?style=social)](https://github.com/unclecode/crawl4ai/stargazers)\n[![GitHub Forks](https://img.shields.io/github/forks/unclecode/crawl4ai?style=social)](https://github.com/unclecode/crawl4ai/network/members)\n\n[![PyPI version](https://badge.fury.io/py/crawl4ai.svg)](https://badge.fury.io/py/crawl4ai)\n[![Python Version](https://img.shields.io/pypi/pyversions/crawl4ai)](https://pypi.org/project/crawl4ai/)\n[![Downloads](https://static.pepy.tech/badge/crawl4ai/month)](https://pepy.tech/project/crawl4ai)\n\n<!-- [![Documentation Status](https://readthedocs.org/projects/crawl4ai/badge/?version=latest)](https://crawl4ai.readthedocs.io/) -->\n[![License](https://img.shields.io/github/license/unclecode/crawl4ai)](https://github.com/unclecode/crawl4ai/blob/main/LICENSE)\n[![Code style: black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/psf/black)\n[![Security: bandit](https://img.shields.io/badge/security-bandit-yellow.svg)](https://github.com/PyCQA/bandit)\n[![Contributor Covenant](https://img.shields.io/badge/Contributor%20Covenant-2.1-4baaaa.svg)](code_of_conduct.md)\n\n</div>\n\nCrawl4AI is the #1 trending GitHub repository, actively maintained by a vibrant community. It delivers blazing-fast, AI-ready web crawling tailored for LLMs, AI agents, and data pipelines. Open source, flexible, and built for real-time performance, Crawl4AI empowers developers with unmatched speed, precision, and deployment ease.  \n\n[âœ¨ Check out latest update v0.4.24x](#-recent-updates)\n\nðŸŽ‰ **Version 0.4.24x is out!** Major improvements in extraction strategies with enhanced JSON handling, SSL security, and Amazon product extraction. Plus, a completely revamped content filtering system! [Read the release notes â†’](https://docs.crawl4ai.com/blog)\n\n## ðŸ§ Why Crawl4AI?\n\n1. **Built for LLMs**: Creates smart, concise Markdown optimized for RAG and fine-tuning applications.  \n2. **Lightning Fast**: Delivers results 6x faster with real-time, cost-efficient performance.  \n3. **Flexible Browser Control**: Offers session management, proxies, and custom hooks for seamless data access.  \n4. **Heuristic Intelligence**: Uses advanced algorithms for efficient extraction, reducing reliance on costly models.  \n5. **Open Source & Deployable**: Fully open-source with no API keysâ€”ready for Docker and cloud integration.  \n6. **Thriving Community**: Actively maintained by a vibrant community and the #1 trending GitHub repository.\n\n## ðŸš€ Quick Start \n\n1. Install Crawl4AI:\n```bash\n# Install the package\npip install -U crawl4ai\n\n# Run post-installation setup\ncrawl4ai-setup\n\n# Verify your installation\ncrawl4ai-doctor\n```\n\nIf you encounter any browser-related issues, you can install them manually:\n```bash\npython -m playwright install --with-deps chromium\n```\n\n2. Run a simple web crawl:\n```python\nimport asyncio\nfrom crawl4ai import *\n\nasync def main():\n    async with AsyncWebCrawler() as crawler:\n        result = await crawler.arun(\n            url=\"https://www.nbcnews.com/business\",\n        )\n        print(result.markdown)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n## âœ¨ Features \n\n<details>\n<summary>ðŸ“ <strong>Markdown Generation</strong></summary>\n\n- ðŸ§¹ **Clean Markdown**: Generates clean, structured Markdown with accurate formatting.\n- ðŸŽ¯ **Fit Markdown**: Heuristic-based filtering to remove noise and irrelevant parts for AI-friendly processing.\n- ðŸ”— **Citations and References**: Converts page links into a numbered reference list with clean citations.\n- ðŸ› ï¸ **Custom Strategies**: Users can create their own Markdown generation strategies tailored to specific needs.\n- ðŸ“š **BM25 Algorithm**: Employs BM25-based filtering for extracting core information and removing irrelevant content. \n</details>\n\n<details>\n<summary>ðŸ“Š <strong>Structured Data Extraction</strong></summary>\n\n- ðŸ¤– **LLM-Driven Extraction**: Supports all LLMs (open-source and proprietary) for structured data extraction.\n- ðŸ§± **Chunking Strategies**: Implements chunking (topic-based, regex, sentence-level) for targeted content processing.\n- ðŸŒŒ **Cosine Similarity**: Find relevant content chunks based on user queries for semantic extraction.\n- ðŸ”Ž **CSS-Based Extraction**: Fast schema-based data extraction using XPath and CSS selectors.\n- ðŸ”§ **Schema Definition**: Define custom schemas for extracting structured JSON from repetitive patterns.\n\n</details>\n\n<details>\n<summary>ðŸŒ <strong>Browser Integration</strong></summary>\n\n- ðŸ–¥ï¸ **Managed Browser**: Use user-owned browsers with full control, avoiding bot detection.\n- ðŸ”„ **Remote Browser Control**: Connect to Chrome Developer Tools Protocol for remote, large-scale data extraction.\n- ðŸ”’ **Session Management**: Preserve browser states and reuse them for multi-step crawling.\n- ðŸ§© **Proxy Support**: Seamlessly connect to proxies with authentication for secure access.\n- âš™ï¸ **Full Browser Control**: Modify headers, cookies, user agents, and more for tailored crawling setups.\n- ðŸŒ **Multi-Browser Support**: Compatible with Chromium, Firefox, and WebKit.\n- ðŸ“ **Dynamic Viewport Adjustment**: Automatically adjusts the browser viewport to match page content, ensuring complete rendering and capturing of all elements.\n\n</details>\n\n<details>\n<summary>ðŸ”Ž <strong>Crawling & Scraping</strong></summary>\n\n- ðŸ–¼ï¸ **Media Support**: Extract images, audio, videos, and responsive image formats like `srcset` and `picture`.\n- ðŸš€ **Dynamic Crawling**: Execute JS and wait for async or sync for dynamic content extraction.\n- ðŸ“¸ **Screenshots**: Capture page screenshots during crawling for debugging or analysis.\n- ðŸ“‚ **Raw Data Crawling**: Directly process raw HTML (`raw:`) or local files (`file://`).\n- ðŸ”— **Comprehensive Link Extraction**: Extracts internal, external links, and embedded iframe content.\n- ðŸ› ï¸ **Customizable Hooks**: Define hooks at every step to customize crawling behavior.\n- ðŸ’¾ **Caching**: Cache data for improved speed and to avoid redundant fetches.\n- ðŸ“„ **Metadata Extraction**: Retrieve structured metadata from web pages.\n- ðŸ“¡ **IFrame Content Extraction**: Seamless extraction from embedded iframe content.\n- ðŸ•µï¸ **Lazy Load Handling**: Waits for images to fully load, ensuring no content is missed due to lazy loading.\n- ðŸ”„ **Full-Page Scanning**: Simulates scrolling to load and capture all dynamic content, perfect for infinite scroll pages.\n\n</details>\n\n<details>\n<summary>ðŸš€ <strong>Deployment</strong></summary>\n\n- ðŸ³ **Dockerized Setup**: Optimized Docker image with API server for easy deployment.\n- ðŸ”„ **API Gateway**: One-click deployment with secure token authentication for API-based workflows.\n- ðŸŒ **Scalable Architecture**: Designed for mass-scale production and optimized server performance.\n- âš™ï¸ **DigitalOcean Deployment**: Ready-to-deploy configurations for DigitalOcean and similar platforms.\n\n</details>\n\n<details>\n<summary>ðŸŽ¯ <strong>Additional Features</strong></summary>\n\n- ðŸ•¶ï¸ **Stealth Mode**: Avoid bot detection by mimicking real users.\n- ðŸ·ï¸ **Tag-Based Content Extraction**: Refine crawling based on custom tags, headers, or metadata.\n- ðŸ”— **Link Analysis**: Extract and analyze all links for detailed data exploration.\n- ðŸ›¡ï¸ **Error Handling**: Robust error management for seamless execution.\n- ðŸ” **CORS & Static Serving**: Supports filesystem-based caching and cross-origin requests.\n- ðŸ“– **Clear Documentation**: Simplified and updated guides for onboarding and advanced usage.\n- ðŸ™Œ **Community Recognition**: Acknowledges contributors and pull requests for transparency.\n\n</details>\n\n## Try it Now!\n\nâœ¨ Play around with this [![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/drive/1SgRPrByQLzjRfwoRNq1wSGE9nYY_EE8C?usp=sharing)\n\nâœ¨ Visit our [Documentation Website](https://docs.crawl4ai.com/)\n\n## Installation ðŸ› ï¸\n\nCrawl4AI offers flexible installation options to suit various use cases. You can install it as a Python package or use Docker.\n\n<details>\n<summary>ðŸ <strong>Using pip</strong></summary>\n\nChoose the installation option that best fits your needs:\n\n### Basic Installation\n\nFor basic web crawling and scraping tasks:\n\n```bash\npip install crawl4ai\ncrawl4ai-setup # Setup the browser\n```\n\nBy default, this will install the asynchronous version of Crawl4AI, using Playwright for web crawling.\n\nðŸ‘‰ **Note**: When you install Crawl4AI, the `crawl4ai-setup` should automatically install and set up Playwright. However, if you encounter any Playwright-related errors, you can manually install it using one of these methods:\n\n1. Through the command line:\n\n   ```bash\n   playwright install\n   ```\n\n2. If the above doesn't work, try this more specific command:\n\n   ```bash\n   python -m playwright install chromium\n   ```\n\nThis second method has proven to be more reliable in some cases.\n\n---\n\n### Installation with Synchronous Version\n\nThe sync version is deprecated and will be removed in future versions. If you need the synchronous version using Selenium:\n\n```bash\npip install crawl4ai[sync]\n```\n\n---\n\n### Development Installation\n\nFor contributors who plan to modify the source code:\n\n```bash\ngit clone https://github.com/unclecode/crawl4ai.git\ncd crawl4ai\npip install -e .                    # Basic installation in editable mode\n```\n\nInstall optional features:\n\n```bash\npip install -e \".[torch]\"           # With PyTorch features\npip install -e \".[transformer]\"     # With Transformer features\npip install -e \".[cosine]\"          # With cosine similarity features\npip install -e \".[sync]\"            # With synchronous crawling (Selenium)\npip install -e \".[all]\"             # Install all optional features\n```\n\n</details>\n\n<details>\n<summary>ðŸ³ <strong>Docker Deployment</strong></summary>\n\n> ðŸš€ **Major Changes Coming!** We're developing a completely new Docker implementation that will make deployment even more efficient and seamless. The current Docker setup is being deprecated in favor of this new solution.\n\n### Current Docker Support\n\nThe existing Docker implementation is being deprecated and will be replaced soon. If you still need to use Docker with the current version:\n\n- ðŸ“š [Deprecated Docker Setup](./docs/deprecated/docker-deployment.md) - Instructions for the current Docker implementation\n- âš ï¸ Note: This setup will be replaced in the next major release\n\n### What's Coming Next?\n\nOur new Docker implementation will bring:\n- Improved performance and resource efficiency\n- Streamlined deployment process\n- Better integration with Crawl4AI features\n- Enhanced scalability options\n\nStay connected with our [GitHub repository](https://github.com/unclecode/crawl4ai) for updates!\n\n</details>\n\n---\n\n### Quick Test\n\nRun a quick test (works for both Docker options):\n\n```python\nimport requests\n\n# Submit a crawl job\nresponse = requests.post(\n    \"http://localhost:11235/crawl\",\n    json={\"urls\": \"https://example.com\", \"priority\": 10}\n)\ntask_id = response.json()[\"task_id\"]\n\n# Continue polling until the task is complete (status=\"completed\")\nresult = requests.get(f\"http://localhost:11235/task/{task_id}\")\n```\n\nFor more examples, see our [Docker Examples](https://github.com/unclecode/crawl4ai/blob/main/docs/examples/docker_example.py). For advanced configuration, environment variables, and usage examples, see our [Docker Deployment Guide](https://docs.crawl4ai.com/basic/docker-deployment/).\n\n</details>\n\n\n## ðŸ”¬ Advanced Usage Examples ðŸ”¬\n\nYou can check the project structure in the directory [https://github.com/unclecode/crawl4ai/docs/examples](docs/examples). Over there, you can find a variety of examples; here, some popular examples are shared.\n\n<details>\n<summary>ðŸ“ <strong>Heuristic Markdown Generation with Clean and Fit Markdown</strong></summary>\n\n```python\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler, BrowserConfig, CrawlerRunConfig, CacheMode\nfrom crawl4ai.content_filter_strategy import PruningContentFilter, BM25ContentFilter\nfrom crawl4ai.markdown_generation_strategy import DefaultMarkdownGenerator\n\nasync def main():\n    browser_config = BrowserConfig(\n        headless=True,  \n        verbose=True,\n    )\n    run_config = CrawlerRunConfig(\n        cache_mode=CacheMode.ENABLED,\n        markdown_generator=DefaultMarkdownGenerator(\n            content_filter=PruningContentFilter(threshold=0.48, threshold_type=\"fixed\", min_word_threshold=0)\n        ),\n        # markdown_generator=DefaultMarkdownGenerator(\n        #     content_filter=BM25ContentFilter(user_query=\"WHEN_WE_FOCUS_BASED_ON_A_USER_QUERY\", bm25_threshold=1.0)\n        # ),\n    )\n    \n    async with AsyncWebCrawler(config=browser_config) as crawler:\n        result = await crawler.arun(\n            url=\"https://docs.micronaut.io/4.7.6/guide/\",\n            config=run_config\n        )\n        print(len(result.markdown))\n        print(len(result.fit_markdown))\n        print(len(result.markdown_v2.fit_markdown))\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n</details>\n\n<details>\n<summary>ðŸ–¥ï¸ <strong>Executing JavaScript & Extract Structured Data without LLMs</strong></summary>\n\n```python\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler, BrowserConfig, CrawlerRunConfig, CacheMode\nfrom crawl4ai.extraction_strategy import JsonCssExtractionStrategy\nimport json\n\nasync def main():\n    schema = {\n    \"name\": \"KidoCode Courses\",\n    \"baseSelector\": \"section.charge-methodology .w-tab-content > div\",\n    \"fields\": [\n        {\n            \"name\": \"section_title\",\n            \"selector\": \"h3.heading-50\",\n            \"type\": \"text\",\n        },\n        {\n            \"name\": \"section_description\",\n            \"selector\": \".charge-content\",\n            \"type\": \"text\",\n        },\n        {\n            \"name\": \"course_name\",\n            \"selector\": \".text-block-93\",\n            \"type\": \"text\",\n        },\n        {\n            \"name\": \"course_description\",\n            \"selector\": \".course-content-text\",\n            \"type\": \"text\",\n        },\n        {\n            \"name\": \"course_icon\",\n            \"selector\": \".image-92\",\n            \"type\": \"attribute\",\n            \"attribute\": \"src\"\n        }\n    }\n}\n\n    extraction_strategy = JsonCssExtractionStrategy(schema, verbose=True)\n\n    browser_config = BrowserConfig(\n        headless=False,\n        verbose=True\n    )\n    run_config = CrawlerRunConfig(\n        extraction_strategy=extraction_strategy,\n        js_code=[\"\"\"(async () => {const tabs = document.querySelectorAll(\"section.charge-methodology .tabs-menu-3 > div\");for(let tab of tabs) {tab.scrollIntoView();tab.click();await new Promise(r => setTimeout(r, 500));}})();\"\"\"],\n        cache_mode=CacheMode.BYPASS\n    )\n        \n    async with AsyncWebCrawler(config=browser_config) as crawler:\n        \n        result = await crawler.arun(\n            url=\"https://www.kidocode.com/degrees/technology\",\n            config=run_config\n        )\n\n        companies = json.loads(result.extracted_content)\n        print(f\"Successfully extracted {len(companies)} companies\")\n        print(json.dumps(companies[0], indent=2))\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n</details>\n\n<details>\n<summary>ðŸ“š <strong>Extracting Structured Data with LLMs</strong></summary>\n\n```python\nimport os\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler, BrowserConfig, CrawlerRunConfig, CacheMode\nfrom crawl4ai.extraction_strategy import LLMExtractionStrategy\nfrom pydantic import BaseModel, Field\n\nclass OpenAIModelFee(BaseModel):\n    model_name: str = Field(..., description=\"Name of the OpenAI model.\")\n    input_fee: str = Field(..., description=\"Fee for input token for the OpenAI model.\")\n    output_fee: str = Field(..., description=\"Fee for output token for the OpenAI model.\")\n\nasync def main():\n    browser_config = BrowserConfig(verbose=True)\n    run_config = CrawlerRunConfig(\n        word_count_threshold=1,\n        extraction_strategy=LLMExtractionStrategy(\n            # Here you can use any provider that Litellm library supports, for instance: ollama/qwen2\n            # provider=\"ollama/qwen2\", api_token=\"no-token\", \n            provider=\"openai/gpt-4o\", api_token=os.getenv('OPENAI_API_KEY'), \n            schema=OpenAIModelFee.schema(),\n            extraction_type=\"schema\",\n            instruction=\"\"\"From the crawled content, extract all mentioned model names along with their fees for input and output tokens. \n            Do not miss any models in the entire content. One extracted model JSON format should look like this: \n            {\"model_name\": \"GPT-4\", \"input_fee\": \"US$10.00 / 1M tokens\", \"output_fee\": \"US$30.00 / 1M tokens\"}.\"\"\"\n        ),            \n        cache_mode=CacheMode.BYPASS,\n    )\n    \n    async with AsyncWebCrawler(config=browser_config) as crawler:\n        result = await crawler.arun(\n            url='https://openai.com/api/pricing/',\n            config=run_config\n        )\n        print(result.extracted_content)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n</details>\n\n<details>\n<summary>ðŸ¤– <strong>Using You own Browswer with Custome User Profile</strong></summary>\n\n```python\nimport os, sys\nfrom pathlib import Path\nimport asyncio, time\nfrom crawl4ai import AsyncWebCrawler, BrowserConfig, CrawlerRunConfig, CacheMode\n\nasync def test_news_crawl():\n    # Create a persistent user data directory\n    user_data_dir = os.path.join(Path.home(), \".crawl4ai\", \"browser_profile\")\n    os.makedirs(user_data_dir, exist_ok=True)\n\n    browser_config = BrowserConfig(\n        verbose=True,\n        headless=True,\n        user_data_dir=user_data_dir,\n        use_persistent_context=True,\n    )\n    run_config = CrawlerRunConfig(\n        cache_mode=CacheMode.BYPASS\n    )\n    \n    async with AsyncWebCrawler(config=browser_config) as crawler:\n        url = \"ADDRESS_OF_A_CHALLENGING_WEBSITE\"\n        \n        result = await crawler.arun(\n            url,\n            config=run_config,\n            magic=True,\n        )\n        \n        print(f\"Successfully crawled {url}\")\n        print(f\"Content length: {len(result.markdown)}\")\n```\n\n</details>\n\n\n## âœ¨ Recent Updates   \n\n- ðŸ”’ **Enhanced SSL & Security**: New SSL certificate handling with custom paths and validation options for secure crawling\n- ðŸ” **Smart Content Filtering**: Advanced filtering system with regex support and efficient chunking strategies\n- ðŸ“¦ **Improved JSON Extraction**: Support for complex JSONPath, JSON-CSS, and Microdata extraction\n- ðŸ—ï¸ **New Field Types**: Added `computed`, `conditional`, `aggregate`, and `template` field types\n- âš¡ **Performance Boost**: Optimized caching, parallel processing, and memory management\n- ðŸ› **Better Error Handling**: Enhanced debugging capabilities with detailed error tracking\n- ðŸ” **Security Features**: Improved input validation and safe expression evaluation\n\nRead the full details of this release in our [0.4.24 Release Notes](https://github.com/unclecode/crawl4ai/blob/main/CHANGELOG.md).\n\n## ðŸ“– Documentation & Roadmap \n\n> ðŸš¨ **Documentation Update Alert**: We're undertaking a major documentation overhaul next week to reflect recent updates and improvements. Stay tuned for a more comprehensive and up-to-date guide!\n\nFor current documentation, including installation instructions, advanced features, and API reference, visit our [Documentation Website](https://docs.crawl4ai.com/).\n\nTo check our development plans and upcoming features, visit our [Roadmap](https://github.com/unclecode/crawl4ai/blob/main/ROADMAP.md).\n\n<details>\n<summary>ðŸ“ˆ <strong>Development TODOs</strong></summary>\n\n- [x] 0. Graph Crawler: Smart website traversal using graph search algorithms for comprehensive nested page extraction\n- [ ] 1. Question-Based Crawler: Natural language driven web discovery and content extraction\n- [ ] 2. Knowledge-Optimal Crawler: Smart crawling that maximizes knowledge while minimizing data extraction\n- [ ] 3. Agentic Crawler: Autonomous system for complex multi-step crawling operations\n- [ ] 4. Automated Schema Generator: Convert natural language to extraction schemas\n- [ ] 5. Domain-Specific Scrapers: Pre-configured extractors for common platforms (academic, e-commerce)\n- [ ] 6. Web Embedding Index: Semantic search infrastructure for crawled content\n- [ ] 7. Interactive Playground: Web UI for testing, comparing strategies with AI assistance\n- [ ] 8. Performance Monitor: Real-time insights into crawler operations\n- [ ] 9. Cloud Integration: One-click deployment solutions across cloud providers\n- [ ] 10. Sponsorship Program: Structured support system with tiered benefits\n- [ ] 11. Educational Content: \"How to Crawl\" video series and interactive tutorials\n\n</details>\n\n## ðŸ¤ Contributing \n\nWe welcome contributions from the open-source community. Check out our [contribution guidelines](https://github.com/unclecode/crawl4ai/blob/main/CONTRIBUTING.md) for more information.\n\n## ðŸ“„ License \n\nCrawl4AI is released under the [Apache 2.0 License](https://github.com/unclecode/crawl4ai/blob/main/LICENSE).\n\n## ðŸ“§ Contact \n\nFor questions, suggestions, or feedback, feel free to reach out:\n\n- GitHub: [unclecode](https://github.com/unclecode)\n- Twitter: [@unclecode](https://twitter.com/unclecode)\n- Website: [crawl4ai.com](https://crawl4ai.com)\n\nHappy Crawling! ðŸ•¸ï¸ðŸš€\n\n## ðŸ—¾ Mission\n\nOur mission is to unlock the value of personal and enterprise data by transforming digital footprints into structured, tradeable assets. Crawl4AI empowers individuals and organizations with open-source tools to extract and structure data, fostering a shared data economy.  \n\nWe envision a future where AI is powered by real human knowledge, ensuring data creators directly benefit from their contributions. By democratizing data and enabling ethical sharing, we are laying the foundation for authentic AI advancement.\n\n<details>\n<summary>ðŸ”‘ <strong>Key Opportunities</strong></summary>\n \n- **Data Capitalization**: Transform digital footprints into measurable, valuable assets.  \n- **Authentic AI Data**: Provide AI systems with real human insights.  \n- **Shared Economy**: Create a fair data marketplace that benefits data creators.  \n\n</details>\n\n<details>\n<summary>ðŸš€ <strong>Development Pathway</strong></summary>\n\n1. **Open-Source Tools**: Community-driven platforms for transparent data extraction.  \n2. **Digital Asset Structuring**: Tools to organize and value digital knowledge.  \n3. **Ethical Data Marketplace**: A secure, fair platform for exchanging structured data.  \n\nFor more details, see our [full mission statement](./MISSION.md).\n</details>\n\n## Star History\n\n[![Star History Chart](https://api.star-history.com/svg?repos=unclecode/crawl4ai&type=Date)](https://star-history.com/#unclecode/crawl4ai&Date)\n"
        },
        {
          "name": "ROADMAP.md",
          "type": "blob",
          "size": 15.3046875,
          "content": "# Crawl4AI Strategic Roadmap\n\n```mermaid\n%%{init: {'themeVariables': { 'fontSize': '14px'}}}%%\ngraph TD\n    subgraph A1[Advanced Crawling Systems ðŸ”§]\n        A[\"`\n        â€¢ Graph Crawler âœ“\n        â€¢ Question-Based Crawler\n        â€¢ Knowledge-Optimal Crawler\n        â€¢ Agentic Crawler\n        `\"]\n    end\n\n    subgraph A2[Specialized Features ðŸ› ï¸]\n        B[\"`\n        â€¢ Automated Schema Generator\n        â€¢ Domain-Specific Scrapers\n        â€¢ \n        â€¢ \n        `\"]\n    end\n\n    subgraph A3[Development Tools ðŸ”¨]\n        C[\"`\n        â€¢ Interactive Playground\n        â€¢ Performance Monitor\n        â€¢ Cloud Integration\n        â€¢ \n        `\"]\n    end\n\n    subgraph A4[Community & Growth ðŸŒ±]\n        D[\"`\n        â€¢ Sponsorship Program\n        â€¢ Educational Content\n        â€¢ \n        â€¢ \n        `\"]\n    end\n\n    classDef default fill:#f9f9f9,stroke:#333,stroke-width:2px\n    classDef section fill:#f0f0f0,stroke:#333,stroke-width:4px,rx:10\n    class A1,A2,A3,A4 section\n\n    %% Layout hints\n    A1 --> A2[\" \"]\n    A3 --> A4[\" \"]\n    linkStyle 0,1 stroke:none\n```\n\nCrawl4AI is evolving to provide more intelligent, efficient, and versatile web crawling capabilities. This roadmap outlines the key developments and features planned for the project, organized into strategic sections that build upon our current foundation.\n\n## 1. Advanced Crawling Systems ðŸ”§\n\nThis section introduces three powerful crawling systems that extend Crawl4AI's capabilities from basic web crawling to intelligent, purpose-driven data extraction.\n\n### 1.1 Question-Based Crawler\nThe Question-Based Crawler enhances our core engine by enabling automatic discovery and extraction of relevant web content based on natural language questions.\n\nKey Features:\n- SerpiAPI integration for intelligent web search\n- Relevancy scoring for search results\n- Automatic URL discovery and prioritization\n- Cross-source validation\n\n```python\nfrom crawl4ai import AsyncWebCrawler\nfrom crawl4ai.discovery import QuestionBasedDiscovery\n\nasync with AsyncWebCrawler() as crawler:\n    discovery = QuestionBasedDiscovery(crawler)\n    results = await discovery.arun(\n        question=\"What are the system requirements for major cloud providers' GPU instances?\",\n        max_urls=5,\n        relevance_threshold=0.7\n    )\n    \n    for result in results:\n        print(f\"Source: {result.url} (Relevance: {result.relevance_score})\")\n        print(f\"Content: {result.markdown}\\n\")\n```\n\n### 1.2 Knowledge-Optimal Crawler\nAn intelligent crawling system that solves the optimization problem of minimizing data extraction while maximizing knowledge acquisition for specific objectives.\n\nKey Features:\n- Smart content prioritization\n- Minimal data extraction for maximum knowledge\n- Probabilistic relevance assessment\n- Objective-driven crawling paths\n\n```python\nfrom crawl4ai import AsyncWebCrawler\nfrom crawl4ai.optimization import KnowledgeOptimizer\n\nasync with AsyncWebCrawler() as crawler:\n    optimizer = KnowledgeOptimizer(\n        objective=\"Understand GPU instance pricing and limitations across cloud providers\",\n        required_knowledge=[\n            \"pricing structure\",\n            \"GPU specifications\",\n            \"usage limits\",\n            \"availability zones\"\n        ],\n        confidence_threshold=0.85\n    )\n    \n    result = await crawler.arun(\n        urls=[\n            \"https://aws.amazon.com/ec2/pricing/\",\n            \"https://cloud.google.com/gpu\",\n            \"https://azure.microsoft.com/pricing/\"\n        ],\n        optimizer=optimizer,\n        optimization_mode=\"minimal_extraction\"\n    )\n    \n    print(f\"Knowledge Coverage: {result.knowledge_coverage}\")\n    print(f\"Data Efficiency: {result.efficiency_ratio}\")\n    print(f\"Extracted Content: {result.optimal_content}\")\n```\n\n### 1.3 Agentic Crawler\nAn autonomous system capable of understanding complex goals and automatically planning and executing multi-step crawling operations.\n\nKey Features:\n- Autonomous goal interpretation\n- Dynamic step planning\n- Interactive navigation capabilities\n- Visual recognition and interaction\n- Automatic error recovery\n\n```python\nfrom crawl4ai import AsyncWebCrawler\nfrom crawl4ai.agents import CrawlerAgent\n\nasync with AsyncWebCrawler() as crawler:\n    agent = CrawlerAgent(crawler)\n    \n    # Automatic planning and execution\n    result = await agent.arun(\n        goal=\"Find research papers about quantum computing published in 2023 with more than 50 citations\",\n        auto_retry=True\n    )\n    print(\"Generated Plan:\", result.executed_steps)\n    print(\"Extracted Data:\", result.data)\n    \n    # Using custom steps with automatic execution\n    result = await agent.arun(\n        goal=\"Extract conference deadlines from ML conferences\",\n        custom_plan=[\n            \"Navigate to conference page\",\n            \"Find important dates section\",\n            \"Extract submission deadlines\",\n            \"Verify dates are for 2024\"\n        ]\n    )\n    \n    # Monitoring execution\n    print(\"Step Completion:\", result.step_status)\n    print(\"Execution Time:\", result.execution_time)\n    print(\"Success Rate:\", result.success_rate)\n```\n\n# Section 2: Specialized Features ðŸ› ï¸\n\nThis section introduces specialized tools and features that enhance Crawl4AI's capabilities for specific use cases and data extraction needs.\n\n### 2.1 Automated Schema Generator\nA system that automatically generates JsonCssExtractionStrategy schemas from natural language descriptions, making structured data extraction accessible to all users.\n\nKey Features:\n- Natural language schema generation\n- Automatic pattern detection\n- Predefined schema templates\n- Chrome extension for visual schema building\n\n```python\nfrom crawl4ai import AsyncWebCrawler\nfrom crawl4ai.schema import SchemaGenerator\n\n# Generate schema from natural language description\ngenerator = SchemaGenerator()\nschema = await generator.generate(\n    url=\"https://news-website.com\",\n    description=\"For each news article on the page, I need the headline, publication date, and main image\"\n)\n\n# Use generated schema with crawler\nasync with AsyncWebCrawler() as crawler:\n    result = await crawler.arun(\n        url=\"https://news-website.com\",\n        extraction_strategy=schema\n    )\n\n# Example of generated schema:\n\"\"\"\n{\n    \"name\": \"News Article Extractor\",\n    \"baseSelector\": \"article.news-item\",\n    \"fields\": [\n        {\n            \"name\": \"headline\",\n            \"selector\": \"h2.article-title\",\n            \"type\": \"text\"\n        },\n        {\n            \"name\": \"date\",\n            \"selector\": \"span.publish-date\",\n            \"type\": \"text\"\n        },\n        {\n            \"name\": \"image\",\n            \"selector\": \"img.article-image\",\n            \"type\": \"attribute\",\n            \"attribute\": \"src\"\n        }\n    ]\n}\n\"\"\"\n```\n\n### 2.2 Domain Specific Scrapers\nSpecialized extraction strategies optimized for common website types and platforms, providing consistent and reliable data extraction without additional configuration.\n\nKey Features:\n- Pre-configured extractors for popular platforms\n- Academic site specialization (arXiv, NCBI)\n- E-commerce standardization\n- Documentation site handling\n\n```python\nfrom crawl4ai import AsyncWebCrawler\nfrom crawl4ai.extractors import AcademicExtractor, EcommerceExtractor\n\nasync with AsyncWebCrawler() as crawler:\n    # Academic paper extraction\n    papers = await crawler.arun(\n        url=\"https://arxiv.org/list/cs.AI/recent\",\n        extractor=\"academic\",  # Built-in extractor type\n        site_type=\"arxiv\",     # Specific site optimization\n        extract_fields=[\n            \"title\", \n            \"authors\", \n            \"abstract\", \n            \"citations\"\n        ]\n    )\n    \n    # E-commerce product data\n    products = await crawler.arun(\n        url=\"https://store.example.com/products\",\n        extractor=\"ecommerce\",\n        extract_fields=[\n            \"name\",\n            \"price\",\n            \"availability\",\n            \"reviews\"\n        ]\n    )\n```\n\n### 2.3 Web Embedding Index\nCreates and maintains a semantic search infrastructure for crawled content, enabling efficient retrieval and querying of web content through vector embeddings.\n\nKey Features:\n- Automatic embedding generation\n- Intelligent content chunking\n- Efficient vector storage and indexing\n- Semantic search capabilities\n\n```python\nfrom crawl4ai import AsyncWebCrawler\nfrom crawl4ai.indexing import WebIndex\n\n# Initialize and build index\nindex = WebIndex(model=\"efficient-mini\")\n\nasync with AsyncWebCrawler() as crawler:\n    # Crawl and index content\n    await index.build(\n        urls=[\"https://docs.example.com\"],\n        crawler=crawler,\n        options={\n            \"chunk_method\": \"semantic\",\n            \"update_policy\": \"incremental\",\n            \"embedding_batch_size\": 100\n        }\n    )\n\n    # Search through indexed content\n    results = await index.search(\n        query=\"How to implement OAuth authentication?\",\n        filters={\n            \"content_type\": \"technical\",\n            \"recency\": \"6months\"\n        },\n        top_k=5\n    )\n\n    # Get similar content\n    similar = await index.find_similar(\n        url=\"https://docs.example.com/auth/oauth\",\n        threshold=0.85\n    )\n```\n\nEach of these specialized features builds upon Crawl4AI's core functionality while providing targeted solutions for specific use cases. They can be used independently or combined for more complex data extraction and processing needs.\n\n# Section 3: Development Tools ðŸ”§\n\nThis section covers tools designed to enhance the development experience, monitoring, and deployment of Crawl4AI applications.\n\n### 3.1 Crawl4AI Playground ðŸŽ®\n\nThe Crawl4AI Playground is an interactive web-based development environment that simplifies web scraping experimentation, development, and deployment. With its intuitive interface and AI-powered assistance, users can quickly prototype, test, and deploy web scraping solutions.\n\n#### Key Features ðŸŒŸ\n\n##### Visual Strategy Builder\n- Interactive point-and-click interface for building extraction strategies\n- Real-time preview of selected elements\n- Side-by-side comparison of different extraction approaches\n- Visual validation of CSS selectors and XPath queries\n\n##### AI Assistant Integration\n- Strategy recommendations based on target website analysis\n- Parameter optimization suggestions\n- Best practices guidance for specific use cases\n- Automated error detection and resolution\n- Performance optimization tips\n\n##### Real-Time Testing & Validation\n- Live preview of extraction results\n- Side-by-side comparison of multiple strategies\n- Performance metrics visualization\n- Automatic validation of extracted data\n- Error detection and debugging tools\n\n##### Project Management\n- Save and organize multiple scraping projects\n- Version control for configurations\n- Export/import project settings\n- Share configurations with team members\n- Project templates for common use cases\n\n##### Deployment Pipeline\n- One-click deployment to various environments\n- Docker container generation\n- Cloud deployment templates (AWS, GCP, Azure)\n- Scaling configuration management\n- Monitoring setup automation\n\n\n### 3.2 Performance Monitoring System\nA comprehensive monitoring solution providing real-time insights into crawler operations, resource usage, and system health through both CLI and GUI interfaces.\n\nKey Features:\n- Real-time resource tracking\n- Active crawl monitoring\n- Performance statistics\n- Customizable alerting system\n\n```python\nfrom crawl4ai import AsyncWebCrawler\nfrom crawl4ai.monitor import CrawlMonitor\n\n# Initialize monitoring\nmonitor = CrawlMonitor()\n\n# Start monitoring with CLI interface\nawait monitor.start(\n    mode=\"cli\",  # or \"gui\"\n    refresh_rate=\"1s\",\n    metrics={\n        \"resources\": [\"cpu\", \"memory\", \"network\"],\n        \"crawls\": [\"active\", \"queued\", \"completed\"],\n        \"performance\": [\"success_rate\", \"response_times\"]\n    }\n)\n\n# Example CLI output:\n\"\"\"\nCrawl4AI Monitor (Live) - Press Q to exit\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nSystem Usage:\n â”œâ”€ CPU: â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘ 70%\n â””â”€ Memory: â–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘ 2.1GB/8GB\n\nActive Crawls:\nID    URL                   Status    Progress\n001   docs.example.com     ðŸŸ¢ Active   75%\n002   api.service.com      ðŸŸ¡ Queue    -\n\nMetrics (Last 5min):\n â”œâ”€ Success Rate: 98%\n â”œâ”€ Avg Response: 0.6s\n â””â”€ Pages/sec: 8.5\n\"\"\"\n```\n\n### 3.3 Cloud Integration\nStreamlined deployment tools for setting up Crawl4AI in various cloud environments, with support for scaling and monitoring.\n\nKey Features:\n- One-click deployment solutions\n- Auto-scaling configuration\n- Load balancing setup\n- Cloud-specific optimizations\n- Monitoring integration\n\n```python\nfrom crawl4ai import AsyncWebCrawler\nfrom crawl4ai.deploy import CloudDeployer\n\n# Initialize deployer\ndeployer = CloudDeployer()\n\n# Deploy crawler service\ndeployment = await deployer.deploy(\n    service_name=\"crawler-cluster\",\n    platform=\"aws\",  # or \"gcp\", \"azure\"\n    config={\n        \"instance_type\": \"compute-optimized\",\n        \"auto_scaling\": {\n            \"min_instances\": 2,\n            \"max_instances\": 10,\n            \"scale_based_on\": \"cpu_usage\"\n        },\n        \"region\": \"us-east-1\",\n        \"monitoring\": True\n    }\n)\n\n# Get deployment status and endpoints\nprint(f\"Service Status: {deployment.status}\")\nprint(f\"API Endpoint: {deployment.endpoint}\")\nprint(f\"Monitor URL: {deployment.monitor_url}\")\n```\n\nThese development tools work together to provide a comprehensive environment for developing, testing, monitoring, and deploying Crawl4AI applications. The Playground helps users experiment and generate optimal configurations, the Performance Monitor ensures smooth operation, and the Cloud Integration tools simplify deployment and scaling.\n\n# Section 4: Community & Growth ðŸŒ±\n\nThis section outlines initiatives designed to build and support the Crawl4AI community, provide educational resources, and ensure sustainable project growth.\n\n### 4.1 Sponsorship Program\nA structured program to support ongoing development and maintenance of Crawl4AI while providing valuable benefits to sponsors.\n\nKey Features:\n- Multiple sponsorship tiers\n- Sponsor recognition system\n- Priority support for sponsors\n- Early access to new features\n- Custom feature development opportunities\n\nProgram Structure (not yet finalized):\n```\nSponsorship Tiers:\n\nðŸ¥‰ Bronze Supporter\n- GitHub Sponsor badge\n- Priority issue response\n- Community Discord role\n\nðŸ¥ˆ Silver Supporter\n- All Bronze benefits\n- Technical support channel\n- Vote on roadmap priorities\n- Early access to beta features\n\nðŸ¥‡ Gold Supporter\n- All Silver benefits\n- Custom feature requests\n- Direct developer access\n- Private support sessions\n\nðŸ’Ž Diamond Partner\n- All Gold benefits\n- Custom development\n- On-demand consulting\n- Integration support\n```\n\n### 4.2 \"How to Crawl\" Video Series\nA comprehensive educational resource teaching users how to effectively use Crawl4AI for various web scraping and data extraction scenarios.\n\nKey Features:\n- Step-by-step tutorials\n- Real-world use cases\n- Best practices\n- Integration guides\n- Advanced feature deep-dives\n\nThese community initiatives are designed to:\n- Provide comprehensive learning resources\n- Foster a supportive user community\n- Ensure sustainable project development\n- Share knowledge and best practices\n- Create opportunities for collaboration\n\nThe combination of structured support through sponsorship, educational content through video series, and interactive learning through the playground creates a robust ecosystem for both new and experienced users of Crawl4AI.\n"
        },
        {
          "name": "crawl4ai",
          "type": "tree",
          "content": null
        },
        {
          "name": "docker-compose.yml",
          "type": "blob",
          "size": 1.603515625,
          "content": "services:\n  # Local build services for different platforms\n  crawl4ai-amd64:\n    build:\n      context: .\n      dockerfile: Dockerfile\n      args:\n        PYTHON_VERSION: \"3.10\"\n        INSTALL_TYPE: ${INSTALL_TYPE:-basic}\n        ENABLE_GPU: false\n      platforms:\n        - linux/amd64\n    profiles: [\"local-amd64\"]\n    extends: &base-config\n      file: docker-compose.yml\n      service: base-config\n\n  crawl4ai-arm64:\n    build:\n      context: .\n      dockerfile: Dockerfile\n      args:\n        PYTHON_VERSION: \"3.10\"\n        INSTALL_TYPE: ${INSTALL_TYPE:-basic}\n        ENABLE_GPU: false\n      platforms:\n        - linux/arm64\n    profiles: [\"local-arm64\"]\n    extends: *base-config\n\n  # Hub services for different platforms and versions\n  crawl4ai-hub-amd64:\n    image: unclecode/crawl4ai:${VERSION:-basic}-amd64\n    profiles: [\"hub-amd64\"]\n    extends: *base-config\n\n  crawl4ai-hub-arm64:\n    image: unclecode/crawl4ai:${VERSION:-basic}-arm64\n    profiles: [\"hub-arm64\"]\n    extends: *base-config\n\n  # Base configuration to be extended\n  base-config:\n    ports:\n      - \"11235:11235\"\n      - \"8000:8000\"\n      - \"9222:9222\"\n      - \"8080:8080\"\n    environment:\n      - CRAWL4AI_API_TOKEN=${CRAWL4AI_API_TOKEN:-}\n      - OPENAI_API_KEY=${OPENAI_API_KEY:-}\n      - CLAUDE_API_KEY=${CLAUDE_API_KEY:-}\n    volumes:\n      - /dev/shm:/dev/shm\n    deploy:\n      resources:\n        limits:\n          memory: 4G\n        reservations:\n          memory: 1G\n    restart: unless-stopped\n    healthcheck:\n      test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:11235/health\"]\n      interval: 30s\n      timeout: 10s\n      retries: 3\n      start_period: 40s"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "main.py",
          "type": "blob",
          "size": 18.19921875,
          "content": "import asyncio, os\nfrom fastapi import FastAPI, HTTPException, BackgroundTasks, Request\nfrom fastapi.responses import JSONResponse\nfrom fastapi import FastAPI, HTTPException, Request\nfrom fastapi.responses import HTMLResponse, JSONResponse\nfrom fastapi.staticfiles import StaticFiles\nfrom fastapi.middleware.cors import CORSMiddleware  \nfrom fastapi.templating import Jinja2Templates\nfrom fastapi.exceptions import RequestValidationError\nfrom starlette.middleware.base import BaseHTTPMiddleware\nfrom starlette.responses import FileResponse\nfrom fastapi.responses import RedirectResponse\nfrom fastapi.security import HTTPBearer, HTTPAuthorizationCredentials\nfrom fastapi import Depends, Security\n\nfrom pydantic import BaseModel, HttpUrl, Field\nfrom typing import Optional, List, Dict, Any, Union\nimport psutil\nimport time\nimport uuid\nfrom collections import defaultdict\nfrom urllib.parse import urlparse\nimport math\nimport logging\nfrom enum import Enum\nfrom dataclasses import dataclass\nimport json\nfrom crawl4ai import AsyncWebCrawler, CrawlResult, CacheMode\nfrom crawl4ai.config import MIN_WORD_THRESHOLD\nfrom crawl4ai.extraction_strategy import (\n    LLMExtractionStrategy,\n    CosineStrategy,\n    JsonCssExtractionStrategy,\n)\n\n__location__ = os.path.realpath(os.path.join(os.getcwd(), os.path.dirname(__file__)))\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\nclass TaskStatus(str, Enum):\n    PENDING = \"pending\"\n    PROCESSING = \"processing\"\n    COMPLETED = \"completed\"\n    FAILED = \"failed\"\n\nclass CrawlerType(str, Enum):\n    BASIC = \"basic\"\n    LLM = \"llm\"\n    COSINE = \"cosine\"\n    JSON_CSS = \"json_css\"\n\nclass ExtractionConfig(BaseModel):\n    type: CrawlerType\n    params: Dict[str, Any] = {}\n\nclass ChunkingStrategy(BaseModel):\n    type: str\n    params: Dict[str, Any] = {}\n\nclass ContentFilter(BaseModel):\n    type: str = \"bm25\"\n    params: Dict[str, Any] = {}\n\nclass CrawlRequest(BaseModel):\n    urls: Union[HttpUrl, List[HttpUrl]]\n    word_count_threshold: int = MIN_WORD_THRESHOLD\n    extraction_config: Optional[ExtractionConfig] = None\n    chunking_strategy: Optional[ChunkingStrategy] = None\n    content_filter: Optional[ContentFilter] = None\n    js_code: Optional[List[str]] = None\n    wait_for: Optional[str] = None\n    css_selector: Optional[str] = None\n    screenshot: bool = False\n    magic: bool = False\n    extra: Optional[Dict[str, Any]] = {}\n    session_id: Optional[str] = None\n    cache_mode: Optional[CacheMode] = CacheMode.ENABLED\n    priority: int = Field(default=5, ge=1, le=10)\n    ttl: Optional[int] = 3600    \n    crawler_params: Dict[str, Any] = {}\n\n@dataclass\nclass TaskInfo:\n    id: str\n    status: TaskStatus\n    result: Optional[Union[CrawlResult, List[CrawlResult]]] = None\n    error: Optional[str] = None\n    created_at: float = time.time()\n    ttl: int = 3600\n\nclass ResourceMonitor:\n    def __init__(self, max_concurrent_tasks: int = 10):\n        self.max_concurrent_tasks = max_concurrent_tasks\n        self.memory_threshold = 0.85\n        self.cpu_threshold = 0.90\n        self._last_check = 0\n        self._check_interval = 1  # seconds\n        self._last_available_slots = max_concurrent_tasks\n\n    async def get_available_slots(self) -> int:\n        current_time = time.time()\n        if current_time - self._last_check < self._check_interval:\n            return self._last_available_slots\n\n        mem_usage = psutil.virtual_memory().percent / 100\n        cpu_usage = psutil.cpu_percent() / 100\n\n        memory_factor = max(0, (self.memory_threshold - mem_usage) / self.memory_threshold)\n        cpu_factor = max(0, (self.cpu_threshold - cpu_usage) / self.cpu_threshold)\n\n        self._last_available_slots = math.floor(\n            self.max_concurrent_tasks * min(memory_factor, cpu_factor)\n        )\n        self._last_check = current_time\n\n        return self._last_available_slots\n\nclass TaskManager:\n    def __init__(self, cleanup_interval: int = 300):\n        self.tasks: Dict[str, TaskInfo] = {}\n        self.high_priority = asyncio.PriorityQueue()\n        self.low_priority = asyncio.PriorityQueue()\n        self.cleanup_interval = cleanup_interval\n        self.cleanup_task = None\n\n    async def start(self):\n        self.cleanup_task = asyncio.create_task(self._cleanup_loop())\n\n    async def stop(self):\n        if self.cleanup_task:\n            self.cleanup_task.cancel()\n            try:\n                await self.cleanup_task\n            except asyncio.CancelledError:\n                pass\n\n    async def add_task(self, task_id: str, priority: int, ttl: int) -> None:\n        task_info = TaskInfo(id=task_id, status=TaskStatus.PENDING, ttl=ttl)\n        self.tasks[task_id] = task_info\n        queue = self.high_priority if priority > 5 else self.low_priority\n        await queue.put((-priority, task_id))  # Negative for proper priority ordering\n\n    async def get_next_task(self) -> Optional[str]:\n        try:\n            # Try high priority first\n            _, task_id = await asyncio.wait_for(self.high_priority.get(), timeout=0.1)\n            return task_id\n        except asyncio.TimeoutError:\n            try:\n                # Then try low priority\n                _, task_id = await asyncio.wait_for(self.low_priority.get(), timeout=0.1)\n                return task_id\n            except asyncio.TimeoutError:\n                return None\n\n    def update_task(self, task_id: str, status: TaskStatus, result: Any = None, error: str = None):\n        if task_id in self.tasks:\n            task_info = self.tasks[task_id]\n            task_info.status = status\n            task_info.result = result\n            task_info.error = error\n\n    def get_task(self, task_id: str) -> Optional[TaskInfo]:\n        return self.tasks.get(task_id)\n\n    async def _cleanup_loop(self):\n        while True:\n            try:\n                await asyncio.sleep(self.cleanup_interval)\n                current_time = time.time()\n                expired_tasks = [\n                    task_id\n                    for task_id, task in self.tasks.items()\n                    if current_time - task.created_at > task.ttl\n                    and task.status in [TaskStatus.COMPLETED, TaskStatus.FAILED]\n                ]\n                for task_id in expired_tasks:\n                    del self.tasks[task_id]\n            except Exception as e:\n                logger.error(f\"Error in cleanup loop: {e}\")\n\nclass CrawlerPool:\n    def __init__(self, max_size: int = 10):\n        self.max_size = max_size\n        self.active_crawlers: Dict[AsyncWebCrawler, float] = {}\n        self._lock = asyncio.Lock()\n\n    async def acquire(self, **kwargs) -> AsyncWebCrawler:\n        async with self._lock:\n            # Clean up inactive crawlers\n            current_time = time.time()\n            inactive = [\n                crawler\n                for crawler, last_used in self.active_crawlers.items()\n                if current_time - last_used > 600  # 10 minutes timeout\n            ]\n            for crawler in inactive:\n                await crawler.__aexit__(None, None, None)\n                del self.active_crawlers[crawler]\n\n            # Create new crawler if needed\n            if len(self.active_crawlers) < self.max_size:\n                crawler = AsyncWebCrawler(**kwargs)\n                await crawler.__aenter__()\n                self.active_crawlers[crawler] = current_time\n                return crawler\n\n            # Reuse least recently used crawler\n            crawler = min(self.active_crawlers.items(), key=lambda x: x[1])[0]\n            self.active_crawlers[crawler] = current_time\n            return crawler\n\n    async def release(self, crawler: AsyncWebCrawler):\n        async with self._lock:\n            if crawler in self.active_crawlers:\n                self.active_crawlers[crawler] = time.time()\n\n    async def cleanup(self):\n        async with self._lock:\n            for crawler in list(self.active_crawlers.keys()):\n                await crawler.__aexit__(None, None, None)\n            self.active_crawlers.clear()\n\nclass CrawlerService:\n    def __init__(self, max_concurrent_tasks: int = 10):\n        self.resource_monitor = ResourceMonitor(max_concurrent_tasks)\n        self.task_manager = TaskManager()\n        self.crawler_pool = CrawlerPool(max_concurrent_tasks)\n        self._processing_task = None\n\n    async def start(self):\n        await self.task_manager.start()\n        self._processing_task = asyncio.create_task(self._process_queue())\n\n    async def stop(self):\n        if self._processing_task:\n            self._processing_task.cancel()\n            try:\n                await self._processing_task\n            except asyncio.CancelledError:\n                pass\n        await self.task_manager.stop()\n        await self.crawler_pool.cleanup()\n\n    def _create_extraction_strategy(self, config: ExtractionConfig):\n        if not config:\n            return None\n\n        if config.type == CrawlerType.LLM:\n            return LLMExtractionStrategy(**config.params)\n        elif config.type == CrawlerType.COSINE:\n            return CosineStrategy(**config.params)\n        elif config.type == CrawlerType.JSON_CSS:\n            return JsonCssExtractionStrategy(**config.params)\n        return None\n\n    async def submit_task(self, request: CrawlRequest) -> str:\n        task_id = str(uuid.uuid4())\n        await self.task_manager.add_task(task_id, request.priority, request.ttl or 3600)\n        \n        # Store request data with task\n        self.task_manager.tasks[task_id].request = request\n        \n        return task_id\n\n    async def _process_queue(self):\n        while True:\n            try:\n                available_slots = await self.resource_monitor.get_available_slots()\n                if False and available_slots <= 0:\n                    await asyncio.sleep(1)\n                    continue\n\n                task_id = await self.task_manager.get_next_task()\n                if not task_id:\n                    await asyncio.sleep(1)\n                    continue\n\n                task_info = self.task_manager.get_task(task_id)\n                if not task_info:\n                    continue\n\n                request = task_info.request\n                self.task_manager.update_task(task_id, TaskStatus.PROCESSING)\n\n                try:\n                    crawler = await self.crawler_pool.acquire(**request.crawler_params)\n                    \n                    extraction_strategy = self._create_extraction_strategy(request.extraction_config)\n                    \n                    if isinstance(request.urls, list):\n                        results = await crawler.arun_many(\n                            urls=[str(url) for url in request.urls],\n                            word_count_threshold=MIN_WORD_THRESHOLD,\n                            extraction_strategy=extraction_strategy,\n                            js_code=request.js_code,\n                            wait_for=request.wait_for,\n                            css_selector=request.css_selector,\n                            screenshot=request.screenshot,\n                            magic=request.magic,\n                            session_id=request.session_id,\n                            cache_mode=request.cache_mode,\n                            **request.extra,\n                        )\n                    else:\n                        results = await crawler.arun(\n                            url=str(request.urls),\n                            extraction_strategy=extraction_strategy,\n                            js_code=request.js_code,\n                            wait_for=request.wait_for,\n                            css_selector=request.css_selector,\n                            screenshot=request.screenshot,\n                            magic=request.magic,\n                            session_id=request.session_id,\n                            cache_mode=request.cache_mode,\n                            **request.extra,\n                        )\n\n                    await self.crawler_pool.release(crawler)\n                    self.task_manager.update_task(task_id, TaskStatus.COMPLETED, results)\n\n                except Exception as e:\n                    logger.error(f\"Error processing task {task_id}: {str(e)}\")\n                    self.task_manager.update_task(task_id, TaskStatus.FAILED, error=str(e))\n\n            except Exception as e:\n                logger.error(f\"Error in queue processing: {str(e)}\")\n                await asyncio.sleep(1)\n\napp = FastAPI(title=\"Crawl4AI API\")\n\n# CORS configuration\norigins = [\"*\"]  # Allow all origins\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=origins,  # List of origins that are allowed to make requests\n    allow_credentials=True,\n    allow_methods=[\"*\"],  # Allows all methods\n    allow_headers=[\"*\"],  # Allows all headers\n)\n\n# API token security\nsecurity = HTTPBearer()\nCRAWL4AI_API_TOKEN = os.getenv(\"CRAWL4AI_API_TOKEN\")\n\nasync def verify_token(credentials: HTTPAuthorizationCredentials = Security(security)):\n    if not CRAWL4AI_API_TOKEN:\n        return credentials  # No token verification if CRAWL4AI_API_TOKEN is not set\n    if credentials.credentials != CRAWL4AI_API_TOKEN:\n        raise HTTPException(status_code=401, detail=\"Invalid token\")\n    return credentials\n\ndef secure_endpoint():\n    \"\"\"Returns security dependency only if CRAWL4AI_API_TOKEN is set\"\"\"\n    return Depends(verify_token) if CRAWL4AI_API_TOKEN else None\n\n# Check if site directory exists\nif os.path.exists(__location__ + \"/site\"):\n    # Mount the site directory as a static directory\n    app.mount(\"/mkdocs\", StaticFiles(directory=\"site\", html=True), name=\"mkdocs\")\n\nsite_templates = Jinja2Templates(directory=__location__ + \"/site\")\n\ncrawler_service = CrawlerService()\n\n@app.on_event(\"startup\")\nasync def startup_event():\n    await crawler_service.start()\n\n@app.on_event(\"shutdown\")\nasync def shutdown_event():\n    await crawler_service.stop()\n\n@app.get(\"/\")\ndef read_root():\n    if os.path.exists(__location__ + \"/site\"):\n        return RedirectResponse(url=\"/mkdocs\")\n    # Return a json response\n    return {\"message\": \"Crawl4AI API service is running\"}\n\n@app.post(\"/crawl\", dependencies=[secure_endpoint()] if CRAWL4AI_API_TOKEN else [])\nasync def crawl(request: CrawlRequest) -> Dict[str, str]:\n    task_id = await crawler_service.submit_task(request)\n    return {\"task_id\": task_id}\n\n@app.get(\"/task/{task_id}\", dependencies=[secure_endpoint()] if CRAWL4AI_API_TOKEN else [])\nasync def get_task_status(task_id: str):\n    task_info = crawler_service.task_manager.get_task(task_id)\n    if not task_info:\n        raise HTTPException(status_code=404, detail=\"Task not found\")\n\n    response = {\n        \"status\": task_info.status,\n        \"created_at\": task_info.created_at,\n    }\n\n    if task_info.status == TaskStatus.COMPLETED:\n        # Convert CrawlResult to dict for JSON response\n        if isinstance(task_info.result, list):\n            response[\"results\"] = [result.dict() for result in task_info.result]\n        else:\n            response[\"result\"] = task_info.result.dict()\n    elif task_info.status == TaskStatus.FAILED:\n        response[\"error\"] = task_info.error\n\n    return response\n\n@app.post(\"/crawl_sync\", dependencies=[secure_endpoint()] if CRAWL4AI_API_TOKEN else [])\nasync def crawl_sync(request: CrawlRequest) -> Dict[str, Any]:\n    task_id = await crawler_service.submit_task(request)\n    \n    # Wait up to 60 seconds for task completion\n    for _ in range(60):\n        task_info = crawler_service.task_manager.get_task(task_id)\n        if not task_info:\n            raise HTTPException(status_code=404, detail=\"Task not found\")\n            \n        if task_info.status == TaskStatus.COMPLETED:\n            # Return same format as /task/{task_id} endpoint\n            if isinstance(task_info.result, list):\n                return {\"status\": task_info.status, \"results\": [result.dict() for result in task_info.result]}\n            return {\"status\": task_info.status, \"result\": task_info.result.dict()}\n            \n        if task_info.status == TaskStatus.FAILED:\n            raise HTTPException(status_code=500, detail=task_info.error)\n            \n        await asyncio.sleep(1)\n    \n    # If we get here, task didn't complete within timeout\n    raise HTTPException(status_code=408, detail=\"Task timed out\")\n\n@app.post(\"/crawl_direct\", dependencies=[secure_endpoint()] if CRAWL4AI_API_TOKEN else [])\nasync def crawl_direct(request: CrawlRequest) -> Dict[str, Any]:\n    try:\n        crawler = await crawler_service.crawler_pool.acquire(**request.crawler_params)\n        extraction_strategy = crawler_service._create_extraction_strategy(request.extraction_config)\n        \n        try:\n            if isinstance(request.urls, list):\n                results = await crawler.arun_many(\n                    urls=[str(url) for url in request.urls],\n                    extraction_strategy=extraction_strategy,\n                    js_code=request.js_code,\n                    wait_for=request.wait_for,\n                    css_selector=request.css_selector,\n                    screenshot=request.screenshot,\n                    magic=request.magic,\n                    cache_mode=request.cache_mode,\n                    session_id=request.session_id,\n                    **request.extra,\n                )\n                return {\"results\": [result.dict() for result in results]}\n            else:\n                result = await crawler.arun(\n                    url=str(request.urls),\n                    extraction_strategy=extraction_strategy,\n                    js_code=request.js_code,\n                    wait_for=request.wait_for,\n                    css_selector=request.css_selector,\n                    screenshot=request.screenshot,\n                    magic=request.magic,\n                    cache_mode=request.cache_mode,\n                    session_id=request.session_id,\n                    **request.extra,\n                )\n                return {\"result\": result.dict()}\n        finally:\n            await crawler_service.crawler_pool.release(crawler)\n    except Exception as e:\n        logger.error(f\"Error in direct crawl: {str(e)}\")\n        raise HTTPException(status_code=500, detail=str(e))\n    \n@app.get(\"/health\")\nasync def health_check():\n    available_slots = await crawler_service.resource_monitor.get_available_slots()\n    memory = psutil.virtual_memory()\n    return {\n        \"status\": \"healthy\",\n        \"available_slots\": available_slots,\n        \"memory_usage\": memory.percent,\n        \"cpu_usage\": psutil.cpu_percent(),\n    }\n\nif __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(app, host=\"0.0.0.0\", port=11235)"
        },
        {
          "name": "mkdocs.yml",
          "type": "blob",
          "size": 3.6689453125,
          "content": "site_name: Crawl4AI Documentation\nsite_description: ðŸ”¥ðŸ•·ï¸ Crawl4AI, Open-source LLM Friendly Web Crawler & Scrapper\nsite_url: https://docs.crawl4ai.com\nrepo_url: https://github.com/unclecode/crawl4ai\nrepo_name: unclecode/crawl4ai\ndocs_dir: docs/md_v2\n\nnav:\n  - Home: 'index.md'\n  - 'Installation': 'basic/installation.md'\n  - 'Docker Deplotment': 'basic/docker-deploymeny.md'\n  - 'Quick Start': 'basic/quickstart.md'\n  - Changelog & Blog:\n    - 'Blog Home': 'blog/index.md'\n    - 'Latest (0.4.1)': 'blog/releases/0.4.1.md'\n    - 'Changelog': 'https://github.com/unclecode/crawl4ai/blob/main/CHANGELOG.md'\n\n  - Basic:\n    - 'Simple Crawling': 'basic/simple-crawling.md'\n    - 'Output Formats': 'basic/output-formats.md'\n    - 'Browser Configuration': 'basic/browser-config.md'\n    - 'Page Interaction': 'basic/page-interaction.md'\n    - 'Content Selection': 'basic/content-selection.md'\n    - 'Cache Modes': 'basic/cache-modes.md'\n\n  - Advanced:\n    - 'Content Processing': 'advanced/content-processing.md'\n    - 'Magic Mode': 'advanced/magic-mode.md'\n    - 'Hooks & Auth': 'advanced/hooks-auth.md'\n    - 'Proxy & Security': 'advanced/proxy-security.md'\n    - 'Session Management': 'advanced/session-management.md'\n    - 'Session Management (Advanced)': 'advanced/session-management-advanced.md'\n  \n  - Extraction:\n    - 'Overview': 'extraction/overview.md'\n    - 'LLM Strategy': 'extraction/llm.md'\n    - 'Json-CSS Extractor Basic': 'extraction/css.md'\n    - 'Json-CSS Extractor Advanced': 'extraction/css-advanced.md'\n    - 'Cosine Strategy': 'extraction/cosine.md'\n    - 'Chunking': 'extraction/chunking.md'\n\n  - API Reference:\n    - 'Parameters Table': 'api/parameters.md'\n    - 'AsyncWebCrawler': 'api/async-webcrawler.md'\n    - 'AsyncWebCrawler.arun()': 'api/arun.md'\n    - 'CrawlResult': 'api/crawl-result.md'\n    - 'Strategies': 'api/strategies.md'\n    \n  - Tutorial:\n    - '1. Getting Started': 'tutorial/episode_01_Introduction_to_Crawl4AI_and_Basic_Installation.md'\n    - '2. Advanced Features': 'tutorial/episode_02_Overview_of_Advanced_Features.md'\n    - '3. Browser Setup': 'tutorial/episode_03_Browser_Configurations_&_Headless_Crawling.md'\n    - '4. Proxy Settings': 'tutorial/episode_04_Advanced_Proxy_and_Security_Settings.md'\n    - '5. Dynamic Content': 'tutorial/episode_05_JavaScript_Execution_and_Dynamic_Content_Handling.md'\n    - '6. Magic Mode': 'tutorial/episode_06_Magic_Mode_and_Anti-Bot_Protection.md'\n    - '7. Content Cleaning': 'tutorial/episode_07_Content_Cleaning_and_Fit_Markdown.md'\n    - '8. Media Handling': 'tutorial/episode_08_Media_Handling_Images_Videos_and_Audio.md'\n    - '9. Link Analysis': 'tutorial/episode_09_Link_Analysis_and_Smart_Filtering.md'\n    - '10. User Simulation': 'tutorial/episode_10_Custom_Headers,_Identity,_and_User_Simulation.md'\n    - '11.1. JSON CSS': 'tutorial/episode_11_1_Extraction_Strategies_JSON_CSS.md'\n    - '11.2. LLM Strategy': 'tutorial/episode_11_2_Extraction_Strategies_LLM.md'\n    - '11.3. Cosine Strategy': 'tutorial/episode_11_3_Extraction_Strategies_Cosine.md'\n    - '12. Session Crawling': 'tutorial/episode_12_Session-Based_Crawling_for_Dynamic_Websites.md'\n    - '13. Text Chunking': 'tutorial/episode_13_Chunking_Strategies_for_Large_Text_Processing.md'\n    - '14. Custom Workflows': 'tutorial/episode_14_Hooks_and_Custom_Workflow_with_AsyncWebCrawler.md'\n\n\ntheme:\n  name: terminal\n  palette: dark\n\nmarkdown_extensions:\n  - pymdownx.highlight:\n      anchor_linenums: true\n  - pymdownx.inlinehilite\n  - pymdownx.snippets\n  - pymdownx.superfences\n  - admonition\n  - pymdownx.details\n  - attr_list\n  - tables\n\nextra_css:\n  - assets/styles.css\n  - assets/highlight.css\n  - assets/dmvendor.css\n\nextra_javascript:\n  - assets/highlight.min.js\n  - assets/highlight_init.js"
        },
        {
          "name": "mkdocs_v2.yml",
          "type": "blob",
          "size": 3.451171875,
          "content": "site_name: Crawl4AI Documentation\nsite_description: ðŸ”¥ðŸ•·ï¸ Crawl4AI, Open-source LLM Friendly Web Crawler & Scrapper\nsite_url: https://docs.crawl4ai.com\nrepo_url: https://github.com/unclecode/crawl4ai\nrepo_name: unclecode/crawl4ai\ndocs_dir: docs/md_v3\n\n\nnav:\n  - Home: index.md\n\n  - Tutorials:\n    - \"Getting Started\": tutorials/getting-started.md\n    - \"AsyncWebCrawler Basics\": tutorials/async-webcrawler-basics.md\n    - \"Targeted Crawling Techniques\": tutorials/targeted-crawling.md\n    - \"Link & Media Analysis\": tutorials/link-media-analysis.md\n    - \"Advanced Features (Proxy, PDF, Screenshots)\": tutorials/advanced-features.md\n    - \"Hooks & Custom Code\": tutorials/hooks-custom.md\n    - \"Markdown Generation Basics\": tutorials/markdown-basics.md\n    - \"Extracting JSON (No LLM)\": tutorials/json-extraction-basic.md\n    - \"Extracting JSON (LLM)\": tutorials/json-extraction-llm.md\n    - \"Deploying with Docker (Quickstart)\": tutorials/docker-quickstart.md\n\n  - How-To Guides:\n    - \"Advanced Browser Configuration\": how-to/advanced-browser-config.md\n    - \"Managing Browser Contexts & Remote Browsers\": how-to/browser-contexts-remote.md\n    - \"Identity-Based Crawling (Anti-Bot)\": how-to/identity-anti-bot.md\n    - \"Link & Media Analysis\": how-to/link-media-analysis.md\n    - \"Markdown Generation Customization\": how-to/markdown-custom.md\n    - \"Structured Data Extraction (Advanced)\": how-to/structured-data-advanced.md\n    - \"Deployment Options\": how-to/deployment-options.md\n    - \"Performance & Caching\": how-to/performance-caching.md\n\n  - Explanations:\n    - \"AsyncWebCrawler & Internal Flow\": explanations/async-webcrawler-flow.md\n    - \"Configuration Objects Explained\": explanations/configuration-objects.md\n    - \"Browser Context & Managed Browser\": explanations/browser-management.md\n    - \"Markdown Generation Architecture\": explanations/markdown-architecture.md\n    - \"Extraction & Chunking Strategies\": explanations/extraction-chunking.md\n    - \"Identity-Based Crawling & Anti-Bot\": explanations/identity-anti-bot.md\n    - \"Deployment Architectures\": explanations/deployment-architectures.md\n\n  - Reference:\n    - \"Configuration\": reference/configuration.md\n    - \"Core Crawler\": reference/core-crawler.md\n    - \"Browser Strategies\": reference/browser-strategies.md\n    - \"Markdown Generation\": reference/markdown-generation.md\n    - \"Content Filters\": reference/content-filters.md\n    - \"Extraction Strategies\": reference/extraction-strategies.md\n    - \"Chunking Strategies\": reference/chunking-strategies.md\n    - \"Identity & Utility\": reference/identity-utilities.md\n    - \"Models\": reference/models.md\n\n  - Blog: \n    - \"Blog Overview\": blog/index.md\n    #  You can add real-life application posts here in the future\n    #  - \"Cool Real-World E-Commerce Scraping\": blog/ecommerce-case-study.md\n    #  - \"Dealing with Complex Anti-Bot Systems\": blog/anti-bot-tricks.md\n\n\ntheme:\n  name: terminal\n  palette: dark\n\nplugins:\n  - search\n  - mkdocstrings:\n      handlers:\n        python:\n          analysis:\n            follow_imports: true\n          rendering:\n            show_root_full_path: false\n\nmarkdown_extensions:\n  - codehilite\n  - toc:\n      permalink: true\n  - pymdownx.highlight:\n      anchor_linenums: true\n  - pymdownx.inlinehilite\n  - pymdownx.snippets\n  - pymdownx.superfences\n  - admonition\n  - pymdownx.details\n  - attr_list\n  - tables\n\nextra_css:\n  - assets/styles.css\n  - assets/highlight.css\n  - assets/dmvendor.css\n\nextra_javascript:\n  - assets/highlight.min.js\n  - assets/highlight_init.js"
        },
        {
          "name": "pyproject.toml",
          "type": "blob",
          "size": 2.0068359375,
          "content": "[build-system]\nrequires = [\"setuptools>=64.0.0\", \"wheel\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[project]\nname = \"Crawl4AI\"\ndynamic = [\"version\"]\ndescription = \"ðŸš€ðŸ¤– Crawl4AI: Open-source LLM Friendly Web Crawler & scraper\"\nreadme = \"README.md\"\nrequires-python = \">=3.9\"\nlicense = {text = \"MIT\"}\nauthors = [\n    {name = \"Unclecode\", email = \"unclecode@kidocode.com\"}\n]\ndependencies = [\n    \"aiosqlite~=0.20\",\n    \"lxml~=5.3\",\n    \"litellm>=1.53.1\",\n    \"numpy>=1.26.0,<3\",\n    \"pillow~=10.4\",\n    \"playwright>=1.49.0\",\n    \"python-dotenv~=1.0\",\n    \"requests~=2.26\",\n    \"beautifulsoup4~=4.12\",\n    \"tf-playwright-stealth>=1.1.0\",\n    \"xxhash~=3.4\",\n    \"rank-bm25~=0.2\",\n    \"aiofiles>=24.1.0\",\n    \"colorama~=0.4\",\n    \"snowballstemmer~=2.2\",\n    \"pydantic>=2.10\",\n    \"pyOpenSSL>=24.3.0\",\n    \"psutil>=6.1.1\",\n    \"nltk>=3.9.1\",\n    \"playwright\",\n    \"aiofiles\"\n]\nclassifiers = [\n    \"Development Status :: 3 - Alpha\",\n    \"Intended Audience :: Developers\",\n    \"License :: OSI Approved :: Apache Software License\",\n    \"Programming Language :: Python :: 3\",\n    \"Programming Language :: Python :: 3.9\",\n    \"Programming Language :: Python :: 3.10\",\n    \"Programming Language :: Python :: 3.11\",\n    \"Programming Language :: Python :: 3.12\",\n    \"Programming Language :: Python :: 3.13\",\n]\n\n[project.optional-dependencies]\ntorch = [\"torch\", \"nltk\", \"scikit-learn\"]\ntransformer = [\"transformers\", \"tokenizers\"]\ncosine = [\"torch\", \"transformers\", \"nltk\"]\nsync = [\"selenium\"]\nall = [\n    \"torch\",\n    \"nltk\",\n    \"scikit-learn\",\n    \"transformers\",\n    \"tokenizers\",\n    \"selenium\"\n]\n\n[project.scripts]\ncrawl4ai-download-models = \"crawl4ai.model_loader:main\"\ncrawl4ai-migrate = \"crawl4ai.migrations:main\"\ncrawl4ai-setup = \"crawl4ai.install:post_install\"\ncrawl4ai-doctor = \"crawl4ai.install:doctor\"\ncrawl = \"crawl4ai.cli:cli\"\n\n[tool.setuptools]\npackages = {find = {where = [\".\"], include = [\"crawl4ai*\"]}}\n\n[tool.setuptools.package-data]\ncrawl4ai = [\"js_snippet/*.js\"]\n\n[tool.setuptools.dynamic]\nversion = {attr = \"crawl4ai.__version__.__version__\"}"
        },
        {
          "name": "requirements.txt",
          "type": "blob",
          "size": 0.4375,
          "content": "# Note: These requirements are also specified in pyproject.toml\n# This file is kept for development environment setup and compatibility\naiosqlite~=0.20\nlxml~=5.3\nlitellm>=1.53.1\nnumpy>=1.26.0,<3\npillow~=10.4\nplaywright>=1.49.0\npython-dotenv~=1.0\nrequests~=2.26\nbeautifulsoup4~=4.12\ntf-playwright-stealth>=1.1.0\nxxhash~=3.4\nrank-bm25~=0.2\naiofiles>=24.1.0\ncolorama~=0.4\nsnowballstemmer~=2.2\npydantic>=2.10\npyOpenSSL>=24.3.0\npsutil>=6.1.1\nnltk>=3.9.1"
        },
        {
          "name": "setup.cfg",
          "type": "blob",
          "size": 0.0361328125,
          "content": "[options]\ninclude_package_data = True"
        },
        {
          "name": "setup.py",
          "type": "blob",
          "size": 2.2216796875,
          "content": "from setuptools import setup, find_packages\nimport os\nfrom pathlib import Path\nimport shutil\n\n# Note: Most configuration is now in pyproject.toml\n# This setup.py is kept for backwards compatibility\n\n# Create the .crawl4ai folder in the user's home directory if it doesn't exist\n# If the folder already exists, remove the cache folder\nbase_dir = os.getenv(\"CRAWL4_AI_BASE_DIRECTORY\")\ncrawl4ai_folder = Path(base_dir) if base_dir else Path.home()\ncrawl4ai_folder = crawl4ai_folder / \".crawl4ai\"\ncache_folder = crawl4ai_folder / \"cache\"\ncontent_folders = [\n    \"html_content\",\n    \"cleaned_html\",\n    \"markdown_content\",\n    \"extracted_content\",\n    \"screenshots\",\n]\n\n# Clean up old cache if exists\nif cache_folder.exists():\n    shutil.rmtree(cache_folder)\n\n# Create new folder structure\ncrawl4ai_folder.mkdir(exist_ok=True)\ncache_folder.mkdir(exist_ok=True)\nfor folder in content_folders:\n    (crawl4ai_folder / folder).mkdir(exist_ok=True)\n\nversion = \"0.0.0\"  # This will be overridden by pyproject.toml's dynamic version\ntry:\n    with open(\"crawl4ai/__version__.py\") as f:\n        for line in f:\n            if line.startswith(\"__version__\"):\n                version = line.split(\"=\")[1].strip().strip('\"')\n                break\nexcept Exception:\n    pass  # Let pyproject.toml handle version\n\nsetup(\n    name=\"Crawl4AI\",\n    version=version,\n    description=\"ðŸš€ðŸ¤– Crawl4AI: Open-source LLM Friendly Web Crawler & scraper\",\n    long_description=open(\"README.md\", encoding=\"utf-8\").read(),\n    long_description_content_type=\"text/markdown\",\n    url=\"https://github.com/unclecode/crawl4ai\",\n    author=\"Unclecode\",\n    author_email=\"unclecode@kidocode.com\",\n    license=\"MIT\",\n    packages=find_packages(),\n    package_data={\n        'crawl4ai': ['js_snippet/*.js']\n    },\n    classifiers=[\n        \"Development Status :: 3 - Alpha\",\n        \"Intended Audience :: Developers\",\n        \"License :: OSI Approved :: Apache Software License\",\n        \"Programming Language :: Python :: 3\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n        \"Programming Language :: Python :: 3.11\",\n        \"Programming Language :: Python :: 3.12\",\n        \"Programming Language :: Python :: 3.13\",\n    ],\n    python_requires=\">=3.9\",\n)\n"
        },
        {
          "name": "ssl_certificate.json",
          "type": "blob",
          "size": 6.2900390625,
          "content": "{\n  \"subject\": {\n    \"C\": \"US\",\n    \"ST\": \"California\",\n    \"L\": \"Los Angeles\",\n    \"O\": \"InternetÂ CorporationÂ forÂ AssignedÂ NamesÂ andÂ Numbers\",\n    \"CN\": \"www.example.org\"\n  },\n  \"issuer\": {\n    \"C\": \"US\",\n    \"O\": \"DigiCert Inc\",\n    \"CN\": \"DigiCert Global G2 TLS RSA SHA256 2020 CA1\"\n  },\n  \"version\": 2,\n  \"serial_number\": \"0x75bcef30689c8addf13e51af4afe187\",\n  \"not_before\": \"20240130000000Z\",\n  \"not_after\": \"20250301235959Z\",\n  \"fingerprint\": \"45463a42413a32363a44383a43313a43453a33373a37393a41433a37373a36333a30413a39303a46383a32313a36333a41333a44363a38393a32453a44363a41463a45453a34303a38363a37323a43463a31393a45423a41373a41333a3632\",\n  \"signature_algorithm\": \"sha256WithRSAEncryption\",\n  \"raw_cert\": \"MIIHbjCCBlagAwIBAgIQB1vO8waJyK3fE+Ua9K/hhzANBgkqhkiG9w0BAQsFADBZMQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMTMwMQYDVQQDEypEaWdpQ2VydCBHbG9iYWwgRzIgVExTIFJTQSBTSEEyNTYgMjAyMCBDQTEwHhcNMjQwMTMwMDAwMDAwWhcNMjUwMzAxMjM1OTU5WjCBljELMAkGA1UEBhMCVVMxEzARBgNVBAgTCkNhbGlmb3JuaWExFDASBgNVBAcTC0xvcyBBbmdlbGVzMUIwQAYDVQQKDDlJbnRlcm5ldMKgQ29ycG9yYXRpb27CoGZvcsKgQXNzaWduZWTCoE5hbWVzwqBhbmTCoE51bWJlcnMxGDAWBgNVBAMTD3d3dy5leGFtcGxlLm9yZzCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAIaFD7sO+cpf2fXgCjIsM9mqDgcpqC8IrXi9wga/9y0rpqcnPVOmTMNLsid3INbBVEm4CNr5cKlh9rJJnWlX2vttJDRyLkfwBD+dsVvivGYxWTLmqX6/1LDUZPVrynv/cltemtg/1Aay88jcj2ZaRoRmqBgVeacIzgU8+zmJ7236TnFSe7fkoKSclsBhPaQKcE3Djs1uszJs8sdECQTdoFX9I6UgeLKFXtg7rRf/hcW5dI0zubhXbrW8aWXbCzySVZn0c7RkJMpnTCiZzNxnPXnHFpwr5quqqjVyN/aBKkjoP04Zmr+eRqoyk/+lslq0sS8eaYSSHbC5ja/yMWyVhvMCAwEAAaOCA/IwggPuMB8GA1UdIwQYMBaAFHSFgMBmx9833s+9KTeqAx2+7c0XMB0GA1UdDgQWBBRM/tASTS4hz2v68vK4TEkCHTGRijCBgQYDVR0RBHoweIIPd3d3LmV4YW1wbGUub3JnggtleGFtcGxlLm5ldIILZXhhbXBsZS5lZHWCC2V4YW1wbGUuY29tggtleGFtcGxlLm9yZ4IPd3d3LmV4YW1wbGUuY29tgg93d3cuZXhhbXBsZS5lZHWCD3d3dy5leGFtcGxlLm5ldDA+BgNVHSAENzA1MDMGBmeBDAECAjApMCcGCCsGAQUFBwIBFhtodHRwOi8vd3d3LmRpZ2ljZXJ0LmNvbS9DUFMwDgYDVR0PAQH/BAQDAgWgMB0GA1UdJQQWMBQGCCsGAQUFBwMBBggrBgEFBQcDAjCBnwYDVR0fBIGXMIGUMEigRqBEhkJodHRwOi8vY3JsMy5kaWdpY2VydC5jb20vRGlnaUNlcnRHbG9iYWxHMlRMU1JTQVNIQTI1NjIwMjBDQTEtMS5jcmwwSKBGoESGQmh0dHA6Ly9jcmw0LmRpZ2ljZXJ0LmNvbS9EaWdpQ2VydEdsb2JhbEcyVExTUlNBU0hBMjU2MjAyMENBMS0xLmNybDCBhwYIKwYBBQUHAQEEezB5MCQGCCsGAQUFBzABhhhodHRwOi8vb2NzcC5kaWdpY2VydC5jb20wUQYIKwYBBQUHMAKGRWh0dHA6Ly9jYWNlcnRzLmRpZ2ljZXJ0LmNvbS9EaWdpQ2VydEdsb2JhbEcyVExTUlNBU0hBMjU2MjAyMENBMS0xLmNydDAMBgNVHRMBAf8EAjAAMIIBfQYKKwYBBAHWeQIEAgSCAW0EggFpAWcAdABOdaMnXJoQwzhbbNTfP1LrHfDgjhuNacCx+mSxYpo53wAAAY1b0vxkAAAEAwBFMEMCH0BRCgxPbBBVxhcWZ26a8JCe83P1JZ6wmv56GsVcyMACIDgpMbEo5HJITTRPnoyT4mG8cLrWjEvhchUdEcWUuk1TAHYAfVkeEuF4KnscYWd8Xv340IdcFKBOlZ65Ay/ZDowuebgAAAGNW9L8MAAABAMARzBFAiBdv5Z3pZFbfgoM3tGpCTM3ZxBMQsxBRSdTS6d8d2NAcwIhALLoCT9mTMN9OyFzIBV5MkXVLyuTf2OAzAOa7d8x2H6XAHcA5tIxY0B3jMEQQQbXcbnOwdJA9paEhvu6hzId/R43jlAAAAGNW9L8XwAABAMASDBGAiEA4Koh/VizdQU1tjZ2E2VGgWSXXkwnQmiYhmAeKcVLHeACIQD7JIGFsdGol7kss2pe4lYrCgPVc+iGZkuqnj26hqhr0TANBgkqhkiG9w0BAQsFAAOCAQEABOFuAj4N4yNG9OOWNQWTNSICC4Rd4nOG1HRP/Bsnrz7KrcPORtb6D+Jx+Q0amhO31QhIvVBYs14gY4Ypyj7MzHgm4VmPXcqLvEkxb2G9Qv9hYuEiNSQmm1fr5QAN/0AzbEbCM3cImLJ69kP5bUjfv/76KB57is8tYf9sh5ikLGKauxCM/zRIcGa3bXLDafk5S2g5Vr2hs230d/NGW1wZrE+zdGuMxfGJzJP+DAFviBfcQnFg4+1zMEKcqS87oniOyG+60RMM0MdejBD7AS43m9us96Gsun/4kufLQUTIFfnzxLutUV++3seshgefQOy5C/ayi8y1VTNmujPCxPCi6Q==\",\n  \"extensions\": [\n    {\n      \"name\": \"authorityKeyIdentifier\",\n      \"value\": \"74:85:80:C0:66:C7:DF:37:DE:CF:BD:29:37:AA:03:1D:BE:ED:CD:17\"\n    },\n    {\n      \"name\": \"subjectKeyIdentifier\",\n      \"value\": \"4C:FE:D0:12:4D:2E:21:CF:6B:FA:F2:F2:B8:4C:49:02:1D:31:91:8A\"\n    },\n    {\n      \"name\": \"subjectAltName\",\n      \"value\": \"DNS:www.example.org, DNS:example.net, DNS:example.edu, DNS:example.com, DNS:example.org, DNS:www.example.com, DNS:www.example.edu, DNS:www.example.net\"\n    },\n    {\n      \"name\": \"certificatePolicies\",\n      \"value\": \"Policy: 2.23.140.1.2.2\\n  CPS: http://www.digicert.com/CPS\"\n    },\n    {\n      \"name\": \"keyUsage\",\n      \"value\": \"Digital Signature, Key Encipherment\"\n    },\n    {\n      \"name\": \"extendedKeyUsage\",\n      \"value\": \"TLS Web Server Authentication, TLS Web Client Authentication\"\n    },\n    {\n      \"name\": \"crlDistributionPoints\",\n      \"value\": \"Full Name:\\n  URI:http://crl3.digicert.com/DigiCertGlobalG2TLSRSASHA2562020CA1-1.crl\\nFull Name:\\n  URI:http://crl4.digicert.com/DigiCertGlobalG2TLSRSASHA2562020CA1-1.crl\"\n    },\n    {\n      \"name\": \"authorityInfoAccess\",\n      \"value\": \"OCSP - URI:http://ocsp.digicert.com\\nCA Issuers - URI:http://cacerts.digicert.com/DigiCertGlobalG2TLSRSASHA2562020CA1-1.crt\"\n    },\n    {\n      \"name\": \"basicConstraints\",\n      \"value\": \"CA:FALSE\"\n    },\n    {\n      \"name\": \"ct_precert_scts\",\n      \"value\": \"Signed Certificate Timestamp:\\n    Version   : v1 (0x0)\\n    Log ID    : 4E:75:A3:27:5C:9A:10:C3:38:5B:6C:D4:DF:3F:52:EB:\\n                1D:F0:E0:8E:1B:8D:69:C0:B1:FA:64:B1:62:9A:39:DF\\n    Timestamp : Jan 30 19:22:50.340 2024 GMT\\n    Extensions: none\\n    Signature : ecdsa-with-SHA256\\n                30:43:02:1F:40:51:0A:0C:4F:6C:10:55:C6:17:16:67:\\n                6E:9A:F0:90:9E:F3:73:F5:25:9E:B0:9A:FE:7A:1A:C5:\\n                5C:C8:C0:02:20:38:29:31:B1:28:E4:72:48:4D:34:4F:\\n                9E:8C:93:E2:61:BC:70:BA:D6:8C:4B:E1:72:15:1D:11:\\n                C5:94:BA:4D:53\\nSigned Certificate Timestamp:\\n    Version   : v1 (0x0)\\n    Log ID    : 7D:59:1E:12:E1:78:2A:7B:1C:61:67:7C:5E:FD:F8:D0:\\n                87:5C:14:A0:4E:95:9E:B9:03:2F:D9:0E:8C:2E:79:B8\\n    Timestamp : Jan 30 19:22:50.288 2024 GMT\\n    Extensions: none\\n    Signature : ecdsa-with-SHA256\\n                30:45:02:20:5D:BF:96:77:A5:91:5B:7E:0A:0C:DE:D1:\\n                A9:09:33:37:67:10:4C:42:CC:41:45:27:53:4B:A7:7C:\\n                77:63:40:73:02:21:00:B2:E8:09:3F:66:4C:C3:7D:3B:\\n                21:73:20:15:79:32:45:D5:2F:2B:93:7F:63:80:CC:03:\\n                9A:ED:DF:31:D8:7E:97\\nSigned Certificate Timestamp:\\n    Version   : v1 (0x0)\\n    Log ID    : E6:D2:31:63:40:77:8C:C1:10:41:06:D7:71:B9:CE:C1:\\n                D2:40:F6:96:84:86:FB:BA:87:32:1D:FD:1E:37:8E:50\\n    Timestamp : Jan 30 19:22:50.335 2024 GMT\\n    Extensions: none\\n    Signature : ecdsa-with-SHA256\\n                30:46:02:21:00:E0:AA:21:FD:58:B3:75:05:35:B6:36:\\n                76:13:65:46:81:64:97:5E:4C:27:42:68:98:86:60:1E:\\n                29:C5:4B:1D:E0:02:21:00:FB:24:81:85:B1:D1:A8:97:\\n                B9:2C:B3:6A:5E:E2:56:2B:0A:03:D5:73:E8:86:66:4B:\\n                AA:9E:3D:BA:86:A8:6B:D1\"\n    }\n  ]\n}"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}