{
  "metadata": {
    "timestamp": 1736561330505,
    "page": 348,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "Rudrabha/Wav2Lip",
      "stars": 11123,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.13671875,
          "content": "*.pkl\n*.jpg\n*.mp4\n*.pth\n*.pyc\n__pycache__\n*.h5\n*.avi\n*.wav\nfilelists/*.txt\nevaluation/test_filelists/lr*.txt\n*.pyc\n*.mkv\n*.gif\n*.webm\n*.mp3\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 12.0361328125,
          "content": "# **Wav2Lip**: *Accurately Lip-syncing Videos In The Wild* \n### Wav2Lip is hosted for free at [sync.](https://sync.so/)\nAre you looking to integrate this into a product? We have a turn-key hosted API with new and improved lip-syncing models here: https://sync.so/\nFor any other commercial / enterprise requests, please contact us at pavan@sync.so and prady@sync.so\nTo reach out to the authors directly you can reach us at prajwal@sync.so, rudrabha@sync.so.\nThis code is part of the paper: _A Lip Sync Expert Is All You Need for Speech to Lip Generation In the Wild_ published at ACM Multimedia 2020. \n[![PWC](https://img.shields.io/endpoint.svg?url=https://paperswithcode.com/badge/a-lip-sync-expert-is-all-you-need-for-speech/lip-sync-on-lrs2)](https://paperswithcode.com/sota/lip-sync-on-lrs2?p=a-lip-sync-expert-is-all-you-need-for-speech)\n[![PWC](https://img.shields.io/endpoint.svg?url=https://paperswithcode.com/badge/a-lip-sync-expert-is-all-you-need-for-speech/lip-sync-on-lrs3)](https://paperswithcode.com/sota/lip-sync-on-lrs3?p=a-lip-sync-expert-is-all-you-need-for-speech)\n[![PWC](https://img.shields.io/endpoint.svg?url=https://paperswithcode.com/badge/a-lip-sync-expert-is-all-you-need-for-speech/lip-sync-on-lrw)](https://paperswithcode.com/sota/lip-sync-on-lrw?p=a-lip-sync-expert-is-all-you-need-for-speech)\n|ðŸ“‘ Original Paper|ðŸ“° Project Page|ðŸŒ€ Demo|âš¡ Live Testing|ðŸ“” Colab Notebook\n|:-:|:-:|:-:|:-:|:-:|\n[Paper](http://arxiv.org/abs/2008.10010) | [Project Page](http://cvit.iiit.ac.in/research/projects/cvit-projects/a-lip-sync-expert-is-all-you-need-for-speech-to-lip-generation-in-the-wild/) | [Demo Video](https://youtu.be/0fXaDCZNOJc) | [Interactive Demo](https://synclabs.so/) | [Colab Notebook](https://colab.research.google.com/drive/1tZpDWXz49W6wDcTprANRGLo2D_EbD5J8?usp=sharing) /[Updated Collab Notebook](https://colab.research.google.com/drive/1IjFW1cLevs6Ouyu4Yht4mnR4yeuMqO7Y#scrollTo=MH1m608OymLH)\n \n![Logo](https://drive.google.com/uc?export=view&id=1Wn0hPmpo4GRbCIJR8Tf20Akzdi1qjjG9)\n----------\n**Highlights**\n----------\n - Weights of the visual quality disc has been updated in readme!\n - Lip-sync videos to any target speech with high accuracy :100:. Try our [interactive demo](https://synclabs.so/).\n - :sparkles: Works for any identity, voice, and language. Also works for CGI faces and synthetic voices.\n - Complete training code, inference code, and pretrained models are available :boom:\n - Or, quick-start with the Google Colab Notebook: [Link](https://colab.research.google.com/drive/1tZpDWXz49W6wDcTprANRGLo2D_EbD5J8?usp=sharing). Checkpoints and samples are available in a Google Drive [folder](https://drive.google.com/drive/folders/1I-0dNLfFOSFwrfqjNa-SXuwaURHE5K4k?usp=sharing) as well. There is also a [tutorial video](https://www.youtube.com/watch?v=Ic0TBhfuOrA) on this, courtesy of [What Make Art](https://www.youtube.com/channel/UCmGXH-jy0o2CuhqtpxbaQgA). Also, thanks to [Eyal Gruss](https://eyalgruss.com), there is a more accessible [Google Colab notebook](https://j.mp/wav2lip) with more useful features. A tutorial collab notebook is present at this [link](https://colab.research.google.com/drive/1IjFW1cLevs6Ouyu4Yht4mnR4yeuMqO7Y#scrollTo=MH1m608OymLH).  \n - :fire: :fire: Several new, reliable evaluation benchmarks and metrics [[`evaluation/` folder of this repo]](https://github.com/Rudrabha/Wav2Lip/tree/master/evaluation) released. Instructions to calculate the metrics reported in the paper are also present.\n--------\n**Disclaimer**\n--------\nAll results from this open-source code or our [demo website](https://bhaasha.iiit.ac.in/lipsync) should only be used for research/academic/personal purposes only. As the models are trained on the <a href=\"http://www.robots.ox.ac.uk/~vgg/data/lip_reading/lrs2.html\">LRS2 dataset</a>, any form of commercial use is strictly prohibited. For commercial requests please contact us directly!\nPrerequisites\n-------------\n- `Python 3.6` \n- ffmpeg: `sudo apt-get install ffmpeg`\n- Install necessary packages using `pip install -r requirements.txt`. Alternatively, instructions for using a docker image is provided [here](https://gist.github.com/xenogenesi/e62d3d13dadbc164124c830e9c453668). Have a look at [this comment](https://github.com/Rudrabha/Wav2Lip/issues/131#issuecomment-725478562) and comment on [the gist](https://gist.github.com/xenogenesi/e62d3d13dadbc164124c830e9c453668) if you encounter any issues. \n- Face detection [pre-trained model](https://www.adrianbulat.com/downloads/python-fan/s3fd-619a316812.pth) should be downloaded to `face_detection/detection/sfd/s3fd.pth`. Alternative [link](https://iiitaphyd-my.sharepoint.com/:u:/g/personal/prajwal_k_research_iiit_ac_in/EZsy6qWuivtDnANIG73iHjIBjMSoojcIV0NULXV-yiuiIg?e=qTasa8) if the above does not work.\nGetting the weights\n----------\n| Model  | Description |  Link to the model | \n| :-------------: | :---------------: | :---------------: |\n| Wav2Lip  | Highly accurate lip-sync | [Link](https://iiitaphyd-my.sharepoint.com/:u:/g/personal/radrabha_m_research_iiit_ac_in/Eb3LEzbfuKlJiR600lQWRxgBIY27JZg80f7V9jtMfbNDaQ?e=TBFBVW)  |\n| Wav2Lip + GAN  | Slightly inferior lip-sync, but better visual quality | [Link](https://iiitaphyd-my.sharepoint.com/:u:/g/personal/radrabha_m_research_iiit_ac_in/EdjI7bZlgApMqsVoEUUXpLsBxqXbn5z8VTmoxp55YNDcIA?e=n9ljGW) |\n| Expert Discriminator  | Weights of the expert discriminator | [Link](https://iiitaphyd-my.sharepoint.com/:u:/g/personal/radrabha_m_research_iiit_ac_in/EQRvmiZg-HRAjvI6zqN9eTEBP74KefynCwPWVmF57l-AYA?e=ZRPHKP) |\n| Visual Quality Discriminator  | Weights of the visual disc trained in a GAN setup | [Link](https://iiitaphyd-my.sharepoint.com/:u:/g/personal/radrabha_m_research_iiit_ac_in/EQVqH88dTm1HjlK11eNba5gBbn15WMS0B0EZbDBttqrqkg?e=ic0ljo) |\nLip-syncing videos using the pre-trained models (Inference)\n-------\nYou can lip-sync any video to any audio:\n```bash\npython inference.py --checkpoint_path <ckpt> --face <video.mp4> --audio <an-audio-source> \n```\nThe result is saved (by default) in `results/result_voice.mp4`. You can specify it as an argument,  similar to several other available options. The audio source can be any file supported by `FFMPEG` containing audio data: `*.wav`, `*.mp3` or even a video file, from which the code will automatically extract the audio.\n##### Tips for better results:\n- Experiment with the `--pads` argument to adjust the detected face bounding box. Often leads to improved results. You might need to increase the bottom padding to include the chin region. E.g. `--pads 0 20 0 0`.\n- If you see the mouth position dislocated or some weird artifacts such as two mouths, then it can be because of over-smoothing the face detections. Use the `--nosmooth` argument and give it another try. \n- Experiment with the `--resize_factor` argument, to get a lower-resolution video. Why? The models are trained on faces that were at a lower resolution. You might get better, visually pleasing results for 720p videos than for 1080p videos (in many cases, the latter works well too). \n- The Wav2Lip model without GAN usually needs more experimenting with the above two to get the most ideal results, and sometimes, can give you a better result as well.\nPreparing LRS2 for training\n----------\nOur models are trained on LRS2. See [here](#training-on-datasets-other-than-lrs2) for a few suggestions regarding training on other datasets.\n##### LRS2 dataset folder structure\n```\ndata_root (mvlrs_v1)\nâ”œâ”€â”€ main, pretrain (we use only main folder in this work)\n|\tâ”œâ”€â”€ list of folders\n|\tâ”‚   â”œâ”€â”€ five-digit numbered video IDs ending with (.mp4)\n```\nPlace the LRS2 filelists (train, val, test) `.txt` files in the `filelists/` folder.\n##### Preprocess the dataset for fast training\n```bash\npython preprocess.py --data_root data_root/main --preprocessed_root lrs2_preprocessed/\n```\nAdditional options like `batch_size` and the number of GPUs to use in parallel to use can also be set.\n##### Preprocessed LRS2 folder structure\n```\npreprocessed_root (lrs2_preprocessed)\nâ”œâ”€â”€ list of folders\n|\tâ”œâ”€â”€ Folders with five-digit numbered video IDs\n|\tâ”‚   â”œâ”€â”€ *.jpg\n|\tâ”‚   â”œâ”€â”€ audio.wav\n```\nTrain!\n----------\nThere are two major steps: (i) Train the expert lip-sync discriminator, (ii) Train the Wav2Lip model(s).\n##### Training the expert discriminator\nYou can download [the pre-trained weights](#getting-the-weights) if you want to skip this step. To train it:\n```bash\npython color_syncnet_train.py --data_root lrs2_preprocessed/ --checkpoint_dir <folder_to_save_checkpoints>\n```\n##### Training the Wav2Lip models\nYou can either train the model without the additional visual quality discriminator (< 1 day of training) or use the discriminator (~2 days). For the former, run: \n```bash\npython wav2lip_train.py --data_root lrs2_preprocessed/ --checkpoint_dir <folder_to_save_checkpoints> --syncnet_checkpoint_path <path_to_expert_disc_checkpoint>\n```\nTo train with the visual quality discriminator, you should run `hq_wav2lip_train.py` instead. The arguments for both files are similar. In both cases, you can resume training as well. Look at `python wav2lip_train.py --help` for more details. You can also set additional less commonly-used hyper-parameters at the bottom of the `hparams.py` file.\nTraining on datasets other than LRS2\n------------------------------------\nTraining on other datasets might require modifications to the code. Please read the following before you raise an issue:\n- You might not get good results by training/fine-tuning on a few minutes of a single speaker. This is a separate research problem, to which we do not have a solution yet. Thus, we would most likely not be able to resolve your issue. \n- You must train the expert discriminator for your own dataset before training Wav2Lip.\n- If it is your own dataset downloaded from the web, in most cases, needs to be sync-corrected.\n- Be mindful of the FPS of the videos of your dataset. Changes to FPS would need significant code changes. \n- The expert discriminator's eval loss should go down to ~0.25 and the Wav2Lip eval sync loss should go down to ~0.2 to get good results. \nWhen raising an issue on this topic, please let us know that you are aware of all these points.\nWe have an HD model trained on a dataset allowing commercial usage. The size of the generated face will be 192 x 288 in our new model.\nEvaluation\n----------\nPlease check the `evaluation/` folder for the instructions.\nLicense and Citation\n----------\nThis repository can only be used for personal/research/non-commercial purposes. However, for commercial requests, please contact us directly at rudrabha@synclabs.so or prajwal@synclabs.so. We have a turn-key hosted API with new and improved lip-syncing models here: https://synclabs.so/\nThe size of the generated face will be 192 x 288 in our new models. Please cite the following paper if you use this repository:\n```\n@inproceedings{10.1145/3394171.3413532,\nauthor = {Prajwal, K R and Mukhopadhyay, Rudrabha and Namboodiri, Vinay P. and Jawahar, C.V.},\ntitle = {A Lip Sync Expert Is All You Need for Speech to Lip Generation In the Wild},\nyear = {2020},\nisbn = {9781450379885},\npublisher = {Association for Computing Machinery},\naddress = {New York, NY, USA},\nurl = {https://doi.org/10.1145/3394171.3413532},\ndoi = {10.1145/3394171.3413532},\nbooktitle = {Proceedings of the 28th ACM International Conference on Multimedia},\npages = {484â€“492},\nnumpages = {9},\nkeywords = {lip sync, talking face generation, video generation},\nlocation = {Seattle, WA, USA},\nseries = {MM '20}\n}\n```\nAcknowledgments\n----------\nParts of the code structure are inspired by this [TTS repository](https://github.com/r9y9/deepvoice3_pytorch). We thank the author for this wonderful code. The code for Face Detection has been taken from the [face_alignment](https://github.com/1adrianb/face-alignment) repository. We thank the authors for releasing their code and models. We thank [zabique](https://github.com/zabique) for the tutorial collab notebook.\n## Acknowledgements\n - [Awesome Readme Templates](https://awesomeopensource.com/project/elangosundar/awesome-README-templates)\n - [Awesome README](https://github.com/matiassingers/awesome-readme)\n - [How to write a Good readme](https://bulldogjob.com/news/449-how-to-write-a-good-readme-for-your-github-project)\n"
        },
        {
          "name": "audio.py",
          "type": "blob",
          "size": 4.3935546875,
          "content": "import librosa\nimport librosa.filters\nimport numpy as np\n# import tensorflow as tf\nfrom scipy import signal\nfrom scipy.io import wavfile\nfrom hparams import hparams as hp\n\ndef load_wav(path, sr):\n    return librosa.core.load(path, sr=sr)[0]\n\ndef save_wav(wav, path, sr):\n    wav *= 32767 / max(0.01, np.max(np.abs(wav)))\n    #proposed by @dsmiller\n    wavfile.write(path, sr, wav.astype(np.int16))\n\ndef save_wavenet_wav(wav, path, sr):\n    librosa.output.write_wav(path, wav, sr=sr)\n\ndef preemphasis(wav, k, preemphasize=True):\n    if preemphasize:\n        return signal.lfilter([1, -k], [1], wav)\n    return wav\n\ndef inv_preemphasis(wav, k, inv_preemphasize=True):\n    if inv_preemphasize:\n        return signal.lfilter([1], [1, -k], wav)\n    return wav\n\ndef get_hop_size():\n    hop_size = hp.hop_size\n    if hop_size is None:\n        assert hp.frame_shift_ms is not None\n        hop_size = int(hp.frame_shift_ms / 1000 * hp.sample_rate)\n    return hop_size\n\ndef linearspectrogram(wav):\n    D = _stft(preemphasis(wav, hp.preemphasis, hp.preemphasize))\n    S = _amp_to_db(np.abs(D)) - hp.ref_level_db\n    \n    if hp.signal_normalization:\n        return _normalize(S)\n    return S\n\ndef melspectrogram(wav):\n    D = _stft(preemphasis(wav, hp.preemphasis, hp.preemphasize))\n    S = _amp_to_db(_linear_to_mel(np.abs(D))) - hp.ref_level_db\n    \n    if hp.signal_normalization:\n        return _normalize(S)\n    return S\n\ndef _lws_processor():\n    import lws\n    return lws.lws(hp.n_fft, get_hop_size(), fftsize=hp.win_size, mode=\"speech\")\n\ndef _stft(y):\n    if hp.use_lws:\n        return _lws_processor(hp).stft(y).T\n    else:\n        return librosa.stft(y=y, n_fft=hp.n_fft, hop_length=get_hop_size(), win_length=hp.win_size)\n\n##########################################################\n#Those are only correct when using lws!!! (This was messing with Wavenet quality for a long time!)\ndef num_frames(length, fsize, fshift):\n    \"\"\"Compute number of time frames of spectrogram\n    \"\"\"\n    pad = (fsize - fshift)\n    if length % fshift == 0:\n        M = (length + pad * 2 - fsize) // fshift + 1\n    else:\n        M = (length + pad * 2 - fsize) // fshift + 2\n    return M\n\n\ndef pad_lr(x, fsize, fshift):\n    \"\"\"Compute left and right padding\n    \"\"\"\n    M = num_frames(len(x), fsize, fshift)\n    pad = (fsize - fshift)\n    T = len(x) + 2 * pad\n    r = (M - 1) * fshift + fsize - T\n    return pad, pad + r\n##########################################################\n#Librosa correct padding\ndef librosa_pad_lr(x, fsize, fshift):\n    return 0, (x.shape[0] // fshift + 1) * fshift - x.shape[0]\n\n# Conversions\n_mel_basis = None\n\ndef _linear_to_mel(spectogram):\n    global _mel_basis\n    if _mel_basis is None:\n        _mel_basis = _build_mel_basis()\n    return np.dot(_mel_basis, spectogram)\n\ndef _build_mel_basis():\n    assert hp.fmax <= hp.sample_rate // 2\n    return librosa.filters.mel(hp.sample_rate, hp.n_fft, n_mels=hp.num_mels,\n                               fmin=hp.fmin, fmax=hp.fmax)\n\ndef _amp_to_db(x):\n    min_level = np.exp(hp.min_level_db / 20 * np.log(10))\n    return 20 * np.log10(np.maximum(min_level, x))\n\ndef _db_to_amp(x):\n    return np.power(10.0, (x) * 0.05)\n\ndef _normalize(S):\n    if hp.allow_clipping_in_normalization:\n        if hp.symmetric_mels:\n            return np.clip((2 * hp.max_abs_value) * ((S - hp.min_level_db) / (-hp.min_level_db)) - hp.max_abs_value,\n                           -hp.max_abs_value, hp.max_abs_value)\n        else:\n            return np.clip(hp.max_abs_value * ((S - hp.min_level_db) / (-hp.min_level_db)), 0, hp.max_abs_value)\n    \n    assert S.max() <= 0 and S.min() - hp.min_level_db >= 0\n    if hp.symmetric_mels:\n        return (2 * hp.max_abs_value) * ((S - hp.min_level_db) / (-hp.min_level_db)) - hp.max_abs_value\n    else:\n        return hp.max_abs_value * ((S - hp.min_level_db) / (-hp.min_level_db))\n\ndef _denormalize(D):\n    if hp.allow_clipping_in_normalization:\n        if hp.symmetric_mels:\n            return (((np.clip(D, -hp.max_abs_value,\n                              hp.max_abs_value) + hp.max_abs_value) * -hp.min_level_db / (2 * hp.max_abs_value))\n                    + hp.min_level_db)\n        else:\n            return ((np.clip(D, 0, hp.max_abs_value) * -hp.min_level_db / hp.max_abs_value) + hp.min_level_db)\n    \n    if hp.symmetric_mels:\n        return (((D + hp.max_abs_value) * -hp.min_level_db / (2 * hp.max_abs_value)) + hp.min_level_db)\n    else:\n        return ((D * -hp.min_level_db / hp.max_abs_value) + hp.min_level_db)\n"
        },
        {
          "name": "checkpoints",
          "type": "tree",
          "content": null
        },
        {
          "name": "color_syncnet_train.py",
          "type": "blob",
          "size": 8.5654296875,
          "content": "from os.path import dirname, join, basename, isfile\nfrom tqdm import tqdm\n\nfrom models import SyncNet_color as SyncNet\nimport audio\n\nimport torch\nfrom torch import nn\nfrom torch import optim\nimport torch.backends.cudnn as cudnn\nfrom torch.utils import data as data_utils\nimport numpy as np\n\nfrom glob import glob\n\nimport os, random, cv2, argparse\nfrom hparams import hparams, get_image_list\n\nparser = argparse.ArgumentParser(description='Code to train the expert lip-sync discriminator')\n\nparser.add_argument(\"--data_root\", help=\"Root folder of the preprocessed LRS2 dataset\", required=True)\n\nparser.add_argument('--checkpoint_dir', help='Save checkpoints to this directory', required=True, type=str)\nparser.add_argument('--checkpoint_path', help='Resumed from this checkpoint', default=None, type=str)\n\nargs = parser.parse_args()\n\n\nglobal_step = 0\nglobal_epoch = 0\nuse_cuda = torch.cuda.is_available()\nprint('use_cuda: {}'.format(use_cuda))\n\nsyncnet_T = 5\nsyncnet_mel_step_size = 16\n\nclass Dataset(object):\n    def __init__(self, split):\n        self.all_videos = get_image_list(args.data_root, split)\n\n    def get_frame_id(self, frame):\n        return int(basename(frame).split('.')[0])\n\n    def get_window(self, start_frame):\n        start_id = self.get_frame_id(start_frame)\n        vidname = dirname(start_frame)\n\n        window_fnames = []\n        for frame_id in range(start_id, start_id + syncnet_T):\n            frame = join(vidname, '{}.jpg'.format(frame_id))\n            if not isfile(frame):\n                return None\n            window_fnames.append(frame)\n        return window_fnames\n\n    def crop_audio_window(self, spec, start_frame):\n        # num_frames = (T x hop_size * fps) / sample_rate\n        start_frame_num = self.get_frame_id(start_frame)\n        start_idx = int(80. * (start_frame_num / float(hparams.fps)))\n\n        end_idx = start_idx + syncnet_mel_step_size\n\n        return spec[start_idx : end_idx, :]\n\n\n    def __len__(self):\n        return len(self.all_videos)\n\n    def __getitem__(self, idx):\n        while 1:\n            idx = random.randint(0, len(self.all_videos) - 1)\n            vidname = self.all_videos[idx]\n\n            img_names = list(glob(join(vidname, '*.jpg')))\n            if len(img_names) <= 3 * syncnet_T:\n                continue\n            img_name = random.choice(img_names)\n            wrong_img_name = random.choice(img_names)\n            while wrong_img_name == img_name:\n                wrong_img_name = random.choice(img_names)\n\n            if random.choice([True, False]):\n                y = torch.ones(1).float()\n                chosen = img_name\n            else:\n                y = torch.zeros(1).float()\n                chosen = wrong_img_name\n\n            window_fnames = self.get_window(chosen)\n            if window_fnames is None:\n                continue\n\n            window = []\n            all_read = True\n            for fname in window_fnames:\n                img = cv2.imread(fname)\n                if img is None:\n                    all_read = False\n                    break\n                try:\n                    img = cv2.resize(img, (hparams.img_size, hparams.img_size))\n                except Exception as e:\n                    all_read = False\n                    break\n\n                window.append(img)\n\n            if not all_read: continue\n\n            try:\n                wavpath = join(vidname, \"audio.wav\")\n                wav = audio.load_wav(wavpath, hparams.sample_rate)\n\n                orig_mel = audio.melspectrogram(wav).T\n            except Exception as e:\n                continue\n\n            mel = self.crop_audio_window(orig_mel.copy(), img_name)\n\n            if (mel.shape[0] != syncnet_mel_step_size):\n                continue\n\n            # H x W x 3 * T\n            x = np.concatenate(window, axis=2) / 255.\n            x = x.transpose(2, 0, 1)\n            x = x[:, x.shape[1]//2:]\n\n            x = torch.FloatTensor(x)\n            mel = torch.FloatTensor(mel.T).unsqueeze(0)\n\n            return x, mel, y\n\nlogloss = nn.BCELoss()\ndef cosine_loss(a, v, y):\n    d = nn.functional.cosine_similarity(a, v)\n    loss = logloss(d.unsqueeze(1), y)\n\n    return loss\n\ndef train(device, model, train_data_loader, test_data_loader, optimizer,\n          checkpoint_dir=None, checkpoint_interval=None, nepochs=None):\n\n    global global_step, global_epoch\n    resumed_step = global_step\n    \n    while global_epoch < nepochs:\n        running_loss = 0.\n        prog_bar = tqdm(enumerate(train_data_loader))\n        for step, (x, mel, y) in prog_bar:\n            model.train()\n            optimizer.zero_grad()\n\n            # Transform data to CUDA device\n            x = x.to(device)\n\n            mel = mel.to(device)\n\n            a, v = model(mel, x)\n            y = y.to(device)\n\n            loss = cosine_loss(a, v, y)\n            loss.backward()\n            optimizer.step()\n\n            global_step += 1\n            cur_session_steps = global_step - resumed_step\n            running_loss += loss.item()\n\n            if global_step == 1 or global_step % checkpoint_interval == 0:\n                save_checkpoint(\n                    model, optimizer, global_step, checkpoint_dir, global_epoch)\n\n            if global_step % hparams.syncnet_eval_interval == 0:\n                with torch.no_grad():\n                    eval_model(test_data_loader, global_step, device, model, checkpoint_dir)\n\n            prog_bar.set_description('Loss: {}'.format(running_loss / (step + 1)))\n\n        global_epoch += 1\n\ndef eval_model(test_data_loader, global_step, device, model, checkpoint_dir):\n    eval_steps = 1400\n    print('Evaluating for {} steps'.format(eval_steps))\n    losses = []\n    while 1:\n        for step, (x, mel, y) in enumerate(test_data_loader):\n\n            model.eval()\n\n            # Transform data to CUDA device\n            x = x.to(device)\n\n            mel = mel.to(device)\n\n            a, v = model(mel, x)\n            y = y.to(device)\n\n            loss = cosine_loss(a, v, y)\n            losses.append(loss.item())\n\n            if step > eval_steps: break\n\n        averaged_loss = sum(losses) / len(losses)\n        print(averaged_loss)\n\n        return\n\ndef save_checkpoint(model, optimizer, step, checkpoint_dir, epoch):\n\n    checkpoint_path = join(\n        checkpoint_dir, \"checkpoint_step{:09d}.pth\".format(global_step))\n    optimizer_state = optimizer.state_dict() if hparams.save_optimizer_state else None\n    torch.save({\n        \"state_dict\": model.state_dict(),\n        \"optimizer\": optimizer_state,\n        \"global_step\": step,\n        \"global_epoch\": epoch,\n    }, checkpoint_path)\n    print(\"Saved checkpoint:\", checkpoint_path)\n\ndef _load(checkpoint_path):\n    if use_cuda:\n        checkpoint = torch.load(checkpoint_path)\n    else:\n        checkpoint = torch.load(checkpoint_path,\n                                map_location=lambda storage, loc: storage)\n    return checkpoint\n\ndef load_checkpoint(path, model, optimizer, reset_optimizer=False):\n    global global_step\n    global global_epoch\n\n    print(\"Load checkpoint from: {}\".format(path))\n    checkpoint = _load(path)\n    model.load_state_dict(checkpoint[\"state_dict\"])\n    if not reset_optimizer:\n        optimizer_state = checkpoint[\"optimizer\"]\n        if optimizer_state is not None:\n            print(\"Load optimizer state from {}\".format(path))\n            optimizer.load_state_dict(checkpoint[\"optimizer\"])\n    global_step = checkpoint[\"global_step\"]\n    global_epoch = checkpoint[\"global_epoch\"]\n\n    return model\n\nif __name__ == \"__main__\":\n    checkpoint_dir = args.checkpoint_dir\n    checkpoint_path = args.checkpoint_path\n\n    if not os.path.exists(checkpoint_dir): os.mkdir(checkpoint_dir)\n\n    # Dataset and Dataloader setup\n    train_dataset = Dataset('train')\n    test_dataset = Dataset('val')\n\n    train_data_loader = data_utils.DataLoader(\n        train_dataset, batch_size=hparams.syncnet_batch_size, shuffle=True,\n        num_workers=hparams.num_workers)\n\n    test_data_loader = data_utils.DataLoader(\n        test_dataset, batch_size=hparams.syncnet_batch_size,\n        num_workers=8)\n\n    device = torch.device(\"cuda\" if use_cuda else \"cpu\")\n\n    # Model\n    model = SyncNet().to(device)\n    print('total trainable params {}'.format(sum(p.numel() for p in model.parameters() if p.requires_grad)))\n\n    optimizer = optim.Adam([p for p in model.parameters() if p.requires_grad],\n                           lr=hparams.syncnet_lr)\n\n    if checkpoint_path is not None:\n        load_checkpoint(checkpoint_path, model, optimizer, reset_optimizer=False)\n\n    train(device, model, train_data_loader, test_data_loader, optimizer,\n          checkpoint_dir=checkpoint_dir,\n          checkpoint_interval=hparams.syncnet_checkpoint_interval,\n          nepochs=hparams.nepochs)\n"
        },
        {
          "name": "evaluation",
          "type": "tree",
          "content": null
        },
        {
          "name": "face_detection",
          "type": "tree",
          "content": null
        },
        {
          "name": "filelists",
          "type": "tree",
          "content": null
        },
        {
          "name": "hparams.py",
          "type": "blob",
          "size": 3.47265625,
          "content": "from glob import glob\nimport os\n\ndef get_image_list(data_root, split):\n\tfilelist = []\n\n\twith open('filelists/{}.txt'.format(split)) as f:\n\t\tfor line in f:\n\t\t\tline = line.strip()\n\t\t\tif ' ' in line: line = line.split()[0]\n\t\t\tfilelist.append(os.path.join(data_root, line))\n\n\treturn filelist\n\nclass HParams:\n\tdef __init__(self, **kwargs):\n\t\tself.data = {}\n\n\t\tfor key, value in kwargs.items():\n\t\t\tself.data[key] = value\n\n\tdef __getattr__(self, key):\n\t\tif key not in self.data:\n\t\t\traise AttributeError(\"'HParams' object has no attribute %s\" % key)\n\t\treturn self.data[key]\n\n\tdef set_hparam(self, key, value):\n\t\tself.data[key] = value\n\n\n# Default hyperparameters\nhparams = HParams(\n\tnum_mels=80,  # Number of mel-spectrogram channels and local conditioning dimensionality\n\t#  network\n\trescale=True,  # Whether to rescale audio prior to preprocessing\n\trescaling_max=0.9,  # Rescaling value\n\t\n\t# Use LWS (https://github.com/Jonathan-LeRoux/lws) for STFT and phase reconstruction\n\t# It\"s preferred to set True to use with https://github.com/r9y9/wavenet_vocoder\n\t# Does not work if n_ffit is not multiple of hop_size!!\n\tuse_lws=False,\n\t\n\tn_fft=800,  # Extra window size is filled with 0 paddings to match this parameter\n\thop_size=200,  # For 16000Hz, 200 = 12.5 ms (0.0125 * sample_rate)\n\twin_size=800,  # For 16000Hz, 800 = 50 ms (If None, win_size = n_fft) (0.05 * sample_rate)\n\tsample_rate=16000,  # 16000Hz (corresponding to librispeech) (sox --i <filename>)\n\t\n\tframe_shift_ms=None,  # Can replace hop_size parameter. (Recommended: 12.5)\n\t\n\t# Mel and Linear spectrograms normalization/scaling and clipping\n\tsignal_normalization=True,\n\t# Whether to normalize mel spectrograms to some predefined range (following below parameters)\n\tallow_clipping_in_normalization=True,  # Only relevant if mel_normalization = True\n\tsymmetric_mels=True,\n\t# Whether to scale the data to be symmetric around 0. (Also multiplies the output range by 2, \n\t# faster and cleaner convergence)\n\tmax_abs_value=4.,\n\t# max absolute value of data. If symmetric, data will be [-max, max] else [0, max] (Must not \n\t# be too big to avoid gradient explosion, \n\t# not too small for fast convergence)\n\t# Contribution by @begeekmyfriend\n\t# Spectrogram Pre-Emphasis (Lfilter: Reduce spectrogram noise and helps model certitude \n\t# levels. Also allows for better G&L phase reconstruction)\n\tpreemphasize=True,  # whether to apply filter\n\tpreemphasis=0.97,  # filter coefficient.\n\t\n\t# Limits\n\tmin_level_db=-100,\n\tref_level_db=20,\n\tfmin=55,\n\t# Set this to 55 if your speaker is male! if female, 95 should help taking off noise. (To \n\t# test depending on dataset. Pitch info: male~[65, 260], female~[100, 525])\n\tfmax=7600,  # To be increased/reduced depending on data.\n\n\t###################### Our training parameters #################################\n\timg_size=96,\n\tfps=25,\n\t\n\tbatch_size=16,\n\tinitial_learning_rate=1e-4,\n\tnepochs=200000000000000000,  ### ctrl + c, stop whenever eval loss is consistently greater than train loss for ~10 epochs\n\tnum_workers=16,\n\tcheckpoint_interval=3000,\n\teval_interval=3000,\n    save_optimizer_state=True,\n\n    syncnet_wt=0.0, # is initially zero, will be set automatically to 0.03 later. Leads to faster convergence. \n\tsyncnet_batch_size=64,\n\tsyncnet_lr=1e-4,\n\tsyncnet_eval_interval=10000,\n\tsyncnet_checkpoint_interval=10000,\n\n\tdisc_wt=0.07,\n\tdisc_initial_learning_rate=1e-4,\n)\n\n\ndef hparams_debug_string():\n\tvalues = hparams.values()\n\thp = [\"  %s: %s\" % (name, values[name]) for name in sorted(values) if name != \"sentences\"]\n\treturn \"Hyperparameters:\\n\" + \"\\n\".join(hp)\n"
        },
        {
          "name": "hq_wav2lip_train.py",
          "type": "blob",
          "size": 16.333984375,
          "content": "from os.path import dirname, join, basename, isfile\nfrom tqdm import tqdm\n\nfrom models import SyncNet_color as SyncNet\nfrom models import Wav2Lip, Wav2Lip_disc_qual\nimport audio\n\nimport torch\nfrom torch import nn\nfrom torch.nn import functional as F\nfrom torch import optim\nimport torch.backends.cudnn as cudnn\nfrom torch.utils import data as data_utils\nimport numpy as np\n\nfrom glob import glob\n\nimport os, random, cv2, argparse\nfrom hparams import hparams, get_image_list\n\nparser = argparse.ArgumentParser(description='Code to train the Wav2Lip model WITH the visual quality discriminator')\n\nparser.add_argument(\"--data_root\", help=\"Root folder of the preprocessed LRS2 dataset\", required=True, type=str)\n\nparser.add_argument('--checkpoint_dir', help='Save checkpoints to this directory', required=True, type=str)\nparser.add_argument('--syncnet_checkpoint_path', help='Load the pre-trained Expert discriminator', required=True, type=str)\n\nparser.add_argument('--checkpoint_path', help='Resume generator from this checkpoint', default=None, type=str)\nparser.add_argument('--disc_checkpoint_path', help='Resume quality disc from this checkpoint', default=None, type=str)\n\nargs = parser.parse_args()\n\n\nglobal_step = 0\nglobal_epoch = 0\nuse_cuda = torch.cuda.is_available()\nprint('use_cuda: {}'.format(use_cuda))\n\nsyncnet_T = 5\nsyncnet_mel_step_size = 16\n\nclass Dataset(object):\n    def __init__(self, split):\n        self.all_videos = get_image_list(args.data_root, split)\n\n    def get_frame_id(self, frame):\n        return int(basename(frame).split('.')[0])\n\n    def get_window(self, start_frame):\n        start_id = self.get_frame_id(start_frame)\n        vidname = dirname(start_frame)\n\n        window_fnames = []\n        for frame_id in range(start_id, start_id + syncnet_T):\n            frame = join(vidname, '{}.jpg'.format(frame_id))\n            if not isfile(frame):\n                return None\n            window_fnames.append(frame)\n        return window_fnames\n\n    def read_window(self, window_fnames):\n        if window_fnames is None: return None\n        window = []\n        for fname in window_fnames:\n            img = cv2.imread(fname)\n            if img is None:\n                return None\n            try:\n                img = cv2.resize(img, (hparams.img_size, hparams.img_size))\n            except Exception as e:\n                return None\n\n            window.append(img)\n\n        return window\n\n    def crop_audio_window(self, spec, start_frame):\n        if type(start_frame) == int:\n            start_frame_num = start_frame\n        else:\n            start_frame_num = self.get_frame_id(start_frame)\n        start_idx = int(80. * (start_frame_num / float(hparams.fps)))\n        \n        end_idx = start_idx + syncnet_mel_step_size\n\n        return spec[start_idx : end_idx, :]\n\n    def get_segmented_mels(self, spec, start_frame):\n        mels = []\n        assert syncnet_T == 5\n        start_frame_num = self.get_frame_id(start_frame) + 1 # 0-indexing ---> 1-indexing\n        if start_frame_num - 2 < 0: return None\n        for i in range(start_frame_num, start_frame_num + syncnet_T):\n            m = self.crop_audio_window(spec, i - 2)\n            if m.shape[0] != syncnet_mel_step_size:\n                return None\n            mels.append(m.T)\n\n        mels = np.asarray(mels)\n\n        return mels\n\n    def prepare_window(self, window):\n        # 3 x T x H x W\n        x = np.asarray(window) / 255.\n        x = np.transpose(x, (3, 0, 1, 2))\n\n        return x\n\n    def __len__(self):\n        return len(self.all_videos)\n\n    def __getitem__(self, idx):\n        while 1:\n            idx = random.randint(0, len(self.all_videos) - 1)\n            vidname = self.all_videos[idx]\n            img_names = list(glob(join(vidname, '*.jpg')))\n            if len(img_names) <= 3 * syncnet_T:\n                continue\n            \n            img_name = random.choice(img_names)\n            wrong_img_name = random.choice(img_names)\n            while wrong_img_name == img_name:\n                wrong_img_name = random.choice(img_names)\n\n            window_fnames = self.get_window(img_name)\n            wrong_window_fnames = self.get_window(wrong_img_name)\n            if window_fnames is None or wrong_window_fnames is None:\n                continue\n\n            window = self.read_window(window_fnames)\n            if window is None:\n                continue\n\n            wrong_window = self.read_window(wrong_window_fnames)\n            if wrong_window is None:\n                continue\n\n            try:\n                wavpath = join(vidname, \"audio.wav\")\n                wav = audio.load_wav(wavpath, hparams.sample_rate)\n\n                orig_mel = audio.melspectrogram(wav).T\n            except Exception as e:\n                continue\n\n            mel = self.crop_audio_window(orig_mel.copy(), img_name)\n            \n            if (mel.shape[0] != syncnet_mel_step_size):\n                continue\n\n            indiv_mels = self.get_segmented_mels(orig_mel.copy(), img_name)\n            if indiv_mels is None: continue\n\n            window = self.prepare_window(window)\n            y = window.copy()\n            window[:, :, window.shape[2]//2:] = 0.\n\n            wrong_window = self.prepare_window(wrong_window)\n            x = np.concatenate([window, wrong_window], axis=0)\n\n            x = torch.FloatTensor(x)\n            mel = torch.FloatTensor(mel.T).unsqueeze(0)\n            indiv_mels = torch.FloatTensor(indiv_mels).unsqueeze(1)\n            y = torch.FloatTensor(y)\n            return x, indiv_mels, mel, y\n\ndef save_sample_images(x, g, gt, global_step, checkpoint_dir):\n    x = (x.detach().cpu().numpy().transpose(0, 2, 3, 4, 1) * 255.).astype(np.uint8)\n    g = (g.detach().cpu().numpy().transpose(0, 2, 3, 4, 1) * 255.).astype(np.uint8)\n    gt = (gt.detach().cpu().numpy().transpose(0, 2, 3, 4, 1) * 255.).astype(np.uint8)\n\n    refs, inps = x[..., 3:], x[..., :3]\n    folder = join(checkpoint_dir, \"samples_step{:09d}\".format(global_step))\n    if not os.path.exists(folder): os.mkdir(folder)\n    collage = np.concatenate((refs, inps, g, gt), axis=-2)\n    for batch_idx, c in enumerate(collage):\n        for t in range(len(c)):\n            cv2.imwrite('{}/{}_{}.jpg'.format(folder, batch_idx, t), c[t])\n\nlogloss = nn.BCELoss()\ndef cosine_loss(a, v, y):\n    d = nn.functional.cosine_similarity(a, v)\n    loss = logloss(d.unsqueeze(1), y)\n\n    return loss\n\ndevice = torch.device(\"cuda\" if use_cuda else \"cpu\")\nsyncnet = SyncNet().to(device)\nfor p in syncnet.parameters():\n    p.requires_grad = False\n\nrecon_loss = nn.L1Loss()\ndef get_sync_loss(mel, g):\n    g = g[:, :, :, g.size(3)//2:]\n    g = torch.cat([g[:, :, i] for i in range(syncnet_T)], dim=1)\n    # B, 3 * T, H//2, W\n    a, v = syncnet(mel, g)\n    y = torch.ones(g.size(0), 1).float().to(device)\n    return cosine_loss(a, v, y)\n\ndef train(device, model, disc, train_data_loader, test_data_loader, optimizer, disc_optimizer,\n          checkpoint_dir=None, checkpoint_interval=None, nepochs=None):\n    global global_step, global_epoch\n    resumed_step = global_step\n\n    while global_epoch < nepochs:\n        print('Starting Epoch: {}'.format(global_epoch))\n        running_sync_loss, running_l1_loss, disc_loss, running_perceptual_loss = 0., 0., 0., 0.\n        running_disc_real_loss, running_disc_fake_loss = 0., 0.\n        prog_bar = tqdm(enumerate(train_data_loader))\n        for step, (x, indiv_mels, mel, gt) in prog_bar:\n            disc.train()\n            model.train()\n\n            x = x.to(device)\n            mel = mel.to(device)\n            indiv_mels = indiv_mels.to(device)\n            gt = gt.to(device)\n\n            ### Train generator now. Remove ALL grads. \n            optimizer.zero_grad()\n            disc_optimizer.zero_grad()\n\n            g = model(indiv_mels, x)\n\n            if hparams.syncnet_wt > 0.:\n                sync_loss = get_sync_loss(mel, g)\n            else:\n                sync_loss = 0.\n\n            if hparams.disc_wt > 0.:\n                perceptual_loss = disc.perceptual_forward(g)\n            else:\n                perceptual_loss = 0.\n\n            l1loss = recon_loss(g, gt)\n\n            loss = hparams.syncnet_wt * sync_loss + hparams.disc_wt * perceptual_loss + \\\n                                    (1. - hparams.syncnet_wt - hparams.disc_wt) * l1loss\n\n            loss.backward()\n            optimizer.step()\n\n            ### Remove all gradients before Training disc\n            disc_optimizer.zero_grad()\n\n            pred = disc(gt)\n            disc_real_loss = F.binary_cross_entropy(pred, torch.ones((len(pred), 1)).to(device))\n            disc_real_loss.backward()\n\n            pred = disc(g.detach())\n            disc_fake_loss = F.binary_cross_entropy(pred, torch.zeros((len(pred), 1)).to(device))\n            disc_fake_loss.backward()\n\n            disc_optimizer.step()\n\n            running_disc_real_loss += disc_real_loss.item()\n            running_disc_fake_loss += disc_fake_loss.item()\n\n            if global_step % checkpoint_interval == 0:\n                save_sample_images(x, g, gt, global_step, checkpoint_dir)\n\n            # Logs\n            global_step += 1\n            cur_session_steps = global_step - resumed_step\n\n            running_l1_loss += l1loss.item()\n            if hparams.syncnet_wt > 0.:\n                running_sync_loss += sync_loss.item()\n            else:\n                running_sync_loss += 0.\n\n            if hparams.disc_wt > 0.:\n                running_perceptual_loss += perceptual_loss.item()\n            else:\n                running_perceptual_loss += 0.\n\n            if global_step == 1 or global_step % checkpoint_interval == 0:\n                save_checkpoint(\n                    model, optimizer, global_step, checkpoint_dir, global_epoch)\n                save_checkpoint(disc, disc_optimizer, global_step, checkpoint_dir, global_epoch, prefix='disc_')\n\n\n            if global_step % hparams.eval_interval == 0:\n                with torch.no_grad():\n                    average_sync_loss = eval_model(test_data_loader, global_step, device, model, disc)\n\n                    if average_sync_loss < .75:\n                        hparams.set_hparam('syncnet_wt', 0.03)\n\n            prog_bar.set_description('L1: {}, Sync: {}, Percep: {} | Fake: {}, Real: {}'.format(running_l1_loss / (step + 1),\n                                                                                        running_sync_loss / (step + 1),\n                                                                                        running_perceptual_loss / (step + 1),\n                                                                                        running_disc_fake_loss / (step + 1),\n                                                                                        running_disc_real_loss / (step + 1)))\n\n        global_epoch += 1\n\ndef eval_model(test_data_loader, global_step, device, model, disc):\n    eval_steps = 300\n    print('Evaluating for {} steps'.format(eval_steps))\n    running_sync_loss, running_l1_loss, running_disc_real_loss, running_disc_fake_loss, running_perceptual_loss = [], [], [], [], []\n    while 1:\n        for step, (x, indiv_mels, mel, gt) in enumerate((test_data_loader)):\n            model.eval()\n            disc.eval()\n\n            x = x.to(device)\n            mel = mel.to(device)\n            indiv_mels = indiv_mels.to(device)\n            gt = gt.to(device)\n\n            pred = disc(gt)\n            disc_real_loss = F.binary_cross_entropy(pred, torch.ones((len(pred), 1)).to(device))\n\n            g = model(indiv_mels, x)\n            pred = disc(g)\n            disc_fake_loss = F.binary_cross_entropy(pred, torch.zeros((len(pred), 1)).to(device))\n\n            running_disc_real_loss.append(disc_real_loss.item())\n            running_disc_fake_loss.append(disc_fake_loss.item())\n\n            sync_loss = get_sync_loss(mel, g)\n            \n            if hparams.disc_wt > 0.:\n                perceptual_loss = disc.perceptual_forward(g)\n            else:\n                perceptual_loss = 0.\n\n            l1loss = recon_loss(g, gt)\n\n            loss = hparams.syncnet_wt * sync_loss + hparams.disc_wt * perceptual_loss + \\\n                                    (1. - hparams.syncnet_wt - hparams.disc_wt) * l1loss\n\n            running_l1_loss.append(l1loss.item())\n            running_sync_loss.append(sync_loss.item())\n            \n            if hparams.disc_wt > 0.:\n                running_perceptual_loss.append(perceptual_loss.item())\n            else:\n                running_perceptual_loss.append(0.)\n\n            if step > eval_steps: break\n\n        print('L1: {}, Sync: {}, Percep: {} | Fake: {}, Real: {}'.format(sum(running_l1_loss) / len(running_l1_loss),\n                                                            sum(running_sync_loss) / len(running_sync_loss),\n                                                            sum(running_perceptual_loss) / len(running_perceptual_loss),\n                                                            sum(running_disc_fake_loss) / len(running_disc_fake_loss),\n                                                             sum(running_disc_real_loss) / len(running_disc_real_loss)))\n        return sum(running_sync_loss) / len(running_sync_loss)\n\n\ndef save_checkpoint(model, optimizer, step, checkpoint_dir, epoch, prefix=''):\n    checkpoint_path = join(\n        checkpoint_dir, \"{}checkpoint_step{:09d}.pth\".format(prefix, global_step))\n    optimizer_state = optimizer.state_dict() if hparams.save_optimizer_state else None\n    torch.save({\n        \"state_dict\": model.state_dict(),\n        \"optimizer\": optimizer_state,\n        \"global_step\": step,\n        \"global_epoch\": epoch,\n    }, checkpoint_path)\n    print(\"Saved checkpoint:\", checkpoint_path)\n\ndef _load(checkpoint_path):\n    if use_cuda:\n        checkpoint = torch.load(checkpoint_path)\n    else:\n        checkpoint = torch.load(checkpoint_path,\n                                map_location=lambda storage, loc: storage)\n    return checkpoint\n\n\ndef load_checkpoint(path, model, optimizer, reset_optimizer=False, overwrite_global_states=True):\n    global global_step\n    global global_epoch\n\n    print(\"Load checkpoint from: {}\".format(path))\n    checkpoint = _load(path)\n    s = checkpoint[\"state_dict\"]\n    new_s = {}\n    for k, v in s.items():\n        new_s[k.replace('module.', '')] = v\n    model.load_state_dict(new_s)\n    if not reset_optimizer:\n        optimizer_state = checkpoint[\"optimizer\"]\n        if optimizer_state is not None:\n            print(\"Load optimizer state from {}\".format(path))\n            optimizer.load_state_dict(checkpoint[\"optimizer\"])\n    if overwrite_global_states:\n        global_step = checkpoint[\"global_step\"]\n        global_epoch = checkpoint[\"global_epoch\"]\n\n    return model\n\nif __name__ == \"__main__\":\n    checkpoint_dir = args.checkpoint_dir\n\n    # Dataset and Dataloader setup\n    train_dataset = Dataset('train')\n    test_dataset = Dataset('val')\n\n    train_data_loader = data_utils.DataLoader(\n        train_dataset, batch_size=hparams.batch_size, shuffle=True,\n        num_workers=hparams.num_workers)\n\n    test_data_loader = data_utils.DataLoader(\n        test_dataset, batch_size=hparams.batch_size,\n        num_workers=4)\n\n    device = torch.device(\"cuda\" if use_cuda else \"cpu\")\n\n     # Model\n    model = Wav2Lip().to(device)\n    disc = Wav2Lip_disc_qual().to(device)\n\n    print('total trainable params {}'.format(sum(p.numel() for p in model.parameters() if p.requires_grad)))\n    print('total DISC trainable params {}'.format(sum(p.numel() for p in disc.parameters() if p.requires_grad)))\n\n    optimizer = optim.Adam([p for p in model.parameters() if p.requires_grad],\n                           lr=hparams.initial_learning_rate, betas=(0.5, 0.999))\n    disc_optimizer = optim.Adam([p for p in disc.parameters() if p.requires_grad],\n                           lr=hparams.disc_initial_learning_rate, betas=(0.5, 0.999))\n\n    if args.checkpoint_path is not None:\n        load_checkpoint(args.checkpoint_path, model, optimizer, reset_optimizer=False)\n\n    if args.disc_checkpoint_path is not None:\n        load_checkpoint(args.disc_checkpoint_path, disc, disc_optimizer, \n                                reset_optimizer=False, overwrite_global_states=False)\n        \n    load_checkpoint(args.syncnet_checkpoint_path, syncnet, None, reset_optimizer=True, \n                                overwrite_global_states=False)\n\n    if not os.path.exists(checkpoint_dir):\n        os.mkdir(checkpoint_dir)\n\n    # Train!\n    train(device, model, disc, train_data_loader, test_data_loader, optimizer, disc_optimizer,\n              checkpoint_dir=checkpoint_dir,\n              checkpoint_interval=hparams.checkpoint_interval,\n              nepochs=hparams.nepochs)\n"
        },
        {
          "name": "inference.py",
          "type": "blob",
          "size": 9.521484375,
          "content": "from os import listdir, path\nimport numpy as np\nimport scipy, cv2, os, sys, argparse, audio\nimport json, subprocess, random, string\nfrom tqdm import tqdm\nfrom glob import glob\nimport torch, face_detection\nfrom models import Wav2Lip\nimport platform\n\nparser = argparse.ArgumentParser(description='Inference code to lip-sync videos in the wild using Wav2Lip models')\n\nparser.add_argument('--checkpoint_path', type=str, \n\t\t\t\t\thelp='Name of saved checkpoint to load weights from', required=True)\n\nparser.add_argument('--face', type=str, \n\t\t\t\t\thelp='Filepath of video/image that contains faces to use', required=True)\nparser.add_argument('--audio', type=str, \n\t\t\t\t\thelp='Filepath of video/audio file to use as raw audio source', required=True)\nparser.add_argument('--outfile', type=str, help='Video path to save result. See default for an e.g.', \n\t\t\t\t\t\t\t\tdefault='results/result_voice.mp4')\n\nparser.add_argument('--static', type=bool, \n\t\t\t\t\thelp='If True, then use only first video frame for inference', default=False)\nparser.add_argument('--fps', type=float, help='Can be specified only if input is a static image (default: 25)', \n\t\t\t\t\tdefault=25., required=False)\n\nparser.add_argument('--pads', nargs='+', type=int, default=[0, 10, 0, 0], \n\t\t\t\t\thelp='Padding (top, bottom, left, right). Please adjust to include chin at least')\n\nparser.add_argument('--face_det_batch_size', type=int, \n\t\t\t\t\thelp='Batch size for face detection', default=16)\nparser.add_argument('--wav2lip_batch_size', type=int, help='Batch size for Wav2Lip model(s)', default=128)\n\nparser.add_argument('--resize_factor', default=1, type=int, \n\t\t\thelp='Reduce the resolution by this factor. Sometimes, best results are obtained at 480p or 720p')\n\nparser.add_argument('--crop', nargs='+', type=int, default=[0, -1, 0, -1], \n\t\t\t\t\thelp='Crop video to a smaller region (top, bottom, left, right). Applied after resize_factor and rotate arg. ' \n\t\t\t\t\t'Useful if multiple face present. -1 implies the value will be auto-inferred based on height, width')\n\nparser.add_argument('--box', nargs='+', type=int, default=[-1, -1, -1, -1], \n\t\t\t\t\thelp='Specify a constant bounding box for the face. Use only as a last resort if the face is not detected.'\n\t\t\t\t\t'Also, might work only if the face is not moving around much. Syntax: (top, bottom, left, right).')\n\nparser.add_argument('--rotate', default=False, action='store_true',\n\t\t\t\t\thelp='Sometimes videos taken from a phone can be flipped 90deg. If true, will flip video right by 90deg.'\n\t\t\t\t\t'Use if you get a flipped result, despite feeding a normal looking video')\n\nparser.add_argument('--nosmooth', default=False, action='store_true',\n\t\t\t\t\thelp='Prevent smoothing face detections over a short temporal window')\n\nargs = parser.parse_args()\nargs.img_size = 96\n\nif os.path.isfile(args.face) and args.face.split('.')[1] in ['jpg', 'png', 'jpeg']:\n\targs.static = True\n\ndef get_smoothened_boxes(boxes, T):\n\tfor i in range(len(boxes)):\n\t\tif i + T > len(boxes):\n\t\t\twindow = boxes[len(boxes) - T:]\n\t\telse:\n\t\t\twindow = boxes[i : i + T]\n\t\tboxes[i] = np.mean(window, axis=0)\n\treturn boxes\n\ndef face_detect(images):\n\tdetector = face_detection.FaceAlignment(face_detection.LandmarksType._2D, \n\t\t\t\t\t\t\t\t\t\t\tflip_input=False, device=device)\n\n\tbatch_size = args.face_det_batch_size\n\t\n\twhile 1:\n\t\tpredictions = []\n\t\ttry:\n\t\t\tfor i in tqdm(range(0, len(images), batch_size)):\n\t\t\t\tpredictions.extend(detector.get_detections_for_batch(np.array(images[i:i + batch_size])))\n\t\texcept RuntimeError:\n\t\t\tif batch_size == 1: \n\t\t\t\traise RuntimeError('Image too big to run face detection on GPU. Please use the --resize_factor argument')\n\t\t\tbatch_size //= 2\n\t\t\tprint('Recovering from OOM error; New batch size: {}'.format(batch_size))\n\t\t\tcontinue\n\t\tbreak\n\n\tresults = []\n\tpady1, pady2, padx1, padx2 = args.pads\n\tfor rect, image in zip(predictions, images):\n\t\tif rect is None:\n\t\t\tcv2.imwrite('temp/faulty_frame.jpg', image) # check this frame where the face was not detected.\n\t\t\traise ValueError('Face not detected! Ensure the video contains a face in all the frames.')\n\n\t\ty1 = max(0, rect[1] - pady1)\n\t\ty2 = min(image.shape[0], rect[3] + pady2)\n\t\tx1 = max(0, rect[0] - padx1)\n\t\tx2 = min(image.shape[1], rect[2] + padx2)\n\t\t\n\t\tresults.append([x1, y1, x2, y2])\n\n\tboxes = np.array(results)\n\tif not args.nosmooth: boxes = get_smoothened_boxes(boxes, T=5)\n\tresults = [[image[y1: y2, x1:x2], (y1, y2, x1, x2)] for image, (x1, y1, x2, y2) in zip(images, boxes)]\n\n\tdel detector\n\treturn results \n\ndef datagen(frames, mels):\n\timg_batch, mel_batch, frame_batch, coords_batch = [], [], [], []\n\n\tif args.box[0] == -1:\n\t\tif not args.static:\n\t\t\tface_det_results = face_detect(frames) # BGR2RGB for CNN face detection\n\t\telse:\n\t\t\tface_det_results = face_detect([frames[0]])\n\telse:\n\t\tprint('Using the specified bounding box instead of face detection...')\n\t\ty1, y2, x1, x2 = args.box\n\t\tface_det_results = [[f[y1: y2, x1:x2], (y1, y2, x1, x2)] for f in frames]\n\n\tfor i, m in enumerate(mels):\n\t\tidx = 0 if args.static else i%len(frames)\n\t\tframe_to_save = frames[idx].copy()\n\t\tface, coords = face_det_results[idx].copy()\n\n\t\tface = cv2.resize(face, (args.img_size, args.img_size))\n\t\t\t\n\t\timg_batch.append(face)\n\t\tmel_batch.append(m)\n\t\tframe_batch.append(frame_to_save)\n\t\tcoords_batch.append(coords)\n\n\t\tif len(img_batch) >= args.wav2lip_batch_size:\n\t\t\timg_batch, mel_batch = np.asarray(img_batch), np.asarray(mel_batch)\n\n\t\t\timg_masked = img_batch.copy()\n\t\t\timg_masked[:, args.img_size//2:] = 0\n\n\t\t\timg_batch = np.concatenate((img_masked, img_batch), axis=3) / 255.\n\t\t\tmel_batch = np.reshape(mel_batch, [len(mel_batch), mel_batch.shape[1], mel_batch.shape[2], 1])\n\n\t\t\tyield img_batch, mel_batch, frame_batch, coords_batch\n\t\t\timg_batch, mel_batch, frame_batch, coords_batch = [], [], [], []\n\n\tif len(img_batch) > 0:\n\t\timg_batch, mel_batch = np.asarray(img_batch), np.asarray(mel_batch)\n\n\t\timg_masked = img_batch.copy()\n\t\timg_masked[:, args.img_size//2:] = 0\n\n\t\timg_batch = np.concatenate((img_masked, img_batch), axis=3) / 255.\n\t\tmel_batch = np.reshape(mel_batch, [len(mel_batch), mel_batch.shape[1], mel_batch.shape[2], 1])\n\n\t\tyield img_batch, mel_batch, frame_batch, coords_batch\n\nmel_step_size = 16\ndevice = 'cuda' if torch.cuda.is_available() else 'cpu'\nprint('Using {} for inference.'.format(device))\n\ndef _load(checkpoint_path):\n\tif device == 'cuda':\n\t\tcheckpoint = torch.load(checkpoint_path)\n\telse:\n\t\tcheckpoint = torch.load(checkpoint_path,\n\t\t\t\t\t\t\t\tmap_location=lambda storage, loc: storage)\n\treturn checkpoint\n\ndef load_model(path):\n\tmodel = Wav2Lip()\n\tprint(\"Load checkpoint from: {}\".format(path))\n\tcheckpoint = _load(path)\n\ts = checkpoint[\"state_dict\"]\n\tnew_s = {}\n\tfor k, v in s.items():\n\t\tnew_s[k.replace('module.', '')] = v\n\tmodel.load_state_dict(new_s)\n\n\tmodel = model.to(device)\n\treturn model.eval()\n\ndef main():\n\tif not os.path.isfile(args.face):\n\t\traise ValueError('--face argument must be a valid path to video/image file')\n\n\telif args.face.split('.')[1] in ['jpg', 'png', 'jpeg']:\n\t\tfull_frames = [cv2.imread(args.face)]\n\t\tfps = args.fps\n\n\telse:\n\t\tvideo_stream = cv2.VideoCapture(args.face)\n\t\tfps = video_stream.get(cv2.CAP_PROP_FPS)\n\n\t\tprint('Reading video frames...')\n\n\t\tfull_frames = []\n\t\twhile 1:\n\t\t\tstill_reading, frame = video_stream.read()\n\t\t\tif not still_reading:\n\t\t\t\tvideo_stream.release()\n\t\t\t\tbreak\n\t\t\tif args.resize_factor > 1:\n\t\t\t\tframe = cv2.resize(frame, (frame.shape[1]//args.resize_factor, frame.shape[0]//args.resize_factor))\n\n\t\t\tif args.rotate:\n\t\t\t\tframe = cv2.rotate(frame, cv2.cv2.ROTATE_90_CLOCKWISE)\n\n\t\t\ty1, y2, x1, x2 = args.crop\n\t\t\tif x2 == -1: x2 = frame.shape[1]\n\t\t\tif y2 == -1: y2 = frame.shape[0]\n\n\t\t\tframe = frame[y1:y2, x1:x2]\n\n\t\t\tfull_frames.append(frame)\n\n\tprint (\"Number of frames available for inference: \"+str(len(full_frames)))\n\n\tif not args.audio.endswith('.wav'):\n\t\tprint('Extracting raw audio...')\n\t\tcommand = 'ffmpeg -y -i {} -strict -2 {}'.format(args.audio, 'temp/temp.wav')\n\n\t\tsubprocess.call(command, shell=True)\n\t\targs.audio = 'temp/temp.wav'\n\n\twav = audio.load_wav(args.audio, 16000)\n\tmel = audio.melspectrogram(wav)\n\tprint(mel.shape)\n\n\tif np.isnan(mel.reshape(-1)).sum() > 0:\n\t\traise ValueError('Mel contains nan! Using a TTS voice? Add a small epsilon noise to the wav file and try again')\n\n\tmel_chunks = []\n\tmel_idx_multiplier = 80./fps \n\ti = 0\n\twhile 1:\n\t\tstart_idx = int(i * mel_idx_multiplier)\n\t\tif start_idx + mel_step_size > len(mel[0]):\n\t\t\tmel_chunks.append(mel[:, len(mel[0]) - mel_step_size:])\n\t\t\tbreak\n\t\tmel_chunks.append(mel[:, start_idx : start_idx + mel_step_size])\n\t\ti += 1\n\n\tprint(\"Length of mel chunks: {}\".format(len(mel_chunks)))\n\n\tfull_frames = full_frames[:len(mel_chunks)]\n\n\tbatch_size = args.wav2lip_batch_size\n\tgen = datagen(full_frames.copy(), mel_chunks)\n\n\tfor i, (img_batch, mel_batch, frames, coords) in enumerate(tqdm(gen, \n\t\t\t\t\t\t\t\t\t\t\ttotal=int(np.ceil(float(len(mel_chunks))/batch_size)))):\n\t\tif i == 0:\n\t\t\tmodel = load_model(args.checkpoint_path)\n\t\t\tprint (\"Model loaded\")\n\n\t\t\tframe_h, frame_w = full_frames[0].shape[:-1]\n\t\t\tout = cv2.VideoWriter('temp/result.avi', \n\t\t\t\t\t\t\t\t\tcv2.VideoWriter_fourcc(*'DIVX'), fps, (frame_w, frame_h))\n\n\t\timg_batch = torch.FloatTensor(np.transpose(img_batch, (0, 3, 1, 2))).to(device)\n\t\tmel_batch = torch.FloatTensor(np.transpose(mel_batch, (0, 3, 1, 2))).to(device)\n\n\t\twith torch.no_grad():\n\t\t\tpred = model(mel_batch, img_batch)\n\n\t\tpred = pred.cpu().numpy().transpose(0, 2, 3, 1) * 255.\n\t\t\n\t\tfor p, f, c in zip(pred, frames, coords):\n\t\t\ty1, y2, x1, x2 = c\n\t\t\tp = cv2.resize(p.astype(np.uint8), (x2 - x1, y2 - y1))\n\n\t\t\tf[y1:y2, x1:x2] = p\n\t\t\tout.write(f)\n\n\tout.release()\n\n\tcommand = 'ffmpeg -y -i {} -i {} -strict -2 -q:v 1 {}'.format(args.audio, 'temp/result.avi', args.outfile)\n\tsubprocess.call(command, shell=platform.system() != 'Windows')\n\nif __name__ == '__main__':\n\tmain()\n"
        },
        {
          "name": "models",
          "type": "tree",
          "content": null
        },
        {
          "name": "preprocess.py",
          "type": "blob",
          "size": 3.25,
          "content": "import sys\n\nif sys.version_info[0] < 3 and sys.version_info[1] < 2:\n\traise Exception(\"Must be using >= Python 3.2\")\n\nfrom os import listdir, path\n\nif not path.isfile('face_detection/detection/sfd/s3fd.pth'):\n\traise FileNotFoundError('Save the s3fd model to face_detection/detection/sfd/s3fd.pth \\\n\t\t\t\t\t\t\tbefore running this script!')\n\nimport multiprocessing as mp\nfrom concurrent.futures import ThreadPoolExecutor, as_completed\nimport numpy as np\nimport argparse, os, cv2, traceback, subprocess\nfrom tqdm import tqdm\nfrom glob import glob\nimport audio\nfrom hparams import hparams as hp\n\nimport face_detection\n\nparser = argparse.ArgumentParser()\n\nparser.add_argument('--ngpu', help='Number of GPUs across which to run in parallel', default=1, type=int)\nparser.add_argument('--batch_size', help='Single GPU Face detection batch size', default=32, type=int)\nparser.add_argument(\"--data_root\", help=\"Root folder of the LRS2 dataset\", required=True)\nparser.add_argument(\"--preprocessed_root\", help=\"Root folder of the preprocessed dataset\", required=True)\n\nargs = parser.parse_args()\n\nfa = [face_detection.FaceAlignment(face_detection.LandmarksType._2D, flip_input=False, \n\t\t\t\t\t\t\t\t\tdevice='cuda:{}'.format(id)) for id in range(args.ngpu)]\n\ntemplate = 'ffmpeg -loglevel panic -y -i {} -strict -2 {}'\n# template2 = 'ffmpeg -hide_banner -loglevel panic -threads 1 -y -i {} -async 1 -ac 1 -vn -acodec pcm_s16le -ar 16000 {}'\n\ndef process_video_file(vfile, args, gpu_id):\n\tvideo_stream = cv2.VideoCapture(vfile)\n\t\n\tframes = []\n\twhile 1:\n\t\tstill_reading, frame = video_stream.read()\n\t\tif not still_reading:\n\t\t\tvideo_stream.release()\n\t\t\tbreak\n\t\tframes.append(frame)\n\t\n\tvidname = os.path.basename(vfile).split('.')[0]\n\tdirname = vfile.split('/')[-2]\n\n\tfulldir = path.join(args.preprocessed_root, dirname, vidname)\n\tos.makedirs(fulldir, exist_ok=True)\n\n\tbatches = [frames[i:i + args.batch_size] for i in range(0, len(frames), args.batch_size)]\n\n\ti = -1\n\tfor fb in batches:\n\t\tpreds = fa[gpu_id].get_detections_for_batch(np.asarray(fb))\n\n\t\tfor j, f in enumerate(preds):\n\t\t\ti += 1\n\t\t\tif f is None:\n\t\t\t\tcontinue\n\n\t\t\tx1, y1, x2, y2 = f\n\t\t\tcv2.imwrite(path.join(fulldir, '{}.jpg'.format(i)), fb[j][y1:y2, x1:x2])\n\ndef process_audio_file(vfile, args):\n\tvidname = os.path.basename(vfile).split('.')[0]\n\tdirname = vfile.split('/')[-2]\n\n\tfulldir = path.join(args.preprocessed_root, dirname, vidname)\n\tos.makedirs(fulldir, exist_ok=True)\n\n\twavpath = path.join(fulldir, 'audio.wav')\n\n\tcommand = template.format(vfile, wavpath)\n\tsubprocess.call(command, shell=True)\n\n\t\ndef mp_handler(job):\n\tvfile, args, gpu_id = job\n\ttry:\n\t\tprocess_video_file(vfile, args, gpu_id)\n\texcept KeyboardInterrupt:\n\t\texit(0)\n\texcept:\n\t\ttraceback.print_exc()\n\t\t\ndef main(args):\n\tprint('Started processing for {} with {} GPUs'.format(args.data_root, args.ngpu))\n\n\tfilelist = glob(path.join(args.data_root, '*/*.mp4'))\n\n\tjobs = [(vfile, args, i%args.ngpu) for i, vfile in enumerate(filelist)]\n\tp = ThreadPoolExecutor(args.ngpu)\n\tfutures = [p.submit(mp_handler, j) for j in jobs]\n\t_ = [r.result() for r in tqdm(as_completed(futures), total=len(futures))]\n\n\tprint('Dumping audios...')\n\n\tfor vfile in tqdm(filelist):\n\t\ttry:\n\t\t\tprocess_audio_file(vfile, args)\n\t\texcept KeyboardInterrupt:\n\t\t\texit(0)\n\t\texcept:\n\t\t\ttraceback.print_exc()\n\t\t\tcontinue\n\nif __name__ == '__main__':\n\tmain(args)"
        },
        {
          "name": "requirements.txt",
          "type": "blob",
          "size": 0.138671875,
          "content": "librosa==0.7.0\nnumpy==1.17.1\nopencv-contrib-python>=4.2.0.34\nopencv-python==4.1.0.25\ntorch==1.1.0\ntorchvision==0.3.0\ntqdm==4.45.0\nnumba==0.48\n"
        },
        {
          "name": "results",
          "type": "tree",
          "content": null
        },
        {
          "name": "temp",
          "type": "tree",
          "content": null
        },
        {
          "name": "wav2lip_train.py",
          "type": "blob",
          "size": 12.615234375,
          "content": "from os.path import dirname, join, basename, isfile\nfrom tqdm import tqdm\n\nfrom models import SyncNet_color as SyncNet\nfrom models import Wav2Lip as Wav2Lip\nimport audio\n\nimport torch\nfrom torch import nn\nfrom torch import optim\nimport torch.backends.cudnn as cudnn\nfrom torch.utils import data as data_utils\nimport numpy as np\n\nfrom glob import glob\n\nimport os, random, cv2, argparse\nfrom hparams import hparams, get_image_list\n\nparser = argparse.ArgumentParser(description='Code to train the Wav2Lip model without the visual quality discriminator')\n\nparser.add_argument(\"--data_root\", help=\"Root folder of the preprocessed LRS2 dataset\", required=True, type=str)\n\nparser.add_argument('--checkpoint_dir', help='Save checkpoints to this directory', required=True, type=str)\nparser.add_argument('--syncnet_checkpoint_path', help='Load the pre-trained Expert discriminator', required=True, type=str)\n\nparser.add_argument('--checkpoint_path', help='Resume from this checkpoint', default=None, type=str)\n\nargs = parser.parse_args()\n\n\nglobal_step = 0\nglobal_epoch = 0\nuse_cuda = torch.cuda.is_available()\nprint('use_cuda: {}'.format(use_cuda))\n\nsyncnet_T = 5\nsyncnet_mel_step_size = 16\n\nclass Dataset(object):\n    def __init__(self, split):\n        self.all_videos = get_image_list(args.data_root, split)\n\n    def get_frame_id(self, frame):\n        return int(basename(frame).split('.')[0])\n\n    def get_window(self, start_frame):\n        start_id = self.get_frame_id(start_frame)\n        vidname = dirname(start_frame)\n\n        window_fnames = []\n        for frame_id in range(start_id, start_id + syncnet_T):\n            frame = join(vidname, '{}.jpg'.format(frame_id))\n            if not isfile(frame):\n                return None\n            window_fnames.append(frame)\n        return window_fnames\n\n    def read_window(self, window_fnames):\n        if window_fnames is None: return None\n        window = []\n        for fname in window_fnames:\n            img = cv2.imread(fname)\n            if img is None:\n                return None\n            try:\n                img = cv2.resize(img, (hparams.img_size, hparams.img_size))\n            except Exception as e:\n                return None\n\n            window.append(img)\n\n        return window\n\n    def crop_audio_window(self, spec, start_frame):\n        if type(start_frame) == int:\n            start_frame_num = start_frame\n        else:\n            start_frame_num = self.get_frame_id(start_frame) # 0-indexing ---> 1-indexing\n        start_idx = int(80. * (start_frame_num / float(hparams.fps)))\n        \n        end_idx = start_idx + syncnet_mel_step_size\n\n        return spec[start_idx : end_idx, :]\n\n    def get_segmented_mels(self, spec, start_frame):\n        mels = []\n        assert syncnet_T == 5\n        start_frame_num = self.get_frame_id(start_frame) + 1 # 0-indexing ---> 1-indexing\n        if start_frame_num - 2 < 0: return None\n        for i in range(start_frame_num, start_frame_num + syncnet_T):\n            m = self.crop_audio_window(spec, i - 2)\n            if m.shape[0] != syncnet_mel_step_size:\n                return None\n            mels.append(m.T)\n\n        mels = np.asarray(mels)\n\n        return mels\n\n    def prepare_window(self, window):\n        # 3 x T x H x W\n        x = np.asarray(window) / 255.\n        x = np.transpose(x, (3, 0, 1, 2))\n\n        return x\n\n    def __len__(self):\n        return len(self.all_videos)\n\n    def __getitem__(self, idx):\n        while 1:\n            idx = random.randint(0, len(self.all_videos) - 1)\n            vidname = self.all_videos[idx]\n            img_names = list(glob(join(vidname, '*.jpg')))\n            if len(img_names) <= 3 * syncnet_T:\n                continue\n            \n            img_name = random.choice(img_names)\n            wrong_img_name = random.choice(img_names)\n            while wrong_img_name == img_name:\n                wrong_img_name = random.choice(img_names)\n\n            window_fnames = self.get_window(img_name)\n            wrong_window_fnames = self.get_window(wrong_img_name)\n            if window_fnames is None or wrong_window_fnames is None:\n                continue\n\n            window = self.read_window(window_fnames)\n            if window is None:\n                continue\n\n            wrong_window = self.read_window(wrong_window_fnames)\n            if wrong_window is None:\n                continue\n\n            try:\n                wavpath = join(vidname, \"audio.wav\")\n                wav = audio.load_wav(wavpath, hparams.sample_rate)\n\n                orig_mel = audio.melspectrogram(wav).T\n            except Exception as e:\n                continue\n\n            mel = self.crop_audio_window(orig_mel.copy(), img_name)\n            \n            if (mel.shape[0] != syncnet_mel_step_size):\n                continue\n\n            indiv_mels = self.get_segmented_mels(orig_mel.copy(), img_name)\n            if indiv_mels is None: continue\n\n            window = self.prepare_window(window)\n            y = window.copy()\n            window[:, :, window.shape[2]//2:] = 0.\n\n            wrong_window = self.prepare_window(wrong_window)\n            x = np.concatenate([window, wrong_window], axis=0)\n\n            x = torch.FloatTensor(x)\n            mel = torch.FloatTensor(mel.T).unsqueeze(0)\n            indiv_mels = torch.FloatTensor(indiv_mels).unsqueeze(1)\n            y = torch.FloatTensor(y)\n            return x, indiv_mels, mel, y\n\ndef save_sample_images(x, g, gt, global_step, checkpoint_dir):\n    x = (x.detach().cpu().numpy().transpose(0, 2, 3, 4, 1) * 255.).astype(np.uint8)\n    g = (g.detach().cpu().numpy().transpose(0, 2, 3, 4, 1) * 255.).astype(np.uint8)\n    gt = (gt.detach().cpu().numpy().transpose(0, 2, 3, 4, 1) * 255.).astype(np.uint8)\n\n    refs, inps = x[..., 3:], x[..., :3]\n    folder = join(checkpoint_dir, \"samples_step{:09d}\".format(global_step))\n    if not os.path.exists(folder): os.mkdir(folder)\n    collage = np.concatenate((refs, inps, g, gt), axis=-2)\n    for batch_idx, c in enumerate(collage):\n        for t in range(len(c)):\n            cv2.imwrite('{}/{}_{}.jpg'.format(folder, batch_idx, t), c[t])\n\nlogloss = nn.BCELoss()\ndef cosine_loss(a, v, y):\n    d = nn.functional.cosine_similarity(a, v)\n    loss = logloss(d.unsqueeze(1), y)\n\n    return loss\n\ndevice = torch.device(\"cuda\" if use_cuda else \"cpu\")\nsyncnet = SyncNet().to(device)\nfor p in syncnet.parameters():\n    p.requires_grad = False\n\nrecon_loss = nn.L1Loss()\ndef get_sync_loss(mel, g):\n    g = g[:, :, :, g.size(3)//2:]\n    g = torch.cat([g[:, :, i] for i in range(syncnet_T)], dim=1)\n    # B, 3 * T, H//2, W\n    a, v = syncnet(mel, g)\n    y = torch.ones(g.size(0), 1).float().to(device)\n    return cosine_loss(a, v, y)\n\ndef train(device, model, train_data_loader, test_data_loader, optimizer,\n          checkpoint_dir=None, checkpoint_interval=None, nepochs=None):\n\n    global global_step, global_epoch\n    resumed_step = global_step\n \n    while global_epoch < nepochs:\n        print('Starting Epoch: {}'.format(global_epoch))\n        running_sync_loss, running_l1_loss = 0., 0.\n        prog_bar = tqdm(enumerate(train_data_loader))\n        for step, (x, indiv_mels, mel, gt) in prog_bar:\n            model.train()\n            optimizer.zero_grad()\n\n            # Move data to CUDA device\n            x = x.to(device)\n            mel = mel.to(device)\n            indiv_mels = indiv_mels.to(device)\n            gt = gt.to(device)\n\n            g = model(indiv_mels, x)\n\n            if hparams.syncnet_wt > 0.:\n                sync_loss = get_sync_loss(mel, g)\n            else:\n                sync_loss = 0.\n\n            l1loss = recon_loss(g, gt)\n\n            loss = hparams.syncnet_wt * sync_loss + (1 - hparams.syncnet_wt) * l1loss\n            loss.backward()\n            optimizer.step()\n\n            if global_step % checkpoint_interval == 0:\n                save_sample_images(x, g, gt, global_step, checkpoint_dir)\n\n            global_step += 1\n            cur_session_steps = global_step - resumed_step\n\n            running_l1_loss += l1loss.item()\n            if hparams.syncnet_wt > 0.:\n                running_sync_loss += sync_loss.item()\n            else:\n                running_sync_loss += 0.\n\n            if global_step == 1 or global_step % checkpoint_interval == 0:\n                save_checkpoint(\n                    model, optimizer, global_step, checkpoint_dir, global_epoch)\n\n            if global_step == 1 or global_step % hparams.eval_interval == 0:\n                with torch.no_grad():\n                    average_sync_loss = eval_model(test_data_loader, global_step, device, model, checkpoint_dir)\n\n                    if average_sync_loss < .75:\n                        hparams.set_hparam('syncnet_wt', 0.01) # without image GAN a lesser weight is sufficient\n\n            prog_bar.set_description('L1: {}, Sync Loss: {}'.format(running_l1_loss / (step + 1),\n                                                                    running_sync_loss / (step + 1)))\n\n        global_epoch += 1\n        \n\ndef eval_model(test_data_loader, global_step, device, model, checkpoint_dir):\n    eval_steps = 700\n    print('Evaluating for {} steps'.format(eval_steps))\n    sync_losses, recon_losses = [], []\n    step = 0\n    while 1:\n        for x, indiv_mels, mel, gt in test_data_loader:\n            step += 1\n            model.eval()\n\n            # Move data to CUDA device\n            x = x.to(device)\n            gt = gt.to(device)\n            indiv_mels = indiv_mels.to(device)\n            mel = mel.to(device)\n\n            g = model(indiv_mels, x)\n\n            sync_loss = get_sync_loss(mel, g)\n            l1loss = recon_loss(g, gt)\n\n            sync_losses.append(sync_loss.item())\n            recon_losses.append(l1loss.item())\n\n            if step > eval_steps: \n                averaged_sync_loss = sum(sync_losses) / len(sync_losses)\n                averaged_recon_loss = sum(recon_losses) / len(recon_losses)\n\n                print('L1: {}, Sync loss: {}'.format(averaged_recon_loss, averaged_sync_loss))\n\n                return averaged_sync_loss\n\ndef save_checkpoint(model, optimizer, step, checkpoint_dir, epoch):\n\n    checkpoint_path = join(\n        checkpoint_dir, \"checkpoint_step{:09d}.pth\".format(global_step))\n    optimizer_state = optimizer.state_dict() if hparams.save_optimizer_state else None\n    torch.save({\n        \"state_dict\": model.state_dict(),\n        \"optimizer\": optimizer_state,\n        \"global_step\": step,\n        \"global_epoch\": epoch,\n    }, checkpoint_path)\n    print(\"Saved checkpoint:\", checkpoint_path)\n\n\ndef _load(checkpoint_path):\n    if use_cuda:\n        checkpoint = torch.load(checkpoint_path)\n    else:\n        checkpoint = torch.load(checkpoint_path,\n                                map_location=lambda storage, loc: storage)\n    return checkpoint\n\ndef load_checkpoint(path, model, optimizer, reset_optimizer=False, overwrite_global_states=True):\n    global global_step\n    global global_epoch\n\n    print(\"Load checkpoint from: {}\".format(path))\n    checkpoint = _load(path)\n    s = checkpoint[\"state_dict\"]\n    new_s = {}\n    for k, v in s.items():\n        new_s[k.replace('module.', '')] = v\n    model.load_state_dict(new_s)\n    if not reset_optimizer:\n        optimizer_state = checkpoint[\"optimizer\"]\n        if optimizer_state is not None:\n            print(\"Load optimizer state from {}\".format(path))\n            optimizer.load_state_dict(checkpoint[\"optimizer\"])\n    if overwrite_global_states:\n        global_step = checkpoint[\"global_step\"]\n        global_epoch = checkpoint[\"global_epoch\"]\n\n    return model\n\nif __name__ == \"__main__\":\n    checkpoint_dir = args.checkpoint_dir\n\n    # Dataset and Dataloader setup\n    train_dataset = Dataset('train')\n    test_dataset = Dataset('val')\n\n    train_data_loader = data_utils.DataLoader(\n        train_dataset, batch_size=hparams.batch_size, shuffle=True,\n        num_workers=hparams.num_workers)\n\n    test_data_loader = data_utils.DataLoader(\n        test_dataset, batch_size=hparams.batch_size,\n        num_workers=4)\n\n    device = torch.device(\"cuda\" if use_cuda else \"cpu\")\n\n    # Model\n    model = Wav2Lip().to(device)\n    print('total trainable params {}'.format(sum(p.numel() for p in model.parameters() if p.requires_grad)))\n\n    optimizer = optim.Adam([p for p in model.parameters() if p.requires_grad],\n                           lr=hparams.initial_learning_rate)\n\n    if args.checkpoint_path is not None:\n        load_checkpoint(args.checkpoint_path, model, optimizer, reset_optimizer=False)\n        \n    load_checkpoint(args.syncnet_checkpoint_path, syncnet, None, reset_optimizer=True, overwrite_global_states=False)\n\n    if not os.path.exists(checkpoint_dir):\n        os.mkdir(checkpoint_dir)\n\n    # Train!\n    train(device, model, train_data_loader, test_data_loader, optimizer,\n              checkpoint_dir=checkpoint_dir,\n              checkpoint_interval=hparams.checkpoint_interval,\n              nepochs=hparams.nepochs)\n"
        }
      ]
    }
  ]
}