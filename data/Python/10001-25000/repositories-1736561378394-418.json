{
  "metadata": {
    "timestamp": 1736561378394,
    "page": 418,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "AIGC-Audio/AudioGPT",
      "stars": 10082,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 1.734375,
          "content": "# JetBrains PyCharm IDE\n.idea/\n.github/\n.circleci/\n\n# Byte-compiled / optimized / DLL files\n*__pycache__/\n__pycache__/\n*.py[cod]\n*$py.class\n\n# C extensions\n*.so\n\n# macOS dir files\n.DS_Store\n\n# Distribution / packaging\n.Python\nenv/\nbuild/\ndevelop-eggs/\ndist/\ndownloads/\neggs/\n.eggs/\nlib/\nlib64/\nparts/\nsdist/\nvar/\nwheels/\n*.egg-info/\n.installed.cfg\n*.egg\n\n# Checkpoints\ncheckpoints\n\n# PyInstaller\n#  Usually these files are written by a python script from a template\n#  before PyInstaller builds the exe, so as to inject date/other infos into it.\n*.manifest\n*.spec\n\n# Installer logs\npip-log.txt\npip-delete-this-directory.txt\n\n# Unit test / coverage reports\nhtmlcov/\n.tox/\n.coverage\n.coverage.*\n.cache\nnosetests.xml\ncoverage.xml\n*.cover\n.hypothesis/\n\n# Translations\n*.mo\n*.pot\n\n# Django stuff:\n*.log\nlocal_settings.py\n\n# Flask stuff:\ninstance/\n.webassets-cache\n\n# Scrapy stuff:\n.scrapy\n\n# Sphinx documentation\ndocs/_build/\n\n# PyBuilder\ntarget/\n\n# Jupyter Notebook\n.ipynb_checkpoints\n\n# pyenv\n.python-version\n\n# celery beat schedule file\ncelerybeat-schedule\n\n# SageMath parsed files\n*.sage.py\n\n# dotenv\n.env\n\n# virtualenv\n.venv\nvenv/\nENV/\n\n# Spyder project settings\n.spyderproject\n.spyproject\n\n# Rope project settings\n.ropeproject\n\n# mkdocs documentation\n/site\n\n# mypy\n.mypy_cache/\n\n# Generated files\n/fairseq/temporal_convolution_tbc\n/fairseq/modules/*_layer/*_forward.cu\n/fairseq/modules/*_layer/*_backward.cu\n/fairseq/version.py\n\n# data\ndata-bin/\n\n# reranking\n/examples/reranking/rerank_data\n\n# Cython-generated C++ source files\n/fairseq/data/data_utils_fast.cpp\n/fairseq/data/token_block_utils_fast.cpp\n\n# VSCODE\n.vscode/ftp-sync.json\n.vscode/settings.json\n\n# Experimental Folder\nexperimental/*\n\n# Weights and Biases logs\nwandb/\n\n# Hydra artifacts\nnohup.out\nmultirun\noutputs\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 0,
          "content": ""
        },
        {
          "name": "NeuralSeq",
          "type": "tree",
          "content": null
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 3.5517578125,
          "content": "# AudioGPT: Understanding and Generating Speech, Music, Sound, and Talking Head\n\n[![arXiv](https://img.shields.io/badge/arXiv-Paper-<COLOR>.svg)](https://arxiv.org/abs/2304.12995)\n[![GitHub Stars](https://img.shields.io/github/stars/AIGC-Audio/AudioGPT?style=social)](https://github.com/AIGC-Audio/AudioGPT)\n![visitors](https://visitor-badge.glitch.me/badge?page_id=AIGC-Audio.AudioGPT)\n[![Hugging Face](https://img.shields.io/badge/%F0%9F%A4%97%20Hugging%20Face-blue)](https://huggingface.co/spaces/AIGC-Audio/AudioGPT)\n\n\nWe provide our implementation and pretrained models as open source in this repository.\n\n\n## Get Started\n\nPlease refer to [run.md](run.md)\n\n\n## Capabilities\n\nHere we list the capability of AudioGPT at this time. More supported models and tasks are coming soon. For prompt examples, refer to [asset](assets/README.md).\n\nCurrently not every model has repository.\n### Speech\n|            Task            |   Supported Foundation Models   | Status |\n|:--------------------------:|:-------------------------------:|:------:|\n|       Text-to-Speech       | [FastSpeech](https://github.com/ming024/FastSpeech2), [SyntaSpeech](https://github.com/yerfor/SyntaSpeech), [VITS](https://github.com/jaywalnut310/vits) |  Yes (WIP)   |\n|       Style Transfer       |         [GenerSpeech](https://github.com/Rongjiehuang/GenerSpeech)         |  Yes   |\n|     Speech Recognition     |           [whisper](https://github.com/openai/whisper), [Conformer](https://github.com/sooftware/conformer)           |  Yes   |\n|     Speech Enhancement     |          [ConvTasNet]()         |  Yes (WIP)   |\n|     Speech Separation      |          [TF-GridNet](https://arxiv.org/pdf/2211.12433.pdf)         |  Yes (WIP)   |\n|     Speech Translation     |          [Multi-decoder](https://arxiv.org/pdf/2109.12804.pdf)      |  WIP   |\n|      Mono-to-Binaural      |          [NeuralWarp](https://github.com/fdarmon/NeuralWarp)         |  Yes   |\n\n### Sing\n\n|           Task            |   Supported Foundation Models   | Status |\n|:-------------------------:|:-------------------------------:|:------:|\n|       Text-to-Sing        |         [DiffSinger](https://github.com/MoonInTheRiver/DiffSinger), [VISinger](https://github.com/jerryuhoo/VISinger)          |  Yes (WIP)   |\n\n### Audio\n|          Task          | Supported Foundation Models | Status |\n|:----------------------:|:---------------------------:|:------:|\n|     Text-to-Audio      |      [Make-An-Audio]()      |  Yes   |\n|    Audio Inpainting    |      [Make-An-Audio]()      |  Yes   |\n|     Image-to-Audio     |      [Make-An-Audio]()      |  Yes   |\n|    Sound Detection     |    [Audio-transformer](https://github.com/RetroCirce/HTS-Audio-Transformer)    | Yes    |\n| Target Sound Detection |    [TSDNet](https://github.com/gy65896/TSDNet)    |  Yes   |\n|    Sound Extraction    |    [LASSNet](https://github.com/liuxubo717/LASS)    |  Yes   |\n\n\n### Talking Head\n\n|           Task            |   Supported Foundation Models   |   Status   |\n|:-------------------------:|:-------------------------------:|:----------:|\n|  Talking Head Synthesis   |          [GeneFace](https://github.com/yerfor/GeneFace)           | Yes (WIP)  |\n\n\n## Acknowledgement\nWe appreciate the open source of the following projects:\n\n[ESPNet](https://github.com/espnet/espnet) &#8194;\n[NATSpeech](https://github.com/NATSpeech/NATSpeech) &#8194;\n[Visual ChatGPT](https://github.com/microsoft/visual-chatgpt) &#8194;\n[Hugging Face](https://github.com/huggingface) &#8194;\n[LangChain](https://github.com/hwchase17/langchain) &#8194;\n[Stable Diffusion](https://github.com/CompVis/stable-diffusion) &#8194;\n\n"
        },
        {
          "name": "assets",
          "type": "tree",
          "content": null
        },
        {
          "name": "audio-chatgpt.py",
          "type": "blob",
          "size": 77.1318359375,
          "content": "import sys\nimport os\nsys.path.append(os.path.dirname(os.path.realpath(__file__)))\nsys.path.append(os.path.dirname(os.path.dirname(os.path.realpath(__file__))))\nsys.path.append(os.path.join(os.path.dirname(os.path.realpath(__file__)), 'NeuralSeq'))\nsys.path.append(os.path.join(os.path.dirname(os.path.realpath(__file__)), 'text_to_audio/Make_An_Audio'))\nsys.path.append(os.path.join(os.path.dirname(os.path.realpath(__file__)), 'audio_detection'))\nsys.path.append(os.path.join(os.path.dirname(os.path.realpath(__file__)), 'mono2binaural'))\nimport gradio as gr\nimport matplotlib\nimport librosa\nimport torch\nfrom langchain.agents.initialize import initialize_agent\nfrom langchain.agents.tools import Tool\nfrom langchain.chains.conversation.memory import ConversationBufferMemory\nfrom langchain.llms.openai import OpenAI\nimport re\nimport uuid\nimport soundfile\nfrom PIL import Image\nimport numpy as np\nfrom omegaconf import OmegaConf\nfrom einops import repeat\nfrom ldm.util import instantiate_from_config\nfrom ldm.data.extract_mel_spectrogram import TRANSFORMS_16000\nfrom vocoder.bigvgan.models import VocoderBigVGAN\nfrom ldm.models.diffusion.ddim import DDIMSampler\nimport whisper\nfrom utils.hparams import set_hparams\nfrom utils.hparams import hparams as hp\nimport scipy.io.wavfile as wavfile\nimport librosa\nfrom audio_infer.utils import config as detection_config\nfrom audio_infer.pytorch.models import PVT\nimport clip\nimport numpy as np\nAUDIO_CHATGPT_PREFIX = \"\"\"AudioGPT\nAudioGPT can not directly read audios, but it has a list of tools to finish different speech, audio, and singing voice tasks. Each audio will have a file name formed as \"audio/xxx.wav\". When talking about audios, AudioGPT is very strict to the file name and will never fabricate nonexistent files. \nAudioGPT is able to use tools in a sequence, and is loyal to the tool observation outputs rather than faking the audio content and audio file name. It will remember to provide the file name from the last tool observation, if a new audio is generated.\nHuman may provide new audios to AudioGPT with a description. The description helps AudioGPT to understand this audio, but AudioGPT should use tools to finish following tasks, rather than directly imagine from the description.\nOverall, AudioGPT is a powerful audio dialogue assistant tool that can help with a wide range of tasks and provide valuable insights and information on a wide range of topics. \n\nTOOLS:\n------\n\nAudioGPT has access to the following tools:\"\"\"\n\nAUDIO_CHATGPT_FORMAT_INSTRUCTIONS = \"\"\"To use a tool, please use the following format:\n\n```\nThought: Do I need to use a tool? Yes\nAction: the action to take, should be one of [{tool_names}]\nAction Input: the input to the action\nObservation: the result of the action\n```\n\nWhen you have a response to say to the Human, or if you do not need to use a tool, you MUST use the format:\n\n```\nThought: Do I need to use a tool? No\n{ai_prefix}: [your response here]\n```\n\"\"\"\n\nAUDIO_CHATGPT_SUFFIX = \"\"\"You are very strict to the filename correctness and will never fake a file name if not exists.\nYou will remember to provide the audio file name loyally if it's provided in the last tool observation.\n\nBegin!\n\nPrevious conversation history:\n{chat_history}\nNew input: {input}\nThought: Do I need to use a tool? {agent_scratchpad}\"\"\"\n\n\n\ndef cut_dialogue_history(history_memory, keep_last_n_words = 500):\n    tokens = history_memory.split()\n    n_tokens = len(tokens)\n    print(f\"history_memory:{history_memory}, n_tokens: {n_tokens}\")\n    if n_tokens < keep_last_n_words:\n        return history_memory\n    else:\n        paragraphs = history_memory.split('\\n')\n        last_n_tokens = n_tokens\n        while last_n_tokens >= keep_last_n_words:\n            last_n_tokens = last_n_tokens - len(paragraphs[0].split(' '))\n            paragraphs = paragraphs[1:]\n        return '\\n' + '\\n'.join(paragraphs)\n\n\ndef merge_audio(audio_path_1, audio_path_2):\n    merged_signal = []\n    sr_1, signal_1 = wavfile.read(audio_path_1)\n    sr_2, signal_2 = wavfile.read(audio_path_2)\n    merged_signal.append(signal_1)\n    merged_signal.append(signal_2)\n    merged_signal = np.hstack(merged_signal)\n    merged_signal = np.asarray(merged_signal, dtype=np.int16)\n    audio_filename = os.path.join('audio', str(uuid.uuid4())[0:8] + \".wav\")\n    wavfile.write(audio_filename, sr_2, merged_signal)\n    return audio_filename\n\nclass T2I:\n    def __init__(self, device):\n        from transformers import AutoModelForCausalLM, AutoTokenizer\n        from diffusers import StableDiffusionPipeline\n        from transformers import pipeline\n        print(\"Initializing T2I to %s\" % device)\n        self.device = device\n        self.pipe = StableDiffusionPipeline.from_pretrained(\"runwayml/stable-diffusion-v1-5\", torch_dtype=torch.float16)\n        self.text_refine_tokenizer = AutoTokenizer.from_pretrained(\"Gustavosta/MagicPrompt-Stable-Diffusion\")\n        self.text_refine_model = AutoModelForCausalLM.from_pretrained(\"Gustavosta/MagicPrompt-Stable-Diffusion\")\n        self.text_refine_gpt2_pipe = pipeline(\"text-generation\", model=self.text_refine_model, tokenizer=self.text_refine_tokenizer, device=self.device)\n        self.pipe.to(device)\n\n    def inference(self, text):\n        image_filename = os.path.join('image', str(uuid.uuid4())[0:8] + \".png\")\n        refined_text = self.text_refine_gpt2_pipe(text)[0][\"generated_text\"]\n        print(f'{text} refined to {refined_text}')\n        image = self.pipe(refined_text).images[0]\n        image.save(image_filename)\n        print(f\"Processed T2I.run, text: {text}, image_filename: {image_filename}\")\n        return image_filename\n\nclass ImageCaptioning:\n    def __init__(self, device):\n        from transformers import BlipProcessor, BlipForConditionalGeneration\n        print(\"Initializing ImageCaptioning to %s\" % device)\n        self.device = device\n        self.processor = BlipProcessor.from_pretrained(\"Salesforce/blip-image-captioning-base\")\n        self.model = BlipForConditionalGeneration.from_pretrained(\"Salesforce/blip-image-captioning-base\").to(self.device)\n\n    def inference(self, image_path):\n        inputs = self.processor(Image.open(image_path), return_tensors=\"pt\").to(self.device)\n        out = self.model.generate(**inputs)\n        captions = self.processor.decode(out[0], skip_special_tokens=True)\n        return captions\n\nclass T2A:\n    def __init__(self, device):\n        print(\"Initializing Make-An-Audio to %s\" % device)\n        self.device = device\n        self.sampler = self._initialize_model('text_to_audio/Make_An_Audio/configs/text_to_audio/txt2audio_args.yaml', 'text_to_audio/Make_An_Audio/useful_ckpts/ta40multi_epoch=000085.ckpt', device=device)\n        self.vocoder = VocoderBigVGAN('text_to_audio/Make_An_Audio/vocoder/logs/bigv16k53w',device=device)\n\n    def _initialize_model(self, config, ckpt, device):\n        config = OmegaConf.load(config)\n        model = instantiate_from_config(config.model)\n        model.load_state_dict(torch.load(ckpt, map_location='cpu')[\"state_dict\"], strict=False)\n\n        model = model.to(device)\n        model.cond_stage_model.to(model.device)\n        model.cond_stage_model.device = model.device\n        sampler = DDIMSampler(model)\n        return sampler\n\n    def txt2audio(self, text, seed = 55, scale = 1.5, ddim_steps = 100, n_samples = 3, W = 624, H = 80):\n        SAMPLE_RATE = 16000\n        prng = np.random.RandomState(seed)\n        start_code = prng.randn(n_samples, self.sampler.model.first_stage_model.embed_dim, H // 8, W // 8)\n        start_code = torch.from_numpy(start_code).to(device=self.device, dtype=torch.float32)\n        uc = self.sampler.model.get_learned_conditioning(n_samples * [\"\"])\n        c = self.sampler.model.get_learned_conditioning(n_samples * [text])\n        shape = [self.sampler.model.first_stage_model.embed_dim, H//8, W//8]  # (z_dim, 80//2^x, 848//2^x)\n        samples_ddim, _ = self.sampler.sample(S = ddim_steps,\n                                            conditioning = c,\n                                            batch_size = n_samples,\n                                            shape = shape,\n                                            verbose = False,\n                                            unconditional_guidance_scale = scale,\n                                            unconditional_conditioning = uc,\n                                            x_T = start_code)\n\n        x_samples_ddim = self.sampler.model.decode_first_stage(samples_ddim)\n        x_samples_ddim = torch.clamp((x_samples_ddim+1.0)/2.0, min=0.0, max=1.0) # [0, 1]\n\n        wav_list = []\n        for idx,spec in enumerate(x_samples_ddim):\n            wav = self.vocoder.vocode(spec)\n            wav_list.append((SAMPLE_RATE,wav))\n        best_wav = self.select_best_audio(text, wav_list)\n        return best_wav\n\n    def select_best_audio(self, prompt, wav_list):\n        from wav_evaluation.models.CLAPWrapper import CLAPWrapper\n        clap_model = CLAPWrapper('text_to_audio/Make_An_Audio/useful_ckpts/CLAP/CLAP_weights_2022.pth', 'text_to_audio/Make_An_Audio/useful_ckpts/CLAP/config.yml',\n                                 use_cuda=torch.cuda.is_available())\n        text_embeddings = clap_model.get_text_embeddings([prompt])\n        score_list = []\n        for data in wav_list:\n            sr, wav = data\n            audio_embeddings = clap_model.get_audio_embeddings([(torch.FloatTensor(wav), sr)], resample=True)\n            score = clap_model.compute_similarity(audio_embeddings, text_embeddings,\n                                                  use_logit_scale=False).squeeze().cpu().numpy()\n            score_list.append(score)\n        max_index = np.array(score_list).argmax()\n        print(score_list, max_index)\n        return wav_list[max_index]\n\n    def inference(self, text, seed = 55, scale = 1.5, ddim_steps = 100, n_samples = 3, W = 624, H = 80):\n        melbins,mel_len = 80,624\n        with torch.no_grad():\n            result = self.txt2audio(\n                text = text,\n                H = melbins,\n                W = mel_len\n            )\n        audio_filename = os.path.join('audio', str(uuid.uuid4())[0:8] + \".wav\")\n        soundfile.write(audio_filename, result[1], samplerate = 16000)\n        print(f\"Processed T2I.run, text: {text}, audio_filename: {audio_filename}\")\n        return audio_filename\n\nclass I2A:\n    def __init__(self, device):\n        print(\"Initializing Make-An-Audio-Image to %s\" % device)\n        self.device = device\n        self.sampler = self._initialize_model('text_to_audio/Make_An_Audio/configs/img_to_audio/img2audio_args.yaml', 'text_to_audio/Make_An_Audio/useful_ckpts/ta54_epoch=000216.ckpt', device=device)\n        self.vocoder = VocoderBigVGAN('text_to_audio/Make_An_Audio/vocoder/logs/bigv16k53w',device=device)\n\n    def _initialize_model(self, config, ckpt, device):\n        config = OmegaConf.load(config)\n        model = instantiate_from_config(config.model)\n        model.load_state_dict(torch.load(ckpt, map_location='cpu')[\"state_dict\"], strict=False)\n\n        model = model.to(device)\n        model.cond_stage_model.to(model.device)\n        model.cond_stage_model.device = model.device\n        sampler = DDIMSampler(model)\n        return sampler\n\n    def img2audio(self, image, seed = 55, scale = 3, ddim_steps = 100, W = 624, H = 80):\n        SAMPLE_RATE = 16000\n        n_samples = 1 # only support 1 sample\n        prng = np.random.RandomState(seed)\n        start_code = prng.randn(n_samples, self.sampler.model.first_stage_model.embed_dim, H // 8, W // 8)\n        start_code = torch.from_numpy(start_code).to(device=self.device, dtype=torch.float32)\n        uc = self.sampler.model.get_learned_conditioning(n_samples * [\"\"])\n        #image = Image.fromarray(image)\n        image = Image.open(image)\n        image = self.sampler.model.cond_stage_model.preprocess(image).unsqueeze(0)\n        image_embedding = self.sampler.model.cond_stage_model.forward_img(image)\n        c = image_embedding.repeat(n_samples, 1, 1)\n        shape = [self.sampler.model.first_stage_model.embed_dim, H//8, W//8]  # (z_dim, 80//2^x, 848//2^x)\n        samples_ddim, _ = self.sampler.sample(S=ddim_steps,\n                                            conditioning=c,\n                                            batch_size=n_samples,\n                                            shape=shape,\n                                            verbose=False,\n                                            unconditional_guidance_scale=scale,\n                                            unconditional_conditioning=uc,\n                                            x_T=start_code)\n\n        x_samples_ddim = self.sampler.model.decode_first_stage(samples_ddim)\n        x_samples_ddim = torch.clamp((x_samples_ddim+1.0)/2.0, min=0.0, max=1.0) # [0, 1]\n        wav_list = []\n        for idx,spec in enumerate(x_samples_ddim):\n            wav = self.vocoder.vocode(spec)\n            wav_list.append((SAMPLE_RATE,wav))\n        best_wav = wav_list[0]\n        return best_wav\n    def inference(self, image, seed = 55, scale = 3, ddim_steps = 100, W = 624, H = 80):\n        melbins,mel_len = 80,624\n        with torch.no_grad():\n            result = self.img2audio(\n                image=image,\n                H=melbins,\n                W=mel_len\n            )\n        audio_filename = os.path.join('audio', str(uuid.uuid4())[0:8] + \".wav\")\n        soundfile.write(audio_filename, result[1], samplerate = 16000)\n        print(f\"Processed I2a.run, image_filename: {image}, audio_filename: {audio_filename}\")\n        return audio_filename\n\nclass TTS:\n    def __init__(self, device=None):\n        from inference.tts.PortaSpeech import TTSInference\n        if device is None:\n            device = 'cuda' if torch.cuda.is_available() else 'cpu'\n        print(\"Initializing PortaSpeech to %s\" % device)\n        self.device = device\n        self.exp_name = 'checkpoints/ps_adv_baseline'\n        self.set_model_hparams()\n        self.inferencer = TTSInference(self.hp, device)\n\n    def set_model_hparams(self):\n        set_hparams(exp_name=self.exp_name, print_hparams=False)\n        self.hp = hp\n\n    def inference(self, text):\n        self.set_model_hparams()\n        inp = {\"text\": text}\n        out = self.inferencer.infer_once(inp)\n        audio_filename = os.path.join('audio', str(uuid.uuid4())[0:8] + \".wav\")\n        soundfile.write(audio_filename, out, samplerate=22050)\n        return audio_filename\n\nclass T2S:\n    def __init__(self, device= None):\n        from inference.svs.ds_e2e import DiffSingerE2EInfer\n        if device is None:\n            device = 'cuda' if torch.cuda.is_available() else 'cpu'\n        print(\"Initializing DiffSinger to %s\" % device)\n        self.device = device\n        self.exp_name = 'checkpoints/0831_opencpop_ds1000'\n        self.config= 'NeuralSeq/egs/egs_bases/svs/midi/e2e/opencpop/ds1000.yaml'\n        self.set_model_hparams()\n        self.pipe = DiffSingerE2EInfer(self.hp, device)\n        self.default_inp = {\n            'text': '你 说 你 不 SP 懂 为 何 在 这 时 牵 手 AP',\n            'notes': 'D#4/Eb4 | D#4/Eb4 | D#4/Eb4 | D#4/Eb4 | rest | D#4/Eb4 | D4 | D4 | D4 | D#4/Eb4 | F4 | D#4/Eb4 | D4 | rest',\n            'notes_duration': '0.113740 | 0.329060 | 0.287950 | 0.133480 | 0.150900 | 0.484730 | 0.242010 | 0.180820 | 0.343570 | 0.152050 | 0.266720 | 0.280310 | 0.633300 | 0.444590'\n        }\n\n    def set_model_hparams(self):\n        set_hparams(config=self.config, exp_name=self.exp_name, print_hparams=False)\n        self.hp = hp\n\n    def inference(self, inputs):\n        self.set_model_hparams()\n        val = inputs.split(\",\")\n        key = ['text', 'notes', 'notes_duration']\n        try:\n            inp = {k: v for k, v in zip(key, val)}\n            wav = self.pipe.infer_once(inp)\n        except:\n            print('Error occurs. Generate default audio sample.\\n')\n            inp = self.default_inp\n            wav = self.pipe.infer_once(inp)\n        #if inputs == '' or len(val) < len(key):\n        #    inp = self.default_inp\n        #else:\n        #    inp = {k:v for k,v in zip(key,val)}\n        #wav = self.pipe.infer_once(inp)\n        wav *= 32767\n        audio_filename = os.path.join('audio', str(uuid.uuid4())[0:8] + \".wav\")\n        wavfile.write(audio_filename, self.hp['audio_sample_rate'], wav.astype(np.int16))\n        print(f\"Processed T2S.run, audio_filename: {audio_filename}\")\n        return audio_filename\n\nclass t2s_VISinger:\n    def __init__(self, device=None):\n        from espnet2.bin.svs_inference import SingingGenerate\n        if device is None:\n            device = 'cuda' if torch.cuda.is_available() else 'cpu'\n        print(\"Initializing VISingere to %s\" % device)\n        tag = 'AQuarterMile/opencpop_visinger1'\n        self.model = SingingGenerate.from_pretrained(\n            model_tag=str_or_none(tag),\n            device=device,\n        )\n        phn_dur = [[0.        , 0.219     ],\n            [0.219     , 0.50599998],\n            [0.50599998, 0.71399999],\n            [0.71399999, 1.097     ],\n            [1.097     , 1.28799999],\n            [1.28799999, 1.98300004],\n            [1.98300004, 7.10500002],\n            [7.10500002, 7.60400009]]\n        phn = ['sh', 'i', 'q', 'v', 'n', 'i', 'SP', 'AP']\n        score = [[0, 0.50625, 'sh_i', 58, 'sh_i'], [0.50625, 1.09728, 'q_v', 56, 'q_v'], [1.09728, 1.9832100000000001, 'n_i', 53, 'n_i'], [1.9832100000000001, 7.105360000000001, 'SP', 0, 'SP'], [7.105360000000001, 7.604390000000001, 'AP', 0, 'AP']]\n        tempo = 70\n        tmp = {}\n        tmp[\"label\"] = phn_dur, phn\n        tmp[\"score\"] = tempo, score\n        self.default_inp = tmp\n\n    def inference(self, inputs):\n        val = inputs.split(\",\")\n        key = ['text', 'notes', 'notes_duration']\n        try: # TODO: input will be update\n            inp = {k: v for k, v in zip(key, val)}\n            wav = self.model(text=inp)[\"wav\"]\n        except:\n            print('Error occurs. Generate default audio sample.\\n')\n            inp = self.default_inp\n            wav = self.model(text=inp)[\"wav\"]\n\n        audio_filename = os.path.join('audio', str(uuid.uuid4())[0:8] + \".wav\")\n        soundfile.write(audio_filename, wav, samplerate=self.model.fs)\n        return audio_filename\n\nclass TTS_OOD:\n    def __init__(self, device):\n        from inference.tts.GenerSpeech import GenerSpeechInfer\n        if device is None:\n            device = 'cuda' if torch.cuda.is_available() else 'cpu'\n        print(\"Initializing GenerSpeech to %s\" % device)\n        self.device = device\n        self.exp_name = 'checkpoints/GenerSpeech'\n        self.config = 'NeuralSeq/modules/GenerSpeech/config/generspeech.yaml'\n        self.set_model_hparams()\n        self.pipe = GenerSpeechInfer(self.hp, device)\n\n    def set_model_hparams(self):\n        set_hparams(config=self.config, exp_name=self.exp_name, print_hparams=False)\n        f0_stats_fn = f'{hp[\"binary_data_dir\"]}/train_f0s_mean_std.npy'\n        if os.path.exists(f0_stats_fn):\n            hp['f0_mean'], hp['f0_std'] = np.load(f0_stats_fn)\n            hp['f0_mean'] = float(hp['f0_mean'])\n            hp['f0_std'] = float(hp['f0_std'])\n        hp['emotion_encoder_path'] = 'checkpoints/Emotion_encoder.pt'\n        self.hp = hp\n\n    def inference(self, inputs):\n        self.set_model_hparams()\n        key = ['ref_audio', 'text']\n        val = inputs.split(\",\")\n        inp = {k: v for k, v in zip(key, val)}\n        wav = self.pipe.infer_once(inp)\n        wav *= 32767\n        audio_filename = os.path.join('audio', str(uuid.uuid4())[0:8] + \".wav\")\n        wavfile.write(audio_filename, self.hp['audio_sample_rate'], wav.astype(np.int16))\n        print(\n            f\"Processed GenerSpeech.run. Input text:{val[1]}. Input reference audio: {val[0]}. Output Audio_filename: {audio_filename}\")\n        return audio_filename\n\nclass Inpaint:\n    def __init__(self, device):\n        print(\"Initializing Make-An-Audio-inpaint to %s\" % device)\n        self.device = device\n        self.sampler = self._initialize_model_inpaint('text_to_audio/Make_An_Audio/configs/inpaint/txt2audio_args.yaml', 'text_to_audio/Make_An_Audio/useful_ckpts/inpaint7_epoch00047.ckpt')\n        self.vocoder = VocoderBigVGAN('text_to_audio/Make_An_Audio/vocoder/logs/bigv16k53w',device=device)\n        self.cmap_transform = matplotlib.cm.viridis\n\n    def _initialize_model_inpaint(self, config, ckpt):\n        config = OmegaConf.load(config)\n        model = instantiate_from_config(config.model)\n        model.load_state_dict(torch.load(ckpt, map_location='cpu')[\"state_dict\"], strict=False)\n        device = torch.device(\"cuda\") if torch.cuda.is_available() else torch.device(\"cpu\")\n        model = model.to(device)\n        print(model.device, device, model.cond_stage_model.device)\n        sampler = DDIMSampler(model)\n        return sampler\n\n    def make_batch_sd(self, mel, mask, num_samples=1):\n\n        mel = torch.from_numpy(mel)[None,None,...].to(dtype=torch.float32)\n        mask = torch.from_numpy(mask)[None,None,...].to(dtype=torch.float32)\n        masked_mel = (1 - mask) * mel\n\n        mel = mel * 2 - 1\n        mask = mask * 2 - 1\n        masked_mel = masked_mel * 2 -1\n\n        batch = {\n             \"mel\": repeat(mel.to(device=self.device), \"1 ... -> n ...\", n=num_samples),\n             \"mask\": repeat(mask.to(device=self.device), \"1 ... -> n ...\", n=num_samples),\n             \"masked_mel\": repeat(masked_mel.to(device=self.device), \"1 ... -> n ...\", n=num_samples),\n        }\n        return batch\n    def gen_mel(self, input_audio_path):\n        SAMPLE_RATE = 16000\n        sr, ori_wav = wavfile.read(input_audio_path)\n        print(\"gen_mel\")\n        print(sr,ori_wav.shape,ori_wav)\n        ori_wav = ori_wav.astype(np.float32, order='C') / 32768.0\n        if len(ori_wav.shape)==2:# stereo\n            ori_wav = librosa.to_mono(ori_wav.T)\n        print(sr,ori_wav.shape,ori_wav)\n        ori_wav = librosa.resample(ori_wav,orig_sr = sr,target_sr = SAMPLE_RATE)\n\n        mel_len,hop_size = 848,256\n        input_len = mel_len * hop_size\n        if len(ori_wav) < input_len:\n            input_wav = np.pad(ori_wav,(0,mel_len*hop_size),constant_values=0)\n        else:\n            input_wav = ori_wav[:input_len]\n\n        mel = TRANSFORMS_16000(input_wav)\n        return mel\n    def gen_mel_audio(self, input_audio):\n        SAMPLE_RATE = 16000\n        sr,ori_wav = input_audio\n        print(\"gen_mel_audio\")\n        print(sr,ori_wav.shape,ori_wav)\n\n        ori_wav = ori_wav.astype(np.float32, order='C') / 32768.0\n        if len(ori_wav.shape)==2:# stereo\n            ori_wav = librosa.to_mono(ori_wav.T)\n        print(sr,ori_wav.shape,ori_wav)\n        ori_wav = librosa.resample(ori_wav,orig_sr = sr,target_sr = SAMPLE_RATE)\n\n        mel_len,hop_size = 848,256\n        input_len = mel_len * hop_size\n        if len(ori_wav) < input_len:\n            input_wav = np.pad(ori_wav,(0,mel_len*hop_size),constant_values=0)\n        else:\n            input_wav = ori_wav[:input_len]\n        mel = TRANSFORMS_16000(input_wav)\n        return mel\n    def show_mel_fn(self, input_audio_path):\n        crop_len = 500\n        crop_mel = self.gen_mel(input_audio_path)[:,:crop_len]\n        color_mel = self.cmap_transform(crop_mel)\n        image = Image.fromarray((color_mel*255).astype(np.uint8))\n        image_filename = os.path.join('image', str(uuid.uuid4())[0:8] + \".png\")\n        image.save(image_filename)\n        return image_filename\n    def inpaint(self, batch, seed, ddim_steps, num_samples=1, W=512, H=512):\n        model = self.sampler.model\n\n        prng = np.random.RandomState(seed)\n        start_code = prng.randn(num_samples, model.first_stage_model.embed_dim, H // 8, W // 8)\n        start_code = torch.from_numpy(start_code).to(device=self.device, dtype=torch.float32)\n\n        c = model.get_first_stage_encoding(model.encode_first_stage(batch[\"masked_mel\"]))\n        cc = torch.nn.functional.interpolate(batch[\"mask\"],\n                                                size=c.shape[-2:])\n        c = torch.cat((c, cc), dim=1) # (b,c+1,h,w) 1 is mask\n\n        shape = (c.shape[1]-1,)+c.shape[2:]\n        samples_ddim, _ = self.sampler.sample(S=ddim_steps,\n                                            conditioning=c,\n                                            batch_size=c.shape[0],\n                                            shape=shape,\n                                            verbose=False)\n        x_samples_ddim = model.decode_first_stage(samples_ddim)\n\n\n        mel = torch.clamp((batch[\"mel\"]+1.0)/2.0,min=0.0, max=1.0)\n        mask = torch.clamp((batch[\"mask\"]+1.0)/2.0,min=0.0, max=1.0)\n        predicted_mel = torch.clamp((x_samples_ddim+1.0)/2.0,min=0.0, max=1.0)\n        inpainted = (1-mask)*mel+mask*predicted_mel\n        inpainted = inpainted.cpu().numpy().squeeze()\n        inapint_wav = self.vocoder.vocode(inpainted)\n\n        return inpainted, inapint_wav\n    def inference(self, input_audio, mel_and_mask, seed = 55, ddim_steps = 100):\n        SAMPLE_RATE = 16000\n        torch.set_grad_enabled(False)\n        mel_img = Image.open(mel_and_mask['image'])\n        mask_img = Image.open(mel_and_mask[\"mask\"])\n        show_mel = np.array(mel_img.convert(\"L\"))/255\n        mask = np.array(mask_img.convert(\"L\"))/255\n        mel_bins,mel_len = 80,848\n        input_mel = self.gen_mel_audio(input_audio)[:,:mel_len]\n        mask = np.pad(mask,((0,0),(0,mel_len-mask.shape[1])),mode='constant',constant_values=0)\n        print(mask.shape,input_mel.shape)\n        with torch.no_grad():\n            batch = self.make_batch_sd(input_mel,mask,num_samples=1)\n            inpainted,gen_wav = self.inpaint(\n                batch=batch,\n                seed=seed,\n                ddim_steps=ddim_steps,\n                num_samples=1,\n                H=mel_bins, W=mel_len\n            )\n        inpainted = inpainted[:,:show_mel.shape[1]]\n        color_mel = self.cmap_transform(inpainted)\n        input_len = int(input_audio[1].shape[0] * SAMPLE_RATE / input_audio[0])\n        gen_wav = (gen_wav * 32768).astype(np.int16)[:input_len]\n        image = Image.fromarray((color_mel*255).astype(np.uint8))\n        image_filename = os.path.join('image', str(uuid.uuid4())[0:8] + \".png\")\n        image.save(image_filename)\n        audio_filename = os.path.join('audio', str(uuid.uuid4())[0:8] + \".wav\")\n        soundfile.write(audio_filename, gen_wav, samplerate = 16000)\n        return image_filename, audio_filename\n    \nclass ASR:\n    def __init__(self, device):\n        print(\"Initializing Whisper to %s\" % device)\n        self.device = device\n        self.model = whisper.load_model(\"base\", device=device)\n\n    def inference(self, audio_path):\n        audio = whisper.load_audio(audio_path)\n        audio = whisper.pad_or_trim(audio)\n        mel = whisper.log_mel_spectrogram(audio).to(self.device)\n        _, probs = self.model.detect_language(mel)\n        options = whisper.DecodingOptions()\n        result = whisper.decode(self.model, mel, options)\n        return result.text\n    def translate_english(self, audio_path):\n        audio = self.model.transcribe(audio_path, language='English')\n        return audio['text']\n\nclass A2T:\n    def __init__(self, device):\n        from audio_to_text.inference_waveform import AudioCapModel\n        print(\"Initializing Audio-To-Text Model to %s\" % device)\n        self.device = device\n        self.model = AudioCapModel(\"audio_to_text/audiocaps_cntrstv_cnn14rnn_trm\")\n    def inference(self, audio_path):\n        audio = whisper.load_audio(audio_path)\n        caption_text = self.model(audio)\n        return caption_text[0]\n\nclass GeneFace:\n    def __init__(self, device=None):\n        print(\"Initializing GeneFace model to %s\" % device)\n        from audio_to_face.GeneFace_binding import GeneFaceInfer\n        if device is None:\n            device = 'cuda' if torch.cuda.is_available() else 'cpu'\n        self.device = device\n        self.geneface_model = GeneFaceInfer(device)\n        print(\"Loaded GeneFace model\")\n\n    def inference(self, audio_path):\n        audio_base_name = os.path.basename(audio_path)[:-4]\n        out_video_name = audio_path.replace(\"audio\",\"video\").replace(\".wav\", \".mp4\")\n        inp = {\n            'audio_source_name': audio_path,\n            'out_npy_name': f'geneface/tmp/{audio_base_name}.npy',\n            'cond_name': f'geneface/tmp/{audio_base_name}.npy',\n            'out_video_name': out_video_name,\n            'tmp_imgs_dir': f'video/tmp_imgs',\n        }\n        self.geneface_model.infer_once(inp)\n        return out_video_name\n\nclass SoundDetection:\n    def __init__(self, device):\n        self.device = device\n        self.sample_rate = 32000\n        self.window_size = 1024\n        self.hop_size = 320\n        self.mel_bins = 64\n        self.fmin = 50\n        self.fmax = 14000\n        self.model_type = 'PVT'\n        self.checkpoint_path = 'audio_detection/audio_infer/useful_ckpts/audio_detection.pth'\n        self.classes_num = detection_config.classes_num\n        self.labels = detection_config.labels\n        self.frames_per_second = self.sample_rate // self.hop_size\n        # Model = eval(self.model_type)\n        self.model = PVT(sample_rate=self.sample_rate, window_size=self.window_size, \n            hop_size=self.hop_size, mel_bins=self.mel_bins, fmin=self.fmin, fmax=self.fmax, \n            classes_num=self.classes_num)\n        checkpoint = torch.load(self.checkpoint_path, map_location=self.device)\n        self.model.load_state_dict(checkpoint['model'])\n        self.model.to(device)\n\n    def inference(self, audio_path):\n        # Forward\n        (waveform, _) = librosa.core.load(audio_path, sr=self.sample_rate, mono=True)\n        waveform = waveform[None, :]    # (1, audio_length)\n        waveform = torch.from_numpy(waveform)\n        waveform = waveform.to(self.device)\n        # Forward\n        with torch.no_grad():\n            self.model.eval()\n            batch_output_dict = self.model(waveform, None)\n        framewise_output = batch_output_dict['framewise_output'].data.cpu().numpy()[0]\n        \"\"\"(time_steps, classes_num)\"\"\"\n        # print('Sound event detection result (time_steps x classes_num): {}'.format(\n        #     framewise_output.shape))\n        import numpy as np\n        import matplotlib.pyplot as plt\n        sorted_indexes = np.argsort(np.max(framewise_output, axis=0))[::-1]\n        top_k = 10  # Show top results\n        top_result_mat = framewise_output[:, sorted_indexes[0 : top_k]]    \n        \"\"\"(time_steps, top_k)\"\"\"\n        # Plot result    \n        stft = librosa.core.stft(y=waveform[0].data.cpu().numpy(), n_fft=self.window_size, \n            hop_length=self.hop_size, window='hann', center=True)\n        frames_num = stft.shape[-1]\n        fig, axs = plt.subplots(2, 1, sharex=True, figsize=(10, 4))\n        axs[0].matshow(np.log(np.abs(stft)), origin='lower', aspect='auto', cmap='jet')\n        axs[0].set_ylabel('Frequency bins')\n        axs[0].set_title('Log spectrogram')\n        axs[1].matshow(top_result_mat.T, origin='upper', aspect='auto', cmap='jet', vmin=0, vmax=1)\n        axs[1].xaxis.set_ticks(np.arange(0, frames_num, self.frames_per_second))\n        axs[1].xaxis.set_ticklabels(np.arange(0, frames_num / self.frames_per_second))\n        axs[1].yaxis.set_ticks(np.arange(0, top_k))\n        axs[1].yaxis.set_ticklabels(np.array(self.labels)[sorted_indexes[0 : top_k]])\n        axs[1].yaxis.grid(color='k', linestyle='solid', linewidth=0.3, alpha=0.3)\n        axs[1].set_xlabel('Seconds')\n        axs[1].xaxis.set_ticks_position('bottom')\n        plt.tight_layout()\n        image_filename = os.path.join('image', str(uuid.uuid4())[0:8] + \".png\")\n        plt.savefig(image_filename)\n        return image_filename\n\nclass SoundExtraction:\n    def __init__(self, device):\n        from sound_extraction.model.LASSNet import LASSNet\n        from sound_extraction.utils.stft import STFT\n        import torch.nn as nn\n        self.device = device\n        self.model_file = 'sound_extraction/useful_ckpts/LASSNet.pt'\n        self.stft = STFT()\n\n        self.model = nn.DataParallel(LASSNet(device)).to(device)\n        checkpoint = torch.load(self.model_file)\n        self.model.load_state_dict(checkpoint['model'])\n        self.model.eval()\n\n    def inference(self, inputs):\n        #key = ['ref_audio', 'text']\n        from sound_extraction.utils.wav_io import load_wav, save_wav\n        val = inputs.split(\",\")\n        audio_path = val[0] # audio_path, text\n        text = val[1]\n        waveform = load_wav(audio_path)\n        waveform = torch.tensor(waveform).transpose(1,0)\n        mixed_mag, mixed_phase = self.stft.transform(waveform)\n        text_query = ['[CLS] ' + text]\n        mixed_mag = mixed_mag.transpose(2,1).unsqueeze(0).to(self.device)\n        est_mask = self.model(mixed_mag, text_query)\n        est_mag = est_mask * mixed_mag  \n        est_mag = est_mag.squeeze(1)  \n        est_mag = est_mag.permute(0, 2, 1) \n        est_wav = self.stft.inverse(est_mag.cpu().detach(), mixed_phase)\n        est_wav = est_wav.squeeze(0).squeeze(0).numpy()  \n        #est_path = f'output/est{i}.wav'\n        audio_filename = os.path.join('audio', str(uuid.uuid4())[0:8] + \".wav\")\n        print('audio_filename ', audio_filename)\n        save_wav(est_wav, audio_filename)\n        return audio_filename\n\n\nclass Binaural:\n    def __init__(self, device):\n        from src.models import BinauralNetwork\n        self.device = device\n        self.model_file = 'mono2binaural/useful_ckpts/m2b/binaural_network.net'\n        self.position_file = ['mono2binaural/useful_ckpts/m2b/tx_positions.txt',\n                              'mono2binaural/useful_ckpts/m2b/tx_positions2.txt',\n                              'mono2binaural/useful_ckpts/m2b/tx_positions3.txt',\n                              'mono2binaural/useful_ckpts/m2b/tx_positions4.txt',\n                              'mono2binaural/useful_ckpts/m2b/tx_positions5.txt']\n        self.net = BinauralNetwork(view_dim=7,\n                      warpnet_layers=4,\n                      warpnet_channels=64,\n                      )\n        self.net.load_from_file(self.model_file)\n        self.sr = 48000\n    def inference(self, audio_path):\n        mono, sr  = librosa.load(path=audio_path, sr=self.sr, mono=True)\n        mono = torch.from_numpy(mono)\n        mono = mono.unsqueeze(0)\n        import numpy as np\n        import random\n        rand_int = random.randint(0,4)\n        view = np.loadtxt(self.position_file[rand_int]).transpose().astype(np.float32)\n        view = torch.from_numpy(view)\n        if not view.shape[-1] * 400 == mono.shape[-1]:\n            mono = mono[:,:(mono.shape[-1]//400)*400] # \n            if view.shape[1]*400 > mono.shape[1]:\n                m_a = view.shape[1] - mono.shape[-1]//400 \n                rand_st = random.randint(0,m_a)\n                view = view[:,m_a:m_a+(mono.shape[-1]//400)] # \n        # binauralize and save output\n        self.net.eval().to(self.device)\n        mono, view = mono.to(self.device), view.to(self.device)\n        chunk_size = 48000  # forward in chunks of 1s\n        rec_field =  1000  # add 1000 samples as \"safe bet\" since warping has undefined rec. field\n        rec_field -= rec_field % 400  # make sure rec_field is a multiple of 400 to match audio and view frequencies\n        chunks = [\n            {\n                \"mono\": mono[:, max(0, i-rec_field):i+chunk_size],\n                \"view\": view[:, max(0, i-rec_field)//400:(i+chunk_size)//400]\n            }\n            for i in range(0, mono.shape[-1], chunk_size)\n        ]\n        for i, chunk in enumerate(chunks):\n            with torch.no_grad():\n                mono = chunk[\"mono\"].unsqueeze(0)\n                view = chunk[\"view\"].unsqueeze(0)\n                binaural = self.net(mono, view).squeeze(0)\n                if i > 0:\n                    binaural = binaural[:, -(mono.shape[-1]-rec_field):]\n                chunk[\"binaural\"] = binaural\n        binaural = torch.cat([chunk[\"binaural\"] for chunk in chunks], dim=-1)\n        binaural = torch.clamp(binaural, min=-1, max=1).cpu()\n        #binaural = chunked_forwarding(net, mono, view)\n        audio_filename = os.path.join('audio', str(uuid.uuid4())[0:8] + \".wav\")\n        import torchaudio\n        torchaudio.save(audio_filename, binaural, sr)\n        #soundfile.write(audio_filename, binaural, samplerate = 48000)\n        print(f\"Processed Binaural.run, audio_filename: {audio_filename}\")\n        return audio_filename\n\nclass TargetSoundDetection:\n    def __init__(self, device):\n        from target_sound_detection.src import models as tsd_models\n        from target_sound_detection.src.models import event_labels\n\n        self.device = device\n        self.MEL_ARGS = {\n            'n_mels': 64,\n            'n_fft': 2048,\n            'hop_length': int(22050 * 20 / 1000),\n            'win_length': int(22050 * 40 / 1000)\n        }\n        self.EPS = np.spacing(1)\n        self.clip_model, _ = clip.load(\"ViT-B/32\", device=self.device)\n        self.event_labels = event_labels\n        self.id_to_event =  {i : label for i, label in enumerate(self.event_labels)}\n        config = torch.load('audio_detection/target_sound_detection/useful_ckpts/tsd/run_config.pth', map_location='cpu')\n        config_parameters = dict(config)\n        config_parameters['tao'] = 0.6\n        if 'thres' not in config_parameters.keys():\n            config_parameters['thres'] = 0.5\n        if 'time_resolution' not in config_parameters.keys():\n            config_parameters['time_resolution'] = 125\n        model_parameters = torch.load('audio_detection/target_sound_detection/useful_ckpts/tsd/run_model_7_loss=-0.0724.pt'\n                                        , map_location=lambda storage, loc: storage) # load parameter \n        self.model = getattr(tsd_models, config_parameters['model'])(config_parameters,\n                    inputdim=64, outputdim=2, time_resolution=config_parameters['time_resolution'], **config_parameters['model_args'])\n        self.model.load_state_dict(model_parameters)\n        self.model = self.model.to(self.device).eval()\n        self.re_embeds = torch.load('audio_detection/target_sound_detection/useful_ckpts/tsd/text_emb.pth')\n        self.ref_mel = torch.load('audio_detection/target_sound_detection/useful_ckpts/tsd/ref_mel.pth')\n\n    def extract_feature(self, fname):\n        import soundfile as sf\n        y, sr = sf.read(fname, dtype='float32')\n        print('y ', y.shape)\n        ti = y.shape[0]/sr\n        if y.ndim > 1:\n            y = y.mean(1)\n        y = librosa.resample(y, sr, 22050)\n        lms_feature = np.log(librosa.feature.melspectrogram(y, **self.MEL_ARGS) + self.EPS).T\n        return lms_feature,ti\n    \n    def build_clip(self, text):\n        text = clip.tokenize(text).to(self.device) # [\"a diagram with dog\", \"a dog\", \"a cat\"]\n        text_features = self.clip_model.encode_text(text)\n        return text_features\n    \n    def cal_similarity(self, target, retrievals):\n        ans = []\n        #target =torch.from_numpy(target)\n        for name in retrievals.keys():\n            tmp = retrievals[name]\n            #tmp = torch.from_numpy(tmp)\n            s = torch.cosine_similarity(target.squeeze(), tmp.squeeze(), dim=0)\n            ans.append(s.item())\n        return ans.index(max(ans))\n    \n    def inference(self, text, audio_path):\n        from target_sound_detection.src.utils import median_filter, decode_with_timestamps\n\n        target_emb = self.build_clip(text) # torch type\n        idx = self.cal_similarity(target_emb, self.re_embeds)\n        target_event = self.id_to_event[idx]\n        embedding = self.ref_mel[target_event]\n        embedding = torch.from_numpy(embedding)\n        embedding = embedding.unsqueeze(0).to(self.device).float()\n        #print('embedding ', embedding.shape)\n        inputs,ti = self.extract_feature(audio_path)\n        #print('ti ', ti)\n        inputs = torch.from_numpy(inputs)\n        inputs = inputs.unsqueeze(0).to(self.device).float()\n        #print('inputs ', inputs.shape)\n        decision, decision_up, logit = self.model(inputs, embedding)\n        pred = decision_up.detach().cpu().numpy()\n        pred = pred[:,:,0]\n        frame_num = decision_up.shape[1]\n        time_ratio = ti / frame_num\n        filtered_pred = median_filter(pred, window_size=1, threshold=0.5)\n        #print('filtered_pred ', filtered_pred)\n        time_predictions = []\n        for index_k in range(filtered_pred.shape[0]):\n            decoded_pred = []\n            decoded_pred_ = decode_with_timestamps(target_event, filtered_pred[index_k,:])\n            if len(decoded_pred_) == 0: # neg deal\n                decoded_pred_.append((target_event, 0, 0))\n            decoded_pred.append(decoded_pred_)\n            for num_batch in range(len(decoded_pred)): # when we test our model,the batch_size is 1\n                cur_pred = pred[num_batch]\n                # Save each frame output, for later visualization\n                label_prediction = decoded_pred[num_batch] # frame predict\n                # print(label_prediction)\n                for event_label, onset, offset in label_prediction:\n                    time_predictions.append({\n                        'onset': onset*time_ratio,\n                        'offset': offset*time_ratio,})\n        ans = ''\n        for i,item in enumerate(time_predictions):\n            ans = ans + 'segment' + str(i+1) + ' start_time: ' + str(item['onset']) + '  end_time: ' + str(item['offset']) + '\\t'\n        #print(ans)\n        return ans\n\n# class Speech_Enh_SS_SC:\n#     \"\"\"Speech Enhancement or Separation in single-channel\n#     Example usage:\n#         enh_model = Speech_Enh_SS(\"cuda\")\n#         enh_wav = enh_model.inference(\"./test_chime4_audio_M05_440C0213_PED_REAL.wav\")\n#     \"\"\"\n#     def __init__(self, device=\"cuda\", model_name=\"lichenda/chime4_fasnet_dprnn_tac\"):\n#         self.model_name = model_name\n#         self.device = device\n#         print(\"Initializing ESPnet Enh to %s\" % device)\n#         self._initialize_model()\n\n#     def _initialize_model(self):\n#         from espnet_model_zoo.downloader import ModelDownloader\n#         from espnet2.bin.enh_inference import SeparateSpeech\n\n#         d = ModelDownloader()\n\n#         cfg = d.download_and_unpack(self.model_name)\n#         self.separate_speech = SeparateSpeech(\n#             train_config=cfg[\"train_config\"],\n#             model_file=cfg[\"model_file\"],\n#             # for segment-wise process on long speech\n#             segment_size=2.4,\n#             hop_size=0.8,\n#             normalize_segment_scale=False,\n#             show_progressbar=True,\n#             ref_channel=None,\n#             normalize_output_wav=True,\n#             device=self.device,\n#         )\n\n#     def inference(self, speech_path, ref_channel=0):\n#         speech, sr = soundfile.read(speech_path)\n#         speech = speech[:, ref_channel]\n#         assert speech.dim() == 1\n\n#         enh_speech = self.separate_speech(speech[None, ], fs=sr)\n#         if len(enh_speech) == 1:\n#             return enh_speech[0]\n#         return enh_speech\n\n# class Speech_Enh_SS_MC:\n#     \"\"\"Speech Enhancement or Separation in multi-channel\"\"\"\n#     def __init__(self, device=\"cuda\", model_name=None, ref_channel=4):\n#         self.model_name = model_name\n#         self.ref_channel = ref_channel\n#         self.device = device\n#         print(\"Initializing ESPnet Enh to %s\" % device)\n#         self._initialize_model()\n\n#     def _initialize_model(self):\n#         from espnet_model_zoo.downloader import ModelDownloader\n#         from espnet2.bin.enh_inference import SeparateSpeech\n\n#         d = ModelDownloader()\n\n#         cfg = d.download_and_unpack(self.model_name)\n#         self.separate_speech = SeparateSpeech(\n#             train_config=cfg[\"train_config\"],\n#             model_file=cfg[\"model_file\"],\n#             # for segment-wise process on long speech\n#             segment_size=2.4,\n#             hop_size=0.8,\n#             normalize_segment_scale=False,\n#             show_progressbar=True,\n#             ref_channel=self.ref_channel,\n#             normalize_output_wav=True,\n#             device=self.device,\n#         )\n\n#     def inference(self, speech_path):\n#         speech, sr = soundfile.read(speech_path)\n#         speech = speech.T\n\n#         enh_speech = self.separate_speech(speech[None, ...], fs=sr)\n#         if len(enh_speech) == 1:\n#             return enh_speech[0]\n#         return enh_speech\n\nclass Speech_Enh_SS_SC:\n    \"\"\"Speech Enhancement or Separation in single-channel\n    Example usage:\n        enh_model = Speech_Enh_SS(\"cuda\")\n        enh_wav = enh_model.inference(\"./test_chime4_audio_M05_440C0213_PED_REAL.wav\")\n    \"\"\"\n    def __init__(self, device=\"cuda\", model_name=\"espnet/Wangyou_Zhang_chime4_enh_train_enh_conv_tasnet_raw\"):\n        self.model_name = model_name\n        self.device = device\n        print(\"Initializing ESPnet Enh to %s\" % device)\n        self._initialize_model()\n\n    def _initialize_model(self):\n        from espnet_model_zoo.downloader import ModelDownloader\n        from espnet2.bin.enh_inference import SeparateSpeech\n\n        d = ModelDownloader()\n\n        cfg = d.download_and_unpack(self.model_name)\n        self.separate_speech = SeparateSpeech(\n            train_config=cfg[\"train_config\"],\n            model_file=cfg[\"model_file\"],\n            # for segment-wise process on long speech\n            segment_size=2.4,\n            hop_size=0.8,\n            normalize_segment_scale=False,\n            show_progressbar=True,\n            ref_channel=None,\n            normalize_output_wav=True,\n            device=self.device,\n        )\n\n    def inference(self, speech_path, ref_channel=0):\n        speech, sr = soundfile.read(speech_path)\n        speech = speech[:, ref_channel]\n        # speech = torch.from_numpy(speech)\n        # assert speech.dim() == 1\n        enh_speech = self.separate_speech(speech[None, ...], fs=sr)\n        audio_filename = os.path.join('audio', str(uuid.uuid4())[0:8] + \".wav\")\n        # if len(enh_speech) == 1:\n        soundfile.write(audio_filename, enh_speech[0].squeeze(), samplerate=sr)\n            # return enh_speech[0]\n        # return enh_speech\n        # else: \n        #     print(\"############\")\n        #     audio_filename_1 = os.path.join('audio', str(uuid.uuid4())[0:8] + \".wav\")\n        #     soundfile.write(audio_filename_1, enh_speech[0].squeeze(), samplerate=sr)\n        #     audio_filename_2 = os.path.join('audio', str(uuid.uuid4())[0:8] + \".wav\")\n        #     soundfile.write(audio_filename_2, enh_speech[1].squeeze(), samplerate=sr)\n        #     audio_filename = merge_audio(audio_filename_1, audio_filename_2)\n        return audio_filename\n\nclass Speech_SS:\n    def __init__(self, device=\"cuda\", model_name=\"lichenda/wsj0_2mix_skim_noncausal\"):\n        self.model_name = model_name\n        self.device = device\n        print(\"Initializing ESPnet SS to %s\" % device)\n        self._initialize_model()\n\n    def _initialize_model(self):\n        from espnet_model_zoo.downloader import ModelDownloader\n        from espnet2.bin.enh_inference import SeparateSpeech\n\n        d = ModelDownloader()\n\n        cfg = d.download_and_unpack(self.model_name)\n        self.separate_speech = SeparateSpeech(\n            train_config=cfg[\"train_config\"],\n            model_file=cfg[\"model_file\"],\n            # for segment-wise process on long speech\n            segment_size=2.4,\n            hop_size=0.8,\n            normalize_segment_scale=False,\n            show_progressbar=True,\n            ref_channel=None,\n            normalize_output_wav=True,\n            device=self.device,\n        )\n\n    def inference(self, speech_path):\n        speech, sr = soundfile.read(speech_path)\n        enh_speech = self.separate_speech(speech[None, ...], fs=sr)\n        audio_filename = os.path.join('audio', str(uuid.uuid4())[0:8] + \".wav\")\n        if len(enh_speech) == 1:\n            soundfile.write(audio_filename, enh_speech[0], samplerate=sr)\n        else:\n            # print(\"############\")\n            audio_filename_1 = os.path.join('audio', str(uuid.uuid4())[0:8] + \".wav\")\n            soundfile.write(audio_filename_1, enh_speech[0].squeeze(), samplerate=sr)\n            audio_filename_2 = os.path.join('audio', str(uuid.uuid4())[0:8] + \".wav\")\n            soundfile.write(audio_filename_2, enh_speech[1].squeeze(), samplerate=sr)\n            audio_filename = merge_audio(audio_filename_1, audio_filename_2)\n        return audio_filename\n\nclass ConversationBot:\n    def __init__(self):\n        print(\"Initializing AudioGPT\")\n        self.llm = OpenAI(temperature=0)\n        self.t2i = T2I(device=\"cuda:1\")\n        self.i2t = ImageCaptioning(device=\"cuda:0\")\n        self.t2a = T2A(device=\"cuda:0\")\n        self.tts = TTS(device=\"cpu\")\n        self.t2s = T2S(device=\"cpu\")\n        self.i2a = I2A(device=\"cuda:0\")\n        self.a2t = A2T(device=\"cpu\")\n        self.asr = ASR(device=\"cuda:0\")\n        self.SE_SS_SC = Speech_Enh_SS_SC(device=\"cuda:0\")\n        # self.SE_SS_MC = Speech_Enh_SS_MC(device=\"cuda:0\")\n        self.SS = Speech_SS(device=\"cuda:0\")\n        self.inpaint = Inpaint(device=\"cuda:0\")\n        self.tts_ood = TTS_OOD(device=\"cpu\")\n        self.geneface = GeneFace(device=\"cuda:0\")\n        self.detection = SoundDetection(device=\"cpu\")\n        self.binaural = Binaural(device=\"cuda:0\")\n        self.extraction = SoundExtraction(device=\"cuda:0\")\n        self.TSD = TargetSoundDetection(device=\"cuda:0\")\n        self.memory = ConversationBufferMemory(memory_key=\"chat_history\", output_key='output')\n\n    def init_tools(self, interaction_type):\n        if interaction_type == 'text':\n            self.tools = [\n                Tool(name=\"Generate Image From User Input Text\", func=self.t2i.inference,\n                     description=\"useful for when you want to generate an image from a user input text and it saved it to a file. like: generate an image of an object or something, or generate an image that includes some objects. \"\n                                 \"The input to this tool should be a string, representing the text used to generate image. \"),\n                Tool(name=\"Get Photo Description\", func=self.i2t.inference,\n                     description=\"useful for when you want to know what is inside the photo. receives image_path as input. \"\n                                 \"The input to this tool should be a string, representing the image_path. \"),\n                Tool(name=\"Generate Audio From User Input Text\", func=self.t2a.inference,\n                     description=\"useful for when you want to generate an audio from a user input text and it saved it to a file.\"\n                                 \"The input to this tool should be a string, representing the text used to generate audio.\"),\n                Tool(\n                    name=\"Style Transfer\", func= self.tts_ood.inference,\n                    description=\"useful for when you want to generate speech samples with styles (e.g., timbre, emotion, and prosody) derived from a reference custom voice.\"\n                                \"Like: Generate a speech with style transferred from this voice. The text is xxx., or speak using the voice of this audio. The text is xxx.\"\n                                \"The input to this tool should be a comma seperated string of two, representing reference audio path and input text.\"),\n                Tool(name=\"Generate Singing Voice From User Input Text, Note and Duration Sequence\", func= self.t2s.inference,\n                     description=\"useful for when you want to generate a piece of singing voice (Optional: from User Input Text, Note and Duration Sequence) and save it to a file.\"\n                                 \"If Like: Generate a piece of singing voice, the input to this tool should be \\\"\\\" since there is no User Input Text, Note and Duration Sequence .\"\n                                 \"If Like: Generate a piece of singing voice. Text: xxx, Note: xxx, Duration: xxx. \"\n                                 \"Or Like: Generate a piece of singing voice. Text is xxx, note is xxx, duration is xxx.\"\n                                 \"The input to this tool should be a comma seperated string of three, representing text, note and duration sequence since User Input Text, Note and Duration Sequence are all provided.\"),\n                Tool(name=\"Synthesize Speech Given the User Input Text\", func=self.tts.inference,\n                     description=\"useful for when you want to convert a user input text into speech audio it saved it to a file.\"\n                                 \"The input to this tool should be a string, representing the text used to be converted to speech.\"),\n                # Tool(name=\"Speech Enhancement Or Separation In Single-Channel\", func=self.SE_SS_SC.inference,\n                #      description=\"useful for when you want to enhance the quality of the speech signal by reducing background noise (single-channel), \"\n                #                  \"or separate each speech from the speech mixture (single-channel), receives audio_path as input.\"\n                #                  \"The input to this tool should be a string, representing the audio_path.\"),\n                Tool(name=\"Speech Enhancement In Single-Channel\", func=self.SE_SS_SC.inference,\n                     description=\"useful for when you want to enhance the quality of the speech signal by reducing background noise (single-channel), receives audio_path as input.\"\n                                 \"The input to this tool should be a string, representing the audio_path.\"),\n                Tool(name=\"Speech Separation In Single-Channel\", func=self.SS.inference,\n                     description=\"useful for when you want to separate each speech from the speech mixture, receives audio_path as input.\"\n                                 \"The input to this tool should be a string, representing the audio_path.\"),\n                # Tool(name=\"Speech Enhancement In Multi-Channel\", func=self.SE_SS_MC.inference,\n                #      description=\"useful for when you want to enhance the quality of the speech signal by reducing background noise (multi-channel), receives audio_path as input.\"\n                #                  \"The input to this tool should be a string, representing the audio_path.\"),                                 \n                Tool(name=\"Generate Audio From The Image\", func=self.i2a.inference,\n                     description=\"useful for when you want to generate an audio based on an image.\"\n                                  \"The input to this tool should be a string, representing the image_path. \"),\n                Tool(name=\"Generate Text From The Audio\", func=self.a2t.inference,\n                     description=\"useful for when you want to describe an audio in text, receives audio_path as input.\"\n                                 \"The input to this tool should be a string, representing the audio_path.\"), \n                Tool(name=\"Audio Inpainting\", func=self.inpaint.show_mel_fn,\n                     description=\"useful for when you want to inpaint a mel spectrum of an audio and predict this audio, this tool will generate a mel spectrum and you can inpaint it, receives audio_path as input, \"\n                                 \"The input to this tool should be a string, representing the audio_path.\"), \n                Tool(name=\"Transcribe Speech\", func=self.asr.inference,\n                     description=\"useful for when you want to know the text corresponding to a human speech, receives audio_path as input.\"\n                                 \"The input to this tool should be a string, representing the audio_path.\"),\n                Tool(name=\"Generate a talking human portrait video given a input Audio\", func=self.geneface.inference,\n                     description=\"useful for when you want to generate a talking human portrait video given a input audio.\"\n                                 \"The input to this tool should be a string, representing the audio_path.\"),\n                Tool(name=\"Detect The Sound Event From The Audio\", func=self.detection.inference,\n                     description=\"useful for when you want to know what event in the audio and the sound event start or end time, this tool will generate an image of all predict events, receives audio_path as input. \"\n                                 \"The input to this tool should be a string, representing the audio_path. \"),\n                Tool(name=\"Sythesize Binaural Audio From A Mono Audio Input\", func=self.binaural.inference,\n                     description=\"useful for when you want to transfer your mono audio into binaural audio, receives audio_path as input. \"\n                                 \"The input to this tool should be a string, representing the audio_path. \"),\n                Tool(name=\"Extract Sound Event From Mixture Audio Based On Language Description\", func=self.extraction.inference,\n                     description=\"useful for when you extract target sound from a mixture audio, you can describe the target sound by text, receives audio_path and text as input. \"\n                                 \"The input to this tool should be a comma seperated string of two, representing mixture audio path and input text.\"),\n                Tool(name=\"Target Sound Detection\", func=self.TSD.inference,\n                     description=\"useful for when you want to know when the target sound event in the audio happens. You can use language descriptions to instruct the model. receives text description and audio_path as input. \"\n                                 \"The input to this tool should be a comma seperated string of two, representing audio path and the text description. \")]       \n\n            self.agent = initialize_agent(\n                self.tools,\n                self.llm,\n                agent=\"conversational-react-description\",\n                verbose=True,\n                memory=self.memory,\n                return_intermediate_steps=True,\n                agent_kwargs={'prefix': AUDIO_CHATGPT_PREFIX, 'format_instructions': AUDIO_CHATGPT_FORMAT_INSTRUCTIONS, 'suffix': AUDIO_CHATGPT_SUFFIX}, )\n\n            return gr.update(visible=True), gr.update(visible=False), gr.update(visible=True), gr.update(visible=False)\n        else:\n            self.tools = [\n                Tool(name=\"Generate Audio From User Input Text\", func=self.t2a.inference,\n                     description=\"useful for when you want to generate an audio from a user input text and it saved it to a file.\"\n                                 \"The input to this tool should be a string, representing the text used to generate audio.\"),\n                Tool(\n                    name=\"Style Transfer\", func= self.tts_ood.inference,\n                    description=\"useful for when you want to generate speech samples with styles (e.g., timbre, emotion, and prosody) derived from a reference custom voice.\"\n                                \"Like: Generate a speech with style transferred from this voice. The text is xxx., or speak using the voice of this audio. The text is xxx.\"\n                                \"The input to this tool should be a comma seperated string of two, representing reference audio path and input text.\"),\n                Tool(name=\"Generate Singing Voice From User Input Text, Note and Duration Sequence\", func= self.t2s.inference,\n                     description=\"useful for when you want to generate a piece of singing voice (Optional: from User Input Text, Note and Duration Sequence) and save it to a file.\"\n                                 \"If Like: Generate a piece of singing voice, the input to this tool should be \\\"\\\" since there is no User Input Text, Note and Duration Sequence .\"\n                                 \"If Like: Generate a piece of singing voice. Text: xxx, Note: xxx, Duration: xxx. \"\n                                 \"Or Like: Generate a piece of singing voice. Text is xxx, note is xxx, duration is xxx.\"\n                                 \"The input to this tool should be a comma seperated string of three, representing text, note and duration sequence since User Input Text, Note and Duration Sequence are all provided.\"),\n                Tool(name=\"Synthesize Speech Given the User Input Text\", func=self.tts.inference,\n                     description=\"useful for when you want to convert a user input text into speech audio it saved it to a file.\"\n                                 \"The input to this tool should be a string, representing the text used to be converted to speech.\"),\n                Tool(name=\"Generate Text From The Audio\", func=self.a2t.inference,\n                     description=\"useful for when you want to describe an audio in text, receives audio_path as input.\"\n                                 \"The input to this tool should be a string, representing the audio_path.\"), \n                Tool(name=\"Generate a talking human portrait video given a input Audio\", func=self.geneface.inference,\n                     description=\"useful for when you want to generate a talking human portrait video given a input audio.\"\n                                 \"The input to this tool should be a string, representing the audio_path.\"),\n                Tool(name=\"Generate Binaural Audio From A Mono Audio Input\", func=self.binaural.inference,\n                     description=\"useful for when you want to transfer your mono audio into binaural audio, receives audio_path as input. \"\n                                 \"The input to this tool should be a string, representing the audio_path. \"),\n                Tool(name=\"Extract Sound Event From Mixture Audio Based On Language Description\", func=self.extraction.inference,\n                     description=\"useful for when you extract target sound from a mixture audio, you can describe the target sound by text, receives audio_path and text as input. \"\n                                 \"The input to this tool should be a comma seperated string of two, representing mixture audio path and input text.\"),\n                Tool(name=\"Target Sound Detection\", func=self.TSD.inference,\n                     description=\"useful for when you want to know when the target sound event in the audio happens. You can use language descriptions to instruct the model. receives text description and audio_path as input. \"\n                                 \"The input to this tool should be a comma seperated string of two, representing audio path and the text description. \")]                \n            self.agent = initialize_agent(\n                self.tools,\n                self.llm,\n                agent=\"conversational-react-description\",\n                verbose=True,\n                memory=self.memory,\n                return_intermediate_steps=True,\n                agent_kwargs={'prefix': AUDIO_CHATGPT_PREFIX, 'format_instructions': AUDIO_CHATGPT_FORMAT_INSTRUCTIONS, 'suffix': AUDIO_CHATGPT_SUFFIX}, )\n\n            return gr.update(visible=False), gr.update(visible=False), gr.update(visible=False), gr.update(visible=True)\n\n    def run_text(self, text, state):\n        print(\"===============Running run_text =============\")\n        print(\"Inputs:\", text, state)\n        print(\"======>Previous memory:\\n %s\" % self.agent.memory)\n        self.agent.memory.buffer = cut_dialogue_history(self.agent.memory.buffer, keep_last_n_words=500)\n        res = self.agent({\"input\": text})\n        if res['intermediate_steps'] == []:\n            print(\"======>Current memory:\\n %s\" % self.agent.memory)\n            response = res['output']\n            state = state + [(text, response)]\n            print(\"Outputs:\", state)\n            return state, state, gr.Audio.update(visible=False), gr.Video.update(visible=False), gr.Image.update(visible=False), gr.Button.update(visible=False)\n        else:\n            tool = res['intermediate_steps'][0][0].tool\n            if tool == \"Generate Image From User Input Text\" or tool == \"Generate Text From The Audio\" or tool == \"Target Sound Detection\":\n                print(\"======>Current memory:\\n %s\" % self.agent.memory)\n                response = re.sub('(image/\\S*png)', lambda m: f'![](/file={m.group(0)})*{m.group(0)}*', res['output'])\n                state = state + [(text, response)]\n                print(\"Outputs:\", state)\n                return state, state, gr.Audio.update(visible=False), gr.Video.update(visible=False), gr.Image.update(visible=False), gr.Button.update(visible=False)\n            elif tool == \"Transcribe Speech\":\n                response = res['output']\n                state = state + [(text, response)]\n                print(\"Outputs:\", state)\n                return state, state, gr.Audio.update(visible=False), gr.Video.update(visible=False), gr.Image.update(visible=False), gr.Button.update(visible=False)\n            elif tool == \"Detect The Sound Event From The Audio\":\n                image_filename = res['intermediate_steps'][0][1]\n                response = res['output'] + f\"![](/file={image_filename})*{image_filename}*\"\n                state = state + [(text, response)]\n                print(\"Outputs:\", state)\n                return state, state, gr.Audio.update(visible=False), gr.Video.update(visible=False), gr.Image.update(visible=False), gr.Button.update(visible=False)       \n            elif tool == \"Audio Inpainting\":\n                audio_filename = res['intermediate_steps'][0][0].tool_input\n                image_filename = res['intermediate_steps'][0][1]\n                print(\"======>Current memory:\\n %s\" % self.agent.memory)\n                response = res['output']\n                state = state + [(text, response)]\n                print(\"Outputs:\", state)\n                return state, state, gr.Audio.update(value=audio_filename,visible=True), gr.Video.update(visible=False), gr.Image.update(value=image_filename,visible=True), gr.Button.update(visible=True)\n            elif tool == \"Generate a talking human portrait video given a input Audio\":\n                video_filename = res['intermediate_steps'][0][1]\n                print(\"======>Current memory:\\n %s\" % self.agent.memory)\n                response = res['output'] \n                state = state + [(text, response)]\n                print(\"Outputs:\", state)\n                return state, state, gr.Audio.update(visible=False), gr.Video.update(value=video_filename,visible=True), gr.Image.update(visible=False), gr.Button.update(visible=False)\n            print(\"======>Current memory:\\n %s\" % self.agent.memory)\n            response = re.sub('(image/\\S*png)', lambda m: f'![](/file={m.group(0)})*{m.group(0)}*', res['output'])\n            audio_filename = res['intermediate_steps'][0][1]\n            state = state + [(text, response)]\n            print(\"Outputs:\", state)\n            return state, state, gr.Audio.update(value=audio_filename,visible=True), gr.Video.update(visible=False), gr.Image.update(visible=False), gr.Button.update(visible=False)\n\n    def run_image_or_audio(self, file, state, txt):\n        file_type = file.name[-3:]\n        if file_type == \"wav\":\n            print(\"===============Running run_audio =============\")\n            print(\"Inputs:\", file, state)\n            print(\"======>Previous memory:\\n %s\" % self.agent.memory)\n            audio_filename = os.path.join('audio', str(uuid.uuid4())[0:8] + \".wav\")\n            # audio_load = whisper.load_audio(file.name)\n            audio_load, sr = soundfile.read(file.name)\n            soundfile.write(audio_filename, audio_load, samplerate = sr)\n            description = self.a2t.inference(audio_filename)\n            Human_prompt = \"\\nHuman: provide an audio named {}. The description is: {}. This information helps you to understand this audio, but you should use tools to finish following tasks, \" \\\n                           \"rather than directly imagine from my description. If you understand, say \\\"Received\\\". \\n\".format(audio_filename, description)\n            AI_prompt = \"Received.  \"\n            self.agent.memory.buffer = self.agent.memory.buffer + Human_prompt + 'AI: ' + AI_prompt\n            print(\"======>Current memory:\\n %s\" % self.agent.memory)\n            #state = state + [(f\"<audio src=audio_filename controls=controls></audio>*{audio_filename}*\", AI_prompt)]\n            state = state + [(f\"*{audio_filename}*\", AI_prompt)]\n            print(\"Outputs:\", state)\n            return state, state, gr.Audio.update(value=audio_filename,visible=True), gr.Video.update(visible=False)\n        else:\n            print(\"===============Running run_image =============\")\n            print(\"Inputs:\", file, state)\n            print(\"======>Previous memory:\\n %s\" % self.agent.memory)\n            image_filename = os.path.join('image', str(uuid.uuid4())[0:8] + \".png\")\n            print(\"======>Auto Resize Image...\")\n            img = Image.open(file.name)\n            width, height = img.size\n            ratio = min(512 / width, 512 / height)\n            width_new, height_new = (round(width * ratio), round(height * ratio))\n            img = img.resize((width_new, height_new))\n            img = img.convert('RGB')\n            img.save(image_filename, \"PNG\")\n            print(f\"Resize image form {width}x{height} to {width_new}x{height_new}\")\n            description = self.i2t.inference(image_filename)\n            Human_prompt = \"\\nHuman: provide a figure named {}. The description is: {}. This information helps you to understand this image, but you should use tools to finish following tasks, \" \\\n                           \"rather than directly imagine from my description. If you understand, say \\\"Received\\\". \\n\".format(image_filename, description)\n            AI_prompt = \"Received.  \"\n            self.agent.memory.buffer = self.agent.memory.buffer + Human_prompt + 'AI: ' + AI_prompt\n            print(\"======>Current memory:\\n %s\" % self.agent.memory)\n            state = state + [(f\"![](/file={image_filename})*{image_filename}*\", AI_prompt)]\n            print(\"Outputs:\", state)\n            return state, state, gr.Audio.update(visible=False), gr.Video.update(visible=False)\n\n    def speech(self, speech_input, state):\n        input_audio_filename = os.path.join('audio', str(uuid.uuid4())[0:8] + \".wav\")\n        text = self.asr.translate_english(speech_input)\n        print(\"Inputs:\", text, state)\n        print(\"======>Previous memory:\\n %s\" % self.agent.memory)\n        self.agent.memory.buffer = cut_dialogue_history(self.agent.memory.buffer, keep_last_n_words=500)\n        res = self.agent({\"input\": text})\n        if res['intermediate_steps'] == []:\n            print(\"======>Current memory:\\n %s\" % self.agent.memory)\n            response = res['output']\n            output_audio_filename = self.tts.inference(response)\n            state = state + [(text, response)]\n            print(\"Outputs:\", state)\n            return gr.Audio.update(value=None), gr.Audio.update(value=output_audio_filename,visible=True), state, gr.Video.update(visible=False)\n        else:\n            tool = res['intermediate_steps'][0][0].tool\n            if tool == \"Generate Image From User Input Text\" or tool == \"Generate Text From The Audio\" or tool == \"Target Sound Detection\":\n                print(\"======>Current memory:\\n %s\" % self.agent.memory)\n                response = re.sub('(image/\\S*png)', lambda m: f'![](/file={m.group(0)})*{m.group(0)}*', res['output'])\n                output_audio_filename = self.tts.inference(res['output'])\n                state = state + [(text, response)]\n                print(\"Outputs:\", state)\n                return gr.Audio.update(value=None), gr.Audio.update(value=output_audio_filename,visible=True), state, gr.Video.update(visible=False)\n            elif tool == \"Transcribe Speech\":\n                print(\"======>Current memory:\\n %s\" % self.agent.memory)\n                output_audio_filename = self.tts.inference(res['output'])\n                response = res['output']\n                state = state + [(text, response)]\n                print(\"Outputs:\", state)\n                return gr.Audio.update(value=None), gr.Audio.update(value=output_audio_filename,visible=True), state, gr.Video.update(visible=False)\n            elif tool == \"Detect The Sound Event From The Audio\":\n                print(\"======>Current memory:\\n %s\" % self.agent.memory)\n                image_filename = res['intermediate_steps'][0][1]\n                output_audio_filename = self.tts.inference(res['output'])\n                response = res['output'] + f\"![](/file={image_filename})*{image_filename}*\"\n                state = state + [(text, response)]\n                print(\"Outputs:\", state)\n                return gr.Audio.update(value=None), gr.Audio.update(value=output_audio_filename,visible=True), state, gr.Video.update(visible=False)   \n            elif tool == \"Generate a talking human portrait video given a input Audio\":\n                video_filename = res['intermediate_steps'][0][1]\n                print(\"======>Current memory:\\n %s\" % self.agent.memory)\n                response = res['output'] \n                output_audio_filename = self.tts.inference(res['output'])\n                state = state + [(text, response)]\n                print(\"Outputs:\", state)\n                return gr.Audio.update(value=None), gr.Audio.update(value=output_audio_filename,visible=True), state, gr.Video.update(value=video_filename,visible=True)\n            print(\"======>Current memory:\\n %s\" % self.agent.memory)\n            response = re.sub('(image/\\S*png)', lambda m: f'![](/file={m.group(0)})*{m.group(0)}*', res['output'])\n            audio_filename = res['intermediate_steps'][0][1]\n            Res = \"The audio file has been generated and the audio is \"\n            output_audio_filename = merge_audio(self.tts.inference(Res), audio_filename)\n            print(output_audio_filename)\n            state = state + [(text, response)]\n            response = res['output'] \n            print(\"Outputs:\", state)\n            return gr.Audio.update(value=None), gr.Audio.update(value=output_audio_filename,visible=True), state, gr.Video.update(visible=False)\n\n    def inpainting(self, state, audio_filename, image_filename):\n        print(\"===============Running inpainting =============\")\n        print(\"Inputs:\", state)\n        print(\"======>Previous memory:\\n %s\" % self.agent.memory)\n        new_image_filename, new_audio_filename = self.inpaint.inference(audio_filename, image_filename)       \n        AI_prompt = \"Here are the predict audio and the mel spectrum.\" + f\"*{new_audio_filename}*\" + f\"![](/file={new_image_filename})*{new_image_filename}*\"\n        output_audio_filename = self.tts.inference(AI_prompt)\n        self.agent.memory.buffer = self.agent.memory.buffer + 'AI: ' + AI_prompt\n        print(\"======>Current memory:\\n %s\" % self.agent.memory)\n        state = state + [(f\"Audio Inpainting\", AI_prompt)]\n        print(\"Outputs:\", state)\n        return state, state, gr.Image.update(visible=False), gr.Audio.update(value=new_audio_filename, visible=True), gr.Video.update(visible=False), gr.Button.update(visible=False)\n\n    def clear_audio(self):\n        return gr.Audio.update(value=None, visible=False)\n    def clear_input_audio(self):\n        return gr.Audio.update(value=None)\n    def clear_image(self):\n        return gr.Image.update(value=None, visible=False)\n    def clear_video(self):\n        return gr.Video.update(value=None, visible=False)\n    def clear_button(self):\n        return gr.Button.update(visible=False)\n\n\nif __name__ == '__main__':\n    bot = ConversationBot()\n    with gr.Blocks(css=\"#chatbot .overflow-y-auto{height:500px}\") as demo:\n        with gr.Row():\n            gr.Markdown(\"## AudioGPT\")\n        chatbot = gr.Chatbot(elem_id=\"chatbot\", label=\"AudioGPT\", visible=False) \n        state = gr.State([])\n\n        with gr.Row() as select_raws:\n            with gr.Column(scale=0.7):\n                interaction_type = gr.Radio(choices=['text', 'speech'], value='text', label='Interaction Type')\n            with gr.Column(scale=0.3, min_width=0):\n                select = gr.Button(\"Select\")\n        \n        with gr.Row(visible=False) as text_input_raws:\n            with gr.Column(scale=0.7):\n                txt = gr.Textbox(show_label=False, placeholder=\"Enter text and press enter, or upload an image\").style(container=False)\n            with gr.Column(scale=0.1, min_width=0):\n                run = gr.Button(\"🏃‍♂️Run\")\n            with gr.Column(scale=0.1, min_width=0):\n                clear_txt = gr.Button(\"🔄Clear️\")\n            with gr.Column(scale=0.1, min_width=0):\n                btn = gr.UploadButton(\"🖼️Upload\", file_types=[\"image\",\"audio\"])\n\n        with gr.Row():\n            outaudio = gr.Audio(visible=False)\n        with gr.Row():\n            with gr.Column(scale=0.3, min_width=0):\n                outvideo = gr.Video(visible=False)\n        with gr.Row():\n            show_mel = gr.Image(type=\"filepath\",tool='sketch',visible=False)\n        with gr.Row():\n            run_button = gr.Button(\"Predict Masked Place\",visible=False)        \n\n        with gr.Row(visible=False) as speech_input_raws: \n            with gr.Column(scale=0.7):\n                speech_input = gr.Audio(source=\"microphone\", type=\"filepath\", label=\"Input\")\n            with gr.Column(scale=0.15, min_width=0):\n                submit_btn = gr.Button(\"🏃‍♂️Submit\")\n            with gr.Column(scale=0.15, min_width=0):\n                clear_speech = gr.Button(\"🔄Clear️\")\n            with gr.Row():\n                speech_output = gr.Audio(label=\"Output\",visible=False)\n\n        select.click(bot.init_tools, [interaction_type], [chatbot, select_raws, text_input_raws, speech_input_raws])\n\n        txt.submit(bot.run_text, [txt, state], [chatbot, state, outaudio, outvideo, show_mel, run_button])\n        txt.submit(lambda: \"\", None, txt)\n        run.click(bot.run_text, [txt, state], [chatbot, state, outaudio, outvideo, show_mel, run_button])\n        run.click(lambda: \"\", None, txt)\n        btn.upload(bot.run_image_or_audio, [btn, state, txt], [chatbot, state, outaudio, outvideo])\n        run_button.click(bot.inpainting, [state, outaudio, show_mel], [chatbot, state, show_mel, outaudio, outvideo, run_button])\n        clear_txt.click(bot.memory.clear)\n        clear_txt.click(lambda: [], None, chatbot)\n        clear_txt.click(lambda: [], None, state)\n        clear_txt.click(lambda:None, None, txt)\n        clear_txt.click(bot.clear_button, None, run_button)\n        clear_txt.click(bot.clear_image, None, show_mel)\n        clear_txt.click(bot.clear_audio, None, outaudio)\n        clear_txt.click(bot.clear_video, None, outvideo)\n\n        submit_btn.click(bot.speech, [speech_input, state], [speech_input, speech_output, state, outvideo])\n        clear_speech.click(bot.clear_input_audio, None, speech_input)\n        clear_speech.click(bot.clear_audio, None, speech_output)\n        clear_speech.click(lambda: [], None, state)\n        clear_speech.click(bot.clear_video, None, outvideo)\n\n        demo.launch(server_name=\"0.0.0.0\", server_port=7860, share=True)"
        },
        {
          "name": "audio_detection",
          "type": "tree",
          "content": null
        },
        {
          "name": "audio_to_text",
          "type": "tree",
          "content": null
        },
        {
          "name": "download.sh",
          "type": "blob",
          "size": 5.0419921875,
          "content": "mkdir checkpoints\nmkdir audio\nmkdir image\nmkdir text_to_audio\n#  Text to sing\nwget -P checkpoints/0831_opencpop_ds1000/ -i https://huggingface.co/spaces/Silentlin/DiffSinger/resolve/main/checkpoints/0831_opencpop_ds1000/config.yaml https://huggingface.co/spaces/Silentlin/DiffSinger/resolve/main/checkpoints/0831_opencpop_ds1000/model_ckpt_steps_320000.ckpt\nwget -P checkpoints/0109_hifigan_bigpopcs_hop128/ -i https://huggingface.co/spaces/Silentlin/DiffSinger/blob/main/checkpoints/0109_hifigan_bigpopcs_hop128/config.yaml https://huggingface.co/spaces/Silentlin/DiffSinger/resolve/main/checkpoints/0109_hifigan_bigpopcs_hop128/model_ckpt_steps_1512000.ckpt\nwget -P checkpoints/0102_xiaoma_pe/ -i https://huggingface.co/spaces/Silentlin/DiffSinger/blob/main/checkpoints/0102_xiaoma_pe/config.yaml https://huggingface.co/spaces/Silentlin/DiffSinger/resolve/main/checkpoints/0102_xiaoma_pe/model_ckpt_steps_60000.ckpt\n#  Text to audio\ncd text_to_audio\nwget -P text_to_audio/Make_An_Audio/useful_ckpts/ -i https://huggingface.co/spaces/DiffusionSpeech/Make_An_Audio/resolve/main/useful_ckpts/ta40multi_epoch=000085.ckpt\nwget -P text_to_audio/Make_An_Audio/useful_ckpts/CLAP/ -i https://huggingface.co/spaces/DiffusionSpeech/Make_An_Audio/resolve/main/useful_ckpts/CLAP/CLAP_weights_2022.pth\nwget -P text_to_audio/Make_An_Audio/useful_ckpts/ -i https://huggingface.co/spaces/DiffusionSpeech/Make_An_Audio_img/resolve/main/useful_ckpts/ta54_epoch=000216.ckpt\nwget -P text_to_audio/Make_An_Audio/useful_ckpts/ -i https://huggingface.co/spaces/DiffusionSpeech/Make_An_Audio_inpaint/resolve/main/useful_ckpts/inpaint7_epoch00047.ckpt\n#  Text to speech\nwget -P checkpoints/GenerSpeech/ -i https://huggingface.co/spaces/Rongjiehuang/GenerSpeech/blob/main/checkpoints/GenerSpeech/config.yaml https://huggingface.co/spaces/Rongjiehuang/GenerSpeech/resolve/main/checkpoints/GenerSpeech/model_ckpt_steps_300000.ckpt\nwget -P checkpoints/trainset_hifigan/ -i https://huggingface.co/spaces/Rongjiehuang/GenerSpeech/blob/main/checkpoints/trainset_hifigan/config.yaml https://huggingface.co/spaces/Rongjiehuang/GenerSpeech/resolve/main/checkpoints/trainset_hifigan/model_ckpt_steps_1000000.ckpt\nwget -P checkpoints/ https://huggingface.co/spaces/Rongjiehuang/GenerSpeech/resolve/main/checkpoints/Emotion_encoder.pt\nwget -P data/binary/training_set https://huggingface.co/spaces/Rongjiehuang/GenerSpeech/resolve/main/data/binary/training_set/mfa_dict.txt\nwget -P data/binary/training_set https://huggingface.co/spaces/Rongjiehuang/GenerSpeech/resolve/main/data/binary/training_set/mfa_model.zip\nwget -P data/binary/training_set https://huggingface.co/spaces/Rongjiehuang/GenerSpeech/resolve/main/data/binary/training_set/phone_set.json\nwget -P data/binary/training_set https://huggingface.co/spaces/Rongjiehuang/GenerSpeech/resolve/main/data/binary/training_set/spk_map.json\nwget -P data/binary/training_set https://huggingface.co/spaces/Rongjiehuang/GenerSpeech/resolve/main/data/binary/training_set/train_f0s_mean_std.npy\nwget -P data/binary/training_set https://huggingface.co/spaces/Rongjiehuang/GenerSpeech/resolve/main/data/binary/training_set/word_set.json\nwget -P text_to_speech/checkpoints/hifi_lj -i https://huggingface.co/AIGC-Audio/AudioGPT/blob/main/text_to_speech/checkpoints/hifi_lj/config.yaml https://huggingface.co/AIGC-Audio/AudioGPT/resolve/main/text_to_speech/checkpoints/hifi_lj/model_ckpt_steps_2076000.ckpt\nwget -P text_to_speech/checkpoints/ljspeech/ps_adv_baseline -i https://huggingface.co/AIGC-Audio/AudioGPT/blob/main/text_to_speech/checkpoints/ljspeech/ps_adv_baseline/config.yaml https://huggingface.co/AIGC-Audio/AudioGPT/resolve/main/checkpoints/ljspeech/ps_adv_baseline/model_ckpt_steps_160000.ckpt https://huggingface.co/AIGC-Audio/AudioGPT/resolve/main/checkpoints/ljspeech/ps_adv_baseline/model_ckpt_steps_160001.ckpt\n# Audio to text\nwget -P audio_to_text/audiocaps_cntrstv_cnn14rnn_trm -i https://huggingface.co/AIGC-Audio/AudioGPT/blob/main/audio_to_text/audiocaps_cntrstv_cnn14rnn_trm/config.yaml https://huggingface.co/AIGC-Audio/AudioGPT/resolve/main/audio_to_text/audiocaps_cntrstv_cnn14rnn_trm/swa.pth\nwget -P audio_to_text/clotho_cntrstv_cnn14rnn_trm -i https://huggingface.co/AIGC-Audio/AudioGPT/blob/main/audio_to_text/clotho_cntrstv_cnn14rnn_trm/config.yaml https://huggingface.co/AIGC-Audio/AudioGPT/resolve/main/audio_to_text/clotho_cntrstv_cnn14rnn_trm/swa.pth\nwget -P audio_to_text/pretrained_feature_extractors https://huggingface.co/AIGC-Audio/AudioGPT/resolve/main/audio_to_text/pretrained_feature_extractors/contrastive_pretrain_cnn14_bertm.pth\n# Audio detection\ncd audio_detection/audio_infer/useful_ckpts\nwget https://huggingface.co/Dongchao/pre_trained_model/resolve/main/audio_detection.pth\ncd mono2binaural/useful_ckpts\nwget https://huggingface.co/Dongchao/pre_trained_model/resolve/main/m2b.tar.gz\ntar -zxvf m2b.tar.gz ./\nrm m2b.tar.gz\ncd audio_detection/target_sound_detection/useful_ckpts\nwget https://huggingface.co/Dongchao/pre_trained_model/resolve/main/tsd.tar.gz\ntar -zxvf tsd.tar.gz ./\nrm tsd.tar.gz\ncd sound_extraction/useful_ckpts\nwget https://huggingface.co/Dongchao/pre_trained_model/resolve/main/LASSNet.pt"
        },
        {
          "name": "mono2binaural",
          "type": "tree",
          "content": null
        },
        {
          "name": "requirements.txt",
          "type": "blob",
          "size": 1.185546875,
          "content": "--extra-index-url https://download.pytorch.org/whl/cu113\naccelerate\naddict==2.4.0\naiofiles\nalbumentations==1.3.0\nappdirs==1.4.4\nbasicsr==1.4.2\nbeautifulsoup4==4.10.0\nCython==0.29.24\ndiffusers\neinops==0.3.0\nespnet\nespnet_model_zoo\nffmpeg-python\ng2p-en==2.1.0\ngoogle==3.0.0\ngradio\nh5py\nimageio==2.9.0\nimageio-ffmpeg==0.4.2\ninvisible-watermark>=0.1.5\njieba\nkornia==0.6\nlangchain==0.0.101\nlibrosa\nloguru\nmiditoolkit==0.1.7\nmmcv==1.5.0\nmmdet==2.23.0 \nmmengine==0.7.2\nmoviepy==1.0.3\nnumpy==1.23.1\nomegaconf==2.1.1\nopen_clip_torch==2.0.2\nopenai\nopenai-whisper\nopencv-contrib-python==4.3.0.36\npraat-parselmouth==0.3.3\nprettytable==3.6.0\nproglog==0.1.9\npycwt==0.3.0a22\npyloudnorm==0.1.0\npypinyin==0.43.0\npytorch-lightning==1.5.0\npytorch-ssim==0.1\npyworld==0.3.0\nresampy==0.2.2\nResemblyzer==0.1.1.dev0\nsafetensors==0.2.7\nsklearn==0.0\nsoundfile\nsoupsieve==2.3\nstreamlit==1.12.1\nstreamlit-drawable-canvas==0.8.0\ntensorboardX==2.4\ntest-tube>=0.7.5\nTextGrid==1.5\ntimm==0.6.12\ntorch==1.12.1\ntorchaudio==0.12.1\ntorch-fidelity==0.3.0\ntorchlibrosa\ntorchmetrics==0.6.0\ntorchvision==0.13.1\ntransformers==4.26.1\ntyping-extensions==4.0.0\nuuid==1.30\nwebdataset==0.2.5\nwebrtcvad==2.0.10\nyapf==0.32.0\ngit+https://github.com/openai/CLIP.git"
        },
        {
          "name": "run.md",
          "type": "blob",
          "size": 0.341796875,
          "content": "# Run AudioGPT\n```\n# create a new environment\nconda create -n audiogpt python=3.8\n\n#  prepare the basic environments\npip install -r requirements.txt\n\n# download the foundation models you need\nbash download.sh\n\n# prepare your private openAI private key\nexport OPENAI_API_KEY={Your_Private_Openai_Key}\n\n# Start AudioGPT !\npython audio-chatgpt.py\n```\n\n\n"
        },
        {
          "name": "sound_extraction",
          "type": "tree",
          "content": null
        },
        {
          "name": "text_to_audio",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}