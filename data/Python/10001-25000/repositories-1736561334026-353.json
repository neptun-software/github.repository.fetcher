{
  "metadata": {
    "timestamp": 1736561334026,
    "page": 353,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM2MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "NVIDIA/Megatron-LM",
      "stars": 11060,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".coveragerc",
          "type": "blob",
          "size": 0.0673828125,
          "content": "[html]\ndirectory = coverage\n\n[run]\ndata_file = .coverage_$LOCAL_RANK\n"
        },
        {
          "name": ".flake8",
          "type": "blob",
          "size": 0.1044921875,
          "content": "[flake8]\nmax-line-length = 100\nextend-ignore = E203,E501,F401,E402,E714\nper-file-ignores = __init__.py:F401"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0849609375,
          "content": "__pycache__\n*.so\nbuild\n.coverage_*\n*.egg-info\n*~\nslurm*\nlogs\n.vscode\nlocal/\n.gitmodules"
        },
        {
          "name": ".gitlab-ci.yml",
          "type": "blob",
          "size": 4.09375,
          "content": "workflow:\n  rules:\n    - if: $CI_PROJECT_NAMESPACE != \"ADLR\"\n      when: never\n    - if: $CI_COMMIT_BRANCH =~ /ci-/ && $CI_PIPELINE_SOURCE != \"schedule\"\n      when: never\n    - if: $CI_PIPELINE_SOURCE == \"schedule\"\n      auto_cancel:\n        on_new_commit: none\n    - if: $CI_PIPELINE_SOURCE == \"web\"\n    - if: $CI_COMMIT_REF_PROTECTED == \"true\"\n      variables:\n        FUNCTIONAL_TEST: 'no'\n    - if: $CI_MERGE_REQUEST_LABELS =~ /Run tests/ && $CI_MERGE_REQUEST_TARGET_BRANCH_SHA != \"\"\n      variables:\n        UNIT_TEST_REPEAT: 1\n        UNIT_TEST_TIMEOUT: 15\n        FUNCTIONAL_TEST: 'yes'\n        FUNCTIONAL_TEST_SCOPE: mr\n        FUNCTIONAL_TEST_REPEAT: 5\n        FUNCTIONAL_TEST_TIME_LIMIT: 2700\n        FUNCTIONAL_TEST_CLUSTER_A100: ''\n        FUNCTIONAL_TEST_CLUSTER_H100: ''\n        PUBLISH: 'no'\n    - if: $CI_MERGE_REQUEST_LABELS =~ /Run nightly/ && $CI_MERGE_REQUEST_TARGET_BRANCH_SHA != \"\"\n      variables:\n        UNIT_TEST_REPEAT: 1\n        UNIT_TEST_TIMEOUT: 15\n        FUNCTIONAL_TEST: 'yes'\n        FUNCTIONAL_TEST_SCOPE: nightly\n        FUNCTIONAL_TEST_REPEAT: 5\n        FUNCTIONAL_TEST_TIME_LIMIT: 2700\n        FUNCTIONAL_TEST_CLUSTER_A100: ''\n        FUNCTIONAL_TEST_CLUSTER_H100: ''\n        PUBLISH: 'no'\n    - if: $CI_MERGE_REQUEST_LABELS =~ /Run weekly/ && $CI_MERGE_REQUEST_TARGET_BRANCH_SHA != \"\"\n      variables:\n        UNIT_TEST_REPEAT: 1\n        UNIT_TEST_TIMEOUT: 15\n        FUNCTIONAL_TEST: 'yes'\n        FUNCTIONAL_TEST_SCOPE: weekly\n        FUNCTIONAL_TEST_REPEAT: 1\n        FUNCTIONAL_TEST_TIME_LIMIT: 9000\n        FUNCTIONAL_TEST_CLUSTER_A100: ''\n        FUNCTIONAL_TEST_CLUSTER_H100: ''\n        PUBLISH: 'no'\n    - if: $CI_PIPELINE_SOURCE == \"merge_request_event\" && $CI_MERGE_REQUEST_TARGET_BRANCH_SHA != \"\"\n      variables:\n        FUNCTIONAL_TEST: 'no'\n        PUBLISH: 'no'\n    - when: never\n  auto_cancel:\n    on_new_commit: interruptible\n    # on_job_failure: all\n\nstages:\n  - test\n  - functional_tests\n  - publish\n\ndefault:\n  interruptible: true\n  retry:\n    max: 2\n    when: runner_system_failure\n\nvariables:\n  UNIT_TEST:\n    value: 'yes'\n    options:\n      - 'yes'\n      - 'no'\n    description: To run the funtional test suite\n  UNIT_TEST_REPEAT:\n    value: '1'\n    description: 'Number of repetitions'\n  UNIT_TEST_TIMEOUT:\n    value: '30'\n    description: Timeout (minutes) for Unit tests (all repeats)\n  FUNCTIONAL_TEST:\n    value: 'yes'\n    options:\n      - 'yes'\n      - 'no'\n    description: To run the funtional test suite\n  FUNCTIONAL_TEST_SCOPE:\n    value: 'mr'\n    options:\n      - 'mr'\n      - 'nightly'\n      - 'weekly'\n      - 'pre-release'\n      - 'release'\n    description: 'Testsuite to run (only for FUNCTIONAL_TEST=yes)'\n  FUNCTIONAL_TEST_REPEAT:\n    value: '5'\n    description: 'Number of repetitions per test'\n  FUNCTIONAL_TEST_TIME_LIMIT:\n    value: '2700'\n    description: 'Timeout in seconds per test'\n  FUNCTIONAL_TEST_CASES:\n    value: 'all'\n    description: \"Comma-separated list of test_cases to run. Use 'all' to run the full suite.\"\n  FUNCTIONAL_TEST_CLUSTER_A100:\n    value: 'dgxa100_dracooci'\n    options:\n      - 'dgxa100_dracooci'\n      - 'dgxa100_dracooci-ord'\n    description: 'Cluster for A100 workloads'\n  FUNCTIONAL_TEST_CLUSTER_H100:\n    value: 'dgxh100_eos'\n    options:\n      - 'dgxh100_coreweave'\n      - 'dgxh100_eos'\n    description: 'Cluster for H100 workloads'\n  FUNCTIONAL_TEST_NAME:\n    description: 'Name of functional test run (only for pre-release and release)'\n  PUBLISH:\n    value: 'no'\n    options:\n      - 'yes'\n      - 'no'\n    description: Build and publish a wheel to PyPi\n  PUBLISH_SCOPE:\n    value: 'code-freeze'\n    options:\n      - 'code-freeze'\n      - 'release'\n    description: Type of publish (freeze or final release)\n\n  # CI wide variables\n  CI_MCORE_LTS_IMAGE: ${GITLAB_ENDPOINT}:5005/adlr/megatron-lm/mcore_ci_lts\n  CI_MCORE_DEV_IMAGE: ${GITLAB_ENDPOINT}:5005/adlr/megatron-lm/mcore_ci_dev\n  CI_NEMO_IMAGE: ${GITLAB_ENDPOINT}:5005/adlr/megatron-lm/nemo_ci\n  UTILITY_IMAGE: ${GITLAB_ENDPOINT}:5005/adlr/megatron-lm/mcore_utility\n\ninclude:\n  - .gitlab/stages/00.pre.yml\n  - .gitlab/stages/01.test.yml\n  - .gitlab/stages/02.functional-tests.yml\n  - .gitlab/stages/03.publish.yml\n"
        },
        {
          "name": ".gitlab",
          "type": "tree",
          "content": null
        },
        {
          "name": ".pylintrc",
          "type": "blob",
          "size": 0.2197265625,
          "content": "[MAIN]\nignore-paths=tests\nmax-line-length=100\n\n[MESSAGES CONTROL]\ndisable=all\n\nenable=C0115,C0116,W0611,C0301\n# C0115: missing-class-docstring\n# C0116: missing-function-docstring\n# W0611: unused-import\n# C0301: line-too-long\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 3.693359375,
          "content": "# Changelog\n\n## NVIDIA Megatron Core 0.9.0\n\n- Uneven pipeline parallelism\n  - Enable pipeline parallelism where first and last ranks have fewer transformer layers than the intermediate ranks\n- Per layer CUDAGraph support for GPT training with Transformer Engine modules\n- Enable different TP sizes for the vision encoder\n- Enable pipeline parallelism for T5 & Llava models\n- Support multi-tile multi-image input in Llava models\n- MoE\n  - FP8 support\n  - Runtime upcycling support\n  - Dispatcher implementation optimizations\n  - Shared expert support with overlapping optimizations\n    - Qwen Model support\n- Known Issues\n  - When using sequence parallel, during the transformer block forward pass, dropout is not using the appropriate rng context.\n\n\n## NVIDIA Megatron Core 0.8.0\n\n- Multimodal\n  - Added initial support for training vision language models using the LLaVA architecture\n  - Added initial support for inference with multimodal inputs\n  - End-to-end multimodal example from data collection to training to evaluation is provided in examples/multimodal\n- MoE\n  - Context Parallel support.\n  - Distributed checkpoint support for grouped GEMM.\n- Mamba\n\n## NVIDIA Megatron Core 0.7.0\n\n- MoE\n  - Token drop support\n  - Several efficiency optimizations\n  - Improved model parallelism\n  - Memory optimizations\n- Distributed checkpointing\n  - Enabled for Retro\n  - Asynchronous checkpoint saving\n- Several minor bug fixes, speed improvements, and memory optimizations\n\n## NVIDIA Megatron Core 0.6.0\n\n- MoE (Mixture of Experts)\n  - Performance optimization\n    - Communication optimization for multi GPU and Single GPU \n    - 23% improvement (323 TFLOPS/GPU) over MCore 0.5.0 on Mixtral with Hopper BF16\n    - GroupedMLP enhancement for Hopper\n    - DP Overlapping. Support overlapping computation with gradient reduction and parameter gathering.\n  - All-to-All based Token Dispatcher\n  - Layer-wise logging for load balancing loss.\n  - Improved expert parallel support including distributed optimizer.\n- Distributed optimizer\n- RETRO\n  - Data processing\n- BERT\n  - Distributed checkpointing\n- Dist checkpointing\n  - PyTorch native distributed backend\n  - Improved saving/loading speed\n- TensorRT-LLM Export\n  - Integration with TensorRT Model Optimizer Post-training quantization (PTQ)\n  - Text generation driver to perform PTQ in Megatron-LM\n  - Llama2 and Nemotron3-8b examples to use TensorRT-LLM unified build API to build engine after training.\n- Several minor enhancements, bug fixes, and documentation updates\n\n## NVIDIA Megatron Core 0.5.0\n\n### Key Features and Enhancements\n\nMegatron core documentation is now [live!](https://docs.nvidia.com/megatron-core/developer-guide/latest/user-guide/index.html#quick-start)\n\n### Model Features\n\n- MoE (Mixture of Experts)\n  - Support for Z-loss, Load balancing and Sinkhorn\n  - Layer and communications refactor\n  - Richer parallelism mappings and EP can be combined with other model parallel techniques for larger MoE variants, e.g. EP + TP + DP + SP + PP\n  - Token dropless architecture with Top-K routing\n  - Performance optimization with with GroupedGEMM when number of local experts is > 1\n  - Distributed checkpointing\n- Interleaved rotary embedding\n\n### Datasets\n\n- Masked WordPiece datasets for BERT and T5\n- Raw and mock datasets\n\n### Parallelism\n\n### Performance\n\n- Activation offloading to CPU\n- Rope and Swiglu fusion\n- Sliding window attention (via Transformer Engine)\n\n### General Improvements\n\n- Timers\n\n## NVIDIA Megatron Core 0.4.0\n\n### Key Features and Enhancements\n\n#### Models\n\n- BERT\n- RETRO\n- T5\n\n#### Parallelism\n\n- Mixture of Experts support for GPT\n- Model parallel efficient Distributed Data Parallel (DDP)\n- Context Parallel (2D Tensor Parallel) support\n\n#### Datasets\n\n- GPT Dataset\n- Blended Dataset\n"
        },
        {
          "name": "CODEOWNERS",
          "type": "blob",
          "size": 1.0478515625,
          "content": "[Core-ADLR] @mcore-reviewers/core-adlr\nmegatron/core/ \n\n[Core-NeMo] @mcore-reviewers/core-nemo\nmegatron/core/ \n\n^[Core-MLPerf] @mcore-reviewers/mlperf\nmegatron/core/\n\n[MoE-ADLR] @mcore-reviewers/moe-adlr\nmegatron/core/transformer/moe/\n\n[MoE-Moe] @mcore-reviewers/moe-moe\nmegatron/core/transformer/moe/\n\n[Datasets] @mcore-reviewers/datasets\nmegatron/core/datasets/\n\n[BERT] @mcore-reviewers/bert\nmegatron/core/models/bert/\n\n[GPT] @mcore-reviewers/gpt\nmegatron/core/models/gpt/\n\n[Retro] @mcore-reviewers/retro\nmegatron/core/models/retro/\n\n[Distributed Checkpointing] @mcore-reviewers/dist-checkpointing\nmegatron/core/dist_checkpointing/\n\n[Distributed Optimizer] @mcore-reviewers/dist-optimizer\nmegatron/core/optimizer/distrib_optimizer/ \n\n[Inference] @mcore-reviewers/inference\nmegatron/core/inference/\n\n^[Quantization and Inference (QAT)] @mcore-reviewers/quantization-and-inference\nmegatron/core/inference/\n\n; [Context Parallelism] @mcore-reviewers/context-parallelism\n; \n\n[CI] @mcore-reviewers/ci\n.gitlab/\n.github/\n.gitlab-ci.yml\nDockerfile.ci.lts\nDockerfile.ci.dev\ntests/\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 4.197265625,
          "content": "# Contributing to Megatron-LM\n\nThis document outlines the processes and policies for issues and pull requests by non-NVIDIA contributors to the Megatron-LM github repository.\n\nEveryone is welcome to contribute to the project but development of Megatron-LM continues internally at NVIDIA. When contributing it important to ensure that changes are in line with the project direction. Small changes to fix bugs are welcomed and appreciated. If proposing large architectural changes or changes for stylistic reasons open an issue first so we can discuss it.\n\nPRs will first be pulled into NVIDIA's internal Megatron-LM repo and then pushed back out to the open github repo with proper credit given to the committers.\n\n## Issue policy\n\nPlease do file any bugs you find, keeping the following in mind:\n\n- If filing a bug, i.e. you have found something that doesn't work as expected, use the BUG template.\n- If you've found a regression in speed or accuracy use the REGRESSION template.\n- If you are requesting a new feature or modification of an existing feature use the ENHANCEMENT template.\n- If opening an issue to ask a question no template is needed but please make your question as clear and concise as possible.\n- One issue per bug. Putting multiple things in the same issue makes both discussion and completion unnecessarily complicated.\n- Your bug is mostly likely to get attention from the development team quickly if we can easily reproduce it.\n- Use proper spelling, grammar, and punctuation.\n- Write in an authoritative and technical tone.\n\n## Code submission policy\n\nHere are some dos & don'ts to try and stick to:\n\n### Do:\n\n- Format new code in a style that is consistent with the file being changed. Megatron-LM doesn't (yet) have a style guide or enforced formatting.\n- Split your changes into separate, atomic commits i.e. A commit per feature or fix.\n- Make sure your commits are rebased on the master branch.\n- Write the commit message subject line in the imperative mood (\"Change the default argument for X\", not \"Changed the default argument for X\").\n- Write your commit messages in proper English, with care and punctuation.\n- Check the spelling of your code, comments and commit messages.\n\n### Don't:\n\n- Submit code that's incompatible with the project licence.\n- Touch anything outside the stated scope of the PR. This includes formatting changes to code not relevant to the PR.\n- Iterate excessively on your design across multiple commits.\n- Include commented-out code.\n- Attempt large architectural changes without first opening an issue to discuss.\n\n## Issue and Pull Request Q&A (Updated Jul 2023)\n\n### I've submitted an issue and PR. When can I expect to get some feedback?\n\nMegatron-LM is developed and maintained by a small team of researchers. We will endeavour to read and acknowledge all new issues and PRs within a week. A few rules of thumb:\n- Reproducible bugs/regressions and bug/regression fixes are likely to get the attention of maintainers the quickest.\n- Issues requesting an enhancement may only recieve acknowlegement that they've been read and may be closed with a \"wontfix\" label if they're not inline with the project direction. If they are acknowledged and remain open you can assume the maintainers agree they're a desirable feature.\n- Support requests, i.e. requests for help running the code, have the lowest priority and will be responded to as maintainer time permits.\n\n### If my issue or PR isn't getting attention, how long should I wait before pinging one of the project maintainers?\n\nOne week if there is no acknowledgement of the intial request.\n\n### Who are the project maintainers I should ping?\n\nThe corresponding maintainers at this time are @jaredcasper and @jon-barker.\n\n### Is there a policy for issues and PRs that haven't been touched in X days? Should they be closed?\n\nYes, starting in July 2023 we have a bot that will mark untouched PRs as \"stale\" after 60 days.\n\nWe have a long backlog of issues and PRs dating back 3.5 years. We are trying to triage these now by working backwards. Older issues we believe may still be relevant may recieve a request to re-test them with the latest code. If there's no response they may be closed. Again, if you they should be re-opened then just respond with a comment to that effect.\n\nThank-you!"
        },
        {
          "name": "Dockerfile.ci.dev",
          "type": "blob",
          "size": 2.703125,
          "content": "# syntax=docker/dockerfile:1.3-labs\n\nARG FROM_IMAGE_NAME\nFROM $FROM_IMAGE_NAME as build_causal_conv1d\nWORKDIR /opt\nRUN CAUSAL_CONV1D_FORCE_BUILD=TRUE pip3 wheel -v git+https://github.com/Dao-AILab/causal-conv1d.git@v1.2.2.post1\n\nFROM $FROM_IMAGE_NAME as build_grouped_gemm\nWORKDIR /opt\nRUN pip3 wheel -v git+https://github.com/fanshiqing/grouped_gemm@v1.1.2\n\nFROM $FROM_IMAGE_NAME as build_mamba_ssm\nWORKDIR /opt\nRUN MAMBA_FORCE_BUILD=TRUE pip3 wheel -v git+https://github.com/state-spaces/mamba.git@v2.2.0\n\nFROM $FROM_IMAGE_NAME as main\nENV DEBIAN_FRONTEND=noninteractive\n\nRUN apt-get update && \\\n    apt-get install -y --no-install-recommends gettext python3-venv && \\\n    apt-get clean && \\\n    python -m venv /opt/jet && \\\n    wget https://github.com/mikefarah/yq/releases/download/v4.44.1/yq_linux_amd64 -O /usr/local/bin/yq && \\\n    chmod a+x /usr/local/bin/yq\n\nCOPY --from=build_causal_conv1d /opt/causal_conv1d-*.whl ./\nCOPY --from=build_grouped_gemm /opt/grouped_gemm-*.whl ./\nCOPY --from=build_mamba_ssm /opt/mamba_ssm-*.whl ./\n\nRUN \\\n    --mount=type=bind,source=requirements,target=requirements \\\n    --mount=type=bind,source=pyproject.toml,target=pyproject.toml \\\n    --mount=type=bind,source=setup.py,target=setup.py \\\n    --mount=type=bind,source=megatron/core/package_info.py,target=megatron/core/package_info.py \\\n    --mount=type=bind,source=megatron/core/README.md,target=megatron/core/README.md \\\n    --mount=type=bind,source=megatron/core/__init__.py,target=megatron/core/__init__.py <<\"EOF\" bash -ex\n\npip install causal_conv1d-*.whl mamba_ssm-*.whl grouped_gemm-*.whl\nPY_ENV=pytorch:24.07 pip install .\nEOF\n\n# Since megatron does not have any dependencies (and isn't a dependency to any other package), we can install it separately to make everything a bit quicker\nARG MCORE_REPO\nARG MCORE_REF\nARG MCORE_BACKWARDS_REF\nRUN <<\"EOF\" bash -exu\n# Checkout latest\ncd /opt\nrm -rf /opt/megatron-lm; mkdir megatron-lm; cd megatron-lm\ngit init\ngit remote add origin ${MCORE_REPO}\ngit fetch origin '+refs/merge-requests/*:refs/remotes/merge-requests/*'\ngit fetch origin $MCORE_REF\ngit checkout $MCORE_REF\n\n# Checkout backwards-ref\ncd /opt\nrm -rf /opt/megatron-lm-legacy; mkdir megatron-lm-legacy; cd megatron-lm-legacy\ngit init\ngit remote add origin ${MCORE_REPO}\ngit fetch origin $MCORE_BACKWARDS_REF\ngit checkout $MCORE_BACKWARDS_REF\nrm -rf megatron; cp -a /opt/megatron-lm/megatron ./\nEOF\n\nRUN PY_ENV=pytorch:24.07 pip install -e /opt/megatron-lm\nENV PYTHONPATH=\"/opt/megatron-lm:$PYTHONPATH\"\n\n##### For NVIDIANS only #####\nFROM main as jet\nARG CACHEBUST=0\nRUN --mount=type=secret,id=JET_INDEX_URLS \\\n    JET_INDEX_URLS=$(cat /run/secrets/JET_INDEX_URLS) && \\\n    pip install jet-client jet-api --upgrade $JET_INDEX_URLS\nENV PATH=\"$PATH:/opt/jet/bin\"\n###"
        },
        {
          "name": "Dockerfile.ci.lts",
          "type": "blob",
          "size": 2.72265625,
          "content": "# syntax=docker/dockerfile:1.3-labs\n\nARG FROM_IMAGE_NAME\nFROM $FROM_IMAGE_NAME as build_causal_conv1d\nWORKDIR /opt\nRUN CAUSAL_CONV1D_FORCE_BUILD=TRUE pip3 wheel -v git+https://github.com/Dao-AILab/causal-conv1d.git@v1.2.2.post1\n\nFROM $FROM_IMAGE_NAME as build_grouped_gemm\nWORKDIR /opt\nRUN pip3 wheel -v git+https://github.com/fanshiqing/grouped_gemm@v1.1.2\n\nFROM $FROM_IMAGE_NAME as build_mamba_ssm\nWORKDIR /opt\nRUN MAMBA_FORCE_BUILD=TRUE pip3 wheel -v git+https://github.com/state-spaces/mamba.git@v2.0.3\n\nARG FROM_IMAGE_NAME\nFROM $FROM_IMAGE_NAME as main\nENV DEBIAN_FRONTEND=noninteractive\n\nRUN apt-get update && \\\n    apt-get install -y --no-install-recommends gettext python3-venv && \\\n    apt-get clean && \\\n    python -m venv /opt/jet && \\\n    wget https://github.com/mikefarah/yq/releases/download/v4.44.1/yq_linux_amd64 -O /usr/local/bin/yq && \\\n    chmod a+x /usr/local/bin/yq\n\nCOPY --from=build_causal_conv1d /opt/causal_conv1d-*.whl ./\nCOPY --from=build_grouped_gemm /opt/grouped_gemm-*.whl ./\nCOPY --from=build_mamba_ssm /opt/mamba_ssm-*.whl ./\n\nRUN \\\n    --mount=type=bind,source=requirements,target=requirements \\\n    --mount=type=bind,source=pyproject.toml,target=pyproject.toml \\\n    --mount=type=bind,source=setup.py,target=setup.py \\\n    --mount=type=bind,source=megatron/core/package_info.py,target=megatron/core/package_info.py \\\n    --mount=type=bind,source=megatron/core/README.md,target=megatron/core/README.md \\\n    --mount=type=bind,source=megatron/core/__init__.py,target=megatron/core/__init__.py <<\"EOF\" bash -ex\n\npip install causal_conv1d-*.whl mamba_ssm-*.whl grouped_gemm-*.whl\nPY_ENV=pytorch:24.07 pip install .\nEOF\n\n# Since megatron does not have any dependencies (and isn't a dependency to any other package), we can install it separately to make everything a bit quicker\nARG MCORE_REPO\nARG MCORE_REF\nARG MCORE_BACKWARDS_REF\nRUN <<\"EOF\" bash -exu\n# Checkout latest\ncd /opt\nrm -rf /opt/megatron-lm; mkdir megatron-lm; cd megatron-lm\ngit init\ngit remote add origin ${MCORE_REPO}\ngit fetch origin '+refs/merge-requests/*:refs/remotes/merge-requests/*'\ngit fetch origin $MCORE_REF\ngit checkout $MCORE_REF\n\n# Checkout backwards-ref\ncd /opt\nrm -rf /opt/megatron-lm-legacy; mkdir megatron-lm-legacy; cd megatron-lm-legacy\ngit init\ngit remote add origin ${MCORE_REPO}\ngit fetch origin $MCORE_BACKWARDS_REF\ngit checkout $MCORE_BACKWARDS_REF\nrm -rf megatron; cp -a /opt/megatron-lm/megatron ./\nEOF\n\nRUN PY_ENV=pytorch:24.01 pip install -e /opt/megatron-lm\nENV PYTHONPATH=\"/opt/megatron-lm:$PYTHONPATH\"\n\n##### For NVIDIANS only #####\nFROM main as jet\nARG CACHEBUST=0\nRUN --mount=type=secret,id=JET_INDEX_URLS \\\n    JET_INDEX_URLS=$(cat /run/secrets/JET_INDEX_URLS) && \\\n    pip install jet-api jet-client --upgrade $JET_INDEX_URLS\nENV PATH=\"$PATH:/opt/jet/bin\"\n###"
        },
        {
          "name": "Dockerfile.linting",
          "type": "blob",
          "size": 0.7734375,
          "content": "# syntax=docker/dockerfile:experimental\n\nARG FROM_IMAGE_NAME\nFROM $FROM_IMAGE_NAME as main\nENV DEBIAN_FRONTEND=noninteractive\n\nRUN sed -i -e 's/^APT/# APT/' -e 's/^DPkg/# DPkg/' \\\n      /etc/apt/apt.conf.d/docker-clean\n\nRUN apt-get update && \\\n      apt-get install -y python3-venv && \\\n      apt-get clean && \\\n      python -m venv /opt/jet\n\nRUN pip3 install --no-cache-dir \\\n      black==24.4.2 \\\n      isort==5.13.2 \\\n      flake8==7.1.0 \\\n      pylint==3.2.6 \\\n      mypy\n\nCOPY . /opt/megatron-lm\n\nWORKDIR /opt/megatron-lm\n\n##### For NVIDIANS only #####\nFROM main as jet\nARG CACHEBUST=0\nRUN --mount=type=secret,id=JET_INDEX_URLS \\\n      JET_INDEX_URLS=$(cat /run/secrets/JET_INDEX_URLS) && \\\n      pip install jet-client jet-api --upgrade $JET_INDEX_URLS\nENV PATH=\"$PATH:/opt/jet/bin\"\n###"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 14.4970703125,
          "content": "The following applies to all files unless otherwise noted:\n\n# Copyright (c) 2022, NVIDIA CORPORATION. All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions\n# are met:\n#  * Redistributions of source code must retain the above copyright\n#    notice, this list of conditions and the following disclaimer.\n#  * Redistributions in binary form must reproduce the above copyright\n#    notice, this list of conditions and the following disclaimer in the\n#    documentation and/or other materials provided with the distribution.\n#  * Neither the name of NVIDIA CORPORATION nor the names of its\n#    contributors may be used to endorse or promote products derived\n#    from this software without specific prior written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY\n# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n# PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n# OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n--\n\nThis repository also contains code from Hugging Face Inc., Google Research,\nFacebook (from their Fairseq, Dino, and ParlAI projects), Microsoft (from their\nSwin-Transformer project), Philip Popien, the Mamba project (Tri Dao and\nAlbert Gu), and the Triton language and compiler project (Philippe Tillet and\nOpenAI). Files from these organizations have notices at the top of each file.\nBelow are licenses used in those files, as indicated.\n\n\n--------------------------------------------------------------------------------\n-- LICENSE FOR Facebook, huggingface, Google Research, LLaVA, and Mamba code  --\n\n\n                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"[]\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright [yyyy] [name of copyright owner]\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n--------------------------------------------------------------------------------\nLICENSE FOR\nFacebook, Inc. and its affiliates,\nMeta Platforms, Inc. and its affiliates,\nMicrosoft Corporation,\nOpenGVLab/InternVL, and\nTriton language and compiler.\n\nMIT License\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n"
        },
        {
          "name": "MANIFEST.in",
          "type": "blob",
          "size": 0.1015625,
          "content": "include megatron/core/requirements.txt\ninclude megatron/core/README.md\nrecursive-include requirements *\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 49.634765625,
          "content": "<div align=\"center\">\n\nMegatron-LM & Megatron-Core\n===========================\n<h4>GPU optimized techniques for training transformer models at-scale</h4>\n\n[![Documentation](https://img.shields.io/badge/docs-latest-brightgreen.svg?style=flat)](https://docs.nvidia.com/megatron-core/developer-guide/latest/index.html)\n[![version](https://img.shields.io/badge/release-0.5.0-green)](./setup.py)\n[![license](https://img.shields.io/badge/license-OpenBSD-blue)](./LICENSE)\n\n<div align=\"left\">\n\n# Latest News\n\n- **[2024/7]** Megatron-Core v0.7 improves scalability and training resiliency and adds support for multimodal training ([blog](https://developer.nvidia.com/blog/train-generative-ai-models-more-efficiently-with-new-nvidia-megatron-core-functionalities/)). \n- **[2024/6]** Megatron-Core added supports for Mamba-based models. Check out our paper [An Empirical Study of Mamba-based Language Models](https://arxiv.org/pdf/2406.07887) and [code example](https://github.com/NVIDIA/Megatron-LM/tree/ssm/examples/mamba).\n- **[2024/1 Announcement]** NVIDIA has released the core capabilities in **Megatron-LM** into [**Megatron-Core**](https://github.com/NVIDIA/Megatron-LM/tree/main/megatron/core) in this repository. Megatron-Core expands upon Megatron-LM's GPU-optimized techniques with more cutting-edge innovations on system-level optimizations, featuring composable and modular APIs. Explore the [Megatron-Core intro](#megatron-core) for more details.\n\n\n\n# Table of Contents\n- [Megatron-LM \\& Megatron-Core](#megatron-lm--megatron-core)\n- [Latest News](#latest-news)\n- [Table of Contents](#table-of-contents)\n- [Megatron Overview](#megatron-overview)\n  - [Megatron-LM](#megatron-lm)\n  - [Megatron-Core](#megatron-core)\n- [Training Speed and Scalability](#training-speed-and-scalability)\n- [Setup](#setup)\n  - [Downloading Checkpoints](#downloading-checkpoints)\n- [Usage](#usage)\n- [Training](#training)\n  - [Data Preprocessing](#data-preprocessing)\n  - [BERT Pretraining](#bert-pretraining)\n  - [GPT Pretraining](#gpt-pretraining)\n  - [T5 Pretraining](#t5-pretraining)\n  - [Distributed Pretraining](#distributed-pretraining)\n  - [Activation Checkpointing and Recomputation](#activation-checkpointing-and-recomputation)\n  - [Distributed Optimizer](#distributed-optimizer)\n  - [FlashAttention](#flashattention)\n  - [GPT-3 Example](#gpt-3-example)\n  - [Retro and InstructRetro](#retro-and-instructretro)\n  - [Mamba-based Language Models](#mamba-based-language-models)\n  - [Mixture of Experts](#mixture-of-experts)\n    - [Key Features of MoE](#key-features-of-moe)\n- [Evaluation and Tasks](#evaluation-and-tasks)\n  - [GPT Text Generation](#gpt-text-generation)\n    - [Detoxify GPT via Self-generation](#detoxify-gpt-via-self-generation)\n  - [GPT Evaluation](#gpt-evaluation)\n    - [WikiText Perplexity Evaluation](#wikitext-perplexity-evaluation)\n    - [LAMBADA Cloze Accuracy](#lambada-cloze-accuracy)\n  - [BERT Task Evaluation](#bert-task-evaluation)\n    - [RACE Evaluation](#race-evaluation)\n    - [MNLI Evaluation](#mnli-evaluation)\n  - [Llama-2 Inference and Finetuning](#llama-2-inference-and-finetuning)\n- [Model Optimization and Deployment](#model-optimization-and-deployment)\n  - [Quantization and TensorRT-LLM Deployment](#quantization-and-tensorrt-llm-deployment)\n- [Datasets](#datasets)\n  - [Collecting Wikipedia Training Data](#collecting-wikipedia-training-data)\n  - [Collecting GPT Webtext Data](#collecting-gpt-webtext-data)\n- [Reproducibility](#reproducibility)\n  - [Projects Using Megatron](#projects-using-megatron)\n\n# Megatron Overview\nThis repository comprises two essential components: **Megatron-LM** and **Megatron-Core**. Megatron-LM serves as a research-oriented framework leveraging Megatron-Core for large language model (LLM) training. Megatron-Core, on the other hand, is a library of GPU optimized training techniques that comes with formal product support including versioned APIs and regular releases. You can use Megatron-Core alongside Megatron-LM or [Nvidia NeMo Framework](https://docs.nvidia.com/deeplearning/nemo/user-guide/docs/en/main/nlp/nemo_megatron/mcore_customization.html) for an end-to-end and cloud-native solution. Alternatively, you can integrate Megatron-Core's building blocks into your preferred training framework.\n\n## Megatron-LM\nFirst introduced in 2019, Megatron ([1](https://arxiv.org/pdf/1909.08053.pdf), [2](https://arxiv.org/pdf/2104.04473.pdf), and [3](https://arxiv.org/pdf/2205.05198)) sparked a wave of innovation in the AI community, enabling researchers and developers to utilize the underpinnings of this library to further LLM advancements. Today, many of the most popular LLM developer frameworks have been inspired by and built directly leveraging the open-source Megatron-LM library, spurring a wave of foundation models and AI startups. Some of the most popular LLM frameworks built on top of Megatron-LM include [Colossal-AI](https://github.com/hpcaitech/ColossalAI), [HuggingFace Accelerate](https://github.com/huggingface/accelerate), and [NVIDIA NeMo Framework](https://www.nvidia.com/en-us/ai-data-science/generative-ai/nemo-framework/). A list of projects that have directly used Megatron can be found [here](#projects-using-megatron).\n\n## Megatron-Core\nMegatron-Core is an open-source PyTorch-based library that contains GPU-optimized techniques and cutting-edge system-level optimizations. It abstracts them into composable and modular APIs, allowing full flexibility for developers and model researchers to train custom transformers at-scale on NVIDIA accelerated computing infrastructure. This library is compatible with all NVIDIA Tensor Core GPUs, including FP8 acceleration support for [NVIDIA Hopper architectures](https://www.nvidia.com/en-us/data-center/technologies/hopper-architecture/). \n\nMegatron-Core offers core building blocks such as attention mechanisms, transformer blocks and layers, normalization layers, and embedding techniques. Additional functionality like activation recomputation, distributed checkpointing is also natively built-in to the library. The building blocks and functionality are all GPU optimized, and can be built with advanced parallelization strategies for optimal training speed and stability on NVIDIA Accelerated Computing Infrastructure. Another key component of the Megatron-Core library includes advanced model parallelism techniques (tensor, sequence, pipeline, context, and MoE expert parallelism). \n\nMegatron-Core can be used with [NVIDIA NeMo](https://www.nvidia.com/en-us/ai-data-science/products/nemo/), an enterprise-grade AI platform. Alternatively, you can explore Megatron-Core with the native PyTorch training loop [here](https://github.com/NVIDIA/Megatron-LM/tree/main/examples). Visit [Megatron-Core documentation](https://docs.nvidia.com/megatron-core/developer-guide/latest/index.html) to learn more.\n\n\n# Training Speed and Scalability\nOur codebase is capable of efficiently training large language models (i.e., models with hundreds of billions of parameters) with both model and data parallelism. To demonstrate how our software scales with multiple GPUs and model sizes, we consider GPT models ranging from 2 billion parameters to 462 billion parameters. All models use a vocabulary size of 131,072 and a sequence length of 4096. We vary hidden size, number of attention heads, and number of layers to arrive at a specific model size. As the model size increases, we also modestly increase batch size. Our experiments use up to 6144 [H100](https://www.nvidia.com/en-us/data-center/h100/) GPUs. We perform fine-grained overlapping of data-parallel (`--overlap-grad-reduce --overlap-param-gather`), tensor-parallel (`--tp-comm-overlap`) and pipeline-parallel communication (enabled by default) with computation to improve scalability. The reported throughputs are measured for end-to-end training and include all operations including data loading, optimizer steps, communication, and even logging. Note that we did not train these models to convergence.\n\n![Model table](images/model_table.png)\n\nOur weak scaled results show superlinear scaling (MFU increases from 41% for the smallest model considered to 47-48% for the largest models); this is because larger GEMMs have higher arithmetic intensity and are consequently more efficient to execute.\n\n![Weak scaling](images/weak_scaling.png)\n\nWe also strong scaled the standard GPT-3 model (our version has slightly more than 175 billion parameters due to larger vocabulary size) from 96 H100 GPUs to 4608 GPUs, using the same batch size of 1152 sequences throughout. Communication becomes more exposed at larger scale, leading to a reduction in MFU from 47% to 42%.\n\n![Strong scaling](images/strong_scaling.png)\n\n\n# Setup\nWe strongly recommend using the latest release of [NGC's PyTorch container](https://ngc.nvidia.com/catalog/containers/nvidia:pytorch) with DGX nodes. If you can't use this for some reason, use the latest pytorch, cuda, nccl, and NVIDIA [APEX](https://github.com/NVIDIA/apex#quick-start) releases.  Data preprocessing requires [NLTK](https://www.nltk.org/install.html), though this is not required for training, evaluation, or downstream tasks.\n\nYou can launch an instance of the PyTorch container and mount Megatron, your dataset, and checkpoints with the following Docker commands:\n```\ndocker pull nvcr.io/nvidia/pytorch:xx.xx-py3\ndocker run --gpus all -it --rm -v /path/to/megatron:/workspace/megatron -v /path/to/dataset:/workspace/dataset -v /path/to/checkpoints:/workspace/checkpoints nvcr.io/nvidia/pytorch:xx.xx-py3\n```\n\n## Downloading Checkpoints\nWe have provided pretrained [BERT-345M](https://ngc.nvidia.com/catalog/models/nvidia:megatron_bert_345m) and [GPT-345M](https://ngc.nvidia.com/catalog/models/nvidia:megatron_lm_345m) checkpoints to evaluate or for finetuning downstream tasks. To access these checkpoints, first [sign up](https://ngc.nvidia.com/signup) for and [setup](https://ngc.nvidia.com/setup/installers/cli) the NVIDIA GPU Cloud (NGC) Registry CLI. Further documentation for downloading models can be found in the [NGC documentation](https://docs.nvidia.com/dgx/ngc-registry-cli-user-guide/index.html#topic_6_4_1).\n\nAlternatively, you can directly download the checkpoints using:\n\n<pre>\nBERT-345M-uncased: wget --content-disposition https://api.ngc.nvidia.com/v2/models/nvidia/megatron_bert_345m/versions/v0.1_uncased/zip -O megatron_bert_345m_v0.1_uncased.zip\nBERT-345M-cased: wget --content-disposition https://api.ngc.nvidia.com/v2/models/nvidia/megatron_bert_345m/versions/v0.1_cased/zip -O megatron_bert_345m_v0.1_cased.zip\nGPT-345M: wget --content-disposition https://api.ngc.nvidia.com/v2/models/nvidia/megatron_lm_345m/versions/v0.0/zip -O megatron_lm_345m_v0.0.zip\n</pre>\n\nThe models require vocabulary files to run. The BERT  WordPiece vocab file can be extracted from Google's pretrained BERT models: [uncased](https://s3.amazonaws.com/models.huggingface.co/bert/bert-large-uncased-vocab.txt), [cased](https://s3.amazonaws.com/models.huggingface.co/bert/bert-large-cased-vocab.txt). The GPT [vocab file](https://s3.amazonaws.com/models.huggingface.co/bert/gpt2-vocab.json) and [merge table](https://s3.amazonaws.com/models.huggingface.co/bert/gpt2-merges.txt) can be downloaded directly.\n\n# Usage\n\nAfter installation, there are several possible workflows. The most comprehensive is:\n1. Data preprocessing\n2. Pretraining\n3. Finetuning (Optional for zero-shot tasks)\n4. Downstream task evaluation or text generation\n\nHowever, steps 1 and 2 can be replaced by using one of the pretrained models mentioned above.\n\nWe've provided several scripts for pretraining both BERT and GPT in the [`examples`](./examples) directory, as well as scripts for both zero-shot and fine-tuned downstream tasks including MNLI, RACE, WikiText103, and LAMBADA evaluation. There is also a script for GPT interactive text generation.\n\n# Training\n## Data Preprocessing\nThe training data requires preprocessing. First, place your training data in a loose json format, with one json containing a text sample per line. For example:\n<pre>\n{\"src\": \"www.nvidia.com\", \"text\": \"The quick brown fox\", \"type\": \"Eng\", \"id\": \"0\", \"title\": \"First Part\"}\n{\"src\": \"The Internet\", \"text\": \"jumps over the lazy dog\", \"type\": \"Eng\", \"id\": \"42\", \"title\": \"Second Part\"}\n</pre>\n\nThe name of the `text` field of the json can be changed by using the `--json-key` flag in [`preprocess_data.py`](./tools/preprocess_data.py) The other metadata are optional and are not used in training.\n\nThe loose json is then processed into a binary format for training. To convert the json into mmap format use `preprocess_data.py`. An example script to prepare data for BERT training is:\n<pre>\npython tools/preprocess_data.py \\\n       --input my-corpus.json \\\n       --output-prefix my-bert \\\n       --vocab-file bert-vocab.txt \\\n       --tokenizer-type BertWordPieceLowerCase \\\n       --split-sentences\n</pre>\n\nThe output will be two files named, in this case, `my-bert_text_sentence.bin` and `my-bert_text_sentence.idx`. The `--data-path` specified in later BERT training is the full path and new filename, but without the file extension.\n\nFor T5 use the same preprocessing as BERT, perhaps renaming it to:\n<pre>\n       --output-prefix my-t5 \\\n</pre>\n\nSome minor modifications are required for GPT data preprocessing, namely, the addition of a merge table, an end-of-document token, removal of sentence splitting, and a change to the tokenizer type:\n<pre>\npython tools/preprocess_data.py \\\n       --input my-corpus.json \\\n       --output-prefix my-gpt2 \\\n       --vocab-file gpt2-vocab.json \\\n       --tokenizer-type GPT2BPETokenizer \\\n       --merge-file gpt2-merges.txt \\\n       --append-eod\n</pre>\n\nHere the output files are named `my-gpt2_text_document.bin` and `my-gpt2_text_document.idx`. As before, in GPT training, use the longer name without the extension as `--data-path`.\n\nFurther command line arguments are described in the source file [`preprocess_data.py`](./tools/preprocess_data.py).\n\n## BERT Pretraining\n\n\nThe [`examples/bert/train_bert_340m_distributed.sh`](examples/bert/train_bert_340m_distributed.sh) script runs single GPU 345M parameter BERT pretraining. Debugging is the primary use for single GPU training, as the code base and command line arguments are optimized for highly distributed training. Most of the arguments are fairly self-explanatory. By default, the learning rate decays linearly over the training iterations starting at `--lr` to a minimum set by `--min-lr` over `--lr-decay-iters` iterations. The fraction of training iterations used for warmup is set by `--lr-warmup-fraction`. While this is single GPU training, the batch size specified by `--micro-batch-size` is a single forward-backward path batch-size and the code will perform gradient accumulation steps until it reaches `global-batch-size` which is the batch size per iteration. The data is partitioned into a 949:50:1 ratio for training/validation/test sets (default is 969:30:1). This partitioning happens on the fly, but is consistent across runs with the same random seed (1234 by default, or specified manually with `--seed`). We use `train-iters` as the training iterations requested. Alternatively, one can provide `--train-samples` which is total number of samples to train on. If this option is present, then instead of providing `--lr-decay-iters`, one will need to provide `--lr-decay-samples`.\n\nThe logging, checkpoint-saving, and evaluation interval options are specified. Note that the `--data-path` now includes the additional `_text_sentence` suffix added in preprocessing, but does not include the file extensions.\n\nFurther command line arguments are described in the source file [`arguments.py`](./megatron/training/arguments.py).\n\nTo run `train_bert_340m_distributed.sh`, make any desired modifications including setting the environment variables for `CHECKPOINT_PATH`, `VOCAB_FILE`, and `DATA_PATH`. Make sure to set these variables to their paths in the container. Then launch the container with Megatron and necessary paths mounted (as explained in [Setup](#setup)) and run the example script.\n\n## GPT Pretraining\n\nThe `examples/gpt3/train_gpt3_175b_distributed.sh` script runs single GPU 345M parameter GPT pretraining. As mentioned above, single GPU training is primarily intended for debugging purposes, as the code is optimized for distributed training.\n\nIt follows largely the same format as the previous BERT script with a few notable differences: the tokenization scheme used is BPE (which requires a merge table and a `json` vocabulary file) instead of WordPiece, the model architecture allows for longer sequences (note that the max position embedding must be greater than or equal to the maximum sequence length), and the `--lr-decay-style` has been set to cosine decay.  Note that the `--data-path` now includes the additional `_text_document` suffix added in preprocessing, but does not include the file extensions.\n\nFurther command line arguments are described in the source file [`arguments.py`](./megatron/training/arguments.py).\n\n`train_gpt3_175b_distributed.sh` can be launched the same way as described for BERT. Set the env vars and make any other modifications, launch the container with appropriate mounts, and run the script.\nMore details in [`examples/gpt3/README.md`](./examples/gpt3/README.md)\n\n## T5 Pretraining\n\nVery similar to BERT and GPT, the `examples/t5/train_t5_220m_distributed.sh` script runs single GPU \"base\" (~220M parameter) T5 pretraining. The primary difference from BERT and GPT is the addition of the following arguments to accommodate the T5 architecture:\n\n* `--kv-channels` sets the inner dimension of the \"key\" and \"value\" matrices of all attention mechanisms in the model. For BERT and GPT this defaults to the hidden size divided by the number of attention heads, but can be configured for T5.\n\n* `--ffn-hidden-size` sets the hidden size in the feed-forward networks within a transformer layer. For BERT and GPT this defaults to 4 times the transformer hidden size, but can be configured for T5.\n\n* `--encoder-seq-length` and `--decoder-seq-length` set the sequence length for the encoder and decoder separately.\n\nAll of the other arguments remain as they were for BERT and GPT pretraining. Run this example with the same steps described above for the other scripts.\n\nMore details in [`examples/t5/README.md`](./examples/t5/README.md)\n\n## Distributed Pretraining\n\nThe `pretrain_{bert,gpt,t5}_distributed.sh` scripts use the PyTorch distributed launcher for distributed training. As such, multi-node training can be achieved by properly setting environment variables. See the official PyTorch [documentation](https://pytorch.org/docs/stable/elastic/run.html#launcher-api) for further description of these [environment variables](https://pytorch.org/docs/stable/distributed.html#environment-variable-initialization). By default, multi-node training uses the [nccl](https://developer.nvidia.com/nccl) distributed backend. A simple set of additional arguments and the use of the PyTorch distributed module with the `torchrun` elastic launcher (equivalent to `python -m torch.distributed.run`) are the only additional requirements to adopt distributed training. See any of `pretrain_{bert,gpt,t5}_distributed.sh` for more details.\n\nWe use two types of parallelism: data and model parallelism. Our data parallelism implementation is in `megatron/core/distributed`, and supports overlapping of the gradient reduction with the backward pass when the `--overlap-grad-reduce` command-line option is used.\n\nSecond, we developed a simple and efficient two-dimensional model-parallel approach. To use the first dimension, tensor model parallelism (splitting execution of a single transformer module over multiple GPUs, see Section 3 of [our paper](https://arxiv.org/pdf/1909.08053.pdf)), add the `--tensor-model-parallel-size` flag to specify the number of GPUs among which to split the model, along with the arguments passed to the distributed launcher as mentioned above. To use the second dimension, sequence parallelism, specify `--sequence-parallel`, which also requires tensor model parallelism to be enabled because it splits across the same GPUs (more details in Section 4.2.2 of [our paper](https://arxiv.org/pdf/2205.05198.pdf)).\n\nTo use pipeline model parallelism (sharding the transformer modules into stages with an equal number of transformer modules on each stage, and then pipelining execution by breaking the batch into smaller microbatches, see Section 2.2 of [our paper](https://arxiv.org/pdf/2104.04473.pdf)), use the `--pipeline-model-parallel-size` flag to specify the number of stages to split the model into (e.g., splitting a model with 24 transformer layers across 4 stages would mean each stage gets 6 transformer layers each).\n\nWe have examples of how to use these two different forms of model parallelism the example scripts ending in `distributed_with_mp.sh`.\n\nOther than these minor changes, the distributed training is identical to the training on a single GPU.\n\nThe interleaved pipelining schedule (more details in Section 2.2.2 of [our paper](https://arxiv.org/pdf/2104.04473.pdf)) can be enabled using the `--num-layers-per-virtual-pipeline-stage` argument, which controls the number of transformer layers in a virtual stage (by default with the non-interleaved schedule, each GPU will execute a single virtual stage with `NUM_LAYERS / PIPELINE_MP_SIZE` transformer layers). The total number of layers in the transformer model should be divisible by this argument value. Additionally, the number of microbatches in the pipeline (computed as `GLOBAL_BATCH_SIZE / (DATA_PARALLEL_SIZE * MICRO_BATCH_SIZE)`) should be divisible by the `PIPELINE_MP_SIZE` when using this schedule (this condition is checked in an assertion in the code). The interleaved schedule is not supported for pipelines with 2 stages (`PIPELINE_MP_SIZE=2`).\n\n## Activation Checkpointing and Recomputation\n\nTo reduce GPU memory usage when training a large model, we support various forms of activation checkpointing and recomputation. Instead of all activations being stored in memory to be used during backprop, as was traditionally the case in deep learning models, only activations at certain \"checkpoints\" in the model are retained (or stored) in memory, and the other activations are recomputed on-the-fly when needed for backprop. Note that this kind of checkpointing, *activation* checkpointing, is very different from the checkpointing of model parameters and optimizer state, which is mentioned elsewhere.\n\nWe support two levels of recompute granularity: `selective` and `full`. Selective recomputation is the default and is recommended in almost all cases. This mode retains in memory the activations that take less memory storage space and are more expensive to recompute and recomputes the activations that take more memory storage space but are relatively inexpensive to recompute. See [our paper](https://arxiv.org/pdf/2205.05198) for details. You should find that this mode maximizes performance while minimizing the memory required to store activations. To enable selective activation recompute simply use `--recompute-activations`.\n\nFor cases where memory is very limited, `full` recompute saves just the inputs to a transformer layer, or a group, or block, of transformer layers, and recomputes everything else. To enable full activation recompute use `--recompute-granularity full`. When using `full` activation recompute, there are two methods: `uniform` and `block`, chosen using the `--recompute-method` argument.\n\n* The `uniform` method uniformly divides the transformer layers into groups of layers (each group of size `--recompute-num-layers`) and stores the input activations of each group in memory. The baseline group size is 1 and, in this case, the input activation of each transformer layer is stored. When the GPU memory is insufficient, increasing the number of layers per group reduces the memory usage, enabling a bigger model to be trained. For example, when `--recompute-num-layers` is set to 4, only the input activation of each group of 4 transformer layers is stored.\n\n* The `block` method recomputes the input activations of a specific number (given by `--recompute-num-layers`) of individual transformer layers per pipeline stage and stores the input activations of the remaining layers in the pipeline stage. Reducing `--recompute-num-layers` results in storing the input activations to more transformer layers, which reduces the activation recomputation required in the backprop, thus improving training performance while increasing memory usage. For example, when we specify 5 layers to recompute of 8 layers per pipeline stage, the input activations of only the first 5 transformer layers are recomputed in the backprop step while the input activations for the final 3 layers are stored. `--recompute-num-layers` can be incrementally increased until the amount of memory storage space required is just small enough to fit in the available memory, thereby both maximally utilizing memory and maximizing performance.\n\n\n## Distributed Optimizer\n\nUsage: `--use-distributed-optimizer`. Compatible with all model and data types.\n\nThe distributed optimizer is a memory savings technique, whereby the optimizer state is evenly distributed across data parallel ranks (versus the traditional method of replicating the optimizer state across data parallel ranks). As described in [ZeRO: Memory Optimizations Toward Training Trillion Parameter Models](https://arxiv.org/abs/1910.02054), our implementation distributes all optimizer state that does not overlap with the model state. For example, when using fp16 model params, the distributed optimizer maintains its own separate copy of fp32 main params & grads, which are distributed across DP ranks. When using bf16 model params, however, the distributed optimizer's fp32 main grads are the same as the model's fp32 grads, and so the grads in this case are not distributed (although the fp32 main params are still distributed, as they are separate from the bf16 model params).\n\nTheoretical memory savings vary depending on the combination of the model's param dtype and grad dtype. In our implementation, the theoretical number of bytes per parameter is (where 'd' is the data parallel size):\n\n| | Non-distributed optim | Distributed optim |\n|-|-|-|\n| fp16 param, fp16 grads | 20 | 4 + 16/d |\n| bf16 param, fp32 grads | 18 | 6 + 12/d |\n| fp32 param, fp32 grads | 16 | 8 + 8/d |\n\nAs with regular data parallelism, overlapping of the gradient reduction (in this case, a reduce-scatter) with the backward pass can be facilitated using the `--overlap-grad-reduce` flag. Additionally, overlapping of the parameter all-gather can be overlapped with the forward pass using `--overlap-param-gather`.\n\n## FlashAttention\n\nUsage: `--use-flash-attn`. Support attention head dimensions at most 128.\n\n[FlashAttention](https://github.com/HazyResearch/flash-attention) is a fast and\nmemory-efficient algorithm to compute exact attention. It speeds up model\ntraining and reduces memory requirement.\n\nTo install FlashAttention:\n```sh\npip install flash-attn\n```\n\n## GPT-3 Example\n\nIn `examples/gpt3/train_gpt3_175b_distributed.sh` we have provided an example of how to configure Megatron to train [GPT-3](https://arxiv.org/abs/2005.14165) with 175 billion parameters on 1024 GPUs. The script is designed for [slurm](https://slurm.schedmd.com/documentation.html) with [pyxis](https://github.com/NVIDIA/pyxis) plugin but can be easily adopted to any other scheduler. It uses 8-way tensor parallelism and 16-way pipeline parallelism. With options `global-batch-size 1536` and `rampup-batch-size 16 16 5859375`, the training will start with global batch size 16 and linearly increase the global batch size to 1536 over 5,859,375 samples with incremental steps 16. The training dataset can be either a single set or a multiple datasets combined with a set of weights.\n\nWith full global batch size of 1536 on 1024 A100 GPUs, each iteration takes around 32 seconds resulting in 138 teraFLOPs per GPU which is 44% of the theoretical peak FLOPs.\n\n## Retro and InstructRetro\n\n\nRetro [(Borgeaud et al., 2022)](https://arxiv.org/abs/2112.04426) is an autoregressive decoder-only language model (LM) pretrained with retrieval-augmentation.\nRetro features practical scalability to support large-scale pretraining from scratch by retrieving from trillions of tokens.\nPretraining with retrieval provides a more efficient storage mechanism of factual knowledge, when compared to storing factual knowledge implicitly within the network's parameters, thus largely reducing model parameters while achieving lower perplexity than standard GPT.\nRetro also provides the flexibility to update the\nknowledge stored in LMs [(Wang et al., 2023a)](https://arxiv.org/abs/2304.06762)\nby updating the retrieval database without training LMs again.\n\nInstructRetro [(Wang et al., 2023b)](https://arxiv.org/abs/2310.07713) further scales up the size of Retro to 48B, featuring the largest LLM pretrained with retrieval (as of December 2023).\nThe obtained foundation model, Retro 48B, largely outperforms the GPT counterpart in terms of perplexity.\nWith instruction tuning on Retro, InstructRetro demonstrates significant improvement over the instruction tuned GPT on downstream tasks in the zero-shot setting. Specifically, the average improvement of InstructRetro is 7% over its GPT counterpart across 8 short-form QA tasks, and 10% over GPT across 4 challenging long-form QA tasks. We also find that one can ablate the encoder from InstructRetro architecture and directly use the InstructRetro decoder backbone as GPT, while achieving comparable results.\n\nIn this repo, we provide an end-to-end reproduction guide to implement Retro and InstructRetro, covering\n- **Retrieval database construction**, which supports billions or even trillions of tokens as a large-scale retrieval database.\n- **Pretraining with retrieval**, which supports pretraining from scratch and pretraining from a pretrained GPT model (Retro-fitting).\n- **Instruction tuning**, where we provide an open-source instruction tuning dataset and the training recipe for instruction tuning on Retro.\n- **Downstream task evaluation**, where we provide the text generation and evaluation scripts for zero-shot question answering tasks.\n\nSee [tools/retro/README.md](tools/retro/README.md) for a detailed overview.\n\n## Mamba-based Language Models\n\nSee [examples/mamba](./examples/mamba) for details.\n\n<!--\n## REALM Pipeline\nWe are working on implementing the [REALM](https://arxiv.org/pdf/2002.08909.pdf) system. The following sections (will) reflect the three stages of training it. For now it's just the ICT code.\nLoosely, they are pretraining the retriever modules, then jointly training the language model and the retriever, and then finetuning a question answering head on the language model with fixed retriever.\n\n### Inverse Cloze Task (ICT) Pretraining\n1. Have a corpus in loose JSON format with the intention of creating a collection of fixed-size blocks of text as the fundamental units of data. For a corpus like Wikipedia, this will mean multiple sentences per block but also multiple blocks per document.\nRun `tools/preprocess_data.py` to construct one or more indexed datasets with the `--split-sentences` argument to make sentences the basic unit. For the original REALM system, we construct two datasets, one with the title of every document, and another with the body.\nRefer to the following script\n<pre>\npython preprocess_data.py \\\n    --input /path/to/corpus.json \\\n    --json-keys text title \\\n    --split-sentences \\\n    --tokenizer-type BertWordPieceLowerCase \\\n    --vocab-file /path/to/vocab.txt \\\n    --output-prefix corpus_indexed \\\n    --workers 5  # works well for 10 CPU cores. Scale up accordingly.\n</pre>\n\n2. Use a custom samples mapping function in place of `megatron/legacy/data/realm_dataset_utils.get_block_samples_mapping` if required. To do this, you will need to implement a new function in C++ inside of `megatron/core/datasets/helpers.cpp`. The samples mapping data structure is used to select the data that will constitute every training sample in advance of the training loop.\n The samples mapping is responsible for holding all of the required metadata needed to construct the sample from one or more indexed datasets. In REALM, the samples mapping contains the start and end sentence indices, as well as the document index (to find the correct title for a body) and a unique ID for every block.\n3. Pretrain a BERT language model using `pretrain_bert.py`, with the sequence length equal to the block size in token ids. This model should be trained on the same indexed dataset that is used to supply the blocks for the information retrieval task.\nIn REALM, this is an uncased bert base model trained with the standard hyperparameters.\n4. Use `pretrain_ict.py` to train an `ICTBertModel` which uses two BERT-based encoders to encode queries and blocks to perform retrieval with.\nThe script below trains the ICT model from REALM. It references a pretrained BERT model (step 3) in the `--bert-load` argument. The batch size used in the paper is 4096, so this would need to be run with data parallel world size 32.\n<pre>\npython pretrain_ict.py \\\n    --num-layers 12 \\\n    --num-attention-heads 12 \\\n    --hidden-size 768 \\\n    --batch-size 128 \\\n    --seq-length 256 \\\n    --max-position-embeddings 256 \\\n    --ict-head-size 128 \\\n    --train-iters 100000 \\\n    --bert-load /path/to/pretrained_bert \\\n    --load checkpoints \\\n    --save checkpoints \\\n    --data-path /path/to/indexed_dataset \\\n    --titles-data-path /path/to/titles_indexed_dataset \\\n    --vocab-file /path/to/vocab.txt \\\n    --lr 0.0001 \\\n    --num-workers 2 \\\n    --lr-decay-style linear \\\n    --weight-decay 1e-2 \\\n    --clip-grad 1.0 \\\n    --lr-warmup-fraction .01 \\\n    --save-interval 3000 \\\n    --query-in-block-prob 0.1 \\\n    --fp16\n\n</pre>\n\n### Building an Index of Block Embeddings\nAfter having trained an ICT model, you can now embed an entire dataset of blocks by creating a `BlockData` structure. After that has been saved, you can load it\nand wrap it with a `FaissMIPSIndex` to do fast similarity search which is key in the learned information retrieval pipeline. The initial index can be built with the following script, meant to be run in an interactive session. It can leverage multiple GPUs on multiple nodes to index large datasets much more quickly.\n\n<pre>\npython tools/create_doc_index.py \\\n    --num-layers 12 \\\n    --hidden-size 768 \\\n    --ict-head-size 128 \\\n    --num-attention-heads 12 \\\n    --batch-size 128 \\\n    --seq-length 256 \\\n    --max-position-embeddings 256 \\\n    --ict-load /path/to/pretrained_ict \\\n    --data-path /path/to/indexed_dataset \\\n    --titles-data-path /path/to/titles_indexed_dataset \\\n    --block-data-path embedded_blocks.pkl \\\n    --indexer-log-interval 1000 \\\n    --indexer-batch-size 128 \\\n    --vocab-file /path/to/vocab.txt \\\n    --num-workers 2 \\\n    --fp16\n</pre>\n\n-->\n\n## Mixture of Experts\nMoE (Mixture of Experts) is a powerful LLM architecture implemented in the Megatron-Core framework, designed to enhance the efficiency and scalability of large language models. It leverages **Expert Parallelism**, allowing multiple experts to be distributed across different workers, where each worker processes distinct batches of training samples. This method significantly increases computational throughput, enabling models to achieve high performance metrics, such as 47% MFU during BF16 training for 8x7B on H100.\n\nKey Features of MoE:\n- **Parallelism Techniques**: MoE combines various parallelism strategies, including Expert Parallelism, Data Parallelism, Tensor Parallelism, Sequence Paralleism, Pipeline Parallelism, and Context Parallelism. This combination allows for handling larger model variants effectively.\n- **Router and Load Balancing**: The system employs advanced routing mechanisms like the Top-K router and utilizes load balancing algorithms to optimize token distribution among experts.\n- **Performance Optimizations**: Techniques such as GroupedGEMM and FP8 training enhance the efficiency of MoE models, particularly when multiple experts are involved.\n- **Token Dispatch Mechanism**: MoE supports both dropless and token drop strategies to manage token distribution effectively across experts.\n\nFor a comprehensive overview of MoE training configurations and optimizations, please refer to the detailed README located at [megatron/core/transformer/moe/README.md](./megatron/core/transformer/moe/README.md).\n\n# Evaluation and Tasks\n\nWe provide several command line arguments, detailed in the scripts listed below, to handle various zero-shot and fine-tuned downstream tasks. However, you can also finetune your model from a pretrained checkpoint on other corpora as desired. To do so, simply add the `--finetune` flag and adjust the input files and training parameters within the original training script. The iteration count will be reset to zero, and the optimizer and internal state will be reinitialized. If the fine-tuning is interrupted for any reason, be sure to remove the `--finetune` flag before continuing, otherwise the training will start again from the beginning.\n\nBecause evaluation requires substantially less memory than training, it may be advantageous to merge a model trained in parallel for use on fewer GPUs in downstream tasks. The following script accomplishes this. This example reads in a GPT model with 4-way tensor and 4-way pipeline model parallelism and writes out a model with 2-way tensor and 2-way pipeline model parallelism.\n\n<pre>\npython tools/checkpoint/convert.py \\\n        --model-type GPT \\\n        --load-dir checkpoints/gpt3_tp4_pp4 \\\n        --save-dir checkpoints/gpt3_tp2_pp2 \\\n        --target-tensor-parallel-size 2 \\\n        --target-pipeline-parallel-size 2\n\n</pre>\n\nSeveral downstream tasks are described for both GPT and BERT models below. They can be run in distributed and model parallel modes with the same changes used in the training scripts.\n\n## GPT Text Generation\n\nWe have included a simple REST server to use for text generation in `tools/run_text_generation_server.py`. You run it much like you would start a pretraining job, specifying an appropriate pretrained checkpoint. There are also few optional parameters: `temperature`, `top-k`and `top-p`. See `--help` or the source file for more information. See [examples/inference/run_text_generation_server_345M.sh](examples/inference/run_text_generation_server_345M.sh) for an example of how to run the server.\n\nOnce the server is running you can use `tools/text_generation_cli.py` to query it, it takes one argument which is the host the server is running on.\n\n<pre>\ntools/text_generation_cli.py localhost:5000\n</pre>\n\nYou can also use CURL or any other tools to query the server directly:\n\n<pre>\ncurl 'http://localhost:5000/api' -X 'PUT' -H 'Content-Type: application/json; charset=UTF-8'  -d '{\"prompts\":[\"Hello world\"], \"tokens_to_generate\":1}'\n</pre>\n\nSee [megatron/inference/text_generation_server.py](megatron/inference/text_generation_server.py) for more API options.\n\n### Detoxify GPT via Self-generation\nWe include an example in `examples/academic_paper_scripts/detxoify_lm/` to detoxify language models by leveraging the generative power of language models.\n\nSee [examples/academic_paper_scripts/detxoify_lm/README.md](examples/academic_paper_scripts/detxoify_lm/README.md) for step-by-step tutorials on how to perform domain-adaptive training and detoxify LM using self-generated corpus.\n\n\n## GPT Evaluation\nWe include example scripts for GPT evaluation on WikiText perplexity evaluation and LAMBADA Cloze accuracy.\n\n### WikiText Perplexity Evaluation\nFor even comparison with prior works, we evaluate perplexity on the word-level [WikiText-103 test dataset](https://s3.amazonaws.com/research.metamind.io/wikitext/wikitext-103-v1.zip), and appropriately compute perplexity given the change in tokens when using our subword tokenizer.\n\nWe use the following command to run WikiText-103 evaluation on a 345M parameter model.\n<pre>\nTASK=\"WIKITEXT103\"\n\nVALID_DATA=&#60;wikitext path&#62;.txt\nVOCAB_FILE=gpt2-vocab.json\nMERGE_FILE=gpt2-merges.txt\nCHECKPOINT_PATH=checkpoints/gpt2_345m\n\nCOMMON_TASK_ARGS=\"--num-layers 24 \\\n                  --hidden-size 1024 \\\n                  --num-attention-heads 16 \\\n                  --seq-length 1024 \\\n                  --max-position-embeddings 1024 \\\n                  --fp16 \\\n                  --vocab-file $VOCAB_FILE\"\n\npython tasks/main.py \\\n       --task $TASK \\\n       $COMMON_TASK_ARGS \\\n       --valid-data $VALID_DATA \\\n       --tokenizer-type GPT2BPETokenizer \\\n       --merge-file $MERGE_FILE \\\n       --load $CHECKPOINT_PATH \\\n       --micro-batch-size 8 \\\n       --log-interval 10 \\\n       --no-load-optim \\\n       --no-load-rng\n</pre>\n\n\n### LAMBADA Cloze Accuracy\nTo compute LAMBADA cloze accuracy (the accuracy of predicting the last token given the preceding tokens) we utilize a detokenized, processed version of the [LAMBADA dataset](https://github.com/cybertronai/bflm/blob/master/lambada_test.jsonl).\n\nWe use the following command to run LAMBADA evaluation on a 345M parameter model. Note that the `--strict-lambada` flag should be used to require whole word matching. Ensure that `lambada` is part of the file path.\n\n<pre>\nTASK=\"LAMBADA\"\n\nVALID_DATA=&#60;lambada path&#62;.json\nVOCAB_FILE=gpt2-vocab.json\nMERGE_FILE=gpt2-merges.txt\nCHECKPOINT_PATH=checkpoints/gpt2_345m\nCOMMON_TASK_ARGS=&#60;same as those in <a href=\"#wikitext-perplexity-evaluation\">WikiText Perplexity Evaluation</a> above&#62;\n\npython tasks/main.py \\\n       --task $TASK \\\n       $COMMON_TASK_ARGS \\\n       --valid-data $VALID_DATA \\\n       --tokenizer-type GPT2BPETokenizer \\\n       --strict-lambada \\\n       --merge-file $MERGE_FILE \\\n       --load $CHECKPOINT_PATH \\\n       --micro-batch-size 8 \\\n       --log-interval 10 \\\n       --no-load-optim \\\n       --no-load-rng\n</pre>\n\nFurther command line arguments are described in the source file [`main.py`](./tasks/main.py)\n\n## BERT Task Evaluation\n### RACE Evaluation\nThe following script finetunes the BERT model for evaluation on the [RACE dataset](http://www.cs.cmu.edu/~glai1/data/race/). The `TRAIN_DATA` and `VALID_DATA` directory contain the RACE dataset as separate `.txt` files. Note that for RACE, the batch size is the number of RACE query's to evaluate. Since each RACE query has four samples, the effective batch size passed through the model will be four times the batch size specified on the command line.\n\n<pre>\nTRAIN_DATA=\"data/RACE/train/middle\"\nVALID_DATA=\"data/RACE/dev/middle \\\n            data/RACE/dev/high\"\nVOCAB_FILE=bert-vocab.txt\nPRETRAINED_CHECKPOINT=checkpoints/bert_345m\nCHECKPOINT_PATH=checkpoints/bert_345m_race\nCOMMON_TASK_ARGS=\"--num-layers 24 \\\n                  --hidden-size 1024 \\\n                  --num-attention-heads 16 \\\n                  --seq-length 512 \\\n                  --max-position-embeddings 512 \\\n                  --fp16 \\\n                  --vocab-file $VOCAB_FILE\"\n\nCOMMON_TASK_ARGS_EXT=\"--train-data $TRAIN_DATA \\\n                      --valid-data $VALID_DATA \\\n                      --pretrained-checkpoint $PRETRAINED_CHECKPOINT \\\n                      --save-interval 10000 \\\n                      --save $CHECKPOINT_PATH \\\n                      --log-interval 100 \\\n                      --eval-interval 1000 \\\n                      --eval-iters 10 \\\n                      --weight-decay 1.0e-1\"\n\npython tasks/main.py \\\n       --task RACE \\\n       $COMMON_TASK_ARGS \\\n       $COMMON_TASK_ARGS_EXT \\\n       --tokenizer-type BertWordPieceLowerCase \\\n       --epochs 3 \\\n       --micro-batch-size 4 \\\n       --lr 1.0e-5 \\\n       --lr-warmup-fraction 0.06\n</pre>\n\n### MNLI Evaluation\nThe following script finetunes the BERT model for evaluation with the [MultiNLI sentence pair corpus](https://www.nyu.edu/projects/bowman/multinli/). Because the matching tasks are quite similar, the script can be quickly tweaked to work with the [Quora Question Pairs](https://www.kaggle.com/quora/question-pairs-dataset) (QQP) dataset as well.\n\n<pre>\n\nTRAIN_DATA=\"data/glue_data/MNLI/train.tsv\"\nVALID_DATA=\"data/glue_data/MNLI/dev_matched.tsv \\\n            data/glue_data/MNLI/dev_mismatched.tsv\"\nPRETRAINED_CHECKPOINT=checkpoints/bert_345m\nVOCAB_FILE=bert-vocab.txt\nCHECKPOINT_PATH=checkpoints/bert_345m_mnli\nCOMMON_TASK_ARGS=&#60;same as those in <a href=\"#race-evaluation\">RACE Evaluation</a> above&#62;\nCOMMON_TASK_ARGS_EXT=&#60;same as those in <a href=\"#race-evaluation\">RACE Evaluation</a> above&#62;\n\npython tasks/main.py \\\n       --task MNLI \\\n       $COMMON_TASK_ARGS \\\n       $COMMON_TASK_ARGS_EXT \\\n       --tokenizer-type BertWordPieceLowerCase \\\n       --epochs 5 \\\n       --micro-batch-size 8 \\\n       --lr 5.0e-5 \\\n       --lr-warmup-fraction 0.065\n</pre>\n\n## Llama-2 Inference and Finetuning\n\nThe Llama-2 [family of models](https://ai.meta.com/llama/) are an open-source set of pretrained & finetuned (for chat) models that have achieved strong results across a wide set of benchmarks. At the time of release, Llama-2 models achieved among the best results for open-source models, and were competitive with the closed-source GPT-3.5 model (see https://arxiv.org/pdf/2307.09288.pdf).\n\nThe Llama-2 checkpoints can be loaded into Megatron for inference and finetuning. See documentation [here](docs/llama_mistral.md).\n\n# Model Optimization and Deployment\nMegatron-Core (MCore) `GPTModel` family supports advanced quantization algorithms and high-performance inference through TensorRT-LLM.\n\n## Quantization and TensorRT-LLM Deployment\nSee [Megatron Model Optimization and Deployment](examples/inference/quantization/README.md) for `llama2` and `nemotron3` examples.\n\n# Datasets\nWe do not host any datasets for GPT or BERT training, however, we detail their collection so that our results may be reproduced.\n\n## Collecting Wikipedia Training Data\nWe recommend following the Wikipedia data extraction process specified by Google research: \"the recommended pre-processing is to download [the latest dump](https://dumps.wikimedia.org/enwiki/latest/enwiki-latest-pages-articles.xml.bz2), extract the text with [WikiExtractor.py](https://github.com/attardi/wikiextractor), and then apply any necessary cleanup to convert it into plain text.\"\n\nWe recommend using the `--json` argument when using WikiExtractor, which will dump the Wikipedia data into loose json format (one json object per line), making it more manageable on the file system and also readily consumable by our codebase. We recommend further preprocessing this json dataset with nltk punctuation standardization. For BERT training, use the `--split-sentences` flag to `preprocess_data.py` as described [above](#data-preprocessing) to include sentence breaks in the produced index. If you'd like to use Wikipedia data for GPT training you should still clean it with nltk/spacy/ftfy, but do not use the `--split-sentences` flag.\n\n## Collecting GPT Webtext Data\nWe utilize the publicly available [OpenWebText](https://github.com/eukaryote31/openwebtext) library from [jcpeterson](https://github.com/jcpeterson/openwebtext) and [eukaryote31's](https://github.com/eukaryote31/openwebtext) work to download urls. We then filter, clean, and deduplicate all downloaded content according to the procedure described in our [openwebtext](./tools/openwebtext) directory. For reddit URLs corresponding to content up to October 2018 we arrived at approximately 37GB of content.\n\n# Reproducibility\nMegatron training can be bitwise reproducible; to enable this mode use `--deterministic-mode`. This means that the same training config run twice in the same HW and SW environment should produce identical model checkpoints, losses and accuracy metric values (iteration time metrics may vary).\n\nThere are currently three known Megatron optimizations that break reproducibility whilst still producing almost identical training runs:\n1. The specific NCCL algorithm that is used during an all-reduce (as specified by the environment variable `NCCL_ALGO`) is important. We have tested the following: `^NVLS`, `Tree`, `Ring`, `CollnetDirect`, `CollnetChain`. The code admits the use of `^NVLS`, which allows NCCL the choice of non-NVLS algorithms; its choice seems to be stable.\n2. Flash attention is non-deterministic; do not use `--use-flash-attn`.\n3. If using Transformer Engine, you must also set the environment variable `NVTE_ALLOW_NONDETERMINISTIC_ALGO=0`.\n\nIn addition, determinisim has only been verified in NGC PyTorch containers up to and newer than 23.12. If you observe nondeterminism in Megatron training under other circumstances please open an issue.\n\n## Projects Using Megatron\nBelow are some of the projects where we have directly used Megatron:\n* [BERT and GPT Studies Using Megatron](https://arxiv.org/pdf/1909.08053.pdf)\n* [BioMegatron: Larger Biomedical Domain Language Model](https://www.aclweb.org/anthology/2020.emnlp-main.379.pdf)\n* [End-to-End Training of Neural Retrievers for Open-Domain Question Answering](https://arxiv.org/abs/2101.00408)\n* [Large Scale Multi-Actor Generative Dialog Modeling](https://www.aclweb.org/anthology/2020.acl-main.8.pdf)\n* [Local Knowledge Powered Conversational Agents](https://arxiv.org/abs/2010.10150)\n* [MEGATRON-CNTRL: Controllable Story Generation with External Knowledge Using Large-Scale Language Models](https://www.aclweb.org/anthology/2020.emnlp-main.226.pdf)\n* [RACE Reading Comprehension Dataset Leaderboard](http://www.qizhexie.com/data/RACE_leaderboard.html)\n* [Training Question Answering Models From Synthetic Data](https://www.aclweb.org/anthology/2020.emnlp-main.468.pdf)\n* [Few-shot Instruction Prompts for Pretrained Language Models to Detect Social Biases](https://arxiv.org/abs/2112.07868)\n* [Exploring the Limits of Domain-Adaptive Training for Detoxifying Large-Scale Language Models](https://arxiv.org/abs/2202.04173)\n* [Using DeepSpeed and Megatron to Train Megatron-Turing NLG 530B, A Large-Scale Generative Language Model](https://arxiv.org/abs/2201.11990)\n* [Multi-Stage Prompting for Knowledgeable Dialogue Generation](https://arxiv.org/abs/2203.08745)\n* [Evaluating Parameter Efficient Learning for Generation](https://aclanthology.org/2022.emnlp-main.319.pdf)\n* [Exploring the Limits of Domain-Adaptive Training for Detoxifying Large-Scale Language Models](https://arxiv.org/abs/2202.04173)\n* [Shall We Pretrain Autoregressive Language Models with Retrieval? A Comprehensive Study](https://arxiv.org/abs/2304.06762)\n* [InstructRetro: Instruction Tuning post Retrieval-Augmented Pretraining](https://arxiv.org/abs/2310.07713)\n* [An Empirical Study of Mamba-based Language Models](https://arxiv.org/abs/2406.07887)\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "images",
          "type": "tree",
          "content": null
        },
        {
          "name": "megatron",
          "type": "tree",
          "content": null
        },
        {
          "name": "mypy.ini",
          "type": "blob",
          "size": 0.3037109375,
          "content": "[mypy]\nignore_missing_imports = True\ncheck_untyped_defs = False\ndisallow_untyped_calls = False\ndisallow_untyped_defs = False\ndisallow_incomplete_defs = False\n\ndisable_error_code = call-arg,operator,var-annotated,union-attr,import-untyped\n\n# Enable only `assignment` error checking\nenable_error_code = assignment"
        },
        {
          "name": "pretrain_bert.py",
          "type": "blob",
          "size": 6.6220703125,
          "content": "# Copyright (c) 2022, NVIDIA CORPORATION.  All rights reserved.\n\n\"\"\"Pretrain BERT\"\"\"\n\nfrom functools import partial\n\nimport torch\nimport torch.nn.functional as F\n\nfrom megatron.training import get_args\nfrom megatron.training import get_tokenizer\nfrom megatron.training import print_rank_0\nfrom megatron.training import get_timers\nfrom megatron.core import tensor_parallel\nfrom megatron.core.enums import ModelType\nimport megatron.legacy.model\nfrom megatron.core.models.bert.bert_model import BertModel\nfrom megatron.training import pretrain\nfrom megatron.training.utils import average_losses_across_data_parallel_group\nfrom megatron.training.arguments import core_transformer_config_from_args\nfrom megatron.core.transformer.spec_utils import import_module\nfrom megatron.core.models.bert.bert_layer_specs import bert_layer_with_transformer_engine_spec, bert_layer_local_spec\nfrom megatron.core.datasets.blended_megatron_dataset_builder import BlendedMegatronDatasetBuilder\nfrom megatron.core.datasets.bert_dataset import BERTMaskedWordPieceDataset, BERTMaskedWordPieceDatasetConfig\nfrom megatron.core.datasets.utils import get_blend_from_list\nfrom megatron.core import mpu, tensor_parallel\n\n\ndef model_provider(pre_process=True, post_process=True):\n    \"\"\"Build the model.\"\"\"\n\n    print_rank_0('building BERT model ...')\n\n    args = get_args()\n    config = core_transformer_config_from_args(args)\n    num_tokentypes = 2 if args.bert_binary_head else 0\n\n    if args.use_legacy_models:\n        model = megatron.legacy.model.BertModel(\n            config=config,\n            num_tokentypes=num_tokentypes,\n            add_binary_head=args.bert_binary_head,\n            parallel_output=True,\n            pre_process=pre_process,\n            post_process=post_process)\n    else:\n        if args.spec is None:\n            transformer_layer_spec = bert_layer_with_transformer_engine_spec #default spec\n        elif args.spec[0] == 'local':\n            print_rank_0('Using Local spec for transformer layers')\n            transformer_layer_spec = bert_layer_local_spec\n        else :\n            transformer_layer_spec = import_module(args.spec)\n\n        model = BertModel(\n            config=config,\n            transformer_layer_spec=transformer_layer_spec,\n            vocab_size=args.padded_vocab_size,\n            max_sequence_length=args.max_position_embeddings,\n            num_tokentypes=num_tokentypes,\n            add_binary_head=args.bert_binary_head,\n            share_embeddings_and_output_weights=not args.untie_embeddings_and_output_weights,\n            parallel_output=True,\n            pre_process=pre_process,\n            post_process=post_process)\n\n    return model\n\n\ndef get_batch(data_iterator):\n    \"\"\"Build the batch.\"\"\"\n\n    # Items and their type.\n    keys = ['text', 'types', 'labels',\n            'is_random', 'loss_mask', 'padding_mask']\n    datatype = torch.int64\n\n    # Broadcast data.\n    if data_iterator is not None:\n        data = next(data_iterator)\n    else:\n        data = None\n    data_b = tensor_parallel.broadcast_data(keys, data, datatype)\n\n    # Unpack.\n    tokens = data_b['text'].long()\n    types = data_b['types'].long()\n    sentence_order = data_b['is_random'].long()\n    loss_mask = data_b['loss_mask'].float()\n    lm_labels = data_b['labels'].long()\n    padding_mask = data_b['padding_mask'].long()\n\n    return tokens, types, sentence_order, loss_mask, lm_labels, padding_mask\n\n\ndef loss_func(loss_mask, sentence_order, output_tensor):\n    lm_loss_, sop_logits = output_tensor\n\n    lm_loss_ = lm_loss_.float()\n    loss_mask = loss_mask.float()\n    lm_loss = torch.sum(\n        lm_loss_.view(-1) * loss_mask.reshape(-1)) / loss_mask.sum()\n\n    if sop_logits is not None:\n        sop_loss = F.cross_entropy(sop_logits.view(-1, 2).float(),\n                                   sentence_order.view(-1),\n                                   ignore_index=-1)\n        sop_loss = sop_loss.float()\n        loss = lm_loss + sop_loss\n        averaged_losses = average_losses_across_data_parallel_group(\n            [lm_loss, sop_loss])\n        return loss, {'lm loss': averaged_losses[0],\n                      'sop loss': averaged_losses[1]}\n    else:\n        loss = lm_loss\n        averaged_losses = average_losses_across_data_parallel_group(\n            [lm_loss])\n        return loss, {'lm loss': averaged_losses[0]}\n\n\ndef forward_step(data_iterator, model):\n    \"\"\"Forward step.\"\"\"\n    args = get_args()\n    timers = get_timers()\n\n    # Get the batch.\n    timers('batch-generator', log_level=2).start()\n    tokens, types, sentence_order, loss_mask, lm_labels, padding_mask = get_batch(\n        data_iterator)\n    timers('batch-generator').stop()\n\n    if not args.bert_binary_head:\n        types = None\n\n    # Forward pass through the model.\n    output_tensor = model(tokens, padding_mask,\n                          tokentype_ids=types, lm_labels=lm_labels)\n\n    return output_tensor, partial(loss_func, loss_mask, sentence_order)\n\n\ndef train_valid_test_datasets_provider(train_val_test_num_samples):\n    \"\"\"Build train, valid, and test datasets.\"\"\"\n    args = get_args()\n\n    tokenizer = get_tokenizer()\n\n    config = BERTMaskedWordPieceDatasetConfig(\n        random_seed=args.seed,\n        sequence_length=args.seq_length,\n        blend=get_blend_from_list(args.data_path),\n        blend_per_split=[\n            get_blend_from_list(args.train_data_path),\n            get_blend_from_list(args.valid_data_path),\n            get_blend_from_list(args.test_data_path)\n        ],\n        renormalize_blend_weights=args.renormalize_blend_weights,\n        split=args.split,\n        path_to_cache=args.data_cache_path,\n        tokenizer=tokenizer,\n        masking_probability=args.mask_prob,\n        short_sequence_probability=args.short_seq_prob,\n        masking_max_ngram=3,\n        masking_do_full_word=True,\n        masking_do_permutation=False,\n        masking_use_longer_ngrams=False,\n        masking_use_geometric_distribution=False,\n        classification_head=args.bert_binary_head,\n    )\n\n    print_rank_0('> building train, validation, and test datasets '\n                 'for BERT ...')\n\n    train_ds, valid_ds, test_ds = BlendedMegatronDatasetBuilder(\n        BERTMaskedWordPieceDataset,\n        train_val_test_num_samples,\n        lambda: mpu.get_tensor_model_parallel_rank() == 0,\n        config,\n    ).build()\n\n    print_rank_0(\"> finished creating BERT datasets ...\")\n\n    return train_ds, valid_ds, test_ds\n\n\nif __name__ == \"__main__\":\n\n    # Temporary for transition to core datasets\n    train_valid_test_datasets_provider.is_distributed = True\n\n    pretrain(train_valid_test_datasets_provider, model_provider,\n             ModelType.encoder_or_decoder,\n             forward_step, args_defaults={'tokenizer_type': 'BertWordPieceLowerCase'})\n"
        },
        {
          "name": "pretrain_gpt.py",
          "type": "blob",
          "size": 10.939453125,
          "content": "# Copyright (c) 2023, NVIDIA CORPORATION.  All rights reserved.\n\"\"\"Pretrain GPT.\"\"\"\n\nimport os\nimport torch\nfrom functools import partial\nfrom contextlib import nullcontext\nimport inspect\n\nfrom typing import List, Optional, Tuple, Union\nfrom megatron.training import get_args\nfrom megatron.training import print_rank_0\nfrom megatron.training import get_timers\nfrom megatron.training import get_tokenizer\nfrom megatron.core import mpu\nfrom megatron.core.enums import ModelType\nfrom megatron.core.datasets.blended_megatron_dataset_builder import BlendedMegatronDatasetBuilder\nfrom megatron.core.datasets.gpt_dataset import GPTDatasetConfig\nfrom megatron.core.datasets.gpt_dataset import MockGPTDataset, GPTDataset\nfrom megatron.core.rerun_state_machine import get_rerun_state_machine\nimport megatron.legacy.model\nfrom megatron.core.models.gpt import GPTModel\nfrom megatron.training import pretrain\nfrom megatron.core.utils import StragglerDetector\nfrom megatron.core.transformer.spec_utils import import_module\nfrom megatron.training.utils import (\n    get_batch_on_this_cp_rank,\n    get_batch_on_this_tp_rank,\n    get_blend_and_blend_per_split,\n)\nfrom megatron.training.arguments import core_transformer_config_from_args\nfrom megatron.training.yaml_arguments import core_transformer_config_from_yaml\nfrom megatron.core.models.gpt.gpt_layer_specs import (\n    get_gpt_decoder_block_spec,\n    get_gpt_layer_local_spec,\n    get_gpt_layer_with_transformer_engine_spec,\n)\n\n\nstimer = StragglerDetector()\n\ndef model_provider(pre_process=True, post_process=True) -> Union[GPTModel, megatron.legacy.model.GPTModel]:\n    \"\"\"Builds the model.\n\n    If you set the use_legacy_models to True, it will return the legacy GPT model and if not the mcore GPT model.\n\n    Args:\n        pre_process (bool, optional): Set to true if you need to compute embedings. Defaults to True.\n        post_process (bool, optional): Set to true if you need to want to compute output logits/loss. Defaults to True.\n\n\n    Returns:\n        Union[GPTModel, megatron.legacy.model.GPTModel]: The returned model\n    \"\"\"\n    args = get_args()\n    use_te = args.transformer_impl == \"transformer_engine\"\n\n    if args.record_memory_history:\n        torch.cuda.memory._record_memory_history(True,\n            # keep 100,000 alloc/free events from before the snapshot\n            trace_alloc_max_entries=100000,\n\n            # record stack information for the trace events\n            trace_alloc_record_context=True)\n\n    print_rank_0('building GPT model ...')\n    # Experimental loading arguments from yaml\n    if args.yaml_cfg is not None:\n        config = core_transformer_config_from_yaml(args, \"language_model\")\n    else:\n        config = core_transformer_config_from_args(args)\n\n    if args.use_legacy_models:\n        model = megatron.legacy.model.GPTModel(\n            config,\n            num_tokentypes=0,\n            parallel_output=True,\n            pre_process=pre_process,\n            post_process=post_process,\n        )\n    else: # using core models\n        if args.spec is not None:\n            transformer_layer_spec = import_module(args.spec)\n        else:\n            if args.num_experts:\n                # Define the decoder block spec\n                transformer_layer_spec = get_gpt_decoder_block_spec(config, use_transformer_engine=use_te)\n            else:\n                # Define the decoder layer spec\n                if use_te:\n                    transformer_layer_spec = get_gpt_layer_with_transformer_engine_spec(\n                        args.num_experts, args.moe_grouped_gemm,\n                        args.qk_layernorm, args.multi_latent_attention, args.moe_use_legacy_grouped_gemm)\n                else:\n                    transformer_layer_spec = get_gpt_layer_local_spec(\n                        args.num_experts, args.moe_grouped_gemm,\n                        args.qk_layernorm, args.multi_latent_attention, args.moe_use_legacy_grouped_gemm)\n\n        build_model_context = nullcontext\n        build_model_context_args = {}\n        if args.fp8_param_gather:\n            try:\n                from transformer_engine.pytorch import fp8_model_init\n\n                build_model_context = fp8_model_init\n                build_model_context_args[\"enabled\"] = True\n\n                # Check if fp8_model_init supports preserve_high_precision_init_val\n                if \"preserve_high_precision_init_val\" in inspect.signature(fp8_model_init).parameters:\n                    build_model_context_args[\"preserve_high_precision_init_val\"] = True\n            except:\n                raise RuntimeError(\"--fp8-param-gather requires `fp8_model_init` from TransformerEngine, but not found.\")\n\n        with build_model_context(**build_model_context_args):\n            model = GPTModel(\n                config=config,\n                transformer_layer_spec=transformer_layer_spec,\n                vocab_size=args.padded_vocab_size,\n                max_sequence_length=args.max_position_embeddings,\n                pre_process=pre_process,\n                post_process=post_process,\n                fp16_lm_cross_entropy=args.fp16_lm_cross_entropy,\n                parallel_output=True,\n                share_embeddings_and_output_weights=not args.untie_embeddings_and_output_weights,\n                position_embedding_type=args.position_embedding_type,\n                rotary_percent=args.rotary_percent,\n                rotary_base=args.rotary_base,\n                rope_scaling=args.use_rope_scaling\n            )\n\n    return model\n\n\ndef get_batch(data_iterator):\n    \"\"\"Generate a batch.\"\"\"\n\n    # TODO: this is pretty hacky, find a better way\n    if (not mpu.is_pipeline_first_stage()) and (not mpu.is_pipeline_last_stage()):\n        return None, None, None, None, None\n\n    # get batches based on the TP rank you are on\n    batch = get_batch_on_this_tp_rank(data_iterator)\n\n    # slice batch along sequence dimension for context parallelism\n    batch = get_batch_on_this_cp_rank(batch)\n\n    return batch.values()\n\n\n# define spiky loss as a variation of 20% or more\nSPIKY_LOSS_PERC = 0.2\n\n\ndef loss_func(loss_mask: torch.Tensor, output_tensor: torch.Tensor):\n    \"\"\"Loss function.\n\n    Args:\n        loss_mask (torch.Tensor): Used to mask out some portions of the loss\n        output_tensor (torch.Tensor): The tensor with the losses\n\n    Returns:\n        the loss scalar for this micro-batch\n        the number of non-padded tokens in this microbatch\n        a dict containing reporting metrics on the loss and number of tokens across\n            the data parallel ranks\n    \"\"\"\n    args = get_args()\n\n    losses = output_tensor.float()\n    loss_mask = loss_mask.view(-1).float()\n    total_tokens = loss_mask.sum()\n    loss = torch.cat([torch.sum(losses.view(-1) * loss_mask).view(1), total_tokens.view(1)])\n\n    if args.context_parallel_size > 1:\n        torch.distributed.all_reduce(loss, group=mpu.get_context_parallel_group())\n\n    # Check individual rank losses are not NaN prior to DP all-reduce.\n    rerun_state_machine = get_rerun_state_machine()\n    if args.check_for_nan_in_loss_and_grad:\n        rerun_state_machine.validate_result(\n            result=loss[0],\n            rejection_func=torch.isnan,\n            message=\"found NaN in local forward loss calculation\",\n            tolerance=0.0,        # forward pass calculations are determinisic\n            fatal=True,\n        )\n    # Check for spiky loss\n    if args.check_for_spiky_loss:\n        rerun_state_machine.validate_result(\n            result=loss[0],\n            rejection_func=partial(rerun_state_machine.is_spiky_loss, threshold=SPIKY_LOSS_PERC),\n            message=\"Spiky loss\",\n            tolerance=0.0,        # forward pass calculations are determinisic\n            fatal=False,\n        )\n    # Reduce loss for logging.\n    reporting_loss = loss.clone().detach()\n    torch.distributed.all_reduce(reporting_loss, group=mpu.get_data_parallel_group())\n\n    local_num_tokens = loss[1].clone().detach().to(torch.int)\n    return (\n        loss[0] * args.context_parallel_size,\n        local_num_tokens,\n        {'lm loss': (reporting_loss[0], reporting_loss[1])},\n    )\n\n\ndef forward_step(data_iterator, model: GPTModel):\n    \"\"\"Forward training step.\n\n    Args:\n        data_iterator : Input data iterator\n        model (GPTModel): The GPT Model\n    \"\"\"\n    args = get_args()\n    timers = get_timers()\n\n    # Get the batch.\n    timers('batch-generator', log_level=2).start()\n    global stimer\n    with stimer(bdata=True):\n        tokens, labels, loss_mask, attention_mask, position_ids = get_batch(\n            data_iterator)\n    timers('batch-generator').stop()\n\n    with stimer:\n        output_tensor = model(tokens, position_ids, attention_mask,\n                              labels=labels)\n\n    return output_tensor, partial(loss_func, loss_mask)\n\n\ndef is_dataset_built_on_rank():\n    return (\n        mpu.is_pipeline_first_stage() or mpu.is_pipeline_last_stage()\n    ) and mpu.get_tensor_model_parallel_rank() == 0\n\n\ndef core_gpt_dataset_config_from_args(args):\n    tokenizer = get_tokenizer()\n\n    # Sometimes --data-path is too long, instead we parse it from a file.\n    blend: Optional[Tuple[List[str], Optional[List[float]]]]\n    blend_per_split: Optional[List[Optional[Tuple[List[str], Optional[List[float]]]]]]\n    blend, blend_per_split = get_blend_and_blend_per_split(args)\n\n    return GPTDatasetConfig(\n        random_seed=args.seed,\n        sequence_length=args.seq_length,\n        blend=blend,\n        blend_per_split=blend_per_split,\n        renormalize_blend_weights=args.renormalize_blend_weights,\n        split=args.split,\n        num_dataset_builder_threads=args.num_dataset_builder_threads,\n        path_to_cache=args.data_cache_path,\n        mmap_bin_files=args.mmap_bin_files,\n        tokenizer=tokenizer,\n        reset_position_ids=args.reset_position_ids,\n        reset_attention_mask=args.reset_attention_mask,\n        eod_mask_loss=args.eod_mask_loss,\n        create_attention_mask=args.create_attention_mask_in_dataloader,\n        s3_cache_path=args.s3_cache_path,\n    )\n\n\ndef train_valid_test_datasets_provider(train_val_test_num_samples):\n    \"\"\"Build the train test and validation datasets.\n\n    Args:\n        train_val_test_num_samples : A list containing the number of samples in train test and validation.\n    \"\"\"\n    args = get_args()\n\n    config = core_gpt_dataset_config_from_args(args)\n\n    if args.mock_data:\n        dataset_type = MockGPTDataset\n    else:\n        dataset_type = GPTDataset\n\n    print_rank_0(\"> building train, validation, and test datasets for GPT ...\")\n\n    train_ds, valid_ds, test_ds = BlendedMegatronDatasetBuilder(\n        dataset_type,\n        train_val_test_num_samples,\n        is_dataset_built_on_rank,\n        config\n    ).build()\n\n    print_rank_0(\"> finished creating GPT datasets ...\")\n\n    return train_ds, valid_ds, test_ds\n\n\nif __name__ == \"__main__\":\n\n    # Temporary for transition to core datasets\n    train_valid_test_datasets_provider.is_distributed = True\n\n    pretrain(\n        train_valid_test_datasets_provider,\n        model_provider,\n        ModelType.encoder_or_decoder,\n        forward_step,\n        args_defaults={'tokenizer_type': 'GPT2BPETokenizer'},\n    )\n"
        },
        {
          "name": "pretrain_ict.py",
          "type": "blob",
          "size": 5.9248046875,
          "content": "# Copyright (c) 2022, NVIDIA CORPORATION.  All rights reserved.\n\n\"\"\"Pretrain BERT for Inverse Cloze Task\"\"\"\n\nfrom functools import partial\nimport math\n\nimport torch\nimport torch.distributed as dist\nimport torch.nn.functional as F\n\nfrom megatron.training import get_args\nfrom megatron.training import print_rank_0\nfrom megatron.training import get_timers\nfrom megatron.core import mpu\nfrom megatron.core.enums import ModelType\nfrom megatron.legacy.data.biencoder_dataset_utils import get_ict_batch\nfrom megatron.legacy.data.dataset_utils import build_train_valid_test_datasets\nfrom megatron.legacy.model.biencoder_model import biencoder_model_provider\nfrom megatron.training import pretrain\nfrom megatron.training.utils import average_losses_across_data_parallel_group\n\n\ndef pretrain_ict_model_provider(pre_process=True, post_process=True):\n    args = get_args()\n\n    model = biencoder_model_provider(\n                only_context_model=False,\n                only_query_model=False,\n                biencoder_shared_query_context_model=\\\n                args.biencoder_shared_query_context_model,\n                pre_process=pre_process, post_process=post_process)\n\n    return model\n\ndef get_group_world_size_rank():\n\n    group = mpu.get_data_parallel_group()\n    rank = torch.distributed.get_rank(group=group)\n    world_size = torch.distributed.get_world_size(group=group)\n\n    return group, rank, world_size\n\n\nclass AllgatherFromDataParallelRegion(torch.autograd.Function):\n\n    @staticmethod\n    def forward(ctx, input_):\n        assert input_.dim() == 2\n        group, rank, world_size = get_group_world_size_rank()\n\n        tensor_list = [torch.empty_like(input_) for _ in range(world_size)]\n        tensor_list[rank] = input_\n        torch.distributed.all_gather(tensor_list, input_, group=group)\n\n        output = torch.cat(tensor_list, dim=0).contiguous()\n\n        return output\n\n\n    @staticmethod\n    def backward(ctx, grad_output):\n        group, rank, world_size = get_group_world_size_rank()\n\n        assert grad_output.shape[0] % world_size == 0\n        dim_size = grad_output.shape[0] // world_size\n        output_list = torch.split(grad_output, dim_size, dim=0)\n\n        # get chunk from this rank\n        output = output_list[rank].contiguous()\n        return output\n\ndef loss_func(output_tensor):\n    args = get_args()\n    query_logits, context_logits = output_tensor\n\n    micro_batch_size = query_logits.shape[0]\n    # recall we assert that tensor_model_parallel_size == 1\n    assert mpu.get_tensor_model_parallel_world_size() == 1, \\\n        \"Model parallel size > 1 not supported for ICT\"\n\n    global_batch_size = dist.get_world_size() * micro_batch_size\n    all_query_logits = AllgatherFromDataParallelRegion.apply(query_logits)\n    all_context_logits = AllgatherFromDataParallelRegion.apply(context_logits)\n\n    # scores are inner products between query and context embeddings\n    retrieval_scores = torch.matmul(all_query_logits,\n                        torch.transpose(all_context_logits, 0, 1))\n    # scaling the retriever scores\n    if args.retriever_score_scaling:\n        retrieval_scores = retrieval_scores / math.sqrt(args.hidden_size)\n\n    softmax_scores = F.log_softmax(retrieval_scores, dim=1)\n    sorted_vals, sorted_indices = torch.topk(softmax_scores,\n                                    k=softmax_scores.shape[1], sorted=True)\n\n    def topk_accuracy(k):\n        return torch.cuda.FloatTensor([sum([int(i in sorted_indices[i, :k]) \\\n            for i in range(global_batch_size)]) / global_batch_size])\n\n    topk_accs = [topk_accuracy(int(k)) for k in args.retriever_report_topk_accuracies]\n\n    labels = torch.arange(global_batch_size).long().cuda()\n    loss = F.nll_loss(softmax_scores, labels, reduction='mean')\n    reduced_losses = average_losses_across_data_parallel_group([loss, *topk_accs])\n\n    # Scale the retrieval loss\n    loss = loss * mpu.get_data_parallel_world_size()\n\n    # create stats_dict with retrieval loss and all specified top-k accuracies\n    topk_acc_dict = {'top{}_acc'.format(k): v * 100 for k, v in \\\n                        zip(args.retriever_report_topk_accuracies, reduced_losses[1:])}\n    stats_dict = dict(loss=reduced_losses[0], **topk_acc_dict)\n    return loss, stats_dict\n\n\n\ndef forward_step(data_iterator, model):\n    \"\"\"Forward step.\"\"\"\n    args = get_args()\n    timers = get_timers()\n\n    # Get the batch.\n    timers('batch-generator', log_level=2).start()\n    query_tokens, query_mask, \\\n    context_tokens, context_mask, context_indices = get_ict_batch(data_iterator)\n    timers('batch-generator').stop()\n\n    # Query and Context Types\n    query_types = torch.cuda.LongTensor(*query_tokens.shape).fill_(0)\n    context_types = torch.cuda.LongTensor(*context_tokens.shape).fill_(0)\n\n    # Forward model.\n    output_tensor = model(query_tokens, query_mask, query_types, context_tokens,\n                        context_mask, context_types)\n\n    return output_tensor, partial(loss_func)\n\ndef train_valid_test_datasets_provider(train_val_test_num_samples):\n    \"\"\"Build train, valid and test datasets.\"\"\"\n    args = get_args()\n    print_rank_0('> building train, validation, and test datasets '\n                 'for BERT ICT...')\n\n    train_ds, valid_ds, test_ds = build_train_valid_test_datasets(\n        data_prefix=args.data_path,\n        splits_string=args.split,\n        train_valid_test_num_samples=train_val_test_num_samples,\n        max_seq_length=args.seq_length,\n        masked_lm_prob=args.mask_prob,\n        short_seq_prob=args.short_seq_prob,\n        seed=args.seed,\n        binary_head=False,\n        dataset_type='ict')\n    print_rank_0(\"> finished creating BERT ICT datasets ...\")\n\n    return train_ds, valid_ds, test_ds\n\n\nif __name__ == \"__main__\":\n    print_rank_0(\"WARNING : This script is DEPRECATED. Will be removed in mcore release 0.9\")\n    pretrain(train_valid_test_datasets_provider,\n             pretrain_ict_model_provider,\n             ModelType.encoder_or_decoder,\n             forward_step,\n             args_defaults={'tokenizer_type': 'BertWordPieceLowerCase'})\n"
        },
        {
          "name": "pretrain_mamba.py",
          "type": "blob",
          "size": 8.7705078125,
          "content": "# Copyright (c) 2024, NVIDIA CORPORATION.  All rights reserved.\n\"\"\"Pretrain Mamba.\"\"\"\n\nimport os\nimport torch\nfrom functools import partial\nfrom typing import List, Optional, Tuple, Union\n\nfrom megatron.training import get_args\nfrom megatron.training import print_rank_0\nfrom megatron.training import get_timers\nfrom megatron.training import get_tokenizer\nfrom megatron.core import mpu\nfrom megatron.core.enums import ModelType\nfrom megatron.core.datasets.blended_megatron_dataset_builder import BlendedMegatronDatasetBuilder\nfrom megatron.core.datasets.gpt_dataset import GPTDatasetConfig\nfrom megatron.core.datasets.gpt_dataset import MockGPTDataset, GPTDataset\nfrom megatron.core.rerun_state_machine import get_rerun_state_machine\nfrom megatron.core.models.mamba import MambaModel\nfrom megatron.training import pretrain\nfrom megatron.core.utils import StragglerDetector\nfrom megatron.core.transformer.spec_utils import import_module\nfrom megatron.training.utils import (\n    get_batch_on_this_cp_rank,\n    get_batch_on_this_tp_rank,\n    get_blend_and_blend_per_split,\n)\nfrom megatron.training.arguments import core_transformer_config_from_args\nfrom megatron.core.models.gpt.gpt_layer_specs import get_gpt_layer_with_transformer_engine_spec\n\n\nstimer = StragglerDetector()\n\ndef count_parameters_in_layer(model, layer_name):\n    num_params = 0\n    for name, param in model.named_parameters():\n        if layer_name in name:\n            num_params += param.numel()\n            print_rank_0(f\" - {name}: {param.numel()}\")\n    return num_params\n\n\ndef model_provider(pre_process=True, post_process=True) -> MambaModel:\n    \"\"\"Builds the model.\n\n    Args:\n        pre_process (bool, optional): Set to true if you need to compute embedings. Defaults to True.\n        post_process (bool, optional): Set to true if you need to want to compute output logits/loss. Defaults to True.\n\n\n    Returns:\n        MambaModel: The returned model\n    \"\"\"\n    args = get_args()\n\n    print_rank_0('building Mamba model ...')\n    config = core_transformer_config_from_args(get_args())\n\n    assert args.use_legacy_models == False, \"Mamba only supported in Mcore!\"\n\n    if args.spec is not None:\n        mamba_stack_spec = import_module(args.spec)\n    else:\n        raise(\"You must provide a valid Mamba layer spec!\")\n\n    model = MambaModel(\n        config=config,\n        mamba_stack_spec=mamba_stack_spec,\n        vocab_size=args.padded_vocab_size,\n        max_sequence_length=args.max_position_embeddings,\n        pre_process=pre_process,\n        hybrid_attention_ratio=args.hybrid_attention_ratio,\n        hybrid_mlp_ratio=args.hybrid_mlp_ratio,\n        hybrid_override_pattern=args.hybrid_override_pattern,\n        post_process=post_process,\n        fp16_lm_cross_entropy=args.fp16_lm_cross_entropy,\n        parallel_output=True,\n        share_embeddings_and_output_weights=not args.untie_embeddings_and_output_weights,\n        position_embedding_type=args.position_embedding_type,\n        rotary_percent=args.rotary_percent,\n        rotary_base=args.rotary_base\n    )\n\n    for l in range(model.decoder.num_layers_per_pipeline_rank):\n        layer_params = count_parameters_in_layer(model, f'decoder.layers.{l}.')\n        print_rank_0(f\" == params layer {l}: {layer_params}\")\n\n    return model\n\n\ndef get_batch(data_iterator):\n    \"\"\"Generate a batch.\"\"\"\n\n    # TODO: this is pretty hacky, find a better way\n    if (not mpu.is_pipeline_first_stage()) and (not mpu.is_pipeline_last_stage()):\n        return None, None, None, None, None\n\n    # get batches based on the TP rank you are on\n    batch = get_batch_on_this_tp_rank(data_iterator)\n\n    # slice batch along sequence dimension for context parallelism\n    batch = get_batch_on_this_cp_rank(batch)\n\n    return batch.values()\n\n\n# define spiky loss as a variation of 20% or more\nSPIKY_LOSS_PERC = 0.2\n\n\ndef loss_func(loss_mask: torch.Tensor, output_tensor: torch.Tensor):\n    \"\"\"Loss function.\n\n    Args:\n        loss_mask (torch.Tensor): Used to mask out some portions of the loss\n        output_tensor (torch.Tensor): The tensor with the losses\n\n    Returns:\n        the loss scalar for this micro-batch\n        the number of non-padded tokens in this microbatch\n        a dict containing reporting metrics on the loss and number of tokens across\n            the data parallel ranks\n    \"\"\"\n    args = get_args()\n\n    losses = output_tensor.float()\n    loss_mask = loss_mask.view(-1).float()\n    total_tokens = loss_mask.sum()\n    loss = torch.cat([torch.sum(losses.view(-1) * loss_mask).view(1), total_tokens.view(1)])\n\n    if args.context_parallel_size > 1:\n        torch.distributed.all_reduce(loss, group=mpu.get_context_parallel_group())\n\n    # Check individual rank losses are not NaN prior to DP all-reduce.\n    rerun_state_machine = get_rerun_state_machine()\n    if args.check_for_nan_in_loss_and_grad:\n        rerun_state_machine.validate_result(\n            result=loss[0],\n            rejection_func=torch.isnan,\n            message=\"found NaN in local forward loss calculation\",\n            tolerance=0.0,        # forward pass calculations are determinisic\n            fatal=True,\n        )\n    # Check for spiky loss\n    if args.check_for_spiky_loss:\n        rerun_state_machine.validate_result(\n            result=loss[0],\n            rejection_func=partial(rerun_state_machine.is_spiky_loss, threshold=SPIKY_LOSS_PERC),\n            message=\"Spiky loss\",\n            tolerance=0.0,        # forward pass calculations are determinisic\n            fatal=False,\n        )\n\n    # Reduce loss for logging.\n    reporting_loss = loss.clone().detach()\n    torch.distributed.all_reduce(reporting_loss, group=mpu.get_data_parallel_group())\n\n    local_num_tokens = loss[1].clone().detach().to(torch.int)\n    return (\n        loss[0] * args.context_parallel_size,\n        local_num_tokens,\n        {'lm loss': (reporting_loss[0], reporting_loss[1])},\n    )\n\n\ndef forward_step(data_iterator, model: MambaModel):\n    \"\"\"Forward training step.\n\n    Args:\n        data_iterator : Input data iterator\n        model (MambaModel): The GPT Model\n    \"\"\"\n    args = get_args()\n    timers = get_timers()\n\n    # Get the batch.\n    timers('batch-generator', log_level=2).start()\n    global stimer\n    with stimer(bdata=True):\n        tokens, labels, loss_mask, attention_mask, position_ids = get_batch(\n            data_iterator)\n    timers('batch-generator').stop()\n\n    with stimer:\n        output_tensor = model(tokens, position_ids, attention_mask,\n                              labels=labels)\n\n    return output_tensor, partial(loss_func, loss_mask)\n\n\ndef is_dataset_built_on_rank():\n    return (\n        mpu.is_pipeline_first_stage() or mpu.is_pipeline_last_stage()\n    ) and mpu.get_tensor_model_parallel_rank() == 0\n\n\ndef core_gpt_dataset_config_from_args(args):\n    tokenizer = get_tokenizer()\n\n    # Sometimes --data-path is too long, instead we parse it from a file.\n    blend: Optional[Tuple[List[str], Optional[List[float]]]]\n    blend_per_split: Optional[List[Optional[Tuple[List[str], Optional[List[float]]]]]]\n    blend, blend_per_split = get_blend_and_blend_per_split(args)\n\n    return GPTDatasetConfig(\n        random_seed=args.seed,\n        sequence_length=args.seq_length,\n        blend=blend,\n        blend_per_split=blend_per_split,\n        renormalize_blend_weights=args.renormalize_blend_weights,\n        split=args.split,\n        num_dataset_builder_threads=args.num_dataset_builder_threads,\n        path_to_cache=args.data_cache_path,\n        mmap_bin_files=args.mmap_bin_files,\n        tokenizer=tokenizer,\n        reset_position_ids=args.reset_position_ids,\n        reset_attention_mask=args.reset_attention_mask,\n        eod_mask_loss=args.eod_mask_loss,\n        create_attention_mask=args.create_attention_mask_in_dataloader,\n        s3_cache_path=args.s3_cache_path,\n    )\n\n\ndef train_valid_test_datasets_provider(train_val_test_num_samples):\n    \"\"\"Build the train test and validation datasets.\n\n    Args:\n        train_val_test_num_samples : A list containing the number of samples in train test and validation.\n    \"\"\"\n    args = get_args()\n\n    config = core_gpt_dataset_config_from_args(args)\n\n    if args.mock_data:\n        dataset_type = MockGPTDataset\n    else:\n        dataset_type = GPTDataset\n\n    print_rank_0(\"> building train, validation, and test datasets for GPT ...\")\n\n    train_ds, valid_ds, test_ds = BlendedMegatronDatasetBuilder(\n        dataset_type,\n        train_val_test_num_samples,\n        is_dataset_built_on_rank,\n        config\n    ).build()\n\n    print_rank_0(\"> finished creating GPT datasets ...\")\n\n    return train_ds, valid_ds, test_ds\n\n\nif __name__ == \"__main__\":\n\n    # Temporary for transition to core datasets\n    train_valid_test_datasets_provider.is_distributed = True\n\n    pretrain(train_valid_test_datasets_provider,\n             model_provider,\n             ModelType.encoder_or_decoder,\n             forward_step,\n             args_defaults={'tokenizer_type': 'GPT2BPETokenizer'})\n"
        },
        {
          "name": "pretrain_retro.py",
          "type": "blob",
          "size": 8.1533203125,
          "content": "# Copyright (c) 2024, NVIDIA CORPORATION.  All rights reserved.\n\n\"\"\"Pretrain Retro.\"\"\"\n\nfrom functools import partial\nimport torch\n\nfrom megatron.training import get_args\nfrom megatron.training import get_timers\nfrom megatron.training import get_tokenizer\nfrom megatron.training import print_rank_0\nfrom megatron.training.arguments import core_transformer_config_from_args\nfrom megatron.core import tensor_parallel\nfrom megatron.core.datasets.blended_megatron_dataset_builder import BlendedMegatronDatasetBuilder\nfrom megatron.core.datasets.utils import get_blend_from_list\nfrom megatron.core.datasets.retro.query.retro_dataset import get_retro_datasets\nfrom megatron.core.datasets.retro.query.multi_split_gpt_dataset import MultiSplitGPTDataset, MultiSplitGPTDatasetConfig\nfrom megatron.core.enums import ModelType\nfrom megatron.core.models.retro import get_retro_decoder_block_spec, RetroConfig, RetroModel\nfrom megatron.core.models.retro.utils import get_all_true_mask\nfrom megatron.training import pretrain\nfrom megatron.training.utils import get_ltor_masks_and_position_ids\nfrom pretrain_gpt import (\n    is_dataset_built_on_rank,\n    loss_func,\n    model_provider as default_model_provider,\n    train_valid_test_datasets_provider as gpt_train_valid_test_datasets_provider,\n)\n\n\ndef get_retro_config():\n    return core_transformer_config_from_args(get_args(), RetroConfig)\n\n\ndef core_model_provider(pre_process=True, post_process=True):\n    \"\"\"Build the model using Megatron-Core.\"\"\"\n\n    args = get_args()\n    config = get_retro_config()\n\n    # NOTE: Experimental customization feature\n    if args.spec is not None:\n        block_spec = import_module(args.spec)()\n    else:\n        block_spec = get_retro_decoder_block_spec(config, use_transformer_engine=True)\n\n    print_rank_0('building GPT model ...')\n    model = RetroModel(\n        config=config,\n        transformer_layer_spec=block_spec,\n        vocab_size=args.padded_vocab_size,\n        max_sequence_length=args.max_position_embeddings,\n        pre_process=pre_process,\n        post_process=post_process,\n        fp16_lm_cross_entropy=args.fp16_lm_cross_entropy,\n        parallel_output=True,\n        share_embeddings_and_output_weights=not args.untie_embeddings_and_output_weights,\n        position_embedding_type=args.position_embedding_type,\n        rotary_percent=args.rotary_percent\n    )\n    return model\n\n\ndef model_provider(pre_process=True, post_process=True):\n    \"\"\"Build the model.\n\n    Select between two different model classes:\n      1. Default model (uses megatron.legacy.models/gpt_model.py).\n      2. Core model (uses megatron/core/models/retro/model.py).\n    \"\"\"\n\n    args = get_args()\n    if not args.use_legacy_models and args.retro_add_retriever:\n        provider = core_model_provider\n    else:\n        provider = default_model_provider\n    model = provider(pre_process=pre_process, post_process=post_process)\n    return model\n\n\ndef get_batch(data_iterator):\n    \"\"\"Generate a batch\"\"\"\n\n    args = get_args()\n    tokenizer = get_tokenizer()\n    config = get_retro_config()\n\n    # Items and their type.\n    keys = ['text']\n    if args.retro_add_retriever:\n        keys.append('neighbor_tokens')\n    datatype = torch.int64\n\n    # Broadcast data.\n    if data_iterator is not None:\n        data = next(data_iterator)\n    else:\n        data = None\n\n    data_b = tensor_parallel.broadcast_data(keys, data, datatype)\n\n    # Unpack.\n    tokens_ = data_b['text'].long()\n    labels = tokens_[:, 1:].contiguous()\n    tokens = tokens_[:, :-1].contiguous()\n\n    # Get the masks and postition ids.\n    attention_mask, loss_mask, position_ids = get_ltor_masks_and_position_ids(\n        tokens,\n        tokenizer.eod,\n        args.reset_position_ids,\n        args.reset_attention_mask,\n        args.eod_mask_loss)\n\n    if args.retro_add_retriever:\n        # note: [bs * l * k, r]\n        # note: 2x == neighbor, continuation\n        neighbor_tokens = data_b['neighbor_tokens'] \\\n            .view(-1, config.retro_retrieved_length).long()\n        _, _, neighbor_position_ids = get_ltor_masks_and_position_ids(\n            neighbor_tokens,\n            tokenizer.eod,\n            args.reset_position_ids,\n            args.reset_attention_mask,\n            args.eod_mask_loss)\n        neighbor_attention_mask = get_all_true_mask(\n            (1, 1, config.retro_retrieved_length, config.retro_retrieved_length),\n            neighbor_tokens.device)\n        return tokens, labels, loss_mask, attention_mask, position_ids, \\\n               neighbor_tokens, neighbor_attention_mask, neighbor_position_ids\n\n    else:\n        return tokens, labels, loss_mask, attention_mask, position_ids\n\n\ndef forward_step(data_iterator, model):\n    \"\"\"Forward step.\"\"\"\n    args = get_args()\n    timers = get_timers()\n\n    # Get the batch.\n    timers('batch-generator').start()\n    if args.retro_add_retriever:\n        tokens, labels, loss_mask, attention_mask, position_ids, \\\n            neighbor_tokens, neighbor_attention_mask, neighbor_position_ids = \\\n                get_batch(data_iterator)\n    else:\n        tokens, labels, loss_mask, attention_mask, position_ids = get_batch(\n            data_iterator)\n        neighbor_tokens, neighbor_attention_mask, neighbor_position_ids = \\\n            None, None, None\n    timers('batch-generator').stop()\n\n    # Model call.\n    if args.use_legacy_models:\n        forward_kwargs = {\n            \"retriever_input_ids\" : neighbor_tokens,\n            \"retriever_position_ids\" : neighbor_position_ids,\n            \"retriever_attn_mask\" : neighbor_attention_mask,\n        }\n    else:\n        if args.retro_add_retriever:\n            forward_kwargs = {\n                \"context_input_ids\" : neighbor_tokens,\n                \"context_position_ids\" : neighbor_position_ids,\n                \"context_mask\" : neighbor_attention_mask,\n            }\n        else:\n            forward_kwargs = {}\n \n    output_tensor = model(tokens, position_ids, attention_mask,\n                          labels=labels, **forward_kwargs)\n\n    return output_tensor, partial(loss_func, loss_mask)\n\n\ndef train_valid_test_datasets_provider(train_valid_test_num_samples):\n    \"\"\"Build train, valid, and test datasets.\"\"\"\n    args = get_args()\n\n    # Dataset config.\n    retro_config = get_retro_config()\n    data_config = MultiSplitGPTDatasetConfig(\n        random_seed=args.seed,\n        sequence_length=args.seq_length,\n        blend=get_blend_from_list(args.data_path),\n        blend_per_split=[\n            get_blend_from_list(args.train_data_path),\n            get_blend_from_list(args.valid_data_path),\n            get_blend_from_list(args.test_data_path)\n        ],\n        renormalize_blend_weights=args.renormalize_blend_weights,\n        split=args.split,\n        split_preprocessing=retro_config.retro_split_preprocessing,\n        path_to_cache=args.data_cache_path,\n        return_document_ids=False,\n        tokenizer=get_tokenizer(),\n        reset_position_ids=args.reset_position_ids,\n        reset_attention_mask=args.reset_attention_mask,\n        eod_mask_loss=args.eod_mask_loss,\n    )\n\n    # GPT datasets.\n    print_rank_0(\" > multi-split gpt datasets.\")\n    train_ds, valid_ds, test_ds = BlendedMegatronDatasetBuilder(\n        MultiSplitGPTDataset,\n        train_valid_test_num_samples,\n        is_dataset_built_on_rank,\n        data_config,\n    ).build()\n\n    gpt_datasets = {\n        \"train\" : (train_ds, train_valid_test_num_samples[0]),\n        \"valid\" : (valid_ds, train_valid_test_num_samples[1]),\n        \"test\"  : (test_ds, train_valid_test_num_samples[2]),\n    }\n\n    # Retro datasets.\n    if args.retro_add_retriever:\n        return get_retro_datasets(\n            config=retro_config,\n            gpt_datasets=gpt_datasets,\n            sample_length=args.seq_length,\n            eod_token_id=get_tokenizer().eod,\n        )\n\n    # Multi-split GPT datasets.\n    else:\n        return (\n            gpt_datasets[\"train\"][0],\n            gpt_datasets[\"valid\"][0],\n            gpt_datasets[\"test\"][0],\n        )\n\n\nif __name__ == \"__main__\":\n\n    # Temporary for transition to core datasets.\n    train_valid_test_datasets_provider.is_distributed = True\n\n    pretrain(train_valid_test_datasets_provider,\n             model_provider,\n             ModelType.retro_decoder,\n             forward_step,\n             args_defaults={'tokenizer_type': 'GPT2BPETokenizer'})\n"
        },
        {
          "name": "pretrain_t5.py",
          "type": "blob",
          "size": 10.8818359375,
          "content": "# Copyright (c) 2022, NVIDIA CORPORATION.  All rights reserved.\n\n\"\"\"Pretrain T5\"\"\"\n\nfrom copy import deepcopy\nfrom functools import partial\nfrom typing import Union\n\nimport torch\n\nimport megatron\nfrom megatron.core import mpu, tensor_parallel\nfrom megatron.core.datasets.blended_megatron_dataset_builder import BlendedMegatronDatasetBuilder\nfrom megatron.core.datasets.t5_dataset import (\n    T5MaskedWordPieceDataset,\n    T5MaskedWordPieceDatasetConfig,\n)\nfrom megatron.core.datasets.utils import get_blend_from_list\nfrom megatron.core.enums import ModelType\nfrom megatron.core.models.T5 import T5Model\nfrom megatron.core.models.T5.t5_spec import (\n    get_t5_decoder_with_local_block_spec,\n    get_t5_decoder_with_transformer_engine_block_spec,\n    get_t5_encoder_with_local_block_spec,\n    get_t5_encoder_with_transformer_engine_block_spec,\n)\nfrom megatron.training import get_args, get_timers, get_tokenizer, pretrain, print_rank_0\nfrom megatron.training.arguments import core_transformer_config_from_args\nfrom pretrain_gpt import loss_func\n\n\"\"\"\nPipeline parallelism for T5\n\nT5 is a model architecture with both encoder and decoder blocks.\nConsequently, pipeline parallelism is implemented slightly differently\ncompared to architectures like GPT and BERT.\n\nIn particular, when pipeline_model_parallel_world_size > 1, each stage\neither executes an encoder block or a decoder block. The\n--pipeline-model-parallel-split-rank argument controls the rank at which\nthe split happens: all ranks lower than this argument execute the\nencoder block, and all ranks equal to or higher than this argument value\nexecute the decoder block.\n\nIn the encoder section of the model, only one tensor is sent downstream:\nthe intermediate encoder_hidden_state. In the decoder section of the\nmodel, two tensors are sent downstream in the forward pass: the fully\ncomputed encoder_hidden_state, and the intermediate decoder_hidden_state.\n\nIn particular, these are the shapes of the tensors sent between\ndifferent workers:\n    If rank is in decoder section:\n        intermediate decoder_hidden_state (pre-transpose),\n        complete encoder_hidden_state (post-transpose).\n    If rank is at boundary between encoder and decoder sections:\n        complete encoder_hidden_state (post-transpose).\n    If rank is in encoder section:\n        intermediate encoder_hidden_state (pre-transpose).\n\nAdditionally, we have code in the backward_step function in schedules.py\nto accumulate the encoder_hidden_state gradient across skip connections\n(encoder_hidden_state fed in as input to each layer in the decoder).\n\"\"\"\n\n\ndef model_provider(\n    pre_process=True, post_process=True, add_encoder=True, add_decoder=True\n) -> Union[megatron.legacy.model.T5Model, T5Model]:\n    \"\"\"Builds the model.\n\n    Args:\n        pre_process (bool, optional): Set to true if you need to\n            compute embedings. Defaults to True.\n        post_process (bool, optional): Set to true if you need to want to\n            compute output logits/loss. Defaults to True.\n        add_encoder (bool, optional): Defaults to True\n        add_decoder (bool, optional): Defaults to True\n    Returns:\n        T5Model: The returned T5 model\n    \"\"\"\n\n    args = get_args()\n\n    assert (\n        args.encoder_tensor_model_parallel_size == 0\n        or args.encoder_tensor_model_parallel_size == args.tensor_model_parallel_size\n    ), f\"Because word embeddings are shared between the encoder & decoder, these \\\n        have to have the same tensor parallel size.\"\n\n    config = core_transformer_config_from_args(args)\n    if args.use_legacy_models:\n        model = megatron.legacy.model.T5Model(\n            config=config,\n            num_tokentypes=0,\n            parallel_output=True,\n            pre_process=pre_process,\n            post_process=post_process,\n            add_encoder=add_encoder,\n            add_decoder=add_decoder,\n        )\n    else:\n        encoder_config = deepcopy(config)\n        encoder_config.num_layers = args.encoder_num_layers\n\n        if args.pipeline_model_parallel_size > 1:\n            assert (\n                args.encoder_pipeline_model_parallel_size > 0\n            ), \"Need to know how to shard the encoder & decoder.\"\n\n        if args.encoder_pipeline_model_parallel_size > 0:\n            encoder_config.pipeline_model_parallel_size = args.encoder_pipeline_model_parallel_size\n\n        encoder_layers_per_pipeline = (\n            encoder_config.num_layers // encoder_config.pipeline_model_parallel_size\n        )\n        decoder_layers_per_pipeline = config.num_layers // config.pipeline_model_parallel_size\n\n        if args.transformer_impl == \"local\":\n            en_block_spec = get_t5_encoder_with_local_block_spec(encoder_layers_per_pipeline)\n            de_block_spec = get_t5_decoder_with_local_block_spec(decoder_layers_per_pipeline)\n        elif args.transformer_impl == \"transformer_engine\":\n            en_block_spec = get_t5_encoder_with_transformer_engine_block_spec(\n                encoder_layers_per_pipeline\n            )\n            de_block_spec = get_t5_decoder_with_transformer_engine_block_spec(\n                decoder_layers_per_pipeline\n            )\n\n        print_rank_0('building T5 model ...')\n        model = T5Model(\n            config=config,\n            encoder_config=encoder_config,\n            transformer_encoder_layer_spec=en_block_spec,\n            transformer_decoder_layer_spec=de_block_spec,\n            vocab_size=args.padded_vocab_size,\n            max_sequence_length=args.max_position_embeddings,\n            pre_process=pre_process,\n            post_process=post_process,\n            fp16_lm_cross_entropy=args.fp16_lm_cross_entropy,\n            parallel_output=True,\n            share_embeddings_and_output_weights=not args.untie_embeddings_and_output_weights,\n            position_embedding_type=args.position_embedding_type,\n            rotary_percent=args.rotary_percent,\n            relative_attention_num_buckets=args.relative_attention_num_buckets,\n            relative_attention_max_distance=args.relative_attention_max_distance,\n            add_encoder=add_encoder,\n            add_decoder=add_decoder,\n        )\n\n    return model\n\n\ndef get_batch(data_iterator, use_local):\n    \"\"\"Build the batch.\"\"\"\n\n    keys = ['text_enc', 'text_dec', 'labels', 'loss_mask', 'enc_mask', 'dec_mask']\n    datatype = torch.int64\n\n    # Broadcast data.\n    if data_iterator is not None:\n        data = next(data_iterator)\n    else:\n        data = None\n    data_b = tensor_parallel.broadcast_data(keys, data, datatype)\n\n    # Unpack.\n    tokens_enc = data_b['text_enc'].long()\n    tokens_dec = data_b['text_dec'].long()\n    labels = data_b['labels'].long()\n    loss_mask = data_b['loss_mask'].float()\n    enc_mask = data_b['enc_mask'] < 0.5\n    dec_mask = data_b['dec_mask'] < 0.5\n\n    # Configure attention mask based on different conditions\n    # (e.g., transformer-impl, TE versions, TE backends)\n    enc_mask, dec_mask, enc_dec_mask = T5MaskedWordPieceDataset.config_attention_mask(\n        tokens_enc, tokens_dec, enc_mask, dec_mask, use_local\n    )\n\n    return tokens_enc, tokens_dec, loss_mask, labels, enc_mask, dec_mask, enc_dec_mask\n\n\ndef forward_step(data_iterator, model: T5Model):\n    \"\"\"Forward training step.\n\n    Args:\n        data_iterator : Input data iterator\n        model (T5Model): The T5 Model\n    \"\"\"\n\n    args = get_args()\n    timers = get_timers()\n\n    # Get the batch.\n    timers('batch generator', log_level=2).start()\n    use_local = args.transformer_impl == \"local\"\n    tokens_enc, tokens_dec, loss_mask, lm_labels, enc_mask, dec_mask, enc_dec_mask = get_batch(\n        data_iterator, use_local\n    )\n    timers('batch generator').stop()\n\n    # Forward model lm_labels\n    output_tensor = model(\n        tokens_enc, tokens_dec, enc_mask, dec_mask, enc_dec_mask, lm_labels=lm_labels\n    )\n\n    return output_tensor, partial(loss_func, loss_mask)\n\n\ndef train_valid_test_datasets_provider(train_val_test_num_samples: int):\n    \"\"\"Build the train test and validation datasets.\n\n    Args:\n        train_val_test_num_samples : A list containing the number of samples\n            in train test and validation.\n    \"\"\"\n    args = get_args()\n\n    tokenizer = get_tokenizer()\n\n    config = T5MaskedWordPieceDatasetConfig(\n        random_seed=args.seed,\n        sequence_length=args.encoder_seq_length,\n        sequence_length_decoder=args.decoder_seq_length,\n        blend=get_blend_from_list(args.data_path),\n        blend_per_split=[\n            get_blend_from_list(args.train_data_path),\n            get_blend_from_list(args.valid_data_path),\n            get_blend_from_list(args.test_data_path),\n        ],\n        renormalize_blend_weights=args.renormalize_blend_weights,\n        split=args.split,\n        path_to_cache=args.data_cache_path,\n        tokenizer=tokenizer,\n        masking_probability=args.mask_prob,\n        short_sequence_probability=args.short_seq_prob,\n        masking_max_ngram=10,\n        masking_do_full_word=True,\n        masking_do_permutation=False,\n        masking_use_longer_ngrams=False,\n        masking_use_geometric_distribution=True,\n    )\n\n    print_rank_0('> building train, validation, and test datasets for T5 ...')\n\n    train_ds, valid_ds, test_ds = BlendedMegatronDatasetBuilder(\n        T5MaskedWordPieceDataset,\n        train_val_test_num_samples,\n        lambda: mpu.get_tensor_model_parallel_rank() == 0,\n        config,\n    ).build()\n\n    print_rank_0(\"> finished creating T5 datasets ...\")\n\n    return train_ds, valid_ds, test_ds\n\n\ndef t5_embedding_ranks(pp_ranks):\n    \"\"\"T5's embedding ranks consist of the encoder's first rank, and\n        the decoder's first & last ranks.\n    Args:\n        pp_ranks: A list of global ranks that constitute a pipeline group.\n    \"\"\"\n    args = get_args()\n\n    first_rank = pp_ranks[0]\n    last_rank = pp_ranks[-1]\n\n    # encoder size is also the index to the first rank of the decoder.\n    epp = args.encoder_pipeline_model_parallel_size\n\n    if len(pp_ranks) == 1:\n        return [first_rank]\n    elif pp_ranks[epp] not in (first_rank, last_rank):\n        return [first_rank, pp_ranks[epp], last_rank]\n    else:\n        return [first_rank, last_rank]\n\n\ndef t5_position_embedding_ranks(pp_ranks):\n    \"\"\"T5's positional embeddings are the encoder & decoder first rank stages\n    Args:\n        pp_ranks: A list of global ranks that constitute a pipeline group.\n    \"\"\"\n    args = get_args()\n\n    # encoder size is also the index to the first rank of the decoder.\n    epp = args.encoder_pipeline_model_parallel_size\n\n    if len(pp_ranks) == 1 or pp_ranks[0] == pp_ranks[epp]:\n        return [pp_ranks[0]]\n    else:\n        return [pp_ranks[0], pp_ranks[epp]]\n\n\nif __name__ == \"__main__\":\n\n    # Temporary for transition to core datasets\n    train_valid_test_datasets_provider.is_distributed = True\n\n    pretrain(\n        train_valid_test_datasets_provider,\n        model_provider,\n        ModelType.encoder_and_decoder,\n        forward_step,\n        args_defaults={'tokenizer_type': 'BertWordPieceLowerCase'},\n        get_embedding_ranks=t5_embedding_ranks,\n        get_position_embedding_ranks=t5_position_embedding_ranks,\n    )\n"
        },
        {
          "name": "pretrain_vision_classify.py",
          "type": "blob",
          "size": 3.3095703125,
          "content": "# Copyright (c) 2022, NVIDIA CORPORATION.  All rights reserved.\n\n\"\"\"Pretrain VIT\"\"\"\n\nimport torch\nimport torch.nn.functional as F\nfrom functools import partial\nfrom megatron.training import get_args, get_timers, print_rank_0\nfrom megatron.core.enums import ModelType\nfrom megatron.legacy.data.vit_dataset import build_train_valid_datasets\nfrom megatron.legacy.model.vision.classification import VitClassificationModel\nfrom megatron.legacy.model.vision.classification import MitClassificationModel\nfrom megatron.training import pretrain\nfrom megatron.training.utils import average_losses_across_data_parallel_group\nfrom megatron.training.arguments import core_transformer_config_from_args\n\n\ndef model_provider(pre_process=True, post_process=True):\n    \"\"\"Build the model.\"\"\"\n\n    args = get_args()\n    config = core_transformer_config_from_args(args)\n    if args.vision_backbone_type == 'vit':\n        print_rank_0(\"building VIT model ...\")\n        model = VitClassificationModel(config=config,\n                                       num_classes=args.num_classes,\n                                       pre_process=pre_process,\n                                       post_process=post_process)\n    elif args.vision_backbone_type == 'mit':\n        print_rank_0(\"building MIT model ...\")\n        model = MitClassificationModel(num_classes=args.num_classes,\n                                       pre_process=pre_process,\n                                       post_process=post_process)\n    else:\n        raise Exception('{} vision backbone is not supported.'.format(\n                              args.vision_backbone_type))\n    return model\n\n\ndef get_batch(data_iterator):\n    \"\"\"Build the batch.\"\"\"\n    data = next(data_iterator)\n\n    # only data parallelism; no need for broadcast\n    images = data[0].cuda()\n    labels = data[1].cuda()\n\n    return images, labels\n\n\ndef loss_func(labels, output_tensor):\n    logits = output_tensor.contiguous().float()\n    loss = F.cross_entropy(logits, labels)\n\n    outputs = torch.argmax(logits, -1)\n    correct = (outputs == labels).float()\n    accuracy = torch.mean(correct)\n\n    averaged_loss = average_losses_across_data_parallel_group([loss, accuracy])\n\n    return loss, {\"loss\": averaged_loss[0], \"accuracy\": averaged_loss[1]}\n\n\ndef forward_step(data_iterator, model):\n    \"\"\"Forward step.\"\"\"\n    timers = get_timers()\n\n    # Get the batch.\n    timers(\"batch-generator\", log_level=2).start()\n    (\n        images,\n        labels,\n    ) = get_batch(data_iterator)\n    timers(\"batch-generator\").stop()\n\n    # Forward model. lm_labels\n    output_tensor = model(images)\n\n    return output_tensor, partial(loss_func, labels)\n\ndef train_valid_test_datasets_provider(train_val_test_num_samples):\n    \"\"\"Build train, valid, and test datasets.\"\"\"\n    args = get_args()\n\n    print_rank_0(\n        \"> building train, validation, and test datasets \" \"for VIT ...\"\n    )\n    train_ds, valid_ds = build_train_valid_datasets(\n        data_path=args.data_path,\n        image_size=(args.img_h, args.img_w)\n    )\n    print_rank_0(\"> finished creating VIT datasets ...\")\n\n    return train_ds, valid_ds, None\n\n\nif __name__ == \"__main__\":\n\n    pretrain(\n        train_valid_test_datasets_provider,\n        model_provider,\n        ModelType.encoder_or_decoder,\n        forward_step,\n        args_defaults={'dataloader_type': 'cyclic', 'vision_pretraining': True}\n    )\n"
        },
        {
          "name": "pretrain_vision_dino.py",
          "type": "blob",
          "size": 3.447265625,
          "content": "# Copyright (c) 2022, NVIDIA CORPORATION.  All rights reserved.\n\nimport torch\nimport torch.nn.functional as F\nimport torch.nn as nn\nimport numpy as np\nimport torch.distributed as dist\nfrom functools import partial\nfrom megatron.training import get_args, get_timers, print_rank_0\nfrom megatron.core.enums import ModelType\nfrom megatron.legacy.data.vit_dataset import build_train_valid_datasets\nfrom megatron.legacy.model.vision.dino import DINOPretrainModel\nfrom megatron.legacy.model.vision.knn_monitor import knn_predict, get_feature_bank\nfrom megatron.training import pretrain\nfrom megatron.training.utils import average_losses_across_data_parallel_group, unwrap_model\nfrom megatron.training.arguments import core_transformer_config_from_args\n\ndef model_provider(pre_process=True, post_process=True):\n    \"\"\"Build the model.\"\"\"\n    config = core_transformer_config_from_args(get_args())\n    return DINOPretrainModel(config, pre_process=pre_process, post_process=post_process)\n\ndef get_batch(data_iterator):\n    \"\"\"Build the batch.\"\"\"\n    data = next(data_iterator)\n\n    # only data parallelism; no need for broadcast\n    if isinstance(data[0], list):\n        images = [aug.cuda() for aug in data[0]]\n    else:\n        images = data[0].cuda()\n    labels = data[1].cuda()\n\n    return images, labels\n\n\ndef loss_func(model, labels, output_tensor, collect_data=False):\n    args = get_args()\n\n    model = unwrap_model(model)\n    if model.training:\n        student_output, teacher_output = output_tensor\n        loss = model.dino_loss(student_output, teacher_output, args.curr_iteration)\n        averaged_loss = average_losses_across_data_parallel_group([loss])\n        return loss, {\"loss\": averaged_loss[0]}\n    else:\n        _, teacher_feature = output_tensor\n        feature_bank, feature_labels, classes = get_feature_bank()\n        feature = F.normalize(teacher_feature.float(), dim=1)\n\n        knn_accs = []\n        for k in [10, 20, 100, 200]:\n            pred_labels = knn_predict(feature, feature_bank,\n                                      feature_labels, classes, k, 0.07)\n            knn_acc = (pred_labels[:, 0] == labels).float().mean()\n            knn_accs.append(knn_acc)\n\n        averaged_loss = average_losses_across_data_parallel_group(knn_accs)\n        return 0, {\"knn_acc_10\": averaged_loss[0],\n                   \"knn_acc_20\": averaged_loss[1],\n                   \"knn_acc_100\": averaged_loss[2],\n                   \"knn_acc_200\": averaged_loss[3]}\n\n\ndef forward_step(data_iterator, model):\n    \"\"\"Forward step.\"\"\"\n    timers = get_timers()\n\n    # Get the batch.\n    timers(\"batch-generator\", log_level=2).start()\n    (\n        images,\n        labels,\n    ) = get_batch(data_iterator)\n    timers(\"batch-generator\").stop()\n\n    return model(images), partial(loss_func, model, labels)\n\n\ndef train_valid_test_datasets_provider(train_val_test_num_samples):\n    \"\"\"Build train, valid, and test datasets.\"\"\"\n    args = get_args()\n\n    print_rank_0(\n        \"> building train, validation, and test datasets \" \"for VIT ...\"\n    )\n    train_ds, valid_ds = build_train_valid_datasets(\n        data_path=args.data_path,\n        image_size=(args.img_h, args.img_w)\n    )\n    print_rank_0(\"> finished creating VIT datasets ...\")\n\n    return train_ds, valid_ds, None\n\n\nif __name__ == \"__main__\":\n\n    pretrain(\n        train_valid_test_datasets_provider,\n        model_provider,\n        ModelType.encoder_or_decoder,\n        forward_step,\n        args_defaults={'dataloader_type': 'cyclic', 'vision_pretraining': True}\n    )\n\n"
        },
        {
          "name": "pretrain_vision_inpaint.py",
          "type": "blob",
          "size": 4.720703125,
          "content": "# Copyright (c) 2022, NVIDIA CORPORATION.  All rights reserved.\n\n\"\"\"Pretrain VIT\"\"\"\n\nimport torch\nimport torch.nn.functional as F\nfrom functools import partial\nfrom megatron.training import get_args, get_timers, print_rank_0, print_rank_last\nfrom megatron.core.enums import ModelType\nfrom megatron.legacy.data.vit_dataset import build_train_valid_datasets\nfrom megatron.legacy.model.vision.inpainting import VitInpaintingModel\nfrom megatron.legacy.model.vision.inpainting import MitInpaintingModel\nfrom megatron.training import pretrain\nfrom megatron.training.utils import average_losses_across_data_parallel_group\nfrom tasks.vision.segmentation.metrics import SSIM, PSNR\nfrom megatron.training.arguments import core_transformer_config_from_args\n\ndef model_provider(pre_process=True, post_process=True):\n    \"\"\"Build the model.\"\"\"\n    args = get_args()\n    config = core_transformer_config_from_args(args)\n    if args.vision_backbone_type == 'vit':\n        model = VitInpaintingModel(config=config,\n                                   pre_process=pre_process,\n                                   post_process=post_process)\n    elif args.vision_backbone_type == 'mit':\n        model = MitInpaintingModel(config=config,\n                                   pre_process=pre_process,\n                                   post_process=post_process)\n    else:\n        raise Exception('{} vision backbone is not supported.'.format(\n                              args.vision_backbone_type))\n    return model\n\n\ndef get_batch(data_iterator):\n    \"\"\"Build the batch.\"\"\"\n    data = next(data_iterator)\n\n    # only data parallelism; no need for broadcast\n    images = data[0][0].cuda()\n    masks = data[0][1].cuda()\n    return images, masks\n\n\ndef loss_func(images, masks, masked_images, outputs, non_loss_data=False):\n    outputs = outputs.contiguous().float()\n    masks_flip = 1-masks\n    flip_masked_outputs = outputs.masked_fill(masks_flip.bool(), 0)\n    flip_masked_images = images.masked_fill(masks_flip.bool(), 0)\n\n    ssim_fun = SSIM()\n    psnr_fun = PSNR()\n\n    if not non_loss_data:\n        mask_count = torch.count_nonzero(masks)\n        loss = F.mse_loss(\n            flip_masked_outputs,\n            flip_masked_images.float(),\n            reduction=\"sum\"\n        )\n        loss = loss/mask_count\n        ssim = ssim_fun(flip_masked_outputs, flip_masked_images.float())\n        psnr = psnr_fun(flip_masked_outputs, flip_masked_images.float())\n\n        averaged_loss = average_losses_across_data_parallel_group(\n            [loss, psnr, ssim]\n        )\n\n        return loss, {\"loss\": averaged_loss[0],\n                      \"psnr\": averaged_loss[1],\n                      'ssim': averaged_loss[2]}\n    else:\n        synth_images = masked_images.float() + flip_masked_outputs\n        ssim = ssim_fun(synth_images, images.float())\n        psnr = psnr_fun(synth_images, images.float())\n        return torch.cat((images, masked_images, synth_images), dim=2), ssim, psnr\n\n\ndef forward_step(data_iterator, model):\n    \"\"\"Forward step.\"\"\"\n    timers = get_timers()\n\n    # Get the batch.\n    timers(\"batch-generator\", log_level=2).start()\n    (\n        images,\n        masks,\n    ) = get_batch(data_iterator)\n    timers(\"batch-generator\").stop()\n\n    masked_images = images.masked_fill(masks.bool(), 0)\n    outputs = model(masked_images)\n\n    # Forward mode\n    return outputs, partial(loss_func, images, masks, masked_images)\n\n\ndef process_non_loss_data(data, iteration, writer):\n    psnr_sum = 0\n    ssim_sum = 0\n    for (output_tb, ssim, psnr) in data:\n        output_tb[output_tb < 0] = 0\n        output_tb[output_tb > 1] = 1\n        writer.add_images(\"gt-input-output-vald\", output_tb,\n                          global_step=iteration, walltime=None,\n                          dataformats='NCHW')\n        psnr_sum = psnr_sum + psnr.item()\n        ssim_sum = ssim_sum + ssim.item()\n    psnr = psnr_sum/len(data)\n    ssim = ssim_sum/len(data)\n    writer.add_scalar('PSNR generate value-validation', psnr, iteration)\n    writer.add_scalar('SSIM generate value-validation', ssim, iteration)\n\n\ndef train_valid_test_datasets_provider(train_val_test_num_samples):\n    \"\"\"Build train, valid, and test datasets.\"\"\"\n    args = get_args()\n\n    print_rank_0(\n        \"> building train, validation, and test datasets \" \"for VIT ...\"\n    )\n    train_ds, valid_ds = build_train_valid_datasets(\n        data_path=args.data_path,\n        image_size=(args.img_h, args.img_w)\n    )\n    print_rank_0(\"> finished creating VIT datasets ...\")\n\n    return train_ds, valid_ds, None\n\n\nif __name__ == \"__main__\":\n\n    pretrain(\n        train_valid_test_datasets_provider,\n        model_provider,\n        ModelType.encoder_or_decoder,\n        forward_step,\n        process_non_loss_data,\n        args_defaults={'dataloader_type': 'cyclic', 'vision_pretraining': True}\n    )\n"
        },
        {
          "name": "pretrain_vlm.py",
          "type": "blob",
          "size": 20.5126953125,
          "content": "# Copyright (c) 2024, NVIDIA CORPORATION.  All rights reserved.\n\"\"\"Pretrain vision language model.\"\"\"\nfrom copy import deepcopy\nfrom functools import partial\nimport warnings\n\nimport torch\n\nfrom megatron.core import parallel_state, tensor_parallel\nfrom megatron.core.datasets.blended_megatron_dataset_builder import BlendedMegatronDatasetBuilder\nfrom megatron.core.datasets.multimodal_dataset import MockMultimodalDataset, MultimodalDatasetConfig\nfrom megatron.core.enums import ModelType\nfrom megatron.core.models.vision.clip_vit_model import get_num_image_embeddings\nfrom megatron.core.transformer.enums import AttnMaskType\nfrom megatron.core.models.multimodal.llava_model import LLaVAModel, DEFAULT_IMAGE_TOKEN_INDEX\nfrom megatron.core.models.multimodal.llava_spec import (\n    decoder_model_with_transformer_engine_default_spec,\n    decoder_model_with_local_default_spec,\n)\nfrom megatron.core.models.vision.vit_layer_specs import (\n    get_vit_layer_with_transformer_engine_spec,\n    get_vit_layer_with_local_spec,\n)\nfrom megatron.core.transformer.spec_utils import import_module\nfrom megatron.core.packed_seq_params import PackedSeqParams\nfrom megatron.training import get_args, get_timers, get_tokenizer, pretrain, print_rank_0\nfrom megatron.training.arguments import core_transformer_config_from_args\nfrom megatron.training.utils import get_batch_on_this_cp_rank\nfrom megatron.core import mpu\nfrom pretrain_gpt import loss_func\n\ndef calculate_model_parallel_padding(decoder_seq_len, text_only=False):\n    args = get_args()\n    cp_size = args.context_parallel_size\n    tp_size = args.tensor_model_parallel_size\n\n    mp_padding_needed = 0\n    # TP Comm overlap is performed with combined text+image embeddings.\n    # text_only flag skips using the full sequence length to calculate padding and uses\n    # the provided decoder_seq_len\n    if args.sequence_parallel and args.decoder_tp_comm_overlap and not text_only:\n        # If TP Comm Overlap is enabled for combined text+image embedding in LM backbone,\n        # user needs to provide decoder_seq_length with any potential padding needed for SP+CP\n        assert args.decoder_seq_length is not None, \\\n            \"Please provide --decoder-seq-length when using TP Comm overlap for LM backbone\"\n        mp_padding_needed = args.decoder_seq_length - decoder_seq_len\n    elif args.sequence_parallel or cp_size > 1:\n        if args.sequence_parallel and cp_size > 1:\n            # Padding to multiple of tp_size * cp_size*2 when using sequence parallel and context parallel\n            padding_factor = tp_size * cp_size * 2\n        elif cp_size > 1:\n            padding_factor = cp_size * 2\n        elif args.sequence_parallel:\n            padding_factor = tp_size\n        mp_padding_needed = int((decoder_seq_len + padding_factor - 1) // (padding_factor) * (padding_factor)) - decoder_seq_len\n        args.decoder_seq_length = decoder_seq_len + mp_padding_needed\n    else:\n        args.decoder_seq_length = decoder_seq_len\n\n    return mp_padding_needed\n\ndef model_provider(\n    pre_process=True, post_process=True, add_encoder=True, add_decoder=True, parallel_output=True\n) -> LLaVAModel:\n    \"\"\"Builds the model.\n\n    Note: currently, only LLaVA model is supported. Follow-up changes will make this configurable.\n\n    Args:\n        pre_process (bool): Include the embedding layer in the gpt decoder (used with pipeline parallelism). Defaults to True.\n        post_process (bool): Include an output layer and a layernorm in the gpt decoder (used with pipeline parallelism). Defaults to True.\n        add_encoder (bool): Construct the encoder module (used with pipeline parallelism). Defaults to True. When we use pipelining, the encoder\n            will live on only a subset of the pipeline stages (specifically, only the first stage).\n        add_decoder (bool): Construct the decoder module (used with pipeline parallelism). Defaults to True. When we use pipelining, the decoder\n            will live on only a subset of the pipeline stages (specifically, every stage after the first one).\n        parallel_output (bool): Enable model parallel output.\n\n    Returns:\n        model (megatron.core.models.multimodal.llava_model.LLaVAModel): A multimodal model\n    \"\"\"\n    args = get_args()\n    vision_model_type = \"clip\"\n\n    assert args.ckpt_format == 'torch', \"Only ckpt-format torch is supported for VLM training currently.\"\n\n    num_image_embeddings = get_num_image_embeddings(\n        args.img_h, args.img_w, args.patch_dim, vision_model_type, args.disable_vision_class_token,\n        class_token_len=1, pixel_shuffle=False, use_tile_tags=False\n    )\n\n    old_seq_length = args.seq_length\n    # dataloader-seq-length is required to determine the length of text seq len\n    if args.dataloader_seq_length is None:\n        args.dataloader_seq_length = args.seq_length\n\n    # decoder_seq_len denotes the language model sequence length.\n    decoder_seq_len = args.dataloader_seq_length + num_image_embeddings\n\n    # seq_length and encoder_seq_length denote the vision model sequence length. Override if the user provided something else.\n    args.seq_length = args.encoder_seq_length = num_image_embeddings\n    if torch.distributed.get_rank() == 0 and old_seq_length != args.seq_length:\n        warnings.warn(\n            f\"Changed seq_length and encoder_seq_length (vision model sequence length) from {old_seq_length} to num_image_tokens ({num_image_embeddings})\"\n        )\n    mp_padding_needed = calculate_model_parallel_padding(decoder_seq_len)\n\n    args.max_position_embeddings = max(args.max_position_embeddings, args.decoder_seq_length)\n\n    print_rank_0('building a multimodal model ...')\n    language_transformer_config = core_transformer_config_from_args(get_args())\n    if args.decoder_tp_comm_overlap:\n        assert args.transformer_impl == \"transformer_engine\", \\\n            \"TransformerEngine is needed to support Decoder TP Comm overlap\"\n        language_transformer_config.tp_comm_overlap = args.decoder_tp_comm_overlap\n\n    if args.spec is not None:\n        language_transformer_layer_spec = import_module(args.spec)\n    elif args.transformer_impl == \"transformer_engine\":\n        language_transformer_layer_spec = decoder_model_with_transformer_engine_default_spec(\n            args.num_experts, args.moe_grouped_gemm\n        )\n    else:  # transformer_impl == \"local\"\n        language_transformer_layer_spec = decoder_model_with_local_default_spec(\n            args.num_experts, args.moe_grouped_gemm\n        )\n\n    # Prepare mask type for any required padding to support CP/SP sequence sharding.\n    if mp_padding_needed > 0:\n        if language_transformer_layer_spec.submodules.self_attention.params.get('attn_mask_type', '') == AttnMaskType.causal:\n            language_transformer_layer_spec.submodules.self_attention.params['attn_mask_type'] = AttnMaskType.padding_causal\n        elif language_transformer_layer_spec.submodules.self_attention.params.get('attn_mask_type', '') == AttnMaskType.no_mask:\n            language_transformer_layer_spec.submodules.self_attention.params['attn_mask_type'] = AttnMaskType.padding\n\n    if args.transformer_impl == \"transformer_engine\":\n        vision_transformer_layer_spec = get_vit_layer_with_transformer_engine_spec()\n    else:  # transformer_impl == \"local\"\n        vision_transformer_layer_spec = get_vit_layer_with_local_spec()\n\n    # TODO: Make these configurable via input .yaml config.\n    vision_transformer_config = deepcopy(language_transformer_config)\n    vision_transformer_config.num_layers = args.encoder_num_layers\n    vision_transformer_config.first_pipeline_num_layers = None\n    vision_transformer_config.last_pipeline_num_layers = None\n    vision_transformer_config.vision_model_type = vision_model_type\n    vision_transformer_config.context_parallel_size = 1 # Force CP=1 for Vision Transformer\n    if vision_transformer_config.sequence_parallel:\n        print_rank_0(\"> Disabling Sequence parallelism in Vision Transformer. Not yet supported\")\n        vision_transformer_config.sequence_parallel = False\n    if vision_transformer_config.tp_comm_overlap:\n        print_rank_0(\"> Disabling TP Comm overlap in Vision Transformer. Not yet supported\")\n        vision_transformer_config.tp_comm_overlap = False\n\n    vision_projection_type = \"mlp\"\n    vision_projection_config = deepcopy(language_transformer_config)\n    vision_projection_config.context_parallel_size = 1 # Force CP=1 for Vision Projection\n    if vision_projection_config.sequence_parallel:\n        print_rank_0(\"> Disabling Sequence parallelism in Vision Projection. Not yet supported\")\n        vision_projection_config.sequence_parallel = False\n    if vision_projection_config.tp_comm_overlap:\n        print_rank_0(\"> Disabling TP Comm overlap in Vision Projection. Not yet supported\")\n        vision_projection_config.tp_comm_overlap = False\n\n    if args.encoder_pipeline_model_parallel_size > 0:\n        assert (\n            args.encoder_pipeline_model_parallel_size == 1\n        ), \"ViT can only live on 1 pipeline stage.\"\n        vision_transformer_config.pipeline_model_parallel_size = (\n            args.encoder_pipeline_model_parallel_size\n        )\n        vision_projection_config.pipeline_model_parallel_size = (\n            args.encoder_pipeline_model_parallel_size\n        )\n        if args.encoder_tensor_model_parallel_size > 0:\n            vision_transformer_config.tensor_model_parallel_size = (\n                args.encoder_tensor_model_parallel_size\n            )\n            vision_projection_config.tensor_model_parallel_size = (\n                args.encoder_tensor_model_parallel_size\n            )\n\n    vision_projection_modules = deepcopy(language_transformer_layer_spec.submodules.mlp.submodules)\n\n    if args.virtual_pipeline_model_parallel_size:\n        raise NotImplementedError(\"virtual pipeline model parallelism is not supported yet.\")\n\n    model = LLaVAModel(\n        language_transformer_config=language_transformer_config,\n        language_transformer_layer_spec=language_transformer_layer_spec,\n        language_vocab_size=args.padded_vocab_size,\n        language_max_sequence_length=args.decoder_seq_length,\n        vision_transformer_config=vision_transformer_config,\n        vision_transformer_layer_spec=vision_transformer_layer_spec,\n        drop_vision_class_token=args.disable_vision_class_token,\n        vision_projection_config=vision_projection_config,\n        vision_projection_layer_spec=vision_projection_modules,\n        vision_projection_type=vision_projection_type,\n        parallel_output=parallel_output,\n        language_position_embedding_type=args.position_embedding_type,\n        language_rotary_percent=args.rotary_percent,\n        language_rope_scaling=args.use_rope_scaling,\n        pre_process=pre_process,\n        post_process=post_process,\n        add_encoder=add_encoder,\n        add_decoder=add_decoder,\n        img_h=args.img_h,\n        img_w=args.img_w,\n        patch_dim=args.patch_dim,\n    )\n\n    model.freeze(\n        freeze_language_model=args.freeze_LM,\n        freeze_vision_model=args.freeze_ViT,\n        freeze_vision_projection=False,\n    )\n\n    return model\n\n\ndef train_valid_test_datasets_provider(train_val_test_num_samples):\n    \"\"\"Build the train test and validation datasets.\n\n    Args:\n        train_val_test_num_samples : A list containing the number of samples in train, validation, and test sets.\n\n    Returns:\n        train_ds, val_ds, test_ds (megatron.core.datasets.multimodal_dataset.MockMultimodalDataset): Train, validation, and test datasets, respectively.\n    \"\"\"\n    args = get_args()\n\n    config = MultimodalDatasetConfig(\n        random_seed=args.seed,\n        split=args.split,\n        sequence_length=args.dataloader_seq_length,\n        tokenizer=get_tokenizer(),\n        reset_position_ids=args.reset_position_ids,\n        reset_attention_mask=args.reset_attention_mask,\n        eod_mask_loss=args.eod_mask_loss,\n        image_h=args.img_h,\n        image_w=args.img_w,\n        preprocess_func=_preprocess_data_for_llava,\n    )\n\n    print_rank_0(\"> building train, validation, and test datasets for multimodal ...\")\n\n    train_ds, valid_ds, test_ds = BlendedMegatronDatasetBuilder(\n        MockMultimodalDataset,\n        train_val_test_num_samples,\n        lambda: parallel_state.get_tensor_model_parallel_rank() == 0,\n        config,\n    ).build()\n\n    print_rank_0(\"> finished creating multimodal datasets ...\")\n\n    return train_ds, valid_ds, test_ds\n\n\ndef _preprocess_data_for_llava(data):\n    \"\"\"Preprocess data sample to the format expected by a LLaVA model.\n\n    Note: This doesn't support all the different modes in the official LLaVA repo yet.\n\n    Args:\n        data (dict): Data sample with keys like 'image', 'tokens', etc.\n\n    Returns:\n        data (dict): Processed data sample suitable for the model.\n    \"\"\"\n    # Prepend image token index to tokens.\n    data[\"tokens\"] = torch.cat(\n        [\n            DEFAULT_IMAGE_TOKEN_INDEX\n            * torch.ones(1, dtype=data[\"tokens\"].dtype, device=data[\"tokens\"].device),\n            data[\"tokens\"],\n        ]\n    )\n    # Prepend labels accordingly.\n    data[\"labels\"] = torch.cat([data[\"tokens\"][1].unsqueeze(0), data[\"labels\"]])\n    # Zero loss mask for the image token index.\n    data[\"loss_mask\"] = torch.cat(\n        [\n            torch.zeros(1, dtype=data[\"loss_mask\"].dtype, device=data[\"loss_mask\"].device),\n            data[\"loss_mask\"],\n        ]\n    )\n    # Add one more position id.\n    data[\"position_ids\"] = torch.cat(\n        [data[\"position_ids\"], data[\"position_ids\"][-1].unsqueeze(0) + 1]\n    )\n\n    return data\n\ndef get_batch(data_iterator):\n    \"\"\"Generate a batch.\n\n    Args:\n        data_iterator: Iterable dataset.\n\n    Returns:\n        sample: A data sample with images, tokens, etc.\n    \"\"\"\n    def _get_packed_seq_params(tokens, img_seq_len, mp_padding_needed):\n        batch_size = tokens.shape[0]\n        # Calculate the valid token seq len that LM backbone should compute on\n        combined_valid_seqlen = tokens.shape[1] + img_seq_len - mp_padding_needed\n        cu_seqlens = torch.arange(\n            0, (batch_size + 1) * (combined_valid_seqlen), step=(combined_valid_seqlen), dtype=torch.int32, device=tokens.device)\n        # Calculate the total padded token seq len\n        combined_padded_seqlen = tokens.shape[1] + img_seq_len\n        cu_seqlens_padded = None\n        qkv_format = 'sbhd'\n        if cp_size > 1:\n            # Provide cu_seqlens_<q/kv>_padded for CP support\n            cu_seqlens_padded = torch.arange(\n                0, (batch_size + 1) * (combined_padded_seqlen), step=(combined_padded_seqlen), dtype=torch.int32, device=tokens.device)\n            # CP with padding mask type requires THD format\n            qkv_format = 'thd'\n        packed_seq_params = PackedSeqParams(\n            cu_seqlens_q=cu_seqlens,\n            cu_seqlens_kv=cu_seqlens,\n            cu_seqlens_q_padded=cu_seqlens_padded,\n            cu_seqlens_kv_padded=cu_seqlens_padded,\n            max_seqlen_q=combined_padded_seqlen,\n            max_seqlen_kv=combined_padded_seqlen,\n            qkv_format=qkv_format,\n        )\n        return packed_seq_params\n\n    args = get_args()\n    cp_size = args.context_parallel_size\n    # Broadcast data.\n    if data_iterator is not None:\n        data = next(data_iterator)\n    else:\n        data = None\n\n    data_i = tensor_parallel.broadcast_data([\"tokens\", \"position_ids\", \"labels\"], data, torch.int64)\n    data_f = tensor_parallel.broadcast_data([\"image\", \"loss_mask\"], data, torch.float32)\n\n    batch = dict()\n    packed_seq_params = None\n    image_token_mask = None\n    # Create batch with tokens and position_ids for CP sharding.\n    tokens = data_i[\"tokens\"].long()\n    position_ids = data_i[\"position_ids\"].long()\n    labels = data_i[\"labels\"].long()\n    loss_mask = data_f[\"loss_mask\"].float()\n    images = data_f[\"image\"].float()\n\n    if cp_size > 1 or args.sequence_parallel:\n        vision_model_type = \"clip\"\n        # Calculate the number of image embedding tokens will be added to text tokens\n        num_image_embeddings_per_tile = get_num_image_embeddings(\n            args.img_h, args.img_w, args.patch_dim, vision_model_type, args.disable_vision_class_token, 1\n        )\n        # Pad to make sure the text sequence can be sharded equally by CP chunks.\n        mp_padding_needed_for_text = calculate_model_parallel_padding(tokens.shape[1], text_only=True)\n        if mp_padding_needed_for_text > 0:\n            tokens, position_ids, labels, loss_mask = [torch.nn.functional.pad(item, (0, mp_padding_needed_for_text)) for item in (tokens, position_ids, labels, loss_mask)]\n        # Image token mask must be supplied before distributed sequence to CP ranks.\n        image_token_mask = tokens == DEFAULT_IMAGE_TOKEN_INDEX\n        num_images_per_sample = torch.sum(image_token_mask, dim=-1)\n        img_seq_len = (num_image_embeddings_per_tile * num_images_per_sample - num_images_per_sample).max()\n        packed_seq_params = _get_packed_seq_params(tokens, img_seq_len, mp_padding_needed_for_text)\n\n    # slice batch along sequence dimension for context parallelism\n    batch = get_batch_on_this_cp_rank({\"tokens\": tokens, \"position_ids\": position_ids})\n    attention_mask = None  # Use the attention mask type defined in layer spec. Typically no mask for the vision model and causal mask for the vision model.\n\n    return batch[\"tokens\"], batch[\"position_ids\"], labels, images, loss_mask, attention_mask, image_token_mask, packed_seq_params\n\n\ndef forward_step(data_iterator, model: LLaVAModel):\n    \"\"\"Forward training step.\n\n    Args:\n        data_iterator: Iterable dataset.\n        model (megatron.core.models.multimodal.llava_model.LLaVAModel): Multimodal model\n\n    Returns:\n        output_tensor (torch.Tensor): Loss of shape [b, s] if labels are provided, otherwise logits of shape [b, s, vocab_size].\n        loss_func (callable): Loss function with a loss mask specified.\n    \"\"\"\n    timers = get_timers()\n\n    # Get the batch.\n    timers('batch-generator', log_level=2).start()\n    tokens, position_ids, labels, images, loss_mask, attention_mask, image_token_mask, packed_seq_params = get_batch(data_iterator)\n    timers('batch-generator').stop()\n\n    output_tensor, loss_mask = model(\n        images, tokens, position_ids, attention_mask, labels, loss_mask, image_token_mask=image_token_mask, packed_seq_params=packed_seq_params\n    )\n\n    return output_tensor, partial(loss_func, loss_mask)\n\n\ndef add_vlm_extra_args(parser):\n    \"\"\"Extra arguments.\"\"\"\n    group = parser.add_argument_group(title='vision language model specific arguments')\n    group.add_argument(\n        '--freeze-LM', action='store_true', default=False, help=\"Freeze language model weights\"\n    )\n    group.add_argument(\n        '--freeze-ViT', action='store_true', default=False, help=\"Freeze vision model (ViT) weights\"\n    )\n    group.add_argument(\n        \"--disable-vision-class-token\",\n        action=\"store_true\",\n        default=False,\n        help=\"Drop vision model class token\",\n    )\n    group.add_argument(\"--dataloader-seq-length\", type=int, help=\"Make dataloader to produce sequences of specific length.\")\n    group.add_argument(\"--decoder-tp-comm-overlap\", action=\"store_true\", default=False, help=\"Enables the overlap of \"\n                        \"Tensor parallel communication and GEMM kernels in Decoder only. \"\n                        \"Please provide decoder-seq-length when using this feature.\")\n    return parser\n\n\ndef llava_embedding_ranks(pp_ranks):\n    \"\"\"LLava's embedding ranks consist of the decoder's first and last ranks (ie, the ViT has no embeddings).\n    Args:\n        pp_ranks: A list of global ranks that constitute a pipeline group.\n    \"\"\"\n    args = get_args()\n\n    # encoder size is also the index to the first rank of the decoder.\n    epp = args.encoder_pipeline_model_parallel_size\n\n    last_rank = pp_ranks[-1]\n    if len(pp_ranks) == 1 or pp_ranks[epp] == last_rank:\n        return [last_rank]\n    else:\n        return [pp_ranks[epp], last_rank]\n\n\ndef llava_position_embedding_ranks(pp_ranks):\n    \"\"\"LLava's embedding ranks consist of the singular rank of the model or the decoder's first rank.\n    Args:\n        pp_ranks: A list of global ranks that constitute a pipeline group.\n    \"\"\"\n    args = get_args()\n\n    # encoder size is also the index to the first rank of the decoder.\n    epp = args.encoder_pipeline_model_parallel_size\n\n    last_rank = pp_ranks[-1]\n    if len(pp_ranks) == 1:\n        return [last_rank]\n    else:\n        return [pp_ranks[epp]]\n\n\nif __name__ == \"__main__\":\n    train_valid_test_datasets_provider.is_distributed = True\n\n    pretrain(\n        train_valid_test_datasets_provider,\n        model_provider,\n        ModelType.encoder_and_decoder,\n        forward_step,\n        args_defaults={'tokenizer_type': 'GPT2BPETokenizer'},\n        extra_args_provider=add_vlm_extra_args,\n        get_embedding_ranks=llava_embedding_ranks,\n        get_position_embedding_ranks=llava_position_embedding_ranks,\n    )\n"
        },
        {
          "name": "pyproject.toml",
          "type": "blob",
          "size": 2.3447265625,
          "content": "# Copyright (c) 2023, NVIDIA CORPORATION.  All rights reserved.\n\n[build-system]\nrequires = [\n    \"setuptools\",\n    \"pybind11\",\n]\n\n[project]\nname = \"megatron-core\"\ndynamic = [\"dependencies\", \"version\"]\ndescription = \"Megatron Core - a library for efficient and scalable training of transformer based models\"\nreadme = \"README.md\"\nlicense = {file = \"LICENSE\"}\nauthors = [{ name = \"NVIDIA\", email = \"nemo-toolkit@nvidia.com\" }]\nmaintainers = [{ name = \"NVIDIA\", email = \"nemo-toolkit@nvidia.com\" }]\nkeywords = [\n    \"NLP\",\n    \"NLU\",\n    \"deep\",\n    \"gpu\",\n    \"language\",\n    \"learning\",\n    \"learning\",\n    \"machine\",\n    \"nvidia\",\n    \"pytorch\",\n    \"torch\",\n    \"transformer\",\n]\nclassifiers = [\n    \"Development Status :: 5 - Production/Stable\",\n    \"Environment :: Console\",\n    \"Intended Audience :: Developers\",\n    \"Intended Audience :: Information Technology\",\n    \"Intended Audience :: Science/Research\",\n    \"License :: OSI Approved :: BSD License\",\n    \"Natural Language :: English\",\n    \"Operating System :: OS Independent\",\n    \"Programming Language :: Python :: 3\",\n    \"Programming Language :: Python :: 3.8\",\n    \"Programming Language :: Python :: 3.9\",\n    \"Topic :: Scientific/Engineering :: Artificial Intelligence\",\n    \"Topic :: Scientific/Engineering :: Image Recognition\",\n    \"Topic :: Scientific/Engineering :: Mathematics\",\n    \"Topic :: Scientific/Engineering\",\n    \"Topic :: Software Development :: Libraries :: Python Modules\",\n    \"Topic :: Software Development :: Libraries\",\n    \"Topic :: Utilities\",\n]\n\n[project.urls]\nDownload = \"https://github.com/NVIDIA/Megatron-LM/releases\"\nHomepage = \"https://github.com/NVIDIA/Megatron-LM/megatron/core\"\n\n[tool.isort]\nprofile = \"black\"  # black-compatible\nline_length = 100  # should match black parameters\npy_version = 310  # python 3.8 as a target version\nknown_first_party = [\"megatron\"]  # FIRSTPARTY section\nknown_third_party = [\"transformer_engine\"]  # THIRDPARTY section\nsections = [\"FUTURE\", \"STDLIB\", \"THIRDPARTY\", \"FIRSTPARTY\", \"LOCALFOLDER\"]\ndefault_section = \"THIRDPARTY\"\nextend_skip = [\"setup.py\"]\n\n[tool.black]\nline_length = 100\nskip_string_normalization = true\n# recongized by future versions, disallows to reformat code with incompatible versions\n# Matches NeMO version so people working on both codebases don't need two different version of black installed\nrequired_version = \"24\"  \nskip_magic_trailing_comma = true"
        },
        {
          "name": "pytest.ini",
          "type": "blob",
          "size": 0.1064453125,
          "content": "# content of pytest.ini\n[pytest]\nmarkers =\n    internal: mark a test as a test to private/internal functions."
        },
        {
          "name": "requirements",
          "type": "tree",
          "content": null
        },
        {
          "name": "setup.py",
          "type": "blob",
          "size": 4.4716796875,
          "content": "\"\"\"Setup for pip package.\"\"\"\n\nimport importlib.util\nimport subprocess\nimport os\nimport setuptools\nfrom setuptools import Extension\n\nspec = importlib.util.spec_from_file_location('package_info', 'megatron/core/package_info.py')\npackage_info = importlib.util.module_from_spec(spec)\nspec.loader.exec_module(package_info)\n\n\n__contact_emails__ = package_info.__contact_emails__\n__contact_names__ = package_info.__contact_names__\n__description__ = package_info.__description__\n__download_url__ = package_info.__download_url__\n__homepage__ = package_info.__homepage__\n__keywords__ = package_info.__keywords__\n__license__ = package_info.__license__\n__package_name__ = package_info.__package_name__\n__repository_url__ = package_info.__repository_url__\n__version__ = package_info.__version__\n\n\nwith open(\"megatron/core/README.md\", \"r\", encoding='utf-8') as fh:\n    long_description = fh.read()\nlong_description_content_type = \"text/markdown\"\n\n\ndef req_file(filename, folder=\"requirements\"):\n    environment = os.getenv(\"PY_ENV\", \"pytorch:24.07\")\n\n    with open(os.path.join(folder, environment, filename), encoding='utf-8') as f:\n        content = f.readlines()\n    # you may also want to remove whitespace characters\n    # Example: `\\n` at the end of each line\n    return [x.strip() for x in content]\n\n\ninstall_requires = req_file(\"requirements.txt\")\n\n###############################################################################\n#                             Extension Making                                #\n# %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% #\n\n###############################################################################\n\nsetuptools.setup(\n    name=__package_name__,\n    # Versions should comply with PEP440.  For a discussion on single-sourcing\n    # the version across setup.py and the project code, see\n    # https://packaging.python.org/en/latest/single_source_version.html\n    version=__version__,\n    description=__description__,\n    long_description=long_description,\n    long_description_content_type=long_description_content_type,\n    # The project's main homepage.\n    url=__repository_url__,\n    download_url=__download_url__,\n    # Author details\n    author=__contact_names__,\n    author_email=__contact_emails__,\n    # maintainer Details\n    maintainer=__contact_names__,\n    maintainer_email=__contact_emails__,\n    # The licence under which the project is released\n    license=__license__,\n    classifiers=[\n        # How mature is this project? Common values are\n        #  1 - Planning\n        #  2 - Pre-Alpha\n        #  3 - Alpha\n        #  4 - Beta\n        #  5 - Production/Stable\n        #  6 - Mature\n        #  7 - Inactive\n        'Development Status :: 5 - Production/Stable',\n        # Indicate who your project is intended for\n        'Intended Audience :: Developers',\n        'Intended Audience :: Science/Research',\n        'Intended Audience :: Information Technology',\n        # Indicate what your project relates to\n        'Topic :: Scientific/Engineering',\n        'Topic :: Scientific/Engineering :: Mathematics',\n        'Topic :: Scientific/Engineering :: Image Recognition',\n        'Topic :: Scientific/Engineering :: Artificial Intelligence',\n        'Topic :: Software Development :: Libraries',\n        'Topic :: Software Development :: Libraries :: Python Modules',\n        'Topic :: Utilities',\n        # Pick your license as you wish (should match \"license\" above)\n        'License :: OSI Approved :: BSD License',\n        # Supported python versions\n        'Programming Language :: Python :: 3',\n        'Programming Language :: Python :: 3.8',\n        'Programming Language :: Python :: 3.9',\n        # Additional Setting\n        'Environment :: Console',\n        'Natural Language :: English',\n        'Operating System :: OS Independent',\n    ],\n    packages=setuptools.find_namespace_packages(include=[\"megatron.core\", \"megatron.core.*\"]),\n    ext_modules=[\n        Extension(\n            \"megatron.core.datasets.helpers_cpp\",\n            sources=[\"megatron/core/datasets/helpers.cpp\"],\n            language=\"c++\",\n            extra_compile_args=(\n                subprocess.check_output([\"python3\", \"-m\", \"pybind11\", \"--includes\"])\n                .decode(\"utf-8\")\n                .strip()\n                .split()\n            )\n            + ['-O3', '-Wall', '-std=c++17'],\n            optional=True,\n        )\n    ],\n    # Add in any packaged data.\n    include_package_data=True,\n    # PyPI package information.\n    keywords=__keywords__,\n    install_requires=install_requires,\n)\n"
        },
        {
          "name": "tasks",
          "type": "tree",
          "content": null
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "tools",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}