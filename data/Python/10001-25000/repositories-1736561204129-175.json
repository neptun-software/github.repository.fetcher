{
  "metadata": {
    "timestamp": 1736561204129,
    "page": 175,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "Dao-AILab/flash-attention",
      "stars": 15000,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.26171875,
          "content": "*.ncu-rep\n.DS_store\n\n# Byte-compiled / optimized / DLL files\n__pycache__/\n*.py[cod]\n\n# C extensions\n*.so\n\n# Distribution / packaging\nbin/\nbuild/\ndevelop-eggs/\ndist/\neggs/\nlib/\nlib64/\nparts/\nsdist/\nvar/\n*.egg-info/\n.installed.cfg\n*.egg\n\n# IDE-related\n.idea/\n\n# Dev\nvenv"
        },
        {
          "name": ".gitmodules",
          "type": "blob",
          "size": 0.208984375,
          "content": "[submodule \"csrc/cutlass\"]\n\tpath = csrc/cutlass\n\turl = https://github.com/NVIDIA/cutlass.git\n[submodule \"csrc/composable_kernel\"]\n\tpath = csrc/composable_kernel\n\turl = https://github.com/ROCm/composable_kernel.git\n"
        },
        {
          "name": "AUTHORS",
          "type": "blob",
          "size": 0.0283203125,
          "content": "Tri Dao, trid@cs.stanford.edu"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.521484375,
          "content": "BSD 3-Clause License\n\nCopyright (c) 2022, the respective contributors, as shown by the AUTHORS file.\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above copyright notice,\n  this list of conditions and the following disclaimer in the documentation\n  and/or other materials provided with the distribution.\n\n* Neither the name of the copyright holder nor the names of its\n  contributors may be used to endorse or promote products derived from\n  this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "MANIFEST.in",
          "type": "blob",
          "size": 0.3076171875,
          "content": "recursive-include csrc *.cu\nrecursive-include csrc *.h\nrecursive-include csrc *.cuh\nrecursive-include csrc *.cpp\nrecursive-include csrc *.hpp\n\nrecursive-include flash_attn *.cu\nrecursive-include flash_attn *.h\nrecursive-include flash_attn *.cuh\nrecursive-include flash_attn *.cpp\nrecursive-include flash_attn *.hpp\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.123046875,
          "content": "\nclean_dist:\n\trm -rf dist/*\n\ncreate_dist: clean_dist\n\tpython setup.py sdist\n\nupload_package: create_dist\n\ttwine upload dist/*\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 21.392578125,
          "content": "# FlashAttention\nThis repository provides the official implementation of FlashAttention and\nFlashAttention-2 from the\nfollowing papers.\n\n**FlashAttention: Fast and Memory-Efficient Exact Attention with IO-Awareness**  \nTri Dao, Daniel Y. Fu, Stefano Ermon, Atri Rudra, Christopher RÃ©  \nPaper: https://arxiv.org/abs/2205.14135  \nIEEE Spectrum [article](https://spectrum.ieee.org/mlperf-rankings-2022) about our submission to the MLPerf 2.0 benchmark using FlashAttention.\n![FlashAttention](assets/flashattn_banner.jpg)\n\n**FlashAttention-2: Faster Attention with Better Parallelism and Work Partitioning**  \nTri Dao\n\nPaper: https://tridao.me/publications/flash2/flash2.pdf\n\n![FlashAttention-2](assets/flashattention_logo.png)\n\n\n## Usage\n\nWe've been very happy to see FlashAttention being widely adopted in such a short\ntime after its release. This [page](https://github.com/Dao-AILab/flash-attention/blob/main/usage.md)\ncontains a partial list of places where FlashAttention is being used.\n\nFlashAttention and FlashAttention-2 are free to use and modify (see LICENSE).\nPlease cite and credit FlashAttention if you use it.\n\n\n## FlashAttention-3 beta release\nFlashAttention-3 is optimized for Hopper GPUs (e.g. H100). \n\nBlogpost: https://tridao.me/blog/2024/flash3/\n\nPaper: https://tridao.me/publications/flash3/flash3.pdf\n\n![FlashAttention-3 speedup on H100 80GB SXM5 with FP16](assets/flash3_fp16_fwd.png)\n\nThis is a beta release for testing / benchmarking before we integrate that with\nthe rest of the repo.\n\nCurrently released:\n- FP16 / BF16 forward and backward, FP8 forward\n\nRequirements: H100 / H800 GPU, CUDA >= 12.3.\n\nFor now, we highly recommend CUDA 12.3 for best performance.\n\nTo install:\n```sh\ncd hopper\npython setup.py install\n```\nTo run the test:\n```sh\nexport PYTHONPATH=$PWD\npytest -q -s test_flash_attn.py\n```\nOnce the package is installed, you can import it as follows:\n```python\nimport flash_attn_interface\nflash_attn_interface.flash_attn_func()\n```\n\n## Installation and features\n**Requirements:**\n- CUDA toolkit or ROCm toolkit\n- PyTorch 1.12 and above.\n- `packaging` Python package (`pip install packaging`)\n- `ninja` Python package (`pip install ninja`) *\n- Linux. Might work for Windows starting v2.3.2 (we've seen a few positive [reports](https://github.com/Dao-AILab/flash-attention/issues/595)) but Windows compilation still requires more testing. If you have ideas on how to set up prebuilt CUDA wheels for Windows, please reach out via Github issue.\n\n\\* Make sure that `ninja` is installed and that it works correctly (e.g. `ninja\n--version` then `echo $?` should return exit code 0). If not (sometimes `ninja\n--version` then `echo $?` returns a nonzero exit code), uninstall then reinstall\n`ninja` (`pip uninstall -y ninja && pip install ninja`). Without `ninja`,\ncompiling can take a very long time (2h) since it does not use multiple CPU\ncores. With `ninja` compiling takes 3-5 minutes on a 64-core machine using CUDA toolkit.\n\n**To install:**\n```sh\npip install flash-attn --no-build-isolation\n```\nAlternatively you can compile from source:\n```sh\npython setup.py install\n```\n\nIf your machine has less than 96GB of RAM and lots of CPU cores, `ninja` might\nrun too many parallel compilation jobs that could exhaust the amount of RAM. To\nlimit the number of parallel compilation jobs, you can set the environment\nvariable `MAX_JOBS`:\n```sh\nMAX_JOBS=4 pip install flash-attn --no-build-isolation\n```\n\n**Interface:** `src/flash_attention_interface.py`\n\n### NVIDIA CUDA Support\n**Requirements:**\n- CUDA 11.7 and above.\n\nWe recommend the\n[Pytorch](https://catalog.ngc.nvidia.com/orgs/nvidia/containers/pytorch)\ncontainer from Nvidia, which has all the required tools to install FlashAttention.\n\nFlashAttention-2 with CUDA currently supports:\n1. Ampere, Ada, or Hopper GPUs (e.g., A100, RTX 3090, RTX 4090, H100). Support for Turing\n   GPUs (T4, RTX 2080) is coming soon, please use FlashAttention 1.x for Turing\n   GPUs for now.\n2. Datatype fp16 and bf16 (bf16 requires Ampere, Ada, or Hopper GPUs).\n3. All head dimensions up to 256. ~~Head dim > 192 backward requires A100/A800 or H100/H800~~. Head dim 256 backward now works on consumer GPUs (if there's no dropout) as of flash-attn 2.5.5.\n\n### AMD ROCm Support\nROCm version has two backends. There is [composable_kernel](https://github.com/ROCm/composable_kernel) (ck) which is the default backend and a [Triton](https://github.com/triton-lang/triton) backend. They provide an implementation of FlashAttention-2.\n\n**Requirements:**\n- ROCm 6.0 and above.\n\nWe recommend the\n[Pytorch](https://hub.docker.com/r/rocm/pytorch)\ncontainer from ROCm, which has all the required tools to install FlashAttention.\n\n#### Composable Kernel Backend\nFlashAttention-2 ROCm CK backend currently supports:\n1. MI200 or MI300 GPUs.\n2. Datatype fp16 and bf16\n3. Both forward's and backward's head dimensions up to 256.\n\n#### Triton Backend\nThe Triton implementation of the [Flash Attention v2](https://tridao.me/publications/flash2/flash2.pdf) is currently a work in progress.\n\nIt supports AMD's CDNA (MI200, MI300) and RDNA GPU's using fp16, bf16 and fp32 datatypes.\n\nThese features are supported in Fwd and Bwd\n1) Fwd and Bwd with causal masking\n2) Variable sequence lengths\n3) Arbitrary Q and KV sequence lengths\n4) Arbitrary head sizes\n\nThese features are supported in Fwd for now. We will add them to backward soon.\n1) Multi and grouped query attention\n2) ALiBi and matrix bias\n\nThese features are in development\n1) Paged Attention \n2) Sliding Window\n3) Rotary embeddings\n4) Dropout\n5) Performance Improvements\n\n#### Getting Started\nTo get started with the triton backend for AMD, follow the steps below.\n\nFirst install the recommended Triton [commit](https://github.com/triton-lang/triton/commit/3ca2f498e98ed7249b82722587c511a5610e00c4).\n\n```\ngit clone https://github.com/triton-lang/triton\ncd triton\ngit checkout 3ca2f498e98ed7249b82722587c511a5610e00c4 \npip install --verbose -e python\n```\nThen install and test Flash Attention with the flag `FLASH_ATTENTION_TRITON_AMD_ENABLE` set to `\"TRUE\"`.\n\n```\nexport FLASH_ATTENTION_TRITON_AMD_ENABLE=\"TRUE\"\ncd flash-attention\npython setup.py install\npytest tests/test_flash_attn.py\n```\n\n\n## How to use FlashAttention\n\nThe main functions implement scaled dot product attention (softmax(Q @ K^T *\nsoftmax_scale) @ V):\n```python\nfrom flash_attn import flash_attn_qkvpacked_func, flash_attn_func\n```\n\n```python\nflash_attn_qkvpacked_func(qkv, dropout_p=0.0, softmax_scale=None, causal=False,\n                          window_size=(-1, -1), alibi_slopes=None, deterministic=False):\n\"\"\"dropout_p should be set to 0.0 during evaluation\nIf Q, K, V are already stacked into 1 tensor, this function will be faster than\ncalling flash_attn_func on Q, K, V since the backward pass avoids explicit concatenation\nof the gradients of Q, K, V.\nIf window_size != (-1, -1), implements sliding window local attention. Query at position i\nwill only attend to keys between [i - window_size[0], i + window_size[1]] inclusive.\nArguments:\n    qkv: (batch_size, seqlen, 3, nheads, headdim)\n    dropout_p: float. Dropout probability.\n    softmax_scale: float. The scaling of QK^T before applying softmax.\n        Default to 1 / sqrt(headdim).\n    causal: bool. Whether to apply causal attention mask (e.g., for auto-regressive modeling).\n    window_size: (left, right). If not (-1, -1), implements sliding window local attention.\n    alibi_slopes: (nheads,) or (batch_size, nheads), fp32. A bias of (-alibi_slope * |i - j|) is added to\n        the attention score of query i and key j.\n    deterministic: bool. Whether to use the deterministic implementation of the backward pass,\n        which is slightly slower and uses more memory. The forward pass is always deterministic.\nReturn:\n    out: (batch_size, seqlen, nheads, headdim).\n\"\"\"\n```\n\n```python\nflash_attn_func(q, k, v, dropout_p=0.0, softmax_scale=None, causal=False,\n                window_size=(-1, -1), alibi_slopes=None, deterministic=False):\n\"\"\"dropout_p should be set to 0.0 during evaluation\nSupports multi-query and grouped-query attention (MQA/GQA) by passing in KV with fewer heads\nthan Q. Note that the number of heads in Q must be divisible by the number of heads in KV.\nFor example, if Q has 6 heads and K, V have 2 heads, head 0, 1, 2 of Q will attention to head\n0 of K, V, and head 3, 4, 5 of Q will attention to head 1 of K, V.\nIf window_size != (-1, -1), implements sliding window local attention. Query at position i\nwill only attend to keys between\n[i + seqlen_k - seqlen_q - window_size[0], i + seqlen_k - seqlen_q + window_size[1]] inclusive.\n\nArguments:\n    q: (batch_size, seqlen, nheads, headdim)\n    k: (batch_size, seqlen, nheads_k, headdim)\n    v: (batch_size, seqlen, nheads_k, headdim)\n    dropout_p: float. Dropout probability.\n    softmax_scale: float. The scaling of QK^T before applying softmax.\n        Default to 1 / sqrt(headdim).\n    causal: bool. Whether to apply causal attention mask (e.g., for auto-regressive modeling).\n    window_size: (left, right). If not (-1, -1), implements sliding window local attention.\n    alibi_slopes: (nheads,) or (batch_size, nheads), fp32. A bias of\n        (-alibi_slope * |i + seqlen_k - seqlen_q - j|)\n        is added to the attention score of query i and key j.\n    deterministic: bool. Whether to use the deterministic implementation of the backward pass,\n        which is slightly slower and uses more memory. The forward pass is always deterministic.\nReturn:\n    out: (batch_size, seqlen, nheads, headdim).\n\"\"\"\n```\n\n```python\ndef flash_attn_with_kvcache(\n    q,\n    k_cache,\n    v_cache,\n    k=None,\n    v=None,\n    rotary_cos=None,\n    rotary_sin=None,\n    cache_seqlens: Optional[Union[(int, torch.Tensor)]] = None,\n    cache_batch_idx: Optional[torch.Tensor] = None,\n    block_table: Optional[torch.Tensor] = None,\n    softmax_scale=None,\n    causal=False,\n    window_size=(-1, -1),  # -1 means infinite context window\n    rotary_interleaved=True,\n    alibi_slopes=None,\n):\n    \"\"\"\n    If k and v are not None, k_cache and v_cache will be updated *inplace* with the new values from\n    k and v. This is useful for incremental decoding: you can pass in the cached keys/values from\n    the previous step, and update them with the new keys/values from the current step, and do\n    attention with the updated cache, all in 1 kernel.\n\n    If you pass in k / v, you must make sure that the cache is large enough to hold the new values.\n    For example, the KV cache could be pre-allocated with the max sequence length, and you can use\n    cache_seqlens to keep track of the current sequence lengths of each sequence in the batch.\n\n    Also apply rotary embedding if rotary_cos and rotary_sin are passed in. The key @k will be\n    rotated by rotary_cos and rotary_sin at indices cache_seqlens, cache_seqlens + 1, etc.\n    If causal or local (i.e., window_size != (-1, -1)), the query @q will be rotated by rotary_cos\n    and rotary_sin at indices cache_seqlens, cache_seqlens + 1, etc.\n    If not causal and not local, the query @q will be rotated by rotary_cos and rotary_sin at\n    indices cache_seqlens only (i.e. we consider all tokens in @q to be at position cache_seqlens).\n\n    See tests/test_flash_attn.py::test_flash_attn_kvcache for examples of how to use this function.\n\n    Supports multi-query and grouped-query attention (MQA/GQA) by passing in KV with fewer heads\n    than Q. Note that the number of heads in Q must be divisible by the number of heads in KV.\n    For example, if Q has 6 heads and K, V have 2 heads, head 0, 1, 2 of Q will attention to head\n    0 of K, V, and head 3, 4, 5 of Q will attention to head 1 of K, V.\n\n    If causal=True, the causal mask is aligned to the bottom right corner of the attention matrix.\n    For example, if seqlen_q = 2 and seqlen_k = 5, the causal mask (1 = keep, 0 = masked out) is:\n        1 1 1 1 0\n        1 1 1 1 1\n    If seqlen_q = 5 and seqlen_k = 2, the causal mask is:\n        0 0\n        0 0\n        0 0\n        1 0\n        1 1\n    If the row of the mask is all zero, the output will be zero.\n\n    If window_size != (-1, -1), implements sliding window local attention. Query at position i\n    will only attend to keys between\n    [i + seqlen_k - seqlen_q - window_size[0], i + seqlen_k - seqlen_q + window_size[1]] inclusive.\n\n    Note: Does not support backward pass.\n\n    Arguments:\n        q: (batch_size, seqlen, nheads, headdim)\n        k_cache: (batch_size_cache, seqlen_cache, nheads_k, headdim) if there's no block_table,\n            or (num_blocks, page_block_size, nheads_k, headdim) if there's a block_table (i.e. paged KV cache)\n            page_block_size must be a multiple of 256.\n        v_cache: (batch_size_cache, seqlen_cache, nheads_k, headdim) if there's no block_table,\n            or (num_blocks, page_block_size, nheads_k, headdim) if there's a block_table (i.e. paged KV cache)\n        k [optional]: (batch_size, seqlen_new, nheads_k, headdim). If not None, we concatenate\n            k with k_cache, starting at the indices specified by cache_seqlens.\n        v [optional]: (batch_size, seqlen_new, nheads_k, headdim). Similar to k.\n        rotary_cos [optional]: (seqlen_ro, rotary_dim / 2). If not None, we apply rotary embedding\n            to k and q. Only applicable if k and v are passed in. rotary_dim must be divisible by 16.\n        rotary_sin [optional]: (seqlen_ro, rotary_dim / 2). Similar to rotary_cos.\n        cache_seqlens: int, or (batch_size,), dtype torch.int32. The sequence lengths of the\n            KV cache.\n        block_table [optional]: (batch_size, max_num_blocks_per_seq), dtype torch.int32.\n        cache_batch_idx: (batch_size,), dtype torch.int32. The indices used to index into the KV cache.\n            If None, we assume that the batch indices are [0, 1, 2, ..., batch_size - 1].\n            If the indices are not distinct, and k and v are provided, the values updated in the cache\n                 might come from any of the duplicate indices.\n        softmax_scale: float. The scaling of QK^T before applying softmax.\n            Default to 1 / sqrt(headdim).\n        causal: bool. Whether to apply causal attention mask (e.g., for auto-regressive modeling).\n        window_size: (left, right). If not (-1, -1), implements sliding window local attention.\n        rotary_interleaved: bool. Only applicable if rotary_cos and rotary_sin are passed in.\n            If True, rotary embedding will combine dimensions 0 & 1, 2 & 3, etc. If False,\n            rotary embedding will combine dimensions 0 & rotary_dim / 2, 1 & rotary_dim / 2 + 1\n            (i.e. GPT-NeoX style).\n        alibi_slopes: (nheads,) or (batch_size, nheads), fp32. A bias of\n            (-alibi_slope * |i + seqlen_k - seqlen_q - j|)\n            is added to the attention score of query i and key j.\n\n    Return:\n        out: (batch_size, seqlen, nheads, headdim).\n    \"\"\"\n```\n\nTo see how these functions are used in a multi-head attention layer (which\nincludes QKV projection, output projection), see the MHA [implementation](https://github.com/Dao-AILab/flash-attention/blob/main/flash_attn/modules/mha.py).\n\n## Changelog\n\n### 2.0: Complete rewrite, 2x faster\nUpgrading from FlashAttention (1.x) to FlashAttention-2\n\nThese functions have been renamed:\n- `flash_attn_unpadded_func` -> `flash_attn_varlen_func`\n- `flash_attn_unpadded_qkvpacked_func` -> `flash_attn_varlen_qkvpacked_func`\n- `flash_attn_unpadded_kvpacked_func` -> `flash_attn_varlen_kvpacked_func`\n\nIf the inputs have the same sequence lengths in the same batch, it is simpler\nand faster to use these functions:\n```python\nflash_attn_qkvpacked_func(qkv, dropout_p=0.0, softmax_scale=None, causal=False)\n```\n```python\nflash_attn_func(q, k, v, dropout_p=0.0, softmax_scale=None, causal=False)\n```\n### 2.1: Change behavior of causal flag\n\nIf seqlen_q != seqlen_k and causal=True, the causal mask is aligned to the\nbottom right corner of the attention matrix, instead of the top-left corner.\n\nFor example, if seqlen_q = 2 and seqlen_k = 5, the causal mask (1 = keep, 0 =\nmasked out) is:  \nv2.0:  \n    1 0 0 0 0  \n    1 1 0 0 0  \nv2.1:  \n    1 1 1 1 0  \n    1 1 1 1 1  \n\nIf seqlen_q = 5 and seqlen_k = 2, the causal mask is:  \nv2.0:  \n    1 0  \n    1 1  \n    1 1  \n    1 1  \n    1 1  \nv2.1:  \n    0 0  \n    0 0  \n    0 0  \n    1 0  \n    1 1  \nIf the row of the mask is all zero, the output will be zero.\n\n### 2.2: Optimize for inference\n\nOptimize for inference (iterative decoding) when query has very small sequence\nlength (e.g., query sequence length = 1). The bottleneck here is to load KV\ncache as fast as possible, and we split the loading across different thread\nblocks, with a separate kernel to combine results.\n\nSee the function `flash_attn_with_kvcache` with more features for inference\n(perform rotary embedding, updating KV cache inplace).\n\nThanks to the xformers team, and in particular Daniel Haziza, for this\ncollaboration.\n\n### 2.3: Local (i.e., sliding window) attention\n\nImplement sliding window attention (i.e., local attention). Thanks to [Mistral\nAI](https://mistral.ai/) and in particular TimothÃ©e Lacroix for this\ncontribution. Sliding window was used in the [Mistral 7B](https://mistral.ai/news/announcing-mistral-7b/) model.\n\n### 2.4: ALiBi (attention with linear bias), deterministic backward pass.\n\nImplement ALiBi (Press et al., 2021). Thanks to Sanghun Cho from Kakao Brain for this contribution.\n\nImplement deterministic backward pass. Thanks to engineers from [Meituan](www.meituan.com) for this contribution.\n\n### 2.5: Paged KV cache.\n\nSupport paged KV cache (i.e., [PagedAttention](https://arxiv.org/abs/2309.06180)).\nThanks to @beginlner for this contribution.\n\n### 2.6: Softcapping.\n\nSupport attention with softcapping, as used in Gemma-2 and Grok models.\nThanks to @Narsil and @lucidrains for this contribution.\n\n### 2.7: Compatibility with torch compile\n\nThanks to @ani300 for this contribution.\n\n## Performance\n\nWe present expected speedup (combined forward + backward pass) and memory savings from using FlashAttention against PyTorch standard attention, depending on sequence length, on different GPUs (speedup depends on memory bandwidth - we see more speedup on slower GPU memory).\n\nWe currently have benchmarks for these GPUs:\n* [A100](#a100)\n* [H100](#h100)\n<!-- * [RTX 3090](#rtx-3090) -->\n<!-- * [T4](#t4) -->\n\n### A100\n\nWe display FlashAttention speedup using these parameters:\n* Head dimension 64 or 128, hidden dimension 2048 (i.e. either 32 or 16 heads).\n* Sequence length 512, 1k, 2k, 4k, 8k, 16k.\n* Batch size set to 16k / seqlen.\n\n#### Speedup\n\n![FlashAttention speedup on A100 80GB SXM5 with FP16/BF16](assets/flash2_a100_fwd_bwd_benchmark.png)\n\n#### Memory\n\n![FlashAttention memory](assets/flashattn_memory.jpg)\n\nWe show memory savings in this graph (note that memory footprint is the same no matter if you use dropout or masking).\nMemory savings are proportional to sequence length -- since standard attention has memory quadratic in sequence length, whereas FlashAttention has memory linear in sequence length.\nWe see 10X memory savings at sequence length 2K, and 20X at 4K.\nAs a result, FlashAttention can scale to much longer sequence lengths.\n\n### H100\n\n![FlashAttention speedup on H100 SXM5 with FP16/BF16](assets/flash2_h100_fwd_bwd_benchmark.png)\n\n## Full model code and training script\n\nWe have released the full GPT model\n[implementation](https://github.com/Dao-AILab/flash-attention/blob/main/flash_attn/models/gpt.py).\nWe also provide optimized implementations of other layers (e.g., MLP, LayerNorm,\ncross-entropy loss, rotary embedding). Overall this speeds up training by 3-5x\ncompared to the baseline implementation from Huggingface, reaching up to 225\nTFLOPs/sec per A100, equivalent to 72% model FLOPs utilization (we don't need\nany activation checkpointing).\n\nWe also include a training\n[script](https://github.com/Dao-AILab/flash-attention/tree/main/training) to\ntrain GPT2 on Openwebtext and GPT3 on The Pile.\n\n## Triton implementation of FlashAttention\n\nPhil Tillet (OpenAI) has an experimental implementation of FlashAttention in Triton:\nhttps://github.com/openai/triton/blob/master/python/tutorials/06-fused-attention.py\n\nAs Triton is a higher-level language than CUDA, it might be easier to understand\nand experiment with. The notations in the Triton implementation are also closer\nto what's used in our paper.\n\nWe also have an experimental implementation in Triton that support attention\nbias (e.g. ALiBi):\nhttps://github.com/Dao-AILab/flash-attention/blob/main/flash_attn/flash_attn_triton.py\n\n\n## Tests\nWe test that FlashAttention produces the same output and gradient as a reference\nimplementation, up to some numerical tolerance. In particular, we check that the\nmaximum numerical error of FlashAttention is at most twice the numerical error\nof a baseline implementation in Pytorch (for different head dimensions, input\ndtype, sequence length, causal / non-causal).\n\nTo run the tests:\n```sh\npytest -q -s tests/test_flash_attn.py\n```\n## When you encounter issues\n\nThis new release of FlashAttention-2 has been tested on several GPT-style\nmodels, mostly on A100 GPUs.\n\nIf you encounter bugs, please open a GitHub Issue!\n\n## Tests\nTo run the tests:\n```sh\npytest tests/test_flash_attn_ck.py\n```\n\n## Citation\nIf you use this codebase, or otherwise found our work valuable, please cite:\n```\n@inproceedings{dao2022flashattention,\n  title={Flash{A}ttention: Fast and Memory-Efficient Exact Attention with {IO}-Awareness},\n  author={Dao, Tri and Fu, Daniel Y. and Ermon, Stefano and Rudra, Atri and R{\\'e}, Christopher},\n  booktitle={Advances in Neural Information Processing Systems (NeurIPS)},\n  year={2022}\n}\n@inproceedings{dao2023flashattention2,\n  title={Flash{A}ttention-2: Faster Attention with Better Parallelism and Work Partitioning},\n  author={Dao, Tri},\n  booktitle={International Conference on Learning Representations (ICLR)},\n  year={2024}\n}\n```\n"
        },
        {
          "name": "assets",
          "type": "tree",
          "content": null
        },
        {
          "name": "benchmarks",
          "type": "tree",
          "content": null
        },
        {
          "name": "csrc",
          "type": "tree",
          "content": null
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "flash_attn",
          "type": "tree",
          "content": null
        },
        {
          "name": "hopper",
          "type": "tree",
          "content": null
        },
        {
          "name": "setup.py",
          "type": "blob",
          "size": 24.60546875,
          "content": "# Copyright (c) 2023, Tri Dao.\n\nimport sys\nimport functools\nimport warnings\nimport os\nimport re\nimport ast\nimport glob\nimport shutil\nfrom pathlib import Path\nfrom packaging.version import parse, Version\nimport platform\n\nfrom setuptools import setup, find_packages\nimport subprocess\n\nimport urllib.request\nimport urllib.error\nfrom wheel.bdist_wheel import bdist_wheel as _bdist_wheel\n\nimport torch\nfrom torch.utils.cpp_extension import (\n    BuildExtension,\n    CppExtension,\n    CUDAExtension,\n    CUDA_HOME,\n    ROCM_HOME,\n    IS_HIP_EXTENSION,\n)\n\n\nwith open(\"README.md\", \"r\", encoding=\"utf-8\") as fh:\n    long_description = fh.read()\n\n\n# ninja build does not work unless include_dirs are abs path\nthis_dir = os.path.dirname(os.path.abspath(__file__))\n\nBUILD_TARGET = os.environ.get(\"BUILD_TARGET\", \"auto\")\n\nif BUILD_TARGET == \"auto\":\n    if IS_HIP_EXTENSION:\n        IS_ROCM = True\n    else:\n        IS_ROCM = False\nelse:\n    if BUILD_TARGET == \"cuda\":\n        IS_ROCM = False\n    elif BUILD_TARGET == \"rocm\":\n        IS_ROCM = True\n\nPACKAGE_NAME = \"flash_attn\"\n\nBASE_WHEEL_URL = (\n    \"https://github.com/Dao-AILab/flash-attention/releases/download/{tag_name}/{wheel_name}\"\n)\n\n# FORCE_BUILD: Force a fresh build locally, instead of attempting to find prebuilt wheels\n# SKIP_CUDA_BUILD: Intended to allow CI to use a simple `python setup.py sdist` run to copy over raw files, without any cuda compilation\nFORCE_BUILD = os.getenv(\"FLASH_ATTENTION_FORCE_BUILD\", \"FALSE\") == \"TRUE\"\nSKIP_CUDA_BUILD = os.getenv(\"FLASH_ATTENTION_SKIP_CUDA_BUILD\", \"FALSE\") == \"TRUE\"\n# For CI, we want the option to build with C++11 ABI since the nvcr images use C++11 ABI\nFORCE_CXX11_ABI = os.getenv(\"FLASH_ATTENTION_FORCE_CXX11_ABI\", \"FALSE\") == \"TRUE\"\nUSE_TRITON_ROCM = os.getenv(\"FLASH_ATTENTION_TRITON_AMD_ENABLE\", \"FALSE\") == \"TRUE\"\n\n\n@functools.lru_cache(maxsize=None)\ndef cuda_archs() -> str:\n    return os.getenv(\"FLASH_ATTN_CUDA_ARCHS\", \"80;90;100;120\").split(\";\")\n\n\ndef get_platform():\n    \"\"\"\n    Returns the platform name as used in wheel filenames.\n    \"\"\"\n    if sys.platform.startswith(\"linux\"):\n        return f'linux_{platform.uname().machine}'\n    elif sys.platform == \"darwin\":\n        mac_version = \".\".join(platform.mac_ver()[0].split(\".\")[:2])\n        return f\"macosx_{mac_version}_x86_64\"\n    elif sys.platform == \"win32\":\n        return \"win_amd64\"\n    else:\n        raise ValueError(\"Unsupported platform: {}\".format(sys.platform))\n\n\ndef get_cuda_bare_metal_version(cuda_dir):\n    raw_output = subprocess.check_output([cuda_dir + \"/bin/nvcc\", \"-V\"], universal_newlines=True)\n    output = raw_output.split()\n    release_idx = output.index(\"release\") + 1\n    bare_metal_version = parse(output[release_idx].split(\",\")[0])\n\n    return raw_output, bare_metal_version\n\n\ndef get_hip_version():\n    return parse(torch.version.hip.split()[-1].rstrip('-').replace('-', '+'))\n\n\ndef check_if_cuda_home_none(global_option: str) -> None:\n    if CUDA_HOME is not None:\n        return\n    # warn instead of error because user could be downloading prebuilt wheels, so nvcc won't be necessary\n    # in that case.\n    warnings.warn(\n        f\"{global_option} was requested, but nvcc was not found.  Are you sure your environment has nvcc available?  \"\n        \"If you're installing within a container from https://hub.docker.com/r/pytorch/pytorch, \"\n        \"only images whose names contain 'devel' will provide nvcc.\"\n    )\n\n\ndef check_if_rocm_home_none(global_option: str) -> None:\n    if ROCM_HOME is not None:\n        return\n    # warn instead of error because user could be downloading prebuilt wheels, so hipcc won't be necessary\n    # in that case.\n    warnings.warn(\n        f\"{global_option} was requested, but hipcc was not found.\"\n    )\n\n\ndef append_nvcc_threads(nvcc_extra_args):\n    nvcc_threads = os.getenv(\"NVCC_THREADS\") or \"2\"\n    return nvcc_extra_args + [\"--threads\", nvcc_threads]\n\n\ndef rename_cpp_to_cu(cpp_files):\n    for entry in cpp_files:\n        shutil.copy(entry, os.path.splitext(entry)[0] + \".cu\")\n\n\ndef validate_and_update_archs(archs):\n    # List of allowed architectures\n    allowed_archs = [\"native\", \"gfx90a\", \"gfx940\", \"gfx941\", \"gfx942\"]\n\n    # Validate if each element in archs is in allowed_archs\n    assert all(\n        arch in allowed_archs for arch in archs\n    ), f\"One of GPU archs of {archs} is invalid or not supported by Flash-Attention\"\n\n\ncmdclass = {}\next_modules = []\n\n# We want this even if SKIP_CUDA_BUILD because when we run python setup.py sdist we want the .hpp\n# files included in the source distribution, in case the user compiles from source.\nif IS_ROCM:\n    if not USE_TRITON_ROCM:\n        subprocess.run([\"git\", \"submodule\", \"update\", \"--init\", \"csrc/composable_kernel\"])\nelse:\n    subprocess.run([\"git\", \"submodule\", \"update\", \"--init\", \"csrc/cutlass\"])\n\nif not SKIP_CUDA_BUILD and not IS_ROCM:\n    print(\"\\n\\ntorch.__version__  = {}\\n\\n\".format(torch.__version__))\n    TORCH_MAJOR = int(torch.__version__.split(\".\")[0])\n    TORCH_MINOR = int(torch.__version__.split(\".\")[1])\n\n    check_if_cuda_home_none(\"flash_attn\")\n    # Check, if CUDA11 is installed for compute capability 8.0\n    cc_flag = []\n    if CUDA_HOME is not None:\n        _, bare_metal_version = get_cuda_bare_metal_version(CUDA_HOME)\n        if bare_metal_version < Version(\"11.7\"):\n            raise RuntimeError(\n                \"FlashAttention is only supported on CUDA 11.7 and above.  \"\n                \"Note: make sure nvcc has a supported version by running nvcc -V.\"\n            )\n\n    if \"80\" in cuda_archs():\n        cc_flag.append(\"-gencode\")\n        cc_flag.append(\"arch=compute_80,code=sm_80\")\n    if CUDA_HOME is not None:\n        if bare_metal_version >= Version(\"11.8\") and \"90\" in cuda_archs():\n            cc_flag.append(\"-gencode\")\n            cc_flag.append(\"arch=compute_90,code=sm_90\")\n        if bare_metal_version >= Version(\"12.8\") and \"100\" in cuda_archs():\n            cc_flag.append(\"-gencode\")\n            cc_flag.append(\"arch=compute_100,code=sm_100\")\n        if bare_metal_version >= Version(\"12.8\") and \"120\" in cuda_archs():\n            cc_flag.append(\"-gencode\")\n            cc_flag.append(\"arch=compute_120,code=sm_120\")\n\n    # HACK: The compiler flag -D_GLIBCXX_USE_CXX11_ABI is set to be the same as\n    # torch._C._GLIBCXX_USE_CXX11_ABI\n    # https://github.com/pytorch/pytorch/blob/8472c24e3b5b60150096486616d98b7bea01500b/torch/utils/cpp_extension.py#L920\n    if FORCE_CXX11_ABI:\n        torch._C._GLIBCXX_USE_CXX11_ABI = True\n    ext_modules.append(\n        CUDAExtension(\n            name=\"flash_attn_2_cuda\",\n            sources=[\n                \"csrc/flash_attn/flash_api.cpp\",\n                \"csrc/flash_attn/src/flash_fwd_hdim32_fp16_sm80.cu\",\n                \"csrc/flash_attn/src/flash_fwd_hdim32_bf16_sm80.cu\",\n                \"csrc/flash_attn/src/flash_fwd_hdim64_fp16_sm80.cu\",\n                \"csrc/flash_attn/src/flash_fwd_hdim64_bf16_sm80.cu\",\n                \"csrc/flash_attn/src/flash_fwd_hdim96_fp16_sm80.cu\",\n                \"csrc/flash_attn/src/flash_fwd_hdim96_bf16_sm80.cu\",\n                \"csrc/flash_attn/src/flash_fwd_hdim128_fp16_sm80.cu\",\n                \"csrc/flash_attn/src/flash_fwd_hdim128_bf16_sm80.cu\",\n                \"csrc/flash_attn/src/flash_fwd_hdim160_fp16_sm80.cu\",\n                \"csrc/flash_attn/src/flash_fwd_hdim160_bf16_sm80.cu\",\n                \"csrc/flash_attn/src/flash_fwd_hdim192_fp16_sm80.cu\",\n                \"csrc/flash_attn/src/flash_fwd_hdim192_bf16_sm80.cu\",\n                \"csrc/flash_attn/src/flash_fwd_hdim256_fp16_sm80.cu\",\n                \"csrc/flash_attn/src/flash_fwd_hdim256_bf16_sm80.cu\",\n                \"csrc/flash_attn/src/flash_fwd_hdim32_fp16_causal_sm80.cu\",\n                \"csrc/flash_attn/src/flash_fwd_hdim32_bf16_causal_sm80.cu\",\n                \"csrc/flash_attn/src/flash_fwd_hdim64_fp16_causal_sm80.cu\",\n                \"csrc/flash_attn/src/flash_fwd_hdim64_bf16_causal_sm80.cu\",\n                \"csrc/flash_attn/src/flash_fwd_hdim96_fp16_causal_sm80.cu\",\n                \"csrc/flash_attn/src/flash_fwd_hdim96_bf16_causal_sm80.cu\",\n                \"csrc/flash_attn/src/flash_fwd_hdim128_fp16_causal_sm80.cu\",\n                \"csrc/flash_attn/src/flash_fwd_hdim128_bf16_causal_sm80.cu\",\n                \"csrc/flash_attn/src/flash_fwd_hdim160_fp16_causal_sm80.cu\",\n                \"csrc/flash_attn/src/flash_fwd_hdim160_bf16_causal_sm80.cu\",\n                \"csrc/flash_attn/src/flash_fwd_hdim192_fp16_causal_sm80.cu\",\n                \"csrc/flash_attn/src/flash_fwd_hdim192_bf16_causal_sm80.cu\",\n                \"csrc/flash_attn/src/flash_fwd_hdim256_fp16_causal_sm80.cu\",\n                \"csrc/flash_attn/src/flash_fwd_hdim256_bf16_causal_sm80.cu\",\n                \"csrc/flash_attn/src/flash_bwd_hdim32_fp16_sm80.cu\",\n                \"csrc/flash_attn/src/flash_bwd_hdim32_bf16_sm80.cu\",\n                \"csrc/flash_attn/src/flash_bwd_hdim64_fp16_sm80.cu\",\n                \"csrc/flash_attn/src/flash_bwd_hdim64_bf16_sm80.cu\",\n                \"csrc/flash_attn/src/flash_bwd_hdim96_fp16_sm80.cu\",\n                \"csrc/flash_attn/src/flash_bwd_hdim96_bf16_sm80.cu\",\n                \"csrc/flash_attn/src/flash_bwd_hdim128_fp16_sm80.cu\",\n                \"csrc/flash_attn/src/flash_bwd_hdim128_bf16_sm80.cu\",\n                \"csrc/flash_attn/src/flash_bwd_hdim160_fp16_sm80.cu\",\n                \"csrc/flash_attn/src/flash_bwd_hdim160_bf16_sm80.cu\",\n                \"csrc/flash_attn/src/flash_bwd_hdim192_fp16_sm80.cu\",\n                \"csrc/flash_attn/src/flash_bwd_hdim192_bf16_sm80.cu\",\n                \"csrc/flash_attn/src/flash_bwd_hdim256_fp16_sm80.cu\",\n                \"csrc/flash_attn/src/flash_bwd_hdim256_bf16_sm80.cu\",\n                \"csrc/flash_attn/src/flash_bwd_hdim32_fp16_causal_sm80.cu\",\n                \"csrc/flash_attn/src/flash_bwd_hdim32_bf16_causal_sm80.cu\",\n                \"csrc/flash_attn/src/flash_bwd_hdim64_fp16_causal_sm80.cu\",\n                \"csrc/flash_attn/src/flash_bwd_hdim64_bf16_causal_sm80.cu\",\n                \"csrc/flash_attn/src/flash_bwd_hdim96_fp16_causal_sm80.cu\",\n                \"csrc/flash_attn/src/flash_bwd_hdim96_bf16_causal_sm80.cu\",\n                \"csrc/flash_attn/src/flash_bwd_hdim128_fp16_causal_sm80.cu\",\n                \"csrc/flash_attn/src/flash_bwd_hdim128_bf16_causal_sm80.cu\",\n                \"csrc/flash_attn/src/flash_bwd_hdim160_fp16_causal_sm80.cu\",\n                \"csrc/flash_attn/src/flash_bwd_hdim160_bf16_causal_sm80.cu\",\n                \"csrc/flash_attn/src/flash_bwd_hdim192_fp16_causal_sm80.cu\",\n                \"csrc/flash_attn/src/flash_bwd_hdim192_bf16_causal_sm80.cu\",\n                \"csrc/flash_attn/src/flash_bwd_hdim256_fp16_causal_sm80.cu\",\n                \"csrc/flash_attn/src/flash_bwd_hdim256_bf16_causal_sm80.cu\",\n                \"csrc/flash_attn/src/flash_fwd_split_hdim32_fp16_sm80.cu\",\n                \"csrc/flash_attn/src/flash_fwd_split_hdim32_bf16_sm80.cu\",\n                \"csrc/flash_attn/src/flash_fwd_split_hdim64_fp16_sm80.cu\",\n                \"csrc/flash_attn/src/flash_fwd_split_hdim64_bf16_sm80.cu\",\n                \"csrc/flash_attn/src/flash_fwd_split_hdim96_fp16_sm80.cu\",\n                \"csrc/flash_attn/src/flash_fwd_split_hdim96_bf16_sm80.cu\",\n                \"csrc/flash_attn/src/flash_fwd_split_hdim128_fp16_sm80.cu\",\n                \"csrc/flash_attn/src/flash_fwd_split_hdim128_bf16_sm80.cu\",\n                \"csrc/flash_attn/src/flash_fwd_split_hdim160_fp16_sm80.cu\",\n                \"csrc/flash_attn/src/flash_fwd_split_hdim160_bf16_sm80.cu\",\n                \"csrc/flash_attn/src/flash_fwd_split_hdim192_fp16_sm80.cu\",\n                \"csrc/flash_attn/src/flash_fwd_split_hdim192_bf16_sm80.cu\",\n                \"csrc/flash_attn/src/flash_fwd_split_hdim256_fp16_sm80.cu\",\n                \"csrc/flash_attn/src/flash_fwd_split_hdim256_bf16_sm80.cu\",\n                \"csrc/flash_attn/src/flash_fwd_split_hdim32_fp16_causal_sm80.cu\",\n                \"csrc/flash_attn/src/flash_fwd_split_hdim32_bf16_causal_sm80.cu\",\n                \"csrc/flash_attn/src/flash_fwd_split_hdim64_fp16_causal_sm80.cu\",\n                \"csrc/flash_attn/src/flash_fwd_split_hdim64_bf16_causal_sm80.cu\",\n                \"csrc/flash_attn/src/flash_fwd_split_hdim96_fp16_causal_sm80.cu\",\n                \"csrc/flash_attn/src/flash_fwd_split_hdim96_bf16_causal_sm80.cu\",\n                \"csrc/flash_attn/src/flash_fwd_split_hdim128_fp16_causal_sm80.cu\",\n                \"csrc/flash_attn/src/flash_fwd_split_hdim128_bf16_causal_sm80.cu\",\n                \"csrc/flash_attn/src/flash_fwd_split_hdim160_fp16_causal_sm80.cu\",\n                \"csrc/flash_attn/src/flash_fwd_split_hdim160_bf16_causal_sm80.cu\",\n                \"csrc/flash_attn/src/flash_fwd_split_hdim192_fp16_causal_sm80.cu\",\n                \"csrc/flash_attn/src/flash_fwd_split_hdim192_bf16_causal_sm80.cu\",\n                \"csrc/flash_attn/src/flash_fwd_split_hdim256_fp16_causal_sm80.cu\",\n                \"csrc/flash_attn/src/flash_fwd_split_hdim256_bf16_causal_sm80.cu\",\n            ],\n            extra_compile_args={\n                \"cxx\": [\"-O3\", \"-std=c++17\"],\n                \"nvcc\": append_nvcc_threads(\n                    [\n                        \"-O3\",\n                        \"-std=c++17\",\n                        \"-U__CUDA_NO_HALF_OPERATORS__\",\n                        \"-U__CUDA_NO_HALF_CONVERSIONS__\",\n                        \"-U__CUDA_NO_HALF2_OPERATORS__\",\n                        \"-U__CUDA_NO_BFLOAT16_CONVERSIONS__\",\n                        \"--expt-relaxed-constexpr\",\n                        \"--expt-extended-lambda\",\n                        \"--use_fast_math\",\n                        # \"--ptxas-options=-v\",\n                        # \"--ptxas-options=-O2\",\n                        # \"-lineinfo\",\n                        # \"-DFLASHATTENTION_DISABLE_BACKWARD\",\n                        # \"-DFLASHATTENTION_DISABLE_DROPOUT\",\n                        # \"-DFLASHATTENTION_DISABLE_ALIBI\",\n                        # \"-DFLASHATTENTION_DISABLE_SOFTCAP\",\n                        # \"-DFLASHATTENTION_DISABLE_UNEVEN_K\",\n                        # \"-DFLASHATTENTION_DISABLE_LOCAL\",\n                    ]\n                    + cc_flag\n                ),\n            },\n            include_dirs=[\n                Path(this_dir) / \"csrc\" / \"flash_attn\",\n                Path(this_dir) / \"csrc\" / \"flash_attn\" / \"src\",\n                Path(this_dir) / \"csrc\" / \"cutlass\" / \"include\",\n            ],\n        )\n    )\nelif not SKIP_CUDA_BUILD and IS_ROCM:\n    print(\"\\n\\ntorch.__version__  = {}\\n\\n\".format(torch.__version__))\n    TORCH_MAJOR = int(torch.__version__.split(\".\")[0])\n    TORCH_MINOR = int(torch.__version__.split(\".\")[1])\n\n    if USE_TRITON_ROCM:\n        # Skip C++ extension compilation if using Triton Backend\n        pass\n    else:\n        ck_dir = \"csrc/composable_kernel\"\n\n        #use codegen get code dispatch\n        if not os.path.exists(\"./build\"):\n            os.makedirs(\"build\")\n\n        os.system(f\"{sys.executable} {ck_dir}/example/ck_tile/01_fmha/generate.py -d fwd --output_dir build --receipt 2\")\n        os.system(f\"{sys.executable} {ck_dir}/example/ck_tile/01_fmha/generate.py -d fwd_appendkv --output_dir build --receipt 2\")\n        os.system(f\"{sys.executable} {ck_dir}/example/ck_tile/01_fmha/generate.py -d fwd_splitkv --output_dir build --receipt 2\")\n        os.system(f\"{sys.executable} {ck_dir}/example/ck_tile/01_fmha/generate.py -d bwd --output_dir build --receipt 2\")\n\n        # Check, if ATen/CUDAGeneratorImpl.h is found, otherwise use ATen/cuda/CUDAGeneratorImpl.h\n        # See https://github.com/pytorch/pytorch/pull/70650\n        generator_flag = []\n        torch_dir = torch.__path__[0]\n        if os.path.exists(os.path.join(torch_dir, \"include\", \"ATen\", \"CUDAGeneratorImpl.h\")):\n            generator_flag = [\"-DOLD_GENERATOR_PATH\"]\n\n        check_if_rocm_home_none(\"flash_attn\")\n        archs = os.getenv(\"GPU_ARCHS\", \"native\").split(\";\")\n        validate_and_update_archs(archs)\n\n        cc_flag = [f\"--offload-arch={arch}\" for arch in archs]\n\n        # HACK: The compiler flag -D_GLIBCXX_USE_CXX11_ABI is set to be the same as\n        # torch._C._GLIBCXX_USE_CXX11_ABI\n        # https://github.com/pytorch/pytorch/blob/8472c24e3b5b60150096486616d98b7bea01500b/torch/utils/cpp_extension.py#L920\n        if FORCE_CXX11_ABI:\n            torch._C._GLIBCXX_USE_CXX11_ABI = True\n\n        sources = [\"csrc/flash_attn_ck/flash_api.cpp\",\n                \"csrc/flash_attn_ck/flash_common.cpp\",\n                \"csrc/flash_attn_ck/mha_bwd.cpp\",\n                \"csrc/flash_attn_ck/mha_fwd_kvcache.cpp\",\n                \"csrc/flash_attn_ck/mha_fwd.cpp\",\n                \"csrc/flash_attn_ck/mha_varlen_bwd.cpp\",\n                \"csrc/flash_attn_ck/mha_varlen_fwd.cpp\"] + glob.glob(\n            f\"build/fmha_*wd*.cpp\"\n        )\n\n        rename_cpp_to_cu(sources)\n\n        renamed_sources = [\"csrc/flash_attn_ck/flash_api.cu\",\n                        \"csrc/flash_attn_ck/flash_common.cu\",\n                        \"csrc/flash_attn_ck/mha_bwd.cu\",\n                        \"csrc/flash_attn_ck/mha_fwd_kvcache.cu\",\n                        \"csrc/flash_attn_ck/mha_fwd.cu\",\n                        \"csrc/flash_attn_ck/mha_varlen_bwd.cu\",\n                        \"csrc/flash_attn_ck/mha_varlen_fwd.cu\"] + glob.glob(f\"build/fmha_*wd*.cu\")\n\n        cc_flag += [\"-O3\",\"-std=c++17\",\n                    \"-DCK_TILE_FMHA_FWD_FAST_EXP2=1\",\n                    \"-fgpu-flush-denormals-to-zero\",\n                    \"-DCK_ENABLE_BF16\",\n                    \"-DCK_ENABLE_BF8\",\n                    \"-DCK_ENABLE_FP16\",\n                    \"-DCK_ENABLE_FP32\",\n                    \"-DCK_ENABLE_FP64\",\n                    \"-DCK_ENABLE_FP8\",\n                    \"-DCK_ENABLE_INT8\",\n                    \"-DCK_USE_XDL\",\n                    \"-DUSE_PROF_API=1\",\n                    # \"-DFLASHATTENTION_DISABLE_BACKWARD\",\n                    \"-D__HIP_PLATFORM_HCC__=1\"]\n\n        cc_flag += [f\"-DCK_TILE_FLOAT_TO_BFLOAT16_DEFAULT={os.environ.get('CK_TILE_FLOAT_TO_BFLOAT16_DEFAULT', 3)}\"]\n\n        # Imitate https://github.com/ROCm/composable_kernel/blob/c8b6b64240e840a7decf76dfaa13c37da5294c4a/CMakeLists.txt#L190-L214\n        hip_version = get_hip_version()\n        if hip_version > Version('5.7.23302'):\n            cc_flag += [\"-fno-offload-uniform-block\"]\n        if hip_version > Version('6.1.40090'):\n            cc_flag += [\"-mllvm\", \"-enable-post-misched=0\"]\n        if hip_version > Version('6.2.41132'):\n            cc_flag += [\"-mllvm\", \"-amdgpu-early-inline-all=true\",\n                        \"-mllvm\", \"-amdgpu-function-calls=false\"]\n        if hip_version > Version('6.2.41133') and hip_version < Version('6.3.00000'):\n            cc_flag += [\"-mllvm\", \"-amdgpu-coerce-illegal-types=1\"]\n\n        extra_compile_args = {\n            \"cxx\": [\"-O3\", \"-std=c++17\"] + generator_flag,\n            \"nvcc\": cc_flag + generator_flag,\n        }\n\n        include_dirs = [\n            Path(this_dir) / \"csrc\" / \"composable_kernel\" / \"include\",\n            Path(this_dir) / \"csrc\" / \"composable_kernel\" / \"library\" / \"include\",\n            Path(this_dir) / \"csrc\" / \"composable_kernel\" / \"example\" / \"ck_tile\" / \"01_fmha\",\n        ]\n\n        ext_modules.append(\n            CUDAExtension(\n                name=\"flash_attn_2_cuda\",\n                sources=renamed_sources,\n                extra_compile_args=extra_compile_args,\n                include_dirs=include_dirs,\n            )\n        )\n\n\ndef get_package_version():\n    with open(Path(this_dir) / \"flash_attn\" / \"__init__.py\", \"r\") as f:\n        version_match = re.search(r\"^__version__\\s*=\\s*(.*)$\", f.read(), re.MULTILINE)\n    public_version = ast.literal_eval(version_match.group(1))\n    local_version = os.environ.get(\"FLASH_ATTN_LOCAL_VERSION\")\n    if local_version:\n        return f\"{public_version}+{local_version}\"\n    else:\n        return str(public_version)\n\n\ndef get_wheel_url():\n    torch_version_raw = parse(torch.__version__)\n    python_version = f\"cp{sys.version_info.major}{sys.version_info.minor}\"\n    platform_name = get_platform()\n    flash_version = get_package_version()\n    torch_version = f\"{torch_version_raw.major}.{torch_version_raw.minor}\"\n    cxx11_abi = str(torch._C._GLIBCXX_USE_CXX11_ABI).upper()\n\n    if IS_ROCM:\n        torch_hip_version = get_hip_version()\n        hip_version = f\"{torch_hip_version.major}{torch_hip_version.minor}\"\n        wheel_filename = f\"{PACKAGE_NAME}-{flash_version}+rocm{hip_version}torch{torch_version}cxx11abi{cxx11_abi}-{python_version}-{python_version}-{platform_name}.whl\"\n    else:\n        # Determine the version numbers that will be used to determine the correct wheel\n        # We're using the CUDA version used to build torch, not the one currently installed\n        # _, cuda_version_raw = get_cuda_bare_metal_version(CUDA_HOME)\n        torch_cuda_version = parse(torch.version.cuda)\n        # For CUDA 11, we only compile for CUDA 11.8, and for CUDA 12 we only compile for CUDA 12.3\n        # to save CI time. Minor versions should be compatible.\n        torch_cuda_version = parse(\"11.8\") if torch_cuda_version.major == 11 else parse(\"12.3\")\n        # cuda_version = f\"{cuda_version_raw.major}{cuda_version_raw.minor}\"\n        cuda_version = f\"{torch_cuda_version.major}\"\n\n        # Determine wheel URL based on CUDA version, torch version, python version and OS\n        wheel_filename = f\"{PACKAGE_NAME}-{flash_version}+cu{cuda_version}torch{torch_version}cxx11abi{cxx11_abi}-{python_version}-{python_version}-{platform_name}.whl\"\n\n    wheel_url = BASE_WHEEL_URL.format(tag_name=f\"v{flash_version}\", wheel_name=wheel_filename)\n\n    return wheel_url, wheel_filename\n\n\nclass CachedWheelsCommand(_bdist_wheel):\n    \"\"\"\n    The CachedWheelsCommand plugs into the default bdist wheel, which is ran by pip when it cannot\n    find an existing wheel (which is currently the case for all flash attention installs). We use\n    the environment parameters to detect whether there is already a pre-built version of a compatible\n    wheel available and short-circuits the standard full build pipeline.\n    \"\"\"\n\n    def run(self):\n        if FORCE_BUILD:\n            return super().run()\n\n        wheel_url, wheel_filename = get_wheel_url()\n        print(\"Guessing wheel URL: \", wheel_url)\n        try:\n            urllib.request.urlretrieve(wheel_url, wheel_filename)\n\n            # Make the archive\n            # Lifted from the root wheel processing command\n            # https://github.com/pypa/wheel/blob/cf71108ff9f6ffc36978069acb28824b44ae028e/src/wheel/bdist_wheel.py#LL381C9-L381C85\n            if not os.path.exists(self.dist_dir):\n                os.makedirs(self.dist_dir)\n\n            impl_tag, abi_tag, plat_tag = self.get_tag()\n            archive_basename = f\"{self.wheel_dist_name}-{impl_tag}-{abi_tag}-{plat_tag}\"\n\n            wheel_path = os.path.join(self.dist_dir, archive_basename + \".whl\")\n            print(\"Raw wheel path\", wheel_path)\n            os.rename(wheel_filename, wheel_path)\n        except (urllib.error.HTTPError, urllib.error.URLError):\n            print(\"Precompiled wheel not found. Building from source...\")\n            # If the wheel could not be downloaded, build from source\n            super().run()\n\n\nclass NinjaBuildExtension(BuildExtension):\n    def __init__(self, *args, **kwargs) -> None:\n        # do not override env MAX_JOBS if already exists\n        if not os.environ.get(\"MAX_JOBS\"):\n            import psutil\n\n            # calculate the maximum allowed NUM_JOBS based on cores\n            max_num_jobs_cores = max(1, os.cpu_count() // 2)\n\n            # calculate the maximum allowed NUM_JOBS based on free memory\n            free_memory_gb = psutil.virtual_memory().available / (1024 ** 3)  # free memory in GB\n            max_num_jobs_memory = int(free_memory_gb / 9)  # each JOB peak memory cost is ~8-9GB when threads = 4\n\n            # pick lower value of jobs based on cores vs memory metric to minimize oom and swap usage during compilation\n            max_jobs = max(1, min(max_num_jobs_cores, max_num_jobs_memory))\n            os.environ[\"MAX_JOBS\"] = str(max_jobs)\n\n        super().__init__(*args, **kwargs)\n\n\nsetup(\n    name=PACKAGE_NAME,\n    version=get_package_version(),\n    packages=find_packages(\n        exclude=(\n            \"build\",\n            \"csrc\",\n            \"include\",\n            \"tests\",\n            \"dist\",\n            \"docs\",\n            \"benchmarks\",\n            \"flash_attn.egg-info\",\n        )\n    ),\n    author=\"Tri Dao\",\n    author_email=\"tri@tridao.me\",\n    description=\"Flash Attention: Fast and Memory-Efficient Exact Attention\",\n    long_description=long_description,\n    long_description_content_type=\"text/markdown\",\n    url=\"https://github.com/Dao-AILab/flash-attention\",\n    classifiers=[\n        \"Programming Language :: Python :: 3\",\n        \"License :: OSI Approved :: BSD License\",\n        \"Operating System :: Unix\",\n    ],\n    ext_modules=ext_modules,\n    cmdclass={\"bdist_wheel\": CachedWheelsCommand, \"build_ext\": NinjaBuildExtension}\n    if ext_modules\n    else {\n        \"bdist_wheel\": CachedWheelsCommand,\n    },\n    python_requires=\">=3.9\",\n    install_requires=[\n        \"torch\",\n        \"einops\",\n    ],\n    setup_requires=[\n        \"packaging\",\n        \"psutil\",\n        \"ninja\",\n    ],\n)\n"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "training",
          "type": "tree",
          "content": null
        },
        {
          "name": "usage.md",
          "type": "blob",
          "size": 6.8876953125,
          "content": "# FlashAttention adoption\n\nWe've been very happy to see FlashAttention being adopted by many organizations\nand research labs to speed up their training / inference (within 6 months after\nFlashAttention's release, at the time of writing).\nThis page contains a partial list of places where FlashAttention is being used.\nIf you'd like to add links to your organization / product / codebase, please open a\nPR or email us. We'd very much like to hear from you!\n\n## Integrated into machine learning frameworks\n\n- Pytorch: [integrated](https://github.com/pytorch/pytorch/pull/81434) into core Pytorch in nn.Transformer.\n\n- Huggingface's [transformers](https://github.com/huggingface/transformers) library.\n  [On-going](https://github.com/huggingface/transformers/pull/18439), blogpost\n  coming soon.\n\n- Microsoft's [DeepSpeed](https://github.com/microsoft/DeepSpeed):\n  FlashAttention is [integrated](https://github.com/microsoft/DeepSpeed/blob/ec13da6ba7cabc44bb4745a64a208b8580792954/deepspeed/ops/transformer/inference/triton_ops.py) into DeepSpeed's inference engine.\n\n- Nvidia's [Megatron-LM](https://github.com/NVIDIA/Megatron-LM/pull/267). This\n  library is a popular framework on training large transformer language models at scale.\n\n- MosaicML [Composer](https://github.com/mosaicml/composer)\n  [library](https://www.mosaicml.com/blog/gpt-3-quality-for-500k). Composer is a\n  library for efficient neural network training.\n  \n- EleutherAI's [GPT-NeoX](https://github.com/EleutherAI/gpt-neox/pull/725). This is a research library for training large language transformer models at scale based on NVIDIA's Megatron-LM and Microsoft's DeepSpeed.\n\n- PaddlePaddle: integrated into the framework with [API](https://github.com/PaddlePaddle/Paddle/blob/develop/python/paddle/nn/functional/flash_attention.py) `paddle.nn.functional.flash_attention`.\n\n## MLPerf benchmarks\n\n[MLPerf](https://mlcommons.org/en/) is a competitive machine learning performance benchmark. FlashAttention\nyields the fastest BERT training on cloud instances in MLPerf training 2.0 (June\n2022) and MLPerf training 2.1 (November 2022).\n\n- MLPerf 2.0: [IEEE Spectrum](https://spectrum.ieee.org/mlperf-rankings-2022) and [Forbes](ttps://www.forbes.com/sites/moorinsights/2022/07/12/google-dethrones-nvidia-in-latest-artificial-intelligence-benchmarking-tests/) articles about our submission to the MLPerf 2.0 benchmark using FlashAttention.\n\n- MLPerf 2.1 -\n  collaboration\n  between [Azure and Hazy Research](https://techcommunity.microsoft.com/t5/azure-high-performance-computing/azure-collaborates-with-hazy-research-and-nvidia-to-achieve/ba-p/3667511): for the first time, we can train MLPerf BERT\n  in under 2 minutes on 16 nodes.\n\n- MLPerf 2.1 -\n  [Nvidia](https://developer.nvidia.com/blog/leading-mlperf-training-2-1-with-full-stack-optimizations-for-ai/):\n  Nvidia uses techniques from FlashAttention to make their (already extremely optimized) BERT\n  implementation go even faster.\n\n- MLPerf 2.1 - [MosaicML](https://www.mosaicml.com/blog/mlperf-nlp-nov2022): FlashAttention\n  helps train BERT 2.7x faster in the open division.\n\n## Language model training & inference\n\n- [PubMedGPT 2.7B](https://crfm.stanford.edu/2022/12/15/pubmedgpt.html), a\n  domain-specific LLM for biomedicine, by Stanford CRFM, trained on\n  [MosaicML](https://www.mosaicml.com/blog/introducing-pubmed-gpt) Cloud. Just\n  using FlashAttention nearly halves the total training time.\n\n- Meta's\n  [AITemplate](https://ai.facebook.com/blog/gpu-inference-engine-nvidia-amd-open-source/)\n  uses FlashAttention as part of their approach to speed up Transformer\n  inference (up to 5.3x on BERT).\n\n- Nvidia's [FasterTransformer](https://github.com/NVIDIA/FasterTransformer) is a\n  state-of-the-art Transformer inference library. As of version\n  [5.2](https://github.com/NVIDIA/FasterTransformer/commit/b672f49e256ba7a2d4fc9691d270b60b7fc1a2ff),\n  FlashAttention is used as a component of FasterTransformer to speed up GPT inference.\n\n- [Kernl](https://github.com/ELS-RD/kernl) is a library for fast Transformer\n  inference. They use FlashAttention as part of their\n  [approach](https://twitter.com/pommedeterre33/status/1585284221014245377) to\n  speed up Transformers by up to 12x.\n\n## Diffusion model training and inference\n\n- Huggingface's [diffusers](https://github.com/huggingface/diffusers) library\n  for diffusion models. FlashAttention is integrated into [diffusers\n  v0.7.0](https://github.com/huggingface/diffusers/releases/tag/v0.7.0).\n  Up to 2x faster inference and lower memory usage.\n\n- Colossal-AI's\n  [implementation](https://github.com/hpcaitech/ColossalAI/tree/main/examples/images/diffusion)\n  of Stable Diffusion: with FlashAttention as one of its components, it speeds up\n  pretraining by up to 6.5x, and reduces the hardware cost of fine-tuning by 7x.\n\n- Meta's\n  [AITemplate](https://ai.facebook.com/blog/gpu-inference-engine-nvidia-amd-open-source/)\n  with FlashAttention one of the components, is currently the [fastest](https://twitter.com/bing_xu_/status/1590447334055632897) Stable\n  Diffusion inference engine that we know of.\n\n- Stable Diffusion inference from\n  [Labml.ai](https://twitter.com/labmlai/status/1573634095732490240): 50% speedup.\n\n- Our own Stable Diffusion [fork](https://twitter.com/realDanFu/status/1580641495991754752) uses FlashAttention to get 3-4x speedup compared\n  to the original version.\n\n## Other models\n\n- [Uni-Fold](https://github.com/dptech-corp/Uni-Fold): Uni-Fold is an\n  open-source platform for developing protein models beyond AlphaFold. With\n  FlashAttention, Uni-Fold is 2.6x\n  [faster](https://twitter.com/guolin_ke/status/1580532071901995008) than AlphaFold.\n\n- [OpenFold](https://github.com/aqlaboratory/openfold): a trainable,\n  memory-efficient, and GPU-friendly PyTorch reproduction of AlphaFold 2. With\n  FlashAttention as one of its\n  [components](https://twitter.com/gahdritz/status/1595420944880779266), it is\n  up to 3x faster than AlphaFold2 to run inference on short sequences, and can\n  predict 2x longer structures.\n\n## Different implementations\n\n- [Triton](https://github.com/openai/triton): an [implementation](https://github.com/openai/triton/blob/master/python/tutorials/06-fused-attention.py) of\n  FlashAttention in Triton by Phil Tillet from OpenAI. Triton is a Python-based\n  language and compiler for parallel programming.\n\n- [xformers](https://github.com/facebookresearch/xformers): The xformers team\n  has implemented [memory-efficient\n  attention](https://twitter.com/fvsmassa/status/1580229170629849089) in a\n  similar spirit to FlashAttention.\n  xformers dynamically dispatches to whichever implementation is available / faster.\n\n- [Jax](https://github.com/google/jax): an [implementation](https://github.com/lucidrains/flash-attention-jax)\n  in Jax by [lucidrains](https://github.com/lucidrains/).\n\n- [Metal](https://developer.apple.com/metal): an [implementation](https://github.com/philipturner/metal-flash-attention) in Metal by Philip Turner. This ports FlashAttention to mobile GPU architectures such as Apple silicon.\n"
        }
      ]
    }
  ]
}