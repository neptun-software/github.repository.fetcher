{
  "metadata": {
    "timestamp": 1736561278837,
    "page": 272,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjI4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "HKUDS/LightRAG",
      "stars": 12696,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".DS_Store",
          "type": "blob",
          "size": 8.00390625,
          "content": null
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.23046875,
          "content": "__pycache__\n*.egg-info\ndickens/\nbook.txt\nlightrag-dev/\n.idea/\ndist/\nenv/\nlocal_neo4jWorkDir/\nneo4jWorkDir/\nignore_this.txt\n.venv/\n*.ignore.*\n.ruff_cache/\ngui/\n*.log\n.vscode\ninputs\nrag_storage\n.env\nvenv/\nexamples/input/\nexamples/output/\n"
        },
        {
          "name": ".pre-commit-config.yaml",
          "type": "blob",
          "size": 0.45703125,
          "content": "repos:\n  - repo: https://github.com/pre-commit/pre-commit-hooks\n    rev: v5.0.0\n    hooks:\n      - id: trailing-whitespace\n      - id: end-of-file-fixer\n      - id: requirements-txt-fixer\n\n\n  - repo: https://github.com/astral-sh/ruff-pre-commit\n    rev: v0.6.4\n    hooks:\n      - id: ruff-format\n      - id: ruff\n        args: [--fix]\n\n\n  - repo: https://github.com/mgedmin/check-manifest\n    rev: \"0.49\"\n    hooks:\n      - id: check-manifest\n        stages: [manual]\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0380859375,
          "content": "MIT License\n\nCopyright (c) 2025 LarFii\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 67.6630859375,
          "content": "<center><h2>ðŸš€ LightRAG: Simple and Fast Retrieval-Augmented Generation</h2></center>\n\n\n![LightRAG Image](https://i-blog.csdnimg.cn/direct/567139f1a36e4564abc63ce5c12b6271.jpeg)\n\n<div align='center'>\n     <p>\n        <a href='https://lightrag.github.io'><img src='https://img.shields.io/badge/Project-Page-Green'></a>\n        <a href='https://youtu.be/oageL-1I0GE'><img src='https://badges.aleen42.com/src/youtube.svg'></a>\n        <a href='https://arxiv.org/abs/2410.05779'><img src='https://img.shields.io/badge/arXiv-2410.05779-b31b1b'></a>\n        <a href='https://learnopencv.com/lightrag'><img src='https://img.shields.io/badge/LearnOpenCV-blue'></a>\n    </p>\n     <p>\n          <img src='https://img.shields.io/github/stars/hkuds/lightrag?color=green&style=social' />\n        <img src=\"https://img.shields.io/badge/python-3.10-blue\">\n        <a href=\"https://pypi.org/project/lightrag-hku/\"><img src=\"https://img.shields.io/pypi/v/lightrag-hku.svg\"></a>\n        <a href=\"https://pepy.tech/project/lightrag-hku\"><img src=\"https://static.pepy.tech/badge/lightrag-hku/month\"></a>\n    </p>\n    <p>\n    <a href='https://discord.gg/yF2MmDJyGJ'><img src='https://discordapp.com/api/guilds/1296348098003734629/widget.png?style=shield'></a>\n        <a href='https://github.com/HKUDS/LightRAG/issues/285'><img src='https://img.shields.io/badge/ç¾¤èŠ-wechat-green'></a>\n    </p>\n\nThis repository hosts the code of LightRAG. The structure of this code is based on [nano-graphrag](https://github.com/gusye1234/nano-graphrag).\n![LightRAG Diagram](https://i-blog.csdnimg.cn/direct/b2aaf634151b4706892693ffb43d9093.png)\n</div>\n\n## ðŸŽ‰ News\n- [x] [2025.01.06]ðŸŽ¯ðŸ“¢LightRAG now supports [PostgreSQL for Storage](https://github.com/HKUDS/LightRAG?tab=readme-ov-file#using-postgres-for-storage).\n- [x] [2024.12.31]ðŸŽ¯ðŸ“¢LightRAG now supports [deletion by document ID](https://github.com/HKUDS/LightRAG?tab=readme-ov-file#delete).\n- [x] [2024.11.25]ðŸŽ¯ðŸ“¢LightRAG now supports seamless integration of [custom knowledge graphs](https://github.com/HKUDS/LightRAG?tab=readme-ov-file#insert-custom-kg), empowering users to enhance the system with their own domain expertise.\n- [x] [2024.11.19]ðŸŽ¯ðŸ“¢A comprehensive guide to LightRAG is now available on [LearnOpenCV](https://learnopencv.com/lightrag). Many thanks to the blog author.\n- [x] [2024.11.12]ðŸŽ¯ðŸ“¢LightRAG now supports [Oracle Database 23ai for all storage types (KV, vector, and graph)](https://github.com/HKUDS/LightRAG/blob/main/examples/lightrag_oracle_demo.py).\n- [x] [2024.11.11]ðŸŽ¯ðŸ“¢LightRAG now supports [deleting entities by their names](https://github.com/HKUDS/LightRAG?tab=readme-ov-file#delete).\n- [x] [2024.11.09]ðŸŽ¯ðŸ“¢Introducing the [LightRAG Gui](https://lightrag-gui.streamlit.app), which allows you to insert, query, visualize, and download LightRAG knowledge.\n- [x] [2024.11.04]ðŸŽ¯ðŸ“¢You can now [use Neo4J for Storage](https://github.com/HKUDS/LightRAG?tab=readme-ov-file#using-neo4j-for-storage).\n- [x] [2024.10.29]ðŸŽ¯ðŸ“¢LightRAG now supports multiple file types, including PDF, DOC, PPT, and CSV via `textract`.\n- [x] [2024.10.20]ðŸŽ¯ðŸ“¢Weâ€™ve added a new feature to LightRAG: Graph Visualization.\n- [x] [2024.10.18]ðŸŽ¯ðŸ“¢Weâ€™ve added a link to a [LightRAG Introduction Video](https://youtu.be/oageL-1I0GE). Thanks to the author!\n- [x] [2024.10.17]ðŸŽ¯ðŸ“¢We have created a [Discord channel](https://discord.gg/yF2MmDJyGJ)! Welcome to join for sharing and discussions! ðŸŽ‰ðŸŽ‰\n- [x] [2024.10.16]ðŸŽ¯ðŸ“¢LightRAG now supports [Ollama models](https://github.com/HKUDS/LightRAG?tab=readme-ov-file#quick-start)!\n- [x] [2024.10.15]ðŸŽ¯ðŸ“¢LightRAG now supports [Hugging Face models](https://github.com/HKUDS/LightRAG?tab=readme-ov-file#quick-start)!\n\n## Algorithm Flowchart\n\n![LightRAG Indexing Flowchart](https://learnopencv.com/wp-content/uploads/2024/11/LightRAG-VectorDB-Json-KV-Store-Indexing-Flowchart-scaled.jpg)\n*Figure 1: LightRAG Indexing Flowchart - Img Caption : [Source](https://learnopencv.com/lightrag/)*\n![LightRAG Retrieval and Querying Flowchart](https://learnopencv.com/wp-content/uploads/2024/11/LightRAG-Querying-Flowchart-Dual-Level-Retrieval-Generation-Knowledge-Graphs-scaled.jpg)\n*Figure 2: LightRAG Retrieval and Querying Flowchart - Img Caption : [Source](https://learnopencv.com/lightrag/)*\n\n## Install\n\n* Install from source (Recommend)\n\n```bash\ncd LightRAG\npip install -e .\n```\n* Install from PyPI\n```bash\npip install lightrag-hku\n```\n\n## Quick Start\n* [Video demo](https://www.youtube.com/watch?v=g21royNJ4fw) of running LightRAG locally.\n* All the code can be found in the `examples`.\n* Set OpenAI API key in environment if using OpenAI models: `export OPENAI_API_KEY=\"sk-...\".`\n* Download the demo text \"A Christmas Carol by Charles Dickens\":\n```bash\ncurl https://raw.githubusercontent.com/gusye1234/nano-graphrag/main/tests/mock_data.txt > ./book.txt\n```\nUse the below Python snippet (in a script) to initialize LightRAG and perform queries:\n\n```python\nimport os\nfrom lightrag import LightRAG, QueryParam\nfrom lightrag.llm import gpt_4o_mini_complete, gpt_4o_complete\n\n#########\n# Uncomment the below two lines if running in a jupyter notebook to handle the async nature of rag.insert()\n# import nest_asyncio\n# nest_asyncio.apply()\n#########\n\nWORKING_DIR = \"./dickens\"\n\n\nif not os.path.exists(WORKING_DIR):\n    os.mkdir(WORKING_DIR)\n\nrag = LightRAG(\n    working_dir=WORKING_DIR,\n    llm_model_func=gpt_4o_mini_complete  # Use gpt_4o_mini_complete LLM model\n    # llm_model_func=gpt_4o_complete  # Optionally, use a stronger model\n)\n\nwith open(\"./book.txt\") as f:\n    rag.insert(f.read())\n\n# Perform naive search\nprint(rag.query(\"What are the top themes in this story?\", param=QueryParam(mode=\"naive\")))\n\n# Perform local search\nprint(rag.query(\"What are the top themes in this story?\", param=QueryParam(mode=\"local\")))\n\n# Perform global search\nprint(rag.query(\"What are the top themes in this story?\", param=QueryParam(mode=\"global\")))\n\n# Perform hybrid search\nprint(rag.query(\"What are the top themes in this story?\", param=QueryParam(mode=\"hybrid\")))\n\n# Perform mix search (Knowledge Graph + Vector Retrieval)\n# Mix mode combines knowledge graph and vector search:\n# - Uses both structured (KG) and unstructured (vector) information\n# - Provides comprehensive answers by analyzing relationships and context\n# - Supports image content through HTML img tags\n# - Allows control over retrieval depth via top_k parameter\nprint(rag.query(\"What are the top themes in this story?\", param=QueryParam(\n    mode=\"mix\")))\n\n```\n\n\n\n\n<details>\n<summary> Using Open AI-like APIs </summary>\n\n* LightRAG also supports Open AI-like chat/embeddings APIs:\n```python\nasync def llm_model_func(\n    prompt, system_prompt=None, history_messages=[], keyword_extraction=False, **kwargs\n) -> str:\n    return await openai_complete_if_cache(\n        \"solar-mini\",\n        prompt,\n        system_prompt=system_prompt,\n        history_messages=history_messages,\n        api_key=os.getenv(\"UPSTAGE_API_KEY\"),\n        base_url=\"https://api.upstage.ai/v1/solar\",\n        **kwargs\n    )\n\nasync def embedding_func(texts: list[str]) -> np.ndarray:\n    return await openai_embedding(\n        texts,\n        model=\"solar-embedding-1-large-query\",\n        api_key=os.getenv(\"UPSTAGE_API_KEY\"),\n        base_url=\"https://api.upstage.ai/v1/solar\"\n    )\n\nrag = LightRAG(\n    working_dir=WORKING_DIR,\n    llm_model_func=llm_model_func,\n    embedding_func=EmbeddingFunc(\n        embedding_dim=4096,\n        max_token_size=8192,\n        func=embedding_func\n    )\n)\n```\n</details>\n\n<details>\n<summary> Using Hugging Face Models </summary>\n\n* If you want to use Hugging Face models, you only need to set LightRAG as follows:\n```python\nfrom lightrag.llm import hf_model_complete, hf_embedding\nfrom transformers import AutoModel, AutoTokenizer\nfrom lightrag.utils import EmbeddingFunc\n\n# Initialize LightRAG with Hugging Face model\nrag = LightRAG(\n    working_dir=WORKING_DIR,\n    llm_model_func=hf_model_complete,  # Use Hugging Face model for text generation\n    llm_model_name='meta-llama/Llama-3.1-8B-Instruct',  # Model name from Hugging Face\n    # Use Hugging Face embedding function\n    embedding_func=EmbeddingFunc(\n        embedding_dim=384,\n        max_token_size=5000,\n        func=lambda texts: hf_embedding(\n            texts,\n            tokenizer=AutoTokenizer.from_pretrained(\"sentence-transformers/all-MiniLM-L6-v2\"),\n            embed_model=AutoModel.from_pretrained(\"sentence-transformers/all-MiniLM-L6-v2\")\n        )\n    ),\n)\n```\n</details>\n\n<details>\n<summary> Using Ollama Models </summary>\n\n### Overview\nIf you want to use Ollama models, you need to pull model you plan to use and embedding model, for example `nomic-embed-text`.\n\nThen you only need to set LightRAG as follows:\n\n```python\nfrom lightrag.llm import ollama_model_complete, ollama_embedding\nfrom lightrag.utils import EmbeddingFunc\n\n# Initialize LightRAG with Ollama model\nrag = LightRAG(\n    working_dir=WORKING_DIR,\n    llm_model_func=ollama_model_complete,  # Use Ollama model for text generation\n    llm_model_name='your_model_name', # Your model name\n    # Use Ollama embedding function\n    embedding_func=EmbeddingFunc(\n        embedding_dim=768,\n        max_token_size=8192,\n        func=lambda texts: ollama_embedding(\n            texts,\n            embed_model=\"nomic-embed-text\"\n        )\n    ),\n)\n```\n\n### Increasing context size\nIn order for LightRAG to work context should be at least 32k tokens. By default Ollama models have context size of 8k. You can achieve this using one of two ways:\n\n#### Increasing the `num_ctx` parameter in Modelfile.\n\n1. Pull the model:\n```bash\nollama pull qwen2\n```\n\n2. Display the model file:\n```bash\nollama show --modelfile qwen2 > Modelfile\n```\n\n3. Edit the Modelfile by adding the following line:\n```bash\nPARAMETER num_ctx 32768\n```\n\n4. Create the modified model:\n```bash\nollama create -f Modelfile qwen2m\n```\n\n#### Setup `num_ctx` via Ollama API.\nTiy can use `llm_model_kwargs` param to configure ollama:\n\n```python\nrag = LightRAG(\n    working_dir=WORKING_DIR,\n    llm_model_func=ollama_model_complete,  # Use Ollama model for text generation\n    llm_model_name='your_model_name', # Your model name\n    llm_model_kwargs={\"options\": {\"num_ctx\": 32768}},\n    # Use Ollama embedding function\n    embedding_func=EmbeddingFunc(\n        embedding_dim=768,\n        max_token_size=8192,\n        func=lambda texts: ollama_embedding(\n            texts,\n            embed_model=\"nomic-embed-text\"\n        )\n    ),\n)\n```\n#### Fully functional example\n\nThere fully functional example `examples/lightrag_ollama_demo.py` that utilizes `gemma2:2b` model, runs only 4 requests in parallel and set context size to 32k.\n\n#### Low RAM GPUs\n\nIn order to run this experiment on low RAM GPU you should select small model and tune context window (increasing context increase memory consumption). For example, running this ollama example on repurposed mining GPU with 6Gb of RAM required to set context size to 26k while using `gemma2:2b`. It was able to find 197 entities and 19 relations on `book.txt`.\n\n</details>\n\n### Query Param\n\n```python\nclass QueryParam:\n    mode: Literal[\"local\", \"global\", \"hybrid\", \"naive\", \"mix\"] = \"global\"\n    only_need_context: bool = False\n    response_type: str = \"Multiple Paragraphs\"\n    # Number of top-k items to retrieve; corresponds to entities in \"local\" mode and relationships in \"global\" mode.\n    top_k: int = 60\n    # Number of tokens for the original chunks.\n    max_token_for_text_unit: int = 4000\n    # Number of tokens for the relationship descriptions\n    max_token_for_global_context: int = 4000\n    # Number of tokens for the entity descriptions\n    max_token_for_local_context: int = 4000\n```\n\n### Batch Insert\n\n```python\n# Basic Batch Insert: Insert multiple texts at once\nrag.insert([\"TEXT1\", \"TEXT2\",...])\n\n# Batch Insert with custom batch size configuration\nrag = LightRAG(\n    working_dir=WORKING_DIR,\n    addon_params={\n        \"insert_batch_size\": 20  # Process 20 documents per batch\n    }\n)\nrag.insert([\"TEXT1\", \"TEXT2\", \"TEXT3\", ...])  # Documents will be processed in batches of 20\n```\n\nThe `insert_batch_size` parameter in `addon_params` controls how many documents are processed in each batch during insertion. This is useful for:\n- Managing memory usage with large document collections\n- Optimizing processing speed\n- Providing better progress tracking\n- Default value is 10 if not specified\n\n### Incremental Insert\n\n```python\n# Incremental Insert: Insert new documents into an existing LightRAG instance\nrag = LightRAG(\n     working_dir=WORKING_DIR,\n     llm_model_func=llm_model_func,\n     embedding_func=EmbeddingFunc(\n          embedding_dim=embedding_dimension,\n          max_token_size=8192,\n          func=embedding_func,\n     ),\n)\n\nwith open(\"./newText.txt\") as f:\n    rag.insert(f.read())\n```\n\n### Using Neo4J for Storage\n\n* For production level scenarios you will most likely want to leverage an enterprise solution\n* for KG storage. Running Neo4J in Docker is recommended for seamless local testing.\n* See: https://hub.docker.com/_/neo4j\n\n```python\nexport NEO4J_URI=\"neo4j://localhost:7687\"\nexport NEO4J_USERNAME=\"neo4j\"\nexport NEO4J_PASSWORD=\"password\"\n\n# When you launch the project be sure to override the default KG: NetworkX\n# by specifying kg=\"Neo4JStorage\".\n\n# Note: Default settings use NetworkX\n# Initialize LightRAG with Neo4J implementation.\nWORKING_DIR = \"./local_neo4jWorkDir\"\n\nrag = LightRAG(\n    working_dir=WORKING_DIR,\n    llm_model_func=gpt_4o_mini_complete,  # Use gpt_4o_mini_complete LLM model\n    graph_storage=\"Neo4JStorage\", #<-----------override KG default\n    log_level=\"DEBUG\"  #<-----------override log_level default\n)\n```\nsee test_neo4j.py for a working example.\n\n### Using PostgreSQL for Storage\nFor production level scenarios you will most likely want to leverage an enterprise solution. PostgreSQL can provide a one-stop solution for you as KV store, VectorDB (pgvector) and GraphDB (apache AGE).\n* PostgreSQL is lightweight,the whole binary distribution including all necessary plugins can be zipped to 40MB: Ref to [Windows Release](https://github.com/ShanGor/apache-age-windows/releases/tag/PG17%2Fv1.5.0-rc0) as it is easy to install for Linux/Mac.\n* How to start? Ref to: [examples/lightrag_zhipu_postgres_demo.py](https://github.com/HKUDS/LightRAG/blob/main/examples/lightrag_zhipu_postgres_demo.py)\n\n### Insert Custom KG\n\n```python\nrag = LightRAG(\n     working_dir=WORKING_DIR,\n     llm_model_func=llm_model_func,\n     embedding_func=EmbeddingFunc(\n          embedding_dim=embedding_dimension,\n          max_token_size=8192,\n          func=embedding_func,\n     ),\n)\n\ncustom_kg = {\n    \"entities\": [\n        {\n            \"entity_name\": \"CompanyA\",\n            \"entity_type\": \"Organization\",\n            \"description\": \"A major technology company\",\n            \"source_id\": \"Source1\"\n        },\n        {\n            \"entity_name\": \"ProductX\",\n            \"entity_type\": \"Product\",\n            \"description\": \"A popular product developed by CompanyA\",\n            \"source_id\": \"Source1\"\n        }\n    ],\n    \"relationships\": [\n        {\n            \"src_id\": \"CompanyA\",\n            \"tgt_id\": \"ProductX\",\n            \"description\": \"CompanyA develops ProductX\",\n            \"keywords\": \"develop, produce\",\n            \"weight\": 1.0,\n            \"source_id\": \"Source1\"\n        }\n    ],\n    \"chunks\": [\n        {\n            \"content\": \"ProductX, developed by CompanyA, has revolutionized the market with its cutting-edge features.\",\n            \"source_id\": \"Source1\",\n        },\n        {\n            \"content\": \"PersonA is a prominent researcher at UniversityB, focusing on artificial intelligence and machine learning.\",\n            \"source_id\": \"Source2\",\n        },\n        {\n            \"content\": \"None\",\n            \"source_id\": \"UNKNOWN\",\n        },\n    ],\n}\n\nrag.insert_custom_kg(custom_kg)\n```\n\n### Delete\n```python\n\nrag = LightRAG(\n     working_dir=WORKING_DIR,\n     llm_model_func=llm_model_func,\n     embedding_func=EmbeddingFunc(\n          embedding_dim=embedding_dimension,\n          max_token_size=8192,\n          func=embedding_func,\n     ),\n)\n\n#  Delete Entity: Deleting entities by their names\nrag.delete_by_entity(\"Project Gutenberg\")\n\n#  Delete Document: Deleting entities and relationships associated with the document by doc id\nrag.delete_by_doc_id(\"doc_id\")\n```\n\n### Multi-file Type Support\n\nThe `textract` supports reading file types such as TXT, DOCX, PPTX, CSV, and PDF.\n\n```python\nimport textract\n\nfile_path = 'TEXT.pdf'\ntext_content = textract.process(file_path)\n\nrag.insert(text_content.decode('utf-8'))\n```\n\n### Graph Visualization\n\n<details>\n<summary> Graph visualization with html </summary>\n\n* The following code can be found in `examples/graph_visual_with_html.py`\n\n```python\nimport networkx as nx\nfrom pyvis.network import Network\n\n# Load the GraphML file\nG = nx.read_graphml('./dickens/graph_chunk_entity_relation.graphml')\n\n# Create a Pyvis network\nnet = Network(notebook=True)\n\n# Convert NetworkX graph to Pyvis network\nnet.from_nx(G)\n\n# Save and display the network\nnet.show('knowledge_graph.html')\n```\n\n</details>\n\n<details>\n<summary> Graph visualization with Neo4j </summary>\n\n* The following code can be found in `examples/graph_visual_with_neo4j.py`\n\n```python\nimport os\nimport json\nfrom lightrag.utils import xml_to_json\nfrom neo4j import GraphDatabase\n\n# Constants\nWORKING_DIR = \"./dickens\"\nBATCH_SIZE_NODES = 500\nBATCH_SIZE_EDGES = 100\n\n# Neo4j connection credentials\nNEO4J_URI = \"bolt://localhost:7687\"\nNEO4J_USERNAME = \"neo4j\"\nNEO4J_PASSWORD = \"your_password\"\n\ndef convert_xml_to_json(xml_path, output_path):\n    \"\"\"Converts XML file to JSON and saves the output.\"\"\"\n    if not os.path.exists(xml_path):\n        print(f\"Error: File not found - {xml_path}\")\n        return None\n\n    json_data = xml_to_json(xml_path)\n    if json_data:\n        with open(output_path, 'w', encoding='utf-8') as f:\n            json.dump(json_data, f, ensure_ascii=False, indent=2)\n        print(f\"JSON file created: {output_path}\")\n        return json_data\n    else:\n        print(\"Failed to create JSON data\")\n        return None\n\ndef process_in_batches(tx, query, data, batch_size):\n    \"\"\"Process data in batches and execute the given query.\"\"\"\n    for i in range(0, len(data), batch_size):\n        batch = data[i:i + batch_size]\n        tx.run(query, {\"nodes\": batch} if \"nodes\" in query else {\"edges\": batch})\n\ndef main():\n    # Paths\n    xml_file = os.path.join(WORKING_DIR, 'graph_chunk_entity_relation.graphml')\n    json_file = os.path.join(WORKING_DIR, 'graph_data.json')\n\n    # Convert XML to JSON\n    json_data = convert_xml_to_json(xml_file, json_file)\n    if json_data is None:\n        return\n\n    # Load nodes and edges\n    nodes = json_data.get('nodes', [])\n    edges = json_data.get('edges', [])\n\n    # Neo4j queries\n    create_nodes_query = \"\"\"\n    UNWIND $nodes AS node\n    MERGE (e:Entity {id: node.id})\n    SET e.entity_type = node.entity_type,\n        e.description = node.description,\n        e.source_id = node.source_id,\n        e.displayName = node.id\n    REMOVE e:Entity\n    WITH e, node\n    CALL apoc.create.addLabels(e, [node.entity_type]) YIELD node AS labeledNode\n    RETURN count(*)\n    \"\"\"\n\n    create_edges_query = \"\"\"\n    UNWIND $edges AS edge\n    MATCH (source {id: edge.source})\n    MATCH (target {id: edge.target})\n    WITH source, target, edge,\n         CASE\n            WHEN edge.keywords CONTAINS 'lead' THEN 'lead'\n            WHEN edge.keywords CONTAINS 'participate' THEN 'participate'\n            WHEN edge.keywords CONTAINS 'uses' THEN 'uses'\n            WHEN edge.keywords CONTAINS 'located' THEN 'located'\n            WHEN edge.keywords CONTAINS 'occurs' THEN 'occurs'\n           ELSE REPLACE(SPLIT(edge.keywords, ',')[0], '\\\"', '')\n         END AS relType\n    CALL apoc.create.relationship(source, relType, {\n      weight: edge.weight,\n      description: edge.description,\n      keywords: edge.keywords,\n      source_id: edge.source_id\n    }, target) YIELD rel\n    RETURN count(*)\n    \"\"\"\n\n    set_displayname_and_labels_query = \"\"\"\n    MATCH (n)\n    SET n.displayName = n.id\n    WITH n\n    CALL apoc.create.setLabels(n, [n.entity_type]) YIELD node\n    RETURN count(*)\n    \"\"\"\n\n    # Create a Neo4j driver\n    driver = GraphDatabase.driver(NEO4J_URI, auth=(NEO4J_USERNAME, NEO4J_PASSWORD))\n\n    try:\n        # Execute queries in batches\n        with driver.session() as session:\n            # Insert nodes in batches\n            session.execute_write(process_in_batches, create_nodes_query, nodes, BATCH_SIZE_NODES)\n\n            # Insert edges in batches\n            session.execute_write(process_in_batches, create_edges_query, edges, BATCH_SIZE_EDGES)\n\n            # Set displayName and labels\n            session.run(set_displayname_and_labels_query)\n\n    except Exception as e:\n        print(f\"Error occurred: {e}\")\n\n    finally:\n        driver.close()\n\nif __name__ == \"__main__\":\n    main()\n```\n\n</details>\n\n### LightRAG init parameters\n\n| **Parameter**                                | **Type** | **Explanation**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | **Default**                                                                                                 |\n|----------------------------------------------| --- |-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------|\n| **working\\_dir**                             | `str` | Directory where the cache will be stored                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | `lightrag_cache+timestamp`                                                                                  |\n| **kv\\_storage**                              | `str` | Storage type for documents and text chunks. Supported types: `JsonKVStorage`, `OracleKVStorage`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | `JsonKVStorage`                                                                                             |\n| **vector\\_storage**                          | `str` | Storage type for embedding vectors. Supported types: `NanoVectorDBStorage`, `OracleVectorDBStorage`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | `NanoVectorDBStorage`                                                                                       |\n| **graph\\_storage**                           | `str` | Storage type for graph edges and nodes. Supported types: `NetworkXStorage`, `Neo4JStorage`, `OracleGraphStorage`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    | `NetworkXStorage`                                                                                           |\n| **log\\_level**                               |     | Log level for application runtime                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | `logging.DEBUG`                                                                                             |\n| **chunk\\_token\\_size**                       | `int` | Maximum token size per chunk when splitting documents                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | `1200`                                                                                                      |\n| **chunk\\_overlap\\_token\\_size**              | `int` | Overlap token size between two chunks when splitting documents                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | `100`                                                                                                       |\n| **tiktoken\\_model\\_name**                    | `str` | Model name for the Tiktoken encoder used to calculate token numbers                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | `gpt-4o-mini`                                                                                               |\n| **entity\\_extract\\_max\\_gleaning**           | `int` | Number of loops in the entity extraction process, appending history messages                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        | `1`                                                                                                         |\n| **entity\\_summary\\_to\\_max\\_tokens**         | `int` | Maximum token size for each entity summary                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | `500`                                                                                                       |\n| **node\\_embedding\\_algorithm**               | `str` | Algorithm for node embedding (currently not used)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | `node2vec`                                                                                                  |\n| **node2vec\\_params**                         | `dict` | Parameters for node embedding                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | `{\"dimensions\": 1536,\"num_walks\": 10,\"walk_length\": 40,\"window_size\": 2,\"iterations\": 3,\"random_seed\": 3,}` |\n| **embedding\\_func**                          | `EmbeddingFunc` | Function to generate embedding vectors from text                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    | `openai_embedding`                                                                                          |\n| **embedding\\_batch\\_num**                    | `int` | Maximum batch size for embedding processes (multiple texts sent per batch)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | `32`                                                                                                        |\n| **embedding\\_func\\_max\\_async**              | `int` | Maximum number of concurrent asynchronous embedding processes                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | `16`                                                                                                        |\n| **llm\\_model\\_func**                         | `callable` | Function for LLM generation                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | `gpt_4o_mini_complete`                                                                                      |\n| **llm\\_model\\_name**                         | `str` | LLM model name for generation                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | `meta-llama/Llama-3.2-1B-Instruct`                                                                          |\n| **llm\\_model\\_max\\_token\\_size**             | `int` | Maximum token size for LLM generation (affects entity relation summaries)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | `32768`                                                                                                     |\n| **llm\\_model\\_max\\_async**                   | `int` | Maximum number of concurrent asynchronous LLM processes                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | `16`                                                                                                        |\n| **llm\\_model\\_kwargs**                       | `dict` | Additional parameters for LLM generation                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |                                                                                                             |\n| **vector\\_db\\_storage\\_cls\\_kwargs**         | `dict` | Additional parameters for vector database (currently not used)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |                                                                                                             |\n| **enable\\_llm\\_cache**                       | `bool` | If `TRUE`, stores LLM results in cache; repeated prompts return cached responses                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    | `TRUE`                                                                                                      |\n| **enable\\_llm\\_cache\\_for\\_entity\\_extract** | `bool` | If `TRUE`, stores LLM results in cache for entity extraction; Good for beginners to debug your application                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  | `TRUE`                                                                                                     |\n| **addon\\_params**                            | `dict` | Additional parameters, e.g., `{\"example_number\": 1, \"language\": \"Simplified Chinese\", \"entity_types\": [\"organization\", \"person\", \"geo\", \"event\"], \"insert_batch_size\": 10}`: sets example limit, output language, and batch size for document processing                                                                                                                                                                                                                                                                                                                                                                                                                            | `example_number: all examples, language: English, insert_batch_size: 10`                                    |\n| **convert\\_response\\_to\\_json\\_func**        | `callable` | Not used                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | `convert_response_to_json`                                                                                  |\n| **embedding\\_cache\\_config**                 | `dict` | Configuration for question-answer caching. Contains three parameters:<br>- `enabled`: Boolean value to enable/disable cache lookup functionality. When enabled, the system will check cached responses before generating new answers.<br>- `similarity_threshold`: Float value (0-1), similarity threshold. When a new question's similarity with a cached question exceeds this threshold, the cached answer will be returned directly without calling the LLM.<br>- `use_llm_check`: Boolean value to enable/disable LLM similarity verification. When enabled, LLM will be used as a secondary check to verify the similarity between questions before returning cached answers. | Default: `{\"enabled\": False, \"similarity_threshold\": 0.95, \"use_llm_check\": False}`                         |\n\n### Error Handling\n<details>\n<summary>Click to view error handling details</summary>\n\nThe API includes comprehensive error handling:\n- File not found errors (404)\n- Processing errors (500)\n- Supports multiple file encodings (UTF-8 and GBK)\n</details>\n\n## Evaluation\n### Dataset\nThe dataset used in LightRAG can be downloaded from [TommyChien/UltraDomain](https://huggingface.co/datasets/TommyChien/UltraDomain).\n\n### Generate Query\nLightRAG uses the following prompt to generate high-level queries, with the corresponding code in `example/generate_query.py`.\n\n<details>\n<summary> Prompt </summary>\n\n```python\nGiven the following description of a dataset:\n\n{description}\n\nPlease identify 5 potential users who would engage with this dataset. For each user, list 5 tasks they would perform with this dataset. Then, for each (user, task) combination, generate 5 questions that require a high-level understanding of the entire dataset.\n\nOutput the results in the following structure:\n- User 1: [user description]\n    - Task 1: [task description]\n        - Question 1:\n        - Question 2:\n        - Question 3:\n        - Question 4:\n        - Question 5:\n    - Task 2: [task description]\n        ...\n    - Task 5: [task description]\n- User 2: [user description]\n    ...\n- User 5: [user description]\n    ...\n```\n</details>\n\n ### Batch Eval\nTo evaluate the performance of two RAG systems on high-level queries, LightRAG uses the following prompt, with the specific code available in `example/batch_eval.py`.\n\n<details>\n<summary> Prompt </summary>\n\n```python\n---Role---\nYou are an expert tasked with evaluating two answers to the same question based on three criteria: **Comprehensiveness**, **Diversity**, and **Empowerment**.\n---Goal---\nYou will evaluate two answers to the same question based on three criteria: **Comprehensiveness**, **Diversity**, and **Empowerment**.\n\n- **Comprehensiveness**: How much detail does the answer provide to cover all aspects and details of the question?\n- **Diversity**: How varied and rich is the answer in providing different perspectives and insights on the question?\n- **Empowerment**: How well does the answer help the reader understand and make informed judgments about the topic?\n\nFor each criterion, choose the better answer (either Answer 1 or Answer 2) and explain why. Then, select an overall winner based on these three categories.\n\nHere is the question:\n{query}\n\nHere are the two answers:\n\n**Answer 1:**\n{answer1}\n\n**Answer 2:**\n{answer2}\n\nEvaluate both answers using the three criteria listed above and provide detailed explanations for each criterion.\n\nOutput your evaluation in the following JSON format:\n\n{{\n    \"Comprehensiveness\": {{\n        \"Winner\": \"[Answer 1 or Answer 2]\",\n        \"Explanation\": \"[Provide explanation here]\"\n    }},\n    \"Empowerment\": {{\n        \"Winner\": \"[Answer 1 or Answer 2]\",\n        \"Explanation\": \"[Provide explanation here]\"\n    }},\n    \"Overall Winner\": {{\n        \"Winner\": \"[Answer 1 or Answer 2]\",\n        \"Explanation\": \"[Summarize why this answer is the overall winner based on the three criteria]\"\n    }}\n}}\n```\n</details>\n\n### Overall Performance Table\n|                      | **Agriculture**         |                       | **CS**                |                       | **Legal**             |                       | **Mix**               |                       |\n|----------------------|-------------------------|-----------------------|-----------------------|-----------------------|-----------------------|-----------------------|-----------------------|-----------------------|\n|                      | NaiveRAG                | **LightRAG**          | NaiveRAG              | **LightRAG**          | NaiveRAG              | **LightRAG**          | NaiveRAG              | **LightRAG**          |\n| **Comprehensiveness** | 32.4%                  | **67.6%**             | 38.4%                | **61.6%**             | 16.4%                | **83.6%**             | 38.8%                | **61.2%**             |\n| **Diversity**         | 23.6%                  | **76.4%**             | 38.0%                | **62.0%**             | 13.6%                | **86.4%**             | 32.4%                | **67.6%**             |\n| **Empowerment**       | 32.4%                  | **67.6%**             | 38.8%                | **61.2%**             | 16.4%                | **83.6%**             | 42.8%                | **57.2%**             |\n| **Overall**           | 32.4%                  | **67.6%**             | 38.8%                | **61.2%**             | 15.2%                | **84.8%**             | 40.0%                | **60.0%**             |\n|                      | RQ-RAG                  | **LightRAG**          | RQ-RAG               | **LightRAG**          | RQ-RAG               | **LightRAG**          | RQ-RAG               | **LightRAG**          |\n| **Comprehensiveness** | 31.6%                  | **68.4%**             | 38.8%                | **61.2%**             | 15.2%                | **84.8%**             | 39.2%                | **60.8%**             |\n| **Diversity**         | 29.2%                  | **70.8%**             | 39.2%                | **60.8%**             | 11.6%                | **88.4%**             | 30.8%                | **69.2%**             |\n| **Empowerment**       | 31.6%                  | **68.4%**             | 36.4%                | **63.6%**             | 15.2%                | **84.8%**             | 42.4%                | **57.6%**             |\n| **Overall**           | 32.4%                  | **67.6%**             | 38.0%                | **62.0%**             | 14.4%                | **85.6%**             | 40.0%                | **60.0%**             |\n|                      | HyDE                    | **LightRAG**          | HyDE                 | **LightRAG**          | HyDE                 | **LightRAG**          | HyDE                 | **LightRAG**          |\n| **Comprehensiveness** | 26.0%                  | **74.0%**             | 41.6%                | **58.4%**             | 26.8%                | **73.2%**             | 40.4%                | **59.6%**             |\n| **Diversity**         | 24.0%                  | **76.0%**             | 38.8%                | **61.2%**             | 20.0%                | **80.0%**             | 32.4%                | **67.6%**             |\n| **Empowerment**       | 25.2%                  | **74.8%**             | 40.8%                | **59.2%**             | 26.0%                | **74.0%**             | 46.0%                | **54.0%**             |\n| **Overall**           | 24.8%                  | **75.2%**             | 41.6%                | **58.4%**             | 26.4%                | **73.6%**             | 42.4%                | **57.6%**             |\n|                      | GraphRAG                | **LightRAG**          | GraphRAG             | **LightRAG**          | GraphRAG             | **LightRAG**          | GraphRAG             | **LightRAG**          |\n| **Comprehensiveness** | 45.6%                  | **54.4%**             | 48.4%                | **51.6%**             | 48.4%                | **51.6%**             | **50.4%**            | 49.6%                |\n| **Diversity**         | 22.8%                  | **77.2%**             | 40.8%                | **59.2%**             | 26.4%                | **73.6%**             | 36.0%                | **64.0%**             |\n| **Empowerment**       | 41.2%                  | **58.8%**             | 45.2%                | **54.8%**             | 43.6%                | **56.4%**             | **50.8%**            | 49.2%                |\n| **Overall**           | 45.2%                  | **54.8%**             | 48.0%                | **52.0%**             | 47.2%                | **52.8%**             | **50.4%**            | 49.6%                |\n\n## Reproduce\nAll the code can be found in the `./reproduce` directory.\n\n### Step-0 Extract Unique Contexts\nFirst, we need to extract unique contexts in the datasets.\n\n<details>\n<summary> Code </summary>\n\n```python\ndef extract_unique_contexts(input_directory, output_directory):\n\n    os.makedirs(output_directory, exist_ok=True)\n\n    jsonl_files = glob.glob(os.path.join(input_directory, '*.jsonl'))\n    print(f\"Found {len(jsonl_files)} JSONL files.\")\n\n    for file_path in jsonl_files:\n        filename = os.path.basename(file_path)\n        name, ext = os.path.splitext(filename)\n        output_filename = f\"{name}_unique_contexts.json\"\n        output_path = os.path.join(output_directory, output_filename)\n\n        unique_contexts_dict = {}\n\n        print(f\"Processing file: {filename}\")\n\n        try:\n            with open(file_path, 'r', encoding='utf-8') as infile:\n                for line_number, line in enumerate(infile, start=1):\n                    line = line.strip()\n                    if not line:\n                        continue\n                    try:\n                        json_obj = json.loads(line)\n                        context = json_obj.get('context')\n                        if context and context not in unique_contexts_dict:\n                            unique_contexts_dict[context] = None\n                    except json.JSONDecodeError as e:\n                        print(f\"JSON decoding error in file {filename} at line {line_number}: {e}\")\n        except FileNotFoundError:\n            print(f\"File not found: {filename}\")\n            continue\n        except Exception as e:\n            print(f\"An error occurred while processing file {filename}: {e}\")\n            continue\n\n        unique_contexts_list = list(unique_contexts_dict.keys())\n        print(f\"There are {len(unique_contexts_list)} unique `context` entries in the file {filename}.\")\n\n        try:\n            with open(output_path, 'w', encoding='utf-8') as outfile:\n                json.dump(unique_contexts_list, outfile, ensure_ascii=False, indent=4)\n            print(f\"Unique `context` entries have been saved to: {output_filename}\")\n        except Exception as e:\n            print(f\"An error occurred while saving to the file {output_filename}: {e}\")\n\n    print(\"All files have been processed.\")\n\n```\n</details>\n\n### Step-1 Insert Contexts\nFor the extracted contexts, we insert them into the LightRAG system.\n\n<details>\n<summary> Code </summary>\n\n```python\ndef insert_text(rag, file_path):\n    with open(file_path, mode='r') as f:\n        unique_contexts = json.load(f)\n\n    retries = 0\n    max_retries = 3\n    while retries < max_retries:\n        try:\n            rag.insert(unique_contexts)\n            break\n        except Exception as e:\n            retries += 1\n            print(f\"Insertion failed, retrying ({retries}/{max_retries}), error: {e}\")\n            time.sleep(10)\n    if retries == max_retries:\n        print(\"Insertion failed after exceeding the maximum number of retries\")\n```\n</details>\n\n### Step-2 Generate Queries\n\nWe extract tokens from the first and the second half of each context in the dataset, then combine them as dataset descriptions to generate queries.\n\n<details>\n<summary> Code </summary>\n\n```python\ntokenizer = GPT2Tokenizer.from_pretrained('gpt2')\n\ndef get_summary(context, tot_tokens=2000):\n    tokens = tokenizer.tokenize(context)\n    half_tokens = tot_tokens // 2\n\n    start_tokens = tokens[1000:1000 + half_tokens]\n    end_tokens = tokens[-(1000 + half_tokens):1000]\n\n    summary_tokens = start_tokens + end_tokens\n    summary = tokenizer.convert_tokens_to_string(summary_tokens)\n\n    return summary\n```\n</details>\n\n### Step-3 Query\nFor the queries generated in Step-2, we will extract them and query LightRAG.\n\n<details>\n<summary> Code </summary>\n\n```python\ndef extract_queries(file_path):\n    with open(file_path, 'r') as f:\n        data = f.read()\n\n    data = data.replace('**', '')\n\n    queries = re.findall(r'- Question \\d+: (.+)', data)\n\n    return queries\n```\n</details>\n\n## Install with API Support\n\nLightRAG provides optional API support through FastAPI servers that add RAG capabilities to existing LLM services. You can install LightRAG with API support in two ways:\n\n### 1. Installation from PyPI\n\n```bash\npip install \"lightrag-hku[api]\"\n```\n\n### 2. Installation from Source (Development)\n\n```bash\n# Clone the repository\ngit clone https://github.com/HKUDS/lightrag.git\n\n# Change to the repository directory\ncd lightrag\n\n# Install in editable mode with API support\npip install -e \".[api]\"\n```\n\n### Prerequisites\n\nBefore running any of the servers, ensure you have the corresponding backend service running:\n\n#### For LoLLMs Server\n- LoLLMs must be running and accessible\n- Default connection: http://localhost:9600\n- Configure using --lollms-host if running on a different host/port\n\n#### For Ollama Server\n- Ollama must be running and accessible\n- Default connection: http://localhost:11434\n- Configure using --ollama-host if running on a different host/port\n\n#### For OpenAI Server\n- Requires valid OpenAI API credentials set in environment variables\n- OPENAI_API_KEY must be set\n\n#### For Azure OpenAI Server\nAzure OpenAI API can be created using the following commands in Azure CLI (you need to install Azure CLI first from [https://docs.microsoft.com/en-us/cli/azure/install-azure-cli](https://docs.microsoft.com/en-us/cli/azure/install-azure-cli)):\n```bash\n# Change the resource group name, location and OpenAI resource name as needed\nRESOURCE_GROUP_NAME=LightRAG\nLOCATION=swedencentral\nRESOURCE_NAME=LightRAG-OpenAI\n\naz login\naz group create --name $RESOURCE_GROUP_NAME --location $LOCATION\naz cognitiveservices account create --name $RESOURCE_NAME --resource-group $RESOURCE_GROUP_NAME  --kind OpenAI --sku S0 --location swedencentral\naz cognitiveservices account deployment create --resource-group $RESOURCE_GROUP_NAME  --model-format OpenAI --name $RESOURCE_NAME --deployment-name gpt-4o --model-name gpt-4o --model-version \"2024-08-06\"  --sku-capacity 100 --sku-name \"Standard\"\naz cognitiveservices account deployment create --resource-group $RESOURCE_GROUP_NAME  --model-format OpenAI --name $RESOURCE_NAME --deployment-name text-embedding-3-large --model-name text-embedding-3-large --model-version \"1\"  --sku-capacity 80 --sku-name \"Standard\"\naz cognitiveservices account show --name $RESOURCE_NAME --resource-group $RESOURCE_GROUP_NAME --query \"properties.endpoint\"\naz cognitiveservices account keys list --name $RESOURCE_NAME -g $RESOURCE_GROUP_NAME\n\n```\nThe output of the last command will give you the endpoint and the key for the OpenAI API. You can use these values to set the environment variables in the `.env` file.\n\n\n\n### Configuration Options\n\nEach server has its own specific configuration options:\n\n#### LoLLMs Server Options\n\n| Parameter | Default | Description |\n|-----------|---------|-------------|\n| --host | 0.0.0.0 | RAG server host |\n| --port | 9621 | RAG server port |\n| --model | mistral-nemo:latest | LLM model name |\n| --embedding-model | bge-m3:latest | Embedding model name |\n| --lollms-host | http://localhost:9600 | LoLLMS backend URL |\n| --working-dir | ./rag_storage | Working directory for RAG |\n| --max-async | 4 | Maximum async operations |\n| --max-tokens | 32768 | Maximum token size |\n| --embedding-dim | 1024 | Embedding dimensions |\n| --max-embed-tokens | 8192 | Maximum embedding token size |\n| --input-file | ./book.txt | Initial input file |\n| --log-level | INFO | Logging level |\n| --key | none | Access Key to protect the lightrag service |\n\n#### Ollama Server Options\n\n| Parameter | Default | Description |\n|-----------|---------|-------------|\n| --host | 0.0.0.0 | RAG server host |\n| --port | 9621 | RAG server port |\n| --model | mistral-nemo:latest | LLM model name |\n| --embedding-model | bge-m3:latest | Embedding model name |\n| --ollama-host | http://localhost:11434 | Ollama backend URL |\n| --working-dir | ./rag_storage | Working directory for RAG |\n| --max-async | 4 | Maximum async operations |\n| --max-tokens | 32768 | Maximum token size |\n| --embedding-dim | 1024 | Embedding dimensions |\n| --max-embed-tokens | 8192 | Maximum embedding token size |\n| --input-file | ./book.txt | Initial input file |\n| --log-level | INFO | Logging level |\n| --key | none | Access Key to protect the lightrag service |\n\n#### OpenAI Server Options\n\n| Parameter | Default | Description |\n|-----------|---------|-------------|\n| --host | 0.0.0.0 | RAG server host |\n| --port | 9621 | RAG server port |\n| --model | gpt-4 | OpenAI model name |\n| --embedding-model | text-embedding-3-large | OpenAI embedding model |\n| --working-dir | ./rag_storage | Working directory for RAG |\n| --max-tokens | 32768 | Maximum token size |\n| --max-embed-tokens | 8192 | Maximum embedding token size |\n| --input-dir | ./inputs | Input directory for documents |\n| --log-level | INFO | Logging level |\n| --key | none | Access Key to protect the lightrag service |\n\n#### OpenAI AZURE Server Options\n\n| Parameter | Default | Description |\n|-----------|---------|-------------|\n| --host | 0.0.0.0 | Server host |\n| --port | 9621 | Server port |\n| --model | gpt-4 | OpenAI model name |\n| --embedding-model | text-embedding-3-large | OpenAI embedding model |\n| --working-dir | ./rag_storage | Working directory for RAG |\n| --max-tokens | 32768 | Maximum token size |\n| --max-embed-tokens | 8192 | Maximum embedding token size |\n| --input-dir | ./inputs | Input directory for documents |\n| --enable-cache | True | Enable response cache |\n| --log-level | INFO | Logging level |\n| --key | none | Access Key to protect the lightrag service |\n\n\nFor protecting the server using an authentication key, you can also use an environment variable named `LIGHTRAG_API_KEY`.\n### Example Usage\n\n#### LoLLMs RAG Server\n\n```bash\n# Custom configuration with specific model and working directory\nlollms-lightrag-server --model mistral-nemo --port 8080 --working-dir ./custom_rag\n\n# Using specific models (ensure they are installed in your LoLLMs instance)\nlollms-lightrag-server --model mistral-nemo:latest --embedding-model bge-m3 --embedding-dim 1024\n\n# Using specific models and an authentication key\nlollms-lightrag-server --model mistral-nemo:latest --embedding-model bge-m3 --embedding-dim 1024 --key ky-mykey\n\n```\n\n#### Ollama RAG Server\n\n```bash\n# Custom configuration with specific model and working directory\nollama-lightrag-server --model mistral-nemo:latest --port 8080 --working-dir ./custom_rag\n\n# Using specific models (ensure they are installed in your Ollama instance)\nollama-lightrag-server --model mistral-nemo:latest --embedding-model bge-m3 --embedding-dim 1024\n```\n\n#### OpenAI RAG Server\n\n```bash\n# Using GPT-4 with text-embedding-3-large\nopenai-lightrag-server --port 9624 --model gpt-4 --embedding-model text-embedding-3-large\n```\n#### Azure OpenAI RAG Server\n```bash\n# Using GPT-4 with text-embedding-3-large\nazure-openai-lightrag-server --model gpt-4o --port 8080 --working-dir ./custom_rag --embedding-model text-embedding-3-large\n```\n\n\n**Important Notes:**\n- For LoLLMs: Make sure the specified models are installed in your LoLLMs instance\n- For Ollama: Make sure the specified models are installed in your Ollama instance\n- For OpenAI: Ensure you have set up your OPENAI_API_KEY environment variable\n- For Azure OpenAI: Build and configure your server as stated in the Prequisites section\n\nFor help on any server, use the --help flag:\n```bash\nlollms-lightrag-server --help\nollama-lightrag-server --help\nopenai-lightrag-server --help\nazure-openai-lightrag-server --help\n```\n\nNote: If you don't need the API functionality, you can install the base package without API support using:\n```bash\npip install lightrag-hku\n```\n\n## API Endpoints\n\nAll servers (LoLLMs, Ollama, OpenAI and Azure OpenAI) provide the same REST API endpoints for RAG functionality.\n\n### Query Endpoints\n\n#### POST /query\nQuery the RAG system with options for different search modes.\n\n```bash\ncurl -X POST \"http://localhost:9621/query\" \\\n    -H \"Content-Type: application/json\" \\\n    -d '{\"query\": \"Your question here\", \"mode\": \"hybrid\"}'\n```\n\n#### POST /query/stream\nStream responses from the RAG system.\n\n```bash\ncurl -X POST \"http://localhost:9621/query/stream\" \\\n    -H \"Content-Type: application/json\" \\\n    -d '{\"query\": \"Your question here\", \"mode\": \"hybrid\"}'\n```\n\n### Document Management Endpoints\n\n#### POST /documents/text\nInsert text directly into the RAG system.\n\n```bash\ncurl -X POST \"http://localhost:9621/documents/text\" \\\n    -H \"Content-Type: application/json\" \\\n    -d '{\"text\": \"Your text content here\", \"description\": \"Optional description\"}'\n```\n\n#### POST /documents/file\nUpload a single file to the RAG system.\n\n```bash\ncurl -X POST \"http://localhost:9621/documents/file\" \\\n    -F \"file=@/path/to/your/document.txt\" \\\n    -F \"description=Optional description\"\n```\n\n#### POST /documents/batch\nUpload multiple files at once.\n\n```bash\ncurl -X POST \"http://localhost:9621/documents/batch\" \\\n    -F \"files=@/path/to/doc1.txt\" \\\n    -F \"files=@/path/to/doc2.txt\"\n```\n\n#### DELETE /documents\nClear all documents from the RAG system.\n\n```bash\ncurl -X DELETE \"http://localhost:9621/documents\"\n```\n\n### Utility Endpoints\n\n#### GET /health\nCheck server health and configuration.\n\n```bash\ncurl \"http://localhost:9621/health\"\n```\n\n## Development\nContribute to the project: [Guide](contributor-readme.MD)\n\n### Running in Development Mode\n\nFor LoLLMs:\n```bash\nuvicorn lollms_lightrag_server:app --reload --port 9621\n```\n\nFor Ollama:\n```bash\nuvicorn ollama_lightrag_server:app --reload --port 9621\n```\n\nFor OpenAI:\n```bash\nuvicorn openai_lightrag_server:app --reload --port 9621\n```\nFor Azure OpenAI:\n```bash\nuvicorn azure_openai_lightrag_server:app --reload --port 9621\n```\n### API Documentation\n\nWhen any server is running, visit:\n- Swagger UI: http://localhost:9621/docs\n- ReDoc: http://localhost:9621/redoc\n\n### Testing API Endpoints\n\nYou can test the API endpoints using the provided curl commands or through the Swagger UI interface. Make sure to:\n1. Start the appropriate backend service (LoLLMs, Ollama, or OpenAI)\n2. Start the RAG server\n3. Upload some documents using the document management endpoints\n4. Query the system using the query endpoints\n\n### Important Features\n\n#### Automatic Document Vectorization\nWhen starting any of the servers with the `--input-dir` parameter, the system will automatically:\n1. Scan the specified directory for documents\n2. Check for existing vectorized content in the database\n3. Only vectorize new documents that aren't already in the database\n4. Make all content immediately available for RAG queries\n\nThis intelligent caching mechanism:\n- Prevents unnecessary re-vectorization of existing documents\n- Reduces startup time for subsequent runs\n- Preserves system resources\n- Maintains consistency across restarts\n\n### Example Usage\n\n#### LoLLMs RAG Server\n\n```bash\n# Start server with automatic document vectorization\n# Only new documents will be vectorized, existing ones will be loaded from cache\nlollms-lightrag-server --input-dir ./my_documents --port 8080\n```\n\n#### Ollama RAG Server\n\n```bash\n# Start server with automatic document vectorization\n# Previously vectorized documents will be loaded from the database\nollama-lightrag-server --input-dir ./my_documents --port 8080\n```\n\n#### OpenAI RAG Server\n\n```bash\n# Start server with automatic document vectorization\n# Existing documents are retrieved from cache, only new ones are processed\nopenai-lightrag-server --input-dir ./my_documents --port 9624\n```\n\n#### Azure OpenAI RAG Server\n\n```bash\n# Start server with automatic document vectorization\n# Existing documents are retrieved from cache, only new ones are processed\nazure-openai-lightrag-server --input-dir ./my_documents --port 9624\n```\n\n**Important Notes:**\n- The `--input-dir` parameter enables automatic document processing at startup\n- Documents already in the database are not re-vectorized\n- Only new documents in the input directory will be processed\n- This optimization significantly reduces startup time for subsequent runs\n- The working directory (`--working-dir`) stores the vectorized documents database\n\n## Star History\n\n<a href=\"https://star-history.com/#HKUDS/LightRAG&Date\">\n <picture>\n   <source media=\"(prefers-color-scheme: dark)\" srcset=\"https://api.star-history.com/svg?repos=HKUDS/LightRAG&type=Date&theme=dark\" />\n   <source media=\"(prefers-color-scheme: light)\" srcset=\"https://api.star-history.com/svg?repos=HKUDS/LightRAG&type=Date\" />\n   <img alt=\"Star History Chart\" src=\"https://api.star-history.com/svg?repos=HKUDS/LightRAG&type=Date\" />\n </picture>\n</a>\n\n## Contribution\n\nThank you to all our contributors!\n\n<a href=\"https://github.com/HKUDS/LightRAG/graphs/contributors\">\n  <img src=\"https://contrib.rocks/image?repo=HKUDS/LightRAG\" />\n</a>\n\n## ðŸŒŸCitation\n\n```python\n@article{guo2024lightrag,\ntitle={LightRAG: Simple and Fast Retrieval-Augmented Generation},\nauthor={Zirui Guo and Lianghao Xia and Yanhua Yu and Tu Ao and Chao Huang},\nyear={2024},\neprint={2410.05779},\narchivePrefix={arXiv},\nprimaryClass={cs.IR}\n}\n```\n**Thank you for your interest in our work!**\n"
        },
        {
          "name": "contributor-README.md",
          "type": "blob",
          "size": 0.5546875,
          "content": "# Handy Tips for Developers Who Want to Contribute to the Project\n## Pre-commit Hooks\nPlease ensure you have run pre-commit hooks before committing your changes.\n### Guides\n1. **Installing Pre-commit Hooks**:\n   - Install pre-commit using pip: `pip install pre-commit`\n   - Initialize pre-commit in your repository: `pre-commit install`\n   - Run pre-commit hooks: `pre-commit run --all-files`\n\n2. **Pre-commit Hooks Configuration**:\n   - Create a `.pre-commit-config.yaml` file in the root of your repository.\n   - Add your hooks to the `.pre-commit-config.yaml`file.\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "get_all_edges_nx.py",
          "type": "blob",
          "size": 1.2236328125,
          "content": "import networkx as nx\n\nG = nx.read_graphml(\"./dickensTestEmbedcall/graph_chunk_entity_relation.graphml\")\n\n\ndef get_all_edges_and_nodes(G):\n    # Get all edges and their properties\n    edges_with_properties = []\n    for u, v, data in G.edges(data=True):\n        edges_with_properties.append(\n            {\n                \"start\": u,\n                \"end\": v,\n                \"label\": data.get(\n                    \"label\", \"\"\n                ),  # Assuming 'label' is used for edge type\n                \"properties\": data,\n                \"start_node_properties\": G.nodes[u],\n                \"end_node_properties\": G.nodes[v],\n            }\n        )\n\n    return edges_with_properties\n\n\n# Example usage\nif __name__ == \"__main__\":\n    # Assume G is your NetworkX graph loaded from Neo4j\n\n    all_edges = get_all_edges_and_nodes(G)\n\n    # Print all edges and node properties\n    for edge in all_edges:\n        print(f\"Edge Label: {edge['label']}\")\n        print(f\"Edge Properties: {edge['properties']}\")\n        print(f\"Start Node: {edge['start']}\")\n        print(f\"Start Node Properties: {edge['start_node_properties']}\")\n        print(f\"End Node: {edge['end']}\")\n        print(f\"End Node Properties: {edge['end_node_properties']}\")\n        print(\"---\")\n"
        },
        {
          "name": "lightrag",
          "type": "tree",
          "content": null
        },
        {
          "name": "reproduce",
          "type": "tree",
          "content": null
        },
        {
          "name": "requirements.txt",
          "type": "blob",
          "size": 0.3427734375,
          "content": "accelerate\naioboto3\naiofiles\naiohttp\nasyncpg\n\n# database packages\ngraspologic\ngremlinpython\nhnswlib\nnano-vectordb\nneo4j\nnetworkx\n\nnumpy\nollama\nopenai\noracledb\npsycopg-pool\npsycopg[binary,pool]\npydantic\npymilvus\npymongo\npymysql\npython-dotenv\npyvis\nsetuptools\n# lmdeploy[all]\nsqlalchemy\ntenacity\n\n\n# LLM packages\ntiktoken\ntorch\ntqdm\ntransformers\nxxhash\n"
        },
        {
          "name": "setup.py",
          "type": "blob",
          "size": 3.6611328125,
          "content": "import setuptools\nfrom pathlib import Path\n\n\n# Reading the long description from README.md\ndef read_long_description():\n    try:\n        return Path(\"README.md\").read_text(encoding=\"utf-8\")\n    except FileNotFoundError:\n        return \"A description of LightRAG is currently unavailable.\"\n\n\n# Retrieving metadata from __init__.py\ndef retrieve_metadata():\n    vars2find = [\"__author__\", \"__version__\", \"__url__\"]\n    vars2readme = {}\n    try:\n        with open(\"./lightrag/__init__.py\") as f:\n            for line in f.readlines():\n                for v in vars2find:\n                    if line.startswith(v):\n                        line = (\n                            line.replace(\" \", \"\")\n                            .replace('\"', \"\")\n                            .replace(\"'\", \"\")\n                            .strip()\n                        )\n                        vars2readme[v] = line.split(\"=\")[1]\n    except FileNotFoundError:\n        raise FileNotFoundError(\"Metadata file './lightrag/__init__.py' not found.\")\n\n    # Checking if all required variables are found\n    missing_vars = [v for v in vars2find if v not in vars2readme]\n    if missing_vars:\n        raise ValueError(\n            f\"Missing required metadata variables in __init__.py: {missing_vars}\"\n        )\n\n    return vars2readme\n\n\n# Reading dependencies from requirements.txt\ndef read_requirements():\n    deps = []\n    try:\n        with open(\"./requirements.txt\") as f:\n            deps = [line.strip() for line in f if line.strip()]\n    except FileNotFoundError:\n        print(\n            \"Warning: 'requirements.txt' not found. No dependencies will be installed.\"\n        )\n    return deps\n\n\ndef read_api_requirements():\n    api_deps = []\n    try:\n        with open(\"./lightrag/api/requirements.txt\") as f:\n            api_deps = [line.strip() for line in f if line.strip()]\n    except FileNotFoundError:\n        print(\"Warning: API requirements.txt not found.\")\n    return api_deps\n\n\nmetadata = retrieve_metadata()\nlong_description = read_long_description()\nrequirements = read_requirements()\n\nsetuptools.setup(\n    name=\"lightrag-hku\",\n    url=metadata[\"__url__\"],\n    version=metadata[\"__version__\"],\n    author=metadata[\"__author__\"],\n    description=\"LightRAG: Simple and Fast Retrieval-Augmented Generation\",\n    long_description=long_description,\n    long_description_content_type=\"text/markdown\",\n    packages=setuptools.find_packages(\n        exclude=(\"tests*\", \"docs*\")\n    ),  # Automatically find packages\n    classifiers=[\n        \"Development Status :: 4 - Beta\",\n        \"Programming Language :: Python :: 3\",\n        \"License :: OSI Approved :: MIT License\",\n        \"Operating System :: OS Independent\",\n        \"Intended Audience :: Developers\",\n        \"Topic :: Software Development :: Libraries :: Python Modules\",\n    ],\n    python_requires=\">=3.9\",\n    install_requires=requirements,\n    include_package_data=True,  # Includes non-code files from MANIFEST.in\n    project_urls={  # Additional project metadata\n        \"Documentation\": metadata.get(\"__url__\", \"\"),\n        \"Source\": metadata.get(\"__url__\", \"\"),\n        \"Tracker\": f\"{metadata.get('__url__', '')}/issues\"\n        if metadata.get(\"__url__\")\n        else \"\",\n    },\n    extras_require={\n        \"api\": read_api_requirements(),  # API requirements as optional\n    },\n    entry_points={\n        \"console_scripts\": [\n            \"lollms-lightrag-server=lightrag.api.lollms_lightrag_server:main [api]\",\n            \"ollama-lightrag-server=lightrag.api.ollama_lightrag_server:main [api]\",\n            \"openai-lightrag-server=lightrag.api.openai_lightrag_server:main [api]\",\n            \"azure-openai-lightrag-server=lightrag.api.azure_openai_lightrag_server:main [api]\",\n        ],\n    },\n)\n"
        },
        {
          "name": "test.py",
          "type": "blob",
          "size": 1.109375,
          "content": "import os\nfrom lightrag import LightRAG, QueryParam\nfrom lightrag.llm import gpt_4o_mini_complete\n#########\n# Uncomment the below two lines if running in a jupyter notebook to handle the async nature of rag.insert()\n# import nest_asyncio\n# nest_asyncio.apply()\n#########\n\nWORKING_DIR = \"./dickens\"\n\nif not os.path.exists(WORKING_DIR):\n    os.mkdir(WORKING_DIR)\n\nrag = LightRAG(\n    working_dir=WORKING_DIR,\n    llm_model_func=gpt_4o_mini_complete,  # Use gpt_4o_mini_complete LLM model\n    # llm_model_func=gpt_4o_complete  # Optionally, use a stronger model\n)\n\nwith open(\"./dickens/book.txt\", \"r\", encoding=\"utf-8\") as f:\n    rag.insert(f.read())\n\n# Perform naive search\nprint(\n    rag.query(\"What are the top themes in this story?\", param=QueryParam(mode=\"naive\"))\n)\n\n# Perform local search\nprint(\n    rag.query(\"What are the top themes in this story?\", param=QueryParam(mode=\"local\"))\n)\n\n# Perform global search\nprint(\n    rag.query(\"What are the top themes in this story?\", param=QueryParam(mode=\"global\"))\n)\n\n# Perform hybrid search\nprint(\n    rag.query(\"What are the top themes in this story?\", param=QueryParam(mode=\"hybrid\"))\n)\n"
        },
        {
          "name": "test_chromadb.py",
          "type": "blob",
          "size": 3.513671875,
          "content": "import os\nimport asyncio\nfrom lightrag import LightRAG, QueryParam\nfrom lightrag.llm import gpt_4o_mini_complete, openai_embedding\nfrom lightrag.utils import EmbeddingFunc\nimport numpy as np\n\n#########\n# Uncomment the below two lines if running in a jupyter notebook to handle the async nature of rag.insert()\n# import nest_asyncio\n# nest_asyncio.apply()\n#########\nWORKING_DIR = \"./chromadb_test_dir\"\nif not os.path.exists(WORKING_DIR):\n    os.mkdir(WORKING_DIR)\n\n# ChromaDB Configuration\nCHROMADB_HOST = os.environ.get(\"CHROMADB_HOST\", \"localhost\")\nCHROMADB_PORT = int(os.environ.get(\"CHROMADB_PORT\", 8000))\nCHROMADB_AUTH_TOKEN = os.environ.get(\"CHROMADB_AUTH_TOKEN\", \"secret-token\")\nCHROMADB_AUTH_PROVIDER = os.environ.get(\n    \"CHROMADB_AUTH_PROVIDER\", \"chromadb.auth.token_authn.TokenAuthClientProvider\"\n)\nCHROMADB_AUTH_HEADER = os.environ.get(\"CHROMADB_AUTH_HEADER\", \"X-Chroma-Token\")\n\n# Embedding Configuration and Functions\nEMBEDDING_MODEL = os.environ.get(\"EMBEDDING_MODEL\", \"text-embedding-3-large\")\nEMBEDDING_MAX_TOKEN_SIZE = int(os.environ.get(\"EMBEDDING_MAX_TOKEN_SIZE\", 8192))\n\n# ChromaDB requires knowing the dimension of embeddings upfront when\n# creating a collection. The embedding dimension is model-specific\n# (e.g. text-embedding-3-large uses 3072 dimensions)\n# we dynamically determine it by running a test embedding\n# and then pass it to the ChromaDBStorage class\n\n\nasync def embedding_func(texts: list[str]) -> np.ndarray:\n    return await openai_embedding(\n        texts,\n        model=EMBEDDING_MODEL,\n    )\n\n\nasync def get_embedding_dimension():\n    test_text = [\"This is a test sentence.\"]\n    embedding = await embedding_func(test_text)\n    return embedding.shape[1]\n\n\nasync def create_embedding_function_instance():\n    # Get embedding dimension\n    embedding_dimension = await get_embedding_dimension()\n    # Create embedding function instance\n    return EmbeddingFunc(\n        embedding_dim=embedding_dimension,\n        max_token_size=EMBEDDING_MAX_TOKEN_SIZE,\n        func=embedding_func,\n    )\n\n\nasync def initialize_rag():\n    embedding_func_instance = await create_embedding_function_instance()\n\n    return LightRAG(\n        working_dir=WORKING_DIR,\n        llm_model_func=gpt_4o_mini_complete,\n        embedding_func=embedding_func_instance,\n        vector_storage=\"ChromaVectorDBStorage\",\n        log_level=\"DEBUG\",\n        embedding_batch_num=32,\n        vector_db_storage_cls_kwargs={\n            \"host\": CHROMADB_HOST,\n            \"port\": CHROMADB_PORT,\n            \"auth_token\": CHROMADB_AUTH_TOKEN,\n            \"auth_provider\": CHROMADB_AUTH_PROVIDER,\n            \"auth_header_name\": CHROMADB_AUTH_HEADER,\n            \"collection_settings\": {\n                \"hnsw:space\": \"cosine\",\n                \"hnsw:construction_ef\": 128,\n                \"hnsw:search_ef\": 128,\n                \"hnsw:M\": 16,\n                \"hnsw:batch_size\": 100,\n                \"hnsw:sync_threshold\": 1000,\n            },\n        },\n    )\n\n\n# Run the initialization\nrag = asyncio.run(initialize_rag())\n\n# with open(\"./dickens/book.txt\", \"r\", encoding=\"utf-8\") as f:\n#     rag.insert(f.read())\n\n# Perform naive search\nprint(\n    rag.query(\"What are the top themes in this story?\", param=QueryParam(mode=\"naive\"))\n)\n\n# Perform local search\nprint(\n    rag.query(\"What are the top themes in this story?\", param=QueryParam(mode=\"local\"))\n)\n\n# Perform global search\nprint(\n    rag.query(\"What are the top themes in this story?\", param=QueryParam(mode=\"global\"))\n)\n\n# Perform hybrid search\nprint(\n    rag.query(\"What are the top themes in this story?\", param=QueryParam(mode=\"hybrid\"))\n)\n"
        },
        {
          "name": "test_neo4j.py",
          "type": "blob",
          "size": 1.146484375,
          "content": "import os\nfrom lightrag import LightRAG, QueryParam\nfrom lightrag.llm import gpt_4o_mini_complete\n\n\n#########\n# Uncomment the below two lines if running in a jupyter notebook to handle the async nature of rag.insert()\n# import nest_asyncio\n# nest_asyncio.apply()\n#########\n\nWORKING_DIR = \"./local_neo4jWorkDir\"\n\nif not os.path.exists(WORKING_DIR):\n    os.mkdir(WORKING_DIR)\n\nrag = LightRAG(\n    working_dir=WORKING_DIR,\n    llm_model_func=gpt_4o_mini_complete,  # Use gpt_4o_mini_complete LLM model\n    graph_storage=\"Neo4JStorage\",\n    log_level=\"INFO\",\n    # llm_model_func=gpt_4o_complete  # Optionally, use a stronger model\n)\n\nwith open(\"./book.txt\") as f:\n    rag.insert(f.read())\n\n# Perform naive search\nprint(\n    rag.query(\"What are the top themes in this story?\", param=QueryParam(mode=\"naive\"))\n)\n\n# Perform local search\nprint(\n    rag.query(\"What are the top themes in this story?\", param=QueryParam(mode=\"local\"))\n)\n\n# Perform global search\nprint(\n    rag.query(\"What are the top themes in this story?\", param=QueryParam(mode=\"global\"))\n)\n\n# Perform hybrid search\nprint(\n    rag.query(\"What are the top themes in this story?\", param=QueryParam(mode=\"hybrid\"))\n)\n"
        }
      ]
    }
  ]
}