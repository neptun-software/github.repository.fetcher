{
  "metadata": {
    "timestamp": 1736561243698,
    "page": 231,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjI0MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "sivel/speedtest-cli",
      "stars": 13633,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.2265625,
          "content": "*.py[co]\n\n# Packages\n*.egg\n*.egg-info\ndist\nbuild\neggs\nparts\nbin\nvar\nsdist\ndevelop-eggs\n.installed.cfg\n\n# Installer logs\npip-log.txt\n\n# Unit test / coverage reports\n.coverage\n.tox\n\n#Translations\n*.mo\n\n#Mr Developer\n.mr.developer.cfg\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 1.34765625,
          "content": "language: python\nsudo: required\ndist: xenial\n\naddons:\n  apt:\n    sources:\n      - deadsnakes\n    packages:\n      - python2.4\n      - python2.5\n      - python2.6\n      - python3.2\n      - python3.3\n\nmatrix:\n  include:\n    - python: 2.7\n      env: TOXENV=flake8\n    - python: 2.7\n      env: TOXENV=py24\n    - python: 2.7\n      env: TOXENV=py25\n    - python: 2.7\n      env: TOXENV=py26\n    - python: 2.7\n      env: TOXENV=py27\n    - python: 2.7\n      env: TOXENV=py32\n    - python: 2.7\n      env: TOXENV=py33\n    - python: 3.4\n      env: TOXENV=py34\n    - python: 3.5\n      env: TOXENV=py35\n    - python: 3.6\n      env: TOXENV=py36\n    - python: 3.7\n      env: TOXENV=py37\n    - python: 3.8-dev\n      env: TOXENV=py38\n    - python: pypy\n      env: TOXENV=pypy\n      dist: trusty\n\nbefore_install:\n  - if [[ $(echo \"$TOXENV\" | egrep -c \"py35\") != 0 ]]; then pyenv global system 3.5; fi;\n\ninstall:\n  - if [[ $(echo \"$TOXENV\" | egrep -c \"py32\") != 0 ]]; then pip install setuptools==17.1.1; fi;\n  - if [[ $(echo \"$TOXENV\" | egrep -c \"(py2[45]|py3[12])\") != 0 ]]; then pip install virtualenv==1.7.2 tox==1.3; fi;\n  - if [[ $(echo \"$TOXENV\" | egrep -c \"(py26|py33)\") != 0 ]]; then pip install virtualenv==15.2.0 tox==2.9.1; fi;\n  - if [[ $(echo \"$TOXENV\" | egrep -c \"(py2[456]|py3[123])\") == 0 ]]; then pip install tox; fi;\n\n\n\nscript:\n  - tox\n\nnotifications:\n  email:\n    - matt@sivel.net\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 1.6318359375,
          "content": "# Pull Requests\n\n## Pull requests should be\n\n1. Made against the `devel` branch.\n1. Made from a git feature branch.\n\n## Pull requests will not be accepted that\n\n1. Are not made against the `devel` branch\n1. Are submitted from a branch named `devel`\n1. Do not pass pep8/pyflakes/flake8\n1. Do not work with Python 2.4-3.4 or pypy\n1. Add python modules not included with the Python standard library\n1. Are made by editing files via the GitHub website\n\n# Coding Guidelines\n\nIn general, I follow strict pep8 and pyflakes. All code must pass these tests. Since we support python 2.4-3.4 and pypy, pyflakes reports unknown names in python 3.  pyflakes is run in python 2.7 only in my tests.\n\n## Some other points\n\n1. Do not use `\\` for line continuations, long strings should be wrapped in `()`.  Imports should start a brand new line in the form of `from foo import...`\n1. String quoting should be done with single quotes `'`, except for situations where you would otherwise have to escape an internal single quote\n1. Docstrings should use three double quotes `\"\"\"`\n1. All functions, classes and modules should have docstrings following both the PEP257 and PEP8 standards\n1. Inline comments should only be used on code where it is not immediately obvious what the code achieves\n\n# Supported Python Versions\n\nAll code needs to support Python 2.4-3.4 and pypy.\n\n# Permitted Python Modules\n\nOnly modules included in the standard library are permitted for use in this application.  This application should not be dependent on any 3rd party modules that would need to be installed external to just Python itself.\n\n# Testing\n\nCurrently there are no unit tests, but they are planned.\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 11.091796875,
          "content": "\n                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"[]\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright [yyyy] [name of copyright owner]\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "MANIFEST.in",
          "type": "blob",
          "size": 0.0341796875,
          "content": "include LICENSE\ninclude README.rst\n"
        },
        {
          "name": "README.rst",
          "type": "blob",
          "size": 5.474609375,
          "content": "speedtest-cli\n=============\n\nCommand line interface for testing internet bandwidth using\nspeedtest.net\n\n.. image:: https://img.shields.io/pypi/v/speedtest-cli.svg\n        :target: https://pypi.python.org/pypi/speedtest-cli/\n        :alt: Latest Version\n.. image:: https://img.shields.io/travis/sivel/speedtest-cli.svg\n        :target: https://pypi.python.org/pypi/speedtest-cli/\n        :alt: Travis\n.. image:: https://img.shields.io/pypi/l/speedtest-cli.svg\n        :target: https://pypi.python.org/pypi/speedtest-cli/\n        :alt: License\n\nVersions\n--------\n\nspeedtest-cli works with Python 2.4-3.7\n\n.. image:: https://img.shields.io/pypi/pyversions/speedtest-cli.svg\n        :target: https://pypi.python.org/pypi/speedtest-cli/\n        :alt: Versions\n\nInstallation\n------------\n\npip / easy\\_install\n~~~~~~~~~~~~~~~~~~~\n\n::\n\n    pip install speedtest-cli\n\nor\n\n::\n\n    easy_install speedtest-cli\n\nGithub\n~~~~~~\n\n::\n\n    pip install git+https://github.com/sivel/speedtest-cli.git\n\nor\n\n::\n\n    git clone https://github.com/sivel/speedtest-cli.git\n    cd speedtest-cli\n    python setup.py install\n\nJust download (Like the way it used to be)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n::\n\n    wget -O speedtest-cli https://raw.githubusercontent.com/sivel/speedtest-cli/master/speedtest.py\n    chmod +x speedtest-cli\n\nor\n\n::\n\n    curl -Lo speedtest-cli https://raw.githubusercontent.com/sivel/speedtest-cli/master/speedtest.py\n    chmod +x speedtest-cli\n\nUsage\n-----\n\n::\n\n    $ speedtest-cli -h\n    usage: speedtest-cli [-h] [--no-download] [--no-upload] [--single] [--bytes]\n                         [--share] [--simple] [--csv]\n                         [--csv-delimiter CSV_DELIMITER] [--csv-header] [--json]\n                         [--list] [--server SERVER] [--exclude EXCLUDE]\n                         [--mini MINI] [--source SOURCE] [--timeout TIMEOUT]\n                         [--secure] [--no-pre-allocate] [--version]\n\n    Command line interface for testing internet bandwidth using speedtest.net.\n    --------------------------------------------------------------------------\n    https://github.com/sivel/speedtest-cli\n\n    optional arguments:\n      -h, --help            show this help message and exit\n      --no-download         Do not perform download test\n      --no-upload           Do not perform upload test\n      --single              Only use a single connection instead of multiple. This\n                            simulates a typical file transfer.\n      --bytes               Display values in bytes instead of bits. Does not\n                            affect the image generated by --share, nor output from\n                            --json or --csv\n      --share               Generate and provide a URL to the speedtest.net share\n                            results image, not displayed with --csv\n      --simple              Suppress verbose output, only show basic information\n      --csv                 Suppress verbose output, only show basic information\n                            in CSV format. Speeds listed in bit/s and not affected\n                            by --bytes\n      --csv-delimiter CSV_DELIMITER\n                            Single character delimiter to use in CSV output.\n                            Default \",\"\n      --csv-header          Print CSV headers\n      --json                Suppress verbose output, only show basic information\n                            in JSON format. Speeds listed in bit/s and not\n                            affected by --bytes\n      --list                Display a list of speedtest.net servers sorted by\n                            distance\n      --server SERVER       Specify a server ID to test against. Can be supplied\n                            multiple times\n      --exclude EXCLUDE     Exclude a server from selection. Can be supplied\n                            multiple times\n      --mini MINI           URL of the Speedtest Mini server\n      --source SOURCE       Source IP address to bind to\n      --timeout TIMEOUT     HTTP timeout in seconds. Default 10\n      --secure              Use HTTPS instead of HTTP when communicating with\n                            speedtest.net operated servers\n      --no-pre-allocate     Do not pre allocate upload data. Pre allocation is\n                            enabled by default to improve upload performance. To\n                            support systems with insufficient memory, use this\n                            option to avoid a MemoryError\n      --version             Show the version number and exit\n\n\nPython API\n----------\n\nSee the `wiki <https://github.com/sivel/speedtest-cli/wiki>`_.\n\n\nInconsistency\n-------------\n\nIt is not a goal of this application to be a reliable latency reporting tool.\n\nLatency reported by this tool should not be relied on as a value indicative of ICMP\nstyle latency. It is a relative value used for determining the lowest latency server\nfor performing the actual speed test against.\n\nThere is the potential for this tool to report results inconsistent with Speedtest.net.\nThere are several concepts to be aware of that factor into the potential inconsistency:\n\n1. Speedtest.net has migrated to using pure socket tests instead of HTTP based tests\n2. This application is written in Python\n3. Different versions of Python will execute certain parts of the code faster than others\n4. CPU and Memory capacity and speed will play a large part in inconsistency between\n   Speedtest.net and even other machines on the same network\n\nIssues relating to inconsistencies will be closed as wontfix and without\nadditional reason or context.\n"
        },
        {
          "name": "setup.cfg",
          "type": "blob",
          "size": 0.01953125,
          "content": "[wheel]\nuniversal=1\n"
        },
        {
          "name": "setup.py",
          "type": "blob",
          "size": 3.33984375,
          "content": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# Copyright 2012 Matt Martz\n# All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\nimport os\nimport re\nimport codecs\n\nfrom setuptools import setup\n\nhere = os.path.abspath(os.path.dirname(__file__))\n\n\n# Read the version number from a source file.\n# Why read it, and not import?\n# see https://groups.google.com/d/topic/pypa-dev/0PkjVpcxTzQ/discussion\ndef find_version(*file_paths):\n    # Open in Latin-1 so that we avoid encoding errors.\n    # Use codecs.open for Python 2 compatibility\n    try:\n        f = codecs.open(os.path.join(here, *file_paths), 'r', 'latin1')\n        version_file = f.read()\n        f.close()\n    except:\n        raise RuntimeError(\"Unable to find version string.\")\n\n    # The version line must have the form\n    # __version__ = 'ver'\n    version_match = re.search(r\"^__version__ = ['\\\"]([^'\\\"]*)['\\\"]\",\n                              version_file, re.M)\n    if version_match:\n        return version_match.group(1)\n    raise RuntimeError(\"Unable to find version string.\")\n\n\n# Get the long description from the relevant file\ntry:\n    f = codecs.open('README.rst', encoding='utf-8')\n    long_description = f.read()\n    f.close()\nexcept:\n    long_description = ''\n\n\nsetup(\n    name='speedtest-cli',\n    version=find_version('speedtest.py'),\n    description=('Command line interface for testing internet bandwidth using '\n                 'speedtest.net'),\n    long_description=long_description,\n    keywords='speedtest speedtest.net',\n    author='Matt Martz',\n    author_email='matt@sivel.net',\n    url='https://github.com/sivel/speedtest-cli',\n    license='Apache License, Version 2.0',\n    py_modules=['speedtest'],\n    entry_points={\n        'console_scripts': [\n            'speedtest=speedtest:main',\n            'speedtest-cli=speedtest:main'\n        ]\n    },\n    classifiers=[\n        'Development Status :: 5 - Production/Stable',\n        'Programming Language :: Python',\n        'Environment :: Console',\n        'License :: OSI Approved :: Apache Software License',\n        'Operating System :: OS Independent',\n        'Programming Language :: Python :: 2',\n        'Programming Language :: Python :: 2.4',\n        'Programming Language :: Python :: 2.5',\n        'Programming Language :: Python :: 2.6',\n        'Programming Language :: Python :: 2.7',\n        'Programming Language :: Python :: 3',\n        'Programming Language :: Python :: 3.1',\n        'Programming Language :: Python :: 3.2',\n        'Programming Language :: Python :: 3.3',\n        'Programming Language :: Python :: 3.4',\n        'Programming Language :: Python :: 3.5',\n        'Programming Language :: Python :: 3.6',\n        'Programming Language :: Python :: 3.7',\n        'Programming Language :: Python :: 3.8',\n        'Programming Language :: Python :: 3.9',\n        'Programming Language :: Python :: 3.10',\n    ]\n)\n"
        },
        {
          "name": "speedtest-cli.1",
          "type": "blob",
          "size": 2.9677734375,
          "content": ".TH \"speedtest-cli\" 1 \"2018-01-05\" \"speedtest-cli\"\n.SH NAME\nspeedtest\\-cli \\- Command line interface for testing internet bandwidth using speedtest.net\n.SH SYNOPSIS\n.B speedtest\\-cli\n[OPTION...]\n.SH DESCRIPTION\nSpeedtest.net is a web service for testing your broadband connection by downloading a file\nfrom a nearby speedtest.net server on the web. This tool allows you to access the service\nfrom the command line.\n\nSpeedtest mini is a version of the Speedtest.net server that you can host locally.\n\n.SH OPTIONS\nUsage: speedtest\\-cli [OPTION...]\n\n.B Help Options\n\n\\fB\\-h, \\-\\-help\\fR\n.RS\nDisplays usage for the tool.\n.RE\n\n.B Options\n\n\\fB\\-\\-no\\-download\\fR\n.RS\nDo not perform download test\n.RE\n\n\\fB\\-\\-no\\-upload\\fR\n.RS\nDo not perform upload test\n.RE\n\n\\fB\\-\\-single\\fR\n.RS\nOnly use a single connection instead of multiple. This simulates a typical file transfer.\n.RE\n\n\\fB\\-\\-bytes\\fR\n.RS\nDisplay values in bytes instead of bits. Does not affect the image generated by \\-\\-share, nor output from \\-\\-json or \\-\\-csv\n.RE\n\n\\fB\\-\\-share\\fR\n.RS\nGenerate and provide a URL to the speedtest.net share results image, not displayed with \\-\\-csv\n.RE\n\n\\fB\\-\\-simple\\fR\n.RS\nSuppress verbose output, only show basic information\n.RE\n\n\\fB\\-\\-csv\\fR\n.RS\nSuppress verbose output, only show basic information in CSV format. Speeds listed in bit/s and not affected by \\-\\-bytes\n.RE\n\n\\fB\\-\\-csv\\-delimiter CSV_DELIMITER\\fR\n.RS\nSingle character delimiter to use in CSV output. Default \",\"\n.RE\n\n\\fB\\-\\-csv\\-header\\fR\n.RS\nPrint CSV headers\n.RE\n\n\\fB\\-\\-json\\fR\n.RS\nSuppress verbose output, only show basic information in JSON format. Speeds listed in bit/s and not affected by \\-\\-bytes\n.RE\n\n\\fB\\-\\-list\\fR\n.RS\nDisplay a list of speedtest.net servers sorted by distance\n.RE\n\n\\fB\\-\\-server SERVER\\fR\n.RS\nSpecify a server ID to test against. Can be supplied multiple times\n.RE\n\n\\fB\\-\\-exclude EXCLUDE\\fR\n.RS\nExclude a server from selection. Can be supplied multiple times\n.RE\n\n\\fB\\-\\-mini MINI\\fR\n.RS\nURL of the Speedtest Mini server\n.RE\n\n\\fB\\-\\-source SOURCE\\fR\n.RS\nSource IP address to bind to\n.RE\n\n\\fB\\-\\-timeout TIMEOUT\\fR\n.RS\nHTTP timeout in seconds. Default 10\n.RE\n\n\\fB\\-\\-secure\\fR\n.RS\nUse HTTPS instead of HTTP when communicating with speedtest.net operated servers\n.RE\n\n\\fB\\-\\-no\\-pre\\-allocate\\fR\n.RS\nDo not pre allocate upload data. Pre allocation is enabled by default to improve upload performance. To support systems with insufficient memory, use this option to avoid a MemoryError\n.RE\n\n\\fB\\-\\-version\\fR\n.RS\nShow the version number and exit\n.RE\n\n.SH EXAMPLES\n\n\\fBAutomatically find closest server and start testing\\fR\n.RS\nspeedtest\\-cli\n.RE\n\n\\fBSpecify testing against server 1491\\fR\n.RS\nspeedtest-cli \\-\\-server 1491\n.RE\n\n\\fBTesting against Speedtest Mini\\fR\n.RS\nspeedtest-cli \\-\\-mini 172.18.66.1\n.RE\n\n.SH REPORTING BUGS\nPlease file issues on the Github bug tracker: https://github.com/sivel/speedtest\\-cli\n\n.SH AUTHORS\nThis manual page was written by Jonathan Carter <jonathan@ubuntu.com>\nSpeedtest\\-cli was written by Matt Martz <matt@sivel.net>\n"
        },
        {
          "name": "speedtest.py",
          "type": "blob",
          "size": 63.802734375,
          "content": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# Copyright 2012 Matt Martz\n# All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\nimport csv\nimport datetime\nimport errno\nimport math\nimport os\nimport platform\nimport re\nimport signal\nimport socket\nimport sys\nimport threading\nimport timeit\nimport xml.parsers.expat\n\ntry:\n    import gzip\n    GZIP_BASE = gzip.GzipFile\nexcept ImportError:\n    gzip = None\n    GZIP_BASE = object\n\n__version__ = '2.1.4b1'\n\n\nclass FakeShutdownEvent(object):\n    \"\"\"Class to fake a threading.Event.isSet so that users of this module\n    are not required to register their own threading.Event()\n    \"\"\"\n\n    @staticmethod\n    def isSet():\n        \"Dummy method to always return false\"\"\"\n        return False\n\n    is_set = isSet\n\n\n# Some global variables we use\nDEBUG = False\n_GLOBAL_DEFAULT_TIMEOUT = object()\nPY25PLUS = sys.version_info[:2] >= (2, 5)\nPY26PLUS = sys.version_info[:2] >= (2, 6)\nPY32PLUS = sys.version_info[:2] >= (3, 2)\nPY310PLUS = sys.version_info[:2] >= (3, 10)\n\n# Begin import game to handle Python 2 and Python 3\ntry:\n    import json\nexcept ImportError:\n    try:\n        import simplejson as json\n    except ImportError:\n        json = None\n\ntry:\n    import xml.etree.ElementTree as ET\n    try:\n        from xml.etree.ElementTree import _Element as ET_Element\n    except ImportError:\n        pass\nexcept ImportError:\n    from xml.dom import minidom as DOM\n    from xml.parsers.expat import ExpatError\n    ET = None\n\ntry:\n    from urllib2 import (urlopen, Request, HTTPError, URLError,\n                         AbstractHTTPHandler, ProxyHandler,\n                         HTTPDefaultErrorHandler, HTTPRedirectHandler,\n                         HTTPErrorProcessor, OpenerDirector)\nexcept ImportError:\n    from urllib.request import (urlopen, Request, HTTPError, URLError,\n                                AbstractHTTPHandler, ProxyHandler,\n                                HTTPDefaultErrorHandler, HTTPRedirectHandler,\n                                HTTPErrorProcessor, OpenerDirector)\n\ntry:\n    from httplib import HTTPConnection, BadStatusLine\nexcept ImportError:\n    from http.client import HTTPConnection, BadStatusLine\n\ntry:\n    from httplib import HTTPSConnection\nexcept ImportError:\n    try:\n        from http.client import HTTPSConnection\n    except ImportError:\n        HTTPSConnection = None\n\ntry:\n    from httplib import FakeSocket\nexcept ImportError:\n    FakeSocket = None\n\ntry:\n    from Queue import Queue\nexcept ImportError:\n    from queue import Queue\n\ntry:\n    from urlparse import urlparse\nexcept ImportError:\n    from urllib.parse import urlparse\n\ntry:\n    from urlparse import parse_qs\nexcept ImportError:\n    try:\n        from urllib.parse import parse_qs\n    except ImportError:\n        from cgi import parse_qs\n\ntry:\n    from hashlib import md5\nexcept ImportError:\n    from md5 import md5\n\ntry:\n    from argparse import ArgumentParser as ArgParser\n    from argparse import SUPPRESS as ARG_SUPPRESS\n    PARSER_TYPE_INT = int\n    PARSER_TYPE_STR = str\n    PARSER_TYPE_FLOAT = float\nexcept ImportError:\n    from optparse import OptionParser as ArgParser\n    from optparse import SUPPRESS_HELP as ARG_SUPPRESS\n    PARSER_TYPE_INT = 'int'\n    PARSER_TYPE_STR = 'string'\n    PARSER_TYPE_FLOAT = 'float'\n\ntry:\n    from cStringIO import StringIO\n    BytesIO = None\nexcept ImportError:\n    try:\n        from StringIO import StringIO\n        BytesIO = None\n    except ImportError:\n        from io import StringIO, BytesIO\n\ntry:\n    import __builtin__\nexcept ImportError:\n    import builtins\n    from io import TextIOWrapper, FileIO\n\n    class _Py3Utf8Output(TextIOWrapper):\n        \"\"\"UTF-8 encoded wrapper around stdout for py3, to override\n        ASCII stdout\n        \"\"\"\n        def __init__(self, f, **kwargs):\n            buf = FileIO(f.fileno(), 'w')\n            super(_Py3Utf8Output, self).__init__(\n                buf,\n                encoding='utf8',\n                errors='strict'\n            )\n\n        def write(self, s):\n            super(_Py3Utf8Output, self).write(s)\n            self.flush()\n\n    _py3_print = getattr(builtins, 'print')\n    try:\n        _py3_utf8_stdout = _Py3Utf8Output(sys.stdout)\n        _py3_utf8_stderr = _Py3Utf8Output(sys.stderr)\n    except OSError:\n        # sys.stdout/sys.stderr is not a compatible stdout/stderr object\n        # just use it and hope things go ok\n        _py3_utf8_stdout = sys.stdout\n        _py3_utf8_stderr = sys.stderr\n\n    def to_utf8(v):\n        \"\"\"No-op encode to utf-8 for py3\"\"\"\n        return v\n\n    def print_(*args, **kwargs):\n        \"\"\"Wrapper function for py3 to print, with a utf-8 encoded stdout\"\"\"\n        if kwargs.get('file') == sys.stderr:\n            kwargs['file'] = _py3_utf8_stderr\n        else:\n            kwargs['file'] = kwargs.get('file', _py3_utf8_stdout)\n        _py3_print(*args, **kwargs)\nelse:\n    del __builtin__\n\n    def to_utf8(v):\n        \"\"\"Encode value to utf-8 if possible for py2\"\"\"\n        try:\n            return v.encode('utf8', 'strict')\n        except AttributeError:\n            return v\n\n    def print_(*args, **kwargs):\n        \"\"\"The new-style print function for Python 2.4 and 2.5.\n\n        Taken from https://pypi.python.org/pypi/six/\n\n        Modified to set encoding to UTF-8 always, and to flush after write\n        \"\"\"\n        fp = kwargs.pop(\"file\", sys.stdout)\n        if fp is None:\n            return\n\n        def write(data):\n            if not isinstance(data, basestring):\n                data = str(data)\n            # If the file has an encoding, encode unicode with it.\n            encoding = 'utf8'  # Always trust UTF-8 for output\n            if (isinstance(fp, file) and\n                    isinstance(data, unicode) and\n                    encoding is not None):\n                errors = getattr(fp, \"errors\", None)\n                if errors is None:\n                    errors = \"strict\"\n                data = data.encode(encoding, errors)\n            fp.write(data)\n            fp.flush()\n        want_unicode = False\n        sep = kwargs.pop(\"sep\", None)\n        if sep is not None:\n            if isinstance(sep, unicode):\n                want_unicode = True\n            elif not isinstance(sep, str):\n                raise TypeError(\"sep must be None or a string\")\n        end = kwargs.pop(\"end\", None)\n        if end is not None:\n            if isinstance(end, unicode):\n                want_unicode = True\n            elif not isinstance(end, str):\n                raise TypeError(\"end must be None or a string\")\n        if kwargs:\n            raise TypeError(\"invalid keyword arguments to print()\")\n        if not want_unicode:\n            for arg in args:\n                if isinstance(arg, unicode):\n                    want_unicode = True\n                    break\n        if want_unicode:\n            newline = unicode(\"\\n\")\n            space = unicode(\" \")\n        else:\n            newline = \"\\n\"\n            space = \" \"\n        if sep is None:\n            sep = space\n        if end is None:\n            end = newline\n        for i, arg in enumerate(args):\n            if i:\n                write(sep)\n            write(arg)\n        write(end)\n\n# Exception \"constants\" to support Python 2 through Python 3\ntry:\n    import ssl\n    try:\n        CERT_ERROR = (ssl.CertificateError,)\n    except AttributeError:\n        CERT_ERROR = tuple()\n\n    HTTP_ERRORS = (\n        (HTTPError, URLError, socket.error, ssl.SSLError, BadStatusLine) +\n        CERT_ERROR\n    )\nexcept ImportError:\n    ssl = None\n    HTTP_ERRORS = (HTTPError, URLError, socket.error, BadStatusLine)\n\nif PY32PLUS:\n    etree_iter = ET.Element.iter\nelif PY25PLUS:\n    etree_iter = ET_Element.getiterator\n\nif PY26PLUS:\n    thread_is_alive = threading.Thread.is_alive\nelse:\n    thread_is_alive = threading.Thread.isAlive\n\n\ndef event_is_set(event):\n    try:\n        return event.is_set()\n    except AttributeError:\n        return event.isSet()\n\n\nclass SpeedtestException(Exception):\n    \"\"\"Base exception for this module\"\"\"\n\n\nclass SpeedtestCLIError(SpeedtestException):\n    \"\"\"Generic exception for raising errors during CLI operation\"\"\"\n\n\nclass SpeedtestHTTPError(SpeedtestException):\n    \"\"\"Base HTTP exception for this module\"\"\"\n\n\nclass SpeedtestConfigError(SpeedtestException):\n    \"\"\"Configuration XML is invalid\"\"\"\n\n\nclass SpeedtestServersError(SpeedtestException):\n    \"\"\"Servers XML is invalid\"\"\"\n\n\nclass ConfigRetrievalError(SpeedtestHTTPError):\n    \"\"\"Could not retrieve config.php\"\"\"\n\n\nclass ServersRetrievalError(SpeedtestHTTPError):\n    \"\"\"Could not retrieve speedtest-servers.php\"\"\"\n\n\nclass InvalidServerIDType(SpeedtestException):\n    \"\"\"Server ID used for filtering was not an integer\"\"\"\n\n\nclass NoMatchedServers(SpeedtestException):\n    \"\"\"No servers matched when filtering\"\"\"\n\n\nclass SpeedtestMiniConnectFailure(SpeedtestException):\n    \"\"\"Could not connect to the provided speedtest mini server\"\"\"\n\n\nclass InvalidSpeedtestMiniServer(SpeedtestException):\n    \"\"\"Server provided as a speedtest mini server does not actually appear\n    to be a speedtest mini server\n    \"\"\"\n\n\nclass ShareResultsConnectFailure(SpeedtestException):\n    \"\"\"Could not connect to speedtest.net API to POST results\"\"\"\n\n\nclass ShareResultsSubmitFailure(SpeedtestException):\n    \"\"\"Unable to successfully POST results to speedtest.net API after\n    connection\n    \"\"\"\n\n\nclass SpeedtestUploadTimeout(SpeedtestException):\n    \"\"\"testlength configuration reached during upload\n    Used to ensure the upload halts when no additional data should be sent\n    \"\"\"\n\n\nclass SpeedtestBestServerFailure(SpeedtestException):\n    \"\"\"Unable to determine best server\"\"\"\n\n\nclass SpeedtestMissingBestServer(SpeedtestException):\n    \"\"\"get_best_server not called or not able to determine best server\"\"\"\n\n\ndef create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n                      source_address=None):\n    \"\"\"Connect to *address* and return the socket object.\n\n    Convenience function.  Connect to *address* (a 2-tuple ``(host,\n    port)``) and return the socket object.  Passing the optional\n    *timeout* parameter will set the timeout on the socket instance\n    before attempting to connect.  If no *timeout* is supplied, the\n    global default timeout setting returned by :func:`getdefaulttimeout`\n    is used.  If *source_address* is set it must be a tuple of (host, port)\n    for the socket to bind as a source address before making the connection.\n    An host of '' or port 0 tells the OS to use the default.\n\n    Largely vendored from Python 2.7, modified to work with Python 2.4\n    \"\"\"\n\n    host, port = address\n    err = None\n    for res in socket.getaddrinfo(host, port, 0, socket.SOCK_STREAM):\n        af, socktype, proto, canonname, sa = res\n        sock = None\n        try:\n            sock = socket.socket(af, socktype, proto)\n            if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n                sock.settimeout(float(timeout))\n            if source_address:\n                sock.bind(source_address)\n            sock.connect(sa)\n            return sock\n\n        except socket.error:\n            err = get_exception()\n            if sock is not None:\n                sock.close()\n\n    if err is not None:\n        raise err\n    else:\n        raise socket.error(\"getaddrinfo returns an empty list\")\n\n\nclass SpeedtestHTTPConnection(HTTPConnection):\n    \"\"\"Custom HTTPConnection to support source_address across\n    Python 2.4 - Python 3\n    \"\"\"\n    def __init__(self, *args, **kwargs):\n        source_address = kwargs.pop('source_address', None)\n        timeout = kwargs.pop('timeout', 10)\n\n        self._tunnel_host = None\n\n        HTTPConnection.__init__(self, *args, **kwargs)\n\n        self.source_address = source_address\n        self.timeout = timeout\n\n    def connect(self):\n        \"\"\"Connect to the host and port specified in __init__.\"\"\"\n        try:\n            self.sock = socket.create_connection(\n                (self.host, self.port),\n                self.timeout,\n                self.source_address\n            )\n        except (AttributeError, TypeError):\n            self.sock = create_connection(\n                (self.host, self.port),\n                self.timeout,\n                self.source_address\n            )\n\n        if self._tunnel_host:\n            self._tunnel()\n\n\nif HTTPSConnection:\n    class SpeedtestHTTPSConnection(HTTPSConnection):\n        \"\"\"Custom HTTPSConnection to support source_address across\n        Python 2.4 - Python 3\n        \"\"\"\n        default_port = 443\n\n        def __init__(self, *args, **kwargs):\n            source_address = kwargs.pop('source_address', None)\n            timeout = kwargs.pop('timeout', 10)\n\n            self._tunnel_host = None\n\n            HTTPSConnection.__init__(self, *args, **kwargs)\n\n            self.timeout = timeout\n            self.source_address = source_address\n\n        def connect(self):\n            \"Connect to a host on a given (SSL) port.\"\n            try:\n                self.sock = socket.create_connection(\n                    (self.host, self.port),\n                    self.timeout,\n                    self.source_address\n                )\n            except (AttributeError, TypeError):\n                self.sock = create_connection(\n                    (self.host, self.port),\n                    self.timeout,\n                    self.source_address\n                )\n\n            if self._tunnel_host:\n                self._tunnel()\n\n            if ssl:\n                try:\n                    kwargs = {}\n                    if hasattr(ssl, 'SSLContext'):\n                        if self._tunnel_host:\n                            kwargs['server_hostname'] = self._tunnel_host\n                        else:\n                            kwargs['server_hostname'] = self.host\n                    self.sock = self._context.wrap_socket(self.sock, **kwargs)\n                except AttributeError:\n                    self.sock = ssl.wrap_socket(self.sock)\n                    try:\n                        self.sock.server_hostname = self.host\n                    except AttributeError:\n                        pass\n            elif FakeSocket:\n                # Python 2.4/2.5 support\n                try:\n                    self.sock = FakeSocket(self.sock, socket.ssl(self.sock))\n                except AttributeError:\n                    raise SpeedtestException(\n                        'This version of Python does not support HTTPS/SSL '\n                        'functionality'\n                    )\n            else:\n                raise SpeedtestException(\n                    'This version of Python does not support HTTPS/SSL '\n                    'functionality'\n                )\n\n\ndef _build_connection(connection, source_address, timeout, context=None):\n    \"\"\"Cross Python 2.4 - Python 3 callable to build an ``HTTPConnection`` or\n    ``HTTPSConnection`` with the args we need\n\n    Called from ``http(s)_open`` methods of ``SpeedtestHTTPHandler`` or\n    ``SpeedtestHTTPSHandler``\n    \"\"\"\n    def inner(host, **kwargs):\n        kwargs.update({\n            'source_address': source_address,\n            'timeout': timeout\n        })\n        if context:\n            kwargs['context'] = context\n        return connection(host, **kwargs)\n    return inner\n\n\nclass SpeedtestHTTPHandler(AbstractHTTPHandler):\n    \"\"\"Custom ``HTTPHandler`` that can build a ``HTTPConnection`` with the\n    args we need for ``source_address`` and ``timeout``\n    \"\"\"\n    def __init__(self, debuglevel=0, source_address=None, timeout=10):\n        AbstractHTTPHandler.__init__(self, debuglevel)\n        self.source_address = source_address\n        self.timeout = timeout\n\n    def http_open(self, req):\n        return self.do_open(\n            _build_connection(\n                SpeedtestHTTPConnection,\n                self.source_address,\n                self.timeout\n            ),\n            req\n        )\n\n    http_request = AbstractHTTPHandler.do_request_\n\n\nclass SpeedtestHTTPSHandler(AbstractHTTPHandler):\n    \"\"\"Custom ``HTTPSHandler`` that can build a ``HTTPSConnection`` with the\n    args we need for ``source_address`` and ``timeout``\n    \"\"\"\n    def __init__(self, debuglevel=0, context=None, source_address=None,\n                 timeout=10):\n        AbstractHTTPHandler.__init__(self, debuglevel)\n        self._context = context\n        self.source_address = source_address\n        self.timeout = timeout\n\n    def https_open(self, req):\n        return self.do_open(\n            _build_connection(\n                SpeedtestHTTPSConnection,\n                self.source_address,\n                self.timeout,\n                context=self._context,\n            ),\n            req\n        )\n\n    https_request = AbstractHTTPHandler.do_request_\n\n\ndef build_opener(source_address=None, timeout=10):\n    \"\"\"Function similar to ``urllib2.build_opener`` that will build\n    an ``OpenerDirector`` with the explicit handlers we want,\n    ``source_address`` for binding, ``timeout`` and our custom\n    `User-Agent`\n    \"\"\"\n\n    printer('Timeout set to %d' % timeout, debug=True)\n\n    if source_address:\n        source_address_tuple = (source_address, 0)\n        printer('Binding to source address: %r' % (source_address_tuple,),\n                debug=True)\n    else:\n        source_address_tuple = None\n\n    handlers = [\n        ProxyHandler(),\n        SpeedtestHTTPHandler(source_address=source_address_tuple,\n                             timeout=timeout),\n        SpeedtestHTTPSHandler(source_address=source_address_tuple,\n                              timeout=timeout),\n        HTTPDefaultErrorHandler(),\n        HTTPRedirectHandler(),\n        HTTPErrorProcessor()\n    ]\n\n    opener = OpenerDirector()\n    opener.addheaders = [('User-agent', build_user_agent())]\n\n    for handler in handlers:\n        opener.add_handler(handler)\n\n    return opener\n\n\nclass GzipDecodedResponse(GZIP_BASE):\n    \"\"\"A file-like object to decode a response encoded with the gzip\n    method, as described in RFC 1952.\n\n    Largely copied from ``xmlrpclib``/``xmlrpc.client`` and modified\n    to work for py2.4-py3\n    \"\"\"\n    def __init__(self, response):\n        # response doesn't support tell() and read(), required by\n        # GzipFile\n        if not gzip:\n            raise SpeedtestHTTPError('HTTP response body is gzip encoded, '\n                                     'but gzip support is not available')\n        IO = BytesIO or StringIO\n        self.io = IO()\n        while 1:\n            chunk = response.read(1024)\n            if len(chunk) == 0:\n                break\n            self.io.write(chunk)\n        self.io.seek(0)\n        gzip.GzipFile.__init__(self, mode='rb', fileobj=self.io)\n\n    def close(self):\n        try:\n            gzip.GzipFile.close(self)\n        finally:\n            self.io.close()\n\n\ndef get_exception():\n    \"\"\"Helper function to work with py2.4-py3 for getting the current\n    exception in a try/except block\n    \"\"\"\n    return sys.exc_info()[1]\n\n\ndef distance(origin, destination):\n    \"\"\"Determine distance between 2 sets of [lat,lon] in km\"\"\"\n\n    lat1, lon1 = origin\n    lat2, lon2 = destination\n    radius = 6371  # km\n\n    dlat = math.radians(lat2 - lat1)\n    dlon = math.radians(lon2 - lon1)\n    a = (math.sin(dlat / 2) * math.sin(dlat / 2) +\n         math.cos(math.radians(lat1)) *\n         math.cos(math.radians(lat2)) * math.sin(dlon / 2) *\n         math.sin(dlon / 2))\n    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n    d = radius * c\n\n    return d\n\n\ndef build_user_agent():\n    \"\"\"Build a Mozilla/5.0 compatible User-Agent string\"\"\"\n\n    ua_tuple = (\n        'Mozilla/5.0',\n        '(%s; U; %s; en-us)' % (platform.platform(),\n                                platform.architecture()[0]),\n        'Python/%s' % platform.python_version(),\n        '(KHTML, like Gecko)',\n        'speedtest-cli/%s' % __version__\n    )\n    user_agent = ' '.join(ua_tuple)\n    printer('User-Agent: %s' % user_agent, debug=True)\n    return user_agent\n\n\ndef build_request(url, data=None, headers=None, bump='0', secure=False):\n    \"\"\"Build a urllib2 request object\n\n    This function automatically adds a User-Agent header to all requests\n\n    \"\"\"\n\n    if not headers:\n        headers = {}\n\n    if url[0] == ':':\n        scheme = ('http', 'https')[bool(secure)]\n        schemed_url = '%s%s' % (scheme, url)\n    else:\n        schemed_url = url\n\n    if '?' in url:\n        delim = '&'\n    else:\n        delim = '?'\n\n    # WHO YOU GONNA CALL? CACHE BUSTERS!\n    final_url = '%s%sx=%s.%s' % (schemed_url, delim,\n                                 int(timeit.time.time() * 1000),\n                                 bump)\n\n    headers.update({\n        'Cache-Control': 'no-cache',\n    })\n\n    printer('%s %s' % (('GET', 'POST')[bool(data)], final_url),\n            debug=True)\n\n    return Request(final_url, data=data, headers=headers)\n\n\ndef catch_request(request, opener=None):\n    \"\"\"Helper function to catch common exceptions encountered when\n    establishing a connection with a HTTP/HTTPS request\n\n    \"\"\"\n\n    if opener:\n        _open = opener.open\n    else:\n        _open = urlopen\n\n    try:\n        uh = _open(request)\n        if request.get_full_url() != uh.geturl():\n            printer('Redirected to %s' % uh.geturl(), debug=True)\n        return uh, False\n    except HTTP_ERRORS:\n        e = get_exception()\n        return None, e\n\n\ndef get_response_stream(response):\n    \"\"\"Helper function to return either a Gzip reader if\n    ``Content-Encoding`` is ``gzip`` otherwise the response itself\n\n    \"\"\"\n\n    try:\n        getheader = response.headers.getheader\n    except AttributeError:\n        getheader = response.getheader\n\n    if getheader('content-encoding') == 'gzip':\n        return GzipDecodedResponse(response)\n\n    return response\n\n\ndef get_attributes_by_tag_name(dom, tag_name):\n    \"\"\"Retrieve an attribute from an XML document and return it in a\n    consistent format\n\n    Only used with xml.dom.minidom, which is likely only to be used\n    with python versions older than 2.5\n    \"\"\"\n    elem = dom.getElementsByTagName(tag_name)[0]\n    return dict(list(elem.attributes.items()))\n\n\ndef print_dots(shutdown_event):\n    \"\"\"Built in callback function used by Thread classes for printing\n    status\n    \"\"\"\n    def inner(current, total, start=False, end=False):\n        if event_is_set(shutdown_event):\n            return\n\n        sys.stdout.write('.')\n        if current + 1 == total and end is True:\n            sys.stdout.write('\\n')\n        sys.stdout.flush()\n    return inner\n\n\ndef do_nothing(*args, **kwargs):\n    pass\n\n\nclass HTTPDownloader(threading.Thread):\n    \"\"\"Thread class for retrieving a URL\"\"\"\n\n    def __init__(self, i, request, start, timeout, opener=None,\n                 shutdown_event=None):\n        threading.Thread.__init__(self)\n        self.request = request\n        self.result = [0]\n        self.starttime = start\n        self.timeout = timeout\n        self.i = i\n        if opener:\n            self._opener = opener.open\n        else:\n            self._opener = urlopen\n\n        if shutdown_event:\n            self._shutdown_event = shutdown_event\n        else:\n            self._shutdown_event = FakeShutdownEvent()\n\n    def run(self):\n        try:\n            if (timeit.default_timer() - self.starttime) <= self.timeout:\n                f = self._opener(self.request)\n                while (not event_is_set(self._shutdown_event) and\n                        (timeit.default_timer() - self.starttime) <=\n                        self.timeout):\n                    self.result.append(len(f.read(10240)))\n                    if self.result[-1] == 0:\n                        break\n                f.close()\n        except IOError:\n            pass\n        except HTTP_ERRORS:\n            pass\n\n\nclass HTTPUploaderData(object):\n    \"\"\"File like object to improve cutting off the upload once the timeout\n    has been reached\n    \"\"\"\n\n    def __init__(self, length, start, timeout, shutdown_event=None):\n        self.length = length\n        self.start = start\n        self.timeout = timeout\n\n        if shutdown_event:\n            self._shutdown_event = shutdown_event\n        else:\n            self._shutdown_event = FakeShutdownEvent()\n\n        self._data = None\n\n        self.total = [0]\n\n    def pre_allocate(self):\n        chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        multiplier = int(round(int(self.length) / 36.0))\n        IO = BytesIO or StringIO\n        try:\n            self._data = IO(\n                ('content1=%s' %\n                 (chars * multiplier)[0:int(self.length) - 9]\n                 ).encode()\n            )\n        except MemoryError:\n            raise SpeedtestCLIError(\n                'Insufficient memory to pre-allocate upload data. Please '\n                'use --no-pre-allocate'\n            )\n\n    @property\n    def data(self):\n        if not self._data:\n            self.pre_allocate()\n        return self._data\n\n    def read(self, n=10240):\n        if ((timeit.default_timer() - self.start) <= self.timeout and\n                not event_is_set(self._shutdown_event)):\n            chunk = self.data.read(n)\n            self.total.append(len(chunk))\n            return chunk\n        else:\n            raise SpeedtestUploadTimeout()\n\n    def __len__(self):\n        return self.length\n\n\nclass HTTPUploader(threading.Thread):\n    \"\"\"Thread class for putting a URL\"\"\"\n\n    def __init__(self, i, request, start, size, timeout, opener=None,\n                 shutdown_event=None):\n        threading.Thread.__init__(self)\n        self.request = request\n        self.request.data.start = self.starttime = start\n        self.size = size\n        self.result = 0\n        self.timeout = timeout\n        self.i = i\n\n        if opener:\n            self._opener = opener.open\n        else:\n            self._opener = urlopen\n\n        if shutdown_event:\n            self._shutdown_event = shutdown_event\n        else:\n            self._shutdown_event = FakeShutdownEvent()\n\n    def run(self):\n        request = self.request\n        try:\n            if ((timeit.default_timer() - self.starttime) <= self.timeout and\n                    not event_is_set(self._shutdown_event)):\n                try:\n                    f = self._opener(request)\n                except TypeError:\n                    # PY24 expects a string or buffer\n                    # This also causes issues with Ctrl-C, but we will concede\n                    # for the moment that Ctrl-C on PY24 isn't immediate\n                    request = build_request(self.request.get_full_url(),\n                                            data=request.data.read(self.size))\n                    f = self._opener(request)\n                f.read(11)\n                f.close()\n                self.result = sum(self.request.data.total)\n            else:\n                self.result = 0\n        except (IOError, SpeedtestUploadTimeout):\n            self.result = sum(self.request.data.total)\n        except HTTP_ERRORS:\n            self.result = 0\n\n\nclass SpeedtestResults(object):\n    \"\"\"Class for holding the results of a speedtest, including:\n\n    Download speed\n    Upload speed\n    Ping/Latency to test server\n    Data about server that the test was run against\n\n    Additionally this class can return a result data as a dictionary or CSV,\n    as well as submit a POST of the result data to the speedtest.net API\n    to get a share results image link.\n    \"\"\"\n\n    def __init__(self, download=0, upload=0, ping=0, server=None, client=None,\n                 opener=None, secure=False):\n        self.download = download\n        self.upload = upload\n        self.ping = ping\n        if server is None:\n            self.server = {}\n        else:\n            self.server = server\n        self.client = client or {}\n\n        self._share = None\n        self.timestamp = '%sZ' % datetime.datetime.utcnow().isoformat()\n        self.bytes_received = 0\n        self.bytes_sent = 0\n\n        if opener:\n            self._opener = opener\n        else:\n            self._opener = build_opener()\n\n        self._secure = secure\n\n    def __repr__(self):\n        return repr(self.dict())\n\n    def share(self):\n        \"\"\"POST data to the speedtest.net API to obtain a share results\n        link\n        \"\"\"\n\n        if self._share:\n            return self._share\n\n        download = int(round(self.download / 1000.0, 0))\n        ping = int(round(self.ping, 0))\n        upload = int(round(self.upload / 1000.0, 0))\n\n        # Build the request to send results back to speedtest.net\n        # We use a list instead of a dict because the API expects parameters\n        # in a certain order\n        api_data = [\n            'recommendedserverid=%s' % self.server['id'],\n            'ping=%s' % ping,\n            'screenresolution=',\n            'promo=',\n            'download=%s' % download,\n            'screendpi=',\n            'upload=%s' % upload,\n            'testmethod=http',\n            'hash=%s' % md5(('%s-%s-%s-%s' %\n                             (ping, upload, download, '297aae72'))\n                            .encode()).hexdigest(),\n            'touchscreen=none',\n            'startmode=pingselect',\n            'accuracy=1',\n            'bytesreceived=%s' % self.bytes_received,\n            'bytessent=%s' % self.bytes_sent,\n            'serverid=%s' % self.server['id'],\n        ]\n\n        headers = {'Referer': 'http://c.speedtest.net/flash/speedtest.swf'}\n        request = build_request('://www.speedtest.net/api/api.php',\n                                data='&'.join(api_data).encode(),\n                                headers=headers, secure=self._secure)\n        f, e = catch_request(request, opener=self._opener)\n        if e:\n            raise ShareResultsConnectFailure(e)\n\n        response = f.read()\n        code = f.code\n        f.close()\n\n        if int(code) != 200:\n            raise ShareResultsSubmitFailure('Could not submit results to '\n                                            'speedtest.net')\n\n        qsargs = parse_qs(response.decode())\n        resultid = qsargs.get('resultid')\n        if not resultid or len(resultid) != 1:\n            raise ShareResultsSubmitFailure('Could not submit results to '\n                                            'speedtest.net')\n\n        self._share = 'http://www.speedtest.net/result/%s.png' % resultid[0]\n\n        return self._share\n\n    def dict(self):\n        \"\"\"Return dictionary of result data\"\"\"\n\n        return {\n            'download': self.download,\n            'upload': self.upload,\n            'ping': self.ping,\n            'server': self.server,\n            'timestamp': self.timestamp,\n            'bytes_sent': self.bytes_sent,\n            'bytes_received': self.bytes_received,\n            'share': self._share,\n            'client': self.client,\n        }\n\n    @staticmethod\n    def csv_header(delimiter=','):\n        \"\"\"Return CSV Headers\"\"\"\n\n        row = ['Server ID', 'Sponsor', 'Server Name', 'Timestamp', 'Distance',\n               'Ping', 'Download', 'Upload', 'Share', 'IP Address']\n        out = StringIO()\n        writer = csv.writer(out, delimiter=delimiter, lineterminator='')\n        writer.writerow([to_utf8(v) for v in row])\n        return out.getvalue()\n\n    def csv(self, delimiter=','):\n        \"\"\"Return data in CSV format\"\"\"\n\n        data = self.dict()\n        out = StringIO()\n        writer = csv.writer(out, delimiter=delimiter, lineterminator='')\n        row = [data['server']['id'], data['server']['sponsor'],\n               data['server']['name'], data['timestamp'],\n               data['server']['d'], data['ping'], data['download'],\n               data['upload'], self._share or '', self.client['ip']]\n        writer.writerow([to_utf8(v) for v in row])\n        return out.getvalue()\n\n    def json(self, pretty=False):\n        \"\"\"Return data in JSON format\"\"\"\n\n        kwargs = {}\n        if pretty:\n            kwargs.update({\n                'indent': 4,\n                'sort_keys': True\n            })\n        return json.dumps(self.dict(), **kwargs)\n\n\nclass Speedtest(object):\n    \"\"\"Class for performing standard speedtest.net testing operations\"\"\"\n\n    def __init__(self, config=None, source_address=None, timeout=10,\n                 secure=False, shutdown_event=None):\n        self.config = {}\n\n        self._source_address = source_address\n        self._timeout = timeout\n        self._opener = build_opener(source_address, timeout)\n\n        self._secure = secure\n\n        if shutdown_event:\n            self._shutdown_event = shutdown_event\n        else:\n            self._shutdown_event = FakeShutdownEvent()\n\n        self.get_config()\n        if config is not None:\n            self.config.update(config)\n\n        self.servers = {}\n        self.closest = []\n        self._best = {}\n\n        self.results = SpeedtestResults(\n            client=self.config['client'],\n            opener=self._opener,\n            secure=secure,\n        )\n\n    @property\n    def best(self):\n        if not self._best:\n            self.get_best_server()\n        return self._best\n\n    def get_config(self):\n        \"\"\"Download the speedtest.net configuration and return only the data\n        we are interested in\n        \"\"\"\n\n        headers = {}\n        if gzip:\n            headers['Accept-Encoding'] = 'gzip'\n        request = build_request('://www.speedtest.net/speedtest-config.php',\n                                headers=headers, secure=self._secure)\n        uh, e = catch_request(request, opener=self._opener)\n        if e:\n            raise ConfigRetrievalError(e)\n        configxml_list = []\n\n        stream = get_response_stream(uh)\n\n        while 1:\n            try:\n                configxml_list.append(stream.read(1024))\n            except (OSError, EOFError):\n                raise ConfigRetrievalError(get_exception())\n            if len(configxml_list[-1]) == 0:\n                break\n        stream.close()\n        uh.close()\n\n        if int(uh.code) != 200:\n            return None\n\n        configxml = ''.encode().join(configxml_list)\n\n        printer('Config XML:\\n%s' % configxml, debug=True)\n\n        try:\n            try:\n                root = ET.fromstring(configxml)\n            except ET.ParseError:\n                e = get_exception()\n                raise SpeedtestConfigError(\n                    'Malformed speedtest.net configuration: %s' % e\n                )\n            server_config = root.find('server-config').attrib\n            download = root.find('download').attrib\n            upload = root.find('upload').attrib\n            # times = root.find('times').attrib\n            client = root.find('client').attrib\n\n        except AttributeError:\n            try:\n                root = DOM.parseString(configxml)\n            except ExpatError:\n                e = get_exception()\n                raise SpeedtestConfigError(\n                    'Malformed speedtest.net configuration: %s' % e\n                )\n            server_config = get_attributes_by_tag_name(root, 'server-config')\n            download = get_attributes_by_tag_name(root, 'download')\n            upload = get_attributes_by_tag_name(root, 'upload')\n            # times = get_attributes_by_tag_name(root, 'times')\n            client = get_attributes_by_tag_name(root, 'client')\n\n        ignore_servers = [\n            int(i) for i in server_config['ignoreids'].split(',') if i\n        ]\n\n        ratio = int(upload['ratio'])\n        upload_max = int(upload['maxchunkcount'])\n        up_sizes = [32768, 65536, 131072, 262144, 524288, 1048576, 7340032]\n        sizes = {\n            'upload': up_sizes[ratio - 1:],\n            'download': [350, 500, 750, 1000, 1500, 2000, 2500,\n                         3000, 3500, 4000]\n        }\n\n        size_count = len(sizes['upload'])\n\n        upload_count = int(math.ceil(upload_max / size_count))\n\n        counts = {\n            'upload': upload_count,\n            'download': int(download['threadsperurl'])\n        }\n\n        threads = {\n            'upload': int(upload['threads']),\n            'download': int(server_config['threadcount']) * 2\n        }\n\n        length = {\n            'upload': int(upload['testlength']),\n            'download': int(download['testlength'])\n        }\n\n        self.config.update({\n            'client': client,\n            'ignore_servers': ignore_servers,\n            'sizes': sizes,\n            'counts': counts,\n            'threads': threads,\n            'length': length,\n            'upload_max': upload_count * size_count\n        })\n\n        try:\n            self.lat_lon = (float(client['lat']), float(client['lon']))\n        except ValueError:\n            raise SpeedtestConfigError(\n                'Unknown location: lat=%r lon=%r' %\n                (client.get('lat'), client.get('lon'))\n            )\n\n        printer('Config:\\n%r' % self.config, debug=True)\n\n        return self.config\n\n    def get_servers(self, servers=None, exclude=None):\n        \"\"\"Retrieve a the list of speedtest.net servers, optionally filtered\n        to servers matching those specified in the ``servers`` argument\n        \"\"\"\n        if servers is None:\n            servers = []\n\n        if exclude is None:\n            exclude = []\n\n        self.servers.clear()\n\n        for server_list in (servers, exclude):\n            for i, s in enumerate(server_list):\n                try:\n                    server_list[i] = int(s)\n                except ValueError:\n                    raise InvalidServerIDType(\n                        '%s is an invalid server type, must be int' % s\n                    )\n\n        urls = [\n            '://www.speedtest.net/speedtest-servers-static.php',\n            'http://c.speedtest.net/speedtest-servers-static.php',\n            '://www.speedtest.net/speedtest-servers.php',\n            'http://c.speedtest.net/speedtest-servers.php',\n        ]\n\n        headers = {}\n        if gzip:\n            headers['Accept-Encoding'] = 'gzip'\n\n        errors = []\n        for url in urls:\n            try:\n                request = build_request(\n                    '%s?threads=%s' % (url,\n                                       self.config['threads']['download']),\n                    headers=headers,\n                    secure=self._secure\n                )\n                uh, e = catch_request(request, opener=self._opener)\n                if e:\n                    errors.append('%s' % e)\n                    raise ServersRetrievalError()\n\n                stream = get_response_stream(uh)\n\n                serversxml_list = []\n                while 1:\n                    try:\n                        serversxml_list.append(stream.read(1024))\n                    except (OSError, EOFError):\n                        raise ServersRetrievalError(get_exception())\n                    if len(serversxml_list[-1]) == 0:\n                        break\n\n                stream.close()\n                uh.close()\n\n                if int(uh.code) != 200:\n                    raise ServersRetrievalError()\n\n                serversxml = ''.encode().join(serversxml_list)\n\n                printer('Servers XML:\\n%s' % serversxml, debug=True)\n\n                try:\n                    try:\n                        try:\n                            root = ET.fromstring(serversxml)\n                        except ET.ParseError:\n                            e = get_exception()\n                            raise SpeedtestServersError(\n                                'Malformed speedtest.net server list: %s' % e\n                            )\n                        elements = etree_iter(root, 'server')\n                    except AttributeError:\n                        try:\n                            root = DOM.parseString(serversxml)\n                        except ExpatError:\n                            e = get_exception()\n                            raise SpeedtestServersError(\n                                'Malformed speedtest.net server list: %s' % e\n                            )\n                        elements = root.getElementsByTagName('server')\n                except (SyntaxError, xml.parsers.expat.ExpatError):\n                    raise ServersRetrievalError()\n\n                for server in elements:\n                    try:\n                        attrib = server.attrib\n                    except AttributeError:\n                        attrib = dict(list(server.attributes.items()))\n\n                    if servers and int(attrib.get('id')) not in servers:\n                        continue\n\n                    if (int(attrib.get('id')) in self.config['ignore_servers']\n                            or int(attrib.get('id')) in exclude):\n                        continue\n\n                    try:\n                        d = distance(self.lat_lon,\n                                     (float(attrib.get('lat')),\n                                      float(attrib.get('lon'))))\n                    except Exception:\n                        continue\n\n                    attrib['d'] = d\n\n                    try:\n                        self.servers[d].append(attrib)\n                    except KeyError:\n                        self.servers[d] = [attrib]\n\n                break\n\n            except ServersRetrievalError:\n                continue\n\n        if (servers or exclude) and not self.servers:\n            raise NoMatchedServers()\n\n        return self.servers\n\n    def set_mini_server(self, server):\n        \"\"\"Instead of querying for a list of servers, set a link to a\n        speedtest mini server\n        \"\"\"\n\n        urlparts = urlparse(server)\n\n        name, ext = os.path.splitext(urlparts[2])\n        if ext:\n            url = os.path.dirname(server)\n        else:\n            url = server\n\n        request = build_request(url)\n        uh, e = catch_request(request, opener=self._opener)\n        if e:\n            raise SpeedtestMiniConnectFailure('Failed to connect to %s' %\n                                              server)\n        else:\n            text = uh.read()\n            uh.close()\n\n        extension = re.findall('upload_?[Ee]xtension: \"([^\"]+)\"',\n                               text.decode())\n        if not extension:\n            for ext in ['php', 'asp', 'aspx', 'jsp']:\n                try:\n                    f = self._opener.open(\n                        '%s/speedtest/upload.%s' % (url, ext)\n                    )\n                except Exception:\n                    pass\n                else:\n                    data = f.read().strip().decode()\n                    if (f.code == 200 and\n                            len(data.splitlines()) == 1 and\n                            re.match('size=[0-9]', data)):\n                        extension = [ext]\n                        break\n        if not urlparts or not extension:\n            raise InvalidSpeedtestMiniServer('Invalid Speedtest Mini Server: '\n                                             '%s' % server)\n\n        self.servers = [{\n            'sponsor': 'Speedtest Mini',\n            'name': urlparts[1],\n            'd': 0,\n            'url': '%s/speedtest/upload.%s' % (url.rstrip('/'), extension[0]),\n            'latency': 0,\n            'id': 0\n        }]\n\n        return self.servers\n\n    def get_closest_servers(self, limit=5):\n        \"\"\"Limit servers to the closest speedtest.net servers based on\n        geographic distance\n        \"\"\"\n\n        if not self.servers:\n            self.get_servers()\n\n        for d in sorted(self.servers.keys()):\n            for s in self.servers[d]:\n                self.closest.append(s)\n                if len(self.closest) == limit:\n                    break\n            else:\n                continue\n            break\n\n        printer('Closest Servers:\\n%r' % self.closest, debug=True)\n        return self.closest\n\n    def get_best_server(self, servers=None):\n        \"\"\"Perform a speedtest.net \"ping\" to determine which speedtest.net\n        server has the lowest latency\n        \"\"\"\n\n        if not servers:\n            if not self.closest:\n                servers = self.get_closest_servers()\n            servers = self.closest\n\n        if self._source_address:\n            source_address_tuple = (self._source_address, 0)\n        else:\n            source_address_tuple = None\n\n        user_agent = build_user_agent()\n\n        results = {}\n        for server in servers:\n            cum = []\n            url = os.path.dirname(server['url'])\n            stamp = int(timeit.time.time() * 1000)\n            latency_url = '%s/latency.txt?x=%s' % (url, stamp)\n            for i in range(0, 3):\n                this_latency_url = '%s.%s' % (latency_url, i)\n                printer('%s %s' % ('GET', this_latency_url),\n                        debug=True)\n                urlparts = urlparse(latency_url)\n                try:\n                    if urlparts[0] == 'https':\n                        h = SpeedtestHTTPSConnection(\n                            urlparts[1],\n                            source_address=source_address_tuple\n                        )\n                    else:\n                        h = SpeedtestHTTPConnection(\n                            urlparts[1],\n                            source_address=source_address_tuple\n                        )\n                    headers = {'User-Agent': user_agent}\n                    path = '%s?%s' % (urlparts[2], urlparts[4])\n                    start = timeit.default_timer()\n                    h.request(\"GET\", path, headers=headers)\n                    r = h.getresponse()\n                    total = (timeit.default_timer() - start)\n                except HTTP_ERRORS:\n                    e = get_exception()\n                    printer('ERROR: %r' % e, debug=True)\n                    cum.append(3600)\n                    continue\n\n                text = r.read(9)\n                if int(r.status) == 200 and text == 'test=test'.encode():\n                    cum.append(total)\n                else:\n                    cum.append(3600)\n                h.close()\n\n            avg = round((sum(cum) / 6) * 1000.0, 3)\n            results[avg] = server\n\n        try:\n            fastest = sorted(results.keys())[0]\n        except IndexError:\n            raise SpeedtestBestServerFailure('Unable to connect to servers to '\n                                             'test latency.')\n        best = results[fastest]\n        best['latency'] = fastest\n\n        self.results.ping = fastest\n        self.results.server = best\n\n        self._best.update(best)\n        printer('Best Server:\\n%r' % best, debug=True)\n        return best\n\n    def download(self, callback=do_nothing, threads=None):\n        \"\"\"Test download speed against speedtest.net\n\n        A ``threads`` value of ``None`` will fall back to those dictated\n        by the speedtest.net configuration\n        \"\"\"\n\n        urls = []\n        for size in self.config['sizes']['download']:\n            for _ in range(0, self.config['counts']['download']):\n                urls.append('%s/random%sx%s.jpg' %\n                            (os.path.dirname(self.best['url']), size, size))\n\n        request_count = len(urls)\n        requests = []\n        for i, url in enumerate(urls):\n            requests.append(\n                build_request(url, bump=i, secure=self._secure)\n            )\n\n        max_threads = threads or self.config['threads']['download']\n        in_flight = {'threads': 0}\n\n        def producer(q, requests, request_count):\n            for i, request in enumerate(requests):\n                thread = HTTPDownloader(\n                    i,\n                    request,\n                    start,\n                    self.config['length']['download'],\n                    opener=self._opener,\n                    shutdown_event=self._shutdown_event\n                )\n                while in_flight['threads'] >= max_threads:\n                    timeit.time.sleep(0.001)\n                thread.start()\n                q.put(thread, True)\n                in_flight['threads'] += 1\n                callback(i, request_count, start=True)\n\n        finished = []\n\n        def consumer(q, request_count):\n            _is_alive = thread_is_alive\n            while len(finished) < request_count:\n                thread = q.get(True)\n                while _is_alive(thread):\n                    thread.join(timeout=0.001)\n                in_flight['threads'] -= 1\n                finished.append(sum(thread.result))\n                callback(thread.i, request_count, end=True)\n\n        q = Queue(max_threads)\n        prod_thread = threading.Thread(target=producer,\n                                       args=(q, requests, request_count))\n        cons_thread = threading.Thread(target=consumer,\n                                       args=(q, request_count))\n        start = timeit.default_timer()\n        prod_thread.start()\n        cons_thread.start()\n        _is_alive = thread_is_alive\n        while _is_alive(prod_thread):\n            prod_thread.join(timeout=0.001)\n        while _is_alive(cons_thread):\n            cons_thread.join(timeout=0.001)\n\n        stop = timeit.default_timer()\n        self.results.bytes_received = sum(finished)\n        self.results.download = (\n            (self.results.bytes_received / (stop - start)) * 8.0\n        )\n        if self.results.download > 100000:\n            self.config['threads']['upload'] = 8\n        return self.results.download\n\n    def upload(self, callback=do_nothing, pre_allocate=True, threads=None):\n        \"\"\"Test upload speed against speedtest.net\n\n        A ``threads`` value of ``None`` will fall back to those dictated\n        by the speedtest.net configuration\n        \"\"\"\n\n        sizes = []\n\n        for size in self.config['sizes']['upload']:\n            for _ in range(0, self.config['counts']['upload']):\n                sizes.append(size)\n\n        # request_count = len(sizes)\n        request_count = self.config['upload_max']\n\n        requests = []\n        for i, size in enumerate(sizes):\n            # We set ``0`` for ``start`` and handle setting the actual\n            # ``start`` in ``HTTPUploader`` to get better measurements\n            data = HTTPUploaderData(\n                size,\n                0,\n                self.config['length']['upload'],\n                shutdown_event=self._shutdown_event\n            )\n            if pre_allocate:\n                data.pre_allocate()\n\n            headers = {'Content-length': size}\n            requests.append(\n                (\n                    build_request(self.best['url'], data, secure=self._secure,\n                                  headers=headers),\n                    size\n                )\n            )\n\n        max_threads = threads or self.config['threads']['upload']\n        in_flight = {'threads': 0}\n\n        def producer(q, requests, request_count):\n            for i, request in enumerate(requests[:request_count]):\n                thread = HTTPUploader(\n                    i,\n                    request[0],\n                    start,\n                    request[1],\n                    self.config['length']['upload'],\n                    opener=self._opener,\n                    shutdown_event=self._shutdown_event\n                )\n                while in_flight['threads'] >= max_threads:\n                    timeit.time.sleep(0.001)\n                thread.start()\n                q.put(thread, True)\n                in_flight['threads'] += 1\n                callback(i, request_count, start=True)\n\n        finished = []\n\n        def consumer(q, request_count):\n            _is_alive = thread_is_alive\n            while len(finished) < request_count:\n                thread = q.get(True)\n                while _is_alive(thread):\n                    thread.join(timeout=0.001)\n                in_flight['threads'] -= 1\n                finished.append(thread.result)\n                callback(thread.i, request_count, end=True)\n\n        q = Queue(threads or self.config['threads']['upload'])\n        prod_thread = threading.Thread(target=producer,\n                                       args=(q, requests, request_count))\n        cons_thread = threading.Thread(target=consumer,\n                                       args=(q, request_count))\n        start = timeit.default_timer()\n        prod_thread.start()\n        cons_thread.start()\n        _is_alive = thread_is_alive\n        while _is_alive(prod_thread):\n            prod_thread.join(timeout=0.1)\n        while _is_alive(cons_thread):\n            cons_thread.join(timeout=0.1)\n\n        stop = timeit.default_timer()\n        self.results.bytes_sent = sum(finished)\n        self.results.upload = (\n            (self.results.bytes_sent / (stop - start)) * 8.0\n        )\n        return self.results.upload\n\n\ndef ctrl_c(shutdown_event):\n    \"\"\"Catch Ctrl-C key sequence and set a SHUTDOWN_EVENT for our threaded\n    operations\n    \"\"\"\n    def inner(signum, frame):\n        shutdown_event.set()\n        printer('\\nCancelling...', error=True)\n        sys.exit(0)\n    return inner\n\n\ndef version():\n    \"\"\"Print the version\"\"\"\n\n    printer('speedtest-cli %s' % __version__)\n    printer('Python %s' % sys.version.replace('\\n', ''))\n    sys.exit(0)\n\n\ndef csv_header(delimiter=','):\n    \"\"\"Print the CSV Headers\"\"\"\n\n    printer(SpeedtestResults.csv_header(delimiter=delimiter))\n    sys.exit(0)\n\n\ndef parse_args():\n    \"\"\"Function to handle building and parsing of command line arguments\"\"\"\n    description = (\n        'Command line interface for testing internet bandwidth using '\n        'speedtest.net.\\n'\n        '------------------------------------------------------------'\n        '--------------\\n'\n        'https://github.com/sivel/speedtest-cli')\n\n    parser = ArgParser(description=description)\n    # Give optparse.OptionParser an `add_argument` method for\n    # compatibility with argparse.ArgumentParser\n    try:\n        parser.add_argument = parser.add_option\n    except AttributeError:\n        pass\n    parser.add_argument('--no-download', dest='download', default=True,\n                        action='store_const', const=False,\n                        help='Do not perform download test')\n    parser.add_argument('--no-upload', dest='upload', default=True,\n                        action='store_const', const=False,\n                        help='Do not perform upload test')\n    parser.add_argument('--single', default=False, action='store_true',\n                        help='Only use a single connection instead of '\n                             'multiple. This simulates a typical file '\n                             'transfer.')\n    parser.add_argument('--bytes', dest='units', action='store_const',\n                        const=('byte', 8), default=('bit', 1),\n                        help='Display values in bytes instead of bits. Does '\n                             'not affect the image generated by --share, nor '\n                             'output from --json or --csv')\n    parser.add_argument('--share', action='store_true',\n                        help='Generate and provide a URL to the speedtest.net '\n                             'share results image, not displayed with --csv')\n    parser.add_argument('--simple', action='store_true', default=False,\n                        help='Suppress verbose output, only show basic '\n                             'information')\n    parser.add_argument('--csv', action='store_true', default=False,\n                        help='Suppress verbose output, only show basic '\n                             'information in CSV format. Speeds listed in '\n                             'bit/s and not affected by --bytes')\n    parser.add_argument('--csv-delimiter', default=',', type=PARSER_TYPE_STR,\n                        help='Single character delimiter to use in CSV '\n                             'output. Default \",\"')\n    parser.add_argument('--csv-header', action='store_true', default=False,\n                        help='Print CSV headers')\n    parser.add_argument('--json', action='store_true', default=False,\n                        help='Suppress verbose output, only show basic '\n                             'information in JSON format. Speeds listed in '\n                             'bit/s and not affected by --bytes')\n    parser.add_argument('--list', action='store_true',\n                        help='Display a list of speedtest.net servers '\n                             'sorted by distance')\n    parser.add_argument('--server', type=PARSER_TYPE_INT, action='append',\n                        help='Specify a server ID to test against. Can be '\n                             'supplied multiple times')\n    parser.add_argument('--exclude', type=PARSER_TYPE_INT, action='append',\n                        help='Exclude a server from selection. Can be '\n                             'supplied multiple times')\n    parser.add_argument('--mini', help='URL of the Speedtest Mini server')\n    parser.add_argument('--source', help='Source IP address to bind to')\n    parser.add_argument('--timeout', default=10, type=PARSER_TYPE_FLOAT,\n                        help='HTTP timeout in seconds. Default 10')\n    parser.add_argument('--secure', action='store_true',\n                        help='Use HTTPS instead of HTTP when communicating '\n                             'with speedtest.net operated servers')\n    parser.add_argument('--no-pre-allocate', dest='pre_allocate',\n                        action='store_const', default=True, const=False,\n                        help='Do not pre allocate upload data. Pre allocation '\n                             'is enabled by default to improve upload '\n                             'performance. To support systems with '\n                             'insufficient memory, use this option to avoid a '\n                             'MemoryError')\n    parser.add_argument('--version', action='store_true',\n                        help='Show the version number and exit')\n    parser.add_argument('--debug', action='store_true',\n                        help=ARG_SUPPRESS, default=ARG_SUPPRESS)\n\n    options = parser.parse_args()\n    if isinstance(options, tuple):\n        args = options[0]\n    else:\n        args = options\n    return args\n\n\ndef validate_optional_args(args):\n    \"\"\"Check if an argument was provided that depends on a module that may\n    not be part of the Python standard library.\n\n    If such an argument is supplied, and the module does not exist, exit\n    with an error stating which module is missing.\n    \"\"\"\n    optional_args = {\n        'json': ('json/simplejson python module', json),\n        'secure': ('SSL support', HTTPSConnection),\n    }\n\n    for arg, info in optional_args.items():\n        if getattr(args, arg, False) and info[1] is None:\n            raise SystemExit('%s is not installed. --%s is '\n                             'unavailable' % (info[0], arg))\n\n\ndef printer(string, quiet=False, debug=False, error=False, **kwargs):\n    \"\"\"Helper function print a string with various features\"\"\"\n\n    if debug and not DEBUG:\n        return\n\n    if debug:\n        if sys.stdout.isatty():\n            out = '\\033[1;30mDEBUG: %s\\033[0m' % string\n        else:\n            out = 'DEBUG: %s' % string\n    else:\n        out = string\n\n    if error:\n        kwargs['file'] = sys.stderr\n\n    if not quiet:\n        print_(out, **kwargs)\n\n\ndef shell():\n    \"\"\"Run the full speedtest.net test\"\"\"\n\n    global DEBUG\n    shutdown_event = threading.Event()\n\n    signal.signal(signal.SIGINT, ctrl_c(shutdown_event))\n\n    args = parse_args()\n\n    # Print the version and exit\n    if args.version:\n        version()\n\n    if not args.download and not args.upload:\n        raise SpeedtestCLIError('Cannot supply both --no-download and '\n                                '--no-upload')\n\n    if len(args.csv_delimiter) != 1:\n        raise SpeedtestCLIError('--csv-delimiter must be a single character')\n\n    if args.csv_header:\n        csv_header(args.csv_delimiter)\n\n    validate_optional_args(args)\n\n    debug = getattr(args, 'debug', False)\n    if debug == 'SUPPRESSHELP':\n        debug = False\n    if debug:\n        DEBUG = True\n\n    if args.simple or args.csv or args.json:\n        quiet = True\n    else:\n        quiet = False\n\n    if args.csv or args.json:\n        machine_format = True\n    else:\n        machine_format = False\n\n    # Don't set a callback if we are running quietly\n    if quiet or debug:\n        callback = do_nothing\n    else:\n        callback = print_dots(shutdown_event)\n\n    printer('Retrieving speedtest.net configuration...', quiet)\n    try:\n        speedtest = Speedtest(\n            source_address=args.source,\n            timeout=args.timeout,\n            secure=args.secure\n        )\n    except (ConfigRetrievalError,) + HTTP_ERRORS:\n        printer('Cannot retrieve speedtest configuration', error=True)\n        raise SpeedtestCLIError(get_exception())\n\n    if args.list:\n        try:\n            speedtest.get_servers()\n        except (ServersRetrievalError,) + HTTP_ERRORS:\n            printer('Cannot retrieve speedtest server list', error=True)\n            raise SpeedtestCLIError(get_exception())\n\n        for _, servers in sorted(speedtest.servers.items()):\n            for server in servers:\n                line = ('%(id)5s) %(sponsor)s (%(name)s, %(country)s) '\n                        '[%(d)0.2f km]' % server)\n                try:\n                    printer(line)\n                except IOError:\n                    e = get_exception()\n                    if e.errno != errno.EPIPE:\n                        raise\n        sys.exit(0)\n\n    printer('Testing from %(isp)s (%(ip)s)...' % speedtest.config['client'],\n            quiet)\n\n    if not args.mini:\n        printer('Retrieving speedtest.net server list...', quiet)\n        try:\n            speedtest.get_servers(servers=args.server, exclude=args.exclude)\n        except NoMatchedServers:\n            raise SpeedtestCLIError(\n                'No matched servers: %s' %\n                ', '.join('%s' % s for s in args.server)\n            )\n        except (ServersRetrievalError,) + HTTP_ERRORS:\n            printer('Cannot retrieve speedtest server list', error=True)\n            raise SpeedtestCLIError(get_exception())\n        except InvalidServerIDType:\n            raise SpeedtestCLIError(\n                '%s is an invalid server type, must '\n                'be an int' % ', '.join('%s' % s for s in args.server)\n            )\n\n        if args.server and len(args.server) == 1:\n            printer('Retrieving information for the selected server...', quiet)\n        else:\n            printer('Selecting best server based on ping...', quiet)\n        speedtest.get_best_server()\n    elif args.mini:\n        speedtest.get_best_server(speedtest.set_mini_server(args.mini))\n\n    results = speedtest.results\n\n    printer('Hosted by %(sponsor)s (%(name)s) [%(d)0.2f km]: '\n            '%(latency)s ms' % results.server, quiet)\n\n    if args.download:\n        printer('Testing download speed', quiet,\n                end=('', '\\n')[bool(debug)])\n        speedtest.download(\n            callback=callback,\n            threads=(None, 1)[args.single]\n        )\n        printer('Download: %0.2f M%s/s' %\n                ((results.download / 1000.0 / 1000.0) / args.units[1],\n                 args.units[0]),\n                quiet)\n    else:\n        printer('Skipping download test', quiet)\n\n    if args.upload:\n        printer('Testing upload speed', quiet,\n                end=('', '\\n')[bool(debug)])\n        speedtest.upload(\n            callback=callback,\n            pre_allocate=args.pre_allocate,\n            threads=(None, 1)[args.single]\n        )\n        printer('Upload: %0.2f M%s/s' %\n                ((results.upload / 1000.0 / 1000.0) / args.units[1],\n                 args.units[0]),\n                quiet)\n    else:\n        printer('Skipping upload test', quiet)\n\n    printer('Results:\\n%r' % results.dict(), debug=True)\n\n    if not args.simple and args.share:\n        results.share()\n\n    if args.simple:\n        printer('Ping: %s ms\\nDownload: %0.2f M%s/s\\nUpload: %0.2f M%s/s' %\n                (results.ping,\n                 (results.download / 1000.0 / 1000.0) / args.units[1],\n                 args.units[0],\n                 (results.upload / 1000.0 / 1000.0) / args.units[1],\n                 args.units[0]))\n    elif args.csv:\n        printer(results.csv(delimiter=args.csv_delimiter))\n    elif args.json:\n        printer(results.json())\n\n    if args.share and not machine_format:\n        printer('Share results: %s' % results.share())\n\n\ndef main():\n    try:\n        shell()\n    except KeyboardInterrupt:\n        printer('\\nCancelling...', error=True)\n    except (SpeedtestException, SystemExit):\n        e = get_exception()\n        # Ignore a successful exit, or argparse exit\n        if getattr(e, 'code', 1) not in (0, 2):\n            msg = '%s' % e\n            if not msg:\n                msg = '%r' % e\n            raise SystemExit('ERROR: %s' % msg)\n\n\nif __name__ == '__main__':\n    main()\n"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "tox.ini",
          "type": "blob",
          "size": 0.4853515625,
          "content": "[tox]\nskipsdist=true\n\n[testenv]\ncommands =\n    {envpython} -V\n    {envpython} -m compileall speedtest.py\n    {envpython} speedtest.py\n    {envpython} speedtest.py --source 172.17.0.1\n    {envpython} tests/scripts/source.py\n\n[testenv:flake8]\nbasepython=python\ndeps=flake8\ncommands =\n    {envpython} -V\n    flake8 speedtest.py\n\n[testenv:pypy]\ncommands =\n    pypy -V\n    pypy -m compileall speedtest.py\n    pypy speedtest.py\n    pypy speedtest.py --source 172.17.0.1\n    pypy tests/scripts/source.py\n"
        }
      ]
    }
  ]
}