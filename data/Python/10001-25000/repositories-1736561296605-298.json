{
  "metadata": {
    "timestamp": 1736561296605,
    "page": 298,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjMwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "dagster-io/dagster",
      "stars": 12242,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".buildkite",
          "type": "tree",
          "content": null
        },
        {
          "name": ".dockerignore",
          "type": "blob",
          "size": 0.0986328125,
          "content": ".git/\n**/.tox/\n**/.yarn/\n**/__pycache__/\n**/*.egg-info/\n**/node_modules/\n**/*.pyc\n**/.next/\n**/venv/\n"
        },
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.0458984375,
          "content": "*.py diff=python\n**/uv.lock linguist-generated\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 2.291015625,
          "content": "# Byte-compiled / optimized / DLL files\n__pycache__/\n*.py[cod]\n*$py.class\n\n# C extensions\n*.so\n\n# Distribution / packaging\n.Python\nenv/\nbuild/\ndevelop-eggs/\ndist/\ndownloads/\neggs/\n.eggs/\nparts/\nsdist/\nvar/\nwheels/\n*.egg-info/\n.installed.cfg\n*.egg\n\n# PyInstaller\n#  Usually these files are written by a python script from a template\n#  before PyInstaller builds the exe, so as to inject date/other infos into it.\n*.manifest\n*.spec\n\n# Installer logs\npip-log.txt\npip-delete-this-directory.txt\n\n# Unit test / coverage reports\nhtmlcov/\n.tox/\n.coverage\n.coverage.*\n.cache\nnosetests.xml\ncoverage.xml\n*.cover\n.hypothesis/\nmlruns/\n\n# Translations\n*.mo\n*.pot\n\n# Django stuff:\n*.log\nlocal_settings.py\n\n# Flask stuff:\n.webassets-cache\n\n# Scrapy stuff:\n.scrapy\n\n# Sphinx documentation\ndocs/_build/\n\n# PyBuilder\ntarget/\n\n# Jupyter Notebook\n.ipynb_checkpoints\n\n# pyenv\n.python-version\n\n# celery beat schedule file\ncelerybeat-schedule\n\n# SageMath parsed files\n*.sage.py\n\n# dotenv\n.env\n.envrc\n\n# virtualenv\n.direnv/\n.venv\nvenv/\nENV/\nPipfile\nPipfile.lock\n\n# Spyder project settings\n.spyderproject\n.spyproject\n\n# Rope project settings\n.ropeproject\n\n# mkdocs documentation\n/site\n\n# ruff\n.ruff_cache/\n\n# mypy\n.mypy_cache/\n\ntags\n!python_modules/dagster/dagster/_core/definitions/tags\n\n.pytest_cache\n.DS_Store\n\ndocs/_build\npython_modules/dagster/docs/_build\n\ndagit_run_logs\n\npython_modules/libraries/dagster-aws/dagster_aws/ecs/config.yaml\n\npython_modules/dagster-webserver/node_modules/\npython_modules/dagster-webserver/yarn.lock\n\n# old dagit stuff\npython_modules/dagit/node_modules/\npython_modules/dagit/yarn.lock\njs_modules/dagit\n\n# Gatsby stuff\ndocs/gatsby/**/node_modules/\ndocs/gatsby/**/_build\ndocs/gatsby/**/public\n# Next stuff\ndocs/next/.mdx-data\ndocs/next/public/sitemap.xml\n# Data\ndata\n# Don't ignore data folders in examples\n!examples/*/data\n!examples/**/**/data\n\n# Dask\ndask-worker-space\n\n# PyCharm IDE Config files\n.idea/\n\n# Codemod bookmarks\n.codemod.bookmark\n\n# Examples outputs\nexamples/docs_snippets/docs_snippets/**/**/output/\nexamples/docs_snippets/docs_snippets/**/**/output/\nexamples/**/**/example.db\n\n# Telemetry instance id\n.telemetry\n\ntest_results.xml\n\n# GitHub Codespaces\npythonenv*/\n\n# Vim project-local settings\n.vim\n\n# DuckDB\n*.duckdb\n\n# PyRight config\npyrightconfig*\n\n# Scripts working directory\nscripts/.build\n\n# dbt .user files\n.user.yml\n"
        },
        {
          "name": ".gitpod.yml",
          "type": "blob",
          "size": 0.3330078125,
          "content": "tasks:\n- init: |\n    python3 -m venv /workspace/venv\n    source /workspace/venv/bin/activate\n    make dev_install\n    cd /workspace\n    zip -qr venv.zip venv\n    rm -fr venv\n- command: |\n    cd /workspace\n    unzip -q venv.zip\n    source /workspace/venv/bin/activate\n    cd /workspace/dagster\n\nports:\n  - port: 3000\n    onOpen: open-browser\n"
        },
        {
          "name": ".graphqlrc.yml",
          "type": "blob",
          "size": 0.1728515625,
          "content": "projects:\n  dagit:\n    schema: \"./js_modules/dagster-ui/packages/ui-core/src/graphql/schema.graphql\"\n    documents: \"./js_modules/dagster-ui/packages/ui-core/src/**/*.{ts,tsx}\"\n"
        },
        {
          "name": ".pre-commit-config.yaml",
          "type": "blob",
          "size": 0.97265625,
          "content": "default_stages: [pre-commit] # don't run on push by default\nrepos:\n- repo: local\n  hooks:\n  - id: ruff-format\n    name: Ruff Format\n    entry: ruff\n    args: [format]\n    language: system\n    pass_filenames: false\n  - id: ruff-lint\n    name: Ruff Lint\n    entry: ruff\n    args: [check, --fix, --exit-non-zero-on-fix]\n    language: system\n    pass_filenames: false\n  - id: docs-mdx-format\n    name: Format Docs\n    language: system\n    entry: bash -c \"cd docs && make mdx-format\"\n    pass_filenames: false\n    files: ^docs/content\n\n  # We do not use pyright's provided pre-commit hook because we need the environment management\n  # supplied by `scripts/run-pyright.py`.\n  - id: pyright\n    name: pyright\n    entry: make quick_pyright\n    stages: [pre-push]\n    # This means pre-commit will not try to install a new environment for this hook. It relies on\n    # having a pre-existing `make` installed (and scripts/run-pyright.py).\n    language: system\n    pass_filenames: false\n    types: [python]\n"
        },
        {
          "name": ".vscode",
          "type": "tree",
          "content": null
        },
        {
          "name": "CHANGES.md",
          "type": "blob",
          "size": 820.0732421875,
          "content": "# Changelog\n\n## 1.9.8 (core) / 0.25.8 (libraries)\n\n### Bugfixes\n\n- Fixed a bug with `load_assets_from_x` functions where we began erroring when a spec and AssetsDefinition had the same key in a given module. We now only error in this case if `include_specs=True`.\n- [dagster-azure] Fixed a bug in 1.9.6 and 1.9.7 where the default behavior of the compute log manager switched from showing logs in the UI to showing a URL. You can toggle the `show_url_only` option to `True` to enable the URL showing behavior.\n- [dagster-dbt] Fixed an issue where group names set on partitioned dbt assets created using the `@dbt_assets` decorator would be ignored\n\n# 1.9.7 (core) / 0.25.7 (libraries)\n\n### New\n\n- Added new function `load_definitions_from_module`, which can load all the assets, checks, schedules, sensors, and job objects within a module scope into a single Definitions object. Check out the documentation to learn more: https://docs.dagster.io/_apidocs/definitions#dagster.load_definitions_from_module.\n- Previously, asset backfills could only target selections of assets in which all assets had a `BackfillPolicy`, or none of them did. Mixed selections are now supported.\n- `AssetSpecs` may now contain a `partitions_def`. Different `AssetSpecs` passed to the same invocation of `@multi_asset` can now have different `PartitionsDefinitions`, as long as `can_subset=True`.\n- Added the option to use a thread pool to process backfills in parallel.\n- Exceptions that are raised when a schedule or sensor is writing to logs will now write an error message to stdout instead of failing the tick.\n- Added validation of `title` for asset backfills (not just for job backfills).\n- [ui] Design tweaks to the asset Automations tab.\n- [ui] Asset selection filtering is now case insensitive.\n- [ui] Add Teradata icon for kind tags.\n- [ui] When creating and editing alerts, when the form is in an invalid state, display the reason on the disabled buttons.\n- [ui] Add Automation history to asset checks.\n- [ui] Improve performance of Run page for very long-running runs.\n- [dagster-airbyte] The `airbyte_assets` decorator has been added. It can be used with the `AirbyteCloudWorkspace` resource and `DagsterAirbyteTranslator` translator to load Airbyte tables for a given connection as assets in Dagster. The `build_airbyte_assets_definitions` factory can be used to create assets for all the connections in your Airbyte workspace.\n- [dagster-airbyte] Airbyte Cloud assets can now be materialized using the `AirbyteCloudWorkspace.sync_and_poll(…)` method in the definition of a `@airbyte_assets` decorator.\n- [dagster-airlift] Airflow imports are now compatible with Airflow 1.\n- [dagster-aws] new `ecs_executor` which executes Dagster steps via AWS ECS tasks. This can be used in conjunction with `ECSRunLauncher`.\n- [dagster-dbt] `dbt-core>=1.9` is now supported.\n- [dagster-dbt] Adds SQL syntax highlighting to raw sql code in dbt asset descriptions.\n- [dagster-looker] `load_looker_asset_specs` and `build_looker_pdt_assets_definitions` are updated to accept an instance of `DagsterLookerApiTranslator` or custom subclass.\n- [dagster-looker] Type hints in the signature of `DagsterLookerApiTranslator.get_asset_spec` have been updated - the parameter `looker_structure` is now of type `LookerApiTranslatorStructureData` instead of `LookerStructureData`. Custom Looker API translators should be updated.\n- [dagster-powerbi] `load_powerbi_asset_specs` has been updated to accept an instance of `DagsterPowerBITranslator` or custom subclass.\n- [dagster-powerbi] Type hints in the signature of `DagsterPowerBITranslator.get_asset_spec` have been updated - the parameter `data` is now of type `PowerBITranslatorData` instead of `PowerBIContentData`. Custom Power BI translators should be updated.\n- [dagster-sigma] `load_sigma_asset_specs` has been updated to accept an instance of `DagsterSigmaTranslator` or a custom subclass.\n- [dagster-sigma] Type hints in the signature of `DagsterLookerApiTranslator.get_asset_spec` have been updated - the parameter `data` is now of type `Union[SigmaDatasetTranslatorData, SigmaWorkbookTranslatorData]` instead of `Union[SigmaDataset, SigmaWorkbook]`. Custom Looker API translators should be updated.\n- [dagster-sigma] Added the option to filter to specific workbooks in addition to folders.\n- [dagster-sigma] Added the option to skip fetching lineage for workbooks in cases where users want to build this information themselves.\n- [dagster-tableau] `load_tableau_asset_specs` has been updated to accept an instance of `DagsterTableauTranslator` or custom subclass.\n- [dagster-tableau] Type hints in the signature of `DagsterTableauTranslator.get_asset_spec` have been updated - the parameter `data` is now of type `TableauTranslatorData` instead of `TableauContentData`. Custom Tableau translators should be updated.\n\n### Bugfixes\n\n- Fixed an issue where sensor and schedule tick logs would accumulate disk over time on Dagster code servers.\n- [ui] Fixed an issue where the app sometimes loads with styles missing.\n- [ui] Fix search string highlighting in global search results.\n- Fixed a race condition where immediately after adding a new asset to the graph, a freshness check sensor targeting that asset might raise an InvalidSubsetError in its first one.\n- [ui] Fixed a bug where backfills launched by Declarative Automation were not being shown in the table of launched runs.\n- The `dagster-airlift` package erroneously introduced a dependency on `dagster`. This has been rectified - `dagster` is only required for the `dagster-airlift[core]` submodule.\n\n### Deprecations\n\n- Deprecation of `@multi_asset_sensor` has been rolled back.\n\n### Dagster Plus\n\n- Introduce the Catalog Viewer role for Users and Teams.\n- Slack, MS Teams, and email alerts for run failures will list the steps that were successful or not executed.\n- [experimental] The option `blobStorageSnapshotUploads` has been added which enables a new process for how definition snapshots are uploaded to Dagster Cloud.\n- Fixed a catalog search issue where exact prefix matches are not prioritized in the search results.\n- Fixed a bug with Insights metric customization.\n\n# 1.9.6 (core) / 0.25.6 (libraries)\n\n### New\n\n- Updated `cronitor` pin to allow versions `>= 5.0.1` to enable use of `DayOfWeek` as 7. Cronitor `4.0.0` is still disallowed. (Thanks, [@joshuataylor](https://github.com/joshuataylor)!)\n- Added flag `checkDbReadyInitContainer` to optionally disable db check initContainer.\n- Added job name filtering to increase the throughput for run status sensors that target jobs.\n- [ui] Added Google Drive icon for `kind` tags. (Thanks, [@dragos-pop](https://github.com/dragos-pop)!)\n- [ui] Renamed the run lineage sidebar on the Run details page to `Re-executions`.\n- [ui] Sensors and schedules that appear in the Runs page are now clickable.\n- [ui] Runs targeting assets now show more of the assets in the Runs page.\n- [dagster-airbyte] The destination type for an Airbyte asset is now added as a `kind` tag for display in the UI.\n- [dagster-gcp] `DataprocResource` now receives an optional parameter `labels` to be attached to Dataproc clusters. (Thanks, [@thiagoazcampos](https://github.com/thiagoazcampos)!)\n- [dagster-k8s] Added a `checkDbReadyInitContainer` flag to the Dagster Helm chart to allow disabling the default init container behavior. (Thanks, [@easontm](https://github.com/easontm)!)\n- [dagster-k8s] K8s pod logs are now logged when a pod fails. (Thanks, [@apetryla](https://github.com/apetryla)!)\n- [dagster-sigma] Introduced `build_materialize_workbook_assets_definition` which can be used to build assets that run materialize schedules for a Sigma workbook.\n- [dagster-snowflake] `SnowflakeResource` and `SnowflakeIOManager` both accept `additional_snowflake_connection_args` config. This dictionary of arguments will be passed to the `snowflake.connector.connect` method. This config will be ignored if you are using the `sqlalchemy` connector.\n- [helm] Added the ability to set user-deployments labels on k8s deployments as well as pods.\n\n### Bugfixes\n\n- Assets with self dependencies and `BackfillPolicy` are now evaluated correctly during backfills. Self dependent assets no longer result in serial partition submissions or disregarded upstream dependencies.\n- Previously, the freshness check sensor would not re-evaluate freshness checks if an in-flight run was planning on evaluating that check. Now, the freshness check sensor will kick off an independent run of the check, even if there's already an in flight run, as long as the freshness check can potentially fail.\n- Previously, if the freshness check was in a failing state, the sensor would wait for a run to update the freshness check before re-evaluating. Now, if there's a materialization later than the last evaluation of the freshness check and no planned evaluation, we will re-evaluate the freshness check automatically.\n- [ui] Fixed run log streaming for runs with a large volume of logs.\n- [ui] Fixed a bug in the Backfill Preview where a loading spinner would spin forever if an asset had no valid partitions targeted by the backfill.\n- [dagster-aws] `PipesCloudWatchMessageReader` correctly identifies streams which are not ready yet and doesn't fail on `ThrottlingException`. (Thanks, [@jenkoian](https://github.com/jenkoian)!)\n- [dagster-fivetran] Column metadata can now be fetched for Fivetran assets using `FivetranWorkspace.sync_and_poll(...).fetch_column_metadata()`.\n- [dagster-k8s] The k8s client now waits for the main container to be ready instead of only waiting for sidecar init containers. (Thanks, [@OrenLederman](https://github.com/OrenLederman)!)\n\n### Documentation\n\n- Fixed a typo in the `dlt_assets` API docs. (Thanks, [@zilto](https://github.com/zilto)!)\n\n# 1.9.5 (core) / 0.25.5 (libraries)\n\n### New\n\n- The automatic run retry daemon has been updated so that there is a single source of truth for if a run will be retried and if the retry has been launched. Tags are now added to run at failure time indicating if the run will be retried by the automatic retry system. Once the automatic retry has been launched, the run ID of the retry is added to the original run.\n- When canceling a backfill of a job, the backfill daemon will now cancel all runs launched by that backfill before marking the backfill as canceled.\n- Dagster execution info (tags such as `dagster/run-id`, `dagster/code-location`, `dagster/user` and Dagster Cloud environment variables) typically attached to external resources are now available under `DagsterRun.dagster_execution_info`.\n- `SensorReturnTypesUnion` is now exported for typing the output of sensor functions.\n- [dagster-dbt] dbt seeds now get a valid code version (Thanks [@marijncv](https://github.com/marijncv)!).\n- Manual and automatic retries of runs launched by backfills that occur while the backfill is still in progress are now incorporated into the backfill's status.\n- Manual retries of runs launched by backfills are no longer considered part of the backfill if the backfill is complete when the retry is launched.\n- [dagster-fivetran] Fivetran assets can now be materialized using the FivetranWorkspace.sync_and_poll(…) method in the definition of a `@fivetran_assets` decorator.\n- [dagster-fivetran] `load_fivetran_asset_specs` has been updated to accept an instance of `DagsterFivetranTranslator` or custom subclass.\n- [dagster-fivetran] The `fivetran_assets` decorator was added. It can be used with the `FivetranWorkspace` resource and `DagsterFivetranTranslator` translator to load Fivetran tables for a given connector as assets in Dagster. The `build_fivetran_assets_definitions` factory can be used to create assets for all the connectors in your Fivetran workspace.\n- [dagster-aws] `ECSPipesClient.run` now waits up to 70 days for tasks completion (waiter parameters are configurable) (Thanks [@jenkoian](https://github.com/jenkoian)!)\n- [dagster-dbt] Update dagster-dbt scaffold template to be compatible with uv (Thanks [@wingyplus](https://github.com/wingyplus)!).\n- [dagster-airbyte] A `load_airbyte_cloud_asset_specs` function has\n  been added. It can be used with the `AirbyteCloudWorkspace` resource and `DagsterAirbyteTranslator` translator to load your Airbyte Cloud connection streams as external assets in Dagster.\n- [ui] Add an icon for the `icechunk` kind.\n- [ui] Improved ui for manual sensor/schedule evaluation.\n\n### Bugfixes\n\n- Fixed database locking bug for the `ConsolidatedSqliteEventLogStorage`, which is mostly used for tests.\n- [dagster-aws] Fixed a bug in the ECSRunLauncher that prevented it from accepting a user-provided task definition when DAGSTER_CURRENT_IMAGE was not set in the code location.\n- [ui] Fixed an issue that would sometimes cause the asset graph to fail to render on initial load.\n- [ui] Fix global auto-materialize tick timeline when paginating.\n\n# 1.9.4 (core) / 0.25.4 (libraries)\n\n### New\n\n- Global op concurrency is now enabled on the default SQLite storage. Deployments that have not been migrated since `1.6.0` may need to run `dagster instance migrate` to enable.\n- Introduced `map_asset_specs` to enable modifying `AssetSpec`s and `AssetsDefinition`s in bulk.\n- Introduced `AssetSpec.replace_attributes` and `AssetSpec.merge_attributes` to easily alter properties of an asset spec.\n- [ui] Add a \"View logs\" button to open tick logs in the sensor tick history table.\n- [ui] Add Spanner kind icon.\n- [ui] The asset catalog now supports filtering using the asset selection syntax.\n- [dagster-pipes, dagster-aws] `PipesS3MessageReader` now has a new parameter `include_stdio_in_messages` which enables log forwarding to Dagster via Pipes messages.\n- [dagster-pipes] Experimental: A new Dagster Pipes message type `log_external_stream` has been added. It can be used to forward external logs to Dagster via Pipes messages.\n- [dagster-powerbi] Opts in to using admin scan APIs to pull data from a Power BI instance. This can be disabled by passing `load_powerbi_asset_specs(..., use_workspace_scan=False)`.\n- [dagster-sigma] Introduced an experimental `dagster-sigma snapshot` command, allowing Sigma workspaces to be captured to a file for faster subsequent loading.\n\n### Bugfixes\n\n- Fixed a bug that caused `DagsterExecutionStepNotFoundError` errors when trying to execute an asset check step of a run launched by a backfill.\n- Fixed an issue where invalid cron strings like \"0 0 30 2 \\*\" that represented invalid dates in February were still allowed as Dagster cron strings, but then failed during schedule execution. Now, these invalid cronstrings will raise an exception when they are first loaded.\n- Fixed a bug where `owners` added to `AssetOut`s when defining a `@graph_multi_asset` were not added to the underlying `AssetsDefinition`.\n- Fixed a bug where using the `&` or `|` operators on `AutomationCondition`s with labels would cause that label to be erased.\n- [ui] Launching partitioned asset jobs from the launchpad now warns if no partition is selected.\n- [ui] Fixed unnecessary middle truncation occurring in dialogs.\n- [ui] Fixed timestamp labels and \"Now\" line rendering bugs on the sensor tick timeline.\n- [ui] Opening Dagster's UI with a single job defined takes you to the Overview page rather than the Job page.\n- [ui] Fix stretched tags in backfill table view for non-partitioned assets.\n- [ui] Open automation sensor evaluation details in a dialog instead of navigating away.\n- [ui] Fix scrollbars in dark mode.\n- [dagster-sigma] Workbooks filtered using a `SigmaFilter` no longer fetch lineage information.\n- [dagster-powerbi] Fixed an issue where reports without an upstream dataset dependency would fail to translate to an asset spec.\n\n### Deprecations\n\n- [dagster-powerbi] `DagsterPowerBITranslator.get_asset_key` is deprecated in favor of `DagsterPowerBITranslator.get_asset_spec().key`\n- [dagster-looker] `DagsterLookerApiTranslator.get_asset_key` is deprecated in favor of `DagsterLookerApiTranslator.get_asset_spec().key`\n- [dagster-sigma] `DagsterSigmaTranslator.get_asset_key` is deprecated in favor of `DagsterSigmaTranslator.get_asset_spec().key`\n- [dagster-tableau] `DagsterTableauTranslator.get_asset_key` is deprecated in favor of `DagsterTableauTranslator.get_asset_spec().key`\n\n# 1.9.3 (core) / 0.25.3 (libraries)\n\n### New\n\n- Added `run_id` to the `run_tags` index to improve database performance. Run `dagster instance migrate` to update the index. (Thanks, [@HynekBlaha](https://github.com/HynekBlaha)!)\n- Added icons for `kind` tags: Cassandra, ClickHouse, CockroachDB, Doris, Druid, Elasticsearch, Flink, Hadoop, Impala, Kafka, MariaDB, MinIO, Pinot, Presto, Pulsar, RabbitMQ, Redis, Redpanda, ScyllaDB, Starrocks, and Superset. (Thanks, [@swrookie](https://github.com/swrookie)!)\n- Added a new icon for the Denodo kind tag. (Thanks, [@tintamarre](https://github.com/tintamarre)!)\n- Errors raised from defining more than one `Definitions` object at module scope now include the object names so that the source of the error is easier to determine.\n- [ui] Asset metadata entries like `dagster/row_count` now appear on the events page and are properly hidden on the overview page when they appear in the sidebar.\n- [dagster-aws] `PipesGlueClient` now attaches AWS Glue metadata to Dagster results produced during Pipes invocation.\n- [dagster-aws] `PipesEMRServerlessClient` now attaches AWS EMR Serverless metadata to Dagster results produced during Pipes invocation and adds Dagster tags to the job run.\n- [dagster-aws] `PipesECSClient` now attaches AWS ECS metadata to Dagster results produced during Pipes invocation and adds Dagster tags to the ECS task.\n- [dagster-aws] `PipesEMRClient` now attaches AWS EMR metadata to Dagster results produced during Pipes invocation.\n- [dagster-databricks] `PipesDatabricksClient` now attaches Databricks metadata to Dagster results produced during Pipes invocation and adds Dagster tags to the Databricks job.\n- [dagster-fivetran] Added `load_fivetran_asset_specs` function. It can be used with the `FivetranWorkspace` resource and `DagsterFivetranTranslator` translator to load your Fivetran connector tables as external assets in Dagster.\n- [dagster-looker] Errors are now handled more gracefully when parsing derived tables.\n- [dagster-sigma] Sigma assets now contain extra metadata and kind tags.\n- [dagster-sigma] Added support for direct workbook to warehouse table dependencies.\n- [dagster-sigma] Added `include_unused_datasets` field to `SigmaFilter` to disable pulling datasets that aren't used by a downstream workbook.\n- [dagster-sigma] Added `skip_fetch_column_data` option to skip loading Sigma column lineage. This can speed up loading large instances.\n- [dagster-sigma] Introduced an experimental `dagster-sigma snapshot` command, allowing Sigma workspaces to be captured to a file for faster subsequent loading.\n\n  ### Introducing: `dagster-airlift` (experimental)\n\n  `dagster-airlift` is coming out of stealth. See the initial Airlift RFC [here](https://github.com/dagster-io/dagster/discussions/25279), and the following documentation to learn more:\n\n  - A full [Airflow migration tutorial](https://docs.dagster.io/integrations/airlift/tutorial/overview).\n  - A tutorial on [federating between Airflow instances](https://docs.dagster.io/integrations/airlift/federation-tutorial/overview).\n\n  More Airflow-related content is coming soon! We'd love for you to check it out, and post any comments / questions in the `#airflow-migration` channel in the Dagster slack.\n\n### Bugfixes\n\n- Fixed a bug in run status sensors where setting incompatible arguments `monitor_all_code_locations` and `monitored_jobs` did not raise the expected error. (Thanks, [@apetryla](https://github.com/apetryla)!)\n- Fixed an issue that would cause the label for `AutomationCondition.any_deps_match()` and `AutomationCondition.all_deps_match()` to render incorrectly when `allow_selection` or `ignore_selection` were set.\n- Fixed a bug which could cause code location load errors when using `CacheableAssetsDefinitions` in code locations that contained `AutomationConditions`\n- Fixed an issue where the default multiprocess executor kept holding onto subprocesses after their step completed, potentially causing `Too many open files` errors for jobs with many steps.\n- [ui] Fixed an issue introduced in 1.9.2 where the backfill overview page would sometimes display extra assets that were targeted by the backfill.\n- [ui] Fixed \"Open in Launchpad\" button when testing a schedule or sensor by ensuring that it opens to the correct deployment.\n- [ui] Fixed an issue where switching a user setting was immediately saved, rather than waiting for the change to be confirmed.\n- [dagster-looker] Unions without unique/distinct criteria are now properly handled.\n- [dagster-powerbi] Fixed an issue where reports without an upstream dataset dependency would fail to translate to an asset spec.\n- [dagster-sigma] Fixed an issue where API fetches did not paginate properly.\n\n### Documentation\n\n- Added an [Airflow Federation Tutorial](https://docs.dagster.io/integrations/airlift/federation-tutorial/overview).\n- Added `dagster-dingtalk` to the list of [community supported libraries](https://docs.dagster.io/integrations#community-supported-libraries).\n- Fixed typos in the `dagster-wandb` (Weights and Biases) documentation. (Thanks, [@matt-weingarten](https://github.com/matt-weingarten)!)\n- Updated the [Role-based Access Control (RBAC)](https://docs.dagster.io/dagster-plus/account/managing-users/managing-user-roles-permissions) documentation.\n- Added additional information about filtering to the [`dagster-sigma`](https://docs.dagster.io/integrations/sigma) documentation.\n\n### Dagster Plus\n\n- [ui] Fixed an issue with filtering and catalog search in branch deployments.\n- [ui] Fixed an issue where the asset graph would reload unexpectedly.\n\n# 1.9.2 (core) / 0.25.2 (libraries)\n\n### New\n\n- Introduced a new constructor, `AssetOut.from_spec`, that will construct an `AssetOut` from an `AssetSpec`.\n- [ui] Column tags are now displayed in the `Column name` section of the asset overview page.\n- [ui] Introduced an icon for the `gcs` (Google Cloud Storage) kind tag.\n- [ui] Introduced icons for `report` and `semanticmodel` kind tags.\n- [ui] The tooltip for a tag containing a cron expression now shows a human-readable, timezone-aware cron string.\n- [ui] Asset check descriptions are now sourced from docstrings and rendered in the UI. (Thanks, [@marijncv](https://github.com/marijncv)!)\n- [dagster-aws] Added option to propagate tags to ECS tasks when using the `EcsRunLauncher`. (Thanks, [@zyd14](https://github.com/zyd14)!)\n- [dagster-dbt] You can now implement `DagsterDbtTranslator.get_code_version` to customize the code version for your dbt assets. (Thanks, [@Grzyblon](https://github.com/Grzyblon)!)\n- [dagster-pipes] Added the ability to pass arbitrary metadata to `PipesClientCompletedInvocation`. This metadata will be attached to all materializations and asset checks stored during the pipes invocation.\n- [dagster-powerbi] During a full workspace scan, owner and column metadata is now automatically attached to assets.\n\n### Bugfixes\n\n- Fixed an issue with `AutomationCondition.execution_in_progress` which would cause it to evaluate to `True` for unpartitioned assets that were part of a run that was in progress, even if the asset itself had already been materialized.\n- Fixed an issue with `AutomationCondition.run_in_progress` that would cause it to ignore queued runs.\n- Fixed an issue that would cause a `default_automation_condition_sensor` to be constructed for user code servers running on dagster version `< 1.9.0` even if the legacy `auto_materialize: use_sensors` configuration setting was set to `False`.\n- [ui] Fixed an issue when executing asset checks where the wrong job name was used in some situations. The correct job name is now used.\n- [ui] Selecting assets with 100k+ partitions no longer causes the asset graph to temporarily freeze.\n- [ui] Fixed an issue that could cause a GraphQL error on certain pages after removing an asset.\n- [ui] The asset events page no longer truncates event history in cases where both materialization and observation events are present.\n- [ui] The backfill coordinator logs tab no longer sits in a loading state when no logs are available to display.\n- [ui] Fixed issue which would cause the \"Partitions evaluated\" label on an asset's automation history page to incorrectly display `0` in cases where all partitions were evaluated.\n- [ui] Fix \"Open in Playground\" link when testing a schedule or sensor by ensuring that it opens to the correct deployment.\n- [ui] Fixed an issue where the asset graph would reload unexpectedly.\n- [dagster-dbt] Fixed an issue where the SQL filepath for a dbt model was incorrectly resolved when the dbt manifest file was built on a Windows machine, but executed on a Unix machine.\n- [dagster-pipes] Asset keys containing embedded `/` characters now work correctly with Dagster Pipes.\n\n### Documentation\n\n- Community-hosted integrations are now listed on the [Integrations](https://docs.dagster.io/integrations) page.\n- Added a [tutorial](https://docs.dagster.io/integrations/airlift/tutorial/overview), [reference page](https://docs.dagster.io/integrations/airlift/reference) and [API docs](https://docs.dagster.io/_apidocs/libraries/dagster-airlift) for `dagster-airlift`.\n- Fixed a typo in the label for superseded APIs. (Thanks, [@matt-weingarten](https://github.com/matt-weingarten)!)\n\n### Deprecations\n\n- The `types-sqlalchemy` package is no longer included in the `dagster[pyright]` extra package.\n\n### Dagster Plus\n\n- [ui] The Environment Variables table can now be sorted by name and update time.\n- [ui] The code location configuration dialog now contains more metadata about the code location.\n- [ui] Fixed an issue where the incorrect user icons were shown in the Users table when a search filter had been applied.\n\n# 1.9.1 (core) / 0.25.1 (libraries)\n\n### New\n\n- `dagster project scaffold` now has an option to create dagster projects from templates with excluded files/filepaths.\n- [ui] Filters in the asset catalog now persist when navigating subdirectories.\n- [ui] The Run page now displays the partition(s) a run was for.\n- [ui] Filtering on owners/groups/tags is now case-insensitive.\n- [dagster-tableau] the helper function `parse_tableau_external_and_materializable_asset_specs` is now available to parse a list of Tableau asset specs into a list of external asset specs and materializable asset specs.\n- [dagster-looker] Looker assets now by default have owner and URL metadata.\n- [dagster-k8s] Added a per_step_k8s_config configuration option to the k8s_job_executor, allowing the k8s configuration of individual steps to be configured at run launch time (thanks @Kuhlwein!)\n- [dagster-fivetran] Introduced `DagsterFivetranTranslator` to customize assets loaded from Fivetran.\n- [dagster-snowflake] `dagster_snowflake.fetch_last_updated_timestamps` now supports ignoring tables not found in Snowflake instead of raising an error.\n\n### Bugfixes\n\n- Fixed issue which would cause a `default_automation_condition_sensor` to be constructed for user code servers running on dagster version < 1.9.0 even if the legacy `auto_materialize: use_sensors` configuration setting was set to `False`.\n- Fixed an issue where running `dagster instance migrate` on Dagster version 1.9.0 constructed a SQL query that exceeded the maximum allowed depth.\n- Fixed an issue where wiping a dynamically partitioned asset causes an error.\n- [dagster-polars] `ImportError`s are no longer raised when bigquery libraries are not installed [#25708]\n\n### Documentation\n\n- [dagster-dbt] A guide on how to use dbt defer with Dagster branch deployments has been added to the dbt reference.\n\n# 1.9.0 (core) / 0.25.0 (libraries)\n\n## Major changes since 1.8.0 (core) / 0.24.0 (libraries)\n\n### Automation\n\n- Declarative Automation, the system which enables setting per-asset `AutomationConditions`, is no longer experimental. We now recommend using this system in all cases where asset-centric orchestration is desired. A suite of built-in static constructors have been added for common usecases, such as `AutomationCondition.on_missing()` (which can fill in missing partitions of assets as soon as upstream data is available), and `AutomationCondition.all_deps_blocking_checks_passed()` (which can prevent materialization of assets until all upstream blocking checks have passed).\n- You can now assign `AutomationConditions` to asset checks, via the `automation_condition` parameter on `@asset_check` or `AssetCheckSpec`.\n- You can now assign `AutomationConditions` to observable source assets, via the `automation_condition` parameter on `@observable_source_asset`.\n- [experimental] You can now define custom subclasses of `AutomationCondition` to execute arbitrary Python code in the context of a broader expression. This allows you to compose built-in conditions with custom business logic.\n- The `target` arguments on schedules and sensors are now marked stable, allowing a stable way for schedules and sensors to target asset selections without needing to define a job.\n\n### Integrations\n\n- Introduced a slate of integrations with business intelligence (BI) tools, enabling dashboards, views, and reports to be represented in the Dagster asset graph.\n  - [Looker](https://docs.dagster.io/integrations/looker)\n  - [Power BI](https://docs.dagster.io/integrations/powerbi)\n  - [Sigma](https://docs.dagster.io/integrations/sigma)\n  - [Tableau](https://docs.dagster.io/integrations/tableau)\n- A rich set of metadata is now automatically collected by our suite of ELT integrations.\n  - The `dagster/table_name` metadata tag, containing the fully-qualified name of the destination model, has been added for Airbyte, dlt, Fivetran and Sling assets.\n  - The `dagster/row_count` metadata tag, containing the number of records loaded in the corresponding run, has been added for dlt and Sling assets.\n  - The `dagster/column_schema` metadata tag, containing column schema information of the destination tables, has been added for Fivetran assets.\n  - Column lineage information is now collected for Sling assets.\n- [dagster-pipes](https://docs.dagster.io/concepts/dagster-pipes) are replacing the now deprecated Step Launchers as the new recommended approach for executing remote Spark jobs. Three new [Pipes clients](https://docs.dagster.io/_apidocs/libraries/dagster-aws#clients) for running Spark applications on Amazon Web Services have been added:\n  - `dagster_aws.pipes.PipesGlueClient`\n  - `dagster_aws.pipes.PipesEMRServerlessClient`\n  - `dagster_aws.pipes.PipesEMRClient`\n\n### UI\n\n- Several changes have been made to the information architecture to make it easier to find what you’re looking for:\n  - Backfills have been moved from their own tab underneath the Overview page to entries within the table on the Runs page. This reflects the fact that backfills and runs are similar entities that share most properties. You can continue to use the legacy Runs page with the “Revert to legacy Runs page” user setting. ([GitHub Discussion](https://github.com/dagster-io/dagster/discussions/24898))\n  - “Jobs” is now a page reachable from the top-level navigation pane. It replaces the Jobs tab within the Overview page.\n  - “Automations” is now a page reachable from the top-level navigation pane. It replaces the schedule and sensor tabs within the Overview page.\n- `@asset` and `AssetSpec` now have a `kinds` attribute that enables specifying labels that show up on asset nodes in the asset graph in the UI. This supersedes the `compute_kind` attribute.\n\n## Changes since 1.8.13 (core) / 0.24.13 (libraries)\n\n### New\n\n- The `tags` parameter to `@asset` and `AssetSpec` is no longer marked as experimental.\n- The `@observable_source_asset` decorator now supports an `automation_condition` argument.\n- `AutomationCondition` and associated APIs are no longer marked as experimental.\n- Added a new `use_user_code_server` parameter to `AutomationConditionSensorDefinition`. If set, the sensor will be evaluated in the user code server (as traditional sensors are), allowing custom `AutomationCondition` subclasses to be evaluated.\n- Added a new column to the BulkActions table, a new column to the Runs table, and a new BackfillTags table to improve the performance of the Runs page. To take advantage of these performance improvements, run `dagster instance migrate`. This migration involves a schema migration to add the new columns and table, and a data migration to populate the new columns for historical backfills and runs.\n- Performance improvements when loading definitions with multi-assets with many asset keys.\n- [ui] The previously-experimental changes to the top nav are now enabled for all users.\n- [ui] Added new code location pages which provide information regarding library versions, metadata, and definitions.\n- [ui] The new version of the Runs page is now enabled by default. To use the legacy version of the Runs page, toggle the \"Revert to legacy Runs page\" user setting.\n- [ui] Clicking an asset with failed partitions on the asset health overview now takes you to a list of the failed partitions.\n- [ui] The Materialize button runs pre-flight checks more efficiently, resulting in faster run launch times.\n- [dagster-pipes] Added support for multi-container log streaming (thanks, [@MattyKuzyk](https://github.com/MattyKuzyk)!)\n- [dagster-docker] `container_kwargs.stop_timeout` can now be set when using the `DockerRunLauncher` or `docker_executor` to configure the amount of time that Docker will wait when terminating a run for it to clean up before forcibly stopping it with a SIGKILL signal.\n- [dagster-dbt] Performance improvements when loading definitions using `build_dbt_asset_selection`.\n\n### Bugfixes\n\n- [ui] Fixed redirect behavior on full pageloads of the legacy auto-materialize overview page.\n- [ui] Plots for assets that emit materialization and observation events at different rates no longer display a time period missing the more frequent event type.\n- [ui] Fixed issue causing scrolling to misbehave on the concurrency settings page.\n- [helm] The blockOpConcurrencyLimitedRuns section of queuedRunCoordinator now correctly templates the appropriate config.\n- [dagster-pipes] Fixed issue where k8s ops would fail after 4 hours (thanks, [@MattyKuzyk](https://github.com/MattyKuzyk)!)\n\n### Documentation\n\n- [dagster-dbt] Added guide for using dbt defer with Dagster branch deployments.\n- [docs] Step Launchers documentation has been removed and replaced with references to Dagster Pipes.\n- [docs] Fixed code example in Dagster Essentials (thanks, [@aleexharris](https://github.com/aleexharris)!)\n\n### Breaking Changes\n\n- `dagster` no longer supports Python 3.8, which hit EOL on 2024-10-07.\n- `dagster` now requires `pydantic>=2`.\n- By default, `AutomationConditionSensorDefinitions` will now emit backfills to handle cases where more than one partition of an asset is requested on a given tick. This allows that asset's `BackfillPolicy` to be respected. This feature can be disabled by setting `allow_backfills` to `False`.\n- Passing a custom `PartitionsDefinition` subclass into a `Definitions` object now issues an error instead of a deprecation warning.\n- `AssetExecutionContext` is no longer a subclass of `OpExecutionContext`. At this release, `AssetExecutionContext` and `OpExecutionContext` implement the same methods, but in the future, the methods implemented by each class may diverge. If you have written helper functions with `OpExecutionContext` type annotations, they may need to be updated to include `AssetExecutionContext` depending on your usage. Explicit calls to `isinstance(context, OpExecutionContext)` will now fail if `context` is an `AssetExecutionContext`.\n- The `asset_selection` parameter on `AutomationConditionSensorDefinition` has been renamed to `target`, to align with existing sensor APIs.\n- The experimental `freshness_policy_sensor` has been removed, as it relies on the long-deprecated `FreshnessPolicy` API.\n- The deprecated `external_assets_from_specs` and `external_asset_from_spec` methods have been removed. Users should use `AssetsDefinition(specs=[...])`, or pass specs directly into the `Definitions` object instead.\n- `AssetKey` objects can no longer be iterated over or indexed in to. This behavior was never an intended access pattern and in all observed cases was a mistake.\n- The `dagster/relation_identifier` metadata key has been renamed to `dagster/table_name`.\n- [dagster-ge] `dagster-ge` now only supports `great_expectations>=0.17.15`. The `ge_validation_op_factory` API has been replaced with the API previously called `ge_validation_op_factory_v3`.\n- [dagster-aws] Removed deprecated parameters from `dagster_aws.pipes.PipesGlueClient.run`.\n- [dagster-embedded-elt] Removed deprecated parameter `dlt_dagster_translator` from `@dlt_assets`. The `dagster_dlt_translator` parameter should be used instead.\n- [dagster-polars] Dropped support for saving storage-level arbitrary metadata via IOManagers.\n\n### Deprecations\n\n- The `DataBricksPysparkStepLauncher`, `EmrPySparkStepLauncher`, and any custom subclass of `StepLauncher` have been marked as deprecated, but will not be removed from the codebase until Dagster 2.0 is released, meaning they will continue to function as they currently do for the foreseeable future. Their functionality has been superseded by the interfaces provided by `dagster-pipes`, and so future development work will be focused there.\n- The experimental `multi_asset_sensor` has been marked as deprecated, as its main use cases have been superseded by the `AutomationCondition` APIs. However, it will not be removed until version 2.0.0.\n\n# 1.8.13 (core) / 0.24.13 (libraries)\n\n### New\n\n- Performance improvements when loading code locations using multi-assets with many asset keys.\n- `AutomationCondition.in_progress()` now will be true if an asset partition is part of an in-progress backfill that has not yet executed it. The prior behavior, which only considered runs, is encapsulated in `AutomationCondition.execution_in_progress()`.\n- [ui] Added tag filter to the jobs page.\n- [ui] Preserve user login state for a longer period of time.\n- [dagster-dbt] Performance improvements when loading definitions using `build_dbt_asset_selection`.\n- [dagster-docker] `container_kwargs.stop_timeout` can now be set when using the `DockerRunLauncher` or `docker_executor` to configure the amount of time that Docker will wait when terminating a run for it to clean up before forcibly stopping it with a SIGKILL signal.\n- [dagster-sigma] The Sigma integration now fetches initial API responses in parallel, speeding up initial load.\n- [dagster-looker] Attempt to naively render liquid templates for derived table sql.\n- [dagster-looker] Added support for views and explores that rely on refinements or extends.\n- [dagster-looker] When fetching explores and dashboards from the Looker API, retrieve in parallel.\n\n### Bugfixes\n\n- Fixed an issue with `AutomationCondition.eager()` that could cause it to attempt to launch a second attempt of an asset in cases where it was skipped or failed during a run where one of its parents successfully materialized.\n- Fixed an issue which would cause `AutomationConditionSensorDefinitions` to not be evaluated if the `use_user_code_server` value was toggled after the initial evaluation.\n- Fixed an issue where configuration values for aliased pydantic fields would be dropped.\n- [ui] Fix an issue in the code locations page where invalid query parameters could crash the page.\n- [ui] Fix navigation between deployments when query parameters are present in the URL.\n- [helm] the blockOpConcurrencyLimitedRuns section of queuedRunCoordinator now correctly templates the appropriate config.\n- [dagster-sigma] Fixed pulling incomplete data for very large workspaces.\n\n# 1.8.12 (core) / 0.24.12 (libraries)\n\n### New\n\n- The `AutomationCondition.eager()`, `AutomationCondition.missing()`, and `AutomationCondition.on_cron` conditions are now compatible with asset checks.\n- Added `AssetSelection.materializable()`, which returns only assets that are materializable in an existing selection.\n- Added a new `AutomationCondition.all_deps_blocking_checks_passed` condition, which can be used to prevent materialization when any upstream blocking checks have failed.\n- Added a `code_version` parameter to the `@graph_asset` decorator.\n- If a `LaunchPartitionBackfill` mutation is submitted to GQL with invalid partition keys, it will now return an early `PartitionKeysNotFoundError`.\n- `AssetSelection.checks_for_assets` now accepts `AssetKey`s and string asset keys, in addition to `AssetsDefinition`s.\n- [ui] Added a search bar to partitions tab on the asset details page.\n- [ui] Restored docked left nav behavior for wide viewports.\n- [dagster-aws] `get_objects` now has a `since_last_modified` that enables only fetching objects modified after a given timestamp.\n- [dagster-aws] New AWS EMR Dagster Pipes client (`dagster_aws.pipes.PipesEMRCLient` ) for running and monitoring AWS EMR jobs from Dagster.\n- [dagster-looker] Pinned the looker-sdk dependency below 24.18.0 to avoid this issue: https://github.com/looker-open-source/sdk-codegen/issues/1518.\n\n### Bugfixes\n\n- Fixed an issue which could cause incorrect evaluation results when using self-dependent partition mappings with `AutomationConditions` that operate over dependencies.\n- [ui] Fixed an issue where the breadcumb on asset pages would flicker nonstop.\n- [dagster-embedded-elt] Fixed extraction of metadata for dlt assets whose source and destination identifiers differ.\n- [dagster-databricks] Fixed a permissioning gap that existed with the `DatabricksPySparkStepLauncher`, so that permissions are now set correctly for non-admin users.\n- [dagster-dbt] Fixed an issue where column metadata generated with `fetch_column_metadata` did not work properly for models imported through dbt dependencies.\n\n### Documentation\n\n- [dagster-k8s] `DagsterK8sPipesClient.run` now shows up in API docs.\n\n### Dagster Plus\n\n- [ui] Fixed a bug in the catalog UI where owners filters were not applied correctly.\n- [ui] Fixed width of the column lineage dropdown selector on the asset page.\n- [ui] Column lineage now correctly renders when set on asset definition metadata\n- [ui] Fixed Settings link on the list of deployments, for users in the legacy navigation flag.\n\n# 1.8.11 (core) / 0.24.11 (libraries)\n\n### New\n\n- [experimental] AutomationCondition.eager() will now only launch runs for missing partitions which become missing _after_ the condition has been added to the asset. This avoids situations in which the eager policy kicks off a large amount of work when added to an asset with many missing historical static/dynamic partitions.\n- [experimental] Added a new AutomationCondition.asset_matches() condition, which can apply a condition against an arbitrary asset in the graph.\n- [experimental] Added the ability to specify multiple kinds for an asset with the kinds parameter.\n- [dagster-github] Added `create_pull_request` method on `GithubClient` that enables creating a pull request.\n- [dagster-github] Added `create_ref` method on `GithubClient` that enables creating a new branch.\n- [dagster-embedded-elt] dlt assets now generate column metadata for child tables.\n- [dagster-embedded-elt] dlt assets can now fetch row count metadata with `dlt.run(...).fetch_row_count()` for both partitioned and non-partitioned assets. Thanks [@kristianandre](https://github.com/kristianandre)!\n- [dagster-airbyte] relation identifier metadata is now attached to Airbyte assets.\n- [dagster-embedded-elt] relation identifier metadata is now attached to sling assets.\n- [dagster-embedded-elt] relation identifier metadata is now attached to dlt assets.\n\n### Bugfixes\n\n- `PartitionedConfig` objects can now return a `RunConfig` without causing a crash.\n- Corrected the `AssetIn.__new__` typing for the dagster_type argument.\n- [dagster-embedded-elt] dlt assets now generate correct column metadata after the first materialization.\n- [dagster-embedded-elt] Sling's `fetch_row_count()` method now works for databases returning uppercase column names. Thanks [@kristianandre](https://github.com/kristianandre)!\n- [dagster-gcp] Ensure blob download is flushed to temporary file for `GCSFileManager.read` operations. Thanks [@ollie-bell](https://github.com/ollie-bell)!\n\n### Dagster Plus\n\n- Fixed a bug in the catalog UI where owners filters were not applied correctly.\n\n# 1.8.10 (core) / 0.24.10 (libraries)\n\n### New\n\n- `JobDefinition`, `@job`, and `define_asset_job` now take a `run_tags` parameter. If `run_tags` are defined, they will be attached to all runs of the job, and `tags` will not be. If `run_tags` is not set, then `tags` are attached to all runs of the job (status quo behavior). This change enables the separation of definition-level and run-level tags on jobs.\n- Then env var `DAGSTER_COMPUTE_LOG_TAIL_WAIT_AFTER_FINISH` can now be used to pause before capturing logs (thanks @HynekBlaha!)\n- The `kinds` parameter is now available on `AssetSpec`.\n- `OutputContext` now exposes the `AssetSpec` of the asset that is being stored as an output (thanks, @marijncv!)\n- [experimental] Backfills are incorporated into the Runs page to improve observability and provide a more simplified UI. See the [GitHub discussion](https://github.com/dagster-io/dagster/discussions/24898) for more details.\n- [ui] The updated navigation is now enabled for all users. You can revert to the legacy navigation via a feature flag. See [GitHub discussion](https://github.com/dagster-io/dagster/discussions/21370) for more.\n- [ui] Improved performance for loading partition statuses of an asset job.\n- [dagster-docker] Run containers launched by the DockerRunLauncher now include dagster/job_name and dagster/run_id labels.\n- [dagster-aws] The ECS launcher now automatically retries transient ECS RunTask failures (like capacity placement failures).\n\n### Bugfixes\n\n- Changed the log volume for global concurrency blocked runs in the run coordinator to be less spammy.\n- [ui] Asset checks are now visible in the run page header when launched from a schedule.\n- [ui] Fixed asset group outlines not rendering properly in Safari.\n- [ui] Reporting a materialization event now removes the asset from the asset health \"Execution failures\" list and returns the asset to a green / success state.\n- [ui] When setting an `AutomationCondition` on an asset, the label of this condition will now be shown in the sidebar on the Asset Details page.\n- [ui] Previously, filtering runs by Created date would include runs that had been updated after the lower bound of the requested time range. This has been updated so that only runs created after the lower bound will be included.\n- [ui] When using the new experimental navigation flag, added a fix for the automations page for code locations that have schedules but no sensors.\n- [ui] Fixed tag wrapping on asset column schema table.\n- [ui] Restored object counts on the code location list view.\n- [ui] Padding when displaying warnings on unsupported run coordinators has been corrected (thanks @hainenber!)\n- [dagster-k8s] Fixed an issue where run termination sometimes did not terminate all step processes when using the k8s_job_executor, if the termination was initiated while it was in the middle of launching a step pod.\n\n### Documentation\n\n- Corrections on the Dagster instance concept page (thanks @mheguy!)\n- Corrections on the code locations concept page (thanks @tiberiuana!)\n- Repeated words removed (thanks @tianzedavid!)\n- [dagster-deltalake] Corrections and improvements (thanks @avriiil!)\n- [dagster-aws] Added docs for PipesEMRServerlessClient.\n- [dagster-cli] A guide on how to validate Dagster definitions using `dagster definitions validate` have been added.\n- [dagster-databricks] Added docs for using Databricks Pipes with existing clusters.\n- [dagster-dbt] Corrected sample sql code (thanks @b-per!)\n\n# 1.8.9 (core) / 0.24.9 (libraries)\n\n### New\n\n- `AssetSpec` now has a `with_io_manager_key` method that returns an `AssetSpec` with the appropriate metadata entry to dictate the key for the IO manager used to load it. The deprecation warning for `SourceAsset` now references this method.\n- Added a `max_runtime_seconds` configuration option to run monitoring, allowing you to specify that any run in your Dagster deployment should terminate if it exceeds a certain runtime. Prevoiusly, jobs had to be individually tagged with a `dagster/max_runtime` tag in order to take advantage of this feature. Jobs and runs can still be tagged in order to override this value for an individual run.\n- It is now possible to set both `tags` and a custom `execution_fn` on a `ScheduleDefinition`. Schedule `tags` are intended to annotate the definition and can be used to search and filter in the UI. They will not be attached to run requests emitted from the schedule if a custom `execution_fn` is provided. If no custom `execution_fn` is provided, then for back-compatibility the tags will also be automatically attached to run requests emitted from the schedule.\n- `SensorDefinition` and all of its variants/decorators now accept a `tags` parameter. The tags annotate the definition and can be used to search and filter in the UI.\n- Added the `dagster definitions validate` command to Dagster CLI. This command validates if Dagster definitions are loadable.\n- [dagster-databricks] Databricks Pipes now allow running tasks in existing clusters.\n\n### Bugfixes\n\n- Fixed an issue where calling `build_op_context` in a unit test would sometimes raise a `TypeError: signal handler must be signal.SIG_IGN, signal.SIG_DFL, or a callable object` Exception on process shutdown.\n- [dagster-webserver] Fix an issue where the incorrect sensor/schedule state would appear when using `DefaultScheduleStatus.STOPPED` / `DefaultSensorStatus.STOPPED` after performing a reset.\n\n### Documentation\n\n- [dagster-pipes] Fixed inconsistencies in the k8s pipes example.\n- [dagster-pandas-pyspark] Fixed example in the Spark/Pandas SDA guide.\n\n### Dagster Plus\n\n- Fixed an issue where users with Launcher permissions for a particular code location were not able to cancel backfills targeting only assets in that code location.\n- Fixed an issue preventing long-running alerts from being sent when there was a quick subsequent run.\n\n# 1.8.8 (core) / 0.24.8 (libraries)\n\n### New\n\n- Added `--partition-range` option to `dagster asset materialize` CLI. This option only works for assets with single-run Backfill Policies.\n- Added a new `.without()` method to `AutomationCondition.eager()`, `AutomationCondition.on_cron()`, and `AutomationCondition.on_missing()` which allows sub-conditions to be removed, e.g. `AutomationCondition.eager().without(AutomationCondition.in_latest_time_window())`.\n- Added `AutomationCondition.on_missing()`, which materializes an asset partition as soon as all of its parent partitions are filled in.\n- `pyproject.toml` can now load multiple Python modules as individual Code Locations. Thanks, [@bdart](https://github.com/bdart)!\n- [ui] If a code location has errors, a button will be shown to view the error on any page in the UI.\n- [dagster-adls2] The `ADLS2PickleIOManager` now accepts `lease_duration` configuration. Thanks, [@0xfabioo](https://github.com/0xfabioo)!\n- [dagster-embedded-elt] Added an option to fetch row count metadata after running a Sling sync by calling `sling.replicate(...).fetch_row_count()`.\n- [dagster-fivetran] The dagster-fivetran integration will now automatically pull and attach column schema metadata after each sync.\n\n### Bugfixes\n\n- Fixed an issue which could cause errors when using `AutomationCondition.any_downstream_condition()` with downstream `AutoMaterializePolicy` objects.\n- Fixed an issue where `process_config_and_initialize` did not properly handle processing nested resource config.\n- [ui] Fixed an issue that would cause some AutomationCondition evaluations to be labeled `DepConditionWrapperCondition` instead of the key that they were evaluated against.\n- [dagster-webserver] Fixed an issue with code locations appearing in fluctuating incorrect state in deployments with multiple webserver processes.\n- [dagster-embedded-elt] Fixed an issue where Sling column lineage did not correctly resolve int the Dagster UI.\n- [dagster-k8s] The `wait_for_pod` check now waits until all pods are available, rather than erroneously returning after the first pod becomes available. Thanks [@easontm](https://github.com/easontm)!\n\n### Dagster Plus\n\n- Backfill daemon logs are now available in the \"Coordinator Logs\" tab in a backfill details page.\n- Users without proper code location permissions can no longer edit sensor cursors.\n\n# 1.8.7 (core) / 0.24.7 (libraries)\n\n### New\n\n- The `AssetSpec` constructor now raises an error if an invalid group name is provided, instead of an error being raised when constructing the `Definitions` object.\n- `dagster/relation_identifier` metadata is now automatically attached to assets which are stored using a DbIOManager.\n- [ui] Streamlined the code location list view.\n- [ui] The “group by” selection on the Timeline Overview page is now part of the query parameters, meaning it will be retained when linked to directly or when navigating between pages.\n- [dagster-dbt] When instantiating `DbtCliResource`, the `project_dir` argument will now override the `DBT_PROJECT_DIR` environment variable if it exists in the local environment (thanks, [@marijncv](https://github.com/marijncv)!).\n- [dagster-embedded-elt] dlt assets now generate `rows_loaded` metadata (thanks, [@kristianandre](https://github.com/kristianandre)!).\n- Added support for pydantic version 1.9.0.\n\n### Bugfixes\n\n- Fixed a bug where setting `asset_selection=[]` on `RunRequest` objects yielded from sensors using `asset_selection` would select all assets instead of none.\n- Fixed bug where the tick status filter for batch-fetched graphql sensors was not being respected.\n- [examples] Fixed missing assets in `assets_dbt_python` example.\n- [dagster-airbyte] Updated the op names generated for Airbyte assets to include the full connection ID, avoiding name collisions.\n- [dagster-dbt] Fixed issue causing dagster-dbt to be unable to load dbt projects where the adapter did not have a `database` field set (thanks, [@dargmuesli](https://github.com/dargmuesli)!)\n- [dagster-dbt] Removed a warning about not being able to load the `dbt.adapters.duckdb` module when loading dbt assets without that package installed.\n\n### Documentation\n\n- Fixed typo on the automation concepts page (thanks, [@oedokumaci](https://github.com/oedokumaci)!)\n\n### Dagster Plus\n\n- You may now wipe specific asset partitions directly from the execution context in user code by calling `DagsterInstance.wipe_asset_partitions`.\n- Dagster+ users with a \"Viewer\" role can now create private catalog views.\n- Fixed an issue where the default IOManager used by Dagster+ Serverless did not respect setting `allow_missing_partitions` as metadata on a downstream asset.\n\n# 1.8.6 (core) / 0.24.6 (libraries)\n\n### Bugfixes\n\n- Fixed an issue where runs in Dagster+ Serverless that materialized partitioned assets would sometimes fail with an `object has no attribute '_base_path'` error.\n- [dagster-graphql] Fixed an issue where the `statuses` filter argument to the `sensorsOrError` GraphQL field was sometimes ignored when querying GraphQL for multiple sensors at the same time.\n\n# 1.8.5 (core) / 0.24.5 (libraries)\n\n### New\n\n- Updated multi-asset sensor definition to be less likely to timeout queries against the asset history storage.\n- Consolidated the `CapturedLogManager` and `ComputeLogManager` APIs into a single base class.\n- [ui] Added an option under user settings to clear client side indexeddb caches as an escape hatch for caching related bugs.\n- [dagster-aws, dagster-pipes] Added a new `PipesECSClient` to allow Dagster to interface with ECS tasks.\n- [dagster-dbt] Increased the default timeout when terminating a run that is running a `dbt` subprocess to wait 25 seconds for the subprocess to cleanly terminate. Previously, it would only wait 2 seconds.\n- [dagster-sdf] Increased the default timeout when terminating a run that is running an `sdf` subprocess to wait 25 seconds for the subprocess to cleanly terminate. Previously, it would only wait 2 seconds.\n- [dagster-sdf] Added support for caching and asset selection (Thanks, [akbog](https://github.com/akbog)!)\n- [dagster-dlt] Added support for `AutomationCondition` using `DagsterDltTranslator.get_automation_condition()` (Thanks, [aksestok](https://github.com/aksestok)!)\n- [dagster-k8s] Added support for setting `dagsterDaemon.runRetries.retryOnAssetOrOpFailure` to False in the Dagster Helm chart to [prevent op retries and run retries from simultaneously firing on the same failure.](https://docs.dagster.io/deployment/run-retries#combining-op-and-run-retries)\n- [dagster-wandb] Removed usage of deprecated `recursive` parameter (Thanks, [chrishiste](https://github.com/chrishiste)!)\n\n### Bugfixes\n\n- [ui] Fixed a bug where in-progress runs from a backfill could not be terminated from the backfill UI.\n- [ui] Fixed a bug that caused an \"Asset must be part of at least one job\" error when clicking on an external asset in the asset graph UI\n- Fixed an issue where viewing run logs with the latest 5.0 release of the watchdog package raised an exception.\n- [ui] Fixed issue causing the “filter to group” action in the lineage graph to have no effect.\n- [ui] Fixed case sensitivity when searching for partitions in the launchpad.\n- [ui] Fixed a bug which would redirect to the events tab for an asset if you loaded the partitions tab directly.\n- [ui] Fixed issue causing runs to get skipped when paging through the runs list (Thanks, [@HynekBlaha](https://github.com/HynekBlaha)!)\n- [ui] Fixed a bug where the asset catalog list view for a particular group would show all assets.\n- [dagster-dbt] fix bug where empty newlines in raw dbt logs were not being handled correctly.\n- [dagster-k8s, dagster-celery-k8s] Correctly set `dagster/image` label when image is provided from `user_defined_k8s_config`. (Thanks, [@HynekBlaha](https://github.com/HynekBlaha)!)\n- [dagster-duckdb] Fixed an issue for DuckDB versions older than 1.0.0 where an unsupported configuration option, `custom_user_agent`, was provided by default\n- [dagster-k8s] Fixed an issue where Kubernetes Pipes failed to create a pod if the op name contained capital or non-alphanumeric containers.\n- [dagster-embedded-elt] Fixed an issue where dbt assets downstream of Sling were skipped\n\n### Deprecations\n\n- [dagser-aws]: Direct AWS API arguments in `PipesGlueClient.run` have been deprecated and will be removed in `1.9.0`. The new `params` argument should be used instead.\n\n### Dagster Plus\n\n- Fixed a bug that caused an error when loading the launchpad for a partition, when using Dagster+ with an agent with version below 1.8.2.\n- Fixed an issue where terminating a Dagster+ Serverless run wouldn’t forward the termination signal to the job to allow it to cleanly terminate.\n\n# 1.8.4 (core) / 0.24.4 (libraries)\n\n### Bugfixes\n\n- Fixed an issue where viewing run logs with the latest 5.0 release of the watchdog package raised an exception.\n- Fixed a bug that caused an \"Asset must be part of at least one job\" error when clicking on an external asset in the asset graph UI\n\n### Dagster Plus\n\n- The default io_manager on Serverless now supports the `allow_missing_partitions` configuration option.\n- Fixed a bug that caused an error when loading the launchpad for a partition, when using in Dagster+ with an agent with version below 1.8.2\n\n# 1.8.3 (core) / 0.24.3 (libraries) (YANKED - This version of Dagster resulted in errors when trying to launch runs that target individual asset partitions)\n\n### New\n\n- When different assets within a code location have different `PartitionsDefinition`s, there will no longer be an implicit asset job `__ASSET_JOB_...` for each `PartitionsDefinition`; there will just be one with all the assets. This reduces the time it takes to load code locations with assets with many different `PartitionsDefinition`s.\n\n# 1.8.2 (core) / 0.24.2 (libraries)\n\n### New\n\n- [ui] Improved performance of the Automation history view for partitioned assets\n- [ui] You can now delete dynamic partitions for an asset from the ui\n- [dagster-sdf] Added support for quoted table identifiers (Thanks, [@akbog](https://github.com/akbog)!)\n- [dagster-openai] Add additional configuration options for the `OpenAIResource` (Thanks, [@chasleslr](https://github.com/chasleslr)!)\n- [dagster-fivetran] Fivetran assets now have relation identifier metadata.\n\n### Bugfixes\n\n- [ui] Fixed a collection of broken links pointing to renamed Declarative Automation pages.\n- [dagster-dbt] Fixed issue preventing usage of `MultiPartitionMapping` with `@dbt_assets` (Thanks, [@arookieds](https://github.com/arookieds)!)\n- [dagster-azure] Fixed issue that would cause an error when configuring an `AzureBlobComputeLogManager` without a `secret_key` (Thanks, [@ion-elgreco](https://github.com/ion-elgreco) and [@HynekBlaha](https://github.com/HynekBlaha)!)\n\n### Documentation\n\n- Added API docs for `AutomationCondition` and associated static constructors.\n- [dagster-deltalake] Corrected some typos in the integration reference (Thanks, [@dargmuesli](https://github.com/dargmuesli)!)\n- [dagster-aws] Added API docs for the new `PipesCloudWatchMessageReader`\n\n# 1.8.1 (core) / 0.24.1 (libraries)\n\n### New\n\n- If the sensor daemon fails while submitting runs, it will now checkpoint its progress and attempt to submit the remaining runs on the next evaluation.\n- `build_op_context` and `build_asset_context` now accepts a `run_tags` argument.\n- Nested partially configured resources can now be used outside of `Definitions`.\n- [ui] Replaced GraphQL Explorer with GraphiQL.\n- [ui] The run timeline can now be grouped by job or by automation.\n- [ui] For users in the experimental navigation flag, schedules and sensors are now in a single merged automations table.\n- [ui] Logs can now be filtered by metadata keys and values.\n- [ui] Logs for `RUN_CANCELED` events now display relevant error messages.\n- [dagster-aws] The new `PipesCloudWatchMessageReader` can consume logs from CloudWatch as pipes messages.\n- [dagster-aws] Glue jobs launched via pipes can be automatically canceled if Dagster receives a termination signal.\n- [dagster-azure] `AzureBlobComputeLogManager` now supports service principals, thanks @[ion-elgreco](https://github.com/ion-elgreco)!\n- [dagster-databricks] `dagster-databricks` now supports `databricks-sdk<=0.17.0`.\n- [dagster-datahub] `dagster-datahub` now allows pydantic versions below 3.0.0, thanks @[kevin-longe-unmind](https://github.com/kevin-longe-unmind)!\n- [dagster-dbt] The `DagsterDbtTranslator` class now supports a modfiying the `AutomationCondition` for dbt models by overriding `get_automation_condition`.\n- [dagster-pandera] `dagster-pandera` now supports `polars`.\n- [dagster-sdf] Table and columns tests can now be used as asset checks.\n- [dagster-embedded-elt] Column metadata and lineage can be fetched on Sling assets by chaining the new `replicate(...).fetch_column_metadata()` method.\n- [dagster-embedded-elt] dlt resource docstrings will now be used to populate asset descriptions, by default.\n- [dagster-embedded-elt] dlt assets now generate column metadata.\n- [dagster-embedded-elt] dlt transformers now refer to the base resource as upstream asset.\n- [dagster-openai] `OpenAIResource` now supports `organization`, `project` and `base_url` for configurting the OpenAI client, thanks @[chasleslr](https://github.com/chasleslr)!\n- [dagster-pandas][dagster-pandera][dagster-wandb] These libraries no longer pin `numpy<2`, thanks @[judahrand](https://github.com/judahrand)!\n\n### Bugfixes\n\n- Fixed a bug for job backfills using backfill policies that materialized multiple partitions in a single run would be launched multiple times.\n- Fixed an issue where runs would sometimes move into a FAILURE state rather than a CANCELED state if an error occurred after a run termination request was started.\n- [ui] Fixed a bug where an incorrect dialog was shown when canceling a backfill.\n- [ui] Fixed the asset page header breadcrumbs for assets with very long key path elements.\n- [ui] Fixed the run timeline time markers for users in timezones that have off-hour offsets.\n- [ui] Fixed bar chart tooltips to use correct timezone for timestamp display.\n- [ui] Fixed an issue introduced in the 1.8.0 release where some jobs created from graph-backed assets were missing the “View as Asset Graph” toggle in the Dagster UI.\n\n### Breaking Changes\n\n- [dagster-airbyte] `AirbyteCloudResource` now supports `client_id` and `client_secret` for authentication - the `api_key` approach is no longer supported. This is motivated by the [deprecation of portal.airbyte.com](https://reference.airbyte.com/reference/portalairbytecom-deprecation) on August 15, 2024.\n\n### Deprecations\n\n- [dagster-databricks] Removed deprecated authentication clients provided by `databricks-cli` and `databricks_api`\n- [dagster-embedded-elt] Removed deprecated Sling resources `SlingSourceConnection`, `SlingTargetConnection`\n- [dagster-embedded-elt] Removed deprecated Sling resources `SlingSourceConnection`, `SlingTargetConnection`\n- [dagster-embedded-elt] Removed deprecated Sling methods `build_sling_assets`, and `sync`\n\n### Documentation\n\n- The Integrating Snowflake & dbt with Dagster+ Insights guide no longer erroneously references BigQuery, thanks @[dnxie12](https://github.com/dnxie12)!\n\n# 1.8.0 (core) / 0.24.0 (libraries)\n\n## Major changes since 1.7.0 (core) / 0.22.0 (libraries)\n\n### Core definition APIs\n\n- You can now pass `AssetSpec` objects to the `assets` argument of `Definitions`, to let Dagster know about assets without associated materialization functions. This replaces the experimental `external_assets_from_specs` API, as well as `SourceAsset`s, which are now deprecated. Unlike `SourceAsset`s, `AssetSpec`s can be used for non-materializable assets with dependencies on Dagster assets, such as BI dashboards that live downstream of warehouse tables that are orchestrated by Dagster. [[docs](https://docs.dagster.io/concepts/assets/external-assets)].\n- [Experimental] You can now merge `Definitions` objects together into a single larger `Definitions` object, using the new `Definitions.merge` API ([doc](https://docs.dagster.io/_apidocs/definitions#dagster.Definitions.merge)). This makes it easier to structure large Dagster projects, as you can construct a `Definitions` object for each sub-domain and then merge them together at the top level.\n\n### Partitions and backfills\n\n- `BackfillPolicy`s assigned to assets are now respected for backfills launched from jobs that target those assets.\n- You can now wipe materializations for individual asset partitions.\n\n### Automation\n\n- [Experimental] You can now add `AutomationCondition`s to your assets to have them automatically executed in response to specific conditions ([docs](https://docs.dagster.io/concepts/automation/declarative-automation)). These serve as a drop-in replacement and improvement over the `AutoMaterializePolicy` system, which is being marked as deprecated.\n- [Experimental] Sensors and schedules can now directly target assets, via the new `target` parameter, instead of needing to construct a job.\n- [Experimental] The Timeline page can now be grouped by job or automation. When grouped by automation, all runs launched by a sensor responsible for evaluating automation conditions will get bucketed to that sensor in the timeline instead of the \"Ad-hoc materializations\" row. Enable this by opting in to the `Experimental navigation` feature flag in user settings.\n\n### Catalog\n\n- The Asset Details page now prominently displays row count and relation identifier (table name, schema, database), when corresponding asset metadata values are provided. For more information, see the [metadata and tags docs](https://docs.dagster.io/concepts/metadata-tags#metadata--tags).\n- Introduced code reference metadata which can be used to open local files in your editor, or files in source control in your browser. Dagster can automatically attach code references to your assets’ Python source. For more information, see the [docs](https://docs.dagster.io/guides/dagster/code-references).\n\n### Data quality and reliability\n\n- [Experimental] Metadata bound checks – The new `build_metadata_bounds_checks` API [[doc](https://docs.dagster.io/_apidocs/asset-checks#dagster.build_metadata_bounds_checks)] enables easily defining asset checks that fail if a numeric asset metadata value falls outside given bounds.\n- [Experimental] Freshness checks from dbt config - Freshness checks can now be set on dbt assets, straight from dbt. Check out the API docs for [build_freshness_checks_from_dbt_assets](https://docs.dagster.io/_apidocs/libraries/dagster-dbt#dagster_dbt.build_freshness_checks_from_dbt_assets) for more.\n\n### Integrations\n\n- Dagster Pipes (`PipesSubprocessClient`) and its integrations with Lambda (`PipesLambdaClient`), Kubernetes (`PipesK8sClient`), and Databricks (`PipesDatabricksClient`) are no longer experimental.\n- The new `DbtProject` class ([docs](https://docs.dagster.io/_apidocs/libraries/dagster-dbt#dagster_dbt.DbtProject)) makes it simpler to define dbt assets that can be constructed in both development and production. `DbtProject.prepare_if_dev()` eliminates boilerplate for local development, and the `dagster-dbt project prepare-and-package` CLI can helps pull deps and generate the manifest at build time.\n- [Experimental] The `dagster-looker` package can be used to define a set of Dagster assets from a Looker project that is defined in LookML and is backed by git. See the [GitHub discussion](https://github.com/dagster-io/dagster/discussions/23479) for more details.\n\n### Dagster Plus\n\n- Catalog views — In Dagster+, selections into the catalog can now be saved and shared across an organization as catalog views. Catalog views have a name and description, and can be applied to scope the catalog, asset health, and global asset lineage pages against the view’s saved selection.\n- Code location history — Dagster+ now stores a history of code location deploys, including the ability to revert to a previously deployed configuration.\n\n## Changes since 1.7.16 (core) / 0.22.16 (libraries)\n\n### New\n\n- The target of both schedules and sensors can now be set using an experimental `target` parameter that accepts an `AssetSelection` or list of assets. Any assets passed this way will also be included automatically in the `assets` list of the containing `Definitions` object.\n- `ScheduleDefinition` and `SensorDefinition` now have a `target` argument that can accept an `AssetSelection`.\n- You can now wipe materializations for individual asset partitions.\n- `AssetSpec` now has a `partitions_def` attribute. All the `AssetSpec`s provided to a `@multi_asset` must have the same `partitions_def`.\n- The `assets` argument on `materialize` now accepts `AssetSpec`s.\n- The `assets` argument on `Definitions` now accepts `AssetSpec`s.\n- The new `merge` method on `Definitions` enables combining multiple `Definitions` object into a single larger `Definition`s object with their combined contents.\n- Runs requested through the Declarative Automation system now have a `dagster/from_automation_condition: true` tag applied to them.\n- Changed the run tags query to be more performant. Thanks [@egordm](https://github.com/egordm)!\n- Dagster Pipes and its integrations with Lambda, Kubernetes, and Databricks are no longer experimental.\n- The `Definitions` constructor will no longer raise errors when the provided definitions aren’t mutually resolve-able – e.g. when there are conflicting definitions with the same name, unsatisfied resource dependencies, etc. These errors will still be raised at code location load time. The new `Definitions.validate_loadable` static method also allows performing the validation steps that used to occur in constructor.\n- `AssetsDefinitions` object provided to a `Definitions` object will now be deduped by reference equality. That is, the following will now work:\n\n  ```python\n  from dagster import asset, Definitions\n\n  @asset\n  def my_asset(): ...\n\n  defs = Definitions(assets=[my_asset, my_asset]) # Deduped into just one AssetsDefinition.\n  ```\n\n- [dagster-embedded-elt] Adds translator options for dlt integration to override auto materialize policy, group name, owners, and tags\n- [dagster-sdf] Introducing the dagster-sdf integration for data modeling and transformations powered by sdf.\n- [dagster-dbt] Added a new `with_insights()` method which can be used to more easily attach Dagster+ Insights metrics to dbt executions: `dbt.cli(...).stream().with_insights()`\n\n### Bugfixes\n\n- Dagster now raises an error when an op yields an output corresponding to an unselected asset.\n- Fixed a bug that caused downstream ops within a graph-backed asset to be skipped when they were downstream of assets within the graph-backed assets that aren’t part of the selection for the current run.\n- Fixed a bug where code references did not work properly for self-hosted GitLab instances. Thanks [@cooperellidge](https://github.com/cooperellidge)!\n- [ui] When engine events with errors appear in run logs, their metadata entries are now rendered correctly.\n- [ui] The asset catalog greeting now uses your first name from your identity provider.\n- [ui] The create alert modal now links to the alerting documentation, and links to the documentation have been updated.\n- [ui] Fixed an issue introduced in the 1.7.13 release where some asset jobs were only displaying their ops in the Dagster UI instead of their assets.\n- Fixed an issue where terminating a run while it was using the Snowflake python connector would sometimes move it into a FAILURE state instead of a CANCELED state.\n- Fixed an issue where backfills would sometimes move into a FAILURE state instead of a CANCELED state when the backfill was canceled.\n\n### Breaking Changes\n\n- The experimental and deprecated `build_asset_with_blocking_check` has been removed. Use the `blocking` argument on `@asset_check` instead.\n- Users with `mypy` and `pydantic` 1 may now experience a “metaclass conflict” error when using `Config`. Previously this would occur when using pydantic 2.\n- `AutoMaterializeSensorDefinition` has been renamed `AutomationConditionSensorDefinition`.\n- The deprecated methods of the `ComputeLogManager` have been removed. Custom `ComputeLogManager` implementations must also implement the `CapturedLogManager` interface. This will not affect any of the core implementations available in the core `dagster` package or the library packages.\n- By default, an `AutomationConditionSensorDefinition` with the name `“default_automation_condition_sensor”` will be constructed for each code location, and will handle evaluating and launching runs for all `AutomationConditions` and `AutoMaterializePolicies` within that code location. You can restore the previous behavior by setting:\n  ```yaml\n  auto_materialize:\n    use_sensors: False\n  ```\n  in your dagster.yaml file.\n- [dagster-dbt] Support for `dbt-core==1.6.*` has been removed because the version is now end-of-life.\n- [dagster-dbt] The following deprecated APIs have been removed:\n  - `KeyPrefixDagsterDbtTranslator` has been removed. To modify the asset keys for a set of dbt assets, implement`DagsterDbtTranslator.get_asset_key()` instead.\n  - Support for setting freshness policies through dbt metadata on field `+meta.dagster_freshness_policy` has been removed. Use `+meta.dagster.freshness_policy` instead.\n  - Support for setting auto-materialize policies through dbt metadata on field `+meta.dagster_auto_materialize_policy` has been removed. Use `+meta.dagster.auto_materialize_policy` instead.\n  - Support for `load_assets_from_dbt_project`, `load_assets_from_dbt_manifest`, and `dbt_cli_resource` has been removed. Use `@dbt_assets`, `DbtCliResource`, and `DbtProject` instead to define how to load dbt assets from a dbt project and to execute them.\n  - Support for rebuilt ops like `dbt_run_op`, `dbt_compile_op`, etc has been removed. Use `@op` and `DbtCliResource` directly to execute dbt commands in an op.\n- Properties on `AssetExecutionContext` , `OpExecutionContext` , and `ScheduleExecutionContext` that include `datetime`s now return standard Python `datetime` objects instead of [Pendulum datetimes](https://pendulum.eustace.io/docs/). The types in the public API for these properties have always been `datetime` and this change should not be breaking in the majority of cases, but Pendulum datetimes include some additional methods that are not present on standard Python `datetime`s, and any code that was using those methods will need to be updated to either no longer use those methods or transform the `datetime` into a Pendulum datetime. See the 1.8 migration guide for more information and examples.\n- `MemoizableIOManager`, `VersionStrategy`, `SourceHashVersionStrategy`, `OpVersionContext`, `ResourceVersionContext`, and `MEMOIZED_RUN_TAG`, which have been deprecated and experimental since pre-1.0, have been removed.\n\n### Deprecations\n\n- The Run Status column of the Backfills page has been removed. This column was only populated for backfills of jobs. To see the run statuses for job backfills, click on the backfill ID to get to the Backfill Details page.\n- The experimental `external_assets_from_specs` API has been deprecated. Instead, you can directly pass `AssetSpec` objects to the `assets` argument of the `Definitions` constructor.\n- `AutoMaterializePolicy` has been marked as deprecated in favor of `AutomationCondition` , which provides a significantly more flexible and customizable interface for expressing when an asset should be executed. More details on how to migrate your `AutoMaterializePolicies` can be found in the Migration Guide.\n- `SourceAsset` has been deprecated. See the major changes section and migration guide for more details.\n- The `asset_partition_key_for_output`, `asset_partition_keys_for_output`, and `asset_partition_key_range_for_output`, and `asset_partitions_time_window_for_output` methods on `OpExecutionContext` have been deprecated. Instead, use the corresponding property: `partition_key`, `partition_keys`, `partition_key_range`, or `partition_time_window`.\n- The `partitions_def` parameter on `define_asset_job` is now deprecated. The `partitions_def` for an asset job is determined from the `partitions_def` attributes on the assets it targets, so this parameter is redundant.\n- [dagster-shell] `create_shell_command_op` and `create_shell_script_op` have been marked as deprecated in favor of `PipesSubprocessClient` (see details in [Dagster Pipes subprocess reference](https://docs.dagster.io/concepts/dagster-pipes/subprocess/reference))\n- [dagster-airbyte] `load_assets_from_airbyte_project` is now deprecated, because the Octavia CLI that it relies on is an experimental feature that is no longer supported. Use `build_airbyte_assets` or `load_assets_from_airbyte_project` instead.\n\n### Documentation\n\n- The Asset Checks concept overview page now includes a table with all the built-in asset checks.\n- The Asset Metadata page concept page now includes a table with all the standard “dagster/” metadata keys.\n- Fixed a typo in the documentation for `MonthlyPartitionsDefinition`. Thanks [@zero_stroke](https://github.com/zero_stroke)!\n- Added a new page about Declarative Automation and a guide about customizing automation conditions\n- Fixed a link in the Limiting concurrency guide.\n\n### Dagster Plus\n\n- In Dagster+, selections into the catalog can now be saved and shared across an organization as catalog views. Catalog views have a name and description, and can be applied to scope the catalog, asset health, and global asset lineage pages against the view’s saved selection.\n- In Dagster+ run alerts, if you are running Dagster 1.8 or greater in your user code, you will now receive exception-level information in the alert body.\n\n# 1.7.16 (core) / 0.23.16 (libraries)\n\n### Experimental\n\n- [pipes] PipesGlueClient, an AWS Glue pipes client has been added to `dagster_aws`.\n\n# 1.7.15 (core) / 0.23.15 (libraries)\n\n### New\n\n- [dagster-celery-k8s] Added a `per_step_k8s_config` configuration option to the `celery_k8s_job_executor` , allowing the k8s configuration of individual steps to be configured at run launch time. Thanks [@alekseik1](https://github.com/alekseik1)!\n- [dagster-dbt] Deprecated the `log_column_level_metadata` macro in favor of the new `with_column_metadata` API.\n- [dagster-airbyte] Deprecated `load_assets_from_airbyte_project` as the Octavia CLI has been deprecated.\n\n### Bugfixes\n\n- [ui] Fix global search to find matches on very long strings.\n- Fixed an issue introduced in the 1.7.14 release where multi-asset sensors would sometimes raise an error about fetching too many event records.\n- Fixes an issue introduced in 1.7.13 where type-checkers interpretted the return type of `RunRequest(...)` as `None`\n- [dagster-aws] Fixed an issue where the `EcsRunLauncher` would sometimes fail to launch runs when the `include_sidecars` option was set to `True`.\n- [dagster-dbt] Fixed an issue where errors would not propagate through deferred metadata fetches.\n\n### Dagster Plus\n\n- On June 20, 2024, AWS changed the AWS CloudMap CreateService API to allow resource-level permissions. The Dagster+ ECS Agent uses this API to launch code locations. We’ve updated the Dagster+ ECS Agent CloudFormation template to accommodate this change for new users. Existing users have until October 14, 2024 to add the new permissions and should have already received similar communication directly from AWS.\n- Fixed a bug with BigQuery cost tracking in Dagster+ insights, where some runs would fail if there were null values for either `total_byte_billed` or `total_slot_ms` in the BigQuery `INFORMATION_SCHEMA.JOBS` table.\n- Fixed an issue where code locations that failed to load with extremely large error messages or stack traces would sometimes cause errors with agent heartbeats until the code location was redeployed.\n\n# 1.7.14 (core) / 0.23.14 (libraries)\n\n### New\n\n- [blueprints] When specifying an asset key in `ShellCommandBlueprint`, you can now use slashes as a delimiter to generate an `AssetKey` with multiple path components.\n- [community-controbution][mlflow] The mlflow resource now has a `mlflow_run_id` attribute (Thanks Joe Percivall!)\n- [community-contribution][mlflow] The mlflow resource will now retry when it fails to fetch the mlflow run ID (Thanks Joe Percivall!)\n\n### Bugfixes\n\n- Fixed an issue introduced in the 1.7.13 release where Dagster would fail to load certain definitions when using Python 3.12.4.\n- Fixed an issue where in-progress steps would continue running after an unexpected exception caused a run to fail.\n- [dagster-dbt] Fixed an issue where column lineage was unable to be built in self-referential incremental models.\n- Fixed an issue where `dagster dev` was logging unexpectedly without the `grpcio<1.65.0` pin.\n- Fixed an issue where a `ContextVar was created in a different context` error was raised when executing an async asset.\n- [community-contribution] `multi_asset` type-checker fix from @aksestok, thanks!\n- [community-contribution][ui] Fix to use relative links for manifest/favicon files, thanks @aebrahim!\n\n### Documentation\n\n- [community-contribution] Fixed helm repo CLI command typo, thanks @fxd24!\n\n### Dagster Plus\n\n- [ui] The deployment settings yaml editor is now on a page with its own URL, instead of within a dialog.\n\n# 1.7.13 (core) / 0.23.13 (libraries)\n\n### New\n\n- The `InputContext` passed to an `IOManager` ’s `load_input` function when invoking the `output_value` or `output_for_node` methods on `JobExecutionResult` now has the name `\"dummy_input_name\"` instead of `None`.\n- [dagster-ui] Asset materializations can now be reported from the dropdown menu in the asset list view.\n- [dagster-dbt] `DbtProject` is adopted and no longer experimental. Using `DbtProject` helps achieve a setup where the dbt manifest file and dbt dependencies are available and up-to-date, during development and in production. Check out the API docs for more: [https://docs.dagster.io/\\_apidocs/libraries/dagster-dbt#dagster_dbt.DbtProject](https://docs.dagster.io/_apidocs/libraries/dagster-dbt#dagster_dbt.DbtProject).\n- [dagster-dbt] The `—use-dbt-project` flag was introduced for the cli command `dagster-dbt project scaffold`. Creating a Dagster project wrapping a dbt project using that flag will include a `DbtProject` .\n- [dagster-ui] The Dagster UI now loads events in batches of 1000 in the run log viewer, instead of batches of 10000. This value can be adjusted by setting the `DAGSTER_UI_EVENT_LOAD_CHUNK_SIZE` environment variable on the Dagster webserver.\n- Asset backfills will now retry if there is an unexpected exception raised in the middle of the backfill. Previously, they would only retry if there was a problem connecting to the code server while launching runs in the backfill.\n- Added the ability to monitor jobs which have failed to start in time with the `RunFailureReason.START_TIMEOUT` run monitoring failure reason. Thanks @jobicarter!\n- [experimental] Introduced the ability to attach code references to your assets, which allow you to view source code for an asset in your editor or in git source control. For more information, see the code references docs: [https://docs.dagster.io/guides/dagster/code-references](https://docs.dagster.io/guides/dagster/code-references).\n- [ui] Performance improvements to loading the asset overview tab.\n- [ui] Performance improvements for rendering gantt charts with 1000’s of ops/steps.\n- [dagster-celery] Introduced a new Dagster Celery runner, a more lightweight way to run Dagster jobs without an executor. Thanks, @egordm!\n\n### Bugfixes\n\n- Fixed a bug that caused tags added to `ObserveResult` objects to not be stored with the produced `AssetObservation` event.\n- Fixed a bug which could cause `metadata` defined on `SourceAssets` to be unavailable when accessed in an IOManager.\n- For subselections of graph-backed multi-assets, there are some situations where we used to unnecessarily execute some of the non-selected assets. Now, we no longer execute them in those situations. There are also some situations where we would skip execution of some ops that might be needed. More information on the particulars is available [here](https://github.com/dagster-io/dagster/pull/22733).\n- Fixed the `@graph_asset` decorator overload missing an `owners` argument, thanks @askvinni!\n- Fixed behavior of passing custom image config to the K8sRunLauncher, thanks @[marchinho11](https://github.com/marchinho11)!\n- [dagster-dbt] Fixed an issue with emitting column lineage when using BigQuery.\n- [dagster-k8s] Added additional retries to `execute_k8s_job` when there was a transient failure while loading logs from the launched job. Thanks [@piotrmarczydlo](https://github.com/piotrmarczydlo)!\n- [dagster-fivetran] Fixed an issue where the Fivetran connector resource would sometimes hang if there was a networking issue while connecting to the Fivetran API.\n- [dagster-aws] Fixed an issue where the EMR step launcher would sometimes fail due to multiple versions of the `dateutil` package being installed in the default EMR python evnrionment.\n- [ui] The “Create date” column in the runs table now correctly shows the time at which a run was created instead of the time when it started to execute.\n- [ui] Fixed dark mode colors in run partitions graphs.\n- [auto-materialize] Fixed an issue which could cause errors in the `AutoMaterializeRule.skip_on_parent_missing` rule when a parent asset had its `PartitionsDefinition` changed.\n- [declarative-automation] Fixed an issue which could cause errors when viewing the evaluation history of assets with `AutomationConditions`.\n- [declarative-automation] Previously, `AutomationCondition.newly_updated()` would trigger on any `ASSET_OBSERVATION` event. Now, it only triggers when the data version on that event changes.\n\n### Breaking Changes\n\n- [dagster-dbt] The cli command `dagster-dbt project prepare-for-deployment` has been replaced by `dagster-dbt project prepare-and-package`.\n- [dagster-dbt] During development,`DbtProject` no longer prepares the dbt manifest file and dbt dependencies in its constructor during initialization. This process has been moved to `prepare_if_dev()`, that can be called on the `DbtProject` instance after initialization. Check out the API docs for more: [https://docs.dagster.io/\\_apidocs/libraries/dagster-dbt#dagster_dbt.DbtProject.prepare_if_dev](https://docs.dagster.io/_apidocs/libraries/dagster-dbt#dagster_dbt.DbtProject.prepare_if_devhttps://docs.dagster.io/_apidocs/libraries/dagster-dbt#dagster_dbt.DbtProject.prepare_if_dev).\n\n### Deprecations\n\n- Passing `GraphDefinition` as the `job` argument to schedules and sensors is deprecated. Derive a job from the `GraphDefinition` using `graph_def.to_job()` and pass this instead.\n\n### Documentation\n\n- Added some additional copy, headings, and other formatting to the [dbt quickstart](https://docs.dagster.io/integrations/dbt/quickstart).\n- Added information about asset checks to the [Testing assets guide](https://docs.dagster.io/guides/dagster/testing-assets).\n- Updated `dagster-plus CLI` in the sidenav to correctly be `dagster-cloud CLI`.\n- Thanks to Tim Nordenfur and Dimitar Vanguelov for fixing a few typos!\n- Introduced guides to migrate Airflow pipelines to Dagster that leverage the TaskFlow API or are containerized and executed with an operator like the KubernetesPodOperator.\n- Fixed instructions on setting secrets in Kubernetes Dagster deployments, thanks @abhinavDhulipala!\n\n### Dagster Plus\n\n- A history of code location deploys can now be viewed on the Code Locations tab under the Deployment view. Previously deployed versions can now be restored from history.\n- [ui] Various improvements have been made to the asset health dashboard, which is now no longer experimental.\n- [ui] Fixed issues in per-event asset insights where bar charts incorrectly displayed events in reverse order, and with UTC timestamps.\n- Fixed a recent regression where creating an alert that notifies asset owners that are teams raises an error.\n\n# 1.7.12 (core)/ 0.23.12 (libraries)\n\n### Bugfixes\n\n- [ui] fixes behavior issues with jobs and asset pages introduced in 1.7.11\n\n# 1.7.11 (core)/ 0.23.11 (libraries)\n\n### New\n\n- [ui] Improved performance for loading assets that are part of big asset graphs.\n- [ui] Improved performance for loading job backfills that have thousands of partitions\n- [ui] The code location page can now be filtered by status\n- [agent] K8s and ECS agent main loop writes a sentinel file that can be used for liveness checks.\n- [agent][experimental] ECS CloudFormation template with private IP addresses using NAT Gateways, security groups, IAM role separation, tighter permissions requirements, and improved documentation.\n- Ephemeral asset jobs are now supported in run status sensors (thanks [@the4thamigo-uk](https://github.com/the4thamigo-uk))!\n\n### Bugfixes\n\n- In `AssetsDefinition` construction, enforce single key per output name\n- Fixed a bug where freshness checks on assets with both observations and materializations would incorrectly miss a materialization if there’s no observation with `dagster/last_updated_timestamp`.\n- Fixed a bug with anomaly detection freshness checks where “not enough records” result would cause the sensor to crash loop.\n- Fixed a bug that could cause errors in the Asset Daemon if an asset using `AutoMaterializeRule.skip_on_not_all_parents_updated_since_cron()` rule gained a new dependency with a different PartitionsDefinition.\n- [ui] Fixed an issue that caused the backfill page not to be scrollable.\n- [ui] Fixed an issue where filtering by partition on the Runs page wouldn’t work if fetching all of your partitions timed out.\n- [dagster-dlt] Fixed bug with dlt integration in which partitioned assets would change the file name when using the filesystem destination.\n- [ui] Fixed an issue where an erroring code location would cause multiple toast popups.\n- Allow a string to be provided for `source_key_prefix` arg of `load_assets_from_modules`. (thanks [@drjlin](https://github.com/drjlin))!\n- Added a missing debug level log message when loading partitions with polars (thanks [Daniel Gafni](https://github.com/danielgafni))!\n- Set postgres timeout via statement, which improves storage-layer compatibility with Amazon RDS (thanks [@james lewis](https://github.com/jameslewisfaculty))!\n- In DBT integration, quote the table identifiers to handle cases where table names require quotes due to special characters. (thanks [@alex launi](https://github.com/lamalex))!\n- remove deprecated param usage in dagster-wandb integration (thanks [@chris histe](https://github.com/chrishiste))!\n- Add missing QUEUED state to DatabricksRunLifeCycleState (thanks [@gabor ratky](https://github.com/gaborratky-db))!\n- Fixed a bug with dbt-cloud integration subsetting implementation (thanks [@ivan tsarev](https://github.com/mudravrik))!\n\n### Breaking Changes\n\n- [dagster-airflow] `load_assets_from_airflow_dag` no longer allows multiple tasks to materialize the same asset.\n\n### Documentation\n\n- Added type-hinting to backfills example\n- Added syntax highlighting to some examples (thanks [@Niko](https://github.com/nikomancy))!\n- Fixed broken link (thanks [@federico caselli](https://github.com/caselit))!\n\n### Dagster Plus\n\n- The `dagster-cloud ci init` CLI will now use the `--deployment` argument as the base deployment when creating a branch deployment. This base deployment will be used for Change Tracking.\n- The BigQuery dbt insights wrapper `dbt_with_bigquery_insights` now respects CLI arguments for profile configuration and also selects location / dataset from the profile when available.\n- [experimental feature] Fixes a recent regression where the UI errored upon attempting to create an insights metric alert.\n\n# 1.7.10 (core)/ 0.23.10 (libraries)\n\n### New\n\n- Performance improvements when rendering the asset graph while runs are in progress.\n- A new API `build_freshness_checks_for_dbt_assets` which allows users to parameterize freshness checks entirely within dbt. Check out the API docs for more: https://docs.dagster.io/_apidocs/libraries/dagster-dbt#dbt-dagster-dbt.\n- Asset search results now display compute and storage kind icons.\n- Asset jobs where the underlying assets have multiple backfill policies will no longer fail at definition time. Instead, the backfill policy for the job will use the minimum `max_partitions_per_run` from the job’s constituent assets.\n- [dagstermill] `asset_tags` can now be specified when building dagstermill assets\n- [dagster-embedded-elt] Custom asset tags can be applied to Sling assets via the `DagsterSlingTranslator`\n- [dagster-embedded-elt] dlt assets now automatically have `dagster/storage_kind` tags attached\n\n### Bugfixes\n\n- `tags` passed to `outs` in `graph_multi_asset` now get correctly propagated to the resulting assets.\n- [ui] Fixed an issue in the where when multiple runs were started at the same time to materialize the same asset, the most recent one was not always shown as in progress in the asset graph in the Dagster UI.\n- The “newly updated” auto-materialize rule will now respond to either new observations or materializations for observable assets.\n- `build_metadata_bounds_checks` now no longer errors when targeting metadata keys that have special characters.\n\n### Documentation\n\n- The [Schedule concept docs](https://docs.dagster.io/concepts/automation/schedules) got a revamp! Specifically, we:\n  - Updated the Schedule concept page to be a “jumping off” point for all-things scheduling, including a high-level look at how schedules work, their benefits, and what you need to know before diving in\n  - Added some basic how-to guides for [automating assets](https://docs.dagster.io/concepts/automation/schedules/automating-assets-schedules-jobs) and [ops](https://docs.dagster.io/concepts/automation/schedules/automating-ops-schedules-jobs) using schedules\n  - Added a [reference of schedule-focused examples](https://docs.dagster.io/concepts/automation/schedules/examples)\n  - Added dedicated guides for common schedule uses, including creating p[artitioned schedules](https://docs.dagster.io/concepts/automation/schedules/partitioned-schedules), [customizing executing timezones](https://docs.dagster.io/concepts/automation/schedules/customizing-executing-timezones), [testing](https://docs.dagster.io/concepts/automation/schedules/testing), and [troubleshooting](https://docs.dagster.io/concepts/automation/schedules/troubleshooting)\n\n### Dagster Plus\n\n- [experimental] The backfill daemon can now store logs and display them in the UI for increased visibility into the daemon’s behavior. Please contact Dagster Labs if you are interested in piloting this experimental feature.\n- Added a `--read-only` flag to the `dagster-cloud ci branch-deployment` CLI command, which returns the current branch deployment name for the current code repository branch without update the status of the branch deployment.\n\n# 1.7.9 (core) / 0.23.9 (libraries)\n\n### New\n\n- Dagster will now display a “storage kind” tag on assets in the UI, similar to the existing compute kind. To set storage kind for an asset, set its `dagster/storage_kind` tag.\n- You can now set retry policy on dbt assets, to enable coarse-grained retries with delay and jitter. For fine-grained partial retries, we still recommend invoking `dbt retry` within a try/except block to avoid unnecessary, duplicate work.\n- `AssetExecutionContext` now exposes a `has_partition_key_range` property.\n- The `owners`, `metadata`, `tags`, and `deps` properties on `AssetSpec` are no longer `Optional`. The `AssetSpec` constructor still accepts `None` values, which are coerced to empty collections of the relevant type.\n- The `docker_executor` and `k8s_job_executor` now consider at most 1000 events at a time when loading events from the current run to determine which steps should be launched. This value can be tuned by setting the `DAGSTER_EXECUTOR_POP_EVENTS_LIMIT` environment variable in the run process.\n- Added a `dagster/retry_on_asset_or_op_failure` tag that can be added to jobs to override run retry behavior for runs of specific jobs. See [the docs](https://docs.dagster.io/deployment/run-retries#combining-op-and-run-retries) for more information.\n- Improved the sensor produced by `build_sensor_for_freshness_checks` to describe when/why it skips evaluating freshness checks.\n- A new “Runs” tab on the backfill details page allows you to see list and timeline views of the runs launched by the backfill.\n- [dagster-dbt] dbt will now attach relation identifier metadata to asset materializations to indicate where the built model is materialized to.\n- [dagster-graphql] The GraphQL Python client will now include the HTTP error code in the exception when a query fails. Thanks [@yuvalgimmunai](https://github.com/yuvalgimmunai)!\n\n### Bugfixes\n\n- Fixed sensor logging behavior with the `@multi_asset_sensor`.\n- `ScheduleDefinition` now properly supports being passed a `RunConfig` object.\n- When an asset function returns a `MaterializeResult`, but the function has no type annotation, previously, the IO manager would still be invoked with a `None` value. Now, the IO manager is not invoked.\n- The `AssetSpec` constructor now raises an error if an invalid owner string is passed to it.\n- When using the `graph_multi_asset` decorator, the `code_version` property on `AssetOut`s passed in used to be ignored. Now, they no longer are.\n- [dagster-deltalake] Fixed GcsConfig import error and type error for partitioned assets (Thanks [@thmswt](https://github.com/thmswt))\n- The asset graph and asset catalog now show the materialization status of External assets (when manually reported) rather than showing “Never observed”\n\n### Documentation\n\n- The External Assets REST APIs now have their own [reference page](https://docs.dagster.io/apidocs/external-assets-rest)\n- Added details, updated copy, and improved formatting to External Assets REST APIs\n\n### Dagster Plus\n\n- The ability to set a custom base deployment when creating a branch deployment has been enabled for all organizations.\n- When a code location fails to deploy, the Kubernetes agent now includes additional any warning messages from the underlying replicaset in the failure message to aid with troubleshooting.\n- Serverless deployments now support using a requirements.txt with [hashes](https://pip.pypa.io/en/stable/topics/secure-installs/#secure-installs).\n- Fixed an issue where the `dagster-cloud job launch` command did not support specifying asset keys with prefixes in the `--asset-key` argument.\n- [catalog UI] Catalog search now allows filtering by type, i.e. `group:`, `code location:`, `tag:`, `owner:`.\n- New dagster+ accounts will now start with two default alert policies; one to alert if the default free credit budget for your plan is exceeded, and one to alert if a single run goes over 24 hours. These alerts will be sent as emails to the email with which the account was initially created.\n\n# 1.7.8 (core) / 0.23.8 (libraries)\n\n### New\n\n- Backfills created via GQL can have a custom title and description.\n- `Definitions` now has a `get_all_asset_specs` method, which allows iterating over properties of the defined assets\n- [ui] In filter dropdowns, it’s now possible to submit before all the suggestions have been loaded (thanks [@bmalehorn](https://github.com/bmalehorn)!)\n- [ui] Performance improvements when loading the Dagster UI for asset graphs with thousands of partition keys.\n- [dagster-dbt] Dbt asset checks now emit execution duration and the number of failing rows as metadata\n- [dagster-embedded-elt] Added support for partitioning in dlt assets (thanks [@edsoncezar16](https://github.com/edsoncezar16)!)\n- [dagster-embedded-elt] Added ability to set custom metadata on dlt assets (thanks [@edsoncezar16](https://github.com/edsoncezar16)!)\n- [dagster-graphql] Added a `terminate_runs` method to the Python GraphQL Client. (thanks [@baumann-t](https://github.com/baumann-t)!)\n- [dagster-polars] dagster-polars IO managers now emit dagster/row_count metadata (thanks [@danielgafni](https://github.com/danielgafni)!)\n- [dagster-dbt] `DbtCliInvocation` now has a `.get_error()` method that can be useful when using `dbt.cli(..., raise_on_error=False)`.\n\n### Bugfixes\n\n- Fix a bug with legacy `DynamicPartitionsDefinition` (using `partitions_fn`) that caused a crash during job backfills.\n- [ui] On the asset graph, filtering to one or more code locations via the Filter dropdown now works as expected.\n- [ui] On the asset overview page, viewing an asset with no definition in a loaded code location no longer renders a clipped empty state.\n\n### Experimental\n\n- The new `build_metadata_bounds_checks` API creates asset checks which verify that numeric metadata values on asset materializations fall within min or max values. See the [documentation](https://docs.dagster.io/_apidocs/asset-checks#dagster.build_metadata_bounds_checks) for more information.\n\n### Documentation\n\n- Added details and links to the [Schedules and Sensors API documentation](https://docs.dagster.io/_apidocs/schedules-sensors)\n- Removed leftover mention of Dagster Cloud from the [Dagster+ Hybrid architecture documentation](https://docs.dagster.io/dagster-plus/deployment/hybrid)\n\n### Dagster Plus\n\n- Fixed an incompatibility between `build_sensor_for_freshness_checks` and Dagster Plus. This API should now work when used with Dagster Plus.\n- [ui] Billing / usage charts no longer appear black-on-black in Dagster’s dark mode.\n- [ui] The asset catalog is now available for teams plans.\n- [ui] Fixed a bug where the alert policy editor would misinterpret the threshold on a long-running job alert.\n- [kubernetes] Added a `dagsterCloudAgent.additionalPodSpecConfig` to the Kubernetes agent Helm chart allowing arbitrary pod configuration to be applied to the agent pod.\n- [ECS] Fixed an issue where the ECS agent would sometimes raise a “Too many concurrent attempts to create a new revision of the specified family” exception when using agent replicas.\n\n# 1.7.7 (core) / 0.23.7 (libraries)\n\n### New\n\n- [ui] Command clicking on nodes in the asset lineage tab will now open them in a separate tab. Same with external asset links in the asset graph.\n- Added support for setting a custom job namespace in user code deployments. (thanks [@tmatthews0020](https://github.com/tmatthews0020)!)\n- Removed warnings due to use of `datetime.utcfromtimestamp` (thanks @[dbrtly](https://github.com/dbrtly)!)\n- Custom smtp user can now be used for e-mail alerts (thanks @[edsoncezar16](https://github.com/edsoncezar16)!)\n- [dagster-dbt] Added support for `dbt-core==1.8.*`.\n- [dagster-embedded-elt] Failed dlt pipelines are now accurately reflected on the asset materialization (thanks @[edsoncezar16](https://github.com/edsoncezar16)!)\n\n### Bugfixes\n\n- Fixed spurious errors in logs due to module shadowing.\n- Fixed an issue in the Backfill Daemon where if the assets to be materialized had different `BackfillPolicy`s, each asset would get materialized in its own run, rather than grouping assets together into single run.\n- Fixed an issue that could cause the Asset Daemon to lose information in its cursor about an asset if that asset’s code location was temporarily unavailable.\n- [dagster-dbt] Mitigated issues with cli length limits by only listing specific dbt tests as needed when the tests aren’t included via indirect selection, rather than listing all tests.\n\n### Documentation\n\n- Markdoc tags can now be used in place of MDX components (thanks @[nikomancy](https://github.com/nikomancy))\n\n# 1.7.6 (core) / 0.23.6 (libraries)\n\n### New\n\n- The backfill daemon now has additional logging to document the progression through each tick and why assets are and are not materialized during each evaluation of a backfill.\n- Made performance improvements in both calculating and storing data version for assets, especially for assets with a large fan-in.\n- Standardized table row count metadata output by various integrations to `dagster/row_count` .\n- [dagster-aws][community-contribution] Additional parameters can now be passed to the following resources: `CloudwatchLogsHandler`, `ECRPublicClient`, `SecretsManagerResource`, `SSMResource` thanks `@jacob-white-simplisafe` !\n- Added additional frontend telemetry. See https://docs.dagster.io/about/telemetry for more information.\n\n### Bugfixes\n\n- Fixed issue that could cause runs to fail if they targeted any assets which had a metadata value of type `TableMetadataValue`, `TableSchemaMetadataValue`, or `TableColumnLineageMetadataValue` defined.\n- Fixed an issue which could cause evaluations produced via the Auto-materialize system to not render the “skip”-type rules.\n- Backfills of asset jobs now correctly use the `BackfillPolicy` of the underlying assets in the job.\n- [dagster-databricks][community-contribution] `databricks-sdk` version bumped to `0.17.0`, thanks `@lamalex` !\n- [helm][community-contribution] resolved incorrect comments about `dagster code-server start` , thanks `@SanjaySiddharth` !\n\n### Documentation\n\n- Added section headings to Pipes API references, along with explanatory copy and links to relevant pages\n- Added a guide for subletting asset checks\n- Add more detailed steps to transition from serverless to hybrid\n- [community-contribution] asset selection syntax corrected, thanks `@JonathanLai2004`!\n\n### Dagster Plus\n\n- Fixed an issue where Dagster Cloud agents would wait longer than necessary when multiple code locations were timing out during a deployment.\n\n# 1.7.5 (core) / 0.23.5 (libraries)\n\n### New\n\n- The Asset > Checks tab now allows you to view plots of numeric metadata emitted by your checks.\n- The Asset > Events tab now supports infinite-scrolling, making it possible to view all historical materialization and observation events.\n- When constructing a `MaterializeResult`, `ObserveResult`, or `Output`, you can now include tags that will be attached to the corresponding `AssetMaterialization` or `AssetObservation` event. These tags will be rendered on these events in the UI.\n\n### Bugfixes\n\n- Fixed an issue where backfills would sometimes fail if a partition definition was changed in the middle of the backfill.\n- Fixed an issue where if the code server became unavailable during the first tick of a backfill, the backfill would stall and be unable to submit runs once the code server became available.\n- Fixed an issue where the status of an external asset would not get updated correctly.\n- Fixed an issue where run status sensors would sometimes fall behind in deployments with large numbers of runs.\n- The descriptions and metadata on the experimental `build_last_update_freshness_checks` and `build_time_partition_freshness_checks` APIs have been updated to be clearer.\n- The headers of tables no longer become misaligned when a scrollbar is present in some scenarios.\n- The sensor type, instigation type, and backfill status filters on their respective pages are now saved to the URL, so sharing the view or reloading the page preserve your filters.\n- Typing a `%` into the asset graph’s query selector no longer crashes the UI.\n- “Materializing” states on the asset graph animate properly in both light and dark themes.\n- Thanks to [@lautaro79](https://github.com/lautaro79) for fixing a helm chart issue.\n\n### Breaking Changes\n\n- Subclasses of `MetadataValue` have been changed from `NamedTuple`s to Pydantic models. `NamedTuple` functionality on these classes was not part of Dagster’s stable public API, but usages relying on their tuple-ness may break. For example: calling `json.dumps` on collections that include them.\n\n### Deprecations\n\n- [dagster-dbt] Support for `dbt-core==1.5.*` has been removed, as it has reached [end of life in April 2024](https://docs.getdbt.com/docs/dbt-versions/core).\n\n### Dagster Plus\n\n- Fixed an issue in the `dagster-cloud` CLI where the `--deployment` argument was ignored when the `DAGSTER_CLOUD_URL` environment variable was set.\n- Fixed an issue where `dagster-cloud-cli` package wouldn’t work unless the `dagster-cloud` package was installed as well.\n- A new “budget alerts” feature has launched for users on self-serve plans. This feature will alert you when you hit your credit limit.\n- The experimental asset health overview now allows you to group assets by compute kind, tag, and tag value.\n- The concurrency and locations pages in settings correctly show Dagster Plus-specific options when experimental navigation is enabled.\n\n# 1.7.4 (core) / 0.23.4 (libraries)\n\n### New\n\n- `TimeWindowPartitionMapping` now supports the `start_offset` and `end_offset` parameters even when the upstream `PartitionsDefinition` is different than the downstream `PartitionsDefinition`. The offset is expressed in units of downstream partitions, so `TimeWindowPartitionMapping(start_offset=-1)` between an hourly upstream and a daily downstream would map each downstream partition to 48 upstream partitions – those for the same and preceding day.\n\n### Bugfixes\n\n- Fixed an issue where certain exceptions in the Dagster daemon would immediately retry instead of waiting for a fixed interval before retrying.\n- Fixed a bug with asset checks in complex asset graphs that include cycles in the underlying nodes.\n- Fixed an issue that would cause unnecessary failures on FIPS-enabled systems due to the use of md5 hashes in non-security-related contexts (thanks [@jlloyd-widen](https://github.com/jlloyd-widen)!)\n- Removed `path` metadata from `UPathIOManager` inputs. This eliminates the creation of `ASSET_OBSERVATION` events for every input on every step for the default I/O manager.\n- Added support for defining `owners` on `@graph_asset`.\n- Fixed an issue where having multiple partitions definitions in a location with the same start date but differing end dates could lead to “`DagsterInvalidSubsetError` when trying to launch runs.\n\n### Documentation\n\n- Fixed a few issues with broken pages as a result of the Dagster+ rename.\n- Renamed a few instances of Dagster Cloud to Dagster+.\n- Added a note about external asset + alert incompatibility to the Dagster+ alerting docs.\n- Fixed references to outdated apis in freshness checks docs.\n\n### Dagster Plus\n\n- When creating a Branch Deployment via GraphQL or the `dagster-cloud branch-deployment` CLI, you can now specify the base deployment. The base deployment will be used for comparing assets for Change Tracking. For example, to set the base deployment to a deployment named `staging`: `dagster-cloud branch-deployment create-or-update --base-deployment-name staging ...`. Note that once a Branch Deployment is created, the base deployment cannot be changed.\n- Fixed an issue where agents serving many branch deployments simultaneously would sometimes raise a `413: Request Entity Too Large` error when uploading a heartbeat to the Dagster Plus servers.\n\n# 1.7.3 (core) / 0.23.3 (libraries)\n\n### New\n\n- `@graph_asset` now accepts a `tags` argument\n- [ui] For users whose light/dark mode theme setting is set to match their system setting, the theme will update automatically when the system changes modes (e.g. based on time of day), with no page reload required.\n- [ui] We have introduced the typefaces Geist and Geist Mono as our new default fonts throughout the Dagster app, with the goal of improving legibility, consistency, and maintainability.\n- [ui] [experimental] We have begun experimenting with a [new navigation structure](https://github.com/dagster-io/dagster/discussions/21370) for the Dagster UI. The change can be enabled via User Settings.\n- [ui] [experimental] Made performance improvements to the Concurrency settings page.\n- [dagster-azure] [community-contribution] ADLS2 IOManager supports custom timeout. Thanks @tomas-gajarsky!\n- [dagster-fivetran] [community-contribution] It’s now possible to specify destination ids in `load_asset_defs_from_fivetran_instance`. Thanks @lamalex!\n\n### Bugfixes\n\n- Fixed an issue where pressing the “Reset sensor status” button in the UI would also reset the sensor’s cursor.\n- Fixed a bug that caused input loading time not to be included in the reported step duration.\n- Pydantic warnings are no longer raised when importing Dagster with Pydantic 2.0+.\n- Fixed an issue which would cause incorrect behavior when auto-materializing partitioned assets based on updates to a parent asset in a different code location.\n- Fixed an issue which would cause every tick of the auto-materialize sensor to produce an evaluation for each asset, even if nothing had changed from the previous tick.\n- [dagster-dbt] Fixed a bug that could raise `Duplicate check specs` errors with singular tests ingested as asset checks.\n- [embedded-elt] resolved an issue where subset of resources were not recognized when using `source.with_resources(...)`\n- [ui] Fixed an issue where a sensor that targeted an invalid set of asset keys could cause the asset catalog to fail to load.\n- [ui] Fixed an issue in which runs in the Timeline that should have been considered overlapping were not correctly grouped together, leading to visual bugs.\n- [ui] On the asset overview page, job tags no longer render poorly when an asset appears in several jobs.\n- [ui] On the asset overview page, hovering over the timestamp tags in the metadata table explains where each entry originated.\n- [ui] Right clicking the background of the asset graph now consistently shows a context menu, and the lineage view supports vertical as well as horizontal layout.\n\n### Documentation\n\n- Sidebar navigation now appropriately handles command-click and middle-click to open links in a new tab.\n- Added a section for asset checks to the [Testing guide](https://docs.dagster.io/concepts/testing#testing-asset-checks).\n- Added a guide about [Column-level lineage for assets](https://docs.dagster.io/concepts/metadata-tags/asset-metadata/column-level-lineage).\n- Lots of updates to examples to reflect the new opt-in approach to I/O managers.\n\n### Dagster+\n\n- [ui] [experimental] A new Overview > Asset Health page provides visibility into failed and missing materializations, check warnings and check errors.\n- [ui] You can now share feedback with the Dagster team directly from the app. Open the Help menu in the top nav, then “Share feedback”. Bugs and feature requests are submitted directly to the Dagster team.\n- [ui] When editing a team, the list of team members is now virtualized, allowing for the UI to scale better for very large team sizes.\n- [ui] Fixed dark mode for billing components.\n\n# 1.7.2 (core) / 0.23.2 (libraries)\n\n### New\n\n- Performance improvements when loading large asset graphs in the Dagster UI.\n- `@asset_check` functions can now be invoked directly for unit testing.\n- `dagster-embedded-elt` dlt resource `DagsterDltResource` can now be used from `@op` definitions in addition to assets.\n- `UPathIOManager.load_partitions` has been added to assist with helping `UpathIOManager` subclasses deal with serialization formats which support partitioning. Thanks `@danielgafni`!\n- [dagster-polars] now supports other data types rather than only string for the partitioning columns. Also `PolarsDeltaIOManager` now supports `MultiPartitionsDefinition` with `DeltaLake` native partitioning. Metadata value `\"partition_by\": {\"dim_1\": \"col_1\", \"dim_2\": \"col_2\"}` should be specified to enable this feature. Thanks `@danielgafni`!\n\n### Bugfixes\n\n- [dagster-airbyte] Auto materialization policies passed to `load_assets_from_airbyte_instance` and `load_assets_from_airbyte_project` will now be properly propagated to the created assets.\n- Fixed an issue where deleting a run that was intended to materialize a partitioned asset would sometimes leave the status of that asset as “Materializing” in the Dagster UI.\n- Fixed an issue with `build_time_partition_freshness_checks` where it would incorrectly intuit that an asset was not fresh in certain cases.\n- [dagster-k8s] Fix an error on transient ‘none’ responses for pod waiting reasons. Thanks @**[piotrmarczydlo](https://github.com/piotrmarczydlo)!**\n- [dagster-dbt] Failing to build column schema metadata will now result in a warning rather than an error.\n- Fixed an issue where incorrect asset keys would cause a backfill to fail loudly.\n- Fixed an issue where syncing unmaterialized assets could include source assets.\n\n### Breaking Changes\n\n- [dagster-polars] `PolarsDeltaIOManager` no longer supports loading natively partitioned DeltaLake tables as dictionaries. They should be loaded as a single `pl.DataFrame`/`pl.LazyFrame` instead.\n\n### Documentation\n\n- Renamed `Dagster Cloud` to `Dagster+` all over the docs.\n- Added a page about [Change Tracking](https://docs.dagster.io/dagster-plus/managing-deployments/branch-deployments/change-tracking) in Dagster+ branch deployments.\n- Added a section about [user-defined metrics](https://docs.dagster.io/concepts/metadata-tags/asset-metadata#asset-owners) to the Dagster+ Insights docs.\n- Added a section about [Asset owners](https://docs.dagster.io/concepts/metadata-tags/asset-metadata#asset-owners) to the asset metadata docs.\n\n### Dagster Cloud\n\n- Branch deployments now have Change Tracking. Assets in each branch deployment will be compared to the main deployment. New assets and changes to code version, dependencies, partitions definitions, tags, and metadata will be marked in the UI of the branch deployment.\n- Pagerduty alerting is now supported with Pro plans. See the [documentation](https://docs.dagster.io/dagster-cloud/managing-deployments/alerts/pagerduty) for more info.\n- Asset metadata is now included in the insights metrics for jobs materializing those assets.\n- Per-run Insights are now available on individual assets.\n- Previously, the `before_storage_id` / `after_storage_id` values in the `AssetRecordsFilter` class were ignored. This has been fixed.\n- Updated the output of `dagster-cloud deployment alert-policies list` to match the format of `sync`.\n- Fixed an issue where Dagster Cloud agents with many code locations would sometimes leave code servers running after the agent shut down.\n\n# 1.7.1 (core) / 0.23.1 (libraries)\n\n### New\n\n- [dagster-dbt][experimental] A new cli command `dagster-dbt project prepare-for-deployment` has been added in conjunction with `DbtProject` for managing the behavior of rebuilding the manifest during development and preparing a pre-built one for production.\n\n### Bugfixes\n\n- Fixed an issue with duplicate asset check keys when loading checks from a package.\n- A bug with the new `build_last_update_freshness_checks` and `build_time_partition_freshness_checks` has been fixed where multi_asset checks passed in would not be executable.\n- [dagster-dbt] Fixed some issues with building column lineage for incremental models, models with implicit column aliases, and models with columns that have multiple dependencies on the same upstream column.\n\n### Breaking Changes\n\n- [dagster-dbt] The experimental `DbtArtifacts` class has been replaced by `DbtProject`.\n\n### Documentation\n\n- Added a dedicated concept page for all things [metadata and tags](https://docs.dagster.io/concepts/metadata-tags)\n- Moved asset metadata content to a dedicated concept page: [Asset metadata](https://docs.dagster.io/concepts/metadata-tags/asset-metadata)\n- Added section headings to the [Software-defined Assets API reference](https://docs.dagster.io/_apidocs/assets), which groups APIs by asset type or use\n- Added a guide about [user settings in the Dagster UI](https://docs.dagster.io/concepts/webserver/ui-user-settings)\n- Added `AssetObservation` to the Software-defined Assets API reference\n- Renamed Dagster Cloud GitHub workflow files to the new, consolidated `dagster-cloud-deploy.yml`\n- Miscellaneous formatting and copy updates\n- [community-contribution] [dagster-embedded-elt] Fixed `get_asset_key` API documentation (thanks @aksestok!)\n- [community-contribution] Updated Python version in contributing documentation (thanks @piotrmarczydlo!)\n- [community-contribution] Typo fix in README (thanks @MiConnell!)\n\n### Dagster Cloud\n\n- Fixed a bug where an incorrect value was being emitted for BigQuery bytes billed in Insights.\n\n# 1.7.0 (core) / 0.23.0 (libraries)\n\n## Major Changes since 1.6.0 (core) / 0.22.0 (libraries)\n\n- Asset definitions can now have tags, via the `tags` argument on `@asset`, `AssetSpec`, and `AssetOut`. [Tags](https://docs.dagster.io/concepts/metadata-tags/tags) are meant to be used for organizing, filtering, and searching for assets.\n- The Asset Details page has been revamped to include an “Overview” tab that centralizes the most important information about the asset – such as current status, description, and columns – in a single place.\n- Assets can now be assigned owners.\n- Asset checks are now considered generally available and will no longer raise experimental warnings when used.\n- Asset checks can now be marked `blocking`, which causes downstream assets in the same run to be skipped if the check fails with ERROR-level severity.\n- The new `@multi_asset_check` decorator enables defining a single op that executes multiple asset checks.\n- The new `build_last_updated_freshness_checks` and `build_time_partition_freshness_checks` APIs allow defining asset checks that error or warn when an asset is overdue for an update. Refer to the [Freshness checks guide](https://docs.dagster.io/concepts/assets/asset-checks/checking-for-data-freshness) for more info.\n- The new `build_column_schema_change_checks` API allows defining asset checks that warn when an asset’s columns have changed since its latest materialization.\n- In the asset graph UI, the “Upstream data”, “Code version changed”, and “Upstream code version” statuses have been collapsed into a single “Unsynced” status. Clicking on “Unsynced” displays more detailed information.\n- I/O managers are now optional. This enhances flexibility for scenarios where they are not necessary. For guidance, see [When to use I/O managers](https://docs.dagster.io/concepts/io-management/io-managers#when-to-use-io-managers).\n  - Assets with `None` or `MaterializeResult` return type annotations won't use I/O managers; dependencies for these assets can be set using the `deps` parameter in the `@asset` decorator.\n- [dagster-dbt] Dagster’s dbt integration can now be configured to automatically collect [metadata about column schema and column lineage](https://docs.dagster.io/integrations/dbt/reference#emit-column-level-metadata-as-materialization-metadata-).\n- [dagster-dbt] dbt tests are now pulled in as Dagster asset checks by default.\n- [dagster-dbt] dbt resource tags are now automatically pulled in as Dagster asset tags.\n- [dagster-snowflake] [dagster-gcp] The dagster-snowflake and dagster-gcp packages now both expose a `fetch_last_updated_timestamps` API, which makes it straightforward to collect data freshness information in source asset observation functions.\n\n## Changes since 1.6.14 (core) / 0.22.14 (libraries)\n\n### New\n\n- Metadata attached during asset or op execution can now be accessed in the I/O manager using `OutputContext.output_metadata`.\n- [experimental] Single-run backfills now support batched inserts of asset materialization events. This is a major performance improvement for large single-run backfills that have database writes as a bottleneck. The feature is off by default and can be enabled by setting the `DAGSTER_EVENT_BATCH_SIZE` environment variable in a code server to an integer (25 recommended, 50 max). It is only currently supported in Dagster Cloud and OSS deployments with a postgres backend.\n- [ui] The new Asset Details page is now enabled for new users by default. To turn this feature off, you can toggle the feature in the User Settings.\n- [ui] Queued runs now display a link to view all the potential reasons why a run might remain queued.\n- [ui] Starting a run status sensor with a stale cursor will now warn you in the UI that it will resume from the point that it was paused.\n- [asset-checks] Asset checks now support asset names that include `.`, which can occur when checks are ingested from dbt tests.\n- [dagster-dbt] The env var `DBT_INDIRECT_SELECTION` will no longer be set to `empty` when executing dbt tests as asset checks, unless specific asset checks are excluded. `dagster-dbt` will no longer explicitly select all dbt tests with the dbt cli, which had caused argument length issues.\n- [dagster-dbt] Singular tests with a single dependency are now ingested as asset checks.\n- [dagster-dbt] Singular tests with multiple dependencies must have the primary dependency must be specified using dbt meta.\n\n```sql\n{{\n    config(\n        meta={\n            'dagster': {\n                'ref': {\n                    'name': <ref_name>,\n                    'package': ... # Optional, if included in the ref.\n                    'version': ... # Optional, if included in the ref.\n                },\n            }\n        }\n    )\n}}\n\n...\n```\n\n- [dagster-dbt] Column lineage metadata can now be emitted when invoking dbt. See the [documentation for details](https://docs.dagster.io/integrations/dbt/reference#emit-column-level-metadata-as-materialization-metadata-).\n- [experimental][dagster-embedded-elt] Add the data load tool (dlt) integration for easily building and integration dlt ingestion pipelines with Dagster.\n- [dagster-dbt][community-contribution] You can now specify a custom schedule name for schedules created with `build_schedule_from_dbt_selection`. Thanks [@dragos-pop](https://github.com/dragos-pop)!\n- [helm][community-contribution] You can now specify a custom job namespace for your user code deployments. Thanks [@tmatthews0020](https://github.com/tmatthews0020)!\n- [dagster-polars][community-contribution] Column schema metadata is now integrated using the dagster-specific metadata key in `dagster_polars`. Thanks [@danielgafni](https://github.com/danielgafni)!\n- [dagster-datadog][community-contribution] Added `datadog.api` module to the `DatadogClient` resource, enabling direct access to API methods. Thanks [@shivgupta](https://github.com/shivonchain)!\n\n### Bugfixes\n\n- Fixed a bug where run status sensors configured to monitor a specific job would trigger for jobs with the same name in other code locations.\n- Fixed a bug where multi-line asset check result descriptions were collapsed into a single line.\n- Fixed a bug that caused a value to show up under “Target materialization” in the asset check UI even when an asset had had observations but never been materialized.\n- Changed typehint of `metadata` argument on `multi_asset` and `AssetSpec` to `Mapping[str, Any]`.\n- [dagster-snowflake-pandas] Fixed a bug introduced in 0.22.4 where column names were not using quote identifiers correctly. Column names will now be quoted.\n- [dagster-aws] Fixed an issue where a race condition where simultaneously materializing the same asset more than once would sometimes raise an Exception when using the `s3_io_manager`.\n- [ui] Fixed a bug where resizable panels could inadvertently be hidden and never recovered, for instance the right panel on the global asset graph.\n- [ui] Fixed a bug where opening a run with an op selection in the Launchpad could lose the op selection setting for the subsequently launched run. The op selection is now correctly preserved.\n- [community-contribution] Fixed `dagster-polars` tests by excluding `Decimal` types. Thanks [@ion-elgreco](https://github.com/ion-elgreco)!\n- [community-contribution] Fixed a bug where auto-materialize rule evaluation would error on FIPS-compliant machines. Thanks [@jlloyd-widen](https://github.com/jlloyd-widen)!\n- [community-contribution] Fixed an issue where an excessive DeprecationWarning was being issued for a `ScheduleDefinition` passed into the `Definitions` object. Thanks [@2Ryan09](https://github.com/2Ryan09)!\n\n### Breaking Changes\n\n- Creating a run with a custom non-UUID `run_id` was previously private and only used for testing. It will now raise an exception.\n- [community-contribution] Previously, calling `get_partition_keys_in_range` on a `MultiPartitionsDefinition` would erroneously return partition keys that were within the one-dimensional range of alphabetically-sorted partition keys for the definition. Now, this method returns the cartesian product of partition keys within each dimension’s range. Thanks, [@mst](https://github.com/mst)!\n- Added `AssetCheckExecutionContext` to replace `AssetExecutionContext` as the type of the `context` param passed in to `@asset_check` functions. `@asset_check` was an experimental decorator.\n- [experimental] `@classmethod` decorators have been removed from [dagster-embedded-slt.sling](http://dagster-embedded-slt.sling) `DagsterSlingTranslator`\n- [dagster-dbt] `@classmethod` decorators have been removed from `DagsterDbtTranslator`.\n- [dagster-k8s] The default merge behavior when raw kubernetes config is supplied at multiple scopes (for example, at the instance level and for a particluar job) has been changed to be more consistent. Previously, configuration was merged shallowly by default, with fields replacing other fields instead of appending or merging. Now, it is merged deeply by default, with lists appended to each other and dictionaries merged, in order to be more consistent with how kubernetes configuration is combined in all other places. See [the docs](https://docs.dagster.io/deployment/guides/kubernetes/customizing-your-deployment#precedence-rules) for more information, including how to restore the previous default merge behavior.\n\n### Deprecations\n\n- `AssetSelection.keys()` has been deprecated. Instead, you can now supply asset key arguments to `AssetSelection.assets()` .\n- Run tag keys with long lengths and certain characters are now deprecated. For consistency with asset tags, run tags keys are expected to only contain alpha-numeric characters, dashes, underscores, and periods. Run tag keys can also contain a prefix section, separated with a slash. The main section and prefix section of a run tag are limited to 63 characters.\n- `AssetExecutionContext` has been simplified. Op-related methods and methods with existing access paths have been marked deprecated. For a full list of deprecated methods see this [GitHub Discussion](https://github.com/dagster-io/dagster/discussions/20974).\n- The `metadata` property on `InputContext` and `OutputContext` has been deprecated and renamed to `definition_metadata` .\n- `FreshnessPolicy` is now deprecated. For monitoring freshness, use freshness checks instead. If you are using `AutoMaterializePolicy.lazy()`, `FreshnessPolicy` is still recommended, and will continue to be supported until an alternative is provided.\n\n### Documentation\n\n- Lots of updates to examples to reflect the recent opt-in nature of I/O managers\n- [Dagster Cloud alert guides](https://docs.dagster.io/dagster-cloud/managing-deployments/alerts) have been split up by alert type:\n  - [Managing alerts in the Dagster Cloud UI](https://docs.dagster.io/dagster-cloud/managing-deployments/alerts/managing-alerts-in-ui)\n  - [Managing alerts using the dagster-cloud CLI](https://docs.dagster.io/dagster-cloud/managing-deployments/alerts/managing-alerts-cli)\n  - [Email alerts](https://docs.dagster.io/dagster-cloud/managing-deployments/alerts/email)\n  - [Microsoft Teams alerts](https://docs.dagster.io/dagster-cloud/managing-deployments/alerts/microsoft-teams)\n  - [Slack alerts](https://docs.dagster.io/dagster-cloud/managing-deployments/alerts/slack)\n- Added info about asset check-based-alerts to the Dagster Cloud [alerting docs](https://docs.dagster.io/dagster-cloud/managing-deployments/alerts)\n- The [Asset checks documentation](https://docs.dagster.io/concepts/asset-checks) got a face lift - info about defining and executing asset checks [now lives in its own guide](https://docs.dagster.io/concepts/assets/asset-checks/define-execute-asset-checks)\n- Added a new guide for [using freshness checks](https://docs.dagster.io/concepts/assets/asset-checks/checking-for-data-freshness) to the Asset checks documentation\n- Cleaned up the [Getting help guide](https://docs.dagster.io/getting-started/getting-help) - it now includes a high-level summary of all Dagster support resources, making it easier to skim!\n- [community-contribution] Fixed the indentation level of a code snippet in the `dagster-polars` documentation. Thanks [@danielgafni](https://github.com/danielgafni)!\n\n### Dagster Cloud\n\n- The Dagster Cloud agent will now monitor the code servers that it spins to detect whether they have stopped serving requests, and will automatically redeploy the code server if it has stopped responding for an extended period of time.\n- New additions and bugfixes in Insights:\n  - Added per-metric cost estimation. Estimates can be added via the “Insights settings” button, and will appear in the table and chart for that metric.\n  - Branch deployments are now included in the deployment filter control.\n  - In the Deployments view, fixed deployment links in the data table.\n  - Added support for BigQuery cost metrics.\n\n# 1.6.14 (core) / 0.22.14 (libraries)\n\n### Bugfixes\n\n- [dagster-dbt] Fixed some issues with building column lineage metadata.\n\n# 1.6.13 (core) / 0.22.13 (libraries)\n\n### Bugfixes\n\n- Fixed a bug where an asset with a dependency on a subset of the keys of a parent multi-asset could sometimes crash asset job construction.\n- Fixed a bug where a Definitions object containing assets having integrated asset checks and multiple partitions definitions could not be loaded.\n\n# 1.6.12 (core) / 0.22.12 (libraries)\n\n### New\n\n- `AssetCheckResult` now has a text `description` property. Check evaluation descriptions are shown in the Checks tab on the asset details page.\n- Introduced `TimestampMetadataValue`. Timestamp metadata values are represented internally as seconds since the Unix epoch. They can be constructed using `MetadataValue.timestamp`. In the UI, they’re rendered in the local timezone, like other timestamps in the UI.\n- `AssetSelection.checks` can now accept `AssetCheckKeys` as well as `AssetChecksDefinition`.\n- [community-contribution] Metadata attached to an output at runtime (via either `add_output_metadata` or by passing to `Output`) is now available on `HookContext` under the `op_output_metadata` property. Thanks [@JYoussouf](https://github.com/JYoussouf)!\n- [experimental] `@asset`, `AssetSpec`, and `AssetOut` now accept a `tags` property. Tags are key-value pairs meant to be used for organizing asset definitions. If `\"__dagster_no_value\"` is set as the value, only the key will be rendered in the UI. `AssetSelection.tag` allows selecting assets that have a particular tag.\n- [experimental] Asset tags can be used in asset CLI selections, e.g. `dagster asset materialize --select tag:department=marketing`\n- [experimental][dagster-dbt] Tags can now be configured on dbt assets, using `DagsterDbtTranslator.get_tags`. By default, we take the dbt tags configured on your dbt models, seeds, and snapshots.\n- [dagster-gcp] Added get_gcs_keys sensor helper function.\n\n### Bugfixes\n\n- Fixed a bug that prevented external assets with dependencies from displaying properly in Dagster UI.\n- Fix a performance regression in loading code locations with large multi-assets.\n- [community-contribution] [dagster-databricks] Fix a bug with the `DatabricksJobRunner` that led to an inability to use dagster-databricks with Databricks instance pools. Thanks [@smats0n](https://github.com/smats0n)!\n- [community-contribution] Fixed a bug that caused a crash when external assets had hyphens in their `AssetKey`. Thanks [@maxfirman](https://github.com/maxfirman)!\n- [community-contribution] Fix a bug with `load_assets_from_package_module` that would cause a crash when any submodule had the same directory name as a dependency. Thanks [@CSRessel](https://github.com/CSRessel)!\n- [community-contribution] Fixed a mypy type error, thanks @parthshyara!\n- [community-contribution][dagster-embedded-elt] Fixed an issue where Sling assets would not properly read group and description metadata from replication config, thanks @jvyoralek!\n- [community-contribution] Ensured annotations from the helm chart properly propagate to k8s run pods, thanks @maxfirman!\n\n### Dagster Cloud\n\n- Fixed an issue in Dagster Cloud Serverless runs where multiple runs simultaneously materializing the same asset would sometimes raise a “Key not found” exception.\n- Fixed an issue when using [agent replicas](https://docs.dagster.io/dagster-cloud/deployment/agents/running-multiple-agents#running-multiple-agents-in-the-same-environment) where one replica would sporadically remove a code server created by another replica due to a race condition, leading to a “code server not found” or “Deployment not found” exception.\n- [experimental] The metadata key for specifying column schema that will be rendered prominently on the new Overview tab of the asset details page has been changed from `\"columns\"` to `\"dagster/column_schema\"`. Materializations using the old metadata key will no longer result in the Columns section of the tab being filled out.\n- [ui] Fixed an Insights bug where loading a view filtered to a specific code location would not preserve that filter on pageload.\n\n# 1.6.11 (core) / 0.22.11 (libraries)\n\n### Bugfixes\n\n- Fixed an issue where `dagster dev` or the Dagster UI would display an error when loading jobs created with op or asset selections.\n\n# 1.6.10 (core) / 0.22.10 (libraries)\n\n### New\n\n- Latency improvements to the scheduler when running many simultaneous schedules.\n\n### Bugfixes\n\n- The performance of loading the Definitions snapshot from a code server when large `@multi_asset` s are in use has been drastically improved.\n- The snowflake quickstart example project now renames the “by” column to avoid reserved snowflake names. Thanks @[jcampbell](https://github.com/jcampbell)!\n- The existing group name (if any) for an asset is now retained if `the_asset.with_attributes` is called without providing a group name. Previously, the existing group name was erroneously dropped. Thanks @[ion-elgreco](https://github.com/ion-elgreco)!\n- [dagster-dbt] Fixed an issue where Dagster events could not be streamed from `dbt source freshness`.\n- [dagster university] Removed redundant use of `MetadataValue` in Essentials course. Thanks @[stianthaulow](https://github.com/stianthaulow)!\n- [ui] Increased the max number of plots on the asset plots page to 100.\n\n### Breaking Changes\n\n- The `tag_keys` argument on `DagsterInstance.get_run_tags`is no longer optional. This has been done to remove an easy way of accidentally executing an extremely expensive database operation.\n\n### Dagster Cloud\n\n- The maximum number of concurrent runs across all branch deployments is now configurable. This setting can now be set via GraphQL or the CLI.\n- [ui] In Insights, fixed display of table rows with zero change in value from the previous time period.\n- [ui] Added deployment-level Insights.\n- [ui] Fixed an issue causing void invoices to show up as “overdue” on the billing page.\n- [experimental] Branch deployments can now indicate the new and modified assets in the branch deployment as compared to the main deployment. To enable this feature, turn on the “Enable experimental branch deployment asset graph diffing” user setting.\n\n# 1.6.9 (core) / 0.22.9 (libraries)\n\n### New\n\n- [ui] When viewing logs for a run, the date for a single log row is now shown in the tooltip on the timestamp. This helps when viewing a run that takes place over more than one date.\n- Added suggestions to the error message when selecting asset keys that do not exist as an upstream asset or in an `AssetSelection.`\n- Improved error messages when trying to materialize a subset of a multi-asset which cannot be subset.\n- [dagster-snowflake] `dagster-snowflake` now requires `snowflake-connector-python>=3.4.0`\n- [embedded-elt] `@sling_assets` accepts an optional name parameter for the underlying op\n- [dagster-openai] `dagster-openai` library is now available.\n- [dagster-dbt] Added a new setting on `DagsterDbtTranslatorSettings` called `enable_duplicate_source_asset_keys` that allows users to set duplicate asset keys for their dbt sources. Thanks @hello-world-bfree!\n- Log messages in the Dagster daemon for unloadable sensors and schedules have been removed.\n- [ui] Search now uses a cache that persists across pageloads which should greatly improve search performance for very large orgs.\n- [ui] groups/code locations in the asset graph’s sidebar are now sorted alphabetically.\n\n### Bugfixes\n\n- Fixed issue where the input/output schemas of configurable IOManagers could be ignored when providing explicit input / output run config.\n- Fixed an issue where enum values could not properly have a default value set in a `ConfigurableResource`.\n- Fixed an issue where graph-backed assets would sometimes lose user-provided descriptions due to a bug in internal copying.\n- [auto-materialize] Fixed an issue introduced in 1.6.7 where updates to ExternalAssets would be ignored when using AutoMaterializePolicies which depended on parent updates.\n- [asset checks] Fixed a bug with asset checks in step launchers.\n- [embedded-elt] Fix a bug when creating a `SlingConnectionResource` where a blank keyword argument would be emitted as an environment variable\n- [dagster-dbt] Fixed a bug where emitting events from `dbt source freshness` would cause an error.\n- [ui] Fixed a bug where using the “Terminate all runs” button with filters selected would not apply the filters to the action.\n- [ui] Fixed an issue where typing a search query into the search box before the search data was fetched would yield “No results” even after the data was fetched.\n\n### Community Contributions\n\n- [docs] fixed typo in embedded-elt.mdx (thanks [@cameronmartin](https://github.com/cameronmartin))!\n- [dagster-databricks] log the url for the run of a databricks job (thanks [@smats0n](https://github.com/smats0n))!\n- Fix missing partition property (thanks [christeefy](https://github.com/christeefy))!\n- Add op_tags to @observable_source_asset decorator (thanks [@maxfirman](https://github.com/maxfirman))!\n- [docs] typo in MultiPartitionMapping docs (thanks [@dschafer](https://github.com/dschafer))\n- Allow github actions to checkout branch from forked repo for docs changes (ci fix) (thanks [hainenber](https://github.com/hainenber))!\n\n### Experimental\n\n- [asset checks] UI performance of asset checks related pages has been improved.\n- [dagster-dbt] The class `DbtArtifacts` has been added for managing the behavior of rebuilding the manifest during development but expecting a pre-built one in production.\n\n### Documentation\n\n- Added example of writing compute logs to AWS S3 when customizing agent configuration.\n- \"Hello, Dagster\" is now \"Dagster Quickstart\" with the option to use a Github Codespace to explore Dagster.\n- Improved guides and reference to better running multiple isolated agents with separate queues on ECS.\n\n### Dagster Cloud\n\n- Microsoft Teams is now supported for alerts. [Documentation](https://docs.dagster.io/dagster-cloud/managing-deployments/setting-up-alerts)\n- A `send sample alert` button now exists on both the alert policies page and in the alert policies editor to make it easier to debug and configure alerts without having to wait for an event to kick them off.\n\n# 1.6.8 (core) / 0.22.8 (libraries)\n\n### Bugfixes\n\n- [dagster-embedded-elt] Fixed a bug in the `SlingConnectionResource` that raised an error when connecting to a database.\n\n### Experimental\n\n- [asset checks] `graph_multi_assets` with `check_specs` now support subsetting.\n\n# 1.6.7 (core) / 0.22.7 (libraries)\n\n### New\n\n- Added a new `run_retries.retry_on_op_or_asset_failures` setting that can be set to false to make run retries only occur when there is an unexpected failure that crashes the run, allowing run-level retries to co-exist more naturally with op or asset retries. See [the docs](https://docs.dagster.io/deployment/run-retries#combining-op-and-run-retries) for more information.\n- `dagster dev` now sets the environment variable `DAGSTER_IS_DEV_CLI` allowing subprocesses to know that they were launched in a development context.\n- [ui] The Asset Checks page has been updated to show more information on the page itself rather than in a dialog.\n\n### Bugfixes\n\n- [ui] Fixed an issue where the UI disallowed creating a dynamic partition if its name contained the “|” pipe character.\n- AssetSpec previously dropped the metadata and code_version fields, resulting in them not being attached to the corresponding asset. This has been fixed.\n\n### Experimental\n\n- The new `@multi_observable_source_asset` decorator enables defining a set of assets that can be observed together with the same function.\n- [dagster-embedded-elt] New Asset Decorator `@sling_assets` and Resource `SlingConnectionResource` have been added for the `[dagster-embedded-elt.sling](http://dagster-embedded-elt.sling)` package. Deprecated `build_sling_asset`, `SlingSourceConnection` and `SlingTargetConnection`.\n- Added support for op-concurrency aware run dequeuing for the `QueuedRunCoordinator`.\n\n### Documentation\n\n- Fixed reference documentation for isolated agents in ECS.\n- Corrected an example in the Airbyte Cloud documentation.\n- Added API links to OSS Helm deployment guide.\n- Fixed in-line pragmas showing up in the documentation.\n\n### Dagster Cloud\n\n- Alerts now support Microsoft Teams.\n- [ECS] Fixed an issue where code locations could be left undeleted.\n- [ECS] ECS agents now support setting multiple replicas per code server.\n- [Insights] You can now toggle the visibility of a row in the chart by clicking on the dot for the row in the table.\n- [Users] Added a new column “Licensed role” that shows the user's most permissive role.\n\n# 1.6.6 (core) / 0.22.6 (libraries)\n\n### New\n\n- Dagster officially supports Python 3.12.\n- `dagster-polars` has been added as an integration. Thanks @danielgafni!\n- [dagster-dbt] `@dbt_assets` now supports loading projects with semantic models.\n- [dagster-dbt] `@dbt_assets` now supports loading projects with model versions.\n- [dagster-dbt] `get_asset_key_for_model` now supports retrieving asset keys for seeds and snapshots. Thanks @aksestok!\n- [dagster-duckdb] The Dagster DuckDB integration supports DuckDB version 0.10.0.\n- [UPath I/O manager] If a non-partitioned asset is updated to have partitions, the file containing the non-partitioned asset data will be deleted when the partitioned asset is materialized, rather than raising an error.\n\n### Bugfixes\n\n- Fixed an issue where creating a backfill of assets with dynamic partitions and a backfill policy would sometimes fail with an exception.\n- Fixed an issue with the type annotations on the `@asset` decorator causing a false positive in Pyright strict mode. Thanks @tylershunt!\n- [ui] On the asset graph, nodes are slightly wider allowing more text to be displayed, and group names are no longer truncated.\n- [ui] Fixed an issue where the groups in the asset graph would not update after an asset was switched between groups.\n- [dagster-k8s] Fixed an issue where setting the `security_context` field on the `k8s_job_executor` didn't correctly set the security context on the launched step pods. Thanks @krgn!\n\n### Experimental\n\n- Observable source assets can now yield `ObserveResult`s with no `data_version`.\n- You can now include `FreshnessPolicy`s on observable source assets. These assets will be considered “Overdue” when the latest value for the “dagster/data_time” metadata value is older than what’s allowed by the freshness policy.\n- [ui] In Dagster Cloud, a new feature flag allows you to enable an overhauled asset overview page with a high-level stakeholder view of the asset’s health, properties, and column schema.\n\n### Documentation\n\n- Updated docs to reflect newly-added support for Python 3.12.\n\n### Dagster Cloud\n\n- [kubernetes] Fixed an issue where the Kubernetes agent would sometimes leave dangling kubernetes services if the agent was interrupted during the middle of being terminated.\n\n# 1.6.5 (core) / 0.22.5 (libraries)\n\n### New\n\n- Within a backfill or within auto-materialize, when submitting runs for partitions of the same assets, runs are now submitted in lexicographical order of partition key, instead of in an unpredictable order.\n- [dagster-k8s] Include k8s pod debug info in run worker failure messages.\n- [dagster-dbt] Events emitted by `DbtCliResource` now include metadata from the dbt adapter response. This includes fields like `rows_affected`, `query_id` from the Snowflake adapter, or `bytes_processed` from the BigQuery adapter.\n\n### Bugfixes\n\n- A previous change prevented asset backfills from grouping multiple assets into the same run when using BackfillPolicies under certain conditions. While the backfills would still execute in the proper order, this could lead to more individual runs than necessary. This has been fixed.\n- [dagster-k8s] Fixed an issue introduced in the 1.6.4 release where upgrading the Helm chart without upgrading the Dagster version used by user code caused failures in jobs using the `k8s_job_executor`.\n- [instigator-tick-logs] Fixed an issue where invoking `context.log.exception` in a sensor or schedule did not properly capture exception information.\n- [asset-checks] Fixed an issue where additional dependencies for dbt tests modeled as Dagster asset checks were not properly being deduplicated.\n- [dagster-dbt] Fixed an issue where dbt model, seed, or snapshot names with periods were not supported.\n\n### Experimental\n\n- `@observable_source_asset`-decorated functions can now return an `ObserveResult`. This allows including metadata on the observation, in addition to a data version. This is currently only supported for non-partitioned assets.\n- [auto-materialize] A new `AutoMaterializeRule.skip_on_not_all_parents_updated_since_cron` class allows you to construct `AutoMaterializePolicys` which wait for all parents to be updated after the latest tick of a given cron schedule.\n- [Global op/asset concurrency] Ops and assets now take run priority into account when claiming global op/asset concurrency slots.\n\n### Documentation\n\n- Fixed an error in our asset checks docs. Thanks [@vaharoni](https://github.com/vaharoni)!\n- Fixed an error in our Dagster Pipes Kubernetes docs. Thanks [@cameronmartin](https://github.com/cameronmartin)!\n- Fixed an issue on the Hello Dagster! guide that prevented it from loading.\n- Add specific capabilities of the Airflow integration to the Airflow integration page.\n- Re-arranged sections in the I/O manager concept page to make info about using I/O versus resources more prominent.\n\n# 1.6.4 (core) / 0.22.4 (libraries)\n\n### New\n\n- `build_schedule_from_partitioned_job` now supports creating a schedule from a static-partitioned job (Thanks `@craustin`!)\n- [dagster-pipes] `PipesK8sClient` will now autodetect the namespace when using in-cluster config. (Thanks `@aignas`!)\n- [dagster-pipes] `PipesK8sClient` can now inject the context in to multiple containers. (Thanks `@aignas`!)\n- [dagster-snowflake] The Snowflake Pandas I/O manager now uses the `write_pandas` method to load Pandas DataFrames in Snowflake. To support this change, the database connector was switched from `SqlDbConnection` to `SnowflakeConnection` .\n- [ui] On the overview sensors page you can now filter sensors by type.\n- [dagster-deltalake-polars] Added LazyFrame support (Thanks `@ion-elgreco`!)\n- [dagster-dbt] When using `@dbt_assets` and multiple dbt resources produce the same `AssetKey`, we now display an exception message that highlights the file paths of the misconfigured dbt resources in your dbt project.\n- [dagster-k8s] The debug info reported upon failure has been improved to include additional information from the Job. (Thanks `@jblawatt`!)\n- [dagster-k8s] Changed the Dagster Helm chart to apply `automountServiceAccountToken: false` to the default service account used by the Helm chart, in order to better comply with security policies. (Thanks `@MattyKuzyk`!)\n\n### Bugfixes\n\n- A unnecessary thread lock has been removed from the sensor daemon. This should improve sensor throughput for users with many sensors who have enabled threading.\n- Retry from failure behavior has been improved for cases where dynamic steps were interrupted.\n- Previously, when backfilling a set of assets which shared a BackfillPolicy and PartitionsDefinition, but had a non-default partition mapping between them, a run for the downstream asset could be launched at the same time as a separate run for the upstream asset, resulting in inconsistent partition ordering. Now, the downstream asset will only execute after the parents complete. (Thanks `@ruizh22`!)\n- Previously, asset backfills would raise an exception if the code server became unreachable mid-iteration. Now, the backfill will pause until the next evaluation.\n- Fixed a bug that was causing ranged backfills over dynamically partitioned assets to fail.\n- [dagster-pipes] `PipesK8sClient` has improved handling for init containers and additional containers. (Thanks `@aignas`!)\n- Fixed the `last_sensor_start_time` property of the `SensorEvaluationContext`, which would get cleared on ticks after the first tick after the sensor starts.\n- [dagster-mysql] Fixed the optional `dagster instance migrate --bigint-migration`, which caused some operational errors on mysql storages.\n- [dagster-dbt] Fixed a bug introduced in 1.6.3 that caused errors when ingesting asset checks with multiple dependencies.\n\n### Deprecations\n\n- The following methods on `AssetExecutionContext` have been marked deprecated, with their suggested replacements in parenthesis:\n  - `context.op_config` (`context.op_execution_context.op_config`)\n  - `context.node_handle` (`context.op_execution_context.node_handle`)\n  - `context.op_handle` (`context.op_execution_context.op_handle`)\n  - `context.op` (`context.op_execution_context.op`)\n  - `context.get_mapping_key` (`context.op_execution_context.get_mapping_key`)\n  - `context.selected_output_names` (`context.op_execution_context.selected_output_names`)\n  - `context.dagster_run` (`context.run`)\n  - `context.run_id` (`context.run.run_id`)\n  - `context.run_config` (`context.run.run_config`)\n  - `context.run_tags` (`context.run.tags`)\n  - `context.has_tag` (`key in context.run.tags`)\n  - `context.get_tag` (`context.run.tags.get(key)`)\n  - `context.get_op_execution_context` (`context.op_execution_context`)\n  - `context.asset_partition_key_for_output` (`context.partition_key`)\n  - `context.asset_partition_keys_for_output` (`context.partition_keys`)\n  - `context.asset_partitions_time_window_for_output` (`context.partition_time_window`)\n  - `context.asset_partition_key_range_for_output` (`context.partition_key_range`)\n\n### Experimental\n\n- [asset checks] `@asset_check` now has a `blocking` parameter. When this is enabled, if the check fails with severity `ERROR` then any downstream assets in the same run won’t execute.\n\n### Documentation\n\n- The Branch Deployment docs have been updated to reflect support for backfills\n- Added Dagster’s maximum supported Python version (3.11) to Dagster University and relevant docs\n- Added documentation for recommended partition limits (a maximum of 25K per asset).\n- References to the Enterprise plan have been renamed to Pro, to reflect recent plan name changes\n- Added syntax example for setting environment variables in PowerShell to our dbt with Dagster tutorial\n- [Dagster University] Dagster Essentials to Dagster v1.6, and introduced the usage of `MaterializeResult`\n- [Dagster University] Fixed a typo in the Dagster University section on adding partitions to an asset (Thanks Brandon Peebles!)\n- [Dagster University] Corrected lesson where sensors are covered (Thanks onefloid!)\n\n### Dagster Cloud\n\n- Agent tokens can now be locked down to particular deployments. Agents will not be able to run any jobs scheduled for deployments that they are not permitted to access. By default, agent tokens have access to all deployments in an organization. Use the `Edit` button next to an agent token on the `Tokens` tab in `Org Settings` to configure permissions for a particular token. You must be an Organization Admin to edit agent token permissions.\n\n# 1.6.3 (core) / 0.22.3 (libraries)\n\n### New\n\n- Added support for the 3.0 release of the `pendulum` library, for Python versions 3.9 and higher.\n- Performance improvements when starting run worker processes or step worker processes for runs in code locations with a large number of jobs.\n- `AllPartitionMapping` now supports mapping to downstream partitions, enabling asset backfills with these dependencies. Thanks [@craustin](https://github.com/craustin)!\n- [asset checks][experimental] `@asset_check` has new fields `additional_deps` and `additional_ins` to allow dependencies on assets other than the asset being checked.\n- [ui] Asset graph group nodes now show status counts.\n  - [dagster-snowflake] The Snowflake I/O Manager now has more specific error handling when a table doesn’t exist.\n- [ui] [experimental] A new experimental UI for the auto-materialize history of a specific asset has been added. This view can be enabled under your user settings by setting “Use new asset auto-materialize history page”.\n- [ui] Command clicking on an asset group will now select or deselect all assets in that group.\n- [dagster-k8s] Added the ability to customize resource limits for initContainers used by Dagster system components in the Dagster Helm chart. Thanks **[@MattyKuzyk](https://github.com/MattyKuzyk)**!\n- [dagster-k8s] Added the ability to specify additional containers and initContainers in code locations in the Helm chart. Thanks **[@craustin](https://github.com/craustin)**!\n- [dagster-k8s] Explicitly listed the set of RBAC permissions used by the agent Helm chart role instead of using a wildcard. Thanks **[@easontm](https://github.com/easontm)**!\n- [dagster-dbt] Support for `dbt-core==1.4.*` is now removed because [the version has reached end-of-life](https://docs.getdbt.com/docs/dbt-versions/core).\n\n### Bugfixes\n\n- Previously, calling `get_partition_keys_not_in_subset` on a `BaseTimeWindowPartitionsSubset` that targeted a partitions definition with no partitions (e.g. a future start date) would raise an error. Now, it returns an empty list.\n- Fixed issue which could cause invalid runs to be launched if a code location was updated during the course of an AMP evaluation.\n- Previously, some asset backfills raised an error when targeting multi-assets with internal asset dependencies. This has been fixed.\n- Previously, using the `LocalComputeLogManager` on Windows could result in errors relating to invalid paths. This has been resolved. Thanks **[@hainenber](https://github.com/hainenber)**!\n- An outdated path in the contribution guide has been updated. Thanks **[@hainenber](https://github.com/hainenber)**!\n- [ui] Previously an error was sometimes raised when attempting to create a dynamic partition within a multi-partitioned asset via the UI. This has been fixed.\n- [ui] The “Upstream materializations are missing” warning when launching a run has been expanded to warn about failed upstream materializations as well.\n- [ui] The community welcome modal now renders properly in dark mode and some elements of Asset and Op graphs have higher contrast in both themes.\n- [ui] Fixed dark mode colors for datepicker, error message, and op definition elements.\n- [ui] Pressing the arrow keys to navigate op/asset graphs while the layout is loading no longer causes errors.\n- [ui] Exporting asset and op graphs to SVG no longer fails when chrome extensions inject additional stylesheets into Dagster’s UI.\n- [ui] Dagster now defaults to UTC when the user’s default timezone cannot be identified, rather than crashing with a date formatting error.\n- [ui] Fixed an issue in the asset graph sidebar that caused groups to only list their first asset.\n- [ui] Fixed an issue where sensors runs would undercount the number of dynamic partition requests added or deleted if there were multiple requests for additions/deletions.\n- [docs] Fixed a typo in the “Using Dagster with Delta Lake” guide. Thanks **[@avriiil](https://github.com/avriiil)!**\n- [asset checks] Fixed an issue which could cause errors when using asset checks with step launchers.\n- [dagster-webserver] A bug preventing WebSocket connections from establishing on python 3.11+ has been fixed.\n- [dagster-databricks] `DatabricksJobRunner` now ensures the correct`databricks-sdk` is installed. Thanks **[@zyd14](https://github.com/zyd14)**!\n- [dagster-dbt] On run termination, an interrupt signal is now correctly forwarded to any in-progress dbt subprocesses.\n- [dagster-dbt] Descriptions for dbt tests ingested as asset checks can now be populated using the `config.meta.description`. Thanks **[@CapitanHeMo](https://github.com/CapitanHeMo)**!\n- [dagster-dbt] Previously, the error message displayed when no dbt profiles information was found would display an incorrect path. This has been fixed. Thanks **[@zoltanctoth](https://github.com/zoltanctoth)**!\n- [dagster-k8s] `PipesK8sClient` can now correctly handle `load_incluster_config` . Thanks **[@aignas](https://github.com/aignas)**!\n\n### Documentation\n\n- Added a new category to **Concepts:** [Automation](https://docs.dagster.io/concepts/automation)**.** This page provides a high-level overview of the various ways Dagster allows you run data pipelines without manual intervention.\n- Moved several concept pages under **Concepts > Automation**: Schedules, Sensors, Asset Sensors, and Auto-materialize Policies.\n\n### Dagster Cloud\n\n- Fixed an issue where configuring the `agent_queue` key in a `dagster_cloud.yaml` file incorrectly failed to validate when using the `dagster-cloud ci init` or `dagster-cloud ci check` commands during CI/CD.\n\n# 1.6.2 (core) / 0.22.2 (libraries)\n\n### New\n\n- The warning for unloadable sensors and schedules in the Dagster UI has now been removed.\n- When viewing an individual sensor or schedule, we now provide a button to reset the status of the sensor or schedule back to its default status as defined in code.\n\n### Experimental\n\n- [asset-checks] dbt asset checks now respect `warn_if`/ `error_if` severities\n\n### Dagster Cloud\n\n- Fixed a bug introduced in `1.6.0` where run status sensors did not cursor correctly when deployed on Dagster Cloud.\n- Schedule and sensor mutations are now tracked in the audit log.\n\n# 1.6.1 (core) / 0.22.1 (libraries)\n\n### New\n\n- Added experimental functionality which hides user code errors from the Dagster UI. You may enable this functionality by setting the `DAGSTER_REDACT_USER_CODE_ERRORS` environment variable to `1`.\n- [dagster-dbt] `@dbt_assets` now accepts a `required_resource_keys` argument.\n\n### Bugfixes\n\n- Fixed a bug where a run that targets no steps is launched by an asset backfill when code updates are pushed after backfill launch time.\n- Previously a graphQL error would be thrown on the asset backfill page if certain unpartitioned assets were changed to a partitioned assets. This has been fixed.\n- [ui] Show run log timestamps in the user’s preferred hour cycle (12/24h) format.\n- [ui] The “Export to SVG” option now works as expected in the improved asset graph UI.\n- [ui] On the asset graph, hovering over a collapsed group or the title bar of an expanded group highlights all edges in/out of the group.\n- Fixed occasional CI/CD errors when building documentation on a feature branch\n\n### Community Contributions\n\n- fix: add missing volumes and volumeMounts in job-instance-migrate.yaml. Thanks [@nhuray](https://github.com/nhuray)!\n\n### Documentation\n\n- Fixed typos in the docs.\n\n### Dagster Cloud\n\n- [ui] Fix dark theme colors for billing components.\n- [ui] Show the number of users for each grant type (admin, editor, etc.) on the Users page.\n\n# 1.6.0 (core) / 0.22.0 (libraries)\n\n## Major Changes since 1.5.0 (core) / 0.21.0 (libraries)\n\n### Core\n\n- **Asset lineage graph UI revamp, to make it easier to visualize and navigate large graphs**\n  - Lineage now flows left-to-right instead of top-to-bottom.\n  - You can expand and collapse asset groups in the graph.\n  - A new left-hand sidebar provides a list of assets, organized by asset group and code location.\n  - You can right-click on assets or groups to filter or materialize them.\n  - You can filter by compute kind.\n- **Dark mode for the Dagster UI** – By default, Dagster will match your system’s light or dark theme but you can adjust this in the user settings in the top right of the UI.\n- **Report asset materializations from the UI** – I.e. you record an asset materialization event without executing the code to materialize the asset. This is useful in cases where you overwrote data outside of Dagster, and you want Dagster to know about it and represent it in the UI. It’s also useful when you have a preexisting partitioned asset and start managing it with Dagster: you want Dagster to show the historical partitions as materialized instead of missing.\n- **`MaterializeResult`, `AssetSpec`, and `AssetDep` now marked stable** – These APIs, introduced in Dagster 1.5, were previously marked experimental. They offer a more straightforward way of defining assets when you don’t want to use I/O managers.\n- **Backfill previews** – When launching a backfill that covers assets with different partitions, can you now click “Preview” to see that partitions for each asset that will be covered by the backfill.\n- **Viewing logs for a sensor or schedule tick is no longer considered experimental** – previously, accessing this functionality required turning on a feature flag in user settings.\n- **Runs triggered by a sensor or schedule link to the tick that triggered them.**\n\n### dagster-pipes\n\n- **AWS Lambda Pipes client** –`PipesLambdaClient` [[guide](https://docs.dagster.io/guides/dagster-pipes/aws-lambda)].\n- **Report arbitrary messages between pipes processes and the orchestrating process** – with `report_custom_message` and `get_custom_messages`.\n- **Termination forwarding** – ensures that external processes are terminated when an orchestration process is.\n\n## **Since 1.5.14 (core) / 0.21.14 (libraries)**\n\n### New\n\n- Default op/asset concurrency limits are now configurable at the deployment level, using the `concurrency` > `default_op_concurrency_limit` configuration in your `dagster.yaml` (OSS) or Deployment Settings page (Dagster Cloud). In OSS, this feature first requires a storage migration (e.g. `dagster instance migrate`).\n- Zero-value op/asset concurrency limits are now supported. In OSS, this feature first requires a storage migration (e.g. `dagster instance migrate`).\n- When a `Nothing`-typed output is returned from an `asset` or `op`, the `handle_output` function of the I/O manager will no longer be called. Users of most Dagster-maintained I/O managers will see no behavioral changes, but users of the In-Memory I/O manager, or custom I/O managers that store `Nothing`-typed outputs should reference the migration guide for more information.\n- [ui] The updated asset graph is no longer behind an experimental flag. The new version features a searchable left sidebar, a horizontal DAG layout, context menus and collapsible groups!\n\n### Bugfixes\n\n- Previously, if a code location was re-deployed with modified assets during an iteration of the asset daemon, empty auto-materialize runs could be produced. This has been fixed.\n- The CLI command `dagster asset materialize` will now return a non-zero exit code upon failure.\n- [ui] The Dagster UI now shows resource descriptions as markdown instead of plain text.\n- [ui] Viewing stdout/stderr logs for steps emitting hundreds of thousands of messages is much more performant and does not render the Run page unusable.\n- [ui] Fixed an issue where sensors with intervals that were less than 30 seconds were shown with an interval of “~30s” in the UI. The correct interval is now shown.\n- [dagster-graphql] Fixed an issue where the GraphQL Python client raised an unclear error if the request failed due to a permissions error.\n\n### Breaking Changes\n\n- A slight change has been made to run status sensors cursor values for Dagster instance using the default SQLite storage implementation. If you are using the default SQLite storage and you are upgrading directly from a version of `dagster<1.5.1`, you may see the first tick of your run status sensor skip runs that completed but were not yet registered by the sensor during your upgrade. This should not be common, but to avoid any chance of that, you may consider an interim upgrade to `dagster>=1.5.1,<1.6.0` first.\n\n### Community Contributions\n\n- Fixed a typo in the docs. Thanks [@tomscholz](https://github.com/tomscholz)!\n- [dagster-pyspark] Added additional file exclude rules to the zip files created by Dagster Pyspark step launchers. Thanks [@maxfirman](https://github.com/maxfirman)!\n\n### Documentation\n\n- Added a high-level overview page for [Logging](https://docs.dagster.io/concepts/logging).\n\n### Dagster Cloud\n\n- Added the ability to annotate code locations with custom agent queues, allowing you to route requests for code locations in a single deployment to different agents. For example, you can route requests for one code location to an agent running in an on-premise data center but requests for all other code locations to another agent running in the cloud. For more information, see [the docs](https://docs.dagster.io/dagster-cloud/deployment/agents/running-multiple-agents#routing-requests-to-specific-agents).\n\n# 1.5.14 / 0.21.14 (libraries)\n\n### New\n\n- Viewing logs for a sensor or schedule tick is now a generally available feature.\n  - The feature flag to view sensor or schedule tick logs has been removed, as the feature is now enabled by default.\n  - Logs can now be viewed even when the sensor or schedule tick fails.\n  - The logs are now viewable in the sensor or schedule tick modal.\n- `graph_multi_asset`s can now accept inputs as `kwargs`.\n- [ui] The tick timeline for schedules and sensors now defaults to showing all ticks, instead of excluding skipped ticks. The previous behavior can be enabled by unchecking the “Skipped” checkbox below the timeline view.\n- [ui] The updated asset graph is no longer behind an experimental flag. The new version features a searchable left sidebar, a horizontal DAG layout, context menus and collapsible groups!\n\n### Bugfixes\n\n- [ui] Fix layout and scrolling issues that arise when a global banner alert is displayed in the app.\n- [ui] Use a larger version of the run config dialog in the Runs list in order to maximize the amount of visible config yaml.\n- [ui] When a software-defined asset is removed from a code location, it will now also be removed from global search.\n- [ui] When selecting assets in the catalog, you can now opt to materialize only “changed and missing” items in your selection.\n- [ui] The “Open in Launchpad” option on asset run pages has been updated to link to the graph of assets or asset job instead of an unusable launchpad page.\n- [ui] Partition status dots of multi-dimensional assets no longer wrap on the Asset > Partitions page.\n- [asset checks] Fixed a bug that caused the `resource_defs` parameter of `@asset_check` to not be respected\n- [ui] Fixed an issue where schedules or sensors with the same name in two different code locations sometimes showed each others runs in the list of runs for that schedule or sensor.\n- [pipes] Fixed an issue with the `PipesFileMessageReader` that could cause a crash on Windows.\n- Previously, calling `context.log` in different threads within a single op could result in some of those log messages being dropped. This has been fixed (thanks [@quantum-byte](https://github.com/quantum-byte)!)\n- [dagster-dbt] On Dagster run termination, the dbt subprocess now exits gracefully to terminate any inflight queries that are materializing models.\n\n### Breaking Changes\n\n- The `file_manager` property on `OpExecutionContext` and `AssetExecutionContext` has been removed. This is an ancient property that was deprecated prior to Dagster 1.0, and since then had been raising a `NotImplementedError` whenever invoked.\n\n### Community Contributions\n\n- Added the Hashicorp Nomad integration to the documentation’s list of [community integrations](https://docs.dagster.io/integrations#community-supported-libraries). Thanks, [@ThomAub](https://github.com/ThomAub)!\n- [dagster-deltalake] Fixed an error when passing non-string valued options and extended the supported data types by the arrow type handler to support pyarrow datasets which allows for lazily loading delta tables. Thanks [@roeap](https://github.com/roeap)!\n\n### Experimental\n\n- [dagster-pipes] The subprocess and databricks clients now forward termination to the external process if the orchestration process is terminated. A `forward_termination` argument is available for opting out.\n\n### Documentation\n\n- Fixed an error in the asset checks factory code example.\n\n### Dagster Cloud\n\n- The UI now correctly displays failed partitions after a single-run backfill occurs. Previously, if a single-run backfill failed, the corresponding partitions would not display as failed.\n- Several performance improvements when submitting Snowflake metrics to Dagster Cloud Insights.\n- Fixed an error which would occur when submitting Snowflake metrics for a removed or renamed asset to Dagster Cloud Insights.\n\n# 1.5.13 / 0.21.13 (libraries)\n\n### New\n\n- The `SensorEvaluationContext` object has two new properties: `last_sensor_start_time` and `is_first_tick_since_sensor_start`. This enables sensor evaluation functions to vary behavior on the first tick vs subsequent ticks after the sensor has started.\n- The `asset_selection` argument to `@sensor` and `SensorDefinition` now accepts sequence of `AssetsDefinitions`, a sequences of strings, or a sequence of `AssetKey`s, in addition to `AssetSelection`s.\n- [dagster-dbt] Support for `dbt-core==1.3.*` has been removed.\n- [ui] In code locations view, link to git repo when it’s a valid URL.\n- [ui] To improve consistency and legibility, when displaying elapsed time, most places in the app will now no longer show milliseconds.\n- [ui] Runs that were launched by schedules or sensors now show information about the relevant schedule or sensor in the header, with a link to view other runs associated with the same tick.\n- [dagster-gcp] Added a `show_url_only` parameter to `GCSComputeLogManager` that allows you to configure the compute log manager so that it displays a link to the GCS console rather than loading the logs from GCS, which can be useful if giving Dagster access to GCS credentials is undesirable.\n\n### Bugfixes\n\n- Fixed behavior of loading partitioned parent assets when using the `BranchingIOManager`\n- [ui] Fixed an unwanted scrollbar that sometimes appears on the code location list.\n\n### Community Contributions\n\n- Fixed a bug where dagster would error on FIPS-enabled systems by explicitly marking callsites of `hashlib.md5` as not used for security purposes (Thanks [@jlloyd-widen](https://github.com/jlloyd-widen)!)\n- [dagster-k8s] Changed `execute_k8s_job` to be aware of run-termination and op failure by deleting the executing k8s job (Thanks [@Taadas](https://github.com/Taadas)!).\n- [dagstermill] Fixed dagstermill integration with the Dagster web UI to allow locally-scoped static resources (required to show certain frontend-components like `plotly` graphs) when viewing dagstermill notebooks (Thanks [@aebrahim](https://github.com/aebrahim)!).\n- [dagster-dbt] Fixed type annotation typo in the `DbtCliResource` API docs (Thanks [@akan72](https://github.com/akan72)!)\n\n### Experimental\n\n- [pipes] Methods have been added to facilitate passing non-Dagster data back from the external process (`report_custom_message` ) to the orchestration process (`get_custom_messages`).\n- [ui] Added a “System settings” option for UI theming, which will use your OS preference to set light or dark mode.\n\n### Documentation\n\n- [graphql] - Removed experimental marker that was missed when the GraphQL client was fully released\n- [assets] - Add an example for using retries with assets to the SDA concept page\n- [general] - Fixed some typos and formatting issues\n\n# 1.5.12 / 0.21.12 (libraries)\n\n### Bugfixes\n\n- [dagster-embedded-elt] Fixed an issue where `EnvVar`s used in Sling source and target configuration would not work properly in some circumstances.\n- [dagster-insights] Reworked the Snowflake insights ingestion pipeline to improve performance and increase observability.\n\n# 1.5.11 / 0.21.11 (libraries)\n\n### New\n\n- [ui] Asset graph now displays active filters.\n- [ui] Asset graph can now be filtered by compute kind.\n- [ui] When backfilling failed and missing partitions of assets, a “Preview” button allows you to see which ranges will be materialized.\n- [dagster-dbt] When running `DAGSTER_DBT_PARSE_PROJECT_ON_LOAD=1 dagster dev` in a new scaffolded project from `dagster-dbt project scaffold`, dbt logs from creating dbt artifacts to loading the project are now silenced.\n- [dagster-airbyte] Added a new `connection_meta_to_group_fn` argument which allows configuring loaded asset groups based on the connection’s metadata dict.\n- [dagster-k8s] Debug information about failed run workers in errors surfaced by run monitoring now includes logs from sidecar containers, not just the main dagster container.\n\n### Bugfixes\n\n- The `QueuedRunCoordinatorDaemon` has been refactored to paginate over runs when applying priority sort and tag concurrency limits. Previously, it loaded all runs into memory causing large memory spikes when many runs were enqueued.\n- Callable objects can once again be used to back sensor definitions.\n- `UPathIOManager` has been updated to use the correct path delimiter when interacting with cloud storages from a Windows process.\n- In the default multiprocess executor, the `STEP_WORKER_STARTED` event now fires before importing code in line with the other executors.\n- During execution, skipping a step now takes precedence over “abandoning” it due to upstream failure. This is expected to substantially improve the “retry from failure” workflow when conditional branching is in use.\n- Fixed an issue where default config values set to `EnvVar` did not work properly.\n- Fixed an issue where resources which implemented `IAttachDifferentObjectToOpContext` would pass the incorrect object to schedules and sensors.\n- Fixed a bug that caused auto-materialize failures when using the `materialize_on_cron` rule with dynamically partitioned assets.\n- Fixed an issue where sensor ticks would sporadically fail with a StopIteration exception.\n- [ui] For a job launchpad with a large number of tabs, the “Remove all” option was pushed offscreen. This has been fixed.\n- [ui] The asset backfill page now correctly shows backfills that target only unpartitioned assets.\n- [ui] Launching an asset job that was defined `without_checks` no longer fails by attempting to include the checks.\n- [dagster-databricks] fix bug that caused crash when polling a submitted job that is still in the Databricks queue (due to concurrency limit).\n\n### Community Contributions\n\n- Patched issue where the local compute log path exposed file content outside of the compute log base directory - thanks **[r1b](https://github.com/r1b)!**\n- [dagster-databricks] Added ability to authenticate using an Azure service principal and fix minor bugs involving authenticating with a service principal while `DATABRICKS_HOST` is set. Thanks [@zyd14](https://github.com/zyd14)!\n\n### Experimental\n\n- [ui] Dark mode is now available via the User Settings dialog, currently in an experimental state. By default, the app will use a “legacy” theme, closely matching our current colors. A new light mode theme is also available.\n- [ui] Asset graph group nodes can be collapsed/expanded by right clicking on the collapsed group node or the header of the expanded group node.\n- [ui] Asset graph group nodes can be all collapsed or all expanded by right clicking anywhere on the graph and selecting the appropriate action.\n- [ui] The tree view was removed from the asset graph.\n- [pipes] `PipesLambdaClient`, an AWS Lambda pipes client has been added to `dagster_aws`.\n- Fixed a performance regression introduced in the 1.5.10 release where auto-materializing multi-assets became slower.\n\n### Documentation\n\n- [getting-started] Added an [overview to the Getting Started section](https://docs.dagster.io/getting-started/overview) that explains the whats and whys of Dagster.\n- [pipes] Added [a guide](https://docs.dagster.io/guides/dagster-pipes/aws-lambda) for using the new `PipesLambdaClient` with Dagster Pipes.\n- [getting-started] Simplified the **Getting Started** category. The following pages have been moved:\n  - [Understanding Dagster project files](https://docs.dagster.io/guides/understanding-dagster-project-files) is now in **Guides**\n  - [Telemetry](https://docs.dagster.io/about/telemetry) is now in **About**\n- [guides] Fixed a broken link in the [Airflow-to-Dagster concept mapping guide](https://docs.dagster.io/integrations/airflow).\n- [deployment] Cleaned up and updated the [Executing with Celery OSS deployment guide](https://docs.dagster.io/deployment/guides/celery).\n- [general] Added two guides that were previously missing to the side navigation:\n  - [Utilizing SCIM provisioning](https://docs.dagster.io/dagster-cloud/account/authentication/utilizing-scim-provisioning) (**Deployment > Cloud > Authentication & users > SCIM provisioning**)\n  - [Pandera](https://docs.dagster.io/integrations/pandera) (**Integrations > Pandera**)\n\n### Dagster Cloud\n\n- When a Dagster Cloud agent starts up, it will now wait to display as Running on the Agents tab in the Dagster Cloud UI until it has launched all the code servers that it needs in order to serve requests.\n\n# 1.5.10 / 0.21.10 (libraries)\n\n### New\n\n- Added a new `MetadataValue.job` metadata type, which can be used to link to a Dagster job from other objects in the UI.\n- [asset backfills] Previously, when partitions definitions were changed after backfill launch, the asset backfill page would be blank. Now, when partitions definitions are changed, the backfill page will display statuses by asset.\n- [dagster-bigquery, dagster-duckdb, dagster-snowflake]. The BigQuery, DuckDB, and Snowflake I/O Managers will now determine the schema (dataset for BigQuery) in the following order of precedence: `schema` metadata set on the `asset` or `op`, I/O manager `schema`/ `dataset` configuration, `key_prefix` set on the `asset`. Previously, all methods for setting the schema/dataset were mutually exclusive, and setting more than one would raise an exception.\n- [dagster-shell] Added option to exclude the shell command from logs.\n- [dagster-dbt] When running `DAGSTER_DBT_PARSE_PROJECT_ON_LOAD=1 dagster dev` in a new scaffolded project from `dagster-dbt project scaffold`, dbt artifacts for loading the project are now created in a static `target/` directory.\n\n### Bugfixes\n\n- Problematic inheritance that was causing pydantic warnings to be emitted has been corrected.\n- It's now possible to use the logger of `ScheduleEvaluationContext` when testing via `build_schedule_context`.\n- The `metadata` from a `Failure` exception is now hoisted up to the failure that culminates when retry limits are exceeded.\n- Fixed bug in which the second instance of an hour partition at a DST boundary would never be shown as “materialized” in certain UI views.\n- Fixed an issue where backfilling an hourly partition that occurred during a fall Daylight Savings Time transition sometimes raised an error.\n- [auto-materialize] Fix issue where assets which were skipped because required parent partitions did not exist would not be materialized once those partitions came into existence.\n- [dagster ecs] The exit code of failed containers is now included in the failure message.\n- [dagster pipes] The `PipesK8sClient` now correctly raises on failed containers.\n- [dagster pipes] Using pipes within ops instead of assets no longer enforces problematic constraints.\n- [helm] Added `maxCatchupRuns` and `maxTickRetries` configuration options for the scheduler in the Helm chart.\n- [embedded-elt] Fixed crashes for non-unicode logs.\n- [UI] Fixed an issue where the test sensor dialog for a sensor that targeted multiple jobs would claim that all of the runs were targeting the same job.\n- [UI] Asset keys, job names, and other strings in Dagster UI no longer truncate unnecessarily in Firefox in some scenarios\n- [UI] A larger “View prior events” button on the Asset > Partitions page makes it easier to see the historical materializations of a specific partition of an asset.\n- [asset-checks, dbt] Fixed a bug that that caused asset checks to not execute when a run was not a subset. As part of the fix, the default dbt selection selection string will not be used for dbt runs, even when not in a subset. Instead we pass the explicit set of models and tests to execute, with `DBT_INDIRECT_SELECTION=empty`.\n- [asset-checks] Fixed a bug that caused asset checks defined with `@asset(check_specs=...` to not cooperate with the `key_prefix` argument of the `load_assets_from_modules` method and it’s compatriots.\n- [asset-checks] Fixed a bug that caused errors when launching a job from the UI that excluded asset checks.\n- [asset-checks] Fixed a bug that caused UI errors when a check run was deleted.\n\n### Deprecations\n\n- Marked the experimental Airbyte ingestion-as-code feature as deprecated, to be removed in a future release. We suggest users interested in managing their Airbyte connections in code use the [Airbyte terraform provider](https://reference.airbyte.com/reference/using-the-terraform-provider).\n\n### Community Contributions\n\n- `define_asset_job` now accepts an `op_retry_policy` argument, which specifies a default retry policies for all of the ops in the job. (thanks Eugenio Contreras!)\n- Fix IOManager not being able to load assets with MultiPartitionsDefinition - thanks [@cyberosa](https://github.com/cyberosa)!\n- [dagster-essentials] Three typo fixes in Lesson 8 - thanks Colton [@cmpadden](https://github.com/cmpadden)!\n\n### Experimental\n\n- The `observable_source_asset` decorator now accepts a `key` argument.\n- [dagster pipes] an `implicit_materializations` argument has been added to `get_results` and `get_materialize_result` to control whether an implicit materialization event is created or not.\n- [embedded-elt] Added a new builder and `SlingConnectionResource` to allow reusing sources and targets interoperably.\n- [UI] Updated the experimental concurrency limits configuration page to show per-op runtime info and control.\n- [UI] The Auto-materialize history tab for each asset now only includes rows for evaluations where the result of evaluating the policy has changed. Previously, it would also show a row in the table representing periods of time where nothing changed.\n- [asset-checks, dbt] `build_dbt_asset_selection` now also selects asset checks based on their underlying dbt tests. E.g. `build_dbt_asset_selection([my_dbt_assets], dbt_select=\"tag:data_quality\")` will select the assets and checks for any models and tests tagged with ‘data_quality’.\n\n### Documentation\n\n- Added information about `EnvVar` vs. `os.getenv` to the [Environment variables documentation](https://docs.dagster.io/guides/dagster/using-environment-variables-and-secrets).\n- Updates to the [Asset selection syntax reference](https://docs.dagster.io/concepts/assets/asset-selection-syntax), including expanded examples for Python, the CLI, and the Dagster UI.\n- Added Experimental tags to all Dagster Cloud Insights docs.\n- Updated the [Helm - Migrating a Dagster instance while upgrading guide](https://docs.dagster.io/deployment/guides/kubernetes/how-to-migrate-your-instance) to include a prerequisites section.\n\n### Dagster Cloud\n\n- Branch deployments now use the same timeouts for starting and canceling runs that are set for their parent full deployment, instead of a fixed value of 10 minutes.\n- [k8s agent] Setting labels on a code location will now apply those labels to the kubernetes deployment and service for that code location, rather than just applying them to the pod for that code location.\n\n# 1.5.9 / 0.21.9 (libraries)\n\n### New\n\n- [ui] Enabled collapsing asset groups in the global asset view when the new experimental asset graph is turned on in User Settings\n- [ui] The experimental asset graph sidebar now supports keyboard navigation via arrow keys\n- [ui] You can now right click nodes in the asset graph to materialize them or filter the graph\n- [ui] Jobs can now be searched by run ID\n- [ui] You can now launch runs from the job actions menu\n- [auto-materialize] A new `AutoMaterializeRule.materialize_on_cron()` rule makes it possible to create policies which materialize assets on a regular cadence.\n- [auto-materialize] If a partition-mapping-related error occurs within the Asset Daemon, a more informative error message will be provided.\n- [dagster-databricks] Extended the set of available config options to the Databricks step launcher - thanks [@zyd14](https://github.com/zyd14)!\n\n### Bugfixes\n\n- Fixed an issue where some schedules incorrectly skipped ticks during Daylight Savings Times transitions.\n- Returning a `SensorResult` from a sensor no longer overwrites a cursor if it was set via the context.\n- Fixed issue which could cause incorrect execution order when executing multi-assets with `can_subset=True` alongside assets which were upstream of some assets in the multi-asset, and downstream of others.\n- Previously, when creating an `HourlyPartitionsDefinition` with a non-UTC timezone and the default format string (or any format string not including a UTC-offset), there was no way to disambiguate between the first and second instance of the repeated hour during a daylight saving time transition. Now, for the one hour per year in which this ambiguity exists, the partition key of the second instance of the hour will have the UTC offset automatically appended to it.\n- [asset checks] Fixed a bug that caused an error when passing `check_specs` to `AssetsDefinition.from_graph`\n- [dagster-dbt] Fixed a bug in `dagster-dbt` that caused some dbt tests to not be selected as asset checks.\n- [dagster-dbt] Fixed an issue where multiple copies of the dbt manifest were held in memory when loading a dbt project as software-defined assets.\n- The `email_on_failure` sensor called deprecated methods on the context. This has been fixed\n\n### Community Contributions\n\n- [dagster-deltalake] Added Delta Lake support along with support for pandas and polars. Thanks Robert Pack [@roeap](https://github.com/roeap)!\n- [dagster-graphql] Fixed the asset cursor format to use a normalized format - thanks [@sisidra](https://github.com/sisidra)!\n- [dagster-databricks] Extended the set of available config options to the Databricks step launcher - thanks [@zyd14](https://github.com/zyd14)!\n\n### Experimental\n\n- `DagsterInstance.report_runless_asset_event` is now public.\n- `AutoMaterializeRule.materialize_on_parent_updated` now accepts an `updated_parents_filter` of type `AutoMaterializeAssetPartitionsFilter`, which allows only materializing based on updates from runs with a required set of tags.\n\n### Documentation\n\n- Added a new guide for using [Dagster Pipes with Kubernetes](https://docs.dagster.io/guides/dagster-pipes)\n- Added all [OSS deployment guides](https://docs.dagster.io/deployment/guides) to the site’s side navigation (**Deployment > Open Source > Guides**)\n- Updated formatting in the [Migrating your Dagster instance while upgrading Helm guide](https://docs.dagster.io/deployment/guides/kubernetes/how-to-migrate-your-instance)\n- Added **Experimental** tags to [Dagster Cloud Insights docs](https://docs.dagster.io/dagster-cloud/insights)\n- The [Transitioning Data Pipelines from Development to Production](https://docs.dagster.io/guides/dagster/transitioning-data-pipelines-from-development-to-production) and [Testing against production with Dagster Cloud Branch Deployments](https://docs.dagster.io/guides/dagster/branch_deployments) guides have been updated to use Pythonic Resources\n\n### Dagster Cloud\n\n- Reporting runless events and manually marking an asset as successfully materialized are no possible with “Launcher” level permissions\n- [ui] Improved search and render performance of Users page, especially for large lists of users.\n- [billing] Fixed issues with correctly displaying your tax ID\n\n# 1.5.8 / 0.21.8 (libraries)\n\n### Bugfixes\n\n- Fixed an error when trying to directly invoke a run status sensor when passing resources.\n- [dagster-airbyte][dagster-fivetran] Fixed an issue where `EnvVars` used in Airbyte or Fivetran resources would show up as their processed values in the launchpad when loading assets from a live Fivetran or Airbyte instance.\n\n### Dagster Cloud\n\n- Substantially improved performance of the Dagster insights DBT/Snowflake usage job.\n\n# 1.5.7 / 0.21.7 (libraries)\n\n### New\n\n- The `OpExecutionContext` and `AssetExecutionContext` now have a `partition_keys` property\n- [dagster-ui] The asset graph layout algorithm has been changed to a much faster one called “tight-tree”\n- [dagster-ui] The Runs table filters has a top level filter for partitions\n- [dagster-dbt] `dbt-core==1.7.*` is now supported.\n\n### Bugfixes\n\n- Fixed an issue where some schedules skipped a tick on the day after a fall Daylight Savings Time transition.\n- Fixed a bug that caused backfill policies that execute multiple partitions in a single run not to work with dynamic partitions.\n- Fixed a bug that caused an error when `build_schedule_from_partitioned_job` was used with a job with multi-partitioned assets and the `partitions_def` argument wasn’t provided to `define_asset_job`.\n- We now raise an error early if the empty string is provided as an asset’s group name (Thanks Sierrra!)\n- Fixed an issue where custom setup and teardown methods were not properly called on nested Pythonic resources.\n- Added a warning message when op or asset config is passed as an argument not named `config`.\n- [dagster-cloud] Fixed an issue where overriding the default I/O manager could break the Snowflake-dbt insights job.\n- [auto-materialize] Fixed an issue where materializing an unpartitioned parent of a dynamic-partitioned asset would only result in the latest dynamic partition of that asset being requested. Now, all partitions will be requested.\n- [dagster-embedded-elt] Fixed an issue in `dagster-embedded-elt` where sling’s `updated_at` parameter was set to the incorrect type\n- [dagster-ui] Fixed an issue in the launchpad where selecting a partition wouldn’t correctly overwrite fields using the partition’s specific configuration\n\n### Community Contributions\n\n- A docs fix to the testing concepts page, thanks @NicolaiLolansen!\n- The schema can now be overridden per asset in DB IO managers, thanks @jrstats!\n\n### Experimental\n\n- Improved failure recovery and retry behavior when the daemon that launches auto-materialization runs fails or crashes in the middle of a tick.\n- [asset-checks] UI performance for displaying check results is improved\n- [asset-checks] Removed noisy experimental warning about `AssetCheckKey`\n- [op-concurrency] Fixed a bug where concurrency slots were not getting assigned if a run that was assigned a slot was deleted before the slot had actually been claimed during execution.\n- [dagster-pipes] The `PipesSubprocessClient` now inherits the environment variables of the parent process in the launched subprocess.\n- [dagster-pipes] Exceptions are now reported in the event log for framework components and from the external process.\n\n### Documentation\n\n- Added a guide for using [Dagster Pipes with Databricks](https://docs.dagster.io/guides/dagster-pipes/databricks)\n\n# 1.5.6 / 0.21.6 (libraries)\n\n### New\n\n- [dagster-k8s] The `PipesK8sClient` will now attempt to load the appropriate kubernetes config, and exposes arguments for controlling this process.\n- [ui] The launch asset backfill modal now offers a preview dialog showing the targeted asset partitions and their backfill policies when partition mapping or varying backfill policies are present.\n- [asset-checks] New `load_asset_checks_from_modules` functions for loading asset checks in tandem with `load_assets_from_modules`.\n- Previously, the daemon process would terminate with an error if it believed that a thread might be hanging, which sometimes caused undesirable terminations when doing large backfills or auto-materializing many assets. Now, the daemon process will emit a warning instead of terminate.\n- [dagster-dbt] `dagster-dbt project scaffold` now uses `~/.dbt/profiles.yml` if a `profiles.yml` is not present in the dbt project directory.\n- [dagster-dbt] `@dbt_assets` now support `PartitionMapping` using `DagsterDbtTranslator.get_partition_mapping`.\n- [dagster-dbt] Self dependencies can now be enabled for dbt models that are represented by `@dbt_assets`. To enable this, add the following metadata to your dbt model’s metadata in your dbt project:\n\n```\nmeta:\n  dagster:\n    has_self_dependency: True\n```\n\n### Bugfixes\n\n- Fixed an issue where Dagster imports would throw errors when using `pydantic<2.0.0` but having `pydantic-core` installed.\n- Previously, asset backfills that targeted partitioned assets with a `LastPartitionMapping` dependency would raise an error. This has been fixed.\n- Fixed a multipartitions partition mapping bug where a `instance is not available to load partitions` error was raised.\n- [asset-checks] Fixed an issue with conflicting op names when using `build_asset_with_blocking_check`\n- [ui] Viewing run logs containing very large messages no longer causes the UI to crash in Safari on macOS\n- [ui] Drilling into the graph of a graph-backed asset with 4+ inputs or outputs no longer causes the asset graph to crash with a rendering error.\n- [ui] On the backfill details page, clicking to a specific asset correctly shows the partitions that were materialized for that asset when partition mapping is in use.\n- [ui] The Asset > Partition page now loads partition details more quickly in cases where calculating the staleness of the partition took a significant amount of time.\n- Fixed a bug introduced in `1.5.0` where instances that haven’t been migrated to the latest schema hit an error upon run deletion.\n- [auto-materialize] Previously, if an asset partition was skipped on a tick for one reason, and then processed and skipped on a later tick for an additional reason, only the most recent skip reason would be tracked. Now, all skip reasons are tracked.\n- [dagster-dbt] Fixed an issue where if an `exclude` that didn’t match any dbt nodes was used in `@dbt_assets`, an error would be raised. The error is now properly handled.\n- [dagster-dbt] When invoking `DbtCliResource.cli(...)` in an `op`, `AssetMaterialization`'s instead of `Output` are now emitted.\n\n### Experimental\n\n- Global op concurrency slots are now released in between retries of op execution failures.\n\n### Documentation\n\n- Updated the tutorial to reflect best practices and APIs as of Dagster 1.5\n\n### Dagster Cloud\n\n- The `report_asset_observation` REST endpoint for reporting runless events is now available.\n\n# 1.5.5 / 0.21.5 (libraries)\n\n### New\n\n- Dagster now supports using Pydantic 2 models for Config and Resources. Pydantic 1.10 continues to be supported.\n- Added a `report_asset_observation` REST API endpoint for runless external asset observation events\n- Dramatically improved the performance of partition-mapping, for basic hourly and daily partitions definitions\n- [ui] When viewing a list of runs, you can quickly add the tag in the “Launched by” column as a filter on the list view. Hover over the tag to see the “Add to filter” button.\n- [helm] The env vars `DAGSTER_K8S_PG_PASSWORD_SECRET` and `DAGSTER_K8S_INSTANCE_CONFIG_MAP` will no longer be set in all pods.\n- [dagster-pyspark] `build_pyspark_zip` now takes an `exclude` parameter that can be used to customize the set of excluded files.\n- [ui] Links beginning with http://, https:// in unstructured run logs (via context.log) are automatically converted to clickable links\n\n### Bugfixes\n\n- Fixed an asset backfill bug where certain asset partitions with no targeted parents would hang indefinitely.\n- Fixed a bug where the `source_key_prefix` argument to `load_assets_from_current_module` and `load_assets_from_package_name` was ignored\n- Fixed two bugs in `dagster_embedded_elt` where the mode parameter was not being passed to Sling, and only one asset could be created at a time\n- Fixed a bug with handing default values for Pydantic validators on Windows\n- [ui] Clicking an asset with checks shows them in the asset graph sidebar, even if live data on the page is still loading.\n- [ui] Reported materialization events are presented more clearly in the asset graph sidebar and in other parts of the Dagster UI.\n\n### Deprecations\n\n- [helm] The `pipelineRun` configuration in the Helm chart is now deprecated. The same config can be set under `dagster-user-deployments`\n\n### Community Contributions\n\n- Added `setup_for_execution` and `teardown_after_execution` calls to the inner IOManagers of the `BranchingIOManager` - thank you @danielgafni!\n- The `S3FakeResource.upload_fileobj()` signature is now consistent with `boto3 S3.Client.upload_fileobj()` - thank you @jeanineharb!\n- `dbt_assets` now have an optional name parameter - thank you @AlexanderVR!\n\n### Documentation\n\n- Added a link to Dagster University to the [docs landing page](https://docs.dagster.io) 🎓\n- Improved readability of [API docs landing page](https://docs.dagster.io/_apidocs)\n- Removed straggling mention of Dagit from the [Kubernetes OSS deployment guide](https://docs.dagster.io/deployment/guides/kubernetes/deploying-with-helm)\n\n# 1.5.4 / 0.21.4 (libraries)\n\n### New\n\n- Added a `report_asset_check` REST API endpoint for runless external asset check evaluation events. This is available in cloud as well.\n- The `config` argument is now supported on `@graph_multi_asset`\n- [ui] Improved performance for global search UI, especially for deployments with very large numbers of jobs or assets.\n- [dagster-pipes] Add S3 context injector/reader.\n- [dagster-dbt] When an exception when running a dbt command, error messages from the underlying dbt invocation are now properly surfaced to the Dagster exception.\n- [dagster-dbt] The path to the dbt executable is now configurable in `DbtCliResource`.\n\n### Bugfixes\n\n- Fixed a bug introduced in 1.5.3 that caused errors when launching specific Ops in a Job.\n- Fixed a bug introduced in 1.5.0 that prevented the `AssetExecutionContext` type annotation for the `context` parameter in `@asset_check` functions.\n- Fixed an issue where the Dagster scheduler would sometimes fail to retry a tick if there was an error reloading a code location in the middle of the tick.\n- [dagster-dbt] Fixed an issue where explicitly passing in `profiles_dir=None` into `DbtCliResource` would cause incorrect validation.\n- [dagster-dbt] Fixed an issue where partial parsing was not working when reusing existing target paths in subsequent dbt invocations.\n- [ui] Fixed an issue where the job partitions UI would show “0 total partitions” if the job consisted of more than 100 assets\n\n### Community Contributions\n\n- [dagster-duckdb] The `DuckDBResource` and `DuckDBIOManager` accept a `connection_config` configuration that will be passed as `config` to the DuckDB connection. Thanks @xjhc!\n\n### Experimental\n\n- Added events in the run log when a step is blocked by a global op concurrency limit.\n- Added a backoff for steps querying for open concurrency slots.\n- Auto-materialize logic to skip materializing when (1) a backfill is in progress or (2) parent partitions are required but nonexistent are now refactored to be skip rules.\n- [ui] Added 2 new asset graph layout algorithms under user settings that are significantly faster for large graphs (1000+ assets).\n\n### Documentation\n\n- Added several pieces of documentation for Dagster Pipes, including:\n  - [A high-level explanation of Pipes](https://docs.dagster.io/guides/dagster-pipes)\n  - [A tutorial](https://docs.dagster.io/guides/dagster-pipes/subprocess) that demonstrates how to use Pipes with a local subprocess\n  - [A reference](https://docs.dagster.io/guides/dagster-pipes/subprocess/reference) for using a local subprocess with Pipes\n  - [A detailed explanation of Pipes](https://docs.dagster.io/guides/dagster-pipes/dagster-pipes-details-and-customization), including how to customize the process\n  - API references for [Pipes](https://docs.dagster.io/_apidocs/pipes) (orchestration-side) and [dagster-pipes](https://docs.dagster.io/_apidocs/libraries/dagster-pipes) (external process)\n- Added documentation for the new [experimental External Assets](https://docs.dagster.io/concepts/assets/external-assets) feature\n\n### Dagster Cloud\n\n- Running multiple agents is no longer considered experimental.\n- When the agent spins up a new code server while updating a code location, it will now wait until the new code location uploads any changes to Dagster Cloud before allowing the new server to serve requests.\n\n# 1.5.3 / 0.21.3 (libraries)\n\n### New\n\n- Alert policies can now be set on assets + asset checks (currently experimental). Check out the alerting [docs](https://docs.dagster.io/dagster-cloud/managing-deployments/setting-up-alerts#setting-up-alerts-in-dagster-cloud) for more information.\n- Added a new flag `--live-data-poll-rate` that allows configuring how often the UI polls for new asset data when viewing the asset graph, asset catalog, or overview assets page. It defaults to 2000 ms.\n- Added back the ability to materialize changed and missing assets from the global asset-graph. A dialog will open allowing you to preview and select which assets to materialize.\n- Added an experimental AMP Timeline page to give more visibility into the automaterialization daemon. You can enable it under user settings\n- Added a `report_asset_materialization` REST API endpoint for creating external asset materialization events. This is available in cloud as well.\n- [dbt] The `@dbt_assets` decorator now accepts a `backfill_policy` argument, for controlling how the assets are backfilled.\n- [dbt] The `@dbt_assets` decorator now accepts a `op_tags` argument, for passing tags to the op underlying the produced `AssetsDefinition`.\n- [pipes] Added `get_materialize_result` & `get_asset_check_result` to `PipesClientCompletedInvocation`\n- [dagster-datahub] The `acryl-datahub` pin in the `dagster-datahub` package has been removed.\n- [dagster-databricks] The `PipesDatabricksClient` now performs stdout/stderr forwarding from the Databricks master node to Dagster.\n- [dagster-dbt] The hostname of the dbt API can now be configured when executing the `dagster-dbt-cloud` CLI.\n- [dagster-k8s] Added the ability to customize how raw k8s config tags set on an individual Dagster job are merged with raw k8s config set on the `K8sRunLauncher`. See [the docs](https://docs.dagster.io/deployment/guides/kubernetes/customizing-your-deployment#precedence-rules) for more information.\n\n### Bugfixes\n\n- Previously, the asset backfill page would display negative counts if failed partitions were manually re-executed. This has been fixed.\n- Fixed an issue where the run list dialog for viewing the runs occupying global op concurrency slots did not expand to fit the content size.\n- Fixed an issue where selecting a partition would clear the launchpad and typing in the launchpad would clear the partition selection\n- Fixed various issues with the asset-graph displaying the wrong graph\n- The IO manager’s `handle_output` method is no longer invoked when observing an observable source asset.\n\n- [ui] Fixed an issue where the run config dialog could not be scrolled.\n- [pipes] Fixed an issue in the `PipesDockerClient` with parsing logs fetched via the docker client.\n- [external assets] Fixed an issue in `external_assets_from_specs` where providing multiple specs would error\n- [external assets] Correct copy in tooltip to explain why Materialize button is disabled on an external asset.\n\n### Breaking Changes\n\n- [pipes] A change has been made to the environment variables used to detect if the external process has been launched with pipes. Update the `dagster-pipes` version used in the external process.\n- [pipes] The top level function `is_dagster_pipes_process` has been removed from the `dagster-pipes` package.\n\n### Community Contributions\n\n- Override a method in the azure data lake IO manager (thanks @[0xfabioo](https://github.com/0xfabioo))!\n- Add support of external launch types in ECS run launcher (thanks @[cuttius](https://github.com/cuttius))!\n\n### Experimental\n\n- The Python GraphQL client is considered stable and is no longer marked as experimental.\n\n# 1.5.2 / 0.21.2 (libraries)\n\n### Bugfixes\n\n- Previously, asset backfills targeting assets with multi-run backfill policies would raise a \"did not submit all run requests\" error. This has been fixed.\n\n### Dagster Cloud\n\n- The experimental dagster-insights package has receieved some API surface area updates and bugfixes.\n\n# 1.5.1 / 0.21.1 (libraries)\n\n### New\n\n- Dagster now automatically infers a dependency relationship between a time-partitioned asset and a multi-partitioned asset with a time dimension. Previously, this was only inferred when the time dimension was the same in each asset.\n- The `EnvVar` utility will now raise an exception if it is used outside of the context of a Dagster resource or config class. The `get_value()` utility will retrieve the value outside of this context.\n- [ui] The runs page now displays a “terminate all” button at the top, to bulk terminate in-progress runs.\n- [ui] Asset Graph - Various performance improvements that make navigating large asset graphs smooth\n- [ui] Asset Graph - The graph now only fetches data for assets within the viewport solving timeout issues with large asset graphs\n- [ui] Asset Graph Sidebar - The sidebar now shows asset status\n- [dagster-dbt] When executing dbt invocations using `DbtCliResource`, an explicit `target_path` can now be specified.\n- [dagster-dbt] Asset checks can now be enabled by using `DagsterDbtTranslator` and `DagsterDbtTranslatorSettings`: see [the docs](https://docs.dagster.io/integrations/dbt/reference) for more information.\n- [dagster-embedded-elt] Dagster library for embedded ELT\n\n### Bugfixes\n\n- [ui] Fixed various issues on the asset details page where partition names would overflow outside their containers\n- [ui] Backfill notification - Fixed an issue where the backfill link didn’t take the —path-prefix option into account\n- [ui] Fixed an issue where the instance configuration yaml would persist rendering even after navigating away from the page.\n- [ui] Fixed issues where config yaml displays could not be scrolled.\n- [dagster-webserver] Fixed a performance issue that caused the UI to load slowly\n\n### Deprecations\n\n- [dagster-dbt] Enabling asset checks using dbt project metadata has been deprecated.\n\n# 1.5.0 (core) / 0.21.0 (libraries) \"How Will I Know\"\n\n## **Major Changes since 1.4.0 (core) / 0.20.0 (libraries)**\n\n### Core\n\n- **Improved ergonomics for execution dependencies in assets**  - We introduced a set of APIs to simplify working with Dagster that don't use the I/O manager system for handling data between assets. I/O manager workflows will not be affected.\n  - `AssetDep` type allows you to specify upstream dependencies with partition mappings when using the `deps` parameter of `@asset` and `AssetSpec`.\n  - `MaterializeResult` can be optionally returned from an asset to report metadata about the asset when the asset handles any storage requirements within the function body and does not use an I/O manager.\n  - `AssetSpec` has been added as a new way to declare the assets produced by `@multi_asset`. When using `AssetSpec`, the multi_asset does not need to return any values to be stored by the I/O manager. Instead, the multi_asset should handle any storage requirements in the body of the function.\n- **Asset checks (experimental)** - You can now define, execute, and monitor data quality checks in Dagster [[docs](https://docs.dagster.io/concepts/assets/asset-checks)].\n\n  - The `@asset_check` decorator, as well as the `check_specs` argument to `@asset` and `@multi_asset` enable defining asset checks.\n  - Materializing assets from the UI will default to executing their asset checks. You can also execute individual checks.\n  - When viewing an asset in the asset graph or the asset details page, you can see whether its checks have passed, failed, or haven’t run successfully.\n\n- **Auto materialize customization (experimental)** - `AutoMaterializePolicies` can now be customized [[docs](https://docs.dagster.io/concepts/assets/asset-auto-execution#auto-materialize-policies)].\n  - All policies are composed of a set of `AutoMaterializeRule`s which determine if an asset should be materialized or skipped.\n  - To modify the default behavior, rules can be added to or removed from a policy to change the conditions under which assets will be materialized.\n\n### dagster-pipes\n\n- Dagster pipes is a new library that implements a protocol for launching compute into external execution environments and consuming streaming logs and Dagster metadata from those environments. See https://github.com/dagster-io/dagster/discussions/16319 for more details on the motivation and vision behind Pipes.\n- Out-the-box integrations\n  - Clients: local subprocess, Docker containers, Kubernetes, and Databricks\n    - `PipesSubprocessClient`, `PipesDocketClient`, `PipesK8sClient`, `PipesDatabricksClient`\n  - Transport: Unix pipes, Filesystem, s3, dbfs\n  - Languages: Python\n- Dagster pipes is composable with existing launching infrastructure via `open_pipes_session`. One can augment existing invocations rather than replacing them wholesale.\n\n## **Since 1.4.17 (core) / 0.20.17 (libraries)**\n\n### New\n\n- [ui] Global Asset Graph performance improvement - the first time you load the graph it will be cached to disk and any subsequent load of the graph should load instantly.\n\n### Bugfixes\n\n- Fixed a bug where deleted runs could retain instance-wide op concurrency slots.\n\n### Breaking Changes\n\n- `AssetExecutionContext` is now a subclass of `OpExecutionContext`, not a type alias. The code\n\n```python\ndef my_helper_function(context: AssetExecutionContext):\n    ...\n\n@op\ndef my_op(context: OpExecutionContext):\n    my_helper_function(context)\n```\n\nwill cause type checking errors. To migrate, update type hints to respect the new subclassing.\n\n- `AssetExecutionContext` cannot be used as the type annotation for `@op`s run in `@jobs`. To migrate, update the type hint in `@op` to `OpExecutionContext`. `@op`s that are used in `@graph_assets` may still use the `AssetExecutionContext` type hint.\n\n```python\n# old\n@op\ndef my_op(context: AssetExecutionContext):\n    ...\n\n# correct\n@op\ndef my_op(context: OpExecutionContext):\n    ...\n```\n\n- [ui] We have removed the option to launch an asset backfill as a single run. To achieve this behavior, add `backfill_policy=BackfillPolicy.single_run()` to your assets.\n\n### Community Contributions\n\n- `has_dynamic_partition` implementation has been optimized. Thanks @edvardlindelof!\n- [dagster-airbyte] Added an optional `stream_to_asset_map` argument to `build_airbyte_assets` to support the Airbyte prefix setting with special characters. Thanks @chollinger93!\n- [dagster-k8s] Moved “labels” to a lower precedence. Thanks @jrouly!\n- [dagster-k8s] Improved handling of failed jobs. Thanks @Milias!\n- [dagster-databricks] Fixed an issue where `DatabricksPysparkStepLauncher` fails to get logs when `job_run` doesn’t have `cluster_id` at root level. Thanks @PadenZach!\n- Docs type fix from @sethusabarish, thank you!\n\n### Documentation\n\n- Our Partitions documentation has gotten a facelift! We’ve split the original page into several smaller pages, as follows:\n  - [Partitions](https://docs.dagster.io/concepts/partitions-schedules-sensors/partitions) - An overview of what a partition is, benefits, and how to use it\n  - [Partitioning assets](https://docs.dagster.io/concepts/partitions-schedules-sensors/partitioning-assets) - Details about partitioning assets\n  - [Partitioning ops](https://docs.dagster.io/concepts/partitions-schedules-sensors/partitioning-ops) - Details about partitioning ops\n  - [Testing partitions](https://docs.dagster.io/concepts/partitions-schedules-sensors/testing-partitions) - As described\n\n### Dagster Cloud\n\n- **New dagster-insights sub-module** - We have released an experimental `dagster_cloud.dagster_insights` module that contains utilities for capturing and submitting external metrics about data operations to Dagster Cloud via an api. Dagster Cloud Insights is a soon-to-be released feature that shows improves visibility into usage and cost metrics such as run duration and Snowflake credits in the Cloud UI.\n\n# 1.4.17 / 0.20.17 (libraries)\n\n### New\n\n- [dagster-dbt] `DbtCliResource` now enforces that the current installed version of `dbt-core` is at least version `1.4.0`.\n- [dagster-dbt] `DbtCliResource` now properly respects `DBT_TARGET_PATH` if it is set by the user. Artifacts from dbt invocations using `DbtCliResource` will now be placed in unique subdirectories of `DBT_TARGET_PATH`.\n\n### Bugfixes\n\n- When executing a backfill that targets a range of time partitions in a single run, the `partition_time_window` attribute on `OpExecutionContext` and `AssetExecutionContext` now returns the time range, instead of raising an error.\n- Fixed an issue where the asset backfill page raised a GraphQL error for backfills that targeted different partitions per-asset.\n- Fixed `job_name` property on the result object of `build_hook_context`.\n\n### Experimental\n\n- `AssetSpec` has been added as a new way to declare the assets produced by `@multi_asset`.\n- `AssetDep` type allows you to specify upstream dependencies with partition mappings when using the `deps` parameter of `@asset` and `AssetSpec`.\n- [dagster-ext] `report_asset_check` method added to `ExtContext`.\n- [dagster-ext] ext clients now must use `yield from` to forward reported materializations and asset check results to Dagster. Results reported from ext that are not yielded will raise an error.\n\n### Documentation\n\n- The [Dagster UI](https://docs.dagster.io/concepts/webserver/ui) documentation got an overhaul! We’ve updated all our screenshots and added a number of previously undocumented pages/features, including:\n  - The Overview page, aka the Factory Floor\n  - Job run compute logs\n  - Global asset lineage\n  - Overview > Resources\n- The [Resources](https://docs.dagster.io/concepts/resources) documentation has been updated to include additional context about using resources, as well as when to use `os.getenv()` versus Dagster’s `EnvVar`.\n- Information about custom loggers has been moved from the Loggers documentation to its own page, [Custom loggers](https://docs.dagster.io/concepts/logging/custom-loggers).\n\n# 1.4.16 / 0.20.16 (libraries)\n\n### New\n\n- [ui] When using the search input within Overview pages, if the viewer’s code locations have not yet fully loaded into the app, a loading spinner will now appear to indicate that search results are pending.\n\n### Bugfixes\n\n- Fixed an asset backfill bug that caused occasionally caused duplicate runs to be kicked off in response to manual runs upstream.\n- Fixed an issue where launching a run from the Launchpad that included many assets would sometimes raise an exception when trying to create the tags for the run.\n- [ui] Fixed a bug where clicking to view a job from a run could lead to an empty page in situations where the viewer’s code locations had not yet loaded in the app.\n\n### Deprecations\n\n- Deprecated `ExpectationResult`. This will be made irrelevant by upcoming data quality features.\n\n### Community Contributions\n\n- Enabled chunked backfill runs to target more than one asset, thanks @ruizh22!\n\n### Experimental\n\n- Users can now emit arbitrary asset materializations, observations, and asset check evaluations from sensors via `SensorResult`.\n\n# 1.4.15 / 0.20.15 (libraries)\n\n### New\n\n- The `deps` parameter for `@asset` and `@multi_asset` now supports directly passing `@multi_asset` definitions. If an `@multi_asset` is passed to `deps`, dependencies will be created on every asset produced by the `@multi_asset`.\n- Added an optional data migration to convert storage ids to use 64-bit integers instead of 32-bit integers. This will incur some downtime, but may be required for instances that are handling a large number of events. This migration can be invoked using `dagster instance migrate --bigint-migration`.\n- [ui] Dagster now allows you to run asset checks individually.\n- [ui] The run list and run details page now show the asset checks targeted by each run.\n- [ui] In the runs list, runs launched by schedules or sensors will now have tags that link directly to those schedules or sensors.\n- [ui] Clicking the \"N assets\" tag on a run allows you to navigate to the filtered asset graph as well as view the full list of asset keys.\n- [ui] Schedules, sensors, and observable source assets now appear on the resource “Uses” page.\n- [dagster-dbt] The `DbtCliResource` now validates at definition time that its `project_dir` and `profiles_dir` arguments are directories that respectively contain a `dbt_project.yml` and `profiles.yml`.\n- [dagster-databricks] You can now configure a `policy_id` for new clusters when using the `databricks_pyspark_step_launcher` (thanks @zyd14!)\n- [ui] Added an experimental sidebar to the Asset lineage graph to aid in navigating large graphs. You can enable this feature under user settings.\n\n### Bugfixes\n\n- Fixed an issue where the `dagster-webserver` command was not indicating which port it was using in the command-line output.\n- Fixed an issue with the quickstart_gcp example wasn’t setting GCP credentials properly when setting up its IOManager.\n- Fixed an issue where the process output for Dagster run and step containers would repeat each log message twice in JSON format when the process finished.\n- [ui] Fixed an issue where the config editor failed to load when materializing certain assets.\n- [auto-materialize] Previously, rematerializing an old partition of an asset which depended on a prior partition of itself would result in a chain of materializations to propagate that change all the way through to the most recent partition of this asset. To prevent these “slow-motion backfills”, this behavior has been updated such that these updates are no longer propagated.\n\n### Experimental\n\n- `MaterializeResult` has been added as a new return type to be used in `@asset` / `@multi_asset` materialization functions\n- [ui] The auto-materialize page now properly indicates that the feature is experimental and links to our documentation.\n\n### Documentation\n\n- The Concepts category page got a small facelift, to bring it line with how the side navigation is organized.\n\n### Dagster Cloud\n\n- Previously, when importing a dbt project in Cloud, naming the code location “dagster” would cause build failures. This is now disabled and an error is now surfaced.\n\n# 1.4.14 / 0.20.14 (libraries)\n\n### New\n\n- Added a new tooltip to asset runs to either view the asset list or lineage\n\n### Bugfixes\n\n- [ui] Fixed an issue where re-executing a run from a particular run's page wouldn’t navigate to the newly created run\n\n### Experimental\n\n- [dagster-ext] An initial version of the `dagster-ext` module along with subprocess, docker, databricks, and k8s pod integrations are now available. Read more at https://github.com/dagster-io/dagster/discussions/16319. Note that the module is temporarily being published to PyPI under `dagster-ext-process`, but is available in python as `import dagster_ext`.\n- [asset checks] Added an ‘execute’ button to run checks without materializing the asset. Currently this is only supported for checks defined with `@asset_check` or `AssetChecksDefinition`.\n- [asset checks] Added `check_specs` argument to `@graph_multi_asset`\n- [asset checks] Fixed a bug with checks on `@graph_asset` that would raise an error about nonexistant checks\n\n# 1.4.13 / 0.20.13 (libraries)\n\n### New\n\n- `OpExecutionContext.add_output_metadata` can now be called multiple times per output.\n\n### Bugfixes\n\n- The double evaluation of log messages in sensor logging has been fixed (thanks `@janosroden` !)\n- Cron schedules targeting leap day (ending with `29 2 *`) no longer cause exceptions in the UI or daemon.\n- Previously, if multiple partitioned `observable_source_asset`s with different partition definitions existed in the same code location, runs targeting those assets could fail to launch. This has been fixed.\n- When using AutoMaterializePolicies with assets that depended on prior partitions of themselves, updating the `start_date` of their underlying `PartitionsDefinition` could result in runs being launched for partitions that no longer existed. This has been fixed.\n- Fixed an issue where auto-materilization could sometimes produce duplicate runs if there was an error in the middle of an auto-materialization tick.\n- [dagster-census] A recent change to the Census API broke compatibility with\n  this integration. This has been fixed (thanks `@ldnicolasmay`!)\n- [dagster-dbt] Fixed an issue where `DagsterDbtTranslator` did not properly invoke `get_auto_materialize_policy` and `get_freshness_policy` for `load_assets_from_dbt_project`.\n- [ui] Fixed a number of interaction bugs with the Launchpad config editor, including issues with newlines and multiple cursors.\n- [ui] Asset keys and partitions presented in the asset checks UI are sorted to avoid flickering.\n- [ui] Backfill actions (terminate backfill runs, cancel backfill submission) are now available from an actions menu on the asset backfill details page.\n\n### Community Contributions\n\n- Typo fix in run monitoring docs (thanks [c0dk](https://github.com/c0dk))!\n- Grammar fixes in testing docs (thanks [sonnyarora](https://github.com/sonnyarora))!\n- Typo fix in contribution docs (thanks [tab1tha](https://github.com/tab1tha))!\n\n### Experimental\n\n- [dagster-dbt][asset checks] Added support to model dbt tests as Dagster asset checks.\n- [asset checks] Added `@graph_asset` support. This can be used to implement blocking checks, by raising an exception if the check fails.\n- [asset checks] Fixed `@multi_asset` subsetting, so only checks which target assets in the subset will execute.\n- [asset checks] `AssetCheckSpec`s will now cause an error at definition time if they target an asset other than the one they’re defined on.\n- [asset checks] The status of asset checks now appears in the asset graph and asset graph sidebar.\n\n### Dagster Cloud\n\n- [Experimental] Added support for freeing global op concurrency slots after runs have finished, using the deployment setting: `run_monitoring > free_slots_after_run_end_seconds`\n\n# 1.4.12 / 0.20.12 (libraries)\n\n### New\n\n- The `context` object now has an `asset_key` property to get the `AssetKey` of the current asset.\n- Performance improvements to the auto-materialize daemon when running on large asset graphs.\n- The `dagster dev` and `dagster-daemon run` commands now include a `--log-level` argument that allows you to customize the logger level threshold.\n- [dagster-airbyte] `AirbyteResource` now includes a `poll_interval` key that allows you to configure how often it checks an Airbyte sync’s status.\n\n### Bugfixes\n\n- Fixed an issue where the dagster scheduler would sometimes raise an error if a schedule set its cron_schedule to a list of strings and also had its default status set to AUTOMATICALLY_RUNNING.\n- Fixed an issue where the auto-materialize daemon would sometimes raise a RecursionError when processing asset graphs with long upstream dependency chains.\n- [ui] Fixed an issue where the Raw Compute Logs dropdown on the Run page sometimes didn’t show the current step name or properly account for retried steps.\n\n### Community Contributions\n\n- [dagster-databricks] Fixed a regression causing `DatabricksStepLauncher` to fail. Thanks [@zyd14](https://github.com/zyd14)!\n- Fixed an issue where Dagster raised an exception when combining observable source assets with multiple partitions definitions. Thanks [@aroig](https://github.com/aroig)!\n- [dagster-databricks] Added support for client authentication with OAuth. Thanks [@zyd14](https://github.com/zyd14)!\n- [dagster-databricks] Added support for `workspace` and `volumes` init scripts in the databricks client. Thanks [@zyd14](https://github.com/zyd14)!\n- Fixed a missing import in our docs. Thanks [@C0DK](https://github.com/C0DK)!\n\n### Experimental\n\n- Asset checks are now displayed in the asset graph and sidebar.\n- [Breaking] Asset check severity is now set at runtime on `AssetCheckResult` instead of in the `@asset_check` definition. Now you can define one check that either errors or warns depending on your check logic. `ERROR` severity no longer causes the run to fail. We plan to reintroduce this functionality with a different API.\n- [Breaking] `@asset_check` now requires the `asset=` argument, even if the asset is passed as an input to the decorated function. Example:\n\n  ```python\n  @asset_check(asset=my_asset)\n  def my_check(my_asset) -> AssetCheckResult:\n      ...\n  ```\n\n- [Breaking] `AssetCheckSpec` now takes `asset=` instead of `asset_key=`, and can accept either a key or an asset definition.\n- [Bugfix] Asset checks now work on assets with `key_prefix` set.\n- [Bugfix] `Execution failure` asset checks are now displayed correctly on the checks tab.\n\n### Documentation\n\n- [dagster-dbt] Added example of invoking `DbtCliResource` in custom asset/op to API docs.\n- [dagster-dbt] Added reference to explain how a dbt manifest can be created at run time or build time.\n- [dagster-dbt] Added reference to outline the steps required to deploy a Dagster and dbt project in CI/CD.\n- Miscellaneous fixes to broken links and typos.\n\n# 1.4.11 / 0.20.11 (libraries)\n\n### New\n\n- Dagster code servers now wait to shut down until any calls that they are running have finished, preventing them from stopping while in the middle of executing sensor ticks or other long-running operations.\n- The `dagster execute job` cli now accepts `—-op-selection` (thanks @silent-lad!)\n- [ui] Option (Alt) + R now reloads all code locations (OSS only)\n\n### Bugfixes\n\n- Adds a check to validate partition mappings when directly constructing `AssetsDefinition` instances.\n- Assets invoked in composition functions like `@graph` and `@job` now work again, fixing a regression introduced in 1.4.5.\n- Fixed an issue where a race condition with parallel runs materializing the same asset could cause a run to raise a RecursionError during execution.\n- Fixed an issue where including a resource in both a schedule and a job raised a “Cannot specify resource requirements” exception when the definitions were loaded.\n- The `ins` argument to `graph_asset` is now respected correctly.\n- Fixed an issue where the daemon process could sometimes stop with a heartbeat failure when the first sensor it ran took a long time to execute.\n- Fixed an issue where `dagster dev` failed on startup when the `DAGSTER_GRPC_PORT` `environment variable was set in the environment.\n- `deps` arguments for an asset can now be specified as an iterable instead of a sequence, allowing for sets to be passed.\n- [dagster-aws] Fixed a bug where the S3PickleIOManager didn’t correctly handle missing partitions when allow_missing_partitions was set. Thanks @o-sirawat!\n- [dagster-k8s] in the helm chart, the daemon `securityContext` setting now applies correctly to all init containers (thanks @maowerner!)\n\n### Community Contributions\n\n- [dagster-databricks] Migrated to use new official databricks Python SDK. Thanks @judahrand!\n\n### Experimental\n\n- New APIs for defining and executing checks on software-defined assets. These APIs are very early and subject to change. The corresponding UI has limited functionality. [Docs](https://docs.dagster.io/_apidocs/asset-checks)\n- Adds a new auto-materialize skip rule `AutoMaterializeRule.skip_on_not_all_parents_updated` that enforces that an asset can only be materialized if all parents have been materialized since the asset's last materialization.\n- Exposed an auto-materialize skip rule – `AutoMaterializeRule.skip_on_parent_missing` –which is already part of the behavior of the default auto-materialize policy.\n- Auto-materialize evaluation history will now be stored for 1 month, instead of 1 week.\n- The auto-materialize asset daemon now includes more logs about what it’s doing for each asset in each tick in the Dagster Daemon process output.\n\n### Documentation\n\n- [dagster-dbt] Added reference docs for `dagster-dbt project scaffold`.\n\n### Dagster Cloud\n\n- Fixed an issue where the Docker agent would sometimes fail to load code locations with long names with a hostname connection error.\n\n# 1.4.10 / 0.20.10 (libraries)\n\n### Bugfixes\n\n- [dagster-webserver] Fixed an issue that broke loading static files on Windows.\n\n# 1.4.9 / 0.20.9 (libraries)\n\n### Bugfixes\n\n- [dagster-webserver] Fixed an issue that caused some missing icons in the UI.\n\n# 1.4.8 / 0.20.8 (libraries)\n\n### New\n\n- A new `@partitioned_config` decorator has been added for defined configuration for partitioned jobs. Thanks @danielgafni!\n- [dagster-aws] The `ConfigurablePickledObjectS3IOManager` has been renamed `S3PickleIOManager` for simplicity. The `ConfigurablePickledObjecS3IOManager` will continue to be available but is considered deprecated in favor of `S3PickleIOManager`. There is no change in the functionality of the I/O manager.\n- [dagster-azure] The `ConfigurablePickledObjectADLS2IOManager` has been renamed `ADLS2PickleIOManager` for simplicity. The `ConfigurablePickledObjectADLS2IOManager` will continue to be available but is considered deprecated in favor of `ADLS2PickleIOManager`. There is no change in the functionality of the I/O manager.\n- [dagster-dbt] When an exception is raised when invoking a dbt command using `DbtCliResource`, the exception message now includes a link to the `dbt.log` produced. This log file can be inspected for debugging.\n- [dagster-gcp] The `ConfigurablePickledObjectGCSIOManager` has been renamed `GCSPickleIOManager` for simplicity. The `ConfigurablePickledObjecGCSIOManager` will continue to be available but is considered deprecated in favor of `GCSPickleIOManager`. There is no change in the functionality of the I/O manager.\n\n### Bugfixes\n\n- Fixed a bug that caused a `DagsterInvariantViolationError` when executing a multi-asset where both assets have self-dependencies on earlier partitions.\n- Fixed an asset backfill issue where some runs continue to be submitted after a backfill is requested for cancellation.\n- [dagster-dbt] Fixed an issue where using the `--debug` flag raised an exception in the Dagster framework.\n- [ui] “Launched run” and “Launched backfill” toasts in the Dagster UI behave the same way. To open in a new tab, hold the cmd/ctrl key when clicking “View”\n- [ui] When opening step compute logs, the view defaults to `stderr` which aligns with Python’s logging defaults.\n- [ui] When viewing a global asset graph with more than 100 assets, the “choose a subset to display” prompt is correctly aligned to the query input.\n\n### Community Contributions\n\n- Fix for loading assets with a `BackfillPolicy`, thanks @ruizh22!\n\n### Experimental\n\n- [dagster-graphql] The Dagster GraphQL Python client now includes a default timeout of 300 seconds for each query, to ensure that GraphQL requests don’t hang and never return a response. If you are running a query that is expected to take longer than 300 seconds, you can set the `timeout` argument when constructing a `DagsterGraphQLClient`.\n- [ui] We are continuing to improve the new horizontal rendering of the asset graph, which you can enable in Settings. This release increases spacing between nodes and improves the traceability of arrows on the graph.\n\n### Documentation\n\n- Several Pythonic resources and I/O managers now have API docs entries.\n- Updated the tutorial’s example project and content to be more explicit about resources.\n- [dagster-dbt] Added API docs examples for `DbtCliResource` and `DbtCliResource.cli(...)`.\n- Some code samples in API docs for `InputContext` and `OutputContext` have been fixed. Thanks @Sergey Mezentsev!\n\n### Dagster Cloud\n\n- When setting up a new organization by importing a dbt project, using GitLab is now supported.\n\n# 1.4.7 / 0.20.7 (libraries)\n\n### Experimental\n\n- Added a `respect_materialization_data_versions` option to auto materialization. It can enabled in `dagster.yaml` with\n\n  ```yaml\n  auto_materialize:\n    respect_materialization_data_versions: True\n  ```\n\n  This flag may be changed or removed in the near future.\n\n# 1.4.6 / 0.20.6 (libraries)\n\n### New\n\n- ops or assets with multiple outputs that are all required and return type `None`/ `Nothing` will interpret an explicitly or implicitly returned value `None` to indicate that all outputs were successful.\n- The `skip_reason` argument to the constructor of `SensorResult` now accepts a string in addition to a `SkipReason`.\n- [dagster-k8s] Added a `step_k8s_config` field to `k8s_job_executor` that allows you to customize the raw Kubernetes config for each step in a job. See [the docs](https://docs.dagster.io/deployment/guides/kubernetes/customizing-your-deployment#kubernetes-configuration-on-every-step-in-a-run) for more information.\n- [dagster-k8s] Launched run pods now have an additional code location label.\n- [dagster-ui] The runs table now lets you toggle which tags are always visible.\n- [dagster-dbt] `dagster-dbt project scaffold` now creates the scaffold in multiple files:\n  - `constants.py` contains a reference to your manifest and dbt project directory\n  - `assets.py` contains your initial dbt assets definitions\n  - `definitions.py` contains the code to load your asset definitions into the Dagster UI\n  - `schedules.py` contains an optional schedule to add for your dbt assets\n- [dagster-dbt] Added new methods `get_auto_materialize_policy` and `get_freshness_policy` to `DagsterDbtTranslator`.\n- [dagster-fivertran] Sync options can now be passed to `load_assets_from_fivetran_instance`.\n- [dagster-wandb] W&B IO Manager now handles partitions natively. (Thanks [@chrishiste](https://github.com/chrishiste)!)\n\n### Bugfixes\n\n- Previously, canceling large asset backfills would cause the daemon to time out and display a “not running” error. This has been fixed.\n- [dagster-ssh] Previously the `SSHResource` would warn when `allow_host_key_change` was set. Now known hosts are always loaded from the system hosts file, and the `allow_host_key_change` parameter is ignored.\n- Previously, when using AutoMaterializePolicies, partitioned assets downstream of partitioned observable source assets could be materialized before their parent partitions were observed. This has been fixed.\n\n### Documentation\n\n- `@graph_multi_asset` now has an API docs entry.\n- The `GCSComputeLogManager` example in the [Dagster Instance reference](https://docs.dagster.io/deployment/dagster-instance#gcscomputelogmanager) is now correct.\n- Several outdated K8s documentation links have been removed from the [Customizing your Kubernetes deployment guide](https://docs.dagster.io/deployment/guides/kubernetes/customizing-your-deployment).\n- Added callouts to the [GitHub](https://docs.dagster.io/dagster-cloud/managing-deployments/branch-deployments/using-branch-deployments-with-github) and [GitLab](https://docs.dagster.io/dagster-cloud/managing-deployments/branch-deployments/using-branch-deployments-with-gitlab) Branch Deployment guides specifying that some steps are optional for Serverless users.\n- The “Graphs” page under the “Concepts” section has been renamed to “Op Graphs” and moved inside under the “Ops” heading.\n- [dagster-dbt] Added API examples for `@dbt_assets` for the following use-cases:\n  - Running dbt commands with flags\n  - Running dbt commands with `--vars`\n  - Running multiple dbt commands\n  - Retrieving dbt artifacts after running a dbt command\n  - Invoking other Dagster resouces alongside dbt\n  - Defining and accessing Dagster config alongside dbt\n\n### Dagster Cloud\n\n- The viewer role now has permission to edit their own user tokens.\n\n# 1.4.5 / 0.20.5 (libraries)\n\n### New\n\n- `@graph_asset` now takes a `config` parameter equivalent to the parameter on `@graph`.\n- Added an optional `dynamic_partitions_store` argument to `DynamicPartitionsDefinition` for multi-partition run properly with dynamic partitions (Thanks @elzzz!).\n- [dagster-grpahql] Added ` partitionsByAssets` to `backfillParams` for ranged partition backfill (Thanks @ruizh22!).\n- [dagster-dbt] Support for `dbt-core==1.6` has been added.\n- [dagster-dbt] `DbtCliResource` now supports configuring `profiles_dir`.\n- [dagster-k8s] Allow specifying `restart_policy` on `k8s_job_op` (Thanks @Taadas!).\n- [dagster-snowflake] Added `authenticator` to `SnowflakePandasIOManager`, which allows specifying the authentication mechanism to use (Thanks @pengw0048!).\n- [ui] The Asset > Events page now allows you to filter by event type, making it easy to hide observations.\n- [ui] The Asset > Partitions page checks to see if the selected partition is stale and displays stale causes in the details pane.\n- [ui] Hovering over \"Fresh\" tags now provides detailed information about why the last materialization meets the asset's freshness policy.\n- [ui] The global asset graph can now be filtered to display a subset of the available asset groups.\n\n### Bugfixes\n\n- In some situations, multiple materializations of the same asset could be kicked off when using a lazy `AutoMaterializePolicy` with assets that had at least one source asset parent and at least one non-source asset parent. This has been fixed.\n- After applying an eager `AutoMaterializePolicy` to a time-partitioned asset downstream of an unpartitioned asset, the latest partition would only ever be materialized a single time, rather than updating in response to any parent updates. This has been fixed.\n- Fixed an issue that would cause the creation of a `StaticPartitionsDefinition` containing many thousands of partitions could take a significant amount of time.\n- The run coordinator daemon now uses a fresh request context on each iteration, fixing an issue where stale grpc server references could be used in certain high volume conditions.\n- Automatically generated data versions for partitioned assets now correctly reflect the data versions of upstream partitions. Previously, they were computed using the data versions from the most recent materializations of upstream assets regardless of partition.\n- [dagster-airbyte] Previously, attempting to load assets from an Airbyte instance in which some of the tables had hyphens in their name would result in an error. This has been fixed.\n- [dagster-dbt] Previously, attempting to load assets from a dbt project in which some of the models had hyphens in their name would result in an error. This has been fixed.\n- [dagstermill] Fixed a bug where known state for executing dagstermill ops was not correctly passed in (Thanks @motuzov!).\n- [ui] Pressing the up or down arrow key without a selection in the asset graph no longer causes a page error.\n\n### Documentation\n\n- Added the starter project’s template for Dagster University.\n- Fixed an incorrect method name in DagsterDbtTranslator Docs (Thanks @akan72!).\n\n### Dagster Cloud\n\n- When importing a dbt project on the Dagster Cloud setup page, an `Unexpected exception` error would be raised when scaffolding a pull request on a repository with no `profiles.yml`. This behavior has been updated to raise a more descriptive error message on the repo selection page.\n- The running multiple agents guide has been revamped to discuss running agent replicas and zero-downtime deployment of the agent.\n- The `agentReplicas` config setting on the helm chart has been renamed to `isolatedAgents`. In order to use this config setting, your user code dagster version needs to be `1.4.3` or greater.\n\n# 1.4.4 / 0.20.4 (libraries)\n\n### New\n\n- [ui] When viewing a run for auto-materialized assets, show a tag with information about the assets that were materialized.\n- [ui] In the Auto-materialize History view, when one or more of an asset’s parents have been updated, the set of updated parents will be viewable.\n- [ui] Link to the auto-materialized history for an asset from the asset DAG view.\n- [ui] For runs that were the result of auto-observation, show a tag for this in the Runs list view.\n- Added warnings for storage incompatibility with the experimental global op concurrency.\n\n### Bugfixes\n\n- [dagster-dbt] Fixed an issue where `dagster-dbt project scaffold` didn’t create a project directory with all the scaffolded files.\n- Fixed an issue which could cause errors when using the `SpecificPartitionsPartitionMapping` with auto-materialization.\n\n### Breaking Change\n\n- Previously, it was possible to set `max_materializations_per_minute` on an `AutoMaterializePolicy` to a non-positive number. This will now result in an error.\n\n### Community Contributions\n\n- Fix for loading multipartitions paths in `upath_io_manager` from @harrylojames; thank you!\n- Docs typo fix from @C0DK; thank you!\n\n### Documentation\n\n- Revamped the dagster-dbt tutorial to take advantage of `dagster project scaffold` and the new dagster-dbt APIs.\n\n# 1.4.3 / 0.20.3 (libraries)\n\n### New\n\n- [dagster-dbt] When invoking`dagster-dbt project scaffold` on a dbt project directory, if a `profiles.yml` exists in the root of the directory, its contents are used to add dbt adapter packages to the scaffolded `setup.py`.\n- The default sentinel value for the multiprocessing executor’s `max_concurrent` field has been changed from `0` to `None` to more clearly signal its intent. A value of `0` is still interpreted as the sentinel value which dynamically allocates `max_concurrent` based on detected CPU count.\n\n### Bugfixes\n\n- IO managers defined on jobs will now be properly merged with resources defined in `Definitions`, so that jobs are able to override the IO manager used.\n- [dagster-fivetran] Fixed an issue where `EnvVars` in a `FivetranResource` would not be evaluated when loading assets from the Fivetran instance.\n- [dagster-airbyte] Fixed an issue where `EnvVars` in an `AirbyteResource` would not be evaluated when loading assets from the Airbyte resource.\n\n### Documentation\n\n- [dagster-dbt] Added API docs for `DbtCliResource`, `DbtCliInvocation`, `@dbt_assets`, `DagsterDbtTranslator`, `dagster-dbt project scaffold`\n- [dagster-dbt] Expanded references for new APIs:\n  - Added documentation to customize asset definition attributes for dbt assets\n  - Added documentation to define upstream and downstream dependencies to dbt assets\n  - Added documentation to define schedules for dbt assets\n\n### Dagster Cloud\n\n- The experimental agent config setting `agent_replicas`has been deprecated in favor of a new name `isolated_agents` (`agentReplicas` --> `isolatedAgents` in the helm chart). Upgrading to the new name requires all code locations to be on `1.4.3` or greater.\n\n# 1.4.2 / 0.20.2 (libraries)\n\n### Bugfixes\n\n- Fixes a bug in `dagster-dbt` that was preventing it from correctly materializing subselections of dbt asset.\n\n# 1.4.1 / 0.20.1 (libraries)\n\n### Bugfixes\n\n- Fixes a bug in `dagster-dbt` that was preventing it efficiently loading dbt projects from a manifest.\n\n# 1.4.0 / 0.20.0 (libraries) \"Material Girl\"\n\n## **Major Changes since 1.3.0 (core) / 0.19.0 (libraries)**\n\n### Core\n\n- **Auto-materialize history** – We’ve added a UI that tracks why assets were or were not materialized according to their`AutoMaterializePolicy`. It’s located under `Assets` → Select an asset with an `AutoMaterializePolicy` → `Auto-materialize history` tab.\n- **Auto-materialize performance** – We’ve made significant performance improvements to the Asset Daemon, allowing it to keep up with asset graphs containing thousands of assets and assets with a large history of previously-materialized partitions.\n- **Asset backfill cancellation** — Asset backfills can now be canceled, bring them to parity with job backfills. When an asset backfill is requested for cancellation, the daemon cancels runs until all runs are terminated, then marks the backfill as “canceled”.\n- **non_argument_deps → deps** – We’ve deprecated the `non_argument_deps` parameter of `@asset` and `@multi_asset` in favor of a new `deps` parameter. The new parameter makes it clear that this is a first-class way of defining dependencies, makes code more concise, and accepts `AssetsDefinition` and `SourceAsset` objects, in addition to the `str`s and `AssetKey`s that the previous parameter accepted.\n- **Group-level asset status UI** – the new Assets Overview dashboard, located underneath the Activity tab of the Overview page, shows the status all the assets in your deployment, rolled up by group.\n- **Op concurrency (experimental)** — We’ve added a feature that allows limiting the number of concurrently executing ops across runs. [[docs](https://docs.dagster.io/guides/limiting-concurrency-in-data-pipelines#limiting-opasset-concurrency-across-runs)]\n- `DynamicPartitionsDefinition` and `SensorResult` are no longer marked experimental.\n- **Automatically observe source assets, without defining jobs (experimental** – The `@observable_source_asset` decorator now accepts an `auto_observe_interval_minutes` parameter. If the asset daemon is turned on, then the observation function will automatically be run at this interval. Downstream assets with eager auto-materialize policies will automatically run if the observation function indicates that the source asset has changed. [[docs](https://docs.dagster.io/concepts/assets/asset-auto-execution#auto-materialize-policies-and-data-versions)]\n- **Dagit → Dagster UI** – To reduce the number of Dagster-specific terms that new users need to learn when learning Dagster, “Dagit” has been renamed to the “The Dagster UI”. The `dagit` package is deprecated in favor of the `dagster-webserver` package.\n- **Default config in the Launchpad** - When you open the launchpad to kick off a job or asset materialization, Dagster will now automatically populate the default values for each field.\n\n### dagster-dbt\n\n- The **new `@dbt_assets` decorator** allows much more control over how Dagster runs your dbt project. [[docs](https://docs.dagster.io/_apidocs/libraries/dagster-dbt#dagster_dbt.dbt_assets)]\n- The **new `dagster-dbt project scaffold` command line interface** makes it easy to create files and directories for a Dagster project that wraps an existing dbt project.\n- **Improved APIs for defining asset dependencies** – The new `get_asset_key_for_model` and `get_asset_key_for_source` utilities make it easy to specify dependencies between upstream dbt assets and downstream non-dbt assets. And you can now more easily specify dependencies between dbt models and upstream non-dbt assets by specifying Dagster asset keys in the dbt metadata for dbt sources.\n\n## **Since 1.3.14 (core) / 0.19.14 (libraries)**\n\n### New\n\n- The published Dagster Docker images now use Python 3.10, instead of 3.7.\n- We’ve deprecated the `non_argument_deps` parameter of `@asset` and `@multi_asset` in favor of a new `deps` parameter. The new parameter makes it clear that this is a first-class way of defining dependencies, makes code more concise, and accepts `AssetsDefinition` and `SourceAsset` objects, in addition to the `str`s and `AssetKey`s that the previous parameter accepted.\n- The `UPathIOManager` can now be extended to load multiple partitions asynchronously (Thanks Daniel Gafni!).\n- By default, Dagster will now automatically load default config values into the launchpad. This behavior can be disabled in the user settings page.\n- [dagster-k8s] The Helm chart now sets readiness probes on user code deployment servers by default. These can be disabled with `dagster-user-deployments.deployments.[...].readinessProbe.enabled=false`.\n- [dagster-airbyte] In line with the deprecation of `non_argument_deps` in favor of `deps`, `build_airbyte_assets` now accepts a `deps` parameter.\n- [dagstermill] In line with the deprecation of `non_argument_deps` in favor of `deps`, `define_dagstermill_asset` now accepts a `deps` parameter.\n- [dagster-dbt] A new CLI utility `dagster-dbt project scaffold` has been provided to scaffold a Dagster code location for an existing dbt project.\n\n### Bugfixes\n\n- Duplicate partition keys passed to `StaticPartitionsDefinition` will now raise an error.\n- Fixed a bug that caused lazy `AutoMaterializePolicy`'s to not materialize missing assets.\n- [ui] Fixed an issue where global search and large DAGs were broken when using `--path-prefix`.\n- Schedule and sensor run submissions are now kept up to date with the current workspace, fixing an issue where a stale reference to a server would be used in some conditions.\n- [dagster-dbt] Fixed an issue where materializing dbt models with the same name as a dbt source would cause an error.\n\n### Breaking Changes\n\n- Support for Python 3.7 has been dropped.\n- `build_asset_reconciliation_sensor` (Experimental) has been removed. It was deprecated in 1.3 in favor of `AutoMaterializePolicy`.\n- `asset_key(s)` properties on `AssetIn` and `AssetDefinition` have been removed in favor of `key(s)`. These APIs were deprecated in 1.0.\n- `root_input_manager` and `RootInputManagerDefinition` have been removed in favor of `input_manager` and `InputManagerDefinition`. These APIs were deprecated in 1.0.\n- [dagster-pandas] The `event_metadata_fn` parameter on `create_dagster_pandas_dataframe_type` has been removed in favor of `metadata_fn`.\n- [dagster-dbt] The library has been substantially revamped to support the new `@dbt_assets` and `DbtCliResource`. See the migration guide for details.\n  - Group names for dbt assets are now taken from a dbt model's group. Before, group names were determined using the model's subdirectory path.\n  - Support for `dbt-rpc` has been removed.\n  - The class alias `DbtCloudResourceV2` has been removed.\n  - `DbtCli` has been renamed to `DbtCliResource`. Previously, `DbtCliResource` was a class alias for `DbtCliClientResource`.\n  - `load_assets_from_dbt_project` and `load_assets_from_dbt_manifest` now default to `use_build=True`.\n  - The default assignment of groups to dbt models loaded from `load_assets_from_dbt_project` and `load_assets_from_dbt_manifest` has changed. Rather than assigning a group name using the model’s subdirectory, a group name will be assigned using the dbt model’s [dbt group](https://docs.getdbt.com/docs/build/groups).\n  - The argument `node_info_to_definition_metadata_fn` for `load_assets_from_dbt_project` and `load_assets_from_dbt_manifest` now overrides metadata instead of adding to it.\n  - The arguments for `load_assets_from_dbt_project` and `load_assets_from_dbt_manifest` now must be specified using keyword arguments.\n  - When using the new `DbtCliResource` with `load_assets_from_dbt_project` and `load_assets_from_dbt_manifest`, stdout logs from the dbt process will now appear in the compute logs instead of the event logs.\n\n### Deprecations\n\n- The `dagit` python package is deprecated and will be removed in 2.0 in favor of `dagster-webserver`. See the migration guide for details.\n- The following fields containing “dagit” in the Dagster helm chart schema have been deprecated in favor of “dagsterWebserver” equivalents (see migration guide for details):\n  - `dagit` → `dagsterWebserver`\n  - `ingress.dagit` → `ingress.dagsterWebserver`\n  - `ingress.readOnlyDagit` → `ingress.readOnlyDagsterWebserver`\n- [Dagster Cloud ECS Agent] We've introduced performance improvements that rely on the [AWS Resource Groups Tagging API](https://docs.aws.amazon.com/resourcegroupstagging/latest/APIReference/overview.html). To enable, grant your agent's IAM policy permission to `tag:GetResources`. Without this policy, the ECS Agent will log a deprecation warning and fall back to its old behavior (listing all ECS services in the cluster and then listing each service's tags).\n- `DbtCliClientResource`, `dbt_cli_resource` and `DbtCliOutput` are now being deprecated in favor of `DbtCliResource`.\n- A number of arguments on `load_assets_from_dbt_project` and `load_assets_from_dbt_manifest` are now deprecated in favor of other options. See the migration for details.\n\n### Community Contributions\n\n- Docs typo fix from @chodera, thank you!\n- Run request docstring fix from @Jinior, thank you!\n\n### Documentation\n\n- All public methods in the Dagster API now have docstrings.\n- The entirety of the documentation has been updated to now refer to the “Dagster webserver” or “Dagster UI” where “Dagit” was previously used for both entities.\n\n# 1.3.14 (core) / 0.19.14 (libraries)\n\n### New\n\n- `DynamicPartitionsDefinition` and `SensorResult` are no longer marked experimental\n- `DagsterInstance` now has a `get_status_by_partition` method, which returns the status of each partition for a given asset. Thanks renzhe-brian!\n- `DagsterInstance` now has a `get_latest_materialization_code_versions` method, which returns the code version of the latest materialization for each of the provided (non-partitioned) assets.\n- The error message for when an asset illegally depends on itself is now more informative.\n- Further performance improvements for the Asset Daemon.\n- Performance improvements in the asset graph view for large asset graphs.\n- Pandas 2.x is now supported in all dagster packages.\n- `build_asset_context` has been added as an asset focused replacement for `build_op_context`.\n- `build_op_context` now accepts a `partition_key_range` parameter.\n- New `AssetSelection.upstream_source_assets` method allows selecting source assets upstream of the current selection.\n- `AssetSelection.key_prefixes` and `AssetSelection.groups` now accept an optional `include_sources` parameter.\n- The AutoMaterialize evaluations UI now provides more details about partitions and waiting on upstream assets.\n- [dbt] The `DbtCli` resource is no longer marked experimental.\n- [dbt] The `global_config` parameter of the `DbtCli` resource has been renamed to `global_config_flags`\n- [dbt] `load_assets_from_dbt_project` and `load_assets_from_dbt_manifest` now work with the `DbtCli` resource.\n- [dbt] The `manifest` argument of the `@dbt_assets` decorator now additionally can accept a `Path` argument representing a path to the manifest file or dictionary argument representing the raw manifest blob.\n- [dbt] When invoking `DbtCli.cli` from inside a `@dbt_assets`-decorated function, you no longer need to supply the manifest argument as long as you provide the context argument.\n- [dbt] The `DbtManifest` object can now generate schedules using dbt selection syntax.\n\n```python\ndbt_manifest.build_schedule(\n  job_name=\"materialize_dbt_models\",\n  cron_schedule=\"0 0 * * *\",\n  dbt_select=\"fqn:*\"\n)\n```\n\n- [dbt] When invoking `DbtCli.cli` and the underlying command fails, an exception will now be raised. To suppress the exception, run the `DbtCli.cli(..., raise_on_error=False`).\n- [ui] You can now alphabetically sort your partitions on the asset partitions page\n- [ui] A button in the “Run is materializing this asset” and “Run failed to materialize this asset” banners provides direct access to the relevant run logs\n\n### Bugfixes\n\n- Fixed a bug that caused asset metadata to not be available available on the `OutputContext` when using `with_attributes` or `AssetsDefinition.from_graph`.\n- Previously, if a partitioned asset at the root of the graph had more missing partitions than its AutoMaterializePolicy’s `max_materializations_per_minute` parameter, those older partitions would not be properly discarded from consideration on subsequent ticks. This has been fixed.\n- Fixed a bug that caused AutoMaterializePolicy.lazy() to not materialize missing assets that were downstream of assets without an AutoMaterializePolicy.\n- In rare cases, the AssetDaemon could hit an exception when using a combination of freshness policies and observable source assets. This has been fixed.\n- Previously, string type annotations (most commonly via modules containing `from __future__ import annotations`) would cause errors in most cases when used with Dagster definitions. This has been fixed for the vast majority of cases.\n- `AssetExecutionContext` has returned to being a type alias for `OpExecutionContext`.\n- [ui] Date filtering on the runs page now takes your timezone into consideration\n- [ui] Fixed a bug where selecting partitions in the launchpad dialog cleared out your configuration\n- [ui] In the run Gantt chart, executed steps that follow skipped steps no longer render off the far right of the visualization.\n- [ui] Cancelling a running backfill no longer makes canceled partitions un-selectable on the job partitions page and backfill modal, and cancellation is shown in gray instead of red.\n\n### Breaking Changes\n\n- [experimental] The internal `time_window_partition_scope_minutes` parameter of the `AutoMaterializePolicy` class has been removed. Instead, `max_materializations_per_minute` should be used to limit the number of runs that may be kicked off for a partitioned asset.\n\n### Deprecations\n\n- [dbt] `DbtCliResource` has been deprecated in favor of `DbtCli`.\n- The python package `dagit` has been deprecated in favor of a new package `dagster-webserver`.\n- `OpExecutionContext.asset_partition_key_range` has been deprecated in favor of `partition_key_range`.\n\n### Community Contributions\n\n- The `databricks_pyspark_step_launcher` will no longer error when executing steps that target a single partition of a `DynamicPartitionsDefinition` (thanks @[weberdavid](https://github.com/weberdavid)!).\n- Increased timeout on readinessProbe for example user code images, which prevents breakages in certain scenarios (thanks @[leehuwuj](https://github.com/leehuwuj))!\n- Avoid creation of erroneous local directories by GCS IO manager (thanks @[peterjclaw](https://github.com/PeterJCLaw))!\n- Fixed typo in intro docs (thanks @[adeboyed](https://github.com/adeboyed))!\n- Fix typo in bigquery docs (thanks @[nigelainscoe](https://github.com/nigelainscoe))!\n- Fix typing on run tag validation (thanks @[yuvalgimmunai](https://github.com/yuvalgimmunai))!\n- Allow passing repositoryCredentials arn as config to ecs run launcher (thanks @[armandobelardo](https://github.com/armandobelardo))!\n\n### Experimental\n\n- The `@observable_source_asset` decorator now accepts an `auto_observe_interval_minutes` parameter. If the asset daemon is turned on, then the observation function will automatically be run at this interval.\n- [dbt] `DbtCliTask` has been renamed to `DbtCliInvocation`\n- [dbt] The `get_asset_key_by_output_name` and `get_node_info_by_output_name` methods of `DbtManifest` have been renamed to`get_asset_key_for_output_name` and `get_node_info_for_output_name`, respectively.\n- [ui] A new feature flag allows you to switch Asset DAG rendering to a tighter horizontal layout, which may be preferable in some scenarios\n\n### Documentation\n\n- Many public methods that were missing in the API docs are now documented. Updated classes include `DagsterInstance`, `*MetadataValue`, `DagsterType`, and others.\n- `dagster-pandera` now has an API docs page.\n- Deprecated methods in the API docs now are marked with a special badge.\n\n# 1.3.13 (core) / 0.19.13 (libraries)\n\n### Bugfixes\n\n- Fixes a bug in `dagster project from-example` that was preventing it from downloading examples correctly.\n\n# 1.3.12 (core) / 0.19.12 (libraries)\n\n### New\n\n- The `--name` argument is now optional when running `dagster project from-example`.\n- An asset key can now be directly specified via the asset decorator: `@asset(key=...)`.\n- `AssetKey` now has a `with_prefix` method.\n- Significant performance improvements when using `AutoMaterializePolicy`s with large numbers of partitions.\n- `dagster instance migrate` now prints information about changes to the instance database schema.\n- The [`dagster-cloud-agent` helm chart](https://artifacthub.io/packages/helm/dagster-cloud/dagster-cloud-agent) now supports setting K8s labels on the agent deployment.\n- [ui] Step compute logs are shown under “Last Materialization” in the asset sidebar.\n- [ui] Truncated asset names now show a tooltip when hovered in the asset graph.\n- [ui] The “Propagate changes” button has been removed and replaced with “Materialize Stale and Missing” (which was the “Propagate changes” predecessor).\n\n### Bugfixes\n\n- [ui] Fixed an issue that prevented filtering by date on the job-specific runs tab.\n- [ui] “F” key with modifiers (alt, ctrl, cmd, shift) no longer toggles the filter menu on pages that support filtering.\n- [ui] Fix empty states on Runs table view for individual jobs, to provide links to materialize an asset or launch a run for the specific job, instead of linking to global pages.\n- [ui] When a run is launched from the Launchpad editor while an editor hint popover is open, the popover remained on the page even after navigation. This has been fixed.\n\n- [ui] Fixed an issue where clicking on the zoom controls on a DAG view would close the right detail panel for selected nodes.\n- [ui] Fixed an issue shift-selecting assets with multi-component asset keys.\n- [ui] Fixed an issue with the truncation of the asset stale causes popover.\n- When using a `TimeWindowPartitionMapping` with a `start_offset` or `end_offset` specified, requesting the downstream partitions of a given upstream partition would yield incorrect results. This has been fixed.\n- When using `AutoMaterializePolicy`s with observable source assets, in rare cases, a second run could be launched in response to the same version being observed twice. This has been fixed.\n\n- When passing in `hook_defs` to `define_asset_job`, if any of those hooks had required resource keys, a missing resource error would surface when the hook was executed. This has been fixed.\n- Fixed a typo in a documentation URL in `dagster-duckdb-polars` tests. The URL now works correctly.\n\n### Experimental\n\n- [dagster-dbt] Added methods to `DbtManifest` to fetch asset keys of sources and models: `DbtManifest.get_asset_key_for_model`, `DbtManifest.get_asset_key_for_source`. These methods are utilities for defining python assets as dependencies of dbt assets via `@asset(key=manifest.get_asset_key_for_model(...)`.\n- [dagster-dbt] The use of the `state_path` parameter with `DbtManifestAssetSelection` has been deprecated, and will be removed in the next minor release.\n- Added experimental support for limiting global op/asset concurrency across runs.\n\n### Dependencies\n\n- Upper bound on the `grpcio` package (for `dagster`) has been removed.\n\n### Breaking Changes\n\n- Legacy methods of `PartitionMapping` have been removed. Defining custom partition mappings has been unsupported since 1.1.7.\n\n### Community Contributions\n\n- [dagster-airbyte] Added the ability to specify asset groups to `build_airbyte_assets`. Thanks [@guy-rvvup](https://github.com/guy-rvvup)!\n\n### Documentation\n\n- For Dagster Cloud Serverless users, we’ve added our static IP addresses to [the Serverless docs](https://docs.dagster.io/dagster-cloud/deployment/serverless#whitelisting-dagsters-ip-addresses).\n\n# 1.3.11 (core) / 0.19.11 (libraries)\n\n### New\n\n- Assets with lazy auto-materialize policies are no longer auto-materialized if they are missing but don’t need to be materialized in order to help downstream assets meet their freshness policies.\n- [ui] The descriptions of auto-materialize policies in the UI now include their skip conditions along with their materialization conditions.\n- [dagster-dbt] Customized asset keys can now be specified for nodes in the dbt project, using `meta.dagster.asset_key`. This field takes in a list of strings that are used as the components of the generated `AssetKey`.\n\n```yaml\nversion: 2\n\nmodels:\n  - name: users\n    config:\n      meta:\n        dagster:\n          asset_key: [\"my\", \"custom\", \"asset_key\"]\n```\n\n- [dagster-dbt] Customized groups can now be specified for models in the dbt project, using `meta.dagster.group`. This field takes in a string that is used as the Dagster group for the generated software-defined asset corresponding to the dbt model.\n\n```yaml\nversion: 2\n\nmodels:\n  - name: users\n    config:\n      meta:\n        dagster:\n          group: \"my_group\"\n```\n\n### Bugfixes\n\n- Fixed an issue where the `dagster-msteams` and `dagster-mlflow` packages could be installed with incompatible versions of the `dagster` package due to a missing pin.\n- Fixed an issue where the `dagster-daemon run` command sometimes kept code server subprocesses open longer than it needed to, making the process use more memory.\n- Previously, when using `@observable_source_asset`s with AutoMaterializePolicies, it was possible for downstream assets to get “stuck”, not getting materialized when other upstream assets changed, or for multiple down materializations to be kicked off in response to the same version being observed multiple times. This has been fixed.\n- Fixed a case where the materialization count for partitioned assets could be wrong.\n- Fixed an error which arose when trying to request resources within run failure sensors.\n- [dagster-wandb] Fixed handling for multi-dimensional partitions. Thanks @chrishiste\n\n### Experimental\n\n- [dagster-dbt] improvements to `@dbt_assets`\n  - `project_dir` and `target_path` in `DbtCliTask` are converted from type `str` to type `pathlib.Path`.\n  - In the case that dbt logs are not emitted as json, the log will still be redirected to be printed in the Dagster compute logs, under `stdout`.\n\n### Documentation\n\n- Fixed a typo in dagster_aws S3 resources. Thanks @akan72\n- Fixed a typo in link on the Dagster Instance page. Thanks @PeterJCLaw\n\n# 1.3.10 (core) / 0.19.10 (libraries)\n\n### New\n\n- [dagster-dbt] By default, freshness policies and auto materialize policies on dbt assets can now be specified using the `dagster` field under `+meta` configuration. The following are equivalent:\n\nBefore:\n\n```yaml\nversion: 2\n\nmodels:\n  - name: users\n    config:\n      dagster_freshness_policy:\n        maximum_lag_minutes: 60\n        cron_schedule: \"0 9 * * *\"\n      dagster_auto_materialize_policy:\n        type: \"lazy\"\n```\n\nAfter:\n\n```yaml\nversion: 2\n\nmodels:\n  - name: users\n    config:\n      meta:\n        dagster:\n          freshness_policy:\n            maximum_lag_minutes: 60\n            cron_schedule: \"0 9 * * *\"\n          auto_materialize_policy:\n            type: \"lazy\"\n```\n\n- Added support for Pythonic Config classes to the `@configured` API, which makes reusing op and asset definitions easier:\n\n  ```python\n  class GreetingConfig(Config):\n      message: str\n\n  @op\n  def greeting_op(config: GreetingConfig):\n      print(config.message)\n\n  class HelloConfig(Config):\n      name: str\n\n  @configured(greeting_op)\n  def hello_op(config: HelloConfig):\n      return GreetingConfig(message=f\"Hello, {config.name}!\")\n  ```\n\n- Added `AssetExecutionContext` to replace `OpExecutionContext` as the context object passed in to `@asset` functions.\n- `TimeWindowPartitionMapping` now contains an `allow_nonexistent_upstream_partitions` argument that, when set to `True`, allows a downstream partition subset to have nonexistent upstream parents.\n- Unpinned the `alembic` dependency in the `dagster` package.\n- [ui] A new “Assets” tab is available from the Overview page.\n- [ui] The Backfills table now includes links to the assets that were targeted by the backfill.\n\n### Bugfixes\n\n- Dagster is now compatible with a breaking change introduced in `croniter==1.4.0`. Users of earlier versions of Dagster can pin `croniter<1.4`.\n- Fixed an issue introduced in 1.3.8 which prevented resources from being bound to sensors when the specified job required late-bound resources.\n- Fixed an issue which prevented specifying resource requirements on a `@run_failure_sensor`.\n- Fixed an issue where the asset reconciliation sensor failed with a “invalid upstream partitions” error when evaluating time partitions definitions with different start times.\n- [dagster-k8s] Fixed an issue where annotations are not included in the Dagster Helm chart for the pod that is created when configuring the Helm chart to run database migrations.\n- [ui] Fixed an issue with filtering runs by created date on the Runs page.\n- [ui] The “upstream partitions missing” warning no longer appears in the asset backfill dialog if the upstream partitioned asset is a source asset.\n- [dagster-dbt] Fixed an issue where asset dependencies for dbt models with ephemeral models in between them would sometimes be improperly rendered.\n\n### Community Contributions\n\n- Added support for setting resources in asset and multi_asset sensors. Thanks [@plaflamme](https://github.com/plaflamme)!\n- Fixed an issue where `py.typed` was missing in the `dagster-graphql` package. Thanks [@Tanguy-LeFloch](https://github.com/Tanguy-LeFloch)!\n\n### Experimental\n\n- Evaluation history for `AutoMaterializePolicy`s will now be cleared after 1 week.\n- [dagster-dbt] Several improvements to `@dbt_assets`:\n  - `profile` and `target` can now be customized on the `DbtCli` resource.\n  - If a `partial_parse.msgpack` is detected in the target directory of your dbt project, it is now copied into the target directories created by `DbtCli` to take advantage of [partial parsing](https://docs.getdbt.com/reference/parsing).\n  - The metadata of assets generated by `@dbt_assets` can now be customized by overriding `DbtManifest.node_info_to_metadata`.\n  - Execution duration of dbt models is now added as default metadata to `AssetMaterialization`s.\n\n### Documentation\n\n- Added [a new tutorial section](https://docs.dagster.io/tutorial/connecting-to-external-services) about using resources.\n\n### Dagster Cloud\n\n- Fixed an issue where overriding the container name of a code server pod using `serverK8sConfig.containerConfig.name` did not actually change the container name.\n\n# 1.3.9 (core) / 0.19.9 (libraries)\n\n### Dagster Cloud\n\n- Fixed an issue in the `1.3.8` release where the Dagster Cloud agent would sometimes fail to start up with an import error.\n\n# 1.3.8 (core) / 0.19.8 (libraries)\n\n### New\n\n- Multipartitioned assets with one time dimension can now depend on earlier partitions of themselves.\n- `define_asset_job` now accepts a `hooks` argument.\n- Added support for `sqlalchemy==2.x`\n- [ui] The Runs page has been revamped with better filtering support\n- [ui] The automaterialize policy page for SDA’s using the experimental AutomaterializePolicy feature now indicates time periods where no materializations happened due to no materialization conditions being met\n- [dagster-k8s] The Dagster Helm chart now includes an `additionalInstanceConfig` key that allows you to supply additional configuration to the [Dagster instance](https://docs.dagster.io/deployment/dagster-instance#dagster-instance).\n- [dagster-aws] The `EcsRunLauncher` now uses a different task definition family for each job, instead of registering a new task definition revision each time a different job is launched.\n- [dagster-aws] The `EcsRunLauncher` now includes a `run_ecs_tags` config key that lets you configure tags on the launched ECS task for each run.\n\n### Bugfixes\n\n- When a sensor had yield statement and also returned a `SkipReason`, the `SkipReason` would be ignored. This has been fixed.\n- [dagster-cloud] Fixed a bug in the docker user code launcher that was preventing code location containers from being properly cleaned up.\n- Fixed an issue where the Dagster UI would sometimes raise a ``RuntimeError: dictionary changed size during iteration` exception while code servers were being reloaded.\n- Fixed an issue where the Dagster daemon reloaded your code server every 60 seconds when using the new experimental `dagster code-server start` CLI, instead of only reloading your code when you initiate a reload from the Dagster UI.\n- Fixed a GraphQL error which would occur when loading the default config for jobs without config.\n- [dagster-dbt] Fixed an error which would arise when trying to load assets from a DBT Cloud instance using the Pythonic-style resource.\n\n### Community Contributions\n\n- Added the ability to specify metadata on asset jobs, by adding the `metadata` parameter to `define_asset_job` (Thanks **[Elliot2718](https://github.com/Elliot2718)!)**\n- [dagster-databricks] Connected databricks stdout to local stdout, to be handled by the compute log manager (Thanks **[loerinczy](https://github.com/loerinczy)!)**\n- [dagster-census] Fixed `poll_sync_run` to handle the “preparing” status from the Census API (Thanks **[ldnicolasmay](https://github.com/ldnicolasmay)!)**\n\n### Experimental\n\n- `@observable_source_asset`-decorated functions can now return a `DataVersionsByPartition` to record versions for partitions.\n- `@dbt_assets`\n  - `DbtCliTask`'s created by invoking `DbtCli.cli(...)` now have a method `.is_successful()`, which returns a boolean representing whether the underlying CLI process executed the dbt command successfully.\n  - Descriptions of assets generated by `@dbt_assets` can now be customized by overriding `DbtManifest.node_info_to_description`.\n  - IO Managers can now be configured on `@dbt_assets`.\n\n### Documentation\n\n- New guide on using Dagster to manage machine learning pipelines\n\n### Dagster Cloud\n\n- Added support for streaming upload of compute logs to Dagster Cloud\n- The ECS agent now supports setting `server_ecs_tags` and `run_ecs_tags` that apply to each service or task created by the agent. See [the docs](https://docs.dagster.io/dagster-cloud/deployment/agents/amazon-ecs/configuration-reference#amazon-ecs-agent-configuration-reference) for more information.\n- Fixed run filtering for calls to `instance.get_run_partition_data` in Dagster Cloud.\n\n# 1.3.7 (core) / 0.19.7 (libraries)\n\n### New\n\n- Adding a `.env` file in the working directory when running `dagster dev` can now be used for Dagster system variables like `DAGSTER_HOME` or environment variables referenced in your `dagster.yaml` file using an `env:` key. Previously, setting a `.env` file only worked for environment variables referenced in your Dagster code.\n- When using the GraphQL Python client, `submit_job_execution` can now take in a `RunConfig` object. Previously, it could only take a Python dictionary with the run configuration.\n- Asset backfills can now be canceled via a button in the UI. This will terminate unfinished runs and prevent new runs from being queued.\n- Introduced a new user setting which allows automatically expanding default config for jobs in the launchpad.\n- [dagit] Dagit now supports displaying a Polars tag on the asset graph.\n\n### Bugfixes\n\n- Fixed an issue where setting a resource in an op didn’t work if the Dagster job was only referenced within a schedule or sensor and wasn’t included in the `jobs` argument to `Definitions`.\n- [dagster-slack][dagster-pagerduty][dagster-msteams][dagster-airflow] Fixed issue where pre-built sensors and hooks which created urls to the runs page in the UI would use the old `/instance/runs` path instead of the new `/runs`.\n\n### Community Contributions\n\n- [dagster-databricks] Added a configurable resource key to `create_databricks_run_now_op`, thanks @srggrs!\n\n# 1.3.6 (core) / 0.19.6 (libraries)\n\n### New\n\n- Added an experimental `dagster code-server start` command that can be used to launch a code server, much like `dagster api grpc`. Unlike `dagster api grpc`, however, `dagster code-server start` runs the code in a subprocess, so it can reload code from the Dagster UI without needing to restart the command. This can be useful for jobs that load code from some external source and may want to reload job definitions without restarting the process.\n- Added a new `sensors.num_submit_workers` key to `dagster.yaml` that can be used to decrease latency when a sensor emits multiple run requests within a single tick. See [the docs](https://docs.dagster.io/deployment/dagster-instance#sensor-evaluation) for more information.\n- [dagster-k8s] The `k8s_job_executor` can now be used to launch each step of a job in its own Kubernetes, pod, even if the Dagster deployment is not using the `K8sRunLauncher` to launch each run in its own Kubernetes pod.\n- [ui] When viewing a list of schedules or sensors in Overview or on individual code locations, it is now possible to filter by running state.\n- [ui] A new experimental asset overview page is available via user settings.\n\n### Bugfixes\n\n- Fixed issue where asset jobs featuring a subset of a larger multi_asset could be rendered as an op-based job.\n- Fixed an issue where Pythonic IO managers could not be passed to the `io_manager_def` param on an asset.\n- Fixed an issue where late-binding an executor to a job, such as providing one to Definitions, would not correctly update the config schema.\n- [dagster-k8s] Fixed an issue where setting `maxResumeRunAttempts` to null in the helm chart would cause it to be set to a default value of 3 instead of disabling run retries.\n- [dagster-k8s] Fixed an issue where the `k8s_job_executor` would sometimes fail with a 409 Conflict error after retrying the creation of a Kubernetes pod for a step, due to the job having already been created during a previous attempt despite raising an error.\n- [dagster-dbt] Fixed an issue where dbt logs were not being captured when invoking dbt commands using the resource.\n- [dagster-dbt] Fixed an issue where if `op_name` was passed to `load_assets_from_dbt_manifest`, and a `select` parameter was specified, a suffix would be appended to the desired op name.\n- [ui] Fixed an issue where using a path prefix for `dagit` would lead to JavaScript bundle loading errors.\n- [ui] Resizing the viewport while viewing the Run timeline now correctly resizes the timeline and its contents.\n- [ui] Ctrl-scroll to zoom the DAG view, and shift-scroll to pan horizontally now work on all platforms and an instructional tooltip explains the zoom interaction.\n\n### Experimental\n\n- [dagster-dbt] Added a new implementation of the dbt Resource, `DbtCli`, in `dagster_dbt.cli`. This new resource only support `dbt-core>=1.4.0`.\n- [dagster-dbt] Added a new decorator `@dbt_assets` in `dagster_dbt.asset_decorator` that allows you to specify a compute function for a selected set of dbt assets that loaded as an `AssetsDefinition`.\n\n### Documentation\n\n- [dagster-duckdb] New guide and API reference page for the DuckDB I/O managers and resource\n- [rbac] - Added documentation for the new [Dagster Cloud Teams feature](https://docs.dagster.io/dagster-cloud/account/managing-users/managing-teams) for role-based access control (RBAC). We’ve also revamped the documentation for Dagster Cloud user roles and permissions - [check it out here](https://docs.dagster.io/dagster-cloud/account/managing-users/managing-user-roles-permissions).\n- Fixed a typo in the \"Using Environment Variables and Secrets\" guide (thanks **[snikch](https://github.com/snikch)!**)\n\n### Dagster Cloud\n\n- Fixed a bug in the multi-asset sensor where using context methods to fetch materializations by partition would cause a timeout.\n- The ECS agent can now configure sidecars to be included with the tasks that the agent launches. See [the docs](https://docs.dagster.io/dagster-cloud/deployment/agents/amazon-ecs/configuration-reference#amazon-ecs-agent-configuration-reference) for more information.\n\n# 1.3.5 (core) / 0.19.5 (libraries)\n\n### New\n\n- A new `max_materializations_per_minute` parameter (with a default of 1) to `AutoMaterializationPolicy.eager()` and `AutoMaterializationPolicy.lazy()` allows you to set bounds on the volume of work that may be automatically kicked off for each asset. To restore the previous behavior, you can explicitly set this limit to `None`.\n- `DailyPartitionsDefinition`, `HourlyPartitionsDefinition`, `WeeklyPartitionsDefinition`, and `MonthlyPartitionsDefinition` now support and `end_date` attribute.\n- [ui] When GraphQL requests time out with 504 errors, a toaster message is now shown indicating the error, instead of failing silently.\n- [dagster-snowflake] The Snowflake I/O managers now support authentication via unencrypted private key.\n\n### Bugfixes\n\n- When using `AutoMaterializePolicy`s or `build_asset_reconciliation_sensor`, a single new data version from an observable source asset could trigger multiple runs of the downstream assets. This has been fixed.\n- Fixed a bug with pythonic resources where raw run config provided to a resource would be ignored.\n- We previously erroneously allowed the use of `EnvVar` and `IntEnvVar` within raw run config - although they just returned the name of the env var rather than retrieve its value. This has been fixed to error directly.\n- [ui] Fixed an issue in the left navigation where code locations with names with URI-encodable characters (e.g. whitespace) could not be expanded.\n- [ui] Fixed an issue where the time shown on the Runs page when a run was starting was shown in an incorrect timezone.\n- [dagster-dbt] Fixed an issue where selecting models by `*` was being interpreted as glob pattern, rather than as a dbt selector argument. We now explicitly set the default selection pattern as `fqn:*`.\n- [dagster-cloud cli] Fixed and issue where `dagster-cloud serverless deploy` did not create a unique image tag if the `--image` tag was not specified.\n\n### Community Contributions\n\n- Added an option to specify `op_name` on `load_assets_from_dbt_project` and `load_assets_from_dbt_manifest` (thanks @wkeifenheim!)\n- [Helm] Added support for connecting to code servers over SSL (thanks @jrouly!)\n\n### Documentation\n\n- New tutorial section on how to manage your own I/O and control over dependencies\n\n### Dagster Cloud\n\n- Added the ability to assign users to teams. A team is a group of users with a shared set of permissions. See [the docs](https://docs.dagster.io/dagster-cloud/account/managing-users/managing-teams) for more information.\n\n# 1.3.4 (core) / 0.19.4 (libraries)\n\n### New\n\n- Run monitoring will now detect runs that are stuck in a CANCELING state due to an error during termination and move them into CANCELED. See the [docs](https://docs.dagster.io/deployment/run-monitoring#run-cancelation-timeouts) for more information.\n- `TimeWindowPartitionMapping` objects are now current-time aware. Subsequently, only upstream/downstream partitions existent at the current time are returned.\n- `ExecuteJobResult` was renamed to `JobExecutionResult` (`ExecuteJobResult` remains a deprecated alias)\n- New `AssetSelection.key_prefixes` method allows matching asset keys starting with a provided prefix.\n- [dagster-airflow] persistent database URI can now be passed via environment variable\n- [dagster-azure] New `ConfigurablePickledObjectADLS2IOManager` that uses pythonic config\n- [dagster-fivetran] Fivetran connectors that are broken or incomplete are now ignored\n- [dagster-gcp] New `DataProcResource` follows the Pythonic resource system. The existing `dataproc_resource` remains supported.\n- [dagster-k8s] The K8sRunLauncher and k8s_job_executor will now retry the api call to create a Kubernetes Job when it gets a transient error code (500, 503, 504, or 401).\n- [dagster-snowflake] The `SnowflakeIOManager` now supports `private_key`s that have been `base64` encoded to avoid issues with newlines in the private key. Non-base64 encoded keys are still supported. See the `SnowflakeIOManager` documentation for more information on `base64` encoded private keys.\n- [ui] Unpartitioned assets show up on the backfill page\n- [ui] On the experimental runs page you can open the “view all tags” dialog of a row by pressing the hotkey ‘t’ while hovering that row.\n- [ui] The “scroll-to-pan” feature flag has been removed, and scroll-to-pan is now default functionality.\n\n### Bugfixes\n\n- The server side polling for events during a live run has had its rate adjusted and no longer uses a fixed interval.\n- [dagster-postgres] Fixed an issue where primary key constraints were not being created for the `kvs`, `instance_info`, and `daemon_hearbeats` table for existing Postgres storage instances that were migrating from before `1.2.2`. This should unblock users relying on the existence of a primary key constraint for replication.\n- Fixed a bug that could cause incorrect counts to be shown for missing asset partitions when partitions are in progress\n- Fixed an issue within `SensorResult` evaluation where multipartitioned run requests containing a dynamic partition added in a dynamic partitions request object would raise an invalid partition key error.\n- [ui] When trying to terminate a queued or in-progress run from a Run page, forcing termination was incorrectly given as the only option. This has been fixed, and these runs can now be terminated normally.\n- [ui] Fixed an issue on the asset job partitions page where an infinite recursion error would be thrown when using `TimeWindowPartitionMapping`.\n- [dagster-databricks] Polling for the status of skipped Databricks runs now properly terminates.\n\n### Deprecations\n\n- `ExecuteJobResult` is now a deprecated alias for the new name, `JobExecutionResult`.\n\n### Community Contributions\n\n- [dagster-airbyte] When supplying an `airbyte_resource` to `load_assets_from_connections` , you may now provide an instance of the `AirbyteResource` class, rather than just `airbyte_resource.configured(...)` (thanks **[@joel-olazagasti](https://github.com/joel-olazagasti)!)**\n- [dagster-airbyte] Fixed an issue connecting to destinations that support normalization (thanks [@nina-j](https://github.com/nina-j)!)\n- Fix an error in the docs code snippets for IO managers (thanks [out-running-27](https://github.com/out-running-27)!)\n- Added [an example](https://github.com/dagster-io/dagster/tree/master/examples/project_analytics) to show how to build the Dagster's Software-Defined Assets for an analytics workflow with different deployments for a local and prod environment. (thanks [@PedramNavid](https://github.com/PedramNavid)!)\n- [dagster-celery] Fixed an issue where the `dagster-celery` CLI accepted an inconsistent configuration format - it now matches the same format as the `celery_executor`. Thanks [@boenshao](https://github.com/boenshao)!\n\n### Documentation\n\n- New “Managing your own I/O” tutorial section and other minor tutorial improvements.\n\n### Dagster Cloud\n\n- The ECS agent will now display task logs and other debug information when a code location fails to start up.\n- You can now set `ecs_timeout` in your ECS user code launcher config to extend how long the ECS agent polls for new code servers to start. Extending this timeout is useful if your code server takes an unusually long time to start up - for example, because it uses a very large image.\n- Added support for running the Dagster Cloud Kubernetes agent in a cluster using istio.\n\n# 1.3.3 (core) / 0.19.3 (libraries)\n\n### New\n\n- `load_assets_from_package_module` and the other core `load_assets_from_` methods now accept a `source_key_prefix` argument, which allows applying a key prefix to all the source assets that are loaded.\n- `OpExecutionContext` now has an `asset_partitions_time_window_for_input` method.\n- `RunFailureSensorContext` now has a `get_step_failure_events` method.\n- The Pythonic resource system now supports a set of lifecycle hooks which can be used to manage setup and teardown:\n\n  ```python\n  class MyAPIClientResource(ConfigurableResource):\n      api_key: str\n      _internal_client: MyAPIClient = PrivateAttr()\n\n      def setup_for_execution(self, context):\n          self._internal_client = MyAPIClient(self.api_key)\n\n      def get_all_items(self):\n          return self._internal_client.items.get()\n  ```\n\n- Added support for specifying input and output config on `ConfigurableIOManager`.\n- `QueuedRunCoordinator` and `SubmitRunContext` are now exposed as public dagster exports.\n- [ui] Downstream cross-location dependencies of all source assets are now visible on the asset graph. Previously these dependencies were only displayed if the source asset was defined as a regular asset.\n- [ui] A new filtering experience is available on the Runs page after enabling feature flag “Experimental Runs table view with filtering”.\n- [dagster-aws] Allow the S3 compute log manager to specify a `show_url_only: true` config option, which will display a URL to the S3 file in dagit, instead of the contents of the log file.\n- [dagster-aws] `PickledObjectS3IOManager` now fully supports loading partitioned inputs.\n- [dagster-azure] `PickedObjectADLS2IOManager` now fully supports loading partitioned inputs.\n- [dagster-gcp] New `GCSResource` and `ConfigurablePickledObjectGCSIOManager` follow the Pythonic resource system. The existing `gcs_resource` and `gcs_pickle_io_manager` remain supported.\n- [dagster-gcp] New `BigQueryResource` follows the Pythonic resource system. The existing `bigquery_resource` remains supported.\n- [dagster-gcp] `PickledObjectGCSIOManager` now fully supports loading partitioned inputs.\n- [dagster-postgres] The event watching implementation has been moved from listen/notify based to the polling watcher used by MySQL and SQLite.\n- [dagster-slack] Add `monitor_all_repositories` to `make_slack_on_run_failure_sensor`, thanks @danielgafni!\n- [dagster-snowflake] New `SnowflakeResource` follows the Pythonic resource system. The existing `snowflake_resource` remains supported.\n\n### Bugfixes\n\n- Multi-asset sensor context methods for partitions now work when partitioned source assets are targeted.\n- Previously, the asset backfill page would incorrectly display negative counts for assets with upstream failures. This has been fixed.\n- In cases where there is an asset which is upstream of one asset produced by a subsettable multi-asset, but downstream of another, Dagster will automatically subset the multi-asset to resolve the underlying cycle in the op dependency graph. In some cases, this process could omit some of the op dependencies, resulting in incorrect execution order. This has been fixed.\n- Fixed an issue with `AssetMetadataValue.value` that would cause an infinite recursion error.\n- Fixed an issue where observable source assets would show up in the asset graph of jobs that did not include them.\n- Fixed an issue with directly invoking an op or asset with a Pythonic config object with a discriminated union did not work properly.\n- Fixes a bug where sensors attached to jobs that rely on resources from Definitions were not provided with the required resource definition.\n\n### Dagster Cloud\n\n- `volumes` and `volumeMounts` values have been added to the agent helm chart.\n\n### Experimental\n\n- [dagster-airbyte] `load_assets_from_airbyte_instance` and `load_assets_from_airbyte_project` now take a `connection_to_auto_materialize_policy_fn` for setting `AutoMaterializePolicy`s on Airbyte assets\n- [dagster-airbyte] Introduced experimental support for Airbyte Cloud. See the [using Dagster with Airbyte Cloud docs for more information](https://docs.dagster.io/integrations/airbyte-cloud).\n\n### Documentation\n\n- Ever wanted to know more about the files in Dagster projects, including where to put them in your project? Check out the new [Dagster project files reference](https://docs.dagster.io/getting-started/project-file-reference) for more info!\n- We’ve made some improvements to the sidenav / information architecture of our docs!\n  - The **Guides** section now contains several new categories, including **Working with data assets** and **Working with tasks**\n  - The **Community** section is now under **About**\n- The Backfills concepts page now includes instructions on how to launch backfills that target ranges of partitions in a single run.\n\n# 1.3.2 (core) / 0.19.2 (libraries)\n\n### New\n\n- Added performance improvements for yielding time-partitioned run requests.\n- The asset backfill page now displays targeted assets in topological order.\n- Replicas can now be specified on Hybrid ECS and K8s agents. In ECS, use the `NumReplicas` parameter on the agent template in CloudFormation, or the `dagsterCloudAgent.replicas` field in Helm.\n- Zero-downtime agent updates can now be configured for the ECS agent. Just set the `enableZeroDowntimeDeploys` parameter to true in the CloudFormation stack for your agent.\n- The `AssetsDefinition.from_graph`, as well as the`@graph_asset` and `@graph_multi_asset` decorators now support specifying `AutoMaterializePolicy`s.\n- [dagstermill] Pythonic resource variant of the dagstermill I/O manager is now available.\n- [dagster-duckdb] New DuckDBResource for connecting to and querying DuckDB databases.\n- [ui] Sensor / Schedule overview pages now allow you to select and start/stop multiple sensors/schedules at once.\n- [ui] Performance improvements to global search for big workspaces.\n\n### Bugfixes\n\n- `async def` ops/assets no longer prematurely finalize async generators during execution.\n- In some cases, the AutoMaterialize Daemon (and the `build_asset_reconciliation_sensor`) could incorrectly launch new runs for partitions that already had an in-progress run. This has been fixed.\n\n### Breaking Changes\n\n- Yielding run requests for experimental dynamic partitions via `run_request_for_partition` now throws an error. Instead, users should yield directly instantiated run requests via `RunRequest(partition_key=...)`.\n- `graph_asset` and `graph_multi_asset` now support specifying `resource_defs` directly (thanks [@kmontag42](https://github.com/KMontag42))!\n\n### Community Contributions\n\n- A new `node_info_to_auto_materialize_policy_fn` param added to `load_assets_from_dbt_*` functions. (thanks [@askvinni](https://github.com/askvinni))!\n- Added `partition_key` field to `RunStatusSensorContext` (thanks [@pdstrnadJC](https://github.com/pdstrnadJC))!\n\n### Experimental\n\n- For multi-partitioned assets with a time dimension, the auto-materialize policy now only kicks off materializations for the latest time partition window. Previously, all partitions would be targeted.\n- Added performance improvements to the multi-asset sensor context’s `latest_materialization_records_by_key` method.\n- The GraphQL API for launching a backfill no longer errors when the backfill targets assets instead of a job and the `allPartitions` argument is provided.\n\n### Documentation\n\n- Fixed a few typos in various guides.\n- Fixed a formatting issue in the Automating pipelines guide that was causing a 404.\n\n# 1.3.1 (core) / 0.19.1 (libraries)\n\n### New\n\n- Performance improvements when evaluating time-partitioned run requests within sensors and schedules.\n- [ui] Performance improvements when loading the asset catalog and launchpad for deployments with many time-partitioned assets.\n\n### Bugfixes\n\n- Fixed an issue where loading a Definitions object that included sensors attached to multiple jobs would raise an error.\n- Fixed a bug in which Pythonic resources would produce underlying resource values that would fail reference equality checks. This would lead to a conflicting resource version error when using the same Pythonic resource in multiple places.\n\n# 1.3.0 (core) / 0.19.0 (libraries) \"Smooth Operator\"\n\n## **Major Changes since 1.2.0 (core) / 0.18.0 (libraries)**\n\n### Core\n\n- **Auto-materialize policies replace the asset reconciliation sensor** - We significantly renovated the APIs used for specifying which assets are scheduled declaratively. Compared to `build_asset_reconciliation_sensor`s , `AutoMaterializePolicy` works across code locations, as well as allow you to customize the conditions under which each asset is auto-materialized. [[docs](https://docs.dagster.io/concepts/assets/asset-auto-execution)]\n- **Asset backfill page** - A new page in the UI for monitoring asset backfills shows the progress of each asset in the backfill.\n- **Clearer labels for tracking changes to data and code** - Instead of the opaque “stale” indicator, Dagster’s UI now indicates whether code, upstream data, or dependencies have changed. When assets are in violation of their `FreshnessPolicy`s, Dagster’s UI now marks them as “overdue” instead of “late”.\n- **Auto-materialization and observable source assets** - Assets downstream of an observable source asset now use the source asset observations to determine whether upstream data has changed and assets need to be materialized.\n- **Pythonic Config and Resources** - The set of APIs [introduced in 1.2](#120-core--0180-libraries) is no longer experimental [[community memo](https://dagster.io/blog/pythonic-config-and-resources)]. Examples, integrations, and documentation have largely ported to the new APIs. Existing resources and config APIs will continue to be supported for the foreseeable future. Check out [migration guide](https://docs.dagster.io/guides/dagster/migrating-to-pythonic-resources-and-config) to learn how to incrementally adopt the new APIs.\n\n### Docs\n\n- **Improved run concurrency docs** - You asked (in support), and we answered! This [new guide](https://docs.dagster.io/guides/limiting-concurrency-in-data-pipelines) is a one-stop-shop for understanding and implementing run concurrency, whether you’re on Dagster Cloud or deploying to your own infrastructure.\n- **Additions to the Intro to Assets tutorial** - We’ve added two new sections to the assets tutorial, focused on [scheduling](https://docs.dagster.io/tutorial/scheduling-your-pipeline) and [I/O](https://docs.dagster.io/tutorial/saving-your-data). While we’re close to wrapping things up for the tutorial revamp, we still have a few topics to cover - stay tuned!\n- **New guide about building machine learning pipelines** - Many of our users learn best by example - [this guide](https://docs.dagster.io/guides/dagster/ml-pipeline) is one way we’re expanding our library of examples. In this guide, we walk you through building a simple machine learning pipeline using Dagster.\n- **Re-organized Dagster Cloud docs** - We overhauled how the Dagster Cloud docs are organized, bringing them more in line with the UI.\n\n## **Since 1.2.7 (core) / 0.18.7 (libraries)**\n\n### New\n\n- Long-running runs can now be terminated after going over a set runtime. See the [run termination docs](https://docs.dagster.io/deployment/run-monitoring#general-run-timeouts) to learn more.\n- Adds a performance improvement to partition status caching for multi-partitioned assets containing a time dimension.\n- [ui] Asset groups are now included in global search.\n- [ui] Assets in the asset catalog have richer status information that matches what is displayed on the asset graph.\n- [dagster-aws] New `AthenaClientResource`, `ECRPublicResource`, `RedshiftClientResource`, `S3Resource`, `S3FileManagerResource`, `ConfigurablePickledObjectS3IOManager`, `SecretsManagerResource` follow Pythonic resource system. The existing APIs remain supported.\n- [dagster-datadog] New `DatadogResource` follows Pythonic resource system. The existing `datadog_resource` remains supported.\n- [dagster-ge] New `GEContextResource` follows Pythonic resource system. The existing `ge_context_resource` remains supported.\n- [dagster-github] New `GithubResource` follows Pythonic resource system. The existing `github_resource` remains supported.\n- [dagster-msteams] New `MSTeamsResource` follows Pythonic resource system. The existing `msteams_resource` remains supported.\n- [dagster-slack] New `SlackResource` follows Pythonic resource system. The existing `slack_resource` remains supported.\n\n### Bugfixes\n\n- Fixed an issue where using `pdb.set_trace` no longer worked when running Dagster locally using `dagster dev` or `dagit`.\n- Fixed a regression where passing custom metadata on `@asset` or `Out` caused an error to be thrown.\n- Fixed a regression where certain states of the asset graph would cause GQL errors.\n- [ui] Fixed a bug where assets downstream of source assets would sometimes incorrectly display a “New data” (previously “stale”) tag for assets with materializations generated from ops (as opposed to SDA materializations).\n- [ui] Fixed a bug where URLs for code locations named `pipelines` or `jobs` could lead to blank pages.\n- [ui] When configuring a partition-mapped asset backfill, helpful context no longer appears nested within the “warnings” section\n- [ui] For observable source assets,the asset sidebar now shows a “latest observation” instead of a “latest materialization”\n\n### Breaking Changes\n\n- By default, resources defined on `Definitions` are now automatically bound to jobs. This will only result in a change in behavior if you a) have a job with no \"io_manager\" defined in its `resource_defs` and b) have supplied an `IOManager` with key \"io_manager\" to the `resource_defs` argument of your `Definitions`. Prior to 1.3.0, this would result in the job using the default filesystem-based `IOManager` for the key \"io_manager\". In 1.3.0, this will result in the \"io_manager\" supplied to your `Definitions` being used instead. The `BindResourcesToJobs` wrapper, introduced in 1.2 to simulate this behavior, no longer has any effect.\n- [dagster-celery-k8s] The default kubernetes namespace for run pods when using the Dagster Helm chart with the `CeleryK8sRunLauncher` is now the same namespace as the Helm chart, instead of the `default` namespace. To restore the previous behavior, you can set the `celeryK8sRunLauncher.jobNamespace` field to the string `default`.\n- [dagster-snowflake-pandas] Due to a longstanding issue storing Pandas Timestamps in Snowflake tables, the `SnowflakePandasIOManager` has historically converted all timestamp data to strings before storing it in Snowflake. Now, it will instead ensure that timestamp data has a timezone, and if not, attach the UTC timezone. This allows the timestamp data to be stored as timestamps in Snowflake. If you have been storing timestamp data using the `SnowflakePandasIOManager` you can set the `store_timestamps_as_strings=True` configuration to continue storing timestamps as strings. For more information, and instructions for migrating Snowflake tables to use timestamp types, see the Migration Guide.\n\n**Changes to experimental APIs**\n\n- Pythonic Resources and Config\n  - Enabled passing `RunConfig` to many APIs which previously would only accept a config dictionary.\n  - Enabled passing raw Python objects as resources to many APIs which previously would only accept `ResourceDefinition`.\n  - Added the ability to pass `execution` config when constructing a `RunConfig` object.\n  - Introduced more clear error messages when trying to mutate state on a Pythonic config or resource object.\n  - Improved direct invocation experience for assets, ops, schedules and sensors using Pythonic config and resources. Config and resources can now be passed directly as args or kwargs.\n- The `minutes_late` and `previous_minutes_late` properties on the experimental `FreshnesPolicySensorContext` have been renamed to `minutes_overdue` and `previous_minutes_overdue`, respectively.\n\n**Removal of deprecated APIs**\n\n- [previously deprecated, 0.15.0] `metadata_entries` arguments to event constructors have been removed. While `MetadataEntry` still exists and will only be removed in 2.0, it is no longer passable to any Dagster public API — users should always pass a dictionary of metadata values instead.\n\n### Experimental\n\n- Adds a performance improvement to the multi-asset sensor context’s `latest_materialization_records_by_key` function.\n\n### Documentation\n\n- The Google BigQuery [tutorial](https://docs.dagster.io/integrations/bigquery/using-bigquery-with-dagster) and [reference](https://docs.dagster.io/integrations/bigquery/reference) pages have been updated to use the new `BigQueryPandasIOManager` and `BigQueryPySparkIOManager`.\n- The Snowflake [tutorial](https://docs.dagster.io/integrations/snowflake/using-snowflake-with-dagster) and [reference](https://docs.dagster.io/integrations/snowflake/reference) pages have been updated to use the new `SnowflakePandasIOManager` and `SnowflakePySparkIOManager`.\n\n### Dagster Cloud\n\n- Previously, when deprovisioning an agent, code location servers were cleaned up in serial. Now, they’re cleaned up in parallel.\n\n# 1.2.7 (core) / 0.18.7 (libraries)\n\n### New\n\n- Resource access (via both `required_resource_keys` and Pythonic resources) are now supported in observable source assets.\n- [ui] The asset graph now shows how many partitions of each asset are currently materializing, and blue bands appear on the partition health bar.\n- [ui] Added a new page to monitor an asset backfill.\n- [ui] Performance improvement for Runs page for runs that materialize large numbers of assets.\n- [ui] Performance improvements for Run timeline and left navigation for users with large numbers of jobs or assets.\n- [ui] In the run timeline, consolidate “Ad hoc materializations” rows into a single row.\n- [dagster-aws] The `EcsRunLauncher` now allows you to customize volumes and mount points for the launched ECS task. See [the API docs](https://docs.dagster.io/_apidocs/libraries/dagster-aws#dagster_aws.ecs.EcsRunLauncher) for more information.\n- [dagster-duckdb, dagster-duckdb-pandas, dagster-duckdb-pyspark] New `DuckDBPandasIOManager` and `DuckDBPySparkIOManager` follow Pythonic resource system. The existing `duckdb_pandas_io_manager` and `duckdb_pyspark_io_manager` remain supported.\n- [dagster-gcp, dagster-gcp-pandas, dagster-gcp-pyspark] New `BigQueryPandasIOManager` and `BigQueryPySparkIOManager` follow Pythonic resource system. The existing `bigquery_pandas_io_manager` and `bigquery_pyspark_io_manager` remain supported.\n- [dagster-gcp] The BigQuery resource now accepts authentication credentials as configuration. If you pass GCP authentication credentials to `gcp_crentials` , a temporary file to store the credentials will be created and the `GOOGLE_APPLICATION_CREDENTIALS` environment variable will be set to the temporary file. When the BigQuery resource is garbage collected, the environment variable will be unset and the temporary file deleted.\n- [dagster-snowflake, dagster-snowflake-pandas, dagster-snowflake-pyspark] New `SnowflakePandasIOManager` and `SnowflakePySparkIOManager` follow Pythonic resource system. The existing `snowflake_pandas_io_manager` and `snowflake_pyspark_io_manager` remain supported.\n\n### Bugfixes\n\n- Fixed an issue where `dagster dev` would periodically emit a harmless but annoying warning every few minutes about a gRPC server being shut down.\n- Fixed a schedule evaluation error that occurred when schedules returned a `RunRequest(partition_key=...)` object.\n- Fixed a bug that caused errors in the asset reconciliation sensor when the event log includes asset materializations with partitions that aren’t part of the asset’s `PartitionsDefinition`.\n- Fixed a bug that caused errors in the asset reconciliation sensor when a partitioned asset is removed.\n- Fixed an issue where `run_request_for_partition` would incorrectly raise an error for a job with a `DynamicPartitionsDefinition` that was defined with a function.\n- Fixed an issue where defining a partitioned job with unpartitioned assets via `define_asset_job` would raise an error.\n- Fixed a bug where source asset observations could not be launched from dagit when the asset graph contained partitioned assets.\n- Fixed a bug that caused **`__ASSET_JOB has no op named ...`** errors when using automatic run retries.\n- [ui] The asset partition health bar now correctly renders partial failed partitions of multi-dimensional assets in a striped red color.\n- [ui] Fixed an issue where steps that were skipped due to an upstream dependency failure were incorrectly listed as “Preparing” in the right-hand column of the runs timeline.\n- [ui] Fixed markdown base64 image embeds.\n- [ui] Guard against localStorage quota errors when storing launchpad config tabs.\n- [dagster-aws] Fixed an issue where the `EcsRunLauncher` would fail to launch runs if the `use_current_ecs_task_config` field was set to `False` but no `task_definition` field was set.\n- [dagster-k8s] Fixed an issue introduced in 1.2.6 where older versions of the kubernetes Python package were unable to import the package.\n\n### Community Contributions\n\n- The `EcsRunLauncher` now allows you to set a capacity provider strategy and customize the ephemeral storage used for launched ECS tasks. See [the docs](https://docs.dagster.io/deployment/guides/aws#customizing-the-launched-runs-task) for details. Thanks [AranVinkItility](https://github.com/AranVinkItility)!\n- Fixed an issue where freshness policies were not being correctly applied to assets with key prefixes defined via `AssetsDefinition.from_op`. Thanks @tghanken for the fix!\n- Added the `minimum_interval_seconds` parameter to enable customizing the evaluation interval on the slack run failure sensor, thanks @ldnicolasmay!\n- Fixed a docs example and updated references, thanks @NicolasPA!\n\n### Experimental\n\n- The `Resource` annotation for Pythonic resource inputs has been renamed to `ResourceParam` in preparation for the release of the feature in 1.3.\n- When invoking ops and assets that request resources via parameters directly, resources can now be specified as arguments.\n- Improved various error messages related to Pythonic config and resources.\n- If the Resources Dagit feature flag is enabled, they will now show up in the overview page and search.\n\n### Documentation\n\n- Learn how to [limit concurrency in your data pipelines](https://docs.dagster.io/guides/limiting-concurrency-in-data-pipelines) with our new guide!\n- Need some help managing a run queue? Check out the new [customizing run queue priority guide](https://docs.dagster.io/guides/customizing-run-queue-priority).\n- New tutorial section that adds I/O managers to the tutorial project.\n\n# 1.2.6 (core) / 0.18.6 (libraries)\n\n### Bugfixes\n\n- Fixed a GraphQL resolution error which occurred when retrieving metadata for step failures in the event log.\n\n# 1.2.5 (core) / 0.18.5 (libraries)\n\n### New\n\n- `materialize` and `materialize_to_memory` now both accept a `selection` argument that allows specifying a subset of assets to materialize.\n- `MultiPartitionsDefinition` is no longer marked experimental.\n- Context methods to access time window partition information now work for `MultiPartitionsDefinition`s with a time dimension.\n- Improved the performance of the asset reconciliation sensor when a non-partitioned asset depends on a partitioned asset.\n- `load_assets_from_package_module` and similar methods now accept a `freshness_policy`, which will be applied to all loaded assets.\n- When the asset reconciliation sensor is scheduling based on freshness policies, and there are observable source assets, the observed versions now inform the data time of the assets.\n- `build_sensor_context` and `build_multi_asset_sensor_context` can now take a `Definitions` object in place of a `RepositoryDefinition`\n- [UI] Performance improvement for loading asset partition statuses.\n- [dagster-aws] `s3_resource` now accepts `use_ssl` and `verify` configurations.\n\n### Bugfixes\n\n- Fixed a bug that caused an error to be raised when passing a multi-asset into the `selection` argument on `define_asset_job`.\n- Fixes a graphQL error that displays on Dagit load when an asset’s partitions definition is change from a single-dimensional partitions definition to a `MultiPartitionsDefinition`.\n- Fixed a bug that caused backfills to fail when spanning assets that live in different code locations.\n- Fixed an error that displays when a code location with a `MultiPartitionsMapping` (experimental) is loaded.\n- Fixed a bug that caused errors with invalid `TimeWindowPartitionMapping`s to not be bubbled up to the UI.\n- Fixed an issue where the scheduler would sometimes incorrectly handle spring Daylight Savings Time transitions for schedules running at 2AM in a timezone other than UTC.\n- Fixed an issue introduced in the 1.2.4 release where running `pdb` stopped working when using dagster dev.\n- Fixed an issue where it is was possible to create `AssetMaterialization` objects with a null `AssetKey`.\n- Previously, if you had a `TimeWindowPartitionsDefinition` with a non-standard cron schedule, and also provided a `minute_of_hour` or similar argument in `build_schedule_from_partitioned_job`. Dagster would silently create the wrong cron expression. It now raises an error.\n- The asset reconciliation sensor now no longer fails when the event log contains materializations that contain partitions that aren’t contained in the asset’s `PartitionsDefinition`. These partitions are now ignored.\n- Fixed a regression that prevented materializing dynamically partitioned assets from the UI (thanks [@planvin](https://github.com/planvin)!)\n- [UI] On the asset graph, the asset health displayed in the sidebar for the selected asset updates as materializations and failures occur.\n- [UI] The asset partitions page has been adjusted to make materialization and observation event metadata more clear.\n- [UI] Large table schema metadata entries now display within a modal rather than taking up considerable space on the page.\n- [UI] Launching a backfill of a partitioned asset with unpartitioned assets immediately upstream no longer shows the “missing partitions” warning.\n- [dagster-airflow] fixed a bug in the `PersistentAirflowDatabase` where versions of airflow from 2.0.0 till 2.3.0 would not use the correct connection environment variable name.\n- [dagster-census] fixed a bug with the `poll_sync_run` function of`dagster-census` that prevented polling from working correctly (thanks [@ldincolasmay](https://github.com/ldnicolasmay)!)\n\n### Deprecations\n\n- The `run_request_for_partition` method on `JobDefinition` and `UnresolvedAssetJobDefinition` is now deprecated and will be removed in 2.0.0. Instead, directly instantiate a run request with a partition key via `RunRequest(partition_key=...)`.\n\n### Documentation\n\n- Added a missing link to next tutorial section (Thanks Mike Kutzma!)\n\n# 1.2.4 (core) / 0.18.4 (libraries)\n\n### New\n\n- Further performance improvements to the asset reconciliation sensor.\n- Performance improvements to asset backfills with large numbers of partitions.\n- New `AssetsDefinition.to_source_assets` to method convert a set of assets to `SourceAsset` objects.\n- (experimental) Added partition mapping that defines dependency relationships between different `MultiPartitionsDefinitions`.\n- [dagster-mlflow] Removed the `mlflow` pin from the `dagster-mlflow` package.\n- [ui] Syntax highlighting now supported in rendered markdown code blocks (from metadata).\n\n### Bugfixes\n\n- When using `build_asset_reconciliation_sensor`, in some cases duplicate runs could be produced for the same partition of an asset. This has been fixed.\n- When using Pythonic configuration for resources, aliased field names would cause an error. This has been fixed.\n- Fixed an issue where `context.asset_partitions_time_window_for_output` threw an error when an asset was directly invoked with `build_op_context`.\n- [dagster-dbt] In some cases, use of ephemeral dbt models could cause the dagster representation of the dbt dependency graph to become incorrect. This has been fixed.\n- [celery-k8s] Fixed a bug that caused JSON deserialization errors when an Op or Asset emitted JSON that doesn't represent a `DagsterEvent`.\n- Fixed an issue where launching a large backfill while running `dagster dev` would sometimes fail with a connection error after running for a few minutes.\n- Fixed an issue where `dagster dev` would sometimes hang when running Dagster code that attempted to read in input via stdin.\n- Fixed an issue where runs that take a long time to import code would sometimes continue running even after they were stopped by [run monitoring](https://docs.dagster.io/deployment/run-monitoring#run-monitoring) for taking too long to start.\n- Fixed an issue where `AssetSelection.groups()` would simultaneously select both source and regular assets and consequently raise an error.\n- Fixed an issue where `BindResourcesToJobs` would raise errors encapsulating jobs which had config specified at definition-time.\n- Fixed Pythonic config objects erroring when omitting optional values rather than specifying `None`.\n- Fixed Pythonic config and resources not supporting Enum values.\n- `DagsterInstance.local_temp` and `DagsterInstance.ephemeral` now use object instance scoped local artifact storage temporary directories instead of a shared process scoped one, removing a class of thread safety errors that could manifest on initialization.\n- Improved direct invocation behavior for ops and assets which specify resource dependencies as parameters, for instance:\n\n  ```python\n  class MyResource(ConfigurableResource):\n      pass\n\n  @op\n  def my_op(x: int, y: int, my_resource: MyResource) -> int:\n      return x + y\n\n  my_op(4, 5, my_resource=MyResource())\n  ```\n\n- [dagster-azure] Fixed an issue with an AttributeError being thrown when using the async `DefaultAzureCredential` (thanks [@mpicard](https://github.com/mpicard))\n- [ui] Fixed an issue introduced in 1.2.3 in which no log levels were selected by default when viewing Run logs, which made it appear as if there were no logs at all.\n\n### Deprecations\n\n- The `environment_vars` argument to `ScheduleDefinition` is deprecated (the argument is currently non-functional; environment variables no longer need to be whitelisted for schedules)\n\n### Community Contributions\n\n- Typos fixed in [CHANGES.md](http://CHANGES.md) (thanks [@fridiculous](https://github.com/fridiculous))\n- Links to telemetry docs fixed (thanks [@Abbe98](https://github.com/Abbe98))\n- `--path-prefix` can now be supplied via Helm chart (thanks [@mpicard](https://github.com/mpicard))\n\n### Documentation\n\n- New machine learning pipeline with Dagster guide\n- New example of multi-asset conditional materialization\n- New tutorial section about scheduling\n- New images on the Dagster README\n\n# 1.2.3 (core) / 0.18.3 (libraries)\n\n### New\n\n- Jobs defined via `define_asset_job` now auto-infer their partitions definitions if not explicitly defined.\n- Observable source assets can now be run as part of a job via `define_asset_job`. This allows putting them on a schedule/sensor.\n- Added an `instance` property to the `HookContext` object that is passed into [Op Hook](https://docs.dagster.io/concepts/ops-jobs-graphs/op-hooks#op-hooks) functions, which can be used to access the current `DagsterInstance` object for the hook.\n- (experimental) Dynamic partitions definitions can now exist as dimensions of multi-partitions definitions.\n- [dagster-pandas] New `create_table_schema_metadata_from_dataframe` function to generate a `TableSchemaMetadataValue` from a Pandas DataFrame. Thanks [@AndyBys](https://github.com/AndyBys)!\n- [dagster-airflow] New option for setting `dag_run` configuration on the integration’s database resources.\n- [ui] The asset partitions page now links to the most recent failed or in-progress run for the selected partition.\n- [ui] Asset descriptions have been moved to the top in the asset sidebar.\n- [ui] Log filter switches have been consolidated into a single control, and selected log levels will be persisted locally so that the same selections are used by default when viewing a run.\n- [ui] You can now customize the hour formatting in timestamp display: 12-hour, 24-hour, or automatic (based on your browser locale). This option can be found in User Settings.\n\n### Bugfixes\n\n- In certain situations a few of the first partitions displayed as “unpartitioned” in the health bar despite being materialized. This has now been fixed, but users may need to run `dagster asset wipe-partitions-status-cache` to see the partitions displayed.\n- Starting `1.1.18`, users with a gRPC server that could not access the Dagster instance on user code deployments would see an error when launching backfills as the instance could not instantiate. This has been fixed.\n- Previously, incorrect partition status counts would display for static partitions definitions with duplicate keys. This has been fixed.\n- In some situations, having SourceAssets could prevent the `build_asset_reconciliation_sensor` from kicking off runs of downstream assets. This has been fixed.\n- The `build_asset_reconciliation_sensor` is now much more performant in cases where unpartitioned assets are upstream or downstream of static-partitioned assets with a large number of partitions.\n- [dagster-airflow] Fixed an issue were the persistent Airflow DB resource required the user to set the correct Airflow database URI environment variable.\n- [dagster-celery-k8s] Fixed an issue where run monitoring failed when setting the `jobNamespace` field in the Dagster Helm chart when using the `CeleryK8sRunLauncher`.\n- [ui] Filtering on the asset partitions page no longer results in keys being presented out of order in the left sidebar in some scenarios.\n- [ui] Launching an asset backfill outside an asset job page now supports partition mapping, even if your selection shares a partition space.\n- [ui] In the run timeline, date/time display at the top of the timeline was sometimes broken for users not using the `en-US` browser locale. This has been fixed.\n\n# 1.2.2 (core) / 0.18.2 (libraries)\n\n### New\n\n- Dagster is now tested on Python 3.11.\n- Users can now opt in to have resources provided to `Definitions` bind to their jobs. Opt in by wrapping your job definitions in `BindResourcesToJobs`. This will become the default behavior in the future.\n\n  ```python\n  @op(required_resource_keys={\"foo\"})\n  def my_op(context)\n      print(context.foo)\n\n  @job\n  def my_job():\n    my_op()\n\n  defs = Definitions(\n      jobs=BindResourcesToJobs([my_job])\n      resources={\"foo\": foo_resource}\n  ```\n\n- Added `dagster asset list` and `dagster asset materialize` commands to Dagster’s command line interface, for listing and materializing software-defined assets.\n- `build_schedule_from_partitioned_job` now accepts jobs partitioned with a `MultiPartitionsDefinition` that have a time-partitioned dimension.\n- Added `SpecificPartitionsPartitionMapping`, which allows an asset, or all partitions of an asset, to depend on a specific subset of the partitions in an upstream asset.\n- `load_asset_value` now supports `SourceAsset`s.\n- [ui] Ctrl+K has been added as a keyboard shortcut to open global search.\n- [ui] Most pages with search bars now sync the search filter to the URL, so it’s easier to bookmark views of interest.\n- [ui] In the run logs table, the timestamp column has been moved to the far left, which will hopefully allow for better visual alignment with op names and tags.\n- [dagster-dbt] A new `node_info_to_definition_metadata_fn` to `load_assets_from_dbt_project` and `load_assets_from_dbt_manifest` allows custom metadata to be attached to the asset definitions generated from these methods.\n- [dagster-celery-k8s] The Kubernetes namespace that runs using the `CeleryK8sRunLauncher` are launched in can now be configured by setting the `jobNamespace` field in the Dagster Helm chart under `celeryK8sRunLauncherConfig`.\n- [dagster-gcp] The BigQuery I/O manager now accepts `timeout` configuration. Currently, this configuration will only be applied when working with Pandas DataFrames, and will set the number of seconds to wait for a request before using a retry.\n- [dagster-gcp] [dagster-snowflake] [dagster-duckdb] The BigQuery, Snowflake, and DuckDB I/O managers now support self-dependent assets. When a partitioned asset depends on a prior partition of itself, the I/O managers will now load that partition as a DataFrame. For the first partition in the dependency sequence, an empty DataFrame will be returned.\n- [dagster-k8s] `k8s_job_op` now supports running Kubernetes jobs with more than one pod (Thanks @Taadas).\n\n### Bugfixes\n\n- Fixed a bug that causes backfill tags that users set in the UI to not be included on the backfill runs, when launching an asset backfill.\n- Fixed a bug that prevented resume from failure re-execution for jobs that contained assets and dynamic graphs.\n- Fixed an issue where the asset reconciliation sensor would issue run requests for assets that were targeted by an active asset backfill, resulting in duplicate runs.\n- Fixed an issue where the asset reconciliation sensor could issue runs more frequently than necessary for assets with FreshnessPolicies having intervals longer than 12 hours.\n- Fixed an issue where `AssetValueLoader.load_asset_value()` didn’t load transitive resource dependencies correctly.\n- Fixed an issue where constructing a `RunConfig` object with optional config arguments would lead to an error.\n- Fixed the type annotation on `ScheduleEvaluationContext.scheduled_execution_time` to not be `Optional`.\n- Fixed the type annotation on `OpExecutionContext.partition_time_window` \\*\\*\\*\\*(thanks @elben10).\n- `InputContext.upstream_output.log` is no longer `None` when loading a source asset.\n- [Pydantic type constraints](https://docs.pydantic.dev/usage/types/#constrained-types) are now supported by the [Pythonic config](https://docs.dagster.io/guides/dagster/pythonic-config) API.\n- An input resolution bug that occurred in certain conditions when composing graphs with same named ops has been fixed.\n- Invoking an op with collisions between positional args and keyword args now throws an exception.\n- `async def` ops are now invoked with `asyncio.run`.\n- `TimeWindowPartitionDefinition` now throws an error at definition time when passed an invalid cron schedule instead of at runtime.\n- [ui] Previously, using dynamic partitions with assets that required config would raise an error in the launchpad. This has been fixed.\n- [ui] The lineage tab loads faster and flickers less as you navigate between connected assets in the lineage graph\n- [ui] The config YAML editor no longer offers incorrect autcompletion context when you’re beginning a new indented line.\n- [ui] When viewing the asset details page for a source asset, the button in the top right correctly reads “Observe” instead of “Materialize”\n- [dagster-dbt] Previously, setting a `cron_schedule_timezone` inside of the config for a dbt model would not result in that property being set on the generated `FreshnessPolicy`. This has been fixed.\n- [dagster-gcp] Added a fallback download url for the `GCSComputeLogManager` when the session does not have permissions to generate signed urls.\n- [dagster-snowflake] In a previous release, functionality was added for the Snowflake I/O manager to attempt to create a schema if it did not already exist. This caused an issue when the schema already existed but the account did not have permission to create the schema. We now check if a schema exists before attempting to create it so that accounts with restricted permissions do not error, but schemas can still be created if they do not exist.\n\n### Breaking Changes\n\n- `validate_run_config` no longer accepts `pipeline_def` or `mode` arguments. These arguments refer to legacy concepts that were removed in Dagster 1.0, and since then there have been no valid values for them.\n\n### Experimental\n\n- Added experimental support for resource requirements in sensors and schedules. Resources can be specified using `required_resource_keys` and accessed through the context or specified as parameters:\n\n  ```python\n  @sensor(job=my_job, required_resource_keys={\"my_resource\"})\n  def my_sensor(context):\n      files_to_process = context.my_resource.get_files()\n  \t\t...\n\n  @sensor(job=my_job)\n  def my_sensor(context, my_resource: MyResource):\n      files_to_process = my_resource.get_files()\n  \t\t...\n  ```\n\n### Documentation\n\n- Added a page on asset selection syntax to the Concepts documentation.\n\n# 1.2.1 (core) / 0.18.1 (libraries)\n\n### Bugfixes\n\n- Fixed a bug with postgres storage where daemon heartbeats were failing on instances that had not been migrated with `dagster instance migrate` after upgrading to `1.2.0`.\n\n# 1.2.0 (core) / 0.18.0 (libraries)\n\n## **Major Changes since 1.1.0 (core) / 0.17.0 (libraries)**\n\n### Core\n\n- Added a new `dagster dev` command that can be used to run both Dagit and the Dagster daemon in the same process during local development. [[docs](https://docs.dagster.io/deployment/guides/running-locally)]\n- Config and Resources\n  - Introduced new Pydantic-based APIs to make defining and using [config](https://docs.dagster.io/guides/dagster/pythonic-config) and [resources](https://docs.dagster.io/guides/dagster/pythonic-resources) easier (experimental). [[Github discussion](https://github.com/dagster-io/dagster/discussions/12510)]\n- Repository > Definitions [[docs](https://docs.dagster.io/concepts/code-locations#definitions-versus-repositories)]\n- Declarative scheduling\n  - The asset reconciliation sensor is now 100x more performant in many situations, meaning that it can handle more assets and more partitions.\n  - You can now set **freshness policies on time-partitioned assets**.\n  - You can now hover over a stale asset to learn why that asset is considered stale.\n- Partitions\n  - `DynamicPartitionsDefinition` allows **partitioning assets dynamically** - you can add and remove partitions without reloading your definitions (experimental). [[docs](https://docs.dagster.io/concepts/partitions-schedules-sensors/partitions#dynamically-partitioned-assets)]\n  - The asset graph in the UI now displays the number of materialized, missing, and failed partitions for each partitioned asset.\n  - Asset partitions can now **depend on earlier time partitions of the same asset**. Backfills and the asset reconciliation sensor respect these dependencies when requesting runs [[example](https://github.com/dagster-io/dagster/discussions/11829)].\n  - `TimeWindowPartitionMapping` now accepts `start_offset` and `end_offset` arguments that allow specifying that time partitions depend on earlier or later time partitions of upstream assets [[docs](https://docs.dagster.io/_apidocs/partitions#dagster.TimeWindowPartitionMapping)].\n- Backfills\n  - Dagster now allows **backfills that target assets with different partitions**, such as a daily asset which rolls up into a weekly asset, as long as the root assets in the selection are partitioned in the same way.\n  - You can now choose to pass a **range of asset partitions to a single run** rather than launching a backfill with a run per partition [[instructions](https://github.com/dagster-io/dagster/discussions/11653)].\n\n### Integrations\n\n- **Weights and Biases** - A new integration `dagster-wandb` with [Weights & Biases](https://wandb.ai/site) allows you to orchestrate your MLOps pipelines and maintain ML assets with Dagster. [[docs](https://docs.dagster.io/_apidocs/libraries/dagster-wandb)]\n- **Snowflake + PySpark** - A new integration `dagster-snowflake-pyspark` allows you to store and load PySpark DataFrames as Snowflake tables using the `snowflake_pyspark_io_manager`. [[docs](https://docs.dagster.io/integrations/snowflake/reference#storing-and-loading-pyspark-dataframes-in-snowflake)]\n- **Google BigQuery** - A new BigQuery I/O manager and new integrations `dagster-gcp-pandas` and `dagster-gcp-pyspark` allow you to store and load Pandas and PySpark DataFrames as BigQuery tables using the `bigquery_pandas_io_manager` and `bigquery_pyspark_io_manager`. [[docs](https://docs.dagster.io/integrations/bigquery)]\n- **Airflow** The `dagster-airflow` integration library was bumped to 1.x.x, with that major bump the library has been refocused on enabling migration from Airflow to Dagster. Refer to the docs for an [in-depth migration guide](https://docs.dagster.io/integrations/airflow/migrating-to-dagster).\n- **Databricks -** Changes:\n  - Added op factories to create ops for running existing Databricks jobs (`create_databricks_run_now_op`), as well as submitting one-off Databricks jobs (`create_databricks_submit_run_op`).\n  - Added a [new Databricks guide](https://docs.dagster.io/master/integrations/databricks).\n  - The previous `create_databricks_job_op` op factory is now deprecated.\n\n### Docs\n\n- [Automating pipelines guide](https://docs.dagster.io/guides/dagster/automating-pipelines) - Check out the best practices for automating your Dagster data pipelines with this new guide. Learn when to use different Dagster tools, such as schedules and sensors, using this guide and its included cheatsheet.\n- [Structuring your Dagster project guide](https://docs.dagster.io/guides/dagster/recommended-project-structure) - Need some help structuring your Dagster project? Learn about our recommendations for getting started and scaling sustainably.\n- [Tutorial revamp](https://docs.dagster.io/tutorial) - Goodbye cereals and hello HackerNews! We’ve overhauled our intro to assets tutorial to not only focus on a more realistic example, but to touch on more Dagster concepts as you build your first end-to-end pipeline in Dagster. [Check it out here.](https://docs.dagster.io/tutorial)\n\nStay tuned, as this is only the first part of the overhaul. We’ll be adding more chapters - including automating materializations, using resources, using I/O managers, and more - in the next few weeks.\n\n## Since 1.1.21 (core) / 0.17.21 (libraries)\n\n### New\n\n- Freshness policies can now be assigned to assets constructed with `@graph_asset` and `@graph_multi_asset`.\n- The `project_fully_featured` example now uses the built in DuckDB and Snowflake I/O managers.\n- A new “failed” state on asset partitions makes it more clear which partitions did not materialize successfully. The number of failed partitions is shown on the asset graph and a new red state appears on asset health bars and status dots.\n- Hovering over “Stale” asset tags in the Dagster UI now explains why the annotated assets are stale. Reasons can include more recent upstream data, changes to code versions, and more.\n- [dagster-airflow] support for persisting airflow db state has been added with `make_persistent_airflow_db_resource` this enables support for Airflow features like pools and cross-dagrun state sharing. In particular retry-from-failure now works for jobs generated from Airflow DAGs.\n- [dagster-gcp-pandas] The `BigQueryPandasTypeHandler` now uses `google.bigquery.Client` methods `load_table_from_dataframe` and `query` rather than the `pandas_gbq` library to store and fetch DataFrames.\n- [dagster-k8s] The Dagster Helm chart now only overrides `args` instead of both `command` and `args` for user code deployments, allowing to include a custom ENTRYPOINT in your the Dockerfile that loads your code.\n- The `protobuf<4` pin in Dagster has been removed. Installing either protobuf 3 or protobuf 4 will both work with Dagster.\n- [dagster-fivetran] Added the ability to specify op_tags to build_fivetran_assets (thanks @Sedosa!)\n- `@graph_asset` and `@graph_multi_asset` now support passing metadata (thanks [@askvinni](https://github.com/askvinni))!\n\n### Bugfixes\n\n- Fixed a bug that caused descriptions supplied to `@graph_asset` and `@graph_multi_asset` to be ignored.\n- Fixed a bug that serialization errors occurred when using `TableRecord`.\n- Fixed an issue where partitions definitions passed to `@multi_asset` and other functions would register as type errors for mypy and other static analyzers.\n- [dagster-aws] Fixed an issue where the EcsRunLauncher failed to launch runs for Windows tasks.\n- [dagster-airflow] Fixed an issue where pendulum timezone strings for Airflow DAG `start_date` would not be converted correctly causing runs to fail.\n- [dagster-airbyte] Fixed an issue when attaching I/O managers to Airbyte assets would result in errors.\n- [dagster-fivetran] Fixed an issue when attaching I/O managers to Fivetran assets would result in errors.\n\n### Database migration\n\n- Optional database schema migrations, which can be run via `dagster instance migrate`:\n  - Improves Dagit performance by adding a database index which should speed up job run views.\n  - Enables dynamic partitions definitions by creating a database table to store partition keys. This feature is experimental and may require future migrations.\n  - Adds a primary key `id` column to the `kvs`, `daemon_heartbeats` and `instance_info` tables, enforcing that all tables have a primary key.\n\n### Breaking Changes\n\n- The minimum `grpcio` version supported by Dagster has been increased to 1.44.0 so that Dagster can support both `protobuf` 3 and `protobuf` 4. Similarly, the minimum `protobuf` version supported by Dagster has been increased to 3.20.0. We are working closely with the gRPC team on resolving the upstream issues keeping the upper-bound `grpcio` pin in place in Dagster, and hope to be able to remove it very soon.\n- Prior to 0.9.19, asset keys were serialized in a legacy format. This release removes support for querying asset events serialized with this legacy format. Contact #dagster-support for tooling to migrate legacy events to the supported version. Users who began using assets after 0.9.19 will not be affected by this change.\n- [dagster-snowflake] The `execute_query`and `execute_queries` methods of the `SnowflakeResource` now have consistent behavior based on the values of the `fetch_results` and `use_pandas_result` parameters. If `fetch_results` is True, the standard Snowflake result will be returned. If `fetch_results` and `use_pandas_result` are True, a pandas DataFrame will be returned. If `fetch_results` is False and `use_pandas_result` is True, an error will be raised. If both are False, no result will be returned.\n- [dagster-snowflake] The `execute_queries` command now returns a list of DataFrames when `use_pandas_result` is True, rather than appending the results of each query to a single DataFrame.\n- [dagster-shell] The default behavior of the `execute` and `execute_shell_command` functions is now to include any environment variables in the calling op. To restore the previous behavior, you can pass in `env={}` to these functions.\n- [dagster-k8s] Several Dagster features that were previously disabled by default in the Dagster Helm chart are now enabled by default. These features are:\n\n  - The [run queue](https://docs.dagster.io/deployment/run-coordinator#limiting-run-concurrency) (by default, without a limit). Runs will now always be launched from the Daemon.\n  - Run queue parallelism - by default, up to 4 runs can now be pulled off of the queue at a time (as long as the global run limit or tag-based concurrency limits are not exceeded).\n  - [Run retries](https://docs.dagster.io/deployment/run-retries#run-retries) - runs will now retry if they have the `dagster/max_retries` tag set. You can configure a global number of retries in the Helm chart by setting `run_retries.max_retries` to a value greater than the default of 0.\n  - Schedule and sensor parallelism - by default, the daemon will now run up to 4 sensors and up to 4 schedules in parallel.\n  - [Run monitoring](https://docs.dagster.io/deployment/run-monitoring) - Dagster will detect hanging runs and move them into a FAILURE state for you (or start a retry for you if the run is configured to allow retries). By default, runs that have been in STARTING for more than 5 minutes will be assumed to be hanging and will be terminated.\n\n  Each of these features can be disabled in the Helm chart to restore the previous behavior.\n\n- [dagster-k8s] The experimental [`k8s_job_op`](https://docs.dagster.io/_apidocs/libraries/dagster-k8s#dagster_k8s.k8s_job_op) op and [`execute_k8s_job`](https://docs.dagster.io/_apidocs/libraries/dagster-k8s#dagster_k8s.execute_k8s_job) functions no longer automatically include configuration from a `dagster-k8s/config` tag on the Dagster job in the launched Kubernetes job. To include raw Kubernetes configuration in a `k8s_job_op`, you can set the `container_config`, `pod_template_spec_metadata`, `pod_spec_config`, or `job_metadata` config fields on the `k8s_job_op` (or arguments to the `execute_k8s_job` function).\n- [dagster-databricks] The integration has now been refactored to support the official Databricks API.\n  - `create_databricks_job_op` is now deprecated. To submit one-off runs of Databricks tasks, you must now use the `create_databricks_submit_run_op`.\n  - The Databricks token that is passed to the `databricks_client` resource must now begin with `https://`.\n\n#### Changes to experimental APIs\n\n- [experimental] `LogicalVersion` has been renamed to `DataVersion` and `LogicalVersionProvenance` has been renamed to `DataProvenance`.\n- [experimental] Methods on the experimental `DynamicPartitionsDefinition` to add, remove, and check for existence of partitions have been removed. Refer to documentation for updated API methods.\n\n#### Removal of deprecated APIs\n\n- [previously deprecated, 0.15.0] Static constructors on `MetadataEntry` have been removed.\n- [previously deprecated, 1.0.0] `DagsterTypeMaterializer`, `DagsterTypeMaterializerContext`, and `@dagster_type_materializer` have been removed.\n- [previously deprecated, 1.0.0] `PartitionScheduleDefinition` has been removed.\n- [previously deprecated, 1.0.0] `RunRecord.pipeline_run` has been removed (use `RunRecord.dagster_run`).\n- [previously deprecated, 1.0.0] `DependencyDefinition.solid` has been removed (use `DependencyDefinition.node`).\n- [previously deprecated, 1.0.0] The `pipeline_run` argument to `build_resources` has been removed (use `dagster_run`)\n\n### Community Contributions\n\n- Deprecated `iteritems` usage was removed and changed to the recommended `items` within `dagster-snowflake-pandas` (thanks [@sethkimmel3](https://github.com/sethkimmel3))!\n- Refactor to simply the new `@asset_graph` decorator (thanks [@simonvanderveldt](https://github.com/simonvanderveldt))!\n\n### Experimental\n\n- User-computed `DataVersions` can now be returned on `Output`\n- Asset provenance info can be accessed via `OpExecutionContext.get_asset_provenance`\n\n### Documentation\n\n- The [Asset Versioning and Caching Guide](https://docs.dagster.io/guides/dagster/asset-versioning-and-caching) now includes a section on user-provided data versions\n- The community contributions doc block `Picking a github issue` was not correctly rendering, this has been fixed (thanks [@Sedosa](https://github.com/Sedosa))!\n\n# 1.1.21 (core) / 0.17.21 (libraries)\n\n### New\n\n- Further performance improvements for `build_asset_reconciliation_sensor`.\n- Dagster now allows you to backfill asset selections that include mapped partition definitions, such as a daily asset which rolls up into a weekly asset, as long as the root assets in your selection share a partition definition.\n- Dagit now includes information about the cause of an asset’s staleness.\n- Improved the error message for non-matching cron schedules in `TimeWindowPartitionMapping`s with offsets. (Thanks Sean Han!)\n- [dagster-aws] The EcsRunLauncher now allows you to configure the `runtimePlatform` field for the task definitions of the runs that it launches, allowing it to launch runs using Windows Docker images.\n- [dagster-azure] Add support for DefaultAzureCredential for adls2_resource (Thanks Martin Picard!)\n- [dagster-databricks] Added op factories to create ops for running existing Databricks jobs (`create_databricks_run_now_op`), as well as submitting one-off Databricks jobs (`create_databricks_submit_run_op`). See the [new Databricks guide](https://docs.dagster.io/master/integrations/databricks) for more details.\n- [dagster-duckdb-polars] Added a dagster-duckdb-polars library that includes a `DuckDBPolarsTypeHandler` for use with `build_duckdb_io_manager`, which allows loading / storing Polars DataFrames from/to DuckDB. (Thanks Pezhman Zarabadi-Poor!)\n- [dagster-gcp-pyspark] New PySpark TypeHandler for the BigQuery I/O manager. Store and load your PySpark DataFrames in BigQuery using `bigquery_pyspark_io_manager`.\n- [dagster-snowflake] [dagster-duckdb] The Snowflake and DuckDB IO managers can now load multiple partitions in a single step - e.g. when a non-partitioned asset depends on a partitioned asset or a single partition of an asset depends on multiple partitions of an upstream asset. Loading occurs using a single SQL query and returns a single `DataFrame`.\n- [dagster-k8s] The Helm chart now supports the full kubernetes env var spec for user code deployments. Example:\n\n  ```yaml\n  dagster-user-deployments:\n    deployments:\n      - name: my-code\n        env:\n          - name: FOO\n            valueFrom:\n              fieldFre:\n                fieldPath: metadata.uid\n  ```\n\n  If `includeConfigInLaunchedRuns` is enabled, these env vars will also be applied to the containers for launched runs.\n\n### Bugfixes\n\n- Previously, if an `AssetSelection` which matched no assets was passed into `define_asset_job`, the resulting job would target all assets in the repository. This has been fixed.\n- Fixed a bug that caused the UI to show an error if you tried to preview a future schedule tick for a schedule built using `build_schedule_from_partitioned_job`.\n- When a non-partitioned non-asset job has an input that comes from a partitioned SourceAsset, we now load all partitions of that asset.\n- Updated the `fs_io_manager` to store multipartitioned materializations in directory levels by dimension. This resolves a bug on windows where multipartitioned materializations could not be stored with the `fs_io_manager`.\n- Schedules and sensors previously timed out when attempting to yield many multipartitioned run requests. This has been fixed.\n- Fixed a bug where `context.partition_key` would raise an error when executing on a partition range within a single run via Dagit.\n- Fixed a bug that caused the default IO manager to incorrectly raise type errors in some situations with partitioned inputs.\n- [ui] Fixed a bug where partition health would fail to display for certain time window partitions definitions with positive offsets.\n- [ui] Always show the “Reload all” button on the code locations list page, to avoid an issue where the button was not available when adding a second location.\n- [ui] Fixed a bug where users running multiple replicas of dagit would see repeated `Definitions reloaded` messages on fresh page loads.\n- [ui] The asset graph now shows only the last path component of linked assets for better readability.\n- [ui] The op metadata panel now longer capitalizes metadata keys\n- [ui] The asset partitions page, asset sidebar and materialization dialog are significantly smoother when viewing assets with a large number of partitions (100k+)\n- [dagster-gcp-pandas] The Pandas TypeHandler for BigQuery now respects user provided `location` information.\n- [dagster-snowflake] `ProgrammingError` was imported from the wrong library, this has been fixed. Thanks @herbert-allium!\n\n### Experimental\n\n- You can now set an explicit logical version on `Output` objects rather than using Dagster’s auto-generated versions.\n- New `get_asset_provenance` method on `OpExecutionContext` allows fetching logical version provenance for an arbitrary asset key.\n- [ui] - you can now create dynamic partitions from the partition selection UI when materializing a dynamically partitioned asset\n\n### Documentation\n\n- Added an example of how to use dynamic asset partitions - in the `examples/assets_dynamic_partitions` folder\n- New [tutorial](https://docs.dagster.io/master/integrations/bigquery/using-bigquery-with-dagster) for using the BigQuery I/O manager.\n- New [reference page](https://docs.dagster.io/master/integrations/bigquery/reference) for BigQuery I/O manager features.\n- New [automating data pipelines guide](https://legacy-versioned-docs.dagster.dagster-docs.io/1.1.21/guides/dagster/automated_pipelines)\n\n# 1.1.20 (core) / 0.17.20 (libraries)\n\n### New\n\n- The new `@graph_asset` and `@graph_multi_asset` decorators make it more ergonomic to define graph-backed assets.\n- Dagster will auto-infer dependency relationships between single-dimensionally partitioned assets and multipartitioned assets, when the single-dimensional partitions definition is a dimension of the `MultiPartitionsDefinition`.\n- A new `Test sensor` / `Test schedule` button that allows you to perform a dry-run of your sensor / schedule. Check out the docs on this functionality [here](https://docs.dagster.io/master/concepts/partitions-schedules-sensors/sensors#via-dagit) for sensors and [here](https://docs.dagster.io/master/concepts/partitions-schedules-sensors/sensors#via-dagit) for schedules.\n- [dagit] Added (back) tag autocompletion in the runs filter, now with improved query performance.\n- [dagit] The Dagster libraries and their versions that were used when loading definitions can now be viewed in the actions menu for each code location.\n- New `bigquery_pandas_io_manager` can store and load Pandas dataframes in BigQuery.\n- [dagster-snowflake, dagster-duckdb] SnowflakeIOManagers and DuckDBIOManagers can now default to loading inputs as a specified type if a type annotation does not exist for the input.\n- [dagster-dbt] Added the ability to use the “state:” selector\n- [dagster-k8s] The Helm chart now supports the full kubernetes env var spec for Dagit and the Daemon. E.g.\n\n  ```yaml\n  dagit:\n    env:\n      - name: “FOO”\n        valueFrom:\n          fieldRef:\n            fieldPath: metadata.uid\n  ```\n\n### Bugfixes\n\n- Previously, graphs would fail to resolve an input with a custom type and an input manager key. This has been fixed.\n- Fixes a bug where negative partition counts were displayed in the asset graph.\n- Previously, when an asset sensor did not yield run requests, it returned an empty result. This has been updated to yield a meaningful message.\n- Fix an issue with a non-partitioned asset downstream of a partitioned asset with self-dependencies causing a GQL error in dagit.\n- [dagster-snowflake-pyspark] Fixed a bug where the PySparkTypeHandler was incorrectly loading partitioned data.\n- [dagster-k8s] Fixed an issue where [run monitoring](https://docs.dagster.io/deployment/run-monitoring#run-monitoring) sometimes failed to detect that the kubernetes job for a run had stopped, leaving the run hanging.\n\n### Documentation\n\n- Updated contributor docs to reference our new toolchain (`ruff`, `pyright`).\n- (experimental) Documentation for the dynamic partitions definition is now added.\n- [dagster-snowflake] The Snowflake I/O Manager reference page now includes information on working with partitioned assets.\n\n# 1.1.19 (core) / 0.17.19 (libraries)\n\n### New\n\n- The `FreshnessPolicy` object now supports a `cron_schedule_timezone` argument.\n- `AssetsDefinition.from_graph` now supports a `freshness_policies_by_output_name` parameter.\n- The `@asset_sensor` will now display an informative `SkipReason` when no new materializations have been created since the last sensor tick.\n- `AssetsDefinition` now has a `to_source_asset` method, which returns a representation of this asset as a `SourceAsset`.\n- You can now designate assets as inputs to ops within a graph or graph-based job. E.g.\n\n```python\nfrom dagster import asset, job, op\n\n@asset\ndef emails_to_send():\n    ...\n\n@op\ndef send_emails(emails) -> None:\n    ...\n\n@job\ndef send_emails_job():\n    send_emails(emails_to_send.to_source_asset())\n```\n\n- Added a `--dagit-host/-h` argument to the `dagster dev` command to allow customization of the host where Dagit runs.\n- [dagster-snowflake, dagster-duckdb] Database I/O managers (Snowflake, DuckDB) now support static partitions, multi-partitions, and dynamic partitions.\n\n### Bugfixes\n\n- Previously, if a description was provided for an op that backed a multi-asset, the op’s description would override the descriptions in Dagit for the individual assets. This has been fixed.\n- Sometimes, when applying an `input_manager_key` to an asset’s input, incorrect resource config could be used when loading that input. This has been fixed.\n- Previously, the backfill page errored when partitions definitions changed for assets that had been backfilled. This has been fixed.\n- When displaying materialized partitions for multipartitioned assets, Dagit would error if a dimension had zero partitions. This has been fixed.\n- [dagster-k8s] Fixed an issue where setting `runK8sConfig` in the Dagster Helm chart would not pass configuration through to pods launched using the `k8s_job_executor`.\n- [dagster-k8s] Previously, using the `execute_k8s_job` op downstream of a dynamic output would result in k8s jobs with duplicate names being created. This has been fixed.\n- [dagster-snowflake] Previously, if the schema for storing outputs didn’t exist, the Snowflake I/O manager would fail. Now it creates the schema.\n\n### Breaking Changes\n\n- Removed the experimental, undocumented `asset_key`, `asset_partitions`, and `asset_partitions_defs` arguments on `Out`.\n- `@multi_asset` no longer accepts `Out` values in the dictionary passed to its `outs` argument. This was experimental and deprecated. Instead, use `AssetOut`.\n- The experimental, undocumented `top_level_resources` argument to the `repository` decorator has been renamed to `_top_level_resources` to emphasize that it should not be set manually.\n\n### Community Contributions\n\n- `load_asset_values` now accepts resource configuration (thanks @Nintorac!)\n- Previously, when using the `UPathIOManager`, paths with the `\".\"` character in them would be incorrectly truncated, which could result in multiple distinct objects being written to the same path. This has been fixed. (Thanks @spenczar!)\n\n### Experimental\n\n- [dagster-dbt] Added documentation to our dbt Cloud integration to cache the loading of software-defined assets from a dbt Cloud job.\n\n### Documentation\n\n- Revamped the introduction to the Partitions concepts page to make it clear that non-time-window partitions are equally encouraged.\n- In Navigation, moved the Partitions and Backfill concept pages to their own section underneath Concepts.\n- Moved the Running Dagster locally guide from **Deployment** to **Guides** to reflect that OSS and Cloud users can follow it.\n- Added [a new guide](https://docs.dagster.io/guides/dagster/asset-versioning-and-caching) covering asset versioning and caching.\n\n# 1.1.18 (core) / 0.17.18 (libraries)\n\n### New\n\n- Assets with time-window `PartitionsDefinition`s (e.g. `HourlyPartitionsDefinition`, `DailyPartitionsDefinition`) may now have a `FreshnessPolicy`.\n- [dagster-dbt] When using `load_assets_from_dbt_project` or `load_assets_from_dbt_manifest` with `dbt-core>=1.4`, `AssetMaterialization` events will be emitted as the dbt command executes, rather than waiting for dbt to complete before emitting events.\n- [dagster-aws] When [run monitoring](https://docs.dagster.io/deployment/run-monitoring#run-monitoring) detects that a run unexpectedly crashed or failed to start, an error message in the run’s event log will include log messages from the ECS task for that run to help diagnose the cause of the failure.\n- [dagster-airflow] added `make_ephemeral_airflow_db_resource` which returns a `ResourceDefinition` for a local only airflow database for use in migrated airflow DAGs\n- Made some performance improvements for job run queries which can be applied by running `dagster instance migrate`.\n- [dagit] System tags (code + logical versions) are now shown in the asset sidebar and on the asset details page.\n- [dagit] Source assets that have never been observed are presented more clearly on the asset graph.\n- [dagit] The number of materialized and missing partitions are shown on the asset graph and in the asset catalog for partitioned assets.\n- [dagit] Databricks-backed assets are now shown on the asset graph with a small “Databricks” logo.\n\n### Bugfixes\n\n- Fixed a bug where materializations of part of the asset graph did not construct required resource keys correctly.\n- Fixed an issue where `observable_source_asset` incorrectly required its function to have a `context` argument.\n- Fixed an issue with serialization of freshness policies, which affected cacheable assets that included these policies such as those from `dagster-airbyte`\n- [dagster-dbt] Previously, the `dagster-dbt` integration was incompatible with `dbt-core>=1.4`. This has been fixed.\n- [dagster-dbt] `load_assets_from_dbt_cloud_job` will now avoid unnecessarily generating docs when compiling a manifest for the job. Compile runs will no longer be kicked off for jobs not managed by this integration.\n- Previously for multipartitioned assets, `context.asset_partition_key` returned a string instead of a `MultiPartitionKey`. This has been fixed.\n- [dagster-k8s] Fixed an issue where pods launched by the `k8s_job_executor` would sometimes unexpectedly fail due to transient 401 errors in certain kubernetes clusters.\n- Fix a bug with nth-weekday-of-the-month handling in cron schedules.\n\n### Breaking Changes\n\n- [dagster-airflow] `load_assets_from_airflow_dag` no longer creates airflow db resource definitions, as a user you will need to provide them on `Definitions` directly\n\n### Deprecations\n\n- The `partitions_fn` argument of the `DynamicPartitionsDefinition` class is now deprecated and will be removed in 2.0.0.\n\n### Community Contributions\n\n- [dagster-wandb] A new integration with [Weights & Biases](https://wandb.ai/site) allows you to orchestrate your MLOps pipelines and maintain ML assets with Dagster.\n- Postgres has been updated to 14.6 for Dagster’s helm chart. Thanks [@DustyShap](https://github.com/DustyShap)!\n- Typo fixed in docs. Thanks [@C0DK](https://github.com/C0DK)!\n- You can now pass a callable directly to `asset` (rather than using `@asset` in decorator form) to create an asset. Thanks [@ns-finkelstein](https://github.com/nsfinkelstein)!\n\n### Documentation\n\n- New “Asset versioning and caching” guide\n- [dagster-snowflake] The Snowflake guide has been updated to include PySpark dataframes\n- [dagster-snowflake] The Snowflake guide has been updated to include private key authentication\n- [dagster-airflow] The Airflow migration guide has been update to include more detailed instructions and considerations for making a migration\n\n# 1.1.17 (core) / 0.17.17 (libraries)\n\n### New\n\n- The `dagster-airflow` library as been moved to 1.x.x to denote the stability of its api's going forward.\n- [dagster-airflow] `make_schedules_and_jobs_from_airflow_dag_bag` has been added to allow for more fine grained composition of your transformed airflow DAGs into Dagster.\n- [dagster-airflow] Airflow dag task `retries` and `retry_delay` configuration are now converted to op [RetryPolicies](https://docs.dagster.io/concepts/ops-jobs-graphs/op-retries#retrypolicy) with all `make_dagster_*` apis.\n\n### Bugfixes\n\n- Fixed an issue where cron schedules using a form like `0 5 * * mon#1` to execute on a certain day of the week each month executed every week instead.\n- [dagit] Fixed an issue where the asset lineage page sometimes timed out while loading large asset graphs.\n- Fixed an issue where the partitions page sometimes failed to load for partitioned asset jobs.\n\n### Breaking Changes\n\n- [dagster-airflow] The `use_airflow_template_context`, `mock_xcom` and `use_ephemeral_airflow_db` params have been dropped, by default all `make_dagster_*` apis now use a run-scoped airflow db, similiar to how `use_ephemeral_airflow_db` worked.\n- [dagster-airflow] `make_airflow_dag` has been removed.\n- [dagster-airflow] `make_airflow_dag_for_operator` has been removed.\n- [dagster-airflow] `make_airflow_dag_containerized` has been removed.\n- [dagster-airflow] `airflow_operator_to_op` has been removed.\n- [dagster-airflow] `make_dagster_repo_from_airflow_dags_path` has been removed.\n- [dagster-airflow] `make_dagster_repo_from_airflow_dag_bag` has been removed.\n- [dagster-airflow] `make_dagster_repo_from_airflow_example_dags` has been removed.\n- [dagster-airflow] The naming convention for ops generated from airflow tasks has been changed to `${dag_id}__${task_id}` from `airflow_${task_id}_${unique_int}`.\n- [dagster-airflow] The naming convention for jobs generated from airflow dags has been changed to `${dag_id}` from `airflow_${dag_id}`.\n\n# 1.1.15 (core) / 0.17.15 (libraries)\n\n### New\n\n- Definitions now accepts Executor instances in its executor argument, not just ExecutorDefinitions.\n- `@multi_asset_sensor` now accepts a `request_assets` parameter, which allows it to directly request that assets be materialized, instead of requesting a run of a job.\n- Improved the performance of instantiating a `Definitions` when using large numbers of assets or many asset jobs.\n- The job passed to `build_schedule_from_partitioned_job` no longer needs to have a `partitions_def` directly assigned to it. Instead, Dagster will infer from the partitions from the assets it targets.\n- `OpExecutionContext.asset_partition_keys_for_output` no longer requires an argument to specify the default output.\n- The “Reload all” button on the Code Locations page in Dagit will now detect changes to a `pyproject.toml` file that were made while Dagit was running. Previously, Dagit needed to be restarted in order for such changes to be shown.\n- `get_run_record_by_id` has been added to `DagsterInstance` to provide easier access to `RunRecord` objects which expose the `start_time` and `end_time` of the run.\n- [dagit] In the “Materialize” modal, you can now choose to pass a range of asset partitions to a single run rather than launching a backfill.\n- [dagster-docker] Added a `docker_container_op` op and `execute_docker_container_op` helper function for running ops that launch arbitrary Docker containers. See [the docs](https://docs.dagster.io/_apidocs/libraries/dagster-docker#ops) for more information.\n- [dagster-snowflake-pyspark] The Snowflake I/O manager now supports PySpark DataFrames.\n- [dagster-k8s] The Docker images include in the Dagster Helm chart are now built on the most recently released `python:3.x-slim` base image.\n\n### Bugfixes\n\n- Previously, the `build_asset_reconciliation_sensor` could time out when evaluating ticks over large selections of assets, or assets with many partitions. A series of performance improvements should make this much less likely.\n- Fixed a bug that caused a failure when using `run_request_for_partition` in a sensor that targeted multiple jobs created via `define_asset_job`.\n- The cost of importing `dagster` has been reduced.\n- Issues preventing “re-execute from failure” from working correctly with dynamic graphs have been fixed.\n- [dagit] In Firefox, Dagit no longer truncates text unnecessarily in some cases.\n- [dagit] Dagit’s asset graph now allows you to click “Materialize” without rendering the graph if you have too many assets to display.\n- [dagit] Fixed a bug that stopped the backfill page from loading when assets that had previously been backfilled no longer had a `PartitionsDefinition`.\n- [dagster-k8s] Fixed an issue where `k8s_job_op` raised an Exception when running pods with multiple containers.\n- [dagster-airbyte] Loosened credentials masking for Airbyte managed ingestion, fixing the Hubspot source, thanks @[joel-olazagasti](https://github.com/joel-olazagasti)!\n- [dagster-airbyte] When using managed ingestion, Airbyte now pulls all source types available to the instance rather than the workspace, thanks @[emilija-omnisend](https://github.com/emilija-omnisend)!\n- [dagster-airbyte] Fixed an issue which arose when attaching freshness policies to Airbyte assets and using the multiprocessing executor.\n- [dagster-fivetran] Added the ability to force assets to be output for all specified Fivetran tables during a sync in the case that a sync’s API outputs are missing one or more tables.\n\n### Breaking Changes\n\n- The `asset_keys` and `asset_selection` parameters of the experimental `@multi_asset_sensor` decorator have been replaced with a `monitored_assets` parameter. This helps disambiguate them from the new `request_assets` parameter.\n\n### Community Contributions\n\n- A broken docs link in snowflake_quickstart has been fixed, thanks @[clayheaton](https://github.com/clayheaton)!\n- Troubleshooting help added to helm deployment guide, thanks @adam-bloom!\n- `StaticPartitionMapping` is now serializable, thanks @[AlexanderVR](https://github.com/AlexanderVR)!\n- [dagster-fivetran] `build_fivetran_assets` now supports `group_name` , thanks @[toddy86](https://github.com/toddy86)!\n- [dagster-azure] `AzureBlobComputeManager` now supports authentication via `DefaultAzureCredential`, thanks @[mpicard](https://github.com/mpicard)!\n\n### Experimental\n\n- [dagster-airflow] added a new api `load_assets_from_airflow_dag` that creates graph-backed, partitioned, assets based on the provided Airflow DAG.\n\n# 1.1.14 (core) / 0.17.14 (libraries)\n\n### New\n\n- Large asset graphs can now be materialized in Dagit without needing to first enter an asset subset. Previously, if you wanted to materialize every asset in such a graph, you needed to first enter `*` as the asset selection before materializing the assets.\n- Added a pin of the `sqlalchemy` package to `<2.0.0` due to a breaking change in that version.\n- Added a pin of the `dbt-core` package to `<1.4.0` due to breaking changes in that release that affected the Dagster dbt integration. We plan to remove this pin in the next release.\n- Added a pin of the `jupyter-client` package to `<8.0` due to an issue with the most recent release causing hangs while running dagstermill ops.\n\n### Bugfixes\n\n- Fixed an issue where the Backfills page in Dagit didn't show partition status for some backfills.\n- [dagster-aws] Fixed an issue where the `EcsRunLauncher` sometimes waited much longer than intended before retrying after a failure launching a run.\n- [dagster-mysql] Fixed an issue where some implementations of MySQL storage were raising invalid version errors.\n\n# 1.1.13 (core) / 0.17.13 (libraries)\n\n### Bugfixes\n\n- The `nux` section of `dagster.yaml` config has been fixed.\n- Changes when heartbeats occur in the daemon to avoid crashes in certain conditions.\n- Fixed an issue where passing a workspace file as an argument into the `dagster dev` command raised an error\n- [dagit] Fixes an issue with asset names being truncated by long asset descriptions in the asset catalog, making them impossible to click.\n- [dagit] The backfill page no longer fails to load if any of the asset backfills had assets that were partitioned at the time of the backfill but are no longer partitioned.\n\n# 1.1.12 (core) / 0.17.12 (libraries)\n\n### Bugfixes\n\n- [dagit] Fixes a \"maximum call stack size exceeded\" error when viewing a materialization of a root asset in Asset Details\n\n# 1.1.11 (core) / 0.17.11 (libraries)\n\n### New\n\n- Added a new `dagster dev` command that can be used to run both Dagit and the Dagster daemon in the same process during local development. See the new [Running Dagster Locally guide](https://docs.dagster.io/deployment/guides/running-locally) in the docs for more information.\n- Added instructions for installing the `dagster` package on M1 and M2 Macs that avoids installation errors when building the `grpcio` package. See [the Installing Dagster guide in the docs](https://docs.dagster.io/getting-started/install) for more information.\n- `create_repository_using_definitions_args` has been added for users to backport their repository definitions to the new `Definitions` API\n- When running Dagit on your local machine, a prompt will now appear that allows you to optionally enter an email address to receive Dagster security updates or subscribe to the Dagster newsletter. This prompt can be dismissed in the UI, or permanently disabled by adding the following to your `dagster.yaml` file:\n\n```\nnux:\n  enabled: false\n```\n\n- The `grpcio` pin in Dagster to <1.48.1 has been restored for Python versions 3.10 and 3.11, due to [upstream issues](https://github.com/grpc/grpc/issues/31885) in the grpcio package causing hangs in Dagster.\n- [dagit] Improved query performance on Scheduled Runs page.\n- [dagit] The \"Materialize\" button now allows you to add tags to asset materialization runs. If your assets do not require config or partitions, you may need to shift-click \"Materialize\".\n- [dagit] The kind tags and logos shown on assets in the Asset Graph now appear in other parts of Dagit so it's easier to understand your assets.\n- [dagit] Selecting a materialization event on the Asset Details page now shows links to the upstream materialzations (\"Source Data\") that were incorporated into that version of the asset.\n- [dagit] Added or improved document (browser tab) titles throughout Dagit.\n- [dagster-snowflake] Snowflake resource and IO manager now support private key authentication with unencrypted keys\n- [dagster-dbt] The op created when using `load_assets_from_dbt*` is now configurable, allowing you to pass in specific parameters to the underlying dbt command (such as `--full-refresh`). To do so, supply config of the form `{\"ops\": {\"run_dbt_<abcde>\": {\"config\": {\"full_refresh\": True}}}}` when defining your asset job, or in Dagit.\n\n### Bugfixes\n\n- For time-partitioned assets, the `build_asset_reconciliation_sensor` will now only materialize partitions from the past day. Previously, if a new asset was added with a large number of missing partitions, a run for each of the missing partitions would be launched immediately.\n- A variety of performance improvements to the `build_asset_reconciliation_sensor`, which should help significantly speed up sensor evaluation in cases where there is a large number of assets or partitions.\n- [dagit] Fixed broken code location names in the “Definitions” filter dialog accessible from the left navigation.\n- [dagit] The Backfills pages in Dagit no longer crash when your backfills span tens of thousands of partition keys\n- [dagit] The asset graph now links to the failed run, not the last successful materialization, when assets are shown in a \"Failed\" state.\n\n### Breaking Changes\n\n- Strings with escaped characters are now invalid substrings of partition keys.\n\n### Experimental\n\n- [dagster-dbt] Added a utility to cache compilations from dbt Cloud jobs, allowing software-defined assets to be loaded faster from dbt Cloud jobs.\n\n### Community Contributions\n\n- In dagster-airbyte, keys containing credentials are now considered a secret (thanks [joel-olazagasti](https://github.com/joel-olazagasti))!\n\n### Documentation\n\n- A new example of using the branching IO manager has been added.\n\n# 1.1.10 (core) / 0.17.10 (libraries)\n\n### New\n\n- The `selection` argument of `define_asset_job` now accepts lists of `AssetKey`s or `AssetsDefinitions`.\n- `RunRequest` now takes a `stale_assets_only` flag that filters the full set of assets that would be materialized by a job to stale assets only. This can be used in schedules and sensors.\n- Dagit will now choose a different open port on the local machine to run on when no port is specified to the `dagit` command and the default port 3000 is already in use.\n- The `grpcio` pin in Dagster to <1.48.1 has been removed for Python versions 3.10 and 3.11. Python 3.7, 3.8, and 3.9 are still pinned to <1.48.1 due to a bug in the grpc library that is causing the process to sometimes hang.\n- When it is likely that an op process was killed due to running out of memory, a clearer error message is now displayed in Dagit.\n- When a sensor tick fails due to taking longer than 60 seconds to execute, a clearer error message is displayed on the sensor timeline in Dagit.\n- When you view compute logs on a run in Dagit, we now locally track whether you choose the `stdout` or `stderr` tab. The next time you view compute logs, you will see that tab first by default.\n- The `executor` and `loggers` arguments on `Definitions` are no longer experimental.\n- [dagster-dbt] When `json_log_format` is set to `False` when using the `dbt_cli_resource`, logs will be emitted at the appropriate log level in some situations. Previously, all logs would be emitted at the `INFO` level.\n- [dagster-snowflake] The Snowflake IO Manager and Snowflake Resource now support private key authentication. Thanks Josh Taylor!\n- [dagster-airbyte] Users can now specify freshness policies when generating Airbyte assets.\n- [dagster-airbyte] When using managed Airbyte ingestion, users can now specify a destination table prefix.\n\n### Bugfixes\n\n- Fixed a bug that caused backfills launched from the asset graph page not to work with code locations running versions of Dagster less than 1.1.8.\n- Fixed a bug that reverted to the default partition mappings in situations where asset dependencies were resolved based on group instead of asset key.\n- The way skips are propagate through the graph when using dynamic outputs are used has been fixed.\n- Fixed a bug affecting the download link for cloud-based compute log manager implementations (e.g. `dagster-azure` / `dagster-aws` / `dagster-gcp`)\n- Fixed a bug that would cause errors when using `build_asset_reconciliation_sensor` with asset graphs that contained references to source assets without the associated `SourceAsset` objects (which may happen when using `load_assets_from_dbt_*`).\n- [dagit] Fixed an issue where an error appeared in dagit when a code server stopped and restarted.\n- [dagit] Previously, when restarting the dagit process, the Dagit frontend kept cached versions of certain queries even after the code location finished loading. This could lead to display of stale versions of jobs or other code objects. These objects will now be correctly retrieved anew from the backend.\n- [dagster-dbt] Fixed a bug with the `DbtManifestAssetSelection` which could result in `KeyErrors` when selecting from projects with sources defined.\n- [dagster-k8s] Fixed a bug where disabling run worker crash recovery by setting maxResumeRunAttempts to 0 in the Helm chart had no effect.\n- [dagster-airflow] Fixed a bug where transformed Airflow DAG schedules would always use UTC for their timezone.\n\n### Breaking Changes\n\n- [dagit] The `/instance` and `/workspace` path prefixes were removed in previous version, but redirects were left in place. These redirects have now been removed.\n\n### Community Contributions\n\n- The new `StaticPartitionMapping` enables explicitly defining the dependencies between partitions in two `StaticPartitionsDefinition`s. Thanks Alexander VR!\n- Fixed a typo in the Dagster Instance documentation header - thanks Cushnir Grigore!\n- Fixed a typo in the Dagster Instance documentation body - thanks Chris Zubak-Skees!\n- Fixed docstring for static_partitioned_config - thanks Sylvain Lesage!\n- Fix dead link in the docs to the Slack community - thanks Emil Christensen!\n\n### Documentation\n\n- The [Ops and jobs tutorial](https://docs.dagster.io/master/guides/dagster/intro-to-ops-jobs) has been moved to the Guides section. Clicking \"Tutorial\" in the sidenav will open the Assets tutorial.\n\n# 1.1.9 (core) / 0.17.9 (libraries)\n\n### Bugfixes\n\n- Fixed an issue which would cause errors when using built-in generic types in annotations for asset and op parameters.\n- Fixed an unintentional dependency on Pydantic >=1.8 which lacked a pin, now older versions of the package may be used.\n\n# 1.1.8 (core) / 0.17.8 (libraries)\n\n### New\n\n- Asset backfills launched from the asset graph now respect partition mappings. For example, if partition N of asset2 depends on partition N-1 of asset1, and both of those partitions are included in a backfill, asset2’s partition N won’t be backfilled until asset1’s partition N-1 has been materialized.\n- Asset backfills launched from the asset graph will now only materialize each non-partitioned asset once - after all upstream partitions within the backfill have been materialized.\n- Executors can now be configured with a `tag_concurrency_limits` key that allows you to specify limits on the number of ops with certain tags that can be executing at once within a single run. See the [docs](https://docs.dagster.io/concepts/ops-jobs-graphs/job-execution#op-concurrency-limits) for more information.\n- `ExecuteInProcessResult`, the type returned by `materialize`, `materialize_to_memory`, and `execute_in_process`, now has an `asset_value` method that allows you to fetch output values by asset key.\n- `AssetIn`s can now accept `Nothing` for their `dagster_type`, which allows omitting the input from the parameters of the `@asset`- or `@multi_asset`- decorated function. This is useful when you want to specify a partition mapping or metadata for a non-managed input.\n- The `start_offset` and `end_offset` arguments of `TimeWindowPartitionMapping` now work across `TimeWindowPartitionsDefinitions` with different start dates and times.\n- If `add_output_metadata` is called multiple times within an op, asset, or IO manager `handle_output`, the values will now be merged, instead of later dictionaries overwriting earlier ones.\n- `materialize` and `materialize_to_memory` now both accept a `tags` argument.\n- Added `SingleDimensionDependencyMapping`, a `PartitionMapping` object that defines a correspondence between an upstream single-dimensional partitions definition and a downstream `MultiPartitionsDefinition`.\n- The `RUN_DEQUEUED` event has been removed from the event log, since it was duplicative with the `RUN_STARTING` event.\n- When an Exception is raised during the execution of an op or asset, Dagit will now include the original Exception that was raised, even if it was caught and another Exception was raised instead. Previously, Dagit would only show exception chains if the Exception was included using the `raise Exception() from e` syntax.\n- [dagit] The Asset Catalog table in Dagit is now a virtualized infinite-scroll table. It is searchable and filterable just as before, and you can now choose assets for bulk materialization without having to select across pages.\n- [dagit] Restored some metadata to the Code Locations table, including image, python file, and module name.\n- [dagit] Viewing a partition on the asset details page now shows both the latest materialization and also all observations about that materialization.\n- [dagit] Improved performance of the loading time for the backfills page\n- [dagit] Improved performance when materializing assets with very large partition sets\n- [dagit] Moving around asset and op graphs while selecting nodes is easier - drag gestures no longer clear your selection.\n- [dagster-k8s] The Dagster Helm chart now allows you to set an arbitrary kubernetes config dictionary to be included in the launched job and pod for each run, using the `runK8sConfig` key in the `k8sRunLauncher` section. See the [docs](https://docs.dagster.io/deployment/guides/kubernetes/customizing-your-deployment#instance-level-kubernetes-configuration) for more information.\n- [dagster-k8s] `securityContext` can now be set in the `k8sRunLauncher` section of the Dagster Helm chart.\n- [dagster-aws] The `EcsRunLauncher` can now be configured with cpu and memory resources for each launched job. Previously, individual jobs needed to be tagged with CPU and memory resources. See the [docs](https://docs.dagster.io/master/deployment/guides/aws#customizing-cpu-and-memory-in-ecs) for more information.\n- [dagster-aws] The `S3ComputeLogManager` now takes in an argument `upload_extra_args` which are passed through as the `ExtraArgs` parameter to the file upload call.\n- [dagster-airflow] added `make_dagster_definitions_from_airflow_dags_path` and **`make_dagster_definitions_from_airflow_dag_bag`** which are passed through as the `ExtraArgs` parameter to the file upload call.\n\n### Bugfixes\n\n- Fixed a bug where ad-hoc materializations of assets were not correctly retrieving metadata of upstream assets.\n- Fixed a bug that caused `ExperimentalWarning`s related to `LogicalVersions` to appear even when version-based staleness was not in use.\n- Fixed a bug in the asset reconciliation sensor that caused multi-assets to be reconciled when some, but not all, of the assets they depended on, were reconciled.\n- Fixed a bug in the asset reconciliation sensor that caused it to only act on one materialization per asset per tick, even when multiple partitions of an asset were materialized.\n- Fixed a bug in the asset reconciliation sensor that caused it to never attempt to rematerialize assets which failed in their last execution. Now, it will launch the next materialization for a given asset at the same time that it would have if the original run had completed successfully.\n- The `load_assets_from_modules` and `load_assets_from_package_module` utilities now will also load cacheable assets from the specified modules.\n- The `dequeue_num_workers` config setting on `QueuedRunCoordinator`is now respected.\n- [dagit] Fixed a bug that caused a “Maximum recursion depth exceeded” error when viewing partitioned assets with self-dependencies.\n- [dagit] Fixed a bug where “Definitions loaded” notifications would constantly show up in cases where there were multiple dagit hosts running.\n- [dagit] Assets that are partitioned no longer erroneously appear \"Stale\" in the asset graph.\n- [dagit] Assets with a freshness policy no longer appear stale when they are still meeting their freshness policy.\n- [dagit] Viewing Dagit in Firefox no longer results in erroneous truncation of labels in the left sidebar.\n- [dagit] Timestamps on the asset graph are smaller and have an appropriate click target.\n- [dagster-databricks] The `databricks_pyspark_step_launcher` will now cancel the relevant databricks job if the Dagster step execution is interrupted.\n- [dagster-databricks] Previously, the `databricks_pyspark_step_launcher` could exit with an unhelpful error after receiving an HTTPError from databricks with an empty message. This has been fixed.\n- [dagster-snowflake] Fixed a bug where calling `execute_queries` or `execute_query` on a `snowflake_resource` would raise an error unless the `parameters` argument was explicitly set.\n- [dagster-aws] Fixed a bug in the `EcsRunLauncher` when launching many runs in parallel. Previously, each run risked hitting a `ClientError` in AWS for registering too many concurrent changes to the same task definition family. Now, the `EcsRunLauncher` recovers gracefully from this error by retrying it with backoff.\n- [dagster-airflow] Added `make_dagster_definitions_from_airflow_dags_path` and `make_dagster_definitions_from_airflow_dag_bag` for creating Dagster definitions from a given airflow Dag file path or DagBag\n\n### Community Contributions\n\n- Fixed a metadata loading error in `UPathIOManager`, thanks @danielgafni!\n- [dagster-aws]`FakeS3Session` now includes additional functions and improvements to align with the boto3 S3 client API, thanks @asharov!\n- Typo fix from @vpicavet, thank you!\n- Repository license file year and company update, thanks @vwbusguy!\n\n### Experimental\n\n- Added experimental `BranchingIOManager` to model use case where you wish to read upstream assets from production environments and write them into a development environment.\n- Add `create_repository_using_definitions_args` to allow for the creation of named repositories.\n- Added the ability to use Python 3 typing to define and access op and asset config.\n- [dagster-dbt] Added `DbtManifestAssetSelection`, which allows you to define selections of assets loaded from a dbt manifest using dbt selection syntax (e.g. `tag:foo,path:marts/finance`).\n\n### Documentation\n\n- There’s now only one [Dagster Cloud Getting Started guide](https://docs.dagster.io/dagster-cloud/getting-started), which includes instructions for both Hybrid and Serverless deployment setups.\n- Lots of updates throughout the docs to clean up remaining references to `@repository`, replacing them with `Definitions`.\n- Lots of updates to the dagster-airflow documentation, a tutorial for getting started with Dagster from an airflow background, a migration guide for going to Dagster from Airflow and a terminology/concept map for Airflow onto Dagster.\n\n# 1.1.7 (core) / 0.17.7 (libraries)\n\n### New\n\n- `Definitions` is no longer marked as experimental and is the preferred API over `@repository` for new users of Dagster. Examples, tutorials, and documentation have largely ported to this new API. No migration is needed. Please see GitHub discussion for more details.\n- The “Workspace” section of Dagit has been removed. All definitions for your code locations can be accessed via the “Deployment” section of the app. Just as in the old Workspace summary page, each code location will show counts of its available jobs, assets, schedules, and sensors. Additionally, the code locations page is now available at `/locations`.\n- Lagged / rolling window partition mappings: `TimeWindowPartitionMapping` now accepts `start_offset` and `end_offset` arguments that allow specifying that time partitions depend on earlier or later time partitions of upstream assets.\n- Asset partitions can now depend on earlier time partitions of the same asset. The asset reconciliation sensor will respect these dependencies when requesting runs.\n- `dagit` can now accept multiple arguments for the `-m` and `-f` flags. For each argument a new code location is loaded.\n- Schedules created by `build_schedule_from_partitioned_job` now execute more performantly - in constant time, rather than linear in the number of partitions.\n- The `QueuedRunCoordinator` now supports options `dequeue_use_threads` and `dequeue_num_workers` options to enable concurrent run dequeue operations for greater throughput.\n- [dagster-dbt] `load_assets_from_dbt_project`, `load_assets_from_dbt_manifest`, and `load_assets_from_dbt_cloud_job` now support applying freshness policies to loaded nodes. To do so, you can apply `dagster_freshness_policy` config directly in your dbt project, i.e. `config(dagster_freshness_policy={\"maximum_lag_minutes\": 60})` would result in the corresponding asset being assigned a `FreshnessPolicy(maximum_lag_minutes=60)`.\n- The `DAGSTER_RUN_JOB_NAME` environment variable is now set in containerized environments spun up by our run launchers and executor.\n- [dagster-airflow] `make_dagster_repo_from_airflow_dags_path` ,`make_dagster_job_from_airflow_dag` and `make_dagster_repo_from_airflow_dag_bag` have a new `connections` parameter which allows for configuring the airflow connections used by migrated dags.\n\n### Bugfixes\n\n- Fixed a bug where the `log` property was not available on the `RunStatusSensorContext` context object provided for run status sensors for sensor logging.\n- Fixed a bug where the re-execute button on runs of asset jobs would incorrectly show warning icon, indicating that the pipeline code may have changed since you last ran it.\n- Fixed an issue which would cause metadata supplied to graph-backed assets to not be viewable in the UI.\n- Fixed an issue where schedules often took up to 5 seconds to start after their tick time.\n- Fixed an issue where Dagster failed to load a dagster.yaml file that specified the folder to use for sqlite storage in the `dagster.yaml` file using an environment variable.\n- Fixed an issue which would cause the k8s/docker executors to unnecessarily reload CacheableAssetsDefinitions (such as those created when using `load_assets_from_dbt_cloud_job`) on each step execution.\n- [dagster-airbyte] Fixed an issue where Python-defined Airbyte sources and destinations were occasionally recreated unnecessarily.\n- Fixed an issue with `build_asset_reconciliation_sensor` that would cause it to ignore in-progress runs in some cases.\n\n- Fixed a bug where GQL errors would be thrown in the asset explorer when a previously materialized asset had its dependencies changed.\n- [dagster-airbyte] Fixed an error when generating assets for normalization table for connections with non-object streams.\n- [dagster-dbt] Fixed an error where dbt Cloud jobs with `dbt run` and `dbt run-operation` were incorrectly validated.\n- [dagster-airflow] `use_ephemeral_airflow_db` now works when running within a PEX deployment artifact.\n\n### Documentation\n\n- New documentation for [Code locations](https://docs.dagster.io/concepts/code-locations) and how to define one using `Definitions`\n- Lots of updates throughout the docs to reflect the recommended usage of `Definitions`. Any content not ported to `Definitions` in this release is in the process of being updated.\n- New documentation for dagster-airflow on how to start writing dagster code from an airflow background.\n\n# 1.1.6 (core) / 0.17.6 (libraries)\n\n### New\n\n- [dagit] Throughout Dagit, when the default repository name `__repository__` is used for a repo, only the code location name will be shown. This change also applies to URL paths.\n- [dagster-dbt] When attempting to generate software-defined assets from a dbt Cloud job, an error is now raised if none are created.\n- [dagster-dbt] Software-defined assets can now be generated for dbt Cloud jobs that execute multiple commands.\n\n### Bugfixes\n\n- Fixed a bug that caused `load_asset_value` to error with the default IO manager when a `partition_key` argument was provided.\n- Previously, trying to access `context.partition_key` or `context.asset_partition_key_for_output` when invoking an asset directly (e.g. in a unit test) would result in an error. This has been fixed.\n- Failure hooks now receive the original exception instead of `RetryRequested` when using a retry policy.\n- The LocationStateChange GraphQL subscription has been fixed (thanks @\\***\\*[roeij](https://github.com/roeij) !)**\n- Fixed a bug where a `sqlite3.ProgrammingError` error was raised when creating an ephemeral `DagsterInstance`, most commonly when `build_resources` was called without passing in an instance parameter.\n- [dagstermill] Jupyter notebooks now correctly render in Dagit on Windows machines.\n- [dagster-duckdb-pyspark] New `duckdb_pyspark_io_manager` helper to automatically create a DuckDB I/O manager that can store and load PySpark DataFrames.\n- [dagster-mysql] Fixed a bug where versions of mysql < `8.0.31` would raise an error on some run queries.\n- [dagster-postgres] connection url param “options“ are no longer overwritten in dagit.\n- [dagit] Dagit now allows backfills to be launched for asset jobs that have partitions and required config.\n- [dagit] Dagit no longer renders the \"Job in repo@location\" label incorrectly in Chrome v109.\n- [dagit] Dagit's run list now shows improved labels on asset group runs of more than three assets\n- [dagit] Dagit's run gantt chart now renders per-step resource initialization markers correctly.\n- [dagit] In op and asset descriptions in Dagit, rendered markdown no longer includes extraneous escape slashes.\n- Assorted typos and omissions fixed in the docs — thanks @[C0DK](https://github.com/C0DK) and @[akan72](https://github.com/akan72)!\n\n### Experimental\n\n- As an optional replacement of the workspace/repository concepts, a new `Definitions` entrypoint for tools and the UI has been added. A single `Definitions` object per code location may be instantiated, and accepts typed, named arguments, rather than the heterogenous list of definitions returned from an `@repository`-decorated function. To learn more about this feature, and provide feedback, please refer to the [Github Discussion](https://github.com/dagster-io/dagster/discussions/10772).\n- [dagster-slack] A new `make_slack_on_freshness_policy_status_change_sensor` allows you to create a sensor to alert you when an asset is out of date with respect to its freshness policy (and when it’s back on time!)\n\n### Documentation\n\n- Refreshed `dagstermill` guide and reference page [https://docs.dagster.io/integrations/dagstermill](https://docs.dagster.io/integrations/dagstermill)\n- New declarative scheduling guide: [https://docs.dagster.io/guides/dagster/scheduling-assets](https://docs.dagster.io/guides/dagster/scheduling-assets)\n- New `dagster-snowflake` guide: [https://docs.dagster.io/integrations/snowflake](https://docs.dagster.io/integrations/snowflake)\n- Added docs for asset code versioning: [https://docs.dagster.io/concepts/assets/software-defined-assets#asset-code-versions](https://docs.dagster.io/concepts/assets/software-defined-assets#asset-code-versions)\n- Added docs for observable source assets: [https://docs.dagster.io/concepts/assets/asset-observations#observable-source-assets](https://docs.dagster.io/concepts/assets/asset-observations#observable-source-assets)\n\n# 1.1.5 (core) / 0.17.5 (libraries)\n\n### Bugfixes\n\n- [dagit] Fixed an issue where the Partitions tab sometimes failed to load for asset jobs.\n\n# 1.1.4 (core) / 0.17.4 (libraries)\n\n### Community Contributions\n\n- Fixed a typo in GCSComputeLogManager docstring (thanks [reidab](https://github.com/reidab))!\n- [dagster-airbyte] job cancellation on run termination is now optional. (Thanks [adam-bloom](https://github.com/adam-bloom))!\n- [dagster-snowflake] Can now specify snowflake role in config to snowflake io manager (Thanks [binhnefits](https://github.com/binhnefits))!\n- [dagster-aws] A new AWS systems manager resource (thanks [zyd14](https://github.com/zyd14))!\n- [dagstermill] Retry policy can now be set on dagstermill assets (thanks [nickvazz](https://github.com/nickvazz))!\n- Corrected typo in docs on metadata (thanks [C0DK](https://github.com/C0dk))!\n\n### New\n\n- Added a `job_name` parameter to `InputContext`\n- Fixed inconsistent io manager behavior when using `execute_in_process` on a `GraphDefinition` (it would use the `fs_io_manager` instead of the in-memory io manager)\n- Compute logs will now load in Dagit even when websocket connections are not supported.\n- [dagit] A handful of changes have been made to our URLs:\n  - The `/instance` URL path prefix has been removed. E.g. `/instance/runs` can now be found at `/runs`.\n  - The `/workspace` URL path prefix has been changed to `/locations`. E.g. the URL for job `my_job` in repository `foo@bar` can now be found at `/locations/foo@bar/jobs/my_job`.\n- [dagit] The “Workspace” navigation item in the top nav has been moved to be a tab under the “Deployment” section of the app, and is renamed to “Definitions”.\n- [dagstermill] Dagster events can now be yielded from asset notebooks using `dagstermill.yield_event`.\n- [dagstermill] Failed notebooks can be saved for inspection and debugging using the new `save_on_notebook_failure` parameter.\n- [dagster-airflow] Added a new option `use_ephemeral_airflow_db` which will create a job run scoped airflow db for airflow dags running in dagster\n- [dagster-dbt] Materializing software-defined assets using dbt Cloud jobs now supports partitions.\n- [dagster-dbt] Materializing software-defined assets using dbt Cloud jobs now supports subsetting. Individual dbt Cloud models can be materialized, and the proper filters will be passed down to the dbt Cloud job.\n- [dagster-dbt] Software-defined assets from dbt Cloud jobs now support configurable group names.\n- [dagster-dbt] Software-defined assets from dbt Cloud jobs now support configurable `AssetKey`s.\n\n### Bugfixes\n\n- Fixed regression starting in `1.0.16` for some compute log managers where an exception in the compute log manager setup/teardown would cause runs to fail.\n- The S3 / GCS / Azure compute log managers now sanitize the optional `prefix` argument to prevent badly constructed paths.\n- [dagit] The run filter typeahead no longer surfaces key-value pairs when searching for `tag:`. This resolves an issue where retrieving the available tags could cause significant performance problems. Tags can still be searched with freeform text, and by adding them via click on individual run rows.\n- [dagit] Fixed an issue in the Runs tab for job snapshots, where the query would fail and no runs were shown.\n- [dagit] Schedules defined with cron unions displayed “Invalid cron string” in Dagit. This has been resolved, and human-readable versions of all members of the union will now be shown.\n\n### Breaking Changes\n\n- You can no longer set an output’s asset key by overriding `get_output_asset_key` on the `IOManager` handling the output. Previously, this was experimental and undocumented.\n\n### Experimental\n\n- Sensor and schedule evaluation contexts now have an experimental `log` property, which log events that can later be viewed in Dagit. To enable these log views in dagit, navigate to the user settings and enable the `Experimental schedule/sensor logging view` option. Log links will now be available for sensor/schedule ticks where logs were emitted. Note: this feature is not available for users using the `NoOpComputeLogManager`.\n\n# 1.1.3 (core) / 0.17.3 (libraries)\n\n### Bugfixes\n\n- Fixed a bug with the asset reconciliation sensor that caused duplicate runs to be submitted in situations where an asset has a different partitioning than its parents.\n- Fixed a bug with the asset reconciliation sensor that caused it to error on time-partitioned assets.\n- [dagster-snowflake] Fixed a bug when materializing partitions with the Snowflake I/O manager where sql `BETWEEN` was used to determine the section of the table to replace. `BETWEEN` included values from the next partition causing the I/O manager to erroneously delete those entries.\n- [dagster-duckdb] Fixed a bug when materializing partitions with the DuckDB I/O manager where sql `BETWEEN` was used to determine the section of the table to replace. `BETWEEN` included values from the next partition causing the I/O manager to erroneously delete those entries.\n\n# 1.1.2 (core) / 0.17.2 (libraries)\n\n### Bugfixes\n\n- In Dagit, assets that had been materialized prior to upgrading to 1.1.1 were showing as \"Stale\". This is now fixed.\n- Schedules that were constructed with a list of cron strings previously rendered with an error in Dagit. This is now fixed.\n- For users running dagit version >= 1.0.17 (or dagster-cloud) with dagster version < 1.0.17, errors could occur when hitting \"Materialize All\" and some other asset-related interactions. This has been fixed.\n\n# 1.1.1 (core) / 0.17.1 (libraries)\n\n## Major Changes since 1.0.0 (core) / 0.16.0 (libraries)\n\n### Core\n\n- You can now create **multi-dimensional partitions definitions** for software-defined assets, through the `MultiPartitionsDefinition` API. In Dagit, you can filter and materialize certain partitions by providing ranges per-dimension, and view your materializations by dimension.\n- The new **asset reconciliation sensor** automatically materializes assets that have never been materialized or whose upstream assets have changed since the last time they were materialized. It works with partitioned assets too. You can construct it using `build_asset_reconciliation_sensor`.\n- You can now add a `FreshnessPolicy` to any of your software-defined assets, to specify how up-to-date you expect that asset to be. You can view the freshness status of each asset in Dagit, alert when assets are missing their targets using the `@freshness_policy_sensor`, and use the `build_asset_reconciliation_sensor` to make a sensor that automatically kick off runs to materialize assets based on their freshness policies.\n- You can now **version your asset ops and source assets** to help you track which of your assets are stale. You can do this by assigning `op_version` s to software-defined assets or `observation_fn` s to `SourceAsset`s. When a set of assets is versioned in this way, their “Upstream Changed” status will be based on whether upstream versions have changed, rather than on whether upstream assets have been re-materialized. You can launch runs that materialize only stale assets.\n- The new `@multi_asset_sensor` decorator enables defining custom sensors that trigger based on the materializations of multiple assets. The context object supplied to the decorated function has methods to fetch latest materializations by asset key, as well as built-in cursor management to mark specific materializations as “consumed”, so that they won’t be returned in future ticks. It can also fetch materializations by partition and mark individual partitions as consumed.\n- `RepositoryDefinition` now exposes a `load_asset_value` method, which accepts an asset key and invokes the asset’s I/O manager’s `load_input` function to load the asset as a Python object. This can be used in notebooks to do exploratory data analysis on assets.\n- With the new `asset_selection` parameter on `@sensor` and `SensorDefinition`, you can now define a sensor that directly targets a selection of assets, instead of targeting a job.\n- When running `dagit` or `dagster-daemon` locally, **environment variables included in a `.env` file** in the form `KEY=value` in the same folder as the command will be automatically included in the environment of any Dagster code that runs, allowing you to easily use environment variables during local development.\n\n### Dagit\n\n- The Asset Graph has been redesigned to make better use of color to communicate asset health. New status indicators make it easy to spot missing and stale assets (even on large graphs!) and the UI updates in real-time as displayed assets are materialized.\n- The Asset Details page has been redesigned and features a new side-by-side UI that makes it easier to inspect event metadata. A color-coded timeline on the partitions view allows you to drag-select a time range and inspect the metadata and status quickly. The new view also supports assets that have been partitioned across multiple dimensions.\n- The new Workspace page helps you quickly find and navigate between all your Dagster definitions. It’s also been re-architected to load significantly faster when you have thousands of definitions.\n- The Overview page is the new home for the live run timeline and helps you understand the status of all the jobs, schedules, sensors, and backfills across your entire deployment. The timeline is now grouped by repository and shows a run status rollup for each group.\n\n### Integrations\n\n- `dagster-dbt` now supports generating software-defined assets from your dbt Cloud jobs.\n- `dagster-airbyte` and `dagster-fivetran` now support automatically generating assets from your ETL connections using `load_assets_from_airbyte_instance` and `load_assets_from_fivetran_instance`.\n- New `dagster-duckdb` integration: `build_duckdb_io_manager` allows you to build an I/O manager that stores and loads Pandas and PySpark DataFrames in DuckDB.\n\n### Database migration\n\n- Optional database schema migration, which can be run via `dagster instance migrate`:\n  - Improves Dagit performance by adding database indexes which should speed up the run view as well as a range of asset-based queries.\n  - Enables multi-dimensional asset partitions and asset versioning.\n\n### Breaking Changes and Deprecations\n\n- `define_dagstermill_solid`, a legacy API, has been removed from `dagstermill`. Use `define_dagstermill_op` or `define_dagstermill_asset` instead to create an `op` or `asset` from a Jupyter notebook, respectively.\n- The internal `ComputeLogManager` API is marked as deprecated in favor of an updated interface: `CapturedLogManager`. It will be removed in `1.2.0`. This should only affect dagster instances that have implemented a custom compute log manager.\n\n### Dependency Changes\n\n- `dagster-graphql` and `dagit` now use version 3 of `graphene`\n\n## Since 1.0.17\n\n### New\n\n- The new `UPathIOManager` base class is now a top-level Dagster export. This enables you to write a custom I/O manager that plugs stores data in any filesystem supported by `universal-pathlib` and uses different serialization format than `pickle` (Thanks Daniel Gafni!).\n- The default `fs_io_manager` now inherits from the `UPathIOManager`, which means that its `base_dir` can be a path on any filesystem supported by `universal-pathlib` (Thanks Daniel Gafni!).\n- `build_asset_reconciliation_sensor` now works with support partitioned assets.\n- `build_asset_reconciliation_sensor` now launches runs to keep assets in line with their defined FreshnessPolicies.\n- The `FreshnessPolicy` object is now exported from the top level dagster package.\n- For assets with a `FreshnessPolicy` defined, their current freshness status will be rendered in the asset graph and asset details pages.\n- The AWS, GCS, and Azure compute log managers now take an additional config argument `upload_interval` which specifies in seconds, the interval in which partial logs will be uploaded to the respective cloud storage. This can be used to display compute logs for long-running compute steps.\n- When running `dagit` or `dagster-daemon` locally, environment variables included in a `.env` file in the form `KEY=value` in the same folder as the command will be automatically included in the environment of any Dagster code that runs, allowing you to easily test environment variables during local development.\n- `observable_source_asset` decorator creates a `SourceAsset` with an associated `observation_fn` that should return a `LogicalVersion`, a new class that wraps a string expressing a version of an asset’s data value.\n- [dagit] The asset graph now shows branded compute_kind tags for dbt, Airbyte, Fivetran, Python and more.\n- [dagit] The asset details page now features a redesigned event viewer, and separate tabs for Partitions, Events, and Plots. This UI was previously behind a feature flag and is now generally available.\n- [dagit] The asset graph UI has been revamped and makes better use of color to communicate asset status, especially in the zoomed-out view.\n- [dagit] The asset catalog now shows freshness policies in the “Latest Run” column when they are defined on your assets.\n- [dagit] The UI for launching backfills in Dagit has been simplified. Rather than selecting detailed ranges, the new UI allows you to select a large “range of interest” and materialize only the partitions of certain statuses within that range.\n- [dagit] The partitions page of asset jobs has been updated to show per-asset status rather than per-op status, so that it shares the same terminology and color coding as other asset health views.\n- [dagster-k8s] Added an `execute_k8s_job` function that can be called within any op to run an image within a Kubernetes job. The implementation is similar to the build-in `k8s_job_op` , but allows additional customization - for example, you can incorporate the output of a previous op into the launched Kubernetes job by passing it into `execute_k8s_job`. See the [dagster-k8s API docs](https://docs.dagster.io/_apidocs/libraries/dagster-k8s#ops) for more information.\n- [dagster-databricks] Environment variables used by dagster cloud are now automatically set when submitting databricks jobs if they exist, thank you @zyd14!\n- [dagstermill] `define_dagstermill_asset` now supports `RetryPolicy` . Thanks @**[nickvazz](https://github.com/dagster-io/dagster/commits?author=nickvazz)!**\n- [dagster-airbyte] When loading assets from an Airbyte instance using `load_assets_from_airbyte_instance`, users can now optionally customize asset names using `connector_to_asset_key_fn`.\n- [dagster-fivetran] When loading assets from a Fivetran instance using `load_assets_from_fivetran_instance`, users can now alter the IO manager using `io_manager_key` or `connector_to_io_manager_key_fn`, and customize asset names using `connector_to_asset_key_fn`.\n\n### Bugfixes\n\n- Fixed a bug where terminating runs from a backfill would fail without notice.\n- Executing a subset of ops within a job that specifies its config value directly on the job, it no longer attempts to use that config value as the default. The default is still presented in the editable interface in dagit.\n- [dagit] The partition step run matrix now reflects historical step status instead of just the last run’s step status for a particular partition.\n\n### Documentation\n\n- Updated [Environment variables and secrets docs](https://docs.dagster.io/guides/dagster/using-environment-variables-and-secrets) with info/instructions for using local `.env` files\n- Added [a new example test to the Testing docs](https://docs.dagster.io/concepts/testing#testing-loading-repository-definitions). This test verifies if Dagster code loads correctly by loading a Dagster repository and its definitions.\n\n# 1.0.17 (core) / 0.16.17 (libraries)\n\n### New\n\n- With the new `asset_selection` parameter on `@sensor` and `SensorDefinition`, you can now define a sensor that directly targets a selection of assets, instead of targeting a job.\n- `materialize` and `materialize_to_memory` now accept a `raise_on_error` argument, which allows you to determine whether to raise an Error if the run hits an error or just return as failed.\n- (experimental) Dagster now supports multi-dimensional asset partitions, through a new `MultiPartitionsDefinition` object. An optional schema migration enables support for this feature (run via `dagster instance migrate`). Users who are not using this feature do not need to run the migration.\n- You can now launch a run that targets a range of asset partitions, by supplying the \"dagster/asset_partition_range_start\" and \"dagster/asset_partition_range_end\" tags.\n- [dagit] Asset and op graphs in Dagit now show integration logos, making it easier to identify assets backed by notebooks, DBT, Airbyte, and more.\n- [dagit] a `-db-pool-recycle` cli flag (and dbPoolRecycle helm option) have been added to control how long the pooled connection dagit uses persists before recycle. The default of 1 hour is now respected by postgres (mysql previously already had a hard coded 1hr setting). Thanks **[@adam-bloom](https://github.com/adam-bloom)**!\n- [dagster-airbyte] Introduced the ability to specify output IO managers when using `load_assets_from_airbyte_instance` and `load_assets_from_airbyte_project`.\n- [dagster-dbt] the `dbt_cloud_resource` resource configuration `account_id` can now be sourced from the environment. Thanks **[@sowusu-ba](https://github.com/sowusu-ba)**!\n- [dagster-duckdb] The DuckDB integration improvements: PySpark DataFrames are now fully supported, “schema” can be specified via IO Manager config, and API documentation has been improved to include more examples\n- [dagster-fivetran] Introduced experimental `load_assets_from_fivetran_instance` helper which automatically pulls assets from a Fivetran instance.\n- [dagster-k8s] Fixed an issue where setting the `securityContext` configuration of the Dagit pod in the Helm chart didn’t apply to one of its containers. Thanks **[@jblawatt](https://github.com/jblawatt)**!\n\n### Bugfixes\n\n- Fixed a bug that caused the `asset_selection` parameter of `RunRequest` to not be respected when used inside a schedule.\n- Fixed a bug with health checks during delayed Op retries with the k8s_executor and docker_executor.\n- [dagit] The asset graph now live-updates when assets fail to materialize due to op failures.\n- [dagit] The \"Materialize\" button now respects the backfill permission for multi-run materializations.\n- [dagit] Materializations without metadata are padded correctly in the run logs.\n- [dagster-aws] Fixed an issue where setting the value of `task_definition` field in the `EcsRunLauncher` to an environment variable stopped working.\n- [dagster-dbt] Add exposures in `load_assets_from_dbt_manifest`. This fixed then error when `load_assets_from_dbt_manifest` failed to load from dbt manifest with exposures. Thanks **[@sowusu-ba](https://github.com/sowusu-ba)**!\n- [dagster-duckdb] In some examples, the duckdb config was incorrectly specified. This has been fixed.\n\n### Breaking Changes\n\n- The behavior of the experimental asset reconciliation sensor, which is accessible via `build_asset_reconciliation_sensor` has changed to be more focused on reconciliation. It now materializes assets that have never been materialized before and avoids materializing assets that are “Upstream changed”. The `build_asset_reconciliation_sensor` API no longer accepts `wait_for_in_progress_runs` and `wait_for_all_upstream` arguments.\n\n### Documentation\n\n- Added documentation outlining [environment variable declaration and usage in Dagster code](https://docs.dagster.io/guides/dagster/using-environment-variables-and-secrets), including how to pass secrets.\n- Fixed a typo on Dagster Instance page. Thanks **[@domsj](https://github.com/domsj)**!\n\n# 1.0.16 (core) / 0.16.16 (libraries)\n\n### New\n\n- [dagit] The new Overview and Workspace pages have been enabled for all users, after being gated with a feature flag for the last several releases. These changes include design updates, virtualized tables, and more performant querying.\n  - The top navigation has been updated to improve space allocation, with main nav links moved to the left.\n  - “Overview” is the new Dagit home page and “factory floor” view, were you can find the run timeline, which now offers time-based pagination. The Overview section also contains pages with all of your jobs, schedules, sensors, and backfills. You can filter objects by name, and collapse or expand repository sections.\n  - “Workspace” has been redesigned to offer a better summary of your repositories, and to use the same performant table views, querying, and filtering as in the Overview pages.\n- `@asset` and `@multi_asset` now accept a `retry_policy` argument. (Thanks @adam-bloom!)\n- When loading an input that depends on multiple partitions of an upstream asset, the `fs_io_manager` will now return a dictionary that maps partition keys to the stored values for those partitions. (Thanks @andrewgryan!).\n- `JobDefinition.execute_in_process` now accepts a `run_config` argument even when the job is partitioned. If supplied, the run config will be used instead of any config provided by the job’s `PartitionedConfig`.\n- The `run_request_for_partition` method on jobs now accepts a `run_config` argument. If supplied, the run config will be used instead of any config provided by the job’s `PartitionedConfig`.\n- The new `NotebookMetadataValue` can be used to report the location of executed jupyter notebooks, and Dagit will be able to render the notebook.\n- Resolving asset dependencies within a group now works with multi-assets, as long as all the assets within the multi-asset are in the same group. (Thanks @peay!)\n- UPathIOManager, a filesystem-agnostic IOManager base class has been added - (Thanks @danielgafni!)\n- A threadpool option has been added for the scheduler daemon. This can be enabled via your `dagster.yaml` file; check out the [docs](https://docs.dagster.io/deployment/dagster-instance#schedule-evaluation).\n- The default LocalComputeLogManager will capture compute logs by process instead of by step. This means that for the `in_process` executor, where all steps are executed in the same process, the captured compute logs for all steps in a run will be captured in the same file.\n- [dagstermill] Added `define_dagstermill_asset` which loads a notebook as an asset.\n- [dagster-airflow] `make_dagster_job_from_airflow_dag` now supports airflow 2, there is also a new mock_xcom parameter that will mock all calls to made by operators to xcom.\n- [helm] volume and volumeMount sections have been added for the dagit and daemon sections of the helm chart.\n\n### Bugfixes\n\n- For partitioned asset jobs whose config is a hardcoded dictionary (rather than a `PartitionedConfig`), previously `run_request_for_partition` would produce a run with no config. Now, the run has the hardcoded dictionary as its config.\n- Previously, asset inputs would be resolved to upstream assets in the same group that had the same name, even if the asset input already had a key prefix. Now, asset inputs are only resolved to upstream assets in the same group if the input path only has a single component.\n- Previously, asset inputs could get resolved to outputs of the same `AssetsDefinition`, through group-based asset dependency resolution, which would later error because of a circular dependency. This has been fixed.\n- Previously, the “Partition Status” and “Backfill Status” fields on the Backfill page in dagit were always incomplete and showed missing partitions. This has been fixed to accurately show the status of the backfill runs.\n- Executors now compress step worker arguments to avoid CLI length limits with large DAGs.\n- [dagit] When viewing the config dialog for a run with a very long config, scrolling was broken and the “copy” button was not visible. This has been fixed.\n- [dagster-msteams] Longer messages can now be used in Teams HeroCard - thanks `@jayhale`\n\n### Documentation\n\n- API docs for InputContext have been improved - (Thanks @peay!)\n- [dagster-snowflake] Improved documentation for the Snowflake IO manager\n\n# 1.0.15 (core) / 0.16.15 (libraries)\n\n### New\n\n- [dagit] The run timeline now shows all future schedule ticks for the visible time window, not just the next ten ticks.\n- [dagit] Asset graph views in Dagit refresh as materialization events arrive, making it easier to watch your assets update in real-time.\n- [dagster-airbyte] Added support for basic auth login to the Airbyte resource.\n- [Configuring a Python Log Level](https://docs.dagster.io/concepts/logging/python-logging#configuring-a-python-log-level-) will now also apply to system logs created by Dagster during a run.\n\n### Bugfixes\n\n- Fixed a bug that broke asset partition mappings when using the `key_prefix` with methods like `load_assets_from_modules`.\n- [dagster-dbt] When running dbt Cloud jobs with the dbt_cloud_run_op, the op would emit a failure if the targeted job did not create a run_results.json artifact, even if this was the expected behavior. This has been fixed.\n- Improved performance by adding database indexes which should speed up the run view as well as a range of asset-based queries. These migrations can be applied by running `dagster instance migrate`.\n- An issue that would cause schedule/sensor latency in the daemon during workspace refreshes has been resolved.\n- [dagit] Shift-clicking Materialize for partitioned assets now shows the asset launchpad, allowing you to launch execution of a partition with config.\n\n### Community Contributions\n\n- Fixed a bug where asset keys with `-` were not being properly sanitized in some situations. Thanks @peay!\n- [dagster-airbyte] A list of connection directories can now be specified in `load_assets_from_airbyte_project`. Thanks @adam-bloom!\n- [dagster-gcp] Dagster will now retry connecting to GCS if it gets a `ServiceUnavailable` error. Thanks @cavila-evoliq!\n- [dagster-postgres] Use of SQLAlchemy engine instead of psycopg2 when subscribing to PostgreSQL events. Thanks @peay!\n\n### Experimental\n\n- [dagster-dbt] Added a `display_raw_sql` flag to the dbt asset loading functions. If set to False, this will remove the raw sql blobs from the asset descriptions. For large dbt projects, this can significantly reduce the size of the generated workspace snapshots.\n- [dagit] A “New asset detail pages” feature flag available in Dagit’s settings allows you to preview some upcoming changes to the way historical materializations and partitions are viewed.\n\n# 1.0.14 (core) / 0.16.14 (libraries)\n\n### New\n\n- Tags can now be provided to an asset reconciliation sensor and will be applied to all RunRequests returned by the sensor.\n- If you don’t explicitly specify a DagsterType on a graph input, but all the inner inputs that the graph input maps to have the same DagsterType, the graph input’s DagsterType will be set to the DagsterType of the inner inputs.\n- [dagster-airbyte] `load_assets_from_airbyte_project` now caches the project data generated at repo load time so it does not have to be regenerated in subprocesses.\n- [dagster-airbyte] Output table schema metadata is now generated at asset definition time when using `load_assets_from_airbyte_instance` or `load_assets_from_airbyte_project`.\n- [dagit] The run timeline now groups all jobs by repository. You can collapse or expand each repository in this view by clicking the repository name. This state will be preserved locally. You can also hold `Shift` while clicking the repository name, and all repository groups will be collapsed or expanded accordingly.\n- [dagit] In the launchpad view, a “Remove all” button is now available once you have accrued three or more tabs for that job, to make it easier to clear stale configuration tabs from view.\n- [dagit] When scrolling through the asset catalog, the toolbar is now sticky. This makes it simpler to select multiple assets and materialize them without requiring you to scroll back to the top of the page.\n- [dagit] A “Materialize” option has been added to the action menu on individual rows in the asset catalog view.\n- [dagster-aws] The `EcsRunLauncher` now allows you to pass in a dictionary in the `task_definition` config field that specifies configuration for the task definition of the launched run, including role ARNs and a list of sidecar containers to include. Previously, the task definition could only be configured by passing in a task definition ARN or by basing the task definition off of the task definition of the ECS task launching the run. See the [docs](https://docs.dagster.io/_apidocs/libraries/dagster-aws#dagster_aws.ecs.EcsRunLauncher) for the full set of available config.\n\n### Bugfixes\n\n- Previously, yielding a `SkipReason` within a multi-asset sensor (experimental) would raise an error. This has been fixed.\n- [dagit] Previously, if you had a partitioned asset job and supplied a hardcoded dictionary of config to `define_asset_job`, you would run into a `CheckError` when launching the job from Dagit. This has been fixed.\n- [dagit] When viewing the Runs section of Dagit, the counts displayed in the tabs (e.g. “In progress”, “Queued”, etc.) were not updating on a poll interval. This has been fixed.\n\n# 1.0.13 (core) / 0.16.13 (libraries)\n\n### New\n\n- `AssetMaterialization` now has a `metadata` property, which allows accessing the materialization’s metadata as a dictionary.\n- `DagsterInstance` now has a `get_latest_materialization_event` method, which allows fetching the most recent materialization event for a particular asset key.\n- `RepositoryDefinition.load_asset_value` and `AssetValueLoader.load_asset_value` now work with IO managers whose `load_input` implementation accesses the `op_def` and `name` attributes on the `InputContext`.\n- `RepositoryDefinition.load_asset_value` and `AssetValueLoader.load_asset_value` now respect the `DAGSTER_HOME` environment variable.\n- `InMemoryIOManager`, the `IOManager` that backs `mem_io_manager`, has been added to the public API.\n- The `multi_asset_sensor` (experimental) now supports marking individual partitioned materializations as “consumed”. Unconsumed materializations will appear in future calls to partitioned context methods.\n- The `build_multi_asset_sensor_context` testing method (experimental) now contains a flag to set the cursor to the newest events in the Dagster instance.\n- `TableSchema` now has a static constructor that enables building it from a dictionary of column names to column types.\n- Added a new CLI command `dagster run migrate-repository` which lets you migrate the run history for a given job from one repository to another. This is useful to preserve run history for a job when you have renamed a repository, for example.\n- [dagit] The run timeline view now shows jobs grouped by repository, with each repository section collapsible. This feature was previously gated by a feature flag, and is now turned on for everyone.\n- [dagster-airbyte] Added option to specify custom request params to the Airbyte resource, which can be used for auth purposes.\n- [dagster-airbyte] When loading Airbyte assets from an instance or from YAML, a filter function can be specified to ignore certain connections.\n- [dagster-airflow] `DagsterCloudOperator` and `DagsterOperator` now support Airflow 2. Previously, installing the library on Airflow 2 would break due to an import error.\n- [dagster-duckdb] A new integration with DuckDB allows you to store op outputs and assets in an in-process database.\n\n### Bugfixes\n\n- Previously, if retries were exceeded when running with `execute_in_process`, no error would be raised. Now, a `DagsterMaxRetriesExceededError` will be launched off.\n- [dagster-airbyte] Fixed generating assets for Airbyte normalization tables corresponding with nested union types.\n- [dagster-dbt] When running assets with `load_assets_from_...(..., use_build=True)`, AssetObservation events would be emitted for each test. These events would have metadata fields which shared names with the fields added to the AssetMaterialization events, causing confusing historical graphs for fields such as Compilation Time. This has been fixed.\n- [dagster-dbt] The name for the underlying op for `load_assets_from_...` was generated in a way which was non-deterministic for dbt projects which pulled in external packages, leading to errors when executing across multiple processes. This has been fixed.\n\n### Dependency changes\n\n- [dagster-dbt] The package no longer depends on pandas and dagster-pandas.\n\n### Community Contributions\n\n- [dagster-airbyte] Added possibility to change request timeout value when calling Airbyte. Thanks @FransDel!\n- [dagster-airflow] Fixed an import error in `dagster_airflow.hooks`. Thanks @bollwyvl!\n- [dagster-gcp] Unpin Google dependencies. `dagster-gcp` now supports google-api-python-client 2.x. Thanks @amarrella!\n- [dagstermill] Fixed an issue where DagsterTranslator was missing an argument required by newer versions of papermill. Thanks @tizz98!\n\n### Documentation\n\n- Added an example, underneath examples/assets_smoke_test, that shows how to write a smoke test that feeds empty data to all the transformations in a data pipeline.\n- Added documentation for `build_asset_reconciliation_sensor`.\n- Added documentation for monitoring partitioned materializations using the `multi_asset_sensor` and kicking off subsequent partitioned runs.\n- [dagster-cloud] Added documentation for running the Dagster Cloud Docker agent with Docker credential helpers.\n- [dagster-dbt] The class methods of the dbt_cli_resource are now visible in the API docs for the dagster-dbt library.\n- [dagster-dbt] Added a step-by-step tutorial for using dbt models with Dagster software-defined assets\n\n# 1.0.12 (core) / 0.16.12 (libraries)\n\n### New\n\n- The `multi_asset_sensor` (experimental) now accepts an `AssetSelection` of assets to monitor. There are also minor API updates for the multi-asset sensor context.\n- `AssetValueLoader`, the type returned by `RepositoryDefinition.get_asset_value_loader` is now part of Dagster’s public API.\n- `RepositoryDefinition.load_asset_value` and `AssetValueLoader.load_asset_value` now support a `partition_key` argument.\n- `RepositoryDefinition.load_asset_value` and `AssetValueLoader.load_asset_value` now work with I/O managers that invoke `context.upstream_output.asset_key`.\n- When running Dagster locally, the default amount of time that the system waits when importing user code has been increased from 60 seconds to 180 seconds, to avoid false positives when importing code with heavy dependencies or large numbers of assets. This timeout can be configured in `dagster.yaml` as follows:\n\n```yaml\ncode_servers:\n  local_startup_timeout: 120\n```\n\n- [dagit] The “Status” section has been renamed to “Deployment”, to better reflect that this section of the app shows deployment-wide information.\n- [dagit] When viewing the compute logs for a run and choosing a step to filter on, there is now a search input to make it easier to find the step you’re looking for.\n- [dagster-aws] The EcsRunLauncher can now launch runs in ECS clusters using both Fargate and EC2 capacity providers. See the [Deploying to ECS docs](http://docs.dagster.io/deployment/guides/aws#customizing-the-launched-runs-task) for more information.\n- [dagster-airbyte] Added the `load_assets_from_airbyte_instance` function which automatically generates asset definitions from an Airbyte instance. For more details, see the [new Airbyte integration guide](https://docs.dagster.io/integrations/airbyte).\n- [dagster-airflow] Added the `DagsterCloudOperator` and `DagsterOperator` , which are airflow operators that enable orchestrating dagster jobs, running on either cloud or OSS dagit instances, from Apache Airflow.\n\n### Bugfixes\n\n- Fixed a bug where if resource initialization failed for a dynamic op, causing other dynamic steps to be skipped, those skipped dynamic steps would be ignored when retrying from failure.\n- Previously, some invocations within the Dagster framework would result in warnings about deprecated metadata APIs. Now, users should only see warnings if their code uses deprecated metadata APIs.\n- How the daemon process manages its understanding of user code artifacts has been reworked to improve memory consumption.\n- [dagit] The partition selection UI in the Asset Materialization modal now allows for mouse selection and matches the UI used for partitioned op jobs.\n- [dagit] Sidebars in Dagit shrink more gracefully on small screens where headers and labels need to be truncated.\n- [dagit] Improved performance for loading runs with >10,000 logs\n- [dagster-airbyte] Previously, the `port` configuration in the `airbyte_resource` was marked as not required, but if it was not supplied, an error would occur. It is now marked as required.\n- [dagster-dbt] A change made to the manifest.json schema in dbt 1.3 would result in an error when using `load_assets_from_dbt_project` or `load_assets_from_manifest_json`. This has been fixed.\n- [dagster-postgres] connections that fail due to **`sqlalchemy.exc.TimeoutError`** now retry\n\n### Breaking Changes\n\n- [dagster-aws] The `redshift_resource` no longer accepts a `schema` configuration parameter. Previously, this parameter would error whenever used, because Redshift connections do not support this parameter.\n\n### Community Contributions\n\n- We now reference the correct method in the \"loading asset values outside of Dagster runs\" example (thank you Peter A. I. Forsyth!)\n- We now reference the correct test directory in the “Create a New Project” documentation (thank you Peter A. I. Forsyth!)\n- [dagster-pyspark] dagster-pyspark now contains a `LazyPysparkResource` that only initializes a spark session once it’s accessed (thank you @zyd14!)\n\n### Experimental\n\n- The new `build_asset_reconciliation_sensor` function accepts a set of software-defined assets and returns a sensor that automatically materializes those assets after their parents are materialized.\n- [dagit] A new \"groups-only\" asset graph feature flag allows you to zoom way out on the global asset graph, collapsing asset groups into smaller nodes you can double-click to expand.\n\n# 1.0.11 (core) / 0.16.11 (libraries)\n\n### New\n\n- `RepositoryDefinition` now exposes a `load_asset_value` method, which accepts an asset key and invokes the asset’s I/O manager’s `load_input` function to load the asset as a Python object. This can be used in notebooks to do exploratory data analysis on assets.\n- Methods to fetch a list of partition keys from an input/output `PartitionKeyRange` now exist on the op execution context and input/output context.\n- [dagit] On the Instance Overview page, batched runs in the run timeline view will now proportionally reflect the status of the runs in the batch instead of reducing all run statuses to a single color.\n- [dagster-dbt] [dagster-snowflake] You can now use the Snowflake IO manager with dbt assets, which allows them to be loaded from Snowflake into Pandas DataFrames in downstream steps.\n- The dagster package’s pin of the alembic package is now much less restrictive.\n\n### Bugfixes\n\n- The sensor daemon when using threads will no longer evaluate the next tick for a sensor if the previous one is still in flight. This resolves a memory leak in the daemon process.\n- The scheduler will no longer remove tracked state for automatically running schedules when they are absent due to a workspace load error.\n- The way user code severs manage repository definitions has been changed to more efficiently serve requests.\n- The `@multi_asset` decorator now respects its `config_schema` parameter.\n- [dagit] Config supplied to `define_asset_job` is now prefilled in the modal that pops up when you click the Materialize button on an asset job page, so you can quickly adjust the defaults.\n- [dagster-dbt] Previously, `DagsterDbtCliError`s produced from the dagster-dbt library would contain large serialized objects representing the raw unparsed logs from the relevant cli command. Now, these messages will contain only the parsed version of these messages.\n- Fixed an issue where the `deploy_ecs` example didn’t work when built and deployed on an M1 Mac.\n\n### Community Contributions\n\n- [dagster-fivetran] The `resync_parameters` configuration on the `fivetran_resync_op` is now optional, enabling triggering historical re\\*syncs for connectors. Thanks @dwallace0723!\n\n### Documentation\n\n- Improved API documentation for the Snowflake resource.\n\n# 1.0.10 (core) / 0.16.10 (libraries)\n\n### New\n\n- Run status sensors can now monitor all runs in a Dagster Instance, rather than just runs from jobs within a single repository. You can enable this behavior by setting `monitor_all_repositories=True` in the run status sensor decorator.\n- The `run_key` argument on `RunRequest` and `run_request_for_partition` is now optional.\n- [dagster-databricks] A new “verbose_logs” config option on the databricks_pyspark_step_launcher makes it possible to silence non-critical logs from your external steps, which can be helpful for long-running, or highly parallel operations (thanks @zyd14!)\n- [dagit] It is now possible to delete a run in Dagit directly from the run page. The option is available in the dropdown menu on the top right of the page.\n- [dagit] The run timeline on the Workspace Overview page in Dagit now includes ad hoc asset materialization runs.\n\n### Bugfixes\n\n- Fixed a set of bugs in `multi_asset_sensor` where the cursor would fail to update, and materializations would be returned out of order for `latest_materialization_records_by_partition`.\n- Fixed a bug that caused failures in runs with time-partitioned asset dependencies when the PartitionsDefinition had an offset that wasn’t included in the date format. E.g. a daily-partitioned asset with an hour offset, whose date format was `%Y-%m-%d`.\n- An issue causing code loaded by file path to import repeatedly has been resolved.\n- To align with best practices, singleton comparisons throughout the codebase have been converted from (e.g.) `foo == None` to `foo is None` (thanks @chrisRedwine!).\n- [dagit] In backfill jobs, the “Partition Set” column would sometimes show an internal `__ASSET_JOB` name, rather than a comprehensible set of asset keys. This has been fixed.\n- [dagit] It is now possible to collapse all Asset Observation rows on the AssetDetails page.\n- [dagster-dbt] Fixed issue that would cause an error when loading assets from dbt projects in which a source had a “\\*” character in its name (e.g. BigQuery sharded tables)\n- [dagster-k8s] Fixed an issue where the `k8s_job_op` would sometimes fail if the Kubernetes job that it creates takes a long time to create a pod.\n- Fixed an issue where links to the compute logs for a run would sometimes fail to load.\n- [dagster-k8s] The `k8s_job_executor` now uses environment variables in place of CLI arguments to avoid limits on argument size with large dynamic jobs.\n\n### Documentation\n\n- Docs added to explain subsetting graph-backed assets. You can use this feature following the documentation [here](https://docs.dagster.io/concepts/assets/graph-backed-assets).\n- UI updated to reflect separate version schemes for mature core Dagster packages and less mature integration libraries\n\n# 1.0.9 (core) / 0.16.9 (libraries)\n\n### New\n\n- The `multi_asset_sensor` (experimental) now has improved capabilities to monitor asset partitions via a `latest_materialization_records_by_partition` method.\n- Performance improvements for the Partitions page in Dagit.\n\n### Bugfixes\n\n- Fixed a bug that caused the op_config argument of `dagstermill.get_context` to be ignored\n- Fixed a bug that caused errors when loading the asset details page for assets with time window partitions definitions\n- Fixed a bug where assets sometimes didn’t appear in the Asset Catalog while in Folder view.\n- [dagit] Opening the asset lineage tab no longer scrolls the page header off screen in some scenarios\n- [dagit] The asset lineage tab no longer attempts to materialize source assets included in the upstream / downstream views.\n- [dagit] The Instance page Run Timeline no longer commingles runs with the same job name in different repositories\n- [dagit] Emitting materializations with JSON metadata that cannot be parsed as JSON no longer crashes the run details page\n- [dagit] Viewing the assets related to a run no longer shows the same assets multiple times in some scenarios\n- [dagster-k8s] Fixed a bug with timeouts causing errors in `k8s_job_op`\n- [dagster-docker] Fixed a bug with Op retries causing errors with the `docker_executor`\n\n### Community Contributions\n\n- [dagster-aws] Thanks @Vivanov98 for adding the `list_objects` method to `S3FakeSession`!\n\n### Experimental\n\n- [dagster-airbyte] Added an experimental function to automatically generate Airbyte assets from project YAML files. For more information, see the [dagster-airbyte docs](https://docs.dagster.io/_apidocs/libraries/dagster-airbyte).\n- [dagster-airbyte] Added the forward_logs option to `AirbyteResource`, allowing users to disble forwarding of Airbyte logs to the compute log, which can be expensive for long-running syncs.\n- [dagster-airbyte] Added the ability to generate Airbyte assets for [basic normalization](https://docs.airbyte.com/understanding-airbyte/basic-normalization/#nesting) tables generated as part of a sync.\n\n### Documentation\n\n- [dagster-dbt] Added a new guide focused on the dbt Cloud integration.\n- Fixed a bug that was hiding display of some public methods in the API docs.\n- Added documentation for [managing full deployments in Dagster Cloud](https://docs.dagster.io/dagster-cloud/managing-deployments/managing-deployments), including a [reference for deployment configuration options](https://docs.dagster.io/dagster-cloud/developing-testing/deployment-settings-reference).\n\n# 1.0.8 (core) / 0.16.8 (libraries)\n\n### New\n\n- With the new `cron_schedule` argument to `TimeWindowPartitionsDefinition`, you can now supply arbitrary cron expressions to define time window-based partition sets.\n- Graph-backed assets can now be subsetted for execution via `AssetsDefinition.from_graph(my_graph, can_subset=True)`.\n- `RunsFilter` is now exported in the public API.\n- [dagster-k8s] The `dagster-user-deployments.deployments[].schedulerName` Helm value for specifying custom Kubernetes schedulers will now also apply to run and step workers launched for the given user deployment. Previously it would only apply to the grpc server.\n\n### Bugfixes\n\n- In some situations, default asset config was ignored when a subset of assets were selected for execution. This has been fixed.\n- Added a pin to `grpcio` in dagster to address an issue with the recent 0.48.1 grpcio release that was sometimes causing Dagster code servers to hang.\n- Fixed an issue where the “Latest run” column on the Instance Status page sometimes displayed an older run instead of the most recent run.\n\n### Community Contributions\n\n- In addition to a single cron string, `cron_schedule` now also accepts a sequence of cron strings. If a sequence is provided, the schedule will run for the union of all execution times for the provided cron strings, e.g., `['45 23 * * 6', '30 9 * * 0]` for a schedule that runs at 11:45 PM every Saturday and 9:30 AM every Sunday. Thanks @erinov1!\n- Added an optional boolean config `install_default_libraries` to `databricks_pyspark_step_launcher` . It allows to run Databricks jobs without installing the default Dagster libraries .Thanks @nvinhphuc!\n\n### Experimental\n\n- [dagster-k8s] Added additional configuration fields (`container_config`, `pod_template_spec_metadata`, `pod_spec_config`, `job_metadata`, and `job_spec_config`) to the experimental `k8s_job_op` that can be used to add additional configuration to the Kubernetes pod that is launched within the op.\n\n# 1.0.7 (core) / 0.16.7 (libraries)\n\n### New\n\n- Several updates to the Dagit run timeline view: your time window preference will now be preserved locally, there is a clearer “Now” label to delineate the current time, and upcoming scheduled ticks will no longer be batched with existing runs.\n- [dagster-k8s] `ingress.labels` is now available in the Helm chart. Any provided labels are appended to the default labels on each object (`helm.sh/chart`, `app.kubernetes.io/version`, and `app.kubernetes.io/managed-by`).\n- [dagster-dbt] Added support for two types of dbt nodes: metrics, and ephemeral models.\n- When constructing a `GraphDefinition` manually, InputMapping and OutputMapping objects should be directly constructed.\n\n### Bugfixes\n\n- [dagster-snowflake] Pandas is no longer imported when `dagster_snowflake` is imported. Instead, it’s only imported when using functionality inside `dagster-snowflake` that depends on pandas.\n- Recent changes to `run_status_sensors` caused sensors that only monitored jobs in external repositories to also monitor all jobs in the current repository. This has been fixed.\n- Fixed an issue where \"unhashable type\" errors could be spawned from sensor executions.\n- [dagit] Clicking between assets in different repositories from asset groups and asset jobs now works as expected.\n- [dagit] The DAG rendering of composite ops with more than one input/output mapping has been fixed.\n- [dagit] Selecting a source asset in Dagit no longer produces a GraphQL error\n- [dagit] Viewing “Related Assets” for an asset run now shows the full set of assets included in the run, regardless of whether they were materialized successfully.\n- [dagit] The Asset Lineage view has been simplified and lets you know if the view is being clipped and more distant upstream/downstream assets exist.\n- Fixed erroneous experimental warnings being thrown when using `with_resources` alongside source assets.\n\n### Breaking Changes\n\n- [dagit] The launchpad tab is no longer shown for Asset jobs. Asset jobs can be launched via the “Materialize All” button shown on the Overview tab. To provide optional configuration, hold shift when clicking “Materialize”.\n- The arguments to `InputMapping` and `OutputMapping` APIs have changed.\n\n### Community Contributions\n\n- The `ssh_resource` can now accept configuration from environment variables. Thanks @[cbini](https://github.com/cbini)!\n- Spelling corrections in `migrations.md`. Thanks @[gogi2811](https://github.com/gogi2811)!\n\n# 1.0.6 (core) / 0.16.6 (libraries)\n\n### New\n\n- [dagit] nbconvert is now installed as an extra in Dagit.\n- Multiple assets can be monitored for materialization using the `multi_asset_sensor` (experimental).\n- Run status sensors can now monitor jobs in external repositories.\n- The `config` argument of `define_asset_job` now works if the job contains partitioned assets.\n- When configuring sqlite-based storages in dagster.yaml, you can now point to environment variables.\n- When emitting `RunRequests` from sensors, you can now optionally supply an `asset_selection` argument, which accepts a list of `AssetKey`s to materialize from the larger job.\n- [dagster-dbt] `load_assets_from_dbt_project` and `load_assets_from_dbt_manifest` now support the `exclude` parameter, allowing you to more precisely which resources to load from your dbt project (thanks @flvndh!)\n- [dagster-k8s] `schedulerName` is now available for all deployments in the Helm chart for users who use a custom Kubernetes scheduler\n\n### Bugfixes\n\n- Previously, types for multi-assets would display incorrectly in Dagit when specified. This has been fixed.\n- In some circumstances, viewing nested asset paths in Dagit could lead to unexpected empty states. This was due to incorrect slicing of the asset list, and has been fixed.\n- Fixed an issue in Dagit where the dialog used to wipe materializations displayed broken text for assets with long paths.\n- [dagit] Fixed the Job page to change the latest run tag and the related assets to bucket repository-specific jobs. Previously, runs from jobs with the same name in different repositories would be intermingled.\n- Previously, if you launched a backfill for a subset of a multi-asset (e.g. dbt assets), all assets would be executed on each run, instead of just the selected ones. This has been fixed.\n- [dagster-dbt] Previously, if you configured a `select` parameter on your `dbt_cli_resource` , this would not get passed into the corresponding invocations of certain `context.resources.dbt.x()` commands. This has been fixed.\n\n# 1.0.4 (core) / 0.16.4 (libraries)\n\n### New\n\n- Assets can now be materialized to storage conditionally by setting `output_required=False`. If this is set and no result is yielded from the asset, Dagster will not create an asset materialization event, the I/O manager will not be invoked, downstream assets will not be materialized, and asset sensors monitoring the asset will not trigger.\n- `JobDefinition.run_request_for_partition` can now be used inside sensors that target multiple jobs (Thanks Metin Senturk!)\n- The environment variable `DAGSTER_GRPC_TIMEOUT_SECONDS` now allows for overriding the default timeout for communications between host processes like dagit and the daemon and user code servers.\n- Import time for the `dagster` module has been reduced, by approximately 50% in initial measurements.\n- `AssetIn` now accepts a `dagster_type` argument, for specifying runtime checks on asset input values.\n- [dagit] The column names on the Activity tab of the asset details page no longer reference the legacy term “Pipeline”.\n- [dagster-snowflake] The `execute_query` method of the snowflake resource now accepts a `use_pandas_result` argument, which fetches the result of the query as a Pandas dataframe. (Thanks @swotai!)\n- [dagster-shell] Made the execute and execute_script_file utilities in dagster_shell part of the public API (Thanks Fahad Khan!)\n- [dagster-dbt] `load_assets_from_dbt_project` and `load_assets_from_dbt_manifest` now support the `exclude` parameter. (Thanks @flvndh!)\n\n### Bugfixes\n\n- [dagit] Removed the x-frame-options response header from Dagit, allowing the Dagit UI to be rendered in an iframe.\n- [fully-featured project example] Fixed the duckdb IO manager so the comment_stories step can load data successfully.\n- [dagster-dbt] Previously, if a `select` parameter was configured on the `dbt_cli_resource`, it would not be passed into invocations of `context.resources.dbt.run()` (and other similar commands). This has been fixed.\n- [dagster-ge] An incompatibility between `dagster_ge_validation_factory` and dagster 1.0 has been fixed.\n- [dagstermill] Previously, updated arguments and properties to `DagstermillExecutionContext` were not exposed. This has since been fixed.\n\n### Documentation\n\n- The integrations page on the docs site now has a section for links to community-hosted integrations. The first linked integration is @silentsokolov’s Vault integration.\n\n# 1.0.3 (core) / 0.16.3 (libraries)\n\n### New\n\n- `Failure` now has an `allow_retries` argument, allowing a means to manually bypass retry policies.\n- `dagstermill.get_context` and `dagstermill.DagstermillExecutionContext` have been updated to reflect stable dagster-1.0 APIs. `pipeline`/`solid` referencing arguments / properties will be removed in the next major version bump of `dagstermill`.\n- `TimeWindowPartitionsDefinition` now exposes a `get_cron_schedule` method.\n\n### Bugfixes\n\n- In some situations where an asset was materialized and that asset that depended on a partitioned asset, and that upstream partitioned asset wasn’t part of the run, the partition-related methods of InputContext returned incorrect values or failed erroneously. This was fixed.\n- Schedules and sensors with the same names but in different repositories no longer affect each others idempotence checks.\n- In some circumstances, reloading a repository in Dagit could lead to an error that would crash the page. This has been fixed.\n\n### Community Contributions\n\n- @will-holley added an optional `key` argument to GCSFileManager methods to set the GCS blob key, thank you!\n- Fix for sensors in [fully featured example](https://docs.dagster.io/guides/dagster/example_project#fully-featured-project), thanks @pwachira!\n\n### Documentation\n\n- New documentation for getting started with Dagster Cloud, including:\n  - [Serverless deployment documentation](https://docs.dagster.io/dagster-cloud/getting-started/getting-started-with-serverless-deployment)\n  - [Hybrid deployment documentation](https://docs.dagster.io/dagster-cloud/getting-started/getting-started-with-hybrid-deployment)\n\n# 1.0.2 (core) / 0.16.2 (libraries)\n\n### New\n\n- When the workpace is updated, a notification will appear in Dagit, and the Workspace tab will automatically refresh.\n\n### Bugfixes\n\n- Restored the correct version mismatch warnings between dagster core and dagster integration libraries\n- `Field.__init__` has been typed, which resolves an error that pylance would raise about `default_value`\n- Previously, `dagster_type_materializer` and `dagster_type_loader` expected functions to take a context argument from an internal dagster import. We’ve added `DagsterTypeMaterializerContext` and `DagsterTypeLoaderContext` so that functions annotated with these decorators can annotate their arguments properly.\n- Previously, a single-output op with a return description would not pick up the description of the return. This has been rectified.\n\n### Community Contributions\n\n- Fixed the `dagster_slack` documentation examples. Thanks @ssingh13-rms!\n\n### Documentation\n\n- New documentation for [Dagster Cloud environment variables](https://docs.dagster.io/dagster-cloud/developing-testing/environment-variables).\n- The full list of APIs removed in 1.0 has been added to the [migration guide](https://github.com/dagster-io/dagster/blob/master/MIGRATION.md).\n\n# 1.0.1 (core) / 0.16.1 (libraries)\n\n### Bugfixes\n\n- Fixed an issue where Dagster libraries would sometimes log warnings about mismatched versions despite having the correct version loaded.\n\n### Documentation\n\n- The [Dagster Cloud docs](https://docs.dagster.io/dagster-cloud) now live alongside all the other Dagster docs! Check them out by nagivating to Deployment > Cloud.\n\n# 1.0.0 (core) / 0.16.0 (libraries)\n\n## Major Changes\n\n- A docs site overhaul! Along with tons of additional content, the existing pages have been significantly edited and reorganized to improve readability.\n- All Dagster [examples](https://github.com/dagster-io/dagster/tree/master/examples)[](https://github.com/dagster-io/dagster/tree/master/examples) are revamped with a consistent project layout, descriptive names, and more helpful README files.\n- A new `dagster project `CLI contains commands for bootstrapping new Dagster projects and repositories:\n  - `dagster project scaffold` creates a folder structure with a single Dagster repository and other files such as workspace.yaml. This CLI enables you to quickly start building a new Dagster project with everything set up.\n  - `dagster project from-example` downloads one of the Dagster examples. This CLI helps you to quickly bootstrap your project with an officially maintained example. You can find the available examples via `dagster project list-examples`.\n  - Check out [Create a New Project](https://docs.dagster.io/getting-started/create-new-project) for more details.\n- A `default_executor_def` argument has been added to the `@repository` decorator. If specified, this will be used for any jobs (asset or op) which do not explicitly set an `executor_def`.\n- A `default_logger_defs` argument has been added to the `@repository` decorator, which works in the same way as `default_executor_def`.\n- A new `execute_job` function presents a Python API for kicking off runs of your jobs.\n- Run status sensors may now yield `RunRequests`, allowing you to kick off a job in response to the status of another job.\n- When loading an upstream asset or op output as an input, you can now set custom loading behavior using the `input_manager_key` argument to AssetIn and In.\n- In the UI, the global lineage graph has been brought back and reworked! The graph keeps assets in the same group visually clustered together, and the query bar allows you to visualize a custom slice of your asset graph.\n\n## Breaking Changes and Deprecations\n\n### Legacy API Removals\n\nIn 1.0.0, a large number of previously-deprecated APIs have been fully removed. A full list of breaking changes and deprecations, alongside instructions on how to migrate older code, can be found in [MIGRATION.md](https://github.com/dagster-io/dagster/blob/master/MIGRATION.md). At a high level:\n\n- The `solid` and `pipeline` APIs have been removed, along with references to them in extension libraries, arguments, and the CLI _(deprecated in `0.13.0)`_.\n- The `AssetGroup` and `build_asset_job` APIs, and a host of deprecated arguments to asset-related functions, have been removed _(deprecated in `0.15.0`)_.\n- The `EventMetadata` and `EventMetadataEntryData` APIs have been removed _(deprecated in `0.15.0`)_.\n\n### Deprecations\n\n- `dagster_type_materializer` and `DagsterTypeMaterializer` have been marked experimental and will likely be removed within a 1.x release. Instead, use an `IOManager`.\n- `FileManager` and `FileHandle` have been marked experimental and will likely be removed within a 1.x release.\n\n### Other Changes\n\n- As of 1.0.0, Dagster no longer guarantees support for python 3.6. This is in line with [PEP 494](https://peps.python.org/pep-0494/), which outlines that 3.6 has reached end of life.\n- **[planned]** In an upcoming 1.x release, we plan to make a change that renders values supplied to `configured` in Dagit. Up through this point, values provided to `configured` have not been sent anywhere outside the process where they were used. This change will mean that, like other places you can supply configuration, `configured` is not a good place to put secrets: **You should not include any values in configuration that you don't want to be stored in the Dagster database and displayed inside Dagit.**\n- `fs_io_manager`, `s3_pickle_io_manager`, and `gcs_pickle_io_manager`, and `adls_pickle_io_manager` no longer write out a file or object when handling an output with the `None` or `Nothing` type.\n- The `custom_path_fs_io_manager` has been removed, as its functionality is entirely subsumed by the `fs_io_manager`, where a custom path can be specified via config.\n- The default `typing_type` of a `DagsterType` is now `typing.Any` instead of `None`.\n- Dagster’s integration libraries haven’t yet achieved the same API maturity as Dagster core. For this reason, all integration libraries will remain on a pre-1.0 (0.16.x) versioning track for the time being. However, 0.16.x library releases remain fully compatible with Dagster 1.x. In the coming months, we will graduate integration libraries one-by-one to the 1.x versioning track as they achieve API maturity. If you have installs of the form:\n\n```\npip install dagster=={DAGSTER_VERSION} dagster-somelibrary=={DAGSTER_VERSION}\n```\n\nthis should be converted to:\n\n```\npip install dagster=={DAGSTER_VERSION} dagster-somelibrary\n```\n\nto make sure the correct library version is installed.\n\n## New since 0.15.8\n\n- [dagster-databricks] When using the `databricks_pyspark_step_launcher` the events sent back to the host process are now compressed before sending, resulting in significantly better performance for steps which produce a large number of events.\n- [dagster-dbt] If an error occurs in `load_assets_from_dbt_project` while loading your repository, the error message in Dagit will now display additional context from the dbt logs, instead of just `DagsterDbtCliFatalRuntimeError`.\n\n### Bugfixes\n\n- Fixed a bug that causes Dagster to ignore the `group_name` argument to `AssetsDefinition.from_graph` when a `key_prefix` argument is also present.\n- Fixed a bug which could cause GraphQL errors in Dagit when loading repositories that contained multiple assets created from the same graph.\n- Ops and software-defined assets with the `None` return type annotation are now given the `Nothing` type instead of the `Any` type.\n- Fixed a bug that caused `AssetsDefinition.from_graph` and `from_op` to fail when invoked on a `configured` op.\n- The `materialize` function, which is not experimental, no longer emits an experimental warning.\n- Fixed a bug where runs from different repositories would be intermingled when viewing the runs for a specific repository-scoped job/schedule/sensor.\n- [dagster-dbt] A regression was introduced in 0.15.8 that would cause dbt logs to show up in json format in the UI. This has been fixed.\n- [dagster-databricks] Previously, if you were using the `databricks_pyspark_step_launcher`, and the external step failed to start, a `RESOURCE_DOES_NOT_EXIST` error would be surfaced, without helpful context. Now, in most cases, the root error causing the step to fail will be surfaced instead.\n\n### Documentation\n\n- New [guide](https://docs.dagster.io/guides/dagster/transitioning-data-pipelines-from-development-to-production) that walks through seamlessly transitioning code from development to production environments.\n- New [guide](https://docs.dagster.io/guides/dagster/branch_deployments) that demonstrates using Branch Deployments to test Dagster code in your cloud environment without impacting your production data.\n\n# 0.15.8\n\n### New\n\n- Software-defined asset config schemas are no longer restricted to `dict`s.\n- The `OpDefinition` constructor now accept `ins` and `outs` arguments, to make direct construction easier.\n- `define_dagstermill_op` accepts `ins` and `outs` in order to make direct construction easier.\n\n### Bugfixes\n\n- Fixed a bug where default configuration was not applied when assets were selected for materialization in Dagit.\n- Fixed a bug where `RunRequests` returned from `run_status_sensors` caused the sensor to error.\n- When supplying config to `define_asset_job`, an error would occur when selecting most asset subsets. This has been fixed.\n- Fixed an error introduced in 0.15.7 that would prevent viewing the execution plan for a job re-execution from 0.15.0 → 0.15.6\n- [dagit] The Dagit server now returns `500` http status codes for GraphQL requests that encountered an unexpected server error.\n- [dagit] Fixed a bug that made it impossible to kick off materializations of partitioned asset if the `day_offset`, `hour_offset`, or `minute_offset` parameters were set on the asset’s partitions definition.\n- [dagster-k8s] Fixed a bug where overriding the Kubernetes command to use to run a Dagster job by setting the `dagster-k8s/config` didn’t actually override the command.\n- [dagster-datahub] Pinned version of `acryl-datahub` to avoid build error.\n\n### Breaking Changes\n\n- The constructor of `JobDefinition` objects now accept a config argument, and the `preset_defs` argument has been removed.\n\n### Deprecations\n\n- `DagsterPipelineRunMetadataValue` has been renamed to `DagsterRunMetadataValue`. `DagsterPipelineRunMetadataValue` will be removed in 1.0.\n\n### Community Contributions\n\n- Thanks to @hassen-io for fixing a broken link in the docs!\n\n### Documentation\n\n- `MetadataEntry` static methods are now marked as deprecated in the docs.\n- `PartitionMapping`s are now included in the API reference.\n- A dbt example and memoization example using legacy APIs have been removed from the docs site.\n\n# 0.15.7\n\n### New\n\n- `DagsterRun` now has a `job_name` property, which should be used instead of `pipeline_name`.\n- `TimeWindowPartitionsDefinition` now has a `get_partition_keys_in_range` method which returns a sequence of all the partition keys between two partition keys.\n- `OpExecutionContext` now has `asset_partitions_def_for_output` and `asset_partitions_def_for_input` methods.\n- Dagster now errors immediately with an informative message when two `AssetsDefinition` objects with the same key are provided to the same repository.\n- `build_output_context` now accepts a `partition_key` argument that can be used when testing the `handle_output` method of an IO manager.\n\n### Bugfixes\n\n- Fixed a bug that made it impossible to load inputs using a DagsterTypeLoader if the InputDefinition had an `asset_key` set.\n- Ops created with the `@asset` and `@multi_asset` decorators no longer have a top-level “assets” entry in their config schema. This entry was unused.\n- In 0.15.6, a bug was introduced that made it impossible to load repositories if assets that had non-standard metadata attached to them were present. This has been fixed.\n- [dagster-dbt] In some cases, using `load_assets_from_dbt_manifest` with a `select` parameter that included sources would result in an error. This has been fixed.\n- [dagit] Fixed an error where a race condition of a sensor/schedule page load and the sensor/schedule removal caused a GraphQL exception to be raised.\n- [dagit] The “Materialize” button no longer changes to “Rematerialize” in some scenarios\n- [dagit] The live overlays on asset views, showing latest materialization and run info, now load faster\n- [dagit] Typing whitespace into the launchpad Yaml editor no longer causes execution to fail to start\n- [dagit] The explorer sidebar no longer displays “mode” label and description for jobs, since modes are deprecated.\n\n### Community Contributions\n\n- An error will now be raised if a `@repository` decorated function expects parameters. Thanks @roeij!\n\n### Documentation\n\n- The non-asset version of the Hacker News example, which lived inside `examples/hacker_news/`, has been removed, because it hadn’t received updates in a long time and had drifted from best practices. The asset version is still there and has an updated README. Check it out [here](https://github.com/dagster-io/dagster/tree/master/examples/hacker_news_assets)\n\n# 0.15.6\n\n### New\n\n- When an exception is wrapped by another exception and raised within an op, Dagit will now display the full chain of exceptions, instead of stopping after a single exception level.\n- A `default_logger_defs` argument has been added to the `@repository` decorator. Check out [the docs](https://docs.dagster.io/concepts/logging/loggers#specifying-default-repository-loggers) on specifying default loggers to learn more.\n- `AssetsDefinition.from_graph` and `AssetsDefinition.from_op` now both accept a `partition_mappings` argument.\n- `AssetsDefinition.from_graph` and `AssetsDefinition.from_op` now both accept a `metadata_by_output_name` argument.\n- `define_asset_job` now accepts an `executor_def` argument.\n- Removed package pin for `gql` in `dagster-graphql`.\n- You can now apply a group name to assets produced with the `@multi_asset` decorator, either by supplying a `group_name` argument (which will apply to all of the output assets), or by setting the `group_name` argument on individual `AssetOut`s.\n- `InputContext` and `OutputContext` now each have an `asset_partitions_def` property, which returns the `PartitionsDefinition` of the asset that’s being loaded or stored.\n- `build_schedule_from_partitioned_job` now raises a more informative error when provided a non-partitioned asset job\n- `PartitionMapping`, `IdentityPartitionMapping`, `AllPartitionMapping`, and `LastPartitionMapping` are exposed at the top-level `dagster` package. They're currently marked experimental.\n- When a non-partitioned asset depends on a partitioned asset, you can now control which partitions of the upstream asset are used by the downstream asset, by supplying a `PartitionMapping`.\n- You can now set `PartitionMappings` on `AssetIn`.\n- [dagit] Made performance improvements to the loading of the partitions and backfill pages.\n- [dagit] The Global Asset Graph is back by popular demand, and can be reached via a new “View global asset lineage ”link on asset group and asset catalog pages! The global graph keeps asset in the same group visually clustered together and the query bar allows you to visualize a custom slice of your asset graph.\n- [dagit] Simplified the Content Security Policy and removed `frame-ancestors` restriction.\n- [dagster-dbt] `load_assets_from_dbt_project` and `load_assets_from_dbt_manifest` now support a `node_info_to_group_name_fn` parameter, allowing you to customize which group Dagster will assign each dbt asset to.\n- [dagster-dbt] When you supply a `runtime_metadata_fn` when loading dbt assets, this metadata is added to the default metadata that dagster-dbt generates, rather than replacing it entirely.\n- [dagster-dbt] When you load dbt assets with `use_build_command=True`, seeds and snapshots will now be represented as Dagster assets. Previously, only models would be loaded as assets.\n\n### Bugfixes\n\n- Fixed an issue where runs that were launched using the `DockerRunLauncher` would sometimes use Dagit’s Python environment as the entrypoint to launch the run, even if that environment did not exist in the container.\n- Dagster no longer raises a “Duplicate definition found” error when a schedule definition targets a partitioned asset job.\n- Silenced some erroneous warnings that arose when using software-defined assets.\n- When returning multiple outputs as a tuple, empty list values no longer cause unexpected exceptions.\n- [dagit] Fixed an issue with graph-backed assets causing a GraphQL error when graph inputs were type-annotated.\n- [dagit] Fixed an issue where attempting to materialize graph-backed assets caused a graphql error.\n- [dagit] Fixed an issue where partitions could not be selected when materializing partitioned assets with associated resources.\n- [dagit] Attempting to materialize assets with required resources now only presents the launchpad modal if at least one resource defines a config schema.\n\n### Breaking Changes\n\n- An op with a non-optional DynamicOutput will now error if no outputs are returned or yielded for that dynamic output.\n- If an `Output` object is used to type annotate the return of an op, an Output object must be returned or an error will result.\n\n### Community Contributions\n\n- Dagit now displays the path of the output handled by `PickledObjectS3IOManager` in run logs and Asset view. Thanks @danielgafni\n\n### Documentation\n\n- The Hacker News example now uses stable 0.15+ asset APIs, instead of the deprecated 0.14.x asset APIs.\n- Fixed the build command in the instructions for contributing docs changes.\n- [dagster-dbt] The dagster-dbt integration guide now contains information on using dbt with Software-Defined Assets.\n\n# 0.15.5\n\n### New\n\n- Added documentation and helm chart configuration for threaded sensor evaluations.\n- Added documentation and helm chart configuration for tick retention policies.\n- Added descriptions for default config schema. Fields like execution, loggers, ops, and resources are now documented.\n- UnresolvedAssetJob objects can now be passed to run status sensors.\n- [dagit] A new global asset lineage view, linked from the Asset Catalog and Asset Group pages, allows you to view a graph of assets in all loaded asset groups and filter by query selector and repo.\n- [dagit] A new option on Asset Lineage pages allows you to choose how many layers of the upstream / downstream graph to display.\n- [dagit] Dagit's DAG view now collapses large sets of edges between the same ops for improved readability and rendering performance.\n\n### Bugfixes\n\n- Fixed a bug with `materialize` that would cause required resources to not be applied correctly.\n- Fixed issue that caused repositories to fail to load when `build_schedule_from_partitioned_job` and `define_asset_job` were used together.\n- Fixed a bug that caused auto run retries to always use the `FROM_FAILURE` strategy\n- Previously, it was possible to construct Software-Defined Assets from graphs whose leaf ops were not mapped to assets. This is invalid, as these ops are not required for the production of any assets, and would cause confusing behavior or errors on execution. This will now result in an error at definition time, as intended.\n- Fixed issue where the run monitoring daemon could mark completed runs as failed if they transitioned quickly between STARTING and SUCCESS status.\n- Fixed stability issues with the sensor daemon introduced in 0.15.3 that caused the daemon to fail heartbeat checks if the sensor evaluation took too long.\n- Fixed issues with the thread pool implementation of the sensor daemon where race conditions caused the sensor to fire more frequently than the minimum interval.\n- Fixed an issue with storage implementations using MySQL server version 5.6 which caused SQL syntax exceptions to surface when rendering the Instance overview pages in Dagit.\n- Fixed a bug with the `default_executor_def` argument on repository where asset jobs that defined executor config would result in errors.\n- Fixed a bug where an erroneous exception would be raised if an empty list was returned for a list output of an op.\n- [dagit] Clicking the \"Materialize\" button for assets with configurable resources will now present the asset launchpad.\n- [dagit] If you have an asset group and no jobs, Dagit will display it by default rather than directing you to the asset catalog.\n- [dagit] DAG renderings of software-defined assets now display only the last component of the asset's key for improved readability.\n- [dagit] Fixes a regression where clicking on a source asset would trigger a GraphQL error.\n- [dagit] Fixed issue where the “Unloadable” section on the sensors / schedules pages in Dagit were populated erroneously with loadable sensors and schedules\n- [dagster-dbt] Fixed an issue where an exception would be raised when using the dbt build command with Software-Defined Assets if a test was defined on a source.\n\n### Deprecations\n\n- Removed the deprecated dagster-daemon health-check CLI command\n\n### Community Contributions\n\n- TimeWindow is now exported from the dagster package (Thanks [@nvinhphuc](https://github.com/nvinhphuc)!)\n- Added a fix to allow customization of slack messages (Thanks [@solarisa21](https://github.com/solarisa21)!)\n- [dagster-databricks] The `databricks_pyspark_step_launcher` now allows you to configure the following (Thanks [@Phazure](https://github.com/Phazure)!):\n  - the `aws_attributes` of the cluster that will be spun up for the step.\n  - arbitrary environment variables to be copied over to databricks from the host machine, rather than requiring these variables to be stored as secrets.\n  - job and cluster permissions, allowing users to view the completed runs through the databricks console, even if they’re kicked off by a service account.\n\n### Experimental\n\n- [dagster-k8s] Added `k8s_job_op` to launch a Kubernetes Job with an arbitrary image and CLI command. This is in contrast with the `k8s_job_executor`, which runs each Dagster op in a Dagster job in its own k8s job. This op may be useful when you need to orchestrate a command that isn't a Dagster op (or isn't written in Python). Usage:\n\n  ```python\n  from dagster_k8s import k8s_job_op\n\n  my_k8s_op = k8s_job_op.configured({\n   \"image\": \"busybox\",\n   \"command\": [\"/bin/sh\", \"-c\"],\n   \"args\": [\"echo HELLO\"],\n   },\n   name=\"my_k8s_op\",\n  )\n  ```\n\n- [dagster-dbt] The dbt asset-loading functions now support `partitions_def` and `partition_key_to_vars_fn` parameters, adding preliminary support for partitioned dbt assets. To learn more, check out the [Github issue](https://github.com/dagster-io/dagster/issues/7683#issuecomment-1175593637)!\n\n# 0.15.4\n\n- Reverted sensor threadpool changes from 0.15.3 to address daemon stability issues.\n\n# 0.15.3\n\n### New\n\n- When loading an upstream asset or op output as an input, you can now set custom loading behavior using the input_manager_key argument to AssetIn and In\n- The list of objects returned by a repository can now contain nested lists.\n- Added a data retention instance setting in dagster.yaml that enables the automatic removal of sensor/schedule ticks after a certain number of days.\n- Added a sensor daemon setting in dagster.yaml that enables sensor evaluations to happen in a thread pool to increase throughput.\n- `materialize_to_memory` and materialize now both have the partition_key argument.\n- `Output` and `DynamicOutput` objects now work with deep equality checks:\n\n```python\nOutput(value=5, name=\"foo\") == Output(value=5, name=\"foo\") # evaluates to True\n```\n\n- RunRequests can now be returned from run status sensors\n- Added `resource_defs` argument to `AssetsDefinition.from_graph`. Allows for specifying resources required by constituent ops directly on the asset.\n- When adding a tag to the Run search filter in Dagit by clicking the hover menu on the tag, the tag will now be appended to the filter instead of replacing the entire filter state.\n\n### Bugfixes\n\n- [dagster-dbt] An exception is now emitted if you attempt to invoke the library without having dbt-core installed. dbt-core is now also added as a dependency to the library.\n- Asset group names can now contain reserved python keywords\n- Fixed a run config parsing bug that was introduced in `0.15.1` that caused Dagit to interpret datetime strings as datetime objects and octal strings as integers.\n- Runs that have failed to start are now represented in the Instance Timeline view on Dagit.\n- Fixed an issue where the partition status was missing for partitioned jobs that had no runs.\n- Fixed a bug where op/resource invocation would error when resources were required, no context was used in the body of the function, and no context was provided when invoking.\n- [dagster-databricks] Fixed an issue where an exception related to the deprecated prior_attempts_count field when using the databricks_pyspark_step_launcher.\n- [dagster-databricks] Polling information logged from the databricks_pyspark_step_launcher is now emitted at the DEBUG level instead of INFO.\n- In the yaml editor in Dagit, the typeahead feature now correctly shows suggestions for nullable schema types.\n- When editing asset configuration in Dagit, the “Scaffold config” button in the Dagit launchpad sometimes showed the scaffold dialog beneath the launchpad. This has been fixed.\n- A recent change added execution timezones to some human-readable cron strings on schedules in Dagit. This was added incorrectly in some cases, and has now been fixed.\n- In the Dagit launchpad, a config state containing only empty newlines could lead to an error that could break the editor. This has been fixed.\n- Fixed issue that could cause partitioned graph-backed assets to attempt to load upstream inputs from the incorrect path when using the fs_io_manager (or other similar io managers).\n- [dagster-dbt] Fixed issue where errors generated from issuing dbt cli commands would only show json-formatted output, rather than a parsed, human-readable output.\n- [dagster-dbt] By default, dagster will invoke the dbt cli with a --log-format json flag. In some cases, this may cause dbt to report incorrect or misleading error messages. As a workaround, it is now possible to disable this behavior by setting the json_log_format configuration option on the dbt_cli_resource to False.\n- materialize_to_memory erroneously allowed non-in-memory io managers to be used. Now, providing io managers to materialize_to_memory will result in an error, and mem_io_manager will be provided to all io manager keys.\n\n# 0.15.2\n\n### Bugfixes\n\n- Fixed an issue where asset dependency resolution would break when two assets in the same group had the same name\n\n# 0.15.1\n\n### New\n\n- When Dagster loads an event from the event log of a type that it doesn’t recognize (for example, because it was created by a newer version of Dagster) it will now return a placeholder event rather than raising an exception.\n- AssetsDefinition.from_graph() now accepts a group_name parameter. All assets created by from_graph are assigned to this group.\n- You can define an asset from an op via a new utility method `AssetsDefinition.from_op`. Dagster will infer asset inputs and outputs from the ins/outs defined on the `@op` in the same way as `@graphs`.\n- A default executor definition can be defined on a repository using the `default_executor_def` argument. The default executor definition will be used for all op/asset jobs that don’t explicitly define their own executor.\n- `JobDefinition.run_request_for_partition` now accepts a `tags` argument (Thanks @jburnich!)\n- In Dagit, the graph canvas now has a dotted background to help it stand out from the reset of the UI.\n- `@multi_asset` now accepts a resource_defs argument. The provided resources can be either used on the context, or satisfy the io manager requirements of the outs on the asset.\n- In Dagit, show execution timezone on cron strings, and use 12-hour or 24-hour time format depending on the user’s locale.\n- In Dagit, when viewing a run and selecting a specific step in the Gantt chart, the compute log selection state will now update to that step as well.\n- `define_asset_job` and `to_job` now can now accept a `partitions_def` argument and a `config` argument at the same time, as long as the value for the `config` argument is a hardcoded config dictionary (not a `PartitionedConfig` or `ConfigMapping`)\n\n### Bugfixes\n\n- Fixed an issue where entering a string in the launchpad that is valid YAML but invalid JSON would render incorrectly in Dagit.\n- Fixed an issue where steps using the `k8s_job_executor` and `docker_executor` would sometimes return the same event lines twice in the command-line output for the step.\n- Fixed type annotations on the `@op` decorator (Thanks Milos Tomic!)\n- Fixed an issue where job backfills were not displayed correctly on the Partition view in Dagit.\n- `UnresolvedAssetJobDefinition` now supports the `run_request_for_partition` method.\n- Fixed an issue in Dagit where the Instance Overview page would briefly flash a loading state while loading fresh data.\n\n### Breaking Changes\n\n- Runs that were executed in newer versions of Dagster may produce errors when their event logs are loaded in older versions of Dagit, due to new event types that were recently added. Going forward, Dagit has been made more resilient to handling new events.\n\n### Deprecations\n\n- Updated deprecation warnings to clarify that the deprecated metadata APIs will be removed in 0.16.0, not 0.15.0.\n\n### Experimental\n\n- If two assets are in the same group and the upstream asset has a multi-segment asset key, the downstream asset doesn’t need to specify the full asset key when declaring its dependency on the upstream asset - just the last segment.\n\n### Documentation\n\n- Added dedicated sections for op, graph, and job Concept docs in the sidenav\n- Moved graph documentation from the jobs docs into its [own page](https://docs.dagster.io/concepts/ops-jobs-graphs/graphs)\n- Added documentation for assigning [asset groups](https://docs.dagster.io/concepts/assets/software-defined-assets#grouping-assets) and viewing them in Dagit\n- Added apidoc for `AssetOut` and `AssetIn`\n- Fixed a typo on the Run Configuration concept page (Thanks Wenshuai Hou!)\n- Updated screenshots in the software-defined assets tutorial to match the new Dagit UI\n- Fixed a typo in the **Defining an asset** section of the software-defined assets tutorial (Thanks Daniel Kim!)\n\n# 0.15.0 \"Cool for the Summer\"\n\n## Major Changes\n\n- Software-defined assets are now marked fully stable and are ready for prime time - we recommend using them whenever your goal using Dagster is to build and maintain data assets.\n- You can now organize software defined assets into groups by providing a group_name on your asset definition. These assets will be grouped together in Dagit.\n- Software-defined assets now accept configuration, similar to ops. E.g.\n\n  ```\n  from dagster import asset\n\n  @asset(config_schema={\"iterations\": int})\n  def my_asset(context):\n      for i in range(context.op_config[\"iterations\"]):\n          ...\n  ```\n\n- Asset definitions can now be created from graphs via `AssetsDefinition.from_graph`:\n\n  ```\n  @graph(out={\"asset_one\": GraphOut(), \"asset_two\": GraphOut()})\n  def my_graph(input_asset):\n      ...\n\n  graph_asset = AssetsDefinition.from_graph(my_graph)\n  ```\n\n- `execute_in_process` and `GraphDefinition.to_job` now both accept an `input_values` argument, so you can pass arbitrary Python objects to the root inputs of your graphs and jobs.\n- Ops that return Outputs and DynamicOutputs now work well with Python type annotations. You no longer need to sacrifice static type checking just because you want to include metadata on an output. E.g.\n\n  ```\n  from dagster import Output, op\n\n  @op\n  def my_op() -> Output[int]:\n      return Output(5, metadata={\"a\": \"b\"})\n  ```\n\n- You can now automatically re-execute runs from failure. This is analogous to op-level retries, except at the job level.\n- You can now supply arbitrary structured metadata on jobs, which will be displayed in Dagit.\n- The partitions and backfills pages in Dagit have been redesigned to be faster and show the status of all partitions, instead of just the last 30 or so.\n- The left navigation pane in Dagit is now grouped by repository, which makes it easier to work with when you have large numbers of jobs, especially when jobs in different repositories have the same name.\n- The Asset Details page for a software-defined asset now includes a Lineage tab, which makes it easy to see all the assets that are upstream or downstream of an asset.\n\n## Breaking Changes and Deprecations\n\n### Software-defined assets\n\nThis release marks the official transition of software-defined assets from experimental to stable. We made some final changes to incorporate feedback and make the APIs as consistent as possible:\n\n- Support for adding tags to asset materializations, which was previously marked as experimental, has been removed.\n- Some of the properties of the previously-experimental AssetsDefinition class have been renamed. group_names is now group_names_by_key, asset_keys_by_input_name is now keys_by_input_name, and asset_keys_by_output_name is now keys_by_output_name, asset_key is now key, and asset_keys is now keys.\n- Removes previously experimental IO manager `fs_asset_io_manager` in favor of merging its functionality with `fs_io_manager`. `fs_io_manager` is now the default IO manager for asset jobs, and will store asset outputs in a directory named with the asset key. Similarly, removed `adls2_pickle_asset_io_manager`, `gcs_pickle_asset_io_manager` , and `s3_pickle_asset_io_manager`. Instead, `adls2_pickle_io_manager`, `gcs_pickle_io_manager`, and `s3_pickle_io_manager` now support software-defined assets.\n- _(deprecation)_ The namespace argument on the `@asset` decorator and AssetIn has been deprecated. Users should use key_prefix instead.\n- _(deprecation)_ AssetGroup has been deprecated. Users should instead place assets directly on repositories, optionally attaching resources using with_resources. Asset jobs should be defined using `define_asset_job` (replacing `AssetGroup.build_job`), and arbitrary sets of assets can be materialized using the standalone function materialize (replacing `AssetGroup.materialize`).\n- _(deprecation)_ The `outs` property of the previously-experimental `@multi_asset` decorator now prefers a dictionary whose values are `AssetOut` objects instead of a dictionary whose values are `Out` objects. The latter still works, but is deprecated.\n- The previously-experimental property on `OpExecutionContext` called `output_asset_partition_key` is now deprecated in favor of `asset_partition_key_for_output`\n\n### Event records\n\n- The `get_event_records` method on DagsterInstance now requires a non-None argument `event_records_filter`. Passing a `None` value for the `event_records_filter` argument will now raise an exception where previously it generated a deprecation warning.\n- Removed methods `events_for_asset_key` and `get_asset_events`, which have been deprecated since 0.12.0.\n\n### Extension libraries\n\n- [dagster-dbt] (breaks previously-experimental API) When using the load_assets_from_dbt_project or load_assets_from_dbt_manifest , the AssetKeys generated for dbt sources are now the union of the source name and the table name, and the AssetKeys generated for models are now the union of the configured schema name for a given model (if any), and the model name. To revert to the old behavior: `dbt_assets = load_assets_from_dbt_project(..., node_info_to_asset_key=lambda node_info: AssetKey(node_info[\"name\"])`.\n- [dagster-k8s] In the Dagster Helm chart, user code deployment configuration (like secrets, configmaps, or volumes) is now automatically included in any runs launched from that code. Previously, this behavior was opt-in. In most cases, this will not be a breaking change, but in less common cases where a user code deployment was running in a different kubernetes namespace or using a different service account, this could result in missing secrets or configmaps in a launched run that previously worked. You can return to the previous behavior where config on the user code deployment was not applied to any runs by setting the includeConfigInLaunchedRuns.enabled field to false for the user code deployment. See the [Kubernetes Deployment docs](https://docs.dagster.io/deployment/guides/kubernetes/deploying-with-helm#configure-your-user-deployment) for more details.\n- [dagster-snowflake] dagster-snowflake has dropped support for python 3.6. The library it is currently built on, snowflake-connector-python, dropped 3.6 support in their recent 2.7.5 release.\n\n### Other\n\n- The `prior_attempts_count` parameter is now removed from step-launching APIs. This parameter was not being used, as the information it held was stored elsewhere in all cases. It can safely be removed from invocations without changing behavior.\n- The `FileCache` class has been removed.\n- Previously, when schedules/sensors targeted jobs with the same name as other jobs in the repo, the jobs on the sensor/schedule would silently overwrite the other jobs. Now, this will cause an error.\n\n## New since 0.14.20\n\n- A new `define_asset_job` function allows you to define a selection of assets that should be executed together. The selection can be a simple string, or an AssetSelection object. This selection will be resolved into a set of assets once placed on the repository.\n\n  ```\n  from dagster import repository, define_asset_job, AssetSelection\n\n  string_selection_job = define_asset_job(\n      name=\"foo_job\", selection=\"*foo\"\n  )\n  object_selection_job = define_asset_job(\n      name=\"bar_job\", selection=AssetSelection.groups(\"some_group\")\n  )\n\n  @repository\n  def my_repo():\n      return [\n          *my_list_of_assets,\n          string_selection_job,\n          object_selection_job,\n      ]\n  ```\n\n- [dagster-dbt] Assets loaded with `load_assets_from_dbt_project` and `load_assets_from_dbt_manifest` will now be sorted into groups based on the subdirectory of the project that each model resides in.\n- `@asset` and `@multi_asset` are no longer considered experimental.\n- Adds new utility methods `load_assets_from_modules`, `assets_from_current_module`, `assets_from_package_module`, and `assets_from_package_name` to fetch and return a list of assets from within the specified python modules.\n- Resources and io managers can now be provided directly on assets and source assets.\n\n  ```\n  from dagster import asset, SourceAsset, resource, io_manager\n\n  @resource\n  def foo_resource():\n      pass\n\n  @asset(resource_defs={\"foo\": foo_resource})\n  def the_resource(context):\n      foo = context.resources.foo\n\n  @io_manager\n  def the_manager():\n      ...\n\n  @asset(io_manager_def=the_manager)\n  def the_asset():\n      ...\n  ```\n\n  Note that assets provided to a job must not have conflicting resource for the same key. For a given job, all resource definitions must match by reference equality for a given key.\n\n- A `materialize_to_memory` method which will load the materializations of a provided list of assets into memory:\n\n  ```\n  from dagster import asset, materialize_to_memory\n\n  @asset\n  def the_asset():\n      return 5\n\n  result = materialize_to_memory([the_asset])\n  output = result.output_for_node(\"the_asset\")\n  ```\n\n- A `with_resources` method, which allows resources to be added to multiple assets / source assets at once:\n\n  ```\n  from dagster import asset, with_resources, resource\n\n  @asset(required_resource_keys={\"foo\"})\n  def requires_foo(context):\n      ...\n\n  @asset(required_resource_keys={\"foo\"})\n  def also_requires_foo(context):\n      ...\n\n  @resource\n  def foo_resource():\n      ...\n\n  requires_foo, also_requires_foo = with_resources(\n      [requires_foo, also_requires_foo],\n      {\"foo\": foo_resource},\n  )\n  ```\n\n- You can now include asset definitions directly on repositories. A `default_executor_def` property has been added to the repository, which will be used on any materializations of assets provided directly to the repository.\n\n  ```\n  from dagster import asset, repository, multiprocess_executor\n\n  @asset\n  def my_asset():\n    ...\n\n  @repository(default_executor_def=multiprocess_executor)\n  def repo():\n      return [my_asset]\n  ```\n\n- The `run_storage`, `event_log_storage`, and `schedule_storage` configuration sections of the `dagster.yaml` can now be replaced by a unified `storage` configuration section. This should avoid duplicate configuration blocks with your `dagster.yaml`. For example, instead of:\n\n  ```\n  # dagster.yaml\n  run_storage:\n  module: dagster_postgres.run_storage\n  class: PostgresRunStorage\n  config:\n      postgres_url: { PG_DB_CONN_STRING }\n  event_log_storage:\n  module: dagster_postgres.event_log\n  class: PostgresEventLogStorage\n  config:\n      postgres_url: { PG_DB_CONN_STRING }\n  schedule_storage:\n  module: dagster_postgres.schedule_storage\n  class: PostgresScheduleStorage\n  config:\n      postgres_url: { PG_DB_CONN_STRING }\n  ```\n\n  You can now write:\n\n  ```\n  storage:\n    postgres:\n      postgres_url: { PG_DB_CONN_STRING }\n  ```\n\n- All assets where a `group_name` is not provided are now part of a group called `default`.\n- The group_name parameter value for `@asset` is now restricted to only allow letters, numbers and underscore.\n- You can now [set policies to automatically retry Job runs](https://docs.dagster.io/master/deployment/run-retries). This is analogous to op-level retries, except at the job level. By default the retries pick up from failure, meaning only failed ops and their dependents are executed.\n- [dagit] The new repository-grouped left navigation is fully launched, and is no longer behind a feature flag.\n- [dagit] The left navigation can now be collapsed even when the viewport window is wide. Previously, the navigation was collapsible only for small viewports, but kept in a fixed, visible state for wide viewports. This visible/collapsed state for wide viewports is now tracked in localStorage, so your preference will persist across sessions.\n- [dagit] Queued runs can now be terminated from the Run page.\n- [dagit] The log filter on a Run page now shows counts for each filter type, and the filters have higher contrast and a switch to indicate when they are on or off.\n- [dagit] The partitions and backfill pages have been redesigned to focus on easily viewing the last run state by partition. These redesigned pages were previously gated behind a feature flag — they are now loaded by default.\n- [dagster-k8s] Overriding labels in the K8sRunLauncher will now apply to both the Kubernetes job and the Kubernetes pod created for each run, instead of just the Kubernetes pod.\n\n### Bugfixes\n\n- [dagster-dbt] In some cases, if Dagster attempted to rematerialize a dbt asset, but dbt failed to start execution, asset materialization events would still be emitted. This has been fixed.\n- [dagit] On the Instance Overview page, the popover showing details of overlapping batches of runs is now scrollable.\n- [dagit] When viewing Instance Overview, reloading a repository via controls in the left navigation could lead to an error that would crash the page due to a bug in client-side cache state. This has been fixed.\n- [dagit] When scrolling through a list of runs, scrolling would sometimes get stuck on certain tags, specifically those with content overflowing the width of the tag. This has been fixed.\n- [dagit] While viewing a job page, the left navigation item corresponding to that job will be highlighted, and the navigation pane will scroll to bring it into view.\n- [dagit] Fixed a bug where the “Scaffold config” button was always enabled.\n\n### Community Contributions\n\n- You can now provide dagster-mlflow configuration parameters as environment variables, thanks @chasleslr!\n\n### Documentation\n\n- Added a guide that helps users who are familiar with ops and graphs understand how and when to use software-defined assets.\n- Updated and reorganized docs to document software-defined assets changes since 0.14.0.\n- The Deploying in Docker example now includes an example of using the `docker_executor` to run each step of a job in a different Docker container.\n- Descriptions for the top-level fields of Dagit GraphQL queries, mutations, and subscriptions have been added.\n\n# 0.14.20\n\n### New\n\n- [dagster-aws] Added an `env_vars` field to the EcsRunLauncher that allows you to configure environment variables in the ECS task for launched runs.\n- [dagster-k8s] The `env_vars` field on `K8sRunLauncher` and `k8s_job_executor` can now except input of the form ENV_VAR_NAME=ENV_VAR_VALUE, and will set the value of ENV_VAR_NAME to ENV_VAR_VALUE. Previously, it only accepted input of the form ENV_VAR_NAME, and the environment variable had to be available in the pod launching the job.\n- [dagster-k8s] setting ‘includeConfigInLaunchedRuns’ on a user code deployment will now also include any image pull secrets from the user code deployment in the pod for the launched runs.\n\n### Bugfixes\n\n- A recent change had made it so that, when `IOManager.load_input` was called to load an asset that was not being materialized as part of the run, the provided context would not include the metadata for that asset. `context.upstream_output.metadata` now correctly returns the metadata on the upstream asset.\n- Fixed an issue where using generic type aliases introduced in Python 3.9 (like `list[str]`) as the type of an input would raise an exception.\n- [dagster-k8s] Fixed an issue where upgrading the Helm chart version without upgrading your user code deployment version would result in an “Received unexpected config entry \"scheme\" at path root:postgres_db\" error.\n\n# 0.14.19\n\n### New\n\n- Metadata can now be added to jobs (via the `metadata` parameter) and viewed in dagit. You can use it to track code owners, link to docs, or add other useful information.\n- In the Dagit launchpad, the panel below the config editor now shows more detailed information about the state of the config, including error state and whether the config requires further scaffolding or the removal of extra config.\n- FileCache is now marked for deprecation in 0.15.0.\n- In Dagit, the asset catalog now shows the last materialization for each asset and links to the latest run.\n- Assets can now have a `config_schema`. If you attempt to materialize an asset with a config schema in Dagit, you'll be able to enter the required config via a modal.\n\n### Bugfixes\n\n- [helm] Fixed an issue where string floats and integers were not properly templated as image tags.\n- [dagster-k8s] Fixed an issue when using the `k8s_job_executor` where ops with long names sometimes failed to create a pod due to a validation error with the label names automatically generated by Dagster.\n- [dagster-aws] Fixed an issue where ECS tasks with large container contexts would sometimes fail to launch because their request to the ECS RunTask API was too large.\n\n### Breaking Changes\n\n- `fs_asset_io_manager` has been removed in favor of merging its functionality with `fs_io_manager`. `fs_io_manager` is now the default IO manager for asset jobs, and will store asset outputs in a directory named with the asset key.\n\n### Community Contributions\n\n- Fixed a bug that broke the `k8s_job_executor`’s `max_conccurent` configuration. Thanks @fahadkh!\n- Fixed a bug that caused the `fs_io_manager` to incorrectly handle assets associated with upstream assets. Thanks @aroig!\n\n### Documentation\n\n- [helm] Add documentation for code server image pull secrets in the main chart.\n- The Dagster README has been revamped with documentation and community links.\n\n# 0.14.17\n\n### New\n\n- Added a pin to `protobuf` version 3 due to a backwards incompatible change in the `probobuf` version 4 release.\n- [helm] The name of the Dagit deployment can now be overridden in the Dagster Helm chart.\n- [dagit] The left navigation now shows jobs as expandable lists grouped by repository. You can opt out of this change using the feature flag in User Settings.\n- [dagit] In the left navigation, when a job has more than one schedule or sensor, clicking the schedule/sensor icon will now display a dialog containing the full list of schedules and sensors for that job.\n- [dagit] Assets on the runs page are now shown in more scenarios.\n- [dagster-dbt] dbt assets now support subsetting! In dagit, you can launch off a dbt command which will only refresh the selected models, and when you’re building jobs using `AssetGroup.build_job()`, you can define selections which select subsets of the loaded dbt project.\n- [dagster-dbt] [experimental] The `load_assets_from_dbt_manifest` function now supports an experimental `select` parameter. This allows you to use dbt selection syntax to select from an existing manifest.json file, rather than having Dagster re-compile the project on demand.\n- For software-defined assets, `OpExecutionContext` now exposes an `asset_key_for_output` method, which returns the asset key that one of the op’s outputs corresponds too.\n- The Backfills tab in Dagit loads much faster when there have been backfills that produced large numbers of runs.\n- Added the ability to run the Dagster Daemon as a Python module, by running `python -m dagster.daemon`.\n- The `non_argument_deps` parameter for the `asset` and `multi_asset` decorators can now be a set of strings in addition to a set of `AssetKey`.\n\n### Bugfixes\n\n- [dagit] In cases where Dagit is unable to make successful WebSocket connections, run logs could become stuck in a loading state. Dagit will now time out on the WebSocket connection attempt after a brief period of time. This allows run logs to fall back to http requests and move past the loading state.\n- In version 0.14.16, launching an asset materialization run with source assets would error with an `InvalidSubsetError`. This is now fixed.\n- Empty strings are no longer allowed as `AssetKey`s.\n- Fixed an issue where schedules built from partitioned job config always ran at midnight, ignoring any hour or minute offset that was specified on the config.\n- Fixed an issue where if the scheduler was interrupted and resumed in the middle of running a schedule tick that produced multiple RunRequests, it would show the same run ID multiple times on the list of runs for the schedule tick.\n- Fixed an issue where Dagit would raise a GraphQL error when a non-dictionary YAML string was entered into the Launchpad.\n- Fixed an issue where Dagster gRPC servers would sometimes raise an exception when loading repositories with many partition sets.\n- Fixed an issue where the `snowflake_io_manager` would sometimes raise an error with `pandas` 1.4 or later installed.\n- Fixed an issue where re-executing an entire set of dynamic steps together with their upstream step resulted in `DagsterExecutionStepNotFoundError`. This is now fixed.\n- [dagit] Added loading indicator for job-scoped partition backfills.\n- Fixed an issue that made it impossible to have graph-backed assets with upstream SourceAssets.\n\n### Community Contributions\n\n- `AssetIn` can now accept a string that will be coerced to an `AssetKey`. Thanks [@aroig](https://github.com/aroig)!\n- Runtime type checks improved for some asset-related functions. Thanks [@aroig](https://github.com/aroig)!\n- Docs grammar fixes. Thanks [@dwinston](https://github.com/dwinston)!\n- Dataproc ops for `dagster-gcp` now have user-configurable timeout length. Thanks [@3cham](https://github.com/3cham)!\n\n# 0.14.16\n\n### New\n\n- `AssetsDefinition.from_graph` now accepts a `partitions_def` argument.\n- `@asset`-decorated functions can now accept variable keyword arguments.\n- Jobs executed in ECS tasks now report the health status of the ECS task\n- The CLI command `dagster instance info` now prints the current schema migration state for the configured instance storage.\n- [dagster-dbt] You can now configure a `docs_url` on the `dbt_cli_resource`. If this value is set, AssetMaterializations associated with each dbt model will contain a link to the dbt docs for that model.\n- [dagster-dbt] You can now configure a `dbt_cloud_host` on the `dbt_cloud_resource`, in the case that your dbt cloud instance is under a custom domain.\n\n### Bugfixes\n\n- Fixed a bug where `InputContext.upstream_output` was missing the `asset_key` when it referred to an asset outside the run.\n- When specifying a `selection` parameter in `AssetGroup.build_job()`, the generated job would include an incorrect set of assets in certain situations. This has been fixed.\n- Previously, a set of database operational exceptions were masked with a `DagsterInstanceSchemaOutdated` exception if the instance storage was not up to date with the latest schema. We no longer wrap these exceptions, allowing the underlying exceptions to bubble up.\n- [dagster-airbyte] Fixed issue where successfully completed Airbyte syncs would send a cancellation request on completion. While this did not impact the sync itself, if alerts were set up on that connection, they would get triggered regardless of if the sync was successful or not.\n- [dagster-azure] Fixed an issue where the Azure Data Lake Storage `adls2_pickle_io_manager` would sometimes fail to recursively delete a folder when cleaning up an output.\n- Previously, if two different jobs with the same name were provided to the same repo, and one was targeted by a sensor/schedule, the job provided by the sensor/schedule would silently overwrite the other job instead of failing. In this release, a warning is fired when this case is hit, which will turn into an error in 0.15.0.\n- Dagit will now display workspace errors after reloading all repositories.\n\n### Breaking Changes\n\n- Calls to `instance.get_event_records` without an event type filter is now deprecated and will generate a warning. These calls will raise an exception starting in `0.15.0`.\n\n### Community Contributions\n\n- `@multi_asset` now supports partitioning. Thanks @aroig!\n- Orphaned process detection now works correctly across a broader set of platforms. Thanks @aroig!\n- [K8s] Added a new `max_concurrent` field to the `k8s_job_executor` that limits the number of concurrent Ops that will execute per run. Since this executor launches a Kubernetes Job per Op, this also limits the number of concurrent Kuberenetes Jobs. Note that this limit is per run, not global. Thanks @kervel!\n- [Helm] Added a new `externalConfigmap` field as an alternative to `dagit.workspace.servers` when running the user deployments chart in a separate release. This allows the workspace to be managed outside of the main Helm chart. Thanks @peay!\n- Removed the pin on `markupsafe<=2.0.1`. Thanks @[bollwyvl](https://github.com/dagster-io/dagster/commits?author=bollwyvl)!\n\n# 0.14.15\n\n### New\n\n- Sensors / schedules can now return a list of `RunRequest` objects instead of yielding them.\n- Repositories can now contain asset definitions and source assets for the same asset key.\n- `OpExecutionContext` (provided as the `context` argument to Ops) now has fields for, `run`, `job_def`, `job_name`, `op_def`, and `op_config`. These replace `pipeline_run`, `pipeline_def`, etc. (though they are still available).\n- When a job is partitioned using an hourly, daily, weekly, or monthly partitions definition, `OpExecutionContext` now offers a `partition_time_window` attribute, which returns a tuple of datetime objects that mark the bounds of the partition’s time window.\n- `AssetsDefinition.from_graph` now accepts a `partitions_def` argument.\n- [dagster-k8s] Removed an unnecessary `dagster-test-connection` pod from the Dagster Helm chart.\n- [dagster-k8s] The `k8s_job_executor` now polls the event log on a ~1 second interval (previously 0.1). Performance testing showed that this reduced DB load while not significantly impacting run time.\n- [dagit] Removed package pins for `Jinja2` and `nbconvert`.\n- [dagit] When viewing a list of Runs, tags with information about schedules, sensors, and backfills are now more visually prominent and are sorted to the front of the list.\n- [dagit] The log view on Run pages now includes a button to clear the filter input.\n- [dagit] When viewing a list of Runs, you can now hover over a tag to see a menu with an option to copy the tag, and in filtered Run views, an option to add the tag to the filter.\n- [dagit] Configuration editors throughout Dagit now display clear indentation guides, and our previous whitespace indicators have been removed.\n- [dagit] The Dagit Content-Security-Policy has been moved from a `<meta>` tag to a response header, and several more security and privacy related headers have been added as well.\n- [dagit] Assets with multi-component key paths are always shown as `foo/bar` in dagit, rather than appearing as `foo > bar` in some contexts.\n- [dagit] The Asset graph now includes a “Reload definitions” button which reloads your repositories.\n- [dagit] On all DAGs, you can hold shift on the ke"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 11.08203125,
          "content": "                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"{}\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright 2023 Dagster Labs, Inc.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "MIGRATION.md",
          "type": "blob",
          "size": 97.166015625,
          "content": "# Version migration\n\nWhen new releases include breaking changes or deprecations, this document describes how to migrate.\n\n## Migrating to 1.9.0\n\n## Database migration\n\n- This release includes database schema and data migrations to improve the performance of the Runs page. We highly recommend running these migrations to avoid slow page loads of the new Runs page. The migration will add a new column to the `runs` table, a new column to the `bulk_actions` table and a new `backfill_tags` table. A data migration will populate the new columns and table. Run `dagster instance migrate` to run the schema and data migration.\n\n## Notable behavior changes\n\n- Backfills have been moved from their own tab underneath the Overview page to entries within the table on the Runs page. This reflects the fact that backfills and runs are similar entities that share most properties. You can continue to use the legacy Runs page with the “Revert to legacy Runs page” user setting. ([GitHub Discussion](https://github.com/dagster-io/dagster/discussions/24898))\n- By default, `AutomationConditionSensorDefinitions` will now emit backfills to handle cases where more than one partition of an asset is requested on a given tick. This allows that asset's `BackfillPolicy` to be respected. This feature can be disabled by setting `allow_backfills` to `False` on the sensor definition.\n\n## Deprecations\n\n- The `DataBricksPysparkStepLauncher`, `EmrPySparkStepLauncher`, and any custom subclass of `StepLauncher` have been marked as deprecated, but will not be removed from the codebase until Dagster 2.0 is released, meaning they will continue to function as they currently do for the foreseeable future. Their functionality has been superseded by the interfaces provided by `dagster-pipes`, and so future development work will be focused there.\n- The experimental `@multi_asset_sensor` has been marked as deprecated, but will not be removed from the codebase until Dagster 2.0 is released, meaning it will continue to function as it currently does for the foreseeable future. Its functionality has been largely superseded by the `AutomationCondition` system.\n\n## Breaking changes\n\n- `dagster` no longer supports Python 3.8, which hit EOL on 2024-10-07.\n- `dagster` now requires `pydantic>=2` .\n- Passing a custom `PartitionsDefinition` subclass into a `Definitions` object now issues an error instead of a deprecation warning.\n- `AssetExecutionContext` is no longer a subclass of `OpExecutionContext`. At this release, `AssetExecutionContext` and `OpExecutionContext` implement the same methods, but in the future, the methods implemented by each class may diverge. If you have written helper functions with `OpExecutionContext` type annotations, they may need to be updated to include `AssetExecutionContext` depending on your usage. Explicit calls to `isinstance(context, OpExecutionContext)` will now fail if `context` is an `AssetExecutionContext`.\n- The `dagster/relation_identifier` metadata key has been renamed to `dagster/table_name`.\n- The `asset_selection` parameter on `AutomationConditionSensorDefinition` has been renamed to `target`, to align with existing sensor APIs.\n- The experimental `freshness_policy_sensor` has been removed, as it relies on the long-deprecated `FreshnessPolicy` API.\n- The deprecated `external_assets_from_specs` and `external_asset_from_spec` methods have been removed. Users should use `AssetsDefinition(specs=[...])`, or pass specs directly into the `Definitions` object instead.\n- `AssetKey` objects can no longer be iterated over or indexed in to. This behavior was never an intended access pattern and in all observed cases was a mistake.\n- [dagster-ge] `dagster-ge` now only supports `great_expectations>=0.17.15`. The `ge_validation_op_factory` API has been replaced with the API previously called `ge_validation_op_factory_v3`.\n- [dagster-aws] Removed deprecated parameters from `dagster_aws.pipes.PipesGlueClient.run`.\n- [dagster-embedded-elt] Removed deprecated parameter `dlt_dagster_translator` from `@dlt_assets`. The `dagster_dlt_translator` parameter should be used instead.\n\n## Migrating to 1.8.0\n\n### Notable behavior changes\n\n- The `Definitions` constructor will no longer raise errors when the provided definitions aren’t mutually resolve-able – e.g. when there are conflicting definitions with the same name, unsatisfied resource dependencies, etc. These errors will still be raised at code location load time. The new `Definitions.validate_loadable` static method also allows performing the validation steps that used to occur in constructor.\n- The “Unsynced” label on an asset is no longer transitive, i.e. it no longer displays purely on account of a parent asset being labeled “Unsynced”. This helps avoid “Unsynced label fatigue”, where huge portions of the graph often have the label because of a distant ancestor. And it also helps the asset graph UI load faster.\n- The Run Status column on the Backfills page has been removed. This column was only filled out for backfills of jobs. Users should instead click on the backfill to see the status of each run.\n- The default behavior for evaluating `AutoMaterializePolicy` and `AutomationCondition` objects has changed. Previously, all assets were evaluated in a single process on the `AssetDaemon` , and evaluation history would show up in the UI in a special-purpose tab. Now, a default `AutomationConditionSensorDefinition` with the name `\"default_automation_condition_sensor\"` will be constructed for each code location, and a history of evaluations can be accessed by navigating to the page of that sensor. These changes are intended to provide a consistent UI/UX for interacting with automation concepts, and the sensor-based APIs allow for greater isolation between separate sets of assets.\n  - The core work of these sensors is still handled by the `AssetDaemon`, so this will need to continue running for your deployment.\n  - If desired, you can retain the current behavior by setting the following in your `dagster.yaml` file:\n  ```yaml\n  auto_materialize:\n    use_sensors: true\n  ```\n- The `datetime` objects that are exposed in Dagster public APIs are now standard Python `datetime.datetime` objects with timezones, instead of [Pendulum](https://pendulum.eustace.io/docs/) `datetime` objects. Technically, this is not a breaking change since Dagster’s public API uses `datetime.datetime` in our APIs, but Pendulum datetimes expose some methods (like `add` and `subtract`) that are not available on standard `datetime.datetime` objects. If your code was using methods that are only available on `Pendulum` datetimes, you can transform your `datetimes` back to Pendulum datetimes before using them.\n\n  - For example, an asset like this:\n\n  ```python\n  from dagster import asset, AssetExecutionContext\n\n  @asset\n  def my_asset(context: AssetExecutionContext):\n    window_start, window_end = context.partition_time_window\n    in_an_hour = window_start.add(hours=1) # will break since add() is only defined in pendulum\n  ```\n\n  - could be changed to this in order to continue using pendulum datetimes:\n\n  ```python\n\n  from dagster import asset, AssetExecutionContext\n  import pendulum\n\n  @asset\n  def my_asset(context: AssetExecutionContext):\n    window_start, window_end = context.partition_time_window\n      window_start = pendulum.instance(window_start) # transform to a pendulum time\n\n    in_an_hour = window_start.add(hours=1) # will continue working\n  ```\n\n### Breaking changes\n\n- `AutoMaterializeSensorDefinition` has been renamed to `AutomationConditionSensorDefinition`. All other functionality is identical.\n- “Op job versioning and memoization”, an experimental and deprecated pre-1.0 feature, has been removed. This feature has been superseded for a long time by `code_version` , data versions, and automation conditions. `MemoizableIOManager`, `VersionStrategy`, `SourceHashVersionStrategy`, `OpVersionContext`, `ResourceVersionContext`, and `MEMOIZED_RUN_TAG` have been removed.\n- The experimental and deprecated `build_asset_with_blocking_check` has been removed. Use the `blocking` argument on `@asset_check` instead.\n- [dagster-dbt] Support for setting freshness policies through dbt metadata on field `+meta.dagster_freshness_policy` has been removed. Use `+meta.dagster.freshness_policy` instead.\n- [dagster-dbt] `KeyPrefixDagsterDbtTranslator` has been removed. To modify the asset keys for a set of dbt assets, implement`DagsterDbtTranslator.get_asset_key()` instead.\n- [dagster-dbt] Support for setting auto-materialize policies through dbt metadata on field `+meta.dagster_auto_materialize_policy` has been removed. Use `+meta.dagster.auto_materialize_policy` instead.\n- [dagster-dbt] Support for `dbt-core==1.6.*` has been removed because the version is now end-of-life.\n- [dagster-dbt] Support for `load_assets_from_dbt_project`, `load_assets_from_dbt_manifest`, and `dbt_cli_resource` has been removed. Use `@dbt_assets`, `DbtCliResource`, and `DbtProject` instead to define how to load dbt assets from a dbt project and to execute them.\n- [dagster-dbt] Support for rebuilt ops like `dbt_run_op`, `dbt_compile_op`, etc has been removed. Use `@op` and `DbtCliResource` directly to execute dbt commands in an op.\n\n### Deprecations\n\n- The experimental `external_assets_from_specs` API has been deprecated. Instead, you can directly pass `AssetSpec` objects to the `assets` argument of the `Definitions` constructor.\n- `AutoMaterializePolicy`, `AutoMaterializeRule`, and the `auto_materialize_policy` arguments to `@asset` and `AssetSpec` have been marked as deprecated, and the new `AutomationCondition` API and `automation_condition` argument should be used instead. These changes are intended to provide a more consistent, composable, and flexible experience for users interested in asset-focused automation. A full migration guide can be found [here](https://github.com/dagster-io/dagster/discussions/23495), and a more detailed explanation of the thought process behind these changes can be found in the [original RFC](https://github.com/dagster-io/dagster/discussions/22811).\n  - `AutoMaterializePolicys` and `AutomationConditions` can interoperate without issue, meaning you do not need to migrate all assets at the same time.\n- The `partitions_def` parameter on `define_asset_job` is now deprecated. The `partitions_def` for an asset job is determined from the `partitions_def` attributes on the assets it targets, so this parameter is redundant.\n- The `asset_partition_key_for_output`, `asset_partition_keys_for_output`, and `asset_partition_key_range_for_output`, and `asset_partitions_time_window_for_output` methods on `OpExecutionContext` have been deprecated. Instead, use the corresponding property: `partition_key`, `partition_keys`, `partition_key_range`, or `partition_time_window`.\n- `SourceAsset` is deprecated, in favor of `AssetSpec`. You can now use `AssetSpec`s in any of the places you could previously use `SourceAsset`s, including passing them to the `assets` argument of `Definitions`, passing them to the `assets` argument of `materialize`, and supplying them as inputs in op graphs. `AssetSpec` has all the properties that `SourceAsset` does, except for `io_manager_key`. To set an IO manager key on an `AssetSpec`, you can supply a metadata entry with the `\"dagster/io_manager_key\"` key:\n\n  ```python\n  # before\n  from dagster import SourceAsset\n  my_asset = SourceAsset(\"my_asset\", io_manager_key=\"abc\")\n\n  # after\n  from dagster import AssetSpec\n  my_asset = AssetSpec(\"my_asset\", metadata={\"dagster/io_manager_key\": \"abc\"})\n  ```\n\n- [dagster-shell] The `dagster-shell` package, which exposes `create_shell_command_op` and `create_shell_script_op`, has been deprecated. Instead, use `PipesSubprocessClient`, from the `dagster` package.\n- [dagster-airbyte] `load_assets_from_airbyte_project` is now deprecated, because the Octavia CLI that it relies on is an experimental feature that is no longer supported. Use `build_airbyte_assets` or `load_assets_from_airbyte_project` instead.\n\n## Migrating to 1.7.0\n\n### Breaking Changes\n\n- Creating a run with a custom non-UUID `run_id` was previously private and only used for testing. It will now raise an exception.\n- [community-contribution] Previously, calling `get_partition_keys_in_range` on a `MultiPartitionsDefinition` would erroneously return partition keys that were within the one-dimensional range of alphabetically-sorted partition keys for the definition. Now, this method returns the cartesian product of partition keys within each dimension’s range. Thanks, [@mst](https://github.com/mst)!\n- Added `AssetCheckExecutionContext` to replace `AssetExecutionContext` as the type of the `context` param passed in to `@asset_check` functions. `@asset_check` was an experimental decorator.\n- [experimental] `@classmethod` decorators have been removed from `[dagster-embedded-slt.sling](http://dagster-embedded-slt.sling)` `DagsterSlingTranslator`\n- [dagster-dbt] `@classmethod` decorators have been removed from `DagsterDbtTranslator`.\n- [dagster-k8s] The default merge behavior when raw kubernetes config is supplied at multiple scopes (for example, at the instance level and for a particluar job) has been changed to be more consistent. Previously, configuration was merged shallowly by default, with fields replacing other fields instead of appending or merging. Now, it is merged deeply by default, with lists appended to each other and dictionaries merged, in order to be more consistent with how kubernetes configuration is combined in all other places. See [the docs](https://docs.dagster.io/deployment/guides/kubernetes/customizing-your-deployment#precedence-rules) for more information, including how to restore the previous default merge behavior.\n\n### Deprecations\n\n- `AssetSelection.keys()` has been deprecated. Instead, you can now supply asset key arguments to `AssetSelection.assets()` .\n- Run tag keys with long lengths and certain characters are now deprecated. For consistency with asset tags, run tags keys are expected to only contain alpha-numeric characters, dashes, underscores, and periods. Run tag keys can also contain a prefix section, separated with a slash. The main section and prefix section of a run tag are limited to 63 characters.\n- `AssetExecutionContext` has been simplified. Op-related methods and methods with existing access paths have been marked deprecated. For a full list of deprecated methods see this [GitHub Discussion](https://github.com/dagster-io/dagster/discussions/20974).\n- The `metadata` property on `InputContext` and `OutputContext` has been deprecated and renamed to `definition_metadata` .\n- `FreshnessPolicy` is now deprecated. For monitoring freshness, use freshness checks instead. If you are using `AutoMaterializePolicy.lazy()`, `FreshnessPolicy` is still recommended, and will continue to be supported until an alternative is provided.\n\n## Migrating to 1.6.0\n\n### Breaking changes\n\n#### Dagster Ingestion-as-Code is being deprecated\n\nWith Dagster 1.1.8, we launched experimental “[ingestion-as-code](https://docs.dagster.io/guides/dagster/airbyte-ingestion-as-code)” functionality for our Airbyte integration, in response to user feedback that users would like to manage their Airbyte connections in code. In the months since, Airbyte has released an official [Terraform provider](https://registry.terraform.io/providers/airbytehq/airbyte/latest/docs) which accomplishes many of the same goals, making ingestion-as-code largely redundant.\n\nIn light of this, we will no longer be publishing new versions of the `dagster-managed-elements` package. `dagster_airbyte.AirbyteManagedElementReconciler` and objects in `dagster_airbyte.managed.*` will be removed.\n\nWe suggest that users consider the official Terraform provider if they would like to continue managing their connections in code.\n\n#### I/O manager `handle_output` will no longer be called when the output typing type is Nothing\n\nMost Dagster-maintained I/O managers include special logic that does not store outputs typed as `None` or `Nothing` (either via return type annotation or explicitly setting the type in `Out`).\n\nIn 1.6, the Dagster framework will no longer invoke the `IOManager.handle_output` at all for outputs with these types. This ensures that I/O managers behave consistently and protects against storing unnecessary `None` s in storage.\n\nFor some I/O managers, e.g. the `InMemoryIOManager` and some user-developed I/O managers, this change may result in input-loading errors when assets downstream try to use the default IO manager to load the upstream output:\n\n```python\n@asset\ndef upstream() -> None:\n    # when this asset is materialized, no `None` value will be stored\n\n@asset\ndef downstream(upstream):\n    # if the default IO manager is the InMemoryIOManager, then, when this asset\n    # is executed, it will hit a load_input error because it can't find the\n    # stored value corresponding to \"upstream\"\n```\n\nThe best way to avoid these errors is to write the downstream asset in a way that `IOManager.load_input` won’t be invoked:\n\n```python\n@asset(deps=[upstream])\ndef downstream():\n    # because `deps` is used instead of a function argument,\n    # IOManager.load_input won't be invoked\n```\n\n### Deprecations\n\n#### dbt\n\n- Prebuilt ops for executing common dbt Core operations (e.g. `dbt_build_op`, `dbt_compile_op`, …) have been marked as deprecated. Instead, we recommend creating your op using the `@op` decorator and `DbtCliResource` directly.\n- `load_assets_from_dbt_manifest` and `load_assets_from_dbt_project` have been marked as deprecated. Instead, we recommend using `@dbt_assets`, `DbtCliResource`, and `DagsterDbtTranslator`.\n  - For examples on how to use `@dbt_assets` and `DbtCliResource` to execute commands like `dbt run` or `dbt build` on your dbt project, see our [API docs](https://docs.dagster.io/_apidocs/libraries/dagster-dbt#dagster_dbt.dbt_assets).\n  - For examples on how to customize your dbt software-defined assets using `DagsterDbtTranslator`, see the [reference](https://docs.dagster.io/integrations/dbt/reference#understanding-asset-definition-attributes).\n  - To replicate the behavior of `load_assets_from_dbt_project`, which generates a dbt manifest at run time using `dbt parse`, see the [reference](https://docs.dagster.io/integrations/dbt/reference#loading-dbt-models-from-a-dbt-project).\n  - To replicate the behavior of `load_assets_from_dbt_manifest`:\n\n```python\n# Before, using `load_assets_from_dbt_manifest`\nfrom dagster_dbt import load_assets_from_dbt_manifest\n\nmy_dbt_assets = load_assets_from_dbt_manifest(\n    manifest=manifest,\n    use_build_command=True,\n)\n\n# After, using `@dbt_assets`, `DbtCliResource`, and `DagsterDbtTranslator\nfrom dagster import AssetExecutionContext\nfrom dagster_dbt import dbt_assets, DbtCliResource\n\n@dbt_assets(manifest=manifest)\ndef my_dbt_assets(context: AssetExecutionContext, dbt: DbtCliResource):\n    yield from dbt.cli([\"build\"], context=context).stream()\n```\n\n- When using `@dbt_assets`, if a time window partition definition is used without an explicit backfill policy, the backfill policy now defaults to a `BackfillPolicy.single_run()` instead of `BackfillPolicy.multi_run()`.\n\n## Migrating to 1.5.0\n\n### Breaking changes\n\n- The UI dialog for launching a backfill no longer includes a toggle to determine whether the backfill is launched as a single run or multiple runs. This toggle was misleading, because it implied that all backfills could be launched as single-run backfills, when it actually required special handling in the implementations of the assets targeted by the backfill to achieve this behavior. Instead, whether to execute a backfill as a single run is now determined by a setting on the asset definition. To enable single-run backfills, set `backfill_policy=BackfillPolicy.single_run()` on the asset definitions. Refer to the [docs on single-run backfills](/concepts/partitions-schedules-sensors/backfills#single-run-backfills) for more information.\n\n- `AssetExecutionContext` is now a subclass of `OpExecutionContext`, not a type alias. The code\n\n```python\ndef my_helper_function(context: AssetExecutionContext):\n    ...\n\n@op\ndef my_op(context: OpExecutionContext):\n    my_helper_function(context)\n```\n\nwill cause type checking errors. To migrate, update type hints to respect the new subclassing.\n\n- `AssetExecutionContext` cannot be used as the type annotation for `@op`s. To migrate, update the type hint in `@op` to `OpExecutionContext`. `@op`s that are used in `@graph_assets` may still use the `AssetExecutionContext` type hint.\n\n```python\n# old\n@op\ndef my_op(context: AssetExecutionContext):\n    ...\n\n# correct\n@op\ndef my_op(context: OpExecutionContext):\n    ...\n```\n\n- `AssetCheckResult(success=True)` is renamed to `AssetCheckResult(passed=True)`\n\n- Asset checks defined with Dagster version 1.4 will no longer work with Dagster Cloud, or with Dagster UI 1.5. Upgrade your `dagster` library to continue using checks.\n\n## Migrating to 1.4.0\n\n### Deprecations\n\n- The `dagit` python package and all references to it are now deprecated. We will continue to publish `dagit` and support APIs that used the term “dagit” until v2.0, but you should transition to newer `dagster-webserver` package. This is a drop-in replacement for `dagit`. Like `dagit`, it exposes an executable of the same name as the package itself, i.e. `dagster-webserver`.\n- Any Dockerfiles or other Python environment specifications used for running the webserver now use `dagster-webserver` instead, e.g.:\n\n```dockerfile\n# no (deprecated)\nRUN pip install dagster dagit ...\n...\nENTRYPOINT [\"dagit\", \"-h\", \"0.0.0.0\", \"-p\", \"3000\"]\n\n# yes\nRUN pip install dagster dagster-webserver\n...\nENTRYPOINT [\"dagster-webserver\", \"-h\", \"0.0.0.0\", \"-p\", \"3000\"]\n```\n\n- [Helm Chart] Three fields that were using the term “dagit” have been deprecated and replaced with “dagsterWebserver” instead:\n\n```yaml\n# no (deprecated)\ndagit:\n  ...\n  # ...\ningress:\n  dagit: ...\n  readOnlyDagit: ...\n\n# yes\ndagsterWebserver:\n  ...\n  # ...\ningress:\n  dagsterWebserver: ...\n  readOnlyDagsterWebserver: ...\n```\n\n- We’ve deprecated the `non_argument_deps` parameter of `@asset` and `@multi_asset` in favor of a new `deps` parameter. To update your code to use `deps`, simply rename any instances of `non_argument_deps` to `deps` and change the type from a set to list. Additionally, you may also want to begin passing the python symbols for assets, rather than their `AssetKey`s to improve in-editor experience with type-aheads and linting.\n\n```python\n@asset\ndef my_asset():\n   ...\n\n@asset(\n   non_argument_deps={\"my_asset\"}\n)\ndef a_downstream_asset():\n   ...\n\n# becomes\n\n@asset\ndef my_asset():\n   ...\n\n@asset(\n   deps=[\"my_asset\"]\n)\ndef a_downstream_asset():\n   ...\n\n# or\n\n@asset\ndef my_asset():\n   ...\n\n@asset(\n   deps=[my_asset]\n)\ndef a_downstream_asset():\n   ...\n```\n\n- [Dagster Cloud ECS Agent] We've introduced performance improvements that rely on the [AWS Resource Groups Tagging API](https://docs.aws.amazon.com/resourcegroupstagging/latest/APIReference/overview.html). To enable, grant your agent's IAM policy permission to `tag:GetResources`. Without this policy, the ECS Agent will log a deprecation warning and fall back to its old behavior (listing all ECS services in the cluster and then listing each service's tags).\n- [dagster-dbt] `DbtCliClientResource`, `dbt_cli_resource` and `DbtCliOutput` are now being deprecated in favor of `DbtCliResource`. `dagster-dbt` Asset APIs like `load_assets_from_dbt_manifest` and `load_assets_from_dbt_project` will continue to work if given either a `DbtCliClientResource` or `DbtCliResource`.\n\n```python\n# old\n@op\ndef my_dbt_op(dbt_resource: DbtCliClientResource):\n    dbt: DbtCliClient = dbt.get_client()\n\n    dbt.cli(\"run\")\n\n    dbt.cli(\"run\", full_refresh=True)\n\n    dbt.cli(\"test\")\n    manifest_json = dbt.get_manifest_json()\n\n# new\nwith Path(\"my/dbt/manifest\").open() as handle:\n    manifest = json.loads(dbt_manifest.read())\n\n@op\ndef my_dbt_op(dbt: DbtCliResource):\n   dbt.cli([\"run\"], manifest=manifest).stream()\n\n   dbt.cli([\"run\", \"--full-refresh\"], manifest=manifest).stream()\n\n   dbt_test_invocation = dbt.cli([\"test\"], manifest_manifest).stream()\n   manifest_json = dbt_test_invocation.get_artifact(\"manifest.json\")\n\n# old\ndbt_assets = load_assets_from_dbt_project(project_dir=\"my/dbt/project\")\n\ndefs = Definitions(\n    assets=dbt_assets,\n    resources={\n        \"dbt\": DbtCliClientResource(project_dir=\"my/dbt/project\")\n    },\n)\n\n# new\ndbt_assets = load_assets_from_dbt_project(project_dir=\"my/dbt/project\")\n\ndefs = Definitions(\n    assets=dbt_assets,\n    resources={\n        \"dbt\": DbtCliResource(project_dir=\"my/dbt/project\")\n    }\n)\n\n```\n\n- The following arguments on `load_assets_from_dbt_project` and `load_assets_from_dbt_manifest` are now deprecated in favor of other options. Arguments will continue to work when passed into these functions, but a deprecation warning will be emitted.\n\n| Deprecated Arguments                      | Recommendation                                                                                                                                                   |\n| ----------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `key_prefix`                              | Instead, provide a custom `DagsterDbtTranslator` that overrides `get_asset_key`                                                                                  |\n| `source_key_prefix`                       | Instead, provide a custom `DagsterDbtTranslator` that overrides `get_asset_key`                                                                                  |\n| `op_name`                                 | Use the `@dbt_assets` decorator if you need to customize your op name.                                                                                           |\n| `manifest_json`                           | Use the `manifest` parameter instead.                                                                                                                            |\n| `display_raw_sql`                         | Instead, provide a custom `DagsterDbtTranslator` that overrides `get_description`.                                                                               |\n| `selected_unique_ids`                     | Use the `select` parameter instead.                                                                                                                              |\n| `dbt_resource_key`                        | Use the `@dbt_assets` decorator if you need to customize your resource key.                                                                                      |\n| `use_build_command`                       | Use the `@dbt_assets` decorator if you need to customize the underlying dbt commands.                                                                            |\n| `partitions_def`                          | Use the `@dbt_assets` decorator to define partitioned dbt assets.                                                                                                |\n| `partition_key_to_vars_fn`                | Use the `@dbt_assets` decorator to define partitioned dbt assets.                                                                                                |\n| `runtime_metadata_fn`                     | Use the `@dbt_assets` decorator if you need to customize runtime metadata.                                                                                       |\n| `node_info_to_asset_key_fn`               | Instead, provide a custom `DagsterDbtTranslator` that overrides `get_asset_key`.                                                                                 |\n| `node_info_to_group_fn`                   | Instead, configure dagster groups on a dbt resource's meta field, assign dbt groups, or provide a custom `DagsterDbtTranslator` that overrides `get_group_name`. |\n| `node_info_to_auto_materialize_policy_fn` | Instead, configure Dagster auto-materialize policies on a dbt resource's meta field.                                                                             |\n| `node_info_to_freshness_policy_fn`        | Instead, configure Dagster freshness policies on a dbt resource's meta field.                                                                                    |\n| `node_info_to_definition_metadata_fn`     | Instead, provide a custom `DagsterDbtTranslator` that overrides `get_metadata`.                                                                                  |\n\n### Breaking changes\n\n- From this release forward Dagster will no longer be tested against Python 3.7. Python 3.7 reached end of life on June 27th 2023 meaning it will no longer receive any security fixes. Previously releases will continue to work on 3.7. Details about moving to 3.8 or beyond can be found at https://docs.python.org/3/whatsnew/3.8.html#porting-to-python-3-8 .\n- `build_asset_reconciliation_sensor` (Experimental) has been removed. It was deprecated in 1.3 in favor of `AutoMaterializePolicy`. Docs are [here](https://docs.dagster.io/concepts/assets/asset-auto-execution).\n- The `dagster-dbt` integration with `dbt-rpc` has been removed, as [the dbt plugin is being deprecated](https://github.com/dbt-labs/dbt-rpc).\n- Previously, `DbtCliResource` was a class alias for `DbtCliClientResource`. Now, `DbtCliResource` is a new resource with a different API. Furthermore, it requires at least `dbt-core>=1.4` to run.\n- [Helm Chart] If upgrading an existing installation to 1.4 and the `dagit.nameOverride` value is set, you will need to either change the value or delete the existing deployment to allow helm to update values that can not be patched for the rename from dagit to dagster-webserver.\n- [dagster-dbt] `load_assets_from_dbt_project` and `load_assets_from_dbt_manifest` now default to `use_build=True`. To switch back to the previous behavior, use `use_build=False`.\n\n```python\nfrom dagster_dbt import group_from_dbt_resource_props_fallback_to_directory\n\nload_assets_from_dbt_project(\n    ...,\n    use_build=False,\n)\n```\n\n- [dagster-dbt] The default assignment of groups to dbt models loaded from `load_assets_from_dbt_project` and `load_assets_from_dbt_manifest` has changed. Rather than assigning a group name using the model’s subdirectory, a group name will be assigned using the dbt model’s [dbt group](https://docs.getdbt.com/docs/build/groups). To switch back to the previous behavior, use the following utility function, `group_from_dbt_resource_props_fallback_to_directory`:\n\n```python\nfrom dagster_dbt import group_from_dbt_resource_props_fallback_to_directory\n\nload_assets_from_dbt_project(\n    ...,\n    node_info_to_group_fn=group_from_dbt_resource_props_fallback_to_directory,\n)\n```\n\n- [dagster-dbt] The argument `node_info_to_definition_metadata_fn` for `load_assets_from_dbt_project` and `load_assets_from_dbt_manifest` now overrides metadata instead of adding to it. To switch back to the previous behavior, use the following utility function:\n\n```python\nfrom dagster_dbt import default_metadata_from_dbt_resource_props\n\ndef my_metadata_from_dbt_resource_props(dbt_resource_props):\n    my_metadata = {...}\n    return {**default_metadata_from_dbt_resource_props(dbt_resource_props), **my_metadata}\n\nload_assets_from_dbt_manifest(\n    ...,\n    node_info_to_definition_metadata_fn=my_metadata_from_dbt_resource_props\n)\n```\n\n- [dagster-dbt] The arguments for `load_assets_from_dbt_project` and `load_assets_from_dbt_manifest` now must be specified using keyword arguments.\n- [dagster-dbt] When using the new `DbtCliResource` with `load_assets_from_dbt_project` and `load_assets_from_dbt_manifest`, stdout logs from the dbt process will now appear in the compute logs instead of the event logs. To view these compute logs, you should ensure that your Dagster instance has [compute log storage configured](https://docs.dagster.io/deployment/dagster-instance#compute-log-storage).\n\n## Migrating to 1.3.0\n\n### Deprecations\n\n- **[deprecation, 1.4.0]** `build_asset_reconciliation_sensor`, which was experimental, is now deprecated, in favor of setting `AutoMaterializePolicy` on assets. Refer to the docs on `AutoMaterializePolicy` for how this works: [https://docs.dagster.io/concepts/assets/asset-auto-execution](https://docs.dagster.io/concepts/assets/asset-auto-execution).\n- **[deprecation, 2.0.0]** Previously, the recommended pattern for creating a run request for a given partition of a job within a sensor was `yield job_def.run_request_for_partition(partition_key=\"...\")`. This has been deprecated, in favor of `yield RunRequest(partition_key=\"...\")`.\n\n### Breaking Changes\n\n- By default, resources defined on `Definitions` are now automatically bound to jobs. This will only result in a change in behavior if you a) have a job with no \"io_manager\" defined in its `resource_defs` and b) have supplied an `IOManager` with key \"io_manager\" to the `resource_defs` argument of your `Definitions`. Prior to 1.3.0, this would result in the job using the default filesystem-based `IOManager` for the key \"io_manager\". In 1.3.0, this will result in the \"io_manager\" supplied to your `Definitions` being used instead. The `BindResourcesToJobs` wrapper, introduced in 1.2 to simulate this behavior, no longer has any effect.\n- **[experimental]** The `minutes_late` and `previous_minutes_late` properties on the experimental `FreshnesPolicySensorContext` have been renamed to `minutes_overdue` and `previous_minutes_overdue`, respectively.\n- **[previously deprecated, 0.15.0]** The `metadata_entries` arguments to user-constructed events (`AssetObservation`,  `AssetMaterialization`,  `ExpectationResult`,  `TypeCheck`,  `Failure`,  `Output`,  `DynamicOutput`), as well as the `DagsterType` object have been removed. Instead, a dictionary of metadata should be passed into the `metadata` argument.\n- **[dagster-celery-k8s]** The default kubernetes namespace for run pods when using the Dagster Helm chart with the `CeleryK8sRunLauncher` is now the same namespace as the Helm chart, instead of the `default` namespace. To restore the previous behavior, you can set the `celeryK8sRunLauncher.jobNamespace` field to the string `default`.\n- **[dagster-snowflake-pandas]** Prior to `dagster-snowflake` version `0.19.0` the Snowflake I/O manager converted all timestamp data to strings before loading the data in Snowflake, and did the opposite conversion when fetching a DataFrame from Snowflake. The I/O manager now ensures timestamp data has a timezone attached and stores the data as TIMESTAMP_NTZ(9) type. If you used the Snowflake I/O manager prior to version `0.19.0` you can set the `store_timestamps_as_strings=True` configuration value for the Snowflake I/O manager to continue storing time data as strings while you do table migrations.\n\nTo migrate a table created prior to `0.19.0` to one with a TIMESTAMP_NTZ(9) type, you can run the follow SQL queries in Snowflake. In the example, our table is located at `database.schema.table` and the column we want to migrate is called `time`:\n\n```sql\n\n// Add a column of type TIMESTAMP_NTZ(9)\nALTER TABLE database.schema.table\nADD COLUMN time_copy TIMESTAMP_NTZ(9)\n\n// copy the data from time and convert to timestamp data\nUPDATE database.schema.table\nSET time_copy = to_timestamp_ntz(time)\n\n// drop the time column\nALTER TABLE database.schema.table\nDROP COLUMN time\n\n// rename the time_copy column to time\nALTER TABLER database.schema.table\nRENAME COLUMN time_copy TO time\n\n```\n\n## Migrating to 1.2.0\n\n### Database migration\n\n1.2.0 adds a set of optional database schema migrations, which can be run via `dagster instance migrate`:\n\n- Improves Dagit performance by adding a database index which should speed up job run views.\n- Enables dynamic partitions definitions by creating a database table to store partition keys. This feature is experimental and may require future migrations.\n- Adds a primary key `id` column to the `kvs`, `daemon_heartbeats` and `instance_info` tables, enforcing that all tables have a primary key.\n\n### Breaking changes\n\n#### Core changes\n\n- The minimum `grpcio` version supported by Dagster has been increased to 1.44.0 so that Dagster can support both `protobuf` 3 and `protobuf` 4. Similarly, the minimum `protobuf` version supported by Dagster has been increased to 3.20.0. We are working closely with the gRPC team on resolving the upstream issues keeping the upper-bound `grpcio` pin in place in Dagster, and hope to be able to remove it very soon.\n- Prior to 0.9.19, asset keys were serialized in a legacy format. This release removes support for querying asset events serialized with this legacy format. Contact #dagster-support for tooling to migrate legacy events to the supported version. Users who began using assets after 0.9.19 will not be affected by this change.\n\n#### Changes to experimental APIs\n\n- [experimental] `LogicalVersion` has been renamed to `DataVersion` and `LogicalVersionProvenance` has been renamed to `DataProvenance`.\n- [experimental] Methods on the experimental `DynamicPartitionsDefinition` to add, remove, and check for existence of partitions have been removed. Refer to documentation for updated API methods.\n\n#### Removal of deprecated APIs\n\n- [previously deprecated, 0.15.0] Static constructors on `MetadataEntry` have been removed.\n- [previously deprecated, 1.0.0] `DagsterTypeMaterializer`, `DagsterTypeMaterializerContext`, and `@dagster_type_materializer` have been removed.\n- [previously deprecated, 1.0.0] `PartitionScheduleDefinition` has been removed.\n- [previously deprecated, 1.0.0] `RunRecord.pipeline_run` has been removed (use `RunRecord.dagster_run`).\n- [previously deprecated, 1.0.0] `DependencyDefinition.solid` has been removed (use `DependencyDefinition.node`).\n- [previously deprecated, 1.0.0] The `pipeline_run` argument to `build_resources` has been removed (use `dagster_run`)\n\n#### Extension Libraries\n\n- [dagster-snowflake] The `execute_query`and `execute_queries` methods of the `SnowflakeResource` now have consistent behavior based on the values of the `fetch_results` and `use_pandas_result` parameters. If `fetch_results` is True, the standard Snowflake result will be returned. If `fetch_results` and `use_pandas_result` are True, a pandas DataFrame will be returned. If `fetch_results` is False and `use_pandas_result` is True, an error will be raised. If both are False, no result will be returned.\n- [dagster-snowflake] The `execute_queries` command now returns a list of DataFrames when `use_pandas_result` is True, rather than appending the results of each query to a single DataFrame.\n- [dagster-shell] The default behavior of the `execute` and `execute_shell_command` functions is now to include any environment variables in the calling op. To restore the previous behavior, you can pass in `env={}` to these functions.\n- [dagster-k8s] Several Dagster features that were previously disabled by default in the Dagster Helm chart are now enabled by default. These features are:\n\n  - The [run queue](https://docs.dagster.io/deployment/run-coordinator#limiting-run-concurrency) (by default, without a limit). Runs will now always be launched from the Daemon.\n  - Run queue parallelism - by default, up to 4 runs can now be pulled off of the queue at a time (as long as the global run limit or tag-based concurrency limits are not exceeded).\n  - [Run retries](https://docs.dagster.io/deployment/run-retries#run-retries) - runs will now retry if they have the `dagster/max_retries` tag set. You can configure a global number of retries in the Helm chart by setting `run_retries.max_retries` to a value greater than the default of 0.\n  - Schedule and sensor parallelism - by default, the daemon will now run up to 4 sensors and up to 4 schedules in parallel.\n  - [Run monitoring](https://docs.dagster.io/deployment/run-monitoring) - Dagster will detect hanging runs and move them into a FAILURE state for you (or start a retry for you if the run is configured to allow retries). By default, runs that have been in STARTING for more than 5 minutes will be assumed to be hanging and will be terminated.\n\n  Each of these features can be disabled in the Helm chart to restore the previous behavior.\n\n- [dagster-k8s] The experimental `[k8s_job_op](https://docs.dagster.io/_apidocs/libraries/dagster-k8s#dagster_k8s.k8s_job_op)` op and `[execute_k8s_job](https://docs.dagster.io/_apidocs/libraries/dagster-k8s#dagster_k8s.execute_k8s_job)` functions no longer automatically include configuration from a `dagster-k8s/config` tag on the Dagster job in the launched Kubernetes job. To include raw Kubernetes configuration in a `k8s_job_op`, you can set the `container_config`, `pod_template_spec_metadata`, `pod_spec_config`, or `job_metadata` config fields on the `k8s_job_op` (or arguments to the `execute_k8s_job` function).\n- [dagster-databricks] The integration has now been refactored to support the official Databricks API.\n  - `create_databricks_job_op` is now deprecated. To submit one-off runs of Databricks tasks, you must now use the `create_databricks_submit_run_op`.\n  - The Databricks token that is passed to the `databricks_client` resource must now begin with `https://`.\n\n## Migrating to 1.1.1\n\n### Database migration\n\nTwo optional database schema migrations, which can be run via `dagster instance migrate`:\n\n- Improves Dagit performance by adding database indexes which should speed up the run view as well as a range of asset-based queries.\n- Enables multi-dimensional asset partitions and asset versioning.\n\n### Breaking changes and deprecations\n\n- `define_dagstermill_solid`, a legacy API, has been removed from `dagstermill`. Use `define_dagstermill_op` or `define_dagstermill_asset` instead to create an `op` or `asset` from a Jupyter notebook, respectively.\n- The internal `ComputeLogManager` API is marked as deprecated in favor of an updated interface: `CapturedLogManager`. It will be removed in `1.2.0`. This should only affect dagster instances that have implemented a custom compute log manager.\n\n## Migrating to 1.0\n\n- Most of the classes and decorators in Dagster have moved to using a bare asterisk argument, enforcing that arguments are provided as keywords. **If using long lists of non-keyword arguments with dagster decorators or classes, you will likely run into errors in 1.0.** This can be fixed by switching to using keyword arguments.\n- In an upcoming 1.x release, we plan to make a change that renders values supplied to `configured` in Dagit. Up through this point, values provided to `configured` have not been sent anywhere outside the process where they were used. This change will mean that, like other places you can supply configuration, `configured` is not a good place to put secrets: **You should not include any values in configuration that you don't want to be stored in the Dagster database and displayed inside Dagit.**\n- **All submodules of dagster have been marked private.** We currently provide aliasing to avoid incurring linting errors, but in a future 1.x release, this will be removed, and imports from submodules of dagster may incur errors.\n- The `dagster.experimental` submodule has been deleted, which previously contained dynamic output APIs, which are available from the top level of the `dagster` module.\n- As of 1.0, **Dagster no longer guarantees support for python 3.6.** This is in line with [PEP 494](https://peps.python.org/pep-0494/), which outlines that 3.6 has reached end of life.\n- Dagster’s integration libraries haven’t yet achieved the same API maturity as Dagster core. For this reason, all integration libraries will remain on a pre-1.0 (0.16.x) versioning track for the time being. However, 0.16.x library releases remain fully compatible with Dagster 1.x. In the coming months, we will graduate integration libraries one-by-one to the 1.x versioning track as they achieve API maturity. If you have installs of the form:\n\n```\npip install dagster=={DAGSTER_VERSION} dagster-somelibrary=={DAGSTER_VERSION}\n```\n\nthis should be converted to:\n\n```\npip install dagster=={DAGSTER_VERSION} dagster-somelibrary\n```\n\nto make sure the correct library version is installed.\n\n### Legacy API Removals\n\n- Dagster's legacy APIs, which were marked \"legacy\" in 0.13.0, have been removed. This includes `@solid`, `SolidDefinition`, `@pipeline`, `PipelineDefinition`, `@composite_solid`, `CompositeSolidDefinition`, `ModeDefinition`, `PresetDefinition`, `PartitionSetDefinition`, `InputDefinition`, `OutputDefinition`, `DynamicOutputDefinition`, `pipeline_failure_sensor`, `@hourly_schedule`, `@daily_schedule`, `@weekly_schedule`, and `@monthly_schedule`. [Here is a guide](https://legacy-versioned-docs.dagster.dagster-docs.io/0.15.6/guides/dagster/graph_job_op) to migrating from the legacy APIs to the stable APIs.\n- Deprecated arguments to library ops have been switched to reflect stable APIs. This includes `input_defs`/`output_defs` arguments on `define_dagstermill_op`, which have been changed to `ins`/`outs` respectively, and `input_defs` argument on `create_shell_script_op`, which has been changed to `ins`.\n- The `pipeline_selection` argument has been removed from `run_failure_sensor` and related decorators / functions, and `job_selection` has been deprecated. Instead, use `monitored_jobs`.\n- `ScheduleExecutionContext` and `SensorExecutionContext` APIs have been removed. In 0.13.0, these were renamed to `ScheduleEvaluationContext` and `SensorEvaluationContext` respectively, and marked deprecated.\n- Along with the rest of the legacy APIs, `execute_pipeline` has been removed. The functionality previously supplied by `execute_pipeline` has been split between `JobDefinition.execute_in_process` ([docs](https://docs.dagster.io/_apidocs/jobs#dagster.JobDefinition.execute_in_process)) and `execute_job` ([docs](https://docs.dagster.io/_apidocs/execution#dagster.execute_job)). If you were previously using `execute_pipeline` for in-process testing, then `JobDefinition.execute_in_process` should replace. If using `execute_pipeline` for out-of-process execution, or non-testing workflows, then `execute_job` is the recommended replacement.\n- Alongside other removals of pipeline-related APIs, the `dagster pipeline` CLI subgroup has been removed in favor of `dagster job`.\n- The `dagster new-project` CLI subgroup has been removed in favor of `dagster project`.\n- `AssetGroup` and `build_assets_job`, which were advertised in an experimental iteration of software-defined assets, have been removed. Instead, check out the docs on [grouping assets](https://docs.dagster.io/concepts/assets/software-defined-assets#assigning-assets-to-groups), and the docs on [defining asset jobs](https://docs.dagster.io/concepts/ops-jobs-graphs/jobs#from-software-defined-assets).\n- The deprecated `partition_mappings` arguments on `@asset` and `@multi_asset` have been removed. Instead, user the `partition_mapping` argument the corresponding `AssetIn`s.\n- The deprecated `namespace` arguments on `@asset` and `AssetIn` have been removed. Instead, use the `key_prefix` argument.\n- The `input_defs` and `output_defs` arguments on [OpDefinition](https://docs.dagster.io/_apidocs/ops#dagster.OpDefinition) have been removed, and replaced with `ins` and `outs` arguments. `input_defs`/`output_defs` have been deprecated since 0.13.0.\n- The `preset_defs` argument on [JobDefinition](https://docs.dagster.io/_apidocs/jobs#dagster.JobDefinition) has been removed. When constructing a `JobDefinition` directly, config can be provided using the `config` argument instead. `preset_defs` has been deprecated since 0.13.0.\n- `EventMetadata` and `EventMetadataEntryData` APIs have been removed. Instead, metadata should be specified using the [MetadataValue](https://docs.dagster.io/_apidocs/ops#dagster.MetadataValue) APIs.\n- APIs referencing pipelines/solids in extension libraries have been removed. This includes `define_dagstermill_solid`, `make_dagster_pipeline_from_airflow_dag`, `create_databricks_job_solid`, the various `dbt_cli_*` and `dbt_rpc_*` solids, `bq_solid_for_queries`, `ge_validation_solid_factory`, `end_mlflow_run_on_pipeline_finished`, the various `shell_command_solid` APIs, `make_slack_on_pipeline_failure_sensor`, `snowflake_solid_for_query`, `end_mlflow_run_on_pipeline_finished`, and `create_spark_solid`.\n- `custom_path_fs_io_manager` has been removed, as its functionality is entirely subsumed by the `fs_io_manager`, where a custom path can be specified via config.\n\n### Removed API List\n\nThis serves as an exhaustive list of the removed APIs.\n\nFrom the main Dagster module:\n\n- `AssetGroup`\n- `DagsterPipelineRunMetadataValue`\n- `CompositeSolidDefinition`\n- `InputDefinition`\n- `Materialization`\n- `ModeDefinition`\n- `OutputDefinition`\n- `PipelineDefinition`\n- `PresetDefinition`\n- `SolidDefinition`\n- `SolidInvocation`\n- `DynamicOutputDefinition`\n- `composite_solid`\n- `lambda_solid`\n- `pipeline`\n- `solid`\n- `pipeline_failure_sensor`\n- `CompositeSolidExecutionResult`\n- `PipelineExecutionResult`\n- `SolidExecutionResult`\n- `SolidExecutionContext`\n- `build_solid_context`\n- `PipelineRun`\n- `PipelineRunStatus`\n- `default_executors`\n- `execute_pipeline_iterator`\n- `execute_pipeline`\n- `execute_solid_within_pipeline`\n- `reexecute_pipeline_iterator`\n- `reexecute_pipeline`\n- `execute_solid`\n- `execute_solids_within_pipeline`\n- `build_assets_job`\n- `schedule_from_partitions`\n- `PartitionSetDefinition`\n- `ScheduleExecutionContext`\n- `SensorExecutionContext`\n- `PipelineFailureSensorContext`\n- `daily_schedule`\n- `hourly_schedule`\n- `monthly_schedule`\n- `weekly_schedule`\n- `create_offset_partition_selector`\n- `date_partition_range`\n- `identity_partition_selector`\n- `custom_path_fs_io_manager`\n\nFrom libraries (APIs removed in 0.16.0 onwards):\n\n- `dagster_airflow.make_dagster_pipeline_from_airflow_dag`\n- `dagster_databricks.create_databricks_job_solid`\n- `dagster_dbt.dbt_cli_compile`\n- `dagster_dbt.dbt_cli_run`\n- `dagster_dbt.dbt_cli_run_operation`\n- `dagster_dbt.dbt_cli_snapshot`\n- `dagster_dbt.dbt_cli_snapshot_freshness`\n- `dagster_dbt.dbt_cli_test`\n- `dagster_dbt.create_dbt_rpc_run_sql_solid`\n- `dagster_dbt.dbt_rpc_run`\n- `dagster_dbt.dbt_rpc_run_and_wait`\n- `dagster_dbt.dbt_rpc_run_operation`\n- `dagster_dbt.dbt_rpc_run_operation_and_wait`\n- `dagster_dbt.dbt_rpc_snapshot`\n- `dagster_dbt.dbt_rpc_snapshot_and_wait`\n- `dagster_dbt.dbt_rpc_snapshot_freshness`\n- `dagster_dbt.dbt_rpc_snapshot_freshness_and_wait`\n- `dagster_dbt.dbt_rpc_test`\n- `dagster_dbt.dbt_rpc_test_and_wait`\n- `dagster_gcp.bq_solid_for_queries`\n- `dagster_ge.ge_validation_solid_factory`\n- `dagster_mlflow.end_mlflow_run_on_pipeline_finishes`\n- `dagster_shell.create_shell_command_solid`\n- `dagster_shell.create_shell_script_solid`\n- `dagster_shell.shell_solid`\n- `dagster_slack.make_slack_on_pipeline_failure_sensor`\n- `dagster_msteams.make_teams_on_pipeline_failure_sensor`\n- `dagster_snowflake.snowflake_solid_for_query`\n- `dagster_spark.create_spark_solid`\n\n## Migrating to 0.15.0\n\nAll items below are breaking changes unless marked with _(deprecation)_.\n\n### Software-defined assets\n\nThis release marks the official transition of software-defined assets from experimental to stable. We made some final changes to incorporate feedback and make the APIs as consistent as possible:\n\n- Support for adding tags to asset materializations, which was previously marked as experimental, has been removed.\n- Some of the properties of the previously-experimental AssetsDefinition class have been renamed. group_names is now group_names_by_key, asset_keys_by_input_name is now keys_by_input_name, and asset_keys_by_output_name is now keys_by_output_name, asset_key is now key, and asset_keys is now keys.\n- fs_asset_io_manager has been removed in favor of merging its functionality with fs_io_manager. fs_io_manager is now the default IO manager for asset jobs, and will store asset outputs in a directory named with the asset key. Similarly, removed adls2_pickle_asset_io_manager, gcs_pickle_asset_io_manager , and s3_pickle_asset_io_manager. Instead, adls2_pickle_io_manager, gcs_pickle_io_manager , and s3_pickle_io_manager now support software-defined assets.\n- _(deprecation)_ The namespace argument on the @asset decorator and AssetIn has been deprecated. Users should use key_prefix instead.\n- _(deprecation)_ AssetGroup has been deprecated. Users should instead place assets directly on repositories, optionally attaching resources using with_resources. Asset jobs should be defined using define_asset_job (replacing AssetGroup.build_job), and arbitrary sets of assets can be materialized using the standalone function materialize (replacing AssetGroup.materialize).\n- _(deprecation)_ The outs property of the previously-experimental @multi_asset decorator now prefers a dictionary whose values are AssetOut objects instead of a dictionary whose values are Out objects. The latter still works, but is deprecated.\n\n### Event records\n\n- The get_event_records method on DagsterInstance now requires a non-None argument event_records_filter. Passing a None value for the event_records_filter argument will now raise an exception where previously it generated a deprecation warning.\n- Removed methods events_for_asset_key and get_asset_events, which have been deprecated since 0.12.0.\n\n### Extension libraries\n\n- [dagster-dbt] (breaks previously-experimental API) When using the load_assets_from_dbt_project or load_assets_from_dbt_manifest , the AssetKeys generated for dbt sources are now the union of the source name and the table name, and the AssetKeys generated for models are now the union of the configured schema name for a given model (if any), and the model name. To revert to the old behavior: dbt_assets = load_assets_from_dbt_project(..., node_info_to_asset_key=lambda node_info: AssetKey(node_info[\"name\"]).\n- [dagster-k8s] In the Dagster Helm chart, user code deployment configuration (like secrets, configmaps, or volumes) is now automatically included in any runs launched from that code. Previously, this behavior was opt-in. In most cases, this will not be a breaking change, but in less common cases where a user code deployment was running in a different kubernetes namespace or using a different service account, this could result in missing secrets or configmaps in a launched run that previously worked. You can return to the previous behavior where config on the user code deployment was not applied to any runs by setting the includeConfigInLaunchedRuns.enabled field to false for the user code deployment. See the Kubernetes Deployment docs (https://docs.dagster.io/deployment/guides/kubernetes/deploying-with-helm#configure-your-user-deployment) for more details.\n- [dagster-snowflake] dagster-snowflake has dropped support for python 3.6. The library it is currently built on, snowflake-connector-python, dropped 3.6 support in their recent 2.7.5 release.\n\n### Other\n\n- The prior_attempts_count parameter is now removed from step-launching APIs. This parameter was not being used, as the information it held was stored elsewhere in all cases. It can safely be removed from invocations without changing behavior.\n- The FileCache class has been removed.\n- Previously, when schedules/sensors targeted jobs with the same name as other jobs in the repo, the jobs on the sensor/schedule would silently overwrite the other jobs. Now, this will cause an error.\n\n## Migrating to 0.14.0\n\nIf migrating from below 0.13.17, you can run\n\n```\ndagster instance migrate\n```\n\nThis optional migration makes performance improvements to the runs page in Dagit.\n\n### Breaking Changes\n\n- The Dagster Daemon now uses the same workspace.yaml file as Dagit to locate your Dagster code. You should ensure that if you make any changes to your workspace.yaml file, they are included in both Dagit’s copy and the Dagster Daemon’s copy. When you make changes to the workspace.yaml file, you don’t need to restart either Dagit or the Dagster Daemon - in Dagit, you can reload the workspace from the Workspace tab, and the Dagster Daemon will periodically check the workspace.yaml file for changes every 60 seconds. If you are using the Dagster Helm chart, no changes are required to include the workspace in the Dagster Daemon.\n- In previous releases, it was possible to supply either an AssetKey, or a function that produced an AssetKey from an OutputContext as the asset_key argument to an Out/OutputDefinition. The latter behavior makes it impossible to gain information about these relationships without running a job, and has been deprecated. However, we still support supplying a static AssetKey as an argument.\n- We have renamed many of the core APIs that interact with ScheduleStorage, which keeps track of sensor/schedule state and ticks. The old term for the generic schedule/sensor “job” has been replaced by the term “instigator” in order to avoid confusion with the execution API introduced in 0.12.0. If you have implemented your own schedule storage, you may need to change your method signatures appropriately.\n- Dagit is now powered by Starlette instead of Flask. If you have implemented a custom run coordinator, you may need to make the following change:\n\n  ```python\n  from flask import has_request_context, request\n\n  def submit_run(self, context: SubmitRunContext) -> PipelineRun:\n      jwt_claims_header = (\n          request.headers.get(\"X-Amzn-Oidc-Data\", None) if has_request_context() else None\n      )\n  ```\n\n  Should be replaced by:\n\n  ```python\n  def submit_run(self, context: SubmitRunContext) -> PipelineRun:\n      jwt_claims_header = context.get_request_header(\"X-Amzn-Oidc-Data\")\n  ```\n\n- The Dagster Daemon now requires a workspace.yaml file, much like Dagit.\n- Ellipsis (“...”) is now an invalid substring of a partition key. This is because Dagit accepts an ellipsis to specify partition ranges.\n- [Helm] The Dagster Helm chart now only supported Kubernetes clusters above version 1.18.\n\n### Deprecation: Metadata API Renames\n\nDagster’s metadata API has undergone a signficant overhaul. Changes include:\n\n- To reflect the fact that metadata can be specified on definitions in addition to events, the following names are changing. The old names are deprecated, and will function as aliases for the new names until 0.15.0:\n  - `EventMetadata` > `MetadataValue`\n  - `EventMetadataEntry` > `MetadataEntry`\n  - `XMetadataEntryData` > `XMetadataValue` (e.g. `TextMetadataEntryData` > `TextMetadataValue`)\n- The `metadata_entries` keyword argument to events and Dagster types is deprecated. Instead, users should use the metadata keyword argument, which takes a dictionary mapping string labels to `MetadataValue`s.\n- Arbitrary metadata on In/InputDefinition and Out/OutputDefinition is deprecated. In 0.15.0, metadata passed for these classes will need to be resolvable to `MetadataValue` (i.e. function like metadata everywhere else in Dagster).\n- The description attribute of `EventMetadataEntry` is deprecated.\n- The static API of `EventMetadataEntry` (e.g. `EventMetadataEntry.text`) is deprecated. In 0.15.0, users should avoid constructing `EventMetadataEntry` objects directly, instead utilizing the metadata dictionary keyword argument, which maps string labels to `MetadataValues`.\n\n## Migrating to 0.13.0\n\nJobs, ops, and graphs have replaced pipelines, solids, modes, and presets as the stable core of the\nsystem. [Here](https://legacy-versioned-docs.dagster.dagster-docs.io/0.15.7/guides/dagster/graph_job_op) is a guide you can use to update your code using the legacy APIs into using the new Dagster core APIs. 0.13.0 is still compatible with the pipeline, solid, mode, and preset APIs, which means that you don't need to migrate your code to upgrade to 0.13.0.\n\n## Migrating to 0.12.0\n\nThe new experimental core API experience in Dagit uses some features that require a data migration. Before enabling the experimental core API flag in Dagit, you will first need to run this command:\n\n```\ndagster instance migrate\n```\n\nIf you are not going to enable the experimental core API experience, this data migration is optional. However, you may still want to run the migration anyway, which will enable better performance in viewing the Asset catalog in Dagit.\n\n## Migrating to 0.11.0\n\n### Action Required: Run and event storage schema changes\n\nRun this after migrating to 0.11.0:\n\n```\ndagster instance migrate\n```\n\nThis release includes several schema changes to the Dagster storages that improve performance, allow support for MySQL, and enable new features like asset tags and reliable backfills. After upgrading to 0.11.0, run the `dagster instance migrate` command to migrate your instance storage to the latest schema.\n\n### Action Required: Schedule timezones\n\nSchedules now run in UTC (instead of the system timezone) if no timezone has been set on the schedule. If you’re using a deprecated scheduler like `SystemCronScheduler` or `K8sScheduler`, we recommend that you switch to the native Dagster scheduler. The deprecated schedulers will be removed in the next Dagster release.\n\n### Action Required: Asset storage\n\nIf upgrading directly to `0.11.0` from `0.9.22` or lower, you might notice some asset keys missing from the catalog if they have not been materialized using a version `0.9.16` or greater. We removed some back-compatibility for performance reasons. If this is the case, you can either run `dagster instance reindex` or execute the appropriate pipelines to materialize those assets again. In either case, the full history of the asset will still be maintained.\n\n### Removals of Deprecated APIs\n\n- The `instance` argument to `RunLauncher.launch_run` has been removed. If you have written a custom RunLauncher, you’ll need to update the signature of that method. You can still access the `DagsterInstance` on the `RunLauncher` via the `_instance` parameter.\n- The `has_config_entry`, `has_configurable_inputs`, and `has_configurable_outputs` properties of `solid` and `composite_solid` have been removed.\n- The deprecated optionality of the `name` argument to `PipelineDefinition` has been removed, and the argument is now required.\n- The `execute_run_with_structured_logs` and `execute_step_with_structured_logs` internal CLI entry points have been removed. Use `execute_run` or `execute_step` instead.\n- The `python_environment` key has been removed from `workspace.yaml`. Instead, to specify that a repository location should use a custom python environment, set the `executable_path` key within a `python_file` or `python_module` key. See [the docs](https://docs.dagster.io/concepts/code-locations/workspace-files) for more information on configuring your `workspace.yaml` file.\n- [dagster-dask] The deprecated schema for reading or materializing dataframes has been removed. Use the `read` or `to` keys accordingly.\n\n### Breaking Changes\n\n- Names provided to `alias` on solids now enforce the same naming rules as solids. You may have to update provided names to meet these requirements.\n- The `retries` method on `Executor` should now return a `RetryMode` instead of a `Retries`. This will only affect custom `Executor` classes.\n- Submitting partition backfills in Dagit now requires `dagster-daemon` to be running. The instance setting in `dagster.yaml` to optionally enable daemon-based backfills has been removed, because all backfills are now daemon-based backfills.\n\n  ```\n  # removed, no longer a valid setting in dagster.yaml\n\n  backfill:\n    daemon_enabled: true\n  ```\n\nThe corresponding value flag `dagsterDaemon.backfill.enabled` has also been removed from the Dagster helm chart.\n\n- The sensor daemon interval settings in `dagster.yaml` has been removed. The sensor daemon now runs in a continuous loop so this customization is no longer useful.\n\n  ```\n  # removed, no longer a valid setting in dagster.yaml\n\n  sensor_settings:\n    interval_seconds: 10\n  ```\n\n## Migrating to 0.10.0\n\n### Action Required: Run and event storage schema changes\n\n```bash\n# Run after migrating to 0.10.0\n\n$ dagster instance migrate\n```\n\nThis release includes several schema changes to the Dagster storages that improve performance and\nenable new features like sensors and run queueing. After upgrading to 0.10.0, run the\n`dagster instance migrate` command to migrate your instance storage to the latest schema. This will\nturn off any running schedules, so you will need to restart any previously running schedules after\nmigrating the schema. Before turning them back on, you should follow the steps below to migrate\nto `DagsterDaemonScheduler`.\n\n### New scheduler: DagsterDaemonScheduler\n\nThis release includes a new `DagsterDaemonScheduler` with improved fault tolerance and full support\nfor timezones. We highly recommend upgrading to the new scheduler during this release. The existing\nschedulers, `SystemCronScheduler` and `K8sScheduler`, are deprecated and will be removed in a\nfuture release.\n\n#### Steps to migrate\n\nInstead of relying on system cron or k8s cron jobs, the `DaemonScheduler` uses the new\n`dagster-daemon` service to run schedules. This requires running the `dagster-daemon` service as a\npart of your deployment.\n\nRefer to our [deployment documentation](https://docs.dagster.io/deployment) for a guides on how to\nset up and run the daemon process for local development, Docker, or Kubernetes deployments.\n\n**If you are currently using the SystemCronScheduler or K8sScheduler:**\n\n1. Stop any currently running schedules, to prevent any dangling cron jobs from being left behind.\n   You can do this through the Dagit UI, or using the following command:\n\n   ```bash\n   dagster schedule stop --location {repository_location_name} {schedule_name}\n   ```\n\n   If you do not stop running schedules before changing schedulers, Dagster will throw an exception\n   on startup due to the misconfigured running schedules.\n\n2. In your `dagster.yaml` file, remove the `scheduler:` entry. If there is no `scheduler:` entry,\n   the `DagsterDaemonScheduler` is automatically used as the default scheduler.\n\n3. Start the `dagster-daemon` process. Guides can be found in our\n   [deployment documentations](https://docs.dagster.io/deployment).\n\nSee our [schedules troubleshooting guide](/concepts/partitions-schedules-sensors/schedules) for\nhelp if you experience any problems with the new scheduler.\n\n**If you are not using a legacy scheduler:**\n\nNo migration steps are needed, but make sure you run `dagster instance migrate` as a part of\nupgrading to 0.10.0.\n\n### Deprecation: Intermediate Storage\n\nWe have deprecated the intermediate storage machinery in favor of the new IO manager abstraction,\nwhich offers finer-grained control over how inputs and outputs are serialized and persisted. Check\nout the [IO Managers Overview](https://docs.dagster.io/concepts/io-management/io-managers) for\nmore information.\n\n#### Steps to Migrate\n\n- We have deprecated the top level `\"storage\"` and `\"intermediate_storage\"` fields on `run_config`.\n  If you are currently executing pipelines as follows:\n\n  ```python\n  @pipeline\n  def my_pipeline():\n      ...\n\n  execute_pipeline(\n      my_pipeline,\n      run_config={\n          \"intermediate_storage\": {\n              \"filesystem\": {\"base_dir\": ...}\n          }\n      },\n  )\n\n  execute_pipeline(\n      my_pipeline,\n      run_config={\n          \"storage\": {\n              \"filesystem\": {\"base_dir\": ...}\n          }\n      },\n  )\n  ```\n\n  You should instead use the built-in IO manager `fs_io_manager`, which can be attached to your\n  pipeline as a resource:\n\n  ```python\n  @pipeline(\n      mode_defs=[\n          ModeDefinition(\n              resource_defs={\"io_manager\": fs_io_manager}\n          )\n      ],\n  )\n  def my_pipeline():\n      ...\n\n  execute_pipeline(\n      my_pipeline,\n      run_config={\n          \"resources\": {\n              \"io_manager\": {\"config\": {\"base_dir\": ...}}\n          }\n      },\n  )\n  ```\n\n  There are corresponding IO managers for other intermediate storages, such as the S3- and\n  ADLS2-based storages\n\n- We have deprecated `IntermediateStorageDefinition` and `@intermediate_storage`.\n\n  If you have written custom intermediate storage, you should migrate to custom IO managers\n  defined using the `@io_manager` API. We have provided a helper method,\n  `io_manager_from_intermediate_storage`, to help migrate your existing custom intermediate\n  storages to IO managers.\n\n  ```python\n  my_io_manager_def = io_manager_from_intermediate_storage(\n      my_intermediate_storage_def\n  )\n\n  @pipeline(\n      mode_defs=[\n          ModeDefinition(\n              resource_defs={\n                  \"io_manager\": my_io_manager_def\n              }\n          ),\n      ],\n  )\n  def my_pipeline():\n      ...\n  ```\n\n- We have deprecated the `intermediate_storage_defs` argument to `ModeDefinition`, in favor of the\n  new IO managers, which should be attached using the `resource_defs` argument.\n\n### Removal: input_hydration_config and output_materialization_config\n\nUse `dagster_type_loader` instead of `input_hydration_config` and `dagster_type_materializer`\ninstead of `output_materialization_config`.\n\nOn `DagsterType` and type constructors in `dagster_pandas` use the `loader` argument instead of\n`input_hydration_config` and the `materializer` argument instead of `dagster_type_materializer`\nargument.\n\n### Removal: repository key in workspace YAML\n\nWe have removed the ability to specify a repository in your workspace using the `repository:` key.\nUse `load_from:` instead when specifying how to load the repositories in your workspace.\n\n### Deprecated: python_environment key in workspace YAML\n\nThe `python_environment:` key is now deprecated and will be removed in a future release.\n\nPreviously, when you wanted to load a repository location in your workspace using a different\nPython environment from Dagit’s Python environment, you needed to use a `python_environment:` key\nunder `load_from:` instead of the `python_file:` or `python_package:` keys. Now, you can simply\ncustomize the `executable_path` in your workspace entries without needing to change to the\n`python_environment:` key.\n\nFor example, the following workspace entry:\n\n```yaml\n- python_environment:\n    executable_path: \"/path/to/venvs/dagster-dev-3.7.6/bin/python\"\n    target:\n      python_package:\n        package_name: dagster_examples\n        location_name: dagster_examples\n```\n\nshould now be expressed as:\n\n```yaml\n- python_package:\n    executable_path: \"/path/to/venvs/dagster-dev-3.7.6/bin/python\"\n    package_name: dagster_examples\n    location_name: dagster_examples\n```\n\nSee our [Workspaces Overview](/concepts/code-locations/workspace-files)\nfor more information and examples.\n\n### Removal: config_field property on definition classes\n\nWe have removed the property `config_field` on definition classes. Use `config_schema` instead.\n\n### Removal: System Storage\n\nWe have removed the system storage abstractions, i.e. `SystemStorageDefinition` and\n`@system_storage` ([deprecated in 0.9.0](#deprecation-system_storage_defs)).\n\nPlease note that the intermediate storage abstraction is also deprecated and will be removed in\n0.11.0. [Use IO managers instead](#deprecation-intermediate-storage).\n\n- We have removed the `system_storage_defs` argument (deprecated in 0.9.0) to `ModeDefinition`, in\n  favor of `intermediate_storage_defs.`\n- We have removed the built-in system storages, e.g. `default_system_storage_defs`\n  (deprecated in 0.9.0).\n\n### Removal: step_keys_to_execute\n\nWe have removed the `step_keys_to_execute` argument to `reexecute_pipeline` and\n`reexecute_pipeline_iterator`, in favor of `step_selection`. This argument accepts the Dagster\nselection syntax, so, for example, `*solid_a+` represents `solid_a`, all of its upstream steps,\nand its immediate downstream steps.\n\n### Breaking Change: date_partition_range\n\nStarting in 0.10.0, Dagster uses the [pendulum](https://pypi.org/project/pendulum/) library to\nensure that schedules and partitions behave correctly with respect to timezones. As part of this\nchange, the `delta` parameter to `date_partition_range` (which determined the time different between\npartitions and was a `datetime.timedelta`) has been replaced by a `delta_range` parameter\n(which must be a string that's a valid argument to the `pendulum.period` function, such as\n`\"days\"`, `\"hours\"`, or `\"months\"`).\n\nFor example, the following partition range for a monthly partition set:\n\n```python\ndate_partition_range(\n    start=datetime.datetime(2018, 1, 1),\n    end=datetime.datetime(2019, 1, 1),\n    delta=datetime.timedelta(months=1)\n)\n```\n\nshould now be expressed as:\n\n```python\ndate_partition_range(\n    start=datetime.datetime(2018, 1, 1),\n    end=datetime.datetime(2019, 1, 1),\n    delta_range=\"months\"\n)\n```\n\n### Breaking Change: PartitionSetDefinition.create_schedule_definition\n\nWhen you create a schedule from a partition set using\n`PartitionSetDefinition.create_schedule_definition`, you now must supply a `partition_selector`\nargument that tells the scheduler which partition to use for a given schedule time.\n\nWe have added two helper functions, `create_offset_partition_selector` and\n`identity_partition_selector`, that capture two common partition selectors (schedules that execute\nat a fixed offset from the partition times, e.g. a schedule that creates the previous day's\npartition each morning, and schedules that execute at the same time as the partition times).\n\nThe previous default partition selector was `last_partition`, which didn't always work as expected\nwhen using the default scheduler and has been removed in favor of the two helper partition selectors\nabove.\n\nFor example, a schedule created from a daily partition set that fills in each partition the next\nday at 10AM would be created as follows:\n\n```python\npartition_set = PartitionSetDefinition(\n    name='hello_world_partition_set',\n    pipeline_name='hello_world_pipeline',\n    partition_fn= date_partition_range(\n        start=datetime.datetime(2021, 1, 1),\n        delta_range=\"days\",\n        timezone=\"US/Central\",\n    )\n    run_config_fn_for_partition=my_run_config_fn,\n)\n\nschedule_definition = partition_set.create_schedule_definition(\n    \"daily_10am_schedule\",\n    \"0 10 * * *\",\n    partition_selector=create_offset_partition_selector(lambda d: d.subtract(hours=10, days=1))\n    execution_timezone=\"US/Central\",\n)\n```\n\n### Renamed: Helm values\n\nFollowing convention in the [Helm docs](https://helm.sh/docs/chart_best_practices/values/#naming-conventions),\nwe now camel case all of our Helm values. To migrate to 0.10.0, you'll need to update your\n`values.yaml` with the following renames:\n\n- `pipeline_run` → `pipelineRun`\n- `dagster_home` → `dagsterHome`\n- `env_secrets` → `envSecrets`\n- `env_config_maps` → `envConfigMaps`\n\n### Restructured: scheduler in Helm values\n\nWhen specifying the Dagster instance scheduler, rather than using a boolean field to switch between\nthe current options of `K8sScheduler` and `DagsterDaemonScheduler`, we now require the scheduler\ntype to be explicitly defined under `scheduler.type`. If the user specified `scheduler.type` has\nrequired config, additional fields will need to be specified under `scheduler.config`.\n\n`scheduler.type` and corresponding `scheduler.config` values are enforced via\n[JSON Schema](https://helm.sh/docs/topics/charts/#schema-files).\n\nFor example, if your Helm values previously were set like this to enable the\n`DagsterDaemonScheduler`:\n​\n\n```yaml\nscheduler:\n  k8sEnabled: false\n```\n\n​\nYou should instead have:\n​\n\n```yaml\nscheduler:\n  type: DagsterDaemonScheduler\n```\n\n### Restructured: celery and k8sRunLauncher in Helm values\n\n`celery` and `k8sRunLauncher` now live under `runLauncher.config.celeryK8sRunLauncher` and\n`runLauncher.config.k8sRunLauncher` respectively. Now, to enable celery, `runLauncher.type` must\nequal `CeleryK8sRunLauncher`. To enable the vanilla K8s run launcher, `runLauncher.type` must\nequal `K8sRunLauncher`.\n\n`runLauncher.type` and corresponding `runLauncher.config` values are enforced via\n[JSON Schema](https://helm.sh/docs/topics/charts/#schema-files).\n\nFor example, if your Helm values previously were set like this to enable the `K8sRunLauncher`:\n​\n\n```yaml\ncelery:\n  enabled: false\n​\nk8sRunLauncher:\n  enabled: true\n  jobNamespace: ~\n  loadInclusterConfig: true\n  kubeconfigFile: ~\n  envConfigMaps: []\n  envSecrets: []\n```\n\n​\nYou should instead have:\n​\n\n```yaml\nrunLauncher:\n  type: K8sRunLauncher\n  config:\n    k8sRunLauncher:\n      jobNamespace: ~\n      loadInclusterConfig: true\n      kubeconfigFile: ~\n      envConfigMaps: []\n      envSecrets: []\n```\n\n### New Helm defaults\n\nBy default, `userDeployments` is enabled and the `runLauncher` is set to the `K8sRunLauncher`.\nAlong with the latter change, all message brokers (e.g. `rabbitmq` and `redis`) are now disabled\nby default.\n\nIf you were using the `CeleryK8sRunLauncher`, one of `rabbitmq` or `redis` must now be explicitly\nenabled in your Helm values.\n\n## Migrating to 0.9.0\n\n### Removal: config argument\n\nWe have removed the `config` argument to the `ConfigMapping`, `@composite_solid`, `@solid`,\n`SolidDefinition`, `@executor`, `ExecutorDefinition`, `@logger`, `LoggerDefinition`, `@resource`,\nand `ResourceDefinition` APIs, which we deprecated in 0.8.0, in favor of `config_schema`, as\ndescribed [here](#renaming-config).\n\n## Migrating to 0.8.8\n\n### Deprecation: Materialization\n\nWe deprecated the `Materialization` event type in favor of the new `AssetMaterialization` event type,\nwhich requires the `asset_key` parameter. Solids yielding `Materialization` events will continue\nto work as before, though the `Materialization` event will be removed in a future release.\n\n### Deprecation: system_storage_defs\n\nWe are starting to deprecate \"system storages\" - instead of pipelines having a system storage\ndefinition which creates an intermediate storage, pipelines now directly have an intermediate\nstorage definition.\n\n- We have added an `intermediate_storage_defs` argument to `ModeDefinition`, which accepts a\n  list of `IntermediateStorageDefinition`s, e.g. `s3_plus_default_intermediate_storage_defs`.\n  As before, the default includes an in-memory intermediate and a local filesystem intermediate\n  storage.\n- We have deprecated `system_storage_defs` argument to `ModeDefinition` in favor of\n  `intermediate_storage_defs`. `system_storage_defs` will be removed in 0.10.0 at the earliest.\n- We have added an `@intermediate_storage` decorator, which makes it easy to define intermediate\n  storages.\n- We have added `s3_file_manager` and `local_file_manager` resources to replace the file managers\n  that previously lived inside system storages. The airline demo has been updated to include\n  an example of how to do this:\n  https://github.com/dagster-io/dagster/blob/0.8.8/examples/airline_demo/airline_demo/solids.py#L171.\n\nFor example, if your `ModeDefinition` looks like this:\n\n```python\nfrom dagster_aws.s3 import s3_plus_default_storage_defs\n\nModeDefinition(system_storage_defs=s3_plus_default_storage_defs)\n```\n\nit is recommended to make it look like this:\n\n```python\nfrom dagster_aws.s3 import s3_plus_default_intermediate_storage_defs\n\nModeDefinition(intermediate_storage_defs=s3_plus_default_intermediate_storage_defs)\n```\n\n## Migrating to 0.8.7\n\n### Loading python modules from the working directory\n\nLoading python modules reliant on the working directory being on the PYTHONPATH is no longer\nsupported. The `dagster` and `dagit` CLI commands no longer add the working directory to the\nPYTHONPATH when resolving modules, which may break some imports. Explicitly installed python\npackages can be specified in workspaces using the `python_package` workspace yaml config option.\nThe `python_module` config option is deprecated and will be removed in a future release.\n\n## Migrating to 0.8.6\n\n### dagster-celery\n\nThe `dagster-celery` module has been broken apart to manage dependencies more coherently. There\nare now three modules: `dagster-celery`, `dagster-celery-k8s`, and `dagster-celery-docker`.\n\nRelated to above, the `dagster-celery worker start` command now takes a required `-A` parameter\nwhich must point to the `app.py` file within the appropriate module. E.g if you are using the\n`celery_k8s_job_executor` then you must use the `-A dagster_celery_k8s.app` option when using the\n`celery` or `dagster-celery` cli tools. Similar for the `celery_docker_executor`:\n`-A dagster_celery_docker.app` must be used.\n\n### Deprecation: input_hydration_config and output_materialization_config\n\nWe renamed the `input_hydration_config` and `output_materialization_config` decorators to\n`dagster_type_` and `dagster_type_materializer` respectively. We also renamed DagsterType's\n`input_hydration_config` and `output_materialization_config` arguments to `loader` and `materializer`\nrespectively.\n\nFor example, if your dagster type definition looks like this:\n\n```python\nfrom dagster import DagsterType, input_hydration_config, output_materialization_config\n\n\n@input_hydration_config(config_schema=my_config_schema)\ndef my_loader(_context, config):\n    '''some implementation'''\n\n\n@output_materialization_config(config_schema=my_config_schema)\ndef my_materializer(_context, config):\n    '''some implementation'''\n\n\nMyType = DagsterType(\n    input_hydration_config=my_loader,\n    output_materialization_config=my_materializer,\n    type_check_fn=my_type_check,\n)\n```\n\nit is recommended to make it look like this:\n\n```python\nfrom dagster import DagsterType, dagster_type_loader, dagster_type_materializer\n\n\n@dagster_type_loader(config_schema=my_config_schema)\ndef my_loader(_context, config):\n    '''some implementation'''\n\n\n@dagster_type_materializer(config_schema=my_config_schema)\ndef my_materializer(_context, config):\n    '''some implementation'''\n\n\nMyType = DagsterType(\n    loader=my_loader,\n    materializer=my_materializer,\n    type_check_fn=my_type_check,\n)\n```\n\n## Migrating to 0.8.5\n\n### Python 3.5\n\nPython 3.5 is no longer under test.\n\n### Engine and ExecutorConfig -> Executor\n\n`Engine` and `ExecutorConfig` have been deleted in favor of `Executor`. Instead of the `@executor` decorator decorating a function that returns an `ExecutorConfig` it should now decorate a function that returns an `Executor`.\n\n## Migrating to 0.8.3\n\n### Change: gcs_resource\n\nPreviously, the `gcs_resource` returned a `GCSResource` wrapper which had a single `client` property that returned a `google.cloud.storage.client.Client`. Now, the `gcs_resource` returns the client directly.\n\nTo update solids that use the `gcp_resource`, change:\n\n```\ncontext.resources.gcs.client\n```\n\nTo:\n\n```\ncontext.resources.gcs\n```\n\n## Migrating to 0.8.0\n\n### Repository loading\n\nDagit and other tools no longer load a single repository containing user definitions such as\npipelines into the same process as the framework code. Instead, they load a \"workspace\" that can\ncontain multiple repositories sourced from a variety of different external locations (e.g., Python\nmodules and Python virtualenvs, with containers and source control repositories soon to come).\n\nThe repositories in a workspace are loaded into their own \"user\" processes distinct from the\n\"host\" framework process. Dagit and other tools now communicate with user code over an IPC\nmechanism.\n\nAs a consequence, the former `repository.yaml` and the associated `-y`/`--repository-yaml` CLI\narguments are deprecated in favor of a new `workspace.yaml` file format and associated\n`-w`/`--workspace-yaml` arguments.\n\n#### Steps to migrate\n\nYou should replace your `repository.yaml` files with `workspace.yaml` files, which can define a\nnumber of possible sources from which to load repositories.\n\n```yaml\nload_from:\n  - python_module:\n      module_name: dagster_examples\n      attribute: define_internal_dagit_repository\n  - python_module: dagster_examples.intro_tutorial.repos\n  - python_file: repos.py\n  - python_environment:\n      executable_path: \"/path/to/venvs/dagster-dev-3.7.6/bin/python\"\n      target:\n        python_module:\n          module_name: dagster_examples\n          location_name: dagster_examples\n          attribute: define_internal_dagit_repository\n```\n\n### Repository definition\n\nThe `@scheduler` and `@repository_partitions` decorators have been removed. In addition, users\nshould prefer the new `@repository` decorator to instantiating `RepositoryDefinition` directly.\n\nOne consequence of this change is that `PartitionSetDefinition` names, including those defined by\na `PartitionScheduleDefinition`, must now be unique within a single repository.\n\n#### Steps to migrate\n\nPreviously you might have defined your pipelines, schedules, partition sets, and repositories in a\npython file such as the following:\n\n```python\n@pipeline\ndef test():\n    ...\n\n@daily_schedule(\n    pipeline_name='test',\n    start_date=datetime.datetime(2020, 1, 1),\n)\ndef daily_test_schedule(_):\n    return {}\n\ntest_partition_set = PartitionSetDefinition(\n    name=\"test\",\n    pipeline_name=\"test\",\n    partition_fn=lambda: [\"test\"],\n    environment_dict_fn_for_partition=lambda _: {},\n)\n\n@schedules\ndef define_schedules():\n    return [daily_test_schedule]\n\n@repository_partitions\ndef define_partitions():\n    return [test_partition_set]\n\ndef define_repository():\n    return RepositoryDefinition('test', pipeline_defs=[test])\n```\n\nWith a `repository.yaml` such as:\n\n```yaml\nrepository:\n  file: repo.py\n  fn: define_repository\n\nscheduler:\n  file: repo.py\n  fn: define_schedules\n\npartitions:\n  file: repo.py\n  fn: define_partitions\n```\n\nIn 0.8.0, you'll write Python like:\n\n```python\n@pipeline\ndef test_pipeline():\n    ...\n\n@daily_schedule(\n    pipeline_name='test',\n    start_date=datetime.datetime(2020, 1, 1),\n)\ndef daily_test_schedule(_):\n    return {}\n\ntest_partition_set = PartitionSetDefinition(\n    name=\"test\",\n    pipeline_name=\"test\",\n    partition_fn=lambda: [\"test\"],\n    run_config_fn_for_partition=lambda _: {},\n)\n\n@repository\ndef test_repository():\n    return [test_pipeline, daily_test_schedule, test_partition_set]\n```\n\nYour `workspace.yaml` will look like:\n\n```yaml\nload_from:\n  - python_file: repo.py\n```\n\nIf you have more than one repository defined in a single Python file, you'll want to instead load\nthe repository using `workspace.yaml` like:\n\n```yaml\nload_from:\n  - python_file:\n      relative_path: repo.py\n      attribute: test_repository\n  - python_file:\n      relative_path: repo.py\n      attribute: other_repository\n```\n\nOf course, the `workspace.yaml` also supports loading from a `python_module`, or with a specific\nPython interpreter from a `python_environment`.\n\nNote that the `@repository` decorator also supports more sophisticated, lazily-loaded repositories.\nConsult the documentation for the decorator for more details.\n\n### Reloadable repositories\n\nIn 0.7.x, dagster attempted to elide the difference between a pipeline that was defined in memory\nand one that was loaded through machinery that used the `ExecutionTargetHandle` machinery. This\nresulted in opaque and hard-to-predict errors and unpleasant workarounds, for instance:\n\n- Pipeline execution in test using `execute_pipeline` would suddenly fail when a multiprocess\n  executor was used.\n- Tests of pipelines with dagstermill solids had to resort to workarounds such as\n\n```python\n    handle = handle_for_pipeline_cli_args(\n        {'module_name': 'some_module.repository', 'fn_name': 'some_pipeline'}\n    )\n    pipeline = handle.build_pipeline_definition()\n    result = execute_pipeline(pipeline, ...)\n```\n\nIn 0.8.0, we've added the `reconstructable` helper to explicitly convert in-memory pipelines into\nreconstructable pipelines that can be passed between processes.\n\n```python\n@pipeline(...)\ndef some_pipeline():\n    ...\n\nexecute_pipeline(reconstructable(some_pipeline), {'execution': {'multiprocess': {}})\n```\n\nPipelines must be defined in module scope in order for `reconstructable` to be used. Note that\npipelines defined _interactively_, e.g., in the Python REPL, cannot be passed between processes.\n\n### Renaming environment_dict and removing RunConfig\n\nIn 0.8.0, we've renamed the common `environment_dict` parameter to many user-facing APIs to\n`run_config`, and we've dropped the previous `run_config` parameter. This change affects the\n`execute_pipeline_iterator` and `execute_pipeline` APIs, the `PresetDefinition` and\n`ScheduleDefinition`, and the `execute_solid` test API. Similarly, the `environment_dict_fn`, `user_defined_environment_dict_fn_for_partition`, and `environment_dict_fn_for_partition` parameters\nto `ScheduleDefinition`, `PartitionSetDefinition`, and `PartitionScheduleDefinition` have been\nrenamed to `run_config_fn`, `user_defined_run_config_fn_for_partition`, and\n`run_config_fn_for_partition` respectively.\n\nThe previous `run_config` parameter has been removed, as has the backing `RunConfig` class. This\nchange affects the `execute_pipeline_iterator` and `execute_pipeline` APIs, and the\n`execute_solids_within_pipeline` and `execute_solid_within_pipeline` test APIs. Instead, you should\nset the `mode`, `preset`, `tags`, `solid_selection`, and, in test, `raise_on_error parameters\ndirectly.\n\nThis change is intended to reduce ambiguity around the notion of a pipeline execution's\n\"environment\", since the config value passed as `run_config` is scoped to a single execution.\n\n### Deprecation: config argument\n\nIn 0.8.0, we've renamed the common `config` parameter to the user-facing definition APIs to\n`config_schema`. This is intended to reduce ambiguity between config values (provided at\nexecution time) and their user-specified schemas (provided at definition time). This change affects\nthe `ConfigMapping`, `@composite_solid`, `@solid`, `SolidDefinition`, `@executor`,\n`ExecutorDefinition`, `@logger`, `LoggerDefinition`, `@resource`, and `ResourceDefinition` APIs.\nIn the CLI, `dagster pipeline execute` and `dagster pipeline launch` now take `-c/--config` instead\nof `-e/--env`.\n\n### Renaming solid_subset and enabling support for solid selection DSL in Python API\n\nIn 0.8.0, we've renamed the `solid_subset`/`--solid-subset` argument to\n`solid_selection`/`--solid-selection` throughout the Python API and CLI. This affects the\n`dagster pipeline execute`, `dagster pipeline launch`, and `dagster pipeline backfill` CLI commands,\nand the `@schedule`, `@monthly_schedule`, `@weekly_schedule`, `@daily_schedule`, `@hourly_schedule`,\n`ScheduleDefinition`, `PresetDefinition`, `PartitionSetDefinition`, `PartitionScheduleDefinition`,\n`execute_pipeline`, `execute_pipeline_iterator`, `DagsterInstance.create_run_for_pipeline`,\n`DagsterInstance.create_run` APIs.\n\nIn addition to the names of individual solids, the new `solid_selection` argument supports selection\nqueries like `*solid_name++` (i.e., `solid_name`, all of its ancestors, its immediate descendants,\nand their immediate descendants), previously supported only in Dagit views.\n\n### Removal of deprectated properties, methods, and arguments\n\n- The deprecated `runtime_type` property on `InputDefinition` and `OutputDefinition` has been\n  removed. Use `dagster_type` instead.\n- The deprecated `has_runtime_type`, `runtime_type_named`, and `all_runtime_types` methods on\n  `PipelineDefinition` have been removed. Use `has_dagster_type`, `dagster_type_named`, and\n  `all_dagster_types` instead.\n- The deprecated `all_runtime_types` method on `SolidDefinition` and `CompositeSolidDefinition`\n  has been removed. Use `all_dagster_types` instead.\n- The deprecated `metadata` argument to `SolidDefinition` and `@solid` has been removed. Use\n  `tags` instead.\n- The use of `is_optional` throughout the codebase was deprecated in 0.7.x and has been removed. Use\n  `is_required` instead.\n\n### Removal of Path config type\n\nThe built-in config type `Path` has been removed. Use `String`.\n\n### dagster-bash\n\nThis package has been renamed to dagster-shell. The`bash_command_solid` and `bash_script_solid`\nsolid factory functions have been renamed to `create_shell_command_solid` and\n`create_shell_script_solid`.\n\n### Dask config\n\nThe config schema for the `dagster_dask.dask_executor` has changed. The previous config should\nnow be nested under the key `local`.\n\n### Spark solids\n\n`dagster_spark.SparkSolidDefinition` has been removed - use `create_spark_solid` instead.\n\n## Migrating to 0.7.0\n\nThe 0.7.0 release contains a number of breaking API changes. While listed\nin the changelog, this document goes into more detail about how to\nresolve the change easily. Most of the eliminated or changed APIs\ncan be adjusted to with relatively straightforward changes.\n\nThe easiest way to use this guide is to search for associated\nerror text.\n\n### Dagster Types\n\nThere have been substantial changes to the core dagster type APIs.\n\nError:\n\n`ImportError: cannot import name 'dagster_type' from 'dagster'`\n\nFix:\n\nUse `usable_as_dagster_type` instead. If dynamically generating\ntypes, construct using `DagsterType` instead.\n\nError:\n\n`ImportError: cannot import name 'as_dagster_type' from 'dagster'`\n\nFix:\n\nUse `make_python_type_usable_as_dagster_type` instead.\n\nError:\n\n`dagster.core.errors.DagsterInvalidDefinitionError: type_check_fn argument type \"BadType\" must take 2 arguments, received 1`\n\nFix:\n\nAdd a context argument (named `_`, `_context`, `context`, or `context_`) as the first argument\nof the `type_check_fn`. The second argument is the value being type-checked.\n\nFurther Information:\n\nWe have eliminated the `@dagster_type` and `as_dagster_type`\nAPIs, which previously were promoted as our primary type\ncreation API. This API automatically created a mapping\nbetween a Python type and a Dagster Type. While convenient,\nthis ended up causing unpredictable behavior based on import\norder, as well as being wholly incompatible with dynamically\ncreated Dagster types.\n\nOur core type creation API is now the `DagsterType` class. It creates a\nDagster type (which is just an instance of `DagsterType`) that can be passed\nto `InputDefinition` and `OutputDefinition`.\n\nThe functionality of `@dagster_type` is preserved, but under a different name:\n`usable_as_dagster_type`. This decorator signifies that the author wants\na bare Python type to be usable in contexts that expect dagster types, such as\nan `InputDefinition` or `OutputDefinition`.\n\nAny user that had been programmatically creating dagster types and was forced\nto decorate classes in local scope using `@dagster_type` and return that class\nshould instead just create a `DagsterType` directly.\n\n`as_dagster_type` has replaced by `make_python_type_usable_as_dagster_type`.\nThe semantics of `as_dagster_type` did not indicate what is was actually doing\nvery well. This function is meant to take an _existing_ type -- often from\na library that one doesn't control -- and make that type usable as a dagster\ntype, the second argument.\n\nThe `type_check_fn` argument has been renamed from `type_check` and now takes\ntwo arguments instead of one. The first argument is a instance of `TypeCheckContext`;\nthe second argument is the value being checked. This allows the type check\nto have access to resources.\n\n### Config System\n\nThe config APIs have been renamed to have no collisions with names in neither python's\n`typing` API nor the dagster type system. Here are some example errors:\n\nError:\n\n`dagster.core.errors.DagsterInvariantViolationError: Cannot resolve Dagster Type Optional.Int to a config type. Repr of type: <dagster.core.types.dagster_type.OptionalType object at 0x102bb2a50>`\n\nFix:\n\nUse `Noneable` of `Optional`.\n\nError:\n\n`TypeError: 'DagsterDictApi' object is not callable`\n\nFix:\n\nPass a raw python dictionary instead of Dict.\n\n`config=Dict({'foo': str})` becomes `config={'foo': str}`\n\nError:\n\n`ImportError: cannot import name 'PermissiveDict' from 'dagster'`\n\nFix:\n\nUse `Permissive` instead.\n\nError:\n\n`dagster.core.errors.DagsterInvariantViolationError: Cannot use List in the context of config. Please use a python list (e.g. [int]) or dagster.Array (e.g. Array(int)) instead.`\n\nFix:\n\nThis happens when a properly constructed List is used within config. Use Array instead.\n\nError:\n\n`dagster.core.errors.DagsterInvalidDefinitionError: Invalid type: dagster_type must be DagsterType, a python scalar, or a python type that has been marked usable as a dagster type via @usable_dagster_type or make_python_type_usable_as_dagster_type: got <dagster.config.config_type.Noneable object at 0x1029c8a10>.`\n\nFix:\n\nThis happens when a List takes an invalid argument and is never constructed.\nThe error could be much better. This is what happens a config type (in this\ncase `Noneable`) is passed to a `List`. The fix is to use either `Array` or\nto use a bare list with a single element, which is a config type.\n\n### Required Resources\n\nAny solid, type, or configuration function that accesses a resource off of a context\nobject must declare that resource key with a `required_resource_key` argument.\n\nError:\n\n`DagsterUnknownResourceError: Unknown resource <resource_name>. Specify <resource_name> as a required resource on the compute / config function that accessed it.`\n\nFix:\n\nFind any references to `context.resources.<resource_name>`, and ensure that the enclosing\nsolid definition, type definition, or config function has the resource key specified\nin its `required_resource_key` argument.\n\nFurther information:\n\nWhen only a subset of solids are being executed in a given process, we only need to\ninitialize resources that will be used by that subset of solids. In order to improve\nthe performance of pipeline execution, we need each solid and type to explicitly declare\nits required resources.\n\nAs a result, we should see improved performance for pipeline subset execution,\nmultiprocess execution, and retry execution.\n\n### RunConfig Removed\n\nError:\n\n`AttributeError: 'ComputeExecutionContext' object has no attribute 'run_config'`\n\nFix:\n\nReplace all references to `context.run_config` with `context.pipeline_run`. The `run_config` field\non the pipeline execution context has been removed and replaced with `pipeline_run`, a `PipelineRun`\ninstance. Along with the fields previously on `RunConfig`, this also includes the pipeline run\nstatus.\n\n### Scheduler\n\nScheduler configuration has been moved to the `dagster.yaml`. After upgrading, the previous schedule\nhistory is no longer compatible with the new storage.\n\nMake sure you delete your existing `$DAGSTER_HOME/schedules` directory, then run:\n\n```\ndagster schedule wipe && dagster schedule up\n```\n\nError:\n\n`TypeError: schedules() got an unexpected keyword argument 'scheduler'`\n\nFix:\n\nThe `@schedules` decorator no longer takes a `scheduler` argument. Remove the argument and instead\nconfigure the scheduler on the instance.\n\nInstead of:\n\n```\n@schedules(scheduler=SystemCronScheduler)\ndef define_schedules():\n    ...\n```\n\nRemove the `scheduler` argument:\n\n```\n@schedules\ndef define_schedules():\n    ...\n```\n\nConfigure the scheduler on your instance by adding the following to `$DAGSTER_HOME/dagster.yaml`:\n\n```\nscheduler:\n    module: dagster_cron.cron_scheduler\n    class: SystemCronScheduler\n```\n\nError:\n\n`TypeError: <lambda>() takes 0 positional arguments but 1 was given\"`\n\nStack Trace:\n\n```\n    File \".../dagster/python_modules/dagster/dagster/core/definitions/schedule.py\", line 171, in should_execute\n        return self._should_execute(context)\n```\n\nFix:\n\nThe `should_execute` and `environment_dict_fn` argument to `ScheduleDefinition` now has a required\nfirst argument `context`, representing the `ScheduleExecutionContext`.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 2.892578125,
          "content": ".PHONY: pyright\n\n# Makefile oddities:\n# - Commands must start with literal tab characters (\\t), not spaces.\n# - Multi-command rules (like `ruff` below) by default terminate as soon as a command has a non-0\n#   exit status. Prefix the command with \"-\" to instruct make to continue to the next command\n#   regardless of the preceding command's exit status.\n\npyright:\n\tpython scripts/run-pyright.py --all\n\ninstall_prettier:\n\tnpm install -g prettier\n\ninstall_pyright:\n\tpip install -e 'python_modules/dagster[pyright]' -e 'python_modules/dagster-pipes'\n\nrebuild_pyright:\n\tpython scripts/run-pyright.py --all --rebuild\n\n# Skip typecheck so that this can be used to test if all requirements can successfully be resolved\n# in CI independently of typechecking.\nrebuild_pyright_pins:\n\tpython scripts/run-pyright.py --update-pins --skip-typecheck\n\nquick_pyright:\n\tpython scripts/run-pyright.py --diff\n\nunannotated_pyright:\n\tpython scripts/run-pyright.py --unannotated\n\nruff:\n\t-ruff check --fix .\n\truff format .\n\ncheck_ruff:\n\truff check .\n\truff format --check .\n\ncheck_prettier:\n#NOTE:  excludes README.md because it's a symlink\n\tprettier `git ls-files \\\n\t'python_modules/*.yml' 'python_modules/*.yaml' 'helm/*.yml' 'helm/*.yaml' \\\n\t':!:helm/**/templates/*.yml' ':!:helm/**/templates/*.yaml' '*.md' ':!:docs/*.md' \\\n\t':!:README.md'` --check\n\nprettier:\n\tprettier `git ls-files \\\n\t'python_modules/*.yml' 'python_modules/*.yaml' 'helm/*.yml' 'helm/*.yaml' \\\n\t':!:helm/**/templates/*.yml' ':!:helm/**/templates/*.yaml' '*.md' ':!:docs/*.md' \\\n\t':!:README.md'` --write\n\ninstall_dev_python_modules:\n\tpython scripts/install_dev_python_modules.py -q\n\ninstall_dev_python_modules_verbose:\n\tpython scripts/install_dev_python_modules.py\n\ninstall_dev_python_modules_verbose_m1:\n\tpython scripts/install_dev_python_modules.py --include-prebuilt-grpcio-wheel\n\ngraphql:\n\tcd js_modules/dagster-ui/; make generate-graphql; make generate-perms\n\nsanity_check:\n#NOTE:  fails on nonPOSIX-compliant shells (e.g. CMD, powershell)\n#NOTE:  dagster-hex is an external package\n\t@echo Checking for prod installs - if any are listed below reinstall with 'uv pip install -e'\n\t@! (uv pip list --exclude-editable | grep -e dagster | grep -v dagster-hex | grep -v dagster-hightouch)\n\nrebuild_ui: sanity_check\n\tcd js_modules/dagster-ui/; yarn install && yarn build\n\nrebuild_ui_with_profiling: sanity_check\n\tcd js_modules/dagster-ui/; yarn install && yarn build-with-profiling\n\ndev_install_m1_grpcio_wheel: install_dev_python_modules_verbose_m1 rebuild_ui\n\ndev_install: install_dev_python_modules_verbose rebuild_ui\n\ndev_install_quiet: install_dev_python_modules rebuild_ui\n\ngraphql_tests:\n\tpytest python_modules/dagster-graphql/dagster_graphql_tests/graphql/ -s -vv\n\ncheck_manifest:\n\tcheck-manifest python_modules/dagster\n\tcheck-manifest python_modules/dagster-webserver\n\tcheck-manifest python_modules/dagster-graphql\n\tls python_modules/libraries | xargs -n 1 -Ipkg check-manifest python_modules/libraries/pkg\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 0.03125,
          "content": "python_modules/dagster/README.md"
        },
        {
          "name": "azure-pipelines.yml",
          "type": "blob",
          "size": 1.322265625,
          "content": "trigger:\n  branches:\n    include:\n      - master\n      - windows/*\npr: none\nparameters:\n  - name: py3_versions\n    type: object\n    default:\n      - \"3.10\"\n  - name: py3_env_suffixes\n    type: object\n    default:\n      - api_tests\n      - cli_tests\n      - general_tests\n      - launcher_tests\n      - daemon_tests\n      - daemon_sensor_tests\n      - scheduler_tests\njobs:\n  - job: \"dagster\"\n    pool:\n      vmImage: \"windows-2019\"\n    strategy:\n      matrix:\n        ${{ each py_version in parameters.py3_versions }}:\n          ${{ each env_suffix in parameters.py3_env_suffixes }}:\n            ${{ replace(py_version, '.', '') }}-windows-${{ env_suffix }}:\n              TOXENV: \"py${{ replace(py_version, '.', '') }}-windows-${{ env_suffix }}\"\n              python.version: \"${{ py_version }}\"\n    variables:\n      PYTHONLEGACYWINDOWSSTDIO: \"1\"\n    steps:\n      - task: UsePythonVersion@0\n        inputs:\n          versionSpec: \"$(python.version)\"\n          architecture: \"x64\"\n      - script: pip install \"tox<4.0.0\" uv\n        displayName: \"Install tox & uv\"\n      - script: cd python_modules\\dagster && tox -e %TOXENV% && cd ..\\..\n        displayName: \"Run tests\"\n      - task: PublishTestResults@2\n        inputs:\n          testResultsFiles: \"**/test_results.xml\"\n          testRunTitle: \"dagster $(TOXENV)\"\n        condition: succeededOrFailed()\n"
        },
        {
          "name": "conftest.py",
          "type": "blob",
          "size": 0.8681640625,
          "content": "import os\n\nimport pytest\n\n\ndef pytest_configure(config):\n    # Create a section break in the logs any time Buildkite invokes pytest\n    # https://buildkite.com/docs/pipelines/managing-log-output\n    # https://docs.pytest.org/en/7.1.x/reference/reference.html?highlight=pytest_configure#pytest.hookspec.pytest_configure\n    if os.getenv(\"BUILDKITE\"):\n        print(\"+++ Running :pytest: PyTest\")  # noqa\n\n    # https://docs.pytest.org/en/7.1.x/example/markers.html#custom-marker-and-command-line-option-to-control-test-runs\n    config.addinivalue_line(\n        \"markers\", \"integration: mark test to skip if DISABLE_INTEGRATION_TESTS is set.\"\n    )\n\n\ndef pytest_runtest_setup(item):\n    try:\n        next(item.iter_markers(\"integration\"))\n        if os.getenv(\"CI_DISABLE_INTEGRATION_TESTS\"):\n            pytest.skip(\"Integration tests are disabled\")\n\n    except StopIteration:\n        pass\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "helm",
          "type": "tree",
          "content": null
        },
        {
          "name": "integration_tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "js_modules",
          "type": "tree",
          "content": null
        },
        {
          "name": "pyproject.toml",
          "type": "blob",
          "size": 8.8642578125,
          "content": "# ########################\n# ##### PYRIGHT\n# ########################\n\n# [Docs root]\n#   https://github.com/microsoft/pyright/tree/main/docs\n# [Config option reference]\n#   https://github.com/microsoft/pyright/blob/main/docs/configuration.md\n\n# Pyright does not have a docs site, but the documentation (a collection of\n# markdown files in the GH repo, linked above) is pretty thorough.\n\n[tool.pyright]\n\ninclude = [\n  \".buildkite/dagster-buildkite\",\n  \"docs/dagster-ui-screenshot\",\n  \"docs/sphinx/_ext/dagster-sphinx\",\n  \"python_modules\",\n  \"examples\",\n  \"integration_tests\",\n  \"scripts\",\n]\n\n# Unfortunately pyright does not offer a way to extend the default exclusions, so we have to\n# reiterate them here if we want to add anything else.\nexclude = [\n  \"**/node_modules\",\n  \"**/__pycache__\",\n  \"**/__generated__\",\n  \"**/vendor\",\n  \"**/_vendored\",\n  \"**/.tox\",\n  \".git\",\n  \"**/.venv*\",\n  \"**/build\",\n]\n\n# These two settings point pyright to a python environment to resolve imports against. This virtual\n# environment is defined in the `pyright` tox environment in the tox section below-- that\n# environment must be built before pyright can run correctly.\nvenv = \".venv\"\nvenvPath = \"pyright/master\"\n\n\n# Minimum version of Python on which code must run. This determines the standard library stubs used by\n# pyright.\npythonVersion = \"3.9\"\n\n# Use \"basic\" ruleset. This differs from strict in several ways, but most\n# importantly it does not flag untyped code as an error.\ntypeCheckingMode = \"basic\"\n\n# Disable reading type annotations from libraries that are not explicitly marked as typed (i.e. that\n# include a py.typed file). All imports from these libraries are given the `Unknown` type (i.e.\n# `Any`). This setting does not affect `py.typed` libraries.\nuseLibraryCodeForTypes = false\n\n# We use ruff for this.\nreportInvalidStringEscapeSequence = false\n\n# As of 2023-02-02, there are still many `py.typed` libs that are not compliant with the standards\n# for defining a public API.\nreportPrivateImportUsage = false\n\n# Since we only use pyright, there is no need to suppress type errors that pyright does not\n# recognize.\nreportUnnecessaryTypeIgnoreComment = \"warning\"\n\n# Skip analyzing unannotated code in examples to facilitate terse code.\nexecutionEnvironments = [\n  { root = \"examples\", analyzeUnannotatedFunctions=false },\n  { root = \"python_modules\" },\n  { root = \"integration_tests\" }\n]\n\n# ########################\n# ##### PYTEST\n# ########################\n\n[tool.pytest.ini_options]\n\nfilterwarnings = [\n  \"ignore::dagster.ExperimentalWarning\",\n  \"ignore::DeprecationWarning\",\n  \"ignore::UserWarning\",\n  \"ignore::pytest.PytestCollectionWarning\",\n]\n\n# ########################\n# ##### RUFF\n# ########################\n\n# [Docs root]\n#   https://beta.ruff.rs/docs/\n# [Config option reference]\n#   https://beta.ruff.rs/docs/configuration/\n#\n# As of 2022-12-05, the entire documentation of Ruff is in its very long\n# README.\n\n[tool.ruff]\n\ntarget-version = \"py39\"\n\n# *.py, *.ipy are included by default\nextend-include = [\"*.ipynb\"]\n\nextend-exclude = [\n  \"*/__generated__/*\",\n  \"*/dagster_airflow/vendor/*\",\n  \"*/_vendored/*\",\n  \"*/snapshots/*\",\n  \"python_modules/libraries/dagstermill/dagstermill_tests/notebooks/cli_test_scaffold.ipynb\",\n]\n\n# Codebase-wide default line length. Override in package-specific pyproject.toml where a different\n# length is desired.\nline-length = 100\n\n# Fail if Ruff is not running this version.\nrequired-version = \"0.8.4\"\n\n[tool.ruff.lint]\n\n# we only want to format notebooks, not lint them\nexclude = [\"*.ipynb\"]\n\nignore = [\n\n  # (missing public docstrings) These work off of the Python sense of \"public\", rather than our\n  # bespoke definition based off of `@public`. When ruff supports custom plugins then we can write\n  # appropriate rules to require docstrings for `@public`.\n  \"D100\",\n  \"D101\",\n  \"D102\",\n  \"D103\",\n  \"D104\",\n  \"D105\",\n  \"D106\",\n  \"D107\",\n\n  # (docstring imperative mood) Overly restrictive.\n  \"D401\",\n\n  # (module level import not at top) There are several places where we use e.g.\n  # warnings.filterwarings calls before imports.\n  \"E402\",\n\n  # (line too long): This fires for comments, which the ruff formatter won't auto-wrap. Disabling\n  # until there is an autoformat solution available for comments.\n  \"E501\",\n\n  # (no type comparison): There are a few places where we use `== type(None)` which are more clear\n  # than the equivalent `isinstance` check.\n  'E721',\n\n  # (bare exception): There are many places where we want to catch a maximally generic exception.\n  'E722',\n\n  # (no assign lambda): existing code assigns lambdas in a few places. With ruff formatting\n  # requiring extra empty lines between defs, disallowing lambda assignment can make code less\n  # readable.\n  \"E731\",\n\n  # (try-except-in-loop) we use this pattern in many places and the performance impact is negligible\n  \"PERF203\",\n\n  # (no concatenation) Existing codebase has many concatentations, no reason to disallow them.\n  \"RUF005\",\n\n  # (use ClassVar for attr declarations with defaults) This is a good rule for vanilla Python, but\n  # triggers false positives for many libs that have DSLs that make use of attr defaults.\n  \"RUF012\",\n\n  ##### TEMPORARY DISABLES\n\n  # (assorted docstring rules) There are too many violations of these to enable\n  # right now, but we should enable after fixing the violations.\n  \"D200\", # (one-line docstring should fit)\n  \"D205\", # (blank line after summary)\n  \"D417\", # (missing arg in docstring)\n\n  # (assorted perf rules) We have a lot of violations, enable when autofix is available\n  \"PERF401\", # (manual-list-comprehension)\n  \"PERF402\", # (manual-list-copy)\n]\n\n# By default, ruff only uses all \"E\" (pycodestyle) and \"F\" (pyflakes) rules.\n# Here we append to the defaults.\nselect = [\n\n  # (flake8-builtins) detect shadowing of python builtin symbols by variables and arguments.\n  # Attributes are OK (which is why A003) is not included here.\n  \"A001\",\n  \"A002\",\n\n  # (useless expression): Expressions that aren't assigned to anything are typically bugs.\n  \"B018\",\n\n  # (static key dict comprehension): Flag reuse of a key in dict comprehensions.\n  \"B035\",\n\n  # (pydocstyle) Docstring-related rules. A large subset of these are ignored by the\n  # \"convention=google\" setting, we set under tool.ruff.pydocstyle.\n  \"D\",\n\n  # (pycodestyle) pycodestyle rules\n  \"E\",\n\n  # (pyflakes) pyflakes rules\n  \"F\",\n\n  # (isort) detect improperly sorted imports\n  \"I001\",\n\n  # ban relative imports\n  \"TID252\",\n\n  # (performance) perflint rules\n  \"PERF\",\n\n  # (pylint) use all pylint rules from categories \"Convention\", \"Error\", and \"Warning\" (ruff\n  # currently implements only a subset of pylint's rules)\n  \"PLE\",\n  \"PLW\",\n\n  # (no commented out code) keep commented out code blocks out of the codebase\n  # \"ERA001\",\n\n  # (ruff-specific) Enable all ruff-specific checks (i.e. not ports of\n  # functionality from an existing linter).\n  \"RUF\",\n\n  # (private member access) Flag access to `_`-prefixed symbols. By default the various special\n  # methods on `NamedTuple` are ignored (e.g. `_replace`).\n  \"SLF001\",\n\n  # (flake8-type-checking) Auto-sort imports into TYPE_CHECKING blocks depending on whether\n  # they are runtime or type-only imports.\n  \"TCH\",\n\n  # (banned-api) Flag use of banned APIs. See tool.ruff.flake8-tidy-imports.banned-api for details.\n  \"TID251\",\n\n  # (disallow print statements) keep debugging statements out of the codebase\n  \"T20\",\n\n  # (pyupgrade) auto-upgrade syntax to newer versions of Python\n  \"UP\",\n\n  # (invalid escape sequence) flag errant backslashes\n  \"W605\",\n]\n\n[tool.ruff.lint.flake8-builtins]\n\n# We use `id` in many places and almost never want to use the python builtin.\nbuiltins-ignorelist = [\"id\"]\n\n[tool.ruff.lint.flake8-tidy-imports.banned-api]\n\n\"__future__.annotations\".msg = \"Directly quote annotations instead.\"\n\n[tool.ruff.lint.isort]\n\n# Combine multiple `from foo import bar as baz` statements with the same source\n# (`foo`) into a single statement.\ncombine-as-imports = true\n\n# In cases where imports are automatically removed, allows the imports to be automatically collapsed\nsplit-on-trailing-comma = false\n\n# Imports of the form `from foo import bar as baz` show one `import bar as baz`\n# per line. Useful for __init__.py files that just re-export symbols.\nforce-wrap-aliases = true\n\n[tool.ruff.lint.flake8-tidy-imports]\n# Disallow all relative imports.\nban-relative-imports = \"all\"\n\n[tool.ruff.lint.per-file-ignores]\n\n# Don't format docstrings in alembic migrations.\n\"**/alembic/versions/*.py\" = [\"D\"]\n\"examples/docs_beta_snippets/docs_beta_snippets/guides/etl/transform-dbt/dbt_definitions*.py\" = [\"I001\"]\n\n[tool.ruff.lint.pydocstyle]\n\n# Enforce google-style docstrings. This is equivalent to ignoring a large number of pydocstyle (D)\n# rules incompatible with google-style docstrings. See:\n# https://google.github.io/styleguide/pyguide.html#383-functions-and-methods\nconvention = \"google\"\n\n[tool.ruff.format]\nexclude = [\"examples/docs_beta_snippets/docs_beta_snippets/guides/etl/transform-dbt/dbt_definitions*.py\"]\n\n[tool.dagster]\nmodule_name = \"dagster_test.toys.repo\"\n"
        },
        {
          "name": "pyright",
          "type": "tree",
          "content": null
        },
        {
          "name": "python_modules",
          "type": "tree",
          "content": null
        },
        {
          "name": "scripts",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}