{
  "metadata": {
    "timestamp": 1736561232498,
    "page": 216,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjIyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "wangshub/wechat_jump_game",
      "stars": 13839,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 1.3017578125,
          "content": "# user-defined\ntest/\npic/\nscreenshot_backups/\nautojump.png\nautojump_temp.png\nregion*.png\njump_range.csv\n\n# Byte-compiled / optimized / DLL files\n__pycache__/\n*.py[cod]\n*$py.class\n\n# C extensions\n*.so\n\n# Distribution / packaging\n.Python\n.idea\nbuild/\ndevelop-eggs/\ndist/\ndownloads/\neggs/\n.eggs/\nlib/\nlib64/\nparts/\nsdist/\nvar/\nwheels/\n*.egg-info/\n.installed.cfg\n*.egg\nMANIFEST\n\n# PyInstaller\n#  Usually these files are written by a python script from a template\n#  before PyInstaller builds the exe, so as to inject date/other infos into it.\n*.manifest\n*.spec\n\n# Installer logs\npip-log.txt\npip-delete-this-directory.txt\n\n# Unit test / coverage reports\nhtmlcov/\n.tox/\n.coverage\n.coverage.*\n.cache\nnosetests.xml\ncoverage.xml\n*.cover\n.hypothesis/\n\n# Translations\n*.mo\n*.pot\n\n# Django stuff:\n*.log\n.static_storage/\n.media/\nlocal_settings.py\n\n# Flask stuff:\ninstance/\n.webassets-cache\n\n# Scrapy stuff:\n.scrapy\n\n# Sphinx documentation\ndocs/_build/\n\n# PyBuilder\ntarget/\n\n# Jupyter Notebook\n.ipynb_checkpoints\n\n# pyenv\n.python-version\n\n# celery beat schedule file\ncelerybeat-schedule\n\n# SageMath parsed files\n*.sage.py\n\n# Environments\n.env\n.venv\nenv/\nvenv/\nENV/\nenv.bak/\nvenv.bak/\n\n# Spyder project settings\n.spyderproject\n.spyproject\n\n# Rope project settings\n.ropeproject\n\n# mkdocs documentation\n/site\n\n# mypy\n.mypy_cache/\n\n# for mac\n.DS_store"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 11.0947265625,
          "content": "                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"[]\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright [wangshub] [name of copyright owner]\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.05078125,
          "content": "run:\n\tmkdir -p jumpbot/data\n\tpython3 jumpbot/bot.py\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 3.259765625,
          "content": "# 教你用 Python 来玩微信跳一跳\n[![GitHub stars](https://img.shields.io/github/stars/wangshub/wechat_jump_game.svg)](https://github.com/wangshub/wechat_jump_game/stargazers) [![GitHub forks](https://img.shields.io/github/forks/wangshub/wechat_jump_game.svg)](https://github.com/wangshub/wechat_jump_game/network) [![GitHub license](https://img.shields.io/github/license/wangshub/wechat_jump_game.svg)](https://github.com/wangshub/wechat_jump_game/blob/master/LICENSE)\n\n[![Throughput Graph](https://graphs.waffle.io/wangshub/wechat_jump_game/throughput.svg)](https://waffle.io/wangshub/wechat_jump_game/metrics/throughput) \n\n## 游戏模式\n\n> 2017 年 12 月 28 日下午，微信发布了 6.6.1 版本，加入了「小游戏」功能，并提供了官方 DEMO「跳一跳」。这是一个 2.5D 插画风格的益智游戏，玩家可以通过按压屏幕时间的长短来控制这个「小人」跳跃的距离。分数越高，那么在好友排行榜更加靠前。通过 Python 脚本自动运行，让你轻松霸榜。\n\n![](./resource/image/jump.gif)\n\n可能刚开始上手的时候，因为时间距离之间的关系把握不恰当，只能跳出几个就掉到了台子下面。**如果能利用图像识别精确测量出起始和目标点之间测距离，就可以估计按压的时间来精确跳跃。**\n\n## 原理说明\n\n##### 由于微信检测非常严厉，这里的防禁代码可能已经不起作用，主要供学习用途\n\n1. 将手机点击到《跳一跳》小程序界面\n\n2. 用 ADB 工具获取当前手机截图，并用 ADB 将截图 pull 上来\n```shell\nadb shell screencap -p /sdcard/autojump.png\nadb pull /sdcard/autojump.png .\n```\n\n3. 计算按压时间\n  * 手动版：用 Matplotlib 显示截图，用鼠标先点击起始点位置，然后点击目标位置，计算像素距离；\n  * 自动版：靠棋子的颜色来识别棋子，靠底色和方块的色差来识别棋盘；\n\n4. 用 ADB 工具点击屏幕蓄力一跳\n```shell\nadb shell input swipe x y x y time(ms)\n```\n\n\n\n## 使用教程\n\n相关软件工具安装和使用步骤请参考 [Android 和 iOS 操作步骤](https://github.com/wangshub/wechat_jump_game/wiki/Android-%E5%92%8C-iOS-%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4)\n\n#### 获取源码\n\n```\n- git clone https://github.com/wangshub/wechat_jump_game.git\n\n```\n##### 非常推荐使用Python3，避免编码及import问题\n## PR 要求\n##### 请选择 merge 进 master 分支，并且标题写上简短描述，例子 \n[优化] 使用PEP8优化代码\n\n## 版本说明\n\n- master 分支：稳定版本，已通过测试\n- dev 分支：开发版本，包含一些较稳定的新功能，累计多个功能并测试通过后合并至 prod 分支\n- 其他分支：功能开发 (feature) 或问题修复 (bugfix)，属于最新尝鲜版本，可能处于开发中的状态，基本完成后合并至 dev 分支\n\n## FAQ\n\n- 详见 [Wiki-FAQ](https://github.com/wangshub/wechat_jump_game/wiki/FAQ)\n\n## 更新日志\n\n- 详见 [changelog](https://github.com/wangshub/wechat_jump_game/blob/master/changelog.md)\n\n## 开发者列表\n\n- 详见 [contributors](https://github.com/wangshub/wechat_jump_game/graphs/contributors)\n\n## 交流\n\n- 314659953 (1000 人)\n- 176740763 (500 人)\n\n- 或者关注我的微信公众号后台留言\n\n![](./resource/image/qrcode_for_gh_3586401957c4_258.jpg)\n\n"
        },
        {
          "name": "README.rst",
          "type": "blob",
          "size": 2.8818359375,
          "content": "##############################################################################\nWechat Jump Bot (iOS)\n##############################################################################\n\n==============================================================================\nFeatures\n==============================================================================\n\n- Auto Mode: play the game automatically;\n- Manual Mode: play the game manually.\n\nWechat Jump Game\n\n.. image:: https://github.com/alpesis-ai/wechat-jumpbot/blob/master/images/auto.png\n   :height: 1334px\n   :width: 500px\n\n\n==============================================================================\nHow it runs\n==============================================================================\n\nPrerequisites\n\n- WebDriverAgent\n- libimobiledevice\n- Python 3\n\nWebDriverAgent\n\n::\n\n    $ git clone https://github.com/facebook/WebDriverAgent && cd WebDriverAgent\n    $ brew install carthage\n    $ ./Scripts/bootstrap.sh\n    # open WebDriverAgent.xcodeproj with Xcode\n    # Xcode:\n    # - code sign (general and build_settings): WebDriverAgentLib/WebDriverAgentRunner\n    # - Product -> Destination -> <your device>\n    # - Product -> Scheme -> WebDriverAgentRunner\n    # - Product -> Test\n\nlibimobiledevice (iproxy)\n\n::\n\n    $ brew install libimobiledevice\n    $ iproxy 8100 8100\n    # browse: http://localhost:8100/status\n    # browse: http://localhost:8100/inspector\n\nBot Agent (iOS)\n\n::\n\n    $ git clone https://github.com/alpesis-ai/wechat-jumpbot.git\n    $ cd bot-agent-ios\n\n    $ pip3 install --pre facebook-wda\n    $ pip3 install -r requirements.txt\n\n    # make run\n    # - model: [ip, plus, ipx, se]\n    # - mode: [auto, manual]\n    # python3 jumpbot/bot.py --model <device_model> --mode <mode>\n    $ mkdir -p jumpbot/data\n    # iphone 6/7\n    $ python3 jumpbot/bot.py --model ip --mode auto\n    # iphone 6/7 plus\n    $ python3 jumpbot/bot.py --model plus --mode auto\n    # iphone X\n    $ python3 jumpbot/bot.py --model ipx --mode auto\n    # iphone SE\n    $ python3 jumpbot/bot.py --model se --mode auto\n\n\n==============================================================================\nAlgorithms\n==============================================================================\n\nManual Mode:\n\n- click the piece(x, y) and board(x, y) and get the coordinates correspondingly\n- calculating the distance and press time\n\n::\n\n    (coord1[0][0] - coord2[0][0])**2 + (coord2[0][1] - coord2[0][1])**2\n    distance = distance ** 0.5\n    press_time = distance * settings.TIME_COEFF\n\nAuto Mode:\n\n- the main idea same as the manual mode, but detecting the piece and the board automatically\n    - find coord_y_start_scan\n    - find piece\n    - find board\n\n\n==============================================================================\nDevelopement\n==============================================================================\n\n::\n\n    connector ---| \n                 | --> auto / manual  --> bot\n    algos     ---|\n"
        },
        {
          "name": "Tools",
          "type": "tree",
          "content": null
        },
        {
          "name": "changelog.md",
          "type": "blob",
          "size": 0.8037109375,
          "content": "## 更新日志\n- 2018-1-8\n  - 发布 release 一键启动 app V1.1.2 版本，针对腾讯 ban 方法进行反 ban 操作，详见 [STOP_jump](https://github.com/wangshub/wechat_jump_game/releases)\n\n- 2018-1-3 ：\n  - 发布 release 一键启动 app，详见 [STOP_jump](https://github.com/wangshub/wechat_jump_game/releases)\n\n- 2017-12-30 :\n  - 请将安卓手机的 USB 调试模式打开，设置 > 更多设置 > 开发者选项 > USB 调试，如果出现运行脚本后小人不跳的情况，请检查是否有打开 “USB 调试（安全模式）”\n  - 根据大家反馈：1080 屏幕距离系数 **1.393**，2K 屏幕为 **1**\n  - 添加部分机型配置文件，可直接复制使用\n\n- 2017-12-29 ：\n  - 增加更新自动化运行脚本，感谢 GitHub 上的 [@binderclip](https://github.com/binderclip)\n"
        },
        {
          "name": "common",
          "type": "tree",
          "content": null
        },
        {
          "name": "config",
          "type": "tree",
          "content": null
        },
        {
          "name": "jump_bot",
          "type": "tree",
          "content": null
        },
        {
          "name": "requirements.txt",
          "type": "blob",
          "size": 0.2744140625,
          "content": "backports.functools-lru-cache==1.4\r\ncycler==0.10.0\r\nmatplotlib==2.1.1\r\nnumpy==1.13.3\r\nolefile==0.44\r\nopencv-python==3.4.0.12\r\nPillow==4.3.0\r\npyparsing==2.2.0\r\npython-dateutil==2.6.1\r\npytz==2017.3\r\nsix==1.11.0\r\ntensorflow==1.4.0\r\npandas==0.22.0\r\nscipy==1.0.0\r\nscikit_learn==0.19.1\r\n"
        },
        {
          "name": "resource",
          "type": "tree",
          "content": null
        },
        {
          "name": "wechat_jump.py",
          "type": "blob",
          "size": 2.087890625,
          "content": "# -*- coding: utf-8 -*-\nfrom __future__ import print_function, division\nimport os\nimport time\nimport datetime\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\nimport cv2\n\nVERSION = \"1.1.4\"\nscale = 0.25\n\ntemplate = cv2.imread('./resource/image/character.png')\ntemplate = cv2.resize(template, (0, 0), fx=scale, fy=scale)\ntemplate_size = template.shape[:2]\n\n\ndef search(img):\n    result = cv2.matchTemplate(img, template, cv2.TM_SQDIFF)\n    min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)\n\n    cv2.rectangle(\n        img,\n        (min_loc[0], min_loc[1]),\n        (min_loc[0] + template_size[1], min_loc[1] + template_size[0]),\n        (255, 0, 0),\n        4)\n    return img, min_loc[0] + template_size[1] / 2, min_loc[1] +  template_size[0]\n\n\ndef pull_screenshot():\n    filename = datetime.datetime.now().strftime(\"%H%M%S\") + '.png'\n    os.system('mv autojump.png {}'.format(filename))\n    os.system('adb shell screencap -p /sdcard/autojump.png')\n    os.system('adb pull /sdcard/autojump.png ./autojump.png')\n\n\ndef jump(distance):\n    press_time = distance * 1.35\n    press_time = int(press_time)\n    cmd = 'adb shell input swipe 320 410 320 410 ' + str(press_time)\n    print(cmd)\n    os.system(cmd)\n\n\ndef update_data():\n    global src_x, src_y\n\n    img = cv2.imread('./autojump.png')\n    img = cv2.resize(img, (0, 0), fx=scale, fy=scale)\n    img, src_x, src_y = search(img)\n    return img\n\n\nfig = plt.figure()\npull_screenshot()\nimg = update_data()\nim = plt.imshow(img, animated=True)\n\nupdate = True\n\n\ndef updatefig(*args):\n    global update\n\n    if update:\n        time.sleep(1)\n        pull_screenshot()\n        im.set_array(update_data())\n        update = False\n    return im,\n\n\ndef on_click(event):\n    global update    \n    global src_x, src_y\n    \n    dst_x, dst_y = event.xdata, event.ydata\n\n    distance = (dst_x - src_x)**2 + (dst_y - src_y)**2 \n    distance = (distance ** 0.5) / scale\n    print('distance = ', distance)\n    jump(distance)\n    update = True\n\n\nfig.canvas.mpl_connect('button_press_event', on_click)\nani = animation.FuncAnimation(fig, updatefig, interval=5, blit=True)\nplt.show()\n"
        },
        {
          "name": "wechat_jump_auto.py",
          "type": "blob",
          "size": 10.107421875,
          "content": "# -*- coding: utf-8 -*-\n\n\"\"\"\n=== 思路 ===\n核心：每次落稳之后截图，根据截图算出棋子的坐标和下一个块顶面的中点坐标，\n    根据两个点的距离乘以一个时间系数获得长按的时间\n识别棋子：靠棋子的颜色来识别位置，通过截图发现最下面一行大概是一条\n    直线，就从上往下一行一行遍历，比较颜色（颜色用了一个区间来比较）\n    找到最下面的那一行的所有点，然后求个中点，求好之后再让 Y 轴坐标\n    减小棋子底盘的一半高度从而得到中心点的坐标\n识别棋盘：靠底色和方块的色差来做，从分数之下的位置开始，一行一行扫描，\n    由于圆形的块最顶上是一条线，方形的上面大概是一个点，所以就\n    用类似识别棋子的做法多识别了几个点求中点，这时候得到了块中点的 X\n    轴坐标，这时候假设现在棋子在当前块的中心，根据一个通过截图获取的\n    固定的角度来推出中点的 Y 坐标\n最后：根据两点的坐标算距离乘以系数来获取长按时间（似乎可以直接用 X 轴距离）\n\"\"\"\n\nimport math\nimport re\nimport random\nimport sys\nimport time\nfrom PIL import Image\nfrom six.moves import input\n\nif sys.version_info.major != 3:\n    print('请使用Python3')\n    exit(1)\ntry:\n    from common import debug, config, screenshot, UnicodeStreamFilter\n    from common.auto_adb import auto_adb\nexcept Exception as ex:\n    print(ex)\n    print('请将脚本放在项目根目录中运行')\n    print('请检查项目根目录中的 common 文件夹是否存在')\n    exit(1)\nadb = auto_adb()\nVERSION = \"1.1.4\"\n\n# DEBUG 开关，需要调试的时候请改为 True，不需要调试的时候为 False\nDEBUG_SWITCH = False\nadb.test_device()\n# Magic Number，不设置可能无法正常执行，请根据具体截图从上到下按需\n# 设置，设置保存在 config 文件夹中\nconfig = config.open_accordant_config()\nunder_game_score_y = config['under_game_score_y']\n# 长按的时间系数，请自己根据实际情况调节\npress_coefficient = config['press_coefficient']\n# 二分之一的棋子底座高度，可能要调节\npiece_base_height_1_2 = config['piece_base_height_1_2']\n# 棋子的宽度，比截图中量到的稍微大一点比较安全，可能要调节\npiece_body_width = config['piece_body_width']\n# 图形中圆球的直径，可以利用系统自带画图工具，用直线测量像素，如果可以实现自动识别圆球直径，那么此处将可实现全自动。\nhead_diameter = config.get('head_diameter')\nif head_diameter == None:\n    density_str = adb.test_density()\n    matches = re.search(r'\\d+', density_str)\n    density_val = int(matches.group(0))\n    head_diameter = density_val / 8\n\n\ndef set_button_position(im):\n    \"\"\"\n    将 swipe 设置为 `再来一局` 按钮的位置\n    \"\"\"\n    global swipe_x1, swipe_y1, swipe_x2, swipe_y2\n    w, h = im.size\n    left = int(w / 2)\n    top = int(1584 * (h / 1920.0))\n    left = int(random.uniform(left - 200, left + 200))\n    top = int(random.uniform(top - 200, top + 200))  # 随机防 ban\n    after_top = int(random.uniform(top - 200, top + 200))\n    after_left = int(random.uniform(left - 200, left + 200))\n    swipe_x1, swipe_y1, swipe_x2, swipe_y2 = left, top, after_left, after_top\n\n\ndef jump(distance, delta_piece_y):\n    \"\"\"\n    跳跃一定的距离\n    \"\"\"\n    # 计算程序长度与截图测得的距离的比例\n    scale = 0.945 * 2 / head_diameter\n    actual_distance = distance * scale * (math.sqrt(6) / 2)\n    press_time = (-945 + math.sqrt(945 ** 2 + 4 * 105 *\n                                   36 * actual_distance)) / (2 * 105) * 1000\n    press_time *= press_coefficient\n    press_time = max(press_time, 200)  # 设置 200ms 是最小的按压时间\n    press_time = int(press_time)\n\n    cmd = 'shell input swipe {x1} {y1} {x2} {y2} {duration}'.format(\n        x1=swipe_x1,\n        y1=swipe_y1,\n        x2=swipe_x2,\n        y2=swipe_y2,\n        duration=press_time + delta_piece_y\n    )\n    print(cmd)\n    adb.run(cmd)\n    return press_time\n\n\ndef find_piece_and_board(im):\n    \"\"\"\n    寻找关键坐标\n    \"\"\"\n    w, h = im.size\n    points = []  # 所有满足色素的点集合\n    piece_y_max = 0\n    board_x = 0\n    board_y = 0\n    scan_x_border = int(w / 8)  # 扫描棋子时的左右边界\n    scan_start_y = 0  # 扫描的起始 y 坐标\n    im_pixel = im.load()\n    # 以 50px 步长，尝试探测 scan_start_y\n    for i in range(int(h / 3), int(h * 2 / 3), 50):\n        last_pixel = im_pixel[0, i]\n        for j in range(1, w):\n            pixel = im_pixel[j, i]\n            # 不是纯色的线，则记录 scan_start_y 的值，准备跳出循环\n            if pixel != last_pixel:\n                scan_start_y = i - 50\n                break\n        if scan_start_y:\n            break\n    print('start scan Y axis: {}'.format(scan_start_y))\n\n    # 从 scan_start_y 开始往下扫描，棋子应位于屏幕上半部分，这里暂定不超过 2/3\n    for i in range(scan_start_y, int(h * 2 / 3)):\n        # 横坐标方面也减少了一部分扫描开销\n        for j in range(scan_x_border, w - scan_x_border):\n            pixel = im_pixel[j, i]\n            # 根据棋子的最低行的颜色判断，找最后一行那些点的平均值，这个颜\n            # 色这样应该 OK，暂时不提出来\n            if (50 < pixel[0] < 60) \\\n                    and (53 < pixel[1] < 63) \\\n                    and (95 < pixel[2] < 110):\n                points.append((j, i))\n                piece_y_max = max(i, piece_y_max)\n\n    bottom_x = [x for x, y in points if y == piece_y_max]  # 所有最底层的点的横坐标\n    if not bottom_x:\n        return 0, 0, 0, 0, 0\n\n    piece_x = int(sum(bottom_x) / len(bottom_x))  # 中间值\n    piece_y = piece_y_max - piece_base_height_1_2  # 上移棋子底盘高度的一半\n\n    # 限制棋盘扫描的横坐标，避免音符 bug\n    if piece_x < w / 2:\n        board_x_start = piece_x\n        board_x_end = w\n    else:\n        board_x_start = 0\n        board_x_end = piece_x\n\n    for i in range(int(h / 3), int(h * 2 / 3)):\n        last_pixel = im_pixel[0, i]\n        if board_x or board_y:\n            break\n        board_x_sum = 0\n        board_x_c = 0\n\n        for j in range(int(board_x_start), int(board_x_end)):\n            pixel = im_pixel[j, i]\n            # 修掉脑袋比下一个小格子还高的情况的 bug\n            if abs(j - piece_x) < piece_body_width:\n                continue\n\n            # 检查Y轴下面5个像素， 和背景色相同， 那么是干扰\n            ver_pixel = im_pixel[j, i + 5]\n            if abs(pixel[0] - last_pixel[0]) \\\n                    + abs(pixel[1] - last_pixel[1]) \\\n                    + abs(pixel[2] - last_pixel[2]) > 10 \\\n                    and abs(ver_pixel[0] - last_pixel[0]) \\\n                    + abs(ver_pixel[1] - last_pixel[1]) \\\n                    + abs(ver_pixel[2] - last_pixel[2]) > 10:\n                board_x_sum += j\n                board_x_c += 1\n        if board_x_sum:\n            board_x = board_x_sum / board_x_c\n    last_pixel = im_pixel[board_x, i]\n\n    # 首先找到游戏的对称中心，由对称中心做辅助线与x=board_x直线的交点即为棋盘的中心位置\n    # 有了对称中心，可以知道棋子在棋盘上面的相对位置（偏高或偏低，偏高的话测量值比实际值大，\n    # 偏低相反。最后通过delta_piece_y来对跳跃时间进行微调\n    center_x = w / 2 + (24 / 1080) * w\n    center_y = h / 2 + (17 / 1920) * h\n    if piece_x > center_x:\n        board_y = round((25.5 / 43.5) * (board_x - center_x) + center_y)\n        delta_piece_y = piece_y - round((25.5 / 43.5) * (piece_x - center_x) + center_y)\n    else:\n        board_y = round(-(25.5 / 43.5) * (board_x - center_x) + center_y)\n        delta_piece_y = piece_y - round(-(25.5 / 43.5) * (piece_x - center_x) + center_y)\n\n    if not all((board_x, board_y)):\n        return 0, 0, 0, 0, 0\n    return piece_x, piece_y, board_x, board_y, delta_piece_y\n\n\ndef yes_or_no():\n    \"\"\"\n    检查是否已经为启动程序做好了准备\n    \"\"\"\n    while True:\n        yes_or_no = str(input('请确保手机打开了 ADB 并连接了电脑，'\n                              '然后打开跳一跳并【开始游戏】后再用本程序，确定开始？[y/n]:'))\n        if yes_or_no == 'y':\n            break\n        elif yes_or_no == 'n':\n            print('谢谢使用', end='')\n            exit(0)\n        else:\n            print('请重新输入')\n\n\ndef main():\n    \"\"\"\n    主函数\n    \"\"\"\n    print('程序版本号：{}'.format(VERSION))\n    print('激活窗口并按 CONTROL + C 组合键退出')\n    debug.dump_device_info()\n    screenshot.check_screenshot()\n\n    i, next_rest, next_rest_time = (0, random.randrange(3, 10),\n                                    random.randrange(5, 10))\n    while True:\n        im = screenshot.pull_screenshot()\n        # 获取棋子和 board 的位置\n        piece_x, piece_y, board_x, board_y, delta_piece_y = find_piece_and_board(im)\n        ts = int(time.time())\n        print(ts, piece_x, piece_y, board_x, board_y)\n        set_button_position(im)\n        jump(math.sqrt((board_x - piece_x) ** 2 + (board_y - piece_y) ** 2), delta_piece_y)\n        if DEBUG_SWITCH:\n            debug.save_debug_screenshot(ts, im, piece_x,\n                                        piece_y, board_x, board_y)\n            debug.backup_screenshot(ts)\n        im.close()\n        i += 1\n        if i == next_rest:\n            print('已经连续打了 {} 下，休息 {}秒'.format(i, next_rest_time))\n            for j in range(next_rest_time):\n                sys.stdout.write('\\r程序将在 {}秒 后继续'.format(next_rest_time - j))\n                sys.stdout.flush()\n                time.sleep(1)\n            print('\\n继续')\n            i, next_rest, next_rest_time = (0, random.randrange(30, 100),\n                                            random.randrange(10, 60))\n        # 为了保证截图的时候应落稳了，多延迟一会儿，随机值防 ban\n        time.sleep(random.uniform(1.2, 1.4))\n\n\nif __name__ == '__main__':\n    try:\n        yes_or_no()\n        main()\n    except KeyboardInterrupt:\n        adb.run('kill-server')\n        print('\\n谢谢使用', end='')\n        exit(0)\n"
        },
        {
          "name": "wechat_jump_auto_ai.py",
          "type": "blob",
          "size": 15.6806640625,
          "content": "# coding: utf-8\n'''\n# === 思路 ===\n# 核心：每次落稳之后截图，根据截图算出棋子的坐标和下一个块顶面的中点坐标，\n#      根据两个点的距离乘以一个时间系数获得长按的时间\n# 识别棋子：靠棋子的颜色来识别位置，通过截图发现最下面一行大概是一条直线，就从上往下一行一行遍历，\n#      比较颜色（颜色用了一个区间来比较）找到最下面的那一行的所有点，然后求个中点，\n#      求好之后再让 Y 轴坐标减小棋子底盘的一半高度从而得到中心点的坐标\n# 识别棋盘：靠底色和方块的色差来做，从分数之下的位置开始，一行一行扫描，由于圆形的块最顶上是一条线，\n#      方形的上面大概是一个点，所以就用类似识别棋子的做法多识别了几个点求中点，\n#      这时候得到了块中点的 X 轴坐标，这时候假设现在棋子在当前块的中心，\n#      根据一个通过截图获取的固定的角度来推出中点的 Y 坐标\n# 最后：根据两点的坐标算距离乘以系数来获取长按时间（似乎可以直接用 X 轴距离）\n'''\nimport os\nimport sys\nimport subprocess\nimport time\nimport math\nimport pandas\nfrom PIL import Image\nimport random\nfrom six.moves import input\n\ntry:\n    from common import ai, debug, config, UnicodeStreamFilter\n    from common.auto_adb import auto_adb\nexcept Exception as ex:\n    print(ex)\n    print('请将脚本放在项目根目录中运行')\n    print('请检查项目根目录中的 common 文件夹是否存在')\n    exit(1)\nadb = auto_adb()\nVERSION = \"1.1.4\"\n\ndebug_switch = True  # debug 开关，需要调试的时候请改为：True\nconfig = config.open_accordant_config()\n\n# Magic Number，不设置可能无法正常执行，请根据具体截图从上到下按需设置，设置保存在 config 文件夹中\nunder_game_score_y = config['under_game_score_y']\npress_coefficient = config['press_coefficient']  # 长按的时间系数，请自己根据实际情况调节\npiece_base_height_1_2 = config['piece_base_height_1_2']  # 二分之一的棋子底座高度，可能要调节\npiece_body_width = config['piece_body_width']  # 棋子的宽度，比截图中量到的稍微大一点比较安全，可能要调节\n\nscreenshot_way = 2\n\n\ndef pull_screenshot():\n    process = subprocess.Popen('adb shell screencap -p', shell=True, stdout=subprocess.PIPE)\n    screenshot = process.stdout.read()\n    if sys.platform == 'win32':\n        screenshot = screenshot.replace(b'\\r\\n', b'\\n')\n    f = open('autojump.png', 'wb')\n    f.write(screenshot)\n    f.close()\n\n\ndef pull_screenshot_temp():\n    process = subprocess.Popen('adb shell screencap -p', shell=True, stdout=subprocess.PIPE)\n    screenshot = process.stdout.read()\n    if sys.platform == 'win32':\n        screenshot = screenshot.replace(b'\\r\\n', b'\\n')\n    f = open('autojump_temp.png', 'wb')\n    f.write(screenshot)\n    f.close()\n\n\ndef set_button_position(im):\n    \"\"\"\n    将 swipe 设置为 `再来一局` 按钮的位置\n    \"\"\"\n    global swipe_x1, swipe_y1, swipe_x2, swipe_y2\n    w, h = im.size\n    left = int(w / 2)\n    top = int(1584 * (h / 1920.0))\n    left = int(random.uniform(left - 100, left + 100))\n    top = int(random.uniform(top - 100, top + 100))  # 随机防 ban\n    after_top = int(random.uniform(top - 100, top + 100))\n    after_left = int(random.uniform(left - 100, left + 100))\n    swipe_x1, swipe_y1, swipe_x2, swipe_y2 = left, top, after_left, after_top\n\n\ndef jump(distance):\n    '''\n    跳跃一定的距离\n    '''\n    if ai.get_result_len() >= 10:  # 需采集10条样本以上\n        k, b, v = ai.computing_k_b_v(distance)\n        press_time = distance * k[0] + b\n        print('Y = {k} * X + {b}'.format(k=k[0], b=b))\n\n    else:\n        press_time = distance * press_coefficient\n        press_time = max(press_time, 200)  # 设置 200ms 是最小的按压时间\n\n    press_time = int(press_time)\n    cmd = 'shell input swipe {x1} {y1} {x2} {y2} {duration}'.format(\n        x1=swipe_x1,\n        y1=swipe_y1,\n        x2=swipe_x2,\n        y2=swipe_y2,\n        duration=press_time\n    )\n    print('{}'.format(cmd))\n    adb.run(cmd)\n    return press_time\n\n\n# 转换色彩模式hsv2rgb\ndef hsv2rgb(h, s, v):\n    h = float(h)\n    s = float(s)\n    v = float(v)\n    h60 = h / 60.0\n    h60f = math.floor(h60)\n    hi = int(h60f) % 6\n    f = h60 - h60f\n    p = v * (1 - s)\n    q = v * (1 - f * s)\n    t = v * (1 - (1 - f) * s)\n    r, g, b = 0, 0, 0\n    if hi == 0:\n        r, g, b = v, t, p\n    elif hi == 1:\n        r, g, b = q, v, p\n    elif hi == 2:\n        r, g, b = p, v, t\n    elif hi == 3:\n        r, g, b = p, q, v\n    elif hi == 4:\n        r, g, b = t, p, v\n    elif hi == 5:\n        r, g, b = v, p, q\n    r, g, b = int(r * 255), int(g * 255), int(b * 255)\n    return r, g, b\n\n\n# 转换色彩模式rgb2hsv\ndef rgb2hsv(r, g, b):\n    r, g, b = r / 255.0, g / 255.0, b / 255.0\n    mx = max(r, g, b)\n    mn = min(r, g, b)\n    df = mx - mn\n    if mx == mn:\n        h = 0\n    elif mx == r:\n        h = (60 * ((g - b) / df) + 360) % 360\n    elif mx == g:\n        h = (60 * ((b - r) / df) + 120) % 360\n    elif mx == b:\n        h = (60 * ((r - g) / df) + 240) % 360\n    if mx == 0:\n        s = 0\n    else:\n        s = df / mx\n    v = mx\n    return h, s, v\n\n\ndef find_piece(im):\n    '''\n    寻找关键坐标\n    '''\n    w, h = im.size\n\n    piece_x_sum = 0\n    piece_x_c = 0\n    piece_y_max = 0\n    scan_x_border = int(w / 8)  # 扫描棋子时的左右边界\n    scan_start_y = 0  # 扫描的起始 y 坐标\n    im_pixel = im.load()\n    # 以 50px 步长，尝试探测 scan_start_y\n    for i in range(int(h / 3), int(h * 2 / 3), 50):\n        last_pixel = im_pixel[0, i]\n        for j in range(1, w):\n            pixel = im_pixel[j, i]\n            # 不是纯色的线，则记录 scan_start_y 的值，准备跳出循环\n            if pixel[0] != last_pixel[0] or pixel[1] != last_pixel[1] or pixel[2] != last_pixel[2]:\n                scan_start_y = i - 50\n                break\n        if scan_start_y:\n            break\n    # print('scan_start_y: {}'.format(scan_start_y))\n\n    # 从 scan_start_y 开始往下扫描，棋子应位于屏幕上半部分，这里暂定不超过 2/3\n    for i in range(scan_start_y, int(h * 2 / 3)):\n        for j in range(scan_x_border, w - scan_x_border):  # 横坐标方面也减少了一部分扫描开销\n            pixel = im_pixel[j, i]\n            # 根据棋子的最低行的颜色判断，找最后一行那些点的平均值，这个颜色这样应该 OK，暂时不提出来\n            if (50 < pixel[0] < 60) and (53 < pixel[1] < 63) and (95 < pixel[2] < 110):\n                piece_x_sum += j\n                piece_x_c += 1\n                piece_y_max = max(i, piece_y_max)\n\n    if not all((piece_x_sum, piece_x_c)):\n        return 0, 0,\n    piece_x = int(piece_x_sum / piece_x_c)\n    piece_y = piece_y_max - piece_base_height_1_2  # 上移棋子底盘高度的一半\n\n    return piece_x, piece_y\n\n\ndef find_piece_and_board(im):\n    w, h = im.size\n\n    piece_x_sum = 0\n    piece_x_c = 0\n    piece_y_max = 0\n    board_x = 0\n    board_y = 0\n\n    left_value = 0\n    left_count = 0\n    right_value = 0\n    right_count = 0\n    from_left_find_board_y = 0\n    from_right_find_board_y = 0\n\n    scan_x_border = int(w / 8)  # 扫描棋子时的左右边界\n    scan_start_y = 0  # 扫描的起始y坐标\n    im_pixel = im.load()\n    # 以50px步长，尝试探测scan_start_y\n    for i in range(int(h / 3), int(h * 2 / 3), 50):\n        last_pixel = im_pixel[0, i]\n        for j in range(1, w):\n            pixel = im_pixel[j, i]\n            # 不是纯色的线，则记录scan_start_y的值，准备跳出循环\n            if pixel[0] != last_pixel[0] or pixel[1] != last_pixel[1] or pixel[2] != last_pixel[2]:\n                scan_start_y = i - 50\n                break\n        if scan_start_y:\n            break\n    # print('scan_start_y: ', scan_start_y)\n\n    # 从scan_start_y开始往下扫描，棋子应位于屏幕上半部分，这里暂定不超过2/3\n    for i in range(scan_start_y, int(h * 2 / 3)):\n        for j in range(scan_x_border, w - scan_x_border):  # 横坐标方面也减少了一部分扫描开销\n            pixel = im_pixel[j, i]\n            # 根据棋子的最低行的颜色判断，找最后一行那些点的平均值，这个颜色这样应该 OK，暂时不提出来\n            if (50 < pixel[0] < 60) and (53 < pixel[1] < 63) and (95 < pixel[2] < 110):\n                piece_x_sum += j\n                piece_x_c += 1\n                piece_y_max = max(i, piece_y_max)\n\n    if not all((piece_x_sum, piece_x_c)):\n        return 0, 0, 0, 0\n    piece_x = piece_x_sum / piece_x_c\n    piece_y = piece_y_max - piece_base_height_1_2  # 上移棋子底盘高度的一半\n\n    for i in range(int(h / 3), int(h * 2 / 3)):\n\n        last_pixel = im_pixel[0, i]\n        # 计算阴影的RGB值,通过photoshop观察,阴影部分其实就是背景色的明度V 乘以0.7的样子\n        h, s, v = rgb2hsv(last_pixel[0], last_pixel[1], last_pixel[2])\n        r, g, b = hsv2rgb(h, s, v * 0.7)\n\n        if from_left_find_board_y and from_right_find_board_y:\n            break\n\n        if not board_x:\n            board_x_sum = 0\n            board_x_c = 0\n\n            for j in range(w):\n                pixel = im_pixel[j, i]\n                # 修掉脑袋比下一个小格子还高的情况的 bug\n                if abs(j - piece_x) < piece_body_width:\n                    continue\n\n                # 修掉圆顶的时候一条线导致的小 bug，这个颜色判断应该 OK，暂时不提出来\n                if abs(pixel[0] - last_pixel[0]) + abs(pixel[1] - last_pixel[1]) + abs(pixel[2] - last_pixel[2]) > 10:\n                    board_x_sum += j\n                    board_x_c += 1\n            if board_x_sum:\n                board_x = board_x_sum / board_x_c\n        else:\n            # 继续往下查找,从左到右扫描,找到第一个与背景颜色不同的像素点,记录位置\n            # 当有连续3个相同的记录时,表示发现了一条直线\n            # 这条直线即为目标board的左边缘\n            # 然后当前的 y 值减 3 获得左边缘的第一个像素\n            # 就是顶部的左边顶点\n            for j in range(w):\n                pixel = im_pixel[j, i]\n                # 修掉脑袋比下一个小格子还高的情况的 bug\n                if abs(j - piece_x) < piece_body_width:\n                    continue\n                if (abs(pixel[0] - last_pixel[0]) + abs(pixel[1] - last_pixel[1]) + abs(pixel[2] - last_pixel[2])\n                    > 10) and (abs(pixel[0] - r) + abs(pixel[1] - g) + abs(pixel[2] - b) > 10):\n                    if left_value == j:\n                        left_count = left_count + 1\n                    else:\n                        left_value = j\n                        left_count = 1\n\n                    if left_count > 3:\n                        from_left_find_board_y = i - 3\n                    break\n            # 逻辑跟上面类似,但是方向从右向左\n            # 当有遮挡时,只会有一边有遮挡\n            # 算出来两个必然有一个是对的\n            for j in range(w)[::-1]:\n                pixel = im_pixel[j, i]\n                # 修掉脑袋比下一个小格子还高的情况的 bug\n                if abs(j - piece_x) < piece_body_width:\n                    continue\n                if (abs(pixel[0] - last_pixel[0]) + abs(pixel[1] - last_pixel[1]) + abs(pixel[2] - last_pixel[2])\n                    > 10) and (abs(pixel[0] - r) + abs(pixel[1] - g) + abs(pixel[2] - b) > 10):\n                    if right_value == j:\n                        right_count = left_count + 1\n                    else:\n                        right_value = j\n                        right_count = 1\n\n                    if right_count > 3:\n                        from_right_find_board_y = i - 3\n                    break\n\n    # 如果顶部像素比较多,说明图案近圆形,相应的求出来的值需要增大,这里暂定增大顶部宽的三分之一\n    if board_x_c > 5:\n        from_left_find_board_y = from_left_find_board_y + board_x_c / 3\n        from_right_find_board_y = from_right_find_board_y + board_x_c / 3\n\n    # 按实际的角度来算，找到接近下一个 board 中心的坐标 这里的角度应该是30°,值应该是tan 30°,math.sqrt(3) / 3\n    board_y = piece_y - abs(board_x - piece_x) * math.sqrt(3) / 3\n\n    # 从左从右取出两个数据进行对比,选出来更接近原来老算法的那个值\n    if abs(board_y - from_left_find_board_y) > abs(from_right_find_board_y):\n        new_board_y = from_right_find_board_y\n    else:\n        new_board_y = from_left_find_board_y\n\n    if not all((board_x, board_y)):\n        return 0, 0, 0, 0\n\n    return piece_x, piece_y, board_x, new_board_y\n\n\ndef check_screenshot():\n    '''\n    检查获取截图的方式\n    '''\n    global screenshot_way\n    if os.path.isfile('autojump.png'):\n        os.remove('autojump.png')\n    if (screenshot_way < 0):\n        print('暂不支持当前设备')\n        sys.exit()\n    pull_screenshot()\n    try:\n        Image.open('./autojump.png').load()\n        print('采用方式 {} 获取截图'.format(screenshot_way))\n    except Exception:\n        screenshot_way -= 1\n        check_screenshot()\n\n\ndef yes_or_no(prompt, true_value='y', false_value='n', default=True):\n    default_value = true_value if default else false_value\n    prompt = '%s %s/%s [%s]: ' % (prompt, true_value, false_value, default_value)\n    i = input(prompt)\n    if not i:\n        return default\n    while True:\n        if i == true_value:\n            return True\n        elif i == false_value:\n            return False\n        prompt = 'Please input %s or %s: ' % (true_value, false_value)\n        i = input(prompt)\n\n\ndef main():\n    '''\n    主函数\n    '''\n    # op = yes_or_no('请确保手机打开了 ADB 并连接了电脑，然后打开跳一跳并【开始游戏】后再用本程序，确定开始？')\n    # if not op:\n    #    print('bye')\n    #    return\n    # 初始化AI\n    ai.init()\n\n    print('程序版本号：{}'.format(VERSION))\n    debug.dump_device_info()\n    check_screenshot()\n\n    i, next_rest, next_rest_time = 0, random.randrange(3, 10), random.randrange(5, 10)\n    while True:\n        pull_screenshot()\n        im = Image.open('./autojump.png')\n        # 获取棋子和 board 的位置\n        piece_x, piece_y, board_x, board_y = find_piece_and_board(im)\n        ts = int(time.time())\n        # print(ts, piece_x, piece_y, board_x, board_y)\n        set_button_position(im)\n        press_time = jump(math.sqrt((board_x - piece_x) ** 2 + (board_y - piece_y) ** 2))\n\n        # 在跳跃落下的瞬间 摄像机移动前截图 这个参数要自己校调\n        time.sleep(0.2)\n        pull_screenshot_temp()\n        im_temp = Image.open('./autojump_temp.png')\n        temp_piece_x, temp_piece_y = find_piece(im_temp)\n        debug.computing_error(press_time, board_x, board_y, piece_x, piece_y, temp_piece_x, temp_piece_y)\n\n        if debug_switch:\n            debug.save_debug_screenshot(ts, im, piece_x, piece_y, board_x, board_y)\n            debug.save_debug_screenshot(ts, im_temp, temp_piece_x, temp_piece_y, board_x, board_y)\n            # debug.backup_screenshot(ts)\n        i = 0\n        if i == next_rest:\n            print('已经连续打了 {} 下，休息 {}s'.format(i, next_rest_time))\n            for j in range(next_rest_time):\n                sys.stdout.write('\\r程序将在 {}s 后继续'.format(next_rest_time - j))\n                sys.stdout.flush()\n                time.sleep(1)\n            print('\\n继续')\n            i, next_rest, next_rest_time = 0, random.randrange(30, 100), random.randrange(10, 60)\n        time.sleep(random.uniform(0.5, 0.6))  # 为了保证截图的时候应落稳了，多延迟一会儿，随机值防 ban\n\n\nif __name__ == '__main__':\n    try:\n        main()\n    except KeyboardInterrupt:\n        adb.run('kill-server')\n        print('bye')\n        exit(0)\n"
        },
        {
          "name": "wechat_jump_auto_curves.py",
          "type": "blob",
          "size": 13.634765625,
          "content": "# -*- coding: utf-8 -*-\n\n\"\"\"\n##基于python3.5(64位)\n###如果缺少scikit-image库，建议进下面网址下载whl直接安装\n##https://www.lfd.uci.edu/~gohlke/pythonlibs/#scikit-image\n\n\n=== 思路 ===\n核心：每次落稳之后截图，根据截图算出棋子的坐标和下一个块顶面的中点坐标，\n    根据两个点的距离乘以一个时间系数获得长按的时间\n识别棋子：靠棋子的颜色来识别位置，通过截图发现最下面一行大概是一条\n    直线，就从上往下一行一行遍历，比较颜色（颜色用了一个区间来比较）\n    找到最下面的那一行的所有点，然后求个中点，求好之后再让 Y 轴坐标\n    减小棋子底盘的一半高度从而得到中心点的坐标\n识别棋盘：靠底色和方块的色差来做，从分数之下的位置开始，一行一行扫描，\n    由于圆形的块最顶上是一条线，方形的上面大概是一个点，所以就\n    用类似识别棋子的做法多识别了几个点求中点，这时候得到了块中点的 X\n    轴坐标，这时候假设现在棋子在当前块的中心，根据一个通过截图获取的\n    固定的角度来推出中点的 Y 坐标\n最后：根据两点的坐标算距离乘以系数来获取长按时间（似乎可以直接用 X 轴距离）\n\"\"\"\nfrom __future__ import print_function, division\nimport sys\nimport time\nimport math\nimport random\nfrom PIL import Image\nfrom six.moves import input\nfrom skimage import io,transform\nimport numpy as np\nimport tensorflow as tf\n\ntry:\n    from common import debug, config, screenshot, UnicodeStreamFilter\n    from common.auto_adb import auto_adb\nexcept Exception as ex:\n    print(ex)\n    print('请将脚本放在项目根目录中运行')\n    print('请检查项目根目录中的 common 文件夹是否存在')\n    exit(1)\nadb = auto_adb()\nVERSION = \"1.1.4\"\n\n# DEBUG 开关，需要调试的时候请改为 True，不需要调试的时候为 False\nDEBUG_SWITCH = False\n\n\n# Magic Number，不设置可能无法正常执行，请根据具体截图从上到下按需\n# 设置，设置保存在 config 文件夹中\nconfig = config.open_accordant_config()\nunder_game_score_y = config['under_game_score_y']\n# 长按的时间系数，请自己根据实际情况调节\npress_coefficient = config['press_coefficient']\n# 二分之一的棋子底座高度，可能要调节\npiece_base_height_1_2 = config['piece_base_height_1_2']\n# 棋子的宽度，比截图中量到的稍微大一点比较安全，可能要调节\npiece_body_width = config['piece_body_width']\n\ntarget_score=1024         ##目标分数\ntotal_step=30    ##达到目标次数所需游戏次数\nstart_score=100        ##设置第一次分数(目前分数)\n\n\n\ndef set_button_position(im):\n    \"\"\"\n    将 swipe 设置为 `再来一局` 按钮的位置\n    \"\"\"\n    global swipe_x1, swipe_y1, swipe_x2, swipe_y2\n    w, h = im.size\n    left = int(w / 2)\n    top = int(1584 * (h / 1920.0))\n    left = int(random.uniform(left - 100, left + 100))\n    top = int(random.uniform(top - 100, top + 100))  # 随机防 ban\n    after_top = int(random.uniform(top - 100, top + 100))\n    after_left = int(random.uniform(left - 100, left + 100))\n    swipe_x1, swipe_y1, swipe_x2, swipe_y2 = left, top, after_left, after_top\n\n\n\ndef jump(distance):\n    \"\"\"\n    跳跃一定的距离\n    \"\"\"\n    press_time = distance * press_coefficient\n    press_time = max(press_time, 200)   # 设置 200ms 是最小的按压时间\n    press_time = int(press_time)\n\n    cmd = 'shell input swipe {x1} {y1} {x2} {y2} {duration}'.format(\n        x1=swipe_x1,\n        y1=swipe_y1,\n        x2=swipe_x2,\n        y2=swipe_y2,\n        duration=press_time\n    )\n    print('{} {}'.format(adb.adb_path, cmd))\n    adb.run(cmd)\n    return press_time\n\n\ndef find_piece_and_board(im):\n    \"\"\"\n    寻找关键坐标\n    \"\"\"\n    w, h = im.size\n\n    piece_x_sum = 0\n    piece_x_c = 0\n    piece_y_max = 0\n    board_x = 0\n    board_y = 0\n    scan_x_border = int(w / 8)  # 扫描棋子时的左右边界\n    scan_start_y = 0  # 扫描的起始 y 坐标\n    im_pixel = im.load()\n    # 以 50px 步长，尝试探测 scan_start_y\n    for i in range(int(h / 3), int(h*2 / 3), 50):\n        last_pixel = im_pixel[0, i]\n        for j in range(1, w):\n            pixel = im_pixel[j, i]\n            # 不是纯色的线，则记录 scan_start_y 的值，准备跳出循环\n            if pixel != last_pixel:\n                scan_start_y = i - 50\n                break\n        if scan_start_y:\n            break\n    print('scan_start_y: {}'.format(scan_start_y))\n\n    # 从 scan_start_y 开始往下扫描，棋子应位于屏幕上半部分，这里暂定不超过 2/3\n    for i in range(scan_start_y, int(h * 2 / 3)):\n        # 横坐标方面也减少了一部分扫描开销\n        for j in range(scan_x_border, w - scan_x_border):\n            pixel = im_pixel[j, i]\n            # 根据棋子的最低行的颜色判断，找最后一行那些点的平均值，这个颜\n            # 色这样应该 OK，暂时不提出来\n            if (50 < pixel[0] < 60) \\\n                    and (53 < pixel[1] < 63) \\\n                    and (95 < pixel[2] < 110):\n                piece_x_sum += j\n                piece_x_c += 1\n                piece_y_max = max(i, piece_y_max)\n\n    if not all((piece_x_sum, piece_x_c)):\n        return 0, 0, 0, 0\n    piece_x = int(piece_x_sum / piece_x_c)\n    piece_y = piece_y_max - piece_base_height_1_2  # 上移棋子底盘高度的一半\n\n    # 限制棋盘扫描的横坐标，避免音符 bug\n    if piece_x < w/2:\n        board_x_start = piece_x\n        board_x_end = w\n    else:\n        board_x_start = 0\n        board_x_end = piece_x\n\n    for i in range(int(h / 3), int(h * 2 / 3)):\n        last_pixel = im_pixel[0, i]\n        if board_x or board_y:\n            break\n        board_x_sum = 0\n        board_x_c = 0\n\n        for j in range(int(board_x_start), int(board_x_end)):\n            pixel = im_pixel[j, i]\n            # 修掉脑袋比下一个小格子还高的情况的 bug\n            if abs(j - piece_x) < piece_body_width:\n                continue\n\n            # 修掉圆顶的时候一条线导致的小 bug，这个颜色判断应该 OK，暂时不提出来\n            if abs(pixel[0] - last_pixel[0]) \\\n                    + abs(pixel[1] - last_pixel[1]) \\\n                    + abs(pixel[2] - last_pixel[2]) > 10:\n                board_x_sum += j\n                board_x_c += 1\n        if board_x_sum:\n            board_x = board_x_sum / board_x_c\n    last_pixel = im_pixel[board_x, i]\n\n    # 从上顶点往下 +274 的位置开始向上找颜色与上顶点一样的点，为下顶点\n    # 该方法对所有纯色平面和部分非纯色平面有效，对高尔夫草坪面、木纹桌面、\n    # 药瓶和非菱形的碟机（好像是）会判断错误\n    for k in range(i+274, i, -1):  # 274 取开局时最大的方块的上下顶点距离\n        pixel = im_pixel[board_x, k]\n        if abs(pixel[0] - last_pixel[0]) \\\n                + abs(pixel[1] - last_pixel[1]) \\\n                + abs(pixel[2] - last_pixel[2]) < 10:\n            break\n    board_y = int((i+k) / 2)\n\n    # 如果上一跳命中中间，则下个目标中心会出现 r245 g245 b245 的点，利用这个\n    # 属性弥补上一段代码可能存在的判断错误\n    # 若上一跳由于某种原因没有跳到正中间，而下一跳恰好有无法正确识别花纹，则有\n    # 可能游戏失败，由于花纹面积通常比较大，失败概率较低\n    for j in range(i, i+200):\n        pixel = im_pixel[board_x, j]\n        if abs(pixel[0] - 245) + abs(pixel[1] - 245) + abs(pixel[2] - 245) == 0:\n            board_y = j + 10\n            break\n\n    if not all((board_x, board_y)):\n        return 0, 0, 0, 0\n    return piece_x, piece_y, board_x, board_y\n\n\ndef yes_or_no(prompt, true_value='y', false_value='n', default=True):\n    \"\"\"\n    检查是否已经为启动程序做好了准备\n    \"\"\"\n    default_value = true_value if default else false_value\n    prompt = '{} {}/{} [{}]: '.format(prompt, true_value,\n        false_value, default_value)\n    i = input(prompt)\n    if not i:\n        return default\n    while True:\n        if i == true_value:\n            return True\n        elif i == false_value:\n            return False\n        prompt = 'Please input {} or {}: '.format(true_value, false_value)\n        i = input(prompt)\n\ndef pross_data(image):\n    pixels = list(image.getdata())  # 得到像素数据 灰度0-255\n    #print(len(pixels))\n    for i in range(len(pixels)):\n        if pixels[i]<100:\n            pixels[i]=0\n        else:\n            pixels[i]=255\n    return pixels\n\ndef pixel_division(img,w,h):\n    pixels = list(img.getdata())\n    row_pix=np.zeros([1,h])\n    col_pix=np.zeros([1,w])\n    for i in range(w):\n        for j in range(h):\n            if pixels[j*w+i]<100:\n                row_pix[0,j]+=1\n                col_pix[0,i]+=1\n    start_h=0\n    end_h=0\n    flag=0\n    for j in range(h):\n        if row_pix[0,j]>=1 and flag==0:\n            start_h=j\n            flag=1\n        if row_pix[0,j]>=1:\n            end_h=j\n\n    pixels_Widh=[]\n    end_w=0\n    for i in range(1,w):\n        if col_pix[0,i-1]<=0 and col_pix[0,i]>=1:\n            pixels_Widh.append(i-1)\n        if col_pix[0,i]>=1:\n            end_w=i\n    pixels_Widh.append(end_w+1)\n    return start_h,end_h,pixels_Widh\n\ndef strint(score0):\n    if(score0<10):\n        return str(score0)\n    else:\n        return \"\"\n\ndef read_one_image(path):\n    img = io.imread(path)\n    w=81\n    h=81\n    c=1\n    img = transform.resize(img,(w,h,c))\n    return np.asarray(img)\n\ndef main():\n    \"\"\"\n    主函数\n    \"\"\"\n    op = yes_or_no('请确保手机打开了 ADB 并连接了电脑，'\n                   '然后打开跳一跳并【开始游戏】后再用本程序，确定开始？')\n    if not op:\n        print('bye')\n        return\n    print('程序版本号：{}'.format(VERSION))\n    debug.dump_device_info()\n    screenshot.check_screenshot()\n\n    i, next_rest, next_rest_time = (0, random.randrange(3, 10),\n                                    random.randrange(5, 10))\n    j= 0\n    ################ 分数曲线公式\n\n    y_score=[]\n    next_start=0\n    global start_score\n    for i in range(total_step):\n        each_score=target_score*(1-np.exp(-0.15*(1024.0/target_score)*i))\n        y_score.append(each_score)\n        if start_score>each_score:\n            next_start=i\n    next_start+=1\n    #print(y_score)\n    if start_score<y_score[0]:\n        next_start=0\n\n    ###################\n    with tf.Session() as sess:\n        saver = tf.train.import_meta_graph('./resource/model/model.ckpt.meta')\n        saver.restore(sess,tf.train.latest_checkpoint('./resource/model/'))\n\n        graph = tf.get_default_graph()\n        x = graph.get_tensor_by_name(\"x:0\")\n        logits = graph.get_tensor_by_name(\"logits_eval:0\")\n    #####################识别分数\n        while True:\n            screenshot.pull_screenshot()\n            im = Image.open('./autojump.png')\n            ##比例系数\n            pix_w=im.size[0]*1.0/1080\n            pix_h=im.size[1]\n            region=im.crop((0,pix_h*0.1,460*pix_w,pix_h*0.2))\n            region=region.convert('L')\n            start_h,end_h,pixels_Widh=pixel_division(region,int(460*pix_w),int(pix_h*0.1))\n            if start_h==end_h:\n                continue\n            data = []\n            for i in range(len(pixels_Widh)-1):\n                region1=region.crop((pixels_Widh[i],start_h,pixels_Widh[i+1],end_h))\n                region1.putdata(pross_data(region1))\n                str1=\"./region\"+str(i)+\".png\"\n                region1.save(str1)\n                data1 = read_one_image(str1)\n                data.append(data1)\n            feed_dict = {x:data}\n            classification_result = sess.run(logits,feed_dict)\n            output = []\n            output = tf.argmax(classification_result,1).eval()\n            m_score=\"\"\n            for i in range(len(output)):\n                m_score+=strint(output[i])\n            if m_score==\"\":\n                continue\n            m_score=int(m_score)\n            print('score:{}'.format(m_score))\n            ####################################\n            # 获取棋子和 board 的位置\n            print(j)\n            piece_x, piece_y, board_x, board_y = find_piece_and_board(im)\n            ts = int(time.time())\n            print(ts, piece_x, piece_y, board_x, board_y)\n            set_button_position(im)\n\n            if m_score > y_score[next_start]: ##自动结束这一次\n                print(\"----------------\")\n                jump(math.sqrt((board_x - piece_x) ** 2 + (board_y - piece_y) ** 2)*5)\n                next_start+=1\n                time.sleep(5*random.random())\n            if next_start >len(y_score):\n                break\n            jump(math.sqrt((board_x - piece_x) ** 2 + (board_y - piece_y) ** 2))\n            if DEBUG_SWITCH:\n                debug.save_debug_screenshot(ts, im, piece_x,\n                                            piece_y, board_x, board_y)\n                debug.backup_screenshot(ts)\n            im.close()\n            i += 1\n            j += 1\n            if i == next_rest:\n                print('已经连续打了 {} 下，休息 {}s'.format(i, next_rest_time))\n                for j in range(next_rest_time):\n                    sys.stdout.write('\\r程序将在 {}s 后继续'.format(next_rest_time - j))\n                    sys.stdout.flush()\n                    time.sleep(1)\n                print('\\n继续')\n                i, next_rest, next_rest_time = (0, random.randrange(30, 100),\n                                                random.randrange(10, 60))\n            # 为了保证截图的时候应落稳了，多延迟一会儿，随机值防 ban\n            time.sleep(random.uniform(0.9, 1.2))\n\n\nif __name__ == '__main__':\n    try:\n        main()\n    except KeyboardInterrupt:\n        adb.run('kill-server')\n        print('bye')\n        exit(0)\n"
        },
        {
          "name": "wechat_jump_auto_iOS.py",
          "type": "blob",
          "size": 7.2705078125,
          "content": "# -*- coding: utf-8 -*-\n\n\"\"\"\n# === 思路 ===\n# 核心：每次落稳之后截图，根据截图算出棋子的坐标和下一个块顶面的中点坐标，\n#      根据两个点的距离乘以一个时间系数获得长按的时间\n# 识别棋子：靠棋子的颜色来识别位置，通过截图发现最下面一行大概是一条\n           直线，就从上往下一行一行遍历，比较颜色（颜色用了一个区间来比较）\n           找到最下面的那一行的所有点，然后求个中点，求好之后再让 Y 轴坐标\n           减小棋子底盘的一半高度从而得到中心点的坐标\n# 识别棋盘：靠底色和方块的色差来做，从分数之下的位置开始，一行一行扫描，\n           由于圆形的块最顶上是一条线，方形的上面大概是一个点，所以就\n           用类似识别棋子的做法多识别了几个点求中点，这时候得到了块中点的 X\n           轴坐标，这时候假设现在棋子在当前块的中心，根据一个通过截图获取的\n           固定的角度来推出中点的 Y 坐标\n# 最后：根据两点的坐标算距离乘以系数来获取长按时间（似乎可以直接用 X 轴距离）\n\"\"\"\nimport os\nimport shutil\nimport time\nimport math\nimport random\nimport json\nfrom PIL import Image, ImageDraw\nimport wda\n\n\nwith open('config.json', 'r') as f:\n    config = json.load(f)\n\n\n# Magic Number，不设置可能无法正常执行，请根据具体截图从上到下按需设置\nunder_game_score_y = config['under_game_score_y']\n# 长按的时间系数，请自己根据实际情况调节\npress_coefficient = config['press_coefficient']\n# 二分之一的棋子底座高度，可能要调节\npiece_base_height_1_2 = config['piece_base_height_1_2']\n# 棋子的宽度，比截图中量到的稍微大一点比较安全，可能要调节\npiece_body_width = config['piece_body_width']\ntime_coefficient = config['press_coefficient']\n\n# 模拟按压的起始点坐标，需要自动重复游戏请设置成“再来一局”的坐标\nswipe = config.get('swipe', {\n    \"x1\": 320,\n    \"y1\": 410,\n    \"x2\": 320,\n    \"y2\": 410\n    })\nVERSION = \"1.1.4\"\nc = wda.Client()\ns = c.session()\n\nscreenshot_backup_dir = 'screenshot_backups/'\nif not os.path.isdir(screenshot_backup_dir):\n    os.mkdir(screenshot_backup_dir)\n\n\ndef pull_screenshot():\n    c.screenshot('1.png')\n\n\ndef jump(distance):\n    press_time = distance * time_coefficient / 1000\n    print('press time: {}'.format(press_time))\n    s.tap_hold(random.uniform(0, 320), random.uniform(64, 320), press_time)\n\n\ndef backup_screenshot(ts):\n    \"\"\"\n    为了方便失败的时候 debug\n    \"\"\"\n    if not os.path.isdir(screenshot_backup_dir):\n        os.mkdir(screenshot_backup_dir)\n    shutil.copy('1.png', '{}{}.png'.format(screenshot_backup_dir, ts))\n\n\ndef save_debug_creenshot(ts, im, piece_x, piece_y, board_x, board_y):\n    draw = ImageDraw.Draw(im)\n    # 对debug图片加上详细的注释\n    draw.line((piece_x, piece_y) + (board_x, board_y), fill=2, width=3)\n    draw.line((piece_x, 0, piece_x, im.size[1]), fill=(255, 0, 0))\n    draw.line((0, piece_y, im.size[0], piece_y), fill=(255, 0, 0))\n    draw.line((board_x, 0, board_x, im.size[1]), fill=(0, 0, 255))\n    draw.line((0, board_y, im.size[0], board_y), fill=(0, 0, 255))\n    draw.ellipse(\n        (piece_x - 10, piece_y - 10, piece_x + 10, piece_y + 10),\n        fill=(255, 0, 0))\n    draw.ellipse(\n        (board_x - 10, board_y - 10, board_x + 10, board_y + 10),\n        fill=(0, 0, 255))\n    del draw\n    im.save('{}{}_d.png'.format(screenshot_backup_dir, ts))\n\n\ndef set_button_position(im):\n    \"\"\"\n    将swipe设置为 `再来一局` 按钮的位置\n    \"\"\"\n    global swipe_x1, swipe_y1, swipe_x2, swipe_y2\n    w, h = im.size\n    left = w / 2\n    top = 1003 * (h / 1280.0) + 10\n    swipe_x1, swipe_y1, swipe_x2, swipe_y2 = left, top, left, top\n\n\ndef find_piece_and_board(im):\n    w, h = im.size\n\n    print(\"size: {}, {}\".format(w, h))\n\n    piece_x_sum = piece_x_c = piece_y_max = 0\n    board_x = board_y = 0\n    scan_x_border = int(w / 8)  # 扫描棋子时的左右边界\n    scan_start_y = 0  # 扫描的起始 y 坐标\n    im_pixel = im.load()\n\n    # 以 50px 步长，尝试探测 scan_start_y\n    for i in range(under_game_score_y, h, 50):\n        last_pixel = im_pixel[0, i]\n        for j in range(1, w):\n            pixel = im_pixel[j, i]\n\n            # 不是纯色的线，则记录scan_start_y的值，准备跳出循环\n            if pixel != last_pixel:\n                scan_start_y = i - 50\n                break\n\n        if scan_start_y:\n            break\n\n    print(\"scan_start_y: \", scan_start_y)\n\n    # 从 scan_start_y 开始往下扫描，棋子应位于屏幕上半部分，这里暂定不超过 2/3\n    for i in range(scan_start_y, int(h * 2 / 3)):\n        # 横坐标方面也减少了一部分扫描开销\n        for j in range(scan_x_border, w - scan_x_border):\n            pixel = im_pixel[j, i]\n            # 根据棋子的最低行的颜色判断，找最后一行那些点的平均值，这个颜\n            # 色这样应该 OK，暂时不提出来\n            if (50 < pixel[0] < 60) \\\n                    and (53 < pixel[1] < 63) \\\n                    and (95 < pixel[2] < 110):\n                piece_x_sum += j\n                piece_x_c += 1\n                piece_y_max = max(i, piece_y_max)\n\n    if not all((piece_x_sum, piece_x_c)):\n        return 0, 0, 0, 0\n    piece_x = piece_x_sum / piece_x_c\n    piece_y = piece_y_max - piece_base_height_1_2  # 上移棋子底盘高度的一半\n\n    for i in range(int(h / 3), int(h * 2 / 3)):\n        last_pixel = im_pixel[0, i]\n        if board_x or board_y:\n            break\n        board_x_sum = 0\n        board_x_c = 0\n\n        for j in range(w):\n            pixel = im_pixel[j, i]\n            # 修掉脑袋比下一个小格子还高的情况的 bug\n            if abs(j - piece_x) < piece_body_width:\n                continue\n\n            # 修掉圆顶的时候一条线导致的小 bug，这个颜色判断应该 OK，暂时不提出来\n            if abs(pixel[0] - last_pixel[0]) \\\n                    + abs(pixel[1] - last_pixel[1]) \\\n                    + abs(pixel[2] - last_pixel[2]) > 10:\n                board_x_sum += j\n                board_x_c += 1\n\n        if board_x_sum:\n            board_x = board_x_sum / board_x_c\n\n    # 按实际的角度来算，找到接近下一个 board 中心的坐标 这里的角度应该\n    # 是 30°,值应该是 tan 30°, math.sqrt(3) / 3\n    board_y = piece_y - abs(board_x - piece_x) * math.sqrt(3) / 3\n\n    if not all((board_x, board_y)):\n        return 0, 0, 0, 0\n\n    return piece_x, piece_y, board_x, board_y\n\n\ndef main():\n    while True:\n        pull_screenshot()\n        im = Image.open(\"./1.png\")\n\n        # 获取棋子和 board 的位置\n        piece_x, piece_y, board_x, board_y = find_piece_and_board(im)\n        ts = int(time.time())\n        print(ts, piece_x, piece_y, board_x, board_y)\n        if piece_x == 0:\n            return\n\n        set_button_position(im)\n        distance = math.sqrt(\n            (board_x - piece_x) ** 2 + (board_y - piece_y) ** 2)\n        jump(distance)\n\n        save_debug_creenshot(ts, im, piece_x, piece_y, board_x, board_y)\n        backup_screenshot(ts)\n        # 为了保证截图的时候应落稳了，多延迟一会儿，随机值防 ban\n        time.sleep(random.uniform(1, 1.1))\n\n\nif __name__ == '__main__':\n    main()\n"
        },
        {
          "name": "wechat_jump_auto_slim.py",
          "type": "blob",
          "size": 7.8828125,
          "content": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n__author__ = 'Erimus'\n'''\n这个是精简版本，只取x轴距离。\n可以适配任意屏幕。\n把磁盘读写截图改为内存读写。\n可以防止被ban(从抓包数据看没有返回Error)。\n'''\n\nimport os\nimport sys\nimport subprocess\nimport time\nimport random\nfrom PIL import Image, ImageDraw\nfrom io import BytesIO\n\n# ◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆\nVERSION = \"1.1.4\"\nscreenshot_way = 2\n\n\ndef check_screenshot():  # 检查获取截图的方式\n    global screenshot_way\n    if (screenshot_way < 0):\n        print('暂不支持当前设备')\n        sys.exit()\n    binary_screenshot = pull_screenshot()\n    try:\n        Image.open(BytesIO(binary_screenshot)).load()  # 直接使用内存IO\n        print('Capture Method: {}'.format(screenshot_way))\n    except Exception:\n        screenshot_way -= 1\n        check_screenshot()\n\n\ndef pull_screenshot():  # 获取截图\n    global screenshot_way\n    if screenshot_way in [1, 2]:\n        process = subprocess.Popen(\n            'adb shell screencap -p', shell=True, stdout=subprocess.PIPE)\n        screenshot = process.stdout.read()\n        if screenshot_way == 2:\n            binary_screenshot = screenshot.replace(b'\\r\\n', b'\\n')\n        else:\n            binary_screenshot = screenshot.replace(b'\\r\\r\\n', b'\\n')\n        return binary_screenshot\n    elif screenshot_way == 0:\n        os.system('adb shell screencap -p /sdcard/autojump.png')\n        os.system('adb pull /sdcard/autojump.png .')\n\n# ◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆\n\n\ndef find_piece_and_board(im):  # 寻找起点和终点坐标\n    w, h = im.size  # 图片宽高\n    im_pixel = im.load()\n\n    def find_piece(pixel):  # 棋子取色精确范围\n        return ((40 < pixel[0] < 65) and\n                (40 < pixel[1] < 65) and\n                (80 < pixel[2] < 105))\n\n    # 寻找棋子 ◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆\n\n    # 粗查棋子位置\n    piece_found, piece_fx, piece_fy = 0, 0, 0\n    scan_piece_unit = w // 40  # 间隔单位\n    ny = (h + w) // 2  # 寻找下限 从画面中央的正方形的下缘开始\n    while ny > (h - w) // 2 and not piece_found:\n        ny -= scan_piece_unit\n        for nx in range(0, w, scan_piece_unit):\n            pixel = im_pixel[nx, ny]\n            if find_piece(pixel):\n                piece_fx, piece_fy = nx, ny\n                piece_found = True\n                break\n    print('%-12s %s,%s' % ('piece_fuzzy:', piece_fx, piece_fy))\n    if not piece_fx:\n        return 0, 0  # 没找到棋子\n\n    # 精查棋子位置\n    piece_x, piece_x_set = 0, []  # 棋子x/棋子坐标集合\n    piece_width = w // 14  # 估算棋子宽度\n    piece_height = w // 5  # 估算棋子高度\n    for ny in range(piece_fy + scan_piece_unit, piece_fy - piece_height, -4):\n        for nx in range(max(piece_fx - piece_width, 0),\n                        min(piece_fx + piece_width, w)):\n            pixel = im_pixel[nx, ny]\n            # print(nx,ny,pixel)\n            if find_piece(pixel):\n                piece_x_set.append(nx)\n        if len(piece_x_set) > 10:\n            piece_x = sum(piece_x_set) / len(piece_x_set)\n            break\n    print('%-12s %s' % ('p_exact_x:', piece_x))\n\n    # 寻找落点 ◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆\n    board_x = 0\n    # 限制棋盘扫描的横坐标 避免音符bug\n    if piece_x < w / 2:\n        board_x_start, board_x_end = w // 2, w  # 起点和终点的中点是画面中心\n    else:\n        board_x_start, board_x_end = 0, w // 2\n\n    # 寻找落点顶点\n    board_x_set = []  # 目标坐标集合/改为list避免去重\n    for by in range((h - w) // 2, (h + w) // 2, 4):\n        bg_pixel = im_pixel[0, by]\n        for bx in range(board_x_start, board_x_end):\n            pixel = im_pixel[bx, by]\n            # 修掉脑袋比下一个小格子还高的情况 屏蔽小人左右的范围\n            if abs(bx - piece_x) < piece_width:\n                continue\n\n            # 修掉圆顶的时候一条线导致的小bug 这个颜色判断应该OK\n            if (abs(pixel[0] - bg_pixel[0]) +\n                    abs(pixel[1] - bg_pixel[1]) +\n                    abs(pixel[2] - bg_pixel[2]) > 10):\n                board_x_set.append(bx)\n\n        if len(board_x_set) > 10:\n            board_x = sum(board_x_set) / len(board_x_set)\n            print('%-12s %s' % ('target_x:', board_x))\n            break  # 找到了退出\n\n    return piece_x, board_x\n\n# ◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆\n\n\ndef set_button_position(im, gameover=0):  # 重设点击位置 再来一局位置\n    w, h = im.size\n    if h // 16 > w // 9 + 2:  # 长窄屏 2px容差 获取ui描绘的高度\n        uih = int(w / 9 * 16)\n    else:\n        uih = h\n    # uiw = int(uih / 16 * 9)\n\n    # 如果游戏结束 点击再来一局\n    left = int(w / 2)  # 按钮半宽约uiw//5\n    # 根据9:16实测按钮高度中心0.825 按钮半高约uiw//28\n    top = int((h - uih) / 2 + uih * 0.825)\n    if gameover:\n        return left, top\n\n    # 游戏中点击 随机位置防 ban\n    left = random.randint(w // 4, w - 20)  # 避开左下角按钮\n    top = random.randint(h * 3 // 4, h - 20)\n    return left, top\n\n# ◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆\n\n\ndef jump(piece_x, board_x, im, swipe_x1, swipe_y1):\n    distanceX = abs(board_x - piece_x)  # 起点到目标的水平距离\n    shortEdge = min(im.size)  # 屏幕宽度\n    jumpPercent = distanceX / shortEdge  # 跳跃百分比\n    jumpFullWidth = 1700  # 跳过整个宽度 需要按压的毫秒数\n    press_time = round(jumpFullWidth * jumpPercent)  # 按压时长\n    press_time = 0 if not press_time else max(\n        press_time, 200)  # press_time大于0时限定最小值\n    print('%-12s %.2f%% (%s/%s) | Press: %sms' %\n          ('Distance:', jumpPercent * 100, distanceX, shortEdge, press_time))\n\n    cmd = 'adb shell input swipe {x1} {y1} {x2} {y2} {duration}'.format(\n        x1=swipe_x1,\n        y1=swipe_y1,\n        x2=swipe_x1 + random.randint(-10, 10),  # 模拟位移\n        y2=swipe_y1 + random.randint(-10, 10),\n        duration=press_time\n    )\n    os.system(cmd)\n\n# ◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆\n\n\ndef main():\n    check_screenshot()  # 检查截图\n\n    count = 0\n    while True:\n        count += 1\n        print('---\\n%-12s %s (%s)' % ('Times:', count, int(time.time())))\n\n        # 获取截图\n        binary_screenshot = pull_screenshot()\n        im = Image.open(BytesIO(binary_screenshot))\n        w, h = im.size\n        if w > h:\n            im = im.rotate(-90, expand=True)  # 添加图片方向判断\n        # print('image | w:%s | h:%s'%(w,h))\n\n        # 获取棋子和 board 的位置\n        piece_x, board_x = find_piece_and_board(im)\n        gameover = 0 if all((piece_x, board_x)) else 1\n        swipe_x1, swipe_y1 = set_button_position(\n            im, gameover=gameover)  # 随机点击位置\n\n        # 标注截图并显示\n        # draw = ImageDraw.Draw(im)\n        # draw.line([piece_x, 0, piece_x, h], fill='blue', width=1)  # start\n        # draw.line([board_x, 0, board_x, h], fill='red', width=1)  # end\n        # draw.ellipse([swipe_x1 - 16, swipe_y1 - 16,\n        #               swipe_x1 + 16, swipe_y1 + 16], fill='red')  # click\n        # im.show()\n\n        jump(piece_x, board_x, im, swipe_x1, swipe_y1)\n\n        wait = (random.random())**5 * 9 + 1  # 停1~9秒 指数越高平均间隔越短\n        print('---\\nWait %.3f s...' % wait)\n        time.sleep(wait)\n        print('Continue!')\n\n# ◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆\n\n\nif __name__ == '__main__':\n    try:\n        main()\n    except KeyboardInterrupt:\n        os.system('adb kill-server')\n        print('bye')\n        exit(0)\n"
        },
        {
          "name": "wechat_jump_iOS_py3.py",
          "type": "blob",
          "size": 1.64453125,
          "content": "# -*- coding: utf-8 -*-\nimport time\nimport wda\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\nfrom PIL import Image\n\n# 截图距离 * time_coefficient = 按键时长\n# time_coefficient:\n#    iphonex: 0.00125\n#    iphone6: 0.00196\n#    iphone6s plus: 0.00120\ntime_coefficient = 0.00120\nVERSION = \"1.1.4\"\n\nc = wda.Client()\ns = c.session()\n\n\ndef pull_screenshot():\n    c.screenshot('autojump.png')\n\n\ndef jump(distance):\n    press_time = distance * time_coefficient\n    press_time = press_time\n    print('press_time = ',press_time)\n    s.tap_hold(200, 200, press_time)\n\n\nfig = plt.figure()\npull_screenshot()\nimg = np.array(Image.open('autojump.png'))\nim = plt.imshow(img, animated=True)\n\nupdate = True\nclick_count = 0\ncor = []\n\n\ndef update_data():\n    return np.array(Image.open('autojump.png'))\n\n\ndef updatefig(*args):\n    global update\n    if update:\n        time.sleep(1)\n        pull_screenshot()\n        im.set_array(update_data())\n        update = False\n    return im,\n\n\ndef on_click(event):\n    global update\n    global ix, iy\n    global click_count\n    global cor\n\n    ix, iy = event.xdata, event.ydata\n    coords = [(ix, iy)]\n    print('now = ', coords)\n    cor.append(coords)\n\n    click_count += 1\n    if click_count > 1:\n        click_count = 0\n        cor1 = cor.pop()\n        cor2 = cor.pop()\n\n        distance = (cor1[0][0] - cor2[0][0])**2 + (cor1[0][1] - cor2[0][1])**2\n        distance = distance ** 0.5\n        print('distance = ', distance)\n        jump(distance)\n        update = True\n\n\nfig.canvas.mpl_connect('button_press_event', on_click)\nani = animation.FuncAnimation(fig, updatefig, interval=50, blit=True)\nplt.show()\n"
        },
        {
          "name": "wechat_jump_py3.py",
          "type": "blob",
          "size": 1.5419921875,
          "content": "# -*- coding: utf-8 -*-\nimport os\nimport time\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\nfrom PIL import Image\n\nVERSION = \"1.1.4\"\ndef pull_screenshot():\n    os.system('adb shell screencap -p /sdcard/autojump.png')\n    os.system('adb pull /sdcard/autojump.png .')\n\n\ndef jump(distance):\n    press_time = distance * 1.35\n    press_time = int(press_time)\n    cmd = 'adb shell input swipe 320 410 320 410 ' + str(press_time)\n    print(cmd)\n    os.system(cmd)\n\n\nfig = plt.figure()\npull_screenshot()\nimg = np.array(Image.open('autojump.png'))\nim = plt.imshow(img, animated=True)\n\nupdate = True\nclick_count = 0\ncor = []\n\n\ndef update_data():\n    return np.array(Image.open('autojump.png'))\n\n\ndef updatefig(*args):\n    global update\n    if update:\n        time.sleep(1.5)\n        pull_screenshot()\n        im.set_array(update_data())\n        update = False\n    return im,\n\n\ndef on_click(event):\n    global update\n    global ix, iy\n    global click_count\n    global cor\n\n    ix, iy = event.xdata, event.ydata\n    coords = [(ix, iy)]\n    print('now = ', coords)\n    cor.append(coords)\n\n    click_count += 1\n    if click_count > 1:\n        click_count = 0\n        cor1 = cor.pop()\n        cor2 = cor.pop()\n\n        distance = (cor1[0][0] - cor2[0][0])**2 + (cor1[0][1] - cor2[0][1])**2\n        distance = distance ** 0.5\n        print('distance = ', distance)\n        jump(distance)\n        update = True\n\n\nfig.canvas.mpl_connect('button_press_event', on_click)\nani = animation.FuncAnimation(fig, updatefig, interval=50, blit=True)\nplt.show()\n"
        }
      ]
    }
  ]
}