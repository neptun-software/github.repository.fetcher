{
  "metadata": {
    "timestamp": 1736561269803,
    "page": 263,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjI3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "postmanlabs/httpbin",
      "stars": 12903,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".dockerignore",
          "type": "blob",
          "size": 0.015625,
          "content": "Dockerfile\n.git\n"
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.078125,
          "content": "env/\nbuild/\ndist/\n.eggs/\n.workon\n.epio-app\n*.pyc\n.tox\n*.egg-info\n*.swp\n.vscode/\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.3115234375,
          "content": "dist: trusty\nlanguage: python\n\nsudo: false\nmatrix:\n    include:\n        - python: 2.7\n          env: TOXENV=py27\n        - python: 3.6\n          env: TOXENV=py36\n        - python: 3.7\n          env: TOXENV=py37\n          dist: xenial\n          sudo: true\n\ninstall:\n    - travis_retry pip install tox\n\nscript:\n    - tox\n"
        },
        {
          "name": "AUTHORS",
          "type": "blob",
          "size": 0.619140625,
          "content": "HttpBin is written and maintained by Kenneth Reitz and\nvarious contributors:\n\nDevelopment Lead\n````````````````\n\n- Kenneth Reitz <_@kennethreitz.com>\n\n\nPatches and Suggestions\n```````````````````````\n\n- Zbigniew Siciarz\n- Andrey Petrov\n- Lispython\n- Kyle Conroy\n- Flavio Percoco\n- Radomir Stevanovic (http://github.com/randomir)\n- Steven Honson\n- Bob Carroll <bob.carroll@alum.rit.edu> @rcarz\n- Cory Benfield (Lukasa) <cory@lukasa.co.uk>\n- Matt Robenolt (https://github.com/mattrobenolt)\n- Dave Challis (https://github.com/davechallis)\n- Florian Bruhin (https://github.com/The-Compiler)\n- Brett Randall (https://github.com/javabrett)\n"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 0.5244140625,
          "content": "FROM ubuntu:18.04\n\nLABEL name=\"httpbin\"\nLABEL version=\"0.9.2\"\nLABEL description=\"A simple HTTP service.\"\nLABEL org.kennethreitz.vendor=\"Kenneth Reitz\"\n\nENV LC_ALL=C.UTF-8\nENV LANG=C.UTF-8\n\nRUN apt update -y && apt install python3-pip git -y && pip3 install --no-cache-dir pipenv\n\nADD Pipfile Pipfile.lock /httpbin/\nWORKDIR /httpbin\nRUN /bin/bash -c \"pip3 install --no-cache-dir -r <(pipenv lock -r)\"\n\nADD . /httpbin\nRUN pip3 install --no-cache-dir /httpbin\n\nEXPOSE 80\n\nCMD [\"gunicorn\", \"-b\", \"0.0.0.0:80\", \"httpbin:app\", \"-k\", \"gevent\"]\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 0.7275390625,
          "content": "ISC License\n\nCopyright (c) 2017 Kenneth Reitz.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted, provided that the above\ncopyright notice and this permission notice appear in all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\nWITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\nANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\nWHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\nACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\nOR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n"
        },
        {
          "name": "MANIFEST.in",
          "type": "blob",
          "size": 0.1357421875,
          "content": "include httpbin/VERSION README.md LICENSE AUTHORS test_httpbin.py\nrecursive-include httpbin/templates *\nrecursive-include httpbin/static *\n"
        },
        {
          "name": "Pipfile",
          "type": "blob",
          "size": 0.287109375,
          "content": "[[source]]\nurl = \"https://pypi.python.org/simple\"\nverify_ssl = true\n\n[packages]\ngunicorn = \"*\"\ndecorator = \"*\"\nbrotlipy = \"*\"\ngevent = \"*\"\nFlask = \"*\"\nmeinheld = \"*\"\nwerkzeug = \">=0.14.1\"\nsix = \"*\"\nflasgger = \"*\"\npyyaml = {git = \"https://github.com/yaml/pyyaml.git\"}\n\n[dev-packages]\nrope = \"*\"\n"
        },
        {
          "name": "Pipfile.lock",
          "type": "blob",
          "size": 13.7978515625,
          "content": "{\n    \"_meta\": {\n        \"hash\": {\n            \"sha256\": \"b709c9b498d9be5088c0f485aafe18a04a8ed5144d397111a8f1d8bd06d7a16e\"\n        },\n        \"pipfile-spec\": 6,\n        \"requires\": {},\n        \"sources\": [\n            {\n                \"url\": \"https://pypi.python.org/simple\",\n                \"verify_ssl\": true\n            }\n        ]\n    },\n    \"default\": {\n        \"brotlipy\": {\n            \"hashes\": [\n                \"sha256:07194f4768eb62a4f4ea76b6d0df6ade185e24ebd85877c351daa0a069f1111a\",\n                \"sha256:091b299bf36dd6ef7a06570dbc98c0f80a504a56c5b797f31934d2ad01ae7d17\",\n                \"sha256:09ec3e125d16749b31c74f021aba809541b3564e5359f8c265cbae442810b41a\",\n                \"sha256:0be698678a114addcf87a4b9496c552c68a2c99bf93cf8e08f5738b392e82057\",\n                \"sha256:0fa6088a9a87645d43d7e21e32b4a6bf8f7c3939015a50158c10972aa7f425b7\",\n                \"sha256:1ea4e578241504b58f2456a6c69952c88866c794648bdc74baee74839da61d44\",\n                \"sha256:2699945a0a992c04fc7dc7fa2f1d0575a2c8b4b769f2874a08e8eae46bef36ae\",\n                \"sha256:2a80319ae13ea8dd60ecdc4f5ccf6da3ae64787765923256b62c598c5bba4121\",\n                \"sha256:2e5c64522364a9ebcdf47c5744a5ddeb3f934742d31e61ebfbbc095460b47162\",\n                \"sha256:36def0b859beaf21910157b4c33eb3b06d8ce459c942102f16988cca6ea164df\",\n                \"sha256:3a3e56ced8b15fbbd363380344f70f3b438e0fd1fcf27b7526b6172ea950e867\",\n                \"sha256:3c1d5e2cf945a46975bdb11a19257fa057b67591eb232f393d260e7246d9e571\",\n                \"sha256:50ca336374131cfad20612f26cc43c637ac0bfd2be3361495e99270883b52962\",\n                \"sha256:5de6f7d010b7558f72f4b061a07395c5c3fd57f0285c5af7f126a677b976a868\",\n                \"sha256:637847560d671657f993313ecc6c6c6666a936b7a925779fd044065c7bc035b9\",\n                \"sha256:653faef61241bf8bf99d73ca7ec4baa63401ba7b2a2aa88958394869379d67c7\",\n                \"sha256:786afc8c9bd67de8d31f46e408a3386331e126829114e4db034f91eacb05396d\",\n                \"sha256:79aaf217072840f3e9a3b641cccc51f7fc23037496bd71e26211856b93f4b4cb\",\n                \"sha256:7e31f7adcc5851ca06134705fcf3478210da45d35ad75ec181e1ce9ce345bb38\",\n                \"sha256:8b39abc3256c978f575df5cd7893153277216474f303e26f0e43ba3d3969ef96\",\n                \"sha256:9448227b0df082e574c45c983fa5cd4bda7bfb11ea6b59def0940c1647be0c3c\",\n                \"sha256:96bc59ff9b5b5552843dc67999486a220e07a0522dddd3935da05dc194fa485c\",\n                \"sha256:a07647886e24e2fb2d68ca8bf3ada398eb56fd8eac46c733d4d95c64d17f743b\",\n                \"sha256:af65d2699cb9f13b26ec3ba09e75e80d31ff422c03675fcb36ee4dabe588fdc2\",\n                \"sha256:b4c98b0d2c9c7020a524ca5bbff42027db1004c6571f8bc7b747f2b843128e7a\",\n                \"sha256:c6cc0036b1304dd0073eec416cb2f6b9e37ac8296afd9e481cac3b1f07f9db25\",\n                \"sha256:d2c1c724c4ac375feb2110f1af98ecdc0e5a8ea79d068efb5891f621a5b235cb\",\n                \"sha256:dc6c5ee0df9732a44d08edab32f8a616b769cc5a4155a12d2d010d248eb3fb07\",\n                \"sha256:fd1d1c64214af5d90014d82cee5d8141b13d44c92ada7a0c0ec0679c6f15a471\"\n            ],\n            \"version\": \"==0.7.0\"\n        },\n        \"cffi\": {\n            \"hashes\": [\n                \"sha256:151b7eefd035c56b2b2e1eb9963c90c6302dc15fbd8c1c0a83a163ff2c7d7743\",\n                \"sha256:1553d1e99f035ace1c0544050622b7bc963374a00c467edafac50ad7bd276aef\",\n                \"sha256:1b0493c091a1898f1136e3f4f991a784437fac3673780ff9de3bcf46c80b6b50\",\n                \"sha256:2ba8a45822b7aee805ab49abfe7eec16b90587f7f26df20c71dd89e45a97076f\",\n                \"sha256:3bb6bd7266598f318063e584378b8e27c67de998a43362e8fce664c54ee52d30\",\n                \"sha256:3c85641778460581c42924384f5e68076d724ceac0f267d66c757f7535069c93\",\n                \"sha256:3eb6434197633b7748cea30bf0ba9f66727cdce45117a712b29a443943733257\",\n                \"sha256:495c5c2d43bf6cebe0178eb3e88f9c4aa48d8934aa6e3cddb865c058da76756b\",\n                \"sha256:4c91af6e967c2015729d3e69c2e51d92f9898c330d6a851bf8f121236f3defd3\",\n                \"sha256:57b2533356cb2d8fac1555815929f7f5f14d68ac77b085d2326b571310f34f6e\",\n                \"sha256:770f3782b31f50b68627e22f91cb182c48c47c02eb405fd689472aa7b7aa16dc\",\n                \"sha256:79f9b6f7c46ae1f8ded75f68cf8ad50e5729ed4d590c74840471fc2823457d04\",\n                \"sha256:7a33145e04d44ce95bcd71e522b478d282ad0eafaf34fe1ec5bbd73e662f22b6\",\n                \"sha256:857959354ae3a6fa3da6651b966d13b0a8bed6bbc87a0de7b38a549db1d2a359\",\n                \"sha256:87f37fe5130574ff76c17cab61e7d2538a16f843bb7bca8ebbc4b12de3078596\",\n                \"sha256:95d5251e4b5ca00061f9d9f3d6fe537247e145a8524ae9fd30a2f8fbce993b5b\",\n                \"sha256:9d1d3e63a4afdc29bd76ce6aa9d58c771cd1599fbba8cf5057e7860b203710dd\",\n                \"sha256:a36c5c154f9d42ec176e6e620cb0dd275744aa1d804786a71ac37dc3661a5e95\",\n                \"sha256:a6a5cb8809091ec9ac03edde9304b3ad82ad4466333432b16d78ef40e0cce0d5\",\n                \"sha256:ae5e35a2c189d397b91034642cb0eab0e346f776ec2eb44a49a459e6615d6e2e\",\n                \"sha256:b0f7d4a3df8f06cf49f9f121bead236e328074de6449866515cea4907bbc63d6\",\n                \"sha256:b75110fb114fa366b29a027d0c9be3709579602ae111ff61674d28c93606acca\",\n                \"sha256:ba5e697569f84b13640c9e193170e89c13c6244c24400fc57e88724ef610cd31\",\n                \"sha256:be2a9b390f77fd7676d80bc3cdc4f8edb940d8c198ed2d8c0be1319018c778e1\",\n                \"sha256:ca1bd81f40adc59011f58159e4aa6445fc585a32bb8ac9badf7a2c1aa23822f2\",\n                \"sha256:d5d8555d9bfc3f02385c1c37e9f998e2011f0db4f90e250e5bc0c0a85a813085\",\n                \"sha256:e55e22ac0a30023426564b1059b035973ec82186ddddbac867078435801c7801\",\n                \"sha256:e90f17980e6ab0f3c2f3730e56d1fe9bcba1891eeea58966e89d352492cc74f4\",\n                \"sha256:ecbb7b01409e9b782df5ded849c178a0aa7c906cf8c5a67368047daab282b184\",\n                \"sha256:ed01918d545a38998bfa5902c7c00e0fee90e957ce036a4000a88e3fe2264917\",\n                \"sha256:edabd457cd23a02965166026fd9bfd196f4324fe6032e866d0f3bd0301cd486f\",\n                \"sha256:fdf1c1dc5bafc32bc5d08b054f94d659422b05aba244d6be4ddc1c72d9aa70fb\"\n            ],\n            \"version\": \"==1.11.5\"\n        },\n        \"click\": {\n            \"hashes\": [\n                \"sha256:29f99fc6125fbc931b758dc053b3114e55c77a6e4c6c3a2674a2dc986016381d\",\n                \"sha256:f15516df478d5a56180fbf80e68f206010e6d160fc39fa508b65e035fd75130b\"\n            ],\n            \"version\": \"==6.7\"\n        },\n        \"decorator\": {\n            \"hashes\": [\n                \"sha256:2c51dff8ef3c447388fe5e4453d24a2bf128d3a4c32af3fabef1f01c6851ab82\",\n                \"sha256:c39efa13fbdeb4506c476c9b3babf6a718da943dab7811c206005a4a956c080c\"\n            ],\n            \"version\": \"==4.3.0\"\n        },\n        \"flasgger\": {\n            \"hashes\": [\n                \"sha256:1c9c03a4b55b60688f2bb2c2d8ff4534cb18eda70fd02973141be8c3bde586b3\",\n                \"sha256:efee892b0554c60f716b441ee78fddcaf7af20bc764696d9eecd6a389fb7f195\"\n            ],\n            \"version\": \"==0.9.0\"\n        },\n        \"flask\": {\n            \"hashes\": [\n                \"sha256:2271c0070dbcb5275fad4a82e29f23ab92682dc45f9dfbc22c02ba9b9322ce48\",\n                \"sha256:a080b744b7e345ccfcbc77954861cb05b3c63786e93f2b3875e0913d44b43f05\"\n            ],\n            \"version\": \"==1.0.2\"\n        },\n        \"gevent\": {\n            \"hashes\": [\n                \"sha256:00a45774ad6e7a8641af5db011807f53c1f0e0bc62cbdcab83e4db18e6201b6e\",\n                \"sha256:15dbcc07cdd09f87b9814ee26483ec49e0d71fdc65d7a61b21c2c56bbb550168\",\n                \"sha256:16143db7b760d9b512edfaf4d0bbef01cf0391e773362c43084901e3ecb892d5\",\n                \"sha256:1a0d422d6c960c36088201d4bbc925dfde87dc4a4e442bf2e4d36ae455f24a96\",\n                \"sha256:22187d0aba6506b57075dd05d0df495b04bfd4b047bbf776eeaac93117a6e9d2\",\n                \"sha256:33320f60be19a865396a7f5e10c15b14e338790ae807c97c90edc990d644dc1c\",\n                \"sha256:3498fec10e3695f3ad31253857c624435378c6a47969babb54a83ac0101615d3\",\n                \"sha256:3c9fbc0dac62e552dc5d03bb67ceaefc5f74d7b4ac04a4bf797cdb0a4438b1db\",\n                \"sha256:53c4dc705886d028f5d81e698b1d1479994a421498cd6529cb9711b5e2a84f74\",\n                \"sha256:57729118fbcf0f39ecf721ae9b318a4a738eb5d9b972af6c6c8c96303e30f011\",\n                \"sha256:6c41413e1eb0b7bf77dcea42ff276e62903bfdc62cb936d71458d338b9edc9a6\",\n                \"sha256:72f7cab120e2af89d3a9d6c526e49da5c0b6c94d47e23ab7a26ae8471ee97ffb\",\n                \"sha256:7ac5a4945fc47e3824d55bb50b6dd65823868e87fac841bea5762f79b9d22019\",\n                \"sha256:7bb0e1ef3adfea008688617fedb1741009856f98e26133983646203c718f7f39\",\n                \"sha256:8c41ef269bc743b5bb88a4553627cd4611be5c59589d5390e29956a8d3ab8623\",\n                \"sha256:a1f32f0b01ceb15f93b2914b7057acb008c5173181813424621dc444f73c00e2\",\n                \"sha256:a51456f842f7de83fff473a0230e313e44ac6fa83e492412e696924f417088b8\",\n                \"sha256:a72a23829ce8eb18086ec6f855715c3f52d3c1e12b83fd040d9fb854e77c0565\",\n                \"sha256:c7e5f8a6bf865ef507db27f85376808991d3189df185864a5ee326d97e144ec4\",\n                \"sha256:cf707886b9b45e56114c6f5522fc556058de5b5bf8674b609e82dfa2f9633c41\",\n                \"sha256:d83370528327364354cfb54c96ca401853599bd7a15f382e6962fd8318cede50\",\n                \"sha256:e9d64081e419eb8a268edaa90bba95fb4c78a6278d2105dcc080b24b42679535\"\n            ],\n            \"version\": \"==1.3.4\"\n        },\n        \"greenlet\": {\n            \"hashes\": [\n                \"sha256:09ef2636ea35782364c830f07127d6c7a70542b178268714a9a9ba16318e7e8b\",\n                \"sha256:0fef83d43bf87a5196c91e73cb9772f945a4caaff91242766c5916d1dd1381e4\",\n                \"sha256:1b7df09c6598f5cfb40f843ade14ed1eb40596e75cd79b6fa2efc750ba01bb01\",\n                \"sha256:1fff21a2da5f9e03ddc5bd99131a6b8edf3d7f9d6bc29ba21784323d17806ed7\",\n                \"sha256:42118bf608e0288e35304b449a2d87e2ba77d1e373e8aa221ccdea073de026fa\",\n                \"sha256:50643fd6d54fd919f9a0a577c5f7b71f5d21f0959ab48767bd4bb73ae0839500\",\n                \"sha256:58798b5d30054bb4f6cf0f712f08e6092df23a718b69000786634a265e8911a9\",\n                \"sha256:5b49b3049697aeae17ef7bf21267e69972d9e04917658b4e788986ea5cc518e8\",\n                \"sha256:75c413551a436b462d5929255b6dc9c0c3c2b25cbeaee5271a56c7fda8ca49c0\",\n                \"sha256:769b740aeebd584cd59232be84fdcaf6270b8adc356596cdea5b2152c82caaac\",\n                \"sha256:a1852b51b06d1367e2d70321f6801844f5122852c9e5169bdfdff3f4d81aae30\",\n                \"sha256:ad2383d39f13534f3ca5c48fe1fc0975676846dc39c2cece78c0f1f9891418e0\",\n                \"sha256:b417bb7ff680d43e7bd7a13e2e08956fa6acb11fd432f74c97b7664f8bdb6ec1\",\n                \"sha256:b6ef0cabaf5a6ecb5ac122e689d25ba12433a90c7b067b12e5f28bdb7fb78254\",\n                \"sha256:c2de19c88bdb0366c976cc125dca1002ec1b346989d59524178adfd395e62421\",\n                \"sha256:c7b04a6dc74087b1598de8d713198de4718fa30ec6cbb84959b26426c198e041\",\n                \"sha256:f8f2a0ae8de0b49c7b5b2daca4f150fdd9c1173e854df2cce3b04123244f9f45\",\n                \"sha256:fcfadaf4bf68a27e5dc2f42cbb2f4b4ceea9f05d1d0b8f7787e640bed2801634\"\n            ],\n            \"markers\": \"platform_python_implementation == 'CPython'\",\n            \"version\": \"==0.4.13\"\n        },\n        \"gunicorn\": {\n            \"hashes\": [\n                \"sha256:aa8e0b40b4157b36a5df5e599f45c9c76d6af43845ba3b3b0efe2c70473c2471\",\n                \"sha256:fa2662097c66f920f53f70621c6c58ca4a3c4d3434205e608e121b5b3b71f4f3\"\n            ],\n            \"version\": \"==19.9.0\"\n        },\n        \"itsdangerous\": {\n            \"hashes\": [\n                \"sha256:cbb3fcf8d3e33df861709ecaf89d9e6629cff0a217bc2848f1b41cd30d360519\"\n            ],\n            \"version\": \"==0.24\"\n        },\n        \"jinja2\": {\n            \"hashes\": [\n                \"sha256:74c935a1b8bb9a3947c50a54766a969d4846290e1e788ea44c1392163723c3bd\",\n                \"sha256:f84be1bb0040caca4cea721fcbbbbd61f9be9464ca236387158b0feea01914a4\"\n            ],\n            \"version\": \"==2.10\"\n        },\n        \"jsonschema\": {\n            \"hashes\": [\n                \"sha256:000e68abd33c972a5248544925a0cae7d1125f9bf6c58280d37546b946769a08\",\n                \"sha256:6ff5f3180870836cae40f06fa10419f557208175f13ad7bc26caa77beb1f6e02\"\n            ],\n            \"version\": \"==2.6.0\"\n        },\n        \"markupsafe\": {\n            \"hashes\": [\n                \"sha256:a6be69091dac236ea9c6bc7d012beab42010fa914c459791d627dad4910eb665\"\n            ],\n            \"version\": \"==1.0\"\n        },\n        \"meinheld\": {\n            \"hashes\": [\n                \"sha256:293eff4983b7fcbd9134b47706b22189883fe354993bd10163c65869d141e565\",\n                \"sha256:40d9dbce0165b2d9142f364d26fd6d59d3682f89d0dfe2117717a8ddad1f4133\"\n            ],\n            \"version\": \"==0.6.1\"\n        },\n        \"mistune\": {\n            \"hashes\": [\n                \"sha256:b4c512ce2fc99e5a62eb95a4aba4b73e5f90264115c40b70a21e1f7d4e0eac91\",\n                \"sha256:bc10c33bfdcaa4e749b779f62f60d6e12f8215c46a292d05e486b869ae306619\"\n            ],\n            \"version\": \"==0.8.3\"\n        },\n        \"pycparser\": {\n            \"hashes\": [\n                \"sha256:99a8ca03e29851d96616ad0404b4aad7d9ee16f25c9f9708a11faf2810f7b226\"\n            ],\n            \"version\": \"==2.18\"\n        },\n        \"pyyaml\": {\n            \"git\": \"https://github.com/yaml/pyyaml.git\",\n            \"ref\": \"a9c28e0b521967f5330f0316edd90a57f99cdd32\"\n        },\n        \"six\": {\n            \"hashes\": [\n                \"sha256:70e8a77beed4562e7f14fe23a786b54f6296e34344c23bc42f07b15018ff98e9\",\n                \"sha256:832dc0e10feb1aa2c68dcc57dbb658f1c7e65b9b61af69048abc87a2db00a0eb\"\n            ],\n            \"version\": \"==1.11.0\"\n        },\n        \"werkzeug\": {\n            \"hashes\": [\n                \"sha256:c3fd7a7d41976d9f44db327260e263132466836cef6f91512889ed60ad26557c\",\n                \"sha256:d5da73735293558eb1651ee2fddc4d0dedcfa06538b8813a2e20011583c9e49b\"\n            ],\n            \"version\": \"==0.14.1\"\n        }\n    },\n    \"develop\": {\n        \"rope\": {\n            \"hashes\": [\n                \"sha256:a09edfd2034fd50099a67822f9bd851fbd0f4e98d3b87519f6267b60e50d80d1\"\n            ],\n            \"version\": \"==0.10.7\"\n        }\n    }\n}\n"
        },
        {
          "name": "Procfile",
          "type": "blob",
          "size": 0.03515625,
          "content": "web: gunicorn httpbin:app -k gevent\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 0.65625,
          "content": "# httpbin(1): HTTP Request & Response Service\n\n\nA [Kenneth Reitz](http://kennethreitz.org/bitcoin) Project.\n\n![ice cream](http://farm1.staticflickr.com/572/32514669683_4daf2ab7bc_k_d.jpg)\n\nRun locally:\n```sh\ndocker pull kennethreitz/httpbin\ndocker run -p 80:80 kennethreitz/httpbin\n```\n\nSee http://httpbin.org for more information.\n\n## Officially Deployed at:\n\n- http://httpbin.org\n- https://httpbin.org\n- https://hub.docker.com/r/kennethreitz/httpbin/\n\n\n## SEE ALSO\n\n- http://requestb.in\n- http://python-requests.org\n- https://grpcb.in/\n\n## Build Status\n\n[![Build Status](https://travis-ci.org/requests/httpbin.svg?branch=master)](https://travis-ci.org/requests/httpbin)\n"
        },
        {
          "name": "app.json",
          "type": "blob",
          "size": 0.376953125,
          "content": "{\n  \"name\": \"httpbin\",\n  \"description\": \"HTTP Request & Response Service, written in Python + Flask.\",\n  \"repository\": \"https://github.com/requests/httpbin\",\n  \"website\": \"https://httpbin.org\",\n  \"logo\": \"https://s3.amazonaws.com/f.cl.ly/items/333Y191Z2C0G2J3m3Y0b/httpbin.svg\",\n  \"keywords\": [\"http\", \"rest\", \"API\", \"testing\", \"integration\", \"python\", \"flask\"],\n  \"addons\": \"sentry\"\n}\n"
        },
        {
          "name": "docker-compose.yml",
          "type": "blob",
          "size": 0.0810546875,
          "content": "version: '2'\nservices:\n    httpbin:\n      build: '.'\n      ports:\n        - '80:80'"
        },
        {
          "name": "httpbin",
          "type": "tree",
          "content": null
        },
        {
          "name": "now.json",
          "type": "blob",
          "size": 0.126953125,
          "content": "{\n    \"name\": \"httpbin\",\n    \"regions\": [\n        \"all\"\n    ],\n    \"alias\": [\n        \"httpbin.org\"\n    ],\n    \"type\": \"docker\"\n}\n"
        },
        {
          "name": "runtime.txt",
          "type": "blob",
          "size": 0.01171875,
          "content": "python-3.6.5"
        },
        {
          "name": "setup.cfg",
          "type": "blob",
          "size": 0.02734375,
          "content": "[bdist_wheel]\nuniversal = 1\n"
        },
        {
          "name": "setup.py",
          "type": "blob",
          "size": 1.255859375,
          "content": "from setuptools import setup, find_packages\nimport os\nimport io\n\n\nwith open(os.path.join(os.path.realpath(os.path.dirname(__file__)), 'httpbin', 'VERSION')) as version_file:\n    version = version_file.read().strip()\n\nsetup(\n    name=\"httpbin\",\n    version=version,\n    description=\"HTTP Request and Response Service\",\n    long_description=\"A simple HTTP Request & Response Service, written in Python + Flask.\",\n\n    # The project URL.\n    url='https://github.com/requests/httpbin',\n\n    # Author details\n    author='Kenneth Reitz',\n    author_email='me@kennethreitz.org',\n\n    # Choose your license\n    license='MIT',\n\n    classifiers=[\n         'Development Status :: 5 - Production/Stable',\n         'Intended Audience :: Developers',\n         'Natural Language :: English',\n         'License :: OSI Approved :: MIT License',\n         'Programming Language :: Python',\n         'Programming Language :: Python :: 2.7',\n         'Programming Language :: Python :: 3.6',\n    ],\n    test_suite=\"test_httpbin\",\n    packages=find_packages(),\n    include_package_data = True, # include files listed in MANIFEST.in\n    install_requires=[\n        'Flask', 'MarkupSafe', 'decorator', 'itsdangerous', 'six', 'brotlipy',\n        'raven[flask]', 'werkzeug>=0.14.1', 'gevent', 'flasgger'\n    ],\n)\n"
        },
        {
          "name": "test_httpbin.py",
          "type": "blob",
          "size": 31.4248046875,
          "content": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\nimport os\nimport base64\nimport unittest\nimport contextlib\nimport six\nimport json\nfrom werkzeug.http import parse_dict_header\nfrom hashlib import md5, sha256, sha512\nfrom six import BytesIO\n\nimport httpbin\nfrom httpbin.helpers import parse_multi_value_header\n\n\n@contextlib.contextmanager\ndef _setenv(key, value):\n    \"\"\"Context manager to set an environment variable temporarily.\"\"\"\n    old_value = os.environ.get(key, None)\n    if value is None:\n        os.environ.pop(key, None)\n    else:\n        os.environ[key] = value\n\n    yield\n\n    if old_value is None:\n        os.environ.pop(key, None)\n    else:\n        os.environ[key] = value\n\n\n\ndef _string_to_base64(string):\n    \"\"\"Encodes string to utf-8 and then base64\"\"\"\n    utf8_encoded = string.encode('utf-8')\n    return base64.urlsafe_b64encode(utf8_encoded)\n\ndef _hash(data, algorithm):\n    \"\"\"Encode binary data according to specified algorithm, use MD5 by default\"\"\"\n    if algorithm == 'SHA-256':\n        return sha256(data).hexdigest()\n    elif algorithm == 'SHA-512':\n        return sha512(data).hexdigest()\n    else:\n        return md5(data).hexdigest()\n\ndef _make_digest_auth_header(username, password, method, uri, nonce,\n                             realm=None, opaque=None, algorithm=None,\n                             qop=None, cnonce=None, nc=None, body=None):\n    \"\"\"Compile a digest authentication header string.\n\n    Arguments:\n    - `nonce`: nonce string, received within \"WWW-Authenticate\" header\n    - `realm`: realm string, received within \"WWW-Authenticate\" header\n    - `opaque`: opaque string, received within \"WWW-Authenticate\" header\n    - `algorithm`: type of hashing algorithm, used by the client\n    - `qop`: type of quality-of-protection, used by the client\n    - `cnonce`: client nonce, required if qop is \"auth\" or \"auth-int\"\n    - `nc`: client nonce count, required if qop is \"auth\" or \"auth-int\"\n    - `body`: body of the outgoing request (bytes), used if qop is \"auth-int\"\n    \"\"\"\n\n    assert username\n    assert password\n    assert nonce\n    assert method\n    assert uri\n    assert algorithm in ('MD5', 'SHA-256', 'SHA-512', None)\n\n    a1 = ':'.join([username, realm or '', password])\n    ha1 = _hash(a1.encode('utf-8'), algorithm)\n\n    a2 = ':'.join([method, uri])\n    if qop == 'auth-int':\n        a2 = ':'.join([a2, _hash(body or b'', algorithm)])\n    ha2 = _hash(a2.encode('utf-8'), algorithm)\n\n    a3 = ':'.join([ha1, nonce])\n    if qop in ('auth', 'auth-int'):\n        assert cnonce\n        assert nc\n        a3 = ':'.join([a3, nc, cnonce, qop])\n\n    a3 = ':'.join([a3, ha2])\n    auth_response = _hash(a3.encode('utf-8'), algorithm)\n\n    auth_header = \\\n        'Digest username=\"{0}\", response=\"{1}\", uri=\"{2}\", nonce=\"{3}\"'\\\n            .format(username, auth_response, uri, nonce)\n\n    # 'realm' and 'opaque' should be returned unchanged, even if empty\n    if realm != None:\n        auth_header += ', realm=\"{0}\"'.format(realm)\n    if opaque != None:\n        auth_header += ', opaque=\"{0}\"'.format(opaque)\n\n    if algorithm:\n        auth_header += ', algorithm=\"{0}\"'.format(algorithm)\n    if cnonce:\n        auth_header += ', cnonce=\"{0}\"'.format(cnonce)\n    if nc:\n        auth_header += ', nc={0}'.format(nc)\n    if qop:\n        auth_header += ', qop={0}'.format(qop)\n\n    return auth_header\n\nclass HttpbinTestCase(unittest.TestCase):\n    \"\"\"Httpbin tests\"\"\"\n\n    def setUp(self):\n        httpbin.app.debug = True\n        self.app = httpbin.app.test_client()\n\n    def test_index(self):   \n        response = self.app.get('/', headers={'User-Agent': 'test'})\n        self.assertEqual(response.status_code, 200)\n \n    def get_data(self, response):\n        if 'get_data' in dir(response):\n            return response.get_data()\n        else:\n            return response.data\n\n    def test_response_headers_simple(self):\n        supported_verbs = ['get', 'post']\n        for verb in supported_verbs:\n            method = getattr(self.app, verb)\n            response = method('/response-headers?animal=dog')\n            self.assertEqual(response.status_code, 200)\n            self.assertEqual(response.headers.get_all('animal'), ['dog'])\n            assert json.loads(response.data.decode('utf-8'))['animal'] == 'dog'\n\n    def test_response_headers_multi(self):\n        supported_verbs = ['get', 'post']\n        for verb in supported_verbs:\n            method = getattr(self.app, verb)\n            response = method('/response-headers?animal=dog&animal=cat')\n            self.assertEqual(response.status_code, 200)\n            self.assertEqual(response.headers.get_all('animal'), ['dog', 'cat'])\n            assert json.loads(response.data.decode('utf-8'))['animal'] == ['dog', 'cat']\n\n    def test_get(self):\n        response = self.app.get('/get', headers={'User-Agent': 'test'})\n        self.assertEqual(response.status_code, 200)\n        data = json.loads(response.data.decode('utf-8'))\n        self.assertEqual(data['args'], {})\n        self.assertEqual(data['headers']['Host'], 'localhost')\n        self.assertEqual(data['headers']['Content-Length'], '0')\n        self.assertEqual(data['headers']['User-Agent'], 'test')\n        # self.assertEqual(data['origin'], None)\n        self.assertEqual(data['url'], 'http://localhost/get')\n        self.assertTrue(response.data.endswith(b'\\n'))\n\n    def test_anything(self):\n        response = self.app.get('/anything')\n        self.assertEqual(response.status_code, 200)\n        response = self.app.get('/anything/foo/bar')\n        self.assertEqual(response.status_code, 200)\n        data = json.loads(response.data.decode('utf-8'))\n        self.assertEqual(data['args'], {})\n        self.assertEqual(data['headers']['Host'], 'localhost')\n        self.assertEqual(data['headers']['Content-Length'], '0')\n        self.assertEqual(data['url'], 'http://localhost/anything/foo/bar')\n        self.assertEqual(data['method'], 'GET')\n        self.assertTrue(response.data.endswith(b'\\n'))\n\n    def test_base64(self):\n        greeting = u'Здравствуй, мир!'\n        b64_encoded = _string_to_base64(greeting)\n        response = self.app.get(b'/base64/' + b64_encoded)\n        content = response.data.decode('utf-8')\n        self.assertEqual(greeting, content)\n\n    def test_post_binary(self):\n        response = self.app.post('/post',\n                                 data=b'\\x01\\x02\\x03\\x81\\x82\\x83',\n                                 content_type='application/octet-stream')\n        self.assertEqual(response.status_code, 200)\n\n    def test_post_body_text(self):\n        with open('httpbin/core.py') as f:\n            response = self.app.post('/post', data={\"file\": f.read()})\n        self.assertEqual(response.status_code, 200)\n\n    def test_post_body_binary(self):\n        response = self.app.post(\n            '/post',\n            data={\"file\": b'\\x01\\x02\\x03\\x81\\x82\\x83'})\n        self.assertEqual(response.status_code, 200)\n\n    def test_post_body_unicode(self):\n        response = self.app.post('/post', data=u'оживлённым'.encode('utf-8'))\n        self.assertEqual(json.loads(response.data.decode('utf-8'))['data'], u'оживлённым')\n\n    def test_post_file_with_missing_content_type_header(self):\n        # I built up the form data manually here because I couldn't find a way\n        # to convince the werkzeug test client to send files without the\n        # content-type of the file set.\n        data = '--bound\\r\\nContent-Disposition: form-data; name=\"media\"; '\n        data += 'filename=\"test.bin\"\\r\\n\\r\\n\\xa5\\xc6\\n--bound--\\r\\n'\n        response = self.app.post(\n            '/post',\n            content_type='multipart/form-data; boundary=bound',\n            data=data,\n        )\n        self.assertEqual(response.status_code, 200)\n\n    \"\"\"\n    This is currently a sort of negative-test.\n    We validate that when running Flask-only server that\n    Transfer-Encoding: chunked requests are unsupported and\n    we return 501 Not Implemented\n    \"\"\"\n    def test_post_chunked(self):\n        data = '{\"animal\":\"dog\"}'\n        response = self.app.post(\n            '/post',\n            content_type='application/json',\n            headers=[('Transfer-Encoding', 'chunked')],\n            data=data,\n        )\n        self.assertEqual(response.status_code, 501)\n        #self.assertEqual(response.status_code, 200)\n        #self.assertEqual(json.loads(response.data.decode('utf-8'))['data'], '{\"animal\":\"dog\"}')\n        #self.assertEqual(json.loads(response.data.decode('utf-8'))['json'], {\"animal\": \"dog\"})\n\n    def test_set_cors_headers_after_request(self):\n        response = self.app.get('/get')\n        self.assertEqual(\n            response.headers.get('Access-Control-Allow-Origin'), '*'\n        )\n\n    def test_set_cors_credentials_headers_after_auth_request(self):\n        response = self.app.get('/basic-auth/foo/bar')\n        self.assertEqual(\n            response.headers.get('Access-Control-Allow-Credentials'), 'true'\n        )\n\n    def test_set_cors_headers_after_request_with_request_origin(self):\n        response = self.app.get('/get', headers={'Origin': 'origin'})\n        self.assertEqual(\n            response.headers.get('Access-Control-Allow-Origin'), 'origin'\n        )\n\n    def test_set_cors_headers_with_options_verb(self):\n        response = self.app.open('/get', method='OPTIONS')\n        self.assertEqual(\n            response.headers.get('Access-Control-Allow-Origin'), '*'\n        )\n        self.assertEqual(\n            response.headers.get('Access-Control-Allow-Credentials'), 'true'\n        )\n        self.assertEqual(\n            response.headers.get('Access-Control-Allow-Methods'),\n            'GET, POST, PUT, DELETE, PATCH, OPTIONS'\n        )\n        self.assertEqual(\n            response.headers.get('Access-Control-Max-Age'), '3600'\n        )\n        # FIXME should we add any extra headers?\n        self.assertNotIn(\n            'Access-Control-Allow-Headers', response.headers\n        )\n    def test_set_cors_allow_headers(self):\n        response = self.app.open('/get', method='OPTIONS', headers={'Access-Control-Request-Headers': 'X-Test-Header'})\n        self.assertEqual(\n            response.headers.get('Access-Control-Allow-Headers'), 'X-Test-Header'\n        )\n\n    def test_headers(self):\n        headers = {\n            \"Accept\": \"*/*\",\n            \"Host\": \"localhost:1234\",\n            \"User-Agent\": \"curl/7.54.0\",\n            \"Via\": \"bar\"\n        }\n        response = self.app.get('/headers', headers=headers)\n        self.assertEqual(response.status_code, 200)\n        self.assertTrue({'Accept', 'Host', 'User-Agent'}.issubset(set(response.json['headers'].keys())))\n        self.assertNotIn('Via', response.json)\n\n    def test_headers_show_env(self):\n        headers = {\n            \"Accept\": \"*/*\",\n            \"Host\": \"localhost:1234\",\n            \"User-Agent\": \"curl/7.54.0\",\n            \"Via\": \"bar\"\n        }\n        response = self.app.get('/headers?show_env=true', headers=headers)\n        self.assertEqual(response.status_code, 200)\n        self.assertTrue({'Accept', 'Host', 'User-Agent', 'Via'}.issubset(set(response.json['headers'].keys())))\n\n    def test_user_agent(self):\n        response = self.app.get(\n            '/user-agent', headers={'User-Agent': 'test'}\n        )\n        self.assertIn('test', response.data.decode('utf-8'))\n        self.assertEqual(response.status_code, 200)\n\n    def test_gzip(self):\n        response = self.app.get('/gzip')\n        self.assertEqual(response.status_code, 200)\n\n    def test_brotli(self):\n        response = self.app.get('/brotli')\n        self.assertEqual(response.status_code, 200)\n\n    def test_bearer_auth(self):\n        token = 'abcd1234'\n        response = self.app.get(\n            '/bearer',\n            headers={'Authorization': 'Bearer ' + token}\n        )\n        self.assertEqual(response.status_code, 200)\n        assert json.loads(response.data.decode('utf-8'))['token'] == token\n\n    def test_bearer_auth_with_wrong_authorization_type(self):\n        \"\"\"Sending an non-Bearer Authorization header to /bearer should return a 401\"\"\"\n        auth_headers = (\n            ('Authorization', 'Basic 1234abcd'),\n            ('Authorization', ''),\n            ('',  '')\n        )\n        for header in auth_headers:\n            response = self.app.get(\n                '/bearer',\n                headers={header[0]: header[1]}\n            )\n            self.assertEqual(response.status_code, 401)\n\n    def test_bearer_auth_with_missing_token(self):\n        \"\"\"Sending an 'Authorization: Bearer' header with no token to /bearer should return a 401\"\"\"\n        response = self.app.get(\n            '/bearer',\n            headers={'Authorization': 'Bearer'}\n        )\n        self.assertEqual(response.status_code, 401)\n\n    def test_digest_auth_with_wrong_password(self):\n        auth_header = 'Digest username=\"user\",realm=\"wrong\",nonce=\"wrong\",uri=\"/digest-auth/user/passwd/MD5\",response=\"wrong\",opaque=\"wrong\"'\n        response = self.app.get(\n            '/digest-auth/auth/user/passwd/MD5',\n            environ_base={\n                # httpbin's digest auth implementation uses the remote addr to\n                # build the nonce\n                'REMOTE_ADDR': '127.0.0.1',\n            },\n            headers={\n                'Authorization': auth_header,\n            }\n        )\n        self.assertTrue('Digest' in response.headers.get('WWW-Authenticate'))\n        self.assertEqual(response.status_code, 401)\n\n    def test_digest_auth(self):\n        \"\"\"Test different combinations of digest auth parameters\"\"\"\n        username = 'user'\n        password = 'passwd'\n        for qop in None, 'auth', 'auth-int',:\n            for algorithm in None, 'MD5', 'SHA-256', 'SHA-512':\n                for body in None, b'', b'request payload':\n                    for stale_after in (None, 1, 4) if algorithm else (None,) :\n                        self._test_digest_auth(username, password, qop, algorithm, body, stale_after)\n\n    def test_digest_auth_with_wrong_authorization_type(self):\n        \"\"\"Sending an non-digest Authorization header to /digest-auth should return a 401\"\"\"\n        auth_headers = (\n            ('Authorization', 'Basic 1234abcd'),\n            ('Authorization', ''),\n            ('',  '')\n        )\n        for header in auth_headers:\n            response = self.app.get(\n                '/digest-auth/auth/myname/mysecret',\n                headers={header[0]: header[1]}\n            )\n            self.assertEqual(response.status_code, 401)\n\n    def _test_digest_auth(self, username, password, qop, algorithm=None, body=None, stale_after=None):\n        uri = self._digest_auth_create_uri(username, password, qop, algorithm, stale_after)\n\n        unauthorized_response = self._test_digest_auth_first_challenge(uri)\n\n        header = unauthorized_response.headers.get('WWW-Authenticate')\n\n        authorized_response, nonce = self._test_digest_response_for_auth_request(header, username, password, qop, uri, body)\n        self.assertEqual(authorized_response.status_code, 200)\n\n        if None == stale_after :\n            return\n\n        # test stale after scenerio\n        self._digest_auth_stale_after_check(header, username, password, uri, body, qop, stale_after)\n\n    def _test_digest_auth_first_challenge(self, uri):\n        unauthorized_response = self.app.get(\n            uri,\n            environ_base={\n                # digest auth uses the remote addr to build the nonce\n                'REMOTE_ADDR': '127.0.0.1',\n            }\n        )\n        # make sure it returns a 401\n        self.assertEqual(unauthorized_response.status_code, 401)\n        return unauthorized_response\n\n    def _digest_auth_create_uri(self, username, password, qop, algorithm, stale_after):\n        uri = '/digest-auth/{0}/{1}/{2}'.format(qop or 'wrong-qop', username, password)\n        if algorithm:\n            uri += '/' + algorithm\n        if stale_after:\n            uri += '/{0}'.format(stale_after)\n        return uri\n\n    def _digest_auth_stale_after_check(self, header, username, password, uri, body, qop, stale_after):\n        for nc in range(2, stale_after + 1):\n            authorized_response, nonce = self._test_digest_response_for_auth_request(header, username, password, qop, uri, \\\n                                                                              body, nc)\n            self.assertEqual(authorized_response.status_code, 200)\n        stale_response, nonce = self._test_digest_response_for_auth_request(header, username, password, qop, uri, \\\n                                                                     body, stale_after + 1)\n        self.assertEqual(stale_response.status_code, 401)\n        header = stale_response.headers.get('WWW-Authenticate')\n        self.assertIn('stale=TRUE', header)\n\n    def _test_digest_response_for_auth_request(self, header, username, password, qop, uri, body, nc=1, nonce=None):\n        auth_type, auth_info = header.split(None, 1)\n        self.assertEqual(auth_type, 'Digest')\n\n        d = parse_dict_header(auth_info)\n\n        nonce = nonce or d['nonce']\n        realm = d['realm']\n        opaque = d['opaque']\n        if qop :\n            self.assertIn(qop, [x.strip() for x in d['qop'].split(',')], 'Challenge should contains expected qop')\n        algorithm = d['algorithm']\n\n        cnonce, nc = (_hash(os.urandom(10), \"MD5\"), '{:08}'.format(nc)) if qop in ('auth', 'auth-int') else (None, None)\n\n        auth_header = _make_digest_auth_header(\n            username, password, 'GET', uri, nonce, realm, opaque, algorithm, qop, cnonce, nc, body)\n\n        # make second request\n        return self.app.get(\n            uri,\n            environ_base={\n                # httpbin's digest auth implementation uses the remote addr to\n                # build the nonce\n                'REMOTE_ADDR': '127.0.0.1',\n            },\n            headers={\n                'Authorization': auth_header,\n            },\n            data=body\n        ), nonce\n\n    def test_digest_auth_wrong_pass(self):\n        \"\"\"Test different combinations of digest auth parameters\"\"\"\n        username = 'user'\n        password = 'passwd'\n        for qop in None, 'auth', 'auth-int',:\n            for algorithm in None, 'MD5', 'SHA-256', 'SHA-512':\n                for body in None, b'', b'request payload':\n                    self._test_digest_auth_wrong_pass(username, password, qop, algorithm, body, 3)\n\n    def _test_digest_auth_wrong_pass(self, username, password, qop, algorithm=None, body=None, stale_after=None):\n        uri = self._digest_auth_create_uri(username, password, qop, algorithm, stale_after)\n        unauthorized_response = self._test_digest_auth_first_challenge(uri)\n\n        header = unauthorized_response.headers.get('WWW-Authenticate')\n\n        wrong_pass_response, nonce = self._test_digest_response_for_auth_request(header, username, \"wrongPassword\", qop, uri, body)\n        self.assertEqual(wrong_pass_response.status_code, 401)\n        header = wrong_pass_response.headers.get('WWW-Authenticate')\n        self.assertNotIn('stale=TRUE', header)\n\n        reused_nonce_response, nonce =  self._test_digest_response_for_auth_request(header, username, password, qop, uri, \\\n                                                                              body, nonce=nonce)\n        self.assertEqual(reused_nonce_response.status_code, 401)\n        header = reused_nonce_response.headers.get('WWW-Authenticate')\n        self.assertIn('stale=TRUE', header)\n\n    def test_drip(self):\n        response = self.app.get('/drip?numbytes=400&duration=2&delay=1')\n        self.assertEqual(response.content_length, 400)\n        self.assertEqual(len(self.get_data(response)), 400)\n        self.assertEqual(response.status_code, 200)\n\n    def test_drip_with_invalid_numbytes(self):\n        for bad_num in -1, 0:\n            uri = '/drip?numbytes={0}&duration=2&delay=1'.format(bad_num)\n            response = self.app.get(uri)\n            self.assertEqual(response.status_code, 400)\n\n    def test_drip_with_custom_code(self):\n        response = self.app.get('/drip?numbytes=400&duration=2&code=500')\n        self.assertEqual(response.content_length, 400)\n        self.assertEqual(len(self.get_data(response)), 400)\n        self.assertEqual(response.status_code, 500)\n\n    def test_get_bytes(self):\n        response = self.app.get('/bytes/1024')\n        self.assertEqual(len(self.get_data(response)), 1024)\n        self.assertEqual(response.status_code, 200)\n\n    def test_bytes_with_seed(self):\n        response = self.app.get('/bytes/10?seed=0')\n        # The RNG changed in python3, so even though we are\n        # setting the seed, we can't expect the value to be the\n        # same across both interpreters.\n        if six.PY3:\n            self.assertEqual(\n                response.data, b'\\xc5\\xd7\\x14\\x84\\xf8\\xcf\\x9b\\xf4\\xb7o'\n            )\n        else:\n            self.assertEqual(\n                response.data, b'\\xd8\\xc2kB\\x82g\\xc8Mz\\x95'\n            )\n\n    def test_stream_bytes(self):\n        response = self.app.get('/stream-bytes/1024')\n        self.assertEqual(len(self.get_data(response)), 1024)\n        self.assertEqual(response.status_code, 200)\n\n    def test_stream_bytes_with_seed(self):\n        response = self.app.get('/stream-bytes/10?seed=0')\n        # The RNG changed in python3, so even though we are\n        # setting the seed, we can't expect the value to be the\n        # same across both interpreters.\n        if six.PY3:\n            self.assertEqual(\n                response.data, b'\\xc5\\xd7\\x14\\x84\\xf8\\xcf\\x9b\\xf4\\xb7o'\n            )\n        else:\n            self.assertEqual(\n                response.data, b'\\xd8\\xc2kB\\x82g\\xc8Mz\\x95'\n            )\n\n    def test_delete_endpoint_returns_body(self):\n        response = self.app.delete(\n            '/delete',\n            data={'name': 'kevin'},\n            content_type='application/x-www-form-urlencoded'\n        )\n        form_data = json.loads(response.data.decode('utf-8'))['form']\n        self.assertEqual(form_data, {'name': 'kevin'})\n\n    def test_methods__to_status_endpoint(self):\n        methods = [\n            'GET',\n            'HEAD',\n            'POST',\n            'PUT',\n            'DELETE',\n            'PATCH',\n            'TRACE',\n        ]\n        for m in methods:\n            response = self.app.open(path='/status/418', method=m)\n            self.assertEqual(response.status_code, 418)\n\n    def test_status_endpoint_invalid_code(self):\n        response = self.app.get(path='/status/4!9')\n        self.assertEqual(response.status_code, 400)\n\n    def test_status_endpoint_invalid_codes(self):\n        response = self.app.get(path='/status/200,402,foo')\n        self.assertEqual(response.status_code, 400)\n\n    def test_xml_endpoint(self):\n        response = self.app.get(path='/xml')\n        self.assertEqual(\n            response.headers.get('Content-Type'), 'application/xml'\n        )\n\n    def test_x_forwarded_proto(self):\n        response = self.app.get(path='/get', headers={\n            'X-Forwarded-Proto':'https'\n        })\n        assert json.loads(response.data.decode('utf-8'))['url'].startswith('https://')\n\n    def test_redirect_n_higher_than_1(self):\n        response = self.app.get('/redirect/5')\n        self.assertEqual(\n            response.headers.get('Location'), '/relative-redirect/4'\n        )\n\n    def test_redirect_to_post(self):\n        response = self.app.post('/redirect-to?url=/post&status_code=307',\n                                 data=b'\\x01\\x02\\x03\\x81\\x82\\x83',\n                                 content_type='application/octet-stream')\n        self.assertEqual(response.status_code, 307)\n        self.assertEqual(\n            response.headers.get('Location'), '/post'\n        )\n\n    def test_redirect_absolute_param_n_higher_than_1(self):\n        response = self.app.get('/redirect/5?absolute=true')\n        self.assertEqual(\n            response.headers.get('Location'), 'http://localhost/absolute-redirect/4'\n        )\n\n    def test_redirect_n_equals_to_1(self):\n        response = self.app.get('/redirect/1')\n        self.assertEqual(response.status_code, 302)\n        self.assertEqual(\n            response.headers.get('Location'), '/get'\n        )\n\n    def test_relative_redirect_n_equals_to_1(self):\n        response = self.app.get('/relative-redirect/1')\n        self.assertEqual(\n            response.headers.get('Location'), '/get'\n        )\n\n    def test_relative_redirect_n_higher_than_1(self):\n        response = self.app.get('/relative-redirect/7')\n        self.assertEqual(response.status_code, 302)\n        self.assertEqual(\n            response.headers.get('Location'), '/relative-redirect/6'\n        )\n\n    def test_absolute_redirect_n_higher_than_1(self):\n        response = self.app.get('/absolute-redirect/5')\n        self.assertEqual(\n            response.headers.get('Location'), 'http://localhost/absolute-redirect/4'\n        )\n\n    def test_absolute_redirect_n_equals_to_1(self):\n        response = self.app.get('/absolute-redirect/1')\n        self.assertEqual(response.status_code, 302)\n        self.assertEqual(\n            response.headers.get('Location'), 'http://localhost/get'\n        )\n\n    def test_request_range(self):\n        response1 = self.app.get('/range/1234')\n        self.assertEqual(response1.status_code, 200)\n        self.assertEqual(response1.headers.get('ETag'), 'range1234')\n        self.assertEqual(response1.headers.get('Content-range'), 'bytes 0-1233/1234')\n        self.assertEqual(response1.headers.get('Accept-ranges'), 'bytes')\n        self.assertEqual(len(self.get_data(response1)), 1234)\n\n        response2 = self.app.get('/range/1234')\n        self.assertEqual(response2.status_code, 200)\n        self.assertEqual(response2.headers.get('ETag'), 'range1234')\n        self.assertEqual(self.get_data(response1), self.get_data(response2))\n\n    def test_request_range_with_parameters(self):\n        response = self.app.get(\n            '/range/100?duration=1.5&chunk_size=5',\n            headers={ 'Range': 'bytes=10-24' }\n        )\n\n        self.assertEqual(response.status_code, 206)\n        self.assertEqual(response.headers.get('ETag'), 'range100')\n        self.assertEqual(response.headers.get('Content-range'), 'bytes 10-24/100')\n        self.assertEqual(response.headers.get('Accept-ranges'), 'bytes')\n        self.assertEqual(response.headers.get('Content-Length'), '15')\n        self.assertEqual(self.get_data(response), 'klmnopqrstuvwxy'.encode('utf8'))\n\n    def test_request_range_first_15_bytes(self):\n        response = self.app.get(\n            '/range/1000',\n            headers={ 'Range': 'bytes=0-15' }\n        )\n\n        self.assertEqual(response.status_code, 206)\n        self.assertEqual(response.headers.get('ETag'), 'range1000')\n        self.assertEqual(self.get_data(response), 'abcdefghijklmnop'.encode('utf8'))\n        self.assertEqual(response.headers.get('Content-range'), 'bytes 0-15/1000')\n\n    def test_request_range_open_ended_last_6_bytes(self):\n        response = self.app.get(\n            '/range/26',\n            headers={ 'Range': 'bytes=20-' }\n        )\n\n        self.assertEqual(response.status_code, 206)\n        self.assertEqual(response.headers.get('ETag'), 'range26')\n        self.assertEqual(self.get_data(response), 'uvwxyz'.encode('utf8'))\n        self.assertEqual(response.headers.get('Content-range'), 'bytes 20-25/26')\n        self.assertEqual(response.headers.get('Content-Length'), '6')\n\n    def test_request_range_suffix(self):\n        response = self.app.get(\n            '/range/26',\n            headers={ 'Range': 'bytes=-5' }\n        )\n\n        self.assertEqual(response.status_code, 206)\n        self.assertEqual(response.headers.get('ETag'), 'range26')\n        self.assertEqual(self.get_data(response), 'vwxyz'.encode('utf8'))\n        self.assertEqual(response.headers.get('Content-range'), 'bytes 21-25/26')\n        self.assertEqual(response.headers.get('Content-Length'), '5')\n\n    def test_request_out_of_bounds(self):\n        response = self.app.get(\n            '/range/26',\n            headers={ 'Range': 'bytes=10-5',\n            }\n        )\n\n        self.assertEqual(response.status_code, 416)\n        self.assertEqual(response.headers.get('ETag'), 'range26')\n        self.assertEqual(len(self.get_data(response)), 0)\n        self.assertEqual(response.headers.get('Content-range'), 'bytes */26')\n        self.assertEqual(response.headers.get('Content-Length'), '0')\n\n        response = self.app.get(\n            '/range/26',\n            headers={ 'Range': 'bytes=32-40',\n            }\n        )\n\n        self.assertEqual(response.status_code, 416)\n        response = self.app.get(\n            '/range/26',\n            headers={ 'Range': 'bytes=0-40',\n            }\n        )\n        self.assertEqual(response.status_code, 416)\n\n    def test_etag_if_none_match_matches(self):\n        response = self.app.get(\n            '/etag/abc',\n            headers={ 'If-None-Match': 'abc' }\n        )\n        self.assertEqual(response.status_code, 304)\n        self.assertEqual(response.headers.get('ETag'), 'abc')\n\n    def test_etag_if_none_match_matches_list(self):\n        response = self.app.get(\n            '/etag/abc',\n            headers={ 'If-None-Match': '\"123\", \"abc\"' }\n        )\n        self.assertEqual(response.status_code, 304)\n        self.assertEqual(response.headers.get('ETag'), 'abc')\n\n    def test_etag_if_none_match_matches_star(self):\n        response = self.app.get(\n            '/etag/abc',\n            headers={ 'If-None-Match': '*' }\n        )\n        self.assertEqual(response.status_code, 304)\n        self.assertEqual(response.headers.get('ETag'), 'abc')\n\n    def test_etag_if_none_match_w_prefix(self):\n        response = self.app.get(\n            '/etag/c3piozzzz',\n            headers={ 'If-None-Match': 'W/\"xyzzy\", W/\"r2d2xxxx\", W/\"c3piozzzz\"' }\n        )\n        self.assertEqual(response.status_code, 304)\n        self.assertEqual(response.headers.get('ETag'), 'c3piozzzz')\n\n    def test_etag_if_none_match_has_no_match(self):\n        response = self.app.get(\n            '/etag/abc',\n            headers={ 'If-None-Match': '123' }\n        )\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(response.headers.get('ETag'), 'abc')\n\n    def test_etag_if_match_matches(self):\n        response = self.app.get(\n            '/etag/abc',\n            headers={ 'If-Match': 'abc' }\n        )\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(response.headers.get('ETag'), 'abc')\n\n    def test_etag_if_match_matches_list(self):\n        response = self.app.get(\n            '/etag/abc',\n            headers={ 'If-Match': '\"123\", \"abc\"' }\n        )\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(response.headers.get('ETag'), 'abc')\n\n    def test_etag_if_match_matches_star(self):\n        response = self.app.get(\n            '/etag/abc',\n            headers={ 'If-Match': '*' }\n        )\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(response.headers.get('ETag'), 'abc')\n\n    def test_etag_if_match_has_no_match(self):\n        response = self.app.get(\n            '/etag/abc',\n            headers={ 'If-Match': '123' }\n        )\n        self.assertEqual(response.status_code, 412)\n        self.assertNotIn('ETag', response.headers)\n\n    def test_etag_with_no_headers(self):\n        response = self.app.get(\n            '/etag/abc'\n        )\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(response.headers.get('ETag'), 'abc')\n\n    def test_parse_multi_value_header(self):\n        self.assertEqual(parse_multi_value_header('xyzzy'), [ \"xyzzy\" ])\n        self.assertEqual(parse_multi_value_header('\"xyzzy\"'), [ \"xyzzy\" ])\n        self.assertEqual(parse_multi_value_header('W/\"xyzzy\"'), [ \"xyzzy\" ])\n        self.assertEqual(parse_multi_value_header('\"xyzzy\", \"r2d2xxxx\", \"c3piozzzz\"'), [ \"xyzzy\", \"r2d2xxxx\", \"c3piozzzz\" ])\n        self.assertEqual(parse_multi_value_header('W/\"xyzzy\", W/\"r2d2xxxx\", W/\"c3piozzzz\"'), [ \"xyzzy\", \"r2d2xxxx\", \"c3piozzzz\" ])\n        self.assertEqual(parse_multi_value_header('*'), [ \"*\" ])\n\nif __name__ == '__main__':\n    unittest.main()\n"
        },
        {
          "name": "tox.ini",
          "type": "blob",
          "size": 0.2451171875,
          "content": "[tox]\nenvlist = py27,py36,py37\n\n[testenv]\ncommands=python test_httpbin.py\n\n[testenv:release]\nskipdist = true\nusedevelop = false\ndeps =\n    twine>=1.6.0\n    wheel\ncommands =\n    python setup.py sdist bdist_wheel\n    twine upload --skip-existing dist/*\n"
        }
      ]
    }
  ]
}