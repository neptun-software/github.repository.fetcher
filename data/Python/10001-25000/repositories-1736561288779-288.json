{
  "metadata": {
    "timestamp": 1736561288779,
    "page": 288,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjI5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "Nuitka/Nuitka",
      "stars": 12351,
      "defaultBranch": "develop",
      "files": [
        {
          "name": ".devcontainer",
          "type": "tree",
          "content": null
        },
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.1767578125,
          "content": "root = true\n\n[*.{py,c,cpp,h,rst,md,yml}]\ntrim_trailing_whitespace = true\ninsert_final_newline = true\nindent_style = space\n\n[*.{py,c,cpp,h}]\nindent_size = 4\n\n[*.yml]\nindent_size = 2\n"
        },
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.0078125,
          "content": "* -text\n"
        },
        {
          "name": ".githooks",
          "type": "tree",
          "content": null
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.9228515625,
          "content": "*~\n*.DS_Store\n*.e4t\n*.e4q\n*.e4s\n*.pyc\n__pycache__/\n*.pyo\n*.swp\n*.swo\n*.o\n*.os\n*.so\n*.pyd\n*.pyi\n*.exe\n*.exe.away\n*.cmd\n*.bin\n*.build\n*.onefile-build\n*.dist\n*.app\n*.key\n*.xml\n*.optimization.log\n*.inclusion.log\n*.strace\n*.dtruss\n*.nuitka-pgo\n.mypy_cache\n*.egg-info\ntests/reflected/nuitka/\ntests/reflected/tests/\ntests/reflected/nuitka.py\ntests/reflected/nuitka-runner.py\ntests/basics/BigConstants.py\ntests/generated/*.py\n!tests/generated/run_all.py\ntests/PyPI-pytest/venv_*\n*.dblite\n*.pdb\nreleases/\nhtml\nman/\nhtmlcov/\nMini.py\npython??.dll\npython??_d.dll\nbuild\n!nuitka/build\ndist\nMANIFEST\nREADME.pdf\nREADME.html\nDeveloper_Manual.pdf\nDeveloper_Manual.html\nChangelog.pdf\nChangelog.html\ndoc/man-*.html\ndoxygen-warnings.log\nvenv_cpython/\nvenv_nuitka/\n.pytest_cache\ndoxygen_*\ndoxygen-*\n.coverage*\n*.tmp\n*.dat\n.vscode/ipch\n.vscode/tags\n.vscode/.ropeproject\nNuitka-*\nnuitka/tools/podman/containers/requirements-devel.txt\nnuitka/build/inline_copy/downloads\n"
        },
        {
          "name": ".gitmodules",
          "type": "blob",
          "size": 1.658203125,
          "content": "[submodule \"tests/CPython26\"]\n    path = tests/CPython26\n    url = https://github.com/Nuitka/Nuitka-CPython-tests.git\n    branch = CPython26\n[submodule \"tests/CPython27\"]\n    path = tests/CPython27\n    url = https://github.com/Nuitka/Nuitka-CPython-tests.git\n    branch = CPython27\n[submodule \"tests/CPython32\"]\n    path = tests/CPython32\n    url = https://github.com/Nuitka/Nuitka-CPython-tests.git\n    branch = CPython32\n[submodule \"tests/CPython33\"]\n    path = tests/CPython33\n    url = https://github.com/Nuitka/Nuitka-CPython-tests.git\n    branch = CPython33\n[submodule \"tests/CPython34\"]\n    path = tests/CPython34\n    url = https://github.com/Nuitka/Nuitka-CPython-tests.git\n    branch = CPython34\n[submodule \"tests/CPython35\"]\n    path = tests/CPython35\n    url = https://github.com/Nuitka/Nuitka-CPython-tests.git\n    branch = CPython35\n[submodule \"tests/CPython36\"]\n    path = tests/CPython36\n    url = https://github.com/Nuitka/Nuitka-CPython-tests.git\n    branch = CPython36\n[submodule \"tests/CPython37\"]\n    path = tests/CPython37\n    url = https://github.com/Nuitka/Nuitka-CPython-tests.git\n    branch = CPython37\n[submodule \"tests/CPython38\"]\n    path = tests/CPython38\n    url = https://github.com/Nuitka/Nuitka-CPython-tests.git\n    branch = CPython38\n[submodule \"tests/CPython39\"]\n    path = tests/CPython39\n    url = https://github.com/Nuitka/Nuitka-CPython-tests.git\n    branch = CPython39\n[submodule \"tests/CPython310\"]\n    path = tests/CPython310\n    url = https://github.com/Nuitka/Nuitka-CPython-tests.git\n    branch = CPython310\n[submodule \"tests/CPython311\"]\n    path = tests/CPython311\n    url = https://github.com/Nuitka/Nuitka-CPython-tests.git\n    branch = CPython311\n"
        },
        {
          "name": ".sourcery.yaml",
          "type": "blob",
          "size": 0.8759765625,
          "content": "#     Copyright 2024, Kay Hayen, mailto:kay.hayen@gmail.com find license text at end of file\n\nignore:\n  - \"tests\"\n  - \"nuitka/build/inline_copy\"\n\nrefactor:\n  python_version: '2.6'\n\n#     Part of \"Nuitka\", an optimizing Python compiler that is compatible and\n#     integrates with CPython, but also works on its own.\n#\n#     Licensed under the Apache License, Version 2.0 (the \"License\");\n#     you may not use this file except in compliance with the License.\n#     You may obtain a copy of the License at\n#\n#        http://www.apache.org/licenses/LICENSE-2.0\n#\n#     Unless required by applicable law or agreed to in writing, software\n#     distributed under the License is distributed on an \"AS IS\" BASIS,\n#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#     See the License for the specific language governing permissions and\n#     limitations under the License.\n"
        },
        {
          "name": ".vscode",
          "type": "tree",
          "content": null
        },
        {
          "name": "CODE_OF_CONDUCT.rst",
          "type": "blob",
          "size": 3.3603515625,
          "content": "######################################\n Contributor Covenant Code of Conduct\n######################################\n\n************\n Our Pledge\n************\n\nIn the interest of fostering an open and welcoming environment, we as\ncontributors and maintainers pledge to making participation in our\nproject and our community a harassment-free experience for everyone,\nregardless of age, body size, disability, ethnicity, sex\ncharacteristics, gender identity and expression, level of experience,\neducation, socio-economic status, nationality, personal appearance,\nrace, religion, or sexual identity and orientation.\n\n***************\n Our Standards\n***************\n\nExamples of behavior that contributes to creating a positive environment\ninclude:\n\n-  Using welcoming and inclusive language\n\n-  Being respectful of differing viewpoints and experiences\n\n-  Gracefully accepting constructive criticism\n\n-  Focusing on what is best for the community\n\n-  Showing empathy towards other community members\n\nExamples of unacceptable behavior by participants include:\n\n-  The use of sexualized language or imagery and unwelcome sexual\n   attention or advances\n\n-  Trolling, insulting/derogatory comments, and personal or political\n   attacks\n\n-  Public or private harassment\n\n-  Publishing other's private information, such as a physical or\n   electronic address, without explicit permission\n\n-  Other conduct which could reasonably be considered inappropriate in a\n   professional setting\n\n**********************\n Our Responsibilities\n**********************\n\nMaintainers are responsible for clarifying the standards of acceptable\nbehavior and are expected to take appropriate and fair corrective action\nin response to any instances of unacceptable behavior.\n\nMaintainers have the right and responsibility to remove, edit, or reject\ncomments, commits, code, wiki edits, issues, and other contributions\nthat are not aligned to this Code of Conduct, or to ban temporarily or\npermanently any contributor for other behaviors that they deem\ninappropriate, threatening, offensive, or harmful.\n\n*******\n Scope\n*******\n\nThis Code of Conduct applies both within project spaces and in public\nspaces when an individual is representing the project or its community.\nExamples of representing a project or community include using an\nofficial project e-mail address, posting via an official social media\naccount, or acting as an appointed representative at an online or\noffline event. Representation of a project may be further defined and\nclarified by project maintainers.\n\n*************\n Enforcement\n*************\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may\nbe reported by contacting the Nuitka Organisation admins via email to\n\"kay@nuitka.net\". Use \"COD complaint:\" in your email subject. All\ncomplaints will be reviewed and investigated and will result in a\nresponse that is deemed necessary and appropriate to the circumstances.\nThe Code of Conduct Committee is obligated to maintain confidentiality\nwith regard to the reporter of an incident. Further details of specific\nenforcement policies may be posted separately.\n\n*************\n Attribution\n*************\n\nThis Code of Conduct is adapted from the Contributor Covenant, version\n1.4, available at\nhttps://www.contributor-covenant.org/version/1/4/code-of-conduct.html\nand the Linux kernel team changes as available under\nhttps://docs.kernel.org/_sources/process/code-of-conduct.rst.txt\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 2.69921875,
          "content": "# Contributing to Nuitka\n\n## First things\n\nWelcome on board. Nuitka is an ambitious project. We are friendly. Join it now.\n\nThis document aims to give an overview of how to contribute to Nuitka. It tries\nto answer commonly asked questions regarding that, and to provide some insight on how to do it properly.\n\n- If you plan on submitting an issue\n\n  Please follow this [template](https://github.com/Nuitka/Nuitka/blob/develop/.github/ISSUE_TEMPLATE.md).\n\n- If you want to open a pull request\n\n  Make sure to read the information on further down this page but also have a\n  look at our [pull request\n  template](https://github.com/Nuitka/Nuitka/blob/develop/.github/PULL_REQUEST_TEMPLATE.md).\n\n## Getting Started\n\n- Read the [Nuitka User Manual](https://nuitka.net/doc/user-manual.html)\n- Read the [Nuitka Developer Manual](https://nuitka.net/doc/developer-manual.html)\n- Checkout the [git repo of Nuitka](https://github.com/Nuitka/Nuitka) additional docs and sources\n- Join the [Discord Server](https://discord.gg/nZ9hr9tUck)\n\n## Submitting a Pull Request\n\nPull requests are great. Here's a quick guide:\n\n1. Fork the repo on github.\n\n2. Install the `pre-commit` git hook\n\n   That is going to automatically format your code as described in the\n   Developer Manual. For that you have to execute this:\n\n   python misc/install-git-hooks.py\n\n3. Make a new branch and base your new branch on `develop`.\n\n4. Ideally add a test specific for your change to demonstrate it.\n\n   Due to Nuitka testing being basically to compile the whole world, it's ok to\n   not have one. But obviously if you fix something, it wasn't observed by that,\n   it would be good to provide a reproducer.\n\n5. Make the tests pass.\n\n6. Push to your fork and submit a pull request against `nuitka:develop`\n\n7. Wait for review\n\n   Suggestions for improvements or alternative ideas may happen. Keep in mind that\n   PR checklist items can be met after the pull request has been opened by adding\n   more commits to the branch. Indicate work in progress with a `WIP:` prefix in your PR title.\n\nAll the submitted pieces including potential data must be compatible with the\nApache License 2, which already says that once you are sending modified source,\ne.g. via pull request, you automatically license it as that too.\n\n## Submitting a Question\n\nIf you want to ask a question about a specific Nuitka aspect, please be kind\nand first of all..\n\n- Search for existing issues\n\n  Consider [GitHub issues tagged as \"question\"](https://github.com/Nuitka/Nuitka/issues?q=label%3Aquestion)\n\n- If not asked yet, ask it there.\n\n## Submitting Issues\n\nThe issue template contains the guidance on how to properly support issues. If you ignore it, likely the issue will be closed as invalid. We cannot really make guesses.\n"
        },
        {
          "name": "Changelog.rst",
          "type": "blob",
          "size": 0.2294921875,
          "content": "##################\n Nuitka Changelog\n##################\n\nIn this document, we track the per version changes and comments. This is\nnow maintained separately at https://nuitka.net/changelog/Changelog.html\nplease check it out from there.\n"
        },
        {
          "name": "Developer_Manual.rst",
          "type": "blob",
          "size": 149.2998046875,
          "content": "#########################\n Nuitka Developer Manual\n#########################\n\nThe purpose of this Developer Manual is to present the current design of\nNuitka, the project rules, and the motivations for choices made. It is\nintended to be a guide to the source code, and to give explanations that\ndon't fit into the source code in comments form.\n\nIt should be used as a reference for the process of planning and\ndocumenting decisions we made. Therefore we are e.g. presenting here the\ntype inference plans before implementing them. And we update them as we\nproceed.\n\nIt grows out of discussions and presentations made at conferences as\nwell as private conversations or issue tracker.\n\n************\n Milestones\n************\n\n#. Feature parity with CPython, understand all the language construct\n   and behave absolutely compatible.\n\n   Feature parity has been reached for CPython 2.6 and 2.7. We do not\n   target any older CPython release. For CPython 3 up to 3.13 it also\n   has been reached. We do not target the older and practically unused\n   CPython 3.0 to 3.3 releases.\n\n   This milestone was reached. Dropping support for Python 2.6 is an\n   option, should this prove to be any benefit. Currently it is not, as\n   it extends the test coverage only.\n\n#. Create the most efficient native code from this. This means to be\n   fast with the basic Python object handling.\n\n   This milestone was reached, although of course, micro optimizations\n   to this are happening all the time.\n\n#. Then do constant propagation, determine as many values and useful\n   constraints as possible at compile time and create more efficient\n   code.\n\n   This milestone is considered almost reached. We continue to discover\n   new things, but the infrastructure is there, and these are easy to\n   add.\n\n#. Type inference, detect and special case the handling of strings,\n   integers, lists in the program.\n\n   This milestone is considered in progress.\n\n#. Add interfacing to C code, so Nuitka can turn a ``ctypes`` binding\n   into an efficient binding as written with C.\n\n   This milestone is planned only.\n\n#. Add hints module with a useful Python implementation that the\n   compiler can use to learn about types from the programmer.\n\n   This milestone is planned only.\n\n*****************\n Version Numbers\n*****************\n\nFor Nuitka we use semantic versioning, initially with a leading zero\nstill, once we pass release ``1.9``, the scheme will indicate the ``10``\nthrough using ``2.0``.\n\n***************\n Current State\n***************\n\nNuitka top level works like this:\n\n-  ``nuitka.tree.Building`` outputs node tree\n\n-  ``nuitka.optimization`` enhances it as best as it can\n\n-  ``nuitka.finalization`` prepares the tree for code generation\n\n-  ``nuitka.code_generation.CodeGeneration`` orchestrates the creation\n   of code snippets\n\n-  ``nuitka.code_generation.*Codes`` knows how specific code kinds are\n   created\n\n-  ``nuitka.MainControl`` keeps it all together\n\nThis design is intended to last.\n\nRegarding types, the state is:\n\n-  Types are always ``PyObject *``, and only a few C types, e.g.\n   ``nuitka_bool`` and ``nuitka_void`` and more are coming. Even for\n   objects, often it's know that things are e.g. really a\n   ``PyTupleObject **``, but no C type is available for that yet.\n\n-  There are a some specific use of types beyond \"compile time\n   constant\", that are encoded in type and value shapes, which can be\n   used to predict some operations, conditions, etc. if they raise, and\n   result types they give.\n\n-  In code generation, the supported C types are used, and sometimes we\n   have specialized code generation, e.g. a binary operation that takes\n   an ``int`` and a ``float`` and produces a ``float`` value. There will\n   be fallbacks to less specific types.\n\nThe expansion with more C types is currently in progress, and there will\nalso be alternative C types, where e.g. ``PyObject *`` and ``C long``\nare in an enum that indicates which value is valid, and where special\ncode will be available that can avoid creating the ``PyObject **``\nunless the later overflows.\n\n***************************************************\n Setting up the Development Environment for Nuitka\n***************************************************\n\nCurrently there are very different kinds of files that we need support\nfor. This is best addressed with an IDE. We cover here how to setup the\nmost common one.\n\nVisual Studio Code\n==================\n\nDownload Visual Studio Code from here:\nhttps://code.visualstudio.com/download\n\nAt this time, this is the recommended IDE for Linux and Windows. This is\ngoing to cover the plugins to install. Configuration is part of the\n``.vscode`` in your Nuitka checkout. If you are not familiar with\nEclipse, this is Free Software IDE,designed to be universally extended,\nand it truly is. There are plugins available for nearly everything.\n\nThe extensions to be installed are part of the Visual Code\nrecommendations in ``.vscode/extensions.json`` and you will be prompted\nabout that and ought to install these.\n\nEclipse / PyCharm\n=================\n\nDon't use these anymore, we consider Visual Studio Code to be far\nsuperior for delivering a nice out of the box environment.\n\n*************************\n Commit and Code Hygiene\n*************************\n\nIn Nuitka we have tools to auto format code, you can execute them\nmanually, but it's probably best to execute them at commit time, to make\nsure when we share code, it's already well format, and to avoid noise\ndoing cleanups.\n\nThe kinds of changes also often cause unnecessary merge conflicts, while\nthe auto format is designed to format code also in a way that it avoids\nmerge conflicts in the normal case, e.g. by doing imports one item per\nline.\n\nIn order to set up hooks, you need to execute these commands:\n\n.. code:: bash\n\n   # Where python is the one you use with Nuitka, this then gets all\n   # development requirements, can be full PATH.\n   python -m pip install -r requirements-devel.txt\n   python ./misc/install-git-hooks.py\n\nThese commands will make sure that the ``autoformat-nuitka-source`` is\nrun on every staged file content at the time you do the commit. For C\nfiles, it may complain unavailability of ``clang-format``, follow it's\nadvice. You may call the above tool at all times, without arguments to\nformat call Nuitka source code.\n\nShould you encounter problems with applying the changes to the checked\nout file, you can always execute it with ``COMMIT_UNCHECKED=1``\nenvironment set.\n\n*********************\n Coding Rules Python\n*********************\n\nThese rules should generally be adhered when working on Nuitka code.\nIt's not library code and it's optimized for readability, and avoids all\nperformance optimization for itself.\n\nTool to format\n==============\n\nThere is a tool ``bin/autoformat-nuitka-source`` which is to apply\nautomatic formatting to code as much as possible. It uses ``black``\n(internally) for consistent code formatting. The imports are sorted with\n``isort`` for proper order.\n\nThe tool (mostly ``black`` and ``isort``) encodes all formatting rules,\nand makes the decisions for us. The idea being that we can focus on\nactual code and do not have to care as much about other things. It also\ndeals with Windows new lines, trailing space, etc. and even sorts PyLint\ndisable statements.\n\nIdentifiers\n===========\n\nClasses\n-------\n\nClasses are camel case with leading upper case. Functions and methods\nare with leading verb in lower case, but also camel case. Variables and\narguments are lower case with ``_`` as a separator.\n\n.. code:: python\n\n   class SomeClass:\n       def doSomething(some_parameter):\n           some_var = (\"foo\", \"bar\")\n\nBase classes that are abstract have their name end with ``Base``, so\nthat a meta class can use that convention, and readers immediately know,\nthat it will not be instantiated like that.\n\nFunctions\n---------\n\nFunction calls use keyword argument preferably. These are slower in\nCPython, but more readable:\n\n.. code:: python\n\n   getSequenceCreationCode(\n       sequence_kind=sequence_kind, element_identifiers=identifiers, context=context\n   )\n\nWhen the names don't add much value, sequential calls can be done:\n\n.. code:: python\n\n   context.setLoopContinueTarget(handler_start_target)\n\nHere, ``setLoopContinueTarget`` will be so well known that the reader is\nexpected to know the argument names and their meaning, but it would be\nstill better to add them. But in this instance, the variable name\nalready indicates that it is.\n\nModule/Package Names\n--------------------\n\nNormal modules are named in camel case with leading upper case, because\nof their role as singleton classes. The difference between a module and\na class is small enough and in the source code they are also used\nsimilarly.\n\nFor the packages, no real code is allowed in their ``__init__.py`` and\nthey must be lower case, like e.g. ``nuitka`` or ``codegen``. This is to\ndistinguish them from the modules.\n\nPackages shall only be used to group things. In\n``nuitka.code_generation`` the code generation packages are located,\nwhile the main interface is ``nuitka.code_generation.CodeGeneration``\nand may then use most of the entries as local imports.\n\nThere is no code in packages themselves. For programs, we use\n``__main__`` package to carry the actual code.\n\nNames of modules should be plurals if they contain classes. Example is\nthat a ``Nodes`` module that contains a ``Node`` class.\n\nContext Managers\n----------------\n\nNames for context manages start with ``with``\n\nIn order to easily recognize that something is to be used as a context\nmanager, we follow a pattern of naming them ``withSomething``, to make\nthat easily recognized.\n\n.. code:: python\n\n   with withEnvironmentPathAdded(os.path.join(sys.prefix, \"bin\")):\n       with withDirectoryChange(self.qt_datadir):\n           ...\n\nThis makes these easy to recognize even in their definition.\n\nPrefer list contractions over built-ins\n=======================================\n\nThis concerns ``map``, ``filter``, and ``apply``. Usage of these\nbuilt-ins is highly discouraged within Nuitka source code. Using them is\nconsidered worth a warning by \"PyLint\" e.g. \"Used built-in function\n'map'\". We should use list contractions instead, because they are more\nreadable.\n\nList contractions are a generalization for all of them. We love\nreadability and with Nuitka as a compiler, there won't be any\nperformance difference at all.\n\nThere are cases where a list contraction is faster because you can avoid\nto make a function call. And there may be cases, where map is faster, if\na function must be called. These calls can be very expensive in CPython,\nand if you introduce a function, just for ``map``, then it might be\nslower.\n\nBut of course, Nuitka is the project to free us from what is faster and\nto allow us to use what is more readable, so whatever is faster, we\ndon't care. We make all options equally fast and let people choose.\n\nFor Nuitka the choice is list contractions as these are more easily\nchanged and readable.\n\nLook at this code examples from Python:\n\n.. code:: python\n\n   class A:\n       def getX(self):\n           return 1\n\n       x = property(getX)\n\n\n   class B(A):\n       def getX(self):\n           return 2\n\n\n   A().x == 1  # True\n   B().x == 1  # True (!)\n\nThis pretty much is what makes properties bad. One would hope ``B().x``\nto be ``2``, but instead it's not changed. Because of the way properties\ntake the functions and not members, and because they then are not part\nof the class, they cannot be overloaded without redeclaring them.\n\nOverloading is then not at all obvious anymore. Now imagine having a\nsetter and only overloading the getter. How to update the property\neasily?\n\nSo, that's not likable about them. And then we are also for clarity in\nthese internal APIs too. Properties try and hide the fact that code\nneeds to run and may do things. So let's not use them.\n\nFor an external API you may exactly want to hide things, but internally\nthat has no use, and in Nuitka, every API is internal API. One exception\nmay be the ``hints`` module, which will gladly use such tricks for an\neasier write syntax.\n\n****************\n Coding Rules C\n****************\n\nFor the static C parts, e.g. compiled types, helper codes, the\n``clang-format`` from LLVM project is used, the tool\n``autoformat-nuitka-source`` does this for us.\n\nWe always have blocks for conditional statements to avoid typical\nmistakes made by adding a statement to a branch, forgetting to make it a\nblock.\n\n**********************\n The \"git flow\" model\n**********************\n\n-  The flow is used for releases and occasionally subsequent hot fixes.\n\n   A few feature branches were used so far. It allows for quick delivery\n   of fixes to both the stable and the development version, supported by\n   a git plug-in, that can be installed via \"apt-get install git-flow\".\n\n-  Stable (``main`` branch)\n\n   The stable version, is expected to pass all the tests at all times\n   and is fully supported. As soon as bugs are discovered, they are\n   fixed as hot fixes, and then merged to develop by the \"git flow\"\n   automatically.\n\n-  Development (``develop`` branch)\n\n   The future release, supposedly in almost ready for release state at\n   nearly all times, but this is less strict. It is not officially\n   supported, and may have problems and at times inconsistencies.\n   Normally this branch is supposed to not be rebased. For severe\n   problems it may be done though.\n\n-  Factory (default feature branch)\n\n   Code under construction. We publish commits there, that may not hold\n   up in testing, and before it enters develop branch. Factory may have\n   severe regressions frequently, and commits become **rebased all the\n   time**, so do not base your patches on it, please prefer the\n   ``develop`` branch for that, unless of course, it's about factory\n   code itself.\n\n-  Personal branches (jorj, orsiris, others as well)\n\n   We are currently not using this, but it's an option.\n\n-  Feature Branches\n\n   We are not currently using these. They could be used for long lived\n   changes that extend for multiple release cycles and are not ready\n   yet. Currently we perform all changes in steps that can be included\n   in releases or delay making those changes.\n\n******************************\n Nuitka \"git/github\" Workflow\n******************************\n\n-  Forking and cloning\n\n   You need to have git installed and GitHub account. Goto Nuitka\n   repository <https://github.com/Nuitka/Nuitka> and fork the\n   repository.\n\n   To clone it to your local machine execute the following your git\n   bash:\n\n   .. code:: bash\n\n      git clone https://github.com/your-user-name/Nuitka.git\n      cd Nuitka\n      git remote add upstream https://github.com/Nuitka/Nuitka.git\n\n-  Create a Branch\n\n   .. code:: bash\n\n      git checkout develop\n      git pull --rebase upstream\n      git checkout -b feature_branch\n\n   If you are having merge conflicts while doing the previous step, then\n   check out (DON'T FORGET TO SAVE YOUR CHANGES FIRST IF ANY):\n   <https://stackoverflow.com/questions/1125968/how-do-i-force-git-pull-to-overwrite-local-files>\n\n-  In case you have an existing branch rebase it to develop\n\n   .. code:: bash\n\n      git fetch upstream\n      git rebase upstream/develop\n\n   Fix the merge conflicts if any and continue or skip commit if it is\n   not your. Sometimes for important bug fixes, develop history gets\n   rewritten. In that case, old and new commits will conflict during\n   your rebase, and skipping is the best way to go.\n\n   .. code:: bash\n\n      git rebase --continue\n      # not your commit:\n      git rebase --skip\n\n   If anything goes wrong while rebasing:\n\n   .. code:: bash\n\n      git rebase --abort\n\n-  Making changes\n\n   .. code:: bash\n\n      git commit -a -m \"Commit Message\"\n      git push -u origin # once, later always:\n      git push\n\n**********************************\n API Documentation and Guidelines\n**********************************\n\nThere is API documentation generated with ``doxygen``, available at\n`this location <https://nuitka.net/apidoc>`__ .\n\nTo ensure meaningful ``doxygen`` output, the following guidelines must\nbe observed when creating or updating Python source:\n\nUse of Standard Python ``__doc__`` Strings\n==========================================\n\nEvery class and every method should be documented via the standard\nPython delimiters (``\"\"\" ... \"\"\"``) in the usual way.\n\nSpecial ``doxygen`` Anatomy of ``__doc__``\n==========================================\n\n.. note::\n\n   We are replacing Doxygen with sphinx, this is all obsolete\n\n-  Immediately after the leading ``\"\"\"``, and after 1 space on the same\n   line, enter a brief description or title of the class or method. This\n   must be 1 line and be followed by at least 1 empty line.\n\n-  Depending on the item, choose from the following \"sections\" to\n   describe what the item is and does.\n\n   Each section name is coded on its own line, aligned with the leading\n   ``\"\"\"`` and followed by a colon \":\". Anything following the section,\n   must start on a new line and be indented by 4 spaces relative to the\n   section. Except for the first section (``Notes:``) after the title,\n   sections need not be preceded by empty lines -- but it is good\n   practice to still do that.\n\n   -  ``Notes:`` detailed description of the item, any length.\n\n      May contain line breaks with each new line starting aligned with\n      previous one. The text will automatically be joined across line\n      breaks and be reformatted in the browser.\n\n      If you describe details for a class, you can do so **without**\n      using this section header and all formatting will still work fine.\n      If you however omit the ``Notes:`` for methods, then the text will\n      be interpreted **as code**, be shown in an ugly monospaced font,\n      and no automatic line breaks will occur in the browser.\n\n   -  ``Args:`` positional arguments.\n\n      Each argument then follows, starting on a new line and indented by\n      4 spaces. The argument name must be followed by a colon ``:`` or\n      double hash ``--``, followed by a description of arbitrary length.\n\n      The description can be separated by line breaks.\n\n   -  ``Kwargs:`` keyword arguments. Same rules as for args.\n\n   -  ``Returns:`` description of what will be returned if applicable\n      (any length).\n\n   -  ``Yields:`` synonymous for ``Returns:``.\n\n   -  ``Raises:`` name any exceptions that may be raised.\n\n   -  ``Examples:`` specify any example code.\n\n.. code:: python\n\n   def foo(p1, p2, kw1=None, kw2=None):\n       \"\"\"This is an example method.\n\n       Notes:\n           It does one or the other indispensable things based on some parameters\n           and proudly returns a dictionary.\n\n       Args:\n           p1: parameter one\n           p2: parameter two\n\n       Kwargs:\n           kw1: keyword one\n           kw2: keyword two\n\n       Returns:\n           A dictionary calculated from the input.\n\n       Raises:\n           ValueError, IndexError\n\n       Examples:\n           >>> foo(1, 2, kw1=3, kw2=4)\n           {'a': 4, 'b': 6}\n       \"\"\"\n\n*********************\n Checking the Source\n*********************\n\nThe static checking for errors is currently done with ``PyLint``. In the\nfuture, Nuitka itself will gain the ability to present its findings in a\nsimilar way, but this is not a priority, and we are not there yet.\n\nSo, we currently use ``PyLint`` with options defined in a script.\n\n.. code:: bash\n\n   ./bin/check-nuitka-with-pylint\n\nThe above command is expected to give no warnings. It is also run on our\nCI and we will not merge branches that do not pass.\n\n*******************\n Running the Tests\n*******************\n\nThis section describes how to run Nuitka tests.\n\nRunning all Tests\n=================\n\nThe top level access to the tests is as simple as this:\n\n.. code:: bash\n\n   ./tests/run-tests\n\nFor fine grained control, it has the following options:\n\n.. code::\n\n   --skip-basic-tests    The basic tests, execute these to check if Nuitka is\n                         healthy. Default is True.\n   --skip-syntax-tests   The syntax tests, execute these to check if Nuitka\n                         handles Syntax errors fine. Default is True.\n   --skip-program-tests  The programs tests, execute these to check if Nuitka\n                         handles programs, e.g. import recursions, etc. fine.\n                         Default is True.\n   --skip-package-tests  The packages tests, execute these to check if Nuitka\n                         handles packages, e.g. import recursions, etc. fine.\n                         Default is True.\n   --skip-optimizations-tests\n                         The optimization tests, execute these to check if\n                         Nuitka does optimize certain constructs fully away.\n                         Default is True.\n   --skip-standalone-tests\n                         The standalone tests, execute these to check if Nuitka\n                         standalone mode, e.g. not referring to outside,\n                         important 3rd library packages like PyQt fine. Default\n                         is True.\n   --skip-reflection-test\n                         The reflection test compiles Nuitka with Nuitka, and\n                         then Nuitka with the compile Nuitka and compares the\n                         outputs. Default is True.\n   --skip-cpython26-tests\n                         The standard CPython2.6 test suite. Execute this for\n                         all corner cases to be covered. With Python 2.7 this\n                         covers exception behavior quite well. Default is True.\n   --skip-cpython27-tests\n                         The standard CPython2.7 test suite. Execute this for\n                         all corner cases to be covered. With Python 2.6 these\n                         are not run. Default is True.\n   --skip-cpython32-tests\n                         The standard CPython3.2 test suite. Execute this for\n                         all corner cases to be covered. With Python 2.6 these\n                         are not run. Default is True.\n   --skip-cpython33-tests\n                         The standard CPython3.3 test suite. Execute this for\n                         all corner cases to be covered. With Python 2.x these\n                         are not run. Default is True.\n   --skip-cpython34-tests\n                         The standard CPython3.4 test suite. Execute this for\n                         all corner cases to be covered. With Python 2.x these\n                         are not run. Default is True.\n   --skip-cpython35-tests\n                         The standard CPython3.5 test suite. Execute this for\n                         all corner cases to be covered. With Python 2.x these\n                         are not run. Default is True.\n   --skip-cpython36-tests\n                         The standard CPython3.6 test suite. Execute this for\n                         all corner cases to be covered. With Python 2.x these\n                         are not run. Default is True.\n   --skip-cpython37-tests\n                         The standard CPython3.7 test suite. Execute this for\n                         all corner cases to be covered. With Python 2.x these\n                         are not run. Default is True.\n   --skip-cpython38-tests\n                         The standard CPython3.8 test suite. Execute this for\n                         all corner cases to be covered. With Python 2.x these\n                         are not run. Default is True.\n   --skip-cpython39-tests\n                         The standard CPython3.9 test suite. Execute this for\n                         all corner cases to be covered. With Python 2.x these\n                         are not run. Default is True.\n   --skip-cpython310-tests\n                         The standard CPython3.10 test suite. Execute this for\n                         all corner cases to be covered. With Python 2.x these\n                         are not run. Default is True.\n   --skip-cpython311-tests\n                         The standard CPython3.11 test suite. Execute this for\n                         all corner cases to be covered. With Python 2.x these\n                         are not run. Default is True.\n   --skip-cpython312-tests\n                         The standard CPython3.12 test suite. Execute this for\n                         all corner cases to be covered. With Python 2.x these\n                         are not run. Default is True.\n   --skip-cpython313-tests\n                         The standard CPython3.13 test suite. Execute this for\n                         all corner cases to be covered. With Python 2.x these\n                         are not run. Default is True.\n   --no-python2.6        Do not use Python 2.6 even if available on the system.\n                         Default is False.\n   --no-python2.7        Do not use Python 2.7 even if available on the system.\n                         Default is False.\n   --no-python3.4        Do not use Python 3.4 even if available on the system.\n                         Default is False.\n   --no-python3.5        Do not use Python 3.5 even if available on the system.\n                         Default is False.\n   --no-python3.6        Do not use Python 3.6 even if available on the system.\n                         Default is False.\n   --no-python3.7        Do not use Python 3.7 even if available on the system.\n                         Default is False.\n   --no-python3.8        Do not use Python 3.8 even if available on the system.\n                         Default is False.\n   --no-python3.9        Do not use Python 3.9 even if available on the system.\n                         Default is False.\n   --no-python3.10       Do not use Python 3.10 even if available on the system.\n                         Default is False.\n   --no-python3.11       Do not use Python 3.11 even if available on the system.\n                         Default is False.\n   --no-python3.12       Do not use Python 3.12 even if available on the system.\n                         Default is False.\n   --no-python3.13       Do not use Python 3.13 even if available on the system.\n                         Default is False.\n   --coverage            Make a coverage analysis, that does not really check.\n                         Default is False.\n\nYou will only run the CPython test suites, if you have the submodules of\nthe Nuitka git repository checked out. Otherwise, these will be skipped\nwith a warning that they are not available.\n\nThe policy is generally, that ``./test/run-tests`` running and passing\nall the tests on Linux and Windows shall be considered sufficient for a\nrelease, but of course, depending on changes going on, that might have\nto be expanded.\n\nBasic Tests\n===========\n\nYou can run the \"basic\" tests like this:\n\n.. code:: bash\n\n   ./tests/basics/run_all.py search\n\nThese tests normally give sufficient coverage to assume that a change is\ncorrect, if these \"basic\" tests pass. The most important constructs and\nbuilt-ins are exercised.\n\nTo control the Python version used for testing, you can set the\n``PYTHON`` environment variable to e.g. ``python3.5`` (can also be full\npath), or simply execute the ``run_all.py`` script directly with the\nintended version, as it is portable across all supported Python\nversions, and defaults testing with the Python version is run with.\n\nSyntax Tests\n============\n\nThen there are \"syntax\" tests, i.e. language constructs that need to\ngive a syntax error.\n\nIt sometimes so happens that Nuitka must do this itself, because the\n``ast.parse`` doesn't see the problem and raises no ``SyntaxError`` of\nits own. These cases are then covered by tests to make sure they work as\nexpected.\n\nUsing the ``global`` statement on a function argument is an example of\nthis. These tests make sure that the errors of Nuitka and CPython are\ntotally the same for this:\n\n.. code:: bash\n\n   ./tests/syntax/run_all.py search\n\nProgram Tests\n=============\n\nThen there are small \"programs\" tests, that e.g. exercise many kinds of\nimport tricks and are designed to reveal problems with inter-module\nbehavior. These can be run like this:\n\n.. code:: bash\n\n   ./tests/programs/run_all.py search\n\nGenerated Tests\n===============\n\nThere are tests, which are generated from Jinja2 templates. They aim at\ne.g. combining at types with operations, in-place or not, or large\nconstants. These can be run like this:\n\n.. code:: bash\n\n   ./tests/generated/run_all.py search\n\nCompile Nuitka with Nuitka\n==========================\n\nAnd there is the \"compile itself\" or \"reflected\" test. This test makes\nNuitka compile itself and compare the resulting C++ when running\ncompiled to non-compiled, which helps to find in-determinism.\n\nThe test compiles every module of Nuitka into an extension module and\nall of Nuitka into a single binary.\n\nThat test case also gives good coverage of the ``import`` mechanisms,\nbecause Nuitka uses a lot of packages and imports between them.\n\n.. code:: bash\n\n   ./tests/reflected/compile_itself.py\n\n*********************\n Internal/Plugin API\n*********************\n\nThe documentation from the source code for both the Python and the C\nparts are published as `Nuitka API <https://nuitka.net/apidoc>`__ and\narguably in a relatively bad shape as we started generating those with\nDoxygen only relatively late.\n\n.. code:: bash\n\n   doxygen ./doc/Doxyfile\n   xdg-open html\n\nImprovements have already been implemented for plugins: The plugin base\nclass defined in ``PluginBase.py`` (which is used as a template for all\nplugins) is fully documented in Doxygen now. The same is true for the\nrecently added standard plugins ``NumpyPlugin.py`` and\n``TkinterPlugin.py``. These will be uploaded very soon.\n\nGoing forward, this will also happen for the remaining standard plugins.\n\nPlease find `here\n<https://github.com/Nuitka/Nuitka/blob/develop/UserPlugin-Creation.rst>`__\na detailed description of how to write your own plugin.\n\nTo learn about plugin option specification consult `this document\n<https://github.com/Nuitka/Nuitka/blob/develop/Using-Plugin-Options.rst>`__.\n\n*********************************\n Working with the CPython suites\n*********************************\n\nResetting CPython suites\n========================\n\nThe CPython test suites are different branches of the same submodule.\nWhen you update your git checkout, they will frequently become detached.\nIn this case, simply execute this command:\n\n.. code:: bash\n\n   git submodule foreach 'git fetch && git checkout $(basename $(pwd)) && \\\n   git reset --hard origin/$(basename $(pwd))'\n\nAdded new CPython suites\n========================\n\nWhen adding a test suite, for a new version, proceed like this, of\ncourse while adapting of course the names. These are the commands used\nfor adding CPython313 based on the CPython312 branch.\n\n.. code:: bash\n\n   # Switch to a new branch.\n   git checkout CPython312\n   git branch CPython313\n   git checkout CPython313\n\n   # Delete all but root commit\n   git reset --hard `git log --root --oneline --reverse | head -1 | cut -d' ' -f1`\n\n   # Switch test data to upstream ones.\n   rm -rf test\n   cp -r ~/repos/Nuitka-references/final/Python-3.13.0/Lib/test test\n   git add test\n\n   # Update commit message to mention proper Python version.\n   git commit --amend -m \"Initial commit of Python tests as in 3.13.0\"\n\n   # Push to github, setting upstream for branch.\n   git push -u\n\n   # Cherry pick the removal commits from previous branches.\n   git log origin/CPython312 --reverse --oneline | grep ' Removed' | cut -d' ' -f1 | xargs git cherry-pick\n   # When being prompted for merge conflicts with the deleted files:\n   git status | sed -n 's/deleted by them://p' | xargs git rm --ignore-unmatch x ; git cherry-pick --continue\n\n   # Push to github, this is useful.\n   git push\n\n   # Cherry pick the first commit of 'run_all.py', the copy it from the last state, and amend the commits.\n   git log --reverse origin/CPython312 --oneline -- run_all.py | head -1 | cut -d' ' -f1 | xargs git cherry-pick\n   git checkout origin/CPython312 -- run_all.py\n   chmod +x run_all.py\n   sed -i -e 's#python3.12#python3.13#' run_all.py\n   git commit --amend --no-edit run_all.py\n\n   # Same for 'update_doctest_generated.py'\n   git log --reverse origin/CPython312 --oneline -- update_doctest_generated.py | head -1 | cut -d' ' -f1 | xargs git cherry-pick\n   git checkout origin/CPython312 -- update_doctest_generated.py\n   chmod +x update_doctest_generated.py\n   sed -i -e 's#python3.12#python3.13#' update_doctest_generated.py\n   git commit --amend --no-edit update_doctest_generated.py\n\n   # Same for .gitignore\n   git log --reverse origin/CPython312 --oneline -- .gitignore | head -1 | cut -d' ' -f1 | xargs git cherry-pick\n   git checkout origin/CPython312 -- .gitignore\n   git commit --amend --no-edit .gitignore\n\n   # Now cherry-pick all commits of test support, these disable network, audio, GUI, random filenames and more\n   # and are crucial for deterministic outputs and non-reliance on outside stuff.\n   git log --reverse origin/CPython312 --oneline -- test/support/__init__.py | tail -n +2 | cut -d' ' -f1 | xargs git cherry-pick\n\n   git push\n\n*********************\n Design Descriptions\n*********************\n\nThese should be a lot more and contain graphics from presentations\ngiven. It will be filled in, but not now.\n\nNuitka Logo\n===========\n\nThe logo was submitted by \"dr. Equivalent\". It's source is contained in\n``doc/Logo`` where 3 variants of the logo in SVG are placed.\n\n-  Symbol only (symbol)\n\n.. code:: rest\n\n   .. image:: doc/images/Nuitka-Logo-Symbol.png\n      :alt: Nuitka Logo\n\n-  Text next to symbol (horizontal)\n\n.. code:: rest\n\n   .. image:: doc/images/Nuitka-Logo-Horizontal.png\n      :alt: Nuitka Logo\n\n-  Text beneath symbol (vertical)\n\n.. code:: rest\n\n   .. image:: doc/images/Nuitka-Logo-Vertical.png\n      :alt: Nuitka Logo\n\nFrom these logos, PNG images, and \"favicons\", and are derived.\n\nThe exact ImageMagick commands are in\n``nuitka/tools/release/Documentation``, but are not executed each time,\nthe commands are also replicated here:\n\n.. code:: bash\n\n   convert -background none doc/Logo/Nuitka-Logo-Symbol.svg doc/images/Nuitka-Logo-Symbol.png\n   convert -background none doc/Logo/Nuitka-Logo-Vertical.svg doc/images/Nuitka-Logo-Vertical.png\n   convert -background none doc/Logo/Nuitka-Logo-Horizontal.svg doc/images/Nuitka-Logo-Horizontal.png\n\nChoice of the Target Language\n=============================\n\n-  Choosing the target language was important decision. factors were:\n\n   -  The portability of Nuitka is decided here\n   -  How difficult is it to generate the code?\n   -  Does the Python C-API have bindings?\n   -  Is that language known?\n   -  Does the language aid to find bugs?\n\nThe *decision for C11* is ultimately one for portability, general\nknowledge of the language and for control over created code, e.g. being\nable to edit and try that quickly.\n\nThe current status is to use pure C11. All code compiles as C11, and\nalso in terms of workaround to missing compiler support as C++03. This\nis mostly needed, because MSVC does not support C. Naturally we are not\nusing any C++ features, just the allowances of C++ features that made it\ninto C11, which is e.g. allowing late definitions of variables.\n\nUse of Scons internally\n=======================\n\nNuitka does not involve Scons in its user interface at all; Scons is\npurely used internally. Nuitka itself, being pure Python, will run\nwithout any build process just fine.\n\nNuitka simply prepares ``<program>.build`` folders with lots of files\nand tasks scons to execute the final build, after which Nuitka again\nwill take control and do more work as necessary.\n\n.. note::\n\n   When we speak of \"standalone\" mode, this is handled outside of Scons,\n   and after it, creating the \".dist\" folder. This is done in\n   ``nuitka.MainControl`` module.\n\nFor interfacing to Scons, there is the module\n``nuitka.build.SconsInterface`` that will support calling ``scons`` -\npotentially from one of two inline copies (one for before / one for\nPython 3.5 or later). These are mainly used on Windows or when using\nsource releases - and passing arguments to it. These arguments are\npassed as ``key=value``, and decoded in the scons file of Nuitka.\n\nThe scons file is named ``SingleExe.scons`` for lack of better name.\nIt's really wrong now, but we have yet to find a better name. It once\nexpressed the intention to be used to create executables, but the same\nworks for modules too, as in terms of building, and to Scons, things\nreally are the same.\n\nThe scons file supports operation in multiple modes for many things, and\nmodules is just one of them. It runs outside of Nuitka process scope,\neven with a different Python version potentially, so all the information\nmust be passed on the command line.\n\nWhat follows is the (lengthy) list of arguments that the scons file\nprocesses:\n\n-  ``source_dir``\n\n   Where is the generated C source code. Scons will just compile\n   everything it finds there. No list of files is passed, but instead\n   this directory is being scanned.\n\n-  ``nuitka_src``\n\n   Where do the include files and static C parts of Nuitka live. These\n   provide e.g. the implementation of compiled function, generators, and\n   other helper codes, this will point to where ``nuitka.build`` package\n   lives normally.\n\n-  ``module_mode``\n\n   Build a module instead of a program.\n\n-  ``result_base``\n\n   This is not a full name, merely the basename for the result to be\n   produced, but with path included, and the suffix comes from module or\n   executable mode.\n\n-  ``debug_mode``\n\n   Enable debug mode, which is a mode, where Nuitka tries to help\n   identify errors in itself, and will generate less optimal code. This\n   also asks for warnings, and makes the build fail if there are any.\n   Scons will pass different compiler options in this case.\n\n-  ``python_debug``\n\n   Compile and link against Python debug mode, which does assertions and\n   extra checks, to identify errors, mostly related to reference\n   counting. May make the build fail, if no debug build library of\n   CPython is available. On Windows it is possible to install it for\n   CPython3.5 or higher.\n\n-  ``full_compat_mode``\n\n   Full compatibility, even where it's stupid, i.e. do not provide\n   information, even if available, in order to assert maximum\n   compatibility. Intended to control the level of compatibility to\n   absurd.\n\n-  ``experimental_mode``\n\n   Do things that are not yet accepted to be safe.\n\n-  ``lto_mode``\n\n   Make use of link time optimization of gcc compiler if available and\n   known good with the compiler in question. So far, this was not found\n   to make major differences.\n\n-  ``disable_console``\n\n   Windows subsystem mode: Disable console for windows builds.\n\n-  ``unstripped_mode``\n\n   Unstripped mode: Do not remove debug symbols.\n\n-  ``clang_mode``\n\n   Clang compiler mode, default on macOS X and FreeBSD, optional on\n   Linux.\n\n-  ``mingw_mode``\n\n   MinGW compiler mode, optional and useful on Windows only.\n\n-  ``standalone_mode``\n\n   Building a standalone distribution for the binary.\n\n-  ``show_scons``\n\n   Show scons mode, output information about Scons operation. This will\n   e.g. also output the actual compiler used, output from compilation\n   process, and generally debug information relating to be build\n   process.\n\n-  ``python_prefix``\n\n   Home of Python to be compiled against, used to locate headers and\n   libraries.\n\n-  ``target_arch``\n\n   Target architecture to build. Only meaningful on Windows.\n\n-  ``python_version``\n\n   The major version of Python built against.\n\n-  ``abiflags``\n\n   The flags needed for the Python ABI chosen. Might be necessary to\n   find the folders for Python installations on some systems.\n\n-  ``icon_path``\n\n   The icon to use for Windows programs if given.\n\nLocating Modules and Packages\n=============================\n\nThe search for modules used is driven by ``nuitka.importing.Importing``\nmodule.\n\n-  Quoting the ``nuitka.importing.Importing`` documentation:\n\n   Locating modules and package source on disk.\n\n   The actual import of a module would already execute code that changes\n   things. Imagine a module that does ``os.system()``, it would be done\n   during compilation. People often connect to databases, and these kind\n   of things, at import time.\n\n   Therefore CPython exhibits the interfaces in an ``imp`` module in\n   standard library, which one can use those to know ahead of time, what\n   file import would load. For us unfortunately there is nothing in\n   CPython that is easily accessible and gives us this functionality for\n   packages and search paths exactly like CPython does, so we implement\n   here a multi step search process that is compatible.\n\n   This approach is much safer of course and there is no loss. To\n   determine if it's from the standard library, one can abuse the\n   attribute ``__file__`` of the ``os`` module like it's done in\n   ``isStandardLibraryPath`` of this module.\n\n   End quoting the ``nuitka.importing.Importing`` documentation.\n\n-  Role\n\n   This module serves the recursion into modules and analysis if a\n   module is a known one. It will give warnings for modules attempted to\n   be located, but not found. These warnings are controlled by a while\n   list inside the module.\n\nThe decision making and caching are located in the ``nuitka.tree``\npackage, in modules ``nuitka.tree.Recursion`` and\n``nuitka.tree.ImportCache``. Each module is only considered once (then\ncached), and we need to obey lots of user choices, e.g. to compile a\nstandard library or not.\n\nHooking for module ``import`` process\n=====================================\n\nCurrently, in generated code, for every ``import`` a normal\n``__import__()`` built-in call is executed. The\n``nuitka/build/static_src/MetaPathBasedLoader.c`` file provides the\nimplementation of a ``sys.meta_path`` hook.\n\nThis meta path based importer allows us to have the Nuitka provided\nmodule imported even when imported by non-compiled code.\n\n.. note::\n\n   Of course, it would make sense to compile time detect which module it\n   is that is being imported and then to make it directly. At this time,\n   we don't have this inter-module optimization yet, mid-term it should\n   become easy to add.\n\nSupporting ``__class__`` of Python3\n===================================\n\nIn Python3 the handling of ``__class__`` and ``super`` is different from\nPython2. It used to be a normal variable, and now the following things\nhave changed.\n\n-  The use of the ``super`` variable name triggers the addition of a\n   closure variable ``__class__``, as can be witnessed by the following\n   code:\n\n   .. code:: python\n\n      class X:\n          def f1(self):\n              print(locals())\n\n          def f2(self):\n              print(locals())\n              super  # Just using the name, not even calling it.\n\n\n      x = X()\n      x.f1()\n      x.f2()\n\n   Output is:\n\n   .. code::\n\n      {'self': <__main__.X object at 0x7f1773762390>''} {'self':\n      <__main__.X object at 0x7f1773762390>, '__class__': <class\n      '__main__.X'>}\n\n-  This value of ``__class__`` is also available in the child functions.\n\n-  The parser marks up code objects usage of \"super\". It doesn't have to\n   be a call, it can also be a local variable. If the ``super`` built-in\n   is assigned to another name and that is used without arguments, it\n   won't work unless ``__class__`` is taken as a closure variable.\n\n-  As can be seen in the CPython3 code, the closure value is added after\n   the class creation is performed.\n\n-  It appears, that only functions locally defined to the class are\n   affected and take the closure.\n\nThis left Nuitka with the strange problem, of how to emulate that.\n\nThe solution is this:\n\n-  Under Python3, usage of ``__class__`` as a reference in a child\n   function body is mandatory. It remains that way until all variable\n   names have been resolved.\n\n-  When recognizing calls to ``super`` without arguments, make the arguments\n      into variable reference to ``__class__`` and potentially ``self``\n      (actually first argument name).\n\n-  After all variables have been known, and no suspicious unresolved\n   calls to anything named ``super`` are down, then unused references\n   are optimized away by the normal unused closure variable.\n\n-  Class dictionary definitions are added.\n\n   These are special direct function calls, ready to propagate also\n   \"bases\" and \"metaclass\" values, which need to be calculated outside.\n\n   The function bodies used for classes will automatically store\n   ``__class__`` as a shared local variable, if anything uses it. And if\n   it's not assigned by user code, it doesn't show up in the \"locals()\"\n   used for dictionary creation.\n\n   Existing ``__class__`` local variable values are in fact provided as\n   closure, and overridden with the built class , but they should be\n   used for the closure giving, before the class is finished.\n\n   So ``__class__`` will be local variable of the class body, until the\n   class is built, then it will be the ``__class__`` itself.\n\nFrame Stack\n===========\n\nIn Python, every function, class, and module has a frame. It is created\nwhen the scope is entered, and there is a stack of these at run time,\nwhich becomes visible in tracebacks in case of exceptions.\n\nThe choice of Nuitka is to make this an explicit element of the node\ntree, that are as such subject to optimization. In cases, where they are\nnot needed, they may be removed.\n\nConsider the following code.\n\n.. code:: python\n\n   def f():\n       if someNotRaisingCall():\n           return somePotentiallyRaisingCall()\n       else:\n           return None\n\nIn this example, the frame is not needed for all the code, because the\ncondition checked wouldn't possibly raise at all. The idea is the make\nthe frame guard explicit and then to reduce its scope whenever possible.\n\nSo we start out with code like this one:\n\n.. code:: python\n\n   def f():\n       with frame_guard(\"f\"):\n           if someNotRaisingCall():\n               return somePotentiallyRaisingCall()\n           else:\n               return None\n\nThis is to be optimized into:\n\n.. code:: python\n\n   def f():\n       if someNotRaisingCall():\n           with frame_guard(\"f\"):\n               return somePotentiallyRaisingCall()\n       else:\n           return None\n\nNotice how the frame guard taking is limited and may be avoided, or in\nbest cases, it might be removed completely. Also this will play a role\nwhen in-lining function. The frame stack entry will then be\nautomatically preserved without extra care.\n\n.. note::\n\n   In the actual code, ``nuitka.nodes.FrameNodes.StatementsFrame`` is\n   represents this as a set of statements to be guarded by a frame\n   presence.\n\nParameter Parsing\n=================\n\nThe parsing of parameters is very convoluted in Python, and doing it in\na compatible way is not that easy. This is a description of the required\nprocess, for an easier overview.\n\nInput\n-----\n\nThe input is an argument ``tuple`` (the type is fixed), which contains\nthe positional arguments, and potentially an argument ``dict`` (type is\nfixed as well, but could also be ``NULL``, indicating that there are no\nkeyword arguments.\n\nKeyword dictionary\n------------------\n\nThe keyword argument dictionary is checked first. Anything in there,\nthat cannot be associated, either raise an error, or is added to a\npotentially given star dict argument. So there are two major cases.\n\n-  No star dict argument: Iterate over dictionary, and assign or raise\n   errors.\n\n   This check covers extra arguments given.\n\n-  With star dict argument: Iterate over dictionary, and assign or raise\n   errors.\n\n   Interesting case for optimization are no positional arguments, then\n   no check is needed, and the keyword argument dictionary could be used\n   as the star argument. Should it change, a copy is needed though.\n\nWhat's noteworthy here, is that in comparison to the keywords, we can\nhope that they are the same value as we use. The interning of strings\nincreases chances for non-compiled code to do that, esp. for short\nnames.\n\nWe then can do a simple ``is`` comparison and only fall back to real\nstring ``==`` comparisons, after all of these failed. That means more\ncode, but also a lot faster code in the positive case.\n\nArgument tuple\n--------------\n\nAfter this completed, the argument tuple is up for processing. The first\nthing it needs to do is to check if it's too many of them, and then to\ncomplain.\n\nFor arguments in Python2, there is the possibility of them being nested,\nin which case they cannot be provided in the keyword dictionary, and\nmerely should get picked from the argument tuple.\n\nOtherwise, the length of the argument tuple should be checked against\nits position and if possible, values should be taken from there. If it's\nalready set (from the keyword dictionary), raise an error instead.\n\nSSA form for Nuitka\n===================\n\nThe SSA form is critical to how optimization works. The so called trace\ncollections builds up traces. These are facts about how this works:\n\n-  Assignments draw from a counter unique for the variable, which\n   becomes the variable version. This happens during tree building\n   phase.\n\n-  References are associated with the version of the variable active.\n\n   This can be a merge of branches. Trace collection does do that and\n   provides nodes with the currently active trace for a variable.\n\nThe data structures used for trace collection need to be relatively\ncompact as the trace information can become easily much more data than\nthe program itself.\n\nEvery trace collection has these:\n\n-  variable_actives\n\n   Dictionary, where per \"variable\" the currently used version is. Used\n   to track situations changes in branches. This is the main input for\n   merge process.\n\n-  variable_traces\n\n   Dictionary, where \"variable\" and \"version\" form the key. The values\n   are objects with or without an assignment, and a list of usages,\n   which starts out empty.\n\n   These objects have usages appended to them. In \"onVariableSet\", a new\n   version is allocated, which gives a new object for the dictionary,\n   with an empty usages list, because each write starts a new version.\n   In \"onVariableUsage\" the version is detected from the current\n   version. It may be not set yet, which means, it's a read of an\n   undefined value (local variable, not a parameter name), or unknown in\n   case of global variable.\n\n   These objects may be told that their value has escaped. This should\n   influence the value friend they attached to the initial assignment.\n   Each usage may have a current value friend state that is different.\n\nWhen merging branches of conditional statements, the merge shall apply\nas follows:\n\n-  Branches have their own collection\n\n   Thee have potentially deviating sets of ``variable_actives``. These\n   are children of an outer collections.\n\n-  Case a) One branch only.\n\n   For that branch a collection is performed. As usual new assignments\n   generate a new version making it \"active\", references then related to\n   these \"active\" versions.\n\n   Then, when the branch is merged, for all \"active\" variables, it is\n   considered, if that is a change related to before the branch. If it's\n   not the same, a merge trace with the branch condition is created with\n   the one active in the collection before that statement.\n\n-  Case b) Two branches.\n\n   When there are two branches, they both as are treated as above,\n   except for the merge.\n\n   When merging, a difference in active variables between the two\n   branches creates the merge trace.\n\n.. note::\n\n   For conditional expressions, there are always only two branches. Even\n   if you think you have more than one branch, you do not. It's always\n   nested branches, already when it comes out of the ``ast`` parser.\n\nTrace structure, there are different kinds of traces.\n\n-  Initial write of the version\n\n   There may be an initial write for each version. It can only occur at\n   the start of the scope, but not later, and there is only one. This\n   might be known to be \"initialized\" (parameter variables of functions\n   are like that) or \"uninitialized\", or \"unknown\".\n\n-  Merge of other one or two other versions\n\n   This combines two or more previous versions. In cases of loop exits\n   or entries, there are multiple branches to combine potentially. These\n   branches can have vastly different properties.\n\n-  Becoming unknown.\n\n   When control flow escapes, e.g. for a module variable, any write can\n   occur to it, and it's value cannot be trusted to be unchanged. These\n   are then traced as unknown.\n\nAll traces have a base class ``ValueTraceBase`` which provides the\ninterface to query facts about the state of a variable in that trace.\nIt's e.g. of some interest, if a variable must have a value or must not.\nThis allows to e.g. omit checks, know what exceptions might raise.\n\nLoop SSA\n========\n\nFor loops we have the addition difficulty that we need would need to\nlook ahead what types a variable has at loop exit, but that is a cyclic\ndependency.\n\nOur solution is to consider the variable types at loop entry. When these\nchange, we drop all gained information from inside the loop. We may e.g.\nthink that a variable is a ``int`` or ``float``, but later recognize\nthat it can only be a float. Derivations from ``int`` must be discarded,\nand the loop analysis restarted.\n\nThen during the loop, we assign an incomplete loop trace shape to the\nvariable, which e.g. says it was an ``int`` initially and additional\ntype shapes, e.g. ``int or long`` are then derived. If at the end of the\nloop, a type produced no new types, we know we are finished and mark the\ntrace as a complete loop trace.\n\nIf it is not, and next time, we have the same initial types, we add the\nones derived from this to the starting values, and see if this gives\nmore types.\n\nPython Slots in Optimization\n============================\n\nBasic Slot Idea\n---------------\n\nFor almost all the operations in Python, a form of overloading is\navailable. That is what makes it so powerful.\n\nSo when you write an expression like this one:\n\n.. code:: python\n\n   1.0 + something\n\nThis something will not just blindly work when it's a float, but go\nthrough a slot mechanism, which then can be overloaded.\n\n.. code:: python\n\n   class SomeStrangeFloat:\n       def __float__(self):\n           return 3.14\n\n\n   something = SomeStrangeFloat()\n   # ...\n   1.0 + float(something) // 4.140000000000001\n\nHere it is the case, that this is used by user code, but more often this\nis used internally. Not all types have all slots, e.g. ``list`` does not\nhave ``__float__`` and therefore will refuse an addition to a ``float``\nvalue, based on that.\n\nAnother slot is working here, that we didn't mention yet, and that is\n``__add__`` which for some times will be these kinds of conversions or\nit will not do that kind of thing, e.g. something do hard checks, which\nis why this fails to work:\n\n.. code:: python\n\n   [] + ()\n\nAs a deliberate choice, there is no ``__list__`` slot used. The Python\ndesigners are aiming at solving many things with slots, but they also\naccept limitations.\n\nThere are many slots that are frequently used, most often behind your\nback (``__iter__``, ``__next__``, ``__lt__``, etc.). The list is large,\nand tends to grow with Python releases, but it is not endless.\n\nRepresentation in Nuitka\n------------------------\n\nSo a slot in Nuitka typically has an owning node. We use ``__len__`` as\nan example here. In the ``computeExpression`` the ``len`` node named\n``ExpressionBuiltinLen`` has to defer the decision what it computes to\nits argument.\n\n.. code:: python\n\n   def computeExpression(self, trace_collection):\n       return self.subnode_value.computeExpressionLen(\n           len_node=self, trace_collection=trace_collection\n       )\n\nThat decision then, in the absence of any type knowledge, must be done\nabsolutely carefully and conservative, as could see anything executing\nhere.\n\nThat examples this code in ``ExpressionBase`` which every expression by\ndefault uses:\n\n.. code:: python\n\n   def computeExpressionLen(self, len_node, trace_collection):\n       shape = self.getValueShape()\n\n       has_len = shape.hasShapeSlotLen()\n\n       if has_len is False:\n           return makeRaiseTypeErrorExceptionReplacementFromTemplateAndValue(\n               template=\"object of type '%s' has no len()\",\n               operation=\"len\",\n               original_node=len_node,\n               value_node=self,\n           )\n       elif has_len is True:\n           iter_length = self.getIterationLength()\n\n           if iter_length is not None:\n               from .ConstantRefNodes import makeConstantRefNode\n\n               result = makeConstantRefNode(\n                   constant=int(iter_length),  # make sure to downcast long\n                   source_ref=len_node.getSourceReference(),\n               )\n\n               result = wrapExpressionWithNodeSideEffects(new_node=result, old_node=self)\n\n               return (\n                   result,\n                   \"new_constant\",\n                   \"Predicted 'len' result from value shape.\",\n               )\n\n       self.onContentEscapes(trace_collection)\n\n       # Any code could be run, note that.\n       trace_collection.onControlFlowEscape(self)\n\n       # Any exception may be raised.\n       trace_collection.onExceptionRaiseExit(BaseException)\n\n       return len_node, None, None\n\nNotice how by default, known ``__len__`` but unpredictable or even\nunknown if a ``__len__`` slot is there, the code indicates that its\ncontents and the control flow escapes (could change things behind out\nback) and any exception could happen.\n\nOther expressions can know better, e.g. for compile time constants we\ncan be a whole lot more certain:\n\n.. code:: python\n\n   def computeExpressionLen(self, len_node, trace_collection):\n       return trace_collection.getCompileTimeComputationResult(\n           node=len_node,\n           computation=lambda: len(self.getCompileTimeConstant()),\n           description=\"\"\"Compile time constant len value pre-computed.\"\"\",\n       )\n\nIn this case, we are using a function that will produce a concrete value\nor the exception that the ``computation`` function raised. In this case,\nwe can let the Python interpreter that runs Nuitka do all the hard work.\nThis lives in ``CompileTimeConstantExpressionBase`` and is the base for\nall kinds of constant values, or even built-in references like the name\n``len`` itself and would be used in case of doing ``len(len)`` which\nobviously gives an exception.\n\nOther overloads do not currently exist in Nuitka, but through the\niteration length, most cases could be addressed, e.g. ``list`` nodes\ntypical know their element counts.\n\nThe C side\n==========\n\nWhen a slot is not optimized away at compile time however, we need to\ngenerate actual code for it. We figure out what this could be by looking\nat the original CPython implementation.\n\n.. code:: C\n\n   PyObject *builtin_len(PyObject *self, PyObject *v) {\n       Py_ssize_t res;\n\n       res = PyObject_Size(v);\n       if (res < 0 && PyErr_Occurred())\n           return NULL;\n       return PyInt_FromSsize_t(res);\n   }\n\nWe find a pointer to ``PyObject_Size`` which is a generic Python C/API\nfunction used in the ``builtin_len`` implementation:\n\n.. code:: C\n\n   Py_ssize_t PyObject_Size(PyObject *o) {\n       PySequenceMethods *m;\n\n       if (o == NULL) {\n           null_error();\n           return -1;\n       }\n\n       m = o->ob_type->tp_as_sequence;\n       if (m && m->sq_length)\n           return m->sq_length(o);\n\n       return PyMapping_Size(o);\n   }\n\nOn the C level, every Python object (the ``PyObject *``) as a type named\n``ob_type`` and most of its elements are slots. Sometimes they form a\ngroup, here ``tp_as_sequence`` and then it may or may not contain a\nfunction. This one is tried in preference. Then, if that fails, next up\nthe mapping size is tried.\n\n.. code:: C\n\n   Py_ssize_t PyMapping_Size(PyObject *o) {\n       PyMappingMethods *m;\n\n       if (o == NULL) {\n           null_error();\n           return -1;\n       }\n\n       m = o->ob_type->tp_as_mapping;\n       if (m && m->mp_length)\n           return m->mp_length(o);\n\n       type_error(\"object of type '%.200s' has no len()\", o);\n       return -1;\n   }\n\nThis is the same principle, except with ``tp_as_mapping`` and\n``mp_length`` used.\n\nSo from this, we can tell how ``len`` gets at what could be a Python\nclass ``__len__`` or other built-in types.\n\nIn principle, every slot needs to be dealt with in Nuitka, and it is\nassumed that currently all slots are supported on at least a very\ndefensive level, to avoid unnoticed escapes of control flow.\n\nBuilt-in call optimization\n==========================\n\nFor calls to built-in names, there is typically a function in Python\nthat delegates to the type constructor (e.g. when we talk about ``int``\nthat just creates an object passing the arguments of the call) or its\nown special implementation as we saw with the ``len``.\n\nFor each built-in called, we have a specialized node, that presents to\noptimization the actions of the built-in. What are the impact, what are\nthe results. We have seen the resulting example for ``len`` above, but\nhow do we get there.\n\nIn Python, built-in names are used only if there is no module level\nvariable of the name, and of course no local variable of that name.\n\nTherefore, optimization of a built-in name is only done if it turns out\nthe actually assigned in other code, and then when the call comes,\narguments are checked and a relatively static node is created.\n\nCode Generation towards C\n=========================\n\nCurrently, Nuitka uses Pure C and no C++ patterns at all. The use of C11\nrequires on some platforms to compile the C11 using a C++ compiler,\nwhich works relatively well, but also limits the amount of C11 that can\nbe used.\n\nExceptions\n----------\n\nTo handle and work with exceptions, every construct that can raise has\neither a ``bool`` or ``int`` return code or ``PyObject *`` with ``NULL``\nreturn value. This is very much in line with that the Python C-API does.\n\nEvery helper function that contains code that might raise needs these\nvariables. After a failed call, our variant of ``PyErr_Fetch`` called\n``FETCH_ERROR_OCCURRED_STATE`` must be used to catch the defined error,\nunless some quick exception cases apply. The quick exception means,\n``NULL`` return from C-API without a set exception means e.g.\n``StopIteration``.\n\nAs an optimization, functions that raise exceptions, but are known not\nto do so, for whatever reason, could only be asserted to not do so.\n\nStatement Temporary Variables\n-----------------------------\n\nFor statements and larger constructs the context object track temporary\nvalues, that represent references. For some, these should be released at\nthe end of the statement, or they represent a leak.\n\nThe larger scope temporary variables, are tracked in the function or\nmodule context, where they are supposed to have explicit ``del`` to\nrelease their references.\n\nLocal Variables Storage\n-----------------------\n\nClosure variables taken are to be released when the function object is\nlater destroyed. For in-lined calls, variables are just passed, and it\ndoes not become an issue to release anything.\n\nFor function exit, owned variables, local or shared to other functions,\nmust be released. This cannot be a ``del`` operation, as it also\ninvolves setting a value, which would be wrong for shared variables (and\nwasteful to local variables, as that would be its last usage). Therefore\nwe need a special operation that simply releases the reference to the\ncell or object variable.\n\nExit Targets\n------------\n\nEach error or other exit releases statement temporary values and then\nexecutes a ``goto`` to the exit target. These targets need to be setup.\nThe ``try``/``except`` will e.g. catch error exits.\n\nOther exits are ``continue``, ``break``, and ``return`` exits. They all\nwork alike.\n\nGenerally, the exits stack of with constructs that need to register\nthemselves for some exit types. A loop e.g. registers the ``continue``\nexit, and a contained ``try``/``finally`` too, so it can execute the\nfinal code should it be needed.\n\nFrames\n------\n\nFrames are containers for variable declarations and cleanups. As such,\nframes provide error exits and success exits, which remove the frame\nfrom the frame stack, and then proceed to the parent exit.\n\nWith the use of non ``PyObject **`` C types, but frame exception exits,\nthe need to convert those types becomes apparent. Exceptions should\nstill resolve the C version. When using different C types at frame\nexception exits, there is a need to trace the active type, so it can be\nused in the correct form.\n\nAbortive Statements\n-------------------\n\nThe way ``try``/``finally`` is handled, copies of the ``finally`` block\nare made, and optimized independently for each abort method. The ones\nthere are of course, ``return``, ``continue``, and ``break``, but also\nimplicit and explicit ``raise`` of an exception.\n\nCode trailing an abortive statement can be discarded, and the control\nflow will follow these \"exits\".\n\nConstant Preparation\n====================\n\nEarly versions of Nuitka, created all constants for the whole program\nfor ready access to generated code, before the program launches. It did\nso in a single file, but that approach didn't scale well.\n\nProblems were\n\n-  Even unused code contributed to start-up time, this can become a lot\n   for large programs, especially in standalone mode.\n\n-  The massive amount of constant creation codes gave backend C\n   compilers a much harder time than necessary to analyse it all at\n   once.\n\nThe current approach is as follows. Code generation detects constants\nused in only one module, and declared ``static`` there, if the module is\nthe only user, or ``extern`` if it is not. Some values are forced to be\nglobal, as they are used pre-main or in helpers.\n\nThese ``extern`` values are globally created before anything is used.\nThe ``static`` values are created when the module is loaded, i.e.\nsomething did import it.\n\nWe trace used constants per module, and for nested ones, we also\nassociate them. The global constants code is special in that it can only\nuse ``static`` for nested values it exclusively uses, and has to export\nvalues that others use.\n\nLanguage Conversions to make things simpler\n===========================================\n\nThere are some cases, where the Python language has things that can in\nfact be expressed in a simpler or more general way, and where we choose\nto do that at either tree building or optimization time.\n\nThe ``assert`` statement\n------------------------\n\nThe ``assert`` statement is a special statement in Python, allowed by\nthe syntax. It has two forms, with and without a second argument. The\nlater is probably less known, as is the fact that raise statements can\nhave multiple arguments too.\n\nThe handling in Nuitka is:\n\n.. code:: python\n\n   assert value\n   # Absolutely the same as:\n   if not value:\n       raise AssertionError\n\n.. code:: python\n\n   assert value, raise_arg\n   # Absolutely the same as:\n   if not value:\n       raise AssertionError(raise_arg)\n\nThis makes assertions absolutely the same as a raise exception in a\nconditional statement.\n\nThis transformation is performed at tree building already, so Nuitka\nnever knows about ``assert`` as an element and standard optimizations\napply. If e.g. the truth value of the assertion can be predicted, the\nconditional statement will have the branch statically executed or\nremoved.\n\nThe \"comparison chain\" expressions\n----------------------------------\n\nIn Nuitka we have the concept of an outline, and therefore we can make\nthe following re-formulation instead:\n\n.. code:: python\n\n   a < b() > c < d\n\n\n   def _comparison_chain():  # So called \"outline\" function\n       tmp_a = a\n       tmp_b = b()\n\n       tmp = tmp_a < tmp_b\n\n       if not tmp:\n           return tmp\n\n       del tmp_a\n       tmp_c = c\n\n       tmp = tmp_b > tmp_c\n\n       if not tmp:\n           return tmp\n\n       del tmp_b\n\n       return tmp_c < d\n\n\n   _comparison_chain()\n\nThis transformation is performed at tree building already. The temporary\nvariables keep the value for the use of the same expression. Only the\nlast expression needs no temporary variable to keep it.\n\nWhat we got from this, is making the checks of the comparison chain\nexplicit and comparisons in Nuitka to be internally always about two\noperands only.\n\nThe ``execfile`` built-in\n-------------------------\n\nHandling is:\n\n.. code:: python\n\n   execfile(filename)\n   # Basically the same as:\n   exec(compile(open(filename).read()), filename, \"exec\")\n\n.. note::\n\n   This allows optimizations to discover the file opening nature easily\n   and apply file embedding or whatever we will have there one day.\n\nThis transformation is performed when the ``execfile`` built-in is\ndetected as such during optimization.\n\nGenerator expressions with ``yield``\n------------------------------------\n\nThese are converted at tree building time into a generator function body\nthat yields from the iterator given, which is the put into a for loop to\niterate, created a lambda function of and then called with the first\niterator.\n\nThat eliminates the generator expression for this case. It's a bizarre\nconstruct and with this trick needs no special code generation.\n\nThis is a complex example, demonstrating multiple cases of yield in\nunexpected cases:\n\n.. code:: python\n\n   x = ((yield i) for i in (1, 2) if not (yield))\n   # Basically the same as:\n   def x():\n       for i in (1, 2):\n           if not (yield):\n               yield (yield i)\n\nFunction Decorators\n-------------------\n\nWhen one learns about decorators, you see that:\n\n.. code:: python\n\n   @decorator\n   def function():\n       pass\n\n\n   # Is basically the same as:\n   def function():\n       pass\n\n\n   function = decorator(function)\n\nThe only difference is the assignment to function. In the ``@decorator``\ncase, if the decorator fails with an exception, the name ``function`` is\nnot assigned yet, but kept in a temporary variable.\n\nTherefore in Nuitka this assignment is more similar to that of a lambda\nexpression, where the assignment to the name is only at the end, which\nalso has the extra benefit of not treating real function and lambda\nfunctions any different.\n\nThis removes the need for optimization and code generation to support\ndecorators at all. And it should make the two variants optimize equally\nwell.\n\nFunctions nested arguments\n--------------------------\n\nNested arguments are a Python2 only feature supported by Nuitka.\nConsider this example:\n\n.. code:: python\n\n   def function(a, (b, c)):\n       return a, b, c\n\nWe solve this, by kind of wrapping the function with another function\nthat does the unpacking and gives the errors that come from this:\n\n.. code:: python\n\n   def function(a, _1):\n       def _tmp(a, b, c):\n           return a, b, c\n\n       a, b = _1\n       return _tmp(a, b, c)\n\nThe ``.1`` is the variable name used by CPython internally, and actually\nworks if you use keyword arguments via star dictionary. So this is very\ncompatible and actually the right kind of re-formulation, but it removes\nthe need from the code that does parameter parsing to deal with these.\n\nObviously, there is no frame for ``_tmp``, just one for ``function`` and\nwe do not use local variables, but temporary functions.\n\nIn-place Assignments\n--------------------\n\nIn-place assignments are re-formulated to an expression using temporary\nvariables.\n\nThese are not as much a reformulation of ``+=`` to ``+``, but instead\none which makes it explicit that the assign target may change its value.\n\n.. code:: python\n\n   a += b\n\n.. code:: python\n\n   _tmp = a.__iadd__(b)\n\n   if a is not _tmp:\n       a = _tmp\n\nUsing ``__iadd__`` here to express that for the ``+``, the in-place\nvariant ``iadd`` is used instead. The ``is`` check may be optimized away\ndepending on type and value knowledge later on.\n\nComplex Assignments\n-------------------\n\nComplex assignments are defined as those with multiple targets to assign\nfrom a single source and are re-formulated to such using a temporary\nvariable and multiple simple assignments instead.\n\n.. code:: python\n\n   a = b = c\n\n.. code:: python\n\n   _tmp = c\n   a = _tmp\n   b = _tmp\n   del _tmp\n\nThis is possible, because in Python, if one assignment fails, it can\njust be interrupted, so in fact, they are sequential, and all that is\nrequired is to not calculate ``c`` twice, which the temporary variable\ntakes care of. Were ``b`` a more complex expression, e.g.\n``b.some_attribute`` that might raise an exception, ``a`` would still be\nassigned.\n\nUnpacking Assignments\n---------------------\n\nUnpacking assignments are re-formulated to use temporary variables as\nwell.\n\n.. code:: python\n\n   a, b.attr, c[ind] = d = e, f, g = h()\n\nBecomes this:\n\n.. code:: python\n\n   _tmp = h()\n\n   _iter1 = iter(_tmp)\n   _tmp1 = unpack(_iter1, 3)\n   _tmp2 = unpack(_iter1, 3)\n   _tmp3 = unpack(_iter1, 3)\n   unpack_check(_iter1)\n   a = _tmp1\n   b.attr = _tmp2\n   c[ind] = _tmp3\n   d = _tmp\n   _iter2 = iter(_tmp)\n   _tmp4 = unpack(_iter2, 3)\n   _tmp5 = unpack(_iter2, 3)\n   _tmp6 = unpack(_iter2, 3)\n   unpack_check(_iter1)\n   e = _tmp4\n   f = _tmp5\n   g = _tmp6\n\nThat way, the unpacking is decomposed into multiple simple statements.\nIt will be the job of optimizations to try and remove unnecessary\nunpacking, in case e.g. the source is a known tuple or list creation.\n\n.. note::\n\n   The ``unpack`` is a special node which is a form of ``next`` that\n   will raise a ``ValueError`` when it cannot get the next value, rather\n   than a ``StopIteration``. The message text contains the number of\n   values to unpack, therefore the integer argument.\n\n.. note::\n\n   The ``unpack_check`` is a special node that raises a ``ValueError``\n   exception if the iterator is not finished, i.e. there are more values\n   to unpack. Again the number of values to unpack is provided to\n   construct the error message.\n\nWith Statements\n---------------\n\nThe ``with`` statements are re-formulated to use temporary variables as\nwell. The taking and calling of ``__enter__`` and ``__exit__`` with\narguments, is presented with standard operations instead. The promise to\ncall ``__exit__`` is fulfilled by ``try``/``except`` clause instead.\n\n.. code:: python\n\n   with some_context as x:\n       something(x)\n\n.. code:: python\n\n   tmp_source = some_context\n\n   # Actually it needs to be \"special look-up\" for Python2.7, so attribute\n   # look-up won't be exactly what is there.\n   tmp_exit = tmp_source.__exit__\n\n   # This one must be held for the whole with statement, it may be assigned\n   # or not, in our example it is. If an exception occurs when calling\n   # ``__enter__``, the ``__exit__`` should not be called.\n   tmp_enter_result = tmp_source.__enter__()\n\n   # Indicator variable to know if \"tmp_exit\" has been called.\n   tmp_indicator = False\n\n   try:\n       # Now the assignment is to be done, if there is any name for the\n       # manager given, this may become multiple assignment statements and\n       # even unpacking ones.\n       x = tmp_enter_result\n\n       # Then the code of the \"with\" block.\n       something(x)\n   except Exception:\n       # Note: This part of the code must not set line numbers, which we\n       # indicate with special source code references, which we call \"internal\".\n       # Otherwise the line of the frame would get corrupted.\n\n       tmp_indicator = True\n\n       if not tmp_exit(*sys.exc_info()):\n           raise\n   finally:\n       if not tmp_indicator:\n           # Call the exit if no exception occurred with all arguments\n           # as \"None\".\n           tmp_exit(None, None, None)\n\n.. note::\n\n   We don't refer really to ``sys.exc_info()`` at all, instead, we have\n   fast references to the current exception type, value and trace, taken\n   directly from the caught exception object on the C level.\n\n   If we had the ability to optimize ``sys.exc_info()`` to do that, we\n   could use the same transformation, but right now we don't have it.\n\nFor Loops\n---------\n\nThe ``for`` loops use normal assignments and handle the iterator that is\nimplicit in the code explicitly.\n\n.. code:: python\n\n   for x, y in iterable:\n       if something(x):\n           break\n   else:\n       otherwise()\n\nThis is roughly equivalent to the following code:\n\n.. code:: python\n\n   _iter = iter(iterable)\n   _no_break_indicator = False\n\n   while 1:\n       try:\n           _tmp_value = next(_iter)\n       except StopIteration:\n           # Set the indicator that the else branch may be executed.\n           _no_break_indicator = True\n\n           # Optimization should be able to tell that the else branch is run\n           # only once.\n           break\n\n       # Normal assignment re-formulation applies to this assignment of course.\n       x, y = _tmp_value\n       del _tmp_value\n\n       if something(x):\n           break\n\n   if _no_break_indicator:\n       otherwise()\n\n.. note::\n\n   The ``_iter`` temporary variable is of course also in a\n   ``try/finally`` construct, to make sure it releases after its used.\n   The ``x, y`` assignment is of course subject to unpacking\n   re-formulation.\n\n   The ``try``/``except`` is detected to allow to use a variant of\n   ``next`` that does not raise an exception, but to be fast check about\n   the ``NULL`` return from ``next`` built-in. So no actual exception\n   handling is happening in this case.\n\nWhile Loops\n-----------\n\nQuoting the ``nuitka.tree.ReformulationWhileLoopStatements``\ndocumentation:\n\nReformulation of while loop statements.\n\nLoops in Nuitka have no condition attached anymore, so while loops are\nre-formulated like this:\n\n.. code:: python\n\n   while condition:\n       something()\n\n.. code:: python\n\n   while 1:\n       if not condition:\n           break\n\n       something()\n\nThis is to totally remove the specialization of loops, with the\ncondition moved to the loop body in an initial conditional statement,\nwhich contains a ``break`` statement.\n\nThat achieves, that only ``break`` statements exit the loop, and allow\nfor optimization to remove always true loop conditions, without\nconcerning code generation about it, and to detect such a situation,\nconsider e.g. endless loops.\n\n.. note::\n\n   Loop analysis (not yet done) can then work on a reduced problem\n   (which ``break`` statements are executed under what conditions) and\n   is then automatically very general.\n\n   The fact that the loop body may not be entered at all, is still\n   optimized, but also in the general sense. Explicit breaks at the loop\n   start and loop conditions are the same.\n\nEnd quoting the ``nuitka.tree.ReformulationWhileLoopStatements``\ndocumentation:\n\nException Handlers\n------------------\n\nException handlers in Python may assign the caught exception value to a\nvariable in the handler definition. And the different handlers are\nrepresented as conditional checks on the result of comparison\noperations.\n\n.. code:: python\n\n   try:\n       block()\n   except A as e:\n       handlerA(e)\n   except B as e:\n       handlerB(e)\n   else:\n       handlerElse()\n\n.. code:: python\n\n   try:\n       block()\n   except:\n       # These are special nodes that access the exception, and don't really\n       # use the \"sys\" module.\n       tmp_exc_type = sys.exc_info()[0]\n       tmp_exc_value = sys.exc_info()[1]\n\n       # exception_matches is a comparison operation, also a special node.\n       if exception_matches(tmp_exc_type, (A,)):\n           e = tmp_exc_value\n           handlerA(e)\n       elif exception_matches(tmp_exc_type, (B,)):\n           e = tmp_exc_value\n           handlerB(e)\n       else:\n           handlerElse()\n\nFor Python3, the assigned ``e`` variables get deleted at the end of the\nhandler block. Should that value be already deleted, that ``del`` does\nnot raise, therefore it's tolerant. This has to be done in any case, so\nfor Python3 it is even more complex.\n\n.. code:: python\n\n   try:\n       block()\n   except:\n       # These are special nodes that access the exception, and don't really\n       # use the \"sys\" module.\n       tmp_exc_type = sys.exc_info()[0]\n       tmp_exc_value = sys.exc_info()[1]\n\n       # exception_matches is a comparison operation, also a special node.\n       if exception_matches(tmp_exc_type, (A,)):\n           try:\n               e = tmp_exc_value\n               handlerA(e)\n           finally:\n               del e\n       elif exception_matches(tmp_exc_type, (B,)):\n           try:\n               e = tmp_exc_value\n               handlerB(e)\n           finally:\n               del e\n       else:\n           handlerElse()\n\nShould there be no ``else:`` branch, a default re-raise statement is\nused instead.\n\nAnd of course, the values of the current exception type and value, both\nuse special references, that access the C++ and don't go via\n``sys.exc_info`` at all, nodes called ``CaughtExceptionTypeRef`` and\n``CaughtExceptionValueRef``.\n\nThis means, that the different handlers and their catching run time\nbehavior are all explicit and reduced the branches.\n\nStatement ``try``/``except`` with ``else``\n------------------------------------------\n\nMuch like ``else`` branches of loops, an indicator variable is used to\nindicate the entry into any of the exception handlers.\n\nTherefore, the ``else`` becomes a real conditional statement in the node\ntree, checking the indicator variable and guarding the execution of the\n``else`` branch.\n\nClass Creation (Python2)\n------------------------\n\nClasses in Python2 have a body that only serves to build the class\ndictionary and is a normal function otherwise. This is expressed with\nthe following re-formulation:\n\n.. code:: python\n\n   # in module \"SomeModule\"\n   # ...\n\n\n   class SomeClass(SomeBase, AnotherBase):\n       \"\"\" This is the class documentation. \"\"\"\n\n       some_member = 3\n\n.. code:: python\n\n   def _makeSomeClass():\n       # The module name becomes a normal local variable too.\n       __module__ = \"SomeModule\"\n\n       # The doc string becomes a normal local variable.\n       __doc__ = \"\"\" This is the class documentation. \"\"\"\n\n       some_member = 3\n\n       return locals()\n\n       # force locals to be a writable dictionary, will be optimized away, but\n       # that property will stick. This is only to express, that locals(), where\n       # used will be writable to.\n       exec(\"\")\n\n\n   SomeClass = make_class(\"SomeClass\", (SomeBase, AnotherBase), _makeSomeClass())\n\nThat is roughly the same, except that ``_makeSomeClass`` is *not*\nvisible to its child functions when it comes to closure taking, which we\ncannot express in Python language at all.\n\nTherefore, class bodies are just special function bodies that create a\ndictionary for use in class creation. They don't really appear after the\ntree building stage anymore. The type inference will of course have to\nbecome able to understand ``make_class`` quite well, so it can recognize\nthe created class again.\n\nClass Creation (Python3)\n------------------------\n\nIn Python3, classes are a complicated way to write a function call, that\ncan interact with its body. The body starts with a dictionary provided\nby the metaclass, so that is different, because it can ``__prepare__`` a\nnon-empty locals for it, which is hidden away in \"prepare_class_dict\"\nbelow.\n\nWhat's noteworthy, is that this dictionary, could e.g. be an\n``OrderDict``. I am not sure, what ``__prepare__`` is allowed to return.\n\n.. code:: python3\n\n   # in module \"SomeModule\"\n   # ...\n\n   class SomeClass(SomeBase, AnotherBase, metaclass = SomeMetaClass):\n       \"\"\" This is the class documentation. \"\"\"\n\n       some_member = 3\n\n.. code:: python\n\n   # Non-keyword arguments, need to be evaluated first.\n   tmp_bases = (SomeBase, AnotherBase)\n\n   # Keyword arguments go next, __metaclass__ is just one of them. In principle\n   # we need to forward the others as well, but this is ignored for the sake of\n   # brevity.\n   tmp_metaclass = select_metaclass(tmp_bases, SomeMetaClass)\n\n   tmp_prepared = tmp_metaclass.__prepare__(\"SomeClass\", tmp_bases)\n\n   # The function that creates the class dictionary. Receives temporary variables\n   # to work with.\n   def _makeSomeClass():\n       # This has effect, currently I don't know how to express that in Python3\n       # syntax, but we will have a node that does that.\n       locals().replace(tmp_prepared)\n\n       # The module name becomes a normal local variable too.\n       __module__ = \"SomeModule\"\n\n       # The doc string becomes a normal local variable.\n       __doc__ = \"\"\" This is the class documentation. \"\"\"\n\n       some_member = 3\n\n       # Create the class, share the potential closure variable \"__class__\"\n       # with others.\n       __class__ = tmp_metaclass(\"SomeClass\", tmp_bases, locals())\n\n       return __class__\n\n\n   # Build and assign the class.\n   SomeClass = _makeSomeClass()\n\nGenerator Expressions\n---------------------\n\nThere are re-formulated as functions.\n\nGenerally they are turned into calls of function bodies with\n(potentially nested) for loops:\n\n.. code:: python\n\n   gen = (x * 2 for x in range(8) if cond())\n\n.. code:: python\n\n   def _gen_helper(__iterator):\n       for x in __iterator:\n           if cond():\n               yield x * 2\n\n\n   gen = _gen_helper(range(8))\n\nList Contractions\n-----------------\n\nThe list contractions of Python2 are different from those of Python3, in\nthat they don't actually do any closure variable taking, and that no\nfunction object ever exists.\n\n.. code:: python\n\n   list_value = [x * 2 for x in range(8) if cond()]\n\n.. code:: python\n\n   def _listcontr_helper(__iterator):\n       result = []\n\n       for x in __iterator:\n           if cond():\n               result.append(x * 2)\n\n       return result\n\n\n   list_value = _listcontr_helper(range(8))\n\nThe difference is that with Python3, the function \"_listcontr_helper\" is\nreally there and named ``<listcontraction>`` (or ``<listcomp>`` as of\nPython3.7 or higher), whereas with Python2 the function is only an\noutline, so it can readily access the containing name space.\n\nSet Contractions\n----------------\n\nThe set contractions of Python2.7 are like list contractions in Python3,\nin that they produce an actual helper function:\n\n.. code:: python\n\n   set_value = {x * 2 for x in range(8) if cond()}\n\n.. code:: python\n\n   def _setcontr_helper(__iterator):\n       result = set()\n\n       for x in __iterator:\n           if cond():\n               result.add(x * 2)\n\n       return result\n\n\n   set_value = _setcontr_helper(range(8))\n\nDictionary Contractions\n-----------------------\n\nThe dictionary contractions of are like list contractions in Python3, in\nthat they produce an actual helper function:\n\n.. code:: python\n\n   dict_value = {x: x * 2 for x in range(8) if cond()}\n\n.. code:: python\n\n   def _dictcontr_helper(__iterator):\n       result = {}\n\n       for x in __iterator:\n           if cond():\n               result[x] = x * 2\n\n       return result\n\n\n   set_value = _dictcontr_helper(range(8))\n\nBoolean expressions ``and`` and ``or``\n--------------------------------------\n\nThe short circuit operators ``or`` and ``and`` tend to be only less\ngeneral that the ``if``/``else`` expressions, but have dedicated nodes.\nWe used to have a re-formulation towards those, but we now do these via\ndedicated nodes too.\n\nThese new nodes, present the evaluation of the left value, checking for\nits truth value, and depending on it, to pick it, or use the right\nvalue.\n\nSimple Calls\n------------\n\nAs seen below, even complex calls are simple calls. In simple calls of\nPython there is still some hidden semantic going on, that we expose.\n\n.. code:: python\n\n   func(arg1, arg2, named1=arg3, named2=arg4)\n\nOn the C-API level there is a tuple and dictionary built. This one is\nexposed:\n\n.. code:: python\n\n   func(*(arg1, arg2), **{\"named1\": arg3, \"named2\": arg4})\n\nA called function will access this tuple and the dictionary to parse the\narguments, once that is also re-formulated (argument parsing), it can\nthen lead to simple in-lining. This way calls only have 2 arguments with\nconstant semantics, that fits perfectly with the C-API where it is the\nsame, so it is actually easier for code generation.\n\nAlthough the above looks like a complex call, it actually is not. No\nchecks are needed for the types of the star arguments and it's directly\ntranslated to ``PyObject_Call``.\n\nComplex Calls\n-------------\n\nThe call operator in Python allows to provide arguments in 4 forms.\n\n-  Positional (or normal) arguments\n\n-  Named (or keyword) arguments\n\n-  Star list arguments\n\n-  Star dictionary arguments\n\nThe evaluation order is precisely that. An example would be:\n\n.. code:: python\n\n   something(pos1, pos2, name1=named1, name2=named2, *star_list, **star_dict)\n\nThe task here is that first all the arguments are evaluated, left to\nright, and then they are merged into only two, that is positional and\nnamed arguments only. for this, the star list argument and the star\ndictionary arguments, are merged with the positional and named\narguments.\n\nWhat's peculiar, is that if both the star list and dictionary arguments\nare present, the merging is first done for star dictionary, and only\nafter that for the star list argument. This makes a difference, because\nin case of an error, the star argument raises first.\n\n.. code:: python\n\n   something(*1, **2)\n\nThis raises \"TypeError: something() argument after ** must be a mapping,\nnot int\" as opposed to a possibly more expected \"TypeError: something()\nargument after * must be a sequence, not int.\"\n\nThat doesn't matter much though, because the value is to be evaluated\nfirst anyway, and the check is only performed afterwards. If the star\nlist argument calculation gives an error, this one is raised before\nchecking the star dictionary argument.\n\nSo, what we do, is we convert complex calls by the way of special\nfunctions, which handle the dirty work for us. The optimization is then\ntasked to do the difficult stuff. Our example becomes this:\n\n.. code:: python\n\n   def _complex_call(called, pos, kw, star_list_arg, star_dict_arg):\n       # Raises errors in case of duplicate arguments or tmp_star_dict not\n       # being a mapping.\n       tmp_merged_dict = merge_star_dict_arguments(\n           called, tmp_named, mapping_check(called, tmp_star_dict)\n       )\n\n       # Raises an error if tmp_star_list is not a sequence.\n       tmp_pos_merged = merge_pos_arguments(called, tmp_pos, tmp_star_list)\n\n       # On the C-API level, this is what it looks like.\n       return called(*tmp_pos_merged, **tmp_merged_dict)\n\n\n   returned = _complex_call(\n       called=something,\n       pos=(pos1, pos2),\n       named={\"name1\": named1, \"name2\": named2},\n       star_list_arg=star_list,\n       star_dict_arg=star_dict,\n   )\n\nThe call to ``_complex_call`` is be a direct function call with no\nparameter parsing overhead. And the call in its end, is a special call\noperation, which relates to the ``PyObject_Call`` C-API.\n\nAssignment Expressions\n----------------------\n\nIn Python 3.8 or higher, you assign inside expressions.\n\n.. code:: python\n\n   if (x := cond()):\n      do_something()\n\nthis is the same as:\n\n.. code:: python\n\n   # Doesn't exist with that name, and it is not really taking closure variables,\n   # it just shares the execution context.\n   def _outline_func():\n      nonlocal x\n      x = cond()\n\n      return x\n\n   if (_outline_func()):\n      do_something\n\nWhen we use this outline function, we are allowed statements, even\nassignments, in expressions. For optimization, they of course pose a\nchallenge to be removed ever, only happens when it becomes only a return\nstatement, but they do not cause much difficulties for code generation,\nsince they are transparent.\n\nMatch Statements\n----------------\n\nIn Python 3.10 or higher, you can write so called ``match`` statements\nlike this:\n\n.. code:: python\n\n   match something():\n       case [x] if x:\n           z = 2\n       case _ as y if y == x and y:\n           z = 1\n       case 0:\n           z = 0\n\nThis is the same as\n\n.. code:: python\n\n   tmp_match_subject = something()\n\n   # Indicator variable, once true, all matching stops.\n   tmp_handled = False\n\n   # First branch\n   x = tmp_match_subject\n\n   if sequence_check(x)\n      if x:\n         z = 2\n         tmp_handled = True\n\n   if tmp_handled is False:\n      y = tmp_match_subject\n\n      if x == y and y:\n         z = 1\n         tmp_handled = True\n\n   if tmp_handled is False:\n      z = 0\n\nPrint Statements\n----------------\n\nThe ``print`` statement exists only in Python2. It implicitly converts\nits arguments to strings before printing them. In order to make this\naccessible and compile time optimized, this is made visible in the node\ntree.\n\n.. code:: python\n\n   print arg1, \"1\", 1\n\nThis is in Nuitka converted so that the code generation for ``print``\ndoesn't do any conversions itself anymore and relies on the string\nnature of its input.\n\n.. code:: python\n\n   print str(arg1), \"1\", str(1)\n\nOnly string objects are spared from the ``str`` built-in wrapper,\nbecause that would only cause noise in optimization stage. Later\noptimization can then find it unnecessary for certain arguments.\n\nAdditionally, each ``print`` may have a target, and multiple arguments,\nwhich we break down as well for dumber code generation. The target is\nevaluated first and should be a file, kept referenced throughout the\nwhole print statement.\n\n.. code:: python\n\n   print >> target_file, str(arg1), \"1\", str(1)\n\nThis is being reformulated to:\n\n.. code:: python\n\n   try:\n      tmp_target = target_file\n\n      print >>tmp_target, str(arg1), print >>tmp_target, \"1\", print\n      >>tmp_target, str(1), print >>tmp_target\n\n   finally:\n      del tmp_target\n\nThis allows code generation to not deal with arbitrary amount of\narguments to ``print``. It also separates the newline indicator from the\nrest of things, which makes sense too, having it as a special node, as\nit's behavior with regards to soft-space is different of course.\n\nAnd finally, for ``print`` without a target, we still assume that a\ntarget was given, which would be ``sys.stdout`` in a rather hard-coded\nway (no variable look-ups involved).\n\nReformulations during Optimization\n==================================\n\nBuiltin ``zip`` for Python2\n---------------------------\n\n.. code:: python\n\n   def _zip(a, b, c):  # Potentially more arguments.\n      # First assign, to preserve the order of execution, the arguments might be\n      # complex expressions with side effects.\n      tmp_arg1 = a\n      tmp_arg2 = b\n      tmp_arg3 = c\n      # could be more\n      ...\n\n      # Creation of iterators goes first.\n      try:\n         tmp_iter_1 = iter(tmp_arg1)\n      except TypeError:\n         raise TypeError(\"zip argument #1 must support iteration\")\n      try:\n         tmp_iter_2 = iter(tmp_arg2)\n      except TypeError:\n         raise TypeError(\"zip argument #2 must support iteration\")\n      try:\n         tmp_iter_3 = iter(tmp_arg3)\n      except TypeError:\n         raise TypeError(\"zip argument #3 must support iteration\")\n\n      # could be more\n      ...\n\n      tmp_result = []\n      try:\n         while 1:\n            tmp_result.append(\n                  (\n                     next(tmp_iter_1),\n                     next(tmp_iter_2),\n                     next(tmp_iter_3),\n                     # more arguments here ...\n                  )\n            )\n      except StopIteration:\n         pass\n\n      return tmp_result\n\nBuiltin ``zip`` for Python3\n^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n.. code:: python\n\n   for x, y, z in zip(a, b, c):\n       ...\n\n.. code:: python\n\n   def _zip_gen_object(a, b, c, ...):\n       ...\n       # See Python2\n       ...\n\n      # could be more\n      ...\n      while 1:\n           yield (\n               next(tmp_iter_1),\n               next(tmp_iter_2),\n               next(tmp_iter_3),\n               ...\n           )\n       except StopIteration:\n           break\n\n   for x, y, z in _zip_gen_object(a, b, c):\n       ...\n\nBuiltin ``map`` for Python2\n---------------------------\n\n.. code:: python\n\n   def _map():\n       # TODO: Not done yet.\n       pass\n\nBuiltin ``min``\n---------------\n\n.. code:: python\n\n   # TODO: keyfunc (Python2/3), defaults (Python3)\n   def _min(a, b, c):  # Potentially more arguments.\n       tmp_arg1 = a\n       tmp_arg2 = b\n       tmp_arg3 = c\n       # more arguments here ...\n\n       result = tmp_arg1\n       if keyfunc is None:  # can be decided during re-formulation\n           tmp_key_result = keyfunc(result)\n           tmp_key_candidate = keyfunc(tmp_arg2)\n           if tmp_key_candidate < tmp_key_result:\n               result = tmp_arg2\n               tmp_key_result = tmp_key_candidate\n           tmp_key_candidate = keyfunc(tmp_arg3)\n           if tmp_key_candidate < tmp_key_result:\n               result = tmp_arg3\n               tmp_key_result = tmp_key_candidate\n           # more arguments here ...\n       else:\n           if tmp_arg2 < result:\n               result = tmp_arg2\n           if tmp_arg3 < result:\n               result = tmp_arg3\n           # more arguments here ...\n\n       return result\n\nBuiltin ``max``\n---------------\n\nSee ``min`` just with ``>`` instead of ``<``.\n\nCall to ``dir`` without arguments\n---------------------------------\n\nThis expression is reformulated to ``locals().keys()`` for Python2, and\n``list(locals.keys())`` for Python3.\n\nCalls to functions with known signatures\n----------------------------------------\n\nAs a necessary step for inlining function calls, we need to change calls\nto variable references to function references.\n\n.. code:: python\n\n   def f(arg1, arg2):\n       return some_op(arg1, arg2)\n\n\n   # ... other code\n\n   x = f(a, b + c)\n\nIn the optimization it is turned into\n\n.. code:: python\n\n   # ... other code\n\n   x = lambda arg1, arg2: some_op(arg1, arg2)(a, b + c)\n\n.. note::\n\n   The ``lambda`` stands here for a reference to the function, rather\n   than a variable reference, this is the normal forward propagation of\n   values, and does not imply duplicating or moving any code at all.\n\nAt this point, we still have not resolved the actual call arguments to\nthe variable names, still a Python level function is created, and\ncalled, and arguments are parsed to a tuple, and from a tuple. For\nsimplicity sake, we have left out keyword arguments out of the equation\nfor now, but they are even more costly.\n\nSo now, what we want to do, is to re-formulate the call into what we\ncall an outline body, which is a inline function, and that does the\nparameter parsing already and contains the function code too. In this\ninlining, there still is a function, but it's technically not a Python\nfunction anymore, just something that is an expression whose value is\ndetermined by control flow and the function call.\n\n.. code:: python\n\n   # ... other code\n\n\n   def _f():\n       tmp_arg1 = arg1\n       tmp_arg2 = b + c\n       return tmp_arg1 + tmp_arg2\n\n\n   x = _f()\n\nWith this, a function is considered inlined, because it becomes part of\nthe abstract execution, and the actual code is duplicated.\n\nThe point is, that matching the signature of the function to the actual\narguments given, is pretty straight forward in many cases, but there are\ntwo forms of complications that can happen. One is default values,\nbecause they need to assigned or not, and the other is keyword\narguments, because they allow to reorder arguments.\n\nLet's consider an example with default values first.\n\n.. code:: python\n\n   def f(arg1, arg2=some_default()):\n       return some_op(arg1, arg2)\n\n\n   # ... other code\n\n   x = f(a, b + c)\n\nSince the point, at which defaults are taken, we must execute them at\nthat point and make them available.\n\n.. code:: python\n\n   tmp_defaults = (some_default,)  # that was f.__defaults__\n\n   # ... other code\n\n\n   def _f():\n       tmp_arg1 = arg1\n       tmp_arg2 = tmp_defaults[0]\n       return tmp_arg1 + tmp_arg2\n\n\n   x = _f()\n\nNow, one where keyword arguments are ordered the other way.\n\n.. code:: python\n\n   def f(arg1, arg2):\n       return some_op(arg1, arg2)\n\n\n   # ... other code\n\n   x = f(arg2=b + c, arg1=a)  # \"b+c\" is evaluated before \"a\"\n\nThe solution is an extra level of temporary variables. We remember the\nargument order by names and then assign parameters from it:\n\n.. code:: python\n\n   # ... other code\n\n\n   def _f():\n       tmp_given_value1 = b + c\n       tmp_given_value2 = a\n       tmp_arg1 = tmp_given_value2\n       tmp_arg2 = tmp_given_value1\n       return tmp_arg1 + tmp_arg2\n\n\n   x = _f()\n\nObviously, optimization of Nuitka can decide, that e.g. should ``a`` or\n``b+c`` not have side effects, to optimize these with standard variable\ntracing away.\n\nNodes that serve special purposes\n=================================\n\nTry statements\n--------------\n\nIn Python, there is ``try``/``except`` and ``try``/``finally``. In\nNuitka there is only a ``try``, which then has blocks to handle\nexceptions, ``continue``, or ``break``, or ``return``. There is no\n``else`` to this node type.\n\nThis is more low level and universal. Code for the different handlers\ncan be different. User provided ``finally`` blocks become copied into\nthe different handlers.\n\nReleases\n--------\n\nWhen a function exits, the local variables are to be released. The same\napplies to temporary variables used in re-formulations. These releases\ncause a reference to the object to the released, but no value change.\nThey are typically the last use of the object in the function.\n\nThe are similar to ``del``, but make no value change. For shared\nvariables this effect is most visible.\n\nSide Effects\n------------\n\nWhen an exception is bound to occur, and this can be determined at\ncompile time, Nuitka will not generate the code the leads to the\nexception, but directly just raise it. But not in all cases, this is the\nfull thing.\n\nConsider this code:\n\n.. code:: python\n\n   f(a(), 1 / 0)\n\nThe second argument will create a ``ZeroDivisionError`` exception, but\nbefore that ``a()`` must be executed, but the call to ``f`` will never\nhappen and no code is needed for that, but the name look-up must still\nsucceed. This then leads to code that is internally like this:\n\n.. code:: python\n\n   f(a(), raise_ZeroDivisionError())\n\nwhich is then modeled as:\n\n.. code:: python\n\n   side_effect(a(), f, raise_ZeroDivisionError())\n\nwhere we can consider ``side_effect`` to be a function that returns the\nlast expression. Of course, if this is not part of another expression,\nbut close to statement level, side effects, can be converted to multiple\nstatements simply.\n\nAnother use case, is that the value of an expression can be predicted,\nbut that the language still requires things to happen, consider this:\n\n.. code:: python\n\n   a = len((f(), g()))\n\nWe can tell that ``a`` will be 2, but the call to ``f`` and ``g`` must\nstill be performed, so it becomes:\n\n.. code:: python\n\n   a = side_effects(f(), g(), 2)\n\nModelling side effects explicitly has the advantage of recognizing them\neasily and allowing to drop the call to the tuple building and checking\nits length, only to release it.\n\nCaught Exception Type/Value References\n--------------------------------------\n\nWhen catching an exception, these are not directly put to\n``sys.exc_info()``, but remain as mere C variables. From there, they can\nbe accessed with these nodes, or if published then from the thread\nstate.\n\nHard Module Imports\n-------------------\n\nThese are module look-ups that don't depend on any local variable for\nthe module to be looked up, but with hard-coded names. These may be the\nresult of optimization gaining such level of certainty.\n\nCurrently they are used to represent ``sys.stdout`` usage for ``print``\nstatements, but other usages will follow.\n\nLocals Dict Update Statement\n----------------------------\n\nFor the ``exec`` re-formulation, we apply an explicit sync back to\nlocals as an explicit node. It helps us to tell the affected local\nvariable traces that they might be affected. It represents the bit of\n``exec`` in Python2, that treats ``None`` as the locals argument as an\nindication to copy back.\n\nOptimizing Attribute Lookups into Method Calls for Built-ins types\n==================================================================\n\nThe attribute lookup node ``ExpressionAttributeLookup`` represents\nlooking up an attribute name, that is known to be a string. That's\nalready a bit more special, than say what ``ExpressionBuiltinGetattr``\ndoes for ``getattr``, where it could be any object being looked up. From\nthe Python syntax however, these are what gets created, as it's not\nallowed in any other way. So, this is where this starts.\n\nThen, when we are creating an attribute node with a *fixed* name, we\ndispatch it to generated node classes, e.g.\n``ExpressionAttributeLookupFixedAppend``. This will be the same, except\nthat the attribute name is hardcoded.\n\nThere are generated, such that they can have code that is special for\n``.append`` lookups. In their case, it makes sense to ask the source, if\nthey are a ``list`` object exactly. It doesn't make sense to do this\ncheck for names that the ``list`` does not contain. So at that stage, we\nare saving both a bit of memory and time.\n\nShould this question succeed, i.e. the expression the attribute values\nis looked up upon, is known to be a ``list`` exactly, we persist this\nknowledge in the also generated nodes that represent ``list.append`` and\njust that. It is called ``ExpressionAttributeLookupListAppend`` and only\nrepresents the knowledge gained so far.\n\nWe do not consider if ``ExpressionAttributeLookupFixedAppend`` is\ncalled, or not, passed as an argument, assigned somewhere, it doesn't\nmatter yet, but for ``ExpressionAttributeLookupListAppend`` we know a\nhell of a lot more. We know its type, we know attributes for it, say\n``__name__``, as it is a compile time constant, therefore much\noptimization can follow for them, and code generation can specialize\nthem too (not yet done).\n\nShould these nodes then, and say this happens later after some inlining\nhappens be seen as called, we can then turn them into method call nodes,\nchecking the arguments and such, this is then\n``ExpressionListOperationAppend`` and at this point, will raising errors\nwith wrong argument counts.\n\nAnd then we have this ``ExpressionListOperationAppend`` which will\ninfluence the tracing of ``list`` contents, i.e. it will be able to tell\nthe ``list`` in question is no more empty after this ``append``, and it\nwill be able to at least predict the last element value, truth value of\nthe list, etc.\n\n******************************\n Plan to add \"ctypes\" support\n******************************\n\nAdd interfacing to C code, so Nuitka can turn a ``ctypes`` binding into\nan efficient binding as if it were written manually with Python C-API or\nbetter.\n\nGoals/Allowances to the task\n============================\n\n#. Goal: Must not directly use any pre-existing C/C++ language file\n   headers, only generate declarations in generated C code ourselves. We\n   would rather write or use tools that turn an existing a C header to\n   some ``ctypes`` declarations if it needs to be, but not mix and use\n   declarations from existing header code.\n\n   .. note::\n\n      The \"cffi\" interface maybe won't have the issue, but it's not\n      something we need to write or test the code for.\n\n#. Allowance: May use ``ctypes`` module at compile time to ask things\n   about ``ctypes`` and its types.\n\n#. Goal: Should make use of ``ctypes``, to e.g. not hard code in Nuitka\n   what ``ctypes.c_int()`` gives on the current platform, unless there\n   is a specific benefit.\n\n#. Allowance: Not all ``ctypes`` usages must be supported immediately.\n\n#. Goal: Try and be as general as possible.\n\n   For the compiler, ``ctypes`` support should be hidden behind a\n   generic interface of some sort. Supporting ``math`` module should be\n   the same thing.\n\nType Inference - The Discussion\n===============================\n\nMain initial goal is to forward value knowledge. When you have ``a =\nb``, that means that a and b now \"alias\". And if you know the value of\n``b`` you can assume to know the value of ``a``. This is called\n\"aliasing\".\n\nWhen assigning ``a`` to something new, that won't change ``b`` at all.\nBut when an attribute is set, a method called of it, that might impact\nthe actual value, referenced by both. We need to understand mutable vs.\nimmutable though, as some things are not affected by aliasing in any\nway.\n\n.. code:: python\n\n   a = 3\n   b = a\n\n   b += 4  # a is not changed\n\n   a = [3]\n   b = a\n\n   b += [4]  # a is changed indeed\n\nIf we cannot tell, we must assume that ``a`` might be changed. It's\neither ``b`` or what ``a`` was before. If the type is not mutable, we\ncan assume the aliasing to be broken up, and if it is, we can assume\nboth to be the same value still.\n\nWhen that value is a compile time constant, we will want to push it\nforward, and we do that with \"(Constant) Value Propagation\", which is\nimplemented already. We avoid too large constants, and we properly trace\nvalue assignments, but not yet aliases.\n\nIn order to fully benefit from type knowledge, the new type system must\nbe able to be fully friends with existing built-in types, but for\nclasses to also work with it, it should not be tied to them. The\nbehavior of a type ``long``, ``str``, etc. ought to be implemented as\nfar as possible with the built-in ``long``, ``str`` at compiled time as\nwell.\n\n.. note::\n\n   This \"use the real thing\" concept extends beyond builtin types, e.g.\n   ``ctypes.c_int()`` should also be used, but we must be aware of\n   platform dependencies. The maximum size of ``ctypes.c_int`` values\n   would be an example of that. Of course that may not be possible for\n   everything.\n\n   This approach has well proven itself with built-in functions already,\n   where we use real built-ins where possible to make computations. We\n   have the problem though that built-ins may have problems to execute\n   everything with reasonable compile time cost.\n\nAnother example, consider the following code:\n\n.. code:: python\n\n   len(\"a\" * 1000000000000)\n\nTo predict this code, calculating it at compile time using constant\noperations, while feasible, puts an unacceptable burden on the\ncompilation.\n\nEsp. we wouldn't want to produce such a huge constant and stream it, the\nC++ code would become too huge. So, we need to stop the ``*`` operator\nfrom being used at compile time and cope with reduced knowledge, already\nhere:\n\n.. code:: python\n\n   \"a\" * 10000000000000\n\nInstead, we would probably say that for this expression:\n\n-  The result is a ``str`` or a C level ``PyStringObject *``.\n\n-  We know its length exactly, it's ``10000000000000``.\n\n-  Can predict every of its elements when sub-scripted, sliced, etc., if\n   need be, with a function we may create.\n\nSimilar is true for this horrible (in Python2) thing:\n\n.. code:: python\n\n   range(10000000000000)\n\nSo it's a rather general problem, this time we know:\n\n-  The result is a ``list`` or C level ``PyListObject *``.\n\n-  We know its length exactly, ``10000000000000``.\n\n-  Can predict every of its elements when index, sliced, etc., if need\n   be, with a function.\n\nAgain, we wouldn't want to create the list. Therefore Nuitka avoids\nexecuting these calculation, when they result in constants larger than a\nthreshold of e.g. 256 elements. This concept has to be also applied to\nlarge integers and more CPU and memory traps.\n\nNow lets look at a more complete use case:\n\n.. code:: python\n\n   for x in range(10000000000000):\n       doSomething()\n\nLooking at this example, one traditional way to look at it, would be to\nturn ``range`` into ``xrange``, and to note that ``x`` is unused. That\nwould already perform better. But really better is to notice that\n``range()`` generated values are not used at all, but only the length of\nthe expression matters.\n\nAnd even if ``x`` were used, only the ability to predict the value from\na function would be interesting, so we would use that computation\nfunction instead of having an iteration source. Being able to predict\nfrom a function could mean to have Python code to do it, as well as C\ncode to do it. Then code for the loop can be generated without any\nCPython library usage at all.\n\n.. note::\n\n   Of course, it would only make sense where such calculations are\n   \"O(1)\" complexity, i.e. do not require recursion like \"n!\" does.\n\nThe other thing is that CPython appears to at - run time - take length\nhints from objects for some operations, and there it would help too, to\ntrack length of objects, and provide it, to outside code.\n\nBack to the original example:\n\n.. code:: python\n\n   len(\"a\" * 1000000000000)\n\nThe theme here, is that when we can't compute all intermediate\nexpressions, and we sure can't do it in the general case. But we can\nstill, predict some of properties of an expression result, more or less.\n\nHere we have ``len`` to look at an argument that we know the size of.\nGreat. We need to ask if there are any side effects, and if there are,\nwe need to maintain them of course. This is already done by existing\noptimization if an operation generates an exception.\n\n.. note::\n\n   The optimization of ``len`` has been implemented and works for all\n   kinds of container creation and ranges.\n\nApplying this to \"ctypes\"\n=========================\n\nThe *not so specific* problem to be solved to understand ``ctypes``\ndeclarations is maybe as follows:\n\n.. code:: python\n\n   import ctypes\n\nThis leads to Nuitka in its tree to have an assignment from a\n``__import__`` expression to the variable ``ctypes``. It can be\npredicted by default to be a module object, and even better, it can be\nknown as ``ctypes`` from standard library with more or less certainty.\nSee the section about \"Importing\".\n\nSo that part is \"easy\", and it's what will happen. During optimization,\nwhen the module ``__import__`` expression is examined, it should say:\n\n-  ``ctypes`` is a module\n\n-  ``ctypes`` is from standard library (if it is, might not be true)\n\n-  ``ctypes`` then has code behind it, called ``ModuleFriend`` that\n   knows things about it attributes, that should be asked.\n\nThe later is the generic interface, and the optimization should connect\nthe two, of course via package and module full names. It will need a\n``ModuleFriendRegistry``, from which it can be pulled. It would be nice\nif we can avoid ``ctypes`` to be loaded into Nuitka unless necessary, so\nthese need to be more like a plug-in, loaded only if necessary, i.e. the\nuser code actually uses ``ctypes``.\n\nComing back to the original expression, it also contains an assignment\nexpression, because it re-formulated to be more like this:\n\n.. code:: python\n\n   ctypes = __import__(\"ctypes\")\n\nThe assigned to object, simply gets the type inferred propagated as part\nof an SSA form. Ideally, we could be sure that nothing in the program\nchanges the variable, and therefore have only one version of that\nvariable.\n\nFor module variables, when the execution leaves the module to unknown\ncode, or unclear code, it might change the variable. Therefore, likely\nwe will often only assume that it could still be ``ctypes``, but also\nsomething else.\n\nDepending on how well we control module variable assignment, we can\ndecide this more of less quickly. With \"compiled modules\" types, the\nexpectation is that it's merely a quick C ``==`` comparison check. The\nmodule friend should offer code to allow a check if it applies, for\nuncertain cases.\n\nThen when we come to uses of it:\n\n.. code:: python\n\n   ctypes.c_int()\n\nAt this point, using SSA, we are more of less sure, that ``ctypes`` is\nat that point the module, and that we know what it's ``c_int`` attribute\nis, at compile time, and what it's call result is. We will use the\nmodule friend to help with that. It will attach knowledge about the\nresult of that expression during the SSA collection process.\n\nThis is more like a value forward propagation than anything else. In\nfact, constant propagation should only be the special case of it, and\none design goal of Nuitka was always to cover these two cases with the\nsame code.\n\nExcursion to Functions\n======================\n\nIn order to decide what this means to functions and their call\nboundaries, if we propagate forward, how to handle this:\n\n.. code:: python\n\n   def my_append(a, b):\n       a.append(b)\n\n       return a\n\nWe annotate that ``a`` is first a \"unknown but defined parameter\nobject\", then later on something that definitely has an ``append``\nattribute, when returned, as otherwise an exception occurs.\n\nThe type of ``a`` changes to that after ``a.append`` look-up succeeds.\nIt might be many kinds of an object, but e.g. it could have a higher\nprobability of being a ``PyListObject``. And we would know it cannot be\na ``PyStringObject``, as that one has no ``append`` method, and would\nhave raised an exception therefore.\n\n.. note::\n\n   If classes, i.e. other types in the program, have an ``append``\n   attribute, it should play a role too, there needs to be a way to\n   plug-in to this decisions.\n\n.. note::\n\n   On the other hand, types without ``append`` attribute can be\n   eliminated.\n\nTherefore, functions through SSA provide an automatic analysis on their\nreturn state, or return value types, or a quick way to predict return\nvalue properties, based on input value knowledge.\n\nSo this could work:\n\n.. code:: python\n\n   b = my_append([], 3)\n\n   assert b == [3]  # Could be decided now\n\nGoal: The structure we use makes it easy to tell what ``my_append`` may\nbe. So, there should be a means to ask it about call results with given\ntype/value information. We need to be able to tell, if evaluating\n``my_append`` makes sense with given parameters or not, if it does\nimpact the return value.\n\nWe should e.g. be able to make ``my_append`` tell, one or more of these:\n\n-  Returns the first parameter value as return value (unless it raises\n   an exception).\n\n-  The return value has the same type as ``a`` (unless it raises an\n   exception).\n\n-  The return value has an ``append`` attribute.\n\n-  The return value might be a ``list`` object.\n\n-  The return value may not be a ``str`` object.\n\n-  The function will raise if first argument has no ``append``\n   attribute.\n\nThe exactness of statements may vary. But some things may be more\ninteresting. If e.g. the aliasing of a parameter value to the return\nvalue is known exactly, then information about it need to all be given\nup, but some can survive.\n\nIt would be nice, if ``my_append`` had sufficient information, so we\ncould specialize with ``list`` and ``int`` from the parameters, and then\ne.g. know at least some things that it does in that case. Such\nspecialization would have to be decided if it makes sense. In the\nalternative, it could be done for each variant anyway, as there won't be\nthat many of them.\n\nDoing this \"forward\" analysis appears to be best suited for functions\nand therefore long term. We will try it that way.\n\nExcursion to Loops\n==================\n\n.. code:: python\n\n   a = 1\n\n   while 1:  # think loop: here\n       b = a + 1\n       a = b\n\n       if cond():\n           break\n\n   print(a)\n\nThe handling of loops (both ``for`` and ``while`` are re-formulated to\nthis kind of loops with ``break`` statements) has its own problem. The\nloop start and may have an assumption from before it started, that ``a``\nis constant, but that is only true for the first iteration. So, we can't\npass knowledge from outside loop forward directly into the for loop\nbody.\n\nSo the collection for loops needs to be two pass for loops. First, to\ncollect assignments, and merge these into the start state, before\nentering the loop body. The need to make two passes is special to loops.\n\nFor a start, it is done like this. At loop entry, all pre-existing, but\nwritten traces, are turned into loop merges. Knowledge is not completely\nremoved about everything assigned or changed in the loop, but then it's\nnot trusted anymore.\n\nFrom that basis, the ``break`` exits are analysed, and merged, building\nup the post loop state, and ``continue`` exits of the loop replacing the\nunknown part of the loop entry state. The loop end is considered a\n``continue`` for this purpose.\n\nExcursion to Conditions\n=======================\n\n.. code:: python\n\n   if cond:\n       x = 1\n   else:\n       x = 2\n\n   b = x < 3\n\nThe above code contains a condition, and these have the problem, that\nwhen exiting the conditional block, a merge must be done, of the ``x``\nversions. It could be either one. The merge may trace the condition\nunder which a choice is taken. That way, we could decide pairs of traces\nunder the same condition.\n\nThese merges of SSA variable \"versions\", represent alternative values.\nThey pose difficulties, and might have to be reduced to commonality. In\nthe above example, the ``<`` operator will have to check for each\nversion, and then to decide that both indeed give the same result.\n\nThe trace collection tracks variable changes in conditional branches,\nand then merges the existing state at conditional statement exits.\n\n.. note::\n\n   A branch is considered \"exiting\" if it is not abortive. Should it end\n   in a ``raise``, ``break``, ``continue``, or ``return``, there is no\n   need to merge that branch, as execution of that branch is terminated.\n\n   Should both branches be abortive, that makes things really simple, as\n   there is no need to even continue.\n\n   Should only one branch exist, but be abortive, then no merge is\n   needed, and the collection can assume after the conditional\n   statement, that the branch was not taken, and continue.\n\nWhen exiting both the branches, these branches must both be merged, with\ntheir new information.\n\nIn the above case:\n\n-  The \"yes\" branch knows variable ``x`` is an ``int`` of constant value\n   ``1``\n\n-  The \"no\" branch knows variable ``x`` is an ``int`` of constant value\n   ``2``\n\nThat might be collapsed to:\n\n-  The variable ``x`` is an integer of value in ``(1,2)``\n\nGiven this, we then should be able to pre-compute the value of this:\n\n.. code:: python\n\n   b = x < 3\n\nThe comparison operator can therefore decide and tell:\n\n-  The variable ``b`` is a boolean of constant value ``True``.\n\nWere it unable to decide, it would still be able to say:\n\n-  The variable ``b`` is a boolean.\n\nFor conditional statements optimization, it's also noteworthy, that the\ncondition is known to pass or not pass the truth check, inside branches,\nand in the case of non-exiting single branches, after the statement it's\nnot true.\n\nWe may want to take advantage of it. Consider e.g.\n\n.. code:: python\n\n   if type(a) is list:\n       a.append(x)\n   else:\n       a += (x,)\n\nIn this case, the knowledge that ``a`` is a list, could be used to\ngenerate better code and with the definite knowledge that ``a`` is of\ntype list. With that knowledge the ``append`` attribute call will become\nthe ``list`` built-in type operation.\n\nExcursion to ``return`` statements\n==================================\n\nThe ``return`` statement (like ``break``, ``continue``, ``raise``) is\n\"aborting\" to control flow. It is always the last statement of inspected\nblock. When there statements to follow it, optimization will remove it\nas \"dead code\".\n\nIf all branches of a conditional statement are \"aborting\", the statement\nis decided \"aborting\" too. If a loop doesn't abort with a break, it\nshould be considered \"aborting\" too.\n\nExcursion to ``yield`` expressions\n==================================\n\nThe ``yield`` expression can be treated like a normal function call, and\nas such invalidates some known constraints just as much as they do. It\nexecutes outside code for an unknown amount of time, and then returns,\nwith little about the outside world known anymore, if it's accessible\nfrom there.\n\nMixed Types\n===========\n\nConsider the following inside a function or module:\n\n.. code:: python\n\n   if cond is not None:\n       a = [x for x in something() if cond(x)]\n   else:\n       a = ()\n\nA programmer will often not make a difference between ``list`` and\n``tuple``. In fact, using a ``tuple`` is a good way to express that\nsomething won't be changed later, as these are mutable.\n\n.. note::\n\n   Better programming style, would be to use this:\n\n   .. code:: python\n\n      if cond is not None:\n          a = tuple(x for x in something() if cond(x))\n      else:\n          a = ()\n\n   People don't do it, because they dislike the performance hit\n   encountered by the generator expression being used to initialize the\n   tuple. But it would be more consistent, and so Nuitka is using it,\n   and of course one day Nuitka ought to be able to make no difference\n   in performance for it.\n\nTo Nuitka though this means, that if ``cond`` is not predictable, after\nthe conditional statement we may either have a ``tuple`` or a ``list``\ntype object in ``a``. In order to represent that without resorting to \"I\nknow nothing about it\", we need a kind of ``min``/``max`` operating\nmechanism that is capable of say what is common with multiple\nalternative values.\n\n.. note::\n\n   At this time, we don't really have that mechanism to find the\n   commonality between values.\n\nBack to \"ctypes\"\n================\n\n.. code:: python\n\n   v = ctypes.c_int()\n\nComing back to this example, we needed to propagate ``ctypes``, then we\ncan propagate \"something\" from ``ctypes.int`` and then known what this\ngives with a call and no arguments, so the walk of the nodes, and\ndiverse operations should be addressed by a module friend.\n\nIn case a module friend doesn't know what to do, it needs to say so by\ndefault. This should be enforced by a base class and give a warning or\nnote.\n\nNow to the interface\n====================\n\nThe following is the intended interface:\n\n-  Iteration with node methods ``computeStatement`` and\n   ``computeExpression``.\n\n   These traverse modules and functions (i.e. scopes) and visit\n   everything in the order that Python executes it. The visiting object\n   is ``TraceCollection`` and pass forward. Some node types, e.g.\n   ``StatementConditional`` new create branch trace collections and\n   handle the SSA merging at exit.\n\n-  Replacing nodes during the visit.\n\n   Both ``computeStatement`` and ``computeExpression`` are tasked to\n   return potential replacements of themselves, together with \"tags\"\n   (meaningless now), and a \"message\", used for verbose tracing.\n\n   The replacement node of ``+`` operator, may e.g. be the pre-computed\n   constant result, wrapped in side effects of the node, or the\n   expression raised, again wrapped in side effects.\n\n-  Assignments and references affect SSA.\n\n   The SSA tree is initialized every time a scope is visited. Then\n   during traversal, traces are built up. Every assignment and merge\n   starts a new trace for that matter. References to a given variable\n   version are traced that way.\n\n-  Value escapes are traced too.\n\n   When an operation hands over a value to outside code, it indicates so\n   to the trace collection. This is for it to know, when e.g. a constant\n   value, might be mutated meanwhile.\n\n-  Nodes can be queried about their properties.\n\n   There is a type shape and a value shape that each node can be asked\n   about. The type shape offers methods that allow to check if certain\n   operations are at all supported or not. These can always return\n   ``True`` (yes), ``False`` (no), and ``None`` (cannot decide). In the\n   case of the later, optimizations may not be able do much about it.\n   Lets call these values \"tri-state\".\n\n   There is also the value shape of a node. This can go deeper, and be\n   more specific to a given node.\n\n   The default implementation will be very pessimistic. Specific node\n   types and shapes may then declare, that they e.g. have no side\n   effects, will not raise for certain operations, have a known truth\n   value, have a known iteration length, can predict their iteration\n   values, etc.\n\n-  Nodes are linked to certain states.\n\n   During the collect, a variable reference, is linked to a certain\n   trace state, and that can be used by parent operations.\n\n   .. code:: python\n\n      a = 1\n      b = a + a\n\n   In this example, the references to ``a``, can look-up the ``1`` in\n   the trace, and base value shape response to ``+`` on it. For compile\n   time evaluation, it may also ask ``isCompileTimeConstant()`` and if\n   both nodes will respond ``True``, then \"getCompileTimeConstant()\"\n   will return ``1``, which will be be used in computation.\n\n   Then ``extractSideEffects()`` for the ``a`` reference will return\n   ``()`` and therefore, the result ``2`` will not be wrapped.\n\n   An alternative approach would be ``hasTypeSlotAdd()`` on the both\n   nodes, and they both do, to see if the selection mechanism used by\n   CPython can be used to find which types ``+`` should be used.\n\n-  Class for module import expression ``ExpressionImportModule``.\n\n   This one just knows that something is imported, but not how or what\n   it is assigned to. It will be able in a recursive compile, to provide\n   the module as an assignment source, or the module variables or\n   submodules as an attribute source when referenced from a variable\n   trace or in an expression.\n\n-  Base class for module friend ``ModuleFriendBase``.\n\n   This is intended to provide something to overload, which e.g. can\n   handle ``math`` in a better way.\n\n-  Module ``ModuleFriendRegistry``\n\n   Provides a register function with ``name`` and instances of\n   ``ValueFriendModuleBase`` to be registered. Recursed to modules\n   should integrate with that too. The registry could well be done with\n   a metaclass approach.\n\n-  The module friends should each live in a module of their own.\n\n   With a naming policy to be determined. These modules should add\n   themselves via above mechanism to ``ModuleFriendRegistry`` and all\n   shall be imported and register. Importing of e.g. ``ctypes`` should\n   be delayed to when the friend is actually used. A meta class should\n   aid this task.\n\n   The delay will avoid unnecessary blot of the compiler at run time, if\n   no such module is used. For \"qt\" and other complex stuff, this will\n   be a must.\n\n-  The walk should initially be single pass, and not maintain history.\n\n   Instead optimization that needs to look at multiple things, e.g.\n   \"unused assignment\", will look at the whole SSA collection\n   afterwards.\n\nDiscussing with examples\n========================\n\nThe following examples:\n\n.. code:: python\n\n   # Assignment, the source decides the type of the assigned expression\n   a = b\n\n   # Operator \"attribute look-up\", the looked up expression \"ctypes\" decides\n   # via its trace.\n   ctypes.c_int\n\n   # Call operator, the called expressions decides with help of arguments,\n   # which have been walked, before the call itself.\n   called_expression_of_any_complexity()\n\n   # import gives a module any case, and the \"ModuleRegistry\" may say more.\n   import ctypes\n\n   # From import need not give module, \"x\" decides what it is.\n   from x import y\n\n   # Operations are decided by arguments, and CPython operator rules between\n   # argument states.\n   a + b\n\nThe optimization is mostly performed by walking of the tree and\nperforming trace collection. When it encounters assignments and\nreferences to them, it considers current state of traces and uses it for\n``computeExpression``.\n\n.. note::\n\n   Assignments to attributes, indexes, slices, etc. will also need to\n   follow the flow of ``append``, so it cannot escape attention that a\n   list may be modified. Usages of ``append`` that we cannot be sure\n   about, must be traced to exist, and disallow the list to be\n   considered known value again.\n\nCode Generation Impact\n======================\n\nRight now, code generation assumes that everything is a ``PyObject *``,\ni.e. a Python object, and does not take knowledge of ``int`` or other\ntypes into consideration at all, and it should remain like that for some\ntime to come.\n\nInstead, ``ctypes`` value friend will be asked give ``Identifiers``,\nlike other codes do too. And these need to be able to convert themselves\nto objects to work with the other things.\n\nBut Code Generation should no longer require that operations must be\nperformed on that level. Imagine e.g. the following calls:\n\n.. code:: python\n\n   c_call(other_c_call())\n\nValue returned by \"other_c_call()\" of say ``c_int`` type, should be\npossible to be fed directly into another call. That should be easy by\nhaving a ``asIntC()`` in the identifier classes, which the ``ctypes``\nIdentifiers handle without conversions.\n\nCode Generation should one day also become able to tell that all uses of\na variable have only ``c_int`` value, and use ``int`` instead of\n``PyObjectLocalVariable`` more or less directly. We could consider\n``PyIntLocalVariable`` of similar complexity as ``int`` after the C++\ncompiler performed its in-lining.\n\nSuch decisions would be prepared by finalization, which then would track\nthe history of values throughout a function or part of it.\n\nInitial Implementation\n======================\n\nThe basic interface will be added to *all* expressions and a node may\noverride it, potentially using trace collection state, as attached\nduring ``computeExpression``.\n\nGoal 1 (Reached)\n----------------\n\nInitially most things will only be able to give up on about anything.\nAnd it will be little more than a tool to do simple look-ups in a\ngeneral form. It will then be the first goal to turn the following code\ninto better performing one:\n\n.. code:: python\n\n   a = 3\n   b = 7\n   c = a / b\n   print(c)\n\nto:\n\n.. code:: python\n\n   a = 3\n   b = 7\n   c = 3 / 7\n   print(c)\n\nand then:\n\n.. code:: python\n\n   a = 3\n   b = 7\n   c = 0\n   print(c)\n\nand then:\n\n.. code:: python\n\n   a = 3\n   b = 7\n   c = 0\n   print(0)\n\nThis depends on SSA form to be able to tell us the values of ``a``,\n``b``, and ``c`` to be written to by constants, which can be forward\npropagated at no cost.\n\nGoal 2 (Reached)\n----------------\n\nThe assignments to ``a``, ``b``, and ``c`` shall all become prey to\n\"unused\" assignment analysis in the next step. They are all only\nassigned to, and the assignment source has no effect, so they can be\nsimply dropped.\n\n.. code:: python\n\n   print(0)\n\nIn the SSA form, these are then assignments without references. These\nassignments, can be removed if the assignment source has no side effect.\nOr at least they could be made \"anonymous\", i.e. use a temporary\nvariable instead of the named one. That would have to take into account\nthough, that the old version still needs a release.\n\nThe most general form would first merely remove assignments that have no\nimpact, and leave the value as a side effect, so we arrive at this\nfirst:\n\n.. code:: python\n\n   3\n   7\n   0\n   print(0)\n\nWhen applying the removal of expression only statements without effect,\nthis gives us:\n\n.. code:: python\n\n   print(0)\n\nwhich is the perfect result. Doing it in one step would only be an\noptimization at the cost of generalization.\n\nIn order to be able to manipulate nodes related to a variable trace, we\nneed to attach the nodes that did it. Consider this:\n\n.. code:: python\n\n   if cond():\n       x = 1\n   elif other():\n       x = 3\n\n   # Not using \"x\".\n   print(0)\n\nIn the above case, the merge of the value traces, should say that ``x``\nmay be undefined, or one of ``1`` or ``3``, but since ``x`` is not used,\napply the \"dead value\" trick to each branch.\n\nThe removal of the \"merge\" of the 3 ``x`` versions, should exhibit that\nthe other versions are also only assigned to, and can be removed. These\nmerges of course appear as usages of the ``x`` versions.\n\nGoal 3\n------\n\nThen third goal is to understand all of this:\n\n.. code:: python\n\n   def f():\n       a = []\n\n       print(a)\n\n       for i in range(1000):\n           print(a)\n\n           a.append(i)\n\n       return len(a)\n\n.. note::\n\n   There are many operations in this, and all of them should be properly\n   handled, or at least ignored in safe way.\n\nThe first goal code gave us that the ``list`` has an annotation from the\nassignment of ``[]`` and that it will be copied to ``a`` until the for\nloop in encountered. Then it must be removed, because the ``for`` loop\nsomehow says so.\n\nThe ``a`` may change its value, due to the unknown attribute look-up of\nit already, not even the call. The for loop must be able to say \"may\nchange value\" due to that, of course also due to the call of that\nattribute too.\n\nThe code should therefore become equivalent to:\n\n.. code:: python\n\n   def f():\n       a = []\n\n       print([])\n\n       for i in range(1000):\n           print(a)\n\n           a.append(i)\n\n       return len(a)\n\nBut no other changes must occur, especially not to the ``return``\nstatement, it must not assume ``a`` to be constant \"[]\" but an unknown\n``a`` instead.\n\nWith that, we would handle this code correctly and have some form\nconstant value propagation in place, handle loops at least correctly,\nand while it is not much, it is important demonstration of the concept.\n\nGoal 4\n------\n\nThe fourth goal is to understand the following:\n\n.. code:: python\n\n   def f(cond):\n       y = 3\n\n       if cond:\n           x = 1\n       else:\n           x = 2\n\n       return x < y\n\nIn this we have a branch, and we will be required to keep track of both\nthe branches separately, and then to merge with the original knowledge.\nAfter the conditional statement we will know that \"x\" is an \"int\" with\npossible values in ``(1,2)``, which can be used to predict that the\nreturn value is always ``True``.\n\nThe fourth goal will therefore be that the \"ValueFriendConstantList\"\nknows that append changes ``a`` value, but it remains a list, and that\nthe size increases by one. It should provide an other value friend\n\"ValueFriendList\" for \"a\" due to that.\n\nIn order to do that, such code must be considered:\n\n.. code:: python\n\n   a = []\n\n   a.append(1)\n   a.append(2)\n\n   print(len(a))\n\nIt will be good, if ``len`` still knows that ``a`` is a list object, but\nnot the constant list anymore.\n\nFrom here, work should be done to demonstrate the correctness of it with\nthe basic tests applied to discover undetected issues.\n\nFifth and optional goal: Extra bonus points for being able to track and\npredict ``append`` to update the constant list in a known way. Using\n``list.append`` that should be done and lead to a constant result of\n``len`` being used.\n\nThe sixth and challenging goal will be to make the code generation be\nimpacted by the value friends types. It should have a knowledge that\n``PyList_Append`` does the job of append and use ``PyList_Size`` for\n``len``. The \"ValueFriends\" should aid the code generation too.\n\nLast and right now optional goal will be to make ``range`` have a value\nfriend, that can interact with iteration of the for loop, and ``append``\nof the ``list`` value friend, so it knows it's possible to iterate 5000\ntimes, and that \"a\" has then after the \"loop\" this size, so ``len(a)``\ncould be predicted. For during the loop, about a the range of its length\nshould be known to be less than 5000. That would make the code of goal 2\ncompletely analyzed at compile time.\n\nLimitations for now\n===================\n\n-  Aim only for limited examples. For ``ctypes`` that means to compile\n   time evaluate:\n\n   .. code:: python\n\n      print(ctypes.c_int(17) + ctypes.c_long(19))\n\n   Later then call to \"libc\" or something else universally available,\n   e.g. \"strlen()\" or \"strcmp()\" from full blown declarations of the\n   callable.\n\n-  We won't have the ability to test that optimization are actually\n   performed, we will check the generated code by hand.\n\n   With time, we will add XML based checks with \"xpath\" queries,\n   expressed as hints, but that is some work that will be based on this\n   work here. The \"hints\" fits into the \"ValueFriends\" concept nicely or\n   so the hope is.\n\n-  No inter-function optimization functions yet\n\n   Of course, once in place, it will make the ``ctypes`` annotation even\n   more usable. Using ``ctypes`` objects inside functions, while\n   creating them on the module level, is therefore not immediately going\n   to work.\n\n-  No loops yet\n\n   Loops break value propagation. For the ``ctypes`` use case, this\n   won't be much of a difficulty. Due to the strangeness of the task, it\n   should be tackled later on at a higher priority.\n\n-  Not too much.\n\n   Try and get simple things to work now. We shall see, what kinds of\n   constraints really make the most sense. Understanding ``list``\n   subscript/slice values e.g. is not strictly useful for much code and\n   should not block us.\n\n.. note::\n\n   This design is not likely to be the final one.\n\n***********************************\n How to make Features Experimental\n***********************************\n\nEvery experimental feature needs a name. We have a rule to pick a name\nwith lower case and ``_`` as separators. An example of with would be the\nname ``jinja_generated_add`` that has been used in the past.\n\nCommand Line\n============\n\nExperimental features are enabled with the command line argument\n\n.. code:: bash\n\n   nuitka --experimental=jinja_generated_add ...\n\nIn C code\n=========\n\nIn Scons, all experimental features automatically are converted into C\ndefines, and can be used like this:\n\n.. code:: C\n\n   #ifdef _NUITKA_EXPERIMENTAL_JINJA_GENERATED_ADD\n   #include \"HelpersOperationGeneratedBinaryAdd.c\"\n   #else\n   #include \"HelpersOperationBinaryAdd.c\"\n   #endif\n\nThe C pre-processor is the only thing that makes an experimental feature\nusable.\n\nIn Python\n=========\n\nYou can query experimental features using ``Options.isExperimental()``\nwith e.g. code like this:\n\n.. code:: python\n\n   if Options.isExperimental(\"use_feature\"):\n       experimental_code()\n   else:\n       standard_code()\n\nWhen to use it\n==============\n\nOften we need to keep feature in parallel because they are not finished,\nor need to be tested after merge and should not break. Then we can do\ncode changes that will not make a difference except when the\nexperimental flag is given on the command line to Nuitka.\n\nThe testing of Nuitka is very heavy weight when e.g. all Python code is\ncompiled, and very often, it is interesting to compare behavior with and\nwithout a change.\n\nWhen to remove it\n=================\n\nWhen a feature becomes default, we might choose to keep the old variant\naround, but normally we do not. Then we remove the ``if`` and ``#if``\nchecks and drop the old code.\n\nAt this time, large scale testing will have demonstrated the viability\nof the code.\n\n*******************************\n Adding dependencies to Nuitka\n*******************************\n\nFirst of all, there is an important distinction to make, run time or\ndevelopment time. The first kind of dependency is used when Nuitka is\nexecuting.\n\nAdding a Run Time Dependency\n============================\n\nThis is the kind of dependency that is the most scrutinized. As we want\nNuitka to run on latest greatest Python as well as relatively old ones,\nwe have to be very careful with these ones.\n\nThere is also a distinction of optional dependencies. Right now e.g. the\n``lxml`` package is relatively optional, and Nuitka can work without it\nbeing installed, because e.g. on some platforms it will not be easy to\ndo so. That bar has lifted somewhat, but it means e.g. that XML based\noptimization tests are not run with all Python versions.\n\nThe list of run time dependencies is in ``requirements.txt`` and it is\nfor those the case, that they are not really required to be installed by\nthe user, consider this snippet:\n\n.. code:: python\n\n   # Folders to use for cache files.\n   appdirs\n\n   # Scons is the backend building tool to turn C files to binaries.\n   scons\n\nFor both these dependencies, there is either an inline copy (Scons) that\nwe handle to use in case, if Scons is not available (in fact we have a\nversion that works with Python 2.6 and 2.7 still), and also the same for\nappdirs and every dependency.\n\nBut since inline copies are against the rules on some platforms that\nstill do not contain the package, we often even have our own wrapper\nwhich provides a minimal fallback or exposes a sane interface for the\nsubset of functionality that we use.\n\n.. note::\n\n   Therefore, please if you consider adding one of these, get in touch\n   with ``@Nuitka-pushers`` first and get a green light.\n\nAdding a Development Dependency\n===============================\n\nA typical example of a development dependency is ``black`` which is used\nby our autoformat tool, and then in turn by the git pre-commit hook. It\nis used to format source code, and doesn't have a role at run time of\nthe actual compiler code of Nuitka.\n\nMuch less strict rules apply to these in comparison to runtime\ndependencies. Generally please take care that the tool must be well\nmaintained an available on newer Pythons. Then we can use it, no problem\nnormally. But if it's really big, say all of SciPy, we might want to\njustify it a bit better.\n\nThe list of development dependencies is in ``requirements-devel.txt``\nand it is for example like this:\n\n.. code:: python\n\n   # Autoformat needs this\n   rstfmt == 0.0.10 ; python_version >= '3.7'\n\nWe always add the version, so that when tests run on as old versions as\nPython 2.6, the installation would fail with that version, so we need to\nmake a version requirement. Sometimes we use older versions for Python2\nthan for Python3, ``Jinaj2`` being a notable candidate, but generally we\nought to avoid that. For many tools only being available for currently\n3.7 or higher is good enough, esp. if they are run as development tools,\nlike ``autoformat-nuitka-source`` is.\n\n**********\n Idea Bin\n**********\n\nThis an area where to drop random ideas on our minds, to later sort it\nout, and out it into action, which could be code changes, plan changes,\nissues created, etc.\n\n-  Make \"SELECT_METACLASS\" meta class selection transparent.\n\n   Looking at the \"SELECT_METACLASS\" it should become an anonymous\n   helper function. In that way, the optimization process can remove\n   choices at compile time, and e.g. in-line the effect of a meta class,\n   if it is known.\n\n   This of course makes most sense, if we have the optimizations in\n   place that will allow this to actually happen.\n\n-  Keeping track of iterations\n\n   The trace collection trace should become the place, where variables\n   or values track their use state. The iterator should keep track of\n   the \"next()\" calls made to it, so it can tell which value to given in\n   that case.\n\n   That would solve the \"iteration of constants\" as a side effect and it\n   would allow to tell that they can be removed.\n\n   That would mean to go back in the tree and modify it long after.\n\n   .. code:: python\n\n      a = iter((2, 3))\n      b = next(a)\n      c = next(a)\n      del a\n\n   It would be sweet if we could recognize that as:\n\n   .. code:: python\n\n      a = iter((2, 3))\n      b = side_effect(next(a), 2)\n      c = side_effect(next(a), 3)\n      del a\n\n   That trivially becomes:\n\n   .. code:: python\n\n      a = iter((2, 3))\n      next(a)\n      b = 2\n      next(a)\n      c = 3\n      del a\n\n   When the ``del a`` is examined at the end of scope, or due to another\n   assignment to the same variable, ending the trace, we would have to\n   consider of the ``next`` uses, and retrofit the information that they\n   had no effect.\n\n   .. code:: python\n\n      a = iter((2, 3))\n      b = 2\n      b = 3\n      del a\n\n-  Aliasing\n\n   Each time an assignment is made, an alias is created. A value may\n   have different names.\n\n   .. code:: python\n\n      a = iter(range(9))\n      b = a\n      c = next(b)\n      d = next(a)\n\n   If we fail to detect the aliasing nature, we will calculate ``d``\n   wrongly. We may incref and decref values to trace it.\n\n   Aliasing is automatically traced already in SSA form. The ``b`` is\n   assigned to version of ``a``. So, that should allow to replace it\n   with this:\n\n   .. code:: python\n\n      a = iter(range(9))\n      c = next(a)\n      d = next(a)\n\n   Which then will be properly handled.\n\n-  Tail recursion optimization.\n\n   Functions that return the results of calls, can be optimized. The\n   Stackless Python does it already.\n\n-  Integrate with \"upx\" compression.\n\n   Calling \"upx\" on the created binaries, would be easy.\n\n-  In-lining constant \"exec\" and \"eval\".\n\n   It should be possible to re-formulate at least cases without \"locals\"\n   or \"globals\" given.\n\n   .. code:: python\n\n      def f():\n          a = 1\n          b = 2\n\n          exec(\"\"\"a+=b;c=1\"\"\")\n\n          return a, c\n\n   Should become this here:\n\n   .. code:: python\n\n      def f():\n          a = 1\n          b = 2\n\n          a += b  #\n          c = 1  # MaybeLocalVariables for everything except known local ones.\n\n          return a, c\n\n   If this holds up, inlining ``exec`` should be relatively easy.\n\n-  Original and overloaded built-ins\n\n   This is about making things visible in the node tree. In Nuitka\n   things that are not visible in the node tree tend to be wrong. We\n   already pushed around information to the node tree a lot.\n\n   Later versions, Nuitka will become able to determine it has to be the\n   original built-in at compile time, then a condition that checks will\n   be optimized away, together with the slow path. Or the other path, if\n   it won't be. Then it will be optimized away, or if doubt exists, it\n   will be correct. That is the goal.\n\n   Right now, the change would mean to effectively disable all built-in\n   call optimization, which is why we don't immediately do it.\n\n   Making the compatible version, will also require a full listing of\n   all built-ins, which is typing work merely, but not needed now. And a\n   way to stop built-in optimization from optimizing built-in calls that\n   it used in a wrap. Probably just some flag to indicate it when it\n   visits it to skip it. That's for later.\n\n   But should we have that both, I figure, we could not raise a\n   ``RuntimeError`` error, but just do the correct thing, in all cases.\n   An earlier step may raise ``RuntimeError`` error, when built-in\n   module values are written to, that we don't support.\n\n******************\n Prongs of Action\n******************\n\nIn this chapter, we keep track of prongs of action currently ongoing.\nThis can get detailed and shows things we strive for.\n\nBuiltin optimization\n====================\n\nDefinitely want to get built-in names under full control, so that\nvariable references to module variables do not have a twofold role.\nCurrently they reference the module variable and also the potential\nbuilt-in as a fallback.\n\nIn terms of generated code size and complexity for modules with many\nvariables and uses of them that is horrible. But ``some_var`` (normally)\ncannot be a built-in and therefore needs no code to check for that each\ntime.\n\nThis is also critical to getting to whole program optimization. Being\ncertain what is what there on module level, will enable more definitely\nknowledge about data flows and module interfaces.\n\nClass Creation Overhead Reduction\n=================================\n\nThis is more of a meta goal. Some work for the metaclass has already\nbeen done, but that is Python2 only currently. Being able to to decide\nbuilt-ins and to distinguish between global only variables, and\nbuilt-ins more clearly will help this a lot.\n\nIn the end, empty classes should be able to be statically converted to\ncalls to ``type`` with static dictionaries. The inlining of class\ncreation function is also needed for this, but on Python3 cannot happen\nyet.\n\nMemory Usage at Compile Time\n============================\n\nWe will need to store more and more information in the future. Getting\nthe tree to be tight shaped is therefore an effort, where we will be\nspending time too.\n\nThe mix-ins prevent slots usage, so lets try and get rid of those. The\n\"children having\" should become more simple and faster code. I am even\nthinking of even generating code in the meta class, so it's both optimal\nand doesn't need that mix-in any more. This is going to be ugly then.\n\nCoverage Testing\n================\n\nAnd then there is coverage, it should be taken and merged from all\nPython versions and OSes, but I never managed to merge between Windows\nand Linux for unknown reasons.\n\nPython3 Performance\n===================\n\nThe Python3 lock for thread state is making it slower by a lot. I have\nonly experimental code that just ignores the lock, but it likely only\nworks on Linux, and I wonder why there is that lock in the first place.\n\nIgnoring the locks cannot be good. But what updates that thread state\npointer ever without a thread change, and is this what ABI flags are\nabout in this context, are there some that allow us to ignore the locks.\n\nAn important bit would be to use a thread state once acquired for as\nmuch as possible, currently exception helpers do not accept it as an\nargument, but that ought to become an option, that way saving and\nrestoring an exception will be much faster, not to mention checking and\ndropping non interesting, or rewriting exceptions.\n\nCaching of Python level compilation\n===================================\n\nWhile the C compilation result is already cached with `ccache` and\nfriends now, we need to also cover our bases and save the resulting node\ntree of potential expensive optimization on the module level.\n\n*************************\n Updates for this Manual\n*************************\n\nThis document is written in REST. That is an ASCII format which is\nreadable to human, but easily used to generate PDF or HTML documents.\n\nYou will find the current source under:\nhttps://github.com/Nuitka/Nuitka/blob/develop/Developer_Manual.rst\n\nAnd the current PDF under: https://nuitka.net/doc/Developer_Manual.pdf\n"
        },
        {
          "name": "LICENSE.txt",
          "type": "blob",
          "size": 11.08203125,
          "content": "\n                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"[]\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright  2010-2019 Kay Hayen\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "MANIFEST.in",
          "type": "blob",
          "size": 1.7080078125,
          "content": "# Spell checking makes no sense, spell-checker: disable\n\ninclude LICENSE.txt\ninclude MANIFEST.in\ninclude README.rst\ninclude Changelog.rst\ninclude Developer_Manual.rst\ninclude doc/nuitka.1\ninclude doc/nuitka-run.1\n\ninclude bin/compare_with_cpython\ninclude bin/compare_with_xml\ninclude bin/check-nuitka-with-pylint\ninclude bin/autoformat-nuitka-source\ninclude bin/measure-construct-performance\n\n# Runners, mainly for source distribution.\ninclude bin/nuitka\ninclude bin/nuitka-run\n\ninclude misc/*.cmd\ninclude tests/run-tests\n\ninclude nuitka/plugins/standard/*.yml\n\n# Logo with source\ninclude doc/Logo/Nuitka-Logo-Symbol.svg\ninclude doc/Logo/Nuitka-Logo-Vertical.svg\ninclude doc/Logo/Nuitka-Logo-Horizontal.svg\ninclude doc/images/Nuitka-Logo-Symbol.png\ninclude doc/images/Nuitka-Logo-Vertical.png\ninclude doc/images/Nuitka-Logo-Horizontal.png\n\nrecursive-include lib *.py\n\n# Core tests are included along with Nuitka itself.\nrecursive-include tests/basics *.py\nrecursive-include tests/syntax *.py\nrecursive-include tests/packages *.py\nrecursive-include tests/programs *.py\ninclude tests/programs/pkgutil_usage/package/DATA_FILE*.txt\ninclude tests/programs/resource_reader37/some_package/DATA_FILE*.txt\ninclude tests/onefile/external-data/*.txt\nrecursive-include tests/optimizations *.py\nrecursive-include tests/standalone *.py\nrecursive-include tests/onefile *.py\nrecursive-include tests/reflected *.py\nrecursive-include tests/plugins *.py\nrecursive-include tests/plugins *.yml\ninclude tests/plugins/data_files/data_files_package/*.txt\ninclude tests/plugins/data_files/data_files_package/sub_dir/*.txt\n\n# C templates for code generation.\nrecursive-include nuitka/code_generation/templates_c *.j2\n\n# Report templates\nrecursive-include nuitka/reports *.j2\n"
        },
        {
          "name": "README.rst",
          "type": "blob",
          "size": 79.9833984375,
          "content": ".. image:: https://img.shields.io/pypi/pyversions/Nuitka.svg\n   :target: https://pypi.org/project/Nuitka\n\n.. image:: https://badge.fury.io/py/Nuitka.svg\n   :target: https://pypi.org/project/Nuitka\n\n.. image:: https://img.shields.io/badge/Contributor%20Covenant-v1.4%20adopted-ff69b4.svg\n   :target: CODE_OF_CONDUCT.md\n\n####################\n Nuitka User Manual\n####################\n\nThis document is the recommended first read when you start using\n**Nuitka**. On this page, you will learn more about **Nuitka**\nfundamentals, such as license type, use cases, requirements, and\ncredits.\n\n.. contents:: Table of Contents\n   :depth: 1\n   :local:\n   :class: page-toc\n\nNuitka is **the** Python compiler. It is written in Python. It is a\nseamless replacement or extension to the Python interpreter and compiles\n**every** construct that Python 2 (2.6, 2.7) and Python 3 (3.4 - 3.13)\nhave, when itself run with that Python version.\n\nIt then executes uncompiled code and compiled code together in an\nextremely compatible manner.\n\nYou can use all Python library modules and all extension modules freely.\n\nNuitka translates the Python modules into a C level program that then\nuses ``libpython`` and static C files of its own to execute in the same\nway as CPython does.\n\nAll optimization is aimed at avoiding overhead, where it's unnecessary.\nNone is aimed at removing compatibility, although slight improvements\nwill occasionally be done, where not every bug of standard Python is\nemulated, e.g. more complete error messages are given, but there is a\nfull compatibility mode to disable even that.\n\n**************\n Requirements\n**************\n\nTo ensure smooth operation of **Nuitka**, make sure to follow system\nrequirements, that include the following components:\n\n.. contents::\n   :depth: 1\n   :local:\n\nC Compiler\n==========\n\nYou need a C compiler with support for C11 or alternatively a C++\ncompiler for C++03 [#]_.\n\nCurrently, this means, you need to use one of these compilers:\n\n-  The MinGW64 C11 compiler, on Windows, must be based on gcc 11.2 or\n   higher. It will be *automatically* downloaded if no usable C compiler\n   is found, which is the recommended way of installing it, as Nuitka\n   will also upgrade it for you.\n\n-  Visual Studio 2022 or higher on Windows [#]_. English language pack\n   for best results (Nuitka filters away garbage outputs, but only for\n   English language). It will be used by default if installed.\n\n-  On all other platforms, the ``gcc`` compiler of at least version 5.1,\n   and below that the ``g++`` compiler of at least version 4.4 as an\n   alternative.\n\n-  The ``clang`` compiler on macOS X and most FreeBSD architectures.\n\n-  On Windows, the ``clang-cl`` compiler on Windows can be used if\n   provided by the Visual Studio installer.\n\n.. [#]\n\n   Support for this C11 is given with gcc 5.x or higher or any clang\n   version.\n\n   The older MSVC compilers don't do it yet. But as a workaround, with\n   Python 3.10 or older, the C++03 language standard is significantly\n   overlapping with C11, it is then used instead.\n\n.. [#]\n\n   Download for free from\n   https://www.visualstudio.com/en-us/downloads/download-visual-studio-vs.aspx\n   (the community editions work just fine).\n\n   The latest version is recommended, but not required. On the other hand,\n   there is no need to except to support pre-Windows 10 versions, and they\n   might work for you, but support of these configurations is only\n   available to commercial users.\n\nPython\n======\n\n**Python 2** (2.6, 2.7) and **Python 3** (3.4  3.13) are supported. If\nat any moment, there is a stable Python release that is not in this\nlist, rest assured it is being worked on and will be added.\n\n.. important::\n\n   For Python 3.4 and *only* that version, we need other Python version\n   as a *compile time* dependency.\n\n   Nuitka itself is fully compatible with all listed versions, but Scons\n   as an internally used tool is not.\n\n   For these versions, you *need* a Python2 or Python 3.5 or higher\n   installed as well, but only during the compile time. That is for use\n   with Scons (which orchestrates the C compilation), which does not\n   support the same Python versions as Nuitka.\n\n   In addition, on Windows, Python2 cannot be used because ``clcache``\n   does not work with it, there a Python 3.5 or higher needs to be\n   installed.\n\n   Nuitka finds these needed Python versions (e.g. on Windows via\n   registry) and you shouldn't notice it as long as they are installed.\n\n   Increasingly, other functionality is available when another Python\n   has a certain package installed. For example, onefile compression\n   will work for a Python 2.x when another Python is found that has the\n   ``zstandard`` package installed.\n\n.. admonition:: Moving binaries to other machines\n\n   The created binaries can be made executable independent of the Python\n   installation, with ``--standalone`` and ``--onefile`` options.\n\n.. admonition:: Binary filename suffix\n\n   The created binaries have an ``.exe`` suffix on Windows. On other\n   platforms they have no suffix for standalone mode, or ``.bin``\n   suffix, that you are free to remove or change, or specify with the\n   ``-o`` option.\n\n   The suffix for acceleration mode is added just to be sure that the\n   original script name and the binary name do not ever collide, so we\n   can safely overwrite the binary without destroying the original\n   source file.\n\n.. admonition:: It **has to** be CPython, Anaconda Python, or Homebrew\n\n   You need the standard Python implementation, called \"CPython\", to\n   execute Nuitka because it is closely tied to implementation details\n   of it.\n\n.. admonition:: It **cannot be** from the Windows app store\n\n   It is known that Windows app store Python definitely does not work,\n   it's checked against.\n\n.. admonition:: It **cannot be** pyenv on macOS\n\n   It is known that macOS \"pyenv\" does **not** work. Use Homebrew\n   instead for self compiled Python installations. But note that\n   standalone mode will be worse on these platforms and not be as\n   backward compatible with older macOS versions.\n\nOperating System\n================\n\nSupported Operating Systems: Linux, FreeBSD, NetBSD, macOS, and Windows\n(32 bits/64 bits/ARM).\n\nOthers will work as well. The portability is expected to be generally\ngood, but the e.g. Nuitka's internal Scons usage may have to be adapted\nor need flags passed. Make sure to match Python and C compiler\narchitecture, or else you will get cryptic error messages.\n\nArchitecture\n============\n\nSupported Architectures are x86, x86_64 (amd64), and arm, likely many,\nmany more.\n\nOther architectures are expected to also work, out of the box, as Nuitka\nis generally not using any hardware specifics. These are just the ones\ntested and known to be good. Feedback is welcome. Generally, the\narchitectures that Debian supports can be considered good and tested,\ntoo.\n\n*******\n Usage\n*******\n\nCommand Line\n============\n\nThe recommended way of executing Nuitka is ``<the_right_python> -m\nnuitka`` to be absolutely certain which Python interpreter you are\nusing, so it is easier to match with what Nuitka has.\n\nThe next best way of executing Nuitka bare that is from a source\ncheckout or archive, with no environment variable changes, most\nnoteworthy, you do not have to mess with ``PYTHONPATH`` at all for\nNuitka. You just execute the ``nuitka`` and ``nuitka-run`` scripts\ndirectly without any changes to the environment. You may want to add the\n``bin`` directory to your ``PATH`` for your convenience, but that step\nis optional.\n\nMoreover, if you want to execute with the right interpreter, in that\ncase, be sure to execute ``<the_right_python> bin/nuitka`` and be good.\n\n.. admonition:: Pick the right Interpreter\n\n   If you encounter a ``SyntaxError`` you absolutely most certainly have\n   picked the wrong interpreter for the program you are compiling.\n\nNuitka has a ``--help`` option to output what it can do:\n\n.. code:: bash\n\n   nuitka --help\n\nThe ``nuitka-run`` command is the same as ``nuitka``, but with a\ndifferent default. It tries to compile *and* directly execute a Python\nscript:\n\n.. code:: bash\n\n   nuitka-run --help\n\nThis option that is different is ``--run``, and passing on arguments\nafter the first non-option to the created binary, so it is somewhat more\nsimilar to what plain ``python`` will do.\n\nInstallation\n============\n\nFor most systems, there will be packages on the `download page\n<https://nuitka.net/doc/download.html>`__ of Nuitka. But you can also\ninstall it from source code as described above, but also like any other\nPython program it can be installed via the normal ``python setup.py\ninstall`` routine.\n\nNotice for integration with GitHub workflows there is this\n`Nuitka-Action <https://github.com/Nuitka/Nuitka-Action>`__ that you\nshould use that makes it really easy to integrate. You ought to start\nwith a local compilation though, but this will be easiest for cross\nplatform compilation with Nuitka.\n\nLicense\n=======\n\nNuitka is licensed under the Apache License, Version 2.0; you may not\nuse it except in compliance with the License.\n\nYou may obtain a copy of the License at\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*************************************\n Tutorial Setup and build on Windows\n*************************************\n\nThis is basic steps if you have nothing installed, of course if you have\nany of the parts, just skip it.\n\nSetup\n=====\n\nInstall Python\n--------------\n\n-  Download and install Python from\n   https://www.python.org/downloads/windows\n\n-  Select one of ``Windows x86-64 web-based installer`` (64 bits Python,\n   recommended) or ``x86 executable`` (32 bits Python) installer.\n\n-  Verify it's working using command ``python --version``.\n\nInstall Nuitka\n--------------\n\n-  ``python -m pip install nuitka``\n\n-  Verify using command ``python -m nuitka --version``\n\nWrite some code and test\n========================\n\nCreate a folder for the Python code\n-----------------------------------\n\n-  ``mkdir`` HelloWorld\n\n-  make a python file named **hello.py**\n\n.. code:: python\n\n   def talk(message):\n       return \"Talk \" + message\n\n\n   def main():\n       print(talk(\"Hello World\"))\n\n\n   if __name__ == \"__main__\":\n       main()\n\nTest your program\n-----------------\n\nDo as you normally would. Running Nuitka on code that works incorrectly\nis not easier to debug.\n\n.. code:: bash\n\n   python hello.py\n\n----\n\nBuild it using\n--------------\n\n.. code:: bash\n\n   python -m nuitka hello.py\n\n.. note::\n\n   This will prompt you to download a C caching tool (to speed up\n   repeated compilation of generated C code) and a MinGW64 based C\n   compiler, unless you have a suitable MSVC installed. Say ``yes`` to\n   both those questions.\n\nRun it\n------\n\nExecute the ``hello.exe`` created near ``hello.py``.\n\nDistribute\n----------\n\nTo distribute, build with ``--standalone`` option, which will not output\na single executable, but a whole folder. Copy the resulting\n``hello.dist`` folder to the other machine and run it.\n\nYou may also try ``--onefile`` which does create a single file, but make\nsure that the mere standalone is working, before turning to it, as it\nwill make the debugging only harder, e.g. in case of missing data files.\n\n***********\n Use Cases\n***********\n\nUse Case 1  Program compilation with all modules embedded\n==========================================================\n\nIf you want to compile a whole program recursively, and not only the\nsingle file that is the main program, do it like this:\n\n.. code:: bash\n\n   python -m nuitka --follow-imports program.py\n\n.. note::\n\n   There are more fine-grained controls than ``--follow-imports``\n   available. Consider the output of ``nuitka --help``. Including fewer\n   modules into the compilation, but instead using normal Python for it,\n   will make it faster to compile.\n\nIn case you have a source directory with dynamically loaded files, i.e.\none which cannot be found by recursing after normal import statements\nvia the ``PYTHONPATH`` (which would be the recommended way), you can\nalways require that a given directory shall also be included in the\nexecutable:\n\n.. code:: bash\n\n   python -m nuitka --follow-imports --include-plugin-directory=plugin_dir program.py\n\n.. note::\n\n   If you don't do any dynamic imports, simply setting your\n   ``PYTHONPATH`` at compilation time is what you should do.\n\n   Use ``--include-plugin-directory`` only if you make ``__import__()``\n   calls that Nuitka cannot predict, and that come from a directory, for\n   everything from your Python installation, use ``--include-module`` or\n   ``--include-package``.\n\n.. note::\n\n   The resulting filename will be ``program.exe`` on Windows,\n   ``program.bin`` on other platforms, but ``--output-filename`` allows\n   changing that.\n\n.. note::\n\n   The resulting binary still depends on CPython and used C extension\n   modules being installed.\n\n   If you want to be able to copy it to another machine, use\n   ``--standalone`` and copy the created ``program.dist`` directory and\n   execute the ``program.exe`` (Windows) or ``program`` (other\n   platforms) put inside.\n\nUse Case 2  Extension Module compilation\n=========================================\n\nIf you want to compile a single extension module, all you have to do is\nthis:\n\n.. code:: bash\n\n   python -m nuitka --module some_module.py\n\nThe resulting file ``some_module.so`` can then be used instead of\n``some_module.py``.\n\n.. important::\n\n   The filename of the produced extension module must not be changed as\n   Python insists on a module name derived function as an entry point,\n   in this case ``PyInit_some_module`` and renaming the file will not\n   change that. Match the filename of the source code to what the binary\n   name should be.\n\n.. note::\n\n   If both the extension module and the source code of it are in the\n   same directory, the extension module is loaded. Changes to the source\n   code only have effect once you recompile.\n\n.. note::\n\n   The option ``--follow-import-to`` works as well, but the included\n   modules will only become importable *after* you imported the\n   ``some_module`` name. If these kinds of imports are invisible to\n   Nuitka, e.g. dynamically created, you can use ``--include-module`` or\n   ``--include-package`` in that case, but for static imports it should\n   not be needed.\n\n.. note::\n\n   An extension module can never include other extension modules. You\n   will have to create a wheel for this to be doable.\n\n.. note::\n\n   The resulting extension module can only be loaded into a CPython of\n   the same version and doesn't include other extension modules.\n\nUse Case 3  Package compilation\n================================\n\nIf you need to compile a whole package and embed all modules, that is\nalso feasible, use Nuitka like this:\n\n.. code:: bash\n\n   python -m nuitka --module some_package --include-package=some_package\n\n.. note::\n\n   The inclusion of the package contents needs to be provided manually;\n   otherwise, the package is mostly empty. You can be more specific if\n   you like, and only include part of it, or exclude part of it, e.g.\n   with ``--nofollow-import-to='*.tests'`` you would not include the\n   unused test part of your code.\n\n.. note::\n\n   Data files located inside the package will not be embedded by this\n   process, you need to copy them yourself with this approach.\n   Alternatively, you can use the `file embedding of Nuitka commercial\n   <https://nuitka.net/doc/commercial/protect-data-files.html>`__.\n\nUse Case 4  Program Distribution\n=================================\n\nFor distribution to other systems, there is the standalone mode, which\nproduces a folder for which you can specify ``--standalone``.\n\n.. code:: bash\n\n   python -m nuitka --standalone program.py\n\nFollowing all imports is default in this mode. You can selectively\nexclude modules by specifically saying ``--nofollow-import-to``, but\nthen an ``ImportError`` will be raised when import of it is attempted at\nprogram run time. This may cause different behavior, but it may also\nimprove your compile time if done wisely.\n\nFor data files to be included, use the option\n``--include-data-files=<source>=<target>`` where the source is a file\nsystem path, but the target has to be specified relative. For the\nstandalone mode, you can also copy them manually, but this can do extra\nchecks, and for the onefile mode, there is no manual copying possible.\n\nTo copy some or all file in a directory, use the option\n``--include-data-files=/etc/*.txt=etc/`` where you get to specify shell\npatterns for the files, and a subdirectory where to put them, indicated\nby the trailing slash.\n\n.. important::\n\n   Nuitka does not consider data files code, do not include DLLs, or\n   Python files as data files, and expect them to work, they will not,\n   unless you really know what you are doing.\n\nIn the following, non-code data files are all files, not matching on of\nthese criterions.\n\n+------------+----------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------+\n| Suffix     | Rationale                                                                              | Solution                                                                                               |\n+============+========================================================================================+========================================================================================================+\n| ``.py``    | Nuitka trims even the stdlib modules to be included. If it doesn't see Python code,    | Use ``--include-module`` on them instead                                                               |\n|            | there is no dependencies analyzed, and as a result it will just not work.              |                                                                                                        |\n+------------+----------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------+\n| ``.pyc``   | Same as ``.py``.                                                                       | Use ``--include-module`` on them from their source code instead.                                       |\n+------------+----------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------+\n| ``.pyo``   | Same as ``.pyc``.                                                                      | Use ``--include-module`` on them from their source code instead.                                       |\n+------------+----------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------+\n| ``.pyw``   | Same as ``.py``.                                                                       | For including multiple programs, use multiple ``--main`` arguments instead.                            |\n+------------+----------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------+\n| ``.pyi``   | These are ignored, because they are code-like and not needed at run time. For the      | Raise an issue if 3rd part software needs it.                                                          |\n|            | ``lazy`` package that actually would depend on them, we made a compile time solution   |                                                                                                        |\n|            | that removes the need.                                                                 |                                                                                                        |\n+------------+----------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------+\n| ``.pyx``   | These are ignored, because they are Cython source code not used at run time            |                                                                                                        |\n+------------+----------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------+\n| ``.dll``   | These are ignored, since they **usually** are not data files. For the cases where 3rd  | Create Nuitka Package configuration for those, with ``dll`` section for the package that uses them.    |\n|            | party packages do actually used them as data, e.g. ``.NET`` packages, we solve that in | For rare cases, data-files section with special configuration might be the correct thing to do.        |\n|            | package configuration for it.                                                          |                                                                                                        |\n+------------+----------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------+\n| ``.dylib`` | These are ignored, since they macOS extension modules or DLLs.                         | Need to add configuration with ``dll`` section or ``depends`` that are missing                         |\n+------------+----------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------+\n| ``.so``    | These are ignored, since they Linux, BSD, etc. extension modules or DLLs.              | Need to add configuration with ``dll`` section or ``depends`` that are missing                         |\n+------------+----------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------+\n| ``.exe``   | The are binaries to Windows.                                                           | You can add Nuitka Package configuration to include those as DLLs and mark them as ``executable: yes`` |\n+------------+----------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------+\n| ``.bin``   | The are binaries to non-Windows, otherwise same as ``.exe``.                           |                                                                                                        |\n+------------+----------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------+\n\nAlso folders are ignored, these are ``site-packages``, ``dist-packages``\nand ``vendor-packages`` which would otherwise include a full virtualenv,\nwhich is never a good thing to happen. And the ``__pycache__`` folder is\nalso always ignored. On non-MacOS the file ``.DS_Store`` is ignored too,\nand ``py.typed`` folders have only meaning to IDEs, and are ignored like\n``.pyi`` files .\n\nTo copy a whole folder with all non-code files, you can use\n``--include-data-dir=/path/to/images=images`` which will place those in\nthe destination, and if you want to use the ``--noinclude-data-files``\noption to remove them. Code files are as detailed above DLLs,\nexecutables, Python files, etc. and will be ignored. For those you can\nuse the ``--include-data-files=/binaries/*.exe=binary/`` form to force\nthem, but that is not recommended and known to cause issues at run-time.\n\nFor package data, there is a better way, namely using\n``--include-package-data``, which detects all non-code data files of\npackages automatically and copies them over. It even accepts patterns in\na shell style. It spares you the need to find the package directory\nyourself and should be preferred whenever available. Functionally it's\nvery similar to ``--include-data-dir`` but it has the benefit to locate\nthe correct folder for you.\n\nWith data files, you are largely on your own. Nuitka keeps track of ones\nthat are needed by popular packages, but it might be incomplete. Raise\nissues if you encounter something in these. Even better, raise PRs with\nenhancements to the Nuitka package configuration. We want 3rd party\nsoftware to just work out of the box.\n\nWhen that is working, you can use the onefile mode if you so desire.\n\n.. code:: bash\n\n   python -m nuitka --onefile program.py\n\nThis will create a single binary, that extracts itself on the target,\nbefore running the program. But notice, that accessing files relative to\nyour program is impacted, make sure to read the section `Onefile:\nFinding files`_ as well.\n\n.. code:: bash\n\n   # Create a binary that unpacks into a temporary folder\n   python -m nuitka --onefile program.py\n\n.. note::\n\n   There are more platform-specific options, e.g. related to icons,\n   splash screen, and version information, consider the ``--help``\n   output for the details of these and check the section Tweaks_.\n\nFor the unpacking, by default a unique user temporary path one is used,\nand then deleted, however this default\n``--onefile-tempdir-spec=\"{TEMP}/onefile_{PID}_{TIME}\"`` can be\noverridden with a path specification, then using a cached path, avoiding\nrepeated unpacking, e.g. with\n``--onefile-tempdir-spec=\"{CACHE_DIR}/{COMPANY}/{PRODUCT}/{VERSION}\"``\nwhich uses version information, and user-specific cache directory.\n\n.. note::\n\n   Using cached paths will be relevant, e.g. when Windows Firewall comes\n   into play because otherwise, the binary will be a different one to it\n   each time it is run.\n\nCurrently, these expanded tokens are available:\n\n+----------------+-----------------------------------------------------------+---------------------------------------+\n| Token          | What this Expands to                                      | Example                               |\n+================+===========================================================+=======================================+\n| {TEMP}         | User temporary file directory                             | C:\\\\Users\\\\...\\\\AppData\\\\Locals\\\\Temp |\n+----------------+-----------------------------------------------------------+---------------------------------------+\n| {PID}          | Process ID                                                | 2772                                  |\n+----------------+-----------------------------------------------------------+---------------------------------------+\n| {TIME}         | Time in seconds since the epoch.                          | 1299852985                            |\n+----------------+-----------------------------------------------------------+---------------------------------------+\n| {PROGRAM}      | Full program run-time filename of executable.             | C:\\\\SomeWhere\\\\YourOnefile.exe        |\n+----------------+-----------------------------------------------------------+---------------------------------------+\n| {PROGRAM_BASE} | No-suffix of run-time filename of executable.             | C:\\\\SomeWhere\\\\YourOnefile            |\n+----------------+-----------------------------------------------------------+---------------------------------------+\n| {CACHE_DIR}    | Cache directory for the user.                             | C:\\\\Users\\\\SomeBody\\\\AppData\\\\Local   |\n+----------------+-----------------------------------------------------------+---------------------------------------+\n| {COMPANY}      | Value given as ``--company-name``                         | YourCompanyName                       |\n+----------------+-----------------------------------------------------------+---------------------------------------+\n| {PRODUCT}      | Value given as ``--product-name``                         | YourProductName                       |\n+----------------+-----------------------------------------------------------+---------------------------------------+\n| {VERSION}      | Combination of ``--file-version`` & ``--product-version`` | 3.0.0.0-1.0.0.0                       |\n+----------------+-----------------------------------------------------------+---------------------------------------+\n| {HOME}         | Home directory for the user.                              | /home/somebody                        |\n+----------------+-----------------------------------------------------------+---------------------------------------+\n| {NONE}         | When provided for file outputs, ``None`` is used          | see notice below                      |\n+----------------+-----------------------------------------------------------+---------------------------------------+\n| {NULL}         | When provided for file outputs, ``os.devnull`` is used    | see notice below                      |\n+----------------+-----------------------------------------------------------+---------------------------------------+\n\n.. important::\n\n   It is your responsibility to make the path provided unique, on\n   Windows a running program will be locked, and while using a fixed\n   folder name is possible, it can cause locking issues in that case,\n   where the program gets restarted.\n\n   Usually, you need to use ``{TIME}`` or at least ``{PID}`` to make a\n   path unique, and this is mainly intended for use cases, where e.g.\n   you want things to reside in a place you choose or abide your naming\n   conventions.\n\n.. important::\n\n   For disabling output and stderr with ``--force-stdout-spec`` and\n   ``--force-stderr-spec`` the values ``{NONE}`` and ``{NULL}`` achieve\n   it, but with different effect. With ``{NONE}``, the corresponding\n   handle becomes ``None``. As a result, e.g. ``sys.stdout`` will be\n   ``None``, which is different from ``{NULL}`` where it will be backed\n   by a file pointing to ``os.devnull``, i.e. you can write to it.\n\n   With ``{NONE}``, you may e.g. get ``RuntimeError: lost sys.stdout``\n   in case it does get used; with ``{NULL}`` that never happens.\n   However, some libraries handle this as input for their logging\n   mechanism, and on Windows this is how you are compatible with\n   ``pythonw.exe`` which is behaving like ``{NONE}``.\n\nUse Case 5  Setuptools Wheels\n==============================\n\nIf you have a ``setup.py``, ``setup.cfg`` or ``pyproject.toml`` driven\ncreation of wheels for your software in place, putting Nuitka to use is\nextremely easy.\n\nLet's start with the most common ``setuptools`` approach, you can,\nhaving Nuitka installed of course, simply execute the target\n``bdist_nuitka`` rather than the ``bdist_wheel``. It takes all the\noptions and allows you to specify some more, that are specific to\nNuitka.\n\n.. code:: python\n\n   # For setup.py if you don't use other build systems:\n   setup(\n      # Data files are to be handled by setuptools and not Nuitka\n      package_data={\"some_package\": [\"some_file.txt\"]},\n      ...,\n      # This is to pass Nuitka options.\n      command_options={\n         'nuitka': {\n            # boolean option, e.g. if you cared for C compilation commands\n            '--show-scons': True,\n            # options without value, e.g. enforce using Clang\n            '--clang': None,\n            # options with single values, e.g. enable a plugin of Nuitka\n            '--enable-plugin': \"pyside2\",\n            # options with several values, e.g. avoid including modules\n            '--nofollow-import-to' : [\"*.tests\", \"*.distutils\"],\n         },\n      },\n   )\n\n   # For setup.py with other build systems:\n   # The tuple nature of the arguments is required by the dark nature of\n   # \"setuptools\" and plugins to it, that insist on full compatibility,\n   # e.g. \"setuptools_rust\"\n\n   setup(\n      # Data files are to be handled by setuptools and not Nuitka\n      package_data={\"some_package\": [\"some_file.txt\"]},\n      ...,\n      # This is to pass Nuitka options.\n      ...,\n      command_options={\n         'nuitka': {\n            # boolean option, e.g. if you cared for C compilation commands\n            '--show-scons': (\"setup.py\", True),\n            # options without value, e.g. enforce using Clang\n            '--clang': (\"setup.py\", None),\n            # options with single values, e.g. enable a plugin of Nuitka\n            '--enable-plugin': (\"setup.py\", \"pyside2\"),\n            # options with several values, e.g. avoid including modules\n            '--nofollow-import-to' : (\"setup.py\", [\"*.tests\", \"*.distutils\"]),\n         }\n      },\n   )\n\nIf for some reason, you cannot or do not want to change the target, you\ncan add this to your ``setup.py``.\n\n.. code:: python\n\n   # For setup.py\n   setup(\n      ...,\n      build_with_nuitka=True\n   )\n\n.. note::\n\n   To temporarily disable the compilation, you could the remove above\n   line, or edit the value to ``False`` by or take its value from an\n   environment variable if you so choose, e.g.\n   ``bool(os.getenv(\"USE_NUITKA\", \"True\"))``. This is up to you.\n\nOr you could put it in your ``setup.cfg``\n\n.. code:: toml\n\n   [metadata]\n   build_with_nuitka = true\n\nAnd last, but not least, Nuitka also supports the new ``build`` meta, so\nwhen you have a ``pyproject.toml`` already, simple replace or add this\nvalue:\n\n.. code:: toml\n\n   [build-system]\n   requires = [\"setuptools>=42\", \"wheel\", \"nuitka\", \"toml\"]\n   build-backend = \"nuitka.distutils.Build\"\n\n   # Data files are to be handled by setuptools and not Nuitka\n   [tool.setuptools.package-data]\n   some_package = ['data_file.txt']\n\n   [tool.nuitka]\n   # These are not recommended, but they make it obvious to have effect.\n\n   # boolean option, e.g. if you cared for C compilation commands, leading\n   # dashes are omitted\n   show-scons = true\n\n   # options with single values, e.g. enable a plugin of Nuitka\n   enable-plugin = \"pyside2\"\n\n   # options with several values, e.g. avoid including modules, accepts\n   # list argument.\n   nofollow-import-to = [\"*.tests\", \"*.distutils\"]\n\n.. note::\n\n   For the ``nuitka`` requirement above absolute paths like\n   ``C:\\Users\\...\\Nuitka`` will also work on Linux, use an absolute path\n   with *two* leading slashes, e.g. ``//home/.../Nuitka``.\n\n.. note::\n\n   Whatever approach you take, data files in these wheels are not\n   handled by Nuitka at all, but by setuptools. You can, however, use\n   the data file embedding of Nuitka commercial. In that case, you\n   actually would embed the files inside the extension module itself,\n   and not as a file in the wheel.\n\nUse Case 6  Multidist\n======================\n\nIf you have multiple programs, that each should be executable, in the\npast you had to compile multiple times, and deploy all of these. With\nstandalone mode, this, of course, meant that you were fairly wasteful,\nas sharing the folders could be done, but wasn't really supported by\nNuitka.\n\nEnter ``Multidist``. There is an option ``--main`` that replaces or adds\nto the positional argument given. And it can be given multiple times.\nWhen given multiple times, Nuitka will create a binary that contains the\ncode of all the programs given, but sharing modules used in them. They\ntherefore do not have to be distributed multiple times.\n\nLet's call the basename of the main path, and entry point. The names of\nthese must, of course, be different. Then the created binary can execute\neither entry point, and will react to what ``sys.argv[0]`` appears to\nit. So if executed in the right way (with something like ``subprocess``\nor OS API you can control this name), or by renaming or copying the\nbinary, or symlinking to it, you can then achieve the miracle.\n\nThis allows to combine very different programs into one.\n\n.. note::\n\n   This feature is still experimental. Use with care and report your\n   findings should you encounter anything that is undesirable behavior\n\nThis mode works with standalone, onefile, and mere acceleration. It does\nnot work with module mode.\n\nUse Case 7  Building with GitHub Workflows\n===========================================\n\nFor integration with GitHub workflows there is this `Nuitka-Action\n<https://github.com/Nuitka/Nuitka-Action>`__ that you should use that\nmakes it really easy to integrate. You ought to start with a local\ncompilation though, but this will be easiest for cross platform\ncompilation with Nuitka.\n\nThis is an example workflow that builds on all 3 OSes\n\n.. code:: yaml\n\n   jobs:\n   build:\n      strategy:\n         matrix:\n         os: [macos-latest, ubuntu-latest, windows-latest]\n\n      runs-on: ${{ matrix.os }}\n\n      steps:\n         - name: Check-out repository\n         uses: actions/checkout@v4\n\n         - name: Setup Python\n         uses: actions/setup-python@v5\n         with:\n            python-version: '3.10'\n            cache: 'pip'\n            cache-dependency-path: |\n               **/requirements*.txt\n\n         - name: Install your Dependencies\n         run: |\n            pip install -r requirements.txt -r requirements-dev.txt\n\n         - name: Build Executable with Nuitka\n         uses: Nuitka/Nuitka-Action@main\n         with:\n            nuitka-version: main\n            script-name: your_main_program.py\n            # many more Nuitka options available, see action doc, but it's best\n            # to use nuitka-project: options in your code, so e.g. you can make\n            # a difference for macOS and create an app bundle there.\n            onefile: true\n\n         - name: Upload Artifacts\n         uses: actions/upload-artifact@v3\n         with:\n            name: ${{ runner.os }} Build\n            path: | # match what's created for the 3 OSes\n               build/*.exe\n               build/*.bin\n               build/*.app/**/*\n\nIf you app is a GUI, e.g. ``your_main_program.py`` should contain these\ncomments as explained in `Nuitka Options in the code`_ since on macOS\nthis should then be a bundle.\n\n.. code:: python\n\n   # Compilation mode, standalone everywhere, except on macOS there app bundle\n   # nuitka-project-if: {OS} in (\"Windows\", \"Linux\", \"FreeBSD\"):\n   #    nuitka-project: --onefile\n   # nuitka-project-if: {OS} == \"Darwin\":\n   #    nuitka-project: --standalone\n   #    nuitka-project: --macos-create-app-bundle\n   #\n\n.. note::\n\n   This is best expression with ``nuitka-project: --mode=app`` which\n   encapsulates these options.\n\n********\n Tweaks\n********\n\nIcons\n=====\n\nFor good looks, you may specify icons. On Windows, you can provide an\nicon file, a template executable, or a PNG file. All of these will work\nand may even be combined:\n\n.. code:: bash\n\n   # These create binaries with icons on Windows\n   python -m nuitka --onefile --windows-icon-from-ico=your-icon.png program.py\n   python -m nuitka --onefile --windows-icon-from-ico=your-icon.ico program.py\n   python -m nuitka --onefile --windows-icon-template-exe=your-icon.ico program.py\n\n   # These create application bundles with icons on macOS\n   python -m nuitka --macos-create-app-bundle --macos-app-icon=your-icon.png program.py\n   python -m nuitka --macos-create-app-bundle --macos-app-icon=your-icon.icns program.py\n\n.. note::\n\n   With Nuitka, you do not have to create platform-specific icons, but\n   instead it will convert e.g. PNG, but also other formats on the fly\n   during the build.\n\nMacOS Entitlements\n==================\n\nEntitlements for an macOS application bundle can be added with the\noption, ``--macos-app-protected-resource``, all values are listed on\n`this page from Apple\n<https://developer.apple.com/documentation/bundleresources/information_property_list/protected_resources>`__\n\nAn example value would be\n``--macos-app-protected-resource=NSMicrophoneUsageDescription:Microphone\naccess`` for requesting access to a Microphone. After the colon, the\ndescriptive text is to be given.\n\n.. note::\n\n   Beware that in the likely case of using spaces in the description\n   part, you need to quote it for your shell to get through to Nuitka\n   and not be interpreted as Nuitka arguments.\n\nConsole Window\n==============\n\nOn Windows, the console is not opened by programs unless you say so.\nNuitka defaults to not show it, you can force it by using\n``--console=force`` though, then the program will open a new terminal\nWindow when its executed.\n\nSplash screen\n=============\n\nSplash screens are useful when program startup is slow. Onefile startup\nitself is not slow, but your program may be, and you cannot really know\nhow fast the computer used will be, so it might be a good idea to have\nthem. Luckily, with Nuitka, they are easy to add for Windows.\n\nFor the splash screen, you need to specify it as a PNG file, and then\nmake sure to disable the splash screen when your program is ready, e.g.\nhas completed the imports, prepared the window, connected to the\ndatabase, and wants the splash screen to go away. Here we are using the\nproject syntax to combine the code with the creation, compile this:\n\n.. code:: python\n\n   # nuitka-project: --mode=onefile\n   # nuitka-project: --mode=onefile-windows-splash-screen-image={MAIN_DIRECTORY}/Splash-Screen.png\n\n   # Whatever this is, obviously\n   print(\"Delaying startup by 10s...\")\n   import time, tempfile, os\n   time.sleep(10)\n\n   # Use this code to signal the splash screen removal.\n   if \"NUITKA_ONEFILE_PARENT\" in os.environ:\n      splash_filename = os.path.join(\n         tempfile.gettempdir(),\n         \"onefile_%d_splash_feedback.tmp\" % int(os.environ[\"NUITKA_ONEFILE_PARENT\"]),\n      )\n\n      if os.path.exists(splash_filename):\n         os.unlink(splash_filename)\n\n   print(\"Done... splash should be gone.\")\n   ...\n\n   # Rest of your program goes here.\n\nReports\n=======\n\nFor analysis of your program and Nuitka packaging, there is the\n`Compilation Report`_ available. You can also make custom reports by\nproviding your template, with a few of them built-in to Nuitka. These\nreports carry all the detail information, e.g. when a module was\nattempted to be imported, but not found, you can see where that happens.\nFor bug reporting, it is very much recommended to provide the report.\n\nVersion Information\n===================\n\nYou can attach copyright and trademark information, company name,\nproduct name, and so on to your compilation. This is then used in\nversion information for the created binary on Windows, or application\nbundle on macOS. If you find something that is lacking, please let us\nknow.\n\n******************\n Typical Problems\n******************\n\nDeployment Mode\n===============\n\nBy default, Nuitka compiles without ``--deployment`` which leaves a set\nof safe guards and helpers on, that are aimed at debugging wrong uses of\nNuitka.\n\nThis is a new feature, and implements a bunch of protections and\nhelpers, that are documented here.\n\nFork bombs (self-execution)\n---------------------------\n\nSo after compilation, ``sys.executable`` is the compiled binary. In case\nof packages like ``multiprocessing``, ``joblib``, or ``loky`` what these\ntypically do is to expect to run from a full ``python`` with\n``sys.executable`` and then to be able to use its options like ``-c\ncommand`` or ``-m module_name`` and then be able to launch other code\ntemporarily or permanently as a service daemon.\n\nWith Nuitka however, this executes your program again, and puts these\narguments, in ``sys.argv`` where you maybe ignore them, and then you\nfork yourself again to launch the helper daemons. Sometimes this ends up\nspawning CPU count processes that spawn CPU count processes that... this\nis called a fork bomb, and with almost all systems, that freezes them\neasily to death.\n\nThat is why e.g. this happens with default Nuitka:\n\n.. code::\n\n   ./hello.dist/hello.bin -l fooL -m fooM -n fooN -o fooO -p\n   Error, the program tried to call itself with '-m' argument. Disable with '--no-deployment-flag=self-execution'.\n\nYour program may well have its own command line parsing, and not use an\nunsupported package that does attempt to re-execute. In this case, you\nneed at *compile time* to use ``--no-deployment-flag=self-execution``\nwhich disables this specific guard.\n\nMisleading Messages\n-------------------\n\nSome packages output what they think is helpful information about what\nthe reason of a failed import might mean. With compiled programs there\nare very often just plain wrong. We try and repair those in\nnon-deployment mode. Here is an example, where we change a message that\nasks to pip install (which is not the issue) to point the user to the\ninclude command that makes an ``imageio`` plugin work.\n\n.. code:: yaml\n\n   - module-name: 'imageio.core.imopen'\n     anti-bloat:\n       - replacements_plain:\n           '`pip install imageio[{config.install_name}]` to install it': '`--include-module={config.module_name}` with Nuitka to include it'\n           'err_type = ImportError': 'err_type = RuntimeError'\n         when: 'not deployment'\n\nAnd much more\n-------------\n\nThe deployment mode is relatively new and has constantly more features\nadded, e.g. something for ``FileNotFoundError`` should be coming soon.\n\nDisabling All\n-------------\n\nAll these helpers can of course be disabled at once with\n``--deployment`` but keep in mind that for debugging, you may want to\nre-enable it. You might want to use Nuitka Project options and an\nenvironment variable to make this conditional.\n\nShould you disable them all?\n\nWe believe, disabling should only happen selectively, but with PyPI\nupgrades, your code changes, all of these issues can sneak back in. The\nspace saving of deployment mode is currently negligible, so attempt to\nnot do it, but review what exists, and if you know that it cannot affect\nyou, or if it does, you will not need it. Some of the future ones, will\nclearly be geared at beginner level usage.\n\nWindows Virus scanners\n======================\n\nBinaries compiled on Windows with default settings of Nuitka and no\nfurther actions taken might be recognized by some AV vendors as malware.\nThis is avoidable, but only in Nuitka commercial there is actual support\nand instructions for how to do it, seeing this as a typical commercial\nonly need. https://nuitka.net/doc/commercial.html\n\nLinux Standalone\n================\n\nFor Linux standalone it is pretty difficult to build a binary that works\non other Linux versions. This is mainly because on Linux, much software\nis built specifically targeted to concrete DLLs. Things like glibc used,\nare then encoded into the binary built, and it will not run with an\nolder glibc, just to give one critical example.\n\nThe solution is to build on the oldest OS that you want to see\nsupported. Picking that and setting it up can be tedious, so can be\nlogin, and keeping it secure, as it's something you put your source code\non.\n\nTo aid that, Nuitka commercial has container based builds, that you can\nuse. This uses dedicated optimized Python builds, targets CentOS 7 and\nsupports even newest Pythons and very old OSes that way using recent C\ncompiler chains all turn key solution. The effort needs to be\ncompensated to support Nuitka development for Linux, there you need to\npurchase it https://nuitka.net/doc/commercial.html but even a sponsor\nlicense will be cheaper than doing it yourself.\n\nProgram crashes system (fork bombs)\n===================================\n\nA fork bomb is a program that starts itself over and over. This can\neasily happen, since ``sys.executable`` for compiled programs is not a\nPython interpreter, and packages that try to do multiprocessing in a\nbetter way, often relaunch themselves through this, and Nuitka needs and\ndoes have handling for these with known packages. However, you may\nencounter a situation where the detection of this fails. See deployment\noption above that is needed to disable this protection.\n\nWhen this fork bomb happens easily all memory, all CPU of the system\nthat is available to the user is being used, and even the most powerful\nbuild system will go down in flames sometimes needing a hard reboot.\n\nFor fork bombs, we can use ``--experimental=debug-self-forking`` and see\nwhat it does, and we have a trick, that prevents fork bombs from having\nany actual success in their bombing. Put this at the start of your\nprogram.\n\n.. code:: python\n\n   import os, sys\n\n   if \"NUITKA_LAUNCH_TOKEN\" not in os.environ:\n      sys.exit(\"Error, need launch token or else fork bomb suspected.\")\n   else:\n      del os.environ[\"NUITKA_LAUNCH_TOKEN\"]\n\nActually Nuitka is trying to get ahold of them without the deployment\noption already, finding \"-c\" and \"-m\" options, but it may not be perfect\nor not work well with a package (anymore).\n\nMemory issues and compiler bugs\n===============================\n\nIn some cases, the C compilers will crash saying they cannot allocate\nmemory or that some input was truncated, or similar error messages,\nclearly from it. These are example error messages, that are a sure sign\nof too low memory, there is no end to them.\n\n.. code::\n\n   # gcc\n   fatal error: error writing to -: Invalid argument\n   Killed signal terminated program\n   # MSVC\n   fatal error C1002: compiler is out of heap space in pass 2\n   fatal error C1001: Internal compiler error\n\nThere are several options you can explore here.\n\nAsk Nuitka to use less memory\n-----------------------------\n\nThere is a dedicated option ``--low-memory`` which influences decisions\nof Nuitka, such that it avoids high usage of memory during compilation\nat the cost of increased compile time.\n\nAvoid 32 bit C compiler/assembler memory limits\n-----------------------------------------------\n\nDo not use a 32 bit compiler, but a 64 bit one. If you are using Python\nwith 32 bits on Windows, you most definitely ought to use MSVC as the C\ncompiler, and not MinGW64. The MSVC is a cross-compiler, and can use\nmore memory than gcc on that platform. If you are not on Windows, that\nis not an option, of course. Also, using the 64 bit Python will work.\n\nUse a minimal virtualenv\n------------------------\n\nWhen you compile from a living installation, that may well have many\noptional dependencies of your software installed. Some software will\nthen have imports on these, and Nuitka will compile them as well. Not\nonly may these be just the troublemakers, they also require more memory,\nso get rid of that. Of course, you do have to check that your program\nhas all the needed dependencies before you attempt to compile, or else\nthe compiled program will equally not run.\n\nUse LTO compilation or not\n--------------------------\n\nWith ``--lto=yes`` or ``--lto=no`` you can switch the C compilation to\nonly produce bytecode, and not assembler code and machine code directly,\nbut make a whole program optimization at the end. This will change the\nmemory usage pretty dramatically, and if your error is coming from the\nassembler, using LTO will most definitely avoid that.\n\nSwitch the C compiler to clang\n------------------------------\n\nPeople have reported that programs that fail to compile with gcc due to\nits bugs or memory usage work fine with clang on Linux. On Windows, this\ncould still be an option, but it needs to be implemented first for the\nautomatic downloaded gcc, that would contain it. Since MSVC is known to\nbe more memory effective anyway, you should go there, and if you want to\nuse Clang, there is support for the one contained in MSVC.\n\nAdd a larger swap file to your embedded Linux\n---------------------------------------------\n\nOn systems with not enough RAM, you need to use swap space. Running out\nof it is possibly a cause, and adding more swap space, or one at all,\nmight solve the issue, but beware that it will make things extremely\nslow when the compilers swap back and forth, so consider the next tip\nfirst or on top of it.\n\nLimit the amount of compilation jobs\n------------------------------------\n\nWith the ``--jobs`` option of Nuitka, it will not start many C compiler\ninstances at once, each competing for the scarce resource of RAM. By\npicking a value of one, only one C compiler instance will be running,\nand on an 8 core system, that reduces the amount of memory by factor 8,\nso that's a natural choice right there.\n\nDynamic ``sys.path``\n====================\n\nIf your script modifies ``sys.path``, e.g. inserts directories with\nsource code relative to it, Nuitka will not be able to see those.\nHowever, if you set the ``PYTHONPATH`` to the resulting value, it will\nbe able to compile it and find the used modules from these paths as\nwell.\n\nManual Python File Loading\n==========================\n\nA very frequent pattern with private code is that it scans plugin\ndirectories of some kind, and e.g. uses ``os.listdir``, then considers\nPython filenames, and then opens a file and does ``exec`` on them. This\napproach works for Python code, but for compiled code, you should use\nthis much cleaner approach, that works for pure Python code and is a lot\nless vulnerable.\n\n.. code:: python\n\n   # Using a package name, to locate the plugins. This is also a sane\n   # way to organize them into a directory.\n   scan_path = scan_package.__path__\n\n   for item in pkgutil.iter_modules(scan_path):\n      importlib.import_module(scan_package.__name__ + \".\" + item.name)\n\n      # You may want to do it recursively, but we don't do this here in\n      # this example. If you'd like to, handle that in this kind of branch.\n      if item.ispkg:\n         ...\n\nMissing data files in standalone\n================================\n\nIf your program fails to find data file, it can cause all kinds of\ndifferent behavior, e.g. a package might complain it is not the right\nversion because a ``VERSION`` file check defaulted to an unknown. The\nabsence of icon files or help texts, may raise strange errors.\n\nOften the error paths for files not being present are even buggy and\nwill reveal programming errors like unbound local variables. Please look\ncarefully at these exceptions, keeping in mind that this can be the\ncause. If your program works without standalone, chances are data files\nmight be the cause.\n\nThe most common error indicating file absence is of course an uncaught\n``FileNotFoundError`` with a filename. You should figure out what\npackage is missing files and then use ``--include-package-data``\n(preferably), or ``--include-data-dir``/``--include-data-files`` to\ninclude them.\n\nMissing DLLs/EXEs in standalone\n===============================\n\nNuitka has plugins that deal with copying DLLs. For NumPy, SciPy,\nTkinter, etc.\n\nThese need special treatment to be able to run on other systems.\nManually copying them is not enough and will give strange errors.\nSometimes newer version of packages, esp. NumPy can be unsupported. In\nthis case, you will have to raise an issue, and use the older one.\n\nIf you want to manually add a DLL or an EXE because it is your project\nonly, you will have to use user Yaml files describing where they can be\nfound. This is described in detail with examples in the `Nuitka Package\nConfiguration <https://nuitka.net/doc/nuitka-package-config.html>`__\npage.\n\nDependency creep in standalone\n==============================\n\nSome packages are a single import, but to Nuitka mean that more than a\nthousand packages (literally) are to be included. The prime example of\nPandas, which does want to plug and use just about everything you can\nimagine. Multiple frameworks for syntax highlighting everything\nimaginable take time.\n\nNuitka will have to learn effective caching to deal with this in the\nfuture. Presently, you will have to deal with huge compilation times for\nthese.\n\nA major weapon in fighting dependency creep should be applied, namely\nthe ``anti-bloat`` plugin, which offers interesting abilities, that can\nbe put to use and block unneeded imports, giving an error for where they\noccur. Use it e.g. like this ``--noinclude-pytest-mode=nofollow\n--noinclude-setuptools-mode=nofollow`` and e.g. also\n``--noinclude-custom-mode=setuptools:error`` to get the compiler to\nerror out for a specific package. Make sure to check its help output. It\ncan take for each module of your choice, e.g. forcing also that e.g.\n``PyQt5`` is considered uninstalled for standalone mode.\n\nIt's also driven by a configuration file, ``anti-bloat.yml`` that you\ncan contribute to, removing typical bloat from packages. Please don't\nhesitate to enhance it and make PRs towards Nuitka with it.\n\nStandalone: Finding files\n=========================\n\nThe standard code that normally works, also works, you should refer to\n``os.path.dirname(__file__)`` or use all the packages like ``pkgutil``,\n``pkg_resources``, ``importlib.resources`` to locate data files near the\nstandalone binary.\n\n.. important::\n\n   What you should **not** do, is use the current directory\n   ``os.getcwd``, or assume that this is the script directory, e.g. with\n   paths like ``data/``.\n\n   If you did that, it was never good code. Links, to a program,\n   launching from another directory, etc. will all fail in bad ways. Do\n   not make assumptions about the directory your program is started\n   from.\n\nIn case you mean to refer to the location of the ``.dist`` folder for\nfiles that are to reside near the binary, there is\n``__compiled__.containing_dir`` that also abstracts all differences with\n``--macos-create-app-bundle`` and the ``.app`` folder a having more\nnested structure.\n\n.. code:: python\n\n   # This will find a file *near* your app or dist folder\n   try:\n      open(os.path.join(__compiled__.containing_dir, \"user-provided-file.txt\"))\n   except NameError:\n      open(os.path.join(os.path.dirname(sys.argv[0]), \"user-provided-file.txt\"))\n\nOnefile: Finding files\n======================\n\nThere is a difference between ``sys.argv[0]`` and ``__file__`` of the\nmain module for the onefile mode, that is caused by using a bootstrap to\na temporary location. The first one will be the original executable\npath, whereas the second one will be the temporary or permanent path the\nbootstrap executable unpacks to. Data files will be in the later\nlocation, your original environment files will be in the former\nlocation.\n\nGiven 2 files, one which you expect to be near your executable, and one\nwhich you expect to be inside the onefile binary, access them like this.\n\n.. code:: python\n\n   # This will find a file *near* your onefile.exe\n   open(os.path.join(os.path.dirname(sys.argv[0]), \"user-provided-file.txt\"))\n   # This will find a file *inside* your onefile.exe\n   open(os.path.join(os.path.dirname(__file__), \"user-provided-file.txt\"))\n\n   # This will find a file *near* your onefile binary and work for standalone too\n   try:\n      open(os.path.join(__compiled__.containing_dir, \"user-provided-file.txt\"))\n   except NameError:\n      open(os.path.join(os.path.dirname(sys.argv[0]), \"user-provided-file.txt\"))\n\n.. note::\n\n   When the program is launched from the executable, the original\n   ``sys.argv[0]`` from the invocation command line will not be\n   preserved, it will be made an absolute path.\n\n   For advanced use cases where one needs access to the original\n   ``sys.argv[0]``, it may be found at ``__compiled__.original_argv0``.\n   The field will read back as ``None`` if the program is not launched\n   from the onefile executable, thus not having gone through the onefile\n   bootstrap stage; the original ``sys.argv[0]`` would be preserved as\n   well in this case.\n\n.. code:: python\n\n   # Suppose the onefile binary is placed at /opt/abc/bin/foo, and it was\n   # symlinked to /usr/local/bin/bar, and invoked as `bar ...`:\n   assert sys.argv[0] == \"/usr/local/bin/bar\"\n   assert __compiled__.original_argv0 == \"bar\"\n\n   # If the onefile tempdir is overridden and the program is invoked\n   # directly from the unpacked location, sys.argv[0] would not be touched.\n   #\n   # Suppose the onefile tempdir is /home/xx/.cache/abc/0.1.2, and the\n   # foo.bin executable inside is symlinked to /usr/local/bin/baz, and\n   # invoked as `baz ...`:\n   assert sys.argv[0] == \"baz\"\n   assert __compiled__.original_argv0 is None\n\nWindows Programs without console give no errors\n===============================================\n\nFor debugging purposes, use the options ``--force-stdout-spec`` and\n``--force-stderr-spec`` with paths as documented for\n``--onefile-tempdir-spec`` above. These can be relative to the program\nor absolute, so you can see the outputs given. Also you can run the\nprogram on a terminal prompt like ``CMD.exe`` to see its outputs.\n\nDeep copying uncompiled functions\n=================================\n\nSometimes people use this kind of code, which for packages on PyPI, we\ndeal with by doing source code patches on the fly. If this is in your\nown code, here is what you can do:\n\n.. code:: python\n\n   def binder(func, name):\n      result = types.FunctionType(func.__code__, func.__globals__, name=func.__name__, argdefs=func.__defaults__, closure=func.__closure__)\n      result = functools.update_wrapper(result, func)\n      result.__kwdefaults__ = func.__kwdefaults__\n      result.__name__ = name\n      return result\n\nCompiled functions cannot be used to create uncompiled ones from, so the\nabove code will not work. However, there is a dedicated ``clone``\nmethod, that is specific to them, so use this instead.\n\n.. code:: python\n\n   def binder(func, name):\n      try:\n         result = func.clone()\n      except AttributeError:\n         result = types.FunctionType(func.__code__, func.__globals__, name=func.__name__, argdefs=func.__defaults__, closure=func.__closure__)\n         result = functools.update_wrapper(result, func)\n         result.__kwdefaults__ = func.__kwdefaults__\n\n      result.__name__ = name\n      return result\n\nModules: Extension modules are not executable directly\n======================================================\n\nA package can be compiled with Nuitka, no problem, but when it comes to\nexecuting it, ``python -m compiled_module`` is not going to work and\ngive the error ``No code object available for AssertsTest`` because the\ncompiled module is not source code, and Python will not just load it.\nThe closest would be ``python -c \"import compile_module\"`` and you might\nhave to call the main function yourself.\n\nTo support this, the CPython ``runpy`` and/or ``ExtensionFileLoader``\nwould need improving such that Nuitka could supply its compiled module\nobject for Python to use.\n\n******\n Tips\n******\n\nNuitka Options in the code\n==========================\n\nOne clean way of providing options to Nuitka, that you will always use\nfor your program, is to put them into the main file you compile. There\nis even support for conditional options, and options using pre-defined\nvariables, this is an example:\n\n.. code:: python\n\n   # Compilation mode, support OS-specific options\n   # nuitka-project-if: {OS} in (\"Windows\", \"Linux\", \"Darwin\", \"FreeBSD\"):\n   #    nuitka-project: --mode=app\n   # nuitka-project-else:\n   #    nuitka-project: --mode=standalone\n\n   # The PySide2 plugin covers qt-plugins\n   # nuitka-project: --enable-plugin=pyside2\n   # nuitka-project: --include-qt-plugins=qml\n\nThe comments must be at the start of lines, and indentation inside of\nthem is to be used, to end a conditional block, much like in Python.\nThere are currently no other keywords than the used ones demonstrated\nabove.\n\nYou can put arbitrary Python expressions there, and if you wanted to\ne.g. access a version information of a package, you could simply use\n``__import__(\"module_name\").__version__`` if that would be required to\ne.g. enable or disable certain Nuitka settings. The only thing Nuitka\ndoes that makes this not Python expressions, is expanding ``{variable}``\nfor a pre-defined set of variables:\n\nTable with supported variables:\n\n+------------------+--------------------------------+------------------------------------------+\n| Variable         | What this Expands to           | Example                                  |\n+==================+================================+==========================================+\n| {OS}             | Name of the OS used            | Linux, Windows, Darwin, FreeBSD, OpenBSD |\n+------------------+--------------------------------+------------------------------------------+\n| {Version}        | Version of Nuitka              | e.g. (1, 6, 0)                           |\n+------------------+--------------------------------+------------------------------------------+\n| {Commercial}     | Version of Nuitka Commercial   | e.g. (2, 1, 0)                           |\n+------------------+--------------------------------+------------------------------------------+\n| {Arch}           | Architecture used              | x86_64, arm64, etc.                      |\n+------------------+--------------------------------+------------------------------------------+\n| {MAIN_DIRECTORY} | Directory of the compiled file | some_dir/maybe_relative                  |\n+------------------+--------------------------------+------------------------------------------+\n| {Flavor}         | Variant of Python              | e.g. Debian Python, Anaconda Python      |\n+------------------+--------------------------------+------------------------------------------+\n\nThe use of ``{MAIN_DIRECTORY}`` is recommended when you want to specify\na filename relative to the main script, e.g. for use in data file\noptions or user package configuration yaml files,\n\n.. code:: python\n\n   # nuitka-project: --include-data-files={MAIN_DIRECTORY}/my_icon.png=my_icon.png\n   # nuitka-project: --user-package-configuration-file={MAIN_DIRECTORY}/user.nuitka-package.config.yml\n\nPython command line flags\n=========================\n\nFor passing things like ``-O`` or ``-S`` to Python, to your compiled\nprogram, there is a command line option name ``--python-flag=`` which\nmakes Nuitka emulate these options.\n\nThe most important ones are supported, more can certainly be added.\n\nCaching compilation results\n===========================\n\nThe C compiler, when invoked with the same input files, will take a long\ntime and much CPU to compile over and over. Make sure you are having\n``ccache`` installed and configured when using gcc (even on Windows). It\nwill make repeated compilations much faster, even if things are not yet\nperfect, i.e. changes to the program can cause many C files to change,\nrequiring a new compilation instead of using the cached result.\n\nOn Windows, with gcc, Nuitka supports using ``ccache.exe``, which it\nwill offer to download from an official source and install it\nautomatically. This is the recommended way of using it on Windows, as\nother versions may cause issues e.g. hanging.\n\nNuitka will pick up ``ccache`` if it's found in system ``PATH``, and it\nwill also be possible to provide if by setting ``NUITKA_CCACHE_BINARY``\nto the full path of the binary, this is for use in CI systems where\nenvironments might be non-standard.\n\nFor the MSVC compilers and ClangCL setups, using the ``clcache`` is\nautomatic and included in Nuitka.\n\nOn macOS and Intel, there is an automatic download of a ``ccache``\nbinary from our site, for arm64 arches, it's recommended to use this\nsetup, which installs Homebrew and ccache in there. Nuitka picks that\none up automatically if it on that kind of machine. You need and should\nnot use Homebrew with Nuitka otherwise, it's not the best for standalone\ndeployments, but we can take ``ccache`` from there.\n\n.. code:: bash\n\n   export HOMEBREW_INSTALL_FROM_API=1\n   /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)\"\n   eval $(/opt/homebrew/bin/brew shellenv)\n   brew install ccache\n\nControl where Caches live\n=========================\n\nThe storage for cache results of all kinds, downloads, cached\ncompilation results from C and Nuitka, is done in a platform dependent\ndirectory as determined by the ``appdirs`` package. However, you can\noverride it with setting the environment variable ``NUITKA_CACHE_DIR``\nto a base directory. This is for use in environments where the home\ndirectory is not persisted, but other paths are.\n\nThere is also per cache control of these caches, here is a table of\nenvironment variables that you can set before starting the compilation,\nto make Nuitka store some of these caches in an entirely separate space.\n\n+------------------+-----------------------------------+----------------------------------------+\n| Cache name       | Environment Variable              | Data Put there                         |\n+==================+===================================+========================================+\n| downloads        | NUITKA_CACHE_DIR_DOWNLOADS        | Downloads made, e.g. dependency walker |\n+------------------+-----------------------------------+----------------------------------------+\n| ccache           | NUITKA_CACHE_DIR_CCACHE           | Object files created by gcc            |\n+------------------+-----------------------------------+----------------------------------------+\n| clcache          | NUITKA_CACHE_DIR_CLCACHE          | Object files created by MSVC           |\n+------------------+-----------------------------------+----------------------------------------+\n| bytecode         | NUITKA_CACHE_DIR_BYTECODE         | Bytecode of demoted modules            |\n+------------------+-----------------------------------+----------------------------------------+\n| dll-dependencies | NUITKA_CACHE_DIR_DLL_DEPENDENCIES | DLL dependencies                       |\n+------------------+-----------------------------------+----------------------------------------+\n\nRunners\n=======\n\nAvoid running the ``nuitka`` binary, doing ``python -m nuitka`` will\nmake a 100% sure you are using what you think you are. Using the wrong\nPython will make it give you ``SyntaxError`` for good code or\n``ImportError`` for installed modules. That is happening, when you run\nNuitka with Python2 on Python3 code and vice versa. By explicitly\ncalling the same Python interpreter binary, you avoid that issue\nentirely.\n\nFastest C Compilers\n===================\n\nThe fastest binaries of ``pystone.exe`` on Windows with 64 bits Python\nproved to be significantly faster with MinGW64, roughly 20% better\nscore. So it is recommended for use over MSVC. Using ``clang-cl.exe`` of\nClang7 was faster than MSVC, but still significantly slower than\nMinGW64, and it will be harder to use, so it is not recommended.\n\nOn Linux, for ``pystone.bin``, the binary produced by ``clang6`` was\nfaster than ``gcc-6.3``, but not by a significant margin. Since gcc is\nmore often already installed, that is recommended to use for now.\n\nDifferences in C compilation times have not yet been examined.\n\nUnexpected Slowdowns\n====================\n\nUsing the Python DLL, like standard CPython does, can lead to unexpected\nslowdowns, e.g. in uncompiled code that works with Unicode strings. This\nis because calling to the DLL rather than residing in the DLL causes\noverhead, and this even happens to the DLL with itself, being slower,\nthan a Python all contained in one binary.\n\nSo if feasible, aim at static linking, which is currently only possible\nwith Anaconda Python on non-Windows, Debian Python2, self compiled\nPythons (do not activate ``--enable-shared``, not needed), and installs\ncreated with ``pyenv``.\n\n.. note::\n\n   On Anaconda, you may need to execute ``conda install\n   libpython-static``\n\nStandalone executables and dependencies\n=======================================\n\nThe process of making standalone executables for Windows traditionally\ninvolves using an external dependency walker to copy necessary libraries\nalong with the compiled executables to the distribution folder.\n\nThere are plenty of ways to find that something is missing. Do not\nmanually copy things into the folder, esp. not DLLs, as that's not going\nto work. Instead, make bug reports to get these handled by Nuitka\nproperly.\n\nWindows errors with resources\n=============================\n\nOn Windows, the Windows Defender tool and the Windows Indexing Service\nboth scan the freshly created binaries, while Nuitka wants to work with\nit, e.g. adding more resources, and then preventing operations randomly\ndue to holding locks. Make sure to exclude your compilation stage from\nthese services.\n\nWindows standalone program redistribution\n=========================================\n\nWhether compiling with MingW or MSVC, the standalone programs have\nexternal dependencies to Visual C Runtime libraries. Nuitka tries to\nship those dependent DLLs by copying them from your system.\n\nBeginning with Microsoft Windows 10, Microsoft ships ``ucrt.dll``\n(Universal C Runtime libraries) which handles calls to\n``api-ms-crt-*.dll``.\n\nWith earlier Windows platforms (and wine/ReactOS), you should consider\ninstalling Visual C runtime libraries before executing a Nuitka\nstandalone compiled program.\n\nDepending on the used C compiler, you'll need the following redist\nversions on the target machines. However, notice that compilation using\nthe 14.3 based version is always recommended, working and best\nsupported, unless you want to target Windows 7.\n\n+------------------+-------------+----------+\n| Visual C version | Redist Year | CPython  |\n+==================+=============+==========+\n| 14.3             | 2022        | 3.11     |\n+------------------+-------------+----------+\n| 14.2             | 2019        | 3.5-3.10 |\n+------------------+-------------+----------+\n| 14.1             | 2017        | 3.5-3.8  |\n+------------------+-------------+----------+\n| 14.0             | 2015        | 3.5-3.8  |\n+------------------+-------------+----------+\n| 10.0             | 2010        | 3.4      |\n+------------------+-------------+----------+\n| 9.0              | 2008        | 2.6, 2.7 |\n+------------------+-------------+----------+\n\nWhen using MingGW64 as downloaded by Nuitka, you'll need the following\nredist versions:\n\n+----------------------------+-------------+---------------------+\n| MingGW64 version           | Redist Year | CPython             |\n+============================+=============+=====================+\n| WinLibs automatic download | 2015        | 2.6, 2.7, 3.4- 3.11 |\n+----------------------------+-------------+---------------------+\n\nOnce the corresponding runtime libraries are installed on the target\nsystem, you may remove all ``api-ms-crt-*.dll`` files from your Nuitka\ncompiled dist folder.\n\nDetecting Nuitka at run time\n============================\n\nNuitka does *not* ``sys.frozen`` unlike other tools because it usually\ntriggers inferior code for no reason. For Nuitka, we have the module\nattribute ``__compiled__`` to test if a specific module was compiled,\nand the function attribute ``__compiled__`` to test if a specific\nfunction was compiled.\n\nProviding extra Options to Nuitka C compilation\n===============================================\n\nNuitka will apply values from the environment variables ``CCFLAGS``,\n``LDFLAGS`` during the compilation on top of what it determines to be\nnecessary. Beware, of course, that this is only useful if you know what\nyou are doing, so should this pose issues, raise them only with perfect\ninformation.\n\nProducing a 32 bit binary on a 64 bit Windows system\n====================================================\n\nNuitka will automatically target the architecture of the Python you are\nusing. If this is 64 bit, it will create a 64 bit binary, if it is 32\nbit, it will create a 32 bit binary. You have the option to select the\nbits when you download the Python. In the output of ``python -m nuitka\n--version`` there is a line for the architecture. It's ``Arch: x86_64``\nfor 64 bits, and just ``Arch: x86`` for 32 bits.\n\nThe C compiler will be picked to match that more or less automatically.\nIf you specify it explicitly, and it mismatches, you will get a warning\nabout the mismatch and informed that your compiler choice was rejected.\n\n********************\n Compilation Report\n********************\n\nWhen you use ``--report=compilation-report.xml`` Nuitka will create an\nXML file with detailed information about the compilation and packaging\nprocess. This is growing in completeness with every release and exposes\nmodule usage attempts, timings of the compilation, plugin influences,\ndata file paths, DLLs, and reasons why things are included or not.\n\nAt this time, the report contains absolute paths in some places, with\nyour private information. The goal is to make this blended out by\ndefault because we also want to become able to compare compilation\nreports from different setups, e.g. with updated packages, and see the\nchanges to Nuitka. The report is, however, recommended for your bug\nreporting.\n\nAlso, another form is available, where the report is free form and\naccording to a Jinja2 template of yours, and one that is included in\nNuitka. The same information as used to produce the XML file is\naccessible. However, right now, this is not yet documented, but we plan\nto add a table with the data. For a reader of the source code that is\nfamiliar with Jinja2, however, it will be easy to do it now already.\n\nIf you have a template, you can use it like this\n``--report-template=your_template.rst.j2:your_report.rst`` and of\ncourse, the usage of restructured text, is only an example. You can use\nMarkdown, your own XML, or whatever you see fit. Nuitka will just expand\nthe template with the compilation report data.\n\nCurrently, the following reports are included in Nuitka. You just use\nthe name as a filename, and Nuitka will pick that one instead.\n\n+---------------+--------------+--------------------------------------------------------+\n| Report Name   | Status       | Purpose                                                |\n+===============+==============+========================================================+\n| LicenseReport | experimental | Distributions used in a compilation with license texts |\n+---------------+--------------+--------------------------------------------------------+\n\n.. note::\n\n   The community can and should contribute more report types and help\n   enhancing the existing ones for good looks.\n\n*************\n Performance\n*************\n\nThis chapter gives an overview, of what to currently expect in terms of\nperformance from Nuitka. It's a work in progress and is updated as we\ngo. The current focus for performance measurements is Python 2.7, but\n3.x is going to follow later.\n\npystone results\n===============\n\nThe results are the top value from this kind of output, running pystone\n1000 times and taking the minimal value. The idea is that the fastest\nrun is most meaningful, and eliminates usage spikes.\n\n.. code:: bash\n\n   echo \"Uncompiled Python2\"\n   for i in {1..100}; do BENCH=1 python2 tests/benchmarks/pystone.py ; done | sort -rn | head -n 1\n   python2 -m nuitka --lto=yes --pgo-c tests/benchmarks/pystone.py\n   echo \"Compiled Python2\"\n   for i in {1..100}; do BENCH=1 ./pystone.bin ; done | sort -n | head -rn 1\n\n   PYTHON3=python3.10\n\n   # Using a 100 gives semi-reliable values already, 1000 for best accuracy.\n   RUNS=1000\n\n   $PYTHON3 -m nuitka --lto=yes --pgo-c --static-libpython=yes tests/benchmarks/pystone3.py\n   echo \"Uncompiled $PYTHON3\"\n   for i in $(seq 1 $RUNS); do BENCH=1 $PYTHON3 tests/benchmarks/pystone3.py ; done | sort -rn | head -n 1\n   echo \"Compiled $PYTHON3\"\n   for i in $(seq 1 $RUNS); do BENCH=1 ./pystone3.bin ; done | sort -rn | head -n 1\n\n+-------------------+-------------------+----------------------+---------------------+\n| Python            | Uncompiled        | Compiled LTO         | Compiled PGO        |\n+===================+===================+======================+=====================+\n| Debian Python 2.7 | 137497.87 (1.000) | 460995.20 (3.353)    | 503681.91 (3.663)   |\n+-------------------+-------------------+----------------------+---------------------+\n| Nuitka Python 2.7 | 144074.78 (1.048) | 479271.51 (3.486)    | 511247.44 (3.718)   |\n+-------------------+-------------------+----------------------+---------------------+\n\nReport issues or bugs\n=====================\n\nShould you encounter any issues, bugs, or ideas, please visit the\n`Nuitka bug tracker <https://github.com/Nuitka/Nuitka/issues>`__ and\nreport them.\n\nBest practices for reporting bugs:\n\n-  Please always include the following information in your report, for\n   the underlying Python version. You can easily copy&paste this into\n   your report. It does contain more information than you think. Do not\n   write something manually. You may always add, of course,\n\n   .. code:: bash\n\n      python -m nuitka --version\n\n-  Try to make your example minimal. That is, try to remove code that\n   does not contribute to the issue as much as possible. Ideally, come\n   up with a small reproducing program that illustrates the issue, using\n   ``print`` with different results when the program runs compiled or\n   native.\n\n-  If the problem occurs spuriously (i.e. not each time), try to set the\n   environment variable ``PYTHONHASHSEED`` to ``0``, disabling hash\n   randomization. If that makes the problem go away, try increasing in\n   steps of 1 to a hash seed value that makes it happen every time,\n   include it in your report.\n\n-  Do not include the created code in your report. Given proper input,\n   it's redundant, and it's not likely that I will look at it without\n   the ability to change the Python or Nuitka source and re-run it.\n\n-  Do not send screenshots of text, that is bad and lazy. Instead,\n   capture text outputs from the console.\n\n***************************\n Unsupported functionality\n***************************\n\nThe ``co_code`` attribute of code objects\n=========================================\n\nThe code objects are empty for native compiled functions. There is no\nbytecode with Nuitka's compiled function objects, so there is no way to\nprovide it.\n\nPDB\n===\n\nThere is no tracing of compiled functions to attach a debugger to.\n"
        },
        {
          "name": "SECURITY.md",
          "type": "blob",
          "size": 0.810546875,
          "content": "# Security Policy\n\n## Supported Versions\n\nThere are no LTS supported versions of Nuitka, but mostly the stable version is\nhot-fixed, and would be for security issues. If possible, git rebases would be\ndone just as they are for corruption bugs, which would then allow to use these,\nbut usually newer Nuitka is the expected to use version, with main always being\nas bug free as possible.\n\n| Version | Supported          |\n| ------- | ------------------ |\n| main    | :white_check_mark: |\n| develop | :white_check_mark: |\n\n## Reporting a Vulnerability\n\nWhen you email me at `kay.hayen@gmail.com` with a well defined report, I\nguarantee a reaction within 72h, and correction as soon as possible. Generally\nprivate emails are not acceptable for questions, there I would point to GitHub,\nbut for sensitive information only, it's great.\n"
        },
        {
          "name": "Standard-Plugins-Documentation.rst",
          "type": "blob",
          "size": 6.630859375,
          "content": "#######################################\n Nuitka Standard Plugins Documentation\n#######################################\n\n.. |ups| replace::\n\n   user plugins\n\n.. |sps| replace::\n\n   standard plugins\n\n.. |ops| replace::\n\n   optional standard plugins\n\n****************************\n Background: Nuitka Plugins\n****************************\n\nPlugins are a feature to modify the way how Nuitka compiles Python\nprograms in extremely flexible ways.\n\nPlugins can automatically include data files and additional shared\nlibraries, import modules which are not detectable by source code\nanalysis, modify or extend the to-be-compiled source code, gather\nstatistics, change Nuitka's parameter defaults and much more.\n\nAny number of plugins may be used in each compilation.\n\nPlugins come in two variants: **standard** plugins and **user** plugins.\n\nUser plugins are not part of the Nuitka package: they must be provided\notherwise. To use them in a compilation, Nuitka must be able to find\nthem using their path / filename. If |ups| are specified, Nuitka will\nactivate them **before** it activates any of its standard plugins.\n\nStandard plugins are part of the Nuitka package and thus always\navailable.\n\nNuitka also differentiates between \"mandatory\" and \"optional\" |sps|.\n\n**Mandatory** |sps| are always enabled and \"invisible\" to the user.\nTheir behavior cannot be influenced other than by modifying them.\n\n**Optional** |sps| must be enabled via the command line parameter\n``--enable-plugin=name``, with an identifying string ``name``. Even when\nnot enabled however, |ops| can detect, whether their use might have been\n\"forgotten\" and issue an appropriate warning.\n\nWhere appropriate, the behaviour of optional |sps| (like with |ups|) can\nbe controlled via *options* (see \"Using Plugin Options\").\n\n*******************\n A Word of Caution\n*******************\n\nAlmost all |ops| are relevant for standalone mode only. Specifying all\nthe right plugins is up to the user and critical for success: For\nexample, if you are using package *numpy* and forget to activate that\nplugin, then your compile will\n\n-  end with no error, but a warning about missing numpy support,\n\n-  not generate a working binary.\n\nAlso:\n\n-  |ups| are able to programmatically enable |ops|, the **reverse is not\n   possible**. The user must know the requirements of his script and\n   specify all appropriate |ops|, including any required *options* (see\n   below).\n\n-  There is currently no way to automatically react to\n   interdependencies. For example, when compiling a script using the\n   *tensorflow* package in standalone mode, you must enable (at least)\n   **both**, the ``tensorflow`` **and** the ``numpy`` plugin.\n\n-  Like every compiler, Nuitka cannot always decide, whether a script\n   will **actually execute** an *import* statement. This knowledge must\n   be provided by you, e.g. with PGO information that is going to be\n   supported.\n\n***********************************\n List of Optional Standard Plugins\n***********************************\n\nCreate a list of available optional |sps| giving their identifier\ntogether with a short description via ``--plugin-list``:\n\nThe following optional standard plugins are available in Nuitka:\n\n.. code::\n\n   anti-bloat            Patch stupid imports out of widely used library modules source codes.\n   data-files\n   data-hiding           Commercial: Hide program constant Python data from offline inspection of created binaries.\n   datafile-inclusion-ng Commercial: Load file trusted file contents at compile time.\n   dill-compat\n   enum-compat\n   ethereum              Commercial: Required for ethereum packages in standalone mode\n   eventlet              Support for including 'eventlet' dependencies and its need for 'dns' package monkey patching\n   gevent                Required by the gevent package\n   gi                    Support for GI dependencies\n   glfw                  Required for glfw in standalone mode\n   implicit-imports\n   multiprocessing       Required by Python's multiprocessing module\n   numpy                 Required for numpy, scipy, pandas, matplotlib, etc.\n   pbr-compat\n   pkg-resources         Resolve version numbers at compile time.\n   pmw-freezer           Required by the Pmw package\n   pylint-warnings       Support PyLint / PyDev linting source markers\n   pyqt5                 Required by the PyQt5 package.\n   pyside2               Required by the PySide2 package.\n   pyside6               Required by the PySide6 package for standalone mode.\n   pyzmq                 Required for pyzmq in standalone mode\n   tensorflow            Required by the tensorflow package\n   tk-inter              Required by Python's Tk modules\n   torch                 Required by the torch / torchvision packages\n   traceback-encryption  Commercial: Encrypt tracebacks (de-Jong-Stacks).\n   windows-service       Commercial: Create Windows Service files\n\n.. note::\n\n   This list is continuously growing and most likely out of date.\n\n*****************************************\n Optional Standard Plugins Documentation\n*****************************************\n\ndill-compat\n===========\n\n-  Required by the *dill* module. Dill extends Python's pickle module\n   for serializing and de-serializing objects.\n\n-  Options: none.\n\neventlet\n========\n\n-  Required by the *eventlet* package. Eventlet is a concurrent\n   networking library.\n\n-  Options: none.\n\ngevent\n======\n\n-  Required by the *gevent* package. Gevent is a coroutine-based Python\n   networking library that uses greenlet to provide a high-level\n   synchronous API.\n\n-  Options: none.\n\npmw-freezer\n===========\n\n-  Required by the *Pmw* package. Pmw is a toolkit for building\n   high-level compound widgets.\n\n-  Options: none.\n\npylint-warnings\n===============\n\n-  Support *PyLint* / *PyDev* linting source markers. Python static code\n   analysis tools which help enforcing a coding standard.\n\n-  Options: none\n\npyside2, pyside6, pyqt5, pyqt6\n==============================\n\n-  Required by the *PySide* and *PyQt* and GUI packages, only one can be\n   activated at a time.\n\n-  Options: With ``--include-qt-plugins`` you can select which Qt\n   plugins to include. By default a relatively small set, called\n   ``sensible`` that is defined in the code is include, but you can add\n   more, and even ``all``, which will add a terrible amount of\n   dependencies though. But without the proper Qt plugins, functionality\n   of Qt might be broken, crashes can occur, or appearance can be\n   inferior.\n\n-  These plugins also inhibit other GUI frameworks from being included\n   in standalone distributions.\n\ntk-inter\n========\n\n-  Required by Python's Tk modules.\n\n-  Options: Can override the automatic detection of Tcl and Tk\n   directories with ``--tk-library-dir`` and ``--tcl-library-dir`` but\n   that should not be needed.\n"
        },
        {
          "name": "UserPlugin-Creation.rst",
          "type": "blob",
          "size": 18.6279296875,
          "content": "#############################\n How To Create a User Plugin\n#############################\n\n**********************************************\n Background: Nuitka Standard and User Plugins\n**********************************************\n\nUser plugins are technically built and structured in the same way as\nNuitka's own *standard* plugins are. There also is no difference with\nrespect to what they can do. Both types are invoked via parameters in\nNuitka's command line. The difference is the invocation format:\n\n-  A standard plugin is invoked by ``--enable-plugin=<plugin_name>``.\n   The string ``<plugin_name>`` is a unique identifier by which Nuitka\n   identifies it. As soon as Nuitka has found the corresponding plugin,\n   it will call its initialization method. Nuitka also has some standard\n   plugins which are always activated. A standard plugin is represented\n   by a Python script living in ``nuitka/plugins/standard``. Standard\n   plugins also internally have an object which can issue warnings when\n   it encounters situations looking like it is required.\n\n-  A user plugin is invoked by ``--user-plugin=</path/to/script.py>``.\n   Nuitka will import the script and call its initialization method just\n   like for a standard plugin. The plugin must have a non-empty string\n   specified in its variable ``plugin_name``. It must also not equal one\n   of the de-activated standard plugin strings. Best practice is filling\n   it with the filename, e.g. ``plugin_name == __file__``, because this\n   allows providing it with options. User plugins are always activated\n   once successfully loaded. They therefore have no mechanism to warn if\n   not being used.\n\n*********************\n Example User Plugin\n*********************\n\nThis is a simple demo user plugin. It will display source code lines of\nthe main program if they contain calls to the ``math`` module, if an\noption named \"trace\" is active:\n\n.. code:: python\n\n   import os\n   import sys\n\n   from nuitka import Options\n   from nuitka.plugins.PluginBase import NuitkaPluginBase\n\n   class NuitkaPluginMine(NuitkaPluginBase):\n       # Derive from filename, but can and should also be explicit.\n       plugin_name = __name__.split(\".\")[-1]\n\n       def __init__(self, trace_my_plugin):\n           # demo only: extract and display my options list\n           # check whether some specific option is set\n\n           self.check = trace_my_plugin\n           self.info(\" 'trace' is set to '%s'\" % self.check)\n\n           # do more init work here ...\n\n       @classmethod\n       def addPluginCommandLineOptions(cls, group):\n           group.add_option(\n               \"--trace-my-plugin\",\n               action=\"store_true\",\n               dest=\"trace_my_plugin\",\n               default=False,\n               help=\"This is show in help output.\"\n           )\n\n       def onModuleSourceCode(self, module_name, source_filename, source_code):\n           # if this is the main script and tracing should be done ...\n           if module_name == \"__main__\" and self.check:\n               self.info(\"\")\n               self.info(\" Calls to 'math' module:\")\n               for i, l in enumerate(source_code.splitlines()):\n                   if \"math.\" in l:\n                       self.info(\" %i: %s\" % (i+1, l))\n               self.info(\"\")\n           return source_code\n\nSample invocation line and output:\n\n.. code:: bash\n\n   python -m nuitka --standalone --user-plugin=user_plugin.py=trace script.py\n\n.. code::\n\n   Nuitka:INFO: 'user_plugin.py' options: ['trace']\n   Nuitka:INFO: 'trace' is set to True\n   Nuitka:INFO:User plugin 'user_plugin.py' loaded.\n   Nuitka:INFO:\n   Nuitka:INFO: Calls to 'math' module:\n   Nuitka:INFO: 125: print(math.sqrt(2))\n   Nuitka:INFO:\n\n*************************\n Nuitka Options Overview\n*************************\n\nAbout 60 methods are available to access option information for the\ncurrent Nuitka execution. Import the ``Options`` module (``from nuitka\nimport Options``) and use one of the following.\n\nPlease note that ``str`` results may return ``None``. Except very few,\nthe methods have no argument.\n\n+--------------------------------------+-----------------------------------------------------------------------------------+\n| **Method**                           | **Description**                                                                   |\n+======================================+===================================================================================+\n| assumeYesForDownloads                | *bool* = ``--assume-yes-for-downloads``                                           |\n+--------------------------------------+-----------------------------------------------------------------------------------+\n| isExperimental                       | *bool*, check for items of ``--experimental=``                                    |\n+--------------------------------------+-----------------------------------------------------------------------------------+\n| getFileReferenceMode                 | *str*, one of ``runtime``, ``original`` or ``frozen`` (``--file-reference-mode``) |\n+--------------------------------------+-----------------------------------------------------------------------------------+\n| getWindowsIconPaths                  | *list*, values of Windows icon options                                            |\n+--------------------------------------+-----------------------------------------------------------------------------------+\n| getLinuxIconPaths                    | *list*, values of Linux icon options                                              |\n+--------------------------------------+-----------------------------------------------------------------------------------+\n| getMacOSIconPaths                    | *list*, values of macOS icon options                                              |\n+--------------------------------------+-----------------------------------------------------------------------------------+\n| getJobLimit                          | *int*, value of ``--jobs`` / ``-j`` or number of CPU kernels                      |\n+--------------------------------------+-----------------------------------------------------------------------------------+\n| getMainArgs                          | *tuple*, arguments following the optional arguments                               |\n+--------------------------------------+-----------------------------------------------------------------------------------+\n| getMsvcVersion                       | *str*, value of ``--msvc``                                                        |\n+--------------------------------------+-----------------------------------------------------------------------------------+\n| getMustIncludeModules                | *list*, items of ``--include-module=``                                            |\n+--------------------------------------+-----------------------------------------------------------------------------------+\n| getMustIncludePackages               | *list*, items of ``--include-package=``                                           |\n+--------------------------------------+-----------------------------------------------------------------------------------+\n| getOutputDir                         | *str*, value of ``--output-dir``                                                  |\n+--------------------------------------+-----------------------------------------------------------------------------------+\n| getOutputFilename                    | *str*, value of ``-o``                                                            |\n+--------------------------------------+-----------------------------------------------------------------------------------+\n| getOutputPath(path)                  | *str*, os.path.join(getOutputDir(), path)                                         |\n+--------------------------------------+-----------------------------------------------------------------------------------+\n| getPluginsDisabled                   | *tuple*, items of ``--disable-plugin=``                                           |\n+--------------------------------------+-----------------------------------------------------------------------------------+\n| getPluginsEnabled                    | *tuple*, enabled plugins (including user plugins)                                 |\n+--------------------------------------+-----------------------------------------------------------------------------------+\n| getPluginOptions(plugin_name)        | *list*, options for specified plugin                                              |\n+--------------------------------------+-----------------------------------------------------------------------------------+\n| getPositionalArgs                    | *tuple*, command line positional arguments                                        |\n+--------------------------------------+-----------------------------------------------------------------------------------+\n| getPythonFlags                       | *list*, value of ``--python-flag``                                                |\n+--------------------------------------+-----------------------------------------------------------------------------------+\n| getPythonPathForScons                | *str*, value of ``--python-for-scons``                                            |\n+--------------------------------------+-----------------------------------------------------------------------------------+\n| getShallFollowExtra                  | *list*, items of ``--include-plugin-directory=``                                  |\n+--------------------------------------+-----------------------------------------------------------------------------------+\n| getShallFollowExtraFilePatterns      | *list*, items of ``--include-plugin-files=``                                      |\n+--------------------------------------+-----------------------------------------------------------------------------------+\n| getShallFollowInNoCase               | *list*, items of ``--nofollow-import-to=``                                        |\n+--------------------------------------+-----------------------------------------------------------------------------------+\n| getShallFollowModules                | *list*, items of ``--follow-import-to=``                                          |\n+--------------------------------------+-----------------------------------------------------------------------------------+\n| getUserPlugins                       | *tuple*, items of ``--user-plugin=``                                              |\n+--------------------------------------+-----------------------------------------------------------------------------------+\n| isAllowedToReexecute                 | *bool* = **not** ``--must-not-re-execute``                                        |\n+--------------------------------------+-----------------------------------------------------------------------------------+\n| isClang                              | *bool* = ``--clang``                                                              |\n+--------------------------------------+-----------------------------------------------------------------------------------+\n| isDebug                              | *bool* = ``--debug`` or ``--debugger``                                            |\n+--------------------------------------+-----------------------------------------------------------------------------------+\n| isExperimental(\"feature\")            | *bool* = ``--experimental=feature``                                               |\n+--------------------------------------+-----------------------------------------------------------------------------------+\n| isFullCompat                         | *bool* = ``--full-compat``                                                        |\n+--------------------------------------+-----------------------------------------------------------------------------------+\n| isLto                                | *bool* = ``--lto``                                                                |\n+--------------------------------------+-----------------------------------------------------------------------------------+\n| isMingw64                            | *bool* = ``--mingw64``                                                            |\n+--------------------------------------+-----------------------------------------------------------------------------------+\n| isProfile                            | *bool* = ``--profile``                                                            |\n+--------------------------------------+-----------------------------------------------------------------------------------+\n| shallUsePythonDebug                  | *bool* = ``--python-debug`` or ``sys.flags.debug``                                |\n+--------------------------------------+-----------------------------------------------------------------------------------+\n| isRemoveBuildDir                     | *bool* = ``--remove-output``                                                      |\n+--------------------------------------+-----------------------------------------------------------------------------------+\n| isShowInclusion                      | *bool* = ``--show-modules``                                                       |\n+--------------------------------------+-----------------------------------------------------------------------------------+\n| isShowMemory                         | *bool* = ``--show-memory``                                                        |\n+--------------------------------------+-----------------------------------------------------------------------------------+\n| isShowProgress                       | *bool* = ``--show-progress``                                                      |\n+--------------------------------------+-----------------------------------------------------------------------------------+\n| isShowScons                          | *bool* = ``--show-scons``                                                         |\n+--------------------------------------+-----------------------------------------------------------------------------------+\n| isStandaloneMode                     | *bool* = ``--standalone``                                                         |\n+--------------------------------------+-----------------------------------------------------------------------------------+\n| isUnstripped                         | *bool* = ``--unstripped`` or ``--profile``                                        |\n+--------------------------------------+-----------------------------------------------------------------------------------+\n| isVerbose                            | *bool* = ``--verbose``                                                            |\n+--------------------------------------+-----------------------------------------------------------------------------------+\n| shallCreatePyiFile                   | *bool* = **not** ``--no-pyi-file``                                                |\n+--------------------------------------+-----------------------------------------------------------------------------------+\n| shallDetectMissingPlugins            | *bool* = **not** ``--plugin-no-detection``                                        |\n+--------------------------------------+-----------------------------------------------------------------------------------+\n| shallExecuteImmediately              | *bool* = ``--run``                                                                |\n+--------------------------------------+-----------------------------------------------------------------------------------+\n| shallExplainImports                  | *bool* = ``--explain-imports``                                                    |\n+--------------------------------------+-----------------------------------------------------------------------------------+\n| shallFollowAllImports                | *bool* = ``--follow-imports``                                                     |\n+--------------------------------------+-----------------------------------------------------------------------------------+\n| shallFollowNoImports                 | *bool* = ``--nofollow-imports``                                                   |\n+--------------------------------------+-----------------------------------------------------------------------------------+\n| shallListPlugins                     | *bool* = ``--plugin-list``                                                        |\n+--------------------------------------+-----------------------------------------------------------------------------------+\n| shallMakeModule                      | *bool* = ``--module``                                                             |\n+--------------------------------------+-----------------------------------------------------------------------------------+\n| shallNotDoExecCCompilerCall          | *bool* = ``--generate-c-only``                                                    |\n+--------------------------------------+-----------------------------------------------------------------------------------+\n| shallNotStoreDependsExeCachedResults | *bool* = ``--disable-dll-dependency-cache``                                       |\n+--------------------------------------+-----------------------------------------------------------------------------------+\n| shallNotUseDependsExeCachedResults   | *bool* = ``--disable-dll-dependency-cache`` or                                    |\n|                                      | ``--force-dll-dependency-cache-update``                                           |\n+--------------------------------------+-----------------------------------------------------------------------------------+\n| shallOnlyExecCCompilerCall           | *bool* = ``--recompile-c-only``                                                   |\n+--------------------------------------+-----------------------------------------------------------------------------------+\n| shallRunInDebugger                   | *bool* = ``--debug``                                                              |\n+--------------------------------------+-----------------------------------------------------------------------------------+\n| shallTraceExecution                  | *bool* = ``--trace-execution``                                                    |\n+--------------------------------------+-----------------------------------------------------------------------------------+\n| shallWarnImplicitRaises              | *bool* = ``--warn-implicit-exceptions``                                           |\n+--------------------------------------+-----------------------------------------------------------------------------------+\n| shallWarnUnusualCode                 | *bool* = ``--warn-unusual-code``                                                  |\n+--------------------------------------+-----------------------------------------------------------------------------------+\n"
        },
        {
          "name": "Using-Plugin-Options.rst",
          "type": "blob",
          "size": 1.8212890625,
          "content": "###########################\n How To Use Plugin Options\n###########################\n\n****************************\n Background: Nuitka Plugins\n****************************\n\nPlugins are a feature to modify the way how Nuitka compiles Python\nprograms in extremely flexible ways.\n\nPlugins can automatically include data files and additional shared\nlibraries, import modules not detectable by source code examination,\nmodify or extend the to-be-compiled source code, gather statistics,\nchange Nuitka's parameter defaults and much more.\n\nAny number of plugins may be used in each compilation.\n\nA **whole new dimension of flexibility** can be added by using\n**options** to control a plugin's functioning.\n\n**********************\n Option Specification\n**********************\n\n**Standard plugins** are activated by the command line parameter\n``--enable-plugin=<plugin_name>``. The parameter ``plugin_name`` must\nequal the plugin's variable with the same name, so that Nuitka can\nidentify it.\n\n**User plugins** are activated by the command line parameter\n``--user-plugin=<script.py>``, where the parameter is a filename (-path)\nof a Python script implementing the plugin protocol, i.e. it must be a\nclass that inherits ``nuitka.plugins.PluginBase.UserPluginBase`` just\nlike every Nuitka plugin.\n\nPlugin options can be added by overloading the method\n\n.. code:: python\n\n   @classmethod\n   def addPluginCommandLineOptions(cls, group):\n       ...  # add options to \"group\" here.\n\nHere you extend the optparser group with any amount of options you\nchoose. Be careful with the ``dest`` names, try to make names that will\nnot collide with other plugins, as we have no per plugin namespace here.\n\n*********\n Example\n*********\n\nTo see a working example for a user plugin with options, consult `this\n<https://github.com/Nuitka/Nuitka/blob/develop/UserPlugin-Creation.rst>`__\ndocument.\n"
        },
        {
          "name": "azure-pipelines.yml",
          "type": "blob",
          "size": 0.3466796875,
          "content": "jobs:\n- job:\n  displayName: 'Ubuntu develop'\n  timeoutInMinutes: 0\n  pool: DevOps-Ubuntu\n\n  steps:\n\n  # - task: Cache@2\n  #   inputs:\n  #     key: '\"ubuntu-pipenv\" | \"$(Build.BuildNumber)\"'\n  #     path: '../pipenv_cache'\n  #     restoreKeys: |\n  #      \"ubuntu-pipenv\"\n\n  - task: CmdLine@2\n    inputs:\n      script: 'python3 ./tests/run-tests --jobs=-1'\n"
        },
        {
          "name": "bin",
          "type": "tree",
          "content": null
        },
        {
          "name": "debian",
          "type": "tree",
          "content": null
        },
        {
          "name": "doc",
          "type": "tree",
          "content": null
        },
        {
          "name": "lib",
          "type": "tree",
          "content": null
        },
        {
          "name": "misc",
          "type": "tree",
          "content": null
        },
        {
          "name": "nuitka",
          "type": "tree",
          "content": null
        },
        {
          "name": "pyproject.toml",
          "type": "blob",
          "size": 0.8447265625,
          "content": "#     Copyright 2024, Kay Hayen, mailto:kay.hayen@gmail.com find license text at end of file\n\n[build-system]\nrequires = [\"setuptools>=42\", \"wheel\"]\n\n#     Part of \"Nuitka\", an optimizing Python compiler that is compatible and\n#     integrates with CPython, but also works on its own.\n#\n#     Licensed under the Apache License, Version 2.0 (the \"License\");\n#     you may not use this file except in compliance with the License.\n#     You may obtain a copy of the License at\n#\n#        http://www.apache.org/licenses/LICENSE-2.0\n#\n#     Unless required by applicable law or agreed to in writing, software\n#     distributed under the License is distributed on an \"AS IS\" BASIS,\n#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#     See the License for the specific language governing permissions and\n#     limitations under the License.\n"
        },
        {
          "name": "requirements-devel.txt",
          "type": "blob",
          "size": 2.4228515625,
          "content": "# Speed up Nuitka by having this available. On Windows, installing on 2.7 is not\n# working easily, so let's exclude that.\nordered-set == 4.1.0; python_version >= '3.7'\norderedset == 2.0.3 ; os.name != 'nt' and sys.platform != 'darwin' and python_version < '3.7'\norderedset == 2.0.3 ; os.name == 'nt' and python_version >= '3.6' and python_version < '3.7'\norderedset == 2.0.3 ; sys.platform == 'darwin' and python_version < '3.7'\n\n# Make testing more reliable on Python2 with timeout features added.\nsubprocess32 == 3.5.4 ; python_version == '2.7'\n\n# PyLint wouldn't be installable on 2.6 and not work with too old Python3\npylint == 3.0.3 ; python_version >= '3.9'\nastroid == 3.0.2 ; python_version >= '3.9'\n\n# linting rest code snippets\nrestructuredtext-lint==1.4.0 ; python_version >= '3.9'\nPygments == 2.15.1 ; python_version >= '3.9'\nrstcheck == 6.2.0 ; python_version >= '3.9'\n\n# Auto-format needs\nblack == 24.10.0 ; python_version >= '3.9'\ntoml >= 0.10.1 ; python_version >= '3.9'\nisort == 5.13.2 ; python_version >= '3.9'\nyamllint == 1.28.0 ; python_version >= '3.9'\nrstfmt == 0.0.14 ; python_version >= '3.9'\njsonschema == 4.6.0 ; python_version >= '3.9'\nruamel.yaml == 0.17.21 ; python_version >= '3.9'\ndeepdiff == 5.8.1 ; python_version >= '3.9'\nmdformat == 0.7.16 ; python_version >= '3.9'\nmdformat-gfm == 0.3.5 ; python_version >= '3.9'\nmdformat-frontmatter == 2.0.1 ; python_version >= '3.9'\nmdformat-footnote == 0.1.1 ; python_version >= '3.9'\n\n# Codespell can be used as well, no need to fix the version\ncodespell ; python_version >= '3.9'\n\n# API doc, doxygen helper for Python\ndoxypypy == 0.8.8.6 ; python_version >= '2.7'\n\n# Run time code generation needs Jinja2 now\nJinja2 == 2.11.3 ; python_version == '2.7'\nJinja2 == 3.1.4 ; python_version >= '3.7'\n\n# For the progress bar to look nice.\ntqdm == 4.64.1 ; python_version < '3.7'\ntqdm == 4.66.4 ; python_version >= '3.7'\n\n# Distutils test, packaging test for PyPI, fixed for Python2 breakage\n# of newer virtualenv.\nvirtualenv == 16.7.10; python_version == '2.7'\nvirtualenv ; python_version >= '3.5'\n\n# Tests of PyPI packages need that usually.\npytest; python_version == '2.7' or python_version >= '3.4'\n\n# Onefile compression\nzstandard >= 0.15; python_version >= '3.5'\n\n# Plugins need that\npyyaml == 6.0.1; python_version >= '3.6'\n# Python3.5 was dropped sooner than Python2.\npyyaml == 5.3.1; python_version == '3.5'\npyyaml == 5.4.1; python_version == '2.7'\n\n# Packaging\nwheel\n\npip < 21.0 ; python_version == '2.7'\n"
        },
        {
          "name": "requirements.txt",
          "type": "blob",
          "size": 1.62109375,
          "content": "#     Copyright 2024, Kay Hayen, mailto:kay.hayen@gmail.com find license text at end of file\n\n# Folders to use for cache files.\nappdirs\n\n# For the progress bar to look nicely.\ntqdm; python_version == '2.7' or python_version >= '3.4'\n\n# Speed up Nuitka by having this available. On Windows, installing on 2.7 is not\n# working easily, so lets exclude that.\nordered-set == 4.1.0; python_version >= '3.7'\norderedset == 2.0.3 ; os.name != 'nt' and sys.platform != 'darwin' and python_version < '3.7'\norderedset == 2.0.3 ; os.name == 'nt' and python_version >= '3.4' and python_version < '3.7'\norderedset == 2.0.3 ; sys.platform == 'darwin' and python_version < '3.7'\n\n# More capable subprocess.\nsubprocess32; python_version == '2.7'\n\n# Onefile compression\nzstandard >= 0.15; python_version >= '3.5'\n\n# Plugins need that, but there is an inline copy for old versions too.\npyyaml; python_version == '2.7' or python_version >= '3.6'\n\nJinja2 >= 2.10.2\n\n#     Part of \"Nuitka\", an optimizing Python compiler that is compatible and\n#     integrates with CPython, but also works on its own.\n#\n#     Licensed under the Apache License, Version 2.0 (the \"License\");\n#     you may not use this file except in compliance with the License.\n#     You may obtain a copy of the License at\n#\n#        http://www.apache.org/licenses/LICENSE-2.0\n#\n#     Unless required by applicable law or agreed to in writing, software\n#     distributed under the License is distributed on an \"AS IS\" BASIS,\n#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#     See the License for the specific language governing permissions and\n#     limitations under the License.\n"
        },
        {
          "name": "rpm",
          "type": "tree",
          "content": null
        },
        {
          "name": "setup.py",
          "type": "blob",
          "size": 16.810546875,
          "content": "#     Copyright 2024, Kay Hayen, mailto:kay.hayen@gmail.com find license text at end of file\n\n\n\"\"\" Setup file for Nuitka.\n\nThis applies a few tricks. First, the Nuitka version is read from\nthe source code. Second, the packages are scanned from the filesystem,\nand third, the byte code compilation is avoided for inline copies of\nscons with mismatching Python major versions. Also a binary distribution\nis enforced, to avoid being cached with wrong inline copies for the\nPython version.\n\nspellchecker: ignore chdir,pythonw,tqdm,distutil,atomicwrites,markupsafe\nspellchecker: ignore wininst,distclass,Containerfile,orderedset\n\"\"\"\n\nimport os\nimport sys\n\nos.chdir(os.path.dirname(__file__) or \".\")\nsys.path.insert(0, os.path.abspath(os.getcwd()))\n\n# Disable setuptools warnings before importing it.\nimport warnings\n\nwarnings.filterwarnings(\"ignore\", \"\")\n\n# Don't allow importing this, and make recognizable that\n# the above imports are not to follow. Sometimes code imports\n# setup and then Nuitka ends up including itself.\nif __name__ != \"__main__\":\n    sys.exit(\"Cannot import 'setup' module of Nuitka\")\n\n# isort:start\n\nimport fnmatch\nimport re\n\nfrom setuptools import Distribution, setup\nfrom setuptools.command import easy_install\n\nfrom nuitka.PythonFlavors import isMSYS2MingwPython\nfrom nuitka.utils.FileOperations import getFileList\nfrom nuitka.Version import getNuitkaVersion\n\nversion = getNuitkaVersion()\n\n\ndef findNuitkaPackages():\n    result = []\n\n    for root, dirnames, filenames in os.walk(\"nuitka\"):\n        # Packages must contain \"__init__.py\" or they are merely directories\n        # in Nuitka as we are Python2 compatible.\n        if \"__init__.py\" not in filenames:\n            continue\n\n        # The \"release\" namespace is code used to release, but not itself for\n        # release, same goes for \"quality\".\n        if \"release\" in dirnames:\n            dirnames.remove(\"release\")\n        if \"quality\" in dirnames:\n            dirnames.remove(\"quality\")\n\n        # Handled separately.\n        if \"inline_copy\" in dirnames:\n            dirnames.remove(\"inline_copy\")\n\n        result.append(root.replace(os.path.sep, \".\"))\n\n    return result\n\n\ninline_copy_files = []\nno_byte_compile = []\n\n\ndef addDataFiles(data_files, base_path, do_byte_compile=True):\n    patterns = (\n        \"%s/*.py\" % base_path,\n        \"%s/*/*.py\" % base_path,\n        \"%s/*/*/*.py\" % base_path,\n        \"%s/*/*/*/*.py\" % base_path,\n        \"%s/*/*/*/*/*.py\" % base_path,\n        \"%s/config*\" % base_path,\n        \"%s/LICENSE*\" % base_path,\n        \"%s/*/LICENSE*\" % base_path,\n        \"%s/READ*\" % base_path,\n    )\n\n    data_files.extend(patterns)\n\n    if not do_byte_compile:\n        no_byte_compile.extend(patterns)\n\n\ndef addInlineCopy(name, do_byte_compile=True):\n    if os.getenv(\"NUITKA_NO_INLINE_COPY\", \"0\") == \"1\":\n        return\n\n    addDataFiles(\n        inline_copy_files, \"inline_copy/%s\" % name, do_byte_compile=do_byte_compile\n    )\n\n\naddInlineCopy(\"appdirs\")\naddInlineCopy(\"glob2\")\naddInlineCopy(\"markupsafe\")\naddInlineCopy(\"tqdm\")\n\naddInlineCopy(\"stubgen\")\n\nsdist_mode = \"sdist\" in sys.argv\ninstall_mode = \"install\" in sys.argv\n\nif os.name == \"nt\" or sdist_mode:\n    addInlineCopy(\"atomicwrites\")\n    addInlineCopy(\"clcache\")\n    addInlineCopy(\"colorama\")\n    addInlineCopy(\"pefile\")\n\nif sys.version_info < (3,) or sdist_mode:\n    addInlineCopy(\"yaml_27\")\nif (3,) < sys.version_info < (3, 6) or sdist_mode:\n    addInlineCopy(\"yaml_35\")\nif sys.version_info >= (3, 6) or sdist_mode:\n    addInlineCopy(\"yaml\")\n\nif sys.version_info < (3, 6) or sdist_mode:\n    addInlineCopy(\"jinja2_35\")\nif sys.version_info >= (3, 6) or sdist_mode:\n    addInlineCopy(\"jinja2\")\n\naddInlineCopy(\"pkg_resources\")\n\n# Scons really only, with historic naming and positioning. Needs to match the\n# \"scons.py\" in bin with respect to versions selection.\naddInlineCopy(\"bin\")\n\nif os.name == \"nt\" or sdist_mode:\n    addInlineCopy(\"lib/scons-4.3.0\", do_byte_compile=sys.version_info >= (3,))\nif (os.name != \"nt\" and sys.version_info < (2, 7)) or sdist_mode:\n    addInlineCopy(\"lib/scons-2.3.2\")\nif (os.name != \"nt\" and sys.version_info >= (2, 7)) or sdist_mode:\n    addInlineCopy(\"lib/scons-3.1.2\")\n\nnuitka_packages = findNuitkaPackages()\n\n# Include extra files\npackage_data = {\n    \"\": [\"*.txt\", \"*.rst\", \"*.c\", \"*.h\", \"*.yml\"],\n    \"nuitka.build\": [\n        \"*.scons\",\n        \"static_src/*.c\",\n        \"static_src/*.cpp\",\n        \"static_src/*/*.c\",\n        \"static_src/*/*.h\",\n        \"inline_copy/zstd/LICENSE.txt\",\n        \"inline_copy/zstd/*.h\",\n        \"inline_copy/zstd/*/*.h\",\n        \"inline_copy/zstd/*/*.c\",\n        \"inline_copy/zlib/LICENSE\",\n        \"inline_copy/zlib/*.h\",\n        \"inline_copy/zlib/*.c\",\n        \"inline_copy/python_hacl/LICENSE.txt\",\n        \"inline_copy/python_hacl/hacl_312/*.h\",\n        \"inline_copy/python_hacl/hacl_312/*.c\",\n        \"inline_copy/python_hacl/hacl_312/*/*.h\",\n        \"inline_copy/python_hacl/hacl_312/*/*/*.c\",\n        \"inline_copy/python_hacl/hacl_312/*/*/*.h\",\n        \"inline_copy/python_hacl/hacl_312/*/*/*/*.h\",\n        \"static_src/*/*.asm\",\n        \"static_src/*/*.S\",\n        \"include/*.h\",\n        \"include/*/*.h\",\n        \"include/*/*/*.h\",\n    ]\n    + inline_copy_files,\n    \"nuitka.code_generation\": [\"templates_c/*.j2\"],\n    \"nuitka.reports\": [\"*.j2\"],\n    \"nuitka.plugins.standard\": [\"*/*.c\", \"*/*.py\"],\n}\n\n\nif \"nuitka.plugins.commercial\" in nuitka_packages:\n    commercial_data_files = []\n\n    commercial_plugins_dir = os.path.join(\"nuitka\", \"plugins\", \"commercial\")\n\n    for filename in getFileList(commercial_plugins_dir):\n        filename_relative = os.path.relpath(filename, commercial_plugins_dir)\n\n        if (\n            filename_relative.endswith(\".py\")\n            and os.path.basename(filename_relative) == filename_relative\n        ):\n            continue\n\n        if filename.endswith((\".py\", \".yml\", \".c\", \".h\", \".plk\", \".tmd\")):\n            commercial_data_files.append(filename_relative)\n            continue\n\n        filename_base = os.path.basename(filename_relative)\n\n        if filename_base.startswith(\"LICENSE\"):\n            commercial_data_files.append(filename_relative)\n            continue\n\n    package_data[\"nuitka.plugins.commercial\"] = commercial_data_files\n    package_data[\"nuitka.tools.commercial.container_build\"] = [\"Containerfile\"]\n\ntry:\n    import distutils.util\nexcept ImportError:\n    # Python 3.12 might do this, we need to find out where to disable the\n    # bytecode compilation there.\n    pass\nelse:\n    orig_byte_compile = distutils.util.byte_compile\n\n    def byte_compile(py_files, *args, **kw):\n        # Disable bytecode compilation output, too annoying.\n        kw[\"verbose\"] = 0\n\n        # Avoid attempting files that won't work.\n        py_files = [\n            filename\n            for filename in py_files\n            if not any(\n                fnmatch.fnmatch(filename, \"*/*/*/\" + pattern)\n                for pattern in no_byte_compile\n            )\n        ]\n\n        orig_byte_compile(py_files, *args, **kw)\n\n\ndistutils.util.byte_compile = byte_compile\n\n\n# We monkey patch easy install script generation to not load pkg_resources,\n# which is very slow to launch. This can save one second or more per launch\n# of Nuitka.\nrunner_script_template = \"\"\"\\\n# -*- coding: utf-8 -*-\n# Launcher for Nuitka\n\nimport %(package_name)s\n%(package_name)s.%(function_name)s()\n\"\"\"\n\n\n# This is for newer setuptools:\n@classmethod\ndef get_args(cls, dist, header=None):\n    \"\"\"\n    Yield write_script() argument tuples for a distribution's\n    console_scripts and gui_scripts entry points.\n    \"\"\"\n    if header is None:\n        header = cls.get_header()\n\n    for type_ in \"console\", \"gui\":\n        group = type_ + \"_scripts\"\n\n        for name, ep in dist.get_entry_map(group).items():\n            package_name, function_name = str(ep).split(\"=\")[1].strip().split(\":\")\n\n            script_text = runner_script_template % {\n                \"package_name\": package_name,\n                \"function_name\": function_name,\n            }\n\n            args = cls._get_script_args(type_, name, header, script_text)\n            for res in args:\n                yield res\n\n\ntry:\n    easy_install.ScriptWriter.get_args = get_args\nexcept AttributeError:\n    pass\n\n\n# This is for older setuptools:\ndef get_script_args(dist, executable=os.path.normpath(sys.executable), wininst=False):\n    \"\"\"Yield write_script() argument tuples for a distribution's entrypoints\"\"\"\n    header = easy_install.get_script_header(\"\", executable, wininst)\n    for group in \"console_scripts\", \"gui_scripts\":\n        for name, _ep in dist.get_entry_map(group).items():\n            script_text = runner_script_template\n            if sys.platform == \"win32\" or wininst:\n                # On Windows/wininst, add a .py extension and an .exe launcher\n                if group == \"gui_scripts\":\n                    launcher_type = \"gui\"\n                    ext = \"-script.pyw\"\n                    old = [\".pyw\"]\n                    new_header = re.sub(\"(?i)python.exe\", \"pythonw.exe\", header)\n                else:\n                    launcher_type = \"cli\"\n                    ext = \"-script.py\"\n                    old = [\".py\", \".pyc\", \".pyo\"]\n                    new_header = re.sub(\"(?i)pythonw.exe\", \"python.exe\", header)\n                if (\n                    os.path.exists(new_header[2:-1].strip('\"'))\n                    or sys.platform != \"win32\"\n                ):\n                    hdr = new_header\n                else:\n                    hdr = header\n                yield (name + ext, hdr + script_text, \"t\", [name + x for x in old])\n                yield (\n                    name + \".exe\",\n                    easy_install.get_win_launcher(launcher_type),\n                    \"b\",  # write in binary mode\n                )\n                if not easy_install.is_64bit():\n                    # install a manifest for the launcher to prevent Windows\n                    #  from detecting it as an installer (which it will for\n                    #  launchers like easy_install.exe). Consider only\n                    #  adding a manifest for launchers detected as installers.\n                    #  See Distribute #143 for details.\n                    m_name = name + \".exe.manifest\"\n                    yield (m_name, easy_install.load_launcher_manifest(name), \"t\")\n            else:\n                # On other platforms, we assume the right thing to do is to\n                # just write the stub with no extension.\n                yield (name, header + script_text)\n\n\ntry:\n    easy_install.get_script_args\nexcept AttributeError:\n    pass\nelse:\n    easy_install.get_script_args = get_script_args\n\nif str is bytes:\n    binary_suffix = \"2\"\nelse:\n    binary_suffix = \"\"\n\nif os.name == \"nt\" and not isMSYS2MingwPython():\n    console_scripts = []\nelse:\n    console_scripts = [\n        \"nuitka%s = nuitka.__main__:main\" % binary_suffix,\n        \"nuitka%s-run = nuitka.__main__:main\" % binary_suffix,\n    ]\n\n    if \"nuitka.plugins.commercial\" in nuitka_packages:\n        console_scripts.append(\n            \"nuitka-decrypt = nuitka.tools.commercial.decrypt.__main__:main\"\n        )\n\nscripts = []\n\n# For Windows, there are CMD batch files to launch Nuitka.\nif os.name == \"nt\" and not isMSYS2MingwPython():\n    scripts += [\"misc/nuitka.cmd\", \"misc/nuitka-run.cmd\"]\n\n    if \"nuitka.plugins.commercial\" in nuitka_packages:\n        scripts.append(\"misc/nuitka-decrypt.cmd\")\n\n\n# With this, we can enforce a binary package.\nclass BinaryDistribution(Distribution):\n    \"\"\"Distribution which always forces a binary package with platform name\"\"\"\n\n    @staticmethod\n    def has_ext_modules():\n        # For \"python setup.py install\" this triggers an attempt to lookup\n        # package dependencies, which fails to work, since it's not yet\n        # installed and might not yet be in PyPI as well.\n        return not install_mode\n\n\nwith open(\"README.rst\", \"rb\") as input_file:\n    long_description = input_file.read().decode(\"utf8\")\n\n    # Need to remove the ..contents etc from the rest, or else PyPI will not render\n    # it.\n    long_description = long_description.replace(\".. contents::\\n\", \"\")\n    long_description = long_description.replace(\n        \".. image:: doc/images/Nuitka-Logo-Symbol.png\\n\", \"\"\n    )\n\ninstall_requires = []\nif sys.version_info >= (3, 7):\n    install_requires.append(\"ordered-set >= 4.1.0\")\nif sys.version_info[:2] == (2, 7):\n    install_requires.append(\"subprocess32\")\nif sys.version_info >= (3, 7):\n    install_requires.append(\"zstandard >= 0.15\")\nif os.name != \"nt\" and sys.platform != \"darwin\" and sys.version_info < (3, 7):\n    install_requires.append(\"orderedset >= 2.0.3\")\nif sys.platform == \"darwin\" and sys.version_info < (3, 7):\n    install_requires.append(\"orderedset >= 2.0.3\")\n\nsetup(\n    name=\"Nuitka\",\n    license=\"Apache License, Version 2.0\",\n    version=version,\n    long_description=long_description,\n    long_description_content_type=\"text/x-rst\",\n    classifiers=[\n        # Nuitka is mature even\n        \"Development Status :: 5 - Production/Stable\",\n        # Indicate who Nuitka is for\n        \"Intended Audience :: Developers\",\n        \"Intended Audience :: Science/Research\",\n        # Nuitka is a compiler and a build tool as such.\n        \"Topic :: Software Development :: Compilers\",\n        \"Topic :: Software Development :: Build Tools\",\n        # Is has a weak subset of PyLint, but aims for more long term\n        \"Topic :: Software Development :: Quality Assurance\",\n        # Nuitka standalone mode aims at distribution\n        \"Topic :: System :: Software Distribution\",\n        # Python3 supported versions.\n        \"Programming Language :: Python :: 3.13\",\n        \"Programming Language :: Python :: 3.12\",\n        \"Programming Language :: Python :: 3.11\",\n        \"Programming Language :: Python :: 3.10\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.8\",\n        \"Programming Language :: Python :: 3.7\",\n        \"Programming Language :: Python :: 3.6\",\n        \"Programming Language :: Python :: 3.5\",\n        \"Programming Language :: Python :: 3.4\",\n        # Python2 supported versions.\n        \"Programming Language :: Python :: 2.7\",\n        \"Programming Language :: Python :: 2.6\",\n        # We depend on CPython.\n        \"Programming Language :: Python :: Implementation :: CPython\",\n        # We generate C intermediate code and implement part of the\n        # run time environment in C. Actually C11.\n        \"Programming Language :: C\",\n        # Supported OSes are many\n        \"Operating System :: POSIX :: Linux\",\n        \"Operating System :: POSIX :: BSD :: FreeBSD\",\n        \"Operating System :: POSIX :: BSD :: NetBSD\",\n        \"Operating System :: POSIX :: BSD :: OpenBSD\",\n        \"Operating System :: Microsoft :: Windows\",\n        \"Operating System :: MacOS\",\n        \"Operating System :: Android\",\n        # License\n        \"License :: OSI Approved :: Apache Software License\",\n    ],\n    packages=nuitka_packages,\n    package_data=package_data,\n    # metadata for upload to PyPI\n    author=\"Kay Hayen\",\n    author_email=\"Kay.Hayen@gmail.com\",\n    url=\"https://nuitka.net\",\n    description=\"\"\"\\\nPython compiler with full language support and CPython compatibility\"\"\",\n    keywords=\"compiler,python,nuitka\",\n    project_urls={\n        \"Commercial\": \"https://nuitka.net/doc/commercial.html\",\n        \"Support\": \"https://nuitka.net/pages/support.html\",\n        \"Documentation\": \"https://nuitka.net/doc/user-manual.html\",\n        \"Donations\": \"https://nuitka.net/pages/donations.html\",\n        \"Mastodon\": \"https://fosstodon.org/@kayhayen\",\n        \"Twitter\": \"https://twitter.com/KayHayen\",\n        \"Source\": \"https://github.com/Nuitka/Nuitka\",\n    },\n    zip_safe=False,\n    scripts=scripts,\n    entry_points={\n        \"distutils.commands\": [\n            \"bdist_nuitka = \\\n             nuitka.distutils.DistutilCommands:bdist_nuitka\",\n            \"build_nuitka = \\\n             nuitka.distutils.DistutilCommands:build\",\n            \"install_nuitka = \\\n             nuitka.distutils.DistutilCommands:install\",\n        ],\n        \"distutils.setup_keywords\": [\n            \"build_with_nuitka = nuitka.distutils.DistutilCommands:setupNuitkaDistutilsCommands\"\n        ],\n        \"console_scripts\": console_scripts,\n    },\n    install_requires=install_requires,\n    # As we do version specific hacks for installed inline copies, make the\n    # wheel version and platform specific.\n    distclass=BinaryDistribution,\n    verbose=0,\n)\n\n#     Part of \"Nuitka\", an optimizing Python compiler that is compatible and\n#     integrates with CPython, but also works on its own.\n#\n#     Licensed under the Apache License, Version 2.0 (the \"License\");\n#     you may not use this file except in compliance with the License.\n#     You may obtain a copy of the License at\n#\n#        http://www.apache.org/licenses/LICENSE-2.0\n#\n#     Unless required by applicable law or agreed to in writing, software\n#     distributed under the License is distributed on an \"AS IS\" BASIS,\n#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#     See the License for the specific language governing permissions and\n#     limitations under the License.\n"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}