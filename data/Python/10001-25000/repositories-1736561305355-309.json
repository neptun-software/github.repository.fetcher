{
  "metadata": {
    "timestamp": 1736561305355,
    "page": 309,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjMxMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "dbader/schedule",
      "stars": 11926,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.39453125,
          "content": "*.py[cod]\n\n# C extensions\n*.so\n\n# Packages\n*.egg\n*.egg-info\ndist\nbuild\neggs\nparts\nbin\nvar\nsdist\ndevelop-eggs\n.installed.cfg\nlib\nlib64\nMANIFEST\n\n# Installer logs\npip-log.txt\n\n# Unit test / coverage reports\n.coverage\n.tox\nnosetests.xml\n\n# Translations\n*.mo\n\n# Mr Developer\n.mr.developer.cfg\n.project\n.pydevproject\n\nenv\nenv3\n__pycache__\nvenv\n\n.cache\ndocs/_build\n\n# For Idea (e.g. PyCharm) users\n.idea\n*.iml\n"
        },
        {
          "name": "AUTHORS.rst",
          "type": "blob",
          "size": 2.005859375,
          "content": "Thanks to all the wonderful folks who have contributed to schedule over the years:\n\n- mattss <https://github.com/mattss>\n- mrhwick <https://github.com/mrhwick>\n- cfrco <https://github.com/cfrco>\n- matrixise <https://github.com/matrixise>\n- abultman <https://github.com/abultman>\n- mplewis <https://github.com/mplewis>\n- WoLfulus <https://github.com/WoLfulus>\n- dylwhich <https://github.com/dylwhich>\n- fkromer <https://github.com/fkromer>\n- alaingilbert <https://github.com/alaingilbert>\n- Zerrossetto <https://github.com/Zerrossetto>\n- yetingsky <https://github.com/yetingsky>\n- schnepp <https://github.com/schnepp> <https://bitbucket.org/saschaschnepp>\n- grampajoe <https://github.com/grampajoe>\n- gilbsgilbs <https://github.com/gilbsgilbs>\n- Nathan Wailes <https://github.com/NathanWailes>\n- Connor Skees <https://github.com/ConnorSkees>\n- qmorek <https://github.com/qmorek>\n- aisk <https://github.com/aisk>\n- MichaelCorleoneLi <https://github.com/MichaelCorleoneLi>\n- sijmenhuizenga <https://github.com/SijmenHuizenga>\n- eladbi <https://github.com/eladbi>\n- chankeypathak <https://github.com/chankeypathak>\n- vubon <https://github.com/vubon>\n- gaguirregabiria <https://github.com/gaguirregabiria>\n- rhagenaars <https://github.com/RHagenaars>\n- Skenvy <https://github.com/skenvy>\n- zcking <https://github.com/zcking>\n- Martin Thoma <https://github.com/MartinThoma>\n- ebllg <https://github.com/ebllg>\n- fredthomsen <https://github.com/fredthomsen>\n- biggerfisch <https://github.com/biggerfisch>\n- sosolidkk <https://github.com/sosolidkk>\n- rudSarkar <https://github.com/rudSarkar>\n- chrimaho <https://github.com/chrimaho>\n- jweijers <https://github.com/jweijers>\n- Akuli <https://github.com/Akuli>\n- NaelsonDouglas <https://github.com/NaelsonDouglas>\n- SergBobrovsky <https://github.com/SergBobrovsky>\n- CPickens42 <https://github.com/CPickens42>\n- emollier <https://github.com/emollier>\n- sunpro108 <https://github.com/sunpro108>\n- kurtasov <https://github.com/kurtasov>\n- AnezeR <https://github.com/AnezeR>\n- a-detiste <https://github.com/a-detiste>\n"
        },
        {
          "name": "HISTORY.rst",
          "type": "blob",
          "size": 6.5849609375,
          "content": ".. :changelog:\n\nHistory\n-------\n\n1.2.2 (2024-05-25)\n++++++++++++++++++\n\n- Fix bugs in cross-timezone scheduling (#601, #602, #604, #623)\n- Add support for python 3.12 (#606)\n- Remove dependency on old mock (#622) Thanks @a-detiste!\n\n\n1.2.1 (2023-11-01)\n++++++++++++++++++\n\n-  Fix bug where schedule was off when using .at with timezone (#583) Thanks @AnezeR!\n\n\n1.2.0 (2023-04-10)\n++++++++++++++++++\n\n- Dropped support for Python 3.6, add support for Python 3.10 and 3.11.\n- Add timezone support for .at(). See #517. Thanks @chrimaho!\n- Get next run by tag (#463) Thanks @jweijers!\n- Add py.typed file. See #521. Thanks @Akuli!\n\n- Fix the re pattern of the 'days'. See #506 Thanks @sunpro108!\n- Fix test_until_time failure when run early. See #563. Thanks @emollier!\n- Fix crash repr on partially constructed job. See #569. Thanks @CPickens42!\n- Code cleanup and modernization. See #567, #536. Thanks @masa-08 and @SergBobrovsky!\n- Documentation improvements and fix typos. See #469, #479, #493, #519, #520. Thanks to @NaelsonDouglas, @chrimaho, @rudSarkar\n\n1.1.0 (2021-04-09)\n++++++++++++++++++\n\n- Added @repeat() decorator. See #148. Thanks @rhagenaars!\n- Added execute .until(). See #195. Thanks @fredthomsen!\n- Added job retrieval filtered by tags using get_jobs('tag'). See #419. Thanks @skenvy!\n- Added type annotations. See #427. Thanks @martinthoma!\n\n- Bugfix: str() of job when there is no __name__. See #430. Thanks @biggerfisch!\n- Improved error messages. See #280, #439. Thanks @connorskees and @sosolidkk!\n- Improved logging. See #193. Thanks @zcking!\n- Documentation improvements and fix typos. See #424, #435, #436, #453, #437, #448. Thanks @ebllg!\n\n1.0.0 (2021-01-20)\n++++++++++++++++++\n\nDepending on your configuration, the following bugfixes might change schedule's behaviour:\n\n- Fix: idle_seconds crashes when no jobs are scheduled. See #401. Thanks @yoonghm!\n- Fix: day.at('HH:MM:SS') where HMS=now+10s doesn't run today. See #331. Thanks @qmorek!\n- Fix: hour.at('MM:SS'), the seconds are set to 00. See #290. Thanks @eladbi!\n- Fix: Long-running jobs skip a day when they finish in the next day #404. Thanks @4379711!\n\nOther changes:\n\n- Dropped Python 2.7 and 3.5 support, added 3.8 and 3.9 support. See #409\n- Fix RecursionError when the job is passed to the do function as an arg. See #190. Thanks @connorskees!\n- Fix DeprecationWarning of 'collections'. See #296. Thanks @gaguirregabiria!\n- Replaced Travis with Github Actions for automated testing\n- Revamp and extend documentation. See #395\n- Improved tests. Thanks @connorskees and @Jamim!\n- Changed log messages to DEBUG level. Thanks @aisk!\n\n\n0.6.0 (2019-01-20)\n++++++++++++++++++\n\n- Make at() accept timestamps with 1 second precision (#267). Thanks @NathanWailes!\n- Introduce proper exception hierarchy (#271). Thanks @ConnorSkees!\n\n\n0.5.0 (2017-11-16)\n++++++++++++++++++\n\n- Keep partially scheduled jobs from breaking the scheduler (#125)\n- Add support for random intervals (Thanks @grampajoe and @gilbsgilbs)\n\n\n0.4.3 (2017-06-10)\n++++++++++++++++++\n\n- Improve docs & clean up docstrings\n\n\n0.4.2 (2016-11-29)\n++++++++++++++++++\n\n- Publish to PyPI as a universal (py2/py3) wheel\n\n\n0.4.0 (2016-11-28)\n++++++++++++++++++\n\n- Add proper HTML (Sphinx) docs available at https://schedule.readthedocs.io/\n- CI builds now run against Python 2.7 and 3.5 (3.3 and 3.4 should work fine but are untested)\n- Fixed an issue with ``run_all()`` and having more than one job that deletes itself in the same iteration. Thanks @alaingilbert.\n- Add ability to tag jobs and to cancel jobs by tag. Thanks @Zerrossetto.\n- Improve schedule docs. Thanks @Zerrossetto.\n- Additional docs fixes by @fkromer and @yetingsky.\n\n0.3.2 (2015-07-02)\n++++++++++++++++++\n\n- Fixed issues where scheduling a job with a functools.partial as the job function fails. Thanks @dylwhich.\n- Fixed an issue where scheduling a job to run every >= 2 days would cause the initial execution to happen one day early. Thanks @WoLfulus for identifying this and providing a fix.\n- Added a FAQ item to describe how to schedule a job that runs only once.\n\n0.3.1 (2014-09-03)\n++++++++++++++++++\n\n- Fixed an issue with unicode handling in setup.py that was causing trouble on Python 3 and Debian (https://github.com/dbader/schedule/issues/27). Thanks to @waghanza for reporting it.\n- Added an FAQ item to describe how to deal with job functions that throw exceptions. Thanks @mplewis.\n\n0.3.0 (2014-06-14)\n++++++++++++++++++\n\n- Added support for scheduling jobs on specific weekdays. Example: ``schedule.every().tuesday.do(job)`` or ``schedule.every().wednesday.at(\"13:15\").do(job)`` (Thanks @abultman.)\n- Run tests against Python 2.7 and 3.4. Python 3.3 should continue to work but we're not actively testing it on CI anymore.\n\n0.2.1 (2013-11-20)\n++++++++++++++++++\n\n- Fixed history (no code changes).\n\n0.2.0 (2013-11-09)\n++++++++++++++++++\n\n- This release introduces two new features in a backwards compatible way:\n- Allow jobs to cancel repeated execution: Jobs can be cancelled by calling ``schedule.cancel_job()`` or by returning ``schedule.CancelJob`` from the job function. (Thanks to @cfrco and @matrixise.)\n- Updated ``at_time()`` to allow running jobs at a particular time every hour. Example: ``every().hour.at(':15').do(job)`` will run ``job`` 15 minutes after every full hour. (Thanks @mattss.)\n- Refactored unit tests to mock ``datetime`` in a cleaner way. (Thanks @matts.)\n\n0.1.11 (2013-07-30)\n+++++++++++++++++++\n\n- Fixed an issue with ``next_run()`` throwing a ``ValueError`` exception when the job queue is empty. Thanks to @dpagano for pointing this out and thanks to @mrhwick for quickly providing a fix.\n\n0.1.10 (2013-06-07)\n+++++++++++++++++++\n\n- Fixed issue with ``at_time`` jobs not running on the same day the job is created (Thanks to @mattss)\n\n0.1.9 (2013-05-27)\n++++++++++++++++++\n\n- Added ``schedule.next_run()``\n- Added ``schedule.idle_seconds()``\n- Args passed into ``do()`` are forwarded to the job function at call time\n- Increased test coverage to 100%\n\n\n0.1.8 (2013-05-21)\n++++++++++++++++++\n\n- Changed default ``delay_seconds`` for ``schedule.run_all()`` to 0 (from 60)\n- Increased test coverage\n\n0.1.7 (2013-05-20)\n++++++++++++++++++\n\n- API change: renamed ``schedule.run_all_jobs()`` to ``schedule.run_all()``\n- API change: renamed ``schedule.run_pending_jobs()`` to ``schedule.run_pending()``\n- API change: renamed ``schedule.clear_all_jobs()`` to ``schedule.clear()``\n- Added ``schedule.jobs``\n\n0.1.6 (2013-05-20)\n++++++++++++++++++\n\n- Fix packaging\n- README fixes\n\n0.1.4 (2013-05-20)\n++++++++++++++++++\n\n- API change: renamed ``schedule.tick()`` to ``schedule.run_pending_jobs()``\n- Updated README and ``setup.py`` packaging\n\n0.1.0 (2013-05-19)\n++++++++++++++++++\n\n- Initial release\n"
        },
        {
          "name": "LICENSE.txt",
          "type": "blob",
          "size": 1.0732421875,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2013 Daniel Bader (http://dbader.org)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "MANIFEST.in",
          "type": "blob",
          "size": 0.1435546875,
          "content": "include README.rst\ninclude HISTORY.rst\ninclude LICENSE.txt\n\ninclude test_schedule.py\n\nrecursive-exclude * __pycache__\nrecursive-exclude * *.py[co]\n"
        },
        {
          "name": "README.rst",
          "type": "blob",
          "size": 2.234375,
          "content": "`schedule <https://schedule.readthedocs.io/>`__\n===============================================\n\n\n.. image:: https://github.com/dbader/schedule/workflows/Tests/badge.svg\n        :target: https://github.com/dbader/schedule/actions?query=workflow%3ATests+branch%3Amaster\n\n.. image:: https://coveralls.io/repos/dbader/schedule/badge.svg?branch=master\n        :target: https://coveralls.io/r/dbader/schedule\n\n.. image:: https://img.shields.io/pypi/v/schedule.svg\n        :target: https://pypi.python.org/pypi/schedule\n\nPython job scheduling for humans. Run Python functions (or any other callable) periodically using a friendly syntax.\n\n- A simple to use API for scheduling jobs, made for humans.\n- In-process scheduler for periodic jobs. No extra processes needed!\n- Very lightweight and no external dependencies.\n- Excellent test coverage.\n- Tested on Python and 3.7, 3.8, 3.9, 3.10, 3.11, 3.12\n\nUsage\n-----\n\n.. code-block:: bash\n\n    $ pip install schedule\n\n.. code-block:: python\n\n    import schedule\n    import time\n\n    def job():\n        print(\"I'm working...\")\n\n    schedule.every(10).seconds.do(job)\n    schedule.every(10).minutes.do(job)\n    schedule.every().hour.do(job)\n    schedule.every().day.at(\"10:30\").do(job)\n    schedule.every(5).to(10).minutes.do(job)\n    schedule.every().monday.do(job)\n    schedule.every().wednesday.at(\"13:15\").do(job)\n    schedule.every().day.at(\"12:42\", \"Europe/Amsterdam\").do(job)\n    schedule.every().minute.at(\":17\").do(job)\n\n    def job_with_argument(name):\n        print(f\"I am {name}\")\n\n    schedule.every(10).seconds.do(job_with_argument, name=\"Peter\")\n\n    while True:\n        schedule.run_pending()\n        time.sleep(1)\n\nDocumentation\n-------------\n\nSchedule's documentation lives at `schedule.readthedocs.io <https://schedule.readthedocs.io/>`_.\n\n\nMeta\n----\n\nDaniel Bader - `@dbader_org <https://twitter.com/dbader_org>`_ - mail@dbader.org\n\nInspired by `Adam Wiggins' <https://github.com/adamwiggins>`_ article `\"Rethinking Cron\" <https://adam.herokuapp.com/past/2010/4/13/rethinking_cron/>`_ and the `clockwork <https://github.com/Rykian/clockwork>`_ Ruby module.\n\nDistributed under the MIT license. See `LICENSE.txt <https://github.com/dbader/schedule/blob/master/LICENSE.txt>`_ for more information.\n\nhttps://github.com/dbader/schedule\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "pyproject.toml",
          "type": "blob",
          "size": 0.6533203125,
          "content": "[build-system]\nrequires = [\"setuptools >= 61.0\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[project]\nname = \"schedule\"\ndescription = \"Job scheduling for humans.\"\ndynamic = [\"version\", \"classifiers\", \"keywords\", \"authors\"]\nreadme = \"README.rst\"\nlicense = {text = \"MIT License\"}\n\nrequires-python = \">= 3.7\"\ndependencies = []\n\nmaintainers = [\n  {name = \"Sijmen Huizenga\"}\n]\n\n[project.optional-dependencies]\ntimezone = [\"pytz\"]\n\n[project.urls]\nDocumentation = \"https://schedule.readthedocs.io\"\nRepository = \"https://github.com/dbader/schedule.git\"\nIssues = \"https://github.com/dbader/schedule/issues\"\nChangelog = \"https://github.com/dbader/schedule/blob/master/HISTORY.rst\"\n"
        },
        {
          "name": "requirements-dev.txt",
          "type": "blob",
          "size": 0.1015625,
          "content": "docutils\nPygments\npytest\npytest-cov\npytest-flake8\nSphinx\nblack==20.8b1\nclick==8.0.4\nmypy\npytz\ntypes-pytz"
        },
        {
          "name": "schedule",
          "type": "tree",
          "content": null
        },
        {
          "name": "setup.cfg",
          "type": "blob",
          "size": 0.021484375,
          "content": "[mypy]\nfiles=schedule\n"
        },
        {
          "name": "setup.py",
          "type": "blob",
          "size": 1.55078125,
          "content": "import codecs\nfrom setuptools import setup\n\n\nSCHEDULE_VERSION = \"1.2.2\"\nSCHEDULE_DOWNLOAD_URL = \"https://github.com/dbader/schedule/tarball/\" + SCHEDULE_VERSION\n\n\ndef read_file(filename):\n    \"\"\"\n    Read a utf8 encoded text file and return its contents.\n    \"\"\"\n    with codecs.open(filename, \"r\", \"utf8\") as f:\n        return f.read()\n\n\nsetup(\n    name=\"schedule\",\n    packages=[\"schedule\"],\n    package_data={\"schedule\": [\"py.typed\"]},\n    version=SCHEDULE_VERSION,\n    description=\"Job scheduling for humans.\",\n    long_description=read_file(\"README.rst\"),\n    license=\"MIT\",\n    author=\"Daniel Bader\",\n    author_email=\"mail@dbader.org\",\n    url=\"https://github.com/dbader/schedule\",\n    download_url=SCHEDULE_DOWNLOAD_URL,\n    keywords=[\n        \"schedule\",\n        \"periodic\",\n        \"jobs\",\n        \"scheduling\",\n        \"clockwork\",\n        \"cron\",\n        \"scheduler\",\n        \"job scheduling\",\n    ],\n    classifiers=[\n        \"Intended Audience :: Developers\",\n        \"License :: OSI Approved :: MIT License\",\n        \"Development Status :: 5 - Production/Stable\",\n        \"Operating System :: OS Independent\",\n        \"Programming Language :: Python\",\n        \"Programming Language :: Python :: 3\",\n        \"Programming Language :: Python :: 3.7\",\n        \"Programming Language :: Python :: 3.8\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n        \"Programming Language :: Python :: 3.11\",\n        \"Programming Language :: Python :: 3.12\",\n        \"Natural Language :: English\",\n    ],\n    python_requires=\">=3.7\",\n)\n"
        },
        {
          "name": "test_schedule.py",
          "type": "blob",
          "size": 65.0048828125,
          "content": "\"\"\"Unit tests for schedule.py\"\"\"\n\nimport datetime\nimport functools\nfrom unittest import mock, TestCase\nimport os\nimport time\n\n# Silence \"missing docstring\", \"method could be a function\",\n# \"class already defined\", and \"too many public methods\" messages:\n# pylint: disable-msg=R0201,C0111,E0102,R0904,R0901\n\nimport schedule\nfrom schedule import (\n    every,\n    repeat,\n    ScheduleError,\n    ScheduleValueError,\n    IntervalError,\n)\n\n# POSIX TZ string format\nTZ_BERLIN = \"CET-1CEST,M3.5.0,M10.5.0/3\"\nTZ_AUCKLAND = \"NZST-12NZDT,M9.5.0,M4.1.0/3\"\nTZ_CHATHAM = \"<+1245>-12:45<+1345>,M9.5.0/2:45,M4.1.0/3:45\"\nTZ_UTC = \"UTC0\"\n\n# Set timezone to Europe/Berlin (CEST) to ensure global reproducibility\nos.environ[\"TZ\"] = TZ_BERLIN\ntime.tzset()\n\n\ndef make_mock_job(name=None):\n    job = mock.Mock()\n    job.__name__ = name or \"job\"\n    return job\n\n\nclass mock_datetime:\n    \"\"\"\n    Monkey-patch datetime for predictable results\n    \"\"\"\n\n    def __init__(self, year, month, day, hour, minute, second=0, zone=None, fold=0):\n        self.year = year\n        self.month = month\n        self.day = day\n        self.hour = hour\n        self.minute = minute\n        self.second = second\n        self.zone = zone\n        self.fold = fold\n        self.original_datetime = None\n        self.original_zone = None\n\n    def __enter__(self):\n        class MockDate(datetime.datetime):\n            @classmethod\n            def today(cls):\n                return cls(self.year, self.month, self.day)\n\n            @classmethod\n            def now(cls, tz=None):\n                mock_date = cls(\n                    self.year,\n                    self.month,\n                    self.day,\n                    self.hour,\n                    self.minute,\n                    self.second,\n                    fold=self.fold,\n                )\n                if tz:\n                    return mock_date.astimezone(tz)\n                return mock_date\n\n        self.original_datetime = datetime.datetime\n        datetime.datetime = MockDate\n\n        self.original_zone = os.environ.get(\"TZ\")\n        if self.zone:\n            os.environ[\"TZ\"] = self.zone\n            time.tzset()\n\n        return MockDate(\n            self.year, self.month, self.day, self.hour, self.minute, self.second\n        )\n\n    def __exit__(self, *args, **kwargs):\n        datetime.datetime = self.original_datetime\n        if self.original_zone:\n            os.environ[\"TZ\"] = self.original_zone\n            time.tzset()\n\n\nclass SchedulerTests(TestCase):\n    def setUp(self):\n        schedule.clear()\n\n    def make_tz_mock_job(self, name=None):\n        try:\n            import pytz\n        except ModuleNotFoundError:\n            self.skipTest(\"pytz unavailable\")\n            return\n        return make_mock_job(name)\n\n    def test_time_units(self):\n        assert every().seconds.unit == \"seconds\"\n        assert every().minutes.unit == \"minutes\"\n        assert every().hours.unit == \"hours\"\n        assert every().days.unit == \"days\"\n        assert every().weeks.unit == \"weeks\"\n\n        job_instance = schedule.Job(interval=2)\n        # without a context manager, it incorrectly raises an error because\n        # it is not callable\n        with self.assertRaises(IntervalError):\n            job_instance.minute\n        with self.assertRaises(IntervalError):\n            job_instance.hour\n        with self.assertRaises(IntervalError):\n            job_instance.day\n        with self.assertRaises(IntervalError):\n            job_instance.week\n        with self.assertRaisesRegex(\n            IntervalError,\n            (\n                r\"Scheduling \\.monday\\(\\) jobs is only allowed for weekly jobs\\. \"\n                r\"Using \\.monday\\(\\) on a job scheduled to run every 2 or more \"\n                r\"weeks is not supported\\.\"\n            ),\n        ):\n            job_instance.monday\n        with self.assertRaisesRegex(\n            IntervalError,\n            (\n                r\"Scheduling \\.tuesday\\(\\) jobs is only allowed for weekly jobs\\. \"\n                r\"Using \\.tuesday\\(\\) on a job scheduled to run every 2 or more \"\n                r\"weeks is not supported\\.\"\n            ),\n        ):\n            job_instance.tuesday\n        with self.assertRaisesRegex(\n            IntervalError,\n            (\n                r\"Scheduling \\.wednesday\\(\\) jobs is only allowed for weekly jobs\\. \"\n                r\"Using \\.wednesday\\(\\) on a job scheduled to run every 2 or more \"\n                r\"weeks is not supported\\.\"\n            ),\n        ):\n            job_instance.wednesday\n        with self.assertRaisesRegex(\n            IntervalError,\n            (\n                r\"Scheduling \\.thursday\\(\\) jobs is only allowed for weekly jobs\\. \"\n                r\"Using \\.thursday\\(\\) on a job scheduled to run every 2 or more \"\n                r\"weeks is not supported\\.\"\n            ),\n        ):\n            job_instance.thursday\n        with self.assertRaisesRegex(\n            IntervalError,\n            (\n                r\"Scheduling \\.friday\\(\\) jobs is only allowed for weekly jobs\\. \"\n                r\"Using \\.friday\\(\\) on a job scheduled to run every 2 or more \"\n                r\"weeks is not supported\\.\"\n            ),\n        ):\n            job_instance.friday\n        with self.assertRaisesRegex(\n            IntervalError,\n            (\n                r\"Scheduling \\.saturday\\(\\) jobs is only allowed for weekly jobs\\. \"\n                r\"Using \\.saturday\\(\\) on a job scheduled to run every 2 or more \"\n                r\"weeks is not supported\\.\"\n            ),\n        ):\n            job_instance.saturday\n        with self.assertRaisesRegex(\n            IntervalError,\n            (\n                r\"Scheduling \\.sunday\\(\\) jobs is only allowed for weekly jobs\\. \"\n                r\"Using \\.sunday\\(\\) on a job scheduled to run every 2 or more \"\n                r\"weeks is not supported\\.\"\n            ),\n        ):\n            job_instance.sunday\n\n        # test an invalid unit\n        job_instance.unit = \"foo\"\n        self.assertRaises(ScheduleValueError, job_instance.at, \"1:0:0\")\n        self.assertRaises(ScheduleValueError, job_instance._schedule_next_run)\n\n        # test start day exists but unit is not 'weeks'\n        job_instance.unit = \"days\"\n        job_instance.start_day = 1\n        self.assertRaises(ScheduleValueError, job_instance._schedule_next_run)\n\n        # test weeks with an invalid start day\n        job_instance.unit = \"weeks\"\n        job_instance.start_day = \"bar\"\n        self.assertRaises(ScheduleValueError, job_instance._schedule_next_run)\n\n        # test a valid unit with invalid hours/minutes/seconds\n        job_instance.unit = \"days\"\n        self.assertRaises(ScheduleValueError, job_instance.at, \"25:00:00\")\n        self.assertRaises(ScheduleValueError, job_instance.at, \"00:61:00\")\n        self.assertRaises(ScheduleValueError, job_instance.at, \"00:00:61\")\n\n        # test invalid time format\n        self.assertRaises(ScheduleValueError, job_instance.at, \"25:0:0\")\n        self.assertRaises(ScheduleValueError, job_instance.at, \"0:61:0\")\n        self.assertRaises(ScheduleValueError, job_instance.at, \"0:0:61\")\n\n        # test self.latest >= self.interval\n        job_instance.latest = 1\n        self.assertRaises(ScheduleError, job_instance._schedule_next_run)\n        job_instance.latest = 3\n        self.assertRaises(ScheduleError, job_instance._schedule_next_run)\n\n    def test_next_run_with_tag(self):\n        with mock_datetime(2014, 6, 28, 12, 0):\n            job1 = every(5).seconds.do(make_mock_job(name=\"job1\")).tag(\"tag1\")\n            job2 = every(2).hours.do(make_mock_job(name=\"job2\")).tag(\"tag1\", \"tag2\")\n            job3 = (\n                every(1)\n                .minutes.do(make_mock_job(name=\"job3\"))\n                .tag(\"tag1\", \"tag3\", \"tag2\")\n            )\n            assert schedule.next_run(\"tag1\") == job1.next_run\n            assert schedule.default_scheduler.get_next_run(\"tag2\") == job3.next_run\n            assert schedule.next_run(\"tag3\") == job3.next_run\n            assert schedule.next_run(\"tag4\") is None\n\n    def test_singular_time_units_match_plural_units(self):\n        assert every().second.unit == every().seconds.unit\n        assert every().minute.unit == every().minutes.unit\n        assert every().hour.unit == every().hours.unit\n        assert every().day.unit == every().days.unit\n        assert every().week.unit == every().weeks.unit\n\n    def test_time_range(self):\n        with mock_datetime(2014, 6, 28, 12, 0):\n            mock_job = make_mock_job()\n\n            # Choose a sample size large enough that it's unlikely the\n            # same value will be chosen each time.\n            minutes = set(\n                [\n                    every(5).to(30).minutes.do(mock_job).next_run.minute\n                    for i in range(100)\n                ]\n            )\n\n            assert len(minutes) > 1\n            assert min(minutes) >= 5\n            assert max(minutes) <= 30\n\n    def test_time_range_repr(self):\n        mock_job = make_mock_job()\n\n        with mock_datetime(2014, 6, 28, 12, 0):\n            job_repr = repr(every(5).to(30).minutes.do(mock_job))\n\n        assert job_repr.startswith(\"Every 5 to 30 minutes do job()\")\n\n    def test_at_time(self):\n        mock_job = make_mock_job()\n        assert every().day.at(\"10:30\").do(mock_job).next_run.hour == 10\n        assert every().day.at(\"10:30\").do(mock_job).next_run.minute == 30\n        assert every().day.at(\"20:59\").do(mock_job).next_run.minute == 59\n        assert every().day.at(\"10:30:50\").do(mock_job).next_run.second == 50\n\n        self.assertRaises(ScheduleValueError, every().day.at, \"2:30:000001\")\n        self.assertRaises(ScheduleValueError, every().day.at, \"::2\")\n        self.assertRaises(ScheduleValueError, every().day.at, \".2\")\n        self.assertRaises(ScheduleValueError, every().day.at, \"2\")\n        self.assertRaises(ScheduleValueError, every().day.at, \":2\")\n        self.assertRaises(ScheduleValueError, every().day.at, \" 2:30:00\")\n        self.assertRaises(ScheduleValueError, every().day.at, \"59:59\")\n        self.assertRaises(ScheduleValueError, every().do, lambda: 0)\n        self.assertRaises(TypeError, every().day.at, 2)\n\n        # without a context manager, it incorrectly raises an error because\n        # it is not callable\n        with self.assertRaises(IntervalError):\n            every(interval=2).second\n        with self.assertRaises(IntervalError):\n            every(interval=2).minute\n        with self.assertRaises(IntervalError):\n            every(interval=2).hour\n        with self.assertRaises(IntervalError):\n            every(interval=2).day\n        with self.assertRaises(IntervalError):\n            every(interval=2).week\n        with self.assertRaises(IntervalError):\n            every(interval=2).monday\n        with self.assertRaises(IntervalError):\n            every(interval=2).tuesday\n        with self.assertRaises(IntervalError):\n            every(interval=2).wednesday\n        with self.assertRaises(IntervalError):\n            every(interval=2).thursday\n        with self.assertRaises(IntervalError):\n            every(interval=2).friday\n        with self.assertRaises(IntervalError):\n            every(interval=2).saturday\n        with self.assertRaises(IntervalError):\n            every(interval=2).sunday\n\n    def test_until_time(self):\n        mock_job = make_mock_job()\n        # Check argument parsing\n        with mock_datetime(2020, 1, 1, 10, 0, 0) as m:\n            assert every().day.until(datetime.datetime(3000, 1, 1, 20, 30)).do(\n                mock_job\n            ).cancel_after == datetime.datetime(3000, 1, 1, 20, 30, 0)\n            assert every().day.until(datetime.datetime(3000, 1, 1, 20, 30, 50)).do(\n                mock_job\n            ).cancel_after == datetime.datetime(3000, 1, 1, 20, 30, 50)\n            assert every().day.until(datetime.time(12, 30)).do(\n                mock_job\n            ).cancel_after == m.replace(hour=12, minute=30, second=0, microsecond=0)\n            assert every().day.until(datetime.time(12, 30, 50)).do(\n                mock_job\n            ).cancel_after == m.replace(hour=12, minute=30, second=50, microsecond=0)\n\n            assert every().day.until(\n                datetime.timedelta(days=40, hours=5, minutes=12, seconds=42)\n            ).do(mock_job).cancel_after == datetime.datetime(2020, 2, 10, 15, 12, 42)\n\n            assert every().day.until(\"10:30\").do(mock_job).cancel_after == m.replace(\n                hour=10, minute=30, second=0, microsecond=0\n            )\n            assert every().day.until(\"10:30:50\").do(mock_job).cancel_after == m.replace(\n                hour=10, minute=30, second=50, microsecond=0\n            )\n            assert every().day.until(\"3000-01-01 10:30\").do(\n                mock_job\n            ).cancel_after == datetime.datetime(3000, 1, 1, 10, 30, 0)\n            assert every().day.until(\"3000-01-01 10:30:50\").do(\n                mock_job\n            ).cancel_after == datetime.datetime(3000, 1, 1, 10, 30, 50)\n            assert every().day.until(datetime.datetime(3000, 1, 1, 10, 30, 50)).do(\n                mock_job\n            ).cancel_after == datetime.datetime(3000, 1, 1, 10, 30, 50)\n\n        # Invalid argument types\n        self.assertRaises(TypeError, every().day.until, 123)\n        self.assertRaises(ScheduleValueError, every().day.until, \"123\")\n        self.assertRaises(ScheduleValueError, every().day.until, \"01-01-3000\")\n\n        # Using .until() with moments in the passed\n        self.assertRaises(\n            ScheduleValueError,\n            every().day.until,\n            datetime.datetime(2019, 12, 31, 23, 59),\n        )\n        self.assertRaises(\n            ScheduleValueError, every().day.until, datetime.timedelta(minutes=-1)\n        )\n        one_hour_ago = datetime.datetime.now() - datetime.timedelta(hours=1)\n        self.assertRaises(ScheduleValueError, every().day.until, one_hour_ago)\n\n        # Unschedule job after next_run passes the deadline\n        schedule.clear()\n        with mock_datetime(2020, 1, 1, 11, 35, 10):\n            mock_job.reset_mock()\n            every(5).seconds.until(datetime.time(11, 35, 20)).do(mock_job)\n            with mock_datetime(2020, 1, 1, 11, 35, 15):\n                schedule.run_pending()\n                assert mock_job.call_count == 1\n                assert len(schedule.jobs) == 1\n            with mock_datetime(2020, 1, 1, 11, 35, 20):\n                schedule.run_all()\n                assert mock_job.call_count == 2\n                assert len(schedule.jobs) == 0\n\n        # Unschedule job because current execution time has passed deadline\n        schedule.clear()\n        with mock_datetime(2020, 1, 1, 11, 35, 10):\n            mock_job.reset_mock()\n            every(5).seconds.until(datetime.time(11, 35, 20)).do(mock_job)\n            with mock_datetime(2020, 1, 1, 11, 35, 50):\n                schedule.run_pending()\n                assert mock_job.call_count == 0\n                assert len(schedule.jobs) == 0\n\n    def test_weekday_at_todady(self):\n        mock_job = make_mock_job()\n\n        # This date is a wednesday\n        with mock_datetime(2020, 11, 25, 22, 38, 5):\n            job = every().wednesday.at(\"22:38:10\").do(mock_job)\n            assert job.next_run.hour == 22\n            assert job.next_run.minute == 38\n            assert job.next_run.second == 10\n            assert job.next_run.year == 2020\n            assert job.next_run.month == 11\n            assert job.next_run.day == 25\n\n            job = every().wednesday.at(\"22:39\").do(mock_job)\n            assert job.next_run.hour == 22\n            assert job.next_run.minute == 39\n            assert job.next_run.second == 00\n            assert job.next_run.year == 2020\n            assert job.next_run.month == 11\n            assert job.next_run.day == 25\n\n    def test_at_time_hour(self):\n        with mock_datetime(2010, 1, 6, 12, 20):\n            mock_job = make_mock_job()\n            assert every().hour.at(\":30\").do(mock_job).next_run.hour == 12\n            assert every().hour.at(\":30\").do(mock_job).next_run.minute == 30\n            assert every().hour.at(\":30\").do(mock_job).next_run.second == 0\n            assert every().hour.at(\":10\").do(mock_job).next_run.hour == 13\n            assert every().hour.at(\":10\").do(mock_job).next_run.minute == 10\n            assert every().hour.at(\":10\").do(mock_job).next_run.second == 0\n            assert every().hour.at(\":00\").do(mock_job).next_run.hour == 13\n            assert every().hour.at(\":00\").do(mock_job).next_run.minute == 0\n            assert every().hour.at(\":00\").do(mock_job).next_run.second == 0\n\n            self.assertRaises(ScheduleValueError, every().hour.at, \"2:30:00\")\n            self.assertRaises(ScheduleValueError, every().hour.at, \"::2\")\n            self.assertRaises(ScheduleValueError, every().hour.at, \".2\")\n            self.assertRaises(ScheduleValueError, every().hour.at, \"2\")\n            self.assertRaises(ScheduleValueError, every().hour.at, \" 2:30\")\n            self.assertRaises(ScheduleValueError, every().hour.at, \"61:00\")\n            self.assertRaises(ScheduleValueError, every().hour.at, \"00:61\")\n            self.assertRaises(ScheduleValueError, every().hour.at, \"01:61\")\n            self.assertRaises(TypeError, every().hour.at, 2)\n\n            # test the 'MM:SS' format\n            assert every().hour.at(\"30:05\").do(mock_job).next_run.hour == 12\n            assert every().hour.at(\"30:05\").do(mock_job).next_run.minute == 30\n            assert every().hour.at(\"30:05\").do(mock_job).next_run.second == 5\n            assert every().hour.at(\"10:25\").do(mock_job).next_run.hour == 13\n            assert every().hour.at(\"10:25\").do(mock_job).next_run.minute == 10\n            assert every().hour.at(\"10:25\").do(mock_job).next_run.second == 25\n            assert every().hour.at(\"00:40\").do(mock_job).next_run.hour == 13\n            assert every().hour.at(\"00:40\").do(mock_job).next_run.minute == 0\n            assert every().hour.at(\"00:40\").do(mock_job).next_run.second == 40\n\n    def test_at_time_minute(self):\n        with mock_datetime(2010, 1, 6, 12, 20, 30):\n            mock_job = make_mock_job()\n            assert every().minute.at(\":40\").do(mock_job).next_run.hour == 12\n            assert every().minute.at(\":40\").do(mock_job).next_run.minute == 20\n            assert every().minute.at(\":40\").do(mock_job).next_run.second == 40\n            assert every().minute.at(\":10\").do(mock_job).next_run.hour == 12\n            assert every().minute.at(\":10\").do(mock_job).next_run.minute == 21\n            assert every().minute.at(\":10\").do(mock_job).next_run.second == 10\n\n            self.assertRaises(ScheduleValueError, every().minute.at, \"::2\")\n            self.assertRaises(ScheduleValueError, every().minute.at, \".2\")\n            self.assertRaises(ScheduleValueError, every().minute.at, \"2\")\n            self.assertRaises(ScheduleValueError, every().minute.at, \"2:30:00\")\n            self.assertRaises(ScheduleValueError, every().minute.at, \"2:30\")\n            self.assertRaises(ScheduleValueError, every().minute.at, \" :30\")\n            self.assertRaises(TypeError, every().minute.at, 2)\n\n    def test_next_run_time(self):\n        with mock_datetime(2010, 1, 6, 12, 15):\n            mock_job = make_mock_job()\n            assert schedule.next_run() is None\n            assert every().minute.do(mock_job).next_run.minute == 16\n            assert every(5).minutes.do(mock_job).next_run.minute == 20\n            assert every().hour.do(mock_job).next_run.hour == 13\n            assert every().day.do(mock_job).next_run.day == 7\n            assert every().day.at(\"09:00\").do(mock_job).next_run.day == 7\n            assert every().day.at(\"12:30\").do(mock_job).next_run.day == 6\n            assert every().week.do(mock_job).next_run.day == 13\n            assert every().monday.do(mock_job).next_run.day == 11\n            assert every().tuesday.do(mock_job).next_run.day == 12\n            assert every().wednesday.do(mock_job).next_run.day == 13\n            assert every().thursday.do(mock_job).next_run.day == 7\n            assert every().friday.do(mock_job).next_run.day == 8\n            assert every().saturday.do(mock_job).next_run.day == 9\n            assert every().sunday.do(mock_job).next_run.day == 10\n            assert (\n                every().minute.until(datetime.time(12, 17)).do(mock_job).next_run.minute\n                == 16\n            )\n\n    def test_next_run_time_day_end(self):\n        mock_job = make_mock_job()\n        # At day 1, schedule job to run at daily 23:30\n        with mock_datetime(2010, 12, 1, 23, 0, 0):\n            job = every().day.at(\"23:30\").do(mock_job)\n            # first occurrence same day\n            assert job.next_run.day == 1\n            assert job.next_run.hour == 23\n\n        # Running the job 01:00 on day 2, afterwards the job should be\n        # scheduled at 23:30 the same day. This simulates a job that started\n        # on day 1 at 23:30 and took 1,5 hours to finish\n        with mock_datetime(2010, 12, 2, 1, 0, 0):\n            job.run()\n            assert job.next_run.day == 2\n            assert job.next_run.hour == 23\n\n        # Run the job at 23:30 on day 2, afterwards the job should be\n        # scheduled at 23:30 the next day\n        with mock_datetime(2010, 12, 2, 23, 30, 0):\n            job.run()\n            assert job.next_run.day == 3\n            assert job.next_run.hour == 23\n\n    def test_next_run_time_hour_end(self):\n        try:\n            import pytz\n        except ModuleNotFoundError:\n            self.skipTest(\"pytz unavailable\")\n\n        self.tst_next_run_time_hour_end(None, 0)\n\n    def test_next_run_time_hour_end_london(self):\n        try:\n            import pytz\n        except ModuleNotFoundError:\n            self.skipTest(\"pytz unavailable\")\n\n        self.tst_next_run_time_hour_end(\"Europe/London\", 0)\n\n    def test_next_run_time_hour_end_katmandu(self):\n        try:\n            import pytz\n        except ModuleNotFoundError:\n            self.skipTest(\"pytz unavailable\")\n\n        # 12:00 in Berlin is 15:45 in Kathmandu\n        # this test schedules runs at :10 minutes, so job runs at\n        # 16:10 in Kathmandu, which is 13:25 in Berlin\n        # in local time we don't run at :10, but at :25, offset of 15 minutes\n        self.tst_next_run_time_hour_end(\"Asia/Kathmandu\", 15)\n\n    def tst_next_run_time_hour_end(self, tz, offsetMinutes):\n        mock_job = make_mock_job()\n\n        # So a job scheduled to run at :10 in Kathmandu, runs always 25 minutes\n        with mock_datetime(2010, 10, 10, 12, 0, 0):\n            job = every().hour.at(\":10\", tz).do(mock_job)\n            assert job.next_run.hour == 12\n            assert job.next_run.minute == 10 + offsetMinutes\n\n        with mock_datetime(2010, 10, 10, 13, 0, 0):\n            job.run()\n            assert job.next_run.hour == 13\n            assert job.next_run.minute == 10 + offsetMinutes\n\n        with mock_datetime(2010, 10, 10, 13, 30, 0):\n            job.run()\n            assert job.next_run.hour == 14\n            assert job.next_run.minute == 10 + offsetMinutes\n\n    def test_next_run_time_minute_end(self):\n        self.tst_next_run_time_minute_end(None)\n\n    def test_next_run_time_minute_end_london(self):\n        try:\n            import pytz\n        except ModuleNotFoundError:\n            self.skipTest(\"pytz unavailable\")\n\n        self.tst_next_run_time_minute_end(\"Europe/London\")\n\n    def test_next_run_time_minute_end_katmhandu(self):\n        try:\n            import pytz\n        except ModuleNotFoundError:\n            self.skipTest(\"pytz unavailable\")\n\n        self.tst_next_run_time_minute_end(\"Asia/Kathmandu\")\n\n    def tst_next_run_time_minute_end(self, tz):\n        mock_job = make_mock_job()\n        with mock_datetime(2010, 10, 10, 10, 10, 0):\n            job = every().minute.at(\":15\", tz).do(mock_job)\n            assert job.next_run.minute == 10\n            assert job.next_run.second == 15\n\n        with mock_datetime(2010, 10, 10, 10, 10, 59):\n            job.run()\n            assert job.next_run.minute == 11\n            assert job.next_run.second == 15\n\n        with mock_datetime(2010, 10, 10, 10, 12, 14):\n            job.run()\n            assert job.next_run.minute == 12\n            assert job.next_run.second == 15\n\n        with mock_datetime(2010, 10, 10, 10, 12, 16):\n            job.run()\n            assert job.next_run.minute == 13\n            assert job.next_run.second == 15\n\n    def test_tz(self):\n        mock_job = self.make_tz_mock_job()\n        with mock_datetime(2022, 2, 1, 23, 15):\n            # Current Berlin time: feb-1 23:15 (local)\n            # Current India time: feb-2 03:45\n            # Expected to run India time: feb-2 06:30\n            # Next run Berlin time: feb-2 02:00\n            next = every().day.at(\"06:30\", \"Asia/Kolkata\").do(mock_job).next_run\n            assert next.day == 2\n            assert next.hour == 2\n            assert next.minute == 0\n\n    def test_tz_daily_midnight(self):\n        mock_job = self.make_tz_mock_job()\n        with mock_datetime(2023, 4, 14, 4, 50):\n            # Current Berlin time: april-14 04:50 (local) (during daylight saving)\n            # Current US/Central time: april-13 21:50\n            # Expected to run US/Central time: april-14 00:00\n            # Next run Berlin time: april-14 07:00\n            next = every().day.at(\"00:00\", \"US/Central\").do(mock_job).next_run\n            assert next.day == 14\n            assert next.hour == 7\n            assert next.minute == 0\n\n    def test_tz_daily_half_hour_offset(self):\n        mock_job = self.make_tz_mock_job()\n        with mock_datetime(2022, 4, 8, 10, 0):\n            # Current Berlin time: 10:00 (local) (during daylight saving)\n            # Current NY time: 04:00\n            # Expected to run NY time: 10:30\n            # Next run Berlin time: 16:30\n            next = every().day.at(\"10:30\", \"America/New_York\").do(mock_job).next_run\n            assert next.hour == 16\n            assert next.minute == 30\n\n    def test_tz_daily_dst(self):\n        mock_job = self.make_tz_mock_job()\n        import pytz\n\n        with mock_datetime(2022, 3, 20, 10, 0):\n            # Current Berlin time: 10:00 (local) (NOT during daylight saving)\n            # Current NY time: 04:00 (during daylight saving)\n            # Expected to run NY time: 10:30\n            # Next run Berlin time: 15:30\n            tz = pytz.timezone(\"America/New_York\")\n            next = every().day.at(\"10:30\", tz).do(mock_job).next_run\n            assert next.hour == 15\n            assert next.minute == 30\n\n    def test_tz_daily_dst_skip_hour(self):\n        mock_job = self.make_tz_mock_job()\n        # Test the DST-case that is described in the documentation\n        with mock_datetime(2023, 3, 26, 1, 30):\n            # Current Berlin time: 01:30 (NOT during daylight saving)\n            # Expected to run: 02:30 - this time doesn't exist\n            #  because clock moves from 02:00 to 03:00\n            # Next run: 03:30\n            job = every().day.at(\"02:30\", \"Europe/Berlin\").do(mock_job)\n            assert job.next_run.day == 26\n            assert job.next_run.hour == 3\n            assert job.next_run.minute == 30\n        with mock_datetime(2023, 3, 27, 1, 30):\n            # the next day the job shall again run at 02:30\n            job.run()\n            assert job.next_run.day == 27\n            assert job.next_run.hour == 2\n            assert job.next_run.minute == 30\n\n    def test_tz_daily_dst_overlap_hour(self):\n        mock_job = self.make_tz_mock_job()\n        # Test the DST-case that is described in the documentation\n        with mock_datetime(2023, 10, 29, 1, 30):\n            # Current Berlin time: 01:30 (during daylight saving)\n            # Expected to run: 02:30 - this time exists twice\n            #  because clock moves from 03:00 to 02:00\n            # Next run should be at the first occurrence of 02:30\n            job = every().day.at(\"02:30\", \"Europe/Berlin\").do(mock_job)\n            assert job.next_run.day == 29\n            assert job.next_run.hour == 2\n            assert job.next_run.minute == 30\n        with mock_datetime(2023, 10, 29, 2, 35):\n            # After the job runs, the next run should be scheduled on the next day at 02:30\n            job.run()\n            assert job.next_run.day == 30\n            assert job.next_run.hour == 2\n            assert job.next_run.minute == 30\n\n    def test_tz_daily_exact_future_scheduling(self):\n        mock_job = self.make_tz_mock_job()\n        with mock_datetime(2022, 3, 20, 10, 0):\n            # Current Berlin time: 10:00 (local) (NOT during daylight saving)\n            # Current Krasnoyarsk time: 16:00\n            # Expected to run Krasnoyarsk time: mar-21 11:00\n            # Next run Berlin time: mar-21 05:00\n            # Expected idle seconds: 68400\n            schedule.clear()\n            every().day.at(\"11:00\", \"Asia/Krasnoyarsk\").do(mock_job)\n            expected_delta = (\n                datetime.datetime(2022, 3, 21, 5, 0) - datetime.datetime.now()\n            )\n            assert schedule.idle_seconds() == expected_delta.total_seconds()\n\n    def test_tz_daily_utc(self):\n        mock_job = self.make_tz_mock_job()\n        with mock_datetime(2023, 9, 18, 10, 59, 0, TZ_AUCKLAND):\n            # Testing issue #598\n            # Current Auckland time: 10:59 (local) (NOT during daylight saving)\n            # Current UTC time: 21:59 (17 september)\n            # Expected to run UTC time: sept-18 00:00\n            # Next run Auckland time: sept-18 12:00\n            schedule.clear()\n            next = every().day.at(\"00:00\", \"UTC\").do(mock_job).next_run\n            assert next.day == 18\n            assert next.hour == 12\n            assert next.minute == 0\n\n            # Test that .day.at() and .monday.at() are equivalent in this case\n            schedule.clear()\n            next = every().monday.at(\"00:00\", \"UTC\").do(mock_job).next_run\n            assert next.day == 18\n            assert next.hour == 12\n            assert next.minute == 0\n\n    def test_tz_daily_issue_592(self):\n        mock_job = self.make_tz_mock_job()\n        with mock_datetime(2023, 7, 15, 13, 0, 0, TZ_UTC):\n            # Testing issue #592\n            # Current UTC time: 13:00\n            # Expected to run US East time: 9:45 (daylight saving active)\n            # Next run UTC time: july-15 13:45\n            schedule.clear()\n            next = every().day.at(\"09:45\", \"US/Eastern\").do(mock_job).next_run\n            assert next.day == 15\n            assert next.hour == 13\n            assert next.minute == 45\n\n    def test_tz_daily_exact_seconds_precision(self):\n        mock_job = self.make_tz_mock_job()\n        with mock_datetime(2023, 10, 19, 15, 0, 0, TZ_UTC):\n            # Testing issue #603\n            # Current UTC: oktober-19 15:00\n            # Current Amsterdam: oktober-19 17:00 (daylight saving active)\n            # Expected run Amsterdam: oktober-20 00:00:20 (daylight saving active)\n            # Next run UTC time: oktober-19 22:00:20\n            schedule.clear()\n            next = every().day.at(\"00:00:20\", \"Europe/Amsterdam\").do(mock_job).next_run\n            assert next.day == 19\n            assert next.hour == 22\n            assert next.minute == 00\n            assert next.second == 20\n\n    def test_tz_weekly_sunday_conversion(self):\n        mock_job = self.make_tz_mock_job()\n        with mock_datetime(2023, 10, 22, 23, 0, 0, TZ_UTC):\n            # Current UTC: sunday 22-okt 23:00\n            # Current Amsterdam: monday 23-okt 01:00 (daylight saving active)\n            # Expected run Amsterdam: sunday 29 oktober 23:00 (daylight saving NOT active)\n            # Next run UTC time: oktober-29 22:00\n            schedule.clear()\n            next = every().sunday.at(\"23:00\", \"Europe/Amsterdam\").do(mock_job).next_run\n            assert next.day == 29\n            assert next.hour == 22\n            assert next.minute == 00\n\n    def test_tz_daily_new_year_offset(self):\n        mock_job = self.make_tz_mock_job()\n        with mock_datetime(2023, 12, 31, 23, 0, 0):\n            # Current Berlin time: dec-31 23:00 (local)\n            # Current Sydney time: jan-1 09:00 (next day)\n            # Expected to run Sydney time: jan-1 12:00\n            # Next run Berlin time: jan-1 02:00\n            next = every().day.at(\"12:00\", \"Australia/Sydney\").do(mock_job).next_run\n            assert next.day == 1\n            assert next.hour == 2\n            assert next.minute == 0\n\n    def test_tz_daily_end_year_cross_continent(self):\n        mock_job = self.make_tz_mock_job()\n        with mock_datetime(2023, 12, 31, 23, 50):\n            # End of the year in Berlin\n            # Current Berlin time: dec-31 23:50\n            # Current Tokyo time: jan-1 07:50 (next day)\n            # Expected to run Tokyo time: jan-1 09:00\n            # Next run Berlin time: jan-1 01:00\n            next = every().day.at(\"09:00\", \"Asia/Tokyo\").do(mock_job).next_run\n            assert next.day == 1\n            assert next.hour == 1\n            assert next.minute == 0\n\n    def test_tz_daily_end_month_offset(self):\n        mock_job = self.make_tz_mock_job()\n        with mock_datetime(2023, 2, 28, 23, 50):\n            # End of the month (non-leap year) in Berlin\n            # Current Berlin time: feb-28 23:50\n            # Current Sydney time: mar-1 09:50 (next day)\n            # Expected to run Sydney time: mar-1 10:00\n            # Next run Berlin time: mar-1 00:00\n            next = every().day.at(\"10:00\", \"Australia/Sydney\").do(mock_job).next_run\n            assert next.day == 1\n            assert next.hour == 0\n            assert next.minute == 0\n\n    def test_tz_daily_leap_year(self):\n        mock_job = self.make_tz_mock_job()\n        with mock_datetime(2024, 2, 28, 23, 50):\n            # End of the month (leap year) in Berlin\n            # Current Berlin time: feb-28 23:50\n            # Current Dubai time: feb-29 02:50\n            # Expected to run Dubai time: feb-29 04:00\n            # Next run Berlin time: feb-29 01:00\n            next = every().day.at(\"04:00\", \"Asia/Dubai\").do(mock_job).next_run\n            assert next.month == 2\n            assert next.day == 29\n            assert next.hour == 1\n            assert next.minute == 0\n\n    def test_tz_daily_issue_605(self):\n        mock_job = self.make_tz_mock_job()\n        with mock_datetime(2023, 9, 18, 10, 00, 0, TZ_AUCKLAND):\n            schedule.clear()\n            # Testing issue #605\n            # Current time: Monday 18 September 10:00 NZST\n            # Current time UTC: Sunday 17 September 22:00\n            # We expect the job to run at 23:00 on Sunday 17 September NZST\n            # That is an expected idle time of 1 hour\n            # Expected next run in NZST: 2023-09-18 11:00:00\n            next = schedule.every().day.at(\"23:00\", \"UTC\").do(mock_job).next_run\n            assert round(schedule.idle_seconds() / 3600) == 1\n            assert next.day == 18\n            assert next.hour == 11\n            assert next.minute == 0\n\n    def test_tz_daily_dst_starting_point(self):\n        mock_job = self.make_tz_mock_job()\n        with mock_datetime(2023, 3, 26, 1, 30):\n            # Daylight Saving Time starts in Berlin\n            # In Berlin, 26 March 2023, 02:00:00 clocks were turned forward 1 hour\n            # In London, 26 March 2023, 01:00:00 clocks were turned forward 1 hour\n            # Current Berlin time:  26 March 01:30 (UTC+1)\n            # Current London time:  26 March 00:30 (UTC+0)\n            # Expected London time: 26 March 02:00 (UTC+1)\n            # Expected Berlin time: 26 March 03:00 (UTC+2)\n            next = every().day.at(\"01:00\", \"Europe/London\").do(mock_job).next_run\n            assert next.day == 26\n            assert next.hour == 3\n            assert next.minute == 0\n\n    def test_tz_daily_dst_ending_point(self):\n        mock_job = self.make_tz_mock_job()\n        with mock_datetime(2023, 10, 29, 2, 30, fold=1):\n            # Daylight Saving Time ends in Berlin\n            # Current Berlin time: oct-29 02:30 (after moving back to 02:00 due to DST end)\n            # Current Istanbul time: oct-29 04:30\n            # Expected to run Istanbul time: oct-29 06:00\n            # Next run Berlin time: oct-29 04:00\n            next = every().day.at(\"06:00\", \"Europe/Istanbul\").do(mock_job).next_run\n            assert next.hour == 4\n            assert next.minute == 0\n\n    def test_tz_daily_issue_608_pre_dst(self):\n        mock_job = self.make_tz_mock_job()\n        with mock_datetime(2023, 9, 18, 10, 00, 0, TZ_AUCKLAND):\n            # See ticket #608\n            # Testing timezone conversion the week before daylight saving comes into effect\n            # Current time: Monday 18 September 10:00 NZST\n            # Current time UTC: Sunday 17 September 22:00\n            # Expected next run in NZST: 2023-09-18 11:00:00\n            schedule.clear()\n            next = schedule.every().day.at(\"23:00\", \"UTC\").do(mock_job).next_run\n            assert next.day == 18\n            assert next.hour == 11\n            assert next.minute == 0\n\n    def test_tz_daily_issue_608_post_dst(self):\n        mock_job = self.make_tz_mock_job()\n        with mock_datetime(2024, 4, 8, 10, 00, 0, TZ_AUCKLAND):\n            # See ticket #608\n            # Testing timezone conversion the week after daylight saving ends\n            # Current time: Monday 8 April 10:00 NZST\n            # Current time UTC: Sunday 7 April 22:00\n            # Expected next run in NZDT: 2023-04-08 11:00:00\n            schedule.clear()\n            next = schedule.every().day.at(\"23:00\", \"UTC\").do(mock_job).next_run\n            assert next.day == 8\n            assert next.hour == 11\n            assert next.minute == 0\n\n    def test_tz_daily_issue_608_mid_dst(self):\n        mock_job = self.make_tz_mock_job()\n        with mock_datetime(2023, 9, 25, 10, 00, 0, TZ_AUCKLAND):\n            # See ticket #608\n            # Testing timezone conversion during the week after daylight saving comes into effect\n            # Current time: Monday 25 September 10:00 NZDT\n            # Current time UTC: Sunday 24 September 21:00\n            # Expected next run in UTC:  2023-09-24 23:00\n            # Expected next run in NZDT: 2023-09-25 12:00\n            schedule.clear()\n            next = schedule.every().day.at(\"23:00\", \"UTC\").do(mock_job).next_run\n            assert next.month == 9\n            assert next.day == 25\n            assert next.hour == 12\n            assert next.minute == 0\n\n    def test_tz_daily_issue_608_before_dst_end(self):\n        mock_job = self.make_tz_mock_job()\n        with mock_datetime(2024, 4, 1, 10, 00, 0, TZ_AUCKLAND):\n            # See ticket #608\n            # Testing timezone conversion during the week before daylight saving ends\n            # Current time: Monday 1 April 10:00 NZDT\n            # Current time UTC: Friday 31 March 21:00\n            # Expected next run in UTC:  2023-03-31 23:00\n            # Expected next run in NZDT: 2024-04-01 12:00\n            schedule.clear()\n            next = schedule.every().day.at(\"23:00\", \"UTC\").do(mock_job).next_run\n            assert next.month == 4\n            assert next.day == 1\n            assert next.hour == 12\n            assert next.minute == 0\n\n    def test_tz_hourly_intermediate_conversion(self):\n        mock_job = self.make_tz_mock_job()\n        with mock_datetime(2024, 5, 4, 14, 37, 22, TZ_CHATHAM):\n            # Crurent time: 14:37:22  New Zealand, Chatham Islands (UTC +12:45)\n            # Current time: 3 may, 23:22:22 Canada, Newfoundland (UTC -2:30)\n            # Exected next run in Newfoundland: 4 may, 09:14:45\n            # Expected next run in Chatham: 5 may, 00:29:45\n            schedule.clear()\n            next = (\n                schedule.every(10)\n                .hours.at(\"14:45\", \"Canada/Newfoundland\")\n                .do(mock_job)\n                .next_run\n            )\n            assert next.day == 5\n            assert next.hour == 0\n            assert next.minute == 29\n            assert next.second == 45\n\n    def test_tz_minutes_year_round(self):\n        mock_job = self.make_tz_mock_job()\n        # Test a full year of scheduling across timezones, where one timezone\n        # is in the northern hemisphere and the other in the southern hemisphere\n        # These two timezones are also a bit exotic (not the usual UTC+1, UTC-1)\n        # Local timezone: Newfoundland, Canada: UTC-2:30 / DST UTC-3:30\n        # Remote timezone: Chatham Islands, New Zealand: UTC+12:45 / DST UTC+13:45\n        schedule.clear()\n        job = schedule.every(20).minutes.at(\":13\", \"Canada/Newfoundland\").do(mock_job)\n        with mock_datetime(2024, 9, 29, 2, 20, 0, TZ_CHATHAM):\n            # First run, nothing special, no utc-offset change\n            # Current time: 29 sept, 02:20:00  Chatham\n            # Current time: 28 sept, 11:05:00  Newfoundland\n            # Expected time: 28 sept, 11:20:13 Newfoundland\n            # Expected time: 29 sept, 02:40:13 Chatham\n            job.run()\n            assert job.next_run.day == 29\n            assert job.next_run.hour == 2\n            assert job.next_run.minute == 40\n            assert job.next_run.second == 13\n        with mock_datetime(2024, 9, 29, 2, 40, 14, TZ_CHATHAM):\n            # next-schedule happens 1 second behind schedule\n            job.run()\n            # On 29 Sep, 02:45 2024, in Chatham, the clock is moved +1 hour\n            # Thus, the next run happens AFTER the local timezone exits DST\n            # Current time:  29 sept, 02:40:14 Chatham      (UTC +12:45)\n            # Current time:  28 sept, 11:25:14 Newfoundland (UTC -2:30)\n            # Expected time: 28 sept, 11:45:13 Newfoundland (UTC -2:30)\n            # Expected time: 29 sept, 04:00:13 Chatham      (UTC +13:45)\n            assert job.next_run.day == 29\n            assert job.next_run.hour == 4\n            assert job.next_run.minute == 00\n            assert job.next_run.second == 13\n        with mock_datetime(2024, 11, 3, 2, 23, 55, TZ_CHATHAM, fold=0):\n            # Time is right before Newfoundland exits DST\n            # Local time will move 1 hour back at 03:00\n\n            job.run()\n            # There are no timezone switches yet, nothing special going on:\n            # Current time:  3 Nov, 02:23:55 Chatham\n            # Expected time: 3 Nov, 02:43:13 Chatham\n            assert job.next_run.day == 3\n            assert job.next_run.hour == 2\n            assert job.next_run.minute == 43  # Within the fold, first occurrence\n            assert job.next_run.second == 13\n        with mock_datetime(2024, 11, 3, 2, 23, 55, TZ_CHATHAM, fold=1):\n            # Time is during the fold. Local time has moved back 1 hour, this is\n            # the second occurrence of the 02:23 time.\n\n            job.run()\n            # Current time:  3 Nov, 02:23:55 Chatham\n            # Expected time: 3 Nov, 02:43:13 Chatham\n            assert job.next_run.day == 3\n            assert job.next_run.hour == 2\n            assert job.next_run.minute == 43\n            assert job.next_run.second == 13\n        with mock_datetime(2025, 3, 9, 19, 00, 00, TZ_CHATHAM):\n            # Time is right before Newfoundland enters DST\n            # At 02:00, the remote clock will move forward 1 hour\n\n            job.run()\n            # Current time:  9 March, 19:00:00 Chatham      (UTC +13:45)\n            # Current time:  9 March, 01:45:00 Newfoundland (UTC -3:30)\n            # Expected time: 9 March, 03:05:13 Newfoundland (UTC -2:30)\n            # Expected time  9 March, 19:20:13 Chatham      (UTC +13:45)\n\n            assert job.next_run.day == 9\n            assert job.next_run.hour == 19\n            assert job.next_run.minute == 20\n            assert job.next_run.second == 13\n        with mock_datetime(2025, 4, 7, 17, 55, 00, TZ_CHATHAM):\n            # Time is within the few hours before Catham exits DST\n            # At 03:45, the local clock moves back 1 hour\n\n            job.run()\n            # Current time:  7 April, 17:55:00 Chatham\n            # Current time:  7 April, 02:40:00 Newfoundland\n            # Expected time: 7 April, 03:00:13 Newfoundland\n            # Expected time  7 April, 18:15:13 Chatham\n            assert job.next_run.day == 7\n            assert job.next_run.hour == 18\n            assert job.next_run.minute == 15\n            assert job.next_run.second == 13\n        with mock_datetime(2025, 4, 7, 18, 55, 00, TZ_CHATHAM):\n            # Schedule the next run exactly when the clock moved backwards\n            # Curren time is before the clock-move, next run is after the clock change\n\n            job.run()\n            # Current time:  7 April, 18:55:00 Chatham\n            # Current time:  7 April, 03:40:00 Newfoundland\n            # Expected time: 7 April, 03:00:13 Newfoundland (clock moved back)\n            # Expected time  7 April, 19:15:13 Chatham\n            assert job.next_run.day == 7\n            assert job.next_run.hour == 19\n            assert job.next_run.minute == 15\n            assert job.next_run.second == 13\n        with mock_datetime(2025, 4, 7, 19, 15, 13, TZ_CHATHAM):\n            # Schedule during the fold in the remote timezone\n\n            job.run()\n            # Current time:  7 April, 19:15:13 Chatham\n            # Current time:  7 April, 03:00:13 Newfoundland (fold)\n            # Expected time: 7 April, 03:20:13 Newfoundland (fold)\n            # Expected time: 7 April, 19:35:13 Chatham\n            assert job.next_run.day == 7\n            assert job.next_run.hour == 19\n            assert job.next_run.minute == 35\n            assert job.next_run.second == 13\n\n    def test_tz_weekly_large_interval_forward(self):\n        mock_job = self.make_tz_mock_job()\n        # Testing scheduling large intervals that skip over clock move forward\n        with mock_datetime(2024, 3, 28, 11, 0, 0, TZ_BERLIN):\n            # At March 31st 2024, 02:00:00 clocks were turned forward 1 hour\n            schedule.clear()\n            next = (\n                schedule.every(7)\n                .days.at(\"11:00\", \"Europe/Berlin\")\n                .do(mock_job)\n                .next_run\n            )\n            assert next.month == 4\n            assert next.day == 4\n            assert next.hour == 11\n            assert next.minute == 0\n            assert next.second == 0\n\n    def test_tz_weekly_large_interval_backward(self):\n        mock_job = self.make_tz_mock_job()\n        import pytz\n\n        # Testing scheduling large intervals that skip over clock move back\n        with mock_datetime(2024, 10, 25, 11, 0, 0, TZ_BERLIN):\n            # At March 31st 2024, 02:00:00 clocks were turned forward 1 hour\n            schedule.clear()\n            next = (\n                schedule.every(7)\n                .days.at(\"11:00\", \"Europe/Berlin\")\n                .do(mock_job)\n                .next_run\n            )\n            assert next.month == 11\n            assert next.day == 1\n            assert next.hour == 11\n            assert next.minute == 0\n            assert next.second == 0\n\n    def test_tz_daily_skip_dst_change(self):\n        mock_job = self.make_tz_mock_job()\n        with mock_datetime(2024, 11, 3, 10, 0):\n            # At 3 November 2024, 02:00:00 clocks are turned backward 1 hour\n            # The job skips the whole DST change becaus it runs at 14:00\n            # Current time Berlin:     3 Nov, 10:00\n            # Current time Anchorage:  3 Nov, 00:00 (UTC-08:00)\n            # Expected time Anchorage: 3 Nov, 14:00 (UTC-09:00)\n            # Expected time Berlin:    4 Nov, 00:00\n            schedule.clear()\n            next = (\n                schedule.every()\n                .day.at(\"14:00\", \"America/Anchorage\")\n                .do(mock_job)\n                .next_run\n            )\n            assert next.day == 4\n            assert next.hour == 0\n            assert next.minute == 00\n\n    def test_tz_daily_different_simultaneous_dst_change(self):\n        mock_job = self.make_tz_mock_job()\n\n        # TZ_BERLIN_EXTRA is the same as Berlin, but during summer time\n        # moves the clock 2 hours forward instead of 1\n        # This is a fictional timezone\n        TZ_BERLIN_EXTRA = \"CET-01CEST-03,M3.5.0,M10.5.0/3\"\n        with mock_datetime(2024, 3, 31, 0, 0, 0, TZ_BERLIN_EXTRA):\n            # In Berlin at March 31 2024, 02:00:00 clocks were turned forward 1 hour\n            # In Berlin Extra, the clocks move forward 2 hour at the same time\n            # Current time Berlin Extra:  31 Mar, 00:00 (UTC+01:00)\n            # Current time Berlin:        31 Mar, 00:00 (UTC+01:00)\n            # Expected time Berlin:       31 Mar, 10:00 (UTC+02:00)\n            # Expected time Berlin Extra: 31 Mar, 11:00 (UTC+03:00)\n            schedule.clear()\n            next = (\n                schedule.every().day.at(\"10:00\", \"Europe/Berlin\").do(mock_job).next_run\n            )\n            assert next.day == 31\n            assert next.hour == 11\n            assert next.minute == 00\n\n    def test_tz_daily_opposite_dst_change(self):\n        mock_job = self.make_tz_mock_job()\n\n        # TZ_BERLIN_INVERTED changes in the opposite direction of Berlin\n        # This is a fictional timezone\n        TZ_BERLIN_INVERTED = \"CET-1CEST,M10.5.0/3,M3.5.0\"\n        with mock_datetime(2024, 3, 31, 0, 0, 0, TZ_BERLIN_INVERTED):\n            # In Berlin at March 31 2024, 02:00:00 clocks were turned forward 1 hour\n            # In Berlin Inverted, the clocks move back 1 hour at the same time\n            # Current time Berlin Inverted:  31 Mar, 00:00 (UTC+02:00)\n            # Current time Berlin:           31 Mar, 00:00 (UTC+01:00)\n            # Expected time Berlin:          31 Mar, 10:00 (UTC+02:00) +9 hour\n            # Expected time Berlin Inverted: 31 Mar, 09:00 (UTC+01:00)\n            schedule.clear()\n            next = (\n                schedule.every().day.at(\"10:00\", \"Europe/Berlin\").do(mock_job).next_run\n            )\n            assert next.day == 31\n            assert next.hour == 9\n            assert next.minute == 00\n\n    def test_tz_invalid_timezone_exceptions(self):\n        mock_job = self.make_tz_mock_job()\n        import pytz\n\n        with self.assertRaises(pytz.exceptions.UnknownTimeZoneError):\n            every().day.at(\"10:30\", \"FakeZone\").do(mock_job)\n\n        with self.assertRaises(ScheduleValueError):\n            every().day.at(\"10:30\", 43).do(mock_job)\n\n    def test_align_utc_offset_no_timezone(self):\n        job = schedule.every().day.at(\"10:00\").do(make_mock_job())\n        now = datetime.datetime(2024, 5, 11, 10, 30, 55, 0)\n        aligned_time = job._correct_utc_offset(now, fixate_time=True)\n        self.assertEqual(now, aligned_time)\n\n    def setup_utc_offset_test(self):\n        try:\n            import pytz\n        except ModuleNotFoundError:\n            self.skipTest(\"pytz unavailable\")\n        job = (\n            schedule.every()\n            .day.at(\"10:00\", \"Europe/Berlin\")\n            .do(make_mock_job(\"tz-test\"))\n        )\n        tz = pytz.timezone(\"Europe/Berlin\")\n        return (job, tz)\n\n    def test_align_utc_offset_no_change(self):\n        (job, tz) = self.setup_utc_offset_test()\n        now = tz.localize(datetime.datetime(2023, 3, 26, 1, 30))\n        aligned_time = job._correct_utc_offset(now, fixate_time=False)\n        self.assertEqual(now, aligned_time)\n\n    def test_align_utc_offset_with_dst_gap(self):\n        (job, tz) = self.setup_utc_offset_test()\n        # Non-existent time in Berlin timezone\n        gap_time = tz.localize(datetime.datetime(2024, 3, 31, 2, 30, 0))\n        aligned_time = job._correct_utc_offset(gap_time, fixate_time=True)\n\n        assert aligned_time.utcoffset() == datetime.timedelta(hours=2)\n        assert aligned_time.day == 31\n        assert aligned_time.hour == 3\n        assert aligned_time.minute == 30\n\n    def test_align_utc_offset_with_dst_fold(self):\n        (job, tz) = self.setup_utc_offset_test()\n        # This time exists twice, this is the first occurance\n        overlap_time = tz.localize(datetime.datetime(2024, 10, 27, 2, 30))\n        aligned_time = job._correct_utc_offset(overlap_time, fixate_time=False)\n        # Since the time exists twice, no fixate_time flag should yield the first occurrence\n        first_occurrence = tz.localize(datetime.datetime(2024, 10, 27, 2, 30, fold=0))\n        self.assertEqual(first_occurrence, aligned_time)\n\n    def test_align_utc_offset_with_dst_fold_fixate_1(self):\n        (job, tz) = self.setup_utc_offset_test()\n        # This time exists twice, this is the 1st occurance\n        overlap_time = tz.localize(datetime.datetime(2024, 10, 27, 1, 30), is_dst=True)\n        overlap_time += datetime.timedelta(\n            hours=1\n        )  # puts it at 02:30+02:00 (Which exists once)\n\n        aligned_time = job._correct_utc_offset(overlap_time, fixate_time=True)\n        # The time should not have moved, because the original time is valid\n        assert aligned_time.utcoffset() == datetime.timedelta(hours=2)\n        assert aligned_time.hour == 2\n        assert aligned_time.minute == 30\n        assert aligned_time.day == 27\n\n    def test_align_utc_offset_with_dst_fold_fixate_2(self):\n        (job, tz) = self.setup_utc_offset_test()\n        # 02:30 exists twice, this is the 2nd occurance\n        overlap_time = tz.localize(datetime.datetime(2024, 10, 27, 2, 30), is_dst=False)\n        # The time 2024-10-27 02:30:00+01:00 exists once\n\n        aligned_time = job._correct_utc_offset(overlap_time, fixate_time=True)\n        # The time was valid, should not have been moved\n        assert aligned_time.utcoffset() == datetime.timedelta(hours=1)\n        assert aligned_time.hour == 2\n        assert aligned_time.minute == 30\n        assert aligned_time.day == 27\n\n    def test_align_utc_offset_after_fold_fixate(self):\n        (job, tz) = self.setup_utc_offset_test()\n        # This time is 30 minutes after a folded hour.\n        duplicate_time = tz.localize(datetime.datetime(2024, 10, 27, 2, 30))\n        duplicate_time += datetime.timedelta(hours=1)\n\n        aligned_time = job._correct_utc_offset(duplicate_time, fixate_time=False)\n\n        assert aligned_time.utcoffset() == datetime.timedelta(hours=1)\n        assert aligned_time.hour == 3\n        assert aligned_time.minute == 30\n        assert aligned_time.day == 27\n\n    def test_daylight_saving_time(self):\n        mock_job = make_mock_job()\n        # 27 March 2022, 02:00:00 clocks were turned forward 1 hour\n        with mock_datetime(2022, 3, 27, 0, 0):\n            assert every(4).hours.do(mock_job).next_run.hour == 4\n\n        # Sunday, 30 October 2022, 03:00:00 clocks were turned backward 1 hour\n        with mock_datetime(2022, 10, 30, 0, 0):\n            assert every(4).hours.do(mock_job).next_run.hour == 4\n\n    def test_move_to_next_weekday_today(self):\n        monday = datetime.datetime(2024, 5, 13, 10, 27, 54)\n        tuesday = schedule._move_to_next_weekday(monday, \"monday\")\n        assert tuesday.day == 13  # today! Time didn't change.\n        assert tuesday.hour == 10\n        assert tuesday.minute == 27\n\n    def test_move_to_next_weekday_tommorrow(self):\n        monday = datetime.datetime(2024, 5, 13, 10, 27, 54)\n        tuesday = schedule._move_to_next_weekday(monday, \"tuesday\")\n        assert tuesday.day == 14  # 1 day ahead\n        assert tuesday.hour == 10\n        assert tuesday.minute == 27\n\n    def test_move_to_next_weekday_nextweek(self):\n        wednesday = datetime.datetime(2024, 5, 15, 10, 27, 54)\n        tuesday = schedule._move_to_next_weekday(wednesday, \"tuesday\")\n        assert tuesday.day == 21  # next week monday\n        assert tuesday.hour == 10\n        assert tuesday.minute == 27\n\n    def test_run_all(self):\n        mock_job = make_mock_job()\n        every().minute.do(mock_job)\n        every().hour.do(mock_job)\n        every().day.at(\"11:00\").do(mock_job)\n        schedule.run_all()\n        assert mock_job.call_count == 3\n\n    def test_run_all_with_decorator(self):\n        mock_job = make_mock_job()\n\n        @repeat(every().minute)\n        def job1():\n            mock_job()\n\n        @repeat(every().hour)\n        def job2():\n            mock_job()\n\n        @repeat(every().day.at(\"11:00\"))\n        def job3():\n            mock_job()\n\n        schedule.run_all()\n        assert mock_job.call_count == 3\n\n    def test_run_all_with_decorator_args(self):\n        mock_job = make_mock_job()\n\n        @repeat(every().minute, 1, 2, \"three\", foo=23, bar={})\n        def job(*args, **kwargs):\n            mock_job(*args, **kwargs)\n\n        schedule.run_all()\n        mock_job.assert_called_once_with(1, 2, \"three\", foo=23, bar={})\n\n    def test_run_all_with_decorator_defaultargs(self):\n        mock_job = make_mock_job()\n\n        @repeat(every().minute)\n        def job(nothing=None):\n            mock_job(nothing)\n\n        schedule.run_all()\n        mock_job.assert_called_once_with(None)\n\n    def test_job_func_args_are_passed_on(self):\n        mock_job = make_mock_job()\n        every().second.do(mock_job, 1, 2, \"three\", foo=23, bar={})\n        schedule.run_all()\n        mock_job.assert_called_once_with(1, 2, \"three\", foo=23, bar={})\n\n    def test_to_string(self):\n        def job_fun():\n            pass\n\n        s = str(every().minute.do(job_fun, \"foo\", bar=23))\n        assert s == (\n            \"Job(interval=1, unit=minutes, do=job_fun, \"\n            \"args=('foo',), kwargs={'bar': 23})\"\n        )\n        assert \"job_fun\" in s\n        assert \"foo\" in s\n        assert \"{'bar': 23}\" in s\n\n    def test_to_repr(self):\n        def job_fun():\n            pass\n\n        s = repr(every().minute.do(job_fun, \"foo\", bar=23))\n        assert s.startswith(\n            \"Every 1 minute do job_fun('foo', bar=23) (last run: [never], next run: \"\n        )\n        assert \"job_fun\" in s\n        assert \"foo\" in s\n        assert \"bar=23\" in s\n\n        # test repr when at_time is not None\n        s2 = repr(every().day.at(\"00:00\").do(job_fun, \"foo\", bar=23))\n        assert s2.startswith(\n            (\n                \"Every 1 day at 00:00:00 do job_fun('foo', \"\n                \"bar=23) (last run: [never], next run: \"\n            )\n        )\n\n        # Ensure Job.__repr__ does not throw exception on a partially-composed Job\n        s3 = repr(schedule.every(10))\n        assert s3 == \"Every 10 None do [None] (last run: [never], next run: [never])\"\n\n    def test_to_string_lambda_job_func(self):\n        assert len(str(every().minute.do(lambda: 1))) > 1\n        assert len(str(every().day.at(\"10:30\").do(lambda: 1))) > 1\n\n    def test_repr_functools_partial_job_func(self):\n        def job_fun(arg):\n            pass\n\n        job_fun = functools.partial(job_fun, \"foo\")\n        job_repr = repr(every().minute.do(job_fun, bar=True, somekey=23))\n        assert \"functools.partial\" in job_repr\n        assert \"bar=True\" in job_repr\n        assert \"somekey=23\" in job_repr\n\n    def test_to_string_functools_partial_job_func(self):\n        def job_fun(arg):\n            pass\n\n        job_fun = functools.partial(job_fun, \"foo\")\n        job_str = str(every().minute.do(job_fun, bar=True, somekey=23))\n        assert \"functools.partial\" in job_str\n        assert \"bar=True\" in job_str\n        assert \"somekey=23\" in job_str\n\n    def test_run_pending(self):\n        \"\"\"Check that run_pending() runs pending jobs.\n        We do this by overriding datetime.datetime with mock objects\n        that represent increasing system times.\n\n        Please note that it is *intended behavior that run_pending() does not\n        run missed jobs*. For example, if you've registered a job that\n        should run every minute and you only call run_pending() in one hour\n        increments then your job won't be run 60 times in between but\n        only once.\n        \"\"\"\n        mock_job = make_mock_job()\n\n        with mock_datetime(2010, 1, 6, 12, 15):\n            every().minute.do(mock_job)\n            every().hour.do(mock_job)\n            every().day.do(mock_job)\n            every().sunday.do(mock_job)\n            schedule.run_pending()\n            assert mock_job.call_count == 0\n\n        with mock_datetime(2010, 1, 6, 12, 16):\n            schedule.run_pending()\n            assert mock_job.call_count == 1\n\n        with mock_datetime(2010, 1, 6, 13, 16):\n            mock_job.reset_mock()\n            schedule.run_pending()\n            assert mock_job.call_count == 2\n\n        with mock_datetime(2010, 1, 7, 13, 16):\n            mock_job.reset_mock()\n            schedule.run_pending()\n            assert mock_job.call_count == 3\n\n        with mock_datetime(2010, 1, 10, 13, 16):\n            mock_job.reset_mock()\n            schedule.run_pending()\n            assert mock_job.call_count == 4\n\n    def test_run_every_weekday_at_specific_time_today(self):\n        mock_job = make_mock_job()\n        with mock_datetime(2010, 1, 6, 13, 16):  # january 6 2010 == Wednesday\n            every().wednesday.at(\"14:12\").do(mock_job)\n            schedule.run_pending()\n            assert mock_job.call_count == 0\n\n        with mock_datetime(2010, 1, 6, 14, 16):\n            schedule.run_pending()\n            assert mock_job.call_count == 1\n\n    def test_run_every_weekday_at_specific_time_past_today(self):\n        mock_job = make_mock_job()\n        with mock_datetime(2010, 1, 6, 13, 16):\n            every().wednesday.at(\"13:15\").do(mock_job)\n            schedule.run_pending()\n            assert mock_job.call_count == 0\n\n        with mock_datetime(2010, 1, 13, 13, 14):\n            schedule.run_pending()\n            assert mock_job.call_count == 0\n\n        with mock_datetime(2010, 1, 13, 13, 16):\n            schedule.run_pending()\n            assert mock_job.call_count == 1\n\n    def test_run_every_n_days_at_specific_time(self):\n        mock_job = make_mock_job()\n        with mock_datetime(2010, 1, 6, 11, 29):\n            every(2).days.at(\"11:30\").do(mock_job)\n            schedule.run_pending()\n            assert mock_job.call_count == 0\n\n        with mock_datetime(2010, 1, 6, 11, 31):\n            schedule.run_pending()\n            assert mock_job.call_count == 0\n\n        with mock_datetime(2010, 1, 7, 11, 31):\n            schedule.run_pending()\n            assert mock_job.call_count == 0\n\n        with mock_datetime(2010, 1, 8, 11, 29):\n            schedule.run_pending()\n            assert mock_job.call_count == 0\n\n        with mock_datetime(2010, 1, 8, 11, 31):\n            schedule.run_pending()\n            assert mock_job.call_count == 1\n\n        with mock_datetime(2010, 1, 10, 11, 31):\n            schedule.run_pending()\n            assert mock_job.call_count == 2\n\n    def test_next_run_property(self):\n        original_datetime = datetime.datetime\n        with mock_datetime(2010, 1, 6, 13, 16):\n            hourly_job = make_mock_job(\"hourly\")\n            daily_job = make_mock_job(\"daily\")\n            every().day.do(daily_job)\n            every().hour.do(hourly_job)\n            assert len(schedule.jobs) == 2\n            # Make sure the hourly job is first\n            assert schedule.next_run() == original_datetime(2010, 1, 6, 14, 16)\n\n    def test_idle_seconds(self):\n        assert schedule.default_scheduler.next_run is None\n        assert schedule.idle_seconds() is None\n\n        mock_job = make_mock_job()\n        with mock_datetime(2020, 12, 9, 21, 46):\n            job = every().hour.do(mock_job)\n            assert schedule.idle_seconds() == 60 * 60\n            schedule.cancel_job(job)\n            assert schedule.next_run() is None\n            assert schedule.idle_seconds() is None\n\n    def test_cancel_job(self):\n        def stop_job():\n            return schedule.CancelJob\n\n        mock_job = make_mock_job()\n\n        every().second.do(stop_job)\n        mj = every().second.do(mock_job)\n        assert len(schedule.jobs) == 2\n\n        schedule.run_all()\n        assert len(schedule.jobs) == 1\n        assert schedule.jobs[0] == mj\n\n        schedule.cancel_job(\"Not a job\")\n        assert len(schedule.jobs) == 1\n        schedule.default_scheduler.cancel_job(\"Not a job\")\n        assert len(schedule.jobs) == 1\n\n        schedule.cancel_job(mj)\n        assert len(schedule.jobs) == 0\n\n    def test_cancel_jobs(self):\n        def stop_job():\n            return schedule.CancelJob\n\n        every().second.do(stop_job)\n        every().second.do(stop_job)\n        every().second.do(stop_job)\n        assert len(schedule.jobs) == 3\n\n        schedule.run_all()\n        assert len(schedule.jobs) == 0\n\n    def test_tag_type_enforcement(self):\n        job1 = every().second.do(make_mock_job(name=\"job1\"))\n        self.assertRaises(TypeError, job1.tag, {})\n        self.assertRaises(TypeError, job1.tag, 1, \"a\", [])\n        job1.tag(0, \"a\", True)\n        assert len(job1.tags) == 3\n\n    def test_get_by_tag(self):\n        every().second.do(make_mock_job()).tag(\"job1\", \"tag1\")\n        every().second.do(make_mock_job()).tag(\"job2\", \"tag2\", \"tag4\")\n        every().second.do(make_mock_job()).tag(\"job3\", \"tag3\", \"tag4\")\n\n        # Test None input yields all 3\n        jobs = schedule.get_jobs()\n        assert len(jobs) == 3\n        assert {\"job1\", \"job2\", \"job3\"}.issubset(\n            {*jobs[0].tags, *jobs[1].tags, *jobs[2].tags}\n        )\n\n        # Test each 1:1 tag:job\n        jobs = schedule.get_jobs(\"tag1\")\n        assert len(jobs) == 1\n        assert \"job1\" in jobs[0].tags\n\n        # Test multiple jobs found.\n        jobs = schedule.get_jobs(\"tag4\")\n        assert len(jobs) == 2\n        assert \"job1\" not in {*jobs[0].tags, *jobs[1].tags}\n\n        # Test no tag.\n        jobs = schedule.get_jobs(\"tag5\")\n        assert len(jobs) == 0\n        schedule.clear()\n        assert len(schedule.jobs) == 0\n\n    def test_clear_by_tag(self):\n        every().second.do(make_mock_job(name=\"job1\")).tag(\"tag1\")\n        every().second.do(make_mock_job(name=\"job2\")).tag(\"tag1\", \"tag2\")\n        every().second.do(make_mock_job(name=\"job3\")).tag(\n            \"tag3\", \"tag3\", \"tag3\", \"tag2\"\n        )\n        assert len(schedule.jobs) == 3\n        schedule.run_all()\n        assert len(schedule.jobs) == 3\n        schedule.clear(\"tag3\")\n        assert len(schedule.jobs) == 2\n        schedule.clear(\"tag1\")\n        assert len(schedule.jobs) == 0\n        every().second.do(make_mock_job(name=\"job1\"))\n        every().second.do(make_mock_job(name=\"job2\"))\n        every().second.do(make_mock_job(name=\"job3\"))\n        schedule.clear()\n        assert len(schedule.jobs) == 0\n\n    def test_misconfigured_job_wont_break_scheduler(self):\n        \"\"\"\n        Ensure an interrupted job definition chain won't break\n        the scheduler instance permanently.\n        \"\"\"\n        scheduler = schedule.Scheduler()\n        scheduler.every()\n        scheduler.every(10).seconds\n        scheduler.run_pending()\n"
        },
        {
          "name": "tox.ini",
          "type": "blob",
          "size": 0.822265625,
          "content": "[tox]\nenvlist = py3{7,8,9,10,11,12}{,-pytz}\nskip_missing_interpreters = true\n\n\n[gh-actions]\npython =\n    3.7: py37, py37-pytz\n    3.8: py38, py38-pytz\n    3.9: py39, py39-pytz\n    3.10: py310, py310-pytz\n    3.11: py311, py311-pytz\n    3.12: py312, py312-pytz\n\n[testenv]\ndeps =\n    pytest\n    pytest-cov\n    mypy\n    types-pytz\n    pytz: pytz\ncommands =\n    py.test test_schedule.py schedule -v --cov schedule --cov-report term-missing\n    python -m mypy -p schedule --install-types --non-interactive\n\n[testenv:docs]\nchangedir = docs\ndeps = -rrequirements-dev.txt\ncommands = sphinx-build -W -b html -d {envtmpdir}/doctrees . {envtmpdir}/html\n\n[testenv:format]\ndeps = -rrequirements-dev.txt\ncommands = black --check .\n\n[testenv:setuppy]\ndeps = -rrequirements-dev.txt\ncommands =\n    python setup.py check --strict --metadata --restructuredtext\n"
        }
      ]
    }
  ]
}