{
  "metadata": {
    "timestamp": 1736561137168,
    "page": 81,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjkw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "Anjok07/ultimatevocalremovergui",
      "stars": 18966,
      "defaultBranch": "master",
      "files": [
        {
          "name": "README.md",
          "type": "blob",
          "size": 13.3876953125,
          "content": "# Ultimate Vocal Remover GUI v5.6\r\n<img src=\"https://raw.githubusercontent.com/Anjok07/ultimatevocalremovergui/master/gui_data/img/UVR_v5.6.png?raw=true\" />\r\n\r\n[![Release](https://img.shields.io/github/release/anjok07/ultimatevocalremovergui.svg)](https://github.com/anjok07/ultimatevocalremovergui/releases/latest)\r\n[![Downloads](https://img.shields.io/github/downloads/anjok07/ultimatevocalremovergui/total.svg)](https://github.com/anjok07/ultimatevocalremovergui/releases)\r\n\r\n## About\r\n\r\nThis application uses state-of-the-art source separation models to remove vocals from audio files. UVR's core developers trained all of the models provided in this package (except for the Demucs v3 and v4 4-stem models).\r\n\r\n- **Core Developers**\r\n    - [Anjok07](https://github.com/anjok07)\r\n    - [aufr33](https://github.com/aufr33)\r\n\r\n- **Support the Project**\r\n    - [Donate](https://www.buymeacoffee.com/uvr5)\r\n\r\n## Installation\r\n\r\nThese bundles contain the UVR interface, Python, PyTorch, and other dependencies needed to run the application effectively. No prerequisites are required.\r\n\r\n### Windows Installation\r\n\r\n- Please Note:\r\n    - This installer is intended for those running Windows 10 or higher. \r\n    - Application functionality for systems running Windows 7 or lower is not guaranteed.\r\n    - Application functionality for Intel Pentium & Celeron CPUs systems is not guaranteed.\r\n    - You must install UVR to the main C:\\ drive. Installing UVR to a secondary drive will cause instability.\r\n\r\n- Download the UVR installer for Windows via the link below:\r\n    - [Main Download Link](https://github.com/Anjok07/ultimatevocalremovergui/releases/download/v5.6/UVR_v5.6.0_setup.exe)\r\n    - [Main Download Link mirror](https://www.mediafire.com/file_premium/jiatpgp0ljou52p/UVR_v5.6.0_setup.exe/file)\r\n- If you use an **AMD Radeon or Intel Arc graphics card**, you can try the OpenCL version:\r\n    - [OpenCL Version - Main Download Link](https://github.com/Anjok07/ultimatevocalremovergui/releases/download/v5.6/UVR_v5.6.0_setup_opencl.exe)\r\n- Update Package instructions for those who have UVR already installed:\r\n    - If you already have UVR installed you can install this package over it or download it straight from the application or [click here for the patch](https://github.com/Anjok07/ultimatevocalremovergui/releases/download/v5.6/UVR_Patch_10_6_23_4_27.exe).\r\n\r\n<details id=\"WindowsManual\">\r\n  <summary>Windows Manual Installation</summary>\r\n\r\n### Manual Windows Installation\r\n\r\n- Download and extract the repository [here](https://github.com/Anjok07/ultimatevocalremovergui/archive/refs/heads/master.zip)\r\n- Download and install Python [here](https://www.python.org/ftp/python/3.9.8/python-3.9.8-amd64.exe)\r\n   - Make sure to check \"Add python.exe to PATH\" during the install\r\n- Run the following commands from the extracted repo directory:\r\n\r\n```\r\npython.exe -m pip install -r requirements.txt\r\n```\r\n\r\nIf you have a compatible Nvidia GPU, run the following command:\r\n\r\n```\r\npython.exe -m pip install --upgrade torch --extra-index-url https://download.pytorch.org/whl/cu117\r\n```\r\n\r\nIf you do not have FFmpeg or Rubber Band installed and want to avoid going through the process of installing them the long way, follow the instructions below.\r\n\r\n**FFmpeg Installation**\r\n\r\n- Download the precompiled build [here](https://www.gyan.dev/ffmpeg/builds/ffmpeg-release-essentials.zip)\r\n- From the archive, extract the following file to the UVR application directory:\r\n   - ```ffmpeg-5.1.2-essentials_build/bin/ffmpeg.exe```\r\n\r\n**Rubber Band Installation**\r\n\r\nIn order to use the Time Stretch or Change Pitch tool, you'll need Rubber Band.\r\n\r\n- Download the precompiled build [here](https://breakfastquay.com/files/releases/rubberband-3.1.2-gpl-executable-windows.zip)\r\n- From the archive, extract the following files to the UVR application directory:\r\n   - ```rubberband-3.1.2-gpl-executable-windows/rubberband.exe```\r\n   - ```rubberband-3.1.2-gpl-executable-windows/sndfile.dll```\r\n\r\n</details>\r\n\r\n### MacOS Installation\r\n- Please Note:\r\n    - The MacOS Sonoma mouse clicking issue has been fixed.\r\n    - MPS (GPU) acceleration for Mac M1 has been expanded to work with Demucs v4 and all MDX-Net models.\r\n    - This bundle is intended for those running macOS Big Sur and above.\r\n    - Application functionality for systems running macOS Catalina or lower is not guaranteed.\r\n    - Application functionality for older or budget Mac systems is not guaranteed.\r\n    - Once everything is installed, the application may take up to 5-10 minutes to start for the first time (depending on your Macbook).\r\n\r\n- Download the UVR dmg for MacOS via one of the links below:\r\n    - Mac M1 (arm64) users:\r\n       - [Main Download Link](https://github.com/Anjok07/ultimatevocalremovergui/releases/download/v5.6/Ultimate_Vocal_Remover_v5_6_MacOS_arm64.dmg)\r\n       - [Main Download Link mirror](https://www.mediafire.com/file_premium/u3rk54wsqadpy93/Ultimate_Vocal_Remover_v5_6_MacOS_arm64.dmg/file)\r\n\r\n    - Mac Intel (x86_64) users:\r\n       - [Main Download Link](https://github.com/Anjok07/ultimatevocalremovergui/releases/download/v5.6/Ultimate_Vocal_Remover_v5_6_MacOS_x86_64.dmg)\r\n       - [Main Download Link mirror](https://www.mediafire.com/file_premium/2gf1werx5ly5ylz/Ultimate_Vocal_Remover_v5_6_MacOS_x86_64.dmg/file)\r\n\r\n<details id=\"CannotOpen\">\r\n  <summary>MacOS Users: Having Trouble Opening UVR?</summary>\r\n\r\n> Due to Apples strict application security, you may need to follow these steps to open UVR.\r\n>\r\n> First, run the following command via Terminal.app to allow applications to run from all sources (it's recommended that you re-enable this once UVR opens properly.)\r\n> \r\n> ```bash\r\n> sudo spctl --master-disable\r\n> ```\r\n> \r\n> Second, run the following command to bypass Notarization: \r\n> \r\n> ```bash\r\n> sudo xattr -rd com.apple.quarantine /Applications/Ultimate\\ Vocal\\ Remover.app\r\n> ```\r\n\r\n</details>\r\n\r\n<details id=\"MacInstall\">\r\n  <summary>Manual MacOS Installation</summary>\r\n\r\n### Manual MacOS Installation\r\n\r\n- Download and save this repository [here](https://github.com/Anjok07/ultimatevocalremovergui/archive/refs/heads/master.zip)\r\n- Download and install Python 3.10 [here](https://www.python.org/ftp/python/3.10.9/python-3.10.9-macos11.pkg)\r\n- From the saved directory run the following - \r\n\r\n```\r\npip3 install -r requirements.txt\r\n```\r\n\r\n- If your Mac is running with an M1, please run the following command next. If not, skip this step. - \r\n\r\n```\r\ncp /Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/_soundfile_data/libsndfile_arm64.dylib /Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/_soundfile_data/libsndfile.dylib\r\n```\r\n\r\n**FFmpeg Installation**\r\n\r\n- Once everything is done installing, download the correct FFmpeg binary for your system [here](http://www.osxexperts.net) and place it into the main application directory.\r\n\r\n**Rubber Band Installation**\r\n\r\nIn order to use the Time Stretch or Change Pitch tool, you'll need Rubber Band.\r\n\r\n- Download the precompiled build [here](https://breakfastquay.com/files/releases/rubberband-3.1.2-gpl-executable-windows.zip)\r\n- From the archive, extract the following files to the UVR/lib_v5 application directory:\r\n   - ```rubberband-3.1.2-gpl-executable-macos/rubberband```\r\n\r\nThis process has been tested on a MacBook Pro 2021 (using M1) and a MacBook Air 2017 and is confirmed to be working on both.\r\n\r\n</details>\r\n\r\n\r\n### Linux Installation (Updated Instructions)\r\n\r\n<details id=\"LinuxInstall\">\r\n  <summary>See Linux Installation Instructions</summary>\r\n\r\n<br />\r\n\r\n**These installation instructions are for Debian & Arch-based Linux systems.**\r\n\r\n---\r\n\r\n#### **Step 1: Download the Repository**\r\n- Download and save this repository from [GitHub](https://github.com/Anjok07/ultimatevocalremovergui/archive/refs/heads/master.zip).\r\n- Extract the downloaded file to a directory of your choice.\r\n\r\n---\r\n\r\n#### **Step 2: Install Dependencies**\r\nUse the following commands based on your system type:\r\n\r\n**For Debian-based systems (Ubuntu, Mint, etc.):**\r\n```bash\r\nsudo apt update && sudo apt upgrade\r\nsudo apt-get install -y ffmpeg python3-pip python3-tk\r\n```\r\n\r\n**For Arch-based systems (EndeavourOS):**\r\n```bash\r\nsudo pacman -Syu\r\nsudo pacman -S ffmpeg python-pip tk\r\n```\r\n\r\n---\r\n\r\n#### **Step 3: Set Up a Virtual Environment (Recommended)**\r\nSetting up a virtual environment (venv) ensures that the program's dependencies do not interfere with system-wide Python packages.\r\n\r\n1. **Navigate to the extracted repository directory:**\r\n   ```bash\r\n   cd /path/to/ultimatevocalremovergui\r\n   ```\r\n\r\n2. **Create a virtual environment:**\r\n   ```bash\r\n   python3 -m venv venv\r\n   ```\r\n\r\n3. **Activate the virtual environment:**\r\n   - For **Debian-based and Arch-based systems:**\r\n     ```bash\r\n     source venv/bin/activate\r\n     ```\r\n\r\n4. **Install dependencies in the virtual environment:**\r\n   ```bash\r\n   pip install -r requirements.txt\r\n   ```\r\n\r\n---\r\n\r\n#### **Step 4: Run the Application**\r\nWhile the virtual environment is activated, start the application:\r\n```bash\r\npython UVR.py\r\n```\r\n\r\n---\r\n\r\n#### **Important Notes**\r\n1. **Avoid Modifying System Files:**  \r\n   Previous instructions suggested deleting the `/usr/lib/python3.11/EXTERNALLY-MANAGED` file, which is dangerous and can break Python package management. Do **NOT** delete this file.\r\n\r\n2. **Why Use Virtual Environments?**  \r\n   Virtual environments isolate the program's dependencies, preventing conflicts with system Python packages. More information is available [here](https://stackoverflow.com/questions/75602063/pip-install-r-requirements-txt-is-failing-this-environment-is-externally-mana/75696359#75696359).\r\n\r\n3. **Known Issues and Discussions:**  \r\n   - [Issue #1578](https://github.com/Anjok07/ultimatevocalremovergui/issues/1578)  \r\n   - [Pull Request #1068](https://github.com/Anjok07/ultimatevocalremovergui/pull/1068)\r\n\r\n---\r\n\r\nIf you encounter issues, refer to the [GitHub Issues](https://github.com/Anjok07/ultimatevocalremovergui/issues) page for help. \r\n\r\n</details>\r\n\r\n### Other Application Notes\r\n- Nvidia GTX 1060 6GB is the minimum requirement for GPU conversions.\r\n- Nvidia GPUs with at least 8GBs of V-RAM are recommended.\r\n- AMD Radeon GPU supported is limited at this time.\r\n   - There is currently a working branch for AMD GPU users [here](https://github.com/Anjok07/ultimatevocalremovergui/tree/v5.6-amd-gpu)\r\n- This application is only compatible with 64-bit platforms. \r\n- This application relies on the Rubber Band library for the Time-Stretch and Pitch-Shift options.\r\n- This application relies on FFmpeg to process non-wav audio files.\r\n- The application will automatically remember your settings when closed.\r\n- Conversion times will significantly depend on your hardware. \r\n- These models are computationally intensive. \r\n\r\n### Performance:\r\n- Model load times are faster.\r\n- Importing/exporting audio files is faster.\r\n\r\n## Troubleshooting\r\n\r\n### Common Issues\r\n\r\n- If FFmpeg is not installed, the application will throw an error if the user attempts to convert a non-WAV file.\r\n- Memory allocation errors can usually be resolved by lowering the \"Segment\" or \"Window\" sizes.\r\n\r\n#### MacOS Sonoma Left-click Bug\r\nThere's a known issue on MacOS Sonoma where left-clicks aren't registering correctly within the app. This was impacting all applications built with Tkinter on Sonoma and has since been resolved. Please download the latest version via the following link if you are still experiencing issues - [link](https://github.com/Anjok07/ultimatevocalremovergui/releases/tag/v5.6)\r\n\r\nThis issue was being tracked [here](https://github.com/Anjok07/ultimatevocalremovergui/issues/840).\r\n\r\n### Issue Reporting\r\n\r\nPlease be as detailed as possible when posting a new issue. \r\n\r\nIf possible, click the \"Settings Button\" to the left of the \"Start Processing\" button and click the \"Error Log\" button for detailed error information that can be provided to us.\r\n\r\n## License\r\n\r\nThe **Ultimate Vocal Remover GUI** code is [MIT-licensed](LICENSE). \r\n\r\n- **Please Note:** For all third-party application developers who wish to use our models, please honor the MIT license by providing credit to UVR and its developers.\r\n\r\n## Credits\r\n- [ZFTurbo](https://github.com/ZFTurbo) - Created & trained the weights for the new MDX23C models. \r\n- [DilanBoskan](https://github.com/DilanBoskan) - Your contributions at the start of this project were essential to the success of UVR. Thank you!\r\n- [Bas Curtiz](https://www.youtube.com/user/bascurtiz) - Designed the official UVR logo, icon, banner, and splash screen.\r\n- [tsurumeso](https://github.com/tsurumeso) - Developed the original VR Architecture code. \r\n- [Kuielab & Woosung Choi](https://github.com/kuielab) - Developed the original MDX-Net AI code. \r\n- [Adefossez & Demucs](https://github.com/facebookresearch/demucs) - Developed the original Demucs AI code. \r\n- [KimberleyJSN](https://github.com/KimberleyJensen) - Advised and aided the implementation of the training scripts for MDX-Net and Demucs. Thank you!\r\n- [Hv](https://github.com/NaJeongMo/Colab-for-MDX_B) - Helped implement chunks into the MDX-Net AI code. Thank you!\r\n\r\n## Contributing\r\n\r\n- For anyone interested in the ongoing development of **Ultimate Vocal Remover GUI**, please send us a pull request, and we will review it. \r\n- This project is 100% open-source and free for anyone to use and modify as they wish. \r\n- We only maintain the development and support for the **Ultimate Vocal Remover GUI** and the models provided. \r\n\r\n## References\r\n- [1] Takahashi et al., \"Multi-scale Multi-band DenseNets for Audio Source Separation\", https://arxiv.org/pdf/1706.09588.pdf\r\n"
        },
        {
          "name": "UVR.py",
          "type": "blob",
          "size": 402.060546875,
          "content": "# GUI modules\r\nimport time\r\n#start_time = time.time()\r\nimport audioread\r\nimport gui_data.sv_ttk\r\nimport hashlib\r\nimport json\r\nimport librosa\r\nimport math\r\nimport natsort\r\nimport os\r\nimport pickle\r\nimport psutil\r\nfrom pyglet import font as pyglet_font\r\nimport pyperclip\r\nimport base64\r\nimport queue\r\nimport shutil\r\nimport subprocess\r\nimport soundfile as sf\r\nimport torch\r\nimport urllib.request\r\nimport webbrowser\r\nimport wget\r\nimport traceback\r\nimport matchering as match\r\nimport tkinter as tk\r\nimport tkinter.ttk as ttk\r\nfrom tkinter.font import Font\r\nfrom tkinter import filedialog\r\nfrom tkinter import messagebox\r\nfrom collections import Counter\r\nfrom __version__ import VERSION, PATCH, PATCH_MAC, PATCH_LINUX\r\nfrom cryptography.fernet import Fernet\r\nfrom cryptography.hazmat.primitives import hashes\r\nfrom cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC\r\nfrom datetime import datetime\r\nfrom gui_data.constants import *\r\nfrom gui_data.app_size_values import *\r\nfrom gui_data.error_handling import error_text, error_dialouge\r\nfrom gui_data.old_data_check import file_check, remove_unneeded_yamls, remove_temps\r\nfrom gui_data.tkinterdnd2 import TkinterDnD, DND_FILES\r\nfrom lib_v5.vr_network.model_param_init import ModelParameters\r\nfrom kthread import KThread\r\nfrom lib_v5 import spec_utils\r\nfrom pathlib  import Path\r\nfrom separate import (\r\n    SeperateDemucs, SeperateMDX, SeperateMDXC, SeperateVR,  # Model-related\r\n    save_format, clear_gpu_cache,  # Utility functions\r\n    cuda_available, mps_available, #directml_available,\r\n)\r\nfrom playsound import playsound\r\nfrom typing import List\r\nimport onnx\r\nimport re\r\nimport sys\r\nimport yaml\r\nfrom ml_collections import ConfigDict\r\nfrom collections import Counter\r\n\r\n# if not is_macos:\r\n#     import torch_directml\r\n\r\n# is_choose_arch = cuda_available and directml_available\r\n# is_opencl_only = not cuda_available and directml_available\r\n# is_cuda_only = cuda_available and not directml_available\r\n\r\nis_gpu_available = cuda_available or mps_available# or directml_available\r\n\r\n# Change the current working directory to the directory\r\n# this file sits in\r\nif getattr(sys, 'frozen', False):\r\n    # If the application is run as a bundle, the PyInstaller bootloader\r\n    # extends the sys module by a flag frozen=True and sets the app\r\n    # path into variable _MEIPASS'.\r\n    BASE_PATH = sys._MEIPASS\r\nelse:\r\n    BASE_PATH = os.path.dirname(os.path.abspath(__file__))\r\n\r\nos.chdir(BASE_PATH)  # Change the current working directory to the base path\r\n\r\nSPLASH_DOC = os.path.join(BASE_PATH, 'tmp', 'splash.txt')\r\n\r\nif os.path.isfile(SPLASH_DOC):\r\n    os.remove(SPLASH_DOC)\r\n\r\ndef get_execution_time(function, name):\r\n    start = time.time()\r\n    function()\r\n    end = time.time()\r\n    time_difference = end - start\r\n    print(f'{name} Execution Time: ', time_difference)\r\n\r\nPREVIOUS_PATCH_WIN = 'UVR_Patch_10_6_23_4_27'\r\n\r\nis_dnd_compatible = True\r\nbanner_placement = -2\r\n\r\nif OPERATING_SYSTEM==\"Darwin\":\r\n    OPEN_FILE_func = lambda input_string:subprocess.Popen([\"open\", input_string])\r\n    dnd_path_check = MAC_DND_CHECK\r\n    banner_placement = -8\r\n    current_patch = PATCH_MAC\r\n    is_windows = False\r\n    is_macos = True\r\n    right_click_button = '<Button-2>'\r\n    application_extension = \".dmg\"\r\nelif OPERATING_SYSTEM==\"Linux\":\r\n    OPEN_FILE_func = lambda input_string:subprocess.Popen([\"xdg-open\", input_string])\r\n    dnd_path_check = LINUX_DND_CHECK\r\n    current_patch = PATCH_LINUX\r\n    is_windows = False\r\n    is_macos = False\r\n    right_click_button = '<Button-3>'\r\n    application_extension = \".zip\"\r\nelif OPERATING_SYSTEM==\"Windows\":\r\n    OPEN_FILE_func = lambda input_string:os.startfile(input_string)\r\n    dnd_path_check = WINDOWS_DND_CHECK\r\n    current_patch = PATCH\r\n    is_windows = True\r\n    is_macos = False\r\n    right_click_button = '<Button-3>'\r\n    application_extension = \".exe\"\r\n\r\ndef right_click_release_linux(window, top_win=None):\r\n    if OPERATING_SYSTEM==\"Linux\":\r\n        root.bind('<Button-1>', lambda e:window.destroy())\r\n        if top_win:\r\n            top_win.bind('<Button-1>', lambda e:window.destroy())\r\n\r\nif not is_windows:\r\n    import ssl\r\n    ssl._create_default_https_context = ssl._create_unverified_context\r\nelse:\r\n    from ctypes import windll, wintypes\r\n    \r\ndef close_process(q:queue.Queue):\r\n    def close_splash():\r\n        name = \"UVR_Launcher.exe\"\r\n        for process in psutil.process_iter(attrs=[\"name\"]):\r\n            process_name = process.info.get(\"name\")\r\n            \r\n            if process_name == name:\r\n                try:\r\n                    process.terminate()\r\n                    q.put(f\"{name} terminated.\")  # Push message to queue\r\n                    break\r\n                except psutil.NoSuchProcess as e:\r\n                    q.put(f\"Error terminating {name}: {e}\")  # Push error to queue\r\n                    \r\n                    try:\r\n                        with open(SPLASH_DOC, 'w') as f:\r\n                            f.write('1')\r\n                    except:\r\n                        print('No splash screen.')\r\n\r\n    thread = KThread(target=close_splash)\r\n    thread.start()\r\n\r\ndef save_data(data):\r\n    \"\"\"\r\n    Saves given data as a .pkl (pickle) file\r\n\r\n    Paramters:\r\n        data(dict):\r\n            Dictionary containing all the necessary data to save\r\n    \"\"\"\r\n    # Open data file, create it if it does not exist\r\n    with open('data.pkl', 'wb') as data_file:\r\n        pickle.dump(data, data_file)\r\n\r\ndef load_data() -> dict:\r\n    \"\"\"\r\n    Loads saved pkl file and returns the stored data\r\n\r\n    Returns(dict):\r\n        Dictionary containing all the saved data\r\n    \"\"\"\r\n    try:\r\n        with open('data.pkl', 'rb') as data_file:  # Open data file\r\n            data = pickle.load(data_file)\r\n\r\n        return data\r\n    except (ValueError, FileNotFoundError):\r\n        # Data File is corrupted or not found so recreate it\r\n\r\n        save_data(data=DEFAULT_DATA)\r\n\r\n        return load_data()\r\n\r\ndef load_model_hash_data(dictionary):\r\n    '''Get the model hash dictionary'''\r\n    with open(dictionary, 'r') as d:\r\n        return json.load(d)\r\n\r\ndef font_checker(font_file):\r\n    chosen_font_name = None\r\n    chosen_font_file = None\r\n    \r\n    try:\r\n        if os.path.isfile(font_file):\r\n            with open(font_file, 'r') as d:\r\n                chosen_font = json.load(d)\r\n                \r\n            chosen_font_name = chosen_font[\"font_name\"]\r\n            if chosen_font[\"font_file\"]:\r\n                chosen_font_file = os.path.join(OTHER_FONT_PATH, chosen_font[\"font_file\"])\r\n                chosen_font_file = chosen_font_file if os.path.isfile(chosen_font_file) else None\r\n    except Exception as e:\r\n        print(e)\r\n        \r\n    chosen_font = chosen_font_name, chosen_font_file\r\n     \r\n    return chosen_font\r\n        \r\ndebugger = []\r\n\r\n#--Constants--\r\n#Models\r\nMODELS_DIR = os.path.join(BASE_PATH, 'models')\r\nVR_MODELS_DIR = os.path.join(MODELS_DIR, 'VR_Models')\r\nMDX_MODELS_DIR = os.path.join(MODELS_DIR, 'MDX_Net_Models')\r\nDEMUCS_MODELS_DIR = os.path.join(MODELS_DIR, 'Demucs_Models')\r\nDEMUCS_NEWER_REPO_DIR = os.path.join(DEMUCS_MODELS_DIR, 'v3_v4_repo')\r\nMDX_MIXER_PATH = os.path.join(BASE_PATH, 'lib_v5', 'mixer.ckpt')\r\n\r\n#Cache & Parameters\r\nVR_HASH_DIR = os.path.join(VR_MODELS_DIR, 'model_data')\r\nVR_HASH_JSON = os.path.join(VR_MODELS_DIR, 'model_data', 'model_data.json')\r\nMDX_HASH_DIR = os.path.join(MDX_MODELS_DIR, 'model_data')\r\nMDX_HASH_JSON = os.path.join(MDX_HASH_DIR, 'model_data.json')\r\nMDX_C_CONFIG_PATH = os.path.join(MDX_HASH_DIR, 'mdx_c_configs')\r\n\r\nDEMUCS_MODEL_NAME_SELECT = os.path.join(DEMUCS_MODELS_DIR, 'model_data', 'model_name_mapper.json')\r\nMDX_MODEL_NAME_SELECT = os.path.join(MDX_MODELS_DIR, 'model_data', 'model_name_mapper.json')\r\nENSEMBLE_CACHE_DIR = os.path.join(BASE_PATH, 'gui_data', 'saved_ensembles')\r\nSETTINGS_CACHE_DIR = os.path.join(BASE_PATH, 'gui_data', 'saved_settings')\r\nVR_PARAM_DIR = os.path.join(BASE_PATH, 'lib_v5', 'vr_network', 'modelparams')\r\nSAMPLE_CLIP_PATH = os.path.join(BASE_PATH, 'temp_sample_clips')\r\nENSEMBLE_TEMP_PATH = os.path.join(BASE_PATH, 'ensemble_temps')\r\nDOWNLOAD_MODEL_CACHE = os.path.join(BASE_PATH, 'gui_data', 'model_manual_download.json')\r\n\r\n#CR Text\r\nCR_TEXT = os.path.join(BASE_PATH, 'gui_data', 'cr_text.txt')\r\n\r\n#Style\r\nICON_IMG_PATH = os.path.join(BASE_PATH, 'gui_data', 'img', 'GUI-Icon.ico')\r\nif not is_windows:\r\n    MAIN_ICON_IMG_PATH = os.path.join(BASE_PATH, 'gui_data', 'img', 'GUI-Icon.png')\r\n\r\nOWN_FONT_PATH = os.path.join(BASE_PATH, 'gui_data', 'own_font.json')\r\n\r\nMAIN_FONT_NAME = 'Montserrat'\r\nSEC_FONT_NAME = 'Century Gothic'\r\nFONT_PATH = os.path.join(BASE_PATH, 'gui_data', 'fonts', 'Montserrat', 'Montserrat.ttf')#\r\nSEC_FONT_PATH = os.path.join(BASE_PATH, 'gui_data', 'fonts', 'centurygothic', 'GOTHIC.ttf')#\r\nOTHER_FONT_PATH = os.path.join(BASE_PATH, 'gui_data', 'fonts', 'other')#\r\n\r\nFONT_MAPPER = {MAIN_FONT_NAME:FONT_PATH,\r\n               SEC_FONT_NAME:SEC_FONT_PATH}\r\n\r\n#Other\r\nCOMPLETE_CHIME = os.path.join(BASE_PATH, 'gui_data', 'complete_chime.wav')\r\nFAIL_CHIME = os.path.join(BASE_PATH, 'gui_data', 'fail_chime.wav')\r\nCHANGE_LOG = os.path.join(BASE_PATH, 'gui_data', 'change_log.txt')\r\n\r\nDENOISER_MODEL_PATH = os.path.join(VR_MODELS_DIR, 'UVR-DeNoise-Lite.pth')\r\nDEVERBER_MODEL_PATH = os.path.join(VR_MODELS_DIR, 'UVR-DeEcho-DeReverb.pth')\r\n\r\nMODEL_DATA_URLS = [VR_MODEL_DATA_LINK, MDX_MODEL_DATA_LINK, MDX_MODEL_NAME_DATA_LINK, DEMUCS_MODEL_NAME_DATA_LINK]\r\nMODEL_DATA_FILES = [VR_HASH_JSON, MDX_HASH_JSON, MDX_MODEL_NAME_SELECT, DEMUCS_MODEL_NAME_SELECT]\r\n\r\nfile_check(os.path.join(MODELS_DIR, 'Main_Models'), VR_MODELS_DIR)\r\nfile_check(os.path.join(DEMUCS_MODELS_DIR, 'v3_repo'), DEMUCS_NEWER_REPO_DIR)\r\nremove_unneeded_yamls(DEMUCS_MODELS_DIR)\r\n\r\nremove_temps(ENSEMBLE_TEMP_PATH)\r\nremove_temps(SAMPLE_CLIP_PATH)\r\nremove_temps(os.path.join(BASE_PATH, 'img'))\r\n\r\nif not os.path.isdir(ENSEMBLE_TEMP_PATH):\r\n    os.mkdir(ENSEMBLE_TEMP_PATH)\r\n    \r\nif not os.path.isdir(SAMPLE_CLIP_PATH):\r\n    os.mkdir(SAMPLE_CLIP_PATH)\r\n\r\nmodel_hash_table = {}\r\ndata = load_data()\r\n\r\ndef drop(event, accept_mode: str = 'files'):\r\n    path = event.data\r\n    if accept_mode == 'folder':\r\n        path = path.replace('{', '').replace('}', '')\r\n        if not os.path.isdir(path):\r\n            messagebox.showerror(parent=root,\r\n                                    title=INVALID_FOLDER_ERROR_TEXT[0],\r\n                                    message=INVALID_FOLDER_ERROR_TEXT[1])\r\n            return\r\n        root.export_path_var.set(path)\r\n    elif accept_mode in ['files', FILE_1, FILE_2, FILE_1_LB, FILE_2_LB]:\r\n        path = path.replace(\"{\", \"\").replace(\"}\", \"\")\r\n        for dnd_file in dnd_path_check:\r\n            path = path.replace(f\" {dnd_file}\", f\";{dnd_file}\")\r\n        path = path.split(';')\r\n        path[-1] = path[-1].replace(';', '')\r\n        \r\n        if accept_mode == 'files':\r\n            root.inputPaths = tuple(path)\r\n            root.process_input_selections()\r\n            root.update_inputPaths()\r\n        elif accept_mode in [FILE_1, FILE_2]:\r\n            if len(path) == 2:\r\n                root.select_audiofile(path[0])\r\n                root.select_audiofile(path[1], is_primary=False)\r\n                root.DualBatch_inputPaths = []\r\n                root.check_dual_paths()\r\n            elif len(path) == 1:\r\n                if accept_mode == FILE_1:\r\n                    root.select_audiofile(path[0])\r\n                else:\r\n                    root.select_audiofile(path[0], is_primary=False)\r\n\r\n        elif accept_mode in [FILE_1_LB, FILE_2_LB]:\r\n            return path\r\n    else:\r\n        return    \r\n\r\nclass ModelData():\r\n    def __init__(self, model_name: str, \r\n                 selected_process_method=ENSEMBLE_MODE, \r\n                 is_secondary_model=False, \r\n                 primary_model_primary_stem=None, \r\n                 is_primary_model_primary_stem_only=False, \r\n                 is_primary_model_secondary_stem_only=False, \r\n                 is_pre_proc_model=False,\r\n                 is_dry_check=False,\r\n                 is_change_def=False,\r\n                 is_get_hash_dir_only=False,\r\n                 is_vocal_split_model=False):\r\n\r\n        device_set = root.device_set_var.get()\r\n        self.DENOISER_MODEL = DENOISER_MODEL_PATH\r\n        self.DEVERBER_MODEL = DEVERBER_MODEL_PATH\r\n        self.is_deverb_vocals = root.is_deverb_vocals_var.get() if os.path.isfile(DEVERBER_MODEL_PATH) else False\r\n        self.deverb_vocal_opt = DEVERB_MAPPER[root.deverb_vocal_opt_var.get()]\r\n        self.is_denoise_model = True if root.denoise_option_var.get() == DENOISE_M and os.path.isfile(DENOISER_MODEL_PATH) else False\r\n        self.is_gpu_conversion = 0 if root.is_gpu_conversion_var.get() else -1\r\n        self.is_normalization = root.is_normalization_var.get()#\r\n        self.is_use_opencl = False#True if is_opencl_only else root.is_use_opencl_var.get()\r\n        self.is_primary_stem_only = root.is_primary_stem_only_var.get()\r\n        self.is_secondary_stem_only = root.is_secondary_stem_only_var.get()\r\n        self.is_denoise = True if not root.denoise_option_var.get() == DENOISE_NONE else False\r\n        self.is_mdx_c_seg_def = root.is_mdx_c_seg_def_var.get()#\r\n        self.mdx_batch_size = 1 if root.mdx_batch_size_var.get() == DEF_OPT else int(root.mdx_batch_size_var.get())\r\n        self.mdxnet_stem_select = root.mdxnet_stems_var.get() \r\n        self.overlap = float(root.overlap_var.get()) if not root.overlap_var.get() == DEFAULT else 0.25\r\n        self.overlap_mdx = float(root.overlap_mdx_var.get()) if not root.overlap_mdx_var.get() == DEFAULT else root.overlap_mdx_var.get()\r\n        self.overlap_mdx23 = int(float(root.overlap_mdx23_var.get()))\r\n        self.semitone_shift = float(root.semitone_shift_var.get())\r\n        self.is_pitch_change = False if self.semitone_shift == 0 else True\r\n        self.is_match_frequency_pitch = root.is_match_frequency_pitch_var.get()\r\n        self.is_mdx_ckpt = False\r\n        self.is_mdx_c = False\r\n        self.is_mdx_combine_stems = root.is_mdx23_combine_stems_var.get()#\r\n        self.mdx_c_configs = None\r\n        self.mdx_model_stems = []\r\n        self.mdx_dim_f_set = None\r\n        self.mdx_dim_t_set = None\r\n        self.mdx_stem_count = 1\r\n        self.compensate = None\r\n        self.mdx_n_fft_scale_set = None\r\n        self.wav_type_set = root.wav_type_set#\r\n        self.device_set = device_set.split(':')[-1].strip() if ':' in device_set else device_set\r\n        self.mp3_bit_set = root.mp3_bit_set_var.get()\r\n        self.save_format = root.save_format_var.get()\r\n        self.is_invert_spec = root.is_invert_spec_var.get()#\r\n        self.is_mixer_mode = False#\r\n        self.demucs_stems = root.demucs_stems_var.get()\r\n        self.is_demucs_combine_stems = root.is_demucs_combine_stems_var.get()\r\n        self.demucs_source_list = []\r\n        self.demucs_stem_count = 0\r\n        self.mixer_path = MDX_MIXER_PATH\r\n        self.model_name = model_name\r\n        self.process_method = selected_process_method\r\n        self.model_status = False if self.model_name == CHOOSE_MODEL or self.model_name == NO_MODEL else True\r\n        self.primary_stem = None\r\n        self.secondary_stem = None\r\n        self.primary_stem_native = None\r\n        self.is_ensemble_mode = False\r\n        self.ensemble_primary_stem = None\r\n        self.ensemble_secondary_stem = None\r\n        self.primary_model_primary_stem = primary_model_primary_stem\r\n        self.is_secondary_model = True if is_vocal_split_model else is_secondary_model\r\n        self.secondary_model = None\r\n        self.secondary_model_scale = None\r\n        self.demucs_4_stem_added_count = 0\r\n        self.is_demucs_4_stem_secondaries = False\r\n        self.is_4_stem_ensemble = False\r\n        self.pre_proc_model = None\r\n        self.pre_proc_model_activated = False\r\n        self.is_pre_proc_model = is_pre_proc_model\r\n        self.is_dry_check = is_dry_check\r\n        self.model_samplerate = 44100\r\n        self.model_capacity = 32, 128\r\n        self.is_vr_51_model = False\r\n        self.is_demucs_pre_proc_model_inst_mix = False\r\n        self.manual_download_Button = None\r\n        self.secondary_model_4_stem = []\r\n        self.secondary_model_4_stem_scale = []\r\n        self.secondary_model_4_stem_names = []\r\n        self.secondary_model_4_stem_model_names_list = []\r\n        self.all_models = []\r\n        self.secondary_model_other = None\r\n        self.secondary_model_scale_other = None\r\n        self.secondary_model_bass = None\r\n        self.secondary_model_scale_bass = None\r\n        self.secondary_model_drums = None\r\n        self.secondary_model_scale_drums = None\r\n        self.is_multi_stem_ensemble = False\r\n        self.is_karaoke = False\r\n        self.is_bv_model = False\r\n        self.bv_model_rebalance = 0\r\n        self.is_sec_bv_rebalance = False\r\n        self.is_change_def = is_change_def\r\n        self.model_hash_dir = None\r\n        self.is_get_hash_dir_only = is_get_hash_dir_only\r\n        self.is_secondary_model_activated = False\r\n        self.vocal_split_model = None\r\n        self.is_vocal_split_model = is_vocal_split_model\r\n        self.is_vocal_split_model_activated = False\r\n        self.is_save_inst_vocal_splitter = root.is_save_inst_set_vocal_splitter_var.get()\r\n        self.is_inst_only_voc_splitter = root.check_only_selection_stem(INST_STEM_ONLY)\r\n        self.is_save_vocal_only = root.check_only_selection_stem(IS_SAVE_VOC_ONLY)\r\n\r\n        if selected_process_method == ENSEMBLE_MODE:\r\n            self.process_method, _, self.model_name = model_name.partition(ENSEMBLE_PARTITION)\r\n            self.model_and_process_tag = model_name\r\n            self.ensemble_primary_stem, self.ensemble_secondary_stem = root.return_ensemble_stems()\r\n            \r\n            is_not_secondary_or_pre_proc = not is_secondary_model and not is_pre_proc_model\r\n            self.is_ensemble_mode = is_not_secondary_or_pre_proc\r\n            \r\n            if root.ensemble_main_stem_var.get() == FOUR_STEM_ENSEMBLE:\r\n                self.is_4_stem_ensemble = self.is_ensemble_mode\r\n            elif root.ensemble_main_stem_var.get() == MULTI_STEM_ENSEMBLE and root.chosen_process_method_var.get() == ENSEMBLE_MODE:\r\n                self.is_multi_stem_ensemble = True\r\n\r\n            is_not_vocal_stem = self.ensemble_primary_stem != VOCAL_STEM\r\n            self.pre_proc_model_activated = root.is_demucs_pre_proc_model_activate_var.get() if is_not_vocal_stem else False\r\n\r\n        if self.process_method == VR_ARCH_TYPE:\r\n            self.is_secondary_model_activated = root.vr_is_secondary_model_activate_var.get() if not is_secondary_model else False\r\n            self.aggression_setting = float(int(root.aggression_setting_var.get())/100)\r\n            self.is_tta = root.is_tta_var.get()\r\n            self.is_post_process = root.is_post_process_var.get()\r\n            self.window_size = int(root.window_size_var.get())\r\n            self.batch_size = 1 if root.batch_size_var.get() == DEF_OPT else int(root.batch_size_var.get())\r\n            self.crop_size = int(root.crop_size_var.get())\r\n            self.is_high_end_process = 'mirroring' if root.is_high_end_process_var.get() else 'None'\r\n            self.post_process_threshold = float(root.post_process_threshold_var.get())\r\n            self.model_capacity = 32, 128\r\n            self.model_path = os.path.join(VR_MODELS_DIR, f\"{self.model_name}.pth\")\r\n            self.get_model_hash()\r\n            if self.model_hash:\r\n                self.model_hash_dir = os.path.join(VR_HASH_DIR, f\"{self.model_hash}.json\")\r\n                if is_change_def:\r\n                    self.model_data = self.change_model_data()\r\n                else:\r\n                    self.model_data = self.get_model_data(VR_HASH_DIR, root.vr_hash_MAPPER) if not self.model_hash == WOOD_INST_MODEL_HASH else WOOD_INST_PARAMS\r\n                if self.model_data:\r\n                    vr_model_param = os.path.join(VR_PARAM_DIR, \"{}.json\".format(self.model_data[\"vr_model_param\"]))\r\n                    self.primary_stem = self.model_data[\"primary_stem\"]\r\n                    self.secondary_stem = secondary_stem(self.primary_stem)\r\n                    self.vr_model_param = ModelParameters(vr_model_param)\r\n                    self.model_samplerate = self.vr_model_param.param['sr']\r\n                    self.primary_stem_native = self.primary_stem\r\n                    if \"nout\" in self.model_data.keys() and \"nout_lstm\" in self.model_data.keys():\r\n                        self.model_capacity = self.model_data[\"nout\"], self.model_data[\"nout_lstm\"]\r\n                        self.is_vr_51_model = True\r\n                    self.check_if_karaokee_model()\r\n   \r\n                else:\r\n                    self.model_status = False\r\n                \r\n        if self.process_method == MDX_ARCH_TYPE:\r\n            self.is_secondary_model_activated = root.mdx_is_secondary_model_activate_var.get() if not is_secondary_model else False\r\n            self.margin = int(root.margin_var.get())\r\n            self.chunks = 0\r\n            self.mdx_segment_size = int(root.mdx_segment_size_var.get())\r\n            self.get_mdx_model_path()\r\n            self.get_model_hash()\r\n            if self.model_hash:\r\n                self.model_hash_dir = os.path.join(MDX_HASH_DIR, f\"{self.model_hash}.json\")\r\n                if is_change_def:\r\n                    self.model_data = self.change_model_data()\r\n                else:\r\n                    self.model_data = self.get_model_data(MDX_HASH_DIR, root.mdx_hash_MAPPER)\r\n                if self.model_data:\r\n                    \r\n                    if \"config_yaml\" in self.model_data:\r\n                        self.is_mdx_c = True\r\n                        config_path = os.path.join(MDX_C_CONFIG_PATH, self.model_data[\"config_yaml\"])\r\n                        if os.path.isfile(config_path):\r\n                            with open(config_path) as f:\r\n                                config = ConfigDict(yaml.load(f, Loader=yaml.FullLoader))\r\n\r\n                            self.mdx_c_configs = config\r\n                                \r\n                            if self.mdx_c_configs.training.target_instrument:\r\n                                # Use target_instrument as the primary stem and set 4-stem ensemble to False\r\n                                target = self.mdx_c_configs.training.target_instrument\r\n                                self.mdx_model_stems = [target]\r\n                                self.primary_stem = target\r\n                            else:\r\n                                # If no specific target_instrument, use all instruments in the training config\r\n                                self.mdx_model_stems = self.mdx_c_configs.training.instruments\r\n                                self.mdx_stem_count = len(self.mdx_model_stems)\r\n                                \r\n                                # Set primary stem based on stem count\r\n                                if self.mdx_stem_count == 2:\r\n                                    self.primary_stem = self.mdx_model_stems[0]\r\n                                else:\r\n                                    self.primary_stem = self.mdxnet_stem_select\r\n                                \r\n                                # Update mdxnet_stem_select based on ensemble mode\r\n                                if self.is_ensemble_mode:\r\n                                    self.mdxnet_stem_select = self.ensemble_primary_stem\r\n                        else:\r\n                            self.model_status = False\r\n                    else:\r\n                        self.compensate = self.model_data[\"compensate\"] if root.compensate_var.get() == AUTO_SELECT else float(root.compensate_var.get())\r\n                        self.mdx_dim_f_set = self.model_data[\"mdx_dim_f_set\"]\r\n                        self.mdx_dim_t_set = self.model_data[\"mdx_dim_t_set\"]\r\n                        self.mdx_n_fft_scale_set = self.model_data[\"mdx_n_fft_scale_set\"]\r\n                        self.primary_stem = self.model_data[\"primary_stem\"]\r\n                        self.primary_stem_native = self.model_data[\"primary_stem\"]\r\n                        self.check_if_karaokee_model()\r\n                        \r\n                    self.secondary_stem = secondary_stem(self.primary_stem)\r\n                else:\r\n                    self.model_status = False\r\n\r\n        if self.process_method == DEMUCS_ARCH_TYPE:\r\n            self.is_secondary_model_activated = root.demucs_is_secondary_model_activate_var.get() if not is_secondary_model else False\r\n            if not self.is_ensemble_mode:\r\n                self.pre_proc_model_activated = root.is_demucs_pre_proc_model_activate_var.get() if not root.demucs_stems_var.get() in [VOCAL_STEM, INST_STEM] else False\r\n            self.margin_demucs = int(root.margin_demucs_var.get())\r\n            self.chunks_demucs = 0\r\n            self.shifts = int(root.shifts_var.get())\r\n            self.is_split_mode = root.is_split_mode_var.get()\r\n            self.segment = root.segment_var.get()\r\n            self.is_chunk_demucs = root.is_chunk_demucs_var.get()\r\n            self.is_primary_stem_only = root.is_primary_stem_only_var.get() if self.is_ensemble_mode else root.is_primary_stem_only_Demucs_var.get() \r\n            self.is_secondary_stem_only = root.is_secondary_stem_only_var.get() if self.is_ensemble_mode else root.is_secondary_stem_only_Demucs_var.get()\r\n            self.get_demucs_model_data()\r\n            self.get_demucs_model_path()\r\n            \r\n        if self.model_status:\r\n            self.model_basename = os.path.splitext(os.path.basename(self.model_path))[0]\r\n        else:\r\n            self.model_basename = None\r\n            \r\n        self.pre_proc_model_activated = self.pre_proc_model_activated if not self.is_secondary_model else False\r\n        \r\n        self.is_primary_model_primary_stem_only = is_primary_model_primary_stem_only\r\n        self.is_primary_model_secondary_stem_only = is_primary_model_secondary_stem_only\r\n\r\n        is_secondary_activated_and_status = self.is_secondary_model_activated and self.model_status\r\n        is_demucs = self.process_method == DEMUCS_ARCH_TYPE\r\n        is_all_stems = root.demucs_stems_var.get() == ALL_STEMS\r\n        is_valid_ensemble = not self.is_ensemble_mode and is_all_stems and is_demucs\r\n        is_multi_stem_ensemble_demucs = self.is_multi_stem_ensemble and is_demucs\r\n\r\n        if is_secondary_activated_and_status:\r\n            if is_valid_ensemble or self.is_4_stem_ensemble or is_multi_stem_ensemble_demucs:\r\n                for key in DEMUCS_4_SOURCE_LIST:\r\n                    self.secondary_model_data(key)\r\n                    self.secondary_model_4_stem.append(self.secondary_model)\r\n                    self.secondary_model_4_stem_scale.append(self.secondary_model_scale)\r\n                    self.secondary_model_4_stem_names.append(key)\r\n                \r\n                self.demucs_4_stem_added_count = sum(i is not None for i in self.secondary_model_4_stem)\r\n                self.is_secondary_model_activated = any(i is not None for i in self.secondary_model_4_stem)\r\n                self.demucs_4_stem_added_count -= 1 if self.is_secondary_model_activated else 0\r\n                \r\n                if self.is_secondary_model_activated:\r\n                    self.secondary_model_4_stem_model_names_list = [i.model_basename if i is not None else None for i in self.secondary_model_4_stem]\r\n                    self.is_demucs_4_stem_secondaries = True\r\n            else:\r\n                primary_stem = self.ensemble_primary_stem if self.is_ensemble_mode and is_demucs else self.primary_stem\r\n                self.secondary_model_data(primary_stem)\r\n\r\n        if self.process_method == DEMUCS_ARCH_TYPE and not is_secondary_model:\r\n            if self.demucs_stem_count >= 3 and self.pre_proc_model_activated:\r\n                self.pre_proc_model = root.process_determine_demucs_pre_proc_model(self.primary_stem)\r\n                self.pre_proc_model_activated = True if self.pre_proc_model else False\r\n                self.is_demucs_pre_proc_model_inst_mix = root.is_demucs_pre_proc_model_inst_mix_var.get() if self.pre_proc_model else False\r\n\r\n        if self.is_vocal_split_model and self.model_status:\r\n            self.is_secondary_model_activated = False\r\n            if self.is_bv_model:\r\n                primary = BV_VOCAL_STEM if self.primary_stem_native == VOCAL_STEM else LEAD_VOCAL_STEM\r\n            else:\r\n                primary = LEAD_VOCAL_STEM if self.primary_stem_native == VOCAL_STEM else BV_VOCAL_STEM\r\n            self.primary_stem, self.secondary_stem = primary, secondary_stem(primary)\r\n            \r\n        self.vocal_splitter_model_data()\r\n            \r\n    def vocal_splitter_model_data(self):\r\n        if not self.is_secondary_model and self.model_status:\r\n            self.vocal_split_model = root.process_determine_vocal_split_model()\r\n            self.is_vocal_split_model_activated = True if self.vocal_split_model else False\r\n            \r\n            if self.vocal_split_model:\r\n                if self.vocal_split_model.bv_model_rebalance:\r\n                    self.is_sec_bv_rebalance = True\r\n            \r\n    def secondary_model_data(self, primary_stem):\r\n        secondary_model_data = root.process_determine_secondary_model(self.process_method, primary_stem, self.is_primary_stem_only, self.is_secondary_stem_only)\r\n        self.secondary_model = secondary_model_data[0]\r\n        self.secondary_model_scale = secondary_model_data[1]\r\n        self.is_secondary_model_activated = False if not self.secondary_model else True\r\n        if self.secondary_model:\r\n            self.is_secondary_model_activated = False if self.secondary_model.model_basename == self.model_basename else True\r\n            \r\n        #print(\"self.is_secondary_model_activated: \", self.is_secondary_model_activated)\r\n              \r\n    def check_if_karaokee_model(self):\r\n        if IS_KARAOKEE in self.model_data.keys():\r\n            self.is_karaoke = self.model_data[IS_KARAOKEE]\r\n        if IS_BV_MODEL in self.model_data.keys():\r\n            self.is_bv_model = self.model_data[IS_BV_MODEL]#\r\n        if IS_BV_MODEL_REBAL in self.model_data.keys() and self.is_bv_model:\r\n            self.bv_model_rebalance = self.model_data[IS_BV_MODEL_REBAL]#\r\n   \r\n    def get_mdx_model_path(self):\r\n        \r\n        if self.model_name.endswith(CKPT):\r\n            self.is_mdx_ckpt = True\r\n\r\n        ext = '' if self.is_mdx_ckpt else ONNX\r\n        \r\n        for file_name, chosen_mdx_model in root.mdx_name_select_MAPPER.items():\r\n            if self.model_name in chosen_mdx_model:\r\n                if file_name.endswith(CKPT):\r\n                    ext = ''\r\n                self.model_path = os.path.join(MDX_MODELS_DIR, f\"{file_name}{ext}\")\r\n                break\r\n        else:\r\n            self.model_path = os.path.join(MDX_MODELS_DIR, f\"{self.model_name}{ext}\")\r\n            \r\n        self.mixer_path = os.path.join(MDX_MODELS_DIR, f\"mixer_val.ckpt\")\r\n    \r\n    def get_demucs_model_path(self):\r\n        \r\n        demucs_newer = self.demucs_version in {DEMUCS_V3, DEMUCS_V4}\r\n        demucs_model_dir = DEMUCS_NEWER_REPO_DIR if demucs_newer else DEMUCS_MODELS_DIR\r\n        \r\n        for file_name, chosen_model in root.demucs_name_select_MAPPER.items():\r\n            if self.model_name == chosen_model:\r\n                self.model_path = os.path.join(demucs_model_dir, file_name)\r\n                break\r\n        else:\r\n            self.model_path = os.path.join(DEMUCS_NEWER_REPO_DIR, f'{self.model_name}.yaml')\r\n\r\n    def get_demucs_model_data(self):\r\n\r\n        self.demucs_version = DEMUCS_V4\r\n\r\n        for key, value in DEMUCS_VERSION_MAPPER.items():\r\n            if value in self.model_name:\r\n                self.demucs_version = key\r\n\r\n        if DEMUCS_UVR_MODEL in self.model_name:\r\n            self.demucs_source_list, self.demucs_source_map, self.demucs_stem_count = DEMUCS_2_SOURCE, DEMUCS_2_SOURCE_MAPPER, 2\r\n        else:\r\n            self.demucs_source_list, self.demucs_source_map, self.demucs_stem_count = DEMUCS_4_SOURCE, DEMUCS_4_SOURCE_MAPPER, 4\r\n\r\n        if not self.is_ensemble_mode:\r\n            self.primary_stem = PRIMARY_STEM if self.demucs_stems == ALL_STEMS else self.demucs_stems\r\n            self.secondary_stem = secondary_stem(self.primary_stem)\r\n            \r\n    def get_model_data(self, model_hash_dir, hash_mapper:dict):\r\n        model_settings_json = os.path.join(model_hash_dir, f\"{self.model_hash}.json\")\r\n\r\n        if os.path.isfile(model_settings_json):\r\n            with open(model_settings_json, 'r') as json_file:\r\n                return json.load(json_file)\r\n        else:\r\n            for hash, settings in hash_mapper.items():\r\n                if self.model_hash in hash:\r\n                    return settings\r\n\r\n            return self.get_model_data_from_popup()\r\n\r\n    def change_model_data(self):\r\n        if self.is_get_hash_dir_only:\r\n            return None\r\n        else:\r\n            return self.get_model_data_from_popup()\r\n\r\n    def get_model_data_from_popup(self):\r\n        if self.is_dry_check:\r\n            return None\r\n            \r\n        if not self.is_change_def:\r\n            confirm = messagebox.askyesno(\r\n                title=UNRECOGNIZED_MODEL[0],\r\n                message=f'\"{self.model_name}\"{UNRECOGNIZED_MODEL[1]}',\r\n                parent=root\r\n            )\r\n            if not confirm:\r\n                return None\r\n        \r\n        if self.process_method == VR_ARCH_TYPE:\r\n            root.pop_up_vr_param(self.model_hash)\r\n            return root.vr_model_params\r\n        elif self.process_method == MDX_ARCH_TYPE:\r\n            root.pop_up_mdx_model(self.model_hash, self.model_path)\r\n            return root.mdx_model_params\r\n\r\n    def get_model_hash(self):\r\n        self.model_hash = None\r\n        \r\n        if not os.path.isfile(self.model_path):\r\n            self.model_status = False\r\n            self.model_hash is None\r\n        else:\r\n            if model_hash_table:\r\n                for (key, value) in model_hash_table.items():\r\n                    if self.model_path == key:\r\n                        self.model_hash = value\r\n                        break\r\n                    \r\n            if not self.model_hash:\r\n                try:\r\n                    with open(self.model_path, 'rb') as f:\r\n                        f.seek(- 10000 * 1024, 2)\r\n                        self.model_hash = hashlib.md5(f.read()).hexdigest()\r\n                except:\r\n                    self.model_hash = hashlib.md5(open(self.model_path,'rb').read()).hexdigest()\r\n                    \r\n                table_entry = {self.model_path: self.model_hash}\r\n                model_hash_table.update(table_entry)\r\n                \r\n        #print(self.model_name,\" - \", self.model_hash)\r\n\r\nclass Ensembler():\r\n    def __init__(self, is_manual_ensemble=False):\r\n        self.is_save_all_outputs_ensemble = root.is_save_all_outputs_ensemble_var.get()\r\n        chosen_ensemble_name = '{}'.format(root.chosen_ensemble_var.get().replace(\" \", \"_\")) if not root.chosen_ensemble_var.get() == CHOOSE_ENSEMBLE_OPTION else 'Ensembled'\r\n        ensemble_algorithm = root.ensemble_type_var.get().partition(\"/\")\r\n        ensemble_main_stem_pair = root.ensemble_main_stem_var.get().partition(\"/\")\r\n        time_stamp = round(time.time())\r\n        self.audio_tool = MANUAL_ENSEMBLE\r\n        self.main_export_path = Path(root.export_path_var.get())\r\n        self.chosen_ensemble = f\"_{chosen_ensemble_name}\" if root.is_append_ensemble_name_var.get() else ''\r\n        ensemble_folder_name = self.main_export_path if self.is_save_all_outputs_ensemble else ENSEMBLE_TEMP_PATH\r\n        self.ensemble_folder_name = os.path.join(ensemble_folder_name, '{}_Outputs_{}'.format(chosen_ensemble_name, time_stamp))\r\n        self.is_testing_audio = f\"{time_stamp}_\" if root.is_testing_audio_var.get() else ''\r\n        self.primary_algorithm = ensemble_algorithm[0]\r\n        self.secondary_algorithm = ensemble_algorithm[2]\r\n        self.ensemble_primary_stem = ensemble_main_stem_pair[0]\r\n        self.ensemble_secondary_stem = ensemble_main_stem_pair[2]\r\n        self.is_normalization = root.is_normalization_var.get()\r\n        self.is_wav_ensemble = root.is_wav_ensemble_var.get()\r\n        self.wav_type_set = root.wav_type_set\r\n        self.mp3_bit_set = root.mp3_bit_set_var.get()\r\n        self.save_format = root.save_format_var.get()\r\n        if not is_manual_ensemble:\r\n            os.mkdir(self.ensemble_folder_name)\r\n\r\n    def ensemble_outputs(self, audio_file_base, export_path, stem, is_4_stem=False, is_inst_mix=False):\r\n        \"\"\"Processes the given outputs and ensembles them with the chosen algorithm\"\"\"\r\n        \r\n        if is_4_stem:\r\n            algorithm = root.ensemble_type_var.get()\r\n            stem_tag = stem\r\n        else:\r\n            if is_inst_mix:\r\n                algorithm = self.secondary_algorithm\r\n                stem_tag = f\"{self.ensemble_secondary_stem} {INST_STEM}\"\r\n            else:\r\n                algorithm = self.primary_algorithm if stem == PRIMARY_STEM else self.secondary_algorithm\r\n                stem_tag = self.ensemble_primary_stem if stem == PRIMARY_STEM else self.ensemble_secondary_stem\r\n\r\n        stem_outputs = self.get_files_to_ensemble(folder=export_path, prefix=audio_file_base, suffix=f\"_({stem_tag}).wav\")\r\n        audio_file_output = f\"{self.is_testing_audio}{audio_file_base}{self.chosen_ensemble}_({stem_tag})\"\r\n        stem_save_path = os.path.join('{}'.format(self.main_export_path),'{}.wav'.format(audio_file_output))\r\n        \r\n        #print(\"get_files_to_ensemble: \", stem_outputs)\r\n        \r\n        if len(stem_outputs) > 1:\r\n            spec_utils.ensemble_inputs(stem_outputs, algorithm, self.is_normalization, self.wav_type_set, stem_save_path, is_wave=self.is_wav_ensemble)\r\n            save_format(stem_save_path, self.save_format, self.mp3_bit_set)\r\n        \r\n        if self.is_save_all_outputs_ensemble:\r\n            for i in stem_outputs:\r\n                save_format(i, self.save_format, self.mp3_bit_set)\r\n        else:\r\n            for i in stem_outputs:\r\n                try:\r\n                    os.remove(i)\r\n                except Exception as e:\r\n                    print(e)\r\n\r\n    def ensemble_manual(self, audio_inputs, audio_file_base, is_bulk=False):\r\n        \"\"\"Processes the given outputs and ensembles them with the chosen algorithm\"\"\"\r\n        \r\n        is_mv_sep = True\r\n        \r\n        if is_bulk:\r\n            number_list = list(set([os.path.basename(i).split(\"_\")[0] for i in audio_inputs]))\r\n            for n in number_list:\r\n                current_list = [i for i in audio_inputs if os.path.basename(i).startswith(n)]\r\n                audio_file_base = os.path.basename(current_list[0]).split('.wav')[0]\r\n                stem_testing = \"instrum\" if \"Instrumental\" in audio_file_base else \"vocals\"\r\n                if is_mv_sep:\r\n                    audio_file_base = audio_file_base.split(\"_\")\r\n                    audio_file_base = f\"{audio_file_base[1]}_{audio_file_base[2]}_{stem_testing}\"\r\n                self.ensemble_manual_process(current_list, audio_file_base, is_bulk)\r\n        else:\r\n            self.ensemble_manual_process(audio_inputs, audio_file_base, is_bulk)\r\n            \r\n    def ensemble_manual_process(self, audio_inputs, audio_file_base, is_bulk):\r\n        \r\n        algorithm = root.choose_algorithm_var.get()\r\n        algorithm_text = \"\" if is_bulk else f\"_({root.choose_algorithm_var.get()})\"\r\n        stem_save_path = os.path.join('{}'.format(self.main_export_path),'{}{}{}.wav'.format(self.is_testing_audio, audio_file_base, algorithm_text))\r\n        spec_utils.ensemble_inputs(audio_inputs, algorithm, self.is_normalization, self.wav_type_set, stem_save_path, is_wave=self.is_wav_ensemble)\r\n        save_format(stem_save_path, self.save_format, self.mp3_bit_set)\r\n\r\n    def get_files_to_ensemble(self, folder=\"\", prefix=\"\", suffix=\"\"):\r\n        \"\"\"Grab all the files to be ensembled\"\"\"\r\n        \r\n        return [os.path.join(folder, i) for i in os.listdir(folder) if i.startswith(prefix) and i.endswith(suffix)]\r\n\r\n    def combine_audio(self, audio_inputs, audio_file_base):\r\n        save_format_ = lambda save_path:save_format(save_path, root.save_format_var.get(), root.mp3_bit_set_var.get())\r\n        spec_utils.combine_audio(audio_inputs, \r\n                                 os.path.join(self.main_export_path, f\"{self.is_testing_audio}{audio_file_base}\"), \r\n                                 self.wav_type_set,\r\n                                 save_format=save_format_)\r\n\r\nclass AudioTools():\r\n    def __init__(self, audio_tool):\r\n        time_stamp = round(time.time())\r\n        self.audio_tool = audio_tool\r\n        self.main_export_path = Path(root.export_path_var.get())\r\n        self.wav_type_set = root.wav_type_set\r\n        self.is_normalization = root.is_normalization_var.get()\r\n        self.is_testing_audio = f\"{time_stamp}_\" if root.is_testing_audio_var.get() else ''\r\n        self.save_format = lambda save_path:save_format(save_path, root.save_format_var.get(), root.mp3_bit_set_var.get())\r\n        self.align_window = TIME_WINDOW_MAPPER[root.time_window_var.get()]\r\n        self.align_intro_val = INTRO_MAPPER[root.intro_analysis_var.get()]\r\n        self.db_analysis_val = VOLUME_MAPPER[root.db_analysis_var.get()]\r\n        self.is_save_align = root.is_save_align_var.get()#\r\n        self.is_match_silence = root.is_match_silence_var.get()#\r\n        self.is_spec_match = root.is_spec_match_var.get()\r\n        \r\n        self.phase_option = root.phase_option_var.get()#\r\n        self.phase_shifts = PHASE_SHIFTS_OPT[root.phase_shifts_var.get()]\r\n        \r\n    def align_inputs(self, audio_inputs, audio_file_base, audio_file_2_base, command_Text, set_progress_bar):\r\n        audio_file_base = f\"{self.is_testing_audio}{audio_file_base}\"\r\n        audio_file_2_base = f\"{self.is_testing_audio}{audio_file_2_base}\"\r\n        \r\n        aligned_path = os.path.join('{}'.format(self.main_export_path),'{}_(Aligned).wav'.format(audio_file_2_base))\r\n        inverted_path = os.path.join('{}'.format(self.main_export_path),'{}_(Inverted).wav'.format(audio_file_base))\r\n\r\n        spec_utils.align_audio(audio_inputs[0], \r\n                               audio_inputs[1], \r\n                               aligned_path, \r\n                               inverted_path, \r\n                               self.wav_type_set, \r\n                               self.is_save_align, \r\n                               command_Text, \r\n                               self.save_format,\r\n                               align_window=self.align_window,\r\n                               align_intro_val=self.align_intro_val,\r\n                               db_analysis=self.db_analysis_val,\r\n                               set_progress_bar=set_progress_bar, \r\n                               phase_option=self.phase_option,\r\n                               phase_shifts=self.phase_shifts,\r\n                               is_match_silence=self.is_match_silence,\r\n                               is_spec_match=self.is_spec_match)\r\n        \r\n    def match_inputs(self, audio_inputs, audio_file_base, command_Text):\r\n        \r\n        target = audio_inputs[0]\r\n        reference = audio_inputs[1]\r\n        \r\n        command_Text(f\"Processing... \")\r\n        \r\n        save_path = os.path.join('{}'.format(self.main_export_path),'{}_(Matched).wav'.format(f\"{self.is_testing_audio}{audio_file_base}\"))\r\n        \r\n        match.process(\r\n            target=target,\r\n            reference=reference,\r\n            results=[match.save_audiofile(save_path, wav_set=self.wav_type_set),\r\n            ],\r\n        )\r\n        \r\n        self.save_format(save_path)\r\n        \r\n    def combine_audio(self, audio_inputs, audio_file_base):\r\n        spec_utils.combine_audio(audio_inputs, \r\n                                 os.path.join(self.main_export_path, f\"{self.is_testing_audio}{audio_file_base}\"), \r\n                                 self.wav_type_set,\r\n                                 save_format=self.save_format)\r\n        \r\n    def pitch_or_time_shift(self, audio_file, audio_file_base):\r\n        is_time_correction = True\r\n        rate = float(root.time_stretch_rate_var.get()) if self.audio_tool == TIME_STRETCH else float(root.pitch_rate_var.get())\r\n        is_pitch = False if self.audio_tool == TIME_STRETCH else True\r\n        if is_pitch:\r\n            is_time_correction = True if root.is_time_correction_var.get() else False\r\n        file_text = TIME_TEXT if self.audio_tool == TIME_STRETCH else PITCH_TEXT\r\n        save_path = os.path.join(self.main_export_path, f\"{self.is_testing_audio}{audio_file_base}{file_text}.wav\")\r\n        spec_utils.augment_audio(save_path, audio_file, rate, self.is_normalization, self.wav_type_set, self.save_format, is_pitch=is_pitch, is_time_correction=is_time_correction)\r\n   \r\nclass ToolTip(object):\r\n\r\n    def __init__(self, widget):\r\n        self.widget = widget\r\n        self.tooltip = None\r\n\r\n    def showtip(self, text, is_message_box=False, is_success_message=None):#\r\n        self.hidetip()\r\n        def create_label_config():\r\n            \r\n            font_size = FONT_SIZE_3 if is_message_box else FONT_SIZE_2\r\n            \r\n            \"\"\"Helper function to generate label configurations.\"\"\"\r\n            common_config = {\r\n                \"text\": text,\r\n                \"relief\": tk.SOLID,\r\n                \"borderwidth\": 1,\r\n                \"font\": (MAIN_FONT_NAME, f\"{font_size}\", \"normal\")\r\n            }\r\n            if is_message_box:\r\n                background_color = \"#03692d\" if is_success_message else \"#8B0000\"\r\n                return {**common_config, \"background\": background_color, \"foreground\": \"#ffffff\"}\r\n            else:\r\n                return {**common_config, \"background\": \"#1C1C1C\", \"foreground\": \"#ffffff\", \r\n                        \"highlightcolor\": \"#898b8e\", \"justify\": tk.LEFT}\r\n\r\n        if is_message_box:\r\n            temp_tooltip = tk.Toplevel(self.widget)\r\n            temp_tooltip.wm_overrideredirect(True)\r\n            temp_tooltip.withdraw()\r\n            label = tk.Label(temp_tooltip, **create_label_config())\r\n            label.pack()\r\n            temp_tooltip.update() if is_windows else temp_tooltip.update_idletasks()\r\n\r\n            x = self.widget.winfo_rootx() + (self.widget.winfo_width() // 2) - (temp_tooltip.winfo_reqwidth() // 2)\r\n            y = self.widget.winfo_rooty() + self.widget.winfo_height()\r\n\r\n            temp_tooltip.destroy()\r\n        else:\r\n            x, y, _, _ = self.widget.bbox(\"insert\")\r\n            x += self.widget.winfo_rootx() + 25\r\n            y += self.widget.winfo_rooty() + 25\r\n\r\n        # Create the actual tooltip\r\n        self.tooltip = tk.Toplevel(self.widget)\r\n        self.tooltip.wm_overrideredirect(True)  \r\n        self.tooltip.wm_geometry(f\"+{x}+{y}\")\r\n\r\n        label_config = create_label_config()\r\n        if not is_message_box:\r\n            label_config['padx'] = 10  # horizontal padding\r\n            label_config['pady'] = 10  # vertical padding\r\n            label_config[\"wraplength\"] = 750\r\n        label = tk.Label(self.tooltip, **label_config)\r\n\r\n        label.pack()\r\n\r\n        if is_message_box:\r\n            self.tooltip.after(3000 if type(is_success_message) is bool else 2000, self.hidetip)\r\n\r\n    def hidetip(self):\r\n        if self.tooltip:\r\n            self.tooltip.destroy()\r\n            self.tooltip = None\r\n\r\nclass ListboxBatchFrame(tk.Frame):\r\n    def __init__(self, master=None, name=\"Listbox\", command=None, image_sel=None, img_mapper=None):\r\n        super().__init__(master)\r\n        self.master = master\r\n\r\n        self.path_list = []  # A list to keep track of the paths\r\n        self.basename_to_path = {}  # A dict to map basenames to paths\r\n\r\n        self.label = tk.Label(self, text=name, font=(MAIN_FONT_NAME, f\"{FONT_SIZE_5}\"), foreground=FG_COLOR)\r\n        self.label.pack(pady=(10, 8))  # add padding between label and listbox\r\n\r\n        self.input_button = ttk.Button(self, text=SELECT_INPUTS, command=self.select_input)  # create button for selecting files\r\n        self.input_button.pack(pady=(0, 10))  # add padding between button and next widget\r\n\r\n        self.listbox = tk.Listbox(self, activestyle='dotbox', font=(MAIN_FONT_NAME, f\"{FONT_SIZE_4}\"), foreground='#cdd3ce', background='#101414', exportselection=0, width=70, height=15)\r\n        self.listbox.pack(fill=\"both\", expand=True)\r\n\r\n        self.button_frame = tk.Frame(self)\r\n        self.button_frame.pack()\r\n\r\n        self.up_button = ttk.Button(self.button_frame, image=img_mapper[\"up\"], command=self.move_up)\r\n        self.up_button.grid(row=0, column=0)\r\n\r\n        self.down_button = ttk.Button(self.button_frame, image=img_mapper[\"down\"], command=self.move_down)\r\n        self.down_button.grid(row=0, column=1)\r\n        \r\n        if command and image_sel:\r\n            self.move_button = ttk.Button(self.button_frame, image=image_sel, command=command)\r\n            self.move_button.grid(row=0, column=2)\r\n\r\n        self.duplicate_button = ttk.Button(self.button_frame, image=img_mapper[\"copy\"], command=self.duplicate_selected)\r\n        self.duplicate_button.grid(row=0, column=3) \r\n\r\n        self.delete_button = ttk.Button(self.button_frame, image=img_mapper[\"clear\"], command=self.delete_selected)\r\n        self.delete_button.grid(row=0, column=4)\r\n\r\n    def delete_selected(self):\r\n        selected = self.listbox.curselection()\r\n        if selected:\r\n            basename = self.listbox.get(selected[0]).split(\": \", 1)[1]  # We get the actual basename here, without the index\r\n            path_to_delete = self.basename_to_path[basename]  # store the path to delete\r\n            del self.basename_to_path[basename]  # delete from the dict\r\n            self.path_list.remove(path_to_delete)  # delete from the list\r\n            self.listbox.delete(selected)\r\n            self.update_displayed_index()\r\n\r\n    def select_input(self, inputs=None):\r\n        files = inputs if inputs else root.show_file_dialog(dialoge_type=MULTIPLE_FILE)\r\n        for file in files:\r\n            if file not in self.path_list:  # only add file if it's not already in the list\r\n                basename = os.path.basename(file)\r\n                self.listbox.insert(tk.END, basename)  # insert basename to the listbox\r\n                self.path_list.append(file)  # append the file path to the list\r\n                self.basename_to_path[basename] = file  # add to the dict\r\n        self.update_displayed_index(is_acc_dupe=False)\r\n\r\n    def duplicate_selected(self):\r\n        selected = self.listbox.curselection()\r\n        if selected:\r\n            basename = self.listbox.get(selected[0]).split(\": \", 1)[1]  # We get the actual basename here, without the index\r\n            path_to_duplicate = self.basename_to_path[basename]  # store the path to duplicate\r\n            self.path_list.append(path_to_duplicate)  # add the duplicated path to the list\r\n            self.update_displayed_index()  # redraw listbox with the duplicated item\r\n\r\n    def update_displayed_index(self, inputs=None, is_acc_dupe=True):\r\n        self.basename_to_path = {}  # reset the dictionary\r\n        \r\n        if inputs:\r\n            self.path_list = inputs\r\n            \r\n        basename_count = Counter(self.path_list)  # count occurrences of each path\r\n\r\n        for i in range(len(self.path_list)):\r\n            basename = os.path.basename(self.path_list[i])\r\n\r\n            # If the path is not unique or we are adding a duplicate\r\n            if basename_count[self.path_list[i]] > 1 and is_acc_dupe:\r\n                j = 1\r\n                new_basename = f\"{basename} ({j})\"\r\n                while new_basename in self.basename_to_path:\r\n                    j += 1\r\n                    new_basename = f\"{basename} ({j})\"\r\n                basename = new_basename\r\n\r\n            self.basename_to_path[basename] = self.path_list[i]  # update the dict with the new order\r\n            self.listbox.delete(i)\r\n            self.listbox.insert(i, f\"{i + 1}: {basename}\")\r\n\r\n    def move_up(self):\r\n        selected = self.listbox.curselection()\r\n        if selected and selected[0] > 0:\r\n            # Swap items in path_list\r\n            self.path_list[selected[0] - 1], self.path_list[selected[0]] = self.path_list[selected[0]], self.path_list[selected[0] - 1]\r\n            # Redraw listbox\r\n            self.update_displayed_index()\r\n            # Reselect item\r\n            self.listbox.select_set(selected[0] - 1)\r\n\r\n    def move_down(self):\r\n        selected = self.listbox.curselection()\r\n        if selected and selected[0] < self.listbox.size() - 1:\r\n            # Swap items in path_list\r\n            self.path_list[selected[0] + 1], self.path_list[selected[0]] = self.path_list[selected[0]], self.path_list[selected[0] + 1]\r\n            # Redraw listbox\r\n            self.update_displayed_index()\r\n            # Reselect item\r\n            self.listbox.select_set(selected[0] + 1)\r\n            \r\n    def get_selected_path(self):\r\n        \"\"\"Returns the path associated with the selected entry.\"\"\"\r\n        selected = self.listbox.curselection()\r\n        if selected:\r\n            basename = self.listbox.get(selected[0]).split(\": \", 1)[1]  # We get the actual basename here, without the index\r\n            path = self.basename_to_path[basename]  # get the path associated with the basename\r\n            return path\r\n        return None\r\n        \r\nclass ComboBoxEditableMenu(ttk.Combobox):\r\n    def __init__(self, master=None, pattern=None, default=None, width=None, is_stay_disabled=False, **kw):\r\n        \r\n        if 'values' in kw:\r\n            kw['values'] = tuple(kw['values']) + (OPT_SEPARATOR, USER_INPUT)\r\n        else:\r\n            kw['values'] = (USER_INPUT)\r\n        \r\n        super().__init__(master, **kw)\r\n\r\n        self.textvariable = kw.get('textvariable', tk.StringVar())\r\n        self.pattern = pattern\r\n        self.test = 1\r\n        self.tooltip = ToolTip(self)\r\n        self.is_user_input_var = tk.BooleanVar(value=False)\r\n        self.is_stay_disabled = is_stay_disabled\r\n        \r\n        if isinstance(default, (str, int)):\r\n            self.default = default\r\n        else:\r\n            self.default = default[0]\r\n        \r\n        self.menu_combobox_configure()\r\n        self.var_validation(is_start_up=True)\r\n\r\n        if width:\r\n            self.configure(width=width)\r\n        \r\n    def menu_combobox_configure(self):\r\n        self.bind('<<ComboboxSelected>>', self.check_input)\r\n        self.bind('<Button-1>', lambda e:self.focus())\r\n        self.bind('<FocusIn>', self.focusin)\r\n        self.bind('<FocusOut>', lambda e: self.var_validation(is_focus_only=True))\r\n\r\n        if is_macos:\r\n            self.bind('<Enter>', lambda e:self.button_released())\r\n\r\n        if not self.is_stay_disabled:\r\n            self.configure(state=READ_ONLY)\r\n        \r\n    def check_input(self, event=None):\r\n        if self.textvariable.get() == USER_INPUT:\r\n            self.textvariable.set('')\r\n            self.configure(state=tk.NORMAL)\r\n            self.focus()\r\n            self.selection_range(0, 0)\r\n        else:\r\n            self.var_validation()\r\n   \r\n    def var_validation(self, is_focus_only=False, is_start_up=False):\r\n        if is_focus_only and not self.is_stay_disabled:\r\n            self.configure(state=READ_ONLY)\r\n\r\n        if re.fullmatch(self.pattern, self.textvariable.get()) is None:\r\n            if not is_start_up and not self.textvariable.get() in (OPT_SEPARATOR, USER_INPUT):\r\n                self.tooltip.showtip(INVALID_INPUT_E, True)\r\n    \r\n            self.textvariable.set(self.default)\r\n            \r\n    def button_released(self, e=None):\r\n        self.event_generate('<Button-3>')\r\n        self.event_generate('<ButtonRelease-3>')\r\n\r\n    def focusin(self, e):\r\n        self.selection_clear()\r\n        if is_macos:\r\n            self.event_generate('<Leave>')\r\n\r\nclass ComboBoxMenu(ttk.Combobox):\r\n    def __init__(self, master=None, dropdown_name=None, offset=185, is_download_menu=False, command=None, width=None, **kw):\r\n        super().__init__(master, **kw)\r\n        \r\n        # Configure the combobox using the menu_combobox_configure method\r\n        self.menu_combobox_configure(is_download_menu, width=width)\r\n\r\n        # Check if both dropdown_name and 'values' are provided to update dropdown size\r\n        if dropdown_name and 'values' in kw:\r\n            self.update_dropdown_size(kw['values'], dropdown_name, offset)\r\n            \r\n        if command:\r\n            self.command(command)\r\n\r\n    def menu_combobox_configure(self, is_download_menu=False, command=None, width=None):\r\n        self.bind('<FocusIn>', self.focusin)\r\n        self.bind('<MouseWheel>', lambda e:\"break\")\r\n        \r\n        if is_macos:\r\n            self.bind('<Enter>', lambda e:self.button_released())\r\n        \r\n        if not is_download_menu:\r\n            self.configure(state=READ_ONLY)\r\n            \r\n        if command:\r\n            self.command(command)\r\n            \r\n        if width:\r\n            self.configure(width=width)\r\n\r\n    def button_released(self, e=None):\r\n        self.event_generate('<Button-3>')\r\n        self.event_generate('<ButtonRelease-3>')\r\n\r\n    def command(self, command):\r\n        if not self.bind('<<ComboboxSelected>>'):\r\n            self.bind('<<ComboboxSelected>>', command)\r\n\r\n    def focusin(self, e):\r\n        self.selection_clear()\r\n        if is_macos:\r\n            self.event_generate('<Leave>')\r\n\r\n    def update_dropdown_size(self, option_list, dropdown_name, offset=185, command=None):\r\n        dropdown_style = f\"{dropdown_name}.TCombobox\"\r\n        if option_list:\r\n            max_string = max(option_list, key=len)\r\n            font = Font(font=self.cget('font'))\r\n            width_in_pixels = font.measure(max_string) - offset\r\n            width_in_pixels = 0 if width_in_pixels < 0 else width_in_pixels\r\n        else:\r\n            width_in_pixels = 0\r\n        \r\n        style = ttk.Style(self)\r\n        style.configure(dropdown_style, padding=(0, 0, 0, 0), postoffset=(0, 0, width_in_pixels, 0))\r\n        self.configure(style=dropdown_style)\r\n                \r\n        if command:\r\n            self.command(command)\r\n\r\nclass ThreadSafeConsole(tk.Text):\r\n    \"\"\"\r\n    Text Widget which is thread safe for tkinter\r\n    \"\"\"\r\n    \r\n    def __init__(self, master, **options):\r\n        tk.Text.__init__(self, master, **options)\r\n        self.queue = queue.Queue()\r\n        self.update_me()\r\n\r\n    def write(self, line):\r\n        self.queue.put(line)\r\n\r\n    def clear(self):\r\n        self.queue.put(None)\r\n\r\n    def update_me(self):\r\n        self.configure(state=tk.NORMAL)\r\n        try:\r\n            while 1:\r\n                line = self.queue.get_nowait()\r\n                if line is None:\r\n                    self.delete(1.0, tk.END)\r\n                else:\r\n                    self.insert(tk.END, str(line))\r\n                self.see(tk.END)\r\n                self.update_idletasks()\r\n        except queue.Empty:\r\n            pass\r\n        self.configure(state=tk.DISABLED)\r\n        self.after(100, self.update_me)\r\n        \r\n    def copy_text(self):\r\n        hightlighted_text = self.selection_get()\r\n        self.clipboard_clear()\r\n        self.clipboard_append(hightlighted_text)\r\n        \r\n    def select_all_text(self):\r\n        self.tag_add('sel', '1.0', 'end')\r\n\r\nclass MainWindow(TkinterDnD.Tk if is_dnd_compatible else tk.Tk):\r\n    # --Constants--\r\n    # Layout\r\n\r\n    IMAGE_HEIGHT = IMAGE_HEIGHT\r\n    FILEPATHS_HEIGHT = FILEPATHS_HEIGHT\r\n    OPTIONS_HEIGHT = OPTIONS_HEIGHT\r\n    CONVERSIONBUTTON_HEIGHT = CONVERSIONBUTTON_HEIGHT\r\n    COMMAND_HEIGHT = COMMAND_HEIGHT\r\n    PROGRESS_HEIGHT = PROGRESS_HEIGHT\r\n    PADDING = PADDING\r\n    WIDTH = WIDTH\r\n    COL1_ROWS = 11\r\n    COL2_ROWS = 11\r\n    \r\n    def __init__(self):\r\n        #Run the __init__ method on the tk.Tk class\r\n        super().__init__()\r\n        \r\n        self.set_app_font()\r\n\r\n        style = ttk.Style(self)\r\n        style.map('TCombobox', selectbackground=[('focus', '#0c0c0c')], selectforeground=[('focus', 'white')])\r\n        style.configure('TCombobox', selectbackground='#0c0c0c')\r\n        #style.configure('TCheckbutton', indicatorsize=30)\r\n        \r\n        # Calculate window height\r\n        height = self.IMAGE_HEIGHT + self.FILEPATHS_HEIGHT + self.OPTIONS_HEIGHT\r\n        height += self.CONVERSIONBUTTON_HEIGHT + self.COMMAND_HEIGHT + self.PROGRESS_HEIGHT\r\n        height += self.PADDING * 5  # Padding\r\n        width = self.WIDTH\r\n        self.main_window_width = width\r\n        self.main_window_height = height\r\n\r\n        # --Window Settings--\r\n        self.withdraw()\r\n        self.title('Ultimate Vocal Remover')\r\n        # Set Geometry and Center Window\r\n        self.geometry('{width}x{height}+{xpad}+{ypad}'.format(\r\n            width=self.main_window_width,\r\n            height=height,\r\n            xpad=int(self.winfo_screenwidth()/2 - width/2),\r\n            ypad=int(self.winfo_screenheight()/2 - height/2 - 30)))\r\n \r\n        self.iconbitmap(ICON_IMG_PATH) if is_windows else self.tk.call('wm', 'iconphoto', self._w, tk.PhotoImage(file=MAIN_ICON_IMG_PATH))\r\n        self.protocol(\"WM_DELETE_WINDOW\", self.save_values)\r\n        self.resizable(False, False)\r\n        \r\n        self.msg_queue = queue.Queue()\r\n        # Create a custom style that inherits from the original Combobox style.\r\n        \r\n        if not is_windows:\r\n            self.update()\r\n\r\n        #Load Images\r\n        img = ImagePath(BASE_PATH)\r\n        self.logo_img = img.open_image(path=img.banner_path, size=(width, height))\r\n        self.efile_img = img.efile_img\r\n        self.stop_img = img.stop_img\r\n        self.help_img = img.help_img\r\n        self.download_img = img.download_img\r\n        self.donate_img = img.donate_img\r\n        self.key_img = img.key_img\r\n        self.credits_img = img.credits_img\r\n        \r\n        self.right_img = img.right_img\r\n        self.left_img = img.left_img\r\n        self.img_mapper = {\r\n            \"down\":img.down_img,\r\n            \"up\":img.up_img,\r\n            \"copy\":img.copy_img,\r\n            \"clear\":img.clear_img\r\n        }\r\n\r\n        #Placeholders\r\n        self.error_log_var = tk.StringVar(value='')\r\n        self.vr_secondary_model_names = []\r\n        self.mdx_secondary_model_names = []\r\n        self.demucs_secondary_model_names = []\r\n        self.vr_primary_model_names = []\r\n        self.mdx_primary_model_names = []\r\n        self.demucs_primary_model_names = []\r\n        \r\n        self.vr_cache_source_mapper = {}\r\n        self.mdx_cache_source_mapper = {}\r\n        self.demucs_cache_source_mapper = {}\r\n        \r\n        # -Tkinter Value Holders-\r\n        \r\n        try:\r\n            self.load_saved_vars(data)\r\n        except Exception as e:\r\n            self.error_log_var.set(error_text('Loading Saved Variables', e))\r\n            self.load_saved_vars(DEFAULT_DATA)\r\n            \r\n        self.cached_sources_clear()\r\n        \r\n        self.method_mapper = {\r\n            VR_ARCH_PM: self.vr_model_var,\r\n            MDX_ARCH_TYPE: self.mdx_net_model_var,\r\n            DEMUCS_ARCH_TYPE: self.demucs_model_var}\r\n\r\n        self.vr_secondary_model_vars = {'voc_inst_secondary_model': self.vr_voc_inst_secondary_model_var,\r\n                                        'other_secondary_model': self.vr_other_secondary_model_var,\r\n                                        'bass_secondary_model': self.vr_bass_secondary_model_var,\r\n                                        'drums_secondary_model': self.vr_drums_secondary_model_var,\r\n                                        'is_secondary_model_activate': self.vr_is_secondary_model_activate_var,\r\n                                        'voc_inst_secondary_model_scale': self.vr_voc_inst_secondary_model_scale_var,\r\n                                        'other_secondary_model_scale': self.vr_other_secondary_model_scale_var,\r\n                                        'bass_secondary_model_scale': self.vr_bass_secondary_model_scale_var,\r\n                                        'drums_secondary_model_scale': self.vr_drums_secondary_model_scale_var}\r\n        \r\n        self.demucs_secondary_model_vars = {'voc_inst_secondary_model': self.demucs_voc_inst_secondary_model_var,\r\n                                        'other_secondary_model': self.demucs_other_secondary_model_var,\r\n                                        'bass_secondary_model': self.demucs_bass_secondary_model_var,\r\n                                        'drums_secondary_model': self.demucs_drums_secondary_model_var,\r\n                                        'is_secondary_model_activate': self.demucs_is_secondary_model_activate_var,\r\n                                        'voc_inst_secondary_model_scale': self.demucs_voc_inst_secondary_model_scale_var,\r\n                                        'other_secondary_model_scale': self.demucs_other_secondary_model_scale_var,\r\n                                        'bass_secondary_model_scale': self.demucs_bass_secondary_model_scale_var,\r\n                                        'drums_secondary_model_scale': self.demucs_drums_secondary_model_scale_var}\r\n        \r\n        self.mdx_secondary_model_vars = {'voc_inst_secondary_model': self.mdx_voc_inst_secondary_model_var,\r\n                                        'other_secondary_model': self.mdx_other_secondary_model_var,\r\n                                        'bass_secondary_model': self.mdx_bass_secondary_model_var,\r\n                                        'drums_secondary_model': self.mdx_drums_secondary_model_var,\r\n                                        'is_secondary_model_activate': self.mdx_is_secondary_model_activate_var,\r\n                                        'voc_inst_secondary_model_scale': self.mdx_voc_inst_secondary_model_scale_var,\r\n                                        'other_secondary_model_scale': self.mdx_other_secondary_model_scale_var,\r\n                                        'bass_secondary_model_scale': self.mdx_bass_secondary_model_scale_var,\r\n                                        'drums_secondary_model_scale': self.mdx_drums_secondary_model_scale_var}\r\n\r\n        #Main Application Vars\r\n        self.progress_bar_main_var = tk.IntVar(value=0)\r\n        self.inputPathsEntry_var = tk.StringVar(value='')\r\n        self.conversion_Button_Text_var = tk.StringVar(value=START_PROCESSING)\r\n        self.chosen_ensemble_var = tk.StringVar(value=CHOOSE_ENSEMBLE_OPTION)\r\n        self.ensemble_main_stem_var = tk.StringVar(value=CHOOSE_STEM_PAIR)\r\n        self.ensemble_type_var = tk.StringVar(value=MAX_MIN)\r\n        self.save_current_settings_var = tk.StringVar(value=SELECT_SAVED_SET)\r\n        self.demucs_stems_var = tk.StringVar(value=ALL_STEMS)\r\n        self.mdxnet_stems_var = tk.StringVar(value=ALL_STEMS)\r\n        self.is_primary_stem_only_Text_var = tk.StringVar(value='')\r\n        self.is_secondary_stem_only_Text_var = tk.StringVar(value='')\r\n        self.is_primary_stem_only_Demucs_Text_var = tk.StringVar(value='')\r\n        self.is_secondary_stem_only_Demucs_Text_var = tk.StringVar(value='')\r\n        self.scaling_var = tk.DoubleVar(value=1.0)\r\n        self.active_processing_thread = None\r\n        self.verification_thread = None\r\n        self.is_menu_settings_open = False\r\n        self.is_root_defined_var = tk.BooleanVar(value=False)\r\n        self.is_check_splash = False\r\n        \r\n        self.is_open_menu_advanced_vr_options = tk.BooleanVar(value=False)\r\n        self.is_open_menu_advanced_demucs_options = tk.BooleanVar(value=False)\r\n        self.is_open_menu_advanced_mdx_options = tk.BooleanVar(value=False)\r\n        self.is_open_menu_advanced_ensemble_options = tk.BooleanVar(value=False)\r\n        self.is_open_menu_view_inputs = tk.BooleanVar(value=False)\r\n        self.is_open_menu_help = tk.BooleanVar(value=False)\r\n        self.is_open_menu_error_log = tk.BooleanVar(value=False)\r\n        self.is_open_menu_advanced_align_options = tk.BooleanVar(value=False)\r\n\r\n        self.menu_advanced_vr_options_close_window = None\r\n        self.menu_advanced_demucs_options_close_window = None\r\n        self.menu_advanced_mdx_options_close_window = None\r\n        self.menu_advanced_ensemble_options_close_window = None\r\n        self.menu_help_close_window = None\r\n        self.menu_error_log_close_window = None\r\n        self.menu_view_inputs_close_window = None\r\n        self.menu_advanced_align_options_close_window = None\r\n\r\n        self.mdx_model_params = None\r\n        self.vr_model_params = None\r\n        self.current_text_box = None\r\n        self.wav_type_set = None\r\n        self.is_online_model_menu = None\r\n        self.progress_bar_var = tk.IntVar(value=0)\r\n        self.is_confirm_error_var = tk.BooleanVar(value=False)\r\n        self.clear_cache_torch = False\r\n        self.vr_hash_MAPPER = load_model_hash_data(VR_HASH_JSON)\r\n        self.mdx_hash_MAPPER = load_model_hash_data(MDX_HASH_JSON)\r\n        self.mdx_name_select_MAPPER = load_model_hash_data(MDX_MODEL_NAME_SELECT)\r\n        self.demucs_name_select_MAPPER = load_model_hash_data(DEMUCS_MODEL_NAME_SELECT)\r\n        self.is_gpu_available = is_gpu_available\r\n        self.is_process_stopped = False\r\n        self.inputs_from_dir = []\r\n        self.iteration = 0\r\n        self.true_model_count = 0\r\n        self.vr_primary_source = None\r\n        self.vr_secondary_source = None\r\n        self.mdx_primary_source = None\r\n        self.mdx_secondary_source = None\r\n        self.demucs_primary_source = None\r\n        self.demucs_secondary_source = None\r\n        self.toplevels = []\r\n\r\n        #Download Center Vars\r\n        self.online_data = {}\r\n        self.bulletin_data = INFO_UNAVAILABLE_TEXT\r\n        self.is_online = False\r\n        self.lastest_version = ''\r\n        self.model_download_demucs_var = tk.StringVar(value='')\r\n        self.model_download_mdx_var = tk.StringVar(value='')\r\n        self.model_download_vr_var = tk.StringVar(value='')\r\n        self.selected_download_var = tk.StringVar(value=NO_MODEL)\r\n        self.select_download_var = tk.StringVar(value='')\r\n        self.download_progress_info_var = tk.StringVar(value='')\r\n        self.download_progress_percent_var = tk.StringVar(value='')\r\n        self.download_progress_bar_var = tk.IntVar(value=0)\r\n        self.download_stop_var = tk.StringVar(value='') \r\n        self.app_update_status_Text_var = tk.StringVar(value=LOADING_VERSION_INFO_TEXT)\r\n        self.app_update_button_Text_var = tk.StringVar(value=CHECK_FOR_UPDATES_TEXT)\r\n        \r\n        self.user_code_validation_var = tk.StringVar(value='')\r\n        self.download_link_path_var = tk.StringVar(value='') \r\n        self.download_save_path_var = tk.StringVar(value='')\r\n        self.download_update_link_var = tk.StringVar(value='') \r\n        self.download_update_path_var = tk.StringVar(value='') \r\n        self.download_demucs_models_list = []\r\n        self.download_demucs_newer_models = []\r\n        self.refresh_list_Button = None\r\n        self.stop_download_Button_DISABLE = None\r\n        self.enable_tabs = None\r\n        self.is_download_thread_active = False\r\n        self.is_process_thread_active = False\r\n        self.is_active_processing_thread = False\r\n        self.active_download_thread = None\r\n        self.pre_proc_model_toggle = None\r\n        self.change_state_lambda = None\r\n        self.file_one_sub_var = tk.StringVar(value=FILE_ONE_MAIN_LABEL) \r\n        self.file_two_sub_var = tk.StringVar(value=FILE_TWO_MAIN_LABEL) \r\n        self.cuda_device_list = GPU_DEVICE_NUM_OPTS\r\n        self.opencl_list = GPU_DEVICE_NUM_OPTS\r\n        \r\n        #Model Update\r\n        self.last_found_ensembles = ENSEMBLE_OPTIONS\r\n        self.last_found_settings = ENSEMBLE_OPTIONS\r\n        self.last_found_models = ()\r\n        self.model_data_table = ()\r\n        self.ensemble_model_list = ()\r\n        self.default_change_model_list = ()\r\n                \r\n        # --Widgets--\r\n        self.fill_main_frame()\r\n        self.bind_widgets()\r\n        \r\n        # --Update Widgets--\r\n        self.update_available_models()\r\n        self.update_main_widget_states()\r\n        self.update_loop()\r\n        self.update_button_states()\r\n        self.download_validate_code()\r\n        self.delete_temps(is_start_up=True)\r\n        self.ensemble_listbox_Option.configure(state=tk.DISABLED)\r\n        self.command_Text.write(f'Ultimate Vocal Remover {VERSION} [{datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")}]')\r\n        self.update_checkbox_text = lambda:self.selection_action_process_method(self.chosen_process_method_var.get())\r\n        self.check_dual_paths()\r\n        if not is_windows:\r\n            self.update_idletasks()\r\n        self.fill_gpu_list()\r\n        self.online_data_refresh(user_refresh=False, is_start_up=True)\r\n        \r\n    # Menu Functions\r\n    def main_window_LABEL_SET(self, master, text):return ttk.Label(master=master, text=text, background=BG_COLOR, font=self.font_set, foreground=FG_COLOR, anchor=tk.CENTER)\r\n    def main_window_LABEL_SUB_SET(self, master, text_var):return ttk.Label(master=master, textvariable=text_var, background=BG_COLOR, font=self.font_set, foreground=FG_COLOR, anchor=tk.CENTER)\r\n    def menu_title_LABEL_SET(self, frame, text, width=35):return ttk.Label(master=frame, text=text, font=(SEC_FONT_NAME, f\"{FONT_SIZE_5}\", \"underline\"), justify=\"center\", foreground=\"#13849f\", width=width, anchor=tk.CENTER)\r\n    def menu_sub_LABEL_SET(self, frame, text, font_size=FONT_SIZE_2):return ttk.Label(master=frame, text=text, font=(MAIN_FONT_NAME, f\"{font_size}\"), foreground=FG_COLOR, anchor=tk.CENTER)\r\n    def menu_FRAME_SET(self, frame, thickness=20):return tk.Frame(frame, highlightbackground=BG_COLOR, highlightcolor=BG_COLOR, highlightthicknes=thickness)\r\n    def check_is_menu_settings_open(self):self.menu_settings() if not self.is_menu_settings_open else None\r\n    def spacer_label(self, frame): return tk.Label(frame, text='', font=(MAIN_FONT_NAME, f\"{FONT_SIZE_1}\"), foreground='#868687', justify=\"left\").grid()\r\n\r\n    #Ensemble Listbox Functions\r\n    def ensemble_listbox_get_all_selected_models(self):return [self.ensemble_listbox_Option.get(i) for i in self.ensemble_listbox_Option.curselection()]\r\n    def ensemble_listbox_select_from_indexs(self, indexes):return [self.ensemble_listbox_Option.selection_set(i) for i in indexes]\r\n    def ensemble_listbox_clear_and_insert_new(self, model_ensemble_updated):return (self.ensemble_listbox_Option.delete(0, 'end'), [self.ensemble_listbox_Option.insert(tk.END, models) for models in model_ensemble_updated])\r\n    def ensemble_listbox_get_indexes_for_files(self, updated, selected):return [updated.index(model) for model in selected if model in updated]\r\n    \r\n    def set_app_font(self):\r\n        chosen_font_name, chosen_font_file = font_checker(OWN_FONT_PATH)\r\n\r\n        if chosen_font_name:\r\n            gui_data.sv_ttk.set_theme(\"dark\", chosen_font_name, 10)\r\n            if chosen_font_file:\r\n                pyglet_font.add_file(chosen_font_file)\r\n            self.font_set = Font(family=chosen_font_name, size=FONT_SIZE_F2)\r\n            self.font_entry = Font(family=chosen_font_name, size=FONT_SIZE_F2)\r\n        else:\r\n            pyglet_font.add_file(FONT_MAPPER[MAIN_FONT_NAME])\r\n            pyglet_font.add_file(FONT_MAPPER[SEC_FONT_NAME])\r\n            gui_data.sv_ttk.set_theme(\"dark\", MAIN_FONT_NAME, 10)\r\n            self.font_set = Font(family=SEC_FONT_NAME, size=FONT_SIZE_F2)\r\n            self.font_entry = Font(family=MAIN_FONT_NAME, size=FONT_SIZE_F2)\r\n    \r\n    def process_iteration(self):\r\n        self.iteration = self.iteration + 1\r\n    \r\n    def assemble_model_data(self, model=None, arch_type=ENSEMBLE_MODE, is_dry_check=False, is_change_def=False, is_get_hash_dir_only=False):\r\n\r\n        if arch_type == ENSEMBLE_STEM_CHECK:\r\n            \r\n            model_data = self.model_data_table\r\n            missing_models = [model.model_status for model in model_data if not model.model_status]\r\n            \r\n            if missing_models or not model_data:\r\n                model_data: List[ModelData] = [ModelData(model_name, is_dry_check=is_dry_check) for model_name in self.ensemble_model_list]\r\n                self.model_data_table = model_data\r\n\r\n        if arch_type == KARAOKEE_CHECK:\r\n            model_list = []\r\n            model_data: List[ModelData] = [ModelData(model_name, is_dry_check=is_dry_check) for model_name in self.default_change_model_list]\r\n            for model in model_data:\r\n                if model.model_status and model.is_karaoke or model.is_bv_model:\r\n                    model_list.append(model.model_and_process_tag)\r\n            \r\n            return model_list\r\n\r\n        if arch_type == ENSEMBLE_MODE:\r\n            model_data: List[ModelData] = [ModelData(model_name) for model_name in self.ensemble_listbox_get_all_selected_models()]\r\n        if arch_type == ENSEMBLE_CHECK:\r\n            model_data: List[ModelData] = [ModelData(model, is_change_def=is_change_def, is_get_hash_dir_only=is_get_hash_dir_only)]\r\n        if arch_type == VR_ARCH_TYPE or arch_type == VR_ARCH_PM:\r\n            model_data: List[ModelData] = [ModelData(model, VR_ARCH_TYPE)]\r\n        if arch_type == MDX_ARCH_TYPE:\r\n            model_data: List[ModelData] = [ModelData(model, MDX_ARCH_TYPE)]\r\n        if arch_type == DEMUCS_ARCH_TYPE:\r\n            model_data: List[ModelData] = [ModelData(model, DEMUCS_ARCH_TYPE)]#\r\n\r\n        return model_data\r\n        \r\n    def clear_cache(self, network):\r\n        \r\n        if network == VR_ARCH_TYPE:\r\n            dir = VR_HASH_DIR\r\n        if network == MDX_ARCH_TYPE:\r\n            dir = MDX_HASH_DIR     \r\n        \r\n        for filename in os.listdir(dir):\r\n            filepath = os.path.join(dir, filename)\r\n            if filename not in ['model_data.json', 'model_name_mapper.json', 'mdx_c_configs'] and not os.path.isdir(filepath):\r\n                os.remove(filepath)\r\n        \r\n        self.vr_model_var.set(CHOOSE_MODEL)\r\n        self.mdx_net_model_var.set(CHOOSE_MODEL)\r\n        self.model_data_table.clear()\r\n        self.chosen_ensemble_var.set(CHOOSE_ENSEMBLE_OPTION)\r\n        self.ensemble_main_stem_var.set(CHOOSE_STEM_PAIR)\r\n        self.ensemble_listbox_Option.configure(state=tk.DISABLED)\r\n        self.update_checkbox_text()\r\n    \r\n    def thread_check(self, thread_to_check):\r\n        '''Checks if thread is alive'''\r\n        \r\n        is_running = False\r\n        \r\n        if type(thread_to_check) is KThread:\r\n            if thread_to_check.is_alive():\r\n                is_running = True\r\n                \r\n        return is_running\r\n\r\n    # -Widget Methods--\r\n\r\n    def fill_main_frame(self):\r\n        \"\"\"Creates root window widgets\"\"\"\r\n        \r\n        self.title_Label = tk.Label(master=self, image=self.logo_img, compound=tk.TOP)\r\n        self.title_Label.place(x=-2, y=banner_placement)\r\n\r\n        self.fill_filePaths_Frame()\r\n        self.fill_options_Frame()\r\n        \r\n        self.conversion_Button = ttk.Button(master=self, textvariable=self.conversion_Button_Text_var, command=self.process_initialize)\r\n        self.conversion_Button.place(x=X_CONVERSION_BUTTON_1080P, y=BUTTON_Y_1080P, width=WIDTH_CONVERSION_BUTTON_1080P, height=HEIGHT_GENERIC_BUTTON_1080P,\r\n                                    relx=0, rely=0, relwidth=1, relheight=0)\r\n        \r\n        self.conversion_Button_enable = lambda:(self.conversion_Button_Text_var.set(START_PROCESSING), self.conversion_Button.configure(state=tk.NORMAL))\r\n        self.conversion_Button_disable = lambda message:(self.conversion_Button_Text_var.set(message), self.conversion_Button.configure(state=tk.DISABLED))\r\n        \r\n        self.stop_Button = ttk.Button(master=self, image=self.stop_img, command=self.confirm_stop_process)\r\n        self.stop_Button.place(x=X_STOP_BUTTON_1080P, y=BUTTON_Y_1080P, width=HEIGHT_GENERIC_BUTTON_1080P, height=HEIGHT_GENERIC_BUTTON_1080P,\r\n                            relx=1, rely=0, relwidth=0, relheight=0)\r\n        self.help_hints(self.stop_Button, text=STOP_HELP)\r\n        \r\n        self.settings_Button = ttk.Button(master=self, image=self.help_img, command=self.check_is_menu_settings_open)\r\n        self.settings_Button.place(x=X_SETTINGS_BUTTON_1080P, y=BUTTON_Y_1080P, width=HEIGHT_GENERIC_BUTTON_1080P, height=HEIGHT_GENERIC_BUTTON_1080P,\r\n                                relx=1, rely=0, relwidth=0, relheight=0)\r\n        self.help_hints(self.settings_Button, text=SETTINGS_HELP)\r\n    \r\n        self.progressbar = ttk.Progressbar(master=self, variable=self.progress_bar_main_var)\r\n        self.progressbar.place(x=X_PROGRESSBAR_1080P, y=Y_OFFSET_PROGRESS_BAR_1080P, width=WIDTH_PROGRESSBAR_1080P, height=HEIGHT_PROGRESSBAR_1080P,\r\n                            relx=0, rely=0, relwidth=1, relheight=0)\r\n\r\n         # Select Music Files Option\r\n        self.console_Frame = tk.Frame(master=self, highlightbackground='#101012', highlightcolor='#101012', highlightthicknes=2)\r\n        self.console_Frame.place(x=15, y=self.IMAGE_HEIGHT + self.FILEPATHS_HEIGHT + self.OPTIONS_HEIGHT + self.CONVERSIONBUTTON_HEIGHT + self.PADDING + 5 *3, width=-30, height=self.COMMAND_HEIGHT+7,\r\n                                relx=0, rely=0, relwidth=1, relheight=0)\r\n\r\n\r\n        self.command_Text = ThreadSafeConsole(master=self.console_Frame, background='#0c0c0d',fg='#898b8e', highlightcolor=\"#0c0c0d\",  font=(MAIN_FONT_NAME, FONT_SIZE_4), borderwidth=0)\r\n        self.command_Text.pack(fill=tk.BOTH, expand=1)\r\n        self.command_Text.bind(right_click_button, lambda e:self.right_click_console(e))\r\n            \r\n    def fill_filePaths_Frame(self):\r\n        \"\"\"Fill Frame with neccessary widgets\"\"\"\r\n\r\n        # Select Music Files Option\r\n        self.filePaths_Frame = ttk.Frame(master=self)\r\n        self.filePaths_Frame.place(x=FILEPATHS_FRAME_X, y=FILEPATHS_FRAME_Y, width=FILEPATHS_FRAME_WIDTH, height=self.FILEPATHS_HEIGHT, relx=0, rely=0, relwidth=1, relheight=0)\r\n\r\n        self.filePaths_musicFile_Button = ttk.Button(master=self.filePaths_Frame, text=SELECT_INPUT_TEXT, command=self.input_select_filedialog)\r\n        self.filePaths_musicFile_Button.place(x=MUSICFILE_BUTTON_X, y=MUSICFILE_BUTTON_Y, width=MUSICFILE_BUTTON_WIDTH, height=MUSICFILE_BUTTON_HEIGHT, relx=0, rely=0, relwidth=0.3, relheight=0.5)\r\n        self.filePaths_musicFile_Entry = ttk.Entry(master=self.filePaths_Frame, textvariable=self.inputPathsEntry_var, font=self.font_entry, state=tk.DISABLED)\r\n        self.filePaths_musicFile_Entry.place(x=MUSICFILE_ENTRY_X, y=MUSICFILE_BUTTON_Y, width=MUSICFILE_ENTRY_WIDTH, height=MUSICFILE_ENTRY_HEIGHT, relx=0.3, rely=0, relwidth=0.7, relheight=0.5)                                   \r\n        self.filePaths_musicFile_Open = ttk.Button(master=self.filePaths_Frame, image=self.efile_img, command=lambda:OPEN_FILE_func(os.path.dirname(self.inputPaths[0])) if self.inputPaths and os.path.isdir(os.path.dirname(self.inputPaths[0])) else self.error_dialoge(INVALID_INPUT))\r\n        self.filePaths_musicFile_Open.place(x=OPEN_BUTTON_X, y=MUSICFILE_BUTTON_Y, width=OPEN_BUTTON_WIDTH, height=MUSICFILE_ENTRY_HEIGHT, relx=0.3, rely=0, relwidth=0.7, relheight=0.5)   \r\n\r\n        # Add any additional configurations or method calls here\r\n        self.filePaths_musicFile_Entry.configure(cursor=\"hand2\")\r\n        self.help_hints(self.filePaths_musicFile_Button, text=INPUT_FOLDER_ENTRY_HELP) \r\n        self.help_hints(self.filePaths_musicFile_Entry, text=INPUT_FOLDER_ENTRY_HELP_2)\r\n        self.help_hints(self.filePaths_musicFile_Open, text=INPUT_FOLDER_BUTTON_HELP)     \r\n\r\n        # Save To Option\r\n        self.filePaths_saveTo_Button = ttk.Button(master=self.filePaths_Frame, text=SELECT_OUTPUT_TEXT, command=self.export_select_filedialog)\r\n        self.filePaths_saveTo_Button.place(x=SAVETO_BUTTON_X, y=SAVETO_BUTTON_Y, width=SAVETO_BUTTON_WIDTH, height=SAVETO_BUTTON_HEIGHT, relx=0, rely=0.5, relwidth=0.3, relheight=0.5)\r\n        self.filePaths_saveTo_Entry = ttk.Entry(master=self.filePaths_Frame, textvariable=self.export_path_var, font=self.font_entry, state=tk.DISABLED)\r\n        self.filePaths_saveTo_Entry.place(x=SAVETO_ENTRY_X, y=SAVETO_BUTTON_Y, width=SAVETO_ENTRY_WIDTH, height=SAVETO_ENTRY_HEIGHT, relx=0.3, rely=0.5, relwidth=0.7, relheight=0.5)\r\n        self.filePaths_saveTo_Open = ttk.Button(master=self.filePaths_Frame, image=self.efile_img, command=lambda:OPEN_FILE_func(Path(self.export_path_var.get())) if os.path.isdir(self.export_path_var.get()) else self.error_dialoge(INVALID_EXPORT))\r\n        self.filePaths_saveTo_Open.place(x=OPEN_BUTTON_X, y=SAVETO_BUTTON_Y, width=OPEN_BUTTON_WIDTH, height=SAVETO_ENTRY_HEIGHT, relx=0.3, rely=0.5, relwidth=0.7, relheight=0.5)\r\n        self.help_hints(self.filePaths_saveTo_Button, text=OUTPUT_FOLDER_ENTRY_HELP) \r\n        self.help_hints(self.filePaths_saveTo_Open, text=OUTPUT_FOLDER_BUTTON_HELP)     \r\n\r\n    def fill_options_Frame(self):\r\n        \"\"\"Fill Frame with neccessary widgets\"\"\"\r\n        \r\n        self.options_Frame = ttk.Frame(master=self)\r\n        self.options_Frame.place(x=OPTIONS_FRAME_X, y=OPTIONS_FRAME_Y, width=OPTIONS_FRAME_WIDTH, height=self.OPTIONS_HEIGHT, relx=0, rely=0, relwidth=1, relheight=0)\r\n\r\n        # -Create Widgets-\r\n\r\n        ## Save Format\r\n        self.wav_button = ttk.Radiobutton(master=self.options_Frame, text=WAV, variable=self.save_format_var, value=WAV)\r\n        self.wav_button.place(x=RADIOBUTTON_X_WAV, y=RADIOBUTTON_Y, width=RADIOBUTTON_WIDTH, height=RADIOBUTTON_HEIGHT, relx=0, rely=0/self.COL2_ROWS, relwidth=1/3, relheight=1/self.COL2_ROWS)\r\n        self.help_hints(self.wav_button, text=f'{FORMAT_SETTING_HELP}{WAV}')\r\n\r\n        self.flac_button = ttk.Radiobutton(master=self.options_Frame, text=FLAC, variable=self.save_format_var, value=FLAC)\r\n        self.flac_button.place(x=RADIOBUTTON_X_FLAC, y=RADIOBUTTON_Y, width=RADIOBUTTON_WIDTH, height=RADIOBUTTON_HEIGHT, relx=1/3, rely=0/self.COL2_ROWS, relwidth=1/3, relheight=1/self.COL2_ROWS)\r\n        self.help_hints(self.flac_button, text=f'{FORMAT_SETTING_HELP}{FLAC}')\r\n\r\n        self.mp3_button = ttk.Radiobutton(master=self.options_Frame, text=MP3, variable=self.save_format_var, value=MP3)\r\n        self.mp3_button.place(x=RADIOBUTTON_X_MP3, y=RADIOBUTTON_Y, width=RADIOBUTTON_WIDTH, height=RADIOBUTTON_HEIGHT, relx=2/3, rely=0/self.COL2_ROWS, relwidth=1/3, relheight=1/self.COL2_ROWS)\r\n        self.help_hints(self.mp3_button, text=f'{FORMAT_SETTING_HELP}{MP3}')\r\n\r\n        # Choose Conversion Method\r\n        self.chosen_process_method_Label = self.main_window_LABEL_SET(self.options_Frame, CHOOSE_PROC_METHOD_MAIN_LABEL)\r\n        self.chosen_process_method_Label.place(x=0, y=MAIN_ROW_Y[0], width=LEFT_ROW_WIDTH, height=LABEL_HEIGHT, relx=0, rely=2/self.COL1_ROWS, relwidth=1/3, relheight=1/self.COL1_ROWS)\r\n        self.chosen_process_method_Option = ComboBoxMenu(self.options_Frame, textvariable=self.chosen_process_method_var, values=PROCESS_METHODS, command=lambda e: self.selection_action_process_method(self.chosen_process_method_var.get(), from_widget=True, is_from_conv_menu=True))\r\n        self.chosen_process_method_Option.place(x=0, y=MAIN_ROW_Y[1], width=LEFT_ROW_WIDTH, height=OPTION_HEIGHT, relx=0, rely=3/self.COL1_ROWS, relwidth=1/3, relheight=1/self.COL1_ROWS)\r\n        #self.chosen_process_method_var.trace_add('write', lambda *args: self.update_main_widget_states())\r\n        self.help_hints(self.chosen_process_method_Label, text=CHOSEN_PROCESS_METHOD_HELP)\r\n        \r\n        #  Choose Settings Option\r\n        self.save_current_settings_Label = self.main_window_LABEL_SET(self.options_Frame, SELECT_SAVED_SETTINGS_MAIN_LABEL)\r\n        self.save_current_settings_Label_place = lambda:self.save_current_settings_Label.place(x=MAIN_ROW_2_X[0], y=LOW_MENU_Y[0], width=0, height=LABEL_HEIGHT, relx=2/3, rely=6/self.COL1_ROWS, relwidth=1/3, relheight=1/self.COL1_ROWS)\r\n        self.save_current_settings_Option = ComboBoxMenu(self.options_Frame, textvariable=self.save_current_settings_var, command=lambda e:self.selection_action_saved_settings(self.save_current_settings_var.get()))\r\n        self.save_current_settings_Option_place = lambda:self.save_current_settings_Option.place(x=MAIN_ROW_2_X[1], y=LOW_MENU_Y[1], width=MAIN_ROW_WIDTH, height=OPTION_HEIGHT, relx=2/3, rely=7/self.COL1_ROWS, relwidth=1/3, relheight=1/self.COL1_ROWS)\r\n        self.help_hints(self.save_current_settings_Label, text=SAVE_CURRENT_SETTINGS_HELP)\r\n        \r\n        ### MDX-NET ###\r\n\r\n        #  Choose MDX-Net Model\r\n        self.mdx_net_model_Label = self.main_window_LABEL_SET(self.options_Frame, CHOOSE_MDX_MODEL_MAIN_LABEL)\r\n        self.mdx_net_model_Label_place = lambda:self.mdx_net_model_Label.place(x=0, y=LOW_MENU_Y[0], width=LEFT_ROW_WIDTH, height=LABEL_HEIGHT, relx=0, rely=6/self.COL1_ROWS, relwidth=1/3, relheight=1/self.COL1_ROWS)\r\n        self.mdx_net_model_Option = ComboBoxMenu(self.options_Frame, textvariable=self.mdx_net_model_var, command=lambda event: self.selection_action(event, self.mdx_net_model_var, is_mdx_net=True))\r\n        self.mdx_net_model_Option_place = lambda:self.mdx_net_model_Option.place(x=0, y=LOW_MENU_Y[1], width=LEFT_ROW_WIDTH, height=OPTION_HEIGHT, relx=0, rely=7/self.COL1_ROWS, relwidth=1/3, relheight=1/self.COL1_ROWS)\r\n        #self.mdx_net_model_var.trace_add('write', lambda *args: self.update_main_widget_states_mdx())\r\n        self.help_hints(self.mdx_net_model_Label, text=CHOOSE_MODEL_HELP)\r\n        \r\n        # MDX-Overlap\r\n        self.overlap_mdx_Label = self.main_window_LABEL_SET(self.options_Frame, 'OVERLAP')\r\n        self.overlap_mdx_Label_place = lambda:self.overlap_mdx_Label.place(x=MAIN_ROW_2_X[0], y=MAIN_ROW_2_Y[0], width=0, height=LABEL_HEIGHT, relx=2/3, rely=2/self.COL1_ROWS, relwidth=1/3, relheight=1/self.COL2_ROWS)\r\n        self.overlap_mdx_Option = ComboBoxEditableMenu(self.options_Frame, values=MDX_OVERLAP, width=MENU_COMBOBOX_WIDTH, textvariable=self.overlap_mdx_var, pattern=REG_OVERLAP, default=MDX_OVERLAP)\r\n        self.overlap_mdx_Option_place = lambda:self.overlap_mdx_Option.place(x=MAIN_ROW_2_X[1], y=MAIN_ROW_2_Y[1], width=MAIN_ROW_WIDTH, height=OPTION_HEIGHT, relx=2/3, rely=3/self.COL1_ROWS, relwidth=1/3, relheight=1/self.COL2_ROWS)\r\n        \r\n        # MDX23-Overlap\r\n        self.overlap_mdx23_Option = ComboBoxEditableMenu(self.options_Frame, values=MDX23_OVERLAP, width=MENU_COMBOBOX_WIDTH, textvariable=self.overlap_mdx23_var, pattern=REG_OVERLAP23, default=\"8\")\r\n        self.overlap_mdx23_Option_place = lambda:self.overlap_mdx23_Option.place(x=MAIN_ROW_2_X[1], y=MAIN_ROW_2_Y[1], width=MAIN_ROW_WIDTH, height=OPTION_HEIGHT, relx=2/3, rely=3/self.COL1_ROWS, relwidth=1/3, relheight=1/self.COL2_ROWS)\r\n        self.help_hints(self.overlap_mdx_Label, text=MDX_OVERLAP_HELP)\r\n        \r\n        # Choose MDX-Net Stems\r\n        self.mdxnet_stems_Label = self.main_window_LABEL_SET(self.options_Frame, CHOOSE_STEMS_MAIN_LABEL)\r\n        self.mdxnet_stems_Label_place = lambda:self.mdxnet_stems_Label.place(x=MAIN_ROW_X[0], y=MAIN_ROW_Y[0], width=0, height=LABEL_HEIGHT, relx=1/3, rely=2/self.COL2_ROWS, relwidth=1/3, relheight=1/self.COL2_ROWS)\r\n        \r\n        self.mdxnet_stems_Option = ComboBoxMenu(self.options_Frame, textvariable=self.mdxnet_stems_var)\r\n        self.mdxnet_stems_Option_place = lambda:self.mdxnet_stems_Option.place(x=MAIN_ROW_X[1], y=MAIN_ROW_Y[1], width=MAIN_ROW_WIDTH, height=OPTION_HEIGHT, relx=1/3, rely=3/self.COL2_ROWS, relwidth=1/3, relheight=1/self.COL2_ROWS)\r\n        self.help_hints(self.mdxnet_stems_Label, text=DEMUCS_STEMS_HELP)\r\n        \r\n        # MDX-Segment Size\r\n        self.mdx_segment_size_Label = self.main_window_LABEL_SET(self.options_Frame, SEGMENT_MDX_MAIN_LABEL)\r\n        self.mdx_segment_size_Label_place = lambda:self.mdx_segment_size_Label.place(x=MAIN_ROW_X[0], y=MAIN_ROW_Y[0], width=0, height=LABEL_HEIGHT, relx=1/3, rely=2/self.COL1_ROWS, relwidth=1/3, relheight=1/self.COL2_ROWS)\r\n        self.mdx_segment_size_Option = ComboBoxEditableMenu(self.options_Frame, values=MDX_SEGMENTS, width=MENU_COMBOBOX_WIDTH, textvariable=self.mdx_segment_size_var, pattern=REG_MDX_SEG, default=\"256\")#\r\n        self.mdx_segment_size_Option_place = lambda:self.mdx_segment_size_Option.place(x=MAIN_ROW_X[1], y=MAIN_ROW_Y[1], width=MAIN_ROW_WIDTH, height=OPTION_HEIGHT, relx=1/3, rely=3/self.COL1_ROWS, relwidth=1/3, relheight=1/self.COL2_ROWS)\r\n        self.help_hints(self.mdx_segment_size_Label, text=MDX_SEGMENT_SIZE_HELP)\r\n\r\n        ### VR ARCH ###\r\n        \r\n        #  Choose VR Model\r\n        self.vr_model_Label = self.main_window_LABEL_SET(self.options_Frame, SELECT_VR_MODEL_MAIN_LABEL)\r\n        self.vr_model_Label_place = lambda:self.vr_model_Label.place(x=0, y=LOW_MENU_Y[0], width=LEFT_ROW_WIDTH, height=LABEL_HEIGHT, relx=0, rely=6/self.COL1_ROWS, relwidth=1/3, relheight=1/self.COL1_ROWS)\r\n        self.vr_model_Option = ComboBoxMenu(self.options_Frame, textvariable=self.vr_model_var, command=lambda event: self.selection_action(event, self.vr_model_var))\r\n        self.vr_model_Option_place = lambda:self.vr_model_Option.place(x=0, y=LOW_MENU_Y[1], width=LEFT_ROW_WIDTH, height=OPTION_HEIGHT, relx=0, rely=7/self.COL1_ROWS, relwidth=1/3, relheight=1/self.COL1_ROWS)\r\n        self.help_hints(self.vr_model_Label, text=CHOOSE_MODEL_HELP)\r\n        \r\n        # Aggression Setting\r\n        self.aggression_setting_Label = self.main_window_LABEL_SET(self.options_Frame, AGGRESSION_SETTING_MAIN_LABEL)\r\n        self.aggression_setting_Label_place = lambda:self.aggression_setting_Label.place(x=MAIN_ROW_2_X[0], y=MAIN_ROW_2_Y[0], width=0, height=LABEL_HEIGHT, relx=2/3, rely=2/self.COL2_ROWS, relwidth=1/3, relheight=1/self.COL2_ROWS)\r\n        self.aggression_setting_Option = ComboBoxEditableMenu(self.options_Frame, values=VR_AGGRESSION, textvariable=self.aggression_setting_var, pattern=REG_AGGRESSION, default=VR_AGGRESSION[5])#\r\n        self.aggression_setting_Option_place = lambda:self.aggression_setting_Option.place(x=MAIN_ROW_2_X[1], y=MAIN_ROW_2_Y[1], width=MAIN_ROW_WIDTH, height=OPTION_HEIGHT, relx=2/3, rely=3/self.COL2_ROWS, relwidth=1/3, relheight=1/self.COL2_ROWS)\r\n        self.help_hints(self.aggression_setting_Label, text=AGGRESSION_SETTING_HELP)\r\n        \r\n        # Window Size\r\n        self.window_size_Label = self.main_window_LABEL_SET(self.options_Frame, WINDOW_SIZE_MAIN_LABEL)\r\n        self.window_size_Label_place = lambda:self.window_size_Label.place(x=MAIN_ROW_X[0], y=MAIN_ROW_Y[0], width=0, height=LABEL_HEIGHT, relx=1/3, rely=2/self.COL2_ROWS, relwidth=1/3, relheight=1/self.COL2_ROWS)\r\n        self.window_size_Option = ComboBoxEditableMenu(self.options_Frame, values=VR_WINDOW, textvariable=self.window_size_var, pattern=REG_WINDOW, default=VR_WINDOW[1])#\r\n        self.window_size_Option_place = lambda:self.window_size_Option.place(x=MAIN_ROW_X[1], y=MAIN_ROW_Y[1], width=MAIN_ROW_WIDTH, height=OPTION_HEIGHT, relx=1/3, rely=3/self.COL2_ROWS, relwidth=1/3, relheight=1/self.COL2_ROWS)\r\n        self.help_hints(self.window_size_Label, text=WINDOW_SIZE_HELP)\r\n        \r\n        ### DEMUCS ###\r\n        \r\n        #  Choose Demucs Models\r\n        self.demucs_model_Label = self.main_window_LABEL_SET(self.options_Frame, CHOOSE_DEMUCS_MODEL_MAIN_LABEL)\r\n        self.demucs_model_Label_place = lambda:self.demucs_model_Label.place(x=0, y=LOW_MENU_Y[0], width=LEFT_ROW_WIDTH, height=LABEL_HEIGHT, relx=0, rely=6/self.COL1_ROWS, relwidth=1/3, relheight=1/self.COL1_ROWS)\r\n        self.demucs_model_Option = ComboBoxMenu(self.options_Frame, textvariable=self.demucs_model_var, command=lambda event: self.selection_action(event, self.demucs_model_var))\r\n        self.demucs_model_Option_place = lambda:self.demucs_model_Option.place(x=0, y=LOW_MENU_Y[1], width=LEFT_ROW_WIDTH, height=OPTION_HEIGHT, relx=0, rely=7/self.COL1_ROWS, relwidth=1/3, relheight=1/self.COL1_ROWS)\r\n        self.help_hints(self.demucs_model_Label, text=CHOOSE_MODEL_HELP)\r\n\r\n        # Choose Demucs Stems\r\n        self.demucs_stems_Label = self.main_window_LABEL_SET(self.options_Frame, CHOOSE_STEMS_MAIN_LABEL)\r\n        self.demucs_stems_Label_place = lambda:self.demucs_stems_Label.place(x=MAIN_ROW_X[0], y=MAIN_ROW_Y[0], width=0, height=LABEL_HEIGHT, relx=1/3, rely=2/self.COL2_ROWS, relwidth=1/3, relheight=1/self.COL2_ROWS)\r\n        self.demucs_stems_Option = ComboBoxMenu(self.options_Frame, textvariable=self.demucs_stems_var)\r\n        self.demucs_stems_Option_place = lambda:self.demucs_stems_Option.place(x=MAIN_ROW_X[1], y=MAIN_ROW_Y[1], width=MAIN_ROW_WIDTH, height=OPTION_HEIGHT, relx=1/3, rely=3/self.COL2_ROWS, relwidth=1/3, relheight=1/self.COL2_ROWS)\r\n        self.help_hints(self.demucs_stems_Label, text=DEMUCS_STEMS_HELP)\r\n\r\n        # Demucs-Segment\r\n        self.segment_Label = self.main_window_LABEL_SET(self.options_Frame, CHOOSE_SEGMENT_MAIN_LABEL)\r\n        self.segment_Label_place = lambda:self.segment_Label.place(x=MAIN_ROW_2_X[0], y=MAIN_ROW_2_Y[0], width=0, height=LABEL_HEIGHT, relx=2/3, rely=2/self.COL2_ROWS, relwidth=1/3, relheight=1/self.COL2_ROWS)\r\n        self.segment_Option = ComboBoxEditableMenu(self.options_Frame, values=DEMUCS_SEGMENTS, textvariable=self.segment_var, pattern=REG_SEGMENTS, default=DEMUCS_SEGMENTS)#\r\n        self.segment_Option_place = lambda:self.segment_Option.place(x=MAIN_ROW_2_X[1], y=MAIN_ROW_2_Y[1], width=MAIN_ROW_WIDTH, height=OPTION_HEIGHT, relx=2/3, rely=3/self.COL2_ROWS, relwidth=1/3, relheight=1/self.COL2_ROWS)\r\n        self.help_hints(self.segment_Label, text=SEGMENT_HELP)\r\n     \r\n        # Stem A\r\n        self.is_primary_stem_only_Demucs_Option = ttk.Checkbutton(master=self.options_Frame, textvariable=self.is_primary_stem_only_Demucs_Text_var, variable=self.is_primary_stem_only_Demucs_var, command=lambda:self.is_primary_stem_only_Demucs_Option_toggle())\r\n        self.is_primary_stem_only_Demucs_Option_place = lambda:self.is_primary_stem_only_Demucs_Option.place(x=CHECK_BOX_X, y=CHECK_BOX_Y, width=CHECK_BOX_WIDTH, height=CHECK_BOX_HEIGHT, relx=1/3, rely=6/self.COL2_ROWS, relwidth=1/3, relheight=1/self.COL2_ROWS)\r\n        self.is_primary_stem_only_Demucs_Option_toggle = lambda:self.is_secondary_stem_only_Demucs_var.set(False) if self.is_primary_stem_only_Demucs_var.get() else self.is_secondary_stem_only_Demucs_Option.configure(state=tk.NORMAL)\r\n        self.help_hints(self.is_primary_stem_only_Demucs_Option, text=SAVE_STEM_ONLY_HELP)\r\n        \r\n        # Stem B\r\n        self.is_secondary_stem_only_Demucs_Option = ttk.Checkbutton(master=self.options_Frame, textvariable=self.is_secondary_stem_only_Demucs_Text_var, variable=self.is_secondary_stem_only_Demucs_var, command=lambda:self.is_secondary_stem_only_Demucs_Option_toggle())\r\n        self.is_secondary_stem_only_Demucs_Option_place = lambda:self.is_secondary_stem_only_Demucs_Option.place(x=CHECK_BOX_X, y=CHECK_BOX_Y, width=CHECK_BOX_WIDTH, height=CHECK_BOX_HEIGHT, relx=1/3, rely=7/self.COL2_ROWS, relwidth=1/3, relheight=1/self.COL2_ROWS)\r\n        self.is_secondary_stem_only_Demucs_Option_toggle = lambda:self.is_primary_stem_only_Demucs_var.set(False) if self.is_secondary_stem_only_Demucs_var.get() else self.is_primary_stem_only_Demucs_Option.configure(state=tk.NORMAL)\r\n        self.is_stem_only_Demucs_Options_Enable = lambda:(self.is_primary_stem_only_Demucs_Option.configure(state=tk.NORMAL), self.is_secondary_stem_only_Demucs_Option.configure(state=tk.NORMAL))\r\n        self.help_hints(self.is_secondary_stem_only_Demucs_Option, text=SAVE_STEM_ONLY_HELP)\r\n\r\n        ### ENSEMBLE MODE ###\r\n\r\n        # Ensemble Mode\r\n        self.chosen_ensemble_Label = self.main_window_LABEL_SET(self.options_Frame, ENSEMBLE_OPTIONS_MAIN_LABEL)\r\n        self.chosen_ensemble_Label_place = lambda:self.chosen_ensemble_Label.place(x=0, y=LOW_MENU_Y[0], width=LEFT_ROW_WIDTH, height=LABEL_HEIGHT, relx=0, rely=6/self.COL1_ROWS, relwidth=1/3, relheight=1/self.COL1_ROWS)\r\n        self.chosen_ensemble_Option = ComboBoxMenu(self.options_Frame, textvariable=self.chosen_ensemble_var, command=lambda e:self.selection_action_chosen_ensemble(self.chosen_ensemble_var.get()))\r\n        self.chosen_ensemble_Option_place = lambda:self.chosen_ensemble_Option.place(x=0, y=LOW_MENU_Y[1], width=LEFT_ROW_WIDTH, height=OPTION_HEIGHT, relx=0, rely=7/self.COL1_ROWS, relwidth=1/3, relheight=1/self.COL1_ROWS)\r\n        self.help_hints(self.chosen_ensemble_Label, text=CHOSEN_ENSEMBLE_HELP)\r\n                        \r\n        # Ensemble Main Stems\r\n        self.ensemble_main_stem_Label = self.main_window_LABEL_SET(self.options_Frame, CHOOSE_MAIN_PAIR_MAIN_LABEL)\r\n        self.ensemble_main_stem_Label_place = lambda:self.ensemble_main_stem_Label.place(x=MAIN_ROW_X[0], y=MAIN_ROW_Y[0], width=0, height=LABEL_HEIGHT, relx=1/3, rely=2/self.COL1_ROWS, relwidth=1/3, relheight=1/self.COL1_ROWS)\r\n        self.ensemble_main_stem_Option = ComboBoxMenu(self.options_Frame, textvariable=self.ensemble_main_stem_var, values=ENSEMBLE_MAIN_STEM, command=lambda e: self.selection_action_ensemble_stems(self.ensemble_main_stem_var.get()))\r\n        self.ensemble_main_stem_Option_place = lambda:self.ensemble_main_stem_Option.place(x=MAIN_ROW_X[1], y=MAIN_ROW_Y[1], width=MAIN_ROW_WIDTH, height=OPTION_HEIGHT, relx=1/3, rely=3/self.COL1_ROWS, relwidth=1/3, relheight=1/self.COL1_ROWS)\r\n        self.help_hints(self.ensemble_main_stem_Label, text=ENSEMBLE_MAIN_STEM_HELP)\r\n\r\n        # Ensemble Algorithm\r\n        self.ensemble_type_Label = self.main_window_LABEL_SET(self.options_Frame, CHOOSE_ENSEMBLE_ALGORITHM_MAIN_LABEL)\r\n        self.ensemble_type_Label_place = lambda:self.ensemble_type_Label.place(x=MAIN_ROW_2_X[0], y=MAIN_ROW_2_Y[0], width=0, height=LABEL_HEIGHT, relx=2/3, rely=2/11, relwidth=1/3, relheight=1/self.COL1_ROWS)\r\n        self.ensemble_type_Option = ComboBoxMenu(self.options_Frame, textvariable=self.ensemble_type_var, values=ENSEMBLE_TYPE)\r\n        self.ensemble_type_Option_place = lambda:self.ensemble_type_Option.place(x=MAIN_ROW_2_X[1], y=MAIN_ROW_2_Y[1], width=MAIN_ROW_WIDTH, height=OPTION_HEIGHT,relx=2/3, rely=3/11, relwidth=1/3, relheight=1/self.COL1_ROWS)\r\n        self.help_hints(self.ensemble_type_Label, text=ENSEMBLE_TYPE_HELP)\r\n        \r\n        # Select Music Files Option\r\n    \r\n        # Ensemble Save Ensemble Outputs\r\n        self.ensemble_listbox_Label = self.main_window_LABEL_SET(self.options_Frame, AVAILABLE_MODELS_MAIN_LABEL)\r\n        self.ensemble_listbox_Label_place = lambda:self.ensemble_listbox_Label.place(x=MAIN_ROW_2_X[0], y=MAIN_ROW_2_Y[1], width=0, height=LABEL_HEIGHT, relx=2/3, rely=5/11, relwidth=1/3, relheight=1/self.COL1_ROWS)\r\n        self.ensemble_listbox_Frame = tk.Frame(self.options_Frame, highlightbackground='#04332c', highlightcolor='#04332c', highlightthicknes=1)\r\n        self.ensemble_listbox_Option = tk.Listbox(self.ensemble_listbox_Frame, selectmode=tk.MULTIPLE, activestyle='dotbox', font=(MAIN_FONT_NAME, f\"{FONT_SIZE_1}\"), background='#070708', exportselection=0, relief=tk.SOLID, borderwidth=0)\r\n        self.ensemble_listbox_scroll = ttk.Scrollbar(self.options_Frame, orient=tk.VERTICAL)\r\n        self.ensemble_listbox_Option.config(yscrollcommand=self.ensemble_listbox_scroll.set)\r\n        self.ensemble_listbox_scroll.configure(command=self.ensemble_listbox_Option.yview)\r\n        self.ensemble_listbox_Option_place = lambda: (self.ensemble_listbox_Frame.place(x=ENSEMBLE_LISTBOX_FRAME_X, y=ENSEMBLE_LISTBOX_FRAME_Y, width=ENSEMBLE_LISTBOX_FRAME_WIDTH, height=ENSEMBLE_LISTBOX_FRAME_HEIGHT, relx=2/3, rely=6/11, relwidth=1/3, relheight=1/self.COL1_ROWS),\r\n                                                    self.ensemble_listbox_scroll.place(x=ENSEMBLE_LISTBOX_SCROLL_X, y=ENSEMBLE_LISTBOX_SCROLL_Y, width=ENSEMBLE_LISTBOX_SCROLL_WIDTH, height=ENSEMBLE_LISTBOX_SCROLL_HEIGHT, relx=2/3, rely=6/11, relwidth=1/10, relheight=1/self.COL1_ROWS))\r\n        self.ensemble_listbox_Option_pack = lambda:self.ensemble_listbox_Option.pack(fill=tk.BOTH, expand=1)\r\n        self.help_hints(self.ensemble_listbox_Label, text=ENSEMBLE_LISTBOX_HELP)\r\n        \r\n        ### AUDIO TOOLS ###\r\n\r\n        # Chosen Audio Tool \r\n        self.chosen_audio_tool_Label = self.main_window_LABEL_SET(self.options_Frame, CHOOSE_AUDIO_TOOLS_MAIN_LABEL)\r\n        self.chosen_audio_tool_Label_place = lambda:self.chosen_audio_tool_Label.place(x=0, y=LOW_MENU_Y[0], width=LEFT_ROW_WIDTH, height=LABEL_HEIGHT, relx=0, rely=6/self.COL1_ROWS, relwidth=1/3, relheight=1/self.COL1_ROWS)\r\n        self.chosen_audio_tool_Option = ComboBoxMenu(self.options_Frame, textvariable=self.chosen_audio_tool_var, values=AUDIO_TOOL_OPTIONS, command=lambda e: self.update_main_widget_states())\r\n        self.chosen_audio_tool_Option_place = lambda:self.chosen_audio_tool_Option.place(x=0, y=LOW_MENU_Y[1], width=LEFT_ROW_WIDTH, height=OPTION_HEIGHT, relx=0, rely=7/self.COL1_ROWS, relwidth=1/3, relheight=1/self.COL1_ROWS)\r\n        self.help_hints(self.chosen_audio_tool_Label, text=AUDIO_TOOLS_HELP)\r\n        \r\n        # Choose Agorithim\r\n        self.choose_algorithm_Label = self.main_window_LABEL_SET(self.options_Frame, CHOOSE_MANUAL_ALGORITHM_MAIN_LABEL)\r\n        self.choose_algorithm_Label_place = lambda:self.choose_algorithm_Label.place(x=MAIN_ROW_X[0], y=MAIN_ROW_Y[0], width=0, height=LABEL_HEIGHT, relx=1/3, rely=2/self.COL1_ROWS, relwidth=1/3, relheight=1/self.COL2_ROWS)\r\n        self.choose_algorithm_Option = ComboBoxMenu(self.options_Frame, textvariable=self.choose_algorithm_var, values=MANUAL_ENSEMBLE_OPTIONS)\r\n        self.choose_algorithm_Option_place = lambda:self.choose_algorithm_Option.place(x=MAIN_ROW_X[1], y=MAIN_ROW_Y[1], width=MAIN_ROW_WIDTH, height=OPTION_HEIGHT, relx=1/3, rely=3/self.COL1_ROWS, relwidth=1/3, relheight=1/self.COL2_ROWS)\r\n        #self.help_hints(self.mdx_segment_size_Label, text=MDX_SEGMENT_SIZE_HELP)\r\n        \r\n        \r\n        # Time Stretch\r\n        self.time_stretch_rate_Label = self.main_window_LABEL_SET(self.options_Frame, CHOOSE_RATE_MAIN_LABEL)\r\n        self.time_stretch_rate_Label_place = lambda:self.time_stretch_rate_Label.place(x=MAIN_ROW_X[0], y=MAIN_ROW_Y[0], width=0, height=LABEL_HEIGHT, relx=1/3, rely=2/self.COL1_ROWS, relwidth=1/3, relheight=1/self.COL2_ROWS)\r\n        self.time_stretch_rate_Option = ComboBoxEditableMenu(self.options_Frame, values=TIME_PITCH, textvariable=self.time_stretch_rate_var, pattern=REG_TIME, default=TIME_PITCH)#\r\n        self.time_stretch_rate_Option_place = lambda:self.time_stretch_rate_Option.place(x=MAIN_ROW_X[1], y=MAIN_ROW_Y[1], width=MAIN_ROW_WIDTH, height=OPTION_HEIGHT, relx=1/3, rely=3/self.COL1_ROWS, relwidth=1/3, relheight=1/self.COL2_ROWS)\r\n        #self.help_hints(self.mdx_segment_size_Label, text=MDX_SEGMENT_SIZE_HELP)\r\n\r\n        # Pitch Rate\r\n        self.pitch_rate_Label = self.main_window_LABEL_SET(self.options_Frame, CHOOSE_SEMITONES_MAIN_LABEL)\r\n        self.pitch_rate_Label_place = lambda:self.pitch_rate_Label.place(x=MAIN_ROW_X[0], y=MAIN_ROW_Y[0], width=0, height=LABEL_HEIGHT, relx=1/3, rely=2/self.COL1_ROWS, relwidth=1/3, relheight=1/self.COL2_ROWS)\r\n        self.pitch_rate_Option = ComboBoxEditableMenu(self.options_Frame, values=TIME_PITCH, textvariable=self.pitch_rate_var, pattern=REG_PITCH, default=TIME_PITCH)#\r\n        self.pitch_rate_Option_place = lambda:self.pitch_rate_Option.place(x=MAIN_ROW_X[1], y=MAIN_ROW_Y[1], width=MAIN_ROW_WIDTH, height=OPTION_HEIGHT, relx=1/3, rely=3/self.COL1_ROWS, relwidth=1/3, relheight=1/self.COL2_ROWS)\r\n\r\n        # Is Time Correction\r\n        self.is_time_correction_Option = ttk.Checkbutton(master=self.options_Frame, text=TIME_CORRECTION_TEXT, variable=self.is_time_correction_var)\r\n        self.is_time_correction_Option_place = lambda:self.is_time_correction_Option.place(x=CHECK_BOX_X, y=CHECK_BOX_Y, width=CHECK_BOX_WIDTH, height=CHECK_BOX_HEIGHT, relx=1/3, rely=5/self.COL2_ROWS, relwidth=1/3, relheight=1/self.COL2_ROWS)\r\n        self.help_hints(self.is_time_correction_Option, text=IS_TIME_CORRECTION_HELP)\r\n        \r\n        # Is Wav Ensemble\r\n        self.is_wav_ensemble_Option = ttk.Checkbutton(master=self.options_Frame, text=ENSEMBLE_WAVFORMS_TEXT, variable=self.is_wav_ensemble_var)\r\n        self.is_wav_ensemble_Option_place = lambda:self.is_wav_ensemble_Option.place(x=CHECK_BOX_X, y=CHECK_BOX_Y, width=CHECK_BOX_WIDTH, height=CHECK_BOX_HEIGHT, relx=1/3, rely=5/self.COL2_ROWS, relwidth=1/3, relheight=1/self.COL2_ROWS)\r\n        self.help_hints(self.is_wav_ensemble_Option, text=IS_WAV_ENSEMBLE_HELP)\r\n\r\n        ## ALIGN TOOL ##\r\n        \r\n        # Track 1\r\n        self.fileOne_Label = self.main_window_LABEL_SUB_SET(self.options_Frame, self.file_one_sub_var)\r\n        self.fileOne_Label_place = lambda: self.fileOne_Label.place(x=FILEONE_LABEL_X, y=LABEL_Y, width=FILEONE_LABEL_WIDTH, height=LABEL_HEIGHT, relx=1/3, rely=2/self.COL1_ROWS, relwidth=1/3, relheight=1/self.COL2_ROWS)\r\n\r\n        self.fileOne_Entry = ttk.Entry(master=self.options_Frame, textvariable=self.fileOneEntry_var, font=self.font_entry, state=tk.DISABLED)\r\n        self.fileOne_Entry_place = lambda: self.fileOne_Entry.place(x=SUB_ENT_ROW_X, y=ENTRY_Y, width=ENTRY_WIDTH, height=OPTION_HEIGHT, relx=1/3, rely=3/self.COL1_ROWS, relwidth=1/3, relheight=1/self.COL2_ROWS)\r\n        self.help_hints(self.fileOne_Entry, text=INPUT_SEC_FIELDS_HELP)\r\n        self.fileOne_Entry.configure(cursor=\"hand2\")\r\n        \r\n        self.fileOne_Open = ttk.Button(master=self.options_Frame, image=self.efile_img, command=lambda:OPEN_FILE_func(os.path.dirname(self.fileOneEntry_Full_var.get())))\r\n        self.fileOne_Open_place = lambda:self.fileOne_Open.place(x=ENTRY_OPEN_BUTT_X_OFF, y=ENTRY_Y, width=ENTRY_OPEN_BUTT_WIDTH, height=OPTION_HEIGHT, relx=1/3, rely=3/self.COL1_ROWS, relwidth=1/3, relheight=1/self.COL2_ROWS)#OPEN_FILE_func(Path(self.export_path_var.get())) if os.path.isdir(self.export_path_var.get()) else self.error_dialoge(INVALID_EXPORT))\r\n        self.help_hints(self.fileOne_Open, text=INPUT_FOLDER_BUTTON_HELP)\r\n\r\n        # Track 2\r\n        self.fileTwo_Label = self.main_window_LABEL_SUB_SET(self.options_Frame, self.file_two_sub_var)\r\n        self.fileTwo_Label_place = lambda: self.fileTwo_Label.place(x=FILETWO_LABEL_X, y=LABEL_Y, width=FILETWO_LABEL_WIDTH, height=LABEL_HEIGHT, relx=1/3, rely=4.5/self.COL1_ROWS, relwidth=1/3, relheight=1/self.COL2_ROWS)\r\n\r\n        self.fileTwo_Entry = ttk.Entry(master=self.options_Frame, textvariable=self.fileTwoEntry_var, font=self.font_entry, state=tk.DISABLED)\r\n        self.fileTwo_Entry_place = lambda:self.fileTwo_Entry.place(x=SUB_ENT_ROW_X, y=ENTRY_Y, width=ENTRY_WIDTH, height=OPTION_HEIGHT, relx=1/3, rely=5.5/self.COL1_ROWS, relwidth=1/3, relheight=1/self.COL2_ROWS)\r\n        self.help_hints(self.fileTwo_Entry, text=INPUT_SEC_FIELDS_HELP)\r\n        self.fileTwo_Entry.configure(cursor=\"hand2\")\r\n        \r\n        self.fileTwo_Open = ttk.Button(master=self.options_Frame, image=self.efile_img, command=lambda:OPEN_FILE_func(os.path.dirname(self.fileTwoEntry_Full_var.get())))\r\n        self.fileTwo_Open_place = lambda:self.fileTwo_Open.place(x=ENTRY_OPEN_BUTT_X_OFF, y=ENTRY_Y, width=ENTRY_OPEN_BUTT_WIDTH, height=OPTION_HEIGHT, relx=1/3, rely=5.5/self.COL1_ROWS, relwidth=1/3, relheight=1/self.COL2_ROWS)\r\n        self.help_hints(self.fileTwo_Open, text=INPUT_FOLDER_BUTTON_HELP)\r\n\r\n        # Time Window\r\n        self.time_window_Label = self.main_window_LABEL_SET(self.options_Frame, TIME_WINDOW_MAIN_LABEL)\r\n        self.time_window_Label_place = lambda: self.time_window_Label.place(x=TIME_WINDOW_LABEL_X, y=LABEL_Y, width=TIME_WINDOW_LABEL_WIDTH, height=LABEL_HEIGHT, relx=1/3, rely=7.37/self.COL1_ROWS, relwidth=1/3, relheight=1/self.COL2_ROWS)\r\n        self.time_window_Option = ComboBoxMenu(self.options_Frame, textvariable=self.time_window_var, values=tuple(TIME_WINDOW_MAPPER.keys()))\r\n        self.time_window_Option_place = lambda: self.time_window_Option.place(x=SUB_ENT_ROW_X, y=ENTRY_Y, width=OPTION_WIDTH, height=OPTION_HEIGHT, relx=1/3, rely=8.37/self.COL1_ROWS, relwidth=1/3, relheight=1/self.COL2_ROWS)\r\n        self.help_hints(self.time_window_Label, text=TIME_WINDOW_ALIGN_HELP)\r\n\r\n        # Align Shifts\r\n        self.intro_analysis_Label = self.main_window_LABEL_SET(self.options_Frame, INTRO_ANALYSIS_MAIN_LABEL)\r\n        self.intro_analysis_Label_place = lambda: self.intro_analysis_Label.place(x=INTRO_ANALYSIS_LABEL_X, y=LABEL_Y, width=INTRO_ANALYSIS_LABEL_WIDTH, height=LABEL_HEIGHT, relx=2/3, rely=7.37/self.COL1_ROWS, relwidth=1/3, relheight=1/self.COL2_ROWS)\r\n        self.intro_analysis_Option = ComboBoxMenu(self.options_Frame, textvariable=self.intro_analysis_var, values=tuple(INTRO_MAPPER.keys()))\r\n        self.intro_analysis_Option_place = lambda: self.intro_analysis_Option.place(x=INTRO_ANALYSIS_OPTION_X, y=ENTRY_Y, width=OPTION_WIDTH, height=OPTION_HEIGHT, relx=2/3, rely=8.37/self.COL1_ROWS, relwidth=1/3, relheight=1/self.COL2_ROWS)\r\n        self.help_hints(self.intro_analysis_Label, text=INTRO_ANALYSIS_ALIGN_HELP)\r\n\r\n        # Volume Adjustment\r\n        self.db_analysis_Label = self.main_window_LABEL_SET(self.options_Frame, VOLUME_ADJUSTMENT_MAIN_LABEL)\r\n        self.db_analysis_Label_place = lambda: self.db_analysis_Label.place(x=DB_ANALYSIS_LABEL_X, y=LABEL_Y, width=DB_ANALYSIS_LABEL_WIDTH, height=LABEL_HEIGHT, relx=2/3, rely=7.37/self.COL1_ROWS, relwidth=1/3, relheight=1/self.COL2_ROWS)\r\n        self.db_analysis_Option = ComboBoxMenu(self.options_Frame, textvariable=self.db_analysis_var, values=tuple(VOLUME_MAPPER.keys()))\r\n        self.db_analysis_Option_place = lambda: self.db_analysis_Option.place(x=DB_ANALYSIS_OPTION_X, y=ENTRY_Y, width=OPTION_WIDTH, height=OPTION_HEIGHT, relx=2/3, rely=8.37/self.COL1_ROWS, relwidth=1/3, relheight=1/self.COL2_ROWS)\r\n        self.help_hints(self.db_analysis_Label, text=VOLUME_ANALYSIS_ALIGN_HELP)\r\n\r\n        # Wav-Type\r\n        self.wav_type_set_Label = self.main_window_LABEL_SET(self.options_Frame, WAVE_TYPE_TEXT)\r\n        self.wav_type_set_Label_place = lambda: self.wav_type_set_Label.place(x=WAV_TYPE_SET_LABEL_X, y=LABEL_Y, width=WAV_TYPE_SET_LABEL_WIDTH, height=LABEL_HEIGHT, relx=1/3, rely=7.37/self.COL1_ROWS, relwidth=1/3, relheight=1/self.COL2_ROWS)\r\n        self.wav_type_set_Option = ComboBoxMenu(self.options_Frame, textvariable=self.wav_type_set_var, values=WAV_TYPE)\r\n        self.wav_type_set_Option_place = lambda: self.wav_type_set_Option.place(x=SUB_ENT_ROW_X, y=ENTRY_Y, width=OPTION_WIDTH, height=OPTION_HEIGHT, relx=1/3, rely=8.37/self.COL1_ROWS, relwidth=1/3, relheight=1/self.COL2_ROWS)\r\n\r\n        ### SHARED SETTINGS ###\r\n        \r\n        # GPU Selection\r\n        self.is_gpu_conversion_Option = ttk.Checkbutton(master=self.options_Frame, text=GPU_CONVERSION_MAIN_LABEL, variable=self.is_gpu_conversion_var)\r\n        self.is_gpu_conversion_Option_place = lambda:self.is_gpu_conversion_Option.place(x=CHECK_BOX_X, y=CHECK_BOX_Y, width=CHECK_BOX_WIDTH, height=CHECK_BOX_HEIGHT, relx=1/3, rely=5/self.COL2_ROWS, relwidth=1/3, relheight=1/self.COL2_ROWS)\r\n        self.is_gpu_conversion_Disable = lambda:(self.is_gpu_conversion_Option.configure(state=tk.DISABLED), self.is_gpu_conversion_var.set(False))\r\n        self.is_gpu_conversion_Enable = lambda:self.is_gpu_conversion_Option.configure(state=tk.NORMAL)\r\n        self.help_hints(self.is_gpu_conversion_Option, text=IS_GPU_CONVERSION_HELP)\r\n\r\n        # Vocal Only\r\n        self.is_primary_stem_only_Option = ttk.Checkbutton(master=self.options_Frame, textvariable=self.is_primary_stem_only_Text_var, variable=self.is_primary_stem_only_var, command=lambda:self.is_primary_stem_only_Option_toggle())\r\n        self.is_primary_stem_only_Option_place = lambda:self.is_primary_stem_only_Option.place(x=CHECK_BOX_X, y=CHECK_BOX_Y, width=CHECK_BOX_WIDTH, height=CHECK_BOX_HEIGHT, relx=1/3, rely=6/self.COL2_ROWS, relwidth=1/3, relheight=1/self.COL2_ROWS)\r\n        self.is_primary_stem_only_Option_toggle = lambda:self.is_secondary_stem_only_var.set(False) if self.is_primary_stem_only_var.get() else self.is_secondary_stem_only_Option.configure(state=tk.NORMAL)\r\n        self.help_hints(self.is_primary_stem_only_Option, text=SAVE_STEM_ONLY_HELP)\r\n        \r\n        # Instrumental Only \r\n        self.is_secondary_stem_only_Option = ttk.Checkbutton(master=self.options_Frame, textvariable=self.is_secondary_stem_only_Text_var, variable=self.is_secondary_stem_only_var, command=lambda:self.is_secondary_stem_only_Option_toggle())\r\n        self.is_secondary_stem_only_Option_place = lambda:self.is_secondary_stem_only_Option.place(x=CHECK_BOX_X, y=CHECK_BOX_Y, width=CHECK_BOX_WIDTH, height=CHECK_BOX_HEIGHT, relx=1/3, rely=7/self.COL2_ROWS, relwidth=1/3, relheight=1/self.COL2_ROWS)\r\n        self.is_secondary_stem_only_Option_toggle = lambda:self.is_primary_stem_only_var.set(False) if self.is_secondary_stem_only_var.get() else self.is_primary_stem_only_Option.configure(state=tk.NORMAL)\r\n        self.is_stem_only_Options_Enable = lambda:(self.is_primary_stem_only_Option.configure(state=tk.NORMAL), self.is_secondary_stem_only_Option.configure(state=tk.NORMAL))\r\n        self.help_hints(self.is_secondary_stem_only_Option, text=SAVE_STEM_ONLY_HELP)\r\n        \r\n        # Sample Mode\r\n        self.model_sample_mode_Option = ttk.Checkbutton(master=self.options_Frame, textvariable=self.model_sample_mode_duration_checkbox_var, variable=self.model_sample_mode_var)#f'Sample ({self.model_sample_mode_duration_var.get()} Seconds)'\r\n        self.model_sample_mode_Option_place = lambda rely=8:self.model_sample_mode_Option.place(x=CHECK_BOX_X, y=CHECK_BOX_Y, width=CHECK_BOX_WIDTH, height=CHECK_BOX_HEIGHT, relx=1/3, rely=rely/self.COL2_ROWS, relwidth=1/3, relheight=1/self.COL2_ROWS)\r\n        self.help_hints(self.model_sample_mode_Option, text=MODEL_SAMPLE_MODE_HELP)\r\n        \r\n        self.GUI_LIST = (self.vr_model_Label,\r\n        self.vr_model_Option,\r\n        self.aggression_setting_Label,\r\n        self.aggression_setting_Option,\r\n        self.window_size_Label,\r\n        self.window_size_Option,\r\n        self.demucs_model_Label,\r\n        self.demucs_model_Option,\r\n        self.demucs_stems_Label,\r\n        self.demucs_stems_Option,\r\n        self.segment_Label,\r\n        self.segment_Option,\r\n        self.mdx_net_model_Label,\r\n        self.mdx_net_model_Option,\r\n        self.overlap_mdx_Label,\r\n        self.overlap_mdx_Option,\r\n        self.overlap_mdx23_Option,\r\n        self.mdxnet_stems_Label,\r\n        self.mdxnet_stems_Option,\r\n        self.mdx_segment_size_Label,\r\n        self.mdx_segment_size_Option,\r\n        self.chosen_ensemble_Label,\r\n        self.chosen_ensemble_Option,\r\n        self.save_current_settings_Label,\r\n        self.save_current_settings_Option,\r\n        self.ensemble_main_stem_Label,\r\n        self.ensemble_main_stem_Option,\r\n        self.ensemble_type_Label,\r\n        self.ensemble_type_Option,\r\n        self.ensemble_listbox_Label,\r\n        self.ensemble_listbox_Frame,\r\n        self.ensemble_listbox_Option,\r\n        self.ensemble_listbox_scroll,\r\n        self.chosen_audio_tool_Label,\r\n        self.chosen_audio_tool_Option,\r\n        self.choose_algorithm_Label,\r\n        self.choose_algorithm_Option,\r\n        self.time_stretch_rate_Label,\r\n        self.time_stretch_rate_Option,\r\n        self.wav_type_set_Label,\r\n        self.wav_type_set_Option,\r\n        self.pitch_rate_Label,\r\n        self.pitch_rate_Option,\r\n        self.fileOne_Label,\r\n        self.fileOne_Entry,\r\n        self.fileOne_Open,\r\n        self.fileTwo_Label,\r\n        self.fileTwo_Entry,\r\n        self.fileTwo_Open,\r\n        self.intro_analysis_Label,\r\n        self.intro_analysis_Option,\r\n        self.time_window_Label,\r\n        self.time_window_Option,\r\n        self.db_analysis_Label,\r\n        self.db_analysis_Option,\r\n        self.is_gpu_conversion_Option,\r\n        self.is_primary_stem_only_Option,\r\n        self.is_secondary_stem_only_Option,\r\n        self.is_primary_stem_only_Demucs_Option,\r\n        self.is_secondary_stem_only_Demucs_Option,\r\n        self.model_sample_mode_Option,\r\n        self.is_time_correction_Option,\r\n        self.is_wav_ensemble_Option)\r\n        \r\n        REFRESH_VARS = (self.mdx_net_model_var,\r\n                        self.vr_model_var,\r\n                        self.demucs_model_var,\r\n                        # self.demucs_stems_var,\r\n                        # self.mdxnet_stems_var,\r\n                        self.is_chunk_demucs_var,\r\n                        self.is_chunk_mdxnet_var,\r\n                        # self.is_primary_stem_only_Demucs_var,\r\n                        # self.is_secondary_stem_only_Demucs_var,\r\n                        # self.is_primary_stem_only_var,\r\n                        # self.is_secondary_stem_only_var,\r\n                        self.model_download_demucs_var,\r\n                        self.model_download_mdx_var,\r\n                        self.model_download_vr_var,\r\n                        self.select_download_var,\r\n                        # self.is_primary_stem_only_Demucs_Text_var,\r\n                        # self.is_secondary_stem_only_Demucs_Text_var,\r\n                        self.chosen_process_method_var,\r\n                        self.ensemble_main_stem_var)\r\n        \r\n        # Change States\r\n        for var in REFRESH_VARS:\r\n            var.trace_add('write', lambda *args: self.update_button_states())\r\n    \r\n    def combo_box_selection_clear(self, frame:tk.Frame):\r\n        for option in frame.winfo_children():\r\n            if type(option) is ttk.Combobox or type(option) is ComboBoxEditableMenu:\r\n                option.selection_clear()\r\n\r\n    def focus_out_widgets(self, all_widgets, frame):\r\n        for option in all_widgets:\r\n            if not type(option) is ComboBoxEditableMenu:\r\n                option.bind('<Button-1>', lambda e:(option.focus(), self.combo_box_selection_clear(frame)))\r\n\r\n    def bind_widgets(self):\r\n        \"\"\"Bind widgets to the drag & drop mechanic\"\"\"\r\n        \r\n        self.chosen_audio_tool_align = tk.BooleanVar(value=True)        \r\n        other_items = [self.options_Frame, self.filePaths_Frame, self.title_Label, self.progressbar, self.conversion_Button, self.settings_Button, self.stop_Button, self.command_Text]\r\n        all_widgets = self.options_Frame.winfo_children() + self.filePaths_Frame.winfo_children() + other_items\r\n        self.focus_out_widgets(all_widgets, self.options_Frame)\r\n        \r\n        if is_dnd_compatible:\r\n            self.filePaths_saveTo_Button.drop_target_register(DND_FILES)\r\n            self.filePaths_saveTo_Entry.drop_target_register(DND_FILES)\r\n            self.drop_target_register(DND_FILES)\r\n            self.dnd_bind('<<Drop>>', lambda e: drop(e, accept_mode='files'))\r\n            self.filePaths_saveTo_Button.dnd_bind('<<Drop>>', lambda e: drop(e, accept_mode='folder'))\r\n            self.filePaths_saveTo_Entry.dnd_bind('<<Drop>>', lambda e: drop(e, accept_mode='folder'))    \r\n            \r\n            self.fileOne_Entry.drop_target_register(DND_FILES)\r\n            self.fileTwo_Entry.drop_target_register(DND_FILES)\r\n            self.fileOne_Entry.dnd_bind('<<Drop>>', lambda e: drop(e, accept_mode=FILE_1))\r\n            self.fileTwo_Entry.dnd_bind('<<Drop>>', lambda e: drop(e, accept_mode=FILE_2))    \r\n            \r\n        self.ensemble_listbox_Option.bind('<<ListboxSelect>>', lambda e: self.chosen_ensemble_var.set(CHOOSE_ENSEMBLE_OPTION))\r\n        self.options_Frame.bind(right_click_button, lambda e:(self.right_click_menu_popup(e, main_menu=True), self.options_Frame.focus()))\r\n        self.filePaths_musicFile_Entry.bind(right_click_button, lambda e:(self.input_right_click_menu(e), self.filePaths_musicFile_Entry.focus()))\r\n        self.filePaths_musicFile_Entry.bind('<Button-1>', lambda e:(self.check_is_menu_open(INPUTS_MENU), self.filePaths_musicFile_Entry.focus()))\r\n\r\n        self.fileOne_Entry.bind('<Button-1>', lambda e:self.menu_batch_dual())\r\n        self.fileTwo_Entry.bind('<Button-1>', lambda e:self.menu_batch_dual())\r\n        self.fileOne_Entry.bind(right_click_button, lambda e:self.input_dual_right_click_menu(e, is_primary=True))\r\n        self.fileTwo_Entry.bind(right_click_button, lambda e:self.input_dual_right_click_menu(e, is_primary=False))\r\n        if not is_macos:\r\n            self.bind(\"<Configure>\", self.adjust_toplevel_positions)\r\n        \r\n    def auto_save(self):\r\n        try:\r\n            self.save_values(app_close=False, is_auto_save=True)\r\n        except Exception as e:\r\n            print(e)\r\n\r\n    #--Input/Export Methods--\r\n    \r\n    def linux_filebox_fix(self, is_on=True):\r\n        fg_color_set = '#575757' if is_on else \"#F6F6F7\"\r\n        style = ttk.Style(self)\r\n        style.configure('TButton', foreground='#F6F6F7')\r\n        style.configure('TCheckbutton', foreground='#F6F6F7')\r\n        style.configure('TCombobox', foreground='#F6F6F7')\r\n        style.configure('TEntry', foreground='#F6F6F7')\r\n        style.configure('TLabel', foreground='#F6F6F7')\r\n        style.configure('TMenubutton', foreground='#F6F6F7')\r\n        style.configure('TRadiobutton', foreground='#F6F6F7')\r\n        gui_data.sv_ttk.set_theme(\"dark\", MAIN_FONT_NAME, 10, fg_color_set=fg_color_set)\r\n\r\n    def show_file_dialog(self, text='Select Audio files', dialoge_type=None):\r\n        parent_win = root\r\n        is_linux = not is_windows and not is_macos\r\n        \r\n        if is_linux:\r\n            self.linux_filebox_fix()\r\n            top = tk.Toplevel(root)\r\n            top.withdraw()\r\n            top.protocol(\"WM_DELETE_WINDOW\", lambda: None)\r\n            parent_win = top\r\n        \r\n        if dialoge_type == MULTIPLE_FILE:\r\n            filenames = filedialog.askopenfilenames(parent=parent_win, \r\n                                                    title=text)\r\n        elif dialoge_type == MAIN_MULTIPLE_FILE:\r\n            filenames = filedialog.askopenfilenames(parent=parent_win, \r\n                                                    title=text,\r\n                                                    initialfile='',\r\n                                                    initialdir=self.lastDir)\r\n        elif dialoge_type == SINGLE_FILE:\r\n            filenames = filedialog.askopenfilename(parent=parent_win, \r\n                                                   title=text)\r\n        elif dialoge_type == CHOOSE_EXPORT_FIR:\r\n            filenames = filedialog.askdirectory(\r\n                                    parent=parent_win,\r\n                                    title=f'Select Folder',)\r\n            \r\n        if is_linux:\r\n            print(\"Is Linux\")\r\n            self.linux_filebox_fix(False)\r\n            top.destroy()\r\n            \r\n        return filenames\r\n\r\n    def input_select_filedialog(self):\r\n        \"\"\"Make user select music files\"\"\"\r\n\r\n        if self.lastDir is not None:\r\n            if not os.path.isdir(self.lastDir):\r\n                self.lastDir = None\r\n\r\n        paths = self.show_file_dialog(dialoge_type=MAIN_MULTIPLE_FILE)\r\n\r\n        if paths:  # Path selected\r\n            self.inputPaths = paths\r\n            \r\n            self.process_input_selections()\r\n            self.update_inputPaths()\r\n\r\n    def export_select_filedialog(self):\r\n        \"\"\"Make user select a folder to export the converted files in\"\"\"\r\n\r\n        export_path = None\r\n        \r\n        path = self.show_file_dialog(dialoge_type=CHOOSE_EXPORT_FIR)\r\n\r\n        if path:  # Path selected\r\n            self.export_path_var.set(path)\r\n            export_path = self.export_path_var.get()\r\n            \r\n        return export_path\r\n     \r\n    def update_inputPaths(self):\r\n        \"\"\"Update the music file entry\"\"\"\r\n        \r\n        if self.inputPaths:\r\n            if len(self.inputPaths) == 1:\r\n                text = self.inputPaths[0]\r\n            else:\r\n                count = len(self.inputPaths) - 1\r\n                file_text = 'file' if len(self.inputPaths) == 2 else 'files'\r\n                text = f\"{self.inputPaths[0]}, +{count} {file_text}\"\r\n        else:\r\n            # Empty Selection\r\n            text = ''\r\n            \r\n        self.inputPathsEntry_var.set(text)\r\n\r\n    def select_audiofile(self, path=None, is_primary=True): \r\n        \"\"\"Make user select music files\"\"\"\r\n            \r\n        vars = {\r\n            True: (self.fileOneEntry_Full_var, self.fileOneEntry_var, self.fileTwoEntry_Full_var, self.fileTwoEntry_var),\r\n            False: (self.fileTwoEntry_Full_var, self.fileTwoEntry_var, self.fileOneEntry_Full_var, self.fileOneEntry_var)\r\n        }\r\n\r\n        file_path_var, file_basename_var, file_path_2_var, file_basename_2_var = vars[is_primary]\r\n            \r\n        if not path:\r\n            path = self.show_file_dialog(text='Select Audio file', dialoge_type=SINGLE_FILE)\r\n\r\n        if path:  # Path selected\r\n            file_path_var.set(path)\r\n            file_basename_var.set(os.path.basename(path))\r\n            \r\n            if BATCH_MODE_DUAL in file_path_2_var.get():\r\n                file_path_2_var.set(\"\")\r\n                file_basename_2_var.set(\"\")\r\n\r\n            self.DualBatch_inputPaths = []\r\n            self.check_dual_paths()\r\n            \r\n    #--Utility Methods--\r\n\r\n    def restart(self):\r\n        \"\"\"Restart the application after asking for confirmation\"\"\"\r\n        \r\n        confirm = messagebox.askyesno(parent=root,\r\n                                         title=CONFIRM_RESTART_TEXT[0],\r\n                                         message=CONFIRM_RESTART_TEXT[1])\r\n        \r\n        if confirm:\r\n            self.save_values(app_close=True, is_restart=True)\r\n        \r\n    def delete_temps(self, is_start_up=False):  \r\n        \"\"\"Deletes temp files\"\"\"\r\n        \r\n        DIRECTORIES = (BASE_PATH, VR_MODELS_DIR, MDX_MODELS_DIR, DEMUCS_MODELS_DIR, DEMUCS_NEWER_REPO_DIR)\r\n        EXTENSIONS = (('.aes', '.txt', '.tmp'))\r\n        \r\n        try:\r\n            if os.path.isfile(f\"{current_patch}{application_extension}\"):\r\n                os.remove(f\"{current_patch}{application_extension}\")\r\n            \r\n            if not is_start_up:\r\n                if os.path.isfile(SPLASH_DOC):\r\n                    os.remove(SPLASH_DOC)\r\n            \r\n            for dir in DIRECTORIES:\r\n                for temp_file in os.listdir(dir):\r\n                    if temp_file.endswith(EXTENSIONS):\r\n                        if os.path.isfile(os.path.join(dir, temp_file)):\r\n                            os.remove(os.path.join(dir, temp_file))\r\n        except Exception as e:\r\n            self.error_log_var.set(error_text(TEMP_FILE_DELETION_TEXT, e))\r\n        \r\n    def get_files_from_dir(self, directory, ext, is_mdxnet=False):\r\n        \"\"\"Gets files from specified directory that ends with specified extention\"\"\"\r\n        \r\n        return tuple(\r\n            x if is_mdxnet and x.endswith(CKPT) else os.path.splitext(x)[0]\r\n            for x in os.listdir(directory)\r\n            if x.endswith(ext)\r\n        )\r\n        \r\n    def return_ensemble_stems(self, is_primary=False): \r\n        \"\"\"Grabs and returns the chosen ensemble stems.\"\"\"\r\n        \r\n        ensemble_stem = self.ensemble_main_stem_var.get().partition(\"/\")\r\n        \r\n        if is_primary:\r\n            return ensemble_stem[0]\r\n        else:\r\n            return ensemble_stem[0], ensemble_stem[2]\r\n\r\n    def message_box(self, message):\r\n        \"\"\"Template for confirmation box\"\"\"\r\n        \r\n        confirm = messagebox.askyesno(title=message[0],\r\n                                         message=message[1],\r\n                                         parent=root)\r\n        \r\n        return confirm\r\n\r\n    def error_dialoge(self, message):\r\n        \"\"\"Template for messagebox that informs user of error\"\"\"\r\n\r\n        messagebox.showerror(master=self,\r\n                                  title=message[0],\r\n                                  message=message[1],\r\n                                  parent=root) \r\n      \r\n    def model_list(self, primary_stem: str, secondary_stem: str, is_4_stem_check=False, is_multi_stem=False, is_dry_check=False, is_no_demucs=False, is_check_vocal_split=False):\r\n        \r\n        stem_check = self.assemble_model_data(arch_type=ENSEMBLE_STEM_CHECK, is_dry_check=is_dry_check)\r\n        \r\n        def matches_stem(model: ModelData):\r\n            primary_match = model.primary_stem in {primary_stem, secondary_stem}\r\n            mdx_stem_match = primary_stem in model.mdx_model_stems and model.mdx_stem_count <= 2\r\n            return primary_match or mdx_stem_match if is_no_demucs else primary_match or primary_stem in model.mdx_model_stems\r\n\r\n        result = []\r\n\r\n        for model in stem_check:\r\n            if is_multi_stem:\r\n                result.append(model.model_and_process_tag)\r\n            elif is_4_stem_check and (model.demucs_stem_count == 4 or model.mdx_stem_count == 4):\r\n                result.append(model.model_and_process_tag)\r\n            elif matches_stem(model) or (not is_no_demucs and primary_stem.lower() in model.demucs_source_list):\r\n                if is_check_vocal_split:\r\n                    model_name = None if model.is_karaoke or not model.vocal_split_model else model.model_basename\r\n                else: \r\n                    model_name = model.model_and_process_tag\r\n                    \r\n                result.append(model_name)\r\n\r\n        return result\r\n\r\n    def help_hints(self, widget, text):\r\n        toolTip = ToolTip(widget)\r\n        def enter(event):\r\n            if self.help_hints_var.get():\r\n                toolTip.showtip(text)\r\n        def leave(event):\r\n            toolTip.hidetip()\r\n        widget.bind('<Enter>', enter)\r\n        widget.bind('<Leave>', leave)\r\n        widget.bind(right_click_button, lambda e:copy_help_hint(e))\r\n\r\n        def copy_help_hint(event):\r\n            if self.help_hints_var.get():\r\n                right_click_menu = tk.Menu(self, font=(MAIN_FONT_NAME, FONT_SIZE_1), tearoff=0)\r\n                right_click_menu.add_command(label='Copy Help Hint Text', command=right_click_menu_copy_hint)\r\n                \r\n                try:\r\n                    right_click_menu.tk_popup(event.x_root,event.y_root)\r\n                    right_click_release_linux(right_click_menu)\r\n                finally:\r\n                    right_click_menu.grab_release()\r\n            else:\r\n                if widget.winfo_toplevel() == root:\r\n                    self.right_click_menu_popup(event, main_menu=True)\r\n\r\n        def right_click_menu_copy_hint():\r\n            pyperclip.copy(text)\r\n\r\n    def check_is_menu_open(self, menu):\r\n        try:\r\n            menu_mapping = {\r\n                VR_OPTION: (self.is_open_menu_advanced_vr_options, self.menu_advanced_vr_options, self.menu_advanced_vr_options_close_window),\r\n                DEMUCS_OPTION: (self.is_open_menu_advanced_demucs_options, self.menu_advanced_demucs_options, self.menu_advanced_demucs_options_close_window),\r\n                MDX_OPTION: (self.is_open_menu_advanced_mdx_options, self.menu_advanced_mdx_options, self.menu_advanced_mdx_options_close_window),\r\n                ENSEMBLE_OPTION: (self.is_open_menu_advanced_ensemble_options, self.menu_advanced_ensemble_options, self.menu_advanced_ensemble_options_close_window),\r\n                HELP_OPTION: (self.is_open_menu_help, self.menu_help, self.menu_help_close_window),\r\n                ERROR_OPTION: (self.is_open_menu_error_log, self.menu_error_log, self.menu_error_log_close_window),\r\n                INPUTS_MENU: (self.is_open_menu_view_inputs, self.menu_view_inputs, self.menu_view_inputs_close_window),\r\n                ALIGNMENT_TOOL: (self.is_open_menu_advanced_align_options, self.menu_advanced_align_options, self.menu_advanced_align_options_close_window)\r\n            }\r\n\r\n            is_open, open_method, close_method = menu_mapping.get(menu, (None, None, None))\r\n            if is_open and is_open.get():\r\n                close_method()\r\n            open_method()\r\n        except Exception as e:\r\n            self.error_log_var.set(\"{}\".format(error_text(menu, e)))\r\n\r\n    def input_right_click_menu(self, event):\r\n\r\n        right_click_menu = tk.Menu(self, font=(MAIN_FONT_NAME, FONT_SIZE_1), tearoff=0)\r\n        right_click_menu.add_command(label='See All Inputs', command=lambda:self.check_is_menu_open(INPUTS_MENU))\r\n        \r\n        try:\r\n            right_click_menu.tk_popup(event.x_root,event.y_root)\r\n            right_click_release_linux(right_click_menu)\r\n        finally:\r\n            right_click_menu.grab_release()\r\n\r\n    def input_dual_right_click_menu(self, event, is_primary:bool):\r\n        input_path = self.fileOneEntry_Full_var.get() if is_primary else self.fileTwoEntry_Full_var.get()\r\n        right_click_menu = tk.Menu(self, font=(MAIN_FONT_NAME, FONT_SIZE_1), tearoff=0)\r\n        right_click_menu.add_command(label=CHOOSE_INPUT_TEXT, command=lambda:self.select_audiofile(is_primary=is_primary))\r\n        if input_path and os.path.isdir(os.path.dirname(input_path)):\r\n            right_click_menu.add_command(label=OPEN_INPUT_DIR_TEXT, command=lambda:OPEN_FILE_func(os.path.dirname(input_path)))\r\n        right_click_menu.add_command(label=BATCH_PROCESS_MENU_TEXT, command=self.menu_batch_dual)\r\n        \r\n        try:\r\n            right_click_menu.tk_popup(event.x_root,event.y_root)\r\n            right_click_release_linux(right_click_menu)\r\n        finally:\r\n            right_click_menu.grab_release()\r\n\r\n    def cached_sources_clear(self):\r\n\r\n        self.vr_cache_source_mapper = {}\r\n        self.mdx_cache_source_mapper = {}\r\n        self.demucs_cache_source_mapper = {}\r\n\r\n    def cached_source_callback(self, process_method, model_name=None):\r\n        \r\n        model, sources = None, None\r\n        \r\n        if process_method == VR_ARCH_TYPE:\r\n            mapper = self.vr_cache_source_mapper\r\n        if process_method == MDX_ARCH_TYPE:\r\n            mapper = self.mdx_cache_source_mapper\r\n        if process_method == DEMUCS_ARCH_TYPE:\r\n            mapper = self.demucs_cache_source_mapper\r\n        \r\n        for key, value in mapper.items():\r\n            if model_name in key:\r\n                model = key\r\n                sources = value\r\n        \r\n        return model, sources\r\n\r\n    def cached_model_source_holder(self, process_method, sources, model_name=None):\r\n        \r\n        if process_method == VR_ARCH_TYPE:\r\n            self.vr_cache_source_mapper = {**self.vr_cache_source_mapper, **{model_name: sources}}\r\n        if process_method == MDX_ARCH_TYPE:\r\n            self.mdx_cache_source_mapper = {**self.mdx_cache_source_mapper, **{model_name: sources}}\r\n        if process_method == DEMUCS_ARCH_TYPE:\r\n            self.demucs_cache_source_mapper = {**self.demucs_cache_source_mapper, **{model_name: sources}}\r\n  \r\n    def cached_source_model_list_check(self, model_list: List[ModelData]):\r\n\r\n        model: ModelData\r\n        primary_model_names = lambda process_method:[model.model_basename if model.process_method == process_method else None for model in model_list]\r\n        secondary_model_names = lambda process_method:[model.secondary_model.model_basename if model.is_secondary_model_activated and model.process_method == process_method else None for model in model_list]\r\n\r\n        self.vr_primary_model_names = primary_model_names(VR_ARCH_TYPE)\r\n        self.mdx_primary_model_names = primary_model_names(MDX_ARCH_TYPE)\r\n        self.demucs_primary_model_names = primary_model_names(DEMUCS_ARCH_TYPE)\r\n        self.vr_secondary_model_names = secondary_model_names(VR_ARCH_TYPE)\r\n        self.mdx_secondary_model_names = secondary_model_names(MDX_ARCH_TYPE)\r\n        self.demucs_secondary_model_names = [model.secondary_model.model_basename if model.is_secondary_model_activated and model.process_method == DEMUCS_ARCH_TYPE and not model.secondary_model is None else None for model in model_list]\r\n        self.demucs_pre_proc_model_name = [model.pre_proc_model.model_basename if model.pre_proc_model else None for model in model_list]#list(dict.fromkeys())\r\n        \r\n        for model in model_list:\r\n            if model.process_method == DEMUCS_ARCH_TYPE and model.is_demucs_4_stem_secondaries:\r\n                if not model.is_4_stem_ensemble:\r\n                    self.demucs_secondary_model_names = model.secondary_model_4_stem_model_names_list\r\n                    break\r\n                else:\r\n                    for i in model.secondary_model_4_stem_model_names_list:\r\n                        self.demucs_secondary_model_names.append(i)\r\n        \r\n        self.all_models = self.vr_primary_model_names + self.mdx_primary_model_names + self.demucs_primary_model_names + self.vr_secondary_model_names + self.mdx_secondary_model_names + self.demucs_secondary_model_names + self.demucs_pre_proc_model_name\r\n      \r\n    def verify_audio(self, audio_file, is_process=True, sample_path=None):\r\n        is_good = False\r\n        error_data = ''\r\n        \r\n        if not type(audio_file) is tuple:\r\n            audio_file = [audio_file]\r\n\r\n        for i in audio_file:\r\n            if os.path.isfile(i):\r\n                try:\r\n                    librosa.load(i, duration=3, mono=False, sr=44100) if not type(sample_path) is str else self.create_sample(i, sample_path)\r\n                    is_good = True\r\n                except Exception as e:\r\n                    error_name = f'{type(e).__name__}'\r\n                    traceback_text = ''.join(traceback.format_tb(e.__traceback__))\r\n                    message = f'{error_name}: \"{e}\"\\n{traceback_text}\"'\r\n                    if is_process:\r\n                        audio_base_name = os.path.basename(i)\r\n                        self.error_log_var.set(f'{ERROR_LOADING_FILE_TEXT[0]}:\\n\\n\\\"{audio_base_name}\\\"\\n\\n{ERROR_LOADING_FILE_TEXT[1]}:\\n\\n{message}')\r\n                    else:\r\n                        error_data = AUDIO_VERIFICATION_CHECK(i, message)\r\n\r\n        if is_process:\r\n            return is_good\r\n        else:\r\n            return is_good, error_data\r\n      \r\n    def create_sample(self, audio_file, sample_path=SAMPLE_CLIP_PATH):\r\n        try:\r\n            with audioread.audio_open(audio_file) as f:\r\n                track_length = int(f.duration)\r\n        except Exception as e:\r\n            print('Audioread failed to get duration. Trying Librosa...')\r\n            y, sr = librosa.load(audio_file, mono=False, sr=44100)\r\n            track_length = int(librosa.get_duration(y=y, sr=sr))\r\n        \r\n        clip_duration = int(self.model_sample_mode_duration_var.get())\r\n        \r\n        if track_length >= clip_duration:\r\n            offset_cut = track_length//3\r\n            off_cut = offset_cut + track_length\r\n            if not off_cut >= clip_duration:\r\n                offset_cut = 0\r\n            name_apped = f'{clip_duration}_second_'\r\n        else:\r\n            offset_cut, clip_duration = 0, track_length\r\n            name_apped = ''\r\n\r\n        sample = librosa.load(audio_file, offset=offset_cut, duration=clip_duration, mono=False, sr=44100)[0].T\r\n        audio_sample = os.path.join(sample_path, f'{os.path.splitext(os.path.basename(audio_file))[0]}_{name_apped}sample.wav')\r\n        sf.write(audio_sample, sample, 44100)\r\n        \r\n        return audio_sample\r\n\r\n    #--Right Click Menu Pop-Ups--\r\n\r\n    def right_click_select_settings_sub(self, parent_menu, process_method):\r\n        saved_settings_sub_menu = tk.Menu(parent_menu, font=(MAIN_FONT_NAME, FONT_SIZE_1), tearoff=False)\r\n        settings_options = self.last_found_settings + tuple(SAVE_SET_OPTIONS)\r\n        \r\n        for settings_options in settings_options:\r\n            settings_options = settings_options.replace(\"_\", \" \")\r\n            saved_settings_sub_menu.add_command(label=settings_options, command=lambda o=settings_options:self.selection_action_saved_settings(o, process_method=process_method))\r\n\r\n        saved_settings_sub_menu.insert_separator(len(self.last_found_settings))\r\n        \r\n        return saved_settings_sub_menu\r\n\r\n    def right_click_menu_popup(self, event, text_box=False, main_menu=False):\r\n        \r\n        def add_text_edit_options(menu):\r\n            \"\"\"Add options related to text editing.\"\"\"\r\n            menu.add_command(label='Copy', command=self.right_click_menu_copy)\r\n            menu.add_command(label='Paste', command=lambda: self.right_click_menu_paste(text_box=text_box))\r\n            menu.add_command(label='Delete', command=lambda: self.right_click_menu_delete(text_box=text_box))\r\n        \r\n        def add_advanced_settings_options(menu, settings_mapper, var_mapper):\r\n            \"\"\"Add advanced settings options to the menu.\"\"\"\r\n            current_method = self.chosen_process_method_var.get()\r\n            \r\n            if current_method in settings_mapper and (var_mapper[current_method] or (current_method == DEMUCS_ARCH_TYPE and self.is_demucs_pre_proc_model_activate_var.get())):\r\n                menu.add_cascade(label='Select Saved Settings', menu=saved_settings_sub_load_for_menu)\r\n                menu.add_separator()\r\n                for method, option in settings_mapper.items():\r\n                    if method != ENSEMBLE_MODE or current_method == ENSEMBLE_MODE:\r\n                        menu.add_command(label=f'Advanced {method} Settings', command=option)\r\n            elif current_method in settings_mapper:\r\n                menu.add_command(label=f'Advanced {current_method} Settings', command=settings_mapper[current_method])\r\n\r\n        # Create the right-click menu\r\n        right_click_menu = tk.Menu(self, font=(MAIN_FONT_NAME, FONT_SIZE_1), tearoff=0)\r\n\r\n        # Mappings\r\n        settings_mapper = {\r\n            ENSEMBLE_MODE: lambda: self.check_is_menu_open(ENSEMBLE_OPTION),\r\n            VR_ARCH_PM: lambda: self.check_is_menu_open(VR_OPTION),\r\n            MDX_ARCH_TYPE: lambda: self.check_is_menu_open(MDX_OPTION),\r\n            DEMUCS_ARCH_TYPE: lambda: self.check_is_menu_open(DEMUCS_OPTION)\r\n        }\r\n        \r\n        var_mapper = {\r\n            ENSEMBLE_MODE: True,\r\n            VR_ARCH_PM: self.vr_is_secondary_model_activate_var.get(),\r\n            MDX_ARCH_TYPE: self.mdx_is_secondary_model_activate_var.get(),\r\n            DEMUCS_ARCH_TYPE: self.demucs_is_secondary_model_activate_var.get()\r\n        }\r\n\r\n        # Submenu for saved settings\r\n        saved_settings_sub_load_for_menu = tk.Menu(right_click_menu, font=(MAIN_FONT_NAME, FONT_SIZE_1), tearoff=False)\r\n        for label, arch_type in [(VR_ARCH_SETTING_LOAD, VR_ARCH_PM), (MDX_SETTING_LOAD, MDX_ARCH_TYPE), (DEMUCS_SETTING_LOAD, DEMUCS_ARCH_TYPE), (ALL_ARCH_SETTING_LOAD, None)]:\r\n            submenu = self.right_click_select_settings_sub(saved_settings_sub_load_for_menu, arch_type)\r\n            saved_settings_sub_load_for_menu.add_cascade(label=label, menu=submenu)\r\n\r\n        if not main_menu:\r\n            add_text_edit_options(right_click_menu)\r\n        else:\r\n            if self.chosen_process_method_var.get() == AUDIO_TOOLS and self.chosen_audio_tool_var.get() == ALIGN_INPUTS:\r\n                right_click_menu.add_command(label='Advanced Align Tool Settings', command=lambda: self.check_is_menu_open(ALIGNMENT_TOOL))\r\n            else:\r\n                add_advanced_settings_options(right_click_menu, settings_mapper, var_mapper)\r\n\r\n            # Additional Settings and Help Hints\r\n            if not self.is_menu_settings_open:\r\n                right_click_menu.add_command(label='Additional Settings', command=lambda: self.menu_settings(select_tab_2=True))\r\n                \r\n            help_hints_label = 'Enable' if not self.help_hints_var.get() else 'Disable'\r\n            right_click_menu.add_command(label=f'{help_hints_label} Help Hints', command=lambda: self.help_hints_var.set(not self.help_hints_var.get()))\r\n                \r\n            if self.error_log_var.get():\r\n                right_click_menu.add_command(label='Error Log', command=lambda: self.check_is_menu_open(ERROR_OPTION))\r\n\r\n        try:\r\n            right_click_menu.tk_popup(event.x_root, event.y_root)\r\n            right_click_release_linux(right_click_menu)\r\n        finally:\r\n            right_click_menu.grab_release()\r\n\r\n    def right_click_menu_copy(self):\r\n        hightlighted_text = self.current_text_box.selection_get()\r\n        self.clipboard_clear()\r\n        self.clipboard_append(hightlighted_text)\r\n\r\n    def right_click_menu_paste(self, text_box=False):\r\n        clipboard = self.clipboard_get()\r\n        self.right_click_menu_delete(text_box=True) if text_box else self.right_click_menu_delete()\r\n        self.current_text_box.insert(self.current_text_box.index(tk.INSERT), clipboard)\r\n\r\n    def right_click_menu_delete(self, text_box=False):\r\n        if text_box:\r\n            try:\r\n                s0 = self.current_text_box.index(\"sel.first\")\r\n                s1 = self.current_text_box.index(\"sel.last\")\r\n                self.current_text_box.tag_configure('highlight')\r\n                self.current_text_box.tag_add(\"highlight\", s0, s1)\r\n                start_indexes = self.current_text_box.tag_ranges(\"highlight\")[0::2]\r\n                end_indexes = self.current_text_box.tag_ranges(\"highlight\")[1::2]\r\n\r\n                for start, end in zip(start_indexes, end_indexes):\r\n                    self.current_text_box.tag_remove(\"highlight\", start, end)\r\n\r\n                for start, end in zip(start_indexes, end_indexes):\r\n                    self.current_text_box.delete(start, end)\r\n            except Exception as e:\r\n                print('RIGHT-CLICK-DELETE ERROR: \\n', e)\r\n        else:\r\n            self.current_text_box.delete(0, tk.END)\r\n    \r\n    def right_click_console(self, event):\r\n        right_click_menu = tk.Menu(self, font=(MAIN_FONT_NAME, FONT_SIZE_1), tearoff=0)\r\n        right_click_menu.add_command(label='Copy', command=self.command_Text.copy_text)\r\n        right_click_menu.add_command(label='Select All', command=self.command_Text.select_all_text)\r\n        \r\n        try:\r\n            right_click_menu.tk_popup(event.x_root,event.y_root)\r\n            right_click_release_linux(right_click_menu)\r\n        finally:\r\n            right_click_menu.grab_release()\r\n\r\n    #--Secondary Window Methods--\r\n\r\n    def vocal_splitter_Button_opt(self, top_window, frame, pady, width=15):\r\n        vocal_splitter_Button = ttk.Button(frame, text=VOCAL_SPLITTER_OPTIONS_TEXT, command=lambda:self.pop_up_set_vocal_splitter(top_window), width=width)#\r\n        vocal_splitter_Button.grid(pady=pady)\r\n\r\n    def adjust_toplevel_positions(self, event):\r\n        # Copy the list to avoid modifying while iterating\r\n        for toplevel in self.toplevels.copy():\r\n            # Check if the toplevel window is still alive\r\n            if not toplevel.winfo_exists():\r\n                self.toplevels.remove(toplevel)\r\n            else:\r\n                menu_offset_x = (root.winfo_width() - toplevel.winfo_width()) // 2\r\n                menu_offset_y = (root.winfo_height() - toplevel.winfo_height()) // 2\r\n                toplevel.geometry(\"+%d+%d\" % (root.winfo_x() + menu_offset_x, root.winfo_y() + menu_offset_y))\r\n\r\n    def menu_placement(self, window: tk.Toplevel, title, pop_up=False, is_help_hints=False, close_function=None, frame_list=None, top_window=None):\r\n        \"\"\"Prepares and centers each secondary window relative to the main window\"\"\"\r\n        \r\n        top_window = top_window if top_window else root\r\n        window.withdraw()\r\n        window.resizable(False, False)\r\n        window.wm_transient(top_window)\r\n        window.title(title)\r\n        window.iconbitmap(ICON_IMG_PATH) if is_windows else self.tk.call('wm', 'iconphoto', window._w, tk.PhotoImage(file=MAIN_ICON_IMG_PATH))\r\n        \r\n        root_location_x = root.winfo_x()\r\n        root_location_y = root.winfo_y()\r\n        root_x = root.winfo_width() \r\n        root_y = root.winfo_height()\r\n        window.update() if is_windows else window.update_idletasks()\r\n        sub_menu_x = window.winfo_reqwidth() \r\n        sub_menu_y = window.winfo_reqheight()\r\n        menu_offset_x = (root_x - sub_menu_x) // 2\r\n        menu_offset_y = (root_y - sub_menu_y) // 2\r\n        window.geometry(\"+%d+%d\" %(root_location_x+menu_offset_x, root_location_y+menu_offset_y))\r\n        \r\n        window.deiconify()\r\n        window.configure(bg=BG_COLOR)\r\n\r\n        if not is_macos:\r\n            self.toplevels.append(window)\r\n        \r\n        def right_click_menu(event):\r\n            help_hints_label = 'Enable' if self.help_hints_var.get() == False else 'Disable'\r\n            help_hints_bool = True if self.help_hints_var.get() == False else False\r\n            right_click_menu = tk.Menu(self, font=(MAIN_FONT_NAME, FONT_SIZE_1), tearoff=0)\r\n            if is_help_hints:\r\n                right_click_menu.add_command(label=f'{help_hints_label} Help Hints', command=lambda:self.help_hints_var.set(help_hints_bool))\r\n            right_click_menu.add_command(label='Exit Window', command=close_function)\r\n            \r\n            try:\r\n                right_click_menu.tk_popup(event.x_root,event.y_root)\r\n                right_click_release_linux(right_click_menu, window)\r\n            finally:\r\n                right_click_menu.grab_release()\r\n        \r\n        if close_function:\r\n            window.bind(right_click_button, lambda e:right_click_menu(e))\r\n\r\n        if frame_list:\r\n            for frame in frame_list:\r\n                #self.adjust_widget_widths(frame)\r\n                self.focus_out_widgets(frame.winfo_children() + [frame], frame)\r\n \r\n        if pop_up:\r\n            window.attributes('-topmost', 'true') if OPERATING_SYSTEM == \"Linux\" else None\r\n            window.grab_set()\r\n            root.wait_window(window)\r\n            \r\n    def adjust_widget_widths(self, frame):\r\n\r\n        def resize_widget(widgets):\r\n            max_width = max(wid.winfo_width() for wid in widgets)\r\n            for wid in widgets:\r\n                if isinstance(wid, (tk.Button, ttk.Combobox)):\r\n                    # For widgets where width represents characters, not pixels\r\n                    wid.configure(width=int(max_width / wid.winfo_pixels('1c')))\r\n                else:\r\n                    # For widgets where width represents pixels\r\n                    wid.configure(width=max_width)\r\n\r\n        resize_widget([widget for widget in frame.winfo_children() if isinstance(widget, tk.Button)])\r\n        resize_widget([widget for widget in frame.winfo_children() if isinstance(widget, ttk.Combobox)])\r\n\r\n    def menu_move_tab(notebook: ttk.Notebook, tab_text, new_position):\r\n        # Get the tab ID\r\n        tab_id = None\r\n        for tab in notebook.tabs():\r\n            if notebook.tab(tab, \"text\") == tab_text:\r\n                tab_id = tab\r\n                break\r\n\r\n        if tab_id is None:\r\n            print(f\"No tab named '{tab_text}'\")\r\n            return\r\n\r\n        # remove the tab\r\n        notebook.forget(tab_id)\r\n        \r\n        # add it back in new position\r\n        notebook.insert(new_position, tab_id)\r\n          \r\n    def menu_tab_control(self, toplevel, ai_network_vars, is_demucs=False, is_mdxnet=False):\r\n        \"\"\"Prepares the tabs setup for some windows\"\"\"\r\n\r\n        tabControl = ttk.Notebook(toplevel)\r\n\r\n        tab1 = ttk.Frame(tabControl)\r\n        tab2 = ttk.Frame(tabControl)\r\n\r\n        tabControl.add(tab1, text=SETTINGS_GUIDE_TEXT)\r\n        tabControl.add(tab2, text=SECONDARY_MODEL_TEXT)\r\n\r\n        tab1.grid_rowconfigure(0, weight=1)\r\n        tab1.grid_columnconfigure(0, weight=1)\r\n\r\n        tab2.grid_rowconfigure(0, weight=1)\r\n        tab2.grid_columnconfigure(0, weight=1)\r\n\r\n        if is_demucs or is_mdxnet:\r\n            tab3 = ttk.Frame(tabControl)\r\n            tabControl.add(tab3, text=PREPROCESS_MODEL_CHOOSE_TEXT if is_demucs else MDX23C_ONLY_OPTIONS_TEXT)\r\n            tab3.grid_rowconfigure(0, weight=1)\r\n            tab3.grid_columnconfigure(0, weight=1)\r\n\r\n        tabControl.pack(expand=1, fill=tk.BOTH)\r\n        \r\n        self.tab2_loaded = False\r\n        self.tab3_loaded = False\r\n\r\n        def on_tab_selected(event):\r\n            # Check if it's tab2 (by tab id or tab title) and if it hasn't been loaded before\r\n            load_screen = False\r\n            if event.widget.tab('current', option='text') == 'Secondary Model' and not self.tab2_loaded:\r\n                tab = tab2\r\n                self.tab2_loaded = True\r\n                tab_load = lambda:self.menu_secondary_model(tab, ai_network_vars)\r\n                load_screen = True\r\n            elif event.widget.tab('current', option='text') == PREPROCESS_MODEL_CHOOSE_TEXT and not self.tab3_loaded:\r\n                tab = tab3\r\n                self.tab3_loaded = True\r\n                tab_load = lambda:self.menu_preproc_model(tab)\r\n                load_screen = True\r\n                \r\n            if load_screen:\r\n                # Step 1: Add \"Loading...\" label\r\n                loading_label = ttk.Label(tab, text=\"Updating model lists...\", font=Font(family=MAIN_FONT_NAME, size=14))\r\n                loading_label.place(relx=0.5, rely=0.5, anchor=tk.CENTER)  # Assuming you want to center it\r\n                \r\n                # Step 2: Update the UI to show the label\r\n                tab.update_idletasks()\r\n\r\n                # Load the content\r\n                tab_load()\r\n                \r\n                # Step 3: Remove or update the \"Loading...\" label\r\n                loading_label.destroy()  # Remove the label. Or you can update its text if desired.\r\n                \r\n            #self.on_tab_changed(tabControl)\r\n\r\n        tabControl.bind(\"<<NotebookTabChanged>>\", on_tab_selected)\r\n\r\n        if is_demucs or is_mdxnet:\r\n            return tab1, tab3\r\n        else:\r\n            return tab1\r\n\r\n    def menu_view_inputs(self):\r\n                     \r\n        menu_view_inputs_top = tk.Toplevel(root)\r\n    \r\n        self.is_open_menu_view_inputs.set(True)\r\n        self.menu_view_inputs_close_window = lambda:close_window()\r\n        menu_view_inputs_top.protocol(\"WM_DELETE_WINDOW\", self.menu_view_inputs_close_window)\r\n    \r\n        input_length_var = tk.StringVar(value='')   \r\n        input_info_text_var = tk.StringVar(value='')  \r\n        is_widen_box_var = tk.BooleanVar(value=False) \r\n        is_play_file_var = tk.BooleanVar(value=False) \r\n        varification_text_var = tk.StringVar(value=VERIFY_INPUTS_TEXT)\r\n\r\n        reset_list = lambda:(input_files_listbox_Option.delete(0, 'end'), [input_files_listbox_Option.insert(tk.END, inputs) for inputs in self.inputPaths])\r\n        audio_input_total = lambda:input_length_var.set(f'{AUDIO_INPUT_TOTAL_TEXT}: {len(self.inputPaths)}')\r\n        audio_input_total()\r\n\r\n        def list_diff(list1, list2): return list(set(list1).symmetric_difference(set(list2)))\r\n\r\n        def list_to_string(list1): return '\\n'.join(''.join(sub) for sub in list1)\r\n\r\n        def close_window():\r\n            self.verification_thread.kill() if self.thread_check(self.verification_thread) else None\r\n            self.is_open_menu_view_inputs.set(False)\r\n            menu_view_inputs_top.destroy()\r\n\r\n        def drag_n_drop(e):\r\n            input_info_text_var.set('')\r\n            drop(e, accept_mode='files')\r\n            reset_list()\r\n            audio_input_total()\r\n            \r\n        def selected_files(is_remove=False):\r\n            if not self.thread_check(self.active_processing_thread):\r\n                items_list = [input_files_listbox_Option.get(i) for i in input_files_listbox_Option.curselection()]\r\n                inputPaths = list(self.inputPaths)# if is_remove else items_list\r\n                if is_remove:\r\n                    [inputPaths.remove(i) for i in items_list if items_list]\r\n                else:\r\n                    [inputPaths.remove(i) for i in self.inputPaths if i not in items_list]\r\n                removed_files = list_diff(self.inputPaths, inputPaths)\r\n                [input_files_listbox_Option.delete(input_files_listbox_Option.get(0, tk.END).index(i)) for i in removed_files]\r\n                starting_len = len(self.inputPaths)\r\n                self.inputPaths = tuple(inputPaths)\r\n                self.update_inputPaths()\r\n                audio_input_total()\r\n                input_info_text_var.set(f'{starting_len - len(self.inputPaths)} input(s) removed.')\r\n            else:\r\n                input_info_text_var.set('You cannot remove inputs during an active process.')\r\n            \r\n        def box_size():\r\n            input_info_text_var.set('')\r\n            input_files_listbox_Option.config(width=230, height=25) if is_widen_box_var.get() else input_files_listbox_Option.config(width=110, height=17)\r\n            self.menu_placement(menu_view_inputs_top, 'Selected Inputs', pop_up=True)\r\n\r\n        def input_options(is_select_inputs=True):\r\n            input_info_text_var.set('')\r\n            if is_select_inputs:\r\n                self.input_select_filedialog()\r\n            else:\r\n                self.inputPaths = ()\r\n            reset_list()\r\n            self.update_inputPaths()\r\n            audio_input_total()\r\n\r\n        def pop_open_file_path(is_play_file=False):\r\n            if self.inputPaths:\r\n                track_selected = self.inputPaths[input_files_listbox_Option.index(tk.ACTIVE)]\r\n                if os.path.isfile(track_selected):\r\n                    OPEN_FILE_func(track_selected if is_play_file else os.path.dirname(track_selected))\r\n        \r\n        def get_export_dir():\r\n            if os.path.isdir(self.export_path_var.get()):\r\n                export_dir = self.export_path_var.get()\r\n            else:\r\n                export_dir = self.export_select_filedialog()\r\n\r\n            return export_dir\r\n        \r\n        def verify_audio(is_create_samples=False):\r\n            inputPaths = list(self.inputPaths)\r\n            iterated_list = self.inputPaths if not is_create_samples else [input_files_listbox_Option.get(i) for i in input_files_listbox_Option.curselection()]\r\n            removed_files = []\r\n            export_dir = None\r\n            total_audio_count, current_file = len(iterated_list), 0\r\n            if iterated_list:\r\n                for i in iterated_list:\r\n                    current_file += 1\r\n                    input_info_text_var.set(f'{SAMPLE_BEGIN if is_create_samples else VERIFY_BEGIN}{current_file}/{total_audio_count}')\r\n                    if is_create_samples:\r\n                        export_dir = get_export_dir()\r\n                        if not export_dir:\r\n                            input_info_text_var.set(f'No export directory selected.')\r\n                            return\r\n                    is_good, error_data = self.verify_audio(i, is_process=False, sample_path=export_dir)\r\n                    if not is_good:\r\n                        inputPaths.remove(i)\r\n                        removed_files.append(error_data)#sample = self.create_sample(i)\r\n                        \r\n                varification_text_var.set(VERIFY_INPUTS_TEXT)\r\n                input_files_listbox_Option.configure(state=tk.NORMAL)\r\n                \r\n                if removed_files:\r\n                    input_info_text_var.set(f'{len(removed_files)} {BROKEN_OR_INCOM_TEXT}')\r\n                    error_text = ''\r\n                    for i in removed_files:\r\n                        error_text += i\r\n                    removed_files = list_diff(self.inputPaths, inputPaths)\r\n                    [input_files_listbox_Option.delete(input_files_listbox_Option.get(0, tk.END).index(i)) for i in removed_files]\r\n                    self.error_log_var.set(REMOVED_FILES(list_to_string(removed_files), error_text))\r\n                    self.inputPaths = tuple(inputPaths)\r\n                    self.update_inputPaths()\r\n                else:\r\n                    input_info_text_var.set(f'No errors found!')\r\n                    \r\n                audio_input_total()\r\n            else:\r\n                input_info_text_var.set(f'{NO_FILES_TEXT} {SELECTED_VER if is_create_samples else DETECTED_VER}')\r\n                varification_text_var.set(VERIFY_INPUTS_TEXT)\r\n                input_files_listbox_Option.configure(state=tk.NORMAL)\r\n                return\r\n            \r\n            audio_input_total()\r\n            \r\n        def verify_audio_start_thread(is_create_samples=False):\r\n            \r\n            if not self.thread_check(self.active_processing_thread):\r\n                if not self.thread_check(self.verification_thread):\r\n                    varification_text_var.set('Stop Progress')\r\n                    input_files_listbox_Option.configure(state=tk.DISABLED)\r\n                    self.verification_thread = KThread(target=lambda:verify_audio(is_create_samples=is_create_samples))\r\n                    self.verification_thread.start()\r\n                else:\r\n                    input_files_listbox_Option.configure(state=tk.NORMAL)\r\n                    varification_text_var.set(VERIFY_INPUTS_TEXT)\r\n                    input_info_text_var.set('Process Stopped')\r\n                    self.verification_thread.kill()\r\n            else:\r\n                input_info_text_var.set('You cannot verify inputs during an active process.')\r\n\r\n        def right_click_menu(event):\r\n                right_click_menu = tk.Menu(self, font=(MAIN_FONT_NAME, FONT_SIZE_1), tearoff=0)\r\n                right_click_menu.add_command(label='Remove Selected Items Only', command=lambda:selected_files(is_remove=True))\r\n                right_click_menu.add_command(label='Keep Selected Items Only', command=lambda:selected_files(is_remove=False))\r\n                right_click_menu.add_command(label='Clear All Input(s)', command=lambda:input_options(is_select_inputs=False))\r\n                right_click_menu.add_separator()\r\n                right_click_menu_sub = tk.Menu(right_click_menu, font=(MAIN_FONT_NAME, FONT_SIZE_1), tearoff=False)\r\n                right_click_menu.add_command(label='Verify and Create Samples of Selected Inputs', command=lambda:verify_audio_start_thread(is_create_samples=True))\r\n                right_click_menu.add_cascade(label='Preferred Double Click Action', menu=right_click_menu_sub)\r\n                if is_play_file_var.get():\r\n                    right_click_menu_sub.add_command(label='Enable: Open Audio File Directory', command=lambda:(input_files_listbox_Option.bind('<Double-Button>', lambda e:pop_open_file_path()), is_play_file_var.set(False)))\r\n                else:\r\n                    right_click_menu_sub.add_command(label='Enable: Open Audio File', command=lambda:(input_files_listbox_Option.bind('<Double-Button>', lambda e:pop_open_file_path(is_play_file=True)), is_play_file_var.set(True)))\r\n\r\n                try:\r\n                    right_click_menu.tk_popup(event.x_root,event.y_root)\r\n                    right_click_release_linux(right_click_menu, menu_view_inputs_top)\r\n                finally:\r\n                    right_click_menu.grab_release()\r\n\r\n        menu_view_inputs_Frame = self.menu_FRAME_SET(menu_view_inputs_top)\r\n        menu_view_inputs_Frame.grid(row=0)  \r\n\r\n        self.main_window_LABEL_SET(menu_view_inputs_Frame, SELECTED_INPUTS).grid(row=0,column=0,padx=0,pady=MENU_PADDING_1)\r\n        tk.Label(menu_view_inputs_Frame, textvariable=input_length_var, font=(MAIN_FONT_NAME, f\"{FONT_SIZE_1}\"), foreground=FG_COLOR).grid(row=1, column=0, padx=0, pady=MENU_PADDING_1)\r\n        if not OPERATING_SYSTEM == \"Linux\":\r\n            ttk.Button(menu_view_inputs_Frame, text=SELECT_INPUTS, command=lambda:input_options()).grid(row=2,column=0,padx=0,pady=MENU_PADDING_2)\r\n        input_files_listbox_Option = tk.Listbox(menu_view_inputs_Frame, selectmode=tk.EXTENDED, activestyle='dotbox', font=(MAIN_FONT_NAME, f\"{FONT_SIZE_1}\"), background='#101414', exportselection=0, width=110, height=17, relief=tk.SOLID, borderwidth=0)\r\n        input_files_listbox_vertical_scroll = ttk.Scrollbar(menu_view_inputs_Frame, orient=tk.VERTICAL)\r\n        input_files_listbox_Option.config(yscrollcommand=input_files_listbox_vertical_scroll.set)\r\n        input_files_listbox_vertical_scroll.configure(command=input_files_listbox_Option.yview)\r\n        input_files_listbox_Option.grid(row=4, sticky=tk.W)\r\n        input_files_listbox_vertical_scroll.grid(row=4, column=1, sticky=tk.NS)\r\n\r\n        tk.Label(menu_view_inputs_Frame, textvariable=input_info_text_var, font=(MAIN_FONT_NAME, f\"{FONT_SIZE_1}\"), foreground=FG_COLOR).grid(row=5, column=0, padx=0, pady=0)\r\n        ttk.Checkbutton(menu_view_inputs_Frame, text=WIDEN_BOX, variable=is_widen_box_var, command=lambda:box_size()).grid(row=6,column=0,padx=0,pady=0)\r\n        verify_audio_Button = ttk.Button(menu_view_inputs_Frame, textvariable=varification_text_var, command=lambda:verify_audio_start_thread())\r\n        verify_audio_Button.grid(row=7,column=0,padx=0,pady=MENU_PADDING_1)\r\n        ttk.Button(menu_view_inputs_Frame, text=CLOSE_WINDOW, command=lambda:menu_view_inputs_top.destroy()).grid(row=8,column=0,padx=0,pady=MENU_PADDING_1)\r\n\r\n        if is_dnd_compatible:\r\n            menu_view_inputs_top.drop_target_register(DND_FILES)\r\n            menu_view_inputs_top.dnd_bind('<<Drop>>', lambda e: drag_n_drop(e))\r\n        input_files_listbox_Option.bind(right_click_button, lambda e:right_click_menu(e))\r\n        input_files_listbox_Option.bind('<Double-Button>', lambda e:pop_open_file_path())\r\n        input_files_listbox_Option.bind('<Delete>', lambda e:selected_files(is_remove=True))\r\n        input_files_listbox_Option.bind('<BackSpace>', lambda e:selected_files(is_remove=False))\r\n\r\n        reset_list()\r\n\r\n        self.menu_placement(menu_view_inputs_top, 'Selected Inputs', pop_up=True)\r\n\r\n    def menu_batch_dual(self):\r\n        menu_batch_dual_top = tk.Toplevel(root)\r\n        \r\n        def drag_n_drop(event, accept_mode):\r\n            listbox = left_frame if accept_mode == FILE_1_LB else right_frame\r\n            paths = drop(event, accept_mode)\r\n            for item in paths:\r\n                if item not in listbox.path_list:  # only add file if it's not already in the list\r\n                    basename = os.path.basename(item)\r\n                    listbox.listbox.insert(tk.END, basename)  # insert basename to the listbox\r\n                    listbox.path_list.append(item)  # append the file path to the list\r\n            listbox.update_displayed_index()\r\n        \r\n        def move_entry(is_primary=True):\r\n            if is_primary:\r\n                selected_frame, other_frame = left_frame, right_frame\r\n            else:\r\n                selected_frame, other_frame = right_frame, left_frame\r\n\r\n            selected = selected_frame.listbox.curselection()\r\n\r\n            if selected:\r\n                basename = selected_frame.listbox.get(selected[0]).split(': ', 1)[1]  # remove displayed index\r\n\r\n                if basename in other_frame.basename_to_path:\r\n                    return\r\n\r\n                path = selected_frame.basename_to_path[basename]  # Get the actual path\r\n\r\n                selected_frame.listbox.delete(selected)\r\n                other_frame.listbox.insert(tk.END, basename)\r\n\r\n                selected_frame.path_list.remove(path)\r\n                del selected_frame.basename_to_path[basename]\r\n\r\n                other_frame.path_list.append(path)\r\n                other_frame.basename_to_path[basename] = path\r\n\r\n                selected_frame.update_displayed_index()\r\n                other_frame.update_displayed_index()\r\n        \r\n        def open_selected_path(lb, is_play_file=False):\r\n            selected_frame = left_frame if lb == FILE_1_LB else right_frame\r\n            selected_path = selected_frame.get_selected_path()\r\n            \r\n            if selected_path:\r\n                if os.path.isfile(selected_path):\r\n                    OPEN_FILE_func(selected_path if is_play_file else os.path.dirname(selected_path))\r\n\r\n        def clear_all_data(lb):\r\n            selected_frame = left_frame if lb == FILE_1_LB else right_frame\r\n            selected_frame.listbox.delete(0, \"end\")\r\n            selected_frame.path_list.clear()\r\n            selected_frame.basename_to_path.clear()\r\n        \r\n        def clear_all(event, lb):\r\n            selected_frame = left_frame if lb == FILE_1_LB else right_frame\r\n            selected = selected_frame.listbox.curselection()\r\n            \r\n            right_click_menu = tk.Menu(self, font=(MAIN_FONT_NAME, FONT_SIZE_1), tearoff=0)\r\n            if selected:\r\n                right_click_menu.add_command(label='Open Location', command=lambda:open_selected_path(lb))\r\n                right_click_menu.add_command(label='Open File', command=lambda:open_selected_path(lb, is_play_file=True))\r\n            right_click_menu.add_command(label='Clear All', command=lambda:clear_all_data(lb))\r\n\r\n            try:\r\n                right_click_menu.tk_popup(event.x_root,event.y_root)\r\n                right_click_release_linux(right_click_menu, menu_batch_dual_top)\r\n            finally:\r\n                right_click_menu.grab_release()\r\n       \r\n        def gather_input_list():\r\n            left_paths = list(left_frame.basename_to_path.values())\r\n            right_paths = list(right_frame.basename_to_path.values())\r\n            \r\n            clear_all_data(FILE_1_LB)\r\n            clear_all_data(FILE_2_LB)\r\n            \r\n            if left_paths and right_paths:\r\n                left_frame.select_input(left_paths)\r\n                right_frame.select_input(right_paths)\r\n\r\n            self.DualBatch_inputPaths = list(zip(left_paths, right_paths))\r\n            self.check_dual_paths()\r\n            menu_batch_dual_top.destroy()\r\n\r\n        menu_view_inputs_Frame = self.menu_FRAME_SET(menu_batch_dual_top)\r\n        menu_view_inputs_Frame.grid(row=0)\r\n        \r\n        left_frame = ListboxBatchFrame(menu_view_inputs_Frame, self.file_one_sub_var.get().title(), move_entry, self.right_img, self.img_mapper)\r\n        left_frame.grid(row=0, column=0, sticky=\"nsew\", padx=(0, 5))\r\n        \r\n        right_frame = ListboxBatchFrame(menu_view_inputs_Frame, self.file_two_sub_var.get().title(), lambda:move_entry(False), self.left_img, self.img_mapper)\r\n        right_frame.grid(row=0, column=1, sticky=\"nsew\", padx=(5, 0))\r\n\r\n        left_frame.listbox.drop_target_register(DND_FILES)\r\n        right_frame.listbox.drop_target_register(DND_FILES)\r\n        left_frame.listbox.dnd_bind('<<Drop>>', lambda e: drag_n_drop(e, FILE_1_LB))\r\n        right_frame.listbox.dnd_bind('<<Drop>>', lambda e: drag_n_drop(e, FILE_2_LB))\r\n        left_frame.listbox.dnd_bind(right_click_button, lambda e: clear_all(e, FILE_1_LB))\r\n        right_frame.listbox.dnd_bind(right_click_button, lambda e: clear_all(e, FILE_2_LB))\r\n\r\n        menu_view_inputs_bottom_Frame = self.menu_FRAME_SET(menu_batch_dual_top)\r\n        menu_view_inputs_bottom_Frame.grid(row=1)\r\n        \r\n        confirm_btn = ttk.Button(menu_view_inputs_bottom_Frame, text=CONFIRM_ENTRIES, command=gather_input_list)\r\n        confirm_btn.grid(pady=MENU_PADDING_1)\r\n        \r\n        close_btn = ttk.Button(menu_view_inputs_bottom_Frame, text=CLOSE_WINDOW, command=lambda:menu_batch_dual_top.destroy())\r\n        close_btn.grid(pady=MENU_PADDING_1)\r\n\r\n        if self.check_dual_paths():\r\n            left_frame_pane = [i[0] for i in self.DualBatch_inputPaths]\r\n            right_frame_pane = [i[1] for i in self.DualBatch_inputPaths]\r\n            left_frame.update_displayed_index(left_frame_pane)\r\n            right_frame.update_displayed_index(right_frame_pane)\r\n            self.check_dual_paths()\r\n\r\n        self.menu_placement(menu_batch_dual_top, DUAL_AUDIO_PROCESSING, pop_up=True)\r\n\r\n    def check_dual_paths(self, is_fill_menu=False):\r\n        \r\n        if self.DualBatch_inputPaths:\r\n            first_paths = tuple(self.DualBatch_inputPaths)\r\n            first_paths_len = len(first_paths)\r\n            first_paths = first_paths[0]\r\n            \r\n            if first_paths_len == 1:\r\n                file1_base_text = os.path.basename(first_paths[0])\r\n                file2_base_text = os.path.basename(first_paths[1])\r\n            else:\r\n                first_paths_len = first_paths_len - 1\r\n                file1_base_text = f\"{os.path.basename(first_paths[0])}, +{first_paths_len} file(s){BATCH_MODE_DUAL}\"\r\n                file2_base_text = f\"{os.path.basename(first_paths[1])}, +{first_paths_len} file(s){BATCH_MODE_DUAL}\"\r\n            \r\n            self.fileOneEntry_var.set(file1_base_text)\r\n            self.fileOneEntry_Full_var.set(f\"{first_paths[0]}\")\r\n            self.fileTwoEntry_var.set(file2_base_text)\r\n            self.fileTwoEntry_Full_var.set(f\"{first_paths[1]}\")\r\n        else:\r\n            if is_fill_menu:\r\n                file_one = self.fileOneEntry_Full_var.get()\r\n                file_two = self.fileTwoEntry_Full_var.get()\r\n\r\n                if file_one and file_two and BATCH_MODE_DUAL not in file_one and BATCH_MODE_DUAL not in file_two:\r\n                    self.DualBatch_inputPaths = [(file_one, file_two)]\r\n            else:\r\n                if BATCH_MODE_DUAL in self.fileOneEntry_var.get():\r\n                    self.fileOneEntry_var.set(\"\")\r\n                    self.fileOneEntry_Full_var.set(\"\")\r\n                if BATCH_MODE_DUAL in self.fileTwoEntry_var.get():\r\n                    self.fileTwoEntry_var.set(\"\")\r\n                    self.fileTwoEntry_Full_var.set(\"\")\r\n            \r\n        return self.DualBatch_inputPaths\r\n\r\n    def fill_gpu_list(self):\r\n        try:\r\n            if cuda_available:\r\n                self.cuda_device_list = [f\"{torch.cuda.get_device_properties(i).name}:{i}\" for i in range(torch.cuda.device_count())]\r\n                self.cuda_device_list.insert(0, DEFAULT)\r\n                #print(self.cuda_device_list)\r\n            \r\n            # if directml_available:\r\n            #     self.opencl_list = [f\"{torch_directml.device_name(i)}:{i}\" for i in range(torch_directml.device_count())]\r\n            #     self.opencl_list.insert(0, DEFAULT)\r\n        except Exception as e:\r\n            print(e)\r\n            \r\n        # if is_cuda_only:\r\n        #     self.is_use_opencl_var.set(False)\r\n            \r\n        check_gpu_list = self.cuda_device_list#self.opencl_list if is_opencl_only or self.is_use_opencl_var.get() else self.cuda_device_list\r\n        if not self.device_set_var.get() in check_gpu_list:\r\n            self.device_set_var.set(DEFAULT)\r\n\r\n    def loop_gpu_list(self, option_menu:ComboBoxMenu, menu_name, option_list):\r\n        option_menu['values'] = option_list\r\n        option_menu.update_dropdown_size(option_list, menu_name)\r\n\r\n    def menu_settings(self, select_tab_2=False, select_tab_3=False):#**\r\n        \"\"\"Open Settings and Download Center\"\"\"\r\n\r\n        settings_menu = tk.Toplevel()\r\n        \r\n        option_var = tk.StringVar(value=SELECT_SAVED_SETTING)\r\n        self.is_menu_settings_open = True\r\n        \r\n        tabControl = ttk.Notebook(settings_menu)\r\n  \r\n        tab1 = ttk.Frame(tabControl)\r\n        tab2 = ttk.Frame(tabControl)\r\n        tab3 = ttk.Frame(tabControl)\r\n\r\n        tabControl.add(tab1, text = SETTINGS_GUIDE_TEXT)\r\n        tabControl.add(tab2, text = ADDITIONAL_SETTINGS_TEXT)\r\n        tabControl.add(tab3, text = DOWNLOAD_CENTER_TEXT)\r\n\r\n        tabControl.pack(expand = 1, fill =\"both\")\r\n        \r\n        tab1.grid_rowconfigure(0, weight=1)\r\n        tab1.grid_columnconfigure(0, weight=1)\r\n        \r\n        tab2.grid_rowconfigure(0, weight=1)\r\n        tab2.grid_columnconfigure(0, weight=1)\r\n        \r\n        tab3.grid_rowconfigure(0, weight=1)\r\n        tab3.grid_columnconfigure(0, weight=1)\r\n\r\n        self.disable_tabs = lambda:(tabControl.tab(0, state=\"disabled\"), tabControl.tab(1, state=\"disabled\"))\r\n        self.enable_tabs = lambda:(tabControl.tab(0, state=\"normal\"), tabControl.tab(1, state=\"normal\"))        \r\n        self.main_menu_var = tk.StringVar(value=CHOOSE_ADVANCED_MENU_TEXT) \r\n\r\n        self.download_progress_bar_var.set(0)\r\n        self.download_progress_info_var.set('')\r\n        self.download_progress_percent_var.set('')\r\n                \r\n        def set_vars_for_sample_mode(event):\r\n            value = int(float(event))\r\n            value = round(value / 5) * 5\r\n            self.model_sample_mode_duration_var.set(value)\r\n            self.model_sample_mode_duration_checkbox_var.set(SAMPLE_MODE_CHECKBOX(value))\r\n            self.model_sample_mode_duration_label_var.set(f'{value} {SECONDS_TEXT}')\r\n            \r\n        #Settings Tab 1\r\n        settings_menu_main_Frame = self.menu_FRAME_SET(tab1)\r\n        settings_menu_main_Frame.grid(row=0)  \r\n        settings_title_Label = self.menu_title_LABEL_SET(settings_menu_main_Frame, GENERAL_MENU_TEXT)\r\n        settings_title_Label.grid(pady=MENU_PADDING_2)\r\n        \r\n        select_Label = self.menu_sub_LABEL_SET(settings_menu_main_Frame, ADDITIONAL_MENUS_INFORMATION_TEXT)\r\n        select_Label.grid(pady=MENU_PADDING_1)\r\n        \r\n        select_Option = ComboBoxMenu(settings_menu_main_Frame, textvariable=self.main_menu_var, values=OPTION_LIST, width=GEN_SETTINGS_WIDTH+3)\r\n        select_Option.update_dropdown_size(OPTION_LIST, 'menuchoose', command=lambda e:(self.check_is_menu_open(self.main_menu_var.get()), close_window()))\r\n        select_Option.grid(pady=MENU_PADDING_1)\r\n        \r\n        help_hints_Option = ttk.Checkbutton(settings_menu_main_Frame, text=ENABLE_HELP_HINTS_TEXT, variable=self.help_hints_var, width=HELP_HINT_CHECKBOX_WIDTH) \r\n        help_hints_Option.grid(pady=MENU_PADDING_1)\r\n        \r\n        open_app_dir_Button = ttk.Button(settings_menu_main_Frame, text=OPEN_APPLICATION_DIRECTORY_TEXT, command=lambda:OPEN_FILE_func(BASE_PATH), width=SETTINGS_BUT_WIDTH)\r\n        open_app_dir_Button.grid(pady=MENU_PADDING_1)\r\n        \r\n        reset_all_app_settings_Button = ttk.Button(settings_menu_main_Frame, text=RESET_ALL_SETTINGS_TO_DEFAULT_TEXT, command=lambda:self.load_to_default_confirm(), width=SETTINGS_BUT_WIDTH)#pop_up_change_model_defaults\r\n        reset_all_app_settings_Button.grid(pady=MENU_PADDING_1)\r\n        \r\n        if is_windows:\r\n            restart_app_Button = ttk.Button(settings_menu_main_Frame, text=RESTART_APPLICATION_TEXT, command=lambda:self.restart())\r\n            restart_app_Button.grid(pady=MENU_PADDING_1)\r\n\r\n        delete_your_settings_Label = self.menu_title_LABEL_SET(settings_menu_main_Frame, DELETE_USER_SAVED_SETTING_TEXT)\r\n        delete_your_settings_Label.grid(pady=MENU_PADDING_2)\r\n        self.help_hints(delete_your_settings_Label, text=DELETE_YOUR_SETTINGS_HELP)\r\n        \r\n        delete_your_settings_Option = ComboBoxMenu(settings_menu_main_Frame, textvariable=option_var, width=GEN_SETTINGS_WIDTH+3)\r\n        delete_your_settings_Option.grid(padx=20,pady=MENU_PADDING_1)\r\n        self.deletion_list_fill(delete_your_settings_Option, option_var, SETTINGS_CACHE_DIR, SELECT_SAVED_SETTING, menu_name='deletesetting')\r\n\r\n        app_update_Label = self.menu_title_LABEL_SET(settings_menu_main_Frame, APPLICATION_UPDATES_TEXT)\r\n        app_update_Label.grid(pady=MENU_PADDING_2)\r\n        \r\n        self.app_update_button = ttk.Button(settings_menu_main_Frame, textvariable=self.app_update_button_Text_var, width=SETTINGS_BUT_WIDTH-2, command=lambda:self.pop_up_update_confirmation())\r\n        self.app_update_button.grid(pady=MENU_PADDING_1)\r\n        \r\n        self.app_update_status_Label = tk.Label(settings_menu_main_Frame, textvariable=self.app_update_status_Text_var, padx=3, pady=3, font=(MAIN_FONT_NAME,  f\"{FONT_SIZE_4}\"), width=UPDATE_LABEL_WIDTH, justify=\"center\", relief=\"ridge\", fg=\"#13849f\")\r\n        self.app_update_status_Label.grid(pady=20)\r\n        \r\n        donate_Button = ttk.Button(settings_menu_main_Frame, image=self.donate_img, command=lambda:webbrowser.open_new_tab(DONATE_LINK_BMAC))\r\n        donate_Button.grid(pady=MENU_PADDING_2)\r\n        self.help_hints(donate_Button, text=DONATE_HELP)\r\n        \r\n        close_settings_win_Button = ttk.Button(settings_menu_main_Frame, text=CLOSE_WINDOW, command=lambda:close_window())\r\n        close_settings_win_Button.grid(pady=MENU_PADDING_1)      \r\n          \r\n        #Settings Tab 2\r\n        settings_menu_format_Frame = self.menu_FRAME_SET(tab2)\r\n        settings_menu_format_Frame.grid(row=0)  \r\n        \r\n        audio_format_title_Label = self.menu_title_LABEL_SET(settings_menu_format_Frame, AUDIO_FORMAT_SETTINGS_TEXT, width=20)\r\n        audio_format_title_Label.grid(pady=MENU_PADDING_2)\r\n        \r\n        wav_type_set_Label = self.menu_sub_LABEL_SET(settings_menu_format_Frame, WAV_TYPE_TEXT)\r\n        wav_type_set_Label.grid(pady=MENU_PADDING_1)\r\n        \r\n        wav_type_set_Option = ComboBoxMenu(settings_menu_format_Frame, textvariable=self.wav_type_set_var, values=WAV_TYPE, width=HELP_HINT_CHECKBOX_WIDTH)\r\n        wav_type_set_Option.grid(padx=20,pady=MENU_PADDING_1)\r\n        \r\n        mp3_bit_set_Label = self.menu_sub_LABEL_SET(settings_menu_format_Frame, MP3_BITRATE_TEXT)\r\n        mp3_bit_set_Label.grid(pady=MENU_PADDING_1)\r\n        \r\n        mp3_bit_set_Option = ComboBoxMenu(settings_menu_format_Frame, textvariable=self.mp3_bit_set_var, values=MP3_BIT_RATES, width=HELP_HINT_CHECKBOX_WIDTH)\r\n        mp3_bit_set_Option.grid(padx=20,pady=MENU_PADDING_1)\r\n\r\n        audio_format_title_Label = self.menu_title_LABEL_SET(settings_menu_format_Frame, GENERAL_PROCESS_SETTINGS_TEXT)\r\n        audio_format_title_Label.grid(pady=MENU_PADDING_2)\r\n        \r\n        is_testing_audio_Option = ttk.Checkbutton(settings_menu_format_Frame, text=SETTINGS_TEST_MODE_TEXT, width=GEN_SETTINGS_WIDTH, variable=self.is_testing_audio_var) \r\n        is_testing_audio_Option.grid()\r\n        self.help_hints(is_testing_audio_Option, text=IS_TESTING_AUDIO_HELP)\r\n        \r\n        is_add_model_name_Option = ttk.Checkbutton(settings_menu_format_Frame, text=MODEL_TEST_MODE_TEXT, width=GEN_SETTINGS_WIDTH, variable=self.is_add_model_name_var) \r\n        is_add_model_name_Option.grid()\r\n        self.help_hints(is_add_model_name_Option, text=IS_MODEL_TESTING_AUDIO_HELP)\r\n        \r\n        is_create_model_folder_Option = ttk.Checkbutton(settings_menu_format_Frame, text=GENERATE_MODEL_FOLDER_TEXT, width=GEN_SETTINGS_WIDTH, variable=self.is_create_model_folder_var) \r\n        is_create_model_folder_Option.grid()\r\n        self.help_hints(is_create_model_folder_Option, text=IS_CREATE_MODEL_FOLDER_HELP)\r\n        \r\n        is_accept_any_input_Option = ttk.Checkbutton(settings_menu_format_Frame, text=ACCEPT_ANY_INPUT_TEXT, width=GEN_SETTINGS_WIDTH, variable=self.is_accept_any_input_var) \r\n        is_accept_any_input_Option.grid()\r\n        self.help_hints(is_accept_any_input_Option, text=IS_ACCEPT_ANY_INPUT_HELP)\r\n        \r\n        is_task_complete_Option = ttk.Checkbutton(settings_menu_format_Frame, text=NOTIFICATION_CHIMES_TEXT, width=GEN_SETTINGS_WIDTH, variable=self.is_task_complete_var) \r\n        is_task_complete_Option.grid()\r\n        self.help_hints(is_task_complete_Option, text=IS_TASK_COMPLETE_HELP)\r\n        \r\n        is_normalization_Option = ttk.Checkbutton(settings_menu_format_Frame, text=NORMALIZE_OUTPUT_TEXT, width=GEN_SETTINGS_WIDTH, variable=self.is_normalization_var) \r\n        is_normalization_Option.grid()\r\n        self.help_hints(is_normalization_Option, text=IS_NORMALIZATION_HELP)\r\n        \r\n        change_model_default_Button = ttk.Button(settings_menu_format_Frame, text=CHANGE_MODEL_DEFAULTS_TEXT, command=lambda:self.pop_up_change_model_defaults(settings_menu), width=SETTINGS_BUT_WIDTH-2)#\r\n        change_model_default_Button.grid(pady=MENU_PADDING_4)\r\n\r\n        #if not is_choose_arch:\r\n        self.vocal_splitter_Button_opt(settings_menu, settings_menu_format_Frame, width=SETTINGS_BUT_WIDTH-2, pady=MENU_PADDING_4)\r\n\r\n        if not is_macos and self.is_gpu_available:\r\n            gpu_list_options = lambda:self.loop_gpu_list(device_set_Option, 'gpudevice', self.cuda_device_list)#self.opencl_list if is_opencl_only or self.is_use_opencl_var.get() else self.cuda_device_list)\r\n            device_set_Label = self.menu_title_LABEL_SET(settings_menu_format_Frame, CUDA_NUM_TEXT)\r\n            device_set_Label.grid(pady=MENU_PADDING_2)\r\n            \r\n            device_set_Option = ComboBoxMenu(settings_menu_format_Frame, textvariable=self.device_set_var, values=GPU_DEVICE_NUM_OPTS, width=GEN_SETTINGS_WIDTH+1)\r\n            device_set_Option.grid(padx=20,pady=MENU_PADDING_1)\r\n            gpu_list_options()\r\n            self.help_hints(device_set_Label, text=IS_CUDA_SELECT_HELP)\r\n            \r\n            # if is_choose_arch:\r\n            #     is_use_opencl_Option = ttk.Checkbutton(settings_menu_format_Frame, \r\n            #                                            text=USE_OPENCL_TEXT, \r\n            #                                            width=9, \r\n            #                                            variable=self.is_use_opencl_var, \r\n            #                                            command=lambda:(gpu_list_options(), self.device_set_var.set(DEFAULT))) \r\n            #     is_use_opencl_Option.grid()\r\n            #     self.help_hints(is_use_opencl_Option, text=IS_NORMALIZATION_HELP)\r\n\r\n        model_sample_mode_Label = self.menu_title_LABEL_SET(settings_menu_format_Frame, MODEL_SAMPLE_MODE_SETTINGS_TEXT)\r\n        model_sample_mode_Label.grid(pady=MENU_PADDING_2)\r\n        \r\n        model_sample_mode_duration_Label = self.menu_sub_LABEL_SET(settings_menu_format_Frame, SAMPLE_CLIP_DURATION_TEXT)\r\n        model_sample_mode_duration_Label.grid(pady=MENU_PADDING_1)\r\n        \r\n        tk.Label(settings_menu_format_Frame, textvariable=self.model_sample_mode_duration_label_var, font=(MAIN_FONT_NAME, f\"{FONT_SIZE_1}\"), foreground=FG_COLOR).grid(pady=2)\r\n        model_sample_mode_duration_Option = ttk.Scale(settings_menu_format_Frame, variable=self.model_sample_mode_duration_var, from_=5, to=120, command=set_vars_for_sample_mode, orient='horizontal')\r\n        model_sample_mode_duration_Option.grid(pady=2)\r\n        \r\n        #Settings Tab 3\r\n        settings_menu_download_center_Frame = self.menu_FRAME_SET(tab3)\r\n        settings_menu_download_center_Frame.grid(row=0)  \r\n        \r\n        download_center_title_Label = self.menu_title_LABEL_SET(settings_menu_download_center_Frame, APPLICATION_DOWNLOAD_CENTER_TEXT)\r\n        download_center_title_Label.grid(padx=20,pady=MENU_PADDING_2)\r\n\r\n        select_download_Label = self.menu_sub_LABEL_SET(settings_menu_download_center_Frame, SELECT_DOWNLOAD_TEXT)\r\n        select_download_Label.grid(pady=MENU_PADDING_2)\r\n        \r\n        self.model_download_vr_Button = ttk.Radiobutton(settings_menu_download_center_Frame, text='VR Arch', width=8, variable=self.select_download_var, value='VR Arc', command=lambda:self.download_list_state())\r\n        self.model_download_vr_Button.grid(pady=MENU_PADDING_1)\r\n        self.model_download_vr_Option = ComboBoxMenu(settings_menu_download_center_Frame, textvariable=self.model_download_vr_var, width=READ_ONLY_COMBO_WIDTH)\r\n        self.model_download_vr_Option.grid(pady=MENU_PADDING_1)\r\n        \r\n        self.model_download_mdx_Button = ttk.Radiobutton(settings_menu_download_center_Frame, text='MDX-Net', width=8, variable=self.select_download_var, value='MDX-Net', command=lambda:self.download_list_state())\r\n        self.model_download_mdx_Button.grid(pady=MENU_PADDING_1)\r\n        self.model_download_mdx_Option = ComboBoxMenu(settings_menu_download_center_Frame, textvariable=self.model_download_mdx_var, width=READ_ONLY_COMBO_WIDTH)\r\n        self.model_download_mdx_Option.grid(pady=MENU_PADDING_1)\r\n\r\n        self.model_download_demucs_Button = ttk.Radiobutton(settings_menu_download_center_Frame, text='Demucs', width=8, variable=self.select_download_var, value='Demucs', command=lambda:self.download_list_state())\r\n        self.model_download_demucs_Button.grid(pady=MENU_PADDING_1)\r\n        self.model_download_demucs_Option = ComboBoxMenu(settings_menu_download_center_Frame, textvariable=self.model_download_demucs_var, width=READ_ONLY_COMBO_WIDTH)\r\n        self.model_download_demucs_Option.grid(pady=MENU_PADDING_1)\r\n        \r\n        self.download_Button = ttk.Button(settings_menu_download_center_Frame, image=self.download_img, command=lambda:self.download_item())#, command=download_model)\r\n        self.download_Button.grid(pady=MENU_PADDING_1)\r\n        \r\n        self.download_progress_info_Label = tk.Label(settings_menu_download_center_Frame, textvariable=self.download_progress_info_var, font=(MAIN_FONT_NAME, f\"{FONT_SIZE_2}\"), foreground=FG_COLOR, borderwidth=0)\r\n        self.download_progress_info_Label.grid(pady=MENU_PADDING_1)\r\n        \r\n        self.download_progress_percent_Label = tk.Label(settings_menu_download_center_Frame, textvariable=self.download_progress_percent_var, font=(MAIN_FONT_NAME, f\"{FONT_SIZE_2}\"), wraplength=350, foreground=FG_COLOR)\r\n        self.download_progress_percent_Label.grid(pady=MENU_PADDING_1)\r\n        \r\n        self.download_progress_bar_Progressbar = ttk.Progressbar(settings_menu_download_center_Frame, variable=self.download_progress_bar_var)\r\n        self.download_progress_bar_Progressbar.grid(pady=MENU_PADDING_1)\r\n        \r\n        self.stop_download_Button = ttk.Button(settings_menu_download_center_Frame, textvariable=self.download_stop_var, width=15, command=lambda:self.download_post_action(DOWNLOAD_STOPPED))\r\n        self.stop_download_Button.grid(pady=MENU_PADDING_1)\r\n        self.stop_download_Button_DISABLE = lambda:(self.download_stop_var.set(\"\"), self.stop_download_Button.configure(state=tk.DISABLED))\r\n        self.stop_download_Button_ENABLE = lambda:(self.download_stop_var.set(STOP_DOWNLOAD_TEXT), self.stop_download_Button.configure(state=tk.NORMAL))\r\n\r\n        self.refresh_list_Button = ttk.Button(settings_menu_download_center_Frame, text=REFRESH_LIST_TEXT, command=lambda:self.online_data_refresh(refresh_list_Button=True))#, command=refresh_list)\r\n        self.refresh_list_Button.grid(pady=MENU_PADDING_1)\r\n        \r\n        self.download_key_Button = ttk.Button(settings_menu_download_center_Frame, image=self.key_img, command=lambda:self.pop_up_user_code_input())\r\n        self.download_key_Button.grid(pady=MENU_PADDING_1)\r\n                            \r\n        self.manual_download_Button = ttk.Button(settings_menu_download_center_Frame, text=TRY_MANUAL_DOWNLOAD_TEXT, command=self.menu_manual_downloads)\r\n        self.manual_download_Button.grid(pady=MENU_PADDING_1)\r\n\r\n        self.download_center_Buttons = (self.model_download_vr_Button,\r\n                                        self.model_download_mdx_Button,\r\n                                        self.model_download_demucs_Button,\r\n                                        self.download_Button,\r\n                                        self.download_key_Button)\r\n        \r\n        self.download_lists = (self.model_download_vr_Option,\r\n                               self.model_download_mdx_Option,\r\n                               self.model_download_demucs_Option)\r\n        \r\n        self.download_list_vars = (self.model_download_vr_var,\r\n                                   self.model_download_mdx_var,\r\n                                   self.model_download_demucs_var)\r\n        \r\n        self.online_data_refresh()\r\n\r\n        self.menu_placement(settings_menu, SETTINGS_GUIDE_TEXT, is_help_hints=True, close_function=lambda:close_window())\r\n\r\n        if select_tab_2:\r\n            tabControl.select(tab2)\r\n            settings_menu.update_idletasks()\r\n            \r\n        if select_tab_3:\r\n            tabControl.select(tab3)\r\n            settings_menu.update_idletasks()\r\n\r\n        def close_window():\r\n            self.active_download_thread.terminate() if self.thread_check(self.active_download_thread) else None\r\n            self.is_menu_settings_open = False\r\n            self.select_download_var.set('')\r\n            settings_menu.destroy()\r\n\r\n        #self.update_checkbox_text()\r\n        settings_menu.protocol(\"WM_DELETE_WINDOW\", close_window)\r\n\r\n    def menu_advanced_vr_options(self):#**\r\n        \"\"\"Open Advanced VR Options\"\"\"     \r\n\r\n        vr_opt = tk.Toplevel()\r\n        \r\n        tab1 = self.menu_tab_control(vr_opt, self.vr_secondary_model_vars)\r\n\r\n        self.is_open_menu_advanced_vr_options.set(True)\r\n        self.menu_advanced_vr_options_close_window = lambda:(self.is_open_menu_advanced_vr_options.set(False), vr_opt.destroy())\r\n        vr_opt.protocol(\"WM_DELETE_WINDOW\", self.menu_advanced_vr_options_close_window)\r\n        \r\n        toggle_post_process = lambda:self.post_process_threshold_Option.configure(state=READ_ONLY) if self.is_post_process_var.get() else self.post_process_threshold_Option.configure(state=tk.DISABLED)\r\n        \r\n        vr_opt_frame = self.menu_FRAME_SET(tab1)\r\n        vr_opt_frame.grid(pady=0 if not self.chosen_process_method_var.get() == VR_ARCH_PM else 70)  \r\n        \r\n        vr_title = self.menu_title_LABEL_SET(vr_opt_frame, ADVANCED_VR_OPTIONS_TEXT)\r\n        vr_title.grid(padx=25, pady=MENU_PADDING_2)\r\n  \r\n        if not self.chosen_process_method_var.get() == VR_ARCH_PM:\r\n            window_size_Label = self.menu_sub_LABEL_SET(vr_opt_frame, WINDOW_SIZE_TEXT)\r\n            window_size_Label.grid(pady=MENU_PADDING_1)\r\n            window_size_Option = ComboBoxEditableMenu(vr_opt_frame, values=VR_WINDOW, width=MENU_COMBOBOX_WIDTH, textvariable=self.window_size_var, pattern=REG_WINDOW, default=VR_WINDOW[1])#\r\n            window_size_Option.grid(pady=MENU_PADDING_1)\r\n            self.help_hints(window_size_Label, text=WINDOW_SIZE_HELP)\r\n            \r\n            aggression_setting_Label = self.menu_sub_LABEL_SET(vr_opt_frame, AGGRESSION_SETTING_TEXT)\r\n            aggression_setting_Label.grid(pady=MENU_PADDING_1)\r\n            aggression_setting_Option = ComboBoxEditableMenu(vr_opt_frame, values=VR_AGGRESSION, width=MENU_COMBOBOX_WIDTH, textvariable=self.aggression_setting_var, pattern=REG_AGGRESSION, default=VR_AGGRESSION[5])#\r\n            aggression_setting_Option.grid(pady=MENU_PADDING_1)\r\n            self.help_hints(aggression_setting_Label, text=AGGRESSION_SETTING_HELP)\r\n        \r\n        self.batch_size_Label = self.menu_sub_LABEL_SET(vr_opt_frame, BATCH_SIZE_TEXT)\r\n        self.batch_size_Label.grid(pady=MENU_PADDING_1)\r\n        self.batch_size_Option = ComboBoxEditableMenu(vr_opt_frame, values=BATCH_SIZE, width=MENU_COMBOBOX_WIDTH, textvariable=self.batch_size_var, pattern=REG_BATCHES, default=BATCH_SIZE)#\r\n        self.batch_size_Option.grid(pady=MENU_PADDING_1)\r\n        self.help_hints(self.batch_size_Label, text=BATCH_SIZE_HELP)\r\n        \r\n        self.post_process_threshold_Label = self.menu_sub_LABEL_SET(vr_opt_frame, POST_PROCESS_THRESHOLD_TEXT)\r\n        self.post_process_threshold_Label.grid(pady=MENU_PADDING_1)\r\n        self.post_process_threshold_Option = ComboBoxEditableMenu(vr_opt_frame, values=POST_PROCESSES_THREASHOLD_VALUES, width=MENU_COMBOBOX_WIDTH, textvariable=self.post_process_threshold_var, pattern=REG_THES_POSTPORCESS, default=POST_PROCESSES_THREASHOLD_VALUES[1])#\r\n        self.post_process_threshold_Option.grid(pady=MENU_PADDING_1)\r\n        self.help_hints(self.post_process_threshold_Label, text=POST_PROCESS_THREASHOLD_HELP)\r\n        \r\n        self.is_tta_Option = ttk.Checkbutton(vr_opt_frame, text=ENABLE_TTA_TEXT, width=VR_CHECKBOXS_WIDTH, variable=self.is_tta_var) \r\n        self.is_tta_Option.grid(pady=0)\r\n        self.help_hints(self.is_tta_Option, text=IS_TTA_HELP)\r\n        \r\n        self.is_post_process_Option = ttk.Checkbutton(vr_opt_frame, text=POST_PROCESS_TEXT, width=VR_CHECKBOXS_WIDTH, variable=self.is_post_process_var, command=toggle_post_process) \r\n        self.is_post_process_Option.grid(pady=0)\r\n        self.help_hints(self.is_post_process_Option, text=IS_POST_PROCESS_HELP)\r\n        \r\n        self.is_high_end_process_Option = ttk.Checkbutton(vr_opt_frame, text=HIGHEND_PROCESS_TEXT, width=VR_CHECKBOXS_WIDTH, variable=self.is_high_end_process_var) \r\n        self.is_high_end_process_Option.grid(pady=0)\r\n        self.help_hints(self.is_high_end_process_Option, text=IS_HIGH_END_PROCESS_HELP)\r\n        \r\n        self.vocal_splitter_Button_opt(vr_opt, vr_opt_frame, pady=MENU_PADDING_1, width=VR_BUT_WIDTH)\r\n        \r\n        self.vr_clear_cache_Button = ttk.Button(vr_opt_frame, text=CLEAR_AUTOSET_CACHE_TEXT, command=lambda:self.clear_cache(VR_ARCH_TYPE), width=VR_BUT_WIDTH)\r\n        self.vr_clear_cache_Button.grid(pady=MENU_PADDING_1)\r\n        self.help_hints(self.vr_clear_cache_Button, text=CLEAR_CACHE_HELP)\r\n        \r\n        self.open_vr_model_dir_Button = ttk.Button(vr_opt_frame, text=OPEN_MODELS_FOLDER_TEXT, command=lambda:OPEN_FILE_func(VR_MODELS_DIR), width=VR_BUT_WIDTH)\r\n        self.open_vr_model_dir_Button.grid(pady=MENU_PADDING_1)\r\n        \r\n        self.vr_return_Button=ttk.Button(vr_opt_frame, text=BACK_TO_MAIN_MENU, command=lambda:(self.menu_advanced_vr_options_close_window(), self.check_is_menu_settings_open()))\r\n        self.vr_return_Button.grid(pady=MENU_PADDING_1)\r\n\r\n        self.vr_close_Button = ttk.Button(vr_opt_frame, text=CLOSE_WINDOW, command=lambda:self.menu_advanced_vr_options_close_window())\r\n        self.vr_close_Button.grid(pady=MENU_PADDING_1)\r\n        \r\n        toggle_post_process()\r\n        \r\n        frame_list = [vr_opt_frame]\r\n        self.menu_placement(vr_opt, ADVANCED_VR_OPTIONS_TEXT, is_help_hints=True, close_function=self.menu_advanced_vr_options_close_window, frame_list=frame_list)\r\n\r\n    def menu_advanced_demucs_options(self):#**\r\n        \"\"\"Open Advanced Demucs Options\"\"\"\r\n        \r\n        demuc_opt = tk.Toplevel()\r\n\r\n        self.is_open_menu_advanced_demucs_options.set(True)\r\n        self.menu_advanced_demucs_options_close_window = lambda:(self.is_open_menu_advanced_demucs_options.set(False), demuc_opt.destroy())\r\n        demuc_opt.protocol(\"WM_DELETE_WINDOW\", self.menu_advanced_demucs_options_close_window)\r\n\r\n        tab1, tab3 = self.menu_tab_control(demuc_opt, self.demucs_secondary_model_vars, is_demucs=True)\r\n        \r\n        demucs_frame = self.menu_FRAME_SET(tab1)\r\n        demucs_frame.grid(pady=0 if not self.chosen_process_method_var.get() == DEMUCS_ARCH_TYPE else 55)  \r\n        \r\n        demucs_pre_model_frame = self.menu_FRAME_SET(tab3)\r\n        demucs_pre_model_frame.grid(row=0)  \r\n        \r\n        demucs_title_Label = self.menu_title_LABEL_SET(demucs_frame, ADVANCED_DEMUCS_OPTIONS_TEXT)\r\n        demucs_title_Label.grid(pady=MENU_PADDING_2)\r\n        \r\n        if not self.chosen_process_method_var.get() == DEMUCS_ARCH_TYPE:\r\n            segment_Label = self.menu_sub_LABEL_SET(demucs_frame, SEGMENTS_TEXT)\r\n            segment_Label.grid(pady=MENU_PADDING_2)\r\n            segment_Option = ComboBoxEditableMenu(demucs_frame, values=DEMUCS_SEGMENTS, width=MENU_COMBOBOX_WIDTH, textvariable=self.segment_var, pattern=REG_SEGMENTS, default=DEMUCS_SEGMENTS)#\r\n            segment_Option.grid()\r\n            self.help_hints(segment_Label, text=SEGMENT_HELP)\r\n        \r\n        self.shifts_Label = self.menu_sub_LABEL_SET(demucs_frame, SHIFTS_TEXT)\r\n        self.shifts_Label.grid(pady=MENU_PADDING_1)\r\n        self.shifts_Option = ComboBoxEditableMenu(demucs_frame, values=DEMUCS_SHIFTS, width=MENU_COMBOBOX_WIDTH, textvariable=self.shifts_var, pattern=REG_SHIFTS, default=DEMUCS_SHIFTS[2])#\r\n        self.shifts_Option.grid(pady=MENU_PADDING_1)\r\n        self.help_hints(self.shifts_Label, text=SHIFTS_HELP)\r\n\r\n        self.overlap_Label = self.menu_sub_LABEL_SET(demucs_frame, OVERLAP_TEXT)\r\n        self.overlap_Label.grid(pady=MENU_PADDING_1)\r\n        self.overlap_Option = ComboBoxEditableMenu(demucs_frame, values=DEMUCS_OVERLAP, width=MENU_COMBOBOX_WIDTH, textvariable=self.overlap_var, pattern=REG_OVERLAP, default=DEMUCS_OVERLAP)#\r\n        self.overlap_Option.grid(pady=MENU_PADDING_1)\r\n        self.help_hints(self.overlap_Label, text=OVERLAP_HELP)\r\n\r\n        pitch_shift_Label = self.menu_sub_LABEL_SET(demucs_frame, SHIFT_CONVERSION_PITCH_TEXT)\r\n        pitch_shift_Label.grid(pady=MENU_PADDING_1)\r\n        pitch_shift_Option = ComboBoxEditableMenu(demucs_frame, values=SEMITONE_SEL, width=MENU_COMBOBOX_WIDTH, textvariable=self.semitone_shift_var, pattern=REG_SEMITONES, default=SEMI_DEF)#\r\n        pitch_shift_Option.grid(pady=MENU_PADDING_1)\r\n        self.help_hints(pitch_shift_Label, text=PITCH_SHIFT_HELP)\r\n\r\n        self.is_split_mode_Option = ttk.Checkbutton(demucs_frame, text=SPLIT_MODE_TEXT, width=DEMUCS_CHECKBOXS_WIDTH, variable=self.is_split_mode_var) \r\n        self.is_split_mode_Option.grid()\r\n        self.help_hints(self.is_split_mode_Option, text=IS_SPLIT_MODE_HELP)\r\n        \r\n        self.is_demucs_combine_stems_Option = ttk.Checkbutton(demucs_frame, text=COMBINE_STEMS_TEXT, width=DEMUCS_CHECKBOXS_WIDTH, variable=self.is_demucs_combine_stems_var) \r\n        self.is_demucs_combine_stems_Option.grid()\r\n        self.help_hints(self.is_demucs_combine_stems_Option, text=IS_DEMUCS_COMBINE_STEMS_HELP)\r\n        \r\n        is_invert_spec_Option = ttk.Checkbutton(demucs_frame, text=SPECTRAL_INVERSION_TEXT, width=DEMUCS_CHECKBOXS_WIDTH, variable=self.is_invert_spec_var) \r\n        is_invert_spec_Option.grid()\r\n        self.help_hints(is_invert_spec_Option, text=IS_INVERT_SPEC_HELP)\r\n        \r\n        self.vocal_splitter_Button_opt(demuc_opt, demucs_frame, width=VR_BUT_WIDTH, pady=MENU_PADDING_1)\r\n        \r\n        self.open_demucs_model_dir_Button = ttk.Button(demucs_frame, text=OPEN_MODELS_FOLDER_TEXT, command=lambda:OPEN_FILE_func(DEMUCS_MODELS_DIR), width=VR_BUT_WIDTH)\r\n        self.open_demucs_model_dir_Button.grid(pady=MENU_PADDING_1)\r\n        \r\n        self.demucs_return_Button = ttk.Button(demucs_frame, text=BACK_TO_MAIN_MENU, command=lambda:(self.menu_advanced_demucs_options_close_window(), self.check_is_menu_settings_open()))\r\n        self.demucs_return_Button.grid(pady=MENU_PADDING_1)\r\n        \r\n        self.demucs_close_Button = ttk.Button(demucs_frame, text=CLOSE_WINDOW, command=lambda:self.menu_advanced_demucs_options_close_window())\r\n        self.demucs_close_Button.grid(pady=MENU_PADDING_1)\r\n        \r\n        frame_list = [demucs_pre_model_frame, demucs_frame]\r\n        self.menu_placement(demuc_opt, ADVANCED_DEMUCS_OPTIONS_TEXT, is_help_hints=True, close_function=self.menu_advanced_demucs_options_close_window, frame_list=frame_list)\r\n        \r\n    def menu_advanced_mdx_options(self):#**\r\n        \"\"\"Open Advanced MDX Options\"\"\"\r\n\r\n        mdx_net_opt = tk.Toplevel()\r\n\r\n        self.is_open_menu_advanced_mdx_options.set(True)\r\n        self.menu_advanced_mdx_options_close_window = lambda:(self.is_open_menu_advanced_mdx_options.set(False), mdx_net_opt.destroy())\r\n        mdx_net_opt.protocol(\"WM_DELETE_WINDOW\", self.menu_advanced_mdx_options_close_window)\r\n\r\n        tab1, tab3 = self.menu_tab_control(mdx_net_opt, self.mdx_secondary_model_vars, is_mdxnet=True)\r\n        \r\n        mdx_net_frame = self.menu_FRAME_SET(tab1)\r\n        mdx_net_frame.grid(pady=0)  \r\n\r\n        mdx_net23_frame = self.menu_FRAME_SET(tab3)\r\n        mdx_net23_frame.grid(pady=0)\r\n\r\n        mdx_opt_title = self.menu_title_LABEL_SET(mdx_net_frame, ADVANCED_MDXNET_OPTIONS_TEXT)\r\n        mdx_opt_title.grid(pady=MENU_PADDING_1)\r\n        \r\n        compensate_Label = self.menu_sub_LABEL_SET(mdx_net_frame, VOLUME_COMPENSATION_TEXT)\r\n        compensate_Label.grid(pady=MENU_PADDING_4)\r\n        compensate_Option = ComboBoxEditableMenu(mdx_net_frame, values=VOL_COMPENSATION, width=MENU_COMBOBOX_WIDTH, textvariable=self.compensate_var, pattern=REG_COMPENSATION, default=VOL_COMPENSATION)#\r\n        compensate_Option.grid(pady=MENU_PADDING_4)\r\n        self.help_hints(compensate_Label, text=COMPENSATE_HELP)\r\n\r\n        mdx_segment_size_Label = self.menu_sub_LABEL_SET(mdx_net_frame, SEGMENT_SIZE_TEXT)\r\n        mdx_segment_size_Label.grid(pady=MENU_PADDING_4)\r\n        mdx_segment_size_Option = ComboBoxEditableMenu(mdx_net_frame, values=MDX_SEGMENTS, width=MENU_COMBOBOX_WIDTH, textvariable=self.mdx_segment_size_var, pattern=REG_MDX_SEG, default=\"256\")#\r\n        mdx_segment_size_Option.grid(pady=MENU_PADDING_4)\r\n        self.help_hints(mdx_segment_size_Label, text=MDX_SEGMENT_SIZE_HELP)\r\n\r\n        overlap_mdx_Label = self.menu_sub_LABEL_SET(mdx_net_frame, OVERLAP_TEXT)\r\n        overlap_mdx_Label.grid(pady=MENU_PADDING_4)\r\n        overlap_mdx_Option = ComboBoxEditableMenu(mdx_net_frame, values=MDX_OVERLAP, width=MENU_COMBOBOX_WIDTH, textvariable=self.overlap_mdx_var, pattern=REG_OVERLAP, default=MDX_OVERLAP)#\r\n        overlap_mdx_Option.grid(pady=MENU_PADDING_4)\r\n        self.help_hints(overlap_mdx_Label, text=OVERLAP_HELP)\r\n\r\n        pitch_shift_Label = self.menu_sub_LABEL_SET(mdx_net_frame, SHIFT_CONVERSION_PITCH_TEXT)\r\n        pitch_shift_Label.grid(pady=MENU_PADDING_4)\r\n        pitch_shift_Option = ComboBoxEditableMenu(mdx_net_frame, values=SEMITONE_SEL, width=MENU_COMBOBOX_WIDTH, textvariable=self.semitone_shift_var, pattern=REG_SEMITONES, default=SEMI_DEF)#\r\n        pitch_shift_Option.grid(pady=MENU_PADDING_4)\r\n        self.help_hints(pitch_shift_Label, text=PITCH_SHIFT_HELP)\r\n        \r\n        if not os.path.isfile(DENOISER_MODEL_PATH):\r\n            denoise_options_var_text = self.denoise_option_var.get()\r\n            denoise_options = [option for option in MDX_DENOISE_OPTION if option != DENOISE_M]\r\n            self.denoise_option_var.set(DENOISE_S if denoise_options_var_text == DENOISE_M else denoise_options_var_text)\r\n        else:\r\n            denoise_options = MDX_DENOISE_OPTION\r\n            \r\n        denoise_option_Label = self.menu_sub_LABEL_SET(mdx_net_frame, DENOISE_OUTPUT_TEXT)\r\n        denoise_option_Label.grid(pady=MENU_PADDING_4)\r\n        denoise_option_Option = ComboBoxMenu(mdx_net_frame, textvariable=self.denoise_option_var, values=denoise_options, width=MENU_COMBOBOX_WIDTH)\r\n        denoise_option_Option.grid(pady=MENU_PADDING_4)\r\n        self.help_hints(denoise_option_Label, text=IS_DENOISE_HELP)\r\n\r\n        is_match_frequency_pitch_Option = ttk.Checkbutton(mdx_net_frame, text=MATCH_FREQ_CUTOFF_TEXT, width=MDX_CHECKBOXS_WIDTH, variable=self.is_match_frequency_pitch_var) \r\n        is_match_frequency_pitch_Option.grid(pady=0)\r\n        self.help_hints(is_match_frequency_pitch_Option, text=IS_FREQUENCY_MATCH_HELP)\r\n\r\n        is_invert_spec_Option = ttk.Checkbutton(mdx_net_frame, text=SPECTRAL_INVERSION_TEXT, width=MDX_CHECKBOXS_WIDTH, variable=self.is_invert_spec_var) \r\n        is_invert_spec_Option.grid(pady=0)\r\n        self.help_hints(is_invert_spec_Option, text=IS_INVERT_SPEC_HELP)\r\n        \r\n        self.vocal_splitter_Button_opt(mdx_net_opt, mdx_net_frame, pady=MENU_PADDING_1, width=VR_BUT_WIDTH)\r\n\r\n        clear_mdx_cache_Button = ttk.Button(mdx_net_frame, text=CLEAR_AUTOSET_CACHE_TEXT, command=lambda:self.clear_cache(MDX_ARCH_TYPE), width=VR_BUT_WIDTH)\r\n        clear_mdx_cache_Button.grid(pady=MENU_PADDING_1)\r\n        self.help_hints(clear_mdx_cache_Button, text=CLEAR_CACHE_HELP)\r\n        \r\n        open_mdx_model_dir_Button = ttk.Button(mdx_net_frame, text=OPEN_MODELS_FOLDER_TEXT, command=lambda:OPEN_FILE_func(MDX_MODELS_DIR), width=VR_BUT_WIDTH)\r\n        open_mdx_model_dir_Button.grid(pady=MENU_PADDING_1)\r\n        \r\n        mdx_return_Button = ttk.Button(mdx_net_frame, text=BACK_TO_MAIN_MENU, command=lambda:(self.menu_advanced_mdx_options_close_window(), self.check_is_menu_settings_open()))\r\n        mdx_return_Button.grid(pady=MENU_PADDING_1)\r\n\r\n        mdx_close_Button = ttk.Button(mdx_net_frame, text=CLOSE_WINDOW, command=lambda:self.menu_advanced_mdx_options_close_window())\r\n        mdx_close_Button.grid(pady=MENU_PADDING_1)\r\n        \r\n        mdx23_opt_title = self.menu_title_LABEL_SET(mdx_net23_frame, ADVANCED_MDXNET23_OPTIONS_TEXT)\r\n        mdx23_opt_title.grid(pady=MENU_PADDING_2)\r\n        \r\n        mdx_batch_size_Label = self.menu_sub_LABEL_SET(mdx_net23_frame, BATCH_SIZE_TEXT)\r\n        mdx_batch_size_Label.grid(pady=MENU_PADDING_1)\r\n        mdx_batch_size_Option = ComboBoxEditableMenu(mdx_net23_frame, values=BATCH_SIZE, width=MENU_COMBOBOX_WIDTH, textvariable=self.mdx_batch_size_var, pattern=REG_BATCHES, default=BATCH_SIZE)#\r\n        mdx_batch_size_Option.grid(pady=MENU_PADDING_1)\r\n        self.help_hints(mdx_batch_size_Label, text=BATCH_SIZE_HELP)\r\n        \r\n        overlap_mdx23_Label = self.menu_sub_LABEL_SET(mdx_net23_frame, OVERLAP_TEXT)\r\n        overlap_mdx23_Label.grid(pady=MENU_PADDING_1)\r\n        overlap_mdx23_Option = ComboBoxEditableMenu(mdx_net23_frame, values=MDX23_OVERLAP, width=MENU_COMBOBOX_WIDTH, textvariable=self.overlap_mdx23_var, pattern=REG_OVERLAP23, default=\"8\")#\r\n        overlap_mdx23_Option.grid(pady=MENU_PADDING_1)\r\n        self.help_hints(overlap_mdx23_Label, text=OVERLAP_23_HELP)\r\n        \r\n        is_mdx_c_seg_def_Option = ttk.Checkbutton(mdx_net23_frame, text=SEGMENT_DEFAULT_TEXT, width=MDX_CHECKBOXS_WIDTH, variable=self.is_mdx_c_seg_def_var) \r\n        is_mdx_c_seg_def_Option.grid(pady=0)\r\n        self.help_hints(is_mdx_c_seg_def_Option, text=IS_SEGMENT_DEFAULT_HELP)\r\n        \r\n        is_mdx_combine_stems_Option = ttk.Checkbutton(mdx_net23_frame, text=COMBINE_STEMS_TEXT, width=MDX_CHECKBOXS_WIDTH, variable=self.is_mdx23_combine_stems_var)\r\n        is_mdx_combine_stems_Option.grid()\r\n        self.help_hints(is_mdx_combine_stems_Option, text=IS_DEMUCS_COMBINE_STEMS_HELP)\r\n        \r\n        mdx23_close_Button = ttk.Button(mdx_net23_frame, text=CLOSE_WINDOW, command=lambda:self.menu_advanced_mdx_options_close_window())\r\n        mdx23_close_Button.grid(pady=MENU_PADDING_2)\r\n        \r\n        frame_list = [mdx_net_frame, mdx_net23_frame]\r\n        self.menu_placement(mdx_net_opt, ADVANCED_MDXNET_OPTIONS_TEXT, is_help_hints=True, close_function=self.menu_advanced_mdx_options_close_window, frame_list=frame_list)\r\n\r\n    def menu_advanced_ensemble_options(self):#**\r\n        \"\"\"Open Ensemble Custom\"\"\"\r\n        \r\n        custom_ens_opt = tk.Toplevel()\r\n        \r\n        self.is_open_menu_advanced_ensemble_options.set(True)\r\n        self.menu_advanced_ensemble_options_close_window = lambda:(self.is_open_menu_advanced_ensemble_options.set(False), custom_ens_opt.destroy())\r\n        custom_ens_opt.protocol(\"WM_DELETE_WINDOW\", self.menu_advanced_ensemble_options_close_window)\r\n\r\n        option_var = tk.StringVar(value=SELECT_SAVED_ENSEMBLE)\r\n\r\n        custom_ens_opt_frame = self.menu_FRAME_SET(custom_ens_opt)\r\n        custom_ens_opt_frame.grid(row=0)  \r\n        \r\n        settings_title_Label = self.menu_title_LABEL_SET(custom_ens_opt_frame, ADVANCED_OPTION_MENU_TEXT)\r\n        settings_title_Label.grid(pady=MENU_PADDING_2)\r\n        \r\n        delete_entry_Label = self.menu_sub_LABEL_SET(custom_ens_opt_frame, REMOVE_SAVED_ENSEMBLE_TEXT)\r\n        delete_entry_Label.grid(pady=MENU_PADDING_1)\r\n        delete_entry_Option = ComboBoxMenu(custom_ens_opt_frame, textvariable=option_var, width=ENSEMBLE_CHECKBOXS_WIDTH+2)\r\n        delete_entry_Option.grid(padx=20,pady=MENU_PADDING_1)\r\n        \r\n        is_save_all_outputs_ensemble_Option = ttk.Checkbutton(custom_ens_opt_frame, text=SAVE_ALL_OUTPUTS_TEXT, width=ENSEMBLE_CHECKBOXS_WIDTH, variable=self.is_save_all_outputs_ensemble_var)\r\n        is_save_all_outputs_ensemble_Option.grid(pady=0)\r\n        self.help_hints(is_save_all_outputs_ensemble_Option, text=IS_SAVE_ALL_OUTPUTS_ENSEMBLE_HELP)\r\n\r\n        is_append_ensemble_name_Option = ttk.Checkbutton(custom_ens_opt_frame, text=APPEND_ENSEMBLE_NAME_TEXT, width=ENSEMBLE_CHECKBOXS_WIDTH, variable=self.is_append_ensemble_name_var) \r\n        is_append_ensemble_name_Option.grid(pady=0)\r\n        self.help_hints(is_append_ensemble_name_Option, text=IS_APPEND_ENSEMBLE_NAME_HELP)\r\n\r\n        is_wav_ensemble_Option = ttk.Checkbutton(custom_ens_opt_frame, text=ENSEMBLE_WAVFORMS_TEXT, width=ENSEMBLE_CHECKBOXS_WIDTH, variable=self.is_wav_ensemble_var) \r\n        is_wav_ensemble_Option.grid(pady=0)\r\n        self.help_hints(is_wav_ensemble_Option, text=IS_WAV_ENSEMBLE_HELP)\r\n\r\n        ensemble_return_Button = ttk.Button(custom_ens_opt_frame, text=BACK_TO_MAIN_MENU, command=lambda:(self.menu_advanced_ensemble_options_close_window(), self.check_is_menu_settings_open()))\r\n        ensemble_return_Button.grid(pady=MENU_PADDING_1)\r\n        \r\n        ensemble_close_Button = ttk.Button(custom_ens_opt_frame, text=CLOSE_WINDOW, command=lambda:self.menu_advanced_ensemble_options_close_window())\r\n        ensemble_close_Button.grid(pady=MENU_PADDING_1)\r\n        \r\n        self.deletion_list_fill(delete_entry_Option, option_var, ENSEMBLE_CACHE_DIR, SELECT_SAVED_ENSEMBLE, menu_name='deleteensemble')\r\n        \r\n        self.menu_placement(custom_ens_opt, ADVANCED_ENSEMBLE_OPTIONS_TEXT, is_help_hints=True, close_function=self.menu_advanced_ensemble_options_close_window)\r\n\r\n    def menu_advanced_align_options(self):#**\r\n        \"\"\"Open Ensemble Custom\"\"\"\r\n        \r\n        advanced_align_opt = tk.Toplevel()\r\n        \r\n        self.is_open_menu_advanced_align_options.set(True)\r\n        self.menu_advanced_align_options_close_window = lambda:(self.is_open_menu_advanced_align_options.set(False), advanced_align_opt.destroy())\r\n        advanced_align_opt.protocol(\"WM_DELETE_WINDOW\", self.menu_advanced_align_options_close_window)\r\n\r\n        advanced_align_opt_frame = self.menu_FRAME_SET(advanced_align_opt)\r\n        advanced_align_opt_frame.grid(row=0)  \r\n        \r\n        settings_title_Label = self.menu_title_LABEL_SET(advanced_align_opt_frame, ADVANCED_ALIGN_TOOL_OPTIONS_TEXT)\r\n        settings_title_Label.grid(pady=MENU_PADDING_2)\r\n        \r\n        phase_option_Label = self.menu_sub_LABEL_SET(advanced_align_opt_frame, SECONDARY_PHASE_TEXT)\r\n        phase_option_Label.grid(pady=4)\r\n        phase_option_Option = ComboBoxMenu(advanced_align_opt_frame, textvariable=self.phase_option_var, values=ALIGN_PHASE_OPTIONS, width=MENU_COMBOBOX_WIDTH)\r\n        phase_option_Option.grid(pady=4)\r\n        self.help_hints(phase_option_Label, text=IS_PHASE_HELP)\r\n        \r\n        phase_shifts_Label = self.menu_sub_LABEL_SET(advanced_align_opt_frame, PHASE_SHIFTS_TEXT)\r\n        phase_shifts_Label.grid(pady=4)#\r\n        phase_shifts_Option = ComboBoxMenu(advanced_align_opt_frame, textvariable=self.phase_shifts_var, values=list(PHASE_SHIFTS_OPT.keys()), width=MENU_COMBOBOX_WIDTH)\r\n        phase_shifts_Option.grid(pady=4)\r\n        self.help_hints(phase_shifts_Label, text=PHASE_SHIFTS_ALIGN_HELP)\r\n        \r\n        is_save_align_Option = ttk.Checkbutton(advanced_align_opt_frame, text=SAVE_ALIGNED_TRACK_TEXT, width=MDX_CHECKBOXS_WIDTH, variable=self.is_save_align_var)\r\n        is_save_align_Option.grid(pady=0)\r\n        self.help_hints(is_save_align_Option, text=IS_ALIGN_TRACK_HELP)\r\n        \r\n        is_match_silence_Option = ttk.Checkbutton(advanced_align_opt_frame, text=SILENCE_MATCHING_TEXT, width=MDX_CHECKBOXS_WIDTH, variable=self.is_match_silence_var)\r\n        is_match_silence_Option.grid(pady=0)\r\n        self.help_hints(is_match_silence_Option, text=IS_MATCH_SILENCE_HELP)\r\n\r\n        is_spec_match_Option = ttk.Checkbutton(advanced_align_opt_frame, text=SPECTRAL_MATCHING_TEXT, width=MDX_CHECKBOXS_WIDTH, variable=self.is_spec_match_var)\r\n        is_spec_match_Option.grid(pady=0)\r\n        self.help_hints(is_spec_match_Option, text=IS_MATCH_SPEC_HELP)\r\n\r\n        ensemble_return_Button = ttk.Button(advanced_align_opt_frame, text=BACK_TO_MAIN_MENU, command=lambda:(self.menu_advanced_align_options_close_window(), self.check_is_menu_settings_open()))\r\n        ensemble_return_Button.grid(pady=MENU_PADDING_1)\r\n        \r\n        ensemble_close_Button = ttk.Button(advanced_align_opt_frame, text=CLOSE_WINDOW, command=lambda:self.menu_advanced_align_options_close_window())\r\n        ensemble_close_Button.grid(pady=MENU_PADDING_1)\r\n        \r\n        self.menu_placement(advanced_align_opt, ADVANCED_ALIGN_TOOL_OPTIONS_TEXT, is_help_hints=True, close_function=self.menu_advanced_align_options_close_window)\r\n \r\n    def menu_help(self):#**\r\n        \"\"\"Open Help Guide\"\"\"\r\n        \r\n        help_guide_opt = tk.Toplevel()\r\n\r\n        self.is_open_menu_help.set(True)\r\n        self.menu_help_close_window = lambda:(self.is_open_menu_help.set(False), help_guide_opt.destroy())\r\n        help_guide_opt.protocol(\"WM_DELETE_WINDOW\", self.menu_help_close_window)\r\n        \r\n        tabControl = ttk.Notebook(help_guide_opt)\r\n\r\n        tab1 = ttk.Frame(tabControl)\r\n        tab2 = ttk.Frame(tabControl)\r\n        tab3 = ttk.Frame(tabControl)\r\n        tab4 = ttk.Frame(tabControl)\r\n\r\n        tabControl.add(tab1, text ='Credits')\r\n        tabControl.add(tab2, text ='Resources')\r\n        tabControl.add(tab3, text ='Application License & Version Information')\r\n        tabControl.add(tab4, text ='Additional Information')\r\n\r\n        tabControl.pack(expand = 1, fill =\"both\")\r\n        \r\n        tab1.grid_rowconfigure(0, weight=1)\r\n        tab1.grid_columnconfigure(0, weight=1)\r\n        \r\n        tab2.grid_rowconfigure(0, weight=1)\r\n        tab2.grid_columnconfigure(0, weight=1)\r\n        \r\n        tab3.grid_rowconfigure(0, weight=1)\r\n        tab3.grid_columnconfigure(0, weight=1)\r\n        \r\n        tab4.grid_rowconfigure(0, weight=1)\r\n        tab4.grid_columnconfigure(0, weight=1)\r\n        \r\n        section_title_Label = lambda place, frame, text, font_size=FONT_SIZE_4: tk.Label(master=frame, text=text,font=(MAIN_FONT_NAME, f\"{font_size}\", \"bold\"), justify=\"center\", fg=\"#F4F4F4\").grid(row=place,column=0,padx=0,pady=MENU_PADDING_4)\r\n        description_Label = lambda place, frame, text, font=FONT_SIZE_2: tk.Label(master=frame, text=text, font=(MAIN_FONT_NAME, f\"{font}\"), justify=\"center\", fg=\"#F6F6F7\").grid(row=place,column=0,padx=0,pady=MENU_PADDING_4)\r\n\r\n        def credit_label(place, frame, text, link=None, message=None, is_link=False, is_top=False):\r\n            if is_top:\r\n                thank = tk.Label(master=frame, text=text, font=(MAIN_FONT_NAME, f\"{FONT_SIZE_3}\", \"bold\"), justify=\"center\", fg=\"#13849f\")\r\n            else:\r\n                thank = tk.Label(master=frame, text=text, font=(MAIN_FONT_NAME, f\"{FONT_SIZE_3}\", \"underline\" if is_link else \"normal\"), justify=\"center\", fg=\"#13849f\")\r\n            thank.configure(cursor=\"hand2\") if is_link else None\r\n            thank.grid(row=place,column=0,padx=0,pady=1)\r\n            if link:\r\n                thank.bind(\"<Button-1>\", lambda e:webbrowser.open_new_tab(link))\r\n            if message:\r\n                description_Label(place+1, frame, message)\r\n        \r\n        def Link(place, frame, text, link, description, font=FONT_SIZE_2): \r\n            link_label = tk.Label(master=frame, text=text, font=(MAIN_FONT_NAME, f\"{FONT_SIZE_4}\", \"underline\"), foreground=FG_COLOR, justify=\"center\", cursor=\"hand2\")\r\n            link_label.grid(row=place,column=0,padx=0,pady=MENU_PADDING_1)\r\n            link_label.bind(\"<Button-1>\", lambda e:webbrowser.open_new_tab(link))\r\n            description_Label(place+1, frame, description, font=font)\r\n\r\n        def right_click_menu(event):\r\n                right_click_menu = tk.Menu(self, font=(MAIN_FONT_NAME, FONT_SIZE_1), tearoff=0)\r\n                right_click_menu.add_command(label='Return to Settings Menu', command=lambda:(self.menu_help_close_window(), self.check_is_menu_settings_open()))\r\n                right_click_menu.add_command(label='Exit Window', command=lambda:self.menu_help_close_window())\r\n                \r\n                try:\r\n                    right_click_menu.tk_popup(event.x_root,event.y_root)\r\n                    right_click_release_linux(right_click_menu, help_guide_opt)\r\n                finally:\r\n                    right_click_menu.grab_release()\r\n\r\n        help_guide_opt.bind(right_click_button, lambda e:right_click_menu(e))\r\n        credits_Frame = tk.Frame(tab1, highlightthicknes=50)\r\n        credits_Frame.grid(row=0, column=0, padx=0, pady=0)\r\n        tk.Label(credits_Frame, image=self.credits_img).grid(row=1,column=0,padx=0,pady=MENU_PADDING_1)\r\n\r\n        section_title_Label(place=0,\r\n                            frame=credits_Frame,\r\n                            text=\"Core UVR Developers\")\r\n        \r\n        credit_label(place=2,\r\n                     frame=credits_Frame,\r\n                     text=\"Anjok07\\nAufr33\",\r\n                     is_top=True)\r\n        \r\n        section_title_Label(place=3,\r\n                            frame=credits_Frame,\r\n                            text=\"Special Thanks\")\r\n        \r\n        credit_label(place=6,\r\n                     frame=credits_Frame,\r\n                     text=\"Tsurumeso\",\r\n                     message=\"Developed the original VR Architecture AI code.\",\r\n                     link=\"https://github.com/tsurumeso/vocal-remover\",\r\n                     is_link=True)\r\n        \r\n        credit_label(place=8,\r\n                     frame=credits_Frame,\r\n                     text=\"Kuielab & Woosung Choi\",\r\n                     message=\"Developed the original MDX-Net AI code.\",\r\n                     link=\"https://github.com/kuielab\",\r\n                     is_link=True)\r\n        \r\n        credit_label(place=10,\r\n                     frame=credits_Frame,\r\n                     text=\"Adefossez & Demucs\",\r\n                     message=\"Core developer of Facebook's Demucs Music Source Separation.\",\r\n                     link=\"https://github.com/facebookresearch/demucs\",\r\n                     is_link=True)\r\n        \r\n        credit_label(place=12,\r\n                     frame=credits_Frame,\r\n                     text=\"Bas Curtiz\",\r\n                     message=\"Designed the official UVR logo, icon, banner, splash screen.\")\r\n        \r\n        credit_label(place=14,\r\n                     frame=credits_Frame,\r\n                     text=\"DilanBoskan\",\r\n                     message=\"Your contributions at the start of this project were essential to the success of UVR. Thank you!\")\r\n        \r\n        credit_label(place=16,\r\n                     frame=credits_Frame,\r\n                     text=\"Audio Separation and CC Karaoke & Friends Discord Communities\",\r\n                     message=\"Thank you for the support!\")\r\n\r\n        more_info_tab_Frame = tk.Frame(tab2, highlightthicknes=30)\r\n        more_info_tab_Frame.grid(row=0,column=0,padx=0,pady=0)\r\n\r\n        section_title_Label(place=3, \r\n                            frame=more_info_tab_Frame, \r\n                            text=\"Resources\")\r\n\r\n        Link(place=4, \r\n             frame=more_info_tab_Frame, \r\n             text=\"Ultimate Vocal Remover (Official GitHub)\", \r\n             link=\"https://github.com/Anjok07/ultimatevocalremovergui\", \r\n             description=\"You can find updates, report issues, and give us a shout via our official GitHub.\",\r\n             font=FONT_SIZE_1)\r\n        \r\n        Link(place=8, \r\n             frame=more_info_tab_Frame, \r\n             text=\"X-Minus AI\", \r\n             link=\"https://x-minus.pro/ai\", \r\n             description=\"Many of the models provided are also on X-Minus.\\n\" + \\\r\n                         \"X-Minus benefits users without the computing resources to run the GUI or models locally.\",\r\n             font=FONT_SIZE_1)\r\n        \r\n        Link(place=12, \r\n             frame=more_info_tab_Frame, \r\n             text=\"MVSep\", \r\n             link=\"https://mvsep.com/quality_checker/leaderboard.php\", \r\n             description=\"Some of our models are also on MVSep.\\n\" + \\\r\n                         \"Click the link above for a list of some of the best settings \\nand model combinations recorded by fellow UVR users.\\nSpecial thanks to ZFTurbo for all his work on MVSep!\",\r\n             font=FONT_SIZE_1)\r\n        \r\n        Link(place=18, \r\n             frame=more_info_tab_Frame, \r\n             text=\"FFmpeg\", \r\n             link=\"https://www.wikihow.com/Install-FFmpeg-on-Windows\", \r\n             description=\"UVR relies on FFmpeg for processing non-wav audio files.\\n\" + \\\r\n                         \"If you are missing FFmpeg, please see the installation guide via the link provided.\",\r\n             font=FONT_SIZE_1)\r\n        \r\n        Link(place=22, \r\n             frame=more_info_tab_Frame, \r\n             text=\"Rubber Band Library\", \r\n             link=\"https://breakfastquay.com/rubberband/\",\r\n             description=\"UVR uses the Rubber Band library for the sound stretch and pitch shift tool.\\n\" + \\\r\n                         \"You can get more information on it via the link provided.\",\r\n             font=FONT_SIZE_1)\r\n        \r\n        Link(place=26, \r\n             frame=more_info_tab_Frame, \r\n             text=\"Matchering\", \r\n             link=\"https://github.com/sergree/matchering\",\r\n             description=\"UVR uses the Matchering library for the \\\"Matchering\\\" Audio Tool.\\n\" + \\\r\n                         \"You can get more information on it via the link provided.\",\r\n             font=FONT_SIZE_1)\r\n        \r\n        Link(place=30, \r\n             frame=more_info_tab_Frame, \r\n             text=\"Official UVR BMAC\", \r\n             link=DONATE_LINK_BMAC, \r\n             description=\"If you wish to support and donate to this project, click the link above!\",\r\n             font=FONT_SIZE_1)\r\n        \r\n        appplication_license_tab_Frame = tk.Frame(tab3)\r\n        appplication_license_tab_Frame.grid(row=0,column=0,padx=0,pady=0)\r\n        \r\n        appplication_license_Label = tk.Label(appplication_license_tab_Frame, text='UVR License Information', font=(MAIN_FONT_NAME, f\"{FONT_SIZE_6}\", \"bold\"), justify=\"center\", fg=\"#f4f4f4\")\r\n        appplication_license_Label.grid(row=0,column=0,padx=0,pady=25)\r\n        \r\n        appplication_license_Text = tk.Text(appplication_license_tab_Frame, font=(MAIN_FONT_NAME, f\"{FONT_SIZE_4}\"), fg=\"white\", bg=\"black\", width=72, wrap=tk.WORD, borderwidth=0)\r\n        appplication_license_Text.grid(row=1,column=0,padx=0,pady=0)\r\n        appplication_license_Text_scroll = ttk.Scrollbar(appplication_license_tab_Frame, orient=tk.VERTICAL)\r\n        appplication_license_Text.config(yscrollcommand=appplication_license_Text_scroll.set)\r\n        appplication_license_Text_scroll.configure(command=appplication_license_Text.yview)\r\n        appplication_license_Text.grid(row=4,sticky=tk.W)\r\n        appplication_license_Text_scroll.grid(row=4, column=1, sticky=tk.NS)\r\n        appplication_license_Text.insert(\"insert\", LICENSE_TEXT(VERSION, current_patch))\r\n        appplication_license_Text.configure(state=tk.DISABLED)\r\n        \r\n        application_change_log_tab_Frame = tk.Frame(tab4)\r\n        application_change_log_tab_Frame.grid(row=0,column=0,padx=0,pady=0)\r\n\r\n        application_change_log_Label = tk.Label(application_change_log_tab_Frame, text='Additional Information', font=(MAIN_FONT_NAME, f\"{FONT_SIZE_6}\", \"bold\"), justify=\"center\", fg=\"#f4f4f4\")\r\n        application_change_log_Label.grid(row=0,column=0,padx=0,pady=25)\r\n        \r\n        application_change_log_Text = tk.Text(application_change_log_tab_Frame, font=(MAIN_FONT_NAME, f\"{FONT_SIZE_4}\"), fg=\"white\", bg=\"black\", width=72, wrap=tk.WORD, borderwidth=0)\r\n        application_change_log_Text.grid(row=1,column=0,padx=40 if is_macos else 30,pady=0)\r\n        application_change_log_Text_scroll = ttk.Scrollbar(application_change_log_tab_Frame, orient=tk.VERTICAL)\r\n        application_change_log_Text.config(yscrollcommand=application_change_log_Text_scroll.set)\r\n        application_change_log_Text_scroll.configure(command=application_change_log_Text.yview)\r\n        application_change_log_Text.grid(row=4,sticky=tk.W)\r\n        application_change_log_Text_scroll.grid(row=4, column=1, sticky=tk.NS)\r\n        application_change_log_Text.insert(\"insert\", self.bulletin_data)\r\n        auto_hyperlink(application_change_log_Text)\r\n        application_change_log_Text.configure(state=tk.DISABLED)\r\n\r\n        self.menu_placement(help_guide_opt, \"Information Guide\")\r\n\r\n    def menu_error_log(self):#\r\n        \"\"\"Open Error Log\"\"\"\r\n\r\n        self.is_confirm_error_var.set(False)\r\n        \r\n        copied_var = tk.StringVar(value='')\r\n        error_log_screen = tk.Toplevel()\r\n        \r\n        self.is_open_menu_error_log.set(True)\r\n        self.menu_error_log_close_window = lambda:(self.is_open_menu_error_log.set(False), error_log_screen.destroy())\r\n        error_log_screen.protocol(\"WM_DELETE_WINDOW\", self.menu_error_log_close_window)\r\n        \r\n        error_log_frame = self.menu_FRAME_SET(error_log_screen)\r\n        error_log_frame.grid(row=0)  \r\n        \r\n        error_consol_title_Label = self.menu_title_LABEL_SET(error_log_frame, ERROR_CONSOLE_TEXT)\r\n        error_consol_title_Label.grid(row=1,column=0,padx=20,pady=MENU_PADDING_2)\r\n        \r\n        error_details_Text = tk.Text(error_log_frame, font=(MAIN_FONT_NAME, f\"{FONT_SIZE_1}\"), fg=\"#D37B7B\", bg=\"black\", width=110, wrap=tk.WORD, borderwidth=0)\r\n        error_details_Text.grid(row=2,column=0,padx=0,pady=0)\r\n        error_details_Text.insert(\"insert\", self.error_log_var.get())\r\n        error_details_Text.bind(right_click_button, lambda e:self.right_click_menu_popup(e, text_box=True))\r\n        self.current_text_box = error_details_Text\r\n        error_details_Text_scroll = ttk.Scrollbar(error_log_frame, orient=tk.VERTICAL)\r\n        error_details_Text.config(yscrollcommand=error_details_Text_scroll.set)\r\n        error_details_Text_scroll.configure(command=error_details_Text.yview)\r\n        error_details_Text.grid(row=2,sticky=tk.W)\r\n        error_details_Text_scroll.grid(row=2, column=1, sticky=tk.NS)\r\n\r\n        copy_text_Label = tk.Label(error_log_frame, textvariable=copied_var, font=(MAIN_FONT_NAME,  f\"{FONT_SIZE_0}\"), justify=\"center\", fg=\"#f4f4f4\")\r\n        copy_text_Label.grid(padx=20,pady=0)\r\n        \r\n        copy_text_Button = ttk.Button(error_log_frame, text=COPY_ALL_TEXT_TEXT, width=14, command=lambda:(pyperclip.copy(error_details_Text.get(1.0, tk.END+\"-1c\")), copied_var.set('Copied!')))\r\n        copy_text_Button.grid(padx=20,pady=MENU_PADDING_1)\r\n        \r\n        report_issue_Button = ttk.Button(error_log_frame, text=REPORT_ISSUE_TEXT, width=14, command=lambda:webbrowser.open_new_tab(ISSUE_LINK))\r\n        report_issue_Button.grid(padx=20,pady=MENU_PADDING_1)\r\n\r\n        error_log_return_Button = ttk.Button(error_log_frame, text=BACK_TO_MAIN_MENU, command=lambda:(self.menu_error_log_close_window(), self.menu_settings()))\r\n        error_log_return_Button.grid(padx=20,pady=MENU_PADDING_1)\r\n        \r\n        error_log_close_Button = ttk.Button(error_log_frame, text=CLOSE_WINDOW, command=lambda:self.menu_error_log_close_window())\r\n        error_log_close_Button.grid(padx=20,pady=MENU_PADDING_1)\r\n        \r\n        self.menu_placement(error_log_screen, UVR_ERROR_LOG_TEXT)\r\n\r\n    def menu_secondary_model(self, tab, ai_network_vars: dict):\r\n        \r\n        #Settings Tab 1\r\n        secondary_model_Frame = self.menu_FRAME_SET(tab)\r\n        secondary_model_Frame.grid(row=0)  \r\n        \r\n        settings_title_Label = self.menu_title_LABEL_SET(secondary_model_Frame, SECONDARY_MODEL_TEXT)\r\n        settings_title_Label.grid(row=0,column=0,padx=0,pady=MENU_PADDING_3)\r\n        \r\n        voc_inst_list = self.model_list(VOCAL_STEM, INST_STEM, is_dry_check=True)\r\n        other_list = self.model_list(OTHER_STEM, NO_OTHER_STEM, is_dry_check=True)\r\n        bass_list = self.model_list(BASS_STEM, NO_BASS_STEM, is_dry_check=True)\r\n        drum_list = self.model_list(DRUM_STEM, NO_DRUM_STEM, is_dry_check=True)\r\n        \r\n        voc_inst_secondary_model_var = ai_network_vars[\"voc_inst_secondary_model\"]\r\n        other_secondary_model_var = ai_network_vars[\"other_secondary_model\"]\r\n        bass_secondary_model_var = ai_network_vars[\"bass_secondary_model\"]\r\n        drums_secondary_model_var = ai_network_vars[\"drums_secondary_model\"]\r\n        voc_inst_secondary_model_scale_var = ai_network_vars['voc_inst_secondary_model_scale']\r\n        other_secondary_model_scale_var = ai_network_vars['other_secondary_model_scale']\r\n        bass_secondary_model_scale_var = ai_network_vars['bass_secondary_model_scale']\r\n        drums_secondary_model_scale_var = ai_network_vars['drums_secondary_model_scale']\r\n        is_secondary_model_activate_var = ai_network_vars[\"is_secondary_model_activate\"]\r\n        \r\n        change_state_lambda = lambda:change_state(tk.NORMAL if is_secondary_model_activate_var.get() else tk.DISABLED)\r\n        init_convert_to_percentage = lambda raw_value:f\"{int(float(raw_value)*100)}%\"\r\n        \r\n        voc_inst_secondary_model_scale_LABEL_var = tk.StringVar(value=init_convert_to_percentage(voc_inst_secondary_model_scale_var.get()))\r\n        other_secondary_model_scale_LABEL_var = tk.StringVar(value=init_convert_to_percentage(other_secondary_model_scale_var.get()))\r\n        bass_secondary_model_scale_LABEL_var = tk.StringVar(value=init_convert_to_percentage(bass_secondary_model_scale_var.get()))\r\n        drums_secondary_model_scale_LABEL_var = tk.StringVar(value=init_convert_to_percentage(drums_secondary_model_scale_var.get()))\r\n\r\n        def change_state(change_state):\r\n            for child_widget in secondary_model_Frame.winfo_children():\r\n                if type(child_widget) is ComboBoxMenu:\r\n                    change_state = READ_ONLY if change_state == tk.NORMAL else change_state\r\n                    child_widget.configure(state=change_state)\r\n                elif type(child_widget) is ttk.Scale:\r\n                    child_widget.configure(state=change_state)\r\n        \r\n        def convert_to_percentage(raw_value, scale_var: tk.StringVar, label_var: tk.StringVar):\r\n            raw_value = '%0.2f' % float(raw_value)\r\n            scale_var.set(raw_value)\r\n            label_var.set(f\"{int(float(raw_value)*100)}%\")\r\n\r\n        def build_widgets(stem_pair: str, model_list: list, option_var: tk.StringVar, label_var: tk.StringVar, scale_var: tk.DoubleVar):\r\n            model_list.insert(0, NO_MODEL)\r\n            secondary_model_Label = self.menu_sub_LABEL_SET(secondary_model_Frame, f'{stem_pair}', font_size=FONT_SIZE_3)\r\n            secondary_model_Label.grid(pady=MENU_PADDING_1)\r\n            secondary_model_Option = ComboBoxMenu(secondary_model_Frame, textvariable=option_var, values=model_list, dropdown_name=stem_pair, offset=310, width=READ_ONLY_COMBO_WIDTH)\r\n            secondary_model_Option.grid(pady=MENU_PADDING_1)\r\n            secondary_scale_info_Label = tk.Label(secondary_model_Frame, textvariable=label_var, font=(MAIN_FONT_NAME, f\"{FONT_SIZE_1}\"), foreground=FG_COLOR)\r\n            secondary_scale_info_Label.grid(pady=0)   \r\n            secondary_model_scale_Option = ttk.Scale(secondary_model_Frame, variable=scale_var, from_=0.01, to=0.99, command=lambda s:convert_to_percentage(s, scale_var, label_var), orient='horizontal')\r\n            secondary_model_scale_Option.grid(pady=2)\r\n            self.help_hints(secondary_model_Label, text=SECONDARY_MODEL_HELP)\r\n            self.help_hints(secondary_scale_info_Label, text=SECONDARY_MODEL_SCALE_HELP)\r\n\r\n        build_widgets(stem_pair=VOCAL_PAIR,\r\n                      model_list=voc_inst_list,\r\n                      option_var=voc_inst_secondary_model_var,\r\n                      label_var=voc_inst_secondary_model_scale_LABEL_var,\r\n                      scale_var=voc_inst_secondary_model_scale_var)\r\n        \r\n        build_widgets(stem_pair=OTHER_PAIR,\r\n                      model_list=other_list,\r\n                      option_var=other_secondary_model_var,\r\n                      label_var=other_secondary_model_scale_LABEL_var,\r\n                      scale_var=other_secondary_model_scale_var)\r\n        \r\n        build_widgets(stem_pair=BASS_PAIR,\r\n                      model_list=bass_list,\r\n                      option_var=bass_secondary_model_var,\r\n                      label_var=bass_secondary_model_scale_LABEL_var,\r\n                      scale_var=bass_secondary_model_scale_var)\r\n        \r\n        build_widgets(stem_pair=DRUM_PAIR,\r\n                      model_list=drum_list,\r\n                      option_var=drums_secondary_model_var,\r\n                      label_var=drums_secondary_model_scale_LABEL_var,\r\n                      scale_var=drums_secondary_model_scale_var)\r\n     \r\n        is_secondary_model_activate_Option = ttk.Checkbutton(secondary_model_Frame, text=ACTIVATE_SECONDARY_MODEL_TEXT, variable=is_secondary_model_activate_var, command=change_state_lambda) \r\n        is_secondary_model_activate_Option.grid(row=21,pady=MENU_PADDING_1)\r\n        self.help_hints(is_secondary_model_activate_Option, text=SECONDARY_MODEL_ACTIVATE_HELP)\r\n        \r\n        change_state_lambda()\r\n        \r\n        self.change_state_lambda = change_state_lambda\r\n        \r\n    def menu_preproc_model(self, tab):\r\n        \r\n        preproc_model_Frame = self.menu_FRAME_SET(tab)\r\n        preproc_model_Frame.grid(row=0)  \r\n\r\n        demucs_pre_proc_model_title_Label = self.menu_title_LABEL_SET(preproc_model_Frame, PREPROCESS_MODEL_CHOOSE_TEXT)\r\n        demucs_pre_proc_model_title_Label.grid(pady=MENU_PADDING_3)\r\n        \r\n        pre_proc_list = self.model_list(VOCAL_STEM, INST_STEM, is_dry_check=True, is_no_demucs=True)\r\n        pre_proc_list.insert(0, NO_MODEL)\r\n        \r\n        enable_pre_proc_model = lambda:(is_demucs_pre_proc_model_inst_mix_Option.configure(state=tk.NORMAL), demucs_pre_proc_model_Option.configure(state=READ_ONLY))\r\n        disable_pre_proc_model = lambda:(is_demucs_pre_proc_model_inst_mix_Option.configure(state=tk.DISABLED), demucs_pre_proc_model_Option.configure(state=tk.DISABLED), self.is_demucs_pre_proc_model_inst_mix_var.set(False))\r\n        pre_proc_model_toggle = lambda:enable_pre_proc_model() if self.is_demucs_pre_proc_model_activate_var.get() else disable_pre_proc_model()\r\n        \r\n        demucs_pre_proc_model_Label = self.menu_sub_LABEL_SET(preproc_model_Frame, SELECT_MODEL_TEXT, font_size=FONT_SIZE_3)\r\n        demucs_pre_proc_model_Label.grid()\r\n        demucs_pre_proc_model_Option = ComboBoxMenu(preproc_model_Frame, textvariable=self.demucs_pre_proc_model_var, values=pre_proc_list, dropdown_name='demucspre', offset=310, width=READ_ONLY_COMBO_WIDTH)\r\n        demucs_pre_proc_model_Option.grid(pady=MENU_PADDING_2)\r\n\r\n        is_demucs_pre_proc_model_inst_mix_Option = ttk.Checkbutton(preproc_model_Frame, text='Save Instrumental Mixture', width=DEMUCS_PRE_CHECKBOXS_WIDTH, variable=self.is_demucs_pre_proc_model_inst_mix_var) \r\n        is_demucs_pre_proc_model_inst_mix_Option.grid()\r\n        self.help_hints(is_demucs_pre_proc_model_inst_mix_Option, text=PRE_PROC_MODEL_INST_MIX_HELP)\r\n        \r\n        is_demucs_pre_proc_model_activate_Option = ttk.Checkbutton(preproc_model_Frame, text=ACTIVATE_PRE_PROCESS_MODEL_TEXT, width=DEMUCS_PRE_CHECKBOXS_WIDTH, variable=self.is_demucs_pre_proc_model_activate_var, command=pre_proc_model_toggle) \r\n        is_demucs_pre_proc_model_activate_Option.grid()\r\n        self.help_hints(is_demucs_pre_proc_model_activate_Option, text=PRE_PROC_MODEL_ACTIVATE_HELP)\r\n        \r\n        pre_proc_model_toggle()\r\n        \r\n    def menu_manual_downloads(self):\r\n        \r\n        manual_downloads_menu = tk.Toplevel()\r\n        model_selection_var = tk.StringVar(value=SELECT_MODEL_TEXT)\r\n        #info_text_var = tk.StringVar(value='')\r\n\r\n        if self.is_online:\r\n            model_data = self.online_data\r\n            \r\n            # Save the data as a JSON file\r\n            with open(DOWNLOAD_MODEL_CACHE, 'w') as json_file:\r\n                json.dump(model_data, json_file)\r\n                \r\n        else:\r\n            if os.path.isfile(DOWNLOAD_MODEL_CACHE):\r\n                with open(DOWNLOAD_MODEL_CACHE, 'r') as json_file:\r\n                    model_data = json.load(json_file)\r\n                    \r\n        vr_download_list = model_data[\"vr_download_list\"]\r\n        mdx_download_list = model_data[\"mdx_download_list\"]\r\n        demucs_download_list = model_data[\"demucs_download_list\"]\r\n        mdx_download_list.update(model_data[\"mdx23c_download_list\"])\r\n\r\n        def create_link(link):\r\n            final_link = lambda:webbrowser.open_new_tab(link)\r\n            return final_link\r\n            \r\n        def get_links():\r\n            for widgets in manual_downloads_link_Frame.winfo_children():\r\n                widgets.destroy()\r\n                \r\n            main_selection = model_selection_var.get()\r\n            \r\n            MAIN_ROW = 0\r\n            \r\n            self.menu_sub_LABEL_SET(manual_downloads_link_Frame, 'Download Link(s)').grid(row=0,column=0,padx=0,pady=MENU_PADDING_4)\r\n            \r\n            if VR_ARCH_TYPE in main_selection:\r\n                main_selection = vr_download_list[main_selection]\r\n                model_dir = VR_MODELS_DIR\r\n            elif MDX_ARCH_TYPE in main_selection or MDX_23_NAME in main_selection:\r\n                if isinstance(mdx_download_list[main_selection], dict):\r\n                    main_selection = mdx_download_list[main_selection]\r\n                    main_selection = list(main_selection.keys())[0]\r\n                else:\r\n                    main_selection = mdx_download_list[main_selection]\r\n                    \r\n                model_dir = MDX_MODELS_DIR\r\n\r\n            elif DEMUCS_ARCH_TYPE in main_selection:\r\n                model_dir = DEMUCS_NEWER_REPO_DIR if 'v3' in main_selection or 'v4' in main_selection else DEMUCS_MODELS_DIR\r\n                main_selection = demucs_download_list[main_selection]\r\n\r\n            if type(main_selection) is dict:\r\n                for links in main_selection.values():\r\n                    MAIN_ROW += 1\r\n                    button_text = f\" - Item {MAIN_ROW}\" if len(main_selection.keys()) >= 2 else ''\r\n                    link = create_link(links)\r\n                    link_button = ttk.Button(manual_downloads_link_Frame, text=f\"Open Link to Model{button_text}\", command=link).grid(row=MAIN_ROW,column=0,padx=0,pady=MENU_PADDING_1)\r\n            else:\r\n                link = f\"{NORMAL_REPO}{main_selection}\"\r\n                link_button = ttk.Button(manual_downloads_link_Frame, text=OPEN_LINK_TO_MODEL_TEXT, command=lambda:webbrowser.open_new_tab(link))\r\n                link_button.grid(row=1,column=0,padx=0,pady=MENU_PADDING_2)\r\n        \r\n            self.menu_sub_LABEL_SET(manual_downloads_link_Frame, SELECTED_MODEL_PLACE_PATH_TEXT).grid(row=MAIN_ROW+2,column=0,padx=0,pady=MENU_PADDING_4)\r\n            ttk.Button(manual_downloads_link_Frame, text=OPEN_MODEL_DIRECTORY_TEXT, command=lambda:OPEN_FILE_func(model_dir)).grid(row=MAIN_ROW+3,column=0,padx=0,pady=MENU_PADDING_1)\r\n        \r\n        manual_downloads_menu_Frame = self.menu_FRAME_SET(manual_downloads_menu)\r\n        manual_downloads_menu_Frame.grid(row=0)  \r\n\r\n        manual_downloads_link_Frame = self.menu_FRAME_SET(manual_downloads_menu, thickness=5)\r\n        manual_downloads_link_Frame.grid(row=1)  \r\n\r\n        manual_downloads_menu_title_Label = self.menu_title_LABEL_SET(manual_downloads_menu_Frame, MANUAL_DOWNLOADS_TEXT, width=45)\r\n        manual_downloads_menu_title_Label.grid(row=0,column=0,padx=0,pady=MENU_PADDING_3)\r\n        \r\n        manual_downloads_menu_select_Label = self.menu_sub_LABEL_SET(manual_downloads_menu_Frame, SELECT_MODEL_TEXT)\r\n        manual_downloads_menu_select_Label.grid(row=1,column=0,padx=0,pady=MENU_PADDING_1)\r\n        \r\n        manual_downloads_menu_select_Option = ttk.OptionMenu(manual_downloads_menu_Frame, model_selection_var)\r\n        manual_downloads_menu_select_VR_Option = tk.Menu(manual_downloads_menu_select_Option['menu'])\r\n        manual_downloads_menu_select_MDX_Option = tk.Menu(manual_downloads_menu_select_Option['menu'])\r\n        manual_downloads_menu_select_DEMUCS_Option = tk.Menu(manual_downloads_menu_select_Option['menu'])\r\n        manual_downloads_menu_select_Option['menu'].add_cascade(label='VR Models', menu= manual_downloads_menu_select_VR_Option)\r\n        manual_downloads_menu_select_Option['menu'].add_cascade(label='MDX-Net Models', menu= manual_downloads_menu_select_MDX_Option)\r\n        manual_downloads_menu_select_Option['menu'].add_cascade(label='Demucs Models', menu= manual_downloads_menu_select_DEMUCS_Option)\r\n\r\n        for model_selection_vr in vr_download_list.keys():\r\n            if not os.path.isfile(os.path.join(VR_MODELS_DIR, vr_download_list[model_selection_vr])):\r\n                manual_downloads_menu_select_VR_Option.add_radiobutton(label=model_selection_vr, variable=model_selection_var, command=get_links)\r\n            \r\n        for model_selection_mdx in mdx_download_list.keys():\r\n            \r\n            model_name = mdx_download_list[model_selection_mdx]\r\n            \r\n            if isinstance(model_name, dict):\r\n                items_list = list(model_name.items())\r\n                model_name, config = items_list[0]\r\n                config_link = f\"{MDX23_CONFIG_CHECKS}{config}\"\r\n                config_local = os.path.join(MDX_C_CONFIG_PATH, config)\r\n                if not os.path.isfile(config_local):\r\n                    try:\r\n                        with urllib.request.urlopen(config_link) as response:\r\n                            with open(config_local, 'wb') as out_file:\r\n                                out_file.write(response.read())\r\n                    except Exception as e:\r\n                        model_name = None\r\n\r\n            #print(model_name)\r\n                \r\n            if model_name: \r\n                if not os.path.isfile(os.path.join(MDX_MODELS_DIR, model_name)):\r\n                    manual_downloads_menu_select_MDX_Option.add_radiobutton(label=model_selection_mdx, variable=model_selection_var, command=get_links)\r\n            \r\n        for model_selection_demucs in demucs_download_list.keys():\r\n            manual_downloads_menu_select_DEMUCS_Option.add_radiobutton(label=model_selection_demucs, variable=model_selection_var, command=get_links)\r\n            \r\n        manual_downloads_menu_select_Option.grid(row=2,column=0,padx=0,pady=MENU_PADDING_1)\r\n    \r\n        self.menu_placement(manual_downloads_menu, MANUAL_DOWNLOADS_TEXT, pop_up=True, close_function=lambda:manual_downloads_menu.destroy())\r\n        \r\n    def invalid_tooltip(self, widget, pattern=None):\r\n        tooltip = ToolTip(widget)\r\n        invalid_message = lambda:tooltip.showtip(INVALID_INPUT_E, True)\r\n        \r\n        def invalid_message_():\r\n            tooltip.showtip(INVALID_INPUT_E, True)\r\n        \r\n        def validation(value):\r\n            if re.fullmatch(modified_pattern, value) is None:\r\n                return False\r\n            else:\r\n                return True\r\n        \r\n        if not pattern:\r\n            pattern = r'^[a-zA-Z0-9 -]{0,25}$'\r\n\r\n        modified_pattern = f\"({pattern}|)\"\r\n\r\n        widget.configure(\r\n            validate='key', \r\n            validatecommand=(self.register(validation), '%P'),\r\n            invalidcommand=(self.register(invalid_message))\r\n        )\r\n        \r\n        return invalid_message_\r\n        \r\n    def pop_up_save_current_settings(self):\r\n        \"\"\"Save current application settings as...\"\"\"\r\n        \r\n        settings_save = tk.Toplevel(root)\r\n        \r\n        settings_save_var = tk.StringVar(value='')\r\n\r\n        settings_save_Frame = self.menu_FRAME_SET(settings_save)\r\n        settings_save_Frame.grid(row=1)  \r\n\r\n        save_func = lambda:(self.pop_up_save_current_settings_sub_json_dump(settings_save_var.get()), settings_save.destroy())\r\n        validation = lambda value:False if re.fullmatch(REG_SAVE_INPUT, value) is None else True\r\n\r\n        settings_save_title = self.menu_title_LABEL_SET(settings_save_Frame, SAVE_CURRENT_SETTINGS_TEXT)\r\n        settings_save_title.grid()\r\n        \r\n        settings_save_name_Label = self.menu_sub_LABEL_SET(settings_save_Frame, NAME_SETTINGS_TEXT)\r\n        settings_save_name_Label.grid(pady=MENU_PADDING_1)\r\n        settings_save_name_Entry = ttk.Entry(settings_save_Frame, textvariable=settings_save_var, justify='center', width=25)\r\n        settings_save_name_Entry.grid(pady=MENU_PADDING_1)\r\n        invalid_message = self.invalid_tooltip(settings_save_name_Entry)\r\n        settings_save_name_Entry.bind(right_click_button, self.right_click_menu_popup)\r\n        self.current_text_box = settings_save_name_Entry\r\n        settings_save_name_Entry.focus_set()\r\n        \r\n        self.spacer_label(settings_save_Frame)\r\n        \r\n        entry_rules_Label = tk.Label(settings_save_Frame, text=ENSEMBLE_INPUT_RULE, font=(MAIN_FONT_NAME, f\"{FONT_SIZE_1}\"), foreground='#868687', justify=\"left\")\r\n        entry_rules_Label.grid()     \r\n        \r\n        settings_save_Button = ttk.Button(settings_save_Frame, text=SAVE_TEXT, command=lambda:save_func() if validation(settings_save_var.get()) else invalid_message())\r\n        settings_save_Button.grid(pady=MENU_PADDING_1)\r\n        \r\n        stop_process_Button = ttk.Button(settings_save_Frame, text=CANCEL_TEXT, command=lambda:settings_save.destroy())\r\n        stop_process_Button.grid(pady=MENU_PADDING_1)\r\n            \r\n        self.menu_placement(settings_save, SAVE_CURRENT_SETTINGS_TEXT, pop_up=True)\r\n\r\n    def pop_up_save_current_settings_sub_json_dump(self, settings_save_name: str):\r\n        \"\"\"Dumps current application settings to a json named after user input\"\"\"\r\n        \r\n        if settings_save_name:\r\n            self.save_current_settings_var.set(settings_save_name)\r\n            settings_save_name = settings_save_name.replace(\" \", \"_\")\r\n            current_settings = self.save_values(app_close=False)\r\n            \r\n            saved_data_dump = json.dumps(current_settings, indent=4)\r\n            with open(os.path.join(SETTINGS_CACHE_DIR, f'{settings_save_name}.json'), \"w\") as outfile:\r\n                outfile.write(saved_data_dump)\r\n\r\n    def pop_up_update_confirmation(self):\r\n        \"\"\"Ask user is they want to update\"\"\"\r\n        \r\n        is_new_update = self.online_data_refresh(confirmation_box=True)\r\n        is_download_in_app_var = tk.BooleanVar(value=False)\r\n        \r\n        def update_type():\r\n            if is_download_in_app_var.get():\r\n                self.download_item(is_update_app=True)\r\n            else:\r\n                webbrowser.open_new_tab(self.download_update_link_var.get())\r\n\r\n            update_confirmation_win.destroy()\r\n            \r\n        if is_new_update:\r\n            \r\n            update_confirmation_win = tk.Toplevel()\r\n\r\n            update_confirmation_Frame = self.menu_FRAME_SET(update_confirmation_win)\r\n            update_confirmation_Frame.grid(row=0)  \r\n            \r\n            update_found_label = self.menu_title_LABEL_SET(update_confirmation_Frame, UPDATE_FOUND_TEXT, width=15)\r\n            update_found_label.grid(row=0,column=0,padx=0,pady=MENU_PADDING_2)\r\n            \r\n            confirm_update_label = self.menu_sub_LABEL_SET(update_confirmation_Frame, UPDATE_CONFIRMATION_TEXT, font_size=FONT_SIZE_3)\r\n            confirm_update_label.grid(row=1,column=0,padx=0,pady=MENU_PADDING_1)\r\n                    \r\n            yes_button = ttk.Button(update_confirmation_Frame, text=YES_TEXT, command=update_type)\r\n            yes_button.grid(row=2,column=0,padx=0,pady=MENU_PADDING_1)\r\n            \r\n            no_button = ttk.Button(update_confirmation_Frame, text=NO_TEXT, command=lambda:(update_confirmation_win.destroy()))\r\n            no_button.grid(row=3,column=0,padx=0,pady=MENU_PADDING_1)\r\n            \r\n            if is_windows:\r\n                download_outside_application_button = ttk.Checkbutton(update_confirmation_Frame, variable=is_download_in_app_var, text='Download Update in Application')\r\n                download_outside_application_button.grid(row=4,column=0,padx=0,pady=MENU_PADDING_1)\r\n\r\n            self.menu_placement(update_confirmation_win, CONFIRM_UPDATE_TEXT, pop_up=True)\r\n\r\n    def pop_up_user_code_input(self):\r\n        \"\"\"Input VIP Code\"\"\"\r\n\r\n        self.user_code_validation_var.set('')\r\n        \r\n        self.user_code = tk.Toplevel()\r\n        \r\n        user_code_Frame = self.menu_FRAME_SET(self.user_code)\r\n        user_code_Frame.grid(row=0)  \r\n                \r\n        user_code_title_Label = self.menu_title_LABEL_SET(user_code_Frame, USER_DOWNLOAD_CODES_TEXT, width=20)\r\n        user_code_title_Label.grid(row=0,column=0,padx=0,pady=MENU_PADDING_1)    \r\n        \r\n        user_code_Label = self.menu_sub_LABEL_SET(user_code_Frame, DOWNLOAD_CODE_TEXT)\r\n        user_code_Label.grid(pady=MENU_PADDING_1)       \r\n                \r\n        self.user_code_Entry = ttk.Entry(user_code_Frame, textvariable=self.user_code_var, justify='center')\r\n        self.user_code_Entry.grid(pady=MENU_PADDING_1)\r\n        self.user_code_Entry.bind(right_click_button, self.right_click_menu_popup)\r\n        self.current_text_box = self.user_code_Entry\r\n        \r\n        tooltip = ToolTip(self.user_code_Entry)\r\n        def invalid_message_(text, is_success_message):\r\n            tooltip.hidetip()\r\n            tooltip.showtip(text, True, is_success_message)\r\n        \r\n        self.spacer_label(user_code_Frame)\r\n\r\n        user_code_confrim_Button = ttk.Button(user_code_Frame, text=CONFIRM_TEXT, command=lambda:self.download_validate_code(confirm=True, code_message=invalid_message_))\r\n        user_code_confrim_Button.grid(pady=MENU_PADDING_1)\r\n        \r\n        user_code_cancel_Button = ttk.Button(user_code_Frame, text=CANCEL_TEXT, command=lambda:self.user_code.destroy())\r\n        user_code_cancel_Button.grid(pady=MENU_PADDING_1)\r\n        \r\n        support_title_Label = self.menu_title_LABEL_SET(user_code_Frame, text=SUPPORT_UVR_TEXT, width=20)\r\n        support_title_Label.grid(pady=MENU_PADDING_1)    \r\n        \r\n        support_sub_Label = tk.Label(user_code_Frame, text=GET_DL_VIP_CODE_TEXT, font=(MAIN_FONT_NAME, f\"{FONT_SIZE_1}\"), foreground=FG_COLOR)\r\n        support_sub_Label.grid(pady=MENU_PADDING_1)\r\n        \r\n        uvr_patreon_Button = ttk.Button(user_code_Frame, text=UVR_PATREON_LINK_TEXT, command=lambda:webbrowser.open_new_tab(DONATE_LINK_PATREON))\r\n        uvr_patreon_Button.grid(pady=MENU_PADDING_1)\r\n        \r\n        bmac_patreon_Button=ttk.Button(user_code_Frame, text=BMAC_UVR_TEXT, command=lambda:webbrowser.open_new_tab(DONATE_LINK_BMAC))\r\n        bmac_patreon_Button.grid(pady=MENU_PADDING_1)\r\n        \r\n        self.menu_placement(self.user_code, INPUT_CODE_TEXT, pop_up=True)\r\n\r\n    def pop_up_change_model_defaults(self, top_window):\r\n        \"\"\"\r\n        Change model defaults...\r\n        \"\"\"\r\n        \r\n        def message_box_(text, is_success_message):\r\n            tooltip.hidetip()\r\n            tooltip.showtip(text, True, is_success_message)\r\n        \r\n        def delete_entry():\r\n            model_data = self.assemble_model_data(model=change_model_defaults_var.get(), arch_type=ENSEMBLE_CHECK, is_change_def=True, is_get_hash_dir_only=True)[0]\r\n            hash_file = model_data.model_hash_dir\r\n            if hash_file:\r\n                if os.path.isfile(hash_file):\r\n                    os.remove(hash_file)\r\n                    message_box_(\"Defined Parameters Deleted\", True)\r\n                else:\r\n                    message_box_(\"No Defined Parameters Found\", False)\r\n                    \r\n                self.update_checkbox_text()\r\n                \r\n        def change_default():\r\n            model_data = self.assemble_model_data(model=change_model_defaults_var.get(), arch_type=ENSEMBLE_CHECK, is_change_def=True)[0]\r\n            if model_data.model_status:\r\n                message_box_(\"Model Parameters Changed\", True)\r\n                self.update_checkbox_text()\r\n\r\n        change_model_defaults = tk.Toplevel(root)\r\n        change_model_defaults_var = tk.StringVar(value=NO_MODEL)\r\n\r\n        default_change_model_list = list(self.default_change_model_list)\r\n        default_change_model_list.insert(0, NO_MODEL)\r\n\r\n        change_model_defaults_Frame = self.menu_FRAME_SET(change_model_defaults)\r\n        change_model_defaults_Frame.grid(row=1)  \r\n\r\n        change_model_defaults_title = self.menu_title_LABEL_SET(change_model_defaults_Frame, CHANGE_MODEL_DEFAULT_TEXT)\r\n        change_model_defaults_title.grid()\r\n        \r\n        model_param_Label = self.menu_sub_LABEL_SET(change_model_defaults_Frame, SELECT_MODEL_TEXT)\r\n        model_param_Label.grid(pady=MENU_PADDING_1)\r\n        model_param_Option = ComboBoxMenu(change_model_defaults_Frame, dropdown_name='changemodeldefault', textvariable=change_model_defaults_var, values=default_change_model_list, offset=310, width=READ_ONLY_COMBO_WIDTH)\r\n        model_param_Option.grid(pady=MENU_PADDING_1)\r\n        tooltip = ToolTip(model_param_Option)\r\n        \r\n        self.spacer_label(change_model_defaults_Frame)\r\n\r\n        change_params_Button = ttk.Button(change_model_defaults_Frame, text=CHANGE_PARAMETERS_TEXT, command=change_default, width=20)\r\n        change_params_Button.grid(pady=MENU_PADDING_1)\r\n        \r\n        delete_params_Button = ttk.Button(change_model_defaults_Frame, text=DELETE_PARAMETERS_TEXT, command=delete_entry, width=20)\r\n        delete_params_Button.grid(pady=MENU_PADDING_1)\r\n        \r\n        cancel_Button = ttk.Button(change_model_defaults_Frame, text=CANCEL_TEXT, command=lambda:change_model_defaults.destroy())\r\n        cancel_Button.grid(pady=MENU_PADDING_1)\r\n            \r\n        self.menu_placement(change_model_defaults, CHANGE_MODEL_DEFAULT_TEXT, top_window=top_window)\r\n\r\n    def pop_up_set_vocal_splitter(self, top_window):\r\n        \"\"\"\r\n        Set vocal splitter\r\n        \"\"\"\r\n\r\n        try:\r\n            set_vocal_splitter = tk.Toplevel(root)\r\n\r\n            model_list = self.assemble_model_data(arch_type=KARAOKEE_CHECK, is_dry_check=True)\r\n            if not model_list:\r\n                self.set_vocal_splitter_var.set(NO_MODEL)\r\n            model_list.insert(0, NO_MODEL)\r\n\r\n            enable_voc_split_model = lambda:(model_select_Option.configure(state=READ_ONLY), save_inst_Button.configure(state=tk.NORMAL))\r\n            disable_voc_split_model = lambda:(model_select_Option.configure(state=tk.DISABLED), save_inst_Button.configure(state=tk.DISABLED), self.is_save_inst_set_vocal_splitter_var.set(False))\r\n            voc_split_model_toggle = lambda:enable_voc_split_model() if self.is_set_vocal_splitter_var.get() else disable_voc_split_model()\r\n            \r\n            enable_deverb_opt = lambda:(deverb_vocals_Option.configure(state=READ_ONLY))\r\n            disable_deverb_opt= lambda:(deverb_vocals_Option.configure(state=tk.DISABLED))\r\n            deverb_opt_toggle = lambda:enable_deverb_opt() if self.is_deverb_vocals_var.get() else disable_deverb_opt()\r\n\r\n            set_vocal_splitter_Frame = self.menu_FRAME_SET(set_vocal_splitter)\r\n            set_vocal_splitter_Frame.grid(row=1)  \r\n\r\n            set_vocal_splitter_title = self.menu_title_LABEL_SET(set_vocal_splitter_Frame, VOCAL_SPLIT_MODE_OPTIONS_TEXT)\r\n            set_vocal_splitter_title.grid(pady=MENU_PADDING_2)\r\n            \r\n            model_select_Label = self.menu_sub_LABEL_SET(set_vocal_splitter_Frame, SELECT_MODEL_TEXT)\r\n            model_select_Label.grid(pady=MENU_PADDING_1)\r\n            model_select_Option = ComboBoxMenu(set_vocal_splitter_Frame, dropdown_name='setvocalsplit', textvariable=self.set_vocal_splitter_var, values=model_list, offset=310, width=READ_ONLY_COMBO_WIDTH)\r\n            model_select_Option.grid(pady=7)\r\n            self.help_hints(model_select_Option, text=VOC_SPLIT_MODEL_SELECT_HELP)#\r\n            \r\n            save_inst_Button = ttk.Checkbutton(set_vocal_splitter_Frame, text=SAVE_SPLIT_VOCAL_INSTRUMENTALS_TEXT, variable=self.is_save_inst_set_vocal_splitter_var, width=SET_VOC_SPLIT_CHECK_WIDTH, command=voc_split_model_toggle)\r\n            save_inst_Button.grid()#\r\n            self.help_hints(save_inst_Button, text=IS_VOC_SPLIT_INST_SAVE_SELECT_HELP)#\r\n            \r\n            change_params_Button = ttk.Checkbutton(set_vocal_splitter_Frame, text=ENABLE_VOCAL_SPLIT_MODE_TEXT, variable=self.is_set_vocal_splitter_var, width=SET_VOC_SPLIT_CHECK_WIDTH, command=voc_split_model_toggle)\r\n            change_params_Button.grid()#\r\n            self.help_hints(change_params_Button, text=IS_VOC_SPLIT_MODEL_SELECT_HELP)#\r\n            \r\n            set_vocal_splitter_title = self.menu_title_LABEL_SET(set_vocal_splitter_Frame, VOCAL_DEVERB_OPTIONS_TEXT)\r\n            set_vocal_splitter_title.grid(pady=MENU_PADDING_2)\r\n            \r\n            deverb_vocals_Label = self.menu_sub_LABEL_SET(set_vocal_splitter_Frame, 'Select Vocal Type to Deverb')\r\n            deverb_vocals_Label.grid(pady=MENU_PADDING_1)\r\n            deverb_vocals_Option = ComboBoxMenu(set_vocal_splitter_Frame, dropdown_name='setvocaldeverb', textvariable=self.deverb_vocal_opt_var, values=list(DEVERB_MAPPER.keys()), width=23)\r\n            deverb_vocals_Option.grid(pady=7)\r\n            self.help_hints(deverb_vocals_Option, text=IS_DEVERB_OPT_HELP)#\r\n            \r\n            is_deverb_vocals_Option = ttk.Checkbutton(set_vocal_splitter_Frame, text=DEVERB_VOCALS_TEXT, width=15 if is_windows else 11, variable=self.is_deverb_vocals_var, command=deverb_opt_toggle) \r\n            is_deverb_vocals_Option.grid(pady=0)\r\n            self.help_hints(is_deverb_vocals_Option, text=IS_DEVERB_VOC_HELP)#\r\n            \r\n            if not os.path.isfile(DEVERBER_MODEL_PATH):\r\n                self.is_deverb_vocals_var.set(False)\r\n                is_deverb_vocals_Option.configure(state=tk.DISABLED)\r\n                disable_deverb_opt()\r\n            \r\n            cancel_Button = ttk.Button(set_vocal_splitter_Frame, text=CLOSE_WINDOW, command=lambda:set_vocal_splitter.destroy(), width=16)\r\n            cancel_Button.grid(pady=MENU_PADDING_3)\r\n                \r\n            voc_split_model_toggle()\r\n            deverb_opt_toggle()\r\n                \r\n            self.menu_placement(set_vocal_splitter, VOCAL_SPLIT_OPTIONS_TEXT, top_window=top_window, pop_up=True)\r\n        except Exception as e:\r\n            error_name = f'{type(e).__name__}'\r\n            traceback_text = ''.join(traceback.format_tb(e.__traceback__))\r\n            message = f'{error_name}: \"{e}\"\\n{traceback_text}\"'\r\n            self.error_log_var.set(message)\r\n\r\n    def pop_up_mdx_model(self, mdx_model_hash, model_path):\r\n        \"\"\"Opens MDX-Net model settings\"\"\"\r\n    \r\n        is_compatible_model = True\r\n        is_ckpt = False\r\n        primary_stem = VOCAL_STEM\r\n        \r\n        try:\r\n            if model_path.endswith(ONNX):\r\n                model = onnx.load(model_path)\r\n                model_shapes = [[d.dim_value for d in _input.type.tensor_type.shape.dim] for _input in model.graph.input][0]\r\n                dim_f = model_shapes[2]\r\n                dim_t = int(math.log(model_shapes[3], 2))\r\n                n_fft = '6144'\r\n                \r\n            if model_path.endswith(CKPT):\r\n                is_ckpt = True\r\n                model_params = torch.load(model_path, map_location=lambda storage, loc: storage)\r\n                model_params = model_params['hyper_parameters']\r\n                dim_f = model_params['dim_f']\r\n                dim_t = int(math.log(model_params['dim_t'], 2))\r\n                n_fft = model_params['n_fft']\r\n                \r\n                for stem in STEM_SET_MENU:\r\n                    if model_params['target_name'] == stem.lower():\r\n                        primary_stem = INST_STEM if model_params['target_name'] == OTHER_STEM.lower() else stem\r\n                \r\n        except Exception as e:\r\n            error_name = f'{type(e).__name__}'\r\n            traceback_text = ''.join(traceback.format_tb(e.__traceback__))\r\n            message = f'{error_name}: \"{e}\"\\n{traceback_text}\"'\r\n            #self.error_log_var.set(message)\r\n            is_compatible_model = False\r\n            if is_ckpt:\r\n                self.pop_up_mdx_c_param(mdx_model_hash)\r\n            else:\r\n                dim_f = 0\r\n                dim_t = 0\r\n                self.error_dialoge(INVALID_ONNX_MODEL_ERROR)\r\n                self.error_log_var.set(\"{}\".format(error_text('MDX-Net Model Settings', e)))\r\n                self.mdx_model_params = None\r\n            \r\n        if is_compatible_model:\r\n            mdx_model_set = tk.Toplevel(root)\r\n            mdx_n_fft_scale_set_var = tk.StringVar(value=n_fft)\r\n            mdx_dim_f_set_var = tk.StringVar(value=dim_f)\r\n            mdx_dim_t_set_var = tk.StringVar(value=dim_t)\r\n            primary_stem_var = tk.StringVar(value=primary_stem)\r\n            mdx_compensate_var = tk.StringVar(value=1.035)\r\n            \r\n            balance_value_var = tk.StringVar(value=0)\r\n            is_kara_model_var = tk.BooleanVar(value=False)\r\n            is_bv_model_var = tk.BooleanVar(value=False)\r\n                \r\n            def toggle_kara():\r\n                if is_kara_model_var.get():\r\n                    is_bv_model_var.set(False)\r\n                    balance_value_Option.configure(state=tk.DISABLED)\r\n                    \r\n            def toggle_bv():\r\n                if is_bv_model_var.get():\r\n                    is_kara_model_var.set(False)\r\n                    balance_value_Option.configure(state=READ_ONLY)\r\n                else:\r\n                    balance_value_Option.configure(state=tk.DISABLED)\r\n\r\n            def opt_menu_selection(selection):\r\n                if not selection in [VOCAL_STEM, INST_STEM]:\r\n                    balance_value_Option.configure(state=tk.DISABLED)\r\n                    is_kara_model_Option.configure(state=tk.DISABLED)\r\n                    is_bv_model_Option.configure(state=tk.DISABLED)\r\n                    is_kara_model_var.set(False)\r\n                    is_bv_model_var.set(False)\r\n                    balance_value_var.set(0)\r\n                else:\r\n                    is_kara_model_Option.configure(state=tk.NORMAL)\r\n                    is_bv_model_Option.configure(state=tk.NORMAL)\r\n                \r\n            mdx_model_set_Frame = self.menu_FRAME_SET(mdx_model_set)\r\n            mdx_model_set_Frame.grid(row=2)  \r\n            \r\n            mdx_model_set_title = self.menu_title_LABEL_SET(mdx_model_set_Frame, SPECIFY_MDX_NET_MODEL_PARAMETERS_TEXT)\r\n            mdx_model_set_title.grid(pady=MENU_PADDING_3)\r\n                    \r\n            set_stem_name_Label = self.menu_sub_LABEL_SET(mdx_model_set_Frame, PRIMARY_STEM_TEXT)\r\n            set_stem_name_Label.grid(pady=MENU_PADDING_1)\r\n            set_stem_name_Option = ttk.OptionMenu(mdx_model_set_Frame, primary_stem_var, None, *STEM_SET_MENU, command=opt_menu_selection)\r\n            set_stem_name_Option.configure(width=15)\r\n            set_stem_name_Option.grid(pady=MENU_PADDING_1)\r\n            set_stem_name_Option['menu'].insert_separator(len(STEM_SET_MENU))\r\n            set_stem_name_Option['menu'].add_radiobutton(label=INPUT_STEM_NAME, command=tk._setit(primary_stem_var, INPUT_STEM_NAME, lambda e:self.pop_up_input_stem_name(primary_stem_var, mdx_model_set)))\r\n            self.help_hints(set_stem_name_Label, text=SET_STEM_NAME_HELP)\r\n\r\n            is_kara_model_Option = ttk.Checkbutton(mdx_model_set_Frame, text=KARAOKE_MODEL_TEXT, width=SET_MENUS_CHECK_WIDTH, variable=is_kara_model_var, command=toggle_kara) \r\n            is_kara_model_Option.grid(pady=0)\r\n\r\n            is_bv_model_Option = ttk.Checkbutton(mdx_model_set_Frame, text=BV_MODEL_TEXT, width=SET_MENUS_CHECK_WIDTH, variable=is_bv_model_var, command=toggle_bv) \r\n            is_bv_model_Option.grid(pady=0)\r\n\r\n            balance_value_Label = self.menu_sub_LABEL_SET(mdx_model_set_Frame, BALANCE_VALUE_TEXT)\r\n            balance_value_Label.grid(pady=MENU_PADDING_1)\r\n            balance_value_Option = ComboBoxMenu(mdx_model_set_Frame, textvariable=balance_value_var, values=BALANCE_VALUES, width=COMBO_WIDTH)\r\n            balance_value_Option.configure(state=tk.DISABLED)\r\n            balance_value_Option.grid(pady=MENU_PADDING_1)\r\n            #self.help_hints(balance_value_Label, text=balance_value_HELP)\r\n\r\n            mdx_dim_t_set_Label = self.menu_sub_LABEL_SET(mdx_model_set_Frame, 'Dim_t')\r\n            mdx_dim_t_set_Label.grid(pady=MENU_PADDING_1)\r\n            mdx_dim_f_set_Label = self.menu_sub_LABEL_SET(mdx_model_set_Frame, MDX_MENU_WAR_TEXT)\r\n            mdx_dim_f_set_Label.grid(pady=MENU_PADDING_1)\r\n            mdx_dim_t_set_Option = ComboBoxEditableMenu(mdx_model_set_Frame, values=('7', '8'), textvariable=mdx_dim_t_set_var, pattern=REG_SHIFTS, default=mdx_dim_t_set_var.get(), width=COMBO_WIDTH, is_stay_disabled=is_ckpt)\r\n            mdx_dim_t_set_Option.grid(pady=MENU_PADDING_1)\r\n            self.help_hints(mdx_dim_t_set_Label, text=MDX_DIM_T_SET_HELP)\r\n            \r\n            mdx_dim_f_set_Label = self.menu_sub_LABEL_SET(mdx_model_set_Frame, 'Dim_f')\r\n            mdx_dim_f_set_Label.grid(pady=MENU_PADDING_1)\r\n            mdx_dim_f_set_Label = self.menu_sub_LABEL_SET(mdx_model_set_Frame, MDX_MENU_WAR_TEXT)\r\n            mdx_dim_f_set_Label.grid(pady=MENU_PADDING_1)\r\n            mdx_dim_f_set_Option = ComboBoxEditableMenu(mdx_model_set_Frame, values=(MDX_POP_DIMF), textvariable=mdx_dim_f_set_var, pattern=REG_SHIFTS, default=mdx_dim_f_set_var.get(), width=COMBO_WIDTH, is_stay_disabled=is_ckpt)\r\n            mdx_dim_f_set_Option.grid(pady=MENU_PADDING_1)\r\n            self.help_hints(mdx_dim_f_set_Label, text=MDX_DIM_F_SET_HELP)\r\n\r\n            mdx_n_fft_scale_set_Label = self.menu_sub_LABEL_SET(mdx_model_set_Frame, 'N_FFT Scale')\r\n            mdx_n_fft_scale_set_Label.grid(pady=MENU_PADDING_1)\r\n            mdx_n_fft_scale_set_Option = ComboBoxEditableMenu(mdx_model_set_Frame, values=(MDX_POP_NFFT), textvariable=mdx_n_fft_scale_set_var, pattern=REG_SHIFTS, default=mdx_n_fft_scale_set_var.get(), width=COMBO_WIDTH, is_stay_disabled=is_ckpt)\r\n            mdx_n_fft_scale_set_Option.grid(pady=MENU_PADDING_1)\r\n            self.help_hints(mdx_n_fft_scale_set_Label, text=MDX_N_FFT_SCALE_SET_HELP)\r\n            \r\n            mdx_compensate_Label = self.menu_sub_LABEL_SET(mdx_model_set_Frame, VOLUME_COMPENSATION_TEXT)\r\n            mdx_compensate_Label.grid(pady=MENU_PADDING_1)\r\n            mdx_compensate_Entry = ComboBoxEditableMenu(mdx_model_set_Frame, values=('1.035', '1.08'), textvariable=mdx_compensate_var, pattern=REG_VOL_COMP, default=mdx_compensate_var.get(), width=COMBO_WIDTH)\r\n            mdx_compensate_Entry.grid(pady=MENU_PADDING_1)\r\n            self.help_hints(mdx_compensate_Label, text=POPUP_COMPENSATE_HELP)\r\n\r\n            mdx_param_set_Button = ttk.Button(mdx_model_set_Frame, text=CONFIRM_TEXT, command=lambda:pull_data())\r\n            mdx_param_set_Button.grid(pady=MENU_PADDING_2)\r\n            \r\n            stop_process_Button = ttk.Button(mdx_model_set_Frame, text=CANCEL_TEXT, command=lambda:cancel())\r\n            stop_process_Button.grid(pady=0)\r\n            \r\n            if is_ckpt:\r\n                mdx_dim_t_set_Option.configure(state=tk.DISABLED)\r\n                mdx_dim_f_set_Option.configure(state=tk.DISABLED)\r\n                mdx_n_fft_scale_set_Option.configure(state=tk.DISABLED)\r\n            \r\n            def pull_data():\r\n                mdx_model_params = {\r\n                    'compensate': float(mdx_compensate_var.get()),\r\n                    'mdx_dim_f_set': int(mdx_dim_f_set_var.get()),\r\n                    'mdx_dim_t_set': int(mdx_dim_t_set_var.get()),\r\n                    'mdx_n_fft_scale_set': int(mdx_n_fft_scale_set_var.get()),\r\n                    'primary_stem': primary_stem_var.get(),\r\n                    IS_KARAOKEE: bool(is_kara_model_var.get()),\r\n                    IS_BV_MODEL: bool(is_bv_model_var.get()),\r\n                    IS_BV_MODEL_REBAL: float(balance_value_var.get())\r\n                    }\r\n                \r\n                self.pop_up_mdx_model_sub_json_dump(mdx_model_params, mdx_model_hash)\r\n                mdx_model_set.destroy()\r\n\r\n            def cancel():\r\n                mdx_model_set.destroy()\r\n                \r\n            mdx_model_set.protocol(\"WM_DELETE_WINDOW\", cancel)\r\n   \r\n            frame_list = [mdx_model_set_Frame]\r\n            opt_menu_selection(primary_stem_var.get())\r\n            self.menu_placement(mdx_model_set, SPECIFY_PARAMETERS_TEXT, pop_up=False if is_macos else True, frame_list=frame_list)\r\n                        \r\n    def pop_up_mdx_model_sub_json_dump(self, mdx_model_params, mdx_model_hash):\r\n        \"\"\"Dumps current selected MDX-Net model settings to a json named after model hash\"\"\"\r\n        \r\n        self.mdx_model_params = mdx_model_params\r\n\r\n        mdx_model_params_dump = json.dumps(mdx_model_params, indent=4)\r\n        with open(os.path.join(MDX_HASH_DIR, f'{mdx_model_hash}.json'), \"w\") as outfile:\r\n            outfile.write(mdx_model_params_dump)\r\n        \r\n    def pop_up_mdx_c_param(self, mdx_model_hash):\r\n        \"\"\"Opens MDX-C param settings\"\"\"\r\n\r\n        mdx_c_param_menu = tk.Toplevel()\r\n        \r\n        get_mdx_c_params = lambda dir, ext:tuple(os.path.splitext(x)[0] for x in os.listdir(dir) if x.endswith(ext))\r\n        new_mdx_c_params = get_mdx_c_params(MDX_C_CONFIG_PATH, YAML)\r\n        mdx_c_model_param_var = tk.StringVar(value=NONE_SELECTED)\r\n        \r\n        def pull_data():\r\n            mdx_c_model_params = {\r\n                'config_yaml': f\"{mdx_c_model_param_var.get()}{YAML}\"}\r\n            \r\n            if not mdx_c_model_param_var.get() == NONE_SELECTED:\r\n                self.pop_up_mdx_model_sub_json_dump(mdx_c_model_params, mdx_model_hash)\r\n                mdx_c_param_menu.destroy()\r\n            else:\r\n                self.mdx_model_params = None\r\n        \r\n        def cancel():\r\n            self.mdx_model_params = None\r\n            mdx_c_param_menu.destroy()\r\n        \r\n        mdx_c_param_Frame = self.menu_FRAME_SET(mdx_c_param_menu)\r\n        mdx_c_param_Frame.grid(row=0)  \r\n        \r\n        mdx_c_param_title_title = self.menu_title_LABEL_SET(mdx_c_param_Frame, MDXNET_C_MODEL_PARAMETERS_TEXT, width=28)\r\n        mdx_c_param_title_title.grid(row=0,column=0,padx=0,pady=0)\r\n                \r\n        mdx_c_model_param_Label = self.menu_sub_LABEL_SET(mdx_c_param_Frame, SELECT_MODEL_PARAM_TEXT)\r\n        mdx_c_model_param_Label.grid(pady=MENU_PADDING_1)\r\n        mdx_c_model_param_Option = ComboBoxMenu(mdx_c_param_Frame, textvariable=mdx_c_model_param_var, values=new_mdx_c_params, width=30)\r\n        mdx_c_model_param_Option.grid(padx=20,pady=MENU_PADDING_1)\r\n        self.help_hints(mdx_c_model_param_Label, text=VR_MODEL_PARAM_HELP)\r\n\r\n        mdx_c_param_confrim_Button = ttk.Button(mdx_c_param_Frame, text=CONFIRM_TEXT, command=lambda:pull_data())\r\n        mdx_c_param_confrim_Button.grid(pady=MENU_PADDING_1)\r\n        \r\n        mdx_c_param_cancel_Button = ttk.Button(mdx_c_param_Frame, text=CANCEL_TEXT, command=cancel)\r\n        mdx_c_param_cancel_Button.grid(pady=MENU_PADDING_1)\r\n        \r\n        mdx_c_param_menu.protocol(\"WM_DELETE_WINDOW\", cancel)\r\n        \r\n        self.menu_placement(mdx_c_param_menu, CHOOSE_MODEL_PARAM_TEXT, pop_up=True)\r\n        \r\n    def pop_up_vr_param(self, vr_model_hash):\r\n        \"\"\"Opens VR param settings\"\"\"\r\n\r\n        vr_param_menu = tk.Toplevel()\r\n        \r\n        get_vr_params = lambda dir, ext:tuple(os.path.splitext(x)[0] for x in os.listdir(dir) if x.endswith(ext))\r\n        new_vr_params = get_vr_params(VR_PARAM_DIR, JSON)\r\n        vr_model_param_var = tk.StringVar(value=NONE_SELECTED)\r\n        vr_model_stem_var = tk.StringVar(value='Vocals')\r\n        vr_model_nout_var = tk.StringVar(value=32)\r\n        vr_model_nout_lstm_var = tk.StringVar(value=128)\r\n        is_new_vr_model_var = tk.BooleanVar(value=False)\r\n        balance_value_var = tk.StringVar(value=0)\r\n        is_kara_model_var = tk.BooleanVar(value=False)\r\n        is_bv_model_var = tk.BooleanVar(value=False)\r\n        \r\n        enable_new_vr_op = lambda:(vr_model_nout_Option.configure(state=READ_ONLY), vr_model_nout_lstm_Option.configure(state=READ_ONLY))\r\n        disable_new_vr_op = lambda:(vr_model_nout_Option.configure(state=tk.DISABLED), vr_model_nout_lstm_Option.configure(state=tk.DISABLED))\r\n        vr_new_toggle = lambda:enable_new_vr_op() if is_new_vr_model_var.get() else disable_new_vr_op()\r\n        \r\n        def pull_data():\r\n            if is_new_vr_model_var.get():\r\n                vr_model_params = {\r\n                    'vr_model_param': vr_model_param_var.get(),\r\n                    'primary_stem': vr_model_stem_var.get(),\r\n                    'nout': int(vr_model_nout_var.get()),\r\n                    'nout_lstm': int(vr_model_nout_lstm_var.get()),\r\n                    IS_KARAOKEE: bool(is_kara_model_var.get()),\r\n                    IS_BV_MODEL: bool(is_bv_model_var.get()),\r\n                    IS_BV_MODEL_REBAL: float(balance_value_var.get())\r\n                    }\r\n            else:\r\n                vr_model_params = {\r\n                    'vr_model_param': vr_model_param_var.get(),\r\n                    'primary_stem': vr_model_stem_var.get(),\r\n                    IS_KARAOKEE: bool(is_kara_model_var.get()),\r\n                    IS_BV_MODEL: bool(is_bv_model_var.get()),\r\n                    IS_BV_MODEL_REBAL: float(balance_value_var.get())}\r\n\r\n            if not vr_model_param_var.get() == NONE_SELECTED:\r\n                self.pop_up_vr_param_sub_json_dump(vr_model_params, vr_model_hash)\r\n                vr_param_menu.destroy()\r\n            else:\r\n                self.vr_model_params = None\r\n                self.error_dialoge(INVALID_PARAM_MODEL_ERROR)\r\n                \r\n        def cancel():\r\n            self.vr_model_params = None\r\n            vr_param_menu.destroy()\r\n        \r\n        def toggle_kara():\r\n            if is_kara_model_var.get():\r\n                is_bv_model_var.set(False)\r\n                balance_value_Option.configure(state=tk.DISABLED)\r\n                \r\n        def toggle_bv():\r\n            if is_bv_model_var.get():\r\n                is_kara_model_var.set(False)\r\n                balance_value_Option.configure(state=READ_ONLY)\r\n            else:\r\n                balance_value_Option.configure(state=tk.DISABLED)\r\n\r\n        def opt_menu_selection(selection):\r\n            if not selection in [VOCAL_STEM, INST_STEM]:\r\n                balance_value_Option.configure(state=tk.DISABLED)\r\n                is_kara_model_Option.configure(state=tk.DISABLED)\r\n                is_bv_model_Option.configure(state=tk.DISABLED)\r\n                is_kara_model_var.set(False)\r\n                is_bv_model_var.set(False)\r\n                balance_value_var.set(0)\r\n            else:\r\n                is_kara_model_Option.configure(state=tk.NORMAL)\r\n                is_bv_model_Option.configure(state=tk.NORMAL)\r\n\r\n        vr_param_Frame = self.menu_FRAME_SET(vr_param_menu)\r\n        vr_param_Frame.grid(row=0, padx=20)  \r\n            \r\n        vr_param_title_title = self.menu_title_LABEL_SET(vr_param_Frame, SPECIFY_VR_MODEL_PARAMETERS_TEXT)\r\n        vr_param_title_title.grid()\r\n                \r\n        vr_model_stem_Label = self.menu_sub_LABEL_SET(vr_param_Frame, PRIMARY_STEM_TEXT)\r\n        vr_model_stem_Label.grid(pady=MENU_PADDING_1)    \r\n        vr_model_stem_Option = ttk.OptionMenu(vr_param_Frame, vr_model_stem_var, None, *STEM_SET_MENU, command=opt_menu_selection)\r\n        vr_model_stem_Option.configure(width=15)\r\n        vr_model_stem_Option.grid(pady=MENU_PADDING_1)\r\n        vr_model_stem_Option['menu'].insert_separator(len(STEM_SET_MENU))\r\n        vr_model_stem_Option['menu'].add_radiobutton(label=INPUT_STEM_NAME, command=tk._setit(vr_model_stem_var, INPUT_STEM_NAME, lambda e:self.pop_up_input_stem_name(vr_model_stem_var, vr_param_menu)))\r\n        self.help_hints(vr_model_stem_Label, text=SET_STEM_NAME_HELP)\r\n                \r\n        is_kara_model_Option = ttk.Checkbutton(vr_param_Frame, text=KARAOKE_MODEL_TEXT, width=SET_MENUS_CHECK_WIDTH, variable=is_kara_model_var, command=toggle_kara) \r\n        is_kara_model_Option.grid(pady=0)\r\n\r\n        is_bv_model_Option = ttk.Checkbutton(vr_param_Frame, text=BV_MODEL_TEXT, width=SET_MENUS_CHECK_WIDTH, variable=is_bv_model_var, command=toggle_bv) \r\n        is_bv_model_Option.grid(pady=0)\r\n\r\n        balance_value_Label = self.menu_sub_LABEL_SET(vr_param_Frame, BALANCE_VALUE_TEXT)\r\n        balance_value_Label.grid(pady=MENU_PADDING_1)\r\n        balance_value_Option = ComboBoxMenu(vr_param_Frame, textvariable=balance_value_var, values=BALANCE_VALUES, width=COMBO_WIDTH)\r\n        balance_value_Option.configure(state=tk.DISABLED)\r\n        balance_value_Option.grid(pady=MENU_PADDING_1)\r\n                \r\n        is_new_vr_model_Option = ttk.Checkbutton(vr_param_Frame, text=VR_51_MODEL_TEXT, width=SET_MENUS_CHECK_WIDTH, variable=is_new_vr_model_var, command=vr_new_toggle) \r\n        is_new_vr_model_Option.grid(pady=MENU_PADDING_1)\r\n        \r\n        vr_model_nout_Label = self.menu_sub_LABEL_SET(vr_param_Frame, 'Out Channels')\r\n        vr_model_nout_Label.grid(pady=MENU_PADDING_1)\r\n        vr_model_nout_Option = ComboBoxEditableMenu(vr_param_Frame, values=NOUT_SEL, textvariable=vr_model_nout_var, pattern=REG_SHIFTS, default='32', width=COMBO_WIDTH)\r\n        vr_model_nout_Option.grid(pady=MENU_PADDING_1)\r\n        #self.help_hints(vr_model_nout_Label, text=VR_MODEL_NOUT_HELP)\r\n\r\n        vr_model_nout_lstm_Label = self.menu_sub_LABEL_SET(vr_param_Frame, 'Out Channels (LSTM layer)')\r\n        vr_model_nout_lstm_Label.grid(pady=MENU_PADDING_1)\r\n        vr_model_nout_lstm_Option = ComboBoxEditableMenu(vr_param_Frame, values=NOUT_LSTM_SEL, textvariable=vr_model_nout_lstm_var, pattern=REG_SHIFTS, default='128', width=COMBO_WIDTH)#\r\n        vr_model_nout_lstm_Option.grid(pady=MENU_PADDING_1)\r\n        #self.help_hints(vr_model_param_Label, text=VR_MODEL_NOUT_LSTM_HELP)\r\n\r\n        vr_model_param_Label = self.menu_sub_LABEL_SET(vr_param_Frame, SELECT_MODEL_PARAM_TEXT)\r\n        vr_model_param_Label.grid(pady=MENU_PADDING_1)\r\n        vr_model_param_Option = ComboBoxMenu(vr_param_Frame, textvariable=vr_model_param_var, values=new_vr_params, width=30)\r\n        vr_model_param_Option.grid(pady=MENU_PADDING_1)\r\n        self.help_hints(vr_model_param_Label, text=VR_MODEL_PARAM_HELP)\r\n\r\n        vr_param_confrim_Button = ttk.Button(vr_param_Frame, text=CONFIRM_TEXT, command=lambda:pull_data())\r\n        vr_param_confrim_Button.grid(pady=MENU_PADDING_1)\r\n        \r\n        vr_param_cancel_Button = ttk.Button(vr_param_Frame, text=CANCEL_TEXT, command=cancel)\r\n        vr_param_cancel_Button.grid(pady=MENU_PADDING_1)\r\n        \r\n        vr_new_toggle()\r\n        opt_menu_selection(vr_model_stem_var.get())\r\n        \r\n        vr_param_menu.protocol(\"WM_DELETE_WINDOW\", cancel)\r\n        \r\n        frame_list = [vr_param_Frame]\r\n        self.menu_placement(vr_param_menu, CHOOSE_MODEL_PARAM_TEXT, pop_up=False if is_macos else True, frame_list=frame_list)\r\n\r\n    def pop_up_vr_param_sub_json_dump(self, vr_model_params, vr_model_hash):\r\n        \"\"\"Dumps current selected VR model settings to a json named after model hash\"\"\"\r\n        \r\n        self.vr_model_params = vr_model_params\r\n\r\n        vr_model_params_dump = json.dumps(vr_model_params, indent=4)\r\n        \r\n        with open(os.path.join(VR_HASH_DIR, f'{vr_model_hash}.json'), \"w\") as outfile:\r\n            outfile.write(vr_model_params_dump)\r\n\r\n    def pop_up_input_stem_name(self, stem_var:tk.StringVar, parent_window:tk.Toplevel):\r\n        \"\"\"\r\n        Input Stem Name\r\n        \"\"\"\r\n        \r\n        stem_input_save = tk.Toplevel(root)\r\n        \r\n        def close_window(is_cancel=True):\r\n            \r\n            if is_cancel or not stem_input_save_var.get():\r\n                stem_var.set(VOCAL_STEM)\r\n            else:\r\n                stem_input_save_text = stem_input_save_var.get().capitalize()\r\n                \r\n                if stem_input_save_text == VOCAL_STEM:\r\n                    stem_text = INST_STEM if is_inverse_stem_var.get() else stem_input_save_text\r\n                elif stem_input_save_text == INST_STEM:\r\n                    stem_text = VOCAL_STEM if is_inverse_stem_var.get() else stem_input_save_text\r\n                else:\r\n                    stem_text = f\"{NO_STEM}{stem_input_save_text}\" if is_inverse_stem_var.get() else stem_input_save_text\r\n                    \r\n                stem_var.set(stem_text)\r\n\r\n            stem_input_save.destroy()\r\n            \r\n            parent_window.attributes('-topmost', 'true') if OPERATING_SYSTEM == \"Linux\" else None\r\n            parent_window.grab_set()\r\n            root.wait_window(parent_window)\r\n        \r\n        stem_input_save_var = tk.StringVar(value='')\r\n        is_inverse_stem_var = tk.BooleanVar(value=False)\r\n\r\n        validation = lambda value:False if re.fullmatch(REG_INPUT_STEM_NAME, value) is None else True\r\n        stem_input_save_Frame = self.menu_FRAME_SET(stem_input_save)\r\n        stem_input_save_Frame.grid(row=1)  \r\n\r\n        stem_input_save_title = self.menu_title_LABEL_SET(stem_input_save_Frame, INPUT_STEM_NAME_TEXT)\r\n        stem_input_save_title.grid(pady=0)\r\n        \r\n        stem_input_name_Label = self.menu_sub_LABEL_SET(stem_input_save_Frame, STEM_NAME_TEXT)\r\n        stem_input_name_Label.grid(pady=MENU_PADDING_1)\r\n        stem_input_name_Entry = ttk.Combobox(stem_input_save_Frame, textvariable=stem_input_save_var, values=STEM_SET_MENU_2, justify='center', width=25)\r\n        invalid_message = self.invalid_tooltip(stem_input_name_Entry, REG_INPUT_STEM_NAME)\r\n        stem_input_name_Entry.grid(pady=MENU_PADDING_1)\r\n        stem_input_name_Entry.focus_set()\r\n        \r\n        self.spacer_label(stem_input_save_Frame)\r\n        \r\n        is_inverse_stem_Button = ttk.Checkbutton(stem_input_save_Frame, text=IS_INVERSE_STEM_TEXT, variable=is_inverse_stem_var)\r\n        is_inverse_stem_Button.grid(pady=0)\r\n\r\n        entry_rules_Label = tk.Label(stem_input_save_Frame, text=STEM_INPUT_RULE, font=(MAIN_FONT_NAME, f\"{FONT_SIZE_1}\"), foreground='#868687', justify=\"left\")\r\n        entry_rules_Label.grid(pady=MENU_PADDING_1)     \r\n        \r\n        mdx_param_set_Button = ttk.Button(stem_input_save_Frame, text=DONE_MENU_TEXT, command=lambda:close_window(is_cancel=False) if validation(stem_input_save_var.get()) else invalid_message())\r\n        mdx_param_set_Button.grid(pady=MENU_PADDING_1)\r\n        \r\n        stop_process_Button = ttk.Button(stem_input_save_Frame, text=CANCEL_TEXT, command=close_window)\r\n        stop_process_Button.grid(pady=MENU_PADDING_1)\r\n\r\n        stem_input_save.protocol(\"WM_DELETE_WINDOW\", close_window)\r\n\r\n        frame_list = [stem_input_save_Frame]\r\n        self.menu_placement(stem_input_save, INPUT_UNIQUE_STEM_NAME_TEXT, pop_up=True, frame_list=frame_list)\r\n\r\n    def pop_up_save_ensemble(self):\r\n        \"\"\"\r\n        Save Ensemble as...\r\n        \"\"\"\r\n        \r\n        ensemble_save = tk.Toplevel(root)\r\n        \r\n        ensemble_save_var = tk.StringVar(value='')\r\n\r\n        ensemble_save_Frame = self.menu_FRAME_SET(ensemble_save)\r\n        ensemble_save_Frame.grid(row=1)  \r\n        \r\n        validation = lambda value:False if re.fullmatch(REG_SAVE_INPUT, value) is None else True\r\n        save_func = lambda:(self.pop_up_save_ensemble_sub_json_dump(self.ensemble_listbox_get_all_selected_models(), ensemble_save_var.get()), ensemble_save.destroy())\r\n\r\n        if len(self.ensemble_listbox_get_all_selected_models()) <= 1:\r\n            ensemble_save_title = self.menu_title_LABEL_SET(ensemble_save_Frame, ENSEMBLE_WARNING_NOT_ENOUGH_SHORT_TEXT, width=20)\r\n            ensemble_save_title.grid()\r\n            \r\n            ensemble_save_title = self.menu_sub_LABEL_SET(ensemble_save_Frame, ENSEMBLE_WARNING_NOT_ENOUGH_TEXT)\r\n            ensemble_save_title.grid(pady=MENU_PADDING_1)\r\n            \r\n            stop_process_Button = ttk.Button(ensemble_save_Frame, text=OK_TEXT, command=lambda:ensemble_save.destroy())\r\n            stop_process_Button.grid()\r\n        else:\r\n            ensemble_save_title = self.menu_title_LABEL_SET(ensemble_save_Frame, SAVE_CURRENT_ENSEMBLE_TEXT)\r\n            ensemble_save_title.grid()\r\n            \r\n            ensemble_name_Label = self.menu_sub_LABEL_SET(ensemble_save_Frame, ENSEMBLE_NAME_TEXT)\r\n            ensemble_name_Label.grid(pady=MENU_PADDING_1)\r\n            ensemble_name_Entry = ttk.Entry(ensemble_save_Frame, textvariable=ensemble_save_var, justify='center', width=25)\r\n            ensemble_name_Entry.grid(pady=MENU_PADDING_1)\r\n            invalid_message = self.invalid_tooltip(ensemble_name_Entry)\r\n            ensemble_name_Entry.focus_set()\r\n            self.spacer_label(ensemble_save_Frame)\r\n            \r\n            entry_rules_Label = tk.Label(ensemble_save_Frame, text=ENSEMBLE_INPUT_RULE, font=(MAIN_FONT_NAME, f\"{FONT_SIZE_1}\"), foreground='#868687', justify=\"left\")\r\n            entry_rules_Label.grid()     \r\n            \r\n            mdx_param_set_Button = ttk.Button(ensemble_save_Frame, text=SAVE_TEXT, command=lambda:save_func() if validation(ensemble_save_var.get()) else invalid_message())\r\n            mdx_param_set_Button.grid(pady=MENU_PADDING_1)\r\n            \r\n            stop_process_Button = ttk.Button(ensemble_save_Frame, text=CANCEL_TEXT, command=lambda:ensemble_save.destroy())\r\n            stop_process_Button.grid(pady=MENU_PADDING_1)\r\n            \r\n        self.menu_placement(ensemble_save, SAVE_CURRENT_ENSEMBLE_TEXT, pop_up=True)\r\n        \r\n    def pop_up_save_ensemble_sub_json_dump(self, selected_ensemble_model, ensemble_save_name: str):\r\n        \"\"\"Dumps current ensemble settings to a json named after user input\"\"\"\r\n        \r\n        if ensemble_save_name:\r\n            self.chosen_ensemble_var.set(ensemble_save_name)\r\n            ensemble_save_name = ensemble_save_name.replace(\" \", \"_\")\r\n            saved_data = {\r\n                'ensemble_main_stem': self.ensemble_main_stem_var.get(),\r\n                'ensemble_type': self.ensemble_type_var.get(),\r\n                'selected_models': selected_ensemble_model,\r\n                }\r\n            \r\n            saved_data_dump = json.dumps(saved_data, indent=4)\r\n            with open(os.path.join(ENSEMBLE_CACHE_DIR, f'{ensemble_save_name}.json'), \"w\") as outfile:\r\n                outfile.write(saved_data_dump)\r\n\r\n    def deletion_list_fill(self, option_menu: ComboBoxMenu, selection_var: tk.StringVar, selection_dir, var_set, menu_name=None):\r\n        \"\"\"Fills the saved settings menu located in tab 2 of the main settings window\"\"\"\r\n                \r\n        def command_callback(event=None):\r\n            self.deletion_entry(selection_var.get(), selection_dir, refresh_menu)\r\n            selection_var.set(var_set)\r\n\r\n        def refresh_menu(remove=None):\r\n            selection_list = self.last_found_ensembles if menu_name == 'deleteensemble' else self.last_found_settings\r\n            main_var = self.chosen_ensemble_var if menu_name == 'deleteensemble' else self.save_current_settings_var\r\n            \r\n            if remove and remove in selection_list:\r\n                selection_list = list(selection_list)\r\n                selection_list.remove(remove)\r\n                main_var.set(CHOOSE_ENSEMBLE_OPTION)\r\n            \r\n            self.update_menus(option_widget=option_menu, \r\n                              style_name=menu_name, \r\n                              command=command_callback,\r\n                              new_items=selection_list)\r\n\r\n        refresh_menu()\r\n        \r\n    def deletion_entry(self, selection: str, path, callback):\r\n        \"\"\"Deletes selected user saved application settings\"\"\"\r\n        \r\n        if selection not in [SELECT_SAVED_SET, SELECT_SAVED_ENSEMBLE]:\r\n            saved_path = os.path.join(path, f'{selection.replace(\" \", \"_\")}.json')\r\n            confirm = self.message_box(DELETE_ENS_ENTRY)\r\n            if confirm:\r\n                if os.path.isfile(saved_path):\r\n                    os.remove(saved_path)\r\n                    callback(selection)\r\n\r\n    #--Download Center Methods--    \r\n\r\n    def online_data_refresh(self, user_refresh=True, confirmation_box=False, refresh_list_Button=False, is_start_up=False, is_download_complete=False):\r\n        \"\"\"Checks for application updates\"\"\"\r\n        \r\n        def online_check():\r\n            if not is_start_up:\r\n                self.app_update_status_Text_var.set(LOADING_VERSION_INFO_TEXT)\r\n                self.app_update_button_Text_var.set(CHECK_FOR_UPDATES_TEXT)\r\n\r\n            is_new_update = False\r\n            try:\r\n                self.online_data = json.load(urllib.request.urlopen(DOWNLOAD_CHECKS))\r\n                self.is_online = True\r\n\r\n                try:\r\n                    with urllib.request.urlopen(BULLETIN_CHECK) as response:\r\n                        self.bulletin_data = response.read().decode('utf-8')\r\n\r\n                    if not is_windows:\r\n                        self.bulletin_data = read_bulliten_text_mac(CR_TEXT, self.bulletin_data)\r\n                    else:\r\n                        self.bulletin_data = self.bulletin_data.replace(\"~\", \"\")\r\n\r\n                except Exception as e:\r\n                    self.bulletin_data = INFO_UNAVAILABLE_TEXT\r\n                    print(e)\r\n\r\n                if user_refresh:\r\n                    self.download_list_state()\r\n                    for widget in self.download_center_Buttons:\r\n                        widget.configure(state=tk.NORMAL)\r\n                    \r\n                if refresh_list_Button:\r\n                    self.download_progress_info_var.set('Download List Refreshed!')\r\n\r\n                if OPERATING_SYSTEM==\"Darwin\":\r\n                    self.lastest_version = self.online_data[\"current_version_mac\"]\r\n                elif OPERATING_SYSTEM==\"Linux\":\r\n                    self.lastest_version = self.online_data[\"current_version_linux\"]\r\n                else:\r\n                    self.lastest_version = self.online_data[\"current_version\"]\r\n                    \r\n                if self.lastest_version == current_patch and not is_start_up:\r\n                    self.app_update_status_Text_var.set('UVR Version Current')\r\n                else:\r\n                    is_new_update = True\r\n                    is_beta_version = True if self.lastest_version == PREVIOUS_PATCH_WIN and BETA_VERSION in current_patch else False\r\n                    \r\n                    if not is_start_up:\r\n                        if is_beta_version:\r\n                            self.app_update_status_Text_var.set(f\"Roll Back: {self.lastest_version}\")\r\n                            self.app_update_button_Text_var.set(ROLL_BACK_TEXT)\r\n                        else:\r\n                            self.app_update_status_Text_var.set(f\"Update Found: {self.lastest_version}\")\r\n                            self.app_update_button_Text_var.set('Click Here to Update')\r\n                        \r\n                        if OPERATING_SYSTEM == \"Windows\":\r\n                            self.download_update_link_var.set('{}{}{}'.format(UPDATE_REPO, self.lastest_version, application_extension))\r\n                            self.download_update_path_var.set(os.path.join(BASE_PATH, f'{self.lastest_version}{application_extension}'))\r\n                        elif OPERATING_SYSTEM == \"Darwin\":\r\n                            self.download_update_link_var.set(UPDATE_MAC_ARM_REPO if SYSTEM_PROC == ARM or ARM in SYSTEM_ARCH else UPDATE_MAC_X86_64_REPO)\r\n                        elif OPERATING_SYSTEM == \"Linux\":\r\n                            self.download_update_link_var.set(UPDATE_LINUX_REPO)\r\n                    \r\n                    if not user_refresh:\r\n                        if not is_beta_version and not self.lastest_version == current_patch:\r\n                            self.command_Text.write(NEW_UPDATE_FOUND_TEXT(self.lastest_version))\r\n\r\n\r\n                is_update_params = self.is_auto_update_model_params if is_start_up else self.is_auto_update_model_params_var.get()\r\n                \r\n                if is_update_params and is_start_up or is_download_complete:\r\n                    self.download_model_settings()\r\n                    \r\n                # if is_download_complete:\r\n                #     self.download_model_settings()\r\n\r\n            except Exception as e:\r\n                self.offline_state_set(is_start_up)\r\n                is_new_update = False\r\n                \r\n                if user_refresh:\r\n                    self.download_list_state(disable_only=True)\r\n                    for widget in self.download_center_Buttons:\r\n                        widget.configure(state=tk.DISABLED)\r\n                        \r\n                try:\r\n                    self.error_log_var.set(error_text('Online Data Refresh', e))\r\n                except Exception as e:\r\n                    print(e)\r\n\r\n            return is_new_update\r\n            \r\n        if confirmation_box:\r\n            return online_check()\r\n        else:\r\n            self.current_thread = KThread(target=online_check)\r\n            self.current_thread.setDaemon(True) if not is_windows else None\r\n            self.current_thread.start()\r\n\r\n    def offline_state_set(self, is_start_up=False):\r\n        \"\"\"Changes relevant settings and \"Download Center\" buttons if no internet connection is available\"\"\"\r\n        \r\n        if not is_start_up and self.is_menu_settings_open:\r\n            self.app_update_status_Text_var.set(f'Version Status: {NO_CONNECTION}')\r\n            self.download_progress_info_var.set(NO_CONNECTION) \r\n            self.app_update_button_Text_var.set('Refresh')\r\n            self.refresh_list_Button.configure(state=tk.NORMAL)\r\n            self.stop_download_Button_DISABLE()\r\n            self.enable_tabs()\r\n            \r\n        self.is_online = False\r\n\r\n    def download_validate_code(self, confirm=False, code_message=None):\r\n        \"\"\"Verifies the VIP download code\"\"\"\r\n        \r\n        self.decoded_vip_link = vip_downloads(self.user_code_var.get())\r\n        \r\n        if confirm:\r\n            if not self.decoded_vip_link == NO_CODE:\r\n                info_text = 'VIP Models Added!'\r\n                is_success_message = True\r\n            else:\r\n                info_text = 'Incorrect Code'\r\n                is_success_message = False\r\n                \r\n            self.download_progress_info_var.set(info_text)\r\n            self.user_code_validation_var.set(info_text)\r\n            \r\n            if code_message:\r\n                code_message(info_text, is_success_message)\r\n                \r\n            self.download_list_fill()\r\n\r\n    def download_list_fill(self, model_type=ALL_TYPES):\r\n        \"\"\"Fills the download lists with the data retrieved from the update check.\"\"\"\r\n        \r\n        self.download_demucs_models_list.clear()\r\n\r\n        model_download_mdx_list, model_download_mdx_name = [], \"mdxdownload\"\r\n        model_download_vr_list, model_download_vr_name = [], \"vrdownload\"\r\n        model_download_demucs_list, model_download_demucs_name = [], \"demucsmdxdownload\"\r\n\r\n        self.vr_download_list = self.online_data[\"vr_download_list\"]\r\n        self.mdx_download_list = self.online_data[\"mdx_download_list\"]\r\n        self.demucs_download_list = self.online_data[\"demucs_download_list\"]\r\n        self.mdx_download_list.update(self.online_data[\"mdx23c_download_list\"])\r\n        \r\n        if not self.decoded_vip_link is NO_CODE:\r\n            self.vr_download_list.update(self.online_data[\"vr_download_vip_list\"])\r\n            self.mdx_download_list.update(self.online_data[\"mdx_download_vip_list\"])\r\n            self.mdx_download_list.update(self.online_data[\"mdx23c_download_vip_list\"])\r\n                     \r\n        def configure_combobox(combobox:ComboBoxMenu, values:list, variable:tk.StringVar, arch_type, name):\r\n            values = [NO_NEW_MODELS] if not values else values\r\n            combobox['values'] = values\r\n            combobox.update_dropdown_size(values, name, offset=310,\r\n                                          command=lambda s: self.download_model_select(variable.get(), arch_type, variable))\r\n                                     \r\n        if model_type in [VR_ARCH_TYPE, ALL_TYPES]:\r\n            for (selectable, model) in self.vr_download_list.items():\r\n                if not os.path.isfile(os.path.join(VR_MODELS_DIR, model)):\r\n                    model_download_vr_list.append(selectable)\r\n                    \r\n            configure_combobox(self.model_download_vr_Option, model_download_vr_list, self.model_download_vr_var, VR_ARCH_TYPE, model_download_vr_name)\r\n\r\n        if model_type in [MDX_ARCH_TYPE, ALL_TYPES]:\r\n            for (selectable, model) in self.mdx_download_list.items():\r\n                if isinstance(model, dict):\r\n                    items_list = list(model.items())\r\n                    model_name, config = items_list[0]\r\n                    config_link = f\"{MDX23_CONFIG_CHECKS}{config}\"\r\n                    config_local = os.path.join(MDX_C_CONFIG_PATH, config)\r\n                    if not os.path.isfile(config_local):\r\n                        with urllib.request.urlopen(config_link) as response:\r\n                            with open(config_local, 'wb') as out_file:\r\n                                out_file.write(response.read())\r\n                else:\r\n                    model_name = str(model)\r\n\r\n                if not os.path.isfile(os.path.join(MDX_MODELS_DIR, model_name)):\r\n                    model_download_mdx_list.append(selectable)\r\n                    \r\n            configure_combobox(self.model_download_mdx_Option, model_download_mdx_list, self.model_download_mdx_var, MDX_ARCH_TYPE, model_download_mdx_name)\r\n\r\n        if model_type in [DEMUCS_ARCH_TYPE, ALL_TYPES]:\r\n            for (selectable, model) in self.demucs_download_list.items():  \r\n                for name in model.items():\r\n                    if [True for x in DEMUCS_NEWER_ARCH_TYPES if x in selectable]:\r\n                        if not os.path.isfile(os.path.join(DEMUCS_NEWER_REPO_DIR, name[0])):\r\n                            self.download_demucs_models_list.append(selectable)\r\n                    else:\r\n                        if not os.path.isfile(os.path.join(DEMUCS_MODELS_DIR, name[0])):\r\n                            self.download_demucs_models_list.append(selectable)\r\n                        \r\n            self.download_demucs_models_list = list(dict.fromkeys(self.download_demucs_models_list)) \r\n        \r\n            for option_name in self.download_demucs_models_list:\r\n                model_download_demucs_list.append(option_name)\r\n            \r\n            configure_combobox(self.model_download_demucs_Option, model_download_demucs_list, self.model_download_demucs_var, DEMUCS_ARCH_TYPE, model_download_demucs_name)\r\n\r\n    def download_model_settings(self):\r\n        '''Update the newest model settings'''\r\n        \r\n        try:\r\n            self.vr_hash_MAPPER = json.load(urllib.request.urlopen(VR_MODEL_DATA_LINK))\r\n            self.mdx_hash_MAPPER = json.load(urllib.request.urlopen(MDX_MODEL_DATA_LINK))\r\n            self.mdx_name_select_MAPPER = json.load(urllib.request.urlopen(MDX_MODEL_NAME_DATA_LINK))\r\n            self.demucs_name_select_MAPPER = json.load(urllib.request.urlopen(DEMUCS_MODEL_NAME_DATA_LINK))\r\n            \r\n            vr_hash_MAPPER_dump = json.dumps(self.vr_hash_MAPPER, indent=4)\r\n            with open(VR_HASH_JSON, \"w\") as outfile:\r\n                outfile.write(vr_hash_MAPPER_dump)\r\n                \r\n            mdx_hash_MAPPER_dump = json.dumps(self.mdx_hash_MAPPER, indent=4)\r\n            with open(MDX_HASH_JSON, \"w\") as outfile:\r\n                outfile.write(mdx_hash_MAPPER_dump)\r\n\r\n            mdx_name_select_MAPPER_dump = json.dumps(self.mdx_name_select_MAPPER, indent=4)\r\n            with open(MDX_MODEL_NAME_SELECT, \"w\") as outfile:\r\n                outfile.write(mdx_name_select_MAPPER_dump)\r\n                \r\n            demucs_name_select_MAPPER_dump = json.dumps(self.demucs_name_select_MAPPER, indent=4)\r\n            with open(DEMUCS_MODEL_NAME_SELECT, \"w\") as outfile:\r\n                outfile.write(demucs_name_select_MAPPER_dump)\r\n\r\n        except Exception as e:\r\n            self.vr_hash_MAPPER = load_model_hash_data(VR_HASH_JSON)\r\n            self.mdx_hash_MAPPER = load_model_hash_data(MDX_HASH_JSON)\r\n            self.mdx_name_select_MAPPER = load_model_hash_data(MDX_MODEL_NAME_SELECT)\r\n            self.demucs_name_select_MAPPER = load_model_hash_data(DEMUCS_MODEL_NAME_SELECT)\r\n            self.error_log_var.set(e)\r\n            print(e)\r\n\r\n    def download_list_state(self, reset=True, disable_only=False):\r\n        \"\"\"Makes sure only the models from the chosen AI network are selectable.\"\"\"\r\n        \r\n        for widget in self.download_lists:\r\n            widget.configure(state=tk.DISABLED)\r\n        \r\n        if reset:\r\n            for download_list_var in self.download_list_vars:\r\n                if self.is_online:\r\n                    download_list_var.set(NO_MODEL)\r\n                    self.download_Button.configure(state=tk.NORMAL)\r\n                else:\r\n                    download_list_var.set(NO_CONNECTION)\r\n                    self.download_Button.configure(state=tk.DISABLED)\r\n                    disable_only = True\r\n            \r\n        if not disable_only:\r\n            self.download_Button.configure(state=tk.NORMAL)\r\n            if self.select_download_var.get() == VR_ARCH_TYPE:\r\n                self.model_download_vr_Option.configure(state=READ_ONLY)\r\n                self.selected_download_var = self.model_download_vr_var\r\n                self.download_list_fill(model_type=VR_ARCH_TYPE)\r\n            if self.select_download_var.get() == MDX_ARCH_TYPE:\r\n                self.model_download_mdx_Option.configure(state=READ_ONLY)\r\n                self.selected_download_var = self.model_download_mdx_var\r\n                self.download_list_fill(model_type=MDX_ARCH_TYPE)\r\n            if self.select_download_var.get() == DEMUCS_ARCH_TYPE:\r\n                self.model_download_demucs_Option.configure(state=READ_ONLY)\r\n                self.selected_download_var = self.model_download_demucs_var\r\n                self.download_list_fill(model_type=DEMUCS_ARCH_TYPE)\r\n                \r\n            self.stop_download_Button_DISABLE()\r\n\r\n    def download_model_select(self, selection, type, var:tk.StringVar):\r\n        \"\"\"Prepares the data needed to download selected model.\"\"\"\r\n        \r\n        self.download_demucs_newer_models.clear()\r\n\r\n        if selection == NO_NEW_MODELS:\r\n            selection = NO_MODEL\r\n            var.set(NO_MODEL)\r\n        \r\n        model_repo = self.decoded_vip_link if VIP_SELECTION in selection else NORMAL_REPO\r\n        is_demucs_newer = [True for x in DEMUCS_NEWER_ARCH_TYPES if x in selection]\r\n\r\n        if type == VR_ARCH_TYPE:\r\n            for selected_model in self.vr_download_list.items():\r\n                if selection in selected_model:\r\n                    self.download_link_path_var.set(\"{}{}\".format(model_repo, selected_model[1]))\r\n                    self.download_save_path_var.set(os.path.join(VR_MODELS_DIR, selected_model[1]))\r\n                    break\r\n                \r\n        if type == MDX_ARCH_TYPE:\r\n            for selected_model in self.mdx_download_list.items():\r\n                if selection in selected_model:\r\n                    if isinstance(selected_model[1], dict):\r\n                        model_name = list(selected_model[1].keys())[0]\r\n                    else:\r\n                        model_name = str(selected_model[1])\r\n                    self.download_link_path_var.set(\"{}{}\".format(model_repo, model_name))\r\n                    self.download_save_path_var.set(os.path.join(MDX_MODELS_DIR, model_name))\r\n                    break\r\n\r\n        if type == DEMUCS_ARCH_TYPE:\r\n            for selected_model, model_data in self.demucs_download_list.items():\r\n                if selection == selected_model:\r\n                    for key, value in model_data.items():\r\n                        if is_demucs_newer:\r\n                            self.download_demucs_newer_models.append([os.path.join(DEMUCS_NEWER_REPO_DIR, key), value])\r\n                        else:\r\n                            self.download_save_path_var.set(os.path.join(DEMUCS_MODELS_DIR, key))\r\n                            self.download_link_path_var.set(value)\r\n\r\n    def download_item(self, is_update_app=False):\r\n        \"\"\"Downloads the model selected.\"\"\"\r\n        \r\n        if not is_update_app:\r\n            if self.selected_download_var.get() == NO_MODEL:\r\n                self.download_progress_info_var.set(NO_MODEL)\r\n                return        \r\n\r\n        for widget in self.download_center_Buttons:\r\n            widget.configure(state=tk.DISABLED)\r\n        self.refresh_list_Button.configure(state=tk.DISABLED)\r\n        self.manual_download_Button.configure(state=tk.DISABLED)\r\n        \r\n        is_demucs_newer = [True for x in DEMUCS_NEWER_ARCH_TYPES if x in self.selected_download_var.get()]\r\n\r\n        self.download_list_state(reset=False, disable_only=True)\r\n        self.stop_download_Button_ENABLE()\r\n        self.disable_tabs()\r\n        \r\n        def download_progress_bar(current, total, model=80):\r\n            progress = ('%s' % (100 * current // total))\r\n            self.download_progress_bar_var.set(int(progress))\r\n            self.download_progress_percent_var.set(progress + ' %')\r\n            \r\n        def push_download():\r\n            self.is_download_thread_active = True\r\n            try:\r\n                if is_update_app:\r\n                    self.download_progress_info_var.set(DOWNLOADING_UPDATE)\r\n                    if os.path.isfile(self.download_update_path_var.get()):\r\n                        self.download_progress_info_var.set(FILE_EXISTS)\r\n                    else:\r\n                        wget.download(self.download_update_link_var.get(), self.download_update_path_var.get(), bar=download_progress_bar)\r\n                        \r\n                    self.download_post_action(DOWNLOAD_UPDATE_COMPLETE)\r\n                else:\r\n                    if self.select_download_var.get() == DEMUCS_ARCH_TYPE and is_demucs_newer:\r\n                        for model_num, model_data in enumerate(self.download_demucs_newer_models, start=1):\r\n                            self.download_progress_info_var.set('{} {}/{}...'.format(DOWNLOADING_ITEM, model_num, len(self.download_demucs_newer_models)))\r\n                            if os.path.isfile(model_data[0]):\r\n                                continue\r\n                            else:\r\n                                wget.download(model_data[1], model_data[0], bar=download_progress_bar)\r\n                    else:\r\n                        self.download_progress_info_var.set(SINGLE_DOWNLOAD)\r\n                        if os.path.isfile(self.download_save_path_var.get()):\r\n                            self.download_progress_info_var.set(FILE_EXISTS)\r\n                        else:\r\n                            wget.download(self.download_link_path_var.get(), self.download_save_path_var.get(), bar=download_progress_bar)\r\n                            \r\n                    self.download_post_action(DOWNLOAD_COMPLETE)\r\n                \r\n            except Exception as e:\r\n                self.error_log_var.set(error_text(DOWNLOADING_ITEM, e))\r\n                self.download_progress_info_var.set(DOWNLOAD_FAILED)\r\n                \r\n                if type(e).__name__ == 'URLError':\r\n                    self.offline_state_set()\r\n                else:\r\n                    self.download_progress_percent_var.set(f\"{type(e).__name__}\")\r\n                    self.download_post_action(DOWNLOAD_FAILED)\r\n                          \r\n        self.active_download_thread = KThread(target=push_download)\r\n        self.active_download_thread.start()\r\n\r\n    def download_post_action(self, action):\r\n        \"\"\"Resets the widget variables in the \"Download Center\" based on the state of the download.\"\"\"\r\n        \r\n        for widget in self.download_center_Buttons:\r\n            widget.configure(state=tk.NORMAL)\r\n        self.refresh_list_Button.configure(state=tk.NORMAL)\r\n        self.manual_download_Button.configure(state=tk.NORMAL)\r\n        \r\n        self.enable_tabs()\r\n        self.stop_download_Button_DISABLE()\r\n        \r\n        if action == DOWNLOAD_FAILED:\r\n            try:\r\n                self.active_download_thread.terminate()\r\n            finally:\r\n                self.download_progress_info_var.set(DOWNLOAD_FAILED)\r\n                self.download_list_state(reset=False)\r\n        if action == DOWNLOAD_STOPPED:\r\n            try:\r\n                self.active_download_thread.terminate()\r\n            finally:\r\n                self.download_progress_info_var.set(DOWNLOAD_STOPPED)\r\n                self.download_list_state(reset=False)\r\n        if action == DOWNLOAD_COMPLETE:\r\n            self.online_data_refresh(is_download_complete=True)\r\n            self.download_progress_info_var.set(DOWNLOAD_COMPLETE)\r\n            self.download_list_state()\r\n        if action == DOWNLOAD_UPDATE_COMPLETE:\r\n            self.download_progress_info_var.set(DOWNLOAD_UPDATE_COMPLETE)\r\n            if os.path.isfile(self.download_update_path_var.get()):\r\n                subprocess.Popen(self.download_update_path_var.get())\r\n            self.download_list_state()\r\n        \r\n        \r\n        self.is_download_thread_active = False\r\n        \r\n        self.delete_temps()\r\n   \r\n    #--Refresh/Loop Methods--    \r\n\r\n    def update_loop(self):\r\n        \"\"\"Update the model dropdown menus\"\"\"\r\n\r\n        if self.clear_cache_torch:\r\n            clear_gpu_cache()\r\n            self.clear_cache_torch = False\r\n\r\n        if self.is_process_stopped:\r\n            if self.thread_check(self.active_processing_thread):\r\n                self.conversion_Button_Text_var.set(STOP_PROCESSING)\r\n                self.conversion_Button.configure(state=tk.DISABLED)\r\n                self.stop_Button.configure(state=tk.DISABLED)\r\n            else:\r\n                self.stop_Button.configure(state=tk.NORMAL)\r\n                self.conversion_Button_Text_var.set(START_PROCESSING)\r\n                self.conversion_Button.configure(state=tk.NORMAL)\r\n                self.progress_bar_main_var.set(0)\r\n                clear_gpu_cache()\r\n                self.is_process_stopped = False\r\n            \r\n        if self.is_confirm_error_var.get():\r\n            self.check_is_menu_open(ERROR_OPTION)\r\n            self.is_confirm_error_var.set(False)\r\n\r\n        if self.is_check_splash and is_windows:\r\n            \r\n            while not self.msg_queue.empty():\r\n                message = self.msg_queue.get_nowait()\r\n                print(message)\r\n            \r\n            close_process(self.msg_queue)\r\n            self.is_check_splash = False\r\n\r\n        #self.auto_save()\r\n\r\n        self.update_available_models()\r\n        self.after(600, self.update_loop)\r\n          \r\n    def update_menus(self, option_widget:ComboBoxMenu, style_name, command, new_items, last_items=None, base_options=None):\r\n                \r\n        if new_items != last_items:\r\n            formatted_items = [item.replace(\"_\", \" \") for item in new_items]\r\n            if not formatted_items and base_options:\r\n                base_options = [option for option in base_options if option != OPT_SEPARATOR_SAVE]\r\n            \r\n            final_options = formatted_items + base_options if base_options else formatted_items\r\n            option_widget['values'] = final_options\r\n            option_widget.update_dropdown_size(formatted_items, style_name, command=command)\r\n            return new_items\r\n        return last_items\r\n          \r\n    def update_available_models(self):\r\n        \"\"\"\r\n        Loops through all models in each model directory and adds them to the appropriate model menu.\r\n        Also updates ensemble listbox and user saved settings list.\r\n        \"\"\"\r\n        \r\n        def fix_name(name, mapper:dict): return next((new_name for old_name, new_name in mapper.items() if name in old_name), name)\r\n        \r\n        new_vr_models = self.get_files_from_dir(VR_MODELS_DIR, PTH)\r\n        new_mdx_models = self.get_files_from_dir(MDX_MODELS_DIR, (ONNX, CKPT), is_mdxnet=True)\r\n        new_demucs_models = self.get_files_from_dir(DEMUCS_MODELS_DIR, (CKPT, '.gz', '.th')) + self.get_files_from_dir(DEMUCS_NEWER_REPO_DIR, YAML)\r\n        new_ensembles_found = self.get_files_from_dir(ENSEMBLE_CACHE_DIR, JSON)\r\n        new_settings_found = self.get_files_from_dir(SETTINGS_CACHE_DIR, JSON)\r\n        new_models_found = new_vr_models + new_mdx_models + new_demucs_models\r\n        is_online = self.is_online_model_menu\r\n        \r\n        def loop_directories(option_menu:ComboBoxMenu, option_var, model_list, model_type, name_mapper=None):\r\n            current_selection = option_menu.get()\r\n            option_list = [fix_name(file_name, name_mapper) for file_name in model_list] if name_mapper else model_list\r\n            sorted_options = natsort.natsorted(option_list)\r\n            option_list_option_menu = sorted_options + [OPT_SEPARATOR, DOWNLOAD_MORE] if self.is_online else sorted_options\r\n            \r\n            if not option_list and self.is_online:\r\n                option_list_option_menu = [option for option in option_list_option_menu if option != OPT_SEPARATOR]\r\n            \r\n            option_menu['values'] = option_list_option_menu\r\n            option_menu.set(current_selection)\r\n            option_menu.update_dropdown_size(option_list, model_type)\r\n            \r\n            if self.is_root_defined_var.get() and model_type == MDX_ARCH_TYPE and self.chosen_process_method_var.get() == MDX_ARCH_TYPE:\r\n                self.selection_action_models_sub(current_selection, model_type, option_var)\r\n                \r\n            return tuple(f\"{model_type}{ENSEMBLE_PARTITION}{model_name}\" for model_name in sorted_options)\r\n\r\n        if new_models_found != self.last_found_models or is_online != self.is_online:\r\n            self.model_data_table = []\r\n            \r\n            vr_model_list = loop_directories(self.vr_model_Option, self.vr_model_var, new_vr_models, VR_ARCH_TYPE, name_mapper=None)\r\n            mdx_model_list = loop_directories(self.mdx_net_model_Option, self.mdx_net_model_var, new_mdx_models, MDX_ARCH_TYPE, name_mapper=self.mdx_name_select_MAPPER)\r\n            demucs_model_list = loop_directories(self.demucs_model_Option, self.demucs_model_var, new_demucs_models, DEMUCS_ARCH_TYPE, name_mapper=self.demucs_name_select_MAPPER)\r\n            \r\n            self.ensemble_model_list = vr_model_list + mdx_model_list + demucs_model_list\r\n            self.default_change_model_list = vr_model_list + mdx_model_list\r\n            self.last_found_models = new_models_found\r\n            self.is_online_model_menu = self.is_online\r\n            \r\n            if not self.chosen_ensemble_var.get() == CHOOSE_ENSEMBLE_OPTION:\r\n                self.selection_action_chosen_ensemble(self.chosen_ensemble_var.get())\r\n            else:\r\n                if not self.ensemble_main_stem_var.get() == CHOOSE_STEM_PAIR:\r\n                    self.selection_action_ensemble_stems(self.ensemble_main_stem_var.get(), auto_update=self.ensemble_listbox_get_all_selected_models())\r\n                else:\r\n                    self.ensemble_listbox_clear_and_insert_new(self.ensemble_model_list)\r\n\r\n        self.last_found_ensembles = self.update_menus(option_widget=self.chosen_ensemble_Option, \r\n                                                      style_name='savedensembles',\r\n                                                      command=None, \r\n                                                      new_items=new_ensembles_found, \r\n                                                      last_items=self.last_found_ensembles, \r\n                                                      base_options=ENSEMBLE_OPTIONS\r\n        )\r\n\r\n        self.last_found_settings = self.update_menus(option_widget=self.save_current_settings_Option, \r\n                                                      style_name='savedsettings',\r\n                                                      command=None, \r\n                                                      new_items=new_settings_found, \r\n                                                      last_items=self.last_found_settings, \r\n                                                      base_options=SAVE_SET_OPTIONS\r\n        )\r\n\r\n    def update_main_widget_states_mdx(self):\r\n        if not self.mdx_net_model_var.get() == DOWNLOAD_MORE:\r\n            self.update_main_widget_states()\r\n\r\n    def move_widget_offscreen(self, widget, step=10):\r\n        current_x = widget.winfo_x()\r\n        current_y = widget.winfo_y()\r\n        if current_x > -1000:  # assuming -1000 is your off-screen target\r\n            widget.place(x=current_x - step, y=current_y)\r\n            widget.after(10, lambda: self.move_widget_offscreen(widget, step))\r\n\r\n    def update_main_widget_states(self):\r\n        \"\"\"Updates main widget states based on chosen process method\"\"\"\r\n\r\n        def place_widgets(*widgets):\r\n            for widget in widgets:\r\n                widget()\r\n\r\n        def general_shared_buttons():\r\n            place_widgets(self.is_gpu_conversion_Option_place, \r\n                          self.model_sample_mode_Option_place)\r\n\r\n        def stem_save_options():\r\n            place_widgets(self.is_primary_stem_only_Option_place, \r\n                          self.is_secondary_stem_only_Option_place)\r\n\r\n        def stem_save_demucs_options():\r\n            place_widgets(self.is_primary_stem_only_Demucs_Option_place, \r\n                          self.is_secondary_stem_only_Demucs_Option_place)\r\n\r\n        def no_ensemble_shared():\r\n            place_widgets(self.save_current_settings_Label_place, \r\n                          self.save_current_settings_Option_place)\r\n\r\n        process_method = self.chosen_process_method_var.get()\r\n        audio_tool = self.chosen_audio_tool_var.get()\r\n        \r\n        for widget in self.GUI_LIST:\r\n            widget.place(x=-1000, y=-1000)\r\n\r\n        if process_method == MDX_ARCH_TYPE:\r\n            place_widgets(self.mdx_net_model_Label_place, \r\n                          self.mdx_net_model_Option_place, \r\n                          general_shared_buttons, \r\n                          stem_save_options, \r\n                          no_ensemble_shared)\r\n        elif process_method == VR_ARCH_PM:\r\n            place_widgets(self.vr_model_Label_place, self.vr_model_Option_place, \r\n                          self.aggression_setting_Label_place, \r\n                          self.aggression_setting_Option_place, \r\n                          self.window_size_Label_place, \r\n                          self.window_size_Option_place, \r\n                          general_shared_buttons, \r\n                          stem_save_options, \r\n                          no_ensemble_shared)\r\n        elif process_method == DEMUCS_ARCH_TYPE:\r\n            place_widgets(self.demucs_model_Label_place, \r\n                          self.demucs_model_Option_place, \r\n                          self.demucs_stems_Label_place, \r\n                          self.demucs_stems_Option_place, \r\n                          self.segment_Label_place, \r\n                          self.segment_Option_place, \r\n                          general_shared_buttons, \r\n                          stem_save_demucs_options, \r\n                          no_ensemble_shared)\r\n        elif process_method == AUDIO_TOOLS:\r\n            place_widgets(self.chosen_audio_tool_Label_place, \r\n                          self.chosen_audio_tool_Option_place)\r\n\r\n            if audio_tool == ALIGN_INPUTS:\r\n                self.file_one_sub_var.set(FILE_ONE_MAIN_LABEL)\r\n                self.file_two_sub_var.set(FILE_TWO_MAIN_LABEL)\r\n            elif audio_tool == MATCH_INPUTS:\r\n                self.file_one_sub_var.set(FILE_ONE_MATCH_MAIN_LABEL)\r\n                self.file_two_sub_var.set(FILE_TWO_MATCH_MAIN_LABEL)\r\n\r\n            audio_tool_options = {\r\n                MANUAL_ENSEMBLE: [self.choose_algorithm_Label_place, \r\n                                  self.choose_algorithm_Option_place,\r\n                                  self.is_wav_ensemble_Option_place],\r\n                TIME_STRETCH: [lambda: self.model_sample_mode_Option_place(rely=5), \r\n                               self.time_stretch_rate_Label_place, \r\n                               self.time_stretch_rate_Option_place],\r\n                CHANGE_PITCH: [self.is_time_correction_Option_place, \r\n                               lambda: self.model_sample_mode_Option_place(rely=6), \r\n                               self.pitch_rate_Label_place, \r\n                               self.pitch_rate_Option_place],\r\n                ALIGN_INPUTS: [self.fileOne_Label_place, \r\n                               self.fileOne_Entry_place, \r\n                               self.fileTwo_Label_place, \r\n                               self.fileTwo_Entry_place,\r\n                               self.fileOne_Open_place,\r\n                               self.fileTwo_Open_place,\r\n                               self.intro_analysis_Label_place, \r\n                               self.intro_analysis_Option_place, \r\n                               self.db_analysis_Label_place, \r\n                               self.db_analysis_Option_place, \r\n                               self.time_window_Label_place, \r\n                               self.time_window_Option_place],\r\n                MATCH_INPUTS: [self.fileOne_Label_place, \r\n                               self.fileOne_Entry_place, \r\n                               self.fileTwo_Label_place, \r\n                               self.fileTwo_Entry_place,\r\n                               self.fileOne_Open_place,\r\n                               self.fileTwo_Open_place,\r\n                               self.wav_type_set_Label_place,\r\n                               self.wav_type_set_Option_place],\r\n            }\r\n            place_widgets(*audio_tool_options.get(audio_tool, []))\r\n        elif process_method == ENSEMBLE_MODE:\r\n            place_widgets(self.chosen_ensemble_Label_place, \r\n                          self.chosen_ensemble_Option_place, \r\n                          self.ensemble_main_stem_Label_place, \r\n                          self.ensemble_main_stem_Option_place, \r\n                          self.ensemble_type_Label_place, \r\n                          self.ensemble_type_Option_place, \r\n                          self.ensemble_listbox_Label_place, \r\n                          self.ensemble_listbox_Option_place, \r\n                          self.ensemble_listbox_Option_pack, \r\n                          general_shared_buttons, \r\n                          stem_save_options)\r\n\r\n        if not self.is_gpu_available:\r\n            self.is_gpu_conversion_Disable()\r\n\r\n        self.update_inputPaths()\r\n\r\n    def update_button_states(self):\r\n        \"\"\"Updates the available stems for selected Demucs model\"\"\"\r\n        \r\n        if self.chosen_process_method_var.get() == DEMUCS_ARCH_TYPE:\r\n            if self.demucs_stems_var.get() == ALL_STEMS:\r\n                self.update_stem_checkbox_labels(PRIMARY_STEM, demucs=True)\r\n            elif self.demucs_stems_var.get() == VOCAL_STEM:\r\n                self.update_stem_checkbox_labels(VOCAL_STEM, demucs=True, is_disable_demucs_boxes=False)\r\n                self.is_stem_only_Demucs_Options_Enable()\r\n            else:\r\n                self.is_stem_only_Demucs_Options_Enable()\r\n\r\n            #self.demucs_stems_Option['menu'].delete(0,'end')\r\n            \r\n            if not self.demucs_model_var.get() == CHOOSE_MODEL:\r\n                if DEMUCS_UVR_MODEL in self.demucs_model_var.get():\r\n                    stems = DEMUCS_2_STEM_OPTIONS\r\n                elif DEMUCS_6_STEM_MODEL in self.demucs_model_var.get():\r\n                    stems = DEMUCS_6_STEM_OPTIONS\r\n                else:\r\n                    stems = DEMUCS_4_STEM_OPTIONS\r\n\r\n                self.demucs_stems_Option['values'] = stems\r\n                self.demucs_stems_Option.command(lambda e:self.update_stem_checkbox_labels(self.demucs_stems_var.get(), demucs=True))\r\n\r\n    def update_button_states_mdx(self, model_stems):\r\n        \"\"\"Updates the available stems for selected Demucs model\"\"\"\r\n        \r\n        model_stems = [stem for stem in model_stems]\r\n        \r\n        if len(model_stems) >= 3:\r\n            model_stems.insert(0, ALL_STEMS)\r\n            self.mdxnet_stems_var.set(ALL_STEMS)\r\n        else:\r\n            self.mdxnet_stems_var.set(model_stems[0])\r\n        \r\n        if self.mdxnet_stems_var.get() == ALL_STEMS:\r\n            self.update_stem_checkbox_labels(PRIMARY_STEM, disable_boxes=True)\r\n        elif self.mdxnet_stems_var.get() == VOCAL_STEM:\r\n            self.update_stem_checkbox_labels(VOCAL_STEM)\r\n            self.is_stem_only_Options_Enable()\r\n        else:\r\n            self.is_stem_only_Options_Enable()\r\n\r\n        if not self.mdx_net_model_var.get() == CHOOSE_MODEL:\r\n            self.mdxnet_stems_Option['values'] = model_stems\r\n            self.mdxnet_stems_Option.command(lambda e:self.update_stem_checkbox_labels(self.mdxnet_stems_var.get()))\r\n                            \r\n    def update_stem_checkbox_labels(self, selection, demucs=False, disable_boxes=False, is_disable_demucs_boxes=True):\r\n        \"\"\"Updates the \"save only\" checkboxes based on the model selected\"\"\"\r\n        \r\n        stem_text = self.is_primary_stem_only_Text_var, self.is_secondary_stem_only_Text_var\r\n\r\n        if selection == ALL_STEMS:\r\n            selection = PRIMARY_STEM\r\n        else:\r\n            self.is_stem_only_Options_Enable()\r\n\r\n        if disable_boxes or selection == PRIMARY_STEM:\r\n            self.is_primary_stem_only_Option.configure(state=tk.DISABLED)\r\n            self.is_secondary_stem_only_Option.configure(state=tk.DISABLED)\r\n            self.is_primary_stem_only_var.set(False)\r\n            self.is_secondary_stem_only_var.set(False)\r\n        else:\r\n            self.is_primary_stem_only_Option.configure(state=tk.NORMAL)\r\n            self.is_secondary_stem_only_Option.configure(state=tk.NORMAL)\r\n        \r\n        if demucs:\r\n            stem_text = self.is_primary_stem_only_Demucs_Text_var, self.is_secondary_stem_only_Demucs_Text_var\r\n\r\n            if is_disable_demucs_boxes:\r\n                self.is_primary_stem_only_Demucs_Option.configure(state=tk.DISABLED)\r\n                self.is_secondary_stem_only_Demucs_Option.configure(state=tk.DISABLED)\r\n                self.is_primary_stem_only_Demucs_var.set(False)\r\n                self.is_secondary_stem_only_Demucs_var.set(False)\r\n                \r\n            if not selection == PRIMARY_STEM:\r\n                self.is_primary_stem_only_Demucs_Option.configure(state=tk.NORMAL)\r\n                self.is_secondary_stem_only_Demucs_Option.configure(state=tk.NORMAL)\r\n                \r\n        stem_text[0].set(f\"{selection} Only\")\r\n        stem_text[1].set(f\"{secondary_stem(selection)} Only\")\r\n     \r\n    def update_ensemble_algorithm_menu(self, is_4_stem=False):\r\n        options = ENSEMBLE_TYPE_4_STEM if is_4_stem else ENSEMBLE_TYPE\r\n\r\n        if not \"/\" in self.ensemble_type_var.get() or is_4_stem: \r\n            self.ensemble_type_var.set(options[0])\r\n\r\n        self.ensemble_type_Option[\"values\"] = options\r\n\r\n    def selection_action(self, event, option_var, is_mdx_net=False):\r\n        selected_value = event.widget.get()\r\n        selected_value = CHOOSE_MODEL if selected_value == OPT_SEPARATOR else selected_value\r\n        option_var.set(selected_value)\r\n        if is_mdx_net:\r\n            self.update_main_widget_states_mdx()\r\n        self.selection_action_models(selected_value)\r\n\r\n    def selection_action_models(self, selection):\r\n        \"\"\"Accepts model names and verifies their state.\"\"\"\r\n\r\n        # Handle different selections.\r\n        if selection in CHOOSE_MODEL:\r\n            self.update_stem_checkbox_labels(PRIMARY_STEM, disable_boxes=True)\r\n        else:\r\n            self.is_stem_only_Options_Enable()\r\n\r\n        # Process method matching current selection.\r\n        self._handle_model_by_chosen_method(selection)\r\n\r\n        # Handle Ensemble mode case.\r\n        if self.chosen_process_method_var.get() == ENSEMBLE_MODE:\r\n            return self._handle_ensemble_mode_selection(selection)\r\n\r\n        if not self.is_menu_settings_open and selection == DOWNLOAD_MORE:\r\n            self.update_checkbox_text()\r\n            self.menu_settings(select_tab_3=True)\r\n\r\n    def _handle_model_by_chosen_method(self, selection):\r\n        \"\"\"Handles model selection based on the currently chosen method.\"\"\"\r\n        current_method = self.chosen_process_method_var.get()\r\n        model_var = self.method_mapper.get(current_method)\r\n        if model_var:\r\n            self.selection_action_models_sub(selection, current_method, model_var)\r\n\r\n    def _handle_ensemble_mode_selection(self, selection):\r\n        \"\"\"Handles the case where the current method is 'ENSEMBLE_MODE'.\"\"\"\r\n        model_data = self.assemble_model_data(selection, ENSEMBLE_CHECK)[0]\r\n        if not model_data.model_status:\r\n            return self.model_stems_list.index(selection)\r\n        return False\r\n\r\n    def selection_action_models_sub(self, selection, ai_type, var: tk.StringVar):\r\n        \"\"\"Takes input directly from the selection_action_models parent function\"\"\"\r\n\r\n        if selection == DOWNLOAD_MORE:\r\n            is_model_status = False\r\n        else:\r\n            model_data = self.assemble_model_data(selection, ai_type)[0]\r\n            is_model_status = model_data.model_status\r\n\r\n        if not is_model_status:\r\n            var.set(CHOOSE_MODEL)\r\n            if ai_type == MDX_ARCH_TYPE:\r\n                self.mdx_segment_size_Label_place()\r\n                self.mdx_segment_size_Option_place()\r\n                self.overlap_mdx_Label_place()\r\n                self.overlap_mdx_Option_place()\r\n                self.update_stem_checkbox_labels(PRIMARY_STEM, disable_boxes=True)\r\n        else:\r\n            if ai_type == DEMUCS_ARCH_TYPE:\r\n                if not self.demucs_stems_var.get().lower() in model_data.demucs_source_list:\r\n                    self.demucs_stems_var.set(ALL_STEMS if model_data.demucs_stem_count == 4 else VOCAL_STEM)\r\n                    \r\n                self.update_button_states()\r\n            else:\r\n                if model_data.is_mdx_c and len(model_data.mdx_model_stems) >= 1:\r\n                    if len(model_data.mdx_model_stems) >= 3:\r\n                        self.mdxnet_stems_Label_place()\r\n                        self.mdxnet_stems_Option_place()\r\n                    else:\r\n                        self.mdx_segment_size_Label_place()\r\n                        self.mdx_segment_size_Option_place()\r\n                    self.overlap_mdx_Label_place()\r\n                    self.overlap_mdx23_Option_place()\r\n                    self.update_button_states_mdx(model_data.mdx_model_stems)\r\n                else:\r\n                    if ai_type == MDX_ARCH_TYPE:\r\n                        self.mdx_segment_size_Label_place()\r\n                        self.mdx_segment_size_Option_place()\r\n                        self.overlap_mdx_Label_place()\r\n                        self.overlap_mdx_Option_place()\r\n\r\n                    stem = model_data.primary_stem\r\n                    self.update_stem_checkbox_labels(stem)\r\n\r\n    def selection_action_process_method(self, selection, from_widget=False, is_from_conv_menu=False):\r\n        \"\"\"Checks model and variable status when toggling between process methods\"\"\"\r\n        \r\n        if is_from_conv_menu:\r\n            self.update_main_widget_states()\r\n\r\n        if from_widget:\r\n            self.save_current_settings_var.set(CHOOSE_ENSEMBLE_OPTION)\r\n\r\n        if selection == ENSEMBLE_MODE:\r\n            ensemble_choice = self.ensemble_main_stem_var.get()\r\n            if ensemble_choice in [CHOOSE_STEM_PAIR, FOUR_STEM_ENSEMBLE, MULTI_STEM_ENSEMBLE]:\r\n                self.update_stem_checkbox_labels(PRIMARY_STEM, disable_boxes=True)\r\n            else:\r\n                self.update_stem_checkbox_labels(self.return_ensemble_stems(is_primary=True))\r\n                self.is_stem_only_Options_Enable()\r\n            return\r\n\r\n        for method_type, model_var in self.method_mapper.items():\r\n            if method_type in selection:\r\n                self.selection_action_models(model_var.get())\r\n                break\r\n\r\n    def selection_action_chosen_ensemble(self, selection):\r\n        \"\"\"Activates specific actions depending on selected ensemble option\"\"\"\r\n        \r\n        if selection not in ENSEMBLE_OPTIONS:\r\n            self.selection_action_chosen_ensemble_load_saved(selection)\r\n        elif selection == SAVE_ENSEMBLE: \r\n            self.chosen_ensemble_var.set(CHOOSE_ENSEMBLE_OPTION)\r\n            self.pop_up_save_ensemble()\r\n        elif selection == OPT_SEPARATOR_SAVE:\r\n            self.chosen_ensemble_var.set(CHOOSE_ENSEMBLE_OPTION)\r\n        elif selection == CLEAR_ENSEMBLE:\r\n            self.ensemble_listbox_Option.selection_clear(0, 'end') \r\n            self.chosen_ensemble_var.set(CHOOSE_ENSEMBLE_OPTION)\r\n           \r\n    def selection_action_chosen_ensemble_load_saved(self, saved_ensemble):\r\n        \"\"\"Loads the data from selected saved ensemble\"\"\"\r\n        \r\n        saved_data = None\r\n        saved_ensemble = saved_ensemble.replace(\" \", \"_\")\r\n        saved_ensemble_path = os.path.join(ENSEMBLE_CACHE_DIR, f'{saved_ensemble}.json')\r\n\r\n        if os.path.isfile(saved_ensemble_path):\r\n            saved_data = json.load(open(saved_ensemble_path))\r\n            \r\n        if saved_data:\r\n            self.selection_action_ensemble_stems(saved_data['ensemble_main_stem'], from_menu=False)\r\n            self.ensemble_main_stem_var.set(saved_data['ensemble_main_stem'])\r\n            self.ensemble_type_var.set(saved_data['ensemble_type'])\r\n            self.saved_model_list = saved_data['selected_models']\r\n        \r\n            for saved_model in self.saved_model_list:         \r\n                status = self.assemble_model_data(saved_model, ENSEMBLE_CHECK)[0].model_status\r\n                if not status:\r\n                    self.saved_model_list.remove(saved_model)\r\n            \r\n            indexes = self.ensemble_listbox_get_indexes_for_files(self.model_stems_list, self.saved_model_list)\r\n            \r\n            for i in indexes:\r\n                self.ensemble_listbox_Option.selection_set(i)\r\n                \r\n        self.update_checkbox_text()\r\n            \r\n    def selection_action_ensemble_stems(self, selection: str, from_menu=True, auto_update=None):\r\n        \"\"\"Filters out all models from ensemble listbox that are incompatible with selected ensemble stem\"\"\"\r\n        \r\n        is_multi_stem = False\r\n        \r\n        if not selection == CHOOSE_STEM_PAIR:\r\n            if selection in [FOUR_STEM_ENSEMBLE, MULTI_STEM_ENSEMBLE]:\r\n                self.update_stem_checkbox_labels(PRIMARY_STEM, disable_boxes=True)\r\n                self.update_ensemble_algorithm_menu(is_4_stem=True)\r\n                self.ensemble_primary_stem = PRIMARY_STEM\r\n                self.ensemble_secondary_stem = SECONDARY_STEM\r\n                is_4_stem_check = True\r\n                if selection == MULTI_STEM_ENSEMBLE:\r\n                    is_multi_stem = True\r\n            else:\r\n                self.update_ensemble_algorithm_menu()\r\n                self.is_stem_only_Options_Enable()\r\n                stems = selection.partition(\"/\")\r\n                self.update_stem_checkbox_labels(stems[0])\r\n                self.ensemble_primary_stem = stems[0]\r\n                self.ensemble_secondary_stem = stems[2]\r\n                is_4_stem_check = False\r\n            \r\n            self.model_stems_list = self.model_list(self.ensemble_primary_stem, self.ensemble_secondary_stem, is_4_stem_check=is_4_stem_check, is_multi_stem=is_multi_stem)\r\n            self.ensemble_listbox_Option.configure(state=tk.NORMAL)\r\n            self.ensemble_listbox_clear_and_insert_new(self.model_stems_list)\r\n\r\n            if auto_update:\r\n                indexes = self.ensemble_listbox_get_indexes_for_files(self.model_stems_list, auto_update)\r\n                self.ensemble_listbox_select_from_indexs(indexes)\r\n        else:\r\n            self.ensemble_listbox_Option.configure(state=tk.DISABLED)\r\n            self.update_stem_checkbox_labels(PRIMARY_STEM, disable_boxes=True)\r\n            self.model_stems_list = ()\r\n                \r\n        if from_menu:\r\n            self.chosen_ensemble_var.set(CHOOSE_ENSEMBLE_OPTION)\r\n\r\n    def selection_action_saved_settings(self, selection, process_method=None):\r\n        \"\"\"Activates specific action based on the selected settings from the saved settings selections\"\"\"\r\n\r\n        if self.thread_check(self.active_processing_thread):\r\n            self.error_dialoge(SET_TO_ANY_PROCESS_ERROR)\r\n            return\r\n\r\n        chosen_process_method = self.chosen_process_method_var.get() \r\n        if process_method:\r\n            chosen_process_method = process_method\r\n\r\n        if selection in SAVE_SET_OPTIONS:\r\n            self.handle_special_options(selection, chosen_process_method)\r\n        else:\r\n            self.handle_saved_settings(selection, chosen_process_method)\r\n\r\n        self.update_checkbox_text()\r\n\r\n    def handle_special_options(self, selection, process_method):\r\n        \"\"\"Handles actions for special options.\"\"\"\r\n\r\n        if selection == SAVE_SETTINGS: \r\n            self.save_current_settings_var.set(SELECT_SAVED_SET)\r\n            self.pop_up_save_current_settings()\r\n\r\n        elif selection == RESET_TO_DEFAULT:\r\n            self.save_current_settings_var.set(SELECT_SAVED_SET)\r\n            self.load_saved_settings(DEFAULT_DATA, process_method)\r\n\r\n        elif selection == OPT_SEPARATOR_SAVE:\r\n            self.save_current_settings_var.set(SELECT_SAVED_SET)\r\n\r\n    def handle_saved_settings(self, selection, process_method):\r\n        \"\"\"Handles actions for saved settings.\"\"\"\r\n\r\n        selection = selection.replace(\" \", \"_\")\r\n        saved_ensemble_path = os.path.join(SETTINGS_CACHE_DIR, f'{selection}.json')\r\n\r\n        if os.path.isfile(saved_ensemble_path):\r\n            with open(saved_ensemble_path, 'r') as file:\r\n                saved_data = json.load(file)\r\n            \r\n            if saved_data:\r\n                self.load_saved_settings(saved_data, process_method)\r\n\r\n    #--Processing Methods-- \r\n\r\n    def process_input_selections(self):\r\n        \"\"\"Grabbing all audio files from selected directories.\"\"\"\r\n        \r\n        input_list = []\r\n\r\n        ext = FFMPEG_EXT if not self.is_accept_any_input_var.get() else ANY_EXT\r\n\r\n        for i in self.inputPaths:\r\n            if os.path.isfile(i):\r\n                if i.endswith(ext):\r\n                    input_list.append(i)\r\n            for root, dirs, files in os.walk(i):\r\n                for file in files:\r\n                    if file.endswith(ext):\r\n                        file = os.path.join(root, file)\r\n                        if os.path.isfile(file):\r\n                            input_list.append(file)\r\n                                         \r\n        self.inputPaths = tuple(input_list)\r\n\r\n    def process_check_wav_type(self):\r\n        if self.wav_type_set_var.get() == '32-bit Float':\r\n            self.wav_type_set = 'FLOAT'\r\n        elif self.wav_type_set_var.get() == '64-bit Float':#\r\n            self.wav_type_set = 'FLOAT' if not self.save_format_var.get() == WAV else 'DOUBLE'\r\n        else:\r\n            self.wav_type_set = self.wav_type_set_var.get()\r\n            \r\n    def process_preliminary_checks(self):\r\n        \"\"\"Verifies a valid model is chosen\"\"\"\r\n        \r\n        self.process_check_wav_type()\r\n        \r\n        if self.chosen_process_method_var.get() == ENSEMBLE_MODE:\r\n            continue_process = lambda:False if len(self.ensemble_listbox_get_all_selected_models()) <= 1 else True\r\n        if self.chosen_process_method_var.get() == VR_ARCH_PM:\r\n            continue_process = lambda:False if self.vr_model_var.get() == CHOOSE_MODEL else True\r\n        if self.chosen_process_method_var.get() == MDX_ARCH_TYPE:\r\n            continue_process = lambda:False if self.mdx_net_model_var.get() == CHOOSE_MODEL else True\r\n        if self.chosen_process_method_var.get() == DEMUCS_ARCH_TYPE:\r\n            continue_process = lambda:False if self.demucs_model_var.get() == CHOOSE_MODEL else True\r\n\r\n        return continue_process()\r\n\r\n    def process_storage_check(self):\r\n        \"\"\"Verifies storage requirments\"\"\"\r\n        \r\n        total, used, free = shutil.disk_usage(\"/\") \r\n        \r\n        space_details = f'Detected Total Space: {int(total/1.074e+9)} GB\\'s\\n' +\\\r\n                        f'Detected Used Space: {int(used/1.074e+9)} GB\\'s\\n' +\\\r\n                        f'Detected Free Space: {int(free/1.074e+9)} GB\\'s\\n'\r\n            \r\n        appropriate_storage = True\r\n            \r\n        if int(free/1.074e+9) <= int(2):\r\n            self.error_dialoge([STORAGE_ERROR[0], f'{STORAGE_ERROR[1]}{space_details}'])\r\n            appropriate_storage = False\r\n        \r\n        if int(free/1.074e+9) in [3, 4, 5, 6, 7, 8]:\r\n            appropriate_storage = self.message_box([STORAGE_WARNING[0], f'{STORAGE_WARNING[1]}{space_details}{CONFIRM_WARNING}'])\r\n                        \r\n        return appropriate_storage\r\n\r\n    def process_initialize(self):\r\n        \"\"\"Verifies the input/output directories are valid and prepares to thread the main process.\"\"\"\r\n        \r\n        if not (\r\n            self.chosen_process_method_var.get() == AUDIO_TOOLS \r\n            and self.chosen_audio_tool_var.get() in [ALIGN_INPUTS, MATCH_INPUTS] \r\n            and self.fileOneEntry_var.get() \r\n            and self.fileTwoEntry_var.get()\r\n        ) and not (\r\n            self.inputPaths and os.path.isfile(self.inputPaths[0])\r\n        ):\r\n            self.error_dialoge(INVALID_INPUT)\r\n            return\r\n\r\n            \r\n        if not os.path.isdir(self.export_path_var.get()):\r\n            self.error_dialoge(INVALID_EXPORT)\r\n            return\r\n\r\n        if not self.process_storage_check():\r\n            return\r\n\r\n        if self.chosen_process_method_var.get() != AUDIO_TOOLS:\r\n            if not self.process_preliminary_checks():\r\n                error_msg = INVALID_ENSEMBLE if self.chosen_process_method_var.get() == ENSEMBLE_MODE else INVALID_MODEL\r\n                self.error_dialoge(error_msg)\r\n                return\r\n            target_function = self.process_start\r\n        else:\r\n            target_function = self.process_tool_start\r\n        \r\n        self.active_processing_thread = KThread(target=target_function)\r\n        self.active_processing_thread.start()\r\n\r\n    def process_button_init(self):\r\n        self.auto_save()\r\n        self.conversion_Button_Text_var.set(WAIT_PROCESSING)\r\n        self.conversion_Button.configure(state=tk.DISABLED)\r\n        self.command_Text.clear()\r\n\r\n    def process_get_baseText(self, total_files, file_num, is_dual=False):\r\n        \"\"\"Create the base text for the command widget\"\"\"\r\n        \r\n        init_text = 'Files' if is_dual else 'File'\r\n        \r\n        text = '{init_text} {file_num}/{total_files} '.format(init_text=init_text,\r\n                                                              file_num=file_num,\r\n                                                              total_files=total_files)\r\n        \r\n        return text\r\n\r\n    def process_update_progress(self, total_files, step: float = 1):\r\n        \"\"\"Calculate the progress for the progress widget in the GUI\"\"\"\r\n        \r\n        total_count = self.true_model_count * total_files\r\n        base = (100 / total_count)\r\n        progress = base * self.iteration - base\r\n        progress += base * step\r\n\r\n        self.progress_bar_main_var.set(progress)\r\n        \r\n        self.conversion_Button_Text_var.set(f'Process Progress: {int(progress)}%')\r\n\r\n    def confirm_stop_process(self):\r\n        \"\"\"Asks for confirmation before halting active process\"\"\"\r\n        \r\n        self.auto_save()\r\n\r\n        if self.thread_check(self.active_processing_thread):\r\n            confirm = messagebox.askyesno(parent=root, title=STOP_PROCESS_CONFIRM[0], message=STOP_PROCESS_CONFIRM[1])\r\n\r\n            if confirm:\r\n                try:\r\n                    self.active_processing_thread.terminate()\r\n                finally:\r\n                    self.is_process_stopped = True\r\n                    self.command_Text.write(PROCESS_STOPPED_BY_USER)\r\n        else:\r\n            self.clear_cache_torch = True\r\n\r\n    def process_end(self, error=None):\r\n        \"\"\"End of process actions\"\"\"\r\n        \r\n        self.auto_save()\r\n        self.cached_sources_clear()\r\n        self.clear_cache_torch = True\r\n        self.conversion_Button_Text_var.set(START_PROCESSING)\r\n        self.conversion_Button.configure(state=tk.NORMAL)\r\n        self.progress_bar_main_var.set(0)\r\n\r\n        if error:\r\n            error_message_box_text = f'{error_dialouge(error)}{ERROR_OCCURED[1]}'\r\n            confirm = messagebox.askyesno(parent=root,\r\n                                             title=ERROR_OCCURED[0],\r\n                                             message=error_message_box_text)\r\n            \r\n            if confirm:\r\n                self.is_confirm_error_var.set(True)\r\n                self.clear_cache_torch = True\r\n\r\n            self.clear_cache_torch = True\r\n            \r\n            if MODEL_MISSING_CHECK in error_message_box_text: \r\n                self.update_checkbox_text()\r\n \r\n    def process_tool_start(self):\r\n        \"\"\"Start the conversion for all the given mp3 and wav files\"\"\"\r\n\r\n        def time_elapsed():\r\n            return f'Time Elapsed: {time.strftime(\"%H:%M:%S\", time.gmtime(int(time.perf_counter() - stime)))}'\r\n\r\n        def get_audio_file_base(audio_file):\r\n            if audio_tool.audio_tool == MANUAL_ENSEMBLE:\r\n                return f'{os.path.splitext(os.path.basename(inputPaths[0]))[0]}'\r\n            elif audio_tool.audio_tool in [ALIGN_INPUTS, MATCH_INPUTS]:\r\n                return f'{os.path.splitext(os.path.basename(audio_file[0]))[0]}'\r\n            else:\r\n                return f'{os.path.splitext(os.path.basename(audio_file))[0]}'\r\n\r\n        def handle_ensemble(inputPaths, audio_file_base):\r\n            self.progress_bar_main_var.set(50)\r\n            if self.choose_algorithm_var.get() == COMBINE_INPUTS:\r\n                audio_tool.combine_audio(inputPaths, audio_file_base)\r\n            else:\r\n                audio_tool.ensemble_manual(inputPaths, audio_file_base)\r\n            self.progress_bar_main_var.set(100)\r\n            self.command_Text.write(DONE)\r\n\r\n        def handle_alignment_match(audio_file, audio_file_base, command_Text, set_progress_bar):\r\n            audio_file_2_base = f'{os.path.splitext(os.path.basename(audio_file[1]))[0]}'\r\n            if audio_tool.audio_tool == MATCH_INPUTS:\r\n                audio_tool.match_inputs(audio_file, audio_file_base, command_Text)\r\n            else:\r\n                command_Text(f\"{PROCESS_STARTING_TEXT}\\n\")\r\n                audio_tool.align_inputs(audio_file, audio_file_base, audio_file_2_base, command_Text, set_progress_bar)\r\n            self.progress_bar_main_var.set(base * file_num)\r\n            self.command_Text.write(f\"{DONE}\\n\")\r\n\r\n        def handle_pitch_time_shift(audio_file, audio_file_base):\r\n            audio_tool.pitch_or_time_shift(audio_file, audio_file_base)\r\n            self.progress_bar_main_var.set(base * file_num)\r\n            self.command_Text.write(DONE)\r\n\r\n        multiple_files = False\r\n        stime = time.perf_counter()\r\n        self.process_button_init()\r\n        inputPaths = self.inputPaths\r\n        is_verified_audio = True\r\n        is_dual = False\r\n        is_model_sample_mode = self.model_sample_mode_var.get()\r\n        self.iteration = 0\r\n        self.true_model_count = 1\r\n        self.process_check_wav_type()\r\n        process_complete_text = PROCESS_COMPLETE\r\n\r\n        if self.chosen_audio_tool_var.get() in [ALIGN_INPUTS, MATCH_INPUTS]:\r\n            if self.DualBatch_inputPaths:\r\n                inputPaths = tuple(self.DualBatch_inputPaths)\r\n            else:\r\n                if not self.fileOneEntry_Full_var.get() or not self.fileTwoEntry_Full_var.get():\r\n                    self.command_Text.write(NOT_ENOUGH_ERROR_TEXT)\r\n                    self.process_end()\r\n                    return\r\n                else:\r\n                    inputPaths = [(self.fileOneEntry_Full_var.get(), self.fileTwoEntry_Full_var.get())]\r\n\r\n        try:\r\n            total_files = len(inputPaths)\r\n            if self.chosen_audio_tool_var.get() == TIME_STRETCH:\r\n                audio_tool = AudioTools(TIME_STRETCH)\r\n                self.progress_bar_main_var.set(2)\r\n            elif self.chosen_audio_tool_var.get() == CHANGE_PITCH:\r\n                audio_tool = AudioTools(CHANGE_PITCH)\r\n                self.progress_bar_main_var.set(2)\r\n            elif self.chosen_audio_tool_var.get() == MANUAL_ENSEMBLE:\r\n                if self.chosen_audio_tool_var.get() == MANUAL_ENSEMBLE:\r\n                    audio_tool = Ensembler(is_manual_ensemble=True)\r\n                multiple_files = True\r\n                if total_files <= 1:\r\n                    self.command_Text.write(NOT_ENOUGH_ERROR_TEXT)\r\n                    self.process_end()\r\n                    return\r\n            elif self.chosen_audio_tool_var.get() in [ALIGN_INPUTS, MATCH_INPUTS]:\r\n                audio_tool = AudioTools(self.chosen_audio_tool_var.get())\r\n                self.progress_bar_main_var.set(2)\r\n                is_dual = True\r\n\r\n            for file_num, audio_file in enumerate(inputPaths, start=1):\r\n                self.iteration += 1\r\n                base = (100 / total_files)\r\n                audio_file_base = get_audio_file_base(audio_file)\r\n                self.base_text = self.process_get_baseText(total_files=total_files, file_num=total_files if multiple_files else file_num, is_dual=is_dual)\r\n                command_Text = lambda text: self.command_Text.write(self.base_text + text)\r\n\r\n                set_progress_bar = lambda step, inference_iterations=0:self.process_update_progress(total_files=total_files, step=(step + (inference_iterations)))\r\n\r\n                if not self.verify_audio(audio_file):\r\n                    error_text_console = f'{self.base_text}\"{os.path.basename(audio_file)}\\\" {MISSING_MESS_TEXT}\\n'\r\n                    if total_files >= 2:\r\n                        self.command_Text.write(f'\\n{error_text_console}')\r\n                    is_verified_audio = False\r\n                    continue\r\n\r\n                audio_tool_action = audio_tool.audio_tool\r\n                if audio_tool_action not in [MANUAL_ENSEMBLE, ALIGN_INPUTS, MATCH_INPUTS]:\r\n                    audio_file = self.create_sample(audio_file) if is_model_sample_mode else audio_file\r\n                    self.command_Text.write(f'{NEW_LINE if file_num != 1 else NO_LINE}{self.base_text}\"{os.path.basename(audio_file)}\\\".{NEW_LINES}')\r\n                elif audio_tool_action in [ALIGN_INPUTS, MATCH_INPUTS]:\r\n                    text_write = (\"File 1\", \"File 2\") if audio_tool_action == ALIGN_INPUTS else (\"Target\", \"Reference\")\r\n                    if audio_file[0] != audio_file[1]:\r\n                        self.command_Text.write(f'{self.base_text}{text_write[0]}:  \"{os.path.basename(audio_file[0])}\"{NEW_LINE}')\r\n                        self.command_Text.write(f'{self.base_text}{text_write[1]}:  \"{os.path.basename(audio_file[1])}\"{NEW_LINES}')\r\n                    else:\r\n                        self.command_Text.write(f'{self.base_text}{text_write[0]} & {text_write[1]} {SIMILAR_TEXT}{NEW_LINES}')\r\n                        continue\r\n                elif audio_tool_action == MANUAL_ENSEMBLE:\r\n                    for n, i in enumerate(inputPaths):\r\n                        self.command_Text.write(f'File {n+1} \"{os.path.basename(i)}\"{NEW_LINE}')\r\n                    self.command_Text.write(NEW_LINE)\r\n                    \r\n                is_verified_audio = True\r\n\r\n                if not audio_tool_action in [ALIGN_INPUTS, MATCH_INPUTS]:\r\n                    command_Text(PROCESS_STARTING_TEXT)\r\n\r\n                if audio_tool_action == MANUAL_ENSEMBLE:\r\n                    handle_ensemble(inputPaths, audio_file_base)\r\n                    break\r\n                if audio_tool_action in [ALIGN_INPUTS, MATCH_INPUTS]:\r\n                    process_complete_text = PROCESS_COMPLETE_2\r\n                    handle_alignment_match(audio_file, audio_file_base, command_Text, set_progress_bar)\r\n                if audio_tool_action in [TIME_STRETCH, CHANGE_PITCH]:\r\n                    handle_pitch_time_shift(audio_file, audio_file_base)\r\n\r\n            if total_files == 1 and not is_verified_audio:\r\n                self.command_Text.write(f'{error_text_console}\\n{PROCESS_FAILED}')\r\n                self.command_Text.write(time_elapsed())\r\n                playsound(FAIL_CHIME) if self.is_task_complete_var.get() else None\r\n            else:\r\n                self.command_Text.write('{}{}'.format(process_complete_text, time_elapsed()))\r\n                playsound(COMPLETE_CHIME) if self.is_task_complete_var.get() else None\r\n\r\n            self.process_end()\r\n\r\n        except Exception as e:\r\n            self.error_log_var.set(error_text(self.chosen_audio_tool_var.get(), e))\r\n            self.command_Text.write(f'\\n\\n{PROCESS_FAILED}')\r\n            self.command_Text.write(time_elapsed())\r\n            playsound(FAIL_CHIME) if self.is_task_complete_var.get() else None\r\n            self.process_end(error=e)\r\n\r\n    def process_determine_secondary_model(self, process_method, main_model_primary_stem, is_primary_stem_only=False, is_secondary_stem_only=False):\r\n        \"\"\"Obtains the correct secondary model data for conversion.\"\"\"\r\n        \r\n        secondary_model_scale = None\r\n        secondary_model = tk.StringVar(value=NO_MODEL)\r\n        \r\n        if process_method == VR_ARCH_TYPE:\r\n            secondary_model_vars = self.vr_secondary_model_vars\r\n        if process_method == MDX_ARCH_TYPE:\r\n            secondary_model_vars = self.mdx_secondary_model_vars\r\n        if process_method == DEMUCS_ARCH_TYPE:\r\n            secondary_model_vars = self.demucs_secondary_model_vars\r\n\r\n        if main_model_primary_stem in [VOCAL_STEM, INST_STEM]:\r\n            secondary_model = secondary_model_vars[\"voc_inst_secondary_model\"]\r\n            secondary_model_scale = secondary_model_vars[\"voc_inst_secondary_model_scale\"].get()\r\n        if main_model_primary_stem in [OTHER_STEM, NO_OTHER_STEM]:\r\n            secondary_model = secondary_model_vars[\"other_secondary_model\"]\r\n            secondary_model_scale = secondary_model_vars[\"other_secondary_model_scale\"].get()\r\n        if main_model_primary_stem in [DRUM_STEM, NO_DRUM_STEM]:\r\n            secondary_model = secondary_model_vars[\"drums_secondary_model\"]\r\n            secondary_model_scale = secondary_model_vars[\"drums_secondary_model_scale\"].get()\r\n        if main_model_primary_stem in [BASS_STEM, NO_BASS_STEM]:\r\n            secondary_model = secondary_model_vars[\"bass_secondary_model\"]\r\n            secondary_model_scale = secondary_model_vars[\"bass_secondary_model_scale\"].get()\r\n\r\n        if secondary_model_scale:\r\n           secondary_model_scale = float(secondary_model_scale)\r\n\r\n        if not secondary_model.get() == NO_MODEL:\r\n            secondary_model = ModelData(secondary_model.get(), \r\n                                        is_secondary_model=True, \r\n                                        primary_model_primary_stem=main_model_primary_stem, \r\n                                        is_primary_model_primary_stem_only=is_primary_stem_only, \r\n                                        is_primary_model_secondary_stem_only=is_secondary_stem_only)\r\n            if not secondary_model.model_status:\r\n                secondary_model = None\r\n        else:\r\n            secondary_model = None\r\n            \r\n        return secondary_model, secondary_model_scale\r\n        \r\n    def process_determine_demucs_pre_proc_model(self, primary_stem=None):\r\n        \"\"\"Obtains the correct pre-process secondary model data for conversion.\"\"\"\r\n        \r\n        # Check if a pre-process model is set and it's not the 'NO_MODEL' value\r\n        if self.demucs_pre_proc_model_var.get() != NO_MODEL and self.is_demucs_pre_proc_model_activate_var.get():\r\n            pre_proc_model = ModelData(self.demucs_pre_proc_model_var.get(), \r\n                                        primary_model_primary_stem=primary_stem, \r\n                                        is_pre_proc_model=True)\r\n            \r\n            # Return the model if it's valid\r\n            if pre_proc_model.model_status:\r\n                return pre_proc_model\r\n                \r\n        return None\r\n\r\n    def process_determine_vocal_split_model(self):\r\n        \"\"\"Obtains the correct vocal splitter secondary model data for conversion.\"\"\"\r\n        \r\n        # Check if a vocal splitter model is set and if it's not the 'NO_MODEL' value\r\n        if self.set_vocal_splitter_var.get() != NO_MODEL and self.is_set_vocal_splitter_var.get():\r\n            vocal_splitter_model = ModelData(self.set_vocal_splitter_var.get(), is_vocal_split_model=True)\r\n            \r\n            # Return the model if it's valid\r\n            if vocal_splitter_model.model_status:\r\n                return vocal_splitter_model\r\n                \r\n        return None\r\n\r\n    def check_only_selection_stem(self, checktype):\r\n        \r\n        chosen_method = self.chosen_process_method_var.get()\r\n        is_demucs = chosen_method == DEMUCS_ARCH_TYPE#\r\n\r\n        stem_primary_label = self.is_primary_stem_only_Demucs_Text_var.get() if is_demucs else self.is_primary_stem_only_Text_var.get()\r\n        stem_primary_bool = self.is_primary_stem_only_Demucs_var.get() if is_demucs else self.is_primary_stem_only_var.get()\r\n        stem_secondary_label = self.is_secondary_stem_only_Demucs_Text_var.get() if is_demucs else self.is_secondary_stem_only_Text_var.get()\r\n        stem_secondary_bool = self.is_secondary_stem_only_Demucs_var.get() if is_demucs else self.is_secondary_stem_only_var.get()\r\n\r\n        if checktype == VOCAL_STEM_ONLY:\r\n            return not (\r\n                (not VOCAL_STEM_ONLY == stem_primary_label and stem_primary_bool) or \r\n                (not VOCAL_STEM_ONLY in stem_secondary_label and stem_secondary_bool)\r\n            )\r\n        elif checktype == INST_STEM_ONLY:\r\n            return (\r\n                (INST_STEM_ONLY == stem_primary_label and stem_primary_bool and self.is_save_inst_set_vocal_splitter_var.get() and self.set_vocal_splitter_var.get() != NO_MODEL) or \r\n                (INST_STEM_ONLY == stem_secondary_label and stem_secondary_bool and self.is_save_inst_set_vocal_splitter_var.get() and self.set_vocal_splitter_var.get() != NO_MODEL)\r\n            )\r\n        elif checktype == IS_SAVE_VOC_ONLY:\r\n            return (\r\n                (VOCAL_STEM_ONLY == stem_primary_label and stem_primary_bool) or \r\n                (VOCAL_STEM_ONLY == stem_secondary_label and stem_secondary_bool)\r\n            )\r\n        elif checktype == IS_SAVE_INST_ONLY:\r\n            return (\r\n                (INST_STEM_ONLY == stem_primary_label and stem_primary_bool) or \r\n                (INST_STEM_ONLY == stem_secondary_label and stem_secondary_bool)\r\n            )\r\n\r\n    def determine_voc_split(self, models):\r\n        is_vocal_active = self.check_only_selection_stem(VOCAL_STEM_ONLY) or self.check_only_selection_stem(INST_STEM_ONLY)\r\n\r\n        if self.set_vocal_splitter_var.get() != NO_MODEL and self.is_set_vocal_splitter_var.get() and is_vocal_active:\r\n            model_stems_list = self.model_list(VOCAL_STEM, INST_STEM, is_dry_check=True, is_check_vocal_split=True)\r\n            if any(model.model_basename in model_stems_list for model in models):\r\n                return 1\r\n        \r\n        return 0\r\n        \r\n    def process_start(self):\r\n        \"\"\"Start the conversion for all the given mp3 and wav files\"\"\"\r\n        \r\n        stime = time.perf_counter()\r\n        time_elapsed = lambda:f'Time Elapsed: {time.strftime(\"%H:%M:%S\", time.gmtime(int(time.perf_counter() - stime)))}'\r\n        export_path = self.export_path_var.get()\r\n        is_ensemble = False\r\n        self.true_model_count = 0\r\n        self.iteration = 0\r\n        is_verified_audio = True\r\n        self.process_button_init()\r\n        inputPaths = self.inputPaths\r\n        inputPath_total_len = len(inputPaths)\r\n        is_model_sample_mode = self.model_sample_mode_var.get()\r\n        \r\n        try:\r\n            if self.chosen_process_method_var.get() == ENSEMBLE_MODE:\r\n                model, ensemble = self.assemble_model_data(), Ensembler()\r\n                export_path, is_ensemble = ensemble.ensemble_folder_name, True\r\n            if self.chosen_process_method_var.get() == VR_ARCH_PM:\r\n                model = self.assemble_model_data(self.vr_model_var.get(), VR_ARCH_TYPE)\r\n            if self.chosen_process_method_var.get() == MDX_ARCH_TYPE:\r\n                model = self.assemble_model_data(self.mdx_net_model_var.get(), MDX_ARCH_TYPE)\r\n            if self.chosen_process_method_var.get() == DEMUCS_ARCH_TYPE:\r\n                model = self.assemble_model_data(self.demucs_model_var.get(), DEMUCS_ARCH_TYPE)\r\n\r\n            self.cached_source_model_list_check(model)\r\n            \r\n            true_model_4_stem_count = sum(m.demucs_4_stem_added_count if m.process_method == DEMUCS_ARCH_TYPE else 0 for m in model)\r\n            true_model_pre_proc_model_count = sum(2 if m.pre_proc_model_activated else 0 for m in model)\r\n            self.true_model_count = sum(2 if m.is_secondary_model_activated else 1 for m in model) + true_model_4_stem_count + true_model_pre_proc_model_count + self.determine_voc_split(model)\r\n\r\n            #print(\"self.true_model_count\", self.true_model_count)\r\n\r\n            for file_num, audio_file in enumerate(inputPaths, start=1):\r\n                self.cached_sources_clear()\r\n                base_text = self.process_get_baseText(total_files=inputPath_total_len, file_num=file_num)\r\n\r\n                if self.verify_audio(audio_file):\r\n                    audio_file = self.create_sample(audio_file) if is_model_sample_mode else audio_file\r\n                    self.command_Text.write(f'{NEW_LINE if not file_num ==1 else NO_LINE}{base_text}\"{os.path.basename(audio_file)}\\\".{NEW_LINES}')\r\n                    is_verified_audio = True\r\n                else:\r\n                    error_text_console = f'{base_text}\"{os.path.basename(audio_file)}\\\" {MISSING_MESS_TEXT}\\n'\r\n                    self.command_Text.write(f'\\n{error_text_console}') if inputPath_total_len >= 2 else None\r\n                    self.iteration += self.true_model_count\r\n                    is_verified_audio = False\r\n                    continue\r\n\r\n                for current_model_num, current_model in enumerate(model, start=1):\r\n                    self.iteration += 1\r\n\r\n                    if is_ensemble:\r\n                        self.command_Text.write(f'Ensemble Mode - {current_model.model_basename} - Model {current_model_num}/{len(model)}{NEW_LINES}')\r\n\r\n                    model_name_text = f'({current_model.model_basename})' if not is_ensemble else ''\r\n                    self.command_Text.write(base_text + f'{LOADING_MODEL_TEXT} {model_name_text}...')\r\n\r\n                    set_progress_bar = lambda step, inference_iterations=0:self.process_update_progress(total_files=inputPath_total_len, step=(step + (inference_iterations)))\r\n                    write_to_console = lambda progress_text, base_text=base_text:self.command_Text.write(base_text + progress_text)\r\n\r\n                    audio_file_base = f\"{file_num}_{os.path.splitext(os.path.basename(audio_file))[0]}\"\r\n                    audio_file_base = audio_file_base if not self.is_testing_audio_var.get() or is_ensemble else f\"{round(time.time())}_{audio_file_base}\"\r\n                    audio_file_base = audio_file_base if not is_ensemble else f\"{audio_file_base}_{current_model.model_basename}\"\r\n                    if not is_ensemble:\r\n                        audio_file_base = audio_file_base if not self.is_add_model_name_var.get() else f\"{audio_file_base}_{current_model.model_basename}\"\r\n\r\n                    if self.is_create_model_folder_var.get() and not is_ensemble:\r\n                        export_path = os.path.join(Path(self.export_path_var.get()), current_model.model_basename, os.path.splitext(os.path.basename(audio_file))[0])\r\n                        if not os.path.isdir(export_path):os.makedirs(export_path) \r\n\r\n                    process_data = {\r\n                                    'model_data': current_model, \r\n                                    'export_path': export_path,\r\n                                    'audio_file_base': audio_file_base,\r\n                                    'audio_file': audio_file,\r\n                                    'set_progress_bar': set_progress_bar,\r\n                                    'write_to_console': write_to_console,\r\n                                    'process_iteration': self.process_iteration,\r\n                                    'cached_source_callback': self.cached_source_callback,\r\n                                    'cached_model_source_holder': self.cached_model_source_holder,\r\n                                    'list_all_models': self.all_models,\r\n                                    'is_ensemble_master': is_ensemble,\r\n                                    'is_4_stem_ensemble': True if self.ensemble_main_stem_var.get() in [FOUR_STEM_ENSEMBLE, MULTI_STEM_ENSEMBLE] and is_ensemble else False}\r\n                    \r\n                    if current_model.process_method == VR_ARCH_TYPE:\r\n                        seperator = SeperateVR(current_model, process_data)\r\n                    if current_model.process_method == MDX_ARCH_TYPE:\r\n                        seperator = SeperateMDXC(current_model, process_data) if current_model.is_mdx_c else SeperateMDX(current_model, process_data)\r\n                    if current_model.process_method == DEMUCS_ARCH_TYPE:\r\n                        seperator = SeperateDemucs(current_model, process_data)\r\n                        \r\n                    seperator.seperate()\r\n                    \r\n                    if is_ensemble:\r\n                        self.command_Text.write('\\n')\r\n\r\n                if is_ensemble:\r\n                    \r\n                    audio_file_base = audio_file_base.replace(f\"_{current_model.model_basename}\",\"\")\r\n                    self.command_Text.write(base_text + ENSEMBLING_OUTPUTS)\r\n                    \r\n                    if self.ensemble_main_stem_var.get() in [FOUR_STEM_ENSEMBLE, MULTI_STEM_ENSEMBLE]:\r\n                        stem_list = extract_stems(audio_file_base, export_path)\r\n                        for output_stem in stem_list:\r\n                            ensemble.ensemble_outputs(audio_file_base, export_path, output_stem, is_4_stem=True)\r\n                    else:\r\n                        if not self.is_secondary_stem_only_var.get():\r\n                            ensemble.ensemble_outputs(audio_file_base, export_path, PRIMARY_STEM)\r\n                        if not self.is_primary_stem_only_var.get():\r\n                            ensemble.ensemble_outputs(audio_file_base, export_path, SECONDARY_STEM)\r\n                            ensemble.ensemble_outputs(audio_file_base, export_path, SECONDARY_STEM, is_inst_mix=True)\r\n\r\n                    self.command_Text.write(DONE)\r\n                    \r\n                if is_model_sample_mode:\r\n                    if os.path.isfile(audio_file):\r\n                        os.remove(audio_file)\r\n                    \r\n                clear_gpu_cache()\r\n                \r\n            shutil.rmtree(export_path) if is_ensemble and len(os.listdir(export_path)) == 0 else None\r\n\r\n            if inputPath_total_len == 1 and not is_verified_audio:\r\n                self.command_Text.write(f'{error_text_console}\\n{PROCESS_FAILED}')\r\n                self.command_Text.write(time_elapsed())\r\n                playsound(FAIL_CHIME) if self.is_task_complete_var.get() else None\r\n            else:\r\n                set_progress_bar(1.0)\r\n                self.command_Text.write(PROCESS_COMPLETE)\r\n                self.command_Text.write(time_elapsed())\r\n                playsound(COMPLETE_CHIME) if self.is_task_complete_var.get() else None\r\n                \r\n            self.process_end()\r\n                        \r\n        except Exception as e:\r\n            self.error_log_var.set(\"{}{}\".format(error_text(self.chosen_process_method_var.get(), e), self.get_settings_list()))\r\n            self.command_Text.write(f'\\n\\n{PROCESS_FAILED}')\r\n            self.command_Text.write(time_elapsed())\r\n            playsound(FAIL_CHIME) if self.is_task_complete_var.get() else None\r\n            self.process_end(error=e)\r\n\r\n    #--Varible Methods--\r\n\r\n    def load_to_default_confirm(self):\r\n        \"\"\"Reset settings confirmation after asking for confirmation\"\"\"\r\n        if self.thread_check(self.active_processing_thread):\r\n            self.error_dialogue(SET_TO_DEFAULT_PROCESS_ERROR)\r\n            return\r\n        \r\n        confirm = messagebox.askyesno(\r\n            parent=root, \r\n            title=RESET_ALL_TO_DEFAULT_WARNING[0], \r\n            message=RESET_ALL_TO_DEFAULT_WARNING[1]\r\n        )\r\n        if not confirm:\r\n            return\r\n        \r\n        self.load_saved_settings(DEFAULT_DATA, is_default_reset=True)\r\n        self.update_checkbox_text()\r\n\r\n        if self.pre_proc_model_toggle is not None and self.is_open_menu_advanced_demucs_options.get():\r\n            self.pre_proc_model_toggle()\r\n\r\n        if (self.change_state_lambda is not None and (\r\n            self.is_open_menu_advanced_vr_options.get() or \r\n            self.is_open_menu_advanced_mdx_options.get() or \r\n            self.is_open_menu_advanced_demucs_options.get()\r\n        )):\r\n            self.change_state_lambda()\r\n\r\n    def load_saved_vars(self, data):\r\n        \"\"\"Initializes primary Tkinter vars\"\"\"\r\n        \r\n        for key, value in DEFAULT_DATA.items():\r\n            if not key in data.keys():\r\n                data = {**data, **{key:value}}\r\n                data['batch_size'] = DEF_OPT\r\n\r\n        ## ADD_BUTTON\r\n        self.chosen_process_method_var = tk.StringVar(value=data['chosen_process_method'])\r\n        \r\n        #VR Architecture Vars\r\n        self.vr_model_var = tk.StringVar(value=data['vr_model'])\r\n        self.aggression_setting_var = tk.StringVar(value=data['aggression_setting'])\r\n        self.window_size_var = tk.StringVar(value=data['window_size'])\r\n        self.mdx_segment_size_var = tk.StringVar(value=data['mdx_segment_size'])\r\n        self.batch_size_var = tk.StringVar(value=data['batch_size'])\r\n        self.crop_size_var = tk.StringVar(value=data['crop_size'])\r\n        self.is_tta_var = tk.BooleanVar(value=data['is_tta'])\r\n        self.is_output_image_var = tk.BooleanVar(value=data['is_output_image'])\r\n        self.is_post_process_var = tk.BooleanVar(value=data['is_post_process'])\r\n        self.is_high_end_process_var = tk.BooleanVar(value=data['is_high_end_process'])\r\n        self.post_process_threshold_var = tk.StringVar(value=data['post_process_threshold'])\r\n        self.vr_voc_inst_secondary_model_var = tk.StringVar(value=data['vr_voc_inst_secondary_model'])\r\n        self.vr_other_secondary_model_var = tk.StringVar(value=data['vr_other_secondary_model'])\r\n        self.vr_bass_secondary_model_var = tk.StringVar(value=data['vr_bass_secondary_model'])\r\n        self.vr_drums_secondary_model_var = tk.StringVar(value=data['vr_drums_secondary_model'])\r\n        self.vr_is_secondary_model_activate_var = tk.BooleanVar(value=data['vr_is_secondary_model_activate'])\r\n        self.vr_voc_inst_secondary_model_scale_var = tk.StringVar(value=data['vr_voc_inst_secondary_model_scale'])\r\n        self.vr_other_secondary_model_scale_var = tk.StringVar(value=data['vr_other_secondary_model_scale'])\r\n        self.vr_bass_secondary_model_scale_var = tk.StringVar(value=data['vr_bass_secondary_model_scale'])\r\n        self.vr_drums_secondary_model_scale_var = tk.StringVar(value=data['vr_drums_secondary_model_scale'])\r\n\r\n        #Demucs Vars\r\n        self.demucs_model_var = tk.StringVar(value=data['demucs_model'])\r\n        self.segment_var = tk.StringVar(value=data['segment'])\r\n        self.overlap_var = tk.StringVar(value=data['overlap'])\r\n        self.overlap_mdx_var = tk.StringVar(value=data['overlap_mdx'])\r\n        self.overlap_mdx23_var = tk.StringVar(value=data['overlap_mdx23'])\r\n        self.shifts_var = tk.StringVar(value=data['shifts'])\r\n        self.chunks_demucs_var = tk.StringVar(value=data['chunks_demucs'])\r\n        self.margin_demucs_var = tk.StringVar(value=data['margin_demucs'])\r\n        self.is_chunk_demucs_var = tk.BooleanVar(value=data['is_chunk_demucs'])\r\n        self.is_chunk_mdxnet_var = tk.BooleanVar(value=False)\r\n        self.is_primary_stem_only_Demucs_var = tk.BooleanVar(value=data['is_primary_stem_only_Demucs'])\r\n        self.is_secondary_stem_only_Demucs_var = tk.BooleanVar(value=data['is_secondary_stem_only_Demucs'])\r\n        self.is_split_mode_var = tk.BooleanVar(value=data['is_split_mode'])\r\n        self.is_demucs_combine_stems_var = tk.BooleanVar(value=data['is_demucs_combine_stems'])#is_mdx23_combine_stems\r\n        self.is_mdx23_combine_stems_var = tk.BooleanVar(value=data['is_mdx23_combine_stems'])\r\n        self.demucs_voc_inst_secondary_model_var = tk.StringVar(value=data['demucs_voc_inst_secondary_model'])\r\n        self.demucs_other_secondary_model_var = tk.StringVar(value=data['demucs_other_secondary_model'])\r\n        self.demucs_bass_secondary_model_var = tk.StringVar(value=data['demucs_bass_secondary_model'])\r\n        self.demucs_drums_secondary_model_var = tk.StringVar(value=data['demucs_drums_secondary_model'])\r\n        self.demucs_is_secondary_model_activate_var = tk.BooleanVar(value=data['demucs_is_secondary_model_activate'])\r\n        self.demucs_voc_inst_secondary_model_scale_var = tk.StringVar(value=data['demucs_voc_inst_secondary_model_scale'])\r\n        self.demucs_other_secondary_model_scale_var = tk.StringVar(value=data['demucs_other_secondary_model_scale'])\r\n        self.demucs_bass_secondary_model_scale_var = tk.StringVar(value=data['demucs_bass_secondary_model_scale'])\r\n        self.demucs_drums_secondary_model_scale_var = tk.StringVar(value=data['demucs_drums_secondary_model_scale'])\r\n        self.demucs_pre_proc_model_var = tk.StringVar(value=data['demucs_pre_proc_model'])\r\n        self.is_demucs_pre_proc_model_activate_var = tk.BooleanVar(value=data['is_demucs_pre_proc_model_activate'])\r\n        self.is_demucs_pre_proc_model_inst_mix_var = tk.BooleanVar(value=data['is_demucs_pre_proc_model_inst_mix'])\r\n        \r\n        #MDX-Net Vars\r\n        self.mdx_net_model_var = tk.StringVar(value=data['mdx_net_model'])\r\n        self.chunks_var = tk.StringVar(value=data['chunks'])\r\n        self.margin_var = tk.StringVar(value=data['margin'])\r\n        self.compensate_var = tk.StringVar(value=data['compensate'])\r\n        self.denoise_option_var = tk.StringVar(value=data['denoise_option'])#\r\n        self.phase_option_var = tk.StringVar(value=data['phase_option'])#\r\n        self.phase_shifts_var = tk.StringVar(value=data['phase_shifts'])#\r\n        self.is_save_align_var = tk.BooleanVar(value=data['is_save_align'])#,\r\n        self.is_match_silence_var = tk.BooleanVar(value=data['is_match_silence'])#\r\n        self.is_spec_match_var = tk.BooleanVar(value=data['is_spec_match'])#\r\n        self.is_match_frequency_pitch_var = tk.BooleanVar(value=data['is_match_frequency_pitch'])#\r\n        self.is_mdx_c_seg_def_var = tk.BooleanVar(value=data['is_mdx_c_seg_def'])#\r\n        self.is_invert_spec_var = tk.BooleanVar(value=data['is_invert_spec'])#\r\n        self.is_deverb_vocals_var = tk.BooleanVar(value=data['is_deverb_vocals'])#\r\n        self.deverb_vocal_opt_var = tk.StringVar(value=data['deverb_vocal_opt'])#\r\n        self.voc_split_save_opt_var = tk.StringVar(value=data['voc_split_save_opt'])#\r\n        self.is_mixer_mode_var = tk.BooleanVar(value=data['is_mixer_mode'])\r\n        self.mdx_batch_size_var = tk.StringVar(value=data['mdx_batch_size'])\r\n        self.mdx_voc_inst_secondary_model_var = tk.StringVar(value=data['mdx_voc_inst_secondary_model'])\r\n        self.mdx_other_secondary_model_var = tk.StringVar(value=data['mdx_other_secondary_model'])\r\n        self.mdx_bass_secondary_model_var = tk.StringVar(value=data['mdx_bass_secondary_model'])\r\n        self.mdx_drums_secondary_model_var = tk.StringVar(value=data['mdx_drums_secondary_model'])\r\n        self.mdx_is_secondary_model_activate_var = tk.BooleanVar(value=data['mdx_is_secondary_model_activate'])\r\n        self.mdx_voc_inst_secondary_model_scale_var = tk.StringVar(value=data['mdx_voc_inst_secondary_model_scale'])\r\n        self.mdx_other_secondary_model_scale_var = tk.StringVar(value=data['mdx_other_secondary_model_scale'])\r\n        self.mdx_bass_secondary_model_scale_var = tk.StringVar(value=data['mdx_bass_secondary_model_scale'])\r\n        self.mdx_drums_secondary_model_scale_var = tk.StringVar(value=data['mdx_drums_secondary_model_scale'])\r\n        self.is_mdxnet_c_model_var = tk.BooleanVar(value=False)\r\n\r\n        #Ensemble Vars\r\n        self.is_save_all_outputs_ensemble_var = tk.BooleanVar(value=data['is_save_all_outputs_ensemble'])\r\n        self.is_append_ensemble_name_var = tk.BooleanVar(value=data['is_append_ensemble_name'])\r\n\r\n        #Audio Tool Vars\r\n        self.chosen_audio_tool_var = tk.StringVar(value=data['chosen_audio_tool'])\r\n        self.choose_algorithm_var = tk.StringVar(value=data['choose_algorithm'])\r\n        self.time_stretch_rate_var = tk.StringVar(value=data['time_stretch_rate'])\r\n        self.pitch_rate_var = tk.StringVar(value=data['pitch_rate'])\r\n        self.is_time_correction_var = tk.BooleanVar(value=data['is_time_correction'])\r\n\r\n        #Shared Vars\r\n        self.semitone_shift_var = tk.StringVar(value=data['semitone_shift'])\r\n        self.mp3_bit_set_var = tk.StringVar(value=data['mp3_bit_set'])\r\n        self.save_format_var = tk.StringVar(value=data['save_format'])\r\n        self.wav_type_set_var = tk.StringVar(value=data['wav_type_set'])#\r\n        self.device_set_var = tk.StringVar(value=data['device_set'])#\r\n        self.user_code_var = tk.StringVar(value=data['user_code']) \r\n        self.is_gpu_conversion_var = tk.BooleanVar(value=data['is_gpu_conversion'])\r\n        self.is_primary_stem_only_var = tk.BooleanVar(value=data['is_primary_stem_only'])\r\n        self.is_secondary_stem_only_var = tk.BooleanVar(value=data['is_secondary_stem_only'])\r\n        self.is_testing_audio_var = tk.BooleanVar(value=data['is_testing_audio'])#\r\n        self.is_auto_update_model_params_var = tk.BooleanVar(value=True)#\r\n        self.is_auto_update_model_params = data['is_auto_update_model_params']\r\n        self.is_add_model_name_var = tk.BooleanVar(value=data['is_add_model_name'])\r\n        self.is_accept_any_input_var = tk.BooleanVar(value=data['is_accept_any_input'])\r\n        self.is_task_complete_var = tk.BooleanVar(value=data['is_task_complete'])\r\n        self.is_normalization_var = tk.BooleanVar(value=data['is_normalization'])#\r\n        self.is_use_opencl_var = tk.BooleanVar(value=False)#True if is_opencl_only else data['is_use_opencl'])#\r\n        self.is_wav_ensemble_var = tk.BooleanVar(value=data['is_wav_ensemble'])#\r\n        self.is_create_model_folder_var = tk.BooleanVar(value=data['is_create_model_folder'])\r\n        self.help_hints_var = tk.BooleanVar(value=data['help_hints_var'])\r\n        self.model_sample_mode_var = tk.BooleanVar(value=data['model_sample_mode'])\r\n        self.model_sample_mode_duration_var = tk.StringVar(value=data['model_sample_mode_duration'])\r\n        self.model_sample_mode_duration_checkbox_var = tk.StringVar(value=SAMPLE_MODE_CHECKBOX(self.model_sample_mode_duration_var.get()))\r\n        self.model_sample_mode_duration_label_var = tk.StringVar(value=f'{self.model_sample_mode_duration_var.get()} Seconds')\r\n        self.set_vocal_splitter_var = tk.StringVar(value=data['set_vocal_splitter'])\r\n        self.is_set_vocal_splitter_var = tk.BooleanVar(value=data['is_set_vocal_splitter'])#\r\n        self.is_save_inst_set_vocal_splitter_var = tk.BooleanVar(value=data['is_save_inst_set_vocal_splitter'])#\r\n        \r\n        #Path Vars\r\n        self.export_path_var = tk.StringVar(value=data['export_path'])\r\n        self.inputPaths = data['input_paths']\r\n        self.lastDir = data['lastDir']\r\n        \r\n        #DualPaths-Align\r\n        self.time_window_var = tk.StringVar(value=data['time_window'])#\r\n        self.intro_analysis_var = tk.StringVar(value=data['intro_analysis'])\r\n        self.db_analysis_var = tk.StringVar(value=data['db_analysis'])\r\n        \r\n        self.fileOneEntry_var = tk.StringVar(value=data['fileOneEntry'])\r\n        self.fileOneEntry_Full_var = tk.StringVar(value=data['fileOneEntry_Full'])\r\n        self.fileTwoEntry_var = tk.StringVar(value=data['fileTwoEntry'])\r\n        self.fileTwoEntry_Full_var = tk.StringVar(value=data['fileTwoEntry_Full'])\r\n        self.DualBatch_inputPaths = data['DualBatch_inputPaths']\r\n   \r\n    def load_saved_settings(self, loaded_setting: dict, process_method=None, is_default_reset=False):\r\n        \"\"\"Loads user saved application settings or resets to default\"\"\"\r\n        \r\n        for key, value in DEFAULT_DATA.items():\r\n            if not key in loaded_setting.keys():\r\n                loaded_setting = {**loaded_setting, **{key:value}}\r\n                loaded_setting['batch_size'] = DEF_OPT\r\n                \r\n        is_default_reset = True if process_method == ENSEMBLE_MODE or is_default_reset else False\r\n        \r\n        if process_method == VR_ARCH_PM or is_default_reset:\r\n            self.vr_model_var.set(loaded_setting['vr_model'])\r\n            self.aggression_setting_var.set(loaded_setting['aggression_setting'])\r\n            self.window_size_var.set(loaded_setting['window_size'])\r\n            self.mdx_segment_size_var.set(loaded_setting['mdx_segment_size'])\r\n            self.batch_size_var.set(loaded_setting['batch_size'])\r\n            self.crop_size_var.set(loaded_setting['crop_size'])\r\n            self.is_tta_var.set(loaded_setting['is_tta'])\r\n            self.is_output_image_var.set(loaded_setting['is_output_image'])\r\n            self.is_post_process_var.set(loaded_setting['is_post_process'])\r\n            self.is_high_end_process_var.set(loaded_setting['is_high_end_process'])\r\n            self.post_process_threshold_var.set(loaded_setting['post_process_threshold'])\r\n            self.vr_voc_inst_secondary_model_var.set(loaded_setting['vr_voc_inst_secondary_model'])\r\n            self.vr_other_secondary_model_var.set(loaded_setting['vr_other_secondary_model'])\r\n            self.vr_bass_secondary_model_var.set(loaded_setting['vr_bass_secondary_model'])\r\n            self.vr_drums_secondary_model_var.set(loaded_setting['vr_drums_secondary_model'])\r\n            self.vr_is_secondary_model_activate_var.set(loaded_setting['vr_is_secondary_model_activate'])\r\n            self.vr_voc_inst_secondary_model_scale_var.set(loaded_setting['vr_voc_inst_secondary_model_scale'])\r\n            self.vr_other_secondary_model_scale_var.set(loaded_setting['vr_other_secondary_model_scale'])\r\n            self.vr_bass_secondary_model_scale_var.set(loaded_setting['vr_bass_secondary_model_scale'])\r\n            self.vr_drums_secondary_model_scale_var.set(loaded_setting['vr_drums_secondary_model_scale'])\r\n        \r\n        if process_method == DEMUCS_ARCH_TYPE or is_default_reset:\r\n            self.demucs_model_var.set(loaded_setting['demucs_model'])\r\n            self.segment_var.set(loaded_setting['segment'])\r\n            self.overlap_var.set(loaded_setting['overlap'])\r\n            self.shifts_var.set(loaded_setting['shifts'])\r\n            self.chunks_demucs_var.set(loaded_setting['chunks_demucs'])\r\n            self.margin_demucs_var.set(loaded_setting['margin_demucs'])\r\n            self.is_chunk_demucs_var.set(loaded_setting['is_chunk_demucs'])\r\n            self.is_chunk_mdxnet_var.set(loaded_setting['is_chunk_mdxnet'])\r\n            self.is_primary_stem_only_Demucs_var.set(loaded_setting['is_primary_stem_only_Demucs'])\r\n            self.is_secondary_stem_only_Demucs_var.set(loaded_setting['is_secondary_stem_only_Demucs'])\r\n            self.is_split_mode_var.set(loaded_setting['is_split_mode'])\r\n            self.is_demucs_combine_stems_var.set(loaded_setting['is_demucs_combine_stems'])#\r\n            self.is_mdx23_combine_stems_var.set(loaded_setting['is_mdx23_combine_stems'])#\r\n            self.demucs_voc_inst_secondary_model_var.set(loaded_setting['demucs_voc_inst_secondary_model'])\r\n            self.demucs_other_secondary_model_var.set(loaded_setting['demucs_other_secondary_model'])\r\n            self.demucs_bass_secondary_model_var.set(loaded_setting['demucs_bass_secondary_model'])\r\n            self.demucs_drums_secondary_model_var.set(loaded_setting['demucs_drums_secondary_model'])\r\n            self.demucs_is_secondary_model_activate_var.set(loaded_setting['demucs_is_secondary_model_activate'])\r\n            self.demucs_voc_inst_secondary_model_scale_var.set(loaded_setting['demucs_voc_inst_secondary_model_scale'])\r\n            self.demucs_other_secondary_model_scale_var.set(loaded_setting['demucs_other_secondary_model_scale'])\r\n            self.demucs_bass_secondary_model_scale_var.set(loaded_setting['demucs_bass_secondary_model_scale'])\r\n            self.demucs_drums_secondary_model_scale_var.set(loaded_setting['demucs_drums_secondary_model_scale'])\r\n            self.demucs_stems_var.set(loaded_setting['demucs_stems'])\r\n            self.mdxnet_stems_var.set(loaded_setting['mdx_stems'])\r\n            self.update_stem_checkbox_labels(self.demucs_stems_var.get(), demucs=True)\r\n            self.demucs_pre_proc_model_var.set(loaded_setting['demucs_pre_proc_model'])\r\n            self.is_demucs_pre_proc_model_activate_var.set(loaded_setting['is_demucs_pre_proc_model_activate'])\r\n            self.is_demucs_pre_proc_model_inst_mix_var.set(loaded_setting['is_demucs_pre_proc_model_inst_mix'])\r\n        \r\n        if process_method == MDX_ARCH_TYPE or is_default_reset:\r\n            self.mdx_net_model_var.set(loaded_setting['mdx_net_model'])\r\n            self.chunks_var.set(loaded_setting['chunks'])\r\n            self.margin_var.set(loaded_setting['margin'])\r\n            self.compensate_var.set(loaded_setting['compensate'])\r\n            self.denoise_option_var.set(loaded_setting['denoise_option'])\r\n            self.is_match_frequency_pitch_var.set(loaded_setting['is_match_frequency_pitch'])#\r\n            self.overlap_mdx_var.set(loaded_setting['overlap_mdx'])\r\n            self.overlap_mdx23_var.set(loaded_setting['overlap_mdx23'])\r\n            self.is_mdx_c_seg_def_var.set(loaded_setting['is_mdx_c_seg_def'])#\r\n            self.is_invert_spec_var.set(loaded_setting['is_invert_spec'])#\r\n            self.is_mixer_mode_var.set(loaded_setting['is_mixer_mode'])\r\n            self.mdx_batch_size_var.set(loaded_setting['mdx_batch_size'])\r\n            self.mdx_voc_inst_secondary_model_var.set(loaded_setting['mdx_voc_inst_secondary_model'])\r\n            self.mdx_other_secondary_model_var.set(loaded_setting['mdx_other_secondary_model'])\r\n            self.mdx_bass_secondary_model_var.set(loaded_setting['mdx_bass_secondary_model'])\r\n            self.mdx_drums_secondary_model_var.set(loaded_setting['mdx_drums_secondary_model'])\r\n            self.mdx_is_secondary_model_activate_var.set(loaded_setting['mdx_is_secondary_model_activate'])\r\n            self.mdx_voc_inst_secondary_model_scale_var.set(loaded_setting['mdx_voc_inst_secondary_model_scale'])\r\n            self.mdx_other_secondary_model_scale_var.set(loaded_setting['mdx_other_secondary_model_scale'])\r\n            self.mdx_bass_secondary_model_scale_var.set(loaded_setting['mdx_bass_secondary_model_scale'])\r\n            self.mdx_drums_secondary_model_scale_var.set(loaded_setting['mdx_drums_secondary_model_scale'])\r\n        \r\n        if is_default_reset:\r\n            self.is_save_all_outputs_ensemble_var.set(loaded_setting['is_save_all_outputs_ensemble'])\r\n            self.is_append_ensemble_name_var.set(loaded_setting['is_append_ensemble_name'])\r\n            self.choose_algorithm_var.set(loaded_setting['choose_algorithm'])\r\n            self.time_stretch_rate_var.set(loaded_setting['time_stretch_rate'])\r\n            self.pitch_rate_var.set(loaded_setting['pitch_rate'])#\r\n            self.is_time_correction_var.set(loaded_setting['is_time_correction'])#\r\n            self.is_primary_stem_only_var.set(loaded_setting['is_primary_stem_only'])\r\n            self.is_secondary_stem_only_var.set(loaded_setting['is_secondary_stem_only'])\r\n            self.is_testing_audio_var.set(loaded_setting['is_testing_audio'])#\r\n            self.is_auto_update_model_params_var.set(loaded_setting['is_auto_update_model_params'])\r\n            self.is_add_model_name_var.set(loaded_setting['is_add_model_name'])\r\n            self.is_accept_any_input_var.set(loaded_setting[\"is_accept_any_input\"])\r\n            self.is_task_complete_var.set(loaded_setting['is_task_complete'])\r\n            self.is_create_model_folder_var.set(loaded_setting['is_create_model_folder'])\r\n            self.mp3_bit_set_var.set(loaded_setting['mp3_bit_set'])\r\n            self.semitone_shift_var.set(loaded_setting['semitone_shift'])#\r\n            self.save_format_var.set(loaded_setting['save_format'])\r\n            self.wav_type_set_var.set(loaded_setting['wav_type_set'])#\r\n            self.device_set_var.set(loaded_setting['device_set'])#\r\n            self.user_code_var.set(loaded_setting['user_code'])\r\n            self.phase_option_var.set(loaded_setting['phase_option'])#\r\n            self.phase_shifts_var.set(loaded_setting['phase_shifts'])#\r\n            self.is_save_align_var.set(loaded_setting['is_save_align'])#i\r\n            self.time_window_var.set(loaded_setting['time_window'])#\r\n            self.is_match_silence_var.set(loaded_setting['is_match_silence'])#\r\n            self.is_spec_match_var.set(loaded_setting['is_spec_match'])#\r\n            self.intro_analysis_var.set(loaded_setting['intro_analysis'])#\r\n            self.db_analysis_var.set(loaded_setting['db_analysis'])#\r\n            self.fileOneEntry_var.set(loaded_setting['fileOneEntry'])#\r\n            self.fileOneEntry_Full_var.set(loaded_setting['fileOneEntry_Full'])#\r\n            self.fileTwoEntry_var.set(loaded_setting['fileTwoEntry'])#\r\n            self.fileTwoEntry_Full_var.set(loaded_setting['fileTwoEntry_Full'])#\r\n            self.DualBatch_inputPaths = []\r\n            \r\n        self.is_gpu_conversion_var.set(loaded_setting['is_gpu_conversion'])\r\n        self.is_normalization_var.set(loaded_setting['is_normalization'])#\r\n        self.is_use_opencl_var.set(False)#True if is_opencl_only else loaded_setting['is_use_opencl'])#\r\n        self.is_wav_ensemble_var.set(loaded_setting['is_wav_ensemble'])#\r\n        self.help_hints_var.set(loaded_setting['help_hints_var'])\r\n        self.is_wav_ensemble_var.set(loaded_setting['is_wav_ensemble'])\r\n        self.set_vocal_splitter_var.set(loaded_setting['set_vocal_splitter'])\r\n        self.is_set_vocal_splitter_var.set(loaded_setting['is_set_vocal_splitter'])#\r\n        self.is_save_inst_set_vocal_splitter_var.set(loaded_setting['is_save_inst_set_vocal_splitter'])#\r\n        self.deverb_vocal_opt_var.set(loaded_setting['deverb_vocal_opt'])#\r\n        self.voc_split_save_opt_var.set(loaded_setting['voc_split_save_opt'])#\r\n        self.is_deverb_vocals_var.set(loaded_setting['is_deverb_vocals'])#\r\n        \r\n        self.model_sample_mode_var.set(loaded_setting['model_sample_mode'])\r\n        self.model_sample_mode_duration_var.set(loaded_setting['model_sample_mode_duration'])\r\n        self.model_sample_mode_duration_checkbox_var.set(SAMPLE_MODE_CHECKBOX(self.model_sample_mode_duration_var.get()))\r\n        self.model_sample_mode_duration_label_var.set(f'{self.model_sample_mode_duration_var.get()} Seconds')\r\n              \r\n    def save_values(self, app_close=True, is_restart=False, is_auto_save=False):\r\n        \"\"\"Saves application data\"\"\"\r\n\r\n        # -Save Data-\r\n        main_settings={\r\n            'vr_model': self.vr_model_var.get(),\r\n            'aggression_setting': self.aggression_setting_var.get(),\r\n            'window_size': self.window_size_var.get(),\r\n            'mdx_segment_size': self.mdx_segment_size_var.get(),\r\n            'batch_size': self.batch_size_var.get(),\r\n            'crop_size': self.crop_size_var.get(),\r\n            'is_tta': self.is_tta_var.get(),\r\n            'is_output_image': self.is_output_image_var.get(),\r\n            'is_post_process': self.is_post_process_var.get(),\r\n            'is_high_end_process': self.is_high_end_process_var.get(),\r\n            'post_process_threshold': self.post_process_threshold_var.get(),\r\n            'vr_voc_inst_secondary_model': self.vr_voc_inst_secondary_model_var.get(),\r\n            'vr_other_secondary_model': self.vr_other_secondary_model_var.get(),\r\n            'vr_bass_secondary_model': self.vr_bass_secondary_model_var.get(),\r\n            'vr_drums_secondary_model': self.vr_drums_secondary_model_var.get(),\r\n            'vr_is_secondary_model_activate': self.vr_is_secondary_model_activate_var.get(),\r\n            'vr_voc_inst_secondary_model_scale': self.vr_voc_inst_secondary_model_scale_var.get(),\r\n            'vr_other_secondary_model_scale': self.vr_other_secondary_model_scale_var.get(),\r\n            'vr_bass_secondary_model_scale': self.vr_bass_secondary_model_scale_var.get(),\r\n            'vr_drums_secondary_model_scale': self.vr_drums_secondary_model_scale_var.get(),\r\n            'demucs_model': self.demucs_model_var.get(),\r\n            'segment': self.segment_var.get(),\r\n            'overlap': self.overlap_var.get(),\r\n            'overlap_mdx': self.overlap_mdx_var.get(),\r\n            'overlap_mdx23': self.overlap_mdx23_var.get(),\r\n            'shifts': self.shifts_var.get(),\r\n            'chunks_demucs': self.chunks_demucs_var.get(),\r\n            'margin_demucs': self.margin_demucs_var.get(),\r\n            'is_chunk_demucs': self.is_chunk_demucs_var.get(),\r\n            'is_chunk_mdxnet': self.is_chunk_mdxnet_var.get(),\r\n            'is_primary_stem_only_Demucs': self.is_primary_stem_only_Demucs_var.get(),\r\n            'is_secondary_stem_only_Demucs': self.is_secondary_stem_only_Demucs_var.get(),\r\n            'is_split_mode': self.is_split_mode_var.get(),\r\n            'is_demucs_combine_stems': self.is_demucs_combine_stems_var.get(),#\r\n            'is_mdx23_combine_stems': self.is_mdx23_combine_stems_var.get(),#\r\n            'demucs_voc_inst_secondary_model': self.demucs_voc_inst_secondary_model_var.get(),\r\n            'demucs_other_secondary_model': self.demucs_other_secondary_model_var.get(),\r\n            'demucs_bass_secondary_model': self.demucs_bass_secondary_model_var.get(),\r\n            'demucs_drums_secondary_model': self.demucs_drums_secondary_model_var.get(),\r\n            'demucs_is_secondary_model_activate': self.demucs_is_secondary_model_activate_var.get(),\r\n            'demucs_voc_inst_secondary_model_scale': self.demucs_voc_inst_secondary_model_scale_var.get(),\r\n            'demucs_other_secondary_model_scale': self.demucs_other_secondary_model_scale_var.get(),\r\n            'demucs_bass_secondary_model_scale': self.demucs_bass_secondary_model_scale_var.get(),\r\n            'demucs_drums_secondary_model_scale': self.demucs_drums_secondary_model_scale_var.get(),\r\n            'demucs_pre_proc_model': self.demucs_pre_proc_model_var.get(),\r\n            'is_demucs_pre_proc_model_activate': self.is_demucs_pre_proc_model_activate_var.get(),\r\n            'is_demucs_pre_proc_model_inst_mix': self.is_demucs_pre_proc_model_inst_mix_var.get(),\r\n            'mdx_net_model': self.mdx_net_model_var.get(),\r\n            'chunks': self.chunks_var.get(),\r\n            'margin': self.margin_var.get(),\r\n            'compensate': self.compensate_var.get(),\r\n            'denoise_option': self.denoise_option_var.get(),#\r\n            'is_match_frequency_pitch': self.is_match_frequency_pitch_var.get(),#\r\n            'phase_option': self.phase_option_var.get(),#\r\n            'phase_shifts': self.phase_shifts_var.get(),#\r\n            'is_save_align': self.is_save_align_var.get(),#\r\n            'is_match_silence': self.is_match_silence_var.get(),#\r\n            'is_spec_match': self.is_spec_match_var.get(),#\r\n            'is_mdx_c_seg_def': self.is_mdx_c_seg_def_var.get(),#\r\n            'is_invert_spec': self.is_invert_spec_var.get(),#\r\n            'is_deverb_vocals': self.is_deverb_vocals_var.get(),##, \r\n            'deverb_vocal_opt': self.deverb_vocal_opt_var.get(),#\r\n            'voc_split_save_opt': self.voc_split_save_opt_var.get(),##, \r\n            'is_mixer_mode': self.is_mixer_mode_var.get(),\r\n            'mdx_batch_size':self.mdx_batch_size_var.get(),\r\n            'mdx_voc_inst_secondary_model': self.mdx_voc_inst_secondary_model_var.get(),\r\n            'mdx_other_secondary_model': self.mdx_other_secondary_model_var.get(),\r\n            'mdx_bass_secondary_model': self.mdx_bass_secondary_model_var.get(),\r\n            'mdx_drums_secondary_model': self.mdx_drums_secondary_model_var.get(),\r\n            'mdx_is_secondary_model_activate': self.mdx_is_secondary_model_activate_var.get(),\r\n            'mdx_voc_inst_secondary_model_scale': self.mdx_voc_inst_secondary_model_scale_var.get(),\r\n            'mdx_other_secondary_model_scale': self.mdx_other_secondary_model_scale_var.get(),\r\n            'mdx_bass_secondary_model_scale': self.mdx_bass_secondary_model_scale_var.get(),\r\n            'mdx_drums_secondary_model_scale': self.mdx_drums_secondary_model_scale_var.get(),\r\n            'is_save_all_outputs_ensemble': self.is_save_all_outputs_ensemble_var.get(),\r\n            'is_append_ensemble_name': self.is_append_ensemble_name_var.get(),\r\n            'chosen_audio_tool': self.chosen_audio_tool_var.get(),\r\n            'choose_algorithm': self.choose_algorithm_var.get(),\r\n            'time_stretch_rate': self.time_stretch_rate_var.get(),\r\n            'pitch_rate': self.pitch_rate_var.get(),#\r\n            'is_time_correction': self.is_time_correction_var.get(),#\r\n            'is_gpu_conversion': self.is_gpu_conversion_var.get(),\r\n            'is_primary_stem_only': self.is_primary_stem_only_var.get(),\r\n            'is_secondary_stem_only': self.is_secondary_stem_only_var.get(),\r\n            'is_testing_audio': self.is_testing_audio_var.get(),#\r\n            'is_auto_update_model_params': self.is_auto_update_model_params_var.get(),\r\n            'is_add_model_name': self.is_add_model_name_var.get(),\r\n            'is_accept_any_input': self.is_accept_any_input_var.get(),\r\n            'is_task_complete': self.is_task_complete_var.get(),\r\n            'is_normalization': self.is_normalization_var.get(),#\r\n            'is_use_opencl': self.is_use_opencl_var.get(),#\r\n            'is_wav_ensemble': self.is_wav_ensemble_var.get(),#\r\n            'is_create_model_folder': self.is_create_model_folder_var.get(),\r\n            'mp3_bit_set': self.mp3_bit_set_var.get(),\r\n            'semitone_shift': self.semitone_shift_var.get(),#\r\n            'save_format': self.save_format_var.get(),\r\n            'wav_type_set': self.wav_type_set_var.get(),#\r\n            'device_set': self.device_set_var.get(),#\r\n            'user_code': self.user_code_var.get(),\r\n            'help_hints_var': self.help_hints_var.get(),\r\n            'set_vocal_splitter': self.set_vocal_splitter_var.get(),\r\n            'is_set_vocal_splitter': self.is_set_vocal_splitter_var.get(),#\r\n            'is_save_inst_set_vocal_splitter': self.is_save_inst_set_vocal_splitter_var.get(),#\r\n            'model_sample_mode': self.model_sample_mode_var.get(),\r\n            'model_sample_mode_duration': self.model_sample_mode_duration_var.get()\r\n            }\r\n\r\n        other_data = {\r\n            'chosen_process_method': self.chosen_process_method_var.get(),\r\n            'input_paths': self.inputPaths,\r\n            'lastDir': self.lastDir,\r\n            'export_path': self.export_path_var.get(),\r\n            'time_window': self.time_window_var.get(),\r\n            'intro_analysis': self.intro_analysis_var.get(),\r\n            'db_analysis': self.db_analysis_var.get(),\r\n            'fileOneEntry': self.fileOneEntry_var.get(),\r\n            'fileOneEntry_Full': self.fileOneEntry_Full_var.get(),\r\n            'fileTwoEntry': self.fileTwoEntry_var.get(),\r\n            'fileTwoEntry_Full': self.fileTwoEntry_Full_var.get(),\r\n            'DualBatch_inputPaths': self.DualBatch_inputPaths,\r\n            #'model_hash_table': model_hash_table,\r\n        }\r\n\r\n        user_saved_extras = {\r\n            'demucs_stems': self.demucs_stems_var.get(),\r\n            'mdx_stems': self.mdxnet_stems_var.get()}\r\n\r\n        if app_close:\r\n            save_data(data={**main_settings, **other_data})\r\n            \r\n            if self.thread_check(self.active_download_thread):\r\n                self.error_dialoge(EXIT_DOWNLOAD_ERROR)\r\n                return\r\n\r\n            if self.thread_check(self.active_processing_thread):\r\n                if self.is_process_stopped: \r\n                    self.error_dialoge(EXIT_HALTED_PROCESS_ERROR)\r\n                else:\r\n                    self.error_dialoge(EXIT_PROCESS_ERROR)\r\n                return\r\n            \r\n            remove_temps(ENSEMBLE_TEMP_PATH)\r\n            remove_temps(SAMPLE_CLIP_PATH)\r\n            self.delete_temps()\r\n            \r\n            if is_restart:\r\n                try:\r\n                    subprocess.Popen(f'UVR_Launcher.exe')\r\n                except Exception:\r\n                    subprocess.Popen(f'python \"{__file__}\"', shell=True)\r\n            \r\n            self.destroy()\r\n            \r\n        elif is_auto_save:\r\n            save_data(data={**main_settings, **other_data})\r\n        else:\r\n            return {**main_settings, **user_saved_extras}\r\n\r\n    def get_settings_list(self):\r\n        \r\n        settings_dict = self.save_values(app_close=False)\r\n        settings_list = '\\n'.join(''.join(f\"{key}: {value}\") for key, value in settings_dict.items() if not key == 'user_code')\r\n\r\n        return f\"\\n{FULL_APP_SET_TEXT}:\\n\\n{settings_list}\"\r\n\r\ndef read_bulliten_text_mac(path, data):\r\n    try:\r\n        with open(path, 'w') as f:\r\n            f.write(data)\r\n\r\n        if os.path.isfile(path):\r\n            with open(path, 'r') as file :\r\n                data = file.read().replace(\"~\", \"\")\r\n    except Exception as e:\r\n        data = 'No information available.'\r\n\r\n    return data\r\n\r\ndef open_link(event, link=None):\r\n    webbrowser.open(link)\r\n\r\ndef auto_hyperlink(text_widget:tk.Text):\r\n    content = text_widget.get('1.0', tk.END)\r\n    \r\n    # Regular expression to identify URLs\r\n    urls = re.findall(r'http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\\\\(\\\\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+', content)\r\n\r\n    for url in urls:\r\n        start_idx = content.find(url)\r\n        end_idx = start_idx + len(url)\r\n        \r\n        # Convert indices to tk.Text widget format\r\n        start_line = content.count('\\n', 0, start_idx) + 1\r\n        start_char = start_idx - content.rfind('\\n', 0, start_idx) - 1\r\n        end_line = content.count('\\n', 0, end_idx) + 1\r\n        end_char = end_idx - content.rfind('\\n', 0, end_idx) - 1\r\n\r\n        start_tag = f\"{start_line}.{start_char}\"\r\n        end_tag = f\"{end_line}.{end_char}\"\r\n\r\n        # Tag the hyperlink text and configure it\r\n        text_widget.tag_add(url, start_tag, end_tag)\r\n        text_widget.tag_configure(url, foreground=FG_COLOR, underline=True)\r\n        text_widget.tag_bind(url, \"<Button-1>\", lambda e, link=url: open_link(e, link))\r\n        text_widget.tag_bind(url, \"<Enter>\", lambda e: text_widget.config(cursor=\"hand2\"))\r\n        text_widget.tag_bind(url, \"<Leave>\", lambda e: text_widget.config(cursor=\"arrow\"))\r\n\r\ndef vip_downloads(password, link_type=VIP_REPO):\r\n    \"\"\"Attempts to decrypt VIP model link with given input code\"\"\"\r\n    \r\n    try:\r\n        kdf = PBKDF2HMAC(\r\n            algorithm=hashes.SHA256(),\r\n            length=32,\r\n            salt=link_type[0],\r\n            iterations=390000,)\r\n\r\n        key = base64.urlsafe_b64encode(kdf.derive(bytes(password, 'utf-8')))\r\n        f = Fernet(key)\r\n\r\n        return str(f.decrypt(link_type[1]), 'UTF-8')\r\n    except Exception:\r\n        return NO_CODE\r\n\r\ndef extract_stems(audio_file_base, export_path):\r\n    \r\n    filenames = [file for file in os.listdir(export_path) if file.startswith(audio_file_base)]\r\n\r\n    pattern = r'\\(([^()]+)\\)(?=[^()]*\\.wav)'\r\n    stem_list = []\r\n\r\n    for filename in filenames:\r\n        match = re.search(pattern, filename)\r\n        if match:\r\n            stem_list.append(match.group(1))\r\n            \r\n    counter = Counter(stem_list)\r\n    filtered_lst = [item for item in stem_list if counter[item] > 1]\r\n\r\n    return list(set(filtered_lst))\r\n\r\nif __name__ == \"__main__\":\r\n\r\n    try:\r\n        windll.user32.SetThreadDpiAwarenessContext(wintypes.HANDLE(-1))\r\n    except Exception as e:\r\n        if OPERATING_SYSTEM == 'Windows':\r\n            print(e)\r\n    \r\n    root = MainWindow()\r\n    root.update_checkbox_text()\r\n    root.is_root_defined_var.set(True)\r\n    root.is_check_splash = True\r\n\r\n    root.update() if is_windows else root.update_idletasks()\r\n    root.deiconify()\r\n    root.configure(bg=BG_COLOR)\r\n    root.mainloop()\r\n"
        },
        {
          "name": "__version__.py",
          "type": "blob",
          "size": 0.12890625,
          "content": "VERSION = 'v5.6.0'\r\nPATCH = 'UVR_Patch_9_29_23_1_39'\r\nPATCH_MAC = 'UVR_Patch_9_29_23_1_39'\r\nPATCH_LINUX = 'UVR_Patch_9_29_23_1_39'\r\n"
        },
        {
          "name": "demucs",
          "type": "tree",
          "content": null
        },
        {
          "name": "gui_data",
          "type": "tree",
          "content": null
        },
        {
          "name": "install_packages.sh",
          "type": "blob",
          "size": 0.0849609375,
          "content": "#!/bin/bash\n\nwhile read package; do\n    pip install \"$package\"\ndone < requirements.txt\n"
        },
        {
          "name": "lib_v5",
          "type": "tree",
          "content": null
        },
        {
          "name": "models",
          "type": "tree",
          "content": null
        },
        {
          "name": "requirements.txt",
          "type": "blob",
          "size": 0.71875,
          "content": "altgraph==0.17.3\r\naudioread==3.0.0\r\ncertifi==2022.12.07\r\ncffi==1.15.1\r\ncryptography==3.4.6\r\neinops==0.6.0\r\nfuture==0.18.3\r\njulius==0.2.7\r\nkthread==0.2.3\r\nlibrosa==0.9.2\r\nllvmlite\r\nmatchering==2.0.6\r\nml_collections==0.1.1\r\nnatsort==8.2.0\r\nomegaconf==2.2.3\r\nopencv-python==4.6.0.66\r\nPillow==9.3.0\r\npsutil==5.9.4\r\npydub==0.25.1\r\npyglet==1.5.23\r\npyperclip==1.8.2\r\npyrubberband==0.3.0\r\npytorch_lightning==2.0.0\r\nPyYAML==6.0\r\nresampy==0.4.2\r\nscipy==1.9.3\r\nsoundstretch==1.2\r\ntorch\r\nurllib3==1.26.12\r\nwget==3.2\r\nsamplerate==0.1.0\r\nscreeninfo==0.8.1\r\ndiffq\r\nplaysound\r\nonnx\r\nonnxruntime\r\nonnxruntime-gpu\r\nonnx2pytorch\r\nSoundFile==0.11.0; sys_platform != 'darwin'\r\nPySoundFile==0.9.0.post1; sys_platform == 'darwin'\r\nDora==0.0.3\r\nnumpy==1.23.5\r\n"
        },
        {
          "name": "separate.py",
          "type": "blob",
          "size": 72.2978515625,
          "content": "from __future__ import annotations\r\nfrom typing import TYPE_CHECKING\r\nfrom demucs.apply import apply_model, demucs_segments\r\nfrom demucs.hdemucs import HDemucs\r\nfrom demucs.model_v2 import auto_load_demucs_model_v2\r\nfrom demucs.pretrained import get_model as _gm\r\nfrom demucs.utils import apply_model_v1\r\nfrom demucs.utils import apply_model_v2\r\nfrom lib_v5.tfc_tdf_v3 import TFC_TDF_net, STFT\r\nfrom lib_v5 import spec_utils\r\nfrom lib_v5.vr_network import nets\r\nfrom lib_v5.vr_network import nets_new\r\nfrom lib_v5.vr_network.model_param_init import ModelParameters\r\nfrom pathlib import Path\r\nfrom gui_data.constants import *\r\nfrom gui_data.error_handling import *\r\nfrom scipy import signal\r\nimport audioread\r\nimport gzip\r\nimport librosa\r\nimport math\r\nimport numpy as np\r\nimport onnxruntime as ort\r\nimport os\r\nimport torch\r\nimport warnings\r\nimport pydub\r\nimport soundfile as sf\r\nimport lib_v5.mdxnet as MdxnetSet\r\nimport math\r\n#import random\r\nfrom onnx import load\r\nfrom onnx2pytorch import ConvertModel\r\nimport gc\r\n \r\nif TYPE_CHECKING:\r\n    from UVR import ModelData\r\n\r\n# if not is_macos:\r\n#     import torch_directml\r\n\r\nmps_available = torch.backends.mps.is_available() if is_macos else False\r\ncuda_available = torch.cuda.is_available()\r\n\r\n# def get_gpu_info():\r\n#     directml_device, directml_available = DIRECTML_DEVICE, False\r\n    \r\n#     if not is_macos:\r\n#         directml_available = torch_directml.is_available()\r\n\r\n#         if directml_available:\r\n#             directml_device = str(torch_directml.device()).partition(\":\")[0]\r\n\r\n#     return directml_device, directml_available\r\n\r\n# DIRECTML_DEVICE, directml_available = get_gpu_info()\r\n\r\ndef clear_gpu_cache():\r\n    gc.collect()\r\n    if is_macos:\r\n        torch.mps.empty_cache()\r\n    else:\r\n        torch.cuda.empty_cache()\r\n\r\nwarnings.filterwarnings(\"ignore\")\r\ncpu = torch.device('cpu')\r\n\r\nclass SeperateAttributes:\r\n    def __init__(self, model_data: ModelData, \r\n                 process_data: dict, \r\n                 main_model_primary_stem_4_stem=None, \r\n                 main_process_method=None, \r\n                 is_return_dual=True, \r\n                 main_model_primary=None, \r\n                 vocal_stem_path=None, \r\n                 master_inst_source=None,\r\n                 master_vocal_source=None):\r\n        \r\n        self.list_all_models: list\r\n        self.process_data = process_data\r\n        self.progress_value = 0\r\n        self.set_progress_bar = process_data['set_progress_bar']\r\n        self.write_to_console = process_data['write_to_console']\r\n        if vocal_stem_path:\r\n            self.audio_file, self.audio_file_base = vocal_stem_path\r\n            self.audio_file_base_voc_split = lambda stem, split:os.path.join(self.export_path, f'{self.audio_file_base.replace(\"_(Vocals)\", \"\")}_({stem}_{split}).wav')\r\n        else:\r\n            self.audio_file = process_data['audio_file']\r\n            self.audio_file_base = process_data['audio_file_base']\r\n            self.audio_file_base_voc_split = None\r\n        self.export_path = process_data['export_path']\r\n        self.cached_source_callback = process_data['cached_source_callback']\r\n        self.cached_model_source_holder = process_data['cached_model_source_holder']\r\n        self.is_4_stem_ensemble = process_data['is_4_stem_ensemble']\r\n        self.list_all_models = process_data['list_all_models']\r\n        self.process_iteration = process_data['process_iteration']\r\n        self.is_return_dual = is_return_dual\r\n        self.is_pitch_change = model_data.is_pitch_change\r\n        self.semitone_shift = model_data.semitone_shift\r\n        self.is_match_frequency_pitch = model_data.is_match_frequency_pitch\r\n        self.overlap = model_data.overlap\r\n        self.overlap_mdx = model_data.overlap_mdx\r\n        self.overlap_mdx23 = model_data.overlap_mdx23\r\n        self.is_mdx_combine_stems = model_data.is_mdx_combine_stems\r\n        self.is_mdx_c = model_data.is_mdx_c\r\n        self.mdx_c_configs = model_data.mdx_c_configs\r\n        self.mdxnet_stem_select = model_data.mdxnet_stem_select\r\n        self.mixer_path = model_data.mixer_path\r\n        self.model_samplerate = model_data.model_samplerate\r\n        self.model_capacity = model_data.model_capacity\r\n        self.is_vr_51_model = model_data.is_vr_51_model\r\n        self.is_pre_proc_model = model_data.is_pre_proc_model\r\n        self.is_secondary_model_activated = model_data.is_secondary_model_activated if not self.is_pre_proc_model else False\r\n        self.is_secondary_model = model_data.is_secondary_model if not self.is_pre_proc_model else True\r\n        self.process_method = model_data.process_method\r\n        self.model_path = model_data.model_path\r\n        self.model_name = model_data.model_name\r\n        self.model_basename = model_data.model_basename\r\n        self.wav_type_set = model_data.wav_type_set\r\n        self.mp3_bit_set = model_data.mp3_bit_set\r\n        self.save_format = model_data.save_format\r\n        self.is_gpu_conversion = model_data.is_gpu_conversion\r\n        self.is_normalization = model_data.is_normalization\r\n        self.is_primary_stem_only = model_data.is_primary_stem_only if not self.is_secondary_model else model_data.is_primary_model_primary_stem_only\r\n        self.is_secondary_stem_only = model_data.is_secondary_stem_only if not self.is_secondary_model else model_data.is_primary_model_secondary_stem_only      \r\n        self.is_ensemble_mode = model_data.is_ensemble_mode\r\n        self.secondary_model = model_data.secondary_model #\r\n        self.primary_model_primary_stem = model_data.primary_model_primary_stem\r\n        self.primary_stem_native = model_data.primary_stem_native\r\n        self.primary_stem = model_data.primary_stem #\r\n        self.secondary_stem = model_data.secondary_stem #\r\n        self.is_invert_spec = model_data.is_invert_spec #\r\n        self.is_deverb_vocals = model_data.is_deverb_vocals\r\n        self.is_mixer_mode = model_data.is_mixer_mode #\r\n        self.secondary_model_scale = model_data.secondary_model_scale #\r\n        self.is_demucs_pre_proc_model_inst_mix = model_data.is_demucs_pre_proc_model_inst_mix #\r\n        self.primary_source_map = {}\r\n        self.secondary_source_map = {}\r\n        self.primary_source = None\r\n        self.secondary_source = None\r\n        self.secondary_source_primary = None\r\n        self.secondary_source_secondary = None\r\n        self.main_model_primary_stem_4_stem = main_model_primary_stem_4_stem\r\n        self.main_model_primary = main_model_primary\r\n        self.ensemble_primary_stem = model_data.ensemble_primary_stem\r\n        self.is_multi_stem_ensemble = model_data.is_multi_stem_ensemble\r\n        self.is_other_gpu = False\r\n        self.is_deverb = True\r\n        self.DENOISER_MODEL = model_data.DENOISER_MODEL\r\n        self.DEVERBER_MODEL = model_data.DEVERBER_MODEL\r\n        self.is_source_swap = False\r\n        self.vocal_split_model = model_data.vocal_split_model\r\n        self.is_vocal_split_model = model_data.is_vocal_split_model\r\n        self.master_vocal_path = None\r\n        self.set_master_inst_source = None\r\n        self.master_inst_source = master_inst_source\r\n        self.master_vocal_source = master_vocal_source\r\n        self.is_save_inst_vocal_splitter = isinstance(master_inst_source, np.ndarray) and model_data.is_save_inst_vocal_splitter\r\n        self.is_inst_only_voc_splitter = model_data.is_inst_only_voc_splitter\r\n        self.is_karaoke = model_data.is_karaoke\r\n        self.is_bv_model = model_data.is_bv_model\r\n        self.is_bv_model_rebalenced = model_data.bv_model_rebalance and self.is_vocal_split_model\r\n        self.is_sec_bv_rebalance = model_data.is_sec_bv_rebalance\r\n        self.stem_path_init = os.path.join(self.export_path, f'{self.audio_file_base}_({self.secondary_stem}).wav')\r\n        self.deverb_vocal_opt = model_data.deverb_vocal_opt\r\n        self.is_save_vocal_only = model_data.is_save_vocal_only\r\n        self.device = cpu\r\n        self.run_type = ['CPUExecutionProvider']\r\n        self.is_opencl = False\r\n        self.device_set = model_data.device_set\r\n        self.is_use_opencl = model_data.is_use_opencl\r\n        \r\n        if self.is_inst_only_voc_splitter or self.is_sec_bv_rebalance:\r\n            self.is_primary_stem_only = False\r\n            self.is_secondary_stem_only = False\r\n        \r\n        if main_model_primary and self.is_multi_stem_ensemble:\r\n            self.primary_stem, self.secondary_stem = main_model_primary, secondary_stem(main_model_primary)\r\n\r\n        if self.is_gpu_conversion >= 0:\r\n            if mps_available:\r\n                self.device, self.is_other_gpu = 'mps', True\r\n            else:\r\n                device_prefix = None\r\n                if self.device_set != DEFAULT:\r\n                    device_prefix = CUDA_DEVICE#DIRECTML_DEVICE if self.is_use_opencl and directml_available else CUDA_DEVICE\r\n\r\n                # if directml_available and self.is_use_opencl:\r\n                #     self.device = torch_directml.device() if not device_prefix else f'{device_prefix}:{self.device_set}'\r\n                #     self.is_other_gpu = True\r\n                if cuda_available:# and not self.is_use_opencl:\r\n                    self.device = CUDA_DEVICE if not device_prefix else f'{device_prefix}:{self.device_set}'\r\n                    self.run_type = ['CUDAExecutionProvider']\r\n\r\n        if model_data.process_method == MDX_ARCH_TYPE:\r\n            self.is_mdx_ckpt = model_data.is_mdx_ckpt\r\n            self.primary_model_name, self.primary_sources = self.cached_source_callback(MDX_ARCH_TYPE, model_name=self.model_basename)\r\n            self.is_denoise = model_data.is_denoise#\r\n            self.is_denoise_model = model_data.is_denoise_model#\r\n            self.is_mdx_c_seg_def = model_data.is_mdx_c_seg_def#\r\n            self.mdx_batch_size = model_data.mdx_batch_size\r\n            self.compensate = model_data.compensate\r\n            self.mdx_segment_size = model_data.mdx_segment_size\r\n            \r\n            if self.is_mdx_c:\r\n                if not self.is_4_stem_ensemble:\r\n                    self.primary_stem = model_data.ensemble_primary_stem if process_data['is_ensemble_master'] else model_data.primary_stem\r\n                    self.secondary_stem = model_data.ensemble_secondary_stem if process_data['is_ensemble_master'] else model_data.secondary_stem\r\n            else:\r\n                self.dim_f, self.dim_t = model_data.mdx_dim_f_set, 2**model_data.mdx_dim_t_set\r\n                \r\n            self.check_label_secondary_stem_runs()\r\n            self.n_fft = model_data.mdx_n_fft_scale_set\r\n            self.chunks = model_data.chunks\r\n            self.margin = model_data.margin\r\n            self.adjust = 1\r\n            self.dim_c = 4\r\n            self.hop = 1024\r\n\r\n        if model_data.process_method == DEMUCS_ARCH_TYPE:\r\n            self.demucs_stems = model_data.demucs_stems if not main_process_method in [MDX_ARCH_TYPE, VR_ARCH_TYPE] else None\r\n            self.secondary_model_4_stem = model_data.secondary_model_4_stem\r\n            self.secondary_model_4_stem_scale = model_data.secondary_model_4_stem_scale\r\n            self.is_chunk_demucs = model_data.is_chunk_demucs\r\n            self.segment = model_data.segment\r\n            self.demucs_version = model_data.demucs_version\r\n            self.demucs_source_list = model_data.demucs_source_list\r\n            self.demucs_source_map = model_data.demucs_source_map\r\n            self.is_demucs_combine_stems = model_data.is_demucs_combine_stems\r\n            self.demucs_stem_count = model_data.demucs_stem_count\r\n            self.pre_proc_model = model_data.pre_proc_model\r\n            self.device = cpu if self.is_other_gpu and not self.demucs_version in [DEMUCS_V3, DEMUCS_V4] else self.device\r\n\r\n            self.primary_stem = model_data.ensemble_primary_stem if process_data['is_ensemble_master'] else model_data.primary_stem\r\n            self.secondary_stem = model_data.ensemble_secondary_stem if process_data['is_ensemble_master'] else model_data.secondary_stem\r\n\r\n            if (self.is_multi_stem_ensemble or self.is_4_stem_ensemble) and not self.is_secondary_model:\r\n                self.is_return_dual = False\r\n            \r\n            if self.is_multi_stem_ensemble and main_model_primary:\r\n                self.is_4_stem_ensemble = False\r\n                if main_model_primary in self.demucs_source_map.keys():\r\n                    self.primary_stem = main_model_primary\r\n                    self.secondary_stem = secondary_stem(main_model_primary)\r\n                elif secondary_stem(main_model_primary) in self.demucs_source_map.keys():\r\n                    self.primary_stem = secondary_stem(main_model_primary)\r\n                    self.secondary_stem = main_model_primary\r\n\r\n            if self.is_secondary_model and not process_data['is_ensemble_master']:\r\n                if not self.demucs_stem_count == 2 and model_data.primary_model_primary_stem == INST_STEM:\r\n                    self.primary_stem = VOCAL_STEM\r\n                    self.secondary_stem = INST_STEM\r\n                else:\r\n                    self.primary_stem = model_data.primary_model_primary_stem\r\n                    self.secondary_stem = secondary_stem(self.primary_stem)\r\n\r\n            self.shifts = model_data.shifts\r\n            self.is_split_mode = model_data.is_split_mode if not self.demucs_version == DEMUCS_V4 else True\r\n            self.primary_model_name, self.primary_sources = self.cached_source_callback(DEMUCS_ARCH_TYPE, model_name=self.model_basename)\r\n\r\n        if model_data.process_method == VR_ARCH_TYPE:\r\n            self.check_label_secondary_stem_runs()\r\n            self.primary_model_name, self.primary_sources = self.cached_source_callback(VR_ARCH_TYPE, model_name=self.model_basename)\r\n            self.mp = model_data.vr_model_param\r\n            self.high_end_process = model_data.is_high_end_process\r\n            self.is_tta = model_data.is_tta\r\n            self.is_post_process = model_data.is_post_process\r\n            self.is_gpu_conversion = model_data.is_gpu_conversion\r\n            self.batch_size = model_data.batch_size\r\n            self.window_size = model_data.window_size\r\n            self.input_high_end_h = None\r\n            self.input_high_end = None\r\n            self.post_process_threshold = model_data.post_process_threshold\r\n            self.aggressiveness = {'value': model_data.aggression_setting, \r\n                                   'split_bin': self.mp.param['band'][1]['crop_stop'], \r\n                                   'aggr_correction': self.mp.param.get('aggr_correction')}\r\n            \r\n    def check_label_secondary_stem_runs(self):\r\n\r\n        # For ensemble master that's not a 4-stem ensemble, and not mdx_c\r\n        if self.process_data['is_ensemble_master'] and not self.is_4_stem_ensemble and not self.is_mdx_c:\r\n            if self.ensemble_primary_stem != self.primary_stem:\r\n                self.is_primary_stem_only, self.is_secondary_stem_only = self.is_secondary_stem_only, self.is_primary_stem_only\r\n            \r\n        # For secondary models\r\n        if self.is_pre_proc_model or self.is_secondary_model:\r\n            self.is_primary_stem_only = False\r\n            self.is_secondary_stem_only = False\r\n            \r\n    def start_inference_console_write(self):\r\n        if self.is_secondary_model and not self.is_pre_proc_model and not self.is_vocal_split_model:\r\n            self.write_to_console(INFERENCE_STEP_2_SEC(self.process_method, self.model_basename))\r\n        \r\n        if self.is_pre_proc_model:\r\n            self.write_to_console(INFERENCE_STEP_2_PRE(self.process_method, self.model_basename))\r\n            \r\n        if self.is_vocal_split_model:\r\n            self.write_to_console(INFERENCE_STEP_2_VOC_S(self.process_method, self.model_basename))\r\n        \r\n    def running_inference_console_write(self, is_no_write=False):\r\n        self.write_to_console(DONE, base_text='') if not is_no_write else None\r\n        self.set_progress_bar(0.05) if not is_no_write else None\r\n        \r\n        if self.is_secondary_model and not self.is_pre_proc_model and not self.is_vocal_split_model:\r\n            self.write_to_console(INFERENCE_STEP_1_SEC)\r\n        elif self.is_pre_proc_model:\r\n            self.write_to_console(INFERENCE_STEP_1_PRE)\r\n        elif self.is_vocal_split_model:\r\n            self.write_to_console(INFERENCE_STEP_1_VOC_S)\r\n        else:\r\n            self.write_to_console(INFERENCE_STEP_1)\r\n        \r\n    def running_inference_progress_bar(self, length, is_match_mix=False):\r\n        if not is_match_mix:\r\n            self.progress_value += 1\r\n\r\n            if (0.8/length*self.progress_value) >= 0.8:\r\n                length = self.progress_value + 1\r\n  \r\n            self.set_progress_bar(0.1, (0.8/length*self.progress_value))\r\n        \r\n    def load_cached_sources(self):\r\n        \r\n        if self.is_secondary_model and not self.is_pre_proc_model:\r\n            self.write_to_console(INFERENCE_STEP_2_SEC_CACHED_MODOEL(self.process_method, self.model_basename))\r\n        elif self.is_pre_proc_model:\r\n            self.write_to_console(INFERENCE_STEP_2_PRE_CACHED_MODOEL(self.process_method, self.model_basename))\r\n        else:\r\n            self.write_to_console(INFERENCE_STEP_2_PRIMARY_CACHED, \"\")\r\n            \r\n    def cache_source(self, secondary_sources):\r\n        \r\n        model_occurrences = self.list_all_models.count(self.model_basename)\r\n        \r\n        if not model_occurrences <= 1:\r\n            if self.process_method == MDX_ARCH_TYPE:\r\n                self.cached_model_source_holder(MDX_ARCH_TYPE, secondary_sources, self.model_basename)\r\n                \r\n            if self.process_method == VR_ARCH_TYPE:\r\n                self.cached_model_source_holder(VR_ARCH_TYPE, secondary_sources, self.model_basename)\r\n\r\n            if self.process_method == DEMUCS_ARCH_TYPE:\r\n                self.cached_model_source_holder(DEMUCS_ARCH_TYPE, secondary_sources, self.model_basename)\r\n           \r\n    def process_vocal_split_chain(self, sources: dict):\r\n        \r\n        def is_valid_vocal_split_condition(master_vocal_source):\r\n            \"\"\"Checks if conditions for vocal split processing are met.\"\"\"\r\n            conditions = [\r\n                isinstance(master_vocal_source, np.ndarray),\r\n                self.vocal_split_model,\r\n                not self.is_ensemble_mode,\r\n                not self.is_karaoke,\r\n                not self.is_bv_model\r\n            ]\r\n            return all(conditions)\r\n        \r\n        # Retrieve sources from the dictionary with default fallbacks\r\n        master_inst_source = sources.get(INST_STEM, None)\r\n        master_vocal_source = sources.get(VOCAL_STEM, None)\r\n\r\n        # Process the vocal split chain if conditions are met\r\n        if is_valid_vocal_split_condition(master_vocal_source):\r\n            process_chain_model(\r\n                self.vocal_split_model,\r\n                self.process_data,\r\n                vocal_stem_path=self.master_vocal_path,\r\n                master_vocal_source=master_vocal_source,\r\n                master_inst_source=master_inst_source\r\n            )\r\n  \r\n    def process_secondary_stem(self, stem_source, secondary_model_source=None, model_scale=None):\r\n        if not self.is_secondary_model:\r\n            if self.is_secondary_model_activated and isinstance(secondary_model_source, np.ndarray):\r\n                secondary_model_scale = model_scale if model_scale else self.secondary_model_scale\r\n                stem_source = spec_utils.average_dual_sources(stem_source, secondary_model_source, secondary_model_scale)\r\n  \r\n        return stem_source\r\n    \r\n    def final_process(self, stem_path, source, secondary_source, stem_name, samplerate):\r\n        source = self.process_secondary_stem(source, secondary_source)\r\n        self.write_audio(stem_path, source, samplerate, stem_name=stem_name)\r\n        \r\n        return {stem_name: source}\r\n    \r\n    def write_audio(self, stem_path: str, stem_source, samplerate, stem_name=None):\r\n        \r\n        def save_audio_file(path, source):\r\n            source = spec_utils.normalize(source, self.is_normalization)\r\n            sf.write(path, source, samplerate, subtype=self.wav_type_set)\r\n\r\n            if is_not_ensemble:\r\n                save_format(path, self.save_format, self.mp3_bit_set)\r\n\r\n        def save_voc_split_instrumental(stem_name, stem_source, is_inst_invert=False):\r\n            inst_stem_name = \"Instrumental (With Lead Vocals)\" if stem_name == LEAD_VOCAL_STEM else \"Instrumental (With Backing Vocals)\"\r\n            inst_stem_path_name = LEAD_VOCAL_STEM_I if stem_name == LEAD_VOCAL_STEM else BV_VOCAL_STEM_I\r\n            inst_stem_path = self.audio_file_base_voc_split(INST_STEM, inst_stem_path_name)\r\n            stem_source = -stem_source if is_inst_invert else stem_source\r\n            inst_stem_source = spec_utils.combine_arrarys([self.master_inst_source, stem_source], is_swap=True)\r\n            save_with_message(inst_stem_path, inst_stem_name, inst_stem_source)\r\n\r\n        def save_voc_split_vocal(stem_name, stem_source):\r\n            voc_split_stem_name = LEAD_VOCAL_STEM_LABEL if stem_name == LEAD_VOCAL_STEM else BV_VOCAL_STEM_LABEL\r\n            voc_split_stem_path = self.audio_file_base_voc_split(VOCAL_STEM, stem_name)\r\n            save_with_message(voc_split_stem_path, voc_split_stem_name, stem_source)\r\n\r\n        def save_with_message(stem_path, stem_name, stem_source):\r\n            is_deverb = self.is_deverb_vocals and (\r\n                self.deverb_vocal_opt == stem_name or\r\n                (self.deverb_vocal_opt == 'ALL' and \r\n                (stem_name == VOCAL_STEM or stem_name == LEAD_VOCAL_STEM_LABEL or stem_name == BV_VOCAL_STEM_LABEL)))\r\n\r\n            self.write_to_console(f'{SAVING_STEM[0]}{stem_name}{SAVING_STEM[1]}')\r\n            \r\n            if is_deverb and is_not_ensemble:\r\n                deverb_vocals(stem_path, stem_source)\r\n            \r\n            save_audio_file(stem_path, stem_source)\r\n            self.write_to_console(DONE, base_text='')\r\n            \r\n        def deverb_vocals(stem_path:str, stem_source):\r\n            self.write_to_console(INFERENCE_STEP_DEVERBING, base_text='')\r\n            stem_source_deverbed, stem_source_2 = vr_denoiser(stem_source, self.device, is_deverber=True, model_path=self.DEVERBER_MODEL)\r\n            save_audio_file(stem_path.replace(\".wav\", \"_deverbed.wav\"), stem_source_deverbed)\r\n            save_audio_file(stem_path.replace(\".wav\", \"_reverb_only.wav\"), stem_source_2)\r\n            \r\n        is_bv_model_lead = (self.is_bv_model_rebalenced and self.is_vocal_split_model and stem_name == LEAD_VOCAL_STEM)\r\n        is_bv_rebalance_lead = (self.is_bv_model_rebalenced and self.is_vocal_split_model and stem_name == BV_VOCAL_STEM)\r\n        is_no_vocal_save = self.is_inst_only_voc_splitter and (stem_name == VOCAL_STEM or stem_name == BV_VOCAL_STEM or stem_name == LEAD_VOCAL_STEM) or is_bv_model_lead\r\n        is_not_ensemble = (not self.is_ensemble_mode or self.is_vocal_split_model)\r\n        is_do_not_save_inst = (self.is_save_vocal_only and self.is_sec_bv_rebalance and stem_name == INST_STEM)\r\n\r\n        if is_bv_rebalance_lead:\r\n            master_voc_source = spec_utils.match_array_shapes(self.master_vocal_source, stem_source, is_swap=True)\r\n            bv_rebalance_lead_source = stem_source-master_voc_source\r\n            \r\n        if not is_bv_model_lead and not is_do_not_save_inst:\r\n            if self.is_vocal_split_model or not self.is_secondary_model:\r\n                if self.is_vocal_split_model and not self.is_inst_only_voc_splitter:\r\n                    save_voc_split_vocal(stem_name, stem_source)\r\n                    if is_bv_rebalance_lead:\r\n                        save_voc_split_vocal(LEAD_VOCAL_STEM, bv_rebalance_lead_source)\r\n                else:\r\n                    if not is_no_vocal_save:\r\n                        save_with_message(stem_path, stem_name, stem_source)\r\n                    \r\n                if self.is_save_inst_vocal_splitter and not self.is_save_vocal_only:\r\n                    save_voc_split_instrumental(stem_name, stem_source)\r\n                    if is_bv_rebalance_lead:\r\n                        save_voc_split_instrumental(LEAD_VOCAL_STEM, bv_rebalance_lead_source, is_inst_invert=True)\r\n\r\n                self.set_progress_bar(0.95)\r\n\r\n        if stem_name == VOCAL_STEM:\r\n            self.master_vocal_path = stem_path\r\n\r\n    def pitch_fix(self, source, sr_pitched, org_mix):\r\n        semitone_shift = self.semitone_shift\r\n        source = spec_utils.change_pitch_semitones(source, sr_pitched, semitone_shift=semitone_shift)[0]\r\n        source = spec_utils.match_array_shapes(source, org_mix)\r\n        return source\r\n    \r\n    def match_frequency_pitch(self, mix):\r\n        source = mix\r\n        if self.is_match_frequency_pitch and self.is_pitch_change:\r\n            source, sr_pitched = spec_utils.change_pitch_semitones(mix, 44100, semitone_shift=-self.semitone_shift)\r\n            source = self.pitch_fix(source, sr_pitched, mix)\r\n\r\n        return source\r\n\r\nclass SeperateMDX(SeperateAttributes):        \r\n\r\n    def seperate(self):\r\n        samplerate = 44100\r\n    \r\n        if self.primary_model_name == self.model_basename and isinstance(self.primary_sources, tuple):\r\n            mix, source = self.primary_sources\r\n            self.load_cached_sources()\r\n        else:\r\n            self.start_inference_console_write()\r\n\r\n            if self.is_mdx_ckpt:\r\n                model_params = torch.load(self.model_path, map_location=lambda storage, loc: storage)['hyper_parameters']\r\n                self.dim_c, self.hop = model_params['dim_c'], model_params['hop_length']\r\n                separator = MdxnetSet.ConvTDFNet(**model_params)\r\n                self.model_run = separator.load_from_checkpoint(self.model_path).to(self.device).eval()\r\n            else:\r\n                if self.mdx_segment_size == self.dim_t and not self.is_other_gpu:\r\n                    ort_ = ort.InferenceSession(self.model_path, providers=self.run_type)\r\n                    self.model_run = lambda spek:ort_.run(None, {'input': spek.cpu().numpy()})[0]\r\n                else:\r\n                    self.model_run = ConvertModel(load(self.model_path))\r\n                    self.model_run.to(self.device).eval()\r\n\r\n            self.running_inference_console_write()\r\n            mix = prepare_mix(self.audio_file)\r\n            \r\n            source = self.demix(mix)\r\n            \r\n            if not self.is_vocal_split_model:\r\n                self.cache_source((mix, source))\r\n            self.write_to_console(DONE, base_text='')            \r\n\r\n        mdx_net_cut = True if self.primary_stem in MDX_NET_FREQ_CUT and self.is_match_frequency_pitch else False\r\n\r\n        if self.is_secondary_model_activated and self.secondary_model:\r\n            self.secondary_source_primary, self.secondary_source_secondary = process_secondary_model(self.secondary_model, self.process_data, main_process_method=self.process_method, main_model_primary=self.primary_stem)\r\n        \r\n        if not self.is_primary_stem_only:\r\n            secondary_stem_path = os.path.join(self.export_path, f'{self.audio_file_base}_({self.secondary_stem}).wav')\r\n            if not isinstance(self.secondary_source, np.ndarray):\r\n                raw_mix = self.demix(self.match_frequency_pitch(mix), is_match_mix=True) if mdx_net_cut else self.match_frequency_pitch(mix)\r\n                self.secondary_source = spec_utils.invert_stem(raw_mix, source) if self.is_invert_spec else mix.T-source.T\r\n            \r\n            self.secondary_source_map = self.final_process(secondary_stem_path, self.secondary_source, self.secondary_source_secondary, self.secondary_stem, samplerate)\r\n        \r\n        if not self.is_secondary_stem_only:\r\n            primary_stem_path = os.path.join(self.export_path, f'{self.audio_file_base}_({self.primary_stem}).wav')\r\n\r\n            if not isinstance(self.primary_source, np.ndarray):\r\n                self.primary_source = source.T\r\n                \r\n            self.primary_source_map = self.final_process(primary_stem_path, self.primary_source, self.secondary_source_primary, self.primary_stem, samplerate)\r\n        \r\n        clear_gpu_cache()\r\n\r\n        secondary_sources = {**self.primary_source_map, **self.secondary_source_map}\r\n        \r\n        self.process_vocal_split_chain(secondary_sources)\r\n\r\n        if self.is_secondary_model or self.is_pre_proc_model:\r\n            return secondary_sources\r\n\r\n    def initialize_model_settings(self):\r\n        self.n_bins = self.n_fft//2+1\r\n        self.trim = self.n_fft//2\r\n        self.chunk_size = self.hop * (self.mdx_segment_size-1)\r\n        self.gen_size = self.chunk_size-2*self.trim\r\n        self.stft = STFT(self.n_fft, self.hop, self.dim_f, self.device)\r\n\r\n    def demix(self, mix, is_match_mix=False):\r\n        self.initialize_model_settings()\r\n        \r\n        org_mix = mix\r\n        tar_waves_ = []\r\n\r\n        if is_match_mix:\r\n            chunk_size = self.hop * (256-1)\r\n            overlap = 0.02\r\n        else:\r\n            chunk_size = self.chunk_size\r\n            overlap = self.overlap_mdx\r\n            \r\n            if self.is_pitch_change:\r\n                mix, sr_pitched = spec_utils.change_pitch_semitones(mix, 44100, semitone_shift=-self.semitone_shift)\r\n\r\n        gen_size = chunk_size-2*self.trim\r\n\r\n        pad = gen_size + self.trim - ((mix.shape[-1]) % gen_size)\r\n        mixture = np.concatenate((np.zeros((2, self.trim), dtype='float32'), mix, np.zeros((2, pad), dtype='float32')), 1)\r\n\r\n        step = self.chunk_size - self.n_fft if overlap == DEFAULT else int((1 - overlap) * chunk_size)\r\n        result = np.zeros((1, 2, mixture.shape[-1]), dtype=np.float32)\r\n        divider = np.zeros((1, 2, mixture.shape[-1]), dtype=np.float32)\r\n        total = 0\r\n        total_chunks = (mixture.shape[-1] + step - 1) // step\r\n\r\n        for i in range(0, mixture.shape[-1], step):\r\n            total += 1\r\n            start = i\r\n            end = min(i + chunk_size, mixture.shape[-1])\r\n\r\n            chunk_size_actual = end - start\r\n\r\n            if overlap == 0:\r\n                window = None\r\n            else:\r\n                window = np.hanning(chunk_size_actual)\r\n                window = np.tile(window[None, None, :], (1, 2, 1))\r\n\r\n            mix_part_ = mixture[:, start:end]\r\n            if end != i + chunk_size:\r\n                pad_size = (i + chunk_size) - end\r\n                mix_part_ = np.concatenate((mix_part_, np.zeros((2, pad_size), dtype='float32')), axis=-1)\r\n\r\n            mix_part = torch.tensor([mix_part_], dtype=torch.float32).to(self.device)\r\n            mix_waves = mix_part.split(self.mdx_batch_size)\r\n            \r\n            with torch.no_grad():\r\n                for mix_wave in mix_waves:\r\n                    self.running_inference_progress_bar(total_chunks, is_match_mix=is_match_mix)\r\n\r\n                    tar_waves = self.run_model(mix_wave, is_match_mix=is_match_mix)\r\n                    \r\n                    if window is not None:\r\n                        tar_waves[..., :chunk_size_actual] *= window \r\n                        divider[..., start:end] += window\r\n                    else:\r\n                        divider[..., start:end] += 1\r\n\r\n                    result[..., start:end] += tar_waves[..., :end-start]\r\n            \r\n        tar_waves = result / divider\r\n        tar_waves_.append(tar_waves)\r\n\r\n        tar_waves_ = np.vstack(tar_waves_)[:, :, self.trim:-self.trim]\r\n        tar_waves = np.concatenate(tar_waves_, axis=-1)[:, :mix.shape[-1]]\r\n        \r\n        source = tar_waves[:,0:None]\r\n\r\n        if self.is_pitch_change and not is_match_mix:\r\n            source = self.pitch_fix(source, sr_pitched, org_mix)\r\n\r\n        source = source if is_match_mix else source*self.compensate\r\n\r\n        if self.is_denoise_model and not is_match_mix:\r\n            if NO_STEM in self.primary_stem_native or self.primary_stem_native == INST_STEM:\r\n                if org_mix.shape[1] != source.shape[1]:\r\n                    source = spec_utils.match_array_shapes(source, org_mix)\r\n                source = org_mix - vr_denoiser(org_mix-source, self.device, model_path=self.DENOISER_MODEL)\r\n            else:\r\n                source = vr_denoiser(source, self.device, model_path=self.DENOISER_MODEL)\r\n\r\n        return source\r\n\r\n    def run_model(self, mix, is_match_mix=False):\r\n        \r\n        spek = self.stft(mix.to(self.device))*self.adjust\r\n        spek[:, :, :3, :] *= 0 \r\n\r\n        if is_match_mix:\r\n            spec_pred = spek.cpu().numpy()\r\n        else:\r\n            spec_pred = -self.model_run(-spek)*0.5+self.model_run(spek)*0.5 if self.is_denoise else self.model_run(spek)\r\n\r\n        return self.stft.inverse(torch.tensor(spec_pred).to(self.device)).cpu().detach().numpy()\r\n\r\nclass SeperateMDXC(SeperateAttributes):        \r\n\r\n    def seperate(self):\r\n        samplerate = 44100\r\n        sources = None\r\n\r\n        if self.primary_model_name == self.model_basename and isinstance(self.primary_sources, tuple):\r\n            mix, sources = self.primary_sources\r\n            self.load_cached_sources()\r\n        else:\r\n            self.start_inference_console_write()\r\n            self.running_inference_console_write()\r\n            mix = prepare_mix(self.audio_file)\r\n            sources = self.demix(mix)\r\n            if not self.is_vocal_split_model:\r\n                self.cache_source((mix, sources))\r\n            self.write_to_console(DONE, base_text='')\r\n\r\n        stem_list = [self.mdx_c_configs.training.target_instrument] if self.mdx_c_configs.training.target_instrument else [i for i in self.mdx_c_configs.training.instruments]\r\n\r\n        if self.is_secondary_model:\r\n            if self.is_pre_proc_model:\r\n                self.mdxnet_stem_select = stem_list[0]\r\n            else:\r\n                self.mdxnet_stem_select = self.main_model_primary_stem_4_stem if self.main_model_primary_stem_4_stem else self.primary_model_primary_stem\r\n            self.primary_stem = self.mdxnet_stem_select\r\n            self.secondary_stem = secondary_stem(self.mdxnet_stem_select)\r\n            self.is_primary_stem_only, self.is_secondary_stem_only = False, False\r\n\r\n        is_all_stems = self.mdxnet_stem_select == ALL_STEMS\r\n        is_not_ensemble_master = not self.process_data['is_ensemble_master']\r\n        is_not_single_stem = not len(stem_list) <= 2\r\n        is_not_secondary_model = not self.is_secondary_model\r\n        is_ensemble_4_stem = self.is_4_stem_ensemble and is_not_single_stem\r\n\r\n        if (is_all_stems and is_not_ensemble_master and is_not_single_stem and is_not_secondary_model) or is_ensemble_4_stem and not self.is_pre_proc_model:\r\n            for stem in stem_list:\r\n                primary_stem_path = os.path.join(self.export_path, f'{self.audio_file_base}_({stem}).wav')\r\n                self.primary_source = sources[stem].T\r\n                self.write_audio(primary_stem_path, self.primary_source, samplerate, stem_name=stem)\r\n                \r\n                if stem == VOCAL_STEM and not self.is_sec_bv_rebalance:\r\n                    self.process_vocal_split_chain({VOCAL_STEM:stem})\r\n        else:\r\n            if len(stem_list) == 1:\r\n                source_primary = sources  \r\n            else:\r\n                source_primary = sources[stem_list[0]] if self.is_multi_stem_ensemble and len(stem_list) == 2 else sources[self.mdxnet_stem_select]\r\n            if self.is_secondary_model_activated and self.secondary_model:\r\n                self.secondary_source_primary, self.secondary_source_secondary = process_secondary_model(self.secondary_model, \r\n                                                                                                         self.process_data, \r\n                                                                                                         main_process_method=self.process_method, \r\n                                                                                                         main_model_primary=self.primary_stem)\r\n\r\n            if not self.is_primary_stem_only:\r\n                secondary_stem_path = os.path.join(self.export_path, f'{self.audio_file_base}_({self.secondary_stem}).wav')\r\n                if not isinstance(self.secondary_source, np.ndarray):\r\n                    \r\n                    if self.is_mdx_combine_stems and len(stem_list) >= 2:\r\n                        if len(stem_list) == 2:\r\n                            secondary_source = sources[self.secondary_stem]\r\n                        else:\r\n                            sources.pop(self.primary_stem)\r\n                            next_stem = next(iter(sources))\r\n                            secondary_source = np.zeros_like(sources[next_stem])\r\n                            for v in sources.values():\r\n                                secondary_source += v\r\n                                \r\n                        self.secondary_source = secondary_source.T \r\n                    else:\r\n                        self.secondary_source, raw_mix = source_primary, self.match_frequency_pitch(mix)\r\n                        self.secondary_source = spec_utils.to_shape(self.secondary_source, raw_mix.shape)\r\n                    \r\n                        if self.is_invert_spec:\r\n                            self.secondary_source = spec_utils.invert_stem(raw_mix, self.secondary_source)\r\n                        else:\r\n                            self.secondary_source = (-self.secondary_source.T+raw_mix.T)\r\n                            \r\n                self.secondary_source_map = self.final_process(secondary_stem_path, self.secondary_source, self.secondary_source_secondary, self.secondary_stem, samplerate)    \r\n\r\n            if not self.is_secondary_stem_only:\r\n                primary_stem_path = os.path.join(self.export_path, f'{self.audio_file_base}_({self.primary_stem}).wav')\r\n                if not isinstance(self.primary_source, np.ndarray):\r\n                    self.primary_source = source_primary.T\r\n\r\n                self.primary_source_map = self.final_process(primary_stem_path, self.primary_source, self.secondary_source_primary, self.primary_stem, samplerate)\r\n\r\n        clear_gpu_cache()\r\n        \r\n        secondary_sources = {**self.primary_source_map, **self.secondary_source_map}\r\n        self.process_vocal_split_chain(secondary_sources)\r\n        \r\n        if self.is_secondary_model or self.is_pre_proc_model:\r\n            return secondary_sources\r\n\r\n    def demix(self, mix):\r\n        sr_pitched = 441000\r\n        org_mix = mix\r\n        if self.is_pitch_change:\r\n            mix, sr_pitched = spec_utils.change_pitch_semitones(mix, 44100, semitone_shift=-self.semitone_shift)\r\n\r\n        model = TFC_TDF_net(self.mdx_c_configs, device=self.device)\r\n        model.load_state_dict(torch.load(self.model_path, map_location=cpu))\r\n        model.to(self.device).eval()\r\n        mix = torch.tensor(mix, dtype=torch.float32)\r\n\r\n        try:\r\n            S = model.num_target_instruments\r\n        except Exception as e:\r\n            S = model.module.num_target_instruments\r\n\r\n        mdx_segment_size = self.mdx_c_configs.inference.dim_t if self.is_mdx_c_seg_def else self.mdx_segment_size\r\n        \r\n        batch_size = self.mdx_batch_size\r\n        chunk_size = self.mdx_c_configs.audio.hop_length * (mdx_segment_size - 1)\r\n        overlap = self.overlap_mdx23\r\n\r\n        hop_size = chunk_size // overlap\r\n        mix_shape = mix.shape[1]\r\n        pad_size = hop_size - (mix_shape - chunk_size) % hop_size\r\n        mix = torch.cat([torch.zeros(2, chunk_size - hop_size), mix, torch.zeros(2, pad_size + chunk_size - hop_size)], 1)\r\n\r\n        chunks = mix.unfold(1, chunk_size, hop_size).transpose(0, 1)\r\n        batches = [chunks[i : i + batch_size] for i in range(0, len(chunks), batch_size)]\r\n        \r\n        X = torch.zeros(S, *mix.shape) if S > 1 else torch.zeros_like(mix)\r\n        X = X.to(self.device)\r\n\r\n        with torch.no_grad():\r\n            cnt = 0\r\n            for batch in batches:\r\n                self.running_inference_progress_bar(len(batches))\r\n                x = model(batch.to(self.device))\r\n                \r\n                for w in x:\r\n                    X[..., cnt * hop_size : cnt * hop_size + chunk_size] += w\r\n                    cnt += 1\r\n\r\n        estimated_sources = X[..., chunk_size - hop_size:-(pad_size + chunk_size - hop_size)] / overlap\r\n        del X\r\n        pitch_fix = lambda s:self.pitch_fix(s, sr_pitched, org_mix)\r\n\r\n        if S > 1:\r\n            sources = {k: pitch_fix(v) if self.is_pitch_change else v for k, v in zip(self.mdx_c_configs.training.instruments, estimated_sources.cpu().detach().numpy())}\r\n            del estimated_sources\r\n            if self.is_denoise_model:\r\n                if VOCAL_STEM in sources.keys() and INST_STEM in sources.keys():\r\n                    sources[VOCAL_STEM] = vr_denoiser(sources[VOCAL_STEM], self.device, model_path=self.DENOISER_MODEL)\r\n                    if sources[VOCAL_STEM].shape[1] != org_mix.shape[1]:\r\n                        sources[VOCAL_STEM] = spec_utils.match_array_shapes(sources[VOCAL_STEM], org_mix)\r\n                    sources[INST_STEM] = org_mix - sources[VOCAL_STEM]\r\n                            \r\n            return sources\r\n        else:\r\n            est_s = estimated_sources.cpu().detach().numpy()\r\n            del estimated_sources\r\n            return pitch_fix(est_s) if self.is_pitch_change else est_s\r\n\r\nclass SeperateDemucs(SeperateAttributes):\r\n    def seperate(self):\r\n        samplerate = 44100\r\n        source = None\r\n        model_scale = None\r\n        stem_source = None\r\n        stem_source_secondary = None\r\n        inst_mix = None\r\n        inst_source = None\r\n        is_no_write = False\r\n        is_no_piano_guitar = False\r\n        is_no_cache = False\r\n        \r\n        if self.primary_model_name == self.model_basename and isinstance(self.primary_sources, np.ndarray) and not self.pre_proc_model:\r\n            source = self.primary_sources\r\n            self.load_cached_sources()\r\n        else:\r\n            self.start_inference_console_write()\r\n            is_no_cache = True\r\n\r\n        mix = prepare_mix(self.audio_file)\r\n\r\n        if is_no_cache:\r\n            if self.demucs_version == DEMUCS_V1:\r\n                if str(self.model_path).endswith(\".gz\"):\r\n                    self.model_path = gzip.open(self.model_path, \"rb\")\r\n                klass, args, kwargs, state = torch.load(self.model_path)\r\n                self.demucs = klass(*args, **kwargs)\r\n                self.demucs.to(self.device) \r\n                self.demucs.load_state_dict(state)\r\n            elif self.demucs_version == DEMUCS_V2:\r\n                self.demucs = auto_load_demucs_model_v2(self.demucs_source_list, self.model_path)\r\n                self.demucs.to(self.device) \r\n                self.demucs.load_state_dict(torch.load(self.model_path))\r\n                self.demucs.eval()\r\n            else:  \r\n                self.demucs = HDemucs(sources=self.demucs_source_list)\r\n                self.demucs = _gm(name=os.path.splitext(os.path.basename(self.model_path))[0], \r\n                                  repo=Path(os.path.dirname(self.model_path)))\r\n                self.demucs = demucs_segments(self.segment, self.demucs)\r\n                self.demucs.to(self.device)\r\n                self.demucs.eval()\r\n\r\n            if self.pre_proc_model:\r\n                if self.primary_stem not in [VOCAL_STEM, INST_STEM]:\r\n                    is_no_write = True\r\n                    self.write_to_console(DONE, base_text='')\r\n                    mix_no_voc = process_secondary_model(self.pre_proc_model, self.process_data, is_pre_proc_model=True)\r\n                    inst_mix = prepare_mix(mix_no_voc[INST_STEM])\r\n                    self.process_iteration()\r\n                    self.running_inference_console_write(is_no_write=is_no_write)\r\n                    inst_source = self.demix_demucs(inst_mix)\r\n                    self.process_iteration()\r\n\r\n            self.running_inference_console_write(is_no_write=is_no_write) if not self.pre_proc_model else None\r\n            \r\n            if self.primary_model_name == self.model_basename and isinstance(self.primary_sources, np.ndarray) and self.pre_proc_model:\r\n                source = self.primary_sources\r\n            else:\r\n                source = self.demix_demucs(mix)\r\n            \r\n            self.write_to_console(DONE, base_text='')\r\n            \r\n            del self.demucs\r\n            clear_gpu_cache()\r\n            \r\n        if isinstance(inst_source, np.ndarray):\r\n            source_reshape = spec_utils.reshape_sources(inst_source[self.demucs_source_map[VOCAL_STEM]], source[self.demucs_source_map[VOCAL_STEM]])\r\n            inst_source[self.demucs_source_map[VOCAL_STEM]] = source_reshape\r\n            source = inst_source\r\n\r\n        if isinstance(source, np.ndarray):\r\n            \r\n            if len(source) == 2:\r\n                self.demucs_source_map = DEMUCS_2_SOURCE_MAPPER\r\n            else:\r\n                self.demucs_source_map = DEMUCS_6_SOURCE_MAPPER if len(source) == 6 else DEMUCS_4_SOURCE_MAPPER\r\n\r\n                if len(source) == 6 and self.process_data['is_ensemble_master'] or len(source) == 6 and self.is_secondary_model:\r\n                    is_no_piano_guitar = True\r\n                    six_stem_other_source = list(source)\r\n                    six_stem_other_source = [i for n, i in enumerate(source) if n in [self.demucs_source_map[OTHER_STEM], self.demucs_source_map[GUITAR_STEM], self.demucs_source_map[PIANO_STEM]]]\r\n                    other_source = np.zeros_like(six_stem_other_source[0])\r\n                    for i in six_stem_other_source:\r\n                        other_source += i\r\n                    source_reshape = spec_utils.reshape_sources(source[self.demucs_source_map[OTHER_STEM]], other_source)\r\n                    source[self.demucs_source_map[OTHER_STEM]] = source_reshape\r\n                    \r\n        if not self.is_vocal_split_model:\r\n            self.cache_source(source)\r\n        \r\n        if (self.demucs_stems == ALL_STEMS and not self.process_data['is_ensemble_master']) or self.is_4_stem_ensemble and not self.is_return_dual:\r\n            for stem_name, stem_value in self.demucs_source_map.items():\r\n                if self.is_secondary_model_activated and not self.is_secondary_model and not stem_value >= 4:\r\n                    if self.secondary_model_4_stem[stem_value]:\r\n                        model_scale = self.secondary_model_4_stem_scale[stem_value]\r\n                        stem_source_secondary = process_secondary_model(self.secondary_model_4_stem[stem_value], self.process_data, main_model_primary_stem_4_stem=stem_name, is_source_load=True, is_return_dual=False)\r\n                        if isinstance(stem_source_secondary, np.ndarray):\r\n                            stem_source_secondary = stem_source_secondary[1 if self.secondary_model_4_stem[stem_value].demucs_stem_count == 2 else stem_value].T\r\n                        elif type(stem_source_secondary) is dict:\r\n                            stem_source_secondary = stem_source_secondary[stem_name]\r\n                            \r\n                stem_source_secondary = None if stem_value >= 4 else stem_source_secondary\r\n                stem_path = os.path.join(self.export_path, f'{self.audio_file_base}_({stem_name}).wav')\r\n                stem_source = source[stem_value].T\r\n                \r\n                stem_source = self.process_secondary_stem(stem_source, secondary_model_source=stem_source_secondary, model_scale=model_scale)\r\n                self.write_audio(stem_path, stem_source, samplerate, stem_name=stem_name)\r\n                \r\n                if stem_name == VOCAL_STEM and not self.is_sec_bv_rebalance:\r\n                    self.process_vocal_split_chain({VOCAL_STEM:stem_source})\r\n                \r\n            if self.is_secondary_model:    \r\n                return source\r\n        else:\r\n            if self.is_secondary_model_activated and self.secondary_model:\r\n                    self.secondary_source_primary, self.secondary_source_secondary = process_secondary_model(self.secondary_model, self.process_data, main_process_method=self.process_method)\r\n                    \r\n            if not self.is_primary_stem_only:\r\n                def secondary_save(sec_stem_name, source, raw_mixture=None, is_inst_mixture=False):\r\n                    secondary_source = self.secondary_source if not is_inst_mixture else None\r\n                    secondary_stem_path = os.path.join(self.export_path, f'{self.audio_file_base}_({sec_stem_name}).wav')\r\n                    secondary_source_secondary = None\r\n                    \r\n                    if not isinstance(secondary_source, np.ndarray):\r\n                        if self.is_demucs_combine_stems:\r\n                            source = list(source)\r\n                            if is_inst_mixture:\r\n                                source = [i for n, i in enumerate(source) if not n in [self.demucs_source_map[self.primary_stem], self.demucs_source_map[VOCAL_STEM]]]\r\n                            else:\r\n                                source.pop(self.demucs_source_map[self.primary_stem])\r\n                                \r\n                            source = source[:len(source) - 2] if is_no_piano_guitar else source\r\n                            secondary_source = np.zeros_like(source[0])\r\n                            for i in source:\r\n                                secondary_source += i\r\n                            secondary_source = secondary_source.T\r\n                        else:\r\n                            if not isinstance(raw_mixture, np.ndarray):\r\n                                raw_mixture = prepare_mix(self.audio_file)\r\n       \r\n                            secondary_source = source[self.demucs_source_map[self.primary_stem]]\r\n                            \r\n                            if self.is_invert_spec:\r\n                                secondary_source = spec_utils.invert_stem(raw_mixture, secondary_source)\r\n                            else:\r\n                                raw_mixture = spec_utils.reshape_sources(secondary_source, raw_mixture)\r\n                                secondary_source = (-secondary_source.T+raw_mixture.T)\r\n                            \r\n                    if not is_inst_mixture:\r\n                        self.secondary_source = secondary_source\r\n                        secondary_source_secondary = self.secondary_source_secondary\r\n                        self.secondary_source = self.process_secondary_stem(secondary_source, secondary_source_secondary)\r\n                        self.secondary_source_map = {self.secondary_stem: self.secondary_source}\r\n\r\n                    self.write_audio(secondary_stem_path, secondary_source, samplerate, stem_name=sec_stem_name)\r\n\r\n                secondary_save(self.secondary_stem, source, raw_mixture=mix)\r\n                \r\n                if self.is_demucs_pre_proc_model_inst_mix and self.pre_proc_model and not self.is_4_stem_ensemble:\r\n                    secondary_save(f\"{self.secondary_stem} {INST_STEM}\", source, raw_mixture=inst_mix, is_inst_mixture=True)\r\n\r\n            if not self.is_secondary_stem_only:\r\n                primary_stem_path = os.path.join(self.export_path, f'{self.audio_file_base}_({self.primary_stem}).wav')\r\n                if not isinstance(self.primary_source, np.ndarray):\r\n                    self.primary_source = source[self.demucs_source_map[self.primary_stem]].T\r\n                \r\n                self.primary_source_map = self.final_process(primary_stem_path, self.primary_source, self.secondary_source_primary, self.primary_stem, samplerate)\r\n\r\n            secondary_sources = {**self.primary_source_map, **self.secondary_source_map}\r\n            \r\n            self.process_vocal_split_chain(secondary_sources)\r\n            \r\n            if self.is_secondary_model:    \r\n                return secondary_sources\r\n    \r\n    def demix_demucs(self, mix):\r\n        \r\n        org_mix = mix\r\n        \r\n        if self.is_pitch_change:\r\n            mix, sr_pitched = spec_utils.change_pitch_semitones(mix, 44100, semitone_shift=-self.semitone_shift)\r\n        \r\n        processed = {}\r\n        mix = torch.tensor(mix, dtype=torch.float32)\r\n        ref = mix.mean(0)        \r\n        mix = (mix - ref.mean()) / ref.std()\r\n        mix_infer = mix \r\n        \r\n        with torch.no_grad():\r\n            if self.demucs_version == DEMUCS_V1:\r\n                sources = apply_model_v1(self.demucs, \r\n                                            mix_infer.to(self.device), \r\n                                            self.shifts, \r\n                                            self.is_split_mode,\r\n                                            set_progress_bar=self.set_progress_bar)\r\n            elif self.demucs_version == DEMUCS_V2:\r\n                sources = apply_model_v2(self.demucs, \r\n                                            mix_infer.to(self.device), \r\n                                            self.shifts,\r\n                                            self.is_split_mode,\r\n                                            self.overlap,\r\n                                            set_progress_bar=self.set_progress_bar)\r\n            else:\r\n                sources = apply_model(self.demucs, \r\n                                        mix_infer[None], \r\n                                        self.shifts,\r\n                                        self.is_split_mode,\r\n                                        self.overlap,\r\n                                        static_shifts=1 if self.shifts == 0 else self.shifts,\r\n                                        set_progress_bar=self.set_progress_bar,\r\n                                        device=self.device)[0]\r\n        \r\n        sources = (sources * ref.std() + ref.mean()).cpu().numpy()\r\n        sources[[0,1]] = sources[[1,0]]\r\n        processed[mix] = sources[:,:,0:None].copy()\r\n        sources = list(processed.values())\r\n        sources = [s[:,:,0:None] for s in sources]\r\n        #sources = [self.pitch_fix(s[:,:,0:None], sr_pitched, org_mix) if self.is_pitch_change else s[:,:,0:None] for s in sources]\r\n        sources = np.concatenate(sources, axis=-1)\r\n                     \r\n        if self.is_pitch_change:\r\n            sources = np.stack([self.pitch_fix(stem, sr_pitched, org_mix) for stem in sources])\r\n                        \r\n        return sources\r\n\r\nclass SeperateVR(SeperateAttributes):        \r\n\r\n    def seperate(self):\r\n        if self.primary_model_name == self.model_basename and isinstance(self.primary_sources, tuple):\r\n            y_spec, v_spec = self.primary_sources\r\n            self.load_cached_sources()\r\n        else:\r\n            self.start_inference_console_write()\r\n\r\n            device = self.device\r\n\r\n            nn_arch_sizes = [\r\n                31191, # default\r\n                33966, 56817, 123821, 123812, 129605, 218409, 537238, 537227]\r\n            vr_5_1_models = [56817, 218409]\r\n            model_size = math.ceil(os.stat(self.model_path).st_size / 1024)\r\n            nn_arch_size = min(nn_arch_sizes, key=lambda x:abs(x-model_size))\r\n\r\n            if nn_arch_size in vr_5_1_models or self.is_vr_51_model:\r\n                self.model_run = nets_new.CascadedNet(self.mp.param['bins'] * 2, \r\n                                                      nn_arch_size, \r\n                                                      nout=self.model_capacity[0], \r\n                                                      nout_lstm=self.model_capacity[1])\r\n                self.is_vr_51_model = True\r\n            else:\r\n                self.model_run = nets.determine_model_capacity(self.mp.param['bins'] * 2, nn_arch_size)\r\n                            \r\n            self.model_run.load_state_dict(torch.load(self.model_path, map_location=cpu)) \r\n            self.model_run.to(device) \r\n\r\n            self.running_inference_console_write()\r\n                        \r\n            y_spec, v_spec = self.inference_vr(self.loading_mix(), device, self.aggressiveness)\r\n            if not self.is_vocal_split_model:\r\n                self.cache_source((y_spec, v_spec))\r\n            self.write_to_console(DONE, base_text='')\r\n            \r\n        if self.is_secondary_model_activated and self.secondary_model:\r\n            self.secondary_source_primary, self.secondary_source_secondary = process_secondary_model(self.secondary_model, self.process_data, main_process_method=self.process_method, main_model_primary=self.primary_stem)\r\n\r\n        if not self.is_secondary_stem_only:\r\n            primary_stem_path = os.path.join(self.export_path, f'{self.audio_file_base}_({self.primary_stem}).wav')\r\n            if not isinstance(self.primary_source, np.ndarray):\r\n                self.primary_source = self.spec_to_wav(y_spec).T\r\n                if not self.model_samplerate == 44100:\r\n                    self.primary_source = librosa.resample(self.primary_source.T, orig_sr=self.model_samplerate, target_sr=44100).T\r\n                \r\n            self.primary_source_map = self.final_process(primary_stem_path, self.primary_source, self.secondary_source_primary, self.primary_stem, 44100)  \r\n\r\n        if not self.is_primary_stem_only:\r\n            secondary_stem_path = os.path.join(self.export_path, f'{self.audio_file_base}_({self.secondary_stem}).wav')\r\n            if not isinstance(self.secondary_source, np.ndarray):\r\n                self.secondary_source = self.spec_to_wav(v_spec).T\r\n                if not self.model_samplerate == 44100:\r\n                    self.secondary_source = librosa.resample(self.secondary_source.T, orig_sr=self.model_samplerate, target_sr=44100).T\r\n            \r\n            self.secondary_source_map = self.final_process(secondary_stem_path, self.secondary_source, self.secondary_source_secondary, self.secondary_stem, 44100)\r\n            \r\n        clear_gpu_cache()\r\n        secondary_sources = {**self.primary_source_map, **self.secondary_source_map}\r\n        \r\n        self.process_vocal_split_chain(secondary_sources)\r\n        \r\n        if self.is_secondary_model:\r\n            return secondary_sources\r\n            \r\n    def loading_mix(self):\r\n\r\n        X_wave, X_spec_s = {}, {}\r\n        \r\n        bands_n = len(self.mp.param['band'])\r\n        \r\n        audio_file = spec_utils.write_array_to_mem(self.audio_file, subtype=self.wav_type_set)\r\n        is_mp3 = audio_file.endswith('.mp3') if isinstance(audio_file, str) else False\r\n\r\n        for d in range(bands_n, 0, -1):        \r\n            bp = self.mp.param['band'][d]\r\n        \r\n            if OPERATING_SYSTEM == 'Darwin':\r\n                wav_resolution = 'polyphase' if SYSTEM_PROC == ARM or ARM in SYSTEM_ARCH else bp['res_type']\r\n            else:\r\n                wav_resolution = bp['res_type']\r\n        \r\n            if d == bands_n: # high-end band\r\n                X_wave[d], _ = librosa.load(audio_file, bp['sr'], False, dtype=np.float32, res_type=wav_resolution)\r\n                X_spec_s[d] = spec_utils.wave_to_spectrogram(X_wave[d], bp['hl'], bp['n_fft'], self.mp, band=d, is_v51_model=self.is_vr_51_model)\r\n                    \r\n                if not np.any(X_wave[d]) and is_mp3:\r\n                    X_wave[d] = rerun_mp3(audio_file, bp['sr'])\r\n\r\n                if X_wave[d].ndim == 1:\r\n                    X_wave[d] = np.asarray([X_wave[d], X_wave[d]])\r\n            else: # lower bands\r\n                X_wave[d] = librosa.resample(X_wave[d+1], self.mp.param['band'][d+1]['sr'], bp['sr'], res_type=wav_resolution)\r\n                X_spec_s[d] = spec_utils.wave_to_spectrogram(X_wave[d], bp['hl'], bp['n_fft'], self.mp, band=d, is_v51_model=self.is_vr_51_model)\r\n\r\n            if d == bands_n and self.high_end_process != 'none':\r\n                self.input_high_end_h = (bp['n_fft']//2 - bp['crop_stop']) + (self.mp.param['pre_filter_stop'] - self.mp.param['pre_filter_start'])\r\n                self.input_high_end = X_spec_s[d][:, bp['n_fft']//2-self.input_high_end_h:bp['n_fft']//2, :]\r\n\r\n        X_spec = spec_utils.combine_spectrograms(X_spec_s, self.mp, is_v51_model=self.is_vr_51_model)\r\n        \r\n        del X_wave, X_spec_s, audio_file\r\n\r\n        return X_spec\r\n\r\n    def inference_vr(self, X_spec, device, aggressiveness):\r\n        def _execute(X_mag_pad, roi_size):\r\n            X_dataset = []\r\n            patches = (X_mag_pad.shape[2] - 2 * self.model_run.offset) // roi_size\r\n            total_iterations = patches//self.batch_size if not self.is_tta else (patches//self.batch_size)*2\r\n            for i in range(patches):\r\n                start = i * roi_size\r\n                X_mag_window = X_mag_pad[:, :, start:start + self.window_size]\r\n                X_dataset.append(X_mag_window)\r\n\r\n            X_dataset = np.asarray(X_dataset)\r\n            self.model_run.eval()\r\n            with torch.no_grad():\r\n                mask = []\r\n                for i in range(0, patches, self.batch_size):\r\n                    self.progress_value += 1\r\n                    if self.progress_value >= total_iterations:\r\n                        self.progress_value = total_iterations\r\n                    self.set_progress_bar(0.1, 0.8/total_iterations*self.progress_value)\r\n                    X_batch = X_dataset[i: i + self.batch_size]\r\n                    X_batch = torch.from_numpy(X_batch).to(device)\r\n                    pred = self.model_run.predict_mask(X_batch)\r\n                    if not pred.size()[3] > 0:\r\n                        raise Exception(ERROR_MAPPER[WINDOW_SIZE_ERROR])\r\n                    pred = pred.detach().cpu().numpy()\r\n                    pred = np.concatenate(pred, axis=2)\r\n                    mask.append(pred)\r\n                if len(mask) == 0:\r\n                    raise Exception(ERROR_MAPPER[WINDOW_SIZE_ERROR])\r\n                \r\n                mask = np.concatenate(mask, axis=2)\r\n            return mask\r\n\r\n        def postprocess(mask, X_mag, X_phase):\r\n            is_non_accom_stem = False\r\n            for stem in NON_ACCOM_STEMS:\r\n                if stem == self.primary_stem:\r\n                    is_non_accom_stem = True\r\n                    \r\n            mask = spec_utils.adjust_aggr(mask, is_non_accom_stem, aggressiveness)\r\n\r\n            if self.is_post_process:\r\n                mask = spec_utils.merge_artifacts(mask, thres=self.post_process_threshold)\r\n\r\n            y_spec = mask * X_mag * np.exp(1.j * X_phase)\r\n            v_spec = (1 - mask) * X_mag * np.exp(1.j * X_phase)\r\n        \r\n            return y_spec, v_spec\r\n        \r\n        X_mag, X_phase = spec_utils.preprocess(X_spec)\r\n        n_frame = X_mag.shape[2]\r\n        pad_l, pad_r, roi_size = spec_utils.make_padding(n_frame, self.window_size, self.model_run.offset)\r\n        X_mag_pad = np.pad(X_mag, ((0, 0), (0, 0), (pad_l, pad_r)), mode='constant')\r\n        X_mag_pad /= X_mag_pad.max()\r\n        mask = _execute(X_mag_pad, roi_size)\r\n        \r\n        if self.is_tta:\r\n            pad_l += roi_size // 2\r\n            pad_r += roi_size // 2\r\n            X_mag_pad = np.pad(X_mag, ((0, 0), (0, 0), (pad_l, pad_r)), mode='constant')\r\n            X_mag_pad /= X_mag_pad.max()\r\n            mask_tta = _execute(X_mag_pad, roi_size)\r\n            mask_tta = mask_tta[:, :, roi_size // 2:]\r\n            mask = (mask[:, :, :n_frame] + mask_tta[:, :, :n_frame]) * 0.5\r\n        else:\r\n            mask = mask[:, :, :n_frame]\r\n\r\n        y_spec, v_spec = postprocess(mask, X_mag, X_phase)\r\n        \r\n        return y_spec, v_spec\r\n\r\n    def spec_to_wav(self, spec):\r\n        if self.high_end_process.startswith('mirroring') and isinstance(self.input_high_end, np.ndarray) and self.input_high_end_h:        \r\n            input_high_end_ = spec_utils.mirroring(self.high_end_process, spec, self.input_high_end, self.mp)\r\n            wav = spec_utils.cmb_spectrogram_to_wave(spec, self.mp, self.input_high_end_h, input_high_end_, is_v51_model=self.is_vr_51_model)       \r\n        else:\r\n            wav = spec_utils.cmb_spectrogram_to_wave(spec, self.mp, is_v51_model=self.is_vr_51_model)\r\n            \r\n        return wav\r\n\r\ndef process_secondary_model(secondary_model: ModelData, \r\n                            process_data, \r\n                            main_model_primary_stem_4_stem=None, \r\n                            is_source_load=False, \r\n                            main_process_method=None, \r\n                            is_pre_proc_model=False, \r\n                            is_return_dual=True, \r\n                            main_model_primary=None):\r\n        \r\n    if not is_pre_proc_model:\r\n        process_iteration = process_data['process_iteration']\r\n        process_iteration()\r\n    \r\n    if secondary_model.process_method == VR_ARCH_TYPE:\r\n        seperator = SeperateVR(secondary_model, process_data, main_model_primary_stem_4_stem=main_model_primary_stem_4_stem, main_process_method=main_process_method, main_model_primary=main_model_primary)\r\n    if secondary_model.process_method == MDX_ARCH_TYPE:\r\n        if secondary_model.is_mdx_c:\r\n            seperator = SeperateMDXC(secondary_model, process_data, main_model_primary_stem_4_stem=main_model_primary_stem_4_stem, main_process_method=main_process_method, is_return_dual=is_return_dual, main_model_primary=main_model_primary)\r\n        else:\r\n            seperator = SeperateMDX(secondary_model, process_data, main_model_primary_stem_4_stem=main_model_primary_stem_4_stem, main_process_method=main_process_method, main_model_primary=main_model_primary)\r\n    if secondary_model.process_method == DEMUCS_ARCH_TYPE:\r\n        seperator = SeperateDemucs(secondary_model, process_data, main_model_primary_stem_4_stem=main_model_primary_stem_4_stem, main_process_method=main_process_method, is_return_dual=is_return_dual, main_model_primary=main_model_primary)\r\n        \r\n    secondary_sources = seperator.seperate()\r\n\r\n    if type(secondary_sources) is dict and not is_source_load and not is_pre_proc_model:\r\n        return gather_sources(secondary_model.primary_model_primary_stem, secondary_stem(secondary_model.primary_model_primary_stem), secondary_sources)\r\n    else:\r\n        return secondary_sources\r\n    \r\ndef process_chain_model(secondary_model: ModelData, \r\n                        process_data, \r\n                        vocal_stem_path, \r\n                        master_vocal_source, \r\n                        master_inst_source=None):\r\n    \r\n    process_iteration = process_data['process_iteration']\r\n    process_iteration()\r\n    \r\n    if secondary_model.bv_model_rebalance:\r\n        vocal_source = spec_utils.reduce_mix_bv(master_inst_source, master_vocal_source, reduction_rate=secondary_model.bv_model_rebalance)\r\n    else:\r\n        vocal_source = master_vocal_source\r\n    \r\n    vocal_stem_path = [vocal_source, os.path.splitext(os.path.basename(vocal_stem_path))[0]]\r\n\r\n    if secondary_model.process_method == VR_ARCH_TYPE:\r\n        seperator = SeperateVR(secondary_model, process_data, vocal_stem_path=vocal_stem_path, master_inst_source=master_inst_source, master_vocal_source=master_vocal_source)\r\n    if secondary_model.process_method == MDX_ARCH_TYPE:\r\n        if secondary_model.is_mdx_c:\r\n            seperator = SeperateMDXC(secondary_model, process_data, vocal_stem_path=vocal_stem_path, master_inst_source=master_inst_source, master_vocal_source=master_vocal_source)\r\n        else:\r\n            seperator = SeperateMDX(secondary_model, process_data, vocal_stem_path=vocal_stem_path, master_inst_source=master_inst_source, master_vocal_source=master_vocal_source)\r\n    if secondary_model.process_method == DEMUCS_ARCH_TYPE:\r\n        seperator = SeperateDemucs(secondary_model, process_data, vocal_stem_path=vocal_stem_path, master_inst_source=master_inst_source, master_vocal_source=master_vocal_source)\r\n        \r\n    secondary_sources = seperator.seperate()\r\n    \r\n    if type(secondary_sources) is dict:\r\n        return secondary_sources\r\n    else:\r\n        return None\r\n    \r\ndef gather_sources(primary_stem_name, secondary_stem_name, secondary_sources: dict):\r\n    \r\n    source_primary = False\r\n    source_secondary = False\r\n\r\n    for key, value in secondary_sources.items():\r\n        if key in primary_stem_name:\r\n            source_primary = value\r\n        if key in secondary_stem_name:\r\n            source_secondary = value\r\n\r\n    return source_primary, source_secondary\r\n        \r\ndef prepare_mix(mix):\r\n    \r\n    audio_path = mix\r\n\r\n    if not isinstance(mix, np.ndarray):\r\n        mix, sr = librosa.load(mix, mono=False, sr=44100)\r\n    else:\r\n        mix = mix.T\r\n\r\n    if isinstance(audio_path, str):\r\n        if not np.any(mix) and audio_path.endswith('.mp3'):\r\n            mix = rerun_mp3(audio_path)\r\n\r\n    if mix.ndim == 1:\r\n        mix = np.asfortranarray([mix,mix])\r\n\r\n    return mix\r\n\r\ndef rerun_mp3(audio_file, sample_rate=44100):\r\n\r\n    with audioread.audio_open(audio_file) as f:\r\n        track_length = int(f.duration)\r\n\r\n    return librosa.load(audio_file, duration=track_length, mono=False, sr=sample_rate)[0]\r\n\r\ndef save_format(audio_path, save_format, mp3_bit_set):\r\n    \r\n    if not save_format == WAV:\r\n        \r\n        if OPERATING_SYSTEM == 'Darwin':\r\n            FFMPEG_PATH = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'ffmpeg')\r\n            pydub.AudioSegment.converter = FFMPEG_PATH\r\n        \r\n        musfile = pydub.AudioSegment.from_wav(audio_path)\r\n        \r\n        if save_format == FLAC:\r\n            audio_path_flac = audio_path.replace(\".wav\", \".flac\")\r\n            musfile.export(audio_path_flac, format=\"flac\")  \r\n        \r\n        if save_format == MP3:\r\n            audio_path_mp3 = audio_path.replace(\".wav\", \".mp3\")\r\n            try:\r\n                musfile.export(audio_path_mp3, format=\"mp3\", bitrate=mp3_bit_set, codec=\"libmp3lame\")\r\n            except Exception as e:\r\n                print(e)\r\n                musfile.export(audio_path_mp3, format=\"mp3\", bitrate=mp3_bit_set)\r\n        \r\n        try:\r\n            os.remove(audio_path)\r\n        except Exception as e:\r\n            print(e)\r\n            \r\ndef pitch_shift(mix):\r\n    new_sr = 31183\r\n\r\n    # Resample audio file\r\n    resampled_audio = signal.resample_poly(mix, new_sr, 44100)\r\n    \r\n    return resampled_audio\r\n\r\ndef list_to_dictionary(lst):\r\n    dictionary = {item: index for index, item in enumerate(lst)}\r\n    return dictionary\r\n\r\ndef vr_denoiser(X, device, hop_length=1024, n_fft=2048, cropsize=256, is_deverber=False, model_path=None):\r\n    batchsize = 4\r\n\r\n    if is_deverber:\r\n        nout, nout_lstm = 64, 128\r\n        mp = ModelParameters(os.path.join('lib_v5', 'vr_network', 'modelparams', '4band_v3.json'))\r\n        n_fft = mp.param['bins'] * 2\r\n    else:\r\n        mp = None\r\n        hop_length=1024\r\n        nout, nout_lstm = 16, 128\r\n    \r\n    model = nets_new.CascadedNet(n_fft, nout=nout, nout_lstm=nout_lstm)\r\n    model.load_state_dict(torch.load(model_path, map_location=cpu))\r\n    model.to(device)\r\n\r\n    if mp is None:\r\n        X_spec = spec_utils.wave_to_spectrogram_old(X, hop_length, n_fft)\r\n    else:\r\n        X_spec = loading_mix(X.T, mp)\r\n   \r\n    #PreProcess\r\n    X_mag = np.abs(X_spec)\r\n    X_phase = np.angle(X_spec)\r\n\r\n    #Sep\r\n    n_frame = X_mag.shape[2]\r\n    pad_l, pad_r, roi_size = spec_utils.make_padding(n_frame, cropsize, model.offset)\r\n    X_mag_pad = np.pad(X_mag, ((0, 0), (0, 0), (pad_l, pad_r)), mode='constant')\r\n    X_mag_pad /= X_mag_pad.max()\r\n\r\n    X_dataset = []\r\n    patches = (X_mag_pad.shape[2] - 2 * model.offset) // roi_size\r\n    for i in range(patches):\r\n        start = i * roi_size\r\n        X_mag_crop = X_mag_pad[:, :, start:start + cropsize]\r\n        X_dataset.append(X_mag_crop)\r\n\r\n    X_dataset = np.asarray(X_dataset)\r\n\r\n    model.eval()\r\n    \r\n    with torch.no_grad():\r\n        mask = []\r\n        # To reduce the overhead, dataloader is not used.\r\n        for i in range(0, patches, batchsize):\r\n            X_batch = X_dataset[i: i + batchsize]\r\n            X_batch = torch.from_numpy(X_batch).to(device)\r\n\r\n            pred = model.predict_mask(X_batch)\r\n\r\n            pred = pred.detach().cpu().numpy()\r\n            pred = np.concatenate(pred, axis=2)\r\n            mask.append(pred)\r\n\r\n        mask = np.concatenate(mask, axis=2)\r\n    \r\n    mask = mask[:, :, :n_frame]\r\n\r\n    #Post Proc\r\n    if is_deverber:\r\n        v_spec = mask * X_mag * np.exp(1.j * X_phase)\r\n        y_spec = (1 - mask) * X_mag * np.exp(1.j * X_phase)\r\n    else:\r\n        v_spec = (1 - mask) * X_mag * np.exp(1.j * X_phase)\r\n\r\n    if mp is None:\r\n        wave = spec_utils.spectrogram_to_wave_old(v_spec, hop_length=1024)\r\n    else:\r\n        wave = spec_utils.cmb_spectrogram_to_wave(v_spec, mp, is_v51_model=True).T\r\n        \r\n    wave = spec_utils.match_array_shapes(wave, X)\r\n\r\n    if is_deverber:\r\n        wave_2 = spec_utils.cmb_spectrogram_to_wave(y_spec, mp, is_v51_model=True).T\r\n        wave_2 = spec_utils.match_array_shapes(wave_2, X)\r\n        return wave, wave_2\r\n    else:\r\n        return wave\r\n\r\ndef loading_mix(X, mp):\r\n\r\n    X_wave, X_spec_s = {}, {}\r\n    \r\n    bands_n = len(mp.param['band'])\r\n    \r\n    for d in range(bands_n, 0, -1):        \r\n        bp = mp.param['band'][d]\r\n    \r\n        if OPERATING_SYSTEM == 'Darwin':\r\n            wav_resolution = 'polyphase' if SYSTEM_PROC == ARM or ARM in SYSTEM_ARCH else bp['res_type']\r\n        else:\r\n            wav_resolution = 'polyphase'#bp['res_type']\r\n    \r\n        if d == bands_n: # high-end band\r\n            X_wave[d] = X\r\n\r\n        else: # lower bands\r\n            X_wave[d] = librosa.resample(X_wave[d+1], mp.param['band'][d+1]['sr'], bp['sr'], res_type=wav_resolution)\r\n            \r\n        X_spec_s[d] = spec_utils.wave_to_spectrogram(X_wave[d], bp['hl'], bp['n_fft'], mp, band=d, is_v51_model=True)\r\n        \r\n        # if d == bands_n and is_high_end_process:\r\n        #     input_high_end_h = (bp['n_fft']//2 - bp['crop_stop']) + (mp.param['pre_filter_stop'] - mp.param['pre_filter_start'])\r\n        #     input_high_end = X_spec_s[d][:, bp['n_fft']//2-input_high_end_h:bp['n_fft']//2, :]\r\n\r\n    X_spec = spec_utils.combine_spectrograms(X_spec_s, mp)\r\n    \r\n    del X_wave, X_spec_s\r\n\r\n    return X_spec\r\n"
        }
      ]
    }
  ]
}