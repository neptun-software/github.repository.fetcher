{
  "metadata": {
    "timestamp": 1736561093889,
    "page": 24,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjMw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "HumanSignal/labelImg",
      "stars": 23090,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.3955078125,
          "content": "resources/icons/.DS_Store\nresources.py\nlabelImg.egg-info*\n\n*.pyc\n.*.swp\n\nbuild/\ndist/\n\ntags\ncscope*\n.ycm_extra_conf.py\n.subvimrc\n.vscode\n*.pkl\nPipfile\n*.xml\n\n# MacOS System-Generated\n.DS_Store\n.DS_Store?\n._*\n.Spotlight-V100\n.Trashes\nehthumbs.db\nThumbs.db\n\n# Byte-compiled / optimized / DLL files\n__pycache__/\n*.py[cod]\n*$py.class\n\n# C extensions\n*.so\n\n# IDE\n*.DS_Store\n*.iml\n.idea\n.unison*\n.attach*\ntmp.*\n"
        },
        {
          "name": "CONTRIBUTING.rst",
          "type": "blob",
          "size": 0.0810546875,
          "content": "TzuTa Lin\n[LabelMe](http://labelme2.csail.mit.edu/Release3.0/index.php)\nRyan Flynn\n"
        },
        {
          "name": "HISTORY.rst",
          "type": "blob",
          "size": 1.6201171875,
          "content": "History\n=======\n\n1.8.6 (2021-10-10)\n------------------\n\n* Display box width and height\n\n\n1.8.5 (2021-04-11)\n------------------\n\n* Merged a couple of PRs\n* Fixed issues\n* Support CreateML format\n\n\n1.8.4 (2020-11-04)\n------------------\n\n* Merged a couple of PRs\n* Fixed issues\n\n1.8.2 (2018-12-02)\n------------------\n\n* Fix pip depolyment issue\n\n\n1.8.1 (2018-12-02)\n------------------\n\n* Fix issues\n* Support zh-Tw strings\n\n\n1.8.0 (2018-10-21)\n------------------\n\n* Support drawing sqaure rect\n* Add item single click slot\n* Fix issues\n\n1.7.0 (2018-05-18)\n------------------\n\n* Support YOLO\n* Fix minor issues\n\n\n1.6.1 (2018-04-17)\n------------------\n\n* Fix issue\n\n1.6.0 (2018-01-29)\n------------------\n\n* Add more pre-defined labels\n* Show cursor pose in status bar\n* Fix minor issues\n\n1.5.2 (2017-10-24)\n------------------\n\n* Assign different colors to different lablels\n\n1.5.1 (2017-9-27)\n------------------\n\n* Show a autosaving dialog\n\n1.5.0 (2017-9-14)\n------------------\n\n* Fix the issues\n* Add feature: Draw a box easier\n\n\n1.4.3 (2017-08-09)\n------------------\n\n* Refactor setting\n* Fix the issues\n\n\n1.4.0 (2017-07-07)\n------------------\n\n* Add feature: auto saving\n* Add feature: single class mode\n* Fix the issues\n\n1.3.4 (2017-07-07)\n------------------\n\n* Fix issues and improve zoom-in\n\n1.3.3 (2017-05-31)\n------------------\n\n* Fix issues\n\n1.3.2 (2017-05-18)\n------------------\n\n* Fix issues\n\n\n1.3.1 (2017-05-11)\n------------------\n\n* Fix issues\n\n1.3.0 (2017-04-22)\n------------------\n\n* Fix issues\n* Add difficult tag\n* Create new files for pypi\n\n1.2.3 (2017-04-22)\n------------------\n\n* Fix issues\n\n1.2.2 (2017-01-09)\n------------------\n\n* Fix issues\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.1689453125,
          "content": "Copyright (c) <2015-Present> Tzutalin\n\nCopyright (C) 2013  MIT, Computer Science and Artificial Intelligence Laboratory. Bryan Russell, Antonio Torralba, William T. Freeman\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "MANIFEST.in",
          "type": "blob",
          "size": 0.29296875,
          "content": "include CONTRIBUTING.rst\ninclude HISTORY.rst\ninclude LICENSE\ninclude README.rst\n\ninclude resources.qrc\n\nrecursive-include data *\nrecursive-include icons *\nrecursive-include libs *\n\nrecursive-exclude build-tools *\nrecursive-exclude tests *\nrecursive-exclude * __pycache__\nrecursive-exclude * *.py[co]\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.5078125,
          "content": "# ex: set ts=8 noet:\n\nall: qt5 test\n\ntest: testpy3\n\ntestpy2:\n\tpython -m unittest discover tests\n\ntestpy3:\n\tpython3 -m unittest discover tests\n\nqt4: qt4py2\n\nqt5: qt5py3\n\nqt4py2:\n\tpyrcc4 -py2 -o libs/resources.py resources.qrc\n\nqt4py3:\n\tpyrcc4 -py3 -o libs/resources.py resources.qrc\n\nqt5py3:\n\tpyrcc5 -o libs/resources.py resources.qrc\n\nclean:\n\trm -rf ~/.labelImgSettings.pkl *.pyc dist labelImg.egg-info __pycache__ build\n\npip_upload:\n\tpython3 setup.py upload\n\nlong_description:\n\trestview --long-description\n\n.PHONY: all\n"
        },
        {
          "name": "README.rst",
          "type": "blob",
          "size": 11.6025390625,
          "content": ".. image:: /readme/images/labelimg.png\n        :target: https://github.com/heartexlabs/label-studio\n\nLabel Studio is a modern, multi-modal data annotation tool\n=======\n\nLabelImg, the popular image annotation tool created by Tzutalin with the help of dozens contributors, is no longer actively being developed and has become part of the Label Studio community. Check out `Label Studio <https://github.com/heartexlabs/label-studio>`__, the most flexible open source data labeling tool for images, text, hypertext, audio, video and time-series data. `Install <https://labelstud.io/guide/install.html>`__ Label Studio and join the `slack community <https://label-studio.slack.com/>`__ to get started.\n\n.. image:: /readme/images/label-studio-1-6-player-screenshot.png\n        :target: https://github.com/heartexlabs/label-studio\n\nAbout LabelImg\n========\n\n.. image:: https://img.shields.io/pypi/v/labelimg.svg\n        :target: https://pypi.python.org/pypi/labelimg\n\n.. image:: https://img.shields.io/github/workflow/status/tzutalin/labelImg/Package?style=for-the-badge\n        :alt: GitHub Workflow Status\n\n.. image:: https://img.shields.io/badge/lang-en-blue.svg\n        :target: https://github.com/tzutalin/labelImg\n\n.. image:: https://img.shields.io/badge/lang-zh-green.svg\n        :target: https://github.com/tzutalin/labelImg/blob/master/readme/README.zh.rst\n\n.. image:: https://img.shields.io/badge/lang-jp-green.svg\n        :target: https://github.com/tzutalin/labelImg/blob/master/readme/README.jp.rst\n\nLabelImg is a graphical image annotation tool.\n\nIt is written in Python and uses Qt for its graphical interface.\n\nAnnotations are saved as XML files in PASCAL VOC format, the format used\nby `ImageNet <http://www.image-net.org/>`__.  Besides, it also supports YOLO and CreateML formats.\n\n.. image:: https://raw.githubusercontent.com/tzutalin/labelImg/master/demo/demo3.jpg\n     :alt: Demo Image\n\n.. image:: https://raw.githubusercontent.com/tzutalin/labelImg/master/demo/demo.jpg\n     :alt: Demo Image\n\n`Watch a demo video <https://youtu.be/p0nR2YsCY_U>`__\n\nInstallation\n------------------\n\nGet from PyPI but only python3.0 or above\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nThis is the simplest (one-command) install method on modern Linux distributions such as Ubuntu and Fedora.\n\n.. code:: shell\n\n    pip3 install labelImg\n    labelImg\n    labelImg [IMAGE_PATH] [PRE-DEFINED CLASS FILE]\n\n\nBuild from source\n~~~~~~~~~~~~~~~~~\n\nLinux/Ubuntu/Mac requires at least `Python\n2.6 <https://www.python.org/getit/>`__ and has been tested with `PyQt\n4.8 <https://www.riverbankcomputing.com/software/pyqt/intro>`__. However, `Python\n3 or above <https://www.python.org/getit/>`__ and  `PyQt5 <https://pypi.org/project/PyQt5/>`__ are strongly recommended.\n\n\nUbuntu Linux\n^^^^^^^^^^^^\n\nPython 3 + Qt5\n\n.. code:: shell\n\n    sudo apt-get install pyqt5-dev-tools\n    sudo pip3 install -r requirements/requirements-linux-python3.txt\n    make qt5py3\n    python3 labelImg.py\n    python3 labelImg.py [IMAGE_PATH] [PRE-DEFINED CLASS FILE]\n\nmacOS\n^^^^^\n\nPython 3 + Qt5\n\n.. code:: shell\n\n    brew install qt  # Install qt-5.x.x by Homebrew\n    brew install libxml2\n\n    or using pip\n\n    pip3 install pyqt5 lxml # Install qt and lxml by pip\n\n    make qt5py3\n    python3 labelImg.py\n    python3 labelImg.py [IMAGE_PATH] [PRE-DEFINED CLASS FILE]\n\n\nPython 3 Virtualenv (Recommended)\n\nVirtualenv can avoid a lot of the QT / Python version issues\n\n.. code:: shell\n\n    brew install python3\n    pip3 install pipenv\n    pipenv run pip install pyqt5==5.15.2 lxml\n    pipenv run make qt5py3\n    pipenv run python3 labelImg.py\n    [Optional] rm -rf build dist; pipenv run python setup.py py2app -A;mv \"dist/labelImg.app\" /Applications\n\nNote: The Last command gives you a nice .app file with a new SVG Icon in your /Applications folder. You can consider using the script: build-tools/build-for-macos.sh\n\n\nWindows\n^^^^^^^\n\nInstall `Python <https://www.python.org/downloads/windows/>`__,\n`PyQt5 <https://www.riverbankcomputing.com/software/pyqt/download5>`__\nand `install lxml <http://lxml.de/installation.html>`__.\n\nOpen cmd and go to the `labelImg <#labelimg>`__ directory\n\n.. code:: shell\n\n    pyrcc4 -o libs/resources.py resources.qrc\n    For pyqt5, pyrcc5 -o libs/resources.py resources.qrc\n\n    python labelImg.py\n    python labelImg.py [IMAGE_PATH] [PRE-DEFINED CLASS FILE]\n\nIf you want to package it into a separate EXE file\n\n.. code:: shell\n\n    Install pyinstaller and execute:\n\n    pip install pyinstaller\n    pyinstaller --hidden-import=pyqt5 --hidden-import=lxml -F -n \"labelImg\" -c labelImg.py -p ./libs -p ./\n\nWindows + Anaconda\n^^^^^^^^^^^^^^^^^^\n\nDownload and install `Anaconda <https://www.anaconda.com/download/#download>`__ (Python 3+)\n\nOpen the Anaconda Prompt and go to the `labelImg <#labelimg>`__ directory\n\n.. code:: shell\n\n    conda install pyqt=5\n    conda install -c anaconda lxml\n    pyrcc5 -o libs/resources.py resources.qrc\n    python labelImg.py\n    python labelImg.py [IMAGE_PATH] [PRE-DEFINED CLASS FILE]\n\nUse Docker\n~~~~~~~~~~~~~~~~~\n.. code:: shell\n\n    docker run -it \\\n    --user $(id -u) \\\n    -e DISPLAY=unix$DISPLAY \\\n    --workdir=$(pwd) \\\n    --volume=\"/home/$USER:/home/$USER\" \\\n    --volume=\"/etc/group:/etc/group:ro\" \\\n    --volume=\"/etc/passwd:/etc/passwd:ro\" \\\n    --volume=\"/etc/shadow:/etc/shadow:ro\" \\\n    --volume=\"/etc/sudoers.d:/etc/sudoers.d:ro\" \\\n    -v /tmp/.X11-unix:/tmp/.X11-unix \\\n    tzutalin/py2qt4\n\n    make qt4py2;./labelImg.py\n\nYou can pull the image which has all of the installed and required dependencies. `Watch a demo video <https://youtu.be/nw1GexJzbCI>`__\n\n\nUsage\n-----\n\nSteps (PascalVOC)\n~~~~~~~~~~~~~~~~~\n\n1. Build and launch using the instructions above.\n2. Click 'Change default saved annotation folder' in Menu/File\n3. Click 'Open Dir'\n4. Click 'Create RectBox'\n5. Click and release left mouse to select a region to annotate the rect\n   box\n6. You can use right mouse to drag the rect box to copy or move it\n\nThe annotation will be saved to the folder you specify.\n\nYou can refer to the below hotkeys to speed up your workflow.\n\nSteps (YOLO)\n~~~~~~~~~~~~\n\n1. In ``data/predefined_classes.txt`` define the list of classes that will be used for your training.\n\n2. Build and launch using the instructions above.\n\n3. Right below \"Save\" button in the toolbar, click \"PascalVOC\" button to switch to YOLO format.\n\n4. You may use Open/OpenDIR to process single or multiple images. When finished with a single image, click save.\n\nA txt file of YOLO format will be saved in the same folder as your image with same name. A file named \"classes.txt\" is saved to that folder too. \"classes.txt\" defines the list of class names that your YOLO label refers to.\n\nNote:\n\n- Your label list shall not change in the middle of processing a list of images. When you save an image, classes.txt will also get updated, while previous annotations will not be updated.\n\n- You shouldn't use \"default class\" function when saving to YOLO format, it will not be referred.\n\n- When saving as YOLO format, \"difficult\" flag is discarded.\n\nCreate pre-defined classes\n~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nYou can edit the\n`data/predefined\\_classes.txt <https://github.com/tzutalin/labelImg/blob/master/data/predefined_classes.txt>`__\nto load pre-defined classes\n\nAnnotation visualization\n~~~~~~~~~~~~~~~~~~~~~~~~\n\n1. Copy the existing lables file to same folder with the images. The labels file name must be same with image file name.\n\n2. Click File and choose 'Open Dir' then Open the image folder.\n\n3. Select image in File List, it will appear the bounding box and label for all objects in that image.\n\n(Choose Display Labels mode in View to show/hide lablels)\n\n\nHotkeys\n~~~~~~~\n\n+--------------------+--------------------------------------------+\n| Ctrl + u           | Load all of the images from a directory    |\n+--------------------+--------------------------------------------+\n| Ctrl + r           | Change the default annotation target dir   |\n+--------------------+--------------------------------------------+\n| Ctrl + s           | Save                                       |\n+--------------------+--------------------------------------------+\n| Ctrl + d           | Copy the current label and rect box        |\n+--------------------+--------------------------------------------+\n| Ctrl + Shift + d   | Delete the current image                   |\n+--------------------+--------------------------------------------+\n| Space              | Flag the current image as verified         |\n+--------------------+--------------------------------------------+\n| w                  | Create a rect box                          |\n+--------------------+--------------------------------------------+\n| d                  | Next image                                 |\n+--------------------+--------------------------------------------+\n| a                  | Previous image                             |\n+--------------------+--------------------------------------------+\n| del                | Delete the selected rect box               |\n+--------------------+--------------------------------------------+\n| Ctrl++             | Zoom in                                    |\n+--------------------+--------------------------------------------+\n| Ctrl--             | Zoom out                                   |\n+--------------------+--------------------------------------------+\n| ↑→↓←               | Keyboard arrows to move selected rect box  |\n+--------------------+--------------------------------------------+\n\n**Verify Image:**\n\nWhen pressing space, the user can flag the image as verified, a green background will appear.\nThis is used when creating a dataset automatically, the user can then through all the pictures and flag them instead of annotate them.\n\n**Difficult:**\n\nThe difficult field is set to 1 indicates that the object has been annotated as \"difficult\", for example, an object which is clearly visible but difficult to recognize without substantial use of context.\nAccording to your deep neural network implementation, you can include or exclude difficult objects during training.\n\nHow to reset the settings\n~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIn case there are issues with loading the classes, you can either:\n\n1. From the top menu of the labelimg click on Menu/File/Reset All\n2. Remove the `.labelImgSettings.pkl` from your home directory. In Linux and Mac you can do:\n    `rm ~/.labelImgSettings.pkl`\n\n\nHow to contribute\n~~~~~~~~~~~~~~~~~\n\nSend a pull request\n\nLicense\n~~~~~~~\n`Free software: MIT license <https://github.com/tzutalin/labelImg/blob/master/LICENSE>`_\n\nCitation: Tzutalin. LabelImg. Git code (2015). https://github.com/tzutalin/labelImg\n\nRelated and additional tools\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n1. `Label Studio <https://github.com/heartexlabs/label-studio>`__ to label images, text, audio, video and time-series data for machine learning and AI\n2. `ImageNet Utils <https://github.com/tzutalin/ImageNet_Utils>`__ to\n   download image, create a label text for machine learning, etc\n3. `Use Docker to run labelImg <https://hub.docker.com/r/tzutalin/py2qt4>`__\n4. `Generating the PASCAL VOC TFRecord files <https://github.com/tensorflow/models/blob/4f32535fe7040bb1e429ad0e3c948a492a89482d/research/object_detection/g3doc/preparing_inputs.md#generating-the-pascal-voc-tfrecord-files>`__\n5. `App Icon based on Icon by Nick Roach (GPL) <https://www.elegantthemes.com/>`__\n6. `Setup python development in vscode <https://tzutalin.blogspot.com/2019/04/set-up-visual-studio-code-for-python-in.html>`__\n7. `The link of this project on iHub platform <https://code.ihub.org.cn/projects/260/repository/labelImg>`__\n8. `Convert annotation files to CSV format or format for Google Cloud AutoML <https://github.com/tzutalin/labelImg/tree/master/tools>`__\n\n\n\nStargazers over time\n~~~~~~~~~~~~~~~~~~~~\n\n.. image:: https://starchart.cc/tzutalin/labelImg.svg\n\n"
        },
        {
          "name": "__init__.py",
          "type": "blob",
          "size": 0,
          "content": ""
        },
        {
          "name": "build-tools",
          "type": "tree",
          "content": null
        },
        {
          "name": "data",
          "type": "tree",
          "content": null
        },
        {
          "name": "demo",
          "type": "tree",
          "content": null
        },
        {
          "name": "issue_template.md",
          "type": "blob",
          "size": 0.1416015625,
          "content": "<!--\n    Please provide as much as detail and example as you can.\n    You can add screenshots if appropriate.\n-->\n\n- **OS:**\n- **PyQt version:**\n"
        },
        {
          "name": "labelImg.py",
          "type": "blob",
          "size": 70.1923828125,
          "content": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\nimport argparse\nimport codecs\nimport os.path\nimport platform\nimport shutil\nimport sys\nimport webbrowser as wb\nfrom functools import partial\n\ntry:\n    from PyQt5.QtGui import *\n    from PyQt5.QtCore import *\n    from PyQt5.QtWidgets import *\nexcept ImportError:\n    # needed for py3+qt4\n    # Ref:\n    # http://pyqt.sourceforge.net/Docs/PyQt4/incompatible_apis.html\n    # http://stackoverflow.com/questions/21217399/pyqt4-qtcore-qvariant-object-instead-of-a-string\n    if sys.version_info.major >= 3:\n        import sip\n        sip.setapi('QVariant', 2)\n    from PyQt4.QtGui import *\n    from PyQt4.QtCore import *\n\nfrom libs.combobox import ComboBox\nfrom libs.default_label_combobox import DefaultLabelComboBox\nfrom libs.resources import *\nfrom libs.constants import *\nfrom libs.utils import *\nfrom libs.settings import Settings\nfrom libs.shape import Shape, DEFAULT_LINE_COLOR, DEFAULT_FILL_COLOR\nfrom libs.stringBundle import StringBundle\nfrom libs.canvas import Canvas\nfrom libs.zoomWidget import ZoomWidget\nfrom libs.lightWidget import LightWidget\nfrom libs.labelDialog import LabelDialog\nfrom libs.colorDialog import ColorDialog\nfrom libs.labelFile import LabelFile, LabelFileError, LabelFileFormat\nfrom libs.toolBar import ToolBar\nfrom libs.pascal_voc_io import PascalVocReader\nfrom libs.pascal_voc_io import XML_EXT\nfrom libs.yolo_io import YoloReader\nfrom libs.yolo_io import TXT_EXT\nfrom libs.create_ml_io import CreateMLReader\nfrom libs.create_ml_io import JSON_EXT\nfrom libs.ustr import ustr\nfrom libs.hashableQListWidgetItem import HashableQListWidgetItem\n\n__appname__ = 'labelImg'\n\n\nclass WindowMixin(object):\n\n    def menu(self, title, actions=None):\n        menu = self.menuBar().addMenu(title)\n        if actions:\n            add_actions(menu, actions)\n        return menu\n\n    def toolbar(self, title, actions=None):\n        toolbar = ToolBar(title)\n        toolbar.setObjectName(u'%sToolBar' % title)\n        # toolbar.setOrientation(Qt.Vertical)\n        toolbar.setToolButtonStyle(Qt.ToolButtonTextUnderIcon)\n        if actions:\n            add_actions(toolbar, actions)\n        self.addToolBar(Qt.LeftToolBarArea, toolbar)\n        return toolbar\n\n\nclass MainWindow(QMainWindow, WindowMixin):\n    FIT_WINDOW, FIT_WIDTH, MANUAL_ZOOM = list(range(3))\n\n    def __init__(self, default_filename=None, default_prefdef_class_file=None, default_save_dir=None):\n        super(MainWindow, self).__init__()\n        self.setWindowTitle(__appname__)\n\n        # Load setting in the main thread\n        self.settings = Settings()\n        self.settings.load()\n        settings = self.settings\n\n        self.os_name = platform.system()\n\n        # Load string bundle for i18n\n        self.string_bundle = StringBundle.get_bundle()\n        get_str = lambda str_id: self.string_bundle.get_string(str_id)\n\n        # Save as Pascal voc xml\n        self.default_save_dir = default_save_dir\n        self.label_file_format = settings.get(SETTING_LABEL_FILE_FORMAT, LabelFileFormat.PASCAL_VOC)\n\n        # For loading all image under a directory\n        self.m_img_list = []\n        self.dir_name = None\n        self.label_hist = []\n        self.last_open_dir = None\n        self.cur_img_idx = 0\n        self.img_count = len(self.m_img_list)\n\n        # Whether we need to save or not.\n        self.dirty = False\n\n        self._no_selection_slot = False\n        self._beginner = True\n        self.screencast = \"https://youtu.be/p0nR2YsCY_U\"\n\n        # Load predefined classes to the list\n        self.load_predefined_classes(default_prefdef_class_file)\n\n        if self.label_hist:\n            self.default_label = self.label_hist[0]\n        else:\n            print(\"Not find:/data/predefined_classes.txt (optional)\")\n\n        # Main widgets and related state.\n        self.label_dialog = LabelDialog(parent=self, list_item=self.label_hist)\n\n        self.items_to_shapes = {}\n        self.shapes_to_items = {}\n        self.prev_label_text = ''\n\n        list_layout = QVBoxLayout()\n        list_layout.setContentsMargins(0, 0, 0, 0)\n\n        # Create a widget for using default label\n        self.use_default_label_checkbox = QCheckBox(get_str('useDefaultLabel'))\n        self.use_default_label_checkbox.setChecked(False)\n        self.default_label_combo_box = DefaultLabelComboBox(self,items=self.label_hist)\n\n        use_default_label_qhbox_layout = QHBoxLayout()\n        use_default_label_qhbox_layout.addWidget(self.use_default_label_checkbox)\n        use_default_label_qhbox_layout.addWidget(self.default_label_combo_box)\n        use_default_label_container = QWidget()\n        use_default_label_container.setLayout(use_default_label_qhbox_layout)\n\n        # Create a widget for edit and diffc button\n        self.diffc_button = QCheckBox(get_str('useDifficult'))\n        self.diffc_button.setChecked(False)\n        self.diffc_button.stateChanged.connect(self.button_state)\n        self.edit_button = QToolButton()\n        self.edit_button.setToolButtonStyle(Qt.ToolButtonTextBesideIcon)\n\n        # Add some of widgets to list_layout\n        list_layout.addWidget(self.edit_button)\n        list_layout.addWidget(self.diffc_button)\n        list_layout.addWidget(use_default_label_container)\n\n        # Create and add combobox for showing unique labels in group\n        self.combo_box = ComboBox(self)\n        list_layout.addWidget(self.combo_box)\n\n        # Create and add a widget for showing current label items\n        self.label_list = QListWidget()\n        label_list_container = QWidget()\n        label_list_container.setLayout(list_layout)\n        self.label_list.itemActivated.connect(self.label_selection_changed)\n        self.label_list.itemSelectionChanged.connect(self.label_selection_changed)\n        self.label_list.itemDoubleClicked.connect(self.edit_label)\n        # Connect to itemChanged to detect checkbox changes.\n        self.label_list.itemChanged.connect(self.label_item_changed)\n        list_layout.addWidget(self.label_list)\n\n\n\n        self.dock = QDockWidget(get_str('boxLabelText'), self)\n        self.dock.setObjectName(get_str('labels'))\n        self.dock.setWidget(label_list_container)\n\n        self.file_list_widget = QListWidget()\n        self.file_list_widget.itemDoubleClicked.connect(self.file_item_double_clicked)\n        file_list_layout = QVBoxLayout()\n        file_list_layout.setContentsMargins(0, 0, 0, 0)\n        file_list_layout.addWidget(self.file_list_widget)\n        file_list_container = QWidget()\n        file_list_container.setLayout(file_list_layout)\n        self.file_dock = QDockWidget(get_str('fileList'), self)\n        self.file_dock.setObjectName(get_str('files'))\n        self.file_dock.setWidget(file_list_container)\n\n        self.zoom_widget = ZoomWidget()\n        self.light_widget = LightWidget(get_str('lightWidgetTitle'))\n        self.color_dialog = ColorDialog(parent=self)\n\n        self.canvas = Canvas(parent=self)\n        self.canvas.zoomRequest.connect(self.zoom_request)\n        self.canvas.lightRequest.connect(self.light_request)\n        self.canvas.set_drawing_shape_to_square(settings.get(SETTING_DRAW_SQUARE, False))\n\n        scroll = QScrollArea()\n        scroll.setWidget(self.canvas)\n        scroll.setWidgetResizable(True)\n        self.scroll_bars = {\n            Qt.Vertical: scroll.verticalScrollBar(),\n            Qt.Horizontal: scroll.horizontalScrollBar()\n        }\n        self.scroll_area = scroll\n        self.canvas.scrollRequest.connect(self.scroll_request)\n\n        self.canvas.newShape.connect(self.new_shape)\n        self.canvas.shapeMoved.connect(self.set_dirty)\n        self.canvas.selectionChanged.connect(self.shape_selection_changed)\n        self.canvas.drawingPolygon.connect(self.toggle_drawing_sensitive)\n\n        self.setCentralWidget(scroll)\n        self.addDockWidget(Qt.RightDockWidgetArea, self.dock)\n        self.addDockWidget(Qt.RightDockWidgetArea, self.file_dock)\n        self.file_dock.setFeatures(QDockWidget.DockWidgetFloatable)\n\n        self.dock_features = QDockWidget.DockWidgetClosable | QDockWidget.DockWidgetFloatable\n        self.dock.setFeatures(self.dock.features() ^ self.dock_features)\n\n        # Actions\n        action = partial(new_action, self)\n        quit = action(get_str('quit'), self.close,\n                      'Ctrl+Q', 'quit', get_str('quitApp'))\n\n        open = action(get_str('openFile'), self.open_file,\n                      'Ctrl+O', 'open', get_str('openFileDetail'))\n\n        open_dir = action(get_str('openDir'), self.open_dir_dialog,\n                          'Ctrl+u', 'open', get_str('openDir'))\n\n        change_save_dir = action(get_str('changeSaveDir'), self.change_save_dir_dialog,\n                                 'Ctrl+r', 'open', get_str('changeSavedAnnotationDir'))\n\n        open_annotation = action(get_str('openAnnotation'), self.open_annotation_dialog,\n                                 'Ctrl+Shift+O', 'open', get_str('openAnnotationDetail'))\n        copy_prev_bounding = action(get_str('copyPrevBounding'), self.copy_previous_bounding_boxes, 'Ctrl+v', 'copy', get_str('copyPrevBounding'))\n\n        open_next_image = action(get_str('nextImg'), self.open_next_image,\n                                 'd', 'next', get_str('nextImgDetail'))\n\n        open_prev_image = action(get_str('prevImg'), self.open_prev_image,\n                                 'a', 'prev', get_str('prevImgDetail'))\n\n        verify = action(get_str('verifyImg'), self.verify_image,\n                        'space', 'verify', get_str('verifyImgDetail'))\n\n        save = action(get_str('save'), self.save_file,\n                      'Ctrl+S', 'save', get_str('saveDetail'), enabled=False)\n\n        def get_format_meta(format):\n            \"\"\"\n            returns a tuple containing (title, icon_name) of the selected format\n            \"\"\"\n            if format == LabelFileFormat.PASCAL_VOC:\n                return '&PascalVOC', 'format_voc'\n            elif format == LabelFileFormat.YOLO:\n                return '&YOLO', 'format_yolo'\n            elif format == LabelFileFormat.CREATE_ML:\n                return '&CreateML', 'format_createml'\n\n        save_format = action(get_format_meta(self.label_file_format)[0],\n                             self.change_format, 'Ctrl+Y',\n                             get_format_meta(self.label_file_format)[1],\n                             get_str('changeSaveFormat'), enabled=True)\n\n        save_as = action(get_str('saveAs'), self.save_file_as,\n                         'Ctrl+Shift+S', 'save-as', get_str('saveAsDetail'), enabled=False)\n\n        close = action(get_str('closeCur'), self.close_file, 'Ctrl+W', 'close', get_str('closeCurDetail'))\n\n        delete_image = action(get_str('deleteImg'), self.delete_image, 'Ctrl+Shift+D', 'close', get_str('deleteImgDetail'))\n\n        reset_all = action(get_str('resetAll'), self.reset_all, None, 'resetall', get_str('resetAllDetail'))\n\n        color1 = action(get_str('boxLineColor'), self.choose_color1,\n                        'Ctrl+L', 'color_line', get_str('boxLineColorDetail'))\n\n        create_mode = action(get_str('crtBox'), self.set_create_mode,\n                             'w', 'new', get_str('crtBoxDetail'), enabled=False)\n        edit_mode = action(get_str('editBox'), self.set_edit_mode,\n                           'Ctrl+J', 'edit', get_str('editBoxDetail'), enabled=False)\n\n        create = action(get_str('crtBox'), self.create_shape,\n                        'w', 'new', get_str('crtBoxDetail'), enabled=False)\n        delete = action(get_str('delBox'), self.delete_selected_shape,\n                        'Delete', 'delete', get_str('delBoxDetail'), enabled=False)\n        copy = action(get_str('dupBox'), self.copy_selected_shape,\n                      'Ctrl+D', 'copy', get_str('dupBoxDetail'),\n                      enabled=False)\n\n        advanced_mode = action(get_str('advancedMode'), self.toggle_advanced_mode,\n                               'Ctrl+Shift+A', 'expert', get_str('advancedModeDetail'),\n                               checkable=True)\n\n        hide_all = action(get_str('hideAllBox'), partial(self.toggle_polygons, False),\n                          'Ctrl+H', 'hide', get_str('hideAllBoxDetail'),\n                          enabled=False)\n        show_all = action(get_str('showAllBox'), partial(self.toggle_polygons, True),\n                          'Ctrl+A', 'hide', get_str('showAllBoxDetail'),\n                          enabled=False)\n\n        help_default = action(get_str('tutorialDefault'), self.show_default_tutorial_dialog, None, 'help', get_str('tutorialDetail'))\n        show_info = action(get_str('info'), self.show_info_dialog, None, 'help', get_str('info'))\n        show_shortcut = action(get_str('shortcut'), self.show_shortcuts_dialog, None, 'help', get_str('shortcut'))\n\n        zoom = QWidgetAction(self)\n        zoom.setDefaultWidget(self.zoom_widget)\n        self.zoom_widget.setWhatsThis(\n            u\"Zoom in or out of the image. Also accessible with\"\n            \" %s and %s from the canvas.\" % (format_shortcut(\"Ctrl+[-+]\"),\n                                             format_shortcut(\"Ctrl+Wheel\")))\n        self.zoom_widget.setEnabled(False)\n\n        zoom_in = action(get_str('zoomin'), partial(self.add_zoom, 10),\n                         'Ctrl++', 'zoom-in', get_str('zoominDetail'), enabled=False)\n        zoom_out = action(get_str('zoomout'), partial(self.add_zoom, -10),\n                          'Ctrl+-', 'zoom-out', get_str('zoomoutDetail'), enabled=False)\n        zoom_org = action(get_str('originalsize'), partial(self.set_zoom, 100),\n                          'Ctrl+=', 'zoom', get_str('originalsizeDetail'), enabled=False)\n        fit_window = action(get_str('fitWin'), self.set_fit_window,\n                            'Ctrl+F', 'fit-window', get_str('fitWinDetail'),\n                            checkable=True, enabled=False)\n        fit_width = action(get_str('fitWidth'), self.set_fit_width,\n                           'Ctrl+Shift+F', 'fit-width', get_str('fitWidthDetail'),\n                           checkable=True, enabled=False)\n        # Group zoom controls into a list for easier toggling.\n        zoom_actions = (self.zoom_widget, zoom_in, zoom_out,\n                        zoom_org, fit_window, fit_width)\n        self.zoom_mode = self.MANUAL_ZOOM\n        self.scalers = {\n            self.FIT_WINDOW: self.scale_fit_window,\n            self.FIT_WIDTH: self.scale_fit_width,\n            # Set to one to scale to 100% when loading files.\n            self.MANUAL_ZOOM: lambda: 1,\n        }\n\n        light = QWidgetAction(self)\n        light.setDefaultWidget(self.light_widget)\n        self.light_widget.setWhatsThis(\n            u\"Brighten or darken current image. Also accessible with\"\n            \" %s and %s from the canvas.\" % (format_shortcut(\"Ctrl+Shift+[-+]\"),\n                                             format_shortcut(\"Ctrl+Shift+Wheel\")))\n        self.light_widget.setEnabled(False)\n\n        light_brighten = action(get_str('lightbrighten'), partial(self.add_light, 10),\n                                'Ctrl+Shift++', 'light_lighten', get_str('lightbrightenDetail'), enabled=False)\n        light_darken = action(get_str('lightdarken'), partial(self.add_light, -10),\n                              'Ctrl+Shift+-', 'light_darken', get_str('lightdarkenDetail'), enabled=False)\n        light_org = action(get_str('lightreset'), partial(self.set_light, 50),\n                           'Ctrl+Shift+=', 'light_reset', get_str('lightresetDetail'), checkable=True, enabled=False)\n        light_org.setChecked(True)\n\n        # Group light controls into a list for easier toggling.\n        light_actions = (self.light_widget, light_brighten,\n                         light_darken, light_org)\n\n        edit = action(get_str('editLabel'), self.edit_label,\n                      'Ctrl+E', 'edit', get_str('editLabelDetail'),\n                      enabled=False)\n        self.edit_button.setDefaultAction(edit)\n\n        shape_line_color = action(get_str('shapeLineColor'), self.choose_shape_line_color,\n                                  icon='color_line', tip=get_str('shapeLineColorDetail'),\n                                  enabled=False)\n        shape_fill_color = action(get_str('shapeFillColor'), self.choose_shape_fill_color,\n                                  icon='color', tip=get_str('shapeFillColorDetail'),\n                                  enabled=False)\n\n        labels = self.dock.toggleViewAction()\n        labels.setText(get_str('showHide'))\n        labels.setShortcut('Ctrl+Shift+L')\n\n        # Label list context menu.\n        label_menu = QMenu()\n        add_actions(label_menu, (edit, delete))\n        self.label_list.setContextMenuPolicy(Qt.CustomContextMenu)\n        self.label_list.customContextMenuRequested.connect(\n            self.pop_label_list_menu)\n\n        # Draw squares/rectangles\n        self.draw_squares_option = QAction(get_str('drawSquares'), self)\n        self.draw_squares_option.setShortcut('Ctrl+Shift+R')\n        self.draw_squares_option.setCheckable(True)\n        self.draw_squares_option.setChecked(settings.get(SETTING_DRAW_SQUARE, False))\n        self.draw_squares_option.triggered.connect(self.toggle_draw_square)\n\n        # Store actions for further handling.\n        self.actions = Struct(save=save, save_format=save_format, saveAs=save_as, open=open, close=close, resetAll=reset_all, deleteImg=delete_image,\n                              lineColor=color1, create=create, delete=delete, edit=edit, copy=copy,\n                              createMode=create_mode, editMode=edit_mode, advancedMode=advanced_mode,\n                              shapeLineColor=shape_line_color, shapeFillColor=shape_fill_color,\n                              zoom=zoom, zoomIn=zoom_in, zoomOut=zoom_out, zoomOrg=zoom_org,\n                              fitWindow=fit_window, fitWidth=fit_width,\n                              zoomActions=zoom_actions,\n                              lightBrighten=light_brighten, lightDarken=light_darken, lightOrg=light_org,\n                              lightActions=light_actions,\n                              fileMenuActions=(\n                                  open, open_dir, save, save_as, close, reset_all, quit),\n                              beginner=(), advanced=(),\n                              editMenu=(edit, copy, delete,\n                                        None, color1, self.draw_squares_option),\n                              beginnerContext=(create, edit, copy, delete),\n                              advancedContext=(create_mode, edit_mode, edit, copy,\n                                               delete, shape_line_color, shape_fill_color),\n                              onLoadActive=(\n                                  close, create, create_mode, edit_mode),\n                              onShapesPresent=(save_as, hide_all, show_all))\n\n        self.menus = Struct(\n            file=self.menu(get_str('menu_file')),\n            edit=self.menu(get_str('menu_edit')),\n            view=self.menu(get_str('menu_view')),\n            help=self.menu(get_str('menu_help')),\n            recentFiles=QMenu(get_str('menu_openRecent')),\n            labelList=label_menu)\n\n        # Auto saving : Enable auto saving if pressing next\n        self.auto_saving = QAction(get_str('autoSaveMode'), self)\n        self.auto_saving.setCheckable(True)\n        self.auto_saving.setChecked(settings.get(SETTING_AUTO_SAVE, False))\n        # Sync single class mode from PR#106\n        self.single_class_mode = QAction(get_str('singleClsMode'), self)\n        self.single_class_mode.setShortcut(\"Ctrl+Shift+S\")\n        self.single_class_mode.setCheckable(True)\n        self.single_class_mode.setChecked(settings.get(SETTING_SINGLE_CLASS, False))\n        self.lastLabel = None\n        # Add option to enable/disable labels being displayed at the top of bounding boxes\n        self.display_label_option = QAction(get_str('displayLabel'), self)\n        self.display_label_option.setShortcut(\"Ctrl+Shift+P\")\n        self.display_label_option.setCheckable(True)\n        self.display_label_option.setChecked(settings.get(SETTING_PAINT_LABEL, False))\n        self.display_label_option.triggered.connect(self.toggle_paint_labels_option)\n\n        add_actions(self.menus.file,\n                    (open, open_dir, change_save_dir, open_annotation, copy_prev_bounding, self.menus.recentFiles, save, save_format, save_as, close, reset_all, delete_image, quit))\n        add_actions(self.menus.help, (help_default, show_info, show_shortcut))\n        add_actions(self.menus.view, (\n            self.auto_saving,\n            self.single_class_mode,\n            self.display_label_option,\n            labels, advanced_mode, None,\n            hide_all, show_all, None,\n            zoom_in, zoom_out, zoom_org, None,\n            fit_window, fit_width, None,\n            light_brighten, light_darken, light_org))\n\n        self.menus.file.aboutToShow.connect(self.update_file_menu)\n\n        # Custom context menu for the canvas widget:\n        add_actions(self.canvas.menus[0], self.actions.beginnerContext)\n        add_actions(self.canvas.menus[1], (\n            action('&Copy here', self.copy_shape),\n            action('&Move here', self.move_shape)))\n\n        self.tools = self.toolbar('Tools')\n        self.actions.beginner = (\n            open, open_dir, change_save_dir, open_next_image, open_prev_image, verify, save, save_format, None, create, copy, delete, None,\n            zoom_in, zoom, zoom_out, fit_window, fit_width, None,\n            light_brighten, light, light_darken, light_org)\n\n        self.actions.advanced = (\n            open, open_dir, change_save_dir, open_next_image, open_prev_image, save, save_format, None,\n            create_mode, edit_mode, None,\n            hide_all, show_all)\n\n        self.statusBar().showMessage('%s started.' % __appname__)\n        self.statusBar().show()\n\n        # Application state.\n        self.image = QImage()\n        self.file_path = ustr(default_filename)\n        self.last_open_dir = None\n        self.recent_files = []\n        self.max_recent = 7\n        self.line_color = None\n        self.fill_color = None\n        self.zoom_level = 100\n        self.fit_window = False\n        # Add Chris\n        self.difficult = False\n\n        # Fix the compatible issue for qt4 and qt5. Convert the QStringList to python list\n        if settings.get(SETTING_RECENT_FILES):\n            if have_qstring():\n                recent_file_qstring_list = settings.get(SETTING_RECENT_FILES)\n                self.recent_files = [ustr(i) for i in recent_file_qstring_list]\n            else:\n                self.recent_files = recent_file_qstring_list = settings.get(SETTING_RECENT_FILES)\n\n        size = settings.get(SETTING_WIN_SIZE, QSize(600, 500))\n        position = QPoint(0, 0)\n        saved_position = settings.get(SETTING_WIN_POSE, position)\n        # Fix the multiple monitors issue\n        for i in range(QApplication.desktop().screenCount()):\n            if QApplication.desktop().availableGeometry(i).contains(saved_position):\n                position = saved_position\n                break\n        self.resize(size)\n        self.move(position)\n        save_dir = ustr(settings.get(SETTING_SAVE_DIR, None))\n        self.last_open_dir = ustr(settings.get(SETTING_LAST_OPEN_DIR, None))\n        if self.default_save_dir is None and save_dir is not None and os.path.exists(save_dir):\n            self.default_save_dir = save_dir\n            self.statusBar().showMessage('%s started. Annotation will be saved to %s' %\n                                         (__appname__, self.default_save_dir))\n            self.statusBar().show()\n\n        self.restoreState(settings.get(SETTING_WIN_STATE, QByteArray()))\n        Shape.line_color = self.line_color = QColor(settings.get(SETTING_LINE_COLOR, DEFAULT_LINE_COLOR))\n        Shape.fill_color = self.fill_color = QColor(settings.get(SETTING_FILL_COLOR, DEFAULT_FILL_COLOR))\n        self.canvas.set_drawing_color(self.line_color)\n        # Add chris\n        Shape.difficult = self.difficult\n\n        def xbool(x):\n            if isinstance(x, QVariant):\n                return x.toBool()\n            return bool(x)\n\n        if xbool(settings.get(SETTING_ADVANCE_MODE, False)):\n            self.actions.advancedMode.setChecked(True)\n            self.toggle_advanced_mode()\n\n        # Populate the File menu dynamically.\n        self.update_file_menu()\n\n        # Since loading the file may take some time, make sure it runs in the background.\n        if self.file_path and os.path.isdir(self.file_path):\n            self.queue_event(partial(self.import_dir_images, self.file_path or \"\"))\n        elif self.file_path:\n            self.queue_event(partial(self.load_file, self.file_path or \"\"))\n\n        # Callbacks:\n        self.zoom_widget.valueChanged.connect(self.paint_canvas)\n        self.light_widget.valueChanged.connect(self.paint_canvas)\n\n        self.populate_mode_actions()\n\n        # Display cursor coordinates at the right of status bar\n        self.label_coordinates = QLabel('')\n        self.statusBar().addPermanentWidget(self.label_coordinates)\n\n        # Open Dir if default file\n        if self.file_path and os.path.isdir(self.file_path):\n            self.open_dir_dialog(dir_path=self.file_path, silent=True)\n\n    def keyReleaseEvent(self, event):\n        if event.key() == Qt.Key_Control:\n            self.canvas.set_drawing_shape_to_square(False)\n\n    def keyPressEvent(self, event):\n        if event.key() == Qt.Key_Control:\n            # Draw rectangle if Ctrl is pressed\n            self.canvas.set_drawing_shape_to_square(True)\n\n    # Support Functions #\n    def set_format(self, save_format):\n        if save_format == FORMAT_PASCALVOC:\n            self.actions.save_format.setText(FORMAT_PASCALVOC)\n            self.actions.save_format.setIcon(new_icon(\"format_voc\"))\n            self.label_file_format = LabelFileFormat.PASCAL_VOC\n            LabelFile.suffix = XML_EXT\n\n        elif save_format == FORMAT_YOLO:\n            self.actions.save_format.setText(FORMAT_YOLO)\n            self.actions.save_format.setIcon(new_icon(\"format_yolo\"))\n            self.label_file_format = LabelFileFormat.YOLO\n            LabelFile.suffix = TXT_EXT\n\n        elif save_format == FORMAT_CREATEML:\n            self.actions.save_format.setText(FORMAT_CREATEML)\n            self.actions.save_format.setIcon(new_icon(\"format_createml\"))\n            self.label_file_format = LabelFileFormat.CREATE_ML\n            LabelFile.suffix = JSON_EXT\n\n    def change_format(self):\n        if self.label_file_format == LabelFileFormat.PASCAL_VOC:\n            self.set_format(FORMAT_YOLO)\n        elif self.label_file_format == LabelFileFormat.YOLO:\n            self.set_format(FORMAT_CREATEML)\n        elif self.label_file_format == LabelFileFormat.CREATE_ML:\n            self.set_format(FORMAT_PASCALVOC)\n        else:\n            raise ValueError('Unknown label file format.')\n        self.set_dirty()\n\n    def no_shapes(self):\n        return not self.items_to_shapes\n\n    def toggle_advanced_mode(self, value=True):\n        self._beginner = not value\n        self.canvas.set_editing(True)\n        self.populate_mode_actions()\n        self.edit_button.setVisible(not value)\n        if value:\n            self.actions.createMode.setEnabled(True)\n            self.actions.editMode.setEnabled(False)\n            self.dock.setFeatures(self.dock.features() | self.dock_features)\n        else:\n            self.dock.setFeatures(self.dock.features() ^ self.dock_features)\n\n    def populate_mode_actions(self):\n        if self.beginner():\n            tool, menu = self.actions.beginner, self.actions.beginnerContext\n        else:\n            tool, menu = self.actions.advanced, self.actions.advancedContext\n        self.tools.clear()\n        add_actions(self.tools, tool)\n        self.canvas.menus[0].clear()\n        add_actions(self.canvas.menus[0], menu)\n        self.menus.edit.clear()\n        actions = (self.actions.create,) if self.beginner()\\\n            else (self.actions.createMode, self.actions.editMode)\n        add_actions(self.menus.edit, actions + self.actions.editMenu)\n\n    def set_beginner(self):\n        self.tools.clear()\n        add_actions(self.tools, self.actions.beginner)\n\n    def set_advanced(self):\n        self.tools.clear()\n        add_actions(self.tools, self.actions.advanced)\n\n    def set_dirty(self):\n        self.dirty = True\n        self.actions.save.setEnabled(True)\n\n    def set_clean(self):\n        self.dirty = False\n        self.actions.save.setEnabled(False)\n        self.actions.create.setEnabled(True)\n\n    def toggle_actions(self, value=True):\n        \"\"\"Enable/Disable widgets which depend on an opened image.\"\"\"\n        for z in self.actions.zoomActions:\n            z.setEnabled(value)\n        for z in self.actions.lightActions:\n            z.setEnabled(value)\n        for action in self.actions.onLoadActive:\n            action.setEnabled(value)\n\n    def queue_event(self, function):\n        QTimer.singleShot(0, function)\n\n    def status(self, message, delay=5000):\n        self.statusBar().showMessage(message, delay)\n\n    def reset_state(self):\n        self.items_to_shapes.clear()\n        self.shapes_to_items.clear()\n        self.label_list.clear()\n        self.file_path = None\n        self.image_data = None\n        self.label_file = None\n        self.canvas.reset_state()\n        self.label_coordinates.clear()\n        self.combo_box.cb.clear()\n\n    def current_item(self):\n        items = self.label_list.selectedItems()\n        if items:\n            return items[0]\n        return None\n\n    def add_recent_file(self, file_path):\n        if file_path in self.recent_files:\n            self.recent_files.remove(file_path)\n        elif len(self.recent_files) >= self.max_recent:\n            self.recent_files.pop()\n        self.recent_files.insert(0, file_path)\n\n    def beginner(self):\n        return self._beginner\n\n    def advanced(self):\n        return not self.beginner()\n\n    def show_tutorial_dialog(self, browser='default', link=None):\n        if link is None:\n            link = self.screencast\n\n        if browser.lower() == 'default':\n            wb.open(link, new=2)\n        elif browser.lower() == 'chrome' and self.os_name == 'Windows':\n            if shutil.which(browser.lower()):  # 'chrome' not in wb._browsers in windows\n                wb.register('chrome', None, wb.BackgroundBrowser('chrome'))\n            else:\n                chrome_path=\"D:\\\\Program Files (x86)\\\\Google\\\\Chrome\\\\Application\\\\chrome.exe\"\n                if os.path.isfile(chrome_path):\n                    wb.register('chrome', None, wb.BackgroundBrowser(chrome_path))\n            try:\n                wb.get('chrome').open(link, new=2)\n            except:\n                wb.open(link, new=2)\n        elif browser.lower() in wb._browsers:\n            wb.get(browser.lower()).open(link, new=2)\n\n    def show_default_tutorial_dialog(self):\n        self.show_tutorial_dialog(browser='default')\n\n    def show_info_dialog(self):\n        from libs.__init__ import __version__\n        msg = u'Name:{0} \\nApp Version:{1} \\n{2} '.format(__appname__, __version__, sys.version_info)\n        QMessageBox.information(self, u'Information', msg)\n\n    def show_shortcuts_dialog(self):\n        self.show_tutorial_dialog(browser='default', link='https://github.com/tzutalin/labelImg#Hotkeys')\n\n    def create_shape(self):\n        assert self.beginner()\n        self.canvas.set_editing(False)\n        self.actions.create.setEnabled(False)\n\n    def toggle_drawing_sensitive(self, drawing=True):\n        \"\"\"In the middle of drawing, toggling between modes should be disabled.\"\"\"\n        self.actions.editMode.setEnabled(not drawing)\n        if not drawing and self.beginner():\n            # Cancel creation.\n            print('Cancel creation.')\n            self.canvas.set_editing(True)\n            self.canvas.restore_cursor()\n            self.actions.create.setEnabled(True)\n\n    def toggle_draw_mode(self, edit=True):\n        self.canvas.set_editing(edit)\n        self.actions.createMode.setEnabled(edit)\n        self.actions.editMode.setEnabled(not edit)\n\n    def set_create_mode(self):\n        assert self.advanced()\n        self.toggle_draw_mode(False)\n\n    def set_edit_mode(self):\n        assert self.advanced()\n        self.toggle_draw_mode(True)\n        self.label_selection_changed()\n\n    def update_file_menu(self):\n        curr_file_path = self.file_path\n\n        def exists(filename):\n            return os.path.exists(filename)\n        menu = self.menus.recentFiles\n        menu.clear()\n        files = [f for f in self.recent_files if f !=\n                 curr_file_path and exists(f)]\n        for i, f in enumerate(files):\n            icon = new_icon('labels')\n            action = QAction(\n                icon, '&%d %s' % (i + 1, QFileInfo(f).fileName()), self)\n            action.triggered.connect(partial(self.load_recent, f))\n            menu.addAction(action)\n\n    def pop_label_list_menu(self, point):\n        self.menus.labelList.exec_(self.label_list.mapToGlobal(point))\n\n    def edit_label(self):\n        if not self.canvas.editing():\n            return\n        item = self.current_item()\n        if not item:\n            return\n        text = self.label_dialog.pop_up(item.text())\n        if text is not None:\n            item.setText(text)\n            item.setBackground(generate_color_by_text(text))\n            self.set_dirty()\n            self.update_combo_box()\n\n    # Tzutalin 20160906 : Add file list and dock to move faster\n    def file_item_double_clicked(self, item=None):\n        self.cur_img_idx = self.m_img_list.index(ustr(item.text()))\n        filename = self.m_img_list[self.cur_img_idx]\n        if filename:\n            self.load_file(filename)\n\n    # Add chris\n    def button_state(self, item=None):\n        \"\"\" Function to handle difficult examples\n        Update on each object \"\"\"\n        if not self.canvas.editing():\n            return\n\n        item = self.current_item()\n        if not item:  # If not selected Item, take the first one\n            item = self.label_list.item(self.label_list.count() - 1)\n\n        difficult = self.diffc_button.isChecked()\n\n        try:\n            shape = self.items_to_shapes[item]\n        except:\n            pass\n        # Checked and Update\n        try:\n            if difficult != shape.difficult:\n                shape.difficult = difficult\n                self.set_dirty()\n            else:  # User probably changed item visibility\n                self.canvas.set_shape_visible(shape, item.checkState() == Qt.Checked)\n        except:\n            pass\n\n    # React to canvas signals.\n    def shape_selection_changed(self, selected=False):\n        if self._no_selection_slot:\n            self._no_selection_slot = False\n        else:\n            shape = self.canvas.selected_shape\n            if shape:\n                self.shapes_to_items[shape].setSelected(True)\n            else:\n                self.label_list.clearSelection()\n        self.actions.delete.setEnabled(selected)\n        self.actions.copy.setEnabled(selected)\n        self.actions.edit.setEnabled(selected)\n        self.actions.shapeLineColor.setEnabled(selected)\n        self.actions.shapeFillColor.setEnabled(selected)\n\n    def add_label(self, shape):\n        shape.paint_label = self.display_label_option.isChecked()\n        item = HashableQListWidgetItem(shape.label)\n        item.setFlags(item.flags() | Qt.ItemIsUserCheckable)\n        item.setCheckState(Qt.Checked)\n        item.setBackground(generate_color_by_text(shape.label))\n        self.items_to_shapes[item] = shape\n        self.shapes_to_items[shape] = item\n        self.label_list.addItem(item)\n        for action in self.actions.onShapesPresent:\n            action.setEnabled(True)\n        self.update_combo_box()\n\n    def remove_label(self, shape):\n        if shape is None:\n            # print('rm empty label')\n            return\n        item = self.shapes_to_items[shape]\n        self.label_list.takeItem(self.label_list.row(item))\n        del self.shapes_to_items[shape]\n        del self.items_to_shapes[item]\n        self.update_combo_box()\n\n    def load_labels(self, shapes):\n        s = []\n        for label, points, line_color, fill_color, difficult in shapes:\n            shape = Shape(label=label)\n            for x, y in points:\n\n                # Ensure the labels are within the bounds of the image. If not, fix them.\n                x, y, snapped = self.canvas.snap_point_to_canvas(x, y)\n                if snapped:\n                    self.set_dirty()\n\n                shape.add_point(QPointF(x, y))\n            shape.difficult = difficult\n            shape.close()\n            s.append(shape)\n\n            if line_color:\n                shape.line_color = QColor(*line_color)\n            else:\n                shape.line_color = generate_color_by_text(label)\n\n            if fill_color:\n                shape.fill_color = QColor(*fill_color)\n            else:\n                shape.fill_color = generate_color_by_text(label)\n\n            self.add_label(shape)\n        self.update_combo_box()\n        self.canvas.load_shapes(s)\n\n    def update_combo_box(self):\n        # Get the unique labels and add them to the Combobox.\n        items_text_list = [str(self.label_list.item(i).text()) for i in range(self.label_list.count())]\n\n        unique_text_list = list(set(items_text_list))\n        # Add a null row for showing all the labels\n        unique_text_list.append(\"\")\n        unique_text_list.sort()\n\n        self.combo_box.update_items(unique_text_list)\n\n    def save_labels(self, annotation_file_path):\n        annotation_file_path = ustr(annotation_file_path)\n        if self.label_file is None:\n            self.label_file = LabelFile()\n            self.label_file.verified = self.canvas.verified\n\n        def format_shape(s):\n            return dict(label=s.label,\n                        line_color=s.line_color.getRgb(),\n                        fill_color=s.fill_color.getRgb(),\n                        points=[(p.x(), p.y()) for p in s.points],\n                        # add chris\n                        difficult=s.difficult)\n\n        shapes = [format_shape(shape) for shape in self.canvas.shapes]\n        # Can add different annotation formats here\n        try:\n            if self.label_file_format == LabelFileFormat.PASCAL_VOC:\n                if annotation_file_path[-4:].lower() != \".xml\":\n                    annotation_file_path += XML_EXT\n                self.label_file.save_pascal_voc_format(annotation_file_path, shapes, self.file_path, self.image_data,\n                                                       self.line_color.getRgb(), self.fill_color.getRgb())\n            elif self.label_file_format == LabelFileFormat.YOLO:\n                if annotation_file_path[-4:].lower() != \".txt\":\n                    annotation_file_path += TXT_EXT\n                self.label_file.save_yolo_format(annotation_file_path, shapes, self.file_path, self.image_data, self.label_hist,\n                                                 self.line_color.getRgb(), self.fill_color.getRgb())\n            elif self.label_file_format == LabelFileFormat.CREATE_ML:\n                if annotation_file_path[-5:].lower() != \".json\":\n                    annotation_file_path += JSON_EXT\n                self.label_file.save_create_ml_format(annotation_file_path, shapes, self.file_path, self.image_data,\n                                                      self.label_hist, self.line_color.getRgb(), self.fill_color.getRgb())\n            else:\n                self.label_file.save(annotation_file_path, shapes, self.file_path, self.image_data,\n                                     self.line_color.getRgb(), self.fill_color.getRgb())\n            print('Image:{0} -> Annotation:{1}'.format(self.file_path, annotation_file_path))\n            return True\n        except LabelFileError as e:\n            self.error_message(u'Error saving label data', u'<b>%s</b>' % e)\n            return False\n\n    def copy_selected_shape(self):\n        self.add_label(self.canvas.copy_selected_shape())\n        # fix copy and delete\n        self.shape_selection_changed(True)\n\n    def combo_selection_changed(self, index):\n        text = self.combo_box.cb.itemText(index)\n        for i in range(self.label_list.count()):\n            if text == \"\":\n                self.label_list.item(i).setCheckState(2)\n            elif text != self.label_list.item(i).text():\n                self.label_list.item(i).setCheckState(0)\n            else:\n                self.label_list.item(i).setCheckState(2)\n\n    def default_label_combo_selection_changed(self, index):\n        self.default_label=self.label_hist[index]\n\n    def label_selection_changed(self):\n        item = self.current_item()\n        if item and self.canvas.editing():\n            self._no_selection_slot = True\n            self.canvas.select_shape(self.items_to_shapes[item])\n            shape = self.items_to_shapes[item]\n            # Add Chris\n            self.diffc_button.setChecked(shape.difficult)\n\n    def label_item_changed(self, item):\n        shape = self.items_to_shapes[item]\n        label = item.text()\n        if label != shape.label:\n            shape.label = item.text()\n            shape.line_color = generate_color_by_text(shape.label)\n            self.set_dirty()\n        else:  # User probably changed item visibility\n            self.canvas.set_shape_visible(shape, item.checkState() == Qt.Checked)\n\n    # Callback functions:\n    def new_shape(self):\n        \"\"\"Pop-up and give focus to the label editor.\n\n        position MUST be in global coordinates.\n        \"\"\"\n        if not self.use_default_label_checkbox.isChecked():\n            if len(self.label_hist) > 0:\n                self.label_dialog = LabelDialog(\n                    parent=self, list_item=self.label_hist)\n\n            # Sync single class mode from PR#106\n            if self.single_class_mode.isChecked() and self.lastLabel:\n                text = self.lastLabel\n            else:\n                text = self.label_dialog.pop_up(text=self.prev_label_text)\n                self.lastLabel = text\n        else:\n            text = self.default_label\n\n        # Add Chris\n        self.diffc_button.setChecked(False)\n        if text is not None:\n            self.prev_label_text = text\n            generate_color = generate_color_by_text(text)\n            shape = self.canvas.set_last_label(text, generate_color, generate_color)\n            self.add_label(shape)\n            if self.beginner():  # Switch to edit mode.\n                self.canvas.set_editing(True)\n                self.actions.create.setEnabled(True)\n            else:\n                self.actions.editMode.setEnabled(True)\n            self.set_dirty()\n\n            if text not in self.label_hist:\n                self.label_hist.append(text)\n        else:\n            # self.canvas.undoLastLine()\n            self.canvas.reset_all_lines()\n\n    def scroll_request(self, delta, orientation):\n        units = - delta / (8 * 15)\n        bar = self.scroll_bars[orientation]\n        bar.setValue(int(bar.value() + bar.singleStep() * units))\n\n    def set_zoom(self, value):\n        self.actions.fitWidth.setChecked(False)\n        self.actions.fitWindow.setChecked(False)\n        self.zoom_mode = self.MANUAL_ZOOM\n        # Arithmetic on scaling factor often results in float\n        # Convert to int to avoid type errors\n        self.zoom_widget.setValue(int(value))\n\n    def add_zoom(self, increment=10):\n        self.set_zoom(self.zoom_widget.value() + increment)\n\n    def zoom_request(self, delta):\n        # get the current scrollbar positions\n        # calculate the percentages ~ coordinates\n        h_bar = self.scroll_bars[Qt.Horizontal]\n        v_bar = self.scroll_bars[Qt.Vertical]\n\n        # get the current maximum, to know the difference after zooming\n        h_bar_max = h_bar.maximum()\n        v_bar_max = v_bar.maximum()\n\n        # get the cursor position and canvas size\n        # calculate the desired movement from 0 to 1\n        # where 0 = move left\n        #       1 = move right\n        # up and down analogous\n        cursor = QCursor()\n        pos = cursor.pos()\n        relative_pos = QWidget.mapFromGlobal(self, pos)\n\n        cursor_x = relative_pos.x()\n        cursor_y = relative_pos.y()\n\n        w = self.scroll_area.width()\n        h = self.scroll_area.height()\n\n        # the scaling from 0 to 1 has some padding\n        # you don't have to hit the very leftmost pixel for a maximum-left movement\n        margin = 0.1\n        move_x = (cursor_x - margin * w) / (w - 2 * margin * w)\n        move_y = (cursor_y - margin * h) / (h - 2 * margin * h)\n\n        # clamp the values from 0 to 1\n        move_x = min(max(move_x, 0), 1)\n        move_y = min(max(move_y, 0), 1)\n\n        # zoom in\n        units = delta // (8 * 15)\n        scale = 10\n        self.add_zoom(scale * units)\n\n        # get the difference in scrollbar values\n        # this is how far we can move\n        d_h_bar_max = h_bar.maximum() - h_bar_max\n        d_v_bar_max = v_bar.maximum() - v_bar_max\n\n        # get the new scrollbar values\n        new_h_bar_value = int(h_bar.value() + move_x * d_h_bar_max)\n        new_v_bar_value = int(v_bar.value() + move_y * d_v_bar_max)\n\n        h_bar.setValue(new_h_bar_value)\n        v_bar.setValue(new_v_bar_value)\n\n    def light_request(self, delta):\n        self.add_light(5*delta // (8 * 15))\n\n    def set_fit_window(self, value=True):\n        if value:\n            self.actions.fitWidth.setChecked(False)\n        self.zoom_mode = self.FIT_WINDOW if value else self.MANUAL_ZOOM\n        self.adjust_scale()\n\n    def set_fit_width(self, value=True):\n        if value:\n            self.actions.fitWindow.setChecked(False)\n        self.zoom_mode = self.FIT_WIDTH if value else self.MANUAL_ZOOM\n        self.adjust_scale()\n\n    def set_light(self, value):\n        self.actions.lightOrg.setChecked(int(value) == 50)\n        # Arithmetic on scaling factor often results in float\n        # Convert to int to avoid type errors\n        self.light_widget.setValue(int(value))\n\n    def add_light(self, increment=10):\n        self.set_light(self.light_widget.value() + increment)\n\n    def toggle_polygons(self, value):\n        for item, shape in self.items_to_shapes.items():\n            item.setCheckState(Qt.Checked if value else Qt.Unchecked)\n\n    def load_file(self, file_path=None):\n        \"\"\"Load the specified file, or the last opened file if None.\"\"\"\n        self.reset_state()\n        self.canvas.setEnabled(False)\n        if file_path is None:\n            file_path = self.settings.get(SETTING_FILENAME)\n        # Make sure that filePath is a regular python string, rather than QString\n        file_path = ustr(file_path)\n\n        # Fix bug: An  index error after select a directory when open a new file.\n        unicode_file_path = ustr(file_path)\n        unicode_file_path = os.path.abspath(unicode_file_path)\n        # Tzutalin 20160906 : Add file list and dock to move faster\n        # Highlight the file item\n        if unicode_file_path and self.file_list_widget.count() > 0:\n            if unicode_file_path in self.m_img_list:\n                index = self.m_img_list.index(unicode_file_path)\n                file_widget_item = self.file_list_widget.item(index)\n                file_widget_item.setSelected(True)\n            else:\n                self.file_list_widget.clear()\n                self.m_img_list.clear()\n\n        if unicode_file_path and os.path.exists(unicode_file_path):\n            if LabelFile.is_label_file(unicode_file_path):\n                try:\n                    self.label_file = LabelFile(unicode_file_path)\n                except LabelFileError as e:\n                    self.error_message(u'Error opening file',\n                                       (u\"<p><b>%s</b></p>\"\n                                        u\"<p>Make sure <i>%s</i> is a valid label file.\")\n                                       % (e, unicode_file_path))\n                    self.status(\"Error reading %s\" % unicode_file_path)\n                    \n                    return False\n                self.image_data = self.label_file.image_data\n                self.line_color = QColor(*self.label_file.lineColor)\n                self.fill_color = QColor(*self.label_file.fillColor)\n                self.canvas.verified = self.label_file.verified\n            else:\n                # Load image:\n                # read data first and store for saving into label file.\n                self.image_data = read(unicode_file_path, None)\n                self.label_file = None\n                self.canvas.verified = False\n\n            if isinstance(self.image_data, QImage):\n                image = self.image_data\n            else:\n                image = QImage.fromData(self.image_data)\n            if image.isNull():\n                self.error_message(u'Error opening file',\n                                   u\"<p>Make sure <i>%s</i> is a valid image file.\" % unicode_file_path)\n                self.status(\"Error reading %s\" % unicode_file_path)\n                return False\n            self.status(\"Loaded %s\" % os.path.basename(unicode_file_path))\n            self.image = image\n            self.file_path = unicode_file_path\n            self.canvas.load_pixmap(QPixmap.fromImage(image))\n            if self.label_file:\n                self.load_labels(self.label_file.shapes)\n            self.set_clean()\n            self.canvas.setEnabled(True)\n            self.adjust_scale(initial=True)\n            self.paint_canvas()\n            self.add_recent_file(self.file_path)\n            self.toggle_actions(True)\n            self.show_bounding_box_from_annotation_file(self.file_path)\n\n            counter = self.counter_str()\n            self.setWindowTitle(__appname__ + ' ' + file_path + ' ' + counter)\n\n            # Default : select last item if there is at least one item\n            if self.label_list.count():\n                self.label_list.setCurrentItem(self.label_list.item(self.label_list.count() - 1))\n                self.label_list.item(self.label_list.count() - 1).setSelected(True)\n\n            self.canvas.setFocus(True)\n            return True\n        return False\n\n    def counter_str(self):\n        \"\"\"\n        Converts image counter to string representation.\n        \"\"\"\n        return '[{} / {}]'.format(self.cur_img_idx + 1, self.img_count)\n\n    def show_bounding_box_from_annotation_file(self, file_path):\n        if self.default_save_dir is not None:\n            basename = os.path.basename(os.path.splitext(file_path)[0])\n            xml_path = os.path.join(self.default_save_dir, basename + XML_EXT)\n            txt_path = os.path.join(self.default_save_dir, basename + TXT_EXT)\n            json_path = os.path.join(self.default_save_dir, basename + JSON_EXT)\n\n            \"\"\"Annotation file priority:\n            PascalXML > YOLO\n            \"\"\"\n            if os.path.isfile(xml_path):\n                self.load_pascal_xml_by_filename(xml_path)\n            elif os.path.isfile(txt_path):\n                self.load_yolo_txt_by_filename(txt_path)\n            elif os.path.isfile(json_path):\n                self.load_create_ml_json_by_filename(json_path, file_path)\n\n        else:\n            xml_path = os.path.splitext(file_path)[0] + XML_EXT\n            txt_path = os.path.splitext(file_path)[0] + TXT_EXT\n            json_path = os.path.splitext(file_path)[0] + JSON_EXT\n\n            if os.path.isfile(xml_path):\n                self.load_pascal_xml_by_filename(xml_path)\n            elif os.path.isfile(txt_path):\n                self.load_yolo_txt_by_filename(txt_path)\n            elif os.path.isfile(json_path):\n                self.load_create_ml_json_by_filename(json_path, file_path)\n            \n\n    def resizeEvent(self, event):\n        if self.canvas and not self.image.isNull()\\\n           and self.zoom_mode != self.MANUAL_ZOOM:\n            self.adjust_scale()\n        super(MainWindow, self).resizeEvent(event)\n\n    def paint_canvas(self):\n        assert not self.image.isNull(), \"cannot paint null image\"\n        self.canvas.scale = 0.01 * self.zoom_widget.value()\n        self.canvas.overlay_color = self.light_widget.color()\n        self.canvas.label_font_size = int(0.02 * max(self.image.width(), self.image.height()))\n        self.canvas.adjustSize()\n        self.canvas.update()\n\n    def adjust_scale(self, initial=False):\n        value = self.scalers[self.FIT_WINDOW if initial else self.zoom_mode]()\n        self.zoom_widget.setValue(int(100 * value))\n\n    def scale_fit_window(self):\n        \"\"\"Figure out the size of the pixmap in order to fit the main widget.\"\"\"\n        e = 2.0  # So that no scrollbars are generated.\n        w1 = self.centralWidget().width() - e\n        h1 = self.centralWidget().height() - e\n        a1 = w1 / h1\n        # Calculate a new scale value based on the pixmap's aspect ratio.\n        w2 = self.canvas.pixmap.width() - 0.0\n        h2 = self.canvas.pixmap.height() - 0.0\n        a2 = w2 / h2\n        return w1 / w2 if a2 >= a1 else h1 / h2\n\n    def scale_fit_width(self):\n        # The epsilon does not seem to work too well here.\n        w = self.centralWidget().width() - 2.0\n        return w / self.canvas.pixmap.width()\n\n    def closeEvent(self, event):\n        if not self.may_continue():\n            event.ignore()\n        settings = self.settings\n        # If it loads images from dir, don't load it at the beginning\n        if self.dir_name is None:\n            settings[SETTING_FILENAME] = self.file_path if self.file_path else ''\n        else:\n            settings[SETTING_FILENAME] = ''\n\n        settings[SETTING_WIN_SIZE] = self.size()\n        settings[SETTING_WIN_POSE] = self.pos()\n        settings[SETTING_WIN_STATE] = self.saveState()\n        settings[SETTING_LINE_COLOR] = self.line_color\n        settings[SETTING_FILL_COLOR] = self.fill_color\n        settings[SETTING_RECENT_FILES] = self.recent_files\n        settings[SETTING_ADVANCE_MODE] = not self._beginner\n        if self.default_save_dir and os.path.exists(self.default_save_dir):\n            settings[SETTING_SAVE_DIR] = ustr(self.default_save_dir)\n        else:\n            settings[SETTING_SAVE_DIR] = ''\n\n        if self.last_open_dir and os.path.exists(self.last_open_dir):\n            settings[SETTING_LAST_OPEN_DIR] = self.last_open_dir\n        else:\n            settings[SETTING_LAST_OPEN_DIR] = ''\n\n        settings[SETTING_AUTO_SAVE] = self.auto_saving.isChecked()\n        settings[SETTING_SINGLE_CLASS] = self.single_class_mode.isChecked()\n        settings[SETTING_PAINT_LABEL] = self.display_label_option.isChecked()\n        settings[SETTING_DRAW_SQUARE] = self.draw_squares_option.isChecked()\n        settings[SETTING_LABEL_FILE_FORMAT] = self.label_file_format\n        settings.save()\n\n    def load_recent(self, filename):\n        if self.may_continue():\n            self.load_file(filename)\n\n    def scan_all_images(self, folder_path):\n        extensions = ['.%s' % fmt.data().decode(\"ascii\").lower() for fmt in QImageReader.supportedImageFormats()]\n        images = []\n\n        for root, dirs, files in os.walk(folder_path):\n            for file in files:\n                if file.lower().endswith(tuple(extensions)):\n                    relative_path = os.path.join(root, file)\n                    path = ustr(os.path.abspath(relative_path))\n                    images.append(path)\n        natural_sort(images, key=lambda x: x.lower())\n        return images\n\n    def change_save_dir_dialog(self, _value=False):\n        if self.default_save_dir is not None:\n            path = ustr(self.default_save_dir)\n        else:\n            path = '.'\n\n        dir_path = ustr(QFileDialog.getExistingDirectory(self,\n                                                         '%s - Save annotations to the directory' % __appname__, path,  QFileDialog.ShowDirsOnly\n                                                         | QFileDialog.DontResolveSymlinks))\n\n        if dir_path is not None and len(dir_path) > 1:\n            self.default_save_dir = dir_path\n\n        self.show_bounding_box_from_annotation_file(self.file_path)\n\n        self.statusBar().showMessage('%s . Annotation will be saved to %s' %\n                                     ('Change saved folder', self.default_save_dir))\n        self.statusBar().show()\n\n\n    def open_annotation_dialog(self, _value=False):\n        if self.file_path is None:\n            self.statusBar().showMessage('Please select image first')\n            self.statusBar().show()\n            return\n\n        path = os.path.dirname(ustr(self.file_path))\\\n            if self.file_path else '.'\n        if self.label_file_format == LabelFileFormat.PASCAL_VOC:\n            filters = \"Open Annotation XML file (%s)\" % ' '.join(['*.xml'])\n            filename = ustr(QFileDialog.getOpenFileName(self, '%s - Choose a xml file' % __appname__, path, filters))\n            if filename:\n                if isinstance(filename, (tuple, list)):\n                    filename = filename[0]\n            self.load_pascal_xml_by_filename(filename)\n\n        elif self.label_file_format == LabelFileFormat.CREATE_ML:\n            \n            filters = \"Open Annotation JSON file (%s)\" % ' '.join(['*.json'])\n            filename = ustr(QFileDialog.getOpenFileName(self, '%s - Choose a json file' % __appname__, path, filters))\n            if filename:\n                if isinstance(filename, (tuple, list)):\n                    filename = filename[0]\n\n            self.load_create_ml_json_by_filename(filename, self.file_path)         \n        \n\n    def open_dir_dialog(self, _value=False, dir_path=None, silent=False):\n        if not self.may_continue():\n            return\n\n        default_open_dir_path = dir_path if dir_path else '.'\n        if self.last_open_dir and os.path.exists(self.last_open_dir):\n            default_open_dir_path = self.last_open_dir\n        else:\n            default_open_dir_path = os.path.dirname(self.file_path) if self.file_path else '.'\n        if silent != True:\n            target_dir_path = ustr(QFileDialog.getExistingDirectory(self,\n                                                                    '%s - Open Directory' % __appname__, default_open_dir_path,\n                                                                    QFileDialog.ShowDirsOnly | QFileDialog.DontResolveSymlinks))\n        else:\n            target_dir_path = ustr(default_open_dir_path)\n        self.last_open_dir = target_dir_path\n        self.import_dir_images(target_dir_path)\n        self.default_save_dir = target_dir_path\n        if self.file_path:\n            self.show_bounding_box_from_annotation_file(file_path=self.file_path)\n\n    def import_dir_images(self, dir_path):\n        if not self.may_continue() or not dir_path:\n            return\n\n        self.last_open_dir = dir_path\n        self.dir_name = dir_path\n        self.file_path = None\n        self.file_list_widget.clear()\n        self.m_img_list = self.scan_all_images(dir_path)\n        self.img_count = len(self.m_img_list)\n        self.open_next_image()\n        for imgPath in self.m_img_list:\n            item = QListWidgetItem(imgPath)\n            self.file_list_widget.addItem(item)\n\n    def verify_image(self, _value=False):\n        # Proceeding next image without dialog if having any label\n        if self.file_path is not None:\n            try:\n                self.label_file.toggle_verify()\n            except AttributeError:\n                # If the labelling file does not exist yet, create if and\n                # re-save it with the verified attribute.\n                self.save_file()\n                if self.label_file is not None:\n                    self.label_file.toggle_verify()\n                else:\n                    return\n\n            self.canvas.verified = self.label_file.verified\n            self.paint_canvas()\n            self.save_file()\n\n    def open_prev_image(self, _value=False):\n        # Proceeding prev image without dialog if having any label\n        if self.auto_saving.isChecked():\n            if self.default_save_dir is not None:\n                if self.dirty is True:\n                    self.save_file()\n            else:\n                self.change_save_dir_dialog()\n                return\n\n        if not self.may_continue():\n            return\n\n        if self.img_count <= 0:\n            return\n\n        if self.file_path is None:\n            return\n\n        if self.cur_img_idx - 1 >= 0:\n            self.cur_img_idx -= 1\n            filename = self.m_img_list[self.cur_img_idx]\n            if filename:\n                self.load_file(filename)\n\n    def open_next_image(self, _value=False):\n        # Proceeding next image without dialog if having any label\n        if self.auto_saving.isChecked():\n            if self.default_save_dir is not None:\n                if self.dirty is True:\n                    self.save_file()\n            else:\n                self.change_save_dir_dialog()\n                return\n\n        if not self.may_continue():\n            return\n\n        if self.img_count <= 0:\n            return\n        \n        if not self.m_img_list:\n            return\n\n        filename = None\n        if self.file_path is None:\n            filename = self.m_img_list[0]\n            self.cur_img_idx = 0\n        else:\n            if self.cur_img_idx + 1 < self.img_count:\n                self.cur_img_idx += 1\n                filename = self.m_img_list[self.cur_img_idx]\n\n        if filename:\n            self.load_file(filename)\n\n    def open_file(self, _value=False):\n        if not self.may_continue():\n            return\n        path = os.path.dirname(ustr(self.file_path)) if self.file_path else '.'\n        formats = ['*.%s' % fmt.data().decode(\"ascii\").lower() for fmt in QImageReader.supportedImageFormats()]\n        filters = \"Image & Label files (%s)\" % ' '.join(formats + ['*%s' % LabelFile.suffix])\n        filename,_ = QFileDialog.getOpenFileName(self, '%s - Choose Image or Label file' % __appname__, path, filters)\n        if filename:\n            if isinstance(filename, (tuple, list)):\n                filename = filename[0]\n            self.cur_img_idx = 0\n            self.img_count = 1\n            self.load_file(filename)\n\n    def save_file(self, _value=False):\n        if self.default_save_dir is not None and len(ustr(self.default_save_dir)):\n            if self.file_path:\n                image_file_name = os.path.basename(self.file_path)\n                saved_file_name = os.path.splitext(image_file_name)[0]\n                saved_path = os.path.join(ustr(self.default_save_dir), saved_file_name)\n                self._save_file(saved_path)\n        else:\n            image_file_dir = os.path.dirname(self.file_path)\n            image_file_name = os.path.basename(self.file_path)\n            saved_file_name = os.path.splitext(image_file_name)[0]\n            saved_path = os.path.join(image_file_dir, saved_file_name)\n            self._save_file(saved_path if self.label_file\n                            else self.save_file_dialog(remove_ext=False))\n\n    def save_file_as(self, _value=False):\n        assert not self.image.isNull(), \"cannot save empty image\"\n        self._save_file(self.save_file_dialog())\n\n    def save_file_dialog(self, remove_ext=True):\n        caption = '%s - Choose File' % __appname__\n        filters = 'File (*%s)' % LabelFile.suffix\n        open_dialog_path = self.current_path()\n        dlg = QFileDialog(self, caption, open_dialog_path, filters)\n        dlg.setDefaultSuffix(LabelFile.suffix[1:])\n        dlg.setAcceptMode(QFileDialog.AcceptSave)\n        filename_without_extension = os.path.splitext(self.file_path)[0]\n        dlg.selectFile(filename_without_extension)\n        dlg.setOption(QFileDialog.DontUseNativeDialog, False)\n        if dlg.exec_():\n            full_file_path = ustr(dlg.selectedFiles()[0])\n            if remove_ext:\n                return os.path.splitext(full_file_path)[0]  # Return file path without the extension.\n            else:\n                return full_file_path\n        return ''\n\n    def _save_file(self, annotation_file_path):\n        if annotation_file_path and self.save_labels(annotation_file_path):\n            self.set_clean()\n            self.statusBar().showMessage('Saved to  %s' % annotation_file_path)\n            self.statusBar().show()\n\n    def close_file(self, _value=False):\n        if not self.may_continue():\n            return\n        self.reset_state()\n        self.set_clean()\n        self.toggle_actions(False)\n        self.canvas.setEnabled(False)\n        self.actions.saveAs.setEnabled(False)\n\n    def delete_image(self):\n        delete_path = self.file_path\n        if delete_path is not None:\n            idx = self.cur_img_idx\n            if os.path.exists(delete_path):\n                os.remove(delete_path)\n            self.import_dir_images(self.last_open_dir)\n            if self.img_count > 0:\n                self.cur_img_idx = min(idx, self.img_count - 1)\n                filename = self.m_img_list[self.cur_img_idx]\n                self.load_file(filename)\n            else:\n                self.close_file()\n\n    def reset_all(self):\n        self.settings.reset()\n        self.close()\n        process = QProcess()\n        process.startDetached(os.path.abspath(__file__))\n\n    def may_continue(self):\n        if not self.dirty:\n            return True\n        else:\n            discard_changes = self.discard_changes_dialog()\n            if discard_changes == QMessageBox.No:\n                return True\n            elif discard_changes == QMessageBox.Yes:\n                self.save_file()\n                return True\n            else:\n                return False\n\n    def discard_changes_dialog(self):\n        yes, no, cancel = QMessageBox.Yes, QMessageBox.No, QMessageBox.Cancel\n        msg = u'You have unsaved changes, would you like to save them and proceed?\\nClick \"No\" to undo all changes.'\n        return QMessageBox.warning(self, u'Attention', msg, yes | no | cancel)\n\n    def error_message(self, title, message):\n        return QMessageBox.critical(self, title,\n                                    '<p><b>%s</b></p>%s' % (title, message))\n\n    def current_path(self):\n        return os.path.dirname(self.file_path) if self.file_path else '.'\n\n    def choose_color1(self):\n        color = self.color_dialog.getColor(self.line_color, u'Choose line color',\n                                           default=DEFAULT_LINE_COLOR)\n        if color:\n            self.line_color = color\n            Shape.line_color = color\n            self.canvas.set_drawing_color(color)\n            self.canvas.update()\n            self.set_dirty()\n\n    def delete_selected_shape(self):\n        self.remove_label(self.canvas.delete_selected())\n        self.set_dirty()\n        if self.no_shapes():\n            for action in self.actions.onShapesPresent:\n                action.setEnabled(False)\n\n    def choose_shape_line_color(self):\n        color = self.color_dialog.getColor(self.line_color, u'Choose Line Color',\n                                           default=DEFAULT_LINE_COLOR)\n        if color:\n            self.canvas.selected_shape.line_color = color\n            self.canvas.update()\n            self.set_dirty()\n\n    def choose_shape_fill_color(self):\n        color = self.color_dialog.getColor(self.fill_color, u'Choose Fill Color',\n                                           default=DEFAULT_FILL_COLOR)\n        if color:\n            self.canvas.selected_shape.fill_color = color\n            self.canvas.update()\n            self.set_dirty()\n\n    def copy_shape(self):\n        if self.canvas.selected_shape is None:\n            # True if one accidentally touches the left mouse button before releasing\n            return\n        self.canvas.end_move(copy=True)\n        self.add_label(self.canvas.selected_shape)\n        self.set_dirty()\n\n    def move_shape(self):\n        self.canvas.end_move(copy=False)\n        self.set_dirty()\n\n    def load_predefined_classes(self, predef_classes_file):\n        if os.path.exists(predef_classes_file) is True:\n            with codecs.open(predef_classes_file, 'r', 'utf8') as f:\n                for line in f:\n                    line = line.strip()\n                    if self.label_hist is None:\n                        self.label_hist = [line]\n                    else:\n                        self.label_hist.append(line)\n\n    def load_pascal_xml_by_filename(self, xml_path):\n        if self.file_path is None:\n            return\n        if os.path.isfile(xml_path) is False:\n            return\n\n        self.set_format(FORMAT_PASCALVOC)\n\n        t_voc_parse_reader = PascalVocReader(xml_path)\n        shapes = t_voc_parse_reader.get_shapes()\n        self.load_labels(shapes)\n        self.canvas.verified = t_voc_parse_reader.verified\n\n    def load_yolo_txt_by_filename(self, txt_path):\n        if self.file_path is None:\n            return\n        if os.path.isfile(txt_path) is False:\n            return\n\n        self.set_format(FORMAT_YOLO)\n        t_yolo_parse_reader = YoloReader(txt_path, self.image)\n        shapes = t_yolo_parse_reader.get_shapes()\n        print(shapes)\n        self.load_labels(shapes)\n        self.canvas.verified = t_yolo_parse_reader.verified\n\n    def load_create_ml_json_by_filename(self, json_path, file_path):\n        if self.file_path is None:\n            return\n        if os.path.isfile(json_path) is False:\n            return\n\n        self.set_format(FORMAT_CREATEML)\n\n        create_ml_parse_reader = CreateMLReader(json_path, file_path)\n        shapes = create_ml_parse_reader.get_shapes()\n        self.load_labels(shapes)\n        self.canvas.verified = create_ml_parse_reader.verified\n\n    def copy_previous_bounding_boxes(self):\n        current_index = self.m_img_list.index(self.file_path)\n        if current_index - 1 >= 0:\n            prev_file_path = self.m_img_list[current_index - 1]\n            self.show_bounding_box_from_annotation_file(prev_file_path)\n            self.save_file()\n\n    def toggle_paint_labels_option(self):\n        for shape in self.canvas.shapes:\n            shape.paint_label = self.display_label_option.isChecked()\n\n    def toggle_draw_square(self):\n        self.canvas.set_drawing_shape_to_square(self.draw_squares_option.isChecked())\n\ndef inverted(color):\n    return QColor(*[255 - v for v in color.getRgb()])\n\n\ndef read(filename, default=None):\n    try:\n        reader = QImageReader(filename)\n        reader.setAutoTransform(True)\n        return reader.read()\n    except:\n        return default\n\n\ndef get_main_app(argv=None):\n    \"\"\"\n    Standard boilerplate Qt application code.\n    Do everything but app.exec_() -- so that we can test the application in one thread\n    \"\"\"\n    if not argv:\n        argv = []\n    app = QApplication(argv)\n    app.setApplicationName(__appname__)\n    app.setWindowIcon(new_icon(\"app\"))\n    # Tzutalin 201705+: Accept extra agruments to change predefined class file\n    argparser = argparse.ArgumentParser()\n    argparser.add_argument(\"image_dir\", nargs=\"?\")\n    argparser.add_argument(\"class_file\",\n                           default=os.path.join(os.path.dirname(__file__), \"data\", \"predefined_classes.txt\"),\n                           nargs=\"?\")\n    argparser.add_argument(\"save_dir\", nargs=\"?\")\n    args = argparser.parse_args(argv[1:])\n\n    args.image_dir = args.image_dir and os.path.normpath(args.image_dir)\n    args.class_file = args.class_file and os.path.normpath(args.class_file)\n    args.save_dir = args.save_dir and os.path.normpath(args.save_dir)\n\n    # Usage : labelImg.py image classFile saveDir\n    win = MainWindow(args.image_dir,\n                     args.class_file,\n                     args.save_dir)\n    win.show()\n    return app, win\n\n\ndef main():\n    \"\"\"construct main app and run it\"\"\"\n    app, _win = get_main_app(sys.argv)\n    return app.exec_()\n\nif __name__ == '__main__':\n    sys.exit(main())\n"
        },
        {
          "name": "libs",
          "type": "tree",
          "content": null
        },
        {
          "name": "readme",
          "type": "tree",
          "content": null
        },
        {
          "name": "requirements",
          "type": "tree",
          "content": null
        },
        {
          "name": "resources.qrc",
          "type": "blob",
          "size": 2.2255859375,
          "content": "<!DOCTYPE RCC><RCC version=\"1.0\">\n<qresource>\n\n<file alias=\"help\">resources/icons/help.png</file>\n<file alias=\"app\">resources/icons/app.png</file>\n<file alias=\"expert\">resources/icons/expert2.png</file>\n<file alias=\"done\">resources/icons/done.png</file>\n<file alias=\"file\">resources/icons/file.png</file>\n<file alias=\"labels\">resources/icons/labels.png</file>\n<file alias=\"new\">resources/icons/objects.png</file>\n<file alias=\"close\">resources/icons/close.png</file>\n<file alias=\"fit-width\">resources/icons/fit-width.png</file>\n<file alias=\"fit-window\">resources/icons/fit-window.png</file>\n<file alias=\"undo\">resources/icons/undo.png</file>\n<file alias=\"hide\">resources/icons/eye.png</file>\n<file alias=\"quit\">resources/icons/quit.png</file>\n<file alias=\"copy\">resources/icons/copy.png</file>\n<file alias=\"edit\">resources/icons/edit.png</file>\n<file alias=\"open\">resources/icons/open.png</file>\n<file alias=\"save\">resources/icons/save.png</file>\n<file alias=\"format_voc\">resources/icons/format_voc.png</file>\n<file alias=\"format_yolo\">resources/icons/format_yolo.png</file>\n<file alias=\"format_createml\">resources/icons/format_createml.png</file>\n<file alias=\"save-as\">resources/icons/save-as.png</file>\n<file alias=\"color\">resources/icons/color.png</file>\n<file alias=\"color_line\">resources/icons/color_line.png</file>\n<file alias=\"zoom\">resources/icons/zoom.png</file>\n<file alias=\"zoom-in\">resources/icons/zoom-in.png</file>\n<file alias=\"zoom-out\">resources/icons/zoom-out.png</file>\n<file alias=\"light_reset\">resources/icons/light_reset.png</file>\n<file alias=\"light_lighten\">resources/icons/light_lighten.png</file>\n<file alias=\"light_darken\">resources/icons/light_darken.png</file>\n<file alias=\"delete\">resources/icons/cancel.png</file>\n<file alias=\"next\">resources/icons/next.png</file>\n<file alias=\"prev\">resources/icons/prev.png</file>\n<file alias=\"resetall\">resources/icons/resetall.png</file>\n<file alias=\"verify\">resources/icons/verify.png</file>\n<file alias=\"strings\">resources/strings/strings.properties</file>\n<file alias=\"strings-zh-TW\">resources/strings/strings-zh-TW.properties</file>\n<file alias=\"strings-zh-CN\">resources/strings/strings-zh-CN.properties</file>\n<file alias=\"strings-ja-JP\">resources/strings/strings-ja-JP.properties</file>\n</qresource>\n</RCC>\n"
        },
        {
          "name": "resources",
          "type": "tree",
          "content": null
        },
        {
          "name": "setup.cfg",
          "type": "blob",
          "size": 0.0947265625,
          "content": "[bumpversion]\ncommit = True\ntag = True\n\n[bumpversion:file:setup.py]\n\n[bdist_wheel]\nuniversal = 1\n"
        },
        {
          "name": "setup.py",
          "type": "blob",
          "size": 3.4814453125,
          "content": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom setuptools import setup, find_packages, Command\nfrom sys import platform as _platform\nfrom shutil import rmtree\nimport sys\nimport os\n\nhere = os.path.abspath(os.path.dirname(__file__))\nNAME = 'labelImg'\nREQUIRES_PYTHON = '>=3.0.0'\nREQUIRED_DEP = ['pyqt5', 'lxml']\nabout = {}\n\nwith open(os.path.join(here, 'libs', '__init__.py')) as f:\n    exec(f.read(), about)\n\nwith open(\"README.rst\", \"rb\") as readme_file:\n    readme = readme_file.read().decode(\"UTF-8\")\n\nwith open(\"HISTORY.rst\", \"rb\") as history_file:\n    history = history_file.read().decode(\"UTF-8\")\n\n# OS specific settings\nSET_REQUIRES = []\nif _platform == \"linux\" or _platform == \"linux2\":\n   # linux\n   print('linux')\nelif _platform == \"darwin\":\n   # MAC OS X\n   SET_REQUIRES.append('py2app')\n\nrequired_packages = find_packages()\nrequired_packages.append('labelImg')\n\nAPP = [NAME + '.py']\nOPTIONS = {\n    'argv_emulation': True,\n    'iconfile': 'resources/icons/app.icns'\n}\n\nclass UploadCommand(Command):\n    \"\"\"Support setup.py upload.\"\"\"\n\n    description=readme + '\\n\\n' + history,\n\n    user_options = []\n\n    @staticmethod\n    def status(s):\n        \"\"\"Prints things in bold.\"\"\"\n        print('\\033[1m{0}\\033[0m'.format(s))\n\n    def initialize_options(self):\n        pass\n\n    def finalize_options(self):\n        pass\n\n    def run(self):\n        try:\n            self.status('Removing previous builds…')\n            rmtree(os.path.join(here, 'dist'))\n        except OSError:\n            self.status('Fail to remove previous builds..')\n            pass\n\n        self.status('Building Source and Wheel (universal) distribution…')\n        os.system(\n            '{0} setup.py sdist bdist_wheel --universal'.format(sys.executable))\n\n        self.status('Uploading the package to PyPI via Twine…')\n        os.system('twine upload dist/*')\n\n        self.status('Pushing git tags…')\n        os.system('git tag -d v{0}'.format(about['__version__']))\n        os.system('git tag v{0}'.format(about['__version__']))\n        # os.system('git push --tags')\n\n        sys.exit()\n\n\nsetup(\n    app=APP,\n    name=NAME,\n    version=about['__version__'],\n    description=\"LabelImg is a graphical image annotation tool and label object bounding boxes in images\",\n    long_description=readme + '\\n\\n' + history,\n    author=\"TzuTa Lin\",\n    author_email='tzu.ta.lin@gmail.com',\n    url='https://github.com/tzutalin/labelImg',\n    python_requires=REQUIRES_PYTHON,\n    package_dir={'labelImg': '.'},\n    packages=required_packages,\n    entry_points={\n        'console_scripts': [\n            'labelImg=labelImg.labelImg:main'\n        ]\n    },\n    include_package_data=True,\n    install_requires=REQUIRED_DEP,\n    license=\"MIT license\",\n    zip_safe=False,\n    keywords='labelImg labelTool development annotation deeplearning',\n    classifiers=[\n        'Development Status :: 5 - Production/Stable',\n        'Intended Audience :: Developers',\n        'License :: OSI Approved :: MIT License',\n        'Natural Language :: English',\n        'Programming Language :: Python :: 3',\n        'Programming Language :: Python :: 3.3',\n        'Programming Language :: Python :: 3.4',\n        'Programming Language :: Python :: 3.5',\n        'Programming Language :: Python :: 3.6',\n        'Programming Language :: Python :: 3.7',\n    ],\n    package_data={'data/predefined_classes.txt': ['data/predefined_classes.txt']},\n    options={'py2app': OPTIONS},\n    setup_requires=SET_REQUIRES,\n    # $ setup.py publish support.\n    cmdclass={\n        'upload': UploadCommand,\n    }\n)\n"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "tools",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}