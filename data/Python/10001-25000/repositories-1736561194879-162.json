{
  "metadata": {
    "timestamp": 1736561194879,
    "page": 162,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "graphdeco-inria/gaussian-splatting",
      "stars": 15372,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.1123046875,
          "content": "*.pyc\n.vscode\noutput\nbuild\ndiff_rasterization/diff_rast.egg-info\ndiff_rasterization/dist\ntensorboard_3d\nscreenshots"
        },
        {
          "name": ".gitmodules",
          "type": "blob",
          "size": 0.5126953125,
          "content": "[submodule \"submodules/simple-knn\"]\n\tpath = submodules/simple-knn\n\turl = https://gitlab.inria.fr/bkerbl/simple-knn.git\n[submodule \"submodules/diff-gaussian-rasterization\"]\n\tpath = submodules/diff-gaussian-rasterization\n\turl = https://github.com/graphdeco-inria/diff-gaussian-rasterization.git\n\tbranch = dr_aa\n[submodule \"SIBR_viewers\"]\n\tpath = SIBR_viewers\n\turl = https://gitlab.inria.fr/sibr/sibr_core.git\n[submodule \"submodules/fused-ssim\"]\n\tpath = submodules/fused-ssim\n\turl = https://github.com/rahul-goel/fused-ssim.git\n"
        },
        {
          "name": "LICENSE.md",
          "type": "blob",
          "size": 4.552734375,
          "content": "Gaussian-Splatting License  \n===========================  \n\n**Inria** and **the Max Planck Institut for Informatik (MPII)** hold all the ownership rights on the *Software* named **gaussian-splatting**.  \nThe *Software* is in the process of being registered with the Agence pour la Protection des  \nProgrammes (APP).  \n\nThe *Software* is still being developed by the *Licensor*.  \n\n*Licensor*'s goal is to allow the research community to use, test and evaluate  \nthe *Software*.  \n\n## 1.  Definitions  \n\n*Licensee* means any person or entity that uses the *Software* and distributes  \nits *Work*.  \n\n*Licensor* means the owners of the *Software*, i.e Inria and MPII  \n\n*Software* means the original work of authorship made available under this  \nLicense ie gaussian-splatting.  \n\n*Work* means the *Software* and any additions to or derivative works of the  \n*Software* that are made available under this License.  \n\n\n## 2.  Purpose  \nThis license is intended to define the rights granted to the *Licensee* by  \nLicensors under the *Software*.  \n\n## 3.  Rights granted  \n\nFor the above reasons Licensors have decided to distribute the *Software*.  \nLicensors grant non-exclusive rights to use the *Software* for research purposes  \nto research users (both academic and industrial), free of charge, without right  \nto sublicense.. The *Software* may be used \"non-commercially\", i.e., for research  \nand/or evaluation purposes only.  \n\nSubject to the terms and conditions of this License, you are granted a  \nnon-exclusive, royalty-free, license to reproduce, prepare derivative works of,  \npublicly display, publicly perform and distribute its *Work* and any resulting  \nderivative works in any form.  \n\n## 4.  Limitations  \n\n**4.1 Redistribution.** You may reproduce or distribute the *Work* only if (a) you do  \nso under this License, (b) you include a complete copy of this License with  \nyour distribution, and (c) you retain without modification any copyright,  \npatent, trademark, or attribution notices that are present in the *Work*.  \n\n**4.2 Derivative Works.** You may specify that additional or different terms apply  \nto the use, reproduction, and distribution of your derivative works of the *Work*  \n(\"Your Terms\") only if (a) Your Terms provide that the use limitation in  \nSection 2 applies to your derivative works, and (b) you identify the specific  \nderivative works that are subject to Your Terms. Notwithstanding Your Terms,  \nthis License (including the redistribution requirements in Section 3.1) will  \ncontinue to apply to the *Work* itself.  \n\n**4.3** Any other use without of prior consent of Licensors is prohibited. Research  \nusers explicitly acknowledge having received from Licensors all information  \nallowing to appreciate the adequacy between of the *Software* and their needs and  \nto undertake all necessary precautions for its execution and use.  \n\n**4.4** The *Software* is provided both as a compiled library file and as source  \ncode. In case of using the *Software* for a publication or other results obtained  \nthrough the use of the *Software*, users are strongly encouraged to cite the  \ncorresponding publications as explained in the documentation of the *Software*.  \n\n## 5.  Disclaimer  \n\nTHE USER CANNOT USE, EXPLOIT OR DISTRIBUTE THE *SOFTWARE* FOR COMMERCIAL PURPOSES  \nWITHOUT PRIOR AND EXPLICIT CONSENT OF LICENSORS. YOU MUST CONTACT INRIA FOR ANY  \nUNAUTHORIZED USE: stip-sophia.transfert@inria.fr . ANY SUCH ACTION WILL  \nCONSTITUTE A FORGERY. THIS *SOFTWARE* IS PROVIDED \"AS IS\" WITHOUT ANY WARRANTIES  \nOF ANY NATURE AND ANY EXPRESS OR IMPLIED WARRANTIES, WITH REGARDS TO COMMERCIAL  \nUSE, PROFESSIONNAL USE, LEGAL OR NOT, OR OTHER, OR COMMERCIALISATION OR  \nADAPTATION. UNLESS EXPLICITLY PROVIDED BY LAW, IN NO EVENT, SHALL INRIA OR THE  \nAUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  \nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE  \nGOODS OR SERVICES, LOSS OF USE, DATA, OR PROFITS OR BUSINESS INTERRUPTION)  \nHOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  \nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING FROM, OUT OF OR  \nIN CONNECTION WITH THE *SOFTWARE* OR THE USE OR OTHER DEALINGS IN THE *SOFTWARE*.  \n\n## 6.  Files subject to permissive licenses\nThe contents of the file ```utils/loss_utils.py``` are based on publicly available code authored by Evan Su, which falls under the permissive MIT license. \n\nTitle: pytorch-ssim\\\nProject code: https://github.com/Po-Hsun-Su/pytorch-ssim\\\nCopyright Evan Su, 2017\\\nLicense: https://github.com/Po-Hsun-Su/pytorch-ssim/blob/master/LICENSE.txt (MIT)"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 39.822265625,
          "content": "# 3D Gaussian Splatting for Real-Time Radiance Field Rendering\nBernhard Kerbl*, Georgios Kopanas*, Thomas Leimkühler, George Drettakis (* indicates equal contribution)<br>\n| [Webpage](https://repo-sam.inria.fr/fungraph/3d-gaussian-splatting/) | [Full Paper](https://repo-sam.inria.fr/fungraph/3d-gaussian-splatting/3d_gaussian_splatting_high.pdf) | [Video](https://youtu.be/T_kXY43VZnk) | [Other GRAPHDECO Publications](http://www-sop.inria.fr/reves/publis/gdindex.php) | [FUNGRAPH project page](https://fungraph.inria.fr) |<br>\n| [T&T+DB COLMAP (650MB)](https://repo-sam.inria.fr/fungraph/3d-gaussian-splatting/datasets/input/tandt_db.zip) | [Pre-trained Models (14 GB)](https://repo-sam.inria.fr/fungraph/3d-gaussian-splatting/datasets/pretrained/models.zip) | [Viewers for Windows (60MB)](https://repo-sam.inria.fr/fungraph/3d-gaussian-splatting/binaries/viewers.zip) | [Evaluation Images (7 GB)](https://repo-sam.inria.fr/fungraph/3d-gaussian-splatting/evaluation/images.zip) |<br>\n![Teaser image](assets/teaser.png)\n\nThis repository contains the official authors implementation associated with the paper \"3D Gaussian Splatting for Real-Time Radiance Field Rendering\", which can be found [here](https://repo-sam.inria.fr/fungraph/3d-gaussian-splatting/). We further provide the reference images used to create the error metrics reported in the paper, as well as recently created, pre-trained models. \n\n<a href=\"https://www.inria.fr/\"><img height=\"100\" src=\"assets/logo_inria.png\"> </a>\n<a href=\"https://univ-cotedazur.eu/\"><img height=\"100\" src=\"assets/logo_uca.png\"> </a>\n<a href=\"https://www.mpi-inf.mpg.de\"><img height=\"100\" src=\"assets/logo_mpi.png\"> </a> \n<a href=\"https://team.inria.fr/graphdeco/\"> <img style=\"width:100%;\" src=\"assets/logo_graphdeco.png\"></a>\n\nAbstract: *Radiance Field methods have recently revolutionized novel-view synthesis of scenes captured with multiple photos or videos. However, achieving high visual quality still requires neural networks that are costly to train and render, while recent faster methods inevitably trade off speed for quality. For unbounded and complete scenes (rather than isolated objects) and 1080p resolution rendering, no current method can achieve real-time display rates. We introduce three key elements that allow us to achieve state-of-the-art visual quality while maintaining competitive training times and importantly allow high-quality real-time (≥ 30 fps) novel-view synthesis at 1080p resolution. First, starting from sparse points produced during camera calibration, we represent the scene with 3D Gaussians that preserve desirable properties of continuous volumetric radiance fields for scene optimization while avoiding unnecessary computation in empty space; Second, we perform interleaved optimization/density control of the 3D Gaussians, notably optimizing anisotropic covariance to achieve an accurate representation of the scene; Third, we develop a fast visibility-aware rendering algorithm that supports anisotropic splatting and both accelerates training and allows realtime rendering. We demonstrate state-of-the-art visual quality and real-time rendering on several established datasets.*\n\n<section class=\"section\" id=\"BibTeX\">\n  <div class=\"container is-max-desktop content\">\n    <h2 class=\"title\">BibTeX</h2>\n    <pre><code>@Article{kerbl3Dgaussians,\n      author       = {Kerbl, Bernhard and Kopanas, Georgios and Leimk{\\\"u}hler, Thomas and Drettakis, George},\n      title        = {3D Gaussian Splatting for Real-Time Radiance Field Rendering},\n      journal      = {ACM Transactions on Graphics},\n      number       = {4},\n      volume       = {42},\n      month        = {July},\n      year         = {2023},\n      url          = {https://repo-sam.inria.fr/fungraph/3d-gaussian-splatting/}\n}</code></pre>\n  </div>\n</section>\n\n\n\n## Funding and Acknowledgments\n\nThis research was funded by the ERC Advanced grant FUNGRAPH No 788065. The authors are grateful to Adobe for generous donations, the OPAL infrastructure from Université Côte d’Azur and for the HPC resources from GENCI–IDRIS (Grant 2022-AD011013409). The authors thank the anonymous reviewers for their valuable feedback, P. Hedman and A. Tewari for proofreading earlier drafts also T. Müller, A. Yu and S. Fridovich-Keil for helping with the comparisons.\n\n## NEW FEATURES !\n\nWe have limited resources for maintaining and updating the code. However, we have added a few new features since the original release that are inspired by some of the excellent work many other researchers have been doing on 3DGS. We will be adding other features within the ability of our resources.\n\n**Update of October 2024**: We integrated [training speed acceleration](#training-speed-acceleration) and made it compatible with [depth regularization](#depth-regularization), [anti-aliasing](#anti-aliasing) and [exposure compensation](#exposure-compensation). We have enhanced the SIBR real time viewer by correcting bugs and adding features in the [Top View](#sibr-top-view) that allows visualization of input and user cameras.\n\n**Update of Spring 2024**:\nOrange Labs has kindly added [OpenXR support](#openxr-support) for VR viewing. \n\n## Step-by-step Tutorial\n\nJonathan Stephens made a fantastic step-by-step tutorial for setting up Gaussian Splatting on your machine, along with instructions for creating usable datasets from videos. If the instructions below are too dry for you, go ahead and check it out [here](https://www.youtube.com/watch?v=UXtuigy_wYc).\n\n## Colab\n\nUser [camenduru](https://github.com/camenduru) was kind enough to provide a Colab template that uses this repo's source (status: August 2023!) for quick and easy access to the method. Please check it out [here](https://github.com/camenduru/gaussian-splatting-colab).\n\n## Cloning the Repository\n\nThe repository contains submodules, thus please check it out with \n```shell\n# SSH\ngit clone git@github.com:graphdeco-inria/gaussian-splatting.git --recursive\n```\nor\n```shell\n# HTTPS\ngit clone https://github.com/graphdeco-inria/gaussian-splatting --recursive\n```\n\n## Overview\n\nThe codebase has 4 main components:\n- A PyTorch-based optimizer to produce a 3D Gaussian model from SfM inputs\n- A network viewer that allows to connect to and visualize the optimization process\n- An OpenGL-based real-time viewer to render trained models in real-time.\n- A script to help you turn your own images into optimization-ready SfM data sets\n\nThe components have different requirements w.r.t. both hardware and software. They have been tested on Windows 10 and Ubuntu Linux 22.04. Instructions for setting up and running each of them are found in the sections below.\n\n\n\n\n## Optimizer\n\nThe optimizer uses PyTorch and CUDA extensions in a Python environment to produce trained models. \n\n### Hardware Requirements\n\n- CUDA-ready GPU with Compute Capability 7.0+\n- 24 GB VRAM (to train to paper evaluation quality)\n- Please see FAQ for smaller VRAM configurations\n\n### Software Requirements\n- Conda (recommended for easy setup)\n- C++ Compiler for PyTorch extensions (we used Visual Studio 2019 for Windows)\n- CUDA SDK 11 for PyTorch extensions, install *after* Visual Studio (we used 11.8, **known issues with 11.6**)\n- C++ Compiler and CUDA SDK must be compatible\n\n### Setup\n\n#### Local Setup\n\nOur default, provided install method is based on Conda package and environment management:\n```shell\nSET DISTUTILS_USE_SDK=1 # Windows only\nconda env create --file environment.yml\nconda activate gaussian_splatting\n```\nPlease note that this process assumes that you have CUDA SDK **11** installed, not **12**. For modifications, see below.\n\nTip: Downloading packages and creating a new environment with Conda can require a significant amount of disk space. By default, Conda will use the main system hard drive. You can avoid this by specifying a different package download location and an environment on a different drive:\n\n```shell\nconda config --add pkgs_dirs <Drive>/<pkg_path>\nconda env create --file environment.yml --prefix <Drive>/<env_path>/gaussian_splatting\nconda activate <Drive>/<env_path>/gaussian_splatting\n```\n\n#### Modifications\n\nIf you can afford the disk space, we recommend using our environment files for setting up a training environment identical to ours. If you want to make modifications, please note that major version changes might affect the results of our method. However, our (limited) experiments suggest that the codebase works just fine inside a more up-to-date environment (Python 3.8, PyTorch 2.0.0, CUDA 12). Make sure to create an environment where PyTorch and its CUDA runtime version match and the installed CUDA SDK has no major version difference with PyTorch's CUDA version.\n\n#### Known Issues\n\nSome users experience problems building the submodules on Windows (```cl.exe: File not found``` or similar). Please consider the workaround for this problem from the FAQ.\n\n### Running\n\nTo run the optimizer, simply use\n\n```shell\npython train.py -s <path to COLMAP or NeRF Synthetic dataset>\n```\n\n<details>\n<summary><span style=\"font-weight: bold;\">Command Line Arguments for train.py</span></summary>\n\n  #### --source_path / -s\n  Path to the source directory containing a COLMAP or Synthetic NeRF data set.\n  #### --model_path / -m \n  Path where the trained model should be stored (```output/<random>``` by default).\n  #### --images / -i\n  Alternative subdirectory for COLMAP images (```images``` by default).\n  #### --eval\n  Add this flag to use a MipNeRF360-style training/test split for evaluation.\n  #### --resolution / -r\n  Specifies resolution of the loaded images before training. If provided ```1, 2, 4``` or ```8```, uses original, 1/2, 1/4 or 1/8 resolution, respectively. For all other values, rescales the width to the given number while maintaining image aspect. **If not set and input image width exceeds 1.6K pixels, inputs are automatically rescaled to this target.**\n  #### --data_device\n  Specifies where to put the source image data, ```cuda``` by default, recommended to use ```cpu``` if training on large/high-resolution dataset, will reduce VRAM consumption, but slightly slow down training. Thanks to [HrsPythonix](https://github.com/HrsPythonix).\n  #### --white_background / -w\n  Add this flag to use white background instead of black (default), e.g., for evaluation of NeRF Synthetic dataset.\n  #### --sh_degree\n  Order of spherical harmonics to be used (no larger than 3). ```3``` by default.\n  #### --convert_SHs_python\n  Flag to make pipeline compute forward and backward of SHs with PyTorch instead of ours.\n  #### --convert_cov3D_python\n  Flag to make pipeline compute forward and backward of the 3D covariance with PyTorch instead of ours.\n  #### --debug\n  Enables debug mode if you experience erros. If the rasterizer fails, a ```dump``` file is created that you may forward to us in an issue so we can take a look.\n  #### --debug_from\n  Debugging is **slow**. You may specify an iteration (starting from 0) after which the above debugging becomes active.\n  #### --iterations\n  Number of total iterations to train for, ```30_000``` by default.\n  #### --ip\n  IP to start GUI server on, ```127.0.0.1``` by default.\n  #### --port \n  Port to use for GUI server, ```6009``` by default.\n  #### --test_iterations\n  Space-separated iterations at which the training script computes L1 and PSNR over test set, ```7000 30000``` by default.\n  #### --save_iterations\n  Space-separated iterations at which the training script saves the Gaussian model, ```7000 30000 <iterations>``` by default.\n  #### --checkpoint_iterations\n  Space-separated iterations at which to store a checkpoint for continuing later, saved in the model directory.\n  #### --start_checkpoint\n  Path to a saved checkpoint to continue training from.\n  #### --quiet \n  Flag to omit any text written to standard out pipe. \n  #### --feature_lr\n  Spherical harmonics features learning rate, ```0.0025``` by default.\n  #### --opacity_lr\n  Opacity learning rate, ```0.05``` by default.\n  #### --scaling_lr\n  Scaling learning rate, ```0.005``` by default.\n  #### --rotation_lr\n  Rotation learning rate, ```0.001``` by default.\n  #### --position_lr_max_steps\n  Number of steps (from 0) where position learning rate goes from ```initial``` to ```final```. ```30_000``` by default.\n  #### --position_lr_init\n  Initial 3D position learning rate, ```0.00016``` by default.\n  #### --position_lr_final\n  Final 3D position learning rate, ```0.0000016``` by default.\n  #### --position_lr_delay_mult\n  Position learning rate multiplier (cf. Plenoxels), ```0.01``` by default. \n  #### --densify_from_iter\n  Iteration where densification starts, ```500``` by default. \n  #### --densify_until_iter\n  Iteration where densification stops, ```15_000``` by default.\n  #### --densify_grad_threshold\n  Limit that decides if points should be densified based on 2D position gradient, ```0.0002``` by default.\n  #### --densification_interval\n  How frequently to densify, ```100``` (every 100 iterations) by default.\n  #### --opacity_reset_interval\n  How frequently to reset opacity, ```3_000``` by default. \n  #### --lambda_dssim\n  Influence of SSIM on total loss from 0 to 1, ```0.2``` by default. \n  #### --percent_dense\n  Percentage of scene extent (0--1) a point must exceed to be forcibly densified, ```0.01``` by default.\n\n</details>\n<br>\n\nNote that similar to MipNeRF360, we target images at resolutions in the 1-1.6K pixel range. For convenience, arbitrary-size inputs can be passed and will be automatically resized if their width exceeds 1600 pixels. We recommend to keep this behavior, but you may force training to use your higher-resolution images by setting ```-r 1```.\n\nThe MipNeRF360 scenes are hosted by the paper authors [here](https://jonbarron.info/mipnerf360/). You can find our SfM data sets for Tanks&Temples and Deep Blending [here](https://repo-sam.inria.fr/fungraph/3d-gaussian-splatting/datasets/input/tandt_db.zip). If you do not provide an output model directory (```-m```), trained models are written to folders with randomized unique names inside the ```output``` directory. At this point, the trained models may be viewed with the real-time viewer (see further below).\n\n### Evaluation\nBy default, the trained models use all available images in the dataset. To train them while withholding a test set for evaluation, use the ```--eval``` flag. This way, you can render training/test sets and produce error metrics as follows:\n```shell\npython train.py -s <path to COLMAP or NeRF Synthetic dataset> --eval # Train with train/test split\npython render.py -m <path to trained model> # Generate renderings\npython metrics.py -m <path to trained model> # Compute error metrics on renderings\n```\n\nIf you want to evaluate our [pre-trained models](https://repo-sam.inria.fr/fungraph/3d-gaussian-splatting/datasets/pretrained/models.zip), you will have to download the corresponding source data sets and indicate their location to ```render.py``` with an additional ```--source_path/-s``` flag. Note: The pre-trained models were created with the release codebase. This code base has been cleaned up and includes bugfixes, hence the metrics you get from evaluating them will differ from those in the paper.\n```shell\npython render.py -m <path to pre-trained model> -s <path to COLMAP dataset>\npython metrics.py -m <path to pre-trained model>\n```\n\n<details>\n<summary><span style=\"font-weight: bold;\">Command Line Arguments for render.py</span></summary>\n\n  #### --model_path / -m \n  Path to the trained model directory you want to create renderings for.\n  #### --skip_train\n  Flag to skip rendering the training set.\n  #### --skip_test\n  Flag to skip rendering the test set.\n  #### --quiet \n  Flag to omit any text written to standard out pipe. \n\n  **The below parameters will be read automatically from the model path, based on what was used for training. However, you may override them by providing them explicitly on the command line.** \n\n  #### --source_path / -s\n  Path to the source directory containing a COLMAP or Synthetic NeRF data set.\n  #### --images / -i\n  Alternative subdirectory for COLMAP images (```images``` by default).\n  #### --eval\n  Add this flag to use a MipNeRF360-style training/test split for evaluation.\n  #### --resolution / -r\n  Changes the resolution of the loaded images before training. If provided ```1, 2, 4``` or ```8```, uses original, 1/2, 1/4 or 1/8 resolution, respectively. For all other values, rescales the width to the given number while maintaining image aspect. ```1``` by default.\n  #### --white_background / -w\n  Add this flag to use white background instead of black (default), e.g., for evaluation of NeRF Synthetic dataset.\n  #### --convert_SHs_python\n  Flag to make pipeline render with computed SHs from PyTorch instead of ours.\n  #### --convert_cov3D_python\n  Flag to make pipeline render with computed 3D covariance from PyTorch instead of ours.\n\n</details>\n\n<details>\n<summary><span style=\"font-weight: bold;\">Command Line Arguments for metrics.py</span></summary>\n\n  #### --model_paths / -m \n  Space-separated list of model paths for which metrics should be computed.\n</details>\n<br>\n\nWe further provide the ```full_eval.py``` script. This script specifies the routine used in our evaluation and demonstrates the use of some additional parameters, e.g., ```--images (-i)``` to define alternative image directories within COLMAP data sets. If you have downloaded and extracted all the training data, you can run it like this:\n```shell\npython full_eval.py -m360 <mipnerf360 folder> -tat <tanks and temples folder> -db <deep blending folder>\n```\nIn the current version, this process takes about 7h on our reference machine containing an A6000. If you want to do the full evaluation on our pre-trained models, you can specify their download location and skip training. \n```shell\npython full_eval.py -o <directory with pretrained models> --skip_training -m360 <mipnerf360 folder> -tat <tanks and temples folder> -db <deep blending folder>\n```\n\nIf you want to compute the metrics on our paper's [evaluation images](https://repo-sam.inria.fr/fungraph/3d-gaussian-splatting/evaluation/images.zip), you can also skip rendering. In this case it is not necessary to provide the source datasets. You can compute metrics for multiple image sets at a time. \n```shell\npython full_eval.py -m <directory with evaluation images>/garden ... --skip_training --skip_rendering\n```\n\n<details>\n<summary><span style=\"font-weight: bold;\">Command Line Arguments for full_eval.py</span></summary>\n  \n  #### --skip_training\n  Flag to skip training stage.\n  #### --skip_rendering\n  Flag to skip rendering stage.\n  #### --skip_metrics\n  Flag to skip metrics calculation stage.\n  #### --output_path\n  Directory to put renderings and results in, ```./eval``` by default, set to pre-trained model location if evaluating them.\n  #### --mipnerf360 / -m360\n  Path to MipNeRF360 source datasets, required if training or rendering.\n  #### --tanksandtemples / -tat\n  Path to Tanks&Temples source datasets, required if training or rendering.\n  #### --deepblending / -db\n  Path to Deep Blending source datasets, required if training or rendering.\n</details>\n<br>\n\n## Interactive Viewers\nWe provide two interactive viewers for our method: remote and real-time. Our viewing solutions are based on the [SIBR](https://sibr.gitlabpages.inria.fr/) framework, developed by the GRAPHDECO group for several novel-view synthesis projects.\n\n### Hardware Requirements\n- OpenGL 4.5-ready GPU and drivers (or latest MESA software)\n- 4 GB VRAM recommended\n- CUDA-ready GPU with Compute Capability 7.0+ (only for Real-Time Viewer)\n\n### Software Requirements\n- Visual Studio or g++, **not Clang** (we used Visual Studio 2019 for Windows)\n- CUDA SDK 11, install *after* Visual Studio (we used 11.8)\n- CMake (recent version, we used 3.24)\n- 7zip (only on Windows)\n\n### Pre-built Windows Binaries\nWe provide pre-built binaries for Windows [here](https://repo-sam.inria.fr/fungraph/3d-gaussian-splatting/binaries/viewers.zip). We recommend using them on Windows for an efficient setup, since the building of SIBR involves several external dependencies that must be downloaded and compiled on-the-fly.\n\n### Installation from Source\nIf you cloned with submodules (e.g., using ```--recursive```), the source code for the viewers is found in ```SIBR_viewers```. The network viewer runs within the SIBR framework for Image-based Rendering applications.\n\n#### Windows\nCMake should take care of your dependencies.\n```shell\ncd SIBR_viewers\ncmake -Bbuild .\ncmake --build build --target install --config RelWithDebInfo\n```\nYou may specify a different configuration, e.g. ```Debug``` if you need more control during development.\n\n#### Ubuntu 22.04\nYou will need to install a few dependencies before running the project setup.\n```shell\n# Dependencies\nsudo apt install -y libglew-dev libassimp-dev libboost-all-dev libgtk-3-dev libopencv-dev libglfw3-dev libavdevice-dev libavcodec-dev libeigen3-dev libxxf86vm-dev libembree-dev\n# Project setup\ncd SIBR_viewers\ncmake -Bbuild . -DCMAKE_BUILD_TYPE=Release # add -G Ninja to build faster\ncmake --build build -j24 --target install\n``` \n\n#### Ubuntu 20.04\nBackwards compatibility with Focal Fossa is not fully tested, but building SIBR with CMake should still work after invoking\n```shell\ngit checkout fossa_compatibility\n```\n\n### Navigation in SIBR Viewers\nThe SIBR interface provides several methods of navigating the scene. By default, you will be started with an FPS navigator, which you can control with ```W, A, S, D, Q, E``` for camera translation and ```I, K, J, L, U, O``` for rotation. Alternatively, you may want to use a Trackball-style navigator (select from the floating menu). You can also snap to a camera from the data set with the ```Snap to``` button or find the closest camera with ```Snap to closest```. The floating menues also allow you to change the navigation speed. You can use the ```Scaling Modifier``` to control the size of the displayed Gaussians, or show the initial point cloud.\n\n### Running the Network Viewer\n\n\n\nhttps://github.com/graphdeco-inria/gaussian-splatting/assets/40643808/90a2e4d3-cf2e-4633-b35f-bfe284e28ff7\n\n\n\nAfter extracting or installing the viewers, you may run the compiled ```SIBR_remoteGaussian_app[_config]``` app in ```<SIBR install dir>/bin```, e.g.: \n```shell\n./<SIBR install dir>/bin/SIBR_remoteGaussian_app\n```\nThe network viewer allows you to connect to a running training process on the same or a different machine. If you are training on the same machine and OS, no command line parameters should be required: the optimizer communicates the location of the training data to the network viewer. By default, optimizer and network viewer will try to establish a connection on **localhost** on port **6009**. You can change this behavior by providing matching ```--ip``` and ```--port``` parameters to both the optimizer and the network viewer. If for some reason the path used by the optimizer to find the training data is not reachable by the network viewer (e.g., due to them running on different (virtual) machines), you may specify an override location to the viewer by using ```-s <source path>```. \n\n<details>\n<summary><span style=\"font-weight: bold;\">Primary Command Line Arguments for Network Viewer</span></summary>\n\n  #### --path / -s\n  Argument to override model's path to source dataset.\n  #### --ip\n  IP to use for connection to a running training script.\n  #### --port\n  Port to use for connection to a running training script. \n  #### --rendering-size \n  Takes two space separated numbers to define the resolution at which network rendering occurs, ```1200``` width by default.\n  Note that to enforce an aspect that differs from the input images, you need ```--force-aspect-ratio``` too.\n  #### --load_images\n  Flag to load source dataset images to be displayed in the top view for each camera.\n</details>\n<br>\n\n### Running the Real-Time Viewer\n\n\n\n\nhttps://github.com/graphdeco-inria/gaussian-splatting/assets/40643808/0940547f-1d82-4c2f-a616-44eabbf0f816\n\n\n\n\nAfter extracting or installing the viewers, you may run the compiled ```SIBR_gaussianViewer_app[_config]``` app in ```<SIBR install dir>/bin```, e.g.: \n```shell\n./<SIBR install dir>/bin/SIBR_gaussianViewer_app -m <path to trained model>\n```\n\nIt should suffice to provide the ```-m``` parameter pointing to a trained model directory. Alternatively, you can specify an override location for training input data using ```-s```. To use a specific resolution other than the auto-chosen one, specify ```--rendering-size <width> <height>```. Combine it with ```--force-aspect-ratio``` if you want the exact resolution and don't mind image distortion. \n\n**To unlock the full frame rate, please disable V-Sync on your machine and also in the application (Menu &rarr; Display). In a multi-GPU system (e.g., laptop) your OpenGL/Display GPU should be the same as your CUDA GPU (e.g., by setting the application's GPU preference on Windows, see below) for maximum performance.**\n\n![Teaser image](assets/select.png)\n\nIn addition to the initial point cloud and the splats, you also have the option to visualize the Gaussians by rendering them as ellipsoids from the floating menu.\nSIBR has many other functionalities, please see the [documentation](https://sibr.gitlabpages.inria.fr/) for more details on the viewer, navigation options etc. There is also a Top View (available from the menu) that shows the placement of the input cameras and the original SfM point cloud; please note that Top View slows rendering when enabled. The real-time viewer also uses slightly more aggressive, fast culling, which can be toggled in the floating menu. If you ever encounter an issue that can be solved by turning fast culling off, please let us know.\n\n<details>\n<summary><span style=\"font-weight: bold;\">Primary Command Line Arguments for Real-Time Viewer</span></summary>\n\n  #### --model-path / -m\n  Path to trained model.\n  #### --iteration\n  Specifies which of state to load if multiple are available. Defaults to latest available iteration.\n  #### --path / -s\n  Argument to override model's path to source dataset.\n  #### --rendering-size \n  Takes two space separated numbers to define the resolution at which real-time rendering occurs, ```1200``` width by default. Note that to enforce an aspect that differs from the input images, you need ```--force-aspect-ratio``` too.\n  #### --load_images\n  Flag to load source dataset images to be displayed in the top view for each camera.\n  #### --device\n  Index of CUDA device to use for rasterization if multiple are available, ```0``` by default.\n  #### --no_interop\n  Disables CUDA/GL interop forcibly. Use on systems that may not behave according to spec (e.g., WSL2 with MESA GL 4.5 software rendering).\n</details>\n<br>\n\n## Processing your own Scenes\n\nOur COLMAP loaders expect the following dataset structure in the source path location:\n\n```\n<location>\n|---images\n|   |---<image 0>\n|   |---<image 1>\n|   |---...\n|---sparse\n    |---0\n        |---cameras.bin\n        |---images.bin\n        |---points3D.bin\n```\n\nFor rasterization, the camera models must be either a SIMPLE_PINHOLE or PINHOLE camera. We provide a converter script ```convert.py```, to extract undistorted images and SfM information from input images. Optionally, you can use ImageMagick to resize the undistorted images. This rescaling is similar to MipNeRF360, i.e., it creates images with 1/2, 1/4 and 1/8 the original resolution in corresponding folders. To use them, please first install a recent version of COLMAP (ideally CUDA-powered) and ImageMagick. Put the images you want to use in a directory ```<location>/input```.\n```\n<location>\n|---input\n    |---<image 0>\n    |---<image 1>\n    |---...\n```\n If you have COLMAP and ImageMagick on your system path, you can simply run \n```shell\npython convert.py -s <location> [--resize] #If not resizing, ImageMagick is not needed\n```\nAlternatively, you can use the optional parameters ```--colmap_executable``` and ```--magick_executable``` to point to the respective paths. Please note that on Windows, the executable should point to the COLMAP ```.bat``` file that takes care of setting the execution environment. Once done, ```<location>``` will contain the expected COLMAP data set structure with undistorted, resized input images, in addition to your original images and some temporary (distorted) data in the directory ```distorted```.\n\nIf you have your own COLMAP dataset without undistortion (e.g., using ```OPENCV``` camera), you can try to just run the last part of the script: Put the images in ```input``` and the COLMAP info in a subdirectory ```distorted```:\n```\n<location>\n|---input\n|   |---<image 0>\n|   |---<image 1>\n|   |---...\n|---distorted\n    |---database.db\n    |---sparse\n        |---0\n            |---...\n```\nThen run \n```shell\npython convert.py -s <location> --skip_matching [--resize] #If not resizing, ImageMagick is not needed\n```\n\n<details>\n<summary><span style=\"font-weight: bold;\">Command Line Arguments for convert.py</span></summary>\n\n  #### --no_gpu\n  Flag to avoid using GPU in COLMAP.\n  #### --skip_matching\n  Flag to indicate that COLMAP info is available for images.\n  #### --source_path / -s\n  Location of the inputs.\n  #### --camera \n  Which camera model to use for the early matching steps, ```OPENCV``` by default.\n  #### --resize\n  Flag for creating resized versions of input images.\n  #### --colmap_executable\n  Path to the COLMAP executable (```.bat``` on Windows).\n  #### --magick_executable\n  Path to the ImageMagick executable.\n</details>\n<br>\n\n### Training speed acceleration\n\nWe integrated the drop-in replacements from [Taming-3dgs](https://humansensinglab.github.io/taming-3dgs/)<sup>1</sup> with [fused ssim](https://github.com/rahul-goel/fused-ssim/tree/main) into the original codebase to speed up training times. Once installed, the accelerated rasterizer delivers a **$\\times$ 1.6 training time speedup** using `--optimizer_type default` and a **$\\times$ 2.7 training time speedup** using `--optimizer_type sparse_adam`.\n\nTo get faster training times you must first install the accelerated rasterizer to your environment:\n\n```bash\npip uninstall diff-gaussian-rasterization -y\ncd submodules/diff-gaussian-rasterization\nrm -r build\ngit checkout 3dgs_accel\npip install .\n```\n\nThen you can add the following parameter to use the sparse adam optimizer when running `train.py`:\n\n```bash\n--optimizer_type sparse_adam\n```\n\n*Note that this custom rasterizer has a different behaviour than the original version, for more details on training times please see [stats for training times](results.md/#training-times-comparisons)*.\n\n*1. Mallick and Goel, et al. ‘Taming 3DGS: High-Quality Radiance Fields with Limited Resources’. SIGGRAPH Asia 2024 Conference Papers, 2024, https://doi.org/10.1145/3680528.3687694, [github](https://github.com/humansensinglab/taming-3dgs)*\n\n\n### Depth regularization\n\nTo have better reconstructed scenes we use depth maps as priors during optimization with each input images. It works best on untextured parts ex: roads and can remove floaters. Several papers have used similar ideas to improve various aspects of 3DGS; (e.g. [DepthRegularizedGS](https://robot0321.github.io/DepthRegGS/index.html), [SparseGS](https://formycat.github.io/SparseGS-Real-Time-360-Sparse-View-Synthesis-using-Gaussian-Splatting/), [DNGaussian](https://fictionarry.github.io/DNGaussian/)). The depth regularization we integrated is that used in our [Hierarchical 3DGS](https://repo-sam.inria.fr/fungraph/hierarchical-3d-gaussians/) paper, but applied to the original 3DGS; for some scenes (e.g., the DeepBlending scenes) it improves quality significantly; for others it either makes a small difference or can even be worse. For example results showing the potential benefit and statistics on quality please see here: [Stats for depth regularization](results.md).\n\nWhen training on a synthetic dataset, depth maps can be produced and they do not require further processing to be used in our method.\n\nFor real world datasets depth maps should be generated for each input images, to generate them please do the following:\n1. Clone [Depth Anything v2](https://github.com/DepthAnything/Depth-Anything-V2?tab=readme-ov-file#usage):\n    ```\n    git clone https://github.com/DepthAnything/Depth-Anything-V2.git\n    ```\n2. Download weights from [Depth-Anything-V2-Large](https://huggingface.co/depth-anything/Depth-Anything-V2-Large/resolve/main/depth_anything_v2_vitl.pth?download=true) and place it under `Depth-Anything-V2/checkpoints/`\n3. Generate depth maps:\n   ```\n   python Depth-Anything-V2/run.py --encoder vitl --pred-only --grayscale --img-path <path to input images> --outdir <output path>\n   ```\n5. Generate a `depth_params.json` file using:\n    ```\n    python utils/make_depth_scale.py --base_dir <path to colmap> --depths_dir <path to generated depths>\n    ```\n\nA new parameter should be set when training if you want to use depth regularization `-d <path to depth maps>`.\n\n### Exposure compensation\nTo compensate for exposure changes in the different input images we optimize an affine transformation for each image just as in [Hierarchical 3dgs](https://repo-sam.inria.fr/fungraph/hierarchical-3d-gaussians/).  \n\nThis can greatly improve reconstruction results for \"in the wild\" captures, e.g., with a smartphone when the exposure setting of the camera is not fixed. For example results showing the potential benefit and statistics on quality please see here: [Stats for exposure compensation](results.md).\n\nAdd the following parameters to enable it:\n```\n--exposure_lr_init 0.001 --exposure_lr_final 0.0001 --exposure_lr_delay_steps 5000 --exposure_lr_delay_mult 0.001 --train_test_exp\n```\nAgain, other excellent papers have used similar ideas e.g. [NeRF-W](https://nerf-w.github.io/), [URF](https://urban-radiance-fields.github.io/).\n\n### Anti-aliasing\nWe added the EWA Filter from [Mip Splatting](https://niujinshuchong.github.io/mip-splatting/) in our codebase to remove aliasing. It is disabled by default but you can enable it by adding `--antialiasing` when training on a scene using `train.py` or rendering using `render.py`. Antialiasing can be toggled in the SIBR viewer, it is disabled by default but you should enable it when viewing a scene trained using `--antialiasing`.\n![aa](/assets/aa_onoff.gif)\n*this scene was trained using `--antialiasing`*.\n\n### SIBR: Top view\n> `Views > Top view`\n\nThe `Top view` renders the SfM point cloud in another view with the corresponding input cameras and the `Point view` user camera. This allows visualization of how far the viewer is from the input cameras for example.\n\nIt is a 3D view so the user can navigate through it just as in the `Point view` (modes available: FPS, trackball, orbit).\n<!-- _gif showing the top view, showing it is realtime_ -->\n<!-- ![topViewOpen_1.gif](../assets/topViewOpen_1_1709560483017_0.gif) -->\n![top view open](assets/top_view_open.gif)\n\nOptions are available to customize this view, meshes can be disabled/enabled and their scales can be modified. \n<!-- _gif showing different options_ -->\n<!-- ![topViewOptions.gif](../assets/topViewOptions_1709560615266_0.gif) -->\n![top view options](assets/top_view_options.gif)\nA useful additional functionality is to move to the position of an input image, and progressively fade out to the SfM point view in that position (e.g., to verify camera alignment). Views from input cameras can be displayed in the `Top view` (*note that `--images-path` must be set in the command line*). One can snap the `Top view` camera to the closest input camera from the user camera in the `Point view` by clicking `Top view settings > Cameras > Snap to closest`. \n<!-- _gif showing for a snapped camera the ground truth image with alpha_ -->\n<!-- ![topViewImageAlpha.gif](../assets/topViewImageAlpha_1709560852268_0.gif) -->\n![top view image alpha](assets/top_view_image_alpha.gif)\n\n### OpenXR support\n\nOpenXR is supported in the branch `gaussian_code_release_openxr` \nWithin that branch, you can find documentation for VR support [here](https://gitlab.inria.fr/sibr/sibr_core/-/tree/gaussian_code_release_openxr?ref_type=heads).\n\n\n## FAQ\n- *Where do I get data sets, e.g., those referenced in ```full_eval.py```?* The MipNeRF360 data set is provided by the authors of the original paper on the project site. Note that two of the data sets cannot be openly shared and require you to consult the authors directly. For Tanks&Temples and Deep Blending, please use the download links provided at the top of the page. Alternatively, you may access the cloned data (status: August 2023!) from [HuggingFace](https://huggingface.co/camenduru/gaussian-splatting)\n\n\n- *How can I use this for a much larger dataset, like a city district?* The current method was not designed for these, but given enough memory, it should work out. However, the approach can struggle in multi-scale detail scenes (extreme close-ups, mixed with far-away shots). This is usually the case in, e.g., driving data sets (cars close up, buildings far away). For such scenes, you can lower the ```--position_lr_init```, ```--position_lr_final``` and ```--scaling_lr``` (x0.3, x0.1, ...). The more extensive the scene, the lower these values should be. Below, we use default learning rates (left) and ```--position_lr_init 0.000016 --scaling_lr 0.001\"``` (right).\n\n| ![Default learning rate result](assets/worse.png \"title-1\") <!-- --> | <!-- --> ![Reduced learning rate result](assets/better.png \"title-2\") |\n| --- | --- |\n\n- *I'm on Windows and I can't manage to build the submodules, what do I do?* Consider following the steps in the excellent video tutorial [here](https://www.youtube.com/watch?v=UXtuigy_wYc), hopefully they should help. The order in which the steps are done is important! Alternatively, consider using the linked Colab template.\n\n- *It still doesn't work. It says something about ```cl.exe```. What do I do?* User Henry Pearce found a workaround. You can you try adding the visual studio path to your environment variables (your version number might differ);\n```C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.29.30133\\bin\\Hostx64\\x64```\nThen make sure you start a new conda prompt and cd to your repo location and try this;\n```\nconda activate gaussian_splatting\ncd <dir_to_repo>/gaussian-splatting\npip install submodules\\diff-gaussian-rasterization\npip install submodules\\simple-knn\n```\n\n- *I'm on macOS/Puppy Linux/Greenhat and I can't manage to build, what do I do?* Sorry, we can't provide support for platforms outside of the ones we list in this README. Consider using the linked Colab template.\n\n- *I don't have 24 GB of VRAM for training, what do I do?* The VRAM consumption is determined by the number of points that are being optimized, which increases over time. If you only want to train to 7k iterations, you will need significantly less. To do the full training routine and avoid running out of memory, you can increase the ```--densify_grad_threshold```, ```--densification_interval``` or reduce the value of ```--densify_until_iter```. Note however that this will affect the quality of the result. Also try setting ```--test_iterations``` to ```-1``` to avoid memory spikes during testing. If ```--densify_grad_threshold``` is very high, no densification should occur and training should complete if the scene itself loads successfully.\n\n- *24 GB of VRAM for reference quality training is still a lot! Can't we do it with less?* Yes, most likely. By our calculations it should be possible with **way** less memory (~8GB). If we can find the time we will try to achieve this. If some PyTorch veteran out there wants to tackle this, we look forward to your pull request!\n\n\n- *How can I use the differentiable Gaussian rasterizer for my own project?* Easy, it is included in this repo as a submodule ```diff-gaussian-rasterization```. Feel free to check out and install the package. It's not really documented, but using it from the Python side is very straightforward (cf. ```gaussian_renderer/__init__.py```).\n\n- *Wait, but ```<insert feature>``` isn't optimized and could be much better?* There are several parts we didn't even have time to think about improving (yet). The performance you get with this prototype is probably a rather slow baseline for what is physically possible.\n\n- *Something is broken, how did this happen?* We tried hard to provide a solid and comprehensible basis to make use of the paper's method. We have refactored the code quite a bit, but we have limited capacity to test all possible usage scenarios. Thus, if part of the website, the code or the performance is lacking, please create an issue. If we find the time, we will do our best to address it.\n"
        },
        {
          "name": "SIBR_viewers",
          "type": "commit",
          "content": null
        },
        {
          "name": "arguments",
          "type": "tree",
          "content": null
        },
        {
          "name": "assets",
          "type": "tree",
          "content": null
        },
        {
          "name": "convert.py",
          "type": "blob",
          "size": 5.2236328125,
          "content": "#\n# Copyright (C) 2023, Inria\n# GRAPHDECO research group, https://team.inria.fr/graphdeco\n# All rights reserved.\n#\n# This software is free for non-commercial, research and evaluation use\n# under the terms of the LICENSE.md file.\n#\n# For inquiries contact  george.drettakis@inria.fr\n#\n\nimport os\nimport logging\nfrom argparse import ArgumentParser\nimport shutil\n\n# This Python script is based on the shell converter script provided in the MipNerF 360 repository.\nparser = ArgumentParser(\"Colmap converter\")\nparser.add_argument(\"--no_gpu\", action='store_true')\nparser.add_argument(\"--skip_matching\", action='store_true')\nparser.add_argument(\"--source_path\", \"-s\", required=True, type=str)\nparser.add_argument(\"--camera\", default=\"OPENCV\", type=str)\nparser.add_argument(\"--colmap_executable\", default=\"\", type=str)\nparser.add_argument(\"--resize\", action=\"store_true\")\nparser.add_argument(\"--magick_executable\", default=\"\", type=str)\nargs = parser.parse_args()\ncolmap_command = '\"{}\"'.format(args.colmap_executable) if len(args.colmap_executable) > 0 else \"colmap\"\nmagick_command = '\"{}\"'.format(args.magick_executable) if len(args.magick_executable) > 0 else \"magick\"\nuse_gpu = 1 if not args.no_gpu else 0\n\nif not args.skip_matching:\n    os.makedirs(args.source_path + \"/distorted/sparse\", exist_ok=True)\n\n    ## Feature extraction\n    feat_extracton_cmd = colmap_command + \" feature_extractor \"\\\n        \"--database_path \" + args.source_path + \"/distorted/database.db \\\n        --image_path \" + args.source_path + \"/input \\\n        --ImageReader.single_camera 1 \\\n        --ImageReader.camera_model \" + args.camera + \" \\\n        --SiftExtraction.use_gpu \" + str(use_gpu)\n    exit_code = os.system(feat_extracton_cmd)\n    if exit_code != 0:\n        logging.error(f\"Feature extraction failed with code {exit_code}. Exiting.\")\n        exit(exit_code)\n\n    ## Feature matching\n    feat_matching_cmd = colmap_command + \" exhaustive_matcher \\\n        --database_path \" + args.source_path + \"/distorted/database.db \\\n        --SiftMatching.use_gpu \" + str(use_gpu)\n    exit_code = os.system(feat_matching_cmd)\n    if exit_code != 0:\n        logging.error(f\"Feature matching failed with code {exit_code}. Exiting.\")\n        exit(exit_code)\n\n    ### Bundle adjustment\n    # The default Mapper tolerance is unnecessarily large,\n    # decreasing it speeds up bundle adjustment steps.\n    mapper_cmd = (colmap_command + \" mapper \\\n        --database_path \" + args.source_path + \"/distorted/database.db \\\n        --image_path \"  + args.source_path + \"/input \\\n        --output_path \"  + args.source_path + \"/distorted/sparse \\\n        --Mapper.ba_global_function_tolerance=0.000001\")\n    exit_code = os.system(mapper_cmd)\n    if exit_code != 0:\n        logging.error(f\"Mapper failed with code {exit_code}. Exiting.\")\n        exit(exit_code)\n\n### Image undistortion\n## We need to undistort our images into ideal pinhole intrinsics.\nimg_undist_cmd = (colmap_command + \" image_undistorter \\\n    --image_path \" + args.source_path + \"/input \\\n    --input_path \" + args.source_path + \"/distorted/sparse/0 \\\n    --output_path \" + args.source_path + \"\\\n    --output_type COLMAP\")\nexit_code = os.system(img_undist_cmd)\nif exit_code != 0:\n    logging.error(f\"Mapper failed with code {exit_code}. Exiting.\")\n    exit(exit_code)\n\nfiles = os.listdir(args.source_path + \"/sparse\")\nos.makedirs(args.source_path + \"/sparse/0\", exist_ok=True)\n# Copy each file from the source directory to the destination directory\nfor file in files:\n    if file == '0':\n        continue\n    source_file = os.path.join(args.source_path, \"sparse\", file)\n    destination_file = os.path.join(args.source_path, \"sparse\", \"0\", file)\n    shutil.move(source_file, destination_file)\n\nif(args.resize):\n    print(\"Copying and resizing...\")\n\n    # Resize images.\n    os.makedirs(args.source_path + \"/images_2\", exist_ok=True)\n    os.makedirs(args.source_path + \"/images_4\", exist_ok=True)\n    os.makedirs(args.source_path + \"/images_8\", exist_ok=True)\n    # Get the list of files in the source directory\n    files = os.listdir(args.source_path + \"/images\")\n    # Copy each file from the source directory to the destination directory\n    for file in files:\n        source_file = os.path.join(args.source_path, \"images\", file)\n\n        destination_file = os.path.join(args.source_path, \"images_2\", file)\n        shutil.copy2(source_file, destination_file)\n        exit_code = os.system(magick_command + \" mogrify -resize 50% \" + destination_file)\n        if exit_code != 0:\n            logging.error(f\"50% resize failed with code {exit_code}. Exiting.\")\n            exit(exit_code)\n\n        destination_file = os.path.join(args.source_path, \"images_4\", file)\n        shutil.copy2(source_file, destination_file)\n        exit_code = os.system(magick_command + \" mogrify -resize 25% \" + destination_file)\n        if exit_code != 0:\n            logging.error(f\"25% resize failed with code {exit_code}. Exiting.\")\n            exit(exit_code)\n\n        destination_file = os.path.join(args.source_path, \"images_8\", file)\n        shutil.copy2(source_file, destination_file)\n        exit_code = os.system(magick_command + \" mogrify -resize 12.5% \" + destination_file)\n        if exit_code != 0:\n            logging.error(f\"12.5% resize failed with code {exit_code}. Exiting.\")\n            exit(exit_code)\n\nprint(\"Done.\")\n"
        },
        {
          "name": "environment.yml",
          "type": "blob",
          "size": 0.36328125,
          "content": "name: gaussian_splatting\nchannels:\n  - pytorch\n  - conda-forge\n  - defaults\ndependencies:\n  - cudatoolkit=11.6\n  - plyfile\n  - python=3.7.13\n  - pip=22.3.1\n  - pytorch=1.12.1\n  - torchaudio=0.12.1\n  - torchvision=0.13.1\n  - tqdm\n  - pip:\n    - submodules/diff-gaussian-rasterization\n    - submodules/simple-knn\n    - submodules/fused-ssim\n    - opencv-python\n    - joblib\n"
        },
        {
          "name": "full_eval.py",
          "type": "blob",
          "size": 4.419921875,
          "content": "#\n# Copyright (C) 2023, Inria\n# GRAPHDECO research group, https://team.inria.fr/graphdeco\n# All rights reserved.\n#\n# This software is free for non-commercial, research and evaluation use \n# under the terms of the LICENSE.md file.\n#\n# For inquiries contact  george.drettakis@inria.fr\n#\n\nimport os\nfrom argparse import ArgumentParser\nimport time\n\nmipnerf360_outdoor_scenes = [\"bicycle\", \"flowers\", \"garden\", \"stump\", \"treehill\"]\nmipnerf360_indoor_scenes = [\"room\", \"counter\", \"kitchen\", \"bonsai\"]\ntanks_and_temples_scenes = [\"truck\", \"train\"]\ndeep_blending_scenes = [\"drjohnson\", \"playroom\"]\n\nparser = ArgumentParser(description=\"Full evaluation script parameters\")\nparser.add_argument(\"--skip_training\", action=\"store_true\")\nparser.add_argument(\"--skip_rendering\", action=\"store_true\")\nparser.add_argument(\"--skip_metrics\", action=\"store_true\")\nparser.add_argument(\"--output_path\", default=\"./eval\")\nparser.add_argument(\"--use_depth\", action=\"store_true\")\nparser.add_argument(\"--use_expcomp\", action=\"store_true\")\nparser.add_argument(\"--fast\", action=\"store_true\")\nparser.add_argument(\"--aa\", action=\"store_true\")\n\n\n\n\nargs, _ = parser.parse_known_args()\n\nall_scenes = []\nall_scenes.extend(mipnerf360_outdoor_scenes)\nall_scenes.extend(mipnerf360_indoor_scenes)\nall_scenes.extend(tanks_and_temples_scenes)\nall_scenes.extend(deep_blending_scenes)\n\nif not args.skip_training or not args.skip_rendering:\n    parser.add_argument('--mipnerf360', \"-m360\", required=True, type=str)\n    parser.add_argument(\"--tanksandtemples\", \"-tat\", required=True, type=str)\n    parser.add_argument(\"--deepblending\", \"-db\", required=True, type=str)\n    args = parser.parse_args()\nif not args.skip_training:\n    common_args = \" --disable_viewer --quiet --eval --test_iterations -1 \"\n    \n    if args.aa:\n        common_args += \" --antialiasing \"\n    if args.use_depth:\n        common_args += \" -d depths2/ \"\n\n    if args.use_expcomp:\n        common_args += \" --exposure_lr_init 0.001 --exposure_lr_final 0.0001 --exposure_lr_delay_steps 5000 --exposure_lr_delay_mult 0.001 --train_test_exp \"\n\n    if args.fast:\n        common_args += \" --optimizer_type sparse_adam \"\n\n    start_time = time.time()\n    for scene in mipnerf360_outdoor_scenes:\n        source = args.mipnerf360 + \"/\" + scene\n        os.system(\"python train.py -s \" + source + \" -i images_4 -m \" + args.output_path + \"/\" + scene + common_args)\n    for scene in mipnerf360_indoor_scenes:\n        source = args.mipnerf360 + \"/\" + scene\n        os.system(\"python train.py -s \" + source + \" -i images_2 -m \" + args.output_path + \"/\" + scene + common_args)\n    m360_timing = (time.time() - start_time)/60.0\n\n    start_time = time.time()\n    for scene in tanks_and_temples_scenes:\n        source = args.tanksandtemples + \"/\" + scene\n        os.system(\"python train.py -s \" + source + \" -m \" + args.output_path + \"/\" + scene + common_args)\n    tandt_timing = (time.time() - start_time)/60.0\n\n    start_time = time.time()\n    for scene in deep_blending_scenes:\n        source = args.deepblending + \"/\" + scene\n        os.system(\"python train.py -s \" + source + \" -m \" + args.output_path + \"/\" + scene + common_args)\n    db_timing = (time.time() - start_time)/60.0\n\nwith open(os.path.join(args.output_path,\"timing.txt\"), 'w') as file:\n    file.write(f\"m360: {m360_timing} minutes \\n tandt: {tandt_timing} minutes \\n db: {db_timing} minutes\\n\")\n\nif not args.skip_rendering:\n    all_sources = []\n    for scene in mipnerf360_outdoor_scenes:\n        all_sources.append(args.mipnerf360 + \"/\" + scene)\n    for scene in mipnerf360_indoor_scenes:\n        all_sources.append(args.mipnerf360 + \"/\" + scene)\n    for scene in tanks_and_temples_scenes:\n        all_sources.append(args.tanksandtemples + \"/\" + scene)\n    for scene in deep_blending_scenes:\n        all_sources.append(args.deepblending + \"/\" + scene)\n    \n    common_args = \" --quiet --eval --skip_train\"\n    \n    if args.aa:\n        common_args += \" --antialiasing \"\n    if args.use_expcomp:\n        common_args += \" --train_test_exp \"\n\n    for scene, source in zip(all_scenes, all_sources):\n        os.system(\"python render.py --iteration 7000 -s \" + source + \" -m \" + args.output_path + \"/\" + scene + common_args)\n        os.system(\"python render.py --iteration 30000 -s \" + source + \" -m \" + args.output_path + \"/\" + scene + common_args)\n\nif not args.skip_metrics:\n    scenes_string = \"\"\n    for scene in all_scenes:\n        scenes_string += \"\\\"\" + args.output_path + \"/\" + scene + \"\\\" \"\n\n    os.system(\"python metrics.py -m \" + scenes_string)\n"
        },
        {
          "name": "gaussian_renderer",
          "type": "tree",
          "content": null
        },
        {
          "name": "lpipsPyTorch",
          "type": "tree",
          "content": null
        },
        {
          "name": "metrics.py",
          "type": "blob",
          "size": 4.0458984375,
          "content": "#\n# Copyright (C) 2023, Inria\n# GRAPHDECO research group, https://team.inria.fr/graphdeco\n# All rights reserved.\n#\n# This software is free for non-commercial, research and evaluation use \n# under the terms of the LICENSE.md file.\n#\n# For inquiries contact  george.drettakis@inria.fr\n#\n\nfrom pathlib import Path\nimport os\nfrom PIL import Image\nimport torch\nimport torchvision.transforms.functional as tf\nfrom utils.loss_utils import ssim\nfrom lpipsPyTorch import lpips\nimport json\nfrom tqdm import tqdm\nfrom utils.image_utils import psnr\nfrom argparse import ArgumentParser\n\ndef readImages(renders_dir, gt_dir):\n    renders = []\n    gts = []\n    image_names = []\n    for fname in os.listdir(renders_dir):\n        render = Image.open(renders_dir / fname)\n        gt = Image.open(gt_dir / fname)\n        renders.append(tf.to_tensor(render).unsqueeze(0)[:, :3, :, :].cuda())\n        gts.append(tf.to_tensor(gt).unsqueeze(0)[:, :3, :, :].cuda())\n        image_names.append(fname)\n    return renders, gts, image_names\n\ndef evaluate(model_paths):\n\n    full_dict = {}\n    per_view_dict = {}\n    full_dict_polytopeonly = {}\n    per_view_dict_polytopeonly = {}\n    print(\"\")\n\n    for scene_dir in model_paths:\n        try:\n            print(\"Scene:\", scene_dir)\n            full_dict[scene_dir] = {}\n            per_view_dict[scene_dir] = {}\n            full_dict_polytopeonly[scene_dir] = {}\n            per_view_dict_polytopeonly[scene_dir] = {}\n\n            test_dir = Path(scene_dir) / \"test\"\n\n            for method in os.listdir(test_dir):\n                print(\"Method:\", method)\n\n                full_dict[scene_dir][method] = {}\n                per_view_dict[scene_dir][method] = {}\n                full_dict_polytopeonly[scene_dir][method] = {}\n                per_view_dict_polytopeonly[scene_dir][method] = {}\n\n                method_dir = test_dir / method\n                gt_dir = method_dir/ \"gt\"\n                renders_dir = method_dir / \"renders\"\n                renders, gts, image_names = readImages(renders_dir, gt_dir)\n\n                ssims = []\n                psnrs = []\n                lpipss = []\n\n                for idx in tqdm(range(len(renders)), desc=\"Metric evaluation progress\"):\n                    ssims.append(ssim(renders[idx], gts[idx]))\n                    psnrs.append(psnr(renders[idx], gts[idx]))\n                    lpipss.append(lpips(renders[idx], gts[idx], net_type='vgg'))\n\n                print(\"  SSIM : {:>12.7f}\".format(torch.tensor(ssims).mean(), \".5\"))\n                print(\"  PSNR : {:>12.7f}\".format(torch.tensor(psnrs).mean(), \".5\"))\n                print(\"  LPIPS: {:>12.7f}\".format(torch.tensor(lpipss).mean(), \".5\"))\n                print(\"\")\n\n                full_dict[scene_dir][method].update({\"SSIM\": torch.tensor(ssims).mean().item(),\n                                                        \"PSNR\": torch.tensor(psnrs).mean().item(),\n                                                        \"LPIPS\": torch.tensor(lpipss).mean().item()})\n                per_view_dict[scene_dir][method].update({\"SSIM\": {name: ssim for ssim, name in zip(torch.tensor(ssims).tolist(), image_names)},\n                                                            \"PSNR\": {name: psnr for psnr, name in zip(torch.tensor(psnrs).tolist(), image_names)},\n                                                            \"LPIPS\": {name: lp for lp, name in zip(torch.tensor(lpipss).tolist(), image_names)}})\n\n            with open(scene_dir + \"/results.json\", 'w') as fp:\n                json.dump(full_dict[scene_dir], fp, indent=True)\n            with open(scene_dir + \"/per_view.json\", 'w') as fp:\n                json.dump(per_view_dict[scene_dir], fp, indent=True)\n        except:\n            print(\"Unable to compute metrics for model\", scene_dir)\n\nif __name__ == \"__main__\":\n    device = torch.device(\"cuda:0\")\n    torch.cuda.set_device(device)\n\n    # Set up command line argument parser\n    parser = ArgumentParser(description=\"Training script parameters\")\n    parser.add_argument('--model_paths', '-m', required=True, nargs=\"+\", type=str, default=[])\n    args = parser.parse_args()\n    evaluate(args.model_paths)\n"
        },
        {
          "name": "render.py",
          "type": "blob",
          "size": 3.236328125,
          "content": "#\n# Copyright (C) 2023, Inria\n# GRAPHDECO research group, https://team.inria.fr/graphdeco\n# All rights reserved.\n#\n# This software is free for non-commercial, research and evaluation use \n# under the terms of the LICENSE.md file.\n#\n# For inquiries contact  george.drettakis@inria.fr\n#\n\nimport torch\nfrom scene import Scene\nimport os\nfrom tqdm import tqdm\nfrom os import makedirs\nfrom gaussian_renderer import render\nimport torchvision\nfrom utils.general_utils import safe_state\nfrom argparse import ArgumentParser\nfrom arguments import ModelParams, PipelineParams, get_combined_args\nfrom gaussian_renderer import GaussianModel\ntry:\n    from diff_gaussian_rasterization import SparseGaussianAdam\n    SPARSE_ADAM_AVAILABLE = True\nexcept:\n    SPARSE_ADAM_AVAILABLE = False\n\n\ndef render_set(model_path, name, iteration, views, gaussians, pipeline, background, train_test_exp, separate_sh):\n    render_path = os.path.join(model_path, name, \"ours_{}\".format(iteration), \"renders\")\n    gts_path = os.path.join(model_path, name, \"ours_{}\".format(iteration), \"gt\")\n\n    makedirs(render_path, exist_ok=True)\n    makedirs(gts_path, exist_ok=True)\n\n    for idx, view in enumerate(tqdm(views, desc=\"Rendering progress\")):\n        rendering = render(view, gaussians, pipeline, background, use_trained_exp=train_test_exp, separate_sh=separate_sh)[\"render\"]\n        gt = view.original_image[0:3, :, :]\n\n        if args.train_test_exp:\n            rendering = rendering[..., rendering.shape[-1] // 2:]\n            gt = gt[..., gt.shape[-1] // 2:]\n\n        torchvision.utils.save_image(rendering, os.path.join(render_path, '{0:05d}'.format(idx) + \".png\"))\n        torchvision.utils.save_image(gt, os.path.join(gts_path, '{0:05d}'.format(idx) + \".png\"))\n\ndef render_sets(dataset : ModelParams, iteration : int, pipeline : PipelineParams, skip_train : bool, skip_test : bool, separate_sh: bool):\n    with torch.no_grad():\n        gaussians = GaussianModel(dataset.sh_degree)\n        scene = Scene(dataset, gaussians, load_iteration=iteration, shuffle=False)\n\n        bg_color = [1,1,1] if dataset.white_background else [0, 0, 0]\n        background = torch.tensor(bg_color, dtype=torch.float32, device=\"cuda\")\n\n        if not skip_train:\n             render_set(dataset.model_path, \"train\", scene.loaded_iter, scene.getTrainCameras(), gaussians, pipeline, background, dataset.train_test_exp, separate_sh)\n\n        if not skip_test:\n             render_set(dataset.model_path, \"test\", scene.loaded_iter, scene.getTestCameras(), gaussians, pipeline, background, dataset.train_test_exp, separate_sh)\n\nif __name__ == \"__main__\":\n    # Set up command line argument parser\n    parser = ArgumentParser(description=\"Testing script parameters\")\n    model = ModelParams(parser, sentinel=True)\n    pipeline = PipelineParams(parser)\n    parser.add_argument(\"--iteration\", default=-1, type=int)\n    parser.add_argument(\"--skip_train\", action=\"store_true\")\n    parser.add_argument(\"--skip_test\", action=\"store_true\")\n    parser.add_argument(\"--quiet\", action=\"store_true\")\n    args = get_combined_args(parser)\n    print(\"Rendering \" + args.model_path)\n\n    # Initialize system state (RNG)\n    safe_state(args.quiet)\n\n    render_sets(model.extract(args), args.iteration, pipeline.extract(args), args.skip_train, args.skip_test, SPARSE_ADAM_AVAILABLE)"
        },
        {
          "name": "results.md",
          "type": "blob",
          "size": 3.3701171875,
          "content": "# Evaluations\nWe evaluated the impact of the features we added on MipNeRF360, Tanks&Temples and Deep Blending datasets. [Exposure Compensation](#exposure-compensation) is evaluated separately. Note that [Default rasterizer](#default-rasterizer) refers to the original [3dgs rasterizer](https://github.com/graphdeco-inria/diff-gaussian-rasterization/tree/9c5c2028f6fbee2be239bc4c9421ff894fe4fbe0) and [Accelerated rasterizer](#accelerated-rasterizer) refers to the [taming-3dgs rasterizer](https://github.com/graphdeco-inria/diff-gaussian-rasterization/tree/3dgs_accel).\n\n## Default rasterizer\n\n### PSNR\n\n![all results PSNR](assets/charts/base_PSNR.png)\n\n***DR**:depth regularization, **AA**:antialiasing*\n\n<br>\n\n![nodepth/depth](assets/depth_comparison.png)\n\n### SSIM\n![all results SSIM](assets/charts/base_SSIM.png)\n\n***DR**:depth regularization, **AA**:antialiasing*\n\n### LPIPS\n![all results LPIPS](assets/charts/base_LPIPS.png)\n\n*lower is better, **DR**:depth regularization, **AA**:antialiasing*\n\n## Accelerated rasterizer\n\n### Default optimizer\n\nThese numbers were obtained using the accelerated rasterizer and `--optimizer_type default` when training.\n\n#### PSNR\n![all results PSNR](assets/charts/accel_default_PSNR.png)\n\n***DR**:depth regularization, **AA**:antialiasing*\n\n#### SSIM\n![all results SSIM](assets/charts/accel_default_SSIM.png)\n\n***DR**:depth regularization, **AA**:antialiasing*\n\n#### LPIPS\n![all results LPIPS](assets/charts/accel_default_LPIPS.png)\n\n*lower is better, **DR**:depth regularization, **AA**:antialiasing*\n\n### Sparse Adam optimizer\n\nThese numbers were obtained using the accelerated rasterizer and `--optimizer_type sparse_adam` when training.\n\n#### PSNR\n![all results PSNR](assets/charts/accel_sparse_adam_PSNR.png)\n\n***DR**:depth regularization, **AA**:antialiasing*\n\n#### SSIM\n![all results SSIM](assets/charts/accel_sparse_adam_SSIM.png)\n\n***DR**:depth regularization, **AA**:antialiasing*\n\n#### LPIPS\n![all results LPIPS](assets/charts/accel_sparse_adam_LPIPS.png)\n\n*lower is better, **DR**:depth regularization, **AA**:antialiasing*\n\n## Exposure compensation\n\nWe account for exposure variations between images by optimizing a 3x4 affine transform for each image. During training, this transform is applied to the colour of the rendered images.\nThe exposure compensation is designed to improve the inputs' coherence during training and is not applied during real-time navigation.\nEnabling the `--train_test_exp` option includes the left half of the test images in the training set, using only their right halves for testing, following the same testing methodology as NeRF-W and Mega-NeRF. This allows us to optimize the exposure affine transform for test views. However, since this setting alters the train/test splits, the resulting metrics are not comparable to those from models trained without it. Here we provide results with `--train_test_exp`, with and without exposure compensation.\n\n### PSNR\n\n![exposures_psnr](/assets/charts/exposure_PSNR.png)\n\n### SSIM\n\n![exposures_ssim](/assets/charts/exposure_SSIM.png)\n\n### LPIPS\n\n*Lower is better.*\n![exposures_lpips](/assets/charts/exposure_LPIPS.png)\n\n![noexposure/exposure](assets/Exposure_comparison.png)\n\n## Training times comparisons\n\nWe report the training times with all features enabled using the original 3dgs rasterizer *(baseline)* and the accelerated rasterizer with default optimizer then sparse adam.\n![Training-times](assets/charts/timings.png)\n"
        },
        {
          "name": "scene",
          "type": "tree",
          "content": null
        },
        {
          "name": "submodules",
          "type": "tree",
          "content": null
        },
        {
          "name": "train.py",
          "type": "blob",
          "size": 13.08984375,
          "content": "#\n# Copyright (C) 2023, Inria\n# GRAPHDECO research group, https://team.inria.fr/graphdeco\n# All rights reserved.\n#\n# This software is free for non-commercial, research and evaluation use \n# under the terms of the LICENSE.md file.\n#\n# For inquiries contact  george.drettakis@inria.fr\n#\n\nimport os\nimport torch\nfrom random import randint\nfrom utils.loss_utils import l1_loss, ssim\nfrom gaussian_renderer import render, network_gui\nimport sys\nfrom scene import Scene, GaussianModel\nfrom utils.general_utils import safe_state, get_expon_lr_func\nimport uuid\nfrom tqdm import tqdm\nfrom utils.image_utils import psnr\nfrom argparse import ArgumentParser, Namespace\nfrom arguments import ModelParams, PipelineParams, OptimizationParams\ntry:\n    from torch.utils.tensorboard import SummaryWriter\n    TENSORBOARD_FOUND = True\nexcept ImportError:\n    TENSORBOARD_FOUND = False\n\ntry:\n    from fused_ssim import fused_ssim\n    FUSED_SSIM_AVAILABLE = True\nexcept:\n    FUSED_SSIM_AVAILABLE = False\n\ntry:\n    from diff_gaussian_rasterization import SparseGaussianAdam\n    SPARSE_ADAM_AVAILABLE = True\nexcept:\n    SPARSE_ADAM_AVAILABLE = False\n\ndef training(dataset, opt, pipe, testing_iterations, saving_iterations, checkpoint_iterations, checkpoint, debug_from):\n\n    if not SPARSE_ADAM_AVAILABLE and opt.optimizer_type == \"sparse_adam\":\n        sys.exit(f\"Trying to use sparse adam but it is not installed, please install the correct rasterizer using pip install [3dgs_accel].\")\n\n    first_iter = 0\n    tb_writer = prepare_output_and_logger(dataset)\n    gaussians = GaussianModel(dataset.sh_degree, opt.optimizer_type)\n    scene = Scene(dataset, gaussians)\n    gaussians.training_setup(opt)\n    if checkpoint:\n        (model_params, first_iter) = torch.load(checkpoint)\n        gaussians.restore(model_params, opt)\n\n    bg_color = [1, 1, 1] if dataset.white_background else [0, 0, 0]\n    background = torch.tensor(bg_color, dtype=torch.float32, device=\"cuda\")\n\n    iter_start = torch.cuda.Event(enable_timing = True)\n    iter_end = torch.cuda.Event(enable_timing = True)\n\n    use_sparse_adam = opt.optimizer_type == \"sparse_adam\" and SPARSE_ADAM_AVAILABLE \n    depth_l1_weight = get_expon_lr_func(opt.depth_l1_weight_init, opt.depth_l1_weight_final, max_steps=opt.iterations)\n\n    viewpoint_stack = scene.getTrainCameras().copy()\n    viewpoint_indices = list(range(len(viewpoint_stack)))\n    ema_loss_for_log = 0.0\n    ema_Ll1depth_for_log = 0.0\n\n    progress_bar = tqdm(range(first_iter, opt.iterations), desc=\"Training progress\")\n    first_iter += 1\n    for iteration in range(first_iter, opt.iterations + 1):\n        if network_gui.conn == None:\n            network_gui.try_connect()\n        while network_gui.conn != None:\n            try:\n                net_image_bytes = None\n                custom_cam, do_training, pipe.convert_SHs_python, pipe.compute_cov3D_python, keep_alive, scaling_modifer = network_gui.receive()\n                if custom_cam != None:\n                    net_image = render(custom_cam, gaussians, pipe, background, scaling_modifier=scaling_modifer, use_trained_exp=dataset.train_test_exp, separate_sh=SPARSE_ADAM_AVAILABLE)[\"render\"]\n                    net_image_bytes = memoryview((torch.clamp(net_image, min=0, max=1.0) * 255).byte().permute(1, 2, 0).contiguous().cpu().numpy())\n                network_gui.send(net_image_bytes, dataset.source_path)\n                if do_training and ((iteration < int(opt.iterations)) or not keep_alive):\n                    break\n            except Exception as e:\n                network_gui.conn = None\n\n        iter_start.record()\n\n        gaussians.update_learning_rate(iteration)\n\n        # Every 1000 its we increase the levels of SH up to a maximum degree\n        if iteration % 1000 == 0:\n            gaussians.oneupSHdegree()\n\n        # Pick a random Camera\n        if not viewpoint_stack:\n            viewpoint_stack = scene.getTrainCameras().copy()\n            viewpoint_indices = list(range(len(viewpoint_stack)))\n        rand_idx = randint(0, len(viewpoint_indices) - 1)\n        viewpoint_cam = viewpoint_stack.pop(rand_idx)\n        vind = viewpoint_indices.pop(rand_idx)\n\n        # Render\n        if (iteration - 1) == debug_from:\n            pipe.debug = True\n\n        bg = torch.rand((3), device=\"cuda\") if opt.random_background else background\n\n        render_pkg = render(viewpoint_cam, gaussians, pipe, bg, use_trained_exp=dataset.train_test_exp, separate_sh=SPARSE_ADAM_AVAILABLE)\n        image, viewspace_point_tensor, visibility_filter, radii = render_pkg[\"render\"], render_pkg[\"viewspace_points\"], render_pkg[\"visibility_filter\"], render_pkg[\"radii\"]\n\n        if viewpoint_cam.alpha_mask is not None:\n            alpha_mask = viewpoint_cam.alpha_mask.cuda()\n            image *= alpha_mask\n\n        # Loss\n        gt_image = viewpoint_cam.original_image.cuda()\n        Ll1 = l1_loss(image, gt_image)\n        if FUSED_SSIM_AVAILABLE:\n            ssim_value = fused_ssim(image.unsqueeze(0), gt_image.unsqueeze(0))\n        else:\n            ssim_value = ssim(image, gt_image)\n\n        loss = (1.0 - opt.lambda_dssim) * Ll1 + opt.lambda_dssim * (1.0 - ssim_value)\n\n        # Depth regularization\n        Ll1depth_pure = 0.0\n        if depth_l1_weight(iteration) > 0 and viewpoint_cam.depth_reliable:\n            invDepth = render_pkg[\"depth\"]\n            mono_invdepth = viewpoint_cam.invdepthmap.cuda()\n            depth_mask = viewpoint_cam.depth_mask.cuda()\n\n            Ll1depth_pure = torch.abs((invDepth  - mono_invdepth) * depth_mask).mean()\n            Ll1depth = depth_l1_weight(iteration) * Ll1depth_pure \n            loss += Ll1depth\n            Ll1depth = Ll1depth.item()\n        else:\n            Ll1depth = 0\n\n        loss.backward()\n\n        iter_end.record()\n\n        with torch.no_grad():\n            # Progress bar\n            ema_loss_for_log = 0.4 * loss.item() + 0.6 * ema_loss_for_log\n            ema_Ll1depth_for_log = 0.4 * Ll1depth + 0.6 * ema_Ll1depth_for_log\n\n            if iteration % 10 == 0:\n                progress_bar.set_postfix({\"Loss\": f\"{ema_loss_for_log:.{7}f}\", \"Depth Loss\": f\"{ema_Ll1depth_for_log:.{7}f}\"})\n                progress_bar.update(10)\n            if iteration == opt.iterations:\n                progress_bar.close()\n\n            # Log and save\n            training_report(tb_writer, iteration, Ll1, loss, l1_loss, iter_start.elapsed_time(iter_end), testing_iterations, scene, render, (pipe, background, 1., SPARSE_ADAM_AVAILABLE, None, dataset.train_test_exp), dataset.train_test_exp)\n            if (iteration in saving_iterations):\n                print(\"\\n[ITER {}] Saving Gaussians\".format(iteration))\n                scene.save(iteration)\n\n            # Densification\n            if iteration < opt.densify_until_iter:\n                # Keep track of max radii in image-space for pruning\n                gaussians.max_radii2D[visibility_filter] = torch.max(gaussians.max_radii2D[visibility_filter], radii[visibility_filter])\n                gaussians.add_densification_stats(viewspace_point_tensor, visibility_filter)\n\n                if iteration > opt.densify_from_iter and iteration % opt.densification_interval == 0:\n                    size_threshold = 20 if iteration > opt.opacity_reset_interval else None\n                    gaussians.densify_and_prune(opt.densify_grad_threshold, 0.005, scene.cameras_extent, size_threshold, radii)\n                \n                if iteration % opt.opacity_reset_interval == 0 or (dataset.white_background and iteration == opt.densify_from_iter):\n                    gaussians.reset_opacity()\n\n            # Optimizer step\n            if iteration < opt.iterations:\n                gaussians.exposure_optimizer.step()\n                gaussians.exposure_optimizer.zero_grad(set_to_none = True)\n                if use_sparse_adam:\n                    visible = radii > 0\n                    gaussians.optimizer.step(visible, radii.shape[0])\n                    gaussians.optimizer.zero_grad(set_to_none = True)\n                else:\n                    gaussians.optimizer.step()\n                    gaussians.optimizer.zero_grad(set_to_none = True)\n\n            if (iteration in checkpoint_iterations):\n                print(\"\\n[ITER {}] Saving Checkpoint\".format(iteration))\n                torch.save((gaussians.capture(), iteration), scene.model_path + \"/chkpnt\" + str(iteration) + \".pth\")\n\ndef prepare_output_and_logger(args):    \n    if not args.model_path:\n        if os.getenv('OAR_JOB_ID'):\n            unique_str=os.getenv('OAR_JOB_ID')\n        else:\n            unique_str = str(uuid.uuid4())\n        args.model_path = os.path.join(\"./output/\", unique_str[0:10])\n        \n    # Set up output folder\n    print(\"Output folder: {}\".format(args.model_path))\n    os.makedirs(args.model_path, exist_ok = True)\n    with open(os.path.join(args.model_path, \"cfg_args\"), 'w') as cfg_log_f:\n        cfg_log_f.write(str(Namespace(**vars(args))))\n\n    # Create Tensorboard writer\n    tb_writer = None\n    if TENSORBOARD_FOUND:\n        tb_writer = SummaryWriter(args.model_path)\n    else:\n        print(\"Tensorboard not available: not logging progress\")\n    return tb_writer\n\ndef training_report(tb_writer, iteration, Ll1, loss, l1_loss, elapsed, testing_iterations, scene : Scene, renderFunc, renderArgs, train_test_exp):\n    if tb_writer:\n        tb_writer.add_scalar('train_loss_patches/l1_loss', Ll1.item(), iteration)\n        tb_writer.add_scalar('train_loss_patches/total_loss', loss.item(), iteration)\n        tb_writer.add_scalar('iter_time', elapsed, iteration)\n\n    # Report test and samples of training set\n    if iteration in testing_iterations:\n        torch.cuda.empty_cache()\n        validation_configs = ({'name': 'test', 'cameras' : scene.getTestCameras()}, \n                              {'name': 'train', 'cameras' : [scene.getTrainCameras()[idx % len(scene.getTrainCameras())] for idx in range(5, 30, 5)]})\n\n        for config in validation_configs:\n            if config['cameras'] and len(config['cameras']) > 0:\n                l1_test = 0.0\n                psnr_test = 0.0\n                for idx, viewpoint in enumerate(config['cameras']):\n                    image = torch.clamp(renderFunc(viewpoint, scene.gaussians, *renderArgs)[\"render\"], 0.0, 1.0)\n                    gt_image = torch.clamp(viewpoint.original_image.to(\"cuda\"), 0.0, 1.0)\n                    if train_test_exp:\n                        image = image[..., image.shape[-1] // 2:]\n                        gt_image = gt_image[..., gt_image.shape[-1] // 2:]\n                    if tb_writer and (idx < 5):\n                        tb_writer.add_images(config['name'] + \"_view_{}/render\".format(viewpoint.image_name), image[None], global_step=iteration)\n                        if iteration == testing_iterations[0]:\n                            tb_writer.add_images(config['name'] + \"_view_{}/ground_truth\".format(viewpoint.image_name), gt_image[None], global_step=iteration)\n                    l1_test += l1_loss(image, gt_image).mean().double()\n                    psnr_test += psnr(image, gt_image).mean().double()\n                psnr_test /= len(config['cameras'])\n                l1_test /= len(config['cameras'])          \n                print(\"\\n[ITER {}] Evaluating {}: L1 {} PSNR {}\".format(iteration, config['name'], l1_test, psnr_test))\n                if tb_writer:\n                    tb_writer.add_scalar(config['name'] + '/loss_viewpoint - l1_loss', l1_test, iteration)\n                    tb_writer.add_scalar(config['name'] + '/loss_viewpoint - psnr', psnr_test, iteration)\n\n        if tb_writer:\n            tb_writer.add_histogram(\"scene/opacity_histogram\", scene.gaussians.get_opacity, iteration)\n            tb_writer.add_scalar('total_points', scene.gaussians.get_xyz.shape[0], iteration)\n        torch.cuda.empty_cache()\n\nif __name__ == \"__main__\":\n    # Set up command line argument parser\n    parser = ArgumentParser(description=\"Training script parameters\")\n    lp = ModelParams(parser)\n    op = OptimizationParams(parser)\n    pp = PipelineParams(parser)\n    parser.add_argument('--ip', type=str, default=\"127.0.0.1\")\n    parser.add_argument('--port', type=int, default=6009)\n    parser.add_argument('--debug_from', type=int, default=-1)\n    parser.add_argument('--detect_anomaly', action='store_true', default=False)\n    parser.add_argument(\"--test_iterations\", nargs=\"+\", type=int, default=[7_000, 30_000])\n    parser.add_argument(\"--save_iterations\", nargs=\"+\", type=int, default=[7_000, 30_000])\n    parser.add_argument(\"--quiet\", action=\"store_true\")\n    parser.add_argument('--disable_viewer', action='store_true', default=False)\n    parser.add_argument(\"--checkpoint_iterations\", nargs=\"+\", type=int, default=[])\n    parser.add_argument(\"--start_checkpoint\", type=str, default = None)\n    args = parser.parse_args(sys.argv[1:])\n    args.save_iterations.append(args.iterations)\n    \n    print(\"Optimizing \" + args.model_path)\n\n    # Initialize system state (RNG)\n    safe_state(args.quiet)\n\n    # Start GUI server, configure and run training\n    if not args.disable_viewer:\n        network_gui.init(args.ip, args.port)\n    torch.autograd.set_detect_anomaly(args.detect_anomaly)\n    training(lp.extract(args), op.extract(args), pp.extract(args), args.test_iterations, args.save_iterations, args.checkpoint_iterations, args.start_checkpoint, args.debug_from)\n\n    # All done\n    print(\"\\nTraining complete.\")\n"
        },
        {
          "name": "utils",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}