{
  "metadata": {
    "timestamp": 1736559906544,
    "page": 664,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjY3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "rkern/line_profiler",
      "stars": 3609,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.1474609375,
          "content": "# Swap files.\n.*.swp\n.*.swo\n*~\n\n*.pyc\n*.pyo\n*.so\n*.o\n*.a\n\nbuild/\ndist/\n_line_profiler.c\nline_profiler.egg-info/\nMANIFEST\npypi-site-docs.zip\nindex.html\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.5146484375,
          "content": "language: python\npython:\n  - \"nightly\"\n  - \"3.7-dev\"\n  - \"3.6-dev\"\n  - \"3.6\"\n  - \"3.5\"\n  - \"3.4\"\n  - \"3.3\"\n  - \"2.7\"\nmatrix:\n  fast_finish: true\n  allow_failures:\n    - python: \"nightly\"\n    - python: \"3.7-dev\"\n    - python: \"3.6-dev\"\ninstall:\n  - pip install --install-option='--no-cython-compile' Cython\n  - pip install -r dev_requirements.txt\n  - python setup.py develop\nscript:\n  - python -m unittest discover -v tests\nnotifications:\n  email:\n      - brett.olsen+travis-ci@gmail.com\n      - robert.kern+travis-ci@gmail.com\n"
        },
        {
          "name": "LICENSE.txt",
          "type": "blob",
          "size": 1.578125,
          "content": "This software is OSI Certified Open Source Software.\nOSI Certified is a certification mark of the Open Source Initiative.\n\nCopyright (c) 2008, Enthought, Inc.\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n * Redistributions of source code must retain the above copyright notice, this\n   list of conditions and the following disclaimer.\n * Redistributions in binary form must reproduce the above copyright notice,\n   this list of conditions and the following disclaimer in the documentation\n   and/or other materials provided with the distribution.\n * Neither the name of Enthought, Inc. nor the names of its contributors may\n   be used to endorse or promote products derived from this software without\n   specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "LICENSE_Python.txt",
          "type": "blob",
          "size": 13.5458984375,
          "content": "The file timers.c was derived from the timer code in Python 2.5.2's _lsprof.c\nfile and falls under the PSF license given below.\n\n\nA. HISTORY OF THE SOFTWARE\n==========================\n\nPython was created in the early 1990s by Guido van Rossum at Stichting\nMathematisch Centrum (CWI, see http://www.cwi.nl) in the Netherlands\nas a successor of a language called ABC.  Guido remains Python's\nprincipal author, although it includes many contributions from others.\n\nIn 1995, Guido continued his work on Python at the Corporation for\nNational Research Initiatives (CNRI, see http://www.cnri.reston.va.us)\nin Reston, Virginia where he released several versions of the\nsoftware.\n\nIn May 2000, Guido and the Python core development team moved to\nBeOpen.com to form the BeOpen PythonLabs team.  In October of the same\nyear, the PythonLabs team moved to Digital Creations (now Zope\nCorporation, see http://www.zope.com).  In 2001, the Python Software\nFoundation (PSF, see http://www.python.org/psf/) was formed, a\nnon-profit organization created specifically to own Python-related\nIntellectual Property.  Zope Corporation is a sponsoring member of\nthe PSF.\n\nAll Python releases are Open Source (see http://www.opensource.org for\nthe Open Source Definition).  Historically, most, but not all, Python\nreleases have also been GPL-compatible; the table below summarizes\nthe various releases.\n\n    Release         Derived     Year        Owner       GPL-\n                    from                                compatible? (1)\n\n    0.9.0 thru 1.2              1991-1995   CWI         yes\n    1.3 thru 1.5.2  1.2         1995-1999   CNRI        yes\n    1.6             1.5.2       2000        CNRI        no\n    2.0             1.6         2000        BeOpen.com  no\n    1.6.1           1.6         2001        CNRI        yes (2)\n    2.1             2.0+1.6.1   2001        PSF         no\n    2.0.1           2.0+1.6.1   2001        PSF         yes\n    2.1.1           2.1+2.0.1   2001        PSF         yes\n    2.2             2.1.1       2001        PSF         yes\n    2.1.2           2.1.1       2002        PSF         yes\n    2.1.3           2.1.2       2002        PSF         yes\n    2.2.1           2.2         2002        PSF         yes\n    2.2.2           2.2.1       2002        PSF         yes\n    2.2.3           2.2.2       2003        PSF         yes\n    2.3             2.2.2       2002-2003   PSF         yes\n    2.3.1           2.3         2002-2003   PSF         yes\n    2.3.2           2.3.1       2002-2003   PSF         yes\n    2.3.3           2.3.2       2002-2003   PSF         yes\n    2.3.4           2.3.3       2004        PSF         yes\n    2.3.5           2.3.4       2005        PSF         yes\n    2.4             2.3         2004        PSF         yes\n    2.4.1           2.4         2005        PSF         yes\n    2.4.2           2.4.1       2005        PSF         yes\n    2.4.3           2.4.2       2006        PSF         yes\n    2.4.4           2.4.3       2006        PSF         yes\n    2.5             2.4         2006        PSF         yes\n    2.5.1           2.5         2007        PSF         yes\n    2.5.2           2.5.2       2008        PSF         yes\n\nFootnotes:\n\n(1) GPL-compatible doesn't mean that we're distributing Python under\n    the GPL.  All Python licenses, unlike the GPL, let you distribute\n    a modified version without making your changes open source.  The\n    GPL-compatible licenses make it possible to combine Python with\n    other software that is released under the GPL; the others don't.\n\n(2) According to Richard Stallman, 1.6.1 is not GPL-compatible,\n    because its license has a choice of law clause.  According to\n    CNRI, however, Stallman's lawyer has told CNRI's lawyer that 1.6.1\n    is \"not incompatible\" with the GPL.\n\nThanks to the many outside volunteers who have worked under Guido's\ndirection to make these releases possible.\n\n\nB. TERMS AND CONDITIONS FOR ACCESSING OR OTHERWISE USING PYTHON\n===============================================================\n\nPYTHON SOFTWARE FOUNDATION LICENSE VERSION 2\n--------------------------------------------\n\n1. This LICENSE AGREEMENT is between the Python Software Foundation\n(\"PSF\"), and the Individual or Organization (\"Licensee\") accessing and\notherwise using this software (\"Python\") in source or binary form and\nits associated documentation.\n\n2. Subject to the terms and conditions of this License Agreement, PSF\nhereby grants Licensee a nonexclusive, royalty-free, world-wide\nlicense to reproduce, analyze, test, perform and/or display publicly,\nprepare derivative works, distribute, and otherwise use Python\nalone or in any derivative version, provided, however, that PSF's\nLicense Agreement and PSF's notice of copyright, i.e., \"Copyright (c)\n2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 Python Software Foundation; \nAll Rights Reserved\" are retained in Python alone or in any derivative \nversion prepared by Licensee.\n\n3. In the event Licensee prepares a derivative work that is based on\nor incorporates Python or any part thereof, and wants to make\nthe derivative work available to others as provided herein, then\nLicensee hereby agrees to include in any such work a brief summary of\nthe changes made to Python.\n\n4. PSF is making Python available to Licensee on an \"AS IS\"\nbasis.  PSF MAKES NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR\nIMPLIED.  BY WAY OF EXAMPLE, BUT NOT LIMITATION, PSF MAKES NO AND\nDISCLAIMS ANY REPRESENTATION OR WARRANTY OF MERCHANTABILITY OR FITNESS\nFOR ANY PARTICULAR PURPOSE OR THAT THE USE OF PYTHON WILL NOT\nINFRINGE ANY THIRD PARTY RIGHTS.\n\n5. PSF SHALL NOT BE LIABLE TO LICENSEE OR ANY OTHER USERS OF PYTHON\nFOR ANY INCIDENTAL, SPECIAL, OR CONSEQUENTIAL DAMAGES OR LOSS AS\nA RESULT OF MODIFYING, DISTRIBUTING, OR OTHERWISE USING PYTHON,\nOR ANY DERIVATIVE THEREOF, EVEN IF ADVISED OF THE POSSIBILITY THEREOF.\n\n6. This License Agreement will automatically terminate upon a material\nbreach of its terms and conditions.\n\n7. Nothing in this License Agreement shall be deemed to create any\nrelationship of agency, partnership, or joint venture between PSF and\nLicensee.  This License Agreement does not grant permission to use PSF\ntrademarks or trade name in a trademark sense to endorse or promote\nproducts or services of Licensee, or any third party.\n\n8. By copying, installing or otherwise using Python, Licensee\nagrees to be bound by the terms and conditions of this License\nAgreement.\n\n\nBEOPEN.COM LICENSE AGREEMENT FOR PYTHON 2.0\n-------------------------------------------\n\nBEOPEN PYTHON OPEN SOURCE LICENSE AGREEMENT VERSION 1\n\n1. This LICENSE AGREEMENT is between BeOpen.com (\"BeOpen\"), having an\noffice at 160 Saratoga Avenue, Santa Clara, CA 95051, and the\nIndividual or Organization (\"Licensee\") accessing and otherwise using\nthis software in source or binary form and its associated\ndocumentation (\"the Software\").\n\n2. Subject to the terms and conditions of this BeOpen Python License\nAgreement, BeOpen hereby grants Licensee a non-exclusive,\nroyalty-free, world-wide license to reproduce, analyze, test, perform\nand/or display publicly, prepare derivative works, distribute, and\notherwise use the Software alone or in any derivative version,\nprovided, however, that the BeOpen Python License is retained in the\nSoftware, alone or in any derivative version prepared by Licensee.\n\n3. BeOpen is making the Software available to Licensee on an \"AS IS\"\nbasis.  BEOPEN MAKES NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR\nIMPLIED.  BY WAY OF EXAMPLE, BUT NOT LIMITATION, BEOPEN MAKES NO AND\nDISCLAIMS ANY REPRESENTATION OR WARRANTY OF MERCHANTABILITY OR FITNESS\nFOR ANY PARTICULAR PURPOSE OR THAT THE USE OF THE SOFTWARE WILL NOT\nINFRINGE ANY THIRD PARTY RIGHTS.\n\n4. BEOPEN SHALL NOT BE LIABLE TO LICENSEE OR ANY OTHER USERS OF THE\nSOFTWARE FOR ANY INCIDENTAL, SPECIAL, OR CONSEQUENTIAL DAMAGES OR LOSS\nAS A RESULT OF USING, MODIFYING OR DISTRIBUTING THE SOFTWARE, OR ANY\nDERIVATIVE THEREOF, EVEN IF ADVISED OF THE POSSIBILITY THEREOF.\n\n5. This License Agreement will automatically terminate upon a material\nbreach of its terms and conditions.\n\n6. This License Agreement shall be governed by and interpreted in all\nrespects by the law of the State of California, excluding conflict of\nlaw provisions.  Nothing in this License Agreement shall be deemed to\ncreate any relationship of agency, partnership, or joint venture\nbetween BeOpen and Licensee.  This License Agreement does not grant\npermission to use BeOpen trademarks or trade names in a trademark\nsense to endorse or promote products or services of Licensee, or any\nthird party.  As an exception, the \"BeOpen Python\" logos available at\nhttp://www.pythonlabs.com/logos.html may be used according to the\npermissions granted on that web page.\n\n7. By copying, installing or otherwise using the software, Licensee\nagrees to be bound by the terms and conditions of this License\nAgreement.\n\n\nCNRI LICENSE AGREEMENT FOR PYTHON 1.6.1\n---------------------------------------\n\n1. This LICENSE AGREEMENT is between the Corporation for National\nResearch Initiatives, having an office at 1895 Preston White Drive,\nReston, VA 20191 (\"CNRI\"), and the Individual or Organization\n(\"Licensee\") accessing and otherwise using Python 1.6.1 software in\nsource or binary form and its associated documentation.\n\n2. Subject to the terms and conditions of this License Agreement, CNRI\nhereby grants Licensee a nonexclusive, royalty-free, world-wide\nlicense to reproduce, analyze, test, perform and/or display publicly,\nprepare derivative works, distribute, and otherwise use Python 1.6.1\nalone or in any derivative version, provided, however, that CNRI's\nLicense Agreement and CNRI's notice of copyright, i.e., \"Copyright (c)\n1995-2001 Corporation for National Research Initiatives; All Rights\nReserved\" are retained in Python 1.6.1 alone or in any derivative\nversion prepared by Licensee.  Alternately, in lieu of CNRI's License\nAgreement, Licensee may substitute the following text (omitting the\nquotes): \"Python 1.6.1 is made available subject to the terms and\nconditions in CNRI's License Agreement.  This Agreement together with\nPython 1.6.1 may be located on the Internet using the following\nunique, persistent identifier (known as a handle): 1895.22/1013.  This\nAgreement may also be obtained from a proxy server on the Internet\nusing the following URL: http://hdl.handle.net/1895.22/1013\".\n\n3. In the event Licensee prepares a derivative work that is based on\nor incorporates Python 1.6.1 or any part thereof, and wants to make\nthe derivative work available to others as provided herein, then\nLicensee hereby agrees to include in any such work a brief summary of\nthe changes made to Python 1.6.1.\n\n4. CNRI is making Python 1.6.1 available to Licensee on an \"AS IS\"\nbasis.  CNRI MAKES NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR\nIMPLIED.  BY WAY OF EXAMPLE, BUT NOT LIMITATION, CNRI MAKES NO AND\nDISCLAIMS ANY REPRESENTATION OR WARRANTY OF MERCHANTABILITY OR FITNESS\nFOR ANY PARTICULAR PURPOSE OR THAT THE USE OF PYTHON 1.6.1 WILL NOT\nINFRINGE ANY THIRD PARTY RIGHTS.\n\n5. CNRI SHALL NOT BE LIABLE TO LICENSEE OR ANY OTHER USERS OF PYTHON\n1.6.1 FOR ANY INCIDENTAL, SPECIAL, OR CONSEQUENTIAL DAMAGES OR LOSS AS\nA RESULT OF MODIFYING, DISTRIBUTING, OR OTHERWISE USING PYTHON 1.6.1,\nOR ANY DERIVATIVE THEREOF, EVEN IF ADVISED OF THE POSSIBILITY THEREOF.\n\n6. This License Agreement will automatically terminate upon a material\nbreach of its terms and conditions.\n\n7. This License Agreement shall be governed by the federal\nintellectual property law of the United States, including without\nlimitation the federal copyright law, and, to the extent such\nU.S. federal law does not apply, by the law of the Commonwealth of\nVirginia, excluding Virginia's conflict of law provisions.\nNotwithstanding the foregoing, with regard to derivative works based\non Python 1.6.1 that incorporate non-separable material that was\npreviously distributed under the GNU General Public License (GPL), the\nlaw of the Commonwealth of Virginia shall govern this License\nAgreement only as to issues arising under or with respect to\nParagraphs 4, 5, and 7 of this License Agreement.  Nothing in this\nLicense Agreement shall be deemed to create any relationship of\nagency, partnership, or joint venture between CNRI and Licensee.  This\nLicense Agreement does not grant permission to use CNRI trademarks or\ntrade name in a trademark sense to endorse or promote products or\nservices of Licensee, or any third party.\n\n8. By clicking on the \"ACCEPT\" button where indicated, or by copying,\ninstalling or otherwise using Python 1.6.1, Licensee agrees to be\nbound by the terms and conditions of this License Agreement.\n\n        ACCEPT\n\n\nCWI LICENSE AGREEMENT FOR PYTHON 0.9.0 THROUGH 1.2\n--------------------------------------------------\n\nCopyright (c) 1991 - 1995, Stichting Mathematisch Centrum Amsterdam,\nThe Netherlands.  All rights reserved.\n\nPermission to use, copy, modify, and distribute this software and its\ndocumentation for any purpose and without fee is hereby granted,\nprovided that the above copyright notice appear in all copies and that\nboth that copyright notice and this permission notice appear in\nsupporting documentation, and that the name of Stichting Mathematisch\nCentrum or CWI not be used in advertising or publicity pertaining to\ndistribution of the software without specific, written prior\npermission.\n\nSTICHTING MATHEMATISCH CENTRUM DISCLAIMS ALL WARRANTIES WITH REGARD TO\nTHIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\nFITNESS, IN NO EVENT SHALL STICHTING MATHEMATISCH CENTRUM BE LIABLE\nFOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\nWHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\nACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT\nOF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n"
        },
        {
          "name": "MANIFEST.in",
          "type": "blob",
          "size": 0.17578125,
          "content": "include LICENSE.txt\ninclude LICENSE_Python.txt\ninclude README.rst\ninclude python25.pxd\ninclude timers.h\ninclude _line_profiler.c\ninclude unset_trace.h\nrecursive-include tests *.py\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.4248046875,
          "content": "all:\n\t@echo 'Just some tools to help me make releases. Nothing for users.'\n\nindex.html: README.rst\n\trst2html.py README.rst index.html\n\npypi-site-docs.zip: index.html kernprof.py LICENSE.txt\n\tzip -r $@ $?\n\nsite: pypi-site-docs.zip\n\n# We need to run build_ext first to make sure we have _line_profiler.c.\n# However, we can't run both commands in the same run.\nsdist:\n\tpython setup.py build_ext\n\tpython setup.py sdist\n\n.PHONY: site sdist\n"
        },
        {
          "name": "README.rst",
          "type": "blob",
          "size": 17.27734375,
          "content": "line_profiler and kernprof\n--------------------------\n\n`line_profiler` is a module for doing line-by-line profiling of functions.\nkernprof is a convenient script for running either `line_profiler` or the Python\nstandard library's cProfile or profile modules, depending on what is available.\n\nThey are available under a `BSD license`_.\n\n.. _BSD license: https://raw.githubusercontent.com/rkern/line_profiler/master/LICENSE.txt\n\n.. contents::\n\n\nInstallation\n============\n\n**Note:** As of version 2.1.2, `pip install line_profiler` does not work.\nPlease install as follows until it is fixed in the next release::\n    \n    git clone https://github.com/rkern/line_profiler.git\n    find line_profiler -name '*.pyx' -exec cython {} \\;\n    cd line_profiler\n    pip install . --user \n\nReleases of `line_profiler` can be installed using pip::\n\n    $ pip install line_profiler\n\nSource releases and any binaries can be downloaded from the PyPI link.\n\n    http://pypi.python.org/pypi/line_profiler\n\nTo check out the development sources, you can use Git_::\n\n    $ git clone https://github.com/rkern/line_profiler.git\n\nYou may also download source tarballs of any snapshot from that URL.\n\nSource releases will require a C compiler in order to build `line_profiler`.\nIn addition, git checkouts will also require Cython_ >= 0.10. Source releases\non PyPI should contain the pregenerated C sources, so Cython should not be\nrequired in that case.\n\n`kernprof` is a single-file pure Python script and does not require\na compiler.  If you wish to use it to run cProfile and not line-by-line\nprofiling, you may copy it to a directory on your `PATH` manually and avoid\ntrying to build any C extensions.\n\n.. _git: http://git-scm.com/\n.. _Cython: http://www.cython.org\n.. _build and install: http://docs.python.org/install/index.html\n\n\nline_profiler\n=============\n\nThe current profiling tools supported in Python 2.7 and later only time\nfunction calls. This is a good first step for locating hotspots in one's program\nand is frequently all one needs to do to optimize the program. However,\nsometimes the cause of the hotspot is actually a single line in the function,\nand that line may not be obvious from just reading the source code. These cases\nare particularly frequent in scientific computing. Functions tend to be larger\n(sometimes because of legitimate algorithmic complexity, sometimes because the\nprogrammer is still trying to write FORTRAN code), and a single statement\nwithout function calls can trigger lots of computation when using libraries like\nnumpy. cProfile only times explicit function calls, not special methods called\nbecause of syntax. Consequently, a relatively slow numpy operation on large\narrays like this, ::\n\n    a[large_index_array] = some_other_large_array\n\nis a hotspot that never gets broken out by cProfile because there is no explicit\nfunction call in that statement.\n\nLineProfiler can be given functions to profile, and it will time the execution\nof each individual line inside those functions. In a typical workflow, one only\ncares about line timings of a few functions because wading through the results\nof timing every single line of code would be overwhelming. However, LineProfiler\ndoes need to be explicitly told what functions to profile. The easiest way to\nget started is to use the `kernprof` script. ::\n\n    $ kernprof -l script_to_profile.py\n\n`kernprof` will create an instance of LineProfiler and insert it into the\n`__builtins__` namespace with the name `profile`. It has been written to be\nused as a decorator, so in your script, you decorate the functions you want\nto profile with @profile. ::\n\n    @profile\n    def slow_function(a, b, c):\n        ...\n\nThe default behavior of `kernprof` is to put the results into a binary file\nscript_to_profile.py.lprof . You can tell `kernprof` to immediately view the\nformatted results at the terminal with the [-v/--view] option. Otherwise, you\ncan view the results later like so::\n\n    $ python -m line_profiler script_to_profile.py.lprof\n\nFor example, here are the results of profiling a single function from\na decorated version of the pystone.py benchmark (the first two lines are output\nfrom `pystone.py`, not `kernprof`)::\n\n    Pystone(1.1) time for 50000 passes = 2.48\n    This machine benchmarks at 20161.3 pystones/second\n    Wrote profile results to pystone.py.lprof\n    Timer unit: 1e-06 s\n\n    File: pystone.py\n    Function: Proc2 at line 149\n    Total time: 0.606656 s\n\n    Line #      Hits         Time  Per Hit   % Time  Line Contents\n    ==============================================================\n       149                                           @profile\n       150                                           def Proc2(IntParIO):\n       151     50000        82003      1.6     13.5      IntLoc = IntParIO + 10\n       152     50000        63162      1.3     10.4      while 1:\n       153     50000        69065      1.4     11.4          if Char1Glob == 'A':\n       154     50000        66354      1.3     10.9              IntLoc = IntLoc - 1\n       155     50000        67263      1.3     11.1              IntParIO = IntLoc - IntGlob\n       156     50000        65494      1.3     10.8              EnumLoc = Ident1\n       157     50000        68001      1.4     11.2          if EnumLoc == Ident1:\n       158     50000        63739      1.3     10.5              break\n       159     50000        61575      1.2     10.1      return IntParIO\n\n\nThe source code of the function is printed with the timing information for each\nline. There are six columns of information.\n\n    * Line #: The line number in the file.\n\n    * Hits: The number of times that line was executed.\n\n    * Time: The total amount of time spent executing the line in the timer's\n      units. In the header information before the tables, you will see a line\n      \"Timer unit:\" giving the conversion factor to seconds. It may be different\n      on different systems.\n\n    * Per Hit: The average amount of time spent executing the line once in the\n      timer's units.\n\n    * % Time: The percentage of time spent on that line relative to the total\n      amount of recorded time spent in the function.\n\n    * Line Contents: The actual source code. Note that this is always read from\n      disk when the formatted results are viewed, *not* when the code was\n      executed. If you have edited the file in the meantime, the lines will not\n      match up, and the formatter may not even be able to locate the function\n      for display.\n\nIf you are using IPython, there is an implementation of an %lprun magic command\nwhich will let you specify functions to profile and a statement to execute. It\nwill also add its LineProfiler instance into the __builtins__, but typically,\nyou would not use it like that.\n\nFor IPython 0.11+, you can install it by editing the IPython configuration file\n`~/.ipython/profile_default/ipython_config.py` to add the `'line_profiler'`\nitem to the extensions list::\n\n    c.TerminalIPythonApp.extensions = [\n        'line_profiler',\n    ]\n\n\nTo get usage help for %lprun, use the standard IPython help mechanism::\n\n    In [1]: %lprun?\n\nThese two methods are expected to be the most frequent user-level ways of using\nLineProfiler and will usually be the easiest. However, if you are building other\ntools with LineProfiler, you will need to use the API. There are two ways to\ninform LineProfiler of functions to profile: you can pass them as arguments to\nthe constructor or use the `add_function(f)` method after instantiation. ::\n\n    profile = LineProfiler(f, g)\n    profile.add_function(h)\n\nLineProfiler has the same `run()`, `runctx()`, and `runcall()` methods as\ncProfile.Profile as well as `enable()` and `disable()`. It should be noted,\nthough, that `enable()` and `disable()` are not entirely safe when nested.\nNesting is common when using LineProfiler as a decorator. In order to support\nnesting, use `enable_by_count()` and `disable_by_count()`. These functions will\nincrement and decrement a counter and only actually enable or disable the\nprofiler when the count transitions from or to 0.\n\nAfter profiling, the `dump_stats(filename)` method will pickle the results out\nto the given file. `print_stats([stream])` will print the formatted results to\nsys.stdout or whatever stream you specify. `get_stats()` will return LineStats\nobject, which just holds two attributes: a dictionary containing the results and\nthe timer unit.\n\n\nkernprof\n========\n\n`kernprof` also works with cProfile, its third-party incarnation lsprof, or the\npure-Python profile module depending on what is available. It has a few main\nfeatures:\n\n    * Encapsulation of profiling concerns. You do not have to modify your script\n      in order to initiate profiling and save the results. Unless if you want to\n      use the advanced __builtins__ features, of course.\n\n    * Robust script execution. Many scripts require things like __name__,\n      __file__, and sys.path to be set relative to it. A naive approach at\n      encapsulation would just use execfile(), but many scripts which rely on\n      that information will fail. kernprof will set those variables correctly\n      before executing the script.\n\n    * Easy executable location. If you are profiling an application installed on\n      your PATH, you can just give the name of the executable. If kernprof does\n      not find the given script in the current directory, it will search your\n      PATH for it.\n\n    * Inserting the profiler into __builtins__. Sometimes, you just want to\n      profile a small part of your code. With the [-b/--builtin] argument, the\n      Profiler will be instantiated and inserted into your __builtins__ with the\n      name \"profile\". Like LineProfiler, it may be used as a decorator, or\n      enabled/disabled with `enable_by_count()` and `disable_by_count()`, or\n      even as a context manager with the \"with profile:\" statement.\n\n    * Pre-profiling setup. With the [-s/--setup] option, you can provide\n      a script which will be executed without profiling before executing the\n      main script. This is typically useful for cases where imports of large\n      libraries like wxPython or VTK are interfering with your results. If you\n      can modify your source code, the __builtins__ approach may be\n      easier.\n\nThe results of profile script_to_profile.py will be written to\nscript_to_profile.py.prof by default. It will be a typical marshalled file that\ncan be read with pstats.Stats(). They may be interactively viewed with the\ncommand::\n\n    $ python -m pstats script_to_profile.py.prof\n\nSuch files may also be viewed with graphical tools like kcachegrind_ through the\nconverter program pyprof2calltree_ or RunSnakeRun_.\n\n.. _kcachegrind: http://kcachegrind.sourceforge.net/html/Home.html\n.. _pyprof2calltree: http://pypi.python.org/pypi/pyprof2calltree/\n.. _RunSnakeRun: http://www.vrplumber.com/programming/runsnakerun/\n\n\nFrequently Asked Questions\n==========================\n\n* Why the name \"kernprof\"?\n\n    I didn't manage to come up with a meaningful name, so I named it after\n    myself.\n\n* Why not use hotshot instead of line_profile?\n\n    hotshot can do line-by-line timings, too. However, it is deprecated and may\n    disappear from the standard library. Also, it can take a long time to\n    process the results while I want quick turnaround in my workflows. hotshot\n    pays this processing time in order to make itself minimally intrusive to the\n    code it is profiling. Code that does network operations, for example, may\n    even go down different code paths if profiling slows down execution too\n    much. For my use cases, and I think those of many other people, their\n    line-by-line profiling is not affected much by this concern.\n\n* Why not allow using hotshot from kernprof.py?\n\n    I don't use hotshot, myself. I will accept contributions in this vein,\n    though.\n\n* The line-by-line timings don't add up when one profiled function calls\n  another. What's up with that?\n\n    Let's say you have function F() calling function G(), and you are using\n    LineProfiler on both. The total time reported for G() is less than the time\n    reported on the line in F() that calls G(). The reason is that I'm being\n    reasonably clever (and possibly too clever) in recording the times.\n    Basically, I try to prevent recording the time spent inside LineProfiler\n    doing all of the bookkeeping for each line. Each time Python's tracing\n    facility issues a line event (which happens just before a line actually gets\n    executed), LineProfiler will find two timestamps, one at the beginning\n    before it does anything (t_begin) and one as close to the end as possible\n    (t_end). Almost all of the overhead of LineProfiler's data structures\n    happens in between these two times.\n\n    When a line event comes in, LineProfiler finds the function it belongs to.\n    If it's the first line in the function, we record the line number and\n    *t_end* associated with the function. The next time we see a line event\n    belonging to that function, we take t_begin of the new event and subtract\n    the old t_end from it to find the amount of time spent in the old line. Then\n    we record the new t_end as the active line for this function. This way, we\n    are removing most of LineProfiler's overhead from the results. Well almost.\n    When one profiled function F calls another profiled function G, the line in\n    F that calls G basically records the total time spent executing the line,\n    which includes the time spent inside the profiler while inside G.\n\n    The first time this question was asked, the questioner had the G() function\n    call as part of a larger expression, and he wanted to try to estimate how\n    much time was being spent in the function as opposed to the rest of the\n    expression. My response was that, even if I could remove the effect, it\n    might still be misleading. G() might be called elsewhere, not just from the\n    relevant line in F(). The workaround would be to modify the code to split it\n    up into two lines, one which just assigns the result of G() to a temporary\n    variable and the other with the rest of the expression.\n\n    I am open to suggestions on how to make this more robust. Or simple\n    admonitions against trying to be clever.\n\n* Why do my list comprehensions have so many hits when I use the LineProfiler?\n\n    LineProfiler records the line with the list comprehension once for each\n    iteration of the list comprehension.\n\n* Why is kernprof distributed with line_profiler? It works with just cProfile,\n  right?\n\n    Partly because kernprof.py is essential to using line_profiler effectively,\n    but mostly because I'm lazy and don't want to maintain the overhead of two\n    projects for modules as small as these. However, kernprof.py is\n    a standalone, pure Python script that can be used to do function profiling\n    with just the Python standard library. You may grab it and install it by\n    itself without `line_profiler`.\n\n* Do I need a C compiler to build `line_profiler`? kernprof.py?\n\n    You do need a C compiler for line_profiler. kernprof.py is a pure Python\n    script and can be installed separately, though.\n\n* Do I need Cython to build `line_profiler`?\n\n    You should not have to if you are building from a released source tarball.\n    It should contain the generated C sources already. If you are running into\n    problems, that may be a bug; let me know. If you are building from\n    a git checkout or snapshot, you will need Cython to generate the\n    C sources. You will probably need version 0.10 or higher. There is a bug in\n    some earlier versions in how it handles NULL PyObject* pointers.\n\n* What version of Python do I need?\n\n    Both `line_profiler` and `kernprof` have been tested with Python 2.7, and\n    3.2-3.4.\n\n\nTo Do\n=====\n\ncProfile uses a neat \"rotating trees\" data structure to minimize the overhead of\nlooking up and recording entries. LineProfiler uses Python dictionaries and\nextension objects thanks to Cython. This mostly started out as a prototype that\nI wanted to play with as quickly as possible, so I passed on stealing the\nrotating trees for now. As usual, I got it working, and it seems to have\nacceptable performance, so I am much less motivated to use a different strategy\nnow. Maybe later. Contributions accepted!\n\n\nBugs and Such\n=============\n\nBugs and pull requested can be submitted on GitHub_.\n\n.. _GitHub: https://github.com/rkern/line_profiler\n\n\nChanges\n=======\n\n2.1\n~~~\n* ENH: Add support for Python 3.5 coroutines\n* ENH: Documentation updates\n* ENH: CI for most recent Python versions (3.5, 3.6, 3.6-dev, 3.7-dev, nightly)\n* ENH: Add timer unit argument for output time granularity spec\n\n2.0\n~~~\n* BUG: Added support for IPython 5.0+, removed support for IPython <=0.12\n\n1.1\n~~~\n* BUG: Read source files as bytes.\n\n1.0\n~~~\n* ENH: `kernprof.py` is now installed as `kernprof`.\n* ENH: Python 3 support. Thanks to the long-suffering Mikhail Korobov for being\n  patient.\n* Dropped 2.6 as it was too annoying.\n* ENH: The `stripzeros` and `add_module` options. Thanks to Erik Tollerud for\n  contributing it.\n* ENH: Support for IPython cell blocks. Thanks to Michael Forbes for adding\n  this feature.\n* ENH: Better warnings when building without Cython. Thanks to David Cournapeau\n  for spotting this.\n\n1.0b3\n~~~~~\n\n* ENH: Profile generators.\n* BUG: Update for compatibility with newer versions of Cython. Thanks to Ondrej\n  Certik for spotting the bug.\n* BUG: Update IPython compatibility for 0.11+. Thanks to Yaroslav Halchenko and\n  others for providing the updated imports.\n\n1.0b2\n~~~~~\n\n* BUG: fixed line timing overflow on Windows.\n* DOC: improved the README.\n\n1.0b1\n~~~~~\n\n* Initial release.\n"
        },
        {
          "name": "_line_profiler.pyx",
          "type": "blob",
          "size": 6.6611328125,
          "content": "from python25 cimport PyFrameObject, PyObject, PyStringObject\n\n\ncdef extern from \"frameobject.h\":\n    ctypedef int (*Py_tracefunc)(object self, PyFrameObject *py_frame, int what, PyObject *arg)\n\ncdef extern from \"Python.h\":\n    ctypedef long long PY_LONG_LONG\n    cdef bint PyCFunction_Check(object obj)\n\n    cdef void PyEval_SetProfile(Py_tracefunc func, object arg)\n    cdef void PyEval_SetTrace(Py_tracefunc func, object arg)\n\n    ctypedef object (*PyCFunction)(object self, object args)\n\n    ctypedef struct PyMethodDef:\n        char *ml_name\n        PyCFunction ml_meth\n        int ml_flags\n        char *ml_doc\n\n    ctypedef struct PyCFunctionObject:\n        PyMethodDef *m_ml\n        PyObject *m_self\n        PyObject *m_module\n\n    # They're actually #defines, but whatever.\n    cdef int PyTrace_CALL\n    cdef int PyTrace_EXCEPTION\n    cdef int PyTrace_LINE\n    cdef int PyTrace_RETURN\n    cdef int PyTrace_C_CALL\n    cdef int PyTrace_C_EXCEPTION\n    cdef int PyTrace_C_RETURN\n\ncdef extern from \"timers.h\":\n    PY_LONG_LONG hpTimer()\n    double hpTimerUnit()\n\ncdef extern from \"unset_trace.h\":\n    void unset_trace()\n\n\ndef label(code):\n    \"\"\" Return a (filename, first_lineno, func_name) tuple for a given code\n    object.\n\n    This is the same labelling as used by the cProfile module in Python 2.5.\n    \"\"\"\n    if isinstance(code, str):\n        return ('~', 0, code)    # built-in functions ('~' sorts at the end)\n    else:\n        return (code.co_filename, code.co_firstlineno, code.co_name)\n\n\ncdef class LineTiming:\n    \"\"\" The timing for a single line.\n    \"\"\"\n    cdef public object code\n    cdef public int lineno\n    cdef public PY_LONG_LONG total_time\n    cdef public long nhits\n\n    def __init__(self, object code, int lineno):\n        self.code = code\n        self.lineno = lineno\n        self.total_time = 0\n        self.nhits = 0\n\n    cdef hit(self, PY_LONG_LONG dt):\n        \"\"\" Record a line timing.\n        \"\"\"\n        self.nhits += 1\n        self.total_time += dt\n\n    def astuple(self):\n        \"\"\" Convert to a tuple of (lineno, nhits, total_time).\n        \"\"\"\n        return (self.lineno, self.nhits, self.total_time)\n\n    def __repr__(self):\n        return '<LineTiming for %r\\n  lineno: %r\\n  nhits: %r\\n  total_time: %r>' % (self.code, self.lineno, self.nhits, <long>self.total_time)\n\n\n# Note: this is a regular Python class to allow easy pickling.\nclass LineStats(object):\n    \"\"\" Object to encapsulate line-profile statistics.\n\n    Attributes\n    ----------\n    timings : dict\n        Mapping from (filename, first_lineno, function_name) of the profiled\n        function to a list of (lineno, nhits, total_time) tuples for each\n        profiled line. total_time is an integer in the native units of the\n        timer.\n    unit : float\n        The number of seconds per timer unit.\n    \"\"\"\n    def __init__(self, timings, unit):\n        self.timings = timings\n        self.unit = unit\n\n\ncdef class LineProfiler:\n    \"\"\" Time the execution of lines of Python code.\n    \"\"\"\n    cdef public list functions\n    cdef public dict code_map\n    cdef public dict last_time\n    cdef public double timer_unit\n    cdef public long enable_count\n\n    def __init__(self, *functions):\n        self.functions = []\n        self.code_map = {}\n        self.last_time = {}\n        self.timer_unit = hpTimerUnit()\n        self.enable_count = 0\n        for func in functions:\n            self.add_function(func)\n\n    def add_function(self, func):\n        \"\"\" Record line profiling information for the given Python function.\n        \"\"\"\n        try:\n            code = func.__code__\n        except AttributeError:\n            import warnings\n            warnings.warn(\"Could not extract a code object for the object %r\" % (func,))\n            return\n        if code not in self.code_map:\n            self.code_map[code] = {}\n            self.functions.append(func)\n\n    def enable_by_count(self):\n        \"\"\" Enable the profiler if it hasn't been enabled before.\n        \"\"\"\n        if self.enable_count == 0:\n            self.enable()\n        self.enable_count += 1\n\n    def disable_by_count(self):\n        \"\"\" Disable the profiler if the number of disable requests matches the\n        number of enable requests.\n        \"\"\"\n        if self.enable_count > 0:\n            self.enable_count -= 1\n            if self.enable_count == 0:\n                self.disable()\n\n    def __enter__(self):\n        self.enable_by_count()\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        self.disable_by_count()\n\n    def enable(self):\n        PyEval_SetTrace(python_trace_callback, self)\n\n    def disable(self):\n        self.last_time = {}\n        unset_trace()\n\n    def get_stats(self):\n        \"\"\" Return a LineStats object containing the timings.\n        \"\"\"\n        stats = {}\n        for code in self.code_map:\n            entries = self.code_map[code].values()\n            key = label(code)\n            stats[key] = [e.astuple() for e in entries]\n            stats[key].sort()\n        return LineStats(stats, self.timer_unit)\n\n\ncdef class LastTime:\n    \"\"\" Record the last callback call for a given line.\n    \"\"\"\n    cdef int f_lineno\n    cdef PY_LONG_LONG time\n\n    def __cinit__(self, int f_lineno, PY_LONG_LONG time):\n        self.f_lineno = f_lineno\n        self.time = time\n\n\ncdef int python_trace_callback(object self_, PyFrameObject *py_frame, int what,\n    PyObject *arg):\n    \"\"\" The PyEval_SetTrace() callback.\n    \"\"\"\n    cdef LineProfiler self\n    cdef object code, key\n    cdef dict line_entries, last_time\n    cdef LineTiming entry\n    cdef LastTime old\n    cdef PY_LONG_LONG time\n\n    self = <LineProfiler>self_\n    last_time = self.last_time\n\n    if what == PyTrace_LINE or what == PyTrace_RETURN:\n        code = <object>py_frame.f_code\n        if code in self.code_map:\n            time = hpTimer()\n            if code in last_time:\n                old = last_time[code]\n                line_entries = self.code_map[code]\n                key = old.f_lineno\n                if key not in line_entries:\n                    entry = LineTiming(code, old.f_lineno)\n                    line_entries[key] = entry\n                else:\n                    entry = line_entries[key]\n                entry.hit(time - old.time)\n            if what == PyTrace_LINE:\n                # Get the time again. This way, we don't record much time wasted\n                # in this function.\n                last_time[code] = LastTime(py_frame.f_lineno, hpTimer())\n            else:\n                # We are returning from a function, not executing a line. Delete\n                # the last_time record. It may have already been deleted if we\n                # are profiling a generator that is being pumped past its end.\n                if code in last_time:\n                    del last_time[code]\n\n    return 0\n\n\n"
        },
        {
          "name": "dev_requirements.txt",
          "type": "blob",
          "size": 0.01953125,
          "content": "Cython\nIPython>=0.13"
        },
        {
          "name": "kernprof.py",
          "type": "blob",
          "size": 7.134765625,
          "content": "#!/usr/bin/env python\n# -*- coding: UTF-8 -*-\n\"\"\" Script to conveniently run profilers on code in a variety of circumstances.\n\"\"\"\n\nimport functools\nimport optparse\nimport os\nimport sys\n\nPY3 = sys.version_info[0] == 3\n\n# Guard the import of cProfile such that 3.x people\n# without lsprof can still use this script.\ntry:\n    from cProfile import Profile\nexcept ImportError:\n    try:\n        from lsprof import Profile\n    except ImportError:\n        from profile import Profile\n\n\n# Python 3.x compatibility utils: execfile\n# ========================================\ntry:\n    execfile\nexcept NameError:\n    # Python 3.x doesn't have 'execfile' builtin\n    import builtins\n    exec_ = getattr(builtins, \"exec\")\n\n    def execfile(filename, globals=None, locals=None):\n        with open(filename, 'rb') as f:\n            exec_(compile(f.read(), filename, 'exec'), globals, locals)\n# =====================================\n\n\n\nCO_GENERATOR = 0x0020\ndef is_generator(f):\n    \"\"\" Return True if a function is a generator.\n    \"\"\"\n    isgen = (f.__code__.co_flags & CO_GENERATOR) != 0\n    return isgen\n\n\nclass ContextualProfile(Profile):\n    \"\"\" A subclass of Profile that adds a context manager for Python\n    2.5 with: statements and a decorator.\n    \"\"\"\n\n    def __init__(self, *args, **kwds):\n        super(ContextualProfile, self).__init__(*args, **kwds)\n        self.enable_count = 0\n\n    def enable_by_count(self, subcalls=True, builtins=True):\n        \"\"\" Enable the profiler if it hasn't been enabled before.\n        \"\"\"\n        if self.enable_count == 0:\n            self.enable(subcalls=subcalls, builtins=builtins)\n        self.enable_count += 1\n\n    def disable_by_count(self):\n        \"\"\" Disable the profiler if the number of disable requests matches the\n        number of enable requests.\n        \"\"\"\n        if self.enable_count > 0:\n            self.enable_count -= 1\n            if self.enable_count == 0:\n                self.disable()\n\n    def __call__(self, func):\n        \"\"\" Decorate a function to start the profiler on function entry and stop\n        it on function exit.\n        \"\"\"\n        # FIXME: refactor this into a utility function so that both it and\n        # line_profiler can use it.\n        if is_generator(func):\n            wrapper = self.wrap_generator(func)\n        else:\n            wrapper = self.wrap_function(func)\n        return wrapper\n\n    # FIXME: refactor this stuff so that both LineProfiler and\n    # ContextualProfile can use the same implementation.\n    def wrap_generator(self, func):\n        \"\"\" Wrap a generator to profile it.\n        \"\"\"\n        @functools.wraps(func)\n        def wrapper(*args, **kwds):\n            g = func(*args, **kwds)\n            # The first iterate will not be a .send()\n            self.enable_by_count()\n            try:\n                item = next(g)\n            finally:\n                self.disable_by_count()\n            input = (yield item)\n            # But any following one might be.\n            while True:\n                self.enable_by_count()\n                try:\n                    item = g.send(input)\n                finally:\n                    self.disable_by_count()\n                input = (yield item)\n        return wrapper\n\n    def wrap_function(self, func):\n        \"\"\" Wrap a function to profile it.\n        \"\"\"\n        @functools.wraps(func)\n        def wrapper(*args, **kwds):\n            self.enable_by_count()\n            try:\n                result = func(*args, **kwds)\n            finally:\n                self.disable_by_count()\n            return result\n        return wrapper\n\n    def __enter__(self):\n        self.enable_by_count()\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        self.disable_by_count()\n\n\ndef find_script(script_name):\n    \"\"\" Find the script.\n\n    If the input is not a file, then $PATH will be searched.\n    \"\"\"\n    if os.path.isfile(script_name):\n        return script_name\n    path = os.getenv('PATH', os.defpath).split(os.pathsep)\n    for dir in path:\n        if dir == '':\n            continue\n        fn = os.path.join(dir, script_name)\n        if os.path.isfile(fn):\n            return fn\n\n    sys.stderr.write('Could not find script %s\\n' % script_name)\n    raise SystemExit(1)\n\n\ndef main(args=None):\n    if args is None:\n        args = sys.argv\n    usage = \"%prog [-s setupfile] [-o output_file_path] scriptfile [arg] ...\"\n    parser = optparse.OptionParser(usage=usage, version=\"%prog 1.0b2\")\n    parser.allow_interspersed_args = False\n    parser.add_option('-l', '--line-by-line', action='store_true',\n        help=\"Use the line-by-line profiler from the line_profiler module \"\n        \"instead of Profile. Implies --builtin.\")\n    parser.add_option('-b', '--builtin', action='store_true',\n        help=\"Put 'profile' in the builtins. Use 'profile.enable()' and \"\n            \"'profile.disable()' in your code to turn it on and off, or \"\n            \"'@profile' to decorate a single function, or 'with profile:' \"\n            \"to profile a single section of code.\")\n    parser.add_option('-o', '--outfile', default=None,\n        help=\"Save stats to <outfile>\")\n    parser.add_option('-s', '--setup', default=None,\n        help=\"Code to execute before the code to profile\")\n    parser.add_option('-v', '--view', action='store_true',\n        help=\"View the results of the profile in addition to saving it.\")\n\n    if not sys.argv[1:]:\n        parser.print_usage()\n        sys.exit(2)\n\n    options, args = parser.parse_args()\n\n    if not options.outfile:\n        if options.line_by_line:\n            extension = 'lprof'\n        else:\n            extension = 'prof'\n        options.outfile = '%s.%s' % (os.path.basename(args[0]), extension)\n\n\n    sys.argv[:] = args\n    if options.setup is not None:\n        # Run some setup code outside of the profiler. This is good for large\n        # imports.\n        setup_file = find_script(options.setup)\n        __file__ = setup_file\n        __name__ = '__main__'\n        # Make sure the script's directory is on sys.path instead of just\n        # kernprof.py's.\n        sys.path.insert(0, os.path.dirname(setup_file))\n        ns = locals()\n        execfile(setup_file, ns, ns)\n\n    if options.line_by_line:\n        import line_profiler\n        prof = line_profiler.LineProfiler()\n        options.builtin = True\n    else:\n        prof = ContextualProfile()\n    if options.builtin:\n        if PY3:\n            import builtins\n        else:\n            import __builtin__ as builtins\n        builtins.__dict__['profile'] = prof\n\n    script_file = find_script(sys.argv[0])\n    __file__ = script_file\n    __name__ = '__main__'\n    # Make sure the script's directory is on sys.path instead of just\n    # kernprof.py's.\n    sys.path.insert(0, os.path.dirname(script_file))\n\n    try:\n        try:\n            execfile_ = execfile\n            ns = locals()\n            if options.builtin:\n                execfile(script_file, ns, ns)\n            else:\n                prof.runctx('execfile_(%r, globals())' % (script_file,), ns, ns)\n        except (KeyboardInterrupt, SystemExit):\n            pass\n    finally:\n        prof.dump_stats(options.outfile)\n        print('Wrote profile results to %s' % options.outfile)\n        if options.view:\n            prof.print_stats()\n\nif __name__ == '__main__':\n    sys.exit(main(sys.argv))\n"
        },
        {
          "name": "line_profiler.py",
          "type": "blob",
          "size": 13.3623046875,
          "content": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\nfrom __future__ import print_function\ntry:\n    import cPickle as pickle\nexcept ImportError:\n    import pickle\n\ntry:\n    from cStringIO import StringIO\nexcept ImportError:\n    from io import StringIO\nimport functools\nimport inspect\nimport linecache\nimport optparse\nimport os\nimport sys\n\nfrom IPython.core.magic import (Magics, magics_class, line_magic)\nfrom IPython.core.page import page\nfrom IPython.utils.ipstruct import Struct\nfrom IPython.core.error import UsageError\n\nfrom _line_profiler import LineProfiler as CLineProfiler\n\n# Python 2/3 compatibility utils\n# ===========================================================\nPY3 = sys.version_info[0] == 3\nPY35 = PY3 and sys.version_info[1] >= 5\n\n# exec (from https://bitbucket.org/gutworth/six/):\nif PY3:\n    import builtins\n    exec_ = getattr(builtins, \"exec\")\n    del builtins\nelse:\n    def exec_(_code_, _globs_=None, _locs_=None):\n        \"\"\"Execute code in a namespace.\"\"\"\n        if _globs_ is None:\n            frame = sys._getframe(1)\n            _globs_ = frame.f_globals\n            if _locs_ is None:\n                _locs_ = frame.f_locals\n            del frame\n        elif _locs_ is None:\n            _locs_ = _globs_\n        exec(\"\"\"exec _code_ in _globs_, _locs_\"\"\")\n\nif PY35:\n    import inspect\n    def is_coroutine(f):\n        return inspect.iscoroutinefunction(f)\nelse:\n    def is_coroutine(f):\n        return False\n\n# ============================================================\n\nCO_GENERATOR = 0x0020\ndef is_generator(f):\n    \"\"\" Return True if a function is a generator.\n    \"\"\"\n    isgen = (f.__code__.co_flags & CO_GENERATOR) != 0\n    return isgen\n\n\nclass LineProfiler(CLineProfiler):\n    \"\"\" A profiler that records the execution times of individual lines.\n    \"\"\"\n\n    def __call__(self, func):\n        \"\"\" Decorate a function to start the profiler on function entry and stop\n        it on function exit.\n        \"\"\"\n        self.add_function(func)\n        if is_coroutine(func):\n            wrapper = self.wrap_coroutine(func)\n        elif is_generator(func):\n            wrapper = self.wrap_generator(func)\n        else:\n            wrapper = self.wrap_function(func)\n        return wrapper\n\n    def wrap_generator(self, func):\n        \"\"\" Wrap a generator to profile it.\n        \"\"\"\n        @functools.wraps(func)\n        def wrapper(*args, **kwds):\n            g = func(*args, **kwds)\n            # The first iterate will not be a .send()\n            self.enable_by_count()\n            try:\n                item = next(g)\n            finally:\n                self.disable_by_count()\n            input = (yield item)\n            # But any following one might be.\n            while True:\n                self.enable_by_count()\n                try:\n                    item = g.send(input)\n                finally:\n                    self.disable_by_count()\n                input = (yield item)\n        return wrapper\n\n    def wrap_function(self, func):\n        \"\"\" Wrap a function to profile it.\n        \"\"\"\n        @functools.wraps(func)\n        def wrapper(*args, **kwds):\n            self.enable_by_count()\n            try:\n                result = func(*args, **kwds)\n            finally:\n                self.disable_by_count()\n            return result\n        return wrapper\n\n    if PY35:\n        import line_profiler_py35\n        wrap_coroutine = line_profiler_py35.wrap_coroutine\n\n    def dump_stats(self, filename):\n        \"\"\" Dump a representation of the data to a file as a pickled LineStats\n        object from `get_stats()`.\n        \"\"\"\n        lstats = self.get_stats()\n        with open(filename, 'wb') as f:\n            pickle.dump(lstats, f, pickle.HIGHEST_PROTOCOL)\n\n    def print_stats(self, stream=None, output_unit=None, stripzeros=False):\n        \"\"\" Show the gathered statistics.\n        \"\"\"\n        lstats = self.get_stats()\n        show_text(lstats.timings, lstats.unit, output_unit=output_unit, stream=stream, stripzeros=stripzeros)\n\n    def run(self, cmd):\n        \"\"\" Profile a single executable statment in the main namespace.\n        \"\"\"\n        import __main__\n        main_dict = __main__.__dict__\n        return self.runctx(cmd, main_dict, main_dict)\n\n    def runctx(self, cmd, globals, locals):\n        \"\"\" Profile a single executable statement in the given namespaces.\n        \"\"\"\n        self.enable_by_count()\n        try:\n            exec_(cmd, globals, locals)\n        finally:\n            self.disable_by_count()\n        return self\n\n    def runcall(self, func, *args, **kw):\n        \"\"\" Profile a single function call.\n        \"\"\"\n        self.enable_by_count()\n        try:\n            return func(*args, **kw)\n        finally:\n            self.disable_by_count()\n\n    def add_module(self, mod):\n        \"\"\" Add all the functions in a module and its classes.\n        \"\"\"\n        from inspect import isclass, isfunction\n\n        nfuncsadded = 0\n        for item in mod.__dict__.values():\n            if isclass(item):\n                for k, v in item.__dict__.items():\n                    if isfunction(v):\n                        self.add_function(v)\n                        nfuncsadded += 1\n            elif isfunction(item):\n                self.add_function(item)\n                nfuncsadded += 1\n\n        return nfuncsadded\n\n\ndef show_func(filename, start_lineno, func_name, timings, unit,\n    output_unit=None, stream=None, stripzeros=False):\n    \"\"\" Show results for a single function.\n    \"\"\"\n    if stream is None:\n        stream = sys.stdout\n\n    template = '%6s %9s %12s %8s %8s  %-s'\n    d = {}\n    total_time = 0.0\n    linenos = []\n    for lineno, nhits, time in timings:\n        total_time += time\n        linenos.append(lineno)\n\n    if stripzeros and total_time == 0:\n        return\n\n    if output_unit is None:\n        output_unit = unit\n    scalar = unit / output_unit\n\n    stream.write(\"Total time: %g s\\n\" % (total_time * unit))\n    if os.path.exists(filename) or filename.startswith(\"<ipython-input-\"):\n        stream.write(\"File: %s\\n\" % filename)\n        stream.write(\"Function: %s at line %s\\n\" % (func_name, start_lineno))\n        if os.path.exists(filename):\n            # Clear the cache to ensure that we get up-to-date results.\n            linecache.clearcache()\n        all_lines = linecache.getlines(filename)\n        sublines = inspect.getblock(all_lines[start_lineno-1:])\n    else:\n        stream.write(\"\\n\")\n        stream.write(\"Could not find file %s\\n\" % filename)\n        stream.write(\"Are you sure you are running this program from the same directory\\n\")\n        stream.write(\"that you ran the profiler from?\\n\")\n        stream.write(\"Continuing without the function's contents.\\n\")\n        # Fake empty lines so we can see the timings, if not the code.\n        nlines = max(linenos) - min(min(linenos), start_lineno) + 1\n        sublines = [''] * nlines\n    for lineno, nhits, time in timings:\n        d[lineno] = (nhits,\n            '%5.1f' % (time * scalar),\n            '%5.1f' % (float(time) * scalar / nhits),\n            '%5.1f' % (100 * time / total_time) )\n    linenos = range(start_lineno, start_lineno + len(sublines))\n    empty = ('', '', '', '')\n    header = template % ('Line #', 'Hits', 'Time', 'Per Hit', '% Time',\n        'Line Contents')\n    stream.write(\"\\n\")\n    stream.write(header)\n    stream.write(\"\\n\")\n    stream.write('=' * len(header))\n    stream.write(\"\\n\")\n    for lineno, line in zip(linenos, sublines):\n        nhits, time, per_hit, percent = d.get(lineno, empty)\n        txt = template % (lineno, nhits, time, per_hit, percent,\n                          line.rstrip('\\n').rstrip('\\r'))\n        stream.write(txt)\n        stream.write(\"\\n\")\n    stream.write(\"\\n\")\n\ndef show_text(stats, unit, output_unit=None, stream=None, stripzeros=False):\n    \"\"\" Show text for the given timings.\n    \"\"\"\n    if stream is None:\n        stream = sys.stdout\n\n    if output_unit is not None:\n        stream.write('Timer unit: %g s\\n\\n' % output_unit)\n    else:\n        stream.write('Timer unit: %g s\\n\\n' % unit)\n\n    for (fn, lineno, name), timings in sorted(stats.items()):\n        show_func(fn, lineno, name, stats[fn, lineno, name], unit,\n            output_unit=output_unit, stream=stream, stripzeros=stripzeros)\n\n@magics_class\nclass LineProfilerMagics(Magics):\n\n    @line_magic\n    def lprun(self, parameter_s=''):\n        \"\"\" Execute a statement under the line-by-line profiler from the\n        line_profiler module.\n\n        Usage:\n          %lprun -f func1 -f func2 <statement>\n\n        The given statement (which doesn't require quote marks) is run via the\n        LineProfiler. Profiling is enabled for the functions specified by the -f\n        options. The statistics will be shown side-by-side with the code through the\n        pager once the statement has completed.\n\n        Options:\n\n        -f <function>: LineProfiler only profiles functions and methods it is told\n        to profile.  This option tells the profiler about these functions. Multiple\n        -f options may be used. The argument may be any expression that gives\n        a Python function or method object. However, one must be careful to avoid\n        spaces that may confuse the option parser.\n\n        -m <module>: Get all the functions/methods in a module\n\n        One or more -f or -m options are required to get any useful results.\n\n        -D <filename>: dump the raw statistics out to a pickle file on disk. The\n        usual extension for this is \".lprof\". These statistics may be viewed later\n        by running line_profiler.py as a script.\n\n        -T <filename>: dump the text-formatted statistics with the code side-by-side\n        out to a text file.\n\n        -r: return the LineProfiler object after it has completed profiling.\n\n        -s: strip out all entries from the print-out that have zeros.\n\n        -u: specify time unit for the print-out in seconds.\n        \"\"\"\n\n        # Escape quote markers.\n        opts_def = Struct(D=[''], T=[''], f=[], m=[], u=None)\n        parameter_s = parameter_s.replace('\"', r'\\\"').replace(\"'\", r\"\\'\")\n        opts, arg_str = self.parse_options(parameter_s, 'rsf:m:D:T:u:', list_all=True)\n        opts.merge(opts_def)\n\n        global_ns = self.shell.user_global_ns\n        local_ns = self.shell.user_ns\n\n        # Get the requested functions.\n        funcs = []\n        for name in opts.f:\n            try:\n                funcs.append(eval(name, global_ns, local_ns))\n            except Exception as e:\n                raise UsageError('Could not find function %r.\\n%s: %s' % (name,\n                    e.__class__.__name__, e))\n\n        profile = LineProfiler(*funcs)\n\n        # Get the modules, too\n        for modname in opts.m:\n            try:\n                mod = __import__(modname, fromlist=[''])\n                profile.add_module(mod)\n            except Exception as e:\n                raise UsageError('Could not find module %r.\\n%s: %s' % (modname,\n                    e.__class__.__name__, e))\n\n        if opts.u is not None:\n            try:\n                output_unit = float(opts.u[0])\n            except Exception as e:\n                raise TypeError(\"Timer unit setting must be a float.\")\n        else:\n            output_unit = None\n\n        # Add the profiler to the builtins for @profile.\n        if PY3:\n            import builtins\n        else:\n            import __builtin__ as builtins\n\n        if 'profile' in builtins.__dict__:\n            had_profile = True\n            old_profile = builtins.__dict__['profile']\n        else:\n            had_profile = False\n            old_profile = None\n        builtins.__dict__['profile'] = profile\n\n        try:\n            try:\n                profile.runctx(arg_str, global_ns, local_ns)\n                message = ''\n            except SystemExit:\n                message = \"\"\"*** SystemExit exception caught in code being profiled.\"\"\"\n            except KeyboardInterrupt:\n                message = (\"*** KeyboardInterrupt exception caught in code being \"\n                    \"profiled.\")\n        finally:\n            if had_profile:\n                builtins.__dict__['profile'] = old_profile\n\n        # Trap text output.\n        stdout_trap = StringIO()\n        profile.print_stats(stdout_trap, output_unit=output_unit, stripzeros='s' in opts)\n        output = stdout_trap.getvalue()\n        output = output.rstrip()\n\n        page(output)\n        print(message, end=\"\")\n\n        dump_file = opts.D[0]\n        if dump_file:\n            profile.dump_stats(dump_file)\n            print('\\n*** Profile stats pickled to file %r. %s' % (\n                dump_file, message))\n\n        text_file = opts.T[0]\n        if text_file:\n            pfile = open(text_file, 'w')\n            pfile.write(output)\n            pfile.close()\n            print('\\n*** Profile printout saved to text file %r. %s' % (\n                text_file, message))\n\n        return_value = None\n        if 'r' in opts:\n            return_value = profile\n\n        return return_value\n\n\ndef load_ipython_extension(ip):\n    \"\"\" API for IPython to recognize this module as an IPython extension.\n    \"\"\"\n    ip.register_magics(LineProfilerMagics)\n\n\ndef load_stats(filename):\n    \"\"\" Utility function to load a pickled LineStats object from a given\n    filename.\n    \"\"\"\n    with open(filename, 'rb') as f:\n        return pickle.load(f)\n\n\ndef main():\n    usage = \"usage: %prog profile.lprof\"\n    parser = optparse.OptionParser(usage=usage, version='%prog 1.0b2')\n\n    options, args = parser.parse_args()\n    if len(args) != 1:\n        parser.error(\"Must provide a filename.\")\n    lstats = load_stats(args[0])\n    show_text(lstats.timings, lstats.unit)\n\nif __name__ == '__main__':\n    main()\n"
        },
        {
          "name": "line_profiler_py35.py",
          "type": "blob",
          "size": 0.4150390625,
          "content": "\"\"\" This file is only imported in python 3.5 environments \"\"\"\nimport functools\n\ndef wrap_coroutine(self, func):\n    \"\"\"\n    Wrap a Python 3.5 coroutine to profile it.\n    \"\"\"\n    @functools.wraps(func)\n    async def wrapper(*args, **kwds):\n        self.enable_by_count()\n        try:\n            result = await func(*args, **kwds)\n        finally:\n            self.disable_by_count()\n        return result\n    return wrapper\n"
        },
        {
          "name": "python25.pxd",
          "type": "blob",
          "size": 39.6513671875,
          "content": "# From: Eric Huss <e-huss@netmeridian.com>\r\n#\r\n# Here is my latest copy.  It does not cover 100% of the API.  It should be\r\n# current up to 2.5.\r\n#\r\n# -Eric\r\n\r\n\r\n\r\n\r\n# XXX:\r\n# - Need to support \"long long\" definitions that are different for different platforms.\r\n# - Support unicode platform dependencies.\r\n# - Add unicode calls.\r\n# - Add setobject calls.\r\n\r\ncdef extern from \"sys/types.h\":\r\n    ctypedef unsigned int size_t\r\n\r\ncdef extern from \"stdio.h\":\r\n    ctypedef struct FILE:\r\n        pass\r\n\r\ncdef extern from \"Python.h\":\r\n\r\n    # XXX: This is platform dependent.\r\n    ctypedef unsigned short Py_UNICODE\r\n\r\n    ctypedef struct PyTypeObject:\r\n        pass\r\n\r\n    ctypedef struct PyObject:\r\n        Py_ssize_t ob_refcnt\r\n        PyTypeObject * ob_type\r\n\r\n    ###############################################################################################\r\n    # bool\r\n    ###############################################################################################\r\n    PyObject * Py_False\r\n    PyObject * Py_True\r\n    PyTypeObject PyBool_Type\r\n    int                 PyBool_Check                    (object)                    # Always succeeds.\r\n    object              PyBool_FromLong                 (long)\r\n\r\n    ###############################################################################################\r\n    # buffer\r\n    ###############################################################################################\r\n    PyTypeObject PyBuffer_Type\r\n    int Py_END_OF_BUFFER\r\n    int                 PyBuffer_Check                  (object)                    # Always succeeds.\r\n    object              PyBuffer_FromMemory             (void *, Py_ssize_t)\r\n    object              PyBuffer_FromObject             (object, Py_ssize_t, Py_ssize_t)\r\n    object              PyBuffer_FromReadWriteMemory    (void *, Py_ssize_t)\r\n    object              PyBuffer_FromReadWriteObject    (object, Py_ssize_t, Py_ssize_t)\r\n    object              PyBuffer_New                    (Py_ssize_t)\r\n    int                 PyObject_AsCharBuffer           (object, char **, Py_ssize_t *)    except -1\r\n    int                 PyObject_AsReadBuffer           (object, void **, Py_ssize_t *)    except -1\r\n    int                 PyObject_AsWriteBuffer          (object, void **, Py_ssize_t *)    except -1\r\n    int                 PyObject_CheckReadBuffer        (object)                    # Always succeeds.\r\n\r\n    ###############################################################################################\r\n    # cobject\r\n    ###############################################################################################\r\n    PyTypeObject PyCObject_Type\r\n\r\n    int                 PyCObject_Check(object)                                     # Always succeeds.\r\n    object              PyCObject_FromVoidPtr(void *, void (*)(void*))\r\n    object              PyCObject_FromVoidPtrAndDesc(void *, void *, void (*)(void*,void*))\r\n    void *              PyCObject_AsVoidPtr(object)                                 except NULL\r\n    void *              PyCObject_GetDesc(object)                                   except NULL\r\n    void *              PyCObject_Import(char *, char *)                            except NULL\r\n\r\n    ###############################################################################################\r\n    # compile\r\n    ###############################################################################################\r\n\r\n    ctypedef struct PyCodeObject:\r\n        int       co_argcount\r\n        int       co_nlocals\r\n        int       co_stacksize\r\n        int       co_flags\r\n        PyObject *co_code\r\n        PyObject *co_consts\r\n        PyObject *co_names\r\n        PyObject *co_varnames\r\n        PyObject *co_freevars\r\n        PyObject *co_cellvars\r\n        PyObject *co_filename\r\n        PyObject *co_name\r\n        int       co_firstlineno\r\n        PyObject *co_lnotab\r\n\r\n    int PyCode_Addr2Line(PyCodeObject *, int)\r\n\r\n    ###############################################################################################\r\n    # complex\r\n    ###############################################################################################\r\n    ctypedef struct Py_complex:\r\n        double real\r\n        double imag\r\n\r\n    PyTypeObject PyComplex_Type\r\n\r\n    Py_complex          PyComplex_AsCComplex            (object)                    # Always succeeds.\r\n    int                 PyComplex_Check                 (object)                    # Always succeeds.\r\n    int                 PyComplex_CheckExact            (object)                    # Always succeeds.\r\n    object              PyComplex_FromCComplex          (Py_complex)\r\n    object              PyComplex_FromDoubles           (double, double)\r\n    double              PyComplex_ImagAsDouble          (object)                    except? -1\r\n    double              PyComplex_RealAsDouble          (object)                    except? -1\r\n    Py_complex          _Py_c_diff                      (Py_complex, Py_complex)\r\n    Py_complex          _Py_c_neg                       (Py_complex)\r\n    Py_complex          _Py_c_pow                       (Py_complex, Py_complex)\r\n    Py_complex          _Py_c_prod                      (Py_complex, Py_complex)\r\n    Py_complex          _Py_c_quot                      (Py_complex, Py_complex)\r\n    Py_complex          _Py_c_sum                       (Py_complex, Py_complex)\r\n\r\n    ###############################################################################################\r\n    # dict\r\n    ###############################################################################################\r\n    PyTypeObject PyDict_Type\r\n\r\n    int                 PyDict_Check                    (object)                    # Always succeeds.\r\n    int                 PyDict_CheckExact               (object)                    # Always succeeds.\r\n    void                PyDict_Clear                    (object)\r\n    int                 PyDict_Contains                 (object, object)            except -1\r\n    object              PyDict_Copy                     (object)\r\n    int                 PyDict_DelItem                  (object, object)            except -1\r\n    int                 PyDict_DelItemString            (object, char *)            except -1\r\n    object              PyDict_Items                    (object)\r\n    object              PyDict_Keys                     (object)\r\n    int                 PyDict_Merge                    (object, object, int)       except -1\r\n    int                 PyDict_MergeFromSeq2            (object, object, int)       except -1\r\n    object              PyDict_New                      ()\r\n    # XXX: Pyrex doesn't support pointer to a python object?\r\n    #int                 PyDict_Next                     (object, Py_ssize_t *, object *, object *) # Always succeeds.\r\n    int                 PyDict_SetItem                  (object, object, object)    except -1\r\n    int                 PyDict_SetItemString            (object, char *, object)    except -1\r\n    Py_ssize_t          PyDict_Size                     (object)                    except -1\r\n    int                 PyDict_Update                   (object, object)            except -1\r\n    object              PyDict_Values                   (object)\r\n    # XXX: Borrowed reference.  No exception on NULL.\r\n    #object              PyDict_GetItem                  (object, object)\r\n    # XXX: Borrowed reference.  No exception on NULL\r\n    #object              PyDict_GetItemString            (object, char *)\r\n\r\n\r\n    ###############################################################################################\r\n    # float\r\n    ###############################################################################################\r\n    PyTypeObject PyFloat_Type\r\n    int                 _PyFloat_Pack4                  (double, unsigned char *, int)  except -1\r\n    int                 _PyFloat_Pack8                  (double, unsigned char *, int)  except -1\r\n    double              _PyFloat_Unpack4                (unsigned char *, int)      except? -1\r\n    double              _PyFloat_Unpack8                (unsigned char *, int)      except? -1\r\n    double              PyFloat_AS_DOUBLE               (object)\r\n    double              PyFloat_AsDouble                (object)                    except? -1\r\n    void                PyFloat_AsReprString            (char*, object)\r\n    void                PyFloat_AsString                (char*, object)\r\n    int                 PyFloat_Check                   (object)                    # Always succeeds.\r\n    int                 PyFloat_CheckExact              (object)                    # Always succeeds.\r\n    object              PyFloat_FromDouble              (double)\r\n    object              PyFloat_FromString              (object, char**)\r\n\r\n    ###############################################################################################\r\n    # frame\r\n    ###############################################################################################\r\n\r\n    ctypedef struct PyFrameObject:\r\n        PyFrameObject *f_back\r\n        PyCodeObject  *f_code\r\n        PyObject *f_builtins\r\n        PyObject *f_globals\r\n        PyObject *f_locals\r\n        PyObject *f_trace\r\n        PyObject *f_exc_type\r\n        PyObject *f_exc_value\r\n        PyObject *f_exc_traceback\r\n        int f_lasti\r\n        int f_lineno\r\n        int f_restricted\r\n        int f_iblock\r\n        int f_nlocals\r\n        int f_ncells\r\n        int f_nfreevars\r\n        int f_stacksize\r\n\r\n    ###############################################################################################\r\n    # int\r\n    ###############################################################################################\r\n    PyTypeObject PyInt_Type\r\n    long                PyInt_AS_LONG                   (object)                    # Always succeeds.\r\n    long                PyInt_AsLong                    (object)                    except? -1\r\n    Py_ssize_t          PyInt_AsSsize_t                 (object)                    except? -1\r\n    unsigned long long  PyInt_AsUnsignedLongLongMask    (object)                    except? -1\r\n    unsigned long       PyInt_AsUnsignedLongMask        (object)                    except? -1\r\n    int                 PyInt_Check                     (object)                    # Always succeeds.\r\n    int                 PyInt_CheckExact                (object)                    # Always succeeds.\r\n    object              PyInt_FromLong                  (long)\r\n    object              PyInt_FromSsize_t               (Py_ssize_t)\r\n    object              PyInt_FromString                (char*, char**, int)\r\n    object              PyInt_FromUnicode               (Py_UNICODE*, Py_ssize_t, int)\r\n    long                PyInt_GetMax                    ()                      # Always succeeds.\r\n\r\n    ###############################################################################################\r\n    # iterator\r\n    ###############################################################################################\r\n    int                 PyIter_Check                    (object)                    # Always succeeds.\r\n    object              PyIter_Next                     (object)\r\n\r\n    ###############################################################################################\r\n    # list\r\n    ###############################################################################################\r\n    PyTypeObject PyList_Type\r\n    int                 PyList_Append                   (object, object)            except -1\r\n    object              PyList_AsTuple                  (object)\r\n    int                 PyList_Check                    (object)                    # Always succeeds.\r\n    int                 PyList_CheckExact               (object)                    # Always succeeds.\r\n    int                 PyList_GET_SIZE                 (object)                    # Always suceeds.\r\n    object              PyList_GetSlice                 (object, Py_ssize_t, Py_ssize_t)\r\n    int                 PyList_Insert                   (object, Py_ssize_t, object)       except -1\r\n    object              PyList_New                      (Py_ssize_t)\r\n    int                 PyList_Reverse                  (object)                    except -1\r\n    int                 PyList_SetSlice                 (object, Py_ssize_t, Py_ssize_t, object)  except -1\r\n    Py_ssize_t          PyList_Size                     (object)                    except -1\r\n    int                 PyList_Sort                     (object)                    except -1\r\n\r\n    ###############################################################################################\r\n    # long\r\n    ###############################################################################################\r\n    PyTypeObject PyLong_Type\r\n    int                 _PyLong_AsByteArray             (object, unsigned char *, size_t, int, int) except -1\r\n    object              _PyLong_FromByteArray           (unsigned char *, size_t, int, int)\r\n    size_t              _PyLong_NumBits                 (object)                    except -1\r\n    int                 _PyLong_Sign                    (object)                    # No error.\r\n    long                PyLong_AsLong                   (object)                    except? -1\r\n    long long           PyLong_AsLongLong               (object)                    except? -1\r\n    unsigned long       PyLong_AsUnsignedLong           (object)                    except? -1\r\n    unsigned long       PyLong_AsUnsignedLongMask       (object)                    except? -1\r\n    unsigned long long  PyLong_AsUnsignedLongLong       (object)                    except? -1\r\n    unsigned long long  PyLong_AsUnsignedLongLongMask   (object)                    except? -1\r\n    int                 PyLong_Check                    (object)                    # Always succeeds.\r\n    int                 PyLong_CheckExact               (object)                    # Always succeeds.\r\n    object              PyLong_FromDouble               (double)\r\n    object              PyLong_FromLong                 (long)\r\n    object              PyLong_FromLongLong             (long long)\r\n    object              PyLong_FromUnsignedLong         (unsigned long)\r\n    object              PyLong_FromUnsignedLongLong     (unsigned long long)\r\n    double              PyLong_AsDouble                 (object)                    except? -1\r\n    object              PyLong_FromVoidPtr              (void *)\r\n    void *              PyLong_AsVoidPtr                (object)                    except NULL\r\n    object              PyLong_FromString               (char *, char **, int)\r\n    object              PyLong_FromUnicode              (Py_UNICODE*, Py_ssize_t, int)\r\n\r\n    ###############################################################################################\r\n    # mapping\r\n    ###############################################################################################\r\n    int                 PyMapping_Check                 (object)                    # Always succeeds.\r\n    int                 PyMapping_DelItem               (object, object)            except -1\r\n    int                 PyMapping_DelItemString         (object, char *)            except -1\r\n    object              PyMapping_GetItemString         (object, char *)\r\n    int                 PyMapping_HasKey                (object, object)            # Always succeeds.\r\n    int                 PyMapping_HasKeyString          (object, char *)            # Always succeeds.\r\n    object              PyMapping_Items                 (object)\r\n    object              PyMapping_Keys                  (object)\r\n    Py_ssize_t          PyMapping_Length                (object)                    except -1\r\n    int                 PyMapping_SetItemString         (object, char *, object)    except -1\r\n    Py_ssize_t          PyMapping_Size                  (object)                    except -1\r\n    object              PyMapping_Values                (object)\r\n\r\n    ###############################################################################################\r\n    # mem\r\n    ###############################################################################################\r\n    void                PyMem_Free                      (void * p)\r\n    void *              PyMem_Malloc                    (size_t n)\r\n    void *              PyMem_Realloc                   (void *, size_t)\r\n\r\n    ###############################################################################################\r\n    # modsupport\r\n    ###############################################################################################\r\n    object              Py_BuildValue                   (char *, ...)\r\n    object              Py_VaBuildValue                 (char *, va_list)\r\n\r\n    ###############################################################################################\r\n    # number\r\n    ###############################################################################################\r\n    object              PyNumber_Absolute               (object)\r\n    object              PyNumber_Add                    (object, object)\r\n    object              PyNumber_And                    (object, object)\r\n    Py_ssize_t          PyNumber_AsSsize_t              (object, object)    except? -1\r\n    int                 PyNumber_Check                  (object)                    # Always succeeds.\r\n    # XXX: Pyrex doesn't support pointer to python object?\r\n    #int                 PyNumber_Coerce                 (object*, object*)          except -1\r\n    object              PyNumber_Divide                 (object, object)\r\n    object              PyNumber_Divmod                 (object, object)\r\n    object              PyNumber_Float                  (object)\r\n    object              PyNumber_FloorDivide            (object, object)\r\n    object              PyNumber_InPlaceAdd             (object, object)\r\n    object              PyNumber_InPlaceAnd             (object, object)\r\n    object              PyNumber_InPlaceDivide          (object, object)\r\n    object              PyNumber_InPlaceFloorDivide     (object, object)\r\n    object              PyNumber_InPlaceLshift          (object, object)\r\n    object              PyNumber_InPlaceMultiply        (object, object)\r\n    object              PyNumber_InPlaceOr              (object, object)\r\n    object              PyNumber_InPlacePower           (object, object, object)\r\n    object              PyNumber_InPlaceRemainder       (object, object)\r\n    object              PyNumber_InPlaceRshift          (object, object)\r\n    object              PyNumber_InPlaceSubtract        (object, object)\r\n    object              PyNumber_InPlaceTrueDivide      (object, object)\r\n    object              PyNumber_InPlaceXor             (object, object)\r\n    object              PyNumber_Int                    (object)\r\n    object              PyNumber_Invert                 (object)\r\n    object              PyNumber_Long                   (object)\r\n    object              PyNumber_Lshift                 (object, object)\r\n    object              PyNumber_Multiply               (object, object)\r\n    object              PyNumber_Negative               (object)\r\n    object              PyNumber_Or                     (object, object)\r\n    object              PyNumber_Positive               (object)\r\n    object              PyNumber_Power                  (object, object, object)\r\n    object              PyNumber_Remainder              (object, object)\r\n    object              PyNumber_Rshift                 (object, object)\r\n    object              PyNumber_Subtract               (object, object)\r\n    object              PyNumber_TrueDivide             (object, object)\r\n    object              PyNumber_Xor                    (object, object)\r\n\r\n    ###############################################################################################\r\n    # object\r\n    ###############################################################################################\r\n    int                 PyCallable_Check                (object)                    # Always succeeds.\r\n    int                 PyObject_AsFileDescriptor       (object)                    except -1\r\n    object              PyObject_Call                   (object, object, object)\r\n    object              PyObject_CallFunction           (object, char *, ...)\r\n    object              PyObject_CallFunctionObjArgs    (object, ...)\r\n    object              PyObject_CallMethod             (object, char *, char *, ...)\r\n    object              PyObject_CallMethodObjArgs      (object, object, ...)\r\n    object              PyObject_CallObject             (object, object)\r\n    int                 PyObject_Cmp                    (object, object, int *result)   except -1\r\n    # Use PyObject_Cmp instead.\r\n    #int                 PyObject_Compare                (object, object)\r\n    int                 PyObject_DelAttr                (object, object)            except -1\r\n    int                 PyObject_DelAttrString          (object, char *)            except -1\r\n    int                 PyObject_DelItem                (object, object)            except -1\r\n    int                 PyObject_DelItemString          (object, char *)            except -1\r\n    object              PyObject_Dir                    (object)\r\n    object              PyObject_GetAttr                (object, object)\r\n    object              PyObject_GetAttrString          (object, char *)\r\n    object              PyObject_GetItem                (object, object)\r\n    object              PyObject_GetIter                (object)\r\n    int                 PyObject_HasAttr                (object, object)            # Always succeeds.\r\n    int                 PyObject_HasAttrString          (object, char *)            # Always succeeds.\r\n    long                PyObject_Hash                   (object)                    except -1\r\n    int                 PyObject_IsInstance             (object, object)            except -1\r\n    int                 PyObject_IsSubclass             (object, object)            except -1\r\n    int                 PyObject_IsTrue                 (object)                    except -1\r\n    Py_ssize_t          PyObject_Length                 (object)                    except -1\r\n    int                 PyObject_Not                    (object)                    except -1\r\n    int                 PyObject_Print                  (object, FILE *, int)       except -1\r\n    object              PyObject_Repr                   (object)\r\n    object              PyObject_RichCompare            (object, object, int)\r\n    int                 PyObject_RichCompareBool        (object, object, int)       except -1\r\n    int                 PyObject_SetAttr                (object, object, object)    except -1\r\n    int                 PyObject_SetAttrString          (object, char *, object)    except -1\r\n    int                 PyObject_SetItem                (object, object, object)    except -1\r\n    Py_ssize_t          PyObject_Size                   (object)                    except -1\r\n    object              PyObject_Str                    (object)\r\n    object              PyObject_Type                   (object)\r\n    int                 PyObject_TypeCheck              (object, object)            # Always succeeds.\r\n    object              PyObject_Unicode                (object)\r\n\r\n    ###############################################################################################\r\n    # pyerrors\r\n    ###############################################################################################\r\n    int                 PyErr_BadArgument               ()\r\n    void                PyErr_BadInternalCall           ()\r\n    int                 PyErr_CheckSignals              ()\r\n    void                PyErr_Clear                     ()\r\n    int                 PyErr_ExceptionMatches          (object)\r\n    object              PyErr_Format                    (object, char *, ...)\r\n    int                 PyErr_GivenExceptionMatches     (object, object)\r\n    object              PyErr_NoMemory                  ()\r\n    object              PyErr_Occurred                  ()\r\n    void                PyErr_Restore                   (object, object, object)\r\n    object              PyErr_SetFromErrno              (object)\r\n    object              PyErr_SetFromErrnoWithFilename  (object, char *)\r\n    object              PyErr_SetFromErrnoWithFilenameObject    (object, object)\r\n    void                PyErr_SetInterrupt              ()\r\n    void                PyErr_SetNone                   (object)\r\n    void                PyErr_SetObject                 (object, object)\r\n    void                PyErr_SetString                 (object, char *)\r\n    int                 PyErr_Warn                      (object, char *)\r\n    int                 PyErr_WarnExplicit              (object, char *, char *, int, char *, object)\r\n    void                PyErr_WriteUnraisable           (object)\r\n\r\n    ###############################################################################################\r\n    # pyeval\r\n    # Be extremely careful with these functions.\r\n    ###############################################################################################\r\n\r\n    ctypedef struct PyThreadState:\r\n        PyFrameObject * frame\r\n        int recursion_depth\r\n        void * curexc_type\r\n        void * curexc_value\r\n        void * curexc_traceback\r\n        void * exc_type\r\n        void * exc_value\r\n        void * exc_traceback\r\n\r\n    void                PyEval_AcquireLock              ()\r\n    void                PyEval_ReleaseLock              ()\r\n    void                PyEval_AcquireThread            (PyThreadState *)\r\n    void                PyEval_ReleaseThread            (PyThreadState *)\r\n    PyThreadState*      PyEval_SaveThread               ()\r\n    void                PyEval_RestoreThread            (PyThreadState *)\r\n\r\n    ###############################################################################################\r\n    # pystate\r\n    # Be extremely careful with these functions.  Read PEP 311 for more detail.\r\n    ###############################################################################################\r\n\r\n    ctypedef int PyGILState_STATE\r\n    PyGILState_STATE    PyGILState_Ensure               ()\r\n    void                PyGILState_Release              (PyGILState_STATE)\r\n\r\n    ctypedef struct PyInterpreterState:\r\n        pass\r\n\r\n    PyThreadState*      PyThreadState_New               (PyInterpreterState *)\r\n    void                PyThreadState_Clear             (PyThreadState *)\r\n    void                PyThreadState_Delete            (PyThreadState *)\r\n    PyThreadState*      PyThreadState_Get               ()\r\n    PyThreadState*      PyThreadState_Swap              (PyThreadState *tstate)\r\n    # XXX: Borrowed reference.\r\n    #object              PyThreadState_GetDict          ()\r\n\r\n    ###############################################################################################\r\n    # run\r\n    # Functions for embedded interpreters are not included.\r\n    ###############################################################################################\r\n    ctypedef struct PyCompilerFlags:\r\n        int cf_flags\r\n\r\n    ctypedef struct _node:\r\n        pass\r\n\r\n    ctypedef void (*PyOS_sighandler_t)(int)\r\n\r\n    void                PyErr_Display                   (object, object, object)\r\n    void                PyErr_Print                     ()\r\n    void                PyErr_PrintEx                   (int)\r\n    char *              PyOS_Readline                   (FILE *, FILE *, char *)\r\n    PyOS_sighandler_t   PyOS_getsig                     (int)\r\n    PyOS_sighandler_t   PyOS_setsig                     (int, PyOS_sighandler_t)\r\n    _node *             PyParser_SimpleParseFile        (FILE *, char *, int)       except NULL\r\n    _node *             PyParser_SimpleParseFileFlags   (FILE *, char *, int,\r\n                                                         int)                       except NULL\r\n    _node *             PyParser_SimpleParseString      (char *, int)               except NULL\r\n    _node *             PyParser_SimpleParseStringFlagsFilename(char *, char *,\r\n                                                         int, int)                  except NULL\r\n    _node *             PyParser_SimpleParseStringFlags (char *, int, int)          except NULL\r\n    int                 PyRun_AnyFile                   (FILE *, char *)            except -1\r\n    int                 PyRun_AnyFileEx                 (FILE *, char *, int)       except -1\r\n    int                 PyRun_AnyFileExFlags            (FILE *, char *, int,\r\n                                                         PyCompilerFlags *)         except -1\r\n    int                 PyRun_AnyFileFlags              (FILE *, char *,\r\n                                                         PyCompilerFlags *)         except -1\r\n    object              PyRun_File                      (FILE *, char *, int,\r\n                                                         object, object)\r\n    object              PyRun_FileEx                    (FILE *, char *, int,\r\n                                                         object, object, int)\r\n    object              PyRun_FileExFlags               (FILE *, char *, int,\r\n                                                         object, object, int,\r\n                                                         PyCompilerFlags *)\r\n    object              PyRun_FileFlags                 (FILE *, char *, int,\r\n                                                         object, object,\r\n                                                         PyCompilerFlags *)\r\n    int                 PyRun_InteractiveLoop           (FILE *, char *)            except -1\r\n    int                 PyRun_InteractiveLoopFlags      (FILE *, char *,\r\n                                                         PyCompilerFlags *)         except -1\r\n    int                 PyRun_InteractiveOne            (FILE *, char *)            except -1\r\n    int                 PyRun_InteractiveOneFlags       (FILE *, char *,\r\n                                                         PyCompilerFlags *)         except -1\r\n    int                 PyRun_SimpleFile                (FILE *, char *)            except -1\r\n    int                 PyRun_SimpleFileEx              (FILE *, char *, int)       except -1\r\n    int                 PyRun_SimpleFileExFlags         (FILE *, char *, int,\r\n                                                         PyCompilerFlags *)         except -1\r\n    int                 PyRun_SimpleString              (char *)                    except -1\r\n    int                 PyRun_SimpleStringFlags         (char *, PyCompilerFlags *) except -1\r\n    object              PyRun_String                    (char *, int, object,\r\n                                                         object)\r\n    object              PyRun_StringFlags               (char *, int, object,\r\n                                                         object, PyCompilerFlags *)\r\n    int                 Py_AtExit                       (void (*func)())\r\n    object              Py_CompileString                (char *, char *, int)\r\n    object              Py_CompileStringFlags           (char *, char *, int, PyCompilerFlags *)\r\n    void                Py_Exit                         (int)\r\n    int                 Py_FdIsInteractive              (FILE *, char *)            # Always succeeds.\r\n    char *              Py_GetBuildInfo                 ()\r\n    char *              Py_GetCompiler                  ()\r\n    char *              Py_GetCopyright                 ()\r\n    char *              Py_GetExecPrefix                ()\r\n    char *              Py_GetPath                      ()\r\n    char *              Py_GetPlatform                  ()\r\n    char *              Py_GetPrefix                    ()\r\n    char *              Py_GetProgramFullPath           ()\r\n    char *              Py_GetProgramName               ()\r\n    char *              Py_GetPythonHome                ()\r\n    char *              Py_GetVersion                   ()\r\n\r\n    ###############################################################################################\r\n    # sequence\r\n    ###############################################################################################\r\n    int                 PySequence_Check                (object)                    # Always succeeds.\r\n    object              PySequence_Concat               (object, object)\r\n    int                 PySequence_Contains             (object, object)            except -1\r\n    Py_ssize_t          PySequence_Count                (object, object)            except -1\r\n    int                 PySequence_DelItem              (object, Py_ssize_t)        except -1\r\n    int                 PySequence_DelSlice             (object, Py_ssize_t, Py_ssize_t) except -1\r\n    object              PySequence_Fast                 (object, char *)\r\n    int                 PySequence_Fast_GET_SIZE        (object)\r\n    object              PySequence_GetItem              (object, Py_ssize_t)\r\n    object              PySequence_GetSlice             (object, Py_ssize_t, Py_ssize_t)\r\n    object              PySequence_ITEM                 (object, int)\r\n    int                 PySequence_In                   (object, object)            except -1\r\n    object              PySequence_InPlaceConcat        (object, object)\r\n    object              PySequence_InPlaceRepeat        (object, Py_ssize_t)\r\n    Py_ssize_t          PySequence_Index                (object, object)            except -1\r\n    Py_ssize_t          PySequence_Length               (object)                    except -1\r\n    object              PySequence_List                 (object)\r\n    object              PySequence_Repeat               (object, Py_ssize_t)\r\n    int                 PySequence_SetItem              (object, Py_ssize_t, object) except -1\r\n    int                 PySequence_SetSlice             (object, Py_ssize_t, Py_ssize_t, object) except -1\r\n    Py_ssize_t          PySequence_Size                 (object)                    except -1\r\n    object              PySequence_Tuple                (object)\r\n\r\n    ###############################################################################################\r\n    # string\r\n    ###############################################################################################\r\n    PyTypeObject PyString_Type\r\n    # Pyrex cannot support resizing because you have no choice but to use\r\n    # realloc which may call free() on the object, and there's no way to tell\r\n    # Pyrex to \"forget\" reference counting for the object.\r\n    #int                 _PyString_Resize                (object *, Py_ssize_t)             except -1\r\n    char *              PyString_AS_STRING              (object)                    # Always succeeds.\r\n    object              PyString_AsDecodedObject        (object, char *, char *)\r\n    object              PyString_AsEncodedObject        (object, char *, char *)\r\n    object              PyString_AsEncodedString        (object, char *, char *)\r\n    char *              PyString_AsString               (object)                    except NULL\r\n    int                 PyString_AsStringAndSize        (object, char **, Py_ssize_t *)    except -1\r\n    int                 PyString_Check                  (object)                    # Always succeeds.\r\n    int                 PyString_CHECK_INTERNED         (object)                    # Always succeeds.\r\n    int                 PyString_CheckExact             (object)                    # Always succeeds.\r\n    # XXX: Pyrex doesn't support pointer to a python object?\r\n    #void                PyString_Concat                 (object *, object)\r\n    # XXX: Pyrex doesn't support pointer to a python object?\r\n    #void                PyString_ConcatAndDel           (object *, object)\r\n    object              PyString_Decode                 (char *, int, char *, char *)\r\n    object              PyString_DecodeEscape           (char *, int, char *, int, char *)\r\n    object              PyString_Encode                 (char *, int, char *, char *)\r\n    object              PyString_Format                 (object, object)\r\n    object              PyString_FromFormat             (char*, ...)\r\n    object              PyString_FromFormatV            (char*, va_list)\r\n    object              PyString_FromString             (char *)\r\n    object              PyString_FromStringAndSize      (char *, Py_ssize_t)\r\n    Py_ssize_t          PyString_GET_SIZE               (object)                    # Always succeeds.\r\n    object              PyString_InternFromString       (char *)\r\n    # XXX: Pyrex doesn't support pointer to a python object?\r\n    #void                PyString_InternImmortal         (object*)\r\n    # XXX: Pyrex doesn't support pointer to a python object?\r\n    #void                PyString_InternInPlace          (object*)\r\n    object              PyString_Repr                   (object, int)\r\n    Py_ssize_t          PyString_Size                   (object)                    except -1\r\n\r\n    # Disgusting hack to access internal object values.\r\n    ctypedef struct PyStringObject:\r\n        int ob_refcnt\r\n        PyTypeObject * ob_type\r\n        int ob_size\r\n        long ob_shash\r\n        int ob_sstate\r\n        char * ob_sval\r\n\r\n    ###############################################################################################\r\n    # tuple\r\n    ###############################################################################################\r\n    PyTypeObject PyTuple_Type\r\n    # See PyString_Resize note about resizing.\r\n    #int                 _PyTuple_Resize                 (object*, Py_ssize_t)              except -1\r\n    int                 PyTuple_Check                   (object)                    # Always succeeds.\r\n    int                 PyTuple_CheckExact              (object)                    # Always succeeds.\r\n    Py_ssize_t          PyTuple_GET_SIZE                (object)                    # Always succeeds.\r\n    object              PyTuple_GetSlice                (object, Py_ssize_t, Py_ssize_t)\r\n    object              PyTuple_New                     (Py_ssize_t)\r\n    object              PyTuple_Pack                    (Py_ssize_t, ...)\r\n    Py_ssize_t          PyTuple_Size                    (object)                    except -1\r\n\r\n    ###############################################################################################\r\n    # Dangerous things!\r\n    # Do not use these unless you really, really know what you are doing.\r\n    ###############################################################################################\r\n    void                Py_INCREF                       (object)\r\n    void                Py_XINCREF                      (object)\r\n    void                Py_DECREF                       (object)\r\n    void                Py_XDECREF                      (object)\r\n    void                Py_CLEAR                        (object)\r\n\r\n    # XXX: Stolen reference.\r\n    void                PyTuple_SET_ITEM                (object, Py_ssize_t, value)\r\n    # XXX: Borrowed reference.\r\n    object              PyTuple_GET_ITEM                (object, Py_ssize_t)\r\n    # XXX: Borrowed reference.\r\n    object              PyTuple_GetItem                 (object, Py_ssize_t)\r\n    # XXX: Stolen reference.\r\n    int                 PyTuple_SetItem                 (object, Py_ssize_t, object)       except -1\r\n\r\n    # XXX: Steals reference.\r\n    int                 PyList_SetItem                  (object, Py_ssize_t, object)       except -1\r\n    # XXX: Borrowed reference\r\n    object              PyList_GetItem                  (object, Py_ssize_t)\r\n    # XXX: Borrowed reference, no NULL on error.\r\n    object              PyList_GET_ITEM                 (object, Py_ssize_t)\r\n    # XXX: Stolen reference.\r\n    void                PyList_SET_ITEM                 (object, Py_ssize_t, object)\r\n\r\n    # XXX: Borrowed reference.\r\n    object              PySequence_Fast_GET_ITEM        (object, Py_ssize_t)\r\n\r\n    # First parameter _must_ be a PyStringObject.\r\n    object              _PyString_Join                  (object, object)\r\n"
        },
        {
          "name": "setup.py",
          "type": "blob",
          "size": 2.7958984375,
          "content": "import os\nimport sys\n\n# Monkeypatch distutils.\nimport setuptools\n\nimport distutils.errors\nfrom distutils.core import setup\nfrom distutils.extension import Extension\nfrom distutils.log import warn\n\ntry:\n    from Cython.Distutils import build_ext\n    cmdclass = dict(build_ext=build_ext)\n    line_profiler_source = '_line_profiler.pyx'\nexcept ImportError:\n    cmdclass = {}\n    line_profiler_source = '_line_profiler.c'\n    if not os.path.exists(line_profiler_source):\n        raise distutils.errors.DistutilsError(\"\"\"\\\nYou need Cython to build the line_profiler from a git checkout, or\nalternatively use a release tarball from PyPI to build it without Cython.\"\"\")\n    else:\n        warn(\"Could not import Cython. \"\n             \"Using the available pre-generated C file.\")\n\nlong_description = \"\"\"\\\nline_profiler will profile the time individual lines of code take to execute.\nThe profiler is implemented in C via Cython in order to reduce the overhead of\nprofiling.\n\nAlso included is the script kernprof.py which can be used to conveniently\nprofile Python applications and scripts either with line_profiler or with the\nfunction-level profiling tools in the Python standard library.\n\"\"\"\n\n\npy_modules = ['line_profiler', 'kernprof']\nif sys.version_info > (3, 4):\n    py_modules += ['line_profiler_py35']\n\nsetup(\n    name = 'line_profiler',\n    version = '2.1.1',\n    author = 'Robert Kern',\n    author_email = 'robert.kern@enthought.com',\n    description = 'Line-by-line profiler.',\n    long_description = long_description,\n    url = 'https://github.com/rkern/line_profiler',\n    download_url = 'https://github.com/rkern/line_profiler/tarball/2.1',\n    ext_modules = [\n        Extension('_line_profiler',\n                  sources=[line_profiler_source, 'timers.c', 'unset_trace.c'],\n                  depends=['python25.pxd'],\n        ),\n    ],\n    license = \"BSD\",\n    keywords = ['timing', 'timer', 'profiling', 'profiler', 'line_profiler'],\n    classifiers = [\n        \"Development Status :: 5 - Production/Stable\",\n        \"Intended Audience :: Developers\",\n        \"License :: OSI Approved :: BSD License\",\n        \"Operating System :: OS Independent\",\n        \"Programming Language :: C\",\n        \"Programming Language :: Python\",\n        'Programming Language :: Python :: 2',\n        'Programming Language :: Python :: 2.7',\n        'Programming Language :: Python :: 3',\n        'Programming Language :: Python :: 3.2',\n        'Programming Language :: Python :: 3.3',\n        'Programming Language :: Python :: 3.4',\n        'Programming Language :: Python :: Implementation :: CPython',\n        \"Topic :: Software Development\",\n    ],\n    py_modules = py_modules,\n    entry_points = {\n        'console_scripts': [\n            'kernprof=kernprof:main',\n        ],\n    },\n    install_requires = [\n        'IPython>=0.13',\n    ],\n    cmdclass = cmdclass,\n)\n"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "timers.c",
          "type": "blob",
          "size": 1.1875,
          "content": "#include \"Python.h\"\n\n/* The following timer code comes from Python 2.5.2's _lsprof.c */\n\n#if !defined(HAVE_LONG_LONG)\n#error \"This module requires long longs!\"\n#endif\n\n/*** Selection of a high-precision timer ***/\n\n#ifdef MS_WINDOWS\n\n#include <windows.h>\n\nPY_LONG_LONG\nhpTimer(void)\n{\n        LARGE_INTEGER li;\n        QueryPerformanceCounter(&li);\n        return li.QuadPart;\n}\n\ndouble\nhpTimerUnit(void)\n{\n        LARGE_INTEGER li;\n        if (QueryPerformanceFrequency(&li))\n                return 1.0 / li.QuadPart;\n        else\n                return 0.000001;  /* unlikely */\n}\n\n#else  /* !MS_WINDOWS */\n\n#ifndef HAVE_GETTIMEOFDAY\n#error \"This module requires gettimeofday() on non-Windows platforms!\"\n#endif\n\n#if (defined(PYOS_OS2) && defined(PYCC_GCC))\n#include <sys/time.h>\n#else\n#include <sys/resource.h>\n#include <sys/times.h>\n#endif\n\nPY_LONG_LONG\nhpTimer(void)\n{\n        struct timeval tv;\n        PY_LONG_LONG ret;\n#ifdef GETTIMEOFDAY_NO_TZ\n        gettimeofday(&tv);\n#else\n        gettimeofday(&tv, (struct timezone *)NULL);\n#endif\n        ret = tv.tv_sec;\n        ret = ret * 1000000 + tv.tv_usec;\n        return ret;\n}\n\ndouble\nhpTimerUnit(void)\n{\n        return 0.000001;\n}\n\n#endif  /* MS_WINDOWS */\n\n"
        },
        {
          "name": "timers.h",
          "type": "blob",
          "size": 0.0732421875,
          "content": "#include \"Python.h\"\n\nPY_LONG_LONG hpTimer(void);\ndouble hpTimerUnit(void);\n"
        },
        {
          "name": "unset_trace.c",
          "type": "blob",
          "size": 0.123046875,
          "content": "/* Hack to hide an <object>NULL from Cython. */\n\n#include \"Python.h\"\n\nvoid unset_trace() {\n    PyEval_SetTrace(NULL, NULL);\n}\n"
        },
        {
          "name": "unset_trace.h",
          "type": "blob",
          "size": 0.01953125,
          "content": "void unset_trace();\n"
        }
      ]
    }
  ]
}