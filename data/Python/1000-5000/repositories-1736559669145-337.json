{
  "metadata": {
    "timestamp": 1736559669145,
    "page": 337,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM0MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "gaussic/text-classification-cnn-rnn",
      "stars": 4180,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.1005859375,
          "content": ".DS_Store\ndata/cnews\ndata/thucnews\n__pycache__\ncnn_keras.py\n.idea\n*.pyc\ncheckpoints\ntensorboard\n.vscode"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0380859375,
          "content": "MIT License\n\nCopyright (c) 2017 dzkang\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 14.30078125,
          "content": "# Text Classification with CNN and RNN\n\n使用卷积神经网络以及循环神经网络进行中文文本分类\n\nCNN做句子分类的论文可以参看: [Convolutional Neural Networks for Sentence Classification](https://arxiv.org/abs/1408.5882)\n\n还可以去读dennybritz大牛的博客：[Implementing a CNN for Text Classification in TensorFlow](http://www.wildml.com/2015/12/implementing-a-cnn-for-text-classification-in-tensorflow/)\n\n以及字符级CNN的论文：[Character-level Convolutional Networks for Text Classification](https://arxiv.org/abs/1509.01626)\n\n本文是基于TensorFlow在中文数据集上的简化实现，使用了字符级CNN和RNN对中文文本进行分类，达到了较好的效果。\n\n文中所使用的Conv1D与论文中有些不同，详细参考官方文档：[tf.nn.conv1d](https://www.tensorflow.org/api_docs/python/tf/nn/conv1d)\n\n## 环境\n\n- Python 2/3 (感谢[howie.hu](https://github.com/howie6879)调试Python2环境)\n- TensorFlow 1.3以上\n- numpy\n- scikit-learn\n- scipy\n\n## 数据集\n\n使用THUCNews的一个子集进行训练与测试，数据集请自行到[THUCTC：一个高效的中文文本分类工具包](http://thuctc.thunlp.org/)下载，请遵循数据提供方的开源协议。\n\n本次训练使用了其中的10个分类，每个分类6500条数据。\n\n类别如下：\n\n```\n体育, 财经, 房产, 家居, 教育, 科技, 时尚, 时政, 游戏, 娱乐\n```\n\n这个子集可以在此下载：链接: https://pan.baidu.com/s/1hugrfRu 密码: qfud\n\n数据集划分如下：\n\n- 训练集: 5000*10\n- 验证集: 500*10\n- 测试集: 1000*10\n\n从原数据集生成子集的过程请参看`helper`下的两个脚本。其中，`copy_data.sh`用于从每个分类拷贝6500个文件，`cnews_group.py`用于将多个文件整合到一个文件中。执行该文件后，得到三个数据文件：\n\n- cnews.train.txt: 训练集(50000条)\n- cnews.val.txt: 验证集(5000条)\n- cnews.test.txt: 测试集(10000条)\n\n## 预处理\n\n`data/cnews_loader.py`为数据的预处理文件。\n\n- `read_file()`: 读取文件数据;\n- `build_vocab()`: 构建词汇表，使用字符级的表示，这一函数会将词汇表存储下来，避免每一次重复处理;\n- `read_vocab()`: 读取上一步存储的词汇表，转换为`{词：id}`表示;\n- `read_category()`: 将分类目录固定，转换为`{类别: id}`表示;\n- `to_words()`: 将一条由id表示的数据重新转换为文字;\n- `process_file()`: 将数据集从文字转换为固定长度的id序列表示;\n- `batch_iter()`: 为神经网络的训练准备经过shuffle的批次的数据。\n\n经过数据预处理，数据的格式如下：\n\n| Data | Shape | Data | Shape |\n| :---------- | :---------- | :---------- | :---------- |\n| x_train | [50000, 600] | y_train | [50000, 10] |\n| x_val | [5000, 600] | y_val | [5000, 10] |\n| x_test | [10000, 600] | y_test | [10000, 10] |\n\n## CNN卷积神经网络\n\n### 配置项\n\nCNN可配置的参数如下所示，在`cnn_model.py`中。\n\n```python\nclass TCNNConfig(object):\n    \"\"\"CNN配置参数\"\"\"\n\n    embedding_dim = 64      # 词向量维度\n    seq_length = 600        # 序列长度\n    num_classes = 10        # 类别数\n    num_filters = 128        # 卷积核数目\n    kernel_size = 5         # 卷积核尺寸\n    vocab_size = 5000       # 词汇表达小\n\n    hidden_dim = 128        # 全连接层神经元\n\n    dropout_keep_prob = 0.5 # dropout保留比例\n    learning_rate = 1e-3    # 学习率\n\n    batch_size = 64         # 每批训练大小\n    num_epochs = 10         # 总迭代轮次\n\n    print_per_batch = 100    # 每多少轮输出一次结果\n    save_per_batch = 10      # 每多少轮存入tensorboard\n```\n\n### CNN模型\n\n具体参看`cnn_model.py`的实现。\n\n大致结构如下：\n\n![images/cnn_architecture](images/cnn_architecture.png)\n\n### 训练与验证\n\n运行 `python run_cnn.py train`，可以开始训练。\n\n> 若之前进行过训练，请把tensorboard/textcnn删除，避免TensorBoard多次训练结果重叠。\n\n```\nConfiguring CNN model...\nConfiguring TensorBoard and Saver...\nLoading training and validation data...\nTime usage: 0:00:14\nTraining and evaluating...\nEpoch: 1\nIter:      0, Train Loss:    2.3, Train Acc:  10.94%, Val Loss:    2.3, Val Acc:   8.92%, Time: 0:00:01 *\nIter:    100, Train Loss:   0.88, Train Acc:  73.44%, Val Loss:    1.2, Val Acc:  68.46%, Time: 0:00:04 *\nIter:    200, Train Loss:   0.38, Train Acc:  92.19%, Val Loss:   0.75, Val Acc:  77.32%, Time: 0:00:07 *\nIter:    300, Train Loss:   0.22, Train Acc:  92.19%, Val Loss:   0.46, Val Acc:  87.08%, Time: 0:00:09 *\nIter:    400, Train Loss:   0.24, Train Acc:  90.62%, Val Loss:    0.4, Val Acc:  88.62%, Time: 0:00:12 *\nIter:    500, Train Loss:   0.16, Train Acc:  96.88%, Val Loss:   0.36, Val Acc:  90.38%, Time: 0:00:15 *\nIter:    600, Train Loss:  0.084, Train Acc:  96.88%, Val Loss:   0.35, Val Acc:  91.36%, Time: 0:00:17 *\nIter:    700, Train Loss:   0.21, Train Acc:  93.75%, Val Loss:   0.26, Val Acc:  92.58%, Time: 0:00:20 *\nEpoch: 2\nIter:    800, Train Loss:   0.07, Train Acc:  98.44%, Val Loss:   0.24, Val Acc:  94.12%, Time: 0:00:23 *\nIter:    900, Train Loss:  0.092, Train Acc:  96.88%, Val Loss:   0.27, Val Acc:  92.86%, Time: 0:00:25\nIter:   1000, Train Loss:   0.17, Train Acc:  95.31%, Val Loss:   0.28, Val Acc:  92.82%, Time: 0:00:28\nIter:   1100, Train Loss:    0.2, Train Acc:  93.75%, Val Loss:   0.23, Val Acc:  93.26%, Time: 0:00:31\nIter:   1200, Train Loss:  0.081, Train Acc:  98.44%, Val Loss:   0.25, Val Acc:  92.96%, Time: 0:00:33\nIter:   1300, Train Loss:  0.052, Train Acc: 100.00%, Val Loss:   0.24, Val Acc:  93.58%, Time: 0:00:36\nIter:   1400, Train Loss:    0.1, Train Acc:  95.31%, Val Loss:   0.22, Val Acc:  94.12%, Time: 0:00:39\nIter:   1500, Train Loss:   0.12, Train Acc:  98.44%, Val Loss:   0.23, Val Acc:  93.58%, Time: 0:00:41\nEpoch: 3\nIter:   1600, Train Loss:    0.1, Train Acc:  96.88%, Val Loss:   0.26, Val Acc:  92.34%, Time: 0:00:44\nIter:   1700, Train Loss:  0.018, Train Acc: 100.00%, Val Loss:   0.22, Val Acc:  93.46%, Time: 0:00:47\nIter:   1800, Train Loss:  0.036, Train Acc: 100.00%, Val Loss:   0.28, Val Acc:  92.72%, Time: 0:00:50\nNo optimization for a long time, auto-stopping...\n```\n\n在验证集上的最佳效果为94.12%，且只经过了3轮迭代就已经停止。\n\n准确率和误差如图所示：\n\n![images](images/acc_loss.png)\n\n\n### 测试\n\n运行 `python run_cnn.py test` 在测试集上进行测试。\n\n```\nConfiguring CNN model...\nLoading test data...\nTesting...\nTest Loss:   0.14, Test Acc:  96.04%\nPrecision, Recall and F1-Score...\n             precision    recall  f1-score   support\n\n         体育       0.99      0.99      0.99      1000\n         财经       0.96      0.99      0.97      1000\n         房产       1.00      1.00      1.00      1000\n         家居       0.95      0.91      0.93      1000\n         教育       0.95      0.89      0.92      1000\n         科技       0.94      0.97      0.95      1000\n         时尚       0.95      0.97      0.96      1000\n         时政       0.94      0.94      0.94      1000\n         游戏       0.97      0.96      0.97      1000\n         娱乐       0.95      0.98      0.97      1000\n\navg / total       0.96      0.96      0.96     10000\n\nConfusion Matrix...\n[[991   0   0   0   2   1   0   4   1   1]\n [  0 992   0   0   2   1   0   5   0   0]\n [  0   1 996   0   1   1   0   0   0   1]\n [  0  14   0 912   7  15   9  29   3  11]\n [  2   9   0  12 892  22  18  21  10  14]\n [  0   0   0  10   1 968   4   3  12   2]\n [  1   0   0   9   4   4 971   0   2   9]\n [  1  16   0   4  18  12   1 941   1   6]\n [  2   4   1   5   4   5  10   1 962   6]\n [  1   0   1   6   4   3   5   0   1 979]]\nTime usage: 0:00:05\n```\n\n在测试集上的准确率达到了96.04%，且各类的precision, recall和f1-score都超过了0.9。\n\n从混淆矩阵也可以看出分类效果非常优秀。\n\n## RNN循环神经网络\n\n### 配置项\n\nRNN可配置的参数如下所示，在`rnn_model.py`中。\n\n```python\nclass TRNNConfig(object):\n    \"\"\"RNN配置参数\"\"\"\n\n    # 模型参数\n    embedding_dim = 64      # 词向量维度\n    seq_length = 600        # 序列长度\n    num_classes = 10        # 类别数\n    vocab_size = 5000       # 词汇表达小\n\n    num_layers= 2           # 隐藏层层数\n    hidden_dim = 128        # 隐藏层神经元\n    rnn = 'gru'             # lstm 或 gru\n\n    dropout_keep_prob = 0.8 # dropout保留比例\n    learning_rate = 1e-3    # 学习率\n\n    batch_size = 128         # 每批训练大小\n    num_epochs = 10          # 总迭代轮次\n\n    print_per_batch = 100    # 每多少轮输出一次结果\n    save_per_batch = 10      # 每多少轮存入tensorboard\n```\n\n### RNN模型\n\n具体参看`rnn_model.py`的实现。\n\n大致结构如下：\n\n![images/rnn_architecture](images/rnn_architecture.png)\n\n### 训练与验证\n\n> 这部分的代码与 run_cnn.py极为相似，只需要将模型和部分目录稍微修改。\n\n运行 `python run_rnn.py train`，可以开始训练。\n\n> 若之前进行过训练，请把tensorboard/textrnn删除，避免TensorBoard多次训练结果重叠。\n\n```\nConfiguring RNN model...\nConfiguring TensorBoard and Saver...\nLoading training and validation data...\nTime usage: 0:00:14\nTraining and evaluating...\nEpoch: 1\nIter:      0, Train Loss:    2.3, Train Acc:   8.59%, Val Loss:    2.3, Val Acc:  11.96%, Time: 0:00:08 *\nIter:    100, Train Loss:   0.95, Train Acc:  64.06%, Val Loss:    1.3, Val Acc:  53.06%, Time: 0:01:15 *\nIter:    200, Train Loss:   0.61, Train Acc:  79.69%, Val Loss:   0.94, Val Acc:  69.88%, Time: 0:02:22 *\nIter:    300, Train Loss:   0.49, Train Acc:  85.16%, Val Loss:   0.63, Val Acc:  81.44%, Time: 0:03:29 *\nEpoch: 2\nIter:    400, Train Loss:   0.23, Train Acc:  92.97%, Val Loss:    0.6, Val Acc:  82.86%, Time: 0:04:36 *\nIter:    500, Train Loss:   0.27, Train Acc:  92.97%, Val Loss:   0.47, Val Acc:  86.72%, Time: 0:05:43 *\nIter:    600, Train Loss:   0.13, Train Acc:  98.44%, Val Loss:   0.43, Val Acc:  87.46%, Time: 0:06:50 *\nIter:    700, Train Loss:   0.24, Train Acc:  91.41%, Val Loss:   0.46, Val Acc:  87.12%, Time: 0:07:57\nEpoch: 3\nIter:    800, Train Loss:   0.11, Train Acc:  96.09%, Val Loss:   0.49, Val Acc:  87.02%, Time: 0:09:03\nIter:    900, Train Loss:   0.15, Train Acc:  96.09%, Val Loss:   0.55, Val Acc:  85.86%, Time: 0:10:10\nIter:   1000, Train Loss:   0.17, Train Acc:  96.09%, Val Loss:   0.43, Val Acc:  89.44%, Time: 0:11:18 *\nIter:   1100, Train Loss:   0.25, Train Acc:  93.75%, Val Loss:   0.42, Val Acc:  88.98%, Time: 0:12:25\nEpoch: 4\nIter:   1200, Train Loss:   0.14, Train Acc:  96.09%, Val Loss:   0.39, Val Acc:  89.82%, Time: 0:13:32 *\nIter:   1300, Train Loss:    0.2, Train Acc:  96.09%, Val Loss:   0.43, Val Acc:  88.68%, Time: 0:14:38\nIter:   1400, Train Loss:  0.012, Train Acc: 100.00%, Val Loss:   0.37, Val Acc:  90.58%, Time: 0:15:45 *\nIter:   1500, Train Loss:   0.15, Train Acc:  96.88%, Val Loss:   0.39, Val Acc:  90.58%, Time: 0:16:52\nEpoch: 5\nIter:   1600, Train Loss:  0.075, Train Acc:  97.66%, Val Loss:   0.41, Val Acc:  89.90%, Time: 0:17:59\nIter:   1700, Train Loss:  0.042, Train Acc:  98.44%, Val Loss:   0.41, Val Acc:  90.08%, Time: 0:19:06\nIter:   1800, Train Loss:   0.08, Train Acc:  97.66%, Val Loss:   0.38, Val Acc:  91.36%, Time: 0:20:13 *\nIter:   1900, Train Loss:  0.089, Train Acc:  98.44%, Val Loss:   0.39, Val Acc:  90.18%, Time: 0:21:20\nEpoch: 6\nIter:   2000, Train Loss:  0.092, Train Acc:  96.88%, Val Loss:   0.36, Val Acc:  91.42%, Time: 0:22:27 *\nIter:   2100, Train Loss:  0.062, Train Acc:  98.44%, Val Loss:   0.39, Val Acc:  90.56%, Time: 0:23:34\nIter:   2200, Train Loss:  0.053, Train Acc:  98.44%, Val Loss:   0.39, Val Acc:  90.02%, Time: 0:24:41\nIter:   2300, Train Loss:   0.12, Train Acc:  96.09%, Val Loss:   0.37, Val Acc:  90.84%, Time: 0:25:48\nEpoch: 7\nIter:   2400, Train Loss:  0.014, Train Acc: 100.00%, Val Loss:   0.41, Val Acc:  90.38%, Time: 0:26:55\nIter:   2500, Train Loss:   0.14, Train Acc:  96.88%, Val Loss:   0.37, Val Acc:  91.22%, Time: 0:28:01\nIter:   2600, Train Loss:   0.11, Train Acc:  96.88%, Val Loss:   0.43, Val Acc:  89.76%, Time: 0:29:08\nIter:   2700, Train Loss:  0.089, Train Acc:  97.66%, Val Loss:   0.37, Val Acc:  91.18%, Time: 0:30:15\nEpoch: 8\nIter:   2800, Train Loss: 0.0081, Train Acc: 100.00%, Val Loss:   0.44, Val Acc:  90.66%, Time: 0:31:22\nIter:   2900, Train Loss:  0.017, Train Acc: 100.00%, Val Loss:   0.44, Val Acc:  89.62%, Time: 0:32:29\nIter:   3000, Train Loss:  0.061, Train Acc:  96.88%, Val Loss:   0.43, Val Acc:  90.04%, Time: 0:33:36\nNo optimization for a long time, auto-stopping...\n```\n\n在验证集上的最佳效果为91.42%，经过了8轮迭代停止，速度相比CNN慢很多。\n\n准确率和误差如图所示：\n\n![images](images/acc_loss_rnn.png)\n\n\n### 测试\n\n运行 `python run_rnn.py test` 在测试集上进行测试。\n\n```\nTesting...\nTest Loss:   0.21, Test Acc:  94.22%\nPrecision, Recall and F1-Score...\n             precision    recall  f1-score   support\n\n         体育       0.99      0.99      0.99      1000\n         财经       0.91      0.99      0.95      1000\n         房产       1.00      1.00      1.00      1000\n         家居       0.97      0.73      0.83      1000\n         教育       0.91      0.92      0.91      1000\n         科技       0.93      0.96      0.94      1000\n         时尚       0.89      0.97      0.93      1000\n         时政       0.93      0.93      0.93      1000\n         游戏       0.95      0.97      0.96      1000\n         娱乐       0.97      0.96      0.97      1000\n\navg / total       0.94      0.94      0.94     10000\n\nConfusion Matrix...\n[[988   0   0   0   4   0   2   0   5   1]\n [  0 990   1   1   1   1   0   6   0   0]\n [  0   2 996   1   1   0   0   0   0   0]\n [  2  71   1 731  51  20  88  28   3   5]\n [  1   3   0   7 918  23   4  31   9   4]\n [  1   3   0   3   0 964   3   5  21   0]\n [  1   0   1   7   1   3 972   0   6   9]\n [  0  16   0   0  22  26   0 931   2   3]\n [  2   3   0   0   2   2  12   0 972   7]\n [  0   3   1   1   7   3  11   5   9 960]]\nTime usage: 0:00:33\n```\n\n在测试集上的准确率达到了94.22%，且各类的precision, recall和f1-score，除了家居这一类别，都超过了0.9。\n\n从混淆矩阵可以看出分类效果非常优秀。\n\n对比两个模型，可见RNN除了在家居分类的表现不是很理想，其他几个类别较CNN差别不大。\n\n还可以通过进一步的调节参数，来达到更好的效果。\n\n\n## 预测\n\n为方便预测，repo 中 `predict.py` 提供了 CNN 模型的预测方法。\n"
        },
        {
          "name": "cnn_model.py",
          "type": "blob",
          "size": 2.6826171875,
          "content": "# coding: utf-8\n\nimport tensorflow as tf\n\n\nclass TCNNConfig(object):\n    \"\"\"CNN配置参数\"\"\"\n\n    embedding_dim = 64  # 词向量维度\n    seq_length = 600  # 序列长度\n    num_classes = 10  # 类别数\n    num_filters = 256  # 卷积核数目\n    kernel_size = 5  # 卷积核尺寸\n    vocab_size = 5000  # 词汇表达小\n\n    hidden_dim = 128  # 全连接层神经元\n\n    dropout_keep_prob = 0.5  # dropout保留比例\n    learning_rate = 1e-3  # 学习率\n\n    batch_size = 64  # 每批训练大小\n    num_epochs = 10  # 总迭代轮次\n\n    print_per_batch = 100  # 每多少轮输出一次结果\n    save_per_batch = 10  # 每多少轮存入tensorboard\n\n\nclass TextCNN(object):\n    \"\"\"文本分类，CNN模型\"\"\"\n\n    def __init__(self, config):\n        self.config = config\n\n        # 三个待输入的数据\n        self.input_x = tf.placeholder(tf.int32, [None, self.config.seq_length], name='input_x')\n        self.input_y = tf.placeholder(tf.float32, [None, self.config.num_classes], name='input_y')\n        self.keep_prob = tf.placeholder(tf.float32, name='keep_prob')\n\n        self.cnn()\n\n    def cnn(self):\n        \"\"\"CNN模型\"\"\"\n        # 词向量映射\n        with tf.device('/cpu:0'):\n            embedding = tf.get_variable('embedding', [self.config.vocab_size, self.config.embedding_dim])\n            embedding_inputs = tf.nn.embedding_lookup(embedding, self.input_x)\n\n        with tf.name_scope(\"cnn\"):\n            # CNN layer\n            conv = tf.layers.conv1d(embedding_inputs, self.config.num_filters, self.config.kernel_size, name='conv')\n            # global max pooling layer\n            gmp = tf.reduce_max(conv, reduction_indices=[1], name='gmp')\n\n        with tf.name_scope(\"score\"):\n            # 全连接层，后面接dropout以及relu激活\n            fc = tf.layers.dense(gmp, self.config.hidden_dim, name='fc1')\n            fc = tf.contrib.layers.dropout(fc, self.keep_prob)\n            fc = tf.nn.relu(fc)\n\n            # 分类器\n            self.logits = tf.layers.dense(fc, self.config.num_classes, name='fc2')\n            self.y_pred_cls = tf.argmax(tf.nn.softmax(self.logits), 1)  # 预测类别\n\n        with tf.name_scope(\"optimize\"):\n            # 损失函数，交叉熵\n            cross_entropy = tf.nn.softmax_cross_entropy_with_logits(logits=self.logits, labels=self.input_y)\n            self.loss = tf.reduce_mean(cross_entropy)\n            # 优化器\n            self.optim = tf.train.AdamOptimizer(learning_rate=self.config.learning_rate).minimize(self.loss)\n\n        with tf.name_scope(\"accuracy\"):\n            # 准确率\n            correct_pred = tf.equal(tf.argmax(self.input_y, 1), self.y_pred_cls)\n            self.acc = tf.reduce_mean(tf.cast(correct_pred, tf.float32))\n"
        },
        {
          "name": "data",
          "type": "tree",
          "content": null
        },
        {
          "name": "helper",
          "type": "tree",
          "content": null
        },
        {
          "name": "images",
          "type": "tree",
          "content": null
        },
        {
          "name": "predict.py",
          "type": "blob",
          "size": 1.845703125,
          "content": "# coding: utf-8\n\nfrom __future__ import print_function\n\nimport os\nimport tensorflow as tf\nimport tensorflow.contrib.keras as kr\n\nfrom cnn_model import TCNNConfig, TextCNN\nfrom data.cnews_loader import read_category, read_vocab\n\ntry:\n    bool(type(unicode))\nexcept NameError:\n    unicode = str\n\nbase_dir = 'data/cnews'\nvocab_dir = os.path.join(base_dir, 'cnews.vocab.txt')\n\nsave_dir = 'checkpoints/textcnn'\nsave_path = os.path.join(save_dir, 'best_validation')  # 最佳验证结果保存路径\n\n\nclass CnnModel:\n    def __init__(self):\n        self.config = TCNNConfig()\n        self.categories, self.cat_to_id = read_category()\n        self.words, self.word_to_id = read_vocab(vocab_dir)\n        self.config.vocab_size = len(self.words)\n        self.model = TextCNN(self.config)\n\n        self.session = tf.Session()\n        self.session.run(tf.global_variables_initializer())\n        saver = tf.train.Saver()\n        saver.restore(sess=self.session, save_path=save_path)  # 读取保存的模型\n\n    def predict(self, message):\n        # 支持不论在python2还是python3下训练的模型都可以在2或者3的环境下运行\n        content = unicode(message)\n        data = [self.word_to_id[x] for x in content if x in self.word_to_id]\n\n        feed_dict = {\n            self.model.input_x: kr.preprocessing.sequence.pad_sequences([data], self.config.seq_length),\n            self.model.keep_prob: 1.0\n        }\n\n        y_pred_cls = self.session.run(self.model.y_pred_cls, feed_dict=feed_dict)\n        return self.categories[y_pred_cls[0]]\n\n\nif __name__ == '__main__':\n    cnn_model = CnnModel()\n    test_demo = ['三星ST550以全新的拍摄方式超越了以往任何一款数码相机',\n                 '热火vs骑士前瞻：皇帝回乡二番战 东部次席唾手可得新浪体育讯北京时间3月30日7:00']\n    for i in test_demo:\n        print(cnn_model.predict(i))\n"
        },
        {
          "name": "requirements.txt",
          "type": "blob",
          "size": 0.0234375,
          "content": "scikit-learn\nscipy\nnumpy"
        },
        {
          "name": "rnn_model.py",
          "type": "blob",
          "size": 3.3984375,
          "content": "#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf\n\nclass TRNNConfig(object):\n    \"\"\"RNN配置参数\"\"\"\n\n    # 模型参数\n    embedding_dim = 64      # 词向量维度\n    seq_length = 600        # 序列长度\n    num_classes = 10        # 类别数\n    vocab_size = 5000       # 词汇表达小\n\n    num_layers= 2           # 隐藏层层数\n    hidden_dim = 128        # 隐藏层神经元\n    rnn = 'gru'             # lstm 或 gru\n\n    dropout_keep_prob = 0.8 # dropout保留比例\n    learning_rate = 1e-3    # 学习率\n\n    batch_size = 128         # 每批训练大小\n    num_epochs = 10          # 总迭代轮次\n\n    print_per_batch = 100    # 每多少轮输出一次结果\n    save_per_batch = 10      # 每多少轮存入tensorboard\n\n\nclass TextRNN(object):\n    \"\"\"文本分类，RNN模型\"\"\"\n    def __init__(self, config):\n        self.config = config\n\n        # 三个待输入的数据\n        self.input_x = tf.placeholder(tf.int32, [None, self.config.seq_length], name='input_x')\n        self.input_y = tf.placeholder(tf.float32, [None, self.config.num_classes], name='input_y')\n        self.keep_prob = tf.placeholder(tf.float32, name='keep_prob')\n\n        self.rnn()\n\n    def rnn(self):\n        \"\"\"rnn模型\"\"\"\n\n        def lstm_cell():   # lstm核\n            return tf.contrib.rnn.BasicLSTMCell(self.config.hidden_dim, state_is_tuple=True)\n\n        def gru_cell():  # gru核\n            return tf.contrib.rnn.GRUCell(self.config.hidden_dim)\n\n        def dropout(): # 为每一个rnn核后面加一个dropout层\n            if (self.config.rnn == 'lstm'):\n                cell = lstm_cell()\n            else:\n                cell = gru_cell()\n            return tf.contrib.rnn.DropoutWrapper(cell, output_keep_prob=self.keep_prob)\n\n        # 词向量映射\n        with tf.device('/cpu:0'):\n            embedding = tf.get_variable('embedding', [self.config.vocab_size, self.config.embedding_dim])\n            embedding_inputs = tf.nn.embedding_lookup(embedding, self.input_x)\n\n        with tf.name_scope(\"rnn\"):\n            # 多层rnn网络\n            cells = [dropout() for _ in range(self.config.num_layers)]\n            rnn_cell = tf.contrib.rnn.MultiRNNCell(cells, state_is_tuple=True)\n\n            _outputs, _ = tf.nn.dynamic_rnn(cell=rnn_cell, inputs=embedding_inputs, dtype=tf.float32)\n            last = _outputs[:, -1, :]  # 取最后一个时序输出作为结果\n\n        with tf.name_scope(\"score\"):\n            # 全连接层，后面接dropout以及relu激活\n            fc = tf.layers.dense(last, self.config.hidden_dim, name='fc1')\n            fc = tf.contrib.layers.dropout(fc, self.keep_prob)\n            fc = tf.nn.relu(fc)\n\n            # 分类器\n            self.logits = tf.layers.dense(fc, self.config.num_classes, name='fc2')\n            self.y_pred_cls = tf.argmax(tf.nn.softmax(self.logits), 1)  # 预测类别\n\n        with tf.name_scope(\"optimize\"):\n            # 损失函数，交叉熵\n            cross_entropy = tf.nn.softmax_cross_entropy_with_logits(logits=self.logits, labels=self.input_y)\n            self.loss = tf.reduce_mean(cross_entropy)\n            # 优化器\n            self.optim = tf.train.AdamOptimizer(learning_rate=self.config.learning_rate).minimize(self.loss)\n\n        with tf.name_scope(\"accuracy\"):\n            # 准确率\n            correct_pred = tf.equal(tf.argmax(self.input_y, 1), self.y_pred_cls)\n            self.acc = tf.reduce_mean(tf.cast(correct_pred, tf.float32))\n"
        },
        {
          "name": "run_cnn.py",
          "type": "blob",
          "size": 6.9287109375,
          "content": "#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\nfrom __future__ import print_function\n\nimport os\nimport sys\nimport time\nfrom datetime import timedelta\n\nimport numpy as np\nimport tensorflow as tf\nfrom sklearn import metrics\n\nfrom cnn_model import TCNNConfig, TextCNN\nfrom data.cnews_loader import read_vocab, read_category, batch_iter, process_file, build_vocab\n\nbase_dir = 'data/cnews'\ntrain_dir = os.path.join(base_dir, 'cnews.train.txt')\ntest_dir = os.path.join(base_dir, 'cnews.test.txt')\nval_dir = os.path.join(base_dir, 'cnews.val.txt')\nvocab_dir = os.path.join(base_dir, 'cnews.vocab.txt')\n\nsave_dir = 'checkpoints/textcnn'\nsave_path = os.path.join(save_dir, 'best_validation')  # 最佳验证结果保存路径\n\n\ndef get_time_dif(start_time):\n    \"\"\"获取已使用时间\"\"\"\n    end_time = time.time()\n    time_dif = end_time - start_time\n    return timedelta(seconds=int(round(time_dif)))\n\n\ndef feed_data(x_batch, y_batch, keep_prob):\n    feed_dict = {\n        model.input_x: x_batch,\n        model.input_y: y_batch,\n        model.keep_prob: keep_prob\n    }\n    return feed_dict\n\n\ndef evaluate(sess, x_, y_):\n    \"\"\"评估在某一数据上的准确率和损失\"\"\"\n    data_len = len(x_)\n    batch_eval = batch_iter(x_, y_, 128)\n    total_loss = 0.0\n    total_acc = 0.0\n    for x_batch, y_batch in batch_eval:\n        batch_len = len(x_batch)\n        feed_dict = feed_data(x_batch, y_batch, 1.0)\n        loss, acc = sess.run([model.loss, model.acc], feed_dict=feed_dict)\n        total_loss += loss * batch_len\n        total_acc += acc * batch_len\n\n    return total_loss / data_len, total_acc / data_len\n\n\ndef train():\n    print(\"Configuring TensorBoard and Saver...\")\n    # 配置 Tensorboard，重新训练时，请将tensorboard文件夹删除，不然图会覆盖\n    tensorboard_dir = 'tensorboard/textcnn'\n    if not os.path.exists(tensorboard_dir):\n        os.makedirs(tensorboard_dir)\n\n    tf.summary.scalar(\"loss\", model.loss)\n    tf.summary.scalar(\"accuracy\", model.acc)\n    merged_summary = tf.summary.merge_all()\n    writer = tf.summary.FileWriter(tensorboard_dir)\n\n    # 配置 Saver\n    saver = tf.train.Saver()\n    if not os.path.exists(save_dir):\n        os.makedirs(save_dir)\n\n    print(\"Loading training and validation data...\")\n    # 载入训练集与验证集\n    start_time = time.time()\n    x_train, y_train = process_file(train_dir, word_to_id, cat_to_id, config.seq_length)\n    x_val, y_val = process_file(val_dir, word_to_id, cat_to_id, config.seq_length)\n    time_dif = get_time_dif(start_time)\n    print(\"Time usage:\", time_dif)\n\n    # 创建session\n    session = tf.Session()\n    session.run(tf.global_variables_initializer())\n    writer.add_graph(session.graph)\n\n    print('Training and evaluating...')\n    start_time = time.time()\n    total_batch = 0  # 总批次\n    best_acc_val = 0.0  # 最佳验证集准确率\n    last_improved = 0  # 记录上一次提升批次\n    require_improvement = 1000  # 如果超过1000轮未提升，提前结束训练\n\n    flag = False\n    for epoch in range(config.num_epochs):\n        print('Epoch:', epoch + 1)\n        batch_train = batch_iter(x_train, y_train, config.batch_size)\n        for x_batch, y_batch in batch_train:\n            feed_dict = feed_data(x_batch, y_batch, config.dropout_keep_prob)\n\n            if total_batch % config.save_per_batch == 0:\n                # 每多少轮次将训练结果写入tensorboard scalar\n                s = session.run(merged_summary, feed_dict=feed_dict)\n                writer.add_summary(s, total_batch)\n\n            if total_batch % config.print_per_batch == 0:\n                # 每多少轮次输出在训练集和验证集上的性能\n                feed_dict[model.keep_prob] = 1.0\n                loss_train, acc_train = session.run([model.loss, model.acc], feed_dict=feed_dict)\n                loss_val, acc_val = evaluate(session, x_val, y_val)  # todo\n\n                if acc_val > best_acc_val:\n                    # 保存最好结果\n                    best_acc_val = acc_val\n                    last_improved = total_batch\n                    saver.save(sess=session, save_path=save_path)\n                    improved_str = '*'\n                else:\n                    improved_str = ''\n\n                time_dif = get_time_dif(start_time)\n                msg = 'Iter: {0:>6}, Train Loss: {1:>6.2}, Train Acc: {2:>7.2%},' \\\n                      + ' Val Loss: {3:>6.2}, Val Acc: {4:>7.2%}, Time: {5} {6}'\n                print(msg.format(total_batch, loss_train, acc_train, loss_val, acc_val, time_dif, improved_str))\n\n            feed_dict[model.keep_prob] = config.dropout_keep_prob\n            session.run(model.optim, feed_dict=feed_dict)  # 运行优化\n            total_batch += 1\n\n            if total_batch - last_improved > require_improvement:\n                # 验证集正确率长期不提升，提前结束训练\n                print(\"No optimization for a long time, auto-stopping...\")\n                flag = True\n                break  # 跳出循环\n        if flag:  # 同上\n            break\n\n\ndef test():\n    print(\"Loading test data...\")\n    start_time = time.time()\n    x_test, y_test = process_file(test_dir, word_to_id, cat_to_id, config.seq_length)\n\n    session = tf.Session()\n    session.run(tf.global_variables_initializer())\n    saver = tf.train.Saver()\n    saver.restore(sess=session, save_path=save_path)  # 读取保存的模型\n\n    print('Testing...')\n    loss_test, acc_test = evaluate(session, x_test, y_test)\n    msg = 'Test Loss: {0:>6.2}, Test Acc: {1:>7.2%}'\n    print(msg.format(loss_test, acc_test))\n\n    batch_size = 128\n    data_len = len(x_test)\n    num_batch = int((data_len - 1) / batch_size) + 1\n\n    y_test_cls = np.argmax(y_test, 1)\n    y_pred_cls = np.zeros(shape=len(x_test), dtype=np.int32)  # 保存预测结果\n    for i in range(num_batch):  # 逐批次处理\n        start_id = i * batch_size\n        end_id = min((i + 1) * batch_size, data_len)\n        feed_dict = {\n            model.input_x: x_test[start_id:end_id],\n            model.keep_prob: 1.0\n        }\n        y_pred_cls[start_id:end_id] = session.run(model.y_pred_cls, feed_dict=feed_dict)\n\n    # 评估\n    print(\"Precision, Recall and F1-Score...\")\n    print(metrics.classification_report(y_test_cls, y_pred_cls, target_names=categories))\n\n    # 混淆矩阵\n    print(\"Confusion Matrix...\")\n    cm = metrics.confusion_matrix(y_test_cls, y_pred_cls)\n    print(cm)\n\n    time_dif = get_time_dif(start_time)\n    print(\"Time usage:\", time_dif)\n\n\nif __name__ == '__main__':\n    if len(sys.argv) != 2 or sys.argv[1] not in ['train', 'test']:\n        raise ValueError(\"\"\"usage: python run_cnn.py [train / test]\"\"\")\n\n    print('Configuring CNN model...')\n    config = TCNNConfig()\n    if not os.path.exists(vocab_dir):  # 如果不存在词汇表，重建\n        build_vocab(train_dir, vocab_dir, config.vocab_size)\n    categories, cat_to_id = read_category()\n    words, word_to_id = read_vocab(vocab_dir)\n    config.vocab_size = len(words)\n    model = TextCNN(config)\n\n    if sys.argv[1] == 'train':\n        train()\n    else:\n        test()\n"
        },
        {
          "name": "run_rnn.py",
          "type": "blob",
          "size": 6.9150390625,
          "content": "# coding: utf-8\n\nfrom __future__ import print_function\n\nimport os\nimport sys\nimport time\nfrom datetime import timedelta\n\nimport numpy as np\nimport tensorflow as tf\nfrom sklearn import metrics\n\nfrom rnn_model import TRNNConfig, TextRNN\nfrom data.cnews_loader import read_vocab, read_category, batch_iter, process_file, build_vocab\n\nbase_dir = 'data/cnews'\ntrain_dir = os.path.join(base_dir, 'cnews.train.txt')\ntest_dir = os.path.join(base_dir, 'cnews.test.txt')\nval_dir = os.path.join(base_dir, 'cnews.val.txt')\nvocab_dir = os.path.join(base_dir, 'cnews.vocab.txt')\n\nsave_dir = 'checkpoints/textrnn'\nsave_path = os.path.join(save_dir, 'best_validation')  # 最佳验证结果保存路径\n\n\ndef get_time_dif(start_time):\n    \"\"\"获取已使用时间\"\"\"\n    end_time = time.time()\n    time_dif = end_time - start_time\n    return timedelta(seconds=int(round(time_dif)))\n\n\ndef feed_data(x_batch, y_batch, keep_prob):\n    feed_dict = {\n        model.input_x: x_batch,\n        model.input_y: y_batch,\n        model.keep_prob: keep_prob\n    }\n    return feed_dict\n\n\ndef evaluate(sess, x_, y_):\n    \"\"\"评估在某一数据上的准确率和损失\"\"\"\n    data_len = len(x_)\n    batch_eval = batch_iter(x_, y_, 128)\n    total_loss = 0.0\n    total_acc = 0.0\n    for x_batch, y_batch in batch_eval:\n        batch_len = len(x_batch)\n        feed_dict = feed_data(x_batch, y_batch, 1.0)\n        loss, acc = sess.run([model.loss, model.acc], feed_dict=feed_dict)\n        total_loss += loss * batch_len\n        total_acc += acc * batch_len\n\n    return total_loss / data_len, total_acc / data_len\n\n\ndef train():\n    print(\"Configuring TensorBoard and Saver...\")\n    # 配置 Tensorboard，重新训练时，请将tensorboard文件夹删除，不然图会覆盖\n    tensorboard_dir = 'tensorboard/textrnn'\n    if not os.path.exists(tensorboard_dir):\n        os.makedirs(tensorboard_dir)\n\n    tf.summary.scalar(\"loss\", model.loss)\n    tf.summary.scalar(\"accuracy\", model.acc)\n    merged_summary = tf.summary.merge_all()\n    writer = tf.summary.FileWriter(tensorboard_dir)\n\n    # 配置 Saver\n    saver = tf.train.Saver()\n    if not os.path.exists(save_dir):\n        os.makedirs(save_dir)\n\n    print(\"Loading training and validation data...\")\n    # 载入训练集与验证集\n    start_time = time.time()\n    x_train, y_train = process_file(train_dir, word_to_id, cat_to_id, config.seq_length)\n    x_val, y_val = process_file(val_dir, word_to_id, cat_to_id, config.seq_length)\n    time_dif = get_time_dif(start_time)\n    print(\"Time usage:\", time_dif)\n\n    # 创建session\n    session = tf.Session()\n    session.run(tf.global_variables_initializer())\n    writer.add_graph(session.graph)\n\n    print('Training and evaluating...')\n    start_time = time.time()\n    total_batch = 0  # 总批次\n    best_acc_val = 0.0  # 最佳验证集准确率\n    last_improved = 0  # 记录上一次提升批次\n    require_improvement = 1000  # 如果超过1000轮未提升，提前结束训练\n\n    flag = False\n    for epoch in range(config.num_epochs):\n        print('Epoch:', epoch + 1)\n        batch_train = batch_iter(x_train, y_train, config.batch_size)\n        for x_batch, y_batch in batch_train:\n            feed_dict = feed_data(x_batch, y_batch, config.dropout_keep_prob)\n\n            if total_batch % config.save_per_batch == 0:\n                # 每多少轮次将训练结果写入tensorboard scalar\n                s = session.run(merged_summary, feed_dict=feed_dict)\n                writer.add_summary(s, total_batch)\n\n            if total_batch % config.print_per_batch == 0:\n                # 每多少轮次输出在训练集和验证集上的性能\n                feed_dict[model.keep_prob] = 1.0\n                loss_train, acc_train = session.run([model.loss, model.acc], feed_dict=feed_dict)\n                loss_val, acc_val = evaluate(session, x_val, y_val)  # todo\n\n                if acc_val > best_acc_val:\n                    # 保存最好结果\n                    best_acc_val = acc_val\n                    last_improved = total_batch\n                    saver.save(sess=session, save_path=save_path)\n                    improved_str = '*'\n                else:\n                    improved_str = ''\n\n                time_dif = get_time_dif(start_time)\n                msg = 'Iter: {0:>6}, Train Loss: {1:>6.2}, Train Acc: {2:>7.2%},' \\\n                      + ' Val Loss: {3:>6.2}, Val Acc: {4:>7.2%}, Time: {5} {6}'\n                print(msg.format(total_batch, loss_train, acc_train, loss_val, acc_val, time_dif, improved_str))\n            \n            feed_dict[model.keep_prob] = config.dropout_keep_prob\n            session.run(model.optim, feed_dict=feed_dict)  # 运行优化\n            total_batch += 1\n\n            if total_batch - last_improved > require_improvement:\n                # 验证集正确率长期不提升，提前结束训练\n                print(\"No optimization for a long time, auto-stopping...\")\n                flag = True\n                break  # 跳出循环\n        if flag:  # 同上\n            break\n\n\ndef test():\n    print(\"Loading test data...\")\n    start_time = time.time()\n    x_test, y_test = process_file(test_dir, word_to_id, cat_to_id, config.seq_length)\n\n    session = tf.Session()\n    session.run(tf.global_variables_initializer())\n    saver = tf.train.Saver()\n    saver.restore(sess=session, save_path=save_path)  # 读取保存的模型\n\n    print('Testing...')\n    loss_test, acc_test = evaluate(session, x_test, y_test)\n    msg = 'Test Loss: {0:>6.2}, Test Acc: {1:>7.2%}'\n    print(msg.format(loss_test, acc_test))\n\n    batch_size = 128\n    data_len = len(x_test)\n    num_batch = int((data_len - 1) / batch_size) + 1\n\n    y_test_cls = np.argmax(y_test, 1)\n    y_pred_cls = np.zeros(shape=len(x_test), dtype=np.int32)  # 保存预测结果\n    for i in range(num_batch):  # 逐批次处理\n        start_id = i * batch_size\n        end_id = min((i + 1) * batch_size, data_len)\n        feed_dict = {\n            model.input_x: x_test[start_id:end_id],\n            model.keep_prob: 1.0\n        }\n        y_pred_cls[start_id:end_id] = session.run(model.y_pred_cls, feed_dict=feed_dict)\n\n    # 评估\n    print(\"Precision, Recall and F1-Score...\")\n    print(metrics.classification_report(y_test_cls, y_pred_cls, target_names=categories))\n\n    # 混淆矩阵\n    print(\"Confusion Matrix...\")\n    cm = metrics.confusion_matrix(y_test_cls, y_pred_cls)\n    print(cm)\n\n    time_dif = get_time_dif(start_time)\n    print(\"Time usage:\", time_dif)\n\n\nif __name__ == '__main__':\n    if len(sys.argv) != 2 or sys.argv[1] not in ['train', 'test']:\n        raise ValueError(\"\"\"usage: python run_rnn.py [train / test]\"\"\")\n\n    print('Configuring RNN model...')\n    config = TRNNConfig()\n    if not os.path.exists(vocab_dir):  # 如果不存在词汇表，重建\n        build_vocab(train_dir, vocab_dir, config.vocab_size)\n    categories, cat_to_id = read_category()\n    words, word_to_id = read_vocab(vocab_dir)\n    config.vocab_size = len(words)\n    model = TextRNN(config)\n\n    if sys.argv[1] == 'train':\n        train()\n    else:\n        test()\n"
        }
      ]
    }
  ]
}