{
  "metadata": {
    "timestamp": 1736559982781,
    "page": 774,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjc4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "pytorch/torchchat",
      "stars": 3458,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".ci",
          "type": "tree",
          "content": null
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.517578125,
          "content": "# Byte-compiled / optimized / DLL files\n__pycache__/\n*.py[cod]\n*$py.class\n\n# C extensions\n*.so\n\n.vscode\n.model-artifacts/\n.venv\n.torchchat\n\n# Build directories\nbuild/android/*\net-build/*\ntorchao-build/*\nrunner-et/cmake-out/*\nrunner-aoti/cmake-out/*\ncmake-out/\n\n# Example project Android Studio ignore\ntorchchat/edge/android/torchchat/.idea/*\n\n\n# pte files\n*.pte\n\n# debug / logging files\nsystem_info.txt\n\n# intermediate system file\n.DS_Store\n\n# build artifacts\ncheckpoints/\nexportedModels/\n\n# test script\n_torchchat_test_script.py\n"
        },
        {
          "name": ".gitmodules",
          "type": "blob",
          "size": 0.12890625,
          "content": "[submodule \"runner/third-party/tokenizers\"]\n\tpath = runner/third-party/tokenizers\n\turl = https://github.com/pytorch-labs/tokenizers\n"
        },
        {
          "name": ".lintrunner.toml",
          "type": "blob",
          "size": 1.3056640625,
          "content": "merge_base_with = \"origin/main\"\n\n[[linter]]\ncode = 'FLAKE8'\ninclude_patterns = ['**/*.py']\ncommand = [\n    'python3',\n    '-m',\n    'lintrunner_adapters',\n    'run',\n    'flake8_linter',\n    '--',\n    '@{{PATHSFILE}}'\n]\ninit_command = [\n    'python3',\n    '-m',\n    'lintrunner_adapters',\n    'run',\n    'pip_init',\n    '--dry-run={{DRYRUN}}',\n    '--requirement=install/requirements-lintrunner.txt',\n]\n\n# Black + usort\n[[linter]]\ncode = 'UFMT'\ninclude_patterns = [\n    '**/*.py',\n    '**/*.pyi',\n]\ncommand = [\n    'python3',\n    '-m',\n    'lintrunner_adapters',\n    'run',\n    'ufmt_linter',\n    '--',\n    '@{{PATHSFILE}}'\n]\ninit_command = [\n    'python3',\n    '-m',\n    'lintrunner_adapters',\n    'run',\n    'pip_init',\n    '--dry-run={{DRYRUN}}',\n    '--no-black-binary',\n    '--requirement=install/requirements-lintrunner.txt',\n]\nis_formatter = true\n\n#CLANGFORMAT\n[[linter]]\ncode = 'CLANGFORMAT'\ninclude_patterns = [\n    '**/*.h',\n    '**/*.cpp',\n]\ncommand = [\n    'python3',\n    '-m',\n    'lintrunner_adapters',\n    'run',\n    'clangformat_linter',\n    '--binary=clang-format',\n    '--fallback',\n    '--',\n    '@{{PATHSFILE}}'\n]\ninit_command = [\n    'python3',\n    '-m',\n    'lintrunner_adapters',\n    'run',\n    'pip_init',\n    '--dry-run={{DRYRUN}}',\n    '--requirement=install/requirements-lintrunner.txt',\n]\nis_formatter = true\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 0.7919921875,
          "content": "cmake_minimum_required(VERSION 3.24)\nset(CMAKE_CXX_STANDARD 17)\nIF(DEFINED ENV{TORCHCHAT_ROOT})\n    set(TORCHCHAT_ROOT $ENV{TORCHCHAT_ROOT})\nELSE()\n    set(TORCHCHAT_ROOT ${CMAKE_CURRENT_SOURCE_DIR}/..)\nENDIF()\n\nproject(Torchchat)\nset(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -Wno-attributes\")\n\n# include tokenizer\nadd_subdirectory(runner/third-party/tokenizers)\n\n# include et_run executable\ninclude(runner/et.cmake)\nif(TARGET et_run)\n    target_link_libraries(et_run PUBLIC tokenizers microkernels-prod)\n    target_include_directories(et_run PUBLIC runner/third-party/tokenizers/include)\nendif()\n\n# include aoti_run executable\ninclude(runner/aoti.cmake)\nif(TARGET aoti_run)\n    target_link_libraries(aoti_run tokenizers)\n    target_include_directories(aoti_run PUBLIC runner/third-party/tokenizers/include)\nendif()\n"
        },
        {
          "name": "CODE_OF_CONDUCT.md",
          "type": "blob",
          "size": 3.2646484375,
          "content": "# Code of Conduct\n\n## Our Pledge\n\nIn the interest of fostering an open and welcoming environment, we as\ncontributors and maintainers pledge to make participation in our project and\nour community a harassment-free experience for everyone, regardless of age, body\nsize, disability, ethnicity, sex characteristics, gender identity and expression,\nlevel of experience, education, socio-economic status, nationality, personal\nappearance, race, religion, or sexual identity and orientation.\n\n## Our Standards\n\nExamples of behavior that contributes to creating a positive environment\ninclude:\n\n* Using welcoming and inclusive language\n* Being respectful of differing viewpoints and experiences\n* Gracefully accepting constructive criticism\n* Focusing on what is best for the community\n* Showing empathy towards other community members\n\nExamples of unacceptable behavior by participants include:\n\n* The use of sexualized language or imagery and unwelcome sexual attention or\nadvances\n* Trolling, insulting/derogatory comments, and personal or political attacks\n* Public or private harassment\n* Publishing others' private information, such as a physical or electronic\naddress, without explicit permission\n* Other conduct which could reasonably be considered inappropriate in a\nprofessional setting\n\n## Our Responsibilities\n\nProject maintainers are responsible for clarifying the standards of acceptable\nbehavior and are expected to take appropriate and fair corrective action in\nresponse to any instances of unacceptable behavior.\n\nProject maintainers have the right and responsibility to remove, edit, or\nreject comments, commits, code, wiki edits, issues, and other contributions\nthat are not aligned to this Code of Conduct, or to ban temporarily or\npermanently any contributor for other behaviors that they deem inappropriate,\nthreatening, offensive, or harmful.\n\n## Scope\n\nThis Code of Conduct applies within all project spaces, and it also applies when\nan individual is representing the project or its community in public spaces.\nExamples of representing a project or community include using an official\nproject e-mail address, posting via an official social media account, or acting\nas an appointed representative at an online or offline event. Representation of\na project may be further defined and clarified by project maintainers.\n\n## Enforcement\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be\nreported by contacting the project team at <conduct@pytorch.org>. All\ncomplaints will be reviewed and investigated and will result in a response that\nis deemed necessary and appropriate to the circumstances. The project team is\nobligated to maintain confidentiality with regard to the reporter of an incident.\nFurther details of specific enforcement policies may be posted separately.\n\nProject maintainers who do not follow or enforce the Code of Conduct in good\nfaith may face temporary or permanent repercussions as determined by other\nmembers of the project's leadership.\n\n## Attribution\n\nThis Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4,\navailable at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html\n\n[homepage]: https://www.contributor-covenant.org\n\nFor answers to common questions about this code of conduct, see\nhttps://www.contributor-covenant.org/faq\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 1.6474609375,
          "content": "# Contributing to torchchat\nWe want to make contributing to this project as easy and transparent as\npossible.\n\n\n## Pull Requests\nWe actively welcome your pull requests.\n\n1. Fork the repo and create your branch from `main`.\n2. If you've added code that should be tested, add tests.\n3. If you've changed APIs, update the documentation.\n4. Ensure the test suite passes.\n5. Make sure your code is well-formatted using the repo linter. See \"Linting\" for details.\n6. If you haven't already, complete the Contributor License Agreement (\"CLA\").\n\n\n### Linting\nInstall the lintrunner dependencies from the requirements file.\n```\npip3 install -r install/requirements-lintrunner.txt\n```\n\nAfter making your changes locally, run the lintrunner and apply all suggestions to your changes.\nYou can do this from the top-level torchchat directory - it will apply suggestions only to files that\nyou have touched.\n```\nlintrunner -a\n```\n\n## Contributor License Agreement (\"CLA\")\nIn order to accept your pull request, we need you to submit a CLA. You only need\nto do this once to work on any of Meta's open source projects.\n\nComplete your CLA here: <https://code.facebook.com/cla>\n\n## Issues\nWe use GitHub issues to track public bugs. Please ensure your description is\nclear and has sufficient instructions to be able to reproduce the issue.\n\nMeta has a [bounty program](https://www.facebook.com/whitehat/) for the safe\ndisclosure of security bugs. In those cases, please go through the process\noutlined on that page and do not file a public issue.\n\n## License\nBy contributing to `torchchat`, you agree that your contributions will be licensed\nunder the LICENSE file in the root directory of this source tree.\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.455078125,
          "content": "BSD 3-Clause License\n\nCopyright (c) 2024 Meta\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this\n   list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\n   this list of conditions and the following disclaimer in the documentation\n   and/or other materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its\n   contributors may be used to endorse or promote products derived from\n   this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 29.7666015625,
          "content": "# Chat with LLMs Everywhere\n\ntorchchat is a small codebase showcasing the ability to run large language models (LLMs) seamlessly. With torchchat, you can run LLMs using Python, within your own (C/C++) application (desktop or server) and on iOS and Android.\n\n> [!IMPORTANT]\n> Update September 25, 2024: torchchat has multimodal support for **Llama3.2 11B**!!\n>\n> To try it out, finish the [Installation](#Installation) section below, then hop\n> over to our [multimodal guide](docs/multimodal.md) to learn more.\n\n\n## What can you do with torchchat?\n- [Run models via PyTorch / Python](#running-via-pytorch--python)\n  - [Chat](#chat)\n  - [Generate](#generate)\n  - [Run chat in the Browser](#browser)\n- [Run models on desktop/server without python](#desktopserver-execution)\n  - [Use AOT Inductor for faster execution](#aoti-aot-inductor)\n  - [Running in c++ using the runner](#run-using-our-c-runner)\n- [Run models on mobile](#mobile-execution)\n  - [Deploy and run on iOS](#deploy-and-run-on-ios)\n  - [Deploy and run on Android](#deploy-and-run-on-android)\n- [Evaluate a model](#eval)\n\n\n## Highlights\n\n- [[New!!] Multimodal Support for Llama 3.2 11B](docs/multimodal.md)\n- Command line interaction with popular LLMs such as Llama 3, Llama 2, Stories, Mistral and more\n- PyTorch-native execution with performance\n- Supports popular hardware and OS\n  - Linux (x86)\n  - Mac OS (M1/M2/M3)\n  - Android (Devices that support XNNPACK)\n  - iOS 17+ and 8+ Gb of RAM (iPhone 15 Pro+ or iPad with Apple Silicon)\n- Multiple data types including: float32, float16, bfloat16\n- Multiple quantization schemes\n- Multiple execution modes including: Python (Eager, Compile) or Native (AOT Inductor (AOTI), ExecuTorch)\n\n\n## Models\n\nThe following models are supported by torchchat and have associated\naliases.\n\n| Model | Mobile Friendly | Notes |\n|------------------|---|---------------------|\n|[meta-llama/Meta-Llama-3.2-3B-Instruct](https://huggingface.co/meta-llama/Llama-3.2-3B-Instruct)|✅|Tuned for `chat`. Alias to `llama3.2-3b`.|\n|[meta-llama/Meta-Llama-3.2-3B](https://huggingface.co/meta-llama/Llama-3.2-3B)|✅|Best for `generate`. Alias to `llama3.2-3b-base`.|\n|[meta-llama/Llama-Guard-3-1B](https://huggingface.co/meta-llama/Llama-Guard-3-1B)|✅|Tuned for classification. Alias to `llama3-1b-guard`.|\n|[meta-llama/Meta-Llama-3.2-1B-Instruct](https://huggingface.co/meta-llama/Llama-3.2-1B-Instruct)|✅|Tuned for `chat`. Alias to `llama3.2-1b`.|\n|[meta-llama/Meta-Llama-3.2-1B](https://huggingface.co/meta-llama/Llama-3.2-1B)|✅|Best for `generate`. Alias to `llama3.2-1b-base`.|\n|[meta-llama/Llama-3.2-11B-Vision-Instruct](https://huggingface.co/meta-llama/Llama-3.2-11B-Vision-Instruct)||Multimodal (Image + Text). Tuned for `chat`. Alias to `llama3.2-11B`.|\n|[meta-llama/Llama-3.2-11B-Vision](https://huggingface.co/meta-llama/Llama-3.2-11B-Vision)||Multimodal (Image + Text). Tuned for `generate`. Alias to `llama3.2-11B-base`.|\n|[meta-llama/Meta-Llama-3.1-8B-Instruct](https://huggingface.co/meta-llama/Meta-Llama-3.1-8B-Instruct)|✅|Tuned for `chat`. Alias to `llama3.1`.|\n|[meta-llama/Meta-Llama-3.1-8B](https://huggingface.co/meta-llama/Meta-Llama-3.1-8B)|✅|Best for `generate`. Alias to `llama3.1-base`.|\n|[meta-llama/Meta-Llama-3-8B-Instruct](https://huggingface.co/meta-llama/Meta-Llama-3-8B-Instruct)|✅|Tuned for `chat`. Alias to `llama3`.|\n|[meta-llama/Meta-Llama-3-8B](https://huggingface.co/meta-llama/Meta-Llama-3-8B)|✅|Best for `generate`. Alias to `llama3-base`.|\n|[meta-llama/Llama-2-7b-chat-hf](https://huggingface.co/meta-llama/Llama-2-7b-chat-hf)|✅|Tuned for `chat`. Alias to `llama2`.|\n|[meta-llama/Llama-2-13b-chat-hf](https://huggingface.co/meta-llama/Llama-2-13b-chat-hf)||Tuned for `chat`. Alias to `llama2-13b-chat`.|\n|[meta-llama/Llama-2-70b-chat-hf](https://huggingface.co/meta-llama/Llama-2-70b-chat-hf)||Tuned for `chat`. Alias to `llama2-70b-chat`.|\n|[meta-llama/Llama-2-7b-hf](https://huggingface.co/meta-llama/Llama-2-7b-hf)|✅|Best for `generate`. Alias to `llama2-base`.|\n|[meta-llama/CodeLlama-7b-Python-hf](https://huggingface.co/meta-llama/CodeLlama-7b-Python-hf)|✅|Tuned for Python and `generate`. Alias to `codellama`.|\n|[meta-llama/CodeLlama-34b-Python-hf](https://huggingface.co/meta-llama/CodeLlama-34b-Python-hf)|✅|Tuned for Python and `generate`. Alias to `codellama-34b`.|\n|[mistralai/Mistral-7B-v0.1](https://huggingface.co/mistralai/Mistral-7B-v0.1)|✅|Best for `generate`. Alias to `mistral-7b-v01-base`.|\n|[mistralai/Mistral-7B-Instruct-v0.1](https://huggingface.co/mistralai/Mistral-7B-Instruct-v0.1)|✅|Tuned for `chat`. Alias to `mistral-7b-v01-instruct`.|\n|[mistralai/Mistral-7B-Instruct-v0.2](https://huggingface.co/mistralai/Mistral-7B-Instruct-v0.2)|✅|Tuned for `chat`. Alias to `mistral`.|\n|[tinyllamas/stories15M](https://huggingface.co/karpathy/tinyllamas/tree/main)|✅|Toy model for `generate`. Alias to `stories15M`.|\n|[tinyllamas/stories42M](https://huggingface.co/karpathy/tinyllamas/tree/main)|✅|Toy model for `generate`. Alias to `stories42M`.|\n|[tinyllamas/stories110M](https://huggingface.co/karpathy/tinyllamas/tree/main)|✅|Toy model for `generate`. Alias to `stories110M`.|\n|[openlm-research/open_llama_7b](https://huggingface.co/openlm-research/open_llama_7b)|✅|Best for `generate`. Alias to `open-llama`.|\n| [ibm-granite/granite-3b-code-instruct-128k](https://huggingface.co/ibm-granite/granite-3b-code-instruct-128k) |✅| Alias to `granite-code` and `granite-code-3b`.|\n| [ibm-granite/granite-8b-code-instruct-128k](https://huggingface.co/ibm-granite/granite-8b-code-instruct-128k) |✅| Alias to `granite-code-8b`.|\n| [ibm-granite/granite-3.0-2b-instruct](https://huggingface.co/ibm-granite/granite-3.0-2b-instruct) |✅| Alias to `granite3-2b` and `granite3`.|\n| [ibm-granite/granite-3.0-8b-instruct](https://huggingface.co/ibm-granite/granite-3.0-8b-instruct) |✅| Alias to `granite3-8b`.|\n| [ibm-granite/granite-3.1-2b-instruct](https://huggingface.co/ibm-granite/granite-3.1-2b-instruct) |✅| Alias to `granite3.1-2b` and `granite3.1`.|\n| [ibm-granite/granite-3.1-8b-instruct](https://huggingface.co/ibm-granite/granite-3.1-8b-instruct) |✅| Alias to `granite3.1-8b`.|\n\n\n## Installation\nThe following steps require that you have [Python 3.10](https://www.python.org/downloads/release/python-3100/) installed.\n\n> [!TIP]\n> torchchat uses the latest changes from various PyTorch projects so it's highly recommended that you use a venv (by using the commands below) or CONDA.\n\n[skip default]: begin\n```bash\ngit clone https://github.com/pytorch/torchchat.git\ncd torchchat\npython3 -m venv .venv\nsource .venv/bin/activate\n./install/install_requirements.sh\n```\n[skip default]: end\n\n[shell default]: ./install/install_requirements.sh\n\n## Commands\n\nThe interfaces of torchchat are leveraged through **Python Commands** and **Native Runners**. While the Python Commands are enumerable in the --help menu, the latter are explored in their respective sections.\n\n```bash\npython3 torchchat.py --help\n```\n\n[skip default]: begin\n\n```bash\n# Output\nusage: torchchat [-h] {chat,browser,generate,export,eval,download,list,remove,where,server} ...\n\npositional arguments:\n  {chat,browser,generate,export,eval,download,list,remove,where,server}\n                        The specific command to run\n    chat                Chat interactively with a model via the CLI\n    generate            Generate responses from a model given a prompt\n    browser             Chat interactively with a model in a locally hosted browser\n    export              Export a model artifact to AOT Inductor or ExecuTorch\n    download            Download model artifacts\n    list                List all supported models\n    remove              Remove downloaded model artifacts\n    where               Return directory containing downloaded model artifacts\n    server              [WIP] Starts a locally hosted REST server for model interaction\n    eval                Evaluate a model via lm-eval\n\noptions:\n  -h, --help            show this help message and exit\n```\n\n[skip default]: end\n\n__Python Inference__ (chat, generate, browser, server)\n* These commands represent different flavors of performing model inference in a Python enviroment.\n* Models are constructed either from CLI args or from loading exported artifacts.\n\n__Exporting__ (export)\n* This command generates model artifacts that are consumed by Python Inference or Native Runners.\n* More information is provided in the [AOT Inductor](https://github.com/pytorch/torchchat?tab=readme-ov-file#aoti-aot-inductor) and [ExecuTorch](https://github.com/pytorch/torchchat?tab=readme-ov-file#export-for-mobile) sections.\n\n__Inventory Management__ (download, list, remove, where)\n* These commands are used to manage and download models.\n* More information is provided in the [Download Weights](https://github.com/pytorch/torchchat?tab=readme-ov-file#download-weights) section.\n\n__Evaluation__ (eval)\n* This command test model fidelity via EleutherAI's [lm_evaluation_harness](https://github.com/EleutherAI/lm-evaluation-harness).\n* More information is provided in the [Evaluation](https://github.com/pytorch/torchchat?tab=readme-ov-file#eval) section.\n\n## Download Weights\nMost models use Hugging Face as the distribution channel, so you will need to create a Hugging Face account.\nCreate a Hugging Face user access token [as documented here](https://huggingface.co/docs/hub/en/security-tokens) with the `write` role.\n\nLog into Hugging Face:\n\n[prefix default]: HF_TOKEN=\"${SECRET_HF_TOKEN_PERIODIC}\"\n\n```\nhuggingface-cli login\n```\n\nTake a look at the available models:\n\n```bash\npython3 torchchat.py list\n```\n\nThen download one for testing (this README uses llama3.1)\n```\npython3 torchchat.py download llama3.1\n```\n\n> [!NOTE]\n> This command may prompt you to request access to Llama 3 via\n> Hugging Face, if you do not already have access. Simply follow the\n> prompts and re-run the command when access is granted.*\n\n\n<details>\n<summary>Additional Model Inventory Management Commands</summary>\n\n### Where\nThis subcommand shows the location of a particular model.\n```bash\npython3 torchchat.py where llama3.1\n```\nThis is useful in scripts when you do not want to hard-code paths\n\n\n### Remove\nThis subcommand removes the specified model\n```bash\npython3 torchchat.py remove llama3.1\n```\n\nMore information about these commands can be found by adding the `--help` option.\n\n</details>\n\n\n## Running via PyTorch / Python\n\nThe simplest way to run a model in PyTorch is via [eager execution](https://pytorch.org/blog/optimizing-production-pytorch-performance-with-graph-transformations/).\nThis is the default execution mode for both PyTorch and torchchat. It performs inference\nwithout creating exporting artifacts or using a separate runner.\n\nThe model used for inference can also be configured and tailored to specific needs\n(compilation, quantization, etc.). See the [customization guide](docs/model_customization.md) for the options supported by torchchat.\n\n> [!TIP]\n> For more information about these commands, please refer to the `--help` menu.\n\n### Chat\nThis mode allows you to chat with an LLM in an interactive fashion.\n\n[skip default]: begin\n```bash\npython3 torchchat.py chat llama3.1\n```\n[skip default]: end\n\n### Generate\nThis mode generates text based on an input prompt.\n```bash\npython3 torchchat.py generate llama3.1 --prompt \"write me a story about a boy and his bear\"\n```\n\n\n### Server\nThis mode exposes a REST API for interacting with a model.\nThe server follows the [OpenAI API specification](https://platform.openai.com/docs/api-reference/chat) for chat completions.\n\nTo test out the REST API, **you'll need 2 terminals**: one to host the server, and one to send the request.\nIn one terminal, start the server\n\n[skip default]: begin\n\n```bash\npython3 torchchat.py server llama3.1\n```\n[skip default]: end\n\n[shell default]: python3 torchchat.py server llama3.1 & server_pid=$! ; sleep 90 # wait for server to be ready to accept requests\n\nIn another terminal, query the server using `curl`. Depending on the model configuration, this query might take a few minutes to respond.\n\n> [!NOTE]\n> Since this feature is under active development, not every parameter is consumed. See api/api.py for details on\n> which request parameters are implemented. If you encounter any issues, please comment on the [tracking Github issue](https://github.com/pytorch/torchchat/issues/973).\n\n<details>\n<summary>Example Query</summary>\n\nSetting `stream` to \"true\" in the request emits a response in chunks. If `stream` is unset or not \"true\", then the client will await the full response from the server.\n\n**Example Input + Output**\n\n```\ncurl http://127.0.0.1:5000/v1/chat/completions \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"model\": \"llama3.1\",\n    \"stream\": \"true\",\n    \"max_tokens\": 200,\n    \"messages\": [\n      {\n        \"role\": \"system\",\n        \"content\": \"You are a helpful assistant.\"\n      },\n      {\n        \"role\": \"user\",\n        \"content\": \"Hello!\"\n      }\n    ]\n  }'\n```\n[skip default]: begin\n```\n{\"response\":\" I'm a software developer with a passion for building innovative and user-friendly applications. I have experience in developing web and mobile applications using various technologies such as Java, Python, and JavaScript. I'm always looking for new challenges and opportunities to learn and grow as a developer.\\n\\nIn my free time, I enjoy reading books on computer science and programming, as well as experimenting with new technologies and techniques. I'm also interested in machine learning and artificial intelligence, and I'm always looking for ways to apply these concepts to real-world problems.\\n\\nI'm excited to be a part of the developer community and to have the opportunity to share my knowledge and experience with others. I'm always happy to help with any questions or problems you may have, and I'm looking forward to learning from you as well.\\n\\nThank you for visiting my profile! I hope you find my information helpful and interesting. If you have any questions or would like to discuss any topics, please feel free to reach out to me. I\"}\n```\n\n[skip default]: end\n\n[shell default]: kill ${server_pid}\n\n</details>\n\n### Browser\nThis command opens a basic browser interface for local chat by querying a local server.\n\nFirst, follow the steps in the Server section above to start a local server. Then, in another terminal, launch the interface. Running the following will open a tab in your browser.\n\n[skip default]: begin\n\n```\nstreamlit run torchchat/usages/browser.py\n```\n\n[skip default]: end\n\nUse the \"Max Response Tokens\" slider to limit the maximum number of tokens generated by the model for each response. Click the \"Reset Chat\" button to remove the message history and start a fresh chat.\n\n\n## Desktop/Server Execution\n\n### AOTI (AOT Inductor)\n[AOTI](https://pytorch.org/blog/pytorch2-2/) compiles models before execution\nfor faster inference. The process creates a zipped PT2 file containing all the\nartifacts generated by AOTInductor, and a\n[.so](https://en.wikipedia.org/wiki/Shared_library) file with the runnable\ncontents that is then loaded for inference. This can be done with both Python\nand C++ enviroments.\n\nThe following example exports and executes the Llama3.1 8B Instruct\nmodel.  The first command compiles and performs the actual export.\n\n```bash\npython3 torchchat.py export llama3.1 --output-aoti-package-path exportedModels/llama3_1_artifacts.pt2\n```\n\n> [!NOTE]\n> If your machine has cuda add this flag for performance\n`--quantize torchchat/quant_config/cuda.json` when exporting.\n\nFor more details on quantization and what settings to use for your use\ncase visit our [customization guide](docs/model_customization.md).\n\n### Run in a Python Environment\n\nTo run in a python enviroment, use the generate subcommand like before, but include the pt2 file.\n\n```bash\npython3 torchchat.py generate llama3.1 --aoti-package-path exportedModels/llama3_1_artifacts.pt2 --prompt \"Hello my name is\"\n```\n\n\n### Run using our C++ Runner\n\nTo run in a C++ enviroment, we need to build the runner binary.\n```bash\ntorchchat/utils/scripts/build_native.sh aoti\n```\n\nThen run the compiled executable, with the pt2.\n```bash\ncmake-out/aoti_run exportedModels/llama3_1_artifacts.pt2 -z `python3 torchchat.py where llama3.1`/tokenizer.model -l 3 -i \"Once upon a time\"\n```\n\n## Mobile Execution\n\n[ExecuTorch](https://github.com/pytorch/executorch) enables you to optimize your model for execution on a\nmobile or embedded device.\n\n### Set Up ExecuTorch\n\nBefore running any commands in torchchat that require ExecuTorch, you\nmust first install ExecuTorch.\n\nTo install ExecuTorch, run the following commands.  This will download the\nExecuTorch repo to ./et-build/src and install various ExecuTorch libraries to\n./et-build/install.\n\n> [!IMPORTANT]\n> The following commands should be run from the torchchat root directory.\n\n```\nexport TORCHCHAT_ROOT=${PWD}\n./torchchat/utils/scripts/install_et.sh\n```\n\n\n### Export for mobile\nSimilar to AOTI, to deploy onto device, we first export the PTE artifact, then we load the artifact for inference.\n\nThe following example uses the Llama3.1 8B Instruct model.\n```\n# Export\npython3 torchchat.py export llama3.1 --quantize torchchat/quant_config/mobile.json --output-pte-path llama3.1.pte\n```\n\n> [!NOTE]\n> We use `--quantize torchchat/quant_config/mobile.json` to quantize the\nllama3.1 model to reduce model size and improve performance for\non-device use cases.\n\nFor more details on quantization and what settings to use for your use\ncase visit our [customization guide](docs/model_customization.md).\n\n### Deploy and run on Desktop\n\nWhile ExecuTorch does not focus on desktop inference, it is capable\nof doing so. This is handy for testing out PTE\nmodels without sending them to a physical device.\n\nSpecifically, there are 2 ways of doing so: Pure Python and via a Runner\n\n<details>\n<summary>Deploying via Python</summary>\n\n```\n# Execute\npython3 torchchat.py generate llama3.1 --pte-path llama3.1.pte --prompt \"Hello my name is\"\n```\n\n</details>\n\n\n<details>\n<summary>Deploying via the c++ Runner</summary>\n\nBuild the runner\n```bash\ntorchchat/utils/scripts/build_native.sh et\n```\n\nExecute using the runner\n```bash\ncmake-out/et_run llama3.1.pte -z `python3 torchchat.py where llama3.1`/tokenizer.model -l 3 -i \"Once upon a time\"\n```\n\n</details>\n\n\n[end default]: end\n\n### Deploy and run on iOS\n\nThe following assumes you've completed the steps for [Setting up ExecuTorch](#set-up-executorch).\n\n<details>\n<summary>Deploying with Xcode</summary>\n\n#### Requirements\n- [Xcode](https://apps.apple.com/us/app/xcode/id497799835?mt=12/) 15.0 or later\n- [Cmake](https://cmake.org/download/) 3.19 or later\n  - Download and open the macOS `.dmg` installer and move the Cmake app to `/Applications` folder.\n  - Install Cmake command line tools: `sudo /Applications/CMake.app/Contents/bin/cmake-gui --install`\n- A development provisioning profile with the [`increased-memory-limit`](https://developer.apple.com/documentation/bundleresources/entitlements/com_apple_developer_kernel_increased-memory-limit) entitlement.\n\n\n#### Steps\n\n1. Open the Xcode project:\n    ```bash\n    open et-build/src/executorch/examples/demo-apps/apple_ios/LLaMA/LLaMA.xcodeproj\n    ```\n\n    > Note: If you're running into any issues related to package dependencies, close Xcode, clean some of the caches and/or the build products, and open the Xcode project again:\n    > ```bash\n    > rm -rf \\\n    >   ~/Library/org.swift.swiftpm \\\n    >   ~/Library/Caches/org.swift.swiftpm \\\n    >   ~/Library/Caches/com.apple.dt.Xcode \\\n    >   ~/Library/Developer/Xcode/DerivedData\n    > ```\n2. Click the Play button to launch the app in the Simulator.\n\n3. To run on a device, ensure you have it set up for development and a provisioning profile with the `increased-memory-limit` entitlement. Update the app's bundle identifier to match your provisioning profile with the required capability.\n\n4. After successfully launching the app, copy the exported ExecuTorch model (`.pte`) and tokenizer (`.model`) files to the iLLaMA folder. You can find the model file called `llama3.1.pte` in the current `torchchat` directory and the tokenizer file at `$(python3 torchchat.py where llama3.1)/tokenizer.model` path.\n\n    - **For the Simulator:** Drag and drop both files onto the Simulator window and save them in the `On My iPhone > iLLaMA` folder.\n    - **For a device:** Open a separate Finder window, navigate to the Files tab, drag and drop both files into the iLLaMA folder, and wait for the copying to finish.\n\n5. Follow the app's UI guidelines to select the model and tokenizer files from the local filesystem and issue a prompt.\n\n*Click the image below to see it in action!*\n\n<p align=\"center\">\n<a href=\"https://pytorch.org/executorch/main/_static/img/llama_ios_app.mp4\">\n  <img src=\"https://pytorch.org/executorch/main/_static/img/llama_ios_app.png\" width=\"600\" alt=\"iOS app running a LlaMA model\">\n</a>\n</p>\n</details>\n\n\n### Deploy and run on Android\n\nThe following assumes you've completed the steps for [Setting up ExecuTorch](#set-up-executorch).\n\n<details>\n<summary>Approach 1 (Recommended): Android Studio</summary>\n\n#### Requirements\n- Android Studio\n- [Java 17](https://developer.android.com/build/jdks)\n- [Android SDK 34](https://developer.android.com/about/versions/14/setup-sdk)\n- [adb](https://developer.android.com/tools/adb)\n\n\n#### Steps\n\n1. Download the AAR file, which contains the Java library and corresponding JNI library, to build and run the app.\n\n   - [executorch.aar](https://ossci-android.s3.amazonaws.com/executorch/release/executorch-241002/executorch.aar) ([sha256sums](https://ossci-android.s3.amazonaws.com/executorch/release/executorch-241002/executorch.aar.sha256sums))\n\n2. Move the downloaded AAR file to `torchchat/edge/android/torchchat/app/libs/`. You may need to create directory `torchchat/edge/android/torchchat/app/libs/` if it does not exist.\n\n3. Push the model and tokenizer file to your device. You can find the model file called `llama3.1.pte` in the current `torchchat` directory and the tokenizer file at `$(python3 torchchat.py where llama3.1)/tokenizer.model` path.\n    ```\n    adb shell mkdir -p /data/local/tmp/llama\n    adb push <model.pte> /data/local/tmp/llama\n    adb push <tokenizer.model or tokenizer.bin> /data/local/tmp/llama\n    ```\n\n4. Use Android Studio to open the torchchat app skeleton, located at `torchchat/edge/android/torchchat`.\n\n5. Click the Play button (^R) to launch it to emulator/device.\n\n    - We recommend using a device with at least 12GB RAM and 20GB storage.\n    - If using an emulated device, refer to [this post](https://stackoverflow.com/questions/45517553/cant-change-the-ram-size-in-avd-manager-android-studio) on how to set the RAM.\n\n6. Follow the app's UI guidelines to pick the model and tokenizer files from the local filesystem. Then issue a prompt.\n\n**Note:** The AAR file listed in Step 1 has the tiktoken and sentensepiece tokenizer. To tweak or use a custom tokenizer and runtime, modify the ExecuTorch code\nand use [this script](https://github.com/pytorch/executorch/blob/main/build/build_android_llm_demo.sh) to build the AAR library.\n\n<p align=\"center\">\n    <img src=\"https://pytorch.org/executorch/main/_static/img/chat.png\" width=\"600\" alt=\"Android app running a LlaMA model\">\n</p>\n\n\n\n</details>\n<details>\n<summary>Approach 2: E2E Script</summary>\n\nAlternatively, you can run `torchchat/utils/scripts/android_example.sh` which sets up Java, Android SDK Manager, Android SDK, Android emulator (if no physical device is found), builds the app, and launches it for you. It can be used if you don't have a GUI.\n\n```\nexport TORCHCHAT_ROOT=$(pwd)\nsh torchchat/utils/scripts/android_example.sh\n```\n\n</details>\n\n## Eval\n\n**Note: This feature is still a work in progress and not all features are working**\n\nUses the lm_eval library to evaluate model accuracy on a variety of\ntasks. Defaults to wikitext and can be manually controlled using the\ntasks and limit args. See [Evaluation](torchchat/utils/docs/evaluation.md)\n\n**Examples**\n\nEager mode:\n```\npython3 torchchat.py eval llama3.1 --dtype fp32 --limit 5\n```\n\nTo test the perplexity for a lowered or quantized model, pass it in\nthe same way you would to generate:\n\n```\npython3 torchchat.py eval llama3.1 --pte-path llama3.1.pte --limit 5\n```\n\n## Design Principles\n\ntorchchat embodies PyTorch’s design philosophy [details](https://pytorch.org/docs/stable/community/design.html), especially \"usability over everything else\".\n\n### Native PyTorch\n\ntorchchat is a native-PyTorch library. While we provide integrations with the surrounding ecosystem (eg: Hugging Face models, etc), all of the core functionality is written in PyTorch.\n\n### Simplicity and Extensibility\n\ntorchchat is designed to be easy to understand, use and extend.\n\n- Composition over implementation inheritance - layers of inheritance for code re-use makes the code hard to read and extend\n- No training frameworks - explicitly outlining the training logic makes it easy to extend for custom use cases\n- Code duplication is preferred over unnecessary abstractions\n- Modular building blocks over monolithic components\n\n### Correctness\n\ntorchchat provides well-tested components with a high-bar on correctness.\nWe provide\n\n- Extensive unit-tests to ensure things operate as they should\n\n## Community Contributions\n\nWe really value our community and the contributions made by our wonderful users. We'll use this section to call out some of these contributions! If you'd like to help out as well, please see the [CONTRIBUTING](CONTRIBUTING.md) guide.\n\nTo connect with us and other community members, we invite you to join our Slack community by filling out this [form](https://docs.google.com/forms/d/e/1FAIpQLSeADnUNW36fjKjYzyHDOzEB_abKQE9b6gqqW9NXse6O0MWh0A/viewform). Once you've joined, you can:\n* Head to the `#torchchat-general` channel for general questions, discussion, and community support.\n* Join the `#torchchat-contributors` channel if you're interested in contributing directly to project development.\n\nLooking forward to discussing with you about torchchat future!\n\n## Troubleshooting\n\nA section of commonly encountered setup errors/exceptions. If this section doesn't contain your situation, check the GitHub [issues](https://github.com/pytorch/torchchat/issues)\n\n### Model Access\n\n**Access to model is restricted and you are not in the authorized list**\n\nSome models require an additional step to access. Follow the\nlink provided in the error to get access.\n\n### Installing ExecuTorch\n\n**Failed Building Wheel**\n\nIf `./torchchat/utils/scripts/install_et.sh` fails with an error like `Building wheel for executorch (pyproject.toml) did not run successfully` It's possible that it's linking to an older version of pytorch installed some other way like via homebrew. You can break the link by uninstalling other versions such as `brew uninstall pytorch` Note: You may break something that depends on this, so be aware.\n\n**CERTIFICATE_VERIFY_FAILED**\n\nRun `pip install --upgrade certifi`.\n\n## Filing Issues\n\nIf you encounter bugs or difficulty using torchchat, please file an GitHub [issue](https://github.com/pytorch/torchchat/issues).\n\nPlease include the exact command you ran and the output of that command.\nAlso, run this script and include the output saved to `system_info.txt` so that we can better debug your issue.\n\n```\n(echo \"Operating System Information\"; uname -a; echo \"\"; cat /etc/os-release; echo \"\"; echo \"Python Version\"; python --version || python3 --version; echo \"\"; echo \"PIP Version\"; pip --version || pip3 --version; echo \"\"; echo \"Installed Packages\"; pip freeze || pip3 freeze; echo \"\"; echo \"PyTorch Version\"; python -c \"import torch; print(torch.__version__)\" || python3 -c \"import torch; print(torch.__version__)\"; echo \"\"; echo \"Collection Complete\") > system_info.txt\n```\n\n## Disclaimer\nThe torchchat Repository Content is provided without any guarantees\nabout performance or compatibility. In particular, torchchat makes\navailable model architectures written in Python for PyTorch that may\nnot perform in the same manner or meet the same standards as the\noriginal versions of those models. When using the torchchat Repository\nContent, including any model architectures, you are solely responsible\nfor determining the appropriateness of using or redistributing the\ntorchchat Repository Content and assume any risks associated with your\nuse of the torchchat Repository Content or any models, outputs, or\nresults, both alone and in combination with any other\ntechnologies. Additionally, you may have other legal obligations that\ngovern your use of other content, such as the terms of service for\nthird-party models, weights, data, or other technologies, and you are\nsolely responsible for complying with all such obligations.\n\n\n## Acknowledgements\nThank you to the community for all the\nawesome libraries and tools you've built around local LLM inference.\n\n* Georgi Gerganov and his [GGML](https://github.com/ggerganov/ggml)\n  project shining a spotlight on community-based enablement and\n  inspiring so many other projects.\n\n* Andrej Karpathy and his\n  [llama2.c](https://github.com/karpathy/llama2.c) project.  So many\n  great (and simple!) ideas in llama2.c that we have directly adopted\n  (both ideas and code) from his repo.  You can never go wrong by\n  following Andrej's work.\n\n* Michael Gschwind, Bert Maher, Scott Wolchok, Bin Bao, Chen Yang,\n  Huamin Li and Mu-Chu Li who built the first version of nanogpt (`DSOGPT`)\n  with AOT Inductor proving that AOTI can be used to build efficient\n  LLMs, and DSOs are a viable distribution format for models.\n  [nanoGPT](https://github.com/karpathy/nanoGPT).\n\n* Bert Maher and his\n  [llama2.so](https://github.com/bertmaher/llama2.so), which built on\n  Andrej's llama2.c and on DSOGPT to close the loop on Llama models\n  with AOTInductor.\n\n* Christian Puhrsch, Horace He, Joe Isaacson and many more for their\n  many contributions in Accelerating GenAI models in the *\"Anything,\n  Fast!\"* pytorch.org blogs, and, in particular, Horace He for [GPT,\n  Fast!](https://github.com/pytorch-labs/gpt-fast), which we have\n  directly adopted (both ideas and code) from his repo.\n\n\n## License\n\ntorchchat is released under the [BSD 3 license](LICENSE). (Additional\ncode in this distribution is covered by the MIT and Apache Open Source\nlicenses.) However, you may have other legal obligations that govern\nyour use of content, such as the terms of service for third-party\nmodels.\n"
        },
        {
          "name": "assets",
          "type": "tree",
          "content": null
        },
        {
          "name": "dist_run.py",
          "type": "blob",
          "size": 22.0029296875,
          "content": "# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\n# Example run command:\n# torchrun --nproc-per-node 4 dist_run.py llama2-7b-chat --pp 2\n# torchrun --nproc-per-node 4 dist_run.py llama3 --pp 2\n\nimport argparse\nimport os\nfrom enum import auto, Enum\nfrom pathlib import Path\nfrom types import SimpleNamespace\nfrom typing import Any, Dict, List, Optional, Tuple\n\nimport torch\nimport torch.distributed as dist\nfrom torch.distributed.pipelining import PipelineStage, ScheduleGPipe\nfrom torchchat.cli.builder import _initialize_tokenizer, TokenizerArgs\n\n# TODO - these are not distributed specific, consider moving to new package\nfrom torchchat.distributed.checkpoint_utils import (\n    get_hf_config_file,\n    load_weights_from_hf_format,\n    load_weights_from_torchchat_format,\n)\n\nfrom torchchat.distributed.logging_utils import SingletonLogger\nfrom torchchat.distributed.utils import (\n    bytes_to_readable,\n    Color as color,\n    CUDATrackTime,\n    get_module_size,\n    get_num_params,\n    GPUMemoryMonitor,\n)\nfrom torchchat.model import ModelArgs, Transformer, TransformerArgs\nfrom torchchat.utils.build_utils import set_precision\n\ntry:\n    from tokenizer.tiktoken import Tokenizer as TiktokenTokenizer\nexcept ImportError:\n    TiktokenTokenizer = None\ntry:\n    from sentencepiece import SentencePieceProcessor\nexcept ImportError:\n    SentencePieceProcessor = None\n\n\nlogger = SingletonLogger.get_logger()\n_tokenizer_type = None  # global variable to store the tokenizer type\n\n# Using model name to identify the model to load, for example \"llama2-7b-chat\".\n# You can change it to other values listed below.\n# For details on the name-to-distribution mapping, see README.md or models.json.\n\n# Name : HF distribution name, dtype, and model dimension\nNAME_TO_DISTRIBUTION_AND_DTYPE = {\n    \"llama2-7b-chat\": (\"meta-llama/Llama-2-7b-chat-hf\", torch.float16, 4096),\n    \"llama3\": (\"meta-llama/Meta-Llama-3-8B-Instruct\", torch.bfloat16, 4096),\n    \"llama3-70b\": (\"meta-llama/Meta-Llama-3-70B-Instruct\", torch.bfloat16, 8192),\n}\n\n\nclass TokenizerType(Enum):\n    Tiktoken = auto()\n    SentencePiece = auto()\n\n\ndef _init_distributed():\n    dist.init_process_group(\"nccl\")\n    rank = dist.get_rank()\n    world_size = dist.get_world_size()\n    # Assuming same number of GPUs per node\n    torch.cuda.set_device(rank % torch.cuda.device_count())\n    return rank, world_size\n\n\ndef _create_device_mesh(mesh_dimensions):\n    return dist.init_device_mesh(\"cuda\", mesh_dimensions, mesh_dim_names=(\"pp\", \"tp\"))\n\n\ndef dict_to_args(dictionary: Dict[str, Any]) -> SimpleNamespace:\n    return SimpleNamespace(**dictionary)\n\n\ndef _build_chat_tokenizer(\n    model_name: str,\n    model_base_name: Optional[str] = None,\n) -> SentencePieceProcessor | TiktokenTokenizer:\n    \"\"\"Builds a tokenizer for the given model name, and sets the global tokenizer type variable\"\"\"\n\n    global _tokenizer_type\n\n    # Try to infer the model base name from the model name:\n    # e.g. \"llama2-7b-chat\" -> \"llama2\"\n    if model_base_name is None:\n        model_base_name = model_name.split(\"-\")[0]\n        logger.info(\n            f\"Using model base name '{model_base_name}' to build tokenizer. \"\n            \"If not found, please specify it using the `model_base_name` argument.\"\n        )\n\n    # Create base args for tokenizer\n    default_model_dir = Path(\n        os.getenv(\"TORCHCHAT_MODELDIR\", \"~/.torchchat/model-cache\")\n    ).expanduser()\n\n    tokenconfig = {\n        \"model_directory\": default_model_dir,\n        \"model\": model_base_name,\n        \"tokenizer_path\": None,\n    }\n    args = dict_to_args(tokenconfig)\n    tokenizer_args = TokenizerArgs.from_args(args)\n    tokenizer = _initialize_tokenizer(tokenizer_args)\n    assert tokenizer is not None, f\"Failed to get tokenizer using {tokenconfig=}\"\n    logger.info(\n        f\"using tokenizer = {tokenizer.__class__.__module__}.{tokenizer.__class__.__name__}\"\n    )\n    # set global variable _tokenizer_type\n    if isinstance(tokenizer, TiktokenTokenizer):\n        _tokenizer_type = TokenizerType.Tiktoken\n    elif isinstance(tokenizer, SentencePieceProcessor):\n        _tokenizer_type = TokenizerType.SentencePiece\n    else:\n        raise ValueError(f\"Unknown tokenizer type: {tokenizer.__class__}\")\n\n    logger.info(f\"tokenizer type = {_tokenizer_type}\")\n    return tokenizer\n\n\ndef _load_model_weights(\n    stage_module: torch.nn.Module,\n    distribution: str,\n    device: torch.device,\n    model_config: ModelArgs,\n    chpt_from: str,\n):\n    \"\"\"Load the weights from the safetensor file(s) into the model stage.\n    Model config is needed b/c we permute wq and wk weights based on attn heads.\n\n    Args:\n        stage_module (torch.nn.Module): The model stage to load the weights into.\n        distribution (str): The distribution name, e.g. \"meta-llama/Meta-Llama-3-8B-Instruct\".\n        device (torch.device): The device to load the weights onto.\n        model_config (ModelArgs): The model config.\n        chpt_from (str): The checkpoint format to load the weights from, e.g. \"torchchat\" or \"hf\".\n    \"\"\"\n    if chpt_from == \"hf\":\n        # This format stands for: index file + multiple binary files\n        load_weights_from_hf_format(stage_module, distribution, device, model_config)\n    elif chpt_from == \"torchchat\":\n        # This format stands for:\n        # single binary file, OR\n        # multiple binary files without index files.\n        load_weights_from_torchchat_format(\n            stage_module, distribution, device, model_config\n        )\n    else:\n        raise ValueError(f\"Unknown checkpoint format: {chpt_from}\")\n\n\ndef _encode_strings(\n    strings: List[str],\n    tokenizer,\n    bos: bool,\n    device: torch.device,\n    dtype=torch.int64,\n) -> List[torch.Tensor]:\n    \"\"\"Encode a list of prompt strings into a list of tensor token ids.\"\"\"\n    encoded_list = []\n    for string in strings:\n        tokens = tokenizer.encode(string)\n        if bos:\n            tokens = [tokenizer.bos_id()] + tokens\n        encoded_list.append(torch.tensor(tokens, dtype=dtype, device=device))\n    return encoded_list\n\n\ndef _create_padded_prompts(\n    input_ids_list: List[torch.Tensor],\n    tokenizer,\n    seqlen: int,\n    start_pos: int,\n    device: torch.device,\n    pad_token_id: Optional[int] = None,\n) -> Tuple[torch.Tensor, List[int]]:\n    \"\"\"\n    Create a padded tensor for multiple encoded input prompts.\n\n    Returns:\n        Tuple[torch.Tensor, List[int]]: A tuple containing the padded tensor and a list of prompt lengths.\n    \"\"\"\n    pad_token_id = pad_token_id if pad_token_id is not None else tokenizer.eos_id()\n\n    # Find the maximum prompt length\n    max_prompt_len = max(ids.size(0) for ids in input_ids_list)\n\n    # Calculate the buffer size\n    max_new_tokens = max(0, min(seqlen - start_pos, seqlen - max_prompt_len))\n    token_buffer_size = max_prompt_len + max_new_tokens\n\n    # Create the padded batch tensor\n    batch_size = len(input_ids_list)\n    batch_seq = torch.full(\n        (batch_size, token_buffer_size), pad_token_id, dtype=torch.int64, device=device\n    )\n\n    prompt_lengths = []\n    for i, input_ids in enumerate(input_ids_list):\n        prompt_len = input_ids.size(0)\n        batch_seq[i, :prompt_len] = input_ids\n        prompt_lengths.append(prompt_len)\n\n    return batch_seq, prompt_lengths\n\n\ndef _batch_decode_next_tokens(\n    output: torch.Tensor,\n    pos: List[int],\n    step: int = -1,\n    temperature: float = 1.0,\n    topk: int = 10,\n) -> torch.Tensor:\n    \"\"\"\n    Decode the next token for each prompt in the batch. Adds temperature option for non-deterministic decoding.\n\n    Args:\n        output (torch.Tensor): The output tensor to decode.\n        pos (List[int]): The positions of the `output` to decode in the sequence length dimension.\n        step (int): Step indicator. If -1, use positions from `pos`. Otherwise, use the first token.\n        temperature (float): Sampling temperature for non-deterministic decoding.\n\n    Returns:\n        torch.Tensor: Decoded token ids.\n    \"\"\"\n    batch_size, seq_len, vocab_size = output.shape\n\n    if step != -1:\n        # `pos` is not provided, so we can use the first token\n        next_token_logits = output[:, 0, :]\n    else:\n        # get the logits for each prompt at the specified positions\n        next_token_logits = output[torch.arange(batch_size), torch.tensor(pos) - 1]\n\n    if temperature != 1.0:\n        next_token_logits = next_token_logits / temperature\n\n    # Uses top-k sampling if temperature is not 1.0, otherwise use argmax\n    if temperature != 1.0:\n        top_k = min(topk, vocab_size)  # Ensure top-k is not greater than vocab size\n        top_k_logits, top_k_indices = torch.topk(next_token_logits, k=top_k, dim=-1)\n        probs = torch.softmax(top_k_logits, dim=-1)\n        next_token_indices = torch.multinomial(probs, num_samples=1).squeeze(-1)\n        next_tokens = top_k_indices.gather(\n            -1, next_token_indices.unsqueeze(-1)\n        ).squeeze(-1)\n    else:\n        # Argmax (deterministic)\n        next_tokens = torch.argmax(next_token_logits, dim=-1, keepdim=True)\n\n    # Token ids in int tensor form\n    return next_tokens\n\n\ndef _update_padded_sequence(\n    padded_sequence: torch.Tensor,\n    new_token: torch.Tensor,\n    prompt_lengths: List[int],\n) -> None:\n    for i in range(len(prompt_lengths)):\n        padded_sequence[i, prompt_lengths[i]] = new_token[i, 0]\n        # logger.info(f\"updated prompt {i} with new token {new_token[i, 0]}\")\n\n\n# Decode token id into string and print it\ndef _decode_in_flight(token, tokenizer, tp_rank):\n    \"\"\"decode token ids for all prompts in the batch and log them\"\"\"\n    # `token` is a tensor of shape (batch_size, 1).\n    # For TiktokenTokenizer, we need to squeeze it to 1D.\n    # For SentencePieceProcessor, we don't.\n    if isinstance(tokenizer, TiktokenTokenizer):\n        token = torch.squeeze(token, dim=1)\n    token_str = tokenizer.decode(token.tolist())\n    # print the token string on tp rank 0\n    if tp_rank == 0:\n        logger.info(\n            f\"{color.green} responses ====>>>> \"\n            f\"{color.blue} {token_str} {color.reset}\"\n        )\n\n\ndef _cleanup():\n    dist.barrier()\n    dist.destroy_process_group()\n\n\nprompt = [\n    \"What is Snow?\",\n    # \"Can you explain what is the purpose of back propagation in neural networks?\",\n    \"Who is Santa Claus?\",\n    \"Where does Santa live?\",\n    # \"Who is Abraham Lincoln?\",\n    # \"How are models trained?\",\n]\n\n\ndef main(args):\n    model_name = args.model_name\n    pp_degree = args.pp\n\n    rank, world_size = _init_distributed()\n\n    gpu_memory_monitor = GPUMemoryMonitor(\"cuda\")\n    logger.info(f\"{color.yellow} {gpu_memory_monitor.get_device_info()}{color.reset}\")\n\n    distribution, model_dtype, model_dimension = NAME_TO_DISTRIBUTION_AND_DTYPE[\n        model_name\n    ]\n    logger.info(\n        f\"Using model weights from {distribution}, dtype {model_dtype} and model dimension {model_dimension}\"\n    )\n\n    # Model-level config\n    model_config = ModelArgs.from_name(distribution)\n    # Transformer-level config\n    config = TransformerArgs.from_params(model_config.transformer_args[\"text\"])\n    logger.info(f\"Transformer Config: {config}\")\n\n    tokenizer = _build_chat_tokenizer(model_name)\n\n    set_precision(model_dtype)\n    logger.info(f\"Using cache precision {model_dtype}\")\n\n    hf_config = get_hf_config_file(distribution)\n    if hf_config is None:\n        raise ValueError(f\"Config file not found for model id {distribution}\")\n\n    # Validate pipeline degree\n    assert world_size % pp_degree == 0\n    assert config.n_layers % pp_degree == 0\n\n    # Tensor parallel is enabled in this program\n    tp_degree = world_size // pp_degree\n    logger.info(f\"Using TP degree {tp_degree} and PP degree {pp_degree}\")\n\n    # Create device mesh\n    mesh_dimensions = (pp_degree, tp_degree)\n    device_mesh = _create_device_mesh(mesh_dimensions)\n    tp_mesh = device_mesh[\"tp\"]\n    pp_mesh = device_mesh[\"pp\"]\n    logger.info(f\"Created device mesh: {device_mesh}\\n{tp_mesh=}, {pp_mesh=}\")\n\n    tp_rank = tp_mesh.get_local_rank()\n    pp_rank = pp_mesh.get_local_rank()\n    tp_group = tp_mesh.get_group()\n    pp_group = pp_mesh.get_group()\n    logger.info(f\"{pp_degree=}, {tp_degree=}\")\n\n    # Convenience variables\n    first_pp_rank = 0\n    last_pp_rank = pp_degree - 1\n\n    # Assuming same number of GPUs per node\n    device = torch.device(f\"cuda:{rank % torch.cuda.device_count()}\")\n\n    # Fill in PP configs\n    config.stage_idx = pp_rank\n    config.n_stages = pp_degree\n\n    with torch.device(\"meta\"):\n        # TODO: we should create model instead of Transformer\n        model = Transformer(config)\n\n    # Distribute model on TP mesh\n    # (Surprisingly, this works even though model is on meta device and mesh is of\n    # cuda devices)\n    model.distribute(tp_mesh)\n    if rank == 0:\n        logger.info(f\"Model: {model}\")\n\n    # Load weights\n    logger.info(f\"Loading weights for {pp_rank=} on {device=}\")\n    with CUDATrackTime() as timer:\n        _load_model_weights(model, distribution, device, config, args.chpt_from)\n\n    logger.info(\n        f\"{color.green}Total weight loading time: {timer.get_time()} {timer.unit} for rank {rank}{color.reset}\"\n    )\n\n    # Batch size. Since we push batches dynamically through the pipeline rather\n    # than chunking them, this is effectively micro-batch size in pipeline\n    # sense. Thus it is interchangeable with micro-batch size below.\n    batch_size = len(prompt)\n    seqlen_prefill = 1024  # sequence length\n\n    # Setup KV caches (after model distribution)\n    # The number of cache lanes is the same as the maximum number of\n    # micro-batches that can be \"in flight\" in parallel -- imagine each\n    # micro-batch takes 1 \"pipeline lane,\" they need distinct KV cache spaces.\n    # When decoding is done for certain micro-batches, we can reuse the KV cache\n    # lanes.\n    # TODO: bump up the lane count\n    pipeline_lanes = 1\n    with device:\n        model.setup_caches(batch_size, seqlen_prefill, cache_lanes=pipeline_lanes)\n\n    # info on stage size and params\n    stage_size = get_module_size(model)\n    stage_size_formatted = bytes_to_readable(stage_size)\n    stage_num_params = get_num_params(model)\n    logger.info(\n        f\"Stage {rank} has {color.blue}{stage_num_params} params{color.reset}, Size: {color.blue}{stage_size_formatted}{color.reset}\"\n    )\n\n    # Setup input position (input_pos) for prefill: a list of increasing integers from 0 to seqlen\n    input_pos = torch.arange(seqlen_prefill, device=device)\n    model.eval()\n\n    # Helper function to get example inputs and outputs for the stages.\n    def get_example_ins_outs(seqlen: int) -> Tuple[torch.Tensor, torch.Tensor]:\n        mb_ids = torch.randint(\n            0, config.vocab_size, (batch_size, seqlen), device=device\n        )\n        activation = torch.rand(\n            batch_size, seqlen, model_dimension, device=device, dtype=model_dtype\n        )\n        logits = torch.rand(\n            batch_size, seqlen, config.vocab_size, device=device, dtype=model_dtype\n        )\n        example_inputs = (mb_ids if pp_rank == first_pp_rank else activation,)\n        example_outputs = (logits if pp_rank == last_pp_rank else activation,)\n        return example_inputs, example_outputs\n\n    # Create prefill stage\n    logger.info(f\"Creating pipeline stage for prefill {pp_rank=}, {pp_degree=}\")\n    example_inputs, example_outputs = get_example_ins_outs(seqlen_prefill)\n    prefill_stage = PipelineStage(\n        model,\n        pp_rank,\n        pp_degree,\n        device,\n        input_args=example_inputs,\n        output_args=example_outputs,\n        group=pp_group,\n    )\n\n    # Create schedule\n    # Number of micro-batches for the schedule is 1, because each step() call we\n    # only push 1 micro-batch into the pipeline. But we can continuously push\n    # new micro-batches into the pipeline as they arrive, achieving same\n    # pipelining effect.\n    prefiller = ScheduleGPipe(prefill_stage, 1)\n\n    start_pos = 0\n\n    # Need these global ids due to the API definition of dist.send and recv\n    first_pp_rank_global_id = dist.get_global_rank(pp_group, first_pp_rank)\n    last_pp_rank_global_id = dist.get_global_rank(pp_group, last_pp_rank)\n\n    # encode the prompt\n    input_ids = _encode_strings(\n        prompt, tokenizer, bos=True, device=device, dtype=torch.int64\n    )\n\n    # create a padded tensor for the input prompt\n    padded_sequence, prompt_lengths = _create_padded_prompts(\n        input_ids, tokenizer, seqlen_prefill, start_pos, device\n    )\n\n    # Need these global ids due to the API definition of dist.send and recv\n    first_pp_rank_global_id = dist.get_global_rank(pp_group, first_pp_rank)\n    last_pp_rank_global_id = dist.get_global_rank(pp_group, last_pp_rank)\n\n    # New token generated each iteration\n    # need a row dimension for each prompt in the batch\n    new_token = torch.zeros(batch_size, 1, device=device, dtype=torch.int64)\n    # Store the generated tokens\n    res = []\n\n    # Prefill phase\n    # Run context input through pipeline\n    # TODO: we need to pass `input_pos` and `cache_lane` to each stage.\n    lane = 0\n    kwargs = {\"input_pos\": input_pos, \"cache_lane\": lane}\n    with torch.no_grad(), CUDATrackTime() as timer:\n        if pp_rank == first_pp_rank:\n            output = prefiller.step(padded_sequence, **kwargs)\n        elif pp_rank == last_pp_rank:\n            output = prefiller.step(**kwargs)\n        else:  # middle pp ranks\n            prefiller.step(**kwargs)\n\n    logger.info(\n        f\"{color.green}Prefilling time: {timer.get_time()} {timer.unit} for rank {rank}{color.reset}\"\n    )\n\n    # Decode the output -- first generated token\n    if pp_rank == last_pp_rank:\n        logger.info(f\"{color.green}Decoding...{prompt_lengths=}{color.reset}\")\n        new_token = _batch_decode_next_tokens(output, prompt_lengths)\n        res.append(new_token)\n        if not args.disable_in_flight_decode:\n            _decode_in_flight(new_token, tokenizer, tp_rank)\n\n    # seqlen = 1 now\n    seqlen_decode = 1\n    input_pos = torch.tensor([prompt_lengths[0]], device=device)\n\n    # Create decode stage\n    logger.info(f\"Creating pipeline stage for decode {pp_rank=}, {pp_degree=}\")\n    example_inputs, example_outputs = get_example_ins_outs(seqlen_decode)\n    decode_stage = PipelineStage(\n        model,\n        pp_rank,\n        pp_degree,\n        device,\n        input_args=example_inputs,\n        output_args=example_outputs,\n        group=pp_group,\n    )\n    # create schedule\n    decoder = ScheduleGPipe(decode_stage, 1)\n\n    # Decoding\n    with torch.no_grad(), CUDATrackTime() as timer:\n        for step in range(args.ntokens - 1):\n            kwargs = {\"input_pos\": input_pos, \"cache_lane\": lane}\n            # sendrecv between last and first ranks, only if:\n            # first_pp_rank != last_pp_rank.\n            if pp_rank == last_pp_rank and pp_rank != first_pp_rank:\n                dist.send(\n                    new_token,\n                    dst=first_pp_rank_global_id,\n                    group=pp_group,\n                )\n            elif pp_rank == first_pp_rank and pp_rank != last_pp_rank:\n                dist.recv(\n                    new_token,\n                    src=last_pp_rank_global_id,\n                    group=pp_group,\n                )\n\n            # Run data through pipeline\n            if pp_rank == first_pp_rank:\n                output = decoder.step(new_token, **kwargs)\n            elif pp_rank == last_pp_rank:\n                output = decoder.step(**kwargs)\n            else:  # middle pp ranks\n                decoder.step(**kwargs)\n\n            # Decode the output\n            if pp_rank == last_pp_rank:\n                new_token = _batch_decode_next_tokens(output, prompt_lengths, step)\n                res.append(new_token)\n                if not args.disable_in_flight_decode:\n                    _decode_in_flight(new_token, tokenizer, tp_rank)\n\n            # Increment input position\n            input_pos += 1\n\n    logger.info(\n        f\"{color.green}Decoding time: {timer.get_time()} {timer.unit} for rank {rank}{color.reset}\"\n    )\n\n    # Display the decoding results\n\n    # output formatted response via last pp group and tp rank 0\n    if pp_rank == last_pp_rank and tp_rank == 0:\n        # `res` is a list of tensors, each being a batch of generated token ids.\n        # We need to concatenate them to get the full sequence of generated\n        # token ids. Thus cat'ing along dim 1.\n        res = torch.cat(res, dim=1)\n        res_list = res.tolist()\n        if _tokenizer_type == TokenizerType.Tiktoken:\n            # For TiktokenTokenizer, we need to decode prompt by prompt.\n            # TODO: is there a better way to do this?\n            responses = [tokenizer.decode(sequence) for sequence in res_list]\n        elif _tokenizer_type == TokenizerType.SentencePiece:  # SentencePieceProcessor\n            # For SentencePieceProcessor, we can decode the entire 2D list at once.\n            responses = tokenizer.decode(res_list)\n        else:\n            raise ValueError(f\"Unknown tokenizer type {_tokenizer_type}\")\n\n        # Show prompts and responses\n        for prompt_text, response_text in zip(prompt, responses):\n            logger.info(f\"Prompt: {color.green}{prompt_text} {color.reset}\")\n            logger.info(f\"Response: {color.red}{response_text} {color.reset}\")\n\n    # Cleanup\n    _cleanup()\n    logger.info(\n        f\"{color.green}Success{color.white} - {color.blue}Rank {rank} has completed.{color.reset}\"\n    )\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\n        \"model_name\",\n        type=str,\n        default=\"llama3\",\n        help=\"Name of the model to load\",\n        choices=NAME_TO_DISTRIBUTION_AND_DTYPE.keys(),\n    )\n\n    parser.add_argument(\"--pp\", type=int, default=1, help=\"Pipeline parallel degree\")\n    parser.add_argument(\n        \"--ntokens\",\n        type=int,\n        default=40,\n        help=\"Number of tokens to generate\",\n    )\n    parser.add_argument(\n        \"--disable-in-flight-decode\",\n        action=\"store_true\",\n        default=False,\n        help=\"Whether to decode token into string in flight\",\n    )\n    parser.add_argument(\n        \"--chpt-from\",\n        type=str,\n        default=\"hf\",  # TODO: change to torchchat once we support it well\n        help=\"Checkpoint format to load from\",\n        choices=[\"hf\", \"torchchat\"],\n    )\n    args = parser.parse_args()\n\n    main(args)\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "install",
          "type": "tree",
          "content": null
        },
        {
          "name": "runner",
          "type": "tree",
          "content": null
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "tokenizer",
          "type": "tree",
          "content": null
        },
        {
          "name": "torchchat.py",
          "type": "blob",
          "size": 3.7509765625,
          "content": "# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport argparse\nimport logging\nimport signal\nimport sys\n\n# MPS ops missing with Multimodal torchtune\n# https://github.com/pytorch/torchtune/issues/1723\nimport os\nos.environ[\"PYTORCH_ENABLE_MPS_FALLBACK\"] = \"1\"\n\nfrom torchchat.cli.cli import (\n    add_arguments_for_verb,\n    arg_init,\n    check_args,\n    INVENTORY_VERBS,\n    KNOWN_VERBS,\n)\n\ndefault_device = \"cpu\"\n\n\ndef signal_handler(sig, frame):\n    print(\"\\nInterrupted by user. Bye!\\n\")\n    sys.exit(0)\n\n\nif __name__ == \"__main__\":\n    # Set the signal handler for SIGINT\n    signal.signal(signal.SIGINT, signal_handler)\n\n    # Initialize the top-level parser\n    parser = argparse.ArgumentParser(\n        prog=\"torchchat\",\n        add_help=True,\n    )\n\n    subparsers = parser.add_subparsers(\n        dest=\"command\",\n        help=\"The specific command to run\",\n    )\n    subparsers.required = True\n\n    VERB_HELP = {\n        \"chat\": \"Chat interactively with a model via the CLI\",\n        \"generate\": \"Generate responses from a model given a prompt\",\n        \"browser\": \"Chat interactively with a model in a locally hosted browser\",\n        \"export\": \"Export a model artifact to AOT Inductor or ExecuTorch\",\n        \"download\": \"Download model artifacts\",\n        \"list\": \"List all supported models\",\n        \"remove\": \"Remove downloaded model artifacts\",\n        \"where\": \"Return directory containing downloaded model artifacts\",\n        \"server\": \"[WIP] Starts a locally hosted REST server for model interaction\",\n        \"eval\": \"Evaluate a model via lm-eval\",\n    }\n    for verb, description in VERB_HELP.items():\n        subparser = subparsers.add_parser(verb, help=description)\n        add_arguments_for_verb(subparser, verb)\n\n    # Now parse the arguments\n    args = parser.parse_args()\n\n    # Don't initialize for Inventory management subcommands\n    # TODO: Remove when arg_init is refactored\n    if args.command not in INVENTORY_VERBS:\n        args = arg_init(args)\n    logging.basicConfig(\n        format=\"%(message)s\", level=logging.DEBUG if args.verbose else logging.INFO\n    )\n\n    if args.command == \"chat\":\n        # enable \"chat\"\n        args.chat = True\n        check_args(args, \"chat\")\n        from generate import main as generate_main\n\n        generate_main(args)\n    elif args.command == \"browser\":\n        print(\n            \"\\nTo test out the browser please use: streamlit run torchchat/usages/browser.py <args>\\n\"\n        )\n    elif args.command == \"server\":\n        check_args(args, \"server\")\n        from torchchat.usages.server import main as server_main\n\n        server_main(args)\n    elif args.command == \"generate\":\n        check_args(args, \"generate\")\n        from torchchat.generate import main as generate_main\n\n        generate_main(args)\n    elif args.command == \"eval\":\n        from torchchat.usages.eval import main as eval_main\n\n        eval_main(args)\n    elif args.command == \"export\":\n        check_args(args, \"export\")\n        from torchchat.export import main as export_main\n\n        export_main(args)\n    elif args.command == \"download\":\n        check_args(args, \"download\")\n        from torchchat.cli.download import download_main\n\n        download_main(args)\n    elif args.command == \"list\":\n        check_args(args, \"list\")\n        from torchchat.cli.download import list_main\n\n        list_main(args)\n    elif args.command == \"where\":\n        check_args(args, \"where\")\n        from torchchat.cli.download import where_main\n\n        where_main(args)\n    elif args.command == \"remove\":\n        check_args(args, \"remove\")\n        from torchchat.cli.download import remove_main\n\n        remove_main(args)\n    else:\n        parser.print_help()\n"
        },
        {
          "name": "torchchat",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}