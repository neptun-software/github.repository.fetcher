{
  "metadata": {
    "timestamp": 1736559566407,
    "page": 181,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "PyImageSearch/imutils",
      "stars": 4551,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 2.2880859375,
          "content": "# Created by https://www.gitignore.io\n\n### Python ###\n# Byte-compiled / optimized / DLL files\n__pycache__/\n*.py[cod]\n\n# C extensions\n*.so\n\n# Distribution / packaging\n.Python\nenv/\nbuild/\ndevelop-eggs/\ndist/\ndownloads/\neggs/\n.eggs/\nlib/\nlib64/\nparts/\nsdist/\nvar/\n*.egg-info/\n.installed.cfg\n*.egg\n\n# PyInstaller\n#  Usually these files are written by a python script from a template\n#  before PyInstaller builds the exe, so as to inject date/other infos into it.\n*.manifest\n*.spec\n\n# Installer logs\npip-log.txt\npip-delete-this-directory.txt\n\n# Unit test / coverage reports\nhtmlcov/\n.tox/\n.coverage\n.coverage.*\n.cache\nnosetests.xml\ncoverage.xml\n*,cover\n\n# Translations\n*.mo\n*.pot\n\n# Django stuff:\n*.log\n\n# Sphinx documentation\ndocs/_build/\n\n# PyBuilder\ntarget/\n\n\n### PyCharm ###\n# Covers JetBrains IDEs: IntelliJ, RubyMine, PhpStorm, AppCode, PyCharm\n\n*.iml\n\n## Directory-based project format:\n.idea/\n# if you remove the above rule, at least ignore the following:\n\n# User-specific stuff:\n# .idea/workspace.xml\n# .idea/tasks.xml\n# .idea/dictionaries\n\n# Sensitive or high-churn files:\n# .idea/dataSources.ids\n# .idea/dataSources.xml\n# .idea/sqlDataSources.xml\n# .idea/dynamic.xml\n# .idea/uiDesigner.xml\n\n# Gradle:\n# .idea/gradle.xml\n# .idea/libraries\n\n# Mongo Explorer plugin:\n# .idea/mongoSettings.xml\n\n## File-based project format:\n*.ipr\n*.iws\n\n## Plugin-specific files:\n\n# IntelliJ\n/out/\n\n# mpeltonen/sbt-idea plugin\n.idea_modules/\n\n# JIRA plugin\natlassian-ide-plugin.xml\n\n# Crashlytics plugin (for Android Studio and IntelliJ)\ncom_crashlytics_export_strings.xml\ncrashlytics.properties\ncrashlytics-build.properties\n\n\n### OSX ###\n.DS_Store\n.AppleDouble\n.LSOverride\n\n# Icon must end with two \\r\nIcon\n\n\n# Thumbnails\n._*\n\n# Files that might appear in the root of a volume\n.DocumentRevisions-V100\n.fseventsd\n.Spotlight-V100\n.TemporaryItems\n.Trashes\n.VolumeIcon.icns\n\n# Directories potentially created on remote AFP share\n.AppleDB\n.AppleDesktop\nNetwork Trash Folder\nTemporary Items\n.apdisk\n\n\n### Windows ###\n# Windows image file caches\nThumbs.db\nehthumbs.db\n\n# Folder config file\nDesktop.ini\n\n# Recycle Bin used on file shares\n$RECYCLE.BIN/\n\n# Windows Installer files\n*.cab\n*.msi\n*.msm\n*.msp\n\n# Windows shortcuts\n*.lnk\n\n\n### Linux ###\n*~\n\n# KDE directory preferences\n.directory\n\n# Linux trash folder which might appear on any partition or disk\n.Trash-*\n"
        },
        {
          "name": "LICENSE.txt",
          "type": "blob",
          "size": 1.091796875,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2015-2016 Adrian Rosebrock, http://www.pyimagesearch.com\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "MANIFEST",
          "type": "blob",
          "size": 0.763671875,
          "content": "# file GENERATED by distutils, do NOT edit\nsetup.cfg\nsetup.py\nbin/range-detector\nimutils/__init__.py\nimutils/contours.py\nimutils/convenience.py\nimutils/encodings.py\nimutils/meta.py\nimutils/object_detection.py\nimutils/paths.py\nimutils/perspective.py\nimutils/face_utils/__init__.py\nimutils/face_utils/facealigner.py\nimutils/face_utils/helpers.py\nimutils/feature/__init__.py\nimutils/feature/dense.py\nimutils/feature/factories.py\nimutils/feature/gftt.py\nimutils/feature/harris.py\nimutils/feature/helpers.py\nimutils/feature/rootsift.py\nimutils/io/__init__.py\nimutils/io/tempfile.py\nimutils/video/__init__.py\nimutils/video/count_frames.py\nimutils/video/filevideostream.py\nimutils/video/fps.py\nimutils/video/pivideostream.py\nimutils/video/videostream.py\nimutils/video/webcamvideostream.py\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 10.314453125,
          "content": "# imutils\nA series of convenience functions to make basic image processing functions such as translation, rotation, resizing, skeletonization, and displaying Matplotlib images easier with OpenCV and ***both*** Python 2.7 and Python 3.\n\nFor more information, along with a detailed code review check out the following posts on the [PyImageSearch.com](http://www.pyimagesearch.com) blog:\n\n- [http://www.pyimagesearch.com/2015/02/02/just-open-sourced-personal-imutils-package-series-opencv-convenience-functions/](http://www.pyimagesearch.com/2015/02/02/just-open-sourced-personal-imutils-package-series-opencv-convenience-functions/)\n- [http://www.pyimagesearch.com/2015/03/02/convert-url-to-image-with-python-and-opencv/](http://www.pyimagesearch.com/2015/03/02/convert-url-to-image-with-python-and-opencv/)\n- [http://www.pyimagesearch.com/2015/04/06/zero-parameter-automatic-canny-edge-detection-with-python-and-opencv/](http://www.pyimagesearch.com/2015/04/06/zero-parameter-automatic-canny-edge-detection-with-python-and-opencv/)\n- [http://www.pyimagesearch.com/2014/09/01/build-kick-ass-mobile-document-scanner-just-5-minutes/](http://www.pyimagesearch.com/2014/09/01/build-kick-ass-mobile-document-scanner-just-5-minutes/)\n- [http://www.pyimagesearch.com/2015/08/10/checking-your-opencv-version-using-python/](http://www.pyimagesearch.com/2015/08/10/checking-your-opencv-version-using-python/)\n\n## Installation\nProvided you already have NumPy, SciPy, Matplotlib, and OpenCV already installed, the `imutils` package is completely `pip`-installable:\n\n<pre>$ pip install imutils</pre>\n\n## Finding function OpenCV functions by name\nOpenCV can be a big, hard to navigate library, especially if you are just getting started learning computer vision and image processing. The `find_function` method allows you to quickly search function names across modules (and optionally sub-modules) to find the function you are looking for.\n\n#### Example:\nLet's find all function names that contain the text `contour`:\n\n<pre>import imutils\nimutils.find_function(\"contour\")</pre>\n\n#### Output:\n<pre>1. contourArea\n2. drawContours\n3. findContours\n4. isContourConvex</pre>\n\nThe `contourArea` function could therefore be accessed via: `cv2.contourArea`\n\n\n## Translation\nTranslation is the shifting of an image in either the *x* or *y* direction. To translate an image in OpenCV you would need to supply the *(x, y)*-shift, denoted as *(t<sub>x</sub>, t<sub>y</sub>)* to construct the translation matrix *M*:\n\n![Translation equation](docs/images/translation_eq.png?raw=true)\n\nAnd from there, you would need to apply the `cv2.warpAffine` function.\n\nInstead of manually constructing the translation matrix *M* and calling `cv2.warpAffine`, you can simply make a call to the `translate` function of `imutils`.\n\n#### Example:\n<pre># translate the image x=25 pixels to the right and y=75 pixels up\ntranslated = imutils.translate(workspace, 25, -75)</pre>\n\n#### Output:\n\n<img src=\"docs/images/translation.png?raw=true\" alt=\"Translation example\" style=\"max-width: 500px;\">\n\n## Rotation\nRotating an image in OpenCV is accomplished by making a call to `cv2.getRotationMatrix2D` and `cv2.warpAffine`. Further care has to be taken to supply the *(x, y)*-coordinate of the point the image is to be rotated about. These calculation calls can quickly add up and make your code bulky and less readable. The `rotate` function in `imutils` helps resolve this problem.\n\n#### Example:\n<pre># loop over the angles to rotate the image\nfor angle in xrange(0, 360, 90):\n\t# rotate the image and display it\n\trotated = imutils.rotate(bridge, angle=angle)\n\tcv2.imshow(\"Angle=%d\" % (angle), rotated)</pre>\n\n#### Output:\n\n<img src=\"docs/images/rotation.png?raw=true\" alt=\"Rotation example\" style=\"max-width: 500px;\">\n\n## Resizing\nResizing an image in OpenCV is accomplished by calling the `cv2.resize` function. However, special care needs to be taken to ensure that the aspect ratio is maintained.  This `resize` function of `imutils` maintains the aspect ratio and provides the keyword arguments `width` and `height` so the image can be resized to the intended width/height while (1) maintaining aspect ratio and (2) ensuring the dimensions of the image do not have to be explicitly computed by the developer.\n\nAnother optional keyword argument, `inter`, can be used to specify interpolation method as well.\n\n#### Example:\n<pre># loop over varying widths to resize the image to\nfor width in (400, 300, 200, 100):\n\t# resize the image and display it\n\tresized = imutils.resize(workspace, width=width)\n\tcv2.imshow(\"Width=%dpx\" % (width), resized)</pre>\n\n#### Output:\n\n<img src=\"docs/images/resizing.png?raw=true\" alt=\"Resizing example\" style=\"max-width: 500px;\">\n\n## Skeletonization\nSkeletonization is the process of constructing the \"topological skeleton\" of an object in an image, where the object is presumed to be white on a black background. OpenCV does not provide a function to explicitly construct the skeleton, but does provide the morphological and binary functions to do so.\n\nFor convenience, the `skeletonize` function of `imutils` can be used to construct the topological skeleton of the image.\n\nThe first argument, `size` is the size of the structuring element kernel. An optional argument, `structuring`, can be used to control the structuring element -- it defaults to `cv2.MORPH_RECT`\t, but can be any valid structuring element.\n\n#### Example:\n<pre># skeletonize the image\ngray = cv2.cvtColor(logo, cv2.COLOR_BGR2GRAY)\nskeleton = imutils.skeletonize(gray, size=(3, 3))\ncv2.imshow(\"Skeleton\", skeleton)</pre>\n\n#### Output:\n\n<img src=\"docs/images/skeletonization.png?raw=true\" alt=\"Skeletonization example\" style=\"max-width: 500px;\">\n\n## Displaying with Matplotlib\nIn the Python bindings of OpenCV, images are represented as NumPy arrays in BGR order. This works fine when using the `cv2.imshow` function. However, if you intend on using Matplotlib, the `plt.imshow` function assumes the image is in RGB order. A simple call to `cv2.cvtColor` will resolve this problem, or you can use the `opencv2matplotlib` convenience function.\n\n#### Example:\n<pre># INCORRECT: show the image without converting color spaces\nplt.figure(\"Incorrect\")\nplt.imshow(cactus)\n\n# CORRECT: convert color spaces before using plt.imshow\nplt.figure(\"Correct\")\nplt.imshow(imutils.opencv2matplotlib(cactus))\nplt.show()</pre>\n\n#### Output:\n\n<img src=\"docs/images/matplotlib.png?raw=true\" alt=\"Matplotlib example\" style=\"max-width: 500px;\">\n\n## URL to Image\nThis the `url_to_image` function accepts a single parameter: the `url` of the image we want to download and convert to a NumPy array in OpenCV format. This function performs the download in-memory. The `url_to_image` function has been detailed [here](http://www.pyimagesearch.com/2015/03/02/convert-url-to-image-with-python-and-opencv/) on the PyImageSearch blog.\n\n#### Example:\n<pre>url = \"http://pyimagesearch.com/static/pyimagesearch_logo_github.png\"\nlogo = imutils.url_to_image(url)\ncv2.imshow(\"URL to Image\", logo)\ncv2.waitKey(0)</pre>\n\n#### Output:\n\n<img src=\"docs/images/url_to_image.png?raw=true\" alt=\"Matplotlib example\" style=\"max-width: 500px;\">\n\n## Checking OpenCV Versions\nOpenCV 3 has finally been released! But with the major release becomes backward compatibility issues (such as with the `cv2.findContours` and `cv2.normalize` functions). If you want your OpenCV 3 code to be backwards compatible with OpenCV 2.4.X, you'll need to take special care to check which version of OpenCV is currently being used and then take appropriate action. The `is_cv2()` and `is_cv3()` are simple functions that can be used to automatically determine the OpenCV version of the current environment.\n\n#### Example:\n<pre>print(\"Your OpenCV version: {}\".format(cv2.__version__))\nprint(\"Are you using OpenCV 2.X? {}\".format(imutils.is_cv2()))\nprint(\"Are you using OpenCV 3.X? {}\".format(imutils.is_cv3()))</pre>\n\n#### Output:\n<pre>Your OpenCV version: 3.0.0\nAre you using OpenCV 2.X? False\nAre you using OpenCV 3.X? True</pre>\n\n## Automatic Canny Edge Detection\nThe Canny edge detector requires two parameters when performing hysteresis. However, tuning these two parameters to obtain an optimal edge map is non-trivial, especially when working with a dataset of images. Instead, we can use the `auto_canny` function which uses the median of the grayscale pixel intensities to derive the upper and lower thresholds. You can read more about the `auto_canny` function [here](http://www.pyimagesearch.com/2015/04/06/zero-parameter-automatic-canny-edge-detection-with-python-and-opencv/).\n\n#### Example:\n<pre>gray = cv2.cvtColor(logo, cv2.COLOR_BGR2GRAY)\nedgeMap = imutils.auto_canny(gray)\ncv2.imshow(\"Original\", logo)\ncv2.imshow(\"Automatic Edge Map\", edgeMap)</pre>\n\n#### Output:\n\n<img src=\"docs/images/auto_canny.png?raw=true\" alt=\"Matplotlib example\" style=\"max-width: 500px;\">\n\n## 4-point Perspective Transform\nA common task in computer vision and image processing is to perform a 4-point perspective transform of a ROI in an image and obtain a top-down, \"birds eye view\" of the ROI. The `perspective` module takes care of this for you. A real-world example of applying a 4-point perspective transform can be bound in this blog on on [building a kick-ass mobile document scanner](http://www.pyimagesearch.com/2014/09/01/build-kick-ass-mobile-document-scanner-just-5-minutes/).\n\n#### Example\nSee the contents of `demos/perspective_transform.py`\n\n#### Output:\n\n<img src=\"docs/images/perspective_transform.png?raw=true\" alt=\"Matplotlib example\" style=\"max-width: 500px;\">\n\n## Sorting Contours\nThe contours returned from `cv2.findContours` are unsorted. By using the `contours` module the the `sort_contours` function we can sort a list of contours from left-to-right, right-to-left, top-to-bottom, and bottom-to-top, respectively.\n\n#### Example:\nSee the contents of `demos/sorting_contours.py`\n\n#### Output:\n\n<img src=\"docs/images/sorting_contours.png?raw=true\" alt=\"Matplotlib example\" style=\"max-width: 500px;\">\n\n## (Recursively) Listing Paths to Images\nThe `paths` sub-module of `imutils` includes a function to recursively find images based on a root directory.\n\n#### Example:\nAssuming we are in the `demos` directory, let's list the contents of the `../demo_images`:\n\n<pre>from imutils import paths\nfor imagePath in paths.list_images(\"../demo_images\"):\n\tprint imagePath</pre>\n\n#### Output:\n<pre>../demo_images/bridge.jpg\n../demo_images/cactus.jpg\n../demo_images/notecard.png\n../demo_images/pyimagesearch_logo.jpg\n../demo_images/shapes.png\n../demo_images/workspace.jpg</pre>\n"
        },
        {
          "name": "bin",
          "type": "tree",
          "content": null
        },
        {
          "name": "demo_images",
          "type": "tree",
          "content": null
        },
        {
          "name": "demos",
          "type": "tree",
          "content": null
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "imutils",
          "type": "tree",
          "content": null
        },
        {
          "name": "setup.cfg",
          "type": "blob",
          "size": 0.0380859375,
          "content": "[metadata]\ndescription-file = README.md"
        },
        {
          "name": "setup.py",
          "type": "blob",
          "size": 0.7724609375,
          "content": "from distutils.core import setup\n\nsetup(\n    name='imutils',\n    packages=['imutils', 'imutils.video', 'imutils.io', 'imutils.feature', 'imutils.face_utils'],\n    version='0.5.4',\n    description='A series of convenience functions to make basic image processing functions such as translation, rotation, resizing, skeletonization, displaying Matplotlib images, sorting contours, detecting edges, and much more easier with OpenCV and both Python 2.7 and Python 3.',\n    author='Adrian Rosebrock',\n    author_email='adrian@pyimagesearch.com',\n    url='https://github.com/jrosebr1/imutils',\n    download_url='https://github.com/jrosebr1/imutils/tarball/0.1',\n    keywords=['computer vision', 'image processing', 'opencv', 'matplotlib'],\n    classifiers=[],\n    scripts=['bin/range-detector'],\n)\n"
        }
      ]
    }
  ]
}