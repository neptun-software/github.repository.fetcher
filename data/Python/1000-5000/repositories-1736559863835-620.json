{
  "metadata": {
    "timestamp": 1736559863835,
    "page": 620,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjYyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "pandolia/qqbot",
      "stars": 3676,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0673828125,
          "content": "*.pyc\nbak/*\nbuild/*\ndist/*\nMANIFEST\nfiles.txt\n*egg-info/*\ntmp*\n*.log\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.177734375,
          "content": "==============================================\nThis is a copy of the MIT license.\n==============================================\nCopyright (C) 2016~2017 Pandolia <pandolia@yeah.net>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.MD",
          "type": "blob",
          "size": 39.5595703125,
          "content": "！！！ [Smart QQ](https://web2.qq.com) 已于 2019 年 1 月 3 日停止服务，目前本项目已无法使用，本项目不再更新和维护。感谢大家对本项目的帮助、支持和鼓励！\n----------------------------\n\n一、介绍\n---------\n\nqqbot 是一个用 python 实现的、基于腾讯 SmartQQ 协议的 QQ 机器人，可运行在 Linux, Windows 和 Mac OSX 平台下。\n\n本项目 github 地址： <https://github.com/pandolia/qqbot>\n\n你可以通过扩展 qqbot 来实现：\n\n* 监控、收集 QQ 消息\n* 自动消息推送\n* 聊天机器人\n* 通过 QQ 远程控制你的设备\n\n二、安装方法\n-------------\n\n在 Python 2.7/3.4+ 下使用，用 pip 安装：\n\n    pip install qqbot\n\n或者下载 [源码](https://github.com/pandolia/qqbot/archive/master.zip) 解压后 cd 到该目录并运行： `pip install`.\n\n三、使用方法\n-------------\n\n##### 1. 启动 QQBot\n\n在命令行输入： **qqbot** ，即可启动一个 QQBot 。\n\n启动过程中会自动弹出二维码图片，需要用手机 QQ 客户端扫码并授权登录。启动成功后，会将本次登录信息保存到本地文件中，下次启动时，可以输入： **qqbot -q qq号码** ，先尝试从本地文件中恢复登录信息（不需要手动扫码），只有恢复不成功或登录信息已过期时才会需要手动扫码登录。一般来说，保存的登录信息将在 2 天之后过期。\n\n注意： Linux 下，需要系统中有 gvfs-open 或者 shotwell 命令才能自动弹出二维码图片（一般安装有 GNOME 虚拟文件系统 gvfs 的系统中都会含这两个命令之一）。 Windows10 下，需要系统中已设置了 png 图片文件的默认打开程序才能自动弹出二维码图片。\n\n若系统无法自动弹出二维码图片，可以手动打开图片文件进行扫码，也可以将二维码显示模式设置为 邮箱模式 、 服务器模式 或 文本模式 进行扫码，详见本文档的第七节。\n\n##### 2. 操作 QQBot\n\nQQBot 启动后，在另一个控制台窗口使用 qq 命令操作 QQBot ，目前提供以下命令：\n\n    1） 帮助、停机和重启命令\n\n        qq help|stop|restart|fresh-restart\n\n\n    2） 联系人查询、搜索命令\n\n        qq list buddy|group|discuss [$cinfo|$clike]\n        ( $cinfo --> $qq|$name|$key=$val )\n        ( $clike --> :like:$qq|:like:$name|$key:like:$name )\n\n        qq list group-member|discuss-member $oinfo|$olike [$cinfo|$clike]\n        ( $oinfo --> $oqq|$oname|$okey=$oval )\n        ( $cinfo --> $qq|$name|$key=$val )\n        ( $olike --> :like:$oqq|:like:$oname|$okey:like:$oname )\n        ( $clike --> :like:$qq|:like:$name|$key:like:$name )\n\n\n    3） 联系人更新命令\n\n        qq update buddy|group|discuss\n\n        qq update group-member|discuss-member $ginfo\n\n\n    4） 消息发送命令\n\n        qq send buddy|group|discuss $rinfo $message\n\n\n    5） 加载/卸载/显示插件\n\n        qq plug/unplug myplugin\n\n        qq plugins\n\n\nlist 命令提供强大的联系人查询和搜索功能，用法示例如下：\n\n    # 列出所有好友\n    qq list buddy\n\n    # 列出 名称 为 xxx 的群\n    qq list group xxx\n\n    # 列出备注名为 jack 的好友\n    qq list buddy mark=jack\n\n    # 列出 群“456班” 的所有成员\n    qq list group-member 456班\n\n    # 列出 群“456班” 中名片为 “mike” 的成员\n    qq list group-member 456班 card=mike\n\n    # 列出 讨论组“XX小组” 中名为 jack 的好友\n    qq list discuss-member XX小组 jack\n\n其中第三、四个参数如果是 key=val 的格式，则应为 name=xx|nick=xx|mark=xx|card=xx|qq=xx 的格式，如果不是 key=val 的格式，则按以下原则进行处理：若是一串数字，则按 QQ 号进行查询，否则，按名称进行查询。\n\n如果存在重名现象，会列出所有重名的联系人。如：\n\n    qq list group 机器人测试\n\n将列出所有名为 “机器人测试” 的群。\n\n如果在 list 命令的第三、四个参数中加入 “:like:” ，则会按部分匹配的模式进行搜索，用法示例如下：\n\n    # 列出名称中含有 “李” 的好友\n    qq list buddy :like:李\n\n    # 列出 QQ 中含有 “234” 的群\n    qq list group :like:234\n\n    # 列出备注名中含有 jack 的好友\n    qq list buddy mark:like:jack\n\n    # 列出 群“456班” 的中名称中含有 “李” 的成员\n    qq list group-member 456班 :like:李\n\n    # 列出 群“456班” 中名片中含有 “mike” 的成员\n    qq list group-member 456班 card:like:mike\n\n    # 列出的 讨论组“xx小组” 中名为 jack 的好友\n    qq list discuss-member :like:小组 jack\n\n从 v2.2.5 版开始， list 命令采用表格的形式输出联系人列表，其输出样式示例如下：\n\n![prettytable.png](https://raw.githubusercontent.com/pandolia/qqbot/master/prettytable.png)\n\n为保证表格在终端中的显示效果，建议将终端的输出字体设置为 consolas 、且每行可打印的最大字符数大于 120 。另外需要注意：为保证表格的显示效果，当联系人的名称、名片等属性的长度太长或含有特殊字符时，将对这些属性进行截断或过滤后再输出至终端。\n\nupdate 命令更新指定的联系人列表，其参数含义和 list 命令相同，如：\n\n    # 更新好友列表\n    qq update buddy\n\n    # 更新群列表\n    qq update group\n\n    # 更新 群“456班” 的成员列表\n    qq update group-member 456班\n\nsend 命令中第三个参数和 list 命令中的第三个参数格式一致。要注意，如果有重名现象，会给所有重名的联系人发信息。 另外要注意，第二个参数只能是 buddy/group/discuss ，不能是 group-member/discuss-member 。示例：\n\n    # 给 好友“jack” 发消息 “你好”\n    qq send buddy jack 你好\n\n    # 给 群“198班” 发消息 “大家好”\n    qq send group 198班 大家好\n\n    # 给 QQ 为 12345 的好友发消息\n    qq send buddy 12345 xxx\n\n    # 给讨论组发消息\n    qq send discuss MyDiscuss hello\n\n可以在消息内容中嵌入“/可爱”等表情关键词来向对方发送表情，详见 [facemap.py](https://github.com/pandolia/qqbot/blob/master/qqbot/facemap.py)。还可以在消息内容中使用 **\\n,\\t** 这两个转义字符（如： send buddy jack 第一行\\n第二行）。\n\n以上所有命令都提供对应的 HTTP API 接口，供 web 前端开发者调用，接口的 url 地址为 http://127.0.0.1:8188/{command} ，只需要将 qq 后面的命令各参数用 \"/\" 分隔开替换 url 中的 command 就可以了，如: http://127.0.0.1:8188/send/buddy/jack/hello ，其他示例详见 [urltestbot.md](https://github.com/pandolia/qqbot/blob/master/urltestbot.html) 。注意：如果命令中含有中文或特殊字符，需要先进行 url 编码（ utf8 ），例如，调用  http://127.0.0.1:8188/send/buddy/jack/nihao%20%E4%BD%A0%E5%A5%BD%20wohao 将发送消息 ”nihao 你好 wohao“ 。（提示：在 JavaScript 中，可以使用 encodeURIComponent 函数进行编码）。\n\n另外， QQBot 启动后，用本 QQ 号在其他客户端（如：手机 QQ ）上向某个 群/讨论组 发消息 “--version” ，则 QQBot 会自动在该 群/讨论组 回复： “QQBot-v2.x.x” 。\n\n四、实现你自己的 QQ 机器人\n---------------------------\n\n实现自己的 QQ 机器人非常简单，只需要定义一个自己的消息响应函数并按插件加载。示例代码：\n```python\n# -*- coding: utf-8 -*-\n\ndef onQQMessage(bot, contact, member, content):\n    if content == '-hello':\n        bot.SendTo(contact, '你好，我是QQ机器人')\n    elif content == '-stop':\n        bot.SendTo(contact, 'QQ机器人已关闭')\n        bot.Stop()\n```\n\n注意，上面注册的响应函数的函数名必须为 “onQQMessage” ，函数参数也必须和上面的一致。\n\n将以上代码另存为 sample.py （注意保存为 utf8 编码的文件）。放到 \\~/.qqbot-tmp/plugins/ 目录下（ **\\~** 代表用户主目录， win7 下为 C:\\\\Users\\\\xxx ），或系统中可以 import 到的目录下（如 python 的安装目录下的 Lib/site-packages 目录）。\n\n之后，保持前面的 qqbot 进程运行，在另一个控制台输入 qq plug sample ，则可将此文件中的 onQQMessage 函数注册到 QQBot 的相应事件上去。此时，用另外一个 QQ 向本 QQ 发送消息 **“-hello”**，则会自动回复 **“你好，我是 QQ 机器人”**，发送消息 **“-stop”** 则会关闭 QQ 机器人。\n\n在控制台输入 qq unplug sample 可以卸载此插件及相应的回调函数。可以同时加载多个插件，此时各插件中的相应函数会依次被调用（但调用顺序和加载次序无关）。\n\nQQBot 开始运行后，每收到一条 QQ 消息，会将消息来源、消息内容以及一个 QQBot 对象传递给已注册的消息响应函数。其中：\n\n    bot     : QQBot 对象，提供 List/SendTo/Stop/Restart 等接口，详见本文档第五节\n    contact : QContact 对象，消息的发送者，具有 ctype/qq/uin/nick/mark/card/name 等属性\n    member  : QContact 对象，仅当本消息为 群消息或讨论组消息 时有效，代表实际发消息的成员\n    content : str 对象，消息内容\n\ncontact 代表消息发送者，其 ctype 属性可以为 `buddy`/`group`/`discuss` ，代表 好友/群/讨论组 对象，表示本消息是 好友消息/群消息/讨论组消息 。\n\nmember 仅当本消息为  群消息或讨论组消息 时有效，代表实际发消息的成员，它的 ctype 属性可以为 `group-member`/`discuss-member` ，代表 群成员/讨论组成员 对象。当本消息为 好友消息 时， member 等于 None 。\n\ncontact 和 member 都是 QContact 对象，不同类型的 QContact 对象所具有的属性含义见： [qcontact-attr](https://github.com/pandolia/qqbot/blob/master/qcontact-attr.md) 。注意所有 QContact 对象都是 **只读对象** ，只能读取它的属性，不能设置它的属性，也不能向它添加额外的属性。 \n\n可以调用 QQBot 对象的 SendTo 接口向 QContact 对象发送消息，但要注意：只可以向 好友/群/讨论组 发消息， **不可以向 群成员/讨论组成员 发送消息** 。也就是说，只可以调用 bot.SendTo(contact, 'xxx') ， 不可以调用 bot.SendTo(member, 'xxx') 。\n\n五、 QQBot 对象的公开接口和属性\n--------------------------------\n\nQQBot 对象提供 List/Update/SendTo/Plug/Unplug/Login/Stop/Restart/FreshRestart 共计 9 个公开接口，这些接口的第一个字母都是大写的。另外，提供一个公开属性 conf 保存全局的配置信息。\n\n一般情况下，请勿 调用/存取 此对象的其他 方法/属性 。特别的， **请勿在子线程中调用这些接口** 。 以下介绍前 7 个接口和 conf 属性。\n\n如果需要在 IDE 或 python-shell 中运行或测试以上接口，需要先关闭 qqbot 进程，并在 IDE 或 python-shell 中运行以下代码进行登录：\n\n    >>> from qqbot import _bot as bot\n    >>> bot.Login(['-q', '1234'])\n\n#### （1） bot.List(tinfo, [cinfo]) --> [contact0, contact1, ..., ]/[]/None\n\n对应本文档第三节的 list 命令。返回联系人对象（ QContact 对象）列表或者 None 。第一个参数 tinfo 是联系人列表的代号，第二个参数是可选的（和 list 命令的第三个参数格式一致）。\n\n参数 tinfo 用来代表某个联系人列表，**该参数在联系人的查询中非常重要，请务必理解以下两种情况** ：\n\n**tinfo 的含义（情况1）：** tinfo 可以为 `buddy`/`group`/`discuss` ，分别代表 好友列表/群列表/讨论组列表 。示例：\n\n    # 返回 好友列表：\n    >>> bot.List('buddy')\n\n    # 返回名为 'jack' 的好友的列表：\n    >>> bot.List('buddy', 'jack')\n\n    # 返回 群列表：\n    >>> bot.List('group')\n\n    # 返回名为 “机器人测试” 的群的列表：\n    >>> bot.List('group', '机器人测试')\n\n**tinfo 的含义（情况2）：** tinfo 也可以是一个 ctype 等于 `group`/`discuss` 的 QContact 对象，代表该 群/讨论组 的成员列表。如以下第二句和第三句分别返回 群“456班” 的成员列表和该群中名片为 “jack” 的成员列表：\n\n    >>> g = bot.List('group', \"456班\")[0]   # g 是一个 Group 对象（群“456班”）\n    >>> bot.List(g)                         # 返回 群“456班” 的成员列表\n    >>> bot.List(g, 'card=jack')            # 返回 群“456班” 中名片为 “jack” 的成员列表\n\n注意上面第三句不允许是 bot.List(g, card='jack') 的格式。\n\n**List 接口的内部执行顺序：** 首先在 QQBot 的联系人数据库内查找 tinfo 所代表的联系人列表；若数据库内已有此列表，则在此列表内进行搜索，并返回一个包含 “此列表中所有和 cinfo 匹配的联系人” 的列表；若数据库内没有此列表，则向 QQ 服务器请求数据获取联系人列表，获取成功后将联系人列表保存到数据库内，然后再进行搜索并返回一个包含 “此列表中所有和 cinfo 匹配的联系人” 的列表；如果在向 QQ 服务器请求数据的过程中出错了，则打印相关的失败信息，并返回 None 。\n\n**List 接口返回值的含义：** 返回一个非空列表表示 tinfo 所指定的联系人列表内所有和 cinfo 匹配的联系人；返回一个空列表表示该联系人列表内没有和 cinfo 匹配的联系人；返回 None 表示向 QQ 服务器请求联系人列表和资料失败，不知道是否有相匹配的联系人。\n\n调用 List 接口后， **务必** 先根据以上三种情况对返回值进行判断，然后再执行后续代码。\n\n**注意： 当 List 接口返回非空列表时，列表内的元素是 QContact 对象，而不是 str 对象：**\n\n    >>> g = bot.List('group')[0]   \t\t\t\t# g 是一个 Group 对象\n    >>> print([g, type(g), g.qq, g.name, g.uin, g.mark])\t# 打印 g 的各项属性\n\n不同类型的 QContact 对象所具有的属性含义见： [qcontact-attr](https://github.com/pandolia/qqbot/blob/master/qcontact-attr.md) 。 \n\n#### （2） bot.Update(tinfo) --> True/False\n\nUpdate 接口的参数 tinfo 和 List 接口中的参数含义相同，调用此接口会立即向 QQ 服务器请求相应的联系人列表并更新联系人数据库，并一直阻塞至更新成功。更新最慢的是好友列表，若好友较多可能会阻塞 5 ~ 10 秒。成员列表更新的较快，即便是 2000 人的大群，更新时间仅 1 ~ 2 秒。\n\n若更新成功，返回 True ，否则，返回 False 。\n\n示例：\n\n    # 更新 好友列表 ：\n    >>> bot.Update('buddy')\n\n    # 更新 群列表 ：\n    >>> bot.Update('group')\n\n    # 更新 某个群的成员列表 ：\n    >>> gl = bot.List('group', \"456班\")\n    >>> if gl:\n    >>>     g = gl[0]\n    >>>     bot.Update(g)\n\n#### （3） bot.SendTo(contact, content, resendOn1202=True) --> '向 xx 发消息成功'/'错误：...'\n\n向联系人发送消息。第一个参数为 QContact 对象，第二个参数为消息内容。再次提醒： 只可以向 好友/群/讨论组 发消息， **不允许向 群成员/讨论组成员 发消息** 。\n\n可以在消息内容中嵌入“/微笑”等表情关键词来向对方发送表情，详见 [facemap.py](https://github.com/pandolia/qqbot/blob/master/qqbot/facemap.py) 。\n\n若发送成功，返回字符串（`向 xx 发消息成功`）。否则，返回含错误原因的字符串（`错误：...`）。\n\n发消息时可能会重复发消息，这是因为 QQ 服务器返回代码 1202 的原因。v2.1.17版已针对此问题在 bot.SendTo 接口中增加了一个参数： resendOn1202 ，若此参数为 True （默认值），则发消息时如果 QQ 服务器返回代码 1202 （表明发消息可能失败），还会继续发送 3 次，直至返回代码 0 ， 若此参数为 False ，则不会尝试重发。\n\n设为 True 在绝大部分情况下能保证消息一定能发出去，但缺点是有时一条消息会重复发送。设为 False 则相反，消息不会重复发送，但有时消息发送不出去。\n\n总之因为这个 1202 代码的不确定性，没有完美的解决办法。请根据各自的实际情况选择 resendOn1202 的值。\n\n第一个参数 contact 必须是通过 bot.List 返回的 QContact 对象、或回调函数 onQQMessage 传递进来的第一个参数。示例：\n\n    # 向 昵称 为 jack 的好友发消息\n    >>> bl = bot.List('buddy', 'jack')\n    >>> if bl:\n    >>>     b = bl[0]\n    >>>     bot.SendTo(b, 'hello')\n \n#### （4） bot.conf\n\nbot.conf 中保存全局的配置信息，各项配置详见本文档第七节。如 bot.conf.termServerPort 保存 QQBot 命令行服务器的端口号， bot.conf.qq 保存本次登录的 QQ 号码。\n\n注意： bot.conf 中保存的配置信息是只读的，请勿修改这些配置信息。\n\n\n六、 注册回调函数、被他人 @ 的通知、判断是否是自己发的消息、定制定时任务\n-------------------------------------------------------------\n\n#### 注册回调函数\n\n除了上面提到的 onQQMessage 响应函数，还可以注册 onInit/onQrcode/onStartupComplete/onInterval/onUpdate/onPlug/onUnplug/onExit 共计九种事件的回调函数，所有事件的回调函数参数格式、含义及示例详见 [sampleslots.py](https://github.com/pandolia/qqbot/blob/master/qqbot/plugins/sampleslots.py) 。\n\n程序的运行流程以及各回调函数的调用时机如下：\n\n![main.png](https://github.com/pandolia/qqbot/raw/master/doc-data/main.png)\n\n再次提醒：**注册的回调函数的函数名以及函数参数（数量和名称）都不得更改** 。\n\n#### 被群内其他成员 @ 的通知\n\n QQBot 收到群消息时，会先根据消息内容判断是否有人 @ 自己。如果是，则在消息内容的开头加一个 `[@ME] ` 的标记，再传递给 onQQMessage 函数；否则，将消息内容中的所有 `@ME` 替换成 `@Me` 再传给 onQQMessage 。因此，在 onQQMessage 函数内，只需要判断 content 内是否含有 `@ME` 就知道自己是否被消息发送者 @ 了。例如：\n\n```python\ndef onQQMessage(bot, contact, member, content):\n    if '@ME' in content:\n        bot.SendTo(contact, member.name+'，艾特我干嘛呢？')\n```\n\n请注意，若群内有另一个成员的名字和自己的名字的开头部分相同（如：自己的名字是 ab ，另一个成员的名字是 abc ），那么当有人 @abc 时，也会误报成 @ME ，在这种情况下，需要修改自己的群名片，以免误报。\n\n#### 判断是否是自己发的消息\n\n当本 QQ 发消息时， QQBot 也会收到一条同样的消息， bot 对象提供一个 isMe 方法来判断是否是自己发的消息：\n\n```python\ndef onQQMessage(bot, contact, member, content):\n    if bot.isMe(contact, member):\n    print('This is me')\n```\n\n#### 定制定时任务\n\n从 2.1.13 起， qqbot 提供一个功能强大的函数装饰器 -- `qqbotsched` 来定制定时任务，示例代码：\n\n\n```python\nfrom qqbot import qqbotsched\n\n@qqbotsched(hour='11,17', minute='55')\ndef mytask(bot):\n    gl = bot.List('group', '456班')\n    if gl is not None:\n        for group in gl:\n            bot.SendTo(group, '同志们：开饭啦啦啦啦啦啦！！！')\n```\n以上代码以插件形式加载后，每到 11:55 和 17:55 ，都会自动向 群“456班” 发送消息：“同志们：开饭啦啦啦啦啦啦！！！” 。\n\nqqbotsched 装饰器接受 year, month, day, week, day_of_week, hour, minute, second, start_date, end_date, timezone 共计 11 个关键字参数，每个参数表示任务的定制时间的分量所应匹配的值。例如： hour='11,17' 表示应在 11:xx 或 17:xx 执行任务， minute='55' 表示应在 xx:55 执行任务， minute='0-55/5' 表示应在 xx:00, xx:05, xx:10, ..., xx:55 执行任务， day_of_week='mon-fri' （或 '0-4' ） 表示应在 星期一 ~ 星期五 执行任务。\n\nqqbotsched 是对 Python 的定时任务框架 apscheduler 的简单封装，其各项参数应采用 Unix 系统中的 crontab 格式输入。有关 crontab 以及 Python 的定时任务框架 apscheduler 的内容可参见以下参考资料：\n\n- https://code.tutsplus.com/tutorials/scheduling-tasks-with-cron-jobs--net-8800/\n- http://apscheduler.readthedocs.io/en/latest/userguide.html\n- [https://lz5z.com/Python定时任务的实现方式/](https://lz5z.com/Python%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/)\n- http://debugo.com/apscheduler/\n\ncrontab 各项参数格式说明详见：\n\n- http://apscheduler.readthedocs.io/en/latest/modules/triggers/cron.html\n\n#### 注册回调函数和定制定时任务的注意事项\n\n注册回调函数和定制定时任务是对 QQBot 进行扩展的唯一方式，在编写这些函数时，请注意以下事项：\n\n- 回调函数的函数名、参数名、参数数量、参数顺序都不得更改\n- 定时任务的函数名可以自己定义，但参数有且只有一个，参数名必须为 bot ，为一个 QQBot 对象。\n- 所有回调函数和定时任务都将在主线程中被依次调用，因此不必担心全局变量的线程安全问题。\n- 回调函数和定时任务的运行时间应尽量短，尽量不要再这些函数中进行阻塞式的操作，否则会阻塞整个程序的运行。一般来说，每个函数的运行时间在 5 秒以内是可以接受的。\n- **绝对不要** 在回调函数、定时任务或 qqbot 主线程的内部调用 os.system 执行 **本 QQ 号对应的 qq 命令** （ 如 os.system('qq send buddy jack hello') ）或请求 **本 QQ 号对应的 HTTP-API 接口** ，否则整个程序会形成死锁（因为 os.system 要等 qq 命令执行完成后才返回、而 qq 命令要等 os.system 返回后才会被执行）。请直接使用 bot 的 SendTo/List 等接口。\n\n七、二维码管理器、QQBot 配置、命令行参数以及工作目录\n--------------------------------------------\n\n#### 二维码的显示模式\n\nWebQQ 登录时需要用手机 QQ 扫描二维码图片，在 QQBot 中，二维码图片可以通过以下四种模式显示：\n\n* GUI模式： 在 GUI 界面中自动弹出二维码图片\n* 邮箱模式： 将二维码图片发送到指定的邮箱\n* 服务器模式： 在一个 HTTP 服务器中显示二维码图片\n* 文本模式： 在 Term 中以文本形式展示二维码(需要自行安装 pillow 和 wcwidth 库)\n\nGUI 模式是默认的模式，只适用于个人电脑。邮箱模式可以适用于个人电脑和远程服务器。服务器模式一般只在有公网 ip 的系统中使用。如果使用 QQ 邮箱来接收二维码，则发送二维码图片之后，手机 QQ 客户端会立即收到通知，在手机 QQ 客户端上打开邮件，再长按二维码就可以扫描了。文本模式方便在开发过程或者服务器部署时使用，为开发者提供快捷方式登陆 QQ 。\n\n注意：当开启了 邮箱模式/服务器模式/文本模式 时， GUI 模式是关闭的，登陆时不会自动弹出二维码图片。\n\n每次登录时会创建一个二维码管理器 （ QrcodeManager 对象） ，二维码管理器会根据配置文件及命令行参数来选择二维码图片的显示方式。\n\n#### 配置文件的使用方法\n\n配置文件为 **~/.qqbot-tmp/v2.x.conf** （ **\\~** 代表用户主目录， win7 下为 C:\\\\Users\\\\xxx ， linux 下为 /home/xxx ），第一次运行 QQBot 后就会自动创建这个配置文件，其中内容如下：\n    \n    {\n    \n        # QQBot 的配置文件\n        # 使用 qqbot -u somebody 启动程序时，依次加载：\n        #     根配置 -> 默认配置 -> 用户 somebody 的配置 -> 命令行参数配置\n        # 使用 qqbot 启动程序时，依次加载：\n        #     根配置 -> 默认配置 -> 命令行参数配置\n        \n        # 用户 somebody 的配置\n        \"somebody\" : {\n            \n            # QQBot-term （HTTP-API） 服务器端口号（该服务器监听 IP 为 127.0.0.1 ）\n            # 设置为 0 则不会开启本服务器（此时 qq 命令和 HTTP-API 接口都无法使用）。\n            \"termServerPort\" : 8188,\n            \n            # 二维码 http 服务器 ip，请设置为公网 ip 或空字符串\n            \"httpServerIP\" : \"\",\n            \n            # 二维码 http 服务器端口号\n            \"httpServerPort\" : 8189,\n            \n            # 自动登录的 QQ 号\n            \"qq\" : \"3497303033\",\n            \n            # 接收二维码图片的邮箱账号\n            \"mailAccount\" : \"3497303033@qq.com\",\n            \n            # 该邮箱的 IMAP/SMTP 服务授权码\n            \"mailAuthCode\" : \"feregfgftrasdsew\",\n            \n            # 是否以文本模式显示二维码\n            \"cmdQrcode\" : False,\n        \n            # 显示/关闭调试信息\n            \"debug\" : False,\n    \n            # QQBot 掉线后自动重启\n            \"restartOnOffline\" : False,\n            \n            # 在后台运行 qqbot ( daemon 模式)\n            \"daemon\": False,\n            \n            # 完成全部联系人列表获取之后才启动 QQBot \n            \"startAfterFetch\" : False,\n            \n            # 插件目录\n            \"pluginPath\" : \".\",\n            \n            # 启动时需加载的插件\n            \"plugins\" : [],\n            \n            # 插件的配置（由用户自定义）\n            \"pluginsConf\" : {},\n        \n        },\n        \n        # 可以在 默认配置 中配置所有用户都通用的设置\n        \"默认配置\" : {\n            \"qq\" : \"\",\n            \"pluginPath\" : \"\",\n            \"plugins\" : [\n                'qqbot.plugins.sampleslots',\n                'qqbot.plugins.schedrestart',\n            ],\n            \"pluginsConf\" : {\n                'qqbot.plugins.schedrestart': '8:00',\n            }\n        },\n        \n        # # 注意：根配置是固定的，用户无法修改（在本文件中修改根配置不会生效）\n        # \"根配置\" : {\n        #     \"termServerPort\" : 8188,\n        #     \"httpServerIP\" : \"\",\n        #     \"httpServerPort\" : 8189,\n        #     \"qq\" : \"\",\n        #     \"mailAccount\" : \"\",\n        #     \"mailAuthCode\" : \"\",\n        #     \"cmdQrcode\" : False,\n        #     \"debug\" : False,\n        #     \"restartOnOffline\" : False,\n        #     \"daemon\" : False,\n        #     \"startAfterFetch\" : False,\n        #     \"pluginPath\" : \"\",\n        #     \"plugins\" : [],\n        #     \"pluginsConf\" : {}\n        # },\n    \n    }\n\n可以在配置文件中添加自己的用户配置（即在该文件的字典中新增一个 item ，此 item 的 key 就代表一个用户），例如，该文件中已有的 somebody 项目就代表名为 somebody 的用户，运行 QQBot 时，输入 **qqbot -u somebody** ，则会加载 somebody 项目下的各项配置。\n\n下面介绍配置文件中各项配置的功能，以下内容均假定已修改了 somebody 下的配置，且以 **qqbot -u somebody** 的方式运行。\n\n#### 邮箱模式的配置（ mailAccount 和 mailAuthCode ）\n\n如果需要使用邮箱模式显示二维码，可以将 mailAccount 和 mailAuthCode 项中分别设置为邮箱帐号和授权码，运行后，二维码管理器会将二维码图片发送至该邮箱。\n\n注意：授权码不是邮箱的登录密码，而是邮箱服务商提供的开通 **IMAP/SMTP** 服务的授权码（提醒：不是 **POP3/SMTP** 服务）， QQ/网易 邮箱可以在网页版的邮箱设置里面开通此项服务，并得到授权码。如果只定义了 mailAccount 而没定义 mailAuthCode ，则程序运行的开始时会要求手工输入此授权码。\n\n邮箱模式已在 QQ 、 网易 和 Google 邮箱中测试过。\n\n#### 服务器模式的配置（ httpServerIP 和 httpServerPort ）\n\n如果需要使用服务器模式，可以配置 httpServerIP 和 httpServerPort 项，一般来说应该设置为公网 ip 。服务器模式开启后，可以通过 http://{httpServerIP}:{httpServerPort}/{any} 来访问二维码图片。其中 {any} 可以是任何非空的数字或字母串。\n\n当邮箱模式和服务器模式同时开启时，发邮件时不会发送真正的图片，只会将图片地址发到邮箱中去，而且只发送一次，二维码过期时刷新一下邮件就可以了。如果只开启邮箱模式，则发邮件时会发送真正的图片，当二维码过期时，需要将邮件设置为已读（用手机 QQ 点开邮件后该邮件就是已读了），之后才会发送最新的二维码图片。\n\n#### 文本模式显示二维码（cmdQrcode）\n\n若 cmdQrcode 项设置为 True ，则会在 term 中以文本模式显示二维码。注意：要使用文本模式，需要自行安装 pillow 和 wcwidth 库，可使用 pip 安装。\n\n#### 自动登录的 QQ 号码（ qq ）\n\n配置文件中每个用户都有 qq 这一项，若此项已设置为某 QQ 号码，则 QQBot 在启动时会先使用此 QQ 号上次登录保存的登录信息来自动登录。\n\n#### 掉线后自动重启（ restartOnOffline ）\n\n如果配置文件中将 restartOnOffline 项设置为 True ，则当 QQBot 掉线或出错终止时，会自动重新启动 QQBot 。\n\n#### 在后台运行 qqbot （ daemon ）\n\n此选项仅在 UNIX 类系统中有效，将配置中的 daemon 选项设置为 True 则会以 daemon 模式运行程序。此时，标准输出和标准错误会重定向到 daemon-$qq.log 文件（其中 $qq 是配置中 qq 选项的值）。\n\n#### 联系人列表获取完成后再启动（ startAfterFetch ）\n\n一般情况下，扫码登录完成就立即启动 QQBot，只有在需要的时候才会去获取联系人列表并更新联系人数据库。如果将配置文件中的 startAfterFetch 设置为 True ，则 **QQBot 会等待所有联系人列表获取完成后才启动** ，注意，如果联系人较多，会耗费较长的时间。\n\n#### QQBot-term 服务器端口号（ termServerPort ）\n\nQQBot 启动后，会开启一个 QQBot-term 服务器监听用户通过 qq 命令行工具发过来的操作命令以及通过 HTTP API 接口发过来的操作命令，此服务器的监听 IP 永远为 127.0.0.1 ，监听端口号默认为 8188 ，可以通过修改 termServerPort 的值来修改此端口号。\n\n如果配置的 QQBot-term 服务器端口号不是默认的 8188 ，那么在运行 qq 命令时，需要在第一个参数中指定端口号，如：\n\n    $ qq 8100 send buddy jack hello\n    $ qq 8100 list group-member chatbot\n\n同样，HTTP API 接口的端口号也需要改变，如： http://127.0.0.1:8100/send/buddy/jack/hello 。\n\n如果不需要使用 qq 命令和 HTTP-API 接口，可以将此端口号设置为 0 ，此时 QQBot-term 服务器不会开启。\n\n如果需要在同一台机器上登录多个 QQ 号码，可以直接在不同的终端中开启多个 qqbot 进程进行登录，但是，每个 qqbot 进程必须设置专有的 termServerPort 和 httpServerPort （或者全部设置为 0 或 空值 ），否则会造成端口号冲突。\n\n#### 调试模式（ debug ）\n\n若 debug 项设置为 True ，则运行过程中会打印调试信息。\n\n#### 插件的配置（ pluginPath 和 plugins ）\n\n一般情况下，插件需要存放在系统的 import 目录下或 \\~/.qqbot-tmp/plugins 目录下，可以在 pluginPath 选项中配置其他的存放目录。另外，在 plugins 选项中可以指定 QQBot 启动时需要加载的插件。\n\n#### 命令行参数及配置的优先级\n\n配置文件中的所有选项都有对应的命令行参数，在命令行参数中输入的选项优先级比配置文件高。输入 **qqbot -h** 可查看所有命令行参数格式。\n\n程序一共有四个级别的配置，其优先级如下：\n\n    使用 qqbot -u somebody 启动程序时，依次加载：\n        根配置 -> 默认配置 -> 用户 somebody 的配置 -> 命令行参数配置\n\n    使用 qqbot 启动程序时，依次加载：\n        根配置 -> 默认配置 -> 命令行参数配置\n\n其中：根配置 是固定的，用户无法修改； 默认配置 和 用户配置 可由用户在 v2.x.conf 文件中进行修改；最后，还可以在 命令行参数 中输入配置。\n\n#### 工作目录\n\nqqbot 运行时，会在 工作目录 下 搜索/创建 以下 文件/目录 ：\n\n+ 配置文件： v2.x.conf\n+ 插件目录： plugins/\n+ 登录文件： v2.x-pyx-xxxx.pickle\n+ 联系人数据库文件： 2017-05-06-20-03-12-xxxx-contact.db\n+ 临时二维码图片： xxxx.png\n+ 保存QQ的文件： qq(pid9816)\n+ 以 daemon 模式运行时的 log 文件： daemon-xxx.log\n\n默认的工作目录为 \\~/.qqbot-tmp/ ，可以在启动 qqbot 时通过命令行参数 -b|--bench 指定其他工作目录，例如： qqbot -b bench 。\n\n八、 插件\n-------------------------\n\n#### 插件的存放位置\n\n插件实际上是一个 python 模块，因此可以是一个 python 文件，也可以是一个 python package。 qqbot 会根据插件名在以下目录中搜索插件：\n\n+ 配置中的 pluginPath 选项（命令行参数 -pp|--pluginPath ）指定的目录\n+ 工作目录下的 plugins 目录\n+ python 的导入目录\n\n#### 插件的加载/卸载\n\n**hot-plug 方式**\n\n可以在 qqbot 的运行过程中动态的加载/卸载插件，有以下三种方法：\n\n+ 利用 qq 命令行工具： qq plug pluginname 或 qq unplug pluginname\n+ 利用 http-api 接口： http://127.0.0.1:8188/plug/pluginname 或 http://127.0.0.1:8188/unplug/pluginname\n+ 利用 bot 对象的接口： bot.Plug('pluginname') 或 bot.Unplug('pluginname')\n\n前面两种方法是供 qqbot 进程的外部进程调用的，第三种方法是在 qqbot 进程内部使用的。请勿在 qqbot 进程的内部使用前面两种方法。\n\n注意：采用 hot-plug 方式加载的插件在 qqbot 重启后会丢失。\n\n**auto-plug-at-start 方式**\n\n也可以在 qqbot 的启动时自动加载插件，在配置中的 plugins 选项（命令行参数 -pl|--plugins ）中指定需要加载的插件名就可以了。这些插件将在启动时、登录之前被加载。\n\n另外，如果系统中（或插件目录中）存在名为 **qqbotdefault** 的 package ，那么该 package 下面的所有子模块都会被当成插件在启动时自动加载（注意：qqbotdefault 本身不会作为插件加载）。\n\n#### 插件内的 onPlug 和 onUnplug 回调函数\n\n+ 插件被加载时，会执行 reload(pluginName) ，因此插件内的所有代码都会被执行一次\n+ 当采用 hot-plug 的方式加载时，插件内的 onPlug 函数会紧接在 reload 成功后被执行\n+ 当采用 auto-plug-at-start 方式加载时，插件在启动时、登录之前被加载，但插件内的 onPlug 函数会延迟到登录成功后才被执行\n+ 插件被卸载时，插件内的 onUnplug 被执行\n\n#### 插件的编写\n\n编写插件主要就是编写回调函数或定时任务函数，详见 [第四~六节](https://github.com/pandolia/qqbot#%E5%9B%9B%E5%AE%9E%E7%8E%B0%E4%BD%A0%E8%87%AA%E5%B7%B1%E7%9A%84-qq-%E6%9C%BA%E5%99%A8%E4%BA%BA) 。\n\n#### 插件列表\n\n|名称                |github作者    | 功能说明                 | 是否默认加载                 \n|:-------------------|:-------------|:----------------------------|:----------------------------\n|[qqbot.plugins.sampleslots](https://github.com/pandolia/qqbot/blob/master/qqbot/plugins/sampleslots.py)             |[pandolia](https://github.com/pandolia)       |回调函数示例       |是\n|[qqbot.plugins.schedrestart](https://github.com/pandolia/qqbot/blob/master/qqbot/plugins/schedrestart.py)             |[pandolia](https://github.com/pandolia)       |定时重启       |是\n|[qqbot.plugins.miniirc](https://github.com/pandolia/qqbot/blob/master/qqbot/plugins/miniirc.md)             |[pandolia](https://github.com/pandolia)       |IRC服务器       |否\n|[passwordlogin](https://github.com/pandolia/qqbot/blob/master/qqbot/plugins/passwordlogin.py)             |[pandolia](https://github.com/pandolia)       |使用用户名-密码登录      |否\n|[adblock](https://github.com/feisuweb/qqbot-plugins/tree/master/adblock.py)             |[feisuweb](https://github.com/feisuweb)       |群广告拦截       |否\n|[chatlog](https://github.com/feisuweb/qqbot-plugins/blob/master/chatlog.py)             |[feisuweb](https://github.com/feisuweb)       |聊天内容记录       |否\n\n如果您有好用的插件分享，欢迎发邮件给我。\n\n九、 命令行模式下使用 IRC 聊天\n----------------------------\n\nlinux 系统下，由于无法使用 QQ 客户端，可以使用插件 qqbot.plugins.miniirc 来实现用 IRC 聊天的功能。加载方式： qq plug qqbot.plugins.miniirc ，或启动时加载： qqbot -pl qqbot.plugins.miniirc ，或者在配置文件中的 plugins 选项中加入 `qqbot.plugins.miniirc` 。\n\n插件加载后将在 6667 端口开启一个微型的 IRC 服务器，用户可以使用 IRC 客户端（如 weechat, irssi 等）连接此服务器来实现命令行模式下的聊天。以下以 weechat 为例介绍使用方法：\n\n    启动 weechat ： weechat\n\n    连接本服务器： /connect localhost\n\n    进入 群聊天 会话： /join group-name\n\n    进入 讨论组聊天 会话： /join !discuss-name\n\n    进入 好友聊天 会话： /query buddy-name\n\n    进入 聊天会话 后，直接敲入文本并回车就可以向对方发送消息了。所有接收到的 QQ 消息也会被转发给相应的 聊天会话 。\n\n    在聊天会话之间切换： ctrl+P 或 ctrl+N\n\n    显示所有 群和讨论组 的名称： /list\n\n以上几乎就是此微型 IRC 服务器所提供的所有功能了，但已经足够用来和 QQ 好友/群/讨论组 聊天了。\n\n十、 smartqq 协议支持及限制\n-------------------------\n\n#### 本项目已实现绝大部分 smartqq 协议支持的功能，如下：\n+ 消息收/发\n+ 联系人（包括 好友/群/讨论组/群成员/讨论组成员）资料获取和查询（包括 昵称/名称/备注名）\n+ 联系人资料根据需要动态更新\n+ 被群内其他成员 @ 的通知\n+ 发送、接收表情（详见 [facemap.py](https://github.com/pandolia/qqbot/blob/master/qqbot/facemap.py)）\n+ 可以获取到自身发送的 好友/群/讨论组 消息。但若是自身发送的 好友 消息，只能获取消息文本，无法知道该消息发送给谁。\n\n#### 其他功能：\n+ 调用系统默认图片浏览器显示登录二维码、将登录二维码发送至邮箱、开启一个 http 服务器用来显示登录二维码、在命令行窗口使用文本模式显示二维码\n+ 用 qq 命令行工具发消息、查询|更新联系人\n+ 提供 HTTP-API 接口发消息、查询|更新联系人\n+ 提供 miniirc 插件，可以在命令行模式下使用 IRC 客户端聊天\n+ 掉线后自动重启功能（有时需要手工扫码）\n+ 定时执行任务（通过 qqbotsched 实现）\n\n#### 因 smartqq 协议的限制，以下问题尚无完美的解决方法：\n+ 无法长时间保持在线状态，每次登录成功后的 cookie 会每在 1 ~ 2 天后失效，将被腾讯服务器强制下线，此时 **必须** 重新登录。可以打开邮箱模式和自动重启模式，并配合 qqbot.plugins.schedrestart 插件使用，每天在固定的时间 **手工扫码** 登录一次，基本上可以稳定的保持在线状态。\n+ 无法发送图片、文件、音频、 xml 卡片消息\n+ 无法获取到联系人的实际 QQ\n+ 无法在群内 @ 其他成员，即便用本程序在群里发送了 “@jack xxx” 这样的消息， jack 也只能收到这个纯文本，收不到“有人@我”的提醒。\n+ 无法向 群/讨论组 内的其他非好友成员发消息，也无法收到非好友成员发过来的临时会话消息\n+ 在非常少的情况下，发消息时会重复发送多次，也可能对方已收到消息但返回发送失败的结果\n\n十一、其他\n-------------\n\n- [常见问题](https://github.com/pandolia/qqbot/blob/master/faq.md)\n- [更新日志](https://github.com/pandolia/qqbot/blob/master/changes)\n\n十二、参考资料\n-------------\n\nQQBot 参考了以下开源项目：\n\n- [ScienJus/qqbot](https://github.com/ScienJus/qqbot) (ruby)\n- [floatinghotpot/qqbot](https://github.com/floatinghotpot/qqbot) (node.js)\n- [sjdy521/Mojo-Webqq](https://github.com/sjdy521/Mojo-Webqq) (perl)\n\n在此感谢以上三位作者的无私分享，特别是感谢 ScienJus 对 SmartQQ 协议所做出的深入细致的分析。\n"
        },
        {
          "name": "autotest.py",
          "type": "blob",
          "size": 0.0625,
          "content": "# -*- coding: utf-8 -*-\n\nfrom qqbot import AutoTest; AutoTest()\n"
        },
        {
          "name": "changes",
          "type": "blob",
          "size": 25.359375,
          "content": "2018-1-19 qqbot v2.3.10\n1） 修复Poll协议变更引起的错误\n\n2018-1-13 qqbot v2.3.9\n1） 修复Poll协议变更引起的错误\n\n2018-1-4 qqbot v2.3.8\n1） 因腾讯关闭了 qun.qq.com 的接口，已无法获取到 好友/群/群成员 的真实 QQ ，故删除了相关的请求代码。\n2） passwordlogin 插件中增加输入框 clear 的代码。\n3） 二维码服务器监听 ip 改为 0.0.0.0 。\n\n2017-11-1 qqbot v2.3.7\n1） 修正miniirc插件的bug，感谢@ferocknew\n2） 修正bot.isMe的bug\n\n2017-10-27 qqbot v2.3.6\n1） 增加 bot.isMe 方法，用于判断是否是自己发的消息\n\n2017-07-23 qqbot v2.3.5\n1） 增加一个 qqbot.plugins.addqqcmd 示例插件，如果需要扩展 qq 命令（比如增加一个自定义命令 qq mycommand xxx），可以参照此插\n    件的代码。\n\n2） 修正最新版 requests 下无法找到 urllib3 模块的 bug ，感谢 @feiyuw 提供代码。\n\n3） 邮箱模式中增加对 网易邮箱 的支持，感谢 @shadowsong91 的帮助。\n\n2017-07-02 qqbot v2.3.4\n\n1） 修正多行消息直接发送给 IRC 客户端的 bug\n\n2017-07-02 qqbot v2.3.3\n\n1） 增加 --daemon 选项，在 UNIX 类系统中可以将 qqbot 放到后台运行，即便控制台窗口关闭也不会停止运行。\n\n2） 修正某些系统下 socket-server 出现 accept-timeout 的错误。\n\n3） 修改 pickle 文件的命名为：v2.x-pyx-xxx.pickle 。\n\n4） 增加 CronTrigger 引用，规避打包时的潜在 bug 。\n\n5） 增加一个插件： qqbot.plugins.miniirc ，可在 linux 系统中使用 IRC 客户端和 QQ 好友/群/讨论组 聊天，\n    详见 https://github.com/pandolia/qqbot/blob/master/qqbot/plugins/miniirc.md 。\n    感谢 @sjdy521 的大力帮助。\n\n\n2017-06-13 qqbot v2.3.2\n\n1） 原 onExpire 扩充为 onExit 函数，在 QQBot 停止、重启、登录过期、未知错误时被调用。原 onExpire 被删除。\n\n2） 修改默认插件 sampleslots 中的 onQQMessage 函数，该函数仅回复自己在群内发的 “--version” 。\n\n3） 修改文档中 qqbotsched 的 day_of_week 参数说明， 0 代表周一， 6 代表周日。\n\n4） 增加功能： QQBot-term 服务器端口号设置为 0 时，将不会开启此服务器。\n\n5） 修正 “因协议更改引起的部分表情被解析为 /惊讶 \" 的错误。\n\n2017-06-11 qqbot v2.3.1\n\n一、主要修改：\n\n1） 整理了程序的运行流程图，增加了 onInit/onQrcode/onUpdate/onPlug/onUnplug/onExpire 事件。请对照运行流程图查看各事件的\n    发生时机。\n\n2） 修改 QQBot 类的内部代码，将所有 classmethod 改写为 instancemethod 。采用单例模式运行，整个进程只有一个 QQBot 实例对象，\n    该对象保存在 qqbot._bot 或 qqbot.QQBot._bot 中。用户无法调用 bot = QQBot() 来创建其他实例，只能通过\n     from qqbot import _bot 的方式获得这个实例。\n\n3） 修改 RunBot 函数的参数，该函数只接受一个 argv 参数（v2.2版中该函数接受三个参数 botcls, qq, user），因此原来采用类继承扩\n    展 qqbot 的方式已无法使用了。修改 QQBot.Login 方法的参数，原来的参数为 qq, user ，现在只有一个参数 argv 。\n\n    可以在 argv 参数中输入命令行参数，比原来的 qq,user 参数功能更强大。所有配置选项都可以在 argv 中输入。如果不提供 argv ，则\n    会使用 sys.argv[1:] 。如：\n\n        bot.Login()\n        bot.Login(['-u', 'somebody', '-r', '-d'])\n\n4） 将原 qslots.py 中的 回调函数 分离出来，移到 qqbot/plugins/sampleslots.py 中，qslots.py 中仅保留 onTermCommand 函数，\n    且其文件名重名为 termbot.py 。\n\n    新增两个默认插件： qqbot.plugins.sampleslots, qqbot.plugins.schedrestart 。\n\n    增加一个功能：如果存在 qqbotdefault 的 package ，那么该 package 下的所有子模块会在 qqbot 启动时自动加载。\n\n5） 修正某些 linux + python3 环境下用 root 用户运行时的中文编码错误，感谢 @Ninzero 反馈。\n\n6） 讨论组成员增加 qq 属性，感谢网友 Fury 3 的帮助。\n\n7） 修正某些情况下重启时无法读取到上次运行的登录 QQ 的bug 。\n\n8） 修改完善文档。\n\n二、v2.2版迁移说明：\n\n本次升级并非 webqq 协议变更引起的，目前原 v2.2 版还能继续稳定使用，因此 v2.2 版的用户可以暂时不升级。\n\n迁移之前需要将 v2.2.conf 重命名为 v2.3.conf ，并在文件中的 plugins 选项中增加 2 个默认插件：['qqbot.plugins.sampleslots',\n'qqbot.plugins.schedrestart']，如果不需要也可以不增加。\n\n（1） 插件模式\n\nv2.2版中，如果是采用插件模式扩展 qqbot ，那么绝大部分情况下程序无需改动就可以在 v2.3 版中使用。仅仅要注意：如果插件设置为启动时自动加\n载，那么加载时间会提前至登录前（原来是登录成功后才加载），但插件中的 onPlug 函数会延迟到登录成功后才被调用，因此原插件内的最外层的初始化\n代码如果调用了 bot.List/SendTo 等接口，那么需要将这些代码移到 onPlug 函数内，例如，如果原插件 xxx.py 中最外层的代码有：\n\nfrom qqbot import QQBot; bot = QQBot._bot\nbl = bot.List('buddy', 'jack')\nif bl:\n    bot.SendTo(bl[0], 'plug')\n\n需要修改为：\n\ndef onPlug(bot):\n    bl = bot.List('buddy', 'jack')\n    if bl:\n        bot.SendTo(bl[0], 'plug')\n\n当然，如果是登录后采用 hot-plug 的方式加载，那么原来的代码不修改也可以运行。但为了统一 hot-plug 和 auto-plug-at-start 的行为，建议\n还是按以上型式进行修改。\n\n（2） 类继承模式或 RunBot\n\n采用类继承方式扩展 QQBot 的方式已经废弃， RunBot 函数也已修改，请按插件模式改写代码。如果需要在 IDE 或 python-shell 里面测试，可参见\n文档第五节。\n\n另外请注意：由于 RunBot 函数中调用了 Popen(sys.argv) 重启整个程序，因此该函数在 IDE 或 python-shell 中运行可能会出问题。只能直接在\n脚本文件中运行。\n\n（3） 其他模式\n\n如果使用了 qqbot 的内部代码，需要注意 QQBot 类的内部代码有较大的改变，且不允许用户自己调用其 __init__ 函数来构造 QQBot 实例（如：\nbot = QQBot() ），需要使用 from qqbot import _bot 来得到这个全局唯一的 QQBot 实例。\n\n另外需要注意， Runbot 函数和 QQBot.Login 方法的参数都变了。\n\n2017-05-26 qqbot v2.2.19\n1） 因协议调整，修正“群内禁言消息误报为自己发的消息”的问题。\n\n2017-05-25 qqbot v2.2.18\n1） 因协议调整， poll 消息时不再忽略 1202 代码。\n2） 修正 setup.py 中的 bug ，（此 bug 导致需要手动安装依赖后，才能安装本程序）。\n3） 修正 python3 下 qq 命令出错的 bug ， 感谢 @007pig 反馈。\n\n2017-05-24 qqbot v2.2.15\n1） 去掉 flask ，采用简单的 socket server 来显示二维码。\n2） 因 webqq 协议调整，已可收到自己通过其他客户端发送的群消息。\n3） 修正指定插件目录的路径名中存在中文时的编码错误问题，感谢网友 Accept 反馈\n\n2017-05-17 qqbot v2.2.14\n1） 修正群内 全体禁言/解除全体禁言 通知到来时强制进行群成员更新的 bug。\n2） 修正 fetch.fetchGroupTable 和 QContactDB.find 中的 bug ，感谢网友 ★匆匆★ 反馈。\n\n2017-05-16 qqbot v2.2.13\n1） 增加 patchfetch 插件 。\n2） 增加插件详细说明及插件列表，感谢 @feisuweb 分享插件\n3） 修正群内 禁言/解除禁言 通知到来时强制进行群成员更新的 bug\n4） pycharm-loader.py 增加了对插件模式的调试的支持， 感谢 @SuperMarioSF\n5） bot 对象增加 started 属性，插件可通过检查 QQBot._bot.started 来确定本插件是在启动时被加载，还是在启动后被加载。\n\n2017-05-15 qqbot v2.2.12\n1） 腾讯又将好友列表和群成员列表的接口调整回 5 月 12 日之前的模式了，因此 fetch.py 中的代码相应调整回 v2.2.9 。\n\n2017-05-14 qqbot v2.2.11\n1） 修改 pycharm-loader.py 文件，感谢 @SuperMarioSF \n2） 修正小部分情况下自动重启时无法读取到上次运行的 qq 号码的 bug （此 bug 几乎不影响使用）\n\n2017-05-12 qqbot v2.2.10\n1） 根据测试结果， poll 消息时不再忽略 103 代码。\n2） 绝大部分情况下，所有好友以及所有群成员的 qq 都可以绑定了，也就是说：绝大部分情况下， onQQMessage 中的 contact.qq 或 member.qq 都是有效的 QQ 号码。\n    感谢腾讯更改协议， webqq 可直接返回已绑定的 qq-uin 。\n3） 本次更改协议的副作用：好友的 nick 属性和 mark 属性都不再有意义了（暂时），这两个属性永远都是 '#NULL' ，但可以使用好友的 name 属性。\n    如果有网友的机器人程序利用了这两个属性，需要修改代码。\n\n2017-05-11 qqbot v2.2.9\n1） 修正某些 linux 系统下 python2 下 sqlite3 数据库文件路径 bug ，感谢 lang 反馈问题。\n2） 根据测试结果， poll 消息时不再忽略 100001 代码，但忽略 103 代码。\n3） 当 poll 消息时收到未知代码时，先运行一次 session.TestLogin() ，只有在测试未通过时才会真正的停止本次 QQBot 的运行。\n\n2017-05-07 qqbot v2.2.8\n1） 忽略 poll 返回 100001 代码。\n2） 修正 python2 下 sqlite3 数据库文件不支持中文路径的 bug 。\n\n2017-05-06 qqbot v2.2.7\n1） 二维码邮件内容中增加 conf.user 和 conf.qq ，方便区分是哪个用户登录时发送的二维码邮件。\n2） 二维码 url 地址改为 http://{httpServerIP}:{httpServerPort}/{any} 其中 {any} 可以是任意的字母或数字组成的字符串。\n3） 修正 Partition 函数中 utf8 分割的 bug\n4） QTERM 服务器单次请求内容长度由 1024 改为 8192\n5） 修正自动登录时当 session.session.verify == False 时没有隐藏 https warning 的 bug\n6） poll 加入 Ejimo 字符转义，感谢 @NineLucas 分享代码\n7） 修正 windows-py3-idle 中 sys.stdout 不存在 buffer 属性的情况下无法运行的 bug\n8） 命令行参数中增加 -b|--bench 选项，用来指定工作目录。默认的工作目录为 ~\\.qqbot-tmp\\ 。\n\n2017-05-02 qqbot v2.2.6\n1） 修正 http 二维码服务器需要刷新的 bug ，二维码的 url 地址改为： http://{httpServerIP}:{httpServerPort}/{pngid} 。感谢 @huangzk 反馈\n\n2017-04-27 qqbot v2.2.5\n1） http-api 返回成员列表的 json 中增加成员的 ctype 属性。\n2） 执行 list 命令时，采用 prettytable 打印成员列表。感谢网友 chx 提供帮助。\n3） 改正文档中的几处笔误，感谢网友 繁星 等人反馈问题。\n4） 缩小文本二维码的大小，感谢 @kairyu\n\n2017-04-25 qqbot v2.2.4\n1） 忽略 poll 返回 1202 代码。\n2） 修正 qconf.py/qsession.py 中 python2 处理中文路径的 bug\n\n2017-04-22 qqbot v2.2.3\n1） 修正 list 查询或搜索时存在的 bug 。如 qq list discuss card=x 会报 <class 'sqlite3.OperationalError'>no such column: card 的错误，因为 discuss 不存在 card 属性。\n\n2017-04-21 qqbot v2.2.2\n1） list 等命令/接口的参数增加 :like: 字段，提供强大的联系人搜索功能。示例：\n\n    # 列出名称中含有 “李” 的好友\n    qq list buddy :like:李\n\n    # 列出 QQ 中含有 “234” 的群\n    qq list group :like:234\n\n    # 列出备注名中含有 jack 的好友\n    qq list buddy mark:like:jack\n\n    # 列出 群“456班” 的中名称中含有 “李” 的成员\n    qq list group-member 456班 :like:李\n\n    # 列出 群“456班” 中名片中含有 “mike” 的成员\n    qq list group-member 456班 card:like:mike\n\n    # 列出的 讨论组“xx小组” 中名为 jack 的好友\n    qq list discuss-member :like:小组 jack\n\n2017-04-21 qqbot v2.2.1\n1） 基本上修复了因 get_friend_uin2 接口被关闭而引起的一系列问题。但当 好友/群/群成员 存在同名现象或名称中含特殊字符时，还是存在无法绑定其实际 QQ 的问题。\n\n2） 由于 smartqq 中获取联系人列表的接口实在太不稳定了，因此关闭后台联系人获取，联系人列表只有在需要用到的时候才会去请求相应的接口获取列表并更新至联系人数据库内。由此取消了 onNewContact 、 onLostContact 和 onFetchComplete 三个回调函数，并取消了 fetchInterval 和 monitorTables 两个配置选项。\n\n3） 整理、优化联系人列表和资料的数据结构，并采用 sqlite3 数据库保存联系人列表和资料。增加联系人的各属性的详细解释，同时，各属性不再不加区分的保存为 str 对象，而是根据需要保存为 str 对象和 int 对象。\n\n4） 利用原 2.1 版开发的机器人程序需要进行以下改动：\n\n    1. ~\\.qqbot-tmp\\ 目录下的配置文件名应改为 v2.2.conf ，并删除其中的 fetchInterval 和 monitorTables 选项\n\n    2. 删除机器人程序中的 onNewContact 、 onLostContact 和 onFetchComplete 三个回调函数。如果确实需要 onFetchComplete ，可将其中的代码放到 onStartupComplete 中，并将启动方式设置为 “联系人列表获取完成后再启动” （将 startAfterFetch 选项设置为True）。\n\n    3. 根据联系人对象（ QContact 对象）的各属性的类型和含义的变化对原有的代码进行调整。\n\n2017-04-17 qqbot v2.1.21\n1） 修正 onTermCommand 中 PY3 中 Reply('') 的 bug\n\n2） 因原有的 获取联系人实际 QQ （get_friend_uin2 ） 接口 已无法使用，因此暂时不去调用此接口（由此导致了无法获取到群成员资料的问题）。\n\n2017-04-17 qqbot v2.1.20\n2017-04-15 qqbot v2.1.19\n1） 修正 v2.1.17 中 PY3 中消息分段函数中的 bug\n\n2017-04-14 qqbot v2.1.17\n1） 修正 v2.1.16 中 QContact 类增加 getattr 方法导致无法被 pickle 的 bug ，感谢 @lixindreamer 不二 kairyu 的帮助\n\n2） 优化消息分段，一次发消息内容最长为 240 个汉字或 720 个英文，也就是 utf8 编码后的长度不能超过 720 ，超过此长度将被分段，按以下原则分段：如果 620~720之间有空格字符（空格，\\t，\\n等），则按最后一个空格进行分割，否则，按 720 进行分割。\n\n3） QQBot 类中将判断是否被 @ 的功能分离出来，放到 detectAtMe 方法中，如果需要实现自己的 @ 判断逻辑，可以覆盖此方法。\n\n4） bot.SendTo 接口中增加一个参数： reSendOn1202 ，若此参数为 True （默认值），则发消息时如果 QQ 服务器返回 1202 代码（表明发消息可能失败），还会继续发送 3 次，直至返回 0 代码， 若此参数为 False ，则不会尝试重发。\n设为 True 在绝大部分情况下能保证消息一定能发出去，但缺点是有时一条消息会重复发送。设为 False 则相反，消息不会重复发送，但有时消息发送不出去。\n总之因为这个 1202 代码的不确定性，没有完美的解决办法。\n\n5） 配置文件中增加一个 pluginsConf 项，用户可以在此项中保存自己的配置，在运行的过程中通过 bot.conf.pluginsConf 访问， qqbot 会在启动时自动读取这里面的配置。\n\n6） 增加一个 fresh-restart 命令，此命令重启程序且不加载 pickle 文件（必须手动扫码）。修改原来的 restart 命令的重启方式，此命令重启程序，且会加载 pickle 文件。\n\n2017-04-13 qqbot v2.1.16\n1） 恢复群管理功能（踢人、设置群名片、设置|取消管理员），再次感谢 @waylonwang ，他提供了用 qinfo.clt.qq.com 的接口实现上述功能的代码。\n\n2） 修正踢人和设置群名片成功后更新缓存的过程中的 bug 。\n\n3） 增加 update 命令及相关接口， qq update buddy 可以强制更新好友列表\n\n\n2017-04-12 qqbot v2.1.15\n1） 昨天开始，由于 qun.qq.com 的 search_group_members 接口无法使用 w.qq.com 的 cookie，因此无法获取群成员列表，由此导致了所有和群成员相关的功能都无法使用了（包括 list group-member, group-manage, @me 等）。非常感谢 @waylonwang 迅速的提供了用 qinfo.clt.qq.com 的接口获取群成员信息的代码，完美的修复了此问题，目前所有相关功能都已恢复正常使用，另外还带了一个好处就是现在可以获取到完整的群名片（以往群名片如果太长会被截断）。\n\n2） 增加了后台获取联系人的间歇时间，每个列表获取完后 sleep 15 秒，所有列表获取完后 sleep 至少 10 分钟。另外，建议暂不要使用 特别监视列表 的功能，避免过于频繁的在后台获取联系人， @lixindreamer 反映开启此功能后 python 的内存占用不断增大，尚不清楚是否确实是程序引起的问题。\n\n3） 测试发现 qun.qq.com 中的 群管理接口中除了 禁言 功能外，其他功能也无法使用了。因此在文档中注明了这些功能暂无法使用。相关的代码暂未删除。\n\n4） 成员属性不再全部保存为 str ，而是根据需要保存为 str ， int 或 boolean\n\n5） 修复了 python3.4 下无法使用 b'%s' % 'xxx' 的 bug\n\n2017-04-07 qqbot v2.1.14\n1） 增加群内成员的扩展属性， 感谢 @SuperMarioSF\n2） 增加 Windows 下用 virtualenv+pyinstaller 打包的说明，见 faq.md\n3） 完善 HTTP-API 接口的 response ，所有 HTTP-API 的 response 均采用 json 格式\n\n注意： 可能是 qun.qq.com 的协议有变，目前 GroupSetAdmin 和 GroupKick 已无法使用，因此请暂时不要使用这两个命令及相应接口。\n\n2017-04-05 qqbot v2.1.13\n1） 修正部分终端文本模式显示二维码无法扫码的问题，感谢 @xrdavies \n2） 增加一个函数装饰器 QQBotSched ，提供强大的定制定时任务的功能\n\n2017-04-04 qqbot v2.1.12\n1） 增加 HTTP API 接口，可供 web 前端开发者调用\n2） 增加 文本模式显示二维码 的功能，感谢 @xrdavies \n\n2017-04-02 qqbot v2.1.11\n1） 修正 python2.7 下命令行中 -mt 选项不能输中文的bug。\n2） 大部分 log 信息的级别由降低至 DEBUG ，在调试模式关闭的情况下，控制台输出的 log 更加清爽。\n3） 更新 pycharm-loader.py，在其中提供了一些调试用的示例。 感谢 @SuperMarioSF 提供此文件。\n4） 增加“用插件形式扩展QQBot”的功能，插件可以在 QQBot 的运行过程中动态的加载和卸载，可以同时加载多个插件。建议尽量采用插件的形式来扩展 QQBot 。\n5） 第一次运行时将显示已创建默认配置文件的信息。\n6） 整理了配置文件的级别，目前的配置优先级更加明确，也更加方便，具体来说：\n\n    使用 qqbot -u somebody 启动程序时，依次加载：\n        根配置 -> 默认配置 -> 用户 somebody 的配置 -> 命令行参数配置\n\n    使用 qqbot 启动程序时，依次加载：\n        根配置 -> 默认配置 -> 命令行参数配置\n\n根配置 是固定的，用户无法修改； 默认配置 和 用户配置 可由用户在 v2.1.conf 文件中进行修改；最后，还可以在 命令行参数 中输入配置。\n\n可能有少量网友注意到了之前的版本中，RunBot 函数和 QQBot 类构造方法可以接受 qq 和 user 两个参数，这两个参数的优先级比命令行参数都要高。请注意：这个功能只是为了方便测试用的，请大家尽量不要利用此功能（测试除外），原因如下：1. 很容易把用户搞混，因为一般的概念是命令行参数的配置优先级最高；2. 在源代码中来设置配置是一个很坏的习惯，因为其他用户无法看到这个配置、也无法修改这个配置。\n\n2017-03-30 qqbot v2.1.10\n1） 增加 “需要特别监视的列表（ monitorTables ）” 的选项，将需要关心的群加入到此项中，此群中的成员变动通知的滞后时间可以大幅缩短（最好的情况下可以缩短至 1~3 秒）。\n\n2017-03-30 qqbot v2.1.9\n1） 增加 “联系人列表获取完成后再启动 QQBot （ startAfterFetch ）” 的选项\n2） 修复 smartRequest 方法中的 bug ，感谢 @chenhouwu 反馈\n3） 增加 “用于在JetBrains PyCharm IDE环境下进行开发时的一个启动文件” ，感谢 @SuperMarioSF 提供此文件\n4） 增加 requirements.txt ，感谢 @gtt116\n\n2017-03-29 qqbot v2.1.8\n1） 修复了 fetchGroupTable 中一个隐藏的很深的 bug ，此 bug 可能导致群的 qq 号获取错误，进而引起一系列的成员获取错误等问题。感谢 SuperMarioSF 的大力支持和帮助调试程序。\n2） 当 fetchInterval 设置为负数时，只进行一次联系人列表获取，且此时 QQBot 延后至联系人资料获取完了再启动。\n3） 完善表情代码，感谢 刘洋 精心整理的更全的表情代码。\n\n2017-03-26 qqbot v2.1.7\n1） 获取群成员列表时不再绑定uin和qq，只在需要时进行绑定。原来 1880 人的群需要 3 分钟采用获取完成员列表，修改后只需 3 秒。\n    由此也修复了原来接收消息、执行命令卡死的 bug 。\n再次感谢 SuperMarioSF 帮忙测试和反馈，没有他，这个 bug 可能很久以后才能被发现。\n\n\n2017-03-25 qqbot v2.1.6\n1） 修正 facemap.py 中的bug\n2） 修正 python3 下 qsession.py 文件中迭代字典的 items() 过程中修改字典的bug\n3） 修正 qqbotcls.py 中 QQBotSlot 函数中的 bug\n4） 加长每个联系人列表 fetch 之间的间隔时间至 20 ~ 30 秒，避免执行命令卡顿\n5） 如果联系人列表更新时间比上次更新超过 1 个小时，则不调用 onNewContact 和 onLostContact 了\n感谢 SuperMarioSF 帮忙测试和反馈。\n\n\n2017-03-24 qqbot v2.1.4\n1） 用命令行发消息时可以使用 \"\\n\", \"\\t\" 等转义字符。\n2） 增加两个 slot ： onStartupComplete 和 onFetchComplete 。\n3） 增加一个选项 -fi,--fetchInterval ，用来设置每轮联系人列表刷新之间的间隙时间，如果设置为 -1 ，则只会进行一次联系人列表获取。\n4） 增加群管理（设置管理员 、 设置群名片 、 群成员禁言 以及 踢除群成员）功能。\n5） 增加发送表情功能，感谢 @sjdy521 精心整理的表情代码表。\n6） 命令行的 help 文档改用中文，感谢 SuperMarioSF 精心制作的中文文档。\n\n\n2017-03-23 qqbot v2.1.3\n1） 修正“群名中含某些特殊字符时无法获取到其真实qq，进而无法获取到其成员列表”的bug。感谢网友  SuperMarioSF 和 某10 的帮助和反馈。\n\n\n2017-03-22 qqbot v2.1.2\n1） 细化文档，增加 List 接口返回值的含义说明；增加 QContact 对象的 nick/mark/card/name 的属性的含义说明。\n2） 增加针对 “获取好友列表有时返回的json中没有备注名列表” 的情况的处理。\n\n\n2017-03-20 qqbot v2.1.1\n2.1 版在 2.0 版的基础上再次进行大量的重构，功能加强，运行更加稳定，修正了几个 bug ，但不再兼容 2.0 版的接口。主要修改如下：\n1） 联系人资料获取和查询功能加强，可获取到联系人的 QQ号/昵称/名称/备注名/群名片 。群内非好友的 QQ 号也可以获取到。\n2） 联系人资料实时更新，增加 新增/失去 联系人的事件通知。\n3） 将启动速度加快到极致， 扫码后 10 秒内可启动 QQBot 。 2.0 版需要获取完所有联系人资料才会启动 QQBot ，新版登陆成功后立即启动 QQBot ，同时在后台开始获取联系人资料。当联系人资料获取尚未全部完成时收到 QQ 消息或 list/send 命令，会主动获取所需的联系人资料，因此 QQBot 刚启动时收到新消息或 list/send 命令会稍微卡顿 1~2 秒。\n4） 修正联系人资料获取中的 bug ，联系人资料获取更加稳定；修正程序掉线时有时无法自动重启的 bug ；修正 windows 下用某些图片浏览器弹出二维码后程序一直卡在等待图片窗口关闭的 bug 。\n5） 修改 qq 命令行工具的命令及格式，去掉 2.0 版的 get 和 member 命令，新的 list 命令提供强大的联系人查询功能。\n6） 修改 QQBot 对象的接口，去掉原来的 Get/Member/Send 接口，只保留 List/SendTo/Stop/Restart 四个接口，新的 List 接口功能更加强大，且参数的格式可读性更好。\n7） 修改 注册事件响应函数 的格式，修改注册 QQ 消息响应函数的格式，新的格式可读性更好。\n8） 增加 新增/失去联系人 事件，可注册这两个事件的响应函数，实现 新人入群/退群 的通知功能。\n9） 增加 Interval 事件，每隔 5 分钟被调用，可注册此事件的响应函数，实现定时执行任务的功能。\n10） 程序的内部运行方式和数据结构有较大改变。程序的主体运行流程见 mainloop.py ，用非常简单和优雅的方式实现了多线程的并行和同步功能。\n11） 配置文件由 ~/.qqbot-tmp/v2.0.conf 改为 ~/.qqbot-tmp/v2.1.conf 。\n\n非常感谢以下网友在本次升级过程的帮助和支持：\n\n@sjdy521 提供了 ”使用 qun.qq.com 的 api 获取联系人实际 QQ ” 的宝贵建议，另外本次新版的 QQBot 启动方式也受到了他的项目的启发。\n@bolfhsu 提出 ”List与Get功能重复、Get应该是获取消息“ 的意见。原版中的 Get 接口很容易让人误解为 ”获取消息“ ，虽然我的本意是 ”获取联系人“ ，本次去掉了 Get 接口，将其功能合并到 List 接口中。\n@279632990 和 Moofeng 反馈了 ”程序掉线时有时无法自动重启“ 的 bug 。\n阿兰若 和 怪我瞎咯 反馈了 ”windows 下用某些图片浏览器弹出二维码后程序一直卡在等待图片窗口关闭的 bug “。\n\n\n2017-03-05 qqbot v2.0.12\n1） 增加 python3 的支持\n2） 增加采用 virtualenv 安装至独立的运行环境的脚本\n3） 增加测试脚本\n\n2018-12-06 qqbot v2.3.11\n1） webqq 的 http 请求全部改为 https。感谢网友 an鑫_wolfxin2010 提供帮助。\n"
        },
        {
          "name": "doc-data",
          "type": "tree",
          "content": null
        },
        {
          "name": "faq.md",
          "type": "blob",
          "size": 7.8564453125,
          "content": "一、问题目录\n-------------\n\n- [python初学者需注意的问题](https://github.com/pandolia/qqbot/blob/master/faq.md#python%E5%88%9D%E5%AD%A6%E8%80%85%E9%9C%80%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98)\n- [qqbot 的配置文件放在哪里？](https://github.com/pandolia/qqbot#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95)\n- [qqbot 的插件应保存在哪个目录？](https://github.com/pandolia/qqbot#%E5%85%AB-%E6%8F%92%E4%BB%B6)\n- [如何修改配置文件和插件的保存目录？](https://github.com/pandolia/qqbot#%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95)\n- [为什么修改了配置没有生效？](https://github.com/pandolia/qqbot/blob/master/faq.md#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BF%AE%E6%94%B9%E4%BA%86%E9%85%8D%E7%BD%AE%E6%B2%A1%E6%9C%89%E7%94%9F%E6%95%88)\n- [onQQMessage 函数中如何获取消息发送者的 QQ 号码等信息？](https://github.com/pandolia/qqbot/blob/master/faq.md#onqqmessage-%E5%87%BD%E6%95%B0%E4%B8%AD%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E8%80%85%E7%9A%84-qq-%E5%8F%B7%E7%A0%81%E7%AD%89%E4%BF%A1%E6%81%AF)\n- [onQQMessage 函数中如何判断消息是好友消息还是群消息？](https://github.com/pandolia/qqbot/blob/master/faq.md#onqqmessage-%E5%87%BD%E6%95%B0%E4%B8%AD%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%B6%88%E6%81%AF%E6%98%AF%E5%A5%BD%E5%8F%8B%E6%B6%88%E6%81%AF%E8%BF%98%E6%98%AF%E7%BE%A4%E6%B6%88%E6%81%AF)\n- [为什么有时候会重复发消息，有无解决办法？](https://github.com/pandolia/qqbot#3-botsendtocontact-content-resendon1202true----%E5%90%91-xx-%E5%8F%91%E6%B6%88%E6%81%AF%E6%88%90%E5%8A%9F%E9%94%99%E8%AF%AF)\n- [如何判断是否是自己发的群消息？](https://github.com/pandolia/qqbot#%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AF%E8%87%AA%E5%B7%B1%E5%8F%91%E7%9A%84%E6%B6%88%E6%81%AF)\n- [onInterval 函数是否可以自己设置调用的间隔时间？](https://github.com/pandolia/qqbot/blob/master/faq.md#oninterval-%E5%87%BD%E6%95%B0%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%87%AA%E5%B7%B1%E8%AE%BE%E7%BD%AE%E8%B0%83%E7%94%A8%E7%9A%84%E9%97%B4%E9%9A%94%E6%97%B6%E9%97%B4)\n- [如何稳定的长期保持在线？](https://github.com/pandolia/qqbot/blob/master/faq.md#%E5%A6%82%E4%BD%95%E7%A8%B3%E5%AE%9A%E7%9A%84%E9%95%BF%E6%9C%9F%E4%BF%9D%E6%8C%81%E5%9C%A8%E7%BA%BF)\n- [如何采用 virtualenv 将本项目安装至独立的运行环境？](https://github.com/pandolia/qqbot/blob/master/faq.md#%E5%A6%82%E4%BD%95%E9%87%87%E7%94%A8-virtualenv-%E5%B0%86%E6%9C%AC%E9%A1%B9%E7%9B%AE%E5%AE%89%E8%A3%85%E8%87%B3%E7%8B%AC%E7%AB%8B%E7%9A%84%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83)\n\n二、问题的回答\n-------------\n\n#### python初学者需注意的问题\n\n- 建议先系统的学习一下 python 的语法，参考资料： [python3 教程](https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000)\n- 建议学习和使用 python3 ，建议使用 [PyCharm IDE](https://www.jetbrains.com/pycharm/)\n- python 脚本的开头要加上 “# -\\*- coding: utf-8 -\\*-” ，并保存为 utf8 编码格式\n- 不要把你的脚本文件保存为 qqbot.py 或 sys.py ，或系统中已有的库或关键字的名字；也不要在脚本中将变量、函数等命名为 qqbot/sys/time 等名字。\n\n#### 为什么修改了配置没有生效？\n\n请确认是在配置文件中的 somebody 项下修改的配置，并且是以 qqbot -u somebody 的方式启动。\n\n当然，也可以自己新增一个 xxx 的项，并以 qqbot -u xxx 的方式启动。\n\n如果你已理解配置文件中的配置优先级和命令行参数，可以修改“默认配置”，或者在命令行参数中修改配置。\n\n#### onQQMessage 函数中如何获取消息发送者的 QQ 号码等信息？\n\n使用该函数中第二、三个参数 contact 和 member 的 qq 等属性，如 contact.qq / contact.name 等。详见： [联系人对象的属性](https://github.com/pandolia/qqbot/blob/master/qcontact-attr.md)。\n\n注意： member 有时侯可能为 None 。\n\n#### onQQMessage 函数中如何判断消息是好友消息还是群消息？\n\ncontact.ctype 为 'buddy'/'group'/'discuss' 时，分别代表本消息时 好友消息/群消息/讨论组消息 。\n\n#### onInterval 函数是否可以自己设置调用的间隔时间？\n\n不能。建议使用 qqbotsched 装饰器，功能更加强大。\n\n#### 如何稳定的长期保持在线？\n\n由于 smartqq 协议的限制，每次登录成功后的 cookie 会每在 1 ~ 2 天后失效，将被腾讯服务器强制下线，此时 **必须** 手工扫码重新登录，因此无法稳定的长期保持在线。\n\n可以打开邮箱模式和自动重启模式，并配合 qqbot.plugins.schedrestart 插件使用，每天在固定的时间扫码登录一次，基本上可以稳定的保持在线状态。建议直接使用 QQ 邮箱，这样发送二维码邮件后手机 QQ 可以马上收到通知，直接用手机 QQ 打开邮件并长按二维码图片就可以扫码了。\n\n#### 如何采用 virtualenv 将本项目安装至独立的运行环境？\n\n本项目依赖于 reqests 、flask 、 certifi 和 apscheduler 库，用 pip 安装本项目时会自动安装以上四个库以及它们所依赖的库。一般来说安装本项目不会与系统其他项目冲突，因此可直接安装至系统的全局 site-packages 目录。\n\n在某些系统中可能会出现 https 请求错误，这时需要安装 certifi 库的指定版本（2015.4.28 版），可能会将系统中已有的 certifi 库升级或降级并导致会使系统中的其他项目无法使用，这时可以使用 virtualenv 将本项目安装至独立的运行环境中。\n\n另外，Windows 下的用户有时需要使用 pyinstaller 打包自己利用 qqbot 开发的程序，此时也建议使用 virtualenv 将 qqbot 以及 pyinstaller 安装至独立的运行环境中，然后利用此环境中的 pyinstaller 进行打包。\n\nvirtualenv 基本原理和使用可参考 [廖雪峰的教程](http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001432712108300322c61f256c74803b43bfd65c6f8d0d0000) 。\n\n以下脚本（Linux下）将在 ~/PyVenv/qqbot-venv 目录下创建一个独立的运行环境，并将 qqbot 及其依赖的库安装至 ~/PyVenv/qqbot-env/lib/site-packages 目录下。系统中的原有的库不会被改动，其他项目不受影响。\n\n    sudo pip install virtualenv\n\n    mkdir ~/PyVenv\n    cd ~/PyVenv\n    virtualenv --no-site-packages qqbot-venv\n\n    source ~/PyVenv/qqbot-env/bin/activate\n\n    pip install requests==2.7.0\n    pip install certifi==2015.4.28\n    pip install flask==0.12\n    pip install apscheduler==3.3.1\n    pip install qqbot\n\n注意：使用本方式安装本项目后，每次使用 qqbot 和 qq 命令之前，需要先运行下面这条命令激活 qqbot-venv 下的运行环境：\n\n    source ~/PyVenv/qqbot-env/bin/activate\n\nWindows 下， 上述脚本改为：\n\n    pip install virtualenv\n    \n    c:\n    mkdir %UserProfile%\\PyVenv\n    cd %UserProfile%\\PyVenv\n    virtualenv --no-site-packages qqbot-env\n\n    %UserProfile%\\PyVenv\\qqbot-env\\Scripts\\activate\n\n    pip install requests==2.7.0\n    pip install certifi==2015.4.28\n    pip install flask==0.12\n    pip install apscheduler==3.3.1\n    pip install qqbot\n\n其中 %UserProfile% 是用户主目录，Win7中为 C:\\Users\\xxx 目录。\n\nWindows 下如果需要使用 pyinstaller 打包，还需要安装 pyinstaller 和 pypiwin32 ：\n\n    pip install pyinstaller==3.2.1\n    pip install pypiwin32==219\n\n然后在 %UserProfile%\\PyVenv\\qqbot-env 下新建一个目录 myapp ：\n    \n    cd %UserProfile%\\PyVenv\\qqbot-env\n    mkdir myapp\n    cd myapp\n\n在该目录下新建一个 main.py ，内容为：\n\n    from qqbot import Main; Main()\n\n再新建一个 hook-ctypes.macholib.py ，内容为：\n\n    from PyInstaller.utils.hooks import copy_metadata\n    datas = copy_metadata('apscheduler')\n\n最后，输入以下命令将 main.py 打包为 dist\\main.exe\n\n    ..\\Scripts\\pyinstaller -F main.py --additional-hooks-dir=.\n"
        },
        {
          "name": "hook-ctypes.macholib.py",
          "type": "blob",
          "size": 0.2138671875,
          "content": "# -*- coding: utf-8 -*-\n# 本文件是 pyinstaller 打包用的，打包命令：\n# pyinstaller -F main.py --additional-hooks-dir=.\nfrom PyInstaller.utils.hooks import copy_metadata\ndatas = copy_metadata('apscheduler')\n"
        },
        {
          "name": "main.py",
          "type": "blob",
          "size": 0.029296875,
          "content": "from qqbot import Main; Main()"
        },
        {
          "name": "plugins-in-dev",
          "type": "tree",
          "content": null
        },
        {
          "name": "prettytable.png",
          "type": "blob",
          "size": 7.189453125,
          "content": null
        },
        {
          "name": "pycharm-loader.py",
          "type": "blob",
          "size": 1.205078125,
          "content": "# -*- coding: utf-8 -*-\n\n#!/usr/bin/python\n# QQbot Loader for JetBrains PyCharm\n#\n# 作者     : SuperMarioSF\n# 上次更新 : 2017-06-13 (QQbot v2.3.2)\n#\n# 由于从QQbot 2.3开始提供了用于IDE环境的启动与测试方式，\n# 同时移除了相关用于非插件脚本加载函数的装饰器，\n# 因此本文件现在只能作为从IDE中启动QQbot的入口。\n#\n# 在 qqbot/plugins 目录中提供了详细的插件开发相关的示例。\n# 使用类似Pycharm这样的IDE开发时，请从本文件调试启动QQbot，\n# 然后正常操作QQbot的qq命令来热插拔你正在编写的插件。\n\n\n# 指定启动参数。详细请参见 qqbot 命令的帮助 （qqbot --help）。\nargs = [\n    # 用户名\n    '--user', 'username',\n    \n    #  QQ 号码\n    '--qq', '12345678',\n    \n    # 插件目录\n    '--pluginPath', '/my/plugin/path',\n    \n    # 启动时自动加载的插件\n    '--plugins', 'plugin1,plugin2,plugin3',\n    \n    # 启动方式：慢启动（获取全部联系人之后再启动）\n    '--startAfterFetch',\n    \n    # 打印调试信息\n    '--debug',\n]\n\n\nif __name__ == \"__main__\":\n    # 注意：此时重启功能无法使用\n    from qqbot import _bot as bot\n    bot.Login(args)\n    bot.Run()\n"
        },
        {
          "name": "qcontact-attr.md",
          "type": "blob",
          "size": 5.3427734375,
          "content": "好友的属性（ Buddy 对象）\n-----------------------------------------------\n\n- `b.ctype` : str 对象，联系人类型，永远为 'buddy'\n\n- `b.qq` : str 对象，好友的 QQ ，当无法获取时为 '#NULL'\n\n- `b.uin` : str 对象，好友的 uin ，每次登录时分配的一个随机 id \n\n- `b.nick` : str 对象，好友的昵称，当无法获取时为 '#NULL'\n\n- `b.mark` : str 对象，好友的备注名，当无法获取时为 '#NULL'\n\n- `b.name` ： str 对象，当设置了备注名时为备注名，否则为昵称，当无法获取时为 'uin'+b.uin\n\n\n群的属性（ Group 对象）\n-----------------------------------------------\n\n- `g.ctype` : str 对象，联系人类型，永远为 'group'\n\n- `g.qq` : str 对象，群的 QQ ，当无法获取时为 '#NULL'\n\n- `g.uin` : str 对象，群的 uin ，每次登录时分配的一个随机 id \n\n- `g.nick` : str 对象，群的原始名称，当无法获取时为 '#NULL'\n\n- `g.mark` : str 对象，群的备注名，当无法获取时为 '#NULL'\n\n- `g.name` ： str 对象，当设置了备注名时为备注名，否则为原始名，当无法获取时为 'uin'+g.uin\n\n- `g.gcode` ： str 对象，群的 gcode （获取群成员时需要用到此值），当无法获取时为 '#NULL'\n\n\n讨论组的属性（ Discuss 对象）\n-----------------------------------------------\n\n- `d.ctype` : str 对象，联系人类型，永远为 'discuss'\n\n- `d.uin` : str 对象，讨论组的 uin ，每次登录时分配的一个随机 id \n\n- `d.name` : str 对象，讨论组的名称 ，当无法获取时为 'uin'+d.uin\n\n\n群成员的属性（ GroupMember 对象）（by @SuperMarioSF , pandolia）\n------------------------------------------------------------------\n\n- `m.ctype` : str 对象，联系人类型，永远为 'group-member'\n\n- `m.qq` : str 对象，成员的 QQ ，当无法获取时为 '#NULL'\n\n- `m.uin` : str 对象，成员的 uin ，每次登录时分配的一个随机 id \n\n- `m.nick` : str 对象，成员的昵称，当无法获取时为 '#NULL'\n\n- `m.mark` : str 对象，成员的备注名，当无法获取时为 '#NULL'\n\n- `m.card` : str 对象，成员的群名片，当无法获取时为 '#NULL'\n\n- `m.name` ： str 对象，当设置了群名片时为群名片，否则为昵称，当无法获取时为 'uin'+m.uin\n\n- `m.join_time` : int 对象，成员入群时间\n   - 此处的入群时间的数值可能为 0 ，在 QQ 中显示为 “ 2012 年 5 月以前”\n   - 不为 0 的值为 Unix 时间戳\n   - 当无法获取时为 -1\n\n- `m.last_speak_time` : int 对象，成员最后发言时间\n   - 此处的最后发言时间的数值可能为 0 ，在 QQ 中表示为 “从未发言”\n   - 不为 0 的值为 Unix 时间戳\n   - 当无法获取时为 -1\n\n- `m.role` ： str 对象，成员角色，可能的取值为 '群主'、'管理员'、'普通成员' ，当无法获取时为 '#NULL'\n\n- `m.role_id` : int 对象，成员角色 id ，可能的取值:  0, 1, 2 ，当无法获取时为 -1\n\n- `m.is_buddy` ：int 对象，该成员是否是自己的好友（取值：1,0），当无法获取时为 -1\n\n- `m.level` :  int 对象，成员等级级别，当无法获取时为 -1\n\n- `m.levelname` : str 对象，成员等级级别名，当无法获取时为 '#NULL'\n\n- `m.point` : int 对象，成员等级分数\n   - m.level 与这个分数有关， QQ 的群活跃等级 PK 中有这个数值的参与\n   - 当无法获取时为 -1\n\n\n讨论组成员的属性（ DiscussMember 对象）\n-----------------------------------------------\n\n- `m.ctype` : str 对象，联系人类型，永远为 'discuss'\n\n- `m.qq` : str 对象，成员的 QQ ，当无法获取时为 '#NULL'\n\n- `m.uin` : str 对象，成员的 uin ，每次登录时分配的一个随机 id \n\n- `m.name` : str 对象，成员的昵称 ，当无法获取时为 'uin'+m.uin\n\n\nUnix时间戳的处理（by @SuperMarioSF ）\n--------------------------------------------\n\n`m.last_speak_time` 、`m.join_time` 返回的是Unix时间戳，但实际应用中我们可能希望得到一个已经格式化处理好的时间格式。\nUnix时间戳是一个整数。表示了UTC时间的1970年1月1日凌晨0:00:00（对应北京时间1970年1月1日早8点）到所要表示的时间的已经经过的秒数。因此Unix时间戳是一个int类型的值。\n\n#### 使用 time 库进行时间处理\n\n`time` 库中有跨平台通用的时间相关的处理方法。\n\n```python\n#!/usr/bin/python3\nimport time\n\n# 产生一个新的Unix时间戳: 北京时间 2017年1月1日早8点\n# time.strptime() 返回 struct_time 类型数据，包含了从输入和格式中格式化后的时间。(并不处理时区转换)\n# time.mktime() 返回 float 类型数据，表示的是浮点数形式的Unix时间戳。接受的是一个表示本地时间的 struct_time 类型。\nunixTimeStamp = int(time.mktime(time.strptime('2017-01-01 08:00:00','%Y-%m-%d %H:%M:%S')))\n\n#显示Unix时间戳。要注意此处的时间戳是整数类型。\nprint('Timestamp: \\t' + str(unixTimeStamp))\n#第一种形式，返回Unix系统常见的时间表示方法。\nprint('ASCIITime: \\t' + time.asctime(time.localtime(unixTimeStamp)))\n#第二种形式，自定义输出格式。详见 time.strftime() 的帮助信息。\nprint('Formatted: \\t' + time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(unixTimeStamp)))\n\n\n```\n\n上述示例的返回值为:\n```\nTimestamp: \t1483228800\nASCIITime: \tSun Jan  1 08:00:00 2017\nFormatted: \t2017-01-01 08:00:00\n```\n"
        },
        {
          "name": "qq_auto_bot.py",
          "type": "blob",
          "size": 1.736328125,
          "content": "#-*-coding:utf8-*-\r\nimport json,urllib,urllib2\r\nfrom qqbot import QQBotSlot as qqbotslot, RunBot\r\n\r\ndef talk(content,userid):\r\n    url = 'http://www.tuling123.com/openapi/api'\r\n    s = urllib2.Request(url)\r\n    da = {\"key\":\"输入图灵机器人给的key值\",\"info\":content,\"userid\":userid}\r\n    da = urllib.urlencode(da)\r\n    opener = urllib2.build_opener(urllib2.HTTPCookieProcessor())\r\n    j = eval(opener.open(s,da).read())\r\n#    r = s.post(url,data = data)\r\n#    j = eval(r.text)\r\n    code = j['code']\r\n    if code == 100000:\r\n        recontent = j['text']\r\n    elif code == 200000:\r\n        recontent = j['text']+j['url']\r\n    elif code == 302000 or code ==308000:\r\n        recontent = j['text']+j['list'][0]['info']+j['list'][0]['detailurl']\r\n    elif code == 40004:\r\n        recontent = '小V每天只能回答5000个问题，今天已经很累了，小V要去休息了哦～～'\r\n    elif code == 40002:\r\n        recontent = '您有什么想对小V说的吗？～'\r\n    elif code == 40007:\r\n        recontent = '您输入的数据格式异常，请重新输入！'\r\n    else:\r\n        recontent = '这货还没学会怎么回复这句话'\r\n    return recontent\r\n\r\n@qqbotslot\r\n\r\ndef onQQMessage(bot, contact, member, content):\r\n    if content == '--stop':\r\n        bot.SendTo(contact,'我轻轻的走了，正如我轻轻的来。挥一挥衣袖，忘掉我的所有～～')\r\n        bot.Stop()\r\n    else:\r\n        if getattr(member, 'uin', None) == bot.conf.qq:\r\n            return()\r\n        else:\r\n            if member == None:\r\n                bot.SendTo(contact,talk(content,contact.qq))\r\n            elif '@ME' in content:\r\n                bot.SendTo(contact, '@'+member.name+'  '+talk(content,contact.qq))\r\n            else:\r\n                return()\r\nRunBot()\r\n"
        },
        {
          "name": "qqbot-venv.sh",
          "type": "blob",
          "size": 0.3203125,
          "content": "sudo pip install virtualenv\n\nmkdir ~/Py3Venv\ncd ~/Py3Venv\nvirtualenv --python=python3 --no-site-packages qqbot-venv\n\ncd qqbot-venv/bin/\nsource activate\n\npip install -r requirements.txt\n\npip install qqbot\n\n# 重新打开终端后，在使用 qqbot 和 qq 命令之前，需要运行：\n# source ~/Py3Venv/qqbot-venv/bin/activate\n"
        },
        {
          "name": "qqbot",
          "type": "tree",
          "content": null
        },
        {
          "name": "requirements.txt",
          "type": "blob",
          "size": 0.0458984375,
          "content": "requests\ncertifi==2015.4.28\napscheduler==3.3.1\n"
        },
        {
          "name": "sample.py",
          "type": "blob",
          "size": 0.4404296875,
          "content": "﻿# -*- coding: utf-8 -*-\n\n# 插件加载方法：\n# 1. 启动 qqbot \n# 2. 将本文件保存至 ~/.qqbot-tmp/plugins 目录 （或 c:\\user\\xxx\\.qqbot-tmp\\plugins ）\n# 3. 在命令行窗口输入： qq plug sample\n\ndef onQQMessage(bot, contact, member, content):\n    if content == '-hello':\n        bot.SendTo(contact, '你好，我是QQ机器人')\n    elif content == '-stop':\n        bot.SendTo(contact, 'QQ机器人已关闭')\n        bot.Stop()\n"
        },
        {
          "name": "setup.cfg",
          "type": "blob",
          "size": 0.0390625,
          "content": "[metadata]\ndescription-file = README.md\n"
        },
        {
          "name": "setup.py",
          "type": "blob",
          "size": 0.78125,
          "content": "# -*- coding: utf-8 -*-\n\nfrom setuptools import setup\n\nversion = 'v2.3.11'\n\nsetup(\n    name = 'qqbot',\n    version = version,\n    packages = ['qqbot', 'qqbot.qcontactdb', 'qqbot.plugins'],\n    entry_points = {\n        'console_scripts': [\n            'qqbot = qqbot:RunBot',\n            'qq = qqbot:QTerm'\n        ]\n    },\n    install_requires = ['requests', 'certifi', 'apscheduler'],\n    description = \"QQBot: A conversation robot base on Tencent's SmartQQ\",\n    author = 'pandolia' ,\n    author_email = 'pandolia@yeah.net',\n    url = 'https://github.com/pandolia/qqbot/',\n    download_url = 'https://github.com/pandolia/qqbot/archive/%s.tar.gz' % version,\n    keywords = ['QQBot', 'conversation robot', 'tencent', 'qq',\n                'web', 'network', 'python', 'http'],\n    classifiers = [],\n)\n"
        },
        {
          "name": "testbot.txt",
          "type": "blob",
          "size": 1.400390625,
          "content": "# (1) test list\nqq list buddy\nqq list buddy Eva\nqq list buddy x\nqq list x\nqq list buddy xx xx\n\nqq list group\nqq list group connie\nqq list group x\n\nqq list discuss\nqq list discuss MyDiscuss\nqq list discuss x\n\nqq list group-member connie\nqq list group-member connie Eva\nqq list group-member connie 158297369\nqq list group-member x\nqq list group-member connie x\n\nqq list discuss-member MyDiscuss\nqq list discuss-member MyDiscuss Eva\nqq list discuss-member MyDiscuss 158297369\nqq list discuss-member x\nqq list discuss-member MyDiscuss x\n\nqq list buddy :like:李\nqq list group-member :like:22 :like:李\n\n# (2) test send\nqq send buddy Eva nihao 你好 wohao\nqq send buddy hcj\nqq send buddy qwe323 fdsf\n\nqq send group connie wohao 我好 wohao\nqq send group connie\nqq send group qwe323 fdsf\n\nqq send discuss MyDiscuss tahao 他好 tahao\nqq send discuss MyDiscuss\nqq send discuss qwe323 fdsf\n\n# (3) test group-manager\nqq group-set-admin connie 158297369,3497303033\nqq group-unset-admin connie 158297369,3497303033\n\nqq group-unset-admin connie sdds,dsad\nqq group-unset-admin connie sdds,dsad cxzc\nqq group-unset-admin connie\n\nqq group-set-card connie 158297369,3497303033 card\nqq list group-member connie\nqq list group-member connie card\n\nqq group-unset-card connie card\nqq list group-member connie\nqq list group-member connie card\n\nqq group-shut connie 158297369,3497303033\n\nqq group-kick connie 158297369,3497303033\n\n# (3) test help\nqq help\n"
        },
        {
          "name": "uploadtopip.sh",
          "type": "blob",
          "size": 0.0986328125,
          "content": "python setup.py register -r pypi\npython setup.py sdist upload -r pypi\nrm -r dist\nrm -r qqbot.egg-info"
        },
        {
          "name": "urltestbot.html",
          "type": "blob",
          "size": 7.3984375,
          "content": "<html>\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf8\">\n</head>\n\n<body>\n\n<h1>(1) test list</h1>\n<a href=\"http://127.0.0.1:8188/list/buddy\">http://127.0.0.1:8188/list/buddy</a></br>\n<a href=\"http://127.0.0.1:8188/list/buddy/Eva\">http://127.0.0.1:8188/list/buddy/Eva</a></br>\n<a href=\"http://127.0.0.1:8188/list/buddy/x\">http://127.0.0.1:8188/list/buddy/x</a></br>\n<a href=\"http://127.0.0.1:8188/list/x\">http://127.0.0.1:8188/list/x</a></br>\n<a href=\"http://127.0.0.1:8188/list/buddy/xx/xx\">http://127.0.0.1:8188/list/buddy/xx/xx</a></br>\n\n<a href=\"http://127.0.0.1:8188/list/group\">http://127.0.0.1:8188/list/group</a></br>\n<a href=\"http://127.0.0.1:8188/list/group/connie\">http://127.0.0.1:8188/list/group/connie</a></br>\n<a href=\"http://127.0.0.1:8188/list/group/x\">http://127.0.0.1:8188/list/group/x</a></br>\n\n<a href=\"http://127.0.0.1:8188/list/discuss\">http://127.0.0.1:8188/list/discuss</a></br>\n<a href=\"http://127.0.0.1:8188/list/discuss/MyDiscuss\">http://127.0.0.1:8188/list/discuss/MyDiscuss</a></br>\n<a href=\"http://127.0.0.1:8188/list/discuss/x\">http://127.0.0.1:8188/list/discuss/x</a></br>\n\n<a href=\"http://127.0.0.1:8188/list/group-member/connie\">http://127.0.0.1:8188/list/group-member/connie</a></br>\n<a href=\"http://127.0.0.1:8188/list/group-member/connie/Eva\">http://127.0.0.1:8188/list/group-member/connie/Eva</a></br>\n<a href=\"http://127.0.0.1:8188/list/group-member/connie/158297369\">http://127.0.0.1:8188/list/group-member/connie/158297369</a></br>\n<a href=\"http://127.0.0.1:8188/list/group-member/x\">http://127.0.0.1:8188/list/group-member/x</a></br>\n<a href=\"http://127.0.0.1:8188/list/group-member/connie/x\">http://127.0.0.1:8188/list/group-member/connie/x</a></br>\n\n<a href=\"http://127.0.0.1:8188/list/discuss-member/MyDiscuss\">http://127.0.0.1:8188/list/discuss-member/MyDiscuss</a></br>\n<a href=\"http://127.0.0.1:8188/list/discuss-member/MyDiscuss/Eva\">http://127.0.0.1:8188/list/discuss-member/MyDiscuss/Eva</a></br>\n<a href=\"http://127.0.0.1:8188/list/discuss-member/MyDiscuss/158297369\">http://127.0.0.1:8188/list/discuss-member/MyDiscuss/158297369</a></br>\n<a href=\"http://127.0.0.1:8188/list/discuss-member/x\">http://127.0.0.1:8188/list/discuss-member/x</a></br>\n<a href=\"http://127.0.0.1:8188/list/discuss-member/MyDiscuss/x\">http://127.0.0.1:8188/list/discuss-member/MyDiscuss/x</a></br>\n\n<a href=\"http://127.0.0.1:8188/list/buddy/%3Alike%3A%E6%9D%8E\">http://127.0.0.1:8188/list/buddy/:like:李</a></br>\n<a href=\"http://127.0.0.1:8188/list/group-member/%3Alike%3A22/%3Alike%3A%E6%9D%8E\">http://127.0.0.1:8188/list/group-member/:like:22/:like:李</a></br>\n\n<h1>(2) test update</h1>\n<a href=\"http://127.0.0.1:8188/update/buddy\">http://127.0.0.1:8188/update/buddy</a></br>\n<a href=\"http://127.0.0.1:8188/update/group\">http://127.0.0.1:8188/update/group</a></br>\n<a href=\"http://127.0.0.1:8188/update/discuss\">http://127.0.0.1:8188/update/discuss</a></br>\n<a href=\"http://127.0.0.1:8188/update/group-member/connie\">http://127.0.0.1:8188/update/group-member/connie</a></br>\n<a href=\"http://127.0.0.1:8188/update/discuss-member/MyDiscuss\">http://127.0.0.1:8188/update/discuss-member/MyDiscuss</a></br>\n<a href=\"http://127.0.0.1:8188/update/discuss-member/MyDiscuss/Eva\">http://127.0.0.1:8188/update/discuss-member/MyDiscuss/Eva</a></br>\n<a href=\"http://127.0.0.1:8188/update/discuss-member\">http://127.0.0.1:8188/update/discuss-member</a></br>\n<a href=\"http://127.0.0.1:8188/update/buddy/x\">http://127.0.0.1:8188/update/buddy/x</a></br>\n\n<h1>(3) test send</h1>\n<a href=\"http://127.0.0.1:8188/send/buddy/Eva/nihao%20%E4%BD%A0%E5%A5%BD%20wohao\">http://127.0.0.1:8188/send/buddy/Eva/nihao%20%E4%BD%A0%E5%A5%BD%20wohao</a></br>\n<a href=\"http://127.0.0.1:8188/send/buddy/hcj\">http://127.0.0.1:8188/send/buddy/hcj</a></br>\n<a href=\"http://127.0.0.1:8188/send/buddy/qwe323/fdsf\">http://127.0.0.1:8188/send/buddy/qwe323/fdsf</a></br>\n\n<a href=\"http://127.0.0.1:8188/send/group/connie/wohao%20%E6%88%91%E5%A5%BD%20wohao\">http://127.0.0.1:8188/send/group/connie/wohao%20%E6%88%91%E5%A5%BD%20wohao</a></br>\n<a href=\"http://127.0.0.1:8188/send/group/connie\">http://127.0.0.1:8188/send/group/connie</a></br>\n<a href=\"http://127.0.0.1:8188/send/group/qwe323/fdsf\">http://127.0.0.1:8188/send/group/qwe323/fdsf</a></br>\n\n<a href=\"http://127.0.0.1:8188/send/discuss/MyDiscuss/tahao%20%E4%BB%96%E5%A5%BD%20tahao\">http://127.0.0.1:8188/send/discuss/MyDiscuss/tahao%20%E4%BB%96%E5%A5%BD%20tahao</a></br>\n<a href=\"http://127.0.0.1:8188/send/discuss/MyDiscuss\">http://127.0.0.1:8188/send/discuss/MyDiscuss</a></br>\n<a href=\"http://127.0.0.1:8188/send/discuss/qwe323/fdsf\">http://127.0.0.1:8188/send/discuss/qwe323/fdsf</a></br>\n\n<h1>(4) test group-manager</h1>\n<a href=\"http://127.0.0.1:8188/group-set-admin/connie/158297369%2C3497303033\">http://127.0.0.1:8188/group-set-admin/connie/158297369%2C3497303033</a></br>\n<a href=\"http://127.0.0.1:8188/group-unset-admin/connie/158297369%2C3497303033\">http://127.0.0.1:8188/group-unset-admin/connie/158297369%2C3497303033</a></br>\n\n<a href=\"http://127.0.0.1:8188/group-unset-admin/connie/sdds%2Cdsad\">http://127.0.0.1:8188/group-unset-admin/connie/sdds%2Cdsad</a></br>\n<a href=\"http://127.0.0.1:8188/group-unset-admin/connie/sdds%2Cdsad/cxzc\">http://127.0.0.1:8188/group-unset-admin/connie/sdds%2Cdsad/cxzc</a></br>\n<a href=\"http://127.0.0.1:8188/group-unset-admin/connie\">http://127.0.0.1:8188/group-unset-admin/connie</a></br>\n\n<a href=\"http://127.0.0.1:8188/group-set-card/connie/158297369%2C3497303033/card\">http://127.0.0.1:8188/group-set-card/connie/158297369%2C3497303033/card</a></br>\n<a href=\"http://127.0.0.1:8188/list/group-member/connie\">http://127.0.0.1:8188/list/group-member/connie</a></br>\n<a href=\"http://127.0.0.1:8188/list/group-member/connie/card\">http://127.0.0.1:8188/list/group-member/connie/card</a></br>\n\n<a href=\"http://127.0.0.1:8188/group-unset-card/connie/card\">http://127.0.0.1:8188/group-unset-card/connie/card</a></br>\n<a href=\"http://127.0.0.1:8188/list/group-member/connie\">http://127.0.0.1:8188/list/group-member/connie</a></br>\n<a href=\"http://127.0.0.1:8188/list/group-member/connie/card\">http://127.0.0.1:8188/list/group-member/connie/card</a></br>\n\n<a href=\"http://127.0.0.1:8188/group-shut/connie/158297369%2C3497303033\">http://127.0.0.1:8188/group-shut/connie/158297369%2C3497303033</a></br>\n\n<a href=\"http://127.0.0.1:8188/group-kick/connie/158297369%2C3497303033\">http://127.0.0.1:8188/group-kick/connie/158297369%2C3497303033</a></br>\n\n<a href=\"http://127.0.0.1:8188/group-kick/connie/3497303033\">http://127.0.0.1:8188/group-kick/connie/3497303033</a></br>\n\n<h1>(5) test plugin</h1>\n<a href=\"http://127.0.0.1:8188/plugins\">http://127.0.0.1:8188/plugins</a></br>\n<a href=\"http://127.0.0.1:8188/plug/sample\">http://127.0.0.1:8188/plug/sample</a></br>\n<a href=\"http://127.0.0.1:8188/plug/sched\">http://127.0.0.1:8188/plug/sched</a></br>\n<a href=\"http://127.0.0.1:8188/plugins\">http://127.0.0.1:8188/plugins</a></br>\n<a href=\"http://127.0.0.1:8188/unplug/sample\">http://127.0.0.1:8188/unplug/sample</a></br>\n<a href=\"http://127.0.0.1:8188/unplug/sched\">http://127.0.0.1:8188/unplug/sched</a></br>\n<a href=\"http://127.0.0.1:8188/plugins\">http://127.0.0.1:8188/plugins</a></br>\n\n<h1>(6) test help|stop|restart|fresh-restart</h1>\n<a href=\"http://127.0.0.1:8188/help\">http://127.0.0.1:8188/help</a></br>\n<a href=\"http://127.0.0.1:8188/restart\">http://127.0.0.1:8188/restart</a></br>\n<a href=\"http://127.0.0.1:8188/fresh-restart\">http://127.0.0.1:8188/fresh-restart</a></br>\n<a href=\"http://127.0.0.1:8188/stop\">http://127.0.0.1:8188/stop</a></br>\n\n</body>\n</html>\n"
        }
      ]
    }
  ]
}