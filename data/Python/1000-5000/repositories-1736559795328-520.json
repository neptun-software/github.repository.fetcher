{
  "metadata": {
    "timestamp": 1736559795328,
    "page": 520,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjUyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "yasoob/intermediatePython",
      "stars": 3854,
      "defaultBranch": "master",
      "files": [
        {
          "name": "CNAME",
          "type": "blob",
          "size": 0.01953125,
          "content": "book.pythontips.com\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 6.619140625,
          "content": "# Makefile for Sphinx documentation\n#\n\n# You can set these variables from the command line.\nSPHINXOPTS    =\nSPHINXBUILD   = sphinx-build\nPAPER         =\nBUILDDIR      = _build\n\n# User-friendly check for sphinx-build\nifeq ($(shell which $(SPHINXBUILD) >/dev/null 2>&1; echo $$?), 1)\n$(error The '$(SPHINXBUILD)' command was not found. Make sure you have Sphinx installed, then set the SPHINXBUILD environment variable to point to the full path of the '$(SPHINXBUILD)' executable. Alternatively you can add the directory with the executable to your PATH. If you don't have Sphinx installed, grab it from http://sphinx-doc.org/)\nendif\n\n# Internal variables.\nPAPEROPT_a4     = -D latex_paper_size=a4\nPAPEROPT_letter = -D latex_paper_size=letter\nALLSPHINXOPTS   = -d $(BUILDDIR)/doctrees $(PAPEROPT_$(PAPER)) $(SPHINXOPTS) .\n# the i18n builder cannot share the environment and doctrees with the others\nI18NSPHINXOPTS  = $(PAPEROPT_$(PAPER)) $(SPHINXOPTS) .\n\n.PHONY: help clean html dirhtml singlehtml pickle json htmlhelp qthelp devhelp epub latex latexpdf text man changes linkcheck doctest gettext\n\nhelp:\n\t@echo \"Please use \\`make <target>' where <target> is one of\"\n\t@echo \"  html       to make standalone HTML files\"\n\t@echo \"  dirhtml    to make HTML files named index.html in directories\"\n\t@echo \"  singlehtml to make a single large HTML file\"\n\t@echo \"  pickle     to make pickle files\"\n\t@echo \"  json       to make JSON files\"\n\t@echo \"  htmlhelp   to make HTML files and a HTML help project\"\n\t@echo \"  qthelp     to make HTML files and a qthelp project\"\n\t@echo \"  devhelp    to make HTML files and a Devhelp project\"\n\t@echo \"  epub       to make an epub\"\n\t@echo \"  latex      to make LaTeX files, you can set PAPER=a4 or PAPER=letter\"\n\t@echo \"  latexpdf   to make LaTeX files and run them through pdflatex\"\n\t@echo \"  latexpdfja to make LaTeX files and run them through platex/dvipdfmx\"\n\t@echo \"  text       to make text files\"\n\t@echo \"  man        to make manual pages\"\n\t@echo \"  texinfo    to make Texinfo files\"\n\t@echo \"  info       to make Texinfo files and run them through makeinfo\"\n\t@echo \"  gettext    to make PO message catalogs\"\n\t@echo \"  changes    to make an overview of all changed/added/deprecated items\"\n\t@echo \"  xml        to make Docutils-native XML files\"\n\t@echo \"  pseudoxml  to make pseudoxml-XML files for display purposes\"\n\t@echo \"  linkcheck  to check all external links for integrity\"\n\t@echo \"  doctest    to run all doctests embedded in the documentation (if enabled)\"\n\nclean:\n\trm -rf $(BUILDDIR)/*\n\nhtml:\n\t$(SPHINXBUILD) -b html $(ALLSPHINXOPTS) $(BUILDDIR)/html\n\t@echo\n\t@echo \"Build finished. The HTML pages are in $(BUILDDIR)/html.\"\n\ndirhtml:\n\t$(SPHINXBUILD) -b dirhtml $(ALLSPHINXOPTS) $(BUILDDIR)/dirhtml\n\t@echo\n\t@echo \"Build finished. The HTML pages are in $(BUILDDIR)/dirhtml.\"\n\nsinglehtml:\n\t$(SPHINXBUILD) -b singlehtml $(ALLSPHINXOPTS) $(BUILDDIR)/singlehtml\n\t@echo\n\t@echo \"Build finished. The HTML page is in $(BUILDDIR)/singlehtml.\"\n\npickle:\n\t$(SPHINXBUILD) -b pickle $(ALLSPHINXOPTS) $(BUILDDIR)/pickle\n\t@echo\n\t@echo \"Build finished; now you can process the pickle files.\"\n\njson:\n\t$(SPHINXBUILD) -b json $(ALLSPHINXOPTS) $(BUILDDIR)/json\n\t@echo\n\t@echo \"Build finished; now you can process the JSON files.\"\n\nhtmlhelp:\n\t$(SPHINXBUILD) -b htmlhelp $(ALLSPHINXOPTS) $(BUILDDIR)/htmlhelp\n\t@echo\n\t@echo \"Build finished; now you can run HTML Help Workshop with the\" \\\n\t      \".hhp project file in $(BUILDDIR)/htmlhelp.\"\n\nqthelp:\n\t$(SPHINXBUILD) -b qthelp $(ALLSPHINXOPTS) $(BUILDDIR)/qthelp\n\t@echo\n\t@echo \"Build finished; now you can run \"qcollectiongenerator\" with the\" \\\n\t      \".qhcp project file in $(BUILDDIR)/qthelp, like this:\"\n\t@echo \"# qcollectiongenerator $(BUILDDIR)/qthelp/PythonTips.qhcp\"\n\t@echo \"To view the help file:\"\n\t@echo \"# assistant -collectionFile $(BUILDDIR)/qthelp/PythonTips.qhc\"\n\ndevhelp:\n\t$(SPHINXBUILD) -b devhelp $(ALLSPHINXOPTS) $(BUILDDIR)/devhelp\n\t@echo\n\t@echo \"Build finished.\"\n\t@echo \"To view the help file:\"\n\t@echo \"# mkdir -p $$HOME/.local/share/devhelp/PythonTips\"\n\t@echo \"# ln -s $(BUILDDIR)/devhelp $$HOME/.local/share/devhelp/PythonTips\"\n\t@echo \"# devhelp\"\n\nepub:\n\t$(SPHINXBUILD) -b epub $(ALLSPHINXOPTS) $(BUILDDIR)/epub\n\t@echo\n\t@echo \"Build finished. The epub file is in $(BUILDDIR)/epub.\"\n\nlatex:\n\t$(SPHINXBUILD) -b latex $(ALLSPHINXOPTS) $(BUILDDIR)/latex\n\t@echo\n\t@echo \"Build finished; the LaTeX files are in $(BUILDDIR)/latex.\"\n\t@echo \"Run \\`make' in that directory to run these through (pdf)latex\" \\\n\t      \"(use \\`make latexpdf' here to do that automatically).\"\n\nlatexpdf:\n\t$(SPHINXBUILD) -b latex $(ALLSPHINXOPTS) $(BUILDDIR)/latex\n\t@echo \"Running LaTeX files through pdflatex...\"\n\t$(MAKE) -C $(BUILDDIR)/latex all-pdf\n\t@echo \"pdflatex finished; the PDF files are in $(BUILDDIR)/latex.\"\n\nlatexpdfja:\n\t$(SPHINXBUILD) -b latex $(ALLSPHINXOPTS) $(BUILDDIR)/latex\n\t@echo \"Running LaTeX files through platex and dvipdfmx...\"\n\t$(MAKE) -C $(BUILDDIR)/latex all-pdf-ja\n\t@echo \"pdflatex finished; the PDF files are in $(BUILDDIR)/latex.\"\n\ntext:\n\t$(SPHINXBUILD) -b text $(ALLSPHINXOPTS) $(BUILDDIR)/text\n\t@echo\n\t@echo \"Build finished. The text files are in $(BUILDDIR)/text.\"\n\nman:\n\t$(SPHINXBUILD) -b man $(ALLSPHINXOPTS) $(BUILDDIR)/man\n\t@echo\n\t@echo \"Build finished. The manual pages are in $(BUILDDIR)/man.\"\n\ntexinfo:\n\t$(SPHINXBUILD) -b texinfo $(ALLSPHINXOPTS) $(BUILDDIR)/texinfo\n\t@echo\n\t@echo \"Build finished. The Texinfo files are in $(BUILDDIR)/texinfo.\"\n\t@echo \"Run \\`make' in that directory to run these through makeinfo\" \\\n\t      \"(use \\`make info' here to do that automatically).\"\n\ninfo:\n\t$(SPHINXBUILD) -b texinfo $(ALLSPHINXOPTS) $(BUILDDIR)/texinfo\n\t@echo \"Running Texinfo files through makeinfo...\"\n\tmake -C $(BUILDDIR)/texinfo info\n\t@echo \"makeinfo finished; the Info files are in $(BUILDDIR)/texinfo.\"\n\ngettext:\n\t$(SPHINXBUILD) -b gettext $(I18NSPHINXOPTS) $(BUILDDIR)/locale\n\t@echo\n\t@echo \"Build finished. The message catalogs are in $(BUILDDIR)/locale.\"\n\nchanges:\n\t$(SPHINXBUILD) -b changes $(ALLSPHINXOPTS) $(BUILDDIR)/changes\n\t@echo\n\t@echo \"The overview file is in $(BUILDDIR)/changes.\"\n\nlinkcheck:\n\t$(SPHINXBUILD) -b linkcheck $(ALLSPHINXOPTS) $(BUILDDIR)/linkcheck\n\t@echo\n\t@echo \"Link check complete; look for any errors in the above output \" \\\n\t      \"or in $(BUILDDIR)/linkcheck/output.txt.\"\n\ndoctest:\n\t$(SPHINXBUILD) -b doctest $(ALLSPHINXOPTS) $(BUILDDIR)/doctest\n\t@echo \"Testing of doctests in the sources finished, look at the \" \\\n\t      \"results in $(BUILDDIR)/doctest/output.txt.\"\n\nxml:\n\t$(SPHINXBUILD) -b xml $(ALLSPHINXOPTS) $(BUILDDIR)/xml\n\t@echo\n\t@echo \"Build finished. The XML files are in $(BUILDDIR)/xml.\"\n\npseudoxml:\n\t$(SPHINXBUILD) -b pseudoxml $(ALLSPHINXOPTS) $(BUILDDIR)/pseudoxml\n\t@echo\n\t@echo \"Build finished. The pseudo-XML files are in $(BUILDDIR)/pseudoxml.\"\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 3.7783203125,
          "content": "![Intermediate Python Book Cover](_static/cover.png)\n\nIntermediate Python\n===================\n\nPython is an amazing language with a strong and friendly community of programmers. However, there is a lack of documentation on what to learn after getting the basics of Python down your throat. Through this book I aim to solve this problem. I will give you bits of information about some interesting topics which you can further explore.\n\nThe topics which are discussed in this book will open your mind to some nice corners of Python language. This book is an outcome of my desire to have something like this when I was beginning to learn Python.\n\nIf you are a beginner, intermediate or even an advanced programmer there is something for you in this book.\n\nPlease note that this book is not a tutorial and does not teach you Python. The topics are not explained in-depth and only the minimum required information is given.\n\nI am sure you are as excited as I am. So, let’s start!\n\nNote: This book is a work in progress. If you find anything which you can further improve (I know you will find a lot of stuff) then kindly submit a pull request. :)\n\nMoreover, if you want to add more content to this book then kindly submit a pull request and I will be more than happy to merge it. :+1:\n\n-------------------\n\n**Note:** If you want to tip me for my work then you can buy the donation version of this book from [Gumroad](https://gum.co/intermediate_python). Apart from that, if this book somehow helps you then kindly share your experience with [me](mailto:yasoob.khld@gmail.com). I would really appreciate it.\n\n-------------------\n\nTable of Contents:\n------------------\n1) Programmer tools\n    - [Virtual Environment](virtual_environment.rst)\n    - [Debugging](debugging.rst)\n    - [Object introspection](object_introspection.rst)\n2) Syntax\n    - [Exceptions](exceptions.rst)\n    - [For - Else](for_-_else.rst)\n    - [Ternary Operators](ternary_operators.rst)\n    - [Global & Return](global_&_return.rst)\n    - [Open function](open_function.rst)\n    - [\\*args and \\*\\*kwargs](args_and_kwargs.rst)\n    - [Context managers](context_managers.rst)\n3) Functional programming\n    - [Enumerate](enumerate.rst)\n    - [Lambdas](lambdas.rst)\n    - [``set`` Data Structure](set_-_data_structure.rst)\n    - [Map & Filter](map_filter.rst)\n    - [Comprehensions](comprehensions.rst)\n4) Data structures\n    - [Generators](generators.rst)\n    - [Coroutines](coroutines.rst)\n    - [Classes](classes.rst)\n5) Data types\n    - [Collections](collections.rst)\n    - [Mutation](mutation.rst)\n    - [\\_\\_slots\\_\\_ Magic](__slots__magic.rst)\n6) Decorators\n    - [What is a decorator?](decorators.rst)\n    - [Function caching](function_caching.rst)\n7) Extras\n    - [One Liners](one_liners.rst)\n    - [Targeting Python 2+3](targeting_python_2_3.rst)\n    - [Python C extensions](python_c_extension.rst)\n\nAuthor:\n------\n\n- [Muhammad Yasoob Ullah Khalid](https://github.com/yasoob)\n\nAcknowledgement:\n----------------\n\n- [Philipp Hagemeister](https://github.com/phihag):\n\nHe wrote the chapter on Open function. Thanks Philipp! :+1:\n\nTranslation:\n------------\nIf you want to translate this book in any other language then kindly let [me know](mailto:yasoob.khld@gmail.com). I would love your contribution. The currently translated versions are listed below:\n\n- [Chinese](https://github.com/eastlakeside/interpy-zh)\n- [Russian](https://github.com/lancelote/interpy-ru)\n- [Korean](https://github.com/DDanggle/interpy-kr)\n- [Portuguese](https://github.com/joanasouza/intermediatePython)\n- [Spanish](https://github.com/cursospython/LibroPython)\n\nLicense:\n-------\n\nThis book is released under the [following](http://creativecommons.org/licenses/by-nc-sa/4.0/) CC license (CC BY-NC-SA 4.0).\n\nIf you end up using/recommending this book to someone then kindly [let me know](mailto:yasoob.khld@gmail.com). :smile:\n\n\n"
        },
        {
          "name": "__slots__magic.rst",
          "type": "blob",
          "size": 3.0927734375,
          "content": "\\_\\_slots\\_\\_ Magic\n-------------------\n\nIn Python every class can have instance attributes. By default Python\nuses a dict to store an object’s instance attributes. This is really\nhelpful as it allows setting arbitrary new attributes at runtime.\n\nHowever, for small classes with known attributes it might be a\nbottleneck. The ``dict`` wastes a lot of RAM. Python can’t just allocate\na static amount of memory at object creation to store all the\nattributes. Therefore it sucks a lot of RAM if you create a lot of\nobjects (I am talking in thousands and millions). Still there is a way\nto circumvent this issue. It involves the usage of ``__slots__`` to\ntell Python not to use a dict, and only allocate space for a fixed set\nof attributes. Here is an example with and without ``__slots__``:\n\n**Without** ``__slots__``:\n\n.. code:: python\n\n    class MyClass(object):\n        def __init__(self, name, identifier):\n            self.name = name\n            self.identifier = identifier\n            self.set_up()\n        # ...\n\n**With** ``__slots__``:\n\n.. code:: python\n\n    class MyClass(object):\n        __slots__ = ['name', 'identifier']\n        def __init__(self, name, identifier):\n            self.name = name\n            self.identifier = identifier\n            self.set_up()\n        # ...\n\nThe second piece of code will reduce the burden on your RAM. Some people\nhave seen almost 40 to 50% reduction in RAM usage by using this\ntechnique.\n\nOn a sidenote, you might want to give PyPy a try. It does all of these\noptimizations by default.\n\n\nBelow you can see an example showing exact memory usage with and without ``__slots__`` done in IPython thanks to https://github.com/ianozsvald/ipython_memory_usage\n\n.. code:: python\n\n\tPython 3.4.3 (default, Jun  6 2015, 13:32:34)\n\tType \"copyright\", \"credits\" or \"license\" for more information.\n\n\tIPython 4.0.0 -- An enhanced Interactive Python.\n\t?         -> Introduction and overview of IPython's features.\n\t%quickref -> Quick reference.\n\thelp      -> Python's own help system.\n\tobject?   -> Details about 'object', use 'object??' for extra details.\n\n\tIn [1]: import ipython_memory_usage.ipython_memory_usage as imu\n\n\tIn [2]: imu.start_watching_memory()\n\tIn [2] used 0.0000 MiB RAM in 5.31s, peaked 0.00 MiB above current, total RAM usage 15.57 MiB\n\n\tIn [3]: %cat slots.py\n\tclass MyClass(object):\n\t\t__slots__ = ['name', 'identifier']\n\t\tdef __init__(self, name, identifier):\n\t\t\tself.name = name\n\t\t\tself.identifier = identifier\n\n\tnum = 1024*256\n\tx = [MyClass(1,1) for i in range(num)]\n\tIn [3] used 0.2305 MiB RAM in 0.12s, peaked 0.00 MiB above current, total RAM usage 15.80 MiB\n\n\tIn [4]: from slots import *\n\tIn [4] used 9.3008 MiB RAM in 0.72s, peaked 0.00 MiB above current, total RAM usage 25.10 MiB\n\n\tIn [5]: %cat noslots.py\n\tclass MyClass(object):\n\t\tdef __init__(self, name, identifier):\n\t\t\tself.name = name\n\t\t\tself.identifier = identifier\n\n\tnum = 1024*256\n\tx = [MyClass(1,1) for i in range(num)]\n\tIn [5] used 0.1758 MiB RAM in 0.12s, peaked 0.00 MiB above current, total RAM usage 25.28 MiB\n\n\tIn [6]: from noslots import *\n\tIn [6] used 22.6680 MiB RAM in 0.80s, peaked 0.00 MiB above current, total RAM usage 47.95 MiB\n"
        },
        {
          "name": "_static",
          "type": "tree",
          "content": null
        },
        {
          "name": "_templates",
          "type": "tree",
          "content": null
        },
        {
          "name": "args_and_kwargs.rst",
          "type": "blob",
          "size": 3.671875,
          "content": "\\*args and \\*\\*kwargs\n---------------------\n\nI have come to see that most new python programmers have a hard time\nfiguring out the \\*args and \\*\\*kwargs magic variables. So what are they\n? First of all, let me tell you that it is not necessary to write \\*args\nor \\*\\*kwargs. Only the ``*`` (asterisk) is necessary. You could have\nalso written \\*var and \\*\\*vars. Writing \\*args and \\*\\*kwargs is just a\nconvention. So now let's take a look at \\*args first.\n\nUsage of \\*args\n^^^^^^^^^^^^^^^\n\n\\*args and \\*\\*kwargs are mostly used in function definitions. \\*args\nand \\*\\*kwargs allow you to pass an unspecified number of arguments to a\nfunction, so when writing the function definition, you do not need to\nknow how many arguments will be passed to your function. \\*args is used to\nsend a **non-keyworded** variable length argument list to the function. \nHere's an example to help you get a clear idea:\n\n.. code:: python\n\n    def test_var_args(f_arg, *argv):\n        print(\"first normal arg:\", f_arg)\n        for arg in argv:\n            print(\"another arg through *argv:\", arg)\n\n    test_var_args('yasoob', 'python', 'eggs', 'test')\n\nThis produces the following result:\n\n.. code:: python\n\n    first normal arg: yasoob\n    another arg through *argv: python\n    another arg through *argv: eggs\n    another arg through *argv: test\n\nI hope this cleared away any confusion that you had. So now let's talk\nabout \\*\\*kwargs\n\nUsage of \\*\\*kwargs\n^^^^^^^^^^^^^^^^^^^\n\n\\*\\*kwargs allows you to pass **keyworded** variable length of arguments\nto a function. You should use \\*\\*kwargs if you want to handle **named\narguments** in a function. Here is an example to get you going with it:\n\n.. code:: python\n\n    def greet_me(**kwargs):\n        for key, value in kwargs.items():\n            print(\"{0} = {1}\".format(key, value))\n\n    >>> greet_me(name=\"yasoob\")\n    name = yasoob\n\nSo you can see how we handled a keyworded argument list in our function.\nThis is just the basics of \\*\\*kwargs and you can see how useful it is.\nNow let's talk about how you can use \\*args and \\*\\*kwargs to call a\nfunction with a list or dictionary of arguments.\n\nUsing \\*args and \\*\\*kwargs to call a function\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nSo here we will see how to call a function using \\*args and \\*\\*kwargs.\nJust consider that you have this little function:\n\n.. code:: python\n\n    def test_args_kwargs(arg1, arg2, arg3):\n        print(\"arg1:\", arg1)\n        print(\"arg2:\", arg2)\n        print(\"arg3:\", arg3)\n\nNow you can use \\*args or \\*\\*kwargs to pass arguments to this little\nfunction. Here's how to do it:\n\n.. code:: python\n\n    # first with *args\n    >>> args = (\"two\", 3, 5)\n    >>> test_args_kwargs(*args)\n    arg1: two\n    arg2: 3\n    arg3: 5\n\n    # now with **kwargs:\n    >>> kwargs = {\"arg3\": 3, \"arg2\": \"two\", \"arg1\": 5}\n    >>> test_args_kwargs(**kwargs)\n    arg1: 5\n    arg2: two\n    arg3: 3\n\n**Order of using \\*args \\*\\*kwargs and formal args**\n\nSo if you want to use all three of these in functions then the order is\n\n.. code:: python\n\n    some_func(fargs, *args, **kwargs)\n\nWhen to use them?\n^^^^^^^^^^^^^^^^^\n\nIt really depends on what your requirements are. The most common use\ncase is when making function decorators (discussed in another chapter).\nMoreover it can be used in monkey patching as well. Monkey patching\nmeans modifying some code at runtime. Consider that you have a class\nwith a function called ``get_info`` which calls an API and returns the\nresponse data. If we want to test it we can replace the API call with\nsome test data. For instance:\n\n.. code:: python\n\n    import someclass\n\n    def get_info(self, *args):\n        return \"Test data\"\n\n    someclass.get_info = get_info\n\nI am sure that you can think of some other use cases as well.\n"
        },
        {
          "name": "classes.rst",
          "type": "blob",
          "size": 5.728515625,
          "content": "Classes\n-------\n\nClasses are the core of Python. They give us a lot of power but it is\nreally easy to misuse this power. In this section I will share some\nobscure tricks and caveats related to ``classes`` in Python. Let's get\ngoing!\n\n1. Instance & Class variables\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nMost beginners and even some advanced Python programmers do not\nunderstand the distinction between instance and class variables. Their\nlack of understanding forces them to use these different types of\nvariables incorrectly. Let's understand them.\n\nThe basic difference is:\n\n-  Instance variables are for data which is unique to every object\n-  Class variables are for data shared between different instances of a\n   class\n\nLet's take a look at an example:\n\n.. code:: python\n\n    class Cal(object):\n        # pi is a class variable\n        pi = 3.142\n\n        def __init__(self, radius):\n            # self.radius is an instance variable\n            self.radius = radius\n\n        def area(self):\n            return self.pi * (self.radius ** 2)\n\n    a = Cal(32)\n    a.area()\n    # Output: 3217.408\n    a.pi\n    # Output: 3.142\n    a.pi = 43\n    a.pi\n    # Output: 43\n\n    b = Cal(44)\n    b.area()\n    # Output: 6082.912\n    b.pi\n    # Output: 3.142\n    b.pi = 50\n    b.pi\n    # Output: 50\n\nThere are not many issues while using immutable class variables. This is\nthe major reason due to which beginners do not try to learn more about\nthis subject because everything works! If you also believe that instance\nand class variables can not cause any problem if used incorrectly then\ncheck the next example.\n\n.. code:: python\n\n    class SuperClass(object):\n        superpowers = []\n\n        def __init__(self, name):\n            self.name = name\n\n        def add_superpower(self, power):\n            self.superpowers.append(power)\n\n    foo = SuperClass('foo')\n    bar = SuperClass('bar')\n    foo.name\n    # Output: 'foo'\n\n    bar.name\n    # Output: 'bar'\n\n    foo.add_superpower('fly')\n    bar.superpowers\n    # Output: ['fly']\n\n    foo.superpowers\n    # Output: ['fly']\n\nThat is the beauty of the wrong usage of mutable class variables. To\nmake your code safe against this kind of surprise attacks then make sure\nthat you do not use mutable class variables. You may use them only if\nyou know what you are doing.\n\n2. New style classes\n^^^^^^^^^^^^^^^^^^^^\n\nNew style classes were introduced in Python 2.1 but a lot of people do\nnot know about them even now! It is so because Python also supports old\nstyle classes just to maintain backward compatibility. I have said a lot\nabout new and old but I have not told you about the difference. Well the\nmajor difference is that:\n\n-  Old base classes do not inherit from anything\n-  New style base classes inherit from ``object``\n\nA very basic example is:\n\n.. code:: python\n\n    class OldClass():\n        def __init__(self):\n            print('I am an old class')\n\n    class NewClass(object):\n        def __init__(self):\n            print('I am a jazzy new class')\n\n    old = OldClass()\n    # Output: I am an old class\n\n    new = NewClass()\n    # Output: I am a jazzy new class\n\nThis inheritance from ``object`` allows new style classes to utilize\nsome *magic*. A major advantage is that you can employ some useful\noptimizations like ``__slots__``. You can use ``super()`` and\ndescriptors and the likes. Bottom line? Always try to use new-style\nclasses.\n\n**Note:** Python 3 only has new-style classes. It does not matter\nwhether you subclass from ``object`` or not. However it is recommended\nthat you still subclass from ``object``.\n\n3. Magic Methods\n^^^^^^^^^^^^^^^^\n\nPython's classes are famous for their magic methods, commonly called\n**dunder** (double underscore) methods. I am going to discuss a few of\nthem.\n\n-  ``__init__``\n\nIt is a class initializer. Whenever an instance of a class is created\nits ``__init__`` method is called. For example:\n\n.. code:: python\n\n    class GetTest(object):\n        def __init__(self):\n            print('Greetings!!')\n        def another_method(self):\n            print('I am another method which is not'\n                  ' automatically called')\n\n    a = GetTest()\n    # Output: Greetings!!\n\n    a.another_method()\n    # Output: I am another method which is not automatically\n    # called\n\nYou can see that ``__init__`` is called immediately after an instance is\ncreated. You can also pass arguments to the class during its\ninitialization. Like this:\n\n.. code:: python\n\n    class GetTest(object):\n        def __init__(self, name):\n            print('Greetings!! {0}'.format(name))\n        def another_method(self):\n            print('I am another method which is not'\n                  ' automatically called')\n\n    a = GetTest('yasoob')\n    # Output: Greetings!! yasoob\n\n    # Try creating an instance without the name arguments\n    b = GetTest()\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>\n    TypeError: __init__() takes exactly 2 arguments (1 given)\n\nI am sure that now you understand the ``__init__`` method.\n\n-  ``__getitem__``\n\nImplementing **getitem** in a class allows its instances to use the []\n(indexer) operator. Here is an example:\n\n.. code:: python\n\n    class GetTest(object):\n        def __init__(self):\n            self.info = {\n                'name':'Yasoob',\n                'country':'Pakistan',\n                'number':12345812\n            }\n\n        def __getitem__(self,i):\n            return self.info[i]\n\n    foo = GetTest()\n\n    foo['name']\n    # Output: 'Yasoob'\n\n    foo['number']\n    # Output: 12345812\n\nWithout the ``__getitem__`` method we would have got this error:\n\n.. code:: python\n\n    >>> foo['name']\n\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>\n    TypeError: 'GetTest' object has no attribute '__getitem__'\n\n.. Static, Class & Abstract methods\n.. ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n"
        },
        {
          "name": "collections.rst",
          "type": "blob",
          "size": 10.0576171875,
          "content": "Collections\n-----------\n\nPython ships with a module that contains a number of container data\ntypes called Collections. We will talk about a few of them and discuss\ntheir usefulness.\n\nThe ones which we will talk about are:\n\n-  ``defaultdict``\n-  ``OrderedDict``\n-  ``Counter``\n-  ``deque``\n-  ``namedtuple``\n-  ``enum.Enum`` (outside of the module; Python 3.4+)\n\n``defaultdict``\n^^^^^^^^^^^^^^^^^^^\n\nI personally use defaultdict quite a bit. Unlike ``dict``, with\n``defaultdict`` you do not need to check whether a key is present or\nnot. So we can do:\n\n.. code:: python\n\n    from collections import defaultdict\n\n    colours = (\n        ('Yasoob', 'Yellow'),\n        ('Ali', 'Blue'),\n        ('Arham', 'Green'),\n        ('Ali', 'Black'),\n        ('Yasoob', 'Red'),\n        ('Ahmed', 'Silver'),\n    )\n\n    favourite_colours = defaultdict(list)\n\n    for name, colour in colours:\n        favourite_colours[name].append(colour)\n\n    print(favourite_colours)\n\n    # output\n    # defaultdict(<type 'list'>,\n    #    {'Arham': ['Green'],\n    #     'Yasoob': ['Yellow', 'Red'],\n    #     'Ahmed': ['Silver'],\n    #     'Ali': ['Blue', 'Black']\n    # })\n\nOne other very important use case is when you are appending to nested\nlists inside a dictionary. If a ``key`` is not already present in the\ndictionary then you are greeted with a ``KeyError``. ``defaultdict``\nallows us to circumvent this issue in a clever way. First let me share\nan example using ``dict`` which raises ``KeyError`` and then I will\nshare a solution using ``defaultdict``.\n\n**Problem:**\n\n.. code:: python\n\n    some_dict = {}\n    some_dict['colours']['favourite'] = \"yellow\"\n    # Raises KeyError: 'colours'\n\n**Solution:**\n\n.. code:: python\n\n    from collections import defaultdict\n    tree = lambda: defaultdict(tree)\n    some_dict = tree()\n    some_dict['colours']['favourite'] = \"yellow\"\n    # Works fine\n\nYou can print ``some_dict`` using ``json.dumps``. Here is some\nsample code:\n\n.. code:: python\n\n    import json\n    print(json.dumps(some_dict))\n    # Output: {\"colours\": {\"favourite\": \"yellow\"}}\n\n``OrderedDict``\n^^^^^^^^^^^^^^^^^^^\n\n``OrderedDict`` keeps its entries sorted as they are initially inserted.\nOverwriting a value of an existing key doesn't change the position of\nthat key. However, deleting and reinserting an entry moves the key to\nthe end of the dictionary. \n\n**Problem:**\n\n.. code:: python\n\n    colours =  {\"Red\" : 198, \"Green\" : 170, \"Blue\" : 160}\n    for key, value in colours.items():\n        print(key, value)\n    # Output:\n    #   Green 170\n    #   Blue 160\n    #   Red 198\n    # Entries are retrieved in an unpredictable order\n   \n**Solution:**\n\n.. code:: python\n\n    from collections import OrderedDict\n    \n    colours = OrderedDict([(\"Red\", 198), (\"Green\", 170), (\"Blue\", 160)])\n    for key, value in colours.items():\n        print(key, value)\n    # Output:\n    #   Red 198\n    #   Green 170\n    #   Blue 160\n    # Insertion order is preserved\n\n``Counter``\n^^^^^^^^^^^^^^^\n\nCounter allows us to count the occurrences of a particular item. For\ninstance it can be used to count the number of individual favourite\ncolours:\n\n.. code:: python\n\n    from collections import Counter\n\n    colours = (\n        ('Yasoob', 'Yellow'),\n        ('Ali', 'Blue'),\n        ('Arham', 'Green'),\n        ('Ali', 'Black'),\n        ('Yasoob', 'Red'),\n        ('Ahmed', 'Silver'),\n    )\n\n    favs = Counter(name for name, colour in colours)\n    print(favs)\n    # Output: Counter({\n    #    'Yasoob': 2,\n    #    'Ali': 2,\n    #    'Arham': 1,\n    #    'Ahmed': 1\n    # })\n\nWe can also count the most common lines in a file using it. For example:\n\n.. code:: python\n\n    with open('filename', 'rb') as f:\n        line_count = Counter(f)\n    print(line_count)\n\n``deque``\n^^^^^^^^^^^^^\n\n``deque`` provides you with a double ended queue which means that you\ncan append and delete elements from either side of the queue. First of\nall you have to import the deque module from the collections library:\n\n.. code:: python\n\n    from collections import deque\n\nNow we can instantiate a deque object.\n\n.. code:: python\n\n    d = deque()\n\nIt works like python lists and provides you with somewhat similar\nmethods as well. For example you can do:\n\n.. code:: python\n\n    d = deque()\n    d.append('1')\n    d.append('2')\n    d.append('3')\n\n    print(len(d))\n    # Output: 3\n\n    print(d[0])\n    # Output: '1'\n\n    print(d[-1])\n    # Output: '3'\n\nYou can pop values from both sides of the deque:\n\n.. code:: python\n\n    d = deque(range(5))\n    print(len(d))\n    # Output: 5\n\n    d.popleft()\n    # Output: 0\n\n    d.pop()\n    # Output: 4\n\n    print(d)\n    # Output: deque([1, 2, 3])\n\nWe can also limit the amount of items a deque can hold. By doing this\nwhen we achieve the maximum limit of our deque it will simply pop out\nthe items from the opposite end. It is better to explain it using an\nexample so here you go:\n\n.. code:: python\n\n    d = deque([0, 1, 2, 3, 5], maxlen=5)\n    print(d)\n    # Output: deque([0, 1, 2, 3, 5], maxlen=5)\n    \n    d.extend([6])\n    print(d)\n    #Output: deque([1, 2, 3, 5, 6], maxlen=5)\n\nNow whenever you insert values after 5, the leftmost value will be\npopped from the list. You can also expand the list in any direction with\nnew values:\n\n.. code:: python\n\n    d = deque([1,2,3,4,5])\n    d.extendleft([0])\n    d.extend([6,7,8])\n    print(d)\n    # Output: deque([0, 1, 2, 3, 4, 5, 6, 7, 8])\n\n``namedtuple``\n^^^^^^^^^^^^^^^^^^\n\nYou might already be acquainted with tuples. A tuple is basically\na immutable list which allows you to store a sequence of values\nseparated by commas. They are just like lists but have a few key\ndifferences. The major one is that unlike lists, **you can not\nreassign an item in a tuple**. In order to access the value in a\ntuple you use integer indexes like:\n\n.. code:: python\n\n    man = ('Ali', 30)\n    print(man[0])\n    # Output: Ali\n\nWell, so now what are ``namedtuples``? They turn tuples into convenient\ncontainers for simple tasks. With namedtuples you don't have to use\ninteger indexes for accessing members of a tuple. You can think of\nnamedtuples like dictionaries but unlike dictionaries they are\nimmutable.\n\n.. code:: python\n\n    from collections import namedtuple\n\n    Animal = namedtuple('Animal', 'name age type')\n    perry = Animal(name=\"perry\", age=31, type=\"cat\")\n\n    print(perry)\n    # Output: Animal(name='perry', age=31, type='cat')\n\n    print(perry.name)\n    # Output: 'perry'\n\nYou can now see that we can access members of a tuple just by their\nname using a ``.``. Let's dissect it a little more. A named tuple has two\nrequired arguments. They are the tuple name and the tuple field\\_names.\nIn the above example our tuple name was 'Animal' and the tuple\nfield\\_names were 'name', 'age' and 'type'. Namedtuple makes your tuples\n**self-document**. You can easily understand what is going on by having\na quick glance at your code. And as you are not bound to use integer\nindexes to access members of a tuple, it makes it more easy to maintain\nyour code. Moreover, as **`namedtuple` instances do not have\nper-instance dictionaries**, they are lightweight and require no more\nmemory than regular tuples. This makes them faster than dictionaries.\nHowever, do remember that as with tuples, **attributes in namedtuples\nare immutable**. It means that this would not work:\n\n.. code:: python\n\n    from collections import namedtuple\n\n    Animal = namedtuple('Animal', 'name age type')\n    perry = Animal(name=\"perry\", age=31, type=\"cat\")\n    perry.age = 42\n\n    # Output: Traceback (most recent call last):\n    #            File \"\", line 1, in\n    #         AttributeError: can't set attribute\n\nYou should use named tuples to make your code self-documenting. **They\nare backwards compatible with normal tuples**. It means that you can use\ninteger indexes with namedtuples as well:\n\n.. code:: python\n\n    from collections import namedtuple\n\n    Animal = namedtuple('Animal', 'name age type')\n    perry = Animal(name=\"perry\", age=31, type=\"cat\")\n    print(perry[0])\n    # Output: perry\n\nLast but not the least, you can convert a namedtuple to a dictionary.\nLike this:\n\n.. code:: python\n\n    from collections import namedtuple\n\n    Animal = namedtuple('Animal', 'name age type')\n    perry = Animal(name=\"Perry\", age=31, type=\"cat\")\n    print(perry._asdict())\n    # Output: OrderedDict([('name', 'Perry'), ('age', 31), ...\n\n``enum.Enum`` (Python 3.4+)\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAnother useful collection is the enum object. It is available in the ``enum``\nmodule, in Python 3.4 and up (also available as a backport in PyPI named ``enum34``.)\nEnums (`enumerated type <https://en.wikipedia.org/wiki/Enumerated_type>`_) are\nbasically a way to organize various things.\n\nLet’s consider the Animal namedtuple from the last example.  It had a ``type``\nfield.  The problem is, the type was a string.  This poses some problems for\nus. What if the user types in ``Cat`` because they held the Shift key?  Or\n``CAT``?  Or ``kitten``?\n\nEnumerations can help us avoid this problem, by not using strings.  Consider\nthis example:\n\n.. code:: python\n\n    from collections import namedtuple\n    from enum import Enum\n\n    class Species(Enum):\n        cat = 1\n        dog = 2\n        horse = 3\n        aardvark = 4\n        butterfly = 5\n        owl = 6\n        platypus = 7\n        dragon = 8\n        unicorn = 9\n        # The list goes on and on...\n\n        # But we don't really care about age, so we can use an alias.\n        kitten = 1\n        puppy = 2\n\n    Animal = namedtuple('Animal', 'name age type')\n    perry = Animal(name=\"Perry\", age=31, type=Species.cat)\n    drogon = Animal(name=\"Drogon\", age=4, type=Species.dragon)\n    tom = Animal(name=\"Tom\", age=75, type=Species.cat)\n    charlie = Animal(name=\"Charlie\", age=2, type=Species.kitten)\n\n    # And now, some tests.\n    >>> charlie.type == tom.type\n    True\n    >>> charlie.type\n    <Species.cat: 1>\n\n\nThis is much less error-prone.  We have to be specific, and we should use only\nthe enumeration to name types.\n\nThere are three ways to access enumeration members.  For example, all three\nmethods will get you the value for ``cat``:\n\n.. code:: python\n\n    Species(1)\n    Species['cat']\n    Species.cat\n\nThis was just a quick drive through the ``collections`` module. Make\nsure you read the official documentation after reading this.\n"
        },
        {
          "name": "comprehensions.rst",
          "type": "blob",
          "size": 3.0986328125,
          "content": "Comprehensions\n--------------\n\nComprehensions are a feature of Python which I would really miss if I\never have to leave it. Comprehensions are constructs that allow\nsequences to be built from other sequences. Several types of\ncomprehensions are supported in both Python 2 and Python 3:\n\n-  list comprehensions\n-  dictionary comprehensions\n-  set comprehensions\n-  generator comprehensions\n\nWe will discuss them one by one. Once you get the hang of using ``list``\ncomprehensions then you can use any of them easily.\n\n``list`` comprehensions\n^^^^^^^^^^^^^^^^^^^^^^^\n\nList comprehensions provide a short and concise way to create lists. It\nconsists of square brackets containing an expression followed by a\n``for`` clause, then zero or more ``for`` or ``if`` clauses. The\nexpressions can be anything, meaning you can put in all kinds of objects\nin lists. The result would be a new list made after the evaluation of\nthe expression in context of the ``if`` and ``for`` clauses.\n\n**Blueprint**\n\n.. code:: python\n\n    variable = [out_exp for out_exp in input_list if out_exp == 2]\n\nHere is a short example:\n\n.. code:: python\n\n    multiples = [i for i in range(30) if i % 3 == 0]\n    print(multiples)\n    # Output: [0, 3, 6, 9, 12, 15, 18, 21, 24, 27]\n\nThis can be really useful to make lists quickly. It is even preferred by\nsome instead of the ``filter`` function. List comprehensions really\nshine when you want to supply a list to a method or function to make a\nnew list by appending to it in each iteration of the ``for`` loop. For\ninstance you would usually do something like this:\n\n.. code:: python\n\n    squared = []\n    for x in range(10):\n        squared.append(x**2)\n\nYou can simplify it using list comprehensions. For example:\n\n.. code:: python\n\n    squared = [x**2 for x in range(10)]\n\n``dict`` comprehensions\n^^^^^^^^^^^^^^^^^^^^^^^\n\nThey are used in a similar way. Here is an example which I found\nrecently:\n\n.. code:: python\n\n    mcase = {'a': 10, 'b': 34, 'A': 7, 'Z': 3}\n\n    mcase_frequency = {\n        k.lower(): mcase.get(k.lower(), 0) + mcase.get(k.upper(), 0)\n        for k in mcase.keys()\n    }\n\n    # mcase_frequency == {'a': 17, 'z': 3, 'b': 34}\n\nIn the above example we are combining the values of keys which are same\nbut in different typecase. I personally do not use ``dict``\ncomprehensions a lot. You can also quickly switch keys and values of a dictionary:\n\n.. code:: python\n\n    {v: k for k, v in some_dict.items()}\n\n``set`` comprehensions\n^^^^^^^^^^^^^^^^^^^^^^\n\nThey are also similar to list comprehensions. The only difference is\nthat they use braces ``{}``. Here is an example:\n\n.. code:: python\n\n    squared = {x**2 for x in [1, 1, 2]}\n    print(squared)\n    # Output: {1, 4}\n\n``generator`` comprehensions\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThey are also similar to list comprehensions. The only difference is that they don't allocate memory for the whole list but generate one item at a time, thus more memory efficient.\n\n.. code:: python\n\n    multiples_gen = (i for i in range(30) if i % 3 == 0)\n    print(multiples_gen)\n    # Output: <generator object <genexpr> at 0x7fdaa8e407d8>\n    for x in multiples_gen:\n      print(x)\n      # Outputs numbers\n"
        },
        {
          "name": "conf.py",
          "type": "blob",
          "size": 9.78515625,
          "content": "# -*- coding: utf-8 -*-\n#\n# Python Tips documentation build configuration file, created by\n# sphinx-quickstart on Tue Apr 28 00:44:47 2015.\n#\n# This file is execfile()d with the current directory set to its containing dir.\n#\n# Note that not all possible configuration values are present in this\n# autogenerated file.\n#\n# All configuration values have a default; values that are commented out\n# serve to show the default.\n\nimport sys, os\nimport sphinx_rtd_theme\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\n#sys.path.insert(0, os.path.abspath('.'))\n\n# -- General configuration -----------------------------------------------------\n\n# If your documentation needs a minimal Sphinx version, state it here.\n#needs_sphinx = '1.0'\n\n# Add any Sphinx extension module names here, as strings. They can be extensions\n# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.\nextensions = ['sphinx.ext.todo']\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = ['_templates']\n\n# The suffix of source filenames.\nsource_suffix = '.rst'\n\n# The encoding of source files.\n#source_encoding = 'utf-8-sig'\n\n# The master toctree document.\nmaster_doc = 'index'\n\n# General information about the project.\nproject = u'Python Tips'\ncopyright = u'2017, Muhammad Yasoob Ullah Khalid'\n\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The short X.Y version.\nversion = '0.1'\n# The full version, including alpha/beta/rc tags.\nrelease = '0.1'\n\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n#language = None\n\n# There are two options for replacing |today|: either, you set today to some\n# non-false value, then it is used:\n#today = ''\n# Else, today_fmt is used as the format for a strftime call.\n#today_fmt = '%B %d, %Y'\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\nexclude_patterns = ['_build']\n\n# The reST default role (used for this markup: `text`) to use for all documents.\n#default_role = None\n\n# If true, '()' will be appended to :func: etc. cross-reference text.\n#add_function_parentheses = True\n\n# If true, the current module name will be prepended to all description\n# unit titles (such as .. function::).\n#add_module_names = True\n\n# If true, sectionauthor and moduleauthor directives will be shown in the\n# output. They are ignored by default.\n#show_authors = False\n\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = 'sphinx'\n\n# A list of ignored prefixes for module index sorting.\n#modindex_common_prefix = []\n\n# If true, keep warnings as \"system message\" paragraphs in the built documents.\n#keep_warnings = False\n\n\n# -- Options for HTML output ---------------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\nhtml_theme = 'default'\n\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\n#html_theme_options = {}\n\n# Add any paths that contain custom themes here, relative to this directory.\n#html_theme_path = []\n\n# The name for this set of Sphinx documents.  If None, it defaults to\n# \"<project> v<release> documentation\".\n#html_title = None\n\n# A shorter title for the navigation bar.  Default is the same as html_title.\n#html_short_title = None\n\n# The name of an image file (relative to this directory) to place at the top\n# of the sidebar.\n#html_logo = None\n\n# The name of an image file (within the static path) to use as favicon of the\n# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32\n# pixels large.\n#html_favicon = None\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named \"default.css\" will overwrite the builtin \"default.css\".\nhtml_static_path = ['_static']\n\n# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,\n# using the given strftime format.\n#html_last_updated_fmt = '%b %d, %Y'\n\n# If true, SmartyPants will be used to convert quotes and dashes to\n# typographically correct entities.\n#html_use_smartypants = True\n\n# Custom sidebar templates, maps document names to template names.\n#html_sidebars = {}\n\n# Additional templates that should be rendered to pages, maps page names to\n# template names.\n#html_additional_pages = {}\n\n# If false, no module index is generated.\n#html_domain_indices = True\n\n# If false, no index is generated.\n#html_use_index = True\n\n# If true, the index is split into individual pages for each letter.\n#html_split_index = False\n\n# If true, links to the reST sources are added to the pages.\n#html_show_sourcelink = True\n\n# If true, \"Created using Sphinx\" is shown in the HTML footer. Default is True.\nhtml_show_sphinx = False\n\n# If true, \"(C) Copyright ...\" is shown in the HTML footer. Default is True.\n#html_show_copyright = True\n\n# If true, an OpenSearch description file will be output, and all pages will\n# contain a <link> tag referring to it.  The value of this option must be the\n# base URL from which the finished HTML is served.\n#html_use_opensearch = ''\n\n# This is the file name suffix for HTML files (e.g. \".xhtml\").\n#html_file_suffix = None\n\n# Output file base name for HTML help builder.\nhtmlhelp_basename = 'PythonTipsdoc'\n\n\n# -- Options for LaTeX output --------------------------------------------------\n\nlatex_elements = {\n    'fontpkg':      r'\\usepackage{mathpazo}',\n    'papersize':    'a4paper',\n    'pointsize':    '12pt',\n    'classoptions': ',oneside',\n    'babel': r'\\usepackage[english]{babel}',\n    'preamble':     r'\\usepackage{flaskstyle}'\n}\nlatex_use_parts = True\n\n# Grouping the document tree into LaTeX files. List of tuples\n# (source start file, target name, title, author, documentclass [howto/manual]).\nlatex_documents = [\n  ('index', 'PythonTips.tex', u'Python Tips',\n   u'Muhammad Yasoob Ullah Khalid', 'manual'),\n]\n\n# The name of an image file (relative to this directory) to place at the top of\n# the title page.\nlatex_logo = '_static/cover.pdf'\nlatex_additional_files = ['flaskstyle.sty', '_static/cover.pdf']\n\n# For \"manual\" documents, if this is true, then toplevel headings are parts,\n# not chapters.\n#latex_use_parts = False\n\n# If true, show page references after internal links.\n#latex_show_pagerefs = False\n\n# If true, show URL addresses after external links.\n#latex_show_urls = False\n\n# Documents to append as an appendix to all manuals.\n#latex_appendices = []\n\n# If false, no module index is generated.\n#latex_domain_indices = True\n\n\n# -- Options for manual page output --------------------------------------------\n\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [\n    ('index', 'pythontips', u'Python Tips',\n     [u'Muhammad Yasoob Ullah Khalid'], 1)\n]\n\n# If true, show URL addresses after external links.\n#man_show_urls = False\n\n\n# -- Options for Texinfo output ------------------------------------------------\n\n# Grouping the document tree into Texinfo files. List of tuples\n# (source start file, target name, title, author,\n#  dir menu entry, description, category)\ntexinfo_documents = [\n  ('index', 'PythonTips', u'Python Tips',\n   u'Muhammad Yasoob Ullah Khalid', 'PythonTips', 'One line description of project.',\n   'Miscellaneous'),\n]\n\n# Documents to append as an appendix to all manuals.\n#texinfo_appendices = []\n\n# If false, no module index is generated.\n#texinfo_domain_indices = True\n\n# How to display URL addresses: 'footnote', 'no', or 'inline'.\n#texinfo_show_urls = 'footnote'\n\n# If true, do not generate a @detailmenu in the \"Top\" node's menu.\n#texinfo_no_detailmenu = False\n\n\n# -- Options for Epub output ---------------------------------------------------\n\n# Bibliographic Dublin Core info.\nepub_title = u'Python Tips'\nepub_author = u'Muhammad Yasoob Ullah Khalid'\nepub_publisher = u'Muhammad Yasoob Ullah Khalid'\nepub_copyright = u'2017, Muhammad Yasoob Ullah Khalid'\n\n\n#epub_theme = 'epub'\n\n# The language of the text. It defaults to the language option\n# or en if the language is not set.\n#epub_language = ''\n\n# The scheme of the identifier. Typical schemes are ISBN or URL.\n#epub_scheme = ''\n\n# The unique identifier of the text. This can be a ISBN number\n# or the project homepage.\n#epub_identifier = ''\n\n# A unique identification for the text.\n#epub_uid = ''\n\n# A tuple containing the cover image and cover page html template filenames.\nepub_cover = ('_static/cover.png', 'epub-cover.html')\n\n# A sequence of (type, uri, title) tuples for the guide element of content.opf.\n#epub_guide = ()\n\n# HTML files that should be inserted before the pages created by sphinx.\n# The format is a list of tuples containing the path and title.\n#epub_pre_files = []\n\n# HTML files shat should be inserted after the pages created by sphinx.\n# The format is a list of tuples containing the path and title.\n#epub_post_files = []\n\n# A list of files that should not be packed into the epub file.\n#epub_exclude_files = []\n\n# The depth of the table of contents in toc.ncx.\n#epub_tocdepth = 3\n\n# Allow duplicate toc entries.\n#epub_tocdup = True\n\n# Fix unsupported image types using the PIL.\n#epub_fix_images = False\n\n# Scale large images.\n#epub_max_image_width = 0\n\n# If 'no', URL addresses will not be shown.\n#epub_show_urls = 'inline'\n\n# If false, no index is generated.\nepub_use_index = False\n\nsys.path.append(os.path.abspath('_themes'))\n#html_theme_path = ['_themes']\nhtml_theme_path = [sphinx_rtd_theme.get_html_theme_path()]\nhtml_theme = 'sphinx_rtd_theme'\n\n"
        },
        {
          "name": "context_managers.rst",
          "type": "blob",
          "size": 6.423828125,
          "content": "Context Managers\n----------------\n\nContext managers allow you to allocate and release resources precisely\nwhen you want to. The most widely used example of context managers is\nthe ``with`` statement. Suppose you have two related operations which\nyou’d like to execute as a pair, with a block of code in between.\nContext managers allow you to do specifically that. For example:\n\n.. code:: python\n\n    with open('some_file', 'w') as opened_file:\n        opened_file.write('Hola!')\n\nThe above code opens the file, writes some data to it and then closes\nit. If an error occurs while writing the data to the file, it tries to\nclose it. The above code is equivalent to:\n\n.. code:: python\n\n    file = open('some_file', 'w')\n    try:\n        file.write('Hola!')\n    finally:\n        file.close()\n\nWhile comparing it to the first example we can see that a lot of\nboilerplate code is eliminated just by using ``with``. The main\nadvantage of using a ``with`` statement is that it makes sure our file\nis closed without paying attention to how the nested block exits.\n\nA common use case of context managers is locking and unlocking resources\nand closing opened files (as I have already shown you).\n\nLet's see how we can implement our own Context Manager. This should allow\nus to understand exactly what's going on behind the scenes.\n\nImplementing a Context Manager as a Class:\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAt the very least a context manager has an ``__enter__`` and\n``__exit__`` method defined. Let's make our own file-opening Context\nManager and learn the basics.\n\n.. code:: python\n\n    class File(object):\n        def __init__(self, file_name, method):\n            self.file_obj = open(file_name, method)\n        def __enter__(self):\n            return self.file_obj\n        def __exit__(self, type, value, traceback):\n            self.file_obj.close()\n\nJust by defining ``__enter__`` and ``__exit__`` methods we can use our new class in\na ``with`` statement. Let's try:\n\n.. code:: python\n\n    with File('demo.txt', 'w') as opened_file:\n        opened_file.write('Hola!')\n\nOur ``__exit__`` method accepts three arguments. They are required by\nevery ``__exit__`` method which is a part of a Context Manager class.\nLet's talk about what happens under-the-hood.\n\n1. The ``with`` statement stores the ``__exit__`` method of the ``File``\n   class.\n2. It calls the ``__enter__`` method of the ``File`` class.\n3. The ``__enter__`` method opens the file and returns it.\n4. The opened file handle is passed to ``opened_file``.\n5. We write to the file using ``.write()``.\n6. The ``with`` statement calls the stored ``__exit__`` method.\n7. The ``__exit__`` method closes the file.\n\nHandling Exceptions\n^^^^^^^^^^^^^^^^^^^\n\nWe did not talk about the ``type``, ``value`` and ``traceback``\narguments of the ``__exit__`` method. Between the 4th and 6th step, if\nan exception occurs, Python passes the type, value and traceback of the\nexception to the ``__exit__`` method. It allows the ``__exit__`` method\nto decide how to close the file and if any further steps are required.\nIn our case we are not paying any attention to them.\n\nWhat if our file object raises an exception? We might be trying to\naccess a method on the file object which it does not supports. For\ninstance:\n\n.. code:: python\n\n    with File('demo.txt', 'w') as opened_file:\n        opened_file.undefined_function('Hola!')\n\nLet's list the steps which are taken by the ``with`` statement when\nan error is encountered:\n\n1. It passes the type, value and traceback of the error to the\n   ``__exit__`` method.\n2. It allows the ``__exit__`` method to handle the exception.\n3. If ``__exit__`` returns ``True`` then the exception was gracefully\n   handled.\n4. If anything other than ``True`` is returned by the ``__exit__`` method then\n   the exception is raised by the ``with`` statement.\n\nIn our case the ``__exit__`` method returns ``None`` (when no return\nstatement is encountered then the method returns ``None``). Therefore,\nthe ``with`` statement raises the exception:\n\n.. code:: python\n\n    Traceback (most recent call last):\n      File \"<stdin>\", line 2, in <module>\n    AttributeError: 'file' object has no attribute 'undefined_function'\n\nLet's try handling the exception in the ``__exit__`` method:\n\n.. code:: python\n\n    class File(object):\n        def __init__(self, file_name, method):\n            self.file_obj = open(file_name, method)\n        def __enter__(self):\n            return self.file_obj\n        def __exit__(self, type, value, traceback):\n            print(\"Exception has been handled\")\n            self.file_obj.close()\n            return True\n\n    with File('demo.txt', 'w') as opened_file:\n        opened_file.undefined_function()\n\n    # Output: Exception has been handled\n\nOur ``__exit__`` method returned ``True``, therefore no exception was raised\nby the ``with`` statement.\n\nThis is not the only way to implement Context Managers. There is another\nway and we will be looking at it in the next section.\n\nImplementing a Context Manager as a Generator\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nWe can also implement Context Managers using decorators and generators.\nPython has a contextlib module for this very purpose. Instead of a\nclass, we can implement a Context Manager using a generator function.\nLet's see a basic, useless example:\n\n.. code:: python\n\n    from contextlib import contextmanager\n\n    @contextmanager\n    def open_file(name):\n        f = open(name, 'w')\n        try:\n            yield f\n        finally:\n            f.close()\n\nOkay! This way of implementing Context Managers appear to be more\nintuitive and easy. However, this method requires some knowledge about\ngenerators, yield and decorators. In this example we have not caught any\nexceptions which might occur. It works in mostly the same way as the\nprevious method.\n\nLet's dissect this method a little.\n\n1. Python encounters the ``yield`` keyword. Due to this it creates a\n   generator instead of a normal function.\n2. Due to the decoration, contextmanager is called with the function\n   name (``open_file``) as its argument.\n3. The ``contextmanager`` decorator returns the generator wrapped by the\n   ``GeneratorContextManager`` object.\n4. The ``GeneratorContextManager`` is assigned to the ``open_file``\n   function. Therefore, when we later call the ``open_file`` function, we\n   are actually calling the ``GeneratorContextManager`` object.\n\nSo now that we know all this, we can use the newly generated Context\nManager like this:\n\n.. code:: python\n\n    with open_file('some_file') as f:\n        f.write('hola!')\n"
        },
        {
          "name": "coroutines.rst",
          "type": "blob",
          "size": 2.134765625,
          "content": "Coroutines\n----------\n\nCoroutines are similar to generators with a few differences. The main\ndifferences are:\n\n-  generators are data producers\n-  coroutines are data consumers\n\nFirst of all let's review the generator creation process. We can make\ngenerators like this:\n\n.. code:: python\n\n    def fib():\n        a, b = 0, 1\n        while True:\n            yield a\n            a, b = b, a+b\n\nWe then commonly use it in a ``for`` loop like this:\n\n.. code:: python\n\n    for i in fib():\n        print(i)\n\nIt is fast and does not put a lot of pressure on memory because it\n**generates** the values on the fly rather than storing them in a list.\nNow, if we use ``yield`` in the above example, more generally, we get a\ncoroutine. Coroutines consume values which are sent to it. A very basic\nexample would be a ``grep`` alternative in Python:\n\n.. code:: python\n\n    def grep(pattern):\n        print(\"Searching for\", pattern)\n        while True:\n            line = (yield)\n            if pattern in line:\n                print(line)\n\nWait! What does ``yield`` return? Well we have turned it into a\ncoroutine. It does not contain any value initially, instead we supply it\nvalues externally. We supply values by using the ``.send()`` method.\nHere is an example:\n\n.. code:: python\n\n    search = grep('coroutine')\n    next(search)\n    # Output: Searching for coroutine\n    search.send(\"I love you\")\n    search.send(\"Don't you love me?\")\n    search.send(\"I love coroutines instead!\")\n    # Output: I love coroutines instead!\n\nThe sent values are accessed by ``yield``. Why did we run ``next()``? It is\nrequired in order to start the coroutine. Just like ``generators``, coroutines do not\nstart the function immediately. Instead they run it in response to the\n``__next__()`` and ``.send()`` methods. Therefore, you have to run\n``next()`` so that the execution advances to the ``yield`` expression.\n\nWe can close a coroutine by calling the ``.close()`` method:\n\n.. code:: python\n\n    search = grep('coroutine')\n    # ...\n    search.close()\n\nThere is a lot more to ``coroutines``. I suggest you check out `this\nawesome\npresentation <http://www.dabeaz.com/coroutines/Coroutines.pdf>`__ by\nDavid Beazley.\n"
        },
        {
          "name": "debugging.rst",
          "type": "blob",
          "size": 2.2333984375,
          "content": "Debugging\n---------\n\nDebugging is also something which once mastered can greatly enhance your\nbug hunting skills. Most newcomers neglect the importance of the\nPython debugger (``pdb``). In this section I am going to tell you only a\nfew important commands. You can learn more about it from the official\ndocumentation.\n\n**Running from the command line**\n\nYou can run a script from the command line using the Python debugger.\nHere is an example:\n\n.. code:: python\n\n    $ python -m pdb my_script.py\n\nIt would cause the debugger to stop the execution on the first statement\nit finds. This is helpful if your script is short. You can then inspect\nthe variables and continue execution line-by-line.\n\n**Running from inside a script**\n\nYou can set break points in the script itself so that you can inspect\nthe variables and stuff at particular points. This is possible using the\n``pdb.set_trace()`` method. Here is an example:\n\n.. code:: python\n\n    import pdb\n\n    def make_bread():\n        pdb.set_trace()\n        return \"I don't have time\"\n\n    print(make_bread())\n\nTry running the above script after saving it. You would enter the\ndebugger as soon as you run it. Now it's time to learn some of the\ncommands of the debugger.\n\n**Commands:**\n\n-  ``c``: continue execution\n-  ``w``: shows the context of the current line it is executing.\n-  ``a``: print the argument list of the current function\n-  ``s``: Execute the current line and stop at the first possible\n   occasion.\n-  ``n``: Continue execution until the next line in the current function\n   is reached or it returns.\n\nThe difference between ``n``\\ ext and ``s``\\ tep is that step stops\ninside a called function, while next executes called functions at\n(nearly) full speed, only stopping at the next line in the current\nfunction.\n\nThese are just a few commands. ``pdb`` also supports post mortem. It is\nalso a really handy function. I would highly suggest you to look at the\nofficial documentation and learn more about it.\n\n**Note:**\n\nIt might seem unintuitive to use `pdb.set_trace()` if you are new to this. Fortunately, if you are using Python 3.7+ then you can simply use the `breakpoint()` [built-in function](https://docs.python.org/3/library/functions.html#breakpoint). It automatically imports `pdb` and calls `pdb.set_trace()`.\n"
        },
        {
          "name": "decorators.rst",
          "type": "blob",
          "size": 13.7958984375,
          "content": "Decorators\n----------\n\nDecorators are a significant part of Python. In simple words: they are\nfunctions which modify the functionality of other functions. They help\nto make our code shorter and more Pythonic. Most beginners do not\nknow where to use them so I am going to share some areas where\ndecorators can make your code more concise.\n\nFirst, let's discuss how to write your own decorator.\n\nIt is perhaps one of the most difficult concepts to grasp. We will take\nit one step at a time so that you can fully understand it.\n\nEverything in Python is an object:\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst of all let's understand functions in Python:\n\n.. code:: python\n\n    def hi(name=\"yasoob\"):\n        return \"hi \" + name\n\n    print(hi())\n    # output: 'hi yasoob'\n\n    # We can even assign a function to a variable like\n    greet = hi\n    # We are not using parentheses here because we are not calling the function hi\n    # instead we are just putting it into the greet variable. Let's try to run this\n\n    print(greet())\n    # output: 'hi yasoob'\n\n    # Let's see what happens if we delete the old hi function!\n    del hi\n    print(hi())\n    #outputs: NameError\n\n    print(greet())\n    #outputs: 'hi yasoob'\n\nDefining functions within functions:\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nSo those are the basics when it comes to functions. Let's take your\nknowledge one step further. In Python we can define functions inside\nother functions:\n\n.. code:: python\n\n    def hi(name=\"yasoob\"):\n        print(\"now you are inside the hi() function\")\n\n        def greet():\n            return \"now you are in the greet() function\"\n\n        def welcome():\n            return \"now you are in the welcome() function\"\n\n        print(greet())\n        print(welcome())\n        print(\"now you are back in the hi() function\")\n\n    hi()\n    #output:now you are inside the hi() function\n    #       now you are in the greet() function\n    #       now you are in the welcome() function\n    #       now you are back in the hi() function\n\n    # This shows that whenever you call hi(), greet() and welcome()\n    # are also called. However the greet() and welcome() functions\n    # are not available outside the hi() function e.g:\n\n    greet()\n    #outputs: NameError: name 'greet' is not defined\n\nSo now we know that we can define functions in other functions. In\nother words: we can make nested functions. Now you need to learn one\nmore thing, that functions can return functions too.\n\nReturning functions from within functions:\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIt is not necessary to execute a function within another function, we\ncan return it as an output as well:\n\n.. code:: python\n\n    def hi(name=\"yasoob\"):\n        def greet():\n            return \"now you are in the greet() function\"\n\n        def welcome():\n            return \"now you are in the welcome() function\"\n\n        if name == \"yasoob\":\n            return greet\n        else:\n            return welcome\n\n    a = hi()\n    print(a)\n    #outputs: <function greet at 0x7f2143c01500>\n\n    #This clearly shows that `a` now points to the greet() function in hi()\n    #Now try this\n\n    print(a())\n    #outputs: now you are in the greet() function\n\nJust take a look at the code again. In the ``if/else`` clause we are\nreturning ``greet`` and ``welcome``, not ``greet()`` and ``welcome()``.\nWhy is that? It's because when you put a pair of parentheses after it, the\nfunction gets executed; whereas if you don't put parenthesis after it,\nthen it can be passed around and can be assigned to other variables\nwithout executing it. Did you get it? Let me explain it in a little bit\nmore detail. When we write ``a = hi()``, ``hi()`` gets executed and\nbecause the name is yasoob by default, the function ``greet`` is returned.\nIf we change the statement to ``a = hi(name = \"ali\")`` then the ``welcome``\nfunction will be returned. We can also do print ``hi()()`` which outputs\n*now you are in the greet() function*.\n\nGiving a function as an argument to another function:\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n.. code:: python\n\n    def hi():\n        return \"hi yasoob!\"\n\n    def doSomethingBeforeHi(func):\n        print(\"I am doing some boring work before executing hi()\")\n        print(func())\n\n    doSomethingBeforeHi(hi)\n    #outputs:I am doing some boring work before executing hi()\n    #        hi yasoob!\n\nNow you have all the required knowledge to learn what decorators really\nare. Decorators let you execute code before and after a function.\n\nWriting your first decorator:\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn the last example we actually made a decorator! Let's modify the\nprevious decorator and make a little bit more usable program:\n\n.. code:: python\n\n    def a_new_decorator(a_func):\n\n        def wrapTheFunction():\n            print(\"I am doing some boring work before executing a_func()\")\n\n            a_func()\n\n            print(\"I am doing some boring work after executing a_func()\")\n\n        return wrapTheFunction\n\n    def a_function_requiring_decoration():\n        print(\"I am the function which needs some decoration to remove my foul smell\")\n\n    a_function_requiring_decoration()\n    #outputs: \"I am the function which needs some decoration to remove my foul smell\"\n\n    a_function_requiring_decoration = a_new_decorator(a_function_requiring_decoration)\n    #now a_function_requiring_decoration is wrapped by wrapTheFunction()\n\n    a_function_requiring_decoration()\n    #outputs:I am doing some boring work before executing a_func()\n    #        I am the function which needs some decoration to remove my foul smell\n    #        I am doing some boring work after executing a_func()\n\nDid you get it? We just applied the previously learned principles. This\nis exactly what the decorators do in Python! They wrap a function and\nmodify its behaviour in one way or another. Now you might be\nwondering why we did not use the @ anywhere in our code? That is just a\nshort way of making up a decorated function. Here is how we could have\nrun the previous code sample using @.\n\n.. code:: python\n\n    @a_new_decorator\n    def a_function_requiring_decoration():\n        \"\"\"Hey you! Decorate me!\"\"\"\n        print(\"I am the function which needs some decoration to \"\n              \"remove my foul smell\")\n\n    a_function_requiring_decoration()\n    #outputs: I am doing some boring work before executing a_func()\n    #         I am the function which needs some decoration to remove my foul smell\n    #         I am doing some boring work after executing a_func()\n\n    #the @a_new_decorator is just a short way of saying:\n    a_function_requiring_decoration = a_new_decorator(a_function_requiring_decoration)\n\nI hope you now have a basic understanding of how decorators work in\nPython. Now there is one problem with our code. If we run:\n\n.. code:: python\n\n    print(a_function_requiring_decoration.__name__)\n    # Output: wrapTheFunction\n\nThat's not what we expected! Its name is\n\"a\\_function\\_requiring\\_decoration\". Well, our function was replaced by\nwrapTheFunction. It overrode the name and docstring of our function.\nLuckily, Python provides us a simple function to solve this problem and\nthat is ``functools.wraps``. Let's modify our previous example to use\n``functools.wraps``:\n\n.. code:: python\n\n    from functools import wraps\n\n    def a_new_decorator(a_func):\n        @wraps(a_func)\n        def wrapTheFunction():\n            print(\"I am doing some boring work before executing a_func()\")\n            a_func()\n            print(\"I am doing some boring work after executing a_func()\")\n        return wrapTheFunction\n\n    @a_new_decorator\n    def a_function_requiring_decoration():\n        \"\"\"Hey yo! Decorate me!\"\"\"\n        print(\"I am the function which needs some decoration to \"\n              \"remove my foul smell\")\n\n    print(a_function_requiring_decoration.__name__)\n    # Output: a_function_requiring_decoration\n\nNow that is much better. Let's move on and learn some use-cases of\ndecorators.\n\n**Blueprint:**\n\n.. code:: python\n\n    from functools import wraps\n    def decorator_name(f):\n        @wraps(f)\n        def decorated(*args, **kwargs):\n            if not can_run:\n                return \"Function will not run\"\n            return f(*args, **kwargs)\n        return decorated\n\n    @decorator_name\n    def func():\n        return(\"Function is running\")\n\n    can_run = True\n    print(func())\n    # Output: Function is running\n\n    can_run = False\n    print(func())\n    # Output: Function will not run\n\nNote: ``@wraps`` takes a function to be decorated and adds the\nfunctionality of copying over the function name, docstring, arguments\nlist, etc. This allows us to access the pre-decorated function's properties\nin the decorator.\n\nUse-cases:\n~~~~~~~~~~\n\nNow let's take a look at the areas where decorators really shine and\ntheir usage makes something really easy to manage.\n\nAuthorization\n~~~~~~~~~~~~~\n\nDecorators can help to check whether someone is authorized to use an\nendpoint in a web application. They are extensively used in Flask web\nframework and Django. Here is an example to employ decorator based\nauthentication:\n\n**Example :**\n\n.. code:: python\n\n    from functools import wraps\n\n    def requires_auth(f):\n        @wraps(f)\n        def decorated(*args, **kwargs):\n            auth = request.authorization\n            if not auth or not check_auth(auth.username, auth.password):\n                authenticate()\n            return f(*args, **kwargs)\n        return decorated\n\nLogging\n~~~~~~~\n\nLogging is another area where the decorators shine. Here is an example:\n\n.. code:: python\n\n    from functools import wraps\n\n    def logit(func):\n        @wraps(func)\n        def with_logging(*args, **kwargs):\n            print(func.__name__ + \" was called\")\n            return func(*args, **kwargs)\n        return with_logging\n\n    @logit\n    def addition_func(x):\n       \"\"\"Do some math.\"\"\"\n       return x + x\n\n\n    result = addition_func(4)\n    # Output: addition_func was called\n\nI am sure you are already thinking about some clever uses of decorators.\n\nDecorators with Arguments\n^^^^^^^^^^^^^^^^^^^^^^^^^\n\nCome to think of it, isn't ``@wraps`` also a decorator?  But, it takes an\nargument like any normal function can do.  So, why can't we do that too?\n\nThis is because when you use the ``@my_decorator`` syntax, you are\napplying a wrapper function with a single function as a parameter.\nRemember, everything in Python is an object, and this includes\nfunctions!  With that in mind, we can write a function that returns\na wrapper function.\n\nNesting a Decorator Within a Function\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nLet's go back to our logging example, and create a wrapper which lets\nus specify a logfile to output to.\n\n.. code:: python\n\n    from functools import wraps\n    \n    def logit(logfile='out.log'):\n        def logging_decorator(func):\n            @wraps(func)\n            def wrapped_function(*args, **kwargs):\n                log_string = func.__name__ + \" was called\"\n                print(log_string)\n                # Open the logfile and append\n                with open(logfile, 'a') as opened_file:\n                    # Now we log to the specified logfile\n                    opened_file.write(log_string + '\\n')\n                return func(*args, **kwargs)\n            return wrapped_function\n        return logging_decorator\n\n    @logit()\n    def myfunc1():\n        pass\n        \n    myfunc1()\n    # Output: myfunc1 was called\n    # A file called out.log now exists, with the above string\n    \n    @logit(logfile='func2.log')\n    def myfunc2():\n        pass\n    \n    myfunc2()\n    # Output: myfunc2 was called\n    # A file called func2.log now exists, with the above string\n\nDecorator Classes\n~~~~~~~~~~~~~~~~~\n\nNow we have our logit decorator in production, but when some parts\nof our application are considered critical, failure might be\nsomething that needs more immediate attention.  Let's say sometimes\nyou want to just log to a file.  Other times you want an email sent,\nso the problem is brought to your attention, and still keep a log\nfor your own records.  This is a case for using inheritence, but\nso far we've only seen functions being used to build decorators.\n\nLuckily, classes can also be used to build decorators.  So, let's\nrebuild logit as a class instead of a function.\n\n.. code:: python\n\n    class logit(object):\n    \n        _logfile = 'out.log'\n    \n        def __init__(self, func):\n            self.func = func\n        \n        def __call__(self, *args):\n            log_string = self.func.__name__ + \" was called\"\n            print(log_string)\n            # Open the logfile and append\n            with open(self._logfile, 'a') as opened_file:\n                # Now we log to the specified logfile\n                opened_file.write(log_string + '\\n')\n            # Now, send a notification\n            self.notify()\n            \n            # return base func\n            return self.func(*args)\n            \n            \n        \n        def notify(self):\n            # logit only logs, no more\n            pass\n    \nThis implementation has an additional advantage of being much cleaner than\nthe nested function approach, and wrapping a function still will use\nthe same syntax as before:\n\n.. code:: python\n    \n    logit._logfile = 'out2.log' # if change log file\n    @logit\n    def myfunc1():\n        pass\n    \n    myfunc1()\n    # Output: myfunc1 was called\n\nNow, let's subclass logit to add email functionality (though this topic\nwill not be covered here).\n\n.. code:: python\n\n    class email_logit(logit):\n        '''\n        A logit implementation for sending emails to admins\n        when the function is called.\n        '''\n        def __init__(self, email='admin@myproject.com', *args, **kwargs):\n            self.email = email\n            super(email_logit, self).__init__(*args, **kwargs)\n            \n        def notify(self):\n            # Send an email to self.email\n            # Will not be implemented here\n            pass\n\nFrom here, ``@email_logit`` works just like ``@logit`` but sends an email\nto the admin in addition to logging.\n"
        },
        {
          "name": "enumerate.rst",
          "type": "blob",
          "size": 1.1982421875,
          "content": "Enumerate\n---------\n\nEnumerate is a built-in function of Python. Its usefulness can not be\nsummarized in a single line. Yet most of the newcomers and even some\nadvanced programmers are unaware of it. It allows us to loop over\nsomething and have an automatic counter. Here is an example:\n\n.. code:: python\n    \n    my_list = ['apple', 'banana', 'grapes', 'pear']\n    for counter, value in enumerate(my_list):\n        print counter, value\n\n    # Output:\n    # 0 apple\n    # 1 banana\n    # 2 grapes\n    # 3 pear\n\nAnd there is more! ``enumerate`` also accepts an optional argument that\nallows us to specify the starting index of the counter.\n\n.. code:: python\n\n    my_list = ['apple', 'banana', 'grapes', 'pear']\n    for c, value in enumerate(my_list, 1):\n        print(c, value)\n\n    # Output:\n    # 1 apple\n    # 2 banana\n    # 3 grapes\n    # 4 pear\n\nAn example of where the optional argument of ``enumerate`` comes in handy\nis creating tuples containing the index and list item using a list. Here \nis an example:\n\n.. code:: python\n\n    my_list = ['apple', 'banana', 'grapes', 'pear']\n    counter_list = list(enumerate(my_list, 1))\n    print(counter_list)\n    # Output: [(1, 'apple'), (2, 'banana'), (3, 'grapes'), (4, 'pear')]\n\n"
        },
        {
          "name": "exceptions.rst",
          "type": "blob",
          "size": 4.5361328125,
          "content": "Exceptions\n----------\n\nException handling is an art which once you master grants you immense\npowers. I am going to show you some of the ways in which we can handle\nexceptions.\n\nIn basic terminology we are aware of the ``try/except`` structure. The code\nthat can cause an exception to occur is put in the ``try`` block and\nthe handling of the exception is implemented in the ``except`` block.\nThe code in the ``except`` block will only execute if the ``try`` block\nruns into an exception.\nHere is a simple example:\n\n.. code:: python\n\n    try:\n        file = open('test.txt', 'rb')\n    except IOError as e:\n        print('An IOError occurred. {}'.format(e.args[-1]))\n\nIn the above example we are handling only the IOError exception. What\nmost beginners do not know is that we can handle multiple exceptions.\n\nHandling multiple exceptions:\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nWe can use three methods to handle multiple exceptions. The first one\ninvolves putting all the exceptions which are likely to occur in a\ntuple. Like so:\n\n.. code:: python\n\n    try:\n        file = open('test.txt', 'rb')\n    except (IOError, EOFError) as e:\n        print(\"An error occurred. {}\".format(e.args[-1]))\n\nAnother method is to handle individual exceptions in separate ``except``\nblocks. We can have as many ``except`` blocks as we want. Here is an example:\n\n.. code:: python\n\n    try:\n        file = open('test.txt', 'rb')\n    except EOFError as e:\n        print(\"An EOF error occurred.\")\n        raise e\n    except IOError as e:\n        print(\"An error occurred.\")\n        raise e\n\nThis way if the exception is not handled by the first ``except`` block then\nit may be handled by a following block, or none at all. Now the last method involves\ntrapping ALL exceptions:\n\n.. code:: python\n\n    try:\n        file = open('test.txt', 'rb')\n    except Exception as e:\n        # Some logging if you want\n        raise e\n\nThis can be helpful when you have no idea about the exceptions that may\nbe thrown by your program. If you are just looking to catch all execptions, \nbut don't actually care about what they are, you can even exclude the \n``Exception as e`` part. \n\nNote:: catching all exceptions may have unintended consequences because catching \nall exceptions may also catch the ones you want to occur; for example, in \nmany command-line based programs, pressing control+c will terminate the program, \nbut if you catch all excepts, the ``KeyboardInterrupt`` will be caught as an \nexception, so pressing control+c will NOT terminate the program.\n\n``finally`` clause\n~~~~~~~~~~~~~~~~~~\n\nWe wrap our main code in the ``try`` clause. After that we wrap some code in\nan ``except`` clause which gets executed if an exception occurs in the code\nwrapped in the ``try`` clause. In this example we will use a third clause as\nwell which is the ``finally`` clause. The code which is wrapped in the\n``finally`` clause will run whether or not an exception occurred. It might be used\nto perform clean-up after a script. Here is a simple example:\n\n.. code:: python\n\n    try:\n        file = open('test.txt', 'rb')\n    except IOError as e:\n        print('An IOError occurred. {}'.format(e.args[-1]))\n    finally:\n        print(\"This would be printed whether or not an exception occurred!\")\n        \n    # Output: An IOError occurred. No such file or directory\n    # This would be printed whether or not an exception occurred!\n\n``try/else`` clause\n~~~~~~~~~~~~~~~~~~~\n\nOften times we might want some code to run if **no** exception occurs. This\ncan easily be achieved by using an ``else`` clause. One might ask: why, if\nyou only want some code to run if no exception occurs, wouldn't you simply\nput that code inside the ``try``? The answer is that then any exceptions in\nthat code will be caught by the ``try``, and you might not want that. Most\npeople don't use it and honestly I have myself not used it widely. Here is an\nexample:\n\n.. code:: python\n\n    try:\n        print('I am sure no exception is going to occur!')\n    except Exception:\n        print('exception')\n    else:\n        # any code that should only run if no exception occurs in the try,\n        # but for which exceptions should NOT be caught\n        print('This would only run if no exception occurs. And an error here '\n              'would NOT be caught.')\n    finally:\n        print('This would be printed in every case.')\n\n    # Output: I am sure no exception is going to occur!\n    # This would only run if no exception occurs. And an error here would NOT be caught\n    # This would be printed in every case.\n\nThe ``else`` clause would only run if no exception occurs and it would run\nbefore the ``finally`` clause.\n"
        },
        {
          "name": "flaskstyle.sty",
          "type": "blob",
          "size": 2.705078125,
          "content": "\\definecolor{TitleColor}{rgb}{0,0,0}\n\\definecolor{InnerLinkColor}{rgb}{0,0,0}\n\\usepackage{geometry}\n\\usepackage{xcolor}\n\\usepackage{pdfpages}\n\\usepackage{graphicx}\n\\usepackage{lipsum}% Used for dummy text.\n\\definecolor{titlepagecolor}{cmyk}{1,.60,0,.40}\n\\definecolor{namecolor}{cmyk}{1,.50,0,.10}\n\\definecolor{VerbatimBorderColor}{rgb}{1,1,1}\n\n\\renewcommand{\\maketitle}{%\n\n  \\begin{titlepage}\n  \\includepdf[pages={1}]{cover.pdf}\n\n  \\end{titlepage}\n  \\restoregeometry % restores the geometry\n  \\nopagecolor% Use this to restore the color pages to white\n\n  \\cleardoublepage%\n  \\setcounter{footnote}{0}%\n  \\let\\thanks\\relax\\let\\maketitle\\relax\n  %\\gdef\\@thanks{}\\gdef\\@author{}\\gdef\\@title{}\n}\n\n\\fancypagestyle{normal}{\n  \\fancyhf{}\n  \\fancyfoot[LE,RO]{{\\thepage}}\n  \\fancyfoot[LO]{{\\nouppercase{\\rightmark}}}\n  \\fancyfoot[RE]{{\\nouppercase{\\leftmark}}}\n  \\fancyhead[LE,RO]{{ \\@title, \\py@release}}\n  \\renewcommand{\\headrulewidth}{0.4pt}\n  \\renewcommand{\\footrulewidth}{0.4pt}\n}\n\n\\fancypagestyle{plain}{\n  \\fancyhf{}\n  \\fancyfoot[LE,RO]{{\\thepage}}\n  \\renewcommand{\\headrulewidth}{0pt}\n  \\renewcommand{\\footrulewidth}{0.4pt}\n}\n\n\\titleformat{\\section}{\\Large}%\n            {\\py@TitleColor\\thesection}{0.5em}{\\py@TitleColor}{\\py@NormalColor}\n\\titleformat{\\subsection}{\\large}%\n            {\\py@TitleColor\\thesubsection}{0.5em}{\\py@TitleColor}{\\py@NormalColor}\n\\titleformat{\\subsubsection}{}%\n            {\\py@TitleColor\\thesubsubsection}{0.5em}{\\py@TitleColor}{\\py@NormalColor}\n\\titleformat{\\paragraph}{\\large}%\n            {\\py@TitleColor}{0em}{\\py@TitleColor}{\\py@NormalColor}\n\n\\ChNameVar{\\raggedleft\\normalsize}\n\\ChNumVar{\\raggedleft \\bfseries\\Large}\n\\ChTitleVar{\\raggedleft \\rm\\Huge}\n\n\\renewcommand\\thepart{\\@Roman\\c@part}\n\\renewcommand\\part{%\n   \\pagestyle{plain}\n   \\if@noskipsec \\leavevmode \\fi\n   \\cleardoublepage\n   \\vspace*{6cm}%\n   \\@afterindentfalse\n   \\secdef\\@part\\@spart}\n\n\\def\\@part[#1]#2{%\n    \\ifnum \\c@secnumdepth >\\m@ne\n      \\refstepcounter{part}%\n      \\addcontentsline{toc}{part}{\\thepart\\hspace{1em}#1}%\n    \\else\n      \\addcontentsline{toc}{part}{#1}%\n    \\fi\n    {\\parindent \\z@ %\\center\n     \\interlinepenalty \\@M\n     \\normalfont\n     \\ifnum \\c@secnumdepth >\\m@ne\n       \\rm\\Large \\partname~\\thepart\n       \\par\\nobreak\n     \\fi\n     \\MakeUppercase{\\rm\\Huge #2}%\n     \\markboth{}{}\\par}%\n    \\nobreak\n    \\vskip 8ex\n    \\@afterheading}\n\\def\\@spart#1{%\n    {\\parindent \\z@ %\\center\n     \\interlinepenalty \\@M\n     \\normalfont\n     \\huge \\bfseries #1\\par}%\n     \\nobreak\n     \\vskip 3ex\n     \\@afterheading}\n\n% use inconsolata font\n\\usepackage{inconsolata}\n\n% fix single quotes, for inconsolata. (does not work)\n%%\\usepackage{textcomp}\n%%\\begingroup\n%%  \\catcode`'=\\active\n%%  \\g@addto@macro\\@noligs{\\let'\\textsinglequote}\n%%  \\endgroup\n%%\\endinput\n"
        },
        {
          "name": "for_-_else.rst",
          "type": "blob",
          "size": 2.48828125,
          "content": "``for/else``\n------------\n\nLoops are an integral part of any language. Likewise ``for`` loops are\nan important part of Python. However there are a few things which most\nbeginners do not know about them. We will discuss a few of them one-by-one.\n\nLet's first start off with what we know. We know that we can use ``for`` loops\nlike this:\n\n.. code:: python\n\n    fruits = ['apple', 'banana', 'mango']\n    for fruit in fruits:\n        print(fruit.capitalize())\n\n    # Output: Apple\n    #         Banana\n    #         Mango\n\nThat is the very basic structure of a ``for`` loop. Now let's move on to\nsome of the lesser known features of ``for`` loops in Python.\n\n``else`` Clause\n^^^^^^^^^^^^^^^\n\n``for`` loops also have an ``else`` clause which most of us are unfamiliar\nwith. The ``else`` clause executes after the loop completes normally.\nThis means that the loop did not encounter a ``break`` statement. They are\nreally useful once you understand where to use them. I, myself, came to\nknow about them a lot later.\n\nThe common construct is to run a loop and search for an item. If the\nitem is found, we break out of the loop using the ``break`` statement. There are two\nscenarios in which the loop may end. The first one is when the item is\nfound and ``break`` is encountered. The second scenario is that the loop\nends without encountering a ``break`` statement. Now we may want to know which one of these is the reason for a\nloop's completion. One method is to set a flag and then check it once the\nloop ends. Another is to use the ``else`` clause.\n\nThis is the basic structure of a ``for/else`` loop:\n\n.. code:: python\n\n    for item in container:\n        if search_something(item):\n            # Found it!\n            process(item)\n            break\n    else:\n        # Didn't find anything..\n        not_found_in_container()\n\nConsider this simple example which I took from the official\ndocumentation:\n\n.. code:: python\n\n    for n in range(2, 10):\n        for x in range(2, n):\n            if n % x == 0:\n                print(n, 'equals', x, '*', n/x)\n                break\n\nIt finds factors for numbers between 2 to 10. Now for the fun part. We\ncan add an additional ``else`` block which catches the numbers which have no factors and are therefore prime numbers:\n\n.. code:: python\n\n    for n in range(2, 10):\n        for x in range(2, n):\n            if n % x == 0:\n                print( n, 'equals', x, '*', n/x)\n                break\n        else:\n            # loop fell through without finding a factor\n            print(n, 'is a prime number')\n"
        },
        {
          "name": "function_caching.rst",
          "type": "blob",
          "size": 2.0380859375,
          "content": "Function caching\n----------------\n\nFunction caching allows us to cache the return values of a function\ndepending on the arguments. It can save time when an I/O bound function\nis periodically called with the same arguments. Before Python 3.2 we had\nto write a custom implementation. In Python 3.2+ there is an\n``lru_cache`` decorator which allows us to quickly cache and uncache the\nreturn values of a function.\n\nLet's see how we can use it in Python 3.2+ and the versions before it.\n\nPython 3.2+\n^^^^^^^^^^^\n\nLet's implement a Fibonacci calculator and use ``lru_cache``.\n\n.. code:: python\n\n    from functools import lru_cache\n\n    @lru_cache(maxsize=32)\n    def fib(n):\n        if n < 2:\n            return n\n        return fib(n-1) + fib(n-2)\n\n    >>> print([fib(n) for n in range(10)])\n    # Output: [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n\nThe ``maxsize`` argument tells ``lru_cache`` about how many recent\nreturn values to cache.\n\nWe can easily uncache the return values as well by using:\n\n.. code:: python\n\n    fib.cache_clear()\n\nPython 2+\n^^^^^^^^^\n\nThere are a couple of ways to achieve the same effect. You can create\nany type of caching mechanism. It entirely depends upon your needs. Here\nis a generic cache:\n\n.. code:: python\n\n    from functools import wraps\n\n    def memoize(function):\n        memo = {}\n        @wraps(function)\n        def wrapper(*args):\n            try:\n                return memo[args]\n            except KeyError:\n                rv = function(*args)\n                memo[args] = rv\n                return rv\n        return wrapper\n\n    @memoize\n    def fibonacci(n):\n        if n < 2: return n\n        return fibonacci(n - 1) + fibonacci(n - 2)\n\n    fibonacci(25)\n\n**Note:** memoize won't cache unhashable types (dict, lists, etc...) but only the immutable types. Keep that in mind when using it.\n\n`Here <https://www.caktusgroup.com/blog/2015/06/08/testing-client-side-applications-django-post-mortem/>`__\nis a fine article by Caktus Group in which they caught a bug in Django\nwhich occurred due to ``lru_cache``. It's an interesting read. Do check it out.\n"
        },
        {
          "name": "generators.rst",
          "type": "blob",
          "size": 5.439453125,
          "content": "Generators\n----------\n\nFirst lets understand iterators. According to Wikipedia, an iterator is\nan object that enables a programmer to traverse a container,\nparticularly lists. However, an iterator performs traversal and gives\naccess to data elements in a container, but does not perform iteration.\nYou might be confused so lets take it a bit slow. There are three parts\nnamely:\n\n-  Iterable\n-  Iterator\n-  Iteration\n\nAll of these parts are linked to each other. We will discuss them one by\none and later talk about generators.\n\nIterable\n^^^^^^^^\n\nAn ``iterable`` is any object in Python which has an ``__iter__`` or a\n``__getitem__`` method defined which returns an **iterator** or can take\nindexes (You can read more about them `here <https://stackoverflow.com/a/20551346>`_). \nIn short an ``iterable`` is any object which can provide us\nwith an **iterator**. So what is an **iterator**?\n\nIterator\n^^^^^^^^\n\nAn iterator is any object in Python which has a ``next`` (Python2) or\n``__next__`` method defined. That's it. That's an iterator. Now let's\nunderstand **iteration**.\n\nIteration\n^^^^^^^^^\n\nIn simple words it is the process of taking an item from something e.g a\nlist. When we use a loop to loop over something it is called iteration.\nIt is the name given to the process itself. Now as we have a basic\nunderstanding of these terms let's understand **generators**.\n\nGenerators\n^^^^^^^^^^\n\nGenerators are iterators, but you can only iterate over them once. It’s\nbecause they do not store all the values in memory, they generate the\nvalues on the fly. You use them by iterating over them, either with a\n'for' loop or by passing them to any function or construct that\niterates. Most of the time ``generators`` are implemented as functions.\nHowever, they do not ``return`` a value, they ``yield`` it. Here is a\nsimple example of a ``generator`` function:\n\n.. code:: python\n\n    def generator_function():\n        for i in range(10):\n            yield i\n\n    for item in generator_function():\n        print(item)\n\n    # Output: 0\n    # 1\n    # 2\n    # 3\n    # 4\n    # 5\n    # 6\n    # 7\n    # 8\n    # 9\n\nIt is not really useful in this case. Generators are best for\ncalculating large sets of results (particularly calculations involving\nloops themselves) where you don't want to allocate the memory for all\nresults at the same time. Many Standard Library functions that return\n``lists`` in Python 2 have been modified to return ``generators`` in\nPython 3 because ``generators`` require fewer resources.\n\nHere is an example ``generator`` which calculates fibonacci numbers:\n\n.. code:: python\n\n    # generator version\n    def fibon(n):\n        a = b = 1\n        for i in range(n):\n            yield a\n            a, b = b, a + b\n\nNow we can use it like this:\n\n.. code:: python\n\n    for x in fibon(1000000):\n        print(x)\n\nThis way we would not have to worry about it using a lot of resources.\nHowever, if we would have implemented it like this:\n\n.. code:: python\n\n    def fibon(n):\n        a = b = 1\n        result = []\n        for i in range(n):\n            result.append(a)\n            a, b = b, a + b\n        return result\n\nIt would have used up all our resources while calculating a large input.\nWe have discussed that we can iterate over ``generators`` only once but\nwe haven't tested it. Before testing it you need to know about one more\nbuilt-in function of Python, ``next()``. It allows us to access the next\nelement of a sequence. So let's test out our understanding:\n\n.. code:: python\n\n    def generator_function():\n        for i in range(3):\n            yield i\n\n    gen = generator_function()\n    print(next(gen))\n    # Output: 0\n    print(next(gen))\n    # Output: 1\n    print(next(gen))\n    # Output: 2\n    print(next(gen))\n    # Output: Traceback (most recent call last):\n    #            File \"<stdin>\", line 1, in <module>\n    #         StopIteration\n\nAs we can see that after yielding all the values ``next()`` caused a\n``StopIteration`` error. Basically this error informs us that all the\nvalues have been yielded. You might be wondering why we don't get\nthis error when using a ``for`` loop? Well the answer is simple. The\n``for`` loop automatically catches this error and stops calling\n``next``. Did you know that a few built-in data types in Python also\nsupport iteration? Let's check it out:\n\n.. code:: python\n\n    my_string = \"Yasoob\"\n    next(my_string)\n    # Output: Traceback (most recent call last):\n    #      File \"<stdin>\", line 1, in <module>\n    #    TypeError: str object is not an iterator\n\nWell that's not what we expected. The error says that ``str`` is not an\niterator. Well it's right! It's an iterable but not an iterator. This\nmeans that it supports iteration but we can't iterate over\nit directly. So how would we iterate over it? It's time to learn about one more\nbuilt-in function, ``iter``. It returns an ``iterator`` object from an\niterable. While an ``int`` isn't an iterable, we can use it on string! \n\n.. code:: python\n\n    int_var = 1779\n    iter(int_var)\n    # Output: Traceback (most recent call last):\n    #   File \"<stdin>\", line 1, in <module>\n    # TypeError: 'int' object is not iterable\n    # This is because int is not iterable\n    \n    my_string = \"Yasoob\"\n    my_iter = iter(my_string)\n    print(next(my_iter))\n    # Output: 'Y'\n\nNow that is much better. I am sure that you loved learning about\ngenerators. Do bear it in mind that you can fully grasp this concept\nonly when you use it. Make sure that you follow this pattern and use\n``generators`` whenever they make sense to you. You won't be\ndisappointed!\n"
        },
        {
          "name": "global_&_return.rst",
          "type": "blob",
          "size": 4.529296875,
          "content": "Global and Return\n---------------\n\nYou might have encountered some functions written in Python which have a\n``return`` keyword in the end of the function. Do you know what it does? It\nis similar to return in other languages. Let's examine this little\nfunction:\n\n.. code:: python\n\n    def add(value1, value2):\n        return value1 + value2\n\n    result = add(3, 5)\n    print(result)\n    # Output: 8\n\nThe function above takes two values as input and then outputs their\naddition. We could have also done:\n\n.. code:: python\n\n    def add(value1,value2):\n        global result\n        result = value1 + value2\n\n    add(3,5)\n    print(result)\n    # Output: 8\n\nSo first let's talk about the first bit of code which involves the\n``return`` keyword. What that function is doing is that it is assigning\nthe value to the variable which is calling that function which in our\ncase is ``result``. In most cases you won't need to use the\n``global`` keyword. However, let's examine the other bit of code as well\nwhich includes the ``global`` keyword. So what that function is doing is\nthat it is making a global variable ``result``. What does global mean\nhere? Global variable means that we can access that variable outside the\nscope of the function as well. Let me demonstrate it with an example:\n\n.. code:: python\n\n    # first without the global variable\n    def add(value1, value2):\n        result = value1 + value2\n\n    add(2, 4)\n    print(result)\n\n    # Oh crap, we encountered an exception. Why is it so?\n    # the python interpreter is telling us that we do not\n    # have any variable with the name of result. It is so\n    # because the result variable is only accessible inside\n    # the function in which it is created if it is not global.\n    Traceback (most recent call last):\n      File \"\", line 1, in\n        result\n    NameError: name 'result' is not defined\n\n    # Now lets run the same code but after making the result\n    # variable global\n    def add(value1, value2):\n        global result\n        result = value1 + value2\n\n    add(2, 4)\n    result\n    6\n\nSo hopefully there are no errors in the second run as expected. In\npractical programming you should try to stay away from ``global``\nkeyword as it only makes life difficult by introducing unwanted variables\nto the global scope.\n\nMultiple return values\n^^^^^^^^^^^^^^^^^^^^^^^\n\nSo what if you want to return two variables from a function instead of one? There are a couple of approaches which new programmers take. The most famous approach is to use ``global`` keyword. Let's take a look at a useless example:\n\n.. code:: python\n\n    def profile():\n        global name\n        global age\n        name = \"Danny\"\n        age = 30\n\n    profile()\n    print(name)\n    # Output: Danny\n\n    print(age)\n    # Output: 30\n\n**Note:**Don't try to use the above mentioned method. I repeat, don't try to use the above mentioned method!\n\nSome try to solve this problem by *returning* a ``tuple``, ``list`` or ``dict`` with the required values after the function terminates. It is one way to do it and works like a charm:\n\n.. code:: python\n\n    def profile():\n        name = \"Danny\"\n        age = 30\n        return (name, age)\n\n    profile_data = profile()\n    print(profile_data[0])\n    # Output: Danny\n\n    print(profile_data[1])\n    # Output: 30\n\nOr by more common convention:\n\n.. code:: python\n\n    def profile():\n        name = \"Danny\"\n        age = 30\n        return name, age\n\n    profile_name, profile_age = profile()\n    print(profile_name)\n    # Output: Danny\n    print(profile_age)\n    # Output: 30\n\nKeep in mind that even in the above example we are returning a tuple (despite the lack of parenthesis) and not separate multiple values. If you want to take it one step further, you can also make use of `namedtuple <https://docs.python.org/3/library/collections.html#collections.namedtuple>`_. Here is an example:\n\n.. code:: python\n\n    from collections import namedtuple\n    def profile():\n        Person = namedtuple('Person', 'name age')\n        return Person(name=\"Danny\", age=31)\n\n    # Use as namedtuple\n    p = profile()\n    print(p, type(p))\n    # Person(name='Danny', age=31) <class '__main__.Person'>\n    print(p.name)\n    # Danny\n    print(p.age)\n    #31\n\n    # Use as plain tuple\n    p = profile()\n    print(p[0])\n    # Danny\n    print(p[1])\n    #31\n\n    # Unpack it immediatly\n    name, age = profile()\n    print(name)\n    # Danny\n    print(age)\n    #31\n\nThis is a better way to do it, along with returning ``list`` and ``dict``. Don't use ``global`` keyword unless you know what you are doing. ``global`` might be a better option in a few cases but is not in most of them.\n"
        },
        {
          "name": "index.rst",
          "type": "blob",
          "size": 2.3310546875,
          "content": ":orphan:\n\n.. note::\n\n   You can sign up to my `mailing list <http://eepurl.com/bwjcej>`__ so that you remain in sync with any major updates to this book or my future projects!\n\nIntermediate Python\n===================\n\n============\nPreface\n============\n\nPython is an amazing language with a strong and friendly community of programmers. However, there is a lack of documentation on what to learn after getting the basics of Python down your throat. Through this book I aim to solve this problem. I would give you bits of information about some interesting topics which you can further explore.\n\nThe topics which are discussed in this book open up your mind towards some nice corners of Python language. This book is an outcome of my desire to have something like this when I was beginning to learn Python.\n\nIf you are a beginner, intermediate or even an advanced programmer there is something for you in this book.\n\nPlease note that this book is not a tutorial and does not teach you Python. The topics are not explained in depth, instead only the minimum required information is given.\n\nI am sure you are as excited as I am so let’s start!\n\n**Note:** This book is a continuous work in progress. If you find anything which you can further improve (I know you will find a lot of stuff) then kindly submit a pull request!\n\n==================\nAuthor\n==================\n\nI am Muhammad Yasoob Ullah Khalid. I have been programming extensively in Python for over 3 years now. I have been involved in a lot of Open Source projects. I regularly blog about interesting Python topics over at my `blog <http://www.pythontips.com>`_ . In 2014 I also spoke at EuroPython which was held in Berlin. It is the biggest Python conference in Europe. If you have an interesting Internship opportunity for me then I would definitely like to hear from you!\n\n==================\nTable of Contents\n==================\n\n.. toctree::\n   :maxdepth: 2\n   :numbered:\n\n   args_and_kwargs\n   debugging\n   generators\n   map_filter\n   set_-_data_structure\n   ternary_operators\n   decorators\n   global_&_return\n   mutation\n   __slots__magic\n   virtual_environment\n   collections\n   enumerate\n   zip\n   object_introspection\n   comprehensions\n   exceptions\n   classes\n   lambdas\n   one_liners\n   for_-_else\n   python_c_extension\n   open_function\n   targeting_python_2_3\n   coroutines\n   function_caching\n   context_managers\n"
        },
        {
          "name": "lambdas.rst",
          "type": "blob",
          "size": 0.8564453125,
          "content": "Lambdas\n-------\n\nLambdas are one line functions. They are also known as anonymous\nfunctions in some other languages. You might want to use lambdas when\nyou don't want to use a function twice in a program. They are just like\nnormal functions and even behave like them.\n\n**Blueprint**\n\n.. code:: python\n\n    lambda argument: manipulate(argument)\n\n**Example**\n\n.. code:: python\n\n    add = lambda x, y: x + y\n\n    print(add(3, 5))\n    # Output: 8\n\nHere are a few useful use cases for lambdas and just a few ways in which\nthey are used in the wild:\n\n**List sorting**\n\n.. code:: python\n\n    a = [(1, 2), (4, 1), (9, 10), (13, -3)]\n    a.sort(key=lambda x: x[1])\n\n    print(a)\n    # Output: [(13, -3), (4, 1), (1, 2), (9, 10)]\n\n**Parallel sorting of lists**\n\n.. code:: python\n\n    data = zip(list1, list2)\n    data = sorted(data)\n    list1, list2 = map(lambda t: list(t), zip(*data))\n"
        },
        {
          "name": "make.bat",
          "type": "blob",
          "size": 6.5517578125,
          "content": "@ECHO OFF\r\n\r\nREM Command file for Sphinx documentation\r\n\r\nif \"%SPHINXBUILD%\" == \"\" (\r\n\tset SPHINXBUILD=sphinx-build\r\n)\r\nset BUILDDIR=_build\r\nset ALLSPHINXOPTS=-d %BUILDDIR%/doctrees %SPHINXOPTS% .\r\nset I18NSPHINXOPTS=%SPHINXOPTS% .\r\nif NOT \"%PAPER%\" == \"\" (\r\n\tset ALLSPHINXOPTS=-D latex_paper_size=%PAPER% %ALLSPHINXOPTS%\r\n\tset I18NSPHINXOPTS=-D latex_paper_size=%PAPER% %I18NSPHINXOPTS%\r\n)\r\n\r\nif \"%1\" == \"\" goto help\r\n\r\nif \"%1\" == \"help\" (\r\n\t:help\r\n\techo.Please use `make ^<target^>` where ^<target^> is one of\r\n\techo.  html       to make standalone HTML files\r\n\techo.  dirhtml    to make HTML files named index.html in directories\r\n\techo.  singlehtml to make a single large HTML file\r\n\techo.  pickle     to make pickle files\r\n\techo.  json       to make JSON files\r\n\techo.  htmlhelp   to make HTML files and a HTML help project\r\n\techo.  qthelp     to make HTML files and a qthelp project\r\n\techo.  devhelp    to make HTML files and a Devhelp project\r\n\techo.  epub       to make an epub\r\n\techo.  latex      to make LaTeX files, you can set PAPER=a4 or PAPER=letter\r\n\techo.  text       to make text files\r\n\techo.  man        to make manual pages\r\n\techo.  texinfo    to make Texinfo files\r\n\techo.  gettext    to make PO message catalogs\r\n\techo.  changes    to make an overview over all changed/added/deprecated items\r\n\techo.  xml        to make Docutils-native XML files\r\n\techo.  pseudoxml  to make pseudoxml-XML files for display purposes\r\n\techo.  linkcheck  to check all external links for integrity\r\n\techo.  doctest    to run all doctests embedded in the documentation if enabled\r\n\tgoto end\r\n)\r\n\r\nif \"%1\" == \"clean\" (\r\n\tfor /d %%i in (%BUILDDIR%\\*) do rmdir /q /s %%i\r\n\tdel /q /s %BUILDDIR%\\*\r\n\tgoto end\r\n)\r\n\r\n\r\n%SPHINXBUILD% 2> nul\r\nif errorlevel 9009 (\r\n\techo.\r\n\techo.The 'sphinx-build' command was not found. Make sure you have Sphinx\r\n\techo.installed, then set the SPHINXBUILD environment variable to point\r\n\techo.to the full path of the 'sphinx-build' executable. Alternatively you\r\n\techo.may add the Sphinx directory to PATH.\r\n\techo.\r\n\techo.If you don't have Sphinx installed, grab it from\r\n\techo.http://sphinx-doc.org/\r\n\texit /b 1\r\n)\r\n\r\nif \"%1\" == \"html\" (\r\n\t%SPHINXBUILD% -b html %ALLSPHINXOPTS% %BUILDDIR%/html\r\n\tif errorlevel 1 exit /b 1\r\n\techo.\r\n\techo.Build finished. The HTML pages are in %BUILDDIR%/html.\r\n\tgoto end\r\n)\r\n\r\nif \"%1\" == \"dirhtml\" (\r\n\t%SPHINXBUILD% -b dirhtml %ALLSPHINXOPTS% %BUILDDIR%/dirhtml\r\n\tif errorlevel 1 exit /b 1\r\n\techo.\r\n\techo.Build finished. The HTML pages are in %BUILDDIR%/dirhtml.\r\n\tgoto end\r\n)\r\n\r\nif \"%1\" == \"singlehtml\" (\r\n\t%SPHINXBUILD% -b singlehtml %ALLSPHINXOPTS% %BUILDDIR%/singlehtml\r\n\tif errorlevel 1 exit /b 1\r\n\techo.\r\n\techo.Build finished. The HTML pages are in %BUILDDIR%/singlehtml.\r\n\tgoto end\r\n)\r\n\r\nif \"%1\" == \"pickle\" (\r\n\t%SPHINXBUILD% -b pickle %ALLSPHINXOPTS% %BUILDDIR%/pickle\r\n\tif errorlevel 1 exit /b 1\r\n\techo.\r\n\techo.Build finished; now you can process the pickle files.\r\n\tgoto end\r\n)\r\n\r\nif \"%1\" == \"json\" (\r\n\t%SPHINXBUILD% -b json %ALLSPHINXOPTS% %BUILDDIR%/json\r\n\tif errorlevel 1 exit /b 1\r\n\techo.\r\n\techo.Build finished; now you can process the JSON files.\r\n\tgoto end\r\n)\r\n\r\nif \"%1\" == \"htmlhelp\" (\r\n\t%SPHINXBUILD% -b htmlhelp %ALLSPHINXOPTS% %BUILDDIR%/htmlhelp\r\n\tif errorlevel 1 exit /b 1\r\n\techo.\r\n\techo.Build finished; now you can run HTML Help Workshop with the ^\r\n.hhp project file in %BUILDDIR%/htmlhelp.\r\n\tgoto end\r\n)\r\n\r\nif \"%1\" == \"qthelp\" (\r\n\t%SPHINXBUILD% -b qthelp %ALLSPHINXOPTS% %BUILDDIR%/qthelp\r\n\tif errorlevel 1 exit /b 1\r\n\techo.\r\n\techo.Build finished; now you can run \"qcollectiongenerator\" with the ^\r\n.qhcp project file in %BUILDDIR%/qthelp, like this:\r\n\techo.^> qcollectiongenerator %BUILDDIR%\\qthelp\\PythonTips.qhcp\r\n\techo.To view the help file:\r\n\techo.^> assistant -collectionFile %BUILDDIR%\\qthelp\\PythonTips.ghc\r\n\tgoto end\r\n)\r\n\r\nif \"%1\" == \"devhelp\" (\r\n\t%SPHINXBUILD% -b devhelp %ALLSPHINXOPTS% %BUILDDIR%/devhelp\r\n\tif errorlevel 1 exit /b 1\r\n\techo.\r\n\techo.Build finished.\r\n\tgoto end\r\n)\r\n\r\nif \"%1\" == \"epub\" (\r\n\t%SPHINXBUILD% -b epub %ALLSPHINXOPTS% %BUILDDIR%/epub\r\n\tif errorlevel 1 exit /b 1\r\n\techo.\r\n\techo.Build finished. The epub file is in %BUILDDIR%/epub.\r\n\tgoto end\r\n)\r\n\r\nif \"%1\" == \"latex\" (\r\n\t%SPHINXBUILD% -b latex %ALLSPHINXOPTS% %BUILDDIR%/latex\r\n\tif errorlevel 1 exit /b 1\r\n\techo.\r\n\techo.Build finished; the LaTeX files are in %BUILDDIR%/latex.\r\n\tgoto end\r\n)\r\n\r\nif \"%1\" == \"latexpdf\" (\r\n\t%SPHINXBUILD% -b latex %ALLSPHINXOPTS% %BUILDDIR%/latex\r\n\tcd %BUILDDIR%/latex\r\n\tmake all-pdf\r\n\tcd %BUILDDIR%/..\r\n\techo.\r\n\techo.Build finished; the PDF files are in %BUILDDIR%/latex.\r\n\tgoto end\r\n)\r\n\r\nif \"%1\" == \"latexpdfja\" (\r\n\t%SPHINXBUILD% -b latex %ALLSPHINXOPTS% %BUILDDIR%/latex\r\n\tcd %BUILDDIR%/latex\r\n\tmake all-pdf-ja\r\n\tcd %BUILDDIR%/..\r\n\techo.\r\n\techo.Build finished; the PDF files are in %BUILDDIR%/latex.\r\n\tgoto end\r\n)\r\n\r\nif \"%1\" == \"text\" (\r\n\t%SPHINXBUILD% -b text %ALLSPHINXOPTS% %BUILDDIR%/text\r\n\tif errorlevel 1 exit /b 1\r\n\techo.\r\n\techo.Build finished. The text files are in %BUILDDIR%/text.\r\n\tgoto end\r\n)\r\n\r\nif \"%1\" == \"man\" (\r\n\t%SPHINXBUILD% -b man %ALLSPHINXOPTS% %BUILDDIR%/man\r\n\tif errorlevel 1 exit /b 1\r\n\techo.\r\n\techo.Build finished. The manual pages are in %BUILDDIR%/man.\r\n\tgoto end\r\n)\r\n\r\nif \"%1\" == \"texinfo\" (\r\n\t%SPHINXBUILD% -b texinfo %ALLSPHINXOPTS% %BUILDDIR%/texinfo\r\n\tif errorlevel 1 exit /b 1\r\n\techo.\r\n\techo.Build finished. The Texinfo files are in %BUILDDIR%/texinfo.\r\n\tgoto end\r\n)\r\n\r\nif \"%1\" == \"gettext\" (\r\n\t%SPHINXBUILD% -b gettext %I18NSPHINXOPTS% %BUILDDIR%/locale\r\n\tif errorlevel 1 exit /b 1\r\n\techo.\r\n\techo.Build finished. The message catalogs are in %BUILDDIR%/locale.\r\n\tgoto end\r\n)\r\n\r\nif \"%1\" == \"changes\" (\r\n\t%SPHINXBUILD% -b changes %ALLSPHINXOPTS% %BUILDDIR%/changes\r\n\tif errorlevel 1 exit /b 1\r\n\techo.\r\n\techo.The overview file is in %BUILDDIR%/changes.\r\n\tgoto end\r\n)\r\n\r\nif \"%1\" == \"linkcheck\" (\r\n\t%SPHINXBUILD% -b linkcheck %ALLSPHINXOPTS% %BUILDDIR%/linkcheck\r\n\tif errorlevel 1 exit /b 1\r\n\techo.\r\n\techo.Link check complete; look for any errors in the above output ^\r\nor in %BUILDDIR%/linkcheck/output.txt.\r\n\tgoto end\r\n)\r\n\r\nif \"%1\" == \"doctest\" (\r\n\t%SPHINXBUILD% -b doctest %ALLSPHINXOPTS% %BUILDDIR%/doctest\r\n\tif errorlevel 1 exit /b 1\r\n\techo.\r\n\techo.Testing of doctests in the sources finished, look at the ^\r\nresults in %BUILDDIR%/doctest/output.txt.\r\n\tgoto end\r\n)\r\n\r\nif \"%1\" == \"xml\" (\r\n\t%SPHINXBUILD% -b xml %ALLSPHINXOPTS% %BUILDDIR%/xml\r\n\tif errorlevel 1 exit /b 1\r\n\techo.\r\n\techo.Build finished. The XML files are in %BUILDDIR%/xml.\r\n\tgoto end\r\n)\r\n\r\nif \"%1\" == \"pseudoxml\" (\r\n\t%SPHINXBUILD% -b pseudoxml %ALLSPHINXOPTS% %BUILDDIR%/pseudoxml\r\n\tif errorlevel 1 exit /b 1\r\n\techo.\r\n\techo.Build finished. The pseudo-XML files are in %BUILDDIR%/pseudoxml.\r\n\tgoto end\r\n)\r\n\r\n:end\r\n"
        },
        {
          "name": "map_filter.rst",
          "type": "blob",
          "size": 2.3330078125,
          "content": "Map, Filter and Reduce\n------------\n\nThese are three functions which facilitate a functional approach to\nprogramming. We will discuss them one by one and understand their use\ncases.\n\nMap\n^^^^^^\n\n``Map`` applies a function to all the items in an input\\_list. Here is\nthe blueprint:\n\n**Blueprint**\n\n.. code:: python\n\n    map(function_to_apply, list_of_inputs)\n\nMost of the times we want to pass all the list elements to a function\none-by-one and then collect the output. For instance:\n\n.. code:: python\n\n    items = [1, 2, 3, 4, 5]\n    squared = []\n    for i in items:\n        squared.append(i**2)\n\n``Map`` allows us to implement this in a much simpler and nicer way.\nHere you go:\n\n.. code:: python\n\n    items = [1, 2, 3, 4, 5]\n    squared = list(map(lambda x: x**2, items))\n\nMost of the times we use lambdas with ``map`` so I did the same. Instead\nof a list of inputs we can even have a list of functions!\n\n.. code:: python\n\n    def multiply(x):\n        return (x*x)\n    def add(x):\n        return (x+x)\n\n    funcs = [multiply, add]\n    for i in range(5):\n        value = list(map(lambda x: x(i), funcs))\n        print(value)\n\n    # Output:\n    # [0, 0]\n    # [1, 2]\n    # [4, 4]\n    # [9, 6]\n    # [16, 8]\n\nFilter\n^^^^^^^^^\n\nAs the name suggests, ``filter`` creates a list of elements for which a\nfunction returns true. Here is a short and concise example:\n\n.. code:: python\n\n    number_list = range(-5, 5)\n    less_than_zero = list(filter(lambda x: x < 0, number_list))\n    print(less_than_zero)\n\n    # Output: [-5, -4, -3, -2, -1]\n\nThe filter resembles a for loop but it is a builtin function and faster.\n\n**Note:** If map & filter do not appear beautiful to you then you can\nread about ``list/dict/tuple`` comprehensions.\n\nReduce\n^^^^^^^^^\n\n``Reduce`` is a really useful function for performing some computation on \na list and returning the result. It applies a rolling computation to sequential \npairs of values in a list. For example, if you wanted to compute the product \nof a list of integers. \n\nSo the normal way you might go about doing this task in python is using\na basic for loop:\n\n.. code:: python\n\n    product = 1\n    list = [1, 2, 3, 4]\n    for num in list: \n        product = product * num\n    \n    # product = 24\n\n\nNow let's try it with reduce:\n\n.. code:: python\n\n    from functools import reduce\n    product = reduce((lambda x, y: x * y), [1, 2, 3, 4])\n\n    # Output: 24\n"
        },
        {
          "name": "mutation.rst",
          "type": "blob",
          "size": 2.236328125,
          "content": "Mutation\n--------\n\nThe mutable and immutable datatypes in Python cause a lot of headache\nfor new programmers. In simple words, mutable means 'able to be changed'\nand immutable means 'constant'. Want your head to spin? Consider this\nexample:\n\n.. code:: python\n\n    foo = ['hi']\n    print(foo)\n    # Output: ['hi']\n\n    bar = foo\n    bar += ['bye']\n    print(foo)\n    # Output: ['hi', 'bye']\n\nWhat just happened? We were not expecting that! We were expecting\nsomething like this:\n\n.. code:: python\n\n    foo = ['hi']\n    print(foo)\n    # Output: ['hi']\n\n    bar = foo\n    bar += ['bye']\n\n    print(foo)\n    # Expected Output: ['hi']\n    # Output: ['hi', 'bye']\n\n    print(bar)\n    # Output: ['hi', 'bye']\n\nIt's not a bug. It's mutability in action. Whenever you assign a\nvariable to another variable of mutable datatype, any changes to the\ndata are reflected by both variables. The new variable is just an alias\nfor the old variable. This is only true for mutable datatypes. Here is a\ngotcha involving functions and mutable data types:\n\n.. code:: python\n\n    def add_to(num, target=[]):\n        target.append(num)\n        return target\n\n    add_to(1)\n    # Output: [1]\n\n    add_to(2)\n    # Output: [1, 2]\n\n    add_to(3)\n    # Output: [1, 2, 3]\n\nYou might have expected it to behave differently. You might be expecting\nthat a fresh list would be created when you call ``add_to`` like this:\n\n.. code:: python\n\n    def add_to(num, target=[]):\n        target.append(num)\n        return target\n\n    add_to(1)\n    # Output: [1]\n\n    add_to(2)\n    # Output: [2]\n\n    add_to(3)\n    # Output: [3]\n\nWell again it is the mutability of lists which causes this pain. In\nPython the default arguments are evaluated once when the function is\ndefined, not each time the function is called. You should never define\ndefault arguments of mutable type unless you know what you are doing.\nYou should do something like this:\n\n.. code:: python\n\n    def add_to(element, target=None):\n        if target is None:\n            target = []\n        target.append(element)\n        return target\n\nNow whenever you call the function without the ``target`` argument, a\nnew list is created. For instance:\n\n.. code:: python\n\n    add_to(42)\n    # Output: [42]\n\n    add_to(42)\n    # Output: [42]\n\n    add_to(42)\n    # Output: [42]\n\n"
        },
        {
          "name": "object_introspection.rst",
          "type": "blob",
          "size": 2.388671875,
          "content": "Object introspection\n--------------------\n\nIn computer programming, introspection is the ability to determine the\ntype of an object at runtime. It is one of Python's strengths.\nEverything in Python is an object and we can examine those objects.\nPython ships with a few built-in functions and modules to help us.\n\n``dir``\n^^^^^^^^^^^\n\nIn this section we will learn about ``dir`` and how it facilitates us\nin introspection.\n\nIt is one of the most important functions for introspection. It returns\na list of attributes and methods belonging to an object. Here is an\nexample:\n\n.. code:: python\n\n    my_list = [1, 2, 3]\n    dir(my_list)\n    # Output: ['__add__', '__class__', '__contains__', '__delattr__', '__delitem__',\n    # '__delslice__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__',\n    # '__getitem__', '__getslice__', '__gt__', '__hash__', '__iadd__', '__imul__',\n    # '__init__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__',\n    # '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__',\n    # '__setattr__', '__setitem__', '__setslice__', '__sizeof__', '__str__',\n    # '__subclasshook__', 'append', 'count', 'extend', 'index', 'insert', 'pop',\n    # 'remove', 'reverse', 'sort']\n\nOur introspection gave us the names of all the methods of a list. This\ncan be handy when you are not able to recall a method name. If we run\n``dir()`` without any argument then it returns all names in the current\nscope.\n\n``type`` and ``id``\n^^^^^^^^^^^^^^^^^^^^^^^\n\nThe ``type`` function returns the type of an object. For example:\n\n.. code:: python\n\n    print(type(''))\n    # Output: <type 'str'>\n\n    print(type([]))\n    # Output: <type 'list'>\n\n    print(type({}))\n    # Output: <type 'dict'>\n\n    print(type(dict))\n    # Output: <type 'type'>\n\n    print(type(3))\n    # Output: <type 'int'>\n\n``id`` returns the unique ids of various objects. For instance:\n\n.. code:: python\n\n    name = \"Yasoob\"\n    print(id(name))\n    # Output: 139972439030304\n\n``inspect`` module\n^^^^^^^^^^^^^^^^^^^^^^\n\nThe inspect module also provides several useful functions to get\ninformation about live objects. For example you can check the members of\nan object by running:\n\n.. code:: python\n\n    import inspect\n    print(inspect.getmembers(str))\n    # Output: [('__add__', <slot wrapper '__add__' of ... ...\n\nThere are a couple of other methods as well which help in introspection.\nYou can explore them if you wish.\n"
        },
        {
          "name": "one_liners.rst",
          "type": "blob",
          "size": 3.5869140625,
          "content": "One-Liners\n----------\n\nIn this chapter I will show you some one-liner Python commands which can\nbe really helpful.\n\n**Simple Web Server**\n\nEver wanted to quickly share a file over a network? Well you are in\nluck. Python has a feature just for you. Go to the directory\nwhich you want to serve over the network and write the following code in\nyour terminal:\n\n.. code:: python\n\n    # Python 2\n    python -m SimpleHTTPServer\n\n    # Python 3\n    python -m http.server\n\n**Pretty Printing**\n\nYou can print a list and dictionary in a beautiful format in the Python\nrepl. Here is the relevant code:\n\n.. code:: python\n\n    from pprint import pprint\n\n    my_dict = {'name': 'Yasoob', 'age': 'undefined', 'personality': 'awesome'}\n    print(dir(my_dict))\n    # ['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']\n    \n    pprint(dir(my_dict))\n    # ['__add__',\n    #  '__class__',\n    #  '__contains__',\n    #  '__delattr__',\n    #  '__delitem__',\n    #  '__dir__',\n    #  '__doc__',\n    #  '__eq__',\n    #  '__format__',\n    #  '__ge__',\n    #  '__getattribute__',\n    #  '__getitem__',\n    #  '__gt__',\n    #  '__hash__',\n    #  '__iadd__',\n    #  '__imul__',\n    #  '__init__',\n    #  '__init_subclass__',\n    #  '__iter__',\n    #  '__le__',\n    #  '__len__',\n    #  '__lt__',\n    #  '__mul__',\n    #  '__ne__',\n    #  '__new__',\n    #  '__reduce__',\n    #  '__reduce_ex__',\n    #  '__repr__',\n    #  '__reversed__',\n    #  '__rmul__',\n    #  '__setattr__',\n    #  '__setitem__',\n    #  '__sizeof__',\n    #  '__str__',\n    #  '__subclasshook__',\n    #  'append',\n    #  'clear',\n    #  'copy',\n    #  'count',\n    #  'extend',\n    #  'index',\n    #  'insert',\n    #  'pop',\n    #  'remove',\n    #  'reverse',\n    #  'sort']\n\n\nThis is more effective on nested ``dict`` s. Moreover, if you want to pretty print\njson quickly from a file then you can simply do:\n\n.. code:: python\n\n    cat file.json | python -m json.tool\n\n**Profiling a script**\n\nThis can be extremely helpful in pinpointing the bottlenecks in your\nscripts:\n\n.. code:: python\n\n    python -m cProfile my_script.py\n\nNote: ``cProfile`` is a faster implementation of ``profile`` as it is\nwritten in c\n\n**CSV to json**\n\nRun this in the terminal:\n\n.. code:: python\n\n    python -c \"import csv,json;print json.dumps(list(csv.reader(open('csv_file.csv'))))\"\n\nMake sure that you replace ``csv_file.csv`` to the relevant file name.\n\n**List Flattening**\n\nYou can quickly and easily flatten a list using\n``itertools.chain.from_iterable`` from the ``itertools`` package. Here\nis a simple example:\n\n.. code:: python\n\n    a_list = [[1, 2], [3, 4], [5, 6]]\n    print(list(itertools.chain.from_iterable(a_list)))\n    # Output: [1, 2, 3, 4, 5, 6]\n    \n    # or \n    print(list(itertools.chain(*a_list)))\n    # Output: [1, 2, 3, 4, 5, 6]\n\n\n**One-Line Constructors**\n\nAvoid a lot of boilerplate assignments when initializing a class\n\n.. code:: python\n\n    class A(object):\n        def __init__(self, a, b, c, d, e, f):\n            self.__dict__.update({k: v for k, v in locals().items() if k != 'self'})\n\n\nAdditional one-liners can be found on the `Python\nwebsite <https://wiki.python.org/moin/Powerful%20Python%20One-Liners>`__.\n"
        },
        {
          "name": "open_function.rst",
          "type": "blob",
          "size": 4.61328125,
          "content": "``open`` Function\n-------------\n\n`open <http://docs.python.org/dev/library/functions.html#open>`__ opens\na file. Pretty simple, eh? Most of the time, we see it being used like\nthis:\n\n.. code:: python\n\n    f = open('photo.jpg', 'r+')\n    jpgdata = f.read()\n    f.close()\n\nThe reason I am writing this article is that most of the time, I see\nopen used like this. There are **three** errors in the above code. Can\nyou spot them all? If not, read on. By the end of this article, you'll\nknow what's wrong in the above code, and, more importantly, be able to\navoid these mistakes in your own code. Let's start with the basics:\n\nThe return value from ``open`` is a file handle, given out from the operating system\nto your Python application. You will want to return this file handle\nonce you're finished with the file, if only so that your application\nwon't reach the limit of the number of open file handles it can have at\nonce.\n\nExplicitly calling ``close`` closes the file handle, but only if the\nread was successful. If there is any error just after ``f = open(...)``,\n``f.close()`` will not be called (depending on the Python interpreter,\nthe file handle may still be returned, but that's another story). To\nmake sure that the file gets closed whether an exception occurs or not,\npack it into a ``with`` statement:\n\n.. code:: python\n\n    with open('photo.jpg', 'r+') as f:\n        jpgdata = f.read()\n\nThe first argument of ``open`` is the filename. The second one (the\n*mode*) determines *how* the file gets opened.\n\n-  If you want to read the file, pass in ``r``\n-  If you want to read and write the file, pass in ``r+``\n-  If you want to overwrite the file, pass in ``w``\n-  If you want to append to the file, pass in ``a``\n\nWhile there are a couple of other valid mode strings, chances are you\nwon't ever use them. The mode matters not only because it changes the\nbehavior, but also because it may result in permission errors. For\nexample, if we were to open a jpg-file in a write-protected directory,\n``open(.., 'r+')`` would fail. The mode can contain one further\ncharacter; we can open the file in binary (you'll get a string of bytes)\nor text mode (a string of characters).\n\nIn general, if the format is written by humans, it tends to be text\nmode. ``jpg`` image files are not generally written by humans (and are\nindeed not readable by humans), and you should therefore open them in\nbinary mode by adding a ``b`` to the mode string (if you're following\nthe opening example, the correct mode would be ``rb``). If you open\nsomething in text mode (i.e. add a ``t``, or nothing apart from\n``r/r+/w/a``), you must also know which encoding to use. For a\ncomputer, all files are just bytes, not characters.\n\nUnfortunately, ``open`` does not allow explicit encoding specification\nin Python 2.x. However, the function\n`io.open <http://docs.python.org/2/library/io.html#io.open>`__ is\navailable in both Python 2.x and 3.x (where it is an alias of ``open``),\nand does the right thing. You can pass in the encoding with the\n``encoding`` keyword. If you don't pass in any encoding, a system -- and\nPython -- specific default will be picked. You may be tempted to rely on\nthese defaults, but the defaults are often wrong, or the default\nencoding cannot actually express all characters in the file (this will happen often on\nPython 2.x and/or Windows). So go ahead and pick an encoding. Encoding is the way to instruct computers about how the numbers should be stored as bytes in memory. ``utf-8``\nis a terrific one and is supported by major browsers and programming languages. When you write a file, you can just pick the encoding\nto your liking (or the liking of the program that will eventually read\nyour file).\n\nHow do you find out which encoding a file you're reading was written in? Well,\nunfortunately, there is no foolproof way to detect the encoding - the\nsame bytes can represent different, but equally valid characters in\ndifferent encodings. Therefore, you must rely on metadata (for example,\nin HTTP headers) to know the encoding. Increasingly, formats just define\nthe encoding to be UTF-8.\n\nArmed with this knowledge, let's write a program that reads a file,\ndetermines whether it's JPG (hint: These files start with the bytes\n``FF D8``), and writes a text file that describe the input file.\n\n.. code:: python\n\n    import io\n\n    with open('photo.jpg', 'rb') as inf:\n        jpgdata = inf.read()\n\n    if jpgdata.startswith(b'\\xff\\xd8'):\n        text = u'This is a JPEG file (%d bytes long)\\n'\n    else:\n        text = u'This is a random file (%d bytes long)\\n'\n\n    with io.open('summary.txt', 'w', encoding='utf-8') as outf:\n        outf.write(text % len(jpgdata))\n\nI am sure that now you will use ``open`` correctly!\n"
        },
        {
          "name": "params.json",
          "type": "blob",
          "size": 1.93359375,
          "content": "{\"name\":\"Python-book\",\"tagline\":\"Intermediate Python\",\"body\":\"### Welcome to GitHub Pages.\\r\\nThis automatic page generator is the easiest way to create beautiful pages for all of your projects. Author your page content here [using GitHub Flavored Markdown](https://guides.github.com/features/mastering-markdown/), select a template crafted by a designer, and publish. After your page is generated, you can check out the new `gh-pages` branch locally. If you’re using GitHub Desktop, simply sync your repository and you’ll see the new branch.\\r\\n\\r\\n### Designer Templates\\r\\nWe’ve crafted some handsome templates for you to use. Go ahead and click 'Continue to layouts' to browse through them. You can easily go back to edit your page before publishing. After publishing your page, you can revisit the page generator and switch to another theme. Your Page content will be preserved.\\r\\n\\r\\n### Creating pages manually\\r\\nIf you prefer to not use the automatic generator, push a branch named `gh-pages` to your repository to create a page manually. In addition to supporting regular HTML content, GitHub Pages support Jekyll, a simple, blog aware static site generator. Jekyll makes it easy to create site-wide headers and footers without having to copy them across every page. It also offers intelligent blog support and other advanced templating features.\\r\\n\\r\\n### Authors and Contributors\\r\\nYou can @mention a GitHub username to generate a link to their profile. The resulting `<a>` element will link to the contributor’s GitHub Profile. For example: In 2007, Chris Wanstrath (@defunkt), PJ Hyett (@pjhyett), and Tom Preston-Werner (@mojombo) founded GitHub.\\r\\n\\r\\n### Support or Contact\\r\\nHaving trouble with Pages? Check out our [documentation](https://help.github.com/pages) or [contact support](https://github.com/contact) and we’ll help you sort it out.\\r\\n\",\"google\":\"\",\"note\":\"Don't delete this file! It's used internally to help with page regeneration.\"}"
        },
        {
          "name": "python_c_extension.rst",
          "type": "blob",
          "size": 12.396484375,
          "content": "Python C extensions\n===================\n\nAn interesting feature offered to developers by the CPython\nimplementation is the ease of interfacing C code to Python.\n\nThere are three key methods developers use to call C functions from\ntheir python code - ``ctypes``, ``SWIG`` and ``Python/C API``. Each\nmethod comes with its own merits and demerits.\n\nFirstly, why would you want to interface C with Python?\n\nA few common reasons are :\n\n-   You want speed and you know C is about 50x faster than Python.\n-   Certain legacy C libraries work just as well as you want them to, so you don't want to rewrite them in python.\n-   Certain low level resource access - from memory to file interfaces.\n-   Just because you want to.\n\nCTypes\n---------\n\nThe Python `ctypes\nmodule <https://docs.python.org/2/library/ctypes.html>`__ is probably\nthe easiest way to call C functions from Python. The ctypes module\nprovides C compatible data types and functions to load DLLs so that\ncalls can be made to C shared libraries without having to modify them.\nThe fact that the C side needn't be touched adds to the simplicity of\nthis method.\n\n**Example**\n\nSimple C code to add two numbers, save it as ``add.c``\n\n.. code:: c\n\n    //sample C file to add 2 numbers - int and floats\n\n    int add_int(int, int);\n    float add_float(float, float);\n\n    int add_int(int num1, int num2){\n        return num1 + num2;\n    }\n\n    float add_float(float num1, float num2){\n        return num1 + num2;\n    }\n\nNext compile the C file to a ``.so`` file (DLL in windows) This will\ngenerate an adder.so file.\n\n.. code:: bash\n\n    #For Linux\n    $  gcc -shared -Wl,-soname,adder -o adder.so -fPIC add.c\n\n    #For Mac\n    $ gcc -shared -Wl,-install_name,adder.so -o adder.so -fPIC add.c\n\nNow in your python code -\n\n.. code:: python\n\n    from ctypes import *\n\n    #load the shared object file\n    adder = CDLL('./adder.so')\n\n    #Find sum of integers\n    res_int = adder.add_int(4,5)\n    print \"Sum of 4 and 5 = \" + str(res_int)\n\n    #Find sum of floats\n    a = c_float(5.5)\n    b = c_float(4.1)\n\n    add_float = adder.add_float\n    add_float.restype = c_float\n    print \"Sum of 5.5 and 4.1 = \", str(add_float(a, b))\n\nAnd the output is as follows\n\n::\n\n    Sum of 4 and 5 = 9\n    Sum of 5.5 and 4.1 =  9.60000038147\n\nIn this example the C file is self explanatory - it contains two\nfunctions, one to add two integers and another to add two floats.\n\nIn the python file, first the ctypes module is imported. Then the CDLL\nfunction of the ctypes module is used to load the shared lib file we\ncreated. The functions defined in the C lib are now available to us via\nthe ``adder`` variable. When ``adder.add_int()`` is called, internally a\ncall is made to the ``add_int`` C function. The ctypes interface allows\nus to use native python integers and strings by default while calling\nthe C functions.\n\nFor other types such as boolean or float, we have to use the correct\nctypes. This is seen while passing parameters to the\n``adder.add_float()``. We first create the required c\\_float types from\npython decimal values, and then use them as arguments to the C code.\nThis method is simple and clean, but limited. For example it's not\npossible to manipulate objects on the C side.\n\nSWIG\n-------\n\nSimplified Wrapper and Interface Generator, or SWIG for short is another\nway to interface C code to Python. In this method, the developer must\ndevelop an extra interface file which is an input to SWIG (the command\nline utility).\n\nPython developers generally don't use this method, because it is in most\ncases unnecessarily complex. This is a great method when you have a\nC/C++ code base, and you want to interface it to many different\nlanguages.\n\n**Example** (from the `SWIG website <http://www.swig.org/tutorial.html>`__ )\n\nThe C code, ``example.c`` that has a variety of functions and variables\n\n.. code:: c\n\n     #include <time.h>\n     double My_variable = 3.0;\n\n     int fact(int n) {\n         if (n <= 1) return 1;\n         else return n*fact(n-1);\n     }\n\n     int my_mod(int x, int y) {\n         return (x%y);\n     }\n\n     char *get_time()\n     {\n         time_t ltime;\n         time(&ltime);\n         return ctime(&ltime);\n     }\n\nThe interface file - this will remain the same irrespective of the\nlanguage you want to port your C code to :\n\n::\n\n    /* example.i */\n     %module example\n     %{\n     /* Put header files here or function declarations like below */\n     extern double My_variable;\n     extern int fact(int n);\n     extern int my_mod(int x, int y);\n     extern char *get_time();\n     %}\n\n     extern double My_variable;\n     extern int fact(int n);\n     extern int my_mod(int x, int y);\n     extern char *get_time();\n\nAnd now to compile it\n\n::\n\n    unix % swig -python example.i\n    unix % gcc -c example.c example_wrap.c \\\n            -I/usr/local/include/python2.1\n    unix % ld -shared example.o example_wrap.o -o _example.so\n\nFinally, the Python output\n\n.. code:: python\n\n    >>> import example\n    >>> example.fact(5)\n    120\n    >>> example.my_mod(7,3)\n    1\n    >>> example.get_time()\n    'Sun Feb 11 23:01:07 1996'\n    >>>\n\nAs we can see, SWIG achieves the same result, but requires a slightly\nmore involved effort. But it's worth it if you are targeting multiple\nlanguages.\n\nPython/C API\n---------------\n\nThe `C/Python API <https://docs.python.org/2/c-api/>`__ is probably the\nmost widely used method - not for its simplicity but for the fact that\nyou can manipulate python objects in your C code.\n\nThis method requires your C code to be specifically written for\ninterfacing with Python code. All Python objects are represented as a\nPyObject struct and the ``Python.h`` header file provides various\nfunctions to manipulate it. For example if the PyObject is also a\nPyListType (basically a list), then we can use the ``PyList_Size()``\nfunction on the struct to get the length of the list. This is equivalent\nto calling ``len(list)`` in python. Most of the basic\nfunctions/opertions that are there for native Python objects are made\navailable in C via the ``Python.h`` header.\n\n**Example**\n\nTo write a C extension that adds all the elements in a python list. (all elements are numbers)\n\nLet's start with the final interface we'd like to have, here is the\npython file that uses the C extension :\n\n.. code:: python\n\n    #Though it looks like an ordinary python import, the addList module is implemented in C\n    import addList\n\n    l = [1,2,3,4,5]\n    print \"Sum of List - \" + str(l) + \" = \" +  str(addList.add(l))\n\nThe above looks like any ordinary python file, which imports and uses\nanother python module called ``addList``. The only difference is that\nthe addList module is not written in Python at all, but rather in C.\n\nNext we'll have a look at the C code that get's built into the\n``addList`` Python module. This may seem a bit daunting at first, but\nonce you understand the various components that go into writing the C\nfile, it's pretty straightforward.\n\n*adder.c*\n\n.. code:: c\n\n    //Python.h has all the required function definitions to manipulate the Python objects\n    #include <Python.h>\n\n     //This is the function that is called from your python code\n    static PyObject* addList_add(PyObject* self, PyObject* args){\n\n      PyObject * listObj;\n\n      //The input arguments come as a tuple, we parse the args to get the various variables\n      //In this case it's only one list variable, which will now be referenced by listObj\n      if (! PyArg_ParseTuple( args, \"O\", &listObj))\n        return NULL;\n\n      //length of the list\n      long length = PyList_Size(listObj);\n\n      //iterate over all the elements\n      long i, sum =0;\n      for(i = 0; i < length; i++){\n        //get an element out of the list - the element is also a python objects\n        PyObject* temp = PyList_GetItem(listObj, i);\n        //we know that object represents an integer - so convert it into C long\n        long elem = PyInt_AsLong(temp);\n        sum += elem;\n      }\n\n      //value returned back to python code - another python object\n      //build value here converts the C long to a python integer\n      return Py_BuildValue(\"i\", sum);\n    }\n\n    //This is the docstring that corresponds to our 'add' function.\n    static char addList_docs[] =\n        \"add( ): add all elements of the list\\n\";\n\n    /* This table contains the relavent info mapping -\n      <function-name in python module>, <actual-function>,\n      <type-of-args the function expects>, <docstring associated with the function>\n    */\n    static PyMethodDef addList_funcs[] = {\n        {\"add\", (PyCFunction)addList_add, METH_VARARGS, addList_docs},\n        {NULL, NULL, 0, NULL}\n    };\n\n    /*\n    addList is the module name, and this is the initialization block of the module.\n    <desired module name>, <the-info-table>, <module's-docstring>\n    */\n    PyMODINIT_FUNC initaddList(void){\n        Py_InitModule3(\"addList\", addList_funcs,\n                       \"Add all ze lists\");\n    }\n\nA step by step explanation :\n\n- The ``<Python.h>`` file consists of all the required types (to represent Python object types) and function definitions (to operate on the python objects).\n- Next we write the function which we plan to call from python. Conventionally the function names are {module-name}\\_{function-name}, which in this case is ``addList_add``. More about the function later.\n- Then fill in the info table - which contains all the relevant info of the functions we desire to have in the module. Every row corresponds to a function, with the last one being a sentinel value (row of null elements).\n- Finally the module initialization block which is of the signature ``PyMODINIT_FUNC init{module-name}``.\n\nThe function ``addList_add`` accepts arguments as a PyObject type struct\n(args is also a tuple type - but since everything in python is an\nobject, we use the generic PyObject notion). The incoming arguments is\nparsed (basically split the tuple into individual elements) by\n``PyArg_ParseTuple()``. The first parameter is the argument variable to\nbe parsed. The second argument is a string that tells us how to parse\neach element in the args tuple. The character in the Nth position of the\nstring tells us the type of the Nth element in the args tuple, example -\n'i' would mean integer, 's' would mean string and 'O' would mean a\nPython object. Next multiple arguments follow, these are where you would\nlike the ``PyArg_ParseTuple()`` function to store all the elements that\nit has parsed. The number of such arguments is equal to the number of\narguments which the module function expects to receive, and positional\nintegrity is maintained. For example if we expected a string, integer\nand a python list in that order, the function signature would be\n\n.. code:: c\n\n    int n;\n    char *s;\n    PyObject* list;\n    PyArg_ParseTuple(args, \"siO\", &s, &n, &list);\n\nIn this case we only have to extract a list object, and store it in the\nvariable ``listObj``. We then use the ``PyList_Size()`` function on our\nlist object and get the length. This is similar to how you would call\n``len(list)`` in python.\n\nNow we loop through the list, get each element using the\n``PyList_GetItem(list, index)`` function. This returns a PyObject\\*. But\nsince we know that the Python objects are also ``PyIntType``, we just\nuse the ``PyInt_AsLong(PyObj *)`` function to get the required value. We\ndo this for every element and finally get the sum.\n\nThe sum is converted to a python object and is returned to the Python\ncode with the help of ``Py_BuildValue()``. Here the \"i\" indicates that\nthe value we want to build is a python integer object.\n\nNow we build the C module. Save the following code as ``setup.py``\n\n.. code:: python\n\n    #build the modules\n\n    from distutils.core import setup, Extension\n\n    setup(name='addList', version='1.0',  \\\n          ext_modules=[Extension('addList', ['adder.c'])])\n\nand run\n\n.. code:: sh\n\n    python setup.py install\n\nThis should now build and install the C file into the python module we\ndesire.\n\nAfter all this hard work, we'll now test if the module works -\n\n.. code:: python\n\n    #module that talks to the C code\n    import addList\n\n    l = [1,2,3,4,5]\n    print \"Sum of List - \" + str(l) + \" = \" +  str(addList.add(l))\n\nAnd here is the output\n\n::\n\n    Sum of List - [1, 2, 3, 4, 5] = 15\n\nSo as you can see, we have developed our first successful C Python\nextension using the Python.h API. This method does seem complex at\nfirst, but once you get used to it it can prove to be quite useful.\n\nOther ways to interface C code to Python is to use an alternative and\nfaster build of python - `Cython <http://cython.org/>`__. But Cython is\na slightly different language than the main stream python we see. Hence\nthat method is not covered here.\n"
        },
        {
          "name": "python_modules_in_c.rst",
          "type": "blob",
          "size": 0.5556640625,
          "content": "Python Modules in C\n-------------------\n\nWe all know that Python can be slow at times. If you are using it to do\nsome resource intensive task then it can be a major bottleneck. What\noptions do we have of making it fast apart from code optimisation?\nFortunately Python has a solution for us. It allows us to interface with\nC code easily and write extensions for critical parts in C. This allows\nto provide a speed boost to our Python code.\n\nThere are already a couple of modules which have been rewritten in C for\nthe sake of speed. They include cPickle, cProfile and c\n"
        },
        {
          "name": "set_-_data_structure.rst",
          "type": "blob",
          "size": 1.8408203125,
          "content": "``set`` Data Structure\n----------------------\n\n``set`` is a really useful data structure. ``sets`` behave mostly like\nlists with the distinction that they can not contain duplicate values.\nIt is really useful in a lot of cases. For instance you might want to\ncheck whether there are duplicates in a list or not. You have two\noptions. The first one involves using a ``for`` loop. Something like\nthis:\n\n.. code:: python\n\n    some_list = ['a', 'b', 'c', 'b', 'd', 'm', 'n', 'n']\n\n    duplicates = []\n    for value in some_list:\n        if some_list.count(value) > 1:\n            if value not in duplicates:\n                duplicates.append(value)\n\n    print(duplicates)\n    # Output: ['b', 'n']\n\nBut there is a simpler and more elegant solution involving ``sets``. You\ncan simply do something like this:\n\n.. code:: python\n\n    some_list = ['a', 'b', 'c', 'b', 'd', 'm', 'n', 'n']\n    duplicates = set([x for x in some_list if some_list.count(x) > 1])\n    print(duplicates)\n    # Output: set(['b', 'n'])\n\nSets also have a few other methods. Below are some of them.\n\n**Intersection**\n\nYou can intersect two sets. For instance:\n\n.. code:: python\n\n    valid = set(['yellow', 'red', 'blue', 'green', 'black'])\n    input_set = set(['red', 'brown'])\n    print(input_set.intersection(valid))\n    # Output: set(['red'])\n\n**Difference**\n\nYou can find the invalid values in the above example using the\ndifference method. For example:\n\n.. code:: python\n\n    valid = set(['yellow', 'red', 'blue', 'green', 'black'])\n    input_set = set(['red', 'brown'])\n    print(input_set.difference(valid))\n    # Output: set(['brown'])\n\nYou can also create sets using the new notation:\n\n.. code:: python\n\n    a_set = {'red', 'blue', 'green'}\n    print(type(a_set))\n    # Output: <type 'set'>\n\nThere are a few other methods as well. I would recommend visiting the\nofficial documentation and giving it a quick read.\n"
        },
        {
          "name": "targeting_python_2_3.rst",
          "type": "blob",
          "size": 3.560546875,
          "content": "Targeting Python 2+3\n--------------------\n\nIn a lot of cases you might want to develop programs which can be run in\nboth Python 2+ and 3+.\n\nJust imagine that you have a very popular Python module which is used by\nhundreds of people but not all of them have the same version of Python (2 or 3). In that case\nyou have two choices. The first one is to distribute 2 modules, one for\nPython 2 and the other for Python 3. The other choice is to modify your\ncurrent code and make it compatible with both Python 2 and 3.\n\nIn this section I am going to highlight some of the tricks which you can\nemploy to make a script compatible with both of them.\n\n**Future imports**\n\nThe first and most important method is to use ``__future__`` imports. It\nallows you to import Python 3 functionality in Python 2. Here are a couple\nexamples:\n\nContext managers were new in Python 2.6+. For using them in Python 2.5 you can use:\n\n.. code:: python\n\n    from __future__ import with_statement\n\n``print`` was changed to a function in Python 3. If you want to use it\nin Python 2 you can import it from ``__future__``:\n\n.. code:: python\n\n    print\n    # Output:\n\n    from __future__ import print_function\n    print(print)\n    # Output: <built-in function print>\n\n**Dealing with module renaming**\n\nFirst, tell me how you import packages in your script ? Most of us do\nthis :\n\n.. code:: python\n\n    import foo\n    # or\n    from foo import bar\n\nDo you know that you can do something like this as well?\n\n.. code:: python\n\n    import foo as foo\n\nI know its function is the same as the above listed code but it is vital\nfor making your script compatible with Python 2 and 3. Now examine the\ncode below :\n\n.. code:: python\n\n    try:\n        import urllib.request as urllib_request  # for Python 3\n    except ImportError:\n        import urllib2 as urllib_request  # for Python 2\n\nSo let me explain the above code a little. We are wrapping our importing\ncode in a ``try/except`` clause. We are doing it because in Python 2 there is\nno ``urllib.request`` module so this would result in an ``ImportError``. The\nfunctionality of ``urllib.request`` is provided by the ``urllib2`` module in\nPython 2. So, when using Python 2, we try to import ``urllib.request`` and\nif we get an ``ImportError`` then we tell Python to import ``urllib2`` instead.\n\nThe final thing you need to know about is the ``as`` keyword. It is\nmapping the imported module to ``urllib_request``. So that all of\nthe classes and methods within ``urllib2`` are available to us via the alias\n``urllib_request``.\n\n**Obsolete Python 2 builtins**\n\nAnother thing to keep in mind is that there are 12 Python 2 builtins\nwhich have been removed from Python 3. Make sure that you don't use them\nin Python 2 in order to make your code compatible with Python 3.\nHere is a way to enforce that you abandon these 12 builtins in Python 2 as\nwell:\n\n.. code:: python\n\n    from future.builtins.disabled import *\n\nNow whenever you try to use the modules which are abandoned in Python 3,\nit raises a ``NameError`` like this:\n\n.. code:: python\n\n    from future.builtins.disabled import *\n\n    apply()\n    # Output: NameError: obsolete Python 2 builtin apply is disabled\n\n**External standard-library backports**\n\nThere are a few packages in the wild which provide Python 3\nfunctionality in Python 2. For instance, we have:\n\n-  enum ``pip install enum34``\n-  singledispatch ``pip install singledispatch``\n-  pathlib ``pip install pathlib``\n\nFor further reading, the Python documentation has a `comprehensive guide\n<https://docs.python.org/3/howto/pyporting.html>`_ of steps you need to\ntake to make your code compatible with both Python 2 and 3.\n"
        },
        {
          "name": "ternary_operators.rst",
          "type": "blob",
          "size": 3.00390625,
          "content": "Ternary Operators\n-----------------\n\nTernary operators are more commonly known as conditional expressions in\nPython. These operators evaluate something based on a condition being\ntrue or not. They became a part of Python in version 2.4\n\nHere is a blueprint and an example of using these conditional\nexpressions.\n\n**Blueprint:**\n\n.. code:: python\n\n    value_if_true if condition else value_if_false\n\n**Example:**\n\n.. code:: python\n\n    is_nice = True\n    state = \"nice\" if is_nice else \"not nice\"\n\nIt allows to quickly test a condition instead of a multiline if\nstatement. Often times it can be immensely helpful and can make your\ncode compact but still maintainable.\n\nAnother more obscure and not widely used example involves tuples. Here\nis some sample code:\n\n**Blueprint:**\n\n.. code:: python\n\n    (if_test_is_false, if_test_is_true)[test]\n\n**Example:**\n\n.. code:: python\n\n    nice = True\n    personality = (\"mean\", \"nice\")[nice]\n    print(\"The cat is \", personality)\n    # Output: The cat is nice\n\nThis works simply because True == 1 and False == 0, and so can be done\nwith lists in addition to tuples.\n\nThe above example is not widely used and is generally disliked by\nPythonistas for not being Pythonic. It is also easy to confuse where to\nput the true value and where to put the false value in the tuple.\n\nAnother reason to avoid using a tupled ternery is that it results in\nboth elements of the tuple being evaluated, whereas the if-else\nternary operator does not.\n\n**Example:**\n\n.. code:: python\n\n    condition = True\n    print(2 if condition else 1/0)\n    #Output is 2\n\n    print((1/0, 2)[condition])\n    #ZeroDivisionError is raised\n    \nThis happens because with the tupled ternary technique, the tuple is\nfirst built, then an index is found.  For the if-else ternary operator,\nit follows the normal if-else logic tree.  Thus, if one case could\nraise an exception based on the condition, or if either case is a\ncomputation-heavy method, using tuples is best avoided.\n\n\n**ShortHand Ternary**\n\nIn python there is also the shorthand ternary tag which is a shorter version of the \nnormal ternary operator you have seen above. \n\nSyntax was introduced in Python 2.5 and can be used in python 2.5 or greater.\n\n**Example**\n\n.. code:: python\n\n    >>> True or \"Some\"\n    True\n    >>>\n    >>> False or \"Some\"\n    'Some'\n\nThe first statement (`True or \"Some\"`) will return `True` and the second statement (`False or \"Some\"`) will return `Some`. \n\nThis is helpful in case where you quickly want to check for the output of a function and give a useful message if the output is empty:\n\n.. code:: python\n\n    >>> output = None\n    >>> msg = output or \"No data returned\"\n    >>> print(msg)\n    No data returned\n\nOr as a simple way to define function parameters with dynamic default values:\n\n.. code:: python\n\n    >>> def my_function(real_name, optional_display_name=None):\n    >>>     optional_display_name = optional_display_name or real_name\n    >>>     print(optional_display_name)\n    >>> my_function(\"John\")\n    John\n    >>> my_function(\"Mike\", \"anonymous123\")\n    anonymous123\n"
        },
        {
          "name": "virtual_environment.rst",
          "type": "blob",
          "size": 2.65234375,
          "content": "Virtual Environment\n-------------------\n\nHave you ever heard of ``virtualenv``? If you are a beginner,\nthen you might not have heard about it but if you are a\nseasoned programmer then it may well be a vital part of your toolset. \n\nSo what is ``virtualenv``? ``Virtualenv`` is a tool which allows us to\nmake isolated python environments. Imagine you have an application that\nneeds version 2 of a library, but another application requires\nversion 3. How can you use and develop both these applications?\n\nIf you install everything into ``/usr/lib/python2.7/site-packages`` (or\nwhatever your platform's standard location is), it's easy to end up in a\nsituation where you unintentionally upgrade a package.\n\nIn another case, imagine that you have an application which is fully\ndeveloped and you do not want to make any change to the libraries it is\nusing but at the same time you start developing another application\nwhich requires the updated versions of those libraries.\n\nWhat will you do? Use ``virtualenv``! It creates isolated environments\nfor your python application and allows you to install Python libraries\nin that isolated environment instead of installing them globally.\n\nTo install it, just type this command in the shell:\n\n.. code:: python\n\n    $ pip install virtualenv\n\nThe most important commands are:\n\n-  ``$ virtualenv myproject``\n-  ``$ source myproject/bin/activate``\n\nThis first one makes an isolated virtualenv environment in the\n``myproject`` folder and the second command activates that isolated\nenvironment.\n\nWhile creating the virtualenv you have to make a decision. Do you\nwant this virtualenv to use packages from your system ``site-packages``\nor install them in the virtualenv’s site-packages? By default,\nvirtualenv will not give access to the global ``site-packages``.\n\nIf you want your ``virtualenv`` to have access to your systems\n``site-packages``, use the ``--system-site-packages`` switch when creating\nyour virtualenv like this:\n\n.. code:: python\n\n    $ virtualenv --system-site-packages mycoolproject\n\nYou can turn off the ``env`` by typing:\n\n.. code:: python\n\n    $ deactivate\n\nRunning `python` after deactivating will use your system installation\nof Python again.\n\n**Bonus**\n\nYou can use ``smartcd`` which is a library for bash and zsh and allows\nyou to alter your bash (or zsh) environment as you cd. It can be really\nhelpful to activate and deactivate a ``virtualenv`` when you change\ndirectories. I have used it quite a lot and love it. You can read more\nabout it on `GitHub <https://github.com/cxreg/smartcd>`__\n\nThis was just a short intro to virtualenv. There's a lot more to it; `this\nlink <http://docs.python-guide.org/en/latest/dev/virtualenvs/>`__ has more\ninformation.\n"
        },
        {
          "name": "zip.rst",
          "type": "blob",
          "size": 2.5185546875,
          "content": "Zip and unzip\n-------------\n\n**Zip**\n\nZip is a useful function that allows you to combine two lists easily. \n\nAfter calling zip, an iterator is returned. In order to see the content wrapped inside, we need to first convert it to a list.\n\nExample:\n\n.. code:: python\n    \n    first_name = ['Joe','Earnst','Thomas','Martin','Charles']\n\n    last_name = ['Schmoe','Ehlmann','Fischer','Walter','Rogan','Green']\n\n    age = [23, 65, 11, 36, 83]\n\n    print(list(zip(first_name,last_name, age)))\n\n    # Output\n    #\n    # [('Joe', 'Schmoe', 23), ('Earnst', 'Ehlmann', 65), ('Thomas', 'Fischer', 11), ('Martin', 'Walter', 36), ('Charles', 'Rogan', 83)]\n\nOne advantage of zip is that it improves readability of for loops.\n\nFor example, instead of needing multiple inputs, you only need one zipped list for the following for loop:\n\n.. code:: python\n\n    first_name = ['Joe','Earnst','Thomas','Martin','Charles']\n    last_name = ['Schmoe','Ehlmann','Fischer','Walter','Rogan','Green']\n    age = [23, 65, 11, 36, 83]\n\n    for first_name, last_name, age in zip(first_name, last_name, age):\n        print(f\"{first_name} {last_name} is {age} years old\")\n\n    # Output\n    #\n    # Joe Schmoe is 23 years old                                                                                                                    \n    # Earnst Ehlmann is 65 years old                                                                                                                \n    # Thomas Fischer is 11 years old                                                                                                                \n    # Martin Walter is 36 years old                                                                                                                 \n    # Charles Rogan is 83 years old\n    \n**Unzip**\n\nWe can use the `zip` function to unzip a list as well. This time, we need an input of a list with an asterisk before it.\n\nThe outputs are the separated lists. \n\nExample:\n\n.. code:: python\n\n    full_name_list = [('Joe', 'Schmoe', 23), \n                      ('Earnst', 'Ehlmann', 65), \n                      ('Thomas', 'Fischer', 11), \n                      ('Martin', 'Walter', 36), \n                      ('Charles', 'Rogan', 83)]\n                      \n    first_name, last_name, age = list(zip(*full_name_list))\n    print(f\"first name: {first_name}\\nlast name: {last_name} \\nage: {age}\")\n\n    # Output\n\n    # first name: ('Joe', 'Earnst', 'Thomas', 'Martin', 'Charles')\n    # last name: ('Schmoe', 'Ehlmann', 'Fischer', 'Walter', 'Rogan')\n    # age: (23, 65, 11, 36, 83)\n\n"
        }
      ]
    }
  ]
}