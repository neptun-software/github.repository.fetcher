{
  "metadata": {
    "timestamp": 1736559640342,
    "page": 295,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjMwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "bitsadmin/wesng",
      "stars": 4278,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 1.8466796875,
          "content": "#### Default Python gitignore ####\n\n# Byte-compiled / optimized / DLL files\n__pycache__/\n*.py[cod]\n*$py.class\n\n# C extensions\n*.so\n\n# Distribution / packaging\n.Python\nbuild/\ndevelop-eggs/\ndist/\ndownloads/\neggs/\n.eggs/\nlib/\nlib64/\nparts/\nsdist/\nvar/\nwheels/\npip-wheel-metadata/\nshare/python-wheels/\n*.egg-info/\n.installed.cfg\n*.egg\nMANIFEST\n\n# PyInstaller\n#  Usually these files are written by a python script from a template\n#  before PyInstaller builds the exe, so as to inject date/other infos into it.\n*.manifest\n*.spec\n\n# Installer logs\npip-log.txt\npip-delete-this-directory.txt\n\n# Unit test / coverage reports\nhtmlcov/\n.tox/\n.nox/\n.coverage\n.coverage.*\n.cache\nnosetests.xml\ncoverage.xml\n*.cover\n*.py,cover\n.hypothesis/\n.pytest_cache/\n\n# Translations\n*.mo\n*.pot\n\n# Django stuff:\n*.log\nlocal_settings.py\ndb.sqlite3\ndb.sqlite3-journal\n\n# Flask stuff:\ninstance/\n.webassets-cache\n\n# Scrapy stuff:\n.scrapy\n\n# Sphinx documentation\ndocs/_build/\n\n# PyBuilder\ntarget/\n\n# Jupyter Notebook\n.ipynb_checkpoints\n\n# IPython\nprofile_default/\nipython_config.py\n\n# pyenv\n.python-version\n\n# pipenv\n#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.\n#   However, in case of collaboration, if having platform-specific dependencies or dependencies\n#   having no cross-platform support, pipenv may install dependencies that don't work, or not\n#   install all needed dependencies.\n#Pipfile.lock\n\n# celery beat schedule file\ncelerybeat-schedule\n\n# SageMath parsed files\n*.sage.py\n\n# Environments\n.env\n.venv\nenv/\nvenv/\nENV/\nenv.bak/\nvenv.bak/\n\n# Spyder project settings\n.spyderproject\n.spyproject\n\n# Rope project settings\n.ropeproject\n\n# mkdocs documentation\n/site\n\n# mypy\n.mypy_cache/\n.dmypy.json\ndmypy.json\n\n# Pyre type checker\n.pyre/\n\n# Visual Studio Code\n.vscode/\n\n# MSRC API key\napikey.txt\n\n# Temporary files created by the collector\nMSRC.csv\nNVD.csv\nBulletin.csv"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 3.732421875,
          "content": "# Version 1.05\n- Support for Windows 11 24H2\n- Fixed regex strings errors running wes.py with Python3 on Windows\n\n# Version 1.04\n- Support for Windows 11 23H2\n- Fix for Windows 11 22H2\n\n# Version 1.03\n- Support for 21H2 of Windows 10, Windows 11 and Windows Server 2022\n\n# Version 1.02\n- Support for Windows 11 and Windows Server 2022\n- Various minor improvements\n\n# Version 1.00\n- Added missingkbs.vbs to use Windows Update to identify missing patches\n- Added support for 'wmic qfe' output\n- Added option to manually specify the Operating System\n- Added support for colored output using --color or -c (thanks to wrighterase)\n- Various minor improvements\n\n# Version 0.98\n- Microsoft Update Catalog lookup feature by Dominic Breuker\n\n# Version 0.97\n- Resolved exception when using --output with Python 2\n- Removed legacy definitions file (CVEs.zip)\n\n# Version 0.96\n- Support for Windows 10 Redstone 6 (1903)\n- Added option to filter on severity \n- Fixup for French systeminfo file\n\n# Version 0.95\n## wes.py\n**New features**\n- Support for manually specified updates in definitions.zip file\n- Feature to remove duplicate results in case of Windows Server\n\n**Improvements**\n- Extended debugging supersedes functionality\n- Cleanup of buildnumbers\n- Added title field to console results\n- Bugfix where in case a Windows version without Service Packs was provided, vulnerabilities of that Windows version _with_ Service Packs would be listed\n- Some minor improvements\n\n## collector\n- Added support to include manually specified updates in definitions.zip file\n- Added csv with manual improvements to the MSRC/Bulletin Excel lists containing:\n  - Services Packs\n  - MS17-010 (EternalBlue) patches for all operating systems\n\n\n# Version 0.942\n**New features**\n- Support for 'wmic qfe' output in case the list of KBs in the systeminfo output is cut off\n- Parameter to use the most recent KB installed as reference point to filter out all vulnerabilities of KBs prior this date\n- Parameter to show version\n- (Hidden) flag to debug supersedes\n\n**Improvements**\n- Added comments to the code for improved readability\n- Some minor improvements\n\n\n# Version 0.94\n## wes.py\n**New features**\n- Updated database format:\n  - Filename of new format: definitions.zip\n  - The CVEs file won't be extracted to disk but instead be directly read from the zip which greatly reduces the on-disk size of WES-NG.\n  - The database format now contains the date at which the definitions have been created and a version number in case the database format will be updated again in the future. In that case the user will be informed to update wes.py tool.\n  - Legacy updates file (CVEs.zip) will still be maintained for a while for whoever is still using a previous version of WES-NG.\n- Update to the latest version of wes.py using the `--update-wes` parameter.\n- Output shows summary of missing patches and the number of vulnerabilities this patch would patch.\n- Option to output to a .csv file instead of to the screen using the `--output` or `-o` parameter, for example `-o vulns.csv`.\n- Manually specify KBs that have been installed (or should be ignored) using the `--patches` or `-p` parameter, for example `-p KB4345421 KB4487017`. See (this)[/todo] article on how to use this feature to reduce false-positives.\n\n**Additionally**\n- For readability restructured code into separate functions.\n- Bugfix in case a record would supersede multiple other records, it would not correctly be processed.\n- Added a banner so when the wes.py output is redirected to a file, it is clear which version of WES-NG was used.\n- Various minor changes and fixes.\n\n## collector\n- collect_bulletin: Merge multiple supersedes instead of splitting them up\n- collect_msrc: Bugfix for multiple supersedes\n- collect_nvd: Added support for outputting the new definitions.zip format\n"
        },
        {
          "name": "CMDLINE.md",
          "type": "blob",
          "size": 7.5830078125,
          "content": "The following commandline options are available for WES-NG v1.0.\n\n# wes.py\n```\nusage: wes.py [-u] [--definitions [DEFINITIONS]]\n              [-p INSTALLEDPATCH [INSTALLEDPATCH ...]] [-d] [-e]\n              [--hide HIDDENVULN [HIDDENVULN ...]] [-i IMPACTS [IMPACTS ...]]\n              [-s SEVERITIES [SEVERITIES ...]] [-o [OUTPUTFILE]]\n              [--muc-lookup] [--os [OPERATING_SYSTEM]] [-c] [-h]\n              [--update-wes]\n\nWindows Exploit Suggester 1.00 ( https://github.com/bitsadmin/wesng/ )\n\noptional arguments:\n  -u, --update          Download latest list of CVEs\n  --definitions [DEFINITIONS]\n                        Definitions zip file (default: definitions.zip)\n  -p INSTALLEDPATCH [INSTALLEDPATCH ...], --patches INSTALLEDPATCH [INSTALLEDPATCH ...]\n                        Manually specify installed patches in addition to the\n                        ones listed in the systeminfo.txt file\n  -d, --usekbdate       Filter out vulnerabilities of KBs published before the\n                        publishing date of the most recent KB installed\n  -e, --exploits-only   Show only vulnerabilities with known exploits\n  --hide HIDDENVULN [HIDDENVULN ...]\n                        Hide vulnerabilities of for example Adobe Flash Player\n                        and Microsoft Edge\n  -i IMPACTS [IMPACTS ...], --impact IMPACTS [IMPACTS ...]\n                        Only display vulnerabilities with a given impact\n  -s SEVERITIES [SEVERITIES ...], --severity SEVERITIES [SEVERITIES ...]\n                        Only display vulnerabilities with a given severity\n  -o [OUTPUTFILE], --output [OUTPUTFILE]\n                        Store results in a file\n  --muc-lookup          Hide vulnerabilities if installed hotfixes are listed\n                        in the Microsoft Update Catalog as superseding\n                        hotfixes for the original BulletinKB\n  --os [OPERATING_SYSTEM]\n                        Specify operating system or ID from list when running\n                        without this parameter\n  -c, --color           Show console output in color (requires termcolor\n                        library)\n  -h, --help            Show this help message and exit\n  --update-wes          Download latest version of wes.py\n\nExamples:\n  Download latest definitions\n  wes.py --update\n  wes.py -u\n\n  Determine vulnerabilities\n  wes.py systeminfo.txt\n  \n  Determine vulnerabilities using the qfe file. List the OS by first running the command without the --os parameter\n  wes.py --qfe qfe.txt --os 'Windows 10 Version 20H2 for x64-based Systems'\n  wes.py -q qfe.txt --os 9\n\n  Determine vulnerabilities and output to file\n  wes.py systeminfo.txt --output vulns.csv\n  wes.py systeminfo.txt -o vulns.csv\n\n  Determine vulnerabilities explicitly specifying KBs to reduce false-positives\n  wes.py systeminfo.txt --patches KB4345421 KB4487017\n  wes.py systeminfo.txt -p KB4345421 KB4487017\n  \n  Determine vulnerabilies filtering out out vulnerabilities of KBs that have been published before the publishing date of the most recent KB installed\n  wes.py systeminfo.txt --usekbdate\n  wes.py systeminfo.txt -d\n\n  Determine vulnerabilities explicitly specifying definitions file\n  wes.py systeminfo.txt --definitions C:\\tmp\\mydefs.zip\n\n  List only vulnerabilities with exploits, excluding IE, Edge and Flash\n  wes.py systeminfo.txt --exploits-only --hide \"Internet Explorer\" Edge Flash\n  wes.py systeminfo.txt -e --hide \"Internet Explorer\" Edge Flash\n\n  Only show vulnerabilities of a certain impact\n  wes.py systeminfo.txt --impact \"Remote Code Execution\"\n  wes.py systeminfo.txt -i \"Remote Code Execution\"\n  \n  Only show vulnerabilities of a certain severity\n  wes.py systeminfo.txt --severity critical\n  wes.py systeminfo.txt -s critical\n  \n  Show vulnerabilities based on missing patches \n  wes.py --missing missing.txt\n  wes.py -m missing.txt\n  \n  Show vulnerabilities based on missing patches specifying OS\n  wes.py --missing missing.txt --os \"Windows 10 Version 1809 for x64-based Systems\"\n  wes.py -m missing.txt --os 2\n\n  Validate supersedence against Microsoft's online Update Catalog\n  wes.py systeminfo.txt --muc-lookup\n\n  Show colored output \n  wes.py systeminfo.txt --color\n  wes.py systeminfo.txt -c\n\n  Download latest version of WES-NG\n  wes.py --update-wes\n```\n\n# missingkbs.vbs\n```\nWindows Exploit Suggester: Missing KBs Identifier v1.0\nhttps://github.com/bitsadmin/wesng/\n\nUsage: missingkbs.vbs [/F] [/I:[filename]] [/P] [/O:[filename]]\n\nDescription:\n    Compiles a list of missing KBs on the current system.\n    These missing KBs are determined based either the online\n    Microsoft Update service or WSUS if configured, or on an offline\n    scanfile (wsusscn2.cab). This scanfile is either provided in the\n    commandline or downloaded from the Microsoft Update site.\n    By default the online Microsoft Update service is used (or WSUS if configured).\n\nParameter List:\n    /F or /Offline  Perform an offline scan using a scanfile.\n    /I:[filename]   Specify path to the scanfile (wsusscn2.cab). Implies /F and /P.\n    /P              Preserve the scanfile.\n    /O:[filename]   Specify filename to store the results in. By default the\n                    file missing.txt in the current directory will be used.\n    /D:[directory]  Just download the scanfile (don't check for missing KBs).\n                    By default the file will be downloaded to the current directory.\n    /? or /Help     Displays this help message.\n\nExamples:\n    Determine missing KBs using online Microsoft Update service (or WSUS if configured)\n    cscript.exe missingkbs.vbs\n\n    Determine missing KBs downloading the wsusscn2.cab scanfile and preserving it\n    cscript.exe missingkbs.vbs /F /P\n\n    Determine missing KBs using the offline wsusscn2.cab scanfile\n    cscript.exe missingkbs.vbs /F /I:E:\\tmp\\wsusscn2.cab\n\n    Determine missing KBs downloading the wsusscn2.cab scanfile saving results in out.txt\n    cscript.exe missingkbs.vbs /F /O:E:\\tmp\\out.txt\n\n    Download the scanfile to E:\\tmp\\\n    cscript.exe missingkbs.vbs /D:E:\\tmp\n```\n\n# missingkbs.ps1\n```\nNAME\n    missingkbs.ps1\n\nSYNOPSIS\n    Compiles a list of missing KBs on the current system.\n\n\nSYNTAX\n    missingkbs.ps1 [-Online] [-OutputFile <String>] [<CommonParameters>]\n\n    missingkbs.ps1 [-Offline] [-ScanFile <String>] [-Preserve] [-OutputFile <String>] [<CommonParameters>]\n\n    missingkbs.ps1 [-DownloadOnly] [-TargetPath <String>] [<CommonParameters>]\n\n\nDESCRIPTION\n    These missing KBs are determined based either on the online Microsoft Update service or WSUS if configured, or on an offline scanfile (wsusscn2.cab). This scanfile is either provided in the command line or downloaded from the Microsoft Update\n    site. By default, the online Microsoft Update service is used (or WSUS if configured).\n\n\nNOTES\n    On Windows, it may be required to enable this Activate.ps1 script by setting the execution policy for the user. You can do this by issuing the following PowerShell command:\n\n    PS C:\\> Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser\n\n    For more information on Execution Policies:\n    https://go.microsoft.com/fwlink/?LinkID=135170\n\n\nEXAMPLES\n    PS > missingkbs.ps1\n    Determine missing KBs using the online Microsoft Update service (or WSUS if configured)\n\n    PS > missingkbs.ps1 -Offline -Preserve\n    Determine missing KBs downloading the wsusscn2.cab scanfile and preserving it\n\n    PS > missingkbs.ps1 -Offline -ScanFile E:\\tmp\\wsusscn2.cab\n    Determine missing KBs using the offline wsusscn2.cab scanfile\n\n    PS > missingkbs.ps1 -Offline -OutputFile E:\\tmp\\out.txt\n    Determine missing KBs downloading the wsusscn2.cab scanfile saving results in out.txt\n\n    PS > missingkbs.ps1 -DownloadOnly E:\\tmp\n    Download the scanfile to E:\\tmp\\\n```"
        },
        {
          "name": "LICENSE.txt",
          "type": "blob",
          "size": 1.423828125,
          "content": "Copyright 2019 Arris Huijgen\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this\nlist of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\nthis list of conditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its contributors\nmay be used to endorse or promote products derived from this software without\nspecific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 5.2998046875,
          "content": "# Windows Exploit Suggester - Next Generation (WES-NG)\r\nWES-NG is a tool based on the output of Windows' `systeminfo` utility which provides the list of vulnerabilities the OS is vulnerable to, including any exploits for these vulnerabilities. Every Windows OS between Windows XP and Windows 11, including their Windows Server counterparts, is supported.\r\n\r\nAt the BITSADMIN blog an in-depth article on WES-NG is available: [Windows Security Updates for Hackers](https://blog.bitsadmin.com/windows-security-updates-for-hackers).\r\n\r\n## Usage\r\n1. Download WES-NG using `pip install wesng` or using the following commandline: `git clone https://github.com/bitsadmin/wesng --depth 1`\r\n2. Obtain the latest database of vulnerabilities by executing the command `wes.py --update`\r\n3. There are two options to check for missing patches:\r\n    a. Launch `missingkbs.vbs` or `missingkbs.ps1` on the host to have Windows determine which patches are missing\r\n    b. Use Windows' built-in `systeminfo.exe` tool to obtain the system information of the local system, or from a remote system using `systeminfo /S MyRemoteHost`, and redirect this to a file: `systeminfo > systeminfo.txt`\r\n4. Depending on the method chosen in step 3 execute WES-NG:\r\n    a. With the `missing.txt` file as input: `wes.py --missing missing.txt` (or `wes.py -m missing.txt`)\r\n    b. With the `systeminfo.txt` file as the parameter: `wes.py systeminfo.txt`\r\nWES-NG then uses the database to determine which patches are applicable to the system and to which vulnerabilities are currently exposed, including exploits if available.\r\n5. As the data provided by Microsoft's MSRC feed is frequently incomplete and false positives are reported by `wes.py`, @DominicBreuker contributed the `--muc-lookup` parameter to validate identified missing patches from the `systeminfo.txt` file against Microsoft's Update Catalog. Additionally, make sure to check the [Eliminating false positives](https://github.com/bitsadmin/wesng/wiki/Eliminating-false-positives) page at the Wiki on how to interpret the results.\r\nFor an overview of all available parameters for `missingkbs.vbs`, `missingkbs.ps1` and `wes.py`, check [CMDLINE.md](https://github.com/bitsadmin/wesng/blob/master/CMDLINE.md).\r\n\r\n## Demo\r\n![Gif animation showing usage of Windows Exploit Suggester - Next Generation](https://raw.githubusercontent.com/bitsadmin/wesng/master/demo.gif)\r\n\r\n## Collector\r\nThis GitHub repository regularly updates the database of vulnerabilities, so running `wes.py` with the `--update` parameter gets the latest version.\r\nIf manual generation of the .csv file with hotfix information is required, use the scripts from the [/collector](collector) folder to compile the database. Read the comments at the top of each script and execute them in the order as they are listed below. Executing these scripts will produce definitions.zip.\r\nThe WES-NG collector pulls information from various sources:\r\n- Microsoft Security Bulletin Data: KBs for older systems [1]\r\n- MSRC: The Microsoft Security Update API of the Microsoft Security Response Center (MSRC): Standard source of information for modern Microsoft Updates [2]\r\n- NIST National Vulnerability Database (NVD): Complement vulnerabilities with Exploit-DB links [3]\r\nThese are combined into a single .csv file which is compressed and hosted in this GitHub repository.\r\n\r\n## Rationale\r\nI developed WES-NG because while [GDSSecurity's Windows-Exploit-Suggester](https://github.com/GDSSecurity/Windows-Exploit-Suggester/) worked excellently for operating systems in the Windows XP and Windows Vista era, GDSSecurity's Windows-Exploit-Suggester does not work for operating systems like Windows 11 and vulnerabilities published in recent years. This is because Microsoft replaced the Microsoft Security Bulletin Data Excel file [1] on which GDSSecurity's Windows-Exploit-Suggester is fully dependent, by the MSRC API [2]. The Microsoft Security Bulletin Data Excel file has not been updated since Q1 2017, so later operating systems and vulnerabilities cannot be detected. Thanks [@gdssecurity](https://twitter.com/gdssecurity), for this great tool which has served many of us for so many years!\r\n\r\n## Bugs\r\n- Bugs can be submitted via the [Issues](https://github.com/bitsadmin/wesng/issues) page\r\n- For false positives in results, please read the [Eliminating false positives](https://github.com/bitsadmin/wesng/wiki/Eliminating-false-positives) page at the Wiki first. In case that doesn't significantly reduce the number of false positives, follow the steps at the [Report false positives](https://github.com/bitsadmin/wesng/wiki/Reporting-false-positives) page on the [Wiki](https://github.com/bitsadmin/wesng/wiki).\r\n\r\n## Changelog\r\nSee [CHANGELOG.md](https://github.com/bitsadmin/wesng/blob/master/CHANGELOG.md)\r\n\r\n## Improvements\r\n- Add support for [NoPowerShell](https://github.com/bitsadmin/nopowershell/)'s `Get-SystemInfo` cmdlet output\r\n- Add support for alternative output formats of `systeminfo` (csv, table)\r\n- More testing on the returned false positive vulnerabilities - see also the [wiki](https://github.com/bitsadmin/wesng/wiki)\r\n\r\n## References\r\n[1] https://www.microsoft.com/download/details.aspx?id=36982\r\n\r\n[2] https://portal.msrc.microsoft.com/en-us/developer\r\n\r\n[3] https://nvd.nist.gov/vuln/data-feeds\r\n\r\n#\r\n**Authored by Arris Huijgen ([@bitsadmin](https://twitter.com/bitsadmin/) - https://github.com/bitsadmin/)**\r\n"
        },
        {
          "name": "collector",
          "type": "tree",
          "content": null
        },
        {
          "name": "definitions.zip",
          "type": "blob",
          "size": 2353.873046875,
          "content": null
        },
        {
          "name": "demo.gif",
          "type": "blob",
          "size": 672.8037109375,
          "content": null
        },
        {
          "name": "missingkbs.ps1",
          "type": "blob",
          "size": 11.7587890625,
          "content": "<#\r\n.SYNOPSIS\r\nCompiles a list of missing KBs on the current system.\r\n\r\n.DESCRIPTION\r\nThese missing KBs are determined based either on the online Microsoft Update service or WSUS if configured, or on an offline scanfile (wsusscn2.cab). This scanfile is either provided in the command line or downloaded from the Microsoft Update site. By default, the online Microsoft Update service is used (or WSUS if configured).\r\n\r\n.PARAMETER Offline\r\nPerform an offline scan using a scanfile.\r\n\r\n.PARAMETER ScanFile\r\nSpecify path to the scanfile (wsusscn2.cab). Implies -Offline and -Preserve.\r\n\r\n.PARAMETER Preserve\r\nPreserve the scanfile.\r\n\r\n.PARAMETER OutputFile\r\nSpecify file path to store the results in. By default, the file missing.txt in the current directory will be used.\r\n\r\n.PARAMETER Download\r\nJust download the scanfile (don't check for missing KBs). By default, the file will be downloaded to the current directory.\r\n\r\n.EXAMPLE\r\nmissingkbs.ps1\r\nDetermine missing KBs using the online Microsoft Update service (or WSUS if configured)\r\n\r\n.EXAMPLE\r\nmissingkbs.ps1 -Offline -Preserve\r\nDetermine missing KBs downloading the wsusscn2.cab scanfile and preserving it\r\n\r\n.EXAMPLE\r\nmissingkbs.ps1 -Offline -ScanFile E:\\tmp\\wsusscn2.cab\r\nDetermine missing KBs using the offline wsusscn2.cab scanfile\r\n\r\n.EXAMPLE\r\nmissingkbs.ps1 -Offline -OutputFile E:\\tmp\\out.txt\r\nDetermine missing KBs downloading the wsusscn2.cab scanfile saving results in out.txt\r\n\r\n.EXAMPLE\r\nmissingkbs.ps1 -DownloadOnly E:\\tmp\r\nDownload the scanfile to E:\\tmp\\\r\n\r\n.LINK\r\nhttps://github.com/bitsadmin/wesng/\r\nhttps://blog.bitsadmin.com/windows-security-updates-for-hackers\r\n\r\n.NOTES\r\nOn Windows, it may be required to enable this Activate.ps1 script by setting the execution policy for the user. You can do this by issuing the following PowerShell command:\r\n\r\nPS C:\\> Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser\r\n\r\nFor more information on Execution Policies: \r\nhttps://go.microsoft.com/fwlink/?LinkID=135170\r\n#>\r\n\r\n[CmdletBinding(DefaultParameterSetName = 'Online')]\r\nparam(\r\n    [Parameter(ParameterSetName = 'Online')]\r\n    [switch]$Online,\r\n\r\n    [Parameter(ParameterSetName = 'Offline')]\r\n    [switch]$Offline,\r\n\r\n    [Parameter(ParameterSetName = 'DownloadOnly')]\r\n    [switch]$DownloadOnly,\r\n\r\n    [Parameter(Mandatory = $false, ParameterSetName = 'Offline')]\r\n    [ValidateScript({\r\n        if(-not (Test-Path $_ -PathType Leaf))\r\n        { \r\n            throw 'File does not exist'\r\n        }\r\n        return $true\r\n    })]\r\n    [string]$ScanFile,\r\n\r\n    [Parameter(Mandatory = $false, ParameterSetName = 'Offline')]\r\n    [switch]$Preserve,\r\n\r\n    [Parameter(Mandatory = $false, ParameterSetName = 'Online')]\r\n    [Parameter(Mandatory = $false, ParameterSetName = 'Offline')]\r\n    [ValidateScript({\r\n        $path = Split-Path $_\r\n        if(-not (Test-Path $path -PathType Container))\r\n        {\r\n            throw 'Path does not exist'\r\n        }\r\n        return $true\r\n    })]\r\n    [string]$OutputFile = (Join-Path -Path (Get-Location).Path -ChildPath 'missing.txt'),\r\n\r\n    [Parameter(ParameterSetName = 'DownloadOnly')]\r\n    [ValidateScript({\r\n        if(-not (Test-Path $_ -PathType Container))\r\n        {\r\n            throw 'Path does not exist'\r\n        }\r\n        return $true\r\n    })]\r\n    [string]$TargetPath = (Get-Location).Path\r\n)\r\n\r\n<#\r\nThis software is provided under the BSD 3-Clause License.\r\nSee the accompanying LICENSE file for more information.\r\n\r\nWindows Exploit Suggester - Next Generation\r\nMissing KBs Identifier utility - \r\n\r\nAuthor: Arris Huijgen (@bitsadmin)\r\nWebsite: https://github.com/bitsadmin\r\n#>\r\n\r\n\r\n# Application information\r\n$version = 1.0\r\n$appname = \"Windows Exploit Suggester: Missing KBs Identifier v$($version.ToString(\"0.0\"))\"\r\n$url = 'https://github.com/bitsadmin/wesng/'\r\n$banner = \"$appname`n$url`n\"\r\n\r\n# Show banner\r\nWrite-Host $banner\r\n\r\n# Online or offline scan?\r\n# Defaults to Online\r\nif($ScanFile)\r\n{\r\n    $Offline = $true\r\n}\r\nelseif(-not $Online)\r\n{\r\n    if(-not $Offline -and -not $DownloadOnly)\r\n    {\r\n        $Online = $true\r\n    }\r\n}\r\n$specifiedScanfile = $Offline -or $ScanFile\r\n$foundScanfile = $false\r\n\r\n$runMode = if($Online){ 'Online' } elseif($Offline){ 'Offline' } elseif($DownloadOnly){ 'DownloadOnly' } else { 'Unknown' }\r\nWrite-Host \"[I] Running in $runMode mode\"\r\n\r\n# Only check and download scanfile in case of offline scan\r\nif ($Offline -or $DownloadOnly)\r\n{\r\n    # Only download the scanfile\r\n    if ($DownloadOnly)\r\n    {\r\n        # Compile path for scanfile\r\n        $scanFilePath = Join-Path -Path $TargetPath -ChildPath 'wsusscn2.cab'\r\n    }\r\n    # Download and perform scan\r\n    else\r\n    {\r\n        # If scanfile -ScanFile parameter is not specified, check if it already exists\r\n        # In case it doesn't exist, download it\r\n        if ($ScanFile)\r\n        {\r\n            $scanFilePath = Resolve-Path $ScanFile\r\n            $Preserve = $true\r\n        }\r\n        else\r\n        {\r\n            # Set target location to current directory or temp, depending on whether scanfile needs to be preserved\r\n            if ($Preserve)\r\n            {\r\n                $targetDirectory = Get-Location\r\n            }\r\n            else\r\n            {\r\n                $targetDirectory = [System.IO.Path]::GetTempPath()\r\n            }\r\n\r\n            # Compile path for scanfile\r\n            $scanFilePath = Join-Path -Path $targetDirectory -ChildPath 'wsusscn2.cab'\r\n        }\r\n\r\n        # Check if scanfile exists\r\n        if (Test-Path -Path $scanFilePath -PathType Leaf)\r\n        {\r\n            $objScanFile = Get-Item -Path $scanFilePath\r\n            Write-Host \"[+] Using scanfile '$scanFilePath' with modification date $($objScanFile.LastWriteTime.ToShortDateString())\"\r\n            $foundScanfile = $true\r\n        }\r\n        elseif ($ScanFile)\r\n        {\r\n            Write-Host \"[-] Scanfile '$scanFilePath' does not exist\" -ForegroundColor Red\r\n            exit\r\n        }\r\n    }\r\n\r\n    # Only download if file doesn't exist yet\r\n    if (-not (Test-Path -Path $scanFilePath -PathType Leaf))\r\n    {\r\n        Write-Host '[+] Downloading wsusscn2.cab (+/- 600MB), depending on your Internet speed this may take a while'\r\n\r\n        $ProgressPreference = 'SilentlyContinue'\r\n        Invoke-WebRequest 'http://download.windowsupdate.com/microsoftupdate/v6/wsusscan/wsusscn2.cab' -OutFile $scanFilePath -UseBasicParsing\r\n        $ProgressPreference = 'Continue'\r\n\r\n        Write-Host \"[+] Scanfile saved to '$scanFilePath'\"\r\n    }\r\n    # Scanfile already exists\r\n    elseif (-not $foundScanfile)\r\n    {\r\n        $objScanFile = Get-Item -Path $scanFilePath\r\n        Write-Host \"[+] File wsusscn2.cab already exists: '$scanFilePath'. Skipping download\"\r\n        Write-Host \"[I] Scanfile modification date: $($objScanFile.LastWriteTime.ToShortDateString())\"\r\n        $foundScanfile = $true\r\n        $Preserve = $true\r\n        $scanFileAge = (Get-Date) - $objScanFile.LastWriteTime\r\n        if ($scanFileAge.Days -gt 31)\r\n        {\r\n            Write-Host '[!] Scanfile is more than a month old, consider downloading the latest version for more accurate results' -ForegroundColor Yellow\r\n        }\r\n    }\r\n}\r\n# Display Windows Update/WSUS settings\r\nelse\r\n{\r\n    # UseWUServer\r\n    $dwUseWUServer = (Get-ItemProperty -Path 'HKLM:\\Software\\Policies\\Microsoft\\Windows\\WindowsUpdate\\AU' -Name 'UseWUServer' -ErrorAction SilentlyContinue).UseWUServer\r\n    if(-not $dwUseWUServer)\r\n    {\r\n        $dwUseWUServer = 0\r\n    }\r\n    \r\n    # WUServer\r\n    if ($dwUseWUServer -eq 0)\r\n    {\r\n        Write-Host '[I] Windows Update online is used'\r\n    }\r\n    else\r\n    {\r\n        $strWSUS = (Get-ItemProperty -Path 'HKLM:\\Software\\Policies\\Microsoft\\Windows\\WindowsUpdate' -Name 'WUServer' -ErrorAction SilentlyContinue).WUServer\r\n        if($strWSUS)\r\n        {\r\n            Write-Host \"[I] WSUS with URL '$strWSUS' is used\"\r\n        }\r\n        else\r\n        {\r\n            Write-Host '[I] WSUS is used, but the WSUS URL could not be read' -ForegroundColor Yellow\r\n        }\r\n        Write-Host '    Usage of WSUS may cause the missing KB information to be incomplete'\r\n        Write-Host '    To use Windows Update ''s online KB information, use the -Offline parameter'\r\n    }\r\n}\r\n\r\n# Skip checking the current system for missing KBs if the -DownloadOnly parameter is provided\r\nif ($DownloadOnly)\r\n{\r\n    Write-Host '[+] Done!'\r\n    exit\r\n}\r\n\r\n# Validate whether Windows Update (wuauserv) service is not disabled\r\n$wuauserv = Get-CimInstance -ClassName Win32_Service -Filter \"Name='wuauserv'\"\r\nif ($wuauserv.StartMode -eq 'Disabled')\r\n{\r\n    Write-Host \"[-] The 'Windows Update' service is disabled\" -ForegroundColor Red\r\n    exit\r\n}\r\n\r\n# Initialize Windows Update and identify missing KBs\r\nWrite-Host '[+] Identifying missing KBs...'\r\ntry\r\n{\r\n    $UpdateSession = New-Object -ComObject 'Microsoft.Update.Session'\r\n}\r\ncatch\r\n{\r\n    Write-Host \"[-] Error initializing Microsoft.Update.Session object: 0x$($Error[0].Exception.HResult.ToString(\"X\"))\" -ForegroundColor Red\r\n    if ($Error[0].Exception.HResult -eq 0x80040154)\r\n    {\r\n        Write-Host '    Windows Update Client API missing. Please install the Windows Update Agent' -ForegroundColor Yellow\r\n    }\r\n    exit\r\n}\r\n$UpdateServiceManager = New-Object -ComObject 'Microsoft.Update.ServiceManager'\r\n\r\n# Only use the scanfile in case of an offline scan\r\nif ($Offline)\r\n{\r\n    try\r\n    {\r\n        $UpdateService = $UpdateServiceManager.AddScanPackageService('Offline Sync Service', $scanFilePath, 1)\r\n    }\r\n    catch\r\n    {\r\n        Write-Host \"[-] Error initializing Windows Update service: 0x$($Error[0].Exception.HResult.ToString(\"X\"))\" -ForegroundColor Red\r\n        if ($Error[0].Exception.HResult -eq 0x80070005)\r\n        {\r\n            Write-Host '    Make sure to run this script as an elevated Administrator when running in Offline mode' -ForegroundColor Yellow\r\n        }\r\n        exit\r\n    }\r\n}\r\n\r\n$UpdateSearcher = $UpdateSession.CreateUpdateSearcher()\r\n\r\n# In case of online scan the ServerSelection and ServiceID don't need to be set\r\nif ($Offline)\r\n{\r\n    $UpdateSearcher.ServerSelection = 3 # ssOthers\r\n    $UpdateSearcher.ServiceID = $UpdateService.ServiceID\r\n}\r\n\r\n# Perform search for updates\r\ntry\r\n{\r\n    $SearchResult = $UpdateSearcher.Search('IsInstalled=0')\r\n}\r\ncatch\r\n{\r\n    Write-Host \"[-] Error searching for updates: 0x$($Error[0].Exception.HResult.ToString(\"X\"))\" -ForegroundColor Red\r\n    if ($Error[0].Exception.HResult -eq 0x8024402C)\r\n    {\r\n        Write-Host '    Make sure your computer is connected to the Internet' -ForegroundColor Yellow\r\n    }\r\n    exit\r\n}\r\n\r\n$updateCount = $SearchResult.Updates.Count\r\n\r\n# List updates\r\nif ($updateCount -eq 0)\r\n{\r\n    if ($specifiedScanfile)\r\n    {\r\n        Write-Host '[+] Based on the provided scanfile no missing KBs were found'\r\n    }\r\n    else\r\n    {\r\n        if ($foundScanfile)\r\n        {\r\n            Write-Host '[+] Based on the scanfile no missing KBs were found'\r\n        }\r\n        else\r\n        {\r\n            Write-Host '[+] There are no missing KBs'\r\n        }\r\n    }\r\n    exit\r\n}\r\n\r\n# Collect missing updates and show them on the screen\r\nWrite-Host '[+] List of missing KBs'\r\n$missingUpdates = @()\r\nfor ($i = 0; $i -lt $updateCount; $i++)\r\n{\r\n    $update = $SearchResult.Updates.Item($i)\r\n    for ($j = 0; $j -lt $update.KBArticleIDs.Count; $j++)\r\n    {\r\n        $articleId = $update.KBArticleIDs.Item($j)\r\n        $missingUpdates += \"KB$articleId\"\r\n        Write-Host \"- KB$($articleId): $($update.Title)\"\r\n    }\r\n}\r\n\r\n# Store list of missing KBs\r\n$missingUpdates | Out-File -FilePath $OutputFile -Encoding ASCII\r\nif($?)\r\n{\r\n    Write-Host \"[+] Saved list of missing updates in '$OutputFile'\"\r\n}\r\nelse\r\n{\r\n    Write-Host '[-] Error storing list of missing updates'\r\n}\r\n\r\n# Cleanup scanfile\r\nif ($Offline)\r\n{\r\n    if (-not $Preserve)\r\n    {\r\n        Write-Host '[+] Cleaning up wsusscn2.cab'\r\n        Remove-Item -Path $scanFilePath\r\n    }\r\n    else\r\n    {\r\n        Write-Host '[+] Skipping cleanup of the scanfile'\r\n    }\r\n}\r\n\r\nWrite-Host '[+] Done!'"
        },
        {
          "name": "missingkbs.vbs",
          "type": "blob",
          "size": 13.5810546875,
          "content": "' This software is provided under the BSD 3-Clause License.\r\n' See the accompanying LICENSE file for more information.\r\n'\r\n' Windows Exploit Suggester - Next Generation\r\n' Missing KBs Identifier utility\r\n'\r\n' Author: Arris Huijgen (@bitsadmin)\r\n' Website: https://github.com/bitsadmin\r\n\r\nOption Explicit\r\nOn Error Resume Next\r\n\r\n' Application information\r\nDim version : version   = 1.0\r\nDim appname : appname   = \"Windows Exploit Suggester: Missing KBs Identifier v\" & Replace(FormatNumber(version, 1), \",\", \".\")\r\nDim url     : url       = \"https://github.com/bitsadmin/wesng/\"\r\nDim banner  : banner    = appname & vbCrLf & _\r\n                          url & vbCrLf\r\n\r\n' Initialize\r\nDim fs: Set fs = CreateObject(\"Scripting.FileSystemObject\")\r\nDim shell: Set shell = CreateObject(\"WScript.Shell\")\r\n\r\n' Collect arguments\r\nDim args: Set args = WScript.Arguments.Named\r\n\r\n' Check if script is running in cscript (-1) or wscript (0)\r\nDim scriptHost: scriptHost = InStrRev(UCase(WScript.FullName), \"CSCRIPT\") <> 0\r\n\r\n' Show message if running in GUI mode\r\nIf scriptHost = 0 Then\r\n    MsgBox  banner & vbCrLf & _\r\n            \"Please run this script from the commandline using:\" & vbCrLf & vbCrLf & _\r\n            \"cscript.exe \" & Wscript.ScriptName, _\r\n            vbInformation, _\r\n            appname\r\n    WScript.Quit\r\nEnd If\r\n\r\n' Configure outputs\r\nDim stdOut: Set stdOut = WScript.StdOut\r\nDim StdErr: Set StdErr = WScript.StdErr\r\n\r\n' Show banner\r\nstdOut.Write banner & vbCrLf\r\n\r\n' Show help if requested\r\nIf args.Exists(\"?\") or args.Exists(\"Help\") Then\r\n    StdErr.Write \"Usage: \" & Wscript.ScriptName & \" [/F] [/I:[filename]] [/P] [/O:[filename]]\" & vbCrLf & vbCrLf\r\n    StdErr.Write \"Description:\"  & vbCrLf\r\n    StdErr.Write \"    Compiles a list of missing KBs on the current system.\" & vbCrLf\r\n    StdErr.Write \"    These missing KBs are determined based either the online\" & vbCrLf\r\n    StdErr.Write \"    Microsoft Update service or WSUS if configured, or on an offline\" & vbCrLf\r\n    StdErr.Write \"    scanfile (wsusscn2.cab). This scanfile is either provided in the\" & vbCrLf\r\n    StdErr.Write \"    commandline or downloaded from the Microsoft Update site.\" & vbCrLf\r\n    StdErr.Write \"    By default the online Microsoft Update service is used (or WSUS if configured).\" & vbCrLf & vbCrLf\r\n    StdErr.Write \"Parameter List:\" & vbCrLf\r\n    StdErr.Write \"    /F or /Offline  Perform an offline scan using a scanfile.\" & vbCrLf\r\n    StdErr.Write \"    /I:[filename]   Specify path to the scanfile (wsusscn2.cab). Implies /F and /P.\" & vbCrLf\r\n    StdErr.Write \"    /P              Preserve the scanfile.\" & vbCrLf\r\n    StdErr.Write \"    /O:[filename]   Specify filename to store the results in. By default the\" & vbCrLf\r\n    StdErr.Write \"                    file missing.txt in the current directory will be used.\" & vbCrLf\r\n    StdErr.Write \"    /D:[directory]  Just download the scanfile (don't check for missing KBs).\" & vbCrLf\r\n    StdErr.Write \"                    By default the file will be downloaded to the current directory.\" & vbCrLf\r\n    StdErr.Write \"    /? or /Help     Displays this help message.\" & vbCrLf & vbCrLf\r\n    StdErr.Write \"Examples:\" & vbCrLf\r\n    StdErr.Write \"    Determine missing KBs using online Microsoft Update service (or WSUS if configured)\" & vbCrLf\r\n    StdErr.Write \"    cscript.exe \" & Wscript.ScriptName & vbCrLf & vbCrLf\r\n    StdErr.Write \"    Determine missing KBs downloading the wsusscn2.cab scanfile and preserving it\" & vbCrLf\r\n    StdErr.Write \"    cscript.exe \" & Wscript.ScriptName & \" /F /P\" & vbCrLf & vbCrLf\r\n    StdErr.Write \"    Determine missing KBs using the offline wsusscn2.cab scanfile\" & vbCrLf\r\n    StdErr.Write \"    cscript.exe \" & Wscript.ScriptName & \" /F /I:E:\\tmp\\wsusscn2.cab\" & vbCrLf & vbCrLf\r\n    StdErr.Write \"    Determine missing KBs downloading the wsusscn2.cab scanfile saving results in out.txt\" & vbCrLf\r\n    StdErr.Write \"    cscript.exe \" & Wscript.ScriptName & \" /F /O:E:\\tmp\\out.txt\" & vbCrLf & vbCrLf\r\n    StdErr.Write \"    Download the scanfile to E:\\tmp\\\" & vbCrLf\r\n    StdErr.Write \"    cscript.exe \" & Wscript.ScriptName & \" /D:E:\\tmp\" & vbCrLf & vbCrLf\r\n    \r\n    WScript.Quit\r\nEnd If\r\n\r\n' Check if running elevated\r\n' Only when just downloading the scanfile, no elevation is required\r\nDim justDownload: justDownload = args.Exists(\"D\")\r\nIf not justDownload Then\r\n    shell.RegRead(\"HKEY_USERS\\s-1-5-19\\\")\r\n    If Err.Number <> 0 Then\r\n        stdErr.Write \"[-] This script needs to be executed as an elevated Administrator\" & vbCrLf\r\n        WScript.Quit\r\n    End If\r\nEnd If\r\n\r\n' Determine output file\r\nDim outputFile\r\nIf args.Exists(\"O\") Then\r\n    outputFile = fs.GetAbsolutePathName(args(\"O\"))\r\nElse\r\n    outputFile = fs.BuildPath(shell.CurrentDirectory, \"missing.txt\")\r\nEnd If\r\n\r\n' Online or offline scan?\r\nDim offlineMode: offlineMode = args.Exists(\"F\") Or args.Exists(\"Offline\") Or args.Exists(\"I\") Or args.Exists(\"D\")\r\nDim specifiedScanfile, foundScanfile, scanFile\r\n\r\n' Only check and download scanfile in case of offline scan\r\nIf offlineMode Then\r\n    ' Determine scanfile\r\n    Dim preserveFile, objScanFile, scanFileAge, targetDirectory\r\n    targetDirectory = shell.CurrentDirectory\r\n    \r\n    ' Only download the scanfile\r\n    If justDownload Then\r\n        ' Determine destination directory for download\r\n        targetDirectory = args(\"D\")\r\n        If Len(targetDirectory) = 0 Then\r\n            targetDirectory = shell.CurrentDirectory\r\n        End If\r\n        \r\n        If Not fs.FolderExists(targetDirectory) Then\r\n            stdErr.Write \"[-] Output directory \"\"\" & targetDirectory & \"\"\" does not exist\" & vbCrLf\r\n            WScript.Quit\r\n        End If\r\n        \r\n        ' Compile path for scanfile\r\n        scanFile = fs.BuildPath(targetDirectory, \"wsusscn2.cab\")\r\n    \r\n    ' Download and perform scan\r\n    Else\r\n        ' If scanfile /I parameter is not specified, check if it already exists\r\n        ' In case it doesn't exist, download it\r\n        specifiedScanfile = args.Exists(\"I\")\r\n        preserveFile = args.Exists(\"P\")\r\n        If specifiedScanfile Then\r\n            preserveFile = True\r\n            scanFile = args(\"I\")\r\n        Else\r\n            ' Determine if file needs to be preserved\r\n            If preserveFile Then\r\n                targetDirectory = shell.CurrentDirectory\r\n            Else\r\n                targetDirectory = fs.GetSpecialFolder(2) ' 2 = %tmp% folder\r\n            End If\r\n            \r\n            ' Compile path for scanfile\r\n            scanFile = fs.BuildPath(targetDirectory, \"wsusscn2.cab\")\r\n        End If\r\n        \r\n        ' Check if scanfile exists\r\n        If fs.FileExists(scanFile) Then\r\n            scanFile = fs.GetAbsolutePathName(scanFile)\r\n            Set objScanFile = fs.GetFile(scanFile)\r\n            stdOut.Write \"[+] Using scanfile \"\"\" & scanFile & \"\"\" with modification date \" & Split(objScanFile.DateLastModified)(0) & vbCrLf\r\n            foundScanfile = True\r\n        ElseIf specifiedScanfile Then\r\n            stdErr.Write \"[-] Scanfile \"\"\" & scanFile & \"\"\" does not exist\" & vbCrLf\r\n            WScript.Quit\r\n        End If\r\n    End If\r\n\r\n    ' Only download if file doesn't exist yet\r\n    If Not fs.FileExists(scanFile) Then\r\n        stdOut.Write \"[+] Downloading wsusscn2.cab (+/- 600 MB), depending on your Internet speed this may take a while\" & vbCrLf\r\n\r\n        ' Initialize HTTP object\r\n        Dim stream\r\n        Dim http: Set http = CreateObject(\"WinHttp.WinHttpRequest.5.1\")\r\n        If http Is Nothing Then Set http = CreateObject(\"WinHttp.WinHttpRequest\")\r\n        If http Is Nothing Then Set http = CreateObject(\"MSXML2.ServerXMLHTTP\")\r\n        If http Is Nothing Then Set http = CreateObject(\"Microsoft.XMLHTTP\")\r\n\r\n        ' Send request and store file\r\n        http.Open \"GET\", \"http://download.windowsupdate.com/microsoftupdate/v6/wsusscan/wsusscn2.cab\", False\r\n        http.Send\r\n        Set stream = CreateObject(\"Adodb.Stream\")\r\n        With stream\r\n            .Type = 1                   ' 1 = adTypeBinary\r\n            .Open\r\n            .Write http.ResponseBody\r\n            .SaveToFile scanFile, 2     ' 2 = adSaveCreateOverWrite\r\n        End With\r\n        stdOut.Write \"[+] Download saved to \"\"\" & scanFile & \"\"\"\" & vbCrLf\r\n    \r\n    ' Scanfile already exists\r\n    ElseIf Not foundScanfile Then\r\n        Set objScanFile = fs.GetFile(scanFile)\r\n        stdOut.Write \"[+] File wsusscn2.cab already exists: \"\"\" & scanFile & \"\"\". Skipping download\" & vbCrLf\r\n        stdOut.Write \"[I] Scanfile modification date: \" & Split(objScanFile.DateLastModified)(0) & vbCrLf\r\n        foundScanfile = True\r\n        preserveFile = True\r\n        scanFileAge = DateDiff(\"d\", objScanFile.DateLastModified, Now())\r\n        If scanFileAge > 31 Then\r\n            stdOut.Write \"[!] Scanfile is more than a month old, consider downloading the latest version for more accurate results\" & vbCrLf\r\n        End If\r\n    End If\r\n\r\n' Show Windows Update/WSUS settings\r\nElse\r\n    Dim dwUseWUServer: dwUseWUServer = shell.RegRead(\"HKEY_LOCAL_MACHINE\\Software\\Policies\\Microsoft\\Windows\\WindowsUpdate\\AU\\UseWUServer\")\r\n    If err.number <> 0 Or dwUseWUServer = 0 Then\r\n        stdOut.Write \"[I] Windows Update online is used\" & vbCrLf\r\n        Err.Clear\r\n    Else\r\n        Dim strWSUS: strWSUS = shell.RegRead(\"HKEY_LOCAL_MACHINE\\Software\\Policies\\Microsoft\\Windows\\WindowsUpdate\\WUServer\")\r\n        If err.number <> 0 Then\r\n            stdOut.Write \"[I] WSUS is used, but the WSUS URL could not be read\" & vbCrLf\r\n            Err.Clear\r\n        Else\r\n            stdOut.Write \"[I] WSUS with URL \"\"\" & strWSUS & \"\"\" is used\" & vbCrLf\r\n        End if\r\n        stdOut.Write \"    Usage of WSUS may cause the missing KB information to be incomplete\" & vbCrLf\r\n        stdOut.Write \"    To use Windows Update's online KB information, use the /F parameter\" & vbCrLf\r\n    End If\r\nEnd If\r\n\r\n' Skip checking the current system for missing KBs if the /D parameter is provided\r\nIf justDownload Then\r\n    stdOut.Write \"[+] Done!\" & vbCrLf\r\n    WScript.Quit\r\nEnd If\r\n\r\n' Validate whether Windows Update (wuauserv) service is not disabled\r\nDim wmi: Set wmi = GetObject(\"winmgmts://./ROOT/CIMv2\")\r\nDim wuauserv: Set wuauserv = wmi.Get(\"Win32_Service.Name='wuauserv'\")\r\nIf wuauserv.StartMode = \"Disabled\" Then\r\n    stdErr.Write \"[-] The \"\"Windows Update\"\" service is disabled\" & vbCrLf\r\n    WScript.Quit\r\nEnd If\r\n\r\n' Initialize Windows Update and identify missing KBs\r\nstdOut.Write \"[+] Identifying missing KBs...\" & vbCrLf\r\nDim UpdateSession: Set UpdateSession = CreateObject(\"Microsoft.Update.Session\")\r\nIf Err.Number <> 0 Then\r\n    stdErr.Write \"[-] Error initializing Microsoft.Update.Session object: 0x\" & Hex(Err.Number) & vbCrLf\r\n    If Err.Number = 429 Then\r\n        stdOut.Write \"    Windows Update Client API missing. Please install the Windows Update Agent\" & vbCrLf\r\n    End If\r\n    WScript.Quit\r\nEnd If\r\nDim UpdateServiceManager: Set UpdateServiceManager = CreateObject(\"Microsoft.Update.ServiceManager\")\r\nIf Err.Number <> 0 Then\r\n    stdErr.Write \"[-] Error initializing Microsoft.Update.ServiceManager object: 0x\" & Hex(Err.Number) & vbCrLf\r\n    WScript.Quit\r\nEnd If\r\n\r\n' Only use the scanfile in case of an offline scan\r\nIf offlineMode Then\r\n    Dim UpdateService: Set UpdateService = UpdateServiceManager.AddScanPackageService(\"Offline Sync Service\", scanFile, 1) ' 1 = usoNonVolatileService\r\n    If Err.Number <> 0 Then\r\n        stdErr.Write \"[-] Error initializing Windows Update service: 0x\" & Hex(Err.Number) & vbCrLf\r\n        If Err.Number = 70 Then\r\n            stdOut.Write \"    Make sure to run this script as an elevated Administrator\" & vbCrLf\r\n        End If\r\n        WScript.Quit\r\n    End If\r\nEnd If\r\n\r\nDim UpdateSearcher: Set UpdateSearcher = UpdateSession.CreateUpdateSearcher()\r\n\r\n' In case of online scan the ServerSelection and ServiceID don't need to be set\r\nIf offlineMode Then\r\n    UpdateSearcher.ServerSelection = 3 ' 3 = ssOthers\r\n    UpdateSearcher.ServiceID = UpdateService.ServiceID\r\nEnd If\r\n\r\nDim SearchResult: Set SearchResult = UpdateSearcher.Search(\"IsInstalled=0\")\r\nDim updateCount: updateCount = searchResult.Updates.Count\r\n\r\n' List updates\r\nIf updateCount = 0 Then\r\n    If specifiedScanfile Then\r\n        stdOut.Write \"[+] Based on the provided scanfile no missing KBs were found\"\r\n    Else\r\n        If foundScanfile Then\r\n            stdOut.Write \"[+] Based on the scanfile no missing KBs were found\"\r\n        Else\r\n            stdOut.Write \"[+] There are no missing KBs\"\r\n        End If\r\n    End If\r\n    WScript.Quit\r\nEnd If\r\n\r\n' Collect missing updates and show them on the screen\r\nstdOut.Write \"[+] List of missing KBs\" & vbCrLf\r\nDim i, j, u, update, articleId\r\nDim missingUpdates(): Redim missingUpdates(updateCount)\r\nu = 0\r\nFor i = 0 to updateCount-1\r\n    Set update = searchResult.Updates.Item(i)\r\n    For j = 0 to update.KBArticleIDs.Count-1\r\n        ' Expand array if needed\r\n        If u > UBound(missingUpdates) Then\r\n            ReDim Preserve missingUpdates(UBound(missingUpdates) + 1)\r\n        End If\r\n        \r\n        ' Store KB in array\r\n        articleId = update.KBArticleIDs.Item(j)\r\n        missingUpdates(u) = \"KB\" & articleId\r\n        \r\n        ' Output to console\r\n        stdOut.Write \"- KB\" & articleId & \": \" & update.Title & vbCrLf\r\n        \r\n        ' Increase index\r\n        u = u + 1\r\n    Next\r\nNext\r\n\r\n' Store list of missing KBs\r\nDim missingFile: Set missingFile = fs.CreateTextFile(outputFile, True)\r\nmissingFile.Write Join(missingUpdates, vbCrLf)\r\nmissingFile.Close\r\nstdOut.Write \"[+] Saved list of missing updates in \"\"\" & outputFile & \"\"\"\" & vbCrLf\r\n\r\n' Cleanup scanfile\r\nIf offlineMode Then\r\n    If Not preserveFile Then\r\n        stdOut.Write \"[+] Cleaning up wssuscan.cab\" & vbCrLf\r\n        fs.DeleteFile scanFile\r\n    Else\r\n        stdOut.Write \"[+] Skipping cleanup of the scanfile\" & vbCrLf\r\n    End If \r\nEnd If\r\n\r\nstdOut.Write \"[+] Done!\" & vbCrLf\r\nWScript.Quit\r\n"
        },
        {
          "name": "muc_lookup.py",
          "type": "blob",
          "size": 6.1357421875,
          "content": "#!/usr/bin/python3\n#\n# This software is provided under the BSD 3-Clause License.\n# See the accompanying LICENSE file for more information.\n#\n# Windows Exploit Suggester - Next Generation\n#\n# Author: Arris Huijgen (@bitsadmin)\n# Website: https://github.com/bitsadmin\n# \n# Microsoft Update Catalog lookup feature developed by Dominic Breuker\n# Website: https://github.com/DominicBreuker\n\nfrom __future__ import print_function\n\nimport sys, os\nimport logging\nimport re\n\n# Python 2 compatibility\nif sys.version_info.major == 2:\n    ModuleNotFoundError = ImportError\n\n# By default show plain output without color\ndef colored(text, color):\n    return text\n\n# Check availability of mechanicalsoup library\ntry:\n    import mechanicalsoup\nexcept ImportError:\n    print(colored(\"[!] Cannot lookup superseded KBs in the Microsoft Update Catalog!\", \"yellow\"))\n    logging.warning('mechanicalsoup module not installed. Install mechanicalsoup using: pip{} install mechanicalsoup'.format(sys.version_info.major))\n    sys.exit(1)\n\n\n# Progress is a simple progress bar\nclass Progress:\n    # __init__ creates a new progress bar\n    # it starts printing immediately, so create it the moment you\n    # want to display it\n    #\n    # name: a human readable name of the progress bar\n    # width: the number of steps needed to progress\n    def __init__(self, name=\"\", width=40):\n        self.name = name\n        self.width = width\n        self.progress = 0\n\n        sys.stdout.write(\"{} [{}]\".format(self.name, \" \" * self.width))\n        sys.stdout.flush()\n        sys.stdout.write(\"\\b\" * (self.width + 1))\n\n    # step moves progress forward\n    def step(self):\n        if self.progress >= self.width:\n            return\n\n        sys.stdout.write(\".\")\n        sys.stdout.flush()\n        self.progress += 1\n\n    # finish terminates the progress bar\n    #\n    # msg: a message to append to the output\n    def finish(self, msg=\"\"):\n        sys.stdout.write(\"] \" + msg + \"\\n\")\n\n\n# some header values Mirosoft seems to like in the header (not extensively tested)\ndefault_headers = {\n    \"authority\": \"www.catalog.update.microsoft.com\",\n    \"user-agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.90 Safari/537.36\",\n    \"sec-fetch-mode\": \"navigate\",\n    \"sec-fetch-user\": \"?1\",\n    \"sec-fetch-site\": \"none\",\n}\n\n# global browser used to scrape the Microsoft Update Catalog\nbrowser = mechanicalsoup.StatefulBrowser()\n\n# global dict of KBs with their superseding KBs\nsuperseded_by = {}\n\n# apply_muc_filter filters the CVEs found by looking up superseded hotfixes in the\n# Microsoft Update Catalog. It returns the CVE iff no superseded hotfixes are installed.\n#\n# found: list of CVEs as created by the main script wes.py\n# kbs_installed: list of installed hotfixes as seen in systeminfo output\ndef apply_muc_filter(found, kbs_installed):\n    if not found:\n        return []\n\n    if not kbs_installed:\n        kbs_installed = []\n\n    kbs_installed = set(kbs_installed)\n\n    global superseded_by\n    for cve in found:\n        kb = cve[\"BulletinKB\"]\n        if kb not in superseded_by:\n            superseded_by[kb] = set(lookup_supersedence(kb))\n\n    return [\n        cve\n        for cve in found\n        if not (superseded_by[cve[\"BulletinKB\"]] & kbs_installed)\n    ]\n\n\n# lookup_supersedence returns a list of all KBs superseded the given KB\n# iterates over entries for all Mirosoft products. That is, it does not\n# attempt to identify the product. My assumption is that if we return KBs\n# that do not apply to the system under anaylsis then this KB will not be\n# present on that system so that the result remains the same.\n# For example, if we return a KB only applicable to Windows Server 2016,\n# not to Windows 10, then this KB will not be installed on the system\n# and accordingly the CVE will not be filtered.\n#\n# kb: the KB to be looked up\ndef lookup_supersedence(kb):\n    try:\n        browser.open(\n            \"https://www.catalog.update.microsoft.com/Search.aspx?q={}\".format(kb),\n            headers=default_headers,\n        )\n        rows = browser.get_current_page().find(id=\"ctl00_catalogBody_updateMatches\")\n        if rows is None:\n            return []\n        updates = rows.find_all(\n            \"a\", {\"onclick\": re.compile(r\"goToDetails\\(\\\"[a-zA-Z0-9-]+\\\"\\)\")}\n        )\n        ids = [a[\"id\"].split(\"_\")[0] for a in updates]\n\n        kbids = set()\n        p = Progress(\n            name = \"\\t- Looking up potentially missing KB%s \" % (kb),\n            width = len(ids),\n        )\n        for uid in ids:\n            kbids = kbids.union(lookup_supersedence_by_uid(uid))\n            p.step()\n        found_kbids = colored(\"[\" + \", \".join(kbids) + \"]\", \"yellow\")\n        if len(kbids) == 0:\n            p.finish(msg=colored(\"No superseded KB's found\", \"cyan\"))\n        else:\n            p.finish(msg=colored(\"\\n\\t\\tFound: \", \"green\") + \"%s\" % (found_kbids))\n\n        return [kbid.lstrip(\"KB\") for kbid in kbids]\n    except KeyboardInterrupt:\n        print(colored(\"\\nKeyboardInterrupt caught.  Exiting!\", \"cyan\"))\n        exit()\n\n\n# lookup_supersedence_by_uid looks up a list of superseded KBs for a\n# Microsoft Update ID. The Microsoft Update Catalog seems to close over\n# transitive supersedence relationships so there is not need for recursive\n# lookups.\n#\n# uid: the Microsoft Update ID of the update to check\ndef lookup_supersedence_by_uid(uid):\n    browser.open(\n        \"https://www.catalog.update.microsoft.com/ScopedViewInline.aspx?updateid={}\".format(\n            uid\n        ),\n        headers=default_headers,\n    )\n    supers = browser.get_current_page().find_all(\"div\", {\"id\": \"supersededbyInfo\"})\n    if len(supers) != 1:\n        return set()\n\n    s = supers[0]\n    kbids = re.findall(\"(KB[0-9]+)\", s.text.strip())\n    if len(kbids) < 1:\n        kbids = []\n    return set(kbids)\n\n\n# can also run standalone to check single KB\nif __name__ == \"__main__\":\n    if len(sys.argv) != 2:\n        print(\"Run this script with a Microsoft HotfixID as the single argument\")\n        print(\"Example: python muc_lookup.py KB4515384\")\n        sys.exit(1)\n\n    kb = re.sub('KB', '', sys.argv[1], flags=re.IGNORECASE)\n    kbids = lookup_supersedence(kb)\n    print(\"{} is superseded by {}\".format(kb, [\"KB{}\".format(kbid) for kbid in kbids]))\n"
        },
        {
          "name": "setup.py",
          "type": "blob",
          "size": 1.875,
          "content": "#!/usr/bin/env python3\n\nfrom setuptools import setup\nfrom os import path\nfrom io import open\n\nhere = path.abspath(path.dirname(__file__))\n\nwith open(path.join(here, 'README.md'), encoding='utf-8') as f:\n    long_description = f.read()\n\nsetup(\n    name='wesng',\n    version='1.0.3',\n    description='WES-NG is a tool based on the output of Windows\\' systeminfo'\n    ' utility which provides the list of vulnerabilities the OS is vulnerable'\n    ' to, including any exploits for these vulnerabilities.',\n    long_description=long_description,\n    long_description_content_type='text/markdown',\n    url='https://github.com/bitsadmin/wesng',\n    author='Arris Huijgen (@bitsadmin)',\n    classifiers=[\n        'Development Status :: 5 - Production/Stable',\n        'Intended Audience :: Information Technology',\n        'Intended Audience :: System Administrators',\n        'Topic :: Security',\n        'License :: OSI Approved :: BSD License',\n        'Programming Language :: Python :: 2',\n        'Programming Language :: Python :: 2.7',\n        'Programming Language :: Python :: 3',\n        'Programming Language :: Python :: 3.4',\n        'Programming Language :: Python :: 3.5',\n        'Programming Language :: Python :: 3.6',\n        'Programming Language :: Python :: 3.7',\n        'Programming Language :: Python :: 3.8',\n        'Programming Language :: Python :: 3.9',\n        'Programming Language :: Python :: 3.10',\n        'Programming Language :: Python :: 3.11',\n    ],\n    py_modules=['wes', 'muc_lookup'],\n    python_requires='>=3.4, >=2.7',\n    install_requires=['chardet'],\n    package_data={\n        'definitions': ['definitions.zip']\n    },\n    entry_points={\n        'console_scripts': [\n            'wes=wes:main',\n        ],\n    },\n    project_urls={  # Optional\n        'Bug Reports': 'https://github.com/bitsadmin/wesng/issues',\n        'Source': 'https://github.com/bitsadmin/wesng/',\n    },\n)\n"
        },
        {
          "name": "validation",
          "type": "tree",
          "content": null
        },
        {
          "name": "wes.py",
          "type": "blob",
          "size": 40.48828125,
          "content": "#!/usr/bin/python3\n#\n# This software is provided under the BSD 3-Clause License.\n# See the accompanying LICENSE file for more information.\n#\n# Windows Exploit Suggester - Next Generation\n#\n# Author: Arris Huijgen (@bitsadmin)\n# Website: https://github.com/bitsadmin\n\nfrom __future__ import print_function\n\nimport sys, csv, re, argparse, os, zipfile, io\nimport logging\nfrom collections import Counter, OrderedDict\nimport copy\n\n\n# Python 2 compatibility\nif sys.version_info.major == 2:\n    from urllib import urlretrieve\n    ModuleNotFoundError = ImportError\nelse:\n    from urllib.request import urlretrieve\n\n\n# Check availability of the chardet library:\n# \"The universal character encoding detector\"\ntry:\n    import chardet\n    # Using chardet library to determine the approperiate encoding\n    def charset_convert(data):\n        encoding = chardet.detect(data)\n        data = data.decode(encoding['encoding'], 'ignore')\n\n        if sys.version_info.major == 2:\n            data = data.encode(sys.getfilesystemencoding())\n\n        return data\n\nexcept (ImportError, ModuleNotFoundError):\n    # Parse everything as ASCII\n    def charset_convert(data):\n        data = data.decode('ascii', 'ignore')\n\n        if sys.version_info.major == 2:\n            data = data.encode(sys.getfilesystemencoding())\n\n        return data\n\n    logging.warning(\n        'chardet module not installed. In case of encoding '\n        'errors, install chardet using: pip{} install chardet'.format(sys.version_info.major))\n\n\n# By default show plain output without color\ndef colored(text, color):\n    return text\n\n\ndef configure_color():\n    # Check availability of the termcolor library\n    try:\n        global colored\n        from termcolor import colored\n\n    except (ImportError, ModuleNotFoundError):\n        logging.warning('termcolor module not installed. To show colored output, '\n                        'install termcolor using: pip{} install termcolor'.format(sys.version_info.major))\n        pass\n\n    # Also check availability of the colorama library in case of Windows\n    try:\n        if os.name == 'nt':\n            import colorama\n            colorama.init()\n    except (ImportError, ModuleNotFoundError):\n        logging.warning('colorama module not installed. To show colored output in Windows, '\n                        'install colorama using: pip{} install colorama'.format(sys.version_info.major))\n        pass\n\n\nclass WesException(Exception):\n    pass\n\n\n# Application details\nTITLE = 'Windows Exploit Suggester'\nVERSION = 1.05\nRELEASE = ''\nWEB_URL = 'https://github.com/bitsadmin/wesng/'\nBANNER = '%s %s ( %s )'\nFILENAME = 'wes.py'\n\n# Mapping table between build numbers and versions to correctly identify\n# the Windows 10/11/Server 2016/2019/2022 version specified in the systeminfo output\nbuildnumbers = OrderedDict([\n    (10240, 1507),\n    (10586, 1511),\n    (14393, 1607),\n    (15063, 1703),\n    (16299, 1709),\n    (17134, 1803),\n    (17763, 1809),\n    (18362, 1903),\n    (18363, 1909),\n    (19041, 2004),\n    (19042, '20H2'),\n    (19043, '21H1'),\n    (19044, '21H2'), # Windows 10\n    (19045, '22H2'),\n    (20348, '21H2'), # Windows Server 2022\n    (22000, '21H2'), # Windows 11\n    (22621, '22H2'),\n    (22631, '23H2'),\n    (26100, '24H2')\n])\n\n\ndef main():\n    args = parse_arguments()\n\n    # Configure output coloring\n    if hasattr(args, 'showcolor') and args.showcolor:\n        configure_color()\n\n    # Application banner\n    print(BANNER % (colored(TITLE, 'green'), colored('%.2f' % VERSION, 'yellow'), colored(WEB_URL, 'blue')))\n\n    # Update definitions\n    if hasattr(args, 'perform_update') and args.perform_update:\n        print(colored('[+] Updating definitions', 'green'))\n        urlretrieve('https://raw.githubusercontent.com/bitsadmin/wesng/master/definitions.zip', 'definitions.zip')\n        cves, date = load_definitions('definitions.zip')\n        print(colored('[+] Obtained definitions created at ', 'green') + '%s' % colored(date, 'yellow'))\n        return\n\n    # Update application\n    if hasattr(args, 'perform_wesupdate') and args.perform_wesupdate:\n        print(colored('[+] Updating wes.py', 'green'))\n        urlretrieve('https://raw.githubusercontent.com/bitsadmin/wesng/master/wes.py', 'wes.py')\n        print(colored('[+] Updated to the latest version. Relaunch wes.py to use.', 'green'))\n        return\n\n    # Show tree of supersedes (for debugging purposes)\n    if hasattr(args, 'debugsupersedes') and args.debugsupersedes:\n        cves, date = load_definitions('definitions.zip')\n        productfilter = args.debugsupersedes[0]\n        supersedes = args.debugsupersedes[1:]\n        filtered = []\n        for cve in cves:\n            if productfilter not in cve['AffectedProduct']:\n                continue\n\n            filtered.append(cve)\n\n        debug_supersedes(filtered, supersedes, 0, args.verbosesupersedes)\n        return\n\n    # Show version\n    if hasattr(args, 'showversion') and args.showversion:\n        cves, date = load_definitions('definitions.zip')\n        print('Wes.py version: %.2f' % VERSION)\n        print('Database version: %s' % date)\n        return\n\n    # Using the list of missing patches as a base\n    if hasattr(args, 'missingpatches') and args.missingpatches:\n        print(colored('[+] Loading definitions', 'green'))\n        cves, date = load_definitions('definitions.zip')\n\n        # Obtain IDs of missing patches from file\n        print(colored('[+] Loading missing patches from file', 'green'))\n        missingpatches = []\n        with open(args.missingpatches, 'r') as f:\n            missingpatches = f.read()\n        missingpatches = list(filter(None, [mp.upper().replace('KB', '') for mp in missingpatches.splitlines()]))\n\n        # Obtain all records matching the IDs of the missing patches\n        found = list(filter(lambda c: c['BulletinKB'] in missingpatches, cves))\n        os_names, os_name = get_operatingsystems(found, args.operating_system)\n\n        # Perform filter on operating system\n        if os_name:\n            print(colored('[+] Filtering vulnerabilities for \"%s\"' % os_name, 'green'))\n            found = list(filter(lambda c: os_name in c['AffectedProduct'], found))\n\n        # Deduplicate results ignoring differences in the Supersedes attribute\n        for f in found:\n            f['Supersedes'] = ''\n        found = [dict(t) for t in {tuple([t for t in d.items()]) for d in found}]\n\n        # Append missing patches from missing.txt which are not included in the definitions.zip\n        foundkbs = set([kb['BulletinKB'] for kb in found])\n        difference = foundkbs.symmetric_difference(missingpatches)\n        for diff in difference:\n            found.append({'DatePosted': '', 'CVE': '', 'BulletinKB': diff, 'Title': '', 'AffectedProduct': '',\n                          'AffectedComponent': '', 'Severity': '', 'Impact': '', 'Supersedes': '', 'Exploits': ''})\n\n        if os_name and 'Windows Server' in os_name:\n            print(colored('[+] Filtering duplicate vulnerabilities', 'green'))\n            found = filter_duplicates(found)\n\n        # Prepare variables for summary\n        sp = None\n        kbs = found\n\n    # Using systeminfo.txt or qfe.txt with list of installed patches as a base\n    else:\n        missingpatches = None\n        cves = None\n        os_names = None\n\n        # Use input from qfe\n        if hasattr(args, 'qfefile') and args.qfefile:\n            # If an operating_system digit is provided or no OS has been provided, load defitions to\n            # respectively retrieve the OS or show the list of OSs\n            if (hasattr(args, 'operating_system') and args.operating_system and args.operating_system.isdigit()) or \\\n                    (not hasattr(args, 'operating_system') or not args.operating_system):\n\n                # Load definitions to compile list of OSs\n                print(colored('[+] Loading definitions', 'green'))\n                cves, date = load_definitions(args.definitions)\n                print('    - Creation date of definitions: %s' % date)\n\n            # Propose/select OS name\n            os_names, os_name = get_operatingsystems(cves, args.operating_system)\n            if not args.operating_system:\n                # Print possible operating systems\n                list_operatingsystems(os_names)\n\n                # Quit script\n                print(colored('[I] Rerun the script providing the --os parameter and the index or name of the OS you want to filter on.', 'yellow'))\n                exit(0)\n            else:\n                productfilter = os_name\n\n            # Read KBs from QFE file\n            print(colored('[+] Parsing quick fix engineering (qfe) output', 'green'))\n            with open(args.qfefile, 'rb') as f:\n                qfe_data = f.read()\n            qfe_data = charset_convert(qfe_data)\n            hotfixes = get_hotfixes(qfe_data)\n\n        # Parse encoding of systeminfo.txt input\n        else:\n            print(colored('[+] Parsing systeminfo output', 'green'))\n            systeminfo_data = open(args.systeminfo, 'rb').read()\n            try:\n                productfilter, win, mybuild, version, arch, hotfixes = determine_product(systeminfo_data)\n            except WesException as e:\n                print(colored('[-] ' + str(e), 'red'))\n                exit(1)\n\n        # Add explicitly specified patches\n        manual_hotfixes = list(set([patch.upper().replace('KB', '') for patch in args.installedpatch]))\n\n        # Display summary\n        # OS info\n        info = colored('[+] Operating System', 'green')\n        if hasattr(args, 'systeminfo') and args.systeminfo:\n            info += ('\\n'\n                     '    - Name: %s\\n'\n                     '    - Generation: %s\\n'\n                     '    - Build: %s\\n'\n                     '    - Version: %s\\n'\n                     '    - Architecture: %s') % (productfilter, win, mybuild, version, arch)\n        elif os_name:\n            info += '\\n    - Selected Operating System: %s' % os_name\n\n        # Hotfixes\n        if hotfixes:\n            info += '\\n    - Installed hotfixes (%d): %s' % (len(hotfixes), ', '.join(['KB%s' % kb for kb in hotfixes]))\n        else:\n            info += '\\n    - Installed hotfixes: None'\n        if manual_hotfixes:\n            info += '\\n    - Manually specified hotfixes (%d): %s' % (len(manual_hotfixes),\n                                                                      ', '.join(['KB%s' % kb for kb in manual_hotfixes]))\n        print(info)\n\n        # Append manually specified KBs to list of hotfixes\n        hotfixes = list(set(hotfixes + manual_hotfixes))\n        hotfixes_orig = copy.deepcopy(hotfixes)\n\n        # Load definitions from definitions.zip (default) or user-provided location\n        # Only in case they haven't been loaded yet when the --qfe parameter has been provided\n        if not cves:\n            print(colored('[+] Loading definitions', 'green'))\n            cves, date = load_definitions(args.definitions)\n            print('    - Creation date of definitions: %s' % date)\n\n        # Determine missing patches\n        try:\n            print(colored('[+] Determining missing patches', 'green'))\n            filtered, found = determine_missing_patches(productfilter, cves, hotfixes)\n        except WesException as e:\n            print(colored('[-] ' + str(e), 'red'))\n            exit(1)\n\n        # If -d parameter is specified, use the most recent patch installed as\n        # reference point for the system's patching status\n        if args.usekbdate:\n            print(colored('[+] Filtering old vulnerabilities', 'green'))\n            recentkb = get_most_recent_kb(found)\n            if recentkb:\n                print('    - Most recent KB installed is KB%s released at %s\\n'\n                      '    - Filtering all KBs released before this date' % (recentkb['BulletinKB'], recentkb['DatePosted']))\n                recentdate = int(recentkb['DatePosted'])\n                found = list(filter(lambda kb: int(kb['DatePosted']) >= recentdate, found))\n\n        if 'Windows Server' in productfilter:\n            print(colored('[+] Filtering duplicate vulnerabilities', 'green'))\n            found = filter_duplicates(found)\n\n    # If specified, hide results containing the user-specified string\n    # in the AffectedComponent and AffectedProduct attributes\n    if args.hiddenvuln or args.only_exploits or args.impacts or args.severities:\n        print(colored('[+] Applying display filters', 'green'))\n        filtered = apply_display_filters(found, args.hiddenvuln, args.only_exploits, args.impacts, args.severities)\n    else:\n        filtered = found\n\n    # In case the list of missing patches is specified,\n    # we don't need to search for supersedes in the MS Update Catalog\n    if not args.missingpatches:\n        # If specified, lookup superseded KBs in the Microsoft Update Catalog\n        # and remove CVEs if a superseded KB is installed.\n        if args.muc_lookup:\n            from muc_lookup import apply_muc_filter # ony import if necessary since it needs MechanicalSoup\n\n            print(colored('[!] Looking up superseded hotfixes in the Microsoft Update Catalog', 'yellow'))\n            filtered = apply_muc_filter(filtered, hotfixes_orig)\n\n        # Split up list of KBs and the potential Service Packs/Cumulative updates available\n        kbs, sp = get_patches_servicepacks(filtered, cves, productfilter)\n\n    # Display results\n    if len(filtered) > 0:\n        print(colored('[!] Found vulnerabilities!', 'yellow'))\n        if args.outputfile:\n            store_results(args.outputfile, filtered)\n            verb = 'Saved'\n            print_summary(kbs, sp)\n        else:\n            print_results(filtered)\n            verb = 'Displaying'\n            print_summary(kbs, sp)\n\n        if not args.operating_system and os_names and len(os_names) > 1:\n            # Print possible operating systems\n            list_operatingsystems(os_names)\n\n            print(colored('[I] Additional filter can be applied using the --os parameter', 'yellow'))\n\n        print(colored('[+] Done. ', 'green') + '%s %s of the %s vulnerabilities found.' % (verb, colored(len(filtered), 'yellow'), colored(len(found), 'yellow')))\n    else:\n        print(colored('[-] Done. No vulnerabilities found\\n', 'green'))\n\n\n# Load definitions.zip containing a CSV with vulnerabilities collected by the WES collector module\n# and a file determining the minimum wes.py version the definitions are compatible with.\ndef load_definitions(definitions):\n    with zipfile.ZipFile(definitions, 'r') as definitionszip:\n        files = definitionszip.namelist()\n\n        # Version_X.XX.txt\n        versions = list(filter(lambda f: f.startswith('Version'), files))\n        versionsfile = versions[0]\n        dbversion = float(re.search(r'Version_(.*)\\.txt', versionsfile, re.MULTILINE | re.IGNORECASE).group(1))\n\n        if dbversion > VERSION:\n            raise WesException(\n                'Definitions require at least version %.2f of wes.py. '\n                'Please update using wes.py --update-wes.' % dbversion)\n\n        # CVEs_yyyyMMdd.csv\n        # DatePosted,CVE,BulletinKB,Title,AffectedProduct,AffectedComponent,Severity,Impact,Supersedes,Exploits\n        cvesfiles = list(filter(lambda f: f.startswith('CVEs'), files))\n        cvesfile = cvesfiles[0]\n        cvesdate = cvesfile.split('.')[0].split('_')[1]\n        f = io.TextIOWrapper(definitionszip.open(cvesfile, 'r'))\n        cves = csv.DictReader(filter(lambda row: row[0] != '#', f), delimiter=str(','), quotechar=str('\"'))\n\n        # Custom_yyyyMMdd.csv\n        customfiles = list(filter(lambda f: f.startswith('Custom'), files))\n        customfile = customfiles[0]\n        f = io.TextIOWrapper(definitionszip.open(customfile, 'r'))\n        custom = csv.DictReader(filter(lambda row: row[0] != '#', f), delimiter=str(','), quotechar=str('\"'))\n\n        # Merge official and custom list of CVEs\n        merged = [cve for cve in cves] + [c for c in custom]\n\n        return merged, cvesdate\n\n\n# Hide results based on filter(s) specified by the user. This can either be to only display results with\n# public exploits, results with a given impact or results containing the user specified string(s) in\n# the AffectedComponent or AffectedProduct attributes.\ndef apply_display_filters(found, hiddenvulns, only_exploits, impacts, severities):\n    # --hide 'Product 1' 'Product 2'\n    hiddenvulns = list(map(lambda s: s.lower(), hiddenvulns))\n    impacts = list(map(lambda s: s.lower(), impacts))\n    severities = list(map(lambda s: s.lower(), severities))\n    filtered = []\n    for cve in found:\n        add = True\n        for hidden in hiddenvulns:\n            if hidden in cve['AffectedComponent'].lower() or hidden in cve['AffectedProduct'].lower() or hidden in cve['Title'].lower():\n                add = False\n                break\n\n        for impact in impacts:\n            if not impact in cve['Impact'].lower():\n                add = False\n            else:\n                add = True\n                break\n\n        for severity in severities:\n            if not severity in cve['Severity'].lower():\n                add = False\n            else:\n                add = True\n                break\n\n        if add:\n            filtered.append(cve)\n\n    # --exploits-only\n    if only_exploits:\n        filtered = list(filter(lambda res: res['Exploits'], filtered))\n\n    return filtered\n\n\n# Filter duplicate CVEs for the Windows Server operating systems which often have a\n# 'Windows Server 2XXX' and a 'Windows Server 2XXX (Server Core installation)' CVE that are exactly the same\ndef filter_duplicates(found):\n    cves = list(set([cve['CVE'] for cve in found]))\n    newfound = []\n\n    # Iterate over unique CVEs\n    for cve in cves:\n        coreresults = list(filter(lambda cr: cr['CVE'] == cve and 'Server Core' in cr['AffectedProduct'], found))\n\n        # If no 'Server Core' results for CVE, just add all records matching the CVE\n        if len(coreresults) == 0:\n            normalresults = list(filter(lambda nr: nr['CVE'] == cve, found))\n            for n in normalresults:\n                newfound.append(n)\n            continue\n\n        # In case 'Server Core' records are found, identify matching non-core results\n        for r in coreresults:\n            regularcounterparts = list(filter(lambda c:\n                                              'Server Core' not in c['AffectedProduct'] and\n                                              c['CVE'] == r['CVE'] and\n                                              c['BulletinKB'] == r['BulletinKB'] and\n                                              c['Title'] == r['Title'] and\n                                              c['AffectedComponent'] == r['AffectedComponent'] and\n                                              c['Severity'] == r['Severity'] and\n                                              c['Impact'] == r['Impact'] and\n                                              c['Exploits'] == r['Exploits'], found))\n\n            # If non-'Server Core' counterparts are found, add these\n            if len(regularcounterparts) >= 1:\n                for rc in regularcounterparts:\n                    newfound.append(rc)\n            # Otherwise, add the 'Server Core' CVE\n            else:\n                newfound.append(r)\n\n    return newfound\n\n\n# Filter CVEs that are applicable to this system\ndef determine_missing_patches(productfilter, cves, hotfixes):\n    filtered = []\n\n    # Product with a Service Pack\n    if 'Service Pack' in productfilter:\n        for cve in cves:\n            if productfilter not in cve['AffectedProduct']:\n                continue\n\n            cve['Relevant'] = True\n            filtered.append(cve)\n\n            if cve['Supersedes']:\n                hotfixes.append(cve['Supersedes'])\n    # Make sure that if the productfilter does not contain a Service Pack, we don't list the versions of that OS\n    # which include a Service Pack in the product name\n    else:\n        productfilter_sp = productfilter + ' Service Pack'\n        for cve in cves:\n            if productfilter not in cve['AffectedProduct'] or productfilter_sp in cve['AffectedProduct']:\n                continue\n\n            cve['Relevant'] = True\n            filtered.append(cve)\n\n            if cve['Supersedes']:\n                hotfixes.append(cve['Supersedes'])\n\n    # Collect patches that are already superseeded and\n    # merge these with the patches found installed on the system\n    hotfixes = ';'.join(set(hotfixes))\n\n    marked = set()\n    mark_superseeded_hotfix(filtered, hotfixes, marked)\n\n    # Check if left over KBs contain overlaps, for example a separate security hotfix\n    # which is also contained in a monthly rollup update\n    check = filter(lambda cve: cve['Relevant'], filtered)\n    supersedes = set([x['Supersedes'] for x in check])\n    checked = filter(lambda cve: cve['BulletinKB'] in supersedes, check)\n    for c in checked:\n        c['Relevant'] = False\n\n    # Final results\n    found = list(filter(lambda cve: cve['Relevant'], filtered))\n    for f in found:\n        del f['Relevant']\n\n    return filtered, found\n\n\n# Function which recursively marks KBs as irrelevant whenever they are superseeded\ndef mark_superseeded_hotfix(filtered, superseeded, marked):\n    # Locate all CVEs for KB\n    for ssitem in superseeded.split(';'):\n        foundSuperseeded = filter(lambda cve: cve['Relevant'] and cve['BulletinKB'] == ssitem, filtered)\n        for ss in foundSuperseeded:\n            ss['Relevant'] = False\n\n            # In case there is a child, recurse (depth first)\n            if ss['Supersedes'] and ss['Supersedes'] not in marked:\n                marked.add(ss['Supersedes'])\n                mark_superseeded_hotfix(filtered, ss['Supersedes'], marked)\n\n\n# Determine Windows version based on the systeminfo input file provided\ndef determine_product(systeminfo):\n    systeminfo = charset_convert(systeminfo)\n\n    # Fixup for 7_sp1_x64_enterprise_fr_systeminfo_powershell.txt\n    systeminfo = systeminfo.replace('\\xA0', '\\x20')\n\n    # OS Version\n    regex_version = re.compile(r'.*?((\\d+\\.?){3}) ((Service Pack (\\d)|N\\/\\w|.+) )?[ -\\xa5]+ (\\d+).*', re.MULTILINE | re.IGNORECASE)\n    systeminfo_matches = regex_version.findall(systeminfo)\n    if len(systeminfo_matches) == 0:\n        raise WesException('Not able to detect OS version based on provided input file\\n    In case you used the missingkbs script, use: wes.py -m missing.txt')\n\n    systeminfo_matches = systeminfo_matches[0]\n    mybuild = int(systeminfo_matches[5])\n    servicepack = systeminfo_matches[4]\n\n    # OS Name\n    win_matches = re.findall(r'.*?Microsoft[\\(R\\)]{0,3} Windows[\\(R\\)?]{0,3} ?(Serverr? )?(\\d+\\.?\\d?( R2)?|XP|VistaT).*', systeminfo, re.MULTILINE | re.IGNORECASE)\n    if len(win_matches) == 0:\n        raise WesException('Not able to detect OS name based on provided input file')\n    win = win_matches[0][1]\n\n    # System Type\n    archs = re.findall(r'.*?([\\w\\d]+?)-based PC.*', systeminfo, re.MULTILINE | re.IGNORECASE)\n    if len(archs) > 0:\n        arch = archs[0]\n    else:\n        logging.warning('Cannot determine system\\'s architecture. Assuming x64')\n        arch = 'x64'\n\n    # Hotfix(s)\n    hotfixes = get_hotfixes(systeminfo)\n\n    # Determine Windows 10/11 version based on build\n    version = None\n    for build in buildnumbers:\n        if mybuild == build:\n            version = buildnumbers[build]\n            break\n        if mybuild > build:\n            version = buildnumbers[build]\n        else:\n            break\n\n    # Compile name for product filter\n    # Architecture\n    if win not in ['XP', 'VistaT', '2003', '2003 R2']:\n        if arch == 'X86':\n            arch = '32-bit'\n        elif arch == 'x64':\n            arch = 'x64-based'\n\n    # Client OSs\n    if win == 'XP':\n        productfilter = 'Microsoft Windows XP'\n        if arch != 'X86':\n            productfilter += ' Professional %s Edition' % arch\n        if servicepack:\n            productfilter += ' Service Pack %s' % servicepack\n    elif win == 'VistaT':\n        productfilter = 'Windows Vista'\n        if arch != 'x86':\n            productfilter += ' %s Edition' % arch\n        if servicepack:\n            productfilter += ' Service Pack %s' % servicepack\n    elif win == '7':\n        productfilter = 'Windows %s for %s Systems' % (win, arch)\n        if servicepack:\n            productfilter += ' Service Pack %s' % servicepack\n    elif win == '8':\n        productfilter = 'Windows %s for %s Systems' % (win, arch)\n    elif win == '8.1':\n        productfilter = 'Windows %s for %s Systems' % (win, arch)\n    elif win == '10':\n        productfilter = 'Windows %s Version %s for %s Systems' % (win, version, arch)\n    elif win == '11':\n        productfilter = 'Windows %s Version %s for %s Systems' % (win, version, arch)\n\n    # Server OSs\n    elif win == '2003':\n        if arch == 'X86':\n            arch = ''\n        elif arch == 'x64':\n            arch = ' x64 Edition'\n        pversion = '' if version is None else ' ' + version\n        productfilter = 'Microsoft Windows Server %s%s%s' % (win, arch, pversion)\n    # elif win == '2003 R2':\n    # Not possible to distinguish between Windows Server 2003 and Windows Server 2003 R2 based on the systeminfo output\n    # See: https://serverfault.com/q/634149\n    # Even though in the definitions there is a distinction though between 2003 and 2003 R2, there are only around 50\n    # KBs specificly for 2003 R2 (x86/x64) and almost 6000 KBs for 2003 (x86/x64)\n    elif win == '2008':\n        pversion = '' if version is None else ' ' + version\n        productfilter = 'Windows Server %s for %s Systems%s' % (win, arch, pversion)\n    elif win == '2008 R2':\n        pversion = '' if version is None else ' ' + version\n        productfilter = 'Windows Server %s for %s Systems%s' % (win, arch, pversion)\n    elif win == '2012':\n        productfilter = 'Windows Server %s' % win\n    elif win == '2012 R2':\n        productfilter = 'Windows Server %s' % win\n    elif win == '2016':\n        productfilter = 'Windows Server %s' % win\n    elif win == '2019':\n        productfilter = 'Windows Server %s' % win\n    elif win == '2022':\n        productfilter = 'Windows Server %s' % win\n    else:\n        raise WesException('Failed assessing Windows version {}'.format(win))\n\n    return productfilter, win, mybuild, version, arch, hotfixes\n\n\n# Extract hotfixes from provided text file\ndef get_hotfixes(text):\n    hotfix_matches = re.findall(r'.*KB\\d+.*', text, re.MULTILINE | re.IGNORECASE)\n    hotfixes = []\n    for match in hotfix_matches:\n        hotfixes.append(re.search(r'.*KB(\\d+).*', match, re.MULTILINE | re.IGNORECASE).group(1))\n\n    return hotfixes\n\n\n# Debugging feature to list hierarchy of superseeded KBs according to the definitions file\ndef debug_supersedes(cves, kbs, indent, verbose):\n    for kb in kbs:\n        # Determine KBs superseeded by provided KB\n        foundkbs = list(filter(lambda k: k['BulletinKB'] == kb, cves))\n\n        # Extract date and title\n        titles = []\n        for f in foundkbs:\n            titles.append(f['Title'])\n        titles = list(set(filter(None, titles)))\n        titles.sort()\n\n        kbdate = foundkbs[0]['DatePosted'] if foundkbs else '????????'\n        kbtitle = titles[0] if titles else ''\n\n        # Print\n        indentstr = '  ' * indent\n        print('[%.2d][%s] %s%s - %s' % (indent, kbdate, indentstr, kb.ljust(7, ' '), kbtitle))\n        if verbose and len(titles) > 1:\n            for t in titles[1:]:\n                print('%s%s%s' % (indentstr, ' ' * 25, t))\n\n        # Recursively iterate over KBs superseeded by the current KB\n        supersedes = []\n        for f in foundkbs:\n            supersedes += f['Supersedes'].split(';')\n        supersedes = list(set(filter(None, supersedes)))\n        debug_supersedes(cves, supersedes, indent + 1, verbose)\n\n\n# Split up list of KBs and the potential Service Packs/Cumulative updates available\ndef get_patches_servicepacks(results, cves, productfilter):\n    # Extract available Service Packs (if any)\n    sp = list(filter(lambda c: c['CVE'].startswith('SP'), results))\n    if len(sp) > 0:\n        sp = sp[0]  # There should only be one result\n\n        # Only focus on OS + architecure, current service pack is not relevant\n        productfilter = re.sub(r' Service Pack \\d', '', productfilter)\n\n        # Determine service packs available for the OS and determine the latest version available\n        servicepacks = list(filter(lambda c: c['CVE'].startswith('SP') and productfilter in c['AffectedProduct'], cves))\n        lastpatch = get_last_patch(servicepacks, sp)\n\n        # Remove service packs from regular KB output\n        kbs = list(filter(lambda c: not c['CVE'].startswith('SP'), results))\n\n        return kbs, lastpatch\n\n    return results, None\n\n\ndef get_operatingsystems(found, os_name):\n    # Compile the list of operating systems available from the results of above filter\n    # This list is provided to the user to further filter down the specific vulnerabilities\n    allproducts = list(set(t['AffectedProduct'] for t in found))\n    regex_wp = re.compile(r'.*(Windows (Server|(\\d+.?)+|XP).*)')\n    os_names = list(set([wp[0] for wp in regex_wp.findall('\\n'.join(allproducts))]))\n    os_names.sort()\n\n    # If --os parameter is provided, filter results on OS\n    if os_name:\n        # Support for providing an index in stead of the full OS string\n        if os_name.isdigit():\n            if int(os_name) >= len(os_names):\n                print(colored('[-] Invalid operating system index specified with the --os parameter', 'red'))\n                exit(1)\n            os_name = os_names[int(os_name)]\n\n    return os_names, os_name\n\n\ndef list_operatingsystems(os_names):\n    # List operating systems\n    print(colored('[I] List of operating systems:', 'green'))\n    i = 0\n    for name in os_names:\n        print('    [%d] %s' % (i, name))\n        i += 1\n\n\n# Obtain most recent patch tracing back recursively locating records which superseeded the provided record\ndef get_last_patch(servicepacks, kb):\n    results = list(filter(lambda c: c['Supersedes'] == kb['BulletinKB'], servicepacks))\n\n    if results:\n        return get_last_patch(servicepacks, results[0])\n    else:\n        return kb\n\n\n# Show summary at the end of results containing the number of patches and the most recent patch installed\ndef print_summary(kbs, sp):\n    # Collect unique BulletinKBs\n    missingpatches = set(r['BulletinKB'] for r in kbs)\n    print(colored('[-] Missing patches: ', 'red') + '%s' % colored(len(missingpatches), 'yellow'))\n\n    # Show missing KBs with number of vulnerabilites per KB\n    grouped = Counter([r['BulletinKB'] for r in kbs if r['DatePosted']])\n    foundmissing = grouped.most_common()\n    for line in foundmissing:\n        kb = line[0]\n        number = line[1]\n        print('    - KB%s: patches %s %s' % (kb, number, 'vulnerability' if number == 1 else 'vulnerabilities'))\n\n    # Show in case a service pack is missing\n    if sp:\n        print(colored('[-] Missing service pack', 'red'))\n        print('    - %s' % sp['Title'])\n\n    # Show additional missing KBs when the --missing parameter is used\n    if len(missingpatches) > len(grouped):\n        difference = missingpatches.symmetric_difference([r[0] for r in foundmissing])\n        for kb in difference:\n            print('    - KB%s: patches an unknown number of vulnerabilities' % kb)\n        print(colored('[I] Check the details of the unknown patches at https://support.microsoft.com/help/KBID,\\n    for example https://support.microsoft.com/help/890830 in case of KB890830', 'yellow'))\n\n    # Show date of most recent KB\n    # Skip if no most recent KB available\n    if len(grouped) == 0:\n        return\n    foundkb = get_most_recent_kb(kbs)\n    message = colored('[I] KB with the most recent release date', 'yellow')\n    print('%s\\n'\n          '    - ID: KB%s\\n'\n          '    - Release date: %s' % (message, foundkb['BulletinKB'], foundkb['DatePosted']))\n\n\n# Obtain most recent KB from a dictionary of results\ndef get_most_recent_kb(results):\n    dates = [int(r['DatePosted']) for r in results if r['DatePosted']]\n    if dates:\n        date = str(max(dates))\n        return list(filter(lambda kb: kb['DatePosted'] == date, results))[0]\n    else:\n        return None\n\n\n# Output results of wes.py to screen\ndef print_results(results):\n    print()\n    for res in results:\n        # Don't print KBs which are supplied through the --missing parameter but are not included in the definitions.zip\n        if not res['DatePosted']:\n            continue\n\n        exploits = res['Exploits'] if 'Exploits' in res else ''\n        label = 'Exploit'\n        value = 'n/a'\n        if len(exploits) > 0:\n            value = colored(exploits, 'blue')\n        if ',' in exploits:\n            label = 'Exploits'\n\n        if res['Severity'] == 'Critical':\n            highlight = 'red'\n        elif res['Severity'] == 'Important':\n            highlight = 'yellow'\n        elif res['Severity'] == 'Low':\n            highlight = 'green'\n        elif res['Severity'] == 'Moderate':\n            highlight = 'blue'\n        else:\n            highlight = 'red'\n\n        print('Date: %s\\n'\n              'CVE: %s\\n'\n              'KB: KB%s\\n'\n              'Title: %s\\n'\n              'Affected product: %s\\n'\n              'Affected component: %s\\n'\n              'Severity: %s\\n'\n              'Impact: %s\\n'\n              '%s: %s\\n' % (res['DatePosted'], res['CVE'], res['BulletinKB'], res['Title'], res['AffectedProduct'], res['AffectedComponent'], colored(res['Severity'], highlight), res['Impact'], label, value))\n\n\n# Output results of wes.py to a .csv file\ndef store_results(outputfile, results):\n    print(colored('[+] Writing %d results to %s' % (len(results), outputfile), 'green'))\n\n    # Python 2 compatibility\n    if sys.version_info.major == 2:\n        f = open(outputfile, 'wb')\n    else:\n        f = open(outputfile, 'w', newline='')\n\n    header = list(results[0].keys())\n    header.remove('Supersedes')\n    writer = csv.DictWriter(f, fieldnames=header, quoting=csv.QUOTE_ALL)\n    writer.writeheader()\n    for r in results:\n        if 'Supersedes' in r:\n            del r['Supersedes']\n        writer.writerow(r)\n\n\n# Validate file existence for user-provided arguments\ndef check_file_exists(value):\n    if not os.path.isfile(value):\n        raise argparse.ArgumentTypeError('File \\'%s\\' does not exist.' % value)\n\n    return value\n\n\n# Validate file existence for definitions file\ndef check_definitions_exists(value):\n    if not os.path.isfile(value):\n        raise argparse.ArgumentTypeError('Definitions file \\'%s\\' does not exist. Try running %s --update first.' % (value, FILENAME))\n\n    return value\n\n\n# Specify arguments using for the argparse library\ndef parse_arguments():\n    examples = r'''Examples:\n  Download latest definitions\n  {0} --update\n  {0} -u\n\n  Determine vulnerabilities\n  {0} systeminfo.txt\n  \n  Determine vulnerabilities using the qfe file. List the OS by first running the command without the --os parameter\n  {0} --qfe qfe.txt --os 'Windows 10 Version 20H2 for x64-based Systems'\n  {0} -q qfe.txt --os 9\n\n  Determine vulnerabilities and output to file\n  {0} systeminfo.txt --output vulns.csv\n  {0} systeminfo.txt -o vulns.csv\n\n  Determine vulnerabilities explicitly specifying KBs to reduce false-positives\n  {0} systeminfo.txt --patches KB4345421 KB4487017\n  {0} systeminfo.txt -p KB4345421 KB4487017\n  \n  Determine vulnerabilies filtering out out vulnerabilities of KBs that have been published before the publishing date of the most recent KB installed\n  {0} systeminfo.txt --usekbdate\n  {0} systeminfo.txt -d\n\n  Determine vulnerabilities explicitly specifying definitions file\n  {0} systeminfo.txt --definitions C:\\tmp\\mydefs.zip\n\n  List only vulnerabilities with exploits, excluding IE, Edge and Flash\n  {0} systeminfo.txt --exploits-only --hide \"Internet Explorer\" Edge Flash\n  {0} systeminfo.txt -e --hide \"Internet Explorer\" Edge Flash\n\n  Only show vulnerabilities of a certain impact\n  {0} systeminfo.txt --impact \"Remote Code Execution\"\n  {0} systeminfo.txt -i \"Remote Code Execution\"\n  \n  Only show vulnerabilities of a certain severity\n  {0} systeminfo.txt --severity critical\n  {0} systeminfo.txt -s critical\n  \n  Show vulnerabilities based on missing patches \n  {0} --missing missing.txt\n  {0} -m missing.txt\n  \n  Show vulnerabilities based on missing patches specifying OS\n  {0} --missing missing.txt --os \"Windows 10 Version 1809 for x64-based Systems\"\n  {0} -m missing.txt --os 2\n\n  Validate supersedence against Microsoft's online Update Catalog\n  {0} systeminfo.txt --muc-lookup\n\n  Show colored output \n  {0} systeminfo.txt --color\n  {0} systeminfo.txt -c\n\n  Download latest version of WES-NG\n  {0} --update-wes\n'''.format(FILENAME)\n\n    parser = argparse.ArgumentParser(\n        description=BANNER % (TITLE, '%.2f' % VERSION, WEB_URL),\n        add_help=False,\n        epilog=examples,\n        formatter_class=argparse.RawDescriptionHelpFormatter\n    )\n\n    # Update definitions\n    parser.add_argument('-u', '--update', dest='perform_update', action='store_true', help='Download latest list of CVEs')\n    args, xx = parser.parse_known_args()\n    if args.perform_update:\n        return parser.parse_args()\n\n    # General options\n    parser.add_argument('--definitions', action='store', nargs='?', type=check_definitions_exists, default='definitions.zip', help='Definitions zip file (default: definitions.zip)')\n    parser.add_argument('-p', '--patches', dest='installedpatch', nargs='+', default='', help='Manually specify installed patches in addition to the ones listed in the systeminfo.txt file')\n    parser.add_argument('-d', '--usekbdate', dest='usekbdate', action='store_true', help='Filter out vulnerabilities of KBs published before the publishing date of the most recent KB installed')\n    parser.add_argument('-e', '--exploits-only', dest='only_exploits', action='store_true', help='Show only vulnerabilities with known exploits')\n    parser.add_argument('--hide', dest='hiddenvuln', nargs='+', default='', help='Hide vulnerabilities of for example Adobe Flash Player and Microsoft Edge')\n    parser.add_argument('-i', '--impact', dest='impacts', nargs='+', default='', help='Only display vulnerabilities with a given impact')\n    parser.add_argument('-s', '--severity', dest='severities', nargs='+', default='', help='Only display vulnerabilities with a given severity')\n    parser.add_argument('-o', '--output', action='store', dest='outputfile', nargs='?', help='Store results in a file')\n    parser.add_argument('--muc-lookup', dest='muc_lookup', action='store_true', help='Hide vulnerabilities if installed hotfixes are listed in the Microsoft Update Catalog as superseding hotfixes for the original BulletinKB')\n    parser.add_argument('--os', action='store', dest='operating_system', nargs='?', help='Specify operating system or ID from list when running without this parameter')\n    parser.add_argument('-c', '--color', dest='showcolor', action='store_true', help='Show console output in color (requires termcolor library)')\n    parser.add_argument('-h', '--help', action='help', help='Show this help message and exit')\n\n   # Update application\n    parser.add_argument('--update-wes', dest='perform_wesupdate', action='store_true', help='Download latest version of wes.py')\n    args, xx = parser.parse_known_args()\n    if args.perform_wesupdate:\n        return parser.parse_args()\n\n    # Show version\n    parser.add_argument('--version', dest='showversion', action='store_true', help='Show version information')\n    args, xx = parser.parse_known_args()\n    if args.showversion:\n        return parser.parse_args()\n\n    # Use missing patches input file\n    parser.add_argument('-m', '--missing', dest='missingpatches', nargs='?', type=check_file_exists, help='Provide file with the list of patches missing from the system. This file can be generated using the WES-NG\\'s missingpatches.vbs utility')\n    args, xx = parser.parse_known_args()\n    if args.missingpatches:\n        return parser.parse_args()\n\n    # Use qfe input file\n    parser.add_argument('-q', '--qfe', dest='qfefile', nargs='?', type=check_file_exists, help='Specify the file containing the output of the \\'wmic qfe\\' command')\n    args, xx = parser.parse_known_args()\n    if args.qfefile:\n        return parser.parse_args()\n\n    # Debug supersedes: perform a check on the supersedence tree according to the definitions.zip\n    # First argument is OS (as listed in the definitions) or an empty string for no filter, next arguments are 1 or more KBs.\n    # The --verbose argument will have wes.py print all titles of KBs found instead of only the first title.\n    # Example: wes.py --debug-supersedes \"Windows Vista x64 Edition Service Pack 2\" 3216916 --verbose\n    parser.add_argument('--debug-supersedes', dest='debugsupersedes', nargs='+', default='', help=argparse.SUPPRESS)\n    parser.add_argument('--verbose', dest='verbosesupersedes', action='store_true', help=argparse.SUPPRESS)\n    args, xx = parser.parse_known_args()\n    if args.debugsupersedes:\n        return parser.parse_args()\n\n    # Mandatory input files, in case no other flow has been chosen\n    parser.add_argument('systeminfo', action='store', type=check_file_exists, help='Specify systeminfo.txt file')\n\n    # Always show full help when no arguments are provided\n    if len(sys.argv) == 1:\n        parser.print_help()\n        exit(1)\n\n    return parser.parse_args()\n\n\nif __name__ == '__main__':\n    main()\n\n"
        }
      ]
    }
  ]
}