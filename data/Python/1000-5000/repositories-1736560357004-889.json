{
  "metadata": {
    "timestamp": 1736560357004,
    "page": 889,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjkwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "tamarott/SinGAN",
      "stars": 3318,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0791015625,
          "content": "# Don't track content of these folders\nOutput/\nTrainedModels/\n__pycache__/\n.idea\n"
        },
        {
          "name": "Downloads",
          "type": "tree",
          "content": null
        },
        {
          "name": "Input",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE.txt",
          "type": "blob",
          "size": 1.1943359375,
          "content": "MIT License\n\nSinGAN: Learning a Generative Model from a Single Natural Image\nICCV 2019\nTamar Rott Shaham, Tali Dekel, Tomer Michaeli\n\nCopyright (c) 2019 Tamar Rott Shaham, Tali Dekel, Tomer Michaeli\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 6.7294921875,
          "content": "# SinGAN\n\n[Project](https://tamarott.github.io/SinGAN.htm) | [Arxiv](https://arxiv.org/pdf/1905.01164.pdf) | [CVF](http://openaccess.thecvf.com/content_ICCV_2019/papers/Shaham_SinGAN_Learning_a_Generative_Model_From_a_Single_Natural_Image_ICCV_2019_paper.pdf) | [Supplementary materials](https://openaccess.thecvf.com/content_ICCV_2019/supplemental/Shaham_SinGAN_Learning_a_ICCV_2019_supplemental.pdf) | [Talk (ICCV`19)](https://youtu.be/mdAcPe74tZI?t=3191) \n### Official pytorch implementation of the paper: \"SinGAN: Learning a Generative Model from a Single Natural Image\"\n#### ICCV 2019 Best paper award (Marr prize)\n\n\n## Random samples from a *single* image\nWith SinGAN, you can train a generative model from a single natural image, and then generate random samples from the given image, for example:\n\n![](imgs/teaser.PNG)\n\n\n## SinGAN's applications\nSinGAN can be also used for a line of image manipulation tasks, for example:\n ![](imgs/manipulation.PNG)\nThis is done by injecting an image to the already trained model. See section 4 in our [paper](https://arxiv.org/pdf/1905.01164.pdf) for more details.\n\n\n### Citation\nIf you use this code for your research, please cite our paper:\n\n```\n@inproceedings{rottshaham2019singan,\n  title={SinGAN: Learning a Generative Model from a Single Natural Image},\n  author={Rott Shaham, Tamar and Dekel, Tali and Michaeli, Tomer},\n  booktitle={Computer Vision (ICCV), IEEE International Conference on},\n  year={2019}\n}\n```\n\n## Code\n\n### Install dependencies\n\n```\npython -m pip install -r requirements.txt\n```\n\nThis code was tested with python 3.6, torch 1.4\n\nPlease note: the code currently only supports torch 1.4 or earlier because of the optimization scheme.\n\nFor later torch versions, you may try this repository: https://github.com/kligvasser/SinGAN (results won't necessarily be identical to the official implementation).\n\n\n###  Train\nTo train SinGAN model on your own image, put the desired training image under Input/Images, and run\n\n```\npython main_train.py --input_name <input_file_name>\n```\n\nThis will also use the resulting trained model to generate random samples starting from the coarsest scale (n=0).\n\nTo run this code on a cpu machine, specify `--not_cuda` when calling `main_train.py`\n\n###  Random samples\nTo generate random samples from any starting generation scale, please first train SinGAN model on the desired image (as described above), then run \n\n```\npython random_samples.py --input_name <training_image_file_name> --mode random_samples --gen_start_scale <generation start scale number>\n```\n\npay attention: for using the full model, specify the generation start scale to be 0, to start the generation from the second scale, specify it to be 1, and so on. \n\n###  Random samples of arbitrary sizes\nTo generate random samples of arbitrary sizes, please first train SinGAN model on the desired image (as described above), then run \n\n```\npython random_samples.py --input_name <training_image_file_name> --mode random_samples_arbitrary_sizes --scale_h <horizontal scaling factor> --scale_v <vertical scaling factor>\n```\n\n###  Animation from a single image\n\nTo generate short animation from a single image, run\n\n```\npython animation.py --input_name <input_file_name> \n```\n\nThis will automatically start a new training phase with noise padding mode.\n\n###  Harmonization\n\nTo harmonize a pasted object into an image (See example in Fig. 13 in [our paper](https://arxiv.org/pdf/1905.01164.pdf)), please first train SinGAN model on the desired background image (as described above), then save the naively pasted reference image and it's binary mask under \"Input/Harmonization\" (see saved images for an example). Run the command\n\n```\npython harmonization.py --input_name <training_image_file_name> --ref_name <naively_pasted_reference_image_file_name> --harmonization_start_scale <scale to inject>\n\n```\n\nPlease note that different injection scale will produce different harmonization effects. The coarsest injection scale equals 1. \n\n###  Editing\n\nTo edit an image, (See example in Fig. 12 in [our paper](https://arxiv.org/pdf/1905.01164.pdf)), please first train SinGAN model on the desired non-edited image (as described above), then save the naive edit as a reference image under \"Input/Editing\" with a corresponding binary map (see saved images for an example). Run the command\n\n```\npython editing.py --input_name <training_image_file_name> --ref_name <edited_image_file_name> --editing_start_scale <scale to inject>\n\n```\nboth the masked and unmasked output will be saved.\nHere as well, different injection scale will produce different editing effects. The coarsest injection scale equals 1. \n\n###  Paint to Image\n\nTo transfer a paint into a realistic image (See example in Fig. 11 in [our paper](https://arxiv.org/pdf/1905.01164.pdf)), please first train SinGAN model on the desired image (as described above), then save your paint under \"Input/Paint\", and run the command\n\n```\npython paint2image.py --input_name <training_image_file_name> --ref_name <paint_image_file_name> --paint_start_scale <scale to inject>\n\n```\nHere as well, different injection scale will produce different editing effects. The coarsest injection scale equals 1. \n\nAdvanced option: Specify quantization_flag to be True, to re-train *only* the injection level of the model, to get a on a color-quantized version of upsampled generated images from the previous scale. For some images, this might lead to more realistic results.\n\n### Super Resolution\nTo super resolve an image, please run:\n```\npython SR.py --input_name <LR_image_file_name>\n```\nThis will automatically train a SinGAN model correspond to 4x upsampling factor (if not exist already).\nFor different SR factors, please specify it using the parameter `--sr_factor` when calling the function.\nSinGAN's results on the BSD100 dataset can be download from the 'Downloads' folder.\n\n## Additional Data and Functions\n\n### Single Image Fr√©chet Inception Distance (SIFID score)\nTo calculate the SIFID between real images and their corresponding fake samples, please run:\n```\npython SIFID/sifid_score.py --path2real <real images path> --path2fake <fake images path> \n```  \nMake sure that each of the fake images file name is identical to its corresponding real image file name. Images should be saved in `.jpg` format.\n\n### Super Resolution Results\nSinGAN's SR results on the BSD100 dataset can be download from the 'Downloads' folder.\n\n### User Study\nThe data used for the user study can be found in the Downloads folder. \n\nreal folder: 50 real images, randomly picked from the [places database](http://places.csail.mit.edu/)\n\nfake_high_variance folder: random samples starting from n=N for each of the real images \n\nfake_mid_variance folder: random samples starting from n=N-1 for each of the real images \n\nFor additional details please see section 3.1 in our [paper](https://arxiv.org/pdf/1905.01164.pdf)\n"
        },
        {
          "name": "SIFID.npy",
          "type": "blob",
          "size": 0.125,
          "content": null
        },
        {
          "name": "SIFID",
          "type": "tree",
          "content": null
        },
        {
          "name": "SR.py",
          "type": "blob",
          "size": 2.681640625,
          "content": "from config import get_arguments\nfrom SinGAN.manipulate import *\nfrom SinGAN.training import *\nfrom SinGAN.imresize import imresize\nimport SinGAN.functions as functions\n\n\nif __name__ == '__main__':\n    parser = get_arguments()\n    parser.add_argument('--input_dir', help='input image dir', default='Input/Images')\n    parser.add_argument('--input_name', help='training image name', default=\"33039_LR.png\")#required=True)\n    parser.add_argument('--sr_factor', help='super resolution factor', type=float, default=4)\n    parser.add_argument('--mode', help='task to be done', default='SR')\n    opt = parser.parse_args()\n    opt = functions.post_config(opt)\n    Gs = []\n    Zs = []\n    reals = []\n    NoiseAmp = []\n    dir2save = functions.generate_dir2save(opt)\n    if dir2save is None:\n        print('task does not exist')\n    #elif (os.path.exists(dir2save)):\n    #    print(\"output already exist\")\n    else:\n        try:\n            os.makedirs(dir2save)\n        except OSError:\n            pass\n\n        mode = opt.mode\n        in_scale, iter_num = functions.calc_init_scale(opt)\n        opt.scale_factor = 1 / in_scale\n        opt.scale_factor_init = 1 / in_scale\n        opt.mode = 'train'\n        dir2trained_model = functions.generate_dir2save(opt)\n        if (os.path.exists(dir2trained_model)):\n            Gs, Zs, reals, NoiseAmp = functions.load_trained_pyramid(opt)\n            opt.mode = mode\n        else:\n            print('*** Train SinGAN for SR ***')\n            real = functions.read_image(opt)\n            opt.min_size = 18\n            real = functions.adjust_scales2image_SR(real, opt)\n            train(opt, Gs, Zs, reals, NoiseAmp)\n            opt.mode = mode\n        print('%f' % pow(in_scale, iter_num))\n        Zs_sr = []\n        reals_sr = []\n        NoiseAmp_sr = []\n        Gs_sr = []\n        real = reals[-1]  # read_image(opt)\n        real_ = real\n        opt.scale_factor = 1 / in_scale\n        opt.scale_factor_init = 1 / in_scale\n        for j in range(1, iter_num + 1, 1):\n            real_ = imresize(real_, pow(1 / opt.scale_factor, 1), opt)\n            reals_sr.append(real_)\n            Gs_sr.append(Gs[-1])\n            NoiseAmp_sr.append(NoiseAmp[-1])\n            z_opt = torch.full(real_.shape, 0, device=opt.device)\n            m = nn.ZeroPad2d(5)\n            z_opt = m(z_opt)\n            Zs_sr.append(z_opt)\n        out = SinGAN_generate(Gs_sr, Zs_sr, reals_sr, NoiseAmp_sr, opt, in_s=reals_sr[0], num_samples=1)\n        out = out[:, :, 0:int(opt.sr_factor * reals[-1].shape[2]), 0:int(opt.sr_factor * reals[-1].shape[3])]\n        dir2save = functions.generate_dir2save(opt)\n        plt.imsave('%s/%s_HR.png' % (dir2save,opt.input_name[:-4]), functions.convert_image_np(out.detach()), vmin=0, vmax=1)\n\n\n\n\n"
        },
        {
          "name": "SinGAN",
          "type": "tree",
          "content": null
        },
        {
          "name": "animation.py",
          "type": "blob",
          "size": 1.8984375,
          "content": "from config import get_arguments\r\nfrom SinGAN.manipulate import *\r\nfrom SinGAN.training import *\r\nfrom SinGAN.imresize import imresize\r\nimport SinGAN.functions as functions\r\n\r\n\r\nif __name__ == '__main__':\r\n    parser = get_arguments()\r\n    #parser.add_argument('--animation_start_scale', type=int, help='generation start scale', default=2)\r\n    parser.add_argument('--alpha_animation', type=float, help='animation random walk first moment', default=0.1)\r\n    #parser.add_argument('--beta_animation', type=float, help='animation random walk second moment', default=0.9)\r\n    parser.add_argument('--input_dir', help='input image dir', default='Input/Images')\r\n    parser.add_argument('--input_name', help='input image name', required=True)\r\n    parser.add_argument('--mode', help='task to be done', default='animation')\r\n    opt = parser.parse_args()\r\n    opt = functions.post_config(opt)\r\n    Gs = []\r\n    Zs = []\r\n    reals = []\r\n    NoiseAmp = []\r\n    dir2save = functions.generate_dir2save(opt)\r\n    if (os.path.exists(dir2save)):\r\n        print(\"output already exist\")\r\n    else:\r\n        opt.min_size = 20\r\n        opt.mode = 'animation_train'\r\n        real = functions.read_image(opt)\r\n        functions.adjust_scales2image(real, opt)\r\n        dir2trained_model = functions.generate_dir2save(opt)\r\n        if (os.path.exists(dir2trained_model)):\r\n            Gs, Zs, reals, NoiseAmp = functions.load_trained_pyramid(opt)\r\n            opt.mode = 'animation'\r\n        else:\r\n            train(opt, Gs, Zs, reals, NoiseAmp)\r\n            opt.mode = 'animation'\r\n        try:\r\n            os.makedirs(dir2save)\r\n        except OSError:\r\n            pass\r\n        for start_scale in range(0, 3, 1):\r\n            for b in range(80, 100, 5):\r\n                #opt.animation_start_scale = start_scale\r\n                #opt.beta_animation = b / 100\r\n                generate_gif(Gs, Zs, reals, NoiseAmp, opt, beta=b/100, start_scale=start_scale)\r\n\r\n"
        },
        {
          "name": "config.py",
          "type": "blob",
          "size": 2.595703125,
          "content": "import argparse\r\n\r\n\r\ndef get_arguments():\r\n    parser = argparse.ArgumentParser()\r\n    #parser.add_argument('--mode', help='task to be done', default='train')\r\n    #workspace:\r\n    parser.add_argument('--not_cuda', action='store_true', help='disables cuda', default=0)\r\n    \r\n    #load, input, save configurations:\r\n    parser.add_argument('--netG', default='', help=\"path to netG (to continue training)\")\r\n    parser.add_argument('--netD', default='', help=\"path to netD (to continue training)\")\r\n    parser.add_argument('--manualSeed', type=int, help='manual seed')\r\n    parser.add_argument('--nc_z',type=int,help='noise # channels',default=3)\r\n    parser.add_argument('--nc_im',type=int,help='image # channels',default=3)\r\n    parser.add_argument('--out',help='output folder',default='Output')\r\n        \r\n    #networks hyper parameters:\r\n    parser.add_argument('--nfc', type=int, default=32)\r\n    parser.add_argument('--min_nfc', type=int, default=32)\r\n    parser.add_argument('--ker_size',type=int,help='kernel size',default=3)\r\n    parser.add_argument('--num_layer',type=int,help='number of layers',default=5)\r\n    parser.add_argument('--stride',help='stride',default=1)\r\n    parser.add_argument('--padd_size',type=int,help='net pad size',default=0)#math.floor(opt.ker_size/2)\r\n        \r\n    #pyramid parameters:\r\n    parser.add_argument('--scale_factor',type=float,help='pyramid scale factor',default=0.75)#pow(0.5,1/6))\r\n    parser.add_argument('--noise_amp',type=float,help='addative noise cont weight',default=0.1)\r\n    parser.add_argument('--min_size',type=int,help='image minimal size at the coarser scale',default=25)\r\n    parser.add_argument('--max_size', type=int,help='image minimal size at the coarser scale', default=250)\r\n\r\n    #optimization hyper parameters:\r\n    parser.add_argument('--niter', type=int, default=2000, help='number of epochs to train per scale')\r\n    parser.add_argument('--gamma',type=float,help='scheduler gamma',default=0.1)\r\n    parser.add_argument('--lr_g', type=float, default=0.0005, help='learning rate, default=0.0005')\r\n    parser.add_argument('--lr_d', type=float, default=0.0005, help='learning rate, default=0.0005')\r\n    parser.add_argument('--beta1', type=float, default=0.5, help='beta1 for adam. default=0.5')\r\n    parser.add_argument('--Gsteps',type=int, help='Generator inner steps',default=3)\r\n    parser.add_argument('--Dsteps',type=int, help='Discriminator inner steps',default=3)\r\n    parser.add_argument('--lambda_grad',type=float, help='gradient penelty weight',default=0.1)\r\n    parser.add_argument('--alpha',type=float, help='reconstruction loss weight',default=10)\r\n\r\n    \r\n    return parser\r\n"
        },
        {
          "name": "config.pyc",
          "type": "blob",
          "size": 2.22265625,
          "content": null
        },
        {
          "name": "editing.py",
          "type": "blob",
          "size": 3.24609375,
          "content": "from config import get_arguments\r\nfrom SinGAN.manipulate import *\r\nfrom SinGAN.training import *\r\nfrom SinGAN.imresize import imresize\r\nfrom SinGAN.imresize import imresize_to_shape\r\nimport SinGAN.functions as functions\r\n\r\n\r\nif __name__ == '__main__':\r\n    parser = get_arguments()\r\n    parser.add_argument('--input_dir', help='input image dir', default='Input/Images')\r\n    parser.add_argument('--input_name', help='training image name', required=True)\r\n    parser.add_argument('--ref_dir', help='input reference dir', default='Input/Editing')\r\n    parser.add_argument('--ref_name', help='reference image name', required=True)\r\n    parser.add_argument('--editing_start_scale', help='editing injection scale', type=int, required=True)\r\n    parser.add_argument('--mode', help='task to be done', default='editing')\r\n    opt = parser.parse_args()\r\n    opt = functions.post_config(opt)\r\n    Gs = []\r\n    Zs = []\r\n    reals = []\r\n    NoiseAmp = []\r\n    dir2save = functions.generate_dir2save(opt)\r\n    if dir2save is None:\r\n        print('task does not exist')\r\n    #elif (os.path.exists(dir2save)):\r\n    #    print(\"output already exist\")\r\n    else:\r\n        try:\r\n            os.makedirs(dir2save)\r\n        except OSError:\r\n            pass\r\n        real = functions.read_image(opt)\r\n        real = functions.adjust_scales2image(real, opt)\r\n        Gs, Zs, reals, NoiseAmp = functions.load_trained_pyramid(opt)\r\n        if (opt.editing_start_scale < 1) | (opt.editing_start_scale > (len(Gs)-1)):\r\n            print(\"injection scale should be between 1 and %d\" % (len(Gs)-1))\r\n        else:\r\n            ref = functions.read_image_dir('%s/%s' % (opt.ref_dir, opt.ref_name), opt)\r\n            mask = functions.read_image_dir('%s/%s_mask%s' % (opt.ref_dir,opt.ref_name[:-4],opt.ref_name[-4:]), opt)\r\n            if ref.shape[3] != real.shape[3]:\r\n                '''\r\n                mask = imresize(mask, real.shape[3]/ref.shape[3], opt)\r\n                mask = mask[:, :, :real.shape[2], :real.shape[3]]\r\n                ref = imresize(ref, real.shape[3] / ref.shape[3], opt)\r\n                ref = ref[:, :, :real.shape[2], :real.shape[3]]\r\n                '''\r\n                mask = imresize_to_shape(mask, [real.shape[2],real.shape[3]], opt)\r\n                mask = mask[:, :, :real.shape[2], :real.shape[3]]\r\n                ref = imresize_to_shape(ref, [real.shape[2],real.shape[3]], opt)\r\n                ref = ref[:, :, :real.shape[2], :real.shape[3]]\r\n\r\n            mask = functions.dilate_mask(mask, opt)\r\n\r\n            N = len(reals) - 1\r\n            n = opt.editing_start_scale\r\n            in_s = imresize(ref, pow(opt.scale_factor, (N - n + 1)), opt)\r\n            in_s = in_s[:, :, :reals[n - 1].shape[2], :reals[n - 1].shape[3]]\r\n            in_s = imresize(in_s, 1 / opt.scale_factor, opt)\r\n            in_s = in_s[:, :, :reals[n].shape[2], :reals[n].shape[3]]\r\n            out = SinGAN_generate(Gs[n:], Zs[n:], reals, NoiseAmp[n:], opt, in_s, n=n, num_samples=1)\r\n            plt.imsave('%s/start_scale=%d.png' % (dir2save, opt.editing_start_scale), functions.convert_image_np(out.detach()), vmin=0, vmax=1)\r\n            out = (1-mask)*real+mask*out\r\n            plt.imsave('%s/start_scale=%d_masked.png' % (dir2save, opt.editing_start_scale), functions.convert_image_np(out.detach()), vmin=0, vmax=1)\r\n\r\n\r\n\r\n\r\n"
        },
        {
          "name": "harmonization.py",
          "type": "blob",
          "size": 2.8330078125,
          "content": "from config import get_arguments\r\nfrom SinGAN.manipulate import *\r\nfrom SinGAN.training import *\r\nfrom SinGAN.imresize import imresize\r\nfrom SinGAN.imresize import imresize_to_shape\r\nimport SinGAN.functions as functions\r\n\r\n\r\nif __name__ == '__main__':\r\n    parser = get_arguments()\r\n    parser.add_argument('--input_dir', help='input image dir', default='Input/Images')\r\n    parser.add_argument('--input_name', help='training image name', required=True)\r\n    parser.add_argument('--ref_dir', help='input reference dir', default='Input/Harmonization')\r\n    parser.add_argument('--ref_name', help='reference image name', required=True)\r\n    parser.add_argument('--harmonization_start_scale', help='harmonization injection scale', type=int, required=True)\r\n    parser.add_argument('--mode', help='task to be done', default='harmonization')\r\n    opt = parser.parse_args()\r\n    opt = functions.post_config(opt)\r\n    Gs = []\r\n    Zs = []\r\n    reals = []\r\n    NoiseAmp = []\r\n    dir2save = functions.generate_dir2save(opt)\r\n    if dir2save is None:\r\n        print('task does not exist')\r\n    #elif (os.path.exists(dir2save)):\r\n    #    print(\"output already exist\")\r\n    else:\r\n        try:\r\n            os.makedirs(dir2save)\r\n        except OSError:\r\n            pass\r\n        real = functions.read_image(opt)\r\n        real = functions.adjust_scales2image(real, opt)\r\n        Gs, Zs, reals, NoiseAmp = functions.load_trained_pyramid(opt)\r\n        if (opt.harmonization_start_scale < 1) | (opt.harmonization_start_scale > (len(Gs)-1)):\r\n            print(\"injection scale should be between 1 and %d\" % (len(Gs)-1))\r\n        else:\r\n            ref = functions.read_image_dir('%s/%s' % (opt.ref_dir, opt.ref_name), opt)\r\n            mask = functions.read_image_dir('%s/%s_mask%s' % (opt.ref_dir,opt.ref_name[:-4],opt.ref_name[-4:]), opt)\r\n            if ref.shape[3] != real.shape[3]:\r\n                mask = imresize_to_shape(mask, [real.shape[2], real.shape[3]], opt)\r\n                mask = mask[:, :, :real.shape[2], :real.shape[3]]\r\n                ref = imresize_to_shape(ref, [real.shape[2], real.shape[3]], opt)\r\n                ref = ref[:, :, :real.shape[2], :real.shape[3]]\r\n            mask = functions.dilate_mask(mask, opt)\r\n\r\n            N = len(reals) - 1\r\n            n = opt.harmonization_start_scale\r\n            in_s = imresize(ref, pow(opt.scale_factor, (N - n + 1)), opt)\r\n            in_s = in_s[:, :, :reals[n - 1].shape[2], :reals[n - 1].shape[3]]\r\n            in_s = imresize(in_s, 1 / opt.scale_factor, opt)\r\n            in_s = in_s[:, :, :reals[n].shape[2], :reals[n].shape[3]]\r\n            out = SinGAN_generate(Gs[n:], Zs[n:], reals, NoiseAmp[n:], opt, in_s, n=n, num_samples=1)\r\n            out = (1-mask)*real+mask*out\r\n            plt.imsave('%s/start_scale=%d.png' % (dir2save,opt.harmonization_start_scale), functions.convert_image_np(out.detach()), vmin=0, vmax=1)\r\n\r\n\r\n\r\n\r\n"
        },
        {
          "name": "imgs",
          "type": "tree",
          "content": null
        },
        {
          "name": "main_train.py",
          "type": "blob",
          "size": 0.9736328125,
          "content": "from config import get_arguments\r\nfrom SinGAN.manipulate import *\r\nfrom SinGAN.training import *\r\nimport SinGAN.functions as functions\r\n\r\n\r\nif __name__ == '__main__':\r\n    parser = get_arguments()\r\n    parser.add_argument('--input_dir', help='input image dir', default='Input/Images')\r\n    parser.add_argument('--input_name', help='input image name', required=True)\r\n    parser.add_argument('--mode', help='task to be done', default='train')\r\n    opt = parser.parse_args()\r\n    opt = functions.post_config(opt)\r\n    Gs = []\r\n    Zs = []\r\n    reals = []\r\n    NoiseAmp = []\r\n    dir2save = functions.generate_dir2save(opt)\r\n\r\n    if (os.path.exists(dir2save)):\r\n        print('trained model already exist')\r\n    else:\r\n        try:\r\n            os.makedirs(dir2save)\r\n        except OSError:\r\n            pass\r\n        real = functions.read_image(opt)\r\n        functions.adjust_scales2image(real, opt)\r\n        train(opt, Gs, Zs, reals, NoiseAmp)\r\n        SinGAN_generate(Gs,Zs,reals,NoiseAmp,opt)\r\n"
        },
        {
          "name": "paint2image.py",
          "type": "blob",
          "size": 4.119140625,
          "content": "from config import get_arguments\r\nfrom SinGAN.manipulate import *\r\nfrom SinGAN.training import *\r\nfrom SinGAN.imresize import imresize\r\nfrom SinGAN.imresize import imresize_to_shape\r\nimport SinGAN.functions as functions\r\n\r\n\r\nif __name__ == '__main__':\r\n    parser = get_arguments()\r\n    parser.add_argument('--input_dir', help='input image dir', default='Input/Images')\r\n    parser.add_argument('--input_name', help='training image name', required=True)\r\n    parser.add_argument('--ref_dir', help='input reference dir', default='Input/Paint')\r\n    parser.add_argument('--ref_name', help='reference image name', required=True)\r\n    parser.add_argument('--paint_start_scale', help='paint injection scale', type=int, required=True)\r\n    parser.add_argument('--quantization_flag', help='specify if to perform color quantization training', type=bool, default=False)\r\n    parser.add_argument('--mode', help='task to be done', default='paint2image')\r\n    opt = parser.parse_args()\r\n    opt = functions.post_config(opt)\r\n    Gs = []\r\n    Zs = []\r\n    reals = []\r\n    NoiseAmp = []\r\n    dir2save = functions.generate_dir2save(opt)\r\n    if dir2save is None:\r\n        print('task does not exist')\r\n    #elif (os.path.exists(dir2save)):\r\n    #    print(\"output already exist\")\r\n    else:\r\n        try:\r\n            os.makedirs(dir2save)\r\n        except OSError:\r\n            pass\r\n        real = functions.read_image(opt)\r\n        real = functions.adjust_scales2image(real, opt)\r\n        Gs, Zs, reals, NoiseAmp = functions.load_trained_pyramid(opt)\r\n        if (opt.paint_start_scale < 1) | (opt.paint_start_scale > (len(Gs)-1)):\r\n            print(\"injection scale should be between 1 and %d\" % (len(Gs)-1))\r\n        else:\r\n            ref = functions.read_image_dir('%s/%s' % (opt.ref_dir, opt.ref_name), opt)\r\n            if ref.shape[3] != real.shape[3]:\r\n                ref = imresize_to_shape(ref, [real.shape[2], real.shape[3]], opt)\r\n                ref = ref[:, :, :real.shape[2], :real.shape[3]]\r\n\r\n            N = len(reals) - 1\r\n            n = opt.paint_start_scale\r\n            in_s = imresize(ref, pow(opt.scale_factor, (N - n + 1)), opt)\r\n            in_s = in_s[:, :, :reals[n - 1].shape[2], :reals[n - 1].shape[3]]\r\n            in_s = imresize(in_s, 1 / opt.scale_factor, opt)\r\n            in_s = in_s[:, :, :reals[n].shape[2], :reals[n].shape[3]]\r\n            if opt.quantization_flag:\r\n                opt.mode = 'paint_train'\r\n                dir2trained_model = functions.generate_dir2save(opt)\r\n                # N = len(reals) - 1\r\n                # n = opt.paint_start_scale\r\n                real_s = imresize(real, pow(opt.scale_factor, (N - n)), opt)\r\n                real_s = real_s[:, :, :reals[n].shape[2], :reals[n].shape[3]]\r\n                real_quant, centers = functions.quant(real_s, opt.device)\r\n                plt.imsave('%s/real_quant.png' % dir2save, functions.convert_image_np(real_quant), vmin=0, vmax=1)\r\n                plt.imsave('%s/in_paint.png' % dir2save, functions.convert_image_np(in_s), vmin=0, vmax=1)\r\n                in_s = functions.quant2centers(ref, centers)\r\n                in_s = imresize(in_s, pow(opt.scale_factor, (N - n)), opt)\r\n                # in_s = in_s[:, :, :reals[n - 1].shape[2], :reals[n - 1].shape[3]]\r\n                # in_s = imresize(in_s, 1 / opt.scale_factor, opt)\r\n                in_s = in_s[:, :, :reals[n].shape[2], :reals[n].shape[3]]\r\n                plt.imsave('%s/in_paint_quant.png' % dir2save, functions.convert_image_np(in_s), vmin=0, vmax=1)\r\n                if (os.path.exists(dir2trained_model)):\r\n                    # print('Trained model does not exist, training SinGAN for SR')\r\n                    Gs, Zs, reals, NoiseAmp = functions.load_trained_pyramid(opt)\r\n                    opt.mode = 'paint2image'\r\n                else:\r\n                    train_paint(opt, Gs, Zs, reals, NoiseAmp, centers, opt.paint_start_scale)\r\n                    opt.mode = 'paint2image'\r\n            out = SinGAN_generate(Gs[n:], Zs[n:], reals, NoiseAmp[n:], opt, in_s, n=n, num_samples=1)\r\n            plt.imsave('%s/start_scale=%d.png' % (dir2save, opt.paint_start_scale), functions.convert_image_np(out.detach()), vmin=0, vmax=1)\r\n\r\n\r\n\r\n\r\n\r\n"
        },
        {
          "name": "random_samples.py",
          "type": "blob",
          "size": 2.431640625,
          "content": "from config import get_arguments\r\nfrom SinGAN.manipulate import *\r\nfrom SinGAN.training import *\r\nfrom SinGAN.imresize import imresize\r\nimport SinGAN.functions as functions\r\n\r\n\r\nif __name__ == '__main__':\r\n    parser = get_arguments()\r\n    parser.add_argument('--input_dir', help='input image dir', default='Input/Images')\r\n    parser.add_argument('--input_name', help='input image name', required=True)\r\n    parser.add_argument('--mode', help='random_samples | random_samples_arbitrary_sizes', default='train', required=True)\r\n    # for random_samples:\r\n    parser.add_argument('--gen_start_scale', type=int, help='generation start scale', default=0)\r\n    # for random_samples_arbitrary_sizes:\r\n    parser.add_argument('--scale_h', type=float, help='horizontal resize factor for random samples', default=1.5)\r\n    parser.add_argument('--scale_v', type=float, help='vertical resize factor for random samples', default=1)\r\n    opt = parser.parse_args()\r\n    opt = functions.post_config(opt)\r\n    Gs = []\r\n    Zs = []\r\n    reals = []\r\n    NoiseAmp = []\r\n    dir2save = functions.generate_dir2save(opt)\r\n    if dir2save is None:\r\n        print('task does not exist')\r\n    elif (os.path.exists(dir2save)):\r\n        if opt.mode == 'random_samples':\r\n            print('random samples for image %s, start scale=%d, already exist' % (opt.input_name, opt.gen_start_scale))\r\n        elif opt.mode == 'random_samples_arbitrary_sizes':\r\n            print('random samples for image %s at size: scale_h=%f, scale_v=%f, already exist' % (opt.input_name, opt.scale_h, opt.scale_v))\r\n    else:\r\n        try:\r\n            os.makedirs(dir2save)\r\n        except OSError:\r\n            pass\r\n        if opt.mode == 'random_samples':\r\n            real = functions.read_image(opt)\r\n            functions.adjust_scales2image(real, opt)\r\n            Gs, Zs, reals, NoiseAmp = functions.load_trained_pyramid(opt)\r\n            in_s = functions.generate_in2coarsest(reals,1,1,opt)\r\n            SinGAN_generate(Gs, Zs, reals, NoiseAmp, opt, gen_start_scale=opt.gen_start_scale)\r\n\r\n        elif opt.mode == 'random_samples_arbitrary_sizes':\r\n            real = functions.read_image(opt)\r\n            functions.adjust_scales2image(real, opt)\r\n            Gs, Zs, reals, NoiseAmp = functions.load_trained_pyramid(opt)\r\n            in_s = functions.generate_in2coarsest(reals,opt.scale_v,opt.scale_h,opt)\r\n            SinGAN_generate(Gs, Zs, reals, NoiseAmp, opt, in_s, scale_v=opt.scale_v, scale_h=opt.scale_h)\r\n\r\n\r\n\r\n\r\n\r\n"
        },
        {
          "name": "requirements.txt",
          "type": "blob",
          "size": 0.0654296875,
          "content": "matplotlib\nscikit-image\nscikit-learn\nscipy\nnumpy\ntorch\ntorchvision\n"
        }
      ]
    }
  ]
}