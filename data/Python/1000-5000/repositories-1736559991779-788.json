{
  "metadata": {
    "timestamp": 1736559991779,
    "page": 788,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjc5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "CyberPunkMetalHead/Binance-volatility-trading-bot",
      "stars": 3438,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.111328125,
          "content": "creds.yml\ntrades.txt\n\n__*__\n\n# Dont upload json files\n*.json\n\n# Virtual environment\n.venv\n\n# IDE settings\n.vscode\n"
        },
        {
          "name": "Binance Detect Moonings.py",
          "type": "blob",
          "size": 22.2509765625,
          "content": "\"\"\"\nDisclaimer\n\nAll investment strategies and investments involve risk of loss.\nNothing contained in this program, scripts, code or repositoy should be\nconstrued as investment advice.Any reference to an investment's past or\npotential performance is not, and should not be construed as, a recommendation\nor as a guarantee of any specific outcome or profit.\n\nBy using this program you accept all liabilities,\nand that no claims can be made against the developers,\nor others connected with the program.\n\"\"\"\n\n\n# use for environment variables\nimport os\n\n# use if needed to pass args to external modules\nimport sys\n\n# used to create threads & dynamic loading of modules\nimport threading\nimport importlib\n\n# used for directory handling\nimport glob\n\n# Needed for colorful console output Install with: python3 -m pip install colorama (Mac/Linux) or pip install colorama (PC)\nfrom colorama import init\ninit()\n\n# needed for the binance API / websockets / Exception handling\nfrom binance.client import Client\nfrom binance.exceptions import BinanceAPIException\nfrom requests.exceptions import ReadTimeout, ConnectionError\n\n# used for dates\nfrom datetime import date, datetime, timedelta\nimport time\n\n# used to repeatedly execute the code\nfrom itertools import count\n\n# used to store trades and sell assets\nimport json\n\n# Load helper modules\nfrom helpers.parameters import (\n    parse_args, load_config\n)\n\n# Load creds modules\nfrom helpers.handle_creds import (\n    load_correct_creds, test_api_key\n)\n\n\n# for colourful logging to the console\nclass txcolors:\n    BUY = '\\033[92m'\n    WARNING = '\\033[93m'\n    SELL_LOSS = '\\033[91m'\n    SELL_PROFIT = '\\033[32m'\n    DIM = '\\033[2m\\033[35m'\n    DEFAULT = '\\033[39m'\n\n\n# tracks profit/loss each session\nglobal session_profit\nsession_profit = 0\n\n\n# print with timestamps\nold_out = sys.stdout\nclass St_ampe_dOut:\n    \"\"\"Stamped stdout.\"\"\"\n    nl = True\n    def write(self, x):\n        \"\"\"Write function overloaded.\"\"\"\n        if x == '\\n':\n            old_out.write(x)\n            self.nl = True\n        elif self.nl:\n            old_out.write(f'{txcolors.DIM}[{str(datetime.now().replace(microsecond=0))}]{txcolors.DEFAULT} {x}')\n            self.nl = False\n        else:\n            old_out.write(x)\n\n    def flush(self):\n        pass\n\nsys.stdout = St_ampe_dOut()\n\n\ndef get_price(add_to_historical=True):\n    '''Return the current price for all coins on binance'''\n\n    global historical_prices, hsp_head\n\n    initial_price = {}\n    prices = client.get_all_tickers()\n\n    for coin in prices:\n\n        if CUSTOM_LIST:\n            if any(item + PAIR_WITH == coin['symbol'] for item in tickers) and all(item not in coin['symbol'] for item in FIATS):\n                initial_price[coin['symbol']] = { 'price': coin['price'], 'time': datetime.now()}\n        else:\n            if PAIR_WITH in coin['symbol'] and all(item not in coin['symbol'] for item in FIATS):\n                initial_price[coin['symbol']] = { 'price': coin['price'], 'time': datetime.now()}\n\n    if add_to_historical:\n        hsp_head += 1\n\n        if hsp_head == RECHECK_INTERVAL:\n            hsp_head = 0\n\n        historical_prices[hsp_head] = initial_price\n\n    return initial_price\n\n\ndef wait_for_price():\n    '''calls the initial price and ensures the correct amount of time has passed\n    before reading the current price again'''\n\n    global historical_prices, hsp_head, volatility_cooloff\n\n    volatile_coins = {}\n    externals = {}\n\n    coins_up = 0\n    coins_down = 0\n    coins_unchanged = 0\n\n    pause_bot()\n\n    if historical_prices[hsp_head]['BNB' + PAIR_WITH]['time'] > datetime.now() - timedelta(minutes=float(TIME_DIFFERENCE / RECHECK_INTERVAL)):\n\n        # sleep for exactly the amount of time required\n        time.sleep((timedelta(minutes=float(TIME_DIFFERENCE / RECHECK_INTERVAL)) - (datetime.now() - historical_prices[hsp_head]['BNB' + PAIR_WITH]['time'])).total_seconds())\n\n    print(f'Working...Session profit:{session_profit:.2f}% Est:${(QUANTITY * session_profit)/100:.2f}')\n\n    # retreive latest prices\n    get_price()\n\n    # calculate the difference in prices\n    for coin in historical_prices[hsp_head]:\n\n        # minimum and maximum prices over time period\n        min_price = min(historical_prices, key = lambda x: float(\"inf\") if x is None else float(x[coin]['price']))\n        max_price = max(historical_prices, key = lambda x: -1 if x is None else float(x[coin]['price']))\n\n        threshold_check = (-1.0 if min_price[coin]['time'] > max_price[coin]['time'] else 1.0) * (float(max_price[coin]['price']) - float(min_price[coin]['price'])) / float(min_price[coin]['price']) * 100\n\n        # each coin with higher gains than our CHANGE_IN_PRICE is added to the volatile_coins dict if less than MAX_COINS is not reached.\n        if threshold_check > CHANGE_IN_PRICE:\n            coins_up +=1\n\n            if coin not in volatility_cooloff:\n                volatility_cooloff[coin] = datetime.now() - timedelta(minutes=TIME_DIFFERENCE)\n\n            # only include coin as volatile if it hasn't been picked up in the last TIME_DIFFERENCE minutes already\n            if datetime.now() >= volatility_cooloff[coin] + timedelta(minutes=TIME_DIFFERENCE):\n                volatility_cooloff[coin] = datetime.now()\n\n                if len(coins_bought) + len(volatile_coins) < MAX_COINS or MAX_COINS == 0:\n                    volatile_coins[coin] = round(threshold_check, 3)\n                    print(f'{coin} has gained {volatile_coins[coin]}% within the last {TIME_DIFFERENCE} minutes, calculating volume in {PAIR_WITH}')\n\n                else:\n                    print(f'{txcolors.WARNING}{coin} has gained {round(threshold_check, 3)}% within the last {TIME_DIFFERENCE} minutes, but you are holding max number of coins{txcolors.DEFAULT}')\n\n        elif threshold_check < CHANGE_IN_PRICE:\n            coins_down +=1\n\n        else:\n            coins_unchanged +=1\n\n    # Disabled until fix\n    #print(f'Up: {coins_up} Down: {coins_down} Unchanged: {coins_unchanged}')\n\n    # Here goes new code for external signalling\n    externals = external_signals()\n    exnumber = 0\n\n    for excoin in externals:\n        if excoin not in volatile_coins and excoin not in coins_bought and \\\n                (len(coins_bought) + exnumber + len(volatile_coins)) < MAX_COINS:\n            volatile_coins[excoin] = 1\n            exnumber +=1\n            print(f'External signal received on {excoin}, calculating volume in {PAIR_WITH}')\n\n    return volatile_coins, len(volatile_coins), historical_prices[hsp_head]\n\n\ndef external_signals():\n    external_list = {}\n    signals = {}\n\n    # check directory and load pairs from files into external_list\n    signals = glob.glob(\"signals/*.exs\")\n    for filename in signals:\n        for line in open(filename):\n            symbol = line.strip()\n            external_list[symbol] = symbol\n        try:\n            os.remove(filename)\n        except:\n            if DEBUG: print(f'{txcolors.WARNING}Could not remove external signalling file{txcolors.DEFAULT}')\n\n    return external_list\n\n\ndef pause_bot():\n    '''Pause the script when exeternal indicators detect a bearish trend in the market'''\n    global bot_paused, session_profit, hsp_head\n\n    # start counting for how long the bot's been paused\n    start_time = time.perf_counter()\n\n    while os.path.isfile(\"signals/paused.exc\"):\n\n        if bot_paused == False:\n            print(f'{txcolors.WARNING}Pausing buying due to change in market conditions, stop loss and take profit will continue to work...{txcolors.DEFAULT}')\n            bot_paused = True\n\n        # Sell function needs to work even while paused\n        coins_sold = sell_coins()\n        remove_from_portfolio(coins_sold)\n        get_price(True)\n\n        # pausing here\n        if hsp_head == 1: print(f'Paused...Session profit:{session_profit:.2f}% Est:${(QUANTITY * session_profit)/100:.2f}')\n        time.sleep((TIME_DIFFERENCE * 60) / RECHECK_INTERVAL)\n\n    else:\n        # stop counting the pause time\n        stop_time = time.perf_counter()\n        time_elapsed = timedelta(seconds=int(stop_time-start_time))\n\n        # resume the bot and ser pause_bot to False\n        if  bot_paused == True:\n            print(f'{txcolors.WARNING}Resuming buying due to change in market conditions, total sleep time: {time_elapsed}{txcolors.DEFAULT}')\n            bot_paused = False\n\n    return\n\n\ndef convert_volume():\n    '''Converts the volume given in QUANTITY from USDT to the each coin's volume'''\n\n    volatile_coins, number_of_coins, last_price = wait_for_price()\n    lot_size = {}\n    volume = {}\n\n    for coin in volatile_coins:\n\n        # Find the correct step size for each coin\n        # max accuracy for BTC for example is 6 decimal points\n        # while XRP is only 1\n        try:\n            info = client.get_symbol_info(coin)\n            step_size = info['filters'][2]['stepSize']\n            lot_size[coin] = step_size.index('1') - 1\n\n            if lot_size[coin] < 0:\n                lot_size[coin] = 0\n\n        except:\n            pass\n\n        # calculate the volume in coin from QUANTITY in USDT (default)\n        volume[coin] = float(QUANTITY / float(last_price[coin]['price']))\n\n        # define the volume with the correct step size\n        if coin not in lot_size:\n            volume[coin] = float('{:.1f}'.format(volume[coin]))\n\n        else:\n            # if lot size has 0 decimal points, make the volume an integer\n            if lot_size[coin] == 0:\n                volume[coin] = int(volume[coin])\n            else:\n                volume[coin] = float('{:.{}f}'.format(volume[coin], lot_size[coin]))\n\n    return volume, last_price\n\n\ndef buy():\n    '''Place Buy market orders for each volatile coin found'''\n    volume, last_price = convert_volume()\n    orders = {}\n\n    for coin in volume:\n\n        # only buy if the there are no active trades on the coin\n        if coin not in coins_bought:\n            print(f\"{txcolors.BUY}Preparing to buy {volume[coin]} {coin}{txcolors.DEFAULT}\")\n\n            if TEST_MODE:\n                orders[coin] = [{\n                    'symbol': coin,\n                    'orderId': 0,\n                    'time': datetime.now().timestamp()\n                }]\n\n                # Log trade\n                if LOG_TRADES:\n                    write_log(f\"Buy : {volume[coin]} {coin} - {last_price[coin]['price']}\")\n\n                continue\n\n            # try to create a real order if the test orders did not raise an exception\n            try:\n                buy_limit = client.create_order(\n                    symbol = coin,\n                    side = 'BUY',\n                    type = 'MARKET',\n                    quantity = volume[coin]\n                )\n\n            # error handling here in case position cannot be placed\n            except Exception as e:\n                print(e)\n\n            # run the else block if the position has been placed and return order info\n            else:\n                orders[coin] = client.get_all_orders(symbol=coin, limit=1)\n\n                # binance sometimes returns an empty list, the code will wait here until binance returns the order\n                while orders[coin] == []:\n                    print('Binance is being slow in returning the order, calling the API again...')\n\n                    orders[coin] = client.get_all_orders(symbol=coin, limit=1)\n                    time.sleep(1)\n\n                else:\n                    print('Order returned, saving order to file')\n\n                    # Log trade\n                    if LOG_TRADES:\n                        write_log(f\"Buy : {volume[coin]} {coin} - {last_price[coin]['price']}\")\n\n\n        else:\n            print(f'Signal detected, but there is already an active trade on {coin}')\n\n    return orders, last_price, volume\n\n\ndef sell_coins():\n    '''sell coins that have reached the STOP LOSS or TAKE PROFIT threshold'''\n\n    global hsp_head, session_profit\n\n    last_price = get_price(False) # don't populate rolling window\n    #last_price = get_price(add_to_historical=True) # don't populate rolling window\n    coins_sold = {}\n\n    for coin in list(coins_bought):\n        # define stop loss and take profit\n        TP = float(coins_bought[coin]['bought_at']) + (float(coins_bought[coin]['bought_at']) * coins_bought[coin]['take_profit']) / 100\n        SL = float(coins_bought[coin]['bought_at']) + (float(coins_bought[coin]['bought_at']) * coins_bought[coin]['stop_loss']) / 100\n\n\n        LastPrice = float(last_price[coin]['price'])\n        BuyPrice = float(coins_bought[coin]['bought_at'])\n        PriceChange = float((LastPrice - BuyPrice) / BuyPrice * 100)\n\n        # check that the price is above the take profit and readjust SL and TP accordingly if trialing stop loss used\n        if LastPrice > TP and USE_TRAILING_STOP_LOSS:\n\n            # increasing TP by TRAILING_TAKE_PROFIT (essentially next time to readjust SL)\n            coins_bought[coin]['take_profit'] = PriceChange + TRAILING_TAKE_PROFIT\n            coins_bought[coin]['stop_loss'] = coins_bought[coin]['take_profit'] - TRAILING_STOP_LOSS\n            if DEBUG: print(f\"{coin} TP reached, adjusting TP {coins_bought[coin]['take_profit']:.2f}  and SL {coins_bought[coin]['stop_loss']:.2f} accordingly to lock-in profit\")\n            continue\n\n        # check that the price is below the stop loss or above take profit (if trailing stop loss not used) and sell if this is the case\n        if LastPrice < SL or LastPrice > TP and not USE_TRAILING_STOP_LOSS:\n            print(f\"{txcolors.SELL_PROFIT if PriceChange >= 0. else txcolors.SELL_LOSS}TP or SL reached, selling {coins_bought[coin]['volume']} {coin} - {BuyPrice} - {LastPrice} : {PriceChange-(TRADING_FEE*2):.2f}% Est:${(QUANTITY*(PriceChange-(TRADING_FEE*2)))/100:.2f}{txcolors.DEFAULT}\")\n\n            # try to create a real order\n            try:\n\n                if not TEST_MODE:\n                    sell_coins_limit = client.create_order(\n                        symbol = coin,\n                        side = 'SELL',\n                        type = 'MARKET',\n                        quantity = coins_bought[coin]['volume']\n\n                    )\n\n            # error handling here in case position cannot be placed\n            except Exception as e:\n                print(e)\n\n            # run the else block if coin has been sold and create a dict for each coin sold\n            else:\n                coins_sold[coin] = coins_bought[coin]\n\n                # prevent system from buying this coin for the next TIME_DIFFERENCE minutes\n                volatility_cooloff[coin] = datetime.now()\n\n                # Log trade\n                if LOG_TRADES:\n                    profit = ((LastPrice - BuyPrice) * coins_sold[coin]['volume'])* (1-(TRADING_FEE*2)) # adjust for trading fee here\n                    write_log(f\"Sell: {coins_sold[coin]['volume']} {coin} - {BuyPrice} - {LastPrice} Profit: {profit:.2f} {PriceChange-(TRADING_FEE*2):.2f}%\")\n                    session_profit=session_profit + (PriceChange-(TRADING_FEE*2))\n            continue\n\n        # no action; print once every TIME_DIFFERENCE\n        if hsp_head == 1:\n            if len(coins_bought) > 0:\n                print(f'TP or SL not yet reached, not selling {coin} for now {BuyPrice} - {LastPrice} : {txcolors.SELL_PROFIT if PriceChange >= 0. else txcolors.SELL_LOSS}{PriceChange-(TRADING_FEE*2):.2f}% Est:${(QUANTITY*(PriceChange-(TRADING_FEE*2)))/100:.2f}{txcolors.DEFAULT}')\n\n    if hsp_head == 1 and len(coins_bought) == 0: print(f'Not holding any coins')\n \n    return coins_sold\n\n\ndef update_portfolio(orders, last_price, volume):\n    '''add every coin bought to our portfolio for tracking/selling later'''\n    if DEBUG: print(orders)\n    for coin in orders:\n\n        coins_bought[coin] = {\n            'symbol': orders[coin][0]['symbol'],\n            'orderid': orders[coin][0]['orderId'],\n            'timestamp': orders[coin][0]['time'],\n            'bought_at': last_price[coin]['price'],\n            'volume': volume[coin],\n            'stop_loss': -STOP_LOSS,\n            'take_profit': TAKE_PROFIT,\n            }\n\n        # save the coins in a json file in the same directory\n        with open(coins_bought_file_path, 'w') as file:\n            json.dump(coins_bought, file, indent=4)\n\n        print(f'Order with id {orders[coin][0][\"orderId\"]} placed and saved to file')\n\n\ndef remove_from_portfolio(coins_sold):\n    '''Remove coins sold due to SL or TP from portfolio'''\n    for coin in coins_sold:\n        coins_bought.pop(coin)\n\n    with open(coins_bought_file_path, 'w') as file:\n        json.dump(coins_bought, file, indent=4)\n\n\ndef write_log(logline):\n    timestamp = datetime.now().strftime(\"%d/%m %H:%M:%S\")\n    with open(LOG_FILE,'a+') as f:\n        f.write(timestamp + ' ' + logline + '\\n')\n\nif __name__ == '__main__':\n\n    # Load arguments then parse settings\n    args = parse_args()\n    mymodule = {}\n\n    # set to false at Start\n    global bot_paused\n    bot_paused = False\n\n    DEFAULT_CONFIG_FILE = 'config.yml'\n    DEFAULT_CREDS_FILE = 'creds.yml'\n\n    config_file = args.config if args.config else DEFAULT_CONFIG_FILE\n    creds_file = args.creds if args.creds else DEFAULT_CREDS_FILE\n    parsed_config = load_config(config_file)\n    parsed_creds = load_config(creds_file)\n\n    # Default no debugging\n    DEBUG = False\n\n    # Load system vars\n    TEST_MODE = parsed_config['script_options']['TEST_MODE']\n    LOG_TRADES = parsed_config['script_options'].get('LOG_TRADES')\n    LOG_FILE = parsed_config['script_options'].get('LOG_FILE')\n    DEBUG_SETTING = parsed_config['script_options'].get('DEBUG')\n    AMERICAN_USER = parsed_config['script_options'].get('AMERICAN_USER')\n\n    # Load trading vars\n    PAIR_WITH = parsed_config['trading_options']['PAIR_WITH']\n    QUANTITY = parsed_config['trading_options']['QUANTITY']\n    MAX_COINS = parsed_config['trading_options']['MAX_COINS']\n    FIATS = parsed_config['trading_options']['FIATS']\n    TIME_DIFFERENCE = parsed_config['trading_options']['TIME_DIFFERENCE']\n    RECHECK_INTERVAL = parsed_config['trading_options']['RECHECK_INTERVAL']\n    CHANGE_IN_PRICE = parsed_config['trading_options']['CHANGE_IN_PRICE']\n    STOP_LOSS = parsed_config['trading_options']['STOP_LOSS']\n    TAKE_PROFIT = parsed_config['trading_options']['TAKE_PROFIT']\n    CUSTOM_LIST = parsed_config['trading_options']['CUSTOM_LIST']\n    TICKERS_LIST = parsed_config['trading_options']['TICKERS_LIST']\n    USE_TRAILING_STOP_LOSS = parsed_config['trading_options']['USE_TRAILING_STOP_LOSS']\n    TRAILING_STOP_LOSS = parsed_config['trading_options']['TRAILING_STOP_LOSS']\n    TRAILING_TAKE_PROFIT = parsed_config['trading_options']['TRAILING_TAKE_PROFIT']\n    TRADING_FEE = parsed_config['trading_options']['TRADING_FEE']\n    SIGNALLING_MODULES = parsed_config['trading_options']['SIGNALLING_MODULES']\n    if DEBUG_SETTING or args.debug:\n        DEBUG = True\n\n    # Load creds for correct environment\n    access_key, secret_key = load_correct_creds(parsed_creds)\n\n    if DEBUG:\n        print(f'loaded config below\\n{json.dumps(parsed_config, indent=4)}')\n        print(f'Your credentials have been loaded from {creds_file}')\n\n\n    # Authenticate with the client, Ensure API key is good before continuing\n    if AMERICAN_USER:\n        client = Client(access_key, secret_key, tld='us')\n    else:\n        client = Client(access_key, secret_key)\n        \n    # If the users has a bad / incorrect API key.\n    # this will stop the script from starting, and display a helpful error.\n    api_ready, msg = test_api_key(client, BinanceAPIException)\n    if api_ready is not True:\n       exit(f'{txcolors.SELL_LOSS}{msg}{txcolors.DEFAULT}')\n\n    # Use CUSTOM_LIST symbols if CUSTOM_LIST is set to True\n    if CUSTOM_LIST: tickers=[line.strip() for line in open(TICKERS_LIST)]\n\n    # try to load all the coins bought by the bot if the file exists and is not empty\n    coins_bought = {}\n\n    # path to the saved coins_bought file\n    coins_bought_file_path = 'coins_bought.json'\n\n    # rolling window of prices; cyclical queue\n    historical_prices = [None] * (TIME_DIFFERENCE * RECHECK_INTERVAL)\n    hsp_head = -1\n\n    # prevent including a coin in volatile_coins if it has already appeared there less than TIME_DIFFERENCE minutes ago\n    volatility_cooloff = {}\n\n    # use separate files for testing and live trading\n    if TEST_MODE:\n        coins_bought_file_path = 'test_' + coins_bought_file_path\n\n    # if saved coins_bought json file exists and it's not empty then load it\n    if os.path.isfile(coins_bought_file_path) and os.stat(coins_bought_file_path).st_size!= 0:\n        with open(coins_bought_file_path) as file:\n                coins_bought = json.load(file)\n\n    print('Press Ctrl-Q to stop the script')\n\n    if not TEST_MODE:\n        if not args.notimeout: # if notimeout skip this (fast for dev tests)\n            print('WARNING: You are using the Mainnet and live funds. Waiting 30 seconds as a security measure')\n            time.sleep(30)\n\n    signals = glob.glob(\"signals/*.exs\")\n    for filename in signals:\n        for line in open(filename):\n            try:\n                os.remove(filename)\n            except:\n                if DEBUG: print(f'{txcolors.WARNING}Could not remove external signalling file {filename}{txcolors.DEFAULT}')\n\n    if os.path.isfile(\"signals/paused.exc\"):\n        try:\n            os.remove(\"signals/paused.exc\")\n        except:\n            if DEBUG: print(f'{txcolors.WARNING}Could not remove external signalling file {filename}{txcolors.DEFAULT}')\n\n    # load signalling modules\n    try:\n        if len(SIGNALLING_MODULES) > 0:\n            for module in SIGNALLING_MODULES:\n                print(f'Starting {module}')\n                mymodule[module] = importlib.import_module(module)\n                t = threading.Thread(target=mymodule[module].do_work, args=())\n                t.daemon = True\n                t.start()\n                time.sleep(2)\n        else:\n            print(f'No modules to load {SIGNALLING_MODULES}')\n    except Exception as e:\n        print(e)\n\n    # seed initial prices\n    get_price()\n    READ_TIMEOUT_COUNT=0\n    CONNECTION_ERROR_COUNT = 0\n    while True:\n        try:\n            orders, last_price, volume = buy()\n            update_portfolio(orders, last_price, volume)\n            coins_sold = sell_coins()\n            remove_from_portfolio(coins_sold)\n        except ReadTimeout as rt:\n            READ_TIMEOUT_COUNT += 1\n            print(f'{txcolors.WARNING}We got a timeout error from from binance. Going to re-loop. Current Count: {READ_TIMEOUT_COUNT}\\n{rt}{txcolors.DEFAULT}')\n        except ConnectionError as ce:\n            CONNECTION_ERROR_COUNT +=1 \n            print(f'{txcolors.WARNING}We got a timeout error from from binance. Going to re-loop. Current Count: {CONNECTION_ERROR_COUNT}\\n{ce}{txcolors.DEFAULT}')\n\n\n"
        },
        {
          "name": "FAQ.md",
          "type": "blob",
          "size": 0.98828125,
          "content": "# Frequently Asked Question\n\n## \n\n## Errors and solutions\n\n\n| Error   |   Solution |\n|----------|-------------|\n| `APIError(code=-1021): Timestamp for this request was 1000ms ahead of the server's time` |  Update your computer/servers ntp server to `time.nist.gov` |\n|`'NoneType' object has no attribute 'encode'`| Your API key is not correct. |\n|`Insufficient Funds` Error| Make sure you have the available USDT. Make sure you dont have lots of it on order. Ensure you QUANTITY is at least 15. |\n| Other Binance API Errors| Go take a look at the [Binance API documentation Exceptions](https://github.com/binance/binance-spot-api-docs/blob/master/errors.md) page |\n\n## Questions and Answers\n\n| Question   |   Answer |\n|----------|-------------|\n| What type of funds are required for this to work in PROD |  Ensure you account has the following: <ul><li>BNB ~$5 USD (used for fees / transactions)</li><li>Atleast X USDT matching your QUANTITYxMAX_COINS  (>$15 USD but check config for 'QUANTITY')</li></ul> |\n\n\n\n\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0498046875,
          "content": "MIT License\n\nCopyright (c) 2021 CyberPunkMetalHead\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 2.8017578125,
          "content": "# Binance Volitility Trading Bot\r\n\r\n## Description\r\nThis Binance trading bot analyses the changes in price across allÂ coins on Binance and place trades on the most volatile ones. \r\nIn addition to that, this Binance trading algorithm will also keep track of all the coins bought and sell them according to your specified Stop Loss and Take Profit.\r\n\r\n\r\n\r\nThe bot will listen to changes in price accross all coins on Binance. By default, we're only picking USDT pairs. We're excluding Margin (like BTCDOWNUSDT) and Fiat pairs\r\n\r\n> Information below is an example and is all configurable\r\n\r\n- The bot checks if the any coin has gone up by more than 3% in the last 5 minutes\r\n- The bot will buy 100 USDT of the most volatile coins on Binance\r\n- The bot will sell at 6% profit or 3% stop loss\r\n\r\n\r\n<br><br>\r\n**UPDATE: The Binance Volatility Bot is now Available with a UI and all the bells and whistles on [Algorithmic Cryptocurrency Trading Platform](https://aesircrypto.com) Aesir**\r\n<br><br>\r\n\r\n\r\n\r\nYou can follow the [Binance volatility bot guide](https://www.cryptomaton.org/2021/05/08/how-to-code-a-binance-trading-bot-that-detects-the-most-volatile-coins-on-binance/) for a step-by-step walkthrough of the bot development.\r\n\r\n## READ BEFORE USE\r\n1. If you use the `TEST_MODE: False` in your config, you will be using REAL money.\r\n2. To ensure you do not do this, ALWAYS check the `TEST_MODE` configuration item in the config.yml file..\r\n3. This is a framework for users to modify and adapt to their overall strategy and needs, and in no way a turn-key solution.\r\n4. Depending on the current market, the default config might not do much, so you will have to adapt it to your own strategy.\r\n\r\n## Usage\r\nPlease checkout our wiki pages:\r\n\r\n- [Setup Guide](https://github.com/CyberPunkMetalHead/Binance-volatility-trading-bot/wiki/Setup-Guide)\r\n- [Bot Strategy Guide](https://github.com/CyberPunkMetalHead/Binance-volatility-trading-bot/wiki/Bot-Strategy-Guide)\r\n- [Configuration Guide](https://github.com/CyberPunkMetalHead/Binance-volatility-trading-bot/wiki/Configuration)\r\n\r\n## Troubleshooting\r\n\r\n1. Read the [FAQ](FAQ.md)\r\n2. Open an issue / check us out on `#troubleshooting` at [Discord](https://discord.gg/buD27Dmvu3) ðŸš€ \r\n    - Do not spam, do not berate, we are all humans like you, this is an open source project, not a full time job. \r\n\r\n## ðŸ’¥ Disclaimer\r\n\r\nAll investment strategies and investments involve risk of loss. \r\n**Nothing contained in this program, scripts, code or repository should be construed as investment advice.**\r\nAny reference to an investment's past or potential performance is not, \r\nand should not be construed as, a recommendation or as a guarantee of \r\nany specific outcome or profit.\r\nBy using this program you accept all liabilities, and that no claims can be made against the developers or others connected with the program.\r\n"
        },
        {
          "name": "config.yml",
          "type": "blob",
          "size": 2.46875,
          "content": "# These options apply to how the script will operate.\nscript_options:\n  # Switch between testnet and mainnet\n  # Setting this to False will use REAL funds, use at your own risk\n  TEST_MODE: True\n  LOG_TRADES: True\n  LOG_FILE: 'trades.txt'\n\n  # Set this to true if you are accessing binance from within the United States of America\n  # Need to change TLD\n  AMERICAN_USER: False\n\n\n# These options apply to the trading methods the script executes\ntrading_options:\n \n  # select your base currency to use for trading (trade for example USDT pairs)\n  PAIR_WITH: USDT\n\n  # Total amount per trade (your base currency balance must be at least MAX_COINS * QUANTITY)\n  # Binance uses a minimum of 10 USDT per trade, add a bit extra to enable selling if the price drops.\n  # Recommended: no less than 12 USDT. Suggested: 15 or more.\n  QUANTITY: 15\n\n  # List of trading pairs to exclude\n  # by default we're excluding the most popular fiat pairs\n  FIATS:\n    - EURUSDT\n    - GBPUSDT\n    - JPYUSDT\n    - USDUSDT\n    - DOWN\n    - UP\n\n  # Maximum number of trade 'slots' at any time (your USDT balance must be at least MAX_COINS * QUANTITY)\n  MAX_COINS: 7\n\n  # the amount of time in MINUTES to calculate the difference from the current price (minimum: 1).\n  TIME_DIFFERENCE: 2\n\n  # Number of times to check for TP/SL during each TIME_DIFFERENCE (minimum: 1).\n  # Don't spam the Binance API, you will be banned (max 1200 requests per minute per IP).\n  RECHECK_INTERVAL: 10\n\n  # the difference in % between the first and second checks for the price.\n  CHANGE_IN_PRICE: 10\n\n  # define in % when to sell a coin that's not making a profit.\n  STOP_LOSS: 5\n\n  # define in % when to take profit on a profitable coin.\n  TAKE_PROFIT: .8\n\n  # Use custom tickers.txt list for filtering pairs.\n  CUSTOM_LIST: True\n   \n  # Name of custom tickers list\n  TICKERS_LIST: 'tickers.txt'\n   \n  # whether to use trailing stop loss or not; default is True\n  USE_TRAILING_STOP_LOSS: True\n\n  # when hit TAKE_PROFIT, move STOP_LOSS to TRAILING_STOP_LOSS percentage points below TAKE_PROFIT hence locking in profit\n  # when hit TAKE_PROFIT, move TAKE_PROFIT up by TRAILING_TAKE_PROFIT percentage points\n  TRAILING_STOP_LOSS: .4\n  TRAILING_TAKE_PROFIT: .1\n  \n  # Trading fee in % per trade.\n  # If using 0.75% (using BNB for fees) you must have BNB in your account to cover trading fees.\n  # If using BNB for fees, it MUST be enabled in your Binance 'Dashboard' page (checkbox).\n  TRADING_FEE: .075\n  \n  SIGNALLING_MODULES:\n    - pausebotmod\n    - signalsamplemod\n    \n  \n"
        },
        {
          "name": "creds.example.yml",
          "type": "blob",
          "size": 0.1943359375,
          "content": "# Ensure your keys and values have a space between them\n# Example:\n# Bad:\n#   access_key:myaccess_key\n# Good:\n#   access_key: myaccess_key \n\n\nprod:\n  access_key: replace_me\n  secret_key: replace_me\n\n"
        },
        {
          "name": "custsignalmod.py",
          "type": "blob",
          "size": 3.1455078125,
          "content": "# Available indicators here: https://python-tradingview-ta.readthedocs.io/en/latest/usage.html#retrieving-the-analysis\r\n\r\nfrom tradingview_ta import TA_Handler, Interval, Exchange\r\n# use for environment variables\r\nimport os\r\n# use if needed to pass args to external modules\r\nimport sys\r\n# used for directory handling\r\nimport glob\r\nimport time\r\nimport threading\r\n\r\nOSC_INDICATORS = ['MACD', 'Stoch.RSI', 'Mom'] # Indicators to use in Oscillator analysis\r\nOSC_THRESHOLD = 2 # Must be less or equal to number of items in OSC_INDICATORS \r\nMA_INDICATORS = ['EMA10', 'EMA20'] # Indicators to use in Moving averages analysis\r\nMA_THRESHOLD = 2 # Must be less or equal to number of items in MA_INDICATORS \r\nINTERVAL = Interval.INTERVAL_5_MINUTES #Timeframe for analysis\r\n\r\nEXCHANGE = 'BINANCE'\r\nSCREENER = 'CRYPTO'\r\nPAIR_WITH = 'USDT'\r\nTICKERS = 'signalsample.txt'\r\nTIME_TO_WAIT = 4 # Minutes to wait between analysis\r\nFULL_LOG = False # List analysis result to console\r\n\r\ndef analyze(pairs):\r\n    signal_coins = {}\r\n    analysis = {}\r\n    handler = {}\r\n    \r\n    if os.path.exists('signals/custsignalmod.exs'):\r\n        os.remove('signals/custsignalmod.exs')\r\n\r\n    for pair in pairs:\r\n        handler[pair] = TA_Handler(\r\n            symbol=pair,\r\n            exchange=EXCHANGE,\r\n            screener=SCREENER,\r\n            interval=INTERVAL,\r\n            timeout= 10)\r\n       \r\n    for pair in pairs:\r\n        try:\r\n            analysis = handler[pair].get_analysis()\r\n        except Exception as e:\r\n            print(\"Signalsample:\")\r\n            print(\"Exception:\")\r\n            print(e)\r\n            print (f'Coin: {pair}')\r\n            print (f'handler: {handler[pair]}')\r\n\r\n        oscCheck=0\r\n        maCheck=0\r\n        for indicator in OSC_INDICATORS:\r\n            if analysis.oscillators ['COMPUTE'][indicator] == 'BUY': oscCheck +=1\r\n      \t\r\n        for indicator in MA_INDICATORS:\r\n            if analysis.moving_averages ['COMPUTE'][indicator] == 'BUY': maCheck +=1\t\t\r\n\r\n        if FULL_LOG:\r\n            print(f'Custsignalmod:{pair} Oscillators:{oscCheck}/{len(OSC_INDICATORS)} Moving averages:{maCheck}/{len(MA_INDICATORS)}')\r\n        \r\n        if oscCheck >= OSC_THRESHOLD and maCheck >= MA_THRESHOLD:\r\n                signal_coins[pair] = pair\r\n                print(f'Custsignalmod: Signal detected on {pair} at {oscCheck}/{len(OSC_INDICATORS)} oscillators and {maCheck}/{len(MA_INDICATORS)} moving averages.')\r\n                with open('signals/custsignalmod.exs','a+') as f:\r\n                    f.write(pair + '\\n')\r\n    \r\n    return signal_coins\r\n\r\ndef do_work():\r\n    signal_coins = {}\r\n    pairs = {}\r\n\r\n    pairs=[line.strip() for line in open(TICKERS)]\r\n    for line in open(TICKERS):\r\n        pairs=[line.strip() + PAIR_WITH for line in open(TICKERS)] \r\n    \r\n    while True:\r\n        if not threading.main_thread().is_alive(): exit()\r\n        print(f'Custsignalmod: Analyzing {len(pairs)} coins')\r\n        signal_coins = analyze(pairs)\r\n        print(f'Custsignalmod: {len(signal_coins)} coins above {OSC_THRESHOLD}/{len(OSC_INDICATORS)} oscillators and {MA_THRESHOLD}/{len(MA_INDICATORS)} moving averages Waiting {TIME_TO_WAIT} minutes for next analysis.')\r\n        time.sleep((TIME_TO_WAIT*60))\r\n"
        },
        {
          "name": "helpers",
          "type": "tree",
          "content": null
        },
        {
          "name": "pausebotmod.py",
          "type": "blob",
          "size": 1.8017578125,
          "content": "from tradingview_ta import TA_Handler, Interval, Exchange\r\nimport os\r\nimport time\r\nimport threading\r\n\r\nINTERVAL = Interval.INTERVAL_1_MINUTE #Timeframe for analysis\r\n\r\nEXCHANGE = 'BINANCE'\r\nSCREENER = 'CRYPTO'\r\nSYMBOL = 'BTCUSDT'\r\nTHRESHOLD = 7 # 7 of 15 MA's indicating sell\r\nTIME_TO_WAIT = 1 # Minutes to wait between analysis\r\nFULL_LOG = False # List analysis result to console\r\n\r\ndef analyze():\r\n    analysis = {}\r\n    handler = {}\r\n    \r\n    handler = TA_Handler(\r\n            symbol=SYMBOL,\r\n            exchange=EXCHANGE,\r\n            screener=SCREENER,\r\n            interval=INTERVAL,\r\n            timeout= 10)\r\n \r\n    try:\r\n        analysis = handler.get_analysis()\r\n    except Exception as e:\r\n        print(\"pausebotmod:\")\r\n        print(\"Exception:\")\r\n        print(e)\r\n    \r\n    ma_sell = analysis.moving_averages['SELL']\r\n    if ma_sell >= THRESHOLD:\r\n        paused = True\r\n        print(f'pausebotmod: Market not looking too good, bot paused from buying {ma_sell}/{THRESHOLD} Waiting {TIME_TO_WAIT} minutes for next market checkup')\r\n    else:\r\n        print(f'pausebotmod: Market looks ok, bot is running {ma_sell}/{THRESHOLD} Waiting {TIME_TO_WAIT} minutes for next market checkup ')\r\n        paused = False\r\n\r\n    return paused\r\n#if __name__ == '__main__':\r\ndef do_work():\r\n      \r\n    while True:\r\n        if not threading.main_thread().is_alive(): exit()\r\n        # print(f'pausebotmod: Fetching market state')\r\n        paused = analyze()\r\n        if paused:\r\n            with open('signals/paused.exc','a+') as f:\r\n                f.write('yes')\r\n        else:\r\n            if os.path.isfile(\"signals/paused.exc\"):\r\n                os.remove('signals/paused.exc')\r\n                        \r\n        # print(f'pausebotmod: Waiting {TIME_TO_WAIT} minutes for next market checkup')    \r\n        time.sleep((TIME_TO_WAIT*60))\r\n"
        },
        {
          "name": "requirements.txt",
          "type": "blob",
          "size": 0.072265625,
          "content": "python-binance==0.7.9\ncolorama==0.4.4\nPyYAML==5.4.1\ntradingview-ta==3.2.3\n"
        },
        {
          "name": "signals",
          "type": "tree",
          "content": null
        },
        {
          "name": "signalsample.py",
          "type": "blob",
          "size": 3.2529296875,
          "content": "from tradingview_ta import TA_Handler, Interval, Exchange\r\n# use for environment variables\r\nimport os\r\n# use if needed to pass args to external modules\r\nimport sys\r\n# used for directory handling\r\nimport glob\r\nimport time\r\n\r\nMY_EXCHANGE = 'BINANCE'\r\nMY_SCREENER = 'CRYPTO'\r\nMY_FIRST_INTERVAL = Interval.INTERVAL_1_MINUTE\r\nMY_SECOND_INTERVAL = Interval.INTERVAL_5_MINUTES\r\nTA_BUY_THRESHOLD = 18 # How many of the 26 indicators to indicate a buy\r\nPAIR_WITH = 'USDT'\r\nTICKERS = 'signalsample.txt'\r\nTIME_TO_WAIT = 4 # Minutes to wait between analysis\r\nFULL_LOG = False # List anylysis result to console\r\n\r\ndef analyze(pairs):\r\n    taMax = 0\r\n    taMaxCoin = 'none'\r\n    signal_coins = {}\r\n    first_analysis = {}\r\n    second_analysis = {}\r\n    first_handler = {}\r\n    second_handler = {}\r\n    if os.path.exists('signals/signalsample.exs'):\r\n        os.remove('signals/signalsample.exs')\r\n\r\n    for pair in pairs:\r\n        first_handler[pair] = TA_Handler(\r\n            symbol=pair,\r\n            exchange=MY_EXCHANGE,\r\n            screener=MY_SCREENER,\r\n            interval=MY_FIRST_INTERVAL,\r\n            timeout= 10\r\n        )\r\n        second_handler[pair] = TA_Handler(\r\n            symbol=pair,\r\n            exchange=MY_EXCHANGE,\r\n            screener=MY_SCREENER,\r\n            interval=MY_SECOND_INTERVAL,\r\n            timeout= 10\r\n        )\r\n    \r\n    for pair in pairs:\r\n       \r\n        try:\r\n            first_analysis = first_handler[pair].get_analysis()\r\n            second_analysis = second_handler[pair].get_analysis()\r\n        except Exception as e:\r\n                    print(\"Exeption:\")\r\n                    print(e)\r\n                    print (f'Coin: {pair}')\r\n                    print (f'First handler: {first_handler[pair]}')\r\n                    print (f'Second handler: {second_handler[pair]}')\r\n                    tacheckS = 0\r\n                \r\n        first_tacheck = first_analysis.summary['BUY']\r\n        second_tacheck = second_analysis.summary['BUY']\r\n        if FULL_LOG:\r\n            print(f'{pair} First {first_tacheck} Second {second_tacheck}')\r\n        else:\r\n            print(\".\", end = '')\r\n\r\n        if first_tacheck > taMax:\r\n                taMax = first_tacheck\r\n                taMaxCoin = pair\r\n        if first_tacheck >= TA_BUY_THRESHOLD and second_tacheck >= TA_BUY_THRESHOLD:\r\n                signal_coins[pair] = pair\r\n                print(\"\")\r\n                print(f'Signal detected on {pair}')\r\n                with open('signals/signalsample.exs','a+') as f:\r\n                    f.write(pair + '\\n')\r\n    print(\"\")\r\n    print(f'Max signal by {taMaxCoin} at {taMax} on shortest timeframe') \r\n\r\n    return signal_coins\r\n\r\nif __name__ == '__main__':\r\n    signal_coins = {}\r\n    pairs = {}\r\n\r\n    pairs=[line.strip() for line in open(TICKERS)]\r\n    for line in open(TICKERS):\r\n        pairs=[line.strip() + PAIR_WITH for line in open(TICKERS)] \r\n    \r\n    while True:\r\n        print(f'Analyzing {len(pairs)} coins')\r\n        signal_coins = analyze(pairs)\r\n        if len(signal_coins) == 0:\r\n            print(f'No coins above {TA_BUY_THRESHOLD} threshold')\r\n        else:\r\n            print(f'{len(signal_coins)} coins above {TA_BUY_THRESHOLD} treshold on both timeframes')\r\n        print(f'Waiting {TIME_TO_WAIT} minutes for next analysis')\r\n        time.sleep((TIME_TO_WAIT*60))\r\n"
        },
        {
          "name": "signalsample.txt",
          "type": "blob",
          "size": 0.0771484375,
          "content": "BTC\r\nETH\r\nBNB\r\nADA\r\nXRP\r\nDOT\r\nICP\r\nBCH\r\nUNI\r\nLTC\r\nLINK\r\nSOL\r\nETC\r\nFIL\r\nEOS\r\nXMR"
        },
        {
          "name": "signalsamplemod.py",
          "type": "blob",
          "size": 3.380859375,
          "content": "from tradingview_ta import TA_Handler, Interval, Exchange\r\n# use for environment variables\r\nimport os\r\n# use if needed to pass args to external modules\r\nimport sys\r\n# used for directory handling\r\nimport glob\r\n\r\nimport time\r\n\r\nMY_EXCHANGE = 'BINANCE'\r\nMY_SCREENER = 'CRYPTO'\r\nMY_FIRST_INTERVAL = Interval.INTERVAL_1_MINUTE\r\nMY_SECOND_INTERVAL = Interval.INTERVAL_5_MINUTES\r\nTA_BUY_THRESHOLD = 18 # How many of the 26 indicators to indicate a buy\r\nPAIR_WITH = 'USDT'\r\nTICKERS = 'signalsample.txt'\r\nTIME_TO_WAIT = 4 # Minutes to wait between analysis\r\nFULL_LOG = False # List anylysis result to console\r\n\r\ndef analyze(pairs):\r\n    taMax = 0\r\n    taMaxCoin = 'none'\r\n    signal_coins = {}\r\n    first_analysis = {}\r\n    second_analysis = {}\r\n    first_handler = {}\r\n    second_handler = {}\r\n    if os.path.exists('signals/signalsample.exs'):\r\n        os.remove('signals/signalsample.exs')\r\n\r\n    for pair in pairs:\r\n        first_handler[pair] = TA_Handler(\r\n            symbol=pair,\r\n            exchange=MY_EXCHANGE,\r\n            screener=MY_SCREENER,\r\n            interval=MY_FIRST_INTERVAL,\r\n            timeout= 10\r\n        )\r\n        second_handler[pair] = TA_Handler(\r\n            symbol=pair,\r\n            exchange=MY_EXCHANGE,\r\n            screener=MY_SCREENER,\r\n            interval=MY_SECOND_INTERVAL,\r\n            timeout= 10\r\n        )\r\n    \r\n    for pair in pairs:\r\n       \r\n        try:\r\n            first_analysis = first_handler[pair].get_analysis()\r\n            second_analysis = second_handler[pair].get_analysis()\r\n        except Exception as e:\r\n                    print(\"Signalsample:\")\r\n                    print(\"Exception:\")\r\n                    print(e)\r\n                    print (f'Coin: {pair}')\r\n                    print (f'First handler: {first_handler[pair]}')\r\n                    print (f'Second handler: {second_handler[pair]}')\r\n                    tacheckS = 0\r\n                \r\n        first_tacheck = first_analysis.summary['BUY']\r\n        second_tacheck = second_analysis.summary['BUY']\r\n        if FULL_LOG:\r\n            print(f'Signalsample:{pair} First {first_tacheck} Second {second_tacheck}')\r\n        #else:\r\n            #print(\".\", end = '')\r\n\r\n        if first_tacheck > taMax:\r\n                taMax = first_tacheck\r\n                taMaxCoin = pair\r\n        if first_tacheck >= TA_BUY_THRESHOLD and second_tacheck >= TA_BUY_THRESHOLD:\r\n                signal_coins[pair] = pair\r\n                print(f'Signalsample: Signal detected on {pair}')\r\n                with open('signals/signalsample.exs','a+') as f:\r\n                    f.write(pair + '\\n')\r\n    print(f'Signalsample: Max signal by {taMaxCoin} at {taMax} on shortest timeframe') \r\n\r\n    return signal_coins\r\n\r\ndef do_work():\r\n    signal_coins = {}\r\n    pairs = {}\r\n\r\n    pairs=[line.strip() for line in open(TICKERS)]\r\n    for line in open(TICKERS):\r\n        pairs=[line.strip() + PAIR_WITH for line in open(TICKERS)] \r\n    \r\n    while True:\r\n        print(f'Signalsample: Analyzing {len(pairs)} coins')\r\n        signal_coins = analyze(pairs)\r\n        if len(signal_coins) == 0:\r\n            print(f'Signalsample: No coins above {TA_BUY_THRESHOLD} threshold on both timeframes. Waiting {TIME_TO_WAIT} minutes for next analysis')\r\n        else:\r\n            print(f'Signalsample: {len(signal_coins)} coins above {TA_BUY_THRESHOLD} treshold on both timeframes. Waiting {TIME_TO_WAIT} minutes for next analysis')\r\n\r\n        time.sleep((TIME_TO_WAIT*60))\r\n"
        },
        {
          "name": "tickerlists",
          "type": "tree",
          "content": null
        },
        {
          "name": "tickers.txt",
          "type": "blob",
          "size": 0.5595703125,
          "content": "1INCH\r\nAAVE\r\nADA\r\nALGO\r\nALPHA\r\nAR\r\nARRR\r\nATOM\r\nAVAX\r\nBAKE\r\nBAT\r\nBCD\r\nBCH\r\nBCHA\r\nBNB\r\nBNT\r\nBSV\r\nBTC\r\nBTCB\r\nBTCST\r\nBTG\r\nCAKE\r\nCCXX\r\nCEL\r\nCELO\r\nCHSB\r\nCOMP\r\nCRV\r\nCTC\r\nDAI\r\nDASH\r\nDCR\r\nDFI\r\nDOT\r\nEGLD\r\nENJ\r\nEOS\r\nETC\r\nETH\r\nFIL\r\nFLOW\r\nFTT\r\nGRT\r\nGT\r\nHNT\r\nHT\r\nICP\r\nICX\r\nKCS\r\nKLAY\r\nKNC\r\nKSM\r\nLEO\r\nLINK\r\nLPT\r\nLSK\r\nLTC\r\nLUNA\r\nLUSD\r\nMANA\r\nMDX\r\nMIOTA\r\nMIR\r\nMKR\r\nNANO\r\nNEAR\r\nNEO\r\nNEXO\r\nOCEAN\r\nOKB\r\nOMG\r\nONT\r\nORC\r\nPROM\r\nPUNDIX\r\nQNT\r\nQTUM\r\nRAY\r\nRENBTC\r\nRLC\r\nRUNE\r\nSNX\r\nSOL\r\nSTORJ\r\nSTX\r\nSUSHI\r\nTHETA\r\nTTT\r\nUMA\r\nUNI\r\nUST\r\nVGX\r\nWAVES\r\nWBNB\r\nWBTC\r\nWRX\r\nXMR\r\nXRP\r\nXTZ\r\nXVS\r\nXWC\r\nYFI\r\nZEC\r\nZEN\r\nZRX"
        },
        {
          "name": "utilities",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}