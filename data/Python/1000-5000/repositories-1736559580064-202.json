{
  "metadata": {
    "timestamp": 1736559580064,
    "page": 202,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjIxMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "zedr/clean-code-python",
      "stars": 4501,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.0625,
          "content": "*.md linguist-documentation=false\n*.md linguist-language=Python\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 1.70703125,
          "content": "# Byte-compiled / optimized / DLL files\n__pycache__/\n*.py[cod]\n*$py.class\n\n# C extensions\n*.so\n\n# Distribution / packaging\n.Python\nbuild/\ndevelop-eggs/\ndist/\ndownloads/\neggs/\n.eggs/\nlib/\nlib64/\nparts/\nsdist/\nvar/\nwheels/\npip-wheel-metadata/\nshare/python-wheels/\n*.egg-info/\n.installed.cfg\n*.egg\nMANIFEST\n\n# PyInstaller\n#  Usually these files are written by a python script from a template\n#  before PyInstaller builds the exe, so as to inject date/other infos into it.\n*.manifest\n*.spec\n\n# Installer logs\npip-log.txt\npip-delete-this-directory.txt\n\n# Unit test / coverage reports\nhtmlcov/\n.tox/\n.nox/\n.coverage\n.coverage.*\n.cache\nnosetests.xml\ncoverage.xml\n*.cover\n*.py,cover\n.hypothesis/\n.pytest_cache/\n\n# Translations\n*.mo\n*.pot\n\n# Django stuff:\n*.log\nlocal_settings.py\ndb.sqlite3\ndb.sqlite3-journal\n\n# Flask stuff:\ninstance/\n.webassets-cache\n\n# Scrapy stuff:\n.scrapy\n\n# Sphinx documentation\ndocs/_build/\n\n# PyBuilder\ntarget/\n\n# Jupyter Notebook\n.ipynb_checkpoints\n\n# IPython\nprofile_default/\nipython_config.py\n\n# pyenv\n.python-version\n\n# pipenv\n#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.\n#   However, in case of collaboration, if having platform-specific dependencies or dependencies\n#   having no cross-platform support, pipenv may install dependencies that don't work, or not\n#   install all needed dependencies.\n#Pipfile.lock\n\n# celery beat schedule file\ncelerybeat-schedule\n\n# SageMath parsed files\n*.sage.py\n\n# Environments\n.env\n.venv\nenv/\nvenv/\nENV/\nenv.bak/\nvenv.bak/\n\n# Spyder project settings\n.spyderproject\n.spyproject\n\n# Rope project settings\n.ropeproject\n\n# mkdocs documentation\n/site\n\n# mypy\n.mypy_cache/\n.dmypy.json\ndmypy.json\n\n# Pyre type checker\n.pyre/\n\n# VSCODE\n.vscode\n.idea\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.13671875,
          "content": "language: python\npython:\n  - \"3.8.3\"\n# command to install dependencies\ninstall:\n  - make deps\n# command to run tests\nscript:\n  - make tests\n"
        },
        {
          "name": "CONTRIBUTORS",
          "type": "blob",
          "size": 0.7099609375,
          "content": "Rigel Di Scala <zedr@zedr.com>\nZachary Anglin <zach@anglin.com>\nAirbusDriver <https://github.com/AirbusDriver>\nMicheal <https://github.com/mpkocher>\nErik OShaughnessy <https://github.com/JnyJny>\nMukhammad Karimov <https://github.com/heykarimoff>\nsitnarf <https://github.com/sitnarf>\nMiguel Gonzalez <https://github.com/migonzalvar>\nAnvar <https://github.com/arpanetus>\nMartin PavlÃ¡sek <https://github.com/mpavlase>\nShahrukh Khan <https://github.com/shahrukhx01>\nAaron Law <https://github.com/AaronLaw>\nFredson Chaves <https://github.com/fredsonchaves07>\nMartinThoma <https://github.com/MartinThoma>\nAli Bagheri <https://github.com/khodealib>\nyinruiqing <https://github.com/yinruiqing>\nYongWoo Lee <https://github.com/wooy0ng>\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0546875,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2016 Ryan McDermott\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.568359375,
          "content": ".PHONY: deps clean tests\n\nENV=.env\nPYTHON=python3\nPYTHON_VERSION=$(shell ${PYTHON} -V | cut -d \" \" -f 2 | cut -c1-3)\nSITE_PACKAGES=${ENV}/lib/python${PYTHON_VERSION}/site-packages\nIN_ENV=source ${ENV}/bin/activate;\n\ndefault: tests\n\n${ENV}:\n\t@echo \"Creating Python environment...\" >&2\n\t@${PYTHON} -m venv ${ENV}\n\t@echo \"Updating pip...\" >&2\n\t@${IN_ENV} pip install -U pip\n\n${SITE_PACKAGES}/pytest.py:\n\t@${IN_ENV} pip install -r requirements.txt\n\ndeps: ${SITE_PACKAGES}/pytest.py\n\ntests: ${ENV} ${SITE_PACKAGES}/pytest.py\n\t@${IN_ENV} pytest\n\nclean:\n\t@rm -rf ${ENV} .env .pytest_cache\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 40.1943359375,
          "content": "# clean-code-python\n\n[![Build Status](https://travis-ci.com/zedr/clean-code-python.svg?branch=master)](https://travis-ci.com/zedr/clean-code-python)\n[![](https://img.shields.io/badge/python-3.8+-blue.svg)](https://www.python.org/download/releases/3.8.3/)\n\n## Table of Contents\n\n1. [Introduction](#introduction)\n2. [Variables](#variables)\n3. [Functions](#functions)\n5. [Classes](#classes)\n    1. [S: Single Responsibility Principle (SRP)](#single-responsibility-principle-srp)\n    2. [O: Open/Closed Principle (OCP)](#openclosed-principle-ocp)\n    3. [L: Liskov Substitution Principle (LSP)](#liskov-substitution-principle-lsp)\n    4. [I: Interface Segregation Principle (ISP)](#interface-segregation-principle-isp)\n    5. [D: Dependency Inversion Principle (DIP)](#dependency-inversion-principle-dip)\n6. [Don't repeat yourself (DRY)](#dont-repeat-yourself-dry)\n7. [Translations](#translations)\n\n## Introduction\n\nSoftware engineering principles, from Robert C. Martin's book\n[*Clean\nCode*](https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882)\n, adapted for Python. This is not a style guide. It's a guide to producing\nreadable, reusable, and refactorable software in Python.\n\nNot every principle herein has to be strictly followed, and even fewer will be\nuniversally agreed upon. These are guidelines and nothing more, but they are\nones codified over many years of collective experience by the authors of *Clean\nCode*.\n\nAdapted\nfrom [clean-code-javascript](https://github.com/ryanmcdermott/clean-code-javascript)\n\nTargets Python3.7+\n\n## **Variables**\n\n### Use meaningful and pronounceable variable names\n\n**Bad:**\n\n```python\nimport datetime\n\nymdstr = datetime.date.today().strftime(\"%y-%m-%d\")\n```\n\nAdditionally, there's no need to add the type of the variable (str) to its\nname.\n\n**Good**:\n\n```python\nimport datetime\n\ncurrent_date: str = datetime.date.today().strftime(\"%y-%m-%d\")\n```\n\n**[â¬† back to top](#table-of-contents)**\n\n### Use the same vocabulary for the same type of variable\n\n**Bad:**\nHere we use three different names for the same underlying entity:\n\n```python\ndef get_user_info(): pass\n\n\ndef get_client_data(): pass\n\n\ndef get_customer_record(): pass\n```\n\n**Good**:\nIf the entity is the same, you should be consistent in referring to it in your\nfunctions:\n\n```python\ndef get_user_info(): pass\n\n\ndef get_user_data(): pass\n\n\ndef get_user_record(): pass\n```\n\n**Even better**\nPython is (also) an object oriented programming language. If it makes sense,\npackage the functions together with the concrete implementation of the entity\nin your code, as instance attributes, property methods, or methods:\n\n```python\nfrom typing import Union, Dict\n\n\nclass Record:\n    pass\n\n\nclass User:\n    info: str\n\n    @property\n    def data(self) -> Dict[str, str]:\n        return {}\n\n    def get_record(self) -> Union[Record, None]:\n        return Record()\n```\n\n**[â¬† back to top](#table-of-contents)**\n\n### Use searchable names\n\nWe will read more code than we will ever write. It's important that the code we\ndo write is readable and searchable. By *not* naming variables that end up\nbeing meaningful for understanding our program, we hurt our readers. Make your\nnames searchable.\n\n**Bad:**\n\n```python\nimport time\n\n# What is the number 86400 for again?\ntime.sleep(86400)\n```\n\n**Good**:\n\n```python\nimport time\n\n# Declare them in the global namespace for the module.\nSECONDS_IN_A_DAY = 60 * 60 * 24\ntime.sleep(SECONDS_IN_A_DAY)\n```\n\n**[â¬† back to top](#table-of-contents)**\n\n### Use explanatory variables\n\n**Bad:**\n\n```python\nimport re\n\naddress = \"One Infinite Loop, Cupertino 95014\"\ncity_zip_code_regex = r\"^[^,\\\\]+[,\\\\\\s]+(.+?)\\s*(\\d{5})?$\"\n\nmatches = re.match(city_zip_code_regex, address)\nif matches:\n    print(f\"{matches[1]}: {matches[2]}\")\n```\n\n**Not bad**:\n\nIt's better, but we are still heavily dependent on regex.\n\n```python\nimport re\n\naddress = \"One Infinite Loop, Cupertino 95014\"\ncity_zip_code_regex = r\"^[^,\\\\]+[,\\\\\\s]+(.+?)\\s*(\\d{5})?$\"\nmatches = re.match(city_zip_code_regex, address)\n\nif matches:\n    city, zip_code = matches.groups()\n    print(f\"{city}: {zip_code}\")\n```\n\n**Good**:\n\nDecrease dependence on regex by naming subpatterns.\n\n```python\nimport re\n\naddress = \"One Infinite Loop, Cupertino 95014\"\ncity_zip_code_regex = r\"^[^,\\\\]+[,\\\\\\s]+(?P<city>.+?)\\s*(?P<zip_code>\\d{5})?$\"\n\nmatches = re.match(city_zip_code_regex, address)\nif matches:\n    print(f\"{matches['city']}, {matches['zip_code']}\")\n```\n\n**[â¬† back to top](#table-of-contents)**\n\n### Avoid Mental Mapping\n\nDonâ€™t force the reader of your code to translate what the variable means.\nExplicit is better than implicit.\n\n**Bad:**\n\n```python\nseq = (\"Austin\", \"New York\", \"San Francisco\")\n\nfor item in seq:\n    # do_stuff()\n    # do_some_other_stuff()\n\n    # Wait, what's `item` again?\n    print(item)\n```\n\n**Good**:\n\n```python\nlocations = (\"Austin\", \"New York\", \"San Francisco\")\n\nfor location in locations:\n    # do_stuff()\n    # do_some_other_stuff()\n    # ...\n    print(location)\n```\n\n**[â¬† back to top](#table-of-contents)**\n\n### Don't add unneeded context\n\nIf your class/object name tells you something, don't repeat that in your\nvariable name.\n\n**Bad:**\n\n```python\nclass Car:\n    car_make: str\n    car_model: str\n    car_color: str\n```\n\n**Good**:\n\n```python\nclass Car:\n    make: str\n    model: str\n    color: str\n```\n\n**[â¬† back to top](#table-of-contents)**\n\n### Use default arguments instead of short circuiting or conditionals\n\n**Tricky**\n\nWhy write:\n\n```python\nimport hashlib\n\n\ndef create_micro_brewery(name):\n    name = \"Hipster Brew Co.\" if name is None else name\n    slug = hashlib.sha1(name.encode()).hexdigest()\n    # etc.\n```\n\n... when you can specify a default argument instead? This also makes it clear\nthat you are expecting a string as the argument.\n\n**Good**:\n\n```python\nimport hashlib\n\n\ndef create_micro_brewery(name: str = \"Hipster Brew Co.\"):\n    slug = hashlib.sha1(name.encode()).hexdigest()\n    # etc.\n```\n\n**[â¬† back to top](#table-of-contents)**\n\n## **Functions**\n\n### Functions should do one thing\n\nThis is by far the most important rule in software engineering. When functions\ndo more than one thing, they are harder to compose, test, and reason about.\nWhen you can isolate a function to just one action, they can be refactored\neasily and your code will read much cleaner. If you take nothing else away from\nthis guide other than this, you'll be ahead of many developers.\n\n**Bad:**\n\n```python\nfrom typing import List\n\n\nclass Client:\n    active: bool\n\n\ndef email(client: Client) -> None:\n    pass\n\n\ndef email_clients(clients: List[Client]) -> None:\n    \"\"\"Filter active clients and send them an email.\n    \"\"\"\n    for client in clients:\n        if client.active:\n            email(client)\n```\n\n**Good**:\n\n```python\nfrom typing import List\n\n\nclass Client:\n    active: bool\n\n\ndef email(client: Client) -> None:\n    pass\n\n\ndef get_active_clients(clients: List[Client]) -> List[Client]:\n    \"\"\"Filter active clients.\n    \"\"\"\n    return [client for client in clients if client.active]\n\n\ndef email_clients(clients: List[Client]) -> None:\n    \"\"\"Send an email to a given list of clients.\n    \"\"\"\n    for client in get_active_clients(clients):\n        email(client)\n```\n\nDo you see an opportunity for using generators now?\n\n**Even better**\n\n```python\nfrom typing import Generator, Iterator\n\n\nclass Client:\n    active: bool\n\n\ndef email(client: Client):\n    pass\n\n\ndef active_clients(clients: Iterator[Client]) -> Generator[Client, None, None]:\n    \"\"\"Only active clients\"\"\"\n    return (client for client in clients if client.active)\n\n\ndef email_client(clients: Iterator[Client]) -> None:\n    \"\"\"Send an email to a given list of clients.\n    \"\"\"\n    for client in active_clients(clients):\n        email(client)\n```\n\n**[â¬† back to top](#table-of-contents)**\n\n### Function arguments (2 or fewer ideally)\n\nA large amount of parameters is usually the sign that a function is\ndoing too much (has more than one responsibility). Try to decompose it \ninto smaller functions having a reduced set of parameters, ideally less than\nthree.\n\nIf the function has a single responsibility, consider if you can bundle\nsome or all parameters into a specialized object that will be passed as an \nargument to the function. These parameters might be attributes of a single\nentity that you can represent with a dedicated data structure. You may also\nbe able to reuse this entity elsewhere in your program. The reason why this is\na better arrangement is than having multiple parameters is that we may be able\nto move some computations, done with those parameters inside the \nfunction, into methods belonging to the new object, therefore reducing the\ncomplexity of the function.\n\n**Bad:**\n\n```python\ndef create_menu(title, body, button_text, cancellable):\n    pass\n```\n\n**Java-esque**:\n\n```python\nclass Menu:\n    def __init__(self, config: dict):\n        self.title = config[\"title\"]\n        self.body = config[\"body\"]\n        # ...\n\n\nmenu = Menu(\n    {\n        \"title\": \"My Menu\",\n        \"body\": \"Something about my menu\",\n        \"button_text\": \"OK\",\n        \"cancellable\": False\n    }\n)\n```\n\n**Also good**\n\n```python\nclass MenuConfig:\n    \"\"\"A configuration for the Menu.\n\n    Attributes:\n        title: The title of the Menu.\n        body: The body of the Menu.\n        button_text: The text for the button label.\n        cancellable: Can it be cancelled?\n    \"\"\"\n    title: str\n    body: str\n    button_text: str\n    cancellable: bool = False\n\n\ndef create_menu(config: MenuConfig) -> None:\n    title = config.title\n    body = config.body\n    # ...\n\n\nconfig = MenuConfig()\nconfig.title = \"My delicious menu\"\nconfig.body = \"A description of the various items on the menu\"\nconfig.button_text = \"Order now!\"\n# The instance attribute overrides the default class attribute.\nconfig.cancellable = True\n\ncreate_menu(config)\n```\n\n**Fancy**\n\n```python\nfrom typing import NamedTuple\n\n\nclass MenuConfig(NamedTuple):\n    \"\"\"A configuration for the Menu.\n\n    Attributes:\n        title: The title of the Menu.\n        body: The body of the Menu.\n        button_text: The text for the button label.\n        cancellable: Can it be cancelled?\n    \"\"\"\n    title: str\n    body: str\n    button_text: str\n    cancellable: bool = False\n\n\ndef create_menu(config: MenuConfig):\n    title, body, button_text, cancellable = config\n    # ...\n\n\ncreate_menu(\n    MenuConfig(\n        title=\"My delicious menu\",\n        body=\"A description of the various items on the menu\",\n        button_text=\"Order now!\"\n    )\n)\n```\n\n**Even fancier**\n\n```python\nfrom dataclasses import astuple, dataclass\n\n\n@dataclass\nclass MenuConfig:\n    \"\"\"A configuration for the Menu.\n\n    Attributes:\n        title: The title of the Menu.\n        body: The body of the Menu.\n        button_text: The text for the button label.\n        cancellable: Can it be cancelled?\n    \"\"\"\n    title: str\n    body: str\n    button_text: str\n    cancellable: bool = False\n\n\ndef create_menu(config: MenuConfig):\n    title, body, button_text, cancellable = astuple(config)\n    # ...\n\n\ncreate_menu(\n    MenuConfig(\n        title=\"My delicious menu\",\n        body=\"A description of the various items on the menu\",\n        button_text=\"Order now!\"\n    )\n)\n```\n\n**Even fancier, Python3.8+ only**\n\n```python\nfrom typing import TypedDict\n\n\nclass MenuConfig(TypedDict):\n    \"\"\"A configuration for the Menu.\n\n    Attributes:\n        title: The title of the Menu.\n        body: The body of the Menu.\n        button_text: The text for the button label.\n        cancellable: Can it be cancelled?\n    \"\"\"\n    title: str\n    body: str\n    button_text: str\n    cancellable: bool\n\n\ndef create_menu(config: MenuConfig):\n    title = config[\"title\"]\n    # ...\n\n\ncreate_menu(\n    # You need to supply all the parameters\n    MenuConfig(\n        title=\"My delicious menu\",\n        body=\"A description of the various items on the menu\",\n        button_text=\"Order now!\",\n        cancellable=True\n    )\n)\n```\n\n**[â¬† back to top](#table-of-contents)**\n\n### Function names should say what they do\n\n**Bad:**\n\n```python\nclass Email:\n    def handle(self) -> None:\n        pass\n\n\nmessage = Email()\n# What is this supposed to do again?\nmessage.handle()\n```\n\n**Good:**\n\n```python\nclass Email:\n    def send(self) -> None:\n        \"\"\"Send this message\"\"\"\n\n\nmessage = Email()\nmessage.send()\n```\n\n**[â¬† back to top](#table-of-contents)**\n\n### Functions should only be one level of abstraction\n\nWhen you have more than one level of abstraction, your function is usually\ndoing too much. Splitting up functions leads to reusability and easier testing.\n\n**Bad:**\n\n```python\n# type: ignore\n\ndef parse_better_js_alternative(code: str) -> None:\n    regexes = [\n        # ...\n    ]\n\n    statements = code.split('\\n')\n    tokens = []\n    for regex in regexes:\n        for statement in statements:\n            pass\n\n    ast = []\n    for token in tokens:\n        pass\n\n    for node in ast:\n        pass\n```\n\n**Good:**\n\n```python\nfrom typing import Tuple, List, Dict\n\nREGEXES: Tuple = (\n    # ...\n)\n\n\ndef parse_better_js_alternative(code: str) -> None:\n    tokens: List = tokenize(code)\n    syntax_tree: List = parse(tokens)\n\n    for node in syntax_tree:\n        pass\n\n\ndef tokenize(code: str) -> List:\n    statements = code.split()\n    tokens: List[Dict] = []\n    for regex in REGEXES:\n        for statement in statements:\n            pass\n\n    return tokens\n\n\ndef parse(tokens: List) -> List:\n    syntax_tree: List[Dict] = []\n    for token in tokens:\n        pass\n\n    return syntax_tree\n```\n\n**[â¬† back to top](#table-of-contents)**\n\n### Don't use flags as function parameters\n\nFlags tell your user that this function does more than one thing. Functions\nshould do one thing. Split your functions if they are following different code\npaths based on a boolean.\n\n**Bad:**\n\n```python\nfrom tempfile import gettempdir\nfrom pathlib import Path\n\n\ndef create_file(name: str, temp: bool) -> None:\n    if temp:\n        (Path(gettempdir()) / name).touch()\n    else:\n        Path(name).touch()\n```\n\n**Good:**\n\n```python\nfrom tempfile import gettempdir\nfrom pathlib import Path\n\n\ndef create_file(name: str) -> None:\n    Path(name).touch()\n\n\ndef create_temp_file(name: str) -> None:\n    (Path(gettempdir()) / name).touch()\n```\n\n**[â¬† back to top](#table-of-contents)**\n\n### Avoid side effects\n\nA function produces a side effect if it does anything other than take a value\nin and return another value or values. For example, a side effect could be\nwriting to a file, modifying some global variable, or accidentally wiring all\nyour money to a stranger.\n\nNow, you do need to have side effects in a program on occasion - for example,\nlike in the previous example, you might need to write to a file. In these\ncases, you should centralize and indicate where you are incorporating side\neffects. Don't have several functions and classes that write to a particular\nfile - rather, have one\n(and only one) service that does it.\n\nThe main point is to avoid common pitfalls like sharing state between objects\nwithout any structure, using mutable data types that can be written to by\nanything, or using an instance of a class, and not centralizing where your side\neffects occur. If you can do this, you will be happier than the vast majority\nof other programmers.\n\n**Bad:**\n\n```python\n# type: ignore\n\n# This is a module-level name.\n# It's good practice to define these as immutable values, such as a string.\n# However...\nfullname = \"Ryan McDermott\"\n\n\ndef split_into_first_and_last_name() -> None:\n    # The use of the global keyword here is changing the meaning of the\n    # the following line. This function is now mutating the module-level\n    # state and introducing a side-effect!\n    global fullname\n    fullname = fullname.split()\n\n\nsplit_into_first_and_last_name()\n\n# MyPy will spot the problem, complaining about 'Incompatible types in\n# assignment: (expression has type \"List[str]\", variable has type \"str\")'\nprint(fullname)  # [\"Ryan\", \"McDermott\"]\n\n# OK. It worked the first time, but what will happen if we call the\n# function again?\n```\n\n**Good:**\n\n```python\nfrom typing import List, AnyStr\n\n\ndef split_into_first_and_last_name(name: AnyStr) -> List[AnyStr]:\n    return name.split()\n\n\nfullname = \"Ryan McDermott\"\nname, surname = split_into_first_and_last_name(fullname)\n\nprint(name, surname)  # => Ryan McDermott\n```\n\n**Also good**\n\n```python\nfrom dataclasses import dataclass\n\n\n@dataclass\nclass Person:\n    name: str\n\n    @property\n    def name_as_first_and_last(self) -> list:\n        return self.name.split()\n\n\n# The reason why we create instances of classes is to manage state!\nperson = Person(\"Ryan McDermott\")\nprint(person.name)  # => \"Ryan McDermott\"\nprint(person.name_as_first_and_last)  # => [\"Ryan\", \"McDermott\"]\n```\n\n**[â¬† back to top](#table-of-contents)**\n\n## **Classes**\n\n### **Single Responsibility Principle (SRP)**\n\nRobert C. Martin writes:\n\n> A class should have only one reason to change.\n\n\"Reasons to change\" are, in essence, the responsibilities managed by a class or\nfunction.\n\nIn the following example, we create an HTML element that represents a comment\nwith the version of the document:\n\n**Bad**\n\n```python\nfrom importlib import metadata\n\n\nclass VersionCommentElement:\n     \"\"\"An element that renders an HTML comment with the program's version number\n     \"\"\"\n\n     def get_version(self) -> str:\n          \"\"\"Get the package version\"\"\"\n          return metadata.version(\"pip\")\n\n     def render(self) -> None:\n          print(f'<!-- Version: {self.get_version()} -->')\n\n\nVersionCommentElement().render()\n```\n\nThis class has two responsibilities:\n\n- Retrieve the version number of the Python package\n- Render itself as an HTML element\n\nAny change to one or the other carries the risk of impacting the other.\n\nWe can rewrite the class and decouple these responsibilities:\n\n**Good**\n\n```python\nfrom importlib import metadata\n\n\ndef get_version(pkg_name: str) -> str:\n     \"\"\"Retrieve the version of a given package\"\"\"\n     return metadata.version(pkg_name)\n\n\nclass VersionCommentElement:\n     \"\"\"An element that renders an HTML comment with the program's version number\n     \"\"\"\n\n     def __init__(self, version: str):\n          self.version = version\n\n     def render(self) -> None:\n          print(f'<!-- Version: {self.version} -->')\n\n\nVersionCommentElement(get_version(\"pip\")).render()\n```\n\nThe result is that the class only needs to take care of rendering itself. It\nreceives the version text during instantiation and this text is generated by\ncalling a separate function, `get_version()`. Changing the class has no impact\non the other, and vice-versa, as long as the contract between them does not\nchange, i.e. the function provides a string and the class `__init__` method\naccepts a string.\n\nAs an added bonus, the `get_version()` is now reusable elsewhere.\n\n### **Open/Closed Principle (OCP)**\n\n> â€œIncorporate new features  by extending the system, not by making\n> modifications (to it)â€,\n> Uncle Bob.\n\nObjects should be open for extension, but closed to modification. It should be\npossible to augment the functionality provided by an object (for example, a\nclass)\nwithout changing its internal contracts. An object can enable this when it is\ndesigned to be extended cleanly.\n\nIn the following example, we try to implement a simple web framework that\nhandles HTTP requests and returns responses. The `View` class has a single\nmethod `.get()` that will be called when the HTTP server will receive a GET\nrequest from a client.\n\n`View` is intentionally simple and returns `text/plain` responses. We would\nalso like to return HTML responses based on a template file, so we subclass it\nusing the `TemplateView` class.\n\n**Bad**\n\n```python\nfrom dataclasses import dataclass\n\n\n@dataclass\nclass Response:\n     \"\"\"An HTTP response\"\"\"\n\n     status: int\n     content_type: str\n     body: str\n\n\nclass View:\n     \"\"\"A simple view that returns plain text responses\"\"\"\n\n     def get(self, request) -> Response:\n          \"\"\"Handle a GET request and return a message in the response\"\"\"\n          return Response(\n               status=200,\n               content_type='text/plain',\n               body=\"Welcome to my web site\"\n          )\n\n\nclass TemplateView(View):\n     \"\"\"A view that returns HTML responses based on a template file.\"\"\"\n\n     def get(self, request) -> Response:\n          \"\"\"Handle a GET request and return an HTML document in the response\"\"\"\n          with open(\"index.html\") as fd:\n               return Response(\n                    status=200,\n                    content_type='text/html',\n                    body=fd.read()\n               )\n\n```\n\nThe `TemplateView` class has modified the internal behaviour of its parent\nclass in order to enable the more advanced functionality. In doing so, it now\nrelies on the `View` to not change the implementation of the `.get()`\nmethod, which now needs to be frozen in time. We cannot introduce, for example,\nsome additional checks in all our `View`-derived classes because the behaviour\nis overridden in at least one subtype and we will need to update it.\n\nLet's redesign our classes to fix this problem and let the `View` class be\nextended (not modified) cleanly:\n\n**Good**\n\n```python\nfrom dataclasses import dataclass\n\n\n@dataclass\nclass Response:\n     \"\"\"An HTTP response\"\"\"\n\n     status: int\n     content_type: str\n     body: str\n\n\nclass View:\n     \"\"\"A simple view that returns plain text responses\"\"\"\n\n     content_type = \"text/plain\"\n\n     def render_body(self) -> str:\n          \"\"\"Render the message body of the response\"\"\"\n          return \"Welcome to my web site\"\n\n     def get(self, request) -> Response:\n          \"\"\"Handle a GET request and return a message in the response\"\"\"\n          return Response(\n               status=200,\n               content_type=self.content_type,\n               body=self.render_body()\n          )\n\n\nclass TemplateView(View):\n     \"\"\"A view that returns HTML responses based on a template file.\"\"\"\n\n     content_type = \"text/html\"\n     template_file = \"index.html\"\n\n     def render_body(self) -> str:\n          \"\"\"Render the message body as HTML\"\"\"\n          with open(self.template_file) as fd:\n               return fd.read()\n\n\n```\n\nNote that we did need to override the `render_body()` in order to change the\nsource of the body, but this method has a single, well defined responsibility\nthat **invites subtypes to override it**. It is designed to be extended by its\nsubtypes.\n\nAnother good way to use the strengths of both object inheritance and object\ncomposition is to\nuse [Mixins](https://docs.djangoproject.com/en/4.1/topics/class-based-views/mixins/)\n.\n\nMixins are bare-bones classes that are meant to be used exclusively with other\nrelated classes. They are \"mixed-in\" with the target class using multiple\ninheritance, in order to change the target's behaviour.\n\nA few rules:\n\n- Mixins should always inherit from `object`\n- Mixins always come before the target class,\n  e.g. `class Foo(MixinA, MixinB, TargetClass): ...`\n\n**Also good**\n\n```python\nfrom dataclasses import dataclass, field\nfrom typing import Protocol\n\n\n@dataclass\nclass Response:\n     \"\"\"An HTTP response\"\"\"\n\n     status: int\n     content_type: str\n     body: str\n     headers: dict = field(default_factory=dict)\n\n\nclass View:\n     \"\"\"A simple view that returns plain text responses\"\"\"\n\n     content_type = \"text/plain\"\n\n     def render_body(self) -> str:\n          \"\"\"Render the message body of the response\"\"\"\n          return \"Welcome to my web site\"\n\n     def get(self, request) -> Response:\n          \"\"\"Handle a GET request and return a message in the response\"\"\"\n          return Response(\n               status=200,\n               content_type=self.content_type,\n               body=self.render_body()\n          )\n\n\nclass TemplateRenderMixin:\n     \"\"\"A mixin class for views that render HTML documents using a template file\n \n     Not to be used by itself!\n     \"\"\"\n     template_file: str = \"\"\n\n     def render_body(self) -> str:\n          \"\"\"Render the message body as HTML\"\"\"\n          if not self.template_file:\n               raise ValueError(\"The path to a template file must be given.\")\n\n          with open(self.template_file) as fd:\n               return fd.read()\n\n\nclass ContentLengthMixin:\n     \"\"\"A mixin class for views that injects a Content-Length header in the\n     response\n \n     Not to be used by itself!\n     \"\"\"\n\n     def get(self, request) -> Response:\n          \"\"\"Introspect and amend the response to inject the new header\"\"\"\n          response = super().get(request)  # type: ignore\n          response.headers['Content-Length'] = len(response.body)\n          return response\n\n\nclass TemplateView(TemplateRenderMixin, ContentLengthMixin, View):\n     \"\"\"A view that returns HTML responses based on a template file.\"\"\"\n\n     content_type = \"text/html\"\n     template_file = \"index.html\"\n\n```\n\nAs you can see, Mixins make object composition easier by packaging together\nrelated functionality into a highly reusable class with a single\nresponsibility, allowing clean decoupling. Class extension is achieved by \"\nmixing-in\" the additional classes.\n\nThe popular Django project makes heavy use of Mixins to compose its class-based\nviews.\n\nFIXME: re-enable typechecking for the line above once it's clear how to use\n`typing.Protocol` to make the type checker work with Mixins.\n\n### **Liskov Substitution Principle (LSP)**\n\n> â€œFunctions that use pointers or references to base classes\n> must be able to use objects of derived classes without knowing itâ€,\n> Uncle Bob.\n\nThis principle is named after Barbara Liskov, who collaborated with fellow\ncomputer scientist Jeannette Wing on the seminal paper\n*\"A behavioral notion of subtyping\" (1994). A core tenet of the paper is that\n\"a subtype (must) preserve the behaviour of the supertype methods and also all\ninvariant and history properties of its supertype\".\n\nIn essence, a function accepting a supertype should also accept all its\nsubtypes with no modification.\n\nCan you spot the problem with the following code?\n\n**Bad**\n\n```python\nfrom dataclasses import dataclass\n\n\n@dataclass\nclass Response:\n     \"\"\"An HTTP response\"\"\"\n\n     status: int\n     content_type: str\n     body: str\n\n\nclass View:\n     \"\"\"A simple view that returns plain text responses\"\"\"\n\n     content_type = \"text/plain\"\n\n     def render_body(self) -> str:\n          \"\"\"Render the message body of the response\"\"\"\n          return \"Welcome to my web site\"\n\n     def get(self, request) -> Response:\n          \"\"\"Handle a GET request and return a message in the response\"\"\"\n          return Response(\n               status=200,\n               content_type=self.content_type,\n               body=self.render_body()\n          )\n\n\nclass TemplateView(View):\n     \"\"\"A view that returns HTML responses based on a template file.\"\"\"\n\n     content_type = \"text/html\"\n\n     def get(self, request, template_file: str) -> Response:  # type: ignore\n          \"\"\"Render the message body as HTML\"\"\"\n          with open(template_file) as fd:\n               return Response(\n                    status=200,\n                    content_type=self.content_type,\n                    body=fd.read()\n               )\n\n\ndef render(view: View, request) -> Response:\n     \"\"\"Render a View\"\"\"\n     return view.get(request)\n\n```\n\nThe expectation is that `render()` function will be able to work with `View`\nand its subtype `TemplateView`, but the latter has broken compatibility by\nmodifying the signature of the `.get()` method. The function will raise\na `TypeError`\nexception when used with `TemplateView`.\n\nIf we want the `render()` function to work with any subtype of `View`, we must\npay attention not to break its public-facing protocol. But how do we know what\nconstitutes it for a given class? Type hinters like *mypy* will raise an error\nwhen it detects mistakes like this:\n\n```\nerror: Signature of \"get\" incompatible with supertype \"View\"\n<string>:36: note:      Superclass:\n<string>:36: note:          def get(self, request: Any) -> Response\n<string>:36: note:      Subclass:\n<string>:36: note:          def get(self, request: Any, template_file: str) -> Response\n```\n\n### **Interface Segregation Principle (ISP)**\n\n> â€œKeep interfaces small\n> so that users donâ€™t end up depending on things they donâ€™t need.â€,\n> Uncle Bob.\n\nSeveral well known object oriented programming languages, like Java and Go,\nhave a concept called interfaces. An interface defines the public methods and\nproperties of an object without implementing them. They are useful when we\ndon't want to couple the signature of a function to a concrete object; we'd\nrather say \"I don't care what object you give me, as long as it has certain\nmethods and attributes I expect to make use of\".\n\nPython does not have interfaces. We have Abstract Base Classes instead, which\nare a little different, but can serve the same purpose.\n\n**Good**\n\n```python\n\nfrom abc import ABCMeta, abstractmethod\n\n\n# Define the Abstract Class for a generic Greeter object\nclass Greeter(metaclass=ABCMeta):\n     \"\"\"An object that can perform a greeting action.\"\"\"\n\n     @staticmethod\n     @abstractmethod\n     def greet(name: str) -> None:\n          \"\"\"Display a greeting for the user with the given name\"\"\"\n\n\nclass FriendlyActor(Greeter):\n     \"\"\"An actor that greets the user with a friendly salutation\"\"\"\n\n     @staticmethod\n     def greet(name: str) -> None:\n          \"\"\"Greet a person by name\"\"\"\n          print(f\"Hello {name}!\")\n\n\ndef welcome_user(user_name: str, actor: Greeter):\n     \"\"\"Welcome a user with a given name using the provided actor\"\"\"\n     actor.greet(user_name)\n\n\nwelcome_user(\"Barbara\", FriendlyActor())\n```\n\nNow imagine the following scenario: we have a certain number of PDF documents\nthat we author and want to serve to our web site visitors. We are using a\nPython web framework and we might be tempted to design a class to manage these\ndocuments, so we go ahead and design a comprehensive abstract base class for\nour document.\n\n**Error**\n\n```python\nimport abc\n\n\nclass Persistable(metaclass=abc.ABCMeta):\n     \"\"\"Serialize a file to data and back\"\"\"\n\n     @property\n     @abc.abstractmethod\n     def data(self) -> bytes:\n          \"\"\"The raw data of the file\"\"\"\n\n     @classmethod\n     @abc.abstractmethod\n     def load(cls, name: str):\n          \"\"\"Load the file from disk\"\"\"\n\n     @abc.abstractmethod\n     def save(self) -> None:\n          \"\"\"Save the file to disk\"\"\"\n\n\n# We just want to serve the documents, so our concrete PDF document\n# implementation just needs to implement the `.load()` method and have\n# a public attribute named `data`.\n\nclass PDFDocument(Persistable):\n     \"\"\"A PDF document\"\"\"\n\n     @property\n     def data(self) -> bytes:\n          \"\"\"The raw bytes of the PDF document\"\"\"\n          ...  # Code goes here - omitted for brevity\n\n     @classmethod\n     def load(cls, name: str):\n          \"\"\"Load the file from the local filesystem\"\"\"\n          ...  # Code goes here - omitted for brevity\n\n\ndef view(request):\n     \"\"\"A web view that handles a GET request for a document\"\"\"\n     requested_name = request.qs['name']  # We want to validate this!\n     return PDFDocument.load(requested_name).data\n\n```\n\nBut we can't! If we don't implement the `.save()` method, an exception will be\nraised:\n\n```\nCan't instantiate abstract class PDFDocument with abstract method save.\n```\n\nThat's annoying. We don't really need to implement `.save()` here. We could\nimplement a dummy method that does nothing or raises `NotImplementedError`, but\nthat's useless code that we will need to maintain.\n\nAt the same time, if we remove `.save()` from the abstract class now we will\nneed to add it back when we will later implement a way for users to submit\ntheir documents, bringing us back to the same situation as before.\n\nThe problem is that we have written an *interface* that has features we don't\nneed right now as we are not using them.\n\nThe solution is to decompose the interface into smaller and composable\ninterfaces that segregate each feature.\n\n**Good**\n\n```python\nimport abc\n\n\nclass DataCarrier(metaclass=abc.ABCMeta):\n     \"\"\"Carries a data payload\"\"\"\n\n     @property\n     def data(self):\n          ...\n\n\nclass Loadable(DataCarrier):\n     \"\"\"Can load data from storage by name\"\"\"\n\n     @classmethod\n     @abc.abstractmethod\n     def load(cls, name: str):\n          ...\n\n\nclass Saveable(DataCarrier):\n     \"\"\"Can save data to storage\"\"\"\n\n     @abc.abstractmethod\n     def save(self) -> None:\n          ...\n\n\nclass PDFDocument(Loadable):\n     \"\"\"A PDF document\"\"\"\n\n     @property\n     def data(self) -> bytes:\n          \"\"\"The raw bytes of the PDF document\"\"\"\n          ...  # Code goes here - omitted for brevity\n\n     @classmethod\n     def load(cls, name: str) -> None:\n          \"\"\"Load the file from the local filesystem\"\"\"\n          ...  # Code goes here - omitted for brevity\n\n\ndef view(request):\n     \"\"\"A web view that handles a GET request for a document\"\"\"\n     requested_name = request.qs['name']  # We want to validate this!\n     return PDFDocument.load(requested_name).data\n\n```\n\n### **Dependency Inversion Principle (DIP)**\n\n> â€œDepend upon abstractions, not concrete detailsâ€,\n> Uncle Bob.\n\nImagine we wanted to write a web view that returns an HTTP response that\nstreams rows of a CSV file we create on the fly. We want to use the CSV writer\nthat is provided by the standard library.\n\n**Bad**\n\n```python\nimport csv\nfrom io import StringIO\n\n\nclass StreamingHttpResponse:\n     \"\"\"A streaming HTTP response\"\"\"\n     ...  # implementation code goes here\n\n\ndef some_view(request):\n     rows = (\n          ['First row', 'Foo', 'Bar', 'Baz'],\n          ['Second row', 'A', 'B', 'C', '\"Testing\"', \"Here's a quote\"]\n     )\n\n     # Define a generator to stream data directly to the client\n     def stream():\n          buffer_ = StringIO()\n          writer = csv.writer(buffer_, delimiter=';', quotechar='\"')\n          for row in rows:\n               writer.writerow(row)\n               buffer_.seek(0)\n               data = buffer_.read()\n               buffer_.seek(0)\n               buffer_.truncate()\n               yield data\n\n     # Create the streaming response  object with the appropriate CSV header.\n     response = StreamingHttpResponse(stream(), content_type='text/csv')\n     response[\n          'Content-Disposition'] = 'attachment; filename=\"somefilename.csv\"'\n\n     return response\n\n```\n\nOur first implementation works around the CSV's writer interface by\nmanipulating a `StringIO` object (which is file-like) and performing several\nlow level operations in order to farm out the rows from the writer. It's a lot\nof work and not very elegant.\n\nA better way is to leverage the fact that the writer just needs an object with\na `.write()` method to do our bidding. Why not pass it a dummy object that\nimmediately returns the newly assembled row, so that\nthe `StreamingHttpResponse`\nclass can immediate stream it back to the client?\n\n**Good**\n\n```python\nimport csv\n\n\nclass Echo:\n     \"\"\"An object that implements just the write method of the file-like\n     interface.\n     \"\"\"\n\n     def write(self, value):\n          \"\"\"Write the value by returning it, instead of storing in a buffer.\"\"\"\n          return value\n\n\ndef some_streaming_csv_view(request):\n     \"\"\"A view that streams a large CSV file.\"\"\"\n     rows = (\n          ['First row', 'Foo', 'Bar', 'Baz'],\n          ['Second row', 'A', 'B', 'C', '\"Testing\"', \"Here's a quote\"]\n     )\n     writer = csv.writer(Echo(), delimiter=';', quotechar='\"')\n     return StreamingHttpResponse(\n          (writer.writerow(row) for row in rows),\n          content_type=\"text/csv\",\n          headers={\n               'Content-Disposition': 'attachment; filename=\"somefilename.csv\"'},\n     )\n\n```\n\nMuch better, and it works like a charm! The reason it's superior to the\nprevious implementation should be obvious: less code (and more performant) to\nachieve the same result. We decided to leverage the fact that the writer class\ndepends on the `.write()` abstraction of the object it receives, without caring\nabout the low level, concrete details of what the method actually does.\n\nThis example was taken from\n[a submission made to the Django documentation](https://code.djangoproject.com/ticket/21179)\nby this author.\n\n**[â¬† back to top](#table-of-contents)**\n\n## **Don't repeat yourself (DRY)**\n\nTry to observe the [DRY](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself)\nprinciple.\n\nDo your absolute best to avoid duplicate code. Duplicate code is bad because it\nmeans that there's more than one place to alter something if you need to change\nsome logic.\n\nImagine if you run a restaurant and you keep track of your inventory: all your\ntomatoes, onions, garlic, spices, etc. If you have multiple lists that you keep\nthis on, then all have to be updated when you serve a dish with tomatoes in\nthem. If you only have one list, there's only one place to update!\n\nOften you have duplicate code because you have two or more slightly different\nthings, that share a lot in common, but their differences force you to have two\nor more separate functions that do much of the same things. Removing duplicate\ncode means creating an abstraction that can handle this set of different things\nwith just one function/module/class.\n\nGetting the abstraction right is critical. Bad abstractions can be worse than\nduplicate code, so be careful! Having said this, if you can make a good\nabstraction, do it! Don't repeat yourself, otherwise you'll find yourself\nupdating multiple places any time you want to change one thing.\n\n**Bad:**\n\n```python\nfrom typing import List, Dict\nfrom dataclasses import dataclass\n\n\n@dataclass\nclass Developer:\n    def __init__(self, experience: float, github_link: str) -> None:\n        self._experience = experience\n        self._github_link = github_link\n\n    @property\n    def experience(self) -> float:\n        return self._experience\n\n    @property\n    def github_link(self) -> str:\n        return self._github_link\n\n\n@dataclass\nclass Manager:\n    def __init__(self, experience: float, github_link: str) -> None:\n        self._experience = experience\n        self._github_link = github_link\n\n    @property\n    def experience(self) -> float:\n        return self._experience\n\n    @property\n    def github_link(self) -> str:\n        return self._github_link\n\n\ndef get_developer_list(developers: List[Developer]) -> List[Dict]:\n    developers_list = []\n    for developer in developers:\n        developers_list.append({\n            'experience': developer.experience,\n            'github_link': developer.github_link\n        })\n    return developers_list\n\n\ndef get_manager_list(managers: List[Manager]) -> List[Dict]:\n    managers_list = []\n    for manager in managers:\n        managers_list.append({\n            'experience': manager.experience,\n            'github_link': manager.github_link\n        })\n    return managers_list\n\n\n## create list objects of developers\ncompany_developers = [\n    Developer(experience=2.5, github_link='https://github.com/1'),\n    Developer(experience=1.5, github_link='https://github.com/2')\n]\ncompany_developers_list = get_developer_list(developers=company_developers)\n\n## create list objects of managers\ncompany_managers = [\n    Manager(experience=4.5, github_link='https://github.com/3'),\n    Manager(experience=5.7, github_link='https://github.com/4')\n]\ncompany_managers_list = get_manager_list(managers=company_managers)\n```\n\n**Good:**\n\n```python\nfrom typing import List, Dict\nfrom dataclasses import dataclass\n\n\n@dataclass\nclass Employee:\n    def __init__(self, experience: float, github_link: str) -> None:\n        self._experience = experience\n        self._github_link = github_link\n\n    @property\n    def experience(self) -> float:\n        return self._experience\n\n    @property\n    def github_link(self) -> str:\n        return self._github_link\n\n\ndef get_employee_list(employees: List[Employee]) -> List[Dict]:\n    employees_list = []\n    for employee in employees:\n        employees_list.append({\n            'experience': employee.experience,\n            'github_link': employee.github_link\n        })\n    return employees_list\n\n\n## create list objects of developers\ncompany_developers = [\n    Employee(experience=2.5, github_link='https://github.com/1'),\n    Employee(experience=1.5, github_link='https://github.com/2')\n]\ncompany_developers_list = get_employee_list(employees=company_developers)\n\n## create list objects of managers\ncompany_managers = [\n    Employee(experience=4.5, github_link='https://github.com/3'),\n    Employee(experience=5.7, github_link='https://github.com/4')\n]\ncompany_managers_list = get_employee_list(employees=company_managers)\n```\n\n**[â¬† back to top](#table-of-contents)**\n\n## **Translations**\n\nThis document is also available in other languages:\n\n- ðŸ‡¨ðŸ‡³ **\n  Chinese** [yinruiqing/clean-code-python](https://github.com/yinruiqing/clean-code-python)\n- ðŸ‡°ðŸ‡· ** Korean ** [wooy0ng/clean-code-python](https://github.com/wooy0ng/clean-code-python)\n- ðŸ‡µðŸ‡¹ ðŸ‡§ðŸ‡· **\n  Portugese** [fredsonchaves07/clean-code-python](https://github.com/fredsonchaves07/clean-code-python)\n- ðŸ‡®ðŸ‡· **\n  Persian:** [SepehrRasouli/clean-code-python](https://github.com/SepehrRasouli/clean-code-python)\n\n**[â¬† back to top](#table-of-contents)**\n"
        },
        {
          "name": "conftest.py",
          "type": "blob",
          "size": 2.6630859375,
          "content": "import importlib\nimport re\nimport time\nimport typing\nfrom pathlib import Path\n\nimport pytest\nfrom mypy import api\n\ncode_rxp = re.compile('```python(.*?)```', re.DOTALL | re.MULTILINE)\n\n\nclass MyPyValidationError(BaseException):\n    \"\"\"A validation error occurred when MyPy attempted to validate the code\"\"\"\n\n\ndef fake_print(*args, **kwargs):\n    \"\"\"Dummy replacement for print() that does nothing\"\"\"\n    pass\n\n\ndef pytest_collect_file(parent, path):\n    \"\"\"Collect all file suitable for use in tests\"\"\"\n    if path.basename == \"README.md\":\n        return ReadmeFile.from_parent(parent, path=Path(path))\n\n\nclass ReadmeFile(pytest.File):\n    \"\"\"A Markdown formatted readme file containing code snippets\"\"\"\n\n    def collect(self):\n        \"\"\"Collect all code snippets\"\"\"\n        raw_text = self.fspath.open().read()\n        for idx, code in enumerate(code_rxp.findall(raw_text), 1):\n            yield ReadmeItem.from_parent(\n                self, name=str(idx), spec=code.strip()\n            )\n\n\ndef _with_patched_sleep(func, *args, **kwargs):\n    \"\"\"Patch the sleep function so that it does nothing\"\"\"\n    _sleep = time.sleep\n    time.sleep = lambda *args: None\n    try:\n        return func(*args, **kwargs)\n    finally:\n        time.sleep = _sleep\n\n\nclass ReadmeItem(pytest.Item):\n    \"\"\"A readme test item that validates a code snippet\"\"\"\n    builtins = (\n        ('typing', typing),\n        ('datetime', importlib.import_module('datetime')),\n        ('hashlib', importlib.import_module('hashlib')),\n        ('print', fake_print)\n    )\n\n    def __init__(self, name, parent, spec):\n        super().__init__(name, parent)\n        self.spec = spec\n\n    def runtest(self):\n        \"\"\"Run the test\"\"\"\n        builtins = dict(self.builtins)\n        byte_code = compile(self.spec, '<inline>', 'exec')\n        _with_patched_sleep(exec, byte_code, builtins)\n        msg, _, error = api.run(['--no-color-output', '-c', self.spec])\n        if error:\n            # Ignore missing return statements\n            if \"Missing return statement\" in msg:\n                return\n            # Ignore missing errors related to the injected names\n            for name in builtins:\n                if f\"Name '{name}' is not defined\" in msg:\n                    break\n            else:\n                raise MyPyValidationError(msg)\n\n    def repr_failure(self, excinfo, **kwargs):\n        \"\"\" called when self.runtest() raises an exception. \"\"\"\n        return (\n            f\"Code snippet {self.name} raised an error: {excinfo.value}. \"\n            f\"The executed code was: {self.spec}\"\n        )\n\n    def reportinfo(self):\n        \"\"\"Report some basic information on the test outcome\"\"\"\n        return self.fspath, 0, \"usecase: {}\".format(self.name)\n"
        },
        {
          "name": "requirements.txt",
          "type": "blob",
          "size": 0.01171875,
          "content": "pytest\nmypy\n"
        }
      ]
    }
  ]
}