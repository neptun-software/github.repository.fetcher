{
  "metadata": {
    "timestamp": 1736559924993,
    "page": 691,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjcwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "CHNZYX/Auto_Simulated_Universe",
      "stars": 3564,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.4638671875,
          "content": "__pycache__/\nvenv/\n.idea/\n.vscode/\nbuild/\ndist/\nimg/\ntest.*\n*.spec\nimgs/bigmap.jpg\nimgs/bwmap.jpg\nimgs/maxloc.jpg\nimgs/screen.jpg\nimgs/sbl.jpg\nimgs/tbw.jpg\nimgs/tmp.jpg\nimgs/tmp_0.jpg\nimgs/tmp1.jpg\nimgs/tmp2.jpg\nimgs/tmp3.jpg\nimgs/tmp4.jpg\nimgs/tmp5.jpg\nimgs/tmp6.jpg\nimgs/collect\nlogs/\nmy_map\n.notif\ncheck0.txt\ncheck5.txt\n*.zip\nocr/\ninfo.yml\ninfo_old.yml\nversion.txt\n*.exe\ntest.py\nmylib.py\nmylib.bat\ntmp.py\ntarg\ntmp\nbig.jpg\nbw.jpg\ntp.jpg\ntp\nutils/mylib/\nupdate.py\nupdate.bat"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0380859375,
          "content": "MIT License\n\nCopyright (c) 2023 CHNZYX\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 8.349609375,
          "content": "[简体中文](README.md) | [繁体中文](README_CHT.md) | [English](README_ENG.md)\n\n# Auto_Simulated_Universe\n星穹铁道-模拟宇宙全自动化\n\n快速上手，请访问：[项目文档](https://asu.stysqy.top/) [备用](https://github.com/Night-stars-1/Auto_Simulated_Universe_Docs/blob/docs/docs/guide/index.md)\n\n遇到问题，请在提问前查看：[Q&A](https://asu.stysqy.top/guide/qa.html) [备用](https://github.com/Night-stars-1/Auto_Simulated_Universe_Docs/blob/docs/docs/guide/qa.md)\n\n运行自动化时不能用电脑做其他事？试试多用户后台运行！[后台运行](https://asu.stysqy.top/guide/bs.html) [备用](https://github.com/Night-stars-1/Auto_Simulated_Universe_Docs/blob/docs/docs/guide/bs.md)\n\n此页面主要介绍差分宇宙自动化，如需详细的普通模拟宇宙自动化介绍请移步[普通宇宙](https://github.com/CHNZYX/Auto_Simulated_Universe/blob/old/README.md)\n\n----------------------------------------------------------------------------------------------\n\n## 免责声明\n本软件是一个外部工具旨在自动化崩坏星轨的游戏玩法。它被设计成仅通过现有用户界面与游戏交互,并遵守相关法律法规。该软件包旨在提供简化和用户通过功能与游戏交互,并且它不打算以任何方式破坏游戏平衡或提供任何不公平的优势。该软件包不会以任何方式修改任何游戏文件或游戏代码。\n\nThis software is open source, free of charge and for learning and exchange purposes only. The developer team has the final right to interpret this project. All problems arising from the use of this software are not related to this project and the developer team. If you encounter a merchant using this software to practice on your behalf and charging for it, it may be the cost of equipment and time, etc. The problems and consequences arising from this software have nothing to do with it.\n\n本软件开源、免费，仅供学习交流使用。开发者团队拥有本项目的最终解释权。使用本软件产生的所有问题与本项目与开发者团队无关。若您遇到商家使用本软件进行代练并收费，可能是设备与时间等费用，产生的问题及后果与本软件无关。\n\n\n请注意，根据MiHoYo的 [崩坏:星穹铁道的公平游戏宣言]([https://hsr.hoyoverse.com/en-us/news/111244](https://sr.mihoyo.com/news/111246?nav=news&type=notice)):\n\n    \"严禁使用外挂、加速器、脚本或其他破坏游戏公平性的第三方工具。\"\n    \"一经发现，米哈游（下亦称“我们”）将视违规严重程度及违规次数，采取扣除违规收益、冻结游戏账号、永久封禁游戏账号等措施。\"\n\n## 安装GUI [![](https://img.shields.io/github/downloads/CHNZYX/Auto_Simulated_Universe/total?color=66ccff)](https://github.com/CHNZYX/Auto_Simulated_Universe/releases)\n\n\\[新增\\]: v7.2后支持云·星穹铁道。云崩铁要用网页应用打开，直接在网页打开会无法识别。需要关闭网速和延迟显示；同时需要设置为全屏幕，并且物理屏幕分辨率为x\\*1080(x>=1920)。若无法达到要求，建议在多用户下开启。\n\n## 命令行用法\n\n只支持x\\*1080(x>=1920,窗口化或全屏幕)，关闭hdr，文本语言选择简体中文，游戏界面不能有任何遮挡。代码版[下载链接](https://github.com/CHNZYX/Auto_Simulated_Universe/archive/refs/heads/main.zip)\n\n如果没怎么接触过python，建议直接在[release](https://github.com/CHNZYX/Auto_Simulated_Universe/releases/latest)中下载gui版本，并直接阅读GUI使用方法\n\n**第一次运行**\n\n建议使用anaconda，创建虚拟环境并安装依赖库（conda需要在cmd下运行，powershell可能无法切换虚拟环境）\n\n```plaintext\nconda create -n asu python=3.12 -y\nconda activate asu\npip install -r requirements.txt\n```\n\n或者直接安装（不建议）：双击`install_requirements.bat`安装依赖库\n\n重命名info_example.yml为info.yml\n\n**运行自动化**\n\n命令行运行\n\n差分宇宙\n```plaintext\npython diver.py\n```\n\n或普通模拟宇宙\n```plaintext\npython simul.py\n```\n\n详细参数：\n```plaintext\npython diver.py <--debug> <--speed> <--cpu> --nums=<nums>\n```\n--speed：开启速通模式\n\n--debug：开启调试模式\n\n--cpu：图像识别强制使用cpu\n\nnums：指定通关次数，必须为正整数\n\n```plaintext\npython simul.py --bonus=<bonus> --debug=<debug> --speed=<speed> --find=<find> --nums=<nums>\n```\nbonus in [0,1]：是否开启沉浸奖励\n\nspeed in [0,1]：开启速通模式\n\nconsumable in [0,1]：精英和首领战之前是否使用最左上角的消耗品\n\ndebug in [0,1,2]：开启调试模式\n\nfind in [0,1]：0为录图，1为跑图\n\nnums：指定通关次数，必须为正整数\n\n----------------------------------------------------------------------------------------------\n\n`info.yml`内容如下\n```yaml\nconfig:\n  # 难度，1-5，（5代表最高难度，如果世界没有难度5则会选择难度4）\n  difficulty: 5\n  # 队伍类型 目前只支持：追击/dot/终结技/击破/盾反\n  team: 终结技\n  # 速通模式\n  speed_mode: 0\n  # 图像识别强制使用cpu\n  cpu_mode: 0\n  # 首领房间需要开秘技的角色，按顺序开\n  skill:\n    - 黄泉\n  # 自动存档数量，0-4，0代表不存档，1-4代表自动存档到前1-4个存档位\n  save: 4\n  timezone: Default\n  max_run: 34\n```\n\n必须携带至少一名远程平a角色，最好放在1号位\n\n注意！！！！！ 开始运行/开始校准之后就不要移动游戏窗口了！要移动请先停止自动化！\n\n**校准**\n\n如果出现视角转动过大/过小而导致迷路的问题，可能是校准值出问题了，可以尝试手动校准：\n\n进入游戏，将人物传送到黑塔的办公室，然后命令行运行 `python align_angle.py`，等待视角转换/原地转圈结束\n\n改变鼠标dpi可能会影响校准值，此时需要重新校准。\n\n## GUI使用方法\n\n**第一次运行**\n\n在游戏中设置“自动沿用战斗设置”\n\n**运行自动化**\n\n点击运行\n\n注意！！！！！ 开始运行/开始校准之后就不要移动游戏窗口了！要移动请先停止自动化！\n\n**TIPS：**\n\n尽量使用远程角色作为一号位，队伍中必须至少有一名远程角色。\n\nF8/‘停止’按钮停止运行。\n\n显隐表示显示/隐藏命令行窗口，默认隐藏\n\n调试模式：如果不希望迷路后退出结算，请开启调试模式\n\n速通模式：开启表示追求最高效率通关，低配队伍慎用\n\n推荐最低画质配置：\n\n![画质](https://github.com/CHNZYX/Auto_Simulated_Universe/blob/main/imgs/image_quality.jpg)\n\n**校准**\n\n如果出现视角转动过大/过小而导致迷路的问题，可能是校准值出问题了，可以尝试手动校准：\n\n进入游戏，将人物传送到黑塔的办公室，然后点击校准，等待视角转换/原地转圈结束\n\n改变鼠标dpi可能会影响校准值，此时需要重新校准。\n\n## 更新\n\n~~双击update.exe~~\n\n## 通知插件使用方法（notif.exe）\n\n如果你没有用本地多用户，那么直接双击`notif.exe`即可开启windows通知，每刷完一次都会通知哦\n\n如果你用了本地多用户，那么请在子用户运行gui，在主用户运行notif，这样就能在主用户收到通知了\n\n计数会在每周自动重置，如果想手动改变计数，请打开`logs/notif.txt`，修改第一行的信息\n\n通知插件会在右下角显示托盘图标\n\n----------------------------------------------------------------------------------------------\n\n~~欢迎加入，欢迎反馈bug，QQ群：831830526~~\n\n~~群没了，可以加736265667~~\n\n二群545443061\n\n----------------------------------------------------------------------------------------------\n\n如果喜欢本项目，可以打赏送作者一杯咖啡喵！\n\n![打赏](https://github.com/CHNZYX/Auto_Simulated_Universe/blob/main/imgs/money.jpg)\n\n----------------------------------------------------------------------------------------------\n## 贡献者\n\n感谢以下贡献者对本项目做出的贡献\n\n<a href=\"https://github.com/CHNZYX/Auto_Simulated_Universe/graphs/contributors\">\n\n  <img src=\"https://contrib.rocks/image?repo=CHNZYX/Auto_Simulated_Universe\" />\n\n</a>\n\n![Alt](https://repobeats.axiom.co/api/embed/a24da575ebc375e58ec8d8a0d7fff6d26306d2fc.svg \"Repobeats analytics image\")\n\n## Star History\n\n[![Star History Chart](https://api.star-history.com/svg?repos=CHNZYX/Auto_Simulated_Universe&type=Date)](https://star-history.com/#CHNZYX/Auto_Simulated_Universe&Date)\n"
        },
        {
          "name": "README_CHT.md",
          "type": "blob",
          "size": 8.60546875,
          "content": "[簡體中文](README.md) | [繁體中文](README_CHT.md) | [English](README_ENG.md)\n\n# Auto_Simulated_Universe\n星穹鐵道-模擬宇宙全自動化\n\n有一定的斷點回復功能，你可以切出去做其他事，切回來會繼續自動化。\n\n目前支持模擬宇宙所有世界\n\n----------------------------------------------------------------------------------------------\n\n## 免責聲明\n本軟件是一個外部工具旨在自動化崩壞星軌的遊戲玩法。它被設計成僅通過現有用戶界面與遊戲交互,並遵守相關法律法規。該軟件包旨在提供簡化和用戶通過功能與遊戲交互,並且它不打算以任何方式破壞遊戲平衡或提供任何不公平的優勢。該軟件包不會以任何方式修改任何遊戲文件或遊戲代碼。\n\nThis software is open source, free of charge and for learning and exchange purposes only. The developer team has the final right to interpret this project. All problems arising from the use of this software are not related to this project and the developer team. If you encounter a merchant using this software to practice on your behalf and charging for it, it may be the cost of equipment and time, etc. The problems and consequences arising from this software have nothing to do with it.\n\n本軟件開源、免費，僅供學習交流使用。開發者團隊擁有本項目的最終解釋權。使用本軟件產生的所有問題與本項目與開發者團隊無關。若您遇到商家使用本軟件進行代練並收費，可能是設備與時間等費用，產生的問題及後果與本軟件無關。\n\n\n請註意，根據MiHoYo的 [崩壞:星穹鐵道的公平遊戲宣言]([https://hsr.hoyoverse.com/en-us/news/111244](https://sr.mihoyo.com/news/111246?nav=news&type=notice)):\n\n    \"嚴禁使用外掛、加速器、腳本或其他破壞遊戲公平性的第三方工具。\"\n    \"一經發現，米哈遊（下亦稱「我們」）將視違規嚴重程度及違規次數，采取扣除違規收益、凍結遊戲賬號、永久封禁遊戲賬號等措施。\"\n\n### 用法\n\n只支持1920\\*1080(窗口化或全屏幕)，關閉hdr，文本語言選擇簡體中文。\n\n默認世界：比如說如果你當前模擬宇宙默認世界4，但是想自動化世界6，那麽請先進入一次世界6來改變默認世界\n\n如果沒怎麽接觸過python，建議直接在[release](https://github.com/CHNZYX/Auto_Simulated_Universe/releases/latest)中下載gui版本，並直接閱讀GUI使用方法\n\n**第一次運行**\n\n雙擊`install_requirements.bat`安裝依賴庫\n\n重命名info_example.yml為info.yml\n\n**運行自動化**\n\n雙擊`run.bat` 或者 命令行運行 \n```plaintext\npython states.py\n```\n\n詳細參數：\n```plaintext\npython states.py --bonus=<bonus> --debug=<debug> --speed=<speed> --find=<find>\n```\nbonus in [0,1]：是否開啟沈浸獎勵\n\nspeed in [0,1]：開啟速通模式\n\nconsumable in [0,1]：菁英和首領戰之前是否使用最左上角的消耗品\n\ndebug in [0,1,2]：開啟調試模式\n\nfind in [0,1]：0為錄圖，1為跑圖\n\n----------------------------------------------------------------------------------------------\n\n`info.yml`內容如下\n```yaml\nconfig:\n  order_text: [1, 2, 3, 4] //模擬宇宙開局選的角色，建議改成自己的配隊，1表示第一個角色。最好在一號位選遠程角色（艾絲妲、三月七）方便開怪。\n  angle: 1.0  //校準數據請勿更改\n  difficulty: 4 //宇宙的難度，如果你要打難度1就改成1保存\n  fate: 巡獵 //命途選擇，默認巡獵，可以直接修改為其它命途。\n  map_sha: '' //地圖數據的版本，不建議更改\n  show_map_mode: 0\n  debug_mode: 0\n  speed_mode: 0\n  use_consumable: 0\n  slow_mode: 0\n  force_update: 0\n  timezone: Default\nprior:\n  優先級信息，按需調整\n```\n\n默認是哪個宇宙就會進哪個！如果你默認不是第6世界，記得先手動切到第6世界！\n\n盡量使用遠程成女角色作為一號位，近戰成女也能適配，其它體型（成男等）會出現穩定性問題。\n\n註意！！！！！ 開始運行/開始校準之後就不要移動遊戲窗口了！要移動請先停止自動化！\n\n**校準**\n\n如果出現視角轉動過大/過小而導致迷路的問題，可能是校準值出問題了，可以嘗試手動校準：\n\n進入遊戲，將人物傳送到黑塔的辦公室，然後雙擊 `align.bat`，等待視角轉換/原地轉圈結束\n\n如果`align.bat`閃退，可以嘗試命令行\n```plaintext\npython align_angle.py\n```\n\n改變鼠標dpi可能會影響校準值，此時需要重新校準。\n\n**更新文件**\n\n雙擊`update.bat`\n\n\n### GUI使用方法\n\n**第一次運行**\n\n在設置中選擇自己想要的難度和命途，配隊請在遊戲中預先選擇默認配隊\n\n最好在一號位選遠程角色（艾絲妲、三月七等）方便開怪。\n\n**運行自動化**\n\n點擊運行\n\n註意！！！！！ 開始運行/開始校準之後就不要移動遊戲窗口了！要移動請先停止自動化！\n\n**TIPS：**\n\n盡量使用遠程成女角色作為一號位，近戰成女也能適配，其它體型（成男等）會出現穩定性問題。\n\nF8/『停止』按鈕停止運行。\n\n顯隱表示顯示/隱藏命令行窗口，默認隱藏\n\n調試模式：如果不希望迷路後退出結算，請開啟調試模式\n\n如果不希望打完34次後自動停止，也請開啟調試模式\n\n速通模式：開啟表示只打每層最後一個怪\n\n推薦最低畫質配置：\n\n![畫質](https://github.com/CHNZYX/Auto_Simulated_Universe/blob/main/imgs/image_quality.jpg)\n\n**校準**\n\n如果出現視角轉動過大/過小而導致迷路的問題，可能是校準值出問題了，可以嘗試手動校準：\n\n進入遊戲，將人物傳送到黑塔的辦公室，然後點擊校準，等待視角轉換/原地轉圈結束\n\n改變鼠標dpi可能會影響校準值，此時需要重新校準。\n\n### 更新\n\n雙擊update.exe\n\n### 自動深淵\n\n自動深淵可以使用固定配隊自動刷忘卻之庭，這項功能的目的是節省手動刷前幾層的時間。\n\n代碼版啟動方法為`python abyss.py`，gui版啟動方法為主界面中的「深淵」按鈕。\n\n代碼版第一次運行需要修改abyss文件夾下的info_example.yml為info.yml，並且修改info.yml為自己的兩隊配隊，gui版可以在深淵界面中輸入自己的配隊。\n\n每隊的配隊信息為四個數字\n\n![配隊編號](https://github.com/CHNZYX/Auto_Simulated_Universe/blob/main/imgs/team.jpg)\n\n比如說這張圖中，你想選擇娜塔莎，景元，希兒，彥卿，那麽請在配隊中輸入：`6 4 3 2`\n\n### 通知插件使用方法（notif.exe）\n\n如果你沒有用本地多用戶，那麽直接雙擊`notif.exe`即可開啟windows通知，每刷完一次都會通知哦\n\n如果你用了本地多用戶，那麽請在子用戶運行gui，在主用戶運行notif，這樣就能在主用戶收到通知了\n\n計數會在每周自動重置，如果想手動改變計數，請打開`logs/notif.txt`，修改第一行的信息\n\n通知插件會在右下角顯示托盤圖標\n\n----------------------------------------------------------------------------------------------\n\n### 部分邏輯\n\n選擇祝福的邏輯基於ocr+自定義優先級\n\n尋路模塊基於小地圖\n\n小地圖中只會識別白色邊緣線和黃色交互點。\n\n----------------------------------------------------------------------------------------------\n\n支持錄製地圖，具體方法為\n\n運行 `python states.py --debug=2 --find=1`\n\n如果遇到新圖會角色停住，這時候結束自動化並且遊戲中暫離模擬宇宙\n\n然後運行 `python states.py --debug=2 --find=0`\n\n運行後會自動進入地圖，期間請不要移動鼠標也不要動鍵盤\n\n幾秒後角色會後退，然後前進。在角色前進時，你可以移動鼠標改變視角，也可以按鍵盤wasd。\n\n在地圖中繞一圈，感覺差不多就`F8/ctrl+c`結束進程能得到地圖數據了。保存在`imgs/maps/my_xxxxx`目錄下（可以按修改時間排序）\n\n有怪的圖最好用希兒戰技，被鎖定會影響小地圖識別。\n\n`imgs/maps/my_xxxxx`目錄下會存在`target.jpg`，你可以用windows自帶的畫圖打開它，然後在上面標記點（可以參考其它地圖文件中的`target.jpg`）\n\n靛藍色：路徑點 黃色：終點 綠色：交互點（問號點） 紅色：怪點\n\n錄製結束後可以暫離並重新運行自動化測試地圖，如果通過測試，你就成功錄製到了新圖！\n\n----------------------------------------------------------------------------------------------\n\n歡迎加入，歡迎反饋bug，QQ群：831830526\n\n----------------------------------------------------------------------------------------------\n\n![打賞](https://github.com/CHNZYX/Auto_Simulated_Universe/blob/main/imgs/money.jpg)\n"
        },
        {
          "name": "README_ENG.md",
          "type": "blob",
          "size": 10.115234375,
          "content": "[简体中文](README.md) | [繁体中文](README_CHT.md) | [English](README_ENG.md)\n\n\n# Auto_Simulated_Universe\nStar Rail - Auto Simulated Universe\n\nThis project incorporates a pause-resume feature. You can switch to other tasks and return later to continue the automation process.\n\nCurrently supports automation of all worlds within the simulated universe.\n\n----------------------------------------------------------------------------------------------\n\n## Disclaimer\nThis software is an external tool intended to automate gameplay in the game \"Honkai Star Rail.\" It is designed to interact with the game solely through existing user interfaces and in compliance with relevant laws and regulations. This software package aims to provide simplification and user interaction with the game's features and does not intend to disrupt game balance or provide any unfair advantages. The package will not modify any game files or game code in any way.\n\nThis software is open-source and free of charge, intended for educational and collaborative purposes only. The development team holds the final interpretation rights for this project. Any issues arising from the use of this software are unrelated to this project and the development team. If you come across merchants using this software for power-leveling and charging for it, the costs might involve equipment and time, and any issues or consequences arising from this software are unrelated to it.\n\nPlease note that according to MiHoYo's [Fair Play Declaration for Honkai Star Rail](https://hsr.hoyoverse.com/en-us/news/111244):\n\n    \"The use of plug-ins, accelerators, scripts, or other third-party tools that disrupt the fairness of the game is strictly prohibited.\"\n    \"Once discovered, miHoYo (hereinafter referred to as 'we') will take measures such as deducting illegal gains, freezing game accounts, and permanently banning game accounts based on the severity and frequency of violations.\"\n\n### Usage\n\nOnly supports 1920x1080 resolution (windowed or fullscreen), turn off hdr, and text language selection is simplified Chinese.\n\nDefault World: For instance, if your current default world in the simulated universe is World 4 but you want to automate World 6, please enter World 6 once to change the default world.\n\nIf you're not familiar with Python, it's recommended to directly download the GUI version from the [release](https://github.com/CHNZYX/Auto_Simulated_Universe/releases/latest) and follow the GUI usage instructions.\n\n**First-time Setup**\n\nDouble-click `install_requirements.bat` to install the required libraries.\n\nRename `info_example.yml` to `info.yml`.\n\n**Running Automation**\n\nDouble-click `run.bat` or run in the command line:\n```plaintext\npython states.py\n```\n\nDetailed parameters:\n```plaintext\npython states.py --bonus=<bonus> --debug=<debug> --speed=<speed> --find=<find>\n```\nbonus in [0,1]: Whether to enable immersion bonus.\n\nspeed in [0,1]: Enable speedrun mode.\n\nconsumable in [0,1]：Enable using the most top-left consumable before elite & boss battle\n\ndebug in [0,1,2]: Enable debug mode.\n\nfind in [0,1]: 0 for recording, 1 for speedrunning.\n\nThe content of `info.yml` is as follows:\n```yaml\nconfig:\n  order_text: [1, 2, 3, 4] # Character selection order at the start of the simulation. Change this according to your team composition. 1 represents the first character. It's advisable to put ranged characters (like Asta or March 7th) in position 1 for better monster clearing.\n  angle: 1.0  # Calibration data, do not modify.\n  difficulty: 4 # Universe difficulty, change to 1 if you want to play on difficulty 1.\n  fate: 巡猎 # Fate selection, default is 巡猎, you can directly modify it to other fates.\n  map_sha: '' # Map data version, not recommended to change.\n  show_map_mode: 0\n  debug_mode: 0\n  speed_mode: 0\n  use_consumable: 0\n  slow_mode: 0\n  force_update: 0\n  timezone: Default\nprior:\n  # Priority information, adjust as needed.\n```\n\nThe simulation will enter the world that corresponds to the default setting. If your default world is not World 6, remember to manually switch to World 6 first!\n\nPrefer using ranged female characters in the first slot whenever possible. Melee females can also be viable, while other body types (e.g., male characters) may result in stability issues.\n\nImportant!!! Once you start running/calibrating, do not move the game window! If you need to move it, please stop the automation first!\n\n**Calibration**\n\nIf you're experiencing issues like excessive/inadequate camera rotation leading to getting lost, it might be due to calibration. You can manually calibrate as follows:\n\nEnter the game and teleport your character to Herta's office. Then, double-click `align.bat` and wait for the camera to rotate/character to spin in place.\n\nIf `align.bat` crashes, you can try using the command line:\n```plaintext\npython align_angle.py\n```\n\nChanging your mouse DPI might affect calibration values, in which case, you'll need to recalibrate.\n\n**Updating Files**\n\nDouble-click `update.bat`.\n\n### GUI Usage Instructions\n\n**First-time Setup**\n\nIn the settings, select your desired difficulty and fate. Please pre-select your default team composition in the game.\n\nIt's advisable to put a ranged character (like Asta or March 7th) in the first position for better monster clearing.\n\n**Running Automation**\n\nClick the \"运行\" button.\n\nImportant!!! Once you start running/calibrating, do not move the game window! If you need to move it, please stop the automation first!\n\n**TIPS:**\n\nPress F8 or the \"停止\" button to halt the process.\n\nPrefer using ranged female characters in the first slot whenever possible. Melee females can also be viable, while other body types (e.g., male characters) may result in stability issues.\n\n\"显隐\" checkbox toggles the visibility of the command-line window. It's hidden by default.\n\n调试模式: If you don't want to exit the settlement after getting lost, please enable debug mode.\n\nIf you don't want it to automatically stop after completing 34 rounds, also enable debug mode.\n\n速通模式: Enabling this means you'll only fight the final enemy on each level.\n\nRecommended minimal graphics settings:\n\n![Graphics Settings](https://github.com/CHNZYX/Auto_Simulated_Universe/blob/main/imgs/image_quality.jpg)\n\n**Calibration**\n\nIf you're experiencing issues like excessive/inadequate camera rotation leading to getting lost, it might be due to calibration. You can manually calibrate as follows:\n\nEnter the game and teleport your character to Herta's office. Then, click the \"Calibrate\" button, and wait for the camera to rotate/character to spin in place.\n\nChanging your mouse DPI might affect calibration values, in which case, you'll need to recalibrate.\n\n### Update\n\nDouble-click `update.exe`.\n\n### Automatic Abyss\n\nAutomatic Abyss allows you to use a fixed team to automatically clear the Oblivion Domains, saving time on manual clearing of the initial levels.\n\nTo run the script version, use `python abyss.py`. For the GUI version, click the \"Abyss\" button on the main interface.\n\nFor the script version's first run, modify the `info_example.yml` file in the \"abyss\" folder to `info.yml`, and edit `info.yml` with your two-team composition. In the GUI version, you can input your team composition in the Abyss interface.\n\nEach team's composition is represented by four numbers.\n\n![Team Composition Numbers](https://github.com/CHNZYX/Auto_Simulated_Universe/blob/main/imgs/team.jpg)\n\nFor instance, in the image above, if you want to choose Natasha, Jing Yuan, Seele, and Yan Qing, input: `6 4 3 2`.\n\n### Notification Plugin Instructions (notif.exe)\n\nIf you're not using a local multi-user setup, simply double-click\n\n `notif.exe` to enable Windows notifications. You'll receive notifications after each completion.\n\nIf you're using a local multi-user setup, run the GUI version in the sub-user account and `notif.exe` in the main user account. This way, notifications will be sent to the main user.\n\nThe counter resets automatically weekly. If you wish to manually modify the count, open `logs/notif.txt` and edit the first line.\n\nThe notification plugin displays a tray icon in the bottom-right corner.\n\n----------------------------------------------------------------------------------------------\n\n### Logic Overview\n\nBlessing selection logic is based on OCR and custom priority settings.\n\nPathfinding module uses a mini-map.\n\nThe mini-map only recognizes white edge lines and yellow interaction points.\n\n----------------------------------------------------------------------------------------------\n\nSupport for recording maps is available:\n\nRun `python states.py --debug=2 --find=1`.\n\nIf a new map is encountered and your character stops, end the automation and put the game in pause mode in the Simulated Universe.\n\nThen, run `python states.py --debug=2 --find=0`.\n\nThe script will automatically enter the map. During this process, do not move the mouse or press any keys.\n\nAfter a few seconds, the character will move backward and then forward. During the forward movement, you can move the mouse to change the camera angle or use WASD on the keyboard.\n\nMove around the map, and when you feel it's sufficient, press F8 or Ctrl+C to terminate the process. This will capture the map data. It will be saved in the `imgs/maps/my_xxxxx` directory (sorted by modification time).\n\nFor maps with monsters, it's advisable to use Seele's ultimate ability. Being locked onto a target can affect the mini-map recognition.\n\nA `target.jpg` file will be present in the `imgs/maps/my_xxxxx` directory. You can use the built-in Paint application on Windows to open it and mark points (you can refer to the `target.jpg` file in other map folders).\n\nIndigo: Path point, Yellow: Destination, Green: Interaction point (question mark), Red: Enemy point\n\nAfter recording, you can exit the game and re-run the automation to test the map. If the test is successful, you've successfully recorded a new map!\n\n----------------------------------------------------------------------------------------------\n\nFeel free to join and provide feedback. QQ Group: 831830526\n\n----------------------------------------------------------------------------------------------\n\nIf you like this project, you can buy the author a cup of coffee!\n\n![Donate](https://github.com/CHNZYX/Auto_Simulated_Universe/blob/main/imgs/money.jpg)\n"
        },
        {
          "name": "abyss.py",
          "type": "blob",
          "size": 6.826171875,
          "content": "import pyautogui\nimport cv2 as cv\nimport numpy as np\nimport time\nimport win32gui\nimport random\nimport sys\nfrom utils.log import log\nfrom utils.simul.utils import UniverseUtils, set_forground\nimport utils.simul.keyops as keyops\nimport os\nimport yaml\nimport pyuac\n\n\nclass Abyss(UniverseUtils):\n    def __init__(self):\n        super().__init__()\n        self.abspath = os.path.dirname(__file__)  # 获取项目根目录../Auto_Simulated_Universe\n        if getattr(sys, 'frozen', False):\n            self.abspath = '.'\n        self.threshold = 0.97\n        self.floor = 0\n        self._stop = 0\n        with open(os.path.join(self.abspath, \"abyss/info.yml\"), \"r\", encoding=\"utf-8\", errors=\"ignore\") as f:\n            config = yaml.safe_load(f)[\"order_text\"]\n            self.team = [config[:4], config[4:]]\n\n    def start_abyss(self):\n        self.fail_drag = 0\n        self.end_battle_time = 0\n        while self._stop == 0:\n            hwnd = win32gui.GetForegroundWindow()  # 根据当前活动窗口获取句柄\n            Text = win32gui.GetWindowText(hwnd)\n            warn_game = False\n            cnt = 0\n            while Text != \"崩坏：星穹铁道\" and not self._stop:\n                self.lst_changed = time.time()\n                if not warn_game:\n                    warn_game = True\n                    log.warning(\"等待游戏窗口\")\n                time.sleep(0.5)\n                cnt += 1\n                if cnt == 1200:\n                    set_forground()\n                hwnd = win32gui.GetForegroundWindow()  # 根据当前活动窗口获取句柄\n                Text = win32gui.GetWindowText(hwnd)\n            self.route()\n            time.sleep(0.2)\n            if self.fail_drag > 4:\n                self.press('esc')\n                break\n\n    def wait(self,peila=False):\n        tm = time.time()\n        ee = -2\n        while self._stop == 0:\n            self.get_screen()\n            hwnd = win32gui.GetForegroundWindow()  # 根据当前活动窗口获取句柄\n            Text = win32gui.GetWindowText(hwnd)\n            if self.check(\"auto_2\", 0.0583, 0.0769) or Text != \"崩坏：星穹铁道\":\n                tm = time.time()\n            if self.check(\"c\", 0.9464, 0.1287, threshold=0.985):\n                if peila:\n                    tm = time.time()\n                    if self.check(\"peila\", 0.6953,0.1880, mask=\"battle_mask\"):\n                        if ee == 3:\n                            ee = 0\n                        else:\n                            self.press(' ')\n                            time.sleep(0.2)\n                            ee += 1\n                        self.press('v')\n                    else:\n                        self.press('v')\n                else:\n                    self.press('v')\n            if peila and self.check_auto():\n                self.press('v')\n                tm = time.time()\n            if time.time() - tm > 14 or self.check(\"abyss/in\", 0.9130, 0.6074):\n                if self.click_text(['返回忘却之庭']):\n                    time.sleep(1.5)\n                self.end_battle_time = time.time()\n                break\n            time.sleep(0.1)\n\n    def ready(self):\n        img = self.get_screen()\n        peila = self.ts.find_text(img, ['佩拉']) is not None\n        for i in range(4):\n            self.press(str(i + 1), 0.2)\n            time.sleep(0.4)\n            self.press(\"e\")\n            time.sleep(1.5)\n            self.get_screen()\n            if not (\n                self.check(\"z\", 0.5010, 0.9426, mask=\"abyss/mask_z\", threshold=0.95)\n                or self.check(\n                    \"abyss/z\", 0.5010, 0.9426, mask=\"abyss/mask_z\", threshold=0.95\n                )\n            ):\n                break\n        time.sleep(1)\n        pyautogui.click()\n        time.sleep(3.5)\n        return peila\n\n    def route(self):\n        img = self.get_screen()\n        # self.click_target('imgs/abyss/fail.jpg',0.9,True)\n        if self.check(\"abyss/fail\", 0.5995, 0.1343):\n            self.click((0.5995, 0.1343))\n        elif self.ts.find_text(img, ['角色编队']) is not None:\n            if self.check(\"abyss/begin\", 0.1062, 0.0815):\n                self.click((0.1062, 0.0806))\n                return\n            if random.randint(0, 1):\n                self.team = self.team[::-1]\n            for i, j in enumerate([(0.4026, 0.3259), (0.4010, 0.2343)]):\n                self.click(j)\n                time.sleep(0.2)\n                for k in self.team[i]:\n                    t = k - 1\n                    if t >= 0:\n                        self.click(\n                            (0.9427 - 0.0661 * (t % 4), 0.8102 - 0.1435 * (t // 4))\n                        )\n                        time.sleep(0.2)\n            self.click((0.1062, 0.0806))\n            time.sleep(1)\n        elif self.ts.find_text(img[:600,:600], ['取得胜利时']) is not None:\n            time.sleep(2)\n            if time.time() - self.end_battle_time > 10:\n                self.click((0.5, 0.14))\n            time.sleep(2)\n            self.press(\"w\", 3.5)\n            t = self.move_to_interac(1, 1)\n            if abs(t) > 30:\n                self.press(\"w\", 1)\n            peila = self.ready()\n            self.wait(peila=peila)\n            if abs(t) > 30:\n                time.sleep(1)\n                self.press(\"w\")\n                time.sleep(0.3)\n                self.move_to_interac(1, 1)\n                self.press(\"w\", 1.7)\n                peila = self.ready()\n                self.wait(peila=peila)\n        elif self.check(\"abyss/6\", 0.5661, 0.5713):\n            self.click((0.5, 0.2))\n        elif self.check(\"abyss/5\", 0.1125, 0.9389):\n            self.click((0.9, 0.9))\n            time.sleep(0.3)\n            self.get_screen()\n            gray = [156, 122, 126]\n            gray2 = [118, 107, 111]\n            bw_map = np.zeros(self.screen.shape[:2], dtype=np.uint8)\n            bw_map[np.sum((self.screen - gray) ** 2, axis=-1) <= 800] = 255\n            bw_map[np.sum((self.screen - gray2) ** 2, axis=-1) <= 800] = 255\n            # cv.imwrite('tp.jpg',bw_map)\n            res = (-1, -1)\n            for i in [\"3_stars\", \"2_stars\", \"1_star\"]:\n                target = cv.imread(self.format_path(\"abyss/\" + i), cv.IMREAD_GRAYSCALE)\n                result = cv.matchTemplate(bw_map, target, cv.TM_CCORR_NORMED)\n                min_val, max_val, min_loc, max_loc = cv.minMaxLoc(result)\n                if max_val > 0.88:\n                    res = max_loc\n                    break\n            if res != (-1, -1):\n                self.click((1 - res[0] / self.xx + 0.06, 1 - res[1] / self.yy + 0.02))\n            else:\n                self.drag((0.5, 0.5), (0.8 - 0.6 * random.randint(0, 1), 0.5))\n                self.fail_drag += 1\n        else:\n            print('未知界面')\n            self.click((0.5, 0.14))\n            time.sleep(1)\n\n\nif __name__ == \"__main__\":\n    if not pyuac.isUserAdmin():\n        pyuac.runAsAdmin()\n    else:\n        abyss = Abyss()\n        abyss.start_abyss()\n"
        },
        {
          "name": "abyss",
          "type": "tree",
          "content": null
        },
        {
          "name": "actions",
          "type": "tree",
          "content": null
        },
        {
          "name": "align_angle.py",
          "type": "blob",
          "size": 2.2080078125,
          "content": "import time\n\nimport numpy as np\nimport pywintypes\nimport win32api\nimport win32con\nimport win32gui\nimport pyuac\nfrom utils.log import log\n\n\ndef get_angle(su, safe):\n    import cv2\n    su.press(\"w\")\n    time.sleep(0.5)\n    su.get_screen()\n    shape = (int(su.scx * 190), int(su.scx * 190))\n    local_screen = su.get_local(0.9333, 0.8657, shape)  # 裁剪后得到的小地图\n    return su.get_now_direc(local_screen)\n\n\n# 不同电脑鼠标移动速度、放缩比、分辨率等不同，因此需要校准\n# 基本逻辑：每次转60度，然后计算实际转了几度，计算出误差比\ndef main(cnt=10, safe=0, ang=[1,1,3], su=None):\n    if su is None or 'Diver' in su.__class__.__name__:\n        from utils.diver.config import config\n    else:\n        from utils.simul.config import config\n    if float(config.angle)>2 and len(ang)<3 and su is not None:\n        su.multi = config.multi\n        return\n    log.info(\"开始校准\")\n    if su is None:\n        from utils.simul.utils import UniverseUtils\n        su = UniverseUtils()\n    su.multi = 1\n    init_ang = get_angle(su, safe)\n    lst_ang = init_ang\n    for i in ang:\n        if lst_ang != init_ang and i==1:\n            continue\n        ang_list = []\n        for j in range(i):\n            su.mouse_move(60, fine=3 // i)\n            time.sleep(0.2)\n            now_ang = get_angle(su, safe)\n            sub = lst_ang - now_ang\n            while sub < 0:\n                sub += 360\n            ang_list.append(sub)\n            lst_ang = now_ang\n        ang_list = np.array(ang_list)\n        # 十/3次转身的角度\n        print(ang_list)\n        ax = 0\n        ay = 0\n        for j in ang_list:\n            if abs(j - np.median(ang_list)) <= 3:\n                ax += 60\n                ay += j\n        su.multi *= ax / ay\n    su.multi += 1e-9\n    try:\n        if not abs(su.multi) <= 2:\n            su.multi = 1\n    except:\n        su.multi = 1\n    config.angle = str(su.multi+len(ang)-1)\n    config.save()\n    if su is None:\n        from utils.simul.config import config\n        config.angle = str(su.multi+len(ang)-1)\n        config.save()\n    log.info(\"校准完成\")\n    return 1\n\n\nif __name__ == \"__main__\":\n    if not pyuac.isUserAdmin():\n        pyuac.runAsAdmin()\n    else:\n        main()\n"
        },
        {
          "name": "diver.py",
          "type": "blob",
          "size": 37.9453125,
          "content": "import threading\nimport traceback\nimport keyboard\nimport pyautogui\nimport cv2 as cv\nimport numpy as np\nimport time\nimport win32gui, win32api, win32con\nimport random\nimport json\nimport sys\nfrom copy import deepcopy\nfrom utils.log import log, set_debug\nfrom utils.log import my_print as print\nfrom utils.log import print_exc\nfrom utils.diver.args import args\nfrom utils.diver.utils import UniverseUtils, set_forground, notif\nimport os\nfrom align_angle import main as align_angle\nfrom utils.diver.config import config\nimport datetime\nimport csv\nimport pytz\nimport pyuac\nimport utils.diver.keyops as keyops\nfrom utils.diver.keyops import KeyController\nimport bisect\nfrom collections import defaultdict\n\n# 版本号\nversion = \"v7.2\"\n\n\nclass DivergentUniverse(UniverseUtils):\n    def __init__(self, debug=0, nums=-1, speed=0):\n        super().__init__()\n        self._stop = True\n        self.end = 0\n        self.floor = 0\n        self.allow_e = 1\n        self.count = self.my_cnt = 0\n        self.debug = debug\n        self.nums = nums\n        self.speed = speed\n        self.init_tm = time.time()\n        self.area_now = None\n        self.action_history = []\n        self.event_prior = self.read_csv(\"actions/event.csv\", name='event')\n        self.character_prior = self.read_csv(\"actions/character.csv\", name='char')\n        self.all_bless = self.read_csv(\"actions/bless.csv\", name='bless')\n        self.bless_prior = defaultdict(int)\n        self.team_member = {}\n        self.ocr_time_list = [0.5]\n        self.fail_tm = 0\n        self.quan = 0\n        self.event_text = ''\n        self.long_range = '1'\n        self.init_floor()\n        self.saved_num = 0\n        self.default_json_path = \"actions/default.json\"\n        self.default_json = self.load_actions(self.default_json_path)\n        if config.weekly_mode:\n            self.default_json['模式选择'][0]['actions'][1]['text'] = '周期演算'\n        if debug != 2:\n            pyautogui.FAILSAFE = False\n        self.update_count()\n        notif(\"开始运行\", f\"初始计数：{self.count}\")\n        set_debug(debug > 0)\n\n    def route(self):\n        self.threshold = 0.97\n        while True:\n            if self._stop:\n                break\n            hwnd = win32gui.GetForegroundWindow()  # 根据当前活动窗口获取句柄\n            Text = win32gui.GetWindowText(hwnd)\n            warn_game = False\n            cnt = 0\n            while Text != \"崩坏：星穹铁道\" and Text != \"云·星穹铁道\" and not self._stop:\n                self.lst_changed = time.time()\n                if self._stop:\n                    raise KeyboardInterrupt\n                if not warn_game:\n                    warn_game = True\n                    log.warning(f\"等待游戏窗口，当前窗口：{Text}\")\n                time.sleep(0.5)\n                cnt += 1\n                if cnt == 1200:\n                    set_forground()\n                hwnd = win32gui.GetForegroundWindow()  # 根据当前活动窗口获取句柄\n                Text = win32gui.GetWindowText(hwnd)\n            if self._stop:\n                break\n            # self.click_target('imgs/divergent/sile.jpg',0.9,True) # 如果需要输出某张图片在游戏窗口中的坐标，可以用这个\n            self.loop()\n        log.info(\"停止运行\")\n\n    def loop(self):\n        self.ts.forward(self.get_screen())\n        # self.ts.find_with_box()\n        # exit()\n        res = self.run_static()\n        if res == '':\n            area_text = self.clean_text(self.ts.ocr_one_row(self.screen, [50, 350, 3, 35]), char=0)\n            if '位面' in area_text or '区域' in area_text or '第' in area_text:\n                self.area()\n            elif self.check(\"c\", 0.9417, 0.1204, threshold=0.965):\n                self.press('v')\n            else:\n                text = self.merge_text(self.ts.find_with_box([400, 1920, 100, 600], redundancy=0))\n                if self.speed and '转化' in text and '继续战斗' not in text and ('数据' in text or '过量' in text):\n                    print('ready to stop')\n                    time.sleep(6)\n                    tm = time.time()\n                    while time.time() - tm < 15:\n                        print('trying to stop')\n                        self.press('esc')\n                        time.sleep(2)\n                        self.ts.forward(self.get_screen())\n                        static_res = self.run_static(action_list=['过量转化'])\n                        if static_res != '':\n                            print(static_res)\n                            break\n        if self.end and res == '加载界面':\n            self.press('esc')\n            time.sleep(2)\n            self.press('esc')\n            self._stop = True\n        \n    def do_action(self, action) -> int:\n        if type(action) == str:\n            return getattr(self, action)()\n        if \"text\" in action:\n            if \"box\" in action:\n                box = action[\"box\"]\n            else:\n                box = [0, 1920, 0, 1080]\n            text = self.ts.find_with_box(box, redundancy=action.get(\"redundancy\", 30))\n            for i in text:\n                if action[\"text\"] in i[\"raw_text\"]:\n                    log.info(f\"点击 {action['text']}:{i['box']}\")\n                    self.click_box(i[\"box\"])\n                    return 1\n        elif \"position\" in action:\n            log.info(f\"点击 {action['position']}\")\n            self.click_position(action[\"position\"])\n            return 1\n        elif \"sleep\" in action:\n            time.sleep(float(action[\"sleep\"]))\n            return 1\n        elif \"press\" in action:\n            self.press(action[\"press\"], action[\"time\"] if \"time\" in action else 0)\n            return 1\n        return 0\n    \n    def load_actions(self, json_path):\n        res = defaultdict(list)\n        with open(json_path, \"r\", encoding=\"utf-8\") as f:\n            for i in json.load(f):\n                res[i[\"name\"]].append(i)\n        return res\n\n    def run_static(self, json_path=None, json_file=None, action_list=[], skip_check=0) -> str:\n        if json_file is None:\n            if json_path is None:\n                json_file = self.default_json\n            else:\n                json_file = self.load_actions(json_path)\n        for j in action_list if len(action_list) else json_file:\n            for i in json_file[j]:\n                trigger = i[\"trigger\"]\n                text = self.ts.find_with_box(trigger[\"box\"], redundancy=trigger.get(\"redundancy\", 30))\n                if skip_check or (len(text) and trigger[\"text\"] in self.merge_text(text)):\n                    log.info(f\"触发 {i['name']}:{trigger['text']}\")\n                    for j in i[\"actions\"]:\n                        self.do_action(j)\n                    self.action_history.append(i[\"name\"])\n                    self.action_history = self.action_history[-10:]\n                    return i['name']\n        return ''\n    \n    def select_difficulty(self):\n        time.sleep(0.5)\n        self.click_position([125, 175+int((self.diffi-1)*(605-175)/4)])\n\n    def read_csv(self, file_path, name):\n        with open(file_path, mode='r', newline='', encoding='cp936') as file:\n            reader = csv.reader(file)\n            next(reader)\n            if name == 'char':\n                data = defaultdict(dict)\n                for row in reader:\n                    data[row[0]].update({white:int(row[3]) for white in row[1].replace('，',',').split(',')})\n                    data[row[0]].update({black:-int(row[3]) for black in row[2].replace('，',',').split(',')})\n            else:\n                data = {row[0]:[s.replace('，',',') for s in row[1:]] for row in reader}\n        return data\n\n    def clean_text(self, text, char=1):\n        symbols = r\"[!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~—“”‘’«»„…·¿¡£¥€©®™°±÷×¶§‰]，。！？；：（）【】「」《》、￥ \"\n        if char:\n            symbols += r\"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n        translator = str.maketrans('', '', symbols)\n        return text.translate(translator)\n\n    def merge_text(self, text, char=1):\n        return self.clean_text(''.join([i['raw_text'] for i in self.ts.sort_text(text)]), char)\n    \n    def init_floor(self):\n        self.portal_cnt = 0 \n        self.area_state = 0\n        self.event_solved = 0\n        self.bless_solved = 0\n        self.fail_cnt = 0\n        self.now_event = ''\n        if hasattr(self, 'keys'):\n            self.keys.fff = 0\n        for i in ['w','a','s','d','f']:\n            keyops.keyUp(i)\n\n    def save_or_exit(self):\n        print('saved_num:', self.saved_num, 'save_cnt:', config.save_cnt)\n        if self.saved_num < config.save_cnt:\n            self.saved_num += 1\n            self.click_position([1204, 959])\n            time.sleep(1)\n        else:\n            self.click_position([716, 959])\n        time.sleep(1.5)\n\n    def select_save(self):\n        self.click_position([186, 237 + int((self.saved_num-1) * (622 - 237) / 3)])\n        time.sleep(1)\n        self.ts.forward(self.get_screen())\n\n    def close_and_exit(self, click=True):\n        self.press('esc')\n        if self.debug and self.floor < 13:\n            with open('test.txt', 'a') as f:\n                format_string = \"%H:%M:%S\"\n                formatted_time = time.strftime(format_string, time.localtime())\n                f.write(formatted_time + '\\n')\n            while 1:\n                time.sleep(1)\n        time.sleep(2.5)\n        self.init_floor()\n        if not click:\n            if time.time() - self.fail_tm < 90:\n                click = True\n                self.fail_tm = 0\n            else:\n                self.fail_tm = time.time()\n        if click:\n            self.floor = 0\n            self.click_position([1530, 990])\n            time.sleep(1)\n\n    def get_text_type(self, text, types, prefix=1):\n        for i in types:\n            if i[:prefix] in text:\n                return i\n        return None\n    \n    def find_team_member(self):\n        boxes = [[1620, 1790, 289, 335],[1620, 1790, 384, 427],[1620, 1790, 478, 521],[1620, 1790, 570, 618]]\n        team_member = {}\n        for i,b in enumerate(boxes):\n            name = self.clean_text(self.ts.ocr_one_row(self.get_screen(), b))\n            if name in self.character_prior:\n                team_member[name] = i\n        return team_member\n\n    def get_now_area(self, deep=0):\n        team_member = self.find_team_member()\n        self.area_text = self.clean_text(self.ts.ocr_one_row(self.screen, [50, 350, 3, 35]), char=0)\n        print('area_text:', self.area_text, 'deep:', deep)\n        if '位面' in self.area_text or '区域' in self.area_text or '第' in self.area_text:\n            check_ok = 1\n            for i in team_member:\n                if i not in self.team_member or team_member[i] != self.team_member[i]:\n                    check_ok = 0\n                    break\n            if not check_ok:\n                self.team_member = team_member\n                print('team_member:', team_member)\n                for i in self.team_member:\n                    if i in config.long_range_list:\n                        self.long_range = str(self.team_member[i]+1)\n                        break\n            res = self.get_text_type(self.area_text, ['事件', '奖励', '遭遇', '商店', '首领', '战斗', '财富', '休整', '位面'])\n            if (res == '位面' or res is None) and deep == 0:\n                self.mouse_move(20)\n                scr = self.screen\n                time.sleep(0.3)\n                self.get_screen()\n                self.mouse_move(-20)\n                res = self.get_now_area(deep=1)\n                self.screen = scr\n            return res\n        else:\n            return None\n    \n    def find_portal(self, type=None):\n        prefer_portal = {'奖励':3, '事件':3, '战斗':2, '遭遇':2, '商店':1, '财富':1}\n        if self.speed:\n            prefer_portal = {'商店':3, '财富':3, '奖励':2, '事件':2, '战斗':1, '遭遇':1}\n            if self.quan and self.allow_e:\n                prefer_portal['战斗'] = 2\n        if config.enable_portal_prior:\n            prefer_portal.update(config.portal_prior)\n        prefer_portal.update({'首领':4, '休整':4})\n        tm = time.time()\n        text = self.ts.find_with_box([0,1920,0,540], forward=1, mode=2)\n        portal = {'score':0,'nums':0,'type':''}\n        for i in text:\n            if ('区' in i['raw_text'] or '域' in i['raw_text']) and (i['box'][0] > 400 or i['box'][2] > 60):\n                portal_type = self.get_text_type(i['raw_text'], prefer_portal)\n                if portal_type is not None:\n                    i.update({'score':prefer_portal[portal_type]+10*(portal_type==type), 'type':portal_type, 'nums':portal['nums']+1})\n                    if i['score'] > portal['score']:\n                        portal = i\n                elif '冒险' in i['raw_text']:\n                    portal['nums'] += 1\n        ocr_time = time.time() - tm\n        self.ocr_time_list = self.ocr_time_list[-5:] + [ocr_time]\n        print(f'识别时间:{int(ocr_time*1000)}ms', text, portal)\n        return portal\n    \n    def sleep(self, tm=2):\n        time.sleep(tm)\n        \n    def portal_bias(self, portal):\n        return (portal['box'][0] + portal['box'][1]) // 2 - 950\n    \n    def aim_portal(self, portal):\n        zero = bisect.bisect_left(config.angles, 0)\n        # win32api.mouse_event(win32con.MOUSEEVENTF_MOVE, 0, int(-200 * self.multi * self.scale))\n        while abs(self.portal_bias(portal)) > 50:\n            angle = bisect.bisect_left(config.angles, self.portal_bias(portal)) - zero\n            self.mouse_move(angle)\n            if abs(self.portal_bias(portal)) < 200:\n                return portal\n            time.sleep(0.2)\n            portal_after = self.find_portal(portal['type'])\n            if portal_after['score'] == 0:\n                self.press('w', 1)\n                portal_after = self.find_portal(portal['type'])\n                if portal_after['score'] == 0:\n                    return portal\n            portal = portal_after\n        return portal\n    \n    def forward_until(self, text_list=[], timeout=5, moving=0):\n        tm = time.time()\n        if not moving:\n            keyops.keyDown('w')\n        while time.time() - tm < timeout:\n            self.get_screen()\n            if self.check_f(check_text=0):\n                keyops.keyUp('w')\n                print(text_list)\n                if self.check_f(is_in=text_list):\n                    self.press('f')\n                    for _ in range(1):\n                        self.press('s',0.2)\n                        self.press('f')\n                    return 1\n                else:\n                    tm += 0.7\n                    keyops.keyDown('w')\n                    time.sleep(0.5)\n        keyops.keyUp('w')\n        return 0\n\n    def portal_opening_days(self, aimed=0, static=0, deep=0):\n        if deep > 1:\n            self.close_and_exit(click = self.fail_count > 1)\n            self.fail_count += 1\n            return\n        if deep == 0:\n            self.portal_cnt += 1\n        portal = {'score':0,'nums':0,'type':''}\n        moving = 0\n        if static:\n            # win32api.mouse_event(win32con.MOUSEEVENTF_MOVE, 0, int(100 * self.multi * self.scale))\n            angles = [0, 90, 90, 90, 45, -90, -90, -90, -45]\n            for i,angle in enumerate(angles):\n                self.mouse_move(angle)\n                time.sleep(0.2)\n                portal = self.find_portal()\n                if portal['score']:\n                    break\n            if self.floor in [1,2,4,5,6,7,9,10]:\n                if portal['nums'] == 1 and portal['score'] < 2:\n                    portal_pre = portal\n                    portal_type = portal['type']\n                    bias = 0\n                    for i in range(i+1, len(angles)):\n                        self.mouse_move(angles[i])\n                        bias += angles[i]\n                        time.sleep(0.2)\n                        portal_after = self.find_portal()\n                        if portal_after['score'] and portal_type != portal_after['type']:\n                            portal = portal_after\n                            break\n                    if portal['type'] == portal_type:\n                        portal = portal_pre\n                        self.mouse_move(-bias)\n        tm = time.time()\n        while time.time() - tm < 5 + 2 * (portal['score'] != 0):\n            if aimed == 0:\n                if portal['score'] == 0:\n                    portal = self.find_portal()\n            else:\n                if self.forward_until([portal['type']] if portal['score'] else ['区域','结束','退出'], timeout=3, moving=moving):\n                    self.init_floor()\n                    return\n                else:\n                    moving = 0\n            if portal['score'] and not aimed:\n                if moving:\n                    print('stop moving')\n                    keyops.keyUp('w')\n                    moving = 0\n                    self.press('s',min(max(self.ocr_time_list), 0.4))\n                    continue\n                else:\n                    print('aiming...')\n                    tmp_portal = self.aim_portal(portal)\n                    if tmp_portal['score'] == 0:\n                        self.portal_opening_days(aimed=0, static=1, deep=deep+1)\n                        return\n                    else:\n                        portal = tmp_portal\n                        aimed = 1\n                    moving = 1\n                    keyops.keyDown('w')\n            elif portal['score'] == 0:\n                if not moving:\n                    keyops.keyDown('w')\n                    moving = 1\n        if moving:\n            keyops.keyUp('w')\n\n    def event_score(self, text, event):\n        score = 0\n        event_weight = [2*self.speed, 1, -10]\n        for i in range(3):\n            for e in event[i].split('-'):\n                if e in text and len(e):\n                    score += event_weight[i]\n        return score\n\n    def event(self):\n        event_id = (-1, '')\n        self.event_solved = 1\n        tm = time.time()\n        while time.time() - tm < 20:\n            title_text = self.clean_text(self.ts.ocr_one_row(self.screen, [185, 820, 945, 1005]), char=0)\n            print(title_text)\n            if event_id[0] == -1:\n                for i, e in enumerate(self.event_prior):\n                    if e in title_text and len(e) > len(event_id[1]):\n                        event_id = (i, e)\n                start = self.now_event == event_id[1]\n                self.now_event = event_id[1]\n                print('event_id:', event_id)\n            if '事件' not in self.merge_text(self.ts.find_with_box([92, 195, 54, 88])):\n                return\n            \n            self.get_screen()\n            if self.check(\"arrow\", 0.1828, 0.5000, mask=\"mask_event\"):\n                self.click((self.tx, self.ty))\n            # 事件界面：退出\n            elif self.check(\"arrow_1\", 0.1828, 0.5000, mask=\"mask_event\"):\n                self.click((self.tx, self.ty))\n            # 事件选择界面\n            elif self.check(\"star\", 0.1828, 0.5000, mask=\"mask_event\", threshold=0.965):\n                if self.debug and event_id[0] == -1:\n                    print(self.ts.res)\n                    while 1:\n                        time.sleep(1)\n                tx, ty = self.tx, self.ty\n                self.ts.forward(self.screen)\n                clicked = 0\n                if event_id[0] != -1:\n                    text = self.ts.find_with_box([1300, 1920, 100, 1080], redundancy=30)\n                    events = []\n                    event_now = None\n                    last_star = 0\n                    for i in text:\n                        if self.check_box(\"star\", [1250, 1460, i['box'][2]-30, i['box'][3]+30]) and last_star<self.ty-20:\n                            last_star = self.ty\n                            if event_now is not None:\n                                events.append(event_now)\n                            event_now = {'raw_text': i['raw_text'].lstrip('米'), 'box': i['box']}\n                        else:\n                            if event_now is not None:\n                                event_now['raw_text'] += i['raw_text']\n                            else:\n                                event_now = {'raw_text': i['raw_text'], 'box': i['box']}\n                    events.append(event_now)\n                    for e in events:\n                        e['raw_text'] = self.clean_text(e['raw_text'], 0)\n                        e['score'] = self.event_score(e['raw_text'], self.event_prior[event_id[1]])\n                    events = sorted(events, key=lambda x: x['score'], reverse=True)\n                    print([{k: v for k, v in event.items() if k != 'box'} for event in events])\n                    for i in events:\n                        self.click_box(i['box'])\n                        time.sleep(0.4)\n                        self.get_screen()\n                        if self.check(\"confirm\", 0.1828, 0.5000, mask=\"mask_event\", threshold=0.965):\n                            self.click((self.tx, self.ty))\n                            clicked = 1\n                            break\n                if not clicked:\n                    self.click((tx, ty))\n                    time.sleep(0.3)\n                    self.click((0.1167, ty - 0.4685 + 0.3546))\n                time.sleep(0.8)\n                start = 0\n            else:\n                if not start:\n                    time.sleep(0.6)\n                    self.ts.forward(self.get_screen())\n                    if '事件' not in self.merge_text(self.ts.find_with_box([92, 195, 54, 88])):\n                        return\n                self.click((0.9479, 0.9565))\n                self.click((0.9479, 0.9565))\n                if start:\n                    self.click((0.9479, 0.9565))\n                    self.click((0.9479, 0.9565))\n                self.ts.forward(self.get_screen())\n\n    def find_event_text(self, save=0):\n        time.sleep(0.3)\n        text = self.ts.find_with_box([300, 1920, 0, 350], forward=1, mode=2)\n        res = 0\n        event_text = ''\n        debug_res = []\n        print('event_text:', text)\n        for i in text:\n            box = i['box']\n            if 'ms' in i['raw_text'] or '状态效' in i['raw_text'] or len(i['raw_text']) < 2 or (box[0] > 1470 and box[2] < 75)\\\n                  or (box[0] > 1800 and box[2] < 120) or (box[0] > 1600 and box[2] > 290) or (box[1] < 400 and box[3] < 160):\n                continue\n            if '?' not in i['raw_text'] and '？' not in i['raw_text'] and len(self.clean_text(i['raw_text'], 1)) == 0:\n                continue\n            w, h = box[1] - box[0], box[3] - box[2]\n            if w < 40 or h > 40:\n                continue\n            if (box[0] + box[1]) // 2 > res or self.event_text in i['raw_text'] or i['raw_text'] in self.event_text:\n                res = (box[0] + box[1]) // 2\n                event_text = i['raw_text']\n            debug_res.append(i)\n        print(debug_res, res, event_text)\n        if save:\n            self.event_text = event_text\n        return res\n    \n    def align_event(self, key, deep=0):\n        find = 0\n        if deep == 0 and key == 'd':\n            win32api.mouse_event(win32con.MOUSEEVENTF_MOVE, 0, int(-200 * self.multi * self.scale))\n            event_text = self.find_event_text(1)\n            if not event_text:\n                self.press('s', 1)\n            else:\n                find = 1\n        if not find:\n            event_text = self.find_event_text(1)\n        self.get_screen()\n        if self.check_f(is_in=['事件','奖励','遭遇','交易']):\n            self.press('f')\n            return\n        # elif self.check_f(is_in=['混沌','药箱']):\n        #     self.press('f')\n        #     time.sleep(2.5)\n        #     self.run_static(action_list=['混沌药箱'], skip_check=1)\n        #     tm = time.time()\n        #     while time.time() - tm < 3:\n        #         self.ts.forward(self.get_screen())\n        #         res = self.run_static(action_list=['点击空白处关闭'])\n        #         if len(res):\n        #             tm = time.time()\n        #     time.sleep(2)\n        #     if deep == 0:\n        #         self.align_event(key, deep+1)\n        #     return\n\n        if not event_text and key == 'a':\n            event_text = 950\n\n        if event_text:\n            if abs(event_text - 950) > 40:\n                self.press(key,0.2)\n                event_text_after = self.find_event_text()\n                if event_text_after:\n                    sub = event_text - event_text_after\n                    if key == 'a':\n                        sub = -sub\n                    print('sub:', sub)\n                    if sub < 60:\n                        sub = 100\n                    if sub < 200:\n                        sub = int((event_text_after - 950) / min(150, sub))\n                        sub = min(5, max(-5, int(sub)))\n                        for _ in range(sub):\n                            self.press('d',0.2)\n                            time.sleep(0.1)\n                        for _ in range(-sub):\n                            self.press('a',0.2)\n                            time.sleep(0.1)\n                else:\n                    self.press('a' if key == 'd' else 'd', 0.2)\n            self.forward_until(['事件','奖励','遭遇','交易'], timeout=2.5, moving=0)\n        else:\n            if deep < 3:\n                self.press('w',[0,0.3,0.5][deep])\n                self.align_event(key, deep+1)\n            return\n            \n    def skill(self, quan=0):\n        if not self.allow_e:\n            return\n        self.press('e')\n        time.sleep(0.5)\n        self.get_screen()\n        if self.check('e',0.4995,0.7500):\n            self.solve_snack()\n            if quan and self.allow_e:\n                time.sleep(0.5)\n            else:\n                time.sleep(1.5*self.allow_e)\n\n    def check_dead(self):\n        self.get_screen()\n        if self.check(\"divergent/sile\", 0.5010,0.7519, threshold=0.96):\n            self.click_position([1188, 813])\n            time.sleep(2.5)\n\n    def area(self):\n        area_now = self.get_now_area()\n        time.sleep(0.5)\n        if self.get_now_area() != area_now or area_now is None:\n            return\n        if self.area_state == -1:\n            self.close_and_exit(click = False)\n            return\n        now_floor = self.floor\n        for i in range(1,14):\n            if f'{i}13' in self.area_text:\n                now_floor = i\n        if now_floor != self.floor:\n            if now_floor < self.floor:\n                self.init_floor()\n            self.floor = now_floor\n            if self.floor in [5,10]:\n                time.sleep(3)\n        time.sleep(0.8)\n        if self.area_state == 0:\n            if '黄泉' in self.team_member and '黄泉' in config.skill_char:\n                self.quan = 1\n            if area_now == '战斗' and self.quan and self.allow_e:\n                self.press(str(self.team_member['黄泉']+1))\n            else:\n                self.press(self.long_range)\n        self.get_screen()\n        if self.check(\"divergent/arrow\", 0.7833,0.9231, threshold=0.96):\n            keyops.keyDown('alt')\n            time.sleep(0.2)\n            self.click_position([413, 79])\n            keyops.keyUp('alt')\n        time.sleep(0.7)\n        self.check_dead()\n        if area_now is not None:\n            self.area_now = area_now\n        else:\n            area_now = self.area_now\n        if self.portal_cnt > 1:\n            self.close_and_exit(click = False)\n            return\n        print('floor:',self.floor,'state:',self.area_state,'area:',area_now,'text:',self.area_text)\n        if area_now in ['事件', '奖励', '遭遇']:\n            if self.area_state==0:\n                keyops.keyDown('w')\n                time.sleep(2.2)\n                keyops.keyDown('d')\n                time.sleep(0.4)\n                keyops.keyUp('w')\n                time.sleep(0.2)\n                keyops.keyUp('d')\n                time.sleep(0.2)\n                self.align_event('a')\n                self.area_state += 1\n            elif self.area_state==1:\n                self.keys.fff = 1\n                self.press('a', 1.3)\n                time.sleep(0.4)\n                self.keys.fff = 0\n                self.get_screen()\n                if self.get_now_area() is not None:\n                    self.press('w', 0.3)\n                    time.sleep(0.6)\n                    self.get_screen()\n                    if self.check_f(check_text=0):\n                        self.press('f')\n                    else:\n                        self.press('s', 0.5)\n                        self.align_event('d')\n                self.area_state += 1\n            else:\n                self.portal_opening_days(static=1)\n        elif area_now == '休整':\n            pyautogui.click()\n            time.sleep(0.8)\n            keyops.keyDown('w')\n            self.press('a', 0.3)\n            time.sleep(3)\n            self.press('d', 0.2)\n            keyops.keyUp('w')\n            time.sleep(0.25)\n            self.portal_opening_days(aimed=1)\n        elif area_now == '商店':\n            pyautogui.click()\n            time.sleep(0.8)\n            keyops.keyDown('w')\n            time.sleep(1.6)\n            self.press('d',0.4)\n            keyops.keyUp('w')\n            time.sleep(0.6)\n            self.portal_opening_days(static=1)\n        elif area_now == '首领':\n            if self.floor == 13 and self.area_state > 0:\n                self.close_and_exit()\n                self.end_of_uni()\n                return\n            if self.area_state == 0:\n                self.press('w',3)\n                for c in config.skill_char:\n                    if (c in self.team_member or c.isdigit()) and self.allow_e:\n                        self.press(int(c) if c.isdigit() else str(self.team_member[c]+1))\n                        time.sleep(0.8)\n                        self.check_dead()\n                        self.skill()\n                        time.sleep(1.5)\n                pyautogui.click()\n                time.sleep(0.2)\n                pyautogui.click()\n                self.area_state += 1\n            elif self.area_state == 1:\n                if self.bless_solved:\n                    if not self.speed:\n                        keyops.keyDown('w')\n                        tm = time.time()\n                        while time.time() - tm < 1.8:\n                            self.get_screen()\n                            if self.check_f(check_text=0):\n                                break\n                        keyops.keyUp('w')\n                        self.press('f')\n                        self.area_state += 1\n                    else:\n                        self.press('w', 1)\n                        self.press('f')\n                        self.area_state = 5\n                else:\n                    self.press('w', 0.5)\n                    self.area_state = 4\n            elif self.area_state == 2:\n                self.press('d', 0.55)\n                self.press('f')\n                self.area_state += 1\n            elif self.area_state == 3:\n                self.press('a', 0.95)\n                self.press('f')\n                self.area_state += 1\n            elif self.area_state == 4:\n                if self.bless_solved:\n                    keyops.keyDown('d')\n                    self.press('s', 0.2)\n                    time.sleep(0.2)\n                    keyops.keyUp('d')\n                    self.portal_opening_days(static=1)\n                else:\n                    self.portal_opening_days(static=1)\n            else:\n                time.sleep(1)\n                self.portal_opening_days(static=1)\n        elif area_now == '战斗':\n            if self.area_state == 0:\n                self.press('w', 3)\n                if self.quan and self.allow_e and self.floor > 1:\n                    for _ in range(4):\n                        self.skill(1)\n                    self.press('w')\n                    time.sleep(1.5)\n                else:\n                    pyautogui.click()\n                self.area_state += 1\n            else:\n                self.press('w', 0.5)\n                self.portal_opening_days(static=1)\n        elif area_now == '财富':\n            self.press('w',2.7)\n            pyautogui.click()\n            time.sleep(0.6)\n            keyops.keyDown('w')\n            time.sleep(0.2)\n            self.keys.fff = 1\n            self.press('a', 0.5)\n            time.sleep(0.35)\n            keyops.keyUp('w')\n            time.sleep(0.6)\n            if self.find_portal()['score'] == 0:\n                self.press('a', 0.4)\n                self.press('s', 0.7)\n                self.press('w', 0.5)\n            self.keys.fff = 0\n            self.portal_opening_days(static=1)\n        elif area_now == '位面':\n            pyautogui.click()\n            time.sleep(2)\n            self.close_and_exit()\n        else:\n            self.press('F4')\n    \n    def update_bless_prior(self):\n        self.bless_prior = defaultdict(int)\n        for i in list(self.team_member) + ['全局', config.team]:\n            if i in self.character_prior:\n                prior = self.character_prior[i]\n                for j in prior:\n                    self.bless_prior[j] += prior[j]\n    \n    def bless_score(self, text):\n        score = 0\n        for i in self.bless_prior:\n            if i in text:\n                score += self.bless_prior[i]\n        for i in self.all_bless:\n            if i[-4:] in text:\n                score += int(self.all_bless[i][0]) - 1\n        return score\n\n    def drop_bless(self):\n        self.bless(0)\n\n    def bless(self, reverse=1):\n        self.bless_solved = 1\n        text = self.ts.find_with_box([350, 1550, 795, 819])\n        if len(text) == 0:\n            text = self.ts.find_with_box([350, 1550, 480, 530])\n        if len(text) == 0:\n            return\n        self.update_bless_prior()\n        blesses = []\n        for i in text:\n            box = i[\"box\"]\n            x, y = (box[0] + box[1]) // 2, (box[2] + box[3]) // 2\n            box = [x - 220, x + 220, 450, 850]\n            bless_text = self.ts.find_with_box(box)\n            bless_raw_text = self.merge_text(bless_text, char=0)\n            blesses.append({'raw_text': bless_raw_text, 'box': box, 'score': self.bless_score(bless_raw_text)})\n        blesses = sorted(blesses, key=lambda x: x['score'], reverse=reverse)\n        print(blesses)\n        box = blesses[0]['box']\n        for _ in range(1):\n            self.click_position([(box[0] + box[1]) // 2, 500])\n        self.click_position([1695, 962])\n        time.sleep(1)\n\n    def end_of_uni(self):\n        self.update_count(0)\n        self.my_cnt += 1\n        tm = int((time.time() - self.init_tm) / 60)\n        remain_round = self.nums-self.my_cnt\n        if remain_round > 0:\n            remain = int(remain_round * (time.time() - self.init_tm) / self.my_cnt / 60)\n        else:\n            remain = 0\n            remain_round = -1\n        notif(\n            \"已完成\",\n            f\"计数:{self.count} 剩余:{remain_round} 已使用：{tm//60}小时{tm%60}分钟  平均{tm//self.my_cnt}分钟一次  预计剩余{remain//60}小时{remain%60}分钟\",\n            cnt=str(self.count),\n        )\n        if self.nums <= self.my_cnt and self.nums >= 0:\n            log.info('已完成上限，准备停止运行')\n            self.end = 1\n        self.floor = 0\n        self.init_floor()\n\n    def update_count(self, read=True):\n        file_name = \"logs/notif.txt\"\n        if read:\n            new_cnt = 0\n            if os.path.exists(file_name):\n                time_cnt = os.path.getmtime(file_name)\n                with open(file_name, \"r\", encoding=\"utf-8\", errors=\"ignore\") as fh:\n                    s = fh.readlines()\n                    try:\n                        new_cnt = int(s[0].strip(\"\\n\"))\n                        time_cnt = float(s[3].strip(\"\\n\"))\n                    except:\n                        pass\n            else:\n                os.makedirs(\"logs\", exist_ok=1)\n                with open(file_name, \"w\", encoding=\"utf-8\") as file:\n                    file.write(\"0\")\n                    file.close()\n                time_cnt = os.path.getmtime(file_name)\n        else:\n            new_cnt = self.count + 1\n            time_cnt = self.count_tm\n        dt = datetime.datetime.now().astimezone()\n        \"\"\"\n        America: GMT-5\n        Asia: GMT+8\n        Europe: GMT+1\n        TW, HK, MO: GMT+8\n        \"\"\"\n        tz_info = None\n        try:\n            tz_dict = {\n                \"Default\": None,\n                \"America\": pytz.timezone(\"US/Central\"),\n                \"Asia\": pytz.timezone(\"Asia/Shanghai\"),\n                \"Europe\": pytz.timezone(\"Europe/London\"),\n            }\n            tz_info = tz_dict[config.timezone]\n        except:\n            pass\n\n        # convert to server time\n        dt = dt.astimezone(tz_info)\n        current_weekday = dt.weekday()\n        monday = dt + datetime.timedelta(days=-current_weekday)\n        target_datetime = datetime.datetime(\n            monday.year, monday.month, monday.day, 4, 0, 0, tzinfo=tz_info\n        )\n        monday_ts = target_datetime.timestamp()\n        if dt.timestamp() >= monday_ts and time_cnt < monday_ts:\n            self.count = int(not read)\n        else:\n            self.count = new_cnt\n        self.count_tm = time.time()\n\n    def stop(self, *_, **__):\n        log.info(\"尝试停止运行\")\n        try:\n            self.init_floor()\n        except:\n            pass\n        self._stop = True\n    \n    def on_key_press(self, event):\n        if event.name == \"f8\":\n            print(\"F8 已被按下，尝试停止运行\")\n            self.stop()\n\n    def start(self):\n        self._stop = False\n        keyboard.on_press(self.on_key_press)\n        self.keys = KeyController(self)\n        try:\n            self.route()\n        except KeyboardInterrupt:\n            print(\"KeyboardInterrupt\")\n            try:\n                log.info('用户终止进程')\n            except:\n                pass\n            if not self._stop:\n                self.stop()\n        except Exception as e:\n            print_exc()\n            traceback.print_exc()\n            log.info(str(e))\n            log.info(\"发生错误，尝试停止运行\")\n            self.stop()\n\ndef main():\n    log.info(f\"debug: {args.debug}\")\n    su = DivergentUniverse(args.debug, args.nums, args.speed)\n    try:\n        su.start()\n    # except ValueError as e:\n    #     pass\n    except Exception:\n        print_exc()\n    finally:\n        su.stop()\n\n\nif __name__ == \"__main__\":\n    if not pyuac.isUserAdmin():\n        pyuac.runAsAdmin()\n    else:\n        main()\n"
        },
        {
          "name": "gui.py",
          "type": "blob",
          "size": 2.9873046875,
          "content": "import atexit\nimport flet as ft\nimport pyuac\nimport threading\nimport os\nimport sys\nimport psutil\nimport shutil\n\nfrom utils.gui.choose import choose_view\nfrom utils.gui.config_simul import config_view as config_view_simul\nfrom utils.gui.config_diver import config_view as config_view_diver\nfrom utils.gui.abyss import abyss_view\nfrom utils.gui.common import Page, init_page\n\n\ndef main(page: Page):\n    def on_route_change(e: Page):\n        page.views.clear()\n        choose_view(page)\n        if e.route == \"/config_simul\":\n            config_view_simul(page)\n        if e.route == \"/config_diver\":\n            config_view_diver(page)\n        if e.route == '/abyss':\n            abyss_view(page)\n        page.update()\n\n    def view_pop():\n        page.views.pop()\n        top_view = page.views[-1]\n        page.go(top_view.route)\n\n\n    init_page(page)\n    page.theme = ft.Theme(\n        color_scheme_seed=ft.colors.PINK,\n    )\n    page.title = \"AutoSimulatedUniverse\"\n    page.vertical_alignment = \"center\"\n    page.horizontal_alignment = \"center\"\n    page.on_route_change = on_route_change\n    page.on_view_pop = view_pop\n    page.window_min_width = 800\n    page.window_width = 800\n    page.window_height = 670\n    page.window_min_height = 650\n    page.go(page.route)\n\ndef cleanup():\n    current_process = psutil.Process(os.getpid())\n    name = current_process.name()\n    if name.endswith('.exe') and name != 'python.exe':\n        try:\n            father = current_process.parent()\n            try:\n                father.terminate()\n            except:\n                pass\n            try:\n                father.kill()\n            except:\n                pass\n            psutil.wait_procs([father], timeout=5)\n        except:\n            pass\n    os._exit(0)\n\ndef clean_temp_files():\n    try:\n        path = sys._MEIPASS\n    except:\n        return\n    now_dir = path\n    parent_dir = os.path.dirname(now_dir)\n    for file in os.listdir(parent_dir):\n        file_path = os.path.join(parent_dir, file)\n        if os.path.basename(now_dir) != file and os.path.isdir(file_path) and file.startswith('_MEI'):\n            files_list = os.listdir(file_path)\n            if 'utils' not in files_list or 'flet' not in files_list or 'win32' not in files_list:\n                continue\n            utils_path = os.path.join(file_path, 'utils')\n            utils_list = os.listdir(utils_path)\n            if 'models' not in utils_list:\n                continue\n            models_path = os.path.join(utils_path, 'models')\n            models_list = os.listdir(models_path)\n            if 'ppocr_keys_v1.txt' not in models_list or 'v3_det.onnx' not in models_list or 'v4_rec.onnx' not in models_list:\n                continue\n            try:\n                shutil.rmtree(file_path, ignore_errors=True)\n            except:\n                pass\n\nif __name__ == \"__main__\":\n    atexit.register(cleanup)\n    if not pyuac.isUserAdmin():\n        pyuac.runAsAdmin()\n    else:\n        threading.Thread(target=clean_temp_files).start()\n        ft.app(target=main)\n    cleanup()"
        },
        {
          "name": "imgs",
          "type": "tree",
          "content": null
        },
        {
          "name": "info_example.yml",
          "type": "blob",
          "size": 1.900390625,
          "content": "# info_example.yml是info.yml的样例文件\n# 该文件仅供参考，不会被自动化程序识别\n# 自动化程序只会识别info.yml\n# 所以修改info_example.yml没有意义！\nconfig:\n  # 校准值\n  angle: 1.0\n  # 难度，1-5，（5代表最高难度，如果世界没有难度5则会选择难度4）\n  difficulty: 5\n  # 队伍类型 目前只支持：追击/dot/终结技/击破/盾反\n  team: 终结技\n  # 速通模式\n  speed_mode: 0\n  # 周期演算\n  weekly_mode: 0\n  # 图像识别强制使用cpu\n  cpu_mode: 0\n  # 首领房间需要开秘技的角色，按顺序开\n  # 目前支持（不要打错字！必须一模一样）：\n  # 流萤,黄泉,波提欧,真理医生,丹恒饮月,瓦尔特杨,克拉拉,银枝,刃,希儿,景元,镜流,卡芙卡,托帕账账,黑天鹅,翡翠,云璃,砂金,椒丘,彦卿,姬子\n  # 杰帕德,藿藿,白露,阿兰,素裳,加拉赫,知更鸟,阮梅,布洛妮娅,花火,符玄,银狼,罗刹,寒鸦,卢卡,桂乃芬,虎克,艾丝妲,米沙,佩拉,黑塔\n  # 三月七,停云,桑博,雪衣,青雀,玲可,驭空,娜塔莎,希露瓦\n  skill:\n    - 符玄\n    - 阮梅\n    - 黄泉\n  # 自动存档数量，0-4，0代表不存档，1-4代表自动存档到前1-4个存档位\n  save: 0\n  timezone: Default\n  max_run: 34\n  # 图像识别精度，默认1440，越高越精确，但是也越慢（最高1920）\n  # 只推荐低性能运行环境调小数值，建议不能低于960\n  accuracy: 1440\n  # 传送门优先级，1-3，3代表优先级最高，1代表优先级最低\n  # 如需自定义请将enable_portal_prior设为1\n  # 只能修改数字，不要修改名称\n  enable_portal_prior: 0\n  portal_prior:\n    商店: 1\n    财富: 1\n    战斗: 2\n    遭遇: 2\n    奖励: 3\n    事件: 3\n\nkey_mapping:\n# 交互键，只能是单个字母\n  - f\n# 地图\n  - m\n# 奔跑\n  - shift\n# 自动战斗\n  - v\n# 秘技\n  - e\n# 移动\n  - w\n  - a\n  - s\n  - d\n# 切换角色\n  - '1'\n  - '2'\n  - '3'\n  - '4'"
        },
        {
          "name": "info_example_old.yml",
          "type": "blob",
          "size": 4.390625,
          "content": "#info_example.yml是info.yml的样例文件\n#该文件仅供参考，不会被自动化程序识别\n#自动化程序只会识别info.yml\n#所以修改info_example.yml没有意义！\nconfig:\n  #配队编号，基本已经弃用，无视即可\n  order_text:\n  - 1\n  - 2\n  - 3\n  - 4\n  #校准值\n  angle: 1.0\n  #难度，1-5，（5代表最高难度，如果世界没有难度5则会选择难度4）\n  difficulty: 5\n  #主命途\n  fate: 巡猎\n  #副命途\n  secondary_fate:\n  - 毁灭\n  - 巡猎\n  - 丰饶\n  #这些无视即可\n  map_sha: ''\n  show_map_mode: 0\n  debug_mode: 0\n  speed_mode: 0\n  slow_mode: 0\n  #是否自动领取沉浸奖励\n  bonus: 0\n  #是否使用长按进入疾跑状态，0代表不启用，1代表启用\n  long_press_sprint: 0\n  #0代表不使用消耗品，1代表最终boss使用消耗品，2代表最后两个boss使用消耗品，3代表所有boss都使用消耗品\n  #自动使用第一个已星标的攻击/防御消耗品，必须收藏消耗品（星星标记）\n  #如果不希望使用防御消耗品，可以取消所有防御消耗品的星标\n  use_consumable: 0\n  force_update: 0\n  timezone: Default\n  max_run: 34\n#奇物，事件和祝福的优先级。祝福优先级只对主命途生效\n#不要擅自更改每一部分之间的顺序\n#比如说调换命途顺序，删除某个命途都是不行的\nprior:\n  奇物:\n  - 福灵胶\n  - 博士之袍\n  - 陨石球\n  - 降维骰子\n  - 信仰债券\n  - 时空棱镜\n  - 朋克洛德\n  - 香涎干酪\n  - 龋齿星系\n  事件:\n  - 购买一个\n  - 丢下雕像\n  - 和序列扑满玩\n  - 信仰星神\n  - 克里珀的恩赐\n  - 哈克的藏品\n  - 动作片\n  - 感恩克里珀星神\n  - 换取1个星祝福\n  - 星神的记载\n  - 翻开牌\n  - 摧毁黑匣\n  - 1个1-星祝福\n  - 1个1星祝福\n  - 选择里奥\n  存护:\n  - 零维强化\n  - 均晶转变\n  - 共晶反应\n  - 宏观偏析\n  - 超静定场\n  - 谐振传递\n  - 四棱锥体\n  - 聚塑\n  - 哨戒\n  - 亚共晶体\n  - 切变结构\n  - 弥合\n  - 迸裂晶格\n  记忆:\n  - 体验的富翁\n  - 全面记忆\n  - 第二次初恋\n  - 浮黎\n  - 缄默\n  - 纯真\n  - 难言的羞耻\n  - 怅然若失\n  - 麻木不仁\n  - 不寒而栗\n  - 特立独行\n  - 头晕目眩\n  - 多愁善感\n  - 沦浃肌髓\n  虚无:\n  - 局外人\n  - 苦难与阳光\n  - 怀疑的四重根\n  - 为何一切尚未消失\n  - 感官追奉者的葬礼\n  - 被装在套子里的人\n  - 旷野的呼告\n  - 存在的黄昏\n  - 火堆外的夜\n  - 知觉迷墙\n  - 虚妄贡品\n  - 日出之前\n  - 无根据颂歌\n  - 自欺咖啡馆\n  - 他人即地狱\n  - 开端与终结\n  丰饶:\n  - 诸行无常\n  - 诸法无我\n  - 一法界心\n  - 施诸愿印\n  - 延彼遐龄\n  - 厌离邪秽苦\n  - 天人不动众\n  - 宝光烛日月\n  - 明澈琉璃身\n  - 法雨\n  - 胜军\n  - 灭罪累生善\n  巡猎:\n  - 柘弓危矢\n  - 射不主皮\n  - 帝星君临\n  - 白矢决射御\n  - 云镝逐步离\n  - 彤弓素矰\n  - 背孤击虚\n  毁灭:\n  - 激变变星\n  - 极端氦闪\n  - 事件视界\n  - 寰宇热寂特征数\n  - 反物质非逆方程\n  - 戒律性闪变\n  - 危害性余光\n  - 毁灭性吸积\n  - 原生黑洞\n  - 轨道红移\n  - 预兆性景深\n  - 递增性末日\n  - 灾难性共振\n  - 破坏性耀发\n  - 偏振受体\n  - 永坍缩体\n  - 不稳定带\n  - 哨戒卫星\n  - 回光效应\n  欢愉:\n  - 末日狂欢\n  - 开盖有奖\n  - 茫茫白夜\n  - 众生安眠\n  - 阴风阵阵\n  - 被涂污的信天翁\n  - 十二猴子与怒汉\n  - 操行满分\n  - 基本有害\n  - 灰暗的火\n  - 第二十一条军规\n  - 流吧你的眼泪\n  繁育:\n  - 刺吸口器\n  - 结晶鳌刺\n  - 酚类物质\n  - 子囊释放\n  - 菌种脓疤\n  - 镰刀肢足\n  - 腐殖疮\n  - 裂解酶\n  - 代谢腔\n  - 裸脑质\n  - 代谢腔\n  - 催化剂\n  - 节间膜\n  - 孢夹\n  - 骨刃\n  - 鳞翅\n  - 脊刺\n  - 槽针\n  - 液囊\n  智识:\n  - 34型灰质\n  - 2型杏仁核\n  - 18型枕叶\n  - 前庭系统\n  - 递质合成\n  - 外显记忆\n  - 触觉通路\n  - 阈下知觉\n  - 纹状皮层\n  - 跳跃传导\n  - 齿轮啮合的王座\n  - 导线弯绕的指环\n  - 能量变距的权杖\n  - 偏时引燃的炬火\n  - 延迟衍射的烛光\n  - 金属斑驳的华盖\n  - 管道交错的桂冠\n  - 线圈编制的罗琦\n#键盘映射，每行只能修改，绝对不能删除/增加行\nkey_mapping:\n#交互键，只能是单个字母\n  - f\n#地图\n  - m\n#奔跑\n  - shift\n#自动战斗\n  - v\n#秘技\n  - e\n#移动\n  - w\n  - a\n  - s\n  - d\n#切换角色\n  - '1'\n  - '2'\n  - '3'\n  - '4'"
        },
        {
          "name": "install_requirements.bat",
          "type": "blob",
          "size": 0.205078125,
          "content": "%1 mshta vbscript:CreateObject(\"Shell.Application\").ShellExecute(\"cmd.exe\",\"/c %~s0 ::\",\"\",\"runas\",1)(window.close)&&exit\ncd/d \"%~dp0\"\npip install -r requirements.txt -i https://pypi.doubanio.com/simple/\npause\n"
        },
        {
          "name": "notif.py",
          "type": "blob",
          "size": 2.5615234375,
          "content": "import os\nimport ctypes\nimport time\nfrom PIL import Image\nfrom pystray import Icon, MenuItem as item\nimport threading\nimport sys\nimport os\nfrom winotify import Notification\nimport psutil\n\ndef notif(title,msg):\n    Notification(app_id=\"椰羊自动化\",title=title,msg=msg,icon=os.getcwd() + \"\\\\imgs\\\\icon.png\").show()\n\ndef exit_program(icon, item):\n    icon.stop()\n    os._exit(0)\n\ndef maopao(icon=None, item=None):\n    file_name = 'logs/notif.txt'\n    cnt='0'\n    tm=None\n    if os.path.exists(file_name):\n        with open(file_name, 'r', encoding=\"utf-8\",errors='ignore') as file:\n            s=file.readlines()\n            cnt=s[0].strip('\\n')\n            try:\n                tm=s[3].strip('\\n')\n            except:\n                pass\n    if tm is None:\n        tm = str(time.time())\n    os.makedirs('logs',exist_ok=1)\n    with open(file_name, 'w', encoding=\"utf-8\") as file:\n        file.write(f\"{cnt}\\n喵\\n计数:{cnt}\\n{tm}\")\n\n\ndef clear(icon=None, item=None):\n    file_name = 'logs/notif.txt'\n    tm = time.time()\n    if os.path.exists(file_name):\n        with open(file_name, 'w', encoding=\"utf-8\",errors='ignore') as file:\n            file.write('0\\n清零\\n计数:0\\n{tm}')\n            \ndef notify():\n    file_name = 'logs/notif.txt'\n    if not os.path.exists(file_name):\n        with open(file_name, 'w', encoding=\"utf-8\") as file:\n            file.write(\"0\")\n    last = os.path.getmtime(file_name)\n    while 1:\n        time.sleep(0.5)\n        if last != os.path.getmtime(file_name):\n            with open(file_name,'r', encoding=\"utf-8\",errors='ignore') as fh:\n                s=fh.readlines()\n            if len(s)>=3:\n                notif(s[1].strip('\\n'),s[2].strip('\\n'))\n            last = os.path.getmtime(file_name)\n\ndef main():\n    # 检测程序是否已经在运行\n    mutex = ctypes.windll.kernel32.CreateMutexW(None, False, \"YEYANG_MyProgramMutex\")\n    if ctypes.windll.kernel32.GetLastError() == 183:\n        ctypes.windll.user32.MessageBoxW(0, \"程序已在运行！\", \"提示\", 0x40)\n        return\n\n    # 创建系统托盘图标\n    image = Image.open(\"imgs/icon.png\")\n    icon = Icon(\"椰羊自动化\", image, \"椰羊自动化\")\n    menu = (\n        item('冒泡', maopao),\n        item('清零', clear),\n        item('退出', exit_program),\n    )\n    icon.menu = menu\n    maopao()\n\n    '''\n    try:\n        mynd = list_handles(f=lambda n:\"notif\" in n[-9:])[0]\n        win32gui.ShowWindow(mynd, 0)\n    except:\n        pass\n    '''\n\n    t_notify = threading.Thread(target=notify)\n    t_notify.start()\n    # 显示系统托盘图标\n    icon.run()\n\n\nif __name__ == '__main__':\n    main()"
        },
        {
          "name": "requirements.txt",
          "type": "blob",
          "size": 0.2001953125,
          "content": "opencv_python\nPyAutoGUI\npywin32\nflet\npyinstaller\npyuac\npillow\nkeyboard\nrequests\nonnxruntime-directml\nshapely\npyclipper\npyscreeze==0.1.28\ntzdata\ntzlocal\npytz\npyyaml\nwinotify\npystray\npsutil\nmss\nnumpy==1.26.4"
        },
        {
          "name": "simul.py",
          "type": "blob",
          "size": 39.822265625,
          "content": "import threading\nimport traceback\nimport keyboard\nimport pyautogui\nimport cv2 as cv\nimport numpy as np\nimport time\nimport win32gui, win32api, win32con\nimport random\nimport sys\nfrom copy import deepcopy\nfrom utils.log import log, set_debug\nfrom utils.simul.map_log import map_log\nfrom utils.simul.update_map import update_map\nfrom utils.simul.utils import UniverseUtils, set_forground, notif\nimport os\nfrom align_angle import main as align_angle\nfrom utils.simul.config import config\nimport datetime\nimport requests\nimport pytz\nimport pyuac\nimport utils.simul.keyops as keyops\n\n# 版本号\nversion = \"v6.3\"\n\n\nclass SimulatedUniverse(UniverseUtils):\n    def __init__(\n        self, find, debug, show_map, speed, consumable, slow, nums=-1, unlock=False, bonus=False, update=0, gui=0\n    ):\n        super().__init__()\n        # t1 = threading.Thread(target=os.system,kwargs={'command':'notif.exe > NUL 2>&1'})\n        # t2 = threading.Thread(target=os.system,kwargs={'command':'python notif.py > NUL 2>&1'})\n        log.info(\"当前命途：\" + self.fate)\n        self.validation = 1\n        if \"debug\" in version and not gui:\n            log.info(\"欢迎加入模拟宇宙小群，群号：921407322 密码：xyzzyx\")\n        self.now_map = None\n        self.now_map_sim = None\n        self.real_loc = [0, 0]\n        self.debug_map = np.zeros((8192, 8192), dtype=np.uint8)\n        self._stop = True\n        self.img_set = []\n        self.find = find\n        self.debug = debug\n        self.speed = speed\n        self.consumable = consumable\n        self.slow = slow\n        self._show_map = show_map & find\n        self.floor = 0\n        self.count = 0\n        self.count_tm = time.time()\n        self.floor_tm = time.time()\n        self.init_tm = time.time()\n        self.my_cnt = 0\n        self.re_align = 0\n        self.unlock = unlock\n        self.check_bonus = bonus\n        self.bonus = bonus\n        self.kl = 0\n        self.gui = gui\n        self.fail_count = 0\n        self.nums = nums\n        self.end = 0\n        self.quan = 0\n        ex_notif = \"\"\n        if debug != 2:\n            pyautogui.FAILSAFE = False\n        if bonus:\n            ex_notif = \" 自动领取沉浸奖励\"\n            log.info(ex_notif)\n        self.update_count()\n        notif(\"开始运行\" + ex_notif, f\"初始计数：{self.count}\")\n        set_debug(debug > 0)\n        if update and find:\n            update_map()\n        self.lst_changed = time.time()\n        log.info(\"加载地图\")\n        for file in os.listdir(\"imgs/maps\"):\n            pth = \"imgs/maps/\" + file + \"/init.jpg\"\n            if os.path.exists(pth):\n                image = cv.imread(pth)\n                self.img_set.append((file, self.extract_features(image)))\n                self.img_map[file]= image\n        log.info(\"加载地图完成，共 %d 张\" % len(self.img_set))\n\n    # 初始化地图，刚进图时调用\n    def init_map(self):\n        self.backup_map()\n        self.big_map = np.zeros((8192, 8192), dtype=np.uint8)\n        self.big_map_c = 0\n        self.lst_tm = 0\n        self.tries = 0\n        self.his_loc = (30, 30)\n        self.offset = (30, 30)\n        self.now_loc = (4096, 4096)\n        self.mini_state = 1\n        self.ang_off = 0\n        self.ang_neg = 0\n        self.first_mini = 1\n        self.in_battle = time.time()\n        self.map_file = \"imgs/maps/my_\" + str(random.randint(0, 99999)) + \"/\"\n        if self.find == 0 and not os.path.exists(self.map_file):\n            os.mkdir(self.map_file)\n\n    def route(self):\n        self.threshold = 0.97\n        self.battle = 0\n        self.quit = 0\n        self.floor_init = 0\n        self.in_battle = 0\n        self.init_map()\n        fail_cnt = 0\n        fail_time = 0\n        self.confirm_time = 0\n        self._stop = os.stat(\"imgs/mon\" + self.tss).st_size != 141882\n        fp = 1\n        while True:\n            if self._stop:\n                break\n            hwnd = win32gui.GetForegroundWindow()  # 根据当前活动窗口获取句柄\n            Text = win32gui.GetWindowText(hwnd)\n            warn_game = False\n            cnt = 0\n            while Text != \"崩坏：星穹铁道\" and Text != \"云·星穹铁道\" and not self._stop:\n                self.lst_changed = time.time()\n                if self._stop:\n                    raise KeyboardInterrupt\n                if not warn_game:\n                    warn_game = True\n                    log.warning(f\"等待游戏窗口，当前窗口：{Text}\")\n                time.sleep(0.5)\n                cnt += 1\n                if cnt == 1200:\n                    set_forground()\n                hwnd = win32gui.GetForegroundWindow()  # 根据当前活动窗口获取句柄\n                Text = win32gui.GetWindowText(hwnd)\n            if self._stop:\n                break\n            self.get_screen()\n            # self.click_target('imgs/fail.jpg',0.9,True) # 如果需要输出某张图片在游戏窗口中的坐标，可以用这个\n            \"\"\"\n            if begin and not self.check(\"f\", 0.4437,0.4231) and not self.check(\"abyss/1\",0.8568,0.6769):\n                begin = 0\n                self.press(\"F4\")\n                time.sleep(0.6)\n                self.get_screen()\n            \"\"\"\n            res = self.normal()\n            # 未匹配到图片，降低匹配阈值，若一直无法匹配则乱点\n            if res == 0:\n                if time.time()-self.in_battle>7:\n                    if time.time()-self.in_battle>90 and self.in_battle>0:\n                        self.press('esc')\n                        time.sleep(1)\n                        self.in_battle = time.time() - 84 * fp\n                        fp = not fp\n                        continue\n                    if self.click_text(['点击空白','开始游戏'],click=0):\n                        self.click((0.2062, 0.1554))\n                        time.sleep(0.5)\n                    if self.ts.nothing:\n                        self.in_battle = time.time()\n                    if time.time()-self.confirm_time>4:\n                        if self.threshold == 0.97 and fail_cnt==0:\n                            log.info(\"匹配不到任何图标\")\n                            fail_time = time.time()\n                        else:\n                            time.sleep(0.8)\n                        if self.threshold > 0.95:\n                            self.threshold -= 0.015\n                        elif time.time()-fail_time>7.5:\n                            time.sleep(0.15)\n                            if fail_cnt <= 1:\n                                self.click((0.5000, 0.1454))\n                                fail_cnt += 1\n                            else:\n                                self.click((0.2062, 0.2054))\n                                fail_cnt = 0\n                                fail_time = time.time()\n                            time.sleep(0.35)\n                            self.threshold = 0.97\n                else:\n                    time.sleep(0.75)\n            # 匹配到图片 res=1时等待一段时间\n            else:\n                fail_cnt = 0\n                self.threshold = 0.97\n                fail_time = time.time()\n            time.sleep(0.1)\n        log.info(\"停止运行\")\n\n    def end_of_uni(self):\n        self.update_count(0)\n        self.my_cnt += 1\n        tm = int((time.time() - self.init_tm) / 60)\n        remain_round = self.nums-self.my_cnt\n        if remain_round > 0:\n            remain = int(remain_round * (time.time() - self.init_tm) / self.my_cnt / 60)\n        else:\n            remain = 0\n            remain_round = -1\n        notif(\n            \"已完成\",\n            f\"计数:{self.count} 剩余:{remain_round} 已使用：{tm//60}小时{tm%60}分钟  平均{tm//self.my_cnt}分钟一次  预计剩余{remain//60}小时{remain%60}分钟\",\n            cnt=str(self.count),\n        )\n        if self.debug == 0 and self.check_bonus == 0 and self.nums <= self.my_cnt and self.nums >= 0:\n            log.info('已完成上限，准备停止运行')\n            self.end = 1\n        self.floor = 0\n\n    def normal(self):\n        # self.lst_changed：最后一次交互时间，长时间无交互则暂离\n        bk_lst_changed = self.lst_changed\n        self.lst_changed = time.time()\n        # 战斗界面\n        if self.check(\"c\", 0.9464, 0.1287, threshold=0.985) or self.check(\n            \"auto_2\", 0.0583, 0.0769):\n            # 需要打开自动战斗\n            if self.check(\"c\", 0.9464, 0.1287, threshold=0.985):\n                self.press(\"v\")\n            if time.time() - self.f_time < 20:\n                self.f_time = 0\n                self.floor -= 1\n                self.restore_map()\n            if self.fate == \"丰饶\":\n                if random.randint(0, 5) == 3:\n                    self.press(\"3\")\n                if random.randint(0, 6) == 3:\n                    self.press(\"r\")\n            # self.battle：最后一次处于战斗状态的时间，0表示处于非战斗状态\n            self.battle = time.time()\n            self.in_battle = time.time()\n            return 1\n        # 祝福界面/回响界面 （放在一起处理了）\n        if self.check(\"choose_bless\", 0.9266, 0.9491):\n            time.sleep(0.3)\n            chose = 0\n            self.battle = 0\n            if self.check(\"reset\",0.2938,0.0954):\n                for _ in range(14):\n                    self.get_screen()\n                    img_down = self.check(\"z\", 0.5042, 0.3204, mask=\"mask\", large=False)\n                    if (\n                        self.ts.split_and_find(self.tk.fates, img_down, mode=\"bless\")[1]\n                        or self._stop\n                    ):\n                        time.sleep(0.2)\n                        break\n                    if not self.check(\"choose_bless\", 0.9266, 0.9491):\n                        return 1\n                    time.sleep(0.2)\n                self.get_screen()\n                img_up = self.check(\"z\", 0.5047, 0.5491, mask=\"mask_bless\", large=False)\n                res_up = self.ts.split_and_find(self.tk.prior_bless, img_up, bless_skip=self.tk.skip)\n                img_down = self.check(\"z\", 0.5042, 0.3204, mask=\"mask\", large=False)\n                res_down = self.ts.split_and_find([self.fate], img_down, mode=\"bless\")\n                if res_up[1] == 2:\n                    self.click(self.calc_point((0.5047, 0.5491), res_up[0]))\n                    chose = 1\n                elif res_down[1] == 2:\n                    self.click(self.calc_point((0.5042, 0.3204), res_down[0]))\n                    chose = 1\n                if not chose:\n                    self.click((0.2990, 0.1046))\n                    time.sleep(1.2)\n            # 未匹配到优先祝福，刷新祝福并再次匹配\n            if not chose:\n                for _ in range(8):\n                    self.get_screen()\n                    img_down = self.check(\"z\", 0.5042, 0.3204, mask=\"mask\", large=False)\n                    if self.ts.split_and_find(self.tk.fates, img_down)[1] or self._stop:\n                        time.sleep(0.2)\n                        break\n                    if not self.check(\"choose_bless\", 0.9266, 0.9491):\n                        return 1\n                    time.sleep(0.2)\n                self.get_screen()\n                img_up = self.check(\"z\", 0.5047, 0.5491, mask=\"mask_bless\", large=False)\n                res_up = self.ts.split_and_find(self.tk.prior_bless, img_up,bless_skip=self.tk.skip)\n                img_down = self.check(\"z\", 0.5042, 0.3204, mask=\"mask\", large=False)\n                res_down = self.ts.split_and_find(\n                    self.tk.secondary, img_down, mode=\"bless\"\n                )\n                if res_up[1] == 2:\n                    self.click(self.calc_point((0.5047, 0.5491), res_up[0]))\n                elif res_down[1] >= 2:\n                    self.click(self.calc_point((0.5042, 0.3204), res_down[0]))\n                else:\n                    self.click(self.calc_point((0.5047, 0.5491), res_up[0]))\n                time.sleep(0.4)\n            self.click((0.1203, 0.1093))\n            tm=time.time()\n            while time.time()-tm<1.6 and self.check(\"choose_bless\", 0.9266, 0.9491):\n                time.sleep(0.1)\n                self.get_screen()\n            self.confirm_time = time.time()\n            if self.quan:\n                self.use_e()\n            return 1\n        # F交互界面\n        elif self.check(\"f\", 0.4443, 0.4417, mask=\"mask_f1\", threshold=0.96):\n            # is_killed：是否是禁用交互（沉浸奖励、复活装置、下载装置）\n            is_killed = 0\n            time.sleep(0.4)\n            self.get_screen()\n            if self.check(\"f\", 0.4443, 0.4417, mask=\"mask_f1\", threshold=0.96):\n                for _ in range(4):\n                    img = self.check(\"z\", 0.3181, 0.4324, mask=\"mask_f\", large=False)\n                    text = self.ts.sim_list(self.tk.interacts, img)\n                    if text is None:\n                        img = self.check(\n                            \"z\", 0.3365, 0.4231, mask=\"mask_f\", large=False\n                        )\n                        text = self.ts.sim_list(self.tk.interacts, img)\n                    if text is not None:\n                        break\n                    time.sleep(0.3)\n                    self.get_screen()\n                # 黑塔\n                if self.ts.sim(\"黑塔\"):\n                    # 与黑塔交互后30秒内禁止再次交互（防止死循环）\n                    if time.time() - self.quit > 30 and self.floor:\n                        self.quit = time.time()\n                        self.press('f')\n                        self.battle = 0\n                    else:\n                        is_killed = 1\n                else:\n                    # tele：区域-xx  exit：离开模拟宇宙\n                    if self.ts.sim(\"区域\"):\n                        log.info(f\"识别到传送点\")\n                        self.press('f')\n                        return self.nof()\n                    elif self.re_align == 1 and self.debug == 0:\n                        # align_angle(10, 1)\n                        # self.multi = config.multi\n                        self.re_align += 1\n                    is_killed = text in [\"沉浸\", \"紧锁\", \"复活\", \"下载\"]\n                    if is_killed == 0:\n                        self.press('f')\n                    self.battle = 0\n                if is_killed == 0:\n                    return 1\n        # 跑图状态\n        if self.isrun():\n            if self.speed and not self.quan and self.check(\"huangquan\", 0.0578,0.7083):\n                self.quan = 1\n            if self.floor_init == 0:\n                if self.get_level() == -1:\n                    return 1\n                self.floor_init = 1\n            self.lst_changed = bk_lst_changed\n            self.battle = 0\n            # 刚进图，初始化一些数据\n            if self.big_map_c == 0:\n                keyops.keyUp(\"w\")\n                # 黑屏检测\n                while 1:\n                    men = np.mean(self.get_screen())\n                    if men > 12:\n                        break\n                    time.sleep(0.1)\n                    if self._stop:\n                        return 1\n                if self._stop:\n                    return 1\n                self.big_map_c = 1\n                # 寻路模式，匹配最接近的地图\n                if self.find:\n                    now_time = time.time()\n                    self.now_map_sim = -1\n                    self.now_map = -1\n                    if self.floor in [0, 5]:\n                        self.mini_state = 0\n                        self.stop_move = 0\n                        while True:\n                            self.exist_minimap()\n                            now_map, now_map_sim = self.match_scr(self.loc_scr)\n                            if self.now_map_sim < now_map_sim:\n                                self.now_map, self.now_map_sim = now_map, now_map_sim\n                            if (\n                                (self.now_map_sim > 0.65 or time.time() - now_time > 2.5)\n                                and self.now_map_sim != -1\n                            ) or self._stop:\n                                break\n                            time.sleep(0.3)\n                        log.info(f\"地图编号：{self.now_map}  相似度：{self.now_map_sim}\")\n                        if self.now_map_sim < 0.35:\n                            notif(\"相似度过低\", \"疑似在黑塔办公室\")\n                            if self.debug==2:\n                                time.sleep(10000)\n                            # self.init_map()\n                            # return 1\n                        if self.debug == 2:\n                            try:\n                                with open(\n                                    \"check0.txt\",\n                                    \"r\",\n                                    encoding=\"utf-8\",\n                                    errors=\"ignore\",\n                                ) as fh:\n                                    s = fh.readline().strip(\"\\n\")\n                                s = eval(s)\n                                self.kl = 0\n                                if not self.now_map in s:\n                                    s.append(self.now_map)\n                                    notif(f\"地图编号：{self.now_map}\",f\"相似度：{self.now_map_sim}\")\n                                else:\n                                    #self.kl = 1\n                                    pass\n                                with open(\n                                    \"check0.txt\",\n                                    \"w\",\n                                    encoding=\"utf-8\",\n                                ) as fh:\n                                    fh.write(str(s))\n                            except:\n                                pass\n                        self.now_pth = \"imgs/maps/\" + self.now_map + \"/\"\n                        files = self.find_latest_modified_file(self.now_pth)\n                        print(\"地图文件：\", files)\n                        self.big_map = cv.imread(files, cv.IMREAD_GRAYSCALE)\n                        self.debug_map = deepcopy(self.big_map)\n                        xy = files.split(\"/\")[-1].split(\"_\")[1:3]\n                        self.now_loc = (4096 - int(xy[0]), 4096 - int(xy[1]))\n                        self.target = self.get_target(self.now_pth + \"target.jpg\")\n                        self.get_screen()\n                        shape = (int(self.scx * 190), int(self.scx * 190))\n                        local_screen = self.get_local(0.9333, 0.8657, shape)\n                        self.init_ang = 360 - self.get_now_direc(local_screen) - 90\n                        log.info(\"target %s\" % self.target)\n                    if self._stop:\n                        return 1\n                    if self.consumable and (self.check_bonus or self.count<34) and self.floor in [3, 7, 12][-self.consumable:]:\n                        self.use_consumable(1, 1)\n                    self.press(\"1\")\n                # 录制模式，保存初始小地图\n                else:\n                    time.sleep(3)\n                    self.mini_state = 0\n                    self.exist_minimap()\n                    cv.imwrite(self.map_file + \"init.jpg\", self.loc_scr)\n            self.get_screen()\n            if time.time() - self.lst_tm > 5 and self.mini_state == 0:\n                if self.find == 0:\n                    self.press(\"s\", 0.5)\n                    if self._stop == 0:\n                        keyops.keyDown(\"w\")\n                    time.sleep(0.5)\n                    self.get_screen()\n            self.lst_tm = time.time()\n            \n            self.kl |= self.floor >= 4 and self.debug == 2\n            # 长时间未交互/战斗，暂离或重开\n            if (\n                (\n                    (time.time() - self.lst_changed >= 37 - 4 * self.debug + 8 * self.slow)\n                    and self.find == 1\n                )\n                or (self.floor == 12 and self.mini_state > 4)\n                or self.kl\n            ):\n                time.sleep(2.5)\n                self.press(\"esc\")\n                time.sleep(2)\n                self.init_map()\n                self.floor_init = 0\n                if self.floor == 12 or self.kl:\n                    self.end_of_uni()\n                    self.click((0.2708, 0.1324))\n                    log.info(f\"通关！当前层数:{self.floor+1}\")\n                elif self.debug == 2:\n                    map_log.error(f\"地图{self.now_map}出现问题,退出程序\")\n                    log.info('地图错误')\n                    notif(f\"地图{self.now_map}出现问题,退出程序\", \"DEBUG\")\n                    self._stop = 1\n                elif self.fail_count <= 1:\n                    notif(\"暂离\", f\"地图{self.now_map}，当前层数:{self.floor+1}\")\n                    map_log.error(f\"地图{self.now_map}未发现目标,相似度{self.now_map_sim}，尝试暂离\")\n                    self.click((0.2708, 0.2324))\n                    self.re_enter()\n                    self.re_align += 1\n                    self.fail_count += 1\n                else:\n                    self.multi = 1.01\n                    if self.debug == 0:\n                        notif(\"中途结算\", f\"地图{self.now_map}，当前层数:{self.floor+1}\")\n                        self.floor = 0\n                        self.click((0.2708, 0.1324))\n                        map_log.error(\n                            f\"地图{self.now_map}未发现目标,相似度{self.now_map_sim}，尝试退出重进\"\n                        )\n                        self.fail_count = 0\n                    else:\n                        self.re_align += 1\n                        map_log.error(\n                            f\"地图{self.now_map}未发现目标,相似度{self.now_map_sim}，尝试暂离 DEBUG\"\n                        )\n                        self.click((0.2708, 0.2324))\n                        self.re_enter()\n                self.lst_changed = time.time()\n                return 1\n            if self.multi == 1.01:\n                align_angle(0, 1, [1], self)\n            self.get_screen()\n            if self.floor > 0 and self.check(\"ruan\",0.0625,0.7065,threshold=0.95) and not self.check(\"U\", 0.0240,0.7759) and not (self.floor==12 and self.mini_state>1):\n                self.press('e')\n                time.sleep(1.5)\n                self.get_screen()\n                if self.check('e',0.4995,0.7500):\n                    self.solve_snack()\n            # 寻路\n            if self.mini_state:\n                self.get_direc_only_minimap()\n            else:\n                self.get_direc()\n            return 2\n        elif self.check('e',0.4995,0.7500):\n            self.solve_snack()\n        elif self.check(\"init\", 0.9120,0.8361):\n            if self.end:\n                time.sleep(1)\n                self.press('esc')\n                self._stop = 1\n                log.info('已退出模拟宇宙，自动化结束')\n                return 1\n            time.sleep(2)\n            self.click((0.3448, 0.4926))\n            time.sleep(1)\n            self.init_map()\n        elif self.check(\"begin\", 0.3578,0.8046):\n            con = self.check(\"conti\", 0.1422,0.0907)\n            if not con:\n                if self.diffi == 5:\n                    self.click((0.9375, 0.8565 - 0.3))\n                    time.sleep(0.2)\n                self.click((0.9375, 0.8565 - 0.1 * (self.diffi - 1)))\n            self.click((0.1083, 0.1009))\n            if con:\n                self.get_level()\n            else:\n                self.floor = 0\n            self.floor_init = 1\n        elif self.check(\"start\", 0.6594, 0.8389):\n            self.fail_count = 0\n            self.allow_e = 1\n            if self.check(\"team4\", 0.5797, 0.2389):\n                dx = 0.9266 - 0.8552\n                dy = 0.8194 - 0.6741\n                for i in self.order:\n                    self.click(\n                        (0.9266 - dx * ((i - 1) % 3), 0.8194 - dy * ((i - 1) // 3))\n                    )\n                    time.sleep(0.3)\n            self.click((0.1635, 0.1056))\n        elif self.check(\"fate_2\", 0.1182,0.0926):\n            self.click((0.1182,0.0926))\n            self.confirm_time = time.time()\n        elif self.check(\"fate\", 0.9432,0.9389):\n            time.sleep(0.6)\n            click_x = [0.02, 0.98]\n            n = 4  # 重试次数\n            res = None\n            while n:\n                self.get_screen()\n                img = self.check(\"z\", 0.4969, 0.3750, mask=\"mask_fate\", large=False)\n                res = self.ts.split_and_find([self.fate], img)\n                if res[1] == 1 and n:\n                    # 没有找到命途\n                    log.info(f\"未找到 {self.fate} 命途，尝试翻页\")\n                    self.click((click_x[n % len(click_x)], 0.5))\n                    n -= 1\n                    time.sleep(0.5)\n                    continue\n                else:\n                    break\n            self.click(self.calc_point((0.4969, 0.3750), res[0]))\n        elif self.check(\"fate_3\", 0.9422, 0.9472):\n            if not self.click_text(['2星祝福','奇物']):\n                self.click((0.5047, 0.4917))\n            self.click((0.5062, 0.1065))\n            time.sleep(1)\n        # 事件界面\n        elif self.check(\"event\", 0.9479, 0.9565):\n            # 事件界面：选择\n            if self.check(\"arrow\", 0.1828, 0.5000, mask=\"mask_event\"):\n                self.click((self.tx, self.ty))\n            # 事件界面：退出\n            elif self.check(\"arrow_1\", 0.1828, 0.5000, mask=\"mask_event\"):\n                self.click((self.tx, self.ty))\n            # 事件选择界面\n            elif self.check(\"star\", 0.1828, 0.5000, mask=\"mask_event\", threshold=0.965):\n                tx, ty = self.tx, self.ty\n                try:\n                    import yaml\n                    with open(\"info.yml\", \"r\", encoding=\"utf-8\", errors=\"ignore\") as f:\n                        event_prior = yaml.safe_load(f)[\"prior\"][\"事件\"]\n                except:\n                    event_prior = [\n                        '购买一个',\n                        '丢下雕像',\n                        '和序列扑满玩',\n                        '信仰星神',\n                        '克里珀的恩赐',\n                        '哈克的藏品',\n                        '动作片',\n                        '感恩克里珀星神',\n                        '换取1个星祝福',\n                        '星神的记载',\n                        '翻开牌',\n                        '摧毁黑匣',\n                        '1个1星祝福',\n                        '1个1-星祝福',\n                        '选择里奥'\n                    ]\n                event_prior = [self.fate] + event_prior\n                success = self.click_text(event_prior,env='event')\n                time.sleep(0.3)\n                self.get_screen()\n                if success and self.check(\"confirm\", 0.1828, 0.5000, mask=\"mask_event\", threshold=0.965):\n                    self.click((self.tx, self.ty))\n                else:\n                    self.click((tx, ty))\n                    time.sleep(0.3)\n                    self.click((0.1167, ty - 0.4685 + 0.3546))\n                time.sleep(0.5)\n                for _ in range(7):\n                    self.get_screen()\n                    if not self.check(\"event\", 0.9479, 0.9565):\n                        break\n                    time.sleep(0.1)\n                self.lst_changed = time.time()\n            else:\n                self.click((0.9479, 0.9565))\n        # 选取奇物\n        elif self.check(\"strange\", 0.9417, 0.9481):\n            time.sleep(0.6)\n            self.get_screen()\n            img = self.check(\"z\", 0.5000, 0.7333, mask=\"mask_strange\", large=False)\n            res = self.ts.split_and_find(self.tk.strange, img, mode=\"strange\")\n            self.click(self.calc_point((0.5000, 0.7333), res[0]))\n            self.click((0.1365, 0.1093))\n            self.wait_fig(lambda:self.check(\"strange\", 0.9417, 0.9481), 1.4)\n        # 丢弃奇物\n        elif self.check(\"drop\", 0.9406, 0.9491):\n            self.click((0.4714, 0.5500))\n            self.click((0.1339, 0.1028))\n            self.wait_fig(lambda:self.check(\"drop\", 0.9406, 0.9491), 1.4)\n        elif self.check(\"drop_bless\", 0.9417, 0.9481, threshold=0.95):\n            time.sleep(1.5)\n            st = set(self.tk.fates) - set(self.tk.secondary)\n            clicked = 0\n            for i,ft in enumerate(self.tk.secondary[::-1]):\n                if ft != self.fate or i == len(self.tk.secondary):\n                    self.get_screen()\n                    img_down = self.check(\"z\", 0.5042, 0.3204, mask=\"mask\", large=False)\n                    if self.debug==2:\n                        print(list(st),self.tk.secondary)\n                    res_down = self.ts.split_and_find(list(st), img_down, mode=\"bless\")\n                    if res_down[1] == 2:\n                        self.click(self.calc_point((0.5042, 0.3204), res_down[0]))\n                        clicked = 1\n                        break\n                    st.add(ft)\n            if not clicked:\n                self.click((0.4714, 0.5500))\n            time.sleep(0.5)\n            self.click((0.1203, 0.1093))\n            self.confirm_time = time.time()\n        elif self.check(\"setting\", 0.9734, 0.3009, threshold=0.98):\n            self.click((0.2708, 0.2324))\n            self.re_enter()\n        elif self.check(\"enhance\", 0.9208, 0.9380):\n            self.quit = time.time()\n            time.sleep(1.5)\n            for i in [None, (0.7984, 0.6824), (0.6859, 0.6824)]:\n                self.get_screen()\n                if self.check(\"enhance_fail\", 0.1068, 0.0907):\n                    break\n                if i is not None:\n                    self.click(i)\n                    time.sleep(0.3)\n                self.click((0.1089, 0.0926))\n                time.sleep(0.3)\n                tm = time.time()\n                self.get_screen()\n                while not self.check(\"enhance\", 0.9208, 0.9380) and time.time()-tm<7:\n                    self.click((0.2062, 0.2054))\n                    time.sleep(0.3)\n                    self.get_screen()\n            self.press(\"esc\")\n            self.press(\"w\", 2)\n            tm = time.time()\n            while time.time()-tm<2 and not self.check(\"f\", 0.4443, 0.4417, mask=\"mask_f1\", threshold=0.96) and not self.isrun():\n                self.get_screen()\n                time.sleep(0.15)\n            # time.sleep(0.35)\n            # self.mouse_move(-30)\n            self.confirm_time = time.time()\n            self.lst_changed = time.time()\n            if self.floor >= 12:\n                self.floor = 11\n        elif self.check(\"yes1\", 0.5, 0.5, mask=\"mask_end\"):\n            self.click((self.tx,self.ty))\n            time.sleep(1)\n            return 0\n        elif self.check(\"fail\", 0.6276, 0.0843):\n            self.click((self.tx, self.ty))\n            time.sleep(1.8)\n        else:\n            return 0\n        return 1\n\n    def find_latest_modified_file(self, folder_path):\n        files = [\n            os.path.join(folder_path, file)\n            for file in os.listdir(folder_path)\n            if file.split(\"/\")[-1][0] == \"m\"\n        ]\n        nx, ny = 4096, 4096\n        file = \"\"\n        for i in files:\n            try:\n                x, y = i.split(\"_\")[-3:-1]\n                x, y = int(x), int(y)\n                if x < nx or y < ny:\n                    nx, ny = x, y\n                    file = i\n            except:\n                pass\n        return file\n\n    def update_count(self, read=True):\n        file_name = \"logs/notif.txt\"\n        if read:\n            new_cnt = 0\n            if os.path.exists(file_name):\n                time_cnt = os.path.getmtime(file_name)\n                with open(file_name, \"r\", encoding=\"utf-8\", errors=\"ignore\") as fh:\n                    s = fh.readlines()\n                    try:\n                        new_cnt = int(s[0].strip(\"\\n\"))\n                        time_cnt = float(s[3].strip(\"\\n\"))\n                    except:\n                        pass\n            else:\n                os.makedirs(\"logs\", exist_ok=1)\n                with open(file_name, \"w\", encoding=\"utf-8\") as file:\n                    file.write(\"0\")\n                    file.close()\n                time_cnt = os.path.getmtime(file_name)\n        else:\n            new_cnt = self.count + 1\n            time_cnt = self.count_tm\n        dt = datetime.datetime.now().astimezone()\n        \"\"\"\n        America: GMT-5\n        Asia: GMT+8\n        Europe: GMT+1\n        TW, HK, MO: GMT+8\n        \"\"\"\n        tz_info = None\n        try:\n            tz_dict = {\n                \"Default\": None,\n                \"America\": pytz.timezone(\"US/Central\"),\n                \"Asia\": pytz.timezone(\"Asia/Shanghai\"),\n                \"Europe\": pytz.timezone(\"Europe/London\"),\n            }\n            tz_info = tz_dict[config.timezone]\n        except:\n            pass\n\n        # convert to server time\n        dt = dt.astimezone(tz_info)\n        current_weekday = dt.weekday()\n        monday = dt + datetime.timedelta(days=-current_weekday)\n        target_datetime = datetime.datetime(\n            monday.year, monday.month, monday.day, 4, 0, 0, tzinfo=tz_info\n        )\n        monday_ts = target_datetime.timestamp()\n        if dt.timestamp() >= monday_ts and time_cnt < monday_ts:\n            self.count = int(not read)\n        else:\n            self.count = new_cnt\n        self.count_tm = time.time()\n\n    def del_pt(self, img, A, S, f):\n        if (\n            A[0] < 0\n            or A[1] < 0\n            or A[0] >= img.shape[0]\n            or A[1] >= img.shape[1]\n            or (img[A] == [0, 0, 0]).all()\n            or (not f(img[A]) and self.get_dis(A, S) > 5)\n            or self.get_dis(A, S) > 10\n        ):\n            return\n        else:\n            img[A] = [0, 0, 0]\n        for dx, dy in [(0, -1), (0, 1), (1, 0), (-1, 0)]:\n            self.del_pt(img, (A[0] + dx, A[1] + dy), S, f)\n\n    def get_target(self, pth):\n        img = cv.imread(pth)\n        res = set()\n        f_set = [\n            lambda p: p[2] < 85 and p[1] < 85 and p[0] > 180,  # 路径点 蓝\n            lambda p: p[2] > 180 and p[1] < 70 and p[0] < 70,  # 怪 红\n            lambda p: p[2] < 90 and p[1] > 150 and p[0] < 90,  # 交互点 绿\n            lambda p: p[2] > 180 and p[1] > 180 and p[0] < 70,  # 终点 黄\n        ]\n        for i in range(img.shape[0]):\n            for j in range(img.shape[1]):\n                for k in range(4):\n                    if f_set[k](img[i, j]):\n                        p = self.get_center(img, i, j)\n                        res.add((p, k))\n                        p = (int(p[0]), int(p[1]))\n                        self.del_pt(img, p, p, f_set[k])\n                        if k == 3:\n                            self.last = p\n        # cv.imwrite(\"imgs/tmp1.jpg\", img)\n        if self.speed:\n            dis = 1000000\n            pt = None\n            for i in res:\n                if i[1] == 1 and self.get_dis(i[0], self.last) < dis:\n                    dis = self.get_dis(i[0], self.last)\n                    pt = i\n            for i in deepcopy(res):\n                if i[1] == 1 and pt != i:\n                    res.remove(i)\n                    res.add((i[0], 0))\n        return res\n\n    def get_center(self, img, i, j):\n        rx, ry, rt = 0, 0, 0\n        for x in range(-7, 7):\n            for y in range(-7, 7):\n                if (\n                    i + x >= 0\n                    and j + y >= 0\n                    and i + x < img.shape[0]\n                    and j + y < img.shape[1]\n                ):\n                    s = np.sum(img[i + x, j + y])\n                    if s > 30 and s < 255 * 3 - 30:\n                        rt += 1\n                        rx += x\n                        ry += y\n        return (i + rx / rt, j + ry / rt)\n    \n    def backup_map(self):\n        try:\n            self.bbig_map,self.bbig_map_c,self.blst_tm,self.btries,self.bhis_loc,self.boffset,self.bnow_loc,self.bmini_state,self.bang_off,self.bang_neg,self.bfirst_mini=self.big_map,self.big_map_c,self.lst_tm,self.tries,self.his_loc,self.offset,self.now_loc,self.mini_state,self.ang_off,self.ang_neg,self.first_mini\n        except:\n            pass\n    def restore_map(self):\n        self.big_map,self.big_map_c,self.lst_tm,self.tries,self.his_loc,self.offset,self.now_loc,self.mini_state,self.ang_off,self.ang_neg,self.first_mini=self.bbig_map,self.bbig_map_c,self.blst_tm,self.btries,self.bhis_loc,self.boffset,self.bnow_loc,self.bmini_state,self.bang_off,self.bang_neg,self.bfirst_mini\n\n    def re_enter(self):\n        tm = time.time()\n        while time.time() - tm < 10:\n            self.get_screen()\n            if self.check(\"f\", 0.4443, 0.4417, mask=\"mask_f1\", threshold=0.96):\n                self.press('f')\n                time.sleep(0.5)\n                self.press('f')\n                time.sleep(0.5)\n                self.press('f')\n                break\n\n    def stop(self, *_, **__):\n        log.info(\"尝试停止运行\")\n        try:\n            if self.debug:\n                traceback.print_stack()\n        except:\n            pass\n        self._stop = True\n        self._stop = 1\n        self._stop = True\n        self._stop = 1\n        self._stop = True\n    \n    def on_key_press(self, event):\n        global stop_flag\n        if event.name == \"f8\":\n            print(\"F8 已被按下，尝试停止运行\")\n            self.stop()\n\n    def show_map(self):\n        # Create a window to display the image\n        cv.namedWindow(\"Map\", cv.WINDOW_AUTOSIZE)\n\n        # Update the image every second\n        while not self._stop:\n            if self.debug_map.shape[0] == 8192:\n                continue\n            # Load the updated image\n            updated_image = self.debug_map.copy()\n\n            # 灰度图转RGB\n            updated_image = cv.cvtColor(updated_image, cv.COLOR_GRAY2RGB)\n            updated_image[\n                self.real_loc[0] - 2 : self.real_loc[0] + 3,\n                self.real_loc[1] - 2 : self.real_loc[1] + 3,\n            ] = [49, 49, 140]\n\n            # 将图片放大两倍\n            updated_image = cv.resize(\n                updated_image, None, fx=2, fy=2, interpolation=cv.INTER_LINEAR\n            )\n\n            # Update the displayed image\n            cv.imshow(\"Map\", updated_image)\n\n            # Wait for one second\n            cv.waitKey(1000)\n\n        # Destroy the window\n        cv.destroyAllWindows()\n\n    def check_req(self):\n        self._stop |= os.system(\"pip show numpy > NUL 2>&1\") and not self.unlock\n        if self._stop:\n            log.info(\"未安装依赖库或环境变量未正确设置\")\n        time.sleep(10)\n        self._stop |= os.system(\"pip show numpy > NUL 2>&1\") and not self.unlock\n        if self._stop:\n            log.info(\"未安装依赖库或环境变量未正确设置\")\n\n    def start(self):\n        self._stop = False\n        if self.validation == 0:\n            return\n        keyboard.on_press(self.on_key_press)\n        if self._show_map:\n            t_map = threading.Thread(target=self.show_map)\n            t_map.start()\n        # threading.Thread(target=self.check_req).start()\n        try:\n            self.route()\n        except KeyboardInterrupt:\n            print(\"KeyboardInterrupt\")\n            try:\n                log.info('用户终止进程')\n            except:\n                pass\n            if not self._stop:\n                self.stop()\n\n\ndef main():\n    global speed, consumable, slow, bonus, nums, update\n    if speed == -1:\n        speed = config.speed_mode\n    if consumable == -1:\n        consumable = config.use_consumable\n    if slow == -1:\n        slow = config.slow_mode\n    if nums == 34:\n        nums = config.max_run\n    log.info(f\"find: {find}, debug: {debug}, show_map: {show_map}, consumable: {consumable}\")\n    su = SimulatedUniverse(find, debug, show_map, speed, consumable, slow, nums, bonus=bonus, update=update)\n    try:\n        su.start()\n    except ValueError as e:\n        pass\n    except Exception:\n        traceback.print_exc()\n    finally:\n        su.stop()\n\n\nif __name__ == \"__main__\":\n    if not pyuac.isUserAdmin():\n        pyuac.runAsAdmin()\n    else:\n        find = 1\n        debug = 0\n        show_map = 0\n        update = 0\n        speed = -1\n        consumable = -1\n        slow = -1\n        bonus = 0\n        nums = 34\n        for i in sys.argv[1:]:\n            st = i.split(\"-\")[-1]\n            if \"=\" not in st:\n                st = st + \"=1\"\n            exec(st)\n        main()\n"
        },
        {
          "name": "start.mp3",
          "type": "blob",
          "size": 241.224609375,
          "content": null
        },
        {
          "name": "utils",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}