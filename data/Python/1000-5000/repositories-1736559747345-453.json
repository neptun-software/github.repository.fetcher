{
  "metadata": {
    "timestamp": 1736559747345,
    "page": 453,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQ2MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "Jack-Lee-Hiter/AlgorithmsByPython",
      "stars": 3969,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".idea",
          "type": "tree",
          "content": null
        },
        {
          "name": "AVL.py",
          "type": "blob",
          "size": 9.2421875,
          "content": "# 构建二叉查找树(非平衡)\nclass TreeNode:\n    def __init__(self, key, val, left = None, right = None, parent = None):\n        self.key = key\n        self.payload = val\n        self.leftChild = left\n        self.rightChild = right\n        self.parent= parent\n\n    def hasLeftChild(self):\n        return self.leftChild\n\n    def hasRightChild(self):\n        return self.rightChild\n\n    def isLeftChild(self):\n        return self.parent and self.parent.leftChild == self\n\n    def isRightChild(self):\n        return self.parent and self.parent.rightChild == self\n\n    def isRoot(self):\n        return not self.parent\n\n    def isLeaf(self):\n        return not (self.rightChild or self.leftChild)\n\n    def hasAnyChildren(self):\n        return self.rightChild or self.leftChild\n\n    def hasBothChildren(self):\n        return self.rightChild and self.leftChild\n\n    def replaceNodeData(self, key, value, lc, rc):\n        self.key = key\n        self.payload = value\n        self.leftChild = lc\n        self.rightChild = rc\n        if self.hasLeftChild():\n            self.leftChild.parent = self\n        if self.hasRightChild():\n            self.rightChild.parent = self\n\nclass BinarySearchTree:\n    def __init__(self):\n        self.root = None\n        self.size = 0\n\n    def length(self):\n        return self.size\n\n    def __len__(self):\n        return self.size\n\n    def __iter__(self):\n        return self.root.__iter__()\n\n    def put(self, key, val):\n        if self.root:\n            self._put(key, val, self.root)\n        else:\n            self.root = TreeNode(key, val)\n        self.size = self.size + 1\n\n    def _put(self, key, val, currentNode):\n        if key < currentNode.key:\n            if currentNode.hasLeftChild():\n                self._put(key, val, currentNode.leftChild)\n            else:\n                currentNode.leftChild = TreeNode(key, val, parent=currentNode)\n                self.updateBalance(currentNode.leftChild)\n        else:\n            if currentNode.hasRightChild():\n                self._put(key, val, currentNode.rightChild)\n            else:\n                currentNode.rightChild = TreeNode(key, val, parent=currentNode)\n                self.updateBalance(currentNode.rightChild)\n\n    def updateBalance(self, node):\n        if node.balanceFactor > 1 or node.balanceFactor < -1:\n            self.rebalance(node)\n            return\n        if node.parent != None:\n            if node.isLeftChild():\n                node.parent.balanceFactor += 1\n            elif node.isRightChild():\n                node.parent.balanceFactor -= 1\n\n            if node.parent.balanceFactor != 0:\n                self.updateBalance(node.parent)\n\n    def rotateLeft(self, rotRoot):\n        newRoot = rotRoot.rightChild\n        rotRoot.rightChild = newRoot.leftChild\n        if newRoot.leftChild != None:\n            newRoot.leftChild.parent = rotRoot\n        newRoot.parent = rotRoot.parent\n        if rotRoot.isRoot():\n            self.root = newRoot\n        else:\n            if rotRoot.isLeftChild():\n                rotRoot.parent.leftChild = newRoot\n            else:\n                rotRoot.parent.rightChild = newRoot\n        newRoot.leftChild = rotRoot\n        rotRoot.parent = newRoot\n        rotRoot.balanceFactor = rotRoot.balanceFactor + 1 - min(newRoot.balanceFactor, 0)\n        newRoot.balanceFactor = newRoot.balanceFactor + 1 + max(rotRoot.balanceFactor, 0)\n\n    def rotateRight(self, rotRoot):\n        newRoot = rotRoot.leftChild\n        rotRoot.leftChild = newRoot.rightChild\n        if newRoot.rightChild != None:\n            newRoot.rightChild.parent = rotRoot\n        newRoot.parent = rotRoot.parent\n        if rotRoot.isRoot():\n            self.root = newRoot\n        else:\n            if rotRoot.isRightChild():\n                rotRoot.parent.rightChild = newRoot\n            else:\n                rotRoot.parent.rightChild = newRoot\n        newRoot.rightChild = rotRoot\n        rotRoot.parent = newRoot\n        rotRoot.balanceFactor = rotRoot.balanceFactor + 1 - min(newRoot.balanceFactor, 0)\n        newRoot.balanceFactor = newRoot.balanceFactor + 1 + max(rotRoot.balanceFactor, 0)\n\n    def rebalance(self, node):\n        if node.balanceFactor < 0:\n            if node.rightChild.balanceFactor > 0:\n                self.rotateRight(node.rightChild)\n                self.rotateLeft(node)\n            else:\n                self.rotateLeft(node)\n        elif node.balanceFactor > 0:\n            if node.leftChild.balanceFactor < 0:\n                self.rotateLeft(node.leftChild)\n                self.rotateRight(node)\n            else:\n                self.rotateRight(node)\n\n    def __setitem__(self, k, v):\n        self.put(k, v)\n\n    def get(self, key):\n        if self.root:\n            res = self._get(key, self.root)\n            if res:\n                return res.payload\n            else:\n                return None\n        else:\n            return None\n\n    def _get(self, key, currentNode):\n        if not currentNode:\n            return None\n        elif currentNode.key == key:\n            return currentNode\n        elif key < currentNode.key:\n            return self._get(key, currentNode.leftChild)\n        else:\n            return self._get(key, currentNode.rightChild)\n\n    def __getitem__(self, key):\n        return self.get(key)\n\n    def __contains__(self, key):\n        if self._get(key, self.root):\n            return True\n        else:\n            return False\n\n    def delete(self, key):\n        if self.size > 1:\n            nodeToRemove = self._get(key, self.root)\n            if nodeToRemove:\n                self.remove(nodeToRemove)\n                self.size -= 1\n            else:\n                raise KeyError('Error, key not in tree')\n        elif self.size == 1 and self.root.key == key:\n            self.root = None\n            self.size = self.size - 1\n        else:\n            raise KeyError('Error, key not in tree')\n\n    def __delitem__(self, key):\n        self.delete(key)\n\n    def spliceOut(self):\n        if self.isLeaf():\n            if self.isLeftChild():\n                self.parent.leftChild = None\n            else:\n                self.parent.rightChild = None\n        elif self.hasAnyChildren():\n            if self.hasLeftChild():\n                if self.isLeftChild():\n                    self.parent.leftChild = self.leftChild\n                else:\n                    self.parent.rightChild = self.leftChild\n                self.leftChild.parent = self.parent\n            else:\n                if self.isLeftChild():\n                    self.parent.leftChild = self.rightChild\n                else:\n                    self.parent.rightChild = self.rightChild\n                self.rightChild.parent = self.parent\n\n    def findSuccessor(self):\n        succ = None\n        if self.hasRightChild():\n            succ = self.rightChild.findMin()\n        else:\n            if self.parent:\n                if self.isLeftChild():\n                    succ = self.parent\n                else:\n                    self.parent.rightChild = None\n                    succ = self.parent.findSuccessor()\n                    self.parent.rightChild = self\n        return succ\n\n    def findMin(self):\n        current = self\n        while current.hasLeftChild():\n            current = current.leftChild\n        return current\n\n    def remove(self, currentNode):\n        if currentNode.isLeaf():  # leaf\n            if currentNode == currentNode.parent.leftChild:\n                currentNode.parent.leftChild = None\n            else:\n                currentNode.parent.rightChild = None\n        elif currentNode.hasBothChildren():  # interior\n            succ = currentNode.findSuccessor()\n            succ.spliceOut()\n            currentNode.key = succ.key\n            currentNode.payload = succ.payload\n\n        else:  # this node has one child\n            if currentNode.hasLeftChild():\n                if currentNode.isLeftChild():\n                    currentNode.leftChild.parent = currentNode.parent\n                    currentNode.parent.leftChild = currentNode.leftChild\n                elif currentNode.isRightChild():\n                    currentNode.leftChild.parent = currentNode.parent\n                    currentNode.parent.rightChild = currentNode.leftChild\n                else:\n                    currentNode.replaceNodeData(currentNode.leftChild.key,\n                                                currentNode.leftChild.payload,\n                                                currentNode.leftChild.leftChild,\n                                                currentNode.leftChild.rightChild)\n            else:\n                if currentNode.isLeftChild():\n                    currentNode.rightChild.parent = currentNode.parent\n                    currentNode.parent.leftChild = currentNode.rightChild\n                elif currentNode.isRightChild():\n                    currentNode.rightChild.parent = currentNode.parent\n                    currentNode.parent.rightChild = currentNode.rightChild\n                else:\n                    currentNode.replaceNodeData(currentNode.rightChild.key,\n                                                currentNode.rightChild.payload,\n                                                currentNode.rightChild.leftChild,\n                                                currentNode.rightChild.rightChild)\n\n\n\nmytree = BinarySearchTree()\nmytree[3]=\"red\"\nmytree[4]=\"blue\"\nmytree[6]=\"yellow\"\nmytree[2]=\"at\"\n\nprint(mytree[6])\nprint(mytree[2])"
        },
        {
          "name": "AnagramDetection.py",
          "type": "blob",
          "size": 1.8916015625,
          "content": "class AnagramDetection:\n    # 先对两个字符串进行list化\n    # 对字符串对应的两个list进行排序\n    # 依次比较字符是否匹配\n    def anagramSolution1(self, s1, s2):\n        alist1 = list(s1)\n        alist2 = list(s2)\n\n        alist1.sort()\n        alist2.sort()\n\n        pos = 0\n        matches = True\n\n        while pos < len(s1) and matches:\n            if alist1[pos] == alist2[pos]:\n                pos = pos + 1\n            else:\n                matches = False\n\n        return matches\n\n    # 首先生成两个26个字母的list\n    # 计算每个字母出现的次数并存入到相应的list中\n    # 比较两个list是否相同\n    def anagramSolution2(self, s1, s2):\n        c1 = [0] * 26\n        c2 = [0] * 26\n\n        for i in range(len(s1)):\n            pos = ord(s1[i]) - ord('a')\n            c1[pos] = c1[pos] + 1\n\n        for i in range(len(s2)):\n            pos = ord(s2[i]) - ord('a')\n            c2[pos] = c2[pos] + 1\n\n        j = 0\n        stillOK = True\n        while j < 26 and stillOK:\n            if c1[j] == c2[j]:\n                j = j + 1\n            else:\n                stillOK = False\n\n        return stillOK\n\n    # 首先将两个字符串list化\n    # 将两个list中的字符生成两个set\n    # 比较两个set, 如果不相等直接返回false\n    # 如果两个set相等, 比较每个set中字符在相应list中的个数, 个数不同返回false\n    def anagramSolution3(self, s1, s2):\n        alist1 = list(s1)\n        alist2 = list(s2)\n\n        aset1 = set(alist1)\n        aset2 = set(alist2)\n\n        if aset1 != aset2:\n            return False\n        else:\n            for ch in aset1:\n                if alist1.count(ch) != alist2.count(ch):\n                    return False\n            return True\n\ns1 = 'abcde'\ns2 = 'acbde'\ntest = AnagramDetection()\nprint(test.anagramSolution1(s1, s2))\nprint(test.anagramSolution2(s1, s2))\nprint(test.anagramSolution3(s1, s2))\n"
        },
        {
          "name": "AwesomeAlgorithms",
          "type": "tree",
          "content": null
        },
        {
          "name": "BinaryHeap.py",
          "type": "blob",
          "size": 1.7431640625,
          "content": "# 构建树实现堆\nclass BinHeap:\n    def __init__(self):\n        self.heapList = [0]\n        self.currentSize = 0\n\n    #插入新结点后必要时交换子节点和父节点的位置保持堆的性质\n    def percUp(self, i):\n        while i//2 > 0:\n            if self.heapList[i] < self.heapList[i//2]:\n                temp = self.heapList[i//2]\n                self.heapList[i//2] = self.heapList[i]\n                self.heapList[i] = temp\n            i = i//2\n\n    # 插入节点\n    def insert(self, k):\n        self.heapList.append(k)\n        self.currentSize += 1\n        self.percUp(self.currentSize)\n\n    # 删除堆顶元素后, 交换堆尾和空堆顶的位置并实现元素的下沉\n    def percDown(self, i):\n        while (i*2) <= self.currentSize:\n            mc = self.minChild(i)\n            if self.heapList[i] > self.heapList[mc]:\n                temp = self.heapList[i]\n                self.heapList[i] = self.heapList[mc]\n                self.heapList[mc] = temp\n            i = mc\n\n    def minChild(self, i):\n        if i * 2 + 1 > self.currentSize:\n            return i * 2\n        else:\n            if self.heapList[i*2] < self.heapList[i*2+1]:\n                return i * 2\n            else:\n                return i * 2 + 1\n\n    def delMin(self):\n        retval = self.heapList[1]\n        self.heapList[1] = self.heapList[self.currentSize]\n        self.currentSize = self.currentSize - 1\n        self.heapList.pop()\n        self.percDown(1)\n        return retval\n\n    def buildHeap(self, alist):\n        i = len(alist) // 2\n        self.currentSize = len(alist)\n        self.heapList = [0] + alist[:]\n        while (i > 0):\n            self.percDown(i)\n            i = i - 1\n        return self.heapList\n\nH = BinHeap()\nprint(H.buildHeap([9, 6, 5, 2, 3]))"
        },
        {
          "name": "BinarySearch.py",
          "type": "blob",
          "size": 0.466796875,
          "content": "# 实现一个二分查找\n# 输入:一个顺序list\n# 输出: 待查找的元素的位置\ndef binarySearch(alist, item):\n    first = 0\n    last = len(alist) - 1\n\n    while first <= last:\n        mid = (first + last)//2\n        print(mid)\n        if alist[mid] > item:\n            last = mid - 1\n        elif alist[mid] < item:\n            first = mid + 1\n        else:\n            return mid+1\n    return -1\n\ntest = [0, 1, 2, 8, 13, 17, 19, 32, 42]\nprint(binarySearch(test, 3))"
        },
        {
          "name": "BinarySearchTree.py",
          "type": "blob",
          "size": 6.787109375,
          "content": "# 构建二叉查找树(非平衡)\nclass TreeNode:\n    def __init__(self, key, val, left = None, right = None, parent = None):\n        self.key = key\n        self.payload = val\n        self.leftChild = left\n        self.rightChild = right\n        self.parent= parent\n\n    def hasLeftChild(self):\n        return self.leftChild\n\n    def hasRightChild(self):\n        return self.rightChild\n\n    def isLeftChild(self):\n        return self.parent and self.parent.leftChild == self\n\n    def isRightChild(self):\n        return self.parent and self.parent.rightChild == self\n\n    def isRoot(self):\n        return not self.parent\n\n    def isLeaf(self):\n        return not (self.rightChild or self.leftChild)\n\n    def hasAnyChildren(self):\n        return self.rightChild or self.leftChild\n\n    def hasBothChildren(self):\n        return self.rightChild and self.leftChild\n\n    def replaceNodeData(self, key, value, lc, rc):\n        self.key = key\n        self.payload = value\n        self.leftChild = lc\n        self.rightChild = rc\n        if self.hasLeftChild():\n            self.leftChild.parent = self\n        if self.hasRightChild():\n            self.rightChild.parent = self\n\nclass BinarySearchTree:\n    def __init__(self):\n        self.root = None\n        self.size = 0\n\n    def length(self):\n        return self.size\n\n    def __len__(self):\n        return self.size\n\n    def __iter__(self):\n        return self.root.__iter__()\n\n    def put(self, key, val):\n        if self.root:\n            self._put(key, val, self.root)\n        else:\n            self.root = TreeNode(key, val)\n        self.size = self.size + 1\n\n    def _put(self, key, val, currentNode):\n        if key < currentNode.key:\n            if currentNode.hasLeftChild():\n                self._put(key, val, currentNode.leftChild)\n            else:\n                currentNode.leftChild = TreeNode(key, val, parent=currentNode)\n        else:\n            if currentNode.hasRightChild():\n                self._put(key, val, currentNode.rightChild)\n            else:\n                currentNode.rightChild = TreeNode(key, val, parent=currentNode)\n\n    def __setitem__(self, k, v):\n        self.put(k, v)\n\n    def get(self, key):\n        if self.root:\n            res = self._get(key, self.root)\n            if res:\n                return res.payload\n            else:\n                return None\n        else:\n            return None\n\n    def _get(self, key, currentNode):\n        if not currentNode:\n            return None\n        elif currentNode.key == key:\n            return currentNode\n        elif key < currentNode.key:\n            return self._get(key, currentNode.leftChild)\n        else:\n            return self._get(key, currentNode.rightChild)\n\n    def __getitem__(self, key):\n        return self.get(key)\n\n    def __contains__(self, key):\n        if self._get(key, self.root):\n            return True\n        else:\n            return False\n\n    def delete(self, key):\n        if self.size > 1:\n            nodeToRemove = self._get(key, self.root)\n            if nodeToRemove:\n                self.remove(nodeToRemove)\n                self.size -= 1\n            else:\n                raise KeyError('Error, key not in tree')\n        elif self.size == 1 and self.root.key == key:\n            self.root = None\n            self.size = self.size - 1\n        else:\n            raise KeyError('Error, key not in tree')\n\n    def __delitem__(self, key):\n        self.delete(key)\n\n    def spliceOut(self):\n        if self.isLeaf():\n            if self.isLeftChild():\n                self.parent.leftChild = None\n            else:\n                self.parent.rightChild = None\n        elif self.hasAnyChildren():\n            if self.hasLeftChild():\n                if self.isLeftChild():\n                    self.parent.leftChild = self.leftChild\n                else:\n                    self.parent.rightChild = self.leftChild\n                self.leftChild.parent = self.parent\n            else:\n                if self.isLeftChild():\n                    self.parent.leftChild = self.rightChild\n                else:\n                    self.parent.rightChild = self.rightChild\n                self.rightChild.parent = self.parent\n\n    def findSuccessor(self):\n        succ = None\n        if self.hasRightChild():\n            succ = self.rightChild.findMin()\n        else:\n            if self.parent:\n                if self.isLeftChild():\n                    succ = self.parent\n                else:\n                    self.parent.rightChild = None\n                    succ = self.parent.findSuccessor()\n                    self.parent.rightChild = self\n        return succ\n\n    def findMin(self):\n        current = self\n        while current.hasLeftChild():\n            current = current.leftChild\n        return current\n\n    def remove(self, currentNode):\n        if currentNode.isLeaf():  # leaf\n            if currentNode == currentNode.parent.leftChild:\n                currentNode.parent.leftChild = None\n            else:\n                currentNode.parent.rightChild = None\n        elif currentNode.hasBothChildren():  # interior\n            succ = currentNode.findSuccessor()\n            succ.spliceOut()\n            currentNode.key = succ.key\n            currentNode.payload = succ.payload\n\n        else:  # this node has one child\n            if currentNode.hasLeftChild():\n                if currentNode.isLeftChild():\n                    currentNode.leftChild.parent = currentNode.parent\n                    currentNode.parent.leftChild = currentNode.leftChild\n                elif currentNode.isRightChild():\n                    currentNode.leftChild.parent = currentNode.parent\n                    currentNode.parent.rightChild = currentNode.leftChild\n                else:\n                    currentNode.replaceNodeData(currentNode.leftChild.key,\n                                                currentNode.leftChild.payload,\n                                                currentNode.leftChild.leftChild,\n                                                currentNode.leftChild.rightChild)\n            else:\n                if currentNode.isLeftChild():\n                    currentNode.rightChild.parent = currentNode.parent\n                    currentNode.parent.leftChild = currentNode.rightChild\n                elif currentNode.isRightChild():\n                    currentNode.rightChild.parent = currentNode.parent\n                    currentNode.parent.rightChild = currentNode.rightChild\n                else:\n                    currentNode.replaceNodeData(currentNode.rightChild.key,\n                                                currentNode.rightChild.payload,\n                                                currentNode.rightChild.leftChild,\n                                                currentNode.rightChild.rightChild)\n\n\n\nmytree = BinarySearchTree()\nmytree[3]=\"red\"\nmytree[4]=\"blue\"\nmytree[6]=\"yellow\"\nmytree[2]=\"at\"\n\nprint(mytree[6])\nprint(mytree[2])"
        },
        {
          "name": "BinaryTree.py",
          "type": "blob",
          "size": 1.4580078125,
          "content": "class BinaryTree:\n    def __init__(self, rootObj):\n        self.key = rootObj\n        self.leftChild = None\n        self.rightChild = None\n\n    def insertLeft(self, newNode):\n        if self.leftChild == None:\n            self.leftChild = BinaryTree(newNode)\n        else:\n            t = BinaryTree(newNode)\n            t.leftChild = self.leftChild\n            self.leftChild = t\n\n    def insertRight(self, newNode):\n        if self.rightChild == None:\n            self.rightChild = BinaryTree(newNode)\n        else:\n            t = BinaryTree(newNode)\n            t.rightChild = self.rightChild\n            self.rightChild = t\n\n    def getRightChild(self):\n        return self.rightChild\n\n    def getLeftChild(self):\n        return self.leftChild\n\n    def setRootVal(self, obj):\n        self.key = obj\n\n    def getRootVal(self):\n        return self.key\n\n    # 树的前序遍历\n    # 树的后序遍历以及中序遍历见ParseTree.py\n    def preorder(self):\n        print(self.key)\n        if self.leftChild:\n            self.leftChild.preorder()\n        if self.rightChild:\n            self.rightChild.preorder()\n\n'''\n以下为测试数据, 去掉 # 即可\n'''\n# r = BinaryTree('a')\n# print(r.getRootVal())\n# print(r.getLeftChild())\n# r.insertLeft('b')\n# print(r.getLeftChild())\n# print(r.getLeftChild().getRootVal())\n# r.insertRight('c')\n# print(r.getRightChild())\n# print(r.getRightChild().getRootVal())\n# r.getRightChild().setRootVal('hello')\n# print(r.getRightChild().getRootVal())\n\n"
        },
        {
          "name": "BubbleSort.py",
          "type": "blob",
          "size": 0.76953125,
          "content": "# Python 实现冒泡排序\ndef bubbleSort(alist):\n    for passnum in range(len(alist)-1, 0, -1):\n        for i in range(passnum):\n            if alist[i] > alist[i+1]:\n                alist[i], alist[i+1] = alist[i+1], alist[i]\n    return alist\n\nalist = [54,26,93,17,77,31,44,55,20]\nprint(bubbleSort(alist))\n\n# 改进的冒泡排序, 加入一个校验, 如果某次循环发现没有发生数值交换, 直接跳出循环\ndef modiBubbleSort(alist):\n    exchange = True\n    passnum = len(alist) - 1\n    while passnum >= 1 and exchange:\n        exchange = False\n        for i in range(passnum):\n            if alist[i] > alist[i+1]:\n                alist[i], alist[i+1] = alist[i+1], alist[i]\n                exchange = True\n        passnum -= 1\n    return alist\n\nprint(bubbleSort(alist))"
        },
        {
          "name": "CheckErrorWord.py",
          "type": "blob",
          "size": 1.455078125,
          "content": "# 网传鹅厂面试题,英语单词拼写检查算法\n# 比如输入hello, 却错误的输入了hellu, 找出出错的字母\n# 感谢知乎知友@Lee Shellay\n\n# 对词典中的每个词, 逐刺逐字母拓展Trie, 单词完结处结点用END符号标识\nEND = '$'\n\ndef make_trie(words):\n    trie = {}\n    for word in words:\n        t = trie\n        for c in word:\n            if c not in t:\n                t[c] = {}\n            t = t[c]\n        t[END] = {}\n    return trie\n\n# 容错查找\n# 实质上是对Trie的深度优先搜索,每一步加深时就消耗目标词的一个字母\n# 当搜索到达某个结点时,分为不消耗容错数和消耗容错数的的情形,继续搜索知道目标词为空。\n# 搜索过程中,用path记录搜索路径,该路径及为一个词典中存在的词,作为纠错的参考\n# 最终结果即为诸多搜索停止位置的结点路径的并集\ndef check_fuzzy(trie, word, path='', tol=1):    #tol为容错数\n    if word == '':\n        return [path] if END in trie else []\n    else:\n        p0 = []\n        if word[0] in trie:\n            p0 = check_fuzzy(trie[word[0]], word[1:], path+word[0], tol)\n        p1 = []\n        if tol > 0:\n            for k in trie:\n                if k != word[0]:\n                    p1.extend(check_fuzzy(trie[k], word[1:], path+k, tol-1))\n        return p0 + p1\n\n\n# 测试代码\nwords = ['hello', 'hela', 'dome']\nt = make_trie(words)\nprint(t)\nprint(check_fuzzy(t, 'hellu'))\nprint(check_fuzzy(t, 'healu', tol=2))"
        },
        {
          "name": "Dynamic Programming.py",
          "type": "blob",
          "size": 1.587890625,
          "content": "# 解决动态规划中的找零问题\n# 输入需要找零的金额和货币的币值向量\n# 输出满足找零条件的最少的硬币个数\ndef ChangeMaking(coinVal, change):\n    alist = [0]*(change+1)\n    for i in range(1, change+1):\n        temp = change; j = 0\n        while j <= len(coinVal)-1 and i >= coinVal[j]:\n            temp = min(alist[i-coinVal[j]], temp)\n            j += 1\n        alist[i] = temp + 1\n    return alist.pop()\n\nprint(ChangeMaking([1, 5, 10, 25], 63))\n\n# 解决动态规划中的币值最大化问题---在满足所选硬币不相邻的条件下,从一堆硬币中选择最大金额的硬币\n# 输入数组C[1..n]保存n个硬币的面值\n# 输出可选硬币的最大金额\ndef coinRow(coinrow):\n    alist = [0]*(len(coinrow)+1)\n    alist[1] = coinrow[0]\n    for i in range(2, len(coinrow)+1):\n        alist[i] = max(coinrow[i-1]+alist[i-2], alist[i-1])\n    return alist.pop()\n\nprint(coinRow([5, 1, 2, 10, 6, 2]))\n\n# 解决0-1背包问题\ndef maxBag(weight, value, totalWeight):\n    if len(weight) <= 0 or len(value) <= 0 or totalWeight <= 0 or len(weight) != len(value):\n        return\n    num = len(weight)\n    tempMat = []\n    for i in range(num+1):\n        tempMat.append([0]*(totalWeight+1))\n    for i in range(1, num+1):\n        for j in range(1, totalWeight+1):\n            if j - weight[i-1] >= 0:\n                tempMat[i][j] = max(tempMat[i-1][j], value[i-1] + tempMat[i-1][j-weight[i-1]])\n            else:\n                tempMat[i][j] = tempMat[i-1][j]\n    return tempMat[-1][-1]\n\nweight, value, totalWeight = [2,1,3,2], [12,10,20,15], 5\nprint(maxBag(weight, value, totalWeight))"
        },
        {
          "name": "Hash.py",
          "type": "blob",
          "size": 3.06640625,
          "content": "# 用Python实现hash表\n# hash的查找操作时间复杂度O(1)\n# hash每个位置被称为slot槽。可以使用list实现hash,每个slot对应一个key,存放元素\n\n# 按照正常的字母在ASCII中的顺序mod tablesize构造hash\ndef hash(astring, tablesize):\n    sum = 0\n    for pos in astring:\n        sum = sum + ord(pos)\n\n    return sum%tablesize\n\nprint(hash('cat', 11))  # cat在hash中的位置,hash table长度11\n\n# 改进hash, 让每一位的字母乘以该字母在字串中的位置然后mod\ndef hash2(astring, tablesize):\n    sum = 0\n    for pos in range(len(astring)):\n        sum += (pos+1) * ord(astring[pos])\n    return sum%tablesize\n\nprint(hash2('cat', 11))\n\n# 冲突解决:分离链--冲突位置排成一个链; linear probing发生冲突去下一个位置\n\nclass HashTable:\n    def __init__(self):\n        self.size = 11\n        self.slots = [None] * self.size\n        self.data = [None] * self.size\n\n    def put(self, key, data):\n        hashvalue = self.hashfunction(key, self.size)\n\n        if self.slots[hashvalue] == None:\n            self.slots[hashvalue] = key\n            self.data[hashvalue] = data\n        else:\n            if self.slots[hashvalue] == key:\n                self.data[hashvalue] = data         # 替换相同索引对应的项目\n            else:\n                if None not in self.slots and key not in self.slots:\n                    # 判断hash是否已经满了, 必须添加key not in self.slots, 否则修改已有hash值会直接返回-1\n                    print('sorry, there is not enough slots for you!')\n                    return -1\n                nextslot = self.rehash(hashvalue, len(self.slots))\n                while self.slots[nextslot] != None and self.slots[nextslot] != key:\n                    nextslot = self.rehash(nextslot, len(self.slots))\n\n                if self.slots[nextslot] == None:\n                    self.slots[nextslot] = key\n                    self.data[nextslot] = data\n                else:\n                    self.data[nextslot] = data\n\n    def hashfunction(self, key, size):\n        return key%size\n\n    def rehash(self, oldhash, size):\n        return (oldhash+1)%size\n\n    def get(self, key):\n        startslot = self.hashfunction(key, len(self.slots))\n\n        data = None\n        stop = False\n        found = False\n        position = startslot\n        while self.slots[position] != None and not found and not stop:\n            if self.slots[position] == key:\n                found = True\n                data = self.data[position]\n            else:\n                position = self.rehash(position, len(self.slots))\n                if position == startslot:\n                    stop = True\n        return data\n\n    def __getitem__(self, key):\n        return self.get(key)\n\n    def __setitem__(self, key, data):\n        self.put(key, data)\n\nH = HashTable()\nH[54] = 'cat'\nH[26] = \"dog\"\nH[93] = \"lion\"\nH[17] = \"tiger\"\nH[77] = \"bird\"\nH[31] = \"cow\"\nH[44] = \"goat\"\nH[55] = \"pig\"\nH[20] = \"chicken\"\nprint(H[20])\nprint(H.slots)\nprint(H.data)\nprint(H[99])\nH[21] = \"elephant\"\nH[22] = \"sheep\"\nH[23] = \"fish\"\nprint(H.data)\nH[20] = 'monkey'\nprint(H.data)"
        },
        {
          "name": "InsertionSort.py",
          "type": "blob",
          "size": 0.6513671875,
          "content": "def insertionSort(alist):\n    for key, item in enumerate(alist):\n        index = key\n        while index > 0 and alist[index-1] > item:\n            alist[index] = alist[index-1]\n            index -= 1\n        alist[index] = item\n    return alist\n\nalist = [54,26,93,17,77,31,44,55,20]\nprint(insertionSort(alist))\n\ndef insertionSort2(alist):\n    for index in range(1, len(alist)):\n        currentvalue = alist[index]\n        position = index\n\n        while position > 0 and alist[position-1] > currentvalue:\n            alist[position] = alist[position-1]\n            position -= 1\n        alist[position] = currentvalue\n\n    return alist\n\nprint(insertionSort2(alist))\n"
        },
        {
          "name": "Lists.py",
          "type": "blob",
          "size": 1.67578125,
          "content": "class Node:\n    def __init__(self, initdata):\n        self.data = initdata\n        self.next = None\n\n    def getData(self):\n        return self.data\n\n    def getNext(self):\n        return self.next\n\n    def setData(self, newdata):\n        self.next = newdata\n\n    def setNext(self, nextNode):\n        self.next = nextNode\n\n\ntemp = Node(93)\ntemp.setData(10)\nprint(temp.getNext())\n\n# 定义一个无序链表\nclass UnorderedList:\n    def __init__(self):\n        self.head = None\n\n    def isEmpty(self):\n        return self.head == None\n\n    def add(self, item):\n        temp = Node(item)\n        temp.setNext(self.head)\n        self.head = temp\n\n    def size(self):\n        current = self.head\n        count = 0\n        while current != None:\n            count += 1\n            current = current.getNext()\n        return count\n\n    def search(self, item):\n        current = self.head\n        found = False\n        while current != None and not found:\n            if current.getData() == item:\n                found = True\n            else:\n                current = current.getNext()\n        return found\n\n    def remove(self, item):\n        current = self.head\n        previous = None\n        found = False\n        while not found:\n            if current.getData() == item:\n                found = True\n            else:\n                previous = current\n                current = current.getNext()\n\n        if previous == None:\n            self.head = current.getNext()\n        else:\n            previous.setNext(current.getNext())\n\nmyList = UnorderedList()\nmyList.add(31)\nmyList.add(77)\nmyList.add(17)\nmyList.add(93)\nmyList.add(26)\nmyList.add(54)\nprint(myList.search(17))\nmyList.remove(54)\nprint(myList.search(54))"
        },
        {
          "name": "Logistic regression",
          "type": "tree",
          "content": null
        },
        {
          "name": "MapReduce_and_filter.py",
          "type": "blob",
          "size": 1.0869140625,
          "content": "# -*- coding:UTF-8 -*-\nimport functools\n# Python3.x和Python2.x对于map、reduce、filter的处理变得不同\n# Python3.x中map和filter的输出是一个map型和filter型, 需要从里面取出需要的值\n# Python2.x中map和filter输出的直接是一个list\n# Python3.x中使用reduce需要引入functools\n\n# 使用map把list中的int变为str\nmap(str, [1, 2, 3, 4, 5, 6, 7, 8, 9])\n# 使用map()把名字规范化, 首字母大写,其余小写\ndef standardName(s):\n    return s.capitalize()\nprint([x for x in map(standardName, ['adam', 'LISA', 'barT'])])\n# 在Python2.x中应该使用print(map(standardName, ['adam', 'LISA', 'barT']))\n\n# 使用reduce()输出一个list的所有数的乘积\ndef prod(aList):\n    return functools.reduce(lambda x, y: x*y, aList)\nprint(prod([1, 2, 3, 4, 5]))\n\n# 使用filter()打印100以内的素数\ndef isPrime(n):\n    isPrimeFlag = True\n    if n <= 1:\n        isPrimeFlag = False\n    i = 2\n\n    while i * i <= n:\n        if n % i == 0:\n            isPrimeFlag = False\n            break\n        i += 1\n    return n if isPrimeFlag else None\nprint(filter(isPrime, range(101)))"
        },
        {
          "name": "MergeSort.py",
          "type": "blob",
          "size": 0.748046875,
          "content": "def mergeSort(alist):\n    if len(alist) > 1:\n        mid = len(alist)//2\n        lefthalf = alist[:mid]\n        righthalf = alist[mid:]\n\n        mergeSort(lefthalf)\n        mergeSort(righthalf)\n\n        i = 0; j = 0; k = 0\n        while i < len(lefthalf) and j < len(righthalf):\n            if lefthalf[i] < righthalf[j]:\n                alist[k] = lefthalf[i]\n                i += 1\n            else:\n                alist[k] = righthalf[j]\n                j += 1\n            k += 1\n\n        while i < len(lefthalf):\n            alist[k] = lefthalf[i]\n            i += 1\n            k += 1\n        while j < len(righthalf):\n            alist[k] = righthalf[j]\n            j += 1\n            k += 1\n\nalist = [54,26,93,17,77,31,44,55,20]\nmergeSort(alist)\nprint(alist)"
        },
        {
          "name": "ParseTree.py",
          "type": "blob",
          "size": 2.650390625,
          "content": "'''\n构造一棵解析树\n需要调用之前写过的Stack文件和BinaryTree文件\n'''\n\nfrom Stack import Stack\nfrom BinaryTree import BinaryTree\nimport operator\n\n# 构造解析树\ndef buildParseTree(fpexp):\n    fplist = fpexp.split()\n    pStack = Stack()\n    eTree = BinaryTree('')\n    pStack.push(eTree)\n    currentTree = eTree\n    for i in fplist:\n        if i == '(':\n            currentTree.insertLeft('')\n            pStack.push(currentTree)\n            currentTree = currentTree.getLeftChild()\n        elif i not in ['+', '-', '*', '/', ')']:\n            currentTree.setRootVal(int(i))\n            parent = pStack.pop()\n            currentTree = parent\n        elif i in ['+', '-', '*', '/']:\n            currentTree.setRootVal(i)\n            currentTree.insertRight('')\n            pStack.push(currentTree)\n            currentTree = currentTree.getRightChild()\n        elif i == ')':\n            currentTree = pStack.pop()\n        else:\n            raise ValueError\n    return eTree\n\n# 递归实现两个叶结点的运算\ndef evaluate(parseTree):\n    opers = {'+':operator.add, '-':operator.sub, '*':operator.mul, '/':operator.truediv}\n\n    leftC = parseTree.getLeftChild()\n    rightC = parseTree.getRightChild()\n\n    if leftC and rightC:\n        fn = opers[parseTree.getRootVal()]\n        return fn(evaluate(leftC), evaluate(rightC))\n    else:\n        return parseTree.getRootVal()\n\n# 递归实现树的后序遍历\ndef postorder(tree):\n    if tree != None:\n        postorder(tree.getLeftChild())\n        postorder(tree.getRightChild())\n        print(tree.getRootVal())\n\n# 利用后序遍历实现两个叶结点的运算\ndef postordereval(tree):\n    opers = {'+': operator.add, '-': operator.sub, '*': operator.mul, '/': operator.truediv}\n    res1 = None\n    res2 = None\n    if tree:\n        res1 = postordereval(tree.getLeftChild())\n        res2 = postordereval(tree.getRightChild())\n        if res1 and res2:\n            return opers[tree.getRootVal()](res1, res2)\n        else:\n            return tree.getRootVal()\n\n# 递归实现中序遍历\ndef inorder(tree):\n    if tree != None:\n        inorder(tree.getLeftChild())\n        print(tree.getRootVal())\n        inorder(tree.getRightChild())\n\n# 因为中序遍历会丢失括号信息, 因此尝试构造一个函数回复解析表达式\ndef printexp(tree):\n    sVal = ''\n    if tree:\n        sVal = '(' + printexp(tree.getLeftChild())\n        sVal = sVal + str(tree.getRootVal())\n        sVal = sVal + printexp(tree.getRightChild()) + ')'\n    return sVal\n\n\npt = buildParseTree(\"( ( 10 + 5 ) * 3 )\")\n# pt.preorder()\n# postorder(pt)\n# ans = evaluate(pt)\n# print(ans)\n# print(postordereval(pt))\n# inorder(pt)\n# print(pt)\nsVal = printexp(pt)\nprint(sVal)"
        },
        {
          "name": "Queue.py",
          "type": "blob",
          "size": 1.5712890625,
          "content": "class Queue:\n    def __init__(self):\n        self.items = []\n\n    def isEmpty(self):\n        return self.items == []\n\n    def enqueue(self, item):\n        self.items.insert(0, item)\n\n    def dequeue(self):\n        return self.items.pop()\n\n    def size(self):\n        return len(self.items)\n\nq = Queue()\nq.enqueue(4)\nq.enqueue('god')\nq.enqueue(True)\nprint(q.dequeue())\n\ndef hotPotato(namelist, num):\n    simqueue = Queue()\n    for name in namelist:\n        simqueue.enqueue(name)\n\n    while simqueue.size() > 1:\n        for i in range(num):\n            simqueue.enqueue(simqueue.dequeue())\n        simqueue.dequeue()\n\n    return simqueue.dequeue()\n\nprint(hotPotato([\"Bill\",\"David\",\"Susan\",\"Jane\",\"Kent\",\"Brad\"],7))\n\n# 设计一个良策都能插入删除的队列deque\nclass Deque:\n    def __init__(self):\n        self.items = []\n\n    def isEmpty(self):\n        return self.items == []\n\n    def addRear(self, item):\n        self.items.insert(0, item)\n\n    def addFront(self, item):\n        self.items.append(item)\n\n    def removeFront(self):\n        return self.items.pop()\n\n    def removeRear(self):\n        return self.items.pop(0)\n\n    def size(self):\n        return len(self.items)\n\n# 利用Deque解决回文字符串\ndef palcheker(aString):\n    chardeque = Deque()\n\n    for ch in aString:\n        chardeque.addFront(ch)\n\n    stillEqual = True\n\n    while chardeque.size() > 1 and stillEqual:\n        first = chardeque.removeFront()\n        last = chardeque.removeRear()\n        if first != last:\n            stillEqual = False\n\n    return stillEqual\n\nprint(palcheker('lsdkjfskf'))\nprint(palcheker('radar'))"
        },
        {
          "name": "QuickSort.py",
          "type": "blob",
          "size": 1.234375,
          "content": "# coding: utf-8\n\ndef quickSort(alist):\n    quickSortHelper(alist, 0, len(alist)-1)\n\ndef quickSortHelper(alist, first, last):\n    if first < last:\n        splitPoint = partition(alist, first, last)\n\n        quickSortHelper(alist, first, splitPoint-1)\n        quickSortHelper(alist, splitPoint+1, last)\n\ndef partition(alist, first, last):\n    pivotvlue = alist[first]\n\n    leftmark = first+1\n    rightmark = last\n    done = False\n\n    while not done:\n        while leftmark <= rightmark and alist[leftmark] <= pivotvlue: # bugfix: 先比较index, 不然数组会越界\n            leftmark += 1\n        while rightmark >= leftmark and alist[rightmark] >= pivotvlue:\n            rightmark -= 1\n\n        if leftmark > rightmark:\n            done = True\n        else:\n            alist[leftmark], alist[rightmark] = alist[rightmark], alist[leftmark]\n    alist[rightmark], alist[first] = alist[first], alist[rightmark]\n    return rightmark\n\nalist = [54,26,93,17,77,31,44,55,20]\nalist2 = [1]\nquickSort(alist2)\nprint(alist2)\n\n\nif __name__ == \"__main__\":\n    test_data = [3,2,111,3,-1,0,0,1,0,2,4]\n\n    res_stable = sorted(test_data)\n    quickSort(test_data)\n    print(test_data)\n    print(res_stable)\n    assert all(map(lambda x: x[0] == x[1], zip(res_stable, test_data)))"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 46.7578125,
          "content": "# 尝试用Python实现一些简单的算法和数据结构\n之前的算法和数据结构基本都是用Swift写的，现在尝试用Python实现一些简单的算法和数据结构。\n\n## update 20160704\n准备加入[《剑指offer》](https://www.amazon.cn/%E5%9B%BE%E4%B9%A6/dp/B00L5LKMVU?ie=UTF8&*Version*=1&*entries*=0)的习题python实现,以及机器学习过程中的一些算法\n\n## update 20160717\n加入leetcode部分\n\n~~## update 20160730~~\n## update 20160814\n整理\n\n如果对你有帮助，请记得点击github工程上的star，^_^ 现在总结如下：\n\n[数据结构markdown格式](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.md)\n\n[链表及常见操作](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Lists.py)\n\n[平衡查找树AVL](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/AVL.py)\n\n[三种方法检测变位词Anagram](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/AnagramDetection.py)\n\n[构建堆](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/BinaryHeap.py)\n\n[二分查找](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/BinarySearch.py)\n\n[二叉查找树](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/BinarySearchTree.py)\n\n[二叉树](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/BinaryTree.py)\n\n[冒泡排序](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/BubbleSort.py)\n\n[英语单词拼写检查算法](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/CheckErrorWord.py)\n\n[几个小的动态规划问题](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Dynamic%20Programming.py)\n\n[Hash及常见操作](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Hash.py)\n\n[插入排序](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/InsertionSort.py)\n\n[归并排序](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/MergeSort.py)\n\n[解析树ParseTree](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/ParseTree.py)\n\n[队列](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Queue.py)\n\n[快排](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/QuickSort.py)\n\n[基数排序](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/RadixSort.py)\n\n[一些递归算法](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Recursion.py)\n\n[选择排序](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/SelectionSort.py)\n\n[希尔排序](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/ShellSort.py)\n\n[栈及常见应用](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Stack.py)\n\n[分治算法](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/divideAndConquer.py)\n\n[堆排序](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/heapSort.py)\n\n[正则表达式和一个使用正则表达式的图片爬虫](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/tree/master/regularExpression)\n\n[剑指offer](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/tree/master/Target%20Offer)\n\n[面试题2：实现Singleton模式](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/Singleton.py)\n\n[面试题3：二维数组中的查找](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%9F%A5%E6%89%BE.py)：对于在一个每一行从左到右依次递增，每一列从上到下依次递增的二维数组查找一个元素，可以选择从数组左上角开始查找array[i]\\[j]，如果目标元素大于array[i]\\[j]，i+=1，如果元素小于array[i]\\[j]，j-=1，依次循环直至找到这个数。\n\n[面试题4：替换空格](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC.py)：如果直接每次遇到空格添加'%20'，那么空格后面的数字就需要频繁向后移动。遇到这种移动问题，我们可以尝试先给出最终需要的长度，然后从后向前扫描，同时给定两个指针来保证定位。**逆向思维**\n\n[面试题5：从头到尾打印链表](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E5%8F%8D%E5%90%91%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8.py)：从头到尾遍历链表，并用一个栈存储每个结点的值，之后出栈输出值即可。\n\n[面试题6：重建二叉树](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91.py)：利用二叉树前序遍历和中序遍历的特性。前序遍历的第一个值一定为根节点，对应于中序遍历中间的一个点。在中序遍历序列中，这个点左侧的均为根的左子树，这个点右侧的均为根的右子树。这时可以利用递归，分别取前序遍历[1:i+1]和中序遍历的[:i]对应与左子树继续上一个过程，取前序遍历[i+1:]和中序遍历[i+1]对应于右子树继续上一个过程，最终得以重建二叉树。\n\n[面试题7：用两个栈实现队列](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97.py)：需要两个栈Stack1和Stack2，push的时候直接push进Stack1。pop需要判断Stack1和Stack2中元素的情况，Stack1空的话，直接从Stack2 pop，Stack1不空的话，把Stack1的元素push进入Stack2，然后pop Stack2的值。[推广：用两个队列实现栈](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E7%94%A8%E4%B8%A4%E4%B8%AA%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88.py)\n\n[面试题8：旋转数组的最小数字](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97.py)：二分查找的变形，注意到旋转数组的首元素肯定不小于旋转数组的尾元素，设置中间点。如果中间点大于首元素，说明最小数字在后面一半，如果中间点小于尾元素，说明最小数字在前一半。依次循环。同时，当一次循环中首元素小于尾元素，说明最小值就是首元素。但是当首元素等于尾元素等于中间值，只能在这个区域顺序查找。\n\n[面试题9：斐波那契数列](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97.py)：如何不使用递归实现斐波那契数列，需要把前面两个数字存入在一个数组中。斐波那契数列的变形有很多，如青蛙跳台阶，一次跳一个或者两个；铺瓷砖问题。**变态青蛙跳**，每次至少跳一个，至多跳n个，一共有f(n)=2<sup>n-1</sup>种跳法。考察数学建模的能力。\n\n[面试题10：二进制中1的个数](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0.py)：注意到每个**非零**整数n和n-1进行按位与运算，整数n的二进制数中最右边的1就会变成0，那么二进制数中的1的个数就会减少一个，因此可以利用一个循环，使得 n = n&(n-1) ，计算经过几次运算减少到0，就是有几个1。注意：书中给了另外两种方法，分别是原始n左移一位和右移一位的方法，因为Python不会出现整数溢出的情况，这里就不再考虑着两种方法。扩展：判断一个数值是不是2得整数次方，如果是的话，这个数的二进制数中有且只有一个1，那么这个数n会有 n&(n-1) == 0。或者求两个整数m和n需要改变m二进制中的多少位才能得到n，可以先做 m^n 的异或运算，然后求这个数中有多少个1。\n\n[面试题11：数值的整数次方](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9.py)：如果采用常规解法，需要注意的地方:当指数为负数的时候；当底数为零且指数为负数的情况；在判断底数base是不是等于0的时候,不能直接写base==0, 因为计算机内表示小数时有误差,只能判断他们的差的绝对值是不是在一个很小的范围内。如果采用递归解法，当n为偶数, a<sup>n</sup> = a<sup>n/2</sup> * a<sup>n/2</sup>，当n为奇数, a<sup>n</sup> = a<sup>(n-1)/2</sup> * a<sup>(n-1)/2</sup> * a，利用右移一位代替除2运算，利用 &1 判断是否为奇数。同时需要注意**递归终止条件**，exponent = 1的话，return base，exponent = -1的话，return 1.0/base。再次提醒！必须写成 1.0/base，否则 1/base，返回一个integer 0！\n\n[面试题12：打印1到最大的n位数](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E6%89%93%E5%8D%B01%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0.py)：该题的要点是注意输入的n位数是否会导致溢出，因此利用字符串模拟整数的加法。**注意**：在打印函数中，需要判断打印的数字是否是以0开头的，同时判断条件是 num[i] != \"0\"，不能写作 num[i] != 0，因为是使用str类型的，后面一种写法导致判断无法成功。\n\n[面试题13：在O(1)时间删除链表结点](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E5%9C%A8O(1)%E6%97%B6%E9%97%B4%E5%86%85%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%BB%93%E7%82%B9.py)：当要删除的结点不是尾结点而且不是仅有一个结点的头结点，可以把该结点i的下一个结点j的内容复制到结点i，同时把i结点的next指向j结点的next，然后再删除结点j。如果要删除的链表为单结点链表且待删除的结点就是头结点，需要把头结点置为None，如果删除的结点为链表的尾结点，那么就需要顺序遍历链表，找到尾节点前面一个结点，然后将其next置空。\n\n[面试题14：调整数组顺序使奇数位于偶数前面](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2.py)：注重函数的扩展性能。把函数中的判断条件写成一个判断条件的函数，方便与函数的扩展。对于奇数位于偶数前面的情况，类似于快排，在头和尾分别设置一个指针，头指针指向奇数则后移，尾指针指向偶数则前移。\n\n[面试题15：链表中倒数第k个结点](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9.py)：代码的鲁棒性。需要注意：如果输入的链表为空；k大于链表的长度；k为0的情况。对于正常情况，设置两个指针分别指向头结点，第一个指针向前走**k-1步**，走到正数第k个结点，同时保持第二个指针不动，然后第一个指针和第二个指针每次同时前移一步，这样第一个指针指向尾结点的时候，第二个指针指向倒数第k个结点。判断尾结点的条件是 **pNode.next == None**。\n\n[面试题16：递归以及非递归实现反转链表](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.py)：需要注意三个问题：输入的链表头指针为None或者整个链表只有一个结点时，反转后的链表出现断裂，返回的翻转之后的头节点不是原始链表的尾结点。因此需要引入一个翻转后的头结点，以及一个指向当前结点的指针，一个指向当前结点前一个结点的指针，一个指向当前结点后一个结点的指针，防止出现断裂。推广：递归实现反转链表\n\n[面试题17：合并两个排序的链表](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8.py)：要注意特殊输入，如果输入是空链表，不能崩溃。\n\n[面试题18：树的子结构](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84.py):多出需要判断指针是不是None，避免访问空指针而造成程序崩溃。\n\n[面试题19：二叉树的镜像](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F.py)：需要判断输入的结点为空或者输入的结点没有子树的情况。\n\n[面试题20：顺时针打印矩阵](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5.py)：首先需要判断每一步开始是的坐标点是否满足小于行数的一半且小于列数的一半，在最后一圈中，可能出现仅能向右走一行，仅能向右走一行向下走一列，向右走一行向下走一列向左走一行，能走完整一圈，一共四种情况。其中只有能向左走一行必然发生，不必判断，剩余的都需要判断发生条件。\n\n[面试题21：包含min函数的栈](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88.py)：引入两个栈，一个栈每次push实际的数字，另一个minStack，如果push的数字小于minStack栈顶的数字，push新的数字，繁殖，把栈顶的数字再压入一遍。\n\n[面试题22：栈的压入、弹出序列](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97.py)：建立一个辅助栈，把push序列的数字依次压入辅助栈，每次压入后，比较辅助栈的栈顶元素和pop序列的首元素是否相等，相等的话就推出pop序列的首元素和辅助栈的栈顶元素，若最后辅助栈为空，则push序列可以对应于pop序列。\n\n[面试题23：从上往下打印二叉树](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91.py)：引入一个队列即可。推广：有向图的广度优先遍历也是基于队列的。\n\n[面试题24：二叉搜索树的后续遍历序列](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E7%BB%AD%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97.py)：根据后续遍历的性质，尾元素必定是树的根，同时小于尾元素的值是左子树，大于尾元素的值为右子树，且序列前半部分均小于尾元素，后半部分均大于尾元素（如果同时存在左右子树的话），可以将序列划分左子树序列和右子树序列，然后递归比较师妹每一段均满足此性质。可以减少递归深度的办法：某段的元素个数如果<=3，则返回True；某整段的最小元素不小于尾元素或者整段的最大元素不大于尾元素，说明仅有左子树或者右子树，返回True。\n\n[面试题25：二叉树中和为某一值的路径](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84.py)：递归\n\n[面试题26：复杂链表的复制](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6.py)：注意链表结点进行复制的时候，不能简单地写作 pCloned = pNode，这样的话之后对pCloned的操作也会作用在pNode上面，导致操作循环往复。需要重新定一个pCloned = ListNode(0)，然后对结点的.val  .next   .random 进行设置。同时，在将复制的结点的random指向原始链表结点的random的next的时候，需要先判断一下，原始链表结点的next是否为None，不为None再指向。\n\n[面试题27：二叉搜索树与双向链表](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.py):按照左右子树分治，递归实现。根的左边连接左子树的最右边结点，右边连接右子树的最左边结点。\n\n[面试题28：字符串的排列](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97%E5%92%8C%E7%BB%84%E5%90%88.py)：依次取一个元素，然后依次和之前递归形成的所有子串组合，形成新的字符串。[扩展：字符串的组合](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97%E5%92%8C%E7%BB%84%E5%90%88.py)\n\n[面试题29：数组中出现次数超过一半的数字](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97.py)：两种思路。第一种思路，出现次数超过一半的数字，不管如何，必然这个数字位于数组中间的位置，因此可以采用类似于快排的划分的方法，找到位于数组中间的位置的数字，然后在顺序检索是否这个数字出现次数超过一半。第二种思路根据数组的特点，出现次数超过一半的数，他出现的次数比其他数字出现的总和还要多，因此可以最开始保存两个数值：数组中的一个数字以及它出现的次数，然后遍历，如果下一个数字等于这个数字，那么次数加一，如果不等，次数减一，当次数等于0的时候，在下一个数字的时候重新复制新的数字以及出现的次数置为1，直到进行到最后，**然后再验证最后留下的数字是否出现次数超过一半**，因为可能前面的次数依次抵消掉，最后一个数字就直接是保留下来的数字，但是出现次数不一定超过一半。\n\n[面试题30：最小的k个数](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0.py)：两种方法。第一种方法是基于划分的方法，如果是查找第k个数字，第一次划分之后，划分的位置如果大于k，那么就在前面的子数组中进行继续划分，反之则在后面的子数组继续划分，时间复杂度O(n)；第二种方法是可以适用于**海量数据**的方法，该方法基于二叉树或者堆来实现，首先把数组前k个数字构建一个最大堆，然后从第k+1个数字开始遍历数组，如果遍历到的元素小于堆顶的数字，那么久将换两个数字，重新构造堆，继续遍历，最后剩下的堆就是最小的k个数，时间复杂度O(nlog k)。\n\n[面试题31：连续子数组的最大和](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C.py)：关键的问题在于成功分析整个过程。对于连续子数组，可以用一个数值来存储当前和，如果当前和小于零，那么在进行到下一个元素的时候，直接把当前和赋值为下一个元素，如果当前和大于零，则累加下一个元素，同时用一个maxNum存储最大值并随时更新。也可以利用动态规划解决。\n\n[面试题32：从1到n整数中1出现的次数](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0.py)：利用[数字规律](http://blog.csdn.net/u012505432/article/details/51889052)实现更为简单。\n\n[面试题33：把数组排成最小数](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0.py)：首先将数组中的数字全部转换为字符串存储在一个新的数组中，然后比较每两个数字串的拼接的mn和nm的大小，若mn<nm，则m更小，反之n更小，然后把更小的数放入一个新的List中，最后输出即可。使用冒泡排序很方便。\n\n[面试题34：丑数](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E4%B8%91%E6%95%B0.py)：空间换时间。建立一个长度为n的数组，保存这n个丑数。在进行运算的时候，某个位置需要求得丑数一定是前面某个丑数乘以2、3或者5的结果，我们分别记录之前乘以2后能得到的最大丑数M<sub>2</sub>，乘以3后能得到的最大丑数M<sub>3</sub>，乘以5后能得到的最大丑数M<sub>5</sub>，那么下一个丑数一定是M<sub>2</sub>，M<sub>3</sub>，M<sub>5</sub>中的最小的那一个。同时注意到，已有的丑数是按顺序存放在数组中的。对乘以2而言，肯定存在某一个丑数T<sub>2</sub>，排在他之前的每一个丑数乘以2得到的结果都会小于已有的最大丑数，在他之后的每一个丑数乘以2得到的结果都会太大，我们只需记下这个丑数的位置，每次生成新的丑数的时候，去更新这个T<sub>2</sub>。对于3和5同理。\n\n[面试题35：第一个只出现一次的字符](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6.py)：先遍历一遍字符串，用一个hash表存放每个出现的字符和字符出现的次数。再遍历一遍字符串，找到hash值等于1的输出即可。\n\n[面试题36：数组中的逆序对](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9.py)：这道题可以这么想，我们要找到数组中的逆序对，可以看做对数据进行排序，需要交换数组中的元素的次数，但是防止相同大小的元素发生交换，因此需要选择一个稳定的排序方法，记录发生交换的次数。那么，基于比较的稳定的排序方法中，最快的方法就是归并了，所以直接按照归并排序的思路，将数组分解、合并、排序即可。但是需要注意的是，在常规归并排序的时候，如果前一个元素大于后一个元素，直接进行交换即可，只进行了一次操作，但是对于这道题来讲，对于每一次的归并段，我们选择从后向前遍历，前面的归并段的某一个数值left[i]如果大于后面的某一个数值right[j]，因为在right自己独自排序的过程中，已经保证了right是有序的，所以j位置前面的数字全部小于right[j]，所以在这里逆序对的个数就会是 j-start-length，其中start是整个数组的起点，length是left的长度，然后再进行交换。\n\n[面试题37：两个链表的第一个公共结点](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9.py)：首先依次遍历两个链表，记录两个链表的长度m和n，如果 m > n，那么我们就先让长度为m的链表走m-n个结点，然后两个链表同时遍历，当遍历到相同的结点的时候停止即可。对于 m < n，同理。\n\n[面试题38：数字在排序数组中出现的次数](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E6%95%B0%E5%AD%97%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0.py)：二分查找的扩展。可以构造两个函数。第一个函数查找目标数字出现的最前面的位置，先使用二分查找找到该数字，如果该数字的index > 0而且该数字前面一个数字等于k的话，那么就令end=middle-1，继续二分查找。对于第二个函数，查找目标数字出现的最后面的位置，反之编写。最后如果**数字存在**的话，令走后面的index减去最前面的index然后+1即可。**在进行有序数组的元素查找，可以先尝试一下二分查找**\n\n[面试题39：二叉树的深度](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6.py)：利用递归实现。如果一棵树只有一个结点，那么它的深度为1。递归的时候无需判断左右子树是否存在，因为如果该节点为叶节点，它的左右子树不存在，那么在下一级递归的时候，直接return 0。同时，记得每次递归返回值的时候，深度加一操作。\n\n[面试题39：判断平衡二叉树](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E5%88%A4%E6%96%AD%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.py)：基于二叉树的深度，再次进行递归。以此判断左子树的高度和右子树的高度差是否大于1，若是则不平衡，反之平衡。\n\n[面试题40：数组中只出现一次的数字](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97.py)：**任何一个数字异或他自己都等于0**，**0异或任何一个数都等于那个数**。数组中出了两个数字之外，其他数字都出现两次，那么我们从头到尾依次异或数组中的每个数，那么出现两次的数字都在整个过程中被抵消掉，那两个不同的数字异或的值不为0，也就是说这两个数的异或值中至少某一位为1。我们找到结果数字中最右边为1的那一位i，然后一次遍历数组中的数字，如果数字的第i位为1，则数字分到第一组，数字的第i位不为1，则数字分到第二组。这样任何两个相同的数字就分到了一组，而两个不同的数字在第i位必然一个为1一个不为1而分到不同的组，然后再对两个组依次进行异或操作，最后每一组得到的结果对应的就是两个只出现一次的数字。\n\n[面试题41：和为s的两个数字](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97.py)：设定两个指针，一个指向数组的起点，一个指向数组的终点，然后对两个数字求和，如果和大于目标值，则把后一个指针前移，如果和小于目标值，则把前一个指针后移。两个指针交汇的时候如果还没找到，就终止操作。\n\n[面试题41：和为s的连续正数序列](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%95%B4%E6%95%B0%E5%BA%8F%E5%88%97.py)：设定两个指针，先分别指向数字1和数字2，并设这两个指针为small和big，对small和big求和，如果和大于目标值，则从当前和中删除small值，并把small值加一，如果和小于目标值，则把big值加一，再把新的big值加入和中。如果和等于目标值，就输出small到big的序列，同时把big加一并加入和中，继续之前的操作。\n\n[面试题42：翻转单词顺序](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F.py)：首先需要写一个reverse函数，把任何输入的字符串完全翻转。然后从前往后依次遍历新字符串，如果遇到空格，就把空格前的字符串用reverse翻转，添加空格，继续遍历。需要注意的是，如果新字符串结尾不是空格，当遍历到结尾的时候，前一个空格到结尾的字符串没有翻转，因此记得跳出遍历后，需要再完成一次翻转操作。\n\n[面试题42：左旋转字符串](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%B7%A6%E6%97%8B%E8%BD%AC.py)：首先需要写一个reverse函数，把任何输入的字符串完全翻转。然后根据题目中给出的左旋转字符串的个数n，用全字符串长度length减去旋转字符串个数n，求得对于新的字符串应该在哪一位进行旋转，然后分别旋转前[:length-n]子串和[length-n:]子串，重新拼接两个子串即可。\n\n[面试题43：n个骰子的点数](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/n%E4%B8%AA%E9%AA%B0%E5%AD%90%E7%9A%84%E7%82%B9%E6%95%B0.py)：用两个数组来存储骰子点数的每一个总数出现次数。在一次循环中，第一个数组中的第n个数字表示骰子和为n出现的次数。在下一次循环中加入一个新的骰子，此时和为n的骰子出现的次数应该等于上一次循环中骰子点数和为n-1，n-2，n-3，n-4，n-5，n-6的次数的总和，也就是把另一个数组的第n个数字对应上一个数组的n-1，n-2，n-3，n-4，n-5，n-6的次数的总和。同时需要注意的是，**每次使用新数组的时候，需要把数组所有位置清零**，因为我们对于第n位进行的累加操作，如果之前第n位有数字但不清零的话，会导致结果偏大。\n\n[面试题44：扑克牌的顺子](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E6%89%91%E5%85%8B%E7%89%8C%E7%9A%84%E9%A1%BA%E5%AD%90.py)：先置换特殊字符AJQK为数字，排序，然后求出大小王即0的个数，然后求出除去0之外的，数组间的数字间隔(求间隔的时候记得减去1，比如4和5的间隔为5-4-1，表示4和5是连续的数字)，同时求间隔的时候需要鉴别是否出现对。最后比较0的个数和间隔的大小即可。\n\n[面试题45：圆圈中剩下的数字](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF.py)：递推公式：f[i] = (f[i-1]+m)%i。[详解](http://blog.csdn.net/u012505432/article/details/51747181)\n\n[面试题46：求1+2+...+n](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E6%B1%82%E5%89%8Dn%E9%A1%B9%E5%92%8C.py)：利用两个函数，一个函数充当递归函数的角色，另一个函数处理终止递归的情况。如果对n连续进行两次反运算，那么非零的n转换为True，0转换为False。利用这一特性终止递归。注意考虑测试用例为0的情况。\n\n[面试题47：不用加减乘除做加法](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95.py)：将两个数的加法看作两步，第一步是两个数相加但是不进位，第二步是记录之前的两数相加应该进位的地方加上前一个相加但是不进位的数。对于具体的两个不小于0的数m和n，第一步可以看做m和n的异或运算m^n，第二步可以看做m和n的与运算然后左移一位得到实际的进位位置(m&n)<<1。然后把两个得到的数字加起来继续操作，指到carry进位为0终止操作。对于含有负数的情况，见[博文](http://blog.csdn.net/u012505432/article/details/51902155)。\n\n[面试题48：不能被继承的类(暂无)](https://github.com/Jack-Lee-Hiter)\n\n[面试题49：把字符串转换成整数](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0.py)：主要是区分输入和合法性，比如输入一个None，输入一个空字符串 \"\"，或者输入的字符串中含有“+”或者“-”，或者输入的字符串中含有除去+ — 数字的非数字字符，如何段应正常的输出还是报错，需要考虑的全面一些。\n\n[面试题50：树中两个节点的最低公共祖先](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E4%BD%8E%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.py)：首先来看比较简单的情况--[二叉搜索树的最低公共祖先](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E4%BD%8E%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.py)，对于二叉搜索树而言，每个节点的左子节点都小于这个数，右子节点都大于这个数，因此，我们比较当前节点和需要比较的结点m，n的大小，如果当前节点的值均大于m，n，则在当前节点的左子树继续操作，如果当前节点均小于m，n，则在当前节点的右子树继续操作，反之，则当前结点是最小公共祖先。而对于普通的二叉树而言，我们如果希望找到两个结点的最低公共祖先，那么我们可以先从树的根节点开始，找到根节点到结点m和结点n的路径，这时候我们就有两个List或者两个链表，然后就像前面题中遇到的寻找两个链表的公共结点一样，从后往前遍历两个List找到最靠后的第一个公共结点即可。\n\n[面试题51：数组中重复的数字](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97.py)：对于一个长度为n的数组里所有的数字都在0到n-1的范围内。查找重复数字的话，首先容易想到，对数组进行排序，然后遍历数组查找重复的数字，这样的时间复杂度为O(nlogn)；或者建立一个哈希表，这样实在O(n)的时间查找到，但是空间复杂度O(n)。另外一个空间复杂度为O(1)的算法如下，因为数字在0~n-1的范围内，那么如果数字没有重复，那么当数组排序之后数字i将出现在下标为i的位置，但是有重复的话，在某个位置j出现的数字将不是j。我们重排这个数组。从头到尾依次扫描这个数组中的每个数字，如果下标i不是出现数字i，那么就把数字i和i处的数字进行交换使数字i出现在应该出现的位置，如果新交换的数字还不是他应该出现的位置，继续交换，直至该处的数字m等于x下标m，如果在交换的过程中，第i处的位置数字等于第m处的数字，那么我们就找到了第一个重复的数字，记录这个数字，在从下一个位置继续扫描。\n\n[面试题52：构建乘积数组](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84.py)：作图画出一个n*n的矩阵，即可看出规律。注意需要得到的向量初始化的时候，初始化的值应该为1。\n\n[面试题53：正则表达式匹配](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D.py)：这道题的关键在于缕清思路。具体情况分析看一下代码中的注释。\n\n[面试题54：表示数值的字符串](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2.py)：这道题的关键也在于讨论清楚情况，把所有可能出现的情况都考虑到。需要注意的是，指数E后面必须跟一个整数，不能没有数，也不能为小数。\n\n[面试题55：字符流中第一个不重复的字符](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6.py)：引入两个辅助存储空间。一个Dict存储当前出现的字符以及字符出现的次数，一个List存储当前出现字符。然后每次比较List的第一个字符在Dict中对应的次数，如果为1则输出这个字符，如果不为1则弹出这个字符比较下一个字符。\n\n[面试题56：链表中环的入口结点](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9.py)：寻找链表中环的入口结点主要分成三个步骤：首先是设置两个快慢指针，如果快慢指针相遇，则快慢指针必然都在环中；然后从相遇的地方设置一个指针向后遍历并记录走的步数，当这个指针重新指到开始的位置的时候，当前对应的步数就是环中结点的数量k；然后设置两个指针从链表开始，第一个节点先走k步，然后第二个指针指到链表的开始，两个指针每次都向后走一步，两个指针相遇的位置就是链表的入口。\n\n[面试题57：删除链表中重复的结点](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E7%BB%93%E7%82%B9.py)：我们需要设置一个指针preNode，preNode最开始为None，然后设置两个指针，pNode指向当前节点，pNext指向pNode下一个结点，⓵如果pNext不为空而且pNext的值等于pNode的值，那么就说明出现了重复数字的结点，就需要删除，然后从pNode开始遍历，如果结点值等于前面那个重复值，继续遍历。当遍历到None或者不同值结点的时候，这时候需要判断preNode结点，如果preNode结点为None，就说明我们刚才的重复结点是从整个链表的头结点开始重复的，就直接把pHead设置为当前结点，pNode也设置为当前结点。反之，如果preNode不为None，直接把preNode的下一个指针指向当前节点，pNode指向preNode即可；⓶如果pNext为空或者pNext的值不等于pNode的值，说明当前的这个pNode和后面的值不重复，直接令preNode = pNode，pNode指向下一个结点即可。\n\n[面试题58：二叉树的下一个结点](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9.py)：三种情况：当前节点有右子树的话，当前节点的下一个结点是右子树中的最左子节点；当前节点无右子树但是是父节点的左子节点，下一个节点是当前结点的父节点；当前节点无右子树而且是父节点的右子节点，则一直向上遍历，直到找到最靠近的一个祖先节点pNode，pNode是其父节点的左子节点，那么输入节点的下一个结点就是pNode的父节点。\n\n[面试题59：对称的二叉树](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91.py)：分为递归和非递归的两种方式，思想是一样的。主要就是把叶子节点的None节点也加入到遍历当中。按照前序遍历二叉树，存入一个序列中。然后按照和前序遍历对应的先父节点，然后右子节点，最后左子节点遍历二叉树，存入一个序列。如果前后两个序列相等，那么说明二叉树是对称的。\n\n[面试题60：把二叉树打印成多行](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E6%88%90%E5%A4%9A%E8%A1%8C.py)：引入两个队列。首先把当前层的节点存入到一个队列queue1中，然后遍历当前队列queue1，在遍历的过程中，如果节点有左子树或右子树，依次存入另一个队列queue2。然后遍历队列queue2，如此往复。\n\n[面试题61：按之字形顺序打印二叉树](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E6%8C%89%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91.py)：按之字形顺序打印二叉树需要两个栈。我们在打印某一行节点时，拔下一层的子节点保存到相应的栈里。如果当前打印的奇数层，则先保存左子节点再保存右子节点到第一个栈里；如果当前打印的是偶数层，则先保存右子节点再保存左子节点到第二个栈里。\n\n[面试题62：序列化二叉树](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91.py)：最终要实现的是二叉树的序列化和反序列化。首先来看二叉树的序列化，二叉树的序列化就是采用前序遍历二叉树输出节点，再碰到左子节点或者右子节点为None的时候输出一个特殊字符\"#\"。对于反序列化，就是针对输入的一个序列构建一棵二叉树，我们可以设置一个指针先指向序列的最开始，然后把指针指向位置的数字转化为二叉树的结点，后移一个数字，继续转化为左子树和右子树。当遇到当前指向的字符为特殊字符\"#\"或者指针超出了序列的长度，则返回None，指针后移，继续遍历。\n\n[面试题63：二叉搜索树的第k个结点](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9.py)：中序遍历输出一个序列，然后找到序列中第k个数即可。\n\n[面试题64：数据流中的中位数](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0.py)：构建一个最大堆和一个最小堆，分别存储比中位数小的数和大的数。当目前两堆总数为偶数的时候，把数字存入最大堆，然后重排最大堆，如果最大堆的堆顶数字大于最小堆堆顶数字，则把两个堆顶数字交换，重排两堆，此时两堆数字总数为奇数，直接输出最大堆堆顶数字即为中位数；如果当前两堆总数为技术的时候，把数字存入最小堆，重排最小堆，如果最大堆的堆顶数字大于最小堆堆顶数字，则把两个堆顶数字交换，重排两堆，此时两堆数字总数为偶数，取两堆堆顶数字做平均即为中位数。\n\n[面试题65：滑动窗口的最大值](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC.py)：我们把可能成为滑动窗口的最大值的数值下标存入一个两端开口的队列index中。首先遍历输入数组，在遍历次数小于窗口长度的时候，如果index数组里面含有元素而且元素后面的下标值对应的输入数组的数如果小于当前遍历到的输入数组元素值，那么就把尾部的元素下标值不断pop出来，再压入当前输入元素对应的下标值。然后再从等于滑动窗口大小的位置继续遍历输入数组。首先把index数组的头元素下标值对应输入数组值压入输出数组。同样的，如果index数组里面含有元素而且元素后面的下标值对应的输入数组的数如果小于当前遍历到的输入数组元素值，那么就把尾部的元素下标值不断pop出来，同时，如果index数组内有元素，而且当一个数字的下标与当前处理的数字的下标只差大于或等于滑动窗口的大小时，这个数字已经从窗口中画出，可以从队列中删除了，再压入当前输入元素对应的下标值。**最后还需要在输出数组中append一下index手元素下标对应的输入元素值**。\n\n[面试题66：矩阵中的路径](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84.py)：回溯法。任选一个格子作为路径的起点。假设矩阵中某个格子的字符为ch并且这个格子将对应于路径上的第i个字符。如果路径上的第i个字符不是ch，那么这个格子不可能处在路径上的第i个位置。如果路径上的第i个字符正好是ch，那么往相邻的格子寻找路径上的第i+1个字符。除在矩阵边界上的格子外，其他各自都有4个相邻的格子。重复这个过程直到路径上的所有字符都在矩阵中找到相应的位置。\n\n[面试题67：机器人的运动范围](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4.py)：回溯法。类似于面试题66。把方格看成一个m*n的矩阵，从（0，0）开始移动。当准备进入坐标(i, j)是，通过检查坐标的数位来判断机器人能否进入。如果能进入的话，接着判断四个相邻的格子。\n\n[面试题补充：三元组实现稀疏矩阵相乘](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/multiSparse.py)\n\n[面试题补充：稀疏矩阵的转置](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/transSparseMatrix.py)\n\n[面试题补充：二叉搜索树的后续遍历](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E7%BB%AD%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97.py)\n\n[面试题补充：八皇后问题](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98.py)\n\n[面试题补充：分治法解决最近对问题](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E5%88%86%E6%B2%BB%E6%B3%95%E8%A7%A3%E5%86%B3%E6%9C%80%E8%BF%91%E5%AF%B9%E9%97%AE%E9%A2%98.py)\n\n[面试题补充：判断平衡二叉树](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E5%88%A4%E6%96%AD%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.py)\n\n[面试题补充：带锁的门](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E5%B8%A6%E9%94%81%E7%9A%84%E9%97%A8.py)\n\n[面试题补充：格雷码](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E6%A0%BC%E9%9B%B7%E7%A0%81.py)\n\n[面试题补充：正方体对面和相同](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E6%AD%A3%E6%96%B9%E4%BD%93%E5%AF%B9%E9%9D%A2%E5%92%8C%E7%9B%B8%E5%90%8C.py)\n\n[面试题补充：转换字符串格式](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E8%BD%AC%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F.py)\n\n[面试题补充：输出连续质数序列](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E8%BE%93%E5%87%BA%E8%BF%9E%E7%BB%AD%E8%B4%A8%E6%95%B0%E5%BA%8F%E5%88%97.py)\n\n[面试题补充：递归和非递归实现二叉搜索树的三种遍历](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E9%80%92%E5%BD%92%E5%92%8C%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86.py)\n\n[面试题补充：二叉树的宽度](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Target%20Offer/%E6%A0%91%E7%9A%84%E5%AE%BD%E5%BA%A6.py)\n\n[LeetCode](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/tree/master/leetcode)\n\n[logistic回归](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/tree/master/Logistic%20regression)\n\n[SVM](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/tree/master/SVM)\n"
        },
        {
          "name": "RadixSort.py",
          "type": "blob",
          "size": 0.8916015625,
          "content": "'''\n实现基数排序RadixSort, 分为:\n最高位优先(Most Significant Digit first)法\n最低位优先(Least Significant Digit first)法\n'''\n\n# 最低位优先法\ndef radixSortLSD(alist):\n    if len(alist) == 0:\n        return\n    if len(alist) == 1:\n        return alist\n    tempList = alist\n    maxNum = max(alist)\n    radix = 10\n    while maxNum * 10 > radix:\n        newArr = [[], [], [], [], [], [], [], [], [], []]\n        for n1 in tempList:\n            testnum = n1 % radix\n            testnum = testnum // (radix / 10)\n            for n2 in range(10):\n                if testnum == n2:\n                    newArr[n2].append(n1)\n        tempList = []\n        for i in range(len(newArr)):\n            for j in range(len(newArr[i])):\n                tempList.append(newArr[i][j])\n        radix *= 10\n    return tempList\n\n\n\nprint(radixSortLSD([10, 12, 24, 23, 13, 52, 15, 158, 74, 32, 254, 201, 30, 19]))\n"
        },
        {
          "name": "Recursion.py",
          "type": "blob",
          "size": 0.9052734375,
          "content": "# 递归求和\ndef listSum(numlist):\n    if len(numlist) == 1:\n        return numlist[0]\n    else:\n        return numlist[0] + listSum(numlist[1:])\n\nprint(listSum([1, 2, 3, 4, 5, 6, 7]))\n\n# 递归求阶乘\ndef listFactorial(num):\n    if num <= 1:\n        return 1\n    else:\n        return num * listFactorial(num-1)\n\nprint(listFactorial(10))\n\n# 递归实现进制转换:\ndef toStr(n,base):\n   convertString = \"0123456789ABCDEF\"\n   if n < base:\n      return convertString[n]\n   else:\n      return toStr(n//base, base) + convertString[n%base]\n\nprint(toStr(1453, 16))\n\n# 递归实现Hanoi塔\ndef Hanoi(fromPole, withPole, toPole, diskNum):\n    if diskNum <= 1:\n        print(\"moving disk from %s to %s\" % (fromPole, toPole))\n    else:\n        Hanoi(fromPole, toPole, withPole, diskNum-1)\n        print(\"moving disk from %s to %s\" % (fromPole, toPole))\n        Hanoi(withPole, fromPole, toPole, diskNum-1)\n\nHanoi('A', 'B', 'C', 3)\n"
        },
        {
          "name": "SVM",
          "type": "tree",
          "content": null
        },
        {
          "name": "SelectionSort.py",
          "type": "blob",
          "size": 0.33984375,
          "content": "# 选择排序, 纯粹练手 - -||\ndef selectionSort(alist):\n    for i in range(len(alist)-1):\n        min = i\n        for j in range(i+1, len(alist)):\n            if alist[j] < alist[min]:\n                min = j\n        alist[i], alist[min] = alist[min], alist[i]\n    return alist\n\nalist = [54,26,93,17,77,31,44,55,20]\nprint(selectionSort(alist))"
        },
        {
          "name": "ShellSort.py",
          "type": "blob",
          "size": 0.6640625,
          "content": "# python实现希尔排序\ndef shellSort(alist):\n    sublistcount= len(alist)//2\n    while sublistcount > 0:\n        for startposition in range(sublistcount):\n            gapInsertionSort(alist, startposition, sublistcount)\n        sublistcount = sublistcount//2\n    return alist\n\ndef gapInsertionSort(alist, start, gap):\n    for i in range(start+gap, len(alist), gap):\n        currentValue = alist[i]\n        position = i\n\n        while position >= gap and alist[position-gap] > currentValue:\n            alist[position] = alist[position-gap]\n            position = position-gap\n        alist[position] = currentValue\n\nalist = [54,26,93,17,77,31,44,55,20]\nprint(shellSort(alist))"
        },
        {
          "name": "Stack.py",
          "type": "blob",
          "size": 3.513671875,
          "content": "# Python3.5\n# 定义一个栈类\nclass Stack():\n    # 栈的初始化\n    def __init__(self):\n        self.items = []\n    # 判断栈是否为空,为空返回True\n    def isEmpty(self):\n        return self.items ==[]\n    # 向栈内压入一个元素\n    def push(self, item):\n        self.items.append(item)\n    # 从栈内推出最后一个元素\n    def pop(self):\n        return self.items.pop()\n    # 返回栈顶元素\n    def peek(self):\n        return self.items[len(self.items)-1]\n    # 判断栈的大小\n    def size(self):\n        return len(self.items)\n\n# 栈属性测试\n# 测试数据\n# s = Stack()\n# print(s.isEmpty())\n# s.push(4)\n# s.push('dog')\n# print(s.peek())\n# s.push(True)\n# print(s.isEmpty())\n# s.push(8.4)\n# print(s.pop())\n# print(s.pop())\n# print(s.size())\n\n# 利用栈将字串的字符反转\ndef revstring(mystr):\n    # your code here\n    s = Stack()\n    outputStr = ''\n    for c in mystr:\n        s.push(c)\n    while not s.isEmpty():\n        outputStr += s.pop()\n    return outputStr\n\n# print(revstring('apple'))\n# print(revstring('x'))\n# print(revstring('1234567890'))\n\n# 利用栈判断括号平衡Balanced parentheses\ndef parChecker(symbolString):\n    s = Stack()\n    balanced = True\n    index = 0\n    while index < len(symbolString) and balanced:\n        symbol = symbolString[index]\n        if symbol in '([{':\n            s.push(symbol)\n        else:\n            if s.isEmpty():\n                balanced = False\n            else:\n                top = s.pop()\n                if not matches(top, symbol):\n                    balanced = False\n        index += 1\n\n    if balanced and s.isEmpty():\n        return True\n    else:\n        return False\n\ndef matches(open, close):\n    opens = '([{'\n    closers = ')]}'\n    return opens.index(open) == closers.index(close)\n\n# print(parChecker('({([()])}){}'))\n\n# 利用栈将十进制整数转化为二进制整数\ndef Dec2Bin(decNumber):\n    s = Stack()\n\n    while decNumber > 0:\n        temp = decNumber % 2\n        s.push(temp)\n        decNumber = decNumber // 2\n    binString = ''\n    while not s.isEmpty():\n        binString += str(s.pop())\n    return binString\n\n# print(Dec2Bin(42))\n\n# 利用栈实现多进制转换\ndef baseConverter(decNumber, base):\n    digits = '0123456789ABCDEF'\n\n    s = Stack()\n\n    while decNumber > 0:\n        temp = decNumber % base\n        s.push(temp)\n        decNumber = decNumber // base\n\n    newString = ''\n    while not s.isEmpty():\n        newString = newString + digits[s.pop()]\n\n    return newString\n\n# print(baseConverter(59, 16))\n\n# 利用栈实现普通多项式的后缀表达式\ndef infixToPostfix(infixexpr):\n    prec = {}\n    prec['*'] = 3\n    prec['/'] = 3\n    prec['+'] = 2\n    prec['-'] = 2\n    prec['('] = 1\n    opStack = Stack()\n    postfixList = []\n    tokenList = infixexpr.split()\n\n    for token in tokenList:\n        if token in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' or token in '0123456789':\n            postfixList.append(token)\n        elif token == '(':\n            opStack.push(token)\n        elif token == ')':\n            topToken = opStack.pop()\n            while topToken != '(':\n                postfixList.append(topToken)\n                topToken = opStack.pop()\n        else:\n            while (not opStack.isEmpty()) and (prec[opStack.peek()] >= prec[token]):\n                postfixList.append(opStack.pop())\n            opStack.push(token)\n\n    while not opStack.isEmpty():\n        postfixList.append(opStack.pop())\n\n    return ''.join(postfixList)\n\n# print(infixToPostfix(\"A * B + C * D\"))\n# print(infixToPostfix(\"( A + B ) * C - ( D - E ) * ( F + G )\"))\n\n"
        },
        {
          "name": "Target Offer",
          "type": "tree",
          "content": null
        },
        {
          "name": "__pycache__",
          "type": "tree",
          "content": null
        },
        {
          "name": "divideAndConquer.py",
          "type": "blob",
          "size": 0.7705078125,
          "content": "'''\n分治算法一般都伴随着递归算法\n'''\n# 分治算法实现查找数组中的最大元素的位置\ndef maxIndex(alist, start, end):\n    if start > end or len(alist) == 0:\n        return\n    pivot = (start+end) >> 1\n    if end - start == 1:\n        return start\n    else:\n        temp1 = maxIndex(alist, start, pivot)\n        temp2 = maxIndex(alist, pivot, end)\n        if alist[temp1] < alist[temp2]:\n            return temp2\n        else:\n            return temp1\nprint(maxIndex([5,7,9,3,4,8,6,2,0,1], 0, 9))\n\n# 分治法计算正整数幂\ndef power(base, x):\n    if x == 1:\n        return base\n    else:\n        if x & 1 == 1:\n            return power(base, x>>1)*power(base, x>>1)*base\n        else:\n            return power(base, x>>1)*power(base, x>>1)\n\nprint(power(2, 6))"
        },
        {
          "name": "heapSort.py",
          "type": "blob",
          "size": 0.859375,
          "content": "def heapSort(alist):\n    if alist == None or len(alist) == 0:\n        return\n    length = len(alist)\n    output = []\n    for i in range(length):\n        tempLen = len(alist)\n        for j in range(tempLen//2-1, -1, -1):\n            preIndex = j\n            preVal, heap = alist[preIndex], False\n            while 2 * preIndex < tempLen - 1 and not heap:\n                curIndex = 2 * preIndex + 1\n                if curIndex < tempLen - 1:\n                    if alist[curIndex] < alist[curIndex+1]:\n                        curIndex += 1\n                if preVal >= alist[curIndex]:\n                    heap = True\n                else:\n                    alist[preIndex] = alist[curIndex]\n                    preIndex = curIndex\n            alist[preIndex] = preVal\n        output.insert(0, alist.pop(0))\n    return output\n\ntest = [2, 6, 5, 9, 10, 3, 7]\nprint(heapSort(test))\n"
        },
        {
          "name": "leetcode",
          "type": "tree",
          "content": null
        },
        {
          "name": "mysingleton.py",
          "type": "blob",
          "size": 0.1015625,
          "content": "# 单例模式\nclass My_Singleton(object):\n    def foo(self):\n        pass\nmy_singleton = My_Singleton()"
        },
        {
          "name": "regularExpression",
          "type": "tree",
          "content": null
        },
        {
          "name": "数据结构.md",
          "type": "blob",
          "size": 65.8037109375,
          "content": "# 数据结构\n## 一些概念\n> 数据结构就是研究数据的**逻辑结构**和**物理结构**以及它们之间**相互关系**，并对这种结构定义相应的运算，而且确保经过这些运算后所得到的新结构仍然是原来的结构类型。\n\n1. 数据：所有能被输入到计算机中，且能被计算机处理的符号的集合。是计算机操作的对象的总称。\n2. 数据元素：数据（集合）中的一个“个体”，数据及结构中讨论的**基本**单位\n3. 数据项：数据的不可分割的最小单位。一个数据元素可由若干个数据项组成。\n4. 数据类型：在一种程序设计语言中，变量所具有的数据种类。整型、浮点型、字符型等等\n\n1. 逻辑结构：数据之间的相互关系。\n\t* 集合 结构中的数据元素除了同属于一种类型外，别无其它关系。\n\t* 线性结构 数据元素之间一对一的关系\n\t* 树形结构 数据元素之间一对多的关系\n\t* 图状结构或网状结构 结构中的数据元素之间存在多对多的关系\n2. 物理结构/存储结构：数据在计算机中的表示。物理结构是描述数据具体在内存中的存储（如：顺序结构、链式结构、索引结构、哈希结构）等\n3. 在数据结构中,从逻辑上可以将其分为线性结构和非线性结构\n4. 数据结构的基本操作的设置的最重要的准则是,**实现应用程序与存储结构的独立**。实现应用程序是“逻辑结构”，存储的是“物理结构”。逻辑结构主要是对该结构操作的设定，物理结构是描述数据具体在内存中的存储（如：顺序结构、链式结构、索引结构、希哈结构）等。\n5. 顺序存储结构中，线性表的逻辑顺序和物理顺序总是一致的。但在链式存储结构中，线性表的逻辑顺序和物理顺序一般是不同的。\n\n1. 算法五个特性： 有穷性、确定性、可行性、输入、输出\n2. 算法设计要求：正确性、可读性、健壮性、高效率与低存储量需求。(好的算法)\n3. 算法的描述有伪程序、流程图、N-S结构图等。E-R图是实体联系模型，不是程序的描述方式。\n4. 设计算法在执行时间时需要考虑：算法选用的规模、问题的规模\n5. 时间复杂度：算法的执行时间与原操作**执行次数**之和成正比。时间复杂度有小到大：O(1)、O(logn)、O(n)、O(nlogn)、O(n<sup>2</sup>)、O(n<sup>3</sup>)。幂次时间复杂度有小到大O(2<sup>n</sup>)、O(n!)、O(n<sup>n</sup>)\n6. 空间复杂度：若输入数据所占空间只取决于问题本身，和算法无关，则只需要分析**除输入和程序之外的辅助变量所占额外空间**。\n\n## 线性表\n线性表是一种典型的线性结构。头结点无前驱有一个后继，尾节点无后继有一个前驱。链表只能顺序查找，定位一个元素的时间为O(N)，删除一个元素的时间为O(1)\n\n1. 线性表的顺序存储结构：把线性表的结点按逻辑顺序依次存放在一组地址连续的存储单元里。用这种方法存储的线性表简称顺序表。是一种随机存取的存储结构。顺序存储指内存地址是一块的，随机存取指访问时可以按下标随机访问，存储和存取是不一样的。如果是存储，则是指按顺序的，如果是存取，则是可以随机的，可以利用元素下标进行。数组比线性表速度更快的是：原地逆序、返回中间节点、选择随机节点。\n\t* 便于线性表的构造和任意元素的访问\n\t* 插入：插入新结点，之后结点后移。平均时间复杂度:O(n)\n\t* 删除：删除节点，之后结点前移。平均时间复杂度:O(n)\n2. 线性链表：用一组任意的存储单元来依次存放线性表的结点，这组存储单元即可以是连续的，也可以是不连续的，甚至是零散分布在内存中的任意位置上的。因此，链表中结点的逻辑次序和物理次序不一定相同。为了能正确表示结点间的逻辑关系，在存储每个结点值的同时，还必须存储指示其后继结点的地址。data域是数据域，用来存放结点的值。next是指针域（亦称链域），用来存放结点的直接后继的地址（或位置）。不需要事先估计存储空间大小。\n\t* **单链表**中每个结点的存储地址是存放在其前趋结点next域中，而开始结点无前趋，故应设头指针head指向开始结点。同时，由于最后一个结点无后继，故结点的指针域为空，即NULL。头插法建表(逆序)、尾插法建表(顺序)。增加头结点的目的是算法实现上的方便，但增大了内存开销。\n\t\t* 查找：只能从链表的头指针出发，顺链域next逐个结点往下搜索，直到搜索到第i个结点为止。因此，**链表不是随机存取结构**。\n\t\t* 插入：先找到表的第i-1的存储位置，然后插入。新结点先连后继，再连前驱。\n\t\t* 删除：首先找到a<sub>i-1</sub>的存储位置p。然后令p–>next指向a<sub>i</sub>的直接后继结点，即把a<sub>i</sub>从链上摘下。最后释放结点a<sub>i</sub>的空间.r=p->next;p->next=r->next;delete r。\n\t\t* 判断一个单向链表中是否存在环的最佳方法是快慢指针。\n\t* 静态链表：用一维数组来实现线性链表，这种用一维数组表示的线性链表，称为静态链表。静态：体现在表的容量是一定的。（数组的大小）；链表：插入与删除同前面所述的动态链表方法相同。静态链表中指针表示的是下一元素在数组中的位置。\n\t* 静态链表是用数组实现的，是顺序的存储结构，在物理地址上是连续的，而且需要预先分配大小。动态链表是用申请内存函数（C是malloc,C++是new）动态申请内存的，所以在链表的长度上没有限制。动态链表因为是动态申请内存的，所以每个节点的物理地址不连续，要通过指针来顺序访问。静态链表在插入、删除时也是通过修改指针域来实现的，与动态链表没有什么分别\n\t* 循环链表：是一种头尾相接的链表。其特点是无须增加存储量，仅对表的链接方式稍作改变，即可使得表处理更加方便灵活。\n\t\t* 在单链表中，将终端结点的指针域NULL改为指向表头结点的或开始结点，就得到了单链形式的循环链表，并简单称为**单循环链表**。由于循环链表中没有NULL指针，故涉及遍历操作时，其终止条件就不再像非循环链表那样判断p或p—>next是否为空，而是判断它们是否等于某一指定指针，如头指针或尾指针等。\n\t* 双向链表:在单链表的每个结点里再增加一个指向其直接前趋的指针域prior。这样就形成的链表中有两个方向不同的链。双链表一般由头指针唯一确定的，将头结点和尾结点链接起来构成循环链表，并称之为双向链表。设指针p指向某一结点，则双向链表结构的对称性可用下式描述：p—>prior—>next=p=p—>next—>prior。从两个方向搜索双链表，比从一个方向搜索双链表的方差要小。\n\t\t* 插入：先搞定插入节点的前驱和后继，再搞定后结点的前驱，最后搞定前结点的后继。\n\t\t* 在有序双向链表中定位删除一个元素的平均时间复杂度为O(n)\n\t\t* 可以直接删除当前指针所指向的节点。而不需要像单向链表中，删除一个元素必须找到其前驱。因此在插入数据时，单向链表和双向链表操作复杂度相同，而删除数据时，双向链表的性能优于单向链表\n\n## 栈和队列\n### 栈\n栈(Stack)是限制在表的一端进行插入和删除运算的线性表，通常称插入、删除的这一端为栈顶(Top)，另一端为栈底(Bottom)。先进后出。top= -1时为空栈，top=0只能说明栈中只有一个元素，并且元素进栈时top应该自增\n\n1. 顺序存储栈：顺序存储结构\n2. 链栈：链式存储结构。插入和删除操作仅限制在链头位置上进行。栈顶指针就是链表的头指针。通常不会出现栈满的情况。 不需要判断栈满但需要判断栈空。\n3. 两个栈共用静态存储空间,对头使用也存在空间溢出问题。栈1的底在v[1]，栈2的底在V[m]，则栈满的条件是top[1]+1=top[2]。\n4. 基本操作：删除栈顶元素、判断栈是否为空以及将栈置为空栈等\n5. 对于n各元素的入栈问题，可能的出栈顺序有C(2n,n)/(n+1)个。\n6. 堆栈溢出一般是循环的递归调用、大数据结构的局部变量导致的\n\n应用，[代码](https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/Stack.py)：\n\n1. 进制转换\n2. 括号匹配的检验\n3. 行编辑程序\n4. 迷宫求解：若当前位置“可通”，则纳入路径，继续前进;若当前位置“不可通”，则后退，换方向继续探索;若四周“均无通路”，则将当前位置从路径中删除出去。\n5. 表达式求解：前缀、中缀、后缀。\n\t* 操作数之间的相对次序不变;\n\t* 运算符的相对次序不同;\n\t* 中缀式丢失了括弧信息，致使运算的次序不确定\n\t* 前缀式的运算规则为:连续出现的两个操作数和在它们之前且紧靠它们的运算符构成一个最小表达式\n\t* 后缀式的运算规则为:运算符在式中出现的顺序恰为表达式的运算顺序;每个运算符和在它之前出现且紧靠它的两个操作数构成一个最小表达式。\n6. 实现递归：多个函数嵌套调用的规则是：后调用先返回。\n7. 浏览器历史纪录，Android中的最近任务，Activity的启动模式，CPU中栈的实现，Word自动保存，解析计算式，解析xml/json。解析XML时，需要校验节点是否闭合，节点闭合的话，有头尾符号相对应，遇到头符号将其放入栈中，遇到尾符号时，弹出栈的内容，看是否有与之对应的头符号，栈的特性刚好符合符号匹配的就近原则。\n\n不是所有的递归程序都需要栈来保护现场，比方说求阶乘的，是单向递归，直接用循环去替代从1乘到n就是结果了，另外一些需要栈保存的也可以用队列等来替代。不是所有的递归转化为非递归都要用到栈。转化为非递归主要有两种方法：对于尾递归或单向递归，可以用循环结构算法代替\n\n\n### 队列\n队列(Queue)也是一种运算受限的线性表。它只允许在表的一端进行插入，而在另一端进行删除。允许删除的一端称为队头(front)，允许插入的一端称为队尾(rear)。先进先出。\n\n1. 顺序队列：顺序存储结构。当头尾指针相等时队列为空。在非空队列里，头指针始终指向队头前一个位置，而尾指针始终指向队尾元素的实际位置\n2. 循环队列。在循环队列中进行出队、入队操作时，头尾指针仍要加1，朝前移动。只不过当头尾指针指向向量上界（MaxSize-1）时，其加1操作的结果是指向向量的下界0。除非向量空间真的被队列元素全部占用，否则不会上溢。因此，除一些简单的应用外，真正实用的顺序队列是循环队列。故队空和队满时头尾指针均相等。因此，我们无法通过front=rear来判断队列“空”还是“满”\n3. 链队列：链式存储结构。限制仅在表头删除和表尾插入的单链表。显然仅有单链表的头指针不便于在表尾做插入操作，为此再增加一个尾指针，指向链表的最后一个结点。\n4. 设尾指针的循环链表表示队列,则入队和出队算法的时间复杂度均为O(1)。用循环链表表示队列，必定有链表的头结点，入队操作在链表尾插入，直接插入在尾指针指向的节点后面，时间复杂度是常数级的；出队操作在链表表头进行，也就是删除表头指向的节点，时间复杂度也是常数级的。\n\n1. 队空条件：rear==front，但是一般需要引入新的标记来说明栈满还是栈空，比如每个位置布尔值\n2. 队满条件：(rear+1) % QueueSize==front，其中QueueSize为循环队列的最大长度\n3. 计算队列长度：（rear-front+QueueSize）% QueueSize\n4. 入队：（rear+1）% QueueSize\n5. 出队：（front+1）% QueueSize\n6. 假设以数组A[N]为容量存放循环队列的元素,其头指针是front,当前队列有X个元素,则队列的尾指针值为(front+X mod N)\n\n## 串\n串(String)是零个或多个字符组成的有限序列。长度为零的串称为**空串**(Empty String)，它不包含任何字符。通常将仅由一个或多个空格组成的串称为**空白串**(Blank String) 注意：空串和空白串的不同，例如“  ”和“”分别表示长度为1的空白串和长度为0的空串。\n\n串的表示和实现：\n\n1. 定长顺序存储表示。静态存储分配的顺序表。\n2. 堆分配存储表示。存储空间是在程序执行过程中动态分配而得。所以也称为动态存储分配的顺序表\n3. 串的链式存储结构。\n\n串匹配：将主串称为目标串，子串称之为模式串。蛮力法匹配。[KMP算法](http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html)匹配。[Boyer-Moore算法](https://github.com/Jack-Lee-Hiter/Introduction-to-The-Design-and-Analysis-of-Algorithms/blob/master/Boyer-Moore/BM%20by%20swift)匹配。\n\n## 数组和广义表\n数组和广义表可看成是一种特殊的线性表，其特殊在于: 表中的元素本身也是一种线性表。内存连续。根据下标在O(1)时间读/写任何元素。\n\n**二维数组，多维数组，广义表、树、图都属于非线性结构**\n\n### 数组\n数组的顺序存储：行优先顺序；列优先顺序。数组中的任一元素可以在相同的时间内存取，即顺序存储的数组是一个随机存取结构。\n\n关联数组(Associative Array)，又称映射（Map）、字典（ Dictionary）是一个抽象的数据结构，它包含着类似于(键，值)的有序对。 不是线性表。\n\n矩阵的压缩：\n\n1. 对称矩阵、三角矩阵：直接存储矩阵的上三角或者下三角元素。**注意区分i>=j和i<j的情况**\n2. 对角矩阵：除了主对角线和主对角线相邻两侧的若干条对角线上的元素之外，其余元素皆为零。\n3. 稀疏矩阵：非零元素个数远小于矩阵元素总数。三元组或十字链表，十字链表更适合矩阵的加法乘法等操作。\n\t* 三元组顺序表。三元组顺序表虽然节省了存储空间，但时间复杂度比一般矩阵转置的算法还要复杂，同时还有可能增加算法的难度。因此，此算法仅适用于t<<m*n的情况。\n\t* 稀疏矩阵在采用压缩存储后将会失去随机存储的功能。因为在这种矩阵中，非零元素的分布是没有规律的，为了压缩存储，就将每一个非零元素的值和它所在的行、列号做为一个结点存放在一起，这样的结点组成的线性表中叫三元组表，它已不是简单的向量，所以无法用下标直接存取矩阵中的元素。\n\t* 对于用三元组存储稀疏矩阵，每个元素要用行号,列号,元素值来表示,在用三元组表示稀疏矩阵,还要三个成员来记住矩阵的行数列数,总的元素数，即总共需要(非零元素个数)n+1个元素。\n\t* 三元组转置（1）将数组的行列值相互交换（2）将每个三元组的i和j相互交换（3）重排三元组的之间的次序便可实现矩阵的转置\n\n### 广义表\n广义表（Lists，又称列表）是线性表的推广。广义表是n(n≥0)个元素a<sup>1</sup>,a<sup>2</sup>,a<sup>3</sup>,…,a<sup>n</sup>的有限序列，其中a<sub>i</sub>或者是原子项，或者是一个广义表。若广义表LS（n>=1)非空，则a<sup>1</sup>是LS的表头，其余元素组成的表(a<sup>2</sup>,…a<sup>n</sup>)称为LS的表尾。广义表的元素可以是广义表，也可以是原子，广义表的元素也可以为空。表尾是指除去表头后剩下的元素组成的表，表头可以为表或单元素值。所以表尾不可以是单个元素值。\n\n例子：\n\n1. A=（）——A是一个空表，其长度为零。\n2. B=（e）——表B只有一个原子e，B的长度为1。\n3. C=（a,(b,c,d))——表C的长度为2，两个元素分别为原子a和子表(b,c,d)。\n4. D=（A，B，C）——表D的长度为3，三个元素都是广义 表。显然，将子表的值代入后，则有D=(( ),(e),(a,(b,c,d)))。\n5. E=（a,E）——这是一个递归的表，它的长度为2，E相当于一个无限的广义表E=(a,(a,(a,(a,…)))).\n\n三个结论：\n\n1. 广义表的元素可以是子表，而子表的元素还可以是子表。由此，广义表是一个多层次的结构，可以用图形象地表示\n2. 广义表可为其它表所共享。例如在上述例4中，广义表A，B，C为D的子表，则在D中可以不必列出子表的值，而是通过子表的名称来引用。\n3. 广义表的递归性\n\n考点：\n\n1. 广义表是0个或多个单因素或子表组成的有限序列，广义表可以是自身的子表，广义表的长度n>=0，所以可以为空表。广义表的**同级**元素(直属于同一个表中的各元素)具有**线性**关系\n2. 广义表的表头为空，并不代表该广义表为空表。广义表()和(())不同。前者是长度为0的空表，对其不能做求表头和表尾的运算；而后者是长度为l的非空表(只不过该表中惟一的一个元素是空表)，对其可进行分解，得到的表头和表尾均是空表()\n3. 已知广义表LS＝((a,b,c),(d,e,f)),运用head和tail函数取出LS中原子e的运算是head(tail(head(tail(LS)))。根据表头、表尾的定义可知：任何一个非空广义表的表头是表中第一个元素，它可以是原子，也可以是子表，而其**表尾必定是子表**。也就是说，广义表的head操作，取出的元素是什么，那么结果就是什么。但是tail操作取出的元素外必须加一个表——“（）“。tail(LS)＝((d,e,f))；head(tail(LS))=(d,e,f)；tail(head(tail(LS)))=(e,f)；head(tail(head(tail(LS))))=e。\n4. 二维以上的数组其实是一种特殊的广义表\n5. 在（非空）广义表中：1、表头head可以是原子或者一个表 2、表尾tail一定是一个表 3.广义表难以用顺序存储结构 4.广义表可以是一个多层次的结构\n\n## 树和二叉树\n一种**非线性**结构。树是递归结构，在树的定义中又用到了树的概念。\n\n基本术语：\n\n1. 树结点：包含一个数据元素及若干指向子树的分支；\n2. 孩子结点：结点的子树的根称为该结点的孩子；\n3. 双亲结点：B结点是A结点的孩子，则A结点是B结点的双亲；\n4. 兄弟结点：同一双亲的孩子结点；\n5. 堂兄结点：同一层上结点；\n6. 结点层次：根结点的层定义为1；根的孩子为第二层结点，依此类推；\n7. 树的高（深）度：树中最大的结点层\n8. 结点的度：结点子树的个数\n9. 树的度： 树中最大的结点度。\n10. 叶子结点：也叫终端结点，是度为0的结点；\n11. 分枝结点：度不为0的结点（非终端结点）；\n12. 森林：互不相交的树集合；\n13. 有序树：子树有序的树，如：家族树；\n14. 无序树：不考虑子树的顺序；\n\n### 二叉树\n二叉树可以为空。二叉树结点的子树要区分左子树和右子树，即使只有一棵子树也要进行区分，说明它是左子树，还是右子树。这是二叉树与树的最主要的差别。注意区分：二叉树、**二叉查找树/二叉排序树/二叉搜索树**、**二叉平衡(查找)树**\n\n**二叉平衡树肯定是一颗二叉排序树。堆不是一颗二叉平衡树。**\n\n**二叉树与树是不同的，二叉树不等价于分支树最多为二的有序树。当一个结点只包含一个子节点时，对于有序树并无左右孩子之分，而对于二叉树来说依然有左右孩子之分，所以二叉树与树是两种不同的结构。**\n\n性质：\n\n1. 在二叉树的第 i 层上至多有2<sup>i-1</sup>个结点。\n2. 深度为 k 的二叉树上至多含 2<sup>k</sup>-1 个结点（k≥1）\n3. 对任何一棵二叉树，若它含有n<sub>0</sub>个叶子结点、n<sub>2</sub>个度为 2 的结点，则必存在关系式：n<sub>0</sub>= n<sub>2</sub>+1。\n4. 具有 n 个结点的完全二叉树的深度为⎣log<sub>2</sub> n⎦+1 。\n5. n个结点的二叉树中，完全二叉树具有最小的路径长度。\n6. 如果对一棵有n个结点的完全二叉树的结点按层序编号,则对任一结点i（1<=i<=n),有：\n\t* 如果i＝1，则结点i无双亲，是二叉树的根；如果i>1，则其双亲的编号是 i/2(整除）。\n\t* 如果2i>n，无左孩子；否则，其左孩子是结点2i。\n\t* 如果2i＋1>n，则结点i无右孩子；否则，其右孩子是结点2i＋1。\n\n二叉树的存储结构\n\n1. 顺序存储结构：仅仅适用于满或完全二叉树，结点之间的层次关系由性质5确定。\n2. 二叉链表法：每个节点存储左子树和右子树。三叉链表：左子树、右子树、父节点，总的指针是n+2\n3. 在有n个结点的二叉链表中，值为非空的链域的个数为n-1。在有N个结点的二叉链表中必定有2N个链域。除根结点外，其余N-1个结点都有一个父结点。所以，一共有N-1个非空链域，其余2N-(N-1)=N+1个为空链域。\n4. 二叉链存储法也叫孩子兄弟法，左指针指向左孩子，右指针指向右兄弟。而中序遍历的顺序是左孩子，根，右孩子。这种遍历顺序与存储结构不同，因此需要堆栈保存中间结果。而中序遍历检索二叉树时，由于其存储结构跟遍历顺序相符，因此不需要用堆栈。\n\n#### **遍历二叉树和线索二叉树**\n\n遍历二叉树：使得每一个结点均被访问一次，而且仅被访问一次。非递归的遍历实现要利用栈。\n\n* 先序遍历DLR：根节点->左子树->右子树\n* 中序遍历LDR：左子树->根节点->右子树。必须要有中序遍历才能得到一棵二叉树的正确顺序\n* 后续遍历LRD：左子树->右子树->根节点。需要栈的支持。\n* 层次遍历：用一维数组存储二叉树时,总是以层次遍历的顺序存储结点。层次遍历应该借助队列。\n\n线索二叉树：对二叉树所有结点做某种处理可在遍历过程中实现；检索（查找）二叉树某个结点，可通过遍历实现；如果能将二叉树线索化，就可以简化遍历算法，提高遍历速度，目的是加快查找结点的前驱或后继的速度。\n\n如何线索化？以中序遍历为例，若能将中序序列中每个结点前趋、后继信息保存起来，以后再遍历二叉树时就可以根据所保存的结点前趋、后继信息对二叉树进行遍历。对于二叉树的线索化，实质上就是遍历一次二叉树，只是在遍历的过程中，检查当前结点左，右指针域是否为空，若为空，将它们改为指向前驱结点或后继结点的线索。**前驱就是在这一点之前走过的点，不是下一将要去往的点**。\n\n加上结点前趋后继信息（结索）的二叉树称为**线索二叉树**。n个结点的线索二叉树上每个结点有2个指针域（指向左孩子和右孩子），总共有2n个指针域；一个n个结点的树有n-1条边，那么空指针域= 2n - (n-1) = n + 1，即线索数为n+1。指针域tag为0，存放孩子指针，为1，存放前驱/后继节点指针。\n\n线索树下结点x的前驱与后继查找：设结点x相应的左（右）标志是线索标志，则lchild(rchild)就是前驱(后继），否则：\n\n* LDR--前驱：左子树中最靠右边的结点；后继：右子树中最靠左边的结点\n* LRD--前驱：右子树的根，若无右子树，为左子树跟。后继：x是根，后继是空；x是双亲的右孩子、x是双亲的左孩子，但双亲无右孩子，双亲是后继；x是双亲的左孩子，双亲有右孩子，双亲右子树中最左的叶子是后继\n* DLR--对称于LRD线索树---将LRD中所有左右互换，前驱与后继互换，得到DLR的方法。\n* 为简化线索链表的遍历算法，仿照线性链表，为线索链表加上一头结点，约定：\n\t* 头结点的lchild域：存放线索链表的根结点指针；\n\t* 头结点的rchild域: 中序序列最后一个结点的指针；\n\t* 中序序列第一结点lchild域指向头结点;\n\t* 中序序列最后一个结点的rchild域指向头结点;\n\n中序遍历的线索二叉树以及线索二叉树链表示意图\n![xiansuobinarytree](http://images.cnitblog.com/blog/311549/201309/13230006-d365a5866c094ee7b3897a1675d34716.jpg)\n\n一棵左右子树均不空的二叉树在前序线索化后,其中空的链域的个数是1。**前序和后续线索化后空链域个数都是1，中序是2**。二叉树在线索化后，仍不能有效求解的问题是前序求前序先驱，后序求后序后继。\n\n中序遍历的顺序为：左、根、右，所以对于每一非空的线索，左子树结点的后继为根结点，右子树结点的前驱为根结点，再递归的执行上面的过程，可得非空线索均指向其祖先结点。**在中序线索二叉树中,每一非空的线索均指向其祖先结点**。\n\n在二叉树上加上结点前趋、后继线索后，可利用线索对二叉树进行遍历,此时，**不需栈，也不需递归**。基本步骤：\n\n1. p=T->lchild; p指向线索链表的根结点；\n2. 若线索链表非空，循环：\n\t* 循环，顺着p左孩子指针找到最左下结点；访问之； \n\t* 若p所指结点的右孩子域为线索，p的右孩子结点即为后继结点循环： p=p->rchild； 并访问p所指结点；（在此循环中，顺着后继线索访问二叉树中的结点）\n\t* 一旦线索“中断”，p所指结点的右孩子域为右孩子指针，p=p->rchild，使 p指向右孩子结点；\n\n### 树和森林\n树的存储结构：\n\n1. 双亲表示法\n2. 孩子表示法\n3. 利用图表示树\n4. 孩子兄弟表示法（二叉树表示法）：链表中每个结点的两指针域分别指向其第一个孩子结点和下一个兄弟结点\n\n将树转化成二叉树：右子树一定为空\n\n1. 加线：在兄弟之间加一连线\n2. 抹线：对每个结点，除了其左孩子外，去除其与其余孩子之间的关系\n3. 旋转：以树的根结点为轴心，将整树顺时针转45°\n\n森林转换成二叉树：\n\n1. 将各棵树分别转换成二叉树\n2. 将每棵树的根结点用线相连\n3. 以第一棵树根结点为二叉树的根\n\n树与转换后的二叉树的关系：转换后的二叉树的先序对应树的先序遍历；转换后的二叉树的中序对应树的后序遍历\n\n### 哈弗曼树/霍夫曼树\n一些概念\n\n1. 路径：从一个祖先结点到子孙结点之间的分支构成这两个结点间的路径；\n2. 路径长度：路径上的分支数目称为路径长度；\n3. 树的路径长度：从根到每个结点的路径长度之和。\n4. 结点的权：根据应用的需要可以给树的结点赋权值；\n5. 结点的带权路径长度：从根到该结点的路径长度与该结点权的乘积；\n6. 树的带权路径长度=树中所有叶子结点的带权路径之和；通常记作  WPL=∑w<sub>i</sub>×l<sub>i</sub> \n7. 哈夫曼树：假设有n个权值(w<sub>1</sub>,  w<sub>2</sub>, … , w<sub>n</sub>)，构造有n个叶子结点的二叉树，每个叶子结点有一个 w<sub>i</sub>作为它的权值。则带权路径长度最小的二叉树称为哈夫曼树。最优二叉树。\n\n前缀码的定义：在一个字符集中，任何一个字符的编码都不是另一个字符编码的前缀。霍夫曼编码就是前缀码，可用于快速判断霍夫曼编码是否正确。霍夫曼树是满二叉树，若有n个节点，则共有(n+1)/2个码子\n\n给定n个权值作为n的叶子结点，构造一棵二叉树，若带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为霍夫曼树(Huffman Tree)。霍夫曼树是带权路径长度最短的树，权值较大的结点离根较近。\n\n假设哈夫曼树是二叉的话，则度为0的结点个数为N，度为2的结点个数为N-1，则结点总数为2N-1。哈夫曼树的结点个数必为奇数。\n\n哈夫曼树不一定是完全二叉树，但一定是最优二叉树。\n\n若度为m的哈夫曼树中,其叶结点个数为n,则非叶结点的个数为[(n-1)/(m-1)]。边的数目等于度。\n\n### 图遍历与回溯\n图搜索->形成搜索树\n\n1. 穷举法。\n2. 贪心法。多步决策，每步选择使得构成一个问题的可能解，同时满足目标函数。\n3. 回溯法。根据题意，选取度量标准，然后将可能的选择方法按度量标准所要求顺序排好，每次处理一个量，得到该意义下的最优解的分解处理。\n\n## 图\n无向图\n\n1. 回路或环：第一个顶点和最后一个顶点相同的路径。\n2. 简单回路或简单环：除第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路\n3. 连通：顶点v至v’ 之间有路径存在\n4. 连通图：无向图图 G 的任意两点之间都是连通的，则称G是连通图。\n5. 连通分量：极大连通子图，子图中包含的顶点个数极大\n6. 所有顶点度的和必须为偶数\n\n有向图：\n\n1. 回路或环：第一个顶点和最后一个顶点相同的路径。\n2. 简单回路或简单环：除第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路。\n3. 连通：顶点v至v’之间有路径存在\n4. 强连通图：有向图G的任意两点之间都是连通的，则称G是强连通图。各个顶点间均可达。\n5. 强连通分量：极大连通子图\n6. 有向图顶点的度是顶点的入度与出度之和。邻接矩阵中第V行中的1的个数是V的出度\n\n1. 生成树：极小连通子图。包含图的所有n个结点，但只含图的n-1条边。在生成树中添加一条边之后，必定会形成回路或环。\n2. 完全图：有 n(n-1)/2 条边的无向图。其中n是结点个数。必定是连通图。\n3. 有向完全图：有n(n-1)条边的有向图。其中n是结点个数。每两个顶点之间都有两条方向相反的边连接的图。\n4. 一个无向图 G=(V,E) 是连通的，那么边的数目大于等于顶点的数目减一：|E|>=|V|-1，而反之不成立。如果 G=(V,E) 是有向图，那么它是强连通图的必要条件是边的数目大于等于顶点的数目：|E|>=|V|，而反之不成立。没有回路的无向图是连通的当且仅当它是树，即等价于：|E|=|V|-1。\n\n### 图的存储形式\n1. 邻接矩阵和加权邻接矩阵\n\t* 无权有向图：出度: i行之和；入度: j列之和。\n\t* 无权无向图：i结点的度: i行或i列之和。\n\t* 加权邻接矩阵：相连为w，不相连为∞\n2. 邻接表\n\t* 用顶点数组表、边（弧）表表示该有向图或无向图\n\t* 顶点数组表：用数组存放所有的顶点。数组大小为图顶点数n\n\t* 边表（边结点表）：每条边用一个结点进行表示。同一个结点的所有的边形成它的边结点单链表。  \n\t* n个顶点的无向图的邻接表最多有n(n-1)个边表结点。有n个顶点的无向图最多有n\\*(n-1)/2条边，此时为完全无向图，而在邻接表中每条边存储两次，所以有n*(n-1)个结点\n\n### 图的遍历\n深度优先搜索利用栈，广度优先搜索利用队列\n\n求一条从顶点i到顶点s的简单路径--深搜。求两个顶点之间的一条长度最短的路径--广搜。当各边上的权值均相等时,BFS算法可用来解决单源最短路径问题。\n\n### 生成树和最小生成树\n每次遍历一个连通图将图的边分成遍历所经过的边和没有经过的边两部分，将遍历经过的边同图的顶点构成一个子图，该子图称为生成树。因此有DFS生成树和BFS生成树。\n\n生成树是连通图的极小子图，有n个顶点的连通图的生成树必定有n-1条边,在生成树中任意增加一条边，必定产生回路。若砍去它的一条边，就会把生成树变成非连通子图\n\n最小生成树：生成树中边的权值(代价)之和最小的树。最小生成树问题是构造连通网的最小代价生成树。\n\nKruskal算法：令最小生成树集合T初始状态为空，在有n个顶点的图中选取代价最小的边并从图中删去。若该边加到T中有回路则丢弃，否则留在T中；依此类推，直至T中有n-1条边为止。\n\nPrim算法、Kruskal算法和Dijkstra算法均属于贪心算法。\n\n1. Dijkstra算法解决的是带权重的有向图上单源最短路径问题，该算法要求所有边的权重都为非负值。\n2. Dijkstra算法解决了从某个原点到其余各顶点的最短路径问题，由循环嵌套可知该算法的时间复杂度为O(N\\*N)。若要求任一顶点到其余所有顶点的最短路径，一个比较简单的方法是对每个顶点当做源点运行一次该算法，等于在原有算法的基础上，再来一次循环，此时整个算法的复杂度就变成了O(N\\*N\\*N)。\n3. Bellman-Ford算法解决的是一般情况下的单源最短路径问题，在这里，边的权重可以为负值。该算法返回一个布尔值，以表明是否存在一个从源节点可以到达的权重为负值的环路。如果存在这样一个环路，算法将告诉我们不存在解决方案。如果没有这种环路存在，算法将给出最短路径和它们的权重。\n\n### 双连通图和关节点\n若从一个连通图中删去任何一个顶点及其相关联的边，它仍为一个连通图的话，则该连通图被称为**重（双）连通图**。\n\n若连通图中的某个顶点和其相关联的边被删去之后，该连通图被分割成两个或两个以上的连通分量，则称此顶点为**关节点**。\n\n没有关节点的连通图为双连通图\n\n1. 若生成树的根结点，有两个或两个以上的分支，则此顶点(生成树的根)必为关节点；\n2. 对生成树上的任意一个非叶“顶点”，若其某棵子树中的所有“顶点”没有和其祖先相通的回边，则该“顶点”必为关节点。\n\n### 有向无环图及其应用\n拓扑排序。在用邻接表表示图时,对有n个顶点和e条弧的有向图而言时间复杂度为O(n+e)。一个有向图能被拓扑排序的充要条件就是它是一个有向无环图。拓扑序列唯一不能唯一确定有向图。\n\nAOV网(Activity On Vertex)：用顶点表示活动，边表示活动的优先关系的有向图称为**AOV网**。AOV网中不允许有回路，这意味着某项活动以自己为先决条件。 \n\n拓扑有序序列：把AOV网络中各顶点按照它们相互之间的优先关系排列一个线性序列的过程。若v<sub>i</sub>是v<sub>j</sub>前驱，则v<sub>i</sub>一定在v<sub>j</sub>之前；对于没有优先关系的点，顺序任意。\n\n拓扑排序：对AOV网络中顶点构造拓扑有序序列的过程。方法：\n\n1. 在有向图中选一个没有前驱的顶点且输出之\n2. 从图中删除该顶点和所有以它为尾的弧\n3. 重复上述两步，直至全部顶点均已输出；或者当图中不存在无前驱的顶点为止(此时说明图中有环）\n\n采用**深度优先搜索**或**拓扑排序**算法可以判断出一个有向图中是否有环(回路).深度优先搜索只要在其中记录下搜索的节点数n，当n大于图中节点数时退出，并可以得出有回路。若有回路，则拓扑排序访问不到图中所有的节点，所以也可以得出回路。~~广度优先搜索~~过程中如果访问到一个已经访问过的节点，可能是多个节点指向这个节点，不一定是存在环。\n\n算法描述：\n\n1. 把邻接表中入度为0的顶点依此进栈\n2. 若栈不空，则\n\t* 栈顶元素v<sub>j</sub>退栈并输出；\n\t* 在邻接表中查找v<sub>j</sub>的直接后继v<sub>k</sub>，把v<sub>k</sub>的入度减1；若v<sub>k</sub>的入度为0则进栈\n3. 若栈空时输出的顶点个数不是n，则有向图有环；否则，拓扑排序完毕。\n\nAOE网：带权的**有向无环图**，其中顶点表示事件，弧表示活动，权表示活动持续时间。在工程上常用来表示工程进度计划。\n\n一些定义：\n\n1. 事件的最早发生时间（ve(j)）：从源点到j结点的最长的路径。意味着事件最早能够发生的时间。\n2. 事件的最迟发生时间（vl(j)）：不影响工程的如期完工，事件j必须发生的时间。\n3. 活动a<sub>i</sub>由弧<j,k>表示，持续时间记为 dut<j,k>,则有:\n\t* 活动的最早开始时间：e(i)=ve(j)\n\t* 活动的最迟开始时间：l(i)=vl(k) - dut(<j , k >)\n4. 活动余量：l(i)-e(i)的差\n5. 关键活动：活动余量为0的活动\n6. 关键路径：从源点到汇点的最长的一条路径，或者全部由关键活动构成的路径。关键活动一定位于关键路径上。\n7. 关键活动组成了关键路径，关键路径是图中的最长路径，关键路径长度代表整个工期的最短完成时间，关键活动延期完成，必将导致关键路径长度增加，即整个工期的最短完成时间增加。关键路径并不唯一，当有多条关键路径存在时，其中一条关键路径上的关键活动时间缩短，只能导致本条关键路径变成非关键路径，而无法缩短整个工期，因为其他关键路径没有变化。任何一条关键路径上的关键活动变长了，都会使这条关键路径变成更长的关键路径，并且导致其他关键路径变成非关键路径（如果关键路径不唯一）。关键活动不按期完成就会影响整个工程的完成时间。所有的关键活动提前完成,那么整个工程才会提前完成。关键路径也不能任意缩短，一旦缩短到一定程度，该关键活动可能变成非关键活动了。\n\n## 查找\n顺序查找、折半查找、索引查找、分块查找是静态查找，动态查找有二叉排序树查找，最优二叉树查找，键树查找，哈希表查找\n### 静态查找表\n顺序表的顺序查找：应用范围：顺序表或线性链表表示的表，表内元素之间无序。查找过程：从表的一端开始逐个进行记录的关键字和给定值的比较。\n\n顺序有序表的二分查找。平均查找时间(n+1)/n log<sub>2</sub>(n+1)\n\n分块查找：将表分成几块，块内无序，块间有序，即前一块中的最大值小于后一块中的最小值。并且有一张索引表，每一项存放每一块的最大值和指向该块第一个元素的指针。索引表有序，块内无序。所以，块间查找用二分查找，块内用顺序查找，效率介于顺序和二分之间；先确定待查记录所在块，再在块内查找。因此跟表中元素个数和块中元素个数都有关。\n\n1. 用数组存放待查记录,\n2. 建立索引表，由每块中最大（小）的关键字及所属块位置的信息组成。\n3. 当索引表较大时，可以采用二分查找\n4. 在数据量极大时，索引可能很多，可考虑建立索引表的索引，即二级索引，原则上索引不超过三级\n\n分块查找平均查找长度：*ASL*<sub>*bs*</sub> = *L*<sub>*b*</sub> + *L*<sub>*w*</sub>。其中，*L*<sub>*b*</sub>是查找索引表确定所在块的平均查找长度， *L*<sub>*w*</sub>是在块中查找元素的平均查找长度。在n一定时，可以通过选择s使ASL尽可能小。当s=sqrt(n)时，ASL最小。\n\n1. 时间：顺序查找最差，二分最好，分块介于两者之间\n2. 空间：分块最大，需要增加索引数据的空间\n3. 顺序查找对表没有特殊要求  \n4. 分块时数据块之间在物理上可不连续。所以可以达到插入、删除数据只涉及对应的块；另外，增加了索引的维护。\n5. 二分查找要求表有序，所以若表的元素的插入与删除很频繁，维持表有序的工作量极大。\n6. 在表不大时，一般直接使用顺序查找。\n\n## 动态查找\n二叉排序树的结点删除：\n\n1. x为叶子结点，则直接删除\n2. x只有左子树x<sub>L</sub>或只有右子树x<sub>R</sub> ,则令x<sub>L</sub>或x<sub>R</sub>直接成为双亲结点f的子树； \n3. x即有左子树x<sub>L</sub>也有右子树x<sub>R</sub>，在x<sub>L</sub>中选值最大的代替x，该数据按二叉排序树的性质应在最右边。\n\n平衡二叉树：每个结点的平衡因子都为 1、－1、0 的二叉排序树。或者说每个结点的左右子树的高度最多差1的二叉排序树。\n\n平衡二叉树的平衡：\n\n1. 左调整(新结点插入在左子树上的调整)：\n\t* LL(插入在结点左子树的左子树上)：旋转前后高度都为h+1\n\t* LR(新插入结点在左子树的右子树上)：旋转前后高度仍为h+1\n2. 右调整(新结点插入在右子树上进行的调整):\n\t* RR(插入在的右子树的右子树上)：处理方法和 LL对称\n\t* RL(插入在的右子树的左子树上)：处理方法和 LR对称\n\n平衡树建立方法：\n\n1. 按二叉排序树插入结点\n2. 如引起结点平衡因子变为|2|，则确定旋转点，该点是离根最远（或最接近于叶子的点）\n3. 确定平衡类型后进行平衡处理，平衡后以平衡点为根的子树高不变\n4. 最小二叉平衡树的节点的公式如下 F(n)=F(n-1)+F(n-2)+1 这个类似于一个递归的数列，可以参考Fibonacci数列，1是根节点，F(n-1)是左子树的节点数量，F(n-2)是右子树的节点数量。\n\n常见的平衡二叉树：\n\n1. 红黑树是平衡二叉树，也就是左右子树是平衡的，高度大概相等。这种情况等价于一块完全二叉树的高度，查找的时间复杂度是树的高度，为logn，插入操作的平均时间复杂度为O(logn)，最坏时间复杂度为O(logn)\r\n![红黑树](https://upload.wikimedia.org/wikipedia/commons/thumb/6/66/Red-black_tree_example.svg/800px-Red-black_tree_example.svg.png)\n    * 节点是红色或黑色。\r\n    * 根是黑色。\r\n    * 所有叶子都是黑色（叶子是NIL节点）。\r\n    * 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)\r\n    * 从任一节点到其每个叶子的所有简单路径 都包含相同数目的黑色节点。\n2. avl树也是自平衡二叉树；红黑树和AVL树查找、插入、删除的时间复杂度相同；包含n个内部结点的红黑树的高度是o(logn); TreeMap 是一个红黑树的实现，能保证插入的值保证排序\r\n3. STL和linux多使用红黑树作为平衡树的实现：\r\n\t1. 如果插入一个node引起了树的不平衡，AVL和RB-Tree都是最多只需要2次旋转操作，即两者都是O(1)；但是在删除node引起树的不平衡时，最坏情况下，AVL需要维护从被删node到root这条路径上所有node的平衡性，因此需要旋转的量级O(logN)，而RB-Tree最多只需3次旋转，只需要O(1)的复杂度。\r\n\t2. 其次，AVL的结构相较RB-Tree来说更为平衡，在插入和删除node更容易引起Tree的unbalance，因此在大量数据需要插入或者删除时，AVL需要rebalance的频率会更高。因此，RB-Tree在需要大量插入和删除node的场景下，效率更高。自然，由于AVL高度平衡，因此AVL的search效率更高。\r\n\t3. map的实现只是折衷了两者在search、insert以及delete下的效率。总体来说，RB-tree的统计性能是高于AVL的。\n\n\n## 查找总结\n1. 既希望较快的查找又便于线性表动态变化的查找方法是哈希法查找。二叉排序树查找，最优二叉树查找，键树查找，哈希法查找是动态查找。分块、顺序、折半、索引顺序查找均为静态。分块法应该是将整个线性表分成若干块进行保存，若动态变化则可以添加在表的尾部（非顺序结构），时间复杂度是O(1)，查找复杂度为O(n)；若每个表内部为顺序结构，则可用二分法将查找时间复杂度降至O(logn)，但同时动态变化复杂度则变成O(n)；顺序法是挨个查找，这种方法最容易实现，不过查找时间复杂度都是O(n)，动态变化时可将保存值放入线性表尾部，则时间复杂度为O(1)；二分法是基于顺序表的一种查找方式，时间复杂度为O(logn)；通过哈希函数将值转化成存放该值的目标地址，O（1）\n2. 二叉树的平均查找长度为O(log<sub>2</sub>n)——O(n).二叉排序树的查找效率与二叉树的高度有关，高度越低，查找效率越高。二叉树的查找成功的平均查找长度ASL不超过二叉树的高度。二叉树的高度与二叉树的形态有关，n个节点的完全二叉树高度最小，高度为[log<sub>2</sub>n]+1,n个节点的单只二叉树的高度最大，高度为n，此时查找成功的ASL为最大(n+1)/2，因此二叉树的高度范围为[log<sub>2</sub>n]+1——n.\n3. 链式存储不能随机访问，必须是顺序存储\n\n## B_树的B+树\n### B_树\nB-树就是B树。m阶B_树满足或空，或为满足下列性质的m叉树：\n\n![B-树](http://img.my.csdn.net/uploads/201106/7/8394323_13074405906V6Q.jpg)\n\n1. 树中每个结点最多有m棵子树\n2. 根结点在不是叶子时，至少有两棵子树\n3. 除根外，所有非终端结点至少有⎡m/2⎤棵子树 \n4. 有s个子树的非叶结点具有 n = s-1个关键字，结点的信息组织为:(n,A<sub>0</sub>,K<sub>1</sub>,A<sub>1</sub>,K<sub>2</sub>,A<sub>2</sub> … K<sub>n</sub>，A<sub>n</sub>)。这里：n为关键字的个数，k<sub>i</sub>（i=1,2,…,n)为关键字，且满足K<sub>i</sub>小于K<sub>i+1</sub>,，A<sub>i</sub>(i=0,1,..n)为指向子树的指针。\n5. 所有的叶子结点都出现在同一层上，不带信息（可认为外部结点或失败结点）。\n6. 关键字集合分布在整颗树中\n7. 任何一个关键字出现且只出现在一个结点中\n8. 搜索有可能在非叶子结点结束\n9. 其搜索性能等价于在关键字全集内做一次二分查找\n10. 只适用于随机检索，不适用于顺序检索。\n11. 有结点的平衡因子都为零\n12. M阶B-树中含有N个关键字，最大深度为log<sub>⎡m/2⎤</sub>(n+1)/2+2\n\nB_树中结点的插入\n\n1. m代表B_树的阶，插入总发生在最低层\n2. 插入后关键字个数小于等于 m-1,完成。\n3. 插入后关键字个数等于m,结点分裂，以中点数据为界一分为二，中点数据放到双亲结点中。这样就有可能使得双亲结点的数据个数为m,引起双亲结点的分裂，最坏情况下一直波及到根，引起根的分裂——B_树长高。\n\n3阶`B_`树的插入。每个结点最多3棵子树，2个数据；最少2棵子树，1个数据。所以3阶B_树也称为2-3树。\n\nB_树中结点的删除\n\n1. 删除发生在最底层\n\t* 被删关键字所在结点中的关键字数目大于等于 m/2 ，直接删除。\n\t* 删除后结点中数据为⎡m/2⎤-2，而相邻的左（右）兄弟中数据大于⎡m/2⎤-1，此时左（右兄弟）中最大（小）的数据上移到双亲中，双亲中接（靠）在它后（前）面的数据移到被删数据的结点中\n\t* 其左右兄弟结点中数据都是⎡m/2⎤-1，此时和左（右）兄弟合并，合并时连同双亲中相关的关键字。此时，双亲中少了一项，因此又可能引起双亲的合并，最坏一直到根，使B-树降低一层。\n2. 删除不在最底层\n\t* 在大于被删数据中选最小的代替被删数据，问题转换成在最底层的删除\n\n### B+树\n在实际的文件系统中，用的是B+树或其变形。有关性质与操作类似与B_树。\n\n![B+树](http://hi.csdn.net/attachment/201106/7/8394323_1307440587b6WG.jpg)\n\n差异：\n\n1. 有n棵子树的结点中有n个关键字，每个关键字不保存数据，只用来索引，所有数据都保存在叶子节点。\n2. 所有叶子结点中包含全部关键字信息，及对应记录位置信息及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接。(而B树的叶子节点并没有包括全部需要查找的信息)\n3. 所有非叶子为索引，结点中仅含有其子树根结点中最大（或最小）关键字。 (而B树的非终节点也包含需要查找的有效信息)\n4. 非叶最底层顺序联结，这样可以进行顺序查找\n\nB+特性\n\n1. 所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；\n2. 不可能在非叶子结点命中\n3. 非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层\n4. 更适合文件索引系统\n5. B+树插入操作的平均时间复杂度为O(logn)，最坏时间复杂度为O(logn)\n\n查找过程\n\n* 在 B+ 树上，既可以进行缩小范围的查找，也可以进行顺序查找；\n* 在进行缩小范围的查找时，不管成功与否，都必须查到叶子结点才能结束；\n* 若在结点内查找时，给定值≤K<sub>i</sub>， 则应继续在 A<sub>i</sub> 所指子树中进行查找\n\n插入和删除的操作：类似于B_树进行，即必要时，也需要进行结点的“分裂”或“合并”。\n\n为什么说B+tree比B树更适合实际应用中操作系统的文件索引和数据库索引？\n\n1. B+tree的磁盘读写代价更低\n\t* B+tree的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。\n\t* 举个例子，假设磁盘中的一个盘块容纳16bytes，而一个关键字2bytes，一个关键字具体信息指针2bytes。一棵9阶B-tree(一个结点最多8个关键字)的内部结点需要2个盘快。而B+树内部结点只需要1个盘快。当需要把内部结点读入内存中的时候，B树就比B+树多一次盘块查找时间(在磁盘中就是盘片旋转的时间)。\n2. B+tree的查询效率更加稳定\n * 由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。\n\nB树和B+树都是平衡的多叉树。B树和B+树都可用于文件的索引结构。B树和B+树都能有效的支持随机检索。B+树既能索引查找也能顺序查找.\n\n## 哈希表\n1. 在记录的存储地址和它的关键字之间建立一个确定的对应关系；这样不经过比较，一次存取就能得到元素。 \n2. 哈希函数——在记录的关键字与记录的存储位置之间建立的一种对应关系。是从关键字空间到存储位置空间的一种映象。\n3. 哈希表——应用哈希函数，由记录的关键字确定记录在表中的位置信息，并将记录根据此信息放入表中，这样构成的表叫哈希表。\n4. Hash查找适合于关键字可能出现的值的集合远远大于实际关键字集合的情形。\n5. 更适合查找，不适合频繁更新\n6. Hash表等查找复杂依赖于Hash值算法的有效性，在最好的情况下，hash表查找复杂度为O(1)。只有无冲突的hash_table复杂度才是O(1)。一般是O(c)，c为哈希关键字冲突时查找的平均长度。插入，删除，查找都是O(1)。平均查找长度不随表中结点数目的增加而增加,而是随负载因子的增大而增大\n7. 由于冲突的产生，使得哈希表的查找过程仍然是一个给定值与关键字比较的过程。\n\n根据抽屉原理，冲突是不可能完全避免的，所以，选择好的**散列函数和冲突处理**方法：\n\n1. 构造一个性能好，冲突少的Hash函数\n2. 如何解决冲突\n\n常用的哈希函数\n\n1. 直接定址法。仅适合于：地址集合的大小 == 关键字集合的大小\n2. 数字分析法。对关键字进行分析，取关键字的若干位或其组合作哈希地址。仅适合于：能预先估计出全体关键字的每一位上各种数字出现的频度。\n3. 平方取中法。以关键字的平方值的中间几位作为存储地址。\n4. 折叠法。将关键字分割成位数相同的几部分，然后取这几部分的叠加和（舍去进位）做哈希地址。移位叠加/间界叠加。适合于: 关键字的数字位数特别多，且每一位上数字分布大致均匀情况。\n5. 除留余数法。取关键字被某个不大于哈希表表长m的数p除后所得余数作哈希地址，即H(key)=key%p，p<=m。\n6. 随机数法。取关键字的伪随机函数值作哈希地址，即H(key)=random(key)，适于关键字长度不等的情况。\n\n冲突解决\n\n1. 开放定址法。当冲突发生时，形成一个探查序列；沿此序列逐个地址探查，直到找到一个空位置（开放的地址），将发生冲突的记录放到该地址中。即H<sub>i</sub>=(H(key)+d<sub>i</sub>) % m，i=1,2,……k(k<=m-1)，H(key)哈希函数，m哈希表长，d<sub>i</sub>增量序列。缺点：删除：只能作标记，不能真正删除；溢出；载因子过大、解决冲突的算法选择不好会发生聚集问题。要求装填因子α较小，故当结点规模较大时会浪费很多空间。\n\t* 线性探测再散列：d<sub>i</sub>=1，2，3，...，m-1\n\t* 二次探测再散列：d<sub>i</sub>=1<sup>2</sup>,-1<sup>2</sup>,2<sup>2</sup>,-2<sup>2</sup>,...，±k<sup>2</sup>（k<=m/2）\n\t* 伪随机探测再散列: d<sub>i</sub>为伪随机数序列\n2. 链地址法：将所有关键字为同义词的记录存储在一个单链表中，并用一维数组存放头指针。拉链法中可取α≥1，且结点较大时，拉链法中增加的指针域可忽略不计，因此节省空间。一旦发生冲突，在当前位置给单链表增加结点就行。\n3. 其他方法：再哈希法、建立公共溢出区\n4. 在用拉链法构造的散列表中，删除结点的操作易于实现。拉链法的缺点是：指针需要额外的空间，故当结点规模较小时，开放定址法较为节省空间。由于拉链法中各链表上的结点空间是动态申请的,故它更适合于造表前无法确定表长的情况。拉链法解决冲突时，需要使用指针，指示下一个元素的存储位置\n5. 开哈希表--链式地址法;闭哈希表--开放地址法.开哈希和闭哈希主要的区别在于，随着哈希表的密集度提高，使用闭哈希时，不仅会与相同哈希值的元素发生冲突，还容易与不同哈希值的元素发生冲突；而开哈希则不受哈希表疏密与否的影响，始终只会与相同哈希值的元素冲突而已。所以在密集度变大的哈希表中查找时，显然开哈希的平均搜索长度不会增长。\n6. 设有n个关键字具有相同的Hash函数值，则用线性探测法把这n个关键字映射到Hash表中需要做n\\*(n-1)/2次线性探测。如果使用二次探测再散列法将这n个关键字存入哈希表，至少要进行n\\*(n+1)/2次探测\n\nHash查找效率：装填因子=表中记录数/表容量\n\n有B+Tree/Hash_Map/STL Map三种数据结构。对于内存中数据，查找性能较好的数据结构是Hash_Map，对于磁盘中数据，查找性能较好的数据结构是B+Tree。Hash操作能根据散列值直接定位数据的存储地址，设计良好的hash表能在常数级时间下找到需要的数据，但是更适合于内存中的查找。B+树是一种是一种树状的数据结构，适合做索引，对磁盘数据来说，索引查找是比较高效的。STL_Map的内部实现是一颗红黑树，但是只是一颗在内存中建立二叉树树，不能用于磁盘操作，而其内存查找性能也比不上Hash查找。\n\n## 内部排序\n1. 内部排序：全部数据可同时放入内存进行的排序。    \n2. 外部排序：文件中数据太多，无法全部调入内存进行的排序。\n\n插入类：\n\n1. 直接插入排序。最坏情况是数据递减序，数据比较和移动量最大，达到O(n<sup>2</sup>)，最好是数据是递增序，比较和移动最少为O(n)。趟数是固定的n-1，即使有序，也要依次从第二个元素开始。排序趟数不等于时间复杂度。\n2. 折半插入排序 。由于插入第i个元素到r[1]到r[i-1]之间时，前i个数据是有序的，所以可以用折半查找确定插入位置，然后插入。\n3. 希尔排序。缩小增量排序。5-3-1。在实际应用中，步长的选取可简化为开始为表长n的一半（n/2），以后每次减半，最后为1。插入的改进，最后一趟已基本有序，比较次数和移动次数相比直接插入最后一趟更少\n\n交换类：\n\n1. 冒泡排序。O(n<sup>2</sup>)通常认为冒泡是比较差的，可以加些改进，比如在一趟中无数据的交换，则结束等措施。\n\t* 在数据已基本有序时，冒泡是一个较好的方法\n   * 在数据量较少时（15个左右）可以用冒泡\n2. 快速排序。\n\t* 时间复杂度。最好情况：每次支点总在中间，O(nlog<sub>2</sub>n)，平均O(nlog<sub>2</sub>n)。最坏，数据已是递增或递减，O(n<sup>2</sup>)。pivotkey的选择越靠近中央，即左右两个子序列长度越接近，排序速度越快。越无序越快。\n\t* 空间复杂度。需栈空间以实现递归，最坏情况：S(n)=O(n)；一般情况：S(n)=O(log<sub>2</sub>n)\n\t* 在序列已是有序的情况下，时间复杂度最高。原因：支点选择不当。改进：随机选取支点或最左、最右、中间三个元素中的值处于中间的作为支点，通常可以避免最坏情况。所以，快速排序在表已基本有序的情况下不合适。\n\t* 在序列长度已较短时，采用直接插入排序、起泡排序等排序方法。序列的个数通常取10左右。\n\n选择类排序：\n\n1. 简单选择排序。O(n<sup>2</sup>)。总比较次数n(n-1)/2。\n2. 堆排序。建堆 O(n)，筛选排序O(nlogn)。找出若干个数中最大/最小的前K个数，用堆排序是最好。小根堆中最大的数一定是放在叶子节点上，堆本身是个完全二叉树，完全二叉树的叶子节点的位置大于[n/2]。时间复杂度不会因为待排序序列的有序程度而改变，但是待排序序列的有序程度会影响比较次数。\n3. 归并排序。时间：与表长成正比，若一个表表长是m，另一个是n，则时间是O(m+n)。单独一个数组归并，时间：O(nlogn)，空间：O(n)，比较次数介于(nlogn)/2和(nlogn)-n+1，赋值操作的次数是(2nlogn)。归并排序算法比较占用内存，但却是**效率高且稳定**的排序算法。在外排序中使用。归并的趟数是logn。\n4. 基数排序。在一般情况下，每个结点有 d 位关键字，必须执行 t = d次分配和收集操作。分配的代价：O(n)；收集的代价：O(rd) （rd是基数）；总的代价为：O( d ×(n + rd))。适用于以数字和字符串为关键字的情况。\n5. 枚举排序，通常也被叫做秩排序，比较计数排序。对每一个要排序的元素，统计小于它的所有元素的个数，从而得到该元素在整个序列中的位置，时间复杂度为O(n<sup>2</sup>)\n\n比较法分类的下界：O(nlogn)\n\n排序算法的一些特点：\n\n1. **堆排序、冒泡排序、快速排序**在每趟排序过程中,都会有一个元素被放置在其最终的位置上。\n2. 有字符序列 ｛Q,H,C,Y,P,A,M,S,R,D,F,X｝ ,新序列{F,H,C,D,P,A,M,Q,R,S,Y,X}，是快速排序算法一趟扫描的结果。(*拿Q作为分割点,快速排序一轮。二路归并，第一趟排序，得到 n / 2 个长度为 2 的各自有序的子序列，第二趟排序，得到 n / 4 个长度为 4 的各自有序的子序列H Q C Y A P M S D R F X。如果是快速排序的话，第一个元素t将会被放到一个最准确的位置，t前的数均小于t，后面的数均大于t。希尔排序每个小分组内将会是有序的。堆排序，把它构成一颗二叉树的时候，该堆要么就是大根堆，要么就是小根堆，第一趟Y排在最后；冒泡，那么肯定会有数据下沉的动作，第一趟有A在第一位。*)\n3. 在文件\"局部有序\"或文件长度较小的情况下,最佳内部排序的方法是**直接插入排序**。（归并排序要求待排序列已经部分有序，而部分有序的含义是待排序列由若干有序的子序列组成，即每个子序列必须有序，并且其时间复杂度为O(nlog2n)；直接插入排序在待排序列基本有序时，每趟的比较次数大为降低，即n-1趟比较的时间复杂度由O(n^2)降至O(n)。在待排序的元素序列基本有序或者每个元素距其最终位置不远也可用插入排序，效率最高的排序方法是**插入排序**）\n4. 排序趟数与序列的原始状态有关的排序方法是优化冒泡和快速排序法。(插入排序和选择排序不管序列的原始状态是什么都要执行n-1趟，优化冒泡和快排不一定。仔细理解`排序的次数`和`比较次数`的区别)\n5. **不稳定的排序方法：快排，堆排，希尔，选择**\n6. 要与关键字的初始排列次序无关,那么就是最好、最坏、一般的情况下排序时间复杂度不变, 总共有堆排序,归并排序,选择排序,基数排序\n7. 快速排序、Shell 排序、归并排序、直接插入排序的关键码比较次数与记录的初始排列有关。折半插入排序、选择排序无关。(直接插入排序在完全有序的情况下每个元素只需要与他左边的元素比较一次就可以确定他最终的位置；折半插入排序，比较次数是固定的，与初始排序无关；快速排序，初始排序不影响每次划分时的比较次数，都要比较n次，但是初始排序会影响划分次数，所以会影响总的比较次数，但快排平均比较次数最小；归并排序在归并的时候，如果右路最小值比左路最大值还大，那么只需要比较n次，如果右路每个元素分别比左路对应位置的元素大，那么需要比较2*n-1次，所以与初始排序有关)\n8. 精俭排序，即一对数字不进行两次和两次以上的比较，插入和归并是“精俭排序”。插入排序，前面是有序的，后面的每一个元素与前面有序的元素比较，比较过的就是有序的了，不会再比较一次。归并每次合并后，内部都是有序的，内部的元素之间不用再比较。选择排序，每次在后面的元素中找到最小的，找最小元素的过程是在没有排好序的那部分进行，所有肯定会比较多次。堆排序也需比较多次。\n\n## 外部排序\n1. 生成合并段（run）：读入文件的部分记录到内存－>在内存中进行内部排序－>将排好序的这些记录写入外存，形成合并段－>再读入该文件的下面的记录，往复进行，直至文件中的记录全部形成合并段为止。\n2. 外部合并：将上一阶段生成的合并段调入内存，进行合并，直至最后形成一个有序的文件。\n3. 外部排序指的是大文件的排序，即待排序的记录存储在外存储器上，待排序的文件无法一次装入内存，需要在内存和外部存储器之间进行多次数据交换，以达到排序整个文件的目的。外部排序最常用的算法是多路归并排序，即将原文件分解成多个能够一次性装入内存的部分，分别把每一部分调入内存完成排序。然后，对已经排序的子文件进行多路归并排序\n4. 不管初始序列是否有序, 冒泡、选择排序时间复杂度是O(n^2),归并、堆排序时间复杂度是O(nlogn）\n5. 外部排序的总时间 = 内部排序（产出初始归并段）所需时间 + 外存信息读取时间 + 内部归并所需的时间\n6. 外排中使用置换选择排序的目的,是为了增加初始归并段的长度。减少外存读写次数需要减小归并趟数\n\n\n1. 根据内存容量设若干个输入缓冲区和一个输出缓冲区。若采用二路归并，用两个输入缓冲。\n2. 归并的方法类似于归并排序的归并算法。增加的是对缓冲的监视，对于输入，一旦缓冲空，要到相应文件读后续数据，对于输出缓冲，一旦缓冲满，要将缓冲内容写到文件中去。\n3. 外排序和内排序不只是考虑内外排序算法的性能，还要考虑IO数据交换效率的问题，内存存取速度远远高于外存。影响外排序的时间因素主要是内存与外设交换信息的总次数\n\n## 有效的算法设计\n1. 贪心法。Dijkstra的最短路径(时间复杂度O(n<sup>2</sup>))；Prim求最小生成树邻接表存储时是O(n+e),图O(n<sub>2</sub>)；关键路径及关键活动的求法。\n2. 回溯法\n3. 分支限界法\n4. 分治法。分割、求解、合并。二分查找、归并排序、快速排序。\n5. 动态规划。Floyd-Warshall算法求解图中所有点对之间最短路径时间复杂度为O(n<sup>3</sup>)\n\n动态规划解题的方法是一种高效率的方法，其时间复杂度通常为O(n<sup>2</sup>)，O(n<sup>3</sup>)等，可以解决相当大的信息量。（数塔在n<=100层时，可以在很短的时间内得到问题解）\n\n* 适用的原则：原则为优化原则，即整体优化可以分解为若干个局部优化。\n* 动态规划比穷举法具有较少的计算次数\n* 递归算法需要很大的栈空间，而动态规划不需要栈空间\n\n贪心和动态规划的差别：\n\n1. 所谓贪心选择性质是指所求问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到。这是贪心算法可行的第一个基本要素，也是贪心算法与动态规划算法的主要区别。\n2. 在动态规划算法中，每步所作的选择往往依赖于相关子问题的解。因而只有在解出相关子问题后，才能作出选择。而在贪心算法中，仅在当前状态下作出最好选择，即局部最优选择。然后再去解作出这个选择后产生的相应的子问题。\n3. 贪心算法所作的贪心选择可以依赖于以往所作过的选择，但决不依赖于将来所作的选择，也不依赖于子问题的解。正是由于这种差别，动态规划算法通常以自底向上的方式解各子问题，而贪心算法则通常以自顶向下的方式进行,以迭代的方式作出相继的贪心选择，每作一次贪心选择就将所求问题简化为一个规模更小的子问题。 \n\nP问题\n\n1. P问题，如果它可以通过运行多项式次(即运行时间至多是输入量大小的多项式函数的一种算法获得解决），可以找到一个能在多项式的时间里解决它的算法。----确定性问题\n2. NP问题，虽然可以用计算机求解，但是对于任意常数k，它们不能在O(n<sup>k</sup>)时间内得到解答，可以在多项式的时间里验证一个解的问题。所有的P类问题都是NP问题。\n3. NP完全问题，知道有效的非确定性算法，但是不知道是否存在有效的确定性算法，同时，不能证明这些问题中的任何一个不存在有效的确定性算法。这类问题称为NP完全问题。"
        },
        {
          "name": "数据结构.mobi",
          "type": "blob",
          "size": 59.029296875,
          "content": null
        }
      ]
    }
  ]
}