{
  "metadata": {
    "timestamp": 1736560035571,
    "page": 854,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjg2MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "kachayev/fn.py",
      "stars": 3356,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.17578125,
          "content": "language: python\npython:\n  - 2.6\n  - 2.7\n  - 3.2\n  - 3.3\n  - 3.4\n  - pypy\n  - pypy3\nscript: \n  - python tests.py\ninstall:\n  - python setup.py install\nnotifications:\n  email: false\n"
        },
        {
          "name": "HISTORY.rst",
          "type": "blob",
          "size": 1.9208984375,
          "content": "History\n=======\n\n06.04.2013\n----------\n\n- added initial origin param to ``fn.Stream``\n- ``monad.Option`` is flatten by default, Full(Empty) -> Empty, Empty(Full) -> Empty\n- added ``op.unfold`` operator \n\n31.03.2013\n----------\n\n- added example of using tail call optimization with changing callable\n\n16.02.2013\n----------\n\n- fixed @23 about flipping of underscore function\n- added special uniform module\n- fixed @22 (underscore functions representation)\n- adjustments to unary operators processing in underscore\n\n02.02.2013\n----------\n\n- prelimitary implementation of ``recur.tco`` to deal with recursive functions\n- ``iters.flatten`` is reimplemented to work with different iterators\n\n27.01.2013\n----------\n\n- ``iters.accumulate`` - backported version for Python < 3.3\n- first implementation for ``monad.Option`` with tests and README samples\n\n23.01.2013\n----------\n\n- ``fn.Stream`` slice is another ``fn.Stream``\n- ``fn.Stream`` got new public method ``cursor`` to get position on next evaluated element\n\n21.01.2013\n----------\n\n- Update documentation with special ``fn._`` use cases for interactive shells\n- Move ``zipwith`` from ``fn.iters`` to ``fn.op``\n- ``fn._`` dump to string\n\n18.01.2013\n----------\n\n-  Added 22 itertools recipes to ``fn.iters``\n-  Documentation is converted to RST\n\n17.01.2013\n----------\n\n-  Unit tests coverage for ``fn.stream.Stream``\n-  ``_StreamIterator`` works fine both in Python 2/3\n\n16.01.2013\n----------\n\n-  Finished underscore module functionality\n-  Test cases for all implemented modules/functions\n-  Update in Readme file with several fixes\n-  Get rid of F.flip classmethod in pref. for simple building blocks\n-  Optimized version for fn.op.flip operator\n\n14.01.2013\n----------\n\n-  Simplest ``Stream`` implementation\n-  Code samples for streams, labdas (``_``) and functions compositions\n-  Plan, contribute section in readme file\n\n13.01.2013\n----------\n\n-  Full list of ideas on paper\n-  Repository is created\n-  Initial commit\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 0.5693359375,
          "content": "Copyright 2013 Alexey Kachayev\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "MANIFEST.in",
          "type": "blob",
          "size": 0.0380859375,
          "content": "include README.rst LICENSE HISTORY.rst\n"
        },
        {
          "name": "README.rst",
          "type": "blob",
          "size": 16.6650390625,
          "content": "Fn.py: enjoy FP in Python\n=========================\n\nDespite the fact that Python is not pure-functional programming\nlanguage, it's multi-paradigm PL and it gives you enough freedom to take\ncredits from functional programming approach. There are theoretical and\npractical advantages to the functional style:\n\n-  Formal provability\n-  Modularity\n-  Composability\n-  Ease of debugging and testing\n\n``Fn.py`` library provides you with missing \"batteries\" to get maximum\nfrom functional approach even in mostly-imperative program.\n\nMore about functional approach from my Pycon UA 2012 talks: `Functional\nProgramming with\nPython <http://kachayev.github.com/talks/uapycon2012/index.html>`_.\n\nScala-style lambdas definition\n------------------------------\n\n.. code-block:: python\n\n    from fn import _\n    from fn.op import zipwith\n    from itertools import repeat\n\n    assert list(map(_ * 2, range(5))) == [0,2,4,6,8]\n    assert list(filter(_ < 10, [9,10,11])) == [9]\n    assert list(zipwith(_ + _)([0,1,2], repeat(10))) == [10,11,12]\n\nMore examples of using ``_`` you can find in `test\ncases <https://github.com/kachayev/fn.py/blob/master/tests.py>`_\ndeclaration (attributes resolving, method calling, slicing).\n\n**Attention!** If you work in interactive python shell, your should remember that ``_`` means \"latest output\" and you'll get unpredictable results. In this case, you can do something like ``from fn import _ as X`` (and then write functions like ``X * 2``).\n\nIf you are not sure, what your function is going to do, you can print it:\n\n.. code-block:: python\n\n    from fn import _\n\n    print (_ + 2) # \"(x1) => (x1 + 2)\"\n    print (_ + _ * _) # \"(x1, x2, x3) => (x1 + (x2 * x3))\"\n\n``_`` will fail with ``ArityError`` (``TypeError`` subclass) on inaccurate number of passed arguments. This is one more restrictions to ensure that you did everything right:\n\n.. code-block:: python\n\n    >>> from fn import _\n    >>> (_ + _)(1)\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>\n      File \"fn/underscore.py\", line 82, in __call__\n        raise ArityError(self, self._arity, len(args))\n    fn.underscore.ArityError: (_ + _) expected 2 arguments, got 1\n\n\nPersistent data structures\n--------------------------\n\n**Attention:** Persistent data structures are under active development.\n\nPersistent data structure is a data structure that always preserves the previous version of itself when it is modified (more formal information on `Wikipedia <http://goo.gl/8VveOH>`_). Each operation with such data structure yields a new updated structure instead of in-place modification (all previous versions are potentially available or GC-ed when possible).\n\nLets take a quick look:\n\n.. code-block:: python\n\n    >>> from fn.immutable import SkewHeap\n    >>> s1 = SkewHeap(10)\n    >>> s2 = s1.insert(20)\n    >>> s2\n    <fn.immutable.heap.SkewHeap object at 0x10b14c050>\n    >>> s3 = s2.insert(30)\n    >>> s3\n    <fn.immutable.heap.SkewHeap object at 0x10b14c158> # <-- other object\n    >>> s3.extract()\n    (10, <fn.immutable.heap.SkewHeap object at 0x10b14c050>)\n    >>> s3.extract() # <-- s3 isn't changed\n    (10, <fn.immutable.heap.SkewHeap object at 0x10b11c052>)\n\nIf you think I'm totally crazy and it will work despairingly slow, just give it 5 minutes. Relax, take a deep breath and read about few techniques that make persistent data structures fast and efficient: `structural sharing <http://en.wikipedia.org/wiki/Persistent_data_structure#Examples_of_persistent_data_structures>`_ and `path copying <http://en.wikipedia.org/wiki/Persistent_data_structure#Path_Copying>`_.\n\nTo see how it works in \"pictures\", you can check great slides from Zach Allaun's talk (StrangeLoop 2013): `\"Functional Vectors, Maps And Sets In Julia\" <http://goo.gl/Cp1Qsq>`_.\n\nAnd, if you are brave enough, go and read:\n\n- Chris Okasaki, \"Purely Functional Data Structures\" (`Amazon <http://goo.gl/c7ptkk>`_)\n- Fethi Rabhi and Guy Lapalme, \"Algorithms: A Functional Programming Approach\" (`Amazon <http://goo.gl/00BxTO>`_)\n\nAvailable immutable data structures in ``fn.immutable`` module:\n\n- ``LinkedList``: most \"obvious\" persistent data structure, used as building block for other list-based structures (stack, queue)\n- ``Stack``: wraps linked list implementation with well-known pop/push API\n- ``Queue``: uses two linked lists and lazy copy to provide O(1) enqueue and dequeue operations\n- ``Deque`` (in progress): `\"Confluently Persistent Deques via Data\n  Structural Bootstrapping\" <http://goo.gl/vVTzx3>`_\n- ``Deque`` based on ``FingerTree`` data structure (see more information below)\n- ``Vector``: O(log32(n)) access to elements by index (which is near-O(1) for reasonable vector size), implementation is based on ``BitmappedTrie``, almost drop-in replacement for built-in Python ``list``\n- ``SkewHeap``: self-adjusting heap implemented as a binary tree with specific branching model, uses heap merge as basic operation, more information - `\"Self-adjusting heaps\" <http://goo.gl/R1PZME>`_\n- ``PairingHeap``: `\"The Pairing-Heap: A New Form of Self-Adjusting Heap\" <http://goo.gl/aiVtPH>`_\n- ``Dict`` (in progress): persistent hash map implementation based on ``BitmappedTrie``\n- ``FingerTree`` (in progress): `\"Finger Trees: A Simple General-purpose Data Structure\" <http://goo.gl/Bzo0df>`_\n\nUse appropriate doc strings to get more information about each data structure as well as sample code.\n\nTo get more clear vision of how persistent heaps work (``SkewHeap`` and ``PairingHeap``), you can look at slides from my talk `\"Union-based heaps\" <http://goo.gl/VMgdG2>`_ (with analyzed data structures definitions in Python and Haskell).\n\n**Note.** Most functional languages use persistent data structures as basic building blocks, well-known examples are Clojure, Haskell and Scala. Clojure community puts much effort to popularize programming based on the idea of data immutability. There are few amazing talk given by Rich Hickey (creator of Clojure), you can check them to find answers on both questions \"How?\" and \"Why?\":\n\n- `\"The Value of Values\" <http://goo.gl/137UG5>`_\n- `\"Persistent Data Structures and Managed References\" <http://goo.gl/M3vZ7E>`_\n\nStreams and infinite sequences declaration\n------------------------------------------\n\nLazy-evaluated Scala-style streams. Basic idea: evaluate each new\nelement \"on demand\" and share calculated elements between all created\niterators. ``Stream`` object supports ``<<`` operator that means pushing\nnew elements when it's necessary.\n\nSimplest cases:\n\n.. code-block:: python\n\n    from fn import Stream\n\n    s = Stream() << [1,2,3,4,5]\n    assert list(s) == [1,2,3,4,5]\n    assert s[1] == 2\n    assert list(s[0:2]) == [1,2]\n\n    s = Stream() << range(6) << [6,7]\n    assert list(s) == [0,1,2,3,4,5,6,7]\n\n    def gen():\n        yield 1\n        yield 2\n        yield 3\n\n    s = Stream() << gen << (4,5)\n    assert list(s) == [1,2,3,4,5]\n\nLazy-evaluated stream is useful for infinite sequences, i.e. fibonacci\nsequence can be calculated as:\n\n.. code-block:: python\n\n    from fn import Stream\n    from fn.iters import take, drop, map\n    from operator import add\n\n    f = Stream()\n    fib = f << [0, 1] << map(add, f, drop(1, f))\n\n    assert list(take(10, fib)) == [0,1,1,2,3,5,8,13,21,34]\n    assert fib[20] == 6765\n    assert list(fib[30:35]) == [832040,1346269,2178309,3524578,5702887]\n\nTrampolines decorator\n---------------------\n\n``fn.recur.tco`` is a workaround for dealing with TCO without heavy stack utilization. Let's start from simple example of recursive factorial calculation:\n\n.. code-block:: python\n\n    def fact(n):\n        if n == 0: return 1\n        return n * fact(n-1)\n\nThis variant works, but it's really ugly. Why? It will utilize memory too heavy cause of recursive storing all previous values to calculate final result. If you will execute this function with big ``n`` (more than ``sys.getrecursionlimit()``) CPython will fail with\n\n.. code-block:: python\n\n    >>> import sys\n    >>> fact(sys.getrecursionlimit() * 2)\n    ... many many lines of stacktrace ...\n    RuntimeError: maximum recursion depth exceeded\n\nWhich is good, cause it prevents you from terrible mistakes in your code.\n\nHow can we optimize this solution? Answer is simple, lets transform function to use tail call:\n\n.. code-block:: python\n\n    def fact(n, acc=1):\n        if n == 0: return acc\n        return fact(n-1, acc*n)\n\nWhy this variant is better? Cause you don't need to remember previous values to calculate final result. More about `tail call optimization <http://en.wikipedia.org/wiki/Tail_call>`_ on Wikipedia. But... Python interpreter will execute this function the same way as previous one, so you won't win anything.\n\n``fn.recur.tco`` gives you mechanism to write \"optimized a bit\" tail call recursion (using \"trampoline\" approach):\n\n.. code-block:: python\n\n    from fn import recur\n\n    @recur.tco\n    def fact(n, acc=1):\n        if n == 0: return False, acc\n        return True, (n-1, acc*n)\n\n``@recur.tco`` is a decorator that execute your function in ``while`` loop and check output:\n\n- ``(False, result)`` means that we finished\n- ``(True, args, kwargs)`` means that we need to call function again with other arguments\n- ``(func, args, kwargs)`` to switch function to be executed inside while loop\n\nThe last variant is really useful, when you need to switch callable inside evaluation loop. Good example for such situation is recursive detection if given number is odd or even:\n\n.. code-block:: python\n\n    >>> from fn import recur\n    >>> @recur.tco\n    ... def even(x):\n    ...     if x == 0: return False, True\n    ...     return odd, (x-1,)\n    ...\n    >>> @recur.tco\n    ... def odd(x):\n    ...     if x == 0: return False, False\n    ...     return even, (x-1,)\n    ...\n    >>> print even(100000)\n    True\n\n**Attention:** be careful with mutable/immutable data structures processing.\n\nItertools recipes\n-----------------\n\n``fn.uniform`` provides you with \"unification\"\nof lazy functionality for few functions to work the same way in Python\n2+/3+:\n\n-  ``map`` (returns ``itertools.imap`` in Python 2+)\n-  ``filter`` (returns ``itertools.ifilter`` in Python 2+)\n-  ``reduce`` (returns ``functools.reduce`` in Python 3+)\n-  ``zip`` (returns ``itertools.izip`` in Python 2+)\n-  ``range`` (returns ``xrange`` in Python 2+)\n-  ``filterfalse`` (returns ``itertools.ifilterfalse`` in Python 2+)\n-  ``zip_longest`` (returns ``itertools.izip_longest`` in Python 2+)\n-  ``accumulate`` (backported to Python < 3.3)\n\n``fn.iters`` is high-level recipes to work with iterators. Most\nof them taken from `Python\ndocs <http://docs.python.org/2.7/library/itertools.html#itertools.product>`_\nand adopted to work both with Python 2+/3+. Such recipes as ``drop``,\n``takelast``, ``droplast``, ``splitat``, ``splitby`` I have already\nsubmitted as `docs patch <http://bugs.python.org/issue16774>`_ which is\nreview status just now.\n\n-  ``take``, ``drop``\n-  ``takelast``, ``droplast``\n-  ``head`` (alias: ``first``), ``tail`` (alias: ``rest``)\n-  ``second``, ``ffirst``\n-  ``compact``, ``reject``\n-  ``every``, ``some``\n-  ``iterate``\n-  ``consume``\n-  ``nth``\n-  ``padnone``, ``ncycles``\n-  ``repeatfunc``\n-  ``grouper``, ``powerset``, ``pairwise``\n-  ``roundrobin``\n-  ``partition``, ``splitat``, ``splitby``\n-  ``flatten``\n-  ``iter_except``\n-  ``first_true``\n\nMore information about use cases you can find in docstrings for each\nfunction in `source\ncode <https://github.com/kachayev/fn.py/blob/master/fn/iters.py>`__ and\nin `test\ncases <https://github.com/kachayev/fn.py/blob/master/tests.py>`_.\n\nHigh-level operations with functions\n------------------------------------\n\n``fn.F`` is a useful function wrapper to provide easy-to-use partial\napplication and functions composition.\n\n.. code-block:: python\n\n    from fn import F, _\n    from operator import add, mul\n\n    # F(f, *args) means partial application\n    # same as functools.partial but returns fn.F instance\n    assert F(add, 1)(10) == 11\n\n    # F << F means functions composition,\n    # so (F(f) << g)(x) == f(g(x))\n    f = F(add, 1) << F(mul, 100)\n    assert list(map(f, [0, 1, 2])) == [1, 101, 201]\n    assert list(map(F() << str << (_ ** 2) << (_ + 1), range(3))) == [\"1\", \"4\", \"9\"]\n\nIt also give you move readable in many cases \"pipe\" notation to deal with functions composition:\n\n.. code-block:: python\n\n    from fn import F, _\n    from fn.iters import filter, range\n\n    func = F() >> (filter, _ < 6) >> sum\n    assert func(range(10)) == 15\n\nYou can find more examples for compositions usage in ``fn._``\nimplementation `source\ncode <https://github.com/kachayev/fn.py/blob/master/fn/underscore.py>`__.\n\n``fn.op.apply`` executes given function with given positional arguments\nin list (or any other iterable). ``fn.op.flip`` returns you function\nthat will reverse arguments order before apply.\n\n.. code-block:: python\n\n    from fn.op import apply, flip\n    from operator import add, sub\n\n    assert apply(add, [1, 2]) == 3\n    assert flip(sub)(20,10) == -10\n    assert list(map(apply, [add, mul], [(1,2), (10,20)])) == [3, 200]\n\n``fn.op.foldl`` and ``fn.op.foldr`` are folding operators. Each accepts function with arity 2 and returns function that can be used to reduce iterable to scalar: from left-to-right and from right-to-left in case of ``foldl`` and ``foldr`` respectively.\n\n.. code-block:: python\n\n    from fn import op, _\n\n    folder = op.foldr(_ * _, 1)\n    assert 6 == op.foldl(_ + _)([1,2,3])\n    assert 6 == folder([1,2,3])\n\nUse case specific for right-side folding is:\n\n.. code-block:: python\n\n    from fn.op import foldr, call\n\n    assert 100 == foldr(call, 0 )([lambda s: s**2, lambda k: k+10])\n    assert 400 == foldr(call, 10)([lambda s: s**2, lambda k: k+10])\n\n\nFunction currying\n-----------------\n\n``fn.func.curried`` is a decorator for building curried functions, for example:\n\n.. code-block:: python\n\n    >>> from fn.func import curried\n    >>> @curried\n    ... def sum5(a, b, c, d, e):\n    ...     return a + b + c + d + e\n    ...\n    >>> sum5(1)(2)(3)(4)(5)\n    15\n    >>> sum5(1, 2, 3)(4, 5)\n    15\n\n\nFunctional style for error-handling\n-----------------------------------\n\n``fn.monad.Option`` represents optional values, each instance of ``Option`` can be either instance of ``Full`` or ``Empty``. It provides you with simple way to write long computation sequences and get rid of many ``if/else`` blocks. See usage examples below.\n\nAssume that you have ``Request`` class that gives you parameter value by its name. To get uppercase notation for non-empty striped value:\n\n.. code-block:: python\n\n    class Request(dict):\n        def parameter(self, name):\n            return self.get(name, None)\n\n    r = Request(testing=\"Fixed\", empty=\"   \")\n    param = r.parameter(\"testing\")\n    if param is None:\n        fixed = \"\"\n    else:\n        param = param.strip()\n        if len(param) == 0:\n            fixed = \"\"\n        else:\n            fixed = param.upper()\n\n\nHmm, looks ugly.. Update code with ``fn.monad.Option``:\n\n.. code-block:: python\n\n    from operator import methodcaller\n    from fn.monad import optionable\n\n    class Request(dict):\n        @optionable\n        def parameter(self, name):\n            return self.get(name, None)\n\n    r = Request(testing=\"Fixed\", empty=\"   \")\n    fixed = r.parameter(\"testing\")\n             .map(methodcaller(\"strip\"))\n             .filter(len)\n             .map(methodcaller(\"upper\"))\n             .get_or(\"\")\n\n``fn.monad.Option.or_call`` is good method for trying several variant to end computation. I.e. use have ``Request`` class with optional attributes ``type``, ``mimetype``, ``url``. You need to evaluate \"request type\" using at least one attribute:\n\n.. code-block:: python\n\n    from fn.monad import Option\n\n    request = dict(url=\"face.png\", mimetype=\"PNG\")\n    tp = Option \\\n            .from_value(request.get(\"type\", None)) \\ # check \"type\" key first\n            .or_call(from_mimetype, request) \\ # or.. check \"mimetype\" key\n            .or_call(from_extension, request) \\ # or... get \"url\" and check extension\n            .get_or(\"application/undefined\")\n\n\nInstallation\n------------\n\nTo install ``fn.py``, simply:\n\n.. code-block:: console\n\n    $ pip install fn\n\nOr, if you absolutely must:\n\n.. code-block:: console\n\n    $ easy_install fn\n\nYou can also build library from source\n\n.. code-block:: console\n\n    $ git clone https://github.com/kachayev/fn.py.git\n    $ cd fn.py\n    $ python setup.py install\n\nWork in progress\n----------------\n\n\"Roadmap\":\n\n- ``fn.monad.Either`` to deal with error logging\n-  C-accelerator for most modules\n\nIdeas to think about:\n\n-  Scala-style for-yield loop to simplify long map/filter blocks\n\nContribute\n----------\n\n1. Check for open issues or open a fresh issue to start a discussion\n   around a feature idea or a bug.\n2. Fork the repository on Github to start making your changes to the\n   master branch (or branch off of it).\n3. Write a test which shows that the bug was fixed or that the feature\n   works as expected.\n\nHow to find me\n--------------\n\n- Twitter: `@kachayev <https://twitter.com/kachayev>`_\n- Email: kachayev <at> gmail.com\n"
        },
        {
          "name": "fn",
          "type": "tree",
          "content": null
        },
        {
          "name": "setup.py",
          "type": "blob",
          "size": 1.2978515625,
          "content": "#!/usr/bin/env python\n\nimport os\nimport sys\n\nimport fn\n\ntry:\n    from setuptools import setup\nexcept ImportError:\n    from distutils.core import setup\n\nif sys.argv[-1] == 'publish':\n    os.system('python setup.py sdist upload')\n    sys.exit()\n\nshort = 'Implementation of missing features to enjoy functional programming in Python'\nsetup(\n    name = 'fn',\n    version = fn.__version__,\n    description = short,\n    long_description = open('README.rst').read() + '\\n\\n' + open('HISTORY.rst').read(),\n    author='Alexey Kachayev',\n    author_email='kachayev@gmail.com',\n    url='https://github.com/kachayev/fn.py',\n    packages=['fn', 'fn.immutable'],\n    package_data={'': ['LICENSE', 'README.rst', 'HISTORY.rst']},\n    include_package_data=True,\n    install_requires=[],\n    license=open('LICENSE').read(),\n    zip_safe=False,\n    classifiers=(\n        'Development Status :: 2 - Pre-Alpha',\n        'Intended Audience :: Developers',\n        'Natural Language :: English',\n        'License :: OSI Approved :: Apache Software License',\n        'Programming Language :: Python',\n        'Programming Language :: Python :: 2.7',\n        'Programming Language :: Python :: 3',\n        'Programming Language :: Python :: 3.1',\n        'Programming Language :: Python :: 3.2',\n        'Programming Language :: Python :: 3.3',\n    ),\n)\n"
        },
        {
          "name": "tests.py",
          "type": "blob",
          "size": 40.587890625,
          "content": "#!/usr/bin/env python\n\n\"\"\"Tests for Fn.py library\"\"\"\n\nimport sys\nimport unittest\nimport operator\nimport itertools\n\nfrom fn import op, _, F, Stream, iters, underscore, monad, recur\nfrom fn.uniform import reduce\nfrom fn.immutable import SkewHeap, PairingHeap, LinkedList, Stack, Queue, Vector, Deque\n\nclass InstanceChecker(object):\n    if sys.version_info[0] == 2 and sys.version_info[1] <= 6:\n        def assertIsInstance(self, inst, cls):\n            self.assertTrue(isinstance(inst, cls))\n\nclass OperatorTestCase(unittest.TestCase):\n\n    def test_currying(self):\n        def add(first):\n            def add(second):\n                return first + second\n            return add\n\n        self.assertEqual(1, op.curry(add, 0, 1))\n\n    def test_apply(self):\n        self.assertEqual(10, op.apply(operator.add, [2,8]))\n\n    def test_flip(self):\n        self.assertEqual(10, op.flip(operator.sub)(2, 12))\n        self.assertEqual(-10, op.flip(op.flip(operator.sub))(2, 12))\n        # flipping of flipped function should use optimization\n        self.assertTrue(operator.sub is op.flip(op.flip(operator.sub)))\n\n    def test_flip_with_shortcut(self):\n        self.assertEqual(10, op.flip(_ - _)(2, 12))\n\n    def test_zipwith(self):\n        zipper = op.zipwith(operator.add)\n        self.assertEqual([10,11,12], list(zipper([0,1,2], itertools.repeat(10))))\n\n        zipper = op.zipwith(_ + _)\n        self.assertEqual([10,11,12], list(zipper([0,1,2], itertools.repeat(10))))\n\n        zipper = F() << list << op.zipwith(_ + _)\n        self.assertEqual([10,11,12], zipper([0,1,2], itertools.repeat(10)))\n\n    def test_foldl(self):\n        self.assertEqual(10, op.foldl(operator.add)([0,1,2,3,4]))\n        self.assertEqual(20, op.foldl(operator.add, 10)([0,1,2,3,4]))\n        self.assertEqual(20, op.foldl(operator.add, 10)(iters.range(5)))\n        self.assertEqual(10, op.foldl(_ + _)(range(5)))\n\n    def test_foldr(self):\n        summer = op.foldr(operator.add)\n        self.assertEqual(10, op.foldr(operator.add)([0,1,2,3,4]))\n        self.assertEqual(20, op.foldr(operator.add, 10)([0,1,2,3,4]))\n        self.assertEqual(20, op.foldr(operator.add, 10)(iters.range(5)))\n        # specific case for right-side folding\n        self.assertEqual(100,\n                         op.foldr(op.call, 0)([lambda s: s**2, lambda k: k+10]))\n\n    def test_unfold_infinite(self):\n        doubler = op.unfold(lambda x: (x*2, x*2))\n        self.assertEqual(20, next(doubler(10)))\n        self.assertEqual([20, 40, 80, 160, 320], list(iters.take(5, doubler(10))))\n\n    def test_unfold_finite(self):\n        countdown = op.unfold(lambda x: (x-1, x-2) if x > 1 else None)\n        self.assertEqual([9,7,5,3,1], list(countdown(10)))\n\nclass UnderscoreTestCase(unittest.TestCase):\n\n    def test_identity_default(self):\n        self.assertEqual(10, _(10))\n\n    def test_arithmetic(self):\n        # operator +\n        self.assertEqual(7, (_ + 2)(5))\n        self.assertEqual([10,11,12], list(map(_ + 10, [0,1,2])))\n        # operator -\n        self.assertEqual(3, (_ - 2)(5))\n        self.assertEqual(13, (_ - 2 + 10)(5))\n        self.assertEqual([0,1,2], list(map(_ - 10, [10,11,12])))\n        # operator *\n        self.assertEqual(10, (_ * 2)(5))\n        self.assertEqual(50, (_ * 2 + 40)(5))\n        self.assertEqual([0,10,20], list(map(_ * 10, [0,1,2])))\n        # operator /\n        self.assertEqual(5, (_ / 2)(10))\n        self.assertEqual(6, (_ / 2 + 1)(10))\n        self.assertEqual([1,2,3], list(map(_ / 10, [10,20,30])))\n        # operator **\n        self.assertEqual(100, (_ ** 2)(10))\n        # operator %\n        self.assertEqual(1, (_ % 2)(11))\n        # operator <<\n        self.assertEqual(32, (_ << 2)(8))\n        # operator >>\n        self.assertEqual(2, (_ >> 2)(8))\n        # operator (-a)\n        self.assertEqual(10,  (-_)(-10))\n        self.assertEqual(-10, (-_)(10))\n        # operator (+a)\n        self.assertEqual(10,  (+_)(10))\n        self.assertEqual(-10, (+_)(-10))\n        # operator (~a)\n        self.assertEqual(-11, (~_)(10))\n\n    def test_arithmetic_multiple(self):\n        self.assertEqual(10, (_ + _)(5, 5))\n        self.assertEqual(0, (_ - _)(5, 5))\n        self.assertEqual(25, (_ * _)(5, 5))\n        self.assertEqual(1, (_ / _)(5, 5))\n\n    def test_arithmetic_swap(self):\n        # operator +\n        self.assertEqual(7, (2 + _)(5))\n        self.assertEqual([10,11,12], list(map(10 + _, [0,1,2])))\n        # operator -\n        self.assertEqual(3, (8 - _)(5))\n        self.assertEqual(13, (8 - _ + 10)(5))\n        self.assertEqual([10,9,8], list(map(10 - _, [0,1,2])))\n        # operator *\n        self.assertEqual(10, (2 * _)(5))\n        self.assertEqual(50, (2 * _ + 40)(5))\n        self.assertEqual([0,10,20], list(map(10 * _, [0,1,2])))\n        # operator /\n        self.assertEqual(5, (10 / _)(2))\n        self.assertEqual(6, (10 / _ + 1)(2))\n        self.assertEqual([10,5,2], list(map(100 / _, [10,20,50])))\n        # operator **\n        self.assertEqual(100, (10**_)(2))\n        # operator %\n        self.assertEqual(1, (11 % _)(2))\n        # operator <<\n        self.assertEqual(32, (8 << _)(2))\n        # operator >>\n        self.assertEqual(2, (8 >> _)(2))\n\n    def test_bitwise(self):\n        # and\n        self.assertTrue( (_ & 1)(1))\n        self.assertFalse((_ & 1)(0))\n        self.assertFalse((_ & 0)(1))\n        self.assertFalse((_ & 0)(0))\n        # or\n        self.assertTrue( (_ | 1)(1))\n        self.assertTrue( (_ | 1)(0))\n        self.assertTrue( (_ | 0)(1))\n        self.assertFalse((_ | 0)(0))\n        # xor\n        self.assertTrue( (_ ^ 1)(0))\n        self.assertTrue( (_ ^ 0)(1))\n        self.assertFalse((_ ^ 1)(1))\n        self.assertFalse((_ ^ 0)(0))\n\n    def test_bitwise_swap(self):\n        # and\n        self.assertTrue( (1 & _)(1))\n        self.assertFalse((1 & _)(0))\n        self.assertFalse((0 & _)(1))\n        self.assertFalse((0 & _)(0))\n        # or\n        self.assertTrue( (1 | _)(1))\n        self.assertTrue( (1 | _)(0))\n        self.assertTrue( (0 | _)(1))\n        self.assertFalse((0 | _)(0))\n        # xor\n        self.assertTrue( (1 ^ _)(0))\n        self.assertTrue( (0 ^ _)(1))\n        self.assertFalse((1 ^ _)(1))\n        self.assertFalse((0 ^ _)(0))\n\n    def test_getattr(self):\n        class GetattrTest(object):\n            def __init__(self):\n                self.doc = \"TestCase\"\n\n        self.assertEqual(\"TestCase\", (_.doc)(GetattrTest()))\n        self.assertEqual(\"TestCaseTestCase\", (_.doc * 2)(GetattrTest()))\n        self.assertEqual(\"TestCaseTestCase\", (_.doc + _.doc)(GetattrTest(), GetattrTest()))\n\n    def test_call_method(self):\n        self.assertEqual([\"test\", \"case\"], (_.call(\"split\"))(\"test case\"))\n        self.assertEqual(\"str\", _.__name__(str))\n\n    def test_call_method_args(self):\n        self.assertEqual([\"test\", \"case\"], (_.call(\"split\", \"-\"))(\"test-case\"))\n        self.assertEqual([\"test-case\"], (_.call(\"split\", \"-\", 0))(\"test-case\"))\n\n    def test_call_method_kwargs(self):\n        test_dict = {'num': 23}\n        _.call(\"update\", num = 42)(test_dict)\n        self.assertEqual({'num': 42}, (test_dict))\n\n    def test_comparator(self):\n        self.assertTrue((_ < 7)(1))\n        self.assertFalse((_ < 7)(10))\n        self.assertTrue((_ > 20)(25))\n        self.assertFalse((_ > 20)(0))\n        self.assertTrue((_ <= 7)(6))\n        self.assertTrue((_ <= 7)(7))\n        self.assertFalse((_ <= 7)(8))\n        self.assertTrue((_ >= 7)(8))\n        self.assertTrue((_ >= 7)(7))\n        self.assertFalse((_ >= 7)(6))\n        self.assertTrue((_ == 10)(10))\n        self.assertFalse((_ == 10)(9))\n\n    def test_none(self):\n        self.assertTrue((_ == None)(None))\n\n        class pushlist(list):\n            def __lshift__(self, item):\n                self.append(item)\n                return self\n\n        self.assertEqual([None], (_ << None)(pushlist()))\n\n    def test_comparator_multiple(self):\n        self.assertTrue((_ < _)(1, 2))\n        self.assertFalse((_ < _)(2, 1))\n        self.assertTrue((_ > _)(25, 20))\n        self.assertFalse((_ > _)(20, 25))\n        self.assertTrue((_ <= _)(6, 7))\n        self.assertTrue((_ <= _)(7, 7))\n        self.assertFalse((_ <= _)(8, 7))\n        self.assertTrue((_ >= _)(8, 7))\n        self.assertTrue((_ >= _)(7, 7))\n        self.assertFalse((_ >= _)(6, 7))\n        self.assertTrue((_ == _)(10, 10))\n        self.assertFalse((_ == _)(9, 10))\n\n    def test_comparator_filter(self):\n        self.assertEqual([0,1,2], list(filter(_ < 5, [0,1,2,10,11,12])))\n\n    def test_slicing(self):\n        self.assertEqual(0,       (_[0])(list(range(10))))\n        self.assertEqual(9,       (_[-1])(list(range(10))))\n        self.assertEqual([3,4,5], (_[3:])(list(range(6))))\n        self.assertEqual([0,1,2], (_[:3])(list(range(10))))\n        self.assertEqual([1,2,3], (_[1:4])(list(range(10))))\n        self.assertEqual([0,2,4], (_[0:6:2])(list(range(10))))\n\n    def test_slicing_multiple(self):\n        self.assertEqual(0, (_[_])(range(10), 0))\n        self.assertEqual(8, (_[_ * (-1)])(range(10), 2))\n\n    def test_arity_error(self):\n        self.assertRaises(underscore.ArityError, _, 1, 2)\n        self.assertRaises(underscore.ArityError, _ + _, 1)\n        # can be catched as TypeError\n        self.assertRaises(TypeError, _, 1, 2)\n        self.assertRaises(TypeError, _ + _, 1)\n\n    def test_more_than_2_operations(self):\n        self.assertEqual(12, (_ * 2 + 10)(1))\n        self.assertEqual(6,  (_ + _ + _)(1,2,3))\n        self.assertEqual(10, (_ + _ + _ + _)(1,2,3,4))\n        self.assertEqual(7,  (_ + _ * _)(1,2,3))\n\n    def test_string_converting(self):\n        self.assertEqual(\"(x1) => x1\", str(_))\n\n        self.assertEqual(\"(x1) => (x1 + 2)\",  str(_ + 2))\n        self.assertEqual(\"(x1) => (x1 - 2)\",  str(_ - 2))\n        self.assertEqual(\"(x1) => (x1 * 2)\",  str(_ * 2))\n        self.assertEqual(\"(x1) => (x1 / 2)\",  str(_ / 2))\n        self.assertEqual(\"(x1) => (x1 % 2)\",  str(_ % 2))\n        self.assertEqual(\"(x1) => (x1 ** 2)\", str(_ ** 2))\n\n        self.assertEqual(\"(x1) => (x1 & 2)\", str(_ & 2))\n        self.assertEqual(\"(x1) => (x1 | 2)\", str(_ | 2))\n        self.assertEqual(\"(x1) => (x1 ^ 2)\", str(_ ^ 2))\n\n        self.assertEqual(\"(x1) => (x1 >> 2)\", str(_ >> 2))\n        self.assertEqual(\"(x1) => (x1 << 2)\", str(_ << 2))\n\n        self.assertEqual(\"(x1) => (x1 < 2)\",  str(_ < 2))\n        self.assertEqual(\"(x1) => (x1 > 2)\",  str(_ > 2))\n        self.assertEqual(\"(x1) => (x1 <= 2)\", str(_ <= 2))\n        self.assertEqual(\"(x1) => (x1 >= 2)\", str(_ >= 2))\n        self.assertEqual(\"(x1) => (x1 == 2)\", str(_ == 2))\n        self.assertEqual(\"(x1) => (x1 != 2)\", str(_ != 2))\n\n        self.assertEqual(\"(x1) => ((x1 * 2) + 1)\", str((_ * 2 + 1)))\n\n    def test_rigthside_string_converting(self):\n        self.assertEqual(\"(x1) => (2 + x1)\",  str(2 + _))\n        self.assertEqual(\"(x1) => (2 - x1)\",  str(2 - _))\n        self.assertEqual(\"(x1) => (2 * x1)\",  str(2 * _))\n        self.assertEqual(\"(x1) => (2 / x1)\",  str(2 / _))\n        self.assertEqual(\"(x1) => (2 % x1)\",  str(2 % _))\n        self.assertEqual(\"(x1) => (2 ** x1)\", str(2 ** _))\n\n        self.assertEqual(\"(x1) => (2 & x1)\", str(2 & _))\n        self.assertEqual(\"(x1) => (2 | x1)\", str(2 | _))\n        self.assertEqual(\"(x1) => (2 ^ x1)\", str(2 ^ _))\n\n        self.assertEqual(\"(x1) => (2 >> x1)\", str(2 >> _))\n        self.assertEqual(\"(x1) => (2 << x1)\", str(2 << _))\n\n    def test_unary_string_converting(self):\n        self.assertEqual(\"(x1) => (+x1)\", str(+_))\n        self.assertEqual(\"(x1) => (-x1)\", str(-_))\n        self.assertEqual(\"(x1) => (~x1)\", str(~_))\n\n    def test_multiple_string_converting(self):\n        self.assertEqual(\"(x1, x2) => (x1 + x2)\", str(_ + _))\n        self.assertEqual(\"(x1, x2) => (x1 * x2)\", str(_ * _))\n        self.assertEqual(\"(x1, x2) => (x1 - x2)\", str(_ - _))\n        self.assertEqual(\"(x1, x2) => (x1 / x2)\", str(_ / _))\n        self.assertEqual(\"(x1, x2) => (x1 % x2)\", str(_ % _))\n        self.assertEqual(\"(x1, x2) => (x1 ** x2)\", str(_ ** _))\n\n        self.assertEqual(\"(x1, x2) => (x1 & x2)\", str(_ & _))\n        self.assertEqual(\"(x1, x2) => (x1 | x2)\", str(_ | _))\n        self.assertEqual(\"(x1, x2) => (x1 ^ x2)\", str(_ ^ _))\n\n        self.assertEqual(\"(x1, x2) => (x1 >> x2)\", str(_ >> _))\n        self.assertEqual(\"(x1, x2) => (x1 << x2)\", str(_ << _))\n\n        self.assertEqual(\"(x1, x2) => (x1 > x2)\",  str(_ > _))\n        self.assertEqual(\"(x1, x2) => (x1 < x2)\",  str(_ < _))\n        self.assertEqual(\"(x1, x2) => (x1 >= x2)\", str(_ >= _))\n        self.assertEqual(\"(x1, x2) => (x1 <= x2)\", str(_ <= _))\n        self.assertEqual(\"(x1, x2) => (x1 == x2)\", str(_ == _))\n        self.assertEqual(\"(x1, x2) => (x1 != x2)\", str(_ != _))\n\n        self.assertEqual(\"(x1, x2) => (((x1 / x2) - 1) * 100)\", str((_ / _ - 1) * 100))\n\n    def test_reverse_string_converting(self):\n        self.assertEqual(\"(x1, x2, x3) => ((x1 + x2) + x3)\", str(_ + _ + _))\n        self.assertEqual(\"(x1, x2, x3) => (x1 + (x2 * x3))\", str(_ + _ * _))\n\n        self.assertEqual(\"(x1) => (1 + (2 * x1))\", str((1 + 2 * _)))\n\n    def test_multi_underscore_string_converting(self):\n        self.assertEqual(\"(x1) => (x1 + '_')\", str(_ + \"_\"))\n        self.assertEqual(\"(x1, x2) => getattr((x1 + x2), '__and_now__')\", str((_ + _).__and_now__))\n        self.assertEqual(\"(x1, x2) => x1['__name__'][x2]\", str(_['__name__'][_]))\n\n    def test_repr(self):\n        self.assertEqual(_ / 2, eval(repr(_ / 2)))\n        self.assertEqual(_ + _, eval(repr(_ + _)))\n        self.assertEqual(_ + _ * _, eval(repr(_ + _ * _)))\n\n    def test_repr_parse_str(self):\n        self.assertEqual('=> ' + _, eval(repr('=> ' + _)))\n        self.assertEqual(\n            reduce(lambda f, n: f.format(n), ('({0} & _)',) * 11).format('_'),\n            repr(reduce(_ & _, (_,) * 12)),\n        )\n\nclass CompositionTestCase(unittest.TestCase):\n\n    def test_composition(self):\n        def f(x): return x * 2\n        def g(x): return x + 10\n\n        self.assertEqual(30, (F(f) << g)(5))\n\n        def z(x): return x * 20\n        self.assertEqual(220, (F(f) << F(g) << F(z))(5))\n\n    def test_partial(self):\n        # Partial should work if we pass additional arguments to F constructor\n        f = F(operator.add, 10) << F(operator.add, 5)\n        self.assertEqual(25, f(10))\n\n    def test_underscore(self):\n        self.assertEqual([1, 4, 9], list(map(F() << (_ ** 2) << _ + 1, range(3))))\n\n    def test_pipe_composition(self):\n        def f(x): return x * 2\n        def g(x): return x + 10\n\n        self.assertEqual(20, (F() >> f >> g)(5))\n\n    def test_pipe_partial(self):\n        func = F() >> (iters.filter, _ < 6) >> sum\n        self.assertEqual(15, func(iters.range(10)))\n\nclass IteratorsTestCase(unittest.TestCase):\n\n    def test_take(self):\n        self.assertEqual([0,1], list(iters.take(2, range(10))))\n        self.assertEqual([0,1], list(iters.take(10, range(2))))\n\n    def test_drop(self):\n        self.assertEqual([3,4], list(iters.drop(3, range(5))))\n        self.assertEqual([], list(iters.drop(10, range(2))))\n\n    def test_first_true(self):\n        pred = _ == 5\n        self.assertEqual(5, iters.first_true(range(1, 10), pred=pred))\n        self.assertEqual(999, iters.first_true(range(6, 10), default=999, pred=pred))\n\n    def test_takelast(self):\n        self.assertEqual([8,9], list(iters.takelast(2, range(10))))\n        self.assertEqual([0,1], list(iters.takelast(10, range(2))))\n\n    def test_droplast(self):\n        self.assertEqual([0,1], list(iters.droplast(3, range(5))))\n        self.assertEqual([], list(iters.droplast(10, range(2))))\n\n    def test_consume(self):\n        # full consuming, without limitation\n        r = iters.range(10)\n        self.assertEqual(10, len(list(r)))\n        itr = iter(r)\n        iters.consume(itr)\n        self.assertEqual(0, len(list(itr)))\n\n    def test_consume_limited(self):\n        r = iters.range(10)\n        self.assertEqual(10, len(list(r)))\n        itr = iter(r)\n        iters.consume(itr, 5)\n        self.assertEqual(5, len(list(itr)))\n\n    def test_nth(self):\n        self.assertEqual(1, iters.nth(range(5), 1))\n        self.assertEqual(None, iters.nth(range(5), 10))\n        self.assertEqual(\"X\", iters.nth(range(5), 10, \"X\"))\n\n    def test_head(self):\n        self.assertEqual(0, iters.head([0,1,2]))\n        self.assertEqual(None, iters.head([]))\n\n        def gen():\n            yield 1\n            yield 2\n            yield 3\n\n        self.assertEqual(1, iters.head(gen()))\n\n    def test_first(self):\n        self.assertEqual(iters.first, iters.head)  # Check if same object\n\n    def test_tail(self):\n        self.assertEqual([1,2], list(iters.tail([0,1,2])))\n        self.assertEqual([], list(iters.tail([])))\n\n        def gen():\n            yield 1\n            yield 2\n            yield 3\n\n        self.assertEqual([2,3], list(iters.tail(gen())))\n\n    def test_rest(self):\n        self.assertEqual(iters.rest, iters.tail)  # Check if same object\n\n    def test_second(self):\n        self.assertEqual(2, iters.second([1, 2, 3]))\n        self.assertEqual(None, iters.second([]))\n\n        def gen():\n            yield 10\n            yield 20\n            yield 30\n\n        self.assertEqual(20, iters.second(gen()))\n\n    def test_ffirst(self):\n        self.assertEqual(1, iters.ffirst([[1, 2], [3, 4]]))\n        self.assertEqual(None, iters.ffirst([[], [10, 20]]))\n\n        def gen():\n            yield (x * 10 for x in (10, 20, 30,))\n\n        self.assertEqual(100, iters.ffirst(gen()))\n\n    def test_compact(self):\n        self.assertEqual([True, 1, 0.1, \"non-empty\", [\"\"], (0,), {\"a\": 1}],\n                         list(iters.compact([None, False, True, 0, 1, 0.0, 0.1,\n                                             \"\", \"non-empty\", [], [\"\"],\n                                             (), (0,), {}, {\"a\": 1}])))\n\n    def test_every(self):\n        self.assertEqual(True, iters.every(_ % 2 == 0, [2, 4, 6]))\n        self.assertEqual(False, iters.every(_ % 2 == 0, [1, 3, 5]))\n        self.assertEqual(False, iters.every(_ % 2 == 0, [2, 4, 6, 7]))\n\n    def test_some(self):\n        self.assertEqual(\"one\",\n                         iters.some(lambda k: {1: \"one\", 2: \"two\"}.get(k, \"\"),\n                                    [1, 2]))\n        self.assertEqual(None,\n                         iters.some(lambda k: {1: \"one\", 2: \"two\"}.get(k, \"\"),\n                                    [4, 3]))\n        self.assertEqual(\"two\",\n                         iters.some(lambda k: {1: \"one\", 2: \"two\"}.get(k, \"\"),\n                                    [4, 3, 2]))\n\n    def test_reject(self):\n        self.assertEqual([1, 3, 5, 7, 9],\n                         list(iters.reject(_ % 2 == 0, range(1, 11))))\n        self.assertEqual([None, False, 0, 0.0, \"\", [], (), {}],\n                         list(iters.reject(None, [None, False, True, 0, 1,\n                                                  0.0, 0.1, \"\", \"non-empty\",\n                                                  [], [\"\"], (), (0,),\n                                                  {}, {\"a\": 1}])))\n\n    def test_iterate(self):\n        it = iters.iterate(lambda x: x * x, 2)\n        self.assertEqual(2, next(it))  # 2\n        self.assertEqual(4, next(it))  # 2 * 2\n        self.assertEqual(16, next(it))  # 4 * 4\n        self.assertEqual(256, next(it))  # 16 * 16\n\n    def test_padnone(self):\n        it = iters.padnone([10,11])\n        self.assertEqual(10, next(it))\n        self.assertEqual(11, next(it))\n        self.assertEqual(None, next(it))\n        self.assertEqual(None, next(it))\n\n    def test_ncycles(self):\n        it = iters.ncycles([10,11], 2)\n        self.assertEqual(10, next(it))\n        self.assertEqual(11, next(it))\n        self.assertEqual(10, next(it))\n        self.assertEqual(11, next(it))\n        self.assertRaises(StopIteration, next, it)\n\n    def test_repeatfunc(self):\n        def f():\n            return \"test\"\n\n        # unlimited count\n        it = iters.repeatfunc(f)\n        self.assertEqual(\"test\", next(it))\n        self.assertEqual(\"test\", next(it))\n        self.assertEqual(\"test\", next(it))\n\n        # limited\n        it = iters.repeatfunc(f, 2)\n        self.assertEqual(\"test\", next(it))\n        self.assertEqual(\"test\", next(it))\n        self.assertRaises(StopIteration, next, it)\n\n    def test_grouper(self):\n        # without fill value (default should be None)\n        a, b, c = iters.grouper(3, \"ABCDEFG\")\n        self.assertEqual([\"A\",\"B\",\"C\"], list(a))\n        self.assertEqual([\"D\",\"E\",\"F\"], list(b))\n        self.assertEqual([\"G\",None,None], list(c))\n\n        # with fill value\n        a, b, c = iters.grouper(3, \"ABCDEFG\", \"x\")\n        self.assertEqual([\"A\",\"B\",\"C\"], list(a))\n        self.assertEqual([\"D\",\"E\",\"F\"], list(b))\n        self.assertEqual([\"G\",\"x\",\"x\"], list(c))\n\n    def test_group_by(self):\n        # verify grouping logic\n        grouped = iters.group_by(len, ['1', '12', 'a', '123', 'ab'])\n        self.assertEqual({1: ['1', 'a'], 2: ['12', 'ab'], 3: ['123']}, grouped)\n\n        # verify it works with any iterable - not only lists\n        def gen():\n            yield '1'\n            yield '12'\n\n        grouped = iters.group_by(len, gen())\n        self.assertEqual({1: ['1'], 2: ['12']}, grouped)\n\n    def test_roundrobin(self):\n        r = iters.roundrobin('ABC', 'D', 'EF')\n        self.assertEqual([\"A\",\"D\",\"E\",\"B\",\"F\",\"C\"], list(r))\n\n    def test_partition(self):\n        def is_odd(x):\n            return x % 2 == 1\n\n        before, after = iters.partition(is_odd, iters.range(5))\n        self.assertEqual([0,2,4], list(before))\n        self.assertEqual([1,3], list(after))\n\n    def test_splitat(self):\n        before, after = iters.splitat(2, iters.range(5))\n        self.assertEqual([0,1], list(before))\n        self.assertEqual([2,3,4], list(after))\n\n    def test_splitby(self):\n        def is_even(x):\n            return x % 2 == 0\n\n        before, after = iters.splitby(is_even, iters.range(5))\n        self.assertEqual([0], list(before))\n        self.assertEqual([1, 2,3,4], list(after))\n\n    def test_powerset(self):\n        ps = iters.powerset([1,2])\n        self.assertEqual([tuple(),(1,),(2,),(1,2)], list(ps))\n\n    def test_pairwise(self):\n        ps = iters.pairwise([1,2,3,4])\n        self.assertEqual([(1,2),(2,3),(3,4)], list(ps))\n\n    def test_iter_except(self):\n        d = [\"a\", \"b\", \"c\"]\n        it = iters.iter_except(d.pop, IndexError)\n        self.assertEqual([\"c\", \"b\", \"a\"], list(it))\n\n    def test_flatten(self):\n        # flatten nested lists\n        self.assertEqual([1,2,3,4], list(iters.flatten([[1,2], [3,4]])))\n        self.assertEqual([1,2,3,4,5,6], list(iters.flatten([[1,2], [3, [4,5,6]]])))\n        # flatten nested tuples, sets, and frozen sets\n        self.assertEqual([1,2,3,4,5,6], list(iters.flatten(((1,2), (3, (4,5,6))))))\n        self.assertEqual([1,2,3], list(iters.flatten(set([1, frozenset([2,3])]))))\n        # flatten nested generators\n        generators = ((num + 1 for num in range(0, n)) for n in range(1, 4))\n        self.assertEqual([1,1,2,1,2,3], list(iters.flatten(generators)))\n        # flat list should return itself\n        self.assertEqual([1,2,3], list(iters.flatten([1,2,3])))\n        # Don't flatten strings, bytes, or bytearrays\n        self.assertEqual([2,\"abc\",1], list(iters.flatten([2,\"abc\",1])))\n        self.assertEqual([2, b'abc', 1], list(iters.flatten([2, b'abc', 1])))\n        self.assertEqual([2, bytearray(b'abc'), 1],\n                         list(iters.flatten([2, bytearray(b'abc'), 1])))\n\n    def test_accumulate(self):\n        self.assertEqual([1,3,6,10,15], list(iters.accumulate([1,2,3,4,5])))\n        self.assertEqual([1,2,6,24,120], list(iters.accumulate([1,2,3,4,5], operator.mul)))\n\n    def test_filterfalse(self):\n        l = iters.filterfalse(lambda x: x > 10, [1,2,3,11,12])\n        self.assertEqual([1,2,3], list(l))\n\nclass StreamTestCase(unittest.TestCase):\n\n    def test_from_list(self):\n        s = Stream() << [1,2,3,4,5]\n        self.assertEqual([1,2,3,4,5], list(s))\n        self.assertEqual(2, s[1])\n        self.assertEqual([1,2], list(s[0:2]))\n\n    def test_from_iterator(self):\n        s = Stream() << range(6) << [6,7]\n        self.assertEqual([0,1,2,3,4,5,6,7], list(s))\n\n    def test_from_generator(self):\n        def gen():\n            yield 1\n            yield 2\n            yield 3\n\n        s = Stream() << gen << (4,5)\n        assert list(s) == [1,2,3,4,5]\n\n    def test_lazy_slicing(self):\n        s = Stream() << iters.range(10)\n        self.assertEqual(s.cursor(), 0)\n\n        s_slice = s[:5]\n        self.assertEqual(s.cursor(), 0)\n        self.assertEqual(len(list(s_slice)), 5)\n\n    def test_lazy_slicing_recursive(self):\n        s = Stream() << iters.range(10)\n        sf = s[1:3][0:2]\n\n        self.assertEqual(s.cursor(), 0)\n        self.assertEqual(len(list(sf)), 2)\n\n    def test_fib_infinite_stream(self):\n        from operator import add\n\n        f = Stream()\n        fib = f << [0, 1] << iters.map(add, f, iters.drop(1, f))\n\n        self.assertEqual([0,1,1,2,3,5,8,13,21,34], list(iters.take(10, fib)))\n        self.assertEqual(6765, fib[20])\n        self.assertEqual([832040,1346269,2178309,3524578,5702887], list(fib[30:35]))\n        # 35 elements should be already evaluated\n        self.assertEqual(fib.cursor(), 35)\n\n    def test_origin_param(self):\n        self.assertEqual([100], list(Stream(100)))\n        self.assertEqual([1,2,3], list(Stream(1, 2, 3)))\n        self.assertEqual([1,2,3,10,20,30], list(Stream(1, 2, 3) << [10,20,30]))\n\n    def test_origin_param_string(self):\n        self.assertEqual([\"stream\"], list(Stream(\"stream\")))\n\nclass OptionTestCase(unittest.TestCase, InstanceChecker):\n\n    def test_create_option(self):\n        self.assertIsInstance(monad.Option(\"A\"), monad.Full)\n        self.assertIsInstance(monad.Option(10), monad.Full)\n        self.assertIsInstance(monad.Option(10, lambda x: x > 7), monad.Full)\n        self.assertIsInstance(monad.Option(None), monad.Empty)\n        self.assertIsInstance(monad.Option(False), monad.Full)\n        self.assertIsInstance(monad.Option(0), monad.Full)\n        self.assertIsInstance(monad.Option(False, checker=bool), monad.Empty)\n        self.assertIsInstance(monad.Option(0, checker=bool), monad.Empty)\n        self.assertIsInstance(monad.Option(10, lambda x: x > 70), monad.Empty)\n\n    def test_map_filter(self):\n        class Request(dict):\n            def parameter(self, name):\n                return monad.Option(self.get(name, None))\n\n        r = Request(testing=\"Fixed\", empty=\"   \")\n\n        # full chain\n        self.assertEqual(\"FIXED\", r.parameter(\"testing\")\n                                   .map(operator.methodcaller(\"strip\"))\n                                   .filter(len)\n                                   .map(operator.methodcaller(\"upper\"))\n                                   .get_or(\"\"))\n\n        # breaks on filter\n        self.assertEqual(\"\", r.parameter(\"empty\")\n                              .map(operator.methodcaller(\"strip\"))\n                              .filter(len)\n                              .map(operator.methodcaller(\"upper\"))\n                              .get_or(\"\"))\n\n        # breaks on parameter\n        self.assertEqual(\"\", r.parameter(\"missed\")\n                              .map(operator.methodcaller(\"strip\"))\n                              .filter(len)\n                              .map(operator.methodcaller(\"upper\"))\n                              .get_or(\"\"))\n\n    def test_empty_check(self):\n        self.assertTrue(monad.Empty().empty)\n        self.assertTrue(monad.Option(None).empty)\n        self.assertTrue(monad.Option.from_call(lambda: None).empty)\n        self.assertFalse(monad.Option(10).empty)\n        self.assertFalse(monad.Full(10).empty)\n\n    def test_lazy_orcall(self):\n        def from_mimetype(request):\n            # you can return both value or Option\n            return request.get(\"mimetype\", None)\n\n        def from_extension(request):\n            # you can return both value or Option\n            return monad.Option(request.get(\"url\", None))\\\n                        .map(lambda s: s.split(\".\")[-1])\n\n        # extract value from extension\n        r = dict(url=\"myfile.png\")\n        self.assertEqual(\"PNG\", monad.Option(r.get(\"type\", None)) \\\n                                     .or_call(from_mimetype, r) \\\n                                     .or_call(from_extension, r) \\\n                                     .map(operator.methodcaller(\"upper\")) \\\n                                     .get_or(\"\"))\n\n        # extract value from mimetype\n        r = dict(url=\"myfile.svg\", mimetype=\"png\")\n        self.assertEqual(\"PNG\", monad.Option(r.get(\"type\", None)) \\\n                                     .or_call(from_mimetype, r) \\\n                                     .or_call(from_extension, r) \\\n                                     .map(operator.methodcaller(\"upper\")) \\\n                                     .get_or(\"\"))\n\n        # type is set directly\n        r = dict(url=\"myfile.jpeg\", mimetype=\"svg\", type=\"png\")\n        self.assertEqual(\"PNG\", monad.Option(r.get(\"type\", None)) \\\n                                     .or_call(from_mimetype, r) \\\n                                     .or_call(from_extension, r) \\\n                                     .map(operator.methodcaller(\"upper\")) \\\n                                     .get_or(\"\"))\n\n    def test_optionable_decorator(self):\n        class Request(dict):\n            @monad.optionable\n            def parameter(self, name):\n                return self.get(name, None)\n\n        r = Request(testing=\"Fixed\", empty=\"   \")\n\n        # full chain\n        self.assertEqual(\"FIXED\", r.parameter(\"testing\")\n                                   .map(operator.methodcaller(\"strip\"))\n                                   .filter(len)\n                                   .map(operator.methodcaller(\"upper\"))\n                                   .get_or(\"\"))\n\n    def test_stringify(self):\n        self.assertEqual(\"Full(10)\", str(monad.Full(10)))\n        self.assertEqual(\"Full(in box!)\", str(monad.Full(\"in box!\")))\n        self.assertEqual(\"Empty()\", str(monad.Empty()))\n        self.assertEqual(\"Empty()\", str(monad.Option(None)))\n\n    def test_option_repr(self):\n        self.assertEqual(\"Full(10)\", repr(monad.Full(10)))\n        self.assertEqual(\"Full(in box!)\", repr(monad.Full(\"in box!\")))\n        self.assertEqual(\"Empty()\", repr(monad.Empty()))\n        self.assertEqual(\"Empty()\", repr(monad.Option(None)))\n\n    def test_static_constructor(self):\n        self.assertEqual(monad.Empty(),  monad.Option.from_value(None))\n        self.assertEqual(monad.Full(10), monad.Option.from_value(10))\n        self.assertEqual(monad.Empty(),  monad.Option.from_call(lambda: None))\n        self.assertEqual(monad.Full(10), monad.Option.from_call(operator.add, 8, 2))\n        self.assertEqual(monad.Empty(),\n                         monad.Option.from_call(lambda d, k: d[k],\n                                                {\"a\":1}, \"b\", exc=KeyError))\n\n    def test_flatten_operation(self):\n        self.assertEqual(monad.Empty(), monad.Empty(monad.Empty()))\n        self.assertEqual(monad.Empty(), monad.Empty(monad.Full(10)))\n        self.assertEqual(monad.Empty(), monad.Full(monad.Empty()))\n        self.assertEqual(\"Full(20)\", str(monad.Full(monad.Full(20))))\n\nclass TrampolineTestCase(unittest.TestCase):\n\n    def test_tco_decorator(self):\n\n        def recur_accumulate(origin, f=operator.add, acc=0):\n            n = next(origin, None)\n            if n is None: return acc\n            return recur_accumulate(origin, f, f(acc, n))\n\n        # this works normally\n        self.assertEqual(10, recur_accumulate(iter(range(5))))\n\n        limit = sys.getrecursionlimit() * 10\n        # such count of recursive calls should fail on CPython,\n        # for PyPy we skip this test cause on PyPy the limit is\n        # approximative and checked at a lower level\n        if not hasattr(sys, 'pypy_version_info'):\n            self.assertRaises(RuntimeError, recur_accumulate, iter(range(limit)))\n\n        # with recur decorator it should run without problems\n        @recur.tco\n        def tco_accumulate(origin, f=operator.add, acc=0):\n            n = next(origin, None)\n            if n is None: return False, acc\n            return True, (origin, f, f(acc, n))\n\n        self.assertEqual(sum(range(limit)), tco_accumulate(iter(range(limit))))\n\n    def test_tco_different_functions(self):\n\n        @recur.tco\n        def recur_inc2(curr, acc=0):\n            if curr == 0: return False, acc\n            return recur_dec, (curr-1, acc+2)\n\n        @recur.tco\n        def recur_dec(curr, acc=0):\n            if curr == 0: return False, acc\n            return recur_inc2, (curr-1, acc-1)\n\n        self.assertEqual(5000, recur_inc2(10000))\n\nclass UnionBasedHeapsTestCase(unittest.TestCase):\n\n    def _heap_basic_operations(self, cls):\n        # Create new heap with 3 elements\n        s1 = cls(10)\n        s2 = s1.insert(30)\n        s3 = s2.insert(20)\n\n        # Extract elements one-by-one\n        el1, sx1 = s3.extract()\n        el2, sx2 = sx1.extract()\n        el3, sx3 = sx2.extract()\n\n        # Check elements ordering\n        self.assertEqual(10, el1)\n        self.assertEqual(20, el2)\n        self.assertEqual(30, el3)\n\n        # Check that previous heap are persistent\n        el22, _ = sx1.extract()\n        self.assertEqual(20, el22)\n\n    def _heap_iterator(self, cls):\n        # Create new heap with 5 elements\n        h = cls(10)\n        h = h.insert(30)\n        h = h.insert(20)\n        h = h.insert(5)\n        h = h.insert(100)\n\n        # Convert to list using iterator\n        self.assertEqual([5, 10, 20, 30, 100], list(h))\n\n    def _heap_custom_compare(self, cls):\n        h = cls(cmp=lambda a,b: len(a) - len(b))\n        h = h.insert(\"give\")\n        h = h.insert(\"few words\")\n        h = h.insert(\"about\")\n        h = h.insert(\"union heaps\")\n        h = h.insert(\"implementation\")\n\n        # Convert to list using iterator\n        self.assertEqual([\"give\",\n                          \"about\",\n                          \"few words\",\n                          \"union heaps\",\n                          \"implementation\"], list(h))\n\n    def _heap_compare_with_keyfunc(self, cls):\n        from operator import itemgetter\n\n        # Create new heap with 5 elements\n        h = cls(key=itemgetter(1))\n        h = h.insert((10, 10))\n        h = h.insert((30, 15))\n        h = h.insert((20, 110))\n        h = h.insert((40, -10))\n        h = h.insert((50, 100))\n\n        # Convert to list using iterator\n        self.assertEqual([(40,-10), (10,10), (30,15), (50,100), (20,110)], list(h))\n\n    def test_skew_heap_basic(self):\n        self._heap_basic_operations(SkewHeap)\n\n    def test_pairing_heap_basic(self):\n        self._heap_basic_operations(PairingHeap)\n\n    def test_skew_heap_iterator(self):\n        self._heap_iterator(SkewHeap)\n\n    def test_pairing_heap_iterator(self):\n        self._heap_iterator(PairingHeap)\n\n    def test_skew_heap_key_func(self):\n        self._heap_compare_with_keyfunc(SkewHeap)\n\n    def test_pairing_heap_key_func(self):\n        self._heap_compare_with_keyfunc(PairingHeap)\n\n    def test_skew_heap_cmp_func(self):\n        self._heap_custom_compare(SkewHeap)\n\n    def test_pairing_heap_cmp_func(self):\n        self._heap_custom_compare(PairingHeap)\n\nclass LinkedListsTestCase(unittest.TestCase):\n\n    def test_linked_list_basic_operations(self):\n        l1 = LinkedList()\n        l2 = l1.cons(1)\n        l3 = l2.cons(2)\n        self.assertEqual(None, l1.head)\n        self.assertEqual(1, l2.head)\n        self.assertEqual(2, l3.head)\n        self.assertEqual(1, l3.tail.head)\n        self.assertEqual(None, l3.tail.tail.head)\n\n    def test_linked_list_num_of_elements(self):\n        self.assertEqual(0, len(LinkedList()))\n        self.assertEqual(3, len(LinkedList().cons(10).cons(20).cons(30)))\n\n    def tests_linked_list_iterator(self):\n        self.assertEqual([30, 20, 10], list(LinkedList().cons(10).cons(20).cons(30)))\n\n    def test_from_iterable(self):\n        expected = [10, 20, 30]\n        actual = list(LinkedList.from_iterable(expected))\n        self.assertEqual(actual, expected)\n\n        actual = LinkedList.from_iterable(tuple(expected))\n        self.assertEqual(list(actual), expected)\n\n        actual = LinkedList.from_iterable(iter(expected))\n        self.assertEqual(list(actual), expected)\n\n        actual = LinkedList.from_iterable(LinkedList().cons(30).cons(20).cons(10))\n        self.assertEqual(list(actual), expected)\n\n    def test_stack_push_pop_ordering(self):\n        s1 = Stack()\n        s2 = s1.push(1)\n        s3 = s2.push(10)\n        s4 = s3.push(100)\n        (sv4, s5) = s4.pop()\n        (sv3, s6) = s5.pop()\n        self.assertEqual(100, sv4)\n        self.assertEqual(10, sv3)\n        self.assertEqual(100, s4.pop()[0])\n\n    def test_stack_length(self):\n        self.assertEqual(0, len(Stack()))\n        self.assertEqual(3, len(Stack().push(1).push(2).push(3)))\n\n    def test_stack_is_empty_check(self):\n        self.assertTrue(Stack().push(100))\n        self.assertFalse(Stack().push(100).is_empty())\n        self.assertTrue(Stack().is_empty())\n\n    def test_pop_empty_stack_exception(self):\n        self.assertRaises(ValueError, Stack().pop)\n\n    def test_stack_iterator(self):\n        self.assertEqual([10, 5, 1], list(Stack().push(1).push(5).push(10)))\n        self.assertEqual(6, sum(Stack().push(1).push(2).push(3)))\n\nclass BankerQueueTestCase(unittest.TestCase):\n\n    def test_queue_basic_operations(self):\n        q1 = Queue()\n        q2 = q1.enqueue(1)\n        q3 = q2.enqueue(10)\n        q4 = q3.enqueue(100)\n        self.assertEqual(1, q4.dequeue()[0])\n        self.assertEqual(1, q3.dequeue()[0])\n        self.assertEqual(1, q2.dequeue()[0])\n        v1, q5 = q4.dequeue()\n        v2, q6 = q5.dequeue()\n        v3, q7 = q6.dequeue()\n        self.assertEqual(1, v1)\n        self.assertEqual(10, v2)\n        self.assertEqual(100, v3)\n        self.assertEqual(0, len(q7))\n\n    def test_queue_num_of_elements(self):\n        self.assertEqual(0, len(Queue()))\n        self.assertEqual(3, len(Queue().enqueue(1).enqueue(2).enqueue(3)))\n\n    def test_queue_is_empty(self):\n        self.assertTrue(Queue().is_empty())\n        self.assertFalse(Queue().enqueue(1).is_empty())\n        self.assertTrue(Queue().enqueue(1).dequeue()[1].is_empty())\n\n    def test_dequeue_from_empty(self):\n        self.assertRaises(ValueError, Queue().dequeue)\n\n    def test_iterator(self):\n        self.assertEqual([], list(Queue()))\n        self.assertEqual([1,2,3], list(Queue().enqueue(1).enqueue(2).enqueue(3)))\n        self.assertEqual(60, sum(Queue().enqueue(10).enqueue(20).enqueue(30)))\n\nclass VectorTestCase(unittest.TestCase):\n\n    def test_cons_operation(self):\n        v = Vector()\n        self.assertEqual(0, len(v))\n        v1 = v.cons(10)\n        self.assertEqual(1, len(v1))\n        self.assertEqual(0, len(v)) # previous value didn't change\n        up = reduce(lambda acc, el: acc.cons(el), range(513), Vector())\n        self.assertEqual(513, len(up))\n\n    def test_assoc_get_operations(self):\n        v = Vector()\n        v1 = v.assoc(0, 10)\n        v2 = v1.assoc(1, 20)\n        v3 = v2.assoc(2, 30)\n        self.assertEqual(10, v3.get(0))\n        self.assertEqual(20, v3.get(1))\n        self.assertEqual(30, v3.get(2))\n        # check persistence\n        v4 = v2.assoc(2, 50)\n        self.assertEqual(30, v3.get(2))\n        self.assertEqual(50, v4.get(2))\n        # long vector\n        up = reduce(lambda acc, el: acc.assoc(el, el*2), range(1500), Vector())\n        self.assertEqual(2800, up.get(1400))\n        self.assertEqual(2998, up.get(1499))\n\n    def test_pop_operations(self):\n        v = reduce(lambda acc, el: acc.cons(el), range(2000), Vector())\n        self.assertEqual(1999, len(v.pop()))\n        self.assertEqual(list(range(1999)), list(v.pop()))\n\n    def test_vector_iterator(self):\n        v = reduce(lambda acc, el: acc.assoc(el, el+1), range(1500), Vector())\n        self.assertEqual(list(range(1, 1501)), list(v))\n        self.assertEqual(1125750, sum(v))\n\n    def test_index_error(self):\n        v = reduce(lambda acc, el: acc.assoc(el, el+2), range(50), Vector())\n        self.assertRaises(IndexError, v.get, -1)\n        self.assertRaises(IndexError, v.get, 50)\n        self.assertRaises(IndexError, v.get, 52)\n\n    def test_setitem_should_not_be_implemented(self):\n        def f():\n            v = Vector().cons(20)\n            v[0] = 10\n        self.assertRaises(NotImplementedError, f)\n\n    def test_subvector_operation(self):\n        pass\n\nclass FingerTreeDequeTestCase(unittest.TestCase):\n\n    def test_deque_basic_operations(self):\n        d1 = Deque()\n        d2 = d1.push_back(1)\n        d3 = d2.push_back(2)\n        d4 = d3.push_back(3)\n        d5 = d4.push_front(10)\n        d6 = d5.push_front(20)\n        self.assertEqual(1, d4.head())\n        self.assertEqual(3, d4.last())\n        self.assertEqual(20, d6.head())\n        self.assertEqual(3, d6.last())\n\n    def test_deque_num_of_elements(self):\n        pass\n\n    def test_deque_is_empty(self):\n        self.assertTrue(Deque().is_empty())\n        self.assertFalse(Deque().push_back(1).is_empty())\n        self.assertTrue(Deque().push_back(1).tail().is_empty())\n\n    def test_iterator(self):\n        self.assertEqual([], list(Deque()))\n        self.assertEqual([1,2,3], list(Deque().push_back(1).push_back(2).push_back(3)))\n        self.assertEqual(60, sum(Deque().push_back(10).push_front(20).push_back(30)))\n        self.assertEqual(sum(range(1,20)), sum(Deque.from_iterable(range(1,20))))\n\nif __name__ == '__main__':\n    unittest.main()\n"
        }
      ]
    }
  ]
}