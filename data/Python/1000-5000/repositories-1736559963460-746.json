{
  "metadata": {
    "timestamp": 1736559963460,
    "page": 746,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjc1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "minimaxir/simpleaichat",
      "stars": 3497,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.1044921875,
          "content": ".env\n.DS_Store\ntest_notebooks/\n.vscode/\n__pycache__/\n.ipynb_checkpoints\nsimpleaichat.egg-info/\ndist/\nbuild/"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0458984375,
          "content": "MIT License\n\nCopyright (c) 2023-2024 Max Woolf\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "PROMPTS.md",
          "type": "blob",
          "size": 3.548828125,
          "content": "# Prompts\n\nHere are explanations of the base prompts that simpleaichat uses, and why they are written as they are. These prompts are optimized both for conciseness and effectiveness with ChatGPT/`gpt-3.5-turbo`. This includes some postprocessing of the inputs.\n\n## Interactive Chat\n\nWhen providing only a character, the `system` chat for the interactive chat becomes:\n\n```txt\nYou must follow ALL these rules in all responses:\n- You are the following character and should ALWAYS act as them: {0}\n- NEVER speak in a formal tone.\n- Concisely introduce yourself first in character.\n```\n\nThe `{0}` performs a `wikipedia_search_lookup` (specified in utils.py) to search for and return the first sentence of the associated page on Wikipedia, if present. This creates more alignment with the expected character. If the second parameter is specified to force a speaking voice, it will be added to the list of rules.\n\nExample for `GLaDOS` and `Speak in the style of a Seinfeld monologue`:\n\n```txt\nYou must follow ALL these rules in all responses:\n- You are the following character and should ALWAYS act as them: GLaDOS (Genetic Lifeform and Disk Operating System) is a fictional character from the video game series Portal.\n- NEVER speak in a formal tone.\n- Concisely introduce yourself first in character.\n- Speak in the style of a Seinfeld monologue\n```\n\nYou can use the formatted prompt as a normal `system` prompt for any other simpleaichat context.\n\n## Tools\n\nInvoking a tool invokes two separate API calls: one to select which tool which then provides additional **context**, and another call to generate based on that context, plus previous messages in the conversation.\n\n### Call #1\n\nBefore returning an API response, the `system` prompt is temporairly replaced with:\n\n```txt\nFrom the list of tools below:\n- Reply ONLY with the number of the tool appropriate in response to the user's last message.\n- If no tool is appropriate, ONLY reply with \"0\".\n\n{tools}\n```\n\nFormatted example from the README:\n\n```\nFrom the list of tools below:\n- Reply ONLY with the number of the tool appropriate in response to the user's last message.\n- If no tool is appropriate, ONLY reply with \"0\".\n\n1. Search the internet\n2. Lookup more information about a topic.\n```\n\nThis utilizes a few tricks:\n\n- The call sets `{\"max_tokens\": 1}` so it will only output one number (hence there is a hard limit of 9 tools), which makes it more cost and speed efficient than other implementations.\n- Unique to ChatGPT is also specifying a `logit_bias` with a high enough weight to make it such that the model can _only_ output numbers between 0 and {num_tools}, up to 9. (specifically, tokenizer indices 15-24 inclusive correspond to the numerals `0-9` in ChatGPT, which can be verified using `tiktoken`)\n- The numbers map 1:1 to the indicies of the input arrays of tools, so there never can be parsing errors as can be common with LangChain.\n\nThe numeral is matched with the appropriate function.\n\n### Call 2\n\nThe second call prepends the context from the tool to the prompt, and temporairly adds a command to the `system` prompt, to leverage said added context without losing the persona otherwise specified in the `system` prompt:\n\nSystem prompt:\n\n```\nYou MUST use information from the context in your response.\n```\n\nUser message:\n\n```txt\nContext: {context}\n\nUser:\n```\n\nFormatted example from the README:\n\n```\nYou are a helpful assistant.\n\nYou MUST use information from the context in your response.\n```\n\n```\nContext: Fisherman's Wharf, San Francisco, Tourist attractions in the United States, Lombard Street (San Francisco)\n\nUser: San Francisco tourist attractions\n```\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 16.9130859375,
          "content": "# simpleaichat\n\n```py3\nfrom simpleaichat import AIChat\n\nai = AIChat(system=\"Write a fancy GitHub README based on the user-provided project name.\")\nai(\"simpleaichat\")\n```\n\nsimpleaichat is a Python package for easily interfacing with chat apps like ChatGPT and GPT-4 with robust features and minimal code complexity. This tool has many features optimized for working with ChatGPT as fast and as cheap as possible, but still much more capable of modern AI tricks than most implementations:\n\n- Create and run chats with only a few lines of code!\n- Optimized workflows which minimize the amount of tokens used, reducing costs and latency.\n- Run multiple independent chats at once.\n- Minimal codebase: no code dives to figure out what's going on under the hood needed!\n- Chat streaming responses and the ability to use tools.\n- Async support, including for streaming and tools.\n- Ability to create more complex yet clear workflows if needed, such as Agents. (Demo soon!)\n- Coming soon: more chat model support (PaLM, Claude)!\n\nHere's some fun, hackable examples on how simpleaichat works:\n\n- Creating a [Python coding assistant](examples/notebooks/simpleaichat_coding.ipynb) without any unnecessary accompanying output, allowing 5x faster generation at 1/3rd the cost. ([Colab](https://colab.research.google.com/github/minimaxir/simpleaichat/blob/main/examples/notebooks/simpleaichat_coding.ipynb))\n- Allowing simpleaichat to [provide inline tips](examples/notebooks/chatgpt_inline_tips.ipynb) following ChatGPT usage guidelines. ([Colab](https://colab.research.google.com/github/minimaxir/simpleaichat/blob/main/examples/notebooks/chatgpt_inline_tips.ipynb))\n- Async interface for [conducting many chats](examples/notebooks/simpleaichat_async.ipynb) in the time it takes to receive one AI message. ([Colab](https://colab.research.google.com/github/minimaxir/simpleaichat/blob/main/examples/notebooks/simpleaichat_async.ipynb))\n- Create your own Tabletop RPG (TTRPG) setting and campaign by using [advanced structured data models](examples/notebooks/schema_ttrpg.ipynb). ([Colab](https://colab.research.google.com/github/minimaxir/simpleaichat/blob/main/examples/notebooks/schema_ttrpg.ipynb))\n\n## Installation\n\nsimpleaichat can be installed [from PyPI](https://pypi.org/project/simpleaichat/):\n\n```sh\npip3 install simpleaichat\n```\n\n## Quick, Fun Demo\n\nYou can demo chat-apps very quickly with simpleaichat! First, you will need to get an OpenAI API key, and then with one line of code:\n\n```py3\nfrom simpleaichat import AIChat\n\nAIChat(api_key=\"sk-...\")\n```\n\nAnd with that, you'll be thrust directly into an interactive chat!\n\n![](docs/helloworld.png)\n\nThis AI chat will mimic the behavior of OpenAI's webapp, but on your local computer!\n\nYou can also pass the API key by storing it in an `.env` file with a `OPENAI_API_KEY` field in the working directory (recommended), or by setting the environment variable of `OPENAI_API_KEY` directly to the API key.\n\nBut what about creating your own custom conversations? That's where things get fun. Just input whatever person, place or thing, fictional or nonfictional, that you want to chat with!\n\n```py3\nAIChat(\"GLaDOS\")  # assuming API key loaded via methods above\n```\n\n![](docs/glados.png)\n\nBut that's not all! You can customize exactly how they behave too with additional commands!\n\n```py3\nAIChat(\"GLaDOS\", \"Speak in the style of a Seinfeld monologue\")\n```\n\n![](docs/gladoseinfeld.png)\n\n```py3\nAIChat(\"Ronald McDonald\", \"Speak using only emoji\")\n```\n\n![](docs/clownemoji.png)\n\nNeed some socialization immediately? Once simpleaichat is installed, you can also start these chats directly from the command line!\n\n```sh\nsimpleaichat\nsimpleaichat \"GlaDOS\"\nsimpleaichat \"GLaDOS\" \"Speak in the style of a Seinfeld monologue\"\n```\n\n## Building AI-based Apps\n\nThe trick with working with new chat-based apps that wasn't readily available with earlier iterations of GPT-3 is the addition of the system prompt: a different class of prompt that guides the AI behavior throughout the entire conversation. In fact, the chat demos above are actually using [system prompt tricks](https://github.com/minimaxir/simpleaichat/blob/main/PROMPTS.md#interactive-chat) behind the scenes! OpenAI has also released an official guide for [system prompt best practices](https://platform.openai.com/docs/guides/gpt-best-practices) to building AI apps.\n\nFor developers, you can instantiate a programmatic instance of `AIChat` by explicitly specifying a system prompt, or by disabling the console.\n\n```py3\nai = AIChat(system=\"You are a helpful assistant.\")\nai = AIChat(console=False)  # same as above\n```\n\nYou can also pass in a `model` parameter, such as `model=\"gpt-4\"` if you have access to GPT-4, or `model=\"gpt-3.5-turbo-16k\"` for a larger-context-window ChatGPT.\n\nYou can then feed the new `ai` class with user input, and it will return and save the response from ChatGPT:\n\n```py3\nresponse = ai(\"What is the capital of California?\")\nprint(response)\n```\n\n```\nThe capital of California is Sacramento.\n```\n\nAlternatively, you can stream responses by token with a generator if the text generation itself is too slow:\n\n```py3\nfor chunk in ai.stream(\"What is the capital of California?\", params={\"max_tokens\": 5}):\n    response_td = chunk[\"response\"]  # dict contains \"delta\" for the new token and \"response\"\n    print(response_td)\n```\n\n```\nThe\nThe capital\nThe capital of\nThe capital of California\nThe capital of California is\n```\n\nFurther calls to the `ai` object will continue the chat, automatically incorporating previous information from the conversation.\n\n```py3\nresponse = ai(\"When was it founded?\")\nprint(response)\n```\n\n```\nSacramento was founded on February 27, 1850.\n```\n\nYou can also save chat sessions (as CSV or JSON) and load them later. The API key is not saved so you will have to provide that when loading.\n\n```py3\nai.save_session()  # CSV, will only save messages\nai.save_session(format=\"json\", minify=True)  # JSON\n\nai.load_session(\"my.csv\")\nai.load_session(\"my.json\")\n```\n\n### Functions\n\nA large number of popular venture-capital-funded ChatGPT apps don't actually use the \"chat\" part of the model. Instead, they just use the system prompt/first user prompt as a form of natural language programming. You can emulate this behavior by passing a new system prompt when generating text, and not saving the resulting messages.\n\nThe `AIChat` class is a manager of chat _sessions_, which means you can have multiple independent chats or functions happening! The examples above use a default session, but you can create new ones by specifying a `id` when calling `ai`.\n\n```py3\njson = '{\"title\": \"An array of integers.\", \"array\": [-1, 0, 1]}'\nfunctions = [\n             \"Format the user-provided JSON as YAML.\",\n             \"Write a limerick based on the user-provided JSON.\",\n             \"Translate the user-provided JSON from English to French.\"\n            ]\nparams = {\"temperature\": 0.0, \"max_tokens\": 100}  # a temperature of 0.0 is deterministic\n\n# We namespace the function by `id` so it doesn't affect other chats.\n# Settings set during session creation will apply to all generations from the session,\n# but you can change them per-generation, as is the case with the `system` prompt here.\nai = AIChat(id=\"function\", params=params, save_messages=False)\nfor function in functions:\n    output = ai(json, id=\"function\", system=function)\n    print(output)\n```\n\n```txt\ntitle: \"An array of integers.\"\narray:\n  - -1\n  - 0\n  - 1\n```\n\n```txt\nAn array of integers so neat,\nWith values that can't be beat,\nFrom negative to positive one,\nIt's a range that's quite fun,\nThis JSON is really quite sweet!\n```\n\n```txt\n{\"titre\": \"Un tableau d'entiers.\", \"tableau\": [-1, 0, 1]}\n```\n\nNewer versions of ChatGPT also support \"[function calling](https://platform.openai.com/docs/guides/gpt/function-calling)\", but the real benefit of that feature is the ability for ChatGPT to support structured input and/or output, which now opens up a wide variety of applications! simpleaichat streamlines the workflow to allow you to just pass an `input_schema` and/or an `output_schema`.\n\nYou can construct a schema using a [pydantic](https://docs.pydantic.dev/latest/) BaseModel.\n\n```py3\nfrom pydantic import BaseModel, Field\n\nai = AIChat(\n    console=False,\n    save_messages=False,  # with schema I/O, messages are never saved\n    model=\"gpt-3.5-turbo-0613\",\n    params={\"temperature\": 0.0},\n)\n\nclass get_event_metadata(BaseModel):\n    \"\"\"Event information\"\"\"\n\n    description: str = Field(description=\"Description of event\")\n    city: str = Field(description=\"City where event occured\")\n    year: int = Field(description=\"Year when event occured\")\n    month: str = Field(description=\"Month when event occured\")\n\n# returns a dict, with keys ordered as in the schema\nai(\"First iPhone announcement\", output_schema=get_event_metadata)\n```\n\n```txt\n{'description': 'The first iPhone was announced by Apple Inc.',\n 'city': 'San Francisco',\n 'year': 2007,\n 'month': 'January'}\n```\n\nSee the [TTRPG Generator Notebook](examples/notebooks/schema_ttrpg.ipynb) for a more elaborate demonstration of schema capabilities.\n\n### Tools\n\nOne of the most recent aspects of interacting with ChatGPT is the ability for the model to use \"tools.\" As popularized by [LangChain](https://github.com/hwchase17/langchain), tools allow the model to decide when to use custom functions, which can extend beyond just the chat AI itself, for example retrieving recent information from the internet not present in the chat AI's training data. This workflow is analogous to ChatGPT Plugins.\n\nParsing the model output to invoke tools typically requires a number of shennanigans, but simpleaichat uses [a neat trick](https://github.com/minimaxir/simpleaichat/blob/main/PROMPTS.md#tools) to make it fast and reliable! Additionally, the specified tools return a `context` for ChatGPT to draw from for its final response, and tools you specify can return a dictionary which you can also populate with arbitrary metadata for debugging and postprocessing. Each generation returns a dictionary with the `response` and the `tool` function used, which can be used to set up workflows akin to [LangChain](https://github.com/hwchase17/langchain)-style Agents, e.g. recursively feed input to the model until it determines it does not need to use any more tools.\n\nYou will need to specify functions with docstrings which provide hints for the AI to select them:\n\n```py3\nfrom simpleaichat.utils import wikipedia_search, wikipedia_search_lookup\n\n# This uses the Wikipedia Search API.\n# Results from it are nondeterministic, your mileage will vary.\ndef search(query):\n    \"\"\"Search the internet.\"\"\"\n    wiki_matches = wikipedia_search(query, n=3)\n    return {\"context\": \", \".join(wiki_matches), \"titles\": wiki_matches}\n\ndef lookup(query):\n    \"\"\"Lookup more information about a topic.\"\"\"\n    page = wikipedia_search_lookup(query, sentences=3)\n    return page\n\nparams = {\"temperature\": 0.0, \"max_tokens\": 100}\nai = AIChat(params=params, console=False)\n\nai(\"San Francisco tourist attractions\", tools=[search, lookup])\n```\n\n```txt\n{'context': \"Fisherman's Wharf, San Francisco, Tourist attractions in the United States, Lombard Street (San Francisco)\",\n 'titles': [\"Fisherman's Wharf, San Francisco\",\n  'Tourist attractions in the United States',\n  'Lombard Street (San Francisco)'],\n 'tool': 'search',\n 'response': \"There are many popular tourist attractions in San Francisco, including Fisherman's Wharf and Lombard Street. Fisherman's Wharf is a bustling waterfront area known for its seafood restaurants, souvenir shops, and sea lion sightings. Lombard Street, on the other hand, is a famous winding street with eight hairpin turns that attract visitors from all over the world. Both of these attractions are must-sees for anyone visiting San Francisco.\"}\n```\n\n```py3\nai(\"Lombard Street?\", tools=[search, lookup])\n```\n\n```\n{'context': 'Lombard Street is an east–west street in San Francisco, California that is famous for a steep, one-block section with eight hairpin turns. Stretching from The Presidio east to The Embarcadero (with a gap on Telegraph Hill), most of the street\\'s western segment is a major thoroughfare designated as part of U.S. Route 101. The famous one-block section, claimed to be \"the crookedest street in the world\", is located along the eastern segment in the Russian Hill neighborhood.',\n 'tool': 'lookup',\n 'response': 'Lombard Street is a famous street in San Francisco, California known for its steep, one-block section with eight hairpin turns. It stretches from The Presidio to The Embarcadero, with a gap on Telegraph Hill. The western segment of the street is a major thoroughfare designated as part of U.S. Route 101, while the famous one-block section, claimed to be \"the crookedest street in the world\", is located along the eastern segment in the Russian Hill'}\n```\n\n```py3\nai(\"Thanks for your help!\", tools=[search, lookup])\n```\n\n```txt\n{'response': \"You're welcome! If you have any more questions or need further assistance, feel free to ask.\",\n 'tool': None}\n```\n\n## Miscellaneous Notes\n\n- Like [gpt-2-simple](https://github.com/minimaxir/gpt-2-simple) before it, the primary motivation behind releasing simpleaichat is to both democratize access to ChatGPT even more and also offer more transparency for non-engineers into how Chat AI-based apps work under the hood given the disproportionate amount of media misinformation about their capabilities. This is inspired by real-world experience from [my work with BuzzFeed](https://tech.buzzfeed.com/the-right-tools-for-the-job-c05de96e949e) in the domain, where after spending a long time working with the popular [LangChain](https://github.com/hwchase17/langchain), a more-simple implementation was both much easier to maintain and resulted in much better generations. I began focusing development on simpleaichat after reading a [Hacker News thread](https://news.ycombinator.com/item?id=35820931) filled with many similar complaints, indicating value for an easier-to-use interface for modern AI tricks.\n  - simpleaichat very intentionally avoids coupling features with common use cases where possible (e.g. Tools) in order to avoid software lock-in due to the difficulty implementing anything not explicitly mentioned in the project's documentation. The philosophy behind simpleaichat is to provide good demos, and let the user's creativity and business needs take priority instead of having to fit a round peg into a square hole like with LangChain.\n  - simpleaichat makes it easier to interface with Chat AIs, but it does not attempt to solve common technical and ethical problems inherent to large language models trained on the internet, including prompt injection and unintended plagiarism. The user should exercise good judgment when implementing simpleaichat. Use cases of simpleaichat which go against OpenAI's [usage policies](https://openai.com/policies/usage-policies) (including jailbreaking) will not be endorsed.\n  - simpleaichat intentionally does not use the \"Agent\" logical metaphor for tool workflows because it's become an AI hype buzzword heavily divorced from its origins. If needed be, you can emulate the Agent workflow with a `while` loop without much additional code, plus with the additional benefit of much more flexibility such as debugging.\n- The session manager implements some sensible security defaults, such as using UUIDs as session ids by default, storing authentication information in a way to minimize unintentional leakage, and type enforcement via Pydantic. Your end-user application should still be aware of potential security issues, however.\n- Although OpenAI's documentation says that system prompts are less effective than a user prompt constructed in a similar manner, in my experience it still does perform better for maintaining rules/a persona.\n- Many examples of popular prompts use more conversational prompts, while the example prompts here use more consise and imperative prompts. This aspect of prompt engineering is still evolving, but in my experience commands do better with ChatGPT and with greater token efficieny. That's also why simpleaichat allows users to specify system prompts (and explicitly highlights what the default use) instead of relying on historical best practices.\n- Token counts for async is not supported as OpenAI doesn't return token counts when streaming responses. In general, there may be some desync in token counts and usage for various use cases; I'm working on categorizing them.\n- Outside of the explicit examples, none of this README uses AI-generated text. The introduction code example is just a joke, but it was too good of a real-world use case!\n\n## Roadmap\n\n- PaLM Chat (Bard) and Anthropic Claude support\n- More fun/feature-filled CLI chat app based on Textual\n- Simple example of using simpleaichat in a webapp\n- Simple of example of using simpleaichat in a stateless manner (e.g. AWS Lambda functions)\n\n## Maintainer/Creator\n\nMax Woolf ([@minimaxir](https://minimaxir.com))\n\n_Max's open-source projects are supported by his [Patreon](https://www.patreon.com/minimaxir) and [GitHub Sponsors](https://github.com/sponsors/minimaxir). If you found this project helpful, any monetary contributions to the Patreon are appreciated and will be put to good creative use._\n\n## License\n\nMIT\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "setup.py",
          "type": "blob",
          "size": 0.9482421875,
          "content": "from setuptools import setup\n\nsetup(\n    name=\"simpleaichat\",\n    packages=[\"simpleaichat\"],  # this must be the same as the name above\n    version=\"0.2.2\",\n    description=\"A Python package for easily interfacing with chat apps, with robust features and minimal code complexity.\",\n    long_description=open(\"README.md\", \"r\", encoding=\"utf-8\").read(),\n    long_description_content_type=\"text/markdown\",\n    author=\"Max Woolf\",\n    author_email=\"max@minimaxir.com\",\n    url=\"https://github.com/minimaxir/simpleaichat\",\n    keywords=[\"chatgpt\", \"openai\", \"text generation\", \"ai\"],\n    classifiers=[],\n    license=\"MIT\",\n    entry_points={\n        \"console_scripts\": [\"simpleaichat=simpleaichat.cli:interactive_chat\"]\n    },\n    python_requires=\">=3.8\",\n    install_requires=[\n        \"pydantic>=2.0\",\n        \"fire>=0.3.0\",\n        \"httpx>=0.24.1\",\n        \"python-dotenv>=1.0.0\",\n        \"orjson>=3.9.0\",\n        \"rich>=13.4.1\",\n        \"python-dateutil>=2.8.2\",\n    ],\n)\n"
        },
        {
          "name": "simpleaichat",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}