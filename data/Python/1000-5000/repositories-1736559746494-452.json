{
  "metadata": {
    "timestamp": 1736559746494,
    "page": 452,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQ2MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "shapely/shapely",
      "stars": 3973,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".circleci",
          "type": "tree",
          "content": null
        },
        {
          "name": ".clang-format",
          "type": "blob",
          "size": 0.06640625,
          "content": "BasedOnStyle:  Google\nDerivePointerAlignment: false\nColumnLimit: 90\n"
        },
        {
          "name": ".dockerignore",
          "type": "blob",
          "size": 0.2939453125,
          "content": "# Ignore everything\n**\n\n# Allow files and directories\n!/*.py\n!/*LICENSE*\n!/setup.cfg\n!/pyproject.toml\n!/shapely/**\n!/src/**\n!/tests/**\n\n# Ignore unnecessary files inside allowed directories\n# This should go after the allowed directories\n**/*~\n**/*.log\n**/.DS_Store\n**/Thumbs.db\n**/*.pyc\n**/*.so\n**/.*\n"
        },
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.0322265625,
          "content": "shapely/_version.py export-subst\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 1.0419921875,
          "content": "# Byte-compiled / optimized / DLL files\n__pycache__/\n*.py[cod]\n*$py.class\n\n# C extensions\n*.so\n*.dylib\n*.dll\n\n# Distribution / packaging\n.Python\nenv/\nbuild/\ndevelop-eggs/\ndist/\ndownloads/\neggs/\n.eggs/\nlib64/\nparts/\nsdist/\nvar/\n*.egg-info/\n.installed.cfg\n*.egg\n*.log\n*.whl\n# to make binary distributions (that pack additional licenses) not 'dirty':\n/LICENSE_GEOS\n/LICENSE_win32\n\n# PyInstaller\n#  Usually these files are written by a python script from a template\n#  before PyInstaller builds the exe, so as to inject date/other infos into it.\n*.manifest\n*.spec\n\n# Installer logs\npip-log.txt\npip-delete-this-directory.txt\n\n# Unit test / coverage reports\nhtmlcov/\n.tox/\n.coverage\n.coverage.*\n.cache\nnosetests.xml\ncoverage.xml\n*,cover\n.hypothesis/\n\n# pyenv python configuration file\n.python-version\n\n# PyCharm\n.idea\n\n# VS Code\n.vscode\n\n# Pipenv\n.venv\nPipfile\nPipfile.lock\n\n# Documentation\ndocs/_build/\ndocs/shapely.*.txt\ndocs/shapely.txt\ndocs/modules.txt\ndocs/_reference.rst\ndocs/reference/*\n\n# Benchmarks\n.asv\n\n# Cython C files\nshapely/*.c\n\n.ipynb_checkpoints\n.DS_Store\n"
        },
        {
          "name": ".mailmap",
          "type": "blob",
          "size": 0.896484375,
          "content": "Allan Adair <allan.m.adair@gmail.com> <allan@rfspot.com>\nAron Bierbaum <aronbierbaum@gmail.com> <aronbierbaum@b426a367-1105-0410-b9ff-cdf4ab011145>\nBrendan Ward <bcward@astutespruce.com>\nCasper van der Wel <caspervdw@gmail.com>\nCasper van der Wel <caspervdw@gmail.com> <casper.vanderwel@nelen-schuurmans.nl>\nFilipe Fernandes <ocefpaf@gmail.com>\nFrédéric Junod <frederic.junod@camptocamp.com>\nKai Lautaportti <dokai@b426a367-1105-0410-b9ff-cdf4ab011145>\nKevin Wurster <wursterk@gmail.com> <kevin@skytruth.org>\nKonstantin Veretennicov <kveretennicov@gmail.com> <kveretennicov+github@gmail.com>\nMike Taves <mwtoews@gmail.com>\nMike Taves <mwtoews@gmail.com> <mwtoews@debian.(none)>\nSean Gillies <sean.gillies@gmail.com>\nSean Gillies <sean.gillies@gmail.com> <seang@b426a367-1105-0410-b9ff-cdf4ab011145>\nSean Gillies <sean.gillies@gmail.com> <seang@krusty-2.local>\nSean Gillies <sean.gillies@gmail.com> <sean@mapbox.com>\n"
        },
        {
          "name": ".pre-commit-config.yaml",
          "type": "blob",
          "size": 0.5830078125,
          "content": "repos:\n  - repo: https://github.com/pre-commit/pre-commit-hooks\n    rev: v4.6.0\n    hooks:\n    - id: check-yaml\n    - id: end-of-file-fixer\n    - id: trailing-whitespace\n  - repo: https://github.com/astral-sh/ruff-pre-commit\n    rev: v0.5.2\n    hooks:\n      # Run the linter.\n      - id: ruff\n        args: [ --fix ]\n      # Run the formatter.\n      - id: ruff-format\n  - repo: https://github.com/PyCQA/doc8\n    rev: v1.1.2\n    hooks:\n      - id: doc8\n  - repo: https://github.com/citation-file-format/cffconvert\n    rev: 054bda51dbe278b3e86f27c890e3f3ac877d616c\n    hooks:\n    - id: validate-cff\n"
        },
        {
          "name": ".readthedocs.yml",
          "type": "blob",
          "size": 0.7705078125,
          "content": "# .readthedocs.yml\n# Read the Docs configuration file\n# See https://docs.readthedocs.io/en/stable/config-file/v2.html for details\n\n# Required\nversion: 2\n\nbuild:\n  os: \"ubuntu-20.04\"\n  tools:\n    python: \"mambaforge-4.10\"\n  jobs:\n    post_checkout:\n      # we need the tags for versioneer to work\n      - git fetch origin --depth 150\n      - git fetch --tags\n    pre_install:\n      # to avoid \"dirty\" version\n      - git update-index --assume-unchanged docs/environment.yml docs/conf.py\n\n# Build documentation in the docs/ directory with Sphinx\nsphinx:\n  configuration: docs/conf.py\n  fail_on_warning: false\n\n# Optionally build your docs in additional formats such as PDF and ePub\nformats: all\n\nconda:\n  environment: docs/environment.yml\n\npython:\n  install:\n    - method: pip\n      path: .\n"
        },
        {
          "name": "CHANGES.txt",
          "type": "blob",
          "size": 15.984375,
          "content": "Changes\n=======\n\n2.1.0 (unreleased)\n------------------\n\nBug fixes:\n\n- Prevent crash when serializing a number > 1e100 to WKT with GEOS < 3.13. (#1907)\n- Fixes GeoJSON serialization of empty points (#2118)\n- Fixes `__geo_interface__` handling of empty points (#2120)\n- Fixes crash when reading nonlinear geometry types (CircularString,\n  CompoundCurve, MultiCurve, CurvePolygon, MultiSurface) from WKB/WKT with\n  GEOS >= 3.13; these types are not yet supported in Shapely and now raise a\n  ``NotImplementedError`` (#2160)\n\nImprovements:\n\n- Require GEOS >= 3.9, NumPy >= 1.20, and Python >= 3.9 (#1802, #1885, #2124)\n- Handle ``Feature`` type in ``shapely.geometry.shape`` (#1815)\n- Add a ``handle_nan`` parameter to ``shapely.linestrings()`` and ``shapely.linearrings()``\n  to allow, skip, or error on nonfinite (NaN / Inf) coordinates. The default\n  behaviour (allow) is backwards compatible (#1594).\n- Add an ``interleaved`` parameter to ``shapely.transform()`` allowing a transposed call\n  signature in the ``transformation`` function.\n- The ``include_z`` in ``shapely.transform()`` now also allows ``None``, which\n  lets it automatically detect the dimensionality of each input geometry.\n- Add parameters ``method`` and ``keep_collapsed`` to ``shapely.make_valid()`` (#1941)\n- Upgraded the GEOS version in the binary wheel distributions to 3.12.1.\n- Add ``disjoint_subset_union`` and ``disjoint_subset_union_all`` as an optimized\n  version of union and union_all, assuming inputs can be divided into subsets that do\n  not intersect. Requires at least GEOS 3.12.\n- The ``voronoi_polygons`` now accepts the ``ordered`` keyword, optionally forcing the\n  order of polygons within the GeometryCollection to follow the order of input\n  coordinates. Requires at least GEOS 3.12. (#1968)\n- Add option on ``invalid=\"fix\"`` to ``from_wkb`` and ``from_wkt`` (#2094)\n- Add function ``minimum_clearance_line`` (#2106)\n- Add function ``maximum_inscribed_circle`` (#1307)\n\nBreaking changes in GEOS 3.12:\n\n- ``oriented_envelope`` / ``minimum_rotated_rectangle`` changed its implementation\n  in GEOS 3.12. Be aware that results will change when updating GEOS. Coincidentally\n  the implementation is similar to the shapely 1.x approach. (#1885)\n- ``get_coordinate_dimension`` / ``has_z`` now considers geometries three dimensional if\n  they have a NaN z coordinate. (#1885)\n- ``voronoi_polygons`` changed its output from a LINESTRING to a MULTILINESTRING in case\n  ``only_edges=True``. (#1885)\n- The WKT representation of a MULTIPOINT changed from for example \"MULTIPOINT (0 0, 1 1)\"\n  to \"MULTIPOINT ((0 0), (1 1))\". (#1885)\n\nDeprecations:\n\n- The ``shapely.geos`` module is deprecated. All GEOS-version related attributes are\n  available directly from the top-level ``shapely`` namespace as well (already since\n  shapely 2.0) (#2145).\n- The ``shapely.vectorized`` module is deprecated. The two functions (``contains and\n  ``touches``) can be replaced by the top-level vectorized functions ``contains_xy``\n  and ``intersects_xy`` (#1630).\n\nPackaging:\n\n- Binary wheels are now built for musllinux (Alpine) x86_64 platforms (#1996).\n\n\n2.0.6 (2024-08-19)\n------------------\n\nBug fixes:\n\n- Fix compatibility with NumPy 2.1.0 (#2099).\n\nWheels are available for Python 3.13 (and still include GEOS 3.11.4).\n\n2.0.5 (2024-07-13)\n------------------\n\nBinary wheels on PyPI include GEOS 3.11.4 from 2024-06-05. Furthermore,\nuniversal2 wheels are removed for macOS since both x86_64 and arm64 wheels are\nprovided.\n\nBug fixes:\n\n- Fix Point x/y/z attributes to return Python floats (#2074).\n- Fix affinity for Apple silicon with NumPy 2.0 by reverting matmul, and\n  use direct matrix multiplication instead (#2085).\n\n2.0.4 (2024-04-16)\n------------------\n\nWheels for Python versions >= 3.9 will be compatible with the upcoming NumPy 2.0\nrelease (as well as with supported NumPy 1.x versions).\n\nBug fixes:\n\n- Fix bug in ``to_wkt`` with multiple empty Z geometries (#2012).\n- Fix bug in ``to_ragged_array`` for an array of Points with missing values (#2034).\n\n\n2.0.3 (2024-02-16)\n------------------\n\n- Fix regression in the ``oriented_envelope`` ufunc to accept array-like input\n  in case of GEOS<3.12 (#1929).\n- The binary wheels are not yet compatible with a future NumPy 2.0 release,\n  therefore a ``numpy<2`` upper pin was added to the requirements (#1972).\n- Upgraded the GEOS version in the binary wheel distributions to 3.11.3.\n\n\n2.0.2 (2023-10-12)\n------------------\n\nBug fixes:\n\n- Fix regression in the (in)equality comparison (``geom1 == geom2``) using ``__eq__`` to\n  not ignore the z-coordinates (#1732).\n- Fix ``MultiPolygon()`` constructor to accept polygons without holes (#1850).\n- Fix ``minimum_rotated_rectangle`` (``oriented_envelope``) to always return\n  the minimum area solution (instead of minimum width). In practice, it will use the\n  GEOS implementation only for GEOS 3.12+, and for older GEOS versions fall back to the\n  implementation that was included in Shapely < 2 (#1670).\n- Fix ``from_ragged_array`` to work with read-only array input (#1744).\n- Fix the handling of z coordinates ``shapely.ops.substring`` (#1699).\n\nWheels are available for Python 3.12 (and still include GEOS 3.11.2). Building\nfrom source is now compatible with Cython 3.\n\nFor a full changelog, see\nhttps://shapely.readthedocs.io/en/latest/release/2.x.html#version-2-0-2\n\n2.0.1 (2023-01-30)\n------------------\n\nBug fixes:\n\n- Fix regression in the ``Polygon()`` constructor taking a sequence of Points (#1662).\n- Fix regression in the geometry constructors when passing ``decimal.Decimal``\n  coordinate values (#1707).\n- Fix ``STRtree()`` to not make the passed geometry array immutable as side-effect of\n  the constructor (#1714).\n- Fix the ``directed`` keyword in ``shapely.ops.linemerge()`` (#1695).\n\nImprovements:\n\n- Expose the function to get a matplotlib Patch object from a (Multi)Polygon (without\n  already plotting it) publicly as :func:`shapely.plotting.patch_from_polygon` (#1704).\n\nFor a full changelog, see\nhttps://shapely.readthedocs.io/en/latest/release/2.x.html#version-2-0-1\n\n\n2.0.0 (2022-12-12)\n------------------\n\nShapely version 2.0.0 is a major release featuring a complete refactor of the\ninternals and new vectorized (element-wise) array operations providing\nconsiderable performance improvements.\n\nFor a full changelog, see\nhttps://shapely.readthedocs.io/en/latest/release/2.x.html#version-2-0-0\n\n\nRelevant changes in behaviour compared to 2.0rc3:\n\n- Added temporary support for unpickling shapely<2.0 geometries.\n\n2.0rc1 (2022-11-26)\n-------------------\n\nRelevant changes in behaviour compared to 2.0b2:\n\n- The ``Point(..)`` constructor no longer accepts a sequence of coordinates\n  consisting of more than one coordinate pair (previously, subsequent\n  coordinates were ignored) (#1600).\n- Fix performance regression in the ``LineString()`` constructor when passing\n  a numpy array of coordinates (#1602).\n\nWheels for 2.0rc1 published on PyPI include GEOS 3.11.1.\n\n2.0b2 (2022-10-29)\n------------------\n\nRelevant changes in behaviour compared to 2.0b1:\n\n- Fix for compatibility with PyPy (#1577).\n- Fix to the ``Point()`` constructor to accept arrays of length 1 for the x and y\n  coordinates (fix compatibility with Shapely 1.8).\n- Raise ValueError for non-finite distance in the ``buffer()`` and ``offset_curve()``\n  methods on the Geometry classes (consistent with Shapely 1.8).\n\n2.0b1 (2022-10-17)\n------------------\n\nRelevant changes in behaviour compared to 2.0a1:\n\n- Renamed the ``tolerance`` keyword to ``max_segment_length`` in the\n  ``segmentize`` function.\n- Renamed the ``quadsegs`` keyword in the top-level ``buffer`` and\n  ``offset_curve`` functions and the ``resolution`` keyword in the Geometry\n  class ``buffer`` and ``offset_curve`` methods all to ``quad_segs``.\n- Added use of ``GEOSGeom_getExtent`` to speed up bounds calculations for\n  GEOS >= 3.11.\n- Restored the behaviour of ``unary_union`` to return an empty GeometryCollection\n  for an empty or all-None sequence as input (and the same for ``intersection_all``\n  and ``symmetric_difference_all``).\n- Fixed the Geometry objects to be weakref-able again (#1535).\n- The ``.type`` attribute is deprecated, use ``.geom_type`` instead (which\n  already existed before as well) (#1492).\n\nWheels for 2.0b1 published on PyPI include GEOS 3.11.0.\n\n2.0a1 (2022-08-03)\n------------------\n\nShapely version 2.0 alpha 1 is the first of a major release featuring a\ncomplete refactor of the internals and new vectorized (element-wise) array\noperations providing considerable performance improvements. For a full\nchangelog, see https://shapely.readthedocs.io/en/latest/release/2.x.html#version-2-0-0\n\nWheels for 2.0a1 published on PyPI include GEOS 3.10.3.\n\n1.8.5.post1 (2022-10-13)\n------------------------\n\nPackaging:\n\nWheels are provided for Python versions 3.6-3.11 and Cython 0.29.32 is used to\ngenerate C extension module code.\n\n1.8.5 (2022-10-12)\n------------------\n\nPackaging:\n\nPython 3.11 wheels have been added to the matrix for all platforms.\n\nBug fixes:\n\n- Assign _lgeos in the macos frozen app check, fixing a bug introduced in 1.8.2\n  (#1528).\n- An exception is now raised when nan is passed to buffer and parallel_offset,\n  preventing segmentation faults (#1516).\n\n1.8.4 (2022-08-17)\n------------------\n\nBug fixes:\n\n- The new c_geom_p type caused a regression and has been removed (#1487).\n\n1.8.3 (2022-08-16)\n------------------\n\nDeprecations:\n\nThe STRtree class will be changed in 2.0.0 and will not be compatible with the\nclass in versions 1.8.x. This change obsoletes the deprecation announcement in\n1.8a3 (below).\n\nPackaging:\n\nWheels for 1.8.3 published on PyPI include GEOS 3.10.3.\n\nBug fixes:\n\n- The signature for GEOSMinimumClearance has been corrected, fixing an issue\n  affecting aarch64-darwin (#1480)\n- Return and arg types have been corrected and made more strict for area,\n  length, and distance properties.\n- A new c_geom_p type has been created to replace c_void_p when calling GEOS\n  functions (#1479).\n- An incorrect polygon-line intersection (#1427) has been fixed in GEOS 3.10.3,\n  which will be included in wheels published to PyPI.\n- GEOS buffer parameters are now destroyed, fixing a memory leak (#1440).\n\n1.8.2 (2022-05-03)\n------------------\n\n- Make Polygons and MultiPolygons closed by definition, like LinearRings.\n  Resolves #1246.\n- Perform frozen app check for GEOS before conda env check on macos as we\n  already do on linux (#1301).\n- Fix leak of GEOS coordinate sequence in nearest_points reported in #1098.\n\n1.8.1.post1 (2022-02-17)\n------------------------\n\nThis post-release addresses a defect in the 1.8.1 source distribution. No .c\nfiles are included in the 1.8.1.post1 sdist and Cython is required to build and\ninstall from source.\n\n1.8.1 (2022-02-16)\n------------------\n\nPackaging:\n\nWheels for 1.8.1 published on PyPI include GEOS 3.10.2. This version is the\nbest version of GEOS yet. Discrepancies in behavior compared to previous\nversions are considered to be improvements.\n\nFor the first time, we will publish wheels for macos_arm64 (see PR #1310).\n\nPython version support:\n\nShapely 1.8.1 works with Pythons 3.6-3.10.\n\nBug fixes:\n\n- Require Cython >= 0.29.24 to support Python 3.10 (#1224).\n- Fix array_interface_base (#1235).\n\n1.8.0 (2021-10-25)\n------------------\n\nThis is the final 1.8.0 release. There have been no changes since 1.8rc2.\n\n1.8rc2 (2021-10-19)\n-------------------\n\nBuild:\n\nA pyproject.toml file has been added to specify build dependencies for the\n_vectorized and _speedups modules (#1128). To install shapely without these\nbuild dependencies, use the features of your build tool that disable PEP 517\nand 518 support.\n\nBug fixes:\n\n- Part of PR #1042, which added a new primary GEOS library name to be searched\n  for, has been reverted by PR #1201.\n\n1.8rc1 (2021-10-04)\n-------------------\n\nDeprecations:\n\nThe almost_exact() method of BaseGeometry has been deprecated. It is confusing\nand will be removed in 2.0.0. The equals_exact() method is to be used instead.\n\nBug fixes:\n\n- We ensure that the _speedups module is always imported before _vectorized to\n  avoid an unexplained condition on Windows with Python 3.8 and 3.9 (#1184).\n\n1.8a3 (2021-08-24)\n------------------\n\nDeprecations:\n\nThe STRtree class deprecation warnings have been removed. The class in 2.0.0\nwill be backwards compatible with the class in 1.8.0.\n\nBug fixes:\n\n- The __array_interface__ raises only AttributeError, all other exceptions are\n  deprecated starting with Numpy 1.21 (#1173).\n- The STRtree class now uses a pair of item, geom sequences internally instead\n  of a dict (#1177).\n\n\n1.8a2 (2021-07-15)\n------------------\n\nPython version support:\n\nShapely 1.8 will support only Python versions >= 3.6.\n\nNew features:\n\n- The STRtree nearest*() methods now take an optional argument that\n  specifies exclusion of the input geometry from results (#1115).\n- A GeometryTypeError has been added to shapely.errors and is consistently\n  raised instead of TypeError or ValueError as in version 1.7. For backwards\n  compatibility, the new exception will derive from TypeError and Value error\n  until version 2.0 (#1099).\n- The STRtree class constructor now takes an optional second argument, a\n  sequence of objects to be stored in the tree. If not provided, the sequence\n  indices of the geometries will be stored, as before (#1112).\n- The STRtree class has new query_geoms(), query_items(), nearest_geom(), and\n  nearest_item() methods (#1112). The query() and nearest() methods remain as\n  aliases for query_geoms() and nearest_geom().\n\nBug fixes:\n\n- We no longer attempt to load libc to get the free function on Linux, but get\n  it from the global symbol table.\n- GEOS error messages printed when GEOS_getCoordSeq() is passed an empty\n  geometry are avoided by never passing an empty geometry (#1134).\n- Python's builtin super() is now used only as described in PEP 3135 (#1109).\n- Only load conda GEOS dll if it exists (on Windows) (#1108).\n- Add /opt/homebrew/lib to the list of directories to be searched for the GEOS\n  shared library.\n- Added new library search path to assist app creation with cx_Freeze.\n\n1.8a1 (2021-03-03)\n------------------\n\nShapely 1.8.0 will be a transitional version. There are a few bug fixes and new\nfeatures, but it is mainly about warning of the upcoming changes in 2.0.0.\nSeveral more pre-releases before 1.8.0 are expected. See the migration guide\nto Shapely 1.8 / 2.0 for more details on how to update your code\n(https://shapely.readthedocs.io/en/latest/migration.html).\n\nPython version support:\n\nShapely 1.8 will support only Python versions >= 3.5 (#884).\n\nDeprecations:\n\nThe following functions and geometry attributes and methods will be removed in\nversion 2.0.0.\n\n- ops.cascaded_union\n- geometry .empty()\n- geometry .ctypes and .__array_interface__\n- multi-part geometry .__len__\n- setting custom attributes on geometry objects\n\nGeometry objects will become immutable in version 2.0.0.\n\nThe STRtree class will be entirely changed in 2.0.0. The exact future API is\nnot yet decided, but will be decided before 1.8.0 is released.\n\nDeprecation warnings will be emitted in 1.8a1 when any of these features are\nused.\n\nThe deprecated .to_wkb() and .to_wkt() methods on the geometry objects have\nbeen removed.\n\nNew features:\n\n- Add a normalize() method to geometry classes, exposing the GEOSNormalize\n  algorithm (#1090).\n- Initialize STRtree with a capacity of 10 items per node (#1070).\n- Load libraries relocated to shapely/.libs by auditwheel versions < 3.1 or\n  relocated to Shapely.libs by auditwheel versions >= 3.1.\n- shapely.ops.voronoi_diagram() computes the Voronoi Diagram of a geometry or\n  geometry collection (#833, #851).\n- shapely.validation.make_valid() fixes invalid geometries (#883)\n\nBug fixes:\n\n- For pyinstaller we now handle the case of more than one GEOS library in the\n  environment, such as when fiona and rasterio wheels are co-installed with\n  shapely (#1071).\n- The ops.split function now splits on touch to eliminate confusing\n  discrepancies between results using multi and single part splitters (#1034).\n- Several issues with duplication and order of vertices in ops.substring have\n  been fixed (#1008).\n\nPackaging:\n\n- The wheels uploaded to PyPI will include GEOS 3.9.1.\n\nPrevious releases\n-----------------\n\nFor older releases in the 1.x line, see https://shapely.readthedocs.io/en/latest/release/1.x.html\n"
        },
        {
          "name": "CITATION.cff",
          "type": "blob",
          "size": 1.025390625,
          "content": "cff-version: 1.2.0\nmessage: \"Please cite this software using these metadata.\"\ntype: software\ntitle: Shapely\nversion: \"2.0.6\"\ndate-released: \"2024-08-19\"\ndoi: 10.5281/zenodo.5597138\nabstract: \"Manipulation and analysis of geometric objects in the Cartesian plane.\"\nrepository-artifact: https://pypi.org/project/Shapely\nrepository-code: https://github.com/shapely/shapely\nlicense: \"BSD-3-Clause\"\nauthors:\n  - given-names: Sean\n    family-names: Gillies\n    orcid: https://orcid.org/0000-0002-8401-9184\n  - given-names: Casper\n    family-names: \"van der Wel\"\n    orcid: https://orcid.org/0000-0002-0488-2237\n  - given-names: Joris\n    family-names: \"Van den Bossche\"\n    orcid: https://orcid.org/0000-0003-3284-2977\n  - given-names: \"Mike W.\"\n    family-names: Taves\n    orcid: https://orcid.org/0000-0003-3657-7963\n  - given-names: Joshua\n    family-names: Arnott\n  - given-names: \"Brendan C.\"\n    family-names: Ward\n    orcid: https://orcid.org/0000-0002-0813-9774\n  - name: others\nkeywords:\n  - cartography\n  - geometry\n  - GEOS\n  - GIS\n  - topology\n"
        },
        {
          "name": "CODE_OF_CONDUCT.md",
          "type": "blob",
          "size": 1.9375,
          "content": "# Contributor Code of Conduct\n\nAs contributors and maintainers of this project, and in the interest of fostering an open and welcoming community, we pledge to respect all people who contribute through reporting issues, posting feature requests, updating documentation, submitting pull requests or patches, and other activities.\n\nWe are committed to making participation in this project a harassment-free experience for everyone, regardless of level of experience, gender, gender identity and expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion, or nationality.\n\nExamples of unacceptable behavior by participants include:\n\n* The use of sexualized language or imagery\n* Personal attacks\n* Trolling or insulting/derogatory comments\n* Public or private harassment\n* Publishing other's private information, such as physical or electronic addresses, without explicit permission\n* Other unethical or unprofessional conduct.\n\nProject maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct. By adopting this Code of Conduct, project maintainers commit themselves to fairly and consistently applying these principles to every aspect of managing this project. Project maintainers who do not follow or enforce the Code of Conduct may be permanently removed from the project team.\n\nThis code of conduct applies both within project spaces and in public spaces when an individual is representing the project or its community.\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be reported by opening an issue or contacting one or more of the project maintainers.\n\nThis Code of Conduct is adapted from the [Contributor Covenant](https://contributor-covenant.org), version 1.2.0, available at [https://contributor-covenant.org/version/1/2/0/](https://contributor-covenant.org/version/1/2/0/)\n"
        },
        {
          "name": "CREDITS.txt",
          "type": "blob",
          "size": 5.91796875,
          "content": "Credits\n=======\n\nShapely is written by:\n\n* Adi Shavit <adishavit@gmail.com>\n* Alan D. Snow <alansnow21@gmail.com>\n* Alberto Rubiales <arubiales11@gmail.com>\n* Allan Adair <allan.m.adair@gmail.com>\n* Andrew Blakey <ablakey@gmail.com>\n* Andy Freeland <andy@andyfreeland.net>\n* Ariel Kadouri <ariel@arielsartistry.com>\n* Aron Bierbaum <aronbierbaum@gmail.com>\n* Bart Broere <2715782+bartbroere@users.noreply.github.com>\n* Bas Couwenberg <sebastic@xs4all.nl>\n* Ben Beasley <code@musicinmybrain.net>\n* Benjamin Root <ben.v.root@gmail.com>\n* BertrandGervais <bertrand.gervais.pro@gmail.com>\n* Bhavika Tekwani <4955119+bhavika@users.noreply.github.com>\n* Bi0T1N <Bi0T1N@users.noreply.github.com>\n* Brad Hards <bradh@frogmouth.net>\n* Brendan Ward <bcward@astutespruce.com>\n* Brandon Wood <btwood@geometeor.com>\n* Casper van der Wel <caspervdw@gmail.com>\n* Chad Hawkins <cwh@chadwhawkins.com>\n* Christian Prior <cprior@gmail.com>\n* Christian Quest <github@cquest.org>\n* Christophe Pradal <christophe.pradal@inria.fr>\n* Dan Baston <dbaston@gmail.com>\n* Dan Mahr <danmahr23@gmail.com>\n* Daniele Esposti <expobrain@users.noreply.github.com>\n* Dave Collins <dave@hopest.net>\n* David Baumgold <david@davidbaumgold.com>\n* David Swinkels <davidswinkelss@gmail.com>\n* Denis Rykov <rykovd@gmail.com>\n* Enrico Ferreguti <enricofer@gmail.com>\n* Erwin Sterrenburg <e.w.sterrenburg@gmail.com>\n* Ewout ter Hoeven <E.M.terHoeven@student.tudelft.nl>\n* Felix Divo <4403130+felixdivo@users.noreply.github.com>\n* Felix Yan <felixonmars@archlinux.org>\n* Filipe Fernandes <ocefpaf@gmail.com>\n* Frédéric Junod <frederic.junod@camptocamp.com>\n* Gabi Davar <grizzly.nyo@gmail.com>\n* Gerrit Holl <gerrit.holl@dwd.de>\n* Hannes <kannes@users.noreply.github.com>\n* Hao Zheng <Furioushaozheng@gmail.com>\n* Henry Walshaw <henry.walshaw@gmail.com>\n* Howard Butler <hobu.inc@gmail.com>\n* Hugo <hugovk@users.noreply.github.com>\n* Idan Miara <idan@miara.com>\n* Jacob Wasserman <jwasserman@gmail.com>\n* Jaeha Lee <jaehaaheaj@gmail.com>\n* James Douglass <jamesdouglassusa@gmail.com>\n* James Gaboardi <jgaboardi@gmail.com>\n* James Lamb <jaylamb20@gmail.com>\n* James McBride <jdmcbr@gmail.com>\n* James Spencer <james.s.spencer@gmail.com>\n* Jamie Hall <jamie1212@gmail.com>\n* Jason Sanford <jason.sanford@mapmyfitness.com>\n* Jeethu Rao <jeethu@jeethurao.com>\n* Jeremiah England <34973839+Jeremiah-England@users.noreply.github.com>\n* Jinkun Wang <mejkunw@gmail.com>\n* Johan Euphrosine <proppy@aminche.com>\n* Johannes Schönberger <jschoenberger@demuc.de>\n* Jonathan Schoonhoven <jschoonhoven@lyft.com>\n* Joris Van den Bossche <jorisvandenbossche@gmail.com>\n* Joshua Arnott <josh@snorfalorpagus.net>\n* Juan Luis Cano Rodríguez <juanlu@satellogic.com>\n* Justin Shenk <shenk.justin@gmail.com>\n* Kai Lautaportti <dokai@b426a367-1105-0410-b9ff-cdf4ab011145>\n* Kelsey Jordahl <kjordahl@enthought.com>\n* Kevin Wurster <wursterk@gmail.com>\n* Konstantin Veretennicov <kveretennicov@gmail.com>\n* Koshy Thomas <koshy1123@gmail.com>\n* Krishna Chaitanya <bkchaitan94@gmail.com>\n* Kristian Evers <kristianevers@gmail.com>\n* Kyle Barron <kylebarron2@gmail.com>\n* Leandro Lima <leandro@limaesilva.com.br>\n* Lukasz <uhho@users.noreply.github.com>\n* Luke Lee <durdenmisc@gmail.com>\n* Maarten Vermeyen <maarten.vermeyen@rwo.vlaanderen.be>\n* Marc Jansen <jansen@terrestris.de>\n* Marco De Nadai <me@marcodena.it>\n* Martin Fleischmann <martin@martinfleischmann.net>\n* Mathieu <mathieu.nivel@gmail.com>\n* Matt Amos <matt.amos@mapzen.com>\n* Matthias Cuntz <mcuntz@users.noreply.github.com>\n* MejstrikRudolf <68251685+MejstrikRudolf@users.noreply.github.com>\n* Michael K <michael-k@users.noreply.github.com>\n* Michel Blancard <michel.blancard@data.gouv.fr>\n* Mike Taves <mwtoews@gmail.com>\n* Morris Tweed <tweed.morris@gmail.com>\n* Naveen Michaud-Agrawal <naveen.michaudagrawal@gmail.com>\n* Oliver Tonnhofer <olt@bogosoft.com>\n* Paveł Tyślacki <tbicr@users.noreply.github.com>\n* Peter Sagerson <psagers.github@ignorare.net>\n* Phil Elson <pelson.pub@gmail.com>\n* Pierre PACI <villerupt@gmail.com>\n* Raja Gangopadhya <raja.gangopadhya@ridewithvia.com>\n* Ricardo Zilleruelo <51384295+zetaatlyft@users.noreply.github.com>\n* Rémy Phelipot <remy-phelipot@users.noreply.github.com>\n* S Murthy <sr-murthy@users.noreply.github.com>\n* Sampo Syrjanen <sampo.syrjanen@here.com>\n* Samuel Chin <samuelchin91@gmail.com>\n* Sean Gillies <sean.gillies@gmail.com>\n* Sobolev Nikita <mail@sobolevn.me>\n* Stephan Hügel <urschrei@gmail.com>\n* Steve M. Kim <steve@climate.com>\n* Taro Matsuzawa aka. btm <btm@tech.email.ne.jp>\n* Thibault Deutsch <thibault.deutsch@gmail.com>\n* Thomas Gratier <thomas_gratier@yahoo.fr>\n* Thomas Kluyver <takowl@gmail.com>\n* Tim Gates <tim.gates@iress.com>\n* Tobias Sauerwein <tobias.sauerwein@camptocamp.com>\n* Tom Caruso <carusot42@gmail.com>\n* Tom Clancy <17627475+clncy@users.noreply.github.com>\n* WANG Aiyong <gepcelway@gmail.com>\n* Will May <williamcmay@live.com>\n* Zachary Ware <zachary.ware@gmail.com>\n* aharfoot <aharfoot@users.noreply.github.com>\n* bstadlbauer <11799671+bstadlbauer@users.noreply.github.com>\n* cclauss <cclauss@me.com>\n* clefrks <33859587+clefrks@users.noreply.github.com>\n* davidh-ssec <david.hoese@ssec.wisc.edu>\n* georgeouzou <geothrock@gmail.com>\n* giumas <gmasetti@ccom.unh.edu>\n* gpapadok <38889721+gpapadok@users.noreply.github.com>\n* joelostblom <joelostblom@users.noreply.github.com>\n* ljwolf <levi.john.wolf@gmail.com>\n* mindw <grizzly.nyo@gmail.com>\n* rsmb <rsmb@users.noreply.github.com>\n* shongololo <garethsimons@me.com>\n* solarjoe <walterwhite666@googlemail.com>\n* sshuair <sshuair@gmail.com>\n* stephenworsley <49274989+stephenworsley@users.noreply.github.com>\n\nSee also: https://github.com/shapely/shapely/graphs/contributors.\n\nAdditional help from:\n\n* Justin Bronn (GeoDjango) for ctypes inspiration\n* Martin Davis (JTS)\n* Sandro Santilli, Mateusz Loskot, Paul Ramsey, et al (GEOS Project)\n\nMajor portions of this work were supported by a grant (for Pleiades_) from the\nU.S. National Endowment for the Humanities (https://www.neh.gov).\n\n.. _Pleiades: https://pleiades.stoa.org\n"
        },
        {
          "name": "FAQ.rst",
          "type": "blob",
          "size": 1.45703125,
          "content": "Frequently asked questions and answers\n======================================\n\nI installed shapely in a conda environment using pip. Why doesn't it work?\n--------------------------------------------------------------------------\n\nShapely versions < 2.0 load a GEOS shared library using ctypes. It's not\nuncommon for users to have multiple copies of GEOS libs on their system.\nLoading the correct one is complicated and shapely has a number of\nplatform-dependent GEOS library loading bugs. The project has particularly poor\nsupport for finding the correct GEOS library for a shapely package installed\nfrom PyPI *into* a conda environment. We recommend that conda users always get\nshapely from conda-forge.\n\nAre there references for the algorithms used by shapely?\n--------------------------------------------------------\n\nGenerally speaking, shapely's predicates and operations are derived from\nmethods of the same name from GEOS_ and the `JTS Topology Suite`_.  See the\n`JTS FAQ`_ for references describing the JTS algorithms.\n\nI used .buffer() on a geometry with Z coordinates. Where did the Z coordinates go?\n----------------------------------------------------------------------------------\n\nThe buffer algorithm in GEOS_ is purely two-dimensional and discards any Z\ncoordinates. This is generally the case for the GEOS algorithms.\n\n\n.. _GEOS: https://libgeos.org/\n.. _JTS Topology Suite: https://locationtech.github.io/jts/\n.. _JTS FAQ: https://locationtech.github.io/jts/jts-faq.html#E1\n"
        },
        {
          "name": "ISSUE_TEMPLATE.md",
          "type": "blob",
          "size": 0.697265625,
          "content": "## Please note\n\nIf you are reporting an installation or module import issue, please note that\nthis project only accepts reports about problems with packages downloaded from\nthe Python Package Index. Conda users should take issues to one of the\nfollowing trackers:\n\n- https://github.com/ContinuumIO/anaconda-issues/issues\n- https://github.com/conda-forge/shapely-feedstock\n\n## Expected behavior and actual behavior.\n\n(For example: the area of my geometry is `1.417` when it should be `1.414`.)\n\n## Steps to reproduce the problem.\n\n(For example, a script with required data)\n\n## Operating system\n\n(For example, Mac OS X 10.12.3)\n\n## Shapely version and provenance\n\n(For example, 1.6b4 installed from PyPI using pip)\n"
        },
        {
          "name": "LICENSE.txt",
          "type": "blob",
          "size": 1.5458984375,
          "content": "BSD 3-Clause License\n\nCopyright (c) 2007, Sean C. Gillies. 2019, Casper van der Wel. 2007-2022, Shapely Contributors.\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this\n   list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\n   this list of conditions and the following disclaimer in the documentation\n   and/or other materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its\n   contributors may be used to endorse or promote products derived from\n   this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "MANIFEST.in",
          "type": "blob",
          "size": 0.2607421875,
          "content": "prune docs\nexclude *.txt\nexclude MANIFEST.in\ninclude CITATION.cff CHANGES.txt CREDITS.txt LICENSE.txt README.rst\ninclude pyproject.toml versioneer.py\nrecursive-include src *.c *.h\nrecursive-include shapely *.pxd *.pyx\nrecursive-exclude shapely *.c\ninclude docs/*.rst\n"
        },
        {
          "name": "README.rst",
          "type": "blob",
          "size": 5.10546875,
          "content": "=======\nShapely\n=======\n\n.. Documentation at RTD — https://readthedocs.org\n\n.. image:: https://readthedocs.org/projects/shapely/badge/?version=stable\n   :alt: Documentation Status\n   :target: https://shapely.readthedocs.io/en/stable/\n\n.. Github Actions status — https://github.com/shapely/shapely/actions\n\n.. |github-actions| image:: https://github.com/shapely/shapely/workflows/Tests/badge.svg?branch=main\n   :alt: Github Actions status\n   :target: https://github.com/shapely/shapely/actions?query=branch%3Amain\n\n.. PyPI\n\n.. image:: https://img.shields.io/pypi/v/shapely.svg\n   :alt: PyPI\n   :target: https://pypi.org/project/shapely/\n\n.. Anaconda\n\n.. image:: https://img.shields.io/conda/vn/conda-forge/shapely\n   :alt: Anaconda\n   :target: https://anaconda.org/conda-forge/shapely\n\n.. Coverage\n\n.. |coveralls| image:: https://coveralls.io/repos/github/shapely/shapely/badge.svg?branch=main\n   :target: https://coveralls.io/github/shapely/shapely?branch=main\n\n.. Zenodo\n\n.. .. image:: https://zenodo.org/badge/191151963.svg\n..   :alt: Zenodo\n..   :target: https://zenodo.org/badge/latestdoi/191151963\n\nManipulation and analysis of geometric objects in the Cartesian plane.\n\n.. image:: https://c2.staticflickr.com/6/5560/31301790086_b3472ea4e9_c.jpg\n   :width: 800\n   :height: 378\n\nShapely is a BSD-licensed Python package for manipulation and analysis of\nplanar geometric objects. It is using the widely deployed open-source\ngeometry library `GEOS <https://libgeos.org/>`__ (the engine of `PostGIS\n<https://postgis.net/>`__, and a port of `JTS <https://locationtech.github.io/jts/>`__).\nShapely wraps GEOS geometries and operations to provide both a feature rich\n`Geometry` interface for singular (scalar) geometries and higher-performance\nNumPy ufuncs for operations using arrays of geometries.\nShapely is not primarily focused on data serialization formats or coordinate\nsystems, but can be readily integrated with packages that are.\n\nWhat is a ufunc?\n----------------\n\nA universal function (or ufunc for short) is a function that operates on\n*n*-dimensional arrays on an element-by-element fashion and supports array\nbroadcasting. The underlying ``for`` loops are implemented in C to reduce the\noverhead of the Python interpreter.\n\nMultithreading\n--------------\n\nShapely functions generally support multithreading by releasing the Global\nInterpreter Lock (GIL) during execution. Normally in Python, the GIL prevents\nmultiple threads from computing at the same time. Shapely functions\ninternally release this constraint so that the heavy lifting done by GEOS can\nbe done in parallel, from a single Python process.\n\nUsage\n=====\n\nHere is the canonical example of building an approximately circular patch by\nbuffering a point, using the scalar Geometry interface:\n\n.. code-block:: pycon\n\n    >>> from shapely import Point\n    >>> patch = Point(0.0, 0.0).buffer(10.0)\n    >>> patch\n    <POLYGON ((10 0, 9.952 -0.98, 9.808 -1.951, 9.569 -2.903, 9.239 -3.827, 8.81...>\n    >>> patch.area\n    313.6548490545941\n\nUsing the vectorized ufunc interface (instead of using a manual for loop),\ncompare an array of points with a polygon:\n\n.. code:: python\n\n    >>> import shapely\n    >>> import numpy as np\n    >>> geoms = np.array([Point(0, 0), Point(1, 1), Point(2, 2)])\n    >>> polygon = shapely.box(0, 0, 2, 2)\n\n    >>> shapely.contains(polygon, geoms)\n    array([False,  True, False])\n\nSee the documentation for more examples and guidance: https://shapely.readthedocs.io\n\nRequirements\n============\n\nShapely 2.1 requires\n\n* Python >=3.9\n* GEOS >=3.9\n* NumPy >=1.20\n\nInstalling Shapely\n==================\n\nWe recommend installing Shapely using one of the available built\ndistributions, for example using ``pip`` or ``conda``:\n\n.. code-block:: console\n\n    $ pip install shapely\n    # or using conda\n    $ conda install shapely --channel conda-forge\n\nSee the `installation documentation <https://shapely.readthedocs.io/en/latest/installation.html>`__\nfor more details and advanced installation instructions.\n\nIntegration\n===========\n\nShapely does not read or write data files, but it can serialize and deserialize\nusing several well known formats and protocols. The shapely.wkb and shapely.wkt\nmodules provide dumpers and loaders inspired by Python's pickle module.\n\n.. code-block:: pycon\n\n    >>> from shapely.wkt import dumps, loads\n    >>> dumps(loads('POINT (0 0)'))\n    'POINT (0.0000000000000000 0.0000000000000000)'\n\nShapely can also integrate with other Python GIS packages using GeoJSON-like\ndicts.\n\n.. code-block:: pycon\n\n    >>> import json\n    >>> from shapely.geometry import mapping, shape\n    >>> s = shape(json.loads('{\"type\": \"Point\", \"coordinates\": [0.0, 0.0]}'))\n    >>> s\n    <POINT (0 0)>\n    >>> print(json.dumps(mapping(s)))\n    {\"type\": \"Point\", \"coordinates\": [0.0, 0.0]}\n\nSupport\n=======\n\nQuestions about using Shapely may be asked on the `GIS StackExchange\n<https://gis.stackexchange.com/questions/tagged/shapely>`__ using the \"shapely\"\ntag.\n\nBugs may be reported at https://github.com/shapely/shapely/issues.\n\nCopyright & License\n===================\n\nShapely is licensed under BSD 3-Clause license.\nGEOS is available under the terms of GNU Lesser General Public License (LGPL) 2.1 at https://libgeos.org.\n"
        },
        {
          "name": "asv.conf.json",
          "type": "blob",
          "size": 6.548828125,
          "content": "{\n    // The version of the config file format.  Do not change, unless\n    // you know what you are doing.\n    \"version\": 1,\n\n    // The name of the project being benchmarked\n    \"project\": \"shapely\",\n\n    // The project's homepage\n    \"project_url\": \"https://github.com/shapely/shapely\",\n\n    // The URL or local path of the source code repository for the\n    // project being benchmarked\n    \"repo\": \".\",\n\n    // The Python project's subdirectory in your repo.  If missing or\n    // the empty string, the project is assumed to be located at the root\n    // of the repository.\n    // \"repo_subdir\": \"\",\n\n    // Customizable commands for building, installing, and\n    // uninstalling the project. See asv.conf.json documentation.\n    //\n    // \"install_command\": [\"in-dir={env_dir} python -mpip install {wheel_file}\"],\n    // \"uninstall_command\": [\"return-code=any python -mpip uninstall -y {project}\"],\n    // \"build_command\": [\n    //     \"python setup.py build\",\n    //     \"PIP_NO_BUILD_ISOLATION=false python -mpip wheel --no-deps --no-index -w {build_cache_dir} {build_dir}\"\n    // ],\n\n    // List of branches to benchmark. If not provided, defaults to \"master\"\n    // (for git) or \"default\" (for mercurial).\n    // \"branches\": [\"master\"], // for git\n    // \"branches\": [\"default\"],    // for mercurial\n\n    // The DVCS being used.  If not set, it will be automatically\n    // determined from \"repo\" by looking at the protocol in the URL\n    // (if remote), or by looking for special directories, such as\n    // \".git\" (if local).\n    // \"dvcs\": \"git\",\n\n    // The tool to use to create environments.  May be \"conda\",\n    // \"virtualenv\" or other value depending on the plugins in use.\n    // If missing or the empty string, the tool will be automatically\n    // determined by looking for tools on the PATH environment\n    // variable.\n    \"environment_type\": \"conda\",\n\n    // timeout in seconds for installing any dependencies in environment\n    // defaults to 10 min\n    //\"install_timeout\": 600,\n\n    // the base URL to show a commit for the project.\n    \"show_commit_url\": \"http://github.com/shapely/shapely/commit/\",\n\n    // The Pythons you'd like to test against.  If not provided, defaults\n    // to the current version of Python used to run `asv`.\n    \"pythons\": [\"3.12\"],\n\n    // The list of conda channel names to be searched for benchmark\n    // dependency packages in the specified order\n    \"conda_channels\": [\"conda-forge\"],\n\n    // The matrix of dependencies to test.  Each key is the name of a\n    // package (in PyPI) and the values are version numbers.  An empty\n    // list or empty string indicates to just test against the default\n    // (latest) version. null indicates that the package is to not be\n    // installed. If the package to be tested is only available from\n    // PyPi, and the 'environment_type' is conda, then you can preface\n    // the package name by 'pip+', and the package will be installed via\n    // pip (with all the conda available packages installed first,\n    // followed by the pip installed packages).\n    //\n    \"matrix\": {\n        \"Cython\": [],\n        \"numpy\": [],\n        \"geos\": []\n    },\n\n    // Combinations of libraries/python versions can be excluded/included\n    // from the set to test. Each entry is a dictionary containing additional\n    // key-value pairs to include/exclude.\n    //\n    // An exclude entry excludes entries where all values match. The\n    // values are regexps that should match the whole string.\n    //\n    // An include entry adds an environment. Only the packages listed\n    // are installed. The 'python' key is required. The exclude rules\n    // do not apply to includes.\n    //\n    // In addition to package names, the following keys are available:\n    //\n    // - python\n    //     Python version, as in the *pythons* variable above.\n    // - environment_type\n    //     Environment type, as above.\n    // - sys_platform\n    //     Platform, as in sys.platform. Possible values for the common\n    //     cases: 'linux2', 'win32', 'cygwin', 'darwin'.\n    //\n    // \"exclude\": [\n    //     {\"python\": \"3.2\", \"sys_platform\": \"win32\"}, // skip py3.2 on windows\n    //     {\"environment_type\": \"conda\", \"six\": null}, // don't run without six on conda\n    // ],\n    //\n    // \"include\": [\n    //     // additional env for python2.7\n    //     {\"python\": \"2.7\", \"numpy\": \"1.8\"},\n    //     // additional env if run on windows+conda\n    //     {\"platform\": \"win32\", \"environment_type\": \"conda\", \"python\": \"2.7\", \"libpython\": \"\"},\n    // ],\n\n    // The directory (relative to the current directory) that benchmarks are\n    // stored in.  If not provided, defaults to \"benchmarks\"\n    // \"benchmark_dir\": \"benchmarks\",\n\n    // The directory (relative to the current directory) to cache the Python\n    // environments in.  If not provided, defaults to \"env\"\n    \"env_dir\": \".asv/env\",\n\n    // The directory (relative to the current directory) that raw benchmark\n    // results are stored in.  If not provided, defaults to \"results\".\n    \"results_dir\": \".asv/results\",\n\n    // The directory (relative to the current directory) that the html tree\n    // should be written to.  If not provided, defaults to \"html\".\n    \"html_dir\": \".asv/html\"\n\n    // The number of characters to retain in the commit hashes.\n    // \"hash_length\": 8,\n\n    // `asv` will cache results of the recent builds in each\n    // environment, making them faster to install next time.  This is\n    // the number of builds to keep, per environment.\n    // \"build_cache_size\": 2,\n\n    // The commits after which the regression search in `asv publish`\n    // should start looking for regressions. Dictionary whose keys are\n    // regexps matching to benchmark names, and values corresponding to\n    // the commit (exclusive) after which to start looking for\n    // regressions.  The default is to start from the first commit\n    // with results. If the commit is `null`, regression detection is\n    // skipped for the matching benchmark.\n    //\n    // \"regressions_first_commits\": {\n    //    \"some_benchmark\": \"352cdf\",  // Consider regressions only after this commit\n    //    \"another_benchmark\": null,   // Skip regression detection altogether\n    // },\n\n    // The thresholds for relative change in results, after which `asv\n    // publish` starts reporting regressions. Dictionary of the same\n    // form as in ``regressions_first_commits``, with values\n    // indicating the thresholds.  If multiple entries match, the\n    // maximum is taken. If no entry matches, the default is 5%.\n    //\n    // \"regressions_thresholds\": {\n    //    \"some_benchmark\": 0.01,     // Threshold of 1%\n    //    \"another_benchmark\": 0.5,   // Threshold of 50%\n    // },\n}\n"
        },
        {
          "name": "benchmarks",
          "type": "tree",
          "content": null
        },
        {
          "name": "ci",
          "type": "tree",
          "content": null
        },
        {
          "name": "docker",
          "type": "tree",
          "content": null
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "pyproject.toml",
          "type": "blob",
          "size": 4.12109375,
          "content": "[build-system]\nrequires = [\n    \"Cython\",\n    # Starting with NumPy 1.25, NumPy is (by default) as far back compatible\n    # as oldest-support-numpy was (customizable with a NPY_TARGET_VERSION\n    # define).\n    \"numpy>=1.25,<3\",\n    \"setuptools>=61.0.0\",\n]\nbuild-backend = \"setuptools.build_meta\"\n\n[project]\nname = \"shapely\"\ndynamic = [\"version\"]\nauthors = [\n    {name = \"Sean Gillies\"},\n]\nmaintainers = [\n    {name = \"Shapely contributors\"},\n]\ndescription = \"Manipulation and analysis of geometric objects\"\nreadme = \"README.rst\"\nkeywords = [\"geometry\", \"topology\", \"gis\"]\nlicense = {text = \"BSD 3-Clause\"}\nclassifiers = [\n    \"Development Status :: 5 - Production/Stable\",\n    \"Intended Audience :: Developers\",\n    \"Intended Audience :: Science/Research\",\n    \"License :: OSI Approved :: BSD License\",\n    \"Operating System :: Unix\",\n    \"Operating System :: MacOS\",\n    \"Operating System :: Microsoft :: Windows\",\n    \"Programming Language :: Python :: 3\",\n    \"Programming Language :: Python :: 3.9\",\n    \"Programming Language :: Python :: 3.10\",\n    \"Programming Language :: Python :: 3.11\",\n    \"Programming Language :: Python :: 3.12\",\n    \"Programming Language :: Python :: 3.13\",\n    \"Topic :: Scientific/Engineering :: GIS\",\n]\nrequires-python = \">=3.9\"\ndependencies = [\n    \"numpy>=1.20\",\n]\n\n[project.optional-dependencies]\ntest = [\n    \"pytest\",\n    \"pytest-cov\",\n]\ndocs = [\n    \"numpydoc==1.1.*\",\n    \"matplotlib\",\n    \"sphinx\",\n    \"sphinx-book-theme\",\n    \"sphinx-remove-toctrees\",\n]\n\n[project.urls]\nDocumentation = \"https://shapely.readthedocs.io/\"\nRepository = \"https://github.com/shapely/shapely\"\n\n[tool.setuptools]\ninclude-package-data = false\n\n[tool.setuptools.packages.find]\ninclude = [\"shapely\", \"shapely.*\"]\n\n[tool.setuptools.package-data]\n\"shapely\" = [\"*.pxd\"]\n\n[tool.cibuildwheel]\nskip = [\"pp*\", \"*_i686\", \"*_ppc64le\", \"*_s390x\"]\nbuild-verbosity = 1\ntest-requires = \"pytest\"\ntest-command = \"pytest --pyargs shapely.tests\"\nfree-threaded-support = true\n\n[tool.coverage.run]\nsource = [\"shapely\"]\nomit = [\"shapely/tests/*\"]\n\n[tool.doc8]\ninclude = [\"docs\"]\nignore = [\"D000\", \"D004\"]\nallow-long-titles = true\nmax-line-length = 79\n\n[tool.ruff]\nline-length = 88\nextend-exclude = [\"docs/*\", \"benchmarks/*\", \"shapely/_version.py\", \"versioneer.py\"]\n\n[tool.ruff.lint]\nselect = [\n    # pyflakes\n    \"F\",\n    # pycodestyle\n    \"E\",\n    \"W\",\n    # pyupgrade\n    \"UP\",\n    # flake8-bugbear\n    \"B\",\n    # flake8-debugger\n    \"T10\",\n    # flake8-simplify\n    # \"SIM\",\n    # pylint\n    \"PLC\",\n    \"PLE\",\n    \"PLR\",\n    \"PLW\",\n    # misc lints\n    \"PIE\",\n    # implicit string concatenation\n    \"ISC\",\n    # type-checking imports\n    \"TCH\",\n    # comprehensions\n    \"C4\",\n    # Ruff-specific rules\n    \"RUF\",\n    # isort\n    \"I\",\n    # pydocstyle\n    \"D\",\n]\n\nignore = [\n    ### Intentionally disabled\n    # module level import not at top of file\n    \"E402\",\n    # do not assign a lambda expression, use a def\n    \"E731\",\n    # mutable-argument-default\n    \"B006\",\n    # unused-loop-control-variable\n    \"B007\",\n    # get-attr-with-constant\n    \"B009\",\n    # Only works with python >=3.10\n    \"B905\",\n    # dict literals\n    \"C408\",\n    # Too many arguments to function call\n    \"PLR0913\",\n    # Too many returns\n    \"PLR0911\",\n    # Too many branches\n    \"PLR0912\",\n    # Too many statements\n    \"PLR0915\",\n    # Magic number\n    \"PLR2004\",\n    # Redefined loop name\n    \"PLW2901\",\n    # Global statements are discouraged\n    \"PLW0603\",\n    # compare-to-empty-string\n    \"PLC1901\",\n\n    ### Additional checks that don't pass yet\n    # Useless statement\n    \"B018\",\n    # Within an except clause, raise exceptions with ...\n    \"B904\",\n    # Consider `elif` instead of `else` then `if` to remove indentation level\n    \"PLR5501\",\n    # collection-literal-concatenation\n    \"RUF005\",\n    # Mutable class attributes should be annotated with `typing.ClassVar`,\n    \"RUF012\"\n]\n\n[tool.ruff.lint.per-file-ignores]\n# ignore pydocstyle errors in tests\n\"**/tests/*\" = [\"D\"]\n# the order of imports in __init__ is a bit tricky, so keep manual\n\"shapely/__init__.py\" = [\"F401\", \"F403\", \"I\"]\n\n[tool.ruff.lint.isort]\ncombine-as-imports = true\nextra-standard-library = [\"packaging\"]\n\n[tool.ruff.lint.pydocstyle]\nconvention = \"numpy\"\n"
        },
        {
          "name": "setup.cfg",
          "type": "blob",
          "size": 0.2412109375,
          "content": "[versioneer]\nVCS = git\nstyle = pep440\nversionfile_source = shapely/_version.py\nversionfile_build = shapely/_version.py\ntag_prefix =\nparentdir_prefix = shapely-\n\n[tool:pytest]\ndoctest_optionflags = NORMALIZE_WHITESPACE ELLIPSIS\nxfail_strict = true\n"
        },
        {
          "name": "setup.py",
          "type": "blob",
          "size": 6,
          "content": "\"\"\"Setuptools build.\"\"\"\n\nimport logging\nimport os\nimport subprocess\nimport sys\nfrom pathlib import Path\n\nfrom setuptools import Extension, setup\n\n# ensure the current directory is on sys.path so versioneer can be imported\n# when pip uses PEP 517/518 build rules.\n# https://github.com/python-versioneer/python-versioneer/issues/193\nsys.path.insert(0, os.path.dirname(__file__))\nimport versioneer\n\n# Skip Cython build if not available\ntry:\n    import cython\n    from Cython.Build import cythonize\nexcept ImportError:\n    cythonize = None\n\n\nlog = logging.getLogger(__name__)\nch = logging.StreamHandler()\nlog.addHandler(ch)\n\nMIN_GEOS_VERSION = \"3.9\"\n\nif \"all\" in sys.warnoptions:\n    # show GEOS messages in console with: python -W all\n    log.setLevel(logging.DEBUG)\n\n\ndef get_geos_config(option):\n    \"\"\"Get configuration option from the `geos-config` development utility.\n\n    The PATH environment variable should include the path where geos-config is\n    located, or the GEOS_CONFIG environment variable should point to the\n    executable.\n    \"\"\"\n    cmd = os.environ.get(\"GEOS_CONFIG\", \"geos-config\")\n    try:\n        proc = subprocess.run([cmd, option], capture_output=True, text=True, check=True)\n    except OSError:\n        return\n    if proc.stderr and not proc.stdout:\n        log.warning(\"geos-config %s returned '%s'\", option, proc.stderr.strip())\n        return\n    result = proc.stdout.strip()\n    log.debug(\"geos-config %s returned '%s'\", option, result)\n    return result\n\n\ndef get_ext_options():\n    \"\"\"Get Extension options to build using GEOS and NumPy C API.\n\n    First the presence of the GEOS_INCLUDE_PATH and GEOS_INCLUDE_PATH environment\n    variables is checked. If they are both present, these are taken.\n\n    If one of the two paths was not present, geos-config is called (it should be on the\n    PATH variable). geos-config provides all the paths.\n\n    If geos-config was not found, no additional paths are provided to the extension.\n    It is still possible to compile in this case using custom arguments to setup.py.\n    \"\"\"\n    import numpy\n\n    opts = {\n        \"define_macros\": [\n            # avoid accidental use of non-reentrant functions\n            (\"GEOS_USE_ONLY_R_API\", None),\n            # silence warnings\n            (\"NPY_NO_DEPRECATED_API\", \"0\"),\n            # minimum numpy version\n            (\"NPY_TARGET_VERSION\", \"NPY_1_20_API_VERSION\"),\n        ],\n        \"include_dirs\": [\"./src\"],\n        \"library_dirs\": [],\n        \"extra_link_args\": [],\n        \"libraries\": [],\n    }\n\n    if include_dir := numpy.get_include():\n        opts[\"include_dirs\"].append(include_dir)\n\n    # Without geos-config (e.g. MSVC), specify these two vars\n    include_dir = os.environ.get(\"GEOS_INCLUDE_PATH\")\n    library_dir = os.environ.get(\"GEOS_LIBRARY_PATH\")\n    if include_dir and library_dir:\n        opts[\"include_dirs\"].append(include_dir)\n        opts[\"library_dirs\"].append(library_dir)\n        opts[\"libraries\"].append(\"geos_c\")\n        return opts\n\n    geos_version = get_geos_config(\"--version\")\n    if not geos_version:\n        log.warning(\n            \"Could not find geos-config executable. Either append the path to \"\n            \"geos-config to PATH or manually provide the include_dirs, library_dirs, \"\n            \"libraries and other link args for compiling against a GEOS version >=%s.\",\n            MIN_GEOS_VERSION,\n        )\n        return {}\n\n    def version_tuple(ver):\n        return tuple(int(itm) if itm.isnumeric() else itm for itm in ver.split(\".\"))\n\n    if version_tuple(geos_version) < version_tuple(MIN_GEOS_VERSION):\n        raise ImportError(\n            f\"GEOS version should be >={MIN_GEOS_VERSION}, found {geos_version}\"\n        )\n\n    for item in get_geos_config(\"--cflags\").split():\n        if item.startswith(\"-I\"):\n            opts[\"include_dirs\"].extend(item[2:].split(\":\"))\n\n    for item in get_geos_config(\"--clibs\").split():\n        if item.startswith(\"-L\"):\n            opts[\"library_dirs\"].extend(item[2:].split(\":\"))\n        elif item.startswith(\"-l\"):\n            opts[\"libraries\"].append(item[2:])\n        else:\n            opts[\"extra_link_args\"].append(item)\n\n    return opts\n\n\next_modules = []\n\nif \"clean\" in sys.argv:\n    # delete any previously Cythonized or compiled files in pygeos\n    p = Path(\".\")\n    for pattern in [\n        \"build/lib.*/shapely/*.so\",\n        \"shapely/*.c\",\n        \"shapely/*.so\",\n        \"shapely/*.pyd\",\n    ]:\n        for filename in p.glob(pattern):\n            print(f\"removing '{filename}'\")\n            filename.unlink()\nelif \"sdist\" in sys.argv:\n    if Path(\"LICENSE_GEOS\").exists() or Path(\"LICENSE_win32\").exists():\n        raise FileExistsError(\n            \"Source distributions should not pack LICENSE_GEOS or LICENSE_win32. \"\n            \"Please remove the files.\"\n        )\nelse:\n    ext_options = get_ext_options()\n\n    ext_modules = [\n        Extension(\n            \"shapely.lib\",\n            sources=[\n                \"src/c_api.c\",\n                \"src/coords.c\",\n                \"src/geos.c\",\n                \"src/lib.c\",\n                \"src/pygeom.c\",\n                \"src/pygeos.c\",\n                \"src/strtree.c\",\n                \"src/ufuncs.c\",\n                \"src/vector.c\",\n            ],\n            **ext_options,\n        )\n    ]\n\n    # Cython is required\n    if not cythonize:\n        sys.exit(\"ERROR: Cython is required to build shapely from source.\")\n\n    cython_modules = [\n        Extension(\n            \"shapely._geometry_helpers\",\n            [\"shapely/_geometry_helpers.pyx\"],\n            **ext_options,\n        ),\n        Extension(\n            \"shapely._geos\",\n            [\"shapely/_geos.pyx\"],\n            **ext_options,\n        ),\n    ]\n    compiler_directives = {\"language_level\": \"3\"}\n    if cython.__version__ >= \"3.1.0\":\n        compiler_directives.update({\"freethreading_compatible\": True})\n    ext_modules += cythonize(\n        cython_modules,\n        compiler_directives=compiler_directives,\n    )\n\n\ncmdclass = versioneer.get_cmdclass()\n\n\n# see pyproject.toml for static project metadata\nsetup(\n    version=versioneer.get_version(),\n    ext_modules=ext_modules,\n    cmdclass=cmdclass,\n)\n"
        },
        {
          "name": "shapely",
          "type": "tree",
          "content": null
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "versioneer.py",
          "type": "blob",
          "size": 81.6474609375,
          "content": "\n# Version: 0.28\n\n\"\"\"The Versioneer - like a rocketeer, but for versions.\n\nThe Versioneer\n==============\n\n* like a rocketeer, but for versions!\n* https://github.com/python-versioneer/python-versioneer\n* Brian Warner\n* License: Public Domain (Unlicense)\n* Compatible with: Python 3.7, 3.8, 3.9, 3.10 and pypy3\n* [![Latest Version][pypi-image]][pypi-url]\n* [![Build Status][travis-image]][travis-url]\n\nThis is a tool for managing a recorded version number in setuptools-based\npython projects. The goal is to remove the tedious and error-prone \"update\nthe embedded version string\" step from your release process. Making a new\nrelease should be as easy as recording a new tag in your version-control\nsystem, and maybe making new tarballs.\n\n\n## Quick Install\n\nVersioneer provides two installation modes. The \"classic\" vendored mode installs\na copy of versioneer into your repository. The experimental build-time dependency mode\nis intended to allow you to skip this step and simplify the process of upgrading.\n\n### Vendored mode\n\n* `pip install versioneer` to somewhere in your $PATH\n   * A [conda-forge recipe](https://github.com/conda-forge/versioneer-feedstock) is\n     available, so you can also use `conda install -c conda-forge versioneer`\n* add a `[tool.versioneer]` section to your `pyproject.toml` or a\n  `[versioneer]` section to your `setup.cfg` (see [Install](INSTALL.md))\n   * Note that you will need to add `tomli; python_version < \"3.11\"` to your\n     build-time dependencies if you use `pyproject.toml`\n* run `versioneer install --vendor` in your source tree, commit the results\n* verify version information with `python setup.py version`\n\n### Build-time dependency mode\n\n* `pip install versioneer` to somewhere in your $PATH\n   * A [conda-forge recipe](https://github.com/conda-forge/versioneer-feedstock) is\n     available, so you can also use `conda install -c conda-forge versioneer`\n* add a `[tool.versioneer]` section to your `pyproject.toml` or a\n  `[versioneer]` section to your `setup.cfg` (see [Install](INSTALL.md))\n* add `versioneer` (with `[toml]` extra, if configuring in `pyproject.toml`)\n  to the `requires` key of the `build-system` table in `pyproject.toml`:\n  ```toml\n  [build-system]\n  requires = [\"setuptools\", \"versioneer[toml]\"]\n  build-backend = \"setuptools.build_meta\"\n  ```\n* run `versioneer install --no-vendor` in your source tree, commit the results\n* verify version information with `python setup.py version`\n\n## Version Identifiers\n\nSource trees come from a variety of places:\n\n* a version-control system checkout (mostly used by developers)\n* a nightly tarball, produced by build automation\n* a snapshot tarball, produced by a web-based VCS browser, like github's\n  \"tarball from tag\" feature\n* a release tarball, produced by \"setup.py sdist\", distributed through PyPI\n\nWithin each source tree, the version identifier (either a string or a number,\nthis tool is format-agnostic) can come from a variety of places:\n\n* ask the VCS tool itself, e.g. \"git describe\" (for checkouts), which knows\n  about recent \"tags\" and an absolute revision-id\n* the name of the directory into which the tarball was unpacked\n* an expanded VCS keyword ($Id$, etc)\n* a `_version.py` created by some earlier build step\n\nFor released software, the version identifier is closely related to a VCS\ntag. Some projects use tag names that include more than just the version\nstring (e.g. \"myproject-1.2\" instead of just \"1.2\"), in which case the tool\nneeds to strip the tag prefix to extract the version identifier. For\nunreleased software (between tags), the version identifier should provide\nenough information to help developers recreate the same tree, while also\ngiving them an idea of roughly how old the tree is (after version 1.2, before\nversion 1.3). Many VCS systems can report a description that captures this,\nfor example `git describe --tags --dirty --always` reports things like\n\"0.7-1-g574ab98-dirty\" to indicate that the checkout is one revision past the\n0.7 tag, has a unique revision id of \"574ab98\", and is \"dirty\" (it has\nuncommitted changes).\n\nThe version identifier is used for multiple purposes:\n\n* to allow the module to self-identify its version: `myproject.__version__`\n* to choose a name and prefix for a 'setup.py sdist' tarball\n\n## Theory of Operation\n\nVersioneer works by adding a special `_version.py` file into your source\ntree, where your `__init__.py` can import it. This `_version.py` knows how to\ndynamically ask the VCS tool for version information at import time.\n\n`_version.py` also contains `$Revision$` markers, and the installation\nprocess marks `_version.py` to have this marker rewritten with a tag name\nduring the `git archive` command. As a result, generated tarballs will\ncontain enough information to get the proper version.\n\nTo allow `setup.py` to compute a version too, a `versioneer.py` is added to\nthe top level of your source tree, next to `setup.py` and the `setup.cfg`\nthat configures it. This overrides several distutils/setuptools commands to\ncompute the version when invoked, and changes `setup.py build` and `setup.py\nsdist` to replace `_version.py` with a small static file that contains just\nthe generated version data.\n\n## Installation\n\nSee [INSTALL.md](./INSTALL.md) for detailed installation instructions.\n\n## Version-String Flavors\n\nCode which uses Versioneer can learn about its version string at runtime by\nimporting `_version` from your main `__init__.py` file and running the\n`get_versions()` function. From the \"outside\" (e.g. in `setup.py`), you can\nimport the top-level `versioneer.py` and run `get_versions()`.\n\nBoth functions return a dictionary with different flavors of version\ninformation:\n\n* `['version']`: A condensed version string, rendered using the selected\n  style. This is the most commonly used value for the project's version\n  string. The default \"pep440\" style yields strings like `0.11`,\n  `0.11+2.g1076c97`, or `0.11+2.g1076c97.dirty`. See the \"Styles\" section\n  below for alternative styles.\n\n* `['full-revisionid']`: detailed revision identifier. For Git, this is the\n  full SHA1 commit id, e.g. \"1076c978a8d3cfc70f408fe5974aa6c092c949ac\".\n\n* `['date']`: Date and time of the latest `HEAD` commit. For Git, it is the\n  commit date in ISO 8601 format. This will be None if the date is not\n  available.\n\n* `['dirty']`: a boolean, True if the tree has uncommitted changes. Note that\n  this is only accurate if run in a VCS checkout, otherwise it is likely to\n  be False or None\n\n* `['error']`: if the version string could not be computed, this will be set\n  to a string describing the problem, otherwise it will be None. It may be\n  useful to throw an exception in setup.py if this is set, to avoid e.g.\n  creating tarballs with a version string of \"unknown\".\n\nSome variants are more useful than others. Including `full-revisionid` in a\nbug report should allow developers to reconstruct the exact code being tested\n(or indicate the presence of local changes that should be shared with the\ndevelopers). `version` is suitable for display in an \"about\" box or a CLI\n`--version` output: it can be easily compared against release notes and lists\nof bugs fixed in various releases.\n\nThe installer adds the following text to your `__init__.py` to place a basic\nversion in `YOURPROJECT.__version__`:\n\n    from ._version import get_versions\n    __version__ = get_versions()['version']\n    del get_versions\n\n## Styles\n\nThe setup.cfg `style=` configuration controls how the VCS information is\nrendered into a version string.\n\nThe default style, \"pep440\", produces a PEP440-compliant string, equal to the\nun-prefixed tag name for actual releases, and containing an additional \"local\nversion\" section with more detail for in-between builds. For Git, this is\nTAG[+DISTANCE.gHEX[.dirty]] , using information from `git describe --tags\n--dirty --always`. For example \"0.11+2.g1076c97.dirty\" indicates that the\ntree is like the \"1076c97\" commit but has uncommitted changes (\".dirty\"), and\nthat this commit is two revisions (\"+2\") beyond the \"0.11\" tag. For released\nsoftware (exactly equal to a known tag), the identifier will only contain the\nstripped tag, e.g. \"0.11\".\n\nOther styles are available. See [details.md](details.md) in the Versioneer\nsource tree for descriptions.\n\n## Debugging\n\nVersioneer tries to avoid fatal errors: if something goes wrong, it will tend\nto return a version of \"0+unknown\". To investigate the problem, run `setup.py\nversion`, which will run the version-lookup code in a verbose mode, and will\ndisplay the full contents of `get_versions()` (including the `error` string,\nwhich may help identify what went wrong).\n\n## Known Limitations\n\nSome situations are known to cause problems for Versioneer. This details the\nmost significant ones. More can be found on Github\n[issues page](https://github.com/python-versioneer/python-versioneer/issues).\n\n### Subprojects\n\nVersioneer has limited support for source trees in which `setup.py` is not in\nthe root directory (e.g. `setup.py` and `.git/` are *not* siblings). The are\ntwo common reasons why `setup.py` might not be in the root:\n\n* Source trees which contain multiple subprojects, such as\n  [Buildbot](https://github.com/buildbot/buildbot), which contains both\n  \"master\" and \"slave\" subprojects, each with their own `setup.py`,\n  `setup.cfg`, and `tox.ini`. Projects like these produce multiple PyPI\n  distributions (and upload multiple independently-installable tarballs).\n* Source trees whose main purpose is to contain a C library, but which also\n  provide bindings to Python (and perhaps other languages) in subdirectories.\n\nVersioneer will look for `.git` in parent directories, and most operations\nshould get the right version string. However `pip` and `setuptools` have bugs\nand implementation details which frequently cause `pip install .` from a\nsubproject directory to fail to find a correct version string (so it usually\ndefaults to `0+unknown`).\n\n`pip install --editable .` should work correctly. `setup.py install` might\nwork too.\n\nPip-8.1.1 is known to have this problem, but hopefully it will get fixed in\nsome later version.\n\n[Bug #38](https://github.com/python-versioneer/python-versioneer/issues/38) is tracking\nthis issue. The discussion in\n[PR #61](https://github.com/python-versioneer/python-versioneer/pull/61) describes the\nissue from the Versioneer side in more detail.\n[pip PR#3176](https://github.com/pypa/pip/pull/3176) and\n[pip PR#3615](https://github.com/pypa/pip/pull/3615) contain work to improve\npip to let Versioneer work correctly.\n\nVersioneer-0.16 and earlier only looked for a `.git` directory next to the\n`setup.cfg`, so subprojects were completely unsupported with those releases.\n\n### Editable installs with setuptools <= 18.5\n\n`setup.py develop` and `pip install --editable .` allow you to install a\nproject into a virtualenv once, then continue editing the source code (and\ntest) without re-installing after every change.\n\n\"Entry-point scripts\" (`setup(entry_points={\"console_scripts\": ..})`) are a\nconvenient way to specify executable scripts that should be installed along\nwith the python package.\n\nThese both work as expected when using modern setuptools. When using\nsetuptools-18.5 or earlier, however, certain operations will cause\n`pkg_resources.DistributionNotFound` errors when running the entrypoint\nscript, which must be resolved by re-installing the package. This happens\nwhen the install happens with one version, then the egg_info data is\nregenerated while a different version is checked out. Many setup.py commands\ncause egg_info to be rebuilt (including `sdist`, `wheel`, and installing into\na different virtualenv), so this can be surprising.\n\n[Bug #83](https://github.com/python-versioneer/python-versioneer/issues/83) describes\nthis one, but upgrading to a newer version of setuptools should probably\nresolve it.\n\n\n## Updating Versioneer\n\nTo upgrade your project to a new release of Versioneer, do the following:\n\n* install the new Versioneer (`pip install -U versioneer` or equivalent)\n* edit `setup.cfg` and `pyproject.toml`, if necessary,\n  to include any new configuration settings indicated by the release notes.\n  See [UPGRADING](./UPGRADING.md) for details.\n* re-run `versioneer install --[no-]vendor` in your source tree, to replace\n  `SRC/_version.py`\n* commit any changed files\n\n## Future Directions\n\nThis tool is designed to make it easily extended to other version-control\nsystems: all VCS-specific components are in separate directories like\nsrc/git/ . The top-level `versioneer.py` script is assembled from these\ncomponents by running make-versioneer.py . In the future, make-versioneer.py\nwill take a VCS name as an argument, and will construct a version of\n`versioneer.py` that is specific to the given VCS. It might also take the\nconfiguration arguments that are currently provided manually during\ninstallation by editing setup.py . Alternatively, it might go the other\ndirection and include code from all supported VCS systems, reducing the\nnumber of intermediate scripts.\n\n## Similar projects\n\n* [setuptools_scm](https://github.com/pypa/setuptools_scm/) - a non-vendored build-time\n  dependency\n* [minver](https://github.com/jbweston/miniver) - a lightweight reimplementation of\n  versioneer\n* [versioningit](https://github.com/jwodder/versioningit) - a PEP 518-based setuptools\n  plugin\n\n## License\n\nTo make Versioneer easier to embed, all its code is dedicated to the public\ndomain. The `_version.py` that it creates is also in the public domain.\nSpecifically, both are released under the \"Unlicense\", as described in\nhttps://unlicense.org/.\n\n[pypi-image]: https://img.shields.io/pypi/v/versioneer.svg\n[pypi-url]: https://pypi.python.org/pypi/versioneer/\n[travis-image]:\nhttps://img.shields.io/travis/com/python-versioneer/python-versioneer.svg\n[travis-url]: https://travis-ci.com/github/python-versioneer/python-versioneer\n\n\"\"\"\n# pylint:disable=invalid-name,import-outside-toplevel,missing-function-docstring\n# pylint:disable=missing-class-docstring,too-many-branches,too-many-statements\n# pylint:disable=raise-missing-from,too-many-lines,too-many-locals,import-error\n# pylint:disable=too-few-public-methods,redefined-outer-name,consider-using-with\n# pylint:disable=attribute-defined-outside-init,too-many-arguments\n\nimport configparser\nimport errno\nimport json\nimport os\nimport re\nimport subprocess\nimport sys\nfrom pathlib import Path\nfrom typing import Callable, Dict\nimport functools\n\nhave_tomllib = True\nif sys.version_info >= (3, 11):\n    import tomllib\nelse:\n    try:\n        import tomli as tomllib\n    except ImportError:\n        have_tomllib = False\n\n\nclass VersioneerConfig:\n    \"\"\"Container for Versioneer configuration parameters.\"\"\"\n\n\ndef get_root():\n    \"\"\"Get the project root directory.\n\n    We require that all commands are run from the project root, i.e. the\n    directory that contains setup.py, setup.cfg, and versioneer.py .\n    \"\"\"\n    root = os.path.realpath(os.path.abspath(os.getcwd()))\n    setup_py = os.path.join(root, \"setup.py\")\n    versioneer_py = os.path.join(root, \"versioneer.py\")\n    if not (os.path.exists(setup_py) or os.path.exists(versioneer_py)):\n        # allow 'python path/to/setup.py COMMAND'\n        root = os.path.dirname(os.path.realpath(os.path.abspath(sys.argv[0])))\n        setup_py = os.path.join(root, \"setup.py\")\n        versioneer_py = os.path.join(root, \"versioneer.py\")\n    if not (os.path.exists(setup_py) or os.path.exists(versioneer_py)):\n        err = (\"Versioneer was unable to run the project root directory. \"\n               \"Versioneer requires setup.py to be executed from \"\n               \"its immediate directory (like 'python setup.py COMMAND'), \"\n               \"or in a way that lets it use sys.argv[0] to find the root \"\n               \"(like 'python path/to/setup.py COMMAND').\")\n        raise VersioneerBadRootError(err)\n    try:\n        # Certain runtime workflows (setup.py install/develop in a setuptools\n        # tree) execute all dependencies in a single python process, so\n        # \"versioneer\" may be imported multiple times, and python's shared\n        # module-import table will cache the first one. So we can't use\n        # os.path.dirname(__file__), as that will find whichever\n        # versioneer.py was first imported, even in later projects.\n        my_path = os.path.realpath(os.path.abspath(__file__))\n        me_dir = os.path.normcase(os.path.splitext(my_path)[0])\n        vsr_dir = os.path.normcase(os.path.splitext(versioneer_py)[0])\n        if me_dir != vsr_dir and \"VERSIONEER_PEP518\" not in globals():\n            print(\"Warning: build in %s is using versioneer.py from %s\"\n                  % (os.path.dirname(my_path), versioneer_py))\n    except NameError:\n        pass\n    return root\n\n\ndef get_config_from_root(root):\n    \"\"\"Read the project setup.cfg file to determine Versioneer config.\"\"\"\n    # This might raise OSError (if setup.cfg is missing), or\n    # configparser.NoSectionError (if it lacks a [versioneer] section), or\n    # configparser.NoOptionError (if it lacks \"VCS=\"). See the docstring at\n    # the top of versioneer.py for instructions on writing your setup.cfg .\n    root = Path(root)\n    pyproject_toml = root / \"pyproject.toml\"\n    setup_cfg = root / \"setup.cfg\"\n    section = None\n    if pyproject_toml.exists() and have_tomllib:\n        try:\n            with open(pyproject_toml, 'rb') as fobj:\n                pp = tomllib.load(fobj)\n            section = pp['tool']['versioneer']\n        except (tomllib.TOMLDecodeError, KeyError):\n            pass\n    if not section:\n        parser = configparser.ConfigParser()\n        with open(setup_cfg) as cfg_file:\n            parser.read_file(cfg_file)\n        parser.get(\"versioneer\", \"VCS\")  # raise error if missing\n\n        section = parser[\"versioneer\"]\n\n    cfg = VersioneerConfig()\n    cfg.VCS = section['VCS']\n    cfg.style = section.get(\"style\", \"\")\n    cfg.versionfile_source = section.get(\"versionfile_source\")\n    cfg.versionfile_build = section.get(\"versionfile_build\")\n    cfg.tag_prefix = section.get(\"tag_prefix\")\n    if cfg.tag_prefix in (\"''\", '\"\"', None):\n        cfg.tag_prefix = \"\"\n    cfg.parentdir_prefix = section.get(\"parentdir_prefix\")\n    cfg.verbose = section.get(\"verbose\")\n    return cfg\n\n\nclass NotThisMethod(Exception):\n    \"\"\"Exception raised if a method is not valid for the current scenario.\"\"\"\n\n\n# these dictionaries contain VCS-specific tools\nLONG_VERSION_PY: Dict[str, str] = {}\nHANDLERS: Dict[str, Dict[str, Callable]] = {}\n\n\ndef register_vcs_handler(vcs, method):  # decorator\n    \"\"\"Create decorator to mark a method as the handler of a VCS.\"\"\"\n    def decorate(f):\n        \"\"\"Store f in HANDLERS[vcs][method].\"\"\"\n        HANDLERS.setdefault(vcs, {})[method] = f\n        return f\n    return decorate\n\n\ndef run_command(commands, args, cwd=None, verbose=False, hide_stderr=False,\n                env=None):\n    \"\"\"Call the given command(s).\"\"\"\n    assert isinstance(commands, list)\n    process = None\n\n    popen_kwargs = {}\n    if sys.platform == \"win32\":\n        # This hides the console window if pythonw.exe is used\n        startupinfo = subprocess.STARTUPINFO()\n        startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW\n        popen_kwargs[\"startupinfo\"] = startupinfo\n\n    for command in commands:\n        try:\n            dispcmd = str([command] + args)\n            # remember shell=False, so use git.cmd on windows, not just git\n            process = subprocess.Popen([command] + args, cwd=cwd, env=env,\n                                       stdout=subprocess.PIPE,\n                                       stderr=(subprocess.PIPE if hide_stderr\n                                               else None), **popen_kwargs)\n            break\n        except OSError:\n            e = sys.exc_info()[1]\n            if e.errno == errno.ENOENT:\n                continue\n            if verbose:\n                print(\"unable to run %s\" % dispcmd)\n                print(e)\n            return None, None\n    else:\n        if verbose:\n            print(\"unable to find command, tried %s\" % (commands,))\n        return None, None\n    stdout = process.communicate()[0].strip().decode()\n    if process.returncode != 0:\n        if verbose:\n            print(\"unable to run %s (error)\" % dispcmd)\n            print(\"stdout was %s\" % stdout)\n        return None, process.returncode\n    return stdout, process.returncode\n\n\nLONG_VERSION_PY['git'] = r'''\n# This file helps to compute a version number in source trees obtained from\n# git-archive tarball (such as those provided by githubs download-from-tag\n# feature). Distribution tarballs (built by setup.py sdist) and build\n# directories (produced by setup.py build) will contain a much shorter file\n# that just contains the computed version number.\n\n# This file is released into the public domain.\n# Generated by versioneer-0.28\n# https://github.com/python-versioneer/python-versioneer\n\n\"\"\"Git implementation of _version.py.\"\"\"\n\nimport errno\nimport os\nimport re\nimport subprocess\nimport sys\nfrom typing import Callable, Dict\nimport functools\n\n\ndef get_keywords():\n    \"\"\"Get the keywords needed to look up the version information.\"\"\"\n    # these strings will be replaced by git during git-archive.\n    # setup.py/versioneer.py will grep for the variable names, so they must\n    # each be defined on a line of their own. _version.py will just call\n    # get_keywords().\n    git_refnames = \"%(DOLLAR)sFormat:%%d%(DOLLAR)s\"\n    git_full = \"%(DOLLAR)sFormat:%%H%(DOLLAR)s\"\n    git_date = \"%(DOLLAR)sFormat:%%ci%(DOLLAR)s\"\n    keywords = {\"refnames\": git_refnames, \"full\": git_full, \"date\": git_date}\n    return keywords\n\n\nclass VersioneerConfig:\n    \"\"\"Container for Versioneer configuration parameters.\"\"\"\n\n\ndef get_config():\n    \"\"\"Create, populate and return the VersioneerConfig() object.\"\"\"\n    # these strings are filled in when 'setup.py versioneer' creates\n    # _version.py\n    cfg = VersioneerConfig()\n    cfg.VCS = \"git\"\n    cfg.style = \"%(STYLE)s\"\n    cfg.tag_prefix = \"%(TAG_PREFIX)s\"\n    cfg.parentdir_prefix = \"%(PARENTDIR_PREFIX)s\"\n    cfg.versionfile_source = \"%(VERSIONFILE_SOURCE)s\"\n    cfg.verbose = False\n    return cfg\n\n\nclass NotThisMethod(Exception):\n    \"\"\"Exception raised if a method is not valid for the current scenario.\"\"\"\n\n\nLONG_VERSION_PY: Dict[str, str] = {}\nHANDLERS: Dict[str, Dict[str, Callable]] = {}\n\n\ndef register_vcs_handler(vcs, method):  # decorator\n    \"\"\"Create decorator to mark a method as the handler of a VCS.\"\"\"\n    def decorate(f):\n        \"\"\"Store f in HANDLERS[vcs][method].\"\"\"\n        if vcs not in HANDLERS:\n            HANDLERS[vcs] = {}\n        HANDLERS[vcs][method] = f\n        return f\n    return decorate\n\n\ndef run_command(commands, args, cwd=None, verbose=False, hide_stderr=False,\n                env=None):\n    \"\"\"Call the given command(s).\"\"\"\n    assert isinstance(commands, list)\n    process = None\n\n    popen_kwargs = {}\n    if sys.platform == \"win32\":\n        # This hides the console window if pythonw.exe is used\n        startupinfo = subprocess.STARTUPINFO()\n        startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW\n        popen_kwargs[\"startupinfo\"] = startupinfo\n\n    for command in commands:\n        try:\n            dispcmd = str([command] + args)\n            # remember shell=False, so use git.cmd on windows, not just git\n            process = subprocess.Popen([command] + args, cwd=cwd, env=env,\n                                       stdout=subprocess.PIPE,\n                                       stderr=(subprocess.PIPE if hide_stderr\n                                               else None), **popen_kwargs)\n            break\n        except OSError:\n            e = sys.exc_info()[1]\n            if e.errno == errno.ENOENT:\n                continue\n            if verbose:\n                print(\"unable to run %%s\" %% dispcmd)\n                print(e)\n            return None, None\n    else:\n        if verbose:\n            print(\"unable to find command, tried %%s\" %% (commands,))\n        return None, None\n    stdout = process.communicate()[0].strip().decode()\n    if process.returncode != 0:\n        if verbose:\n            print(\"unable to run %%s (error)\" %% dispcmd)\n            print(\"stdout was %%s\" %% stdout)\n        return None, process.returncode\n    return stdout, process.returncode\n\n\ndef versions_from_parentdir(parentdir_prefix, root, verbose):\n    \"\"\"Try to determine the version from the parent directory name.\n\n    Source tarballs conventionally unpack into a directory that includes both\n    the project name and a version string. We will also support searching up\n    two directory levels for an appropriately named parent directory\n    \"\"\"\n    rootdirs = []\n\n    for _ in range(3):\n        dirname = os.path.basename(root)\n        if dirname.startswith(parentdir_prefix):\n            return {\"version\": dirname[len(parentdir_prefix):],\n                    \"full-revisionid\": None,\n                    \"dirty\": False, \"error\": None, \"date\": None}\n        rootdirs.append(root)\n        root = os.path.dirname(root)  # up a level\n\n    if verbose:\n        print(\"Tried directories %%s but none started with prefix %%s\" %%\n              (str(rootdirs), parentdir_prefix))\n    raise NotThisMethod(\"rootdir doesn't start with parentdir_prefix\")\n\n\n@register_vcs_handler(\"git\", \"get_keywords\")\ndef git_get_keywords(versionfile_abs):\n    \"\"\"Extract version information from the given file.\"\"\"\n    # the code embedded in _version.py can just fetch the value of these\n    # keywords. When used from setup.py, we don't want to import _version.py,\n    # so we do it with a regexp instead. This function is not used from\n    # _version.py.\n    keywords = {}\n    try:\n        with open(versionfile_abs, \"r\") as fobj:\n            for line in fobj:\n                if line.strip().startswith(\"git_refnames =\"):\n                    mo = re.search(r'=\\s*\"(.*)\"', line)\n                    if mo:\n                        keywords[\"refnames\"] = mo.group(1)\n                if line.strip().startswith(\"git_full =\"):\n                    mo = re.search(r'=\\s*\"(.*)\"', line)\n                    if mo:\n                        keywords[\"full\"] = mo.group(1)\n                if line.strip().startswith(\"git_date =\"):\n                    mo = re.search(r'=\\s*\"(.*)\"', line)\n                    if mo:\n                        keywords[\"date\"] = mo.group(1)\n    except OSError:\n        pass\n    return keywords\n\n\n@register_vcs_handler(\"git\", \"keywords\")\ndef git_versions_from_keywords(keywords, tag_prefix, verbose):\n    \"\"\"Get version information from git keywords.\"\"\"\n    if \"refnames\" not in keywords:\n        raise NotThisMethod(\"Short version file found\")\n    date = keywords.get(\"date\")\n    if date is not None:\n        # Use only the last line.  Previous lines may contain GPG signature\n        # information.\n        date = date.splitlines()[-1]\n\n        # git-2.2.0 added \"%%cI\", which expands to an ISO-8601 -compliant\n        # datestamp. However we prefer \"%%ci\" (which expands to an \"ISO-8601\n        # -like\" string, which we must then edit to make compliant), because\n        # it's been around since git-1.5.3, and it's too difficult to\n        # discover which version we're using, or to work around using an\n        # older one.\n        date = date.strip().replace(\" \", \"T\", 1).replace(\" \", \"\", 1)\n    refnames = keywords[\"refnames\"].strip()\n    if refnames.startswith(\"$Format\"):\n        if verbose:\n            print(\"keywords are unexpanded, not using\")\n        raise NotThisMethod(\"unexpanded keywords, not a git-archive tarball\")\n    refs = {r.strip() for r in refnames.strip(\"()\").split(\",\")}\n    # starting in git-1.8.3, tags are listed as \"tag: foo-1.0\" instead of\n    # just \"foo-1.0\". If we see a \"tag: \" prefix, prefer those.\n    TAG = \"tag: \"\n    tags = {r[len(TAG):] for r in refs if r.startswith(TAG)}\n    if not tags:\n        # Either we're using git < 1.8.3, or there really are no tags. We use\n        # a heuristic: assume all version tags have a digit. The old git %%d\n        # expansion behaves like git log --decorate=short and strips out the\n        # refs/heads/ and refs/tags/ prefixes that would let us distinguish\n        # between branches and tags. By ignoring refnames without digits, we\n        # filter out many common branch names like \"release\" and\n        # \"stabilization\", as well as \"HEAD\" and \"master\".\n        tags = {r for r in refs if re.search(r'\\d', r)}\n        if verbose:\n            print(\"discarding '%%s', no digits\" %% \",\".join(refs - tags))\n    if verbose:\n        print(\"likely tags: %%s\" %% \",\".join(sorted(tags)))\n    for ref in sorted(tags):\n        # sorting will prefer e.g. \"2.0\" over \"2.0rc1\"\n        if ref.startswith(tag_prefix):\n            r = ref[len(tag_prefix):]\n            # Filter out refs that exactly match prefix or that don't start\n            # with a number once the prefix is stripped (mostly a concern\n            # when prefix is '')\n            if not re.match(r'\\d', r):\n                continue\n            if verbose:\n                print(\"picking %%s\" %% r)\n            return {\"version\": r,\n                    \"full-revisionid\": keywords[\"full\"].strip(),\n                    \"dirty\": False, \"error\": None,\n                    \"date\": date}\n    # no suitable tags, so version is \"0+unknown\", but full hex is still there\n    if verbose:\n        print(\"no suitable tags, using unknown + full revision id\")\n    return {\"version\": \"0+unknown\",\n            \"full-revisionid\": keywords[\"full\"].strip(),\n            \"dirty\": False, \"error\": \"no suitable tags\", \"date\": None}\n\n\n@register_vcs_handler(\"git\", \"pieces_from_vcs\")\ndef git_pieces_from_vcs(tag_prefix, root, verbose, runner=run_command):\n    \"\"\"Get version from 'git describe' in the root of the source tree.\n\n    This only gets called if the git-archive 'subst' keywords were *not*\n    expanded, and _version.py hasn't already been rewritten with a short\n    version string, meaning we're inside a checked out source tree.\n    \"\"\"\n    GITS = [\"git\"]\n    if sys.platform == \"win32\":\n        GITS = [\"git.cmd\", \"git.exe\"]\n\n    # GIT_DIR can interfere with correct operation of Versioneer.\n    # It may be intended to be passed to the Versioneer-versioned project,\n    # but that should not change where we get our version from.\n    env = os.environ.copy()\n    env.pop(\"GIT_DIR\", None)\n    runner = functools.partial(runner, env=env)\n\n    _, rc = runner(GITS, [\"rev-parse\", \"--git-dir\"], cwd=root,\n                   hide_stderr=not verbose)\n    if rc != 0:\n        if verbose:\n            print(\"Directory %%s not under git control\" %% root)\n        raise NotThisMethod(\"'git rev-parse --git-dir' returned error\")\n\n    # if there is a tag matching tag_prefix, this yields TAG-NUM-gHEX[-dirty]\n    # if there isn't one, this yields HEX[-dirty] (no NUM)\n    describe_out, rc = runner(GITS, [\n        \"describe\", \"--tags\", \"--dirty\", \"--always\", \"--long\",\n        \"--match\", f\"{tag_prefix}[[:digit:]]*\"\n    ], cwd=root)\n    # --long was added in git-1.5.5\n    if describe_out is None:\n        raise NotThisMethod(\"'git describe' failed\")\n    describe_out = describe_out.strip()\n    full_out, rc = runner(GITS, [\"rev-parse\", \"HEAD\"], cwd=root)\n    if full_out is None:\n        raise NotThisMethod(\"'git rev-parse' failed\")\n    full_out = full_out.strip()\n\n    pieces = {}\n    pieces[\"long\"] = full_out\n    pieces[\"short\"] = full_out[:7]  # maybe improved later\n    pieces[\"error\"] = None\n\n    branch_name, rc = runner(GITS, [\"rev-parse\", \"--abbrev-ref\", \"HEAD\"],\n                             cwd=root)\n    # --abbrev-ref was added in git-1.6.3\n    if rc != 0 or branch_name is None:\n        raise NotThisMethod(\"'git rev-parse --abbrev-ref' returned error\")\n    branch_name = branch_name.strip()\n\n    if branch_name == \"HEAD\":\n        # If we aren't exactly on a branch, pick a branch which represents\n        # the current commit. If all else fails, we are on a branchless\n        # commit.\n        branches, rc = runner(GITS, [\"branch\", \"--contains\"], cwd=root)\n        # --contains was added in git-1.5.4\n        if rc != 0 or branches is None:\n            raise NotThisMethod(\"'git branch --contains' returned error\")\n        branches = branches.split(\"\\n\")\n\n        # Remove the first line if we're running detached\n        if \"(\" in branches[0]:\n            branches.pop(0)\n\n        # Strip off the leading \"* \" from the list of branches.\n        branches = [branch[2:] for branch in branches]\n        if \"master\" in branches:\n            branch_name = \"master\"\n        elif not branches:\n            branch_name = None\n        else:\n            # Pick the first branch that is returned. Good or bad.\n            branch_name = branches[0]\n\n    pieces[\"branch\"] = branch_name\n\n    # parse describe_out. It will be like TAG-NUM-gHEX[-dirty] or HEX[-dirty]\n    # TAG might have hyphens.\n    git_describe = describe_out\n\n    # look for -dirty suffix\n    dirty = git_describe.endswith(\"-dirty\")\n    pieces[\"dirty\"] = dirty\n    if dirty:\n        git_describe = git_describe[:git_describe.rindex(\"-dirty\")]\n\n    # now we have TAG-NUM-gHEX or HEX\n\n    if \"-\" in git_describe:\n        # TAG-NUM-gHEX\n        mo = re.search(r'^(.+)-(\\d+)-g([0-9a-f]+)$', git_describe)\n        if not mo:\n            # unparsable. Maybe git-describe is misbehaving?\n            pieces[\"error\"] = (\"unable to parse git-describe output: '%%s'\"\n                               %% describe_out)\n            return pieces\n\n        # tag\n        full_tag = mo.group(1)\n        if not full_tag.startswith(tag_prefix):\n            if verbose:\n                fmt = \"tag '%%s' doesn't start with prefix '%%s'\"\n                print(fmt %% (full_tag, tag_prefix))\n            pieces[\"error\"] = (\"tag '%%s' doesn't start with prefix '%%s'\"\n                               %% (full_tag, tag_prefix))\n            return pieces\n        pieces[\"closest-tag\"] = full_tag[len(tag_prefix):]\n\n        # distance: number of commits since tag\n        pieces[\"distance\"] = int(mo.group(2))\n\n        # commit: short hex revision ID\n        pieces[\"short\"] = mo.group(3)\n\n    else:\n        # HEX: no tags\n        pieces[\"closest-tag\"] = None\n        out, rc = runner(GITS, [\"rev-list\", \"HEAD\", \"--left-right\"], cwd=root)\n        pieces[\"distance\"] = len(out.split())  # total number of commits\n\n    # commit date: see ISO-8601 comment in git_versions_from_keywords()\n    date = runner(GITS, [\"show\", \"-s\", \"--format=%%ci\", \"HEAD\"], cwd=root)[0].strip()\n    # Use only the last line.  Previous lines may contain GPG signature\n    # information.\n    date = date.splitlines()[-1]\n    pieces[\"date\"] = date.strip().replace(\" \", \"T\", 1).replace(\" \", \"\", 1)\n\n    return pieces\n\n\ndef plus_or_dot(pieces):\n    \"\"\"Return a + if we don't already have one, else return a .\"\"\"\n    if \"+\" in pieces.get(\"closest-tag\", \"\"):\n        return \".\"\n    return \"+\"\n\n\ndef render_pep440(pieces):\n    \"\"\"Build up version string, with post-release \"local version identifier\".\n\n    Our goal: TAG[+DISTANCE.gHEX[.dirty]] . Note that if you\n    get a tagged build and then dirty it, you'll get TAG+0.gHEX.dirty\n\n    Exceptions:\n    1: no tags. git_describe was just HEX. 0+untagged.DISTANCE.gHEX[.dirty]\n    \"\"\"\n    if pieces[\"closest-tag\"]:\n        rendered = pieces[\"closest-tag\"]\n        if pieces[\"distance\"] or pieces[\"dirty\"]:\n            rendered += plus_or_dot(pieces)\n            rendered += \"%%d.g%%s\" %% (pieces[\"distance\"], pieces[\"short\"])\n            if pieces[\"dirty\"]:\n                rendered += \".dirty\"\n    else:\n        # exception #1\n        rendered = \"0+untagged.%%d.g%%s\" %% (pieces[\"distance\"],\n                                          pieces[\"short\"])\n        if pieces[\"dirty\"]:\n            rendered += \".dirty\"\n    return rendered\n\n\ndef render_pep440_branch(pieces):\n    \"\"\"TAG[[.dev0]+DISTANCE.gHEX[.dirty]] .\n\n    The \".dev0\" means not master branch. Note that .dev0 sorts backwards\n    (a feature branch will appear \"older\" than the master branch).\n\n    Exceptions:\n    1: no tags. 0[.dev0]+untagged.DISTANCE.gHEX[.dirty]\n    \"\"\"\n    if pieces[\"closest-tag\"]:\n        rendered = pieces[\"closest-tag\"]\n        if pieces[\"distance\"] or pieces[\"dirty\"]:\n            if pieces[\"branch\"] != \"master\":\n                rendered += \".dev0\"\n            rendered += plus_or_dot(pieces)\n            rendered += \"%%d.g%%s\" %% (pieces[\"distance\"], pieces[\"short\"])\n            if pieces[\"dirty\"]:\n                rendered += \".dirty\"\n    else:\n        # exception #1\n        rendered = \"0\"\n        if pieces[\"branch\"] != \"master\":\n            rendered += \".dev0\"\n        rendered += \"+untagged.%%d.g%%s\" %% (pieces[\"distance\"],\n                                          pieces[\"short\"])\n        if pieces[\"dirty\"]:\n            rendered += \".dirty\"\n    return rendered\n\n\ndef pep440_split_post(ver):\n    \"\"\"Split pep440 version string at the post-release segment.\n\n    Returns the release segments before the post-release and the\n    post-release version number (or -1 if no post-release segment is present).\n    \"\"\"\n    vc = str.split(ver, \".post\")\n    return vc[0], int(vc[1] or 0) if len(vc) == 2 else None\n\n\ndef render_pep440_pre(pieces):\n    \"\"\"TAG[.postN.devDISTANCE] -- No -dirty.\n\n    Exceptions:\n    1: no tags. 0.post0.devDISTANCE\n    \"\"\"\n    if pieces[\"closest-tag\"]:\n        if pieces[\"distance\"]:\n            # update the post release segment\n            tag_version, post_version = pep440_split_post(pieces[\"closest-tag\"])\n            rendered = tag_version\n            if post_version is not None:\n                rendered += \".post%%d.dev%%d\" %% (post_version + 1, pieces[\"distance\"])\n            else:\n                rendered += \".post0.dev%%d\" %% (pieces[\"distance\"])\n        else:\n            # no commits, use the tag as the version\n            rendered = pieces[\"closest-tag\"]\n    else:\n        # exception #1\n        rendered = \"0.post0.dev%%d\" %% pieces[\"distance\"]\n    return rendered\n\n\ndef render_pep440_post(pieces):\n    \"\"\"TAG[.postDISTANCE[.dev0]+gHEX] .\n\n    The \".dev0\" means dirty. Note that .dev0 sorts backwards\n    (a dirty tree will appear \"older\" than the corresponding clean one),\n    but you shouldn't be releasing software with -dirty anyways.\n\n    Exceptions:\n    1: no tags. 0.postDISTANCE[.dev0]\n    \"\"\"\n    if pieces[\"closest-tag\"]:\n        rendered = pieces[\"closest-tag\"]\n        if pieces[\"distance\"] or pieces[\"dirty\"]:\n            rendered += \".post%%d\" %% pieces[\"distance\"]\n            if pieces[\"dirty\"]:\n                rendered += \".dev0\"\n            rendered += plus_or_dot(pieces)\n            rendered += \"g%%s\" %% pieces[\"short\"]\n    else:\n        # exception #1\n        rendered = \"0.post%%d\" %% pieces[\"distance\"]\n        if pieces[\"dirty\"]:\n            rendered += \".dev0\"\n        rendered += \"+g%%s\" %% pieces[\"short\"]\n    return rendered\n\n\ndef render_pep440_post_branch(pieces):\n    \"\"\"TAG[.postDISTANCE[.dev0]+gHEX[.dirty]] .\n\n    The \".dev0\" means not master branch.\n\n    Exceptions:\n    1: no tags. 0.postDISTANCE[.dev0]+gHEX[.dirty]\n    \"\"\"\n    if pieces[\"closest-tag\"]:\n        rendered = pieces[\"closest-tag\"]\n        if pieces[\"distance\"] or pieces[\"dirty\"]:\n            rendered += \".post%%d\" %% pieces[\"distance\"]\n            if pieces[\"branch\"] != \"master\":\n                rendered += \".dev0\"\n            rendered += plus_or_dot(pieces)\n            rendered += \"g%%s\" %% pieces[\"short\"]\n            if pieces[\"dirty\"]:\n                rendered += \".dirty\"\n    else:\n        # exception #1\n        rendered = \"0.post%%d\" %% pieces[\"distance\"]\n        if pieces[\"branch\"] != \"master\":\n            rendered += \".dev0\"\n        rendered += \"+g%%s\" %% pieces[\"short\"]\n        if pieces[\"dirty\"]:\n            rendered += \".dirty\"\n    return rendered\n\n\ndef render_pep440_old(pieces):\n    \"\"\"TAG[.postDISTANCE[.dev0]] .\n\n    The \".dev0\" means dirty.\n\n    Exceptions:\n    1: no tags. 0.postDISTANCE[.dev0]\n    \"\"\"\n    if pieces[\"closest-tag\"]:\n        rendered = pieces[\"closest-tag\"]\n        if pieces[\"distance\"] or pieces[\"dirty\"]:\n            rendered += \".post%%d\" %% pieces[\"distance\"]\n            if pieces[\"dirty\"]:\n                rendered += \".dev0\"\n    else:\n        # exception #1\n        rendered = \"0.post%%d\" %% pieces[\"distance\"]\n        if pieces[\"dirty\"]:\n            rendered += \".dev0\"\n    return rendered\n\n\ndef render_git_describe(pieces):\n    \"\"\"TAG[-DISTANCE-gHEX][-dirty].\n\n    Like 'git describe --tags --dirty --always'.\n\n    Exceptions:\n    1: no tags. HEX[-dirty]  (note: no 'g' prefix)\n    \"\"\"\n    if pieces[\"closest-tag\"]:\n        rendered = pieces[\"closest-tag\"]\n        if pieces[\"distance\"]:\n            rendered += \"-%%d-g%%s\" %% (pieces[\"distance\"], pieces[\"short\"])\n    else:\n        # exception #1\n        rendered = pieces[\"short\"]\n    if pieces[\"dirty\"]:\n        rendered += \"-dirty\"\n    return rendered\n\n\ndef render_git_describe_long(pieces):\n    \"\"\"TAG-DISTANCE-gHEX[-dirty].\n\n    Like 'git describe --tags --dirty --always -long'.\n    The distance/hash is unconditional.\n\n    Exceptions:\n    1: no tags. HEX[-dirty]  (note: no 'g' prefix)\n    \"\"\"\n    if pieces[\"closest-tag\"]:\n        rendered = pieces[\"closest-tag\"]\n        rendered += \"-%%d-g%%s\" %% (pieces[\"distance\"], pieces[\"short\"])\n    else:\n        # exception #1\n        rendered = pieces[\"short\"]\n    if pieces[\"dirty\"]:\n        rendered += \"-dirty\"\n    return rendered\n\n\ndef render(pieces, style):\n    \"\"\"Render the given version pieces into the requested style.\"\"\"\n    if pieces[\"error\"]:\n        return {\"version\": \"unknown\",\n                \"full-revisionid\": pieces.get(\"long\"),\n                \"dirty\": None,\n                \"error\": pieces[\"error\"],\n                \"date\": None}\n\n    if not style or style == \"default\":\n        style = \"pep440\"  # the default\n\n    if style == \"pep440\":\n        rendered = render_pep440(pieces)\n    elif style == \"pep440-branch\":\n        rendered = render_pep440_branch(pieces)\n    elif style == \"pep440-pre\":\n        rendered = render_pep440_pre(pieces)\n    elif style == \"pep440-post\":\n        rendered = render_pep440_post(pieces)\n    elif style == \"pep440-post-branch\":\n        rendered = render_pep440_post_branch(pieces)\n    elif style == \"pep440-old\":\n        rendered = render_pep440_old(pieces)\n    elif style == \"git-describe\":\n        rendered = render_git_describe(pieces)\n    elif style == \"git-describe-long\":\n        rendered = render_git_describe_long(pieces)\n    else:\n        raise ValueError(\"unknown style '%%s'\" %% style)\n\n    return {\"version\": rendered, \"full-revisionid\": pieces[\"long\"],\n            \"dirty\": pieces[\"dirty\"], \"error\": None,\n            \"date\": pieces.get(\"date\")}\n\n\ndef get_versions():\n    \"\"\"Get version information or return default if unable to do so.\"\"\"\n    # I am in _version.py, which lives at ROOT/VERSIONFILE_SOURCE. If we have\n    # __file__, we can work backwards from there to the root. Some\n    # py2exe/bbfreeze/non-CPython implementations don't do __file__, in which\n    # case we can only use expanded keywords.\n\n    cfg = get_config()\n    verbose = cfg.verbose\n\n    try:\n        return git_versions_from_keywords(get_keywords(), cfg.tag_prefix,\n                                          verbose)\n    except NotThisMethod:\n        pass\n\n    try:\n        root = os.path.realpath(__file__)\n        # versionfile_source is the relative path from the top of the source\n        # tree (where the .git directory might live) to this file. Invert\n        # this to find the root from __file__.\n        for _ in cfg.versionfile_source.split('/'):\n            root = os.path.dirname(root)\n    except NameError:\n        return {\"version\": \"0+unknown\", \"full-revisionid\": None,\n                \"dirty\": None,\n                \"error\": \"unable to find root of source tree\",\n                \"date\": None}\n\n    try:\n        pieces = git_pieces_from_vcs(cfg.tag_prefix, root, verbose)\n        return render(pieces, cfg.style)\n    except NotThisMethod:\n        pass\n\n    try:\n        if cfg.parentdir_prefix:\n            return versions_from_parentdir(cfg.parentdir_prefix, root, verbose)\n    except NotThisMethod:\n        pass\n\n    return {\"version\": \"0+unknown\", \"full-revisionid\": None,\n            \"dirty\": None,\n            \"error\": \"unable to compute version\", \"date\": None}\n'''\n\n\n@register_vcs_handler(\"git\", \"get_keywords\")\ndef git_get_keywords(versionfile_abs):\n    \"\"\"Extract version information from the given file.\"\"\"\n    # the code embedded in _version.py can just fetch the value of these\n    # keywords. When used from setup.py, we don't want to import _version.py,\n    # so we do it with a regexp instead. This function is not used from\n    # _version.py.\n    keywords = {}\n    try:\n        with open(versionfile_abs, \"r\") as fobj:\n            for line in fobj:\n                if line.strip().startswith(\"git_refnames =\"):\n                    mo = re.search(r'=\\s*\"(.*)\"', line)\n                    if mo:\n                        keywords[\"refnames\"] = mo.group(1)\n                if line.strip().startswith(\"git_full =\"):\n                    mo = re.search(r'=\\s*\"(.*)\"', line)\n                    if mo:\n                        keywords[\"full\"] = mo.group(1)\n                if line.strip().startswith(\"git_date =\"):\n                    mo = re.search(r'=\\s*\"(.*)\"', line)\n                    if mo:\n                        keywords[\"date\"] = mo.group(1)\n    except OSError:\n        pass\n    return keywords\n\n\n@register_vcs_handler(\"git\", \"keywords\")\ndef git_versions_from_keywords(keywords, tag_prefix, verbose):\n    \"\"\"Get version information from git keywords.\"\"\"\n    if \"refnames\" not in keywords:\n        raise NotThisMethod(\"Short version file found\")\n    date = keywords.get(\"date\")\n    if date is not None:\n        # Use only the last line.  Previous lines may contain GPG signature\n        # information.\n        date = date.splitlines()[-1]\n\n        # git-2.2.0 added \"%cI\", which expands to an ISO-8601 -compliant\n        # datestamp. However we prefer \"%ci\" (which expands to an \"ISO-8601\n        # -like\" string, which we must then edit to make compliant), because\n        # it's been around since git-1.5.3, and it's too difficult to\n        # discover which version we're using, or to work around using an\n        # older one.\n        date = date.strip().replace(\" \", \"T\", 1).replace(\" \", \"\", 1)\n    refnames = keywords[\"refnames\"].strip()\n    if refnames.startswith(\"$Format\"):\n        if verbose:\n            print(\"keywords are unexpanded, not using\")\n        raise NotThisMethod(\"unexpanded keywords, not a git-archive tarball\")\n    refs = {r.strip() for r in refnames.strip(\"()\").split(\",\")}\n    # starting in git-1.8.3, tags are listed as \"tag: foo-1.0\" instead of\n    # just \"foo-1.0\". If we see a \"tag: \" prefix, prefer those.\n    TAG = \"tag: \"\n    tags = {r[len(TAG):] for r in refs if r.startswith(TAG)}\n    if not tags:\n        # Either we're using git < 1.8.3, or there really are no tags. We use\n        # a heuristic: assume all version tags have a digit. The old git %d\n        # expansion behaves like git log --decorate=short and strips out the\n        # refs/heads/ and refs/tags/ prefixes that would let us distinguish\n        # between branches and tags. By ignoring refnames without digits, we\n        # filter out many common branch names like \"release\" and\n        # \"stabilization\", as well as \"HEAD\" and \"master\".\n        tags = {r for r in refs if re.search(r'\\d', r)}\n        if verbose:\n            print(\"discarding '%s', no digits\" % \",\".join(refs - tags))\n    if verbose:\n        print(\"likely tags: %s\" % \",\".join(sorted(tags)))\n    for ref in sorted(tags):\n        # sorting will prefer e.g. \"2.0\" over \"2.0rc1\"\n        if ref.startswith(tag_prefix):\n            r = ref[len(tag_prefix):]\n            # Filter out refs that exactly match prefix or that don't start\n            # with a number once the prefix is stripped (mostly a concern\n            # when prefix is '')\n            if not re.match(r'\\d', r):\n                continue\n            if verbose:\n                print(\"picking %s\" % r)\n            return {\"version\": r,\n                    \"full-revisionid\": keywords[\"full\"].strip(),\n                    \"dirty\": False, \"error\": None,\n                    \"date\": date}\n    # no suitable tags, so version is \"0+unknown\", but full hex is still there\n    if verbose:\n        print(\"no suitable tags, using unknown + full revision id\")\n    return {\"version\": \"0+unknown\",\n            \"full-revisionid\": keywords[\"full\"].strip(),\n            \"dirty\": False, \"error\": \"no suitable tags\", \"date\": None}\n\n\n@register_vcs_handler(\"git\", \"pieces_from_vcs\")\ndef git_pieces_from_vcs(tag_prefix, root, verbose, runner=run_command):\n    \"\"\"Get version from 'git describe' in the root of the source tree.\n\n    This only gets called if the git-archive 'subst' keywords were *not*\n    expanded, and _version.py hasn't already been rewritten with a short\n    version string, meaning we're inside a checked out source tree.\n    \"\"\"\n    GITS = [\"git\"]\n    if sys.platform == \"win32\":\n        GITS = [\"git.cmd\", \"git.exe\"]\n\n    # GIT_DIR can interfere with correct operation of Versioneer.\n    # It may be intended to be passed to the Versioneer-versioned project,\n    # but that should not change where we get our version from.\n    env = os.environ.copy()\n    env.pop(\"GIT_DIR\", None)\n    runner = functools.partial(runner, env=env)\n\n    _, rc = runner(GITS, [\"rev-parse\", \"--git-dir\"], cwd=root,\n                   hide_stderr=not verbose)\n    if rc != 0:\n        if verbose:\n            print(\"Directory %s not under git control\" % root)\n        raise NotThisMethod(\"'git rev-parse --git-dir' returned error\")\n\n    # if there is a tag matching tag_prefix, this yields TAG-NUM-gHEX[-dirty]\n    # if there isn't one, this yields HEX[-dirty] (no NUM)\n    describe_out, rc = runner(GITS, [\n        \"describe\", \"--tags\", \"--dirty\", \"--always\", \"--long\",\n        \"--match\", f\"{tag_prefix}[[:digit:]]*\"\n    ], cwd=root)\n    # --long was added in git-1.5.5\n    if describe_out is None:\n        raise NotThisMethod(\"'git describe' failed\")\n    describe_out = describe_out.strip()\n    full_out, rc = runner(GITS, [\"rev-parse\", \"HEAD\"], cwd=root)\n    if full_out is None:\n        raise NotThisMethod(\"'git rev-parse' failed\")\n    full_out = full_out.strip()\n\n    pieces = {}\n    pieces[\"long\"] = full_out\n    pieces[\"short\"] = full_out[:7]  # maybe improved later\n    pieces[\"error\"] = None\n\n    branch_name, rc = runner(GITS, [\"rev-parse\", \"--abbrev-ref\", \"HEAD\"],\n                             cwd=root)\n    # --abbrev-ref was added in git-1.6.3\n    if rc != 0 or branch_name is None:\n        raise NotThisMethod(\"'git rev-parse --abbrev-ref' returned error\")\n    branch_name = branch_name.strip()\n\n    if branch_name == \"HEAD\":\n        # If we aren't exactly on a branch, pick a branch which represents\n        # the current commit. If all else fails, we are on a branchless\n        # commit.\n        branches, rc = runner(GITS, [\"branch\", \"--contains\"], cwd=root)\n        # --contains was added in git-1.5.4\n        if rc != 0 or branches is None:\n            raise NotThisMethod(\"'git branch --contains' returned error\")\n        branches = branches.split(\"\\n\")\n\n        # Remove the first line if we're running detached\n        if \"(\" in branches[0]:\n            branches.pop(0)\n\n        # Strip off the leading \"* \" from the list of branches.\n        branches = [branch[2:] for branch in branches]\n        if \"master\" in branches:\n            branch_name = \"master\"\n        elif not branches:\n            branch_name = None\n        else:\n            # Pick the first branch that is returned. Good or bad.\n            branch_name = branches[0]\n\n    pieces[\"branch\"] = branch_name\n\n    # parse describe_out. It will be like TAG-NUM-gHEX[-dirty] or HEX[-dirty]\n    # TAG might have hyphens.\n    git_describe = describe_out\n\n    # look for -dirty suffix\n    dirty = git_describe.endswith(\"-dirty\")\n    pieces[\"dirty\"] = dirty\n    if dirty:\n        git_describe = git_describe[:git_describe.rindex(\"-dirty\")]\n\n    # now we have TAG-NUM-gHEX or HEX\n\n    if \"-\" in git_describe:\n        # TAG-NUM-gHEX\n        mo = re.search(r'^(.+)-(\\d+)-g([0-9a-f]+)$', git_describe)\n        if not mo:\n            # unparsable. Maybe git-describe is misbehaving?\n            pieces[\"error\"] = (\"unable to parse git-describe output: '%s'\"\n                               % describe_out)\n            return pieces\n\n        # tag\n        full_tag = mo.group(1)\n        if not full_tag.startswith(tag_prefix):\n            if verbose:\n                fmt = \"tag '%s' doesn't start with prefix '%s'\"\n                print(fmt % (full_tag, tag_prefix))\n            pieces[\"error\"] = (\"tag '%s' doesn't start with prefix '%s'\"\n                               % (full_tag, tag_prefix))\n            return pieces\n        pieces[\"closest-tag\"] = full_tag[len(tag_prefix):]\n\n        # distance: number of commits since tag\n        pieces[\"distance\"] = int(mo.group(2))\n\n        # commit: short hex revision ID\n        pieces[\"short\"] = mo.group(3)\n\n    else:\n        # HEX: no tags\n        pieces[\"closest-tag\"] = None\n        out, rc = runner(GITS, [\"rev-list\", \"HEAD\", \"--left-right\"], cwd=root)\n        pieces[\"distance\"] = len(out.split())  # total number of commits\n\n    # commit date: see ISO-8601 comment in git_versions_from_keywords()\n    date = runner(GITS, [\"show\", \"-s\", \"--format=%ci\", \"HEAD\"], cwd=root)[0].strip()\n    # Use only the last line.  Previous lines may contain GPG signature\n    # information.\n    date = date.splitlines()[-1]\n    pieces[\"date\"] = date.strip().replace(\" \", \"T\", 1).replace(\" \", \"\", 1)\n\n    return pieces\n\n\ndef do_vcs_install(versionfile_source, ipy):\n    \"\"\"Git-specific installation logic for Versioneer.\n\n    For Git, this means creating/changing .gitattributes to mark _version.py\n    for export-subst keyword substitution.\n    \"\"\"\n    GITS = [\"git\"]\n    if sys.platform == \"win32\":\n        GITS = [\"git.cmd\", \"git.exe\"]\n    files = [versionfile_source]\n    if ipy:\n        files.append(ipy)\n    if \"VERSIONEER_PEP518\" not in globals():\n        try:\n            my_path = __file__\n            if my_path.endswith((\".pyc\", \".pyo\")):\n                my_path = os.path.splitext(my_path)[0] + \".py\"\n            versioneer_file = os.path.relpath(my_path)\n        except NameError:\n            versioneer_file = \"versioneer.py\"\n        files.append(versioneer_file)\n    present = False\n    try:\n        with open(\".gitattributes\", \"r\") as fobj:\n            for line in fobj:\n                if line.strip().startswith(versionfile_source):\n                    if \"export-subst\" in line.strip().split()[1:]:\n                        present = True\n                        break\n    except OSError:\n        pass\n    if not present:\n        with open(\".gitattributes\", \"a+\") as fobj:\n            fobj.write(f\"{versionfile_source} export-subst\\n\")\n        files.append(\".gitattributes\")\n    run_command(GITS, [\"add\", \"--\"] + files)\n\n\ndef versions_from_parentdir(parentdir_prefix, root, verbose):\n    \"\"\"Try to determine the version from the parent directory name.\n\n    Source tarballs conventionally unpack into a directory that includes both\n    the project name and a version string. We will also support searching up\n    two directory levels for an appropriately named parent directory\n    \"\"\"\n    rootdirs = []\n\n    for _ in range(3):\n        dirname = os.path.basename(root)\n        if dirname.startswith(parentdir_prefix):\n            return {\"version\": dirname[len(parentdir_prefix):],\n                    \"full-revisionid\": None,\n                    \"dirty\": False, \"error\": None, \"date\": None}\n        rootdirs.append(root)\n        root = os.path.dirname(root)  # up a level\n\n    if verbose:\n        print(\"Tried directories %s but none started with prefix %s\" %\n              (str(rootdirs), parentdir_prefix))\n    raise NotThisMethod(\"rootdir doesn't start with parentdir_prefix\")\n\n\nSHORT_VERSION_PY = \"\"\"\n# This file was generated by 'versioneer.py' (0.28) from\n# revision-control system data, or from the parent directory name of an\n# unpacked source archive. Distribution tarballs contain a pre-generated copy\n# of this file.\n\nimport json\n\nversion_json = '''\n%s\n'''  # END VERSION_JSON\n\n\ndef get_versions():\n    return json.loads(version_json)\n\"\"\"\n\n\ndef versions_from_file(filename):\n    \"\"\"Try to determine the version from _version.py if present.\"\"\"\n    try:\n        with open(filename) as f:\n            contents = f.read()\n    except OSError:\n        raise NotThisMethod(\"unable to read _version.py\")\n    mo = re.search(r\"version_json = '''\\n(.*)'''  # END VERSION_JSON\",\n                   contents, re.M | re.S)\n    if not mo:\n        mo = re.search(r\"version_json = '''\\r\\n(.*)'''  # END VERSION_JSON\",\n                       contents, re.M | re.S)\n    if not mo:\n        raise NotThisMethod(\"no version_json in _version.py\")\n    return json.loads(mo.group(1))\n\n\ndef write_to_version_file(filename, versions):\n    \"\"\"Write the given version number to the given _version.py file.\"\"\"\n    os.unlink(filename)\n    contents = json.dumps(versions, sort_keys=True,\n                          indent=1, separators=(\",\", \": \"))\n    with open(filename, \"w\") as f:\n        f.write(SHORT_VERSION_PY % contents)\n\n    print(\"set %s to '%s'\" % (filename, versions[\"version\"]))\n\n\ndef plus_or_dot(pieces):\n    \"\"\"Return a + if we don't already have one, else return a .\"\"\"\n    if \"+\" in pieces.get(\"closest-tag\", \"\"):\n        return \".\"\n    return \"+\"\n\n\ndef render_pep440(pieces):\n    \"\"\"Build up version string, with post-release \"local version identifier\".\n\n    Our goal: TAG[+DISTANCE.gHEX[.dirty]] . Note that if you\n    get a tagged build and then dirty it, you'll get TAG+0.gHEX.dirty\n\n    Exceptions:\n    1: no tags. git_describe was just HEX. 0+untagged.DISTANCE.gHEX[.dirty]\n    \"\"\"\n    if pieces[\"closest-tag\"]:\n        rendered = pieces[\"closest-tag\"]\n        if pieces[\"distance\"] or pieces[\"dirty\"]:\n            rendered += plus_or_dot(pieces)\n            rendered += \"%d.g%s\" % (pieces[\"distance\"], pieces[\"short\"])\n            if pieces[\"dirty\"]:\n                rendered += \".dirty\"\n    else:\n        # exception #1\n        rendered = \"0+untagged.%d.g%s\" % (pieces[\"distance\"],\n                                          pieces[\"short\"])\n        if pieces[\"dirty\"]:\n            rendered += \".dirty\"\n    return rendered\n\n\ndef render_pep440_branch(pieces):\n    \"\"\"TAG[[.dev0]+DISTANCE.gHEX[.dirty]] .\n\n    The \".dev0\" means not master branch. Note that .dev0 sorts backwards\n    (a feature branch will appear \"older\" than the master branch).\n\n    Exceptions:\n    1: no tags. 0[.dev0]+untagged.DISTANCE.gHEX[.dirty]\n    \"\"\"\n    if pieces[\"closest-tag\"]:\n        rendered = pieces[\"closest-tag\"]\n        if pieces[\"distance\"] or pieces[\"dirty\"]:\n            if pieces[\"branch\"] != \"master\":\n                rendered += \".dev0\"\n            rendered += plus_or_dot(pieces)\n            rendered += \"%d.g%s\" % (pieces[\"distance\"], pieces[\"short\"])\n            if pieces[\"dirty\"]:\n                rendered += \".dirty\"\n    else:\n        # exception #1\n        rendered = \"0\"\n        if pieces[\"branch\"] != \"master\":\n            rendered += \".dev0\"\n        rendered += \"+untagged.%d.g%s\" % (pieces[\"distance\"],\n                                          pieces[\"short\"])\n        if pieces[\"dirty\"]:\n            rendered += \".dirty\"\n    return rendered\n\n\ndef pep440_split_post(ver):\n    \"\"\"Split pep440 version string at the post-release segment.\n\n    Returns the release segments before the post-release and the\n    post-release version number (or -1 if no post-release segment is present).\n    \"\"\"\n    vc = str.split(ver, \".post\")\n    return vc[0], int(vc[1] or 0) if len(vc) == 2 else None\n\n\ndef render_pep440_pre(pieces):\n    \"\"\"TAG[.postN.devDISTANCE] -- No -dirty.\n\n    Exceptions:\n    1: no tags. 0.post0.devDISTANCE\n    \"\"\"\n    if pieces[\"closest-tag\"]:\n        if pieces[\"distance\"]:\n            # update the post release segment\n            tag_version, post_version = pep440_split_post(pieces[\"closest-tag\"])\n            rendered = tag_version\n            if post_version is not None:\n                rendered += \".post%d.dev%d\" % (post_version + 1, pieces[\"distance\"])\n            else:\n                rendered += \".post0.dev%d\" % (pieces[\"distance\"])\n        else:\n            # no commits, use the tag as the version\n            rendered = pieces[\"closest-tag\"]\n    else:\n        # exception #1\n        rendered = \"0.post0.dev%d\" % pieces[\"distance\"]\n    return rendered\n\n\ndef render_pep440_post(pieces):\n    \"\"\"TAG[.postDISTANCE[.dev0]+gHEX] .\n\n    The \".dev0\" means dirty. Note that .dev0 sorts backwards\n    (a dirty tree will appear \"older\" than the corresponding clean one),\n    but you shouldn't be releasing software with -dirty anyways.\n\n    Exceptions:\n    1: no tags. 0.postDISTANCE[.dev0]\n    \"\"\"\n    if pieces[\"closest-tag\"]:\n        rendered = pieces[\"closest-tag\"]\n        if pieces[\"distance\"] or pieces[\"dirty\"]:\n            rendered += \".post%d\" % pieces[\"distance\"]\n            if pieces[\"dirty\"]:\n                rendered += \".dev0\"\n            rendered += plus_or_dot(pieces)\n            rendered += \"g%s\" % pieces[\"short\"]\n    else:\n        # exception #1\n        rendered = \"0.post%d\" % pieces[\"distance\"]\n        if pieces[\"dirty\"]:\n            rendered += \".dev0\"\n        rendered += \"+g%s\" % pieces[\"short\"]\n    return rendered\n\n\ndef render_pep440_post_branch(pieces):\n    \"\"\"TAG[.postDISTANCE[.dev0]+gHEX[.dirty]] .\n\n    The \".dev0\" means not master branch.\n\n    Exceptions:\n    1: no tags. 0.postDISTANCE[.dev0]+gHEX[.dirty]\n    \"\"\"\n    if pieces[\"closest-tag\"]:\n        rendered = pieces[\"closest-tag\"]\n        if pieces[\"distance\"] or pieces[\"dirty\"]:\n            rendered += \".post%d\" % pieces[\"distance\"]\n            if pieces[\"branch\"] != \"master\":\n                rendered += \".dev0\"\n            rendered += plus_or_dot(pieces)\n            rendered += \"g%s\" % pieces[\"short\"]\n            if pieces[\"dirty\"]:\n                rendered += \".dirty\"\n    else:\n        # exception #1\n        rendered = \"0.post%d\" % pieces[\"distance\"]\n        if pieces[\"branch\"] != \"master\":\n            rendered += \".dev0\"\n        rendered += \"+g%s\" % pieces[\"short\"]\n        if pieces[\"dirty\"]:\n            rendered += \".dirty\"\n    return rendered\n\n\ndef render_pep440_old(pieces):\n    \"\"\"TAG[.postDISTANCE[.dev0]] .\n\n    The \".dev0\" means dirty.\n\n    Exceptions:\n    1: no tags. 0.postDISTANCE[.dev0]\n    \"\"\"\n    if pieces[\"closest-tag\"]:\n        rendered = pieces[\"closest-tag\"]\n        if pieces[\"distance\"] or pieces[\"dirty\"]:\n            rendered += \".post%d\" % pieces[\"distance\"]\n            if pieces[\"dirty\"]:\n                rendered += \".dev0\"\n    else:\n        # exception #1\n        rendered = \"0.post%d\" % pieces[\"distance\"]\n        if pieces[\"dirty\"]:\n            rendered += \".dev0\"\n    return rendered\n\n\ndef render_git_describe(pieces):\n    \"\"\"TAG[-DISTANCE-gHEX][-dirty].\n\n    Like 'git describe --tags --dirty --always'.\n\n    Exceptions:\n    1: no tags. HEX[-dirty]  (note: no 'g' prefix)\n    \"\"\"\n    if pieces[\"closest-tag\"]:\n        rendered = pieces[\"closest-tag\"]\n        if pieces[\"distance\"]:\n            rendered += \"-%d-g%s\" % (pieces[\"distance\"], pieces[\"short\"])\n    else:\n        # exception #1\n        rendered = pieces[\"short\"]\n    if pieces[\"dirty\"]:\n        rendered += \"-dirty\"\n    return rendered\n\n\ndef render_git_describe_long(pieces):\n    \"\"\"TAG-DISTANCE-gHEX[-dirty].\n\n    Like 'git describe --tags --dirty --always -long'.\n    The distance/hash is unconditional.\n\n    Exceptions:\n    1: no tags. HEX[-dirty]  (note: no 'g' prefix)\n    \"\"\"\n    if pieces[\"closest-tag\"]:\n        rendered = pieces[\"closest-tag\"]\n        rendered += \"-%d-g%s\" % (pieces[\"distance\"], pieces[\"short\"])\n    else:\n        # exception #1\n        rendered = pieces[\"short\"]\n    if pieces[\"dirty\"]:\n        rendered += \"-dirty\"\n    return rendered\n\n\ndef render(pieces, style):\n    \"\"\"Render the given version pieces into the requested style.\"\"\"\n    if pieces[\"error\"]:\n        return {\"version\": \"unknown\",\n                \"full-revisionid\": pieces.get(\"long\"),\n                \"dirty\": None,\n                \"error\": pieces[\"error\"],\n                \"date\": None}\n\n    if not style or style == \"default\":\n        style = \"pep440\"  # the default\n\n    if style == \"pep440\":\n        rendered = render_pep440(pieces)\n    elif style == \"pep440-branch\":\n        rendered = render_pep440_branch(pieces)\n    elif style == \"pep440-pre\":\n        rendered = render_pep440_pre(pieces)\n    elif style == \"pep440-post\":\n        rendered = render_pep440_post(pieces)\n    elif style == \"pep440-post-branch\":\n        rendered = render_pep440_post_branch(pieces)\n    elif style == \"pep440-old\":\n        rendered = render_pep440_old(pieces)\n    elif style == \"git-describe\":\n        rendered = render_git_describe(pieces)\n    elif style == \"git-describe-long\":\n        rendered = render_git_describe_long(pieces)\n    else:\n        raise ValueError(\"unknown style '%s'\" % style)\n\n    return {\"version\": rendered, \"full-revisionid\": pieces[\"long\"],\n            \"dirty\": pieces[\"dirty\"], \"error\": None,\n            \"date\": pieces.get(\"date\")}\n\n\nclass VersioneerBadRootError(Exception):\n    \"\"\"The project root directory is unknown or missing key files.\"\"\"\n\n\ndef get_versions(verbose=False):\n    \"\"\"Get the project version from whatever source is available.\n\n    Returns dict with two keys: 'version' and 'full'.\n    \"\"\"\n    if \"versioneer\" in sys.modules:\n        # see the discussion in cmdclass.py:get_cmdclass()\n        del sys.modules[\"versioneer\"]\n\n    root = get_root()\n    cfg = get_config_from_root(root)\n\n    assert cfg.VCS is not None, \"please set [versioneer]VCS= in setup.cfg\"\n    handlers = HANDLERS.get(cfg.VCS)\n    assert handlers, \"unrecognized VCS '%s'\" % cfg.VCS\n    verbose = verbose or cfg.verbose\n    assert cfg.versionfile_source is not None, \\\n        \"please set versioneer.versionfile_source\"\n    assert cfg.tag_prefix is not None, \"please set versioneer.tag_prefix\"\n\n    versionfile_abs = os.path.join(root, cfg.versionfile_source)\n\n    # extract version from first of: _version.py, VCS command (e.g. 'git\n    # describe'), parentdir. This is meant to work for developers using a\n    # source checkout, for users of a tarball created by 'setup.py sdist',\n    # and for users of a tarball/zipball created by 'git archive' or github's\n    # download-from-tag feature or the equivalent in other VCSes.\n\n    get_keywords_f = handlers.get(\"get_keywords\")\n    from_keywords_f = handlers.get(\"keywords\")\n    if get_keywords_f and from_keywords_f:\n        try:\n            keywords = get_keywords_f(versionfile_abs)\n            ver = from_keywords_f(keywords, cfg.tag_prefix, verbose)\n            if verbose:\n                print(\"got version from expanded keyword %s\" % ver)\n            return ver\n        except NotThisMethod:\n            pass\n\n    try:\n        ver = versions_from_file(versionfile_abs)\n        if verbose:\n            print(\"got version from file %s %s\" % (versionfile_abs, ver))\n        return ver\n    except NotThisMethod:\n        pass\n\n    from_vcs_f = handlers.get(\"pieces_from_vcs\")\n    if from_vcs_f:\n        try:\n            pieces = from_vcs_f(cfg.tag_prefix, root, verbose)\n            ver = render(pieces, cfg.style)\n            if verbose:\n                print(\"got version from VCS %s\" % ver)\n            return ver\n        except NotThisMethod:\n            pass\n\n    try:\n        if cfg.parentdir_prefix:\n            ver = versions_from_parentdir(cfg.parentdir_prefix, root, verbose)\n            if verbose:\n                print(\"got version from parentdir %s\" % ver)\n            return ver\n    except NotThisMethod:\n        pass\n\n    if verbose:\n        print(\"unable to compute version\")\n\n    return {\"version\": \"0+unknown\", \"full-revisionid\": None,\n            \"dirty\": None, \"error\": \"unable to compute version\",\n            \"date\": None}\n\n\ndef get_version():\n    \"\"\"Get the short version string for this project.\"\"\"\n    return get_versions()[\"version\"]\n\n\ndef get_cmdclass(cmdclass=None):\n    \"\"\"Get the custom setuptools subclasses used by Versioneer.\n\n    If the package uses a different cmdclass (e.g. one from numpy), it\n    should be provide as an argument.\n    \"\"\"\n    if \"versioneer\" in sys.modules:\n        del sys.modules[\"versioneer\"]\n        # this fixes the \"python setup.py develop\" case (also 'install' and\n        # 'easy_install .'), in which subdependencies of the main project are\n        # built (using setup.py bdist_egg) in the same python process. Assume\n        # a main project A and a dependency B, which use different versions\n        # of Versioneer. A's setup.py imports A's Versioneer, leaving it in\n        # sys.modules by the time B's setup.py is executed, causing B to run\n        # with the wrong versioneer. Setuptools wraps the sub-dep builds in a\n        # sandbox that restores sys.modules to it's pre-build state, so the\n        # parent is protected against the child's \"import versioneer\". By\n        # removing ourselves from sys.modules here, before the child build\n        # happens, we protect the child from the parent's versioneer too.\n        # Also see https://github.com/python-versioneer/python-versioneer/issues/52\n\n    cmds = {} if cmdclass is None else cmdclass.copy()\n\n    # we add \"version\" to setuptools\n    from setuptools import Command\n\n    class cmd_version(Command):\n        description = \"report generated version string\"\n        user_options = []\n        boolean_options = []\n\n        def initialize_options(self):\n            pass\n\n        def finalize_options(self):\n            pass\n\n        def run(self):\n            vers = get_versions(verbose=True)\n            print(\"Version: %s\" % vers[\"version\"])\n            print(\" full-revisionid: %s\" % vers.get(\"full-revisionid\"))\n            print(\" dirty: %s\" % vers.get(\"dirty\"))\n            print(\" date: %s\" % vers.get(\"date\"))\n            if vers[\"error\"]:\n                print(\" error: %s\" % vers[\"error\"])\n    cmds[\"version\"] = cmd_version\n\n    # we override \"build_py\" in setuptools\n    #\n    # most invocation pathways end up running build_py:\n    #  distutils/build -> build_py\n    #  distutils/install -> distutils/build ->..\n    #  setuptools/bdist_wheel -> distutils/install ->..\n    #  setuptools/bdist_egg -> distutils/install_lib -> build_py\n    #  setuptools/install -> bdist_egg ->..\n    #  setuptools/develop -> ?\n    #  pip install:\n    #   copies source tree to a tempdir before running egg_info/etc\n    #   if .git isn't copied too, 'git describe' will fail\n    #   then does setup.py bdist_wheel, or sometimes setup.py install\n    #  setup.py egg_info -> ?\n\n    # pip install -e . and setuptool/editable_wheel will invoke build_py\n    # but the build_py command is not expected to copy any files.\n\n    # we override different \"build_py\" commands for both environments\n    if 'build_py' in cmds:\n        _build_py = cmds['build_py']\n    else:\n        from setuptools.command.build_py import build_py as _build_py\n\n    class cmd_build_py(_build_py):\n        def run(self):\n            root = get_root()\n            cfg = get_config_from_root(root)\n            versions = get_versions()\n            _build_py.run(self)\n            if getattr(self, \"editable_mode\", False):\n                # During editable installs `.py` and data files are\n                # not copied to build_lib\n                return\n            # now locate _version.py in the new build/ directory and replace\n            # it with an updated value\n            if cfg.versionfile_build:\n                target_versionfile = os.path.join(self.build_lib,\n                                                  cfg.versionfile_build)\n                print(\"UPDATING %s\" % target_versionfile)\n                write_to_version_file(target_versionfile, versions)\n    cmds[\"build_py\"] = cmd_build_py\n\n    if 'build_ext' in cmds:\n        _build_ext = cmds['build_ext']\n    else:\n        from setuptools.command.build_ext import build_ext as _build_ext\n\n    class cmd_build_ext(_build_ext):\n        def run(self):\n            root = get_root()\n            cfg = get_config_from_root(root)\n            versions = get_versions()\n            _build_ext.run(self)\n            if self.inplace:\n                # build_ext --inplace will only build extensions in\n                # build/lib<..> dir with no _version.py to write to.\n                # As in place builds will already have a _version.py\n                # in the module dir, we do not need to write one.\n                return\n            # now locate _version.py in the new build/ directory and replace\n            # it with an updated value\n            if not cfg.versionfile_build:\n                return\n            target_versionfile = os.path.join(self.build_lib,\n                                              cfg.versionfile_build)\n            if not os.path.exists(target_versionfile):\n                print(f\"Warning: {target_versionfile} does not exist, skipping \"\n                      \"version update. This can happen if you are running build_ext \"\n                      \"without first running build_py.\")\n                return\n            print(\"UPDATING %s\" % target_versionfile)\n            write_to_version_file(target_versionfile, versions)\n    cmds[\"build_ext\"] = cmd_build_ext\n\n    if \"cx_Freeze\" in sys.modules:  # cx_freeze enabled?\n        from cx_Freeze.dist import build_exe as _build_exe\n        # nczeczulin reports that py2exe won't like the pep440-style string\n        # as FILEVERSION, but it can be used for PRODUCTVERSION, e.g.\n        # setup(console=[{\n        #   \"version\": versioneer.get_version().split(\"+\", 1)[0], # FILEVERSION\n        #   \"product_version\": versioneer.get_version(),\n        #   ...\n\n        class cmd_build_exe(_build_exe):\n            def run(self):\n                root = get_root()\n                cfg = get_config_from_root(root)\n                versions = get_versions()\n                target_versionfile = cfg.versionfile_source\n                print(\"UPDATING %s\" % target_versionfile)\n                write_to_version_file(target_versionfile, versions)\n\n                _build_exe.run(self)\n                os.unlink(target_versionfile)\n                with open(cfg.versionfile_source, \"w\") as f:\n                    LONG = LONG_VERSION_PY[cfg.VCS]\n                    f.write(LONG %\n                            {\"DOLLAR\": \"$\",\n                             \"STYLE\": cfg.style,\n                             \"TAG_PREFIX\": cfg.tag_prefix,\n                             \"PARENTDIR_PREFIX\": cfg.parentdir_prefix,\n                             \"VERSIONFILE_SOURCE\": cfg.versionfile_source,\n                             })\n        cmds[\"build_exe\"] = cmd_build_exe\n        del cmds[\"build_py\"]\n\n    if 'py2exe' in sys.modules:  # py2exe enabled?\n        try:\n            from py2exe.setuptools_buildexe import py2exe as _py2exe\n        except ImportError:\n            from py2exe.distutils_buildexe import py2exe as _py2exe\n\n        class cmd_py2exe(_py2exe):\n            def run(self):\n                root = get_root()\n                cfg = get_config_from_root(root)\n                versions = get_versions()\n                target_versionfile = cfg.versionfile_source\n                print(\"UPDATING %s\" % target_versionfile)\n                write_to_version_file(target_versionfile, versions)\n\n                _py2exe.run(self)\n                os.unlink(target_versionfile)\n                with open(cfg.versionfile_source, \"w\") as f:\n                    LONG = LONG_VERSION_PY[cfg.VCS]\n                    f.write(LONG %\n                            {\"DOLLAR\": \"$\",\n                             \"STYLE\": cfg.style,\n                             \"TAG_PREFIX\": cfg.tag_prefix,\n                             \"PARENTDIR_PREFIX\": cfg.parentdir_prefix,\n                             \"VERSIONFILE_SOURCE\": cfg.versionfile_source,\n                             })\n        cmds[\"py2exe\"] = cmd_py2exe\n\n    # sdist farms its file list building out to egg_info\n    if 'egg_info' in cmds:\n        _egg_info = cmds['egg_info']\n    else:\n        from setuptools.command.egg_info import egg_info as _egg_info\n\n    class cmd_egg_info(_egg_info):\n        def find_sources(self):\n            # egg_info.find_sources builds the manifest list and writes it\n            # in one shot\n            super().find_sources()\n\n            # Modify the filelist and normalize it\n            root = get_root()\n            cfg = get_config_from_root(root)\n            self.filelist.append('versioneer.py')\n            if cfg.versionfile_source:\n                # There are rare cases where versionfile_source might not be\n                # included by default, so we must be explicit\n                self.filelist.append(cfg.versionfile_source)\n            self.filelist.sort()\n            self.filelist.remove_duplicates()\n\n            # The write method is hidden in the manifest_maker instance that\n            # generated the filelist and was thrown away\n            # We will instead replicate their final normalization (to unicode,\n            # and POSIX-style paths)\n            from setuptools import unicode_utils\n            normalized = [unicode_utils.filesys_decode(f).replace(os.sep, '/')\n                          for f in self.filelist.files]\n\n            manifest_filename = os.path.join(self.egg_info, 'SOURCES.txt')\n            with open(manifest_filename, 'w') as fobj:\n                fobj.write('\\n'.join(normalized))\n\n    cmds['egg_info'] = cmd_egg_info\n\n    # we override different \"sdist\" commands for both environments\n    if 'sdist' in cmds:\n        _sdist = cmds['sdist']\n    else:\n        from setuptools.command.sdist import sdist as _sdist\n\n    class cmd_sdist(_sdist):\n        def run(self):\n            versions = get_versions()\n            self._versioneer_generated_versions = versions\n            # unless we update this, the command will keep using the old\n            # version\n            self.distribution.metadata.version = versions[\"version\"]\n            return _sdist.run(self)\n\n        def make_release_tree(self, base_dir, files):\n            root = get_root()\n            cfg = get_config_from_root(root)\n            _sdist.make_release_tree(self, base_dir, files)\n            # now locate _version.py in the new base_dir directory\n            # (remembering that it may be a hardlink) and replace it with an\n            # updated value\n            target_versionfile = os.path.join(base_dir, cfg.versionfile_source)\n            print(\"UPDATING %s\" % target_versionfile)\n            write_to_version_file(target_versionfile,\n                                  self._versioneer_generated_versions)\n    cmds[\"sdist\"] = cmd_sdist\n\n    return cmds\n\n\nCONFIG_ERROR = \"\"\"\nsetup.cfg is missing the necessary Versioneer configuration. You need\na section like:\n\n [versioneer]\n VCS = git\n style = pep440\n versionfile_source = src/myproject/_version.py\n versionfile_build = myproject/_version.py\n tag_prefix =\n parentdir_prefix = myproject-\n\nYou will also need to edit your setup.py to use the results:\n\n import versioneer\n setup(version=versioneer.get_version(),\n       cmdclass=versioneer.get_cmdclass(), ...)\n\nPlease read the docstring in ./versioneer.py for configuration instructions,\nedit setup.cfg, and re-run the installer or 'python versioneer.py setup'.\n\"\"\"\n\nSAMPLE_CONFIG = \"\"\"\n# See the docstring in versioneer.py for instructions. Note that you must\n# re-run 'versioneer.py setup' after changing this section, and commit the\n# resulting files.\n\n[versioneer]\n#VCS = git\n#style = pep440\n#versionfile_source =\n#versionfile_build =\n#tag_prefix =\n#parentdir_prefix =\n\n\"\"\"\n\nOLD_SNIPPET = \"\"\"\nfrom ._version import get_versions\n__version__ = get_versions()['version']\ndel get_versions\n\"\"\"\n\nINIT_PY_SNIPPET = \"\"\"\nfrom . import {0}\n__version__ = {0}.get_versions()['version']\n\"\"\"\n\n\ndef do_setup():\n    \"\"\"Do main VCS-independent setup function for installing Versioneer.\"\"\"\n    root = get_root()\n    try:\n        cfg = get_config_from_root(root)\n    except (OSError, configparser.NoSectionError,\n            configparser.NoOptionError) as e:\n        if isinstance(e, (OSError, configparser.NoSectionError)):\n            print(\"Adding sample versioneer config to setup.cfg\",\n                  file=sys.stderr)\n            with open(os.path.join(root, \"setup.cfg\"), \"a\") as f:\n                f.write(SAMPLE_CONFIG)\n        print(CONFIG_ERROR, file=sys.stderr)\n        return 1\n\n    print(\" creating %s\" % cfg.versionfile_source)\n    with open(cfg.versionfile_source, \"w\") as f:\n        LONG = LONG_VERSION_PY[cfg.VCS]\n        f.write(LONG % {\"DOLLAR\": \"$\",\n                        \"STYLE\": cfg.style,\n                        \"TAG_PREFIX\": cfg.tag_prefix,\n                        \"PARENTDIR_PREFIX\": cfg.parentdir_prefix,\n                        \"VERSIONFILE_SOURCE\": cfg.versionfile_source,\n                        })\n\n    ipy = os.path.join(os.path.dirname(cfg.versionfile_source),\n                       \"__init__.py\")\n    if os.path.exists(ipy):\n        try:\n            with open(ipy, \"r\") as f:\n                old = f.read()\n        except OSError:\n            old = \"\"\n        module = os.path.splitext(os.path.basename(cfg.versionfile_source))[0]\n        snippet = INIT_PY_SNIPPET.format(module)\n        if OLD_SNIPPET in old:\n            print(\" replacing boilerplate in %s\" % ipy)\n            with open(ipy, \"w\") as f:\n                f.write(old.replace(OLD_SNIPPET, snippet))\n        elif snippet not in old:\n            print(\" appending to %s\" % ipy)\n            with open(ipy, \"a\") as f:\n                f.write(snippet)\n        else:\n            print(\" %s unmodified\" % ipy)\n    else:\n        print(\" %s doesn't exist, ok\" % ipy)\n        ipy = None\n\n    # Make VCS-specific changes. For git, this means creating/changing\n    # .gitattributes to mark _version.py for export-subst keyword\n    # substitution.\n    do_vcs_install(cfg.versionfile_source, ipy)\n    return 0\n\n\ndef scan_setup_py():\n    \"\"\"Validate the contents of setup.py against Versioneer's expectations.\"\"\"\n    found = set()\n    setters = False\n    errors = 0\n    with open(\"setup.py\", \"r\") as f:\n        for line in f.readlines():\n            if \"import versioneer\" in line:\n                found.add(\"import\")\n            if \"versioneer.get_cmdclass()\" in line:\n                found.add(\"cmdclass\")\n            if \"versioneer.get_version()\" in line:\n                found.add(\"get_version\")\n            if \"versioneer.VCS\" in line:\n                setters = True\n            if \"versioneer.versionfile_source\" in line:\n                setters = True\n    if len(found) != 3:\n        print(\"\")\n        print(\"Your setup.py appears to be missing some important items\")\n        print(\"(but I might be wrong). Please make sure it has something\")\n        print(\"roughly like the following:\")\n        print(\"\")\n        print(\" import versioneer\")\n        print(\" setup( version=versioneer.get_version(),\")\n        print(\"        cmdclass=versioneer.get_cmdclass(),  ...)\")\n        print(\"\")\n        errors += 1\n    if setters:\n        print(\"You should remove lines like 'versioneer.VCS = ' and\")\n        print(\"'versioneer.versionfile_source = ' . This configuration\")\n        print(\"now lives in setup.cfg, and should be removed from setup.py\")\n        print(\"\")\n        errors += 1\n    return errors\n\n\ndef setup_command():\n    \"\"\"Set up Versioneer and exit with appropriate error code.\"\"\"\n    errors = do_setup()\n    errors += scan_setup_py()\n    sys.exit(1 if errors else 0)\n\n\nif __name__ == \"__main__\":\n    cmd = sys.argv[1]\n    if cmd == \"setup\":\n        setup_command()\n"
        }
      ]
    }
  ]
}