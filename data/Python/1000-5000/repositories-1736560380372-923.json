{
  "metadata": {
    "timestamp": 1736560380372,
    "page": 923,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjkzMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "eliben/pycparser",
      "stars": 3285,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.03125,
          "content": "*.ppout linguist-vendored=true\n\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.1611328125,
          "content": "*.pyc\ntests/parser.out\ntests/*tab.py\nbuild\nyacctab.py\nlextab.py\ndist\nMANIFEST\n*.exe\n*.o\nparser.out\n*.orig\n*.rej\n.tox\nutils/z.c\n*.egg-info\n*.swp\n.DS_Store\nast.pickle\n"
        },
        {
          "name": ".vimrc",
          "type": "blob",
          "size": 0.267578125,
          "content": "\" Force indentation styles for this directory\nautocmd FileType python set shiftwidth=4\nautocmd FileType python set tabstop=4\nautocmd FileType python set softtabstop=4\n\nautocmd FileType c set shiftwidth=2\nautocmd FileType c set tabstop=2\nautocmd FileType c set softtabstop=2\n"
        },
        {
          "name": "CHANGES",
          "type": "blob",
          "size": 10.93359375,
          "content": "+ Starting with version 2.22, please use the GitHub UI\n  at https://github.com/eliben/pycparser/tags\n  to compare tags in order to find out what changed.\n\n+ Version 2.21 (2021.11.06)\n\n  - Much improved support for C11 (multiple PRs)\n  - Support for parehthesized compount statements (#423)\n  - Support for modern Python versions (3.9 and 3.10)\n  - Fix support for structs with nested enums (#387)\n  - Multiple small bug fixes\n\n+ Version 2.20 (2020.03.04)\n\n  - #61: Fix slow backtracking when parsing strings.\n  - #99: Parser for FuncDecl incorrectly sets declname attribute on return type.\n  - #310: Fix crash when file starts with a semicolon.\n  - #313: Fix array type generation.\n  - #314: Fix failed parsing of unnamed function parameters with array dim\n    qualifiers.\n  - #315: Fix pointer type generation.\n  - #324: Fixes for u/l constant integer suffix.\n  - #346: Fix error transforming an empty switch.\n  - #350: Recognize integer multicharacter constants like 'ABCD'.\n  - #363: Fix incorrect AST when parsing offsetof.\n\n+ Version 2.19 (2018.09.19)\n\n  - PR #277: Fix parsing of floating point literals\n  - PR #254: Add support for parsing empty structs\n  - PR #240: Fix enum formatting in generated C code (also #216)\n  - PR #222: Add support for #pragma in struct declarations\n  - There are reports that this release doesn't work with Python 2.6 (#281).\n    Please note that the minimal supported version is 2.7; the required versions\n    are listed in the README file.\n\n+ Version 2.18 (2017.07.04)\n\n  - PR #161 & #184: Update bundled PLY version to 3.10\n  - PR #158: Add support for the __int128 type.\n  - PR #169: Handle more tricky TYPEID in declarators.\n  - PR #178: Add columns to the coord of each node\n\n+ Version 2.17 (2016.10.29)\n\n  - Again functionality identical to 2.15 and 2.16; the difference is that the\n    tarball now contains Python files with properly set permissions.\n\n+ Version 2.16 (2016.10.18)\n\n  - Functionally identical to 2.15, but fixes a packaging problem that caused\n    failed installation (_build_tables wasn't rerun in the pycparser/ dir).\n\n+ Version 2.15 (2016.10.18)\n\n  - PR #121: Update bundled PLY version to 3.8\n  - Issue #117: Fix parsing of extra semi-colons inside structure declarations.\n  - PR #109: Update c_generator to add {} around nested named initializers.\n  - PR #101: Added support for parsing pragmas into the AST.\n  - Additional fake headers and typedefs, manifest fixes (#97, #106, #111).\n  - Testing with Python 3.5 instead of 3.3 now (3.4 and 3.5 are the 3.x versions\n    tested).\n  - PR #145: More complete support for offsetof()\n  - Issue #116: Fix line numbers recorded for empty and compound statements.\n  - Minor performance improvement to the invalid string literal regex.\n\n+ Version 2.14 (2015.06.09)\n\n  - Added CParser parameter to specify output directory for generated parsing\n    tables (#84).\n  - Removed lcc's cpp and its license from the distribution. Using lcc's cpp\n    is no longer recommended, now that Clang has binary builds available for\n    Windows.\n\n+ Version 2.13 (2015.05.12)\n\n  - Added support for offsetof() the way gcc implements it (special builtin\n    that takes a type as an argument).\n  - Added faked va_* macros (these are expected to come from stdarg.h)\n  - Added a bunch more fake headers and typedefs to support parsing C projects\n    like Git and SQLite without modifications to pycparser.\n  - Added support for empty initializer lists (#79).\n\n+ Version 2.12 (2015.04.21)\n\n  - This is a fix release for 2.11; the memory optimization with __slots__ on\n    Coord and AST nodes didn't take weakrefs into account, which broke cffi and\n    its many dependents (issue #76). Fixed by adding __weakref__ to __slots__.\n\n+ Version 2.11 (2015.04.21)\n\n  - Add support for C99 6.5.3.7 p7 - qualifiers within array dimensions in\n    function declarations. Started with issue #21 (reported with initial patch\n    by Robin Martinjak).\n  - Issue #27: bug in handling of unified wstring literals.\n  - Issue #28: fix coord reporting for 'for' loops.\n  - Added ``examples/using_gcc_E_libc.py`` to demonstrate how ``gcc -E`` can\n    be used instead of ``cpp`` for preprocessing.\n  - Pull request #64: support keywords like const, volatile, restrict and static\n    in dimensions in array declarations.\n  - Reduce memory usage of AST nodes (issue #72).\n  - Parsing order of nested pointer declarations fixed (issue #68).\n\n+ Version 2.10 (2013.08.03)\n\n  - A number of improvements in the handling of typedef-name ambiguities,\n    contributed by Sye van der Veen in GitHub issue #1:\n\n    * Allow shadowing of types by identifiers in inner scopes.\n    * Allow struct field names to reside in a separate namespace and have\n      the same names as types.\n    * Allow duplicate typedefs in some cases to mimic real compiler behavior.\n\n  - c_generator error for ExprList in expression context.\n  - Assume default int type for functions whose argument or return types were\n    not specified.\n  - Relax the lexer a bit w.r.t. some integer suffixes and $ in identifier names\n    (which is supported by some other compilers).\n\n+ Version 2.09.1 (2012.12.29)\n\n  - No actual functionality changes.\n  - The source distribution was re-packaged to contain the pre-generated Lex and\n    Yacc tables of PLY.\n\n+ Version 2.09 (2012.12.27)\n\n  - The pycparser project has moved to Bitbucket. For this version, issue\n    numbers still refer to the old Googlecode project, unless stated otherwise.\n    Starting with the next version all issue numbers will refer to the new\n    Bitbucket project.\n  - pycparser now carries its PLY dependency along. The pycparser/ply directory\n    contains the source of PLY for the currently supported version. This makes\n    distribution and testing easier.\n  - Issue #79: fix generation of new switch/case AST nodes.\n  - Issue #83: fix parsing and C generation to distinguish between initializer\n    lists in declarations and initializing variables with parenthesized\n    comma-separated expressions.\n  - Issue #84: fix C generation for some statements.\n  - Issues #86 and #87: improve location reporting for parse errors.\n  - Issue #89: fix C generation for K&R-style function definitions.\n\n+ Version 2.08 (2012.08.10)\n\n  - Issue 73: initial support for #pragma directives. Consume them without\n    errors and ignore (no tokens are returned). Line numbers are preserved.\n  - Issue 68: more correct handling of source files without any actual content.\n  - Issue 69: running all tests will now set appropriate return code.\n  - Better error reporting in case where multiple type specifiers are provided.\n    Also fixes Issue 60.\n  - Issue 63: line endings cleanup for consistent LF ending.\n  - Issues 64 & 65: added some more headers and typedefs to fake includes.\n  - Refactoring the cpp invocation in parse_file into a separate function, which\n    can also be used as a utility.\n  - Issue 74: some Windows include paths were handled incorrectly.\n\n+ Version 2.07 (2012.06.16)\n\n  - Issue 54: added an optional parser argument to parse_file\n  - Issue 59: added some more fake headers for C99\n  - Issue 62: correct coord for Ellipsis nodes\n  - Issue 57: support for C99 hexadecimal float constants\n  - Made running tests that call on 'cpp' a bit more robust.\n\n+ Version 2.06 (2012.02.04)\n\n  - Issue 48: gracefully handle parsing of empty files\n  - Issues 49 & 50: handle more escaped chars in paths to #line - \"..\\..\\test.h\".\n  - Support for C99 _Complex type.\n  - CGenerator moves from examples/ to pycparser/ as a first-class citizen, and\n    added some fixes to it. examples/c-to-c.py still stays as a convenience\n    wrapper.\n  - Fix problem with parsing a file in which the first statement is just a\n    semicolon.\n  - Improved the AST created for switch statements, making it closer to the\n    semantic meaning than to the grammar.\n\n+ Version 2.05 (2011.10.16)\n\n  - Added support for the C99 ``_Bool`` type and ``stdbool.h`` header file\n  - Expanded ``examples/explore_ast.py`` with more details on working with the\n    AST\n  - Relaxed the rules on parsing unnamed struct members (helps parse ``windows.h``)\n  - Bug fixes:\n\n    * Fixed spacing issue for some type declarations\n    * Issue 47: display empty statements (lone ';') correctly after parsing\n\n+ Version 2.04 (2011.05.21)\n\n  - License changed from LGPL to BSD\n  - Bug fixes:\n\n    * Issue 31: constraining the scope of typedef definitions\n    * Issues 33, 35: fixes for the c-to-c.py example\n\n  - Added C99 integer types to fake headers\n  - Added unit tests for the c-to-c.py example\n\n+ Version 2.03 (2011.03.06)\n\n  - Bug fixes:\n\n    * Issue 17: empty file-level declarations\n    * Issue 18: empty statements and declarations in functions\n    * Issue 19: anonymous structs & union fields\n    * Issue 23: fix coordinates of Cast nodes\n\n  - New example added (``examples/c-to-c.py``) for translating ASTs generated\n    by ``pycparser`` back into C code.\n  - ``pycparser`` is now on PyPI (Python Package Index)\n  - Created `FAQ <http://code.google.com/p/pycparser/wiki/FAQ>`_ on\n    the ``pycparser`` project page\n  - Removed support for Python 2.5. ``pycparser`` supports Python 2\n    from 2.6 and on, and Python 3.\n\n+ Version 2.02 (2010.12.10)\n\n  * The name of a ``NamedInitializer`` node was turned into a sequence of nodes\n    instead of an attribute, to make it discoverable by the AST node visitor.\n  * Documentation updates\n\n+ Version 2.01 (04.12.2010)\n\n  * Removed dependency on YAML. Parsing of the AST node configuration file\n    is done with a simple parser.\n  * Fixed issue 12: installation problems\n\n+ Version 2.00 (2010.10.31)\n\n  * Support for C99 (read\n    `this wiki page <http://code.google.com/p/pycparser/wiki/C99support>`_\n    for more information).\n\n+ Version 1.08 (2010.10.09)\n\n  * Bug fixes:\n\n    + Correct handling of ``do{} ... while`` statements in some cases\n    + Issues 6 & 7: Concatenation of string literals\n    + Issue 9: Support for unnamed bitfields in structs\n\n+ Version 1.07 (2010.05.18)\n\n  * Python 3.1 compatibility: ``pycparser`` was modified to run\n    on Python 3.1 as well as 2.6\n\n+ Version 1.06 (2010.04.10)\n\n  * Bug fixes:\n\n    + coord not propagated to FuncCall nodes\n    + lexing of the ^= token (XOREQUALS)\n    + parsing failed on some abstract declarator rules\n\n  * Linux compatibility: fixed end-of-line and ``cpp`` path issues to allow\n    all tests and examples run on Linux\n\n+ Version 1.05 (2009.10.16)\n\n  * Fixed the ``parse_file`` auxiliary function to handle multiple arguments to\n    ``cpp`` correctly\n\n+ Version 1.04 (2009.05.22)\n\n  * Added the ``fake_libc_include`` directory to allow parsing of C code that\n    uses standard C library include files without dependency on a real C\n    library.\n  * Tested with Python 2.6 and PLY 3.2\n\n+ Version 1.03 (2009.01.31)\n\n  * Accept enumeration lists with a comma after the last item (C99 feature).\n\n+ Version 1.02 (2009.01.16)\n\n  * Fixed problem of parsing struct/enum/union names that were named similarly\n    to previously defined ``typedef`` types.\n\n+ Version 1.01 (2009.01.09)\n\n  * Fixed subprocess invocation in the helper function parse_file - now\n    it's more portable\n\n+ Version 1.0 (2008.11.15)\n\n  * Initial release\n  * Support for ANSI C89\n"
        },
        {
          "name": "CONTRIBUTORS",
          "type": "blob",
          "size": 0.583984375,
          "content": "This is a list of people who have contributed to pycparser by supplying patches,\nopening issues, or generally helping out, before the project moved to Github.\n\nFor more recent contributions, check out the \"Contributors\" page of the\npycparser Github project.\n\nThe list is sorted in increasing alphabetic order by first name.\n\n* Andreas Kl√∂ckner\n* Andrew de los Reyes\n* Benoit Pradelle\n* Dov Feldstern\n* Even Wiik Thomassen\n* Greg Smith\n* Jaroslav Franek\n* Li Xuan Ji\n* Mateusz Czaplinski\n* Paolo Di Maio\n* Rory Yorke\n* Rubin\n* Scott Tsai\n* Sye van der Veen\n* Thomas W. Barr\n* Tomer Segal\n* Weyllor\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.5068359375,
          "content": "pycparser -- A C parser in Python\n\nCopyright (c) 2008-2022, Eli Bendersky\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above copyright notice, this \n  list of conditions and the following disclaimer.\n* Redistributions in binary form must reproduce the above copyright notice, \n  this list of conditions and the following disclaimer in the documentation \n  and/or other materials provided with the distribution.\n* Neither the name of the copyright holder nor the names of its contributors may \n  be used to endorse or promote products derived from this software without \n  specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND \nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED \nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE \nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE \nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR \nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE \nGOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) \nHOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT \nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT \nOF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "MANIFEST.in",
          "type": "blob",
          "size": 0.3271484375,
          "content": "recursive-include examples *.c *.h *.py\nrecursive-include tests *.c *.h *.py\nrecursive-include pycparser *.py *.cfg\nrecursive-include utils/fake_libc_include *.h\ninclude README.*\ninclude LICENSE\ninclude CHANGES\ninclude setup.*\nexclude setup.pyc\n\nrecursive-exclude tests yacctab.* lextab.*\nrecursive-exclude examples yacctab.* lextab.*\n"
        },
        {
          "name": "README.rst",
          "type": "blob",
          "size": 7.7822265625,
          "content": "===============\npycparser v2.22\n===============\n\n\n.. image:: https://github.com/eliben/pycparser/workflows/pycparser-tests/badge.svg\n  :align: center\n  :target: https://github.com/eliben/pycparser/actions\n\n----\n\n.. contents::\n    :backlinks: none\n\n.. sectnum::\n\n\nIntroduction\n============\n\nWhat is pycparser?\n------------------\n\n**pycparser** is a parser for the C language, written in pure Python. It is a\nmodule designed to be easily integrated into applications that need to parse\nC source code.\n\nWhat is it good for?\n--------------------\n\nAnything that needs C code to be parsed. The following are some uses for\n**pycparser**, taken from real user reports:\n\n* C code obfuscator\n* Front-end for various specialized C compilers\n* Static code checker\n* Automatic unit-test discovery\n* Adding specialized extensions to the C language\n\nOne of the most popular uses of **pycparser** is in the `cffi\n<https://cffi.readthedocs.io/en/latest/>`_ library, which uses it to parse the\ndeclarations of C functions and types in order to auto-generate FFIs.\n\n**pycparser** is unique in the sense that it's written in pure Python - a very\nhigh level language that's easy to experiment with and tweak. To people familiar\nwith Lex and Yacc, **pycparser**'s code will be simple to understand. It also\nhas no external dependencies (except for a Python interpreter), making it very\nsimple to install and deploy.\n\nWhich version of C does pycparser support?\n------------------------------------------\n\n**pycparser** aims to support the full C99 language (according to the standard\nISO/IEC 9899). Some features from C11 are also supported, and patches to support\nmore are welcome.\n\n**pycparser** supports very few GCC extensions, but it's fairly easy to set\nthings up so that it parses code with a lot of GCC-isms successfully. See the\n`FAQ <https://github.com/eliben/pycparser/wiki/FAQ>`_ for more details.\n\nWhat grammar does pycparser follow?\n-----------------------------------\n\n**pycparser** very closely follows the C grammar provided in Annex A of the C99\nstandard (ISO/IEC 9899).\n\nHow is pycparser licensed?\n--------------------------\n\n`BSD license <https://github.com/eliben/pycparser/blob/master/LICENSE>`_.\n\nContact details\n---------------\n\nFor reporting problems with **pycparser** or submitting feature requests, please\nopen an `issue <https://github.com/eliben/pycparser/issues>`_, or submit a\npull request.\n\n\nInstalling\n==========\n\nPrerequisites\n-------------\n\n* **pycparser** was tested with Python 3.8+ on Linux, macOS and Windows.\n\n* **pycparser** has no external dependencies. The only non-stdlib library it\n  uses is PLY, which is bundled in ``pycparser/ply``. The current PLY version is\n  3.10, retrieved from `<http://www.dabeaz.com/ply/>`_\n\nNote that **pycparser** (and PLY) uses docstrings for grammar specifications.\nPython installations that strip docstrings (such as when using the Python\n``-OO`` option) will fail to instantiate and use **pycparser**. You can try to\nwork around this problem by making sure the PLY parsing tables are pre-generated\nin normal mode; this isn't an officially supported/tested mode of operation,\nthough.\n\nInstallation process\n--------------------\n\nThe recommended way to install **pycparser** is with ``pip``::\n\n    > pip install pycparser\n\nUsing\n=====\n\nInteraction with the C preprocessor\n-----------------------------------\n\nIn order to be compilable, C code must be preprocessed by the C preprocessor -\n``cpp``. ``cpp`` handles preprocessing directives like ``#include`` and\n``#define``, removes comments, and performs other minor tasks that prepare the C\ncode for compilation.\n\nFor all but the most trivial snippets of C code **pycparser**, like a C\ncompiler, must receive preprocessed C code in order to function correctly. If\nyou import the top-level ``parse_file`` function from the **pycparser** package,\nit will interact with ``cpp`` for you, as long as it's in your PATH, or you\nprovide a path to it.\n\nNote also that you can use ``gcc -E`` or ``clang -E`` instead of ``cpp``. See\nthe ``using_gcc_E_libc.py`` example for more details. Windows users can download\nand install a binary build of Clang for Windows `from this website\n<http://llvm.org/releases/download.html>`_.\n\nWhat about the standard C library headers?\n------------------------------------------\n\nC code almost always ``#include``\\s various header files from the standard C\nlibrary, like ``stdio.h``. While (with some effort) **pycparser** can be made to\nparse the standard headers from any C compiler, it's much simpler to use the\nprovided \"fake\" standard includes for C11 in ``utils/fake_libc_include``. These\nare standard C header files that contain only the bare necessities to allow\nvalid parsing of the files that use them. As a bonus, since they're minimal, it\ncan significantly improve the performance of parsing large C files.\n\nThe key point to understand here is that **pycparser** doesn't really care about\nthe semantics of types. It only needs to know whether some token encountered in\nthe source is a previously defined type. This is essential in order to be able\nto parse C correctly.\n\nSee `this blog post\n<https://eli.thegreenplace.net/2015/on-parsing-c-type-declarations-and-fake-headers>`_\nfor more details.\n\nNote that the fake headers are not included in the ``pip`` package nor installed\nvia ``setup.py`` (`#224 <https://github.com/eliben/pycparser/issues/224>`_).\n\nBasic usage\n-----------\n\nTake a look at the |examples|_ directory of the distribution for a few examples\nof using **pycparser**. These should be enough to get you started. Please note\nthat most realistic C code samples would require running the C preprocessor\nbefore passing the code to **pycparser**; see the previous sections for more\ndetails.\n\n.. |examples| replace:: ``examples``\n.. _examples: examples\n\n\nAdvanced usage\n--------------\n\nThe public interface of **pycparser** is well documented with comments in\n``pycparser/c_parser.py``. For a detailed overview of the various AST nodes\ncreated by the parser, see ``pycparser/_c_ast.cfg``.\n\nThere's also a `FAQ available here <https://github.com/eliben/pycparser/wiki/FAQ>`_.\nIn any case, you can always drop me an `email <eliben@gmail.com>`_ for help.\n\n\nModifying\n=========\n\nThere are a few points to keep in mind when modifying **pycparser**:\n\n* The code for **pycparser**'s AST nodes is automatically generated from a\n  configuration file - ``_c_ast.cfg``, by ``_ast_gen.py``. If you modify the AST\n  configuration, make sure to re-generate the code. This can be done by running\n  the ``_build_tables.py`` script from the ``pycparser`` directory.\n* Make sure you understand the optimized mode of **pycparser** - for that you\n  must read the docstring in the constructor of the ``CParser`` class. For\n  development you should create the parser without optimizations, so that it\n  will regenerate the Yacc and Lex tables when you change the grammar.\n\n\nPackage contents\n================\n\nOnce you unzip the ``pycparser`` package, you'll see the following files and\ndirectories:\n\nREADME.rst:\n  This README file.\n\nLICENSE:\n  The pycparser license\n\nsetup.py:\n  Installation script\n\nexamples/:\n  A directory with some examples of using **pycparser**\n\npycparser/:\n  The **pycparser** module source code.\n\ntests/:\n  Unit tests.\n\nutils/fake_libc_include:\n  Minimal standard C library include files that should allow to parse any C code.\n  Note that these headers now include C11 code, so they may not work when the\n  preprocessor is configured to an earlier C standard (like ``-std=c99``).\n\nutils/internal/:\n  Internal utilities for my own use. You probably don't need them.\n\n\nContributors\n============\n\nSome people have contributed to **pycparser** by opening issues on bugs they've\nfound and/or submitting patches. The list of contributors is in the CONTRIBUTORS\nfile in the source distribution. After **pycparser** moved to Github I stopped\nupdating this list because Github does a much better job at tracking\ncontributions.\n\n\n"
        },
        {
          "name": "SECURITY.md",
          "type": "blob",
          "size": 0.5703125,
          "content": "# Security Policy\n\n## Supported Versions\n\nOnly the latest released version is supported\n(see https://github.com/eliben/pycparser/tags). Updates will be made in\nthe `master` branch.\n\n## Reporting a Vulnerability\n\nTo report a security issue, please disclose it at [security advisory](https://github.com/eliben/pycparser/security/advisories/new).\n\nWe will respond within 14 working days of your submission. If the issue is confirmed as a vulnerability, we will open a Security Advisory and acknowledge your contributions as part of it. This project follows a 90 day disclosure timeline.\n"
        },
        {
          "name": "TODO.txt",
          "type": "blob",
          "size": 1.4775390625,
          "content": "Todo\n----\n\nVersion Update\n--------------\n\nsetup.py, __init__.py, README, CHANGES\n- Make sure _build_tables was run in pycparser/\n- If PLY version changes, note it in README and ply/LICENSE\n\npython setup.py sdist bdist_wheel\n\nCopy the newly created tarball and untar it; check that the permissions of\nPython files in the pycparser/ directory are OK. Check to see that lextab.py and\nyacctab.py are there.\n\nNow create a new virtualenv and in it install the tarball with\n`pip install <tarballname>`. May need to install `wheel` first if seeing errors\nabout `bdist_wheel`.\n\nSee that pycparser is importable in the Python interpreter of this virtualenv;\nrun pycparser tests from this virtualenv.\n\nAfter this it's OK to rerun `python3.6 -m twine upload dist/*` to push to PyPI\n(older Pythons use a deprecated API for PyPI uploading).\n\n- Tag in git. When pushing to GitHub, git push --tags\n- Create new GitHub release (?)\n\nMisc\n----\n\nyacc optimization:\n- If parsetab.py/pyc doesn't exist in the path, the table will be reconstructed\n  anyway, regardless of the optimize parameter\n- If it does exist:\n  - If optimize=True, the table will be loaded unconditionally\n  - If optimize=False, the table will be loaded only if it's older than the\n    grammar\n\nlex optimization:\n- If optimize=False, the lexical table is re-computed and is not saved to a\n  lextab file\n- If optimize=True:\n  - If lextab.py/pyc exists in the path, it will be loaded unconditionally\n  - If lextab.py/pyc doesn't exist, it will be created and loaded\n"
        },
        {
          "name": "_clean_tables.py",
          "type": "blob",
          "size": 0.8134765625,
          "content": "# Cleanup all tables and PYC files to ensure no PLY stuff is cached\nimport itertools\nimport fnmatch\nimport os, shutil\n\nfile_patterns = ('yacctab.*', 'lextab.*', '*.pyc', '__pycache__')\n\n\ndef do_cleanup(root):\n    for path, dirs, files in os.walk(root):\n        for file in itertools.chain(dirs, files):\n            try:\n                for pattern in file_patterns:\n                    if fnmatch.fnmatch(file, pattern):\n                        fullpath = os.path.join(path, file)\n                        if os.path.isdir(fullpath):\n                            shutil.rmtree(fullpath, ignore_errors=False)\n                        else:\n                            os.unlink(fullpath)\n                        print('Deleted', fullpath)\n            except OSError:\n                pass\n\n\nif __name__ == \"__main__\":\n    do_cleanup('.')\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "pycparser",
          "type": "tree",
          "content": null
        },
        {
          "name": "setup.cfg",
          "type": "blob",
          "size": 0.033203125,
          "content": "[metadata]\nlicense_file = LICENSE\n"
        },
        {
          "name": "setup.py",
          "type": "blob",
          "size": 2.2900390625,
          "content": "import os, sys\ntry:\n    from setuptools import setup\n    from setuptools.command.install import install as _install\n    from setuptools.command.sdist import sdist as _sdist\nexcept ImportError:\n    from distutils.core import setup\n    from distutils.command.install import install as _install\n    from distutils.command.sdist import sdist as _sdist\n\n\ndef _run_build_tables(dir):\n    from subprocess import check_call\n    # This is run inside the install staging directory (that had no .pyc files)\n    # We don't want to generate any.\n    # https://github.com/eliben/pycparser/pull/135\n    check_call([sys.executable, '-B', '_build_tables.py'],\n               cwd=os.path.join(dir, 'pycparser'))\n\n\nclass install(_install):\n    def run(self):\n        _install.run(self)\n        self.execute(_run_build_tables, (self.install_lib,),\n                     msg=\"Build the lexing/parsing tables\")\n\n\nclass sdist(_sdist):\n    def make_release_tree(self, basedir, files):\n        _sdist.make_release_tree(self, basedir, files)\n        self.execute(_run_build_tables, (basedir,),\n                     msg=\"Build the lexing/parsing tables\")\n\n\nsetup(\n    # metadata\n    name='pycparser',\n    description='C parser in Python',\n    long_description=\"\"\"\n        pycparser is a complete parser of the C language, written in\n        pure Python using the PLY parsing library.\n        It parses C code into an AST and can serve as a front-end for\n        C compilers or analysis tools.\n    \"\"\",\n    license='BSD-3-Clause',\n    version='2.22',\n    author='Eli Bendersky',\n    maintainer='Eli Bendersky',\n    author_email='eliben@gmail.com',\n    url='https://github.com/eliben/pycparser',\n    platforms='Cross Platform',\n    classifiers = [\n        'Development Status :: 5 - Production/Stable',\n        'License :: OSI Approved :: BSD License',\n        'Programming Language :: Python :: 3',\n        'Programming Language :: Python :: 3.8',\n        'Programming Language :: Python :: 3.9',\n        'Programming Language :: Python :: 3.10',\n        'Programming Language :: Python :: 3.11',\n        'Programming Language :: Python :: 3.12',\n        'Programming Language :: Python :: 3.13',\n    ],\n    python_requires=\">=3.8\",\n    packages=['pycparser', 'pycparser.ply'],\n    package_data={'pycparser': ['*.cfg']},\n    cmdclass={'install': install, 'sdist': sdist},\n)\n"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "utils",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}