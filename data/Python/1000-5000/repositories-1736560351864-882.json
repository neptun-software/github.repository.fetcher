{
  "metadata": {
    "timestamp": 1736560351864,
    "page": 882,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjg5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "217heidai/adblockfilters",
      "stars": 3328,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 20.0888671875,
          "content": "# AdBlock DNS Filters\n去广告合并规则，每8个小时更新一次。  \n个人收藏了不少广告过滤规则，但是每次往新设备添加的时候很是头疼，于是写了这个项目，定时自动获取各规则源更新，生成合并规则库。\n\n## 说明\n1. 定时从上游各规则源获取更新，合并去重。\n2. 使用国内、国外各 3 组 DNS 服务，分别对上游各规则源拦截的域名进行解析，去除已无法解析的域名。（上游各规则源中存在大量已无法解析的域名，无需加入拦截规则）\n3. 本项目仅对上游规则进行合并、去重、去除无效域名，不做任何修改。如发现误拦截情况，可临时添加放行规则（如 `@@||www.example.com^$important`），并向上游规则反馈。\n\n## 订阅链接\n1. AdGuard Home 等 DNS 拦截服务使用规则1\n2. AdGuard 等浏览器插件使用规则1 + 规则2（规则2为规则1的补充，仅适用浏览器插件）\n3. InviZible Pro、personalDNSfilter 使用规则3（规则3与规则1拦截域名一致，仅格式差异）\n4. DNSMasq 使用规则4（与规则1拦截域名一致，仅格式差异）\n5. SmartDNS 使用规则5（与规则1拦截域名一致，仅格式差异）\n6. Clash 使用规则6（与规则1拦截域名一致，仅格式差异）\n7. QuantumultX 使用规则7（与规则1拦截域名一致，仅格式差异）\n8. 规则x’为规则x的 Lite 版，仅针对国内域名拦截，体积较小（如添加完整规则报错数量限制，请尝试 Lite 规则）\n9. 已对 jsdelivr 缓存进行主动刷新，但 jsdelivr 加速链接仍存在一定延时\n\n| 规则 | 原始链接 | 加速链接1 | 加速链接2 | 加速链接3 | 适配说明 |\n|:-|:-|:-|:-|:-|:-|\n| 规则1 | [原始链接](https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/adblockdns.txt) | [加速链接1](https://gcore.jsdelivr.net/gh/217heidai/adblockfilters@main/rules/adblockdns.txt) | [加速链接2](https://github.boki.moe/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/adblockdns.txt) | [加速链接3](https://mirror.ghproxy.com/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/adblockdns.txt) | AdGuard、AdGuard Home 等 |\n| 规则1' | [原始链接](https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/adblockdnslite.txt) | [加速链接1](https://gcore.jsdelivr.net/gh/217heidai/adblockfilters@main/rules/adblockdnslite.txt) | [加速链接2](https://github.boki.moe/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/adblockdnslite.txt) | [加速链接3](https://mirror.ghproxy.com/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/adblockdnslite.txt) | AdGuard、AdGuard Home 等 |\n| 规则2 | [原始链接](https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/adblockfilters.txt) | [加速链接1](https://gcore.jsdelivr.net/gh/217heidai/adblockfilters@main/rules/adblockfilters.txt) | [加速链接2](https://github.boki.moe/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/adblockfilters.txt) | [加速链接3](https://mirror.ghproxy.com/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/adblockfilters.txt) | AdGuard 等 |\n| 规则2' | [原始链接](https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/adblockfilterslite.txt) | [加速链接1](https://gcore.jsdelivr.net/gh/217heidai/adblockfilters@main/rules/adblockfilterslite.txt) | [加速链接2](https://github.boki.moe/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/adblockfilterslite.txt) | [加速链接3](https://mirror.ghproxy.com/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/adblockfilterslite.txt) | AdGuard 等 |\n| 规则3 | [原始链接](https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/adblockdomain.txt) | [加速链接1](https://gcore.jsdelivr.net/gh/217heidai/adblockfilters@main/rules/adblockdomain.txt) | [加速链接2](https://github.boki.moe/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/adblockdomain.txt) | [加速链接3](https://mirror.ghproxy.com/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/adblockdomain.txt) | InviZible Pro、personalDNSfilter |\n| 规则3' | [原始链接](https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/adblockdomainlite.txt) | [加速链接1](https://gcore.jsdelivr.net/gh/217heidai/adblockfilters@main/rules/adblockdomainlite.txt) | [加速链接2](https://github.boki.moe/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/adblockdomainlite.txt) | [加速链接3](https://mirror.ghproxy.com/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/adblockdomainlite.txt) | InviZible Pro、personalDNSfilter |\n| 规则4 | [原始链接](https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/adblockdnsmasq.txt) | [加速链接1](https://gcore.jsdelivr.net/gh/217heidai/adblockfilters@main/rules/adblockdnsmasq.txt) | [加速链接2](https://github.boki.moe/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/adblockdnsmasq.txt) | [加速链接3](https://mirror.ghproxy.com/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/adblockdnsmasq.txt) | DNSMasq |\n| 规则4' | [原始链接](https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/adblockdnsmasqlite.txt) | [加速链接1](https://gcore.jsdelivr.net/gh/217heidai/adblockfilters@main/rules/adblockdnsmasqlite.txt) | [加速链接2](https://github.boki.moe/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/adblockdnsmasqlite.txt) | [加速链接3](https://mirror.ghproxy.com/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/adblockdnsmasqlite.txt) | DNSMasq |\n| 规则5 | [原始链接](https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/adblocksmartdns.conf) | [加速链接1](https://gcore.jsdelivr.net/gh/217heidai/adblockfilters@main/rules/adblocksmartdns.conf) | [加速链接2](https://github.boki.moe/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/adblocksmartdns.conf) | [加速链接3](https://mirror.ghproxy.com/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/adblocksmartdns.conf) | SmartDNS |\n| 规则5' | [原始链接](https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/adblocksmartdnslite.conf) | [加速链接1](https://gcore.jsdelivr.net/gh/217heidai/adblockfilters@main/rules/adblocksmartdnslite.conf) | [加速链接2](https://github.boki.moe/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/adblocksmartdnslite.conf) | [加速链接3](https://mirror.ghproxy.com/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/adblocksmartdnslite.conf) | SmartDNS |\n| 规则6 | [原始链接](https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/adblockclash.list) | [加速链接1](https://gcore.jsdelivr.net/gh/217heidai/adblockfilters@main/rules/adblockclash.list) | [加速链接2](https://github.boki.moe/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/adblockclash.list) | [加速链接3](https://mirror.ghproxy.com/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/adblockclash.list) | Clash |\n| 规则6' | [原始链接](https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/adblockclashlite.list) | [加速链接1](https://gcore.jsdelivr.net/gh/217heidai/adblockfilters@main/rules/adblockclashlite.list) | [加速链接2](https://github.boki.moe/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/adblockclashlite.list) | [加速链接3](https://mirror.ghproxy.com/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/adblockclashlite.list) | Clash |\n| 规则7 | [原始链接](https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/adblockqx.conf) | [加速链接1](https://gcore.jsdelivr.net/gh/217heidai/adblockfilters@main/rules/adblockqx.conf) | [加速链接2](https://github.boki.moe/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/adblockqx.conf) | [加速链接3](https://mirror.ghproxy.com/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/adblockqx.conf) | QuantumultX |\n| 规则7' | [原始链接](https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/adblockqxlite.conf) | [加速链接1](https://gcore.jsdelivr.net/gh/217heidai/adblockfilters@main/rules/adblockqxlite.conf) | [加速链接2](https://github.boki.moe/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/adblockqxlite.conf) | [加速链接3](https://mirror.ghproxy.com/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/adblockqxlite.conf) | QuantumultX |\n\n## 上游规则源\n1. 感谢各位广告过滤规则维护大佬们的辛苦付出。\n2. 不再引用[anti-AD](https://anti-ad.net/adguard.txt)、[yhosts](https://raw.githubusercontent.com/VeleSila/yhosts/master/hosts.txt)，具体原因见[Mosney/anti-anti-AD](https://github.com/Mosney/anti-anti-AD)。\n3. 移除[Notracking blocklist](https://raw.githubusercontent.com/notracking/hosts-blocklists/master/adblock/adblock.txt)，原项目[已停止维护](https://github.com/notracking/hosts-blocklists/issues/900)。\n4. 移除[ADgk](https://raw.githubusercontent.com/banbendalao/ADgk/master/ADgk.txt)，项目超过 1 年未更新。\n5. 不再引用[NEO DEV HOST](https://github.com/neodevpro/neodevhost/blob/master/lite_adblocker)，原因见[Issues 85](https://github.com/217heidai/adblockfilters/issues/85)。\n\n| 规则 | 类型 | 原始链接 | 加速链接1 | 加速链接2 | 加速链接3 | 更新日期 |\n|:-|:-|:-|:-|:-|:-|:-|\n| AdGuard Base filter | filter | [原始链接](https://raw.githubusercontent.com/AdguardTeam/FiltersRegistry/master/filters/filter_2_Base/filter.txt) | [加速链接1](https://gcore.jsdelivr.net/gh/217heidai/adblockfilters@main/rules/AdGuard_Base_filter.txt) | [加速链接2](https://github.boki.moe/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/AdGuard_Base_filter.txt) | [加速链接3](https://mirror.ghproxy.com/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/AdGuard_Base_filter.txt) | 2025/01/11 |\n| AdGuard Chinese filter | filter | [原始链接](https://raw.githubusercontent.com/AdguardTeam/FiltersRegistry/master/filters/filter_224_Chinese/filter.txt) | [加速链接1](https://gcore.jsdelivr.net/gh/217heidai/adblockfilters@main/rules/AdGuard_Chinese_filter.txt) | [加速链接2](https://github.boki.moe/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/AdGuard_Chinese_filter.txt) | [加速链接3](https://mirror.ghproxy.com/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/AdGuard_Chinese_filter.txt) | 2025/01/11 |\n| AdGuard Mobile Ads filter | filter | [原始链接](https://raw.githubusercontent.com/AdguardTeam/AdguardFilters/master/MobileFilter/sections/adservers.txt) | [加速链接1](https://gcore.jsdelivr.net/gh/217heidai/adblockfilters@main/rules/AdGuard_Mobile_Ads_filter.txt) | [加速链接2](https://github.boki.moe/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/AdGuard_Mobile_Ads_filter.txt) | [加速链接3](https://mirror.ghproxy.com/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/AdGuard_Mobile_Ads_filter.txt) | 2025/01/04 |\n| AdGuard DNS filter | filter | [原始链接](https://adguardteam.github.io/AdGuardSDNSFilter/Filters/filter.txt) | [加速链接1](https://gcore.jsdelivr.net/gh/217heidai/adblockfilters@main/rules/AdGuard_DNS_filter.txt) | [加速链接2](https://github.boki.moe/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/AdGuard_DNS_filter.txt) | [加速链接3](https://mirror.ghproxy.com/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/AdGuard_DNS_filter.txt) | 2025/01/11 |\n| AdRules DNS List | filter | [原始链接](https://raw.githubusercontent.com/Cats-Team/AdRules/main/dns.txt) | [加速链接1](https://gcore.jsdelivr.net/gh/217heidai/adblockfilters@main/rules/AdRules_DNS_List.txt) | [加速链接2](https://github.boki.moe/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/AdRules_DNS_List.txt) | [加速链接3](https://mirror.ghproxy.com/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/AdRules_DNS_List.txt) | 2025/01/11 |\n| CJX's Annoyance List | filter | [原始链接](https://raw.githubusercontent.com/cjx82630/cjxlist/master/cjx-annoyance.txt) | [加速链接1](https://gcore.jsdelivr.net/gh/217heidai/adblockfilters@main/rules/CJX's_Annoyance_List.txt) | [加速链接2](https://github.boki.moe/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/CJX's_Annoyance_List.txt) | [加速链接3](https://mirror.ghproxy.com/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/CJX's_Annoyance_List.txt) | 2024/12/22 |\n| EasyList | filter | [原始链接](https://easylist-downloads.adblockplus.org/easylist.txt) | [加速链接1](https://gcore.jsdelivr.net/gh/217heidai/adblockfilters@main/rules/EasyList.txt) | [加速链接2](https://github.boki.moe/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/EasyList.txt) | [加速链接3](https://mirror.ghproxy.com/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/EasyList.txt) | 2025/01/11 |\n| EasyList China | filter | [原始链接](https://easylist-downloads.adblockplus.org/easylistchina.txt) | [加速链接1](https://gcore.jsdelivr.net/gh/217heidai/adblockfilters@main/rules/EasyList_China.txt) | [加速链接2](https://github.boki.moe/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/EasyList_China.txt) | [加速链接3](https://mirror.ghproxy.com/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/EasyList_China.txt) | 2025/01/11 |\n| EasyPrivacy | filter | [原始链接](https://easylist-downloads.adblockplus.org/easyprivacy.txt) | [加速链接1](https://gcore.jsdelivr.net/gh/217heidai/adblockfilters@main/rules/EasyPrivacy.txt) | [加速链接2](https://github.boki.moe/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/EasyPrivacy.txt) | [加速链接3](https://mirror.ghproxy.com/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/EasyPrivacy.txt) | 2025/01/11 |\n| xinggsf mv | filter | [原始链接](https://raw.githubusercontent.com/xinggsf/Adblock-Plus-Rule/master/mv.txt) | [加速链接1](https://gcore.jsdelivr.net/gh/217heidai/adblockfilters@main/rules/xinggsf_mv.txt) | [加速链接2](https://github.boki.moe/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/xinggsf_mv.txt) | [加速链接3](https://mirror.ghproxy.com/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/xinggsf_mv.txt) | 2025/01/05 |\n| xinggsf rule | filter | [原始链接](https://raw.githubusercontent.com/xinggsf/Adblock-Plus-Rule/master/rule.txt) | [加速链接1](https://gcore.jsdelivr.net/gh/217heidai/adblockfilters@main/rules/xinggsf_rule.txt) | [加速链接2](https://github.boki.moe/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/xinggsf_rule.txt) | [加速链接3](https://mirror.ghproxy.com/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/xinggsf_rule.txt) | 2024/11/17 |\n| jiekouAD | filter | [原始链接](https://raw.githubusercontent.com/damengzhu/banad/main/jiekouAD.txt) | [加速链接1](https://gcore.jsdelivr.net/gh/217heidai/adblockfilters@main/rules/jiekouAD.txt) | [加速链接2](https://github.boki.moe/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/jiekouAD.txt) | [加速链接3](https://mirror.ghproxy.com/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/jiekouAD.txt) | 2025/01/10 |\n| 1Hosts (Lite) | dns | [原始链接](https://raw.githubusercontent.com/badmojr/1Hosts/master/Lite/adblock.txt) | [加速链接1](https://gcore.jsdelivr.net/gh/217heidai/adblockfilters@main/rules/1Hosts_(Lite).txt) | [加速链接2](https://github.boki.moe/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/1Hosts_(Lite).txt) | [加速链接3](https://mirror.ghproxy.com/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/1Hosts_(Lite).txt) | 2025/01/06 |\n| AWAvenue Ads Rule | dns | [原始链接](https://raw.githubusercontent.com/TG-Twilight/AWAvenue-Ads-Rule/main/AWAvenue-Ads-Rule.txt) | [加速链接1](https://gcore.jsdelivr.net/gh/217heidai/adblockfilters@main/rules/AWAvenue_Ads_Rule.txt) | [加速链接2](https://github.boki.moe/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/AWAvenue_Ads_Rule.txt) | [加速链接3](https://mirror.ghproxy.com/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/AWAvenue_Ads_Rule.txt) | 2025/01/11 |\n| DNS-Blocklists Light | dns | [原始链接](https://raw.githubusercontent.com/hagezi/dns-blocklists/main/adblock/light.txt) | [加速链接1](https://gcore.jsdelivr.net/gh/217heidai/adblockfilters@main/rules/DNS-Blocklists_Light.txt) | [加速链接2](https://github.boki.moe/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/DNS-Blocklists_Light.txt) | [加速链接3](https://mirror.ghproxy.com/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/DNS-Blocklists_Light.txt) | 2025/01/11 |\n| Hblock | dns | [原始链接](https://hblock.molinero.dev/hosts_adblock.txt) | [加速链接1](https://gcore.jsdelivr.net/gh/217heidai/adblockfilters@main/rules/Hblock.txt) | [加速链接2](https://github.boki.moe/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/Hblock.txt) | [加速链接3](https://mirror.ghproxy.com/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/Hblock.txt) | 2025/01/10 |\n| OISD Basic | dns | [原始链接](https://abp.oisd.nl/basic/) | [加速链接1](https://gcore.jsdelivr.net/gh/217heidai/adblockfilters@main/rules/OISD_Basic.txt) | [加速链接2](https://github.boki.moe/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/OISD_Basic.txt) | [加速链接3](https://mirror.ghproxy.com/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/OISD_Basic.txt) | 2025/01/11 |\n| SmartTV Blocklist | dns | [原始链接](https://raw.githubusercontent.com/Perflyst/PiHoleBlocklist/master/SmartTV-AGH.txt) | [加速链接1](https://gcore.jsdelivr.net/gh/217heidai/adblockfilters@main/rules/SmartTV_Blocklist.txt) | [加速链接2](https://github.boki.moe/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/SmartTV_Blocklist.txt) | [加速链接3](https://mirror.ghproxy.com/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/SmartTV_Blocklist.txt) | 2023/10/11 |\n| 1024 hosts | host | [原始链接](https://raw.githubusercontent.com/Goooler/1024_hosts/master/hosts) | [加速链接1](https://gcore.jsdelivr.net/gh/217heidai/adblockfilters@main/rules/1024_hosts.txt) | [加速链接2](https://github.boki.moe/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/1024_hosts.txt) | [加速链接3](https://mirror.ghproxy.com/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/1024_hosts.txt) | 2023/08/31 |\n| ad-wars hosts | host | [原始链接](https://raw.githubusercontent.com/jdlingyu/ad-wars/master/hosts) | [加速链接1](https://gcore.jsdelivr.net/gh/217heidai/adblockfilters@main/rules/ad-wars_hosts.txt) | [加速链接2](https://github.boki.moe/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/ad-wars_hosts.txt) | [加速链接3](https://mirror.ghproxy.com/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/ad-wars_hosts.txt) | 2023/11/17 |\n| StevenBlack hosts | host | [原始链接](https://raw.githubusercontent.com/StevenBlack/hosts/master/hosts) | [加速链接1](https://gcore.jsdelivr.net/gh/217heidai/adblockfilters@main/rules/StevenBlack_hosts.txt) | [加速链接2](https://github.boki.moe/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/StevenBlack_hosts.txt) | [加速链接3](https://mirror.ghproxy.com/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/StevenBlack_hosts.txt) | 2025/01/10 |\n\n## Star History\n[![Star History Chart](https://api.star-history.com/svg?repos=217heidai/adblockfilters&type=Date)](https://star-history.com/#217heidai/adblockfilters&Date)\n"
        },
        {
          "name": "adblock.py",
          "type": "blob",
          "size": 1.3486328125,
          "content": "import os\n\nfrom loguru import logger\n\nfrom readme import ReadMe\nfrom updater import Updater\nfrom filter import Filter\n\nclass ADBlock(object):\n    def __init__(self):\n        self.pwd = os.getcwd()\n\n    def refresh(self):\n        readme = ReadMe(self.pwd + '/README.md')\n        ruleList = readme.getRules()\n        '''\n        # for test\n        testList = []\n        for rule in ruleList:\n            if rule.type in ['filter']:\n                testList.append(rule)\n        #    if rule.name in [\"AdGuard Mobile Ads filter\"]: # \"AdRules DNS List\", \"CJX's Annoyance List\", \"EasyList China\", \"EasyList\", \"EasyPrivacy\", \"jiekouAD\", \"xinggsf mv\", \"xinggsf rule\"\n        #        testList.append(rule)\n        ruleList = testList\n        '''\n        # 更新上游规\n        updater = Updater(ruleList)\n        update, ruleList = updater.update(self.pwd + '/rules')\n        if not update:\n            return\n        \n        # 生成新规则\n        filter = Filter(ruleList, self.pwd + '/rules')\n        filter.generate(readme.getRulesNames())\n        \n        # 生成 readme.md\n        readme.setRules(ruleList)\n        readme.regenerate()\n        \n\nif __name__ == '__main__':\n    '''\n    # for test\n    logFile = os.getcwd() + \"/adblock.log\"\n    if os.path.exists(logFile):\n        os.remove(logFile)\n    logger.add(logFile)\n    '''\n    adBlock = ADBlock()\n    adBlock.refresh()"
        },
        {
          "name": "app",
          "type": "tree",
          "content": null
        },
        {
          "name": "blacklist.py",
          "type": "blob",
          "size": 15.330078125,
          "content": "import os\nimport asyncio\nimport re\nfrom concurrent.futures import ThreadPoolExecutor,as_completed\n\nimport httpx\nimport IPy\nfrom tld import get_tld\nfrom loguru import logger\nfrom dns.asyncresolver import Resolver as DNSResolver\nfrom dns.rdatatype import RdataType as DNSRdataType\n\n\nclass ChinaDomian(object):\n    def __init__(self, fileName, url):\n        self.__fileName = fileName\n        self.__url = url\n        self.fullSet = set()\n        self.domainSet = set()\n        self.regexpSet = set()\n        self.keywordSet = set()\n        self.__update()\n        self.__resolve()\n\n    def __update(self):\n        try:\n            if os.path.exists(self.__fileName):\n                os.remove(self.__fileName)\n            \n            with httpx.Client() as client:\n                response = client.get(self.__url)\n                response.raise_for_status()\n                with open(self.__fileName,'wb') as f:\n                    f.write(response.content)\n        except Exception as e:\n            logger.error(\"%s\"%(e))\n    \n    def __isDomain(self, address):\n        fld, subdomain = '', ''\n        try:\n            res = get_tld(address, fix_protocol=True, as_object=True) # 确认是否为域名\n            fld, subdomain = res.fld, res.subdomain\n        except Exception as e:\n            logger.error(\"%s: not domain\"%(address))\n        finally:\n            return fld, subdomain\n\n    def __resolve(self):\n        try:\n            if not os.path.exists(self.__fileName):\n                return\n            \n            with open(self.__fileName, 'r') as f:\n                for line in f:\n                    # 去掉换行符\n                    line = line.replace('\\r', '').replace('\\n', '').strip()\n                    # 去掉空行\n                    if len(line) < 1:\n                        continue\n                    # 去掉注释\n                    if line.startswith('#'):\n                        continue\n                    if line.find('#') > 0:\n                        line = line[:line.find('#')].strip()\n                    \n                    # regexp\n                    if line.startswith('regexp:'):\n                        self.regexpSet.add(line[len('regexp:'):])\n                        continue\n                    \n                    # keyword\n                    if line.startswith('keyword:'):\n                        self.keywordSet.add(line[len('keyword:'):])\n                        continue\n                    \n                    if line.startswith('full:'):\n                        domain = line[len('full:'):]\n                    elif line.startswith('domain:'):\n                        domain = line[len('domain:'):]\n                    else:\n                        domain = line\n                    fld, subdomian = self.__isDomain(domain)\n                    if len(fld) > 0:\n                        if len(subdomian) > 0:\n                            self.fullSet.add(domain)\n                        else:\n                            self.domainSet.add(domain)\n                    else:\n                        logger.error(\"%s: not domain[domain]\"%(line))\n        except Exception as e:\n            logger.error(\"%s\"%(e))\n\n\nclass BlackList(object):\n    def __init__(self):\n        self.__ChinalistFile = os.getcwd() + \"/rules/china.txt\"\n        self.__blacklistFile = os.getcwd() + \"/rules/black.txt\"\n        self.__domainlistFile = os.getcwd() + \"/rules/domain.txt\"\n        self.__domainlistFile_CN = os.getcwd() + \"/rules/direct-list.txt\"\n        self.__domainlistUrl_CN = \"https://raw.githubusercontent.com/Loyalsoldier/v2ray-rules-dat/refs/heads/release/direct-list.txt\"\n        self.__domainlistFile_CN_Apple = os.getcwd() + \"/rules/apple-cn.txt\"\n        self.__domainlistUrl_CN_Apple = \"https://raw.githubusercontent.com/Loyalsoldier/v2ray-rules-dat/refs/heads/release/apple-cn.txt\"\n        self.__domainlistFile_CN_Google = os.getcwd() + \"/rules/google-cn.txt\"\n        self.__domainlistUrl_CN_Google = \"https://raw.githubusercontent.com/Loyalsoldier/v2ray-rules-dat/refs/heads/release/google-cn.txt\"\n        self.__iplistFile_CN = os.getcwd() + \"/rules/CN-ip-cidr.txt\"\n        self.__iplistUrl_CN = \"https://raw.githubusercontent.com/Hackl0us/GeoIP2-CN/refs/heads/release/CN-ip-cidr.txt\"\n        self.__maxTask = 500\n\n    def __getDomainList(self):\n        logger.info(\"resolve adblock dns backup...\")\n        domainList = []\n        try:\n            if os.path.exists(self.__domainlistFile):\n                with open(self.__domainlistFile, 'r') as f:\n                    tmp = f.readlines()\n                    domainList = list(map(lambda x: x.replace(\"\\n\", \"\"), tmp))\n        except Exception as e:\n            logger.error(\"%s\"%(e))\n        finally:\n            logger.info(\"adblock dns backup: %d\"%(len(domainList)))\n            return domainList\n        \n    def __getDomainSet_CN(self):\n        logger.info(\"resolve China domain list...\")\n        fullSet,domainSet,regexpSet,keywordSet = set(),set(),set(),set()\n        try:\n            domain_cn = ChinaDomian(self.__domainlistFile_CN, self.__domainlistUrl_CN)\n            domain_apple = ChinaDomian(self.__domainlistFile_CN_Apple, self.__domainlistUrl_CN_Apple)\n            domain_google = ChinaDomian(self.__domainlistFile_CN_Google, self.__domainlistUrl_CN_Google)\n\n            fullSet = domain_cn.fullSet | domain_apple.fullSet | domain_google.fullSet\n            domainSet = domain_cn.domainSet | domain_apple.domainSet | domain_google.domainSet\n            regexpSet = domain_cn.regexpSet | domain_apple.regexpSet | domain_google.regexpSet\n            keywordSet = domain_cn.keywordSet | domain_apple.keywordSet | domain_google.keywordSet\n        except Exception as e:\n            logger.error(\"%s\"%(e))\n        finally:\n            logger.info(\"China domain list: full[%d], domain[%d], regexp[%d], keyword[%d]\"%(len(fullSet),len(domainSet),len(regexpSet),len(keywordSet)))\n            return fullSet,domainSet,regexpSet,keywordSet\n        \n    def __getIPDict_CN(self):\n        logger.info(\"resolve China IP list...\")\n        IPDict = dict()\n        try:\n            if os.path.exists(self.__iplistFile_CN):\n                os.remove(self.__iplistFile_CN)\n            \n            with httpx.Client() as client:\n                response = client.get(self.__iplistUrl_CN)\n                response.raise_for_status()\n                with open(self.__iplistFile_CN,'wb') as f:\n                    f.write(response.content)\n            \n            if os.path.exists(self.__iplistFile_CN):\n                with open(self.__iplistFile_CN, 'r') as f:\n                    for line in f.readlines():\n                        row = line.replace(\"\\n\", \"\").split(\"/\")\n                        ip, offset = row[0], int(row[1])\n                        IPDict[IPy.parseAddress(ip)[0]] = offset\n        except Exception as e:\n            logger.error(\"%s\"%(e))\n        finally:\n            logger.info(\"China IP list: %d\"%(len(IPDict)))\n            return IPDict\n    \n    async def __resolve(self, dnsresolver, domain):\n        ipList = []\n        try:\n            query_object = await dnsresolver.resolve(qname=domain, rdtype=\"A\")\n            query_item = None\n            for item in query_object.response.answer:\n                if item.rdtype == DNSRdataType.A:\n                    query_item = item\n                    break\n            if query_item is None:\n                raise Exception(\"not A type\")\n            for item in query_item:\n                ip = '{}'.format(item)\n                if ip != \"0.0.0.0\":\n                    ipList.append(ip)\n        except Exception as e:\n            logger.error('\"%s\": %s' % (domain, e if e else \"Resolver failed\"))\n        finally:\n            return ipList\n\n    async def __pingx(self, dnsresolver, domain, semaphore):\n        async with semaphore: # 限制并发数，超过系统限制后会报错Too many open files\n            host = domain\n            port = None\n            ipList = []\n            if domain.rfind(\":\") > 0: # 兼容 host:port格式\n                offset = domain.rfind(\":\")\n                host = domain[ : offset]\n                port = int(domain[offset + 1 : ])\n            try:\n                get_tld(host, fix_protocol=True, as_object=True) # 确认是否为域名\n            except Exception as e:\n                port = 80\n            if port:\n                try:\n                    _, writer = await asyncio.open_connection(host, port)\n                    writer.close()\n                    await writer.wait_closed()\n                    ipList.append(host)\n                except Exception as e:\n                    if port == 80:\n                        port = 443\n                        try:\n                            _, writer = await asyncio.open_connection(host, port)\n                            writer.close()\n                            await writer.wait_closed()\n                            ipList.append(host)\n                        except Exception as e:\n                            logger.error('\"%s\": %s' % (domain, e if e else \"Connect failed\"))\n            else:\n                count = 3\n                while len(ipList) < 1 and count > 0:\n                    ipList = await self.__resolve(dnsresolver, host)\n                    count -= 1\n\n            logger.info(\"%s: %s\" % (domain, ipList))\n            return domain, ipList\n\n    def __generateBlackList(self, blackList):\n        logger.info(\"generate black list...\")\n        try:\n            if os.path.exists(self.__blacklistFile):\n                os.remove(self.__blacklistFile)\n            \n            with open(self.__blacklistFile, \"w\") as f:\n                for domain in blackList:\n                    f.write(\"%s\\n\"%(domain))\n            logger.info(\"block domain: %d\"%(len(blackList)))\n        except Exception as e:\n            logger.error(\"%s\"%(e))\n    \n    def __generateChinaList(self, ChinaList):\n        logger.info(\"generate China list...\")\n        try:\n            if os.path.exists(self.__ChinalistFile):\n                os.remove(self.__ChinalistFile)\n            \n            with open(self.__ChinalistFile, \"w\") as f:\n                for domain in ChinaList:\n                    f.write(\"%s\\n\"%(domain))\n            logger.info(\"China domain: %d\"%(len(ChinaList)))\n        except Exception as e:\n            logger.error(\"%s\"%(e))\n\n    def __testDomain(self, domainList, nameservers, port=53):\n        logger.info(\"resolve domain...\")\n        # 异步检测\n        dnsresolver = DNSResolver()\n        dnsresolver.nameservers = nameservers\n        dnsresolver.port = port\n        # 启动异步循环\n        loop = asyncio.get_event_loop()\n        semaphore = asyncio.Semaphore(self.__maxTask) # 限制并发量为500\n        # 添加异步任务\n        taskList = []\n        for domain in domainList:\n            task = asyncio.ensure_future(self.__pingx(dnsresolver, domain, semaphore))\n            taskList.append(task)\n        # 等待异步任务结束\n        loop.run_until_complete(asyncio.wait(taskList))\n        # 获取异步任务结果\n        domainDict = {}\n        for task in taskList:\n            domain, ipList = task.result()\n            domainDict[domain] = ipList\n\n        logger.info(\"resolve domain: %d\"%(len(domainDict)))\n        return domainDict\n\n    def __isChinaDomain(self, domain, ipList, fullSet_CN, domainSet_CN, regexpSet_CN, keywordSet_CN, IPDict_CN):\n        isChinaDomain = False\n        try:\n            if domain.find(':') > 0:\n                domain = domain[ : domain.find(':')]\n            \n            while True:\n                try:\n                    res = get_tld(domain, fix_protocol=True, as_object=True)\n                    if domain[-3:] == \".cn\":\n                        isChinaDomain = True\n                        break\n                    # full:\n                    if domain in fullSet_CN:\n                        isChinaDomain = True\n                        break\n                    # doamin:\n                    if res.fld in domainSet_CN:\n                        isChinaDomain = True\n                        break\n                    # regexp:\n                    for regexp in regexpSet_CN:\n                        if re.match(regexp, domain):\n                            isChinaDomain = True\n                            break\n                    if isChinaDomain:\n                        break\n                    # keyword:\n                    for keyword in keywordSet_CN:\n                        if re.match(\".*%s.*\"%(keyword), domain):\n                            isChinaDomain = True\n                            break\n                    if isChinaDomain:\n                        break\n                    # IP\n                    raise Exception(\"try to resolve ip\")\n                except Exception as e:\n                    # IP\n                    for ip in ipList:\n                        ip = IPy.parseAddress(ip)[0]\n                        for k, v in IPDict_CN.items():\n                            if (ip ^ k) >> (32 - v)  == 0:\n                                isChinaDomain = True\n                                break\n                        if isChinaDomain:\n                            break\n                break\n        except Exception as e: \n            logger.error('\"%s\": not domain'%(domain))\n        finally:\n            return domain,isChinaDomain\n\n    def generate(self):\n        try:\n            domainList = self.__getDomainList()\n            if len(domainList) < 1:\n                return\n            #domainList = domainList[:1000] # for test\n            \n            domainDict = self.__testDomain(domainList, [\"127.0.0.1\"], 5053) # 使用本地 smartdns 进行域名解析，配置3组国内、3组国际域名解析服务器，提高识别效率\n            #domainDict = self.__testDomain(domainList, [\"1.12.12.12\"], 53) # for test\n\n            fullSet_CN,domainSet_CN,regexpSet_CN,keywordSet_CN = self.__getDomainSet_CN()\n            IPDict_CN = self.__getIPDict_CN()\n            blackList = []\n            if len(domainSet_CN) > 100 and len(IPDict_CN) > 100:\n                thread_pool = ThreadPoolExecutor(max_workers=os.cpu_count() if os.cpu_count() > 4 else 4)\n                taskList = []\n                for domain in domainList:\n                    if len(domainDict[domain]):\n                        taskList.append(thread_pool.submit(self.__isChinaDomain, domain, domainDict[domain], fullSet_CN, domainSet_CN, regexpSet_CN, keywordSet_CN, IPDict_CN))\n                    else:\n                        blackList.append(domain)\n                # 获取解析结果\n                ChinaSet_tmp = set()\n                for future in as_completed(taskList):\n                    domain,isChinaDomain = future.result()\n                    if isChinaDomain:\n                        ChinaSet_tmp.add(domain)\n                # 生成China域名列表\n                ChinaList = []\n                for domain in domainList:\n                    if domain in ChinaSet_tmp:\n                        ChinaList.append(domain)\n                if len(ChinaList):\n                    self.__generateChinaList(ChinaList)\n            else:\n                for domain in domainList:\n                    if domainDict[domain] is None:\n                        blackList.append(domain)\n\n            # 生成黑名单\n            if len(blackList):\n                self.__generateBlackList(blackList)\n        except Exception as e:\n            logger.error(\"%s\"%(e))\n\nif __name__ == \"__main__\":\n    '''\n    # for test\n    logFile = os.getcwd() + \"/adblock.log\"\n    if os.path.exists(logFile):\n        os.remove(logFile)\n    logger.add(logFile)\n    '''\n    blackList = BlackList()\n    blackList.generate()"
        },
        {
          "name": "filter.py",
          "type": "blob",
          "size": 10.2451171875,
          "content": "import os\nimport re\nfrom concurrent.futures import ThreadPoolExecutor,as_completed\nfrom typing import List,Dict,Set,Tuple\n\nfrom loguru import logger\nfrom tld import get_tld\n\nfrom app import AdGuard, AdGuardHome, Clash, DNSMasq, InviZible, QuantumultX, SmartDNS\nfrom readme import Rule\nfrom resolver import Resolver\n\nclass Filter(object):\n    def __init__(self, ruleList:List[Rule], path:str):\n        self.ruleList = ruleList\n        self.path = path\n    \n    # 获取拦截规则\n    def __getFilters(self) -> Tuple[Dict[str, Set[str]], Dict[str, Set[str]], Dict[str, str]]:\n        def dictadd(d1:Dict[str,Set], d2:Dict[str,Set]) -> Dict[str,Set]:\n            d3 = dict()\n            s = set.union(set(d1), set(d2))\n            for item in s:\n                d3[item] = set.union(d1.get(item, set()), d2.get(item, set()))\n            return d3\n\n        thread_pool = ThreadPoolExecutor(max_workers=os.cpu_count() if os.cpu_count() > 4 else 4)\n        resolver = Resolver(self.path)\n        # 线程池解析\n        taskList = []\n        for rule in self.ruleList:\n            logger.info(\"resolve %s...\"%(rule.name))\n            if rule.type == \"host\":\n                taskList.append(thread_pool.submit(resolver.resolveHost, rule))\n            if rule.type == \"dns\":\n                taskList.append(thread_pool.submit(resolver.resolveDNS, rule))\n            if rule.type == \"filter\":\n                taskList.append(thread_pool.submit(resolver.resolveFilter, rule))\n        # 添加收集的补充规则\n        rule = Rule(\"myblock\", \"dns\", \"\", \"\")\n        taskList.append(thread_pool.submit(resolver.resolveDNS, rule))\n        \n        # 获取解析结果\n        blockDict:Dict[str,Set[str]] = dict()\n        unblockDict:Dict[str,Set[str]] = dict()\n        filterDict:Dict[str,str] = dict()\n        for future in as_completed(taskList):\n            __blockDict,__unblockDict,__filterDict = future.result()\n            blockDict = dictadd(blockDict, __blockDict)\n            unblockDict = dictadd(unblockDict, __unblockDict)\n            for filter,domain in __filterDict.items():\n                filterDict[filter] = domain\n\n        return blockDict,unblockDict,filterDict\n    \n    # 获取黑名单\n    def __getBlackList(self, fileName:str) -> Set[str]:\n        logger.info(\"resolve black list...\")\n        blackSet = set()\n        if os.path.exists(fileName):\n            with open(fileName, 'r') as f:\n                blackList = f.readlines()\n                blackSet = set(map(lambda x: x.replace(\"\\n\", \"\"), blackList))\n        logger.info(\"black list: %d\"%(len(blackSet)))\n        return blackSet\n\n    # 获取白名单\n    def __getWhiteList(self, fileName:str) -> Set[str]:\n        logger.info(\"resolve white list...\")\n        whiteSet = set()\n        if os.path.exists(fileName):\n            with open(fileName, 'r') as f:\n                for line in f.readlines():\n                    if not line.startswith(\"#\") and len(line.replace(\"\\n\", \"\")) > 4:\n                        whiteSet.add(line.replace(\"\\n\", \"\"))\n        logger.info(\"white list: %d\"%(len(whiteSet)))\n        return whiteSet\n    \n    # 获取 China domain 清单\n    def __getChinaList(self, fileName:str) -> Set[str]:\n        logger.info(\"resolve China list...\")\n        ChinaSet = set()\n        if os.path.exists(fileName):\n            with open(fileName, 'r') as f:\n                ChinaList = f.readlines()\n                ChinaSet = set(map(lambda x: x.replace(\"\\n\", \"\"), ChinaList))\n        logger.info(\"China list: %d\"%(len(ChinaSet)))\n        return ChinaSet\n\n    # 去重、排序\n    def __domainSort(self, domainDict:Dict[str, Set[str]], blackSet:Set[str], whiteSet:Set[str]) -> Tuple[List[str], Set[str]]:\n        def repetition(l): # 短域名已被拦截，则干掉所有长域名。如'a.example'、'b.example'、'example'，则只保留'example'\n            l = sorted(l, key = lambda item:len(item), reverse=False) # 按从短到长排序\n            if l[0] == '':\n                return l[:1]\n            if len(l) < 2:\n                return l\n            tmp = set()\n            for i in range(len(l) - 1):\n                for j in range(i+1, len(l)):\n                    if re.match('.*\\.%s$'%(l[i]), l[j]):\n                        tmp.add(l[j])\n            l = list(set(l)-tmp)\n            l.sort()\n            return l\n        def get_domain(fld, subdomain):\n            if len(subdomain) > 0:\n                domain = (\"%s.%s\")%(subdomain, fld)\n            else:\n                domain = (\"%s\")%(fld)\n            return domain\n\n        domanList = []\n        domanSet_all = set()\n        fldList = list(domainDict.keys())\n        fldList.sort() # 排序\n        for fld in fldList:\n            subdomainList_origin = list(domainDict[fld])\n            subdomainList = repetition(subdomainList_origin) # 短域名已被拦截，则干掉所有长域名。如'a.example'、'b.example'、'example'，则只保留'example'\n            for subdomain in subdomainList:\n                subdomain_not_black = False\n                for _subdomain in list(set(subdomainList_origin) - set(subdomainList)):\n                    if len(subdomain) > 0:\n                        if re.match('.*\\.%s$'%(subdomain), _subdomain):\n                            _domain = get_domain(fld, _subdomain)\n                            if _domain not in blackSet:\n                                subdomain_not_black = True\n                                break\n                    else:\n                        _domain = get_domain(fld, _subdomain)\n                        if _domain not in blackSet:\n                            subdomain_not_black = True\n                            break\n                \n                domain = get_domain(fld, subdomain)\n                if domain not in whiteSet:\n                    if domain not in blackSet:\n                        domanList.append(domain)\n                    else:\n                        if subdomain_not_black: # 只要子域名有一个未black，仍然保留\n                            domanList.append(domain)\n\n            # 全域名保留，用于后续验证连通性\n            for subdomain in subdomainList_origin: \n                domain = get_domain(fld, subdomain)\n                domanSet_all.add(domain)\n            \n        return domanList,domanSet_all\n\n    def __filterSort(self, filterDict:Dict[str,str], blockSet:Set[str], unblockSet:Set[str], blackSet:Set[str], whiteSet:Set[str]) -> Tuple[list[str], Set[str]]:\n        filterList = list(set(filterDict) - whiteSet) # 剔除白名单\n        filterList.sort() # 排序\n        # 与 adblockdns 去重\n        filterList_var = []\n        filterList_final = []\n        domainSet_all = set()\n        for filter in filterList:\n            if filter.startswith('#%#var'):\n                filterList_var.append(filter)\n                continue\n            \n            domain = filterDict[filter]\n            if domain:\n                if domain in blackSet: # 剔除黑名单\n                    continue\n                try:\n                    res = get_tld(domain, fix_protocol=True, as_object=True)\n                    fld = res.fld\n                except Exception as e:\n                    fld = ''\n                if filter.startswith('@@'):\n                    if domain in unblockSet or fld in unblockSet: # 剔除 adblockdns 已放行\n                        continue\n                else:\n                    if domain in blockSet or fld in blockSet: # 剔除 adblockdns 已拦截\n                        continue\n                domainSet_all.add(domain)\n            \n            filterList_final.append(filter)\n        \n        return filterList_var, filterList_final, domainSet_all\n\n    # 生成用于域名连通性检测的全域名清单\n    def __generateDomainBackup(self, domainSet, fileName:str):\n        logger.info(\"generate domain backup...\")\n        if os.path.exists(fileName):\n            os.remove(fileName)\n\n        domainList = list(domainSet)\n        domainList.sort() # 排序\n\n        with open(fileName, 'a') as f:\n            for domain in domainList:\n                f.write(\"%s\\n\"%(domain))\n        \n        logger.info(\"domain backup: %d\"%(len(domainList)))\n\n    def generate(self, sourceRule):\n        # 提取规则\n        blockDict,unblockDict,filterDict = self.__getFilters()\n        # 提取黑名单、白名单、China domain\n        blackSet = self.__getBlackList(self.path + \"/black.txt\")\n        whiteSet = self.__getWhiteList(self.path + \"/white.txt\")\n        ChinaSet = self.__getChinaList(self.path + \"/china.txt\")\n        # 规则处理：合并、去重、排序、剔除白名单、剔除黑名单\n        blockList, blockSet_block = self.__domainSort(blockDict, blackSet, whiteSet)\n        unblockList, unblockSet_unblock = self.__domainSort(unblockDict, blackSet, whiteSet)\n        filterList_var, filterList, domainSet_filter = self.__filterSort(filterDict, set(blockList), set(unblockList), blackSet, whiteSet)\n        # 生成合并规则 AdGuard, AdGuardHome, DNSMasq, InviZible, SmartDNS\n        adguard = AdGuard(blockList, unblockList, filterDict, filterList, filterList_var, ChinaSet, self.path + \"/adblockfilters.txt\", sourceRule)\n        adguard.generateAll()\n        adguardhome = AdGuardHome(blockList, unblockList, filterDict, filterList, filterList_var, ChinaSet, self.path + \"/adblockdns.txt\", sourceRule)\n        adguardhome.generateAll()\n        clash = Clash(blockList, unblockList, filterDict, filterList, filterList_var, ChinaSet, self.path + \"/adblockclash.list\", sourceRule)\n        clash.generateAll()\n        dnsmasq = DNSMasq(blockList, unblockList, filterDict, filterList, filterList_var, ChinaSet, self.path + \"/adblockdnsmasq.txt\", sourceRule)\n        dnsmasq.generateAll()\n        invizible = InviZible(blockList, unblockList, filterDict, filterList, filterList_var, ChinaSet, self.path + \"/adblockdomain.txt\", sourceRule)\n        invizible.generateAll()\n        quantumultx = QuantumultX(blockList, unblockList, filterDict, filterList, filterList_var, ChinaSet, self.path + \"/adblockqx.conf\", sourceRule)\n        quantumultx.generateAll()\n        smartdns = SmartDNS(blockList, unblockList, filterDict, filterList, filterList_var, ChinaSet, self.path + \"/adblocksmartdns.conf\", sourceRule)\n        smartdns.generateAll()\n        # 生成用于域名连通性检测的全域名清单\n        self.__generateDomainBackup(blockSet_block | unblockSet_unblock | domainSet_filter, self.path + \"/domain.txt\")"
        },
        {
          "name": "readme.py",
          "type": "blob",
          "size": 8.2431640625,
          "content": "import re\nimport os\nfrom typing import List\n\nfrom loguru import logger\n\nclass Rule(object):\n    def __init__(self, name:str, type:str, url:str, latest:str, update:bool=False):\n        self.name = name\n        self.filename = self.name.replace(' ', '_') + '.txt'\n        self.type = type\n        self.url = url\n        self.latest = latest\n        self.update = update\n\n# redme文件操作\nclass ReadMe(object):\n    def __init__(self, filename:str):\n        self.filename = filename\n        self.ruleList:List[Rule] = []\n        self.proxyList = [\n            \"\",\n            \"https://gcore.jsdelivr.net/gh\",\n            \"https://github.boki.moe\",\n            \"https://mirror.ghproxy.com\"\n        ]\n\n    def getRules(self) -> List[Rule]:\n        logger.info(\"resolve readme...\")\n        self.ruleList = []\n        with open(self.filename, \"r\") as f:\n            for line in f:\n                line = line.replace('\\r', '').replace('\\n', '')\n                if line.find('|')==0 and line.rfind('|')==len(line)-1:\n                    rule = list(map(lambda x: x.strip(), line[1:-1].split('|')))\n                    if rule[2].find('(') > 0 and rule[2].find(')') > 0 and rule[1].find('(') < 0:\n                        url = rule[2][rule[2].find('(')+1:rule[2].find(')')]\n                        matchObj1 = re.match('(http|https):\\/\\/[\\w\\-_]+(\\.[\\w\\-_]+)+([\\w\\-\\.,@?^=%&:/~\\+#]*[\\w\\-\\@?^=%&/~\\+#])?', url)\n                        if matchObj1:\n                            self.ruleList.append(Rule(rule[0], rule[1], url, rule[-1]))\n        return self.ruleList\n\n    def getRulesNames(self) -> str:\n        names = \"\"\n        \n        for rule in self.ruleList:\n            names += rule.name + '、'\n        \n        return names[:-1]\n\n    def setRules(self, ruleList:List[Rule]):\n        self.ruleList = ruleList\n\n    def __subscribeLink(self, fileName:str, url:str=None):\n        link = \"\"\n\n        if url:\n            link += \" [原始链接](%s) |\"%(url)\n        else:\n            link += \" [原始链接](https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/%s) |\"%(fileName)\n        \n        for i in range(1, len(self.proxyList)):\n            proxy = self.proxyList[i]\n            if proxy.startswith(\"https://gcore.jsdelivr.net/\"):\n                link += \" [加速链接%d](%s/217heidai/adblockfilters@main/rules/%s) |\"%(i, proxy, fileName)\n            else:\n                link += \" [加速链接%d](%s/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/%s) |\"%(i, proxy, fileName)\n        \n        return link\n    \n    def regenerate(self):\n        logger.info(\"regenerate readme...\")\n        if os.path.exists(self.filename):\n            os.remove(self.filename)\n        \n        with open(self.filename, 'a') as f:\n            f.write(\"# AdBlock DNS Filters\\n\")\n            f.write(\"去广告合并规则，每8个小时更新一次。  \\n\")\n            f.write(\"个人收藏了不少广告过滤规则，但是每次往新设备添加的时候很是头疼，于是写了这个项目，定时自动获取各规则源更新，生成合并规则库。\\n\")\n            f.write(\"\\n\")\n\n            f.write(\"## 说明\\n\")\n            f.write(\"1. 定时从上游各规则源获取更新，合并去重。\\n\")\n            f.write(\"2. 使用国内、国外各 3 组 DNS 服务，分别对上游各规则源拦截的域名进行解析，去除已无法解析的域名。（上游各规则源中存在大量已无法解析的域名，无需加入拦截规则）\\n\")\n            f.write(\"3. 本项目仅对上游规则进行合并、去重、去除无效域名，不做任何修改。如发现误拦截情况，可临时添加放行规则（如 `@@||www.example.com^$important`），并向上游规则反馈。\\n\")\n            f.write(\"\\n\")\n\n            f.write(\"## 订阅链接\\n\")\n            f.write(\"1. AdGuard Home 等 DNS 拦截服务使用规则1\\n\")\n            f.write(\"2. AdGuard 等浏览器插件使用规则1 + 规则2（规则2为规则1的补充，仅适用浏览器插件）\\n\")\n            f.write(\"3. InviZible Pro、personalDNSfilter 使用规则3（规则3与规则1拦截域名一致，仅格式差异）\\n\")\n            f.write(\"4. DNSMasq 使用规则4（与规则1拦截域名一致，仅格式差异）\\n\")\n            f.write(\"5. SmartDNS 使用规则5（与规则1拦截域名一致，仅格式差异）\\n\")\n            f.write(\"6. Clash 使用规则6（与规则1拦截域名一致，仅格式差异）\\n\")\n            f.write(\"7. QuantumultX 使用规则7（与规则1拦截域名一致，仅格式差异）\\n\")\n            f.write(\"8. 规则x’为规则x的 Lite 版，仅针对国内域名拦截，体积较小（如添加完整规则报错数量限制，请尝试 Lite 规则）\\n\")\n            f.write(\"9. 已对 jsdelivr 缓存进行主动刷新，但 jsdelivr 加速链接仍存在一定延时\\n\")\n            f.write(\"\\n\")\n            tmp = \"| 规则 | 原始链接 |\"\n            for i in range(1, len(self.proxyList)):\n                tmp += \" 加速链接%d |\"%(i)\n            tmp += \" 适配说明 |\\n\"\n            f.write(tmp)\n            tmp = \"|\" + \":-|\" * ( 1 + len(self.proxyList) + 1) + \"\\n\"\n            f.write(tmp)\n            f.write(\"| 规则1 |\" + self.__subscribeLink(\"adblockdns.txt\") + \" AdGuard、AdGuard Home 等 |\\n\")\n            f.write(\"| 规则1' |\" + self.__subscribeLink(\"adblockdnslite.txt\") + \" AdGuard、AdGuard Home 等 |\\n\")\n            f.write(\"| 规则2 |\" + self.__subscribeLink(\"adblockfilters.txt\") + \" AdGuard 等 |\\n\")\n            f.write(\"| 规则2' |\" + self.__subscribeLink(\"adblockfilterslite.txt\") + \" AdGuard 等 |\\n\")\n            f.write(\"| 规则3 |\" + self.__subscribeLink(\"adblockdomain.txt\") + \" InviZible Pro、personalDNSfilter |\\n\")\n            f.write(\"| 规则3' |\" + self.__subscribeLink(\"adblockdomainlite.txt\") + \" InviZible Pro、personalDNSfilter |\\n\")\n            f.write(\"| 规则4 |\" + self.__subscribeLink(\"adblockdnsmasq.txt\") + \" DNSMasq |\\n\")\n            f.write(\"| 规则4' |\" + self.__subscribeLink(\"adblockdnsmasqlite.txt\") + \" DNSMasq |\\n\")\n            f.write(\"| 规则5 |\" + self.__subscribeLink(\"adblocksmartdns.conf\") + \" SmartDNS |\\n\")\n            f.write(\"| 规则5' |\" + self.__subscribeLink(\"adblocksmartdnslite.conf\") + \" SmartDNS |\\n\")\n            f.write(\"| 规则6 |\" + self.__subscribeLink(\"adblockclash.list\") + \" Clash |\\n\")\n            f.write(\"| 规则6' |\" + self.__subscribeLink(\"adblockclashlite.list\") + \" Clash |\\n\")\n            f.write(\"| 规则7 |\" + self.__subscribeLink(\"adblockqx.conf\") + \" QuantumultX |\\n\")\n            f.write(\"| 规则7' |\" + self.__subscribeLink(\"adblockqxlite.conf\") + \" QuantumultX |\\n\")\n            f.write(\"\\n\")\n\n            f.write(\"## 上游规则源\\n\")\n            f.write(\"1. 感谢各位广告过滤规则维护大佬们的辛苦付出。\\n\")\n            f.write(\"2. 不再引用[anti-AD](https://anti-ad.net/adguard.txt)、[yhosts](https://raw.githubusercontent.com/VeleSila/yhosts/master/hosts.txt)，具体原因见[Mosney/anti-anti-AD](https://github.com/Mosney/anti-anti-AD)。\\n\")\n            f.write(\"3. 移除[Notracking blocklist](https://raw.githubusercontent.com/notracking/hosts-blocklists/master/adblock/adblock.txt)，原项目[已停止维护](https://github.com/notracking/hosts-blocklists/issues/900)。\\n\")\n            f.write(\"4. 移除[ADgk](https://raw.githubusercontent.com/banbendalao/ADgk/master/ADgk.txt)，项目超过 1 年未更新。\\n\")\n            f.write(\"5. 不再引用[NEO DEV HOST](https://github.com/neodevpro/neodevhost/blob/master/lite_adblocker)，原因见[Issues 85](https://github.com/217heidai/adblockfilters/issues/85)。\\n\")\n            f.write(\"\\n\")\n\n            tmp = \"| 规则 | 类型 | 原始链接 |\"\n            for i in range(1, len(self.proxyList)):\n                tmp += \" 加速链接%d |\"%(i)\n            tmp += \" 更新日期 |\\n\"\n            f.write(tmp)\n            tmp = \"|\" + \":-|\" * ( 2 + len(self.proxyList) + 1) + \"\\n\"\n            f.write(tmp)\n            for rule in self.ruleList:\n                f.write(\"| %s | %s |%s %s |\\n\" % (rule.name, rule.type, self.__subscribeLink(rule.filename, rule.url),rule.latest))\n            f.write(\"\\n\")\n            \n            f.write(\"## Star History\\n\")\n            f.write(\"[![Star History Chart](https://api.star-history.com/svg?repos=217heidai/adblockfilters&type=Date)](https://star-history.com/#217heidai/adblockfilters&Date)\\n\")"
        },
        {
          "name": "refreshcdn.py",
          "type": "blob",
          "size": 1.8642578125,
          "content": "import os\nimport asyncio\nfrom typing import List,Tuple\n\nimport httpx\nfrom loguru import logger\n\nclass RefreshCDN(object):\n    def __init__(self):\n        self.pwd = os.getcwd() + '/rules'\n        self.blockList = [\n            \"apple-cn.txt\",\n            \"black.txt\",\n            \"china.txt\",\n            \"CN-ip-cidr.txt\",\n            \"direct-list.txt\",\n            \"domain.txt\",\n            \"google-cn.txt\",\n            \"myblock.txt\",\n            \"white.txt\"\n        ]\n\n    def __getRuleList(self, pwd:str) -> List[str]:\n        L = []\n        cmd = 'cd %s && ls' %(pwd)\n        process = os.popen(cmd)\n        output = process.read()\n        process.close()\n        result = output.split(\"\\n\")\n        for fileName in result:\n            if os.path.isfile(\"%s/%s\"%(pwd, fileName)) and fileName not in self.blockList:\n                L.append(fileName)\n        return L\n\n    async def __refresh(self, fileName):\n        try:\n            async with httpx.AsyncClient() as client:\n                response = await client.get(\"https://purge.jsdelivr.net/gh/217heidai/adblockfilters@main/rules/%s\"%(fileName))\n                response.raise_for_status()\n                status = response.json().get(\"status\", \"\")\n                logger.info(f'%s refresh status: %s' % (fileName, status))\n        except Exception as e:\n            logger.error(f'%s refresh failed: %s' % (fileName, e))\n\n    def refresh(self):\n        ruleList = self.__getRuleList(self.pwd)\n        # 启动异步循环\n        loop = asyncio.get_event_loop()\n        # 添加异步任务\n        taskList = []\n        for rule in ruleList:\n            logger.info(\"refresh %s...\"%(rule))\n            task = asyncio.ensure_future(self.__refresh(rule))\n            taskList.append(task)\n        # 等待异步任务结束\n        loop.run_until_complete(asyncio.wait(taskList))\n\nif __name__ == '__main__':\n    cdn = RefreshCDN()\n    cdn.refresh()"
        },
        {
          "name": "resolver.py",
          "type": "blob",
          "size": 21.7705078125,
          "content": "import os\nimport sys\nimport re\nfrom typing import Tuple,Dict,Set,List\n\nfrom tld import get_tld\nimport IPy\nfrom loguru import logger\n\nfrom readme import Rule\n\nclass Resolver(object):\n    def __init__(self, path:str):\n        self.path = path\n        self.options = {# Adblock Plus filter options\n                        'script',         '~script',\n                        'image',          '~image',\n                        'stylesheet',     '~stylesheet',\n                        'object',         '~object',\n                        'subdocument',    '~subdocument',\n                        'xmlhttprequest', '~xmlhttprequest',\n                        'websocket',      '~websocket',\n                        'webrtc',         '~webrtc',\n                        'popup',\n                        'generichide',\n                        'genericblock',\n                        'document',\n                        'elemhide',\n                        'third-party', '~third-party',\n                        'ping',\n                        'other',\n                        'match-case',\n                        # AdGuard Advanced capabilities\n                        'ctag',\n                        'all',\n                        'redirect',\n                        'stealth',\n                        'domain'\n                    }\n    \n    def __ip_or_domain(self, address:str) -> Tuple[str]: # ip, fld, subdomain\n        ip, fld, subdomain = None, None, None\n        try:\n            res = get_tld(address, fix_protocol=True, as_object=True)\n            fld = res.fld\n            subdomain = res.subdomain\n        except Exception as e:\n            try:\n                ip_address = IPy.IP(address)\n                if ip_address.iptype() == \"PUBLIC\":\n                    ip = address\n            except Exception as e:\n                pass\n        finally:\n            return ip, fld, subdomain\n    \n    def __analysis(self, address:str) -> Tuple[str]:\n        address_tmp = address\n        if address.rfind(\":\") > 0:\n            address_tmp = address[ : address.rfind(\":\")]\n        ip, fld, subdomain = self.__ip_or_domain(address_tmp)\n        if ip:\n            return address, \"\" # 可能包含port，因此直接return address\n        if fld:\n            return fld, subdomain\n        raise Exception('\"%s\": not domain or public ip'%(address))\n\n    # host 模式\n    def __resolveHost(self, line) -> Tuple[str]:\n        def match(pattern, string):\n            return True if re.match(pattern, string) else False\n        try:\n            block=None\n            while True:\n                # #* 注释\n                if match('^#.*', line):\n                    break\n\n                if line.find('#') > 0:\n                    line = line[:line.find('#')].strip()\n                \n                if line.startswith('0.0.0.0') or line.startswith('127.0.0.1'):\n                    row = line.split(' ')\n                    domain = row[-1]\n                    if domain not in {'localhost', 'localhost.localdomain', 'local', '0.0.0.0'}:\n                        block = self.__analysis(domain)\n                        break\n                raise Exception('\"%s\": not keep'%(line))\n        except Exception as e:\n            logger.error(\"%s\"%(e))\n        finally:\n            return block\n\n    # 从 filter 规则中找出包含的域名\n    def __resolveFilterDomain(self, filter) -> Tuple[str, str]:\n        def match(pattern, string) -> bool:\n            return True if re.match(pattern, string) else False\n        domain = None\n        try:\n            domain_tmp = None\n            while True:\n                '''\n                # for test\n                if filter == \"@@|https://media.amazon.map.fastly.net^$script\":\n                    print(filter)\n                '''\n                if filter.startswith('#%#var'):\n                    break\n\n                if filter.startswith('###'):\n                    break\n\n                if filter.startswith('##') and filter.find('://') < 0:\n                    break\n\n                if match('^/.*/$', filter):\n                    break\n\n                if match('^\\|\\|.*\\*.*\\^$', filter):\n                    break\n\n                # ||example.org^$option\n                # @@||example.org^$option\n                if match('^\\|\\|.*\\^\\$.*', filter) or match('^@@\\|\\|.*\\^\\$.*', filter):\n                    for opt in self.options:\n                        if match('^\\|\\|.*\\^\\$%s'%(opt), filter):\n                            domain_tmp = filter[len('||'):filter.find('^$%s'%(opt))]\n                            break\n                        if match('^@@\\|\\|.*\\^\\$%s'%(opt), filter):\n                            domain_tmp = filter[len('@@||'):filter.find('^$%s'%(opt))]\n                            break\n                    break\n                # ||example.org\n                if match('^\\|\\|.*', filter):\n                    domain_tmp = filter[len('||'):]\n                    if domain_tmp.find('/') > 0:\n                        domain_tmp = domain_tmp[:domain_tmp.find('/')]\n                    if domain_tmp.find('$') > 0:\n                        domain_tmp = domain_tmp[:domain_tmp.find('$')]\n                    if domain_tmp.find('^*') > 0:\n                        domain_tmp = domain_tmp[:domain_tmp.find('^*')]\n                    if domain_tmp.find('*') > 0:\n                        domain_tmp = domain_tmp[:domain_tmp.find('*')]\n                    break\n                # @@||example.org\n                if match('^@@\\|\\|.*', filter):\n                    domain_tmp = filter[len('@@||'):]\n                    if domain_tmp.find('/') > 0:\n                        domain_tmp = domain_tmp[:domain_tmp.find('/')]\n                    if domain_tmp.find('$') > 0:\n                        domain_tmp = domain_tmp[:domain_tmp.find('$')]\n                    if domain_tmp.find('^*') > 0:\n                        domain_tmp = domain_tmp[:domain_tmp.find('^*')]\n                    if domain_tmp.find('*') > 0:\n                        domain_tmp = domain_tmp[:domain_tmp.find('*')]\n                    break\n\n                # ip$network\n                if match('.*\\$network$', filter):\n                    domain_tmp = filter[:-len('$network')]\n                    if domain_tmp.startswith('@@'):\n                        domain_tmp = domain_tmp[2:]\n                    break\n\n                # example.org^\n                if match('.*\\^$', filter):\n                    domain_tmp = filter[:-1]\n                    break\n                \n                # ##\n                # example.com##selector\n                # ~example.com##selector\n                # example.com,example.edu##selector\n                # example.com,~mail.example.com##selector\n                connector = '##'\n                if match('.*%s.*'%(connector), filter) and not filter.startswith(connector) and not filter.endswith(connector):\n                    domain_tmp = filter[ : filter.find(connector)]\n                    if domain_tmp.find(',') > 0:\n                        domain_tmp = None\n                    break\n                # #?#\n                # example.com#?#selector\n                # ~example.com#?#selector\n                # example.com,example.edu#?#selector\n                # example.com,~mail.example.com#?#selector\n                connector = '#\\?#'\n                if match('.*%s.*'%(connector), filter) and not filter.startswith(connector) and not filter.endswith(connector):\n                    domain_tmp = filter[ : filter.find('#?#')] # 需去掉转义符'#\\?#' -> '#?#'\n                    if domain_tmp.find(',') > 0:\n                        domain_tmp = None\n                    break\n                # #@#\n                # example.com#@#selector\n                # ~example.com#@#selector\n                # example.com,example.edu#@#selector\n                # example.com,~mail.example.com#@#selector\n                connector = '#@#'\n                if match('.*%s.*'%(connector), filter) and not filter.startswith(connector) and not filter.endswith(connector):\n                    domain_tmp = filter[ : filter.find(connector)]\n                    if domain_tmp.find(',') > 0:\n                        domain_tmp = None\n                    break\n                # #$#\n                # example.com#$#selector\n                # ~example.com#$#selector\n                # example.com,example.edu#$#selector\n                # example.com,~mail.example.com#$#selector\n                connector = '#\\$#'\n                if match('.*%s.*'%(connector), filter) and not filter.startswith(connector) and not filter.endswith(connector):\n                    domain_tmp = filter[ : filter.find('#$#')] # 需去掉转义符'#\\$#' -> '#$#'\n                    if domain_tmp.find(',') > 0:\n                        domain_tmp = None\n                    break\n                # #%#\n                # example.com#%#selector\n                # ~example.com#%#selector\n                # example.com,example.edu#%#selector\n                # example.com,~mail.example.com#%#selector\n                connector = '#%#'\n                if match('.*%s.*'%(connector), filter) and not filter.startswith(connector) and not filter.endswith(connector):\n                    domain_tmp = filter[ : filter.find(connector)]\n                    if domain_tmp.find(',') > 0:\n                        domain_tmp = None\n                    break\n                \n                # a[href^=\"http://sarcasmadvisor.com/\"]\n                if match('.*http:\\/\\/.*', filter):\n                    domain_tmp = filter[filter.find('http://') + len('http://'):]\n                    if domain_tmp.startswith('*.'):\n                        domain_tmp = domain_tmp[2:]\n                    if domain_tmp.find(\"'\") > 0:\n                        domain_tmp = domain_tmp[:domain_tmp.find(\"'\")]\n                    if domain_tmp.find(\"^\") > 0:\n                        domain_tmp = domain_tmp[:domain_tmp.find(\"^\")]\n                    if domain_tmp.find('$') > 0:\n                        domain_tmp = domain_tmp[:domain_tmp.find('$')]\n                    if domain_tmp.find(',') > 0:\n                        domain_tmp = None\n                    break\n\n                # a[href^=\"https://sarcasmadvisor.com/\"]\n                if match('.*https:\\/\\/.*', filter):\n                    domain_tmp = filter[filter.find('https://') + len('https://'):]\n                    if domain_tmp.startswith('*.'):\n                        domain_tmp = domain_tmp[2:]\n                    if domain_tmp.find(\"'\") > 0:\n                        domain_tmp = domain_tmp[:domain_tmp.find(\"'\")]\n                    if domain_tmp.find(\"^\") > 0:\n                        domain_tmp = domain_tmp[:domain_tmp.find(\"^\")]\n                    if domain_tmp.find('$') > 0:\n                        domain_tmp = domain_tmp[:domain_tmp.find('$')]\n                    if domain_tmp.find(',') > 0:\n                        domain_tmp = None\n                    break\n                \n                # 其它规则\n                raise Exception('\"%s\": can not resolve domain or ip'%(filter))\n            \n            if domain_tmp:\n                if domain_tmp.find('\"') > 0:\n                    domain_tmp = domain_tmp[:domain_tmp.find('\"')]\n                if domain_tmp.find('^') > 0:\n                    domain_tmp = domain_tmp[:domain_tmp.find('^')]\n                if domain_tmp.startswith('*.') > 0:\n                    domain_tmp = domain_tmp[len('*.'):]\n                if domain_tmp.startswith('~') or domain_tmp.startswith('/') or domain_tmp.startswith('.'):\n                    domain_tmp = domain_tmp[1:]\n                if domain_tmp.find('/') > 0:\n                    domain_tmp = domain_tmp[:domain_tmp.find('/')]\n                if len(domain_tmp) < 4 or domain_tmp.find('.') < 0 or domain_tmp.find('*') >= 0 or domain_tmp[-1]=='.' or domain_tmp.startswith('-'):\n                    raise Exception('\"%s\": not include domain or ip'%(filter))\n                try:\n                    fld, subdomain = self.__analysis(domain_tmp)\n                    if len(subdomain) > 0:\n                        domain = \"%s.%s\"%(subdomain,fld)\n                    else:\n                        domain = \"%s\"%(fld)\n                except Exception as e:\n                    raise Exception('\"%s\": not include domain or ip'%(filter))\n        except Exception as e:\n            logger.error(\"%s\"%(e))\n        finally:\n            return filter,domain\n\n    # dns 模式\n    def __resolveDNS(self, line) -> Tuple[Tuple[str],Tuple[str],Tuple[str]]:\n        def match(pattern, string):\n            return True if re.match(pattern, string) else False\n        try:\n            block,unblock,filter=None,None,None\n            while True:\n                # !* 注释\n                if match('^!.*', line):\n                    break\n                # [*] 注释\n                if match('^\\[.*\\]$', line):\n                    break\n                # #* 注释\n                if match('^#.*', line):\n                    break\n\n                # 干掉注释\n                if line.find('#') > 0:\n                    line = line[:line.find('#')].strip()\n\n                # ||example.org^\n                if match('^\\|\\|.*\\^$', line):\n                    domain = line[2:-1]\n                    if domain.find('*') >= 0:\n                        if domain.startswith('*.') and domain[2:].find('*')<0:\n                            domain = domain[2:]\n                            block = self.__analysis(domain)\n                            break\n                        filter = line\n                        break\n                    block = self.__analysis(domain)\n                    break\n                # @@||example.org^\n                if match('^@@\\|\\|.*\\^$', line):\n                    domain = line[4:-1]\n                    if domain.find('*') >= 0:\n                        if domain.startswith('*.') and domain[2:].find('*')<0:\n                            domain = domain[2:]\n                            unblock = self.__analysis(domain)\n                            break\n                        filter = line\n                        break\n                    unblock = self.__analysis(domain)\n                    break\n                # /REGEX/\n                if match('^/.*/$', line):\n                    filter = line\n                    break\n                # ||example. or ||example.org^$ctag=device_tv\n                if match('^\\|\\|.*', line):\n                    filter = line\n                    break\n                # other\n                raise Exception('\"%s\": not keep'%(line))\n            \n            if filter:\n                filter = self.__resolveFilterDomain(filter)\n        except Exception as e:\n            logger.error(\"%s\"%(e))\n        finally:\n            return block,unblock,filter\n\n    # filter 模式\n    def __resolveFilter(self, line) -> Tuple[Tuple[str],Tuple[str],Tuple[str]]:\n        def match(pattern, string):\n            return True if re.match(pattern, string) else False\n        try:\n            block,unblock,filter=None,None,None\n            while True:\n                # !* 注释\n                if match('^!.*', line):\n                    break\n                # [*] 注释\n                if match('^\\[.*\\]$', line):\n                    break\n                # ## or ###\n                if match('^##.*', line):\n                    filter = line\n                    break\n                # #%#\n                if match('^#%#.*', line):\n                    filter = line\n                    break\n                # #* 注释\n                if match('^#.*', line):\n                    break\n\n                # 干掉注释\n                #if line.find(' #') > 0:\n                #    line = line[:line.find(' #')].strip()\n\n                # ||example.org^: block access to the example.org domain and all its subdomains, like www.example.org.\n                if match('^\\|\\|.*\\^$', line):\n                    domain = line[2:-1]\n                    if domain.find('/') >= 0:\n                        filter = line\n                        break\n                    if domain.find('*') >= 0:\n                        if domain.startswith('*.') and domain[2:].find('*')<0:\n                            domain = domain[2:]\n                            block = self.__analysis(domain)\n                            break\n                        else:\n                            filter = line\n                            break\n                    block = self.__analysis(domain)\n                    break\n                # @@||example.org^: unblock access to the example.org domain and all its subdomains.\n                if match('^@@\\|\\|.*\\^$', line):\n                    domain = line[4:-1]\n                    if domain.find('*') >= 0 or domain.find('/') >= 0:\n                        filter = line\n                        break\n                    unblock = self.__analysis(domain)\n                    break\n                # @@||example.org^|: unblock access to the example.org domain and all its subdomains.\n                if match('^@@\\|\\|.*\\^\\|$', line):\n                    domain = line[4:-2]\n                    if domain.find('*') >= 0 or domain.find('/') >= 0:\n                        filter = line\n                        break\n                    unblock = self.__analysis(domain)\n                    break\n                # /REGEX/: block access to the domains matching the specified regular expression\n                if match('^/.*/$', line):\n                    filter = line\n                    break\n                # 判断是否为单纯的域名\n                if line.find('.')>0 and not line.startswith('*.') and not line.startswith('-') and line.find('=')<0 and line.find(':')<0 and line.find('*')<0 and line.find('_')<0 and line.find('?')<0 and line.find(';')<0 and line.find('|')<0 and line.find('$')<0 and line.find('#')<0 and line.find('/')<0 and line.find('%')<0 and line.find('^') < 0:\n                    domain = line\n                    block = self.__analysis(domain)\n                    break\n                # other\n                filter = line\n                break\n\n            if filter:\n                filter = self.__resolveFilterDomain(filter)\n        except Exception as e:\n            logger.error(\"%s\"%(e))\n        finally:\n            return block,unblock,filter\n\n    def resolveHost(self, rule:Rule) -> Tuple[Dict[str,Set[str]],Dict[str,Set[str]],Dict[str,str]]:\n        blockDict:Dict[str,Set[str]] = dict()\n        unblockDict:Dict[str,Set[str]] = dict()\n        filterDict:Dict[str,str] = dict()\n\n        filename = self.path + '/' + rule.filename\n\n        if not os.path.exists(filename):\n            return blockDict,unblockDict,filterDict\n\n        with open(filename, \"r\") as f:\n            for line in f:\n                # 去掉换行符\n                line = line.replace('\\r', '').replace('\\n', '').strip()\n                # 去掉空行\n                if len(line) < 1:\n                    continue\n\n                block = self.__resolveHost(line)\n                \n                if block:\n                    if block[0] not in blockDict:\n                        blockDict[block[0]] = {block[1],}\n                    else:\n                        blockDict[block[0]].add(block[1])\n        logger.info(\"%s: block=%d, unblock=%d, filter=%d\"%(rule.name,len(blockDict),len(unblockDict),len(filterDict)))\n        return blockDict,unblockDict,filterDict\n\n    def resolveDNS(self, rule:Rule) -> Tuple[Dict[str,Set[str]],Dict[str,Set[str]],Dict[str,str]]:\n        blockDict:Dict[str,Set[str]] = dict()\n        unblockDict:Dict[str,Set[str]] = dict()\n        filterDict:Dict[str,str] = dict()\n\n        filename = self.path + '/' + rule.filename\n\n        if not os.path.exists(filename):\n            return blockDict,unblockDict,filterDict\n\n        with open(filename, \"r\") as f:\n            for line in f:\n                # 去掉换行符\n                line = line.replace('\\r', '').replace('\\n', '').strip()\n                # 去掉空行\n                if len(line) < 1:\n                    continue\n\n                block,unblock,filter = self.__resolveDNS(line)\n                \n                if block:\n                    if block[0] not in blockDict:\n                        blockDict[block[0]] = {block[1],}\n                    else:\n                        blockDict[block[0]].add(block[1])\n                if unblock:\n                    if unblock[0] not in unblockDict:\n                        unblockDict[unblock[0]] = {unblock[1],}\n                    else:\n                        unblockDict[unblock[0]].add(unblock[1])\n                if filter:\n                    filterDict[filter[0]] = filter[1]\n        logger.info(\"%s: block=%d, unblock=%d, filter=%d\"%(rule.name,len(blockDict),len(unblockDict),len(filterDict)))\n        return blockDict,unblockDict,filterDict\n    \n    def resolveFilter(self, rule:Rule) -> Tuple[Dict[str,Set[str]],Dict[str,Set[str]],Dict[str,str]]:\n        blockDict:Dict[str,Set[str]] = dict()\n        unblockDict:Dict[str,Set[str]] = dict()\n        filterDict:Dict[str,str] = dict()\n\n        filename = self.path + '/' + rule.filename\n\n        if not os.path.exists(filename):\n            return blockDict,unblockDict,filterDict\n\n        with open(filename, \"r\") as f:\n            for line in f:\n                # 去掉换行符\n                line = line.replace('\\r', '').replace('\\n', '').strip()\n                # 去掉空行\n                if len(line) < 1:\n                    continue\n\n                block,unblock,filter = self.__resolveFilter(line)\n                \n                if block:\n                    if block[0] not in blockDict:\n                        blockDict[block[0]] = {block[1],}\n                    else:\n                        blockDict[block[0]].add(block[1])\n                if unblock:\n                    if unblock[0] not in unblockDict:\n                        unblockDict[unblock[0]] = {unblock[1],}\n                    else:\n                        unblockDict[unblock[0]].add(unblock[1])\n                if filter:\n                    filterDict[filter[0]] = filter[1]\n        logger.info(\"%s: block=%d, unblock=%d, filter=%d\"%(rule.name,len(blockDict),len(unblockDict),len(filterDict)))\n        return blockDict,unblockDict,filterDict"
        },
        {
          "name": "rules",
          "type": "tree",
          "content": null
        },
        {
          "name": "smartdns.conf",
          "type": "blob",
          "size": 1.998046875,
          "content": "# 监听端口\nbind [::]:5053\n\n#### log ####\n# 日志级别 off、fatal、error、warn、notice、info 或 debug\nlog-level info\n# 日志文件路径\nlog-file /tmp/smartdns/smartdns.log\n\n#### 缓存 ####\n# 域名结果缓存个数，1 条缓存占内存 512 字节。0 关闭缓存，不配置为系统自动设置（系统内存 128 M，自动缓存 32768 条占内存 16 M；系统内存 256 M，自动缓存 65536 条占内存 32 M；系统内存 512 M，自动缓存 131072 条占内存 64 M；系统内存大于 512 M，自动缓存 262144 条占内存 128 M）。\n#cache-size 65536\n# 是否持久化缓存。自动，当 cache-file 所在的位置有超过 128 MB 的可用空间时启用，否则禁用\ncache-persist yes\n# 缓存持久化文件路径\ncache-file /tmp/smartdns/cache.dump\n\n#### IPV6 #####\n# 双栈 IP 优选。关闭\ndualstack-ip-selection no\n# 强制 AAAA 地址返回 SOA。禁用ipv6\nforce-AAAA-SOA yes\n\n#### 测速 ####\n# 测速模式\nspeed-check-mode ping,tcp:80,tcp:443\n# 首次查询响应模式。模式：\n#[first-ping]: 最快ping响应地址模式，DNS上游最快查询时延+ping时延最短，查询等待与链接体验最佳;\n#[fastest-ip]: 最快IP地址模式，查询到的所有IP地址中ping最短的IP。需等待IP测速;\n#[fastest-response]: 最快响应的DNS结果，DNS查询等待时间最短，返回的IP地址可能不是最快。\nresponse-mode first-ping\n\n#### 其它 ####\n# 强制指定 qtype 返回 SOA。禁用 SOA 65\nforce-qtype-SOA 65\n# TCP 链接空闲超时时间\ntcp-idle-time 120\n\n#### 上游 DNS 服务 ####\n# 此处利用 SmartDNS 的 EDNS 客户端子网，解析上海电信（202.96.209.133 为上海电信 DNS IP）优化的访问 IP。\n# Google\nserver-tls 8.8.8.8:853 -subnet 202.96.209.133\n# Cloudflare\nserver-tls 1.1.1.1:853 -subnet 202.96.209.133\n# Quad9\nserver-tls 9.9.9.9:853 -subnet 202.96.209.133\n# AliDNS\nserver-tls 223.5.5.5:853 -subnet 202.96.209.133\n# DNSPod\nserver-tls 1.12.12.12:853 -subnet 202.96.209.133\n# 360\nserver-tls 112.65.69.15:853 -subnet 202.96.209.133"
        },
        {
          "name": "updater.py",
          "type": "blob",
          "size": 2.822265625,
          "content": "import os\nimport time\nimport hashlib\nimport asyncio\nfrom typing import List,Tuple\n\nimport httpx\nfrom loguru import logger\n\nfrom readme import Rule\n\n# 上游规则更新\nclass Updater(object):\n    def __init__(self, ruleList:List[Rule]):\n        self.ruleList = ruleList\n        self.isNeedUpdate = False\n\n    def update(self, path:str) -> Tuple[bool,List[Rule]]:\n        # 启动异步循环\n        loop = asyncio.get_event_loop()\n        # 添加异步任务\n        taskList = []\n        for rule in self.ruleList:\n            logger.info(\"updating %s...\"%(rule.name))\n            task = asyncio.ensure_future(self.__Download(rule, path))\n            taskList.append(task)\n        # 等待异步任务结束\n        loop.run_until_complete(asyncio.wait(taskList))\n        # 获取异步任务结果\n        for task in taskList:\n            new:Rule = task.result()\n            for rule in self.ruleList:\n                if new.name == rule.name:\n                    rule.latest = new.latest\n                    rule.update = new.update\n                    if rule.update:\n                        self.isNeedUpdate = rule.update\n                    break\n        return self.isNeedUpdate, self.ruleList\n\n    def __CalcFileSha256(self, filename):\n        with open(filename, \"rb\") as f:\n            sha256obj = hashlib.sha256()\n            sha256obj.update(f.read())\n            hash_value = sha256obj.hexdigest()\n            return hash_value\n\n    async def __Download(self, rule:Rule, path:str) -> Rule:\n        fileName = path + \"/\" + rule.filename\n        fileName_download = fileName + '.download'\n        try:\n            if os.path.exists(fileName_download):\n                os.remove(fileName_download)\n\n            async with httpx.AsyncClient() as client:\n                response = await client.get(rule.url)\n                response.raise_for_status()\n                contentType = response.headers.get(\"Content-Type\")\n                if contentType.find(\"text/plain\") < 0:\n                    raise Exception(\"Content-Type[%s] error\"%(contentType))\n                with open(fileName_download,'wb') as f:\n                    f.write(response.content)\n\n            if os.path.exists(fileName):\n                sha256Old = self.__CalcFileSha256(fileName)\n                sha256New = self.__CalcFileSha256(fileName_download)\n                if sha256New != sha256Old:\n                    rule.update = True\n                os.remove(fileName)\n            else:\n                rule.update = True\n\n            os.rename(fileName_download, fileName)\n        except Exception as e:\n            logger.error(f'%s download failed: %s' % (rule.name, e))\n        finally:\n            if rule.update:\n                rule.latest = time.strftime(\"%Y/%m/%d\", time.localtime())\n            logger.info(\"%s: latest=%s, update=%s\"%(rule.name,rule.latest,rule.update))\n            return rule"
        }
      ]
    }
  ]
}