{
  "metadata": {
    "timestamp": 1736559666605,
    "page": 332,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM0MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "getsentry/responses",
      "stars": 4190,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".craft.yml",
          "type": "blob",
          "size": 0.2587890625,
          "content": "minVersion: \"0.21.0\"\ngithub:\n  owner: getsentry\n  repo: responses\nchangelog: CHANGES\ntargets:\n  - name: pypi\n  - name: github\n  - name: sentry-pypi\n    internalPypiRepo: getsentry/pypi\nrequireNames:\n  - /^responses-.+-py3-none-any.whl$/\n  - /^responses-.+.tar.gz$/\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.12890625,
          "content": ".arcconfig\n.coverage\n.DS_Store\n.idea\n.env\nvenv\n*.db\n*.egg-info\n*.pyc\n/htmlcov\n/dist\n/build\n/.cache\n/.pytest_cache\n/.tox\n/.artifacts\n"
        },
        {
          "name": ".pre-commit-config.yaml",
          "type": "blob",
          "size": 1.017578125,
          "content": "repos:\n  - repo: https://github.com/psf/black\n    rev: 23.3.0\n    hooks:\n    - id: black\n      args: [--line-length=88, --safe]\n  - repo: https://github.com/pre-commit/pre-commit-hooks\n    rev: v4.4.0\n    hooks:\n    - id: check-case-conflict\n    - id: check-merge-conflict\n    - id: check-symlinks\n    - id: end-of-file-fixer\n    - id: trailing-whitespace\n    - id: debug-statements\n    - id: requirements-txt-fixer\n  - repo: https://github.com/pycqa/isort\n    rev: 5.12.0\n    hooks:\n      - id: isort\n        name: isort (python)\n        args: ['--force-single-line-imports', '--profile', 'black']\n  - repo: https://github.com/pycqa/flake8\n    rev: 6.0.0\n    hooks:\n      - id: flake8\n        args: [ '--max-line-length', '100', '--max-doc-length', '120' ]\n  - repo: https://github.com/asottile/pyupgrade\n    rev: v3.10.1\n    hooks:\n    -   id: pyupgrade\n        args: [--py37-plus]\n  - repo: https://github.com/adamchainz/blacken-docs\n    rev: 1.14.0\n    hooks:\n      - id: blacken-docs\n        additional_dependencies: [ black == 23.3.0 ]\n"
        },
        {
          "name": ".vscode",
          "type": "tree",
          "content": null
        },
        {
          "name": "CHANGES",
          "type": "blob",
          "size": 15.4970703125,
          "content": "0.25.5\n------\n\n* Fix readme issue that prevented 0.25.4 from being published to pypi.\n\n0.25.4\n------\n\n* Responses can now match requests that use `data` with file-like objects.\n  Files will be read as bytes and stored in the request mock. See #736\n* `RequestsMock.matchers` was added. This property is an alias to `responses.matchers`. See #739\n* Removed tests from packaged wheels. See #746\n* Improved recorder API to ease use in REPL environments. See #745\n\n0.25.3\n------\n\n* Fixed `recorder` not saving and loading response headers with yaml files. See #715\n\n0.25.2\n------\n\n* Mulligan on 0.25.1 to run release pipeline correctly.\n* Added `matchers.body_matcher` for matching string request bodies. See #717\n\n0.25.1\n------\n\n* Fixed tests failures during RPM package builds. See #706\n* Fix mocked HEAD responses that have `Content-Length` set. See #712\n* Fixed error messages when matches fail: inputs are not sorted or reformatted. See #704\n\n0.25.0\n------\n\n* Added support for Python 3.12\n* Fixed `matchers.header_matcher` not failing when a matched header is missing from the request. See #702\n\n\n0.24.1\n------\n\n* Reverted overloads removal\n* Added typing to `Call` attributes.\n* Fix socket issues (see #693)\n\n\n0.24.0\n------\n\n* Added `BaseResponse.calls` to access calls data of a separate mocked request. See #664\n* Added `real_adapter_send` parameter to `RequestsMock` that will allow users to set\n  through which function they would like to send real requests\n* Added support for re.Pattern based header matching.\n* Added support for gzipped response bodies to `json_params_matcher`.\n* Fix `Content-Type` headers issue when the header was duplicated. See #644\n* Moved types-pyyaml dependency to `tests_requires`\n* Removed Python3.7 support\n\n0.23.3\n------\n\n* Allow urllib3>=1.25.10\n\n\n0.23.2\n------\n\n> This release is the last to support Python 3.7\n\n* Updated dependency to urllib3>=2 and requests>=2.30.0. See #635\n* Fixed issue when custom adapters were sending only positional args. See #642\n* Expose `unbound_on_send` method in `RequestsMock` class. This method returns new function\n  that is called by `RequestsMock` instead of original `send` method defined by any adapter.\n\n\n0.23.1\n------\n\n* Remove `tomli` import. See #630\n\n0.23.0\n------\n\n* Add Python 3.11 support\n* Fix type annotations of `CallList`. See #593\n* `request` object is attached to any custom exception provided as `Response` `body` argument. See #588\n* Fixed mocked responses leaking between tests when `assert_all_requests_are_fired` and a request was not fired.\n* [BETA] Default recorder format was changed to YAML.  Added `responses.RequestsMock._parse_response_file` and\n  `responses._recorder.Recorder.dump_to_file` methods that allow users to override default parser to eg toml, json\n\n0.22.0\n------\n\n* Update `requests` dependency to the version of 2.22.0 or higher. See #584.\n* [BETA] Added possibility to record responses to TOML files via `@_recorder.record(file_path=\"out.toml\")` decorator.\n* [BETA] Added possibility to replay responses (populate registry) from TOML files\n  via `responses._add_from_file(file_path=\"out.toml\")` method.\n* Fix type for the `mock`'s patcher object. See #556\n* Fix type annotation for `CallList`\n* Add `passthrough` argument to `BaseResponse` object. See #557\n* Fix `registries` leak. See #563\n* `OriginalResponseShim` is removed. See #585\n* Add support for the `loose` version of `json_params_matcher` via named argument `strict_match`. See #551\n* Add lists support as JSON objects in `json_params_matcher`. See #559\n* Added project links to pypi listing.\n* `delete`, `get`, `head`, `options`, `patch`, `post`, `put` shortcuts are now implemented using `functools.partialmethod`.\n* Fix `MaxRetryError` exception. Replace exception by `RetryError` according to `requests` implementation. See #572.\n* Adjust error message when `Retry` is exhausted. See #580.\n\n0.21.0\n------\n\n* Add `threading.Lock()` to allow `responses` working with `threading` module.\n* Add `urllib3` `Retry` mechanism. See #135\n* Removed internal `_cookies_from_headers` function\n* Now `add`, `upsert`, `replace` methods return registered response.\n  `remove` method returns list of removed responses.\n* Added null value support in `urlencoded_params_matcher` via `allow_blank` keyword argument\n* Added strict version of decorator. Now you can apply `@responses.activate(assert_all_requests_are_fired=True)`\n  to your function to validate that all requests were executed in the wrapped function. See #183\n\n\n0.20.0\n------\n\n* Deprecate `responses.assert_all_requests_are_fired`, `responses.passthru_prefixes`, `responses.target`\n  since they are not actual properties of the class instance.\n  Use `responses.mock.assert_all_requests_are_fired`,\n  `responses.mock.passthru_prefixes`, `responses.mock.target` instead.\n* Fixed the issue when `reset()` method was called in not stopped mock. See #511\n\n0.19.0\n------\n\n* Added a registry that provides more strict ordering based on the invocation index.\n  See `responses.registries.OrderedRegistry`.\n* Added shortcuts for each request method: delete, get, head, options, patch, post, put.\n  For example, to add response for POST request you can use `responses.post()` instead\n  of `responses.add(responses.POST)`.\n* Prevent `responses.activate` decorator to leak, if wrapped function called from within another\n  wrapped function. Also, allow calling of above mentioned chain. See #481 for more details.\n* Expose `get_registry()` method of `RequestsMock` object. Replaces internal `_get_registry()`.\n* `query_param_matcher` can now accept dictionaries with `int` and `float` values.\n* Add support for the `loose` version of `query_param_matcher` via named argument `strict_match`.\n* Added support for `async/await` functions.\n* `response_callback` is no longer executed on exceptions raised by failed `Response`s\n* Change logic of `_get_url_and_path` to comply with RFC 3986. Now URL match occurs by matching\n  schema, authority and path, where path is terminated by the first question mark (\"?\") or\n  number sign (\"#\") character, or by the end of the URI.\n* An error is now raised when both `content_type` and `headers[content-type]` are provided as parameters.\n* When a request isn't matched the passthru prefixes are now included in error messages.\n\n\n0.18.0\n------\n\n* Dropped support of Python 2.7, 3.5, 3.6\n* Fixed issue with type annotation for `responses.activate` decorator. See #468\n* Removed internal `_is_string` and `_ensure_str` functions\n* Removed internal `_quote` from `test_responses.py`\n* Removed internal `_matches` attribute of `RequestsMock` object.\n* Generated decorator wrapper now uses stdlib features instead of strings and exec\n* Fix issue when Deprecation Warning was raised with default arguments\n  in `responses.add_callback` due to `match_querystring`. See #464\n\n0.17.0\n------\n\n* This release is the last to support Python 2.7.\n* Fixed issue when `response.iter_content` when `chunk_size=None` entered infinite loop\n* Fixed issue when `passthru_prefixes` persisted across tests.\n  Now `add_passthru` is valid only within a context manager or for a single function and\n  cleared on exit\n* Deprecate `match_querystring` argument in `Response` and `CallbackResponse`.\n  Use `responses.matchers.query_param_matcher` or `responses.matchers.query_string_matcher`\n* Added support for non-UTF-8 bytes in `responses.matchers.multipart_matcher`\n* Added `responses.registries`. Now user can create custom registries to\n  manipulate the order of responses in the match algorithm\n  `responses.activate(registry=CustomRegistry)`\n* Fixed issue with response match when requests were performed between adding responses with\n  same URL. See Issue #212\n\n0.16.0\n------\n\n* Fixed regression with `stream` parameter deprecation, requests.session() and cookie handling.\n* Replaced adhoc URL parsing with `urllib.parse`.\n* Added ``match`` parameter to ``add_callback`` method\n* Added `responses.matchers.fragment_identifier_matcher`. This matcher allows you\n  to match request URL fragment identifier.\n* Improved test coverage.\n* Fixed failing test in python 2.7 when `python-future` is also installed.\n\n0.15.0\n------\n\n* Added `responses.PassthroughResponse` and\n  `reponses.BaseResponse.passthrough`. These features make building passthrough\n  responses more compatible with dynamcially generated response objects.\n* Removed the unused ``_is_redirect()`` function from responses internals.\n* Added `responses.matchers.request_kwargs_matcher`. This matcher allows you\n  to match additional request arguments like `stream`.\n* Added `responses.matchers.multipart_matcher`. This matcher allows you\n  to match request body and headers for ``multipart/form-data`` data\n* Added `responses.matchers.query_string_matcher`. This matcher allows you\n  to match request query string, similar to `responses.matchers.query_param_matcher`.\n* Added `responses.matchers.header_matcher()`. This matcher allows you to match\n  request headers. By default only headers supplied to `header_matcher()` are checked.\n  You can make header matching exhaustive by passing `strict_match=True` to `header_matcher()`.\n* Changed all matchers output message in case of mismatch. Now message is aligned\n  between Python2 and Python3 versions\n* Deprecate ``stream`` argument in ``Response`` and ``CallbackResponse``\n* Added Python 3.10 support\n\n0.14.0\n------\n\n* Added `responses.matchers`.\n* Moved `responses.json_params_matcher` to `responses.matchers.json_params_matcher`\n* Moved `responses.urlencoded_params_matcher` to\n  `responses.matchers.urlencoded_params_matcher`\n* Added `responses.matchers.query_param_matcher`. This matcher allows you\n  to match query strings with a dictionary.\n* Added `auto_calculate_content_length` option to `responses.add()`. When\n  enabled, this option will generate a `Content-Length` header\n  based on the number of bytes in the response body.\n\n0.13.4\n------\n\n* Improve typing support\n* Use URLs with normalized hostnames when comparing URLs.\n\n0.13.3\n------\n\n* Switch from Travis to GHA for deployment.\n\n0.13.2\n------\n\n* Fixed incorrect type stubs for `add_callback`\n\n0.13.1\n------\n\n* Fixed packages not containing type stubs.\n\n0.13.0\n------\n\n* `responses.upsert()` was added. This method will `add()` a response if one\n  has not already been registered for a URL, or `replace()` an existing\n  response.\n* `responses.registered()` was added. The method allows you to get a list of\n  the currently registered responses. This formalizes the previously private\n  `responses.mock._matches` method.\n* A more useful `__repr__` has been added to `Response`.\n* Error messages have been improved.\n\n0.12.1\n------\n\n* `responses.urlencoded_params_matcher` and `responses.json_params_matcher` now\n  accept None to match empty requests.\n* Fixed imports to work with new `urllib3` versions.\n* `request.params` now allows parameters to have multiple values for the same key.\n* Improved ConnectionError messages.\n\n0.12.0\n------\n\n- Remove support for Python 3.4.\n\n0.11.0\n------\n\n- Added the `match` parameter to `add()`.\n- Added `responses.urlencoded_params_matcher()` and `responses.json_params_matcher()`.\n\n0.10.16\n-------\n\n- Add a requirements pin to urllib3. This helps prevent broken install states where\n  cookie usage fails.\n\n0.10.15\n-------\n\n- Added `assert_call_count` to improve ergonomics around ensuring a mock was called.\n- Fix incorrect handling of paths with query strings.\n- Add Python 3.9 support to CI matrix.\n\n0.10.14\n-------\n\n- Retag of 0.10.13\n\n0.10.13\n-------\n\n- Improved README examples.\n- Improved handling of unicode bodies. The inferred content-type for unicode\n  bodies is now `text/plain; charset=utf-8`.\n- Streamlined querysting matching code.\n\n0.10.12\n-------\n\n- Fixed incorrect content-type in `add_callback()` when headers are provided as a list of tuples.\n\n0.10.11\n-------\n\n- Fixed invalid README formatted.\n- Fixed string formatting in error message.\n\n0.10.10\n------\n\n- Added Python 3.8 support\n- Remove Python 3.4 from test suite matrix.\n- The `response.request` object now has a `params` attribute that contains the query string parameters from the request that was captured.\n- `add_passthru` now supports `re` pattern objects to match URLs.\n- ConnectionErrors raised by responses now include more details on the request that was attempted and the mocks registered.\n\n0.10.9\n------\n\n- Fixed regression with `add_callback()` and content-type header.\n- Fixed implicit dependency on urllib3>1.23.0\n\n0.10.8\n------\n\n- Fixed cookie parsing and enabled multiple cookies to be set by using a list of\n  tuple values.\n\n0.10.7\n------\n\n- Added pypi badges to README.\n- Fixed formatting issues in README.\n- Quoted cookie values are returned correctly now.\n- Improved compatibility for pytest 5\n- Module level method names are no longer generated dynamically improving IDE navigation.\n\n0.10.6\n------\n\n- Improved documentation.\n- Improved installation requirements for py3\n- ConnectionError's raised by responses now indicate which request\n  path/method failed to match a mock.\n- `test_responses.py` is no longer part of the installation targets.\n\n0.10.5\n------\n\n- Improved support for raising exceptions from callback mocks. If a mock\n  callback returns an exception object that exception will be raised.\n\n0.10.4\n------\n\n- Fixed generated wrapper when using `@responses.activate` in Python 3.6+\n  when decorated functions use parameter and/or return annotations.\n\n0.10.3\n------\n\n- Fixed deprecation warnings in python 3.7 for inspect module usage.\n\n0.10.2\n------\n\n- Fixed build setup to use undeprecated `pytest` bin stub.\n- Updated `tox` configuration.\n- Added example of using responses with `pytest.fixture`\n- Removed dependency on `biscuits` in py3. Instead `http.cookies` is being used.\n\n0.10.1\n------\n\n- Packaging fix to distribute wheel (#219)\n\n0.10.0\n------\n\n- Fix passing through extra settings (#207)\n- Fix collections.abc warning on Python 3.7 (#215)\n- Use 'biscuits' library instead of 'cookies' on Python 3.4+ (#218)\n\n0.9.0\n-----\n\n- Support for Python 3.7 (#196)\n- Support streaming responses for BaseResponse (#192)\n- Support custom patch targets for mock (#189)\n- Fix unicode support for passthru urls (#178)\n- Fix support for unicode in domain names and tlds (177)\n\n0.8.0\n-----\n\n- Added the ability to passthru real requests via ``add_passthru()``\n  and ``passthru_prefixes`` configurations.\n\n0.7.0\n-----\n\n- Responses will now be rotated until the final match is hit, and\n  then persist using that response (GH-171).\n\n0.6.2\n-----\n\n- Fixed call counting with exceptions (GH-163).\n- Fixed behavior with arbitrary status codes (GH-164).\n- Fixed handling of multiple responses with the same match (GH-165).\n- Fixed default path behavior with ``match_querystring`` (GH-166).\n\n0.6.1\n-----\n\n- Restored ``adding_headers`` compatibility (GH-160).\n\n0.6.0\n-----\n\n- Allow empty list/dict as json object (GH-100).\n- Added `response_callback` (GH-151).\n- Added ``Response`` interfaces (GH-155).\n- Fixed unicode characters in querystring (GH-153).\n- Added support for streaming IO buffers (GH-154).\n- Added support for empty (unset) Content-Type (GH-139).\n- Added reason to mocked responses (GH-132).\n- ``yapf`` autoformatting now enforced on codebase.\n\n0.5.1\n-----\n\n- Add LICENSE, README and CHANGES to the PyPI distribution (GH-97).\n\n0.5.0\n-----\n\n- Allow passing a JSON body to `response.add` (GH-82)\n- Improve ConnectionError emulation (GH-73)\n- Correct assertion in assert_all_requests_are_fired (GH-71)\n\n0.4.0\n-----\n\n- Requests 2.0+ is required\n- Mocking now happens on the adapter instead of the session\n\n0.3.0\n-----\n\n- Add the ability to mock errors (GH-22)\n- Add responses.mock context manager (GH-36)\n- Support custom adapters (GH-33)\n- Add support for regexp error matching (GH-25)\n- Add support for dynamic bodies via `responses.add_callback` (GH-24)\n- Preserve argspec when using `responses.activate` decorator (GH-18)\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 10.5810546875,
          "content": "                              Apache License\n                        Version 2.0, January 2004\n                     http://www.apache.org/licenses/\n\nTERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n1. Definitions.\n\n   \"License\" shall mean the terms and conditions for use, reproduction,\n   and distribution as defined by Sections 1 through 9 of this document.\n\n   \"Licensor\" shall mean the copyright owner or entity authorized by\n   the copyright owner that is granting the License.\n\n   \"Legal Entity\" shall mean the union of the acting entity and all\n   other entities that control, are controlled by, or are under common\n   control with that entity. For the purposes of this definition,\n   \"control\" means (i) the power, direct or indirect, to cause the\n   direction or management of such entity, whether by contract or\n   otherwise, or (ii) ownership of fifty percent (50%) or more of the\n   outstanding shares, or (iii) beneficial ownership of such entity.\n\n   \"You\" (or \"Your\") shall mean an individual or Legal Entity\n   exercising permissions granted by this License.\n\n   \"Source\" form shall mean the preferred form for making modifications,\n   including but not limited to software source code, documentation\n   source, and configuration files.\n\n   \"Object\" form shall mean any form resulting from mechanical\n   transformation or translation of a Source form, including but\n   not limited to compiled object code, generated documentation,\n   and conversions to other media types.\n\n   \"Work\" shall mean the work of authorship, whether in Source or\n   Object form, made available under the License, as indicated by a\n   copyright notice that is included in or attached to the work\n   (an example is provided in the Appendix below).\n\n   \"Derivative Works\" shall mean any work, whether in Source or Object\n   form, that is based on (or derived from) the Work and for which the\n   editorial revisions, annotations, elaborations, or other modifications\n   represent, as a whole, an original work of authorship. For the purposes\n   of this License, Derivative Works shall not include works that remain\n   separable from, or merely link (or bind by name) to the interfaces of,\n   the Work and Derivative Works thereof.\n\n   \"Contribution\" shall mean any work of authorship, including\n   the original version of the Work and any modifications or additions\n   to that Work or Derivative Works thereof, that is intentionally\n   submitted to Licensor for inclusion in the Work by the copyright owner\n   or by an individual or Legal Entity authorized to submit on behalf of\n   the copyright owner. For the purposes of this definition, \"submitted\"\n   means any form of electronic, verbal, or written communication sent\n   to the Licensor or its representatives, including but not limited to\n   communication on electronic mailing lists, source code control systems,\n   and issue tracking systems that are managed by, or on behalf of, the\n   Licensor for the purpose of discussing and improving the Work, but\n   excluding communication that is conspicuously marked or otherwise\n   designated in writing by the copyright owner as \"Not a Contribution.\"\n\n   \"Contributor\" shall mean Licensor and any individual or Legal Entity\n   on behalf of whom a Contribution has been received by Licensor and\n   subsequently incorporated within the Work.\n\n2. Grant of Copyright License. Subject to the terms and conditions of\n   this License, each Contributor hereby grants to You a perpetual,\n   worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n   copyright license to reproduce, prepare Derivative Works of,\n   publicly display, publicly perform, sublicense, and distribute the\n   Work and such Derivative Works in Source or Object form.\n\n3. Grant of Patent License. Subject to the terms and conditions of\n   this License, each Contributor hereby grants to You a perpetual,\n   worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n   (except as stated in this section) patent license to make, have made,\n   use, offer to sell, sell, import, and otherwise transfer the Work,\n   where such license applies only to those patent claims licensable\n   by such Contributor that are necessarily infringed by their\n   Contribution(s) alone or by combination of their Contribution(s)\n   with the Work to which such Contribution(s) was submitted. If You\n   institute patent litigation against any entity (including a\n   cross-claim or counterclaim in a lawsuit) alleging that the Work\n   or a Contribution incorporated within the Work constitutes direct\n   or contributory patent infringement, then any patent licenses\n   granted to You under this License for that Work shall terminate\n   as of the date such litigation is filed.\n\n4. Redistribution. You may reproduce and distribute copies of the\n   Work or Derivative Works thereof in any medium, with or without\n   modifications, and in Source or Object form, provided that You\n   meet the following conditions:\n\n   (a) You must give any other recipients of the Work or\n       Derivative Works a copy of this License; and\n\n   (b) You must cause any modified files to carry prominent notices\n       stating that You changed the files; and\n\n   (c) You must retain, in the Source form of any Derivative Works\n       that You distribute, all copyright, patent, trademark, and\n       attribution notices from the Source form of the Work,\n       excluding those notices that do not pertain to any part of\n       the Derivative Works; and\n\n   (d) If the Work includes a \"NOTICE\" text file as part of its\n       distribution, then any Derivative Works that You distribute must\n       include a readable copy of the attribution notices contained\n       within such NOTICE file, excluding those notices that do not\n       pertain to any part of the Derivative Works, in at least one\n       of the following places: within a NOTICE text file distributed\n       as part of the Derivative Works; within the Source form or\n       documentation, if provided along with the Derivative Works; or,\n       within a display generated by the Derivative Works, if and\n       wherever such third-party notices normally appear. The contents\n       of the NOTICE file are for informational purposes only and\n       do not modify the License. You may add Your own attribution\n       notices within Derivative Works that You distribute, alongside\n       or as an addendum to the NOTICE text from the Work, provided\n       that such additional attribution notices cannot be construed\n       as modifying the License.\n\n   You may add Your own copyright statement to Your modifications and\n   may provide additional or different license terms and conditions\n   for use, reproduction, or distribution of Your modifications, or\n   for any such Derivative Works as a whole, provided Your use,\n   reproduction, and distribution of the Work otherwise complies with\n   the conditions stated in this License.\n\n5. Submission of Contributions. Unless You explicitly state otherwise,\n   any Contribution intentionally submitted for inclusion in the Work\n   by You to the Licensor shall be under the terms and conditions of\n   this License, without any additional terms or conditions.\n   Notwithstanding the above, nothing herein shall supersede or modify\n   the terms of any separate license agreement you may have executed\n   with Licensor regarding such Contributions.\n\n6. Trademarks. This License does not grant permission to use the trade\n   names, trademarks, service marks, or product names of the Licensor,\n   except as required for reasonable and customary use in describing the\n   origin of the Work and reproducing the content of the NOTICE file.\n\n7. Disclaimer of Warranty. Unless required by applicable law or\n   agreed to in writing, Licensor provides the Work (and each\n   Contributor provides its Contributions) on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n   implied, including, without limitation, any warranties or conditions\n   of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n   PARTICULAR PURPOSE. You are solely responsible for determining the\n   appropriateness of using or redistributing the Work and assume any\n   risks associated with Your exercise of permissions under this License.\n\n8. Limitation of Liability. In no event and under no legal theory,\n   whether in tort (including negligence), contract, or otherwise,\n   unless required by applicable law (such as deliberate and grossly\n   negligent acts) or agreed to in writing, shall any Contributor be\n   liable to You for damages, including any direct, indirect, special,\n   incidental, or consequential damages of any character arising as a\n   result of this License or out of the use or inability to use the\n   Work (including but not limited to damages for loss of goodwill,\n   work stoppage, computer failure or malfunction, or any and all\n   other commercial damages or losses), even if such Contributor\n   has been advised of the possibility of such damages.\n\n9. Accepting Warranty or Additional Liability. While redistributing\n   the Work or Derivative Works thereof, You may choose to offer,\n   and charge a fee for, acceptance of support, warranty, indemnity,\n   or other liability obligations and/or rights consistent with this\n   License. However, in accepting such obligations, You may act only\n   on Your own behalf and on Your sole responsibility, not on behalf\n   of any other Contributor, and only if You agree to indemnify,\n   defend, and hold each Contributor harmless for any liability\n   incurred by, or claims asserted against, such Contributor by reason\n   of your accepting any such warranty or additional liability.\n\nEND OF TERMS AND CONDITIONS\n\nAPPENDIX: How to apply the Apache License to your work.\n\n   To apply the Apache License to your work, attach the following\n   boilerplate notice, with the fields enclosed by brackets \"[]\"\n   replaced with your own identifying information. (Don't include\n   the brackets!)  The text should be enclosed in the appropriate\n   comment syntax for the file format. We also recommend that a\n   file or class name and description of purpose be included on the\n   same \"printed page\" as the copyright notice for easier\n   identification within third-party archives.\n\nCopyright 2015 David Cramer\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n"
        },
        {
          "name": "MANIFEST.in",
          "type": "blob",
          "size": 0.1357421875,
          "content": "include README.rst CHANGES LICENSE\nrecursive-include responses *.py\ninclude tox.ini\nrecursive-include responses py.typed\nglobal-exclude *~\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.392578125,
          "content": "develop: setup-git install-deps\n\ninstall-deps:\n\tpip install -e \"file://`pwd`#egg=responses[tests]\"\n\ninstall-pre-commit:\n\tpip install \"pre-commit>=2.9.2\"\n\nsetup-git: install-pre-commit\n\tpre-commit install\n\tgit config branch.autosetuprebase always\n\ntest: develop lint\n\t@echo \"Running Python tests\"\n\tpy.test .\n\t@echo \"\"\n\nlint: install-pre-commit\n\t@echo \"Linting Python files\"\n\tpre-commit run -a\n\t@echo \"\"\n"
        },
        {
          "name": "README.rst",
          "type": "blob",
          "size": 44.2744140625,
          "content": "Responses\n=========\n\n.. image:: https://img.shields.io/pypi/v/responses.svg\n    :target: https://pypi.python.org/pypi/responses/\n\n.. image:: https://img.shields.io/pypi/pyversions/responses.svg\n    :target: https://pypi.org/project/responses/\n\n.. image:: https://img.shields.io/pypi/dm/responses\n   :target: https://pypi.python.org/pypi/responses/\n\n.. image:: https://codecov.io/gh/getsentry/responses/branch/master/graph/badge.svg\n    :target: https://codecov.io/gh/getsentry/responses/\n\nA utility library for mocking out the ``requests`` Python library.\n\n..  note::\n\n    Responses requires Python 3.8 or newer, and requests >= 2.30.0\n\n\nTable of Contents\n-----------------\n\n.. contents::\n\n\nInstalling\n----------\n\n``pip install responses``\n\n\nDeprecations and Migration Path\n-------------------------------\n\nHere you will find a list of deprecated functionality and a migration path for each.\nPlease ensure to update your code according to the guidance.\n\n.. list-table:: Deprecation and Migration\n   :widths: 50 25 50\n   :header-rows: 1\n\n   * - Deprecated Functionality\n     - Deprecated in Version\n     - Migration Path\n   * - ``responses.json_params_matcher``\n     - 0.14.0\n     - ``responses.matchers.json_params_matcher``\n   * - ``responses.urlencoded_params_matcher``\n     - 0.14.0\n     - ``responses.matchers.urlencoded_params_matcher``\n   * - ``stream`` argument in ``Response`` and ``CallbackResponse``\n     - 0.15.0\n     - Use ``stream`` argument in request directly.\n   * - ``match_querystring`` argument in ``Response`` and ``CallbackResponse``.\n     - 0.17.0\n     - Use ``responses.matchers.query_param_matcher`` or ``responses.matchers.query_string_matcher``\n   * - ``responses.assert_all_requests_are_fired``, ``responses.passthru_prefixes``, ``responses.target``\n     - 0.20.0\n     - Use ``responses.mock.assert_all_requests_are_fired``,\n       ``responses.mock.passthru_prefixes``, ``responses.mock.target`` instead.\n\nBasics\n------\n\nThe core of ``responses`` comes from registering mock responses and covering test function\nwith ``responses.activate`` decorator. ``responses`` provides similar interface as ``requests``.\n\nMain Interface\n^^^^^^^^^^^^^^\n\n* responses.add(``Response`` or ``Response args``) - allows either to register ``Response`` object or directly\n  provide arguments of ``Response`` object. See `Response Parameters`_\n\n.. code-block:: python\n\n    import responses\n    import requests\n\n\n    @responses.activate\n    def test_simple():\n        # Register via 'Response' object\n        rsp1 = responses.Response(\n            method=\"PUT\",\n            url=\"http://example.com\",\n        )\n        responses.add(rsp1)\n        # register via direct arguments\n        responses.add(\n            responses.GET,\n            \"http://twitter.com/api/1/foobar\",\n            json={\"error\": \"not found\"},\n            status=404,\n        )\n\n        resp = requests.get(\"http://twitter.com/api/1/foobar\")\n        resp2 = requests.put(\"http://example.com\")\n\n        assert resp.json() == {\"error\": \"not found\"}\n        assert resp.status_code == 404\n\n        assert resp2.status_code == 200\n        assert resp2.request.method == \"PUT\"\n\n\nIf you attempt to fetch a url which doesn't hit a match, ``responses`` will raise\na ``ConnectionError``:\n\n.. code-block:: python\n\n    import responses\n    import requests\n\n    from requests.exceptions import ConnectionError\n\n\n    @responses.activate\n    def test_simple():\n        with pytest.raises(ConnectionError):\n            requests.get(\"http://twitter.com/api/1/foobar\")\n\n\nShortcuts\n^^^^^^^^^\n\nShortcuts provide a shorten version of ``responses.add()`` where method argument is prefilled\n\n* responses.delete(``Response args``) - register DELETE response\n* responses.get(``Response args``) - register GET response\n* responses.head(``Response args``) - register HEAD response\n* responses.options(``Response args``) - register OPTIONS response\n* responses.patch(``Response args``) - register PATCH response\n* responses.post(``Response args``) - register POST response\n* responses.put(``Response args``) - register PUT response\n\n.. code-block:: python\n\n    import responses\n    import requests\n\n\n    @responses.activate\n    def test_simple():\n        responses.get(\n            \"http://twitter.com/api/1/foobar\",\n            json={\"type\": \"get\"},\n        )\n\n        responses.post(\n            \"http://twitter.com/api/1/foobar\",\n            json={\"type\": \"post\"},\n        )\n\n        responses.patch(\n            \"http://twitter.com/api/1/foobar\",\n            json={\"type\": \"patch\"},\n        )\n\n        resp_get = requests.get(\"http://twitter.com/api/1/foobar\")\n        resp_post = requests.post(\"http://twitter.com/api/1/foobar\")\n        resp_patch = requests.patch(\"http://twitter.com/api/1/foobar\")\n\n        assert resp_get.json() == {\"type\": \"get\"}\n        assert resp_post.json() == {\"type\": \"post\"}\n        assert resp_patch.json() == {\"type\": \"patch\"}\n\nResponses as a context manager\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nInstead of wrapping the whole function with decorator you can use a context manager.\n\n.. code-block:: python\n\n    import responses\n    import requests\n\n\n    def test_my_api():\n        with responses.RequestsMock() as rsps:\n            rsps.add(\n                responses.GET,\n                \"http://twitter.com/api/1/foobar\",\n                body=\"{}\",\n                status=200,\n                content_type=\"application/json\",\n            )\n            resp = requests.get(\"http://twitter.com/api/1/foobar\")\n\n            assert resp.status_code == 200\n\n        # outside the context manager requests will hit the remote server\n        resp = requests.get(\"http://twitter.com/api/1/foobar\")\n        resp.status_code == 404\n\n\nResponse Parameters\n-------------------\n\nThe following attributes can be passed to a Response mock:\n\nmethod (``str``)\n    The HTTP method (GET, POST, etc).\n\nurl (``str`` or ``compiled regular expression``)\n    The full resource URL.\n\nmatch_querystring (``bool``)\n    DEPRECATED: Use ``responses.matchers.query_param_matcher`` or\n    ``responses.matchers.query_string_matcher``\n\n    Include the query string when matching requests.\n    Enabled by default if the response URL contains a query string,\n    disabled if it doesn't or the URL is a regular expression.\n\nbody (``str`` or ``BufferedReader`` or ``Exception``)\n    The response body. Read more `Exception as Response body`_\n\njson\n    A Python object representing the JSON response body. Automatically configures\n    the appropriate Content-Type.\n\nstatus (``int``)\n    The HTTP status code.\n\ncontent_type (``content_type``)\n    Defaults to ``text/plain``.\n\nheaders (``dict``)\n    Response headers.\n\nstream (``bool``)\n    DEPRECATED: use ``stream`` argument in request directly\n\nauto_calculate_content_length (``bool``)\n    Disabled by default. Automatically calculates the length of a supplied string or JSON body.\n\nmatch (``tuple``)\n    An iterable (``tuple`` is recommended) of callbacks to match requests\n    based on request attributes.\n    Current module provides multiple matchers that you can use to match:\n\n    * body contents in JSON format\n    * body contents in URL encoded data format\n    * request query parameters\n    * request query string (similar to query parameters but takes string as input)\n    * kwargs provided to request e.g. ``stream``, ``verify``\n    * 'multipart/form-data' content and headers in request\n    * request headers\n    * request fragment identifier\n\n    Alternatively user can create custom matcher.\n    Read more `Matching Requests`_\n\n\nException as Response body\n--------------------------\n\nYou can pass an ``Exception`` as the body to trigger an error on the request:\n\n.. code-block:: python\n\n    import responses\n    import requests\n\n\n    @responses.activate\n    def test_simple():\n        responses.get(\"http://twitter.com/api/1/foobar\", body=Exception(\"...\"))\n        with pytest.raises(Exception):\n            requests.get(\"http://twitter.com/api/1/foobar\")\n\n\nMatching Requests\n-----------------\n\nMatching Request Body Contents\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nWhen adding responses for endpoints that are sent request data you can add\nmatchers to ensure your code is sending the right parameters and provide\ndifferent responses based on the request body contents. ``responses`` provides\nmatchers for JSON and URL-encoded request bodies.\n\nURL-encoded data\n\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\n.. code-block:: python\n\n    import responses\n    import requests\n    from responses import matchers\n\n\n    @responses.activate\n    def test_calc_api():\n        responses.post(\n            url=\"http://calc.com/sum\",\n            body=\"4\",\n            match=[matchers.urlencoded_params_matcher({\"left\": \"1\", \"right\": \"3\"})],\n        )\n        requests.post(\"http://calc.com/sum\", data={\"left\": 1, \"right\": 3})\n\n\nJSON encoded data\n\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\nMatching JSON encoded data can be done with ``matchers.json_params_matcher()``.\n\n.. code-block:: python\n\n    import responses\n    import requests\n    from responses import matchers\n\n\n    @responses.activate\n    def test_calc_api():\n        responses.post(\n            url=\"http://example.com/\",\n            body=\"one\",\n            match=[\n                matchers.json_params_matcher({\"page\": {\"name\": \"first\", \"type\": \"json\"}})\n            ],\n        )\n        resp = requests.request(\n            \"POST\",\n            \"http://example.com/\",\n            headers={\"Content-Type\": \"application/json\"},\n            json={\"page\": {\"name\": \"first\", \"type\": \"json\"}},\n        )\n\n\nQuery Parameters Matcher\n^^^^^^^^^^^^^^^^^^^^^^^^\n\nQuery Parameters as a Dictionary\n\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\nYou can use the ``matchers.query_param_matcher`` function to match\nagainst the ``params`` request parameter. Just use the same dictionary as you\nwill use in ``params`` argument in ``request``.\n\nNote, do not use query parameters as part of the URL. Avoid using ``match_querystring``\ndeprecated argument.\n\n.. code-block:: python\n\n    import responses\n    import requests\n    from responses import matchers\n\n\n    @responses.activate\n    def test_calc_api():\n        url = \"http://example.com/test\"\n        params = {\"hello\": \"world\", \"I am\": \"a big test\"}\n        responses.get(\n            url=url,\n            body=\"test\",\n            match=[matchers.query_param_matcher(params)],\n        )\n\n        resp = requests.get(url, params=params)\n\n        constructed_url = r\"http://example.com/test?I+am=a+big+test&hello=world\"\n        assert resp.url == constructed_url\n        assert resp.request.url == constructed_url\n        assert resp.request.params == params\n\nBy default, matcher will validate that all parameters match strictly.\nTo validate that only parameters specified in the matcher are present in original request\nuse ``strict_match=False``.\n\nQuery Parameters as a String\n\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\nAs alternative, you can use query string value in ``matchers.query_string_matcher`` to match\nquery parameters in your request\n\n.. code-block:: python\n\n    import requests\n    import responses\n    from responses import matchers\n\n\n    @responses.activate\n    def my_func():\n        responses.get(\n            \"https://httpbin.org/get\",\n            match=[matchers.query_string_matcher(\"didi=pro&test=1\")],\n        )\n        resp = requests.get(\"https://httpbin.org/get\", params={\"test\": 1, \"didi\": \"pro\"})\n\n\n    my_func()\n\n\nRequest Keyword Arguments Matcher\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nTo validate request arguments use the ``matchers.request_kwargs_matcher`` function to match\nagainst the request kwargs.\n\nOnly following arguments are supported: ``timeout``, ``verify``, ``proxies``, ``stream``, ``cert``.\n\nNote, only arguments provided to ``matchers.request_kwargs_matcher`` will be validated.\n\n.. code-block:: python\n\n    import responses\n    import requests\n    from responses import matchers\n\n    with responses.RequestsMock(assert_all_requests_are_fired=False) as rsps:\n        req_kwargs = {\n            \"stream\": True,\n            \"verify\": False,\n        }\n        rsps.add(\n            \"GET\",\n            \"http://111.com\",\n            match=[matchers.request_kwargs_matcher(req_kwargs)],\n        )\n\n        requests.get(\"http://111.com\", stream=True)\n\n        # >>>  Arguments don't match: {stream: True, verify: True} doesn't match {stream: True, verify: False}\n\n\nRequest multipart/form-data Data Validation\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nTo validate request body and headers for ``multipart/form-data`` data you can use\n``matchers.multipart_matcher``. The ``data``, and ``files`` parameters provided will be compared\nto the request:\n\n.. code-block:: python\n\n    import requests\n    import responses\n    from responses.matchers import multipart_matcher\n\n\n    @responses.activate\n    def my_func():\n        req_data = {\"some\": \"other\", \"data\": \"fields\"}\n        req_files = {\"file_name\": b\"Old World!\"}\n        responses.post(\n            url=\"http://httpbin.org/post\",\n            match=[multipart_matcher(req_files, data=req_data)],\n        )\n        resp = requests.post(\"http://httpbin.org/post\", files={\"file_name\": b\"New World!\"})\n\n\n    my_func()\n    # >>> raises ConnectionError: multipart/form-data doesn't match. Request body differs.\n\nRequest Fragment Identifier Validation\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nTo validate request URL fragment identifier you can use ``matchers.fragment_identifier_matcher``.\nThe matcher takes fragment string (everything after ``#`` sign) as input for comparison:\n\n.. code-block:: python\n\n    import requests\n    import responses\n    from responses.matchers import fragment_identifier_matcher\n\n\n    @responses.activate\n    def run():\n        url = \"http://example.com?ab=xy&zed=qwe#test=1&foo=bar\"\n        responses.get(\n            url,\n            match=[fragment_identifier_matcher(\"test=1&foo=bar\")],\n            body=b\"test\",\n        )\n\n        # two requests to check reversed order of fragment identifier\n        resp = requests.get(\"http://example.com?ab=xy&zed=qwe#test=1&foo=bar\")\n        resp = requests.get(\"http://example.com?zed=qwe&ab=xy#foo=bar&test=1\")\n\n\n    run()\n\nRequest Headers Validation\n^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nWhen adding responses you can specify matchers to ensure that your code is\nsending the right headers and provide different responses based on the request\nheaders.\n\n.. code-block:: python\n\n    import responses\n    import requests\n    from responses import matchers\n\n\n    @responses.activate\n    def test_content_type():\n        responses.get(\n            url=\"http://example.com/\",\n            body=\"hello world\",\n            match=[matchers.header_matcher({\"Accept\": \"text/plain\"})],\n        )\n\n        responses.get(\n            url=\"http://example.com/\",\n            json={\"content\": \"hello world\"},\n            match=[matchers.header_matcher({\"Accept\": \"application/json\"})],\n        )\n\n        # request in reverse order to how they were added!\n        resp = requests.get(\"http://example.com/\", headers={\"Accept\": \"application/json\"})\n        assert resp.json() == {\"content\": \"hello world\"}\n\n        resp = requests.get(\"http://example.com/\", headers={\"Accept\": \"text/plain\"})\n        assert resp.text == \"hello world\"\n\nBecause ``requests`` will send several standard headers in addition to what was\nspecified by your code, request headers that are additional to the ones\npassed to the matcher are ignored by default. You can change this behaviour by\npassing ``strict_match=True`` to the matcher to ensure that only the headers\nthat you're expecting are sent and no others. Note that you will probably have\nto use a ``PreparedRequest`` in your code to ensure that ``requests`` doesn't\ninclude any additional headers.\n\n.. code-block:: python\n\n    import responses\n    import requests\n    from responses import matchers\n\n\n    @responses.activate\n    def test_content_type():\n        responses.get(\n            url=\"http://example.com/\",\n            body=\"hello world\",\n            match=[matchers.header_matcher({\"Accept\": \"text/plain\"}, strict_match=True)],\n        )\n\n        # this will fail because requests adds its own headers\n        with pytest.raises(ConnectionError):\n            requests.get(\"http://example.com/\", headers={\"Accept\": \"text/plain\"})\n\n        # a prepared request where you overwrite the headers before sending will work\n        session = requests.Session()\n        prepped = session.prepare_request(\n            requests.Request(\n                method=\"GET\",\n                url=\"http://example.com/\",\n            )\n        )\n        prepped.headers = {\"Accept\": \"text/plain\"}\n\n        resp = session.send(prepped)\n        assert resp.text == \"hello world\"\n\n\nCreating Custom Matcher\n^^^^^^^^^^^^^^^^^^^^^^^\n\nIf your application requires other encodings or different data validation you can build\nyour own matcher that returns ``Tuple[matches: bool, reason: str]``.\nWhere boolean represents ``True`` or ``False`` if the request parameters match and\nthe string is a reason in case of match failure. Your matcher can\nexpect a ``PreparedRequest`` parameter to be provided by ``responses``.\n\nNote, ``PreparedRequest`` is customized and has additional attributes ``params`` and ``req_kwargs``.\n\nResponse Registry\n---------------------------\n\nDefault Registry\n^^^^^^^^^^^^^^^^\n\nBy default, ``responses`` will search all registered ``Response`` objects and\nreturn a match. If only one ``Response`` is registered, the registry is kept unchanged.\nHowever, if multiple matches are found for the same request, then first match is returned and\nremoved from registry.\n\nOrdered Registry\n^^^^^^^^^^^^^^^^\n\nIn some scenarios it is important to preserve the order of the requests and responses.\nYou can use ``registries.OrderedRegistry`` to force all ``Response`` objects to be dependent\non the insertion order and invocation index.\nIn following example we add multiple ``Response`` objects that target the same URL. However,\nyou can see, that status code will depend on the invocation order.\n\n\n.. code-block:: python\n\n    import requests\n\n    import responses\n    from responses.registries import OrderedRegistry\n\n\n    @responses.activate(registry=OrderedRegistry)\n    def test_invocation_index():\n        responses.get(\n            \"http://twitter.com/api/1/foobar\",\n            json={\"msg\": \"not found\"},\n            status=404,\n        )\n        responses.get(\n            \"http://twitter.com/api/1/foobar\",\n            json={\"msg\": \"OK\"},\n            status=200,\n        )\n        responses.get(\n            \"http://twitter.com/api/1/foobar\",\n            json={\"msg\": \"OK\"},\n            status=200,\n        )\n        responses.get(\n            \"http://twitter.com/api/1/foobar\",\n            json={\"msg\": \"not found\"},\n            status=404,\n        )\n\n        resp = requests.get(\"http://twitter.com/api/1/foobar\")\n        assert resp.status_code == 404\n        resp = requests.get(\"http://twitter.com/api/1/foobar\")\n        assert resp.status_code == 200\n        resp = requests.get(\"http://twitter.com/api/1/foobar\")\n        assert resp.status_code == 200\n        resp = requests.get(\"http://twitter.com/api/1/foobar\")\n        assert resp.status_code == 404\n\n\nCustom Registry\n^^^^^^^^^^^^^^^\n\nBuilt-in ``registries`` are suitable for most of use cases, but to handle special conditions, you can\nimplement custom registry which must follow interface of ``registries.FirstMatchRegistry``.\nRedefining the ``find`` method will allow you to create custom search logic and return\nappropriate ``Response``\n\nExample that shows how to set custom registry\n\n.. code-block:: python\n\n    import responses\n    from responses import registries\n\n\n    class CustomRegistry(registries.FirstMatchRegistry):\n        pass\n\n\n    print(\"Before tests:\", responses.mock.get_registry())\n    \"\"\" Before tests: <responses.registries.FirstMatchRegistry object> \"\"\"\n\n\n    # using function decorator\n    @responses.activate(registry=CustomRegistry)\n    def run():\n        print(\"Within test:\", responses.mock.get_registry())\n        \"\"\" Within test: <__main__.CustomRegistry object> \"\"\"\n\n\n    run()\n\n    print(\"After test:\", responses.mock.get_registry())\n    \"\"\" After test: <responses.registries.FirstMatchRegistry object> \"\"\"\n\n    # using context manager\n    with responses.RequestsMock(registry=CustomRegistry) as rsps:\n        print(\"In context manager:\", rsps.get_registry())\n        \"\"\" In context manager: <__main__.CustomRegistry object> \"\"\"\n\n    print(\"After exit from context manager:\", responses.mock.get_registry())\n    \"\"\"\n    After exit from context manager: <responses.registries.FirstMatchRegistry object>\n    \"\"\"\n\nDynamic Responses\n-----------------\n\nYou can utilize callbacks to provide dynamic responses. The callback must return\na tuple of (``status``, ``headers``, ``body``).\n\n.. code-block:: python\n\n    import json\n\n    import responses\n    import requests\n\n\n    @responses.activate\n    def test_calc_api():\n        def request_callback(request):\n            payload = json.loads(request.body)\n            resp_body = {\"value\": sum(payload[\"numbers\"])}\n            headers = {\"request-id\": \"728d329e-0e86-11e4-a748-0c84dc037c13\"}\n            return (200, headers, json.dumps(resp_body))\n\n        responses.add_callback(\n            responses.POST,\n            \"http://calc.com/sum\",\n            callback=request_callback,\n            content_type=\"application/json\",\n        )\n\n        resp = requests.post(\n            \"http://calc.com/sum\",\n            json.dumps({\"numbers\": [1, 2, 3]}),\n            headers={\"content-type\": \"application/json\"},\n        )\n\n        assert resp.json() == {\"value\": 6}\n\n        assert len(responses.calls) == 1\n        assert responses.calls[0].request.url == \"http://calc.com/sum\"\n        assert responses.calls[0].response.text == '{\"value\": 6}'\n        assert (\n            responses.calls[0].response.headers[\"request-id\"]\n            == \"728d329e-0e86-11e4-a748-0c84dc037c13\"\n        )\n\nYou can also pass a compiled regex to ``add_callback`` to match multiple urls:\n\n.. code-block:: python\n\n    import re, json\n\n    from functools import reduce\n\n    import responses\n    import requests\n\n    operators = {\n        \"sum\": lambda x, y: x + y,\n        \"prod\": lambda x, y: x * y,\n        \"pow\": lambda x, y: x**y,\n    }\n\n\n    @responses.activate\n    def test_regex_url():\n        def request_callback(request):\n            payload = json.loads(request.body)\n            operator_name = request.path_url[1:]\n\n            operator = operators[operator_name]\n\n            resp_body = {\"value\": reduce(operator, payload[\"numbers\"])}\n            headers = {\"request-id\": \"728d329e-0e86-11e4-a748-0c84dc037c13\"}\n            return (200, headers, json.dumps(resp_body))\n\n        responses.add_callback(\n            responses.POST,\n            re.compile(\"http://calc.com/(sum|prod|pow|unsupported)\"),\n            callback=request_callback,\n            content_type=\"application/json\",\n        )\n\n        resp = requests.post(\n            \"http://calc.com/prod\",\n            json.dumps({\"numbers\": [2, 3, 4]}),\n            headers={\"content-type\": \"application/json\"},\n        )\n        assert resp.json() == {\"value\": 24}\n\n\n    test_regex_url()\n\n\nIf you want to pass extra keyword arguments to the callback function, for example when reusing\na callback function to give a slightly different result, you can use ``functools.partial``:\n\n.. code-block:: python\n\n    from functools import partial\n\n\n    def request_callback(request, id=None):\n        payload = json.loads(request.body)\n        resp_body = {\"value\": sum(payload[\"numbers\"])}\n        headers = {\"request-id\": id}\n        return (200, headers, json.dumps(resp_body))\n\n\n    responses.add_callback(\n        responses.POST,\n        \"http://calc.com/sum\",\n        callback=partial(request_callback, id=\"728d329e-0e86-11e4-a748-0c84dc037c13\"),\n        content_type=\"application/json\",\n    )\n\n\nIntegration with unit test frameworks\n-------------------------------------\n\nResponses as a ``pytest`` fixture\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nUse the pytest-responses package to export ``responses`` as a pytest fixture.\n\n``pip install pytest-responses``\n\nYou can then access it in a pytest script using:\n\n.. code-block:: python\n\n    import pytest_responses\n\n\n    def test_api(responses):\n        responses.get(\n            \"http://twitter.com/api/1/foobar\",\n            body=\"{}\",\n            status=200,\n            content_type=\"application/json\",\n        )\n        resp = requests.get(\"http://twitter.com/api/1/foobar\")\n        assert resp.status_code == 200\n\nAdd default responses for each test\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nWhen run with ``unittest`` tests, this can be used to set up some\ngeneric class-level responses, that may be complemented by each test.\nSimilar interface could be applied in ``pytest`` framework.\n\n.. code-block:: python\n\n    class TestMyApi(unittest.TestCase):\n        def setUp(self):\n            responses.get(\"https://example.com\", body=\"within setup\")\n            # here go other self.responses.add(...)\n\n        @responses.activate\n        def test_my_func(self):\n            responses.get(\n                \"https://httpbin.org/get\",\n                match=[matchers.query_param_matcher({\"test\": \"1\", \"didi\": \"pro\"})],\n                body=\"within test\",\n            )\n            resp = requests.get(\"https://example.com\")\n            resp2 = requests.get(\n                \"https://httpbin.org/get\", params={\"test\": \"1\", \"didi\": \"pro\"}\n            )\n            print(resp.text)\n            # >>> within setup\n            print(resp2.text)\n            # >>> within test\n\n\nRequestMock methods: start, stop, reset\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n``responses`` has ``start``, ``stop``, ``reset`` methods very analogous to\n`unittest.mock.patch <https://docs.python.org/3/library/unittest.mock.html#patch-methods-start-and-stop>`_.\nThese make it simpler to do requests mocking in ``setup`` methods or where\nyou want to do multiple patches without nesting decorators or with statements.\n\n.. code-block:: python\n\n    class TestUnitTestPatchSetup:\n        def setup(self):\n            \"\"\"Creates ``RequestsMock`` instance and starts it.\"\"\"\n            self.r_mock = responses.RequestsMock(assert_all_requests_are_fired=True)\n            self.r_mock.start()\n\n            # optionally some default responses could be registered\n            self.r_mock.get(\"https://example.com\", status=505)\n            self.r_mock.put(\"https://example.com\", status=506)\n\n        def teardown(self):\n            \"\"\"Stops and resets RequestsMock instance.\n\n            If ``assert_all_requests_are_fired`` is set to ``True``, will raise an error\n            if some requests were not processed.\n            \"\"\"\n            self.r_mock.stop()\n            self.r_mock.reset()\n\n        def test_function(self):\n            resp = requests.get(\"https://example.com\")\n            assert resp.status_code == 505\n\n            resp = requests.put(\"https://example.com\")\n            assert resp.status_code == 506\n\n\nAssertions on declared responses\n--------------------------------\n\nWhen used as a context manager, Responses will, by default, raise an assertion\nerror if a url was registered but not accessed. This can be disabled by passing\nthe ``assert_all_requests_are_fired`` value:\n\n.. code-block:: python\n\n    import responses\n    import requests\n\n\n    def test_my_api():\n        with responses.RequestsMock(assert_all_requests_are_fired=False) as rsps:\n            rsps.add(\n                responses.GET,\n                \"http://twitter.com/api/1/foobar\",\n                body=\"{}\",\n                status=200,\n                content_type=\"application/json\",\n            )\n\nAssert Request Call Count\n-------------------------\n\nAssert based on ``Response`` object\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nEach ``Response`` object has ``call_count`` attribute that could be inspected\nto check how many times each request was matched.\n\n.. code-block:: python\n\n    @responses.activate\n    def test_call_count_with_matcher():\n        rsp = responses.get(\n            \"http://www.example.com\",\n            match=(matchers.query_param_matcher({}),),\n        )\n        rsp2 = responses.get(\n            \"http://www.example.com\",\n            match=(matchers.query_param_matcher({\"hello\": \"world\"}),),\n            status=777,\n        )\n        requests.get(\"http://www.example.com\")\n        resp1 = requests.get(\"http://www.example.com\")\n        requests.get(\"http://www.example.com?hello=world\")\n        resp2 = requests.get(\"http://www.example.com?hello=world\")\n\n        assert resp1.status_code == 200\n        assert resp2.status_code == 777\n\n        assert rsp.call_count == 2\n        assert rsp2.call_count == 2\n\nAssert based on the exact URL\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAssert that the request was called exactly n times.\n\n.. code-block:: python\n\n    import responses\n    import requests\n\n\n    @responses.activate\n    def test_assert_call_count():\n        responses.get(\"http://example.com\")\n\n        requests.get(\"http://example.com\")\n        assert responses.assert_call_count(\"http://example.com\", 1) is True\n\n        requests.get(\"http://example.com\")\n        with pytest.raises(AssertionError) as excinfo:\n            responses.assert_call_count(\"http://example.com\", 1)\n        assert (\n            \"Expected URL 'http://example.com' to be called 1 times. Called 2 times.\"\n            in str(excinfo.value)\n        )\n\n\n    @responses.activate\n    def test_assert_call_count_always_match_qs():\n        responses.get(\"http://www.example.com\")\n        requests.get(\"http://www.example.com\")\n        requests.get(\"http://www.example.com?hello=world\")\n\n        # One call on each url, querystring is matched by default\n        responses.assert_call_count(\"http://www.example.com\", 1) is True\n        responses.assert_call_count(\"http://www.example.com?hello=world\", 1) is True\n\n\nAssert Request Calls data\n-------------------------\n\n``Request`` object has ``calls`` list which elements correspond to ``Call`` objects\nin the global list of ``Registry``. This can be useful when the order of requests is not\nguaranteed, but you need to check their correctness, for example in multithreaded\napplications.\n\n.. code-block:: python\n\n    import concurrent.futures\n    import responses\n    import requests\n\n\n    @responses.activate\n    def test_assert_calls_on_resp():\n        rsp1 = responses.patch(\"http://www.foo.bar/1/\", status=200)\n        rsp2 = responses.patch(\"http://www.foo.bar/2/\", status=400)\n        rsp3 = responses.patch(\"http://www.foo.bar/3/\", status=200)\n\n        def update_user(uid, is_active):\n            url = f\"http://www.foo.bar/{uid}/\"\n            response = requests.patch(url, json={\"is_active\": is_active})\n            return response\n\n        with concurrent.futures.ThreadPoolExecutor(max_workers=3) as executor:\n            future_to_uid = {\n                executor.submit(update_user, uid, is_active): uid\n                for (uid, is_active) in [(\"3\", True), (\"2\", True), (\"1\", False)]\n            }\n            for future in concurrent.futures.as_completed(future_to_uid):\n                uid = future_to_uid[future]\n                response = future.result()\n                print(f\"{uid} updated with {response.status_code} status code\")\n\n        assert len(responses.calls) == 3  # total calls count\n\n        assert rsp1.call_count == 1\n        assert rsp1.calls[0] in responses.calls\n        assert rsp1.calls[0].response.status_code == 200\n        assert json.loads(rsp1.calls[0].request.body) == {\"is_active\": False}\n\n        assert rsp2.call_count == 1\n        assert rsp2.calls[0] in responses.calls\n        assert rsp2.calls[0].response.status_code == 400\n        assert json.loads(rsp2.calls[0].request.body) == {\"is_active\": True}\n\n        assert rsp3.call_count == 1\n        assert rsp3.calls[0] in responses.calls\n        assert rsp3.calls[0].response.status_code == 200\n        assert json.loads(rsp3.calls[0].request.body) == {\"is_active\": True}\n\nMultiple Responses\n------------------\n\nYou can also add multiple responses for the same url:\n\n.. code-block:: python\n\n    import responses\n    import requests\n\n\n    @responses.activate\n    def test_my_api():\n        responses.get(\"http://twitter.com/api/1/foobar\", status=500)\n        responses.get(\n            \"http://twitter.com/api/1/foobar\",\n            body=\"{}\",\n            status=200,\n            content_type=\"application/json\",\n        )\n\n        resp = requests.get(\"http://twitter.com/api/1/foobar\")\n        assert resp.status_code == 500\n        resp = requests.get(\"http://twitter.com/api/1/foobar\")\n        assert resp.status_code == 200\n\n\nURL Redirection\n---------------\n\nIn the following example you can see how to create a redirection chain and add custom exception that will be raised\nin the execution chain and contain the history of redirects.\n\n..  code-block::\n\n    A -> 301 redirect -> B\n    B -> 301 redirect -> C\n    C -> connection issue\n\n.. code-block:: python\n\n    import pytest\n    import requests\n\n    import responses\n\n\n    @responses.activate\n    def test_redirect():\n        # create multiple Response objects where first two contain redirect headers\n        rsp1 = responses.Response(\n            responses.GET,\n            \"http://example.com/1\",\n            status=301,\n            headers={\"Location\": \"http://example.com/2\"},\n        )\n        rsp2 = responses.Response(\n            responses.GET,\n            \"http://example.com/2\",\n            status=301,\n            headers={\"Location\": \"http://example.com/3\"},\n        )\n        rsp3 = responses.Response(responses.GET, \"http://example.com/3\", status=200)\n\n        # register above generated Responses in ``response`` module\n        responses.add(rsp1)\n        responses.add(rsp2)\n        responses.add(rsp3)\n\n        # do the first request in order to generate genuine ``requests`` response\n        # this object will contain genuine attributes of the response, like ``history``\n        rsp = requests.get(\"http://example.com/1\")\n        responses.calls.reset()\n\n        # customize exception with ``response`` attribute\n        my_error = requests.ConnectionError(\"custom error\")\n        my_error.response = rsp\n\n        # update body of the 3rd response with Exception, this will be raised during execution\n        rsp3.body = my_error\n\n        with pytest.raises(requests.ConnectionError) as exc_info:\n            requests.get(\"http://example.com/1\")\n\n        assert exc_info.value.args[0] == \"custom error\"\n        assert rsp1.url in exc_info.value.response.history[0].url\n        assert rsp2.url in exc_info.value.response.history[1].url\n\n\nValidate ``Retry`` mechanism\n----------------------------\n\nIf you are using the ``Retry`` features of ``urllib3`` and want to cover scenarios that test your retry limits, you can test those scenarios with ``responses`` as well. The best approach will be to use an `Ordered Registry`_\n\n.. code-block:: python\n\n    import requests\n\n    import responses\n    from responses import registries\n    from urllib3.util import Retry\n\n\n    @responses.activate(registry=registries.OrderedRegistry)\n    def test_max_retries():\n        url = \"https://example.com\"\n        rsp1 = responses.get(url, body=\"Error\", status=500)\n        rsp2 = responses.get(url, body=\"Error\", status=500)\n        rsp3 = responses.get(url, body=\"Error\", status=500)\n        rsp4 = responses.get(url, body=\"OK\", status=200)\n\n        session = requests.Session()\n\n        adapter = requests.adapters.HTTPAdapter(\n            max_retries=Retry(\n                total=4,\n                backoff_factor=0.1,\n                status_forcelist=[500],\n                method_whitelist=[\"GET\", \"POST\", \"PATCH\"],\n            )\n        )\n        session.mount(\"https://\", adapter)\n\n        resp = session.get(url)\n\n        assert resp.status_code == 200\n        assert rsp1.call_count == 1\n        assert rsp2.call_count == 1\n        assert rsp3.call_count == 1\n        assert rsp4.call_count == 1\n\n\nUsing a callback to modify the response\n---------------------------------------\n\nIf you use customized processing in ``requests`` via subclassing/mixins, or if you\nhave library tools that interact with ``requests`` at a low level, you may need\nto add extended processing to the mocked Response object to fully simulate the\nenvironment for your tests.  A ``response_callback`` can be used, which will be\nwrapped by the library before being returned to the caller.  The callback\naccepts a ``response`` as it's single argument, and is expected to return a\nsingle ``response`` object.\n\n.. code-block:: python\n\n    import responses\n    import requests\n\n\n    def response_callback(resp):\n        resp.callback_processed = True\n        return resp\n\n\n    with responses.RequestsMock(response_callback=response_callback) as m:\n        m.add(responses.GET, \"http://example.com\", body=b\"test\")\n        resp = requests.get(\"http://example.com\")\n        assert resp.text == \"test\"\n        assert hasattr(resp, \"callback_processed\")\n        assert resp.callback_processed is True\n\n\nPassing through real requests\n-----------------------------\n\nIn some cases you may wish to allow for certain requests to pass through responses\nand hit a real server. This can be done with the ``add_passthru`` methods:\n\n.. code-block:: python\n\n    import responses\n\n\n    @responses.activate\n    def test_my_api():\n        responses.add_passthru(\"https://percy.io\")\n\nThis will allow any requests matching that prefix, that is otherwise not\nregistered as a mock response, to passthru using the standard behavior.\n\nPass through endpoints can be configured with regex patterns if you\nneed to allow an entire domain or path subtree to send requests:\n\n.. code-block:: python\n\n    responses.add_passthru(re.compile(\"https://percy.io/\\\\w+\"))\n\n\nLastly, you can use the ``passthrough`` argument of the ``Response`` object\nto force a response to behave as a pass through.\n\n.. code-block:: python\n\n    # Enable passthrough for a single response\n    response = Response(\n        responses.GET,\n        \"http://example.com\",\n        body=\"not used\",\n        passthrough=True,\n    )\n    responses.add(response)\n\n    # Use PassthroughResponse\n    response = PassthroughResponse(responses.GET, \"http://example.com\")\n    responses.add(response)\n\nViewing/Modifying registered responses\n--------------------------------------\n\nRegistered responses are available as a public method of the RequestMock\ninstance. It is sometimes useful for debugging purposes to view the stack of\nregistered responses which can be accessed via ``responses.registered()``.\n\nThe ``replace`` function allows a previously registered ``response`` to be\nchanged. The method signature is identical to ``add``. ``response`` s are\nidentified using ``method`` and ``url``. Only the first matched ``response`` is\nreplaced.\n\n.. code-block:: python\n\n    import responses\n    import requests\n\n\n    @responses.activate\n    def test_replace():\n        responses.get(\"http://example.org\", json={\"data\": 1})\n        responses.replace(responses.GET, \"http://example.org\", json={\"data\": 2})\n\n        resp = requests.get(\"http://example.org\")\n\n        assert resp.json() == {\"data\": 2}\n\n\nThe ``upsert`` function allows a previously registered ``response`` to be\nchanged like ``replace``. If the response is registered, the ``upsert`` function\nwill registered it like ``add``.\n\n``remove`` takes a ``method`` and ``url`` argument and will remove **all**\nmatched responses from the registered list.\n\nFinally, ``reset`` will reset all registered responses.\n\nCoroutines and Multithreading\n-----------------------------\n\n``responses`` supports both Coroutines and Multithreading out of the box.\nNote, ``responses`` locks threading on ``RequestMock`` object allowing only\nsingle thread to access it.\n\n.. code-block:: python\n\n    async def test_async_calls():\n        @responses.activate\n        async def run():\n            responses.get(\n                \"http://twitter.com/api/1/foobar\",\n                json={\"error\": \"not found\"},\n                status=404,\n            )\n\n            resp = requests.get(\"http://twitter.com/api/1/foobar\")\n            assert resp.json() == {\"error\": \"not found\"}\n            assert responses.calls[0].request.url == \"http://twitter.com/api/1/foobar\"\n\n        await run()\n\nBETA Features\n-------------\nBelow you can find a list of BETA features. Although we will try to keep the API backwards compatible\nwith released version, we reserve the right to change these APIs before they are considered stable. Please share your feedback via\n`GitHub Issues <https://github.com/getsentry/responses/issues>`_.\n\nRecord Responses to files\n^^^^^^^^^^^^^^^^^^^^^^^^^\n\nYou can perform real requests to the server and ``responses`` will automatically record the output to the\nfile. Recorded data is stored in `YAML <https://yaml.org>`_ format.\n\nApply ``@responses._recorder.record(file_path=\"out.yaml\")`` decorator to any function where you perform\nrequests to record responses to ``out.yaml`` file.\n\nFollowing code\n\n.. code-block:: python\n\n    import requests\n    from responses import _recorder\n\n\n    def another():\n        rsp = requests.get(\"https://httpstat.us/500\")\n        rsp = requests.get(\"https://httpstat.us/202\")\n\n\n    @_recorder.record(file_path=\"out.yaml\")\n    def test_recorder():\n        rsp = requests.get(\"https://httpstat.us/404\")\n        rsp = requests.get(\"https://httpbin.org/status/wrong\")\n        another()\n\nwill produce next output:\n\n.. code-block:: yaml\n\n    responses:\n    - response:\n        auto_calculate_content_length: false\n        body: 404 Not Found\n        content_type: text/plain\n        method: GET\n        status: 404\n        url: https://httpstat.us/404\n    - response:\n        auto_calculate_content_length: false\n        body: Invalid status code\n        content_type: text/plain\n        method: GET\n        status: 400\n        url: https://httpbin.org/status/wrong\n    - response:\n        auto_calculate_content_length: false\n        body: 500 Internal Server Error\n        content_type: text/plain\n        method: GET\n        status: 500\n        url: https://httpstat.us/500\n    - response:\n        auto_calculate_content_length: false\n        body: 202 Accepted\n        content_type: text/plain\n        method: GET\n        status: 202\n        url: https://httpstat.us/202\n\nIf you are in the REPL, you can also activete the recorder for all following responses:\n\n.. code-block:: python\n\n    import requests\n    from responses import _recorder\n\n    _recorder.recorder.start()\n\n    requests.get(\"https://httpstat.us/500\")\n\n    _recorder.recorder.dump_to_file(\"out.yaml\")\n\n    # you can stop or reset the recorder\n    _recorder.recorder.stop()\n    _recorder.recorder.reset()\n\nReplay responses (populate registry) from files\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nYou can populate your active registry from a ``yaml`` file with recorded responses.\n(See `Record Responses to files`_ to understand how to obtain a file).\nTo do that you need to execute ``responses._add_from_file(file_path=\"out.yaml\")`` within\nan activated decorator or a context manager.\n\nThe following code example registers a ``patch`` response, then all responses present in\n``out.yaml`` file and a ``post`` response at the end.\n\n.. code-block:: python\n\n    import responses\n\n\n    @responses.activate\n    def run():\n        responses.patch(\"http://httpbin.org\")\n        responses._add_from_file(file_path=\"out.yaml\")\n        responses.post(\"http://httpbin.org/form\")\n\n\n    run()\n\n\nContributing\n------------\n\nEnvironment Configuration\n^^^^^^^^^^^^^^^^^^^^^^^^^\n\nResponses uses several linting and autoformatting utilities, so it's important that when\nsubmitting patches you use the appropriate toolchain:\n\nClone the repository:\n\n.. code-block:: shell\n\n    git clone https://github.com/getsentry/responses.git\n\nCreate an environment (e.g. with ``virtualenv``):\n\n.. code-block:: shell\n\n    virtualenv .env && source .env/bin/activate\n\nConfigure development requirements:\n\n.. code-block:: shell\n\n    make develop\n\n\nTests and Code Quality Validation\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThe easiest way to validate your code is to run tests via ``tox``.\nCurrent ``tox`` configuration runs the same checks that are used in\nGitHub Actions CI/CD pipeline.\n\nPlease execute the following command line from the project root to validate\nyour code against:\n\n* Unit tests in all Python versions that are supported by this project\n* Type validation via ``mypy``\n* All ``pre-commit`` hooks\n\n.. code-block:: shell\n\n    tox\n\nAlternatively, you can always run a single test. See documentation below.\n\nUnit tests\n\"\"\"\"\"\"\"\"\"\"\n\nResponses uses `Pytest <https://docs.pytest.org/en/latest/>`_ for\ntesting. You can run all tests by:\n\n.. code-block:: shell\n\n    tox -e py37\n    tox -e py310\n\nOR manually activate required version of Python and run\n\n.. code-block:: shell\n\n    pytest\n\nAnd run a single test by:\n\n.. code-block:: shell\n\n    pytest -k '<test_function_name>'\n\nType Validation\n\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\nTo verify ``type`` compliance, run `mypy <https://github.com/python/mypy>`_ linter:\n\n.. code-block:: shell\n\n    tox -e mypy\n\nOR\n\n.. code-block:: shell\n\n    mypy --config-file=./mypy.ini -p responses\n\nCode Quality and Style\n\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\nTo check code style and reformat it run:\n\n.. code-block:: shell\n\n    tox -e precom\n\nOR\n\n.. code-block:: shell\n\n    pre-commit run --all-files\n"
        },
        {
          "name": "mypy.ini",
          "type": "blob",
          "size": 0.6806640625,
          "content": "[mypy]\nshow_column_numbers=True\nshow_error_codes = True\n\ndisallow_any_unimported=False\ndisallow_any_expr=False\ndisallow_any_decorated=True\ndisallow_any_explicit=False\ndisallow_any_generics=True\ndisallow_subclassing_any=True\n\ndisallow_untyped_calls=True\ndisallow_untyped_defs=True\ndisallow_incomplete_defs=True\ncheck_untyped_defs=True\ndisallow_untyped_decorators=True\n\nno_implicit_optional=True\nstrict_optional=True\n\nwarn_redundant_casts=True\nwarn_unused_ignores=True\nwarn_no_return=True\nwarn_return_any=False\nwarn_unreachable=False\n\nstrict_equality=True\nignore_missing_imports=True\n\n[mypy-responses.tests.*]\ndisallow_untyped_calls=False\ndisallow_untyped_defs=False\ndisable_error_code = union-attr\n"
        },
        {
          "name": "pyproject.toml",
          "type": "blob",
          "size": 0.2236328125,
          "content": "[build-system]\n# Suggest a reasonably modern floor for setuptools to ensure\n# the source dist package is assembled with all the expected resources.\nrequires = [\"setuptools >= 60\", \"wheel\"]\nbuild-backend = \"setuptools.build_meta\"\n"
        },
        {
          "name": "responses",
          "type": "tree",
          "content": null
        },
        {
          "name": "scripts",
          "type": "tree",
          "content": null
        },
        {
          "name": "setup.py",
          "type": "blob",
          "size": 1.9814453125,
          "content": "#!/usr/bin/env python\n\"\"\"\nresponses\n=========\n\nA utility library for mocking out the `requests` Python library.\n\n:copyright: (c) 2015 David Cramer\n:license: Apache 2.0\n\"\"\"\n\nfrom setuptools import setup\n\ninstall_requires = [\n    \"requests>=2.30.0,<3.0\",\n    \"urllib3>=1.25.10,<3.0\",\n    \"pyyaml\",\n]\n\ntests_require = [\n    \"pytest>=7.0.0\",\n    \"coverage >= 6.0.0\",\n    \"pytest-cov\",\n    \"pytest-asyncio\",\n    \"pytest-httpserver\",\n    \"flake8\",\n    \"types-PyYAML\",\n    \"types-requests\",\n    \"mypy\",\n    # for check of different parsers in recorder\n    \"tomli; python_version < '3.11'\",\n    \"tomli-w\",\n]\n\nextras_require = {\"tests\": tests_require}\n\nsetup(\n    name=\"responses\",\n    version=\"0.25.5\",\n    author=\"David Cramer\",\n    description=\"A utility library for mocking out the `requests` Python library.\",\n    url=\"https://github.com/getsentry/responses\",\n    project_urls={\n        \"Bug Tracker\": \"https://github.com/getsentry/responses/issues\",\n        \"Changes\": \"https://github.com/getsentry/responses/blob/master/CHANGES\",\n        \"Documentation\": \"https://github.com/getsentry/responses/blob/master/README.rst\",\n        \"Source Code\": \"https://github.com/getsentry/responses\",\n    },\n    license=\"Apache 2.0\",\n    long_description=open(\"README.rst\", encoding=\"utf-8\").read(),\n    long_description_content_type=\"text/x-rst\",\n    packages=[\"responses\"],\n    zip_safe=False,\n    python_requires=\">=3.8\",\n    install_requires=install_requires,\n    extras_require=extras_require,\n    classifiers=[\n        \"Intended Audience :: Developers\",\n        \"Intended Audience :: System Administrators\",\n        \"Operating System :: OS Independent\",\n        \"Programming Language :: Python\",\n        \"Programming Language :: Python :: 3\",\n        \"Programming Language :: Python :: 3.8\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n        \"Programming Language :: Python :: 3.11\",\n        \"Programming Language :: Python :: 3.12\",\n        \"Topic :: Software Development\",\n    ],\n)\n"
        },
        {
          "name": "tox.ini",
          "type": "blob",
          "size": 0.6767578125,
          "content": "[tox]\nenvlist = py38,py39,py310,py311,py312,mypy,precom\n\n[pytest]\nfilterwarnings =\n    error\n    default::DeprecationWarning\n\n[testenv]\nextras = tests\ncommands =\n    pytest . --asyncio-mode=auto --cov responses --cov-report term-missing {posargs}\n\n\n[testenv:mypy]\ndescription = Check types using 'mypy'\nbasepython = python3.10\ncommands =\n    python -m mypy --config-file=mypy.ini -p responses\n    # see https://github.com/getsentry/responses/issues/556\n    python -m mypy --config-file=mypy.ini --namespace-packages -p responses\n\n[testenv:precom]\ndescription = Run pre-commit hooks (black, flake, etc)\nbasepython = python3.10\ndeps = pre-commit>=2.9.2\ncommands =\n    pre-commit run --all-files\n"
        }
      ]
    }
  ]
}