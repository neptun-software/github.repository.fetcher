{
  "metadata": {
    "timestamp": 1736559517541,
    "page": 104,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjExMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "jcjohnson/pytorch-examples",
      "stars": 4732,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.005859375,
          "content": "*.swp\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0458984375,
          "content": "MIT License\n\nCopyright (c) 2017 Justin Johnson\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 27.22265625,
          "content": "This repository introduces the fundamental concepts of\n[PyTorch](https://github.com/pytorch/pytorch)\nthrough self-contained examples.\n\nAt its core, PyTorch provides two main features:\n- An n-dimensional Tensor, similar to numpy but can run on GPUs\n- Automatic differentiation for building and training neural networks\n\nWe will use a fully-connected ReLU network as our running example. The network\nwill have a single hidden layer, and will be trained with gradient descent to\nfit random data by minimizing the Euclidean distance between the network output\nand the true output.\n\n**NOTE:** These examples have been update for PyTorch 0.4, which made several\nmajor changes to the core PyTorch API. Most notably, prior to 0.4 Tensors had\nto be wrapped in Variable objects to use autograd; this functionality has now\nbeen added directly to Tensors, and Variables are now deprecated.\n\n### Table of Contents\n- <a href='#warm-up-numpy'>Warm-up: numpy</a>\n- <a href='#pytorch-tensors'>PyTorch: Tensors</a>\n- <a href='#pytorch-autograd'>PyTorch: Autograd</a>\n- <a href='#pytorch-defining-new-autograd-functions'>PyTorch: Defining new autograd functions</a>\n- <a href='#tensorflow-static-graphs'>TensorFlow: Static Graphs</a>\n- <a href='#pytorch-nn'>PyTorch: nn</a>\n- <a href='#pytorch-optim'>PyTorch: optim</a>\n- <a href='#pytorch-custom-nn-modules'>PyTorch: Custom nn Modules</a>\n- <a href='#pytorch-control-flow--weight-sharing'>PyTorch: Control Flow and Weight Sharing</a>\n\n## Warm-up: numpy\n\nBefore introducing PyTorch, we will first implement the network using numpy.\n\nNumpy provides an n-dimensional array object, and many functions for manipulating\nthese arrays. Numpy is a generic framework for scientific computing; it does not\nknow anything about computation graphs, or deep learning, or gradients. However\nwe can easily use numpy to fit a two-layer network to random data by manually\nimplementing the forward and backward passes through the network using numpy\noperations:\n\n```python\n# Code in file tensor/two_layer_net_numpy.py\nimport numpy as np\n\n# N is batch size; D_in is input dimension;\n# H is hidden dimension; D_out is output dimension.\nN, D_in, H, D_out = 64, 1000, 100, 10\n\n# Create random input and output data\nx = np.random.randn(N, D_in)\ny = np.random.randn(N, D_out)\n\n# Randomly initialize weights\nw1 = np.random.randn(D_in, H)\nw2 = np.random.randn(H, D_out)\n\nlearning_rate = 1e-6\nfor t in range(500):\n  # Forward pass: compute predicted y\n  h = x.dot(w1)\n  h_relu = np.maximum(h, 0)\n  y_pred = h_relu.dot(w2)\n  \n  # Compute and print loss\n  loss = np.square(y_pred - y).sum()\n  print(t, loss)\n  \n  # Backprop to compute gradients of w1 and w2 with respect to loss\n  grad_y_pred = 2.0 * (y_pred - y)\n  grad_w2 = h_relu.T.dot(grad_y_pred)\n  grad_h_relu = grad_y_pred.dot(w2.T)\n  grad_h = grad_h_relu.copy()\n  grad_h[h < 0] = 0\n  grad_w1 = x.T.dot(grad_h)\n \n  # Update weights\n  w1 -= learning_rate * grad_w1\n  w2 -= learning_rate * grad_w2\n```\n\n## PyTorch: Tensors\n\nNumpy is a great framework, but it cannot utilize GPUs to accelerate its\nnumerical computations. For modern deep neural networks, GPUs often provide\nspeedups of [50x or greater](https://github.com/jcjohnson/cnn-benchmarks), so\nunfortunately numpy won't be enough for modern deep learning.\n\nHere we introduce the most fundamental PyTorch concept: the **Tensor**. A PyTorch\nTensor is conceptually identical to a numpy array: a Tensor is an n-dimensional\narray, and PyTorch provides many functions for operating on these Tensors.\nAny computation you might want to perform with numpy can also be accomplished\nwith PyTorch Tensors; you should think of them as a generic tool for scientific\ncomputing.\n\nHowever unlike numpy, PyTorch Tensors can utilize GPUs to accelerate their\nnumeric computations. To run a PyTorch Tensor on GPU, you use the `device`\nargument when constructing a Tensor to place the Tensor on a GPU.\n\nHere we use PyTorch Tensors to fit a two-layer network to random data. Like the\nnumpy example above we manually implement the forward and backward\npasses through the network, using operations on PyTorch Tensors:\n\n```python\n# Code in file tensor/two_layer_net_tensor.py\nimport torch\n\ndevice = torch.device('cpu')\n# device = torch.device('cuda') # Uncomment this to run on GPU\n\n# N is batch size; D_in is input dimension;\n# H is hidden dimension; D_out is output dimension.\nN, D_in, H, D_out = 64, 1000, 100, 10\n\n# Create random input and output data\nx = torch.randn(N, D_in, device=device)\ny = torch.randn(N, D_out, device=device)\n\n# Randomly initialize weights\nw1 = torch.randn(D_in, H, device=device)\nw2 = torch.randn(H, D_out, device=device)\n\nlearning_rate = 1e-6\nfor t in range(500):\n  # Forward pass: compute predicted y\n  h = x.mm(w1)\n  h_relu = h.clamp(min=0)\n  y_pred = h_relu.mm(w2)\n\n  # Compute and print loss; loss is a scalar, and is stored in a PyTorch Tensor\n  # of shape (); we can get its value as a Python number with loss.item().\n  loss = (y_pred - y).pow(2).sum()\n  print(t, loss.item())\n\n  # Backprop to compute gradients of w1 and w2 with respect to loss\n  grad_y_pred = 2.0 * (y_pred - y)\n  grad_w2 = h_relu.t().mm(grad_y_pred)\n  grad_h_relu = grad_y_pred.mm(w2.t())\n  grad_h = grad_h_relu.clone()\n  grad_h[h < 0] = 0\n  grad_w1 = x.t().mm(grad_h)\n\n  # Update weights using gradient descent\n  w1 -= learning_rate * grad_w1\n  w2 -= learning_rate * grad_w2\n```\n\n## PyTorch: Autograd\n\nIn the above examples, we had to manually implement both the forward and\nbackward passes of our neural network. Manually implementing the backward pass\nis not a big deal for a small two-layer network, but can quickly get very hairy\nfor large complex networks.\n\nThankfully, we can use\n[automatic differentiation](https://en.wikipedia.org/wiki/Automatic_differentiation)\nto automate the computation of backward passes in neural networks. \nThe **autograd** package in PyTorch provides exactly this functionality.\nWhen using autograd, the forward pass of your network will define a\n**computational graph**; nodes in the graph will be Tensors, and edges will be\nfunctions that produce output Tensors from input Tensors. Backpropagating through\nthis graph then allows you to easily compute gradients.\n\nThis sounds complicated, it's pretty simple to use in practice. If we want to\ncompute gradients with respect to some Tensor, then we set `requires_grad=True`\nwhen constructing that Tensor. Any PyTorch operations on that Tensor will cause\na computational graph to be constructed, allowing us to later perform backpropagation\nthrough the graph. If `x` is a Tensor with `requires_grad=True`, then after\nbackpropagation `x.grad` will be another Tensor holding the gradient of `x` with\nrespect to some scalar value.\n\nSometimes you may wish to prevent PyTorch from building computational graphs when\nperforming certain operations on Tensors with `requires_grad=True`; for example\nwe usually don't want to backpropagate through the weight update steps when\ntraining a neural network. In such scenarios we can use the `torch.no_grad()`\ncontext manager to prevent the construction of a computational graph.\n\nHere we use PyTorch Tensors and autograd to implement our two-layer network;\nnow we no longer need to manually implement the backward pass through the\nnetwork:\n\n```python\n# Code in file autograd/two_layer_net_autograd.py\nimport torch\n\ndevice = torch.device('cpu')\n# device = torch.device('cuda') # Uncomment this to run on GPU\n\n# N is batch size; D_in is input dimension;\n# H is hidden dimension; D_out is output dimension.\nN, D_in, H, D_out = 64, 1000, 100, 10\n\n# Create random Tensors to hold input and outputs\nx = torch.randn(N, D_in, device=device)\ny = torch.randn(N, D_out, device=device)\n\n# Create random Tensors for weights; setting requires_grad=True means that we\n# want to compute gradients for these Tensors during the backward pass.\nw1 = torch.randn(D_in, H, device=device, requires_grad=True)\nw2 = torch.randn(H, D_out, device=device, requires_grad=True)\n\nlearning_rate = 1e-6\nfor t in range(500):\n  # Forward pass: compute predicted y using operations on Tensors. Since w1 and\n  # w2 have requires_grad=True, operations involving these Tensors will cause\n  # PyTorch to build a computational graph, allowing automatic computation of\n  # gradients. Since we are no longer implementing the backward pass by hand we\n  # don't need to keep references to intermediate values.\n  y_pred = x.mm(w1).clamp(min=0).mm(w2)\n  \n  # Compute and print loss. Loss is a Tensor of shape (), and loss.item()\n  # is a Python number giving its value.\n  loss = (y_pred - y).pow(2).sum()\n  print(t, loss.item())\n\n  # Use autograd to compute the backward pass. This call will compute the\n  # gradient of loss with respect to all Tensors with requires_grad=True.\n  # After this call w1.grad and w2.grad will be Tensors holding the gradient\n  # of the loss with respect to w1 and w2 respectively.\n  loss.backward()\n\n  # Update weights using gradient descent. For this step we just want to mutate\n  # the values of w1 and w2 in-place; we don't want to build up a computational\n  # graph for the update steps, so we use the torch.no_grad() context manager\n  # to prevent PyTorch from building a computational graph for the updates\n  with torch.no_grad():\n    w1 -= learning_rate * w1.grad\n    w2 -= learning_rate * w2.grad\n\n    # Manually zero the gradients after running the backward pass\n    w1.grad.zero_()\n    w2.grad.zero_()\n```\n\n## PyTorch: Defining new autograd functions\nUnder the hood, each primitive autograd operator is really two functions that\noperate on Tensors. The **forward** function computes output Tensors from input\nTensors. The **backward** function receives the gradient of the output Tensors\nwith respect to some scalar value, and computes the gradient of the input Tensors\nwith respect to that same scalar value.\n\nIn PyTorch we can easily define our own autograd operator by defining a subclass\nof `torch.autograd.Function` and implementing the `forward` and `backward` functions.\nWe can then use our new autograd operator by constructing an instance and calling it\nlike a function, passing Tensors containing input data.\n\nIn this example we define our own custom autograd function for performing the ReLU\nnonlinearity, and use it to implement our two-layer network:\n\n```python\n# Code in file autograd/two_layer_net_custom_function.py\nimport torch\n\nclass MyReLU(torch.autograd.Function):\n  \"\"\"\n  We can implement our own custom autograd Functions by subclassing\n  torch.autograd.Function and implementing the forward and backward passes\n  which operate on Tensors.\n  \"\"\"\n  @staticmethod\n  def forward(ctx, x):\n    \"\"\"\n    In the forward pass we receive a context object and a Tensor containing the\n    input; we must return a Tensor containing the output, and we can use the\n    context object to cache objects for use in the backward pass.\n    \"\"\"\n    ctx.save_for_backward(x)\n    return x.clamp(min=0)\n\n  @staticmethod\n  def backward(ctx, grad_output):\n    \"\"\"\n    In the backward pass we receive the context object and a Tensor containing\n    the gradient of the loss with respect to the output produced during the\n    forward pass. We can retrieve cached data from the context object, and must\n    compute and return the gradient of the loss with respect to the input to the\n    forward function.\n    \"\"\"\n    x, = ctx.saved_tensors\n    grad_x = grad_output.clone()\n    grad_x[x < 0] = 0\n    return grad_x\n\n\ndevice = torch.device('cpu')\n# device = torch.device('cuda') # Uncomment this to run on GPU\n\n# N is batch size; D_in is input dimension;\n# H is hidden dimension; D_out is output dimension.\nN, D_in, H, D_out = 64, 1000, 100, 10\n\n# Create random Tensors to hold input and output\nx = torch.randn(N, D_in, device=device)\ny = torch.randn(N, D_out, device=device)\n\n# Create random Tensors for weights.\nw1 = torch.randn(D_in, H, device=device, requires_grad=True)\nw2 = torch.randn(H, D_out, device=device, requires_grad=True)\n\nlearning_rate = 1e-6\nfor t in range(500):\n  # Forward pass: compute predicted y using operations on Tensors; we call our\n  # custom ReLU implementation using the MyReLU.apply function\n  y_pred = MyReLU.apply(x.mm(w1)).mm(w2)\n \n  # Compute and print loss\n  loss = (y_pred - y).pow(2).sum()\n  print(t, loss.item())\n\n  # Use autograd to compute the backward pass.\n  loss.backward()\n\n  with torch.no_grad():\n    # Update weights using gradient descent\n    w1 -= learning_rate * w1.grad\n    w2 -= learning_rate * w2.grad\n\n    # Manually zero the gradients after running the backward pass\n    w1.grad.zero_()\n    w2.grad.zero_()\n\n```\n\n## TensorFlow: Static Graphs\nPyTorch autograd looks a lot like TensorFlow: in both frameworks we define\na computational graph, and use automatic differentiation to compute gradients.\nThe biggest difference between the two is that TensorFlow's computational graphs\nare **static** and PyTorch uses **dynamic** computational graphs.\n\nIn TensorFlow, we define the computational graph once and then execute the same\ngraph over and over again, possibly feeding different input data to the graph.\nIn PyTorch, each forward pass defines a new computational graph.\n\nStatic graphs are nice because you can optimize the graph up front; for example\na framework might decide to fuse some graph operations for efficiency, or to\ncome up with a strategy for distributing the graph across many GPUs or many\nmachines. If you are reusing the same graph over and over, then this potentially\ncostly up-front optimization can be amortized as the same graph is rerun over\nand over.\n\nOne aspect where static and dynamic graphs differ is control flow. For some models\nwe may wish to perform different computation for each data point; for example a\nrecurrent network might be unrolled for different numbers of time steps for each\ndata point; this unrolling can be implemented as a loop. With a static graph the\nloop construct needs to be a part of the graph; for this reason TensorFlow\nprovides operators such as `tf.scan` for embedding loops into the graph. With\ndynamic graphs the situation is simpler: since we build graphs on-the-fly for\neach example, we can use normal imperative flow control to perform computation\nthat differs for each input.\n\nTo contrast with the PyTorch autograd example above, here we use TensorFlow to\nfit a simple two-layer net:\n\n```python\n# Code in file autograd/tf_two_layer_net.py\nimport tensorflow as tf\nimport numpy as np\n\n# First we set up the computational graph:\n\n# N is batch size; D_in is input dimension;\n# H is hidden dimension; D_out is output dimension.\nN, D_in, H, D_out = 64, 1000, 100, 10\n\n# Create placeholders for the input and target data; these will be filled\n# with real data when we execute the graph.\nx = tf.placeholder(tf.float32, shape=(None, D_in))\ny = tf.placeholder(tf.float32, shape=(None, D_out))\n\n# Create Variables for the weights and initialize them with random data.\n# A TensorFlow Variable persists its value across executions of the graph.\nw1 = tf.Variable(tf.random_normal((D_in, H)))\nw2 = tf.Variable(tf.random_normal((H, D_out)))\n\n# Forward pass: Compute the predicted y using operations on TensorFlow Tensors.\n# Note that this code does not actually perform any numeric operations; it\n# merely sets up the computational graph that we will later execute.\nh = tf.matmul(x, w1)\nh_relu = tf.maximum(h, tf.zeros(1))\ny_pred = tf.matmul(h_relu, w2)\n\n# Compute loss using operations on TensorFlow Tensors\nloss = tf.reduce_sum((y - y_pred) ** 2.0)\n\n# Compute gradient of the loss with respect to w1 and w2.\ngrad_w1, grad_w2 = tf.gradients(loss, [w1, w2])\n\n# Update the weights using gradient descent. To actually update the weights\n# we need to evaluate new_w1 and new_w2 when executing the graph. Note that\n# in TensorFlow the the act of updating the value of the weights is part of\n# the computational graph; in PyTorch this happens outside the computational\n# graph.\nlearning_rate = 1e-6\nnew_w1 = w1.assign(w1 - learning_rate * grad_w1)\nnew_w2 = w2.assign(w2 - learning_rate * grad_w2)\n\n# Now we have built our computational graph, so we enter a TensorFlow session to\n# actually execute the graph.\nwith tf.Session() as sess:\n  # Run the graph once to initialize the Variables w1 and w2.\n  sess.run(tf.global_variables_initializer())\n\n  # Create numpy arrays holding the actual data for the inputs x and targets y\n  x_value = np.random.randn(N, D_in)\n  y_value = np.random.randn(N, D_out)\n  for _ in range(500):\n    # Execute the graph many times. Each time it executes we want to bind\n    # x_value to x and y_value to y, specified with the feed_dict argument.\n    # Each time we execute the graph we want to compute the values for loss,\n    # new_w1, and new_w2; the values of these Tensors are returned as numpy\n    # arrays.\n    loss_value, _, _ = sess.run([loss, new_w1, new_w2],\n                                feed_dict={x: x_value, y: y_value})\n    print(loss_value)\n```\n\n\n## PyTorch: nn\nComputational graphs and autograd are a very powerful paradigm for defining\ncomplex operators and automatically taking derivatives; however for large\nneural networks raw autograd can be a bit too low-level.\n\nWhen building neural networks we frequently think of arranging the computation\ninto **layers**, some of which have **learnable parameters** which will be\noptimized during learning.\n\nIn TensorFlow, packages like [Keras](https://github.com/fchollet/keras),\n[TensorFlow-Slim](https://github.com/tensorflow/tensorflow/tree/master/tensorflow/contrib/slim),\nand [TFLearn](http://tflearn.org/) provide higher-level abstractions over\nraw computational graphs that are useful for building neural networks.\n\nIn PyTorch, the `nn` package serves this same purpose. The `nn` package defines a set of\n**Modules**, which are roughly equivalent to neural network layers. A Module receives\ninput Tensors and computes output Tensors, but may also hold internal state such as\nTensors containing learnable parameters. The `nn` package also defines a set of useful\nloss functions that are commonly used when training neural networks.\n\nIn this example we use the `nn` package to implement our two-layer network:\n\n```python\n# Code in file nn/two_layer_net_nn.py\nimport torch\n\ndevice = torch.device('cpu')\n# device = torch.device('cuda') # Uncomment this to run on GPU\n\n# N is batch size; D_in is input dimension;\n# H is hidden dimension; D_out is output dimension.\nN, D_in, H, D_out = 64, 1000, 100, 10\n\n# Create random Tensors to hold inputs and outputs\nx = torch.randn(N, D_in, device=device)\ny = torch.randn(N, D_out, device=device)\n\n# Use the nn package to define our model as a sequence of layers. nn.Sequential\n# is a Module which contains other Modules, and applies them in sequence to\n# produce its output. Each Linear Module computes output from input using a\n# linear function, and holds internal Tensors for its weight and bias.\n# After constructing the model we use the .to() method to move it to the\n# desired device.\nmodel = torch.nn.Sequential(\n          torch.nn.Linear(D_in, H),\n          torch.nn.ReLU(),\n          torch.nn.Linear(H, D_out),\n        ).to(device)\n\n# The nn package also contains definitions of popular loss functions; in this\n# case we will use Mean Squared Error (MSE) as our loss function. Setting\n# reduction='sum' means that we are computing the *sum* of squared errors rather\n# than the mean; this is for consistency with the examples above where we\n# manually compute the loss, but in practice it is more common to use mean\n# squared error as a loss by setting reduction='elementwise_mean'.\nloss_fn = torch.nn.MSELoss(reduction='sum')\n\nlearning_rate = 1e-4\nfor t in range(500):\n  # Forward pass: compute predicted y by passing x to the model. Module objects\n  # override the __call__ operator so you can call them like functions. When\n  # doing so you pass a Tensor of input data to the Module and it produces\n  # a Tensor of output data.\n  y_pred = model(x)\n\n  # Compute and print loss. We pass Tensors containing the predicted and true\n  # values of y, and the loss function returns a Tensor containing the loss.\n  loss = loss_fn(y_pred, y)\n  print(t, loss.item())\n  \n  # Zero the gradients before running the backward pass.\n  model.zero_grad()\n\n  # Backward pass: compute gradient of the loss with respect to all the learnable\n  # parameters of the model. Internally, the parameters of each Module are stored\n  # in Tensors with requires_grad=True, so this call will compute gradients for\n  # all learnable parameters in the model.\n  loss.backward()\n\n  # Update the weights using gradient descent. Each parameter is a Tensor, so\n  # we can access its data and gradients like we did before.\n  with torch.no_grad():\n    for param in model.parameters():\n      param.data -= learning_rate * param.grad\n```\n\n\n## PyTorch: optim\nUp to this point we have updated the weights of our models by manually mutating\nTensors holding learnable parameters. This is not a huge burden\nfor simple optimization algorithms like stochastic gradient descent, but in practice\nwe often train neural networks using more sophisiticated optimizers like AdaGrad,\nRMSProp, Adam, etc.\n\nThe `optim` package in PyTorch abstracts the idea of an optimization algorithm and\nprovides implementations of commonly used optimization algorithms.\n\nIn this example we will use the `nn` package to define our model as before, but we\nwill optimize the model using the Adam algorithm provided by the `optim` package:\n\n```python\n# Code in file nn/two_layer_net_optim.py\nimport torch\n\n# N is batch size; D_in is input dimension;\n# H is hidden dimension; D_out is output dimension.\nN, D_in, H, D_out = 64, 1000, 100, 10\n\n# Create random Tensors to hold inputs and outputs.\nx = torch.randn(N, D_in)\ny = torch.randn(N, D_out)\n\n# Use the nn package to define our model and loss function.\nmodel = torch.nn.Sequential(\n          torch.nn.Linear(D_in, H),\n          torch.nn.ReLU(),\n          torch.nn.Linear(H, D_out),\n        )\nloss_fn = torch.nn.MSELoss(reduction='sum')\n\n# Use the optim package to define an Optimizer that will update the weights of\n# the model for us. Here we will use Adam; the optim package contains many other\n# optimization algorithms. The first argument to the Adam constructor tells the\n# optimizer which Tensors it should update.\nlearning_rate = 1e-4\noptimizer = torch.optim.Adam(model.parameters(), lr=learning_rate)\nfor t in range(500):\n  # Forward pass: compute predicted y by passing x to the model.\n  y_pred = model(x)\n\n  # Compute and print loss.\n  loss = loss_fn(y_pred, y)\n  print(t, loss.item())\n  \n  # Before the backward pass, use the optimizer object to zero all of the\n  # gradients for the Tensors it will update (which are the learnable weights\n  # of the model)\n  optimizer.zero_grad()\n\n  # Backward pass: compute gradient of the loss with respect to model parameters\n  loss.backward()\n\n  # Calling the step function on an Optimizer makes an update to its parameters\n  optimizer.step()\n```\n\n\n## PyTorch: Custom nn Modules\nSometimes you will want to specify models that are more complex than a sequence of\nexisting Modules; for these cases you can define your own Modules by subclassing\n`nn.Module` and defining a `forward` which receives input Tensors and produces\noutput Tensors using other modules or other autograd operations on Tensors.\n\nIn this example we implement our two-layer network as a custom Module subclass:\n\n```python\n# Code in file nn/two_layer_net_module.py\nimport torch\n\nclass TwoLayerNet(torch.nn.Module):\n  def __init__(self, D_in, H, D_out):\n    \"\"\"\n    In the constructor we instantiate two nn.Linear modules and assign them as\n    member variables.\n    \"\"\"\n    super(TwoLayerNet, self).__init__()\n    self.linear1 = torch.nn.Linear(D_in, H)\n    self.linear2 = torch.nn.Linear(H, D_out)\n\n  def forward(self, x):\n    \"\"\"\n    In the forward function we accept a Tensor of input data and we must return\n    a Tensor of output data. We can use Modules defined in the constructor as\n    well as arbitrary (differentiable) operations on Tensors.\n    \"\"\"\n    h_relu = self.linear1(x).clamp(min=0)\n    y_pred = self.linear2(h_relu)\n    return y_pred\n\n# N is batch size; D_in is input dimension;\n# H is hidden dimension; D_out is output dimension.\nN, D_in, H, D_out = 64, 1000, 100, 10\n\n# Create random Tensors to hold inputs and outputs\nx = torch.randn(N, D_in)\ny = torch.randn(N, D_out)\n\n# Construct our model by instantiating the class defined above.\nmodel = TwoLayerNet(D_in, H, D_out)\n\n# Construct our loss function and an Optimizer. The call to model.parameters()\n# in the SGD constructor will contain the learnable parameters of the two\n# nn.Linear modules which are members of the model.\nloss_fn = torch.nn.MSELoss(reduction='sum')\noptimizer = torch.optim.SGD(model.parameters(), lr=1e-4)\nfor t in range(500):\n  # Forward pass: Compute predicted y by passing x to the model\n  y_pred = model(x)\n\n  # Compute and print loss\n  loss = loss_fn(y_pred, y)\n  print(t, loss.item())\n\n  # Zero gradients, perform a backward pass, and update the weights.\n  optimizer.zero_grad()\n  loss.backward()\n  optimizer.step()\n\n```\n\n\n## PyTorch: Control Flow + Weight Sharing\nAs an example of dynamic graphs and weight sharing, we implement a very strange\nmodel: a fully-connected ReLU network that on each forward pass chooses a random\nnumber between 1 and 4 and uses that many hidden layers, reusing the same weights\nmultiple times to compute the innermost hidden layers.\n\nFor this model can use normal Python flow control to implement the loop, and we\ncan implement weight sharing among the innermost layers by simply reusing the\nsame Module multiple times when defining the forward pass.\n\nWe can easily implement this model as a Module subclass:\n\n```python\n# Code in file nn/dynamic_net.py\nimport random\nimport torch\n\nclass DynamicNet(torch.nn.Module):\n  def __init__(self, D_in, H, D_out):\n    \"\"\"\n    In the constructor we construct three nn.Linear instances that we will use\n    in the forward pass.\n    \"\"\"\n    super(DynamicNet, self).__init__()\n    self.input_linear = torch.nn.Linear(D_in, H)\n    self.middle_linear = torch.nn.Linear(H, H)\n    self.output_linear = torch.nn.Linear(H, D_out)\n\n  def forward(self, x):\n    \"\"\"\n    For the forward pass of the model, we randomly choose either 0, 1, 2, or 3\n    and reuse the middle_linear Module that many times to compute hidden layer\n    representations.\n\n    Since each forward pass builds a dynamic computation graph, we can use normal\n    Python control-flow operators like loops or conditional statements when\n    defining the forward pass of the model.\n\n    Here we also see that it is perfectly safe to reuse the same Module many\n    times when defining a computational graph. This is a big improvement from Lua\n    Torch, where each Module could be used only once.\n    \"\"\"\n    h_relu = self.input_linear(x).clamp(min=0)\n    for _ in range(random.randint(0, 3)):\n      h_relu = self.middle_linear(h_relu).clamp(min=0)\n    y_pred = self.output_linear(h_relu)\n    return y_pred\n\n\n# N is batch size; D_in is input dimension;\n# H is hidden dimension; D_out is output dimension.\nN, D_in, H, D_out = 64, 1000, 100, 10\n\n# Create random Tensors to hold inputs and outputs.\nx = torch.randn(N, D_in)\ny = torch.randn(N, D_out)\n\n# Construct our model by instantiating the class defined above\nmodel = DynamicNet(D_in, H, D_out)\n\n# Construct our loss function and an Optimizer. Training this strange model with\n# vanilla stochastic gradient descent is tough, so we use momentum\ncriterion = torch.nn.MSELoss(reduction='sum')\noptimizer = torch.optim.SGD(model.parameters(), lr=1e-4, momentum=0.9)\nfor t in range(500):\n  # Forward pass: Compute predicted y by passing x to the model\n  y_pred = model(x)\n\n  # Compute and print loss\n  loss = criterion(y_pred, y)\n  print(t, loss.item())\n\n  # Zero gradients, perform a backward pass, and update the weights.\n  optimizer.zero_grad()\n  loss.backward()\n  optimizer.step()\n```\n"
        },
        {
          "name": "README_raw.md",
          "type": "blob",
          "size": 10.7421875,
          "content": "This repository introduces the fundamental concepts of\n[PyTorch](https://github.com/pytorch/pytorch)\nthrough self-contained examples.\n\nAt its core, PyTorch provides two main features:\n- An n-dimensional Tensor, similar to numpy but can run on GPUs\n- Automatic differentiation for building and training neural networks\n\nWe will use a fully-connected ReLU network as our running example. The network\nwill have a single hidden layer, and will be trained with gradient descent to\nfit random data by minimizing the Euclidean distance between the network output\nand the true output.\n\n**NOTE:** These examples have been update for PyTorch 0.4, which made several\nmajor changes to the core PyTorch API. Most notably, prior to 0.4 Tensors had\nto be wrapped in Variable objects to use autograd; this functionality has now\nbeen added directly to Tensors, and Variables are now deprecated.\n\n### Table of Contents\n- <a href='#warm-up-numpy'>Warm-up: numpy</a>\n- <a href='#pytorch-tensors'>PyTorch: Tensors</a>\n- <a href='#pytorch-autograd'>PyTorch: Autograd</a>\n- <a href='#pytorch-defining-new-autograd-functions'>PyTorch: Defining new autograd functions</a>\n- <a href='#tensorflow-static-graphs'>TensorFlow: Static Graphs</a>\n- <a href='#pytorch-nn'>PyTorch: nn</a>\n- <a href='#pytorch-optim'>PyTorch: optim</a>\n- <a href='#pytorch-custom-nn-modules'>PyTorch: Custom nn Modules</a>\n- <a href='#pytorch-control-flow--weight-sharing'>PyTorch: Control Flow and Weight Sharing</a>\n\n## Warm-up: numpy\n\nBefore introducing PyTorch, we will first implement the network using numpy.\n\nNumpy provides an n-dimensional array object, and many functions for manipulating\nthese arrays. Numpy is a generic framework for scientific computing; it does not\nknow anything about computation graphs, or deep learning, or gradients. However\nwe can easily use numpy to fit a two-layer network to random data by manually\nimplementing the forward and backward passes through the network using numpy\noperations:\n\n```python\n:INCLUDE tensor/two_layer_net_numpy.py\n```\n\n## PyTorch: Tensors\n\nNumpy is a great framework, but it cannot utilize GPUs to accelerate its\nnumerical computations. For modern deep neural networks, GPUs often provide\nspeedups of [50x or greater](https://github.com/jcjohnson/cnn-benchmarks), so\nunfortunately numpy won't be enough for modern deep learning.\n\nHere we introduce the most fundamental PyTorch concept: the **Tensor**. A PyTorch\nTensor is conceptually identical to a numpy array: a Tensor is an n-dimensional\narray, and PyTorch provides many functions for operating on these Tensors.\nAny computation you might want to perform with numpy can also be accomplished\nwith PyTorch Tensors; you should think of them as a generic tool for scientific\ncomputing.\n\nHowever unlike numpy, PyTorch Tensors can utilize GPUs to accelerate their\nnumeric computations. To run a PyTorch Tensor on GPU, you use the `device`\nargument when constructing a Tensor to place the Tensor on a GPU.\n\nHere we use PyTorch Tensors to fit a two-layer network to random data. Like the\nnumpy example above we manually implement the forward and backward\npasses through the network, using operations on PyTorch Tensors:\n\n```python\n:INCLUDE tensor/two_layer_net_tensor.py\n```\n\n## PyTorch: Autograd\n\nIn the above examples, we had to manually implement both the forward and\nbackward passes of our neural network. Manually implementing the backward pass\nis not a big deal for a small two-layer network, but can quickly get very hairy\nfor large complex networks.\n\nThankfully, we can use\n[automatic differentiation](https://en.wikipedia.org/wiki/Automatic_differentiation)\nto automate the computation of backward passes in neural networks. \nThe **autograd** package in PyTorch provides exactly this functionality.\nWhen using autograd, the forward pass of your network will define a\n**computational graph**; nodes in the graph will be Tensors, and edges will be\nfunctions that produce output Tensors from input Tensors. Backpropagating through\nthis graph then allows you to easily compute gradients.\n\nThis sounds complicated, it's pretty simple to use in practice. If we want to\ncompute gradients with respect to some Tensor, then we set `requires_grad=True`\nwhen constructing that Tensor. Any PyTorch operations on that Tensor will cause\na computational graph to be constructed, allowing us to later perform backpropagation\nthrough the graph. If `x` is a Tensor with `requires_grad=True`, then after\nbackpropagation `x.grad` will be another Tensor holding the gradient of `x` with\nrespect to some scalar value.\n\nSometimes you may wish to prevent PyTorch from building computational graphs when\nperforming certain operations on Tensors with `requires_grad=True`; for example\nwe usually don't want to backpropagate through the weight update steps when\ntraining a neural network. In such scenarios we can use the `torch.no_grad()`\ncontext manager to prevent the construction of a computational graph.\n\nHere we use PyTorch Tensors and autograd to implement our two-layer network;\nnow we no longer need to manually implement the backward pass through the\nnetwork:\n\n```python\n:INCLUDE autograd/two_layer_net_autograd.py\n```\n\n## PyTorch: Defining new autograd functions\nUnder the hood, each primitive autograd operator is really two functions that\noperate on Tensors. The **forward** function computes output Tensors from input\nTensors. The **backward** function receives the gradient of the output Tensors\nwith respect to some scalar value, and computes the gradient of the input Tensors\nwith respect to that same scalar value.\n\nIn PyTorch we can easily define our own autograd operator by defining a subclass\nof `torch.autograd.Function` and implementing the `forward` and `backward` functions.\nWe can then use our new autograd operator by constructing an instance and calling it\nlike a function, passing Tensors containing input data.\n\nIn this example we define our own custom autograd function for performing the ReLU\nnonlinearity, and use it to implement our two-layer network:\n\n```python\n:INCLUDE autograd/two_layer_net_custom_function.py\n```\n\n## TensorFlow: Static Graphs\nPyTorch autograd looks a lot like TensorFlow: in both frameworks we define\na computational graph, and use automatic differentiation to compute gradients.\nThe biggest difference between the two is that TensorFlow's computational graphs\nare **static** and PyTorch uses **dynamic** computational graphs.\n\nIn TensorFlow, we define the computational graph once and then execute the same\ngraph over and over again, possibly feeding different input data to the graph.\nIn PyTorch, each forward pass defines a new computational graph.\n\nStatic graphs are nice because you can optimize the graph up front; for example\na framework might decide to fuse some graph operations for efficiency, or to\ncome up with a strategy for distributing the graph across many GPUs or many\nmachines. If you are reusing the same graph over and over, then this potentially\ncostly up-front optimization can be amortized as the same graph is rerun over\nand over.\n\nOne aspect where static and dynamic graphs differ is control flow. For some models\nwe may wish to perform different computation for each data point; for example a\nrecurrent network might be unrolled for different numbers of time steps for each\ndata point; this unrolling can be implemented as a loop. With a static graph the\nloop construct needs to be a part of the graph; for this reason TensorFlow\nprovides operators such as `tf.scan` for embedding loops into the graph. With\ndynamic graphs the situation is simpler: since we build graphs on-the-fly for\neach example, we can use normal imperative flow control to perform computation\nthat differs for each input.\n\nTo contrast with the PyTorch autograd example above, here we use TensorFlow to\nfit a simple two-layer net:\n\n```python\n:INCLUDE autograd/tf_two_layer_net.py\n```\n\n\n## PyTorch: nn\nComputational graphs and autograd are a very powerful paradigm for defining\ncomplex operators and automatically taking derivatives; however for large\nneural networks raw autograd can be a bit too low-level.\n\nWhen building neural networks we frequently think of arranging the computation\ninto **layers**, some of which have **learnable parameters** which will be\noptimized during learning.\n\nIn TensorFlow, packages like [Keras](https://github.com/fchollet/keras),\n[TensorFlow-Slim](https://github.com/tensorflow/tensorflow/tree/master/tensorflow/contrib/slim),\nand [TFLearn](http://tflearn.org/) provide higher-level abstractions over\nraw computational graphs that are useful for building neural networks.\n\nIn PyTorch, the `nn` package serves this same purpose. The `nn` package defines a set of\n**Modules**, which are roughly equivalent to neural network layers. A Module receives\ninput Tensors and computes output Tensors, but may also hold internal state such as\nTensors containing learnable parameters. The `nn` package also defines a set of useful\nloss functions that are commonly used when training neural networks.\n\nIn this example we use the `nn` package to implement our two-layer network:\n\n```python\n:INCLUDE nn/two_layer_net_nn.py\n```\n\n\n## PyTorch: optim\nUp to this point we have updated the weights of our models by manually mutating\nTensors holding learnable parameters. This is not a huge burden\nfor simple optimization algorithms like stochastic gradient descent, but in practice\nwe often train neural networks using more sophisiticated optimizers like AdaGrad,\nRMSProp, Adam, etc.\n\nThe `optim` package in PyTorch abstracts the idea of an optimization algorithm and\nprovides implementations of commonly used optimization algorithms.\n\nIn this example we will use the `nn` package to define our model as before, but we\nwill optimize the model using the Adam algorithm provided by the `optim` package:\n\n```python\n:INCLUDE nn/two_layer_net_optim.py\n```\n\n\n## PyTorch: Custom nn Modules\nSometimes you will want to specify models that are more complex than a sequence of\nexisting Modules; for these cases you can define your own Modules by subclassing\n`nn.Module` and defining a `forward` which receives input Tensors and produces\noutput Tensors using other modules or other autograd operations on Tensors.\n\nIn this example we implement our two-layer network as a custom Module subclass:\n\n```python\n:INCLUDE nn/two_layer_net_module.py\n```\n\n\n## PyTorch: Control Flow + Weight Sharing\nAs an example of dynamic graphs and weight sharing, we implement a very strange\nmodel: a fully-connected ReLU network that on each forward pass chooses a random\nnumber between 1 and 4 and uses that many hidden layers, reusing the same weights\nmultiple times to compute the innermost hidden layers.\n\nFor this model can use normal Python flow control to implement the loop, and we\ncan implement weight sharing among the innermost layers by simply reusing the\nsame Module multiple times when defining the forward pass.\n\nWe can easily implement this model as a Module subclass:\n\n```python\n:INCLUDE nn/dynamic_net.py\n```\n"
        },
        {
          "name": "autograd",
          "type": "tree",
          "content": null
        },
        {
          "name": "build_readme.py",
          "type": "blob",
          "size": 1.2236328125,
          "content": "import os\n\n\"\"\"\nGitHub doesn't provide an include mechanism for README files so we have to\nimplement our own.\n\"\"\"\n\ndef main():\n  build_readme('README_raw.md', 'README.md')\n  for d in os.listdir('.'):\n    if not os.path.isdir(d) or d.startswith('.'):\n      continue\n    in_path = os.path.join(d, 'README_raw.md')\n    out_path = os.path.join(d, 'README.md')\n    build_readme(in_path, out_path)\n\n\ndef build_readme(in_path, out_path):\n  if not os.path.isfile(in_path):\n    return\n  with open(in_path, 'r') as fin, open(out_path, 'w') as fout:\n    for line in fin:\n      if not line.startswith(':INCLUDE'):\n        fout.write('%s' % line)\n      else:\n        include_path = line.split(' ')[1].strip()\n        include_path = os.path.join(os.path.split(in_path)[0], include_path)\n        fout.write('# Code in file %s\\n' % include_path)\n        skip_toggle = False\n        skip_next = False\n        with open(include_path, 'r') as finc:\n          for ll in finc:\n            if ll.startswith('\"\"\"'):\n              skip_next = skip_toggle\n              skip_toggle = not skip_toggle\n            elif not skip_toggle and not skip_next:\n              fout.write(ll)\n            elif skip_next:\n              skip_next = False\n\nif __name__ == '__main__':\n  main()\n\n"
        },
        {
          "name": "nn",
          "type": "tree",
          "content": null
        },
        {
          "name": "tensor",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}