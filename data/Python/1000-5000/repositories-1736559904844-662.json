{
  "metadata": {
    "timestamp": 1736559904844,
    "page": 662,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjY3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "lanjelot/patator",
      "stars": 3615,
      "defaultBranch": "master",
      "files": [
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 3.2041015625,
          "content": "FROM ubuntu:22.04\n\nENV DEBIAN_FRONTEND=noninteractive \n\n# dependencies\nRUN apt-get update \\\n && apt-get install -y --no-install-recommends \\\n  build-essential python3-setuptools \\\n  libcurl4-openssl-dev python3-dev libssl-dev \\\n  ldap-utils \\\n  libmysqlclient-dev \\\n  libpq-dev \\\n  ike-scan unzip default-jdk \\\n  libsqlite3-dev \\\n  libsqlcipher-dev \\\n  python3-pip \\\n && rm -rf /var/lib/apt/lists/*\n\n## cx_oracle\nRUN apt-get update \\\n && apt-get install -y --no-install-recommends libaio1 wget unzip git \\\n && rm -rf /var/lib/apt/lists/*\n\nWORKDIR /opt/oracle\nRUN wget https://download.oracle.com/otn_software/linux/instantclient/instantclient-basiclite-linuxx64.zip \\\n && wget https://download.oracle.com/otn_software/linux/instantclient/instantclient-sdk-linuxx64.zip \\\n && unzip instantclient-basiclite-linuxx64.zip \\\n && rm -f instantclient-basiclite-linuxx64.zip \\\n && unzip instantclient-sdk-linuxx64.zip \\\n && rm -f instantclient-sdk-linuxx64.zip \\\n && cd /opt/oracle/instantclient_* \\\n && rm -f *jdbc* *occi* *mysql* *README *jar uidrvci genezi adrci \\\n && echo /opt/oracle/instantclient_* > /etc/ld.so.conf.d/oracle-instantclient.conf \\\n && ldconfig\n\n## xfreerdp (see https://github.com/FreeRDP/FreeRDP/wiki/Compilation)\nWORKDIR /opt/FreeRDP\nRUN apt-get update \\\n && apt-get install -y --no-install-recommends ninja-build build-essential git-core debhelper cdbs dpkg-dev autotools-dev cmake pkg-config xmlto libssl-dev docbook-xsl xsltproc libxkbfile-dev libx11-dev libwayland-dev libxrandr-dev libxi-dev libxrender-dev libxext-dev libxinerama-dev libxfixes-dev libxcursor-dev libxv-dev libxdamage-dev libxtst-dev libcups2-dev libpcsclite-dev libasound2-dev libpulse-dev libjpeg-dev libgsm1-dev libusb-1.0-0-dev libudev-dev libdbus-glib-1-dev uuid-dev libxml2-dev libgstreamer1.0-dev libgstreamer-plugins-base1.0-dev libfaad-dev libfaac-dev libsdl2-dev libcjson-dev libpkcs11-helper1-dev \\\n && apt-get install -y --no-install-recommends libavutil-dev libavcodec-dev libswresample-dev \\\n && rm -rf /var/lib/apt/lists/* \\\n && git clone --depth 1 --branch 2.9.0 https://github.com/freerdp/freerdp.git \\\n && cmake -B freerdp-build -S freerdp -DCMAKE_BUILD_TYPE=Debug -DWITH_CLIENT_SDL=OFF -DWITH_KRB5=OFF -DWITH_SWSCALE=OFF -DWITTH_SSE2=ON -DWITH_FUSE=OFF \\\n && cmake --build freerdp-build \\\n && cmake --install freerdp-build \\\n && rm -rf /opt/FreeRDP\n\n# patator\nWORKDIR /opt/patator\nCOPY ./requirements.txt ./\nRUN python3 -m pip install --upgrade pip \\\n  && python3 -m pip install -r requirements.txt\n\n# uncomment for python2\n# RUN apt-get update \\\n#  && apt-get install -y --no-install-recommends python-pip ipython \\\n#  && rm -rf /var/lib/apt/lists/* \\\n#  && sed -e '/cx_Oracle/d' -e 's,pysqlcipher3,pysqlcipher,' requirements.txt | python2 -m pip install -r /dev/stdin \\\n#  && git clone --branch 5.3 https://github.com/oracle/python-cx_Oracle \\\n#  && cd python-cx_Oracle && export ORACLE_HOME=$(echo /opt/oracle/instantclient_*) && python2 setup.py build && python2 setup.py install\n\n# utils\nRUN apt-get update \\\n && apt-get install -y --no-install-recommends ipython3 iputils-ping iproute2 netcat curl rsh-client telnet vim mlocate nmap \\\n && rm -rf /var/lib/apt/lists/* \\\n && echo 'set bg=dark' > /root/.vimrc\n\nCOPY ./patator.py ./\nENTRYPOINT [\"python3\", \"./patator.py\"]\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 17.66796875,
          "content": "                    GNU GENERAL PUBLIC LICENSE\n                       Version 2, June 1991\n\n Copyright (C) 1989, 1991 Free Software Foundation, Inc.,\n 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n                            Preamble\n\n  The licenses for most software are designed to take away your\nfreedom to share and change it.  By contrast, the GNU General Public\nLicense is intended to guarantee your freedom to share and change free\nsoftware--to make sure the software is free for all its users.  This\nGeneral Public License applies to most of the Free Software\nFoundation's software and to any other program whose authors commit to\nusing it.  (Some other Free Software Foundation software is covered by\nthe GNU Lesser General Public License instead.)  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthis service if you wish), that you receive source code or can get it\nif you want it, that you can change the software or use pieces of it\nin new free programs; and that you know you can do these things.\n\n  To protect your rights, we need to make restrictions that forbid\nanyone to deny you these rights or to ask you to surrender the rights.\nThese restrictions translate to certain responsibilities for you if you\ndistribute copies of the software, or if you modify it.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must give the recipients all the rights that\nyou have.  You must make sure that they, too, receive or can get the\nsource code.  And you must show them these terms so they know their\nrights.\n\n  We protect your rights with two steps: (1) copyright the software, and\n(2) offer you this license which gives you legal permission to copy,\ndistribute and/or modify the software.\n\n  Also, for each author's protection and ours, we want to make certain\nthat everyone understands that there is no warranty for this free\nsoftware.  If the software is modified by someone else and passed on, we\nwant its recipients to know that what they have is not the original, so\nthat any problems introduced by others will not reflect on the original\nauthors' reputations.\n\n  Finally, any free program is threatened constantly by software\npatents.  We wish to avoid the danger that redistributors of a free\nprogram will individually obtain patent licenses, in effect making the\nprogram proprietary.  To prevent this, we have made it clear that any\npatent must be licensed for everyone's free use or not licensed at all.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n                    GNU GENERAL PUBLIC LICENSE\n   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\n\n  0. This License applies to any program or other work which contains\na notice placed by the copyright holder saying it may be distributed\nunder the terms of this General Public License.  The \"Program\", below,\nrefers to any such program or work, and a \"work based on the Program\"\nmeans either the Program or any derivative work under copyright law:\nthat is to say, a work containing the Program or a portion of it,\neither verbatim or with modifications and/or translated into another\nlanguage.  (Hereinafter, translation is included without limitation in\nthe term \"modification\".)  Each licensee is addressed as \"you\".\n\nActivities other than copying, distribution and modification are not\ncovered by this License; they are outside its scope.  The act of\nrunning the Program is not restricted, and the output from the Program\nis covered only if its contents constitute a work based on the\nProgram (independent of having been made by running the Program).\nWhether that is true depends on what the Program does.\n\n  1. You may copy and distribute verbatim copies of the Program's\nsource code as you receive it, in any medium, provided that you\nconspicuously and appropriately publish on each copy an appropriate\ncopyright notice and disclaimer of warranty; keep intact all the\nnotices that refer to this License and to the absence of any warranty;\nand give any other recipients of the Program a copy of this License\nalong with the Program.\n\nYou may charge a fee for the physical act of transferring a copy, and\nyou may at your option offer warranty protection in exchange for a fee.\n\n  2. You may modify your copy or copies of the Program or any portion\nof it, thus forming a work based on the Program, and copy and\ndistribute such modifications or work under the terms of Section 1\nabove, provided that you also meet all of these conditions:\n\n    a) You must cause the modified files to carry prominent notices\n    stating that you changed the files and the date of any change.\n\n    b) You must cause any work that you distribute or publish, that in\n    whole or in part contains or is derived from the Program or any\n    part thereof, to be licensed as a whole at no charge to all third\n    parties under the terms of this License.\n\n    c) If the modified program normally reads commands interactively\n    when run, you must cause it, when started running for such\n    interactive use in the most ordinary way, to print or display an\n    announcement including an appropriate copyright notice and a\n    notice that there is no warranty (or else, saying that you provide\n    a warranty) and that users may redistribute the program under\n    these conditions, and telling the user how to view a copy of this\n    License.  (Exception: if the Program itself is interactive but\n    does not normally print such an announcement, your work based on\n    the Program is not required to print an announcement.)\n\nThese requirements apply to the modified work as a whole.  If\nidentifiable sections of that work are not derived from the Program,\nand can be reasonably considered independent and separate works in\nthemselves, then this License, and its terms, do not apply to those\nsections when you distribute them as separate works.  But when you\ndistribute the same sections as part of a whole which is a work based\non the Program, the distribution of the whole must be on the terms of\nthis License, whose permissions for other licensees extend to the\nentire whole, and thus to each and every part regardless of who wrote it.\n\nThus, it is not the intent of this section to claim rights or contest\nyour rights to work written entirely by you; rather, the intent is to\nexercise the right to control the distribution of derivative or\ncollective works based on the Program.\n\nIn addition, mere aggregation of another work not based on the Program\nwith the Program (or with a work based on the Program) on a volume of\na storage or distribution medium does not bring the other work under\nthe scope of this License.\n\n  3. You may copy and distribute the Program (or a work based on it,\nunder Section 2) in object code or executable form under the terms of\nSections 1 and 2 above provided that you also do one of the following:\n\n    a) Accompany it with the complete corresponding machine-readable\n    source code, which must be distributed under the terms of Sections\n    1 and 2 above on a medium customarily used for software interchange; or,\n\n    b) Accompany it with a written offer, valid for at least three\n    years, to give any third party, for a charge no more than your\n    cost of physically performing source distribution, a complete\n    machine-readable copy of the corresponding source code, to be\n    distributed under the terms of Sections 1 and 2 above on a medium\n    customarily used for software interchange; or,\n\n    c) Accompany it with the information you received as to the offer\n    to distribute corresponding source code.  (This alternative is\n    allowed only for noncommercial distribution and only if you\n    received the program in object code or executable form with such\n    an offer, in accord with Subsection b above.)\n\nThe source code for a work means the preferred form of the work for\nmaking modifications to it.  For an executable work, complete source\ncode means all the source code for all modules it contains, plus any\nassociated interface definition files, plus the scripts used to\ncontrol compilation and installation of the executable.  However, as a\nspecial exception, the source code distributed need not include\nanything that is normally distributed (in either source or binary\nform) with the major components (compiler, kernel, and so on) of the\noperating system on which the executable runs, unless that component\nitself accompanies the executable.\n\nIf distribution of executable or object code is made by offering\naccess to copy from a designated place, then offering equivalent\naccess to copy the source code from the same place counts as\ndistribution of the source code, even though third parties are not\ncompelled to copy the source along with the object code.\n\n  4. You may not copy, modify, sublicense, or distribute the Program\nexcept as expressly provided under this License.  Any attempt\notherwise to copy, modify, sublicense or distribute the Program is\nvoid, and will automatically terminate your rights under this License.\nHowever, parties who have received copies, or rights, from you under\nthis License will not have their licenses terminated so long as such\nparties remain in full compliance.\n\n  5. You are not required to accept this License, since you have not\nsigned it.  However, nothing else grants you permission to modify or\ndistribute the Program or its derivative works.  These actions are\nprohibited by law if you do not accept this License.  Therefore, by\nmodifying or distributing the Program (or any work based on the\nProgram), you indicate your acceptance of this License to do so, and\nall its terms and conditions for copying, distributing or modifying\nthe Program or works based on it.\n\n  6. Each time you redistribute the Program (or any work based on the\nProgram), the recipient automatically receives a license from the\noriginal licensor to copy, distribute or modify the Program subject to\nthese terms and conditions.  You may not impose any further\nrestrictions on the recipients' exercise of the rights granted herein.\nYou are not responsible for enforcing compliance by third parties to\nthis License.\n\n  7. If, as a consequence of a court judgment or allegation of patent\ninfringement or for any other reason (not limited to patent issues),\nconditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot\ndistribute so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you\nmay not distribute the Program at all.  For example, if a patent\nlicense would not permit royalty-free redistribution of the Program by\nall those who receive copies directly or indirectly through you, then\nthe only way you could satisfy both it and this License would be to\nrefrain entirely from distribution of the Program.\n\nIf any portion of this section is held invalid or unenforceable under\nany particular circumstance, the balance of the section is intended to\napply and the section as a whole is intended to apply in other\ncircumstances.\n\nIt is not the purpose of this section to induce you to infringe any\npatents or other property right claims or to contest validity of any\nsuch claims; this section has the sole purpose of protecting the\nintegrity of the free software distribution system, which is\nimplemented by public license practices.  Many people have made\ngenerous contributions to the wide range of software distributed\nthrough that system in reliance on consistent application of that\nsystem; it is up to the author/donor to decide if he or she is willing\nto distribute software through any other system and a licensee cannot\nimpose that choice.\n\nThis section is intended to make thoroughly clear what is believed to\nbe a consequence of the rest of this License.\n\n  8. If the distribution and/or use of the Program is restricted in\ncertain countries either by patents or by copyrighted interfaces, the\noriginal copyright holder who places the Program under this License\nmay add an explicit geographical distribution limitation excluding\nthose countries, so that distribution is permitted only in or among\ncountries not thus excluded.  In such case, this License incorporates\nthe limitation as if written in the body of this License.\n\n  9. The Free Software Foundation may publish revised and/or new versions\nof the General Public License from time to time.  Such new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\nEach version is given a distinguishing version number.  If the Program\nspecifies a version number of this License which applies to it and \"any\nlater version\", you have the option of following the terms and conditions\neither of that version or of any later version published by the Free\nSoftware Foundation.  If the Program does not specify a version number of\nthis License, you may choose any version ever published by the Free Software\nFoundation.\n\n  10. If you wish to incorporate parts of the Program into other free\nprograms whose distribution conditions are different, write to the author\nto ask for permission.  For software which is copyrighted by the Free\nSoftware Foundation, write to the Free Software Foundation; we sometimes\nmake exceptions for this.  Our decision will be guided by the two goals\nof preserving the free status of all derivatives of our free software and\nof promoting the sharing and reuse of software generally.\n\n                            NO WARRANTY\n\n  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY\nFOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN\nOTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES\nPROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED\nOR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS\nTO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE\nPROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,\nREPAIR OR CORRECTION.\n\n  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR\nREDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,\nINCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING\nOUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED\nTO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY\nYOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER\nPROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGES.\n\n                     END OF TERMS AND CONDITIONS\n\n            How to Apply These Terms to Your New Programs\n\n  If you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these terms.\n\n  To do so, attach the following notices to the program.  It is safest\nto attach them to the start of each source file to most effectively\nconvey the exclusion of warranty; and each file should have at least\nthe \"copyright\" line and a pointer to where the full notice is found.\n\n    <one line to give the program's name and a brief idea of what it does.>\n    Copyright (C) <year>  <name of author>\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\nAlso add information on how to contact you by electronic and paper mail.\n\nIf the program is interactive, make it output a short notice like this\nwhen it starts in an interactive mode:\n\n    Gnomovision version 69, Copyright (C) year name of author\n    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n    This is free software, and you are welcome to redistribute it\n    under certain conditions; type `show c' for details.\n\nThe hypothetical commands `show w' and `show c' should show the appropriate\nparts of the General Public License.  Of course, the commands you use may\nbe called something other than `show w' and `show c'; they could even be\nmouse-clicks or menu items--whatever suits your program.\n\nYou should also get your employer (if you work as a programmer) or your\nschool, if any, to sign a \"copyright disclaimer\" for the program, if\nnecessary.  Here is a sample; alter the names:\n\n  Yoyodyne, Inc., hereby disclaims all copyright interest in the program\n  `Gnomovision' (which makes passes at compilers) written by James Hacker.\n\n  <signature of Ty Coon>, 1 April 1989\n  Ty Coon, President of Vice\n\nThis General Public License does not permit incorporating your program into\nproprietary programs.  If your program is a subroutine library, you may\nconsider it more useful to permit linking proprietary applications with the\nlibrary.  If this is what you want to do, use the GNU Lesser General\nPublic License instead of this License.\n"
        },
        {
          "name": "MANIFEST.in",
          "type": "blob",
          "size": 0.0576171875,
          "content": "include README.md\ninclude LICENSE\ninclude requirements.txt\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 19.8212890625,
          "content": "# Patator\n\nPatator was written out of frustration from using Hydra, Medusa, Ncrack, Metasploit modules and Nmap NSE scripts for password guessing attacks. I opted for a different approach in order to not create yet another brute-forcing tool and avoid repeating the same shortcomings. Patator is a multi-threaded tool written in Python, that strives to be more reliable and flexible than his fellow predecessors.\n\nCurrently it supports the following modules:\n\n```\n* ftp_login      : Brute-force FTP\n* ssh_login      : Brute-force SSH\n* telnet_login   : Brute-force Telnet\n* smtp_login     : Brute-force SMTP\n* smtp_vrfy      : Enumerate valid users using the SMTP VRFY command\n* smtp_rcpt      : Enumerate valid users using the SMTP RCPT TO command\n* finger_lookup  : Enumerate valid users using Finger\n* http_fuzz      : Brute-force HTTP/HTTPS\n* rdp_gateway    : Brute-force RDP Gateway\n* ajp_fuzz       : Brute-force AJP\n* pop_login      : Brute-force POP\n* pop_passd      : Brute-force poppassd (not POP3)\n* imap_login     : Brute-force IMAP\n* ldap_login     : Brute-force LDAP\n* dcom_login     : Brute-force DCOM\n* smb_login      : Brute-force SMB\n* smb_lookupsid  : Brute-force SMB SID-lookup\n* rlogin_login   : Brute-force rlogin\n* vmauthd_login  : Brute-force VMware Authentication Daemon\n* mssql_login    : Brute-force MSSQL\n* oracle_login   : Brute-force Oracle\n* mysql_login    : Brute-force MySQL\n* mysql_query    : Brute-force MySQL queries\n* rdp_login      : Brute-force RDP (NLA)\n* pgsql_login    : Brute-force PostgreSQL\n* vnc_login      : Brute-force VNC\n* dns_forward    : Brute-force DNS\n* dns_reverse    : Brute-force DNS (reverse lookup subnets)\n* ike_enum       : Enumerate IKE transforms\n* snmp_login     : Brute-force SNMPv1/2 and SNMPv3\n* unzip_pass     : Brute-force the password of encrypted ZIP files\n* keystore_pass  : Brute-force the password of Java keystore files\n* sqlcipher_pass : Brute-force the password of SQLCipher-encrypted databases\n* umbraco_crack  : Crack Umbraco HMAC-SHA1 password hashes\n```\n\nThe name \"Patator\" comes from [this](https://www.youtube.com/watch?v=9sF9fTALhVA).\n\nPatator is NOT script-kiddie friendly, please read the full README inside [patator.py](patator.py) before reporting.\n\nPlease donate if you like this project! :)\n\n[![paypal](https://www.paypalobjects.com/en_US/i/btn/btn_donateCC_LG.gif)](https://www.paypal.com/cgi-bin/webscr?cmd=_donations&business=SB36VJH4EM5WG&lc=AU&item_name=lanjelot&item_number=patator&currency_code=AUD&bn=PP%2dDonationsBF%3abtn_donateCC_LG%2egif%3aNonHosted)\n\nMany thanks! [@lanjelot](https://twitter.com/lanjelot)\n\n## Install\n\n```\ngit clone https://github.com/lanjelot/patator.git\ngit clone https://github.com/danielmiessler/SecLists.git\ndocker build -t patator patator/\ndocker run -it --rm -v $PWD/SecLists/Passwords:/mnt patator dummy_test data=FILE0 0=/mnt/richelieu-french-top5000.txt\n```\n\n## Usage Examples\n\n* FTP : Enumerating users denied login in `vsftpd/userlist`\n\n```\n$ ftp_login host=10.0.0.1 user=FILE0 0=logins.txt password=asdf -x ignore:mesg='Login incorrect.' -x ignore,reset,retry:code=500\n19:36:06 patator    INFO - Starting Patator v0.7-beta (https://github.com/lanjelot/patator) at 2015-02-08 19:36 AEDT\n19:36:06 patator    INFO -\n19:36:06 patator    INFO - code  size    time | candidate                          |   num | mesg\n19:36:06 patator    INFO - -----------------------------------------------------------------------------\n19:36:07 patator    INFO - 230   17     0.002 | anonymous                          |     7 | Login successful.\n19:36:07 patator    INFO - 230   17     0.001 | ftp                                |    10 | Login successful.\n19:36:08 patator    INFO - 530   18     1.000 | root                               |     1 | Permission denied.\n19:36:17 patator    INFO - 530   18     1.000 | michael                            |    50 | Permission denied.\n19:36:36 patator    INFO - 530   18     1.000 | robert                             |    93 | Permission denied.\n...\n```\n\nTested against `vsftpd-3.0.2-9` on `CentOS 7.0-1406`.\n\n* SSH : Time-based user enumeration\n\n```\n$ ssh_login host=10.0.0.1 user=FILE0 0=logins.txt password=$(perl -e \"print 'A'x50000\") --max-retries 0 --timeout 10 -x ignore:time=0-3\n17:45:20 patator    INFO - Starting Patator v0.7-beta (https://github.com/lanjelot/patator) at 2015-02-08 17:45 AEDT\n17:45:20 patator    INFO -\n17:45:20 patator    INFO - code  size    time | candidate                          |   num | mesg\n17:45:20 patator    INFO - -----------------------------------------------------------------------------\n17:45:30 patator    FAIL - xxx   41    10.001 | root                               |     1 | <class '__main__.TimeoutError'> timed out\n17:45:34 patator    FAIL - xxx   41    10.000 | john                               |    23 | <class '__main__.TimeoutError'> timed out\n17:45:37 patator    FAIL - xxx   41    10.000 | joe                                |    40 | <class '__main__.TimeoutError'> timed out\n...\n```\n\nTested against `openssh-server 1:6.0p1-4+deb7u2` on `Debian 7.8`.\n\n* HTTP : Brute-force phpMyAdmin logon\n\n```\n$ http_fuzz url=http://10.0.0.1/pma/index.php method=POST body='pma_username=COMBO00&pma_password=COMBO01&server=1&target=index.php&lang=en&token=' 0=combos.txt before_urls=http://10.0.0.1/pma/index.php accept_cookie=1 follow=1 -x ignore:fgrep='Cannot log in to the MySQL server' -l /tmp/qsdf\n11:53:47 patator    INFO - Starting Patator v0.7-beta (http://code.google.com/p/patator/) at 2014-08-31 11:53 EST\n11:53:47 patator    INFO -\n11:53:47 patator    INFO - code size:clen       time | candidate                          |   num | mesg\n11:53:47 patator    INFO - -----------------------------------------------------------------------------\n11:53:48 patator    INFO - 200  49585:0        0.150 | root:p@ssw0rd                      |    26 | HTTP/1.1 200 OK\n11:53:51 patator    INFO - 200  13215:0        0.351 | root:                              |    72 | HTTP/1.1 200 OK\n^C\n11:53:54 patator    INFO - Hits/Done/Skip/Fail/Size: 2/198/0/0/3000, Avg: 29 r/s, Time: 0h 0m 6s\n11:53:54 patator    INFO - To resume execution, pass --resume 15,15,15,16,15,36,15,16,15,40\n```\n\nPayload #72 was a false positive due to an unexpected error message:\n\n```\n$ grep AllowNoPassword /tmp/qsdf/72_200\\:13215\\:0\\:0.351.txt\n... class=\"icon ic_s_error\" /> Login without a password is forbidden by configuration (see AllowNoPassword)</div><noscript>\n```\n\nTested against `phpMyAdmin 4.2.7.1`.\n\n* IKEv1 : Enumerate transforms supported by VPN peer\n\n```\n# ike_enum host=10.0.0.1 transform=MOD0 0=TRANS aggressive=RANGE1 1=int:0-1 -x ignore:fgrep='NO-PROPOSAL'\n16:52:58 patator    INFO - Starting Patator v0.7-beta (https://github.com/lanjelot/patator) at 2015-04-05 16:52 AEST\n16:52:58 patator    INFO -\n16:52:58 patator    INFO - code  size    time | candidate                          |   num | mesg\n16:52:58 patator    INFO - -----------------------------------------------------------------------------\n16:53:03 patator    INFO - 0     70     0.034 | 5,1,1,2:0                          |  1539 | Handshake returned: Enc=3DES Hash=MD5 Group=2:modp1024 Auth=PSK (Main)\n16:53:03 patator    INFO - 0     72     0.031 | 5,1,65001,2:0                      |  1579 | Handshake returned: Enc=3DES Hash=MD5 Group=2:modp1024 Auth=XAUTH&PSK (Main)\n16:53:03 patator    INFO - 0     76     0.033 | 5,1,1,2:1                          |  1540 | Handshake returned: Enc=3DES Hash=MD5 Group=2:modp1024 Auth=PSK (Aggressive)\n16:53:03 patator    INFO - 0     78     0.034 | 5,1,65001,2:1                      |  1580 | Handshake returned: Enc=3DES Hash=MD5 Group=2:modp1024 Auth=XAUTH&PSK (Aggressive)\n16:53:06 patator    INFO - 0     84     0.034 | 7/128,2,1,2:0                      |  2371 | Handshake returned: Enc=AES KeyLength=128 Hash=SHA1 Group=2:modp1024 Auth=PSK (Main)\n16:53:06 patator    INFO - 0     90     0.033 | 7/128,2,1,2:1                      |  2372 | Handshake returned: Enc=AES KeyLength=128 Hash=SHA1 Group=2:modp1024 Auth=PSK (Aggressive)\n16:53:06 patator    INFO - 0     86     0.034 | 7/128,2,65001,2:0                  |  2411 | Handshake returned: Enc=AES KeyLength=128 Hash=SHA1 Group=2:modp1024 Auth=XAUTH&PSK (Main)\n16:53:06 patator    INFO - 0     92     0.035 | 7/128,2,65001,2:1                  |  2412 | Handshake returned: Enc=AES KeyLength=128 Hash=SHA1 Group=2:modp1024 Auth=XAUTH&PSK (Aggressive)\n\n+ 10.0.0.1:500 (Main Mode)\n    Encryption       Hash             Auth       Group\n    ---------- ----------       ----------  ----------\n          3DES        MD5              PSK    modp1024\n          3DES        MD5        XAUTH&PSK    modp1024\n        AES128       SHA1              PSK    modp1024\n        AES128       SHA1        XAUTH&PSK    modp1024\n\n+ 10.0.0.1:500 (Aggressive Mode)\n    Encryption       Hash             Auth       Group\n    ---------- ----------       ----------  ----------\n          3DES        MD5              PSK    modp1024\n          3DES        MD5        XAUTH&PSK    modp1024\n        AES128       SHA1              PSK    modp1024\n        AES128       SHA1        XAUTH&PSK    modp1024\n16:53:11 patator    INFO - Hits/Done/Skip/Fail/Size: 8/3840/0/0/3840, Avg: 284 r/s, Time: 0h 0m 13s\n```\n\n* SNMPv3 : Find valid usernames\n\n```\n$ snmp_login host=10.0.0.1 version=3 user=FILE0 0=logins.txt -x ignore:mesg=unknownUserName\n17:51:06 patator    INFO - Starting Patator v0.5\n17:51:06 patator    INFO -\n17:51:06 patator    INFO - code  size | candidate                          |   num | mesg\n17:51:06 patator    INFO - ----------------------------------------------------------------------\n17:51:11 patator    INFO - 0-0   11   | robert                             |    55 | wrongDigest\n17:51:12 patator    INFO - Progress:  20% (70/345) | Speed: 10 r/s | ETC: 17:51:38 (00:00:26 remaining)\n17:51:33 patator    INFO - 0-0   11   | myuser                             |   311 | wrongDigest\n17:51:36 patator    INFO - Hits/Done/Skip/Fail/Size: 2/345/0/0/345, Avg: 11 r/s, Time: 0h 0m 30s\n```\n\n* SNMPv3 : Find valid passwords\n\n```\n$ snmp_login host=10.0.0.1 version=3 user=robert auth_key=FILE0 0=passwords_8+.txt -x ignore:mesg=wrongDigest\n17:52:15 patator    INFO - Starting Patator v0.5\n17:52:15 patator    INFO -\n17:52:15 patator    INFO - code  size | candidate                          |   num | mesg\n17:52:15 patator    INFO - ----------------------------------------------------------------------\n17:52:16 patator    INFO - 0-0   69   | password123                        |    16 | Linux thug 2.6.36-gentoo #5 SMP Fri Aug 12 14:49:51 CEST 2011 i686\n17:52:17 patator    INFO - Hits/Done/Skip/Fail/Size: 1/50/0/0/50, Avg: 38 r/s, Time: 0h 0m 1s\n```\n\n* DNS : Forward lookup\n\n```\n$ dns_forward name=FILE0.hsc.fr 0=names.txt -x ignore:code=3\n03:18:46 patator    INFO - Starting Patator v0.5 (http://code.google.com/p/patator/) at 2012-06-29 03:18 PMT\n03:18:46 patator    INFO -\n03:18:46 patator    INFO - code  size | candidate                          |   num | mesg\n03:18:46 patator    INFO - ----------------------------------------------------------------------\n03:18:46 patator    INFO - 0     41   | www                                |     4 | NOERROR [www.hsc.fr. IN A 217.174.211.25]\n03:18:46 patator    INFO - 0     81   | mail                               |    32 | NOERROR [mail.hsc.fr. IN CNAME itesec.hsc.fr.][itesec.hsc.fr. IN A 192.70.106.33]\n03:18:46 patator    INFO - 0     44   | webmail                            |    62 | NOERROR [webmail.hsc.fr. IN A 192.70.106.95]\n03:18:46 patator    INFO - 0     93   | test                               |    54 | NOERROR [hsc.fr. IN SOA itesec.hsc.fr. hostmaster.hsc.fr. 2012012301 21600 3600 1209600 3600]\n03:18:46 patator    INFO - 0     40   | wap                                |    66 | NOERROR [wap.hsc.fr. IN A 192.70.106.33]\n03:18:46 patator    INFO - 0     85   | extranet                           |   131 | NOERROR [extranet.hsc.fr. IN CNAME itesec.hsc.fr.][itesec.hsc.fr. IN A 192.70.106.33]\n03:18:46 patator    INFO - 0     81   | news                               |   114 | NOERROR [news.hsc.fr. IN CNAME itesec.hsc.fr.][itesec.hsc.fr. IN A 192.70.106.33]\n03:18:46 patator    INFO - 0     93   | mailhost                           |   137 | NOERROR [mailhost.hsc.fr. IN A 192.70.106.33][mailhost.hsc.fr. IN AAAA 2001:7a8:1155:2::abcd]\n03:18:46 patator    INFO - 0     47   | lists                              |   338 | NOERROR [lists.hsc.fr. IN MX 10 itesec.hsc.fr.]\n03:18:46 patator    INFO - 0     93   | fr                                 |   319 | NOERROR [hsc.fr. IN SOA itesec.hsc.fr. hostmaster.hsc.fr. 2012012301 21600 3600 1209600 3600]\n03:18:47 patator    INFO - 0     40   | gl                                 |   586 | NOERROR [gl.hsc.fr. IN A 192.70.106.103]\nRecords ------------------------------------------\n                  extranet.hsc.fr.   IN CNAME   itesec.hsc.fr.\n                        gl.hsc.fr.   IN A       192.70.106.103\n                           hsc.fr.   IN SOA     itesec.hsc.fr. hostmaster.hsc.fr. 2012012301 21600 3600 1209600 3600\n                    itesec.hsc.fr.   IN A       192.70.106.33\n                     lists.hsc.fr.   IN MX      10 itesec.hsc.fr.\n                      mail.hsc.fr.   IN CNAME   itesec.hsc.fr.\n                  mailhost.hsc.fr.   IN A       192.70.106.33\n                  mailhost.hsc.fr.   IN AAAA    2001:7a8:1155:2::abcd\n                      news.hsc.fr.   IN CNAME   itesec.hsc.fr.\n                       wap.hsc.fr.   IN A       192.70.106.33\n                   webmail.hsc.fr.   IN A       192.70.106.95\n                       www.hsc.fr.   IN A       217.174.211.25\nHostmap ------------------------------------------\n                   mailhost.hsc.fr 2001:7a8:1155:2::abcd\n                   mailhost.hsc.fr 192.70.106.33\n                        wap.hsc.fr 192.70.106.33\n                     itesec.hsc.fr 192.70.106.33\n                   extranet.hsc.fr\n                       mail.hsc.fr\n                       news.hsc.fr\n                    webmail.hsc.fr 192.70.106.95\n                         gl.hsc.fr 192.70.106.103\n                        www.hsc.fr 217.174.211.25\nDomains ------------------------------------------\n                            hsc.fr 10\nNetworks -----------------------------------------\n                                   2001:7a8:1155:2::abcd\n                                   192.70.106.x\n                                   217.174.211.25\n03:18:53 patator    INFO - Hits/Done/Skip/Fail/Size: 11/1000/0/0/1000, Avg: 133 r/s, Time: 0h 0m 7s\n```\n\nAlso notice that `test.hsc.fr.` is the start of a new zone because we got NOERROR and no IP address.\n\n* DNS : Reverse lookup two netblocks owned by Google\n\n```\n$ dns_reverse host=NET0 0=216.239.32.0-216.239.47.255,8.8.8.0/24 -x ignore:code=3 -x ignore:fgrep!=google.com -x ignore:fgrep=216-239-\n03:24:22 patator    INFO - Starting Patator v0.5 (http://code.google.com/p/patator/) at 2012-06-29 03:24 PMT\n03:24:22 patator    INFO -\n03:24:22 patator    INFO - code  size | candidate                          |   num | mesg\n03:24:22 patator    INFO - ----------------------------------------------------------------------\n03:24:22 patator    INFO - 0     46   | 216.239.32.10                      |    11 | NOERROR [216.239.32.10 IN PTR ns1.google.com.]\n03:24:22 patator    INFO - 0     45   | 216.239.32.11                      |    12 | NOERROR [216.239.32.11 IN PTR ns.google.com.]\n03:24:22 patator    INFO - 0     48   | 216.239.32.15                      |    16 | NOERROR [216.239.32.15 IN PTR time1.google.com.]\n03:24:23 patator    INFO - 0     47   | 216.239.33.5                       |   262 | NOERROR [216.239.33.5 IN PTR proxy.google.com.]\n03:24:23 patator    INFO - 0     47   | 216.239.33.12                      |   269 | NOERROR [216.239.33.12 IN PTR dns1.google.com.]\n03:24:23 patator    INFO - 0     51   | 216.239.33.22                      |   279 | NOERROR [216.239.33.22 IN PTR transfer.google.com.]\n03:24:23 patator    INFO - 0     50   | 216.239.33.20                      |   277 | NOERROR [216.239.33.20 IN PTR esc-out.google.com.]\n03:24:23 patator    INFO - 0     46   | 216.239.34.10                      |   523 | NOERROR [216.239.34.10 IN PTR ns2.google.com.]\n03:24:23 patator    INFO - 0     48   | 216.239.34.15                      |   528 | NOERROR [216.239.34.15 IN PTR time2.google.com.]\n^C\nRecords ------------------------------------------\n                     216.239.32.10       IN PTR      ns1.google.com.\n                     216.239.32.11       IN PTR      ns.google.com.\n                     216.239.32.15       IN PTR      time1.google.com.\n                     216.239.33.12       IN PTR      dns1.google.com.\n                     216.239.33.20       IN PTR      esc-out.google.com.\n                     216.239.33.22       IN PTR      transfer.google.com.\n                      216.239.33.5       IN PTR      proxy.google.com.\n                     216.239.34.10       IN PTR      ns2.google.com.\n                     216.239.34.15       IN PTR      time2.google.com.\nHostmap ------------------------------------------\n                    ns1.google.com 216.239.32.10\n                     ns.google.com 216.239.32.11\n                  time1.google.com 216.239.32.15\n                  proxy.google.com 216.239.33.5\n                   dns1.google.com 216.239.33.12\n                esc-out.google.com 216.239.33.20\n               transfer.google.com 216.239.33.22\n                    ns2.google.com 216.239.34.10\n                  time2.google.com 216.239.34.15\nDomains ------------------------------------------\n                        google.com 9\nNetworks -----------------------------------------\n                                   216.239.32.x\n                                   216.239.33.x\n                                   216.239.34.x\n03:24:29 patator    INFO - Hits/Done/Skip/Fail/Size: 9/872/0/0/4352, Avg: 115 r/s, Time: 0h 0m 7s\n03:24:29 patator    INFO - To resume execution, pass --resume 91,75,93,73,84,95,94,95,83,89\n```\n\n* ZIP : Crack a password-protected ZIP file (older pkzip encryption used not to be supported in JtR)\n\n```\n$ unzip_pass zipfile=challenge1.zip password=FILE0 0=rockyou.dic -x ignore:code!=0\n10:54:29 patator    INFO - Starting Patator v0.5 (http://code.google.com/p/patator/) at 2012-06-29 10:54:29 PMT\n10:54:29 patator    INFO -\n10:54:29 patator    INFO - code  size | candidate                          |   num | mesg\n10:54:29 patator    INFO - ----------------------------------------------------------------------\n10:54:30 patator    INFO - 0     82   | love                               |   387 | 0 [82] No errors detected in compressed data of challenge1.zip.\n^C\n10:54:31 patator    INFO - Hits/Done/Skip/Fail/Size: 1/1589/0/0/5000, Avg: 699 r/s, Time: 0h 0m 2s\n10:54:31 patator    INFO - To resume execution, pass --resume 166,164,165,166,155,158,148,158,155,154\n```\n\n## PyInstaller\n### Bundling on Windows 5.2.3790 x86\n\nInstall `python-2.7.9.msi` from [Python](https://www.python.org/downloads/windows/).\nInstall `pywin32-219.win32-py2.7.exe` from [PyWin32](http://sourceforge.net/projects/pywin32/files/pywin32/).\nInstall `vcredist_x86.exe` from [Microsoft](http://www.microsoft.com/en-us/download/confirmation.aspx?id=29).\nInstall `Git-1.9.5.exe` from [Git](http://git-scm.com/download/win) (and select \"Use Git from Windows Command Prompt\" during install).\nAdd `c:\\Python27;c:\\Python27\\Scripts` to your `PATH`.\n\n```\npip install pycrypto pyopenssl\npip install impacket\npip install paramiko\npip install IPy\npip install dnspython\npip install pysnmp\n\ncd c:\\\ngit clone https://github.com/lanjelot/patator\ngit clone https://github.com/pyinstaller/pyinstaller\ncd pyinstaller\ngit checkout a2b0617251ebe70412f6e3573f00a49ce08b7b32 # fixes this issue: https://groups.google.com/forum/#!topic/pyinstaller/6xD75_w4F-c\npython pyinstaller.py --clean --onefile c:\\patator\\patator.py\npatator\\dist\\patator.exe -h\n```\n\nThe resulting stand-alone `patator.exe` executable was confirmed to run successfully on Windows 2003 (5.2.3790), Windows 7 (6.1.7600), Windows 2008 R2 SP1 (6.1.7601) and Windows 2012 R2 (6.3.9600), and is likely to work fine on other Windows versions.\n\nRefer to [#50](https://github.com/lanjelot/patator/issues/50) for more info.\n"
        },
        {
          "name": "Vagrantfile",
          "type": "blob",
          "size": 2.576171875,
          "content": "# -*- mode: ruby -*-\n# vi: set ft=ruby :\n\n$apt = <<SCRIPT\nexport DEBIAN_FRONTEND=noninteractive \n\n# refresh\napt-get update -y\n\n# essentials\napt-get install -y tmux git wget build-essential vim\n\n# requirements.txt deps\napt-get install -y libcurl4-openssl-dev python3-dev libssl-dev # pycurl\napt-get install -y ldap-utils # ldapsearch\napt-get install -y libmariadbclient-dev # mysqlclient-python\napt-get install -y libpq-dev # psycopg2\napt-get install -y ike-scan unzip default-jdk\napt-get install -y libsqlite3-dev libsqlcipher-dev # pysqlcipher\n\n# cx_oracle\napt-get install -y libaio1 wget unzip\nrm -fr /opt/oracle\nmkdir /opt/oracle && cd /opt/oracle\nwget https://download.oracle.com/otn_software/linux/instantclient/instantclient-basiclite-linuxx64.zip\nunzip instantclient-basiclite-linuxx64.zip\nrm -f instantclient-basiclite-linuxx64.zip\ncd /opt/oracle/instantclient*\nrm -f *jdbc* *occi* *mysql* *README *jar uidrvci genezi adrci\necho /opt/oracle/instantclient* > /etc/ld.so.conf.d/oracle-instantclient.conf\nldconfig\n\n# xfreerdp (see https://github.com/FreeRDP/FreeRDP/wiki/Compilation)\napt-get install -y ninja-build build-essential git-core debhelper cdbs dpkg-dev autotools-dev cmake pkg-config xmlto libssl-dev docbook-xsl xsltproc libxkbfile-dev libx11-dev libwayland-dev libxrandr-dev libxi-dev libxrender-dev libxext-dev libxinerama-dev libxfixes-dev libxcursor-dev libxv-dev libxdamage-dev libxtst-dev libcups2-dev libpcsclite-dev libasound2-dev libpulse-dev libjpeg-dev libgsm1-dev libusb-1.0-0-dev libudev-dev libdbus-glib-1-dev uuid-dev libxml2-dev libgstreamer1.0-dev libgstreamer-plugins-base1.0-dev libfaad-dev libfaac-dev\napt-get install -y libavutil-dev libavcodec-dev libavresample-dev\nrm -fr /tmp/FreeRDP\ngit clone https://github.com/FreeRDP/FreeRDP/ /tmp/FreeRDP && (cd /tmp/FreeRDP && cmake -DCMAKE_BUILD_TYPE=Debug -DWITH_SSE2=ON . && cmake --build . && sudo cmake --build . --target install)\n\nSCRIPT\n\n$patator = <<SCRIPT\npython3 -m venv patatorenv --without-pip\nsource patatorenv/bin/activate\nwget --quiet -O - https://bootstrap.pypa.io/get-pip.py | python3\npython3 -m pip install patator\n\nSCRIPT\n\nVagrant.configure(2) do |config|\n  config.vm.box = \"ubuntu/bionic64\"\n  config.vm.box_check_update = false\n \n  # prevent TTY error messages\n  config.ssh.shell = \"bash -c 'BASH_ENV=/etc/profile exec bash'\"\n\n  config.vm.provision \"shell\",\n                      inline: $apt,\n                      preserve_order: true,\n                      privileged: true \n\n  config.vm.provision \"shell\",\n                      inline: $patator,\n                      preserve_order: true,\n                      privileged: false\nend\n"
        },
        {
          "name": "docker-compose.yml",
          "type": "blob",
          "size": 1.056640625,
          "content": "version: \"3\"\nservices:\n  unix:\n    build: testing/unix\n    image: patator-unix-testing\n#   ports:\n#      - \"21:21\"\n#      - \"22:22\"\n#      - \"23:23\"\n#      - \"25:25\"\n#      - \"79:79\"\n#      - \"80:80\"\n#      - \"106:106\"\n#      - \"110:110\"\n#      - \"139:139\"\n#      - \"143:143\"\n#      - \"389:389\"\n#      - \"445:445\"\n#      - \"513:513\"\n#      - \"636:636\"\n#      - \"993:993\"\n#      - \"995:995\"\n#      - \"3306:3306\"\n#      - \"4444:4444\"\n#      - \"5432:5432\"\n#      - \"5900:5900\"\n#      - \"8009:8009\"\n#      - \"8080:8080\"\n#      - \"161:161/udp\"\n    volumes:\n      - .:/opt/patator\n\n  oracle:\n    image: oracleinanutshell/oracle-xe-11g\n    environment:\n       - ORACLE_ENABLE_XDB=true\n    ports:\n      - \"1521:1521\"\n\n  mssql:\n    image: mcr.microsoft.com/mssql/server:2019-latest\n    environment:\n      - ACCEPT_EULA=Y\n      - SA_PASSWORD=Password1\n    ports:\n      - \"1433:1433\"\n\n  patator:\n    build: .\n    image: patator\n    depends_on:\n      - unix\n      - oracle\n      - mssql\n    environment:\n      - DISPLAY\n    volumes:\n      - .:/opt/patator\n      - /tmp/.X11-unix:/tmp/.X11-unix\n"
        },
        {
          "name": "patator.py",
          "type": "blob",
          "size": 165.2568359375,
          "content": "#!/usr/bin/env python3\n\n# Copyright (C) 2012 Sebastien MACKE\n#\n# This program is free software; you can redistribute it and/or modify it under\n# the terms of the GNU General Public License version 2, as published by the\n# Free Software Foundation\n#\n# This program is distributed in the hope that it will be useful, but WITHOUT\n# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n# details (http://www.gnu.org/licenses/gpl.txt).\n\nimport sys\n\n__author__  = 'Sebastien Macke'\n__email__   = 'patator@hsc.fr'\n__url__     = 'http://www.hsc.fr/ressources/outils/patator/'\n__git__     = 'https://github.com/lanjelot/patator'\n__twitter__ = 'https://twitter.com/lanjelot'\n__version__ = '1.1-dev'\n__license__ = 'GPLv2'\n__pyver__   = '%d.%d.%d' % sys.version_info[0:3]\n__banner__  = 'Patator %s (%s) with python-%s' % (__version__, __git__, __pyver__)\n\n# README {{{\n'''\nINTRODUCTION\n------------\n\n* What ?\n\nPatator is a multi-purpose brute-forcer, with a modular design and a flexible usage.\n\nCurrently it supports the following modules:\n  + ftp_login      : Brute-force FTP\n  + ssh_login      : Brute-force SSH\n  + telnet_login   : Brute-force Telnet\n  + smtp_login     : Brute-force SMTP\n  + smtp_vrfy      : Enumerate valid users using SMTP VRFY\n  + smtp_rcpt      : Enumerate valid users using SMTP RCPT TO\n  + finger_lookup  : Enumerate valid users using Finger\n  + http_fuzz      : Brute-force HTTP\n  + rdp_gateway    : Brute-force RDP Gateway\n  + ajp_fuzz       : Brute-force AJP\n  + pop_login      : Brute-force POP3\n  + pop_passd      : Brute-force poppassd (http://netwinsite.com/poppassd/)\n  + imap_login     : Brute-force IMAP4\n  + ldap_login     : Brute-force LDAP\n  + dcom_login     : Brute-force DCOM\n  + smb_login      : Brute-force SMB\n  + smb_lookupsid  : Brute-force SMB SID-lookup\n  + rlogin_login   : Brute-force rlogin\n  + vmauthd_login  : Brute-force VMware Authentication Daemon\n  + mssql_login    : Brute-force MSSQL\n  + oracle_login   : Brute-force Oracle\n  + mysql_login    : Brute-force MySQL\n  + mysql_query    : Brute-force MySQL queries\n  * rdp_login      : Brute-force RDP (NLA)\n  + pgsql_login    : Brute-force PostgreSQL\n  + vnc_login      : Brute-force VNC\n\n  + dns_forward    : Forward DNS lookup\n  + dns_reverse    : Reverse DNS lookup\n  + snmp_login     : Brute-force SNMP v1/2/3\n  + ike_enum       : Enumerate IKE transforms\n\n  + unzip_pass     : Brute-force the password of encrypted ZIP files\n  + keystore_pass  : Brute-force the password of Java keystore files\n  + sqlcipher_pass : Brute-force the password of SQLCipher-encrypted databases\n  + umbraco_crack  : Crack Umbraco HMAC-SHA1 password hashes\n\n  + tcp_fuzz       : Fuzz TCP services\n  + dummy_test     : Testing module\n\nFuture modules to be implemented:\n  - rdp_login w/no NLA\n\nThe name \"Patator\" comes from https://www.youtube.com/watch?v=9sF9fTALhVA\n\n* Why ?\n\nBasically, I got tired of using Medusa, Hydra, Ncrack, Metasploit auxiliary modules, Nmap NSE scripts and the like because:\n  - they either do not work or are not reliable (got me false negatives several times in the past)\n  - they are not flexible enough (how to iterate over all wordlists, fuzz any module parameter)\n  - they lack useful features (display progress or pause during execution)\n\n\nFEATURES\n--------\n  * No false negatives, as it is the user that decides what results to ignore based on:\n      + status code of response\n      + size of response\n      + matching string or regex in response data\n      + ... see --help\n\n  * Modular design\n      + not limited to network modules (eg. the unzip_pass module)\n      + not limited to brute-forcing (eg. remote exploit testing, or vulnerable version probing)\n\n  * Interactive runtime\n      + show progress during execution (press Enter)\n      + pause/unpause execution (press p)\n      + increase/decrease verbosity\n      + add new actions & conditions during runtime (eg. to exclude more types of response from showing)\n      + ... press h to see all available interactive commands\n\n  * Use persistent connections (ie. will test several passwords until the server disconnects)\n\n  * Multi-threaded\n\n  * Flexible user input\n    - Any module parameter can be fuzzed:\n      + use the FILE keyword to iterate over a file\n      + use the COMBO keyword to iterate over a combo file\n      + use the NET keyword to iterate over every hosts of a network subnet\n      + use the RANGE keyword to iterate over hexadecimal, decimal or alphabetical ranges\n      + use the PROG keyword to iterate over the output of an external program\n\n    - Iteration over the joined wordlists can be done in any order\n\n  * Save every response (along with request) to separate log files for later reviewing\n\n\nINSTALL\n-------\n\n* Dependencies (best tested versions)\n\n                 |  Required for  |                        URL                         | Version |\n--------------------------------------------------------------------------------------------------\nparamiko         | SSH            | http://www.lag.net/paramiko/                       |   2.7.1 |\n--------------------------------------------------------------------------------------------------\npycurl           | HTTP           | http://pycurl.sourceforge.net/                     |  7.43.0 |\n--------------------------------------------------------------------------------------------------\nlibcurl          | HTTP           | https://curl.haxx.se/                              |  7.58.0 |\n--------------------------------------------------------------------------------------------------\najpy             | AJP            | https://github.com/hypn0s/AJPy/                    |   0.0.4 |\n--------------------------------------------------------------------------------------------------\nopenldap         | LDAP           | http://www.openldap.org/                           |  2.4.45 |\n--------------------------------------------------------------------------------------------------\nimpacket         | SMB, MSSQL     | https://github.com/CoreSecurity/impacket           |  0.9.20 |\n--------------------------------------------------------------------------------------------------\npyOpenSSL        | impacket       | https://pyopenssl.org/                             |  19.1.0 |\n--------------------------------------------------------------------------------------------------\ncx_Oracle        | Oracle         | http://cx-oracle.sourceforge.net/                  |   7.3.0 |\n--------------------------------------------------------------------------------------------------\nmysqlclient      | MySQL          | https://github.com/PyMySQL/mysqlclient-python      |   1.4.6 |\n--------------------------------------------------------------------------------------------------\nxfreerdp         | RDP (NLA)      | https://github.com/FreeRDP/FreeRDP/                |   1.2.0 |\n--------------------------------------------------------------------------------------------------\npsycopg          | PostgreSQL     | http://initd.org/psycopg/                          |   2.8.4 |\n--------------------------------------------------------------------------------------------------\npycrypto         | VNC, impacket  | http://www.dlitz.net/software/pycrypto/            |   2.6.1 |\n--------------------------------------------------------------------------------------------------\ndnspython        | DNS            | http://www.dnspython.org/                          |  1.16.0 |\n--------------------------------------------------------------------------------------------------\nIPy              | NET keyword    | https://github.com/haypo/python-ipy                |     1.0 |\n--------------------------------------------------------------------------------------------------\npysnmp           | SNMP           | http://pysnmp.sourceforge.net/                     |  4.4.12 |\n--------------------------------------------------------------------------------------------------\npyasn1           | SNMP, impacket | http://sourceforge.net/projects/pyasn1/            |   0.4.8 |\n--------------------------------------------------------------------------------------------------\nike-scan         | IKE            | http://www.nta-monitor.com/tools-resources/        |     1.9 |\n--------------------------------------------------------------------------------------------------\nunzip            | ZIP passwords  | http://www.info-zip.org/                           |     6.0 |\n--------------------------------------------------------------------------------------------------\nJava             | keystore files | http://www.oracle.com/technetwork/java/javase/     |       6 |\n--------------------------------------------------------------------------------------------------\npysqlcipher3     | SQLCipher      | https://github.com/rigglemania/pysqlcipher3        |   1.0.3 |\n--------------------------------------------------------------------------------------------------\npython           |                | http://www.python.org/                             |     3.6 |\n--------------------------------------------------------------------------------------------------\n\n* Shortcuts (optional)\nln -s path/to/patator.py /usr/bin/ftp_login\nln -s path/to/patator.py /usr/bin/http_fuzz\netc.\n\n\nUSAGE\n-----\n\n$ python patator.py <module> -h # or\n$ <module> -h                   # if shortcuts were created\n\nThere are global options and module options:\n  - all global options start with - or --\n  - all module options are of the form option=value\n\nAll module options are fuzzable:\n---------\n./module host=FILE0 port=FILE1 foobar=FILE2.google.FILE3 0=hosts.txt 1=ports.txt 2=foo.txt 3=bar.txt\n\nIf a module option starts with the @ character, data will be loaded from the given filename.\n$ ./http_fuzz raw_request=@req.txt 0=vhosts.txt 1=uagents.txt\n\nThe keywords (FILE, COMBO, NET, ...) act as place-holders. They indicate the type of wordlist\nand where to replace themselves with the actual words to test.\n\nEach keyword is numbered in order to:\n  - match the corresponding wordlist\n  - and indicate in what order to iterate over all the wordlists\n\nFor example, this would be the classic order:\n---------\n$ ./module host=FILE0 user=FILE1 password=FILE2 0=hosts.txt 1=logins.txt 2=passwords.txt\n10.0.0.1 root password\n10.0.0.1 root 123456\n10.0.0.1 root qsdfghj\n... (trying all passwords before testing next login)\n10.0.0.1 admin password\n10.0.0.1 admin 123456\n10.0.0.1 admin qsdfghj\n... (trying all logins before testing next host)\n10.0.0.2 root password\n...\n\nWhile a more effective order might be:\n---------\n$ ./module host=FILE2 user=FILE1 password=FILE0 2=hosts.txt 1=logins.txt 0=passwords.txt\n10.0.0.1 root password\n10.0.0.2 root password\n10.0.0.1 admin password\n10.0.0.2 admin password\n10.0.0.1 root 123456\n10.0.0.2 root 123456\n10.0.0.1 admin 123456\n...\n\nBy default Patator iterates over the cartesian product of all payload sets. Use\nthe --groups option to iterate over sets simultaneously instead. For example to\ndistribute all payloads among identical servers:\n---------\n$ ./module name=FILE0.FILE1 resolver=FILE2 0=names.txt 1=domains.txt 2=ips.txt --groups 0,1:2\nftp.abc.fr 8.8.8.8\nftp.xyz.fr 8.8.4.4\ngit.abc.fr 8.8.8.8\ngit.xyz.fr 8.8.4.4\nwww.abc.fr 8.8.8.8\nwww.xyz.fr 8.8.4.4\n\nThe numbers of every keyword given on the command line must be specified.\nUse ',' to iterate over the cartesian product of sets and use ':' to iterate\nover sets simultaneously.\n\n\n* Keywords\n\nBrute-force a list of hosts with a file containing combo entries (each line => login:password).\n---------\n./module host=FILE0 user=COMBO10 password=COMBO11 0=hosts.txt 1=combos.txt\n\nScan subnets to just grab version banners.\n---------\n./module host=NET0 0=10.0.1.0/24,10.0.2.0/24,10.0.3.128-10.0.3.255\n\nFuzz a parameter by iterating over a range of values.\n---------\n./module param=RANGE0 0=hex:0x00-0xffff\n./module param=RANGE0 0=int:0-500\n./module param=RANGE0 0=lower:a-zzz\n\nFuzz a parameter by iterating over the output of an external program.\n---------\n./module param=PROG0 0='john -stdout -i'\n./module param=PROG0 0='mp64.bin ?l?l?l',$(mp64.bin --combination ?l?l?l) # http://hashcat.net/wiki/doku.php?id=maskprocessor\n\n\n* Actions & Conditions\n\nUse the -x option to do specific actions upon receiving specific responses. For example:\n\nIgnore responses with status code 200 *AND* a size within a specific range.\n---------\n./module host=10.0.0.1 user=FILE0 -x ignore:code=200,size=57-74\n\nIgnore responses with status code 500 *OR* containing \"Internal error\".\n---------\n./module host=10.0.0.1 user=FILE0 -x ignore:code=500 -x ignore:fgrep='Internal error'\n\nRemember that conditions are ANDed within the same -x option, use multiple -x options to\nspecify ORed conditions.\n\n\n* Actions skip and free\n\nStop testing the same value from keyword #0 after a valid combination is found.\n---------\n./module data=FILE0.FILE1 -x skip=0:fgrep=Success\n\nStop testing the same combination after a valid match is found.\n---------\n./module data=FILE0.FILE1 data2=RANGE2 -x free=data:fgrep=Success\n\n* Failures\n\nDuring execution, failures may happen, such as a TCP connect timeout for\nexample. By definition a failure is an exception that the module does not expect,\nand as a result the exception is caught upstream by the controller.\n\nSuch exceptions, or failures, are not immediately reported to the user, the\ncontroller will retry 4 more times (see --max-retries) before reporting the\nfailed payload to the user with the logging level \"FAIL\".\n\n\n* Read carefully the following examples to get a good understanding of how patator works.\n{{{ FTP\n\n* Brute-force authentication. Do not report wrong passwords.\n---------\n$ ftp_login host=10.0.0.1 user=FILE0 password=FILE1 0=logins.txt 1=passwords.txt -x ignore:mesg='Login incorrect.'\n\nNB0. If you get errors like \"500 OOPS: priv_sock_get_cmd\", use -x ignore,reset,retry:code=500\n     in order to retry the last login/password using a new TCP connection. Odd servers like vsftpd\n     return this when they shut down the TCP connection (ie. max login attempts reached).\n\nNB1. If you get errors like \"too many connections from your IP address\", try decreasing the number of\n     threads, the server may be enforcing a maximum number of concurrent connections.\n\n* Same as before, but stop testing a user after his password is found.\n---------\n$ ftp_login ... -x free=user:code=0\n\n\n* Find anonymous FTP servers on a subnet.\n---------\n$ ftp_login host=NET0 user=anonymous password=test@example.com 0=10.0.0.0/24\n\n}}}\n{{{ SSH\n* Brute-force authentication with password same as login (aka single mode). Do not report wrong passwords.\n---------\n$ ssh_login host=10.0.0.1 user=FILE0 password=FILE0 0=logins.txt -x ignore:mesg='Authentication failed.'\n\nNB. If you get errors like \"Error reading SSH protocol banner ... Connection reset by peer\",\n    try decreasing the number of threads, the server may be enforcing a maximum\n    number of concurrent connections (eg. MaxStartups in OpenSSH).\n\n\n* Brute-force several hosts and stop testing a host after a valid password is found.\n---------\n$ ssh_login host=FILE0 user=FILE1 password=FILE2 0=hosts.txt 1=logins.txt 2=passwords.txt -x free=host:code=0\n\n\n* Same as previous, but stop testing a user on a host after his password is found.\n---------\n$ ssh_login host=FILE0 user=FILE1 password=FILE2 0=hosts.txt 1=logins.txt 2=passwords.txt -x free=host+user:code=0\n\n}}}\n{{{ Telnet\n\n* Brute-force authentication.\n  (a) Enter login after first prompt is detected, enter password after second prompt.\n  (b) The regex to detect the login and password prompts.\n  (c) Reconnect when we get no login prompt back (max number of tries reached or successful login).\n------------                 (a)\n$ telnet_login host=10.0.0.1 inputs='FILE0\\nFILE1' 0=logins.txt 1=passwords.txt \\\n    prompt_re='tux login:|Password:' -x reset:egrep!='Login incorrect.+tux login:'\n    (b)                              (c)\n\nNB. If you get errors like \"telnet connection closed\", try decreasing the number of threads,\n    the server may be enforcing a maximum number of concurrent connections.\n\n}}}\n{{{ SMTP\n\n* Enumerate valid users using the VRFY command.\n  (a) Do not report invalid recipients.\n  (b) Do not report when the server shuts us down with \"421 too many errors\", reconnect and resume testing.\n---------                                         (a)\n$ smtp_vrfy host=10.0.0.1 user=FILE0 0=logins.txt -x ignore:fgrep='User unknown in local recipient table' \\\n    -x ignore,reset,retry:code=421\n    (b)\n\n* Use the RCPT TO command in case the VRFY command is not available.\n---------\n$ smtp_rcpt host=10.0.0.1 user=FILE0@localhost 0=logins.txt helo='ehlo mx.fb.com' mail_from=root\n\n\n* Brute-force authentication.\n  (a) Send a fake hostname (by default your host fqdn is sent)\n---------                  (a)\n$ smtp_login host=10.0.0.1 helo='ehlo its.me.com' user=FILE0@dom.com password=FILE1 0=logins.txt 1=passwords.txt\n\n}}}\n{{{ HTTP\n\n* Find hidden web resources.\n  (a) Use a specific header.\n  (b) Follow redirects.\n  (c) Do not report 404 errors.\n  (d) Retry on 500 errors.\n---------                                          (a)\n$ http_fuzz url=http://localhost/FILE0 0=words.txt header='Cookie: SESSID=A2FD8B2DA4' \\\n    follow=1 -x ignore:code=404 -x ignore,retry:code=500\n    (b)      (c)                (d)\n\nNB. You may be able to go 10 times faster using webef (http://www.hsc.fr/ressources/outils/webef/).\n    It is the fastest HTTP brute-forcer I know, yet at the moment it still lacks useful features\n    that will prevent you from performing the following attacks.\n\n* Brute-force phpMyAdmin logon.\n  (a) Use POST requests.\n  (b) Follow redirects using cookies sent by server.\n  (c) Ignore failed authentications.\n---------                                            (a)         (b)      (b)\n$ http_fuzz url=http://10.0.0.1/phpmyadmin/index.php method=POST follow=1 accept_cookie=1 \\\n    body='pma_username=root&pma_password=FILE0&server=1&lang=en' 0=passwords.txt \\\n    -x ignore:fgrep='Cannot log in to the MySQL server'\n    (c)\n\n* Scan subnet for directory listings.\n  (a) Ignore not matching responses.\n  (b) Save matching responses into directory.\n---------\n$ http_fuzz url=http://NET0/FILE1 0=10.0.0.0/24 1=dirs.txt -x ignore:fgrep!='Index of' \\\n    -l /tmp/directory-listings                             (a)\n    (b)\n\n* Brute-force Basic authentication.\n  (a) Single mode (login == password).\n  (b) Do not report failed login attempts.\n---------\n$ http_fuzz url=http://10.0.0.1/manager/html user_pass=FILE0:FILE0 0=logins.txt -x ignore:code=401\n                                             (a)                                (b)\n\n* Find hidden virtual hosts.\n  (a) Read template from file.\n  (b) Fuzz both the Host and User-Agent headers.\n  (c) Stop testing a virtual host name after a valid one is found.\n---------\n$ echo -e 'Host: FILE0\\nUser-Agent: FILE1' > headers.txt\n$ http_fuzz url=http://10.0.0.1/ header=@headers.txt 0=vhosts.txt 1=agents.txt -x skip=0:code!=404\n                                 (a)                (b)                           (c)\n\n* Brute-force logon using GET requests.\n  (a) Encode everything surrounded by the two tags _@@_ in hexadecimal.\n  (b) Ignore HTTP 200 responses with a content size (header+body) within given range\n      and that also contain the given string.\n  (c) Use a different delimiter string because the comma cannot be escaped.\n---------                                                                     (a)\n$ http_fuzz url='http://10.0.0.1/login?username=admin&password=_@@_FILE0_@@_' -e _@@_:hex \\\n    0=words.txt -x ignore:'code=200|size=1500-|fgrep=Welcome, unauthenticated user' -X '|'\n                (b)                                                                 (c)\n\n* Brute-force logon that enforces two random nonces to be submitted along every POST.\n  (a) First, request the page that provides the nonces as hidden input fields.\n  (b) Use regular expressions to extract the nonces that are to be submitted along the main request.\n---------\n$ http_fuzz url=http://10.0.0.1/login method=POST body='user=admin&pass=FILE0&nonce1=_N1_&nonce2=_N2_' 0=passwords.txt accept_cookie=1 \\\n before_urls=http://10.0.0.1/index before_egrep='_N1_:<input type=\"hidden\" name=\"nonce1\" value=\"(\\w+)\"|_N2_:name=\"nonce2\" value=\"(\\w+)\"'\n (a)                               (b)\n\n* Test the OPTIONS method against a list of URLs.\n  (a) Ignore URLs that only allow the HEAD and GET methods.\n  (b) Header end of line is '\\r\\n'.\n  (c) Use a different delimiter string because the comma cannot be escaped.\n---------\n$ http_fuzz url=FILE0 0=urls.txt method=OPTIONS -x ignore:egrep='^Allow: HEAD, GET\\r$' -X '|'\n                                                (a)                               (b)  (c)\n}}}\n{{{ LDAP\n\n* Brute-force authentication.\n  (a) Do not report wrong passwords.\n  (b) Talk SSL/TLS to port 636.\n---------\n$ ldap_login host=10.0.0.1 binddn='cn=FILE0,dc=example,dc=com' 0=logins.txt bindpw=FILE1 1=passwords.txt \\\n    -x ignore:mesg='ldap_bind: Invalid credentials (49)' ssl=1 port=636\n    (a)                                                  (b)\n}}}\n{{{ SMB\n\n* Brute-force authentication.\n---------\n$ smb_login host=10.0.0.1 user=FILE0 password=FILE1 0=logins.txt 1=passwords.txt -x ignore:fgrep=STATUS_LOGON_FAILURE\n\nNB. If you suddenly get STATUS_ACCOUNT_LOCKED_OUT errors for an account although\n    it is not the first password you test on this account, then you must have locked it.\n\n* Pass-the-hash.\n  (a) Test a list of hosts.\n  (b) Test every user (each line := login:rid:LM hash:NT hash).\n---------\n$ smb_login host=FILE0 0=hosts.txt user=COMBO10 password_hash=COMBO12:COMBO13 1=pwdump.txt -x ...\n            (a)                                 (b)\n}}}\n{{{ rlogin\n\n* Brute-force usernames that root might be allowed to login as with no password (eg. a ~/.rhosts file with the line \"+ root\").\n$ rlogin_login host=10.0.0.1 luser=root user=FILE0 0=logins.txt persistent=0 -x ignore:fgrep=Password:\n\n* Brute-force usernames that might be allowed to login as root with no password (eg. a /root/.rhosts file with the line \"+ john\").\n$ rlogin_login host=10.0.0.1 user=root luser=FILE0 0=logins.txt persistent=0 -x ignore:fgrep=Password:\n\n}}}\n{{{ MSSQL\n\n* Brute-force authentication.\n-----------\n$ mssql_login host=10.0.0.1 user=sa password=FILE0 0=passwords.txt -x ignore:fgrep='Login failed for user'\n\n}}}\n{{{ Oracle\nBeware, by default in Oracle, accounts are permanently locked out after 10 wrong passwords,\nexcept for the SYS account.\n\n* Brute-force authentication.\n------------\n$ oracle_login host=10.0.0.1 user=SYS password=FILE0 0=passwords.txt sid=ORCL -x ignore:code=ORA-01017\n\nNB0. With Oracle 10g XE (Express Edition), you do not need to pass a SID.\n\nNB1. If you get ORA-12516 errors, it may be because you reached the limit of\n     concurrent connections or db processes, try using \"--rate-limit 0.5 -t 2\" to be\n     more polite. Also you can run \"alter system set processes=150 scope=spfile;\"\n     and restart your database to get rid of this.\n\n* Brute-force SID.\n------------\n$ oracle_login host=10.0.0.1 sid=FILE0 0=sids.txt -x ignore:code=ORA-12505\n\nNB. Against Oracle9, it may crash (Segmentation fault) as soon as a valid SID is\n    found (cx_Oracle bug). Sometimes, the SID gets printed out before the crash,\n    so try running the same command again if it did not.\n\n}}}\n{{{ MySQL\n\n* Brute-force authentication.\n-----------\n$ mysql_login host=10.0.0.1 user=FILE0 password=FILE0 0=logins.txt -x ignore:fgrep='Access denied for user'\n\n}}}\n{{{ PostgreSQL\n\n* Brute-force authentication.\n-----------\n$ pgsql_login host=10.0.0.1 user=postgres password=FILE0 0=passwords.txt -x ignore:fgrep='password authentication failed'\n\n}}}\n{{{ VNC\nSome VNC servers have built-in anti-bruteforce functionality that temporarily\nblacklists the attacker IP address after too many wrong passwords.\n - RealVNC-4.1.3 or TightVNC-1.3.10 for example, allow 5 failed attempts and\n   then enforce a 10 second delay. For each subsequent failed attempt that\n   delay is doubled.\n - RealVNC-3.3.7 or UltraVNC allow 6 failed attempts and then enforce a 10\n   second delay between each following attempt.\n\n* Brute-force authentication.\n  (a) No need to use more than one thread.\n  (b) Keep retrying the same password when we are blacklisted by the server.\n  (c) Exit execution as soon as a valid password is found.\n---------                                                (a)\n$ vnc_login host=10.0.0.1 password=FILE0 0=passwords.txt --threads 1 \\\n    -x retry:fgrep!='Authentication failure' --max-retries -1 -x quit:code=0\n    (b)                                      (b)              (c)\n}}}\n{{{ DNS\n\n* Brute-force subdomains.\n  (a) Ignore NXDOMAIN responses (rcode 3).\n-----------\n$ dns_forward name=FILE0.google.com 0=names.txt -x ignore:code=3\n                                                (a)\n* Brute-force domain with every possible TLDs.\n-----------\n$ dns_forward name=google.MOD0 0=TLD -x ignore:code=3\n\n* Brute-force SRV records.\n-----------\n$ dns_forward name=MOD0.microsoft.com 0=SRV qtype=SRV -x ignore:code=3\n\n* Grab the version of several hosts.\n-----------\n$ dns_forward server=FILE0 0=hosts.txt name=version.bind qtype=txt qclass=ch\n\n* Reverse lookup several networks.\n  (a) Ignore names that do not contain 'google.com'.\n  (b) Ignore generic PTR records.\n-----------\n$ dns_reverse host=NET0 0=216.239.32.0-216.239.47.255,8.8.8.0/24 -x ignore:code=3 -x ignore:fgrep!=google.com -x ignore:fgrep=216-239-\n                                                                                  (a)                         (b)\n}}}\n{{{ SNMP\n\n* SNMPv1/2 : Find valid community names.\n----------\n$ snmp_login host=10.0.0.1 community=FILE0 0=names.txt -x ignore:mesg='No SNMP response received before timeout'\n\n\n* SNMPv3 : Find valid usernames.\n----------\n$ snmp_login host=10.0.0.1 version=3 user=FILE0 0=logins.txt -x ignore:mesg=unknownUserName\n\n\n* SNMPv3 : Find valid passwords.\n----------\n$ snmp_login host=10.0.0.1 version=3 user=myuser auth_key=FILE0 0=passwords.txt -x ignore:mesg=wrongDigest\n\nNB0. If you get \"notInTimeWindow\" error messages, increase the retries option.\nNB1. SNMPv3 requires passphrases to be at least 8 characters long.\n\n}}}\n{{{ Unzip\n\n* Brute-force the ZIP file password (cracking older pkzip encryption used to be not supported in JtR).\n----------\n$ unzip_pass zipfile=file.zip password=FILE0 0=passwords.txt -x ignore:code!=0\n\n}}}\n\nCHANGELOG\n---------\n\n* v1.0 2023/10/09\n  - updated Dockerfile to ubuntu-22.04\n  - fixed bugs\n\n* v0.9 2020/07/26\n  - fixed encoding bugs\n  - new Dockerfile\n  - new --groups and --auto-progress options\n  - fixed various issues reported on Github\n  - new testing env with docker-compose\n\n* v0.8 2020/03/22\n  - new switches (-R, --csv, --xml, --hits)\n  - new pathasis option for http_fuzz\n  - new rdp_gateway module\n  - fixed various issues reported on Github\n\n* v0.7 2017/12/14\n  - added Python3 support\n  - added Windows support\n  - new --timeout and --allow-ignore-failures options\n  - switched to multiprocesses instead of threads (for --timeout to work on Windows)\n  - new modules: ike_enum, rdp_login, ajp_fuzz, sqlcipher_pass\n  - more info added to XML output\n  - fixed many bugs\n\n* v0.6 2014/08/25\n  - added CSV and XML output formats\n  - added module execution time column\n  - improved RANGE keyword\n  - new modules: rlogin_login, umbrack_crack\n  - minor bug fixes/improvements in http_fuzz and smb_login\n  - added more TLDs to dns_forward\n\n* v0.5 2013/07/05\n  - new modules: mysql_query, tcp_fuzz\n  - new RANGE and PROG keywords (supersedes the reading from stdin feature)\n  - switched to impacket for mssql_login\n  - output more intuitive\n  - fixed connection cache\n  - minor bug fixes\n\n* v0.4 2012/11/02\n  - new modules: smb_lookupsid, finger_lookup, pop_login, imap_login, vmauthd_login\n  - improved connection cache\n  - improved usage, user can now act upon specific responses (eg. stop brute-forcing host if down, or stop testing login if password found)\n  - improved dns brute-forcing presentation\n  - switched to dnspython which is not limited to the IN class (eg. can now scan for {hostname,version}.bind)\n  - rewrote itertools.product to avoid memory over-consumption when using large wordlists\n  - can now read wordlist from stdin\n  - added timeout option to most of the network brute-forcing modules\n  - added SSL and/or TLS support to a few modules\n  - before_egrep now allows more than one expression (ie. useful when more than one random nonce needs to be submitted)\n  - fixed numerous bugs\n\n* v0.3 2011/12/16\n    - minor bugs fixed in http_fuzz\n    - option -e better implemented\n    - better warnings about missing dependencies\n\n* v0.2 2011/12/01\n    - new smtp_login module\n    - several bugs fixed\n\n* v0.1 2011/11/25 : Public release\n\n\nTODO\n----\n  * new option -e ns like in Medusa (not likely to be implemented due to design)\n  * replace dnspython|paramiko|IPy with a better module (scapy|libssh2|netaddr... ?) // https://netaddr.readthedocs.org/en/latest/tutorial_01.html\n'''\n\n# }}}\n\n# logging {{{\nclass Logger:\n  def __init__(self, queue):\n    self.queue = queue\n    self.name = multiprocessing.current_process().name\n\n  def send(self, action, *args):\n    self.queue.put((self.name, action, args))\n\n  def quit(self):\n    self.send('quit')\n\n  def headers(self):\n    self.send('headers')\n\n  def result(self, *args):\n    self.send('result', *args)\n\n  def save_response(self, *args):\n    self.send('save_response', *args)\n\n  def save_hit(self, *args):\n    self.send('save_hit', *args)\n\n  def setLevel(self, level):\n    self.send('setLevel', level)\n\n  def warn(self, msg):\n    self.send('warning', msg)\n\n  def info(self, msg):\n    self.send('info', msg)\n\n  def debug(self, msg):\n    self.send('debug', msg)\n\nimport logging\nclass TXTFormatter(logging.Formatter):\n  def __init__(self, indicatorsfmt):\n    self.resultfmt = '%(asctime)s %(name)-7s %(levelname)7s - ' + ' '.join('%%(%s)%ss' % (k, v) for k, v in indicatorsfmt) + ' | %(candidate)-34s | %(num)5s | %(mesg)s'\n\n    super(TXTFormatter, self).__init__(datefmt='%H:%M:%S')\n\n  def format(self, record):\n    if not record.msg or record.msg == 'headers':\n      fmt = self.resultfmt\n\n    else:\n      if record.levelno == logging.DEBUG:\n        fmt = '%(asctime)s %(name)-7s %(levelname)7s [%(pname)s] %(message)s'\n      else:\n        fmt = '%(asctime)s %(name)-7s %(levelname)7s - %(message)s'\n\n    if PY3:\n      self._style._fmt = fmt\n    else:\n      self._fmt = fmt\n\n    pp = {}\n    for k, v in record.__dict__.items():\n      if k in ['candidate', 'mesg']:\n        pp[k] = repr23(v)\n      else:\n        pp[k] = v\n\n    return super(TXTFormatter, self).format(logging.makeLogRecord(pp))\n\nclass CSVFormatter(logging.Formatter):\n  def __init__(self, indicatorsfmt):\n    fmt = '%(asctime)s,%(levelname)s,'+','.join('%%(%s)s' % name for name, _ in indicatorsfmt)+',%(candidate)s,%(num)s,%(mesg)s'\n\n    super(CSVFormatter, self).__init__(fmt=fmt, datefmt='%H:%M:%S')\n\n  def format(self, record):\n    pp = {}\n    for k, v in record.__dict__.items():\n      if k in ['candidate', 'mesg']:\n        pp[k] = '\"%s\"' % v.replace('\"', '\"\"')\n      else:\n        pp[k] = v\n\n    return super(CSVFormatter, self).format(logging.makeLogRecord(pp))\n\nclass XMLFormatter(logging.Formatter):\n  def __init__(self, indicatorsfmt):\n    fmt = '''<result time=\"%(asctime)s\" level=\"%(levelname)s\">\n''' + '\\n'.join('  <{0}>%({1})s</{0}>'.format(name.replace(':', '_'), name) for name, _ in indicatorsfmt) + '''\n  <candidate>%(candidate)s</candidate>\n  <num>%(num)s</num>\n  <mesg>%(mesg)s</mesg>\n  <target %(target)s/>\n</result>'''\n\n    super(XMLFormatter, self).__init__(fmt=fmt, datefmt='%H:%M:%S')\n\n  def format(self, record):\n    pp = {}\n    for k, v in record.__dict__.items():\n      if isinstance(v, str):\n        pp[k] = xmlescape(v)\n      else:\n        pp[k] = v\n\n    return super(XMLFormatter, self).format(logging.makeLogRecord(pp))\n\nclass MsgFilter(logging.Filter):\n\n  def filter(self, record):\n    if record.msg:\n      return 0\n    else:\n      return 1\n\ndef process_logs(queue, indicatorsfmt, argv, log_dir, runtime_file, csv_file, xml_file, hits_file):\n\n  ignore_ctrlc()\n\n  if PY3:\n    logging._levelToName[logging.ERROR] = 'FAIL'\n    encoding = 'latin1'\n  else:\n    logging._levelNames[logging.ERROR] = 'FAIL'\n    encoding = None\n\n  handler_out = logging.StreamHandler()\n  handler_out.setFormatter(TXTFormatter(indicatorsfmt))\n\n  logger = logging.getLogger('patator')\n  logger.setLevel(logging.DEBUG)\n  logger.addHandler(handler_out)\n\n  names = [name for name, _ in indicatorsfmt] + ['candidate', 'num', 'mesg']\n\n  if runtime_file or log_dir:\n    runtime_log = os.path.join(log_dir or '', runtime_file or 'RUNTIME.log')\n\n    with open(runtime_log, 'a') as f:\n      f.write('$ %s\\n' % ' '.join(argv))\n\n    handler_log = logging.FileHandler(runtime_log, encoding=encoding)\n    handler_log.setFormatter(TXTFormatter(indicatorsfmt))\n\n    logger.addHandler(handler_log)\n\n  if csv_file or log_dir:\n    results_csv = os.path.join(log_dir or '', csv_file or 'RESULTS.csv')\n\n    if not os.path.exists(results_csv):\n      with open(results_csv, 'w') as f:\n        f.write('time,level,%s\\n' % ','.join(names))\n\n    handler_csv = logging.FileHandler(results_csv, encoding=encoding)\n    handler_csv.addFilter(MsgFilter())\n    handler_csv.setFormatter(CSVFormatter(indicatorsfmt))\n\n    logger.addHandler(handler_csv)\n\n  if xml_file or log_dir:\n    results_xml = os.path.join(log_dir or '', xml_file or 'RESULTS.xml')\n\n    if not os.path.exists(results_xml):\n      with open(results_xml, 'w') as f:\n        f.write('<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n<root>\\n')\n        f.write('<start utc=%s local=%s/>\\n' % (xmlquoteattr(strfutctime()), xmlquoteattr(strflocaltime())))\n        f.write('<cmdline>%s</cmdline>\\n' % xmlescape(' '.join(argv)))\n        f.write('<module>%s</module>\\n' % xmlescape(argv[0]))\n        f.write('<options>\\n')\n\n        i = 0\n        del argv[0]\n        while i < len(argv):\n          arg = argv[i]\n          if arg[0] == '-':\n            if arg in ('-d', '--debug', '--allow-ignore-failures', '-y'):\n              f.write('  <option type=\"global\" name=%s/>\\n' % xmlquoteattr(arg))\n            else:\n              if not arg.startswith('--') and len(arg) > 2:\n                name, value = arg[:2], arg[2:]\n              elif '=' in arg:\n                name, value = arg.split('=', 1)\n              else:\n                name, value = arg, argv[i+1]\n                i += 1\n              f.write('  <option type=\"global\" name=%s>%s</option>\\n' % (xmlquoteattr(name), xmlescape(value)))\n          else:\n            name, value = arg.split('=', 1)\n            f.write('  <option type=\"module\" name=%s>%s</option>\\n' % (xmlquoteattr(name), xmlescape(value)))\n          i += 1\n        f.write('</options>\\n')\n        f.write('<results>\\n')\n\n    else:  # remove \"</results>...</root>\"\n      with open(results_xml, 'r+b') as f:\n        offset = f.read().find(b'</results>')\n        if offset != -1:\n          f.seek(offset)\n          f.truncate(f.tell())\n\n    handler_xml = logging.FileHandler(results_xml, encoding=encoding)\n    handler_xml.addFilter(MsgFilter())\n    handler_xml.setFormatter(XMLFormatter(indicatorsfmt))\n\n    logger.addHandler(handler_xml)\n\n  if hits_file:\n    if os.path.exists(hits_file):\n      os.rename(hits_file, hits_file + '.' + strftime(\"%Y%m%d%H%M%S\", localtime()))\n\n  while True:\n\n    pname, action, args = queue.get()\n\n    if action == 'quit':\n      if xml_file or log_dir:\n        with open(results_xml, 'a') as f:\n          f.write('</results>\\n<stop utc=%s local=%s/>\\n</root>\\n' % (xmlquoteattr(strfutctime()), xmlquoteattr(strflocaltime())))\n      break\n\n    elif action == 'headers':\n\n      logger.info(' '*77)\n      logger.info('headers', extra=dict((n, n) for n in names))\n      logger.info('-'*77)\n\n    elif action == 'result':\n\n      typ, resp, candidate, num = args\n\n      results = [(name, value) for (name, _), value in zip(indicatorsfmt, resp.indicators())]\n      results += [('candidate', candidate), ('num', num), ('mesg', str(resp)), ('target', resp.str_target())]\n\n      if typ == 'fail':\n        logger.error(None, extra=dict(results))\n      else:\n        logger.info(None, extra=dict(results))\n\n    elif action == 'save_response':\n\n      resp, num = args\n\n      if log_dir:\n        filename = '%d_%s' % (num, '-'.join(map(str, resp.indicators())))\n        with open('%s.txt' % os.path.join(log_dir, filename), 'wb') as f:\n          f.write(resp.dump())\n\n    elif action == 'save_hit':\n      if hits_file:\n        with open(hits_file, 'ab') as f:\n          f.write(b(args[0] +'\\n'))\n\n    elif action == 'setLevel':\n      logger.setLevel(args[0])\n\n    else:  # 'warn', 'info', 'debug'\n      getattr(logger, action)(args[0], extra={'pname': pname})\n\n# }}}\n\n# imports {{{\nimport re\nimport os\nimport sys\nfrom time import localtime, gmtime, strftime, sleep, time\nfrom platform import system\nfrom functools import reduce\nfrom operator import mul, itemgetter\nfrom select import select\nfrom itertools import islice, cycle\nimport string\nimport random\nfrom decimal import Decimal\nfrom base64 import b64encode\nfrom datetime import timedelta, datetime\nimport socket\nimport subprocess\nimport hashlib\nfrom collections import defaultdict\nimport multiprocessing\nimport signal\nimport ctypes\nimport glob\nfrom xml.sax.saxutils import escape as xmlescape, quoteattr as xmlquoteattr\nfrom ssl import SSLContext\nfrom binascii import hexlify, unhexlify\n\nPY3 = sys.version_info >= (3,)\n\nif PY3:\n  from queue import Empty, Full\n  from urllib.parse import quote, urlencode, urlparse, urlunparse, quote_plus, unquote\n  from io import StringIO\n  from sys import maxsize as maxint\nelse:\n  from Queue import Empty, Full\n  from urllib import quote, urlencode, quote_plus, unquote\n  from urlparse import urlparse, urlunparse\n  from cStringIO import StringIO\n  from sys import maxint\n\nif PY3:  # http://python3porting.com/problems.html\n  def b(x):\n    if isinstance(x, bytes):\n      return x\n    else:\n      return x.encode('ISO-8859-1', errors='ignore')\n\n  def B(x):\n    if isinstance(x, str):\n      return x\n    else:\n      return x.decode('ISO-8859-1', errors='ignore')\nelse:\n  def b(x):\n    return x\n\n  def B(x):\n    return x\n\ntry:\n   input = raw_input\nexcept NameError:\n   pass\n\nnotfound = []\ntry:\n  from IPy import IP\n  has_ipy = True\nexcept ImportError:\n  has_ipy = False\n  notfound.append('IPy')\n\ntry:\n  # Python 3.4+\n  if sys.platform.startswith('win'):\n    import multiprocessing.popen_spawn_win32 as forking\n  else:\n    import multiprocessing.popen_fork as forking\nexcept ImportError:\n  import multiprocessing.forking as forking\n\nif sys.platform.startswith('win'):\n  # First define a modified version of Popen.\n  class _Popen(forking.Popen):\n    def __init__(self, *args, **kw):\n      if hasattr(sys, 'frozen'):\n        # We have to set original _MEIPASS2 value from sys._MEIPASS\n        # to get --onefile mode working.\n        os.putenv('_MEIPASS2', sys._MEIPASS)\n      try:\n        super(_Popen, self).__init__(*args, **kw)\n      finally:\n        if hasattr(sys, 'frozen'):\n          # On some platforms (e.g. AIX) 'os.unsetenv()' is not\n          # available. In those cases we cannot delete the variable\n          # but only set it to the empty string. The bootloader\n          # can handle this case.\n          if hasattr(os, 'unsetenv'):\n            os.unsetenv('_MEIPASS2')\n          else:\n            os.putenv('_MEIPASS2', '')\n\n  # Second override 'Popen' class with our modified version.\n  forking.Popen = _Popen\n\nfrom multiprocessing.managers import SyncManager\n\n# }}}\n\n# utils {{{\ndef expand_path(s):\n    return os.path.expandvars(os.path.expanduser(s))\n\ndef strfutctime():\n  return strftime(\"%Y-%m-%d %H:%M:%S\", gmtime())\n\ndef strflocaltime():\n  return strftime(\"%Y-%m-%d %H:%M:%S %Z\", localtime())\n\ndef which(program):\n  def is_exe(fpath):\n    return os.path.exists(fpath) and os.access(fpath, os.X_OK)\n\n  fpath, fname = os.path.split(program)\n  if on_windows() and fname[-4:] != '.exe':\n    fname += '.exe'\n\n  if fpath:\n    if is_exe(program):\n      return program\n  else:\n    for path in os.environ[\"PATH\"].split(os.pathsep):\n      exe_file = os.path.join(path, fname)\n      if is_exe(exe_file):\n        return exe_file\n\n  return None\n\ndef build_logdir(opt_dir, opt_auto, assume_yes):\n    if opt_auto:\n      return create_time_dir(opt_dir or '/tmp/patator', opt_auto)\n    elif opt_dir:\n      return create_dir(opt_dir, assume_yes)\n    else:\n      return None\n\ndef create_dir(top_path, assume_yes):\n  top_path = os.path.abspath(top_path)\n  if os.path.isdir(top_path):\n    files = os.listdir(top_path)\n    if files:\n      if assume_yes or input(\"Directory '%s' is not empty, do you want to wipe it ? [Y/n]: \" % top_path) != 'n':\n        for root, dirs, files in os.walk(top_path):\n          if dirs:\n            print(\"Directory '%s' contains sub-directories, safely aborting...\" % root)\n            sys.exit(0)\n          for f in files:\n            os.unlink(os.path.join(root, f))\n          break\n  else:\n    os.mkdir(top_path)\n  return top_path\n\ndef create_time_dir(top_path, desc):\n  now = localtime()\n  date, time = strftime('%Y-%m-%d', now), strftime('%H%M%S', now)\n  top_path = os.path.abspath(top_path)\n  date_path = os.path.join(top_path, date)\n  time_path = os.path.join(top_path, date, time + '_' + desc)\n\n  if not os.path.isdir(top_path):\n    os.makedirs(top_path)\n  if not os.path.isdir(date_path):\n    os.mkdir(date_path)\n  if not os.path.isdir(time_path):\n    os.mkdir(time_path)\n\n  return time_path\n\ndef pprint_seconds(seconds, fmt):\n  return fmt % reduce(lambda x, y: divmod(x[0], y) + x[1:], [(seconds,), 60, 60])\n\ndef repr23(s):\n  if all(True if 0x20 <= ord(c) < 0x7f else False for c in s):\n    return s\n\n  if PY3:\n    return repr(s.encode('latin1'))[1:]\n  else:\n    return repr(s)\n\ndef md5hex(plain):\n  return hashlib.md5(plain).hexdigest()\n\ndef sha1hex(plain):\n  return hashlib.sha1(plain).hexdigest()\n\ndef html_unescape(s):\n  if PY3:\n    import html\n    return html.unescape(s)\n  else:\n    from HTMLParser import HTMLParser\n    h = HTMLParser()\n    return h.unescape(s)\n\ndef count_lines(filename):\n  with open(filename, 'rb') as f:\n    lines = 0\n    buf_size = 1024 * 1024\n    read_f = f.read\n\n    buf = read_f(buf_size)\n    while buf:\n      lines += buf.count(b'\\n')\n      buf = read_f(buf_size)\n\n    return lines\n\n# I rewrote itertools.product to avoid memory over-consumption when using large wordlists\ndef product(xs, *rest):\n  if len(rest) == 0:\n    for x in xs:\n      yield [x]\n  else:\n    for head in xs:\n      for tail in product(*rest):\n        yield [head] + tail\n\nclass chain:\n  def __init__(self, *iterables):\n    self.iterables = iterables\n\n  def __iter__(self):\n    for iterable in self.iterables:\n      for element in iterable:\n        yield element\n\nclass FileIter:\n  def __init__(self, filename):\n    self.filename = filename\n\n  def __iter__(self):\n    return open(self.filename, 'rb')\n\ndef padhex(d):\n  x = '%x' % d\n  return '0' * (len(x) % 2) + x\n\n# These are examples. You can easily write your own iterator to fit your needs.\n# Or using the PROG keyword, you can call an external program such as:\n#   - seq(1) from coreutils\n#   - http://hashcat.net/wiki/doku.php?id=maskprocessor\n#   - john -stdout -i\n# For example:\n# $ ./dummy_test data=PROG0 0='seq 1 80'\n# $ ./dummy_test data=PROG0 0='mp64.bin ?l?l?l',$(mp64.bin --combination ?l?l?l)\nclass RangeIter:\n\n  def __init__(self, typ, rng, random=None):\n    if typ not in ['hex', 'int', 'float', 'letters', 'lower', 'lowercase', 'upper', 'uppercase']:\n      raise ValueError('Incorrect range type %r' % typ)\n\n    if typ in ('hex', 'int', 'float'):\n\n      m = re.match('(-?[^-]+)-(-?[^-]+)$', rng) # 5-50 or -5-50 or 5--50 or -5--50\n      if not m:\n        raise ValueError('Unsupported range %r' % rng)\n\n      mn = m.group(1)\n      mx = m.group(2)\n\n      if typ in ('hex', 'int'):\n\n        mn = int(mn, 16 if '0x' in mn else 10)\n        mx = int(mx, 16 if '0x' in mx else 10)\n\n        if typ == 'hex':\n          fmt = padhex\n        elif typ == 'int':\n          fmt = '%d'\n\n      elif typ == 'float':\n        mn = Decimal(mn)\n        mx = Decimal(mx)\n\n      if mn > mx:\n        step = -1\n      else:\n        step = 1\n\n    elif typ == 'letters':\n      charset = [c for c in string.ascii_letters]\n\n    elif typ in ('lower', 'lowercase'):\n      charset = [c for c in string.ascii_lowercase]\n\n    elif typ in ('upper', 'uppercase'):\n      charset = [c for c in string.ascii_uppercase]\n\n    def zrange(start, stop, step, fmt):\n      x = start\n      while x != stop+step:\n\n        if callable(fmt):\n          yield fmt(x)\n        else:\n          yield fmt % x\n        x += step\n\n    def letterrange(first, last, charset):\n      for k in range(len(last)):\n        for x in product(*[chain(charset)]*(k+1)):\n          result = ''.join(x)\n          if first:\n            if first != result:\n              continue\n            else:\n              first = None\n          yield result\n          if result == last:\n            return\n\n    if typ == 'float':\n      precision = max(len(str(x).partition('.')[-1]) for x in (mn, mx))\n\n      fmt = '%%.%df' % precision\n      exp = 10**precision\n      step *= Decimal(1) / exp\n\n      self.generator = zrange, (mn, mx, step, fmt)\n      self.size = int(abs(mx-mn) * exp) + 1\n\n      def random_generator():\n        while True:\n          yield fmt % (Decimal(random.randint(mn*exp, mx*exp)) / exp)\n\n    elif typ in ('hex', 'int'):\n      self.generator = zrange, (mn, mx, step, fmt)\n      self.size = abs(mx-mn) + 1\n\n      def random_generator():\n        while True:\n          yield fmt % random.randint(mn, mx)\n\n    else: # letters, lower, upper\n      def count(f):\n        total = 0\n        i = 0\n        for c in f[::-1]:\n          z = charset.index(c) + 1\n          total += (len(charset)**i)*z\n          i += 1\n        return total + 1\n\n      first, last = rng.split('-')\n      self.generator = letterrange, (first, last, charset)\n      self.size = count(last) - count(first) + 1\n\n    if random:\n      self.generator = random_generator, ()\n      self.size = maxint\n\n  def __iter__(self):\n    fn, args = self.generator\n    return fn(*args)\n\n  def __len__(self):\n    return self.size\n\nclass ProgIter:\n  def __init__(self, prog):\n    self.prog = prog\n\n  def __iter__(self):\n    p = subprocess.Popen(self.prog.split(' '), stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n    return p.stdout\n\nclass Progress:\n  def __init__(self):\n    self.current = ''\n    self.done_count = 0\n    self.hits_count = 0\n    self.skip_count = 0\n    self.fail_count = 0\n    self.seconds = [1]*25 # avoid division by zero early bug condition\n\nclass TimeoutError(Exception):\n  pass\n\ndef on_windows():\n  return 'Win' in system()\n\ndef ignore_ctrlc():\n  if on_windows():\n    ctypes.windll.kernel32.SetConsoleCtrlHandler(0, 1)\n  else:\n    signal.signal(signal.SIGINT, signal.SIG_IGN)\n\ndef handle_alarm():\n  if not on_windows():\n    signal.signal(signal.SIGALRM, raise_timeout)\n\ndef raise_timeout(signum, frame):\n  if signum == signal.SIGALRM:\n    raise TimeoutError('timed out')\n\ndef enable_alarm(timeout):\n  if not on_windows():\n    signal.alarm(timeout)\n\ndef disable_alarm():\n  if not on_windows():\n     signal.alarm(0)\n\n# SyncManager.start(initializer) only available since python2.7\nclass MyManager(SyncManager):\n  @classmethod\n  def _run_server(cls, registry, address, authkey, serializer, writer, initializer=None, initargs=()):\n    ignore_ctrlc()\n    super(MyManager, cls)._run_server(registry, address, authkey, serializer, writer)\n\ndef ppstr(s):\n  if isinstance(s, bytes):\n    s = B(s)\n  if not isinstance(s, str):\n    s = str(s)\n  return s.rstrip('\\r\\n')\n\ndef flatten(l):\n  r = []\n  for x in l:\n    if isinstance(x, (list, tuple)):\n      r.extend(map(ppstr, x))\n    else:\n      r.append(ppstr(x))\n  return r\n\ndef parse_query(qs, keep_blank_values=False, encoding='utf-8', errors='replace'):\n  '''Same as urllib.parse.parse_qsl but without replacing '+' with ' '\n  '''\n  pairs = [s2 for s1 in qs.split('&') for s2 in s1.split(';')]\n  r = []\n\n  for name_value in pairs:\n    if not name_value:\n      continue\n    nv = name_value.split('=', 1)\n    if len(nv) != 2:\n      if keep_blank_values:\n        nv.append('')\n      else:\n        continue\n    if len(nv[1]) or keep_blank_values:\n      name = unquote(nv[0], encoding=encoding, errors=errors)\n      value = unquote(nv[1], encoding=encoding, errors=errors)\n      r.append((name, value))\n  return r\n\n# }}}\n\n# Controller {{{\nclass Controller:\n\n  builtin_actions = (\n    ('ignore', 'do not report'),\n    ('retry', 'try payload again'),\n    ('skip', 'stop testing the same keyword value'),\n    ('free', 'stop testing the same option value'),\n    ('quit', 'terminate execution now'),\n    )\n\n  available_encodings = {\n    'hex': (lambda s: B(hexlify(s)), 'encode in hexadecimal'),\n    'unhex': (lambda s: B(unhexlify(s)), 'decode from hexadecimal'),\n    'b64': (lambda s: B(b64encode(b(s))), 'encode in base64'),\n    'md5': (md5hex, 'hash in md5'),\n    'sha1': (sha1hex, 'hash in sha1'),\n    'url': (quote_plus, 'url encode'),\n    }\n\n  def expand_key(self, arg):\n    yield arg.split('=', 1)\n\n  def find_file_keys(self, value):\n    return map(int, re.findall(r'FILE(\\d)', value))\n\n  def find_net_keys(self, value):\n    return map(int, re.findall(r'NET(\\d)', value))\n\n  def find_combo_keys(self, value):\n    return [map(int, t) for t in re.findall(r'COMBO(\\d)(\\d)', value)]\n\n  def find_module_keys(self, value):\n    return map(int, re.findall(r'MOD(\\d)', value))\n\n  def find_range_keys(self, value):\n    return map(int, re.findall(r'RANGE(\\d)', value))\n\n  def find_prog_keys(self, value):\n    return map(int, re.findall(r'PROG(\\d)', value))\n\n  def usage_parser(self, name):\n    from optparse import OptionParser\n    from optparse import OptionGroup\n    from optparse import IndentedHelpFormatter\n\n    class MyHelpFormatter(IndentedHelpFormatter):\n      def format_epilog(self, epilog):\n        return epilog\n\n      def format_heading(self, heading):\n        if self.current_indent == 0 and heading == 'Options':\n          heading = 'Global options'\n        return \"%*s%s:\\n\" % (self.current_indent, \"\", heading)\n\n      def format_usage(self, usage):\n        return '%s\\nUsage: %s\\n' % (__banner__, usage)\n\n    available_actions = self.builtin_actions + self.module.available_actions\n    available_conditions = self.module.Response.available_conditions\n\n    usage = '''%%prog <module-options ...> [global-options ...]\n\nExamples:\n  %s''' % '\\n  '.join(self.module.usage_hints)\n\n    usage += '''\n\nModule options:\n%s ''' % ('\\n'.join('  %-14s: %s' % (k, v) for k, v in self.module.available_options))\n\n    epilog = '''\nSyntax:\n -x actions:conditions\n\n    actions    := action[,action]*\n    action     := \"%s\"\n    conditions := condition=value[,condition=value]*\n    condition  := \"%s\"\n''' % ('\" | \"'.join(k for k, v in available_actions),\n       '\" | \"'.join(k for k, v in available_conditions))\n\n    epilog += '''\n%s\n\n%s\n''' % ('\\n'.join('    %-12s: %s' % (k, v) for k, v in available_actions),\n       '\\n'.join('    %-12s: %s' % (k, v) for k, v in available_conditions))\n\n    epilog += '''\nFor example, to ignore all redirects to the home page:\n... -x ignore:code=302,fgrep='Location: /home.html'\n\n -e tag:encoding\n\n    tag        := any unique string (eg. T@G or _@@_ or ...)\n    encoding   := \"%s\"\n\n%s''' % ('\" | \"'.join(k for k in self.available_encodings),\n        '\\n'.join('    %-12s: %s' % (k, v) for k, (f, v) in self.available_encodings.items()))\n\n    epilog += '''\n\nFor example, to encode every password in base64:\n... host=10.0.0.1 user=admin password=_@@_FILE0_@@_ -e _@@_:b64\n\nPlease read the README inside for more examples and usage information.\n'''\n\n    parser = OptionParser(usage=usage, prog=name, epilog=epilog, version=__banner__, formatter=MyHelpFormatter())\n\n    exe_grp = OptionGroup(parser, 'Execution')\n    exe_grp.add_option('-x', dest='actions', action='append', default=[], metavar='arg', help='actions and conditions, see Syntax below')\n    exe_grp.add_option('--start', dest='start', type='int', default=0, metavar='N', help='start from offset N in the product of all payload sets')\n    exe_grp.add_option('--stop', dest='stop', type='int', default=None, metavar='N', help='stop at offset N')\n    exe_grp.add_option('--resume', dest='resume', metavar='r1[,rN]*', help='resume previous run')\n    exe_grp.add_option('-e', dest='encodings', action='append', default=[], metavar='arg', help='encode everything between two tags, see Syntax below')\n    exe_grp.add_option('-C', dest='combo_delim', default=':', metavar='str', help=\"delimiter string in combo files (default is ':')\")\n    exe_grp.add_option('-X', dest='condition_delim', default=',', metavar='str', help=\"delimiter string in conditions (default is ',')\")\n    exe_grp.add_option('--allow-ignore-failures', dest='allow_ignore_failures', action='store_true', help=\"failures cannot be ignored with -x (this is by design to avoid false negatives) this option overrides this safeguard\")\n    exe_grp.add_option('-y', dest='assume_yes', action='store_true', help=\"automatically answer yes for all questions\")\n\n    opt_grp = OptionGroup(parser, 'Optimization')\n    opt_grp.add_option('--rate-limit', dest='rate_limit', type='float', default=0, metavar='N', help='wait N seconds between each attempt (default is 0)')\n    opt_grp.add_option('--timeout', dest='timeout', type='int', default=0, metavar='N', help='wait N seconds for a response before retrying payload (default is 0)')\n    opt_grp.add_option('--max-retries', dest='max_retries', type='int', default=4, metavar='N', help='skip payload after N retries (default is 4) (-1 for unlimited)')\n    opt_grp.add_option('-t', '--threads', dest='num_threads', type='int', default=10, metavar='N', help='number of threads (default is 10)')\n    opt_grp.add_option('--groups', dest='groups', default='', metavar='', help=\"default is to iterate over the cartesian product of all payload sets, use this option to iterate over sets simultaneously instead (aka pitchfork), see syntax inside (default is '0,1..n')\")\n\n    log_grp = OptionGroup(parser, 'Logging')\n    log_grp.add_option('-l', dest='log_dir', metavar='DIR', help=\"save output and response data into DIR \")\n    log_grp.add_option('-L', dest='auto_log', metavar='SFX', help=\"automatically save into DIR/yyyy-mm-dd/hh:mm:ss_SFX (DIR defaults to '/tmp/patator')\")\n    log_grp.add_option('-R', dest='runtime_file', metavar='FILE', help=\"save output to FILE\")\n    log_grp.add_option('--csv', dest='csv_file', metavar='FILE', help=\"save CSV results to FILE\")\n    log_grp.add_option('--xml', dest='xml_file', metavar='FILE', help=\"save XML results to FILE\")\n    log_grp.add_option('--hits', dest='hits_file', metavar='FILE', help=\"save found candidates to FILE\")\n\n    dbg_grp = OptionGroup(parser, 'Debugging')\n    dbg_grp.add_option('-d', '--debug', dest='debug', action='store_true', help='enable debug messages')\n    dbg_grp.add_option('--auto-progress', dest='auto_progress', type='int', default=0, metavar='N', help='automatically display progress every N seconds')\n\n    parser.option_groups.extend([exe_grp, opt_grp, log_grp, dbg_grp])\n\n    return parser\n\n  def parse_usage(self, argv):\n    parser = self.usage_parser(argv[0])\n    opts, args = parser.parse_args(argv[1:])\n\n    if not len(args) > 0:\n      parser.print_usage()\n      print('ERROR: wrong usage. Please read the README inside for more information.')\n      sys.exit(2)\n\n    return opts, args\n\n  def __init__(self, module, argv):\n    self.thread_report = []\n    self.thread_progress = []\n\n    self.payload = {}\n    self.iter_keys = {}\n    self.iter_groups = {}\n    self.enc_keys = []\n\n    self.module = module\n\n    opts, args = self.parse_usage(argv)\n\n    self.combo_delim = opts.combo_delim\n    self.condition_delim = opts.condition_delim\n    self.rate_limit = opts.rate_limit\n    self.timeout = opts.timeout\n    self.max_retries = opts.max_retries\n    self.num_threads = opts.num_threads\n    self.start, self.stop = opts.start, opts.stop\n    self.allow_ignore_failures = opts.allow_ignore_failures\n    self.auto_progress = opts.auto_progress\n    self.auto_progress_next = None\n\n    self.resume = [int(i) for i in opts.resume.split(',')] if opts.resume else None\n\n    manager = MyManager()\n    manager.start()\n\n    self.ns = manager.Namespace()\n    self.ns.actions = {}\n    self.ns.free_list = []\n    self.ns.skip_list = []\n    self.ns.paused = False\n    self.ns.quit_now = False\n    self.ns.start_time = 0\n    self.ns.total_size = 1\n\n    log_queue = multiprocessing.Queue()\n\n    logsvc = multiprocessing.Process(name='LogSvc', target=process_logs, args=(log_queue, module.Response.indicatorsfmt, argv, build_logdir(opts.log_dir, opts.auto_log, opts.assume_yes), opts.runtime_file, opts.csv_file, opts.xml_file, opts.hits_file))\n    logsvc.daemon = True\n    logsvc.start()\n\n    global logger\n    logger = Logger(log_queue)\n\n    if opts.debug:\n      logger.setLevel(logging.DEBUG)\n    else:\n      logger.setLevel(logging.INFO)\n\n    wlists = {}\n    kargs = []\n    for arg in args: # ('host=NET0', '0=10.0.0.0/24', 'user=COMBO10', 'password=COMBO11', '1=combos.txt', 'name=google.MOD2', '2=TLD')\n      logger.debug('arg: %r' % arg)\n      for k, v in self.expand_key(arg):\n        logger.debug('k: %s, v: %s' % (k, v))\n\n        if k.isdigit():\n          wlists[k] = v\n\n        else:\n          if v.startswith('@'):\n            p = expand_path(v[1:])\n            with open(p, 'rb') as f:\n              v = B(f.read())\n\n          kargs.append((k, v))\n\n    iter_vals = [v for k, v in sorted(wlists.items())]\n\n    logger.debug('kargs: %s' % kargs) # [('host', 'NET0'), ('user', 'COMBO10'), ('password', 'COMBO11'), ('name', 'google.MOD2')]\n    logger.debug('iter_vals: %s' % iter_vals) # ['10.0.0.0/24', 'combos.txt', 'TLD']\n\n    for k, v in kargs:\n\n      for e in opts.encodings:\n        meta, enc = e.split(':')\n        if re.search(r'{0}.+?{0}'.format(meta), v):\n          self.enc_keys.append((k, meta, self.available_encodings[enc][0]))\n\n      for i in self.find_file_keys(v):\n        if i not in self.iter_keys:\n          self.iter_keys[i] = ('FILE', iter_vals[i], [])\n        self.iter_keys[i][2].append(k)\n\n      else:\n        for i in self.find_net_keys(v):\n          if i not in self.iter_keys:\n            self.iter_keys[i] = ('NET', iter_vals[i], [])\n          self.iter_keys[i][2].append(k)\n\n          if not has_ipy:\n            print('IPy (https://github.com/haypo/python-ipy) is required for using NET keyword.')\n            print('Please read the README inside for more information.')\n            sys.exit(3)\n\n        else:\n          for i, j in self.find_combo_keys(v):\n            if i not in self.iter_keys:\n              self.iter_keys[i] = ('COMBO', iter_vals[i], [])\n            self.iter_keys[i][2].append((j, k))\n\n          else:\n            for i in self.find_module_keys(v):\n              if i not in self.iter_keys:\n                self.iter_keys[i] = ('MOD', iter_vals[i], [])\n              self.iter_keys[i][2].append(k)\n\n            else:\n              for i in self.find_range_keys(v):\n                if i not in self.iter_keys:\n                  self.iter_keys[i] = ('RANGE', iter_vals[i], [])\n                self.iter_keys[i][2].append(k)\n\n              else:\n                for i in self.find_prog_keys(v):\n                  if i not in self.iter_keys:\n                    self.iter_keys[i] = ('PROG', iter_vals[i], [])\n                  self.iter_keys[i][2].append(k)\n\n                else:\n                  self.payload[k] = v\n\n    if self.iter_keys:\n      if not opts.groups:\n        # default is to iterate over the cartesian product of all payload sets\n        opts.groups = ','.join(map(str, self.iter_keys))\n\n      for i, g in enumerate(opts.groups.split(':')):\n        ks = list(map(int, g.split(',')))\n        for k in ks:\n          if k not in self.iter_keys:\n            raise ValueError('Unknown keyword number %r' % k)\n\n        self.iter_groups[i] = sorted(ks)\n\n    logger.debug('iter_groups: %s' % self.iter_groups) # {0: [0, 1], 1: [2]}\n    logger.debug('iter_keys: %s' % self.iter_keys) # [(0, ('NET', '10.0.0.0/24', ['host'])), (1, ('COMBO', 'combos.txt', [(0, 'user'), (1, 'password')])), (2, ('MOD', 'TLD', ['name']))]\n    logger.debug('enc_keys: %s' % self.enc_keys) # [('password', 'ENC', hex), ('header', 'B64', b64encode), ...\n    logger.debug('payload: %s' % self.payload) # {'host': 'NET0', 'user': 'COMBO10', 'password': 'COMBO11', 'name': 'google.MOD2'}\n\n    self.iter_groups = sorted(self.iter_groups.items())\n    self.iter_keys = sorted(self.iter_keys.items())\n    self.available_actions = [k for k, _ in self.builtin_actions + self.module.available_actions]\n    self.module_actions = [k for k, _ in self.module.available_actions]\n\n    for x in opts.actions:\n      self.update_actions(x)\n\n    logger.debug('actions: %s' % self.ns.actions)\n\n  def update_actions(self, arg):\n    ns_actions = self.ns.actions\n\n    actions, conditions = arg.split(':', 1)\n    for action in actions.split(','):\n\n      conds = [c.split('=', 1) for c in conditions.split(self.condition_delim)]\n\n      if '=' in action:\n        name, opts = action.split('=')\n      else:\n        name, opts = action, None\n\n      if name not in self.available_actions:\n        raise ValueError('Unsupported action %r' % name)\n\n      if name not in ns_actions:\n        ns_actions[name] = []\n\n      ns_actions[name].append((conds, opts))\n\n    self.ns.actions = ns_actions\n\n  def lookup_actions(self, resp):\n    actions = {}\n    for action, conditions in self.ns.actions.items():\n      for condition, opts in conditions:\n        for key, val in condition:\n          if key[-1] == '!':\n            if resp.match(key[:-1], val):\n              break\n          else:\n            if not resp.match(key, val):\n              break\n        else:\n          actions[action] = opts\n    return actions\n\n  def should_free(self, payload):\n    # free_list: [[('host', '10.0.0.1')], [('user', 'anonymous')], [('host', '10.0.0.7'),('user','test')], ...\n    for l in self.ns.free_list:\n      for k, v in l:\n        if payload[k] != v:\n          break\n      else:\n        return True\n\n    return False\n\n  def register_free(self, payload, opts):\n    self.ns.free_list += [[(k, payload[k]) for k in opts.split('+')]]\n    logger.debug('free_list updated: %s' % self.ns.free_list)\n\n  def should_skip(self, prod):\n    # skip_list: [[(0, '10.0.0.1')], [(1, 'anonymous')], [(0, '10.0.0.7'), (1, 'test')], ...\n    for l in self.ns.skip_list:\n      for k, v in l:\n        if prod[k] != v:\n          break\n      else:\n        return True\n\n    return False\n\n  def register_skip(self, prod, opts):\n    self.ns.skip_list += [[(k, prod[k]) for k in map(int, opts.split('+'))]]\n    logger.debug('skip_list updated: %s' % self.ns.skip_list)\n\n  def fire(self):\n    logger.info('Starting %s at %s' % (__banner__, strftime('%Y-%m-%d %H:%M %Z', localtime())))\n\n    try:\n      self.start_threads()\n      self.monitor_progress()\n    except KeyboardInterrupt:\n      pass\n    except:\n      logging.exception(sys.exc_info()[1])\n    finally:\n      self.ns.quit_now = True\n\n    try:\n      # waiting for reports enqueued by consumers to be flushed\n      while True:\n        active = multiprocessing.active_children()\n        self.report_progress()\n        if not len(active) > 2: # SyncManager and LogSvc\n          break\n        logger.debug('active: %s' % active)\n        sleep(.1)\n    except KeyboardInterrupt:\n      pass\n\n    if self.ns.total_size >= maxint:\n      total_size = -1\n    else:\n      total_size = self.ns.total_size\n\n    total_time = time() - self.ns.start_time\n\n    hits_count = sum(p.hits_count for p in self.thread_progress)\n    done_count = sum(p.done_count for p in self.thread_progress)\n    skip_count = sum(p.skip_count for p in self.thread_progress)\n    fail_count = sum(p.fail_count for p in self.thread_progress)\n\n    speed_avg = done_count / total_time\n\n    self.show_final()\n\n    logger.info('Hits/Done/Skip/Fail/Size: %d/%d/%d/%d/%d, Avg: %d r/s, Time: %s' % (\n      hits_count, done_count, skip_count, fail_count, total_size, speed_avg,\n      pprint_seconds(total_time, '%dh %dm %ds')))\n\n    if done_count < total_size:\n      resume = []\n      for i, p in enumerate(self.thread_progress):\n        c = p.done_count + p.skip_count\n        if self.resume:\n          if i < len(self.resume):\n            c += self.resume[i]\n        resume.append(str(c))\n\n      logger.info('To resume execution, pass --resume %s' % ','.join(resume))\n\n    logger.quit()\n    while len(multiprocessing.active_children()) > 1:\n      sleep(.1)\n\n  def push_final(self, resp): pass\n  def show_final(self): pass\n\n  def start_threads(self):\n\n    task_queues = [multiprocessing.Queue(maxsize=10000) for _ in range(self.num_threads)]\n\n    # consumers\n    for num in range(self.num_threads):\n      report_queue = multiprocessing.Queue(maxsize=1000)\n      t = multiprocessing.Process(name='Consumer-%d' % num, target=self.consume, args=(task_queues[num], report_queue, logger.queue))\n      t.daemon = True\n      t.start()\n      self.thread_report.append(report_queue)\n      self.thread_progress.append(Progress())\n\n    # producer\n    t = multiprocessing.Process(name='Producer', target=self.produce, args=(task_queues, logger.queue))\n    t.daemon = True\n    t.start()\n\n  def produce(self, task_queues, log_queue):\n\n    ignore_ctrlc()\n\n    global logger\n    logger = Logger(log_queue)\n\n    def abort(msg):\n      logger.warn(msg)\n      self.ns.quit_now = True\n\n    psets = {}\n    for k, (t, v, _) in self.iter_keys:\n\n      pset = []\n      size = 0\n\n      if t in ('FILE', 'COMBO'):\n        for name in v.split(','):\n          for fpath in sorted(glob.iglob(expand_path(name))):\n            if not os.path.isfile(fpath):\n              return abort(\"No such file '%s'\" % fpath)\n\n            pset.append(FileIter(fpath))\n            size += count_lines(fpath)\n\n      elif t == 'NET':\n        pset = [IP(n, make_net=True) for n in v.split(',')]\n        size = sum(len(subnet) for subnet in pset)\n\n      elif t == 'MOD':\n        elements, size = self.module.available_keys[v]()\n        pset = [elements]\n\n      elif t == 'RANGE':\n        for r in v.split(','):\n          typ, opt = r.split(':', 1)\n\n          try:\n            ri = RangeIter(typ, opt)\n            size += len(ri)\n            pset.append(ri)\n          except ValueError as e:\n            return abort(\"Invalid range '%s' of type '%s', %s\" % (opt, typ, e))\n\n      elif t == 'PROG':\n        m = re.match(r'(.+),(\\d+)$', v)\n        if m:\n          prog, size = m.groups()\n        else:\n          prog, size = v, maxint\n\n        logger.debug('prog: %s, size: %s' % (prog, size))\n\n        pset = [ProgIter(prog)]\n        size = int(size)\n\n      else:\n        return abort('Incorrect keyword %r' % t)\n\n      psets[k] = chain(*pset), size\n\n    logger.debug('payload sets: %r' % psets)\n\n    zipit = []\n    if not psets:\n      total_size = 1\n      zipit.append([''])\n\n    else:\n      group_sizes = {}\n      for i, ks in self.iter_groups:\n        group_sizes[i] = reduce(mul, (size for _, size in [psets[k] for k in ks]))\n\n      logger.debug('group_sizes: %s' % group_sizes)\n\n      total_size = max(group_sizes.values())\n      biggest, _ = max(group_sizes.items(), key=itemgetter(1))\n\n      for i, ks in self.iter_groups:\n\n        r = []\n        for k in ks:\n          pset, _ = psets[k]\n          r.append(pset)\n\n        it = product(*r)\n        if i != biggest:\n          it = cycle(it)\n\n        zipit.append(it)\n\n    logger.debug('zipit: %s' % zipit)\n    logger.debug('total_size: %d' % total_size)\n\n    if self.stop and total_size > self.stop:\n      total_size = self.stop - self.start\n    else:\n      total_size -= self.start\n\n    if self.resume:\n      total_size -= sum(self.resume)\n\n    self.ns.total_size = total_size\n    self.ns.start_time = time()\n\n    logger.headers()\n\n    count = 0\n    for pp in islice(zip(*zipit), self.start, self.stop):\n\n      if self.ns.quit_now:\n        break\n\n      pp = flatten(pp)\n      logger.debug('pp: %s' % pp)\n\n      prod = [''] * len(pp)\n      for _, ks in self.iter_groups:\n        for k in ks:\n          prod[k] = pp.pop(0)\n\n      if self.resume:\n        idx = count % len(self.resume)\n        off = self.resume[idx]\n\n        if count < off * len(self.resume):\n          #logger.debug('Skipping %d %s, resume[%d]: %s' % (count, ':'.join(prod), idx, self.resume[idx]))\n          count += 1\n          continue\n\n      while True:\n        if self.ns.quit_now:\n          break\n\n        try:\n          cid = count % self.num_threads\n          task_queues[cid].put_nowait(prod)\n          break\n        except Full:\n          sleep(.1)\n\n      count += 1\n\n    if not self.ns.quit_now:\n      for q in task_queues:\n        q.put(None)\n\n    logger.debug('producer done')\n\n    while True:\n      if self.ns.quit_now:\n        for q in task_queues:\n          q.cancel_join_thread()\n        break\n      sleep(.5)\n\n    logger.debug('producer exits')\n\n  def consume(self, task_queue, report_queue, log_queue):\n\n    ignore_ctrlc()\n    handle_alarm()\n\n    global logger\n    logger = Logger(log_queue)\n\n    module = self.module()\n\n    def shutdown():\n      if hasattr(module, '__del__'):\n        module.__del__()\n      logger.debug('consumer done')\n\n    while True:\n      if self.ns.quit_now:\n        return shutdown()\n\n      try:\n        prod = task_queue.get_nowait()\n      except Empty:\n        sleep(.1)\n        continue\n\n      if prod is None:\n        return shutdown()\n\n      payload = self.payload.copy()\n\n      for i, (t, _, keys) in self.iter_keys:\n        if t == 'FILE':\n          for k in keys:\n            payload[k] = payload[k].replace('FILE%d' % i, prod[i])\n        elif t == 'NET':\n          for k in keys:\n            payload[k] = payload[k].replace('NET%d' % i, prod[i])\n        elif t == 'COMBO':\n          for j, k in keys:\n            payload[k] = payload[k].replace('COMBO%d%d' % (i, j), prod[i].split(self.combo_delim, max(j for j, _ in keys))[j])\n        elif t == 'MOD':\n          for k in keys:\n            payload[k] = payload[k].replace('MOD%d' % i, prod[i])\n        elif t == 'RANGE':\n          for k in keys:\n            payload[k] = payload[k].replace('RANGE%d' % i, prod[i])\n        elif t == 'PROG':\n          for k in keys:\n            payload[k] = payload[k].replace('PROG%d' % i, prod[i])\n\n      for k, m, e in self.enc_keys:\n        payload[k] = re.sub(r'{0}(.+?){0}'.format(m), lambda m: e(b(m.group(1))), payload[k])\n\n      logger.debug('product: %s' % prod)\n      prod_str = ':'.join(prod)\n\n      if self.should_free(payload):\n        logger.debug('skipping')\n        report_queue.put(('skip', prod_str, None, 0))\n        continue\n\n      if self.should_skip(prod):\n        logger.debug('skipping')\n        report_queue.put(('skip', prod_str, None, 0))\n        continue\n\n      try_count = 0\n      start_time = time()\n\n      while True:\n\n        while self.ns.paused and not self.ns.quit_now:\n          sleep(1)\n\n        if self.ns.quit_now:\n          return shutdown()\n\n        if self.rate_limit > 0:\n          sleep(self.rate_limit)\n\n        if try_count <= self.max_retries or self.max_retries < 0:\n\n          actions = {}\n          try_count += 1\n\n          logger.debug('payload: %s [try %d/%d]' % (payload, try_count, self.max_retries+1))\n\n          try:\n            enable_alarm(self.timeout)\n            resp = module.execute(**payload)\n\n            disable_alarm()\n          except:\n            disable_alarm()\n\n            mesg = '%s %s' % sys.exc_info()[:2]\n            logger.debug('caught: %s' % mesg)\n\n            #logging.exception(sys.exc_info()[1])\n\n            resp = self.module.Response('xxx', mesg, timing=time()-start_time)\n\n            if hasattr(module, 'reset'):\n              module.reset()\n\n            sleep(try_count * .1)\n            continue\n\n        else:\n          actions = {'fail': None}\n\n        actions.update(self.lookup_actions(resp))\n        report_queue.put((actions, prod_str, resp, time() - start_time))\n\n        for name in self.module_actions:\n          if name in actions:\n            getattr(module, name)(**payload)\n\n        if 'free' in actions:\n          self.register_free(payload, actions['free'])\n          break\n\n        if 'skip' in actions:\n          self.register_skip(prod, actions['skip'])\n          break\n\n        if 'fail' in actions:\n          break\n\n        if 'quit' in actions:\n          return shutdown()\n\n        if 'retry' in actions:\n          continue\n\n        break\n\n  def monitor_progress(self):\n    # loop until SyncManager, LogSvc and Producer are the only children left alive\n    while len(multiprocessing.active_children()) > 3 and not self.ns.quit_now:\n      self.report_progress()\n      self.monitor_interaction()\n\n  def report_progress(self):\n    for i, pq in enumerate(self.thread_report):\n      p = self.thread_progress[i]\n\n      while True:\n\n        try:\n          actions, current, resp, seconds = pq.get_nowait()\n          #logger.info('actions reported: %s' % '+'.join(actions))\n\n        except Empty:\n          break\n\n        if actions == 'skip':\n          p.skip_count += 1\n          continue\n\n        if self.resume:\n          offset = p.done_count + self.resume[i]\n        else:\n          offset = p.done_count\n\n        offset = (offset * self.num_threads) + i + 1 + self.start\n\n        p.current = current\n        p.seconds[p.done_count % len(p.seconds)] = seconds\n\n        if 'quit' in actions:\n          self.ns.quit_now = True\n\n        if 'fail' in actions:\n          if not self.allow_ignore_failures or 'ignore' not in actions:\n            logger.result('fail', resp, current, offset)\n\n        elif 'ignore' not in actions:\n          logger.result('hit', resp, current, offset)\n\n        if 'fail' in actions:\n          p.fail_count += 1\n\n        elif 'retry' in actions:\n          continue\n\n        elif 'ignore' not in actions:\n          p.hits_count += 1\n\n          logger.save_response(resp, offset)\n          logger.save_hit(current)\n\n          self.push_final(resp)\n\n        p.done_count += 1\n\n  def monitor_interaction(self):\n\n    def read_command():\n      if on_windows():\n        import msvcrt\n        if not msvcrt.kbhit():\n          sleep(.1)\n          return None\n\n        command = msvcrt.getche()\n        if command == 'x':\n          command += input()\n\n      else:\n        i, _, _ = select([sys.stdin], [], [], .1)\n        if not i or not sys.stdin.isatty():\n          return None\n        command = i[0].readline().strip()\n\n      return command\n\n    command = read_command()\n\n    if command is None:\n      if self.auto_progress == 0:\n        return\n\n      if self.ns.paused:\n        self.auto_progress_next = None\n        return\n\n      if self.auto_progress_next is None:\n        self.auto_progress_next = time() + self.auto_progress\n        return\n\n      if time() < self.auto_progress_next:\n        return\n\n      self.auto_progress_next = None\n      command = ''\n\n    if command == 'h':\n      logger.info('''Available commands:\n       h       show help\n       <Enter> show progress\n       d/D     increase/decrease debug level\n       p       pause progress\n       f       show verbose progress\n       x arg   add monitor condition\n       a       show all active conditions\n       q       terminate execution now\n       ''')\n\n    elif command == 'q':\n      self.ns.quit_now = True\n\n    elif command == 'p':\n      self.ns.paused = not self.ns.paused\n      logger.info(self.ns.paused and 'Paused' or 'Unpaused')\n\n    elif command == 'd':\n      logger.setLevel(logging.DEBUG)\n\n    elif command == 'D':\n      logger.setLevel(logging.INFO)\n\n    elif command == 'a':\n      logger.info(repr(self.ns.actions))\n\n    elif command.startswith('x') or command.startswith('-x'):\n      _, arg = command.split(' ', 1)\n      try:\n        self.update_actions(arg)\n      except ValueError:\n        logger.warn('usage: x actions:conditions')\n\n    else: # show progress\n\n      thread_progress = self.thread_progress\n      num_threads = self.num_threads\n      total_size = self.ns.total_size\n\n      total_count = sum(p.done_count+p.skip_count for p in thread_progress)\n      speed_avg = num_threads / (sum(sum(p.seconds) / len(p.seconds) for p in thread_progress) / num_threads)\n      if total_size >= maxint:\n        etc_time = 'inf'\n        remain_time = 'inf'\n      else:\n        remain_seconds = (total_size - total_count) / speed_avg\n        remain_time = pprint_seconds(remain_seconds, '%02d:%02d:%02d')\n        etc_seconds = datetime.now() + timedelta(seconds=remain_seconds)\n        etc_time = etc_seconds.strftime('%H:%M:%S')\n\n      logger.info('Progress: {0:>3}% ({1}/{2}) | Speed: {3:.0f} r/s | ETC: {4} ({5} remaining) {6}'.format(\n        total_count * 100 // total_size,\n        total_count,\n        total_size,\n        speed_avg,\n        etc_time,\n        remain_time,\n        self.ns.paused and '| Paused' or ''))\n\n      if command == 'f':\n        for i, p in enumerate(thread_progress):\n          total_count = p.done_count + p.skip_count\n          logger.info(' {0:>3}: {1:>3}% ({2}/{3}) {4}'.format(\n            '#%d' % (i+1),\n            int(100*total_count/(1.0*total_size/num_threads)),\n            total_count,\n            total_size/num_threads,\n            p.current))\n\n# }}}\n\n# Response_Base {{{\ndef match_range(size, val):\n  if '-' in val:\n    size_min, size_max = val.split('-')\n\n    if not size_min and not size_max:\n      raise ValueError('Invalid interval')\n\n    elif not size_min: # size == -N\n      return size <= float(size_max)\n\n    elif not size_max: # size == N-\n      return size >= float(size_min)\n\n    else:\n      size_min, size_max = float(size_min), float(size_max)\n      if size_min >= size_max:\n        raise ValueError('Invalid interval')\n\n      return size_min <= size <= size_max\n\n  else:\n    return size == float(val)\n\nclass Response_Base:\n\n  available_conditions = (\n    ('code', 'match status code'),\n    ('size', 'match size (N or N-M or N- or -N)'),\n    ('time', 'match time (N or N-M or N- or -N)'),\n    ('mesg', 'match message'),\n    ('fgrep', 'search for string in mesg'),\n    ('egrep', 'search for regex in mesg'),\n    )\n\n  indicatorsfmt = [('code', -5), ('size', -4), ('time', 7)]\n\n  def __init__(self, code, mesg, timing=0, trace=None):\n    self.code = code\n    self.mesg = mesg\n    self.time = timing.time if isinstance(timing, Timing) else timing\n    self.size = len(mesg)\n    self.trace = trace\n\n  def indicators(self):\n    return self.code, self.size, '%.3f' % self.time\n\n  def __str__(self):\n    return self.mesg\n\n  def match(self, key, val):\n    return getattr(self, 'match_'+key)(val)\n\n  def match_code(self, val):\n    return re.match('%s$' % val, str(self.code))\n\n  def match_size(self, val):\n    return match_range(self.size, val)\n\n  def match_time(self, val):\n    return match_range(self.time, val)\n\n  def match_mesg(self, val):\n    return val == self.mesg\n\n  def match_fgrep(self, val):\n    return val in self.mesg\n\n  def match_egrep(self, val):\n    return re.search(val, self.mesg)\n\n  def dump(self):\n    return b(self.trace or str(self))\n\n  def str_target(self):\n    return ''\n\nclass Timing:\n  def __enter__(self):\n    self.t1 = time()\n    return self\n\n  def __exit__(self, exc_type, exc_value, traceback):\n    self.time = time() - self.t1\n\n# }}}\n\n# TCP_Cache {{{\nclass TCP_Connection:\n  def __init__(self, fp, banner=None):\n    self.fp = fp\n    self.banner = banner\n\n  def close(self):\n    self.fp.close()\n\nclass TCP_Cache:\n\n  available_actions = (\n    ('reset', 'close current connection in order to reconnect next time'),\n    )\n\n  available_options = (\n    ('persistent', 'use persistent connections [1|0]'),\n    )\n\n  def __init__(self):\n    self.cache = {} # '10.0.0.1:22': ('root', conn1), '10.0.0.2:22': ('admin', conn2),\n    self.curr = None\n\n  def __del__(self):\n    for _, (_, c) in self.cache.items():\n      c.close()\n    self.cache.clear()\n\n  def bind(self, host, port, *args, **kwargs):\n\n    hp = '%s:%s' % (host, port)\n    key = ':'.join(map(str, args))\n\n    if hp in self.cache:\n      k, c = self.cache[hp]\n\n      if key == k:\n        self.curr = hp, k, c\n        return c.fp, c.banner\n\n      else:\n        c.close()\n        del self.cache[hp]\n\n    self.curr = None\n\n    logger.debug('connect')\n    conn = self.connect(host, port, *args, **kwargs)\n\n    self.cache[hp] = (key, conn)\n    self.curr = hp, key, conn\n\n    return conn.fp, conn.banner\n\n  def reset(self, **kwargs):\n    if self.curr:\n      hp, _, c = self.curr\n\n      c.close()\n      del self.cache[hp]\n\n      self.curr = None\n\n# }}}\n\n# FTP {{{\nfrom ftplib import FTP, Error as FTP_Error\ntry:\n  from ftplib import FTP_TLS # only available since python 2.7\nexcept ImportError:\n  notfound.append('python')\n\nclass FTP_login(TCP_Cache):\n  '''Brute-force FTP'''\n\n  usage_hints = (\n    '''%prog host=10.0.0.1 user=FILE0 password=FILE1 0=logins.txt 1=passwords.txt'''\n    ''' -x ignore:mesg='Login incorrect.' -x ignore,reset,retry:code=500''',\n    )\n\n  available_options = (\n    ('host', 'target host'),\n    ('port', 'target port [21]'),\n    ('user', 'usernames to test'),\n    ('password', 'passwords to test'),\n    ('tls', 'use TLS [0|1]'),\n    ('timeout', 'seconds to wait for a response [10]'),\n    )\n  available_options += TCP_Cache.available_options\n\n  Response = Response_Base\n\n  def connect(self, host, port, tls, timeout):\n\n    if tls == '0':\n      fp = FTP(timeout=int(timeout))\n    else:\n      fp = FTP_TLS(timeout=int(timeout))\n\n    banner = fp.connect(host, int(port))\n\n    if tls != '0':\n      fp.auth()\n\n    return TCP_Connection(fp, banner)\n\n  def execute(self, host, port='21', tls='0', user=None, password=None, timeout='10', persistent='1'):\n\n    try:\n      with Timing() as timing:\n        fp, resp = self.bind(host, port, tls, timeout=timeout)\n\n      if user is not None or password is not None:\n        with Timing() as timing:\n\n          if user is not None:\n            resp = fp.sendcmd('USER ' + user)\n\n          if password is not None:\n            resp = fp.sendcmd('PASS ' + password)\n\n      logger.debug('No error: %r' % resp)\n      self.reset()\n\n    except FTP_Error as e:\n      logger.debug('FTP_Error: %s' % e)\n      resp = str(e)\n\n    if persistent == '0':\n      self.reset()\n\n    code, mesg = resp.split(' ', 1)\n    return self.Response(code, mesg, timing)\n\n# }}}\n\n# SSH {{{\ntry:\n  from logging import NullHandler # only available since python 2.7\nexcept ImportError:\n  class NullHandler(logging.Handler):\n    def emit(self, record):\n      pass\n\ntry:\n  import paramiko\n  logging.getLogger('paramiko.transport').addHandler(NullHandler())\nexcept ImportError:\n  notfound.append('paramiko')\n\ndef load_keyfile(keyfile):\n  for cls in (paramiko.RSAKey, paramiko.DSSKey, paramiko.ECDSAKey, paramiko.Ed25519Key):\n    try:\n      return cls.from_private_key_file(keyfile)\n    except paramiko.SSHException:\n      pass\n  else:\n    raise\n\nclass SSH_login(TCP_Cache):\n  '''Brute-force SSH'''\n\n  usage_hints = (\n    \"\"\"%prog host=10.0.0.1 user=root password=FILE0 0=passwords.txt -x ignore:mesg='Authentication failed.'\"\"\",\n    )\n\n  available_options = (\n    ('host', 'target host'),\n    ('port', 'target port [22]'),\n    ('user', 'usernames to test'),\n    ('password', 'passwords to test'),\n    ('auth_type', 'type of password authentication to use [password|keyboard-interactive|auto]'),\n    ('keyfile', 'file with RSA, DSA, ECDSA or ED25519 private key to test'),\n    )\n  available_options += TCP_Cache.available_options\n\n  Response = Response_Base\n\n  def connect(self, host, port, user):\n    fp = paramiko.Transport('%s:%s' % (host, int(port)))\n    fp.start_client()\n\n    return TCP_Connection(fp, fp.remote_version)\n\n  def execute(self, host, port='22', user=None, password=None, auth_type='password', keyfile=None, persistent='1'):\n\n    try:\n      with Timing() as timing:\n        fp, banner = self.bind(host, port, user)\n\n      if user is not None:\n\n        if keyfile is not None:\n          key = load_keyfile(keyfile)\n\n        with Timing() as timing:\n\n          if keyfile is not None:\n            fp.auth_publickey(user, key)\n\n          elif password is not None:\n            if auth_type == 'password':\n              fp.auth_password(user, password, fallback=False)\n\n            elif auth_type == 'keyboard-interactive':\n              fp.auth_interactive(user, lambda a, b, c: [password] if len(c) == 1 else [])\n\n            elif auth_type == 'auto':\n              fp.auth_password(user, password, fallback=True)\n\n            else:\n              raise ValueError('Incorrect auth_type %r' % auth_type)\n\n      logger.debug('No error')\n      code, mesg = '0', banner\n\n      self.reset()\n\n    except paramiko.AuthenticationException as e:\n      logger.debug('AuthenticationException: %s' % e)\n      code, mesg = '1', str(e)\n\n    if persistent == '0':\n      self.reset()\n\n    return self.Response(code, mesg, timing)\n\n# }}}\n\n# Telnet {{{\ntry:\n  from telnetlib import Telnet\nexcept ImportError:\n  notfound.append('telnetlib')\n\nclass Telnet_login(TCP_Cache):\n  '''Brute-force Telnet'''\n\n  usage_hints = (\n    \"\"\"%prog host=10.0.0.1 inputs='FILE0\\\\nFILE1' 0=logins.txt 1=passwords.txt\"\"\"\n    \"\"\" prompt_re='login:|Password:' -x ignore:fgrep='Login incorrect'\"\"\",\n    )\n\n  available_options = (\n    ('host', 'target host'),\n    ('port', 'target port [23]'),\n    ('inputs', 'list of values to input'),\n    ('prompt_re', 'regular expression to match prompts [\\w+:]'),\n    ('timeout', 'seconds to wait for a response and for prompt_re to match received data [20]'),\n    )\n  available_options += TCP_Cache.available_options\n\n  Response = Response_Base\n\n  def connect(self, host, port, timeout):\n    self.prompt_count = 0\n    fp = Telnet(host, int(port), int(timeout))\n\n    return TCP_Connection(fp)\n\n  def execute(self, host, port='23', inputs=None, prompt_re='\\w+:', timeout='20', persistent='0'):\n\n    with Timing() as timing:\n      fp, _ = self.bind(host, port, timeout=timeout)\n\n    trace = b''\n    prompt_re = b(prompt_re)\n    timeout = int(timeout)\n\n    if self.prompt_count == 0:\n      _, _, raw = fp.expect([prompt_re], timeout=timeout)\n      logger.debug('raw banner: %r' % raw)\n      trace += raw\n      self.prompt_count += 1\n\n    if inputs is not None:\n      with Timing() as timing:\n\n        for val in inputs.split(r'\\n'):\n          logger.debug('input: %s' % val)\n          cmd = b(val + '\\n') #'\\r\\x00'\n          fp.write(cmd)\n          trace += cmd\n\n          _, _, raw = fp.expect([prompt_re], timeout=timeout)\n          logger.debug('raw %d: %r' % (self.prompt_count, raw))\n          trace += raw\n          self.prompt_count += 1\n\n    if persistent == '0':\n      self.reset()\n\n    mesg = B(raw).strip()\n    return self.Response(0, mesg, timing, trace)\n\n# }}}\n\n# SMTP {{{\nfrom smtplib import SMTP, SMTP_SSL, SMTPException, SMTPResponseException\n\nclass SMTP_Base(TCP_Cache):\n\n  available_options = TCP_Cache.available_options\n  available_options += (\n    ('timeout', 'seconds to wait for a response [10]'),\n    ('host', 'target host'),\n    ('port', 'target port [25]'),\n    ('ssl', 'use SSL [0|1]'),\n    ('helo', 'helo or ehlo command to send after connect [skip]'),\n    ('starttls', 'send STARTTLS [0|1]'),\n    ('user', 'usernames to test'),\n    )\n\n  Response = Response_Base\n\n  def connect(self, host, port, ssl, helo, starttls, timeout):\n\n    if ssl == '0':\n      if not port:\n        port = 25\n      fp = SMTP(timeout=int(timeout))\n    else:\n      if not port:\n        port = 465\n      fp = SMTP_SSL(timeout=int(timeout))\n\n    resp = fp.connect(host, int(port))\n\n    if helo:\n      cmd, name = helo.split(' ', 1)\n\n      if cmd.lower() == 'ehlo':\n        resp = fp.ehlo(name)\n      else:\n        resp = fp.helo(name)\n\n    if not starttls == '0':\n      fp._host = host\n      resp = fp.starttls()\n\n    return TCP_Connection(fp, resp)\n\n\nclass SMTP_vrfy(SMTP_Base):\n  '''Enumerate valid users using SMTP VRFY'''\n\n  usage_hints = (\n    '''%prog host=10.0.0.1 user=FILE0 0=logins.txt [helo='ehlo its.me.com']'''\n    ''' -x ignore:fgrep='User unknown' -x ignore,reset,retry:code=421''',\n    )\n\n  def execute(self, host, port='', ssl='0', helo='', starttls='0', user=None, timeout='10', persistent='1'):\n\n    with Timing() as timing:\n      fp, resp = self.bind(host, port, ssl, helo, starttls, timeout=timeout)\n\n    if user is not None:\n      with Timing() as timing:\n        resp = fp.verify(user)\n\n    if persistent == '0':\n      self.reset()\n\n    code, mesg = resp\n    return self.Response(code, B(mesg), timing)\n\n\nclass SMTP_rcpt(SMTP_Base):\n  '''Enumerate valid users using SMTP RCPT TO'''\n\n  usage_hints = (\n    '''%prog host=10.0.0.1 user=FILE0@localhost 0=logins.txt [helo='ehlo its.me.com']'''\n    ''' [mail_from=bar@example.com] -x ignore:fgrep='User unknown' -x ignore,reset,retry:code=421''',\n    )\n\n  available_options = SMTP_Base.available_options\n  available_options += (\n    ('mail_from', 'sender email [test@example.org]'),\n    )\n\n  def execute(self, host, port='', ssl='0', helo='', starttls='0', mail_from='test@example.org', user=None, timeout='10', persistent='1'):\n\n    with Timing() as timing:\n      fp, resp = self.bind(host, port, ssl, helo, starttls, timeout=timeout)\n\n    if mail_from or user is not None:\n      with Timing() as timing:\n        if mail_from:\n          resp = fp.mail(mail_from)\n        if user is not None:\n          resp = fp.rcpt(user)\n\n    fp.rset()\n\n    if persistent == '0':\n      self.reset()\n\n    code, mesg = resp\n    return self.Response(code, B(mesg), timing)\n\n\nclass SMTP_login(SMTP_Base):\n  '''Brute-force SMTP'''\n\n  usage_hints = (\n    '''%prog host=10.0.0.1 user=f.bar@dom.com password=FILE0 0=passwords.txt [helo='ehlo its.me.com']'''\n    ''' -x ignore:fgrep='Authentication failed' -x ignore,reset,retry:code=421''',\n    )\n\n  available_options = SMTP_Base.available_options\n  available_options += (\n    ('password', 'passwords to test'),\n    )\n\n  def execute(self, host, port='', ssl='0', helo='', starttls='0', user=None, password=None, timeout='10', persistent='1'):\n\n    with Timing() as timing:\n      fp, resp = self.bind(host, port, ssl, helo, starttls, timeout=timeout)\n\n    try:\n      if user is not None and password is not None:\n        with Timing() as timing:\n          resp = fp.login(user, password)\n\n      logger.debug('No error: %s' % str(resp))\n      self.reset()\n\n    except SMTPResponseException as e:\n      logger.debug('SMTPResponseException: %s' % e)\n      resp = e.args\n\n    if persistent == '0':\n      self.reset()\n\n    code, mesg = resp\n    return self.Response(code, B(mesg), timing)\n\n# }}}\n\n# Finger {{{\nclass Controller_Finger(Controller):\n\n  user_list = []\n\n  def push_final(self, resp):\n    if hasattr(resp, 'lines'):\n      for l in resp.lines:\n         if l not in self.user_list:\n           self.user_list.append(l)\n\n  def show_final(self):\n    print('\\n'.join(self.user_list))\n\nclass Finger_lookup:\n  '''Enumerate valid users using Finger'''\n\n  usage_hints = (\n    \"\"\"%prog host=10.0.0.1 user=FILE0 0=words.txt -x ignore:fgrep='no such user'\"\"\",\n    )\n\n  available_options = (\n    ('host', 'target host'),\n    ('port', 'target port [79]'),\n    ('user', 'usernames to test'),\n    ('timeout', 'seconds to wait for a response [5]'),\n    )\n  available_actions = ()\n\n  Response = Response_Base\n\n  def execute(self, host, port='79', user='', timeout='5'):\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.settimeout(int(timeout))\n\n    with Timing() as timing:\n      s.connect((host, int(port)))\n\n    if user:\n      s.send(b(user))\n    s.send(b'\\r\\n')\n\n    raw = b''\n    with Timing() as timing:\n      while True:\n        resp = s.recv(1024)\n        if not resp:\n          break\n        raw += resp\n\n    s.close()\n\n    logger.debug('recv: %r' % raw)\n\n    mesg = B(raw).strip()\n\n    resp = self.Response(0, mesg, timing, raw)\n    resp.lines = [l.strip('\\r\\n') for l in mesg.split('\\n')]\n\n    return resp\n# }}}\n\n# DCOM {{{\ntry:\n  from impacket.dcerpc.v5 import transport\n  from impacket.uuid import uuidtup_to_bin\n  from impacket.dcerpc.v5.rpcrt import RPC_C_AUTHN_LEVEL_PKT_PRIVACY, RPC_C_AUTHN_LEVEL_NONE, RPC_C_AUTHN_WINNT, DCERPCException, rpc_status_codes\n  from impacket.dcerpc.v5.ndr import NDRCALL\nexcept ImportError:\n  notfound.append('impacket')\n\nclass DCOM_login:\n  '''Brute-force DCOM'''\n\n  usage_hints = (\n    \"\"\"%prog host=10.0.0.1 port=49667 uuid=12345678-1234-ABCD-EF00-0123456789AB ver=1.0 user='admin' password=FILE0 0=passwords.txt (authtype=0/9/10/14/16/68/255 authlevel=1/2/3/4/5/6)\"\"\",\n    )\n\n  available_options = (\n    ('host', 'target host'),\n    ('port', 'target port'),\n    ('uuid', 'UUID of RPC interface'),\n    ('ver', 'version of RPC interface'),\n    ('opnum', 'opnum of RPC interface'),\n    ('syntax', 'transfer syntax of RPC interface'),\n    ('domain', 'domains to test'),\n    ('user', 'usernames to test'),\n    ('password', 'passwords to test'),\n    ('lmhash', 'LM-hash to test'),\n    ('nthash', 'NT-hash to test'),\n    ('aeskey', 'AES-hash to test'),\n    ('tgt', 'TGT-ticket to test'),\n    ('tgs', 'TGS-ticket to test'),\n    ('authtype', 'auth type (security provider)'),\n    ('authlevel', 'auth level'),\n    )\n  available_actions = ()\n\n  Response = Response_Base\n\n  def execute(self, host, port, uuid, ver, opnum='0', syntax='8a885d04-1ceb-11c9-9fe8-08002b104860:2.0', domain='', user='', password='', lmhash='', nthash='', aeskey=None, tgt=None, tgs=None, authtype=RPC_C_AUTHN_WINNT, authlevel=RPC_C_AUTHN_LEVEL_PKT_PRIVACY):\n    stringBinding = r'ncacn_ip_tcp:%s[%s]' % (host,port)\n    rpctransport = transport.DCERPCTransportFactory(stringBinding)\n    dce = rpctransport.get_dce_rpc()\n    dce.set_auth_type(int(authtype))\n    if user or password or lmhash or nthash or aeskey or tgt or tgs:\n      dce.set_credentials(user, password, domain, lmhash, nthash, aeskey, tgt, tgs)\n      dce.set_auth_level(int(authlevel))\n    else:\n      dce.set_auth_level(RPC_C_AUTHN_LEVEL_NONE)\n    timing = 0\n    try:\n      dce.connect()\n      with Timing() as timing:\n        dce.bind(uuidtup_to_bin((uuid,ver)), transfer_syntax=syntax.split(\":\"))\n        dce.call(int(opnum), NDRCALL())\n        res = dce.recv()\n        code, mesg = 0, 'none'\n    except DCERPCException as e:\n      mesg = e.error_string\n      code = [key for key, val in rpc_status_codes.items() if val == mesg][0] if [key for key, val in rpc_status_codes.items() if val == mesg] else -1\n    dce.disconnect()\n    return self.Response(code, mesg, timing)\n\n# }}}\n\n# LDAP {{{\nif not which('ldapsearch'):\n  notfound.append('openldap')\n\n# Because python-ldap-2.4.4 did not allow using a PasswordPolicyControl\n# during bind authentication (cf. http://article.gmane.org/gmane.comp.python.ldap/1003),\n# I chose to wrap around ldapsearch with \"-e ppolicy\".\n\nclass LDAP_login:\n  '''Brute-force LDAP'''\n\n  usage_hints = (\n    \"\"\"%prog host=10.0.0.1 binddn='cn=Directory Manager' bindpw=FILE0 0=passwords.txt\"\"\"\n    \"\"\" -x ignore:mesg='ldap_bind: Invalid credentials (49)'\"\"\",\n    )\n\n  available_options = (\n    ('host', 'target host'),\n    ('port', 'target port [389]'),\n    ('binddn', 'usernames to test'),\n    ('bindpw', 'passwords to test'),\n    ('basedn', 'base DN for search'),\n    ('ssl', 'use SSL/TLS [0|1]'),\n    )\n  available_actions = ()\n\n  Response = Response_Base\n\n  def execute(self, host, port='389', binddn='', bindpw='', basedn='', ssl='0'):\n    uri = 'ldap%s://%s:%s' % ('s' if ssl != '0' else '', host, port)\n    cmd = ['ldapsearch', '-H', uri, '-e', 'ppolicy', '-D', binddn, '-w', bindpw, '-b', basedn, '-s', 'one']\n\n    with Timing() as timing:\n      p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, env={'LDAPTLS_REQCERT': 'never'})\n      out, err = map(B, p.communicate())\n      code = p.returncode\n\n    mesg = (out + err).strip()\n    trace = '%s\\n[out]\\n%s\\n[err]\\n%s\\n' % (' '.join(cmd), out, err)\n\n    return self.Response(code, mesg, timing, trace)\n\n# }}}\n\n# SMB {{{\ntry:\n  from impacket.smbconnection import SMBConnection, SessionError\n  from impacket import nt_errors\n  from impacket.dcerpc.v5 import transport, lsat, lsad\n  from impacket.dcerpc.v5.samr import SID_NAME_USE\n  from impacket.dcerpc.v5.dtypes import MAXIMUM_ALLOWED\n  from impacket.dcerpc.v5.rpcrt import DCERPCException\nexcept ImportError:\n  notfound.append('impacket')\n\nclass SMB_Connection(TCP_Connection):\n  def close(self):\n    self.fp.getSMBServer().get_socket().close()\n\nclass Response_SMB(Response_Base):\n  indicatorsfmt = [('code', -8), ('size', -4), ('time', 6)]\n\ndef split_ntlm(password_hash):\n    if password_hash:\n      if ':' in password_hash:\n        lmhash, nthash = password_hash.split(':')\n      else:\n        lmhash, nthash = 'aad3b435b51404eeaad3b435b51404ee', password_hash\n    else:\n      lmhash, nthash = '', ''\n\n    return lmhash, nthash\n\nclass SMB_login(TCP_Cache):\n  '''Brute-force SMB'''\n\n  usage_hints = (\n    \"\"\"%prog host=10.0.0.1 user=FILE0 password=FILE1 0=logins.txt 1=passwords.txt\"\"\"\n    \"\"\" -x ignore:fgrep='unknown user name or bad password'\"\"\",\n    )\n\n  available_options = (\n    ('host', 'target host'),\n    ('port', 'target port [139]'),\n    ('user', 'usernames to test'),\n    ('password', 'passwords to test'),\n    ('password_hash', \"LM/NT hashes to test, at least one hash must be provided ('lm:nt' or ':nt' or 'lm:')\"),\n    ('domain', 'domain to test'),\n    )\n  available_options += TCP_Cache.available_options\n\n  Response = Response_SMB\n\n  def connect(self, host, port):\n    # if port == 445, impacket will use <host> instead of '*SMBSERVER' as the remote_name\n    fp = SMBConnection('*SMBSERVER', host, sess_port=int(port))\n\n    return SMB_Connection(fp)\n\n  def execute(self, host, port='139', user=None, password='', password_hash=None, domain='', persistent='1'):\n\n    with Timing() as timing:\n      fp, _ = self.bind(host, port)\n\n    try:\n      if user is None:\n        fp.login('', '') # retrieve workgroup/domain and computer name\n      else:\n        with Timing() as timing:\n          if password_hash:\n            lmhash, nthash = split_ntlm(password_hash)\n\n            fp.login(user, '', domain, lmhash, nthash)\n          else:\n            fp.login(user, password, domain)\n\n      logger.debug('No error')\n      code, mesg = '0', '%s\\\\%s (%s)' % (fp.getServerDomain(), fp.getServerName(), fp.getServerOS())\n\n      self.reset()\n\n    except SessionError as e:\n      code = '%x' % e.getErrorCode()\n      mesg = nt_errors.ERROR_MESSAGES[e.getErrorCode()][0]\n\n    if persistent == '0':\n      self.reset()\n\n    return self.Response(code, mesg, timing)\n\nclass DCE_Connection(TCP_Connection):\n  def __init__(self, fp, rpct):\n    self.rpct = rpct\n    TCP_Connection.__init__(self, fp)\n\n  def close(self):\n    self.rpct.get_socket().close()\n\n# impacket/examples/lookupsid.py is much faster because it queries 1000 SIDs per packet\nclass SMB_lookupsid(TCP_Cache):\n  '''Brute-force SMB SID-lookup'''\n\n  usage_hints = (\n    '''%prog host=10.0.0.1 sid=S-1-5-21-1234567890-1234567890-1234567890 rid=RANGE0 0=int:500-2000 -x ignore:code=1''',\n    )\n\n  available_options = (\n    ('host', 'target host'),\n    ('port', 'target port [445]'),\n    ('sid', 'SID to test'),\n    ('rid', 'RID to test'),\n    ('user', 'username to use if auth required'),\n    ('password', 'password to use if auth required'),\n    ('password_hash', \"LM/NT hashes to test, at least one hash must be provided ('lm:nt' or ':nt' or 'lm:')\"),\n    ('domain', 'domain to test'),\n    )\n  available_options += TCP_Cache.available_options\n\n  Response = Response_Base\n\n  def connect(self, host, port, user, password, domain, password_hash, sid):\n\n    lmhash, nthash = split_ntlm(password_hash)\n\n    rpctransport = transport.DCERPCTransportFactory(r'ncacn_np:%s[\\pipe\\lsarpc]' % host) # remoteName\n    rpctransport.set_dport(port)\n    rpctransport.setRemoteHost(host)\n    rpctransport.set_credentials(user, password, domain, lmhash, nthash)\n\n    dce = rpctransport.get_dce_rpc()\n    dce.connect()\n    dce.bind(lsat.MSRPC_UUID_LSAT)\n\n    op2 = lsad.hLsarOpenPolicy2(dce, MAXIMUM_ALLOWED | lsat.POLICY_LOOKUP_NAMES)\n\n    if sid is None:\n      res = lsad.hLsarQueryInformationPolicy2(dce, op2['PolicyHandle'], lsad.POLICY_INFORMATION_CLASS.PolicyAccountDomainInformation)\n      sid = res['PolicyInformation']['PolicyAccountDomainInfo']['DomainSid'].formatCanonical()\n\n    self.sid = sid\n    self.policy_handle = op2['PolicyHandle']\n\n    return DCE_Connection(dce, rpctransport)\n\n  def execute(self, host, port='445', user='', password='', password_hash=None, domain='', sid=None, rid=None, persistent='1'):\n\n    dce, _ = self.bind(host, port, user, password, domain, password_hash, sid)\n\n    if rid:\n      sid = '%s-%s' % (self.sid, rid)\n    else:\n      sid = self.sid\n\n    try:\n      res = lsat.hLsarLookupSids(dce, self.policy_handle, [sid], lsat.LSAP_LOOKUP_LEVEL.LsapLookupWksta)\n\n      code, names = 0, []\n      for n, item in enumerate(res['TranslatedNames']['Names']):\n        names.append(\"%s\\\\%s (%s)\" % (res['ReferencedDomains']['Domains'][item['DomainIndex']]['Name'], item['Name'], SID_NAME_USE.enumItems(item['Use']).name[7:]))\n\n    except DCERPCException:\n      code, names = 1, ['unknown'] # STATUS_NONE_MAPPED\n\n    if persistent == '0':\n      self.reset()\n\n    return self.Response(code, ', '.join(names))\n\n# }}}\n\n# POP {{{\nfrom poplib import POP3, POP3_SSL, error_proto as pop_error\n\nclass POP_Connection(TCP_Connection):\n  def close(self):\n    if PY3:\n      self.fp.close()\n    else:\n      self.fp.quit()\n\nclass POP_login(TCP_Cache):\n  '''Brute-force POP3'''\n\n  usage_hints = (\n    '''%prog host=10.0.0.1 user=FILE0 password=FILE1 0=logins.txt 1=passwords.txt -x ignore:code=-ERR''',\n    )\n\n  available_options = (\n    ('host', 'target host'),\n    ('port', 'target port [110]'),\n    ('user', 'usernames to test'),\n    ('password', 'passwords to test'),\n    ('ssl', 'use SSL [0|1]'),\n    ('timeout', 'seconds to wait for a response [10]'),\n    )\n  available_options += TCP_Cache.available_options\n\n  Response = Response_Base\n\n  def connect(self, host, port, ssl, timeout):\n    if ssl == '0':\n      if not port:\n        port = 110\n      fp = POP3(host, int(port), timeout=int(timeout))\n    else:\n      if not port:\n        port = 995\n      fp = POP3_SSL(host, int(port)) # timeout=int(timeout)) # no timeout option in python2\n\n    return POP_Connection(fp, fp.welcome)\n\n  def execute(self, host, port='', ssl='0', user=None, password=None, timeout='10', persistent='1'):\n\n    with Timing() as timing:\n      fp, resp = self.bind(host, port, ssl, timeout=timeout)\n\n    try:\n      if user is not None or password is not None:\n        with Timing() as timing:\n\n          if user is not None:\n            resp = fp.user(user)\n          if password is not None:\n            resp = fp.pass_(password)\n\n      logger.debug('No error: %s' % resp)\n      self.reset()\n\n    except pop_error as e:\n      logger.debug('pop_error: %s' % e)\n      resp = ', '.join(map(B, e.args))\n\n    if persistent == '0':\n      self.reset()\n\n    code, mesg = B(resp).split(' ', 1)\n    return self.Response(code, mesg, timing)\n\nclass POP_passd:\n  '''Brute-force poppassd (http://netwinsite.com/poppassd/)'''\n\n  usage_hints = (\n    '''%prog host=10.0.0.1 user=FILE0 password=FILE1 0=logins.txt 1=passwords.txt -x ignore:code=500''',\n    )\n\n  available_options = (\n    ('host', 'target host'),\n    ('port', 'target port [106]'),\n    ('user', 'usernames to test'),\n    ('password', 'passwords to test'),\n    ('timeout', 'seconds to wait for a response [10]'),\n    )\n  available_actions = ()\n\n  Response = Response_Base\n\n  def execute(self, host, port='106', user=None, password=None, timeout='10'):\n\n    fp = LineReceiver()\n    with Timing() as timing:\n      resp = fp.connect(host, int(port), int(timeout))\n    trace = resp + '\\r\\n'\n\n    try:\n      if user is not None or password is not None:\n        with Timing() as timing:\n\n          if user is not None:\n            cmd = 'USER %s' % user\n            resp = fp.sendcmd(cmd)\n            trace += '%s\\r\\n%s\\r\\n' % (cmd, resp)\n\n          if password is not None:\n            cmd = 'PASS %s' % password\n            resp = fp.sendcmd(cmd)\n            trace += '%s\\r\\n%s\\r\\n' % (cmd, resp)\n\n    except LineReceiver_Error as e:\n      logger.debug('LineReceiver_Error: %s' % e)\n      resp = str(e)\n      trace += '%s\\r\\n%s\\r\\n' % (cmd, resp)\n\n    finally:\n      fp.close()\n\n    code, mesg = fp.parse(resp)\n    return self.Response(code, mesg, timing, trace)\n\n# }}}\n\n# IMAP {{{\nfrom imaplib import IMAP4, IMAP4_SSL\n\nclass IMAP_login:\n  '''Brute-force IMAP4'''\n\n  usage_hints = (\n    '''%prog host=10.0.0.1 user=FILE0 password=FILE1 0=logins.txt 1=passwords.txt''',\n    )\n\n  available_options = (\n    ('host', 'target host'),\n    ('port', 'target port [143]'),\n    ('user', 'usernames to test'),\n    ('password', 'passwords to test'),\n    ('ssl', 'use SSL [0|1]'),\n    )\n  available_actions = ()\n\n  Response = Response_Base\n\n  def execute(self, host, port='', ssl='0', user=None, password=None):\n    if ssl == '0':\n      if not port:\n        port = 143\n      klass = IMAP4\n    else:\n      if not port:\n        port = 993\n      klass = IMAP4_SSL\n\n    with Timing() as timing:\n      fp = klass(host, port)\n\n    code, resp = 0, B(fp.welcome)\n\n    try:\n      if user is not None and password is not None:\n        with Timing() as timing:\n          r = fp.login(user, password)\n        code, resp = r[0], ', '.join(map(B, r[1]))\n\n    except IMAP4.error as e:\n      logger.debug('imap_error: %s' % e)\n      code, resp = 1, ', '.join(map(B, e.args))\n\n    return self.Response(code, resp, timing)\n\n# }}}\n\n# rlogin {{{\nclass Rlogin_login(TCP_Cache):\n  '''Brute-force rlogin'''\n\n  usage_hints = (\n    \"\"\"Please note that rlogin requires to bind a socket to an Internet domain privileged port.\"\"\",\n    \"\"\"%prog host=10.0.0.1 user=root luser=FILE0 0=logins.txt\"\"\",\n    \"\"\"%prog host=10.0.0.1 user=john password=FILE0 0=passwords.txt\"\"\",\n    )\n\n  available_options = (\n    ('host', 'target host'),\n    ('port', 'target port [513]'),\n    ('luser', 'client username [root]'),\n    ('user', 'usernames to test'),\n    ('password', 'passwords to test'),\n    ('prompt_re', 'regular expression to match prompts [\\w+:]'),\n    ('timeout', 'seconds to wait for a response and for prompt_re to match received data [10]'),\n    )\n  available_options += TCP_Cache.available_options\n\n  Response = Response_Base\n\n  def connect(self, host, port, timeout):\n    fp = Telnet()\n\n    for i in range(50):\n      try:\n        fp.sock = socket.create_connection((host, int(port)), timeout=int(timeout), source_address=('', 1023 - i))\n        break\n      except socket.error as e:\n        if (e.errno, e.strerror) != (98, 'Address already in use'):\n          raise e\n\n    self.need_handshake = True\n\n    return TCP_Connection(fp)\n\n  def execute(self, host, port='513', luser='root', user='', password=None, prompt_re='\\w+:', timeout='10', persistent='0'):\n\n    fp, _ = self.bind(host, port, timeout=int(timeout))\n\n    trace = b''\n    prompt_re = b(prompt_re)\n    timeout = int(timeout)\n\n    with Timing() as timing:\n      if self.need_handshake:\n        fp.write(b('\\x00%s\\x00%s\\x00vt100/9600\\x00' % (luser, user)))\n        self.need_handshake = False\n      else:\n        fp.write(b('%s\\r' % user))\n\n      _, m, raw = fp.expect([prompt_re], timeout=timeout) # expecting the Password: prompt\n      logger.debug('raw: %r' % raw)\n      trace += raw\n\n      if m and password is not None:\n        fp.write(b('%s\\r' % password))\n        _, _, raw = fp.expect([prompt_re], timeout=timeout) # expecting the login: prompt\n        logger.debug('raw: %r' % raw)\n        trace += raw\n\n    if persistent == '0':\n      self.reset()\n\n    mesg = B(raw).strip()\n    return self.Response(0, mesg, timing, trace)\n\n# }}}\n\n# VMauthd {{{\nclass LineReceiver_Error(Exception):\n  pass\n\nclass LineReceiver:\n\n  def connect(self, host, port, timeout, ssl=False):\n    self.sock = socket.create_connection((host, port), timeout)\n    banner = self.getresp()\n\n    if ssl:\n      self.sock = SSLContext().wrap_socket(sock=self.sock)\n\n    return banner # welcome banner\n\n  def close(self):\n    self.sock.close()\n\n  def sendcmd(self, cmd):\n    self.sock.sendall(b(cmd + '\\r\\n'))\n    return self.getresp()\n\n  def getresp(self):\n    resp = self.sock.recv(1024)\n    while not resp.endswith(b'\\n'):\n      resp += self.sock.recv(1024)\n\n    resp = B(resp).rstrip()\n    code, _ = self.parse(resp)\n\n    if not code.isdigit():\n      raise Exception('Unexpected response: %r' % resp)\n\n    if code[0] not in ('1', '2', '3'):\n      raise LineReceiver_Error(resp)\n\n    return resp\n\n  def parse(self, resp):\n    i = resp.rfind('\\n') + 1\n    code = resp[i:i+3]\n    mesg = resp[i+4:]\n\n    return code, mesg\n\nclass VMauthd_login(TCP_Cache):\n  '''Brute-force VMware Authentication Daemon'''\n\n  usage_hints = (\n    '''%prog host=10.0.0.1 user=root password=FILE0 0=passwords.txt''',\n    )\n\n  available_options = (\n    ('host', 'target host'),\n    ('port', 'target port [902]'),\n    ('user', 'usernames to test'),\n    ('password', 'passwords to test'),\n    ('ssl', 'use SSL [1|0]'),\n    ('timeout', 'seconds to wait for a response [10]'),\n    )\n  available_options += TCP_Cache.available_options\n\n  Response = Response_Base\n\n  def connect(self, host, port, ssl, timeout):\n    fp = LineReceiver()\n    banner = fp.connect(host, int(port), int(timeout), ssl != '0')\n    return TCP_Connection(fp, banner)\n\n  def execute(self, host, port='902', user=None, password=None, ssl='1', timeout='10', persistent='1'):\n\n    with Timing() as timing:\n      fp, resp = self.bind(host, port, ssl, timeout=timeout)\n    trace = resp + '\\r\\n'\n\n    try:\n      if user is not None or password is not None:\n        with Timing() as timing:\n\n          if user is not None:\n            cmd = 'USER %s' % user\n            resp = fp.sendcmd(cmd)\n            trace += '%s\\r\\n%s\\r\\n' % (cmd, resp)\n\n          if password is not None:\n            cmd = 'PASS %s' % password\n            resp = fp.sendcmd(cmd)\n            trace += '%s\\r\\n%s\\r\\n' % (cmd, resp)\n\n    except LineReceiver_Error as e:\n      logger.debug('LineReceiver_Error: %s' % e)\n      resp = str(e)\n      trace += '%s\\r\\n%s\\r\\n' % (cmd, resp)\n\n    if persistent == '0':\n      self.reset()\n\n    code, mesg = fp.parse(resp)\n    return self.Response(code, mesg, timing, trace)\n\n# }}}\n\n# MySQL {{{\ntry:\n  from MySQLdb import _mysql\nexcept ImportError:\n  notfound.append('mysqlclient')\n\nclass MySQL_login:\n  '''Brute-force MySQL'''\n\n  usage_hints = (\n    \"\"\"%prog host=10.0.0.1 user=FILE0 password=FILE1 0=logins.txt 1=passwords.txt -x ignore:fgrep='Access denied for user'\"\"\",\n    )\n\n  available_options = (\n    ('host', 'target host'),\n    ('port', 'target port [3306]'),\n    ('user', 'usernames to test'),\n    ('password', 'passwords to test'),\n    ('timeout', 'seconds to wait for a response [10]'),\n    )\n  available_actions = ()\n\n  Response = Response_Base\n\n  def execute(self, host, port='3306', user='anony', password='', timeout='10'):\n\n    try:\n      with Timing() as timing:\n        if PY3:\n          fp = _mysql.connect(host=host, port=int(port), user=user, password=password, connect_timeout=int(timeout))\n        else:\n          fp = _mysql.connect(host=host, port=int(port), user=user, passwd=password, connect_timeout=int(timeout))\n\n      resp = '0', fp.get_server_info()\n\n    except _mysql.Error as e:\n      logger.debug('MysqlError: %s' % e)\n      resp = e.args\n\n    code, mesg = resp\n    return self.Response(code, mesg, timing)\n\nclass MySQL_query(TCP_Cache):\n  '''Brute-force MySQL queries'''\n\n  usage_hints = (\n    '''%prog host=10.0.0.1 user=root password=s3cr3t query=\"select length(load_file('/home/adam/FILE0'))\" 0=files.txt -x ignore:size=0''',\n    )\n\n  available_options = (\n    ('host', 'target host'),\n    ('port', 'target port [3306]'),\n    ('user', 'username to use'),\n    ('password', 'password to use'),\n    ('query', 'SQL query to execute'),\n    )\n\n  available_actions = ()\n\n  Response = Response_Base\n\n  def connect(self, host, port, user, password):\n    if PY3:\n      fp = _mysql.connect(host=host, port=int(port), user=user, password=password) # db=db\n    else:\n      fp = _mysql.connect(host=host, port=int(port), user=user, passwd=password)\n\n    return TCP_Connection(fp)\n\n  def execute(self, host, port='3306', user='', password='', query='select @@version'):\n\n    fp, _ = self.bind(host, port, user, password)\n\n    with Timing() as timing:\n      fp.query(query)\n\n    rs = fp.store_result()\n    rows = rs.fetch_row(maxrows=0, how=0)\n\n    logger.debug('fetched %d rows: %s' % (len(rows), rows))\n\n    code, mesg = '0', '\\n'.join(', '.join(map(B, r)) for r in filter(any, rows))\n    return self.Response(code, mesg, timing)\n\n# }}}\n\n# MSSQL {{{\n# I did not use pymssql because neither version 1.x nor 2.0.0b1_dev were multithreads safe (they all segfault)\ntry:\n  from impacket import tds\n  from impacket.tds import TDS_ERROR_TOKEN, TDS_LOGINACK_TOKEN\nexcept ImportError:\n  notfound.append('pyopenssl')\n\nclass MSSQL_login:\n  '''Brute-force MSSQL'''\n\n  usage_hints = (\n    \"\"\"%prog host=10.0.0.1 user=sa password=FILE0 0=passwords.txt -x ignore:fgrep='Login failed for user'\"\"\",\n    )\n\n  available_options = (\n    ('host', 'target host'),\n    ('port', 'target port [1433]'),\n    ('user', 'usernames to test'),\n    ('password', 'passwords to test'),\n    ('windows_auth', 'use Windows auth [0|1]'),\n    ('domain', 'domain to test []'),\n    ('password_hash', \"LM/NT hashes to test ('lm:nt' or ':nt')\"),\n    #('timeout', 'seconds to wait for a response [10]'),\n    )\n  available_actions = ()\n\n  Response = Response_Base\n\n  def execute(self, host, port='1433', user='', password='', windows_auth='0', domain='', password_hash=None): #, timeout='10'):\n\n    fp = tds.MSSQL(host, int(port))\n    fp.connect()\n\n    with Timing() as timing:\n      if windows_auth == '0':\n        r = fp.login(None, user, password, None, None, False)\n      else:\n        r = fp.login(None, user, password, domain, password_hash, True)\n\n    if not r:\n      key = fp.replies[TDS_ERROR_TOKEN][0]\n\n      code = key['Number']\n      mesg = key['MsgText'].decode('utf-16le')\n\n    else:\n      key = fp.replies[TDS_LOGINACK_TOKEN][0]\n\n      code = '0'\n      mesg = '%s (%d%d %d%d)' % (key['ProgName'].decode('utf-16le'), key['MajorVer'], key['MinorVer'], key['BuildNumHi'], key['BuildNumLow'])\n\n    fp.disconnect()\n\n    return self.Response(code, mesg, timing)\n\n# }}}\n\n# Oracle {{{\ntry:\n  import cx_Oracle\nexcept ImportError:\n  notfound.append('cx_Oracle')\n\nclass Response_Oracle(Response_Base):\n  indicatorsfmt = [('code', -9), ('size', -4), ('time', 6)]\n\nclass Oracle_login:\n  '''Brute-force Oracle'''\n\n  usage_hints = (\n    '''%prog host=10.0.0.1 sid=FILE0 0=sids.txt -x ignore:code=ORA-12505''',\n    '''%prog host=10.0.0.1 user=SYS password=FILE0 0=passwords.txt -x ignore:code=ORA-01017''',\n    )\n\n  available_options = (\n    ('host', 'hostnames or subnets to target'),\n    ('port', 'ports to target [1521]'),\n    ('user', 'usernames to test'),\n    ('password', 'passwords to test'),\n    ('sid', 'sid to test'),\n    ('service_name', 'service name to test'),\n    )\n  available_actions = ()\n\n  Response = Response_Oracle\n\n  def execute(self, host, port='1521', user='', password='', sid='', service_name=''):\n\n    if sid:\n      dsn = cx_Oracle.makedsn(host=host, port=port, sid=sid)\n    elif service_name:\n      dsn = cx_Oracle.makedsn(host=host, port=port, service_name=service_name)\n    else:\n      raise ValueError('Options sid and service_name cannot be both empty')\n\n    try:\n      with Timing() as timing:\n        fp = cx_Oracle.connect(user, password, dsn, threaded=True)\n\n      code, mesg = '0', fp.version\n\n    except cx_Oracle.DatabaseError as e:\n      code, mesg = e.args[0].message[:-1].split(': ', 1)\n\n    return self.Response(code, mesg, timing)\n\n# }}}\n\n# PostgreSQL {{{\ntry:\n  import psycopg2\nexcept ImportError:\n  notfound.append('psycopg')\n\nclass Pgsql_login:\n  '''Brute-force PostgreSQL'''\n\n  usage_hints = (\n    \"\"\"%prog host=10.0.0.1 user=postgres password=FILE0 0=passwords.txt -x ignore:fgrep='password authentication failed for user'\"\"\",\n    )\n\n  available_options = (\n    ('host', 'target host'),\n    ('port', 'target port [5432]'),\n    ('user', 'usernames to test'),\n    ('password', 'passwords to test'),\n    ('database', 'databases to test [postgres]'),\n    ('timeout', 'seconds to wait for a response [10]'),\n    )\n  available_actions = ()\n\n  Response = Response_Base\n\n  def execute(self, host, port='5432', user=None, password=None, database='postgres', ssl='disable', timeout='10'):\n\n    try:\n      with Timing() as timing:\n        psycopg2.connect(host=host, port=int(port), user=user, password=password, database=database, sslmode=ssl, connect_timeout=int(timeout))\n\n      code, mesg = '0', 'OK'\n\n    except psycopg2.OperationalError as e:\n      logger.debug('OperationalError: %s' % e)\n      code, mesg = '1', str(e).strip()\n\n    return self.Response(code, mesg, timing)\n\n# }}}\n\n# HTTP {{{\ntry:\n  import pycurl\n\n  if hasattr(pycurl, 'PRIMARY_PORT'):\n    proxytype_mapping = {\n      'http': pycurl.PROXYTYPE_HTTP,\n      'socks4': pycurl.PROXYTYPE_SOCKS4,\n      'socks4a': pycurl.PROXYTYPE_SOCKS4A,\n      'socks5': pycurl.PROXYTYPE_SOCKS5,\n      'socks5_with_hostname': pycurl.PROXYTYPE_SOCKS5_HOSTNAME,\n    }\n  else:\n    # PRIMARY_PORT available since libcurl-7.21.0 and all PROXY_* since libcurl-7.18\n    # PRIMARY_PORT and all PROXY_* available since pycurl-7.19.5.1\n    notfound.append('libcurl')\nexcept ImportError:\n  notfound.append('pycurl')\n\nclass Response_HTTP(Response_Base):\n\n  indicatorsfmt = [('code', -4), ('size:clen', -13), ('time', 6)]\n\n  def __init__(self, code, response, timing=0, trace=None, content_length=-1, target={}):\n    Response_Base.__init__(self, code, response, timing, trace=trace)\n    self.content_length = content_length\n    self.target = target\n\n  def indicators(self):\n    return self.code, '%d:%d' % (self.size, self.content_length), '%.3f' % self.time\n\n  def __str__(self):\n    lines = re.findall('^(HTTP/.+)$', self.mesg, re.M)\n    if lines:\n      return lines[-1].rstrip('\\r')\n    else:\n      return self.mesg\n\n  def match_clen(self, val):\n    return match_range(self.content_length, val)\n\n  def match_egrep(self, val):\n    return re.search(val, self.mesg, re.M)\n\n  def str_target(self):\n    return ' '.join('%s=%s' % (k, xmlquoteattr(str(v))) for k, v in self.target.items())\n\n  available_conditions = Response_Base.available_conditions\n  available_conditions += (\n    ('clen', 'match Content-Length header (N or N-M or N- or -N)'),\n    )\n\ntry:\n  from http.server import BaseHTTPRequestHandler\nexcept ImportError:\n  from BaseHTTPServer import BaseHTTPRequestHandler\n\nclass HTTPRequestParser(BaseHTTPRequestHandler):\n  def __init__(self, fd):\n    self.rfile = fd\n    self.error = None\n    self.body = None\n\n    command, path, version = B(self.rfile.readline()).split()\n    self.raw_requestline = b('%s %s %s' % (command, path, 'HTTP/1.1' if version.startswith('HTTP/2') else version))\n\n    self.parse_request()\n    self.request_version = version\n\n    if self.command == 'POST':\n      self.body = B(self.rfile.read(-1)).rstrip('\\r\\n')\n\n      if 'Content-Length' in self.headers:\n        del self.headers['Content-Length']\n\n  def send_error(self, code, message):\n    self.error = message\n\nclass Controller_HTTP(Controller):\n\n  def expand_key(self, arg):\n    key, val = arg.split('=', 1)\n    if key == 'raw_request':\n\n      with open(val, 'rb') as fd:\n        r = HTTPRequestParser(fd)\n\n      if r.error:\n        raise ValueError('Failed to parse file %r as a raw HTTP request' % val, r.error)\n\n      opts = {}\n\n      if r.path.startswith('http'):\n        opts['url'] = r.path\n      else:\n        _, _, opts['path'], opts['params'], opts['query'], opts['fragment'] = urlparse(r.path)\n        opts['host'] = r.headers['Host']\n\n      opts['header'] = str(r.headers)\n      opts['method'] = r.command\n      opts['body'] = r.body\n\n      for key, val in opts.items():\n        if val:\n          yield (key, val)\n\n    else:\n      yield (key, val)\n\nclass HTTP_fuzz(TCP_Cache):\n  '''Brute-force HTTP'''\n\n  usage_hints = [\n    '''%prog url=http://10.0.0.1/FILE0 0=paths.txt -x ignore:code=404 -x ignore,retry:code=500''',\n    '''%prog url=http://10.0.0.1/manager/html user_pass=COMBO00:COMBO01 0=combos.txt -x ignore:code=401''',\n    '''%prog url=http://10.0.0.1/phpmyadmin/index.php method=POST'''\n    ''' body='pma_username=root&pma_password=FILE0&server=1&lang=en' 0=passwords.txt follow=1'''\n    \"\"\" accept_cookie=1 -x ignore:fgrep='Cannot log in to the MySQL server'\"\"\",\n    ]\n\n  available_options = (\n    ('url', 'target url (scheme://host[:port]/path?query)'),\n    #('host', 'target host'),\n    #('port', 'target port'),\n    #('path', 'web path [/]'),\n    #('query', 'query string'),\n    ('body', 'body data'),\n    ('header', 'use custom headers'),\n    ('method', 'method to use [GET|POST|HEAD|...]'),\n    ('raw_request', 'load request from file'),\n    ('scheme', 'scheme [http|https]'),\n    ('auto_urlencode', 'automatically perform URL-encoding [1|0]'),\n    ('pathasis', 'retain sequences of /../ or /./ [0|1]'),\n    ('user_pass', 'username and password for HTTP authentication (user:pass)'),\n    ('auth_type', 'type of HTTP authentication [basic | digest | ntlm]'),\n    ('follow', 'follow any Location redirect [0|1]'),\n    ('max_follow', 'redirection limit [5]'),\n    ('accept_cookie', 'save received cookies to issue them in future requests [0|1]'),\n    ('proxy', 'proxy to use (host:port)'),\n    ('proxy_type', 'proxy type [http|socks4|socks4a|socks5]'),\n    ('resolve', 'hostname to IP address resolution to use (hostname:IP)'),\n    ('ssl_cert', 'client SSL certificate file (cert+key in PEM format)'),\n    ('timeout_tcp', 'seconds to wait for a TCP handshake [10]'),\n    ('timeout', 'seconds to wait for a HTTP response [20]'),\n    ('before_urls', 'comma-separated URLs to query before the main request'),\n    ('before_header', 'use a custom header in the before_urls request'),\n    ('before_egrep', 'extract data from the before_urls response to place in the main request'),\n    ('after_urls', 'comma-separated URLs to query after the main request'),\n    ('max_mem', 'store no more than N bytes of request+response data in memory [-1 (unlimited)]'),\n    )\n  available_options += TCP_Cache.available_options\n\n  Response = Response_HTTP\n\n  def connect(self, host, port, scheme):\n    fp = pycurl.Curl()\n    fp.setopt(pycurl.SSL_VERIFYPEER, 0)\n    fp.setopt(pycurl.SSL_VERIFYHOST, 0)\n    fp.setopt(pycurl.HEADER, 1)\n    fp.setopt(pycurl.USERAGENT, 'Mozilla/5.0')\n    fp.setopt(pycurl.NOSIGNAL, 1)\n\n    return TCP_Connection(fp)\n\n  @staticmethod\n  def perform_fp(fp, method, url, header='', body=''):\n    #logger.debug('perform: %s' % url)\n    fp.setopt(pycurl.URL, url)\n\n    if method == 'GET':\n      fp.setopt(pycurl.HTTPGET, 1)\n\n    elif method == 'POST':\n      fp.setopt(pycurl.POST, 1)\n      fp.setopt(pycurl.POSTFIELDS, body)\n\n    elif method == 'HEAD':\n      fp.setopt(pycurl.NOBODY, 1)\n\n    else:\n      fp.setopt(pycurl.CUSTOMREQUEST, method)\n\n    headers = [h.strip('\\r') for h in header.split('\\n') if h]\n    fp.setopt(pycurl.HTTPHEADER, headers)\n\n    fp.perform()\n\n  def execute(self, url=None, host=None, port='', scheme='http', path='/', params='', query='', fragment='', body='',\n    header='', method='GET', auto_urlencode='1', pathasis='0', user_pass='', auth_type='basic',\n    follow='0', max_follow='5', accept_cookie='0', proxy='', proxy_type='http', resolve='', ssl_cert='', timeout_tcp='10', timeout='20', persistent='1',\n    before_urls='', before_header='', before_egrep='', after_urls='', max_mem='-1'):\n\n    if url:\n      scheme, host, path, params, query, fragment = urlparse(url)\n      del url\n\n    if host:\n      if ':' in host:\n        host, port = host.split(':')\n\n    if resolve:\n      resolve_host, resolve_ip = resolve.split(':', 1)\n      if port:\n        resolve_port = port\n      else:\n        resolve_port = 80\n\n      resolve = '%s:%s:%s' % (resolve_host, resolve_port, resolve_ip)\n\n    if proxy_type in proxytype_mapping:\n      proxy_type = proxytype_mapping[proxy_type]\n    else:\n      raise ValueError('Invalid proxy_type %r' % proxy_type)\n\n    fp, _ = self.bind(host, port, scheme)\n\n    fp.setopt(pycurl.PATH_AS_IS, int(pathasis))\n    fp.setopt(pycurl.FOLLOWLOCATION, int(follow))\n    fp.setopt(pycurl.MAXREDIRS, int(max_follow))\n    fp.setopt(pycurl.CONNECTTIMEOUT, int(timeout_tcp))\n    fp.setopt(pycurl.TIMEOUT, int(timeout))\n    fp.setopt(pycurl.PROXY, proxy)\n    fp.setopt(pycurl.PROXYTYPE, proxy_type)\n\n    if resolve:\n      fp.setopt(pycurl.RESOLVE, [resolve])\n\n    def noop(buf): pass\n    fp.setopt(pycurl.WRITEFUNCTION, noop)\n\n    def debug_func(t, s):\n      if max_mem > 0 and trace.tell() > max_mem:\n        return 0\n\n      if t not in (pycurl.INFOTYPE_HEADER_OUT, pycurl.INFOTYPE_DATA_OUT, pycurl.INFOTYPE_TEXT, pycurl.INFOTYPE_HEADER_IN, pycurl.INFOTYPE_DATA_IN):\n        return 0\n\n      s = B(s)\n\n      if t in (pycurl.INFOTYPE_HEADER_OUT, pycurl.INFOTYPE_DATA_OUT):\n        trace.write(s)\n\n      elif t == pycurl.INFOTYPE_TEXT and 'upload completely sent off' in s:\n        trace.write('\\n\\n')\n\n      elif t in (pycurl.INFOTYPE_HEADER_IN, pycurl.INFOTYPE_DATA_IN):\n        trace.write(s)\n        response.write(s)\n\n    max_mem = int(max_mem)\n    response, trace = StringIO(), StringIO()\n\n    fp.setopt(pycurl.DEBUGFUNCTION, debug_func)\n    fp.setopt(pycurl.VERBOSE, 1)\n\n    if user_pass:\n      fp.setopt(pycurl.USERPWD, user_pass)\n      if auth_type == 'basic':\n        fp.setopt(pycurl.HTTPAUTH, pycurl.HTTPAUTH_BASIC)\n      elif auth_type == 'digest':\n        fp.setopt(pycurl.HTTPAUTH, pycurl.HTTPAUTH_DIGEST)\n      elif auth_type == 'ntlm':\n        fp.setopt(pycurl.HTTPAUTH, pycurl.HTTPAUTH_NTLM)\n      else:\n        raise ValueError('Incorrect auth_type %r' % auth_type)\n\n    if ssl_cert:\n      fp.setopt(pycurl.SSLCERT, ssl_cert)\n\n    if accept_cookie == '1':\n      fp.setopt(pycurl.COOKIEFILE, '')\n      # warning: do not pass a Cookie: header into HTTPHEADER if using COOKIEFILE as it will\n      # produce requests with more than one Cookie: header\n      # and the server will process only one of them (eg. Apache only reads the last one)\n\n    if before_urls:\n      for before_url in before_urls.split(','):\n        self.perform_fp(fp, 'GET', before_url, before_header)\n\n      if before_egrep:\n        for be in before_egrep.split('|'):\n          mark, regex = be.split(':', 1)\n          val = re.search(regex, response.getvalue(), re.M).group(1)\n\n          if auto_urlencode == '1':\n            val = html_unescape(val)\n            val = quote(val)\n\n          header = header.replace(mark, val)\n          query = query.replace(mark, val)\n          body = body.replace(mark, val)\n\n      response = StringIO()\n\n    if auto_urlencode == '1':\n      path = quote(path)\n      query = urlencode(parse_query(query, True))\n      body = urlencode(parse_query(body, True))\n\n    if port:\n      host = '%s:%s' % (host, port)\n\n    url = urlunparse((scheme, host, path, params, query, fragment))\n    self.perform_fp(fp, method, url, header, body)\n\n    target = {}\n    target['ip'] = fp.getinfo(pycurl.PRIMARY_IP)\n    target['port'] = fp.getinfo(pycurl.PRIMARY_PORT)\n    target['hostname'] = host\n\n    for h in header.split('\\n'):\n      if ': ' in h:\n        k, v = h.split(': ', 1)\n        if k.lower() == 'host':\n          target['vhost'] = v.rstrip('\\r')\n          break\n\n    if after_urls:\n      for after_url in after_urls.split(','):\n        self.perform_fp(fp, 'GET', after_url)\n\n    http_code = fp.getinfo(pycurl.HTTP_CODE)\n    content_length = fp.getinfo(pycurl.CONTENT_LENGTH_DOWNLOAD)\n    response_time = fp.getinfo(pycurl.TOTAL_TIME) - fp.getinfo(pycurl.PRETRANSFER_TIME)\n\n    if persistent == '0':\n      self.reset()\n\n    return self.Response(http_code, response.getvalue(), response_time, trace.getvalue(), content_length, target)\n\n# }}}\n\n# RDP Gateway {{{\nimport uuid\n\nclass RDP_gateway(HTTP_fuzz):\n  '''Brute-force RDP Gateway'''\n\n  usage_hints = (\n      '''%prog url='https://example.com/remoteDesktopGateway/' user_pass=COMBO00:COMBO01 0=combos.txt -x ignore:code=401''',\n    )\n\n  @staticmethod\n  def perform_fp(fp, method, url, header='', body=''):\n    method = 'RDG_OUT_DATA'\n    header += '\\nRDG-Connection-Id: {%s}' % uuid.uuid4()\n\n    # if authentication is successful the gateway server hangs and won't send a body\n    fp.setopt(pycurl.NOBODY, 1)\n\n    HTTP_fuzz.perform_fp(fp, method, url, header)\n\n# }}}\n\n# AJP {{{\ntry:\n  from ajpy.ajp import AjpForwardRequest\nexcept ImportError:\n  notfound.append('ajpy')\n\nclass AJP_Connection(TCP_Connection):\n  def close(self):\n    sock, stream = self.fp\n    sock.close()\n\nclass Response_AJP(Response_HTTP):\n  def __init__(self, code, response, timing=0, trace=None, content_length=-1, target={}):\n    Response_HTTP.__init__(self, code, response, timing, trace, content_length, target)\n\n  def __str__(self):\n    lines = self.mesg.splitlines()\n    if lines:\n      return lines[0].rstrip('\\r')\n    else:\n      return self.mesg\n\ndef prepare_ajp_forward_request(target_host, req_uri, method):\n  fr = AjpForwardRequest(AjpForwardRequest.SERVER_TO_CONTAINER)\n  fr.method = method\n  fr.protocol = 'HTTP/1.1'\n  fr.req_uri = req_uri\n  fr.remote_addr = target_host\n  fr.remote_host = None\n  fr.server_name = target_host\n  fr.server_port = 80\n  fr.request_headers = {\n    'SC_REQ_ACCEPT': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',\n    'SC_REQ_CONNECTION': 'keep-alive',\n    'SC_REQ_CONTENT_LENGTH': '0',\n    'SC_REQ_HOST': target_host,\n    'SC_REQ_USER_AGENT': 'Mozilla/5.0 (X11; Linux x86_64; rv:46.0) Gecko/20100101 Firefox/46.0',\n    'Accept-Encoding': 'gzip, deflate, sdch',\n    'Accept-Language': 'en-US,en;q=0.5',\n    'Upgrade-Insecure-Requests': '1',\n    'Cache-Control': 'max-age=0'\n  }\n  fr.is_ssl = False\n  fr.attributes = []\n\n  return fr\n\nclass AJP_fuzz(TCP_Cache):\n  '''Brute-force AJP'''\n\n  usage_hints = [\n    '''%prog url=ajp://10.0.0.1/FILE0 0=paths.txt -x ignore:code=404 -x ignore,retry:code=500''',\n    '''%prog url=ajp://10.0.0.1/manager/html user_pass=COMBO00:COMBO01 0=combos.txt -x ignore:code=401''',\n    ]\n\n  available_options = (\n    ('url', 'target url (ajp://host[:port]/path?query)'),\n    ('header', 'use custom headers'),\n    ('user_pass', 'username and password for HTTP authentication (user:pass)'),\n    )\n\n  Response = Response_AJP\n\n  def connect(self, host, port):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    sock.connect((host, int(port)))\n    stream = sock.makefile('rb', None if PY3 else 0)\n\n    return AJP_Connection((sock, stream))\n\n  def execute(self, url=None, host=None, port='8009', path='/', params='', query='', header='', user_pass='', persistent='1'):\n\n    if url:\n      scheme, host, path, params, query, fragment = urlparse(url)\n      if ':' in host:\n        host, port = host.split(':')\n      del url\n\n    req_uri = urlunparse(('', '', path, params, query, fragment))\n\n    fr = prepare_ajp_forward_request(host, req_uri, AjpForwardRequest.REQUEST_METHODS.get('GET'))\n    fr.request_headers['SC_REQ_AUTHORIZATION'] = \"Basic \" + B(b64encode(b(user_pass)))\n\n    headers = [h.strip('\\r') for h in header.split('\\n') if h]\n    for h in headers:\n      k, _, v = h.partition(':')\n      fr.request_headers[k] = v\n\n    (sock, stream), _ = self.bind(host, port)\n\n    with Timing() as timing:\n      responses = fr.send_and_receive(sock, stream)\n\n    snd_hdrs_res = responses[0]\n    http_code = snd_hdrs_res.http_status_code\n    http_status_msg = B(snd_hdrs_res.http_status_msg)\n    content_length = int(snd_hdrs_res.response_headers.get('Content-Length', 0))\n\n    data_res = responses[1:-1]\n    data = ''\n    for dr in data_res:\n      data += B(dr.data)\n\n    target = {}\n    target['ip'] = host\n    target['port'] = port\n\n    if persistent == '0':\n      self.reset()\n\n    return self.Response(http_code, http_status_msg + '\\n' + data, timing, data, content_length, target)\n\n# }}}\n\n# RDP {{{\nif not which('xfreerdp'):\n  notfound.append('xfreerdp')\n\nclass RDP_login:\n  '''Brute-force RDP (NLA)'''\n\n  usage_hints = (\n    '''%prog host=10.0.0.1 user='administrator' password=FILE0 0=passwords.txt''',\n    )\n\n  available_options = (\n    ('host', 'target host'),\n    ('port', 'target port [3389]'),\n    ('user', 'usernames to test'),\n    ('password', 'passwords to test'),\n    )\n  available_actions = ()\n\n  Response = Response_Base\n\n  def execute(self, host, port='3389', user=None, password=None):\n\n    cmd = ['xfreerdp', '/v:%s:%d' % (host, int(port)), '/u:%s' % user, '/p:%s' % password, '/cert:ignore', '/tls-seclevel:0', '+auth-only', '/sec:nla', '/log-level:error']\n\n    with Timing() as timing:\n      p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n      out, err = map(B, p.communicate())\n      code = p.returncode\n\n    mesg = []\n    m = re.search(' Authentication only, exit status (\\d+)', err)\n    if m:\n      mesg.append(('exit', m.group(1)))\n    m = re.search(' (ERR.+?) ', err)\n    if m:\n      mesg.append(('err', m.group(1)))\n\n    mesg = ', '.join([f'{k}: {v}' for k, v in mesg])\n    trace = '%s\\n[out]\\n%s\\n[err]\\n%s\\n' % (' '.join(cmd), out, err)\n\n    return self.Response(code, mesg, timing, trace)\n\n# }}}\n\n# VNC {{{\ntry:\n  from Cryptodome.Cipher import DES\nexcept ImportError:\n  notfound.append('pycrypto')\n\nclass VNC_Error(Exception):\n  pass\n\nclass VNC:\n  def connect(self, host, port, timeout):\n    self.fp = socket.create_connection((host, port), timeout=timeout)\n    resp = self.fp.recv(99) # banner\n\n    logger.debug('banner: %r' % resp)\n    self.version = B(resp[:11])\n\n    if len(resp) > 12:\n      raise VNC_Error('%s %r' % (self.version, B(resp[12:])))\n\n    return self.version\n\n  def login(self, password):\n    logger.debug('Remote version: %r' % self.version)\n    major, minor = self.version[6], self.version[10]\n\n    if (major, minor) in [('3', '8'), ('4', '1')]:\n      proto = 'RFB 003.008\\n'\n\n    elif (major, minor) == ('3', '7'):\n      proto = 'RFB 003.007\\n'\n\n    else:\n      proto = 'RFB 003.003\\n'\n\n    logger.debug('Client version: %r' % proto[:-1])\n    self.fp.sendall(b(proto))\n\n    sleep(0.5)\n\n    resp = self.fp.recv(99)\n    logger.debug('Security types supported: %r' % resp)\n\n    if major == '4' or (major == '3' and int(minor) >= 7):\n      code = ord(resp[0:1])\n      if code == 0:\n        raise VNC_Error('Session setup failed: %s' % B(resp))\n\n      self.fp.sendall(b'\\x02') # always use classic VNC authentication\n      resp = self.fp.recv(99)\n\n    else: # minor == '3':\n      code = ord(resp[3:4])\n      if code != 2:\n        raise VNC_Error('Session setup failed: %s' % B(resp))\n\n      resp = resp[-16:]\n\n    if len(resp) != 16:\n      raise VNC_Error('Unexpected challenge size (No authentication required? Unsupported authentication type?)')\n\n    logger.debug('challenge: %r' % resp)\n    pw = password.ljust(8, '\\x00')[:8] # make sure it is 8 chars long, zero padded\n\n    key = self.gen_key(pw)\n    logger.debug('key: %r' % key)\n\n    des = DES.new(key, DES.MODE_ECB)\n    enc = des.encrypt(resp)\n\n    logger.debug('enc: %r' % enc)\n    self.fp.sendall(enc)\n\n    resp = self.fp.recv(99)\n    logger.debug('resp: %r' % resp)\n\n    code = ord(resp[3:4])\n    mesg = B(resp[8:])\n\n    if code == 1:\n      return code, mesg or 'Authentication failure'\n\n    elif code == 0:\n      return code, mesg or 'OK'\n\n    else:\n      raise VNC_Error('Unknown response: %r (code: %s)' % (resp, code))\n\n  def gen_key(self, key):\n    newkey = []\n    for ki in range(len(key)):\n      bsrc = ord(key[ki])\n      btgt = 0\n      for i in range(8):\n        if bsrc & (1 << i):\n          btgt = btgt | (1 << 7-i)\n      newkey.append(btgt)\n\n    if PY3:\n      return bytes(newkey)\n    else:\n      return ''.join(chr(c) for c in newkey)\n\nclass VNC_login:\n  '''Brute-force VNC'''\n\n  usage_hints = (\n    '''%prog host=10.0.0.1 password=FILE0 0=passwords.txt -t 1 -x 'retry:fgrep!=Authentication failure' --max-retries -1 -x quit:code=0''',\n    )\n\n  available_options = (\n    ('host', 'target host'),\n    ('port', 'target port [5900]'),\n    ('password', 'passwords to test'),\n    ('timeout', 'seconds to wait for a response [10]'),\n    )\n  available_actions = ()\n\n  Response = Response_Base\n\n  def execute(self, host, port=None, password=None, timeout='10'):\n    v = VNC()\n\n    try:\n      with Timing() as timing:\n        code, mesg = 0, v.connect(host, int(port or 5900), int(timeout))\n\n      if password is not None:\n        with Timing() as timing:\n          code, mesg = v.login(password)\n\n    except VNC_Error as e:\n      logger.debug('VNC_Error: %s' % e)\n      code, mesg = 2, str(e)\n\n    return self.Response(code, mesg, timing)\n\n# }}}\n\n# DNS {{{\ntry:\n  import dns.rdatatype\n  import dns.message\n  import dns.query\n  import dns.reversename\nexcept ImportError:\n  notfound.append('dnspython')\n\ndef dns_query(server, timeout, protocol, qname, qtype, qclass):\n  request = dns.message.make_query(qname, qtype, qclass)\n\n  if protocol == 'tcp':\n    response = dns.query.tcp(request, server, timeout=timeout, one_rr_per_rrset=True)\n\n  else:\n    response = dns.query.udp(request, server, timeout=timeout, one_rr_per_rrset=True)\n\n    if response.flags & dns.flags.TC:\n      response = dns.query.tcp(request, server, timeout=timeout, one_rr_per_rrset=True)\n\n  return response\n\ndef generate_tld():\n  # NB. does not return an exhaustive list (ie. missing co.uk, co.nz etc.)\n\n  from itertools import product\n  from string import ascii_lowercase\n\n  # http://data.iana.org/TLD/tlds-alpha-by-domain.txt\n  gtld = ['academy', 'actor', 'aero', 'agency', 'archi', 'arpa', 'asia', 'axa',\n    'bar', 'bargains', 'berlin', 'best', 'bid', 'bike', 'biz', 'black', 'blue',\n    'boutique', 'build', 'builders', 'buzz', 'cab', 'camera', 'camp', 'cards',\n    'careers', 'cat', 'catering', 'center', 'ceo', 'cheap', 'christmas',\n    'cleaning', 'clothing', 'club', 'codes', 'coffee', 'cologne', 'com',\n    'community', 'company', 'computer', 'condos', 'construction', 'contractors',\n    'cooking', 'cool', 'coop', 'country', 'cruises', 'dance', 'dating', 'democrat',\n    'diamonds', 'directory', 'dnp', 'domains', 'edu', 'education', 'email',\n    'enterprises', 'equipment', 'estate', 'events', 'expert', 'exposed', 'farm',\n    'fish', 'fishing', 'flights', 'florist', 'foundation', 'futbol', 'gallery',\n    'gift', 'glass', 'gov', 'graphics', 'guitars', 'guru', 'haus', 'holdings',\n    'holiday', 'horse', 'house', 'immobilien', 'industries', 'info', 'ink',\n    'institute', 'int', 'international', 'jetzt', 'jobs', 'kaufen', 'kim',\n    'kitchen', 'kiwi', 'koeln', 'kred', 'land', 'lighting', 'limo', 'link',\n    'london', 'luxury', 'maison', 'management', 'mango', 'marketing', 'meet',\n    'menu', 'miami', 'mil', 'mobi', 'moda', 'moe', 'monash', 'museum', 'nagoya',\n    'name', 'net', 'neustar', 'ninja', 'nyc', 'okinawa', 'onl', 'org', 'partners',\n    'parts', 'photo', 'photography', 'photos', 'pics', 'pink', 'plumbing', 'post',\n    'pro', 'productions', 'properties', 'pub', 'qpon', 'recipes', 'red', 'ren',\n    'rentals', 'repair', 'report', 'reviews', 'rich', 'rodeo', 'ruhr', 'sexy',\n    'shiksha', 'shoes', 'singles', 'social', 'sohu', 'solar', 'solutions',\n    'supplies', 'supply', 'support', 'systems', 'tattoo', 'technology', 'tel',\n    'tienda', 'tips', 'today', 'tokyo', 'tools', 'trade', 'training', 'travel',\n    'uno', 'vacations', 'vegas', 'ventures', 'viajes', 'villas', 'vision', 'vodka',\n    'vote', 'voting', 'voto', 'voyage', 'wang', 'watch', 'webcam', 'wed', 'wien',\n    'wiki', 'works', 'xn--3bst00m', 'xn--3ds443g', 'xn--3e0b707e', 'xn--45brj9c',\n    'xn--55qw42g', 'xn--55qx5d', 'xn--6frz82g', 'xn--6qq986b3xl', 'xn--80ao21a',\n    'xn--80asehdb', 'xn--80aswg', 'xn--90a3ac', 'xn--c1avg', 'xn--cg4bki',\n    'xn--clchc0ea0b2g2a9gcd', 'xn--czru2d', 'xn--d1acj3b', 'xn--fiq228c5hs',\n    'xn--fiq64b', 'xn--fiqs8s', 'xn--fiqz9s', 'xn--fpcrj9c3d', 'xn--fzc2c9e2c',\n    'xn--gecrj9c', 'xn--h2brj9c', 'xn--i1b6b1a6a2e', 'xn--io0a7i', 'xn--j1amh',\n    'xn--j6w193g', 'xn--kprw13d', 'xn--kpry57d', 'xn--l1acc', 'xn--lgbbat1ad8j',\n    'xn--mgb9awbf', 'xn--mgba3a4f16a', 'xn--mgbaam7a8h', 'xn--mgbab2bd',\n    'xn--mgbayh7gpa', 'xn--mgbbh1a71e', 'xn--mgbc0a9azcg', 'xn--mgberp4a5d4ar',\n    'xn--mgbx4cd0ab', 'xn--ngbc5azd', 'xn--nqv7f', 'xn--nqv7fs00ema', 'xn--o3cw4h',\n    'xn--ogbpf8fl', 'xn--p1ai', 'xn--pgbs0dh', 'xn--q9jyb4c', 'xn--rhqv96g',\n    'xn--s9brj9c', 'xn--unup4y', 'xn--wgbh1c', 'xn--wgbl6a', 'xn--xkc2al3hye2a',\n    'xn--xkc2dl3a5ee0h', 'xn--yfro4i67o', 'xn--ygbi2ammx', 'xn--zfr164b', 'xxx',\n    'xyz', 'zone']\n\n  cctld = [''.join(i) for i in product(*[ascii_lowercase]*2)]\n\n  tld = gtld + cctld\n  return tld, len(tld)\n\ndef generate_srv():\n  common = [\n    '_gc._tcp', '_kerberos._tcp', '_kerberos._udp', '_ldap._tcp',\n    '_test._tcp', '_sips._tcp', '_sip._udp', '_sip._tcp', '_aix._tcp', '_aix._udp',\n    '_finger._tcp', '_ftp._tcp', '_http._tcp', '_nntp._tcp', '_telnet._tcp',\n    '_whois._tcp', '_h323cs._tcp', '_h323cs._udp', '_h323be._tcp', '_h323be._udp',\n    '_h323ls._tcp', '_h323ls._udp', '_sipinternal._tcp', '_sipinternaltls._tcp',\n    '_sip._tls', '_sipfederationtls._tcp', '_jabber._tcp', '_xmpp-server._tcp', '_xmpp-client._tcp',\n    '_imap.tcp', '_certificates._tcp', '_crls._tcp', '_pgpkeys._tcp', '_pgprevokations._tcp',\n    '_cmp._tcp', '_svcp._tcp', '_crl._tcp', '_ocsp._tcp', '_PKIXREP._tcp',\n    '_smtp._tcp', '_hkp._tcp', '_hkps._tcp', '_jabber._udp', '_xmpp-server._udp',\n    '_xmpp-client._udp', '_jabber-client._tcp', '_jabber-client._udp',\n    '_adsp._domainkey', '_policy._domainkey', '_domainkey', '_ldap._tcp.dc._msdcs', '_ldap._udp.dc._msdcs']\n\n  def distro():\n    import os\n    import re\n    files = ['/usr/share/nmap/nmap-protocols', '/usr/share/nmap/nmap-services', '/etc/protocols', '/etc/services']\n    ret = []\n    for filepath in files:\n      if not os.path.isfile(filepath):\n        logger.warn(\"File '%s' is missing, there will be less records to test\" % filepath)\n        continue\n      with open(filepath, 'rb') as f:\n        for line in f:\n          match = re.match(r'([a-zA-Z0-9]+)\\s', B(line))\n          if not match:\n            continue\n          for w in re.split(r'[^a-z0-9]', match.group(1).strip().lower()):\n            ret.extend(['_%s.%s' % (w, i) for i in ('_tcp', '_udp')])\n    return ret\n\n  srv = set(common + distro())\n  return srv, len(srv)\n\nclass HostInfo:\n  def __init__(self):\n    self.name = set()\n    self.ip = set()\n    self.alias = set()\n\n  def __str__(self):\n    line = ''\n    if self.name:\n      line = ' '.join(self.name)\n    if self.ip:\n      if line:\n        line += ' / '\n      line += ' '.join(map(str, self.ip))\n    if self.alias:\n      if line:\n        line += ' / '\n      line += ' '.join(self.alias)\n\n    return line\n\nclass Controller_DNS(Controller):\n  records = defaultdict(list)\n  hostmap = defaultdict(HostInfo)\n\n  # show_final {{{\n  def show_final(self):\n    ''' Expected output:\n    Records -----\n          ftp.example.com.   IN A       10.0.1.1\n          www.example.com.   IN A       10.0.1.1\n         prod.example.com.   IN CNAME   www.example.com.\n         ipv6.example.com.   IN AAAA    dead:beef::\n          dev.example.com.   IN A       10.0.1.2\n          svn.example.com.   IN A       10.0.2.1\n      websrv1.example.com.   IN CNAME   prod.example.com.\n         blog.example.com.   IN CNAME   example.wordpress.com.\n    '''\n    print('Records ' + '-'*42)\n    for name, infos in sorted(self.records.items()):\n      for qclass, qtype, rdata in infos:\n        print('%34s %4s %-7s %s' % (name, qclass, qtype, rdata))\n\n    ''' Expected output:\n    Hostmap ------\n           ipv6.example.com dead:beef::\n            ftp.example.com 10.0.1.1\n            www.example.com 10.0.1.1\n           prod.example.com\n        websrv1.example.com\n            dev.example.com 10.0.1.2\n            svn.example.com 10.0.2.1\n      example.wordpress.com ?\n           blog.example.com\n    Domains ---------------------------\n                example.com 8\n    Networks --------------------------\n                           dead:beef::\n                              10.0.1.x\n                              10.0.2.1\n    '''\n    ipmap = defaultdict(HostInfo)\n    noips = defaultdict(list)\n\n    '''\n    hostmap = {\n       'www.example.com': {'ip': ['10.0.1.1'], 'alias': ['prod.example.com']},\n       'ftp.example.com': {'ip': ['10.0.1.1'], 'alias': []},\n       'prod.example.com': {'ip': [], 'alias': ['websrv1.example.com']},\n       'ipv6.example.com': {'ip': ['dead:beef::'], 'alias': []},\n       'dev.example.com': {'ip': ['10.0.1.2'], 'alias': []},\n       'example.wordpress.com': {'ip': [], 'alias': ['blog.example.com']},\n\n    ipmap = {'10.0.1.1': {'name': ['www.example.com', 'ftp.example.com'], 'alias': ['prod.example.com', 'websrv1.example.com']}, ...\n    noips = {'example.wordpress.com': ['blog.example.com'],\n    '''\n\n    for name, hinfo in self.hostmap.items():\n      for ip in hinfo.ip:\n        ip = IP(ip)\n        ipmap[ip].name.add(name)\n        ipmap[ip].alias.update(hinfo.alias)\n\n    for name, hinfo in self.hostmap.items():\n      if not hinfo.ip and hinfo.alias:\n        found = False\n        for ip, v in ipmap.items():\n          if name in v.alias:\n            for alias in hinfo.alias:\n              ipmap[ip].alias.add(alias)\n              found = True\n\n        if not found: # orphan CNAME hostnames (with no IP address) may be still valid virtual hosts\n          noips[name].extend(hinfo.alias)\n\n    print('Hostmap ' + '-'*42)\n    for ip, hinfo in sorted(ipmap.items()):\n      for name in hinfo.name:\n        print('%34s %s' % (name, ip))\n      for alias in hinfo.alias:\n        print('%34s' % alias)\n\n    for k, v in noips.items():\n      print('%34s ?' % k)\n      for alias in v:\n        print('%34s' % alias)\n\n    print('Domains ' + '-'*42)\n    domains = {}\n    for ip, hinfo in ipmap.items():\n      for name in hinfo.name.union(hinfo.alias):\n        if name.count('.') > 1:\n          i = 1\n        else:\n          i = 0\n        d = '.'.join(name.split('.')[i:])\n        if d not in domains:\n          domains[d] = 0\n        domains[d] += 1\n\n    for domain, count in sorted(domains.items(), key=lambda a: a[0].split('.')[-1::-1]):\n      print('%34s %d' % (domain, count))\n\n    print('Networks ' + '-'*41)\n    nets = {}\n    for ip in set(ipmap):\n      if not ip.version() == 4:\n        nets[ip] = [ip]\n      else:\n        n = ip.make_net('255.255.255.0')\n        if n not in nets:\n          nets[n] = []\n        nets[n].append(ip)\n\n    for net, ips in sorted(nets.items()):\n      if len(ips) == 1:\n        print(' '*34 + ' %s' % ips[0])\n      else:\n        print(' '*34 + ' %s.x' % '.'.join(str(net).split('.')[:-1]))\n\n  # }}}\n\n  def push_final(self, resp):\n    if hasattr(resp, 'rrs'):\n      for rr in resp.rrs:\n        name, qclass, qtype, data = rr\n\n        info = (qclass, qtype, data)\n        if info not in self.records[name]:\n          self.records[name].append(info)\n\n        if not qclass == 'IN':\n          continue\n\n        if qtype == 'PTR':\n          data = data[:-1]\n          self.hostmap[data].ip.add(name)\n\n        else:\n          if qtype in ('A', 'AAAA'):\n            name = name[:-1]\n            self.hostmap[name].ip.add(data)\n\n          elif qtype == 'CNAME':\n            name, data = name[:-1], data[:-1]\n            self.hostmap[data].alias.add(name)\n\nclass DNS_reverse:\n  '''Reverse DNS lookup'''\n\n  usage_hints = [\n    '''%prog host=NET0 0=192.168.0.0/24 -x ignore:code=3''',\n    '''%prog host=NET0 0=216.239.32.0-216.239.47.255,8.8.8.0/24 -x ignore:code=3 -x ignore:fgrep!=google.com -x ignore:fgrep=216-239-''',\n    ]\n\n  available_options = (\n    ('host', 'IP addresses to reverse lookup'),\n    ('server', 'name server to query (directly asking a zone authoritative NS may return more results) [8.8.8.8]'),\n    ('timeout', 'seconds to wait for a response [5]'),\n    ('protocol', 'send queries over udp or tcp [udp]'),\n    )\n  available_actions = ()\n\n  Response = Response_Base\n\n  def execute(self, host, server='8.8.8.8', timeout='5', protocol='udp'):\n\n    with Timing() as timing:\n      response = dns_query(server, int(timeout), protocol, dns.reversename.from_address(host), qtype='PTR', qclass='IN')\n\n    rcode = response.rcode()\n    code = int(rcode)\n    status = dns.rcode.to_text(rcode)\n\n    rrs = [[host, c, t, d] for _, _, c, t, d in [rr.to_text().split(' ', 4) for rr in response.answer]]\n\n    mesg = '%s %s' % (status, ''.join('[%s]' % ' '.join(rr) for rr in rrs))\n    resp = self.Response(code, mesg, timing)\n\n    resp.rrs = rrs\n\n    return resp\n\nclass DNS_forward:\n  '''Forward DNS lookup'''\n\n  usage_hints = [\n    '''%prog name=FILE0.google.com 0=names.txt -x ignore:code=3''',\n    '''%prog name=google.MOD0 0=TLD -x ignore:code=3''',\n    '''%prog name=MOD0.microsoft.com 0=SRV qtype=SRV -x ignore:code=3''',\n    ]\n\n  available_options = (\n    ('name', 'domain names to lookup'),\n    ('server', 'name server to query (directly asking the zone authoritative NS may return more results) [8.8.8.8]'),\n    ('timeout', 'seconds to wait for a response [5]'),\n    ('protocol', 'send queries over udp or tcp [udp]'),\n    ('qtype', 'type to query [ANY]'),\n    ('qclass', 'class to query [IN]'),\n    )\n  available_actions = ()\n\n  available_keys = {\n    'TLD': generate_tld,\n    'SRV': generate_srv,\n    }\n\n  Response = Response_Base\n\n  def execute(self, name, server='8.8.8.8', timeout='5', protocol='udp', qtype='ANY', qclass='IN'):\n\n    with Timing() as timing:\n      response = dns_query(server, int(timeout), protocol, name, qtype=qtype, qclass=qclass)\n\n    rcode = response.rcode()\n    code = int(rcode)\n    status = dns.rcode.to_text(rcode)\n\n    rrs = [[n, c, t, d] for n, _, c, t, d in [rr.to_text().split(' ', 4) for rr in response.answer + response.additional + response.authority]]\n\n    mesg = '%s %s' % (status, ''.join('[%s]' % ' '.join(rr) for rr in rrs))\n    resp = self.Response(code, mesg, timing)\n\n    resp.rrs = rrs\n\n    return resp\n\n# }}}\n\n# SNMP {{{\ntry:\n  from pysnmp.hlapi import getCmd, SnmpEngine, CommunityData, UsmUserData\n  from pysnmp.hlapi import UdpTransportTarget, ContextData, ObjectType, ObjectIdentity\n  from pysnmp.hlapi import usmHMACMD5AuthProtocol, usmHMACSHAAuthProtocol, usmHMAC384SHA512AuthProtocol\n  from pysnmp.hlapi import usmDESPrivProtocol, usmAesCfb128Protocol\n\n  SNMP_AUTHPROTO = {'md5': usmHMACMD5AuthProtocol, 'sha': usmHMACSHAAuthProtocol, 'sha512': usmHMAC384SHA512AuthProtocol}\n  SNMP_PRIVPROTO = {'des': usmDESPrivProtocol, 'aes': usmAesCfb128Protocol}\nexcept ImportError:\n  notfound.append('pysnmp')\n\ntry:\n  import pyasn1\nexcept ImportError:\n  notfound.append('pyasn1')\n\nclass SNMP_login:\n  '''Brute-force SNMP v1/2/3'''\n\n  usage_hints = (\n    \"\"\"%prog host=10.0.0.1 version=2 community=FILE0 0=names.txt -x ignore:mesg='No SNMP response received before timeout'\"\"\",\n    \"\"\"%prog host=10.0.0.1 version=3 user=FILE0 0=logins.txt -x ignore:mesg=unknownUserName\"\"\",\n    \"\"\"%prog host=10.0.0.1 version=3 user=myuser auth_key=FILE0 0=passwords.txt -x ignore:mesg=wrongDigest\"\"\",\n    )\n\n  available_options = (\n    ('host', 'target host'),\n    ('port', 'target port [161]'),\n    ('version', 'SNMP version to use [2|3|1]'),\n    ('community', 'SNMPv1/2c community names to test [public]'),\n    ('user', 'SNMPv3 usernames to test [op5user]'),\n    ('auth_key', 'SNMPv3 passwords to test [authPass]'),\n    ('auth_proto', 'SNMPv3 authentication protocol [md5|sha|sha512]'),\n    ('priv_key', 'SNMPv3 encryption key'),\n    ('priv_proto', 'SNMPv3 encryption protocol [des|aes]'),\n    ('timeout', 'seconds to wait for a response [1]'),\n    ('retries', 'number of successive request retries [2]'),\n    )\n  available_actions = ()\n\n  Response = Response_Base\n\n  def execute(self, host, port=None, version='2', community='public', user='op5user', auth_key='authPass', auth_proto='md5', priv_key='', priv_proto='des', timeout='1', retries='2'):\n    if version in ('1', '2', '2c'):\n      security_model = CommunityData(community, mpModel=0 if version == '1' else 1)\n\n    elif version == '3':\n      if auth_proto not in SNMP_AUTHPROTO:\n        raise ValueError('Unsupported SNMPv3 auth protocol %r' % auth_proto)\n      if priv_proto not in SNMP_PRIVPROTO:\n        raise ValueError('Unsupported SNMPv3 priv protocol %r' % priv_proto)\n\n      if len(auth_key) < 8 or priv_key and len(priv_key) < 8:\n        return self.Response('1', 'SNMPv3 requires passwords to be at least 8 characters long')\n\n      kwargs = dict(authKey=auth_key, authProtocol=SNMP_AUTHPROTO[auth_proto])\n      if priv_key:\n        kwargs.update(dict(privKey=priv_key, privProtocol=SNMP_PRIVPROTO[priv_proto]))\n\n      security_model = UsmUserData(user, **kwargs)\n\n    else:\n      raise ValueError('Incorrect SNMP version %r' % version)\n\n    with Timing() as timing:\n      errorIndication, errorStatus, errorIndex, varBinds = next(\n        getCmd(\n          SnmpEngine(),\n          security_model,\n          UdpTransportTarget((host, int(port or 161)), timeout=int(timeout), retries=int(retries)),\n          ContextData(),\n          ObjectType(ObjectIdentity('SNMPv2-MIB', 'sysDescr', 0))) #(1, 3, 6, 1, 2, 1, 1, 1, 0)\n        )\n\n    if errorIndication:\n      mesg = '%s' % errorIndication\n    elif errorStatus:\n      mesg = '%s' % (errorStatus.prettyPrint())\n      if errorIndex > 0:\n        mesg += ' %s' % varBinds[int(errorIndex) - 1][0]\n    else:\n      mesg = ''.join(' = '.join([x.prettyPrint() for x in varBind]) for varBind in varBinds)\n\n    return self.Response(int(errorStatus), mesg, timing)\n\n# }}}\n\n# IKE {{{\nif not which('ike-scan'):\n  notfound.append('ike-scan')\n\n# http://www.iana.org/assignments/ipsec-registry/ipsec-registry.xhtml (except for vendor specifics.) These transforms below are IKEv1 only. IKEv2 is not assessed.\nIKE_ENC   = [('1', 'DES'), ('2', 'IDEA'), ('3', 'BLOWFISH'), ('4', 'RC5'), ('5', '3DES'), ('6', 'CAST'), ('7/128', 'AES128'), ('7/192', 'AES192'), ('7/256', 'AES256'), ('8', 'Camellia'),\n            ('65001', 'Mars'), ('65002', 'RC6'), ('65004', 'Serpent'), ('65005', 'Twofish')]\nIKE_HASH  = [('1', 'MD5'), ('2', 'SHA1'), ('3', 'Tiger'), ('4', 'SHA2-256'), ('5', 'SHA2-384'), ('6', 'SHA2-512')]\nIKE_AUTH  = [('1', 'PSK'), ('2', 'DSS-Sig'), ('3', 'RSA-Sig'), ('4', 'RSA-Enc'), ('5', 'Revised-RSA-Enc'),\n            ('6', 'EIGAMEL-Enc'), ('7', 'Revised-EIGAMEL-Enc'), #('8', 'ECDSA-Sig'), # Reserved\n            #('9', 'ECDSA-SHA-256'), ('10', 'ECDSA-SHA-384'), ('11', 'ECDSA-SHA-512'), # RFC4754\n            ('128', 'Harkins-CRACK'), # https://tools.ietf.org/html/draft-harkins-ipsec-ike-crack-00.txt\n            ('64221', 'Hybrid-RSA-Sig'), ('64223', 'Hybrid-DSS-Sig'), ('65001', 'XAUTH&PSK')] #, ('65003', 'XAUTH&DSS-Sig'), ('65005', 'XAUTH&RSA-Sig'), ('65007', 'XAUTH&RSA-Enc'), ('65009', 'XAUTH&Revised-RSA-Enc')]\nIKE_GROUP = [('1', 'modp768'), ('2', 'modp1024'), ('5', 'modp1536'),\n            #('3', 'ec2n155'), ('4', 'ec2n185'),\n            # ('6', 'ec2n163'), ('7', 'ec2n163'), ('8', 'ec2n283'), ('9', 'ec2n283'), ('10', 'ec2n409'), ('11', 'ec2n409'), ('12', 'ec2n571'), ('13', 'ec2n571'), # only in draft, not RFC\n            ('14', 'modp2048')] #, ('15', 'modp3072'), ('16', 'modp4096'), ('17', 'modp6144'), ('18', 'modp8192')] # RFC3526\n            # ('19', 'ecp256'), ('20', 'ecp384'), ('21', 'ecp521'), ('22', 'modp1024s160'), ('23', 'modp2048s224'), ('24', 'modp2048s256'), ('25', 'ecp192'), ('26', 'ecp224'), # RFC5903\n            # ('27', 'brainpoolP224r1'), ('28', 'brainpoolP256r1'), ('29', 'brainpoolP384r1'), ('30', 'brainpoolP512r1')] # RFC6932\n\ndef generate_transforms():\n  lists = list(map(lambda l: [i[0] for i in l], [IKE_ENC, IKE_HASH, IKE_AUTH, IKE_GROUP]))\n  return map(lambda p: ','.join(p), product(*[chain(l) for l in lists])), reduce(lambda x, y: x*y, map(len, lists))\n\nclass Controller_IKE(Controller):\n\n  results = defaultdict(list)\n\n  def show_final(self):\n    ''' Expected output:\n+ 10.0.0.1:500 (Main Mode)\n    Encryption       Hash         Auth      Group\n    ---------- ----------   ---------- ----------\n          3DES        MD5          PSK   modp1024\n          3DES        MD5        XAUTH   modp1024\n        AES128       SHA1          PSK   modp1024\n        AES128       SHA1        XAUTH   modp1024\n\n+ 10.0.0.1:500 (Aggressive Mode)\n    Encryption       Hash         Auth      Group\n    ---------- ----------   ---------- ----------\n          3DES        MD5          PSK   modp1024\n          3DES        MD5        XAUTH   modp1024\n        AES128       SHA1          PSK   modp1024\n        AES128       SHA1        XAUTH   modp1024\n    '''\n\n    ike_enc = dict(IKE_ENC)\n    ike_hsh = dict(IKE_HASH)\n    ike_ath = dict(IKE_AUTH)\n    ike_grp = dict(IKE_GROUP)\n\n    for endpoint, transforms in self.results.items():\n      print('\\n+ %s' % endpoint)\n      print('    %10s %10s %12s %10s' % ('Encryption', 'Hash', 'Auth', 'Group'))\n      print('    %10s %10s %12s %10s' % ('-'*10, '-'*10, '-'*10, '-'*10))\n      for transform in transforms:\n        e, h, a, g = transform.split(',')\n        enc = ike_enc[e]\n        hsh = ike_hsh[h]\n        ath = ike_ath[a]\n        grp = ike_grp[g]\n        print('    %10s %10s %12s %10s' % (enc, hsh, ath, grp))\n\n  def push_final(self, resp):\n    if hasattr(resp, 'rrs'):\n      endpoint, transform = resp.rrs\n      self.results[endpoint].append(transform)\n\nclass IKE_enum:\n  '''Enumerate IKE transforms'''\n\n  usage_hints = [\n    '''%prog host=10.0.0.1 transform=MOD0 0=TRANS -x ignore:fgrep=NO-PROPOSAL''',\n    '''%prog host=10.0.0.1 transform=MOD0 0=TRANS -x ignore:fgrep=NO-PROPOSAL aggressive=RANGE1 1=int:0-1''',\n    ]\n\n  available_options = (\n    ('host', 'target host'),\n    ('port', 'target port [500]'),\n    ('transform', 'transform to test [5,1,1,2]'),\n    ('aggressive', 'use aggressive mode [0|1]'),\n    ('groupname', 'identification value for aggressive mode [foo]'),\n    ('vid', 'comma-separated vendor IDs to use'),\n    )\n  available_actions = ()\n\n  available_keys = {\n    'TRANS': generate_transforms,\n    }\n\n  Response = Response_Base\n\n  def __init__(self):\n    uid = multiprocessing.current_process().name[9:]\n    self.sport = '51%d' % int(uid)\n\n  def execute(self, host, port='500', transform='5,1,1,2', aggressive='0', groupname='foo', vid=''):\n\n    cmd = ['ike-scan', '-M', '--sport', self.sport, host, '--dport', port, '--trans', transform]\n    if aggressive == '1':\n      cmd.append('-A')\n      if groupname:\n        cmd.extend(['--id', groupname])\n    for v in vid.split(','):\n      cmd.extend(['--vendor', v])\n\n    with Timing() as timing:\n      p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n      out, err = map(B, p.communicate())\n      code = p.returncode\n\n    trace = '%s\\n[out]\\n%s\\n[err]\\n%s\\n' % (' '.join(cmd), out, err)\n    logger.debug('trace: %r' % trace)\n\n    has_sa = 'SA=(' in out\n    if has_sa:\n      mesg = 'Handshake returned: %s (%s)' % (re.search('SA=\\((.+) LifeType', out).group(1), re.search('\\t(.+) Mode Handshake returned', out).group(1))\n    else:\n      try:\n        mesg = out.strip().split('\\n')[1].split('\\t')[-1]\n      except:\n        mesg = ' '.join(repr(s) for s in filter(None, [out, err]))\n\n    resp = self.Response(code, mesg, timing, trace)\n    if has_sa:\n      endpoint = '%s:%s (%s Mode)' % (host, port, 'Aggressive' if aggressive == '1' else 'Main')\n      resp.rrs = endpoint, transform\n\n    return resp\n\n# }}}\n\n# Unzip {{{\nif not which('unzip'):\n  notfound.append('unzip')\n\nclass Unzip_pass:\n  '''Brute-force the password of encrypted ZIP files'''\n\n  usage_hints = [\n    \"\"\"%prog zipfile=file.zip password=FILE0 0=passwords.txt -x ignore:code!=0\"\"\",\n    ]\n\n  available_options = (\n    ('zipfile', 'ZIP files to test'),\n    ('password', 'passwords to test'),\n    )\n\n  available_actions = ()\n\n  Response = Response_Base\n\n  def execute(self, zipfile, password):\n    zipfile = os.path.abspath(zipfile)\n    cmd = ['unzip', '-t', '-q', '-P', password, zipfile]\n\n    with Timing() as timing:\n      p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n      out, err = map(B, p.communicate())\n      code = p.returncode\n\n    mesg = out.strip()\n    trace = '%s\\n[out]\\n%s\\n[err]\\n%s\\n' % (' '.join(cmd), out, err)\n\n    return self.Response(code, mesg, timing, trace)\n\n# }}}\n\n# Keystore {{{\nif not which('keytool'):\n  notfound.append('java')\n\nclass Keystore_pass:\n  '''Brute-force the password of Java keystore files'''\n\n  usage_hints = [\n    \"\"\"%prog keystore=keystore.jks password=FILE0 0=passwords.txt -x ignore:fgrep='password was incorrect'\"\"\",\n    ]\n\n  available_options = (\n    ('keystore', 'keystore files to test'),\n    ('password', 'passwords to test'),\n    ('storetype', 'type of keystore to test'),\n    )\n\n  available_actions = ()\n\n  Response = Response_Base\n\n  def execute(self, keystore, password, storetype='jks'):\n    keystore = os.path.abspath(keystore)\n    cmd = ['keytool', '-list', '-keystore', keystore, '-storepass', password, '-storetype', storetype]\n\n    with Timing() as timing:\n      p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n      out, err = map(B, p.communicate())\n      code = p.returncode\n\n    mesg = out.strip()\n    trace = '%s\\n[out]\\n%s\\n[err]\\n%s\\n' % (' '.join(cmd), out, err)\n\n    return self.Response(code, mesg, timing, trace)\n\n# }}}\n\n# SQLCipher {{{\ntry:\n  if PY3:\n    from pysqlcipher3 import dbapi2 as sqlcipher\n  else:\n    from pysqlcipher import dbapi2 as sqlcipher\nexcept ImportError:\n  notfound.append('pysqlcipher')\n\nclass SQLCipher_pass:\n  '''Brute-force the password of SQLCipher-encrypted databases'''\n\n  usage_hints = [\n    \"\"\"%prog database=db.sqlite password=FILE0 0=passwords.txt -x ignore:fgrep='file is encrypted'\"\"\",\n    ]\n\n  available_options = (\n    ('database', 'database files to test'),\n    ('password', 'passwords to test'),\n    )\n  available_actions = ()\n\n  Response = Response_Base\n\n  def execute(self, database, password):\n    with sqlcipher.connect(database) as db:\n      c = db.cursor()\n      c.execute('PRAGMA key=%r' % password)\n\n    try:\n      c.execute('PRAGMA integrity_check')\n      code, mesg = '0', 'OK'\n\n    except sqlcipher.DatabaseError as e:\n      code, mesg = '1', str(e)\n\n    return self.Response(code, mesg)\n\n# }}}\n\n# Umbraco {{{\nimport hmac\n\nclass Umbraco_crack:\n  '''Crack Umbraco HMAC-SHA1 password hashes'''\n\n  usage_hints = (\n    '''%prog hashlist=@umbraco_users.pw password=FILE0 0=passwords.txt''',\n    )\n\n  available_options = (\n    ('hashlist', 'hashes to crack'),\n    ('password', 'password to test'),\n    )\n  available_actions = ()\n\n  Response = Response_Base\n\n  def execute(self, password, hashlist):\n\n    p = password.encode('utf-16-le')\n    h = B(b64encode(hmac.new(p, p, digestmod=hashlib.sha1).digest()))\n\n    if h not in hashlist:\n      code, mesg = 1, 'fail'\n    else:\n      cracked = [line.rstrip() for line in hashlist.split('\\n') if h in line]\n      code, mesg = 0, ' '.join(cracked)\n\n    return self.Response(code, mesg)\n\n# }}}\n\n# TCP Fuzz {{{\nclass TCP_fuzz:\n  '''Fuzz TCP services'''\n\n  usage_hints = (\n    '''%prog host=10.0.0.1 port=10000 data=RANGE0 0=hex:0x00-0xffffff''',\n    )\n\n  available_options = (\n    ('host', 'target host'),\n    ('port', 'target port'),\n    ('timeout', 'seconds to wait for a response [10]'),\n    ('ssl', 'use SSL/TLS [0|1]'),\n    )\n  available_actions = ()\n\n  Response = Response_Base\n\n  def execute(self, host, port, data='', timeout='2', ssl='0'):\n    fp = socket.create_connection((host, port), int(timeout))\n    if ssl != '0':\n      fp = SSLContext().wrap_socket(sock=fp)\n    fp.send(unhexlify(data))\n    #fp.send(b(data))\n    with Timing() as timing:\n      resp = fp.recv(1024)\n    fp.close()\n\n    code = 0\n    #mesg = B(hexlify(resp))\n    mesg = B(resp)\n\n    return self.Response(code, mesg, timing)\n\n# }}}\n\n# Dummy Test {{{\ndef generate_tst():\n  return ['prd', 'dev'], 2\n\nclass Dummy_test:\n  '''Testing module'''\n\n  usage_hints = (\n    \"\"\"%prog data=_@@_RANGE0_@@_ 0=hex:0x00-0xff -e _@@_:unhex\"\"\",\n    \"\"\"%prog data=RANGE0 0=int:10-0\"\"\",\n    \"\"\"%prog data=PROG0 0='seq -w 10 -1 0'\"\"\",\n    \"\"\"%prog data=PROG0 0='mp64.bin -i ?l?l?l',$(mp64.bin --combination -i ?l?l?l)\"\"\",\n    )\n\n  available_options = (\n    ('data', 'data to test'),\n    ('data2', 'data2 to test'),\n    ('delay', 'fake random delay'),\n    )\n  available_actions = ()\n\n  available_keys = {\n    'TST': generate_tst,\n    }\n\n  Response = Response_Base\n\n  def execute(self, data, data2='', delay='1'):\n    code, mesg = 0, '%s / %s' % (data, data2)\n    with Timing() as timing:\n      sleep(random.randint(0, int(delay)*1000)/1000.0)\n\n    return self.Response(code, mesg, timing)\n\n# }}}\n\n# modules {{{\nmodules = [\n  ('ftp_login', (Controller, FTP_login)),\n  ('ssh_login', (Controller, SSH_login)),\n  ('telnet_login', (Controller, Telnet_login)),\n  ('smtp_login', (Controller, SMTP_login)),\n  ('smtp_vrfy', (Controller, SMTP_vrfy)),\n  ('smtp_rcpt', (Controller, SMTP_rcpt)),\n  ('finger_lookup', (Controller_Finger, Finger_lookup)),\n  ('http_fuzz', (Controller_HTTP, HTTP_fuzz)),\n  ('rdp_gateway', (Controller_HTTP, RDP_gateway)),\n  ('ajp_fuzz', (Controller, AJP_fuzz)),\n  ('pop_login', (Controller, POP_login)),\n  ('pop_passd', (Controller, POP_passd)),\n  ('imap_login', (Controller, IMAP_login)),\n  ('ldap_login', (Controller, LDAP_login)),\n  ('dcom_login', (Controller, DCOM_login)),\n  ('smb_login', (Controller, SMB_login)),\n  ('smb_lookupsid', (Controller, SMB_lookupsid)),\n  ('rlogin_login', (Controller, Rlogin_login)),\n  ('vmauthd_login', (Controller, VMauthd_login)),\n  ('mssql_login', (Controller, MSSQL_login)),\n  ('oracle_login', (Controller, Oracle_login)),\n  ('mysql_login', (Controller, MySQL_login)),\n  ('mysql_query', (Controller, MySQL_query)),\n  ('rdp_login', (Controller, RDP_login)),\n  ('pgsql_login', (Controller, Pgsql_login)),\n  ('vnc_login', (Controller, VNC_login)),\n\n  ('dns_forward', (Controller_DNS, DNS_forward)),\n  ('dns_reverse', (Controller_DNS, DNS_reverse)),\n  ('snmp_login', (Controller, SNMP_login)),\n  ('ike_enum', (Controller_IKE, IKE_enum)),\n\n  ('unzip_pass', (Controller, Unzip_pass)),\n  ('keystore_pass', (Controller, Keystore_pass)),\n  ('sqlcipher_pass', (Controller, SQLCipher_pass)),\n  ('umbraco_crack', (Controller, Umbraco_crack)),\n\n  ('tcp_fuzz', (Controller, TCP_fuzz)),\n  ('dummy_test', (Controller, Dummy_test)),\n  ]\n\ndependencies = {\n  'paramiko': [('ssh_login',), 'http://www.paramiko.org/', '2.7.1'],\n  'telnetlib': [('telnet_login',), 'telnetlib was removed in Python 3.13', '<= 3.12'],\n  'pycurl': [('http_fuzz', 'rdp_gateway'), 'http://pycurl.io/', '7.43.0'],\n  'libcurl': [('http_fuzz', 'rdp_gateway'), 'https://curl.haxx.se/', '7.58.0'],\n  'ajpy': [('ajp_fuzz',), 'https://github.com/hypn0s/AJPy/', '0.0.4'],\n  'openldap': [('ldap_login',), 'http://www.openldap.org/', '2.4.45'],\n  'impacket': [('smb_login', 'smb_lookupsid', 'dcom_login', 'mssql_login'), 'https://github.com/CoreSecurity/impacket', '0.9.20'],\n  'pyopenssl': [('mssql_login',), 'https://pyopenssl.org/', '19.1.0'],\n  'cx_Oracle': [('oracle_login',), 'http://cx-oracle.sourceforge.net/', '7.3.0'],\n  'mysqlclient': [('mysql_login',), 'https://github.com/PyMySQL/mysqlclient-python', '1.4.6'],\n  'xfreerdp': [('rdp_login',), 'https://github.com/FreeRDP/FreeRDP.git', '1.2.0-beta1'],\n  'psycopg': [('pgsql_login',), 'http://initd.org/psycopg/', '2.8.4'],\n  'pycrypto': [('smb_login', 'smb_lookupsid', 'mssql_login', 'vnc_login',), 'http://www.dlitz.net/software/pycrypto/', '2.6.1'],\n  'dnspython': [('dns_reverse', 'dns_forward'), 'http://www.dnspython.org/', '1.16.0'],\n  'IPy': [('dns_reverse', 'dns_forward'), 'https://github.com/haypo/python-ipy', '1.0'],\n  'pysnmp': [('snmp_login',), 'http://pysnmp.sf.net/', '4.4.12'],\n  'pyasn1': [('smb_login', 'smb_lookupsid', 'mssql_login', 'snmp_login'), 'http://sourceforge.net/projects/pyasn1/', '0.4.8'],\n  'ike-scan': [('ike_enum',), 'http://www.nta-monitor.com/tools-resources/security-tools/ike-scan', '1.9'],\n  'unzip': [('unzip_pass',), 'http://www.info-zip.org/', '6.0'],\n  'java': [('keystore_pass',), 'http://www.oracle.com/technetwork/java/javase/', '6'],\n  'pysqlcipher': [('sqlcipher_pass',), 'https://github.com/rigglemania/pysqlcipher3', '1.0.3'],\n  'python': [('ftp_login',), 'Patator requires Python 3.6 or above and may still work on Python 2.'],\n  }\n\n# }}}\n\n# main {{{\nif __name__ == '__main__':\n  multiprocessing.freeze_support()\n\n  def show_usage():\n    print(__banner__)\n    print('''Usage: patator.py module --help\n\nAvailable modules:\n%s''' % '\\n'.join('  + %-13s : %s' % (k, v[1].__doc__) for k, v in modules))\n\n    sys.exit(2)\n\n  available = dict(modules)\n  name = os.path.basename(sys.argv[0]).lower()\n\n  if name not in available:\n    if len(sys.argv) == 1:\n      show_usage()\n\n    name = os.path.basename(sys.argv[1]).lower()\n    if name not in available:\n      show_usage()\n\n    del sys.argv[0]\n\n  # dependencies\n  abort = False\n  for k in set(notfound):\n    args = dependencies[k]\n    if name in args[0]:\n      if len(args) == 2:\n        print('WARNING: %s' % args[1])\n      else:\n        url, ver = args[1:]\n        print('ERROR: %s %s (%s) is required to run %s.' % (k, ver, url, name))\n        abort = True\n\n  if abort:\n    print('Please read the README inside for more information.')\n    sys.exit(3)\n\n  # start\n  ctrl, module = available[name]\n  powder = ctrl(module, [name] + sys.argv[1:])\n  powder.fire()\n\n# }}}\n\n# vim: ts=2 sw=2 sts=2 et fdm=marker bg=dark\n"
        },
        {
          "name": "release.sh",
          "type": "blob",
          "size": 0.4208984375,
          "content": "#!/bin/bash\n\nset -ex\n\nDOCKER_IMAGE='lanjelot/patator'\nGIT_REPO='https://github.com/lanjelot/patator'\nTMP_COPY=$(mktemp -d)\n\ngit clone -b master $GIT_REPO $TMP_COPY\ncd $TMP_COPY\nVERSION=$(echo `git tag|sort -V|tail -1`-`git rev-parse --verify HEAD|cut -b -7`)\nsed -i -e \"s,^__version__.*$,__version__ = '$VERSION',\" patator.py\ndocker build . -t $DOCKER_IMAGE:$VERSION -t $DOCKER_IMAGE:latest\n\ndocker login\ndocker push $DOCKER_IMAGE\n"
        },
        {
          "name": "requirements.txt",
          "type": "blob",
          "size": 0.14453125,
          "content": "paramiko\npycurl\najpy\nimpacket\npyopenssl\ncx_Oracle\nmysqlclient\npsycopg2-binary\npycryptodomex\ndnspython\nIPy\npysnmp==4.4.12\npyasn1==0.4.8\npysqlcipher3\n"
        },
        {
          "name": "run-tests.sh",
          "type": "blob",
          "size": 4.724609375,
          "content": "#!/bin/bash\n\nif ! docker compose version &>/dev/null; then\n  echo 'docker compose is required'\n  exit 1\nfi\n\ndocker compose up -d --build\n\ncase \"$1\" in\n  python2|python3)\n    PYTHON=$1\n    ;;\n  *)\n    PYTHON='python3'\n  ;;\nesac\n\nUNIX='unix'\nORACLE='oracle'\nMSSQL='mssql'\nWIN10='' # 192.168.1.5 # vagrant add senglin/win-7-enterprise\nVPN=''   #\n\nLOGS='-l ./asdf -y --hits ./hits.txt'\n\nrun()\n{\n  echo\n  echo \"$ $@\"\n  docker compose run --no-deps --rm --entrypoint \"$PYTHON patator.py\" patator \"$@\"\n}\n\necho\necho \">>> $PYTHON\"\n\nrun ftp_login host=$UNIX\nrun ftp_login host=$UNIX user=userRANGE0 password=PasswordRANGE0 0=int:0-9\n\nrun ssh_login host=$UNIX\nrun ssh_login host=$UNIX user=userRANGE0 password=PasswordRANGE0 0=int:0-9\n\nrun telnet_login host=$UNIX\nrun telnet_login host=$UNIX inputs='userRANGE0\\nPasswordRANGE0' 0=int:0-9 prompt_re='login:|Password:' timeout=5\n\nrun smtp_vrfy host=$UNIX\nrun smtp_vrfy host=$UNIX user=userRANGE0 0=int:1-500 -x ignore:fgrep='User unknown' -x ignore,reset,retry:code=421 --auto-progress 10\n\nrun smtp_rcpt host=$UNIX\nrun smtp_rcpt host=$UNIX mail_from=root@localhost user=userRANGE0@localhost 0=int:1-200 -x ignore:fgrep='User unknown'\n\nrun smtp_login host=$UNIX\nrun smtp_login host=$UNIX user=userRANGE0 password=PasswordRANGE0 0=int:0-30 starttls=1 #-x ignore,reset,retry:code=421\n\nrun finger_lookup host=$UNIX\nrun finger_lookup host=$UNIX user=userRANGE0 0=int:0-20 -x ignore:fgrep='no such user'\n\nrun ldap_login host=$UNIX\nrun ldap_login host=$UNIX binddn='cn=admin,dc=example,dc=com' bindpw=PasswordRANGE0 0=int:0-9 basedn='dc=example,dc=com'\n\nrun smb_login host=$UNIX\nrun smb_login host=$UNIX user=userRANGE0 password=PasswordRANGE0 0=int:0-9\n\nif [[ ! -z $WIN10 ]]; then\n  run smb_login host=$WIN10 user=vagranRANGE0 password=vagranRANGE0 0=lower:r-v\n  run smb_lookupsid host=$WIN10 user=vagrant password=vagrant rid=RANGE0 0=int:500-2000 -x ignore:code=1\n  run dcom_login host=$WIN10 user=vagranRANGE0 password=vagranRANGE0 0=lower:r-v\n\n  xhost +si:localuser:root\n  run rdp_login host=$WIN10 user=vagranRANGE0 password=vagranRANGE0 0=lower:r-v\n  xhost -si:localuser:root\nfi\n\nrun pop_login host=$UNIX\nrun pop_login host=$UNIX user=userRANGE0 password=PasswordRANGE0 0=int:0-9\n\nrun pop_passd host=$UNIX\nrun pop_passd host=$UNIX user=userRANGE0 password=PasswordRANGE0 0=int:0-9\n\nrun imap_login host=$UNIX\nrun imap_login host=$UNIX user=userRANGE0 password=PasswordRANGE0 0=int:0-9\n\nrun rlogin_login host=$UNIX user=userRANGE0 password=PasswordRANGE0 0=int:0-9\n\nrun mysql_login host=$UNIX\nrun mysql_login host=$UNIX user=root password=PasswordRANGE0 0=int:0-9\n\nrun mysql_query host=$UNIX user=root password=Password1 query='select host, user from mysql.user'\nrun mysql_query host=$UNIX user=root password=Password1 query='select load_file(\"/etc/hosts\")'\n\nrun mssql_login host=$MSSQL user=sa password=PasswordRANGE0 0=int:0-9\n\nrun oracle_login host=$ORACLE sid=xRANGE0 0=lower:a-f -t 1\nrun oracle_login host=$ORACLE sid=xe user=sys password=oraclRANGE0 0=lower:a-f\n\nrun pgsql_login host=$UNIX\nrun pgsql_login host=$UNIX user=postgres password=PasswordRANGE0 0=int:0-9\n\nrun http_fuzz url=\"http://$UNIX/RANGE0\" 0=lower:a-zzz -x ignore:code=404\nrun http_fuzz url=http://$UNIX:8080/manager/html user_pass=tomcat:PasswordRANGE0 0=int:0-9\n\nrun ajp_fuzz url=ajp://$UNIX/manager/html user_pass=tomcat:PasswordRANGE0 0=int:0-9\n\nrun vnc_login host=$UNIX port=5900 password=PassworRANGE0 0=lower:a-f\n\nrun dns_reverse host=NET0 0=216.239.32.0-216.239.32.255,8.8.8.0/24 -x ignore:code=3 -x ignore:fgrep!=google.com -x ignore:fgrep=216-239-\nrun dns_forward name=MOD0.microsoft.com 0=SRV qtype=SRV -x ignore:code=3 --auto-progress 15\n\nrun snmp_login host=$UNIX community=publiRANGE0 0=lower:a-f\nrun snmp_login host=$UNIX community=public version=3 user=userRANGE0 0=int:0-5 auth_key=whatever\nrun snmp_login host=$UNIX community=public version=3 user=user3 auth_proto=sha auth_key=authPasRANGE0 0=lower:q-v\nrun snmp_login host=$UNIX community=public version=3 user=user3 auth_proto=sha auth_key=authPass priv_proto=aes priv_key=privPasRANGE0 0=lower:q-v\n\nif [[ ! -z $VPN ]]; then\n  run ike_enum host=$VPN transform=MOD0 0=TRANS aggressive=RANGE1 1=int:0-1 -x ignore:fgrep=NO-PROPOSAL\nfi\n\nrun unzip_pass zipfile=enc.zip password=PasswordRANGE0 0=int:0-9\nrun keystore_pass keystore=keystore.jks password=PasswordRANGE0 0=int:0-9\nrun sqlcipher_pass database=enc.db password=PasswordRANGE0 0=int:0-9\nrun umbraco_crack hashlist=@umbraco_users.pw password=PasswordRANGE0 0=int:0-9\n\nrun tcp_fuzz host=$UNIX port=4444 data=RANGE0 0=hex:0xf0-0xf9 # $LOGS\n\necho -e '\\xde\\xad\\xbe\\xef\\nprintable ascii' > dummy.txt\nrun dummy_test delay=0 data=FILE0 0=dummy.txt data2=RANGE1 1=lower:a-b\n\necho -e 'wrong pass\\np\\x1fssw\\x09rd' > user9.pass\nrun ssh_login host=unix user=user9 password=FILE0 0=user9.pass\n\nrm -f dummy.txt user9.pass\n"
        },
        {
          "name": "setup.py",
          "type": "blob",
          "size": 1.7119140625,
          "content": "from setuptools import setup, find_packages\n\ndef parse_requirements(file):\n    required = []\n    with open(file) as f:\n        for req in f.read().splitlines():\n            if not req.strip().startswith('#'):\n                required.append(req)\n    return required\n\nrequirements = parse_requirements('requirements.txt')\nlong_description = \"Patator was written out of frustration from using Hydra, Medusa, Ncrack, Metasploit modules and Nmap NSE scripts for password guessing attacks. I opted for a different approach in order to not create yet another brute-forcing tool and avoid repeating the same shortcomings. Patator is a multi-threaded tool written in Python, that strives to be more reliable and flexible than his fellow predecessors.\"\n\nsetup(\n    name=\"patator\",\n    version=\"1.0\",\n    description=\"multi-purpose brute-forcer\",\n    long_description=long_description,\n    url=\"https://github.com/lanjelot/patator\",\n    author=\"Sebastien Macke\",\n    author_email=\"patator@hsc.fr\",\n    license=\"GPLv2\",\n\n    classifiers=[\n        'Development Status :: 4 - Beta',\n        'Environment :: Console',\n        'Intended Audience :: Developers',\n        'Intended Audience :: System Administrators',\n        'Intended Audience :: Information Technology',\n        'License :: OSI Approved :: GNU General Public License v2 (GPLv2)',\n        'Programming Language :: Python :: 3',\n        'Operating System :: Microsoft :: Windows',\n        'Operating System :: POSIX :: Linux',\n        'Topic :: Utilities',\n        'Topic :: Security',\n    ],\n\n    keywords=\"pentest brute force password attack\",\n    packages=find_packages(),\n    install_requires=requirements,\n\n    python_requires='>=2.7, !=3.0.*, !=3.1.*, !=3.2.*, <4',\n\n    scripts=['patator.py'],\n)\n"
        },
        {
          "name": "testing",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}