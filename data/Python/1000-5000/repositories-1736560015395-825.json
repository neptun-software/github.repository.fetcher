{
  "metadata": {
    "timestamp": 1736560015395,
    "page": 825,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjgzMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "ZiniuLu/Python-100-Days",
      "stars": 3385,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.029296875,
          "content": "venv\n.idea\n*.pyc\n__pycache__\n\n"
        },
        {
          "name": "Day01-15",
          "type": "tree",
          "content": null
        },
        {
          "name": "Day16-20",
          "type": "tree",
          "content": null
        },
        {
          "name": "Day21-30",
          "type": "tree",
          "content": null
        },
        {
          "name": "Day31-35",
          "type": "tree",
          "content": null
        },
        {
          "name": "Day36-40",
          "type": "tree",
          "content": null
        },
        {
          "name": "Day41-55",
          "type": "tree",
          "content": null
        },
        {
          "name": "Day56-65",
          "type": "tree",
          "content": null
        },
        {
          "name": "Day66-75",
          "type": "tree",
          "content": null
        },
        {
          "name": "Day76-90",
          "type": "tree",
          "content": null
        },
        {
          "name": "Day91-100",
          "type": "tree",
          "content": null
        },
        {
          "name": "PEP 8风格指南.md",
          "type": "blob",
          "size": 4.064453125,
          "content": "## PEP 8风格指南\n\nPEP是Python Enhancement Proposal的缩写，通常翻译为“Python增强提案”。每个PEP都是一份为Python社区提供的指导Python往更好的方向发展的技术文档，其中的第8号增提案即PEP 8是针对Python语言编订的代码风格指南。尽管我们可以在保证语法没有问题的前提下随意书写Python代码，但是在实际开发中，采用一致的风格书写出可读性强的代码是每个专业的程序员应该做到的事情，也是每个公司的编程规范中会提出的要求，这些在多人协作开发一个项目（团队开发）的时候显得尤为重要。我们可以从Python官方网站的[PEP 8链接](https://www.python.org/dev/peps/pep-0008/)中找到该文档，下面我们对该文档的关键部分做一个简单的总结。\n\n### 空格的使用\n\n1. **使用空格来表示缩进而不要用制表符（Tab）**。这一点对习惯了其他编程语言的人来说简直觉得不可理喻，因为绝大多数的程序员都会用Tab来表示缩进，但是要知道Python并没有像C/C++或Java那样的用花括号来构造一个代码块的语法，在Python中分支和循环结构都使用缩进来表示哪些代码属于同一个级别，鉴于此Python代码对缩进以及缩进宽度的依赖比其他很多语言都强得多。在不同的编辑器中，Tab的宽度可能是2、4或8个字符，甚至是其他更离谱的值，用Tab来表示缩进对Python代码来说可能是一场灾难。\n2. **和语法相关的每一层缩进都用4个空格来表示。**\n3. **每行的字符数不要超过79个字符，如果表达式因太长而占据了多行，除了首行之外的其余各行都应该在正常的缩进宽度上再加上4个空格。**\n4. **函数和类的定义，代码前后都要用两个空行进行分隔。**\n5. **在同一个类中，各个方法之间应该用一个空行进行分隔。**\n6. **二元运算符的左右两侧应该保留一个空格，而且只要一个空格就好。**\n\n### 标识符命名\n\nPEP 8倡导用不同的命名风格来命名Python中不同的标识符，以便在阅读代码时能够通过标识符的名称来确定该标识符在Python中扮演了怎样的角色（在这一点上，Python自己的内置模块以及某些第三方模块都做得并不是很好）。\n\n1. **变量、函数和属性应该使用小写字母来拼写，如果有多个单词就使用下划线进行连接。**\n2. **类中受保护的实例属性，应该以一个下划线开头。**\n3. **类中私有的实例属性，应该以两个下划线开头。**\n4. **类和异常的命名，应该每个单词首字母大写。**\n5. **模块级别的常量，应该采用全大写字母，如果有多个单词就用下划线进行连接。**\n6. **类的实例方法，应该把第一个参数命名为`self`以表示对象自身。**\n7. **类的类方法，应该把第一个参数命名为`cls`以表示该类自身。**\n\n### 表达式和语句\n\n在Python之禅（可以使用`import this`查看）中有这么一句名言：“There should be one-- and preferably only one --obvious way to do it.”，翻译成中文是“做一件事应该有而且最好只有一种确切的做法”，这句话传达的思想在PEP 8中也是无处不在的。\n\n1. **采用内联形式的否定词，而不要把否定词放在整个表达式的前面。**例如`if a is not b`就比`if not a is b`更容易让人理解。\n2. **不要用检查长度的方式来判断字符串、列表等是否为`None`或者没有元素，应该用`if not x`这样的写法来检查它。**\n3. **就算`if`分支、`for`循环、`except`异常捕获等中只有一行代码，也不要将代码和`if`、`for`、`except`等写在一起，分开写才会让代码更清晰。**\n4. **`import`语句总是放在文件开头的地方**。\n5. **引入模块的时候，`from math import sqrt`比`import math`更好。**\n6. **如果有多个`import`语句，应该将其分为三部分，从上到下分别是Python标准模块、第三方模块和自定义模块，每个部分内部应该按照模块名称的字母表顺序来排列。**\n\n"
        },
        {
          "name": "Python参考书籍.md",
          "type": "blob",
          "size": 2.4873046875,
          "content": "## Python参考书籍\n\n### 入门读物\n\n1. 《Python基础教程》（*Beginning Python From Novice to Professional*）\n2. 《Python学习手册》（*Learning Python*）\n3. 《Python编程》（*Programming Python*）\n4. 《Python Cookbook》\n5. 《Python程序设计》（*Python Programming: An Introduction to Computer Science*）\n6. 《Modern Python Cookbook》\n\n### 进阶读物\n\n1. 《Python核心编程》（*Core Python Applications Programming*）\n2. 《流畅的Python》（*Fluent Python*）\n3. 《Effective Python：编写高质量Python代码的59个有效方法》（*Effective Python 59 Specific Ways to Write Better Python*）\n4. 《Python设计模式》（*Learning Python Design Patterns*）\n5. 《Python高级编程》（*Expert Python Programming*）\n6. 《Python性能分析与优化》（*Mastering Python High Performance*）\n\n### Web框架\n\n1. 《Django基础教程》（*Tango with Django*）\n2. 《轻量级Django》（*Lightweight Django*）\n3. 《Python Web开发：测试驱动方法》（*Test-Driven Development with Python*）\n4. 《Web Development with Django Cookbook》\n5. 《Test-Driven Development with Django》\n6. 《Django Project Blueprints 》\n7. 《Flask Web开发：基于Python的Web应用开发实战》（*Flask Web Development: Developing Web Applications with Python*）\n8. 《深入理解Flask》（*Mastering Flask*）\n\n### 爬虫开发\n\n1. 《用Python写网络爬虫》（*Web Scraping with Python*）\n2. 《精通Python爬虫框架Scrapy》（*Learning Scrapy*）\n3. 《Python网络数据采集》（*Web Scraping with Python*）\n4. 《Python爬虫开发与项目实战》\n5. 《Python 3网络爬虫开发实战》\n\n### 数据分析\n\n1. 《利用Python进行数据分析》（*Python for Data Analysis*）\n2. 《Python数据科学手册》（*Python Data Science Handbook*）\n3. 《Python金融大数据分析》（*Python for Finance*）\n4. 《Python数据可视化编程实战》（*Python Data Visualization Cookbook*）\n5. 《Python数据处理》（*Data Wrangling with Python*）\n\n### 机器学习\n\n1. 《Python机器学习基础教程》（*Introduction to Machine Learning with Python*）\n2. 《Python机器学习实践指南》（*Python Machine Learning Blueprints*）\n3. 《Python Machine Learning Case Studies》\n4. 《Python机器学习实践：测试驱动的开发方法》（*Thoughtful Machine Learning with Python A Test Driven Approach*）\n5. 《Python机器学习经典实例》（*Python Machine Learning Cookbook*）\n6. 《TensorFlow：实战Google深度学习框架》"
        },
        {
          "name": "Python惯例.md",
          "type": "blob",
          "size": 3.74609375,
          "content": "## Python惯例\n\n“惯例”这个词指的是“习惯的做法，常规的办法，一贯的做法”，与这个词对应的英文单词叫“idiom”。由于Python跟其他很多编程语言在语法和使用上还是有比较显著的差别，因此作为一个Python开发者如果不能掌握这些惯例，就无法写出“Pythonic”的代码。下面我们总结了一些在Python开发中的惯用的代码。\n\n1. 让代码既可以被导入又可以被执行。\n\n   ```Python\n   if __name__ == '__main__':\n   ```\n\n\n2. 用下面的方式判断逻辑“真”或“假”。\n\n   ```Python\n   if x:\n   if not x:\n   ```\n\n   **好**的代码：\n\n   ```Python\n   name = 'jackfrued'\n   fruits = ['apple', 'orange', 'grape']\n   owners = {'1001': '骆昊', '1002': '王大锤'}\n   if name and fruits and owners:\n       print('I love fruits!')\n   ```\n\n   **不好**的代码：\n\n   ```Python\n   name = 'jackfrued'\n   fruits = ['apple', 'orange', 'grape']\n   owners = {'1001': '骆昊', '1002': '王大锤'}\n   if name != '' and len(fruits) > 0 and owners != {}:\n       print('I love fruits!')\n   ```\n\n3. 善于使用in运算符。\n\n   ```Python\n   if x in items: # 包含\n   for x in items: # 迭代\n   ```\n\n   **好**的代码：\n\n   ```Python\n   name = 'Hao LUO'\n   if 'L' in name:\n       print('The name has an L in it.')\n   ```\n\n   **不好**的代码：\n\n   ```Python\n   name = 'Hao LUO'\n   if name.find('L') != -1:\n       print('This name has an L in it!')\n   ```\n\n4. 不使用临时变量交换两个值。\n\n   ```Python\n   a, b = b, a\n   ```\n\n5. 用序列构建字符串。\n\n   **好**的代码：\n\n   ```Python\n   chars = ['j', 'a', 'c', 'k', 'f', 'r', 'u', 'e', 'd']\n   name = ''.join(chars)\n   print(name)  # jackfrued\n   ```\n\n   **不好**的代码：\n\n   ```Python\n   chars = ['j', 'a', 'c', 'k', 'f', 'r', 'u', 'e', 'd']\n   name = ''\n   for char in chars:\n       name += char\n   print(name)  # jackfrued\n   ```\n\n6. EAFP优于LBYL。\n\n   EAFP - **E**asier to **A**sk **F**orgiveness than **P**ermission.\n\n   LBYL - **L**ook **B**efore **Y**ou **L**eap.\n\n   **好**的代码：\n\n   ```Python\n   d = {'x': '5'}\n   try:\n       value = int(d['x'])\n       print(value)\n   except (KeyError, TypeError, ValueError):\n       value = None\n   ```\n\n   **不好**的代码：\n\n   ```Python\n   d = {'x': '5'}\n   if 'x' in d and isinstance(d['x'], str) \\\n   \t\tand d['x'].isdigit():\n       value = int(d['x'])\n       print(value)\n   else:\n       value = None\n   ```\n\n7. 使用enumerate进行迭代。\n\n   **好**的代码：\n\n   ```Python\n   fruits = ['orange', 'grape', 'pitaya', 'blueberry']\n   for index, fruit in enumerate(fruits):\n   \tprint(index, ':', fruit)\n   ```\n\n   **不好**的代码：\n\n   ```Python\n   fruits = ['orange', 'grape', 'pitaya', 'blueberry']\n   index = 0\n   for fruit in fruits:\n       print(index, ':', fruit)\n       index += 1\n   ```\n\n8. 用生成式生成列表。\n\n   **好**的代码：\n\n   ```Python\n   data = [7, 20, 3, 15, 11]\n   result = [num * 3 for num in data if num > 10]\n   print(result)  # [60, 45, 33]\n   ```\n\n   **不好**的代码：\n\n   ```Python\n   data = [7, 20, 3, 15, 11]\n   result = []\n   for i in data:\n       if i > 10:\n           result.append(i * 3)\n   print(result)  # [60, 45, 33]\n   ```\n\n9. 用zip组合键和值来创建字典。\n\n   **好**的代码：\n\n   ```Python\n   keys = ['1001', '1002', '1003']\n   values = ['骆昊', '王大锤', '白元芳']\n   d = dict(zip(keys, values))\n   print(d)\n   ```\n\n   **不好**的代码：\n\n   ```Python\n   keys = ['1001', '1002', '1003']\n   values = ['骆昊', '王大锤', '白元芳']\n   d = {}\n   for i, key in enumerate(keys):\n       d[key] = values[i]\n   print(d)\n   ```\n\n> **说明**：这篇文章的内容来自于网络，有兴趣的读者可以阅读[原文](http://safehammad.com/downloads/python-idioms-2014-01-16.pdf)。\n\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 13.00390625,
          "content": "## Python - 100天从新手到大师\n\n### Python应用领域和就业形势分析\n\n简单的说，Python是一个“优雅”、“明确”、“简单”的编程语言。\n\n - 学习曲线低，适合非专业人士\n - 开源系统，拥有强大的生态圈\n - 解释型语言，完美的平台可移植性\n - 支持面向对象和函数式编程\n - 可扩展性，能调用C/C++代码\n - 代码规范程度高，可读性强\n\n目前几个比较流行的领域，Python都有用武之地。\n\n - 云基础设施 - Python / Java / Go\n - DevOps - Python / Shell / Ruby / Go\n - 网络爬虫 - Python / PHP / C++\n - 数据分析挖掘 - Python / R / Scala / Matlab\n - 机器学习 - Python / R / Java / Lisp\n\n作为一名Python开发者，主要的就业领域包括：\n\n- Python服务器后台开发 / 游戏服务器开发 / 数据接口开发工程师\n- Python自动化运维工程师\n- Python数据分析 / 数据可视化 / 科学计算 / 大数据工程师\n- Python爬虫工程师\n- Python聊天机器人开发 / 图像识别和视觉算法 / 深度学习工程师\n\n下图显示了主要城市Python招聘需求量及薪资待遇排行榜（截止到2018年5月）。\n\n![Python招聘需求及薪资待遇Top 10](./res/python-top-10.png)\n\n![](./res/python-bj-salary.png)\n\n![](./res/python-cd-salary.png)\n\n给初学者的几个建议（老司机的忠告）：\n\n- Make English as your working language.\n- Practice makes perfect.\n- All experience comes from mistakes.\n- Don't be one of the leeches.\n- Either stand out or kicked out.\n\n### Day01~15 - [Python语言基础](./Day01-15)\n\n#### Day01 - [初识Python](./Day01-15/Day01/初识Python.md)\n\n- Python简介 - Python的历史 / Python的优缺点 / Python的应用领域\n- 搭建编程环境 - Windows环境 / Linux环境 / MacOS环境\n- 从终端运行Python程序 - DOS命令 / Hello, world / print函数 / 运行程序\n- 使用IDLE - 交互式环境(REPL) / 编写多行代码 / 运行程序 / 退出IDLE\n- 注释 - 注释的作用 / 单行注释 / 多行注释\n\n#### Day02 - [语言元素](./Day01-15/Day02/语言元素.md)\n\n- 程序和进制 - 指令和程序 / 冯诺依曼机 / 二进制和十进制 / 八进制和十六进制\n- 变量和类型 - 变量的命名 / 变量的使用 / input函数 / 检查变量类型 / 类型转换\n- 数字和字符串 - 整数 / 浮点数 / 复数 / 字符串 / 字符串基本操作 / 字符编码\n- 运算符 - 数学运算符 / 赋值运算符 / 比较运算符 / 逻辑运算符 / 身份运算符 / 运算符的优先级\n- 应用案例 - 华氏温度转换成摄氏温度 / 输入圆的半径计算周长和面积 / 输入年份判断是否是闰年\n\n#### Day03 - [分支结构](./Day01-15/Day03/分支结构.md)\n\n- 分支结构的应用场景 - 条件 / 缩进 / 代码块 / 流程图\n- if语句 - 简单的if / if-else结构 / if-elif-else结构 / 嵌套的if\n- 应用案例 - 用户身份验证 / 英制单位与公制单位互换 / 掷骰子决定做什么 / 百分制成绩转等级制 / 分段函数求值 / 输入三条边的长度如果能构成三角形就计算周长和面积\n\n#### Day04 - [循环结构](./Day01-15/Day04/循环结构.md)\n\n- 循环结构的应用场景 - 条件 / 缩进 / 代码块 / 流程图\n- while循环 - 基本结构 / break语句 / continue语句\n- for循环 - 基本结构 / range类型 / 循环中的分支结构 / 嵌套的循环 / 提前结束程序 \n- 应用案例 - 1~100求和 / 判断素数 / 猜数字游戏 / 打印九九表 / 打印三角形图案 / 猴子吃桃 / 百钱百鸡\n\n#### Day05 - [总结和练习](./Day01-15/Day05/练习.md)\n\n- 基础练习 - 水仙花数 / 完美数 / 五人分鱼 / Fibonacci数列 / 回文素数 \n- 综合练习 - Craps赌博游戏\n\n#### Day06 - [函数和模块的使用](./Day01-15/Day06/函数和模块的使用.md)\n\n- 函数的作用 - 代码的坏味道 / 用函数封装功能模块\n- 定义函数 - def语句 / 函数名 / 参数列表 / return语句 / 调用自定义函数\n- 调用函数 - Python内置函数 /  导入模块和函数\n- 函数的参数 - 默认参数 / 可变参数 / 关键字参数(\\*) / 命名关键字参数(\\*)\n- 函数的返回值 - 没有返回值  / 返回单个值 / 返回多个值(\\*)\n- 作用域问题 - 局部作用域 / 嵌套作用域 / 全局作用域 / 内置作用域 / 和作用域相关的关键字\n- 用模块管理函数 - 模块的概念 / 用自定义模块管理函数 / 命名冲突的时候会怎样（同一个模块和不同的模块）\n\n#### Day07 - [字符串和常用数据结构](./Day01-15/Day07/字符串和常用数据结构.md)\n\n- 字符串的使用 - 计算长度 / 下标运算 / 切片 / 常用方法\n- 列表基本用法 - 定义列表 / 用下表访问元素 / 下标越界 / 添加元素 / 删除元素 / 修改元素 / 切片 / 循环遍历\n- 列表常用操作 - 连接 / 复制(复制元素和复制数组) / 长度 / 排序 / 倒转 / 查找\n- 生成列表 - 使用range创建数字列表 / 生成表达式 / 生成器\n- 元组的使用 - 定义元组 / 使用元组中的值 / 修改元组变量 / 元组和列表转换\n- 集合基本用法 - 集合和列表的区别 /  创建集合 / 添加元素 / 删除元素 /  清空\n- 集合常用操作 - 交集 / 并集 / 差集 / 对称差 / 子集 / 超集\n- 字典的基本用法 - 字典的特点 / 创建字典 / 添加元素 / 删除元素 / 取值 / 清空\n- 字典常用操作 - keys()方法 / values()方法 / items()方法 / setdefault()方法\n- 基础练习 - 跑马灯效果 / 列表找最大元素 / 统计考试成绩的平均分 / Fibonacci数列 / 杨辉三角\n- 综合案例 - 双色球选号 / 井字棋\n\n#### Day08 - [面向对象编程基础](./Day01-15/Day08/面向对象编程基础.md)\n\n- 类和对象 - 什么是类 / 什么是对象 / 面向对象其他相关概念\n- 定义类 - 基本结构 / 属性和方法 / 构造器 / 析构器 / \\_\\_str\\_\\_方法\n- 使用对象 - 创建对象 / 给对象发消息\n- 面向对象的四大支柱 - 抽象 / 封装 / 继承 / 多态\n- 基础练习 - 定义学生类 / 定义时钟类 / 定义图形类 / 定义汽车类\n\n#### Day09 - [面向对象进阶](./Day01-15/Day09/面向对象进阶.md)\n\n- 属性 - 类属性 / 实例属性 / 属性访问器 / 属性修改器 / 属性删除器 / 使用\\_\\_slots\\_\\_\n- 类中的方法 - 实例方法 / 类方法 / 静态方法\n- 运算符重载 - \\_\\_add\\_\\_ / \\_\\_sub\\_\\_ / \\_\\_or\\_\\_ /\\_\\_getitem\\_\\_ / \\_\\_setitem\\_\\_ / \\_\\_len\\_\\_ / \\_\\_repr\\_\\_ / \\_\\_gt\\_\\_ / \\_\\_lt\\_\\_ / \\_\\_le\\_\\_ / \\_\\_ge\\_\\_ / \\_\\_eq\\_\\_ / \\_\\_ne\\_\\_ / \\_\\_contains\\_\\_ \n- 类(的对象)之间的关系 - 关联 / 继承 / 依赖\n- 继承和多态 - 什么是继承 / 继承的语法 / 调用父类方法 / 方法重写 / 类型判定 / 多重继承 / 菱形继承(钻石继承)和C3算法\n- 综合案例 - 工资结算系统 / 图书自动折扣系统 / 自定义分数类\n\n#### Day10 - [图形用户界面和游戏开发](./Day01-15/Day10/图形用户界面和游戏开发.md)\n\n#### Day11 - [文件和异常](./Day01-15/Day11/文件和异常.md)\n\n- 读文件 - 读取整个文件 / 逐行读取 / 文件路径\n- 写文件 - 覆盖写入 / 追加写入 / 文本文件 / 二进制文件\n- 异常处理 - 异常机制的重要性 / try-except代码块 / else代码块 / finally代码块 / 内置异常类型 / 异常栈 / raise语句\n- 数据持久化 - CSV文件概述 / csv模块的应用 / JSON数据格式 / json模块的应用\n- 综合案例 - 歌词解析\n\n#### Day12 - [字符串和正则表达式](./Day01-15/Day12/字符串和正则表达式.md)\n\n- 字符串高级操作 - 转义字符 \\ 原始字符串 \\ 多行字符串 \\ in和 not in运算符 \\ is开头的方法 \\ join和split方法 \\ strip相关方法 \\ pyperclip模块 \\ 不变字符串和可变字符串 \\ StringIO的使用\n- 正则表达式入门 - 正则表达式的作用 \\ 元字符 \\ 转义 \\ 量词 \\ 分组 \\ 零宽断言 \\贪婪匹配与惰性匹配懒惰 \\ 使用re模块实现正则表达式操作（匹配、搜索、替换、捕获）\n- 使用正则表达式 - re模块 \\ compile函数 \\ group和groups方法 \\ match方法 \\ search方法 \\ findall和finditer方法 \\ sub和subn方法 \\ split方法\n- 应用案例 - 使用正则表达式验证输入的字符串\n\n#### Day13 - [进程和线程](./Day01-15/Day13/进程和线程入门.md)\n\n- 进程和线程的概念 - 什么是进程 / 什么是线程 / 多线程的应用场景\n- 使用进程 - fork函数 / multiprocessing模块 / 进程池 / 进程间通信\n- 使用线程 - thread模块 / threading模块 / Thread类 / Lock类\n\n#### Day14 - [网络编程入门](./Day01-15/Day14/网络编程入门.md)\n\n- 计算机网络基础 - 计算机网络发展史 / “TCP-IP”模型 / IP地址 / 端口 / 协议 / 其他相关概念\n- 网络应用架构 - “客户端-服务器”架构 / “浏览器-服务器”架构\n- Python网络编程 - 套接字的概念 / socket模块 /  socket函数 / 创建TCP服务器 / 创建TCP客户端 / 创建UDP服务器 / 创建UDP客户端 / SocketServer模块\n\n#### Day15 - [网络应用开发](./Day01-15/Day15/网络应用开发.md)\n\n- 访问网络API - 网络API概述 / 访问URL / requests模块 / 解析JSON格式数据\n- 文件传输 - FTP协议 / ftplib模块 / 交互式FTP应用\n- 电子邮件 - SMTP协议 / POP3协议 / IMAP协议 / smtplib模块 / poplib模块 / imaplib模块\n- 短信服务 - twilio模块 / 国内的短信服务\n\n### Day16~Day20 - [Python语言进阶 ](./Day16-20)\n\n\n\n### Day21~30 - [Web前端](./Day21-30)\n\n- 用HTML标签承载页面内容\n- 用CSS渲染页面\n- 用JavaScript处理交互式行为\n- jQuery入门和提高\n- Bootstrap在Web项目中的应用\n\n### Day31~35 - [Linux操作系统](./Day31-35)\n\n- 操作系统发展史和Linux概述\n- Linux基础命令\n- Linux中的实用程序\n- Linux的文件系统\n- Vim编辑器的应用\n- 环境变量和Shell编程\n- 软件的安装和服务的配置\n- 网络访问和管理\n- 其他相关内容\n\n### Day36~40 - [数据库基础和进阶](./Day36-40)\n\n- [关系型数据库MySQL](./Day36-40/关系型数据库MySQL.md)\n  - 关系型数据库概述\n  - MySQL的安装和使用\n  - SQL的使用\n    - DDL\n    - DML\n    - DQL\n    - DCL\n  - 在Python中操作MySQL\n  - MySQL高级知识\n- [NoSQL入门](./Day36-40/NoSQL入门.md)\n  - NoSQL概述\n  - 主流NoSQL数据库\n  - Redis概述\n  - Mongo概述\n\n### Day41~55 - [Django](./Day41-55)\n\n#### Day41 - [Django2实战(01) - 快速上手](./Day41-55/Django2实战01.md)\n\n#### Day42 - [Django2实战(02) - 深入模型](./Day41-55/Django2实战02.md)\n\n#### Day43 - [Django2实战(03) - 视图和模板](./Day41-55/Django2实战03.md)\n\n#### Day44 - [Django2实战(04) - 表单的应用](./Day41-55/Django2实战04.md)\n\n#### Day45 - [Django2实战(05) - Cookie和会话](./Day41-55/Django2实战05.md)\n\n#### Day46 - [Django2实战(06) - 日志和缓存](./Day41-55/Django2实战06.md)\n\n#### Day47 - [Django2实战(07) - 文件上传和通用视图](./Day41-55/Django2实战07.md)\n\n#### Day48 - [Django2实战(08) - 用户/角色/权限和中间件](./Day41-55/Django2实战08.md)\n\n#### Day49 - [Django2实战(09) - RESTful架构和应用(上)](./Day41-55/Django2实战09.md)\n\n#### Day50 - [Django2实战(10) - RESTful架构和应用(下)](./Day41-55/Django2实战10.md)\n\n#### Day51-55 - [Django2项目实战](./Day41-55/Django2项目实战.md)\n\n- 项目开发流程和相关工具\n- 生成非HTML内容\n- 项目部署和测试\n- 项目性能调优\n- Web应用安全保护\n\n\n### Day56~65 - [Flask](./Day56-65)\n\n#### Day56 - [Flask安装和入门](./Day56-65/Flash安装和入门.md) \n\n#### Day57 - [模板的使用](./Day56-65/模板的使用.md) \n\n#### Day58 - [表单的处理](./Day56-65/表单的处理.md) \n\n#### Day59 - [数据库操作](./Day56-65/数据库操作.md)\n\n#### Day60 - [使用Flask进行项目开发](./Day56-65/使用Flask进行项目开发.md)  \n\n#### Day61-65 - [Flask项目实战](./Day56-65/Flask项目实战.md)\n\n- 性能和测试\n- 项目部署\n\n### Day66~75 - [爬虫](./Day66-75)\n\n#### Day66 - [网络爬虫和相关工具](./Day66-75/01.网络爬虫和相关工具.md)\n\n#### Day67 - [数据采集和解析](./Day66-75/02.数据采集和解析.md)\n\n#### Day68 - [存储数据](./Day66-75/03.存储数据.md)\n\n#### Day69 - [并发下载](./Day66-75/04.并发下载.md)\n\n#### Day70 - [解析动态内容](./Day66-75/05.解析动态内容.md)\n\n#### Day71 - [表单交互和验证码处理](./Day66-75/06.表单交互和验证码处理.md)\n\n#### Day72 - [Scrapy爬虫框架入门](./Day66-75/Scrapy爬虫框架入门.md)\n\n#### Day73 - [Scrapy爬虫框架高级应用](./Day66-75/Scrapy爬虫框架高级应用.md)\n\n#### Day74 - [Scrapy爬虫框架分布式实现](./Day66-75/Scrapy爬虫框架分布式实现.md)\n\n### Day76~90 - [数据处理和机器学习](./Day76-90)\n\n#### Pandas的应用\n\n#### NumPy和SciPy的应用\n\n#### Matplotlib和数据可视化\n\n#### K最邻近分类算法(KNN)\n\n#### 线性回归和Logistic回归\n\n#### 支持向量机(SVM)和Kmeans聚类\n\n#### 决策树和贝叶斯分类\n\n#### Tensorflow实战01\n\n#### Tensorflow实战02\n\n#### Tensorflow实战03\n\n### Day91~100 - [团队项目开发](./Day91-100)\n\n#### 软件项目的过程模型\n\n#### 团队开发工具\n\n#### 模块分割设计与单元测试\n\n#### 用Jenkins实现持续集成\n\n#### 部署和自动化部署\n\n#### 性能测试和改善\n\n\n\n"
        },
        {
          "name": "res",
          "type": "tree",
          "content": null
        },
        {
          "name": "玩转PyCharm(上).md",
          "type": "blob",
          "size": 3.7392578125,
          "content": "## 玩转PyCharm(上)\n\nPyCharm是由JetBrains公司开发的提供给Python专业的开发者的一个集成开发环境，它最大的优点是能够大大提升Python开发者的工作效率，为开发者集成了很多用起来非常顺手的功能，包括代码调试、高亮语法、代码跳转、智能提示、自动补全、单元测试、版本控制等等。此外，PyCharm还提供了对一些高级功能的支持，包括支持基于Django框架的Web开发、。\n\n### PyCharm的安装\n\n可以在[JetBrains公司的官方网站]()找到PyCharm的[下载链接](https://www.jetbrains.com/pycharm/download/)，有两个可供下载的版本一个是社区版一个是专业版，社区版在[Apache许可证](https://zh.wikipedia.org/wiki/Apache%E8%AE%B8%E5%8F%AF%E8%AF%81)下发布，专业版在专用许可证下发布（需要购买授权下载后可试用30天），其拥有许多额外功能。安装PyCharm需要有JRE（Java运行时环境）的支持，如果没有可以在安装过程中选择在线下载安装。\n\n> 说明：如果你是一名学生，希望购买PyCharm来使用，可以看看[教育优惠官方申请指南](https://sales.jetbrains.com/hc/zh-cn/articles/207154369)。\n\n### 首次使用的设置\n\n第一次使用PyCharm时，会有一个导入设置的向导，如果之前没有使用PyCharm或者没有保存过设置的就直接选择“Do not import settings”进入下一步即可。\n\n![](./res/pycharm-import-settings.png)\n\n专业版的PyCharm是需要激活的，**强烈建议为优秀的软件支付费用**，如果不用做商业用途，我们可以暂时选择试用30天或者使用社区版的PyCharm。\n\n![](./res/pycharm-activate.png)\n\n 接下来是选择UI主题，这个可以根据个人喜好进行选择。\n\n![](./res/pycharm-set-ui-theme.png)\n\n 再接下来是创建可以在终端（命令行）中使用PyCharm项目的启动脚本，当然也可以直接跳过这一步。\n\n![](./res/pycharm-create-launcher-script.png)\n\n然后可以选择需要安装哪些插件，我们可以暂时什么都不安装等需要的时候再来决定。\n\n![](./res/pycharm-plugins.png)\n\n### 用PyCharm创建项目\n\n点击上图中的“Start using PyCharm”按钮就可以开始使用PyCharm啦，首先来到的是一个欢迎页，在欢迎页上我们可以选择“创建新项目”、“打开已有项目”和“从版本控制系统中检出项目”。\n\n![](./res/pycharm-welcome.png)\n\n如果选择了“Create New Project”来创建新项目就会打一个创建项目的向导页。\n\n![](./res/pycharm-new-project.png)\n\n在如上图所示的界面中，我们可以选择创建项目的模板，包括了纯Python项目、基于各种不同框架的Web项目、Web前端项目、跨平台项目等各种不同的项目模板。如果选择Python的项目，那么有一个非常重要的设定是选择“New environment…”（创建新的虚拟环境）还是使用“Existing Interpreter”（已经存在的解释器）。前者肯定是更好的选择，因为新的虚拟环境不会对系统环境变量中配置的Python环境造成影响，简单举个例子就是你在虚拟环境下安装或者更新了任何三方库，它并不会对系统原有的Python解释器造成任何的影响，但代价是需要额外的存储空间来建立这个虚拟环境。\n\n项目创建完成后就可以开始新建各种文件来书写Python代码了。\n\n![](./res/pycharm-workspace.png)\n\n在工作窗口的右键菜单中可以找到“Run ...”和“Debug ...”菜单项，通过这两个菜单项我们就可以运行和调试我们的代码啦。建议关注一下菜单栏中的“Code”、“Refactor”和“Tools”菜单，这里面为编写Python代码提供了很多有用的帮助，我们在后面也会陆续为大家介绍这些功能。"
        },
        {
          "name": "用函数还是用复杂的表达式.md",
          "type": "blob",
          "size": 4.7265625,
          "content": "## 要不要使用复杂表达式\n\nPerl语言的原作者Larry Wall曾经说过，伟大的程序员都有三个优点：懒惰、暴躁和自负。乍一看这三个词语没有一个是褒义词，但在程序员的世界里，这三个词有不同的意义。首先，懒惰会促使程序员去写一些省事儿的程序来辅助自己或别人更好的完成工作，这样我们就无需做那些重复和繁琐的劳动；同理能够用3行代码解决的事情，我们也绝不会写出10行代码来。其次，暴躁会让程序员主动的去完成一些你还没有提出的工作，去优化自己的代码让它更有效率，能够3秒钟完成的任务，我们绝不能容忍1分钟的等待。最后，自负会促使程序员写出可靠无误的代码，我们写代码不是为了接受批评和指责，而是为了让其他人来膜拜。\n\n那么接下来就有一个很有意思的问题值得探讨一下，我们需要一个程序从输入的三个数中找出最大的那个数。这个程序对任何会编程的人来说都是小菜一碟，甚至不会编程的人经过10分钟的学习也能搞定。下面是用来解决这个问题的Python代码。\n\n```Python\na = int(input('a = '))\nb = int(input('b = '))\nc = int(input('c = '))\nif a > b:\n\tthe_max = a\nelse:\n\tthe_max = b\nif c > the_max:\n\tthe_max = c\nprint('The max is:', the_max)\n\n```\n\n但是我们刚才说了，程序员都是懒惰的，很多程序员都会使用三元条件运算符来改写上面的代码。\n\n```Python\na = int(input('a = '))\nb = int(input('b = '))\nc = int(input('c = '))\nthe_max = a if a > b else b\nthe_max = c if c > the_max else the_max\nprint('The max is:', the_max)\n\n```\n\n需要说明的是，Python在2.5版本以前是没有上面代码第4行和第5行中使用的三元条件运算符的，究其原因是Guido van Rossum（Python之父）认为三元条件运算符并不能帮助 Python变得更加简洁，于是那些习惯了在C/C++或Java中使用三元条件运算符（在这些语言中，三元条件运算符也称为“Elvis运算符”，因为`?:`放在一起很像著名摇滚歌手猫王Elvis的大背头）的程序员试着用`and`和`or`运算符的短路特性来模拟出三元操作符，于是在那个年代，上面的代码是这样写的。\n\n```Python\na = int(input('a = '))\nb = int(input('b = '))\nc = int(input('c = '))\nthe_max = a > b and a or b\nthe_max = c > the_max and c or the_max\nprint('The max is:', the_max)\n\n```\n\n但是这种做法在某些场景下是不能成立的，且看下面的代码。\n\n```Python\na = 0\nb = -100\n# 下面的代码本来预期输出a的值，结果却得到了b的值\n# 因为a的值0在进行逻辑运算时会被视为False来处理\nprint(True and a or b)\n# print(a if True else b)\n```\n\n所以在Python 2.5以后引入了三元条件运算符来避免上面的风险（上面代码被注释掉的最后一句话）。那么，问题又来了，上面的代码还可以写得更简短吗？答案是肯定的。\n\n```Python\na = int(input('a = '))\nb = int(input('b = '))\nc = int(input('c = '))\nprint('The max is:', (a if a > b else b) if (a if a > b else b) > c else c)\n\n```\n\n但是，这样做真的好吗？如此复杂的表达式是不是让代码变得晦涩了很多呢？我们发现，在实际开发中很多开发者都喜欢过度的使用某种语言的特性或语法糖，于是简单的多行代码变成了复杂的单行表达式，这样做真的好吗？这个问题我也不止一次的问过自己，现在我能给出的答案是下面的代码，使用辅助函数。\n\n```Python\ndef the_max(x, y):\n\treturn x if x > y else y\n\n\na = int(input('a = '))\nb = int(input('b = '))\nc = int(input('c = '))\nprint('The max is:', the_max(the_max(a, b), c))\n\n```\n\n上面的代码中，我定义了一个辅助函数`the_max`用来找出参数传入的两个值中较大的那一个，于是下面的输出语句可以通过两次调用`the_max`函数来找出三个数中的最大值，现在代码的可读性是不是好了很多。用辅助函数来替代复杂的表达式真的是一个不错的选择，关键是比较大小的逻辑转移到这个辅助函数后不仅可以反复调用它，而且还可以进行级联操作。\n\n当然，很多语言中比较大小的函数根本没有必要自己来实现（通常都是内置函数），Python也是如此。Python内置的max函数利用了Python对可变参数的支持，允许一次性传入多个值或者一个迭代器并找出那个最大值，所以上面讨论的问题在Python中也就是一句话的事，但是从复杂表达式到使用辅助函数简化复杂表达式这个思想是非常值得玩味的，所以分享出来跟大家做一个交流。\n\n```Python\na = int(input('a = '))\nb = int(input('b = '))\nc = int(input('c = '))\nprint('The max is:', max(a, b, c))\n\n```\n\n"
        },
        {
          "name": "那些年我们踩过的那些坑.md",
          "type": "blob",
          "size": 11.0830078125,
          "content": "## 那些年我们踩过的那些坑\n\n### 坑01 - 整数比较的坑\n\n在 Python 中一切都是对象，整数也是对象，在比较两个整数时有两个运算符`==`和`is`，它们的区别是：\n\n- `is`比较的是两个整数对象的id值是否相等，也就是比较两个引用是否代表了内存中同一个地址。\n- `==`比较的是两个整数对象的内容是否相等，使用`==`时其实是调用了对象的`__eq__()`方法。\n\n知道了`is`和`==`的区别之后，我们可以来看看下面的代码，了解Python中整数比较有哪些坑：\n\n```Python\ndef main():\n\tx = y = -1\n\twhile True:\n\t\tx += 1\n\t\ty += 1\n\t\tif x is y:\n\t\t\tprint('%d is %d' % (x, y))\n\t\telse:\n\t\t\tprint('Attention! %d is not %d' % (x, y))\n\t\t\tbreak\n\t\t\t\n\tx = y = 0\n\twhile True:\n\t\tx -= 1\n\t\ty -= 1\n\t\tif x is y:\n\t\t\tprint('%d is %d' % (x, y))\n\t\telse:\n\t\t\tprint('Attention! %d is not %d' % (x, y))\n\t\t\tbreak\n\n\nif __name__ == '__main__':\n\tmain()\n\n```\n\n上面代码的部分运行结果如下图所示，出现这个结果的原因是Python出于对性能的考虑所做的一项优化。对于整数对象，Python把一些频繁使用的整数对象缓存起来，保存到一个叫`small_ints`的链表中，在Python的整个生命周期内，任何需要引用这些整数对象的地方，都不再重新创建新的对象，而是直接引用缓存中的对象。Python把频繁使用的整数对象的值定在[-5, 256]这个区间，如果需要这个范围的整数，就直接从`small_ints`中获取引用而不是临时创建新的对象。因为大于256或小于-5的整数不在该范围之内，所以就算两个整数的值是一样，但它们是不同的对象。\n\n![](./res/int-is-comparation.png)\n\n当然仅仅如此这个坑就不值一提了，如果你理解了上面的规则，我们就再看看下面的代码。\n\n```Python\nimport dis\na = 257\n\n\ndef main():\n\tb = 257  # 第6行\n\tc = 257  # 第7行\n\tprint(b is c)  # True\n\tprint(a is b)  # False\n\tprint(a is c)  # False\n\n\nif __name__ == \"__main__\":\n\tmain()\n\n```\n\n程序的执行结果已经用注释写在代码上了。够坑吧！看上去`a`、`b`和`c`的值都是一样的，但是`is`运算的结果却不一样。为什么会出现这样的结果，首先我们来说说Python程序中的代码块。所谓代码块是程序的一个最小的基本执行单位，一个模块文件、一个函数体、一个类、交互式命令中的单行代码都叫做一个代码块。上面的代码由两个代码块构成，`a = 257`是一个代码块，`main`函数是另外一个代码块。Python内部为了进一步提高性能，凡是在一个代码块中创建的整数对象，如果值不在`small_ints`缓存范围之内，但在同一个代码块中已经存在一个值与其相同的整数对象了，那么就直接引用该对象，否则创建一个新的对象出来，这条规则对不在`small_ints`范围的负数并不适用，对负数值浮点数也不适用，但对非负浮点数和字符串都是适用的，这一点读者可以自行证明。所以 `b is c`返回了`True`，而`a`和`b`不在同一个代码块中，虽然值都是257，但却是两个不同的对象，`is`运算的结果自然是`False`了。\n为了验证刚刚的结论，我们可以借用`dis`模块（听名字就知道是进行反汇编的模块）从字节码的角度来看看这段代码。如果不理解什么是字节码，可以先看看[《谈谈 Python 程序的运行原理》]((http://www.cnblogs.com/restran/p/4903056.html))这篇文章。可以先用`import dis`导入`dis`模块并按照如下所示的方式修改代码。\n\n```Python\nif __name__ == \"__main__\":\n\tmain()\n\tdis.dis(main)\n\n```\n\n代码的执行结果如下图所示。可以看出代码第6行和第7行，也就是`main`函数中的257是从同一个位置加载的，因此是同一个对象；而代码第9行的`a`明显是从不同的地方加载的，因此引用的是不同的对象。\n\n![](./res/result-of-dis.png)\n\n如果还想对这个问题进行进一步深挖，推荐大家阅读[《Python整数对象实现原理》](https://foofish.net/python_int_implement.html)这篇文章。\n\n### 坑02 - 嵌套列表的坑\n\nPython中有一种内置的数据类型叫列表，它是一种容器，可以用来承载其他的对象（准确的说是其他对象的引用），列表中的对象可以称为列表的元素，很明显我们可以把列表作为列表中的元素，这就是所谓的嵌套列表。嵌套列表可以模拟出现实中的表格、矩阵、2D游戏的地图（如植物大战僵尸的花园）、棋盘（如国际象棋、黑白棋）等。但是在使用嵌套的列表时要小心，否则很可能遭遇非常尴尬的情况，下面是一个小例子。\n\n```Python\ndef main():\n\tnames = ['关羽', '张飞', '赵云', '马超', '黄忠']\n\tsubjs = ['语文', '数学', '英语']\n\tscores = [[0] * 3] * 5\n\tfor row, name in enumerate(names):\n\t\tprint('请输入%s的成绩' % name)\n\t\tfor col, subj in enumerate(subjs):\n\t\t\tscores[row][col] = float(input(subj + ': '))\n\tprint(scores)\n\n\nif __name__ == '__main__':\n\tmain()\n\n```\n\n我们希望录入5个学生3门课程的成绩，于是定义了一个有5个元素的列表，而列表中的每个元素又是一个由3个元素构成的列表，这样一个列表的列表刚好跟一个表格是一致的，相当于有5行3列，接下来我们通过嵌套的for-in循环输入每个学生3门课程的成绩。程序执行完成后我们发现，每个学生3门课程的成绩是一模一样的，而且就是最后录入的那个学生的成绩。\n\n要想把这个坑填平，我们首先要区分对象和对象的引用这两个概念，而要区分这两个概念，还得先说说内存中的栈和堆。我们经常会听人说起“堆栈”这个词，但实际上“堆”和“栈”是两个不同的概念。众所周知，一个程序运行时需要占用一些内存空间来存储数据和代码，那么这些内存从逻辑上又可以做进一步的划分。对底层语言（如C语言）有所了解的程序大都知道，程序中可以使用的内存从逻辑上可以为五个部分，按照地址从高到低依次是：栈（stack）、堆（heap）、数据段（data segment）、只读数据段（static area）和代码段（code segment）。其中，栈用来存储局部、临时变量，以及函数调用时保存现场和恢复现场需要用到的数据，这部分内存在代码块开始执行时自动分配，代码块执行结束时自动释放，通常由编译器自动管理；堆的大小不固定，可以动态的分配和回收，因此如果程序中有大量的数据需要处理，这些数据通常都放在堆上，如果堆空间没有正确的被释放会引发内存泄露的问题，而像Python、Java等编程语言都使用了垃圾回收机制来实现自动化的内存管理（自动回收不再使用的堆空间）。所以下面的代码中，变量`a`并不是真正的对象，它是对象的引用，相当于记录了对象在堆空间的地址，通过这个地址我们可以访问到对应的对象；同理，变量`b`是列表容器的引用，它引用了堆空间上的列表容器，而列表容器中并没有保存真正的对象，它保存的也仅仅是对象的引用。\n\n ```Python\na = object()\nb = ['apple', 'pitaya', 'grape']\n ```\n\n知道了这一点，我们可以回过头看看刚才的程序，我们对列表进行`[[0] * 3] * 5`操作时，仅仅是将`[0, 0, 0]`这个列表的地址进行了复制，并没有创建新的列表对象，所以容器中虽然有5个元素，但是这5个元素引用了同一个列表对象，这一点可以通过`id`函数检查`scores[0]`和`scores[1]`的地址得到证实。所以正确的代码应该按照如下的方式进行修改。\n\n```Python\ndef main():\n\tnames = ['关羽', '张飞', '赵云', '马超', '黄忠']\n\tsubjs = ['语文', '数学', '英语']\n\tscores = [[]] * 5\n\tfor row, name in enumerate(names):\n\t\tprint('请输入%s的成绩' % name)\n\t\tscores[row] = [0] * 3\n\t\tfor col, subj in enumerate(subjs):\n\t\t\tscores[row][col] = float(input(subj + ': '))\n\tprint(scores)\n\n\nif __name__ == '__main__':\n\tmain()\n\n```\n\n或者\n\n```Python\ndef main():\n\tnames = ['关羽', '张飞', '赵云', '马超', '黄忠']\n\tsubjs = ['语文', '数学', '英语']\n\tscores = [[0] * 3 for _ in range(5)]\n\tfor row, name in enumerate(names):\n\t\tprint('请输入%s的成绩' % name)\n\t\tscores[row] = [0] * 3\n\t\tfor col, subj in enumerate(subjs):\n\t\t\tscores[row][col] = float(input(subj + ': '))\n\tprint(scores)\n\n\nif __name__ == '__main__':\n\tmain()\n\n```\n\n如果对内存的使用不是很理解，可以看看[PythonTutor网站](http://www.pythontutor.com/)上提供的代码可视化执行功能，通过可视化执行，我们可以看到内存是如何分配的，从而避免在使用嵌套列表或者复制对象时可能遇到的坑。\n\n![](./res/python-tutor-visualize.png)\n\n![](./res/python-tutor-visualize2.png)\n\n### 坑03 - 访问修饰符的坑\n\n用Python做过面向对象编程的人都知道，Python的类提供了两种访问控制权限，一种是公开，一种是私有（在属性或方法前加上双下划线）。而用惯了Java或C#这类编程语言的人都知道，类中的属性（数据抽象）通常都是私有的，其目的是为了将数据保护起来；而类中的方法（行为抽象）通常都是公开的，因为方法是对象向外界提供的服务。但是Python并没有从语法层面确保私有成员的私密性，因为它只是对类中所谓的私有成员进行了命名的变换，如果知道命名的规则照样可以直接访问私有成员，请看下面的代码。\n\n```Python\nclass Student(object):\n\n    def __init__(self, name, age):\n        self.__name = name\n        self.__age = age\n\n    def __str__(self):\n        return self.__name + ': ' + str(self.__age)\n\n\ndef main():\n    stu = Student('骆昊', 38)\n    # 'Student' object has no attribute '__name'\n    # print(stu.__name)\n    # 用下面的方式照样可以访问类中的私有成员\n    print(stu._Student__name)\n    print(stu._Student__age)\n\n\nif __name__ == '__main__':\n    main()\n\n```\n\nPython为什么要做出这样的设定呢？用一句广为流传的格言来解释这个问题：“We are all consenting adults here”（我们都是成年人）。这句话表达了很多Python程序员的一个共同观点，那就是开放比封闭要好，我们应该自己对自己的行为负责而不是从语言层面来限制对数据或方法的访问。\n\n所以在Python中我们实在没有必要将类中的属性或方法用双下划线开头的命名处理成私有的成员，因为这并没有任何实际的意义。如果想对属性或方法进行保护，我们建议用单下划线开头的受保护成员，虽然它也不能真正保护这些属性或方法，但是它相当于给调用者一个暗示，让调用者知道这是不应该直接访问的属性或方法，而且这样做并不影响子类去继承这些东西。\n\n需要提醒大家注意的是，Python类中的那些魔法方法，如\\_\\_str\\_\\_、\\_\\_repr\\_\\_等，这些方法并不是私有成员哦，虽然它们以双下划线开头，但是他们也是以双下划线结尾的，这种命名并不是私有成员的命名，这一点对初学者来说真的很坑。\n\n（未完待续） "
        }
      ]
    }
  ]
}