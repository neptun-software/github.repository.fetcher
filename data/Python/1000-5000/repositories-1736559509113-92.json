{
  "metadata": {
    "timestamp": 1736559509113,
    "page": 92,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjEwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "blackboxo/CleanMyWechat",
      "stars": 4767,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0361328125,
          "content": "config.json\nbuild/\ndist/\n*.spec\n*.zip"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.041015625,
          "content": "MIT License\n\nCopyright (c) 2022 blackboxo\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "images",
          "type": "tree",
          "content": null
        },
        {
          "name": "main.py",
          "type": "blob",
          "size": 17.9775390625,
          "content": "import sys\n\nfrom PyQt5.QtWidgets import QApplication, QMainWindow, QGraphicsDropShadowEffect, QListWidgetItem, QListView, QWidget, \\\n    QLabel, QHBoxLayout, QFileDialog\nfrom PyQt5.QtCore import Qt, QPropertyAnimation, QEasingCurve, QThread, pyqtSignal, QMutex, QSize, QEvent, QPoint, QTimer\nfrom PyQt5.QtGui import QMouseEvent, QCursor, QColor\nfrom PyQt5.uic import loadUi\n\nfrom pathlib import Path, PureWindowsPath\nfrom dateutil import relativedelta\nimport utils.resources\nimport os, datetime, time, re, math, shutil, json\n\nfrom utils.deleteThread import *\nfrom utils.multiDeleteThread import multiDeleteThread\nfrom utils.selectVersion import *\nfrom utils.selectVersion import check_dir, existing_user_config\n# 设置应用程序在高DPI屏幕上启用高DPI缩放。Set the application to enable high DPI scaling on high DPI screens\n# 注意事项：此行代码必须在QApplication实例化之前调用，否则会调用失败。Notes: This line of code must be called before the instantiation of the QApplication object; otherwise, it will fail\nQApplication.setAttribute(Qt.AA_EnableHighDpiScaling)\n\n# determine if application is a script file or frozen exe\nif getattr(sys, 'frozen', False):\n    working_dir = os.path.dirname(os.path.realpath(sys.executable))\nelif __file__:\n    working_dir = os.path.split(os.path.realpath(__file__))[0]\n\n# 主窗口\nclass Window(QMainWindow):\n    def mousePressEvent(self, event):\n        # 重写一堆方法使其支持拖动\n        if event.button() == Qt.LeftButton:\n            self.m_drag = True\n            self.m_DragPosition = event.globalPos() - self.pos()\n            event.accept()\n            # self.setCursor(QCursor(Qt.OpenHandCursor))\n\n    def mouseMoveEvent(self, QMouseEvent):\n        try:\n            if Qt.LeftButton and self.m_drag:\n                self.move(QMouseEvent.globalPos() - self.m_DragPosition)\n                QMouseEvent.accept()\n        except:\n            pass\n\n    def mouseReleaseEvent(self, QMouseEvent):\n        self.m_drag = False\n        # self.setCursor(QCursor(Qt.ArrowCursor))\n\n    def _frame(self):\n        # 边框\n        self.setWindowFlags(Qt.FramelessWindowHint)\n        self.setAttribute(Qt.WA_TranslucentBackground, True)\n        # 阴影\n        effect = QGraphicsDropShadowEffect(blurRadius=12, xOffset=0, yOffset=0)\n        effect.setColor(QColor(25, 25, 25, 170))\n        self.mainFrame.setGraphicsEffect(effect)\n\n    def doFadeIn(self):\n        # 动画\n        self.animation = QPropertyAnimation(self, b'windowOpacity')\n        # 持续时间250ms\n        self.animation.setDuration(250)\n        try:\n            # 尝试先取消动画完成后关闭窗口的信号\n            self.animation.finished.disconnect(self.close)\n        except:\n            pass\n        self.animation.stop()\n        # 透明度范围从0逐渐增加到1\n        self.animation.setEasingCurve(QEasingCurve.InOutCubic)\n        self.animation.setStartValue(0)\n        self.animation.setEndValue(1)\n        self.animation.start()\n\n    def doFadeOut(self):\n        self.animation.stop()\n        # 动画完成则关闭窗口\n        self.animation.finished.connect(self.close)\n        # 透明度范围从1逐渐减少到0s\n        self.animation.setEasingCurve(QEasingCurve.InOutCubic)\n        self.animation.setStartValue(1)\n        self.animation.setEndValue(0)\n        self.animation.start()\n\n    def setWarninginfo(self, text):\n        self.lab_info.setStyleSheet(\"\"\"\n            .QLabel {\n                border:1px solid #ffccc7;\n                border-radius:3px;\n                line-height: 140px;\n                padding: 5px;\n                color: #434343;\n                background: #fff2f0;\n            }\n            \"\"\")\n        self.lab_info.setWordWrap(True)  # 启用自动换行\n        self.lab_info.setText(text)\n\n    def setSuccessinfo(self, text):\n        self.lab_info.setStyleSheet(\"\"\"\n            .QLabel {\n                border:1px solid #b7eb8f;\n                border-radius:3px;\n                line-height: 140px;\n                padding: 5px;\n                color: #434343;\n                background: #f6ffed;\n            }\n            \"\"\")\n        self.lab_info.setWordWrap(True)  # 启用自动换行\n        self.lab_info.setText(text)\n\n\nclass ConfigWindow(Window):\n    Signal_OneParameter = pyqtSignal(int)\n\n    config = {}\n\n    def _connect(self):\n        self.combo_user.currentIndexChanged.connect(self.refresh_ui)\n        self.btn_close.clicked.connect(self.save_config)\n        self.btn_file.clicked.connect(self.open_file)\n\n    def open_file(self):\n        openfile_path = QFileDialog.getExistingDirectory(self, '选择微信数据目录', '')\n        if not openfile_path or openfile_path == '':\n            return False\n        if check_dir(openfile_path) == 0:\n            self.setSuccessinfo('读取路径成功！')\n            list_ = os.listdir(openfile_path)\n            user_list = [\n                elem for elem in list_\n                if elem != 'All Users' and elem != 'Applet' and elem != 'WMPF'\n            ]\n            # 如果已有用户配置，那么写入新的用户配置，否则默认写入新配置\n            dir_list = []\n            user_config = []\n            existing_user_config_dic = existing_user_config()\n            for user_wx_id in user_list:\n                dir_list.append(os.path.join(openfile_path, user_wx_id))\n                if user_wx_id in existing_user_config_dic:\n                    user_config.append(existing_user_config_dic[user_wx_id])\n                else:\n                    user_config.append({\n                        \"wechat_id\": user_wx_id,\n                        \"clean_days\": \"365\",\n                        \"is_clean\": True,\n                        \"clean_pic_cache\": True,\n                        \"clean_file\": False,\n                        \"clean_pic\": True,\n                        \"clean_video\": True,\n                        \"is_timer\": True,\n                        \"timer\": \"0h\"\n                    })\n\n            config = {\"data_dir\": dir_list, \"users\": user_config}\n\n            with open(\n                    working_dir + \"/config.json\", \"w\", encoding=\"utf-8\") as f:\n                json.dump(config, f)\n            self.load_config()\n        else:\n            self.setWarninginfo('请选择正确的文件夹！\\n一般是WeChat Files文件夹。')\n\n    def save_config(self):\n        self.update_config()\n        self.doFadeOut()\n\n    def check_wechat_exists(self):\n        self.selectVersion = selectVersion()\n        self.scan = self.selectVersion.getAllPath()\n        self.version_scan = self.scan[0]\n        self.users_scan = self.scan[1]\n        if len(self.version_scan) == 0:\n            return False\n        else:\n            return True\n\n    def load_config(self):\n        fd = open(working_dir + \"/config.json\", encoding=\"utf-8\")\n        self.config = json.load(fd)\n\n        self.combo_user.clear()\n        for value in self.config[\"users\"]:\n            self.combo_user.addItem(value[\"wechat_id\"])\n\n        self.line_gobackdays.setText(\n            str(self.config[\"users\"][0][\"clean_days\"]))\n        self.check_is_clean.setChecked(self.config[\"users\"][0][\"is_clean\"])\n        self.check_picdown.setChecked(self.config[\"users\"][0][\"clean_pic\"])\n        self.check_files.setChecked(self.config[\"users\"][0][\"clean_file\"])\n        self.check_video.setChecked(self.config[\"users\"][0][\"clean_video\"])\n        self.check_picscache.setChecked(\n            self.config[\"users\"][0][\"clean_pic_cache\"])\n        self.setSuccessinfo(\"请确认每个账号的删除内容及时间，以防误删！\")\n\n    def refresh_ui(self):\n        self.config = open(working_dir + \"/config.json\", encoding=\"utf-8\")\n        self.config = json.load(self.config)\n\n        for value in self.config[\"users\"]:\n            if value[\"wechat_id\"] == self.combo_user.currentText():\n                self.line_gobackdays.setText(str(value[\"clean_days\"]))\n                self.check_is_clean.setChecked(value[\"is_clean\"])\n                self.check_picdown.setChecked(value[\"clean_pic\"])\n                self.check_files.setChecked(value[\"clean_file\"])\n                self.check_video.setChecked(value[\"clean_video\"])\n                self.check_picscache.setChecked(value[\"clean_pic_cache\"])\n\n    def create_config(self):\n        if not os.path.exists(working_dir + \"/config.json\"):\n            if not self.check_wechat_exists():\n                self.setWarninginfo(\"默认位置没有微信，请自定义位置\")\n                return\n\n            self.config = {\"data_dir\": self.version_scan, \"users\": []}\n            for value in self.users_scan:\n                self.config[\"users\"].append({\n                    \"wechat_id\": value,\n                    \"clean_days\": 365,\n                    \"is_clean\": True,\n                    \"clean_pic_cache\": True,\n                    \"clean_file\": False,\n                    \"clean_pic\": True,\n                    \"clean_video\": True,\n                    \"is_timer\": True,\n                    \"timer\": \"0h\"\n                })\n            with open(\n                    working_dir + \"/config.json\", \"w\", encoding=\"utf-8\") as f:\n                json.dump(self.config, f)\n            self.load_config()\n            self.setSuccessinfo(\"请确认每个账号的删除内容及时间，以防误删！\")\n        else:\n            self.setSuccessinfo(\"请确认每个账号的删除内容及时间，以防误删！\")\n            self.load_config()\n\n    def update_config(self):\n        if not len(self.config):\n            return\n        else:\n            for value in self.config[\"users\"]:\n                if value[\"wechat_id\"] == self.combo_user.currentText():\n                    try:\n                        days = int(self.line_gobackdays.text())\n                        if days < 0:\n                            value[\"clean_days\"] = \"0\"\n                        else:\n                            value[\"clean_days\"] = self.line_gobackdays.text()\n                    except ValueError:\n                        value[\"clean_days\"] = \"0\"\n                    value[\"is_clean\"] = self.check_is_clean.isChecked()\n                    value[\"clean_pic\"] = self.check_picdown.isChecked()\n                    value[\"clean_file\"] = self.check_files.isChecked()\n                    value[\"clean_video\"] = self.check_video.isChecked()\n                    value[\"clean_pic_cache\"] = self.check_picscache.isChecked()\n\n            with open(working_dir + \"/config.json\", \"w\", encoding=\"utf-8\") as f:\n                json.dump(self.config, f)\n            self.setSuccessinfo(\"更新配置文件成功\")\n            self.Signal_OneParameter.emit(1)\n\n    def __init__(self):\n        super().__init__()\n        loadUi(working_dir + \"/images/config.ui\", self)\n\n        self._frame()\n        self._connect()\n\n        self.doFadeIn()\n        self.create_config()\n\n        self.show()\n\n\nclass MainWindow(Window):\n\n    def deal_emit_slot(self, set_status):\n        if set_status and not self.config_exists:\n            self.setSuccessinfo(\"已经准备好，可以开始了！\")\n            self.config_exists = True\n\n    def closeEvent(self, event):\n        sys.exit(0)\n\n    def eventFilter(self, object, event):\n        if event.type() == QEvent.MouseButtonPress:\n            if object == self.lab_close:\n                self.doFadeOut()\n                return True\n            elif object == self.lab_clean:\n                try:\n                    self.setSuccessinfo(\"正在清理中...\")\n                    self.justdoit()\n                except:\n                    self.setWarninginfo(\"清理失败，请检查配置文件后重试\")\n                return True\n            elif object == self.lab_config:\n                cw = ConfigWindow()\n                cw.Signal_OneParameter.connect(self.deal_emit_slot)\n                return True\n        return False\n\n    def _eventfilter(self):\n        # 事件过滤\n        self.lab_close.installEventFilter(self)\n        self.lab_clean.installEventFilter(self)\n        self.lab_config.installEventFilter(self)\n\n    def get_fileNum(self, path, day, picCacheCheck, fileCheck, picCheck,\n                    videoCheck, file_list, dir_list):\n        dir_name = PureWindowsPath(path)\n        # Convert path to the right format for the current operating system\n        correct_path = Path(dir_name)\n        now = datetime.datetime.now()\n        if picCacheCheck:\n            path_one = correct_path / 'Attachment'\n            path_two = correct_path / 'FileStorage/Cache'\n            self.getPathFileNum(now, day, path_one, path_two, file_list,\n                                dir_list)\n        if fileCheck:\n            path_one = correct_path / 'Files'\n            path_two = correct_path / 'FileStorage/File'\n            self.getPathFileNum(now, day, path_one, path_two, file_list,\n                                dir_list)\n        if picCheck:\n            path_one = correct_path / 'Image/Image'\n            path_two = correct_path / 'FileStorage/Image'\n            self.getPathFileNum(now, day, path_one, path_two, file_list,\n                                dir_list)\n        if videoCheck:\n            path_one = correct_path / 'Video'\n            path_two = correct_path / 'FileStorage/Video'\n            self.getPathFileNum(now, day, path_one, path_two, file_list,\n                                dir_list)\n\n    def pathFileDeal(self, now, day, path, file_list, dir_list):\n        if os.path.exists(path):\n            filelist = [\n                f for f in os.listdir(path)\n                if os.path.isfile(os.path.join(path, f))\n            ]\n            for i in range(0, len(filelist)):\n                file_path = os.path.join(path, filelist[i])\n                if os.path.isdir(file_path):\n                    continue\n                timestamp = datetime.datetime.fromtimestamp(\n                    os.path.getmtime(file_path))\n                diff = (now - timestamp).days\n                if diff >= day:\n                    file_list.append(file_path)\n\n    def getPathFileNum(self, now, day, path_one, path_two, file_list,\n                       dir_list):\n        # caculate path_one\n        self.pathFileDeal(now, day, path_one, file_list, dir_list)\n        td = datetime.datetime.now() - datetime.timedelta(days=day)\n        td_year = td.year\n        td_month = td.month\n        # caculate path_two\n        if os.path.exists(path_two):\n            osdir = os.listdir(path_two)\n            dirlist = []\n            for i in range(0, len(osdir)):\n                file_path = os.path.join(path_two, osdir[i])\n                if os.path.isdir(file_path):\n                    dirlist.append(osdir[i])\n            for i in range(0, len(dirlist)):\n                file_path = os.path.join(path_two, dirlist[i])\n                if os.path.isfile(file_path):\n                    continue\n                if re.match('\\d{4}(\\-)\\d{2}', dirlist[i]) != None:\n                    cyear = int(dirlist[i].split('-', 1)[0])\n                    cmonth = int(dirlist[i].split('-', 1)[1])\n                    if self.__before_deadline(cyear, cmonth, td_year,\n                                              td_month):\n                        dir_list.append(file_path)\n                    else:\n                        if cmonth == td_month:\n                            self.pathFileDeal(now, day, file_path, file_list,\n                                              dir_list)\n\n    def __before_deadline(self, cyear, cmonth, td_year, td_month):\n        if cyear < td_year:\n            return True\n        elif cyear > td_year:\n            return False\n        elif cyear == td_year:\n            return cmonth < td_month\n\n    def callback(self, v):\n        value = v / int((self.total_file + self.total_dir)) * 100\n        self.bar_progress.setValue(int(value))\n        if value == 100:\n            out = \"本次共清理文件\" + str(self.total_file) + \"个，文件夹\" + str(\n                self.total_dir) + \"个。\\n请前往回收站检查并清空。\"\n            self.setSuccessinfo(out)\n            return\n\n    def justdoit(self): \n        fd = open(working_dir + \"/config.json\", encoding=\"utf-8\")\n        self.config = json.load(fd)\n        i = 0\n        need_clean = False\n        thread_list = []\n        total_file = 0\n        total_dir = 0\n        share_thread_arr = [0]\n        for value in self.config[\"users\"]:\n            file_list = []\n            dir_list = []\n            if value[\"is_clean\"]:\n                self.get_fileNum(self.config[\"data_dir\"][i],\n                                 int(value[\"clean_days\"]),\n                                 value[\"clean_pic_cache\"], value[\"clean_file\"],\n                                 value[\"clean_pic\"], value[\"clean_video\"],\n                                 file_list, dir_list)\n\n            if len(file_list) + len(dir_list) != 0:\n                need_clean = True\n                total_file += len(file_list)\n                total_dir += len(dir_list)\n                thread_list.append(\n                    multiDeleteThread(file_list, dir_list, share_thread_arr))\n                thread_list[-1].delete_process_signal.connect(self.callback)\n            i = i + 1\n\n        if not need_clean:\n            self.setWarninginfo(\"没有需要清理的文件\")\n        else:\n            self.total_file = total_file\n            self.total_dir = total_dir\n            for thread in thread_list:\n                thread.run()\n\n    def show_config_window(self):\n        self.config_window = ConfigWindow()\n        self.setSuccessinfo(\"已经准备好，可以开始了！\")\n\n    def __init__(self):\n        super().__init__()\n        loadUi(working_dir + \"/images/main.ui\", self)\n\n        self._frame()\n        self._eventfilter()\n        self.doFadeIn()\n        self.config_exists = True\n        self.show()\n\n        # 判断配置文件是否存在\n        if not os.path.exists(working_dir + \"/config.json\"):\n            self.setWarninginfo(\"首次使用，即将自动弹出配置窗口\")\n            self.config_exists = False\n\n            timer = QTimer(self)\n            timer.timeout.connect(self.show_config_window)\n            timer.setSingleShot(True)  # 只执行一次\n            \n            # 设置定时器的时间间隔，这里设置为 1000ms（1秒）\n            timer.start(1000)\n\n\nif __name__ == '__main__':\n    app = QApplication([])\n    win = MainWindow()\n    app.exec_()\n"
        },
        {
          "name": "readme.md",
          "type": "blob",
          "size": 3.375,
          "content": "# Clean My PC Wechat\n\n![](https://markdown-pic-blackboxo.oss-cn-shanghai.aliyuncs.com/banner.png)\n\n[![](https://img.shields.io/badge/platform-win64-lightgrey)](https://github.com/blackboxo/AutoDeleteFileOnPCWechat/releases) [![](https://img.shields.io/github/v/release/blackboxo/AutoDeleteFileOnPCWechat)](https://github.com/blackboxo/AutoDeleteFileOnPCWechat/releases) [![](https://img.shields.io/github/downloads/blackboxo/AutoDeleteFileOnPCWechat/total)](https://github.com/blackboxo/AutoDeleteFileOnPCWechat/releases)\n\n<a href=\"https://hellogithub.com/repository/372422c3479e496aabd39ee17d56b5ba\" target=\"_blank\"><img src=\"https://api.hellogithub.com/v1/widgets/recommend.svg?rid=372422c3479e496aabd39ee17d56b5ba&claim_uid=Nyem9zKIlpfGH2U\" alt=\"Featured｜HelloGitHub\" style=\"width: 250px; height: 54px;\" width=\"250\" height=\"54\" /></a>\n\n自动删除 PC 端微信自动下载的大量文件、视频、图片等数据内容，解放一年几十 G 的空间占用。\n\n该工具不会删除文字的聊天记录，请放心使用。请给个 **Star** 吧，非常感谢！\n\n**现已经支持 Windows 系统中的所有微信版本。**\n\n[国内地址 - 点击下载](\nhttps://wwvs.lanzouj.com/is77n0yap4dc)\n\n[Github Release - 点击下载](\nhttps://github.com/blackboxo/CleanMyWechat/releases/download/v2.1/CleanMyWechat.zip)\n\n**碰到无法清理的，请记得勾选第一个选项，勾选后才会清理该账号下的内容。**\n\n[Buy me a coffee :coffee:](https://www.chongya.com/@blackboxo)\n\n## 特性\n1. 自动识别微信账号，支持用户选择自定义路径；\n2. 同时管理多个账号，保留配置参数，打开即用；\n3. 自由设置想要删除的文件类型，包括图片类缓存、文件、图片、视频；\n4. 自由设置需要删除的文件的距离时间，默认 365 天；\n5. 删除后的文件放置在回收站中，检查后自行清空，防止删错需要的文件；\n\n## 运行截图\n\n![](https://markdown-pic-blackboxo.oss-cn-shanghai.aliyuncs.com/20200929151623.jpg)\n\n## 微信现状\n\n下载两年时间，微信一个软件就占用多达 33.5 G 存储空间。其中大部分都是与自己无关的各大群聊中的文件、视频、图片等内容，且很久以前的文件仍旧存在电脑中。\n\n![](https://markdown-pic-blackboxo.oss-cn-shanghai.aliyuncs.com/20200213142805.png)\n\n## 待改进\n\n欢迎 PR！\n\n- [ ] Mac 版本的开发\n- [ ] 增加企业微信的支持\n- [ ] Windows XP/7 系统的支持\n\n其他需求详见 Issue\n\n## 打包 EXE 方式\n\n```Shell\npip install -r requirements.txt\npyinstaller -F -i images/icon.ico -w main.py\ncp -r images dist/\n./dist/main.exe\n```\n\n## 致谢\n\n[@mylittlefox](https://www.mylittlefox.art)：图标及 Banner 设计\n\n[@Gears](https://refun.eu.org)：提供微信 for Windows 版本的文件目录树及测试支持\n\n@SongJee：版本 1.1 的主要开发者，增加进度条，支持多个微信版本，自动识别路径\n\n[@LenmoisLemon](https://github.com/LenmoisLemon)：版本 2.0 的主要开发者，全新 UI 设计，增加多用户配置\n\n[@Louhwz](https://github.com/Louhwz)：版本 2.0 的主要开发者，增加多用户支持、多线程删除、自定义路径等\n\n## 开发者\n\n微博：@BlackBoXo\n\n邮箱：bwu18@fudan.edu.cn\n\nBlog：https://www.blackboxo.top/\n\n## Star History\n\n[![Star History Chart](https://api.star-history.com/svg?repos=blackboxo/CleanMyWechat&type=Date)](https://star-history.com/#blackboxo/CleanMyWechat&Date)\n"
        },
        {
          "name": "requirements.txt",
          "type": "blob",
          "size": 0.0791015625,
          "content": "Send2Trash==1.8.3\nPyQt5==5.15.10\npython_dateutil==2.9.0.post0\npyinstaller==6.8.0\n"
        },
        {
          "name": "utils",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}