{
  "metadata": {
    "timestamp": 1736559572780,
    "page": 190,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "subzeroid/instagrapi",
      "stars": 4526,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".bandit",
          "type": "blob",
          "size": 0.0654296875,
          "content": "[bandit]\nexclude: *venv*,*env*,*scratch*\nskips: B101,B311,B303,B306"
        },
        {
          "name": ".dockerignore",
          "type": "blob",
          "size": 0.01953125,
          "content": ".github/\n.git/\nvenv/"
        },
        {
          "name": ".flake8",
          "type": "blob",
          "size": 0.087890625,
          "content": "[flake8]\nignore = W503\nmax-line-length = 120\nexclude = */tests/*,*test*.py,*/migrations/*\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 1.85546875,
          "content": "/*.mp4\n/*.jpg\n/*.m4a\n# emacs\n*~\n.DS_Store\n\n# Byte-compiled / optimized / DLL files\n__pycache__/\n*.py[cod]\n*$py.class\n\n# C extensions\n*.so\n\n# Distribution / packaging\n.Python\nbuild/\ndevelop-eggs/\ndist/\ndownloads/\neggs/\n.eggs/\nlib/\nlib64/\nparts/\nsdist/\nvar/\nwheels/\npip-wheel-metadata/\nshare/python-wheels/\n*.egg-info/\n.installed.cfg\n*.egg\nMANIFEST\n\n# PyInstaller\n#  Usually these files are written by a python script from a template\n#  before PyInstaller builds the exe, so as to inject date/other infos into it.\n*.manifest\n*.spec\n\n# Installer logs\npip-log.txt\npip-delete-this-directory.txt\n\n# Unit test / coverage reports\nhtmlcov/\n.tox/\n.nox/\n.coverage\n.coverage.*\n.cache\nnosetests.xml\ncoverage.xml\n*.cover\n*.py,cover\n.hypothesis/\n.pytest_cache/\n\n# Translations\n*.mo\n*.pot\n\n# Django stuff:\n*.log\nlocal_settings.py\ndb.sqlite3\ndb.sqlite3-journal\n\n# Flask stuff:\ninstance/\n.webassets-cache\n\n# Scrapy stuff:\n.scrapy\n\n# Sphinx documentation\ndocs/_build/\n\n# PyBuilder\ntarget/\n\n# Jupyter Notebook\n.ipynb_checkpoints\n\n# IPython\nprofile_default/\nipython_config.py\n\n# pyenv\n.python-version\n\n# pipenv\n#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.\n#   However, in case of collaboration, if having platform-specific dependencies or dependencies\n#   having no cross-platform support, pipenv may install dependencies that don't work, or not\n#   install all needed dependencies.\n#Pipfile.lock\n\n# PEP 582; used by e.g. github.com/David-OConnor/pyflow\n__pypackages__/\n\n# Celery stuff\ncelerybeat-schedule\ncelerybeat.pid\n\n# SageMath parsed files\n*.sage.py\n\n# Environments\n.env\n.venv\nenv/\nvenv/\nENV/\nenv.bak/\nvenv.bak/\n\n# Spyder project settings\n.spyderproject\n.spyproject\n\n# Rope project settings\n.ropeproject\n\n# mkdocs documentation\n/site\n\n# mypy\n.mypy_cache/\n.dmypy.json\ndmypy.json\n\n# Pyre type checker\n.pyre/\n\n# PyCharm\n.idea\n*.iml\n\n# VSCode\n.vscode\nig_settings.json\n"
        },
        {
          "name": ".isort.cfg",
          "type": "blob",
          "size": 0.03515625,
          "content": "[settings]\nprofile=black\natomic=true"
        },
        {
          "name": ".pre-commit-config.yaml",
          "type": "blob",
          "size": 0.3388671875,
          "content": "repos:\n-   repo: https://github.com/pre-commit/pre-commit-hooks\n    rev: v4.3.0\n    hooks:\n    -   id: check-yaml\n    -   id: end-of-file-fixer\n    -   id: trailing-whitespace\n-   repo: https://github.com/psf/black\n    rev: 22.8.0\n    hooks:\n    -   id: black\n-   repo: https://github.com/pycqa/flake8\n    rev: 5.0.4\n    hooks:\n    -   id: flake8\n"
        },
        {
          "name": "CODE_OF_CONDUCT.md",
          "type": "blob",
          "size": 5.1025390625,
          "content": "# Contributor Covenant Code of Conduct\n\n## Our Pledge\n\nWe as members, contributors, and leaders pledge to make participation in our\ncommunity a harassment-free experience for everyone, regardless of age, body\nsize, visible or invisible disability, ethnicity, sex characteristics, gender\nidentity and expression, level of experience, education, socio-economic status,\nnationality, personal appearance, race, religion, or sexual identity\nand orientation.\n\nWe pledge to act and interact in ways that contribute to an open, welcoming,\ndiverse, inclusive, and healthy community.\n\n## Our Standards\n\nExamples of behavior that contributes to a positive environment for our\ncommunity include:\n\n* Demonstrating empathy and kindness toward other people\n* Being respectful of differing opinions, viewpoints, and experiences\n* Giving and gracefully accepting constructive feedback\n* Accepting responsibility and apologizing to those affected by our mistakes,\n  and learning from the experience\n* Focusing on what is best not just for us as individuals, but for the\n  overall community\n\nExamples of unacceptable behavior include:\n\n* The use of sexualized language or imagery, and sexual attention or\n  advances of any kind\n* Trolling, insulting or derogatory comments, and personal or political attacks\n* Public or private harassment\n* Publishing others' private information, such as a physical or email\n  address, without their explicit permission\n* Other conduct which could reasonably be considered inappropriate in a\n  professional setting\n\n## Enforcement Responsibilities\n\nCommunity leaders are responsible for clarifying and enforcing our standards of\nacceptable behavior and will take appropriate and fair corrective action in\nresponse to any behavior that they deem inappropriate, threatening, offensive,\nor harmful.\n\nCommunity leaders have the right and responsibility to remove, edit, or reject\ncomments, commits, code, wiki edits, issues, and other contributions that are\nnot aligned to this Code of Conduct, and will communicate reasons for moderation\ndecisions when appropriate.\n\n## Scope\n\nThis Code of Conduct applies within all community spaces, and also applies when\nan individual is officially representing the community in public spaces.\nExamples of representing our community include using an official e-mail address,\nposting via an official social media account, or acting as an appointed\nrepresentative at an online or offline event.\n\n## Enforcement\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be\nreported to the community leaders responsible for enforcement at\nhttps://t.me/instagrapi.\nAll complaints will be reviewed and investigated promptly and fairly.\n\nAll community leaders are obligated to respect the privacy and security of the\nreporter of any incident.\n\n## Enforcement Guidelines\n\nCommunity leaders will follow these Community Impact Guidelines in determining\nthe consequences for any action they deem in violation of this Code of Conduct:\n\n### 1. Correction\n\n**Community Impact**: Use of inappropriate language or other behavior deemed\nunprofessional or unwelcome in the community.\n\n**Consequence**: A private, written warning from community leaders, providing\nclarity around the nature of the violation and an explanation of why the\nbehavior was inappropriate. A public apology may be requested.\n\n### 2. Warning\n\n**Community Impact**: A violation through a single incident or series\nof actions.\n\n**Consequence**: A warning with consequences for continued behavior. No\ninteraction with the people involved, including unsolicited interaction with\nthose enforcing the Code of Conduct, for a specified period of time. This\nincludes avoiding interactions in community spaces as well as external channels\nlike social media. Violating these terms may lead to a temporary or\npermanent ban.\n\n### 3. Temporary Ban\n\n**Community Impact**: A serious violation of community standards, including\nsustained inappropriate behavior.\n\n**Consequence**: A temporary ban from any sort of interaction or public\ncommunication with the community for a specified period of time. No public or\nprivate interaction with the people involved, including unsolicited interaction\nwith those enforcing the Code of Conduct, is allowed during this period.\nViolating these terms may lead to a permanent ban.\n\n### 4. Permanent Ban\n\n**Community Impact**: Demonstrating a pattern of violation of community\nstandards, including sustained inappropriate behavior,  harassment of an\nindividual, or aggression toward or disparagement of classes of individuals.\n\n**Consequence**: A permanent ban from any sort of public interaction within\nthe community.\n\n## Attribution\n\nThis Code of Conduct is adapted from the [Contributor Covenant][homepage],\nversion 2.0, available at\nhttps://www.contributor-covenant.org/version/2/0/code_of_conduct.html.\n\nCommunity Impact Guidelines were inspired by [Mozilla's code of conduct\nenforcement ladder](https://github.com/mozilla/diversity).\n\n[homepage]: https://www.contributor-covenant.org\n\nFor answers to common questions about this code of conduct, see the FAQ at\nhttps://www.contributor-covenant.org/faq. Translations are available at\nhttps://www.contributor-covenant.org/translations.\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 4.3857421875,
          "content": "# Contributing\n\nWhen contributing to this repository, please first discuss the change you wish to make via issue,\nemail, or any other method with the owners of this repository before making a change.\n\nPlease note we have a code of conduct, please follow it in all your interactions with the project.\n\n## Pull Request Process\n\n1. Ensure any install or build dependencies are removed before the end of the layer when doing a\n   build.\n2. Add or change [unittests](/tests.py) that are specific to functionality according to [Development Guide](https://subzeroid.github.io/instagrapi/development-guide.html)\n3. Add documentation about your methods and changes to [docs](/docs)\n4. Update the README.md with details of changes to the interface, this includes new environment\n   variables, exposed ports, useful file locations and container parameters.\n5. Increase the version number in [setup.py](/setup.py) and date of last reverse-engineering in the README.md to the new version that this\n   Pull Request would represent. The versioning scheme we use is [SemVer](http://semver.org/).\n6. You may merge the Pull Request in once you have the sign-off of two other developers, or if you\n   do not have permission to do that, you may request the second reviewer to merge it for you.\n\n## Code of Conduct\n\n### Our Pledge\n\nIn the interest of fostering an open and welcoming environment, we as\ncontributors and maintainers pledge to making participation in our project and\nour community a harassment-free experience for everyone, regardless of age, body\nsize, disability, ethnicity, gender identity and expression, level of experience,\nnationality, personal appearance, race, religion, or sexual identity and\norientation.\n\n### Our Standards\n\nExamples of behavior that contributes to creating a positive environment\ninclude:\n\n* Using welcoming and inclusive language\n* Being respectful of differing viewpoints and experiences\n* Gracefully accepting constructive criticism\n* Focusing on what is best for the community\n* Showing empathy towards other community members\n\nExamples of unacceptable behavior by participants include:\n\n* The use of sexualized language or imagery and unwelcome sexual attention or\nadvances\n* Trolling, insulting/derogatory comments, and personal or political attacks\n* Public or private harassment\n* Publishing others' private information, such as a physical or electronic\n  address, without explicit permission\n* Other conduct which could reasonably be considered inappropriate in a\n  professional setting\n\n### Our Responsibilities\n\nProject maintainers are responsible for clarifying the standards of acceptable\nbehavior and are expected to take appropriate and fair corrective action in\nresponse to any instances of unacceptable behavior.\n\nProject maintainers have the right and responsibility to remove, edit, or\nreject comments, commits, code, wiki edits, issues, and other contributions\nthat are not aligned to this Code of Conduct, or to ban temporarily or\npermanently any contributor for other behaviors that they deem inappropriate,\nthreatening, offensive, or harmful.\n\n### Scope\n\nThis Code of Conduct applies both within project spaces and in public spaces\nwhen an individual is representing the project or its community. Examples of\nrepresenting a project or community include using an official project e-mail\naddress, posting via an official social media account, or acting as an appointed\nrepresentative at an online or offline event. Representation of a project may be\nfurther defined and clarified by project maintainers.\n\n### Enforcement\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be\nreported by contacting the project team at [INSERT EMAIL ADDRESS]. All\ncomplaints will be reviewed and investigated and will result in a response that\nis deemed necessary and appropriate to the circumstances. The project team is\nobligated to maintain confidentiality with regard to the reporter of an incident.\nFurther details of specific enforcement policies may be posted separately.\n\nProject maintainers who do not follow or enforce the Code of Conduct in good\nfaith may face temporary or permanent repercussions as determined by other\nmembers of the project's leadership.\n\n### Attribution\n\nThis Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4,\navailable at [http://contributor-covenant.org/version/1/4][version]\n\n[homepage]: http://contributor-covenant.org\n[version]: http://contributor-covenant.org/version/1/4/\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.03125,
          "content": "MIT License\n\nCopyright (c) 2023\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 10.8388671875,
          "content": "If you want to work with Instagrapi (business interests), we strongly advise you to prefer [HikerAPI SaaS](https://hikerapi.com/p/bkXQlaVe) project.\nHowever, you won't need to spend weeks or even months setting it up.\nThe best service available today is [HikerAPI SaaS](https://hikerapi.com/p/bkXQlaVe), which handles 4–5 million daily requests, provides support around-the-clock, and offers partners a special rate.\nIn many instances, our clients tried to save money and preferred instagrapi, but in our experience, they ultimately returned to [HikerAPI SaaS](https://hikerapi.com/p/bkXQlaVe) after spending much more time and money.\nIt will be difficult to find good accounts, good proxies, or resolve challenges, and IG will ban your accounts.\n\nThe instagrapi more suits for testing or research than a working business!\n\n✨ [aiograpi - Asynchronous Python library for Instagram Private API](https://github.com/subzeroid/aiograpi) ✨\n\n### We recommend using our services:\n\n* [LamaTok](https://lamatok.com/p/B9ScEYIQ) for TikTok API 🔥\n* [HikerAPI](https://hikerapi.com/p/bkXQlaVe) for Instagram API ⚡⚡⚡\n* [DataLikers](https://datalikers.com/p/S9Lv5vBy) for Instagram Datasets 🚀\n\n[![Package](https://github.com/subzeroid/instagrapi/actions/workflows/python-package.yml/badge.svg?branch=master&1)](https://github.com/subzeroid/instagrapi/actions/workflows/python-package.yml)\n[![PyPI](https://img.shields.io/pypi/v/instagrapi)](https://pypi.org/project/instagrapi/)\n![PyPI - Python Version](https://img.shields.io/pypi/pyversions/instagrapi)\n![Checked with mypy](https://img.shields.io/badge/mypy-checked-blue)\n\n\nFeatures:\n\n* Getting public data of user, posts, stories, highlights, followers and following users\n* Getting public email and phone number, if the user specified them in his business profile\n* Getting public data of post, story, album, Reels, IGTV data and the ability to download content\n* Getting public data of hashtag and location data, as well as a list of posts for them\n* Getting public data of all comments on a post and a list of users who liked it\n* Management of [proxy servers](https://bit.ly/instagrapi-oxy), mobile devices and challenge resolver\n* Login by username and password, sessionid and support 2FA\n* Managing messages and threads for Direct and attach files\n* Download and upload a Photo, Video, IGTV, Reels, Albums and Stories\n* Work with Users, Posts, Comments, Insights, Collections, Location and Hashtag\n* Insights by account, posts and stories\n* Like, following, commenting, editing account (Bio) and much more else\n\n# instagrapi - Unofficial Instagram API for Python\n\nFast and effective Instagram Private API wrapper (public+private requests and challenge resolver) without selenium. Use the most recent version of the API from Instagram, which was obtained using reverse-engineering with Charles Proxy and [Proxyman](https://proxyman.io/).\n\n*Instagram API valid for **25 Dec 2024** (last reverse-engineering check)*\n\nSupport **Python >= 3.9**\n\nFor any other languages (e.g. C++, C#, F#, D, [Golang](https://github.com/subzeroid/instagrapi-rest/tree/main/golang), Erlang, Elixir, Nim, Haskell, Lisp, Closure, Julia, R, Java, Kotlin, Scala, OCaml, JavaScript, Crystal, Ruby, Rust, [Swift](https://github.com/subzeroid/instagrapi-rest/tree/main/swift), Objective-C, Visual Basic, .NET, Pascal, Perl, Lua, PHP and others), I suggest using [instagrapi-rest](https://github.com/subzeroid/instagrapi-rest)\n\n[Support Chat in Telegram](https://t.me/instagrapi)\n![](https://gist.githubusercontent.com/m8rge/4c2b36369c9f936c02ee883ca8ec89f1/raw/c03fd44ee2b63d7a2a195ff44e9bb071e87b4a40/telegram-single-path-24px.svg) and [GitHub Discussions](https://github.com/subzeroid/instagrapi/discussions)\n\n\n## Features\n\n1. Performs [Web API](https://subzeroid.github.io/instagrapi/usage-guide/fundamentals.html) or [Mobile API](https://subzeroid.github.io/instagrapi/usage-guide/fundamentals.html) requests depending on the situation (to avoid Instagram limits)\n2. [Login](https://subzeroid.github.io/instagrapi/usage-guide/interactions.html) by username and password, including 2FA and by sessionid (and uses Authorization header instead Cookies)\n3. [Challenge Resolver](https://subzeroid.github.io/instagrapi/usage-guide/challenge_resolver.html) have Email and SMS handlers\n4. Support [upload](https://subzeroid.github.io/instagrapi/usage-guide/media.html) a Photo, Video, IGTV, Reels, Albums and Stories\n5. Support work with [User](https://subzeroid.github.io/instagrapi/usage-guide/user.html), [Media](https://subzeroid.github.io/instagrapi/usage-guide/media.html), [Comment](https://subzeroid.github.io/instagrapi/usage-guide/comment.html), [Insights](https://subzeroid.github.io/instagrapi/usage-guide/insight.html), [Collections](https://subzeroid.github.io/instagrapi/usage-guide/collection.html), [Location](https://subzeroid.github.io/instagrapi/usage-guide/location.html) (Place), [Hashtag](https://subzeroid.github.io/instagrapi/usage-guide/hashtag.html) and [Direct Message](https://subzeroid.github.io/instagrapi/usage-guide/direct.html) objects\n6. [Like](https://subzeroid.github.io/instagrapi/usage-guide/media.html), [Follow](https://subzeroid.github.io/instagrapi/usage-guide/user.html), [Edit account](https://subzeroid.github.io/instagrapi/usage-guide/account.html) (Bio) and much more else\n7. [Insights](https://subzeroid.github.io/instagrapi/usage-guide/insight.html) by account, posts and stories\n8. [Build stories](https://subzeroid.github.io/instagrapi/usage-guide/story.html) with custom background, font animation, link sticker and mention users\n9. In the next release, account registration and captcha passing will appear\n\n## Examples of apps that use instagrapi\n\n* [Telegram Bot for Download Posts, Stories and Highlights](https://t.me/instagram_load_bot)\n\n### Installation\n\n```\npip install instagrapi\n```\n\n### Basic Usage\n\n``` python\nfrom instagrapi import Client\n\ncl = Client()\ncl.login(ACCOUNT_USERNAME, ACCOUNT_PASSWORD)\n\nuser_id = cl.user_id_from_username(ACCOUNT_USERNAME)\nmedias = cl.user_medias(user_id, 20)\n```\n\n<details>\n    <summary>Additional example</summary>\n\n```python\nfrom instagrapi import Client\nfrom instagrapi.types import StoryMention, StoryMedia, StoryLink, StoryHashtag\n\ncl = Client()\ncl.login(USERNAME, PASSWORD, verification_code=\"<2FA CODE HERE>\")\n\nmedia_pk = cl.media_pk_from_url('https://www.instagram.com/p/CGgDsi7JQdS/')\nmedia_path = cl.video_download(media_pk)\nsubzeroid = cl.user_info_by_username('subzeroid')\nhashtag = cl.hashtag_info('dhbastards')\n\ncl.video_upload_to_story(\n    media_path,\n    \"Credits @subzeroid\",\n    mentions=[StoryMention(user=subzeroid, x=0.49892962, y=0.703125, width=0.8333333333333334, height=0.125)],\n    links=[StoryLink(webUri='https://github.com/subzeroid/instagrapi')],\n    hashtags=[StoryHashtag(hashtag=hashtag, x=0.23, y=0.32, width=0.5, height=0.22)],\n    medias=[StoryMedia(media_pk=media_pk, x=0.5, y=0.5, width=0.6, height=0.8)]\n)\n```\n</details>\n\n## Documentation\n\n* [Index](https://subzeroid.github.io/instagrapi/)\n* [Getting Started](https://subzeroid.github.io/instagrapi/getting-started.html)\n* [Usage Guide](https://subzeroid.github.io/instagrapi/usage-guide/fundamentals.html)\n* [Interactions](https://subzeroid.github.io/instagrapi/usage-guide/interactions.html)\n  * [`Media`](https://subzeroid.github.io/instagrapi/usage-guide/media.html) - Publication (also called post): Photo, Video, Album, IGTV and Reels\n  * [`Resource`](https://subzeroid.github.io/instagrapi/usage-guide/media.html) - Part of Media (for albums)\n  * [`MediaOembed`](https://subzeroid.github.io/instagrapi/usage-guide/media.html) - Short version of Media\n  * [`Account`](https://subzeroid.github.io/instagrapi/usage-guide/account.html) - Full private info for your account (e.g. email, phone_number)\n  * [`TOTP`](https://subzeroid.github.io/instagrapi/usage-guide/totp.html) - 2FA TOTP helpers (generate seed, enable/disable TOTP, generate code as Google Authenticator)\n  * [`User`](https://subzeroid.github.io/instagrapi/usage-guide/user.html) - Full public user data\n  * [`UserShort`](https://subzeroid.github.io/instagrapi/usage-guide/user.html) - Short public user data (used in Usertag, Comment, Media, Direct Message)\n  * [`Usertag`](https://subzeroid.github.io/instagrapi/usage-guide/user.html) - Tag user in Media (coordinates + UserShort)\n  * [`Location`](https://subzeroid.github.io/instagrapi/usage-guide/location.html) - GEO location (GEO coordinates, name, address)\n  * [`Hashtag`](https://subzeroid.github.io/instagrapi/usage-guide/hashtag.html) - Hashtag object (id, name, picture)\n  * [`Collection`](https://subzeroid.github.io/instagrapi/usage-guide/collection.html) - Collection of medias (name, picture and list of medias)\n  * [`Comment`](https://subzeroid.github.io/instagrapi/usage-guide/comment.html) - Comments to Media\n  * [`Highlight`](https://subzeroid.github.io/instagrapi/usage-guide/highlight.html) - Highlights\n  * [`Notes`](https://subzeroid.github.io/instagrapi/usage-guide/notes.html) - Notes\n  * [`Story`](https://subzeroid.github.io/instagrapi/usage-guide/story.html) - Story\n  * [`StoryLink`](https://subzeroid.github.io/instagrapi/usage-guide/story.html) - Link Sticker\n  * [`StoryLocation`](https://subzeroid.github.io/instagrapi/usage-guide/story.html) - Tag Location in Story (as sticker)\n  * [`StoryMention`](https://subzeroid.github.io/instagrapi/usage-guide/story.html) - Mention users in Story (user, coordinates and dimensions)\n  * [`StoryHashtag`](https://subzeroid.github.io/instagrapi/usage-guide/story.html) - Hashtag for story (as sticker)\n  * [`StorySticker`](https://subzeroid.github.io/instagrapi/usage-guide/story.html) - Tag sticker to story (for example from giphy)\n  * [`StoryBuild`](https://subzeroid.github.io/instagrapi/usage-guide/story.html) - [StoryBuilder](/instagrapi/story.py) return path to photo/video and mention co-ordinates\n  * [`DirectThread`](https://subzeroid.github.io/instagrapi/usage-guide/direct.html) - Thread (topic) with messages in Direct Message\n  * [`DirectMessage`](https://subzeroid.github.io/instagrapi/usage-guide/direct.html) - Message in Direct Message\n  * [`Insight`](https://subzeroid.github.io/instagrapi/usage-guide/insight.html) - Insights for a post\n  * [`Track`](https://subzeroid.github.io/instagrapi/usage-guide/track.html) - Music track (for Reels/Clips)\n* [Best Practices](https://subzeroid.github.io/instagrapi/usage-guide/best-practices.html)\n* [Development Guide](https://subzeroid.github.io/instagrapi/development-guide.html)\n* [Handle Exceptions](https://subzeroid.github.io/instagrapi/usage-guide/handle_exception.html)\n* [Challenge Resolver](https://subzeroid.github.io/instagrapi/usage-guide/challenge_resolver.html)\n* [Exceptions](https://subzeroid.github.io/instagrapi/exceptions.html)\n\n## Contributing\n\n[![List of contributors](https://opencollective.com/instagrapi/contributors.svg?width=890&button=0)](https://github.com/subzeroid/instagrapi/graphs/contributors)\n\nTo release, you need to call the following commands:\n\n    python setup.py sdist\n    twine upload dist/*\n"
        },
        {
          "name": "SECURITY.md",
          "type": "blob",
          "size": 0.369140625,
          "content": "# Security Policy\n\n## Supported Versions\n\nOnly the latest versions are supported\n\n| Version    | Supported          |\n| ---------- | ------------------ |\n| 1.12.x     | :white_check_mark: |\n| < 1.12.0   | :x:                |\n\n## Reporting a Vulnerability\n\nReport vulnerabilities in the telegram channel https://t.me/instagrapi or https://github.com/subzeroid/instagrapi/issues\n"
        },
        {
          "name": "docker-compose.yml",
          "type": "blob",
          "size": 1.001953125,
          "content": "version: \"3.4\"\n\nx-mount-app-and-user-git-config: &mount-app-and-user-git-config\n  volumes:\n    - ./:/app\n    - ~/.gitconfig:/home/instagrapi/.gitconfig # allow script to commit as user\n\nservices:\n\n  # \"devbox\" to enable the developer to have a fully loaded development environment\n  devbox: &devbox\n    build:\n      dockerfile: \"./docker/devbox.dockerfile\"\n      context: \".\"\n    tty: true\n    volumes:\n      - \"./:/app\"\n\n  # \"test\" enables the developer to run all the tests and linting locally\n  test:\n    <<: *devbox\n    command: \"docker/run_tests.sh --format-code\"\n\n  tests:\n    <<: *devbox\n    command: \"python -m unittest tests\"\n\n  lock-requirements:\n    <<: *devbox\n    entrypoint: \"/bin/bash\"\n    command: \"docker/lock_requirements.sh\"\n\n  # generate and serve the project documentation locally\n  mkdocs: &mkdocs\n    <<: *devbox\n    entrypoint: \"mkdocs\"\n    ports:\n      - \"8000:8000\"\n    command: [ \"serve\", \"--dev-addr=0.0.0.0:8000\" ]\n\n  mike:\n    <<: [*mkdocs, *mount-app-and-user-git-config]\n    entrypoint: \"mike\"\n"
        },
        {
          "name": "docker",
          "type": "tree",
          "content": null
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "instagrapi",
          "type": "tree",
          "content": null
        },
        {
          "name": "mkdocs.yml",
          "type": "blob",
          "size": 1.5234375,
          "content": "site_name: instagrapi Documentation\nrepo_url: https://github.com/subzeroid/instagrapi/\nsite_url: https://subzeroid.github.io/instagrapi/\nrepo_name: subzeroid/instagrapi\nedit_uri: edit/main/docs/\ndocs_dir: docs\nnav:\n  - Overview: index.md\n  - Getting Started: getting-started.md\n  - Usage Guide:\n    - Fundamentals: usage-guide/fundamentals.md\n    - Interactions: usage-guide/interactions.md\n    - Handle Exceptions: usage-guide/handle_exception.md\n    - Collection: usage-guide/collection.md\n    - Comment: usage-guide/comment.md\n    - Direct: usage-guide/direct.md\n    - Hashtag: usage-guide/hashtag.md\n    - Insight: usage-guide/insight.md\n    - Location: usage-guide/location.md\n    - Media: usage-guide/media.md\n    - Story: usage-guide/story.md\n    - Track: usage-guide/track.md\n    - User: usage-guide/user.md\n    - Account: usage-guide/account.md\n  - Best Practices: best-practices.md\n  - Development Guide: development-guide.md\n  - Exceptions: exceptions.md\ntheme: material\nmarkdown_extensions:\n  - markdown_include.include:\n      base_path: docs\n  - admonition\n  - codehilite\n  - footnotes\n  - pymdownx.highlight\n  - pymdownx.keys\n  - pymdownx.superfences\nplugins:\n  - mkdocstrings:\n      handlers:\n        python:\n          selection:\n            docstring_style: \"restructured-text\"\n          rendering:\n            heading_level: 3\n            show_root_heading: True\n            show_source: False\n            show_root_full_path: False\n  - mkdocstrings_patch_type_aliases\n\nextra:\n  version:\n    provider: mike\nextra_css:\n  - css/mkdocstrings.css\n"
        },
        {
          "name": "requirements-test.txt",
          "type": "blob",
          "size": 0.2568359375,
          "content": "flake8==7.1.1\nPillow==11.0.0\nisort==5.13.2\nbandit==1.8.0\nmike==2.1.3\nmarkdown-include==0.8.1\nmkdocs-material==9.5.49\nmkdocs-minify-plugin==0.8.0\nmkdocstrings==0.27.0\n./util/mkdocs-redirects\n./util/mkdocstrings_patch_type_aliases\npytest-xdist==3.6.1\npytest~=8.3.4\n"
        },
        {
          "name": "requirements.lock",
          "type": "blob",
          "size": 0.376953125,
          "content": "# THIS IS AN AUTOGENERATED LOCKFILE. DO NOT EDIT MANUALLY.\ncertifi==2020.12.5\nchardet==4.0.0\ndecorator==4.4.2\nidna==2.10\nimageio==2.9.0\nimageio-ffmpeg==0.4.3\nmoviepy==1.0.3\nnumpy==1.20.2\nPillow==8.2.0\npip==21.0.1\nproglog==0.1.9\npycryptodomex==3.9.9\npydantic==2.5.2\nPySocks==1.7.1\nrequests==2.25.1\nsetuptools==53.0.0\ntqdm==4.60.0\ntyping-extensions==3.7.4.3\nurllib3==1.26.4\nwheel==0.36.2\n"
        },
        {
          "name": "requirements.txt",
          "type": "blob",
          "size": 0.083984375,
          "content": "requests==2.32.3\nPySocks==1.7.1\npydantic==2.10.4\nmoviepy==1.0.3\npycryptodomex==3.21.0\n"
        },
        {
          "name": "setup.py",
          "type": "blob",
          "size": 2.6025390625,
          "content": "from setuptools import find_packages, setup\n\nlong_description = \"\"\"\nFast and effective Instagram Private API wrapper (public+private requests and challenge resolver).\n\nUse the most recent version of the API from Instagram.\n\nFeatures:\n\n1. Performs Public API (web, anonymous) or Private API (mobile app, authorized)\n   requests depending on the situation (to avoid Instagram limits)\n2. Challenge Resolver have Email (as well as recipes for automating receive a code from email) and SMS handlers\n3. Support upload a Photo, Video, IGTV, Clips (Reels), Albums and Stories\n4. Support work with User, Media, Insights, Collections, Location (Place), Hashtag and Direct objects\n5. Like, Follow, Edit account (Bio) and much more else\n6. Insights by account, posts and stories\n7. Build stories with custom background, font animation, swipe up link and mention users\n8. In the next release, account registration and captcha passing will appear\n\"\"\"\n\nrequirements = [\n    \"requests<3.0,>=2.25.1\",\n    \"PySocks==1.7.1\",\n    \"pydantic==2.10.4\",\n    \"pycryptodomex==3.21.0\",\n]\n# requirements = [\n#     line.strip()\n#     for line in open('requirements.txt').readlines()\n# ]\n\nsetup(\n    name=\"instagrapi\",\n    version=\"2.1.3\",\n    author=\"Mark Subzeroid\",\n    author_email=\"143403577+subzeroid@users.noreply.github.com\",\n    license=\"MIT\",\n    url=\"https://github.com/subzeroid/instagrapi\",\n    install_requires=requirements,\n    keywords=[\n        \"instagram private api\",\n        \"instagram-private-api\",\n        \"instagram api\",\n        \"instagram-api\",\n        \"instagram\",\n        \"instagram-scraper\",\n        \"instagram-client\",\n        \"instagram-stories\",\n        \"instagram-feed\",\n        \"instagram-reels\",\n        \"instagram-insights\",\n        \"downloader\",\n        \"uploader\",\n        \"videos\",\n        \"photos\",\n        \"albums\",\n        \"igtv\",\n        \"reels\",\n        \"stories\",\n        \"pictures\",\n        \"instagram-user-photos\",\n        \"instagram-photos\",\n        \"instagram-metadata\",\n        \"instagram-downloader\",\n        \"instagram-uploader\",\n        \"instagram-note\",\n    ],\n    description=\"Fast and effective Instagram Private API wrapper\",\n    long_description=long_description,\n    long_description_content_type=\"text/markdown\",\n    packages=find_packages(),\n    python_requires=\">=3.9\",\n    include_package_data=True,\n    classifiers=[\n        \"Development Status :: 4 - Beta\",\n        \"Intended Audience :: Developers\",\n        \"License :: OSI Approved :: MIT License\",\n        \"Topic :: Software Development :: Libraries :: Python Modules\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n    ],\n)\n"
        },
        {
          "name": "tests.py",
          "type": "blob",
          "size": 62.9580078125,
          "content": "import os\nimport json\nimport os.path\nimport random\nimport logging\nimport requests\nimport unittest\nfrom datetime import datetime, timedelta\nfrom json.decoder import JSONDecodeError\nfrom pathlib import Path\n\nfrom instagrapi import Client\nfrom instagrapi.utils import gen_password\nfrom instagrapi.exceptions import (\n    BadCredentials,\n    DirectThreadNotFound,\n    ProxyAddressIsBlocked,\n    BadPassword,\n)\nfrom instagrapi.story import StoryBuilder\nfrom instagrapi.types import (\n    Account,\n    Collection,\n    Comment,\n    DirectMessage,\n    DirectThread,\n    Hashtag,\n    Highlight,\n    Location,\n    Media,\n    MediaOembed,\n    Share,\n    Story,\n    StoryLink,\n    StoryMedia,\n    StoryMention,\n    StorySticker,\n    User,\n    UserShort,\n    Usertag,\n)\nfrom instagrapi.utils import generate_jazoest\nfrom instagrapi.zones import UTC\n\nlogger = logging.getLogger(\"instagrapi.tests\")\nACCOUNT_USERNAME = os.getenv(\"IG_USERNAME\", \"username\")\nACCOUNT_PASSWORD = os.getenv(\"IG_PASSWORD\", \"password*\")\nACCOUNT_SESSIONID = os.getenv(\"IG_SESSIONID\", \"\")\nTEST_ACCOUNTS_URL = os.getenv(\"TEST_ACCOUNTS_URL\")\n\nREQUIRED_MEDIA_FIELDS = [\n    \"pk\",\n    \"taken_at\",\n    \"id\",\n    \"media_type\",\n    \"code\",\n    \"thumbnail_url\",\n    \"location\",\n    \"user\",\n    \"comment_count\",\n    \"like_count\",\n    \"caption_text\",\n    \"usertags\",\n    \"video_url\",\n    \"view_count\",\n    \"video_duration\",\n    \"title\",\n]\nREQUIRED_STORY_FIELDS = [\n    \"pk\",\n    \"id\",\n    \"code\",\n    \"taken_at\",\n    \"media_type\",\n    \"product_type\",\n    \"thumbnail_url\",\n    \"user\",\n    \"video_url\",\n    \"video_duration\",\n    \"mentions\",\n    \"links\",\n]\n\n\ndef cleanup(*paths):\n    for path in paths:\n        try:\n            os.remove(path)\n            os.remove(f\"{path}.jpg\")\n        except FileNotFoundError:\n            continue\n\n\ndef keep_path(user):\n    user.profile_pic_url = user.profile_pic_url.path\n    return user\n\n\nclass BaseClientMixin:\n    def __init__(self, *args, **kwargs):\n        if self.cl is None:\n            self.cl = Client()\n        self.set_proxy_if_exists()\n        super().__init__(*args, **kwargs)\n\n    def set_proxy_if_exists(self):\n        proxy = os.getenv(\"IG_PROXY\", \"\")\n        if proxy:\n            self.cl.set_proxy(proxy)  # \"socks5://127.0.0.1:30235\"\n        return True\n\n\nclass ClientPrivateTestCase(BaseClientMixin, unittest.TestCase):\n    cl = None\n    _username_cache = {}\n\n    def user_info_by_username(self, username):\n        return self.cl.user_info_by_username_v1(username)\n\n    def user_id_from_username(self, username):\n        info = self._username_cache.get(username)\n        if not info:\n            info = self.user_info_by_username(username)\n            self._username_cache[username] = info\n        return str(info.pk)\n\n    def setup_method(self, *args, **kwargs):\n        if TEST_ACCOUNTS_URL:\n            self.cl = self.fresh_account()\n\n    def fresh_account(self):\n        acc = requests.get(TEST_ACCOUNTS_URL).json()[0]\n        print(\"New fresh account %(username)r\" % acc)\n        settings = acc[\"client_settings\"]\n        totp_seed = settings.pop(\"totp_seed\", None)\n        cl = Client(settings=settings, proxy=acc[\"proxy\"])\n        if totp_seed:\n            totp_code = cl.totp_generate_code(totp_seed)\n            cl.login(\n                acc[\"username\"],\n                acc[\"password\"],\n                verification_code=totp_code,\n                relogin=True,\n            )\n            cl.totp_seed = totp_seed\n            cl.totp_code = totp_code\n            cl._user_id = acc.get(\"user_id\")\n        return cl\n\n    def __init__(self, *args, **kwargs):\n        if TEST_ACCOUNTS_URL:\n            self.cl = self.fresh_account()\n            return super().__init__(*args, **kwargs)\n        filename = f\"/tmp/instagrapi_tests_client_settings_{ACCOUNT_USERNAME}.json\"\n        self.cl = Client()\n        settings = {}\n        try:\n            st = os.stat(filename)\n            if datetime.fromtimestamp(st.st_mtime) > (\n                datetime.now() - timedelta(seconds=3600)\n            ):\n                # use only fresh session (5 minutes)\n                settings = self.cl.load_settings(filename)\n        except FileNotFoundError:\n            pass\n        except JSONDecodeError as e:\n            logger.info(\n                \"JSONDecodeError when read stored client settings. Use empty settings\"\n            )\n            logger.exception(e)\n        self.cl.set_settings(settings)\n        # self.cl.set_locale('ru_RU')\n        # self.cl.set_timezone_offset(10800)\n        self.cl.request_timeout = 1\n        self.set_proxy_if_exists()\n        if ACCOUNT_SESSIONID:\n            self.cl.login_by_sessionid(ACCOUNT_SESSIONID)\n        else:\n            self.cl.login(ACCOUNT_USERNAME, ACCOUNT_PASSWORD, relogin=True)\n        self.cl.dump_settings(filename)\n        super().__init__(*args, **kwargs)\n\n\nclass ClientPublicTestCase(BaseClientMixin, unittest.TestCase):\n    cl = None\n\n    def assertDict(self, obj, data):\n        for key, value in data.items():\n            if isinstance(value, str) and \"...\" in value:\n                self.assertTrue(value.replace(\"...\", \"\") in obj[key])\n            elif isinstance(value, int):\n                self.assertTrue(obj[key] >= value)\n            else:\n                self.assertEqual(obj[key], value)\n\n    def test_media_info_gql(self):\n        media_pk = self.cl.media_pk_from_url(\"https://www.instagram.com/p/BVDOOolFFxg/\")\n        m = self.cl.media_info_gql(media_pk)\n        self.assertIsInstance(m, Media)\n        media = {\n            \"pk\": 1532130876531694688,\n            \"id\": \"1532130876531694688_25025320\",\n            \"code\": \"BVDOOolFFxg\",\n            \"taken_at\": datetime(2017, 6, 7, 19, 37, 35, tzinfo=UTC()),\n            \"media_type\": 1,\n            \"product_type\": \"\",\n            \"thumbnail_url\": \"https://...\",\n            \"location\": None,\n            \"comment_count\": 6,\n            \"like_count\": 79,\n            \"has_liked\": None,\n            \"caption_text\": \"#creepy #creepyclothing\",\n            \"usertags\": [],\n            \"video_url\": None,\n            \"view_count\": 0,\n            \"video_duration\": 0.0,\n            \"title\": \"\",\n            \"resources\": [],\n        }\n        self.assertDict(m.dict(), media)\n        user = {\n            \"pk\": \"25025320\",\n            \"username\": \"example\",\n            \"full_name\": \"Example Example\",\n            \"profile_pic_url\": \"https://...\",\n        }\n        self.assertDict(m.user.dict(), user)\n\n\nclass ClientTestCase(unittest.TestCase):\n    def test_jazoest(self):\n        phone_id = \"57d64c41-a916-3fa5-bd7a-3796c1dab122\"\n        self.assertTrue(generate_jazoest(phone_id), \"22413\")\n\n    def test_lg(self):\n        settings = {\n            \"uuids\": {\n                \"phone_id\": \"57d64c41-a916-3fa5-bd7a-3796c1dab122\",\n                \"uuid\": \"8aa373c6-f316-44d7-b49e-d74563f4a8f3\",\n                \"client_session_id\": \"6c296d0a-3534-4dce-b5aa-a6a6ab017443\",\n                \"advertising_id\": \"8dc88b76-dfbc-44dc-abbc-31a6f1d54b04\",\n                \"android_device_id\": \"android-e021b636049dc0e9\",\n                \"request_id\": \"72d0f808-b5cd-40e2-910b-01ae7ae60a5b\",\n                \"tray_session_id\": \"bc44ef1d-c083-4ecd-b369-6f4a9e1a077c\",\n            },\n            \"mid\": \"YA1YMAACAAGtxxnZ1p4AYc8ufNMn\",\n            \"device_settings\": {\n                \"cpu\": \"h1\",\n                \"dpi\": \"640dpi\",\n                \"model\": \"h1\",\n                \"device\": \"RS988\",\n                \"resolution\": \"1440x2392\",\n                \"app_version\": \"269.0.0.19.301\",\n                \"manufacturer\": \"LGE/lge\",\n                \"version_code\": \"168361634\",\n                \"android_release\": \"6.0.1\",\n                \"android_version\": 23,\n            },\n            # \"user_agent\": \"Instagram 117.0.0.28.123 Android (23/6.0.1; US; 168361634)\"\n            \"user_agent\": \"Instagram 269.0.0.19.301 Android (27/8.1.0; 480dpi; 1080x1776; motorola; Moto G (5S); montana; qcom; ru_RU; 253447809)\",\n            \"country\": \"RU\",\n            \"locale\": \"ru_RU\",\n            \"timezone_offset\": 10800,  # Moscow, GMT+3\n        }\n        cl = Client(settings)\n        cl.login(ACCOUNT_USERNAME, ACCOUNT_PASSWORD)\n        self.assertIsInstance(cl.user_id, int)\n        self.assertEqual(cl.username, ACCOUNT_USERNAME)\n\n    def test_country_locale_timezone(self):\n        cl = Client()\n        # defaults:\n        self.assertEqual(cl.country, \"US\")\n        self.assertEqual(cl.locale, \"en_US\")\n        self.assertEqual(cl.timezone_offset, -14400)\n        settings = {\n            \"uuids\": {\n                \"phone_id\": \"57d64c41-a916-3fa5-bd7a-3796c1dab122\",\n                \"uuid\": \"8aa373c6-f316-44d7-b49e-d74563f4a8f3\",\n                \"client_session_id\": \"6c296d0a-3534-4dce-b5aa-a6a6ab017443\",\n                \"advertising_id\": \"8dc88b76-dfbc-44dc-abbc-31a6f1d54b04\",\n                \"android_device_id\": \"android-e021b636049dc0e9\",\n                \"request_id\": \"72d0f808-b5cd-40e2-910b-01ae7ae60a5b\",\n                \"tray_session_id\": \"bc44ef1d-c083-4ecd-b369-6f4a9e1a077c\",\n            },\n            \"mid\": \"YA1YMAACAAGtxxnZ1p4AYc8ufNMn\",\n            \"device_settings\": {\n                \"app_version\": \"269.0.0.19.301\",\n                \"android_version\": 26,\n                \"android_release\": \"8.0.0\",\n                \"dpi\": \"480dpi\",\n                \"resolution\": \"1080x1920\",\n                \"manufacturer\": \"Xiaomi\",\n                \"device\": \"capricorn\",\n                \"model\": \"MI 5s\",\n                \"cpu\": \"qcom\",\n                \"version_code\": \"301484483\",\n            },\n            \"user_agent\": \"Instagram 269.0.0.19.301 Android (26/8.0.0; 480dpi; 1080x1920; Xiaomi; MI 5s; capricorn; qcom; en_US; 301484483)\",\n            \"country\": \"UK\",\n            \"locale\": \"en_US\",\n            \"timezone_offset\": 3600,  # London, GMT+1\n        }\n        device = {\n            \"app_version\": \"165.1.0.20.119\",\n            \"android_version\": 27,\n            \"android_release\": \"8.1.0\",\n            \"dpi\": \"480dpi\",\n            \"resolution\": \"1080x1776\",\n            \"manufacturer\": \"motorola\",\n            \"device\": \"Moto G (5S)\",\n            \"model\": \"montana\",\n            \"cpu\": \"qcom\",\n            \"version_code\": \"253447809\",\n        }\n        # change settings\n        cl.set_settings(settings)\n\n        def check(country, locale, timezone_offset):\n            self.assertDictEqual(cl.get_settings()[\"uuids\"], settings[\"uuids\"])\n            self.assertEqual(cl.country, country)\n            self.assertEqual(cl.locale, locale)\n            self.assertEqual(cl.timezone_offset, timezone_offset)\n            self.assertIn(cl.locale, cl.user_agent)\n\n        cl.set_country(\"AU\")  # change only country\n        check(\"AU\", \"en_US\", 3600)\n        cl.set_locale(\"ru_RU\")  # locale change country\n        check(\"RU\", \"ru_RU\", 3600)\n        cl.set_timezone_offset(10800)  # change timezone_offset\n        check(\"RU\", \"ru_RU\", 10800)\n        cl.set_user_agent(\"TEST\")  # change user-agent\n        self.assertEqual(cl.get_settings()[\"user_agent\"], \"TEST\")\n        cl.set_device(device)  # change device\n        self.assertDictEqual(cl.get_settings()[\"device_settings\"], device)\n        cl.set_settings(settings)  # load source settings\n        check(\"UK\", \"en_US\", 3600)\n        self.assertEqual(cl.get_settings()[\"user_agent\"], settings[\"user_agent\"])\n        self.assertEqual(\n            cl.get_settings()[\"device_settings\"], settings[\"device_settings\"]\n        )\n\n\nclass ClientDeviceTestCase(ClientPrivateTestCase):\n    def test_set_device(self):\n        fields = [\"uuids\", \"cookies\", \"last_login\", \"device_settings\", \"user_agent\"]\n        for field in fields:\n            settings = self.cl.get_settings()\n            self.assertIn(field, settings)\n        device = {\n            \"app_version\": \"165.1.0.20.119\",\n            \"android_version\": 27,\n            \"android_release\": \"8.1.0\",\n            \"dpi\": \"480dpi\",\n            \"resolution\": \"1080x1776\",\n            \"manufacturer\": \"motorola\",\n            \"device\": \"Moto G (5S)\",\n            \"model\": \"montana\",\n            \"cpu\": \"qcom\",\n            \"version_code\": \"253447809\",\n        }\n        user_agent = \"Instagram 165.1.0.29.119 Android (27/8.1.0; 480dpi; 1080x1776; motorola; Moto G (5S); montana; qcom; ru_RU; 253447809)\"\n        self.cl.set_device(device)\n        self.cl.set_user_agent(user_agent)\n        settings = self.cl.get_settings()\n        self.assertDictEqual(device, settings[\"device_settings\"])\n        self.assertEqual(user_agent, settings[\"user_agent\"])\n        self.user_info_by_username(\"example\")\n        request_user_agent = self.cl.last_response.request.headers.get(\"User-Agent\")\n        self.assertEqual(user_agent, request_user_agent)\n\n\nclass ClientDeviceAgentTestCase(ClientPrivateTestCase):\n    def test_set_device_agent(self):\n        device = {\n            \"app_version\": \"165.1.0.20.119\",\n            \"android_version\": 27,\n            \"android_release\": \"8.1.0\",\n            \"dpi\": \"480dpi\",\n            \"resolution\": \"1080x1776\",\n            \"manufacturer\": \"motorola\",\n            \"device\": \"Moto G (5S)\",\n            \"model\": \"montana\",\n            \"cpu\": \"qcom\",\n            \"version_code\": \"253447809\",\n        }\n        user_agent = \"Instagram 165.1.0.29.119 Android (27/8.1.0; 480dpi; 1080x1776; motorola; Moto G (5S); montana; qcom; ru_RU; 253447809)\"\n        cl = Client()\n        cl.set_device(device)\n        cl.set_user_agent(user_agent)\n        cl.login(ACCOUNT_USERNAME, ACCOUNT_PASSWORD)\n        self.assertDictEqual(device, cl.settings[\"device_settings\"])\n        self.assertEqual(user_agent, cl.settings[\"user_agent\"])\n\n\nclass ClientUserTestCase(ClientPrivateTestCase):\n    def test_user_followers(self):\n        user_id = self.user_id_from_username(\"instagram\")\n        followers = self.cl.user_followers(user_id, amount=10)\n        self.assertTrue(len(followers) == 10)\n        self.assertIsInstance(list(followers.values())[0], UserShort)\n\n\nclass ClientUserExtendTestCase(ClientPrivateTestCase):\n    def test_username_from_user_id(self):\n        self.assertEqual(self.cl.username_from_user_id(25025320), \"instagram\")\n\n    def test_user_following(self):\n        user_id = self.user_id_from_username(\"instagram\")\n        self.cl.user_follow(user_id)\n        following = self.cl.user_following(self.cl.user_id, amount=1)\n        self.assertIn(user_id, following)\n        self.assertEqual(following[user_id].username, \"instagram\")\n        self.assertTrue(len(following) == 1)\n        self.assertIsInstance(list(following.values())[0], UserShort)\n\n    def test_user_info(self):\n        user_id = self.user_id_from_username(\"instagram\")\n        user = self.cl.user_info(user_id)\n        self.assertIsInstance(user, User)\n        for key, value in {\n            \"biography\": \"...Instagram...\",\n            \"external_url\": \"https://...\",\n            \"full_name\": \"Instagram\",\n            \"pk\": \"25025320\",\n            \"is_private\": False,\n            \"is_verified\": True,\n            \"profile_pic_url\": \"https://...\",\n            \"username\": \"instagram\",\n        }.items():\n            if isinstance(value, str) and \"...\" in value:\n                self.assertTrue(value.replace(\"...\", \"\") in getattr(user, key))\n            else:\n                self.assertEqual(value, getattr(user, key))\n\n    def test_user_info_by_username(self):\n        user = self.user_info_by_username(\"instagram\")\n        self.assertIsInstance(user, User)\n        self.assertEqual(user.pk, \"25025320\")\n        self.assertEqual(user.full_name, \"Instagram\")\n        self.assertFalse(user.is_private)\n\n    def test_user_medias(self):\n        user_id = self.user_id_from_username(\"instagram\")\n        medias = self.cl.user_medias(user_id, amount=10)\n        self.assertGreater(len(medias), 5)\n        media = medias[0]\n        self.assertIsInstance(media, Media)\n        for field in REQUIRED_MEDIA_FIELDS:\n            self.assertTrue(hasattr(media, field))\n\n    def test_usertag_medias(self):\n        user_id = self.user_id_from_username(\"instagram\")\n        medias = self.cl.usertag_medias(user_id, amount=10)\n        self.assertGreater(len(medias), 5)\n        media = medias[0]\n        self.assertIsInstance(media, Media)\n        for field in REQUIRED_MEDIA_FIELDS:\n            self.assertTrue(hasattr(media, field))\n\n    def test_user_follow_unfollow(self):\n        user_id = self.user_id_from_username(\"instagram\")\n        self.cl.user_follow(user_id)\n        following = self.cl.user_following(self.cl.user_id)\n        self.assertIn(user_id, following)\n        self.cl.user_unfollow(user_id)\n        following = self.cl.user_following(self.cl.user_id)\n        self.assertNotIn(user_id, following)\n\n    # def test_send_new_note(self):\n    #     self.cl.create_note(\"Hello from Instagrapi!\", 0)\n\n\nclass ClientMediaTestCase(ClientPrivateTestCase):\n    def test_media_id(self):\n        self.assertEqual(\n            self.cl.media_id(3258619191829745894), \"3258619191829745894_25025320\"\n        )\n\n    def test_media_pk(self):\n        self.assertEqual(\n            self.cl.media_pk(\"2154602296692269830_25025320\"), \"2154602296692269830\"\n        )\n\n    def test_media_pk_from_code(self):\n        self.assertEqual(self.cl.media_pk_from_code(\"B-fKL9qpeab\"), 2278584739065882267)\n        self.assertEqual(\n            self.cl.media_pk_from_code(\"B8jnuB2HAbyc0q001y3F9CHRSoqEljK_dgkJjo0\"),\n            2243811726252050162,\n        )\n\n    def test_code_from_media_pk(self):\n        self.assertEqual(self.cl.media_code_from_pk(2278584739065882267), \"B-fKL9qpeab\")\n        self.assertEqual(self.cl.media_code_from_pk(2243811726252050162), \"B8jnuB2HAby\")\n\n    def test_media_pk_from_url(self):\n        self.assertEqual(\n            self.cl.media_pk_from_url(\"https://instagram.com/p/B1LbfVPlwIA/\"),\n            2110901750722920960,\n        )\n        self.assertEqual(\n            self.cl.media_pk_from_url(\n                \"https://www.instagram.com/p/B-fKL9qpeab/?igshid=1xm76zkq7o1im\"\n            ),\n            2278584739065882267,\n        )\n\n\nclass ClientMediaExtendTestCase(ClientPrivateTestCase):\n    def test_media_user(self):\n        user = self.cl.media_user(2154602296692269830)\n        self.assertIsInstance(user, UserShort)\n        for key, val in {\n            \"pk\": \"25025320\",\n            \"username\": \"instagram\",\n            \"full_name\": \"Instagram\",\n            \"is_private\": False,\n        }.items():\n            self.assertEqual(getattr(user, key), val)\n        self.assertTrue(user.profile_pic_url.startswith(\"https://\"))\n\n    def test_media_oembed(self):\n        media_oembed = self.cl.media_oembed(\"https://www.instagram.com/p/B3mr1-OlWMG/\")\n        self.assertIsInstance(media_oembed, MediaOembed)\n        for key, val in {\n            \"title\": \"В гостях у ДК @delai_krasivo_kaifui\",\n            \"author_name\": \"instagram\",\n            \"author_url\": \"https://www.instagram.com/instagram\",\n            \"author_id\": \"25025320\",\n            \"media_id\": \"2154602296692269830_25025320\",\n            \"width\": 658,\n            \"height\": None,\n            \"thumbnail_width\": 640,\n            \"thumbnail_height\": 480,\n            \"can_view\": True,\n        }.items():\n            self.assertEqual(getattr(media_oembed, key), val)\n        self.assertTrue(media_oembed.thumbnail_url.startswith(\"http\"))\n\n    def test_media_likers(self):\n        media = self.cl.user_medias(self.cl.user_id, amount=3)[-1]\n        self.assertIsInstance(media, Media)\n        likers = self.cl.media_likers(media.pk)\n        self.assertTrue(len(likers) > 0)\n        self.assertIsInstance(likers[0], UserShort)\n\n    def test_media_like_by_pk(self):\n        media_pk = self.cl.media_pk_from_url(\"https://www.instagram.com/p/ByU3LAslgWY/\")\n        self.assertTrue(self.cl.media_like(media_pk))\n\n    def test_media_edit(self):\n        # Upload photo\n        media_pk = self.cl.media_pk_from_url(\"https://www.instagram.com/p/BVDOOolFFxg/\")\n        path = self.cl.photo_download(media_pk)\n        self.assertIsInstance(path, Path)\n        try:\n            msg = \"Test caption for photo\"\n            media = self.cl.photo_upload(path, msg)\n            self.assertIsInstance(media, Media)\n            self.assertEqual(media.caption_text, msg)\n            # Change caption\n            msg = \"New caption %s\" % random.randint(1, 100)\n            self.cl.media_edit(media.pk, msg)\n            media = self.cl.media_info(media.pk)\n            self.assertIsInstance(media, Media)\n            self.assertEqual(media.caption_text, msg)\n            self.assertTrue(self.cl.media_delete(media.pk))\n        finally:\n            cleanup(path)\n\n    def test_media_edit_igtv(self):\n        media_pk = self.cl.media_pk_from_url(\n            \"https://www.instagram.com/tv/B91gKCcpnTk/\"\n        )\n        path = self.cl.igtv_download(media_pk)\n        self.assertIsInstance(path, Path)\n        try:\n            media = self.cl.igtv_upload(path, \"Test title\", \"Test caption for IGTV\")\n            self.assertIsInstance(media, Media)\n            # Enter title\n            title = \"Title %s\" % random.randint(1, 100)\n            msg = \"New caption %s\" % random.randint(1, 100)\n            self.cl.media_edit(media.pk, msg, title)\n            media = self.cl.media_info(media.pk)\n            self.assertIsInstance(media, Media)\n            self.assertEqual(media.title, title)\n            self.assertEqual(media.caption_text, msg)\n            # Split caption to title and caption\n            title = \"Title %s\" % random.randint(1, 100)\n            msg = \"New caption %s\" % random.randint(1, 100)\n            self.cl.media_edit(media.pk, f\"{title}\\n{msg}\")\n            media = self.cl.media_info(media.pk)\n            self.assertIsInstance(media, Media)\n            self.assertEqual(media.title, title)\n            self.assertEqual(media.caption_text, msg)\n            # Empty title (duplicate one-line caption)\n            msg = \"New caption %s\" % random.randint(1, 100)\n            self.cl.media_edit(media.pk, msg, \"\")\n            media = self.cl.media_info(media.pk)\n            self.assertIsInstance(media, Media)\n            self.assertEqual(media.title, msg)\n            self.assertEqual(media.caption_text, msg)\n            self.assertTrue(self.cl.media_delete(media.id))\n        finally:\n            cleanup(path)\n\n    def test_media_like_and_unlike(self):\n        media_pk = self.cl.media_pk_from_url(\"https://www.instagram.com/p/B3mr1-OlWMG/\")\n        self.assertTrue(self.cl.media_unlike(media_pk))\n        media = self.cl.media_info_v1(media_pk)\n        like_count = int(media.like_count)\n        # like\n        self.assertTrue(self.cl.media_like(media.id))\n        media = self.cl.media_info_v1(media_pk)  # refresh after like\n        new_like_count = int(media.like_count)\n        self.assertEqual(new_like_count, like_count + 1)\n        # unlike\n        self.assertTrue(self.cl.media_unlike(media.id))\n        media = self.cl.media_info_v1(media_pk)  # refresh after unlike\n        self.assertEqual(media.like_count, like_count)\n\n\nclass ClientCommentTestCase(ClientPrivateTestCase):\n    def test_media_comments_amount(self):\n        comments = self.cl.media_comments_v1(2154602296692269830, amount=2)\n        self.assertTrue(len(comments) == 2)\n        comments = self.cl.media_comments_v1(2154602296692269830, amount=0)\n        self.assertTrue(len(comments) > 2)\n\n    def test_media_comments(self):\n        comments = self.cl.media_comments_v1(2154602296692269830)\n        self.assertTrue(len(comments) > 5)\n        comment = comments[0]\n        self.assertIsInstance(comment, Comment)\n        comment_fields = comment.__fields__.keys()\n        user_fields = comment.user.__fields__.keys()\n        for field in [\"pk\", \"text\", \"created_at_utc\", \"content_type\", \"status\", \"user\"]:\n            self.assertIn(field, comment_fields)\n        for field in [\n            \"pk\",\n            \"username\",\n            \"full_name\",\n            \"profile_pic_url\",\n        ]:\n            self.assertIn(field, user_fields)\n\n\nclass ClientCommentExtendTestCase(ClientPrivateTestCase):\n    def test_media_comment(self):\n        text = \"Test text [%s]\" % datetime.now().strftime(\"%s\")\n        now = datetime.now(tz=UTC())\n        comment = self.cl.media_comment_v1(2276404890775267248, text)\n        self.assertIsInstance(comment, Comment)\n        comment = comment.dict()\n        for key, val in {\n            \"text\": text,\n            \"content_type\": \"comment\",\n            \"status\": \"Active\",\n        }.items():\n            self.assertEqual(comment[key], val)\n        self.assertIn(\"pk\", comment)\n        # The comment was written no more than 120 seconds ago\n        self.assertTrue(abs((now - comment[\"created_at_utc\"]).total_seconds()) <= 120)\n        user_fields = comment[\"user\"].keys()\n        for field in [\"pk\", \"username\", \"full_name\", \"profile_pic_url\"]:\n            self.assertIn(field, user_fields)\n\n    def test_comment_like_and_unlike(self):\n        media_pk = self.cl.media_pk_from_url(\"https://www.instagram.com/p/B3mr1-OlWMG/\")\n        comment = self.cl.media_comments_v1(media_pk)[0]\n        if comment.has_liked:\n            self.assertTrue(self.cl.comment_unlike(comment.pk))\n        like_count = int(comment.like_count)\n        # like\n        self.assertTrue(self.cl.comment_like(comment.pk))\n        comment = self.cl.media_comments(media_pk)[0]\n        new_like_count = int(comment.like_count)\n        self.assertEqual(new_like_count, like_count + 1)\n        # unlike\n        self.assertTrue(self.cl.comment_unlike(comment.pk))\n        comment = self.cl.media_comments(media_pk)[0]\n        self.assertEqual(comment.like_count, like_count)\n\n\nclass ClientCompareExtractTestCase(ClientPrivateTestCase):\n    def assertLocation(self, v1, gql):\n        if not isinstance(v1, dict):\n            return self.assertEqual(v1, gql)\n        for key, val in v1.items():\n            if key == \"external_id\":\n                continue  # id may differ\n            gql_val = gql[key]\n            if isinstance(val, float):\n                val, gql_val = round(val, 4), round(gql_val, 4)\n            self.assertEqual(val, gql_val)\n\n    def assertMedia(self, v1, gql):\n        self.assertTrue(v1.pop(\"comment_count\") <= gql.pop(\"comment_count\"))\n        self.assertLocation(v1.pop(\"location\"), gql.pop(\"location\"))\n        v1.pop(\"has_liked\")\n        gql.pop(\"has_liked\")\n        self.assertDictEqual(v1, gql)\n\n    def media_info(self, media_pk):\n        media_v1 = self.cl.media_info_v1(media_pk)\n        self.assertIsInstance(media_v1, Media)\n        media_gql = self.cl.media_info_gql(media_pk)\n        self.assertIsInstance(media_gql, Media)\n        return media_v1.dict(), media_gql.dict()\n\n    def test_two_extract_media_photo(self):\n        media_v1, media_gql = self.media_info(self.cl.media_pk_from_code(\"B3mr1-OlWMG\"))\n        self.assertTrue(media_v1.pop(\"thumbnail_url\").startswith(\"https://\"))\n        self.assertTrue(media_gql.pop(\"thumbnail_url\").startswith(\"https://\"))\n        self.assertMedia(media_v1, media_gql)\n\n    def test_two_extract_media_video(self):\n        media_v1, media_gql = self.media_info(self.cl.media_pk_from_code(\"B3rFQPblq40\"))\n        self.assertTrue(media_v1.pop(\"video_url\").startswith(\"https://\"))\n        self.assertTrue(media_gql.pop(\"video_url\").startswith(\"https://\"))\n        self.assertTrue(media_v1.pop(\"thumbnail_url\").startswith(\"https://\"))\n        self.assertTrue(media_gql.pop(\"thumbnail_url\").startswith(\"https://\"))\n        self.assertMedia(media_v1, media_gql)\n\n    def test_two_extract_media_album(self):\n        media_v1, media_gql = self.media_info(self.cl.media_pk_from_code(\"BjNLpA1AhXM\"))\n        for res in media_v1[\"resources\"]:\n            self.assertTrue(res.pop(\"thumbnail_url\").startswith(\"https://\"))\n            if res[\"media_type\"] == 2:\n                self.assertTrue(res.pop(\"video_url\").startswith(\"https://\"))\n        for res in media_gql[\"resources\"]:\n            self.assertTrue(res.pop(\"thumbnail_url\").startswith(\"https://\"))\n            if res[\"media_type\"] == 2:\n                self.assertTrue(res.pop(\"video_url\").startswith(\"https://\"))\n        self.assertMedia(media_v1, media_gql)\n\n    def test_two_extract_media_igtv(self):\n        media_v1, media_gql = self.media_info(self.cl.media_pk_from_code(\"ByYn5ZNlHWf\"))\n        self.assertTrue(media_v1.pop(\"video_url\").startswith(\"https://\"))\n        self.assertTrue(media_gql.pop(\"video_url\").startswith(\"https://\"))\n        self.assertTrue(media_v1.pop(\"thumbnail_url\").startswith(\"https://\"))\n        self.assertTrue(media_gql.pop(\"thumbnail_url\").startswith(\"https://\"))\n        self.assertMedia(media_v1, media_gql)\n\n    def test_two_extract_user(self):\n        user_v1 = self.cl.user_info_v1(25025320)\n        user_gql = self.cl.user_info_gql(25025320)\n        self.assertIsInstance(user_v1, User)\n        self.assertIsInstance(user_gql, User)\n        user_v1, user_gql = user_v1.dict(), user_gql.dict()\n        self.assertTrue(user_v1.pop(\"profile_pic_url\").startswith(\"https://\"))\n        self.assertTrue(user_gql.pop(\"profile_pic_url\").startswith(\"https://\"))\n        self.assertDictEqual(user_v1, user_gql)\n\n\nclass ClientExtractTestCase(ClientPrivateTestCase):\n    def test_extract_media_photo(self):\n        media_pk = self.cl.media_pk_from_url(\"https://www.instagram.com/p/B3mr1-OlWMG/\")\n        media = self.cl.media_info(media_pk)\n        self.assertIsInstance(media, Media)\n        self.assertTrue(len(media.resources) == 0)\n        self.assertTrue(media.comment_count > 5)\n        self.assertTrue(media.like_count > 80)\n        for key, val in {\n            \"caption_text\": \"В гостях у ДК @delai_krasivo_kaifui\",\n            \"thumbnail_url\": \"https://\",\n            \"pk\": \"2154602296692269830\",\n            \"code\": \"B3mr1-OlWMG\",\n            \"media_type\": 1,\n            \"taken_at\": datetime(2019, 10, 14, 15, 57, 10, tzinfo=UTC()),\n        }.items():\n            if isinstance(val, str):\n                self.assertTrue(getattr(media, key).startswith(val))\n            else:\n                self.assertEqual(getattr(media, key), val)\n        for key, val in {\"pk\": \"25025320\", \"username\": \"instagram\"}.items():\n            self.assertEqual(getattr(media.user, key), val)\n\n    def test_extract_media_video(self):\n        media_pk = self.cl.media_pk_from_url(\"https://www.instagram.com/p/BgRIGUQFltp/\")\n        media = self.cl.media_info(media_pk)\n        self.assertIsInstance(media, Media)\n        self.assertTrue(len(media.resources) == 0)\n        self.assertTrue(media.view_count > 150)\n        self.assertTrue(media.comment_count > 1)\n        self.assertTrue(media.like_count > 40)\n        for key, val in {\n            \"caption_text\": \"Веселья ради\\n\\n@milashensky #dowhill #skateboarding #foros #crimea\",\n            \"pk\": 1734202949948037993,\n            \"code\": \"BgRIGUQFltp\",\n            \"video_url\": \"https://\",\n            \"thumbnail_url\": \"https://\",\n            \"media_type\": 2,\n            \"taken_at\": datetime(2018, 3, 13, 14, 59, 23, tzinfo=UTC()),\n        }.items():\n            if isinstance(val, str):\n                self.assertTrue(getattr(media, key).startswith(val))\n            else:\n                self.assertEqual(getattr(media, key), val)\n        for key, val in {\"pk\": \"25025320\", \"username\": \"instagram\"}.items():\n            self.assertEqual(getattr(media.user, key), val)\n\n    def test_extract_media_album(self):\n        media_pk = self.cl.media_pk_from_url(\"https://www.instagram.com/p/BjNLpA1AhXM/\")\n        media = self.cl.media_info(media_pk)\n        self.assertIsInstance(media, Media)\n        self.assertTrue(len(media.resources) == 3)\n        video_resource = media.resources[0]\n        photo_resource = media.resources.pop()\n        self.assertTrue(media.view_count == 0)\n        self.assertTrue(media.comment_count == 0)\n        self.assertTrue(media.like_count > 40)\n        for key, val in {\n            \"caption_text\": \"@mind__flowers в Форосе под дождём, 24 мая 2018 #downhill \"\n            \"#skateboarding #downhillskateboarding #crimea #foros #rememberwheels\",\n            \"pk\": 1787135824035452364,\n            \"code\": \"BjNLpA1AhXM\",\n            \"media_type\": 8,\n            \"taken_at\": datetime(2018, 5, 25, 15, 46, 53, tzinfo=UTC()),\n            \"product_type\": \"\",\n        }.items():\n            self.assertEqual(getattr(media, key), val)\n        for key, val in {\"pk\": \"25025320\", \"username\": \"instagram\"}.items():\n            self.assertEqual(getattr(media.user, key), val)\n        for key, val in {\n            \"video_url\": \"https://\",\n            \"thumbnail_url\": \"https://\",\n            \"media_type\": 2,\n            \"pk\": 1787135361353462176,\n        }.items():\n            if isinstance(val, str):\n                self.assertTrue(getattr(video_resource, key).startswith(val))\n            else:\n                self.assertEqual(getattr(video_resource, key), val)\n        for key, val in {\n            \"video_url\": None,\n            \"thumbnail_url\": \"https://\",\n            \"media_type\": 1,\n            \"pk\": 1787133803186894424,\n        }.items():\n            if isinstance(val, str):\n                self.assertTrue(getattr(photo_resource, key).startswith(val))\n            else:\n                self.assertEqual(getattr(photo_resource, key), val)\n\n    def test_extract_media_igtv(self):\n        media_pk = self.cl.media_pk_from_url(\n            \"https://www.instagram.com/tv/ByYn5ZNlHWf/\"\n        )\n        media = self.cl.media_info(media_pk)\n        self.assertIsInstance(media, Media)\n        self.assertTrue(len(media.resources) == 0)\n        self.assertTrue(media.view_count > 200)\n        self.assertTrue(media.comment_count > 10)\n        self.assertTrue(media.like_count > 50)\n        for key, val in {\n            \"title\": \"zr trip, crimea, feb 2017. Edit by @milashensky\",\n            \"caption_text\": \"Нашёл на диске неопубликованное в инсте произведение @milashensky\",\n            \"pk\": 2060572297417487775,\n            \"video_url\": \"https://\",\n            \"thumbnail_url\": \"https://\",\n            \"code\": \"ByYn5ZNlHWf\",\n            \"media_type\": 2,\n            \"taken_at\": datetime(2019, 6, 6, 22, 22, 6, tzinfo=UTC()),\n            \"product_type\": \"igtv\",\n        }.items():\n            if isinstance(val, str):\n                self.assertTrue(getattr(media, key).startswith(val))\n            else:\n                self.assertEqual(getattr(media, key), val)\n        for key, val in {\"pk\": \"25025320\", \"username\": \"instagram\"}.items():\n            self.assertEqual(getattr(media.user, key), val)\n\n\nclass ClienUploadTestCase(ClientPrivateTestCase):\n    def get_location(self):\n        location = self.cl.location_search(lat=59.939095, lng=30.315868)[0]\n        self.assertIsInstance(location, Location)\n        return location\n\n    def assertLocation(self, location):\n        # Instagram sometimes changes location by GEO coordinates:\n        locations = [\n            dict(\n                pk=213597007,\n                name=\"Palace Square\",\n                lat=59.939166666667,\n                lng=30.315833333333,\n            ),\n            dict(\n                pk=107617247320879,\n                name=\"Russia, Saint-Petersburg\",\n                address=\"Russia, Saint-Petersburg\",\n                lat=59.93318,\n                lng=30.30605,\n                external_id=107617247320879,\n                external_id_source=\"facebook_places\",\n            ),\n        ]\n        for data in locations:\n            if data[\"pk\"] == location.pk:\n                break\n        for key, val in data.items():\n            itm = getattr(location, key)\n            if isinstance(val, float):\n                val = round(val, 2)\n                itm = round(itm, 2)\n            self.assertEqual(itm, val)\n\n    def test_photo_upload_without_location(self):\n        media_pk = self.cl.media_pk_from_url(\"https://www.instagram.com/p/BVDOOolFFxg/\")\n        path = self.cl.photo_download(media_pk)\n        self.assertIsInstance(path, Path)\n        try:\n            media = self.cl.photo_upload(path, \"Test caption for photo\")\n            self.assertIsInstance(media, Media)\n            self.assertEqual(media.caption_text, \"Test caption for photo\")\n            self.assertFalse(media.location)\n        finally:\n            cleanup(path)\n            self.assertTrue(self.cl.media_delete(media.id))\n\n    def test_photo_upload(self):\n        media_pk = self.cl.media_pk_from_url(\"https://www.instagram.com/p/BVDOOolFFxg/\")\n        path = self.cl.photo_download(media_pk)\n        self.assertIsInstance(path, Path)\n        try:\n            media = self.cl.photo_upload(\n                path, \"Test caption for photo\", location=self.get_location()\n            )\n            self.assertIsInstance(media, Media)\n            self.assertEqual(media.caption_text, \"Test caption for photo\")\n            self.assertLocation(media.location)\n        finally:\n            cleanup(path)\n            self.assertTrue(self.cl.media_delete(media.id))\n\n    def test_video_upload(self):\n        media_pk = self.cl.media_pk_from_url(\"https://www.instagram.com/p/Bk2tOgogq9V/\")\n        path = self.cl.video_download(media_pk)\n        self.assertIsInstance(path, Path)\n        try:\n            media = self.cl.video_upload(\n                path, \"Test caption for video\", location=self.get_location()\n            )\n            self.assertIsInstance(media, Media)\n            self.assertEqual(media.caption_text, \"Test caption for video\")\n            self.assertLocation(media.location)\n        finally:\n            cleanup(path)\n            self.assertTrue(self.cl.media_delete(media.id))\n\n    def test_album_upload(self):\n        media_pk = self.cl.media_pk_from_url(\"https://www.instagram.com/p/BjNLpA1AhXM/\")\n        paths = self.cl.album_download(media_pk)\n        [self.assertIsInstance(path, Path) for path in paths]\n        try:\n            instagram = self.user_info_by_username(\"instagram\")\n            usertag = Usertag(user=instagram, x=0.5, y=0.5)\n            location = self.get_location()\n            media = self.cl.album_upload(\n                paths, \"Test caption for album\", usertags=[usertag], location=location\n            )\n            self.assertIsInstance(media, Media)\n            self.assertEqual(media.caption_text, \"Test caption for album\")\n            self.assertEqual(len(media.resources), 3)\n            self.assertLocation(media.location)\n            keep_path(media.usertags[0].user)\n            keep_path(usertag.user)\n            self.assertEqual(media.usertags, [usertag])\n        finally:\n            cleanup(*paths)\n            self.assertTrue(self.cl.media_delete(media.id))\n\n    def test_igtv_upload(self):\n        media_pk = self.cl.media_pk_from_url(\n            \"https://www.instagram.com/tv/B91gKCcpnTk/\"\n        )\n        path = self.cl.igtv_download(media_pk)\n        self.assertIsInstance(path, Path)\n        try:\n            title = \"6/6: The Transceiver Failure\"\n            caption_text = \"Test caption for IGTV\"\n            media = self.cl.igtv_upload(\n                path, title, caption_text, location=self.get_location()\n            )\n            self.assertIsInstance(media, Media)\n            self.assertEqual(media.title, title)\n            self.assertEqual(media.caption_text, caption_text)\n            self.assertLocation(media.location)\n        finally:\n            cleanup(path)\n            self.assertTrue(self.cl.media_delete(media.id))\n\n    def test_clip_upload(self):\n        # media_type: 2 (video, not IGTV)\n        # product_type: clips\n        media_pk = self.cl.media_pk_from_url(\"https://www.instagram.com/p/CEjXskWJ1on/\")\n        path = self.cl.clip_download(media_pk)\n        self.assertIsInstance(path, Path)\n        try:\n            # location = self.get_location()\n            caption_text = \"Upload clip\"\n            media = self.cl.clip_upload(\n                path,\n                caption_text,\n                # location=location\n            )\n            self.assertIsInstance(media, Media)\n            self.assertEqual(media.caption_text, caption_text)\n            # self.assertLocation(media.location)\n        finally:\n            cleanup(path)\n            self.assertTrue(self.cl.media_delete(media.id))\n\n    def test_reel_upload_with_music(self):\n        # media_type: 2 (video, not IGTV)\n        # product_type: reels\n\n        media_pk = self.cl.media_pk_from_url(\"https://www.instagram.com/p/CEjXskWJ1on/\")\n        path = self.cl.clip_download(media_pk)\n        self.assertIsInstance(path, Path)\n        try:\n            title = \"Kill My Vibe (feat. Tom G)\"\n            caption = \"Test caption for reel\"\n            track = self.cl.search_music(title)[0]\n            media = self.cl.clip_upload_as_reel_with_music(path, caption, track)\n            self.assertIsInstance(media, Media)\n            self.assertEqual(media.caption_text, caption)\n        finally:\n            cleanup(path)\n            self.assertTrue(self.cl.media_delete(media.id))\n\n\nclass ClientCollectionTestCase(ClientPrivateTestCase):\n    def test_collections(self):\n        collections = self.cl.collections()\n        self.assertTrue(len(collections) > 0)\n        collection = collections[0]\n        self.assertIsInstance(collection, Collection)\n        for field in (\"id\", \"name\", \"type\", \"media_count\"):\n            self.assertTrue(hasattr(collection, field))\n\n    def test_collection_medias_by_name(self):\n        medias = self.cl.collection_medias_by_name(\"Repost\")\n        self.assertTrue(len(medias) > 0)\n        media = medias[0]\n        self.assertIsInstance(media, Media)\n        for field in REQUIRED_MEDIA_FIELDS:\n            self.assertTrue(hasattr(media, field))\n\n    def test_media_save_to_collection(self):\n        media_pk = self.cl.media_pk_from_url(\"https://www.instagram.com/p/B3mr1-OlWMG/\")\n        collection_pk = self.cl.collection_pk_by_name(\"Repost\")\n        # clear and check\n        self.cl.media_unsave(media_pk)\n        medias = self.cl.collection_medias(collection_pk)\n        self.assertNotIn(media_pk, [m.pk for m in medias])\n        # save\n        self.cl.media_save(media_pk, collection_pk)\n        medias = self.cl.collection_medias(collection_pk)\n        self.assertIn(media_pk, [m.pk for m in medias])\n        # unsave\n        self.cl.media_unsave(media_pk, collection_pk)\n        medias = self.cl.collection_medias(collection_pk)\n        self.assertNotIn(media_pk, [m.pk for m in medias])\n\n\nclass ClientDirectTestCase(ClientPrivateTestCase):\n    def test_direct_thread(self):\n        # threads\n        threads = self.cl.direct_threads()\n        self.assertTrue(len(threads) > 0)\n        thread = threads[0]\n        self.assertIsInstance(thread, DirectThread)\n        # messages\n        messages = self.cl.direct_messages(thread.id, 2)\n        self.assertTrue(3 > len(messages) > 0)\n        # self.assertTrue(thread.is_seen(self.cl.user_id))\n        message = messages[0]\n        self.assertIsInstance(message, DirectMessage)\n        instagram = self.user_id_from_username(\"instagram\")\n        ping = self.cl.direct_send(\"Ping\", user_ids=[instagram])\n        self.assertIsInstance(ping, DirectMessage)\n        pong = self.cl.direct_answer(ping.thread_id, \"Pong\")\n        self.assertIsInstance(pong, DirectMessage)\n        self.assertEqual(ping.thread_id, pong.thread_id)\n        # send direct photo\n        photo = self.cl.direct_send_photo(\n            path=\"examples/kanada.jpg\", user_ids=[instagram]\n        )\n        self.assertIsInstance(photo, DirectMessage)\n        self.assertEqual(photo.thread_id, pong.thread_id)\n        # send seen\n        seen = self.cl.direct_send_seen(thread_id=thread.id)\n        self.assertEqual(seen.status, \"ok\")\n        # mute and unmute thread\n        self.assertTrue(self.cl.direct_thread_mute(thread.id))\n        self.assertTrue(self.cl.direct_thread_unmute(thread.id))\n        # mute video call and unmute\n        self.assertTrue(self.cl.direct_thread_mute_video_call(thread.id))\n        self.assertTrue(self.cl.direct_thread_unmute_video_call(thread.id))\n\n    def test_direct_send_photo(self):\n        instagram = self.user_id_from_username(\"instagram\")\n        dm = self.cl.direct_send_photo(path=\"examples/kanada.jpg\", user_ids=[instagram])\n        self.assertIsInstance(dm, DirectMessage)\n\n    def test_direct_send_video(self):\n        instagram = self.user_id_from_username(\"instagram\")\n        path = self.cl.video_download(\n            self.cl.media_pk_from_url(\"https://www.instagram.com/p/B3rFQPblq40/\")\n        )\n        dm = self.cl.direct_send_video(path=path, user_ids=[instagram])\n        self.assertIsInstance(dm, DirectMessage)\n\n    def test_direct_thread_by_participants(self):\n        try:\n            self.cl.direct_thread_by_participants([12345])\n        except DirectThreadNotFound:\n            pass\n\n\nclass ClientAccountTestCase(ClientPrivateTestCase):\n    def test_account_edit(self):\n        # current\n        one = self.cl.user_info(self.cl.user_id)\n        self.assertIsInstance(one, User)\n        # change\n        url = \"https://trotiq.com/\"\n        two = self.cl.account_edit(external_url=url)\n        self.assertIsInstance(two, Account)\n        self.assertEqual(str(two.external_url), url)\n        # return back\n        three = self.cl.account_edit(external_url=one.external_url)\n        self.assertIsInstance(three, Account)\n        self.assertEqual(one.external_url, three.external_url)\n\n    def test_account_change_picture(self):\n        # current\n        one = self.cl.user_info(self.cl.user_id)\n        self.assertIsInstance(one, User)\n        instagram = self.user_info_by_username(\"instagram\")\n        # change\n        two = self.cl.account_change_picture(\n            self.cl.photo_download_by_url(instagram.profile_pic_url)\n        )\n        self.assertIsInstance(two, UserShort)\n        # return back\n        three = self.cl.account_change_picture(\n            self.cl.photo_download_by_url(one.profile_pic_url)\n        )\n        self.assertIsInstance(three, UserShort)\n\n\nclass ClientLocationTestCase(ClientPrivateTestCase):\n    def test_location_search(self):\n        loc = self.cl.location_search(51.0536111111, 13.8108333333)[0]\n        self.assertIsInstance(loc, Location)\n        self.assertIn(\"Dresden\", loc.name)\n        self.assertIn(\"Dresden\", loc.address)\n        self.assertEqual(150300262230285, loc.external_id)\n        self.assertEqual(\"facebook_places\", loc.external_id_source)\n\n    def test_location_complete_pk(self):\n        source = Location(\n            name=\"Daily Surf Supply\",\n            external_id=533689780360041,\n            external_id_source=\"facebook_places\",\n        )\n        result = self.cl.location_complete(source)\n        self.assertIsInstance(result, Location)\n        self.assertEqual(result.pk, 533689780360041)\n\n    def test_location_complete_lat_lng(self):\n        source = Location(\n            pk=150300262230285,\n            name=\"Blaues Wunder (Dresden)\",\n        )\n        result = self.cl.location_complete(source)\n        self.assertIsInstance(result, Location)\n        self.assertEqual(result.lat, 51.0536111111)\n        self.assertEqual(result.lng, 13.8108333333)\n\n    def test_location_complete_external_id(self):\n        source = Location(\n            name=\"Blaues Wunder (Dresden)\", lat=51.0536111111, lng=13.8108333333\n        )\n        result = self.cl.location_complete(source)\n        self.assertIsInstance(result, Location)\n        self.assertEqual(result.external_id, 150300262230285)\n        self.assertEqual(result.external_id_source, \"facebook_places\")\n\n    def test_location_build(self):\n        loc = self.cl.location_info(150300262230285)\n        self.assertIsInstance(loc, Location)\n        json_data = self.cl.location_build(loc)\n        self.assertIsInstance(json_data, str)\n        data = json.loads(json_data)\n        self.assertIsInstance(data, dict)\n        self.assertDictEqual(\n            data,\n            {\n                \"name\": \"Blaues Wunder (Dresden)\",\n                \"address\": \"Dresden, Germany\",\n                \"lat\": 51.053611111111,\n                \"lng\": 13.810833333333,\n                \"facebook_places_id\": 150300262230285,\n                \"external_source\": \"facebook_places\",\n            },\n        )\n\n    def test_location_info(self):\n        loc = self.cl.location_info(150300262230285)\n        self.assertIsInstance(loc, Location)\n        self.assertEqual(loc.pk, 150300262230285)\n        self.assertEqual(loc.name, \"Blaues Wunder (Dresden)\")\n        self.assertEqual(loc.lng, 13.8108333333)\n        self.assertEqual(loc.lat, 51.0536111111)\n\n    def test_location_info_without_lat_lng(self):\n        loc = self.cl.location_info(197780767581661)\n        self.assertIsInstance(loc, Location)\n        self.assertEqual(loc.pk, 197780767581661)\n        self.assertEqual(loc.name, \"In The Clouds\")\n\n    def test_location_medias_top(self):\n        medias = self.cl.location_medias_top(197780767581661, amount=2)\n        self.assertEqual(len(medias), 2)\n        self.assertIsInstance(medias[0], Media)\n\n    # def test_extract_location_medias_top(self):\n    #     medias_a1 = self.cl.location_medias_top_a1(197780767581661, amount=9)\n    #     medias_v1 = self.cl.location_medias_top_v1(197780767581661, amount=9)\n    #     self.assertEqual(len(medias_a1), 9)\n    #     self.assertIsInstance(medias_a1[0], Media)\n    #     self.assertEqual(len(medias_v1), 9)\n    #     self.assertIsInstance(medias_v1[0], Media)\n\n    def test_location_medias_recent(self):\n        medias = self.cl.location_medias_recent(197780767581661, amount=2)\n        self.assertEqual(len(medias), 2)\n        self.assertIsInstance(medias[0], Media)\n\n\nclass SignUpTestCase(unittest.TestCase):\n\n    def test_password_enrypt(self):\n        cl = Client()\n        enc_password = cl.password_encrypt('test')\n        parts = enc_password.split(':')\n        self.assertEqual(parts[0], '#PWD_INSTAGRAM')\n        self.assertEqual(parts[1], '4')\n        self.assertTrue(int(parts[2]) > 1607612345)\n        self.assertTrue(len(parts[3]) == 392)\n\n    def test_signup(self):\n        cl = Client()\n        username = gen_password()\n        password = gen_password(12, symbols=True)\n        email = f'{username}@gmail.com'\n        phone_number = os.environ.get(\"IG_PHONE_NUMBER\")\n        full_name = f'John {username}'\n        user = cl.signup(\n            username, password, email, phone_number, full_name,\n            year=random.randint(1980, 1990),\n            month=random.randint(1, 12),\n            day=random.randint(1, 30)\n        )\n        self.assertIsInstance(user, UserShort)\n        for key, val in {\n            \"username\": username,\n            \"full_name\": full_name\n        }.items():\n            self.assertEqual(getattr(user, key), val)\n        self.assertTrue(user.profile_pic_url.startswith(\"https://\"))\n\n\nclass ClientHashtagTestCase(ClientPrivateTestCase):\n    REQUIRED_MEDIA_FIELDS = [\n        \"pk\",\n        \"taken_at\",\n        \"id\",\n        \"media_type\",\n        \"code\",\n        \"thumbnail_url\",\n        \"like_count\",\n        \"caption_text\",\n        \"video_url\",\n        \"view_count\",\n        \"video_duration\",\n        \"title\",\n    ]\n\n    def test_hashtag_info(self):\n        hashtag = self.cl.hashtag_info(\"instagram\")\n        self.assertIsInstance(hashtag, Hashtag)\n        self.assertEqual(\"instagram\", hashtag.name)\n\n    def test_extract_hashtag_info(self):\n        hashtag_a1 = self.cl.hashtag_info_a1(\"instagram\")\n        hashtag_v1 = self.cl.hashtag_info_v1(\"instagram\")\n        self.assertIsInstance(hashtag_a1, Hashtag)\n        self.assertIsInstance(hashtag_v1, Hashtag)\n        self.assertEqual(\"instagram\", hashtag_a1.name)\n        self.assertEqual(hashtag_a1.id, hashtag_v1.id)\n        self.assertEqual(hashtag_a1.name, hashtag_v1.name)\n        self.assertEqual(hashtag_a1.media_count, hashtag_v1.media_count)\n\n    def test_hashtag_medias_top(self):\n        medias = self.cl.hashtag_medias_top(\"instagram\", amount=2)\n        self.assertEqual(len(medias), 2)\n        self.assertIsInstance(medias[0], Media)\n\n    def test_extract_hashtag_medias_top(self):\n        medias_a1 = self.cl.hashtag_medias_top_a1(\"instagram\", amount=9)\n        medias_v1 = self.cl.hashtag_medias_top_v1(\"instagram\", amount=9)\n        self.assertEqual(len(medias_a1), 9)\n        self.assertIsInstance(medias_a1[0], Media)\n        self.assertEqual(len(medias_v1), 9)\n        self.assertIsInstance(medias_v1[0], Media)\n\n    def test_hashtag_medias_recent(self):\n        medias = self.cl.hashtag_medias_recent(\"instagram\", amount=2)\n        self.assertEqual(len(medias), 2)\n        self.assertIsInstance(medias[0], Media)\n\n    def test_extract_hashtag_medias_recent(self):\n        medias_v1 = self.cl.hashtag_medias_recent_v1(\"instagram\", amount=31)\n        medias_a1 = self.cl.hashtag_medias_recent_a1(\"instagram\", amount=31)\n        self.assertEqual(len(medias_a1), 31)\n        self.assertIsInstance(medias_a1[0], Media)\n        self.assertEqual(len(medias_v1), 31)\n        self.assertIsInstance(medias_v1[0], Media)\n        for i, a1 in enumerate(medias_a1[:10]):\n            a1 = a1.dict()\n            v1 = medias_v1[i].dict()\n            for f in self.REQUIRED_MEDIA_FIELDS:\n                a1_val, v1_val = a1[f], v1[f]\n                is_album = a1[\"media_type\"] == 8\n                is_video = v1.get(\"video_duration\") > 0\n                if f == \"thumbnail_url\" and not is_album:\n                    a1_val = a1[f].path.rsplit(\"/\", 1)[1]\n                    v1_val = v1[f].path.rsplit(\"/\", 1)[1]\n                if f == \"video_url\" and is_video:\n                    a1_val = a1[f].path.rsplit(\".\", 1)[1]\n                    v1_val = v1[f].path.rsplit(\".\", 1)[1]\n                if f in (\"view_count\", \"like_count\"):\n                    # instagram can different counts for public and private\n                    if f == \"view_count\" and not is_video:\n                        continue\n                    self.assertTrue(a1_val > 1)\n                    self.assertTrue(v1_val > 1)\n                    continue\n                self.assertEqual(a1_val, v1_val)\n\n\nclass ClientStoryTestCase(ClientPrivateTestCase):\n    def test_story_pk_from_url(self):\n        story_pk = self.cl.story_pk_from_url(\n            \"https://www.instagram.com/stories/instagram/2581281926631793076/\"\n        )\n        self.assertEqual(story_pk, 2581281926631793076)\n\n    def test_upload_photo_story(self):\n        media_pk = self.cl.media_pk_from_url(\"https://www.instagram.com/p/B3mr1-OlWMG/\")\n        path = self.cl.photo_download(media_pk)\n        self.assertIsInstance(path, Path)\n        caption = \"Test photo caption\"\n        instagram = self.user_info_by_username(\"instagram\")\n        self.assertIsInstance(instagram, User)\n        mentions = [StoryMention(user=instagram)]\n        medias = [StoryMedia(media_pk=media_pk, x=0.5, y=0.5, width=0.6, height=0.8)]\n        links = [StoryLink(webUri=\"https://instagram.com/\")]\n        # hashtags = [StoryHashtag(hashtag=self.cl.hashtag_info('instagram'))]\n        # locations = [\n        #     StoryLocation(\n        #         location=Location(\n        #             pk=150300262230285,\n        #             name='Blaues Wunder (Dresden)',\n        #         )\n        #     )\n        # ]\n        stickers = [\n            StorySticker(\n                id=\"Igjf05J559JWuef4N5\",\n                type=\"gif\",\n                x=0.5,\n                y=0.5,\n                width=0.4,\n                height=0.08,\n            )\n        ]\n        try:\n            story = self.cl.photo_upload_to_story(\n                path,\n                caption,\n                mentions=mentions,\n                links=links,\n                # hashtags=hashtags,\n                # locations=locations,\n                stickers=stickers,\n                medias=medias,\n            )\n            self.assertIsInstance(story, Story)\n            self.assertTrue(story)\n            s = self.cl.story_info(story.pk)\n            self.assertIsInstance(s, Story)\n            self.assertTrue(s)\n            m, sm = medias[0], s.medias[0]\n            self.assertEqual(m.media_pk, sm.media_pk)\n            self.assertEqual(m.x, sm.x)\n            self.assertEqual(m.y, sm.y)\n        finally:\n            if path:\n                cleanup(path)\n            self.assertTrue(self.cl.story_delete(story.id))\n\n    def test_upload_video_story(self):\n        media_pk = self.cl.media_pk_from_url(\"https://www.instagram.com/p/Bk2tOgogq9V/\")\n        story = None\n        path = self.cl.video_download(media_pk)\n        self.assertIsInstance(path, Path)\n        caption = \"Test video caption\"\n        instagram = self.user_info_by_username(\"instagram\")\n        self.assertIsInstance(instagram, User)\n        mentions = [StoryMention(user=instagram)]\n        medias = [StoryMedia(media_pk=media_pk, x=0.5, y=0.5, width=0.6, height=0.8)]\n        links = [StoryLink(webUri=\"https://instagram.com/\")]\n        # hashtags = [StoryHashtag(hashtag=self.cl.hashtag_info('instagram'))]\n        # locations = [\n        #     StoryLocation(\n        #         location=Location(\n        #             pk=150300262230285,\n        #             name='Blaues Wunder (Dresden)',\n        #         )\n        #     )\n        # ]\n        try:\n            buildout = StoryBuilder(\n                path, caption, mentions, Path(\"./examples/background.png\")\n            ).video(1)\n            story = self.cl.video_upload_to_story(\n                buildout.path,\n                caption,\n                mentions=buildout.mentions,\n                links=links,\n                # hashtags=hashtags,\n                # locations=locations,\n                medias=medias,\n            )\n            self.assertIsInstance(story, Story)\n            self.assertTrue(story)\n            s = self.cl.story_info(story.pk)\n            self.assertIsInstance(s, Story)\n            self.assertTrue(s)\n            m, sm = medias[0], s.medias[0]\n            self.assertEqual(m.media_pk, sm.media_pk)\n            self.assertEqual(m.x, sm.x)\n            self.assertEqual(m.y, sm.y)\n        finally:\n            cleanup(path)\n            if story:\n                self.assertTrue(self.cl.story_delete(story.id))\n\n    def test_user_stories(self):\n        user_id = self.user_id_from_username(\"instagram\")\n        stories = self.cl.user_stories(user_id, 2)\n        self.assertEqual(len(stories), 2)\n        story = stories[0]\n        self.assertIsInstance(story, Story)\n        for field in REQUIRED_STORY_FIELDS:\n            self.assertTrue(hasattr(story, field))\n        stories = self.cl.user_stories(self.user_id_from_username(\"instagram\"))\n        self.assertIsInstance(stories, list)\n\n    def test_extract_user_stories(self):\n        user_id = self.user_id_from_username(\"instagram\")\n        stories_v1 = self.cl.user_stories_v1(user_id, amount=2)\n        stories_gql = self.cl.user_stories_gql(user_id, amount=2)\n        self.assertEqual(len(stories_v1), 2)\n        self.assertIsInstance(stories_v1[0], Story)\n        self.assertEqual(len(stories_gql), 2)\n        self.assertIsInstance(stories_gql[0], Story)\n        for i, gql in enumerate(stories_gql[:2]):\n            gql = gql.dict()\n            v1 = stories_v1[i].dict()\n            for f in REQUIRED_STORY_FIELDS:\n                gql_val, v1_val = gql[f], v1[f]\n                is_video = v1.get(\"video_duration\") > 0\n                if f == \"video_url\" and is_video:\n                    gql_val = gql[f].path.rsplit(\".\", 1)[1]\n                    v1_val = v1[f].path.rsplit(\".\", 1)[1]\n                elif f == \"thumbnail_url\":\n                    self.assertIn(\".jpg\", gql_val)\n                    self.assertIn(\".jpg\", v1_val)\n                    continue\n                elif f == \"user\":\n                    gql_val.pop(\"full_name\")\n                    v1_val.pop(\"full_name\")\n                    gql_val.pop(\"is_private\")\n                    v1_val.pop(\"is_private\")\n                    gql_val[\"profile_pic_url\"] = gql_val[\"profile_pic_url\"].path\n                    v1_val[\"profile_pic_url\"] = v1_val[\"profile_pic_url\"].path\n                elif f == \"mentions\":\n                    for item in [*gql_val, *v1_val]:\n                        item[\"user\"].pop(\"pk\")\n                        item[\"user\"].pop(\"profile_pic_url\")\n                        item.pop(\"width\")\n                        item.pop(\"height\")\n                        item[\"x\"] = round(item[\"x\"], 4)\n                        item[\"y\"] = round(item[\"y\"], 4)\n                elif f == \"links\":\n                    # [{'webUri': HttpUrl('https://youtu.be/x3GYpar-e64', scheme='https', host='youtu.be', tld='be', host_type='domain', path='/x3GYpar-e64')}]\n                    # [{'webUri': HttpUrl('https://l.instagram.com/?u=https%3A%2F%2Fyoutu.be%2Fx3GYpar-e64&e=ATM59nvUNmptw8vUsyoX835T....}]\n                    self.assertEqual(len(v1_val), len(gql_val))\n                    if gql_val:\n                        self.assertIn(\n                            gql_val[0][\"webUri\"].host, v1_val[0][\"webUri\"].query\n                        )\n                    continue\n                if gql_val != v1_val:\n                    import pudb\n\n                    pudb.set_trace()\n                self.assertEqual(gql_val, v1_val)\n\n    def test_story_info(self):\n        user_id = self.user_id_from_username(\"instagram\")\n        stories = self.cl.user_stories(user_id, amount=1)\n        story = self.cl.story_info(stories[0].pk)\n        self.assertIsInstance(story, Story)\n        story = self.cl.story_info(stories[0].id)\n        self.assertIsInstance(story, Story)\n        self.assertTrue(self.cl.story_seen([story.pk]))\n\n\n# class BloksTestCase(ClientPrivateTestCase):\n#\n#     def test_bloks_change_password(self):\n#         last_json = {\n#             'step_name': 'change_password',\n#             'step_data': {'new_password1': 'None', 'new_password2': 'None'},\n#             'flow_render_type': 3,\n#             'bloks_action': 'com.instagram.challenge.navigation.take_challenge',\n#             'cni': 12346879508000123,\n#             'challenge_context': '{\"step_name\": \"change_password\", \"cni\": 12346879508000123, \"is_stateless\": false, \"challenge_type_enum\": \"PASSWORD_RESET\"}',\n#             'challenge_type_enum_str': 'PASSWORD_RESET',\n#             'status': 'ok'\n#         }\n#        self.assertTrue(self.cl.bloks_change_password(\"2r9j20r9j4230t8hj39tHW4\"))\n\n\nclass TOTPTestCase(ClientPrivateTestCase):\n    def test_totp_code(self):\n        seed = self.cl.totp_generate_seed()\n        code = self.cl.totp_generate_code(seed)\n        self.assertIsInstance(code, str)\n        self.assertTrue(code.isdigit())\n        self.assertEqual(len(code), 6)\n\n\nclass ClientHighlightTestCase(ClientPrivateTestCase):\n    def test_highlight_pk_from_url(self):\n        highlight_pk = self.cl.highlight_pk_from_url(\n            \"https://www.instagram.com/stories/highlights/17983407089364361/\"\n        )\n        self.assertEqual(highlight_pk, \"17983407089364361\")\n\n    def test_highlight_info(self):\n        highlight = self.cl.highlight_info(17983407089364361)\n        self.assertIsInstance(highlight, Highlight)\n        self.assertEqual(highlight.pk, \"17983407089364361\")\n        self.assertTrue(len(highlight.items) > 0)\n        self.assertEqual(len(highlight.items), highlight.media_count)\n        self.assertEqual(len(highlight.items), len(highlight.media_ids))\n\n\nclass ClientShareTestCase(ClientPrivateTestCase):\n    def test_share_code_from_url(self):\n        url = \"https://www.instagram.com/s/aGlnaGxpZ2h0OjE3OTMzOTExODE2NTY4Njcx?utm_medium=share_sheet\"\n        code = self.cl.share_code_from_url(url)\n        self.assertEqual(code, \"aGlnaGxpZ2h0OjE3OTMzOTExODE2NTY4Njcx\")\n\n    def test_share_info_by_url(self):\n        url = \"https://www.instagram.com/s/aGlnaGxpZ2h0OjE3OTMzOTExODE2NTY4Njcx?utm_medium=share_sheet\"\n        share = self.cl.share_info_by_url(url)\n        self.assertIsInstance(share, Share)\n        self.assertEqual(share.pk, \"17933911816568671\")\n        self.assertEqual(share.type, \"highlight\")\n\n    def test_share_info(self):\n        share = self.cl.share_info(\"aGlnaGxpZ2h0OjE3OTMzOTExODE2NTY4Njcx\")\n        self.assertIsInstance(share, Share)\n        self.assertEqual(share.pk, \"17933911816568671\")\n        self.assertEqual(share.type, \"highlight\")\n        # UnicodeDecodeError: 'utf-8' codec can't decode byte 0xb1 in position 6: invalid start byte\n        share = self.cl.share_info(\"aGlnaGxpsdsdZ2h0OjE3OTg4MDg5NjI5MzgzNzcw\")\n        self.assertIsInstance(share, Share)\n        self.assertEqual(share.pk, \"17988089629383770\")\n        self.assertEqual(share.type, \"highlight\")\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n"
        },
        {
          "name": "util",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}