{
  "metadata": {
    "timestamp": 1736559681879,
    "page": 355,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM2MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "bklieger-groq/g1",
      "stars": 4136,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0146484375,
          "content": ".env\nvenv\n.venv"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0478515625,
          "content": "MIT License\n\nCopyright (c) 2024 Benjamin Klieger\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 7.7333984375,
          "content": "# g1: Using Llama-3.1 70b on Groq to create o1-like reasoning chains\n\n[Video Demo](https://github.com/user-attachments/assets/db2a221f-f8eb-48c3-b5a7-8399c6300243)\n\nThis is an early prototype of using prompting strategies to improve the LLM's reasoning capabilities through o1-like reasoning chains. This allows the LLM to \"think\" and solve logical problems that usually otherwise stump leading models. Unlike o1, all the reasoning tokens are shown, and the app uses an open source model.\n\ng1 is experimental and being open sourced to help inspire the open source community to develop new strategies to produce o1-like reasoning. This experiment helps show the power of prompting reasoning in visualized steps, not a comparison to or full replication of o1, which uses different techniques. OpenAI's o1 is instead trained with large-scale reinforcement learning to reason using Chain of Thought, achieving state-of-the-art performance on complex PhD-level problems. \n\ng1 demonstrates the potential of prompting alone to overcome straightforward LLM logic issues like the Strawberry problem, allowing existing open source models to benefit from dynamic reasoning chains and an improved interface for exploring them.\n\n\n### How it works\n\ng1 powered by Llama3.1-70b creates reasoning chains, in principle a dynamic Chain of Thought, that allows the LLM to \"think\" and solve some logical problems that usually otherwise stump leading models.\n\nAt each step, the LLM can choose to continue to another reasoning step, or provide a final answer. Each step is titled and visible to the user. The system prompt also includes tips for the LLM. There is a full explanation under Prompt Breakdown, but a few examples are asking the model to “include exploration of alternative answers” and “use at least 3 methods to derive the answer”.\n\nThe reasoning ability of the LLM is therefore improved through combining Chain-of-Thought with the requirement to try multiple methods, explore alternative answers, question previous draft solutions, and consider the LLM’s limitations. This alone, without any training, is sufficient to achieve ~70% accuracy on the Strawberry problem (n=10, \"How many Rs are in strawberry?\"). Without prompting, Llama-3.1-70b had 0% accuracy and ChatGPT-4o had 30% accuracy.\n\n\n### Examples\n\n> [!IMPORTANT]\n> g1 is not perfect, but it can perform significantly better than LLMs out-of-the-box. From initial testing, g1 accurately solves simple logic problems 60-80% of the time that usually stump LLMs. However, accuracy has yet to be formally evaluated. See examples below.\n\n\n##### How many Rs are in strawberry?\n\nPrompt: How many Rs are in strawberry?\n\nResult:\n\n![Strawberry example](examples/strawberry.png)\n\n---\n\nPrompt: Which is larger, .9 or .11?\n\nResult:\n\n![0.9 or 0.11 example](examples/math.png)\n\n\n### Quickstart\n\nTo use the Streamlit UI, follow these instructions:\n\n~~~\npython3 -m venv venv\n~~~\n\n~~~\nsource venv/bin/activate\n~~~\n\n~~~\npip3 install -r requirements.txt\n~~~\n\n~~~\nexport GROQ_API_KEY=gsk...\n~~~\n\n~~~\nstreamlit run app.py\n~~~\n\n---\n\nAlternatively, follow these additional instructions to use the Gradio UI:\n\n~~~\ncd gradio\n~~~\n\n~~~\npip3 install -r requirements.txt\n~~~\n\n~~~\npython3 app.py\n~~~\n\n\n### Prompting Strategy\n\nThe prompt is as follows:\n\n```\nYou are an expert AI assistant that explains your reasoning step by step. For each step, provide a title that describes what you're doing in that step, along with the content. Decide if you need another step or if you're ready to give the final answer. Respond in JSON format with 'title', 'content', and 'next_action' (either 'continue' or 'final_answer') keys. USE AS MANY REASONING STEPS AS POSSIBLE. AT LEAST 3. BE AWARE OF YOUR LIMITATIONS AS AN LLM AND WHAT YOU CAN AND CANNOT DO. IN YOUR REASONING, INCLUDE EXPLORATION OF ALTERNATIVE ANSWERS. CONSIDER YOU MAY BE WRONG, AND IF YOU ARE WRONG IN YOUR REASONING, WHERE IT WOULD BE. FULLY TEST ALL OTHER POSSIBILITIES. YOU CAN BE WRONG. WHEN YOU SAY YOU ARE RE-EXAMINING, ACTUALLY RE-EXAMINE, AND USE ANOTHER APPROACH TO DO SO. DO NOT JUST SAY YOU ARE RE-EXAMINING. USE AT LEAST 3 METHODS TO DERIVE THE ANSWER. USE BEST PRACTICES.\n\nExample of a valid JSON response:\njson\n{\n    \"title\": \"Identifying Key Information\",\n    \"content\": \"To begin solving this problem, we need to carefully examine the given information and identify the crucial elements that will guide our solution process. This involves...\",\n    \"next_action\": \"continue\"\n}\n```\n\n#### Breakdown\n\nFirst, a persona is added:\n\n> You are an expert AI assistant that explains your reasoning step by step.\n\n\n\nThen, instructions to describe the expected step-by-step reasoning process while titling each reasoning step. This includes the ability for the LLM to decide if another reasoning step is needed or if the final answer can be provided.\n\n> For each step, provide a title that describes what you're doing in that step, along with the content. Decide if you need another step or if you're ready to give the final answer. \n\n\n\nJSON formatting is introduced with an example provided later.\n\n> Respond in JSON format with 'title', 'content', and 'next_action' (either 'continue' or 'final_answer') keys. \n\n\n\nIn all-caps to improve prompt compliance by emphasizing the importance of the instruction, a set of tips and best practices are included.\n\n1. Use as many reasoning steps as possible. At least 3. -> This ensures the LLM actually takes the time to think first, and results usually in about 5-10 steps.\n2. Be aware of your limitations as an llm and what you can and cannot do. -> This helps the LLM remember to use techniques which produce better results, like breaking \"strawberry\" down into individual letters before counting.\n3. Include exploration of alternative answers. Consider you may be wrong, and if you are wrong in your reasoning, where it would be. -> A large part of the gains seem to come from the LLM re-evaluating its initial response to ensure it logically aligns with the problem.\n4. When you say you are re-examining, actually re-examine, and use another approach to do so. Do not just say you are re-examining. -> This encourages the prevention of the LLM just saying it re-examined a problem without actually trying a new approach. \n5. Use at least 3 methods to derive the answer. -> This helps the LLM come to the right answer by trying multiple methods to derive it.\n6. Use best practices. -> This is as simple as the \"Do better\" prompts which improve LLM code output. By telling the LLM to use best practices, or do better, it generally performs better!\n\n\n> USE AS MANY REASONING STEPS AS POSSIBLE. AT LEAST 3. BE AWARE OF YOUR LIMITATIONS AS AN LLM AND WHAT YOU CAN AND CANNOT DO. IN YOUR REASONING, INCLUDE EXPLORATION OF ALTERNATIVE ANSWERS. CONSIDER YOU MAY BE WRONG, AND IF YOU ARE WRONG IN YOUR REASONING, WHERE IT WOULD BE. FULLY TEST ALL OTHER POSSIBILITIES. YOU CAN BE WRONG. WHEN YOU SAY YOU ARE RE-EXAMINING, ACTUALLY RE-EXAMINE, AND USE ANOTHER APPROACH TO DO SO. DO NOT JUST SAY YOU ARE RE-EXAMINING. USE AT LEAST 3 METHODS TO DERIVE THE ANSWER. USE BEST PRACTICES.\n\n\n\nFinally, after the problem is added as a user message, an assistant message is loaded to provide a standardized starting point for the LLM's generation.\n\n> Assistant: Thank you! I will now think step by step following my instructions, starting at the beginning after decomposing the problem\n\n\n### Top Forks\n\n* Huggingface Spaces Demo: [![Hugging Face Spaces](https://img.shields.io/badge/%F0%9F%A4%97%20Hugging%20Face-Spaces-blue)](https://huggingface.co/spaces/xylin/g1-demo)\n* Mult1: Using multiple AI providers to create o1-like reasoning chains ([GitHub Repository](https://github.com/tcsenpai/multi1))\n* thinkR: o1 like chain of thoughts with local LLMs in R ([GitHub Repository](https://github.com/eonurk/thinkR))\n\n### Credits\n\nThis app was developed by [Benjamin Klieger](https://x.com/benjaminklieger).\n"
        },
        {
          "name": "app.py",
          "type": "blob",
          "size": 2.7294921875,
          "content": "import streamlit as st\nfrom g1 import generate_response\nimport json\n\ndef main():\n    st.set_page_config(page_title=\"g1 prototype\", page_icon=\"🧠\", layout=\"wide\")\n    \n    st.title(\"g1: Using Llama-3.1 70b on Groq to create o1-like reasoning chains\")\n    \n    st.markdown(\"\"\"\n    This is an early prototype of using prompting to create o1-like reasoning chains to improve output accuracy. It is not perfect and accuracy has yet to be formally evaluated. It is powered by Groq so that the reasoning step is fast!\n                \n    Open source [repository here](https://github.com/bklieger-groq)\n    \"\"\")\n    \n    # Text input for user query\n    user_query = st.text_input(\"Enter your query:\", placeholder=\"e.g., How many 'R's are in the word strawberry?\")\n    \n    if user_query:\n        st.write(\"Generating response...\")\n        \n        # Create empty elements to hold the generated text and total time\n        response_container = st.empty()\n        time_container = st.empty()\n        \n        # Generate and display the response\n        for steps, total_thinking_time in generate_response(user_query):\n            with response_container.container():\n                for i, (title, content, thinking_time) in enumerate(steps):\n                    # Ensure content is a string\n                    if not isinstance(content, str):\n                        content = json.dumps(content)\n                    if title.startswith(\"Final Answer\"):\n                        st.markdown(f\"### {title}\")\n                        if '```' in content:\n                            parts = content.split('```')\n                            for index, part in enumerate(parts):\n                                if index % 2 == 0:\n                                    st.markdown(part)\n                                else:\n                                    if '\\n' in part:\n                                        lang_line, code = part.split('\\n', 1)\n                                        lang = lang_line.strip()\n                                    else:\n                                        lang = ''\n                                        code = part\n                                    st.code(part, language=lang)\n                        else:\n                            st.markdown(content.replace('\\n', '<br>'), unsafe_allow_html=True)\n                    else:\n                        with st.expander(title, expanded=True):\n                            st.markdown(content.replace('\\n', '<br>'), unsafe_allow_html=True)\n            \n            # Only show total time when it's available at the end\n            if total_thinking_time is not None:\n                time_container.markdown(f\"**Total thinking time: {total_thinking_time:.2f} seconds**\")\n\nif __name__ == \"__main__\":\n    main()\n"
        },
        {
          "name": "example.env",
          "type": "blob",
          "size": 0.0185546875,
          "content": "GROQ_API_KEY=gsk..."
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "file-or-image-context",
          "type": "tree",
          "content": null
        },
        {
          "name": "g1.py",
          "type": "blob",
          "size": 4.4765625,
          "content": "import groq\nimport time\nimport os\nimport json\n\nclient = groq.Groq()\n\ndef make_api_call(messages, max_tokens, is_final_answer=False, custom_client=None):\n    global client\n    if custom_client != None:\n        client = custom_client\n    \n    for attempt in range(3):\n        try:\n            if is_final_answer:\n                response = client.chat.completions.create(\n                    model=\"llama-3.1-70b-versatile\",\n                    messages=messages,\n                    max_tokens=max_tokens,\n                    temperature=0.2,\n            ) \n                return response.choices[0].message.content\n            else:\n                response = client.chat.completions.create(\n                    model=\"llama-3.1-70b-versatile\",\n                    messages=messages,\n                    max_tokens=max_tokens,\n                    temperature=0.2,\n                    response_format={\"type\": \"json_object\"}\n                )\n                return json.loads(response.choices[0].message.content)\n        except Exception as e:\n            if attempt == 2:\n                if is_final_answer:\n                    return {\"title\": \"Error\", \"content\": f\"Failed to generate final answer after 3 attempts. Error: {str(e)}\"}\n                else:\n                    return {\"title\": \"Error\", \"content\": f\"Failed to generate step after 3 attempts. Error: {str(e)}\", \"next_action\": \"final_answer\"}\n            time.sleep(1)  # Wait for 1 second before retrying\n\ndef generate_response(prompt, custom_client=None):\n    messages = [\n        {\"role\": \"system\", \"content\": \"\"\"You are an expert AI assistant that explains your reasoning step by step. For each step, provide a title that describes what you're doing in that step, along with the content. Decide if you need another step or if you're ready to give the final answer. Respond in JSON format with 'title', 'content', and 'next_action' (either 'continue' or 'final_answer') keys. USE AS MANY REASONING STEPS AS POSSIBLE. AT LEAST 3. BE AWARE OF YOUR LIMITATIONS AS AN LLM AND WHAT YOU CAN AND CANNOT DO. IN YOUR REASONING, INCLUDE EXPLORATION OF ALTERNATIVE ANSWERS. CONSIDER YOU MAY BE WRONG, AND IF YOU ARE WRONG IN YOUR REASONING, WHERE IT WOULD BE. FULLY TEST ALL OTHER POSSIBILITIES. YOU CAN BE WRONG. WHEN YOU SAY YOU ARE RE-EXAMINING, ACTUALLY RE-EXAMINE, AND USE ANOTHER APPROACH TO DO SO. DO NOT JUST SAY YOU ARE RE-EXAMINING. USE AT LEAST 3 METHODS TO DERIVE THE ANSWER. USE BEST PRACTICES.\n\nExample of a valid JSON response:\n```json\n{\n    \"title\": \"Identifying Key Information\",\n    \"content\": \"To begin solving this problem, we need to carefully examine the given information and identify the crucial elements that will guide our solution process. This involves...\",\n    \"next_action\": \"continue\"\n}```\n\"\"\"},\n        {\"role\": \"user\", \"content\": prompt},\n        {\"role\": \"assistant\", \"content\": \"Thank you! I will now think step by step following my instructions, starting at the beginning after decomposing the problem.\"}\n    ]\n    \n    steps = []\n    step_count = 1\n    total_thinking_time = 0\n    \n    while True:\n        start_time = time.time()\n        step_data = make_api_call(messages, 300, custom_client=custom_client)\n        end_time = time.time()\n        thinking_time = end_time - start_time\n        total_thinking_time += thinking_time\n        \n        steps.append((f\"Step {step_count}: {step_data['title']}\", step_data['content'], thinking_time))\n        \n        messages.append({\"role\": \"assistant\", \"content\": json.dumps(step_data)})\n        \n        if step_data['next_action'] == 'final_answer' or step_count > 25: # Maximum of 25 steps to prevent infinite thinking time. Can be adjusted.\n            break\n        \n        step_count += 1\n\n        # Yield after each step for Streamlit to update\n        yield steps, None  # We're not yielding the total time until the end\n\n    # Generate final answer\n    messages.append({\"role\": \"user\", \"content\": \"Please provide the final answer based solely on your reasoning above. Do not use JSON formatting. Only provide the text response without any titles or preambles. Retain any formatting as instructed by the original prompt, such as exact formatting for free response or multiple choice.\"})\n    \n    start_time = time.time()\n    final_data = make_api_call(messages, 1200, is_final_answer=True, custom_client=custom_client)\n    end_time = time.time()\n    thinking_time = end_time - start_time\n    total_thinking_time += thinking_time\n    \n    steps.append((\"Final Answer\", final_data, thinking_time))\n\n    yield steps, total_thinking_time\n"
        },
        {
          "name": "gradio",
          "type": "tree",
          "content": null
        },
        {
          "name": "ollama",
          "type": "tree",
          "content": null
        },
        {
          "name": "requirements.txt",
          "type": "blob",
          "size": 0.0146484375,
          "content": "streamlit\ngroq\n"
        },
        {
          "name": "tool-use",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}