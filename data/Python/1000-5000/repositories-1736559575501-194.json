{
  "metadata": {
    "timestamp": 1736559575501,
    "page": 194,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjIwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "Fanghua-Yu/SUPIR",
      "stars": 4510,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".idea",
          "type": "tree",
          "content": null
        },
        {
          "name": "CKPT_PTH.py",
          "type": "blob",
          "size": 0.349609375,
          "content": "LLAVA_CLIP_PATH = '/opt/data/private/AIGC_pretrain/LLaVA1.5/clip-vit-large-patch14-336'\nLLAVA_MODEL_PATH = '/opt/data/private/AIGC_pretrain/LLaVA1.5/llava-v1.5-13b'\nSDXL_CLIP1_PATH = '/opt/data/private/AIGC_pretrain/clip-vit-large-patch14'\nSDXL_CLIP2_CKPT_PTH = '/opt/data/private/AIGC_pretrain/CLIP-ViT-bigG-14-laion2B-39B-b160k/open_clip_pytorch_model.bin'"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 8.0302734375,
          "content": "SUPIR Software License Agreement\n\nCopyright (c) 2024 by SupPixel Pty Ltd. All rights reserved.\n\nThis work is jointly owned by SupPixel Pty Ltd, an Australian company (ACN 676 560 320). All rights reserved. The work is created by the author team of SUPIR at SupPixel Pty Ltd.\n\nThis License Agreement (\"Agreement\") is made and entered into by and between SupPixel Pty Ltd (collectively, the \"Licensor\") and any person or entity who accesses, uses, or distributes the SUPIR software (the \"Licensee\").\n\n1. Definitions\n\na. Licensed Software: Refers to the SUPIR software, including its source code, associated documentation, and any updates, upgrades, or modifications thereof. The Licensed Software includes both open-source components and proprietary components, as described herein.\n\nb. Neural Network Components: Includes the weights, biases, and architecture of the proprietary neural network(s) developed and trained by the Licensor. This excludes any pre-existing open-source neural networks used in conjunction with the Licensor's proprietary networks, for which the Licensor does not hold copyright.\n\nc. Commercial Use: Refers to any use of the Licensed Software or its components, in whole or in part, for the purpose of generating revenue, conducting business operations, or creating products or services for sale or profit. This includes, but is not limited to:\n\n- Deploying the software on a server to provide a service to users for a fee.\n- Using the software to process images that are intended for sale.\n- Integrating the software or its components into a commercial product that is sold to end-users.\n- Using the software to provide commercial consulting or contracting services, such as image analysis, enhancement, or modification for clients.\n- Using the software to process images that are subsequently used in training datasets for machine learning models or other types of data analysis. This includes datasets that are used internally, sold, or provided to third parties under a commercial agreement.\n- Licensing the software or its components to other businesses for commercial purposes.\n\n2. License Grant\n\na. Open-Source Components: The Licensor grants the Licensee a non-exclusive, worldwide, royalty-free license to use, copy, modify, and distribute the source code of the open-source components of the Licensed Software, subject to the terms and conditions of their respective open-source licenses. The specific open-source licenses for each component are indicated in the source code files and documentation of the Licensed Software.\n\nb. Proprietary Neural Network Components: Notwithstanding the open-source license granted in Section 2(a) for open-source components, the Licensor retains all rights, title, and interest in and to the proprietary Neural Network Components developed and trained by the Licensor. The license granted herein does not include rights to use, copy, modify, distribute, or create derivative works of these proprietary Neural Network Components without obtaining express written permission from the Licensor.\n\nc. The source code of the Licensed Software is available as open-source on this GitHub repository. However, the open-source license does not grant any rights to the weights, biases, or architecture of the proprietary neural network(s) used in the Licensed Software, which remain the exclusive property of the Licensor.\n\n3. Commercial Use and Licensing\n\na. The Licensor retains all ownership and commercial usage rights in the Licensed Software, including its neural network(s), regardless of the open-source availability of portions of the Licensed Software's source code. Under the open-source license, anyone may freely use, copy, modify, and distribute the source code of the Licensed Software for non-commercial purposes only. Similarly, the proprietary neural network weights, biases, and architecture may only be used for non-commercial purposes. Any commercial use, copying, modification, distribution, or creation of derivative works of the Licensed Software's source code or the proprietary neural network weights, biases, and architecture is strictly prohibited without express written permission from the Licensor.\n\nb. Any Commercial Use of the Licensed Software, including its source code and neural network(s), requires a separate commercial license agreement with the Licensor. The terms and conditions of such commercial licensing, including the scope of use, fees, and delivery of the relevant components, shall be negotiated and agreed upon between the Licensor and the Licensee in writing. For commercial licensing inquiries, please contact the Licensor at jinjin.gu@suppixel.ai.\n\n4. Intellectual Property Rights\n\na. The Licensor retains all intellectual property rights in the Licensed Software, including copyrights, patents, trademarks, trade secrets, and any other proprietary rights. The Licensee acknowledges that the Licensor is the sole owner of the Licensed Software and its components, including the proprietary Neural Network Components.\n\nb. The Licensee agrees not to challenge or contest the Licensor's ownership or intellectual property rights in the Licensed Software, nor to assist or encourage any third party in doing so.\n\nc. The Licensee shall promptly notify the Licensor of any actual or suspected infringement of the Licensor's intellectual property rights in the Licensed Software by third parties, and shall provide reasonable assistance to the Licensor in enforcing its rights against such infringement.\n\n5. Warranty Disclaimer\n\nThe Licensed Software is provided \"as is\", without warranty of any kind, either express or implied, including, but not limited to, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement. The Licensor disclaims all warranties, express or implied, regarding the accuracy, reliability, completeness, or usefulness of the Licensed Software or its components. The Licensor does not warrant that the Licensed Software will be error-free, uninterrupted, or free from defects or vulnerabilities.\n\n6. Limitation of Liability\n\nIn no event shall the Licensor be liable for any claim, damages, or other liability, whether in an action of contract, tort, or otherwise, arising from, out of, or in connection with the Licensed Software or the use or other dealings in the Licensed Software. The Licensor shall not be liable for any direct, indirect, incidental, special, consequential, or exemplary damages, including but not limited to damages for loss of profits, goodwill, use, data, or other intangible losses, even if the Licensor has been advised of the possibility of such damages.\n\n7. Indemnification\n\nThe Licensee agrees to indemnify, defend, and hold harmless the Licensor and its affiliates, officers, directors, employees, and agents from and against any and all claims, liabilities, damages, losses, costs, expenses, or fees (including reasonable attorneys' fees) arising from or relating to the Licensee's use of the Licensed Software or any violation of this Agreement by the Licensee.\n\n8. Governing Law and Jurisdiction\n\nThis Agreement shall be governed by and construed in accordance with the laws of the State of New South Wales, Australia, without giving effect to any choice or conflict of law provision or rule. Any legal action or proceeding arising out of or relating to this Agreement shall be brought exclusively in the courts of New South Wales, Australia, and each party irrevocably submits to the jurisdiction of such courts.\n\n9. Entire Agreement\n\nThis Agreement constitutes the entire agreement between the parties concerning the subject matter hereof and supersedes all prior or contemporaneous communications, understandings, and agreements, whether written or oral, between the parties regarding such subject matter.\n\nBy accessing, using, or distributing the Licensed Software, the Licensee agrees to be bound by the terms and conditions of this Agreement. If the Licensee does not agree to the terms of this Agreement, the Licensee must not access, use, or distribute the Licensed Software.\n\nFor inquiries or to obtain permission for Commercial Use, please contact:\n\nDr. Jinjin Gu\nSupPixel Pty Ltd\nEmail: jinjin.gu@suppixel.ai\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 9.029296875,
          "content": "## (CVPR2024) Scaling Up to Excellence: Practicing Model Scaling for Photo-Realistic Image Restoration In the Wild\n\n> [[Paper](https://arxiv.org/abs/2401.13627)] &emsp; [[Project Page](http://supir.xpixel.group/)] &emsp; [[Online App]](https://supir.suppixel.ai/home) <br>\n> Fanghua, Yu, [Jinjin Gu](https://www.jasongt.com/), Zheyuan Li, Jinfan Hu, Xiangtao Kong, [Xintao Wang](https://xinntao.github.io/), [Jingwen He](https://scholar.google.com.hk/citations?user=GUxrycUAAAAJ), [Yu Qiao](https://scholar.google.com.hk/citations?user=gFtI-8QAAAAJ), [Chao Dong](https://scholar.google.com.hk/citations?user=OSDCB0UAAAAJ) <br>\n> Shenzhen Institute of Advanced Technology; Shanghai AI Laboratory; University of Sydney; The Hong Kong Polytechnic University; ARC Lab, Tencent PCG; The Chinese University of Hong Kong <br>\n\n\n<p align=\"center\">\n  <img src=\"assets/teaser.png\">\n</p>\n\n---\n#### üöÄ We're thrilled to announce the official launch of SupPixel AI! Experience the next level of image processing and upscaling with our cutting-edge AI technology based on SUPIR. Explore now at [suppixel.ai](https://supir.suppixel.ai/home).\n\n---\n## üîß Dependencies and Installation\n\n1. Clone repo\n    ```bash\n    git clone https://github.com/Fanghua-Yu/SUPIR.git\n    cd SUPIR\n    ```\n\n2. Install dependent packages\n    ```bash\n    conda create -n SUPIR python=3.8 -y\n    conda activate SUPIR\n    pip install --upgrade pip\n    pip install -r requirements.txt\n    ```\n\n3. Download Checkpoints\n\nFor users who can connect to huggingface, please setting `LLAVA_CLIP_PATH, SDXL_CLIP1_PATH, SDXL_CLIP2_CKPT_PTH` in `CKPT_PTH.py` as `None`. These CLIPs will be downloaded automatically. \n\n#### Dependent Models\n* [SDXL CLIP Encoder-1](https://huggingface.co/openai/clip-vit-large-patch14)\n* [SDXL CLIP Encoder-2](https://huggingface.co/laion/CLIP-ViT-bigG-14-laion2B-39B-b160k)\n* [SDXL base 1.0_0.9vae](https://huggingface.co/stabilityai/stable-diffusion-xl-base-1.0/blob/main/sd_xl_base_1.0_0.9vae.safetensors)\n* [LLaVA CLIP](https://huggingface.co/openai/clip-vit-large-patch14-336)\n* [LLaVA v1.5 13B](https://huggingface.co/liuhaotian/llava-v1.5-13b)\n* (optional) [Juggernaut-XL_v9_RunDiffusionPhoto_v2](https://huggingface.co/RunDiffusion/Juggernaut-XL-v9/blob/main/Juggernaut-XL_v9_RunDiffusionPhoto_v2.safetensors)\n  * Replacement of `SDXL base 1.0_0.9vae` for Photo Realistic\n* (optional) [Juggernaut_RunDiffusionPhoto2_Lightning_4Steps](https://huggingface.co/RunDiffusion/Juggernaut-XL-Lightning/blob/main/Juggernaut_RunDiffusionPhoto2_Lightning_4Steps.safetensors)\n  * Distilling model used in `SUPIR_v0_Juggernautv9_lightning.yaml`\n\n\n#### Models we provided:\n* `SUPIR-v0Q`: [Baidu Netdisk](https://pan.baidu.com/s/1lnefCZhBTeDWijqbj1jIyw?pwd=pjq6), [Google Drive](https://drive.google.com/drive/folders/1yELzm5SvAi9e7kPcO_jPp2XkTs4vK6aR?usp=sharing)\n    \n    Default training settings with paper. High generalization and high image quality in most cases.\n\n* `SUPIR-v0F`: [Baidu Netdisk](https://pan.baidu.com/s/1AECN8NjiVuE3hvO8o-Ua6A?pwd=k2uz), [Google Drive](https://drive.google.com/drive/folders/1yELzm5SvAi9e7kPcO_jPp2XkTs4vK6aR?usp=sharing)\n\n    Training with light degradation settings. Stage1 encoder of `SUPIR-v0F` remains more details when facing light degradations.\n\n4. Edit Custom Path for Checkpoints\n    ```\n    * [CKPT_PTH.py] --> LLAVA_CLIP_PATH, LLAVA_MODEL_PATH, SDXL_CLIP1_PATH, SDXL_CLIP2_CACHE_DIR \n    * [options/SUPIR_v0.yaml] --> SDXL_CKPT, SUPIR_CKPT_Q, SUPIR_CKPT_F\n    ```\n---\n\n## ‚ö° Quick Inference\n### Val Dataset\nRealPhoto60: [Baidu Netdisk](https://pan.baidu.com/s/1CJKsPGtyfs8QEVCQ97voBA?pwd=aocg), [Google Drive](https://drive.google.com/drive/folders/1yELzm5SvAi9e7kPcO_jPp2XkTs4vK6aR?usp=sharing)\n\n### Usage of SUPIR\n```Shell\nUsage: \n-- python test.py [options] \n-- python gradio_demo.py [interactive options]\n\n--img_dir                Input folder.\n--save_dir               Output folder.\n--upscale                Upsampling ratio of given inputs. Default: 1\n--SUPIR_sign             Model selection. Default: 'Q'; Options: ['F', 'Q']\n--seed                   Random seed. Default: 1234\n--min_size               Minimum resolution of output images. Default: 1024\n--edm_steps              Numb of steps for EDM Sampling Scheduler. Default: 50\n--s_stage1               Control Strength of Stage1. Default: -1 (negative means invalid)\n--s_churn                Original hy-param of EDM. Default: 5\n--s_noise                Original hy-param of EDM. Default: 1.003\n--s_cfg                  Classifier-free guidance scale for prompts. Default: 7.5\n--s_stage2               Control Strength of Stage2. Default: 1.0\n--num_samples            Number of samples for each input. Default: 1\n--a_prompt               Additive positive prompt for all inputs. \n    Default: 'Cinematic, High Contrast, highly detailed, taken using a Canon EOS R camera, \n    hyper detailed photo - realistic maximum detail, 32k, Color Grading, ultra HD, extreme\n     meticulous detailing, skin pore detailing, hyper sharpness, perfect without deformations.'\n--n_prompt               Fixed negative prompt for all inputs. \n    Default: 'painting, oil painting, illustration, drawing, art, sketch, oil painting, \n    cartoon, CG Style, 3D render, unreal engine, blurring, dirty, messy, worst quality, \n    low quality, frames, watermark, signature, jpeg artifacts, deformed, lowres, over-smooth'\n--color_fix_type         Color Fixing Type. Default: 'Wavelet'; Options: ['None', 'AdaIn', 'Wavelet']\n--linear_CFG             Linearly (with sigma) increase CFG from 'spt_linear_CFG' to s_cfg. Default: False\n--linear_s_stage2        Linearly (with sigma) increase s_stage2 from 'spt_linear_s_stage2' to s_stage2. Default: False\n--spt_linear_CFG         Start point of linearly increasing CFG. Default: 1.0\n--spt_linear_s_stage2    Start point of linearly increasing s_stage2. Default: 0.0\n--ae_dtype               Inference data type of AutoEncoder. Default: 'bf16'; Options: ['fp32', 'bf16']\n--diff_dtype             Inference data type of Diffusion. Default: 'fp16'; Options: ['fp32', 'fp16', 'bf16']\n```\n\n### Python Script\n```Shell\n# Seek for best quality for most cases\nCUDA_VISIBLE_DEVICES=0,1 python test.py --img_dir '/opt/data/private/LV_Dataset/DiffGLV-Test-All/RealPhoto60/LQ' --save_dir ./results-Q --SUPIR_sign Q --upscale 2\n# for light degradation and high fidelity\nCUDA_VISIBLE_DEVICES=0,1 python test.py --img_dir '/opt/data/private/LV_Dataset/DiffGLV-Test-All/RealPhoto60/LQ' --save_dir ./results-F --SUPIR_sign F --upscale 2 --s_cfg 4.0 --linear_CFG\n```\n\n### Gradio Demo\n```Shell\nCUDA_VISIBLE_DEVICES=0,1 python gradio_demo.py --ip 0.0.0.0 --port 6688 --use_image_slider --log_history\n\n# Juggernaut_RunDiffusionPhoto2_Lightning_4Steps and DPM++ M2 SDE Karras for fast sampling\nCUDA_VISIBLE_DEVICES=0,1 python gradio_demo.py --ip 0.0.0.0 --port 6688 --use_image_slider --log_history --opt options/SUPIR_v0_Juggernautv9_lightning.yaml\n\n# less VRAM & slower (12G for Diffusion, 16G for LLaVA)\nCUDA_VISIBLE_DEVICES=0,1 python gradio_demo.py --ip 0.0.0.0 --port 6688 --use_image_slider --log_history --loading_half_params --use_tile_vae --load_8bit_llava\n```\n<p align=\"center\">\n  <img src=\"assets/DemoGuide.png\">\n</p>\n\n\n### Online App\n\nWe've just launched [SupPixel AI](https://supir.suppixel.ai/home), an easy-to-use tool designed to help with high-quality image processing and upscaling. It builds on SUPIR. Whether you‚Äôre into photography, digital art, or just love playing around with image enhancement, we‚Äôd love for you to check it out.~\n\n<p align=\"center\">\n  <img src=\"assets/APP.png\">\n</p>\n\n\n---\n\n## BibTeX\n    @misc{yu2024scaling,\n      title={Scaling Up to Excellence: Practicing Model Scaling for Photo-Realistic Image Restoration In the Wild}, \n      author={Fanghua Yu and Jinjin Gu and Zheyuan Li and Jinfan Hu and Xiangtao Kong and Xintao Wang and Jingwen He and Yu Qiao and Chao Dong},\n      year={2024},\n      eprint={2401.13627},\n      archivePrefix={arXiv},\n      primaryClass={cs.CV}\n    }\n\n---\n\n## üìß Contact\nIf you have any question, please email `fanghuayu96@gmail.com` or `jinjin.gu@suppixel.ai`.\n\n---\n## Non-Commercial Use Only Declaration\nThe SUPIR (\"Software\") is made available for use, reproduction, and distribution strictly for non-commercial purposes. For the purposes of this declaration, \"non-commercial\" is defined as not primarily intended for or directed towards commercial advantage or monetary compensation.\n\nBy using, reproducing, or distributing the Software, you agree to abide by this restriction and not to use the Software for any commercial purposes without obtaining prior written permission from Dr. Jinjin Gu.\n\nThis declaration does not in any way limit the rights under any open source license that may apply to the Software; it solely adds a condition that the Software shall not be used for commercial purposes.\n\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nFor inquiries or to obtain permission for commercial use, please contact Dr. Jinjin Gu (jinjin.gu@suppixel.ai).\n"
        },
        {
          "name": "SUPIR",
          "type": "tree",
          "content": null
        },
        {
          "name": "assets",
          "type": "tree",
          "content": null
        },
        {
          "name": "gradio_demo.py",
          "type": "blob",
          "size": 17.1123046875,
          "content": "import os\n\nimport gradio as gr\nfrom gradio_imageslider import ImageSlider\nimport argparse\nfrom SUPIR.util import HWC3, upscale_image, fix_resize, convert_dtype\nimport numpy as np\nimport torch\nfrom SUPIR.util import create_SUPIR_model, load_QF_ckpt\nfrom PIL import Image\nfrom llava.llava_agent import LLavaAgent\nfrom CKPT_PTH import LLAVA_MODEL_PATH\nimport einops\nimport copy\nimport time\n\nparser = argparse.ArgumentParser()\nparser.add_argument(\"--opt\", type=str, default='options/SUPIR_v0.yaml')\nparser.add_argument(\"--ip\", type=str, default='127.0.0.1')\nparser.add_argument(\"--port\", type=int, default='6688')\nparser.add_argument(\"--no_llava\", action='store_true', default=False)\nparser.add_argument(\"--use_image_slider\", action='store_true', default=False)\nparser.add_argument(\"--log_history\", action='store_true', default=False)\nparser.add_argument(\"--loading_half_params\", action='store_true', default=False)\nparser.add_argument(\"--use_tile_vae\", action='store_true', default=False)\nparser.add_argument(\"--encoder_tile_size\", type=int, default=512)\nparser.add_argument(\"--decoder_tile_size\", type=int, default=64)\nparser.add_argument(\"--load_8bit_llava\", action='store_true', default=False)\nargs = parser.parse_args()\nserver_ip = args.ip\nserver_port = args.port\nuse_llava = not args.no_llava\n\nif torch.cuda.device_count() >= 2:\n    SUPIR_device = 'cuda:0'\n    LLaVA_device = 'cuda:1'\nelif torch.cuda.device_count() == 1:\n    SUPIR_device = 'cuda:0'\n    LLaVA_device = 'cuda:0'\nelse:\n    raise ValueError('Currently support CUDA only.')\n\n# load SUPIR\nmodel, default_setting = create_SUPIR_model(args.opt, SUPIR_sign='Q', load_default_setting=True)\nif args.loading_half_params:\n    model = model.half()\nif args.use_tile_vae:\n    model.init_tile_vae(encoder_tile_size=args.encoder_tile_size, decoder_tile_size=args.decoder_tile_size)\nmodel = model.to(SUPIR_device)\nmodel.first_stage_model.denoise_encoder_s1 = copy.deepcopy(model.first_stage_model.denoise_encoder)\nmodel.current_model = 'v0-Q'\nckpt_Q, ckpt_F = load_QF_ckpt(args.opt)\n\n# load LLaVA\nif use_llava:\n    llava_agent = LLavaAgent(LLAVA_MODEL_PATH, device=LLaVA_device, load_8bit=args.load_8bit_llava, load_4bit=False)\nelse:\n    llava_agent = None\n\ndef stage1_process(input_image, gamma_correction):\n    torch.cuda.set_device(SUPIR_device)\n    LQ = HWC3(input_image)\n    LQ = fix_resize(LQ, 512)\n    # stage1\n    LQ = np.array(LQ) / 255 * 2 - 1\n    LQ = torch.tensor(LQ, dtype=torch.float32).permute(2, 0, 1).unsqueeze(0).to(SUPIR_device)[:, :3, :, :]\n    LQ = model.batchify_denoise(LQ, is_stage1=True)\n    LQ = (LQ[0].permute(1, 2, 0) * 127.5 + 127.5).cpu().numpy().round().clip(0, 255).astype(np.uint8)\n    # gamma correction\n    LQ = LQ / 255.0\n    LQ = np.power(LQ, gamma_correction)\n    LQ *= 255.0\n    LQ = LQ.round().clip(0, 255).astype(np.uint8)\n    return LQ\n\ndef llave_process(input_image, temperature, top_p, qs=None):\n    torch.cuda.set_device(LLaVA_device)\n    if use_llava:\n        LQ = HWC3(input_image)\n        LQ = Image.fromarray(LQ.astype('uint8'))\n        captions = llava_agent.gen_image_caption([LQ], temperature=temperature, top_p=top_p, qs=qs)\n    else:\n        captions = ['LLaVA is not available. Please add text manually.']\n    return captions[0]\n\ndef stage2_process(input_image, prompt, a_prompt, n_prompt, num_samples, upscale, edm_steps, s_stage1, s_stage2,\n                   s_cfg, seed, s_churn, s_noise, color_fix_type, diff_dtype, ae_dtype, gamma_correction,\n                   linear_CFG, linear_s_stage2, spt_linear_CFG, spt_linear_s_stage2, model_select):\n    torch.cuda.set_device(SUPIR_device)\n    event_id = str(time.time_ns())\n    event_dict = {'event_id': event_id, 'localtime': time.ctime(), 'prompt': prompt, 'a_prompt': a_prompt,\n                  'n_prompt': n_prompt, 'num_samples': num_samples, 'upscale': upscale, 'edm_steps': edm_steps,\n                  's_stage1': s_stage1, 's_stage2': s_stage2, 's_cfg': s_cfg, 'seed': seed, 's_churn': s_churn,\n                  's_noise': s_noise, 'color_fix_type': color_fix_type, 'diff_dtype': diff_dtype, 'ae_dtype': ae_dtype,\n                  'gamma_correction': gamma_correction, 'linear_CFG': linear_CFG, 'linear_s_stage2': linear_s_stage2,\n                  'spt_linear_CFG': spt_linear_CFG, 'spt_linear_s_stage2': spt_linear_s_stage2,\n                  'model_select': model_select}\n\n    if model_select != model.current_model:\n        if model_select == 'v0-Q':\n            print('load v0-Q')\n            model.load_state_dict(ckpt_Q, strict=False)\n            model.current_model = 'v0-Q'\n        elif model_select == 'v0-F':\n            print('load v0-F')\n            model.load_state_dict(ckpt_F, strict=False)\n            model.current_model = 'v0-F'\n    input_image = HWC3(input_image)\n    input_image = upscale_image(input_image, upscale, unit_resolution=32,\n                                min_size=1024)\n\n    LQ = np.array(input_image) / 255.0\n    LQ = np.power(LQ, gamma_correction)\n    LQ *= 255.0\n    LQ = LQ.round().clip(0, 255).astype(np.uint8)\n    LQ = LQ / 255 * 2 - 1\n    LQ = torch.tensor(LQ, dtype=torch.float32).permute(2, 0, 1).unsqueeze(0).to(SUPIR_device)[:, :3, :, :]\n    if use_llava:\n        captions = [prompt]\n    else:\n        captions = ['']\n\n    model.ae_dtype = convert_dtype(ae_dtype)\n    model.model.dtype = convert_dtype(diff_dtype)\n\n    samples = model.batchify_sample(LQ, captions, num_steps=edm_steps, restoration_scale=s_stage1, s_churn=s_churn,\n                                    s_noise=s_noise, cfg_scale=s_cfg, control_scale=s_stage2, seed=seed,\n                                    num_samples=num_samples, p_p=a_prompt, n_p=n_prompt, color_fix_type=color_fix_type,\n                                    use_linear_CFG=linear_CFG, use_linear_control_scale=linear_s_stage2,\n                                    cfg_scale_start=spt_linear_CFG, control_scale_start=spt_linear_s_stage2)\n\n    x_samples = (einops.rearrange(samples, 'b c h w -> b h w c') * 127.5 + 127.5).cpu().numpy().round().clip(\n        0, 255).astype(np.uint8)\n    results = [x_samples[i] for i in range(num_samples)]\n\n    if args.log_history:\n        os.makedirs(f'./history/{event_id[:5]}/{event_id[5:]}', exist_ok=True)\n        with open(f'./history/{event_id[:5]}/{event_id[5:]}/logs.txt', 'w') as f:\n            f.write(str(event_dict))\n        f.close()\n        Image.fromarray(input_image).save(f'./history/{event_id[:5]}/{event_id[5:]}/LQ.png')\n        for i, result in enumerate(results):\n            Image.fromarray(result).save(f'./history/{event_id[:5]}/{event_id[5:]}/HQ_{i}.png')\n    return [input_image] + results, event_id, 3, ''\n\n\ndef load_and_reset(param_setting):\n    edm_steps = default_setting.edm_steps\n    s_stage2 = 1.0\n    s_stage1 = -1.0\n    s_churn = 5\n    s_noise = 1.003\n    a_prompt = 'Cinematic, High Contrast, highly detailed, taken using a Canon EOS R camera, hyper detailed photo - ' \\\n               'realistic maximum detail, 32k, Color Grading, ultra HD, extreme meticulous detailing, skin pore ' \\\n               'detailing, hyper sharpness, perfect without deformations.'\n    n_prompt = 'painting, oil painting, illustration, drawing, art, sketch, oil painting, cartoon, CG Style, ' \\\n               '3D render, unreal engine, blurring, dirty, messy, worst quality, low quality, frames, watermark, ' \\\n               'signature, jpeg artifacts, deformed, lowres, over-smooth'\n    color_fix_type = 'Wavelet'\n    spt_linear_s_stage2 = 0.0\n    linear_s_stage2 = False\n    linear_CFG = True\n    if param_setting == \"Quality\":\n        s_cfg = default_setting.s_cfg_Quality\n        spt_linear_CFG = default_setting.spt_linear_CFG_Quality\n    elif param_setting == \"Fidelity\":\n        s_cfg = default_setting.s_cfg_Fidelity\n        spt_linear_CFG = default_setting.spt_linear_CFG_Fidelity\n    else:\n        raise NotImplementedError\n    return edm_steps, s_cfg, s_stage2, s_stage1, s_churn, s_noise, a_prompt, n_prompt, color_fix_type, linear_CFG, \\\n        linear_s_stage2, spt_linear_CFG, spt_linear_s_stage2\n\n\ndef submit_feedback(event_id, fb_score, fb_text):\n    if args.log_history:\n        with open(f'./history/{event_id[:5]}/{event_id[5:]}/logs.txt', 'r') as f:\n            event_dict = eval(f.read())\n        f.close()\n        event_dict['feedback'] = {'score': fb_score, 'text': fb_text}\n        with open(f'./history/{event_id[:5]}/{event_id[5:]}/logs.txt', 'w') as f:\n            f.write(str(event_dict))\n        f.close()\n        return 'Submit successfully, thank you for your comments!'\n    else:\n        return 'Submit failed, the server is not set to log history.'\n\n\ntitle_md = \"\"\"\n# **SUPIR: Practicing Model Scaling for Photo-Realistic Image Restoration**\n\n‚ö†Ô∏èSUPIR is still a research project under tested and is not yet a stable commercial product.\n\n[[Paper](https://arxiv.org/abs/2401.13627)] &emsp; [[Project Page](http://supir.xpixel.group/)] &emsp; [[How to play](https://github.com/Fanghua-Yu/SUPIR/blob/master/assets/DemoGuide.png)]\n\"\"\"\n\n\nclaim_md = \"\"\"\n## **Terms of use**\n\nBy using this service, users are required to agree to the following terms: The service is a research preview intended for non-commercial use only. It only provides limited safety measures and may generate offensive content. It must not be used for any illegal, harmful, violent, racist, or sexual purposes. The service may collect user dialogue data for future research. Please submit a feedback to us if you get any inappropriate answer! We will collect those to keep improving our models. For an optimal experience, please use desktop computers for this demo, as mobile devices may compromise its quality.\n\n## **License**\n\nThe service is a research preview intended for non-commercial use only, subject to the model [License](https://github.com/Fanghua-Yu/SUPIR) of SUPIR.\n\"\"\"\n\n\nblock = gr.Blocks(title='SUPIR').queue()\nwith block:\n    with gr.Row():\n        gr.Markdown(title_md)\n    with gr.Row():\n        with gr.Column():\n            with gr.Row(equal_height=True):\n                with gr.Column():\n                    gr.Markdown(\"<center>Input</center>\")\n                    input_image = gr.Image(type=\"numpy\", elem_id=\"image-input\", height=400, width=400)\n                with gr.Column():\n                    gr.Markdown(\"<center>Stage1 Output</center>\")\n                    denoise_image = gr.Image(type=\"numpy\", elem_id=\"image-s1\", height=400, width=400)\n            prompt = gr.Textbox(label=\"Prompt\", value=\"\")\n            with gr.Accordion(\"Stage1 options\", open=False):\n                gamma_correction = gr.Slider(label=\"Gamma Correction\", minimum=0.1, maximum=2.0, value=1.0, step=0.1)\n            with gr.Accordion(\"LLaVA options\", open=False):\n                temperature = gr.Slider(label=\"Temperature\", minimum=0., maximum=1.0, value=0.2, step=0.1)\n                top_p = gr.Slider(label=\"Top P\", minimum=0., maximum=1.0, value=0.7, step=0.1)\n                qs = gr.Textbox(label=\"Question\", value=\"Describe this image and its style in a very detailed manner. \"\n                                                        \"The image is a realistic photography, not an art painting.\")\n            with gr.Accordion(\"Stage2 options\", open=False):\n                num_samples = gr.Slider(label=\"Num Samples\", minimum=1, maximum=4 if not args.use_image_slider else 1\n                                        , value=1, step=1)\n                upscale = gr.Slider(label=\"Upscale\", minimum=1, maximum=8, value=1, step=1)\n                edm_steps = gr.Slider(label=\"Steps\", minimum=1, maximum=200, value=default_setting.edm_steps, step=1)\n                s_cfg = gr.Slider(label=\"Text Guidance Scale\", minimum=1.0, maximum=15.0,\n                                  value=default_setting.s_cfg_Quality, step=0.1)\n                s_stage2 = gr.Slider(label=\"Stage2 Guidance Strength\", minimum=0., maximum=1., value=1., step=0.05)\n                s_stage1 = gr.Slider(label=\"Stage1 Guidance Strength\", minimum=-1.0, maximum=6.0, value=-1.0, step=1.0)\n                seed = gr.Slider(label=\"Seed\", minimum=-1, maximum=2147483647, step=1, randomize=True)\n                s_churn = gr.Slider(label=\"S-Churn\", minimum=0, maximum=40, value=5, step=1)\n                s_noise = gr.Slider(label=\"S-Noise\", minimum=1.0, maximum=1.1, value=1.003, step=0.001)\n                a_prompt = gr.Textbox(label=\"Default Positive Prompt\",\n                                      value='Cinematic, High Contrast, highly detailed, taken using a Canon EOS R '\n                                            'camera, hyper detailed photo - realistic maximum detail, 32k, Color '\n                                            'Grading, ultra HD, extreme meticulous detailing, skin pore detailing, '\n                                            'hyper sharpness, perfect without deformations.')\n                n_prompt = gr.Textbox(label=\"Default Negative Prompt\",\n                                      value='painting, oil painting, illustration, drawing, art, sketch, oil painting, '\n                                            'cartoon, CG Style, 3D render, unreal engine, blurring, dirty, messy, '\n                                            'worst quality, low quality, frames, watermark, signature, jpeg artifacts, '\n                                            'deformed, lowres, over-smooth')\n                with gr.Row():\n                    with gr.Column():\n                        linear_CFG = gr.Checkbox(label=\"Linear CFG\", value=True)\n                        spt_linear_CFG = gr.Slider(label=\"CFG Start\", minimum=1.0,\n                                                        maximum=9.0, value=default_setting.spt_linear_CFG_Quality, step=0.5)\n                    with gr.Column():\n                        linear_s_stage2 = gr.Checkbox(label=\"Linear Stage2 Guidance\", value=False)\n                        spt_linear_s_stage2 = gr.Slider(label=\"Guidance Start\", minimum=0.,\n                                                        maximum=1., value=0., step=0.05)\n                with gr.Row():\n                    with gr.Column():\n                        diff_dtype = gr.Radio(['fp32', 'fp16', 'bf16'], label=\"Diffusion Data Type\", value=\"fp16\",\n                                              interactive=True)\n                    with gr.Column():\n                        ae_dtype = gr.Radio(['fp32', 'bf16'], label=\"Auto-Encoder Data Type\", value=\"bf16\",\n                                            interactive=True)\n                    with gr.Column():\n                        color_fix_type = gr.Radio([\"None\", \"AdaIn\", \"Wavelet\"], label=\"Color-Fix Type\", value=\"Wavelet\",\n                                                  interactive=True)\n                    with gr.Column():\n                        model_select = gr.Radio([\"v0-Q\", \"v0-F\"], label=\"Model Selection\", value=\"v0-Q\",\n                                                interactive=True)\n\n        with gr.Column():\n            gr.Markdown(\"<center>Stage2 Output</center>\")\n            if not args.use_image_slider:\n                result_gallery = gr.Gallery(label='Output', show_label=False, elem_id=\"gallery1\")\n            else:\n                result_gallery = ImageSlider(label='Output', show_label=False, elem_id=\"gallery1\")\n            with gr.Row():\n                with gr.Column():\n                    denoise_button = gr.Button(value=\"Stage1 Run\")\n                with gr.Column():\n                    llave_button = gr.Button(value=\"LlaVa Run\")\n                with gr.Column():\n                    diffusion_button = gr.Button(value=\"Stage2 Run\")\n            with gr.Row():\n                with gr.Column():\n                    param_setting = gr.Dropdown([\"Quality\", \"Fidelity\"], interactive=True, label=\"Param Setting\",\n                                               value=\"Quality\")\n                with gr.Column():\n                    restart_button = gr.Button(value=\"Reset Param\", scale=2)\n            with gr.Accordion(\"Feedback\", open=True):\n                fb_score = gr.Slider(label=\"Feedback Score\", minimum=1, maximum=5, value=3, step=1,\n                                     interactive=True)\n                fb_text = gr.Textbox(label=\"Feedback Text\", value=\"\", placeholder='Please enter your feedback here.')\n                submit_button = gr.Button(value=\"Submit Feedback\")\n    with gr.Row():\n        gr.Markdown(claim_md)\n        event_id = gr.Textbox(label=\"Event ID\", value=\"\", visible=False)\n\n    llave_button.click(fn=llave_process, inputs=[denoise_image, temperature, top_p, qs], outputs=[prompt])\n    denoise_button.click(fn=stage1_process, inputs=[input_image, gamma_correction],\n                         outputs=[denoise_image])\n    stage2_ips = [input_image, prompt, a_prompt, n_prompt, num_samples, upscale, edm_steps, s_stage1, s_stage2,\n                  s_cfg, seed, s_churn, s_noise, color_fix_type, diff_dtype, ae_dtype, gamma_correction,\n                  linear_CFG, linear_s_stage2, spt_linear_CFG, spt_linear_s_stage2, model_select]\n    diffusion_button.click(fn=stage2_process, inputs=stage2_ips, outputs=[result_gallery, event_id, fb_score, fb_text])\n    restart_button.click(fn=load_and_reset, inputs=[param_setting],\n                         outputs=[edm_steps, s_cfg, s_stage2, s_stage1, s_churn, s_noise, a_prompt, n_prompt,\n                                  color_fix_type, linear_CFG, linear_s_stage2, spt_linear_CFG, spt_linear_s_stage2])\n    submit_button.click(fn=submit_feedback, inputs=[event_id, fb_score, fb_text], outputs=[fb_text])\nblock.launch(server_name=server_ip, server_port=server_port)\n"
        },
        {
          "name": "gradio_demo_face.py",
          "type": "blob",
          "size": 21.9326171875,
          "content": "import os\n\nimport gradio as gr\nfrom gradio_imageslider import ImageSlider\nimport argparse\nfrom SUPIR.util import HWC3, upscale_image, fix_resize, convert_dtype\nimport numpy as np\nimport torch\nfrom SUPIR.util import create_SUPIR_model, load_QF_ckpt\nfrom PIL import Image\nfrom llava.llava_agent import LLavaAgent\nfrom CKPT_PTH import LLAVA_MODEL_PATH\nimport einops\nimport copy\nimport time\nfrom omegaconf import OmegaConf\nfrom SUPIR.utils.face_restoration_helper import FaceRestoreHelper\n\nparser = argparse.ArgumentParser()\nparser.add_argument(\"--ip\", type=str, default='127.0.0.1')\nparser.add_argument(\"--port\", type=int, default='6688')\nparser.add_argument(\"--no_llava\", action='store_true', default=False)\nparser.add_argument(\"--use_image_slider\", action='store_true', default=False)\nparser.add_argument(\"--log_history\", action='store_true', default=False)\nparser.add_argument(\"--loading_half_params\", action='store_true', default=False)\nparser.add_argument(\"--use_tile_vae\", action='store_true', default=False)\nparser.add_argument(\"--load_8bit_llava\", action='store_true', default=False)\nparser.add_argument(\"--local_prompt\", action='store_true', default=False)\nargs = parser.parse_args()\nserver_ip = args.ip\nserver_port = args.port\nuse_llava = not args.no_llava\n\nif torch.cuda.device_count() >= 2:\n    SUPIR_device = 'cuda:0'\n    LLaVA_device = 'cuda:1'\nelif torch.cuda.device_count() == 1:\n    SUPIR_device = 'cuda:0'\n    LLaVA_device = 'cuda:0'\nelse:\n    raise ValueError('Currently support CUDA only.')\n\n# load SUPIR\nconfig_path = 'options/SUPIR_v0.yaml'\nconfig = OmegaConf.load(config_path)\nmodel = create_SUPIR_model(config_path, SUPIR_sign='Q')\nif args.loading_half_params:\n    model = model.half()\nif args.use_tile_vae:\n    model.init_tile_vae(encoder_tile_size=512, decoder_tile_size=64)\nmodel = model.to(SUPIR_device)\nmodel.first_stage_model.denoise_encoder_s1 = copy.deepcopy(model.first_stage_model.denoise_encoder)\nmodel.current_model = 'v0-Q'\nckpt_Q, ckpt_F = load_QF_ckpt('options/SUPIR_v0.yaml')\n\n# load LLaVA\nif use_llava:\n    llava_agent = LLavaAgent(LLAVA_MODEL_PATH, device=LLaVA_device, load_8bit=args.load_8bit_llava, load_4bit=False)\nelse:\n    llava_agent = None\n\n# load face helper\nface_helper = FaceRestoreHelper(\n        device=SUPIR_device,\n        upscale_factor=1,\n        face_size=1024,\n        use_parse=True,\n        det_model='retinaface_resnet50'\n    )\n\n# only exhibit the overall quality of the stage1 output\ndef stage1_process(input_image, gamma_correction):\n    torch.cuda.set_device(SUPIR_device)\n    LQ = HWC3(input_image)\n    LQ = fix_resize(LQ, 512)\n    # stage1\n    LQ = np.array(LQ) / 255 * 2 - 1\n    LQ = torch.tensor(LQ, dtype=torch.float32).permute(2, 0, 1).unsqueeze(0).to(SUPIR_device)[:, :3, :, :]\n    LQ = model.batchify_denoise(LQ, is_stage1=True)\n    LQ = (LQ[0].permute(1, 2, 0) * 127.5 + 127.5).cpu().numpy().round().clip(0, 255).astype(np.uint8)\n    # gamma correction\n    LQ = LQ / 255.0\n    LQ = np.power(LQ, gamma_correction)\n    LQ *= 255.0\n    LQ = LQ.round().clip(0, 255).astype(np.uint8)\n    return LQ\n\ndef llave_process(input_image, upscale, temperature, top_p, qs=None):\n    torch.cuda.set_device(SUPIR_device)\n    input_image = HWC3(input_image)\n    input_image = upscale_image(input_image, upscale, unit_resolution=32,\n                                min_size=1024)\n    LQ = np.array(input_image) / 255 * 2 - 1\n    LQ = torch.tensor(LQ, dtype=torch.float32).permute(2, 0, 1).unsqueeze(0).to(SUPIR_device)[:, :3, :, :]\n    LQ = model.batchify_denoise(LQ, is_stage1=True)\n\n    LQ = (LQ[0].permute(1, 2, 0) * 127.5 + 127.5).cpu().numpy().round().clip(0, 255).astype(np.uint8)\n    LQs = [Image.fromarray(LQ)]\n\n    face_helper.clean_all()\n    face_helper.read_image(LQ)\n    # get face landmarks for each face\n    face_helper.get_face_landmarks_5(only_center_face=False, resize=640, eye_dist_threshold=5)\n    face_helper.align_warp_face()\n\n    for face in face_helper.cropped_faces:\n        LQs.append(Image.fromarray(face))\n\n    captions = []\n    torch.cuda.set_device(LLaVA_device)\n    if use_llava:\n        for LQ in LQs:\n            captions += llava_agent.gen_image_caption([LQ], temperature=temperature, top_p=top_p, qs=qs)\n    else:\n        captions = ['LLaVA is not available. Please add text manually.']\n    del LQs[0]\n    return str(captions), [np.array(face) for face in LQs]\n\n\ndef stage2_process(input_image, prompt, a_prompt, n_prompt, num_samples, upscale, edm_steps, s_stage1, s_stage2,\n                   s_cfg, seed, s_churn, s_noise, color_fix_type, diff_dtype, ae_dtype, gamma_correction,\n                   linear_CFG, linear_s_stage2, spt_linear_CFG, spt_linear_s_stage2, model_select,\n                   face_resolution, apply_bg, apply_face):\n    torch.cuda.set_device(SUPIR_device)\n    event_id = str(time.time_ns())\n    event_dict = {'event_id': event_id, 'localtime': time.ctime(), 'prompt': prompt, 'a_prompt': a_prompt,\n                  'n_prompt': n_prompt, 'num_samples': num_samples, 'upscale': upscale, 'edm_steps': edm_steps,\n                  's_stage1': s_stage1, 's_stage2': s_stage2, 's_cfg': s_cfg, 'seed': seed, 's_churn': s_churn,\n                  's_noise': s_noise, 'color_fix_type': color_fix_type, 'diff_dtype': diff_dtype, 'ae_dtype': ae_dtype,\n                  'gamma_correction': gamma_correction, 'linear_CFG': linear_CFG, 'linear_s_stage2': linear_s_stage2,\n                  'spt_linear_CFG': spt_linear_CFG, 'spt_linear_s_stage2': spt_linear_s_stage2,\n                  'model_select': model_select}\n\n    if model_select != model.current_model:\n        if model_select == 'v0-Q':\n            print('load v0-Q')\n            model.load_state_dict(ckpt_Q, strict=False)\n            model.current_model = 'v0-Q'\n        elif model_select == 'v0-F':\n            print('load v0-F')\n            model.load_state_dict(ckpt_F, strict=False)\n            model.current_model = 'v0-F'\n    input_image = HWC3(input_image)\n    input_image = upscale_image(input_image, upscale, unit_resolution=32,\n                                min_size=1024)\n\n    LQ = np.array(input_image)\n    face_helper.clean_all()\n    face_helper.read_image(LQ)\n    # get face landmarks for each face\n    face_helper.get_face_landmarks_5(only_center_face=False, resize=640, eye_dist_threshold=5)\n    face_helper.align_warp_face()\n\n    LQ = LQ / 255 * 2 - 1\n    LQ = torch.tensor(LQ, dtype=torch.float32).permute(2, 0, 1).unsqueeze(0).to(SUPIR_device)[:, :3, :, :]\n\n    if use_llava and prompt != '':\n        captions = eval(prompt)\n    else:\n        captions = [''] * (1 + len(face_helper.cropped_faces))\n\n    bg_caption, face_captions = captions[0], captions[1:]\n\n    model.ae_dtype = convert_dtype(ae_dtype)\n    model.model.dtype = convert_dtype(diff_dtype)\n\n    _faces = []\n    if apply_face:\n        faces = []\n        for face in face_helper.cropped_faces:\n            _faces.append(face)\n            face = np.array(face) / 255 * 2 - 1\n            face = torch.tensor(face, dtype=torch.float32).permute(2, 0, 1).unsqueeze(0).to(SUPIR_device)[:, :3, :, :]\n            faces.append(face)\n\n        for face, caption in zip(faces, face_captions):\n            caption = [caption]\n\n            from torch.nn.functional import interpolate\n            face = interpolate(face, size=face_resolution, mode='bilinear', align_corners=False)\n            if face_resolution < 1024:\n                face = torch.nn.functional.pad(face, (512-face_resolution//2, 512-face_resolution//2,\n                                                      512-face_resolution//2, 512-face_resolution//2), 'constant', 0)\n\n            samples = model.batchify_sample(face, caption, num_steps=edm_steps, restoration_scale=s_stage1, s_churn=s_churn,\n                                            s_noise=s_noise, cfg_scale=s_cfg, control_scale=s_stage2, seed=seed,\n                                            num_samples=num_samples, p_p=a_prompt, n_p=n_prompt, color_fix_type=color_fix_type,\n                                            use_linear_CFG=linear_CFG, use_linear_control_scale=linear_s_stage2,\n                                            cfg_scale_start=spt_linear_CFG, control_scale_start=spt_linear_s_stage2)\n            if face_resolution < 1024:\n                samples = samples[:, :, 512-face_resolution//2:512+face_resolution//2,\n                          512-face_resolution//2:512+face_resolution//2]\n            samples = interpolate(samples, size=face_helper.face_size, mode='bilinear', align_corners=False)\n            x_samples = (einops.rearrange(samples, 'b c h w -> b h w c') * 127.5 + 127.5).cpu().numpy().round().clip(\n                0, 255).astype(np.uint8)\n\n            face_helper.add_restored_face(x_samples[0])\n            _faces.append(x_samples[0])\n\n        if apply_bg:\n            caption = [bg_caption]\n            samples = model.batchify_sample(LQ, caption, num_steps=edm_steps, restoration_scale=s_stage1,\n                                            s_churn=s_churn,\n                                            s_noise=s_noise, cfg_scale=s_cfg, control_scale=s_stage2, seed=seed,\n                                            num_samples=num_samples, p_p=a_prompt, n_p=n_prompt,\n                                            color_fix_type=color_fix_type,\n                                            use_linear_CFG=linear_CFG, use_linear_control_scale=linear_s_stage2,\n                                            cfg_scale_start=spt_linear_CFG, control_scale_start=spt_linear_s_stage2)\n        else:\n            samples = LQ\n        _bg = (einops.rearrange(samples, 'b c h w -> b h w c') * 127.5 + 127.5).cpu().numpy().round().clip(\n            0, 255).astype(np.uint8)\n        face_helper.get_inverse_affine(None)\n        results = [face_helper.paste_faces_to_input_image(upsample_img=_bg[0])]\n    else:\n        caption = [bg_caption]\n        samples = model.batchify_sample(LQ, caption, num_steps=edm_steps, restoration_scale=s_stage1,\n                                        s_churn=s_churn,\n                                        s_noise=s_noise, cfg_scale=s_cfg, control_scale=s_stage2, seed=seed,\n                                        num_samples=num_samples, p_p=a_prompt, n_p=n_prompt,\n                                        color_fix_type=color_fix_type,\n                                        use_linear_CFG=linear_CFG, use_linear_control_scale=linear_s_stage2,\n                                        cfg_scale_start=spt_linear_CFG, control_scale_start=spt_linear_s_stage2)\n        x_samples = (einops.rearrange(samples, 'b c h w -> b h w c') * 127.5 + 127.5).cpu().numpy().round().clip(\n            0, 255).astype(np.uint8)\n        results = [x_samples[0]]\n\n    if args.log_history:\n        os.makedirs(f'./history/{event_id[:5]}/{event_id[5:]}', exist_ok=True)\n        with open(f'./history/{event_id[:5]}/{event_id[5:]}/logs.txt', 'w') as f:\n            f.write(str(event_dict))\n        f.close()\n        Image.fromarray(input_image).save(f'./history/{event_id[:5]}/{event_id[5:]}/LQ.png')\n        for i, result in enumerate(results):\n            Image.fromarray(result).save(f'./history/{event_id[:5]}/{event_id[5:]}/HQ_{i}.png')\n    return [input_image] + results, event_id, 3, '', _faces\n\ndef load_and_reset(param_setting):\n    edm_steps = 50\n    s_stage2 = 1.0\n    s_stage1 = -1.0\n    s_churn = 5\n    s_noise = 1.003\n    a_prompt = 'Cinematic, High Contrast, highly detailed, taken using a Canon EOS R camera, hyper detailed photo - ' \\\n               'realistic maximum detail, 32k, Color Grading, ultra HD, extreme meticulous detailing, skin pore ' \\\n               'detailing, hyper sharpness, perfect without deformations.'\n    n_prompt = 'painting, oil painting, illustration, drawing, art, sketch, oil painting, cartoon, CG Style, ' \\\n               '3D render, unreal engine, blurring, dirty, messy, worst quality, low quality, frames, watermark, ' \\\n               'signature, jpeg artifacts, deformed, lowres, over-smooth'\n    color_fix_type = 'Wavelet'\n    spt_linear_s_stage2 = 0.0\n    linear_s_stage2 = False\n    linear_CFG = True\n    if param_setting == \"Quality\":\n        s_cfg = 7.5\n        spt_linear_CFG = 4.0\n    elif param_setting == \"Fidelity\":\n        s_cfg = 4.0\n        spt_linear_CFG = 1.0\n    else:\n        raise NotImplementedError\n    return edm_steps, s_cfg, s_stage2, s_stage1, s_churn, s_noise, a_prompt, n_prompt, color_fix_type, linear_CFG, \\\n        linear_s_stage2, spt_linear_CFG, spt_linear_s_stage2\n\n\ndef submit_feedback(event_id, fb_score, fb_text):\n    if args.log_history:\n        with open(f'./history/{event_id[:5]}/{event_id[5:]}/logs.txt', 'r') as f:\n            event_dict = eval(f.read())\n        f.close()\n        event_dict['feedback'] = {'score': fb_score, 'text': fb_text}\n        with open(f'./history/{event_id[:5]}/{event_id[5:]}/logs.txt', 'w') as f:\n            f.write(str(event_dict))\n        f.close()\n        return 'Submit successfully, thank you for your comments!'\n    else:\n        return 'Submit failed, the server is not set to log history.'\n\ntitle_md = \"\"\"\n# **SUPIR: Practicing Model Scaling for Photo-Realistic Image Restoration**\n\n‚ö†Ô∏èSUPIR is still a research project under tested and is not yet a stable commercial product.\n\n[[Paper](https://arxiv.org/abs/2401.13627)] &emsp; [[Project Page](http://supir.xpixel.group/)] &emsp; [[How to play](https://github.com/Fanghua-Yu/SUPIR/blob/master/assets/DemoGuide.png)]\n\"\"\"\n\n\nclaim_md = \"\"\"\n## **Terms of use**\n\nBy using this service, users are required to agree to the following terms: The service is a research preview intended for non-commercial use only. It only provides limited safety measures and may generate offensive content. It must not be used for any illegal, harmful, violent, racist, or sexual purposes. The service may collect user dialogue data for future research. Please submit a feedback to us if you get any inappropriate answer! We will collect those to keep improving our models. For an optimal experience, please use desktop computers for this demo, as mobile devices may compromise its quality.\n\n## **License**\n\nThe service is a research preview intended for non-commercial use only, subject to the model [License](https://github.com/Fanghua-Yu/SUPIR) of SUPIR.\n\"\"\"\n\n\nblock = gr.Blocks(title='SUPIR').queue()\nwith block:\n    with gr.Row():\n        gr.Markdown(title_md)\n    with gr.Row():\n        with gr.Column():\n            with gr.Row(equal_height=True):\n                with gr.Column():\n                    gr.Markdown(\"<center>Input</center>\")\n                    input_image = gr.Image(type=\"numpy\", elem_id=\"image-input\", height=400, width=400)\n                with gr.Column():\n                    gr.Markdown(\"<center>Stage1 Output</center>\")\n                    denoise_image = gr.Image(type=\"numpy\", elem_id=\"image-s1\", height=400, width=400)\n            prompt = gr.Textbox(label=\"Prompt\", value=\"\")\n            with gr.Accordion(\"Stage1 options\", open=False):\n                gamma_correction = gr.Slider(label=\"Gamma Correction\", minimum=0.1, maximum=2.0, value=1.0, step=0.1)\n            with gr.Accordion(\"LLaVA options\", open=False):\n                temperature = gr.Slider(label=\"Temperature\", minimum=0., maximum=1.0, value=0.2, step=0.1)\n                top_p = gr.Slider(label=\"Top P\", minimum=0., maximum=1.0, value=0.7, step=0.1)\n                qs = gr.Textbox(label=\"Question\", value=\"Describe this image and its style in a very detailed manner. \"\n                                                        \"The image is a realistic photography, not an art painting.\")\n            with gr.Accordion(\"Stage2 options\", open=False):\n                num_samples = gr.Slider(label=\"Num Samples\", minimum=1, maximum=4 if not args.use_image_slider else 1\n                                        , value=1, step=1)\n                upscale = gr.Slider(label=\"Upscale\", minimum=1, maximum=8, value=1, step=1)\n                edm_steps = gr.Slider(label=\"Steps\", minimum=20, maximum=200, value=50, step=1)\n                s_cfg = gr.Slider(label=\"Text Guidance Scale\", minimum=1.0, maximum=15.0, value=7.5, step=0.1)\n                s_stage2 = gr.Slider(label=\"Stage2 Guidance Strength\", minimum=0., maximum=1., value=1., step=0.05)\n                s_stage1 = gr.Slider(label=\"Stage1 Guidance Strength\", minimum=-1.0, maximum=6.0, value=-1.0, step=1.0)\n                seed = gr.Slider(label=\"Seed\", minimum=-1, maximum=2147483647, step=1, randomize=True)\n                s_churn = gr.Slider(label=\"S-Churn\", minimum=0, maximum=40, value=5, step=1)\n                s_noise = gr.Slider(label=\"S-Noise\", minimum=1.0, maximum=1.1, value=1.003, step=0.001)\n                a_prompt = gr.Textbox(label=\"Default Positive Prompt\",\n                                      value='Cinematic, High Contrast, highly detailed, taken using a Canon EOS R '\n                                            'camera, hyper detailed photo - realistic maximum detail, 32k, Color '\n                                            'Grading, ultra HD, extreme meticulous detailing, skin pore detailing, '\n                                            'hyper sharpness, perfect without deformations.')\n                n_prompt = gr.Textbox(label=\"Default Negative Prompt\",\n                                      value='painting, oil painting, illustration, drawing, art, sketch, oil painting, '\n                                            'cartoon, CG Style, 3D render, unreal engine, blurring, dirty, messy, '\n                                            'worst quality, low quality, frames, watermark, signature, jpeg artifacts, '\n                                            'deformed, lowres, over-smooth')\n                with gr.Row():\n                    with gr.Column():\n                        linear_CFG = gr.Checkbox(label=\"Linear CFG\", value=True)\n                        spt_linear_CFG = gr.Slider(label=\"CFG Start\", minimum=1.0,\n                                                        maximum=9.0, value=4.0, step=0.5)\n                    with gr.Column():\n                        linear_s_stage2 = gr.Checkbox(label=\"Linear Stage2 Guidance\", value=False)\n                        spt_linear_s_stage2 = gr.Slider(label=\"Guidance Start\", minimum=0.,\n                                                        maximum=1., value=0., step=0.05)\n                with gr.Row():\n                    with gr.Column():\n                        diff_dtype = gr.Radio(['fp32', 'fp16', 'bf16'], label=\"Diffusion Data Type\", value=\"fp16\",\n                                              interactive=True)\n                    with gr.Column():\n                        ae_dtype = gr.Radio(['fp32', 'bf16'], label=\"Auto-Encoder Data Type\", value=\"bf16\",\n                                            interactive=True)\n                    with gr.Column():\n                        color_fix_type = gr.Radio([\"None\", \"AdaIn\", \"Wavelet\"], label=\"Color-Fix Type\", value=\"Wavelet\",\n                                                  interactive=True)\n                    with gr.Column():\n                        model_select = gr.Radio([\"v0-Q\", \"v0-F\"], label=\"Model Selection\", value=\"v0-Q\",\n                                                interactive=True)\n\n        with gr.Column():\n            gr.Markdown(\"<center>Stage2 Output</center>\")\n            if not args.use_image_slider:\n                result_gallery = gr.Gallery(label='Output', show_label=False, elem_id=\"gallery1\")\n            else:\n                result_gallery = ImageSlider(label='Output', show_label=False, elem_id=\"gallery1\")\n            with gr.Row():\n                with gr.Column():\n                    denoise_button = gr.Button(value=\"Stage1 Run\")\n                with gr.Column():\n                    llave_button = gr.Button(value=\"LlaVa Run\")\n                with gr.Column():\n                    diffusion_button = gr.Button(value=\"Stage2 Run\")\n            with gr.Row():\n                with gr.Column():\n                    param_setting = gr.Dropdown([\"Quality\", \"Fidelity\"], interactive=True, label=\"Param Setting\",\n                                               value=\"Quality\")\n                with gr.Column():\n                    restart_button = gr.Button(value=\"Reset Param\", scale=2)\n            with gr.Accordion(\"Face Options\", open=True):\n                face_resolution = gr.Slider(label=\"Text Guidance Scale\", minimum=256, maximum=2048, value=1024, step=32)\n                with gr.Row():\n                    with gr.Column():\n                        apply_bg = gr.Checkbox(label=\"BG restoration\", value=True)\n                    with gr.Column():\n                        apply_face = gr.Checkbox(label=\"Face restoration\", value=True)\n            with gr.Accordion(\"Feedback\", open=False):\n                fb_score = gr.Slider(label=\"Feedback Score\", minimum=1, maximum=5, value=3, step=1,\n                                     interactive=True)\n                fb_text = gr.Textbox(label=\"Feedback Text\", value=\"\", placeholder='Please enter your feedback here.')\n                submit_button = gr.Button(value=\"Submit Feedback\")\n            face_gallery = gr.Gallery(label='Faces', show_label=False, elem_id=\"gallery2\")\n    with gr.Row():\n        gr.Markdown(claim_md)\n        event_id = gr.Textbox(label=\"Event ID\", value=\"\", visible=False)\n\n    llave_button.click(fn=llave_process, inputs=[input_image, upscale, temperature, top_p, qs], outputs=[prompt, face_gallery])\n    denoise_button.click(fn=stage1_process, inputs=[input_image, gamma_correction],\n                         outputs=[denoise_image])\n    stage2_ips = [input_image, prompt, a_prompt, n_prompt, num_samples, upscale, edm_steps, s_stage1, s_stage2,\n                  s_cfg, seed, s_churn, s_noise, color_fix_type, diff_dtype, ae_dtype, gamma_correction,\n                  linear_CFG, linear_s_stage2, spt_linear_CFG, spt_linear_s_stage2, model_select, face_resolution, apply_bg, apply_face]\n    diffusion_button.click(fn=stage2_process, inputs=stage2_ips, outputs=[result_gallery, event_id, fb_score, fb_text, face_gallery])\n    restart_button.click(fn=load_and_reset, inputs=[param_setting],\n                         outputs=[edm_steps, s_cfg, s_stage2, s_stage1, s_churn, s_noise, a_prompt, n_prompt,\n                                  color_fix_type, linear_CFG, linear_s_stage2, spt_linear_CFG, spt_linear_s_stage2])\n    submit_button.click(fn=submit_feedback, inputs=[event_id, fb_score, fb_text], outputs=[fb_text])\nblock.launch(server_name=server_ip, server_port=server_port)\n"
        },
        {
          "name": "gradio_demo_tiled.py",
          "type": "blob",
          "size": 17.9931640625,
          "content": "import os\n\nimport gradio as gr\nfrom gradio_imageslider import ImageSlider\nimport argparse\nfrom SUPIR.util import HWC3, upscale_image, fix_resize, convert_dtype\nimport numpy as np\nimport torch\nfrom SUPIR.util import create_SUPIR_model, load_QF_ckpt\nfrom PIL import Image\nfrom llava.llava_agent import LLavaAgent\nfrom CKPT_PTH import LLAVA_MODEL_PATH\nimport einops\nimport copy\nimport time\nfrom omegaconf import OmegaConf\nfrom sgm.modules.diffusionmodules.sampling import _sliding_windows\n\nparser = argparse.ArgumentParser()\nparser.add_argument(\"--ip\", type=str, default='127.0.0.1')\nparser.add_argument(\"--port\", type=int, default='6688')\nparser.add_argument(\"--no_llava\", action='store_true', default=False)\nparser.add_argument(\"--use_image_slider\", action='store_true', default=False)\nparser.add_argument(\"--log_history\", action='store_true', default=False)\nparser.add_argument(\"--loading_half_params\", action='store_true', default=False)\nparser.add_argument(\"--use_tile_vae\", action='store_true', default=False)\nparser.add_argument(\"--encoder_tile_size\", type=int, default=512)\nparser.add_argument(\"--decoder_tile_size\", type=int, default=64)\nparser.add_argument(\"--load_8bit_llava\", action='store_true', default=False)\nparser.add_argument(\"--local_prompt\", action='store_true', default=False)\nargs = parser.parse_args()\nserver_ip = args.ip\nserver_port = args.port\nuse_llava = not args.no_llava\n\nif torch.cuda.device_count() >= 2:\n    SUPIR_device = 'cuda:0'\n    LLaVA_device = 'cuda:1'\nelif torch.cuda.device_count() == 1:\n    SUPIR_device = 'cuda:0'\n    LLaVA_device = 'cuda:0'\nelse:\n    raise ValueError('Currently support CUDA only.')\n\n# load SUPIR\nconfig_path = 'options/SUPIR_v0_tiled.yaml'\nconfig = OmegaConf.load(config_path)\nmodel = create_SUPIR_model(config_path, SUPIR_sign='Q')\nif args.loading_half_params:\n    model = model.half()\nif args.use_tile_vae:\n    model.init_tile_vae(encoder_tile_size=512, decoder_tile_size=64)\nmodel = model.to(SUPIR_device)\nmodel.first_stage_model.denoise_encoder_s1 = copy.deepcopy(model.first_stage_model.denoise_encoder)\nmodel.current_model = 'v0-Q'\nckpt_Q, ckpt_F = load_QF_ckpt('options/SUPIR_v0.yaml')\n\ntile_size = config.model.params.sampler_config.params.tile_size * 8\ntile_stride = config.model.params.sampler_config.params.tile_stride * 8\n\n# load LLaVA\nif use_llava:\n    llava_agent = LLavaAgent(LLAVA_MODEL_PATH, device=LLaVA_device, load_8bit=args.load_8bit_llava, load_4bit=False)\nelse:\n    llava_agent = None\n\n# only exhibit the overall quality of the stage1 output\ndef stage1_process(input_image, gamma_correction):\n    torch.cuda.set_device(SUPIR_device)\n    LQ = HWC3(input_image)\n    LQ = fix_resize(LQ, 512)\n    # stage1\n    LQ = np.array(LQ) / 255 * 2 - 1\n    LQ = torch.tensor(LQ, dtype=torch.float32).permute(2, 0, 1).unsqueeze(0).to(SUPIR_device)[:, :3, :, :]\n    LQ = model.batchify_denoise(LQ, is_stage1=True)\n    LQ = (LQ[0].permute(1, 2, 0) * 127.5 + 127.5).cpu().numpy().round().clip(0, 255).astype(np.uint8)\n    # gamma correction\n    LQ = LQ / 255.0\n    LQ = np.power(LQ, gamma_correction)\n    LQ *= 255.0\n    LQ = LQ.round().clip(0, 255).astype(np.uint8)\n    return LQ\n\ndef llave_process(input_image, upscale, temperature, top_p, qs=None):\n    torch.cuda.set_device(SUPIR_device)\n    input_image = HWC3(input_image)\n    input_image = upscale_image(input_image, upscale, unit_resolution=32,\n                                min_size=1024)\n    LQ = np.array(input_image) / 255.0\n    LQ *= 255.0\n    LQ = LQ.round().clip(0, 255).astype(np.uint8)\n    LQ = LQ / 255 * 2 - 1\n    LQ = torch.tensor(LQ, dtype=torch.float32).permute(2, 0, 1).unsqueeze(0).to(SUPIR_device)[:, :3, :, :]\n    LQ = model.batchify_denoise(LQ, is_stage1=True)\n\n    _, _, h, w = LQ.shape\n    tiles_iterator = _sliding_windows(h, w, tile_size, tile_stride)\n    LQ_tiles = []\n    for hi, hi_end, wi, wi_end in tiles_iterator:\n        _LQ = LQ[:, :, hi:hi_end, wi:wi_end]\n        _LQ = (_LQ[0].permute(1, 2, 0) * 127.5 + 127.5).cpu().numpy().round().clip(0, 255).astype(np.uint8)\n        LQ_tiles.append(Image.fromarray(_LQ))\n\n    captions = []\n    torch.cuda.set_device(LLaVA_device)\n    if use_llava:\n        for LQ_tile in LQ_tiles:\n            captions += llava_agent.gen_image_caption([LQ_tile], temperature=temperature, top_p=top_p, qs=qs)\n    else:\n        captions = 'LLaVA is not available. Please add text manually.'\n    return str(captions)\n\n\ndef stage2_process(input_image, prompt, a_prompt, n_prompt, num_samples, upscale, edm_steps, s_stage1, s_stage2,\n                   s_cfg, seed, s_churn, s_noise, color_fix_type, diff_dtype, ae_dtype, gamma_correction,\n                   linear_CFG, linear_s_stage2, spt_linear_CFG, spt_linear_s_stage2, model_select):\n    torch.cuda.set_device(SUPIR_device)\n    event_id = str(time.time_ns())\n    event_dict = {'event_id': event_id, 'localtime': time.ctime(), 'prompt': prompt, 'a_prompt': a_prompt,\n                  'n_prompt': n_prompt, 'num_samples': num_samples, 'upscale': upscale, 'edm_steps': edm_steps,\n                  's_stage1': s_stage1, 's_stage2': s_stage2, 's_cfg': s_cfg, 'seed': seed, 's_churn': s_churn,\n                  's_noise': s_noise, 'color_fix_type': color_fix_type, 'diff_dtype': diff_dtype, 'ae_dtype': ae_dtype,\n                  'gamma_correction': gamma_correction, 'linear_CFG': linear_CFG, 'linear_s_stage2': linear_s_stage2,\n                  'spt_linear_CFG': spt_linear_CFG, 'spt_linear_s_stage2': spt_linear_s_stage2,\n                  'model_select': model_select}\n\n    if model_select != model.current_model:\n        if model_select == 'v0-Q':\n            print('load v0-Q')\n            model.load_state_dict(ckpt_Q, strict=False)\n            model.current_model = 'v0-Q'\n        elif model_select == 'v0-F':\n            print('load v0-F')\n            model.load_state_dict(ckpt_F, strict=False)\n            model.current_model = 'v0-F'\n    input_image = HWC3(input_image)\n    input_image = upscale_image(input_image, upscale, unit_resolution=32,\n                                min_size=1024)\n\n    LQ = np.array(input_image) / 255.0\n    LQ = np.power(LQ, gamma_correction)\n    LQ *= 255.0\n    LQ = LQ.round().clip(0, 255).astype(np.uint8)\n    LQ = LQ / 255 * 2 - 1\n    LQ = torch.tensor(LQ, dtype=torch.float32).permute(2, 0, 1).unsqueeze(0).to(SUPIR_device)[:, :3, :, :]\n    if use_llava:\n        captions = [eval(prompt)]\n    else:\n        captions = ['']\n\n    model.ae_dtype = convert_dtype(ae_dtype)\n    model.model.dtype = convert_dtype(diff_dtype)\n\n    samples = model.batchify_sample(LQ, captions, num_steps=edm_steps, restoration_scale=s_stage1, s_churn=s_churn,\n                                    s_noise=s_noise, cfg_scale=s_cfg, control_scale=s_stage2, seed=seed,\n                                    num_samples=num_samples, p_p=a_prompt, n_p=n_prompt, color_fix_type=color_fix_type,\n                                    use_linear_CFG=linear_CFG, use_linear_control_scale=linear_s_stage2,\n                                    cfg_scale_start=spt_linear_CFG, control_scale_start=spt_linear_s_stage2)\n\n    x_samples = (einops.rearrange(samples, 'b c h w -> b h w c') * 127.5 + 127.5).cpu().numpy().round().clip(\n        0, 255).astype(np.uint8)\n    results = [x_samples[i] for i in range(num_samples)]\n\n    if args.log_history:\n        os.makedirs(f'./history/{event_id[:5]}/{event_id[5:]}', exist_ok=True)\n        with open(f'./history/{event_id[:5]}/{event_id[5:]}/logs.txt', 'w') as f:\n            f.write(str(event_dict))\n        f.close()\n        Image.fromarray(input_image).save(f'./history/{event_id[:5]}/{event_id[5:]}/LQ.png')\n        for i, result in enumerate(results):\n            Image.fromarray(result).save(f'./history/{event_id[:5]}/{event_id[5:]}/HQ_{i}.png')\n    return [input_image] + results, event_id, 3, ''\n\ndef load_and_reset(param_setting):\n    edm_steps = 50\n    s_stage2 = 1.0\n    s_stage1 = -1.0\n    s_churn = 5\n    s_noise = 1.003\n    a_prompt = 'Cinematic, High Contrast, highly detailed, taken using a Canon EOS R camera, hyper detailed photo - ' \\\n               'realistic maximum detail, 32k, Color Grading, ultra HD, extreme meticulous detailing, skin pore ' \\\n               'detailing, hyper sharpness, perfect without deformations.'\n    n_prompt = 'painting, oil painting, illustration, drawing, art, sketch, oil painting, cartoon, CG Style, ' \\\n               '3D render, unreal engine, blurring, dirty, messy, worst quality, low quality, frames, watermark, ' \\\n               'signature, jpeg artifacts, deformed, lowres, over-smooth'\n    color_fix_type = 'Wavelet'\n    spt_linear_s_stage2 = 0.0\n    linear_s_stage2 = False\n    linear_CFG = True\n    if param_setting == \"Quality\":\n        s_cfg = 7.5\n        spt_linear_CFG = 4.0\n    elif param_setting == \"Fidelity\":\n        s_cfg = 4.0\n        spt_linear_CFG = 1.0\n    else:\n        raise NotImplementedError\n    return edm_steps, s_cfg, s_stage2, s_stage1, s_churn, s_noise, a_prompt, n_prompt, color_fix_type, linear_CFG, \\\n        linear_s_stage2, spt_linear_CFG, spt_linear_s_stage2\n\n\ndef submit_feedback(event_id, fb_score, fb_text):\n    if args.log_history:\n        with open(f'./history/{event_id[:5]}/{event_id[5:]}/logs.txt', 'r') as f:\n            event_dict = eval(f.read())\n        f.close()\n        event_dict['feedback'] = {'score': fb_score, 'text': fb_text}\n        with open(f'./history/{event_id[:5]}/{event_id[5:]}/logs.txt', 'w') as f:\n            f.write(str(event_dict))\n        f.close()\n        return 'Submit successfully, thank you for your comments!'\n    else:\n        return 'Submit failed, the server is not set to log history.'\n\ntitle_md = \"\"\"\n# **SUPIR: Practicing Model Scaling for Photo-Realistic Image Restoration**\n\n‚ö†Ô∏èSUPIR is still a research project under tested and is not yet a stable commercial product.\n\n[[Paper](https://arxiv.org/abs/2401.13627)] &emsp; [[Project Page](http://supir.xpixel.group/)] &emsp; [[How to play](https://github.com/Fanghua-Yu/SUPIR/blob/master/assets/DemoGuide.png)]\n\"\"\"\n\n\nclaim_md = \"\"\"\n## **Terms of use**\n\nBy using this service, users are required to agree to the following terms: The service is a research preview intended for non-commercial use only. It only provides limited safety measures and may generate offensive content. It must not be used for any illegal, harmful, violent, racist, or sexual purposes. The service may collect user dialogue data for future research. Please submit a feedback to us if you get any inappropriate answer! We will collect those to keep improving our models. For an optimal experience, please use desktop computers for this demo, as mobile devices may compromise its quality.\n\n## **License**\n\nThe service is a research preview intended for non-commercial use only, subject to the model [License](https://github.com/Fanghua-Yu/SUPIR) of SUPIR.\n\"\"\"\n\n\nblock = gr.Blocks(title='SUPIR').queue()\nwith block:\n    with gr.Row():\n        gr.Markdown(title_md)\n    with gr.Row():\n        with gr.Column():\n            with gr.Row(equal_height=True):\n                with gr.Column():\n                    gr.Markdown(\"<center>Input</center>\")\n                    input_image = gr.Image(type=\"numpy\", elem_id=\"image-input\", height=400, width=400)\n                with gr.Column():\n                    gr.Markdown(\"<center>Stage1 Output</center>\")\n                    denoise_image = gr.Image(type=\"numpy\", elem_id=\"image-s1\", height=400, width=400)\n            prompt = gr.Textbox(label=\"Prompt\", value=\"\")\n            with gr.Accordion(\"Stage1 options\", open=False):\n                gamma_correction = gr.Slider(label=\"Gamma Correction\", minimum=0.1, maximum=2.0, value=1.0, step=0.1)\n            with gr.Accordion(\"LLaVA options\", open=False):\n                temperature = gr.Slider(label=\"Temperature\", minimum=0., maximum=1.0, value=0.2, step=0.1)\n                top_p = gr.Slider(label=\"Top P\", minimum=0., maximum=1.0, value=0.7, step=0.1)\n                qs = gr.Textbox(label=\"Question\", value=\"Describe this image and its style in a very detailed manner. \"\n                                                        \"The image is a realistic photography, not an art painting.\")\n            with gr.Accordion(\"Stage2 options\", open=False):\n                num_samples = gr.Slider(label=\"Num Samples\", minimum=1, maximum=4 if not args.use_image_slider else 1\n                                        , value=1, step=1)\n                upscale = gr.Slider(label=\"Upscale\", minimum=1, maximum=8, value=1, step=1)\n                edm_steps = gr.Slider(label=\"Steps\", minimum=20, maximum=200, value=50, step=1)\n                s_cfg = gr.Slider(label=\"Text Guidance Scale\", minimum=1.0, maximum=15.0, value=7.5, step=0.1)\n                s_stage2 = gr.Slider(label=\"Stage2 Guidance Strength\", minimum=0., maximum=1., value=1., step=0.05)\n                s_stage1 = gr.Slider(label=\"Stage1 Guidance Strength\", minimum=-1.0, maximum=6.0, value=-1.0, step=1.0)\n                seed = gr.Slider(label=\"Seed\", minimum=-1, maximum=2147483647, step=1, randomize=True)\n                s_churn = gr.Slider(label=\"S-Churn\", minimum=0, maximum=40, value=5, step=1)\n                s_noise = gr.Slider(label=\"S-Noise\", minimum=1.0, maximum=1.1, value=1.003, step=0.001)\n                a_prompt = gr.Textbox(label=\"Default Positive Prompt\",\n                                      value='Cinematic, High Contrast, highly detailed, taken using a Canon EOS R '\n                                            'camera, hyper detailed photo - realistic maximum detail, 32k, Color '\n                                            'Grading, ultra HD, extreme meticulous detailing, skin pore detailing, '\n                                            'hyper sharpness, perfect without deformations.')\n                n_prompt = gr.Textbox(label=\"Default Negative Prompt\",\n                                      value='painting, oil painting, illustration, drawing, art, sketch, oil painting, '\n                                            'cartoon, CG Style, 3D render, unreal engine, blurring, dirty, messy, '\n                                            'worst quality, low quality, frames, watermark, signature, jpeg artifacts, '\n                                            'deformed, lowres, over-smooth')\n                with gr.Row():\n                    with gr.Column():\n                        linear_CFG = gr.Checkbox(label=\"Linear CFG\", value=True)\n                        spt_linear_CFG = gr.Slider(label=\"CFG Start\", minimum=1.0,\n                                                        maximum=9.0, value=4.0, step=0.5)\n                    with gr.Column():\n                        linear_s_stage2 = gr.Checkbox(label=\"Linear Stage2 Guidance\", value=False)\n                        spt_linear_s_stage2 = gr.Slider(label=\"Guidance Start\", minimum=0.,\n                                                        maximum=1., value=0., step=0.05)\n                with gr.Row():\n                    with gr.Column():\n                        diff_dtype = gr.Radio(['fp32', 'fp16', 'bf16'], label=\"Diffusion Data Type\", value=\"fp16\",\n                                              interactive=True)\n                    with gr.Column():\n                        ae_dtype = gr.Radio(['fp32', 'bf16'], label=\"Auto-Encoder Data Type\", value=\"bf16\",\n                                            interactive=True)\n                    with gr.Column():\n                        color_fix_type = gr.Radio([\"None\", \"AdaIn\", \"Wavelet\"], label=\"Color-Fix Type\", value=\"Wavelet\",\n                                                  interactive=True)\n                    with gr.Column():\n                        model_select = gr.Radio([\"v0-Q\", \"v0-F\"], label=\"Model Selection\", value=\"v0-Q\",\n                                                interactive=True)\n\n        with gr.Column():\n            gr.Markdown(\"<center>Stage2 Output</center>\")\n            if not args.use_image_slider:\n                result_gallery = gr.Gallery(label='Output', show_label=False, elem_id=\"gallery1\")\n            else:\n                result_gallery = ImageSlider(label='Output', show_label=False, elem_id=\"gallery1\")\n            with gr.Row():\n                with gr.Column():\n                    denoise_button = gr.Button(value=\"Stage1 Run\")\n                with gr.Column():\n                    llave_button = gr.Button(value=\"LlaVa Run\")\n                with gr.Column():\n                    diffusion_button = gr.Button(value=\"Stage2 Run\")\n            with gr.Row():\n                with gr.Column():\n                    param_setting = gr.Dropdown([\"Quality\", \"Fidelity\"], interactive=True, label=\"Param Setting\",\n                                               value=\"Quality\")\n                with gr.Column():\n                    restart_button = gr.Button(value=\"Reset Param\", scale=2)\n            with gr.Accordion(\"Feedback\", open=True):\n                fb_score = gr.Slider(label=\"Feedback Score\", minimum=1, maximum=5, value=3, step=1,\n                                     interactive=True)\n                fb_text = gr.Textbox(label=\"Feedback Text\", value=\"\", placeholder='Please enter your feedback here.')\n                submit_button = gr.Button(value=\"Submit Feedback\")\n    with gr.Row():\n        gr.Markdown(claim_md)\n        event_id = gr.Textbox(label=\"Event ID\", value=\"\", visible=False)\n\n    llave_button.click(fn=llave_process, inputs=[input_image, upscale, temperature, top_p, qs], outputs=[prompt])\n    denoise_button.click(fn=stage1_process, inputs=[input_image, gamma_correction],\n                         outputs=[denoise_image])\n    stage2_ips = [input_image, prompt, a_prompt, n_prompt, num_samples, upscale, edm_steps, s_stage1, s_stage2,\n                  s_cfg, seed, s_churn, s_noise, color_fix_type, diff_dtype, ae_dtype, gamma_correction,\n                  linear_CFG, linear_s_stage2, spt_linear_CFG, spt_linear_s_stage2, model_select]\n    diffusion_button.click(fn=stage2_process, inputs=stage2_ips, outputs=[result_gallery, event_id, fb_score, fb_text])\n    restart_button.click(fn=load_and_reset, inputs=[param_setting],\n                         outputs=[edm_steps, s_cfg, s_stage2, s_stage1, s_churn, s_noise, a_prompt, n_prompt,\n                                  color_fix_type, linear_CFG, linear_s_stage2, spt_linear_CFG, spt_linear_s_stage2])\n    submit_button.click(fn=submit_feedback, inputs=[event_id, fb_score, fb_text], outputs=[fb_text])\nblock.launch(server_name=server_ip, server_port=server_port)\n"
        },
        {
          "name": "llava",
          "type": "tree",
          "content": null
        },
        {
          "name": "options",
          "type": "tree",
          "content": null
        },
        {
          "name": "requirements.txt",
          "type": "blob",
          "size": 0.7177734375,
          "content": "fastapi==0.95.1\ngradio==4.16.0\ngradio_imageslider==0.0.17\ngradio_client==0.8.1\nMarkdown==3.4.1\nnumpy==1.24.2\nrequests==2.28.2\nsentencepiece==0.1.98\ntokenizers==0.13.3\ntorch>=2.1.0\ntorchvision>=0.16.0\nuvicorn==0.21.1\nwandb==0.14.0\nhttpx==0.24.0\ntransformers==4.28.1\naccelerate==0.18.0\nscikit-learn==1.2.2\nsentencepiece==0.1.98\neinops==0.7.0\neinops-exts==0.0.4\ntimm==0.9.8\nopenai-clip==1.0.1\nfsspec==2023.4.0\nkornia==0.6.9\nmatplotlib==3.7.1\nninja==1.11.1\nomegaconf==2.3.0\nopen-clip-torch==2.17.1\nopencv-python==4.7.0.72\npandas==2.0.1\nPillow==9.4.0\npytorch-lightning==2.1.2\nPyYAML==6.0\nscipy==1.9.1\ntqdm==4.65.0\ntriton==2.1.0\nurllib3==1.26.15\nwebdataset==0.2.48\nxformers>=0.0.20\nfacexlib==0.3.0\nk-diffusion==0.1.1.post1\ndiffusers==0.16.1\n"
        },
        {
          "name": "sgm",
          "type": "tree",
          "content": null
        },
        {
          "name": "test.py",
          "type": "blob",
          "size": 5.294921875,
          "content": "import torch.cuda\nimport argparse\nfrom SUPIR.util import create_SUPIR_model, PIL2Tensor, Tensor2PIL, convert_dtype\nfrom PIL import Image\nfrom llava.llava_agent import LLavaAgent\nfrom CKPT_PTH import LLAVA_MODEL_PATH\nimport os\nfrom torch.nn.functional import interpolate\n\nif torch.cuda.device_count() >= 2:\n    SUPIR_device = 'cuda:0'\n    LLaVA_device = 'cuda:1'\nelif torch.cuda.device_count() == 1:\n    SUPIR_device = 'cuda:0'\n    LLaVA_device = 'cuda:0'\nelse:\n    raise ValueError('Currently support CUDA only.')\n\n# hyparams here\nparser = argparse.ArgumentParser()\nparser.add_argument(\"--img_dir\", type=str)\nparser.add_argument(\"--save_dir\", type=str)\nparser.add_argument(\"--upscale\", type=int, default=1)\nparser.add_argument(\"--SUPIR_sign\", type=str, default='Q', choices=['F', 'Q'])\nparser.add_argument(\"--seed\", type=int, default=1234)\nparser.add_argument(\"--min_size\", type=int, default=1024)\nparser.add_argument(\"--edm_steps\", type=int, default=50)\nparser.add_argument(\"--s_stage1\", type=int, default=-1)\nparser.add_argument(\"--s_churn\", type=int, default=5)\nparser.add_argument(\"--s_noise\", type=float, default=1.003)\nparser.add_argument(\"--s_cfg\", type=float, default=7.5)\nparser.add_argument(\"--s_stage2\", type=float, default=1.)\nparser.add_argument(\"--num_samples\", type=int, default=1)\nparser.add_argument(\"--a_prompt\", type=str,\n                    default='Cinematic, High Contrast, highly detailed, taken using a Canon EOS R '\n                            'camera, hyper detailed photo - realistic maximum detail, 32k, Color '\n                            'Grading, ultra HD, extreme meticulous detailing, skin pore detailing, '\n                            'hyper sharpness, perfect without deformations.')\nparser.add_argument(\"--n_prompt\", type=str,\n                    default='painting, oil painting, illustration, drawing, art, sketch, oil painting, '\n                            'cartoon, CG Style, 3D render, unreal engine, blurring, dirty, messy, '\n                            'worst quality, low quality, frames, watermark, signature, jpeg artifacts, '\n                            'deformed, lowres, over-smooth')\nparser.add_argument(\"--color_fix_type\", type=str, default='Wavelet', choices=[\"None\", \"AdaIn\", \"Wavelet\"])\nparser.add_argument(\"--linear_CFG\", action='store_true', default=True)\nparser.add_argument(\"--linear_s_stage2\", action='store_true', default=False)\nparser.add_argument(\"--spt_linear_CFG\", type=float, default=4.0)\nparser.add_argument(\"--spt_linear_s_stage2\", type=float, default=0.)\nparser.add_argument(\"--ae_dtype\", type=str, default=\"bf16\", choices=['fp32', 'bf16'])\nparser.add_argument(\"--diff_dtype\", type=str, default=\"fp16\", choices=['fp32', 'fp16', 'bf16'])\nparser.add_argument(\"--no_llava\", action='store_true', default=False)\nparser.add_argument(\"--loading_half_params\", action='store_true', default=False)\nparser.add_argument(\"--use_tile_vae\", action='store_true', default=False)\nparser.add_argument(\"--encoder_tile_size\", type=int, default=512)\nparser.add_argument(\"--decoder_tile_size\", type=int, default=64)\nparser.add_argument(\"--load_8bit_llava\", action='store_true', default=False)\nargs = parser.parse_args()\nprint(args)\nuse_llava = not args.no_llava\n\n# load SUPIR\nmodel = create_SUPIR_model('options/SUPIR_v0.yaml', SUPIR_sign=args.SUPIR_sign)\nif args.loading_half_params:\n    model = model.half()\nif args.use_tile_vae:\n    model.init_tile_vae(encoder_tile_size=args.encoder_tile_size, decoder_tile_size=args.decoder_tile_size)\nmodel.ae_dtype = convert_dtype(args.ae_dtype)\nmodel.model.dtype = convert_dtype(args.diff_dtype)\nmodel = model.to(SUPIR_device)\n# load LLaVA\nif use_llava:\n    llava_agent = LLavaAgent(LLAVA_MODEL_PATH, device=LLaVA_device, load_8bit=args.load_8bit_llava, load_4bit=False)\nelse:\n    llava_agent = None\n\nos.makedirs(args.save_dir, exist_ok=True)\nfor img_pth in os.listdir(args.img_dir):\n    img_name = os.path.splitext(img_pth)[0]\n\n    LQ_ips = Image.open(os.path.join(args.img_dir, img_pth))\n    LQ_img, h0, w0 = PIL2Tensor(LQ_ips, upsacle=args.upscale, min_size=args.min_size)\n    LQ_img = LQ_img.unsqueeze(0).to(SUPIR_device)[:, :3, :, :]\n\n    # step 1: Pre-denoise for LLaVA, resize to 512\n    LQ_img_512, h1, w1 = PIL2Tensor(LQ_ips, upsacle=args.upscale, min_size=args.min_size, fix_resize=512)\n    LQ_img_512 = LQ_img_512.unsqueeze(0).to(SUPIR_device)[:, :3, :, :]\n    clean_imgs = model.batchify_denoise(LQ_img_512)\n    clean_PIL_img = Tensor2PIL(clean_imgs[0], h1, w1)\n\n    # step 2: LLaVA\n    if use_llava:\n        captions = llava_agent.gen_image_caption([clean_PIL_img])\n    else:\n        captions = ['']\n    print(captions)\n\n    # # step 3: Diffusion Process\n    samples = model.batchify_sample(LQ_img, captions, num_steps=args.edm_steps, restoration_scale=args.s_stage1, s_churn=args.s_churn,\n                                    s_noise=args.s_noise, cfg_scale=args.s_cfg, control_scale=args.s_stage2, seed=args.seed,\n                                    num_samples=args.num_samples, p_p=args.a_prompt, n_p=args.n_prompt, color_fix_type=args.color_fix_type,\n                                    use_linear_CFG=args.linear_CFG, use_linear_control_scale=args.linear_s_stage2,\n                                    cfg_scale_start=args.spt_linear_CFG, control_scale_start=args.spt_linear_s_stage2)\n    # save\n    for _i, sample in enumerate(samples):\n        Tensor2PIL(sample, h0, w0).save(f'{args.save_dir}/{img_name}_{_i}.png')\n\n"
        }
      ]
    }
  ]
}