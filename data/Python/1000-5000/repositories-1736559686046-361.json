{
  "metadata": {
    "timestamp": 1736559686046,
    "page": 361,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "evhub/coconut",
      "stars": 4122,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".appveyor.yml",
          "type": "blob",
          "size": 1.1142578125,
          "content": "pull_requests:\n  do_not_increment_build_number: true\nshallow_clone: true\n\nimage: Visual Studio 2015\n\nenvironment:\n  matrix:\n    - PYTHON: \"C:\\\\Python266\"\n      PYTHON_VERSION: \"2.6.6\"\n      PYTHON_ARCH: \"64\"\n    - PYTHON: \"C:\\\\Python27\"\n      PYTHON_VERSION: \"2.7.x\"\n      PYTHON_ARCH: \"64\"\n    - PYTHON: \"C:\\\\Python35\"\n      PYTHON_VERSION: \"3.5.x\"\n      PYTHON_ARCH: \"64\"\n    - PYTHON: \"C:\\\\Python39\"\n      PYTHON_VERSION: \"3.9.x\"\n      PYTHON_ARCH: \"64\"\n    - PYTHON: \"C:\\\\Python310\"\n      PYTHON_VERSION: \"3.10.x\"\n      PYTHON_ARCH: \"64\"\n    - PYTHON: \"C:\\\\Python311\"\n      PYTHON_VERSION: \"3.11.x\"\n      PYTHON_ARCH: \"64\"\n\ninstall:\n  # pywinpty installation fails without prior rust installation on some Python versions\n  - curl -sSf -o rustup-init.exe https://win.rustup.rs\n  - rustup-init.exe -yv --default-toolchain stable --default-host i686-pc-windows-msvc\n  - \"SET PATH=%APPDATA%\\\\Python;%APPDATA%\\\\Python\\\\Scripts;%PYTHON%;%PYTHON%\\\\Scripts;c:\\\\MinGW\\\\bin;%PATH%;C:\\\\Users\\\\appveyor\\\\.cargo\\\\bin\"\n  - \"copy c:\\\\MinGW\\\\bin\\\\mingw32-make.exe c:\\\\MinGW\\\\bin\\\\make.exe\"\n  - make install\n\nbuild: false\n\ntest_script:\n  - make test-all\n"
        },
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.1708984375,
          "content": "# Auto detect text files and perform LF normalization\n* text=auto\n\n# Treat Coconut and Python template files as Python\n*.coco          diff=python\n*.py_template   diff=python\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 1.373046875,
          "content": "# OS files\n.DS_Store\nThumbs.db\n*~\n.#*\n._*\n\\#*\\#\n\n# Python files\n__pycache__/\n*.py[cod]\n*$py.class\n*.so\n\n# Packaging\n.Python\nbuild/\ndevelop-eggs/\ndist/\ndownloads/\neggs/\n.eggs/\nlib/\nlib64/\nparts/\nsdist/\nvar/\nwheels/\npip-wheel-metadata/\nshare/python-wheels/\n*.egg-info/\n.installed.cfg\n*.egg\nbin/\n*.iml\n\n# PyInstaller\n*.manifest\n*.spec\n\n# Installer logs\npip-log.txt\npip-delete-this-directory.txt\npip-wheel-metadata/\n\n# Unit test / coverage reports\nhtmlcov/\n.tox/\n.nox/\n.coverage\n.coverage.*\n.cache\nnosetests.xml\ncoverage.xml\n*.cover\n*.py,cover\n.hypothesis/\n.pytest_cache/\n\n# Translations\n*.mo\n*.pot\n\n# Django\n*.log\nlocal_settings.py\ndb.sqlite3\ndb.sqlite3-journal\n\n# Flask\ninstance/\n.webassets-cache\n\n# Scrapy\n.scrapy\n\n# PyBuilder\ntarget/\n\n# Jupyter\n.ipynb_checkpoints\n\n# IPython\nprofile_default/\nipython_config.py\n\n# Celery\ncelerybeat-schedule\ncelerybeat.pid\n\n# SageMath\n*.sage.py\n\n# Environments\n.python-version\n.env\n.venv\nenv/\nvenv/\nENV/\n\n# Spyder\n.spyderproject\n.spyproject\n\n# Rope\n.ropeproject\n\n# MyPy\n.mypy_cache/\n.dmypy.json\ndmypy.json\n\n# Pyre\n.pyre/\n\n# mkdocs\n/site\n\n# Vim\n*.sw[nop]\n.ropeproject\n\n# Sublime\n*.sublime-*\n\n# PEP 582\n__pypackages__/\n\n# VSCode\n.vscode\n\n# Coconut\n/coconut/tests/dest/\n/docs/\npyston/\npyprover/\nbbopt/\ncoconut-prelude/\nindex.rst\n/coconut/icoconut/coconut/\n__coconut_cache__/\n\n# Profiling\nvprof.json\nprofile.svg\nprofile.speedscope\nruntime_profile.svg\nruntime_profile.speedscope\n"
        },
        {
          "name": ".pre-commit-config.yaml",
          "type": "blob",
          "size": 1.0966796875,
          "content": "repos:\n-   repo: https://github.com/pre-commit/mirrors-autopep8\n    rev: v2.0.4\n    hooks:\n    -   id: autopep8\n        args:\n        - --in-place\n        - --aggressive\n        - --aggressive\n        - --experimental\n        - --ignore=W503,E501,E722,E402,E721\n-   repo: https://github.com/pre-commit/pre-commit-hooks.git\n    rev: v4.6.0\n    hooks:\n    -   id: check-added-large-files\n    -   id: fix-byte-order-marker\n    -   id: fix-encoding-pragma\n    -   id: check-executables-have-shebangs\n    -   id: check-merge-conflict\n    -   id: check-case-conflict\n    -   id: check-vcs-permalinks\n    -   id: check-ast\n    -   id: check-builtin-literals\n    -   id: check-docstring-first\n    -   id: check-json\n    -   id: check-yaml\n    -   id: check-toml\n    -   id: check-symlinks\n    -   id: trailing-whitespace\n    -   id: end-of-file-fixer\n    -   id: debug-statements\n    -   id: detect-private-key\n    -   id: pretty-format-json\n        args:\n        - --autofix\n-   repo: https://github.com/pycqa/flake8\n    rev: 7.1.1\n    hooks:\n    -   id: flake8\n        args:\n        - --ignore=W503,E501,E265,E402,F405,E305,E126\n"
        },
        {
          "name": ".readthedocs.yaml",
          "type": "blob",
          "size": 0.732421875,
          "content": "# .readthedocs.yaml\n# Read the Docs configuration file\n# See https://docs.readthedocs.io/en/stable/config-file/v2.html for details\n\n# Required\nversion: 2\n\nformats: all\n\n# Set the version of Python and other tools you might need\nbuild:\n  os: ubuntu-22.04\n  tools:\n    python: \"3.11\"\n    # You can also specify other tool versions:\n    # nodejs: \"19\"\n    # rust: \"1.64\"\n    # golang: \"1.19\"\n\n# Build documentation in the docs/ directory with Sphinx\nsphinx:\n   configuration: conf.py\n\n# If using Sphinx, optionally build your docs in additional formats such as PDF\n# formats:\n#    - pdf\n\n# Optionally declare the Python requirements required to build your docs\npython:\n  install:\n    - method: pip\n      path: .\n      extra_requirements:\n        - docs\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 13.4873046875,
          "content": "# Coconut Contributing Guidelines\n\n_By contributing to Coconut, you agree to your contribution being released under [Coconut's Apache 2.0 license](https://github.com/evhub/coconut/blob/develop/LICENSE.txt)._\n\n**Anyone is welcome to submit an issue or pull request!** The purpose of this document is simply to explain the contribution process and the internals of how Coconut works to make contributing easier.\n\nIf you are considering contributing to Coconut, you'll be doing so on the [`develop` branch](https://github.com/evhub/coconut/tree/develop), which means you should be viewing [the `develop` version of the Contributing Guidelines](http://coconut.readthedocs.io/en/develop/CONTRIBUTING.html), if you aren't doing so already.\n\n## Asking Questions\n\nIf you are thinking about contributing to Coconut, please don't hesitate to ask questions at Coconut's [Gitter](https://gitter.im/evhub/coconut)! That includes any questions at all about contributing, including understanding the source code, figuring out how to implement a specific change, or just trying to figure out what needs to be done.\n\n## Good First Issues\n\nWant to help out, but don't know what to work on? Head over to Coconut's [open issues](https://github.com/evhub/coconut/issues) and look for ones labeled \"good first issue.\" These issues are those that require less intimate knowledge of Coconut's inner workings, and are thus possible for new contributors to work on.\n\n## Contribution Process\n\nContributing to Coconut is as simple as\n\n1. forking Coconut on [GitHub](https://github.com/evhub/coconut),\n2. making changes to the [`develop` branch](https://github.com/evhub/coconut/tree/develop), and\n3. proposing a pull request.\n\n_Note: Don't forget to add yourself to the \"Authors:\" section in the moduledocs of any files you modify!_\n\n## Testing New Changes\n\nFirst, you'll want to set up a local copy of Coconut's recommended development environment. For that, just run `git checkout develop`, make sure your default `python` installation is some variant of Python 3, and run `make dev`. That should switch you to the `develop` branch, install all possible dependencies, bind the `coconut` command to your local copy, and set up [pre-commit](http://pre-commit.com/), which will check your code for errors for you whenever you `git commit`.\n\nThen, you should be able to use the Coconut command-line for trying out simple things, and to run a paired-down version of the test suite locally, just `make test-univ`.\n\nAfter you've tested your changes locally, you'll want to add more permanent tests to Coconut's test suite. Coconut's test suite is primarily written in Coconut itself, so testing new features just means using them inside of one of Coconut's `.coco` test files, with some `assert` statements to check validity.\n\n## File Layout\n\n- `DOCS.md`\n    + Markdown file containing detailed documentation on every Coconut feature. If you are adding a new feature, you should also add documentation on it to this file.\n- `FAQ.md`\n    + Markdown file containing frequently asked questions and their answers. If you had a question you wished was answered earlier when learning Coconut, you should add it to this file.\n- `HELP.md`\n    + Markdown file containing Coconut's tutorial. The tutorial should be a streamlined introduction to Coconut and all of its most important features.\n- `Makefile`\n    + Contains targets for installing Coconut, building the documentation, checking for dependency updates, etc.\n- `setup.py`\n    + Using information from `requirements.py` and `constants.py` to install Coconut. Also reads `README.rst` to generate the PyPI description.\n- `conf.py`\n    + Sphinx configuration file for Coconut's documentation.\n- coconut\n    - `__coconut__.py`\n        + Mimics the Coconut header by generating and executing it when imported. Used by the REPL.\n    - `__init__.py`\n        + Includes the implementation of the `%coconut` IPython magic.\n    - `__main__.py`\n        + Imports and runs `main` from `main.py`.\n    - `constants.py`\n        + All constants used across Coconut are defined here, including dependencies, magic numbers/strings, etc.\n    - `convenience.py`\n        + Contains `cmd`, `version`, `setup`, and `parse` functions as convenience utilities when using Coconut as a module. Documented in `DOCS.md`.\n    - `exceptions.py`\n        + All of the exceptions raised by Coconut are defined here, both those shown to the user and those used only internally.\n    - `highlighter.py`\n        + Contains Coconut's Pygments syntax highlighter, as well as modified Python highlighters that don't fail if they encounter unknown syntax.\n    - `main.py`\n        + Contains `main` and `main_run`, the entry points for the `coconut` and `coconut-run` commands, respectively.\n    - `requirements.py`\n        + Processes Coconut's requirements from `constants.py` into a form `setup.py` can use, as well as checks for updates to Coconut's dependencies.\n    - `root.py`\n        + `root.py` creates and executes the part of Coconut's header that normalizes Python built-ins across versions. Whenever you are writing a new file, you should always add `from coconut.root import *` to ensure compatibility with different Python versions. `root.py` also sets basic version-related constants.\n    - `terminal.py`\n        + Contains utilities for displaying messages to the console, mainly `logger`, which is Coconut's primary method of logging a message from anywhere.\n    - command\n        - `__init__.py`\n            + Imports everything in `command.py`.\n        - `cli.py`\n            + Creates the `ArgumentParser` object used to parse Coconut command-line arguments.\n        - `command.py`\n            + Contains `Command`, whose `start` method is the main entry point for the Coconut command-line utility.\n        - `mypy.py`\n            + Contains objects necessary for Coconut's `--mypy` flag.\n        - `util.py`\n            + Contains utilities used by `command.py`, including `Prompt` for getting syntax-highlighted input, and `Runner` for executing compiled Python.\n        - `watch.py`\n            + Contains objects necessary for Coconut's `--watch` flag.\n    - compiler\n        - `__init__.py`\n            + Imports everything in `compiler.py`.\n        - `compiler.py`\n            + Contains `Compiler`, the class that actually compiles Coconut code. `Compiler` inherits from `Grammar` in `grammar.py` to get all of the basic grammatical definitions, then extends them with all of the handlers that depend on the compiler's options (e.g. the current `--target`). `Compiler` also does pre- and post-processing, including replacing strings with markers (pre-processing) and adding the header (post-processing).\n        - `grammar.py`\n            + Contains `Grammar`, the class that specifies Coconut's grammar in PyParsing. Coconut performs one-pass compilation by attaching \"handlers\" to specific grammar objects to transform them into compiled Python. `grammar.py` contains all basic (non-option-dependent) handlers.\n        - `header.py`\n            + Contains `getheader`, which generates the header at the top of all compiled Coconut files.\n        - `matching.py`\n            + Contains `Matcher`, which handles the compilation of all Coconut pattern-matching, including `match` statements, destructuring assignment, and pattern-matching functions.\n        - `util.py`\n            + Contains utilities for working with PyParsing objects that are primarily used by `grammar.py`.\n        - templates\n            - `header.py_template`\n                + Template for the main body of Coconut's header; use and formatting of this file is all in `header.py`.\n    - icoconut\n        - `__init__.py`\n            + Imports everything from `icoconut/root.py`.\n        - `__main__.py`\n            + Contains the main entry point for Coconut's Jupyter kernel.\n        - `root.py`\n            + Contains the implementation of Coconut's Jupyter kernel, made by subclassing the IPython kernel.\n    - tests\n        - `__init__.py`\n            + Imports everything in `main_test.py`.\n        - `__main__.py`\n            + When run, compiles all of the test source code, but _does not run any tests_. To run the tests, the command `make test`, or a  `pytest` command to run a specific test, is necessary.\n        - `main_test.py`\n            + Contains `TestCase` subclasses that run all of the commands for testing the Coconut files in `src`.\n        - src\n            - `extras.coco`\n                + Directly imports and calls functions in the Coconut package, including from `convenience.py` and icoconut.\n            - `runnable.coco`\n                + Makes sure the argument `--arg` was passed when running the file.\n            - `runner.coco`\n                + Runs `main` from `cocotest/agnostic/main.py`.\n            - cocotest\n                + _Note: Files in the folders below all get compiled into the top-level cocotest directory. The folders are only for differentiating what files to compile on what Python version._\n                - agnostic\n                    - `__init__.coco`\n                        + Contains a docstring that `main.coco` asserts exists.\n                    - `main.coco`\n                        + Contains the main test entry point as well as many simple, one-line tests.\n                    - `specific.coco`\n                        + Tests to be run only on a specific Python version, but not necessarily only under a specific `--target`.\n                    - `suite.coco`\n                        + Tests objects defined in `util.coco`.\n                    - `tutorial.coco`\n                        + Tests all the examples in `TUTORIAL.md`.\n                    - `util.coco`\n                        + Contains objects used in `suite.coco`.\n                - python2\n                    - `py2_test.coco`\n                        + Tests to be run only on Python 2 with `--target 2`.\n                - python3\n                    - `py3_test.coco`\n                        + Tests to be run only on Python 3 with `--target 3`.\n                - python35\n                    - `py35_test.coco`\n                        + Tests to be run only on Python 3.5 with `--target 3.5`.\n                - python36\n                    - `py36_test.coco`\n                        + Tests to be run only on Python 3.6 with `--target 3.6`.\n    - coconut-stubs\n        - `__coconut__.pyi`\n            + A MyPy stub file for specifying the type of all the objects defined in Coconut's package header (which is saved as `__coconut__.py`).\n\n## Release Process\n\n1. Preparation:\n    1. Run `make check-reqs` and update dependencies as necessary\n    2. Run `sudo make format`\n    3. Make sure `make test`, `make test-pyright`, and `make test-easter-eggs` are passing\n    4. Ensure that `coconut --watch` can successfully compile files when they're modified\n    5. Check changes in [`compiled-cocotest`](https://github.com/evhub/compiled-cocotest), [`pyprover`](https://github.com/evhub/pyprover), and [`coconut-prelude`](https://github.com/evhub/coconut-prelude)\n    6. Check [Codebeat](https://codebeat.co/a/evhub/projects) and [LGTM](https://lgtm.com/dashboard) for `coconut` and `compiled-cocotest`\n    7. Make sure [`coconut-develop`](https://pypi.python.org/pypi/coconut-develop) package looks good\n    8. Run `make docs` and ensure local documentation looks good\n    9. Make sure all of the following are passing:\n        1.  [Github Actions](https://github.com/evhub/coconut/actions)\n        2.  [AppVeyor](https://ci.appveyor.com/project/evhub/coconut)\n        3.  [readthedocs](https://readthedocs.org/projects/coconut/builds/)\n    10. Make sure [develop documentation](http://coconut.readthedocs.io/en/develop/) looks good\n    11. Turn off `develop` in `root.py`\n    12. Set `root.py` to new version number\n    13. If major release, set `root.py` to new version name\n\n2. Pull Request:\n    1. Move unresolved issues to new milestone\n    2. Create a pull request to merge `develop` into `master`\n    3. Link contributors on pull request\n    4. Wait until everything is passing\n\n3. Release:\n    1. Release a new version of [`sublime-coconut`](https://github.com/evhub/sublime-coconut) if applicable\n        1. Edit the [`package.json`](https://github.com/evhub/sublime-coconut/blob/master/package.json) with the new version\n        2. Run `make publish`\n        3. [Release a new version on GitHub](https://github.com/evhub/sublime-coconut/releases)\n    2. Merge pull request and mark as resolved\n    3. Release `master` on GitHub\n    4. `git fetch`, `git checkout master`, and `git pull`\n    5. Run `sudo make upload`\n    6. `git checkout develop`, `git rebase master`, and `git push`\n    7. Turn on `develop` in `root`\n    8. Run `sudo make dev`\n    9.  Push to `develop`\n    10. Wipe all updated versions on [readthedocs](https://readthedocs.org/projects/coconut/versions/)\n    11. Build all updated versions on [readthedocs](https://readthedocs.org/projects/coconut/builds/)\n    12. Copy [PyPI](https://pypi.python.org/pypi/coconut) keywords to [readthedocs tags](https://readthedocs.org/dashboard/coconut/edit/)\n    13. Get SHA-256 hash from [PyPI](https://pypi.python.org/pypi/coconut) `.tar.gz` file and use that as well as the current version requirements in [`constants.py`](https://github.com/evhub/coconut/blob/master/coconut/constants.py) to update the [local feedstock](https://github.com/evhub/coconut-feedstock)\n    14. Submit PR to update [Coconut's `conda-forge` feedstock](https://github.com/conda-forge/coconut-feedstock)\n    15. Update [website](https://github.com/evhub/coconut/tree/gh-pages) if it needs updating\n    16. Wait until feedstock PR is passing then merge it\n    17. Close release [milestone](https://github.com/evhub/coconut/milestones?direction=asc&sort=due_date)\n"
        },
        {
          "name": "DOCS.md",
          "type": "blob",
          "size": 216.865234375,
          "content": "```{eval-rst}\n:tocdepth: 2\n```\n\n# Coconut Documentation\n\n```{contents}\n---\nlocal:\ndepth: 2\n---\n```\n\n\n## Overview\n\nThis documentation covers all the features of the [Coconut Programming Language](http://evhub.github.io/coconut/), and is intended as a reference/specification, not a tutorialized introduction. For an introduction to and tutorial of Coconut, see [the tutorial](./HELP.md).\n\nCoconut is a variant of [Python](https://www.python.org/) built for **simple, elegant, Pythonic functional programming**. Coconut syntax is a strict superset of the latest Python 3 syntax. Thus, users familiar with Python will already be familiar with most of Coconut.\n\nThe Coconut compiler turns Coconut code into Python code. The primary method of accessing the Coconut compiler is through the Coconut command-line utility, which also features an interpreter for real-time compilation. In addition to the command-line utility, Coconut also supports the use of IPython/Jupyter notebooks.\n\nThought Coconut syntax is primarily based on that of Python, other languages that inspired Coconut include [Haskell](https://www.haskell.org/), [CoffeeScript](http://coffeescript.org/), [F#](http://fsharp.org/), and [Julia](https://julialang.org/).\n\n#### Try It Out\n\nIf you want to try Coconut in your browser, check out the [online interpreter](https://cs121-team-panda.github.io/coconut-interpreter). Note, however, that it may be running an outdated version of Coconut.\n\n\n## Installation\n\n```{contents}\n---\nlocal:\ndepth: 2\n---\n```\n\n#### Using Pip\n\nSince Coconut is hosted on the [Python Package Index](https://pypi.python.org/pypi/coconut), it can be installed easily using `pip`. Simply [install Python](https://www.python.org/downloads/), open up a command-line prompt, and enter\n```\npip install coconut\n```\nwhich will install Coconut and its required dependencies.\n\n_Note: If you have an old version of Coconut installed and you want to upgrade, run `pip install --upgrade coconut` instead._\n\nIf you are encountering errors running `pip install coconut`, try adding `--user` or running\n```\npip install --no-deps --upgrade coconut \"pyparsing<3\"\n```\nwhich will force Coconut to use the pure-Python [`pyparsing`](https://github.com/pyparsing/pyparsing) module instead of the faster [`cPyparsing`](https://github.com/evhub/cpyparsing) module. If you are still getting errors, you may want to try [using conda](#using-conda) instead.\n\nIf `pip install coconut` works, but you cannot access the `coconut` command, be sure that Coconut's installation location is in your `PATH` environment variable. On UNIX, that is `/usr/local/bin` (without `--user`) or `${HOME}/.local/bin/` (with `--user`).\n\n#### Using Conda\n\nIf you prefer to use [`conda`](https://conda.io/docs/) instead of `pip` to manage your Python packages, you can also install Coconut using `conda`. Just [install `conda`](https://conda.io/miniconda.html), open up a command-line prompt, and enter\n```\nconda config --add channels conda-forge\nconda install coconut\n```\nwhich will properly create and build a `conda` recipe out of [Coconut's `conda-forge` feedstock](https://github.com/conda-forge/coconut-feedstock).\n\n_Note: Coconut's `conda` recipe uses `pyparsing` rather than `cPyparsing`, which may lead to degraded performance relative to installing Coconut via `pip`._\n\n#### Using Homebrew\n\nIf you prefer to use [Homebrew](https://brew.sh/), you can also install Coconut using `brew`:\n```\nbrew install coconut\n```\n\n_Note: Coconut's Homebrew formula may not always be up-to-date with the latest version of Coconut._\n\n#### Optional Dependencies\n\nCoconut also has optional dependencies, which can be installed by entering\n```\npip install coconut[name_of_optional_dependency]\n```\nor, to install multiple optional dependencies,\n```\npip install coconut[opt_dep_1,opt_dep_2]\n```\n\nThe full list of optional dependencies is:\n\n- `all`: alias for everything below (this is the recommended way to install a feature-complete version of Coconut).\n- `jupyter`/`ipython`: enables use of the `--jupyter` / `--ipython` flag.\n- `kernel`: lightweight subset of `jupyter` that only includes the dependencies that are strictly necessary for Coconut's [Jupyter kernel](#kernel).\n- `watch`: enables use of the `--watch` flag.\n- `mypy`: enables use of the `--mypy` flag.\n- `pyright`: enables use of the `--pyright` flag.\n- `xonsh`: enables use of Coconut's [`xonsh` support](#xonsh-support).\n- `numpy`: installs everything necessary for making use of Coconut's [`numpy` integration](#numpy-integration).\n- `jupyterlab`: installs everything necessary to use [JupyterLab](https://github.com/jupyterlab/jupyterlab) with Coconut.\n- `jupytext`: installs everything necessary to use [Jupytext](https://github.com/mwouts/jupytext) with Coconut.\n\n#### Develop Version\n\nAlternatively, if you want to test out Coconut's latest and greatest, enter\n```\npip install coconut-develop\n```\nwhich will install the most recent working version from Coconut's [`develop` branch](https://github.com/evhub/coconut/tree/develop). Optional dependency installation is supported in the same manner as above. For more information on the current development build, check out the [development version of this documentation](http://coconut.readthedocs.io/en/develop/DOCS.html). Be warned: `coconut-develop` is likely to be unstable—if you find a bug, please report it by [creating a new issue](https://github.com/evhub/coconut/issues/new).\n\n_Note: if you have an existing release version of `coconut` installed, you'll need to `pip uninstall coconut` before installing `coconut-develop`._\n\n\n## Compilation\n\n```{contents}\n---\nlocal:\ndepth: 1\n---\n```\n\n#### Usage\n\n```\ncoconut [-h] [--and source [dest ...]] [-v] [-t version] [-i] [-p] [-a] [-l]\n        [--no-line-numbers] [-k] [-w] [-r] [-n] [-d] [-q] [-s] [--no-tco] [--no-wrap-types]\n        [-c code] [-j processes] [-f] [--minify] [--jupyter ...] [--mypy ...] [--pyright]\n        [--argv ...] [--tutorial] [--docs] [--style name] [--vi-mode]\n        [--recursion-limit limit] [--stack-size kbs] [--fail-fast] [--no-cache]\n        [--site-install] [--site-uninstall] [--verbose] [--trace] [--profile]\n        [source] [dest]\n```\n\n##### Positional Arguments\n\n```\nsource              path to the Coconut file/folder to compile\ndest                destination directory for compiled files (defaults to\n                    the source directory)\n```\n\n##### Optional Arguments\n\n```\n-h, --help            show this help message and exit\n--and source [dest ...]\n                      add an additional source/dest pair to compile (dest is optional)\n-v, -V, --version     print Coconut and Python version information\n-t version, --target version\n                      specify target Python version (defaults to universal)\n-i, --interact        force the interpreter to start (otherwise starts if no other command is\n                      given) (implies --run)\n-p, --package         compile source as part of a package (defaults to only if source is a\n                      directory)\n-a, --standalone, --stand-alone\n                      compile source as standalone files (defaults to only if source is a single\n                      file)\n-l, --line-numbers, --linenumbers\n                      force enable line number comments (--line-numbers are enabled by default\n                      unless --minify is passed)\n--no-line-numbers, --nolinenumbers\n                      disable line number comments (opposite of --line-numbers)\n-k, --keep-lines, --keeplines\n                      include source code in comments for ease of debugging\n-w, --watch           watch a directory and recompile on changes\n-r, --run             execute compiled Python\n-n, --no-write, --nowrite\n                      disable writing compiled Python\n-d, --display         print compiled Python\n-q, --quiet           suppress all informational output (combine with --display to write\n                      runnable code to stdout)\n-s, --strict          enforce code cleanliness standards\n--no-tco, --notco     disable tail call optimization\n--no-wrap-types, --nowraptypes\n                      disable wrapping type annotations in strings and turn off 'from __future__\n                      import annotations' behavior\n-c code, --code code  run Coconut passed in as a string (can also be piped into stdin)\n-j processes, --jobs processes\n                      number of additional processes to use (defaults to 'sys') (0 is no\n                      additional processes; 'sys' uses machine default)\n-f, --force           force re-compilation even when source code and compilation parameters\n                      haven't changed\n--minify              reduce size of compiled Python\n--jupyter ..., --ipython ...\n                      run Jupyter/IPython with Coconut as the kernel (remaining args passed to\n                      Jupyter)\n--mypy ...            run MyPy on compiled Python (remaining args passed to MyPy) (implies\n                      --package --line-numbers)\n--pyright             run Pyright on compiled Python (implies --package)\n--argv ..., --args ...\n                      set sys.argv to source plus remaining args for use in the Coconut script\n                      being run\n--tutorial            open Coconut's tutorial in the default web browser\n--docs, --documentation\n                      open Coconut's documentation in the default web browser\n--style name          set Pygments syntax highlighting style (or 'list' to list styles)\n                      (defaults to COCONUT_STYLE environment variable if it exists, otherwise\n                      'default')\n--vi-mode, --vimode   enable vi mode in the interpreter (currently set to False) (can be\n                      modified by setting COCONUT_VI_MODE environment variable)\n--recursion-limit limit, --recursionlimit limit\n                      set maximum recursion depth in compiler (defaults to 1920) (when\n                      increasing --recursion-limit, you may also need to increase --stack-size;\n                      setting them to approximately equal values is recommended)\n--stack-size kbs, --stacksize kbs\n                      run the compiler in a separate thread with the given stack size in\n                      kilobytes\n--fail-fast           causes the compiler to fail immediately upon encountering a compilation\n                      error rather than attempting to continue compiling other files\n--no-cache            disables use of Coconut's incremental parsing cache (caches previous\n                      parses to improve recompilation performance for slightly modified files)\n--site-install, --siteinstall\n                      set up coconut.api to be imported on Python start\n--site-uninstall, --siteuninstall\n                      revert the effects of --site-install\n--verbose             print verbose debug output\n--trace               print verbose parsing data (only available in coconut-develop)\n--profile             collect and print timing info (only available in coconut-develop)\n```\n\n#### Coconut Scripts\n\nTo run a Coconut file as a script, Coconut provides the command\n```\ncoconut-run <source> <args>\n```\nas an alias for\n```\ncoconut --quiet --target sys --keep-lines --run <source> --argv <args>\n```\nwhich will quietly compile and run `<source>`, passing any additional arguments to the script, mimicking how the `python` command works. To instead pass additional compilation arguments to Coconut itself (e.g. `--no-tco`), put them before the `<source>` file.\n\n`coconut-run` can be used to compile and run directories rather than files, again mimicking how the `python` command works. Specifically, Coconut will compile the directory and then run the `__main__.coco` in that directory, which must exist.\n\n`coconut-run` can be used in a Unix shebang line to create a Coconut script by adding the following line to the start of your script:\n```bash\n#!/usr/bin/env coconut-run\n```\n\n`coconut-run` will always enable [automatic compilation](#automatic-compilation), such that Coconut source files can be directly imported from any Coconut files run via `coconut-run`. Additionally, compilation parameters (e.g. `--no-tco`) used in `coconut-run` will be passed along and used for any auto compilation.\n\nOn Python 3.4+, `coconut-run` will use a `__coconut_cache__` directory to cache the compiled Python. Note that `__coconut_cache__` will always be removed from `__file__`.\n\n#### Naming Source Files\n\nCoconut source files should, so the compiler can recognize them, use the extension `.coco`.\n\nWhen Coconut compiles a `.coco` file, it will compile to another file with the same name, except with `.py` instead of `.coco`, which will hold the compiled code.\n\nIf an extension other than `.py` is desired for the compiled files, then that extension can be put before `.coco` in the source file name, and it will be used instead of `.py` for the compiled files. For example, `name.coco` will compile to `name.py`, whereas `name.abc.coco` will compile to `name.abc`.\n\n#### Compilation Modes\n\nFiles compiled by the `coconut` command-line utility will vary based on compilation parameters. If an entire directory of files is compiled (which the compiler will search recursively for any folders containing `.coco` files), a `__coconut__.py` file will be created to house necessary functions (package mode), whereas if only a single file is compiled, that information will be stored within a header inside the file (standalone mode). Standalone mode is better for single files because it gets rid of the overhead involved in importing `__coconut__.py`, but package mode is better for large packages because it gets rid of the need to run the same Coconut header code again in every file, since it can just be imported from `__coconut__.py`.\n\nBy default, if the `source` argument to the command-line utility is a file, it will perform standalone compilation on it, whereas if it is a directory, it will recursively search for all `.coco` files and perform package compilation on them. Thus, in most cases, the mode chosen by Coconut automatically will be the right one. But if it is very important that no additional files like `__coconut__.py` be created, for example, then the command-line utility can also be forced to use a specific mode with the `--package` (`-p`) and `--standalone` (`-a`) flags.\n\n#### Compatible Python Versions\n\nWhile Coconut syntax is based off of the latest Python 3, Coconut code compiled in universal mode (the default `--target`)—and the Coconut compiler itself—should run on any Python version `>= 2.6` on the `2.x` branch or `>= 3.2` on the `3.x` branch (and on either [CPython](https://www.python.org/) or [PyPy](http://pypy.org/)).\n\nTo make Coconut built-ins universal across Python versions, Coconut makes available on any Python version built-ins that only exist in later versions, including **automatically overwriting Python 2 built-ins with their Python 3 counterparts.** Additionally, Coconut also [overwrites some Python 3 built-ins for optimization and enhancement purposes](#enhanced-built-ins). If access to the original Python versions of any overwritten built-ins is desired, the old built-ins can be retrieved by prefixing them with `py_`. Specifically, the overwritten built-ins are:\n\n- `py_bytes`\n- `py_chr`\n- `py_dict`\n- `py_hex`\n- `py_input`\n- `py_int`\n- `py_map`\n- `py_object`\n- `py_oct`\n- `py_open`\n- `py_print`\n- `py_range`\n- `py_str`\n- `py_super`\n- `py_zip`\n- `py_filter`\n- `py_reversed`\n- `py_enumerate`\n- `py_raw_input`\n- `py_xrange`\n- `py_repr`\n- `py_breakpoint`\n- `py_min`\n- `py_max`\n\n_Note: Coconut's `repr` can be somewhat tricky, as it will attempt to remove the `u` before reprs of unicode strings on Python 2, but will not always be able to do so if the unicode string is nested._\n\nFor standard library compatibility, **Coconut automatically maps imports under Python 3 names to imports under Python 2 names**. Thus, Coconut will automatically take care of any standard library modules that were renamed from Python 2 to Python 3 if just the Python 3 name is used. For modules or packages that only exist in Python 3, however, Coconut has no way of maintaining compatibility.\n\nFinally, while Coconut will try to compile Python-3-specific syntax to its universal equivalent, the following constructs have no equivalent in Python 2, and require the specification of a target of at least `3` to be used:\n\n- the `nonlocal` keyword,\n- keyword-only function parameters (use [pattern-matching function definition](#pattern-matching-functions) for universal code),\n- `async` and `await` statements (requires a specific target; Coconut will attempt different [backports](#backports) based on the targeted version),\n- `:=` assignment expressions (requires `--target 3.8`),\n- positional-only function parameters (use [pattern-matching function definition](#pattern-matching-functions) for universal code) (requires `--target 3.8`),\n- `a[x, *y]` variadic generic syntax (use [type parameter syntax](#type-parameter-syntax) for universal code) (requires `--target 3.11`), and\n- `except*` multi-except statements (requires `--target 3.11`).\n\n_Note: Coconut also universalizes many magic methods, including making `__bool__` and [`__set_name__`](https://docs.python.org/3/reference/datamodel.html#object.__set_name__) work on any Python version._\n\n#### Allowable Targets\n\nIf the version of Python that the compiled code will be running on is known ahead of time, a target should be specified with `--target`. The given target will only affect the compiled code and whether or not the Python-3-specific syntax detailed above is allowed. Where Python syntax differs across versions, Coconut syntax will always follow the latest Python 3 across all targets. The supported targets are:\n\n- `universal`, `univ` (the default): will work on _any_ of the below\n- `2`, `2.6`: will work on any Python `>= 2.6` but `< 3`\n- `2.7`: will work on any Python `>= 2.7` but `< 3`\n- `3`, `3.2`: will work on any Python `>= 3.2`\n- `3.3`: will work on any Python `>= 3.3`\n- `3.4`: will work on any Python `>= 3.4`\n- `3.5`: will work on any Python `>= 3.5`\n- `3.6`: will work on any Python `>= 3.6`\n- `3.7`: will work on any Python `>= 3.7`\n- `3.8`: will work on any Python `>= 3.8`\n- `3.9`: will work on any Python `>= 3.9`\n- `3.10`: will work on any Python `>= 3.10`\n- `3.11`: will work on any Python `>= 3.11`\n- `3.12`: will work on any Python `>= 3.12`\n- `3.13`: will work on any Python `>= 3.13`\n- `sys`: chooses the target corresponding to the current Python version\n- `psf`: will work on any Python not considered [end-of-life](https://devguide.python.org/versions/) by the PSF (Python Software Foundation)\n\n_Note: Periods are optional in target specifications, such that the target `27` is equivalent to the target `2.7`._\n\n#### `strict` Mode\n\nIf the `--strict` (`-s` for short) flag is enabled, Coconut will perform additional checks on the code being compiled. It is recommended that you use the `--strict` flag if you are starting a new Coconut project, as it will help you write cleaner code. Specifically, the extra checks done by `--strict` are:\n\n- disabling deprecated features (making them entirely unavailable to code compiled with `--strict`),\n- errors instead of warnings on unused imports (unless they have a `# NOQA` or `# noqa` comment),\n- errors instead of warnings when overwriting built-ins (unless a backslash is used to escape the built-in name),\n- warning on missing `__init__.coco` files when compiling in `--package` mode,\n- throwing errors on various style problems (see list below).\n\nThe style issues which will cause `--strict` to throw an error are:\n\n- mixing of tabs and spaces\n- use of `\"hello\" \"world\"` implicit string concatenation (use explicit `+` instead)\n- use of `from __future__` imports (Coconut does these automatically)\n- inheriting from `object` in classes (Coconut does this automatically)\n- semicolons at end of lines\n- use of `u` to denote Unicode strings (all Coconut strings are Unicode strings)\n- `f`-strings with no format expressions in them\n- commas after [statement lambdas](#statement-lambdas) (not recommended as it can be unclear whether the comma is inside or outside the lambda)\n- missing new line at end of file\n- trailing whitespace at end of lines\n- use of the Python-style `lambda` statement (use [Coconut's lambda syntax](#lambdas) instead)\n- use of backslash continuation (use [parenthetical continuation](#enhanced-parenthetical-continuation) instead)\n- Python-3.10/PEP-634-style dotted names in pattern-matching (Coconut style is to preface these with `==`)\n- use of `:` instead of `<:` to specify upper bounds in [Coconut's type parameter syntax](#type-parameter-syntax)\n\nNote that many of the above style issues will still show a warning if `--strict` is not present.\n\n#### Backports\n\nIn addition to the newer Python features that Coconut can backport automatically itself to older Python versions, Coconut will also automatically compile code to make use of a variety of external backports as well. These backports are automatically installed with Coconut if needed and Coconut will automatically use them instead of the standard library if the standard library is not available. These backports are:\n- [`typing`](https://pypi.org/project/typing/) for backporting [`typing`](https://docs.python.org/3/library/typing.html).\n- [`typing_extensions`](https://pypi.org/project/typing-extensions/) for backporting individual `typing` objects.\n- [`backports.functools-lru-cache`](https://pypi.org/project/backports.functools-lru-cache/) for backporting [`functools.lru_cache`](https://docs.python.org/3/library/functools.html#functools.lru_cache).\n- [`exceptiongroup`](https://pypi.org/project/exceptiongroup/) for backporting [`ExceptionGroup` and `BaseExceptionGroup`](https://docs.python.org/3/library/exceptions.html#ExceptionGroup).\n- [`dataclasses`](https://pypi.org/project/dataclasses/) for backporting [`dataclasses`](https://docs.python.org/3/library/dataclasses.html).\n- [`aenum`](https://pypi.org/project/aenum) for backporting [`enum`](https://docs.python.org/3/library/enum.html).\n- [`async_generator`](https://github.com/python-trio/async_generator) for backporting [`async` generators](https://peps.python.org/pep-0525/) and [`asynccontextmanager`](https://docs.python.org/3/library/contextlib.html#contextlib.asynccontextmanager).\n- [`trollius`](https://pypi.python.org/pypi/trollius) for backporting [`async`/`await`](https://docs.python.org/3/library/asyncio-task.html) and [`asyncio`](https://docs.python.org/3/library/asyncio.html).\n\nNote that, when distributing compiled Coconut code, if you use any of these backports, you'll need to make sure that the requisite backport module is included as a dependency.\n\n\n## Integrations\n\n```{contents}\n---\nlocal:\ndepth: 2\n---\n```\n\n#### Syntax Highlighting\n\nText editors with support for Coconut syntax highlighting are:\n\n- **VSCode**: Install [Coconut (Official)](https://marketplace.visualstudio.com/items?itemName=evhub.coconut) (for **VSCodium**, install from Open VSX [here](https://open-vsx.org/extension/evhub/coconut) instead).\n- **SublimeText**: See SublimeText section below.\n- **Spyder** (or any other editor that supports **Pygments**): See Pygments section below.\n- **Vim**: See [`coconut.vim`](https://github.com/manicmaniac/coconut.vim).\n- **Emacs**: See [`emacs-coconut`](https://codeberg.org/kobarity/emacs-coconut)/[`emacs-ob-coconut`](https://codeberg.org/kobarity/emacs-ob-coconut).\n- **Atom**: See [`language-coconut`](https://github.com/enilsen16/language-coconut).\n\nAlternatively, if none of the above work for you, you can just treat Coconut as Python. Simply set up your editor so it interprets all `.coco` files as Python and that should highlight most of your code well enough (e.g. for IntelliJ IDEA see [registering file types](https://www.jetbrains.com/help/idea/creating-and-registering-file-types.html)).\n\n##### SublimeText\n\nCoconut syntax highlighting for SublimeText requires that [Package Control](https://packagecontrol.io/installation), the standard package manager for SublimeText, be installed. Once that is done, simply:\n\n1. open the SublimeText command palette by pressing `Ctrl+Shift+P` (or `Cmd+Shift+P` on Mac),\n2. type and enter `Package Control: Install Package`, and\n3. finally type and enter `Coconut`.\n\nTo make sure everything is working properly, open a `.coco` file, and make sure `Coconut` appears in the bottom right-hand corner. If something else appears, like `Plain Text`, click on it, select `Open all with current extension as...` at the top of the resulting menu, and then select `Coconut`.\n\n_Note: Coconut syntax highlighting for SublimeText is provided by the [sublime-coconut](https://github.com/evhub/sublime-coconut) package._\n\n##### Pygments\n\nThe same `pip install coconut` command that installs the Coconut command-line utility will also install the `coconut` Pygments lexer. How to use this lexer depends on the Pygments-enabled application being used, but in general simply use the `.coco` file extension (should be all you need to do for Spyder) and/or enter `coconut` as the language being highlighted and Pygments should be able to figure it out.\n\nFor example, this documentation is generated with [Sphinx](http://www.sphinx-doc.org/en/stable/), with the syntax highlighting you see created by adding the line\n```coconut_python\nhighlight_language = \"coconut\"\n```\nto Coconut's `conf.py`.\n\n#### IPython/Jupyter Support\n\nIf you use [IPython](http://ipython.org/) (the Python kernel for the [Jupyter](http://jupyter.org/) framework) notebooks or console, Coconut can be used as a Jupyter kernel or IPython extension.\n\n##### Kernel\n\nIf Coconut is used as a kernel, all code in the console or notebook will be sent directly to Coconut instead of Python to be evaluated. Otherwise, the Coconut kernel behaves exactly like the IPython kernel, including support for `%magic` commands.\n\nSimply installing Coconut should add a `Coconut` kernel to your Jupyter/IPython notebooks. If you are having issues accessing the Coconut kernel, however, the special command `coconut --jupyter install` will re-install the `Coconut` kernel to ensure it is using the current Python as well as add the additional kernels `Coconut (Default Python)`, `Coconut (Default Python 2)`, and `Coconut (Default Python 3)` which will use, respectively, the Python accessible as `python`, `python2`, and `python3` (these kernels are accessible in the console as `coconut_py`, `coconut_py2`, and `coconut_py3`). Coconut also supports `coconut --jupyter install --user` for user installation. Furthermore, the Coconut kernel fully supports [`nb_conda_kernels`](https://github.com/Anaconda-Platform/nb_conda_kernels) to enable accessing the Coconut kernel in one Conda environment from another Conda environment.\n\nThe Coconut kernel will always compile using the parameters: `--target sys --line-numbers --keep-lines --no-wrap-types`.\n\nCoconut also provides the following commands:\n\n- `coconut --jupyter notebook` will ensure that the Coconut kernel is available and launch a Jupyter/IPython notebook.\n- `coconut --jupyter console` will launch a Jupyter/IPython console using the Coconut kernel.\n- `coconut --jupyter lab` will ensure that the Coconut kernel is available and launch [JupyterLab](https://github.com/jupyterlab/jupyterlab).\n\nAdditionally, [Jupytext](https://github.com/mwouts/jupytext) contains special support for the Coconut kernel and Coconut contains special support for [Papermill](https://papermill.readthedocs.io/en/latest/).\n\n##### Extension\n\nIf Coconut is used as an extension, a special magic command will send snippets of code to be evaluated using Coconut instead of IPython, but IPython will still be used as the default.\n\nThe line magic `%load_ext coconut` will load Coconut as an extension, providing the `%coconut` and `%%coconut` magics and adding Coconut built-ins. The `%coconut` line magic will run a line of Coconut with default parameters, and the `%%coconut` block magic will take command-line arguments on the first line, and run any Coconut code provided in the rest of the cell with those parameters.\n\n_Note: Unlike the normal Coconut command-line, `%%coconut` defaults to the `sys` target rather than the `universal` target._\n\n#### Type Checking\n\n##### MyPy Integration\n\nCoconut has the ability to integrate with [MyPy](http://mypy-lang.org/) to provide optional static type_checking, including for all Coconut built-ins. Simply pass `--mypy` to `coconut` to enable MyPy integration, though be careful to pass it only as the last argument, since all arguments after `--mypy` are passed to `mypy`, not Coconut.\n\nYou can also run `mypy`—or any other static type checker—directly on the compiled Coconut. If the static type checker is unable to find the necessary stub files, however, then you may need to:\n\n1. run `coconut --mypy install` and\n2. tell your static type checker of choice to look in `~/.coconut_stubs` for stub files (for `mypy`, this is done by adding it to your [`MYPYPATH`](https://mypy.readthedocs.io/en/latest/running_mypy.html#how-imports-are-found)).\n\nTo distribute your code with checkable type annotations, you'll need to include `coconut` as a dependency (though a `--no-deps` install should be fine), as installing it is necessary to make the requisite stub files available. You'll also probably want to include a [`py.typed`](https://peps.python.org/pep-0561/) file.\n\n##### Pyright Integration\n\nThough not as well-supported as MyPy, Coconut also has built-in [Pyright](https://github.com/microsoft/pyright) support. Simply pass `--pyright` to automatically run Pyright on all compiled code. To adjust Pyright options, rather than pass them at the command-line, add your settings to the file `~/.coconut_pyrightconfig.json` (automatically generated the first time `coconut --pyright` is run).\n\n##### Syntax\n\nTo explicitly annotate your code with types to be checked, Coconut supports (on all Python versions):\n* [Python 3 function type annotations](https://www.python.org/dev/peps/pep-0484/),\n* [Python 3.6 variable type annotations](https://www.python.org/dev/peps/pep-0526/),\n* [Python 3.12 type parameter syntax](#type-parameter-syntax) for easily adding type parameters to classes, functions, [`data` types](#data), and type aliases,\n* Coconut's own [enhanced type annotation syntax](#enhanced-type-annotation), and\n* Coconut's [protocol intersection operator](#protocol-intersection).\n\nBy default, all type annotations are compiled to Python-2-compatible type comments, which means they should all work on any Python version.\n\nSometimes, MyPy will not know how to handle certain Coconut constructs, such as `addpattern`. For the `addpattern` case, it is recommended to pass `--allow-redefinition` to MyPy (i.e. run `coconut <args> --mypy --allow-redefinition`), though in some cases `--allow-redefinition` may not be sufficient. In that case, either hide the offending code using [`TYPE_CHECKING`](#type_checking) or put a `# type: ignore` comment on the Coconut line which is generating the line MyPy is complaining about and the comment will be added to every generated line.\n\n##### Interpreter\n\nCoconut even supports `--mypy` (though not `--pyright`) in the interpreter, which will intelligently scan each new line of code, in the context of previous lines, for newly-introduced MyPy errors. For example:\n```coconut_pycon\n>>> a: str = count()[0]\n<string>:14: error: Incompatible types in assignment (expression has type \"int\", variable has type \"str\")\n>>> reveal_type(a)\n0\n<string>:19: note: Revealed type is 'builtins.unicode'\n```\n_For more information on `reveal_type`, see [`reveal_type` and `reveal_locals`](#reveal-type-and-reveal-locals)._\n\n#### `numpy` Integration\n\nTo allow for better use of [`numpy`](https://numpy.org/) objects in Coconut, all compiled Coconut code will do a number of special things to better integrate with `numpy` (if `numpy` is available to import when the code is run). Specifically:\n\n- Coconut's [multidimensional array literal and array concatenation syntax](#multidimensional-array-literalconcatenation-syntax) supports `numpy` objects, including using fast `numpy` concatenation methods if given `numpy` arrays rather than Coconut's default much slower implementation built for Python lists of lists.\n- Many of Coconut's built-ins include special `numpy` support, specifically:\n  * [`fmap`](#fmap) will use [`numpy.vectorize`](https://numpy.org/doc/stable/reference/generated/numpy.vectorize.html) to map over `numpy` arrays.\n  * [`multi_enumerate`](#multi_enumerate) allows for easily looping over all the multidimensional indices in a `numpy` array.\n  * [`cartesian_product`](#cartesian_product) can compute the Cartesian product of given `numpy` arrays as a `numpy` array.\n  * [`all_equal`](#all_equal) allows for easily checking if all the elements in a `numpy` array are the same.\n- [`numpy.ndarray`](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html) is registered as a [`collections.abc.Sequence`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence), enabling it to be used in [sequence patterns](#semantics-specification).\n- `numpy` objects are allowed seamlessly in Coconut's [implicit coefficient syntax](#implicit-function-application-and-coefficients), allowing the use of e.g. `A B**2` shorthand for `A * B**2` when `A` and `B` are `numpy` arrays (note: **not** `A @ B**2`).\n- Coconut supports `@` for matrix multiplication of `numpy` arrays on all Python versions, as well as supplying the `(@)` [operator function](#operator-functions).\n\nAdditionally, Coconut provides the exact same support for [`pandas`](https://pandas.pydata.org/), [`xarray`](https://docs.xarray.dev/en/stable/), [`pytorch`](https://pytorch.org/), and [`jax.numpy`](https://jax.readthedocs.io/en/latest/jax.numpy.html) objects.\n\n#### `xonsh` Support\n\nCoconut integrates with [`xonsh`](https://xon.sh/) to allow the use of Coconut code directly from your command line. To use Coconut in `xonsh`, simply `pip install coconut` should be all you need to enable the use of Coconut syntax in the `xonsh` shell. In some circumstances, in particular depending on the installed `xonsh` version, adding `xontrib load coconut` to your [`xonshrc`](https://xon.sh/xonshrc.html) file might be necessary.\n\nFor an example of using Coconut from `xonsh`:\n```\nuser@computer ~ $ xontrib load coconut\nuser@computer ~ $ cd ./files\nuser@computer ~ $ $(ls -la) |> .splitlines() |> len\n30\n```\n\nCompilation always uses the same parameters as in the [Coconut Jupyter kernel](#kernel).\n\nNote that the way that Coconut integrates with `xonsh`, `@(<code>)` syntax and the `execx` command will only work with Python code, not Coconut code. Additionally, Coconut will only compile individual commands—Coconut will not touch the `.xonshrc` or any other `.xsh` files.\n\n\n## Operators\n\n```{contents}\n---\nlocal:\ndepth: 1\n---\n```\n\n\n### Precedence\n\nIn order of precedence, highest first, the operators supported in Coconut are:\n```\n====================== ==========================\nSymbol(s)              Associativity\n====================== ==========================\nawait x                n/a\n**                     right (allows unary)\nf x                    n/a\n+, -, ~                unary\n*, /, //, %, @         left\n+, -                   left\n<<, >>                 left\n&                      left\n&:                     yes\n^                      left\n|                      left\n::                     yes (lazy)\n..                     yes\na `b` c,               left (captures lambda)\n  all custom operators\n??                     left (short-circuits)\n..>, <.., ..*>, <*..,  n/a (captures lambda)\n  ..**>, <**.., etc.\n|>, <|, |*>, <*|,      left (captures lambda)\n  |**>, <**|, etc.\n==, !=, <, >,\n  <=, >=,\n  in, not in,\n  is, is not           n/a\nnot                    unary\nand                    left (short-circuits)\nor                     left (short-circuits)\nx if c else y,         ternary (short-circuits)\n  if c then x else y\n=>                     right\n====================== ==========================\n```\n\nFor example, since addition has a higher precedence than piping, expressions of the form `x |> y + z` are equivalent to `x |> (y + z)`.\n\n\n### Lambdas\n\nCoconut provides the simple, clean `=>` operator as an alternative to Python's `lambda` statements. The syntax for the `=>` operator is `(parameters) => expression` (or `parameter => expression` for one-argument lambdas). The operator has the same precedence as the old statement, which means it will often be necessary to surround the lambda in parentheses, and is right-associative.\n\nAdditionally, Coconut also supports an implicit usage of the `=>` operator of the form `(=> expression)`, which is equivalent to `((_=None) => expression)`, which allows an implicit lambda to be used both when no arguments are required, and when one argument (assigned to `_`) is required.\n\n_Note: If normal lambda syntax is insufficient, Coconut also supports an extended lambda syntax in the form of [statement lambdas](#statement-lambdas). Statement lambdas support full statements rather than just expressions and allow for the use of [pattern-matching function definition](#pattern-matching-functions)._\n\n_Deprecated: `->` can be used as an alternative to `=>`, though `->`-based lambdas are disabled inside type annotations to avoid conflicting with Coconut's [enhanced type annotation syntax](#enhanced-type-annotation)._\n\n##### Rationale\n\nIn Python, lambdas are ugly and bulky, requiring the entire word `lambda` to be written out every time one is constructed. This is fine if in-line functions are very rarely needed, but in functional programming in-line functions are an essential tool.\n\n##### Python Docs\n\nLambda forms (lambda expressions) have the same syntactic position as expressions. They are a shorthand to create anonymous functions; the expression `(arguments) => expression` yields a function object. The unnamed object behaves like a function object defined with:\n```coconut\ndef <lambda>(arguments):\n    return expression\n```\nNote that functions created with lambda forms cannot contain statements or annotations.\n\n##### Example\n\n**Coconut:**\n```coconut\ndubsums = map((x, y) => 2*(x+y), range(0, 10), range(10, 20))\ndubsums |> list |> print\n```\n\n**Python:**\n```coconut_python\ndubsums = map(lambda x, y: 2*(x+y), range(0, 10), range(10, 20))\nprint(list(dubsums))\n```\n\n#### Implicit Lambdas\n\nCoconut also supports implicit lambdas, which allow a lambda to take either no arguments or a single argument. Implicit lambdas are formed with the usual Coconut lambda operator `=>`, in the form `(=> expression)`. This is equivalent to `((_=None) => expression)`. When an argument is passed to an implicit lambda, it will be assigned to `_`, replacing the default value `None`.\n\nBelow are two examples of implicit lambdas. The first uses the implicit argument `_`, while the second does not.\n\n**Single Argument Example:**\n```coconut\nsquare = (=> _**2)\n```\n\n**No-Argument Example:**\n```coconut\nimport random\n\nget_random_number = (=> random.random())\n```\n\n_Note: Nesting implicit lambdas can lead to problems with the scope of the `_` parameter to each lambda. It is recommended that nesting implicit lambdas be avoided._\n\n\n### Partial Application\n\nCoconut uses a `$` sign right after a function's name but before the open parenthesis used to call the function to denote partial application.\n\nCoconut's partial application also supports the use of a `?` to skip partially applying an argument, deferring filling in that argument until the partially-applied function is called. This is useful if you want to partially apply arguments that aren't first in the argument order.\n\nAdditionally, `?` can even be used as the value of keyword arguments to convert them into positional arguments. For example, `f$(x=?)` is effectively equivalent to\n```coconut_python\ndef new_f(x, *args, **kwargs):\n    kwargs[\"x\"] = x\n    return f(*args, **kwargs)\n```\n\nUnlike `functools.partial`, Coconut's partial application will preserve the `__name__` of the wrapped function.\n\n##### Rationale\n\nPartial application, or currying, is a mainstay of functional programming, and for good reason: it allows the dynamic customization of functions to fit the needs of where they are being used. Partial application allows a new function to be created out of an old function with some of its arguments pre-specified.\n\n##### Python Docs\n\nReturn a new `partial` object which when called will behave like _func_ called with the positional arguments _args_ and keyword arguments _keywords_. If more arguments are supplied to the call, they are appended to _args_. If additional keyword arguments are supplied, they extend and override _keywords_. Roughly equivalent to:\n```coconut_python\ndef partial(func, *args, **keywords):\n    def newfunc(*fargs, **fkeywords):\n        newkeywords = keywords.copy()\n        newkeywords.update(fkeywords)\n        return func(*(args + fargs), **newkeywords)\n    newfunc.func = func\n    newfunc.args = args\n    newfunc.keywords = keywords\n    return newfunc\n```\nThe `partial` object is used for partial function application which “freezes” some portion of a function's arguments and/or keywords resulting in a new object with a simplified signature.\n\n##### Example\n\n**Coconut:**\n```coconut\nexpnums = range(5) |> map$(pow$(?, 2))\nexpnums |> list |> print\n```\n\n**Python:**\n```coconut_python\n# unlike this simple lambda, $ produces a pickleable object\nexpnums = map(lambda x: pow(x, 2), range(5))\nprint(list(expnums))\n```\n\n\n### Pipes\n\nCoconut uses pipe operators for pipeline-style function application. All the operators have a precedence in-between function composition pipes and comparisons, and are left-associative. All operators also support in-place versions. The different operators are:\n```coconut\n(|>)    => pipe forward\n(|*>)   => multiple-argument pipe forward\n(|**>)  => keyword argument pipe forward\n(<|)    => pipe backward\n(<*|)   => multiple-argument pipe backward\n(<**|)  => keyword argument pipe backward\n(|?>)   => None-aware pipe forward\n(|?*>)  => None-aware multi-arg pipe forward\n(|?**>) => None-aware keyword arg pipe forward\n(<?|)   => None-aware pipe backward\n(<*?|)  => None-aware multi-arg pipe backward\n(<**?|) => None-aware keyword arg pipe backward\n```\n\nThe None-aware pipe operators here are equivalent to a [monadic bind](https://en.wikipedia.org/wiki/Monad_(functional_programming)) treating the object as a `Maybe` monad composed of either `None` or the given object. Thus, `x |?> f` is equivalent to `None if x is None else f(x)`. Note that only the object being piped, not the function being piped into, may be `None` for `None`-aware pipes.\n\nAdditionally, some special syntax constructs are only available in pipes to enable doing as many operations as possible via pipes if so desired:\n* For working with `async` functions in pipes, all non-starred pipes support piping into `await` to await the awaitable piped into them, such that `x |> await` is equivalent to `await x`.\n* All non-starred pipes support piping into `(<name> := .)` (mirroring the syntax for [operator implicit partials](#implicit-partial-application)) to assign the piped in item to `<name>`.\n* All pipe operators support a lambda as the last argument, despite lambdas having a lower precedence. Thus, `a |> x => b |> c` is equivalent to `a |> (x => b |> c)`, not `a |> (x => b) |> c`.\n\n_Note: To visually spread operations across several lines, just use [parenthetical continuation](#enhanced-parenthetical-continuation)._\n\n##### Optimizations\n\nIt is common in Coconut to write code that uses pipes to pass an object through a series of [partials](#partial-application) and/or [implicit partials](#implicit-partial-application), as in\n```coconut\nobj |> .attribute |> .method(args) |> func$(args) |> .[index]\n```\nwhich is often much more readable, as it allows the operations to be written in the order in which they are performed, instead of as in\n```coconut_python\nfunc(args, obj.attribute.method(args))[index]\n```\nwhere `func` has to go at the beginning.\n\nIf Coconut compiled each of the partials in the pipe syntax as an actual partial application object, it would make the Coconut-style syntax significantly slower than the Python-style syntax. Thus, Coconut does not do that. If any of the above styles of partials or implicit partials are used in pipes, they will whenever possible be compiled to the Python-style syntax, producing no intermediate partial application objects.\n\nThis applies even to in-place pipes such as `|>=`.\n\n##### Examples\n\n**Coconut:**\n```coconut\ndef sq(x) = x**2\n(1, 2) |*> (+) |> sq |> print\n```\n\n```coconut\nasync def do_stuff(some_data) = (\n    some_data\n    |> async_func\n    |> await\n    |> post_proc\n)\n```\n\n**Python:**\n```coconut_python\nimport operator\ndef sq(x): return x**2\nprint(sq(operator.add(1, 2)))\n```\n\n```coconut_python\nasync def do_stuff(some_data):\n    return post_proc(await async_func(some_data))\n```\n\n\n### Function Composition\n\nCoconut has three basic function composition operators: `..`, `..>`, and `<..`. Both `..` and `<..` use math-style \"backwards\" function composition, where the first function is called last, while `..>` uses \"forwards\" function composition, where the first function is called first. Forwards and backwards function composition pipes cannot be used together in the same expression (unlike normal pipes) and have precedence in-between `None`-coalescing and normal pipes.\n\nThe `..>` and `<..` function composition pipe operators also have multi-arg, keyword, and None variants as with [normal pipes](#pipes). The full list of function composition pipe operators is:\n```\n..>    => forwards function composition pipe\n<..    => backwards function composition pipe\n..*>   => forwards multi-arg function composition pipe\n<*..   => backwards multi-arg function composition pipe\n..**>  => forwards keyword arg function composition pipe\n<**..  => backwards keyword arg function composition pipe\n..?>   => forwards None-aware function composition pipe\n<?..   => backwards None-aware function composition pipe\n..?*>  => forwards None-aware multi-arg function composition pipe\n<*?..  => backwards None-aware multi-arg function composition pipe\n..?**> => forwards None-aware keyword arg function composition pipe\n<**?.. => backwards None-aware keyword arg function composition pipe\n```\n\nNote that `None`-aware function composition pipes don't allow either function to be `None`—rather, they allow the return of the first evaluated function to be `None`, in which case `None` is returned immediately rather than calling the next function.\n\nThe `..` operator has lower precedence than `::` but higher precedence than infix functions while the `..>` pipe operators have a precedence directly higher than normal pipes.\n\nAll function composition operators also have in-place versions (e.g. `..=`).\n\nSince all forms of function composition always call the first function in the composition (`f` in `f ..> g` and `g` in `f <.. g`) with exactly the arguments passed into the composition, all forms of function composition will preserve all metadata attached to the first function in the composition, including the function's [signature](https://docs.python.org/3/library/inspect.html#inspect.signature) and any of that function's attributes.\n\n_Note: for composing `async` functions, see [`and_then` and `and_then_await`](#and_then-and-and_then_await)._\n\n##### Example\n\n**Coconut:**\n```coconut\nfog = f..g\nf_into_g = f ..> g\n```\n\n**Python:**\n```coconut_python\n# unlike these simple lambdas, Coconut produces pickleable objects\nfog = lambda *args, **kwargs: f(g(*args, **kwargs))\nf_into_g = lambda *args, **kwargs: g(f(*args, **kwargs))\n```\n\n\n### Iterator Slicing\n\nCoconut uses a `$` sign right after an iterator before a slice to perform iterator slicing, as in `it$[:5]`. Coconut's iterator slicing works much the same as Python's sequence slicing, and looks much the same as Coconut's partial application, but with brackets instead of parentheses.\n\nIterator slicing works just like sequence slicing, including support for negative indices and slices, and support for `slice` objects in the same way as can be done with normal slicing. Iterator slicing makes no guarantee, however, that the original iterator passed to it be preserved (to preserve the iterator, use Coconut's [`reiterable`](#reiterable) built-in).\n\nCoconut's iterator slicing is very similar to Python's `itertools.islice`, but unlike `itertools.islice`, Coconut's iterator slicing supports negative indices, and will preferentially call an object's `__iter_getitem__` (always used if available) or `__getitem__` (only used if the object is a `collections.abc.Sequence`). Coconut's iterator slicing is also optimized to work well with all of Coconut's built-in objects, only computing the elements of each that are actually necessary to extract the desired slice.\n\n##### Example\n\n**Coconut:**\n```coconut\nmap(x => x*2, range(10**100))$[-1] |> print\n```\n\n**Python:**\n_Can't be done without a complicated iterator slicing function and inspection of custom objects. The necessary definitions in Python can be found in the Coconut header._\n\n\n### Iterator Chaining\n\nCoconut uses the `::` operator for iterator chaining. Coconut's iterator chaining is done lazily, in that the arguments are not evaluated until they are needed. It has a precedence in-between bitwise or and infix calls. Chains are reiterable (can be iterated over multiple times and get the same result) only when the iterators passed in are reiterable. The in-place operator is `::=`.\n\n_Note that [lazy lists](#lazy-lists) and [flatten](#flatten) are used under the hood to implement chaining such that `a :: b` is equivalent to `flatten((|a, b|))`._\n\n##### Rationale\n\nA useful tool to make working with iterators as easy as working with sequences is the ability to lazily combine multiple iterators together. This operation is called chain, and is equivalent to addition with sequences, except that nothing gets evaluated until it is needed.\n\n##### Python Docs\n\nMake an iterator that returns elements from the first iterable until it is exhausted, then proceeds to the next iterable, until all of the iterables are exhausted. Used for treating consecutive sequences as a single sequence. Chained inputs are evaluated lazily. Roughly equivalent to:\n```coconut_python\ndef chain(*iterables):\n    # chain('ABC', 'DEF') --> A B C D E F\n    for it in iterables:\n        for element in it:\n            yield element\n```\n\n##### Example\n\n**Coconut:**\n```coconut\ndef N(n=0) = (n,) :: N(n+1)  # no infinite loop because :: is lazy\n\n(range(-10, 0) :: N())$[5:15] |> list |> print\n```\n\n**Python:**\n_Can't be done without a complicated iterator comprehension in place of the lazy chaining. See the compiled code for the Python syntax._\n\n\n### Infix Functions\n\nCoconut allows for infix function calling, where an expression that evaluates to a function is surrounded by backticks and then can have arguments placed in front of or behind it. Infix calling has a precedence in-between chaining and `None`-coalescing, and is left-associative.\n\nThe allowable notations for infix calls are:\n```coconut\nx `f` y  =>  f(x, y)\n`f` x    =>  f(x)\nx `f`    =>  f(x)\n`f`      =>  f()\n```\nAdditionally, infix notation supports a lambda as the last argument, despite lambdas having a lower precedence. Thus, ``a `func` b => c`` is equivalent to `func(a, b => c)`.\n\nCoconut also supports infix function definition to make defining functions that are intended for infix usage simpler. The syntax for infix function definition is\n```coconut\ndef <arg> `<name>` <arg>:\n    <body>\n```\nwhere `<name>` is the name of the function, the `<arg>`s are the function arguments, and `<body>` is the body of the function. If an `<arg>` includes a default, the `<arg>` must be surrounded in parentheses.\n\n_Note: Infix function definition can be combined with assignment and/or pattern-matching function definition._\n\n##### Rationale\n\nA common idiom in functional programming is to write functions that are intended to behave somewhat like operators, and to call and define them by placing them between their arguments. Coconut's infix syntax makes this possible.\n\n##### Example\n\n**Coconut:**\n```coconut\ndef a `mod` b = a % b\n(x `mod` 2) `print`\n```\n\n**Python:**\n```coconut_python\ndef mod(a, b): return a % b\nprint(mod(x, 2))\n```\n\n\n### Custom Operators\n\nCoconut allows you to declare your own custom operators with the syntax\n```\noperator <op>\n```\nwhere `<op>` is whatever sequence of Unicode characters you want to use as a custom operator. The `operator` statement must appear at the top level and only affects code that comes after it.\n\nOnce declared, you can use your custom operator anywhere where you would be able to use an [infix function](#infix-functions) as well as refer to the actual operator itself with the same `(<op>)` syntax as in other [operator functions](#operator-functions). Since custom operators work like infix functions, they always have the same precedence as infix functions and are always left-associative. Custom operators can be used as binary, unary, or none-ary operators, and both prefix and postfix notation for unary operators is supported.\n\nSome example syntaxes for defining custom operators once declared:\n```\ndef x <op> y: ...\ndef <op> x = ...\nmatch def (x) <op> (y): ...\n(<op>) = ...\nfrom module import name as (<op>)\n```\n\nAnd some example syntaxes for using custom operators:\n```\nx <op> y\nx <op> y <op> z\n<op> x\nx <op>\nx = (<op>)\nf(<op>)\n(x <op> .)\n(. <op> y)\nmatch x <op> in ...: ...\nmatch x <op> y in ...: ...\n```\n\nAdditionally, to import custom operators from other modules, Coconut supports the special syntax:\n```\nfrom <module> import operator <op>\n```\n\nCustom operators will often need to be surrounded by whitespace (or parentheses when used as an operator function) to be parsed correctly.\n\nIf a custom operator that is also a valid name is desired, you can use a backslash before the name to get back the name instead using Coconut's [keyword/variable disambiguation syntax](#handling-keywordvariable-name-overlap).\n\n_Note: redefining existing Coconut operators using custom operator definition syntax is forbidden, including Coconut's built-in [Unicode operator alternatives](#unicode-alternatives)._\n\n##### Examples\n\n**Coconut:**\n```coconut\noperator %%\n(%%) = math.remainder\n10 %% 3 |> print\n\noperator !!\n(!!) = bool\n!! 0 |> print\n\noperator log10\nfrom math import \\log10 as (log10)\n100 log10 |> print\n```\n\n**Python:**\n```coconut_python\nprint(math.remainder(10, 3))\n\nprint(bool(0))\n\nprint(math.log10(100))\n```\n\n\n### None Coalescing\n\nCoconut provides `??` as a `None`-coalescing operator, similar to the `??` null-coalescing operator in C# and Swift. Additionally, Coconut implements all of the `None`-aware operators proposed in [PEP 505](https://www.python.org/dev/peps/pep-0505/).\n\nCoconut's `??` operator evaluates to its left operand if that operand is not `None`, otherwise its right operand. The expression `foo ?? bar` evaluates to `foo` as long as it isn't `None`, and to `bar` if it is. The `None`-coalescing operator is short-circuiting, such that if the left operand is not `None`, the right operand won't be evaluated. This allows the right operand to be a potentially expensive operation without incurring any unnecessary cost.\n\nThe `None`-coalescing operator has a precedence in-between infix function calls and composition pipes, and is left-associative.\n\n##### Example\n\n**Coconut:**\n```coconut\ncould_be_none() ?? calculate_default_value()\n```\n\n**Python:**\n```coconut_python\n(lambda result: result if result is not None else calculate_default_value())(could_be_none())\n```\n\n#### Coalescing Assignment Operator\n\nThe in-place assignment operator is `??=`, which allows conditionally setting a variable if it is currently `None`.\n\n```coconut\nfoo = 1\nbar = None\nfoo ??= 10  # foo is still 1\nbar ??= 10  # bar is now 10\n```\n\nAs described with the standard `??` operator, the `None`-coalescing assignment operator will not evaluate the right hand side unless the left hand side is `None`.\n\n```coconut\nbaz = 0\nbaz ??= expensive_task()  # right hand side isn't evaluated\n```\n\n#### Other None-Aware Operators\n\nCoconut also allows a single `?` before attribute access, function calling, partial application, and (iterator) indexing to short-circuit the rest of the evaluation if everything so far evaluates to `None`. This is sometimes known as a \"safe navigation\" operator.\n\nWhen using a `None`-aware operator for member access, either for a method or an attribute, the syntax is `obj?.method()` or `obj?.attr` respectively. `obj?.attr` is equivalent to `obj.attr if obj is not None else obj`. This does not prevent an `AttributeError` if `attr` is not an attribute or method of `obj`.\n\nThe `None`-aware indexing operator is used identically to normal indexing, using `?[]` instead of `[]`. `seq?[index]` is equivalent to the expression `seq[index] if seq is not None else seq`. Using this operator will not prevent an `IndexError` if `index` is outside the bounds of `seq`.\n\nCoconut also supports None-aware [pipe operators](#pipes) and [function composition pipes](#function-composition).\n\n##### Example\n\n**Coconut:**\n```coconut\ncould_be_none?.attr     # attribute access\ncould_be_none?(arg)     # function calling\ncould_be_none?.method() # method calling\ncould_be_none?$(arg)    # partial application\ncould_be_none()?[0]     # indexing\ncould_be_none()?.attr[index].method()\n```\n\n**Python:**\n```coconut_python\nimport functools\n(lambda result: None if result is None else result.attr)(could_be_none())\n(lambda result: None if result is None else result(arg))(could_be_none())\n(lambda result: None if result is None else result.method())(could_be_none())\n(lambda result: None if result is None else functools.partial(result, arg))(could_be_none())\n(lambda result: None if result is None else result[0])(could_be_none())\n(lambda result: None if result is None else result.attr[index].method())(could_be_none())\n```\n\n\n### Protocol Intersection\n\nCoconut uses the `&:` operator to indicate protocol intersection. That is, for two [`typing.Protocol`s](https://docs.python.org/3/library/typing.html#typing.Protocol) `Protocol1` and `Protocol1`, `Protocol1 &: Protocol2` is equivalent to a `Protocol` that combines the requirements of both `Protocol1` and `Protocol2`.\n\nThe recommended way to use Coconut's protocol intersection operator is in combination with Coconut's [operator `Protocol`s](#supported-protocols). Note, however, that while `&:` will work anywhere, operator `Protocol`s will only work inside type annotations (which means, for example, you'll need to do `type HasAdd = (+)` instead of just `HasAdd = (+)`).\n\nSee Coconut's [enhanced type annotation](#enhanced-type-annotation) for more information on how Coconut handles type annotations more generally.\n\n##### Example\n\n**Coconut:**\n```coconut\nfrom typing import Protocol\n\nclass X(Protocol):\n    x: str\n\nclass Y(Protocol):\n    y: str\n\ndef foo(xy: X &: Y) -> None:\n    print(xy.x, xy.y)\n\ntype CanAddAndSub = (+) &: (-)\n```\n\n**Python:**\n```coconut_python\nfrom typing import Protocol, TypeVar, Generic\n\nclass X(Protocol):\n    x: str\n\nclass Y(Protocol):\n    y: str\n\nclass XY(X, Y, Protocol):\n    pass\n\ndef foo(xy: XY) -> None:\n    print(xy.x, xy.y)\n\nT = TypeVar(\"T\", infer_variance=True)\nU = TypeVar(\"U\", infer_variance=True)\nV = TypeVar(\"V\", infer_variance=True)\n\nclass CanAddAndSub(Protocol, Generic[T, U, V]):\n    def __add__(self: T, other: U) -> V:\n        raise NotImplementedError\n    def __sub__(self: T, other: U) -> V:\n        raise NotImplementedError\n    def __neg__(self: T) -> V:\n        raise NotImplementedError\n```\n\n\n### Unicode Alternatives\n\nCoconut supports Unicode alternatives to many different operator symbols. The Unicode alternatives are relatively straightforward, and chosen to reflect the look and/or meaning of the original symbol.\n\n_Note: these are only the default, built-in unicode operators. Coconut supports [custom operator definition](#custom-operators) to define your own._\n\n##### Full List\n\n```\n⇒ (\\u21d2)                 => \"=>\"\n→ (\\u2192)                  => \"->\"\n× (\\xd7)                    => \"*\" (only multiplication)\n↑ (\\u2191)                  => \"**\" (only exponentiation)\n÷ (\\xf7)                    => \"/\" (only division)\n÷/ (\\xf7/)                  => \"//\"\n⁻ (\\u207b)                  => \"-\" (only negation)\n≠ (\\u2260) or ¬= (\\xac=)    => \"!=\"\n≤ (\\u2264) or ⊆ (\\u2286)    => \"<=\"\n≥ (\\u2265) or ⊇ (\\u2287)    => \">=\"\n⊊ (\\u228a)                  => \"<\"\n⊋ (\\u228b)                  => \">\"\n∩ (\\u2229)                  => \"&\"\n∪ (\\u222a)                  => \"|\"\n« (\\xab)                    => \"<<\"\n» (\\xbb)                    => \">>\"\n… (\\u2026)                  => \"...\"\nλ (\\u03bb)                  => \"lambda\"\n↦ (\\u21a6)                 => \"|>\"\n↤ (\\u21a4)                 => \"<|\"\n*↦ (*\\u21a6)               => \"|*>\"\n↤* (\\u21a4*)               => \"<*|\"\n**↦ (**\\u21a6)             => \"|**>\"\n↤** (\\u21a4**)             => \"<**|\"\n?↦ (?\\u21a6)               => \"|?>\"\n↤? (?\\u21a4)               => \"<?|\"\n?*↦ (?*\\u21a6)             => \"|?*>\"\n↤*? (\\u21a4*?)             => \"<*?|\"\n?**↦ (?**\\u21a6)           => \"|?**>\"\n↤**? (\\u21a4**?)           => \"<**?|\"\n∘ (\\u2218)                  => \"..\"\n∘> (\\u2218>)                => \"..>\"\n<∘ (<\\u2218)                => \"<..\"\n∘*> (\\u2218*>)              => \"..*>\"\n<*∘ (<*\\u2218)              => \"<*..\"\n∘**> (\\u2218**>)            => \"..**>\"\n<**∘ (<**\\u2218)            => \"<**..\"\n∘?> (\\u2218?>)              => \"..?>\"\n<?∘ (<?\\u2218)              => \"<?..\"\n∘?*> (\\u2218?*>)            => \"..?*>\"\n<*?∘ (<*?\\u2218)            => \"<*?..\"\n∘?**> (\\u2218?**>)          => \"..?**>\"\n<**?∘ (<**?\\u2218)          => \"<**?..\"\n⏨ (\\u23e8)                  => \"e\" (in scientific notation)\n```\n\n\n## Keywords\n\n```{contents}\n---\nlocal:\ndepth: 1\n---\n```\n\n\n### `match`\n\nCoconut provides fully-featured, functional pattern-matching through its `match` statements. Coconut `match` syntax is a strict superset of [Python's `match` syntax](https://peps.python.org/pep-0636/).\n\n_Note: In describing Coconut's pattern-matching syntax, this section focuses on `match` statements, but Coconut's pattern-matching can also be used in many other places, such as [pattern-matching function definition](#pattern-matching-functions), [`case` statements](#case), [destructuring assignment](#destructuring-assignment), [`match data`](#match-data), and [`match for`](#match-for)._\n\n##### Overview\n\nMatch statements follow the basic syntax `match <pattern> in <value>`. The match statement will attempt to match the value against the pattern, and if successful, bind any variables in the pattern to whatever is in the same position in the value, and execute the code below the match statement.\n\nMatch statements also support, in their basic syntax, an `if <cond>` that will check the condition after executing the match before executing the code below, and an `else` statement afterwards that will only be executed if the `match` statement is not.\n\nAll pattern-matching in Coconut is atomic, such that no assignments will be executed unless the whole match succeeds.\n\n##### Syntax Specification\n\nCoconut match statement syntax is\n```coconut\nmatch <pattern> [not] in <value> [if <cond>]:\n    <body>\n[else:\n    <body>]\n```\nwhere `<value>` is the item to match against, `<cond>` is an optional additional check, and `<body>` is simply code that is executed if the header above it succeeds. `<pattern>` follows its own, special syntax, defined roughly as below. In the syntax specification below, brackets denote optional syntax and parentheses followed by a `*` denote that the syntax may appear zero or more times.\n\n```coconut\npattern ::= and_pattern (\"or\" and_pattern)*  # match any\n\nand_pattern ::= as_pattern (\"and\" as_pattern)*  # match all\n\nas_pattern ::= infix_pattern (\"as\" name)*  # explicit binding\n\ninfix_pattern ::= bar_or_pattern (\"`\" EXPR \"`\" [EXPR])*  # infix check\n\nbar_or_pattern ::= pattern (\"|\" pattern)*  # match any\n\nbase_pattern ::= (\n    \"(\" pattern \")\"                  # parentheses\n    | \"None\" | \"True\" | \"False\"      # constants\n    | NUMBER                         # numbers\n    | STRING                         # strings\n    | [\"as\"] NAME                    # variable binding\n    | \"==\" EXPR                      # equality check\n    | \"is\" EXPR                      # identity check\n    | DOTTED_NAME                    # implicit equality check (disabled in destructuring assignment)\n    | NAME \"(\" patterns \")\"          # classes or data types\n    | \"data\" NAME \"(\" patterns \")\"   # data types\n    | \"class\" NAME \"(\" patterns \")\"  # classes\n    | \"(\" name \"=\" pattern ... \")\"   # anonymous named tuples\n    | \"{\" pattern_pairs              # dictionaries\n        [\",\" \"**\" (NAME | \"{}\")] \"}\" #  (keys must be constants or equality checks)\n    | [\"s\" | \"f\" | \"m\"] \"{\"\n        pattern_consts\n        [\",\" (\"*_\" | \"*()\")]\n      \"}\"                            # sets\n    | (EXPR) -> pattern              # view patterns\n    | \"(\" patterns \")\"               # sequences can be in tuple form\n    | \"[\" patterns \"]\"               #  or in list form\n    | \"(|\" patterns \"|)\"             # lazy lists\n    | (\"(\" | \"[\")                    # star splits\n        [patterns \",\"]\n        \"*\" pattern\n        [\",\" patterns]\n        [\"*\" pattern\n        [\",\" patterns]]\n      (\")\" | \"]\")\n    | [(                             # sequence splits\n        \"(\" patterns \")\"\n        | \"[\" patterns \"]\"\n      ) \"+\"] NAME [\"+\" (\n        \"(\" patterns \")\"                 # this match must be the same\n        | \"[\" patterns \"]\"               #  construct as the first match\n      )] [\"+\" NAME [\"+\" (\n        \"(\" patterns \")\"                 # and same here\n        | \"[\" patterns \"]\"\n      )]]\n    | [(                             # iterable splits\n        \"(\" patterns \")\"\n        | \"[\" patterns \"]\"\n        | \"(|\" patterns \"|)\"\n      ) \"::\"] NAME [\"::\" (\n        \"(\" patterns \")\"\n        | \"[\" patterns \"]\"\n        | \"(|\" patterns \"|)\"\n      )] [ \"::\" NAME [\n        \"(\" patterns \")\"\n        | \"[\" patterns \"]\"\n        | \"(|\" patterns \"|)\"\n      ]]\n    | [STRING \"+\"] NAME              # complex string matching\n        [\"+\" STRING]\n        [\"+\" NAME [\"+\" STRING]]\n)\n```\n\n##### Semantics Specification\n\n`match` statements will take their pattern and attempt to \"match\" against it, performing the checks and deconstructions on the arguments as specified by the pattern. The different constructs that can be specified in a pattern, and their function, are:\n- Variable Bindings:\n  - Implicit Bindings (`<var>`): will match to anything, and will be bound to whatever they match to, with some exceptions:\n    * If the same variable is used multiple times, a check will be performed that each use matches to the same value.\n    * If the variable name `_` is used, nothing will be bound and everything will always match to it (`_` is Coconut's \"wildcard\").\n  - Explicit Bindings (`<pattern> as <var>`): will bind `<var>` to `<pattern>`.\n- Basic Checks:\n  - Constants, Numbers, and Strings: will only match to the same constant, number, or string in the same position in the arguments.\n  - Equality Checks (`==<expr>`): will check that whatever is in that position is `==` to the expression `<expr>`.\n  - Identity Checks (`is <expr>`): will check that whatever is in that position `is` the expression `<expr>`.\n- Arbitrary Function Patterns:\n  - Infix Checks (`` <pattern> `<op>` <expr> ``): will check that the operator `<op>$(?, <expr>)` returns a truthy value when called on whatever is in that position, then matches `<pattern>`. For example, `` x `isinstance` int `` will check that whatever is in that position `isinstance$(?, int)` and bind it to `x`. If `<expr>` is not given, will simply check `<op>` directly rather than `<op>$(<expr>)`. Additionally, `` `<op>` `` can instead be a [custom operator](#custom-operators) (in that case, no backticks should be used).\n  - View Patterns (`(<expression>) -> <pattern>`): calls `<expression>` on the item being matched and matches the result to `<pattern>`. The match fails if a [`MatchError`](#matcherror) is raised. `<expression>` may be unparenthesized only when it is a single atom.\n- Class and Data Type Matching:\n  - Classes or Data Types (`<name>(<args>)`): will match as a data type if given [a Coconut `data` type](#data) (or a tuple of Coconut data types) and a class otherwise.\n  - Data Types (`data <name>(<args>)`): will check that whatever is in that position is of data type `<name>` and will match the attributes to `<args>`. Generally, `data <name>(<args>)` will match any data type that could have been constructed with `makedata(<name>, <args>)`. Includes support for positional arguments, named arguments, default arguments, and starred arguments. Also supports strict attributes by prepending a dot to the attribute name that raises `AttributError` if the attribute is not present rather than failing the match (e.g. `data MyData(.my_attr=<some_pattern>)`).\n  - Classes (`class <name>(<args>)`): does [PEP-634-style class matching](https://www.python.org/dev/peps/pep-0634/#class-patterns). Also supports strict attribute matching as above.\n  - Anonymous Named Tuples (`(<name>=<pattern>, ...)`): checks that the object is a `tuple` of the given length with the given attributes. For matching [anonymous `namedtuple`s](#anonymous-namedtuples).\n- Dict Destructuring:\n  - Dicts (`{<key>: <value>, ...}`): will match any mapping (`collections.abc.Mapping`) with the given keys and values that match the value patterns. Keys must be constants or equality checks.\n  - Dicts With Rest (`{<pairs>, **<rest>}`): will match a mapping (`collections.abc.Mapping`) containing all the `<pairs>`, and will put a `dict` of everything else into `<rest>`. If `<rest>` is `{}`, will enforce that the mapping is exactly the same length as `<pairs>`.\n- Set Destructuring:\n  - Sets (`s{<constants>, *_}`): will match a set (`collections.abc.Set`) that contains the given `<constants>`, though it may also contain other items. The `s` prefix and the `*_` are optional.\n  - Fixed-length Sets (`s{<constants>, *()}`): will match a `set` (`collections.abc.Set`) that contains the given `<constants>`, and nothing else.\n  - Frozensets (`f{<constants>}`): will match a `frozenset` (`frozenset`) that contains the given `<constants>`. May use either normal or fixed-length syntax.\n  - Multisets (`m{<constants>}`): will match a [`multiset`](#multiset) (`collections.Counter`) that contains at least the given `<constants>`. May use either normal or fixed-length syntax.\n- Sequence Destructuring:\n  - Lists (`[<patterns>]`), Tuples (`(<patterns>)`): will only match a sequence (`collections.abc.Sequence`) of the same length, and will check the contents against `<patterns>` (Coconut automatically registers `numpy` arrays and `collections.deque` objects as sequences).\n  - Lazy lists (`(|<patterns>|)`): same as list or tuple matching, but checks for an Iterable (`collections.abc.Iterable`) instead of a Sequence.\n  - Head-Tail Splits (`<list/tuple> + <var>` or `(<patterns>, *<var>)`): will match the beginning of the sequence against the `<list/tuple>`/`<patterns>`, then bind the rest to `<var>`, and make it the type of the construct used.\n  - Init-Last Splits (`<var> + <list/tuple>` or `(*<var>, <patterns>)`): exactly the same as head-tail splits, but on the end instead of the beginning of the sequence.\n  - Head-Last Splits (`<list/tuple> + <var> + <list/tuple>` or `(<patterns>, *<var>, <patterns>)`): the combination of a head-tail and an init-last split.\n  - Search Splits (`<var1> + <list/tuple> + <var2>` or `(*<var1>, <patterns>, *<var2>)`): searches for the first occurrence of the `<list/tuple>`/`<patterns>` in the sequence, then puts everything before into `<var1>` and everything after into `<var2>`.\n  - Head-Last Search Splits (`<list/tuple> + <var> + <list/tuple> + <var> + <list/tuple>` or `(<patterns>, *<var>, <patterns>, *<var>, <patterns>)`): the combination of a head-tail split and a search split.\n  - Iterable Splits (`<list/tuple/lazy list> :: <var> :: <list/tuple/lazy list> :: <var> :: <list/tuple/lazy list>`): same as other sequence destructuring, but works on any iterable (`collections.abc.Iterable`), including infinite iterators (note that if an iterator is matched against it will be modified unless it is [`reiterable`](#reiterable)).\n  - Complex String Matching (`<string> + <var> + <string> + <var> + <string>`): string matching supports the same destructuring options as above.\n\n_Note: Like [iterator slicing](#iterator-slicing), iterator and lazy list matching make no guarantee that the original iterator matched against be preserved (to preserve the iterator, use Coconut's [`reiterable`](#reiterable) built-in)._\n\nWhen checking whether or not an object can be matched against in a particular fashion, Coconut makes use of Python's abstract base classes. Therefore, to ensure proper matching for a custom object, it's recommended to register it with the proper abstract base classes.\n\n##### Examples\n\n**Coconut:**\n```coconut\ndef factorial(value):\n    match 0 in value:\n        return 1\n    else: match n `isinstance` int in value if n > 0:  # Coconut allows nesting of statements on the same line\n        return n * factorial(n-1)\n    else:\n        raise TypeError(\"invalid argument to factorial of: \"+repr(value))\n\n3 |> factorial |> print\n```\n_Showcases `else` statements, which work much like `else` statements in Python: the code under an `else` statement is only executed if the corresponding match fails._\n\n```coconut\ndata point(x, y):\n    def transform(self, other):\n        match point(x, y) in other:\n            return point(self.x + x, self.y + y)\n        else:\n            raise TypeError(\"arg to transform must be a point\")\n\npoint(1,2) |> point(3,4).transform |> print\npoint(1,2) |> (==)$(point(1,2)) |> print\n```\n_Showcases matching to data types and the default equality operator. Values defined by the user with the `data` statement can be matched against and their contents accessed by specifically referencing arguments to the data type's constructor._\n\n```coconut\nclass Tree\ndata Empty() from Tree\ndata Leaf(n) from Tree\ndata Node(l, r) from Tree\n\ncase def depth:\n    case(Tree()) = 0\n    case(Tree(n)) = 1\n    case(Tree(l, r)) = 1 + max(depth(l), depth(r))\n\nEmpty() |> depth |> print\nLeaf(5) |> depth |> print\nNode(Leaf(2), Node(Empty(), Leaf(3))) |> depth |> print\n```\n_Showcases how the combination of data types and match statements can be used to powerful effect to replicate the usage of algebraic data types in other functional programming languages._\n\n```coconut\ndef duplicate_first([x] + xs as l) =\n    [x] + l\n\n[1,2,3] |> duplicate_first |> print\n```\n_Showcases head-tail splitting, one of the most common uses of pattern-matching, where a `+ <var>` (or `:: <var>` for any iterable) at the end of a list or tuple literal can be used to match the rest of the sequence._\n\n```coconut\ncase def sieve:\n    case([head] :: tail) =\n        [head] :: sieve(n for n in tail if n % head)\n    case((||)) = []\n```\n_Showcases how to match against iterators, namely that the empty iterator case (`(||)`) must come last, otherwise that case will exhaust the whole iterator before any other pattern has a chance to match against it._\n\n```coconut\ndef odd_primes(p=3) =\n    (p,) :: filter(=> _ % p != 0, odd_primes(p + 2))\n\ndef primes() =\n    (2,) :: odd_primes()\n\ncase def twin_primes:\n    case(_ :: [p, (.-2) -> p] :: ps) =\n        [(p, p+2)] :: twin_primes([p + 2] :: ps)\n    case() =\n        twin_primes(primes())\n\ntwin_primes()$[:5] |> list |> print\n```\n_Showcases the use of an iterable search pattern and a view pattern to construct an iterator of all twin primes._\n\n**Python:**\n_Can't be done without a long series of checks for each `match` statement. See the compiled code for the Python syntax._\n\n\n### `case`\n\nCoconut's `case` blocks serve as an extension of Coconut's `match` statement for performing multiple `match` statements against the same value, where only one of them should succeed. Unlike lone `match` statements, only one match statement inside of a `case` block will ever succeed, and thus more general matches should be put below more specific ones.\n\nCoconut's `case` blocks are an extension of Python 3.10's [`case` blocks](https://www.python.org/dev/peps/pep-0634) to support additional pattern-matching constructs added by Coconut (and Coconut will ensure that they work on all Python versions, not just 3.10+).\n\nEach pattern in a case block is checked until a match is found, and then the corresponding body is executed, and the case block terminated. The syntax for case blocks is\n```coconut\nmatch <value>:\n    case <pattern> [if <cond>]:\n        <body>\n    case <pattern> [if <cond>]:\n        <body>\n    ...\n[else:\n    <body>]\n```\nwhere `<pattern>` is any `match` pattern, `<value>` is the item to match against, `<cond>` is an optional additional check, and `<body>` is simply code that is executed if the header above it succeeds. Note the absence of an `in` in the `match` statements: that's because the `<value>` in `case <value>` is taking its place. If no `else` is present and no match succeeds, then the `case` statement is simply skipped over as with [`match` statements](#match) (though unlike [destructuring assignments](#destructuring-assignment)).\n\n_Deprecated: Additionally, `cases` or `case` can be used as the top-level keyword instead of `match`, and in such a block `match` is used for each case rather than `case`._\n\n##### Examples\n\n**Coconut:**\n```coconut\ndef classify_sequence(value):\n    out = \"\"        # unlike with normal matches, only one of the patterns\n    match value:     #  will match, and out will only get appended to once\n        case ():\n            out += \"empty\"\n        case (_,):\n            out += \"singleton\"\n        case (x,x):\n            out += \"duplicate pair of \"+str(x)\n        case (_,_):\n            out += \"pair\"\n        case _ is (tuple, list):\n            out += \"sequence\"\n    else:\n        raise TypeError()\n    return out\n\n[] |> classify_sequence |> print\n() |> classify_sequence |> print\n[1] |> classify_sequence |> print\n(1,1) |> classify_sequence |> print\n(1,2) |> classify_sequence |> print\n(1,1,1) |> classify_sequence |> print\n```\n_Example of using Coconut's `case` syntax._\n```coconut\ncases {\"a\": 1, \"b\": 2}:\n    match {\"a\": a}:\n        pass\n    match _:\n        assert False\nassert a == 1\n```\n_Example of the `cases` keyword instead._\n\n**Python:**\n_Can't be done without a long series of checks for each `match` statement. See the compiled code for the Python syntax._\n\n\n### `match for`\n\nCoconut supports pattern-matching in for loops, where the pattern is matched against each item in the iterable. The syntax is\n```coconut\n[match] for <pattern> in <iterable>:\n    <body>\n```\nwhich is equivalent to the [destructuring assignment](#destructuring-assignment)\n```coconut\nfor elem in <iterable>:\n    match <pattern> = elem\n    <body>\n```\n\nPattern-matching can also be used in `async for` loops, with both `async match for` and `match async for` allowed as explicit syntaxes.\n\n##### Example\n\n**Coconut:**\n```\nfor {\"user\": uid, **_} in get_data():\n    print(uid)\n```\n\n**Python:**\n```\nfor user_data in get_data():\n    uid = user_data[\"user\"]\n    print(uid)\n```\n\n\n### `data`\n\nCoconut's `data` keyword is used to create immutable, algebraic data types, including built-in support for destructuring [pattern-matching](#match) and [`fmap`](#fmap).\n\nThe syntax for `data` blocks is a cross between the syntax for functions and the syntax for classes. The first line looks like a function definition, but the rest of the body looks like a class, usually containing method definitions. This is because while `data` blocks actually end up as classes in Python, Coconut automatically creates a special, immutable constructor based on the given arguments.\n\nCoconut data statement syntax looks like:\n```coconut\ndata <name>(<args>) [from <inherits>]:\n    <body>\n```\n`<name>` is the name of the new data type, `<args>` are the arguments to its constructor as well as the names of its attributes, `<body>` contains the data type's methods, and `<inherits>` optionally contains any desired base classes.\n\nCoconut allows data fields in `<args>` to have defaults and/or [type annotations](#enhanced-type-annotation) attached to them, and supports a starred parameter at the end to collect extra arguments. Additionally, Coconut allows type parameters to be specified in brackets after `<name>` using Coconut's [type parameter syntax](#type-parameter-syntax).\n\nWriting constructors for `data` types must be done using the `__new__` method instead of the `__init__` method. For helping to easily write `__new__` methods, Coconut provides the [makedata](#makedata) built-in.\n\nSubclassing `data` types can be done easily by inheriting from them either in another `data` statement or a normal Python `class`. If a normal `class` statement is used, making the new subclass immutable will require adding the line\n```coconut\n__slots__ = ()\n```\nwhich will need to be put in the subclass body before any method or attribute definitions. If you need to inherit magic methods from a base class in your `data` type, such subclassing is the recommended method, as the `data ... from ...` syntax will overwrite any magic methods in the base class with magic methods built for the new `data` type.\n\nCompared to [`namedtuple`s](#anonymous-namedtuples), from which `data` types are derived, `data` types:\n\n- use typed equality,\n- don't support tuple addition or multiplication (unless explicitly defined via special methods in the `data` body),\n- support starred, typed, and [pattern-matching](#match-data) arguments, and\n- have special [pattern-matching](#match) behavior.\n\nLike [`namedtuple`s](https://docs.python.org/3/library/collections.html#namedtuple-factory-function-for-tuples-with-named-fields), `data` types also support a variety of extra methods, such as [`._asdict()`](https://docs.python.org/3/library/collections.html#collections.somenamedtuple._asdict) and [`._replace(**kwargs)`](https://docs.python.org/3/library/collections.html#collections.somenamedtuple._replace).\n\n##### Rationale\n\nA mainstay of functional programming that Coconut improves in Python is the use of values, or immutable data types. Immutable data can be very useful because it guarantees that once you have some data it won't change, but in Python creating custom immutable data types is difficult. Coconut makes it very easy by providing `data` blocks.\n\n##### Examples\n\n**Coconut:**\n```coconut\ndata vector2(x:int=0, y:int=0):\n    def __abs__(self):\n        return (self.x**2 + self.y**2)**.5\n\nv = vector2(3, 4)\nv |> print  # all data types come with a built-in __repr__\nv |> abs |> print\nv.x = 2  # this will fail because data objects are immutable\nvector2() |> print\n```\n_Showcases the syntax, features, and immutable nature of `data` types, as well as the use of default arguments and type annotations._\n\n```coconut\ndata Empty()\ndata Leaf(n)\ndata Node(l, r)\n\ncase def size:\n    case(Empty()) = 0\n    case(Leaf(n)) = 1\n    case(Node(l, r)) = size(l) + size(r)\n\nsize(Node(Empty(), Leaf(10))) == 1\n```\n_Showcases the use of pattern-matching to deconstruct `data` types._\n\n```coconut\ndata vector(*pts):\n    \"\"\"Immutable arbitrary-length vector.\"\"\"\n\n    def __abs__(self) =\n        self.pts |> map$(pow$(?, 2)) |> sum |> pow$(?, 0.5)\n\n    def __add__(self, other) =\n        vector(*other_pts) = other\n        assert len(other_pts) == len(self.pts)\n        map((+), self.pts, other_pts) |*> vector\n\n    def __neg__(self) =\n        self.pts |> map$((-)) |*> vector\n\n    def __sub__(self, other) =\n        self + -other\n```\n_Showcases starred `data` declaration._\n\n**Python:**\n_Can't be done without a series of method definitions for each data type. See the compiled code for the Python syntax._\n\n#### `match data`\n\nIn addition to normal `data` statements, Coconut also supports pattern-matching data statements that enable the use of Coconut's pattern-matching syntax to define the data type's constructor. Pattern-matching data types look like\n```\n[match] data <name>(<patterns>) [from <base class>]:\n    <body>\n```\nwhere `<patterns>` are exactly as in [pattern-matching functions](#pattern-matching-functions).\n\nIt is important to keep in mind that pattern-matching data types vary from normal data types in a variety of ways. First, like pattern-matching functions, they raise [`MatchError`](#matcherror) instead of `TypeError` when passed the wrong arguments. Second, pattern-matching data types will not do any special handling of starred arguments. Thus,\n```\ndata vec(*xs)\n```\nwhen iterated over will iterate over all the elements of `xs`, but\n```\nmatch data vec(*xs)\n```\nwhen iterated over will only give the single element `xs`.\n\n##### Example\n\n**Coconut:**\n```\ndata namedpt(name `isinstance` str, x `isinstance` int, y `isinstance` int):\n    def mag(self) = (self.x**2 + self.y**2)**0.5\n```\n\n**Python:**\n_Can't be done without a series of method definitions for each data type. See the compiled code for the Python syntax._\n\n\n### `where`\n\nCoconut's `where` statement is fairly straightforward. The syntax for a `where` statement is just\n```\n<stmt> where:\n    <body>\n```\nwhich executes `<body>` followed by `<stmt>`, with the exception that any new variables defined in `<body>` are available _only_ in `<stmt>` (though they are only mangled, not deleted, such that e.g. lambdas can still capture them).\n\n##### Example\n\n**Coconut:**\n```coconut\nresult = a + b where:\n    a = 1\n    b = 2\n```\n\n**Python:**\n```coconut_python\n_a = 1\n_b = 2\nresult = _a + _b\n```\n\n\n### `async with for`\n\nIn modern Python `async` code, such as when using [`contextlib.aclosing`](https://docs.python.org/3/library/contextlib.html#contextlib.aclosing), it is often recommended to use a pattern like\n```coconut_python\nasync with aclosing(my_generator()) as values:\n    async for value in values:\n        ...\n```\nsince it is substantially safer than the more syntactically straightforward\n```coconut_python\nasync for value in my_generator():\n    ...\n```\n\nThis is especially true when using [`trio`](https://github.com/python-trio/trio), which [completely disallows iterating over `async` generators with `async for`](https://discuss.python.org/t/preventing-yield-inside-certain-context-managers/1091), instead requiring the above `async with ... async for` pattern using utilities such as [`trio_util.trio_async_generator`](https://trio-util.readthedocs.io/en/latest/#trio_util.trio_async_generator).\n\nSince this pattern can often be quite syntactically cumbersome, Coconut provides the shortcut syntax\n```\nasync with for value in aclosing(my_generator()):\n    ...\n```\nwhich compiles to exactly the pattern above.\n\n`async with for` also [supports pattern-matching, just like normal Coconut `for` loops](#match-for).\n\n##### Example\n\n**Coconut:**\n```coconut\nfrom trio_util import trio_async_generator\n\n@trio_async_generator\nasync def my_generator():\n    # yield values, possibly from a nursery or cancel scope\n    # ...\n\nasync with for value in my_generator():\n    print(value)\n```\n\n**Python:**\n```coconut_python\nfrom trio_util import trio_async_generator\n\n@trio_async_generator\nasync def my_generator():\n    # yield values, possibly from a nursery or cancel scope\n    # ...\n\nasync with my_generator() as agen:\n    async for value in agen:\n        print(value)\n```\n\n\n### Handling Keyword/Variable Name Overlap\n\nIn Coconut, the following keywords are also valid variable names:\n- `data`\n- `match`\n- `case`\n- `cases`\n- `addpattern`\n- `where`\n- `operator`\n- `then`\n- `λ` (a [Unicode alternative](#unicode-alternatives) for `lambda`)\n\nWhile Coconut can usually disambiguate these two use cases, special syntax is available for disambiguating them if necessary. Note that, if what you're writing can be interpreted as valid Python 3, Coconut will always prefer that interpretation by default.\n\nTo specify that you want a _variable_, prefix the name with a backslash as in `\\data`, and to specify that you want a _keyword_, prefix the name with a colon as in `:match`.\n\nAdditionally, backslash syntax for escaping variable names can also be used to distinguish between variable names and [custom operators](#custom-operators) as well as explicitly signify that an assignment to a built-in is desirable to dismiss [`--strict` warnings](#strict-mode).\n\nFinally, such disambiguation syntax can also be helpful for letting syntax highlighters know what you're doing.\n\n##### Examples\n\n**Coconut:**\n```coconut\n\\data = 5\nprint(\\data)\n```\n\n```coconut\n# without the colon, Coconut will interpret this as the valid Python match[x, y] = input_list\n:match [x, y] = input_list\n```\n\n**Python:**\n```coconut_python\ndata = 5\nprint(data)\n```\n\n```coconut_python\nx, y = input_list\n```\n\n\n## Expressions\n\n```{contents}\n---\nlocal:\ndepth: 1\n---\n```\n\n\n### Statement Lambdas\n\nThe statement lambda syntax is an extension of the [normal lambda syntax](#lambdas) to support statements, not just expressions.\n\nThe syntax for a statement lambda is\n```\n[async|match|copyclosure] def (arguments) => statement; statement; ...\n```\nwhere `arguments` can be standard function arguments or [pattern-matching function definition](#pattern-matching-functions) arguments and `statement` can be any non-compound statement—that is, any statement that doesn't open a code block below it (so `def x => assert x` is fine but `def x => if x: True` is not). Note that the `async`, `match`, and [`copyclosure`](#copyclosure-functions) keywords can be combined and can be in any order.\n\nIf the last `statement` (not followed by a semicolon) in a statement lambda is an `expression`, it will automatically be returned.\n\nStatement lambdas also support implicit lambda syntax such that `def => _` is equivalent to `def (_=None) => _` as well as explicitly marking them as pattern-matching such that `match def (x) => x` will be a pattern-matching function.\n\nAdditionally, statement lambdas have slightly different scoping rules than normal lambdas. When a statement lambda is inside of an expression with an expression-local variable, such as a normal lambda or comprehension, the statement lambda will capture the value of the variable at the time that the statement lambda is defined (rather than a reference to the overall namespace as with normal lambdas). As a result, while `[=> y for y in range(2)] |> map$(call) |> list` is `[1, 1]`, `[def => y for y in range(2)] |> map$(call) |> list` is `[0, 1]`. Note that this only works for expression-local variables: to copy the entire namespace at the time of function definition, use [`copyclosure`](#copyclosure-functions) (which can be used with statement lambdas).\n\nNote that statement lambdas have a lower precedence than normal lambdas and thus capture things like trailing commas. To avoid confusion, statement lambdas should always be wrapped in their own set of parentheses.\n\n_Deprecated: Statement lambdas also support `->` instead of `=>`. Note that when using `->`, any lambdas in the body of the statement lambda must also use `->` rather than `=>`._\n\n##### Example\n\n**Coconut:**\n```coconut\nL |> map$(def (x) =>\n    y = 1/x;\n    y*(1 - y))\n```\n\n**Python:**\n```coconut_python\ndef _lambda(x):\n    y = 1/x\n    return y*(1 - y)\nmap(_lambda, L)\n```\n\n#### Type annotations\n\nAnother case where statement lambdas would be used over standard lambdas is when the parameters to the lambda are typed with type annotations. Statement lambdas use the standard Python syntax for adding type annotations to their parameters:\n\n```coconut\nf = def (c: str) -> None => print(c)\n\ng = def (a: int, b: int) -> int => a ** b\n```\n\n_Deprecated: if the deprecated `->` is used in place of `=>`, then return type annotations will not be available._\n\n\n### Operator Functions\n\nCoconut uses a simple operator function short-hand: surround an operator with parentheses to retrieve its function. Similarly to iterator comprehensions, if the operator function is the only argument to a function, the parentheses of the function call can also serve as the parentheses for the operator function.\n\nAll operator functions also support [implicit partial application](#implicit-partial-application), e.g. `(. + 1)` is equivalent to `(=> _ + 1)`.\n\n##### Rationale\n\nA very common thing to do in functional programming is to make use of function versions of built-in operators: currying them, composing them, and piping them. To make this easy, Coconut provides a short-hand syntax to access operator functions.\n\n##### Full List\n\n```coconut\n(::)        => (itertools.chain)  # will not evaluate its arguments lazily\n($)         => (functools.partial)\n(.)         => (getattr)\n(,)         => (*args) => args  # (but pickleable)\n(+)         => (operator.add)\n(-)         => # 1 arg: operator.neg, 2 args: operator.sub\n(*)         => (operator.mul)\n(**)        => (operator.pow)\n(/)         => (operator.truediv)\n(//)        => (operator.floordiv)\n(%)         => (operator.mod)\n(&)         => (operator.and_)\n(^)         => (operator.xor)\n(|)         => (operator.or_)\n(<<)        => (operator.lshift)\n(>>)        => (operator.rshift)\n(<)         => (operator.lt)\n(>)         => (operator.gt)\n(==)        => (operator.eq)\n(<=)        => (operator.le)\n(>=)        => (operator.ge)\n(!=)        => (operator.ne)\n(~)         => (operator.inv)\n(@)         => (operator.matmul)\n(|>)        => # pipe forward\n(|*>)       => # multi-arg pipe forward\n(|**>)      => # keyword arg pipe forward\n(<|)        => # pipe backward\n(<*|)       => # multi-arg pipe backward\n(<**|)      => # keyword arg pipe backward\n(|?>)       => # None-aware pipe forward\n(|?*>)      => # None-aware multi-arg pipe forward\n(|?**>)     => # None-aware keyword arg pipe forward\n(<?|)       => # None-aware pipe backward\n(<*?|)      => # None-aware multi-arg pipe backward\n(<**?|)     => # None-aware keyword arg pipe backward\n(..), (<..) => # backward function composition\n(..>)       => # forward function composition\n(<*..)      => # multi-arg backward function composition\n(..*>)      => # multi-arg forward function composition\n(<**..)     => # keyword arg backward function composition\n(..**>)     => # keyword arg forward function composition\n(not)       => (operator.not_)\n(and)       => # boolean and\n(or)        => # boolean or\n(is)        => (operator.is_)\n(is not)    => (operator.is_not)\n(in)        => (operator.contains)\n(not in)    => # negative containment\n(assert)    => def (cond, msg=None) => assert cond, msg  # (but a better msg if msg is None)\n(raise)     => def (exc=None, from_exc=None) => raise exc from from_exc  # or just raise if exc is None\n# operator functions for multidimensional array concatenation use brackets:\n[;]         => def (x, y) => [x; y]\n[;;]        => def (x, y) => [x;; y]\n...  # and so on for any number of semicolons\n# there are two operator functions that don't require parentheses:\n.[]         => (operator.getitem)\n.$[]        => # iterator slicing operator\n```\n\nFor an operator function for function application, see [`call`](#call).\n\nThough no operator function is available for `await`, an equivalent syntax is available for [pipes](#pipes) in the form of `awaitable |> await`.\n\n##### Example\n\n**Coconut:**\n```coconut\n(range(0, 5), range(5, 10)) |*> map$(+) |> list |> print\n```\n\n**Python:**\n```coconut_python\nimport operator\nprint(list(map(operator.add, range(0, 5), range(5, 10))))\n```\n\n\n### Implicit Partial Application\n\nCoconut supports a number of different syntactical aliases for common partial application use cases. These are:\n```coconut\n# attribute access and method calling\n.attr1.attr2        =>  operator.attrgetter(\"attr1.attr2\")\n.method(args)       =>  operator.methodcaller(\"method\", args)\n.attr.method(args)  =>  .attr ..> .method(args)\n\n# indexing\n.[a:b:c]            =>  operator.itemgetter(slice(a, b, c))\n.[x][y]             => .[x] ..> .[y]\n.method[x]          => .method ..> .[x]\nseq[]               =>  operator.getitem$(seq)\n\n# iterator indexing\n.$[a:b:c]           =>  # the equivalent of .[a:b:c] for iterators\n.$[x]$[y]           => .$[x] ..> .$[y]\niter$[]             =>  # the equivalent of seq[] for iterators\n\n# currying\nfunc$               =>  ($)$(func)\n```\n\nIn addition, for every Coconut [operator function](#operator-functions), Coconut supports syntax for implicitly partially applying that operator function as\n```\n(. <op> <arg>)\n(<arg> <op> .)\n```\nwhere `<op>` is the operator function and `<arg>` is any expression. Note that, as with operator functions themselves, the parentheses are necessary for this type of implicit partial application. This syntax is slightly different for multidimensional array concatenation operator functions, which use brackets instead of parentheses.\n\nFurthermore, Coconut also supports implicit operator function partials for arbitrary functions as\n```\n(. `<name>` <arg>)\n(<arg> `<name>` .)\n```\nbased on Coconut's [infix notation](#infix-functions) where `<name>` is the name of the function. Additionally, `` `<name>` `` can instead be a [custom operator](#custom-operators) (in that case, no backticks should be used).\n\n_Deprecated: Coconut also supports `obj.` as an implicit partial for `getattr$(obj)`, but its usage is deprecated and will show a warning to switch to `getattr$(obj)` instead._\n\n##### Example\n\n**Coconut:**\n```coconut\n1 |> \"123\"[]\nmod$ <| 5 <| 3\n3 |> (.*2) |> (.+1)\n```\n\n**Python:**\n```coconut_python\n\"123\"[1]\nmod(5, 3)\n(3 * 2) + 1\n```\n\n\n### Enhanced Type Annotation\n\nSince Coconut syntax is a superset of the latest Python 3 syntax, it supports [Python 3 function type annotation syntax](https://www.python.org/dev/peps/pep-0484/) and [Python 3.6 variable type annotation syntax](https://www.python.org/dev/peps/pep-0526/). By default, Coconut compiles all type annotations into Python-2-compatible type comments. If you want to keep the type annotations instead, simply pass a `--target` that supports them.\n\nSince not all supported Python versions support the [`typing`](https://docs.python.org/3/library/typing.html) module, Coconut provides the [`TYPE_CHECKING`](#type_checking) built-in for hiding your `typing` imports and `TypeVar` definitions from being executed at runtime. Coconut will also automatically use [`typing_extensions`](https://pypi.org/project/typing-extensions/) over `typing` objects at runtime when importing them from `typing`, even when they aren't natively supported on the current Python version (this works even if you just do `import typing` and then `typing.<Object>`).\n\nFurthermore, when compiling type annotations to Python 3 versions without [PEP 563](https://www.python.org/dev/peps/pep-0563/) support, Coconut wraps annotation in strings to prevent them from being evaluated at runtime (to avoid this, e.g. if you want to use annotations at runtime, `--no-wrap-types` will disable all wrapping, including via PEP 563 support). Only on `--target 3.13` does `--no-wrap-types` do nothing, since there [PEP 649](https://peps.python.org/pep-0649/) support is used instead.\n\nAdditionally, Coconut adds special syntax for making type annotations easier and simpler to write. When inside of a type annotation, Coconut treats certain syntax constructs differently, compiling them to type annotations instead of what they would normally represent. Specifically, Coconut applies the following transformations:\n```coconut\nA | B\n    => typing.Union[A, B]\n(A; B)\n    => typing.Tuple[A, B]\nA?\n    => typing.Optional[A]\nA[]\n    => typing.Sequence[A]\nA$[]\n    => typing.Iterable[A]\n() -> <ret>\n    => typing.Callable[[], <ret>]\n<arg> -> <ret>\n    => typing.Callable[[<arg>], <ret>]\n(<args>) -> <ret>\n    => typing.Callable[[<args>], <ret>]\n-> <ret>\n    => typing.Callable[..., <ret>]\n(<args>, **<ParamSpec>) -> <ret>\n    => typing.Callable[typing.Concatenate[<args>, <ParamSpec>], <ret>]\nasync (<args>) -> <ret>\n    => typing.Callable[[<args>], typing.Awaitable[<ret>]]\n```\nwhere `typing` is the Python 3.5 built-in [`typing` module](https://docs.python.org/3/library/typing.html). For more information on the Callable syntax, see [PEP 677](https://peps.python.org/pep-0677), which Coconut fully supports.\n\nAdditionally, many of Coconut's [operator functions](#operator-functions) will compile into equivalent [`Protocol`s](https://docs.python.org/3/library/typing.html#typing.Protocol) instead when inside a type annotation. See below for the full list and specification.\n\n_Note: The transformation to `Union` is not done on Python 3.10 as Python 3.10 has native [PEP 604](https://www.python.org/dev/peps/pep-0604) support._\n\nTo use these transformations in a [type alias](https://peps.python.org/pep-0484/#type-aliases), use the syntax\n```\ntype <name> = <type>\n```\nwhich will allow `<type>` to include Coconut's special type annotation syntax and type `<name>` as a [`typing.TypeAlias`](https://docs.python.org/3/library/typing.html#typing.TypeAlias). If you try to instead just do a naked `<name> = <type>` type alias, Coconut won't be able to tell you're attempting a type alias and thus won't apply any of the above transformations.\n\nSuch type alias statements—as well as all `class`, `data`, and function definitions in Coconut—also support Coconut's [type parameter syntax](#type-parameter-syntax), allowing you to do things like `type OrStr[T] = T | str`.\n\n##### Supported Protocols\n\nUsing Coconut's [operator function](#operator-functions) syntax inside of a type annotation will instead produce a [`Protocol`](https://docs.python.org/3/library/typing.html#typing.Protocol) corresponding to that operator (or raise a syntax error if no such `Protocol` is available). All available `Protocol`s are listed below.\n\nFor the operator functions\n```\n(+)\n(*)\n(**)\n(/)\n(//)\n(%)\n(&)\n(^)\n(|)\n(<<)\n(>>)\n(@)\n```\nthe resulting `Protocol` is\n```coconut\nclass SupportsOp[T, U, V](Protocol):\n    def __op__(self: T, other: U) -> V:\n        raise NotImplementedError(...)\n```\nwhere `__op__` is the magic method corresponding to that operator.\n\nFor the operator function `(-)`, the resulting `Protocol` is:\n```coconut\nclass SupportsMinus[T, U, V](Protocol):\n    def __sub__(self: T, other: U) -> V:\n        raise NotImplementedError\n    def __neg__(self: T) -> V:\n        raise NotImplementedError\n```\n\nFor the operator function `(~)`, the resulting `Protocol` is:\n```coconut\nclass SupportsInv[T, V](Protocol):\n    def __invert__(self: T) -> V:\n        raise NotImplementedError(...)\n```\n\n##### `List` vs. `Sequence`\n\nImportantly, note that `T[]` does not map onto `typing.List[T]` but onto `typing.Sequence[T]`. This allows the resulting type to be covariant, such that if `U` is a subtype of `T`, then `U[]` is a subtype of `T[]`. Additionally, `Sequence[T]` allows for tuples, and when writing in an idiomatic functional style, assignment should be rare and tuples should be common. Using `Sequence` covers both cases, accommodating tuples and lists and preventing indexed assignment. When an indexed assignment is attempted into a variable typed with `Sequence`, MyPy will generate an error:\n\n```coconut\nfoo: int[] = [0, 1, 2, 3, 4, 5]\nfoo[0] = 1   # MyPy error: \"Unsupported target for indexed assignment\"\n```\n\nIf you want to use `List` instead (e.g. if you want to support indexed assignment), use the standard Python 3.5 variable type annotation syntax: `foo: List[<type>]`.\n\n_Note: To easily view your defined types, see [`reveal_type` and `reveal_locals`](#reveal-type-and-reveal-locals)._\n\n##### Example\n\n**Coconut:**\n```coconut\ndef int_map(\n    f: int -> int,\n    xs: int[],\n) -> int[] =\n    xs |> map$(f) |> list\n\ntype CanAddAndSub = (+) &: (-)\n```\n\n**Python:**\n```coconut_python\nimport typing  # unlike this typing import, Coconut produces universal code\n\ndef int_map(\n    f,  # type: typing.Callable[[int], int]\n    xs,  # type: typing.Sequence[int]\n):\n    # type: (...) -> typing.Sequence[int]\n    return list(map(f, xs))\n\nT = typing.TypeVar(\"T\", infer_variance=True)\nU = typing.TypeVar(\"U\", infer_variance=True)\nV = typing.TypeVar(\"V\", infer_variance=True)\nclass CanAddAndSub(typing.Protocol, typing.Generic[T, U, V]):\n    def __add__(self: T, other: U) -> V:\n        raise NotImplementedError\n    def __sub__(self: T, other: U) -> V:\n        raise NotImplementedError\n    def __neg__(self: T) -> V:\n        raise NotImplementedError\n```\n\n\n### Multidimensional Array Literal/Concatenation Syntax\n\nCoconut supports multidimensional array literal and array [concatenation](https://numpy.org/doc/stable/reference/generated/numpy.concatenate.html)/[stack](https://numpy.org/doc/stable/reference/generated/numpy.stack.html) syntax.\n\nBy default, all multidimensional array syntax will simply operate on Python lists of lists (or any non-`str` `Sequence`). However, if [`numpy`](#numpy-integration) objects are used, the appropriate `numpy` calls will be made instead. To give custom objects multidimensional array concatenation support, define `type(obj).__matconcat__` (should behave as `np.concat`), `obj.ndim` (should behave as `np.ndarray.ndim`), and `obj.reshape` (should behave as `np.ndarray.reshape`).\n\nAs a simple example, 2D matrices can be constructed by separating the rows with `;;` inside of a list literal:\n```coconut_pycon\n>>> [1, 2 ;;\n     3, 4]\n\n[[1, 2], [3, 4]]\n>>> import numpy as np\n>>> np.array([1, 2 ;; 3, 4])\narray([[1, 2],\n       [3, 4]])\n```\nAs can be seen, `np.array` (or equivalent) can be used to turn the resulting list of lists into an actual array. This syntax works because `;;` inside of a list literal functions as a concatenation/stack along the `-2` axis (with the inner arrays being broadcast to `(1, 2)` arrays before concatenation). Note that this concatenation is done entirely in Python lists of lists here, since the `np.array` call comes only at the end.\n\nIn general, the number of semicolons indicates the dimension from the end on which to concatenate. Thus, `;` indicates conatenation along the `-1` axis, `;;` along the `-2` axis, and so on. Before concatenation, arrays are always broadcast to a shape which is large enough to allow the concatenation.\n\nThus, if `a` is a `numpy` array, `[a; a]` is equivalent to `np.concatenate((a, a), axis=-1)`, while `[a ;; a]` would be equivalent to a version of `np.concatenate((a, a), axis=-2)` that also ensures that `a` is at least two dimensional. For normal lists of lists, the behavior is the same, but is implemented without any `numpy` calls.\n\nIf multiple different concatenation operators are used, the operators with the least number of semicolons will bind most tightly. Thus, you can write a 3D array literal as:\n```coconut_pycon\n>>> [1, 2 ;;\n     3, 4\n     ;;;\n     5, 6 ;;\n     7, 8]\n\n[[[1, 2], [3, 4]], [[5, 6], [7, 8]]]\n```\n\n_Note: the [operator functions](#operator-functions) for multidimensional array concatenation are spelled `[;]`, `[;;]`, etc. (with any number of parentheses). The [implicit partials](#implicit-partial-application) are similarly spelled `[. ; x]`, `[x ; .]`, etc._\n\n##### Comparison to Julia\n\nCoconut's multidimensional array syntax is based on that of [Julia](https://docs.julialang.org/en/v1/manual/arrays/#man-array-literals). The primary difference between Coconut's syntax and Julia's syntax is that multidimensional arrays are row-first in Coconut (following `numpy`), but column-first in Julia. Thus, `;` is vertical concatenation in Julia but **horizontal concatenation** in Coconut and `;;` is horizontal concatenation in Julia but **vertical concatenation** in Coconut.\n\n##### Examples\n\n**Coconut:**\n```coconut_pycon\n>>> [[1;;2] ; [3;;4]]\n[[1, 3], [2, 4]]\n```\n_Array literals can be written in column-first order if the columns are first created via vertical concatenation (`;;`) and then joined via horizontal concatenation (`;`)._\n\n```coconut_pycon\n>>> [range(3) |> list ;; x+1 for x in range(3)]\n[[0, 1, 2], [1, 2, 3]]\n```\n_Arbitrary expressions, including comprehensions, are allowed in multidimensional array literals._\n\n```coconut_pycon\n>>> import numpy as np\n>>> a = np.array([1, 2 ;; 3, 4])\n>>> [a ; a]\narray([[1, 2, 1, 2],\n       [3, 4, 3, 4]])\n>>> [a ;; a]\narray([[1, 2],\n       [3, 4],\n       [1, 2],\n       [3, 4]])\n>>> [a ;;; a]\narray([[[1, 2],\n        [3, 4]],\n\n       [[1, 2],\n        [3, 4]]])\n```\n_General showcase of how the different concatenation operators work using `numpy` arrays._\n\n**Python:** _The equivalent Python array literals can be seen in the printed representations in each example._\n\n\n### Lazy Lists\n\nCoconut supports the creation of lazy lists, where the contents in the list will be treated as an iterator and not evaluated until they are needed. Unlike normal iterators, however, lazy lists can be iterated over multiple times and still return the same result. Lazy lists can be created in Coconut simply by surrounding a comma-separated list of items with `(|` and `|)` (so-called \"banana brackets\") instead of `[` and `]` for a list or `(` and `)` for a tuple.\n\nLazy lists use [reiterable](#reiterable) under the hood to enable them to be iterated over multiple times. Lazy lists will even continue to be reiterable when combined with [lazy chaining](#iterator-chaining).\n\n##### Rationale\n\nLazy lists, where sequences are only evaluated when their contents are requested, are a mainstay of functional programming, allowing for dynamic evaluation of the list's contents.\n\n##### Example\n\n**Coconut:**\n```coconut\n(| print(\"hello,\"), print(\"world!\") |) |> consume\n```\n\n**Python:**\n_Can't be done without a complicated iterator comprehension in place of the lazy list. See the compiled code for the Python syntax._\n\n\n### Implicit Function Application and Coefficients\n\nCoconut supports implicit function application of the form `f x y`, which is compiled to `f(x, y)` (note: **not** `f(x)(y)` as is common in many languages with automatic currying).\n\nAdditionally, if the first argument is not callable, and is instead an `int`, `float`, `complex`, or [`numpy`](#numpy-integration) object, then the result is multiplication rather than function application, such that `2 x` is equivalent to `2*x`.\n\nThough the first item may be any atom, following arguments are highly restricted, and must be:\n- variables/attributes (e.g. `a.b`),\n- literal constants (e.g. `True`),\n- number literals (e.g. `1.5`) (and no binary, hex, or octal), or\n- one of the above followed by an exponent (e.g. `a**-5`).\n\nFor example, `(f .. g) x 1` will work, but `f x [1]`, `f x (1+2)`, and `f \"abc\"` will not.\n\nImplicit function application and coefficient syntax is only intended for simple use cases. For more complex cases, use the standard multiplication operator `*`, standard function application, or [pipes](#pipes).\n\nImplicit function application and coefficient syntax has a lower precedence than `**` but a higher precedence than unary operators. As a result, `2 x**2 + 3 x` is equivalent to `2 * x**2 + 3 * x`.\n\nDue to potential confusion, some syntactic constructs are explicitly disallowed in implicit function application and coefficient syntax. Specifically:\n- Strings are always disallowed everywhere in implicit function application / coefficient syntax due to conflicting with [Python's implicit string concatenation](https://stackoverflow.com/questions/18842779/string-concatenation-without-operator).\n- Multiplying two or more numeric literals with implicit coefficient syntax is prohibited, so `10 20` is not allowed.\n- `await` is not allowed in front of implicit function application and coefficient syntax. To use `await`, simply parenthesize the expression, as in `await (f x)`.\n\n_Note: implicit function application and coefficient syntax is disabled when [using Coconut in `xonsh`](#xonsh-support) due to conflicting with console commands._\n\n##### Examples\n\n**Coconut:**\n```coconut\ndef f(x, y) = (x, y)\nprint(f 5 10)\n```\n\n```coconut\ndef p1(x) = x + 1\nprint <| p1 5\n```\n\n```coconut\nquad = 5 x**2 + 3 x + 1\n```\n\n**Python:**\n```coconut_python\ndef f(x, y): return (x, y)\nprint(f(100, 5+6))\n```\n\n```coconut_python\ndef p1(x): return x + 1\nprint(p1(5))\n```\n\n```coconut_python\nquad = 5 * x**2 + 3 * x + 1\n```\n\n\n### Keyword Argument Name Elision\n\nWhen passing in long variable names as keyword arguments of the same name, Coconut supports the syntax\n```\nf(long_variable_name=)\n```\nas a shorthand for\n```\nf(long_variable_name=long_variable_name)\n```\n\nSuch syntax is also supported in [partial application](#partial-application), [anonymous `namedtuple`s](#anonymous-namedtuples), and [`class`/`data`/anonymous `namedtuple` patterns](#match).\n\n_Deprecated: Coconut also supports `f(...=long_variable_name)` as an alternative shorthand syntax._\n\n##### Example\n\n**Coconut:**\n```coconut\nreally_long_variable_name_1 = get_1()\nreally_long_variable_name_2 = get_2()\nmain_func(\n    really_long_variable_name_1=,\n    really_long_variable_name_2=,\n)\n```\n\n**Python:**\n```coconut_python\nreally_long_variable_name_1 = get_1()\nreally_long_variable_name_2 = get_2()\nmain_func(\n    really_long_variable_name_1=really_long_variable_name_1,\n    really_long_variable_name_2=really_long_variable_name_2,\n)\n```\n\n\n### Anonymous Namedtuples\n\nCoconut supports anonymous [`namedtuple`](https://docs.python.org/3/library/collections.html#collections.namedtuple) literals, such that `(a=1, b=2)` can be used just as `(1, 2)`, but with added names. Anonymous `namedtuple`s are always pickleable and support [`__match_args__`](https://peps.python.org/pep-0622/) on all Python versions.\n\nThe syntax for anonymous namedtuple literals is:\n```coconut\n(<name> [: <type>] = <value>, ...)\n```\nwhere, if `<type>` is given for any field, [`typing.NamedTuple`](https://docs.python.org/3/library/typing.html#typing.NamedTuple) is used instead of `collections.namedtuple`.\n\nAnonymous `namedtuple`s also support [keyword argument name elision](#keyword-argument-name-elision).\n\n##### `_namedtuple_of`\n\nOn Python versions `>=3.6`, `_namedtuple_of` is provided as a built-in that can mimic the behavior of anonymous namedtuple literals such that `_namedtuple_of(a=1, b=2)` is equivalent to `(a=1, b=2)`. Since `_namedtuple_of` is only available on Python 3.6 and above, however, it is generally recommended to use anonymous namedtuple literals instead, as they work on any Python version.\n\n_`_namedtuple_of` is just provided to give namedtuple literals a representation that corresponds to an expression that can be used to recreate them._\n\n##### Example\n\n**Coconut:**\n```coconut\nusers = [\n    (id=1, name=\"Alice\"),\n    (id=2, name=\"Bob\"),\n]\n```\n\n**Python:**\n```coconut_python\nfrom collections import namedtuple\n\nusers = [\n    namedtuple(\"_\", \"id, name\")(1, \"Alice\"),\n    namedtuple(\"_\", \"id, name\")(2, \"Bob\"),\n]\n```\n\n\n### Set Literals\n\nCoconut allows an optional `s` to be prepended in front of Python set literals. While in most cases this does nothing, in the case of the empty set it lets Coconut know that it is an empty set and not an empty dictionary. Set literals also support unpacking syntax (e.g. `s{*xs}`).\n\nAdditionally, Coconut also supports replacing the `s` with an `f` to generate a `frozenset` or an `m` to generate a Coconut [`multiset`](#multiset).\n\n##### Example\n\n**Coconut:**\n```coconut\nempty_frozen_set = f{}\n```\n\n**Python:**\n```coconut_python\nempty_frozen_set = frozenset()\n```\n\n\n### Imaginary Literals\n\nIn addition to Python's `<num>j` or `<num>J` notation for imaginary literals, Coconut also supports `<num>i` or `<num>I`, to make imaginary literals more readable if used in a mathematical context.\n\n##### Python Docs\n\nImaginary literals are described by the following lexical definitions:\n```coconut\nimagnumber ::= (floatnumber | intpart) (\"j\" | \"J\" | \"i\" | \"I\")\n```\nAn imaginary literal yields a complex number with a real part of 0.0. Complex numbers are represented as a pair of floating point numbers and have the same restrictions on their range. To create a complex number with a nonzero real part, add a floating point number to it, e.g., `(3+4i)`. Some examples of imaginary literals:\n```coconut\n3.14i   10.i    10i     .001i   1e100i  3.14e-10i\n```\n\n##### Example\n\n**Coconut:**\n```coconut\n3 + 4i |> abs |> print\n```\n\n**Python:**\n```coconut_python\nprint(abs(3 + 4j))\n```\n\n\n### Alternative Ternary Operator\n\nPython supports the ternary operator syntax\n```coconut_python\nresult = if_true if condition else if_false\n```\nwhich, since Coconut is a superset of Python, Coconut also supports.\n\nHowever, Coconut also provides an alternative syntax that uses the more conventional argument ordering as\n```\nresult = if condition then if_true else if_false\n```\nmaking use of the Coconut-specific `then` keyword ([though Coconut still allows `then` as a variable name](#handling-keyword-variable-name-overlap)).\n\n##### Example\n\n**Coconut:**\n```coconut\nvalue = (\n    if should_use_a() then a\n    else if should_use_b() then b\n    else if should_use_c() then c\n    else fallback\n)\n```\n\n**Python:**\n```coconut_python\nvalue = (\n    a if should_use_a() else\n    b if should_use_b() else\n    c if should_use_c() else\n    fallback\n)\n```\n\n\n## Function Definition\n\n```{contents}\n---\nlocal:\ndepth: 1\n---\n```\n\n\n### Tail Call Optimization\n\nCoconut will perform automatic [tail call](https://en.wikipedia.org/wiki/Tail_call) optimization and tail recursion elimination on any function that meets the following criteria:\n\n1. it must directly return (using either `return` or [assignment function notation](#assignment-functions)) a call to itself (tail recursion elimination, the most powerful optimization) or another function (tail call optimization),\n2. it must not be a generator (uses `yield`) or an asynchronous function (uses `async`).\n\nTail call optimization (though not tail recursion elimination) will work even for 1) mutual recursion and 2) pattern-matching functions split across multiple definitions using [`addpattern`](#addpattern).\n\n##### Example\n\n**Coconut:**\n```coconut\n# unlike in Python, this function will never hit a maximum recursion depth error\ndef factorial(n, acc=1):\n    match n:\n        case 0:\n            return acc\n        case int() if n > 0:\n            return factorial(n-1, acc*n)\n```\n_Showcases tail recursion elimination._\n\n```coconut\n# unlike in Python, neither of these functions will ever hit a maximum recursion depth error\ndef is_even(0) = True\naddpattern def is_even(n `isinstance` int if n > 0) = is_odd(n-1)\n\ndef is_odd(0) = False\naddpattern def is_odd(n `isinstance` int if n > 0) = is_even(n-1)\n```\n_Showcases tail call optimization._\n\n**Python:**\n_Can't be done without rewriting the function(s)._\n\n#### `--no-tco` flag\n\nTail call optimization will be turned off if you pass the `--no-tco` command-line option, which is useful if you are having trouble reading your tracebacks and/or need maximum performance.\n\n`--no-tco` does not disable tail recursion elimination.\nThis is because tail recursion elimination is usually faster than doing nothing, while other types of tail call optimization are usually slower than doing nothing.\nTail recursion elimination results in a big performance win because Python has a fairly large function call overhead. By unwinding a recursive function, far fewer function calls need to be made.\nWhen the `--no-tco` flag is disabled, Coconut will attempt to do all types of tail call optimizations, handling non-recursive tail calls, split pattern-matching functions, mutual recursion, and tail recursion. When the `--no-tco` flag is enabled, Coconut will no longer perform any tail call optimizations other than tail recursion elimination.\n\n#### Tail Recursion Elimination and Python lambdas\n\nCoconut does not perform tail recursion elimination in functions that utilize lambdas or inner functions. This is because of the way that Python handles lambdas.\n\nEach lambda stores a pointer to the namespace enclosing it, rather than a copy of the namespace. Thus, if the Coconut compiler tries to recycle anything in the namespace that produced the lambda, which needs to be done for TRE, the lambda can be changed retroactively.\n\nA simple example demonstrating this behavior in Python:\n\n```python\nx = 1\nfoo = lambda: x\nprint(foo())  # 1\nx = 2         # Directly alter the values in the namespace enclosing foo\nprint(foo())  # 2 (!)\n```\n\nBecause this could have unintended and potentially damaging consequences, Coconut opts to not perform TRE on any function with a lambda or inner function.\n\n\n### Assignment Functions\n\nCoconut allows for assignment function definition that automatically returns the last line of the function body. An assignment function is constructed by substituting `=` for `:` after the function definition line. Thus, the syntax for assignment function definition is either\n```coconut\n[async] def <name>(<args>) = <expr>\n```\nfor one-liners or\n```coconut\n[async] def <name>(<args>) =\n    <stmts>\n    <expr>\n```\nfor full functions, where `<name>` is the name of the function, `<args>` are the functions arguments, `<stmts>` are any statements that the function should execute, and `<expr>` is the value that the function should return.\n\n_Note: Assignment function definition can be combined with infix and/or pattern-matching function definition._\n\n##### Rationale\n\nCoconut's Assignment function definition is as easy to write as assignment to a lambda, but will appear named in tracebacks, as it compiles to normal Python function definition.\n\n##### Example\n\n**Coconut:**\n```coconut\ndef binexp(x) = 2**x\n5 |> binexp |> print\n```\n\n**Python:**\n```coconut_python\ndef binexp(x): return 2**x\nprint(binexp(5))\n```\n\n\n### Pattern-Matching Functions\n\nCoconut pattern-matching functions are just normal functions, except where the arguments are patterns to be matched against instead of variables to be assigned to. The syntax for pattern-matching function definition is\n```coconut\n[match] def <name>(<arg>, <arg>, ... [if <cond>]) [-> <return_type>]:\n    <body>\n```\nwhere `<arg>` is defined as\n```coconut\n[*|**] <pattern> [= <default>]\n```\nwhere `<name>` is the name of the function, `<cond>` is an optional additional check, `<body>` is the body of the function, `<pattern>` is defined by Coconut's [`match` statement](#match), `<default>` is the optional default if no argument is passed, and `<return_type>` is the optional return type annotation (note that argument type annotations are not supported for pattern-matching functions). The `match` keyword at the beginning is optional, but is sometimes necessary to disambiguate pattern-matching function definition from normal function definition, since Python function definition will always take precedence. Note that the `async` and `match` keywords can be in any order.\n\nIf `<pattern>` has a variable name (via any variable binding that binds the entire pattern, e.g. `x` in `int(x)` or `[a, b] as x`), the resulting pattern-matching function will support keyword arguments using that variable name.\n\nIn addition to supporting pattern-matching in their arguments, pattern-matching function definitions also have a couple of notable differences compared to Python functions. Specifically:\n- If pattern-matching function definition fails, it will raise a [`MatchError`](#matcherror) (just like [destructuring assignment](#destructuring-assignment)) instead of a `TypeError`.\n- All defaults in pattern-matching function definition are late-bound rather than early-bound. Thus, `match def f(xs=[]) = xs` will instantiate a new list for each call where `xs` is not given, unlike `def f(xs=[]) = xs`, which will use the same list for all calls where `xs` is unspecified. This also allows defaults for later arguments to be specified in terms of matched values from earlier arguments, as in `match def f(x, y=x) = (x, y)`.\n\nPattern-matching function definition can also be combined with `async` functions, [`copyclosure` functions](#copyclosure-functions), [`yield` functions](#explicit-generators), [infix function definition](#infix-functions), and [assignment function syntax](#assignment-functions). The various keywords in front of the `def` can be put in any order.\n\n##### Example\n\n**Coconut:**\n```coconut\ndef last_two(_ + [a, b]):\n    return a, b\ndef xydict_to_xytuple({\"x\": x `isinstance` int, \"y\": y `isinstance` int}):\n    return x, y\n\nrange(5) |> last_two |> print\n{\"x\":1, \"y\":2} |> xydict_to_xytuple |> print\n```\n\n**Python:**\n_Can't be done without a long series of checks at the top of the function. See the compiled code for the Python syntax._\n\n\n### `case` Functions\n\nFor easily defining a pattern-matching function with many different cases, Coconut provides the `case def` syntax based on Coconut's [`case`](#case) syntax. The basic syntax is\n```\ncase def <name>:\n    case(<arg>, <arg>, ... [if <cond>]):\n        <body>\n    case(<arg>, <arg>, ... [if <cond>]):\n        <body>\n    ...\n```\nwhere the patterns in each `case` are checked in sequence until a match is found and the body under that match is executed, or a [`MatchError`](#matcherror) is raised. Each `case(...)` statement is effectively treated as a separate pattern-matching function signature that is checked independently, as if they had each been defined separately and then combined with [`addpattern`](#addpattern).\n\nAny individual body can also be defined with [assignment function syntax](#assignment-functions) such that\n```\ncase def <name>:\n    case(<arg>, <arg>, ... [if <cond>]) = <body>\n```\nis equivalent to\n```\ncase def <name>:\n    case(<arg>, <arg>, ... [if <cond>]): return <body>\n```\n\n`case` function definition can also be combined with `async` functions, [`copyclosure` functions](#copyclosure-functions), and [`yield` functions](#explicit-generators). The various keywords in front of the `def` can be put in any order.\n\n`case def` also allows for easily providing type annotations for pattern-matching functions. To add type annotations, inside the body of the `case def`, instead of just `case(...)` statements, include some `type(...)` statements as well, which will compile into [`typing.overload`](https://docs.python.org/3/library/typing.html#overload) declarations. The syntax is\n```\ncase def <name>[<type vars>]:\n    type(<arg>: <type>, <arg>: <type>, ...) -> <type>\n    type(<arg>: <type>, <arg>: <type>, ...) -> <type>\n    ...\n```\nwhich can be interspersed with the `case(...)` statements.\n\n##### Example\n\n**Coconut:**\n```coconut\ncase def my_min[T]:\n    type(x: T, y: T) -> T\n    case(x, y if x <= y) = x\n    case(x, y) = y\n\n    type(xs: T[]) -> T\n    case([x]) = x\n    case([x] + xs) = my_min(x, my_min(xs))\n```\n\n**Python:**\n_Can't be done without a long series of checks for each pattern-matching. See the compiled code for the Python syntax._\n\n### `addpattern` Functions\n\nCoconut provides the `addpattern def` syntax as a shortcut for the full\n```coconut\n@addpattern(func)\nmatch def func(...):\n  ...\n```\nsyntax using the [`addpattern`](#addpattern) decorator.\n\nIf you want to put a decorator on an `addpattern def` function, make sure to put it on the _last_ pattern function.\n\nFor complex multi-pattern functions, it is generally recommended to use [`case def`](#case-functions) over `addpattern def` in most situations.\n\n_Deprecated: `addpattern def` will act just like a normal [`match def`](#pattern-matching-functions) if the function has not previously been defined. This will show a [`CoconutWarning`](#coconutwarning) and is not recommended._\n\n##### Example\n\n**Coconut:**\n```coconut\naddpattern def factorial(0) = 1\naddpattern def factorial(n) = n * factorial(n - 1)\n```\n\n**Python:**\n_Can't be done without a complicated decorator definition and a long series of checks for each pattern-matching. See the compiled code for the Python syntax._\n\n\n### `copyclosure` Functions\n\nCoconut supports the syntax\n```\ncopyclosure def <name>(<args>):\n    <body>\n```\nto define a function that uses as its closure a shallow copy of its enclosing scopes at the time that the function is defined, rather than a reference to those scopes (as with normal Python functions).\n\nFor example,`in\n```coconut\ndef outer_func():\n    funcs = []\n    for x in range(10):\n        copyclosure def inner_func():\n            return x\n        funcs.append(inner_func)\n    return funcs\n```\nthe resulting `inner_func`s will each return a _different_ `x` value rather than all the same `x` value, since they look at what `x` was bound to at function definition time rather than during function execution.\n\n`copyclosure` functions can also be combined with `async` functions, [`yield` functions](#explicit-generators), [pattern-matching functions](#pattern-matching-functions), [infix function definition](#infix-functions), and [assignment function syntax](#assignment-functions). The various keywords in front of the `def` can be put in any order.\n\nIf `global` or `nonlocal` are used in a `copyclosure` function, they will not be able to modify variables in enclosing scopes. However, they will allow state to be preserved accross multiple calls to the `copyclosure` function.\n\n##### Example\n\n**Coconut:**\n```coconut\ndef outer_func():\n    funcs = []\n    for x in range(10):\n        copyclosure def inner_func():\n            return x\n        funcs.append(inner_func)\n    return funcs\n```\n\n**Python:**\n```coconut_python\nfrom functools import partial\n\ndef outer_func():\n    funcs = []\n    for x in range(10):\n        def inner_func(_x):\n            return _x\n        funcs.append(partial(inner_func, x))\n    return funcs\n```\n\n\n### Explicit Generators\n\nCoconut supports the syntax\n```\nyield def <name>(<args>):\n    <body>\n```\nto denote that you are explicitly defining a generator function. This is useful to ensure that, even if all the `yield`s in your function are removed, it'll always be a generator function.\n\nExplicit generator functions can also be combined with `async` functions, [`copyclosure` functions](#copyclosure-functions), [pattern-matching functions](#pattern-matching-functions), [infix function definition](#infix-functions), and [assignment function syntax](#assignment-functions) (though note that assignment function syntax here creates a generator return). The various keywords in front of the `def` can be put in any order.\n\n##### Example\n\n**Coconut:**\n```coconut\nyield def empty_it(): pass\n```\n\n**Python:**\n```coconut_python\ndef empty_it():\n    if False:\n        yield\n```\n\n\n### Dotted Function Definition\n\nCoconut allows for function definition using a dotted name to assign a function as a method of an object as specified in [PEP 542](https://www.python.org/dev/peps/pep-0542/). Dotted function definition can be combined with all other types of function definition above.\n\n##### Example\n\n**Coconut:**\n```coconut\ndef MyClass.my_method(self):\n    ...\n```\n\n**Python:**\n```coconut_python\ndef my_method(self):\n    ...\nMyClass.my_method = my_method\n```\n\n\n## Statements\n\n```{contents}\n---\nlocal:\ndepth: 1\n---\n```\n\n\n### Destructuring Assignment\n\nCoconut supports significantly enhanced destructuring assignment, similar to Python's tuple/list destructuring, but much more powerful. The syntax for Coconut's destructuring assignment is\n```coconut\n[match] <pattern> = <value>\n```\nwhere `<value>` is any expression and `<pattern>` is defined by Coconut's [`match` statement](#match). The `match` keyword at the beginning is optional, but is sometimes necessary to disambiguate destructuring assignment from normal assignment, which will always take precedence. Coconut's destructuring assignment is equivalent to a match statement that follows the syntax:\n```coconut\nmatch <pattern> in <value>:\n    pass\nelse:\n    err = MatchError(<error message>)\n    err.pattern = \"<pattern>\"\n    err.value = <value>\n    raise err\n```\nIf a destructuring assignment statement fails, then instead of continuing on as if a `match` block had failed, a [`MatchError`](#matcherror) object will be raised describing the failure.\n\n##### Example\n\n**Coconut:**\n```coconut\n_ + [a, b] = [0, 1, 2, 3]\nprint(a, b)\n```\n\n**Python:**\n_Can't be done without a long series of checks in place of the destructuring assignment statement. See the compiled code for the Python syntax._\n\n\n### Type Parameter Syntax\n\nCoconut fully supports [Python 3.12 PEP 695](https://peps.python.org/pep-0695/) type parameter syntax on all Python versions.\n\nThat includes type parameters for classes, [`data` types](#data), and [all types of function definition](#function-definition). For different types of function definition, the type parameters always come in brackets right after the function name. Coconut's [enhanced type annotation syntax](#enhanced-type-annotation) is supported for all type parameter bounds.\n\n_Warning: until `mypy` adds support for `infer_variance=True` in `TypeVar`, `TypeVar`s created this way will always be invariant._\n\nAdditionally, Coconut supports the alternative bounds syntax of `type NewType[T <: bound] = ...` rather than `type NewType[T: bound] = ...`, to make it more clear that it is an upper bound rather than a type. In `--strict` mode, `<:` is required over `:` for all type parameter bounds. _Deprecated: `<=` can also be used as an alternative to `<:`._\n\nNote that the `<:` syntax should only be used for [type bounds](https://peps.python.org/pep-0695/#upper-bound-specification), not [type constraints](https://peps.python.org/pep-0695/#constrained-type-specification)—for type constraints, Coconut style prefers the vanilla Python `:` syntax, which helps to disambiguate between the two cases, as they are functionally different but otherwise hard to tell apart at a glance. This is enforced in `--strict` mode.\n\n_Note that, by default, all type declarations are wrapped in strings to enable forward references and improve runtime performance. If you don't want that—e.g. because you want to use type annotations at runtime—simply pass the `--no-wrap-types` flag._\n\n##### PEP 695 Docs\n\nDefining a generic class prior to this PEP looks something like this.\n\n```coconut_python\nfrom typing import Generic, TypeVar\n\n_T_co = TypeVar(\"_T_co\", covariant=True, bound=str)\n\nclass ClassA(Generic[_T_co]):\n    def method1(self) -> _T_co:\n        ...\n```\n\nWith the new syntax, it looks like this.\n\n```coconut\nclass ClassA[T: str]:\n    def method1(self) -> T:\n        ...\n```\n\nHere is an example of a generic function today.\n\n```coconut_python\nfrom typing import TypeVar\n\n_T = TypeVar(\"_T\")\n\ndef func(a: _T, b: _T) -> _T:\n    ...\n```\n\nAnd the new syntax.\n\n```coconut\ndef func[T](a: T, b: T) -> T:\n    ...\n```\n\nHere is an example of a generic type alias today.\n\n```coconut_python\nfrom typing import TypeAlias\n\n_T = TypeVar(\"_T\")\n\nListOrSet: TypeAlias = list[_T] | set[_T]\n```\n\nAnd with the new syntax.\n\n```coconut\ntype ListOrSet[T] = list[T] | set[T]\n```\n\n\n##### Example\n\n**Coconut:**\n```coconut\ndata D[T](x: T, y: T)\n\ndef my_ident[T](x: T) -> T = x\n```\n\n**Python:**\n_Can't be done without a complex definition for the data type. See the compiled code for the Python syntax._\n\n\n### Implicit `pass`\n\nCoconut supports the simple `class name(base)` and `data name(args)` as aliases for `class name(base): pass` and `data name(args): pass`.\n\n##### Example\n\n**Coconut:**\n```coconut\nclass Tree\ndata Empty from Tree\ndata Leaf(item) from Tree\ndata Node(left, right) from Tree\n```\n\n**Python:**\n_Can't be done without a series of method definitions for each data type. See the compiled code for the Python syntax._\n\n\n### Statement Nesting\n\nCoconut supports the nesting of compound statements on the same line. This allows the mixing of `match` and `if` statements together, as well as compound `try` statements.\n\n##### Example\n\n**Coconut:**\n```coconut\nif invalid(input_list):\n    raise Exception()\nelse: match [head] + tail in input_list:\n    print(head, tail)\nelse:\n    print(input_list)\n```\n\n**Python:**\n```coconut_python\nfrom collections.abc import Sequence\nif invalid(input_list):\n    raise Exception()\nelif isinstance(input_list, Sequence) and len(input_list) >= 1:\n    head, tail = inputlist[0], inputlist[1:]\n    print(head, tail)\nelse:\n    print(input_list)\n```\n\n\n### `except` Statements\n\nPython 3 requires that if multiple exceptions are to be caught, they must be placed inside of parentheses, so as to disallow Python 2's use of a comma instead of `as`. Coconut allows commas in except statements to translate to catching multiple exceptions without the need for parentheses, since, as in Python 3, `as` is always required to bind the exception to a name.\n\n##### Example\n\n**Coconut:**\n```coconut\ntry:\n    unsafe_func(arg)\nexcept SyntaxError, ValueError as err:\n    handle(err)\n```\n\n**Python:**\n```coconut_python\ntry:\n    unsafe_func(arg)\nexcept (SyntaxError, ValueError) as err:\n    handle(err)\n```\n\n\n### In-line `global` And `nonlocal` Assignment\n\nCoconut allows for `global` or `nonlocal` to precede assignment to a list of variables or (augmented) assignment to a variable to make that assignment `global` or `nonlocal`, respectively.\n\n##### Example\n\n**Coconut:**\n```coconut\nglobal state_a, state_b = 10, 100\nglobal state_c += 1\n```\n\n**Python:**\n```coconut_python\nglobal state_a, state_b; state_a, state_b = 10, 100\nglobal state_c; state_c += 1\n```\n\n\n### Code Passthrough\n\nCoconut supports the ability to pass arbitrary code through the compiler without being touched, for compatibility with other variants of Python, such as [Cython](http://cython.org/) or [Mython](http://mython.org/). When using Coconut to compile to another variant of Python, make sure you [name your source file properly](#naming-source-files) to ensure the resulting compiled code has the right file extension for the intended usage.\n\nAnything placed between `\\(` and the corresponding close parenthesis will be passed through, as well as any line starting with `\\\\`, which will have the additional effect of allowing indentation under it.\n\n##### Example\n\n**Coconut:**\n```coconut\n\\\\cdef f(x):\n    return x |> g\n```\n\n**Python:**\n```coconut_python\ncdef f(x):\n    return g(x)\n```\n\n\n### Enhanced Parenthetical Continuation\n\nSince Coconut syntax is a superset of the latest Python 3 syntax, Coconut supports the same line continuation syntax as Python. That means both backslash line continuation and implied line continuation inside of parentheses, brackets, or braces will all work.\n\nIn Python, however, there are some cases (such as multiple `with` statements) where only backslash continuation, and not parenthetical continuation, is supported. Coconut adds support for parenthetical continuation in all these cases. This also includes support as per [PEP 679](https://peps.python.org/pep-0679) for parenthesized `assert` statements.\n\nSupporting parenthetical continuation everywhere allows the [PEP 8](https://www.python.org/dev/peps/pep-0008/) convention, which avoids backslash continuation in favor of implied parenthetical continuation, to always be possible to follow. From PEP 8:\n\n> The preferred way of wrapping long lines is by using Python's implied line continuation inside parentheses, brackets and braces. Long lines can be broken over multiple lines by wrapping expressions in parentheses. These should be used in preference to using a backslash for line continuation.\n\n_Note: Passing `--strict` will enforce the PEP 8 convention by disallowing backslash continuations._\n\n##### Example\n\n**Coconut:**\n```coconut\nwith (open('/path/to/some/file/you/want/to/read') as file_1,\n      open('/path/to/some/file/being/written', 'w') as file_2):\n    file_2.write(file_1.read())\n```\n\n**Python:**\n```coconut_python\n# split into two with statements for Python 2.6 compatibility\nwith open('/path/to/some/file/you/want/to/read') as file_1:\n    with open('/path/to/some/file/being/written', 'w') as file_2:\n        file_2.write(file_1.read())\n```\n\n\n### Assignment Expression Chaining\n\nUnlike Python, Coconut allows assignment expressions to be chained, as in `a := b := c`. Note, however, that assignment expressions in general are currently only supported on `--target 3.8` or higher.\n\n##### Example\n\n**Coconut:**\n```coconut\n(a := b := 1)\n```\n\n**Python:**\n```coconut_python\n(a := (b := 1))\n```\n\n\n## Built-Ins\n\n```{contents}\n---\nlocal:\ndepth: 2\n---\n```\n\n\n### Built-In Function Decorators\n\n```{contents}\n---\nlocal:\ndepth: 1\n---\n```\n\n#### `addpattern`\n\n**addpattern**(_base\\_func_, *_add\\_funcs_, _allow\\_any\\_func_=`False`)\n\nTakes one argument that is a [pattern-matching function](#pattern-matching-functions), and returns a decorator that adds the patterns in the existing function to the new function being decorated, where the existing patterns are checked first, then the new. `addpattern` also supports a shortcut syntax where the new patterns can be passed in directly.\n\nRoughly equivalent to:\n```coconut_python\ndef _pattern_adder(base_func, add_func):\n    def add_pattern_func(*args, **kwargs):\n        try:\n            return base_func(*args, **kwargs)\n        except MatchError:\n            return add_func(*args, **kwargs)\n    return add_pattern_func\ndef addpattern(base_func, *add_funcs, allow_any_func=False):\n    \"\"\"Decorator to add a new case to a pattern-matching function (where the new case is checked last).\n\n    Pass allow_any_func=True to allow any object as the base_func rather than just pattern-matching functions.\n    If add_func is passed, addpattern(base_func, add_func) is equivalent to addpattern(base_func)(add_func).\n    \"\"\"\n    if not add_funcs:\n        return addpattern$(base_func)\n    for add_func in add_funcs:\n        base_func = pattern_adder(base_func, add_func)\n    return base_func\n```\n\nIf you want to give an `addpattern` function a docstring, make sure to put it on the _last_ function.\n\nNote that the function taken by `addpattern` must be a pattern-matching function. If `addpattern` receives a non pattern-matching function, the function with not raise `MatchError`, and `addpattern` won't be able to detect the failed match. Thus, if a later function was meant to be called, `addpattern` will not know that the first match failed and the correct path will never be reached.\n\nFor example, the following code raises a `TypeError`:\n```coconut\ndef print_type():\n    print(\"Received no arguments.\")\n\n@addpattern(print_type)\ndef print_type(int()):\n    print(\"Received an int.\")\n\nprint_type()  # appears to work\nprint_type(1) # TypeError: print_type() takes 0 positional arguments but 1 was given\n```\n\nThis can be fixed by using either the `match` keyword. For example:\n```coconut\nmatch def print_type():\n    print(\"Received no arguments.\")\n\naddpattern def print_type(int()):\n    print(\"Received an int.\")\n\nprint_type(1)  # Works as expected\nprint_type(\"This is a string.\") # Raises MatchError\n```\n\nThe last case in an `addpattern` function, however, doesn't have to be a pattern-matching function if it is intended to catch all remaining cases.\n\nTo catch this mistake, `addpattern` will emit a warning if passed what it believes to be a non-pattern-matching function. However, this warning can sometimes be erroneous if the original pattern-matching function has been wrapped in some way, in which case you can pass `allow_any_func=True` to dismiss the warning.\n\n##### Example\n\n**Coconut:**\n```coconut\ndef factorial(0) = 1\n\n@addpattern(factorial)\ndef factorial(n) = n * factorial(n - 1)\n```\n_Simple example of adding a new pattern to a pattern-matching function._\n\n```coconut\n\"[A], [B]\" |> windowsof$(3) |> map$(addpattern(\n    (def ((\"[\",\"A\",\"]\")) => \"A\"),\n    (def ((\"[\",\"B\",\"]\")) => \"B\"),\n    (def ((_,_,_)) => None),\n)) |> filter$((.is None) ..> (not)) |> list |> print\n```\n_An example of a case where using the `addpattern` function is necessary over the [`addpattern` keyword](#addpattern-functions) due to the use of in-line pattern-matching [statement lambdas](#statement-lambdas)._\n\n**Python:**\n_Can't be done without a complicated decorator definition and a long series of checks for each pattern-matching. See the compiled code for the Python syntax._\n\n##### `prepattern`\n\n**DEPRECATED:** Coconut also has a `prepattern` built-in, which adds patterns in the opposite order of `addpattern`; `prepattern` is defined as:\n\n```coconut_python\ndef prepattern(base_func):\n    \"\"\"Decorator to add a new case to a pattern-matching function,\n    where the new case is checked first.\"\"\"\n    def pattern_prepender(func):\n        return addpattern(func)(base_func)\n    return pattern_prepender\n```\n_Note: Passing `--strict` disables deprecated features._\n\n#### `memoize`\n\n**memoize**(_maxsize_=`None`, _typed_=`False`)\n\n**memoize**(_user\\_function_)\n\nCoconut provides `functools.lru_cache` as a built-in under the name `memoize` with the modification that the _maxsize_ parameter is set to `None` by default. `memoize` makes the use case of optimizing recursive functions easier, as a _maxsize_ of `None` is usually what is desired in that case.\n\nUse of `memoize` requires `functools.lru_cache`, which exists in the Python 3 standard library, but under Python 2 will require `pip install backports.functools_lru_cache` to function. Additionally, if on Python 2 and `backports.functools_lru_cache` is present, Coconut will patch `functools` such that `functools.lru_cache = backports.functools_lru_cache.lru_cache`.\n\nNote that, if the function to be memoized is a generator or otherwise returns an iterator, [`recursive_generator`](#recursive_generator) can also be used to achieve a similar effect, the use of which is required for recursive generators.\n\n##### Python Docs\n\n@**memoize**(_user\\_function_)\n\n@**memoize**(_maxsize=None, typed=False_)\n\nDecorator to wrap a function with a memoizing callable that saves up to the _maxsize_ most recent calls. It can save time when an expensive or I/O bound function is periodically called with the same arguments.\n\nSince a dictionary is used to cache results, the positional and keyword arguments to the function must be hashable.\n\nDistinct argument patterns may be considered to be distinct calls with separate cache entries. For example, `f(a=1, b=2)` and `f(b=2, a=1)` differ in their keyword argument order and may have two separate cache entries.\n\nIf _user\\_function_ is specified, it must be a callable. This allows the _memoize_ decorator to be applied directly to a user function, leaving the maxsize at its default value of `None`:\n```coconut_python\n@memoize\ndef count_vowels(sentence):\n    return sum(sentence.count(vowel) for vowel in 'AEIOUaeiou')\n```\n\nIf _maxsize_ is set to `None`, the LRU feature is disabled and the cache can grow without bound.\n\nIf _typed_ is set to true, function arguments of different types will be cached separately. If typed is false, the implementation will usually regard them as equivalent calls and only cache a single result. (Some types such as str and int may be cached separately even when typed is false.)\n\nNote, type specificity applies only to the function’s immediate arguments rather than their contents. The scalar arguments, `Decimal(42)` and `Fraction(42)` are be treated as distinct calls with distinct results. In contrast, the tuple arguments `('answer', Decimal(42))` and `('answer', Fraction(42))` are treated as equivalent.\n\nThe decorator also provides a `cache_clear()` function for clearing or invalidating the cache.\n\nThe original underlying function is accessible through the `__wrapped__` attribute. This is useful for introspection, for bypassing the cache, or for rewrapping the function with a different cache.\n\nThe cache keeps references to the arguments and return values until they age out of the cache or until the cache is cleared.\n\nIf a method is cached, the `self` instance argument is included in the cache. See [How do I cache method calls?](https://docs.python.org/3/faq/programming.html#faq-cache-method-calls)\n\nAn [LRU (least recently used) cache](https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU)) works best when the most recent calls are the best predictors of upcoming calls (for example, the most popular articles on a news server tend to change each day). The cache’s size limit assures that the cache does not grow without bound on long-running processes such as web servers.\n\nIn general, the LRU cache should only be used when you want to reuse previously computed values. Accordingly, it doesn’t make sense to cache functions with side-effects, functions that need to create distinct mutable objects on each call, or impure functions such as time() or random().\n\nExample of efficiently computing Fibonacci numbers using a cache to implement a dynamic programming technique:\n```coconut_pycon\n@memoize\ndef fib(n):\n    if n < 2:\n        return n\n    return fib(n-1) + fib(n-2)\n\n>>> [fib(n) for n in range(16)]\n[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610]\n\n>>> fib.cache_info()\nCacheInfo(hits=28, misses=16, maxsize=None, currsize=16)\n```\n\n##### Example\n\n**Coconut:**\n```coconut\ndef fib(n if n < 2) = n\n\n@memoize\n@addpattern(fib)\ndef fib(n) = fib(n-1) + fib(n-2)\n```\n\n**Python:**\n```coconut_python\ntry:\n    from functools import lru_cache\nexcept ImportError:\n    from backports.functools_lru_cache import lru_cache\n@lru_cache(maxsize=None)\ndef fib(n):\n    if n < 2:\n        return n\n    return fib(n-1) + fib(n-2)\n```\n\n#### `override`\n\n**override**(_func_)\n\nCoconut provides the `@override` decorator to allow declaring a method definition in a subclass as an override of some parent class method. When `@override` is used on a method, if a method of the same name does not exist on some parent class, the class definition will raise a `RuntimeError`. `@override` works with other decorators such as `@classmethod` and `@staticmethod`, but only if `@override` is the outer-most decorator.\n\nAdditionally, `override` will present to type checkers as [`typing_extensions.override`](https://pypi.org/project/typing-extensions/).\n\n##### Example\n\n**Coconut:**\n```coconut\nclass A:\n    x = 1\n    def f(self, y) = self.x + y\n\nclass B:\n    @override\n    def f(self, y) = self.x + y + 1\n```\n\n**Python:**\n_Can't be done without a long decorator definition. The full definition of the decorator in Python can be found in the Coconut header._\n\n#### `recursive_generator`\n\n**recursive\\_generator**(_func_)\n\nCoconut provides a `recursive_generator` decorator that memoizes and makes [`reiterable`](#reiterable) any generator or other stateless function that returns an iterator. To use `recursive_generator` on a function, it must meet the following criteria:\n\n1. your function either always `return`s an iterator or generates an iterator using `yield`,\n2. when called multiple times with arguments that are equal, your function produces the same iterator (your function is stateless), and\n3. your function gets called (usually calls itself) multiple times with the same arguments.\n\nImportantly, `recursive_generator` also allows the resolution of a [nasty segmentation fault in Python's iterator logic that has never been fixed](http://bugs.python.org/issue14010). Specifically, instead of writing\n```coconut\nseq = get_elem() :: seq\n```\nwhich will crash due to the aforementioned Python issue, write\n```coconut\n@recursive_generator\ndef seq() = get_elem() :: seq()\n```\nwhich will work just fine.\n\nOne pitfall to keep in mind working with `recursive_generator` is that it shouldn't be used in contexts where the function can potentially be called multiple times with the same iterator object as an input, but with that object not actually corresponding to the same items (e.g. because the first time the object hasn't been iterated over yet and the second time it has been).\n\n_Deprecated: `recursive_iterator` is available as a deprecated alias for `recursive_generator`. Note that deprecated features are disabled in `--strict` mode._\n\n##### Example\n\n**Coconut:**\n```coconut\n@recursive_generator\ndef fib() = (1, 1) :: map((+), fib(), fib()$[1:])\n```\n\n**Python:**\n_Can't be done without a long decorator definition. The full definition of the decorator in Python can be found in the Coconut header._\n\n\n### Built-In Types\n\n```{contents}\n---\nlocal:\ndepth: 1\n---\n```\n\n#### `multiset`\n\n**multiset**(_iterable_=`None`, /, **kwds)\n\nCoconut provides `multiset` as a built-in subclass of [`collections.Counter`](https://docs.python.org/3/library/collections.html#collections.Counter) that additionally implements the full [Set and MutableSet interfaces](https://docs.python.org/3/library/collections.abc.html).\n\nFor easily constructing multisets, Coconut also provides [multiset literals](#set-literals).\n\nThe new methods provided by `multiset` on top of `collections.Counter` are:\n- multiset.**add**(_item_): Add an element to a multiset.\n- multiset.**discard**(_item_): Remove an element from a multiset if it is a member.\n- multiset.**remove**(_item_): Remove an element from a multiset; it must be a member.\n- multiset.**isdisjoint**(_other_): Return True if two multisets have a null intersection.\n- multiset.**\\_\\_xor\\_\\_**(_other_): Return the symmetric difference of two multisets as a new multiset. Specifically: `a ^ b = (a - b) | (b - a)`\n- multiset.**count**(_item_): Return the number of times an element occurs in a multiset. Equivalent to `multiset[item]`, but additionally verifies the count is non-negative.\n- multiset.**\\_\\_fmap\\_\\_**(_func_): Apply a function to the contents of the multiset, preserving counts; magic method for [`fmap`](#fmap).\n\nCoconut also ensures that `multiset` supports [rich comparisons and `Counter.total()`](https://docs.python.org/3/library/collections.html#collections.Counter) on all Python versions.\n\n##### Example\n\n**Coconut:**\n```coconut\nmy_multiset = m{1, 1, 2}\nmy_multiset.add(3)\nmy_multiset.remove(2)\nprint(my_multiset)\n```\n\n**Python:**\n```coconut_python\nfrom collections import Counter\nmy_counter = Counter((1, 1, 2))\nmy_counter[3] += 1\nmy_counter[2] -= 1\nif my_counter[2] <= 0:\n    del my_counter[2]\nprint(my_counter)\n```\n\n#### `Expected`\n\n**Expected**(_result_=`None`, _error_=`None`)\n\nCoconut's `Expected` built-in is a Coconut [`data` type](#data) that represents a value that may or may not be an error, similar to Haskell's [`Either`](https://hackage.haskell.org/package/base-4.17.0.0/docs/Data-Either.html).\n\n`Expected` is effectively equivalent to the following:\n```coconut\ndata Expected[T](result: T? = None, error: BaseException? = None):\n    def __bool__(self) -> bool:\n        return self.error is None\n    def __fmap__[U](self, func: T -> U) -> Expected[U]:\n        \"\"\"Maps func over the result if it exists.\n\n        __fmap__ should be used directly only when fmap is not available (e.g. when consuming an Expected in vanilla Python).\n        \"\"\"\n        return self.__class__(func(self.result)) if self else self\n    def and_then[U](self, func: T -> Expected[U]) -> Expected[U]:\n        \"\"\"Maps a T -> Expected[U] over an Expected[T] to produce an Expected[U].\n        Implements a monadic bind. Equivalent to fmap ..> .join().\"\"\"\n        return self |> fmap$(func) |> .join()\n    def join(self: Expected[Expected[T]]) -> Expected[T]:\n        \"\"\"Monadic join. Converts Expected[Expected[T]] to Expected[T].\"\"\"\n        if not self:\n            return self\n        if not self.result `isinstance` Expected:\n            raise TypeError(\"Expected.join() requires an Expected[Expected[_]]\")\n        return self.result\n    def map_error(self, func: BaseException -> BaseException) -> Expected[T]:\n        \"\"\"Maps func over the error if it exists.\"\"\"\n        return self if self else self.__class__(error=func(self.error))\n    def handle(self, err_type, handler: BaseException -> T) -> Expected[T]:\n        \"\"\"Recover from the given err_type by calling handler on the error to determine the result.\"\"\"\n        if not self and isinstance(self.error, err_type):\n            return self.__class__(handler(self.error))\n        return self\n    def expect_error(self, *err_types: BaseException) -> Expected[T]:\n        \"\"\"Raise any errors that do not match the given error types.\"\"\"\n        if not self and not isinstance(self.error, err_types):\n            raise self.error\n        return self\n    def unwrap(self) -> T:\n        \"\"\"Unwrap the result or raise the error.\"\"\"\n        if not self:\n            raise self.error\n        return self.result\n    def or_else[U](self, func: BaseException -> Expected[U]) -> Expected[T | U]:\n        \"\"\"Return self if no error, otherwise return the result of evaluating func on the error.\"\"\"\n        return self if self else func(self.error)\n    def result_or_else[U](self, func: BaseException -> U) -> T | U:\n        \"\"\"Return the result if it exists, otherwise return the result of evaluating func on the error.\"\"\"\n        return self.result if self else func(self.error)\n    def result_or[U](self, default: U) -> T | U:\n        \"\"\"Return the result if it exists, otherwise return the default.\n\n        Since .result_or() completely silences errors, it is highly recommended that you\n        call .expect_error() first to explicitly declare what errors you are okay silencing.\n        \"\"\"\n        return self.result if self else default\n```\n\n`Expected` is primarily used as the return type for [`safe_call`](#safe_call).\n\nGenerally, the best way to use `Expected` is with [`fmap`](#fmap), which will apply a function to the result if it exists, or otherwise retain the error. If you want to sequence multiple `Expected`-returning operations, `.and_then` should be used instead of `fmap`. To handle specific errors, the following patterns are equivalent:\n```\nsafe_call(might_raise_IOError).handle(IOError, const 10).unwrap()\nsafe_call(might_raise_IOError).expect_error(IOError).result_or(10)\n```\n\nTo match against an `Expected`, just:\n```\nExpected(res) = Expected(\"result\")\nExpected(error=err) = Expected(error=TypeError())\n```\n\n##### Example\n\n**Coconut:**\n```coconut\ndef try_divide(x: float, y: float) -> Expected[float]:\n    try:\n        return Expected(x / y)\n    except Exception as err:\n        return Expected(error=err)\n\ntry_divide(1, 2) |> fmap$(.+1) |> print\ntry_divide(1, 0) |> fmap$(.+1) |> print\n```\n\n**Python:**\n_Can't be done without a complex `Expected` definition. See the compiled code for the Python syntax._\n\n#### `MatchError`\n\nA `MatchError` is raised when a [destructuring assignment](#destructuring-assignment) or [pattern-matching function](#pattern-matching-functions) fails, and thus `MatchError` is provided as a built-in for catching those errors. `MatchError` objects support three attributes: `pattern`, which is a string describing the failed pattern; `value`, which is the object that failed to match that pattern; and `message` which is the full error message. To avoid unnecessary `repr` calls, `MatchError` only computes the `message` once it is actually requested.\n\nAdditionally, if you are using [view patterns](#match), you might need to raise your own `MatchError` (though you can also just use a destructuring assignment or pattern-matching function definition to do so). To raise your own `MatchError`, just `raise MatchError(pattern, value)` (both arguments are optional).\n\nIn some cases where there are multiple Coconut packages installed at the same time, there may be multiple `MatchError`s defined in different packages. Coconut can perform some magic under the hood to make sure that all these `MatchError`s will seamlessly interoperate, but only if all such packages are compiled in [`--package` mode rather than `--standalone` mode](#compilation-modes).\n\n### `CoconutWarning`\n\n`CoconutWarning` is the [`Warning`](https://docs.python.org/3/library/exceptions.html#Warning) subclass used for all runtime Coconut warnings; see [`warnings`](https://docs.python.org/3/library/warnings.html).\n\n\n### Generic Built-In Functions\n\n```{contents}\n---\nlocal:\ndepth: 1\n---\n```\n\n#### `makedata`\n\n**makedata**(_data\\_type_, *_args_)\n\nCoconut provides the `makedata` function to construct a container given the desired type and contents. This is particularly useful when writing alternative constructors for [`data`](#data) types by overwriting `__new__`, since it allows direct access to the base constructor of the data type created with the Coconut `data` statement.\n\n`makedata` takes the data type to construct as the first argument, and the objects to put in that container as the rest of the arguments.\n\n`makedata` can also be used to extract the underlying constructor for [`match data`](#match-data) types that bypasses the normal pattern-matching constructor.\n\nAdditionally, `makedata` can also be called with non-`data` type as the first argument, in which case it will do its best to construct the given type of object with the given arguments. This functionality is used internally by `fmap`.\n\n##### `datamaker`\n\n**DEPRECATED:** Coconut also has a `datamaker` built-in, which partially applies `makedata`; `datamaker` is defined as:\n```coconut\ndef datamaker(data_type):\n    \"\"\"Get the original constructor of the given data type or class.\"\"\"\n    return makedata$(data_type)\n```\n_Note: Passing `--strict` disables deprecated features._\n\n##### Example\n\n**Coconut:**\n```coconut\ndata Tuple(elems):\n    def __new__(cls, *elems):\n        return elems |> makedata$(cls)\n```\n\n**Python:**\n_Can't be done without a series of method definitions for each data type. See the compiled code for the Python syntax._\n\n#### `fmap`\n\n**fmap**(_func_, _obj_)\n\nIn Haskell, `fmap(func, obj)` takes a data type `obj` and returns a new data type with `func` mapped over the contents. Coconut's `fmap` function does the exact same thing for Coconut's [data types](#data).\n\n`fmap` can also be used on the built-in objects `str`, `dict`, `list`, `tuple`, `set`, `frozenset`, `bytes`, `bytearray`, and `dict` as a variant of `map` that returns back an object of the same type.\n\nFor `dict`, or any other `collections.abc.Mapping`, `fmap` will map over the mapping's `.items()` instead of the default iteration through its `.keys()`, with the new mapping reconstructed from the mapped over items. _Deprecated: `fmap$(starmap_over_mappings=True)` will `starmap` over the `.items()` instead of `map` over them._\n\nFor asynchronous iterables, `fmap` will map asynchronously, making `fmap` equivalent in that case to\n```coconut_python\nasync def fmap_over_async_iters(func, async_iter):\n    async for item in async_iter:\n        yield func(item)\n```\nsuch that `fmap` can effectively be used as an async map.\n\nSome objects from external libraries are also given special support:\n* For [`numpy`](#numpy-integration) objects, `fmap` will use [`np.vectorize`](https://docs.scipy.org/doc/numpy/reference/generated/numpy.vectorize.html) to produce the result.\n* For [`pandas`](https://pandas.pydata.org/) objects, `fmap` will use [`.apply`](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.apply.html) along the last axis (so row-wise for `DataFrame`'s, element-wise for `Series`'s).\n* For [`xarray`](https://docs.xarray.dev/en/stable/) objects, `fmap` will first convert them into `pandas` objects, apply `fmap`, then convert them back.\n\nThe behavior of `fmap` for a given object can be overridden by defining an `__fmap__(self, func)` magic method that will be called whenever `fmap` is invoked on that object. Note that `__fmap__` implementations should always satisfy the [Functor Laws](https://wiki.haskell.org/Functor).\n\n_Deprecated: `fmap(func, obj, fallback_to_init=True)` will fall back to `obj.__class__(map(func, obj))` if no `fmap` implementation is available rather than raise `TypeError`._\n\n##### Example\n\n**Coconut:**\n```coconut\n[1, 2, 3] |> fmap$(x => x+1) == [2, 3, 4]\n\nclass Maybe\ndata Nothing() from Maybe\ndata Just(n) from Maybe\n\nJust(3) |> fmap$(x => x*2) == Just(6)\nNothing() |> fmap$(x => x*2) == Nothing()\n```\n\n**Python:**\n_Can't be done without a series of method definitions for each data type. See the compiled code for the Python syntax._\n\n\n#### `call`\n\n**call**(_func_, /, *_args_, \\*\\*_kwargs_)\n\nCoconut's `call` simply implements function application. Thus, `call` is effectively equivalent to\n```coconut\ndef call(f, /, *args, **kwargs) = f(*args, **kwargs)\n```\n\n`call` is primarily useful as an [operator function](#operator-functions) for function application when writing in a point-free style.\n\n_Deprecated: `of` is available as a deprecated alias for `call`. Note that deprecated features are disabled in `--strict` mode._\n\n#### `safe_call`\n\n**safe_call**(_func_, /, *_args_, \\*\\*_kwargs_)\n\nCoconut's `safe_call` is a version of [`call`](#call) that catches any `Exception`s and returns an [`Expected`](#expected) containing either the result or the error.\n\n`safe_call` is effectively equivalent to:\n```coconut\ndef safe_call(f, /, *args, **kwargs):\n    try:\n        return Expected(f(*args, **kwargs))\n    except Exception as err:\n        return Expected(error=err)\n```\n\nTo define a function that always returns an `Expected` rather than raising any errors, simply decorate it with `@safe_call$`.\n\n##### Example\n\n**Coconut:**\n```coconut\nres, err = safe_call(=> 1 / 0) |> fmap$(.+1)\n```\n\n**Python:**\n_Can't be done without a complex `Expected` definition. See the compiled code for the Python syntax._\n\n#### `ident`\n\n**ident**(_x_, *, _side\\_effect_=`None`)\n\nCoconut's `ident` is the identity function, generally equivalent to `x => x`.\n\n`ident` also accepts one keyword-only argument, `side_effect`, which specifies a function to call on the argument before it is returned. Thus, `ident` is effectively equivalent to:\n```coconut\ndef ident(x, *, side_effect=None):\n    if side_effect is not None:\n        side_effect(x)\n    return x\n```\n\n`ident` is primarily useful when writing in a point-free style (e.g. in combination with [`lift`](#lift)) or for debugging [pipes](#pipes) where `ident$(side_effect=print)` can let you see what is being piped.\n\n#### `const`\n\n**const**(_value_)\n\nCoconut's `const` simply constructs a function that, whatever its arguments, just returns the given value. Thus, `const` is equivalent to a pickleable version of\n```coconut\ndef const(value) = (*args, **kwargs) => value\n```\n\n`const` is primarily useful when writing in a point-free style (e.g. in combination with [`lift`](#lift)).\n\n#### `flip`\n\n**flip**(_func_, _nargs_=`None`)\n\nCoconut's `flip(f, nargs=None)` is a higher-order function that, given a function `f`, returns a new function with reversed argument order. If `nargs` is passed, only the first `nargs` arguments are reversed.\n\nFor the binary case, `flip` works as\n```coconut\nflip(f, 2)(x, y) == f(y, x)\n```\nsuch that `flip$(?, 2)` implements the `C` combinator (`flip` in Haskell).\n\nIn the general case, `flip` is equivalent to a pickleable version of\n```coconut\ndef flip(f, nargs=None) =\n    (*args, **kwargs) => (\n        f(*args[::-1], **kwargs) if nargs is None\n        else f(*(args[nargs-1::-1] + args[nargs:]), **kwargs)\n    )\n```\n\n#### `lift` and `lift_apart`\n\n##### **lift**(_func_)\n\n##### **lift**(_func_, *_func\\_args_, **_func\\_kwargs_)\n\nCoconut's `lift` built-in is a higher-order function that takes in a function and “lifts” it up so that all of its arguments are functions.\n\nAs a simple example, for a binary function `f(x, y)` and two unary functions `g(z)` and `h(z)`, `lift` works as\n```coconut\nlift(f)(g, h)(z) == f(g(z), h(z))\n```\nsuch that in this case `lift` implements the `S'` combinator (`liftA2` or `liftM2` in Haskell).\n\nIn the general case, `lift` is equivalent to a pickleable version of\n```coconut\ndef lift(f) = (\n    (*func_args, **func_kwargs) =>\n        (*args, **kwargs) =>\n            f(\n                *(g(*args, **kwargs) for g in func_args),\n                **{k: h(*args, **kwargs) for k, h in func_kwargs.items()}\n            )\n)\n```\n\n`lift` also supports a shortcut form such that `lift(f, *func_args, **func_kwargs)` is equivalent to `lift(f)(*func_args, **func_kwargs)`.\n\n##### **lift\\_apart**(_func_)\n\n##### **lift\\_apart**(_func_, *_func\\_args_, **_func\\_kwargs_)\n\nCoconut's `lift_apart` built-in is very similar to `lift`, except instead of duplicating the final arguments to each function, it separates them out.\n\nFor a binary function `f(x, y)` and two unary functions `g(z)` and `h(z)`, `lift_apart` works as\n```coconut\nlift_apart(f)(g, h)(z, w) == f(g(z), h(w))\n```\nsuch that in this case `lift_apart` implements the `D2` combinator.\n\nIn the general case, `lift_apart` is equivalent to a pickleable version of\n```coconut\ndef lift_apart(f) = (\n    (*func_args, **func_kwargs) =>\n        (*args, **kwargs) =>\n            f(\n                *(f(x) for f, x in zip(func_args, args, strict=True)),\n                **{k: func_kwargs[k](kwargs[k]) for k in func_kwargs.keys() | kwargs.keys()},\n            )\n)\n```\n\n`lift_apart` supports the same shortcut form as `lift`.\n\n##### Examples\n\n**Coconut:**\n```coconut\nxs_and_xsp1 = ident `lift(zip)` map$(=>_+1)\nmin_and_max = lift(,)(min, max)\nplus_and_times = (+) `lift(,)` (*)\n```\n\n**Python:**\n```coconut_python\ndef xs_and_xsp1(xs):\n    return zip(xs, map(lambda x: x + 1, xs))\ndef min_and_max(xs):\n    return min(xs), max(xs)\ndef plus_and_times(x, y):\n    return x + y, x * y\n```\n\n**Coconut:**\n```coconut\nfirst_false_and_last_true = (\n    lift(,)(ident, reversed)\n    ..*> lift_apart(,)(dropwhile$(bool), dropwhile$(not))\n    ..*> lift_apart(,)(.$[0], .$[0])\n)\n```\n\n**Python:**\n```coconut_python\nfrom itertools import dropwhile\n\ndef first_false_and_last_true(xs):\n    rev_xs = reversed(xs)\n    return (\n        next(dropwhile(bool, xs)),\n        next(dropwhile(lambda x: not x, rev_xs)),\n    )\n```\n\n#### `and_then` and `and_then_await`\n\n**and\\_then**(_first\\_async\\_func_, _second\\_func_)\n\n**and\\_then\\_await**(_first\\_async\\_func_, _second\\_async\\_func_)\n\nCoconut provides the `and_then` and `and_then_await` built-ins for composing `async` functions. Specifically:\n* To forwards compose an async function `async_f` with a normal function `g` (such that `g` is called on the result of `await`ing `async_f`), write ``async_f `and_then` g``.\n* To forwards compose an async function `async_f` with another async function `async_g` (such that `async_g` is called on the result of `await`ing `async_f`, and then `async_g` is itself awaited), write ``async_f `and_then_await` async_g``.\n* To forwards compose a normal function `f` with an async function `async_g` (such that `async_g` is called on the result of `f`), just write `f ..> async_g`.\n\nNote that all of the above will always result in the resulting composition being an `async` function.\n\nThe built-ins are effectively equivalent to:\n```coconut\ndef and_then[**T, U, V](\n    first_async_func: async (**T) -> U,\n    second_func: U -> V,\n) -> async (**T) -> V =\n    async def (*args, **kwargs) => (\n        first_async_func(*args, **kwargs)\n        |> await\n        |> second_func\n    )\n\ndef and_then_await[**T, U, V](\n    first_async_func: async (**T) -> U,\n    second_async_func: async U -> V,\n) -> async (**T) -> V =\n    async def (*args, **kwargs) => (\n        first_async_func(*args, **kwargs)\n        |> await\n        |> second_async_func\n        |> await\n    )\n```\n\nLike normal [function composition](#function-composition), `and_then` and `and_then_await` will preserve all metadata attached to the first function in the composition.\n\n##### Example\n\n**Coconut:**\n```coconut\nload_and_send_data = (\n    load_data_async()\n    `and_then` proc_data\n    `and_then_await` send_data\n)\n```\n\n**Python:**\n```coconut_python\nasync def load_and_send_data():\n    return await send_data(proc_data(await load_data_async()))\n```\n\n\n### Built-Ins for Working with Iterators\n\n```{contents}\n---\nlocal:\ndepth: 1\n---\n```\n\n#### Enhanced Built-Ins\n\nCoconut's `map`, `zip`, `filter`, `reversed`, and `enumerate` objects are enhanced versions of their Python equivalents that support:\n\n- The ability to be iterated over multiple times if the underlying iterators can be iterated over multiple times.\n  - _Note: This can lead to different behavior between Coconut built-ins and Python built-ins. Use `py_` versions if the Python behavior is necessary._\n- `reversed`\n- `repr`\n- Optimized normal (and iterator) indexing/slicing (`map`, `zip`, `reversed`, and `enumerate` but not `filter`).\n- `len` (all but `filter`) (though `bool` will still always yield `True`).\n- [PEP 618](https://www.python.org/dev/peps/pep-0618) `zip(..., strict=True)` support on all Python versions.\n- Added `strict=True` support to `map` as well (enforces that iterables are the same length in the multi-iterable case; uses `zip` under the hood such that errors will show up as `zip(..., strict=True)` errors).\n- Added attributes which subclasses can make use of to get at the original arguments to the object:\n  * `map`: `func`, `iters`\n  * `zip`: `iters`\n  * `filter`: `func`, `iter`\n  * `reversed`: `iter`\n  * `enumerate`: `iter`, `start`\n\n##### Indexing into other built-ins\n\nThough Coconut provides random access indexing/slicing to `range`, `map`, `zip`, `reversed`, and `enumerate`, Coconut cannot index into built-ins like `filter`, `takewhile`, or `dropwhile` directly, as there is no efficient way to do so.\n\n```coconut\nrange(10) |> filter$(i => i>3) |> .[0]  # doesn't work\n```\n\nIn order to make this work, you can explicitly use iterator slicing, which is less efficient in the general case:\n\n```coconut\nrange(10) |> filter$(i => i>3) |> .$[0]  # works\n```\n\nFor more information on Coconut's iterator slicing, see [here](#iterator-slicing).\n\n##### Examples\n\n**Coconut:**\n```coconut\nmap((+), range(5), range(6)) |> len |> print\nrange(10) |> filter$((x) => x < 5) |> reversed |> tuple |> print\n```\n\n**Python:**\n_Can't be done without defining a custom `map` type. The full definition of `map` can be found in the Coconut header._\n\n**Coconut:**\n```coconut\nrange(0, 12, 2)[4]  # 8\n\nmap((i => i*2), range(10))[2]  # 4\n```\n\n**Python:**\n_Can’t be done quickly without Coconut’s iterable indexing, which requires many complicated pieces. The necessary definitions in Python can be found in the Coconut header._\n\n#### `reduce`\n\n**reduce**(_function_, _iterable_[, _initial_])\n\nCoconut re-introduces Python 2's `reduce` built-in, using the `functools.reduce` version. Additionally, unlike `functools.reduce`, Coconut's `reduce` always supports keyword arguments.\n\n##### Python Docs\n\n**reduce**(_function, iterable_**[**_, initial_**]**)\n\nApply _function_ of two arguments cumulatively to the items of _sequence_, from left to right, so as to reduce the sequence to a single value. For example, `reduce((x, y) => x+y, [1, 2, 3, 4, 5])` calculates `((((1+2)+3)+4)+5)`. The left argument, _x_, is the accumulated value and the right argument, _y_, is the update value from the _sequence_. If the optional _initial_ is present, it is placed before the items of the sequence in the calculation, and serves as a default when the sequence is empty. If _initial_ is not given and _sequence_ contains only one item, the first item is returned.\n\n##### Example\n\n**Coconut:**\n```coconut\nproduct = reduce$(*)\nrange(1, 10) |> product |> print\n```\n\n**Python:**\n```coconut_python\nimport operator\nimport functools\nproduct = functools.partial(functools.reduce, operator.mul)\nprint(product(range(1, 10)))\n```\n\n#### `reiterable`\n\n**reiterable**(_iterable_)\n\n`reiterable` wraps the given iterable to ensure that every time the `reiterable` is iterated over, it produces the same results. Note that the result need not be a `reiterable` object if the given iterable is already reiterable. `reiterable` uses [`tee`](#tee) under the hood and `tee` can be used in its place, though `reiterable` is generally recommended over `tee`.\n\n##### Example\n\n**Coconut:**\n```coconut\ndef list_type(xs):\n    match reiterable(xs):\n        case [fst, snd] :: tail:\n            return \"at least 2\"\n        case [fst] :: tail:\n            return \"at least 1\"\n        case (| |):\n            return \"empty\"\n```\n\n**Python:**\n_Can't be done without a long series of checks for each `match` statement. See the compiled code for the Python syntax._\n\n#### `starmap`\n\n**starmap**(_function_, _iterable_)\n\nCoconut provides a modified version of `itertools.starmap` that supports `reversed`, `repr`, optimized normal (and iterator) slicing, `len`, and `func`/`iter` attributes.\n\n##### Python Docs\n\n**starmap**(_function, iterable_)\n\nMake an iterator that computes the function using arguments obtained from the iterable. Used instead of `map()` when argument parameters are already grouped in tuples from a single iterable (the data has been \"pre-zipped\"). The difference between `map()` and `starmap()` parallels the distinction between `function(a,b)` and `function(*c)`. Roughly equivalent to:\n\n```coconut_python\ndef starmap(function, iterable):\n    # starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000\n    for args in iterable:\n        yield function(*args)\n```\n\n##### Example\n\n**Coconut:**\n```coconut\nrange(1, 5) |> map$(range) |> starmap$(print) |> consume\n```\n\n**Python:**\n```coconut_python\nimport itertools, collections\ncollections.deque(itertools.starmap(print, map(range, range(1, 5))), maxlen=0)\n```\n\n#### `zip_longest`\n\n**zip\\_longest**(*_iterables_, _fillvalue_=`None`)\n\nCoconut provides an enhanced version of `itertools.zip_longest` as a built-in under the name `zip_longest`. `zip_longest` supports all the same features as Coconut's [enhanced zip](#enhanced-built-ins) as well as the additional attribute `fillvalue`.\n\n##### Python Docs\n\n**zip\\_longest**(_\\*iterables, fillvalue=None_)\n\nMake an iterator that aggregates elements from each of the iterables. If the iterables are of uneven length, missing values are filled-in with _fillvalue_. Iteration continues until the longest iterable is exhausted. Roughly equivalent to:\n\n```coconut_python\ndef zip_longest(*args, fillvalue=None):\n    # zip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-\n    iterators = [iter(it) for it in args]\n    num_active = len(iterators)\n    if not num_active:\n        return\n    while True:\n        values = []\n        for i, it in enumerate(iterators):\n            try:\n                value = next(it)\n            except StopIteration:\n                num_active -= 1\n                if not num_active:\n                    return\n                iterators[i] = repeat(fillvalue)\n                value = fillvalue\n            values.append(value)\n        yield tuple(values)\n```\n\nIf one of the iterables is potentially infinite, then the `zip_longest()` function should be wrapped with something that limits the number of calls (for example iterator slicing or `takewhile`). If not specified, _fillvalue_ defaults to `None`.\n\n##### Example\n\n**Coconut:**\n```coconut\nresult = zip_longest(range(5), range(10))\n```\n\n**Python:**\n```coconut_python\nimport itertools\nresult = itertools.zip_longest(range(5), range(10))\n```\n\n#### `takewhile`\n\n**takewhile**(_predicate_, _iterable_)\n\nCoconut provides `itertools.takewhile` as a built-in under the name `takewhile`. Additionally, unlike `itertools.takewhile`, Coconut's `takewhile` always supports keyword arguments.\n\n##### Python Docs\n\n**takewhile**(_predicate, iterable_)\n\nMake an iterator that returns elements from the _iterable_ as long as the _predicate_ is true. Equivalent to:\n```coconut_python\ndef takewhile(predicate, iterable):\n    # takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4\n    for x in iterable:\n        if predicate(x):\n            yield x\n        else:\n            break\n```\n\n##### Example\n\n**Coconut:**\n```coconut\nnegatives = numiter |> takewhile$(x => x < 0)\n```\n\n**Python:**\n```coconut_python\nimport itertools\nnegatives = itertools.takewhile(lambda x: x < 0, numiter)\n```\n\n#### `dropwhile`\n\n**dropwhile**(_predicate_, _iterable_)\n\nCoconut provides `itertools.dropwhile` as a built-in under the name `dropwhile`. Additionally, unlike `itertools.dropwhile`, Coconut's `dropwhile` always supports keyword arguments.\n\n##### Python Docs\n\n**dropwhile**(_predicate, iterable_)\n\nMake an iterator that drops elements from the _iterable_ as long as the _predicate_ is true; afterwards, returns every element. Note: the iterator does not produce any output until the predicate first becomes false, so it may have a lengthy start-up time. Equivalent to:\n```coconut_python\ndef dropwhile(predicate, iterable):\n    # dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1\n    iterable = iter(iterable)\n    for x in iterable:\n        if not predicate(x):\n            yield x\n            break\n    for x in iterable:\n        yield x\n```\n\n##### Example\n\n**Coconut:**\n```coconut\npositives = numiter |> dropwhile$(x => x < 0)\n```\n\n**Python:**\n```coconut_python\nimport itertools\npositives = itertools.dropwhile(lambda x: x < 0, numiter)\n```\n\n#### `flatten`\n\n**flatten**(_iterable_, _levels_=`1`)\n\nCoconut provides an enhanced version of `itertools.chain.from_iterable` as a built-in under the name `flatten` with added support for `reversed`, `repr`, `in`, `.count()`, `.index()`, and `fmap`.\n\nBy default, `flatten` only flattens the top level of the given iterable/array. If _levels_ is passed, however, it can be used to control the number of levels flattened, with `0` meaning no flattening and `None` flattening as many iterables as are found. Note that if _levels_ is set to any non-`None` value, the first _levels_ levels must be iterables, or else an error will be raised.\n\n##### Python Docs\n\nchain.**from_iterable**(_iterable_)\n\nAlternate constructor for `chain()`. Gets chained inputs from a single iterable argument that is evaluated lazily. Roughly equivalent to:\n\n```coconut_python\ndef flatten(iterables):\n    # flatten(['ABC', 'DEF']) --> A B C D E F\n    for it in iterables:\n        for element in it:\n            yield element\n```\n\n##### Example\n\n**Coconut:**\n```coconut\niter_of_iters = [[1, 2], [3, 4]]\nflat_it = iter_of_iters |> flatten |> list\n```\n\n**Python:**\n```coconut_python\nfrom itertools import chain\niter_of_iters = [[1, 2], [3, 4]]\nflat_it = list(chain.from_iterable(iter_of_iters))\n```\n\n#### `scan`\n\n**scan**(_function_, _iterable_[, _initial_])\n\nCoconut provides a modified version of `itertools.accumulate` with opposite argument order as `scan` that also supports `repr`, `len`, and `func`/`iter`/`initial` attributes. `scan` works exactly like [`reduce`](#reduce), except that instead of only returning the last accumulated value, it returns an iterator of all the intermediate values.\n\n##### Python Docs\n\n**scan**(_function, iterable_**[**_, initial_**]**)\n\nMake an iterator that returns accumulated results of some function of two arguments. Elements of the input iterable may be any type that can be accepted as arguments to _function_. (For example, with the operation of addition, elements may be any addable type including Decimal or Fraction.) If the input iterable is empty, the output iterable will also be empty.\n\nIf no _initial_ is given, roughly equivalent to:\n```coconut_python\ndef scan(function, iterable):\n    'Return running totals'\n    # scan(operator.add, [1,2,3,4,5]) --> 1 3 6 10 15\n    # scan(operator.mul, [1,2,3,4,5]) --> 1 2 6 24 120\n    it = iter(iterable)\n    try:\n        total = next(it)\n    except StopIteration:\n        return\n    yield total\n    for element in it:\n        total = function(total, element)\n        yield total\n```\n\n##### Example\n\n**Coconut:**\n```coconut\ninput_data = [3, 4, 6, 2, 1, 9, 0, 7, 5, 8]\nrunning_max = input_data |> scan$(max) |> list\n```\n\n**Python:**\n```coconut_python\ninput_data = [3, 4, 6, 2, 1, 9, 0, 7, 5, 8]\nrunning_max = []\nmax_so_far = input_data[0]\nfor x in input_data:\n    if x > max_so_far:\n        max_so_far = x\n    running_max.append(max_so_far)\n```\n\n#### `count`\n\n**count**(_start_=`0`, _step_=`1`)\n\nCoconut provides a modified version of `itertools.count` that supports `in`, normal slicing, optimized iterator slicing, the standard `count` and `index` sequence methods, `repr`, and `start`/`step` attributes as a built-in under the name `count`. If the _step_ parameter is set to `None`, `count` will behave like `itertools.repeat` instead.\n\nSince `count` supports slicing, `count()[...]` can be used as a version of `range` that can in some cases be more readable. In particular, it is easy to accidentally write `range(10, 2)` when you meant `range(0, 10, 2)`, but it is hard to accidentally write `count()[10:2]` when you mean `count()[:10:2]`.\n\n##### Python Docs\n\n**count**(_start=0, step=1_)\n\nMake an iterator that returns evenly spaced values starting with number _start_. Often used as an argument to `map()` to generate consecutive data points. Also, used with `zip()` to add sequence numbers. Roughly equivalent to:\n```coconut_python\ndef count(start=0, step=1):\n    # count(10) --> 10 11 12 13 14 ...\n    # count(2.5, 0.5) -> 2.5 3.0 3.5 ...\n    n = start\n    while True:\n        yield n\n        if step:\n          n += step\n```\n\n##### Example\n\n**Coconut:**\n```coconut\ncount()$[10**100] |> print\n```\n\n**Python:**\n_Can't be done quickly without Coconut's iterator slicing, which requires many complicated pieces. The necessary definitions in Python can be found in the Coconut header._\n\n#### `cycle`\n\n**cycle**(_iterable_, _times_=`None`)\n\nCoconut's `cycle` is a modified version of `itertools.cycle` with a `times` parameter that controls the number of times to cycle through _iterable_ before stopping. `cycle` also supports `in`, slicing, `len`, `reversed`, `.count()`, `.index()`, and `repr`.\n\n##### Python Docs\n\n**cycle**(_iterable_)\n\nMake an iterator returning elements from the iterable and saving a copy of each. When the iterable is exhausted, return elements from the saved copy. Repeats indefinitely. Roughly equivalent to:\n\n```coconut_python\ndef cycle(iterable):\n    # cycle('ABCD') --> A B C D A B C D A B C D ...\n    saved = []\n    for element in iterable:\n        yield element\n        saved.append(element)\n    while saved:\n        for element in saved:\n              yield element\n```\n\nNote, this member of the toolkit may require significant auxiliary storage (depending on the length of the iterable).\n\n##### Example\n\n**Coconut:**\n```coconut\ncycle(range(2), 2) |> list |> print\n```\n\n**Python:**\n```coconut_python\nfrom itertools import cycle, islice\nprint(list(islice(cycle(range(2)), 4)))\n```\n\n#### `cartesian_product`\n\n**cartesian\\_product**(*_iterables_, _repeat_=`1`)\n\nCoconut provides an enhanced version of `itertools.product` as a built-in under the name `cartesian_product` with added support for `len`, `repr`, `in`, `.count()`, and `fmap`.\n\nAdditionally, `cartesian_product` includes special support for [`numpy`](#numpy-integration) objects, in which case a multidimensional array is returned instead of an iterator.\n\n##### Python Docs\n\n**cartesian\\_product**(_\\*iterables, repeat=1_)\n\nCartesian product of input iterables.\n\nRoughly equivalent to nested for-loops in a generator expression. For example, `cartesian_product(A, B)` returns the same as `((x,y) for x in A for y in B)`.\n\nThe nested loops cycle like an odometer with the rightmost element advancing on every iteration. This pattern creates a lexicographic ordering so that if the input’s iterables are sorted, the product tuples are emitted in sorted order.\n\nTo compute the product of an iterable with itself, specify the number of repetitions with the optional repeat keyword argument. For example, `product(A, repeat=4)` means the same as `cartesian_product(A, A, A, A)`.\n\nThis function is roughly equivalent to the following code, except that the actual implementation does not build up intermediate results in memory:\n\n```coconut_python\ndef cartesian_product(*args, repeat=1):\n    # product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy\n    # product(range(2), repeat=3) --> 000 001 010 011 100 101 110 111\n    pools = [tuple(pool) for pool in args] * repeat\n    result = [[]]\n    for pool in pools:\n        result = [x+[y] for x in result for y in pool]\n    for prod in result:\n        yield tuple(prod)\n```\n\nBefore `cartesian_product()` runs, it completely consumes the input iterables, keeping pools of values in memory to generate the products. Accordingly, it is only useful with finite inputs.\n\n##### Example\n\n**Coconut:**\n```coconut\nv = [1, 2]\nassert cartesian_product(v, v) |> list == [(1, 1), (1, 2), (2, 1), (2, 2)]\n```\n\n**Python:**\n```coconut_python\nfrom itertools import product\nv = [1, 2]\nassert list(product(v, v)) == [(1, 1), (1, 2), (2, 1), (2, 2)]\n```\n\n#### `multi_enumerate`\n\n**multi\\_enumerate**(_iterable_)\n\nCoconut's `multi_enumerate` enumerates through an iterable of iterables. `multi_enumerate` works like enumerate, but indexes through inner iterables and produces a tuple index representing the index in each inner iterable. Supports indexing.\n\nFor [`numpy`](#numpy-integration) objects, uses [`np.nditer`](https://numpy.org/doc/stable/reference/generated/numpy.nditer.html) under the hood. Also supports `len` for [`numpy`](#numpy-integration) arrays.\n\n##### Example\n\n**Coconut:**\n```coconut_pycon\n>>> [1, 2;; 3, 4] |> multi_enumerate |> list\n[((0, 0), 1), ((0, 1), 2), ((1, 0), 3), ((1, 1), 4)]\n```\n\n**Python:**\n```coconut_python\narray = [[1, 2], [3, 4]]\nenumerated_array = []\nfor i in range(len(array)):\n    for j in range(len(array[i])):\n        enumerated_array.append(((i, j), array[i][j]))\n```\n\n#### `groupsof`\n\n**groupsof**(_n_, _iterable_, _fillvalue_=`...`)\n\nCoconut provides the `groupsof` built-in to split an iterable into groups of a specific length. Specifically, `groupsof(n, iterable)` will split `iterable` into tuples of length `n`, with only the last tuple potentially of size `< n` if the length of `iterable` is not divisible by `n`. If that is not the desired behavior, _fillvalue_ can be passed and will be used to pad the end of the last tuple to length `n`.\n\nAdditionally, `groupsof` supports `len` when `iterable` supports `len`.\n\n##### Example\n\n**Coconut:**\n```coconut\npairs = range(1, 11) |> groupsof$(2)\n```\n\n**Python:**\n```coconut_python\npairs = []\ngroup = []\nfor item in range(1, 11):\n    group.append(item)\n    if len(group) == 2:\n        pairs.append(tuple(group))\n        group = []\nif group:\n    pairs.append(tuple(group))\n```\n\n#### `windowsof`\n\n**windowsof**(_size_, _iterable_, _fillvalue_=`...`, _step_=`1`)\n\n`windowsof` produces an iterable that effectively mimics a sliding window over _iterable_ of size _size_. _step_ determines the spacing between windows.\n\nIf _size_ is larger than _iterable_, `windowsof` will produce an empty iterable. If that is not the desired behavior, _fillvalue_ can be passed and will be used in place of missing values. Also, if _fillvalue_ is passed and the length of the _iterable_ is not divisible by _step_, _fillvalue_ will be used in that case to pad the last window as well. Note that _fillvalue_ will only ever appear in the last window.\n\nAdditionally, `windowsof` supports `len` when `iterable` supports `len`.\n\n##### Example\n\n**Coconut:**\n```coconut\nassert \"12345\" |> windowsof$(3) |> list == [(\"1\", \"2\", \"3\"), (\"2\", \"3\", \"4\"), (\"3\", \"4\", \"5\")]\n```\n\n**Python:**\n_Can't be done without the definition of `windowsof`; see the compiled header for the full definition._\n\n#### `all_equal`\n\n**all\\_equal**(_iterable_, _to_=`...`)\n\nCoconut's `all_equal` built-in takes in an iterable and determines whether all of its elements are equal to each other.\n\nIf _to_ is passed, `all_equal` will check that all the elements are specifically equal to that value, rather than just equal to each other.\n\nNote that `all_equal` assumes transitivity of equality, that `!=` is the negation of `==`, and that empty arrays always have all their elements equal.\n\nSpecial support is provided for [`numpy`](#numpy-integration) objects.\n\n##### Example\n\n**Coconut:**\n```coconut\nall_equal([1, 1, 1])\nall_equal([1, 1, 2])\n```\n\n**Python:**\n```coconut_python\nsentinel = object()\ndef all_equal(iterable):\n    first_item = sentinel\n    for item in iterable:\n        if first_item is sentinel:\n            first_item = item\n        elif first_item != item:\n            return False\n    return True\nall_equal([1, 1, 1])\nall_equal([1, 1, 2])\n```\n\n#### `tee`\n\n**tee**(_iterable_, _n_=`2`)\n\nCoconut provides an optimized version of `itertools.tee` as a built-in under the name `tee`.\n\nThough `tee` is not deprecated, [`reiterable`](#reiterable) is generally recommended over `tee`.\n\nCustom `tee`/`reiterable` implementations for custom [Containers/Collections](https://docs.python.org/3/library/collections.abc.html) should be put in the `__copy__` method. Note that all [Sequences/Mappings/Sets](https://docs.python.org/3/library/collections.abc.html) are always assumed to be reiterable even without calling `__copy__`.\n\n##### Python Docs\n\n**tee**(_iterable, n=2_)\n\nReturn _n_ independent iterators from a single iterable. Equivalent to:\n```coconut_python\ndef tee(iterable, n=2):\n    it = iter(iterable)\n    deques = [collections.deque() for i in range(n)]\n    def gen(mydeque):\n        while True:\n            if not mydeque:             # when the local deque is empty\n                newval = next(it)       # fetch a new value and\n                for d in deques:        # load it to all the deques\n                    d.append(newval)\n            yield mydeque.popleft()\n    return tuple(gen(d) for d in deques)\n```\nOnce `tee()` has made a split, the original _iterable_ should not be used anywhere else; otherwise, the _iterable_ could get advanced without the tee objects being informed.\n\nThis itertool may require significant auxiliary storage (depending on how much temporary data needs to be stored). In general, if one iterator uses most or all of the data before another iterator starts, it is faster to use `list()` instead of `tee()`.\n\n##### Example\n\n**Coconut:**\n```coconut\noriginal, temp = tee(original)\nsliced = temp$[5:]\n```\n\n**Python:**\n```coconut_python\nimport itertools\noriginal, temp = itertools.tee(original)\nsliced = itertools.islice(temp, 5, None)\n```\n\n#### `consume`\n\n**consume**(_iterable_, _keep\\_last_=`0`)\n\nCoconut provides the `consume` function to efficiently exhaust an iterator and thus perform any lazy evaluation contained within it. `consume` takes one optional argument, `keep_last`, that defaults to 0 and specifies how many, if any, items from the end to return as a sequence (`None` will keep all elements).\n\nEquivalent to:\n```coconut\ndef consume(iterable, keep_last=0):\n    \"\"\"Fully exhaust iterable and return the last keep_last elements.\"\"\"\n    return collections.deque(iterable, maxlen=keep_last)  # fastest way to exhaust an iterator\n```\n\n##### Rationale\n\nIn the process of lazily applying operations to iterators, eventually a point is reached where evaluation of the iterator is necessary. To do this efficiently, Coconut provides the `consume` function, which will fully exhaust the iterator given to it.\n\n##### Example\n\n**Coconut:**\n```coconut\nrange(10) |> map$((x) => x**2) |> map$(print) |> consume\n```\n\n**Python:**\n```coconut_python\ncollections.deque(map(print, map(lambda x: x**2, range(10))), maxlen=0)\n```\n\n\n### Built-Ins for Parallelization\n\n#### `process_map` and `thread_map`\n\n##### **process\\_map**(_function_, *_iterables_, *, _chunksize_=`1`, _strict_=`False`, _stream_=`False`, _ordered_=`True`)\n\nCoconut provides a `multiprocessing`-based version of `map` under the name `process_map`. `process_map` makes use of multiple processes, and is therefore much faster than `map` for CPU-bound tasks. If any exceptions are raised inside of `process_map`, a traceback will be printed as soon as they are encountered. Results will be in the same order as the input unless _ordered_=`False`.\n\n`process_map` never loads the entire input iterator into memory, though by default it does consume the entire input iterator as soon as a single output is requested. Results can be streamed one at a time when iterating by passing _stream_=`True`, however note that _stream_=`True` requires that the resulting iterator only be iterated over inside of a `process_map.multiple_sequential_calls` block (see below).\n\nBecause `process_map` uses multiple processes for its execution, it is necessary that all of its arguments be pickleable. Only objects defined at the module level, and not lambdas, objects defined inside of a function, or objects defined inside of the interpreter, are pickleable. Furthermore, on Windows, it is necessary that all calls to `process_map` occur inside of an `if __name__ == \"__main__\"` guard.\n\n`process_map` supports a `chunksize` argument, which determines how many items are passed to each process at a time. Larger values of _chunksize_ are recommended when dealing with very long iterables. Additionally, in the multi-iterable case, _strict_ can be set to `True` to ensure that all iterables are the same length.\n\n_Deprecated: `parallel_map` is available as a deprecated alias for `process_map`. Note that deprecated features are disabled in `--strict` mode._\n\n##### **process\\_map\\.multiple\\_sequential\\_calls**(_max\\_workers_=`None`)\n\nIf multiple sequential calls to `process_map` need to be made, it is highly recommended that they be done inside of a `with process_map.multiple_sequential_calls():` block, which will cause the different calls to use the same process pool and result in `process_map` immediately returning a list rather than a `process_map` object. If multiple sequential calls are necessary and the laziness of process_map is required, then the `process_map` objects should be constructed before the `multiple_sequential_calls` block and then only iterated over once inside the block.\n\n`process_map.multiple_sequential_calls` also supports a  _max\\_workers_ argument to set the number of processes. If `max_workers=None`, Coconut will pick a suitable _max\\_workers_, including reusing worker pools from higher up in the call stack.\n\n##### **thread\\_map**(_function_, *_iterables_, *, _chunksize_=`1`, _strict_=`False`, _stream_=`False`, _ordered_=`True`)\n\n##### **thread\\_map\\.multiple\\_sequential\\_calls**(_max\\_workers_=`None`)\n\nCoconut provides a `multithreading`-based version of [`process_map`](#process_map) under the name `thread_map`. `thread_map` and `thread_map.multiple_sequential_calls` behave identically to `process_map` except that they use multithreading instead of multiprocessing, and are therefore primarily useful only for IO-bound tasks due to CPython's Global Interpreter Lock.\n\n_Deprecated: `concurrent_map` is available as a deprecated alias for `thread_map`. Note that deprecated features are disabled in `--strict` mode._\n\n##### Python Docs\n\n**process_map**(_func, \\*iterables_, _chunksize_=`1`)\n\nEquivalent to `map(func, *iterables)` except _func_ is executed asynchronously and several calls to _func_ may be made concurrently. If a call raises an exception, then that exception will be raised when its value is retrieved from the iterator.\n\n`process_map` chops the iterable into a number of chunks which it submits to the process pool as separate tasks. The (approximate) size of these chunks can be specified by setting _chunksize_ to a positive integer. For very long iterables using a large value for _chunksize_ can make the job complete **much** faster than using the default value of `1`.\n\n**thread_map**(_func, \\*iterables_, _chunksize_=`1`)\n\nEquivalent to `map(func, *iterables)` except _func_ is executed asynchronously and several calls to _func_ may be made concurrently. If a call raises an exception, then that exception will be raised when its value is retrieved from the iterator.\n\n`thread_map` chops the iterable into a number of chunks which it submits to the thread pool as separate tasks. The (approximate) size of these chunks can be specified by setting _chunksize_ to a positive integer. For very long iterables using a large value for _chunksize_ can make the job complete **much** faster than using the default value of `1`.\n\n##### Examples\n\n**Coconut:**\n```coconut\nprocess_map(pow$(2), range(100)) |> list |> print\n```\n\n**Python:**\n```coconut_python\nimport functools\nfrom multiprocessing import Pool\nwith Pool() as pool:\n    print(list(pool.imap(functools.partial(pow, 2), range(100))))\n```\n\n**Coconut:**\n```coconut\nthread_map(get_data_for_user, get_all_users()) |> list |> print\n```\n\n**Python:**\n```coconut_python\nimport functools\nimport concurrent.futures\nwith concurrent.futures.ThreadPoolExecutor() as executor:\n    print(list(executor.map(get_data_for_user, get_all_users())))\n```\n\n#### `collectby` and `mapreduce`\n\n##### **collectby**(_key\\_func_, _iterable_, _value\\_func_=`None`, \\*, _reduce\\_func_=`None`, _collect\\_in_=`None`, _reduce\\_func\\_init_=`...`, _map\\_using_=`None`)\n\n`collectby(key_func, iterable)` collects the items in `iterable` into a dictionary of lists keyed by `key_func(item)`.\n\nIf _value\\_func_ is passed, instead collects `value_func(item)` into each list instead of `item`.\n\nIf _reduce\\_func_ is passed, instead of collecting the items into lists, [`reduce`](#reduce) over the items of each key with _reduce\\_func_, effectively implementing a MapReduce operation. If keys are intended to be unique, set `reduce_func=False` (`reduce_func=False` is also the default if _collect\\_in_ is passed). If _reduce\\_func_ is passed, then _reduce\\_func\\_init_ may also be passed, and will determine the initial value when reducing with _reduce\\_func_.\n\nIf _collect\\_in_ is passed, initializes the collection from _collect\\_in_ rather than as a `collections.defaultdict` (if `reduce_func=None`) or an empty `dict` (otherwise). Additionally, _reduce\\_func_ defaults to `False` rather than `None` when _collect\\_in_ is passed. Useful when you want to collect the results into a `pandas.DataFrame`.\n\nIf _map_using_ is passed, calculates `key_func` and `value_func` by mapping them over the iterable using `map_using` as `map`. Useful with [`process_map`](#process_map)/[`thread_map`](#thread_map). See `.using_threads` and `.using_processes` methods below for simple shortcut methods that make use of `map_using` internally.\n\n`collectby` is similar to [`itertools.groupby`](https://docs.python.org/3/library/itertools.html#itertools.groupby) except that `collectby` aggregates common elements regardless of their order in the input iterable, whereas `groupby` only aggregates common elements that are adjacent in the input iterable.\n\n##### **mapreduce**(_key\\_value\\_func_, _iterable_, \\*, _reduce\\_func_=`None`, _collect\\_in_=`None`, _reduce\\_func\\_init_=`...`, _map\\_using_=`None`)\n\n`mapreduce(key_value_func, iterable)` functions the same as `collectby`, but allows calculating the keys and values together in one function. _key\\_value\\_func_ must return a 2-tuple of `(key, value)`.\n\n##### **collectby.using_threads**(_key\\_func_, _iterable_, _value\\_func_=`None`, \\*, _reduce\\_func_=`None`, _collect\\_in_=`None`, _reduce\\_func\\_init_=`...`, _ordered_=`False`, _chunksize_=`1`, _max\\_workers_=`None`)\n\n##### **collectby.using_processes**(_key\\_func_, _iterable_, _value\\_func_=`None`, \\*, _reduce\\_func_=`None`, _collect\\_in_=`None`, _reduce\\_func\\_init_=`...`, _ordered_=`False`, _chunksize_=`1`, _max\\_workers_=`None`)\n\n##### **mapreduce.using_threads**(_key\\_value\\_func_, _iterable_, \\*, _reduce\\_func_=`None`, _collect\\_in_=`None`, _reduce\\_func\\_init_=`...`, _ordered_=`False`, _chunksize_=`1`, _max\\_workers_=`None`)\n\n##### **mapreduce.using_processes**(_key\\_value\\_func_, _iterable_, \\*, _reduce\\_func_=`None`, _collect\\_in_=`None`, _reduce\\_func\\_init_=`...`, _ordered_=`False`, _chunksize_=`1`, _max\\_workers_=`None`)\n\nThese shortcut methods call `collectby`/`mapreduce` with `map_using` set to [`process_map`](#process_map)/[`thread_map`](#thread_map), properly managed using the `.multiple_sequential_calls` method and the `stream=True` argument of [`process_map`](#process_map)/[`thread_map`](#thread_map). `reduce_func` will be called as soon as results arrive, and by default in whatever order they arrive in (to enforce the original order, pass _ordered_=`True`).\n\nTo make multiple sequential calls to `collectby.using_threads()`/`mapreduce.using_threads()`, manage them using `thread_map.multiple_sequential_calls()`. Similarly, use `process_map.multiple_sequential_calls()` to manage `.using_processes()`.\n\nNote that, for very long iterables, it is highly recommended to pass a value other than the default `1` for _chunksize_.\n\nAs an example, `mapreduce.using_processes` is effectively equivalent to:\n```coconut\ndef mapreduce.using_processes(key_value_func, iterable, *, reduce_func=None, ordered=False, chunksize=1, max_workers=None):\n    with process_map.multiple_sequential_calls(max_workers=max_workers):\n        return mapreduce(\n            key_value_func,\n            iterable,\n            reduce_func=reduce_func,\n            map_using=process_map$(\n                stream=True,\n                ordered=ordered,\n                chunksize=chunksize,\n            ),\n        )\n```\n\n##### Example\n\n**Coconut:**\n```coconut\nuser_balances = (\n    balance_data\n    |> collectby$(.user, value_func=.balance, reduce_func=(+))\n)\n```\n\n**Python:**\n```coconut_python\nfrom collections import defaultdict\n\nuser_balances = defaultdict(int)\nfor item in balance_data:\n    user_balances[item.user] += item.balance\n```\n\n#### `async_map`\n\n**async\\_map**(_async\\_func_, *_iters_, _strict_=`False`)\n\n`async_map` maps _async\\_func_ over _iters_ asynchronously using [`anyio`](https://anyio.readthedocs.io/en/stable/), which must be installed for _async\\_func_ to work. _strict_ functions as in [`map`/`zip`](#enhanced-built-ins), enforcing that all the _iters_ must have the same length.\n\nEquivalent to:\n```coconut\nasync def async_map[T, U](\n    async_func: async T -> U,\n    *iters: T$[],\n    strict: bool = False\n) -> U[]:\n    \"\"\"Map async_func over iters asynchronously using anyio.\"\"\"\n    import anyio\n    results = []\n    async def store_func_in_of(i, args):\n        got = await async_func(*args)\n        results.extend([None] * (1 + i - len(results)))\n        results[i] = got\n    async with anyio.create_task_group() as nursery:\n        for i, args in enumerate(zip(*iters, strict=strict)):\n            nursery.start_soon(store_func_in_of, i, args)\n    return results\n```\n\n##### Example\n\n**Coconut:**\n```coconut\nasync def load_pages(urls) = (\n    urls\n    |> async_map$(load_page)\n    |> await\n)\n```\n\n**Python:**\n```coconut_python\nimport anyio\n\nasync def load_pages(urls):\n    results = [None] * len(urls)\n    async def proc_url(i, url):\n        results[i] = await load_page(url)\n    async with anyio.create_task_group() as nursery:\n        for i, url in enumerate(urls)\n          nursery.start_soon(proc_url, i, url)\n    return results\n```\n\n\n### Typing-Specific Built-Ins\n\n```{contents}\n---\nlocal:\ndepth: 1\n---\n```\n\n#### `TYPE_CHECKING`\n\nThe `TYPE_CHECKING` variable is set to `False` at runtime and `True` during type_checking, allowing you to prevent your `typing` imports and `TypeVar` definitions from being executed at runtime. By wrapping your `typing` imports in an `if TYPE_CHECKING:` block, you can even use the [`typing`](https://docs.python.org/3/library/typing.html) module on Python versions that don't natively support it. Furthermore, `TYPE_CHECKING` can also be used to hide code that is mistyped by default.\n\n##### Python Docs\n\nA special constant that is assumed to be `True` by 3rd party static type checkers. It is `False` at runtime. Usage:\n```coconut_python\nif TYPE_CHECKING:\n    import expensive_mod\n\ndef fun(arg: expensive_mod.SomeType) -> None:\n    local_var: expensive_mod.AnotherType = other_fun()\n```\n\n##### Examples\n\n**Coconut:**\n```coconut\nif TYPE_CHECKING:\n    from typing import List\nx: List[str] = [\"a\", \"b\"]\n```\n\n```coconut\nif TYPE_CHECKING:\n    def factorial(n: int) -> int: ...\nelse:\n    def factorial(0) = 1\n    addpattern def factorial(n) = n * factorial(n-1)\n```\n\n**Python:**\n```coconut_python\ntry:\n    from typing import TYPE_CHECKING\nexcept ImportError:\n    TYPE_CHECKING = False\n\nif TYPE_CHECKING:\n    from typing import List\nx: List[str] = [\"a\", \"b\"]\n```\n\n```coconut_python\ntry:\n    from typing import TYPE_CHECKING\nexcept ImportError:\n    TYPE_CHECKING = False\n\nif TYPE_CHECKING:\n    def factorial(n: int) -> int: ...\nelse:\n    def factorial(n):\n        if n == 0:\n            return 1\n        else:\n            return n * factorial(n-1)\n```\n\n#### `reveal_type` and `reveal_locals`\n\nWhen using static type analysis tools integrated with Coconut such as [MyPy](#mypy-integration), `reveal_type(<expr>)` will cause MyPy to print the type of `<expr>` and `reveal_locals()` will cause MyPy to print the types of the current `locals()`. At runtime, `reveal_type(x)` is always the identity function and `reveal_locals()` always returns `None`. See [the MyPy documentation](https://mypy.readthedocs.io/en/stable/common_issues.html#reveal-type) for more information.\n\n##### Example\n\n**Coconut:**\n```coconut_pycon\n> coconut --mypy\nCoconut Interpreter vX.X.X:\n(enter 'exit()' or press Ctrl-D to end)\n>>> reveal_type(fmap)\n<function fmap at 0x00000239B06E2040>\n<string>:17: note: Revealed type is 'def [_T, _U] (func: def (_T`-1) -> _U`-2, obj: typing.Iterable[_T`-1]) -> typing.Iterable[_U`-2]'\n>>>\n```\n\n**Python**\n```coconut_python\ntry:\n    from typing import TYPE_CHECKING\nexcept ImportError:\n    TYPE_CHECKING = False\n\nif not TYPE_CHECKING:\n    def reveal_type(x):\n        return x\n\nfrom coconut.__coconut__ import fmap\nreveal_type(fmap)\n```\n\n\n## Coconut API\n\n```{contents}\n---\nlocal:\ndepth: 2\n---\n```\n\n\n### `coconut.embed`\n\n**coconut.embed**(_kernel_=`None`, _depth_=`0`, \\*\\*_kwargs_)\n\nIf _kernel_=`False` (default), embeds a Coconut Jupyter console initialized from the current local namespace. If _kernel_=`True`, launches a Coconut Jupyter kernel initialized from the local namespace that can then be attached to. The _depth_ indicates how many additional call frames to ignore. _kwargs_ are as in [IPython.embed](https://ipython.readthedocs.io/en/stable/api/generated/IPython.terminal.embed.html#IPython.terminal.embed.embed) or [IPython.embed_kernel](https://ipython.readthedocs.io/en/stable/api/generated/IPython.html#IPython.embed_kernel) based on _kernel_.\n\nRecommended usage is as a debugging tool, where the code `from coconut import embed; embed()` can be inserted to launch an interactive Coconut shell initialized from that point.\n\n\n### Automatic Compilation\n\nAutomatic compilation lets you simply import Coconut files directly without having to go through a compilation step first. Automatic compilation can be enabled either by importing [`coconut.api`](#coconut-api) before you import anything else, or by running `coconut --site-install`.\n\nOnce automatic compilation is enabled, Coconut will check each of your imports to see if you are attempting to import a `.coco` file and, if so, automatically compile it for you. Note that, for Coconut to know what file you are trying to import, it will need to be accessible via `sys.path`, just like a normal import.\n\nAutomatic compilation always compiles with `--target sys --line-numbers --keep-lines` by default. On Python 3.4+, automatic compilation will use a `__coconut_cache__` directory to cache the compiled Python. Note that `__coconut_cache__` will always be removed from `__file__`.\n\nAutomatic compilation is always available in the Coconut interpreter or when using [`coconut-run`](#coconut-scripts). When using auto compilation through the Coconut interpreter, any compilation options passed in will also be used for auto compilation. Additionally, the interpreter always allows importing from the current working directory, letting you easily compile and play around with a `.coco` file simply by running the Coconut interpreter and importing it.\n\nIf using the Coconut interpreter, a `reload` built-in is always provided to easily reload (and thus recompile) imported modules.\n\n\n### Coconut Encoding\n\nWhile automatic compilation is the preferred method for dynamically compiling Coconut files, as it caches the compiled code as a `.py` file to prevent recompilation, Coconut also supports a special\n```coconut\n# coding: coconut\n```\ndeclaration which can be added to `.py` files to have them treated as Coconut files instead. To use such a coding declaration, you'll need to either run `coconut --site-install` or `import coconut.api` at some point before you first attempt to import a file with a `# coding: coconut` declaration. Like automatic compilation, the Coconut encoding is always available from the Coconut interpreter. Compilation always uses the same parameters as in the [Coconut Jupyter kernel](#kernel).\n\n\n### `coconut.api`\n\nIn addition to enabling automatic compilation, `coconut.api` can also be used to call the Coconut compiler from code instead of from the command line. See below for specifications of the different api functions.\n\n_Deprecated: `coconut.convenience` is a deprecated alias for `coconut.api`._\n\n#### `get_state`\n\n**coconut.api.get\\_state**(_state_=`None`)\n\nGets a state object which stores the current compilation parameters. State objects can be configured with [**setup**](#setup) or [**cmd**](#cmd) and then used in [**parse**](#parse) or other endpoints.\n\nIf _state_ is `None`, gets a new state object, whereas if _state_ is `False`, the global state object is returned.\n\n#### `parse`\n\n**coconut.api.parse**(_code_=`\"\"`, _mode_=`\"sys\"`, _state_=`False`, _keep\\_internal\\_state_=`None`)\n\nLikely the most useful of the api functions, `parse` takes Coconut code as input and outputs the equivalent compiled Python code. _mode_ is used to indicate the context for the parsing and _state_ is the state object storing the compilation parameters to use as obtained from [**get_state**](#get_state) (if `False`, uses the global state object). _keep\\_internal\\_state_ determines whether the state object will keep internal state (such as what [custom operators](#custom-operators) have been declared)—if `None`, internal state will be kept iff you are not using the global _state_.\n\nIf _code_ is not passed, `parse` will output just the given _mode_'s header, which can be executed to set up an execution environment in which future code can be parsed and executed without a header.\n\nEach _mode_ has two components: what parser it uses, and what header it prepends. The parser determines what Coconut code is allowed as input, and the header determines how the compiled Python can be used. Possible values of _mode_ are:\n\n- `\"sys\"`: (the default)\n    + parser: file\n        * The file parser can parse any Coconut code.\n    + header: sys\n        * This header imports [`coconut.__coconut__`](#coconut-coconut) to access the necessary Coconut objects.\n- `\"exec\"`:\n    + parser: file\n    + header: exec\n        * When passed to `exec` at the global level, this header will create all the necessary Coconut objects itself instead of importing them.\n- `\"file\"`:\n    + parser: file\n    + header: file\n        * This header is meant to be written to a `--standalone` file and should not be passed to `exec`.\n- `\"package\"`:\n    + parser: file\n    + header: package\n        * This header is meant to be written to a `--package` file and should not be passed to `exec`.\n- `\"block\"`:\n    + parser: file\n    + header: none\n        * No header is included, thus this can only be passed to `exec` if code with a header has already been executed at the global level.\n- `\"single\"`:\n    + parser: single\n        * Can only parse one line of Coconut code.\n    + header: none\n- `\"eval\"`:\n    + parser: eval\n        * Can only parse a Coconut expression, not a statement.\n    + header: none\n- `\"lenient\"`:\n    + parser: lenient\n        * Can parse any Coconut code, allows leading whitespace, and has no trailing newline.\n    + header: none\n- `\"xonsh\"`:\n    + parser: xonsh\n        * Parses Coconut [`xonsh`](https://xon.sh) code for use in [Coconut's `xonsh` support](#xonsh-support).\n    + header: none\n\n##### Example\n\n```coconut_python\nfrom coconut.api import parse\nexec(parse())\nwhile True:\n    exec(parse(input(), mode=\"block\"))\n```\n\n#### `setup`\n\n**coconut.api.setup**(_target_=`None`, _strict_=`False`, _minify_=`False`, _line\\_numbers_=`True`, _keep\\_lines_=`False`, _no\\_tco_=`False`, _no\\_wrap_=`False`, *, _state_=`False`)\n\n`setup` can be used to set up the given state object with the given compilation parameters, each corresponding to the command-line flag of the same name. _target_ should be either `None` for the default target or a string of any [allowable target](#allowable-targets).\n\nIf _state_ is `False`, the global state object is used.\n\n#### `warm_up`\n\n**coconut.api.warm_up**(_streamline_=`True`, _enable\\_incremental\\_mode_=`False`, *, _state_=`False`)\n\nCan optionally be called to warm up the compiler and get it ready for parsing. Passing _streamline_ will cause the warm up to take longer but will substantially reduce parsing times (by default, this level of warm up is only done when the compiler encounters a large file). Passing _enable\\_incremental\\_mode_ will enable the compiler's incremental mdoe, where parsing some string, then later parsing a continuation of that string, will yield substantial performance improvements.\n\n#### `cmd`\n\n**coconut.api.cmd**(_args_=`None`, *, _argv_=`None`, _interact_=`False`, _default\\_target_=`None`, _default\\_jobs_=`None`, _state_=`False`)\n\nExecutes the given _args_ as if they were fed to `coconut` on the command-line, with the exception that unless _interact_ is true or `-i` is passed, the interpreter will not be started. Additionally, _argv_ can be used to pass in arguments as in `--argv` and _default\\_target_ can be used to set the default `--target`.\n\nHas the same effect of setting the command-line flags on the given _state_ object as `setup` (with the global `state` object used when _state_ is `False`).\n\n#### `cmd_sys`\n\n**coconut.api.cmd_sys**(_args_=`None`, *, _argv_=`None`, _interact_=`False`, _default\\_target_=`\"sys\"`, _default\\_jobs_=`\"0\"`, _state_=`False`)\n\nSame as `coconut.api.cmd` but _default\\_target_ is `\"sys\"` rather than `None` (universal) and _default\\_jobs_=`\"0\"` rather than `None` (`\"sys\"`). Since `cmd_sys` defaults to not using `multiprocessing`, it is preferred whenever that might be a problem, e.g. [if you're not inside an `if __name__ == \"__main__\"` block on Windows](https://stackoverflow.com/questions/20360686/compulsory-usage-of-if-name-main-in-windows-while-using-multiprocessi).\n\n#### `coconut_exec`\n\n**coconut.api.coconut_exec**(_expression_, _globals_=`None`, _locals_=`None`, _state_=`False`, _keep\\_internal\\_state_=`None`)\n\nVersion of [`exec`](https://docs.python.org/3/library/functions.html#exec) which can execute Coconut code.\n\n#### `coconut_eval`\n\n**coconut.api.coconut_eval**(_expression_, _globals_=`None`, _locals_=`None`, _state_=`False`, _keep\\_internal\\_state_=`None`)\n\nVersion of [`eval`](https://docs.python.org/3/library/functions.html#eval) which can evaluate Coconut code.\n\n#### `auto_compilation`\n\n**coconut.api.auto_compilation**(_on_=`True`, _args_=`None`, _use\\_cache\\_dir_=`None`)\n\nTurns [automatic compilation](#automatic-compilation) on or off. This function is called automatically when `coconut.api` is imported.\n\nIf _args_ is passed, it will set the Coconut command-line arguments to use for automatic compilation. Arguments will be processed the same way as with [`coconut-run`](#coconut-scripts) such that `--quiet --target sys --keep-lines` will all be set by default.\n\nIf _use\\_cache\\_dir_ is passed, it will turn on or off the usage of a `__coconut_cache__` directory to put compile files in rather than compiling them in-place. Note that `__coconut_cache__` will always be removed from `__file__`.\n\n#### `use_coconut_breakpoint`\n\n**coconut.api.use_coconut_breakpoint**(_on_=`True`)\n\nSwitches the [`breakpoint` built-in](https://www.python.org/dev/peps/pep-0553/) which Coconut makes universally available to use [`coconut.embed`](#coconut-embed) instead of [`pdb.set_trace`](https://docs.python.org/3/library/pdb.html#pdb.set_trace) (or undoes that switch if `on=False`). This function is called automatically when `coconut.api` is imported.\n\n#### `find_packages` and `find_and_compile_packages`\n\n**coconut.api.find_packages**(_where_=`\".\"`, _exclude_=`()`, _include_=`(\"*\",)`)\n\n**coconut.api.find_and_compile_packages**(_where_=`\".\"`, _exclude_=`()`, _include_=`(\"*\",)`)\n\nBoth functions behave identically to [`setuptools.find_packages`](https://setuptools.pypa.io/en/latest/userguide/quickstart.html#package-discovery), except that they find Coconut packages rather than Python packages. `find_and_compile_packages` additionally compiles any Coconut packages that it finds in-place.\n\nNote that if you want to use either of these functions in your `setup.py`, you'll need to include `coconut` as a [build-time dependency in your `pyproject.toml`](https://pip.pypa.io/en/stable/reference/build-system/pyproject-toml/#build-time-dependencies). If you want `setuptools` to package your Coconut files, you'll also need to add `global-include *.coco` to your [`MANIFEST.in`](https://setuptools.pypa.io/en/latest/userguide/miscellaneous.html) and [pass `include_package_data=True` to `setuptools.setup`](https://setuptools.pypa.io/en/latest/userguide/datafiles.html).\n\n##### Example\n\n```coconut_python\n# if you put this in your setup.py, your Coconut package will be compiled in-place whenever it is installed\n\nfrom setuptools import setup\nfrom coconut.api import find_and_compile_packages\n\nsetup(\n    name=...,\n    version=...,\n    packages=find_and_compile_packages(),\n)\n```\n\n#### `version`\n\n**coconut.api.version**(**[**_which_**]**)\n\nRetrieves a string containing information about the Coconut version. The optional argument _which_ is the type of version information desired. Possible values of _which_ are:\n\n- `\"num\"`: the numerical version (the default)\n- `\"name\"`: the version codename\n- `\"spec\"`: the numerical version with the codename attached\n- `\"tag\"`: the version tag used in GitHub and documentation URLs\n- `\"-v\"`: the full string printed by `coconut -v`\n\n#### `CoconutException`\n\nIf an error is encountered in a api function, a `CoconutException` instance may be raised. `coconut.api.CoconutException` is provided to allow catching such errors.\n\n\n### `coconut.__coconut__`\n\nIt is sometimes useful to be able to access Coconut built-ins from pure Python. To accomplish this, Coconut provides `coconut.__coconut__`, which behaves exactly like the `__coconut__.py` header file included when Coconut is compiled in package mode.\n\nAll Coconut built-ins are accessible from `coconut.__coconut__`. The recommended way to import them is to use `from coconut.__coconut__ import` and import whatever built-ins you'll be using.\n\n##### Example\n\n```coconut_python\nfrom coconut.__coconut__ import process_map\n```\n"
        },
        {
          "name": "FAQ.md",
          "type": "blob",
          "size": 11.087890625,
          "content": "# Coconut FAQ\n\n## Frequently Asked Questions\n\n```{contents}\n---\nlocal:\n---\n```\n\n### Can I use Python modules from Coconut and Coconut modules from Python?\n\nYes and yes! Coconut compiles to Python, so Coconut modules are accessible from Python and Python modules are accessible from Coconut, including the entire Python standard library.\n\n### What versions of Python does Coconut support?\n\nCoconut supports any Python version `>= 2.6` on the `2.x` branch or `>= 3.2` on the `3.x` branch. In fact, Coconut code is compiled to run the same on every one of those supported versions! See [compatible Python versions](./DOCS.md#compatible-python-versions) for more information.\n\n### Can Coconut be used to convert Python from one version to another?\n\nYes! But only in the backporting direction: Coconut can convert Python 3 to Python 2, but not the other way around. Coconut really can, though, turn Python 3 code into version-independent Python. Coconut will compile Python 3 syntax, built-ins, and even imports to code that will work on any supported Python version (`2.6`, `2.7`, `>=3.2`).\n\nThere a couple of caveats to this, however: Coconut can't magically make all your other third-party packages version-independent, and some constructs will require a particular `--target` to make them work (for a full list, see [compatible Python versions](./DOCS.md#compatible-python-versions)).\n\n### How do I release a Coconut package on PyPI?\n\nSince Coconut just compiles to Python, releasing a Coconut package on PyPI is exactly the same as releasing a Python package, with an extra compilation step. Just write your package in Coconut, run `coconut` on the source code, and upload the compiled code to PyPI. You can even mix Python and Coconut code, since the compiler will only touch `.coco` files. If you want to see an example of a PyPI package written in Coconut, including a [Makefile with the exact compiler commands being used](https://github.com/evhub/bbopt/blob/master/Makefile), check out [bbopt](https://github.com/evhub/bbopt).\n\n### I saw that Coconut was recently updated. Where is the change log?\n\nInformation on every Coconut release is chronicled on the [GitHub releases page](https://github.com/evhub/coconut/releases). There you can find all of the new features and breaking changes introduced in each release.\n\n### Does Coconut support static type checking?\n\nYes! Coconut compiles the [newest](https://www.python.org/dev/peps/pep-0526/), [fanciest](https://www.python.org/dev/peps/pep-0484/) type annotation syntax into version-independent type comments which can then by checked using Coconut's built-in [MyPy Integration](./DOCS.md#mypy-integration).\n\n### Help! I tried to write a recursive generator and my Python segfaulted!\n\nNo problem—just use Coconut's [`recursive_generator`](./DOCS.md#recursive_generator) decorator and you should be fine. This is a [known Python issue](http://bugs.python.org/issue14010) but `recursive_generator` will fix it for you.\n\n### How do I split an expression across multiple lines in Coconut?\n\nSince Coconut syntax is a superset of Python 3 syntax, Coconut supports the same line continuation syntax as Python. That means both backslash line continuation and implied line continuation inside of parentheses, brackets, or braces will all work. Parenthetical continuation is the recommended method, and Coconut even supports an [enhanced version of it](./DOCS.md#enhanced-parenthetical-continuation).\n\n### I want to use Coconut in a production environment; how do I achieve maximum performance?\n\nFirst, you're going to want a fast compiler, so you should make sure you're using [`cPyparsing`](https://github.com/evhub/cpyparsing). Second, there are two simple things you can do to make Coconut produce faster Python: compile with `--no-tco` and compile with a `--target` specification for the exact version of Python you want to run your code on. Passing `--target` helps Coconut optimize the compiled code for the Python version you want, and, though [Tail Call Optimization](./DOCS.md#tail-call-optimization) is useful, it will usually significantly slow down functions that use it, so disabling it will often provide a major performance boost.\n\n### How do I use a runtime type checker like [`beartype`](https://pypi.org/project/beartype) when Coconut seems to compile all my type annotations to strings/comments?\n\nFirst, to make sure you get actual type annotations rather than type comments, you'll need to `--target` a Python version that supports the sorts of type annotations you'll be using (specifically `--target 3.6` should usually do the trick). Second, if you're using runtime type checking, you'll need to pass the `--no-wrap` argument, which will tell Coconut not to wrap type annotations in strings. When using type annotations for static type checking, wrapping them in strings is preferred, but when using them for runtime type checking, you'll want to disable it.\n\n### When I try to use Coconut on the command line, I get weird unprintable characters and numbers; how do I get rid of them?\n\nYou're probably seeing color codes while using a terminal that doesn't support them (e.g. Windows `cmd`). Try setting the `COCONUT_USE_COLOR` environment variable to `FALSE` to get rid of them.\n\n### How will I be able to debug my Python if I'm not the one writing it?\n\nEase of debugging has long been a problem for all compiled languages, including languages like `C` and `C++` that these days we think of as very low-level languages. The solution to this problem has always been the same: line number maps. If you know what line in the compiled code corresponds to what line in the source code, you can easily debug just from the source code, without ever needing to deal with the compiled code at all. In Coconut, this can easily be accomplished by passing the `--line-numbers` or `-l` flag, which will add a comment to every line in the compiled code with the number of the corresponding line in the source code. Alternatively, `--keep-lines` or `-k` will put in the verbatim source line instead of or in addition to the source line number. Then, if Python raises an error, you'll be able to see from the snippet of the compiled code that it shows you a comment telling you what line in your source code you need to look at to debug the error.\n\n### If I'm already perfectly happy with Python, why should I learn Coconut?\n\nYou're exactly the person Coconut was built for! Coconut lets you keep doing the thing you do well—write Python—without having to worry about annoyances like version compatibility, while also allowing you to do new cool things you might never have thought were possible before like pattern-matching and lazy evaluation. If you've ever used a functional programming language before, you'll know that functional code is often much simpler, cleaner, and more readable (but not always, which is why Coconut isn't purely functional). Python is a wonderful imperative language, but when it comes to modern functional programming—which, in Python's defense, it wasn't designed for—Python falls short, and Coconut corrects that shortfall.\n\n### I don't like functional programming, should I still learn Coconut?\n\nDefinitely! While Coconut is great for functional programming, it also has a bunch of other awesome features as well, including the ability to compile Python 3 code into universal Python code that will run the same on _any version_. And that's not even mentioning all of the features like pattern-matching and destructuring assignment with utility extending far beyond just functional programming. That being said, I'd highly recommend you give functional programming a shot, and since Coconut isn't purely functional, it's a great introduction to the functional style.\n\n### I don't know functional programming, should I still learn Coconut?\n\nYes, absolutely! Coconut's [tutorial](./HELP.md) assumes absolutely no prior knowledge of functional programming, only Python. Because Coconut is not a purely functional programming language, and all valid Python is valid Coconut, Coconut is a great introduction to functional programming. If you learn Coconut, you'll be able to try out a new functional style of programming without having to abandon all the Python you already know and love.\n\n### I don't know Python very well, should I still learn Coconut?\n\nMaybe. If you know the very basics of Python, and are also very familiar with functional programming, then definitely—Coconut will let you continue to use all your favorite tools of functional programming while you make your way through learning Python. If you're not very familiar either with Python, or with functional programming, then you may be better making your way through a Python tutorial before you try learning Coconut. That being said, using Coconut to compile your pure Python code might still be very helpful for you, since it will alleviate having to worry about version incompatibility.\n\n### Why isn't Coconut purely functional?\n\nThe short answer is that Python isn't purely functional, and all valid Python is valid Coconut. The long answer is that Coconut isn't purely functional for the same reason Python was never purely imperative—different problems demand different approaches. Coconut is built to be _useful_, and that means not imposing constraints about what style the programmer is allowed to use. That being said, Coconut is built specifically to work nicely when programming in a functional style, which means if you want to write all your code purely functionally, Coconut will make it a smooth experience, and allow you to have good-looking code to show for it.\n\n### Won't a transpiled language like Coconut be bad for the Python community?\n\nI certainly hope not! Unlike most transpiled languages, all valid Python is valid Coconut. Coconut's goal isn't to replace Python, but to _extend_ it. If a newbie learns Coconut, it won't mean they have a harder time learning Python, it'll mean they _already know_ Python. And not just any Python, the newest and greatest—Python 3. And of course, Coconut is perfectly interoperable with Python, and uses all the same libraries—thus, Coconut can't split the Python community, because the Coconut community _is_ the Python community.\n\n### I want to contribute to Coconut, how do I get started?\n\nThat's great! Coconut is completely open-source, and new contributors are always welcome. Check out Coconut's [contributing guidelines](./CONTRIBUTING.md) for more information.\n\n### Why the name Coconut?\n\n![](http://i.imgur.com/PoFot.jpg)\n\nIf you don't get the reference, the image above is from [Monty Python and the Holy Grail](https://en.wikipedia.org/wiki/Monty_Python_and_the_Holy_Grail), in which the Knights of the Round Table bang Coconuts together to mimic the sound of riding a horse. The name was chosen to reference the fact that [Python is named after Monty Python](https://www.python.org/doc/essays/foreword/) as well.\n\n### Who developed Coconut?\n\n[Evan Hubinger](https://github.com/evhub) is an [AI safety research scientist](https://www.alignmentforum.org/users/evhub) at [Anthropic](https://www.anthropic.com/). He can be reached by asking a question on [Coconut's Gitter chat room](https://gitter.im/evhub/coconut), through email at <evanjhub@gmail.com>, or on [LinkedIn](https://www.linkedin.com/in/ehubinger).\n"
        },
        {
          "name": "FUNDING.yml",
          "type": "blob",
          "size": 0.701171875,
          "content": "# These are supported funding model platforms\n\ngithub: [evhub] # Replace with up to 4 GitHub Sponsors-enabled usernames e.g., [user1, user2]\n# patreon: # Replace with a single Patreon username\nopen_collective: coconut # Replace with a single Open Collective username\n# ko_fi: # Replace with a single Ko-fi username\n# tidelift: # Replace with a single Tidelift platform-name/package-name e.g., npm/babel\n# community_bridge: # Replace with a single Community Bridge project-name e.g., cloud-foundry\n# liberapay: # Replace with a single Liberapay username\n# issuehunt: # Replace with a single IssueHunt username\n# otechie: # Replace with a single Otechie username\n# custom: # Replace with a single custom sponsorship URL\n"
        },
        {
          "name": "HELP.md",
          "type": "blob",
          "size": 63.611328125,
          "content": "# Coconut Tutorial\n\n```{contents}\n---\nlocal:\n---\n```\n\n## Introduction\n\nWelcome to the tutorial for the [Coconut Programming Language](http://evhub.github.io/coconut/)! Coconut is a variant of [Python](https://www.python.org/) built for **simple, elegant, Pythonic functional programming**. But those are just words; what they mean in practice is that _all valid Python 3 is valid Coconut_ but Coconut builds on top of Python a suite of _simple, elegant utilities for functional programming_.\n\nWhy use Coconut? Coconut is built to be useful. Coconut enhances the repertoire of Python programmers to include the tools of modern functional programming, in such a way that those tools are _easy_ to use and immensely _powerful;_ that is, Coconut does to functional programming what Python did to imperative programming. And Coconut code runs the same on _any Python version_, making the Python 2/3 split a thing of the past.\n\nSpecifically, Coconut adds to Python _built-in, syntactical support_ for:\n- pattern-matching\n- algebraic data types\n- destructuring assignment\n- partial application\n- lazy lists\n- function composition\n- prettier lambdas\n- infix notation\n- pipeline-style programming\n- operator functions\n- tail call optimization\n- where statements\n\nand much more!\n\n### Interactive Tutorial\n\nThis tutorial is non-interactive. To get an interactive tutorial instead, check out [Coconut's interactive tutorial](https://hmcfabfive.github.io/coconut-tutorial).\n\nNote, however, that the interactive tutorial is less up-to-date than this one and thus may contain old, deprecated syntax (though Coconut will let you know if you encounter such a situation) as well as outdated idioms (meaning that the example code in the interactive tutorial is likely to be much less elegant than the example code here).\n\n### Installation\n\nAt its very core, Coconut is a compiler that turns Coconut code into Python code. That means that anywhere where you can use a Python script, you can also use a compiled Coconut script. To access that core compiler, Coconut comes with a command-line utility, which can\n- compile single Coconut files or entire Coconut projects,\n- interpret Coconut code on-the-fly, and\n- hook into existing Python applications like IPython/Jupyter and MyPy.\n\nInstalling Coconut, including all the features above, is drop-dead simple. Just\n\n1. install [Python](https://www.python.org/downloads/),\n2. open a command-line prompt,\n3. and enter:\n```\npip install coconut\n```\n\n_Note: If you are having trouble installing Coconut, try following the debugging steps in the [installation section of Coconut's documentation](./DOCS.md#installation)._\n\nTo check that your installation is functioning properly, try entering into the command line\n```\ncoconut -h\n```\nwhich should display Coconut's command-line help.\n\n_Note: If you're having trouble, or if anything mentioned in this tutorial doesn't seem to work for you, feel free to [ask for help on Gitter](https://gitter.im/evhub/coconut) and somebody will try to answer your question as soon as possible._\n\n## Starting Out\n\n### Using the Interpreter\n\nNow that you've got Coconut installed, the obvious first thing to do is to play around with it. To launch the Coconut interpreter, just go to the command line and type\n```\ncoconut\n```\nand you should see something like\n```coconut\nCoconut Interpreter vX.X.X:\n(enter 'exit()' or press Ctrl-D to end)\n>>>\n```\nwhich is Coconut's way of telling you you're ready to start entering code for it to evaluate. So let's do that!\n\nIn case you missed it earlier, _all valid Python 3 is valid Coconut_. That doesn't mean compiled Coconut will only run on Python 3—in fact, compiled Coconut will run the same on any Python version—but it does mean that only Python 3 code is guaranteed to compile as Coconut code.\n\nThat means that if you're familiar with Python, you're already familiar with a good deal of Coconut's core syntax and Coconut's entire standard library. To show that, let's try entering some basic Python into the Coconut interpreter. For example:\n```coconut_pycon\n>>> \"hello, world!\"\n'hello, world!'\n>>> 1 + 1\n2\n```\n\n### Writing Coconut Files\n\nOf course, while being able to interpret Coconut code on-the-fly is a great thing, it wouldn't be very useful without the ability to write and compile larger programs. To that end, it's time to write our first Coconut program: \"hello, world!\" Coconut-style.\n\nFirst, we're going to need to create a file to put our code into. The file extension for Coconut source files is `.coco`, so let's create the new file `hello_world.coco`. After you do that, you should take the time now to set up your text editor to properly highlight Coconut code. For instructions on how to do that, see the documentation on [Coconut syntax highlighting](./DOCS.md#syntax-highlighting).\n\nNow let's put some code in our `hello_world.coco` file. Unlike in Python, where headers like\n```coconut_python\n#!/usr/bin/env python\n# -*- coding: UTF-8 -*-\nfrom __future__ import print_function, absolute_import, unicode_literals, division\n```\nare common and often very necessary, the Coconut compiler will automatically take care of all of that for you, so all you need to worry about is your own code. To that end, let's add the code for our \"hello, world!\" program.\n\nIn pure Python 3, \"hello, world!\" is\n```coconut_python\nprint(\"hello, world!\")\n```\nand while that will work in Coconut, equally as valid is to use a pipeline-style approach, which is what we'll do, and write\n```coconut\n\"hello, world!\" |> print\n```\nwhich should let you see very clearly how Coconut's `|>` operator enables pipeline-style programming: it allows an object to be passed along from function to function, with a different operation performed at each step. In this case, we are piping the object `\"hello, world!\"` into the operation `print`. Now let's save our simple \"hello, world!\" program, and try to run it.\n\n### Using the Compiler\n\nCompiling Coconut files and projects with the Coconut command-line utility is incredibly simple. Just `cd` into the directory of your `hello_world.coco` file and type\n```\ncoconut hello_world.coco\n```\nwhich should give the output\n```\nCoconut: Compiling       hello_world.coco ...\nCoconut: Compiled to     hello_world.py .\n```\nand deposit a new `hello_world.py` file in the same directory as the `hello_world.coco` file. You should then be able to run that file with\n```\npython hello_world.py\n```\nwhich should produce `hello, world!` as the output.\n\n_Note: You can compile and run your code all in one step if you use Coconut's `--run` option (`-r` for short)._\n\nCompiling single files is not the only way to use the Coconut command-line utility, however. We can also compile all the Coconut files in a given directory simply by passing that directory as the first argument, which will get rid of the need to run the same Coconut header code in each file by storing it in a `__coconut__.py` file in the same directory.\n\nThe Coconut  compiler supports a large variety of different compilation options, the help for which can always be accessed by entering `coconut -h` into the command line. One of the most useful of these is `--line-numbers` (or `-l` for short). Using `--line-numbers` will add the line numbers of your source code as comments in the compiled code, allowing you to see what line in your source code corresponds to a line in the compiled code where an error occurred, for ease of debugging.\n\n_Note: If you don't need the full control of the Coconut compiler, you can also [access your Coconut code just by importing it](./DOCS.md#automatic-compilation), either from the Coconut interpreter, or in any Python file where you import [`coconut.api`](./DOCS.md#coconut-api)._\n\n### Using IPython/Jupyter\n\nAlthough all different types of programming can benefit from using more functional techniques, scientific computing, perhaps more than any other field, lends itself very well to functional programming, an observation the case studies in this tutorial are very good examples of. That's why Coconut aims to provide extensive support for the established tools of scientific computing in Python.\n\nTo that end, Coconut provides [built-in IPython/Jupyter support](./DOCS.md#ipython-jupyter-support). To launch a Jupyter notebook with Coconut, just enter the command\n```\ncoconut --jupyter notebook\n```\n\n_Alternatively, to launch the Jupyter interpreter with Coconut as the kernel, run `coconut --jupyter console` instead. Additionally, you can launch an interactive Coconut Jupyter console initialized from the current namespace by inserting `from coconut import embed; embed()` into your code, which can be a very useful debugging tool._\n\n### Case Studies\n\nBecause Coconut is built to be useful, the best way to demo it is to show it in action. To that end, the majority of this tutorial will be showing how to apply Coconut to solve particular problems, which we'll call case studies.\n\nThese case studies are not intended to provide a complete picture of all of Coconut's features. For that, see Coconut's [documentation](./DOCS.md). Instead, they are intended to show how Coconut can actually be used to solve practical programming problems.\n\n## Case Study 1: `factorial`\n\nIn the first case study we will be defining a `factorial` function, that is, a function that computes `n!` where `n` is an integer `>= 0`. This is somewhat of a toy example, since Python can fairly easily do this, but it will serve as a good showcase of some of the basic features of Coconut and how they can be used to great effect.\n\nTo start off with, we're going to have to decide what sort of an implementation of `factorial` we want. There are many different ways to tackle this problem, but for the sake of concision we'll split them into four major categories: imperative, recursive, iterative, and `addpattern`.\n\n### Imperative Method\n\nThe imperative approach is the way you'd write `factorial` in a language like C. Imperative approaches involve lots of state change, where variables are regularly modified and loops are liberally used. In Coconut, the imperative approach to the `factorial` problem looks like this:\n```coconut\ndef factorial(n):\n    \"\"\"Compute n! where n is an integer >= 0.\"\"\"\n    if n `isinstance` int and n >= 0:\n        acc = 1\n        for x in range(1, n+1):\n            acc *= x\n        return acc\n    else:\n        raise TypeError(\"the argument to factorial must be an integer >= 0\")\n\n# Test cases:\n-1 |> factorial |> print  # TypeError\n0.5 |> factorial |> print  # TypeError\n0 |> factorial |> print  # 1\n3 |> factorial |> print  # 6\n```\n\nBefore we delve into what exactly is happening here, let's give it a run and make sure the test cases check out. If we were really writing a Coconut program, we'd want to save and compile an actual file, but since we're just playing around, let's try copy-pasting into the interpreter. Here, you should get two `TypeErrors`, then `1`, then `6`.\n\nNow that we've verified it works, let's take a look at what's going on. Since the imperative approach is a fundamentally non-functional method, Coconut can't help us improve this example very much. Even here, though, the use of Coconut's infix notation (where the function is put in-between its arguments, surrounded in backticks) in `` n `isinstance` int `` makes the code slightly cleaner and easier to read.\n\n### Recursive Method\n\nThe recursive approach is the first of the fundamentally functional approaches, in that it doesn't involve the state change and loops of the imperative approach. Recursive approaches avoid the need to change variables by making that variable change implicit in the recursive function call. Here's the recursive approach to the `factorial` problem in Coconut:\n```coconut\ndef factorial(n):\n    \"\"\"Compute n! where n is an integer >= 0.\"\"\"\n    match n:\n        case 0:\n            return 1\n        case x `isinstance` int if x > 0:\n            return x * factorial(x-1)\n    else:\n        raise TypeError(\"the argument to factorial must be an integer >= 0\")\n\n# Test cases:\n-1 |> factorial |> print  # TypeError\n0.5 |> factorial |> print  # TypeError\n0 |> factorial |> print  # 1\n3 |> factorial |> print  # 6\n```\n\nGo ahead and copy and paste the code and tests into the interpreter. You should get the same test results as you got for the imperative version—but you can probably tell there's quite a lot more going on here than there. That's intentional: Coconut is intended for functional programming, not imperative programming, and so its new features are built to be most useful when programming in a functional style.\n\nLet's take a look at the specifics of the syntax in this example. The first thing we see is `match n`. This statement starts a `case` block, in which only `case` statements can occur. Each `case` statement will attempt to match its given pattern against the value in the `case` block. Only the first successful match inside of any given `case` block will be executed. When a match is successful, any variable bindings in that match will also be performed. Additionally, as is true in this case, `case` statements can also have `if` guards that will check the given condition before the match is considered final. Finally, after the `case` block, an `else` statement is allowed, which will only be executed if no `case` statement is.\n\nSpecifically, in this example, the first `case` statement checks whether `n` matches to `0`. If it does, it executes `return 1`. Then the second `case` statement checks whether `n` matches to `` x `isinstance` int ``, which checks that `n` is an `int` (using `isinstance`) and assigns `x = n` if so, then checks whether `x > 0`, and if so, executes `return x * factorial(x-1)`. If neither of those two statements are executed, the `else` statement triggers and executes `raise TypeError(\"the argument to factorial must be an integer >= 0\")`.\n\nAlthough this example is very basic, pattern-matching is both one of Coconut's most powerful and most complicated features. As a general intuitive guide, it is helpful to think _assignment_ whenever you see the keyword `match`. A good way to showcase this is that all `match` statements can be converted into equivalent destructuring assignment statements, which are also valid Coconut. In this case, the destructuring assignment equivalent to the `factorial` function above would be:\n```coconut\ndef factorial(n):\n    \"\"\"Compute n! where n is an integer >= 0.\"\"\"\n    try:\n        # The only value that can be assigned to 0 is 0, since 0 is an\n        # immutable constant; thus, this assignment fails if n is not 0.\n        0 = n\n    except MatchError:\n        pass\n    else:\n        return 1\n    try:\n        # This attempts to assign n to x, which has been declared to be\n        # an int; since only an int can be assigned to an int, this\n        # fails if n is not an int.\n        x `isinstance` int = n\n    except MatchError:\n        pass\n    else: if x > 0:  # in Coconut, statements can be nested on the same line\n        return x * factorial(x-1)\n    raise TypeError(\"the argument to factorial must be an integer >= 0\")\n\n# Test cases:\n-1 |> factorial |> print  # TypeError\n0.5 |> factorial |> print  # TypeError\n0 |> factorial |> print  # 1\n3 |> factorial |> print  # 6\n```\n\nFirst, copy and paste! While this destructuring assignment equivalent should work, it is much more cumbersome than `match` statements when you expect that they'll fail, which is why `match` statement syntax exists. But the destructuring assignment equivalent illuminates what exactly the pattern-matching is doing, by making it clear that `match` statements are really just fancy destructuring assignment statements. In fact, to be explicit about using destructuring assignment instead of normal assignment, the `match` keyword can be put before a destructuring assignment statement to signify it as such.\n\nIt will be helpful to, as we continue to use Coconut's pattern-matching and destructuring assignment statements in further examples, think _assignment_ whenever you see the keyword `match`.\n\nNext, we can make a couple of simple improvements to our `factorial` function. First, we don't actually need to assign `x` as a new variable, since it has the same value as `n`, so if we use `_` instead of `x`, Coconut won't ever actually assign the variable. Thus, we can rewrite our `factorial` function as:\n```coconut\ndef factorial(n):\n    \"\"\"Compute n! where n is an integer >= 0.\"\"\"\n    match n:\n        case 0:\n            return 1\n        case _ `isinstance` int if n > 0:\n            return n * factorial(n-1)\n    else:\n        raise TypeError(\"the argument to factorial must be an integer >= 0\")\n\n# Test cases:\n-1 |> factorial |> print  # TypeError\n0.5 |> factorial |> print  # TypeError\n0 |> factorial |> print  # 1\n3 |> factorial |> print  # 6\n```\n\nCopy, paste! This new `factorial` function should behave exactly the same as before.\n\nSecond, we can replace the `` _ `isinstance` int `` pattern with the class pattern `int()`, which, when used with no arguments like that, is equivalent. Thus, we can again rewrite our `factorial` function to:\n```coconut\ndef factorial(n):\n    \"\"\"Compute n! where n is an integer >= 0.\"\"\"\n    match n:\n        case 0:\n            return 1\n        case int() if n > 0:\n            return n * factorial(n-1)\n    else:\n        raise TypeError(\"the argument to factorial must be an integer >= 0\")\n\n# Test cases:\n-1 |> factorial |> print  # TypeError\n0.5 |> factorial |> print  # TypeError\n0 |> factorial |> print  # 1\n3 |> factorial |> print  # 6\n```\n\nUp until now, for the recursive method, we have only dealt with pattern-matching, but there's actually another way that Coconut allows us to improve our `factorial` function. Coconut performs automatic tail call optimization, which means that whenever a function directly returns a call to another function, Coconut will optimize away the additional call. Thus, we can improve our `factorial` function by rewriting it to use a tail call:\n```coconut\ndef factorial(n, acc=1):\n    \"\"\"Compute n! where n is an integer >= 0.\"\"\"\n    match n:\n        case 0:\n            return acc\n        case int() if n > 0:\n            return factorial(n-1, acc*n)\n    else:\n        raise TypeError(\"the argument to factorial must be an integer >= 0\")\n\n# Test cases:\n-1 |> factorial |> print  # TypeError\n0.5 |> factorial |> print  # TypeError\n0 |> factorial |> print  # 1\n3 |> factorial |> print  # 6\n```\n\nCopy, paste! This new `factorial` function is equivalent to the original version, with the exception that it will never raise a `RuntimeError` due to reaching Python's maximum recursion depth, since Coconut will optimize away the tail call.\n\n### Iterative Method\n\nThe other main functional approach is the iterative one. Iterative approaches avoid the need for state change and loops by using higher-order functions, those that take other functions as their arguments, like `map` and `reduce`, to abstract out the basic operations being performed. In Coconut, the iterative approach to the `factorial` problem is:\n```coconut\ndef factorial(n):\n    \"\"\"Compute n! where n is an integer >= 0.\"\"\"\n    match n:\n        case 0:\n            return 1\n        case int() if n > 0:\n            return range(1, n+1) |> reduce$(*)\n    else:\n        raise TypeError(\"the argument to factorial must be an integer >= 0\")\n\n# Test cases:\n-1 |> factorial |> print  # TypeError\n0.5 |> factorial |> print  # TypeError\n0 |> factorial |> print  # 1\n3 |> factorial |> print  # 6\n```\n\nCopy, paste! This definition differs from the recursive definition only by one line. That's intentional: because both the iterative and recursive approaches are functional approaches, Coconut can provide a great assist in making the code cleaner and more readable. The one line that differs is this one:\n```coconut\nreturn range(1, n+1) |> reduce$(*)\n```\n\nLet's break down what's happening on this line. First, the `range` function constructs an iterator of all the numbers that need to be multiplied together. Then, it is piped into the function `reduce$(*)`, which does that multiplication. But how? What is `reduce$(*)`?\n\nWe'll start with the base, the `reduce` function. `reduce` used to exist as a built-in in Python 2, and Coconut brings it back. `reduce` is a higher-order function that takes a function of two arguments as its first argument, and an iterator as its second argument, and applies that function to the given iterator by starting with the first element, and calling the function on the accumulated call so far and the next element, until the iterator is exhausted. Here's a visual representation:\n```coconut\nreduce(f, (a, b, c, d))\n\nacc                 iter\n                    (a, b, c, d)\na                   (b, c, d)\nf(a, b)             (c, d)\nf(f(a, b), c)       (d)\nf(f(f(a, b), c), d)\n\nreturn acc\n```\n\nNow let's take a look at what we do to `reduce` to make it multiply all the numbers we feed into it together. The Coconut code that we saw for that was `reduce$(*)`. There are two different Coconut constructs being used here: the operator function for multiplication in the form of `(*)`, and partial application in the form of `$`.\n\nFirst, the operator function. In Coconut, a function form of any operator can be retrieved by surrounding that operator in parentheses. In this case, `(*)` is roughly equivalent to `lambda x, y: x*y`, but much cleaner and neater. In Coconut's lambda syntax, `(*)` is also equivalent to `(x, y) => x*y`, which we will use from now on for all lambdas, even though both are legal Coconut, because Python's `lambda` statement is too ugly and bulky to use regularly.\n\n_Note: If Coconut's `--strict` mode is enabled, which will force your code to obey certain cleanliness standards, it will raise an error whenever Python `lambda` statements are used._\n\nSecond, the partial application. Think of partial application as _lazy function calling_, and `$` as the _lazy-ify_ operator, where lazy just means \"don't evaluate this until you need to.\" In Coconut, if a function call is prefixed by a `$`, like in this example, instead of actually performing the function call, a new function is returned with the given arguments already provided to it, so that when it is then called, it will be called with both the partially-applied arguments and the new arguments, in that order. In this case, `reduce$(*)` is roughly equivalent to `(*args, **kwargs) => reduce((*), *args, **kwargs)`.\n\n_You can partially apply arguments in any order using `?` in place of missing arguments, as in `to_binary = int$(?, 2)`._\n\nPutting it all together, we can see how the single line of code\n```coconut\nrange(1, n+1) |> reduce$(*)\n```\nis able to compute the proper factorial, without using any state or loops, only higher-order functions, in true functional style. By supplying the tools we use here like partial application (`$`), pipeline-style programming (`|>`), higher-order functions (`reduce`), and operator functions (`(*)`), Coconut enables this sort of functional programming to be done cleanly, neatly, and easily.\n\n### `addpattern` Method\n\nWhile the iterative approach is very clean, there are still some bulky pieces—looking at the iterative version below, you can see that it takes three entire indentation levels to get from the function definition to the actual objects being returned:\n```coconut\ndef factorial(n):\n    \"\"\"Compute n! where n is an integer >= 0.\"\"\"\n    match n:\n        case 0:\n            return 1\n        case int() if n > 0:\n            return range(1, n+1) |> reduce$(*)\n    else:\n        raise TypeError(\"the argument to factorial must be an integer >= 0\")\n```\n\nBy making use of the [Coconut `addpattern` syntax](./DOCS.md#addpattern), we can take that from three indentation levels down to one. Take a look:\n```coconut\ndef factorial(0) = 1\n\naddpattern def factorial(int() as n if n > 0) =\n    \"\"\"Compute n! where n is an integer >= 0.\"\"\"\n    range(1, n+1) |> reduce$(*)\n\n# Test cases:\n-1 |> factorial |> print  # MatchError\n0.5 |> factorial |> print  # MatchError\n0 |> factorial |> print  # 1\n3 |> factorial |> print  # 6\n```\nCopy, paste! This should work exactly like before, except now it raises `MatchError` as a fall through instead of `TypeError`. There are three major new concepts to talk about here: `addpattern`, of course, assignment function notation, and pattern-matching function definition—how both of the functions above are defined.\n\nFirst, assignment function notation. This one's pretty straightforward. If a function is defined with an `=` instead of a `:`, the last line is required to be an expression, and is automatically returned.\n\nSecond, pattern-matching function definition. Pattern-matching function definition does exactly that—pattern-matches against all the arguments that are passed to the function. Unlike normal function definition, however, if the pattern doesn't match (if for example the wrong number of arguments are passed), your function will raise a `MatchError`. Finally, like destructuring assignment, if you want to be more explicit about using pattern-matching function definition, you can add a `match` before the `def`. In this case, we're also using one new pattern-matching construct, the `as` match, which matches against the pattern on the left and assigns the result to the name on the right.\n\nThird, `addpattern`. `addpattern` creates a new pattern-matching function by adding the new pattern as an additional case to the old pattern-matching function it is replacing. Thus, `addpattern` can be thought of as doing exactly what it says—it adds a new pattern to an existing pattern-matching function.\n\nFinally, not only can we rewrite the iterative approach using `addpattern`, as we did above, we can also rewrite the recursive approach using `addpattern`, like so:\n```coconut\ndef factorial(0) = 1\n\naddpattern def factorial(int() as n if n > 0) =\n    \"\"\"Compute n! where n is an integer >= 0.\"\"\"\n    n * factorial(n - 1)\n\n# Test cases:\n-1 |> factorial |> print  # MatchError\n0.5 |> factorial |> print  # MatchError\n0 |> factorial |> print  # 1\n3 |> factorial |> print  # 6\n```\nCopy, paste! It should work exactly like before, except, as above, with `TypeError` replaced by `MatchError`.\n\n## Case Study 2: `quick_sort`\n\nIn the second case study, we will be implementing the [quick sort algorithm](https://en.wikipedia.org/wiki/Quicksort). We will implement two versions: first, a `quick_sort` function that takes in a list and outputs a list, and second, a `quick_sort` function that takes in an iterator and outputs an iterator.\n\n### Sorting a Sequence\n\nFirst up is `quick_sort` for lists. We're going to use a recursive `addpattern`-based approach to tackle this problem—a similar approach to the very last `factorial` function we wrote, using `addpattern` to reduce the amount of indentation we're going to need. Without further ado, here's our implementation of `quick_sort` for lists:\n```coconut\ndef quick_sort([]) = []\n\naddpattern def quick_sort([head] + tail) =\n    \"\"\"Sort the input sequence using the quick sort algorithm.\"\"\"\n    quick_sort(left) + [head] + quick_sort(right) where:\n        left = [x for x in tail if x < head]\n        right = [x for x in tail if x >= head]\n\n# Test cases:\n[] |> quick_sort |> print  # []\n[3] |> quick_sort |> print  # [3]\n[0,1,2,3,4] |> quick_sort |> print  # [0,1,2,3,4]\n[4,3,2,1,0] |> quick_sort |> print  # [0,1,2,3,4]\n[3,0,4,2,1] |> quick_sort |> print  # [0,1,2,3,4]\n```\nCopy, paste! Two new feature here: head-tail pattern-matching and `where` statements.\n\nFirst, `where` statements are extremely straightforward. In fact, I bet you've already figured out what they do from the code above. A `where` statement is just a way to compute something in the context of some set of assignment statements.\n\nSecond, head-tail pattern-matching, which you can see here as `[head] + tail`, simply follows the form of a list or tuple added to a variable. When this appears in any pattern-matching context, the value being matched against will be treated as a sequence, the list or tuple matched against the beginning of that sequence, and the rest of it bound to the variable. In this case, we use the head-tail pattern to remove the head so we can use it as the pivot for splitting the rest of the list.\n\n### Sorting an Iterator\n\nNow it's time to try `quick_sort` for iterators. Our method for tackling this problem is going to be a combination of the recursive and iterative approaches we used for the `factorial` problem, in that we're going to be lazily building up an iterator, and we're going to be doing it recursively. Here's the code:\n```coconut\ndef quick_sort(l):\n    \"\"\"Sort the input iterator using the quick sort algorithm.\"\"\"\n    match [head] :: tail in l:\n        tail = reiterable(tail)\n        yield from quick_sort(left) :: [head] :: quick_sort(right) where:\n            left = (x for x in tail if x < head)\n            right = (x for x in tail if x >= head)\n    # By yielding nothing if the match falls through, we implicitly return an empty iterator.\n\n# Test cases:\n[] |> quick_sort |> list |> print  # []\n[3] |> quick_sort |> list |> print  # [3]\n[0,1,2,3,4] |> quick_sort |> list |> print  # [0,1,2,3,4]\n[4,3,2,1,0] |> quick_sort |> list |> print  # [0,1,2,3,4]\n[3,0,4,2,1] |> quick_sort |> list |> print  # [0,1,2,3,4]\n```\nCopy, paste! This `quick_sort` algorithm works uses a bunch of new constructs, so let's go over them.\n\nFirst, the `::` operator, which appears here both in pattern-matching and by itself. In essence, the `::` operator is lazy `+` for iterators. On its own, it takes two iterators and concatenates, or chains, them together, and it does this lazily, not evaluating anything until its needed, so it can be used for making infinite iterators. In pattern-matching, it inverts that operation, destructuring the beginning of an iterator into a pattern, and binding the rest of that iterator to a variable.\n\nWhich brings us to the second new thing, `match ... in ...` notation. The notation\n```coconut\nmatch pattern in item:\n    <body>\nelse:\n    <else>\n```\nis shorthand for\n```coconut\nmatch item:\n    case pattern:\n        <body>\nelse:\n    <else>\n```\nthat avoids the need for an additional level of indentation when only one `match` is being performed.\n\nThe third new construct is the [Coconut built-in `reiterable`](./DOCS.md#reiterable). There is a problem in doing immutable functional programming with Python iterators: whenever an element of an iterator is accessed, it's lost. `reiterable` solves this problem by allowing the iterable it's called on to be iterated over multiple times while still yielding the same result each time\n\nFinally, although it's not a new construct, since it exists in Python 3, the use of `yield from` here deserves a mention. In Python, `yield` is the statement used to construct iterators, functioning much like `return`, with the exception that multiple `yield`s can be encountered, and each one will produce another element. `yield from` is very similar, except instead of adding a single element to the produced iterator, it adds another whole iterator.\n\nPutting it all together, here's our `quick_sort` function again:\n```coconut\ndef quick_sort(l):\n    \"\"\"Sort the input iterator using the quick sort algorithm.\"\"\"\n    match [head] :: tail in l:\n        tail = reiterable(tail)\n        yield from quick_sort(left) :: [head] :: quick_sort(right) where:\n            left = (x for x in tail if x < head)\n            right = (x for x in tail if x >= head)\n    # By yielding nothing if the match falls through, we implicitly return an empty iterator.\n```\n\nThe function first attempts to split `l` into an initial element and a remaining iterator. If `l` is the empty iterator, that match will fail, and it will fall through, yielding the empty iterator (that's how the function handles the base case). Otherwise, we make a copy of the rest of the iterator, and yield the join of (the quick sort of all the remaining elements less than the initial element), (the initial element), and (the quick sort of all the remaining elements greater than the initial element).\n\nThe advantages of the basic approach used here, heavy use of iterators and recursion, as opposed to the classical imperative approach, are numerous. First, our approach is more clear and more readable, since it is describing _what_ `quick_sort` is instead of _how_ `quick_sort` could be implemented. Second, our approach is _lazy_ in that our `quick_sort` won't evaluate any data until it needs it. Finally, and although this isn't relevant for `quick_sort` it is relevant in many other cases, an example of which we'll see later in this tutorial, our approach allows for working with _infinite_ series just like they were finite.\n\nAnd Coconut makes programming in such an advantageous functional approach significantly easier. In this example, Coconut's pattern-matching lets us easily split the given iterator, and Coconut's `::` iterator joining operator lets us easily put it back together again in sorted order.\n\n## Case Study 3: `vector` Part I\n\nIn the next case study, we'll be doing something slightly different—instead of defining a function, we'll be creating an object. Specifically, we're going to try to implement an immutable n-vector that supports all the basic vector operations.\n\nIn functional programming, it is often very desirable to define _immutable_ objects, those that can't be changed once created—like Python's strings or tuples. Like strings and tuples, immutable objects are useful for a wide variety of reasons:\n- they're easier to reason about, since you can be guaranteed they won't change,\n- they're hashable and pickleable, so they can be used as keys and serialized,\n- they're significantly more efficient since they require much less overhead,\n- and when combined with pattern-matching, they can be used as what are called _algebraic data types_ to build up and then match against large, complicated data structures very easily.\n\n### 2-Vector\n\nCoconut's `data` statement brings the power and utility of _immutable, algebraic data types_ to Python, and it is this that we will be using to construct our `vector` type. The demonstrate the syntax of `data` statements, we'll start by defining a simple 2-vector. Our vector will have one special method `__abs__` which will compute the vector's magnitude, defined as the square root of the sum of the squares of the elements. Here's our 2-vector:\n```coconut\ndata vector2(x, y):\n    \"\"\"Immutable 2-vector.\"\"\"\n    def __abs__(self) =\n        \"\"\"Return the magnitude of the 2-vector.\"\"\"\n        (self.x**2 + self.y**2)**0.5\n\n# Test cases:\nvector2(1, 2) |> print  # vector2(x=1, y=2)\nvector2(3, 4) |> abs |> print  # 5\nvector2(1, 2) |> fmap$(x => x*2) |> print  # vector2(x=2, y=4)\nv = vector2(2, 3)\nv.x = 7  # AttributeError\n```\n\nCopy, paste! This example shows the basic syntax of `data` statements:\n```coconut\ndata <name>(<attributes>):\n    <body>\n```\nwhere `<name>` and `<body>` are the same as the equivalent `class` definition, but `<attributes>` are the different attributes of the data type, in order that the constructor should take them as arguments. In this case, `vector2` is a data type of two attributes, `x` and `y`, with one defined method, `__abs__`, that computes the magnitude. As the test cases show, we can then create, print, but _not modify_ instances of `vector2`.\n\nOne other thing to call attention to here is the use of the [Coconut built-in `fmap`](./DOCS.md#fmap). `fmap` allows you to map functions over algebraic data types. Coconut's `data` types do support iteration, so the standard `map` works on them, but it doesn't return another object of the same data type. In this case, `fmap` is simply `map` plus a call to the object's constructor.\n\n### n-Vector Constructor\n\nNow that we've got the 2-vector under our belt, let's move to back to our original, more complicated problem: n-vectors, that is, vectors of arbitrary length. We're going to try to make our n-vector support all the basic vector operations, but we'll start out with just the `data` definition and the constructor:\n```coconut\ndata vector(*pts):\n    \"\"\"Immutable n-vector.\"\"\"\n    def __new__(cls, *pts):\n        \"\"\"Create a new vector from the given pts.\"\"\"\n        match [v `isinstance` vector] in pts:\n            return v  # vector(v) where v is a vector should return v\n        else:\n            return pts |*> makedata$(cls)  # accesses base constructor\n\n# Test cases:\nvector(1, 2, 3) |> print  # vector(*pts=(1, 2, 3))\nvector(4, 5) |> vector |> print  # vector(*pts=(4, 5))\n```\n\nCopy, paste! The big new thing here is how to write `data` constructors. Since `data` types are immutable, `__init__` construction won't work. Instead, a different special method `__new__` is used, which must return the newly constructed instance, and unlike most methods, takes the class not the object as the first argument. Since `__new__` needs to return a fully constructed instance, in almost all cases it will be necessary to access the underlying `data` constructor. To achieve this, Coconut provides the [built-in `makedata` function](./DOCS.md#makedata), which takes a data type and calls its underlying `data` constructor with the rest of the arguments.\n\nIn this case, the constructor checks whether nothing but another `vector` was passed, in which case it returns that, otherwise it returns the result of passing the arguments to the underlying constructor, the form of which is `vector(*pts)`, since that is how we declared the data type. We use sequence pattern-matching to determine whether we were passed a single vector, which is just a list or tuple of patterns to match against the contents of the sequence.\n\nOne important pitfall that's worth pointing out here: in this case, you must use `` v `isinstance` vector `` rather than `vector() as v`, since, as we'll see later, patterns like `vector()` behave differently for `data` types than normal classes. In this case, `vector()` would only match a _zero-length_ vector, not just any vector.\n\nThe other new construct used here is the `|*>`, or star-pipe, operator, which functions exactly like the normal pipe, except that instead of calling the function with one argument, it calls it with as many arguments as there are elements in the sequence passed into it. The difference between `|>` and `|*>` is exactly analogous to the difference between `f(args)` and `f(*args)`.\n\n### n-Vector Methods\n\nNow that we have a constructor for our n-vector, it's time to write its methods. First up is `__abs__`, which should compute the vector's magnitude. This will be slightly more complicated than with the 2-vector, since we have to make it work over an arbitrary number of `pts`. Fortunately, we can use Coconut's pipeline-style programming and partial application to make it simple:\n```coconut\n    def __abs__(self) =\n        \"\"\"Return the magnitude of the vector.\"\"\"\n        self.pts |> map$(.**2) |> sum |> (.**0.5)\n```\nThe basic algorithm here is map square over each element, sum them all, then square root the result. The one new construct here is the `(.**2)` and `(.**0.5)` syntax, which are effectively equivalent to `(x => x**2)` and `(x => x**0.5)`, respectively (though the `(.**2)` syntax produces a pickleable object). This syntax works for all [operator functions](./DOCS.md#operator-functions), so you can do things like `(1-.)` or `(cond() or .)`.\n\nNext up is vector addition. The goal here is to add two vectors of equal length by adding their components. To do this, we're going to make use of Coconut's ability to perform pattern-matching, or in this case destructuring assignment, to data types, like so:\n```coconut\n    def __add__(self, vector(*other_pts)\n                if len(other_pts) == len(self.pts)) =\n        \"\"\"Add two vectors together.\"\"\"\n        map((+), self.pts, other_pts) |*> vector\n```\n\nThere are a couple of new constructs here, but the main notable one is the pattern-matching `vector(*other_pts)` which showcases the syntax for pattern-matching against data types: it mimics exactly the original `data` declaration of that data type. In this case, `vector(*other_pts)` will only match a vector, raising a `MatchError` otherwise, and if it does match a vector, will assign the vector's `pts` attribute to the variable `other_pts`.\n\nNext is vector subtraction, which is just like vector addition, but with `(-)` instead of `(+)`:\n```coconut\n    def __sub__(self, vector(*other_pts)\n                if len(other_pts) == len(self.pts)) =\n        \"\"\"Subtract one vector from another.\"\"\"\n        map((-), self.pts, other_pts) |*> vector\n```\n\nOne thing to note here is that unlike the other operator functions, `(-)` can either mean negation or subtraction, the meaning of which will be inferred based on how many arguments are passed, 1 for negation, 2 for subtraction. To show this, we'll use the same `(-)` function to implement vector negation, which should simply negate each element:\n```coconut\n    def __neg__(self) =\n        \"\"\"Retrieve the negative of the vector.\"\"\"\n        self.pts |> map$(-) |*> vector\n```\n\nThe last method we'll implement is multiplication. This one is a little bit tricky, since mathematically, there are a whole bunch of different ways to multiply vectors. For our purposes, we're just going to look at two: between two vectors of equal length, we want to compute the dot product, defined as the sum of the corresponding elements multiplied together, and between a vector and a scalar, we want to compute the scalar multiple, which is just each element multiplied by that scalar. Here's our implementation:\n```coconut\n    def __mul__(self, other):\n        \"\"\"Scalar multiplication and dot product.\"\"\"\n        match vector(*other_pts) in other:\n            assert len(other_pts) == len(self.pts)\n            return map((*), self.pts, other_pts) |> sum  # dot product\n        else:\n            return self.pts |> map$(.*other) |*> vector  # scalar multiple\n    def __rmul__(self, other) =\n        \"\"\"Necessary to make scalar multiplication commutative.\"\"\"\n        self * other\n```\n\nThe first thing to note here is that unlike with addition and subtraction, where we wanted to raise an error if the vector match failed, here, we want to do scalar multiplication if the match fails, so instead of using destructuring assignment, we use a `match` statement. The second thing to note here is the combination of pipeline-style programming, partial application, operator functions, and higher-order functions we're using to compute the dot product and scalar multiple. For the dot product, we map multiplication over the two vectors, then sum the result. For the scalar multiple, we take the original points, map multiplication by the scalar over them, then use them to make a new vector.\n\nFinally, putting everything together:\n```coconut\ndata vector(*pts):\n    \"\"\"Immutable n-vector.\"\"\"\n    def __new__(cls, *pts):\n        \"\"\"Create a new vector from the given pts.\"\"\"\n        match [v `isinstance` vector] in pts:\n            return v  # vector(v) where v is a vector should return v\n        else:\n            return pts |*> makedata$(cls)  # accesses base constructor\n    def __abs__(self) =\n        \"\"\"Return the magnitude of the vector.\"\"\"\n        self.pts |> map$(.**2) |> sum |> (.**0.5)\n    def __add__(self, vector(*other_pts)\n                if len(other_pts) == len(self.pts)) =\n        \"\"\"Add two vectors together.\"\"\"\n        map((+), self.pts, other_pts) |*> vector\n    def __sub__(self, vector(*other_pts)\n                if len(other_pts) == len(self.pts)) =\n        \"\"\"Subtract one vector from another.\"\"\"\n        map((-), self.pts, other_pts) |*> vector\n    def __neg__(self) =\n        \"\"\"Retrieve the negative of the vector.\"\"\"\n        self.pts |> map$(-) |*> vector\n    def __mul__(self, other):\n        \"\"\"Scalar multiplication and dot product.\"\"\"\n        match vector(*other_pts) in other:\n            assert len(other_pts) == len(self.pts)\n            return map((*), self.pts, other_pts) |> sum  # dot product\n        else:\n            return self.pts |> map$(.*other) |*> vector  # scalar multiplication\n    def __rmul__(self, other) =\n        \"\"\"Necessary to make scalar multiplication commutative.\"\"\"\n        self * other\n\n# Test cases:\nvector(1, 2, 3) |> print  # vector(*pts=(1, 2, 3))\nvector(4, 5) |> vector |> print  # vector(*pts=(4, 5))\nvector(3, 4) |> abs |> print  # 5\nvector(1, 2) + vector(2, 3) |> print  # vector(*pts=(3, 5))\nvector(2, 2) - vector(0, 1) |> print  # vector(*pts=(2, 1))\n-vector(1, 3) |> print  # vector(*pts=(-1, -3))\n(vector(1, 2) == \"string\") |> print  # False\n(vector(1, 2) == vector(3, 4)) |> print  # False\n(vector(2, 4) == vector(2, 4)) |> print  # True\n2*vector(1, 2) |> print  # vector(*pts=(2, 4))\nvector(1, 2) * vector(1, 3) |> print  # 7\n```\n\nCopy, paste! Now that was a lot of code. But looking it over, it looks clean, readable, and concise, and it does precisely what we intended it to do: create an algebraic data type for an immutable n-vector that supports the basic vector operations. And we did the whole thing without needing any imperative constructs like state or loops—pure functional programming.\n\n## Case Study 4: `vector_field`\n\nFor the final case study, instead of me writing the code, and you looking at it, you'll be writing the code—of course, I won't be looking at it, but I will show you how I would have done it after you give it a shot by yourself.\n\n_The bonus challenge for this section is to write each of the functions we'll be defining in just one line. Try using assignment functions to help with that!_\n\nFirst, let's introduce the general goal of this case study. We want to write a program that will allow us to produce infinite vector fields that we can iterate over and apply operations to. And in our case, we'll say we only care about vectors with positive components.\n\nOur first step, therefore, is going to be creating a field of all the points with positive `x` and `y` values—that is, the first quadrant of the `x-y` plane, which looks something like this:\n```\n...\n\n(0,2)   ...\n\n(0,1)   (1,1)   ...\n\n(0,0)   (1,0)   (2,0)   ...\n```\n\nBut since we want to be able to iterate over that plane, we're going to need to linearize it somehow, and the easiest way to do that is to split it up into diagonals, and traverse the first diagonal, then the second diagonal, and so on, like this:\n```\n(0, 0), (1, 0), (0, 1), (2, 0), (1, 1), (0, 2), ...\n```\n\n### `diagonal_line`\n\nThus, our first function `diagonal_line(n)` should construct an iterator of all the points, represented as coordinate tuples, in the `n`th diagonal, starting with `(0, 0)` as the `0`th diagonal. Like we said at the start of this case study, this is where we I let go and you take over. Using all the tools of functional programming that Coconut provides, give `diagonal_line` a shot. When you're ready to move on, scroll down.\n\nHere are some tests that you can use:\n```coconut\ndiagonal_line(0) `isinstance` (list, tuple) |> print  # False (should be an iterator)\ndiagonal_line(0) |> list |> print  # [(0, 0)]\ndiagonal_line(1) |> list |> print  # [(0, 1), (1, 0)]\n```\n\n_Hint: the `n`th diagonal should contain `n+1` elements, so try starting with `range(n+1)` and then transforming it in some way._\n\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n\nThat wasn't so bad, now was it? Now, let's take a look at my solution:\n```coconut\ndef diagonal_line(n) = range(n+1) |> map$(i => (i, n-i))\n```\nPretty simple, huh? We take `range(n+1)`, and use `map` to transform it into the right sequence of tuples.\n\n### `linearized_plane`\n\nNow that we've created our diagonal lines, we need to join them together to make the full linearized plane, and to do that we're going to write the function `linearized_plane()`. `linearized_plane` should produce an iterator that goes through all the points in the plane, in order of all the points in the first `diagonal(0)`, then the second `diagonal(1)`, and so on. `linearized_plane` is going to be, by necessity, an infinite iterator, since it needs to loop through all the points in the plane, which have no end. To help you accomplish this, remember that the `::` operator is lazy, and won't evaluate its operands until they're needed, which means it can be used to construct infinite iterators. When you're ready to move on, scroll down.\n\nTests:\n```coconut\n# Note: these tests use $[] notation, which we haven't introduced yet\n#  but will introduce later in this case study; for now, just run the\n#  tests, and make sure you get the same result as is in the comment\nlinearized_plane()$[0] |> print  # (0, 0)\nlinearized_plane()$[:3] |> list |> print  # [(0, 0), (0, 1), (1, 0)]\n```\n\n_Hint: instead of defining the function as `linearized_plane()`, try defining it as `linearized_plane(n=0)`, where `n` is the diagonal to start at, and use recursion to build up from there._\n\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n\nThat was a little bit rougher than the first one, but hopefully still not too bad. Let's compare to my solution:\n```coconut\ndef linearized_plane(n=0) = diagonal_line(n) :: linearized_plane(n+1)\n```\nAs you can see, it's a very fundamentally simple solution: just use `::` and recursion to join all the diagonals together in order.\n\n### `vector_field`\n\nNow that we have a function that builds up all the points we need, it's time to turn them into vectors, and to do that we'll define the new function `vector_field()`, which should turn all the tuples in `linearized_plane` into vectors, using the n-vector class we defined earlier.\n\nTests:\n```coconut\n# You'll need to bring in the vector class from earlier to make these work\nvector_field()$[0] |> print  # vector(*pts=(0, 0))\nvector_field()$[2:3] |> list |> print  # [vector(*pts=(1, 0))]\n```\n\n_Hint: Remember, the way we defined vector it takes the components as separate arguments, not a single tuple. You may find the [Coconut built-in `starmap`](./DOCS.md#starmap) useful in dealing with that._\n\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n\nWe're making good progress! Before we move on, check your solution against mine:\n```coconut\ndef vector_field() = linearized_plane() |> starmap$(vector)\n```\nAll we're doing is taking our `linearized_plane` and mapping `vector` over it, but using `starmap` instead of `map` so that `vector` gets called with each element of the tuple as a separate argument.\n\n### Applications\n\nNow that we've built all the functions we need for our vector field, it's time to put it all together and test it. Feel free to substitute in your versions of the functions below:\n```coconut\ndata vector(*pts):\n    \"\"\"Immutable n-vector.\"\"\"\n    def __new__(cls, *pts):\n        \"\"\"Create a new vector from the given pts.\"\"\"\n        match [v `isinstance` vector] in pts:\n            return v  # vector(v) where v is a vector should return v\n        else:\n            return pts |*> makedata$(cls)  # accesses base constructor\n    def __abs__(self) =\n        \"\"\"Return the magnitude of the vector.\"\"\"\n        self.pts |> map$(.**2) |> sum |> (.**0.5)\n    def __add__(self, vector(*other_pts)\n                if len(other_pts) == len(self.pts)) =\n        \"\"\"Add two vectors together.\"\"\"\n        map((+), self.pts, other_pts) |*> vector\n    def __sub__(self, vector(*other_pts)\n                if len(other_pts) == len(self.pts)) =\n        \"\"\"Subtract one vector from another.\"\"\"\n        map((-), self.pts, other_pts) |*> vector\n    def __neg__(self) =\n        \"\"\"Retrieve the negative of the vector.\"\"\"\n        self.pts |> map$(-) |*> vector\n    def __mul__(self, other):\n        \"\"\"Scalar multiplication and dot product.\"\"\"\n        match vector(*other_pts) in other:\n            assert len(other_pts) == len(self.pts)\n            return map((*), self.pts, other_pts) |> sum  # dot product\n        else:\n            return self.pts |> map$(.*other) |*> vector  # scalar multiplication\n    def __rmul__(self, other) =\n        \"\"\"Necessary to make scalar multiplication commutative.\"\"\"\n        self * other\n\ndef diagonal_line(n) = range(n+1) |> map$(i => (i, n-i))\ndef linearized_plane(n=0) = diagonal_line(n) :: linearized_plane(n+1)\ndef vector_field() = linearized_plane() |> starmap$(vector)\n\n# Test cases:\ndiagonal_line(0) `isinstance` (list, tuple) |> print  # False (should be an iterator)\ndiagonal_line(0) |> list |> print  # [(0, 0)]\ndiagonal_line(1) |> list |> print  # [(0, 1), (1, 0)]\nlinearized_plane()$[0] |> print  # (0, 0)\nlinearized_plane()$[:3] |> list |> print  # [(0, 0), (0, 1), (1, 0)]\nvector_field()$[0] |> print  # vector(*pts=(0, 0))\nvector_field()$[2:3] |> list |> print  # [vector(*pts=(1, 0))]\n```\n\nCopy, paste! Once you've made sure everything is working correctly if you substituted in your own functions, take a look at the last 4 tests. You'll notice that they use a new notation, similar to the notation for partial application we saw earlier, but with brackets instead of parentheses. This is the notation for iterator slicing. Similar to how partial application was lazy function calling, iterator slicing is _lazy sequence slicing_. Like with partial application, it is helpful to think of `$` as the _lazy-ify_ operator, in this case turning normal Python slicing, which is evaluated immediately, into lazy iterator slicing, which is evaluated only when the elements in the slice are needed.\n\nWith that in mind, now that we've built our vector field, it's time to use iterator slicing to play around with it. Try doing something cool to our vector fields like\n- create a `magnitude_field` where each point is that vector's magnitude\n- combine entire vector fields together with `map` and the vector addition and multiplication methods we wrote earlier\n\nthen use iterator slicing to take out portions and examine them.\n\n## Case Study 5: `vector` Part II\n\nFor the some of the applications you might want to use your `vector_field` for, it might be desirable to add some useful methods to our `vector`. In this case study, we're going to be focusing on one in particular: `.angle`.\n\n`.angle` will take one argument, another vector, and compute the angle between the two vectors. Mathematically, the formula for the angle between two vectors is the dot product of the vectors' respective unit vectors. Thus, before we can implement `.angle`, we're going to need `.unit`. Mathematically, the formula for the unit vector of a given vector is that vector divided by its magnitude. Thus, before we can implement `.unit`, and by extension `.angle`, we'll need to start by implementing division.\n\n### `__truediv__`\n\nVector division is just scalar division, so we're going to write a `__truediv__` method that takes `self` as the first argument and `other` as the second argument, and returns a new vector the same size as `self` with every element divided by `other`. For an extra challenge, try writing this one in one line using assignment function notation.\n\nTests:\n```coconut\nvector(3, 4) / 1 |> print  # vector(*pts=(3.0, 4.0))\nvector(2, 4) / 2 |> print  # vector(*pts=(1.0, 2.0))\n```\n\n_Hint: Look back at how we implemented scalar multiplication._\n\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n\nHere's my solution for you to check against:\n```coconut\n    def __truediv__(self, other) = self.pts |> map$(x => x/other) |*> vector\n```\n\n### `.unit`\n\nNext up, `.unit`. We're going to write a `unit` method that takes just `self` as its argument and returns a new vector the same size as `self` with each element divided by the magnitude of `self`, which we can retrieve with `abs`. This should be a very simple one-line function.\n\nTests:\n```coconut\nvector(0, 1).unit() |> print  # vector(*pts=(0.0, 1.0))\nvector(5, 0).unit() |> print  # vector(*pts=(1.0, 0.0))\n```\n\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n\nHere's my solution:\n```coconut\n    def unit(self) = self / abs(self)\n```\n\n### `.angle`\n\nThis one is going to be a little bit more complicated. For starters, the mathematical formula for the angle between two vectors is the `math.acos` of the dot product of those vectors' respective unit vectors, and recall that we already implemented the dot product of two vectors when we wrote `__mul__`. So, `.angle` should take `self` as the first argument and `other` as the second argument, and if `other` is a vector, use that formula to compute the angle between `self` and `other`, or if `other` is not a vector, `.angle` should raise a `MatchError`. To accomplish this, we're going to want to use destructuring assignment to check that `other` is indeed a `vector`.\n\nTests:\n```coconut\nimport math\nvector(2, 0).angle(vector(3, 0)) |> print  # 0.0\nprint(vector(1, 0).angle(vector(0, 2)), math.pi/2)  # should be the same\nvector(1, 2).angle(5)  # MatchError\n```\n\n_Hint: Look back at how we checked whether the argument to `factorial` was an integer using pattern-matching._\n\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n\nHere's my solution—take a look:\n```coconut\n    def angle(self, other `isinstance` vector) = math.acos(self.unit() * other.unit())\n```\n\nAnd now it's time to put it all together. Feel free to substitute in your own versions of the methods we just defined.\n\n```coconut\nimport math  # necessary for math.acos in .angle\n\ndata vector(*pts):\n    \"\"\"Immutable n-vector.\"\"\"\n    def __new__(cls, *pts):\n        \"\"\"Create a new vector from the given pts.\"\"\"\n        match [v `isinstance` vector] in pts:\n            return v  # vector(v) where v is a vector should return v\n        else:\n            return pts |*> makedata$(cls)  # accesses base constructor\n    def __abs__(self) =\n        \"\"\"Return the magnitude of the vector.\"\"\"\n        self.pts |> map$(.**2) |> sum |> (.**0.5)\n    def __add__(self, vector(*other_pts)\n                if len(other_pts) == len(self.pts)) =\n        \"\"\"Add two vectors together.\"\"\"\n        map((+), self.pts, other_pts) |*> vector\n    def __sub__(self, vector(*other_pts)\n                if len(other_pts) == len(self.pts)) =\n        \"\"\"Subtract one vector from another.\"\"\"\n        map((-), self.pts, other_pts) |*> vector\n    def __neg__(self) =\n        \"\"\"Retrieve the negative of the vector.\"\"\"\n        self.pts |> map$(-) |*> vector\n    def __mul__(self, other):\n        \"\"\"Scalar multiplication and dot product.\"\"\"\n        match vector(*other_pts) in other:\n            assert len(other_pts) == len(self.pts)\n            return map((*), self.pts, other_pts) |> sum  # dot product\n        else:\n            return self.pts |> map$(.*other) |*> vector  # scalar multiplication\n    def __rmul__(self, other) =\n        \"\"\"Necessary to make scalar multiplication commutative.\"\"\"\n        self * other\n    # New one-line functions necessary for finding the angle between vectors:\n    def __truediv__(self, other) = self.pts |> map$(x => x/other) |*> vector\n    def unit(self) = self / abs(self)\n    def angle(self, other `isinstance` vector) = math.acos(self.unit() * other.unit())\n\n# Test cases:\nvector(3, 4) / 1 |> print  # vector(*pts=(3.0, 4.0))\nvector(2, 4) / 2 |> print  # vector(*pts=(1.0, 2.0))\nvector(0, 1).unit() |> print  # vector(*pts=(0.0, 1.0))\nvector(5, 0).unit() |> print  # vector(*pts=(1.0, 0.0))\nvector(2, 0).angle(vector(3, 0)) |> print  # 0.0\nprint(vector(1, 0).angle(vector(0, 2)), math.pi/2)  # should be the same\nvector(1, 2).angle(5)  # MatchError\n```\n_One note of warning here: be careful not to leave a blank line when substituting in your methods, or the interpreter will cut off the code for the `vector` there. This isn't a problem in normal Coconut code, only here because we're copy-and-pasting into the command line._\n\nCopy, paste! If everything is working, you can try going back to playing around with `vector_field` [applications](#applications) using our new methods.\n\n## Filling in the Gaps\n\nAnd with that, this tutorial is out of case studies—but that doesn't mean Coconut is out of features! In this last section, we'll touch on some of the other useful features of Coconut that we managed to miss in the case studies.\n\n### Lazy Lists\n\nFirst up is lazy lists. Lazy lists are lazily-evaluated lists, similar in their laziness to Coconut's `::` operator, in that any expressions put inside a lazy list won't be evaluated until that element of the lazy list is needed. The syntax for lazy lists is exactly the same as the syntax for normal lists, but with \"banana brackets\" (`(|` and `|)`) instead of normal brackets, like so:\n```coconut\nabc = (| a, b, c |)\n```\n\nUnlike Python iterators, lazy lists can be iterated over multiple times and still return the same result.\n\nUnlike Python lists, however, using a lazy list, it is possible to define the values used in the following expressions as needed without raising a `NameError`:\n\n```coconut\nabcd = (| d(a), d(b), d(c) |)  # a, b, c, and d are not defined yet\ndef d(n) = n + 1\n\na = 1\nabcd$[0]\nb = 2\nabcd$[1]\nc = 3\nabcd$[2]\n```\n\n### Function Composition\n\nNext is function composition. In Coconut, this is primarily accomplished through the `f1 ..> f2` operator, which takes two functions and composes them, creating a new function equivalent to `(*args, **kwargs) => f2(f1(*args, **kwargs))`. This can be useful in combination with partial application for piecing together multiple higher-order functions, like so:\n```coconut\nzipsum = zip ..> map$(sum)\n```\n\n_While `..>` is generally preferred, if you'd rather use the more traditional mathematical function composition ordering, you can get that with the `<..` operator._\n\nIf the composed functions are wrapped in parentheses, arguments can be passed into them:\n```coconut\ndef plus1(x) = x + 1\ndef square(x) = x * x\n\n(square ..> plus1)(3) == 10  # True\n```\n\nFunctions of different arities can be composed together, as long as they are in the correct order. If they are in the incorrect order, a `TypeError` will be raised. In this example we will compose a unary function with a binary function:\n```coconut\ndef add(n, m) = n + m  # binary function\ndef square(n) = n * n  # unary function\n\n(square ..> add)(3, 1)    # Raises TypeError: square() takes exactly 1 argument (2 given)\n(add ..> square)(3, 1)    # 16\n```\n\nAnother useful trick with function composition involves composing a function with a higher-order function:\n```coconut\ndef inc_or_dec(t):\n    # Our higher-order function, which returns another function\n    if t:\n        return x => x+1\n    else:\n        return x => x-1\n\ndef square(n) = n * n\n\nsquare_inc = inc_or_dec(True) ..> square\nsquare_dec = inc_or_dec(False) ..> square\nsquare_inc(4)  # 25\nsquare_dec(4)  # 9\n\n```\n\n_Note: Coconut also supports the function composition operators `..`, `..*>`, `<*..`, `..**>`, and `<**..`._\n\n### Implicit Partials\n\nAnother useful Coconut feature is implicit partials. Coconut supports a number of different \"incomplete\" expressions that will evaluate to a function that takes in the part necessary to complete them, that is, an implicit partial application function. The different allowable expressions are:\n```coconut\n.attr\n.method(args)\nfunc$\nseq[]\niter$[]\n.[slice]\n.$[slice]\n```\n\nFor a full explanation of what each implicit partial does, see Coconut's documentation on [implicit partials](./DOCS.md#implicit-partial-application).\n\n### Type Annotations\n\nFor many people, one of the big downsides of Python is the fact that it is dynamically-typed. In Python, this problem is addressed by [MyPy](http://mypy-lang.org/), a static type analyzer for Python, which can check Python-3-style type annotations such as\n```coconut_python\ndef plus1(x: int) -> int:\n    return x + 1\na: int = plus1(10)\n```\n\nUnfortunately, in Python, such type annotation syntax only exists in Python 3. Not to worry in Coconut, however, which compiles Python-3-style type annotations to universally compatible type comments. Not only that, but Coconut has built-in [MyPy integration](./DOCS.md#mypy-integration) for automatically type-checking your code, and its own [enhanced type annotation syntax](./DOCS.md#enhanced-type-annotation) for more easily expressing complex types, like so:\n```coconut\ndef int_map(\n    f: int -> int,\n    xs: int[],\n) -> int[] =\n    xs |> map$(f) |> list\n```\n\n### Further Reading\n\nAnd that's it for this tutorial! But that's hardly it for Coconut. All of the features examined in this tutorial, as well as a bunch of others, are detailed in Coconut's [documentation](./DOCS.md).\n\nAlso, if you have any other questions not covered in this tutorial, feel free to ask around at Coconut's [Gitter](https://gitter.im/evhub/coconut), a GitHub-integrated chat room for Coconut developers.\n\nFinally, Coconut is a new, growing language, and if you'd like to get involved in the development of Coconut, all the code is available completely open-source on Coconut's [GitHub](https://github.com/evhub/coconut). Contributing is a simple as forking the code, making your changes, and proposing a pull request! See Coconuts [contributing guidelines](./CONTRIBUTING.md) for more information.\n"
        },
        {
          "name": "LICENSE.txt",
          "type": "blob",
          "size": 11.091796875,
          "content": "\n                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"[]\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright [yyyy] [name of copyright owner]\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "MANIFEST.in",
          "type": "blob",
          "size": 0.458984375,
          "content": "global-include *.py\nglobal-include *.pyi\nglobal-include *.py_template\nglobal-include *.pth\nglobal-include *.txt\nglobal-include *.rst\nglobal-include *.md\nglobal-include *.json\nglobal-include *.toml\nglobal-include *.coco\nglobal-include *.ini\nglobal-include py.typed\nprune coconut/tests/dest\nprune docs\nprune pyston\nprune pyprover\nprune bbopt\nprune coconut-prelude\nprune .mypy_cache\nprune .pytest_cache\nprune *.egg-info\nprune .github\nexclude index.rst\nexclude profile.json\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 13.826171875,
          "content": "# the main test command to use when developing rapidly\n.PHONY: test\ntest: test-mypy\n\n# same as test, but for testing only changes to the tests\n.PHONY: test-tests\ntest-tests: test-mypy-tests\n\n.PHONY: dev\ndev: clean setup\n\tpython -m pip install --upgrade -e .[dev]\n\tpre-commit install -f --install-hooks\n\tcoconut --site-install\n\n.PHONY: dev-py2\ndev-py2: clean setup-py2\n\tpython2 -m pip install --upgrade -e .[dev]\n\tcoconut --site-install\n\n.PHONY: dev-py3\ndev-py3: clean setup-py3\n\tpython3 -m pip install --upgrade -e .[dev]\n\tpre-commit install -f --install-hooks\n\tcoconut --site-install\n\n.PHONY: setup\nsetup:\n\t-python -m ensurepip\n\tpython -m pip install --upgrade setuptools wheel pip cython\n\n.PHONY: setup-py2\nsetup-py2:\n\t-python2 -m ensurepip\n\tpython2 -m pip install --upgrade \"setuptools<58\" wheel pip cython\n\n.PHONY: setup-py3\nsetup-py3:\n\t-python3 -m ensurepip\n\tpython3 -m pip install --upgrade setuptools wheel pip cython\n\n.PHONY: setup-pypy\nsetup-pypy:\n\t-pypy -m ensurepip\n\tpypy -m pip install --upgrade \"setuptools<58\" wheel pip\n\n.PHONY: setup-pypy3\nsetup-pypy3:\n\t-pypy3 -m ensurepip\n\tpypy3 -m pip install --upgrade setuptools wheel pip\n\n.PHONY: install\ninstall: setup\n\tpython -m pip install -e .[tests]\n\n.PHONY: install-purepy\ninstall-purepy: setup\n\tpython -m pip install --no-deps --upgrade -e . \"pyparsing<3\"\n\n.PHONY: install-py2\ninstall-py2: setup-py2\n\tpython2 -m pip install -e .[tests]\n\n.PHONY: install-py3\ninstall-py3: setup-py3\n\tpython3 -m pip install -e .[tests]\n\n.PHONY: install-pypy\ninstall-pypy: setup-pypy\n\tpypy -m pip install -e .[tests]\n\n.PHONY: install-pypy3\ninstall-pypy3: setup-pypy3\n\tpypy3 -m pip install -e .[tests]\n\n.PHONY: format\nformat: dev\n\tpre-commit autoupdate\n\tpre-commit run --all-files\n\n# test-all takes a very long time and should usually only be run by CI\n.PHONY: test-all\ntest-all: clean\n\tpytest --strict-markers -s ./coconut/tests\n\n# basic testing for the universal target\n.PHONY: test-univ\ntest-univ: export COCONUT_USE_COLOR=TRUE\ntest-univ: clean\n\tpython ./coconut/tests --strict --keep-lines --force\n\tpython ./coconut/tests/dest/runner.py\n\tpython ./coconut/tests/dest/extras.py\n\n# same as test-univ, but doesn't recompile unchanged test files;\n# should only be used when testing the tests not the compiler\n.PHONY: test-univ-tests\ntest-univ-tests: export COCONUT_USE_COLOR=TRUE\ntest-univ-tests: clean-no-tests\n\tpython ./coconut/tests --strict --keep-lines\n\tpython ./coconut/tests/dest/runner.py\n\tpython ./coconut/tests/dest/extras.py\n\n# same as test-univ but uses Python 2\n.PHONY: test-py2\ntest-py2: export COCONUT_USE_COLOR=TRUE\ntest-py2: clean\n\tpython2 ./coconut/tests --strict --keep-lines --force\n\tpython2 ./coconut/tests/dest/runner.py\n\tpython2 ./coconut/tests/dest/extras.py\n\n# same as test-univ but uses Python 3 and --target 3\n.PHONY: test-py3\ntest-py3: export COCONUT_USE_COLOR=TRUE\ntest-py3: clean\n\tpython3 ./coconut/tests --strict --keep-lines --force --target 3\n\tpython3 ./coconut/tests/dest/runner.py\n\tpython3 ./coconut/tests/dest/extras.py\n\n# same as test-univ but uses PyPy\n.PHONY: test-pypy\ntest-pypy: export COCONUT_USE_COLOR=TRUE\ntest-pypy: clean\n\tpypy ./coconut/tests --strict --keep-lines --force\n\tpypy ./coconut/tests/dest/runner.py\n\tpypy ./coconut/tests/dest/extras.py\n\n# same as test-univ but uses PyPy3\n.PHONY: test-pypy3\ntest-pypy3: export COCONUT_USE_COLOR=TRUE\ntest-pypy3: clean\n\tpypy3 ./coconut/tests --strict --keep-lines --force\n\tpypy3 ./coconut/tests/dest/runner.py\n\tpypy3 ./coconut/tests/dest/extras.py\n\n# same as test-univ but reverses any ofs\n.PHONY: test-any-of\ntest-any-of: export COCONUT_ADAPTIVE_ANY_OF=TRUE\ntest-any-of: export COCONUT_REVERSE_ANY_OF=TRUE\ntest-any-of: test-univ\n\n# same as test-univ but also runs mypy\n.PHONY: test-mypy-univ\ntest-mypy-univ: export COCONUT_USE_COLOR=TRUE\ntest-mypy-univ: clean\n\tpython ./coconut/tests --strict --keep-lines --force --no-cache --mypy --follow-imports silent --ignore-missing-imports --allow-redefinition\n\tpython ./coconut/tests/dest/runner.py\n\tpython ./coconut/tests/dest/extras.py\n\n# same as test-mypy-univ but uses --target sys\n.PHONY: test-mypy\ntest-mypy: export COCONUT_USE_COLOR=TRUE\ntest-mypy: clean\n\tpython ./coconut/tests --strict --keep-lines --force --target sys --no-cache --mypy --follow-imports silent --ignore-missing-imports --allow-redefinition\n\tpython ./coconut/tests/dest/runner.py\n\tpython ./coconut/tests/dest/extras.py\n\n# same as test-mypy but doesn't use --force\n.PHONY: test-mypy-tests\ntest-mypy-tests: export COCONUT_USE_COLOR=TRUE\ntest-mypy-tests: clean-no-tests\n\tpython ./coconut/tests --strict --keep-lines --target sys --mypy --follow-imports silent --ignore-missing-imports --allow-redefinition\n\tpython ./coconut/tests/dest/runner.py\n\tpython ./coconut/tests/dest/extras.py\n\n# same as test-mypy but uses pyright instead\n.PHONY: test-pyright\ntest-pyright: export COCONUT_USE_COLOR=TRUE\ntest-pyright: clean\n\tpython ./coconut/tests --strict --keep-lines --force --target sys --no-cache --pyright\n\tpython ./coconut/tests/dest/runner.py\n\tpython ./coconut/tests/dest/extras.py\n\n# same as test-univ but includes verbose output for better debugging\n#  regex for getting non-timing lines: ^(?!'|\\s*(Time|Packrat|Loaded|Saving|Adaptive|Errorless|Grammar|Failed|Incremental|Pruned|Compiled)\\s)[^\\n]*\\n*\n.PHONY: test-verbose\ntest-verbose: export COCONUT_USE_COLOR=TRUE\ntest-verbose: clean\n\tpython ./coconut/tests --strict --keep-lines --force --verbose\n\tpython ./coconut/tests/dest/runner.py\n\tpython ./coconut/tests/dest/extras.py\n\n# same as test-verbose but reuses the incremental cache\n.PHONY: test-verbose-cache\ntest-verbose-cache: export COCONUT_USE_COLOR=TRUE\ntest-verbose-cache: clean-no-tests\n\tpython ./coconut/tests --strict --keep-lines --force --verbose\n\tpython ./coconut/tests/dest/runner.py\n\tpython ./coconut/tests/dest/extras.py\n\n# same as test-verbose but doesn't use the incremental cache\n.PHONY: test-verbose-no-cache\ntest-verbose-no-cache: export COCONUT_USE_COLOR=TRUE\ntest-verbose-no-cache: clean\n\tpython ./coconut/tests --strict --keep-lines --force --verbose --no-cache\n\tpython ./coconut/tests/dest/runner.py\n\tpython ./coconut/tests/dest/extras.py\n\n# same as test-verbose but is fully synchronous\n.PHONY: test-verbose-sync\ntest-verbose-sync: export COCONUT_USE_COLOR=TRUE\ntest-verbose-sync: clean\n\tpython ./coconut/tests --strict --keep-lines --force --verbose --jobs 0\n\tpython ./coconut/tests/dest/runner.py\n\tpython ./coconut/tests/dest/extras.py\n\n# same as test-mypy but uses --verbose\n.PHONY: test-mypy-verbose\ntest-mypy-verbose: export COCONUT_USE_COLOR=TRUE\ntest-mypy-verbose: clean\n\tpython ./coconut/tests --strict --keep-lines --force --target sys --verbose --mypy --follow-imports silent --ignore-missing-imports --allow-redefinition\n\tpython ./coconut/tests/dest/runner.py\n\tpython ./coconut/tests/dest/extras.py\n\n# same as test-mypy but uses --check-untyped-defs\n.PHONY: test-mypy-all\ntest-mypy-all: export COCONUT_USE_COLOR=TRUE\ntest-mypy-all: clean\n\tpython ./coconut/tests --strict --keep-lines --force --target sys --no-cache --mypy --follow-imports silent --ignore-missing-imports --allow-redefinition --check-untyped-defs\n\tpython ./coconut/tests/dest/runner.py\n\tpython ./coconut/tests/dest/extras.py\n\n# same as test-univ but also tests easter eggs\n.PHONY: test-easter-eggs\ntest-easter-eggs: export COCONUT_USE_COLOR=TRUE\ntest-easter-eggs: clean\n\tpython ./coconut/tests --strict --keep-lines --force\n\tpython ./coconut/tests/dest/runner.py --test-easter-eggs\n\tpython ./coconut/tests/dest/extras.py\n\n# same as test-univ but uses python pyparsing\n.PHONY: test-purepy\ntest-purepy: export COCONUT_PURE_PYTHON=TRUE\ntest-purepy: test-univ\n\n# same as test-univ but disables the computation graph\n.PHONY: test-no-computation-graph\ntest-no-computation-graph: export COCONUT_USE_COMPUTATION_GRAPH=FALSE\ntest-no-computation-graph: test-univ\n\n# same as test-univ but uses --minify\n.PHONY: test-minify\ntest-minify: export COCONUT_USE_COLOR=TRUE\ntest-minify: clean\n\tpython ./coconut/tests --strict --keep-lines --force --minify\n\tpython ./coconut/tests/dest/runner.py\n\tpython ./coconut/tests/dest/extras.py\n\n# same as test-univ but uses --no-wrap\n.PHONY: test-no-wrap\ntest-no-wrap: export COCONUT_USE_COLOR=TRUE\ntest-no-wrap: clean\n\tpython ./coconut/tests --strict --keep-lines --force --no-wrap\n\tpython ./coconut/tests/dest/runner.py\n\tpython ./coconut/tests/dest/extras.py\n\n# same as test-univ but watches tests before running them\n.PHONY: test-watch\ntest-watch: export COCONUT_USE_COLOR=TRUE\ntest-watch: clean\n\tpython ./coconut/tests --strict --keep-lines --force\n\tmake just-watch\n\tpython ./coconut/tests/dest/runner.py\n\tpython ./coconut/tests/dest/extras.py\n\n# just watches tests\n.PHONY: just-watch\njust-watch: export COCONUT_USE_COLOR=TRUE\njust-watch:\n\tcoconut ./coconut/tests/src/cocotest/agnostic ./coconut/tests/dest/cocotest --watch --strict --keep-lines --stack-size 4096 --recursion-limit 4096\n\n# same as just-watch but uses verbose output and is fully sychronous and doesn't use the cache\n.PHONY: just-watch-verbose\njust-watch-verbose: export COCONUT_USE_COLOR=TRUE\njust-watch-verbose:\n\tcoconut ./coconut/tests/src/cocotest/agnostic ./coconut/tests/dest/cocotest --watch --strict --keep-lines --stack-size 4096 --recursion-limit 4096 --verbose --jobs 0 --no-cache\n\n# mini test that just compiles agnostic tests\n.PHONY: test-mini\ntest-mini: export COCONUT_USE_COLOR=TRUE\ntest-mini:\n\tcoconut ./coconut/tests/src/cocotest/agnostic ./coconut/tests/dest/cocotest --force --stack-size 4096 --recursion-limit 4096\n\n# same as test-mini but with verbose output\n.PHONY: test-mini-verbose\ntest-mini-verbose: export COCONUT_USE_COLOR=TRUE\ntest-mini-verbose:\n\tcoconut ./coconut/tests/src/cocotest/agnostic ./coconut/tests/dest/cocotest --force --verbose --stack-size 4096 --recursion-limit 4096\n\n# same as test-mini-verbose but doesn't overwrite the cache\n.PHONY: test-mini-cache\ntest-mini-cache: export COCONUT_ALLOW_SAVE_TO_CACHE=FALSE\ntest-mini-cache: test-mini-verbose\n\n# same as test-mini-verbose but with fully synchronous output and fast failing\n.PHONY: test-mini-sync\ntest-mini-sync: export COCONUT_USE_COLOR=TRUE\ntest-mini-sync:\n\tcoconut ./coconut/tests/src/cocotest/agnostic ./coconut/tests/dest/cocotest --force --verbose --jobs 0 --fail-fast --stack-size 4096 --recursion-limit 4096\n\n# same as test-univ but debugs crashes\n.PHONY: test-univ-debug\ntest-univ-debug: export COCONUT_TEST_DEBUG_PYTHON=TRUE\ntest-univ-debug: test-univ\n\n# same as test-mini but debugs crashes, is fully synchronous, and doesn't use verbose output\n.PHONY: test-mini-debug\ntest-mini-debug: export COCONUT_USE_COLOR=TRUE\ntest-mini-debug:\n\tpython -X dev -m coconut ./coconut/tests/src/cocotest/agnostic ./coconut/tests/dest/cocotest --strict --keep-lines --force --jobs 0 --stack-size 4096 --recursion-limit 4096\n\n# same as test-mini-debug but uses vanilla pyparsing\n.PHONY: test-mini-debug-purepy\ntest-mini-debug-purepy: export COCONUT_PURE_PYTHON=TRUE\ntest-mini-debug-purepy: test-mini-debug\n\n.PHONY: debug-test-crash\ndebug-test-crash:\n\tpython -X dev ./coconut/tests/dest/runner.py\n\n.PHONY: diff\ndiff:\n\tgit diff origin/develop\n\n.PHONY: fix-develop\nfix-develop:\n\tgit merge master -s ours\n\n.PHONY: docs\ndocs: clean\n\tsphinx-build -b html . ./docs\n\trm -f index.rst\n\n.PHONY: clean-no-tests\nclean-no-tests:\n\trm -rf ./docs ./dist ./build ./bbopt ./pyprover ./pyston ./coconut-prelude index.rst ./.mypy_cache\n\n.PHONY: clean\nclean: clean-no-tests\n\trm -rf ./coconut/tests/dest\n\t-find . -name \"__coconut_cache__\" -type d -prune -exec rm -rf '{}' +\n\t-powershell -Command \"get-childitem -Include __coconut_cache__ -Recurse -force | Remove-Item -Force -Recurse\"\n\n.PHONY: wipe\nwipe: clean\n\trm -rf ./coconut/tests/dest vprof.json profile.log *.egg-info\n\t-find . -name \"__pycache__\" -type d -prune -exec rm -rf '{}' +\n\t-powershell -Command \"get-childitem -Include __pycache__ -Recurse -force | Remove-Item -Force -Recurse\"\n\t-find . -name \"*.pyc\" -delete\n\t-powershell -Command \"get-childitem -Include *.pyc -Recurse -force | Remove-Item -Force -Recurse\"\n\t-python -m coconut --site-uninstall\n\t-python3 -m coconut --site-uninstall\n\t-python2 -m coconut --site-uninstall\n\t-pip uninstall coconut\n\t-pip uninstall coconut-develop\n\t-pip3 uninstall coconut\n\t-pip3 uninstall coconut-develop\n\t-pip2 uninstall coconut\n\t-pip2 uninstall coconut-develop\n\n.PHONY: build\nbuild:\n\tpython setup.py sdist bdist_wheel\n\n.PHONY: just-upload\njust-upload: build\n\tpip install --upgrade --ignore-installed twine\n\ttwine upload dist/* -u __token__\n\n.PHONY: upload\nupload: wipe dev just-upload\n\n.PHONY: check-reqs\ncheck-reqs:\n\tpython ./coconut/requirements.py\n\n.PHONY: profile\nprofile: export COCONUT_USE_COLOR=TRUE\nprofile:\n\tcoconut ./coconut/tests/src/cocotest/agnostic/util.coco ./coconut/tests/dest/cocotest --force --verbose --profile --stack-size 4096 --recursion-limit 4096 2>&1 | tee ./profile.log\n\n.PHONY: open-speedscope\nopen-speedscope:\n\tnpm install -g speedscope\n\tspeedscope ./profile.speedscope\n\n.PHONY: pyspy\npyspy:\n\tpy-spy record -o profile.speedscope --format speedscope --subprocesses --rate 75 -- python -m coconut ./coconut/tests/src/cocotest/agnostic ./coconut/tests/dest/cocotest --force\n\tmake open-speedscope\n\n.PHONY: pyspy-purepy\npyspy-purepy: export COCONUT_PURE_PYTHON=TRUE\npyspy-purepy: pyspy\n\n.PHONY: pyspy-native\npyspy-native:\n\tpy-spy record -o profile.speedscope --format speedscope --native --rate 75 -- python -m coconut ./coconut/tests/src/cocotest/agnostic ./coconut/tests/dest/cocotest --force --jobs 0\n\tmake open-speedscope\n\n.PHONY: pyspy-runtime\npyspy-runtime:\n\tpy-spy record -o runtime_profile.speedscope --format speedscope -- python ./coconut/tests/dest/runner.py\n\tspeedscope ./runtime_profile.speedscope\n\n.PHONY: vprof-time\nvprof-time:\n\tvprof -c h \"./coconut ./coconut/tests/src/cocotest/agnostic ./coconut/tests/dest/cocotest --force --jobs 0 --stack-size 4096 --recursion-limit 4096\" --output-file ./vprof.json\n\tmake view-vprof\n\n.PHONY: vprof-memory\nvprof-memory:\n\tvprof -c m \"./coconut ./coconut/tests/src/cocotest/agnostic ./coconut/tests/dest/cocotest --force --jobs 0 --stack-size 4096 --recursion-limit 4096\" --output-file ./vprof.json\n\tmake view-vprof\n\n.PHONY: view-vprof\nview-vprof:\n\tvprof --input-file ./vprof.json\n"
        },
        {
          "name": "README.rst",
          "type": "blob",
          "size": 3.4853515625,
          "content": "|logo| Coconut\n==============\n\n..\n    <insert toctree here>\n\n.. |logo| image:: https://github.com/evhub/coconut/raw/gh-pages/favicon-32x32.png\n\n.. image:: https://opencollective.com/coconut/backers/badge.svg\n    :alt: Backers on Open Collective\n    :target: #backers\n.. image:: https://opencollective.com/coconut/sponsors/badge.svg\n    :alt: Sponsors on Open Collective\n    :target: #sponsors\n.. image:: https://badges.gitter.im/evhub/coconut.svg\n    :alt: Join the chat at https://gitter.im/evhub/coconut\n    :target: https://gitter.im/evhub/coconut?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge\n\nCoconut (`coconut-lang.org`__) is a variant of Python_ that **adds on top of Python syntax** new features for simple, elegant, Pythonic **functional programming**.\n\n__ Coconut_\n.. _Coconut: http://coconut-lang.org/\n\nCoconut is developed on GitHub_ and hosted on PyPI_. Installing Coconut is as easy as opening a command prompt and entering::\n\n    pip install coconut\n\nTo help you get started, check out these links for more information about Coconut:\n\n- Tutorial_: If you're new to Coconut, a good place to start is Coconut's **tutorial**.\n- Documentation_: If you're looking for info about a specific feature, check out Coconut's **documentation**.\n- `Online Interpreter`_: If you want to try Coconut in your browser, check out Coconut's **online interpreter**.\n- FAQ_: If you have general questions about Coconut—like who Coconut is built for and whether or not you should use it—Coconut's frequently asked questions are often the best place to start.\n- `Create a New Issue <https://github.com/evhub/coconut/issues/new>`_: If you're having a problem with Coconut, creating a new issue detailing the problem will allow it to be addressed as soon as possible.\n- Gitter_: For any questions, concerns, or comments about anything Coconut-related, ask around at Coconut's Gitter, a GitHub-integrated chat room for Coconut developers.\n- Releases_: Want to know what's been added in recent Coconut versions? Check out the release log for all the new features and fixes.\n\n.. _Python: https://www.python.org/\n.. _PyPI: https://pypi.python.org/pypi/coconut\n.. _Tutorial: http://coconut.readthedocs.io/en/latest/HELP.html\n.. _Documentation: http://coconut.readthedocs.io/en/latest/DOCS.html\n.. _`Online Interpreter`: https://cs121-team-panda.github.io/coconut-interpreter\n.. _FAQ: http://coconut.readthedocs.io/en/latest/FAQ.html\n.. _GitHub: https://github.com/evhub/coconut\n.. _Gitter: https://gitter.im/evhub/coconut\n.. _Releases: https://github.com/evhub/coconut/releases\n\nCredits\n+++++++\n\nContributors\n------------\n\nThis project exists thanks to all the people who contribute! `Become a contributor`__.\n\n.. image:: https://opencollective.com/coconut/contributors.svg?width=890&button=false\n    :target: https://github.com/evhub/coconut/graphs/contributors\n\n__ Contributor_\n.. _Contributor: http://coconut.readthedocs.io/en/develop/CONTRIBUTING.html\n\nBackers\n-------\n\nThank you to all our backers! `Become a backer`__.\n\n.. image:: https://opencollective.com/coconut/backers.svg?width=890\n    :target: https://opencollective.com/coconut#backers\n\n__ Backer_\n.. _Backer: https://opencollective.com/coconut#backer\n\nSponsors\n--------\n\nSupport Coconut by becoming a sponsor. Your logo will show up here with a link to your website. `Become a sponsor`__.\n\n.. image:: https://opencollective.com/XX/sponsor/0/avatar.svg\n    :target: https://opencollective.com/coconut/sponsor/0/website\n\n__ Sponsor_\n.. _Sponsor: https://opencollective.com/coconut#sponsor\n"
        },
        {
          "name": "__coconut__",
          "type": "tree",
          "content": null
        },
        {
          "name": "_coconut",
          "type": "tree",
          "content": null
        },
        {
          "name": "coconut",
          "type": "tree",
          "content": null
        },
        {
          "name": "conf.py",
          "type": "blob",
          "size": 2.2509765625,
          "content": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n# -----------------------------------------------------------------------------------------------------------------------\n# INFO:\n# -----------------------------------------------------------------------------------------------------------------------\n\n\"\"\"\nAuthor: Evan Hubinger\nLicense: Apache 2.0\nDescription: Sphinx configuration file for the Coconut Programming Language.\n\"\"\"\n\n# -----------------------------------------------------------------------------------------------------------------------\n# IMPORTS:\n# -----------------------------------------------------------------------------------------------------------------------\n\nfrom __future__ import print_function, absolute_import, unicode_literals, division\n\nimport sys\nimport os.path\nsys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))\n\nfrom coconut.root import *  # NOQA\n\nfrom coconut.constants import (\n    version_tag,\n    without_toc,\n    with_toc,\n    exclude_docs_dirs,\n)\nfrom coconut.util import univ_open\n\nimport pydata_sphinx_theme  # NOQA\nimport myst_parser  # NOQA\n\n# -----------------------------------------------------------------------------------------------------------------------\n# README:\n# -----------------------------------------------------------------------------------------------------------------------\n\nwith univ_open(\"README.rst\", \"r\") as readme_file:\n    readme = readme_file.read()\n\nwith univ_open(\"index.rst\", \"w\") as index_file:\n    index_file.write(readme.replace(without_toc, with_toc))\n\n# -----------------------------------------------------------------------------------------------------------------------\n# DEFINITIONS:\n# -----------------------------------------------------------------------------------------------------------------------\n\nfrom coconut.constants import (  # NOQA\n    project,\n    copyright,\n    author,\n    highlight_language,\n)\n\nversion = VERSION\nrelease = version_tag\n\nhtml_theme = \"pydata_sphinx_theme\"\nhtml_theme_options = {\n}\n\nmaster_doc = \"index\"\n\nsource_suffix = [\".rst\", \".md\"]\n\nexclude_patterns = list(exclude_docs_dirs)\n\ndefault_role = \"code\"\n\nextensions = [\"myst_parser\"]\n\nmyst_enable_extensions = [\n    \"smartquotes\",\n]\n\nmyst_heading_anchors = 4\n\nhtml_sidebars = {\n    \"**\": [\n        \"localtoc.html\",\n    ],\n}\n"
        },
        {
          "name": "pyproject.toml",
          "type": "blob",
          "size": 0.0615234375,
          "content": "[build-system]\nrequires=[\n    \"setuptools>=18\",\n    \"wheel\",\n]\n"
        },
        {
          "name": "setup.cfg",
          "type": "blob",
          "size": 0.0703125,
          "content": "[bdist_wheel]\nuniversal = 1\n\n[metadata]\nlicense_files =\n    LICENSE.txt\n"
        },
        {
          "name": "setup.py",
          "type": "blob",
          "size": 2.7314453125,
          "content": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n# -----------------------------------------------------------------------------------------------------------------------\n# INFO:\n# -----------------------------------------------------------------------------------------------------------------------\n\n\"\"\"\nAuthor: Evan Hubinger\nLicense: Apache 2.0\nDescription: Installer for the Coconut Programming Language.\n\"\"\"\n\n# -----------------------------------------------------------------------------------------------------------------------\n# IMPORTS:\n# -----------------------------------------------------------------------------------------------------------------------\n\nfrom __future__ import print_function, absolute_import, unicode_literals, division\n\nimport sys\nimport os.path\nsys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))\n\nfrom coconut.root import *  # NOQA\n\nimport setuptools\n\nfrom coconut.constants import (\n    package_name,\n    author,\n    author_email,\n    description,\n    website_url,\n    classifiers,\n    search_terms,\n    script_names,\n    license_name,\n    exclude_install_dirs,\n    pygments_lexers,\n)\nfrom coconut.util import (\n    univ_open,\n    get_kernel_data_files,\n)\nfrom coconut.requirements import (\n    using_modern_setuptools,\n    requirements,\n    extras,\n)\n\n# -----------------------------------------------------------------------------------------------------------------------\n# SETUP:\n# -----------------------------------------------------------------------------------------------------------------------\n\nif not using_modern_setuptools and \"bdist_wheel\" in sys.argv:\n    raise RuntimeError(\"bdist_wheel not supported for setuptools versions < 18 (run '{python} -m pip install --upgrade setuptools' to fix)\".format(python=sys.executable))\n\nwith univ_open(\"README.rst\", \"r\") as readme_file:\n    readme = readme_file.read()\n\nsetuptools.setup(\n    name=package_name,\n    version=VERSION,\n    description=description,\n    long_description=readme,\n    url=website_url,\n    author=author,\n    author_email=author_email,\n    install_requires=requirements,\n    extras_require=extras,\n    packages=setuptools.find_packages(\n        exclude=list(exclude_install_dirs),\n    ),\n    include_package_data=True,\n    zip_safe=False,\n    entry_points={\n        \"console_scripts\": [\n            script + \" = coconut.main:main\"\n            for script in script_names\n        ] + [\n            script + \"-run = coconut.main:main_run\"\n            for script in script_names\n        ],\n        \"pygments.lexers\": list(pygments_lexers),\n        \"xonsh.xontribs\": [\n            \"coconut = coconut.integrations\",\n        ],\n    },\n    classifiers=list(classifiers),\n    keywords=list(search_terms),\n    license=license_name,\n    data_files=get_kernel_data_files(sys.argv),\n)\n"
        },
        {
          "name": "xontrib",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}