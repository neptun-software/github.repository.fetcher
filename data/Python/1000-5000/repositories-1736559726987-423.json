{
  "metadata": {
    "timestamp": 1736559726987,
    "page": 423,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQzMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "h2oai/wave",
      "stars": 4027,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".dockerignore",
          "type": "blob",
          "size": 0.138671875,
          "content": "# git\n.git\n\n# IDEs\n**/.vscode\n\n# Python\n**/venv\n**/.pytest_cache\n**/__pycache__\n\n# Node.js\n**/node_modules\nnode_modules\n\n# build artefacts\nqd\n"
        },
        {
          "name": ".flake8",
          "type": "blob",
          "size": 0.333984375,
          "content": "[flake8]\n# Ignore unused imports because wave apps need \"main\" imported eventhough it is not used (ASGI works that way).\nignore = F401\nper-file-ignores =\n    py/demo/dashboard_*.py:F405,F403\nmax-line-length = 120\nexclude =\n  py/h2o_wave/ui.py\n  py/h2o_wave/types.py\n\nimport-order-style = smarkets\ninline-quotes = \"\napplication-import-names =\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.373046875,
          "content": "# Binaries for programs and plugins\n*.exe\n*.exe~\n*.dll\n*.so\n*.dylib\n\n# Test binary, built with `go test -c`\n*.test\n\n# Output of the go coverage tool, specifically when used with LiteIDE\n*.out\n\n# Dependency directories (remove the comment below to include it)\n# vendor/\n\n.vscode/settings.json\n.idea\n/build\n/data\n/waved\n/wavedb\n.wave-keychain\n/*.db\n*.log\n*.swp\nnode_modules\n.DS_Store\n"
        },
        {
          "name": ".nvmrc",
          "type": "blob",
          "size": 0.0078125,
          "content": "v16.16.0"
        },
        {
          "name": ".python-version",
          "type": "blob",
          "size": 0.0078125,
          "content": "3.10.10\n"
        },
        {
          "name": ".vscode",
          "type": "tree",
          "content": null
        },
        {
          "name": "CODEOWNERS",
          "type": "blob",
          "size": 0.015625,
          "content": "* @lo5 @mturoci\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 11.091796875,
          "content": "\n                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"[]\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright [yyyy] [name of copyright owner]\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 8.1328125,
          "content": "OS?=linux\nVERSION ?= $(shell cat VERSION)\nARCH?=amd64\nBUILD_DATE?=$(shell date '+%Y%m%d%H%M%S')\nREL=wave-$(VERSION)-$(OS)-$(ARCH)\nLDFLAGS := -ldflags '-X main.Version=$(VERSION) -X main.BuildDate=$(BUILD_DATE)'\n# HACK: Linux uses GNU sed, while OSX uses BSD - need to install gsed to unify.\nSED=$(shell command -v gsed || command -v sed)\n\nall: clean setup build ## Setup and build everything\n\nsetup: ## Set up development dependencies\n\t$(MAKE) setup-ui\n\t$(MAKE) setup-vsc\n\tcd py && $(MAKE) setup\n\tcd tools/wavegen && $(MAKE) setup build\n\tcd tools/showcase && $(MAKE) setup\n\nclean: ## Clean\n\trm -rf build\n\tcd ui && $(MAKE) clean\n\tcd py && $(MAKE) clean\n\tcd tools/wavegen && $(MAKE) clean\n\tcd tools/showcase && $(MAKE) clean\n\trm -f waved\n\nsetup-ui:\n\tcd ui && $(MAKE) setup\n\nsetup-py-tests:\n\tcd py && $(MAKE) setup-tests\n\nsetup-vsc:\n\tcd tools/vscode-extension && $(MAKE) setup\n\nsetup-e2e:\n\tcd e2e && $(MAKE) setup\n\n.PHONY: build\nbuild: build-ui build-server ## Build everything\n\nbuild-ui: ## Build UI\n\tcd ui && $(MAKE) build\n\nbuild-ide: ## Build IDE\n\tcd ide && npm run build\n\trm -rf ui/build/_ide\n\tmv ide/dist ui/build/_ide\n\nbuild-r: ## Build R client.\n\tcd r && $(MAKE) build\n\nbuild-r-nightly: ## Build nightly R client.\n\tcd r && $(MAKE) build-nightly\n\nbuild-apps: ## Prepare apps for HAC upload.\n\trm -rf py/tmp\n\tmkdir -p py/tmp\n\tfor app in py/apps/*; do mkdir -p build/apps/wave-`basename $$app`; done\n\tcp -r py/apps/* py/tmp/\n\tfind py/tmp -type f -name '*.toml' -exec $(SED) -i -e \"s/{{VERSION}}/$(VERSION)/g\" {} \\;\n\tfind py/tmp -type f -name 'requirements.txt' -exec $(SED) -i -e \"s/{{VERSION}}/$(VERSION)/g\" {} \\;\n\trsync -a py/examples py/tmp/tour --exclude \"*.idea*\" --exclude \"*__pycache__*\" --exclude \"*.mypy_cache*\" --exclude \"dist\" --exclude \"build\"\n\trsync -a py/demo py/tmp/dashboard --exclude \"*.idea*\" --exclude \"*__pycache__*\" --exclude \"*.mypy_cache*\" --exclude \"dist\" --exclude \"build\"\n\tcp py/examples/theme_generator.py py/tmp/theme-generator\n\tcp tools/vscode-extension/base-snippets.json py/tmp/tour/examples\n\tcp tools/vscode-extension/component-snippets.json py/tmp/tour/examples\n\tcp tools/vscode-extension/server/utils.py py/tmp/tour/examples/tour_autocomplete_utils.py\n\tcp tools/vscode-extension/server/parser.py py/tmp/tour/examples/tour_autocomplete_parser.py\n\t$(SED) -i -r -e \"s#^@app\\(('|\\\")(.*)('|\\\")(.*)#@app\\('/'\\4#\" py/tmp/tour/examples/tour.py \n\t$(SED) -i -r -e \"s#^@app\\(('|\\\")(.*)('|\\\")(.*)#@app\\('/'\\4#\" py/tmp/theme-generator/theme_generator.py \n\tfor app in py/tmp/*; do cd $$app && zip -r ../../../build/apps/wave-`basename $$app`/`basename $$app`-$(VERSION).wave * && cd -; done\n\tcd studio && $(MAKE) build\n\tcd university && $(MAKE) build\n\nremove-build-apps-directory: ## Remove the wave apps files copied to tmp\n\trm -rf py/tmp\n\ngenerator: ## Build driver generator\n\tcd tools/wavegen && $(MAKE) build\n\nrun-ui: ## Run UI in development mode (hot reloading)\n\tcd ui && $(MAKE) run\n\ntest-ui-ci: ## Run UI unit tests in CI mode\n\tcd ui && $(MAKE) test-ci\n\ntest-py-ci: ## Run Python unit tests in CI mode\n\tcd py && $(MAKE) test\n\ntest-vsc-ci: ## Run Python unit tests in CI mode\n\tcd tools/vscode-extension && $(MAKE) test\n\ntest-intellij-ci:\n\tcd tools/intellij-plugin && $(MAKE) test\n\ntest-e2e-ci:\n\tcd e2e && $(MAKE) test\n\ntest-e2e-macos-ci:\n\tcd e2e && $(MAKE) test-macos\n\ntest-ui-watch: ## Run UI unit tests\n\tcd ui && $(MAKE) test\n\nbuild-server: ## Build server for current OS/Arch\n\tGOEXPERIMENT=boringcrypto go build $(LDFLAGS) -o waved cmd/wave/main.go\n\nbuild-db: ## Build database server for current OS/Arch\n\tGOEXPERIMENT=boringcrypto go build $(LDFLAGS) -o wavedb cmd/wavedb/main.go\n\nbuild-db-micro:\n\tgo build -ldflags '-s -w -X main.Version=$(VERSION) -X main.BuildDate=$(BUILD_DATE)' -o wavedb cmd/wavedb/main.go\n\tupx --brute wavedb\n\nrelease-db: # Build release package for database server\n\tmkdir -p build\n\tGOEXPERIMENT=boringcrypto go build -ldflags '-X main.Version=$(VERSION) -X main.BuildDate=$(BUILD_DATE)' -o wavedb$(EXE_EXT) cmd/wavedb/main.go\n\ttar -czf wavedb-$(VERSION)-$(OS)-amd64.tar.gz wavedb$(EXE_EXT)\n\nrelease-db-windows: # Build OSX release package for database server\n\t$(MAKE) OS=windows EXE_EXT=\".exe\" release-db\n\nrelease-db-darwin: # Build OSX release package for database server\n\t$(MAKE) OS=darwin release-db\n\nrelease-db-linux: # Build Linux release package for database server\n\t$(MAKE) OS=linux release-db\n\nbuild-server-micro: ## Build smaller (~2M instead of ~10M) server executable\n\tgo build -ldflags '-s -w -X main.Version=$(VERSION) -X main.BuildDate=$(BUILD_DATE)' -o waved cmd/wave/main.go\n\tupx --brute waved\n\nbuild-py: ## Build h2o_wave, h2o_lightwave and h2o_lightwave_web wheel.\n\tcd py && $(MAKE) build\n\nbuild-docker:\n\tdocker build \\\n\t\t--build-arg uid=$(shell id -u) \\\n\t\t--build-arg gid=$(shell id -g) \\\n\t\t-t wave-test:$(VERSION) \\\n\t\t.\n\nrun: ## Run server\n\tGOEXPERIMENT=boringcrypto go run cmd/wave/main.go -web-dir ./ui/build -debug -editable -proxy -public-dir /assets/@./assets\n\nrun-db: ## Run database server\n\tgo run cmd/wavedb/main.go\n\nrun-hb: ## Run handlebars frontend\n\tgo run cmd/wave/main.go -web-dir ./x/handlebars\n\nrun-cypress: ## Run Cypress\n\tcd test && ./node_modules/.bin/cypress open\n\ngenerate: ## Generate driver bindings\n\tcd tools/wavegen && $(MAKE) run\n\n.PHONY: pydocs\npydocs: ## Generate API docs and copy to website\n\tcd py && $(MAKE) docs\n\tcd tools/showcase && $(MAKE) generate\n\nrelease: build-ui ## Prepare release builds (e.g. \"VERSION=1.2.3 make release)\"\n\t$(MAKE) OS=linux ARCH=amd64 release-os\n\t$(MAKE) OS=darwin ARCH=amd64 release-os\n\t$(MAKE) OS=darwin ARCH=arm64 release-os\n\t$(MAKE) OS=windows ARCH=amd64 EXE_EXT=\".exe\" release-os\n\t$(MAKE) website\n\t$(MAKE) build-py\n\t# $(MAKE) build-r\n\nrelease-nightly: build-ui ## Prepare nightly release builds. \n\t$(MAKE) OS=linux ARCH=amd64 release-os\n\t$(MAKE) OS=darwin ARCH=amd64 release-os\n\t$(MAKE) OS=darwin ARCH=arm64 release-os\n\t$(MAKE) OS=windows ARCH=amd64 EXE_EXT=\".exe\" release-os\n\tcd py && $(MAKE) build-wave\n\t$(MAKE) build-r-nightly\n\npublish-release-s3:\n\taws s3 sync build/ s3://h2o-wave/releases --acl public-read --exclude \"*\" --include \"*.tar.gz\"\n\taws s3 sync py/h2o_wave/dist/ s3://h2o-wave/releases --acl public-read --exclude \"*\" --include \"*.whl\"\n\t# aws s3 sync r/build/ s3://h2o-wave/releases --acl public-read --exclude \"*\" --include \"*.tar.gz\"\n\npublish-apps-s3-mc:\n\taws s3 sync build/apps/wave-dashboard $(MC_S3_BUCKET)/wave-dashboard\n\taws s3 sync build/apps/wave-tour $(MC_S3_BUCKET)/wave-tour\n\taws s3 sync build/apps/wave-theme-generator $(MC_S3_BUCKET)/wave-theme-generator\n\npublish-apps-s3-hac:\n\tfor app in build/apps/*; do aws s3 sync $$app $(HAC_S3_BUCKET)/`basename $$app`; done\n\nrelease-os:\n\trm -rf build/$(REL)\n\tmkdir -p build/$(REL)\n\trsync -a ui/build/ build/$(REL)/www\n\trsync -a py/examples build/$(REL)/\n\trsync -a py/demo build/$(REL)/\n\trm -rf test/cypress/integration/*.js\n\trm -rf test/cypress/screenshots/*.*\n\trm -rf test/cypress/videos/*.*\n\trsync --exclude node_modules -a test build/$(REL)/\n\tGOOS=$(OS) GOARCH=$(ARCH) GOEXPERIMENT=boringcrypto go build $(LDFLAGS) -o build/$(REL)/waved$(EXE_EXT) cmd/wave/main.go\n\tcd build && tar -czf $(REL).tar.gz  --exclude='*.state'  --exclude='__pycache__' $(REL)\n\n.PHONY: website\nwebsite: pydocs ## Build website\n\tcd website && npm ci && npm run build\n\npreview-website: ## Preview website\n\tgo run cmd/fs/main.go -web-dir website/build\n\npublish-website: ## Publish website\n\taws s3 sync website/build s3://wave.h2o.ai --delete\n\npublish-pycharm: ## Publish PyCharm plugin\n\tcd tools/intellij-plugin && $(MAKE) publish\n\t\npublish-vsc-extension: ## Publish VS Code extension\n\tcd tools/vscode-extension && $(MAKE) publish\n\npublish-university:\n\tcd university && $(MAKE) publish\n\t\npublish-lightwave:\n\tcd ui && npm ci && npm run build\n\tcd py && $(MAKE) setup\n\tcd py && $(MAKE) build-lightwave\n\tcd py && $(MAKE) build-lightwave-web\n\t\n.PHONY: tag\ntag: ## Bump version and tag\n\tcd py && $(MAKE) tag\n\tcd ui && $(MAKE) tag\n\tcd r && $(MAKE) tag\n\tcd university && $(MAKE) tag\n\tcd tools/vscode-extension && $(MAKE) tag\n\tcd tools/intellij-plugin && $(MAKE) tag\n\tgit add .\n\tgit commit -m \"chore: Release v$(VERSION)\"\n\tgit tag v$(VERSION)\n\tgit push origin && git push origin --tags\n\nhelp: ## List all make tasks\n\t@grep -E '^[a-zA-Z_-]+:.*?## .*$$' $(MAKEFILE_LIST) | sort | awk 'BEGIN {FS = \":.*?## \"}; {printf \"\\033[36m%-30s\\033[0m %s\\n\", $$1, $$2}'\n"
        },
        {
          "name": "NOTICE",
          "type": "blob",
          "size": 0.109375,
          "content": "H2O Wave\nCopyright 2020 H2O.ai, Inc.\n\nThis product includes software developed at H2O.ai, Inc (http://h2o.ai/).\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 3.1669921875,
          "content": "## H2O Wave\n\n<img src=\"assets/brand/wave-type-yellow.png\" alt=\"Wave logo\">\n\n<p>\n  <img alt=\"PyPI - Downloads\" src=\"https://img.shields.io/pypi/dm/h2o-wave?color=FBE52B\">\n  <img alt=\"License\" src=\"https://img.shields.io/github/license/h2oai/wave?color=yellow\">\n  <img alt=\"PyPI\" src=\"https://img.shields.io/pypi/v/h2o-wave?label=current-version\">\n  <img alt=\"Twitter Follow\" src=\"https://img.shields.io/twitter/follow/h2o_wave\">\n  <a href=\"https://discord.gg/V8GZFAy3WM\"><img src=\"https://img.shields.io/badge/chat-discord-blue?style=flat&logo=discord\" alt=\"discord chat\"></a>\n  <img alt=\"Contributor covenant\" src=\"https://img.shields.io/badge/Contributor%20Covenant-2.0-4baaaa.svg\">\n</p>\n\n### Realtime Web Apps and Dashboards for Python and R\n\n**New!** *[R Language API](https://wave.h2o.ai/blog/r-api-preview) Build and control Wave dashboards using R!*\n\nH2O Wave is a software stack for building beautiful, low-latency, realtime, browser-based applications and dashboards entirely in Python/R without using HTML, Javascript, or CSS.\n\nH2O Wave excels at capturing information from multiple sources and broadcasting them live over the web, letting you build and deploy realtime analytics with dramatically less effort.\n\n- [Download](https://github.com/h2oai/wave/releases) / [How to install](https://wave.h2o.ai/docs/installation/)\n- [Documentation](https://wave.h2o.ai/): [Getting Started](https://wave.h2o.ai/docs/getting-started/) / [Widgets](https://wave.h2o.ai/docs/widgets/overview) / [Gallery and Examples](https://wave.h2o.ai/docs/examples/) / [Python API](https://wave.h2o.ai/docs/api/index/)\n- [Developing](https://github.com/h2oai/wave/blob/main/.github/CONTRIBUTING.md#development-setup)\n- [Discuss / Support / Q&A / Ideas](https://github.com/h2oai/wave/discussions)\n- [Report a problem](https://github.com/h2oai/wave/issues/new/choose)\n- [Blog](https://wave.h2o.ai/blog/) / [@h2o_wave](https://twitter.com/h2o_wave)\n\n### Live demos\n\n- [Wave Tour](https://huggingface.co/spaces/h2oai/wave-tour) - 200+ interactive examples.\n- [Wave University](https://huggingface.co/spaces/h2oai/wave-university) - Learn Wave basics interactively.\n- [Wave Theme Generator](https://huggingface.co/spaces/h2oai/theme-generator) - Create your color theme.\n\n### Responsive Layouts\n\n![Dashboard](website/blog/assets/2021-01-17/dashboards.png)\n\n![Dashboard](website/blog/assets/2021-01-17/dashboard_red.png)\n\n![Dashboard](website/blog/assets/2021-01-17/dashboard_blue.png)\n\n![Dashboard](website/blog/assets/2021-01-17/dashboard_orange.png)\n\n![Dashboard](website/blog/assets/2021-01-17/dashboard_cyan.png)\n\n![Dashboard](website/blog/assets/2021-01-17/dashboard_mint.png)\n\n![Dashboard](website/blog/assets/2021-01-17/dashboard_purple.png)\n\nCode: <https://github.com/h2oai/wave/tree/main/py/demo>\n\n### Themes\n\n![Light Theme](assets/visuals/theme-light.png)\n\n![Neon Theme](assets/visuals/theme-neon.png)\n\n(Coming soon!)\n\n![Dark Theme](assets/visuals/theme-dark.png)\n\n### 80+ components, 250+ examples\n\nMore at <https://wave.h2o.ai/docs/examples>\n\n![Components](assets/visuals/components-1.png)\n\n![Visualizations](assets/visuals/components-2.png)\n\n### License\n\nH2O Wave is licensed under the Apache License 2.0. See [LICENSE](LICENSE) for more information.\n"
        },
        {
          "name": "VERSION",
          "type": "blob",
          "size": 0.00390625,
          "content": "DEV\n"
        },
        {
          "name": "app.go",
          "type": "blob",
          "size": 3.6533203125,
          "content": "// Copyright 2020 H2O.ai, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage wave\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"net/http\"\n)\n\n// AppMode represents app modes.\ntype AppMode int\n\nconst (\n\tunicastMode AppMode = iota\n\tmulticastMode\n\tbroadcastMode\n)\n\n// App represents an app\ntype App struct {\n\tbroker    *Broker\n\tclient    *http.Client\n\tmode      AppMode // mode\n\troute     string  // route\n\taddr      string  // upstream address http://host:port\n\tkeyID     string  // access key ID\n\tkeySecret string  // access key secret\n}\n\nfunc toAppMode(mode string) AppMode {\n\tswitch mode {\n\tcase \"broadcast\":\n\t\treturn broadcastMode\n\tcase \"multicast\":\n\t\treturn multicastMode\n\t}\n\treturn unicastMode\n}\n\nfunc newApp(broker *Broker, mode, route, addr, keyID, keySecret string) *App {\n\treturn &App{\n\t\tbroker,\n\t\t&http.Client{}, // TODO tune keep-alive and idle timeout\n\t\ttoAppMode(mode),\n\t\troute,\n\t\taddr,\n\t\tkeyID,\n\t\tkeySecret,\n\t}\n}\n\nfunc (app *App) disconnect(clientID string) error {\n\treq, err := http.NewRequest(\"POST\", app.addr+\"/disconnect\", nil)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed creating request: %v\", err)\n\t}\n\n\treq.SetBasicAuth(app.keyID, app.keySecret)\n\treq.Header.Set(\"Wave-Client-ID\", clientID)\n\n\tresp, err := app.client.Do(req)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"request failed: %v\", err)\n\t}\n\tdefer resp.Body.Close()\n\tif resp.StatusCode != 200 {\n\t\treturn fmt.Errorf(\"request failed: %s\", http.StatusText(resp.StatusCode))\n\t}\n\tif _, err := readWithLimit(resp.Body, 0); err != nil { // apps always return empty plain-text responses.\n\t\treturn fmt.Errorf(\"failed reading response: %v\", err)\n\t}\n\treturn nil\n}\n\nfunc (app *App) forward(clientID string, session *Session, data []byte) {\n\tif err := app.send(clientID, session, data); err != nil {\n\t\techo(Log{\"t\": \"app\", \"route\": app.route, \"host\": app.addr, \"error\": err.Error()})\n\t\tif !app.broker.keepAppLive {\n\t\t\tapp.broker.dropApp(app.route)\n\t\t}\n\t}\n}\n\nfunc (app *App) send(clientID string, session *Session, data []byte) error {\n\treq, err := http.NewRequest(\"POST\", app.addr, bytes.NewReader(data))\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed creating request: %v\", err)\n\t}\n\n\treq.SetBasicAuth(app.keyID, app.keySecret)\n\n\treq.Header.Set(\"Content-Type\", \"application/json; charset=utf-8\")\n\tif len(clientID) > 0 {\n\t\treq.Header.Set(\"Wave-Client-ID\", clientID)\n\t}\n\treq.Header.Set(\"Wave-Subject-ID\", session.subject)\n\treq.Header.Set(\"Wave-Username\", session.username)\n\tif session.subject != anon {\n\t\treq.Header.Set(\"Wave-Session-ID\", session.id)\n\t\t// TODO: Figure out how can the token be nil.\n\t\tif session.token != nil {\n\t\t\treq.Header.Set(\"Wave-Access-Token\", session.token.AccessToken)\n\t\t\treq.Header.Set(\"Wave-Refresh-Token\", session.token.RefreshToken)\n\t\t} else {\n\t\t\tif app.broker.debug {\n\t\t\t\techo(Log{\"t\": \"app_send\", \"error\": \"session token is nil\"})\n\t\t\t}\n\t\t}\n\t}\n\n\tresp, err := app.client.Do(req)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"request failed: %v\", err)\n\t}\n\tdefer resp.Body.Close()\n\tif resp.StatusCode != 200 {\n\t\treturn fmt.Errorf(\"request failed: %s\", http.StatusText(resp.StatusCode))\n\t}\n\tif _, err := readWithLimit(resp.Body, 0); err != nil { // apps always return empty plain-text responses.\n\t\treturn fmt.Errorf(\"failed reading response: %v\", err)\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "assets",
          "type": "tree",
          "content": null
        },
        {
          "name": "attack.txt",
          "type": "blob",
          "size": 0.10546875,
          "content": "POST http://localhost:8000\nAuthorization: Basic Zm9vOmJhcg==\nContent-Type: application/json\n@increment.json\n"
        },
        {
          "name": "auth.go",
          "type": "blob",
          "size": 13.244140625,
          "content": "// Copyright 2020 H2O.ai, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage wave\n\nimport (\n\t\"context\"\n\t\"crypto/rand\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"path\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/coreos/go-oidc\"\n\t\"github.com/google/uuid\"\n\t\"github.com/h2oai/wave/pkg/keychain\"\n\t\"golang.org/x/oauth2\"\n)\n\nconst authCookieName = \"oidcsession\"\n\nvar authDefaultScopes = []string{oidc.ScopeOpenID, \"profile\"}\n\nfunc connectToProvider(conf *AuthConf) (*oauth2.Config, error) {\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\tprovider, err := oidc.NewProvider(ctx, conf.ProviderURL)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tscopes := authDefaultScopes\n\tif len(conf.Scopes) > 0 && conf.Scopes[0] != \"\" {\n\t\tscopes = conf.Scopes\n\t}\n\treturn &oauth2.Config{\n\t\tClientID:     conf.ClientID,\n\t\tClientSecret: conf.ClientSecret,\n\t\tEndpoint:     provider.Endpoint(),\n\t\tRedirectURL:  conf.RedirectURL,\n\t\tScopes:       scopes,\n\t}, nil\n}\n\n// Session represents an end-user session\ntype Session struct {\n\tsync.RWMutex\n\tid         string\n\tstate      string\n\tnonce      string\n\tsubject    string\n\tusername   string\n\tsuccessURL string\n\ttoken      *oauth2.Token\n\texpiry     time.Time\n}\n\nvar errInactivityTimeout = errors.New(\"timed out due to inactivity\")\n\nfunc (s *Session) touch(timeout time.Duration) error {\n\tif s == anonymous {\n\t\treturn nil\n\t}\n\n\tnow := time.Now()\n\n\ts.RLock()\n\texpired := s.expiry.Before(now)\n\ts.RUnlock()\n\n\tif expired {\n\t\treturn errInactivityTimeout\n\t}\n\n\ts.Lock()\n\ts.expiry = now.Add(timeout)\n\ts.Unlock()\n\n\treturn nil\n}\n\nconst (\n\tanon = \"anon\"\n)\n\nvar anonymous = &Session{\n\tsubject:  anon,\n\tusername: anon,\n\ttoken:    &oauth2.Token{},\n\texpiry:   time.Now().Add(365 * 24 * time.Hour),\n}\n\n// Auth holds authenticated end-user sessions\ntype Auth struct {\n\tsync.RWMutex\n\tconf     *AuthConf\n\toauth    *oauth2.Config\n\tsessions map[string]*Session\n\tbaseURL  string\n\tinitURL  string\n\tloginURL string\n}\n\nfunc newAuth(conf *AuthConf, baseURL, initURL, loginURL string) (*Auth, error) {\n\toauth, err := connectToProvider(conf)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &Auth{\n\t\tconf:     conf,\n\t\toauth:    oauth,\n\t\tsessions: make(map[string]*Session),\n\t\tbaseURL:  baseURL,\n\t\tinitURL:  initURL,\n\t\tloginURL: loginURL,\n\t}, nil\n}\n\nfunc (auth *Auth) get(key string) (*Session, bool) {\n\tauth.RLock()\n\tdefer auth.RUnlock()\n\tsession, ok := auth.sessions[key]\n\treturn session, ok\n}\n\nfunc (auth *Auth) set(session *Session) {\n\tauth.Lock()\n\tdefer auth.Unlock()\n\tauth.sessions[session.id] = session\n}\n\nfunc (auth *Auth) remove(key string) {\n\tauth.Lock()\n\tdefer auth.Unlock()\n\tdelete(auth.sessions, key)\n}\n\nfunc (auth *Auth) identify(r *http.Request) *Session {\n\tcookie, err := r.Cookie(authCookieName)\n\tif err != nil {\n\t\techo(Log{\"t\": \"oauth2_cookie_read\", \"warning\": err.Error()})\n\t\treturn nil\n\t}\n\n\tsessionID := cookie.Value\n\tsession, ok := auth.get(sessionID)\n\tif !ok {\n\t\techo(Log{\"t\": \"oauth2_session\", \"error\": \"invalid session\", \"session_id\": sessionID})\n\t\treturn nil\n\t}\n\n\tif err := session.touch(auth.conf.InactivityTimeout); err != nil {\n\t\techo(Log{\"t\": \"inactivity_timeout\", \"subject\": session.subject})\n\t\treturn nil\n\t}\n\n\ttoken, err := auth.ensureValidOAuth2Token(r.Context(), session.token)\n\tif err != nil {\n\t\techo(Log{\"t\": \"oauth2_token_refresh\", \"error\": err.Error(), \"subject\": session.subject})\n\t\treturn nil\n\t}\n\n\tif session.token != token {\n\t\tsession.token = token\n\t\tauth.set(session)\n\t}\n\n\treturn session\n}\n\nfunc (auth *Auth) allow(r *http.Request) bool {\n\treturn auth.identify(r) != nil\n}\n\nfunc (auth *Auth) wrap(h http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tif len(path.Ext(r.URL.Path)) > 0 {\n\t\t\th.ServeHTTP(w, r)\n\t\t\treturn\n\t\t}\n\n\t\tif r.URL.Path == auth.loginURL {\n\t\t\tif auth.conf.SkipLogin {\n\t\t\t\tauth.redirectToAuth(w, r)\n\t\t\t\treturn\n\t\t\t}\n\t\t\th.ServeHTTP(w, r)\n\t\t\treturn\n\t\t}\n\n\t\tif !auth.allow(r) {\n\t\t\tauth.redirectToLogin(w, r)\n\t\t\treturn\n\t\t}\n\n\t\th.ServeHTTP(w, r)\n\t})\n}\n\nfunc (auth *Auth) ensureValidOAuth2Token(ctx context.Context, token *oauth2.Token) (*oauth2.Token, error) {\n\ttoken, err := auth.oauth.TokenSource(ctx, token).Token()\n\tif token == nil {\n\t\techo(Log{\"t\": \"ensure_token_refresh\", \"error\": \"refresh token is nil\"})\n\t\techo(Log{\"t\": \"ensure_token_refresh\", \"error\": err.Error()})\n\t}\n\treturn token, err\n}\n\nfunc (auth *Auth) redirectToLogin(w http.ResponseWriter, r *http.Request) {\n\t// X -> /_auth/login?next=X\n\tu, _ := url.Parse(auth.loginURL)\n\tq := u.Query()\n\tq.Set(\"next\", r.URL.Path)\n\tu.RawQuery = q.Encode()\n\thttp.Redirect(w, r, u.String(), http.StatusFound)\n}\n\nfunc (auth *Auth) redirectToAuth(w http.ResponseWriter, r *http.Request) {\n\t// /_auth/login -> /_auth/init\n\t// /_auth/login?next=X -> /_auth/init?next=X\n\tu, _ := url.Parse(auth.initURL)\n\tnext := r.URL.Query().Get(\"next\")\n\tif next != \"\" {\n\t\tq := u.Query()\n\t\tq.Set(\"next\", next)\n\t\tu.RawQuery = q.Encode()\n\t}\n\thttp.Redirect(w, r, u.String(), http.StatusFound)\n}\n\nfunc generateRandomKey(byteCount int) (string, error) {\n\tb := make([]byte, byteCount)\n\t_, err := rand.Read(b)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn fmt.Sprintf(\"%x\", b), nil\n}\n\n// LoginHandler handles auth requests\ntype LoginHandler struct {\n\tauth *Auth\n}\n\nfunc newLoginHandler(auth *Auth) http.Handler {\n\treturn &LoginHandler{auth}\n}\n\nfunc (h *LoginHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\t// `state` is to protect from CSRF (OAuth2 part).\n\tstate, err := generateRandomKey(4)\n\tif err != nil {\n\t\techo(Log{\"t\": \"oidc_random_state_key\", \"error\": err.Error()})\n\t\thttp.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\t// `nonce` is to protect from replay attacks (OpenID part).\n\tnonce, err := generateRandomKey(4)\n\tif err != nil {\n\t\techo(Log{\"t\": \"oidc_random_nonce_key\", \"error\": err.Error()})\n\t\thttp.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tsuccessURL := h.auth.baseURL\n\tif nextValues, ok := r.URL.Query()[\"next\"]; ok {\n\t\tsuccessURL = nextValues[0]\n\t}\n\n\t// Session ID stored in cookie.\n\tsessionID := uuid.New().String()\n\n\th.auth.set(&Session{id: sessionID, state: state, nonce: nonce, successURL: successURL, expiry: time.Now().Add(h.auth.conf.InactivityTimeout)})\n\tcookie := http.Cookie{Name: authCookieName, Value: sessionID, Path: h.auth.baseURL, Expires: time.Now().Add(h.auth.conf.SessionExpiry)}\n\thttp.SetCookie(w, &cookie)\n\n\tvar options []oauth2.AuthCodeOption\n\toptions = append(options, oidc.Nonce(nonce))\n\tfor _, param := range h.auth.conf.URLParameters {\n\t\toptions = append(options, oauth2.SetAuthURLParam(param[0], param[1]))\n\t}\n\thttp.Redirect(w, r, h.auth.oauth.AuthCodeURL(state, options...), http.StatusFound)\n}\n\n// AuthHandler handles OAuth2 requests\ntype AuthHandler struct {\n\tauth *Auth\n}\n\nfunc newAuthHandler(auth *Auth) http.Handler {\n\treturn &AuthHandler{auth}\n}\n\nfunc (h *AuthHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\t// Retrieve saved session.\n\tcookie, err := r.Cookie(authCookieName)\n\tif err != nil {\n\t\techo(Log{\"t\": \"oauth2_cookie\", \"error\": err.Error()})\n\t\thttp.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tsessionID := cookie.Value\n\tsession, ok := h.auth.get(sessionID)\n\tif !ok {\n\t\techo(Log{\"t\": \"oauth2_session\", \"error\": \"not found\"})\n\t\thttp.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\t// Handle errors from provider.\n\tif err := r.URL.Query().Get(\"error\"); err != \"\" {\n\t\terrorDescription := r.URL.Query().Get(\"error_description\")\n\t\techo(Log{\"t\": \"oauth2_callback\", \"error\": err, \"description\": errorDescription})\n\t\thttp.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\t// Compare to stored state.\n\tresponseState := r.URL.Query().Get(\"state\")\n\tif session.state != responseState {\n\t\techo(Log{\"t\": \"oauth2_state\", \"error\": \"failed matching state\"})\n\t\thttp.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\toAuth2Provider, err := oidc.NewProvider(r.Context(), h.auth.conf.ProviderURL)\n\tif err != nil {\n\t\techo(Log{\"t\": \"oauth2_oidc_provider\", \"error\": err.Error()})\n\t\thttp.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\toauth2Token, err := h.auth.oauth.Exchange(r.Context(), r.URL.Query().Get(\"code\"))\n\tif err != nil {\n\t\techo(Log{\"t\": \"oauth2_exchange\", \"error\": err.Error()})\n\t\thttp.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\trawIDToken, ok := oauth2Token.Extra(\"id_token\").(string)\n\tif !ok {\n\t\techo(Log{\"t\": \"oauth2_exchange\", \"error\": \"failed reading id_token\"})\n\t\thttp.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\toidcVerifier := oAuth2Provider.Verifier(&oidc.Config{ClientID: h.auth.oauth.ClientID})\n\tidToken, err := oidcVerifier.Verify(r.Context(), rawIDToken)\n\tif err != nil {\n\t\techo(Log{\"t\": \"oauth2_oidc_verifier\", \"error\": \"failed verifying id_token\"})\n\t\thttp.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tvar claims struct {\n\t\tPreferredUsername string `json:\"preferred_username\"`\n\t\tNonce             string `json:\"nonce\"`\n\t}\n\terr = idToken.Claims(&claims)\n\tif err != nil {\n\t\techo(Log{\"t\": \"oauth2_claim\", \"error\": \"failed parsing token claims\"})\n\t\thttp.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\t// Compare to stored nonce.\n\tif session.nonce != claims.Nonce {\n\t\tif !ok {\n\t\t\techo(Log{\"t\": \"oauth2_nonce\", \"error\": \"failed matching nonce\"})\n\t\t\thttp.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t}\n\n\tsession.token = oauth2Token\n\tsession.subject = idToken.Subject\n\tsession.username = claims.PreferredUsername\n\n\techo(Log{\"t\": \"login\", \"subject\": session.subject, \"username\": session.username})\n\n\th.auth.set(session)\n\n\thttp.Redirect(w, r, session.successURL, http.StatusFound)\n}\n\n// LogoutHandler handles logout requests\ntype LogoutHandler struct {\n\tauth   *Auth\n\tbroker *Broker\n}\n\nfunc newLogoutHandler(auth *Auth, broker *Broker) http.Handler {\n\treturn &LogoutHandler{auth, broker}\n}\n\nfunc (h *LogoutHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tvar idToken string\n\n\t// Retrieve saved session.\n\tcookie, err := r.Cookie(authCookieName)\n\tif err != nil {\n\t\techo(Log{\"t\": \"logout_cookie\", \"error\": \"not found\"})\n\t\th.redirect(w, r, idToken)\n\t\treturn\n\t}\n\n\tsessionID := cookie.Value\n\tsession, ok := h.auth.get(sessionID)\n\n\t// Delete cookie.\n\tcookie.MaxAge = -1\n\thttp.SetCookie(w, cookie)\n\n\t// Purge session\n\th.auth.remove(sessionID)\n\n\tif ok {\n\t\t// Reload all of this user's browser tabs\n\t\th.broker.resetClients(session)\n\n\t\t// A token may not be present if the oauth2 workflow failed, so check before access.\n\t\tif session.token != nil {\n\t\t\tidToken, _ = session.token.Extra(\"id_token\").(string) // raw id_token (required by Okta)\n\t\t}\n\t}\n\n\th.redirect(w, r, idToken)\n}\n\nfunc (h *LogoutHandler) redirect(w http.ResponseWriter, r *http.Request, idToken string) {\n\tif h.auth.conf.EndSessionURL == \"\" {\n\t\thttp.Redirect(w, r, h.auth.baseURL, http.StatusFound)\n\t\treturn\n\t}\n\n\tredirectURL, err := url.Parse(h.auth.conf.EndSessionURL)\n\tif err != nil {\n\t\techo(Log{\"t\": \"logout_redirect_parse\", \"error\": err.Error()})\n\t\treturn\n\t}\n\n\tpost_logout_redirect_url := h.auth.conf.PostLogoutRedirectURL\n\tif post_logout_redirect_url == \"\" {\n\t\tpost_logout_redirect_url = r.Host\n\t}\n\tquery := redirectURL.Query()\n\tquery.Set(\"post_logout_redirect_uri\", post_logout_redirect_url)\n\tif len(idToken) > 0 {\n\t\t// required by Okta\n\t\t// https://developer.okta.com/docs/reference/api/oidc/#logout\n\t\tquery.Set(\"id_token_hint\", idToken)\n\t}\n\tredirectURL.RawQuery = query.Encode()\n\n\thttp.Redirect(w, r, redirectURL.String(), http.StatusFound)\n}\n\n// Handles token refreshes.\ntype RefreshHandler struct {\n\tauth     *Auth\n\tkeychain *keychain.Keychain\n}\n\nfunc newRefreshHandler(auth *Auth, keychain *keychain.Keychain) http.Handler {\n\treturn &RefreshHandler{auth, keychain}\n}\n\nfunc (h *RefreshHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tif !h.keychain.Guard(w, r) { // API\n\t\treturn\n\t}\n\n\tsessionID := r.Header.Get(\"Wave-Session-ID\")\n\tsession, ok := h.auth.get(sessionID)\n\n\tif !ok {\n\t\techo(Log{\"t\": \"refresh_session\", \"error\": \"session unavailable\"})\n\t\thttp.Error(w, http.StatusText(http.StatusUnauthorized), http.StatusUnauthorized)\n\t\treturn\n\t}\n\n\ttoken, err := h.auth.ensureValidOAuth2Token(r.Context(), session.token)\n\tif err != nil {\n\t\t// Purge session and reload clients if refresh not successful?\n\t\techo(Log{\"t\": \"refresh_session\", \"error\": err.Error()})\n\t\thttp.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tsession.token = token\n\th.auth.set(session)\n\n\tw.Header().Set(\"Wave-Access-Token\", token.AccessToken)\n\tw.Header().Set(\"Wave-Refresh-Token\", token.RefreshToken)\n\tw.WriteHeader(http.StatusOK)\n}\n"
        },
        {
          "name": "broker.go",
          "type": "blob",
          "size": 7.009765625,
          "content": "// Copyright 2020 H2O.ai, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage wave\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"log\"\n\t\"sort\"\n\t\"sync\"\n)\n\n// MsgT represents message types.\ntype MsgT int\n\nconst (\n\tbadMsgT MsgT = iota\n\tnoopMsgT\n\tpatchMsgT\n\tqueryMsgT\n\twatchMsgT\n)\n\n// Msg represents a message.\ntype Msg struct {\n\tt    MsgT\n\taddr string\n\tdata []byte\n}\n\nvar (\n\tmsgSep     = []byte{' '}\n\temptyJSON  = []byte(\"{}\")\n\tresetMsg   []byte\n\tinvalidMsg = Msg{t: badMsgT}\n\tlogoutMsg  = []byte(`{\"data\": {\"\":{\"@system\":{\"logout\":true}}}}`)\n)\n\n// Pub represents a published message\ntype Pub struct {\n\troute string\n\tdata  []byte\n}\n\n// Sub represents a subscription.\ntype Sub struct {\n\troute  string\n\tclient *Client\n}\n\n// Broker represents a message broker.\ntype Broker struct {\n\tsite        *Site\n\teditable    bool\n\tnoStore     bool\n\tnoLog       bool\n\tdebug       bool\n\tclients     map[string]map[*Client]interface{} // route => client-set\n\tpublish     chan Pub\n\tsubscribe   chan Sub\n\tunsubscribe chan *Client\n\tlogout      chan Pub\n\tapps        map[string]*App // route => app\n\tappsMux     sync.RWMutex    // mutex for tracking apps\n\tunicasts    map[string]bool // \"/client_id\" => true\n\tunicastsMux sync.RWMutex    // mutex for tracking unicast routes\n\tkeepAppLive bool\n\tclientsByID map[string]*Client\n}\n\nfunc newBroker(site *Site, editable, noStore, noLog, keepAppLive, debug bool) *Broker {\n\treturn &Broker{\n\t\tsite,\n\t\teditable,\n\t\tnoStore,\n\t\tnoLog,\n\t\tdebug,\n\t\tmake(map[string]map[*Client]interface{}),\n\t\tmake(chan Pub, 1024),     // TODO tune\n\t\tmake(chan Sub, 1024),     // TODO tune\n\t\tmake(chan *Client, 1024), // TODO tune\n\t\tmake(chan Pub, 1024),     // TODO tune\n\t\tmake(map[string]*App),\n\t\tsync.RWMutex{},\n\t\tmake(map[string]bool),\n\t\tsync.RWMutex{},\n\t\tkeepAppLive,\n\t\tmake(map[string]*Client),\n\t}\n}\n\nfunc (b *Broker) getClient(id string) *Client {\n\tb.unicastsMux.RLock()\n\tdefer b.unicastsMux.RUnlock()\n\treturn b.clientsByID[id]\n}\n\nfunc (b *Broker) addApp(mode, route, addr, keyID, keySecret string) {\n\ts := newApp(b, mode, route, addr, keyID, keySecret)\n\n\tb.appsMux.Lock()\n\tb.apps[route] = s\n\tb.appsMux.Unlock()\n\n\techo(Log{\"t\": \"app_add\", \"route\": route, \"host\": addr})\n\n\t// Force-reload all browsers listening to this app\n\tb.resetSubscribers(route)\n}\n\nfunc (b *Broker) getApp(route string) *App {\n\tb.appsMux.RLock()\n\tdefer b.appsMux.RUnlock()\n\treturn b.apps[route]\n}\n\nfunc (b *Broker) getApps() []*App {\n\tb.appsMux.RLock()\n\tdefer b.appsMux.RUnlock()\n\tvar apps []*App\n\tfor _, app := range b.apps {\n\t\tapps = append(apps, app)\n\t}\n\treturn apps\n}\n\nfunc (b *Broker) dropApp(route string) {\n\tb.appsMux.Lock()\n\tdelete(b.apps, route)\n\tb.appsMux.Unlock()\n\n\techo(Log{\"t\": \"app_drop\", \"route\": route})\n\n\t// Force-reload all browsers listening to this app\n\tb.resetSubscribers(route)\n}\n\nfunc parseMsgT(s []byte) MsgT {\n\tif len(s) == 1 {\n\t\tswitch s[0] {\n\t\tcase '*':\n\t\t\treturn patchMsgT\n\t\tcase '@':\n\t\t\treturn queryMsgT\n\t\tcase '+':\n\t\t\treturn watchMsgT\n\t\tcase '#':\n\t\t\treturn noopMsgT\n\t\t}\n\t}\n\treturn badMsgT\n}\n\nfunc parseMsg(s []byte) Msg {\n\t// protocol: t<sep>addr<sep>data\n\tparts := bytes.SplitN(s, msgSep, 3)\n\tif len(parts) == 3 {\n\t\tt, addr, data := parts[0], parts[1], parts[2]\n\t\taction := parseMsgT(t)\n\t\tif action == badMsgT {\n\t\t\treturn invalidMsg\n\t\t}\n\t\treturn Msg{action, string(addr), data}\n\t}\n\treturn invalidMsg\n}\n\nfunc (b *Broker) isUnicast(route string) bool {\n\tb.unicastsMux.RLock()\n\tdefer b.unicastsMux.RUnlock()\n\t_, ok := b.unicasts[route]\n\treturn ok\n}\n\n// patch broadcasts changes to clients and patches site data.\nfunc (b *Broker) patch(route string, data []byte) {\n\tb.publish <- Pub{route, data}\n\n\tif !b.noLog {\n\t\t// Write AOF entry with patch marker \"*\" as-is to log file.\n\t\t// FIXME bufio.Scanner.Scan() is not reliable if line length > 65536 chars,\n\t\t// so reading back in is unreliable.\n\t\tlog.Println(\"*\", route, string(data))\n\t}\n\n\t// Skip writes if storage is disabled or unicast apps without -editable\n\tif b.noStore || (!b.editable && b.isUnicast(route)) {\n\t\treturn\n\t}\n\n\tif err := b.site.patch(route, data); err != nil {\n\t\techo(Log{\"t\": \"broker_patch\", \"error\": err.Error()})\n\t}\n}\n\nfunc init() {\n\tvar err error\n\tif resetMsg, err = json.Marshal(OpsD{R: 1}); err != nil {\n\t\tpanic(\"failed marshaling reset message\")\n\t}\n}\n\nfunc (b *Broker) resetSubscribers(route string) {\n\tb.publish <- Pub{route, resetMsg}\n}\n\nfunc (b *Broker) resetClients(session *Session) {\n\tb.logout <- Pub{session.subject, resetMsg}\n\tapps := b.getApps()\n\tfor _, app := range apps {\n\t\tgo func(app *App) {\n\t\t\tapp.forward(\"\", session, logoutMsg)\n\t\t}(app)\n\t}\n}\n\n// run starts i/o between the broker and clients.\nfunc (b *Broker) run() {\n\tfor {\n\t\tselect {\n\t\tcase sub := <-b.subscribe:\n\t\t\tb.addClient(sub.route, sub.client)\n\t\tcase client := <-b.unsubscribe:\n\t\t\tb.dropClient(client)\n\t\tcase pub := <-b.publish:\n\t\t\tif clients, ok := b.clients[pub.route]; ok {\n\t\t\t\tb.sendAll(clients, pub.data)\n\t\t\t}\n\t\tcase pub := <-b.logout:\n\t\t\ttargets := make(map[*Client]interface{})\n\t\t\t// TODO speed up using another map?\n\t\t\tfor _, clients := range b.clients {\n\t\t\t\tfor client := range clients {\n\t\t\t\t\tif client.session.subject == pub.route {\n\t\t\t\t\t\ttargets[client] = nil\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tb.sendAll(targets, pub.data)\n\t\t}\n\t}\n}\n\nfunc (b *Broker) sendAll(clients map[*Client]interface{}, data []byte) {\n\tfor client := range clients {\n\t\tif !client.send(data) {\n\t\t\tb.dropClient(client)\n\t\t}\n\t}\n}\n\nfunc (b *Broker) addClient(route string, client *Client) {\n\tclients, ok := b.clients[route]\n\tif !ok {\n\t\tclients = make(map[*Client]interface{})\n\t\tb.clients[route] = clients\n\t}\n\tclients[client] = nil\n\n\tb.unicastsMux.Lock()\n\tb.unicasts[\"/\"+client.id] = true\n\tb.clientsByID[client.id] = client\n\tb.unicastsMux.Unlock()\n\n\techo(Log{\"t\": \"ui_add\", \"addr\": client.addr, \"route\": route})\n}\n\nfunc (b *Broker) dropClient(client *Client) {\n\tvar gc []string\n\n\tfor _, route := range client.routes {\n\t\tif clients, ok := b.clients[route]; ok {\n\t\t\tdelete(clients, client)\n\t\t\tif len(clients) == 0 {\n\t\t\t\tgc = append(gc, route)\n\t\t\t}\n\t\t}\n\t}\n\n\tclient.quit()\n\n\tfor _, route := range gc {\n\t\tdelete(b.clients, route)\n\t}\n\n\t// FIXME leak: this is not captured in the AOF logging; page will be recreated on hydration\n\tb.site.del(client.id) // delete transient page, if any.\n\n\tb.unicastsMux.Lock()\n\tdelete(b.unicasts, \"/\"+client.id)\n\tdelete(b.clientsByID, client.id)\n\tb.unicastsMux.Unlock()\n\n\techo(Log{\"t\": \"ui_drop\", \"client_id\": client.id})\n}\n\n// routes returns a sorted slice of routes managed by this broker.\nfunc (b *Broker) routes() []string {\n\tb.appsMux.RLock()\n\tdefer b.appsMux.RUnlock()\n\n\tapps := b.apps\n\n\troutes := make([]string, len(apps))\n\ti := 0\n\tfor route := range apps {\n\t\troutes[i] = route\n\t\ti++\n\t}\n\n\tsort.Strings(routes)\n\treturn routes\n}\n"
        },
        {
          "name": "cache.go",
          "type": "blob",
          "size": 3.30859375,
          "content": "// Copyright 2020 H2O.ai, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage wave\n\nimport (\n\t\"bytes\"\n\t\"net/http\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"github.com/h2oai/wave/pkg/keychain\"\n)\n\n// Shard represents a collection of key-value pairs.\ntype Shard struct {\n\tsync.RWMutex\n\titems map[string][]byte\n}\n\n// Cache represents a collection of shards.\ntype Cache struct {\n\tsync.RWMutex\n\tprefix         string\n\tkeychain       *keychain.Keychain\n\tshards         map[string]*Shard\n\tmaxRequestSize int64\n}\n\nfunc newCache(prefix string, keychain *keychain.Keychain, maxRequestSize int64) *Cache {\n\treturn &Cache{\n\t\tprefix:         prefix,\n\t\tkeychain:       keychain,\n\t\tshards:         make(map[string]*Shard),\n\t\tmaxRequestSize: maxRequestSize,\n\t}\n}\n\nfunc (c *Cache) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tif !c.keychain.Guard(w, r) {\n\t\treturn\n\t}\n\n\ts, k := c.parse(r.URL.Path)\n\tswitch r.Method {\n\tcase http.MethodGet:\n\t\tif len(k) > 0 {\n\t\t\tif v, ok := c.get(s, k); ok {\n\t\t\t\tw.Write(v)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tif v, ok := c.keys(s); ok {\n\t\t\t\tw.Write(v)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\thttp.Error(w, http.StatusText(http.StatusNotFound), http.StatusNotFound)\n\tcase http.MethodPut:\n\t\tv, err := readRequestWithLimit(w, r.Body, c.maxRequestSize)\n\t\tif err != nil {\n\t\t\techo(Log{\"t\": \"read cache request body\", \"error\": err.Error()})\n\t\t\tif isRequestTooLarge(err) {\n\t\t\t\thttp.Error(w, http.StatusText(http.StatusRequestEntityTooLarge), http.StatusRequestEntityTooLarge)\n\t\t\t\treturn\n\t\t\t}\n\t\t\thttp.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\tc.set(s, k, v)\n\n\tcase http.MethodDelete:\n\t\tc.del(s, k)\n\n\tdefault:\n\t\thttp.Error(w, http.StatusText(http.StatusMethodNotAllowed), http.StatusMethodNotAllowed)\n\t}\n}\n\nfunc (c *Cache) at(s string) *Shard {\n\tc.RLock()\n\tshard := c.shards[s]\n\tc.RUnlock()\n\treturn shard\n}\n\nfunc (c *Cache) get(s, k string) ([]byte, bool) {\n\tshard := c.at(s)\n\tif shard == nil {\n\t\treturn nil, false\n\t}\n\tshard.RLock()\n\tv, ok := shard.items[k]\n\tshard.RUnlock()\n\treturn v, ok\n}\n\nfunc (c *Cache) keys(s string) ([]byte, bool) {\n\tshard := c.at(s)\n\tif shard == nil {\n\t\treturn nil, false\n\t}\n\tshard.RLock()\n\tdefer shard.RUnlock()\n\n\tvar b bytes.Buffer\n\tfor k := range shard.items {\n\t\tb.WriteString(k)\n\t\tb.WriteByte('\\n')\n\t}\n\treturn b.Bytes(), true\n}\n\nfunc (c *Cache) set(s, k string, v []byte) {\n\tif shard := c.at(s); shard != nil {\n\t\tshard.Lock()\n\t\tshard.items[k] = v\n\t\tshard.Unlock()\n\t\treturn\n\t}\n\tc.Lock()\n\tc.shards[s] = &Shard{items: map[string][]byte{k: v}}\n\tc.Unlock()\n}\n\nfunc (c *Cache) del(s, k string) {\n\tif shard := c.at(s); shard != nil {\n\t\tshard.Lock()\n\t\tdelete(shard.items, k)\n\t\tshard.Unlock()\n\t}\n}\n\nfunc (c *Cache) parse(url string) (string, string) {\n\tp := strings.SplitN(strings.TrimPrefix(url, c.prefix), \"/\", 2) // \"/_c/foo/bar/baz\" -> \"foo\", \"bar/baz\"\n\tif len(p) == 2 {\n\t\treturn p[0], p[1]\n\t}\n\treturn p[0], \"\"\n}\n"
        },
        {
          "name": "card.go",
          "type": "blob",
          "size": 6.7109375,
          "content": "// Copyright 2020 H2O.ai, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage wave\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n// Buf represents a generic dictionary-like buffer.\ntype Buf interface {\n\t// get cursor at key k\n\tget(k string) (Cur, bool)\n\t// overwrite all records\n\tput(v any)\n\t// set record at key k\n\tset(k string, v any)\n\t// dump contents\n\tdump() BufD\n}\n\nfunc loadBuf(ns *Namespace, b BufD) Buf {\n\tif b.C != nil {\n\t\treturn loadCycBuf(ns, b.C)\n\t}\n\tif b.F != nil {\n\t\treturn loadFixBuf(ns, b.F)\n\t}\n\tif b.M != nil {\n\t\treturn loadMapBuf(ns, b.M)\n\t}\n\tif b.L != nil {\n\t\treturn loadListBuf(ns, b.L)\n\t}\n\treturn nil\n}\n\n// Card represents an item on a Page, and holds attributes and data for rendering views.\ntype Card struct {\n\tdata             map[string]any\n\tnameComponentMap map[string]any // Cache for cards with items, secondary_items or buttons.\n}\n\n// Tmp placeholder for key-buffer pairs.\ntype BufEntry struct {\n\tk   string\n\tbuf interface{}\n}\n\nconst dataPrefix = \"~\"\n\nfunc loadCard(ns *Namespace, c CardD) *Card {\n\tcard := &Card{\n\t\tdata:             make(map[string]any),\n\t\tnameComponentMap: nil,\n\t}\n\tks := make([]string, 1)         // to avoid allocation during card.set() below\n\tbufAttrs := make([]BufEntry, 0) // Go does not guarantee map iteration order, set buffers after all other attributes.\n\n\tfor k, v := range c.D {\n\t\tif strings.HasPrefix(k, dataPrefix) {\n\t\t\tif f, ok := v.(float64); ok {\n\t\t\t\ti := int(f)\n\t\t\t\tif i >= 0 && i < len(c.B) {\n\t\t\t\t\tbufAttrs = append(bufAttrs, BufEntry{strings.TrimPrefix(k, dataPrefix), loadBuf(ns, c.B[i])})\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif k == \"items\" || k == \"secondary_items\" || k == \"buttons\" || k == \"commands\" {\n\t\t\tif card.nameComponentMap == nil {\n\t\t\t\tcard.nameComponentMap = make(map[string]any)\n\t\t\t}\n\t\t\tfillNameComponentMap(card.nameComponentMap, v)\n\t\t}\n\t\tks[0] = k\n\t\tcard.set(ks, v)\n\t}\n\tfor b := range bufAttrs {\n\t\tks[0] = bufAttrs[b].k\n\t\tcard.set(ks, bufAttrs[b].buf)\n\t}\n\treturn card\n}\n\nfunc (c *Card) set(ks []string, v any) {\n\tswitch len(ks) {\n\tcase 0: // should not get here; outer interpreter loop will clobber this card.\n\t\treturn\n\tcase 1: // .foo = bar\n\t\tp := ks[0]\n\t\tif ib, ok := c.data[p]; ok { // TODO can optimize by duplicating all bufs in a card.bufs map\n\t\t\tif b, ok := ib.(Buf); ok { // avoid clobbering buffers; overwrite instead.\n\t\t\t\tb.put(v)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tkeys := strings.Split(p, \".\")\n\t\tvar x any = c.data\n\t\t// Get the object even if nested.\n\t\tfor _, key := range keys[:len(keys)-1] {\n\t\t\tx = get(x, key)\n\t\t}\n\n\t\tif x, ok := x.(map[string]any); ok {\n\t\t\tlastKey := keys[len(keys)-1]\n\t\t\tif v == nil {\n\t\t\t\tdelete(x, lastKey)\n\t\t\t} else {\n\t\t\t\tx[lastKey] = v\n\t\t\t}\n\t\t}\n\tdefault: // .foo.bar.baz = qux\n\t\tvar x any = c.data\n\n\t\tstartIdx := 0\n\t\tif _, ok := c.data[ks[0]]; !ok && c.nameComponentMap[ks[0]] != nil {\n\t\t\t// By-name access.\n\t\t\tx = c.nameComponentMap[ks[0]]\n\t\t\tstartIdx = 1\n\t\t}\n\t\tfor _, k := range ks[startIdx : len(ks)-1] {\n\t\t\tx = get(x, k)\n\t\t}\n\n\t\tp := ks[len(ks)-1]\n\t\tset(x, p, v)\n\t}\n}\n\nfunc set(ix any, k string, v any) {\n\tswitch x := ix.(type) {\n\tcase Buf:\n\t\tx.set(k, v)\n\tcase Cur:\n\t\tx.set(k, v)\n\tcase map[string]any:\n\t\tif v == nil {\n\t\t\tdelete(x, k)\n\t\t} else {\n\t\t\tx[k] = v\n\t\t}\n\tcase []any:\n\t\tif i, err := strconv.Atoi(k); err == nil {\n\t\t\tif i >= 0 && i < len(x) {\n\t\t\t\tx[i] = v\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc get(ix any, k string) any {\n\tswitch x := ix.(type) {\n\tcase Buf:\n\t\tif r, ok := x.get(k); ok {\n\t\t\treturn r\n\t\t}\n\tcase Cur:\n\t\treturn x.get(k)\n\tcase map[string]any:\n\t\tif v, ok := x[k]; ok {\n\t\t\treturn v\n\t\t}\n\tcase []any:\n\t\tif i, err := strconv.Atoi(k); err == nil {\n\t\t\tif i >= 0 && i < len(x) {\n\t\t\t\treturn x[i]\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (c *Card) dump() CardD {\n\tdata := make(map[string]any)\n\tvar bufs []BufD\n\n\t// Look for nested buffers within form_card.\n\tif v, ok := c.data[\"view\"]; ok {\n\t\tif v, ok := v.(string); ok && v == \"form\" {\n\t\t\tfillFormCardBufs(c.data, data, &bufs, make([]string, 0))\n\t\t}\n\t}\n\n\tfor k, iv := range c.data {\n\t\tif v, ok := iv.(Buf); ok {\n\t\t\tdata[dataPrefix+k] = len(bufs)\n\t\t\tbufs = append(bufs, v.dump())\n\t\t} else {\n\t\t\tdata[k] = deepClone(iv)\n\t\t}\n\t}\n\treturn CardD{data, bufs}\n}\n\nfunc deepClone(ix any) any {\n\tswitch x := ix.(type) {\n\tcase map[string]any:\n\t\tm := make(map[string]any)\n\t\tfor k, v := range x {\n\t\t\tm[k] = deepClone(v)\n\t\t}\n\t\treturn m\n\tcase []any:\n\t\ts := make([]any, len(x))\n\t\tfor i, v := range x {\n\t\t\ts[i] = deepClone(v)\n\t\t}\n\t\treturn s\n\t}\n\treturn ix\n}\n\nfunc fillNameComponentMap(m map[string]any, wrappedItems any) {\n\tfor _, wrappedItem := range wrappedItems.([]any) {\n\t\t// Form components are always wrapped in a single key object so this is O(1) not O(n).\n\t\tfor _, item := range wrappedItem.(map[string]any) {\n\n\t\t\tvar component map[string]any\n\t\t\tif i, ok := item.(map[string]any); ok {\n\t\t\t\tcomponent = i\n\t\t\t} else {\n\t\t\t\t// Handle non-form components, e.g. ui.tab.\n\t\t\t\tcomponent = wrappedItem.(map[string]any)\n\t\t\t}\n\t\t\tif name, ok := component[\"name\"]; ok {\n\t\t\t\tif n, ok := name.(string); ok {\n\t\t\t\t\tm[n] = component\n\t\t\t\t}\n\t\t\t}\n\t\t\tif items, ok := component[\"items\"]; ok {\n\t\t\t\tfillNameComponentMap(m, items)\n\t\t\t}\n\t\t\tif secondaryItems, ok := component[\"secondary_items\"]; ok {\n\t\t\t\tfillNameComponentMap(m, secondaryItems)\n\t\t\t}\n\t\t\tif buttons, ok := component[\"buttons\"]; ok {\n\t\t\t\tfillNameComponentMap(m, buttons)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc fillFormCardBufs(data map[string]any, outData map[string]any, bufs *[]BufD, keys []string) {\n\titems, ok := data[\"items\"]\n\tif !ok {\n\t\treturn\n\t}\n\titemsSlice, ok := items.([]any)\n\tif !ok {\n\t\treturn\n\t}\n\n\tkeys = append(keys, \"items\")\n\tfor idx, item := range itemsSlice {\n\t\titemMap, ok := item.(map[string]any)\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\t\tif v, ok := itemMap[\"inline\"]; ok {\n\t\t\tif v, ok := v.(map[string]any); ok {\n\t\t\t\tkeys = append(keys, strconv.Itoa(idx), \"inline\")\n\t\t\t\tfillFormCardBufs(v, outData, bufs, keys)\n\t\t\t\tkeys = keys[:len(keys)-2]\n\t\t\t}\n\t\t}\n\t\tvisualizationMap, ok := item.(map[string]any)\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\t\tv, ok := visualizationMap[\"visualization\"]\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\t\tvalueMap, ok := v.(map[string]any)\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\t\tb, ok := valueMap[\"data\"]\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\t\tif b, ok := b.(Buf); ok {\n\t\t\tkey := fmt.Sprintf(\"%s.%d.visualization.data\", strings.Join(keys, \".\"), idx)\n\t\t\toutData[dataPrefix+key] = len(*bufs)\n\t\t\t*bufs = append(*bufs, b.dump())\n\t\t}\n\t}\n\t//lint:ignore SA4006 this function is recursive so mutation is necessary.\n\tkeys = keys[:len(keys)-1]\n}\n"
        },
        {
          "name": "client.go",
          "type": "blob",
          "size": 9.21484375,
          "content": "// Copyright 2020 H2O.ai, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage wave\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/google/uuid\"\n\t\"github.com/gorilla/websocket\"\n)\n\nconst (\n\twriteWait      = 10 * time.Second // Time allowed to write a message to the peer.\n\tmaxMessageSize = 1 * 1024 * 1024  // bytes Maximum message size allowed from peer.\n\t// TODO: Refactor into iota.\n\tSTATE_CREATED    = \"CREATED\"\n\tSTATE_TIMEOUT    = \"TIMEOUT\"\n\tSTATE_LISTEN     = \"LISTEN\"\n\tSTATE_RECONNECT  = \"RECONNECT\"\n\tSTATE_DISCONNECT = \"DISCONNECT\"\n\tSTATE_CLOSED     = \"CLOSED\"\n)\n\nvar (\n\tnewline       = []byte{'\\n'}\n\tnotFoundMsg   = []byte(`{\"e\":\"not_found\"}`)\n\tdisconnectMsg = []byte(`{\"data\": {\"\":{\"@system\":{\"client_disconnect\":true}}}}`)\n\tclearStateMsg = []byte(`{\"c\":1}`)\n)\n\n// BootMsg represents the initial message sent to an app when a client first connects to it.\ntype BootMsg struct {\n\tData struct {\n\t\tHash           string `json:\"#,omitempty\"`                        // location hash\n\t\tSubmissionName string `json:\"__wave_submission_name__,omitempty\"` // mark the cause of the serve invocation\n\t} `json:\"data\"`\n\tHeaders http.Header `json:\"headers\"` // forwarded headers\n}\n\n// Client represent a websocket (UI) client.\ntype Client struct {\n\tid               string          // unique id\n\tauth             *Auth           // auth provider, might be nil\n\taddr             string          // remote IP:port, used for logging only\n\tsession          *Session        // end-user session\n\tbroker           *Broker         // broker\n\tconn             *websocket.Conn // connection\n\troutes           []string        // watched routes\n\tdata             chan []byte     // send data\n\teditable         bool            // allow editing? // TODO move to user; tie to role\n\tbaseURL          string          // URL prefix of the Wave server\n\theader           *http.Header    // forwarded headers from the WS connection\n\tappPath          string          // path of the app this client is connected to, doesn't change throughout WS lifetime\n\tpingInterval     time.Duration\n\treconnectTimeout time.Duration\n\tlock             *sync.Mutex\n\tstate            string\n}\n\n// TODO: Refactor some of the params into a Config struct.\nfunc newClient(addr string, auth *Auth, session *Session, broker *Broker, conn *websocket.Conn, editable bool,\n\tbaseURL string, header *http.Header, pingInterval time.Duration, reconnectTimeout time.Duration) *Client {\n\tid := uuid.New().String()\n\treturn &Client{id, auth, addr, session, broker, conn, nil, make(chan []byte, 256),\n\t\teditable, baseURL, header, \"\", pingInterval, reconnectTimeout, &sync.Mutex{}, STATE_CREATED}\n}\n\nfunc (c *Client) refreshToken() error {\n\tif c.auth != nil && c.session.token != nil {\n\t\t// TODO: use more meaningful context, e.g. context of current message\n\t\tctx, cancel := context.WithTimeout(context.TODO(), 10*time.Second)\n\t\tdefer cancel()\n\n\t\ttoken, err := c.auth.ensureValidOAuth2Token(ctx, c.session.token)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tc.session.token = token\n\t}\n\treturn nil\n}\n\nfunc (c *Client) setState(newState string) {\n\tc.lock.Lock()\n\tc.state = newState\n\tc.lock.Unlock()\n}\n\nfunc (c *Client) listen() {\n\tdefer func() {\n\t\tc.lock.Lock()\n\t\techo(Log{\"t\": \"ws_disconnect\", \"client\": c.id, \"state\": c.state})\n\t\tdefer c.lock.Unlock()\n\t\tif c.state != STATE_DISCONNECT {\n\t\t\treturn\n\t\t}\n\t\t// This defer runs to completion. If the client drops, reconnects and drops out again, ignore first drop timeout.\n\t\ttimeoutID := STATE_TIMEOUT + uuid.New().String()\n\t\tc.state = timeoutID\n\t\tc.lock.Unlock()\n\n\t\tselect {\n\t\t// Send disconnect message only if client doesn't reconnect within the specified timeframe.\n\t\tcase <-time.After(c.reconnectTimeout):\n\t\t\tc.lock.Lock()\n\t\t\tif c.state != timeoutID {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tapp := c.broker.getApp(c.appPath)\n\t\t\tif app != nil {\n\t\t\t\tapp.forward(c.id, c.session, disconnectMsg)\n\t\t\t\tif err := app.disconnect(c.id); err != nil {\n\t\t\t\t\techo(Log{\"t\": \"disconnect\", \"client\": c.addr, \"route\": c.appPath, \"err\": err.Error()})\n\t\t\t\t}\n\t\t\t}\n\n\t\t\techo(Log{\"t\": \"client_unsubscribe\", \"client\": c.id})\n\t\t\tc.broker.unsubscribe <- c\n\t\t\tc.state = STATE_CLOSED\n\t\t\treturn\n\t\t}\n\t}()\n\t// Time allowed to read the next pong message from the peer. Must be greater than ping interval.\n\tpongWait := 10 * c.pingInterval / 9\n\tc.conn.SetReadLimit(maxMessageSize)\n\tc.conn.SetReadDeadline(time.Now().Add(pongWait))\n\tc.conn.SetPongHandler(func(string) error {\n\t\tc.conn.SetReadDeadline(time.Now().Add(pongWait))\n\t\treturn nil\n\t})\n\tfor {\n\t\t_, msg, err := c.conn.ReadMessage()\n\t\tif err != nil {\n\t\t\tif websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) {\n\t\t\t\techo(Log{\"t\": \"socket_read\", \"client\": c.addr, \"err\": err.Error()})\n\t\t\t}\n\t\t\tc.setState(STATE_DISCONNECT)\n\t\t\tbreak\n\t\t}\n\n\t\tif err := c.refreshToken(); err != nil {\n\t\t\t// token refresh failed, this is not fatal err, try next time\n\t\t\t// TODO kick user out?\n\t\t\techo(Log{\"t\": \"refresh_oauth2_token\", \"client\": c.addr, \"err\": err.Error()})\n\t\t}\n\n\t\tif c.session != nil && c.auth != nil {\n\t\t\tif err := c.session.touch(c.auth.conf.InactivityTimeout); err != nil {\n\t\t\t\tif msg, err := json.Marshal(OpsD{U: c.baseURL + \"_auth/logout\"}); err == nil {\n\t\t\t\t\tc.send(msg)\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\tm := parseMsg(msg)\n\t\tm.addr = resolveURL(m.addr, c.baseURL)\n\t\tswitch m.t {\n\t\tcase patchMsgT:\n\t\t\tif c.editable { // allow only if editing is enabled\n\t\t\t\tc.broker.patch(m.addr, m.data)\n\t\t\t}\n\t\tcase queryMsgT:\n\t\t\tapp := c.broker.getApp(m.addr)\n\t\t\tif app == nil {\n\t\t\t\techo(Log{\"t\": \"query\", \"client\": c.addr, \"route\": m.addr, \"error\": \"service unavailable\"})\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tapp.forward(c.id, c.session, []byte(\"{\\\"data\\\":\"+string(m.data)+\"}\"))\n\n\t\t\t// Remove any dirty UI state if broadcast or multicast.\n\t\t\tif app.mode == multicastMode {\n\t\t\t\tc.broker.sendAll(c.broker.clients[\"/\"+c.session.subject], clearStateMsg)\n\t\t\t}\n\t\t\tif app.mode == broadcastMode {\n\t\t\t\tc.broker.sendAll(c.broker.clients[app.route], clearStateMsg)\n\t\t\t}\n\t\tcase watchMsgT:\n\t\t\tc.lock.Lock()\n\t\t\tstate := c.state\n\t\t\tc.lock.Unlock()\n\t\t\tif state != STATE_CREATED {\n\t\t\t\tc.lock.Lock()\n\t\t\t\tc.state = STATE_LISTEN\n\t\t\t\tc.lock.Unlock()\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tc.subscribe(m.addr)                             // subscribe even if page is currently NA\n\t\t\tif app := c.broker.getApp(m.addr); app != nil { // do we have an app handling this route?\n\t\t\t\tc.appPath = m.addr\n\t\t\t\tswitch app.mode {\n\t\t\t\tcase unicastMode:\n\t\t\t\t\tc.subscribe(\"/\" + c.id) // client-level\n\t\t\t\tcase multicastMode:\n\t\t\t\t\tc.subscribe(\"/\" + c.session.subject) // user-level\n\t\t\t\t}\n\n\t\t\t\tboot := BootMsg{Headers: *c.header}\n\n\t\t\t\tif len(m.data) > 0 { // location hash\n\t\t\t\t\tboot.Data.Hash = string(m.data)\n\t\t\t\t\tboot.Data.SubmissionName = \"#\"\n\t\t\t\t}\n\n\t\t\t\tbody, err := json.Marshal(boot)\n\t\t\t\tif err != nil {\n\t\t\t\t\techo(Log{\"t\": \"watch\", \"client\": c.addr, \"route\": m.addr, \"error\": \"failed marshaling body\"})\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tapp.forward(c.id, c.session, body)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif headers, err := json.Marshal(OpsD{M: &Meta{Username: c.session.username, Editor: c.editable}}); err == nil {\n\t\t\t\tc.send(headers)\n\t\t\t}\n\n\t\t\tif page := c.broker.site.at(m.addr); page != nil { // is page?\n\t\t\t\tif data := page.marshal(); data != nil {\n\t\t\t\t\tc.send(data)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tc.send(notFoundMsg)\n\t\t}\n\t}\n}\n\nfunc (c *Client) subscribe(route string) {\n\tc.routes = append(c.routes, route)\n\tc.broker.subscribe <- Sub{route, c}\n}\n\nfunc (c *Client) send(data []byte) bool {\n\tselect {\n\tcase c.data <- data:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc (c *Client) flush() {\n\tticker := time.NewTicker(c.pingInterval)\n\tdefer func() {\n\t\tticker.Stop()\n\t\tc.conn.Close()\n\t\tc.lock.Unlock()\n\t}()\n\tfor {\n\t\tselect {\n\t\tcase data, ok := <-c.data:\n\t\t\t// An alternative to the mutex here would be a new channel for closing the connection so it does not race with reconnect.\n\t\t\tc.lock.Lock()\n\t\t\tc.conn.SetWriteDeadline(time.Now().Add(writeWait))\n\t\t\tif !ok {\n\t\t\t\t// broker closed the channel.\n\t\t\t\tc.conn.WriteMessage(websocket.CloseMessage, []byte{})\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tw, err := c.conn.NextWriter(websocket.TextMessage)\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tw.Write(data)\n\n\t\t\t// push queued messages, if any\n\t\t\tn := len(c.data)\n\t\t\tfor i := 0; i < n; i++ {\n\t\t\t\tw.Write(newline)\n\t\t\t\tw.Write(<-c.data)\n\t\t\t}\n\n\t\t\tif err := w.Close(); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tc.lock.Unlock()\n\t\tcase <-ticker.C:\n\t\t\tc.lock.Lock()\n\t\t\tc.conn.SetWriteDeadline(time.Now().Add(writeWait))\n\t\t\tif err := c.conn.WriteMessage(websocket.PingMessage, nil); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tc.lock.Unlock()\n\t\t}\n\t}\n}\n\nfunc (c *Client) quit() {\n\t// FIXME: Gather more info about how can the same client be closed twice and fix this properly.\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\techo(Log{\"t\": \"client_quit\", \"client\": c.id, \"msg\": \"Report at https://github.com/h2oai/wave/issues together with full server log.\", \"err\": fmt.Errorf(\"%v\", r).Error()})\n\t\t}\n\t}()\n\tclose(c.data)\n}\n"
        },
        {
          "name": "cmd",
          "type": "tree",
          "content": null
        },
        {
          "name": "conf.go",
          "type": "blob",
          "size": 9.869140625,
          "content": "// Copyright 2020 H2O.ai, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage wave\n\nimport (\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/h2oai/wave/pkg/keychain\"\n)\n\n// ServerConf represents Server configuration options.\ntype ServerConf struct {\n\tVersion              string\n\tBuildDate            string\n\tListen               string\n\tBaseURL              string\n\tWebDir               string\n\tDataDir              string\n\tPublicDirs           []string\n\tPrivateDirs          []string\n\tKeychain             *keychain.Keychain\n\tInit                 string\n\tCompact              string\n\tCertFile             string\n\tSkipCertVerification bool\n\tKeyFile              string\n\tHeader               http.Header\n\tEditable             bool\n\tMaxRequestSize       int64\n\tMaxCacheRequestSize  int64\n\tProxy                bool\n\tMaxProxyRequestSize  int64\n\tMaxProxyResponseSize int64\n\tNoStore              bool\n\tNoLog                bool\n\tIDE                  bool\n\tDebug                bool\n\tAuth                 *AuthConf\n\tForwardedHeaders     map[string]bool\n\tKeepAppLive          bool\n\tPingInterval         time.Duration\n\tReconnectTimeout     time.Duration\n\tAllowedOrigins       map[string]bool\n}\n\ntype AuthConf struct {\n\tClientID              string\n\tClientSecret          string\n\tProviderURL           string\n\tRedirectURL           string\n\tEndSessionURL         string\n\tPostLogoutRedirectURL string\n\tScopes                []string\n\tURLParameters         [][]string\n\tSkipLogin             bool\n\tSessionExpiry         time.Duration\n\tInactivityTimeout     time.Duration\n}\n\ntype Conf struct {\n\tVersion               bool   `cfg:\"version\" env:\"H2O_WAVE_VERSION\" cfgDefault:\"false\"`\n\tListen                string `cfg:\"listen\" env:\"H2O_WAVE_LISTEN\" cfgDefault:\":10101\" cfgHelper:\"listen on this address\"`\n\tBaseUrl               string `cfg:\"base-url\" env:\"H2O_WAVE_BASE_URL\" cfgDefault:\"/\" cfgHelper:\"the base URL (path prefix) to be used for resolving relative URLs (e.g. /foo/ or /foo/bar/, without the host)\"`\n\tWebDir                string `cfg:\"web-dir\" env:\"H2O_WAVE_WEB_DIR\" cfgDefault:\"./www\" cfgHelper:\"directory to serve web assets from, hosted at /\"`\n\tDataDir               string `cfg:\"data-dir\" env:\"H2O_WAVE_DATA_DIR\" cfgDefault:\"./data\" cfgHelper:\"directory to store site data\"`\n\tPublicDirs            string `cfg:\"public-dir\" env:\"H2O_WAVE_PUBLIC_DIR\" cfgDefault:\"\" cfgHelper:\"additional directory to serve files from, in the format \\\"[url-path]@[filesystem-path]\\\", e.g. \\\"/public/files/@/some/local/path\\\" will host /some/local/path/foo.txt at /public/files/foo.txt; multiple directory mappings allowed\"`\n\tPrivateDirs           string `cfg:\"private-dir\" env:\"H2O_WAVE_PRIVATE_DIR\" cfgDefault:\"\" cfgHelper:\"additional directory to serve files from (authenticated users only), in the format \\\"[url-path]@[filesystem-path]\\\", e.g. \\\"/public/files/@/some/local/path\\\" will host /some/local/path/foo.txt at /public/files/foo.txt; multiple directory mappings allowed\"`\n\tAccessKeyID           string `cfg:\"access-key-id\" env:\"H2O_WAVE_ACCESS_KEY_ID\" cfgDefault:\"access_key_id\" cfgHelper:\"default API access key ID\"`\n\tAccessKeySecret       string `cfg:\"access-key-secret\" env:\"H2O_WAVE_ACCESS_KEY_SECRET\" cfgDefault:\"access_key_secret\" cfgHelper:\"default API access key secret\"`\n\tAccessKeyFile         string `cfg:\"access-keychain\" env:\"H2O_WAVE_ACCESS_KEYCHAIN\" cfgDefault:\".wave-keychain\" cfgHelper:\"path to file containing API access keys\"`\n\tCreateAccessKey       bool   `cfg:\"create-access-key\" env:\"H2O_WAVE_CREATE_ACCESS_KEY\" cfgDefault:\"false\" cfgHelper:\"generate and add a new API access key ID and secret pair to the keychain\"`\n\tListAccessKeys        bool   `cfg:\"list-access-keys\" env:\"H2O_WAVE_LIST_ACCESS_KEYS\" cfgDefault:\"false\" cfgHelper:\"list all the access key IDs in the keychain\"`\n\tRemoveAccessKeyID     string `cfg:\"remove-access-key\" env:\"H2O_WAVE_REMOVE_ACCESS_KEY\" cfgDefault:\"\" cfgHelper:\"remove the specified API access key ID from the keychain\"`\n\tInit                  string `cfg:\"init\" env:\"H2O_WAVE_INIT\" cfgDefault:\"\" cfgHelper:\"initialize site content from AOF log\"`\n\tCompact               string `cfg:\"compact\" env:\"H2O_WAVE_COMPACT\" cfgDefault:\"\" cfgHelper:\"compact AOF log\"`\n\tCertFile              string `cfg:\"tls-cert-file\" env:\"H2O_WAVE_TLS_CERT_FILE\" cfgDefault:\"\" cfgHelper:\"path to certificate file (TLS only)\"`\n\tKeyFile               string `cfg:\"tls-key-file\" env:\"H2O_WAVE_TLS_KEY_FILE\" cfgDefault:\"\" cfgHelper:\"path to private key file (TLS only)\"`\n\tSkipCertVerification  bool   `cfg:\"no-tls-verify\" env:\"H2O_WAVE_NO_TLS_VERIFY\" cfgDefault:\"false\" cfgHelper:\"do not verify TLS certificates during external communication - DO NOT USE IN PRODUCTION\"`\n\tHttpHeadersFile       string `cfg:\"http-headers-file\" env:\"H2O_WAVE_HTTP_HEADERS_FILE\" cfgDefault:\"\" cfgHelper:\"path to a MIME-formatted file containing additional HTTP headers to add to responses from the server\"`\n\tForwardedHttpHeaders  string `cfg:\"forwarded-http-headers\" env:\"H2O_WAVE_FORWARDED_HTTP_HEADERS\" cfgDefault:\"*\" cfgHelper:\"comma-separated list of case insesitive HTTP header keys to forward to the Wave app from the browser WS connection. If not specified, defaults to '*' - all headers are allowed. If set to an empty string, no headers are forwarded.\"`\n\tEditable              bool   `cfg:\"editable\" env:\"H2O_WAVE_EDITABLE\" cfgDefault:\"false\" cfgHelper:\"allow users to edit web pages\"`\n\tMaxRequestSize        string `cfg:\"max-request-size\" env:\"H2O_WAVE_MAX_REQUEST_SIZE\" cfgDefault:\"5M\" cfgHelper:\"maximum allowed size of HTTP requests to the server (e.g. 5M or 5MB or 5MiB)\"`\n\tMaxCacheRequestSize   string `cfg:\"max-cache-request-size\" env:\"H2O_WAVE_MAX_CACHE_REQUEST_SIZE\" cfgDefault:\"5M\" cfgHelper:\"maximum allowed size of HTTP requests to the server cache (e.g. 5M or 5MB or 5MiB)\"`\n\tProxy                 bool   `cfg:\"proxy\" env:\"H2O_WAVE_PROXY\" cfgDefault:\"false\" cfgHelper:\"enable HTTP proxy (for IDE / language server support only - not recommended for internet-facing websites)\"`\n\tMaxProxyRequestSize   string `cfg:\"max-proxy-request-size\" env:\"H2O_WAVE_MAX_PROXY_REQUEST_SIZE\" cfgDefault:\"5M\" cfgHelper:\"maximum allowed size of proxied HTTP requests (e.g. 5M or 5MB or 5MiB)\"`\n\tMaxProxyResponseSize  string `cfg:\"max-proxy-response-size\" env:\"H2O_WAVE_MAX_PROXY_RESPONSE_SIZE\" cfgDefault:\"5M\" cfgHelper:\"maximum allowed size of proxied HTTP responses (e.g. 5M or 5MB or 5MiB)\"`\n\tSessionExpiry         string `cfg:\"session-expiry\" env:\"H2O_WAVE_SESSION_EXPIRY\" cfgDefault:\"720h\" cfgHelper:\"session cookie lifetime duration (e.g. 1800s or 30m or 0.5h)\"`\n\tInactivityTimeout     string `cfg:\"session-inactivity-timeout\" env:\"H2O_WAVE_SESSION_INACTIVITY_TIMEOUT\" cfgDefault:\"30m\" cfgHelper:\"session inactivity timeout duration (e.g. 1800s or 30m or 0.5h)\"`\n\tPingInterval          string `cfg:\"ping-interval\" env:\"H2O_WAVE_PING_INTERVAL\" cfgDefault:\"50s\" cfgHelper:\"how often should ping messages be sent (e.g. 60s or 1m or 0.1h) to keep the websocket connection alive (default 50s)\"`\n\tNoStore               bool   `cfg:\"no-store\" env:\"H2O_WAVE_NO_STORE\" cfgDefault:\"false\" cfgHelper:\"disable storage (scripts and multicast/broadcast apps will not work)\"`\n\tNoLog                 bool   `cfg:\"no-log\" env:\"H2O_WAVE_NO_LOG\" cfgDefault:\"false\" cfgHelper:\"disable AOF logging (connect/disconnect and diagnostic logging messages are not disabled)\"`\n\tDebug                 bool   `cfg:\"debug\" env:\"H2O_WAVE_DEBUG\" cfgDefault:\"false\" cfgHelper:\"enable debug mode (profiling, inspection, etc.)\"`\n\tClientID              string `cfg:\"oidc-client-id\" env:\"H2O_WAVE_OIDC_CLIENT_ID\" cfgDefault:\"\" cfgHelper:\"OIDC client ID\"`\n\tClientSecret          string `cfg:\"oidc-client-secret\" env:\"H2O_WAVE_OIDC_CLIENT_SECRET\" cfgDefault:\"\" cfgHelper:\"OIDC client secret\"`\n\tProviderUrl           string `cfg:\"oidc-provider-url\" env:\"H2O_WAVE_OIDC_PROVIDER_URL\" cfgDefault:\"\" cfgHelper:\"OIDC provider URL\"`\n\tRedirectUrl           string `cfg:\"oidc-redirect-url\" env:\"H2O_WAVE_OIDC_REDIRECT_URL\" cfgDefault:\"\" cfgHelper:\"OIDC redirect URL\"`\n\tEndSessionUrl         string `cfg:\"oidc-end-session-url\" env:\"H2O_WAVE_OIDC_END_SESSION_URL\" cfgDefault:\"\" cfgHelper:\"OIDC end session URL\"`\n\tPostLogoutRedirectUrl string `cfg:\"oidc-post-logout-redirect-url\" env:\"H2O_WAVE_OIDC_POST_LOGOUT_REDIRECT_URL\" cfgDefault:\"\" cfgHelper:\"OIDC post logout redirect URL\"`\n\tRawAuthScopes         string `cfg:\"oidc-scopes\" env:\"H2O_WAVE_OIDC_SCOPES\" cfgDefault:\"openid,profile\" cfgHelper:\"OIDC scopes, comma-separated (default \\\"openid,profile\\\")\"`\n\tRawAuthURLParams      string `cfg:\"oidc-auth-url-params\" env:\"H2O_WAVE_OIDC_AUTH_URL_PARAMS\" cfgDefault:\"\" cfgHelper:\"additional URL parameters to pass during OIDC authorization, in the format \\\"key:value\\\", comma-separated, e.g. \\\"foo:bar,qux:42\\\"\"`\n\tSkipLogin             bool   `cfg:\"oidc-skip-login\" env:\"H2O_WAVE_OIDC_SKIP_LOGIN\" cfgDefault:\"false\" cfgHelper:\"do not display the login form during OIDC authorization\"`\n\tKeepAppLive           bool   `cfg:\"keep-app-live\" env:\"H2O_WAVE_KEEP_APP_LIVE\" cfgDefault:\"false\" cfgHelper:\"do not unregister unresponsive apps\"`\n\tConf                  string `cfg:\"conf\" env:\"H2O_WAVE_CONF\" cfgDefault:\".env\" cfgHelper:\"path to configuration file\"`\n\tReconnectTimeout      string `cfg:\"reconnect-timeout\" env:\"H2O_WAVE_RECONNECT_TIMEOUT\" cfgDefault:\"5s\" cfgHelper:\"Time to wait for reconnect before dropping the client\"`\n\tAllowedOrigins        string `cfg:\"allowed-origins\" env:\"H2O_WAVE_ALLOWED_ORIGINS\" cfgDefault:\"\" cfgHelper:\"comma-separated list of allowed origins (e.g. http://foo.com) for websocket upgrades, use '*' to allow all origins\"`\n}\n"
        },
        {
          "name": "cycbuf.go",
          "type": "blob",
          "size": 1.3466796875,
          "content": "// Copyright 2020 H2O.ai, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage wave\n\n// CycBuf represents a cyclic buffer.\ntype CycBuf struct {\n\tb *FixBuf\n\ti int\n}\n\nfunc (b *CycBuf) put(ixs interface{}) {\n\tif xs, ok := ixs.([]interface{}); ok {\n\t\tfor _, x := range xs {\n\t\t\tb.set(\"\", x)\n\t\t}\n\t}\n}\n\nfunc (b *CycBuf) set(_ string, v interface{}) { // append-only; ignore key\n\tfb := b.b\n\tfb.seti(b.i, v)\n\tb.i++\n\tif b.i >= len(fb.tups) {\n\t\tb.i = 0\n\t}\n}\n\nfunc (b *CycBuf) get(_ string) (Cur, bool) { // no random access; ignore key\n\treturn b.b.geti(b.i)\n}\n\nfunc (b *CycBuf) dump() BufD {\n\treturn BufD{C: &CycBufD{b.b.t.f, b.b.tups, len(b.b.tups), b.i}}\n}\n\nfunc loadCycBuf(ns *Namespace, b *CycBufD) *CycBuf {\n\tt := ns.make(b.F)\n\tif len(b.D) == 0 {\n\t\tn := b.N\n\t\tif n <= 0 {\n\t\t\tn = 10\n\t\t}\n\t\treturn &CycBuf{newFixBuf(t, n), 0}\n\t}\n\treturn &CycBuf{&FixBuf{t, b.D}, b.I}\n}\n"
        },
        {
          "name": "debug.go",
          "type": "blob",
          "size": 1.5576171875,
          "content": "// Copyright 2020 H2O.ai, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage wave\n\nimport (\n\t\"net/http\"\n\t\"text/template\"\n)\n\nconst siteTemplate = `\n<!DOCTYPE html>\n<html>\n\t<head>\n\t\t<meta charset=\"UTF-8\">\n\t\t<title>Site Profile</title>\n\t</head>\n\t<body style=\"font-family:monospace\">\n\t  <div><strong>Apps</strong><div>\n\t\t{{range .Apps}}<div><a href=\"{{ . }}\">{{ . }}</a></div>{{else}}<div>No apps.</div>{{end}}\n\t  <div><strong>Pages</strong><div>\n\t\t{{range .Pages}}<div><a href=\"{{ . }}\">{{ . }}</a></div>{{else}}<div>No pages.</div>{{end}}\n\t</body>\n</html>`\n\n// DebugHandler is a HTTP handler for site profiling.\ntype DebugHandler struct {\n\tbroker       *Broker\n\tsiteTemplate *template.Template\n}\n\nfunc newDebugHandler(broker *Broker) *DebugHandler {\n\treturn &DebugHandler{\n\t\tbroker,\n\t\ttemplate.Must(template.New(\"site\").Parse(siteTemplate)),\n\t}\n}\n\nfunc (h *DebugHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tdata := struct {\n\t\tApps  []string\n\t\tPages []string\n\t}{\n\t\tApps:  h.broker.routes(),\n\t\tPages: h.broker.site.urls(),\n\t}\n\th.siteTemplate.Execute(w, data)\n}\n"
        },
        {
          "name": "dir_server.go",
          "type": "blob",
          "size": 1.375,
          "content": "// Copyright 2020 H2O.ai, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage wave\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/h2oai/wave/pkg/keychain\"\n)\n\n// DirServer represents a file server for arbitrary directories.\ntype DirServer struct {\n\tkeychain *keychain.Keychain\n\tauth     *Auth\n\thandler  http.Handler\n}\n\nfunc newDirServer(dir string, keychain *keychain.Keychain, auth *Auth) http.Handler {\n\treturn &DirServer{\n\t\tkeychain,\n\t\tauth,\n\t\thttp.FileServer(http.Dir(dir)),\n\t}\n}\n\nfunc (ds *DirServer) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\t// Disallow if:\n\t// - unauthorized api call\n\t// - auth enabled and unauthorized\n\tif !ds.keychain.Allow(r) && (ds.auth != nil && !ds.auth.allow(r)) { // API or UI\n\t\thttp.Error(w, http.StatusText(http.StatusUnauthorized), http.StatusUnauthorized)\n\t\treturn\n\t}\n\n\techo(Log{\"t\": \"file_download\", \"path\": r.URL.Path})\n\tds.handler.ServeHTTP(w, r)\n}\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "e2e",
          "type": "tree",
          "content": null
        },
        {
          "name": "file_server.go",
          "type": "blob",
          "size": 7.3251953125,
          "content": "// Copyright 2020 H2O.ai, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage wave\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"mime\"\n\t\"mime/multipart\"\n\t\"net/http\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"github.com/google/uuid\"\n\t\"github.com/h2oai/wave/pkg/keychain\"\n)\n\n// FileServer represents a file server.\ntype FileServer struct {\n\tdir      string\n\tkeychain *keychain.Keychain\n\tauth     *Auth\n\thandler  http.Handler\n\tbaseURL  string\n}\n\nfunc newFileServer(dir string, keychain *keychain.Keychain, auth *Auth, baseURL string) http.Handler {\n\treturn &FileServer{\n\t\tdir,\n\t\tkeychain,\n\t\tauth,\n\t\thttp.FileServer(http.Dir(dir)),\n\t\tbaseURL,\n\t}\n}\n\nvar (\n\terrInvalidUnloadPath = errors.New(\"invalid file path\")\n)\n\n// UploadResponse represents a response to a file upload operation.\ntype UploadResponse struct {\n\tFiles []string `json:\"files\"`\n}\n\nfunc (fs *FileServer) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tswitch r.Method {\n\tcase http.MethodGet:\n\t\t// Disallow if:\n\t\t// - unauthorized api call\n\t\t// - auth enabled and unauthorized\n\t\tif !fs.keychain.Allow(r) && (fs.auth != nil && !fs.auth.allow(r)) { // API or UI\n\t\t\thttp.Error(w, http.StatusText(http.StatusUnauthorized), http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\ttrimmedPrefix := strings.TrimPrefix(r.URL.Path, fs.baseURL)\n\t\tfsDirPath := path.Join(fs.dir, trimmedPrefix)\n\t\t// Ignore requests for directories and non-existent / unaccessible files.\n\t\tif fileInfo, err := os.Stat(filepath.FromSlash(fsDirPath)); err != nil || fileInfo.IsDir() {\n\t\t\techo(Log{\"t\": \"file_download\", \"path\": r.URL.Path, \"error\": \"not found\"})\n\t\t\thttp.Error(w, http.StatusText(http.StatusNotFound), http.StatusNotFound)\n\t\t\treturn\n\t\t}\n\n\t\techo(Log{\"t\": \"file_download\", \"path\": r.URL.Path})\n\t\tr.URL.Path = trimmedPrefix // public\n\t\tfs.handler.ServeHTTP(w, r)\n\n\tcase http.MethodPost:\n\t\t// Disallow if:\n\t\t// - unauthorized api call\n\t\t// - auth enabled and unauthorized\n\t\tif !fs.keychain.Allow(r) && (fs.auth != nil && !fs.auth.allow(r)) { // API or UI\n\t\t\thttp.Error(w, http.StatusText(http.StatusUnauthorized), http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tfiles, err := fs.acceptFiles(r)\n\t\tif err != nil {\n\t\t\techo(Log{\"t\": \"file_upload\", \"error\": err.Error()})\n\t\t\thttp.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tres, err := json.Marshal(UploadResponse{Files: files})\n\t\tif err != nil {\n\t\t\techo(Log{\"t\": \"file_upload\", \"error\": err.Error()})\n\t\t\thttp.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tw.Write(res)\n\n\tcase http.MethodDelete:\n\t\t// TODO garbage collection\n\n\t\tif !fs.keychain.Guard(w, r) { // Allow APIs only\n\t\t\treturn\n\t\t}\n\n\t\tif err := fs.deleteFile(r.URL.Path, fs.baseURL); err != nil {\n\t\t\techo(Log{\"t\": \"file_unload\", \"path\": r.URL.Path, \"error\": err.Error()})\n\t\t\thttp.Error(w, http.StatusText(http.StatusNotFound), http.StatusNotFound)\n\t\t\treturn\n\t\t}\n\t\techo(Log{\"t\": \"file_unload\", \"path\": r.URL.Path})\n\n\tdefault:\n\t\techo(Log{\"t\": \"file_download\", \"method\": r.Method, \"path\": r.URL.Path, \"error\": \"method not allowed\"})\n\t\thttp.Error(w, http.StatusText(http.StatusMethodNotAllowed), http.StatusMethodNotAllowed)\n\t}\n}\n\nfunc (fs *FileServer) acceptFiles(r *http.Request) ([]string, error) {\n\tif err := r.ParseMultipartForm(32 << 20); err != nil { // 32 MB\n\t\treturn nil, fmt.Errorf(\"failed parsing upload form from request: %v\", err)\n\t}\n\n\tform := r.MultipartForm\n\tfiles, ok := form.File[\"files\"]\n\tif !ok {\n\t\treturn nil, errors.New(\"want 'files' field in upload form, got none\")\n\t}\n\n\tisDirectoryUpload := r.Header.Get(\"Wave-Directory-Upload\")\n\tif isDirectoryUpload == \"True\" {\n\t\treturn fs.storeFilesInSingleDir(files)\n\t}\n\n\treturn fs.storeFilesInSeparateDirs(files)\n}\n\nfunc (fs *FileServer) deleteFile(url, baseURL string) error {\n\t// Remove baseURL portion if specified.\n\tcleanURL := strings.Replace(path.Clean(url), baseURL, \"/_f\", 1)\n\ttokens := strings.Split(cleanURL, \"/\")\n\tif len(tokens) != 4 { // /_f/uuid/file.ext\n\t\treturn errInvalidUnloadPath\n\t}\n\tif tokens[0] != \"\" || tokens[1] != \"_f\" || path.Ext(tokens[3]) == \"\" {\n\t\treturn errInvalidUnloadPath\n\t}\n\n\tdirpath := filepath.Join(fs.dir, tokens[2])\n\treturn os.RemoveAll(dirpath)\n}\n\nfunc (fs *FileServer) storeFilesInSingleDir(files []*multipart.FileHeader) ([]string, error) {\n\n\tid, err := uuid.NewRandom()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed generating file id: %v\", err)\n\t}\n\n\tdirID := id.String()\n\tuploadDir := filepath.Join(fs.dir, dirID)\n\n\tif err := os.MkdirAll(uploadDir, 0700); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed creating upload dir %s: %v\", uploadDir, err)\n\t}\n\n\tfor _, file := range files {\n\t\tsrc, err := file.Open()\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed opening uploaded file: %v\", err)\n\t\t}\n\t\tdefer src.Close()\n\n\t\t// Need to parse the filename from the Content-Disposition header due to HTTP standard saying FileName should be basename.\n\t\t// https://github.com/golang/go/blob/8dbf3e9393400d72d313e5616c88873e07692c70/src/mime/multipart/multipart.go#L82-L84\n\t\t_, params, _ := mime.ParseMediaType(file.Header.Get(\"Content-Disposition\"))\n\t\tfilename := params[\"filename\"]\n\t\tif filename == \"\" {\n\t\t\tfilename = file.Filename\n\t\t}\n\n\t\tdir, file := filepath.Split(filename)\n\t\tuploadPath := filepath.Join(uploadDir, dir)\n\n\t\tif err := os.MkdirAll(uploadPath, 0700); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed creating dir structure %s: %v\", uploadDir, err)\n\t\t}\n\n\t\tuploadPath = filepath.Join(uploadPath, file)\n\t\tdst, err := os.Create(uploadPath)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed writing uploaded file %s: %v\", uploadPath, err)\n\t\t}\n\t\tdefer dst.Close()\n\n\t\tif _, err = io.Copy(dst, src); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed copying uploaded file %s: %v\", uploadPath, err)\n\t\t}\n\t}\n\n\treturn []string{path.Join(fs.baseURL, dirID)}, nil\n}\n\nfunc (fs *FileServer) storeFilesInSeparateDirs(files []*multipart.FileHeader) ([]string, error) {\n\tuploadPaths := make([]string, len(files))\n\tfor i, file := range files {\n\n\t\tid, err := uuid.NewRandom()\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed generating file id: %v\", err)\n\t\t}\n\n\t\tsrc, err := file.Open()\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed opening uploaded file: %v\", err)\n\t\t}\n\t\tdefer src.Close()\n\n\t\tfileID := id.String()\n\t\tuploadDir := filepath.Join(fs.dir, fileID)\n\n\t\tif err := os.MkdirAll(uploadDir, 0700); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed creating upload dir %s: %v\", uploadDir, err)\n\t\t}\n\n\t\tbasename := filepath.Base(file.Filename)\n\t\tuploadPath := filepath.Join(uploadDir, basename)\n\n\t\tdst, err := os.Create(uploadPath)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed writing uploaded file %s: %v\", uploadPath, err)\n\t\t}\n\t\tdefer dst.Close()\n\n\t\tif _, err = io.Copy(dst, src); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed copying uploaded file %s: %v\", uploadPath, err)\n\t\t}\n\n\t\tuploadPaths[i] = path.Join(fs.baseURL, fileID, basename)\n\t}\n\treturn uploadPaths, nil\n}\n"
        },
        {
          "name": "fixbuf.go",
          "type": "blob",
          "size": 1.775390625,
          "content": "// Copyright 2020 H2O.ai, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage wave\n\nimport \"strconv\"\n\n// FixBuf represents a fixed-sized buffer.\ntype FixBuf struct {\n\tt    Typ\n\ttups [][]interface{}\n}\n\nfunc newFixBuf(t Typ, n int) *FixBuf {\n\treturn &FixBuf{t, make([][]interface{}, n)}\n}\n\nfunc (b *FixBuf) put(ixs interface{}) {\n\tif xs, ok := ixs.([]interface{}); ok {\n\t\tif len(xs) == len(b.tups) {\n\t\t\tfor i, x := range xs {\n\t\t\t\tb.seti(i, x)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (b *FixBuf) set(k string, v interface{}) {\n\tif i, err := strconv.Atoi(k); err == nil {\n\t\tb.seti(i, v)\n\t}\n}\n\nfunc (b *FixBuf) seti(i int, v interface{}) {\n\tif i >= 0 && i < len(b.tups) {\n\t\tif v == nil {\n\t\t\tb.tups[i] = nil\n\t\t} else if tup, ok := b.t.match(v); ok {\n\t\t\tb.tups[i] = tup\n\t\t}\n\t}\n}\n\nfunc (b *FixBuf) get(k string) (Cur, bool) {\n\tif i, err := strconv.Atoi(k); err == nil {\n\t\treturn b.geti(i)\n\t}\n\treturn Cur{}, false\n}\n\nfunc (b *FixBuf) geti(i int) (Cur, bool) {\n\tif i >= 0 && i < len(b.tups) {\n\t\treturn Cur{b.t, b.tups[i]}, true\n\t}\n\treturn Cur{}, false\n}\n\nfunc (b *FixBuf) dump() BufD {\n\treturn BufD{F: &FixBufD{b.t.f, b.tups, len(b.tups)}}\n}\n\nfunc loadFixBuf(ns *Namespace, b *FixBufD) *FixBuf {\n\tt := ns.make(b.F)\n\tif len(b.D) == 0 {\n\t\tn := b.N\n\t\tif n <= 0 {\n\t\t\tn = 10\n\t\t}\n\t\treturn newFixBuf(t, n)\n\t}\n\treturn &FixBuf{t, b.D}\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.765625,
          "content": "module github.com/h2oai/wave\n\ngo 1.22\n\nrequire (\n\tgithub.com/coreos/go-oidc v2.2.1+incompatible\n\tgithub.com/google/uuid v1.6.0\n\tgithub.com/gorilla/websocket v1.5.1\n\tgithub.com/h2oai/goconfig v1.3.2-0.20230628122159-683a9532f8d2\n\tgithub.com/hashicorp/golang-lru v1.0.2\n\tgithub.com/lo5/sqlite3 v0.1.0\n\tgolang.org/x/crypto v0.32.0\n\tgolang.org/x/oauth2 v0.18.0\n)\n\nrequire (\n\tgithub.com/fsnotify/fsnotify v1.5.1 // indirect\n\tgithub.com/golang/protobuf v1.5.4 // indirect\n\tgithub.com/joho/godotenv v1.5.1 // indirect\n\tgithub.com/pquerna/cachecontrol v0.2.0 // indirect\n\tgolang.org/x/net v0.34.0 // indirect\n\tgolang.org/x/sys v0.29.0 // indirect\n\tgoogle.golang.org/appengine v1.6.8 // indirect\n\tgoogle.golang.org/protobuf v1.33.0 // indirect\n\tgopkg.in/square/go-jose.v2 v2.6.0 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 7.0595703125,
          "content": "github.com/coreos/go-oidc v2.2.1+incompatible h1:mh48q/BqXqgjVHpy2ZY7WnWAbenxRjsz9N1i1YxjHAk=\ngithub.com/coreos/go-oidc v2.2.1+incompatible/go.mod h1:CgnwVTmzoESiwO9qyAFEMiHoZ1nMCKZlZ9V6mm3/LKc=\ngithub.com/davecgh/go-spew v1.1.0 h1:ZDRjVQ15GmhC3fiQ8ni8+OwkZQO4DARzQgrnXU1Liz8=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/fsnotify/fsnotify v1.5.1 h1:mZcQUHVQUQWoPXXtuf9yuEXKudkV2sx1E06UadKWpgI=\ngithub.com/fsnotify/fsnotify v1.5.1/go.mod h1:T3375wBYaZdLLcVNkcVbzGHY7f1l/uK5T5Ai1i3InKU=\ngithub.com/golang/protobuf v1.5.0/go.mod h1:FsONVRAS9T7sI+LIUmWTfcYkHO4aIWwzhcaSAoJOfIk=\ngithub.com/golang/protobuf v1.5.2/go.mod h1:XVQd3VNwM+JqD3oG2Ue2ip4fOMUkwXdXDdiuN0vRsmY=\ngithub.com/golang/protobuf v1.5.4 h1:i7eJL8qZTpSEXOPTxNKhASYpMn+8e5Q6AdndVa1dWek=\ngithub.com/golang/protobuf v1.5.4/go.mod h1:lnTiLA8Wa4RWRcIUkrtSVa5nRhsEGBg48fD6rSs7xps=\ngithub.com/google/go-cmp v0.5.5/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.5.9 h1:O2Tfq5qg4qc4AmwVlvv0oLiVAGB7enBSJ2x2DqQFi38=\ngithub.com/google/go-cmp v0.5.9/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=\ngithub.com/google/uuid v1.6.0 h1:NIvaJDMOsjHA8n1jAhLSgzrAzy1Hgr+hNrb57e+94F0=\ngithub.com/google/uuid v1.6.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=\ngithub.com/gorilla/websocket v1.5.1 h1:gmztn0JnHVt9JZquRuzLw3g4wouNVzKL15iLr/zn/QY=\ngithub.com/gorilla/websocket v1.5.1/go.mod h1:x3kM2JMyaluk02fnUJpQuwD2dCS5NDG2ZHL0uE0tcaY=\ngithub.com/h2oai/goconfig v1.3.2-0.20230628122159-683a9532f8d2 h1:OzMkxFBlEOp/hdmJ3JcwoUoe5ZJCibI7xApO/UBNB4w=\ngithub.com/h2oai/goconfig v1.3.2-0.20230628122159-683a9532f8d2/go.mod h1:+ik4b6fJebd8qP4tK06xoSMAhHoYLPnaydm1tt0J1Sw=\ngithub.com/hashicorp/golang-lru v1.0.2 h1:dV3g9Z/unq5DpblPpw+Oqcv4dU/1omnb4Ok8iPY6p1c=\ngithub.com/hashicorp/golang-lru v1.0.2/go.mod h1:iADmTwqILo4mZ8BN3D2Q6+9jd8WM5uGBxy+E8yxSoD4=\ngithub.com/joho/godotenv v1.5.1 h1:7eLL/+HRGLY0ldzfGMeQkb7vMd0as4CfYvUVzLqw0N0=\ngithub.com/joho/godotenv v1.5.1/go.mod h1:f4LDr5Voq0i2e/R5DDNOoa2zzDfwtkZa6DnEwAbqwq4=\ngithub.com/lo5/sqlite3 v0.1.0 h1:mjM6n1DPRPKotAN3/DZgN0UOTlU0xL9n4jZ3LliWDGQ=\ngithub.com/lo5/sqlite3 v0.1.0/go.mod h1:bld1oUU4buWPOuyyJfmLL+t02pmJY9qMCTpYK8PrhOs=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/pquerna/cachecontrol v0.2.0 h1:vBXSNuE5MYP9IJ5kjsdo8uq+w41jSPgvba2DEnkRx9k=\ngithub.com/pquerna/cachecontrol v0.2.0/go.mod h1:NrUG3Z7Rdu85UNR3vm7SOsl1nFIeSiQnrHV5K9mBcUI=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/testify v1.6.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.7.0 h1:nwc3DEeHmmLAfoZucVR881uASk0Mfjw8xYJ99tb5CcY=\ngithub.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/yuin/goldmark v1.4.13/go.mod h1:6yULJ656Px+3vBD8DxQVa3kxgyrAnzto9xy5taEt/CY=\ngolang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/crypto v0.0.0-20210921155107-089bfa567519/go.mod h1:GvvjBRRGRdwPK5ydBHafDWAxML/pGHZbMvKqRZ5+Abc=\ngolang.org/x/crypto v0.32.0 h1:euUpcYgM8WcP71gNpTqQCn6rC2t6ULUPiOzfWaXVVfc=\ngolang.org/x/crypto v0.32.0/go.mod h1:ZnnJkOaASj8g0AjIduWNlq2NRxL0PlBrbKVyZ6V/Ugc=\ngolang.org/x/mod v0.6.0-dev.0.20220419223038-86c51ed26bb4/go.mod h1:jJ57K6gSWd91VN4djpZkiMVwK6gcyfeH4XE8wZrZaV4=\ngolang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20210226172049-e18ecbb05110/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=\ngolang.org/x/net v0.0.0-20220722155237-a158d28d115b/go.mod h1:XRhObCWvk6IyKnWLug+ECip1KBveYUHfp+8e9klMJ9c=\ngolang.org/x/net v0.34.0 h1:Mb7Mrk043xzHgnRM88suvJFwzVrRfHEHJEl5/71CKw0=\ngolang.org/x/net v0.34.0/go.mod h1:di0qlW3YNM5oh6GqDGQr92MyTozJPmybPK4Ev/Gm31k=\ngolang.org/x/oauth2 v0.18.0 h1:09qnuIAgzdx1XplqJvW6CQqMCtGZykZWcXzPMPUusvI=\ngolang.org/x/oauth2 v0.18.0/go.mod h1:Wf7knwG0MPoWIMMBgFlEaSUDaKskp0dCfrlJRJXbBi8=\ngolang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20220722155255-886fb9371eb4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210615035016-665e8c7367d1/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20210630005230-0f9fa26af87c/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220520151302-bc2c85ada10a/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220722155257-8c9f86f7a55f/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.29.0 h1:TPYlXGxvx1MGTn2GiZDhnjPA9wZzZeGKHHmKhHYvgaU=\ngolang.org/x/sys v0.29.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=\ngolang.org/x/term v0.0.0-20210927222741-03fcf44c2211/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/text v0.3.7/go.mod h1:u+2+/6zg+i71rQMx5EYifcz6MCKuco9NR6JIITiCfzQ=\ngolang.org/x/text v0.3.8/go.mod h1:E6s5w1FMmriuDzIBO73fBruAKo1PCIq6d2Q6DHfQ8WQ=\ngolang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.1.12/go.mod h1:hNGJHUnrk76NpqgfD5Aqm5Crs+Hm0VOH/i9J2+nxYbc=\ngolang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngoogle.golang.org/appengine v1.6.8 h1:IhEN5q69dyKagZPYMSdIjS2HqprW324FRQZJcGqPAsM=\ngoogle.golang.org/appengine v1.6.8/go.mod h1:1jJ3jBArFh5pcgW8gCtRJnepW8FzD1V44FJffLiz/Ds=\ngoogle.golang.org/protobuf v1.26.0-rc.1/go.mod h1:jlhhOSvTdKEhbULTjvd4ARK9grFBp09yW+WbY/TyQbw=\ngoogle.golang.org/protobuf v1.26.0/go.mod h1:9q0QmTI4eRPtz6boOQmLYwt+qCgq0jsYwAQnmE0givc=\ngoogle.golang.org/protobuf v1.33.0 h1:uNO2rsAINq/JlFpSdYEKIZ0uKD/R9cpdv0T+yoGwGmI=\ngoogle.golang.org/protobuf v1.33.0/go.mod h1:c6P6GXX6sHbq/GpV6MGZEdwhWPcYBgnhAHhKbcUYpos=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/square/go-jose.v2 v2.6.0 h1:NGk74WTnPKBNUhNzQX7PYcTLUjoq7mzKk2OKbvwk2iI=\ngopkg.in/square/go-jose.v2 v2.6.0/go.mod h1:M9dMgbHiYLoDGQrXy7OpJDJWiKiU//h+vD76mk0e1AI=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c h1:dUUwHk2QECo/6vqA44rthZ8ie2QXMNeKRTHCNY2nXvo=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "gzip.go",
          "type": "blob",
          "size": 1.2333984375,
          "content": "// Copyright 2020 H2O.ai, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage wave\n\nimport (\n\t\"compress/gzip\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"sync\"\n)\n\ntype gzipResponseWriter struct {\n\tio.Writer\n\thttp.ResponseWriter\n}\n\nvar gzPool = sync.Pool{\n\tNew: func() interface{} {\n\t\treturn gzip.NewWriter(ioutil.Discard)\n\t},\n}\n\nfunc (w *gzipResponseWriter) Write(b []byte) (int, error) {\n\treturn w.Writer.Write(b)\n}\n\nfunc serveGzipped(h http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"Content-Encoding\", \"gzip\")\n\n\t\tgz := gzPool.Get().(*gzip.Writer)\n\t\tdefer gzPool.Put(gz)\n\n\t\tgz.Reset(w)\n\t\tdefer gz.Close()\n\n\t\th.ServeHTTP(&gzipResponseWriter{ResponseWriter: w, Writer: gz}, r)\n\t})\n}\n"
        },
        {
          "name": "headers.txt",
          "type": "blob",
          "size": 0.0908203125,
          "content": "X-Frame-Options: SAMEORIGIN\nX-Content-Type-Options: nosniff\nX-XSS-Protection: 1; mode=block\n\n"
        },
        {
          "name": "ide",
          "type": "tree",
          "content": null
        },
        {
          "name": "increment.json",
          "type": "blob",
          "size": 0.0185546875,
          "content": "{\"increment\":true}\n"
        },
        {
          "name": "listbuf.go",
          "type": "blob",
          "size": 1.818359375,
          "content": "// Copyright 2020 H2O.ai, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage wave\n\nimport \"strconv\"\n\n// ListBuf represents a list (dynamic array) buffer.\ntype ListBuf struct {\n\tb *FixBuf\n\ti int\n}\n\nfunc (b *ListBuf) put(ixs any) {\n\tif xs, ok := ixs.([]any); ok {\n\t\tfor _, x := range xs {\n\t\t\tb.set(\"\", x)\n\t\t}\n\t}\n}\n\nfunc (b *ListBuf) set(key string, v any) {\n\tfb := b.b\n\t// Check if key is a valid index.\n\tif i, err := strconv.Atoi(key); err == nil {\n\t\t// Support negative indices.\n\t\tif i < 0 {\n\t\t\ti += b.i\n\t\t}\n\t\tif i >= 0 && i < len(fb.tups) {\n\t\t\tfb.seti(i, v)\n\t\t\treturn\n\t\t}\n\t}\n\t// Otherwise, append to the current end.\n\tif b.i >= len(fb.tups) {\n\t\txs := make([][]interface{}, len(fb.tups)*2)\n\t\ttups := fb.tups\n\t\tfb.tups = xs\n\n\t\tfor i, t := range tups {\n\t\t\tfb.seti(i, t)\n\t\t}\n\t}\n\tfb.seti(b.i, v)\n\tb.i++\n}\n\nfunc (b *ListBuf) get(key string) (Cur, bool) {\n\t// Check if key is a valid index.\n\tif i, err := strconv.Atoi(key); err == nil {\n\t\tif i < 0 {\n\t\t\ti += len(b.b.tups)\n\t\t}\n\t\treturn b.b.geti(i)\n\t}\n\n\treturn b.b.geti(b.i)\n}\n\nfunc (b *ListBuf) dump() BufD {\n\treturn BufD{L: &ListBufD{b.b.t.f, b.b.tups, len(b.b.tups)}}\n}\n\nfunc loadListBuf(ns *Namespace, b *ListBufD) *ListBuf {\n\tt := ns.make(b.F)\n\tif len(b.D) == 0 {\n\t\tn := b.N\n\t\tif n <= 0 {\n\t\t\tn = 10\n\t\t}\n\t\treturn &ListBuf{newFixBuf(t, n), n - 1}\n\t}\n\treturn &ListBuf{&FixBuf{t, b.D}, len(b.D)}\n}\n"
        },
        {
          "name": "mapbuf.go",
          "type": "blob",
          "size": 1.501953125,
          "content": "// Copyright 2020 H2O.ai, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage wave\n\n// MapBuf represents a map (dictionary) buffer.\ntype MapBuf struct {\n\tt    Typ\n\ttups map[string][]interface{}\n}\n\nfunc newMapBuf(t Typ) *MapBuf {\n\treturn &MapBuf{t, make(map[string][]interface{})}\n}\n\nfunc (b *MapBuf) put(ixs interface{}) {\n\tif xs, ok := ixs.(map[string]interface{}); ok {\n\t\ttups := make(map[string][]interface{})\n\t\tfor k, x := range xs {\n\t\t\tif tup, ok := b.t.match(x); ok {\n\t\t\t\ttups[k] = tup\n\t\t\t}\n\t\t}\n\t\tb.tups = tups\n\t}\n}\n\nfunc (b *MapBuf) set(k string, v interface{}) {\n\tif v == nil {\n\t\tdelete(b.tups, k)\n\t} else if tup, ok := b.t.match(v); ok {\n\t\tb.tups[k] = tup\n\t}\n}\n\nfunc (b *MapBuf) get(k string) (Cur, bool) {\n\tif tup, ok := b.tups[k]; ok {\n\t\treturn Cur{b.t, tup}, true\n\t}\n\treturn Cur{}, false\n}\n\nfunc (b *MapBuf) dump() BufD {\n\treturn BufD{M: &MapBufD{b.t.f, b.tups}}\n}\n\nfunc loadMapBuf(ns *Namespace, b *MapBufD) *MapBuf {\n\tt := ns.make(b.F)\n\tif b.D == nil {\n\t\treturn newMapBuf(t)\n\t}\n\treturn &MapBuf{t, b.D}\n}\n"
        },
        {
          "name": "multipart.go",
          "type": "blob",
          "size": 4.138671875,
          "content": "// Copyright 2020 H2O.ai, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage wave\n\nimport (\n\t\"crypto/rand\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"github.com/h2oai/wave/pkg/keychain\"\n)\n\nvar nothing = struct{}{}\n\n// MultipartSource represents a source of multipart data.\ntype MultipartSource struct {\n\tsync.RWMutex\n\ttargets map[chan *MultipartFrame]struct{}\n}\n\n// MultipartFrame represents a single frame in a multipart stream.\ntype MultipartFrame struct {\n\tcontentType string\n\tdata        []byte\n}\n\n// MultipartServer handles multipart/x-mixed-replace content.\ntype MultipartServer struct {\n\tsync.RWMutex\n\tprefix         string\n\tkeychain       *keychain.Keychain\n\tauth           *Auth\n\tmaxRequestSize int64\n\tsources        map[string]*MultipartSource\n}\n\nfunc newMultipartServer(prefix string, keychain *keychain.Keychain, auth *Auth, maxRequestSize int64) *MultipartServer {\n\treturn &MultipartServer{\n\t\tprefix:         prefix,\n\t\tkeychain:       keychain,\n\t\tauth:           auth,\n\t\tmaxRequestSize: maxRequestSize,\n\t\tsources:        make(map[string]*MultipartSource),\n\t}\n}\n\nfunc randomBoundary() string {\n\tvar buf [30]byte\n\t_, err := io.ReadFull(rand.Reader, buf[:])\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn fmt.Sprintf(\"%x\", buf[:])\n}\n\nfunc (s *MultipartServer) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tkey := strings.TrimPrefix(r.URL.Path, s.prefix)\n\tswitch r.Method {\n\tcase http.MethodGet:\n\t\tif s.auth != nil && !s.auth.allow(r) {\n\t\t\thttp.Error(w, http.StatusText(http.StatusUnauthorized), http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\ts.RLock()\n\t\tsource, ok := s.sources[key]\n\t\ts.RUnlock()\n\t\tif !ok {\n\t\t\thttp.Error(w, http.StatusText(http.StatusNotFound), http.StatusNotFound)\n\t\t\treturn\n\t\t}\n\n\t\tframes := make(chan *MultipartFrame, 256)\n\t\tsource.Lock()\n\t\tsource.targets[frames] = nothing\n\t\tsource.Unlock()\n\n\t\tboundary := randomBoundary()\n\t\tw.Header().Set(\"Content-Type\", \"multipart/x-mixed-replace; boundary=\"+boundary)\n\n\t\tfor frame := range frames { // blocking\n\t\t\tfmt.Fprintf(w, \"Content-Type: %s\\r\\n\", frame.contentType)\n\t\t\tfmt.Fprintf(w, \"Content-Length: %d\\r\\n\\r\\n\", len(frame.data))\n\t\t\tw.Write(frame.data)\n\t\t\tfmt.Fprintf(w, \"\\r\\n--%s\\r\\n\", boundary)\n\t\t}\n\n\tcase http.MethodPost:\n\t\tif !s.keychain.Guard(w, r) {\n\t\t\treturn\n\t\t}\n\n\t\ts.RLock()\n\t\tsource, ok := s.sources[key]\n\t\ts.RUnlock()\n\t\tif !ok {\n\t\t\tsource = &MultipartSource{targets: make(map[chan *MultipartFrame]struct{})}\n\t\t\ts.Lock()\n\t\t\ts.sources[key] = source\n\t\t\ts.Unlock()\n\t\t}\n\n\t\tmr, err := r.MultipartReader()\n\t\tif err != nil {\n\t\t\techo(Log{\"t\": \"multipart_read\", \"error\": err.Error()})\n\t\t\thttp.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tpart, err := mr.NextPart()\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}\n\t\tdata, err := ioutil.ReadAll(io.LimitReader(part, s.maxRequestSize))\n\t\tif err != nil {\n\t\t\techo(Log{\"t\": \"multipart_read\", \"error\": err.Error()})\n\t\t\thttp.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\tcontentType := part.Header.Get(\"Content-Type\")\n\t\tfor _, frames := range source.getTargets() {\n\t\t\tselect {\n\t\t\tcase frames <- &MultipartFrame{contentType, data}:\n\t\t\tdefault: // full; drop frame\n\t\t\t}\n\t\t}\n\n\tcase http.MethodDelete:\n\t\tif !s.keychain.Guard(w, r) {\n\t\t\treturn\n\t\t}\n\n\t\ts.RLock()\n\t\tsource, ok := s.sources[key]\n\t\ts.RUnlock()\n\t\tif !ok {\n\t\t\treturn\n\t\t}\n\n\t\tfor _, frames := range source.getTargets() {\n\t\t\tclose(frames) // terminate GETs\n\t\t}\n\n\t\ts.Lock()\n\t\tdelete(s.sources, key)\n\t\ts.Unlock()\n\t}\n}\n\nfunc (s *MultipartSource) getTargets() []chan *MultipartFrame {\n\ts.RLock()\n\tdefer s.RUnlock()\n\tvar targets []chan *MultipartFrame\n\tfor t := range s.targets {\n\t\ttargets = append(targets, t)\n\t}\n\treturn targets\n}\n"
        },
        {
          "name": "page.go",
          "type": "blob",
          "size": 1.7275390625,
          "content": "// Copyright 2020 H2O.ai, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage wave\n\nimport (\n\t\"encoding/json\"\n\t\"strings\"\n\t\"sync\"\n)\n\n// Page represents a web page.\ntype Page struct {\n\tsync.RWMutex\n\tcards map[string]*Card\n\tcache []byte\n}\n\nfunc newPage() *Page {\n\treturn &Page{cards: make(map[string]*Card)}\n}\n\nfunc (p *Page) read() []byte {\n\tp.RLock()\n\tdefer p.RUnlock()\n\treturn p.cache\n}\n\nfunc (p *Page) set(k string, v interface{}) {\n\tks := strings.Split(k, keySeparator) // PERF avoid allocation\n\tif len(ks) == 1 {\n\t\tdelete(p.cards, k)\n\t\treturn\n\t}\n\n\tif card, ok := p.cards[ks[0]]; ok {\n\t\tcard.set(ks[1:], v)\n\t}\n}\n\nfunc (p *Page) dump() *PageD {\n\tc := make(map[string]CardD)\n\tfor k, v := range p.cards {\n\t\tc[k] = v.dump()\n\t}\n\treturn &PageD{c}\n}\n\nfunc (p *Page) marshal() []byte {\n\tif cache := p.read(); cache != nil {\n\t\treturn cache\n\t}\n\n\tp.Lock()\n\tdefer p.Unlock()\n\n\tcache, err := json.Marshal(OpsD{P: p.dump()})\n\tif err != nil {\n\t\techo(Log{\"t\": \"page_marshal\", \"error\": err.Error()})\n\t\treturn nil\n\t}\n\tp.cache = cache // invalidated by site exec() under write-lock\n\treturn cache\n}\n\nfunc loadPage(ns *Namespace, d *PageD) *Page {\n\tcards := make(map[string]*Card)\n\tfor k, v := range d.C {\n\t\tcards[k] = loadCard(ns, v)\n\t}\n\treturn &Page{cards: cards}\n}\n"
        },
        {
          "name": "parse.go",
          "type": "blob",
          "size": 1.66796875,
          "content": "// Copyright 2020 H2O.ai, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage wave\n\nimport (\n\t\"errors\"\n\t\"strconv\"\n\t\"strings\"\n\t\"unicode\"\n)\n\n// Adapted from https://github.com/cloudfoundry/bytefmt\n\nconst (\n\tBYTE = 1 << (10 * iota)\n\tKILOBYTE\n\tMEGABYTE\n\tGIGABYTE\n\tTERABYTE\n\tPETABYTE\n\tEXABYTE\n)\n\nvar errInvalidByteSize = errors.New(\"invalid byte size\")\n\n// ParseBytes parses string representations (e.g. 42K or 42KB or 42KiB) to bytes\nfunc ParseBytes(s string) (uint64, error) {\n\ts = strings.ToUpper(strings.TrimSpace(s))\n\ti := strings.IndexFunc(s, unicode.IsLetter)\n\n\tif i == -1 {\n\t\treturn 0, errInvalidByteSize\n\t}\n\n\tnum, unit := s[:i], s[i:]\n\tb, err := strconv.ParseFloat(num, 64)\n\tif err != nil || b < 0 {\n\t\treturn 0, errInvalidByteSize\n\t}\n\n\tswitch unit {\n\tcase \"E\", \"EB\", \"EIB\":\n\t\treturn uint64(b * EXABYTE), nil\n\tcase \"P\", \"PB\", \"PIB\":\n\t\treturn uint64(b * PETABYTE), nil\n\tcase \"T\", \"TB\", \"TIB\":\n\t\treturn uint64(b * TERABYTE), nil\n\tcase \"G\", \"GB\", \"GIB\":\n\t\treturn uint64(b * GIGABYTE), nil\n\tcase \"M\", \"MB\", \"MIB\":\n\t\treturn uint64(b * MEGABYTE), nil\n\tcase \"K\", \"KB\", \"KIB\":\n\t\treturn uint64(b * KILOBYTE), nil\n\tcase \"B\":\n\t\treturn uint64(b), nil\n\tdefault:\n\t\treturn 0, errInvalidByteSize\n\t}\n}\n"
        },
        {
          "name": "parse_test.go",
          "type": "blob",
          "size": 1.6357421875,
          "content": "// Copyright 2020 H2O.ai, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage wave\n\nimport (\n\t\"testing\"\n\n\t\"github.com/h2oai/wave/pkg/assert\"\n)\n\nfunc TestParseBytes(t *testing.T) {\n\t_, ok, no := assert.Assert(t)\n\tunits := []string{\"e\", \"p\", \"t\", \"g\", \"m\", \"k\"}\n\tvalues := []int{EXABYTE, PETABYTE, TERABYTE, GIGABYTE, MEGABYTE, KILOBYTE}\n\tfor i, unit := range units {\n\t\tv := values[i]\n\n\t\tb, err := ParseBytes(\"5\" + unit)\n\t\tno(err)\n\t\tok(uint64(5*v) == b, \"int without B\")\n\n\t\tb, err = ParseBytes(\"0\" + unit)\n\t\tno(err)\n\t\tok(b == 0, \"zero\")\n\n\t\tb, err = ParseBytes(\"5\" + unit + \"b\")\n\t\tno(err)\n\t\tok(uint64(5*v) == b, \"int with B\")\n\n\t\tb, err = ParseBytes(\"5\" + unit + \"ib\")\n\t\tno(err)\n\t\tok(uint64(5*v) == b, \"int with iB\")\n\n\t\tb, err = ParseBytes(\"4.2\" + unit + \"ib\")\n\t\tno(err)\n\t\tok(uint64(4.2*float64(v)) == b, \"float values\")\n\t}\n\n\tb, err := ParseBytes(\"  \\n\\t5MB\\t\")\n\tok(uint64(5*MEGABYTE) == b, \"allows whitespace\")\n\tno(err)\n\n\t_, err = ParseBytes(\"5\")\n\tok(err != nil, \"no unit\")\n\n\t_, err = ParseBytes(\"-5bb\")\n\tok(err != nil, \"bad unit\")\n\n\t_, err = ParseBytes(\"-5mbb\")\n\tok(err != nil, \"bad unit\")\n\n\t_, err = ParseBytes(\"-5mb\")\n\tok(err != nil, \"negative values\")\n}\n"
        },
        {
          "name": "perf.txt",
          "type": "blob",
          "size": 4.33984375,
          "content": "Perf testing notes\n\nH2O_WAVE_APP_ACCESS_KEY_ID=foo \\\n   H2O_WAVE_APP_ACCESS_KEY_SECRET=bar \\\n   wave run --no-reload examples.counter_unicast\n\n----------------------------------------------------------------------------------------------------\nBaseline: 50rps, 30s\n\n$ cat attack.txt | vegeta attack -duration=30s | tee results.bin | vegeta report\nRequests      [total, rate, throughput]  1500, 50.03, 50.03\nDuration      [total, attack, wait]      29.982134872s, 29.980576236s, 1.558636ms\nLatencies     [mean, 50, 95, 99, max]    923.275µs, 890.324µs, 1.248683ms, 1.786492ms, 5.758645ms\nBytes In      [total, mean]              0, 0.00\nBytes Out     [total, mean]              28500, 19.00\nSuccess       [ratio]                    100.00%\nStatus Codes  [code:count]               200:1500\nError Set:\n\n$ cat attack.txt | vegeta attack -duration=30s | tee results.bin | vegeta report\nRequests      [total, rate, throughput]  1500, 50.03, 50.03\nDuration      [total, attack, wait]      29.980969278s, 29.98021853s, 750.748µs\nLatencies     [mean, 50, 95, 99, max]    971.274µs, 920.005µs, 1.378814ms, 1.718148ms, 6.412542ms\nBytes In      [total, mean]              0, 0.00\nBytes Out     [total, mean]              28500, 19.00\nSuccess       [ratio]                    100.00%\nStatus Codes  [code:count]               200:1500\nError Set:\n\n$ cat attack.txt | vegeta attack -duration=30s | tee results.bin | vegeta report\nRequests      [total, rate, throughput]  1500, 50.03, 50.03\nDuration      [total, attack, wait]      29.981506648s, 29.980566198s, 940.45µs\nLatencies     [mean, 50, 95, 99, max]    950.011µs, 898.614µs, 1.376998ms, 1.739228ms, 7.575071ms\nBytes In      [total, mean]              0, 0.00\nBytes Out     [total, mean]              28500, 19.00\nSuccess       [ratio]                    100.00%\nStatus Codes  [code:count]               200:1500\nError Set:\n\n\n----------------------------------------------------------------------------------------------------\nBaseline: 500rps, 30s\n\n$ cat attack.txt | vegeta attack -duration=30s -rate=500 | tee results.bin | vegeta report\nRequests      [total, rate, throughput]  15000, 500.03, 500.01\nDuration      [total, attack, wait]      29.999543772s, 29.998173312s, 1.37046ms\nLatencies     [mean, 50, 95, 99, max]    43.646089ms, 5.01603ms, 270.952433ms, 463.433687ms, 580.247216ms\nBytes In      [total, mean]              0, 0.00\nBytes Out     [total, mean]              285000, 19.00\nSuccess       [ratio]                    100.00%\nStatus Codes  [code:count]               200:15000\nError Set:\n\nFulfillment:\n  First request\n    2021/10/25 09:03:45 * /None {\"d\":[{\"k\":\"example items 0 button label\",\"v\":\"Count=9\"}]}\n  Last request\n    2021/10/25 09:06:16 * /None {\"d\":[{\"k\":\"example items 0 button label\",\"v\":\"Count=14930\"}]}\n  Elapsed time\n    02:31\n\n----------------------------------------------------------------------------------------------------\nWith HTTP Basic Auth disabled\n\n$ cat attack.txt | vegeta attack -duration=30s -rate=500 | tee results.bin | vegeta report\nRequests      [total, rate, throughput]  15000, 500.03, 500.01\nDuration      [total, attack, wait]      29.999317765s, 29.998388779s, 928.986µs\nLatencies     [mean, 50, 95, 99, max]    1.893424ms, 855.601µs, 6.830168ms, 9.922392ms, 34.859879ms\nBytes In      [total, mean]              0, 0.00\nBytes Out     [total, mean]              285000, 19.00\nSuccess       [ratio]                    100.00%\nStatus Codes  [code:count]               200:15000\nError Set:\n\nFulfillment:\n  First request\n    2021/10/25 10:30:21 * /None {\"d\":[{\"k\":\"example items 0 button label\",\"v\":\"Count=2\"}]}\n  Last request\n    2021/10/25 10:30:51 * /None {\"d\":[{\"k\":\"example items 0 button label\",\"v\":\"Count=15000\"}]}\n  Elapsed time\n    00:30\n\n----------------------------------------------------------------------------------------------------\ncat attack.txt | vegeta attack -duration=120s -rate=500 | tee results.bin | vegeta report\nRequests      [total, rate, throughput]         60000, 500.01, 461.67\nDuration      [total, attack, wait]             2m0s, 2m0s, 173.227ms\nLatencies     [min, mean, 50, 90, 95, 99, max]  25.608µs, 113.477ms, 23.006ms, 261.914ms, 361.195ms, 2.403s, 3.235s\nBytes In      [total, mean]                     0, 0.00\nBytes Out     [total, mean]                     1220538, 20.34\nSuccess       [ratio]                           92.47%\nStatus Codes  [code:count]                      0:4521  200:55479 \n\n"
        },
        {
          "name": "pkg",
          "type": "tree",
          "content": null
        },
        {
          "name": "protocol.go",
          "type": "blob",
          "size": 3.638671875,
          "content": "// Copyright 2020 H2O.ai, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage wave\n\n// OpsD represents the set of changes to be applied to a Page. This is a discriminated union.\ntype OpsD struct {\n\tP *PageD `json:\"p,omitempty\"` // page\n\tD []OpD  `json:\"d,omitempty\"` // deltas\n\tR int    `json:\"r,omitempty\"` // reset\n\tU string `json:\"u,omitempty\"` // redirect\n\tE string `json:\"e,omitempty\"` // error\n\tM *Meta  `json:\"m,omitempty\"` // metadata\n\tC int    `json:\"c,omitempty\"` // clear UI state\n\tI string `json:\"i,omitempty\"` // client id\n}\n\n// Meta represents metadata unrelated to commands\ntype Meta struct {\n\tUsername string `json:\"u\"` // active user's username\n\tEditor   bool   `json:\"e\"` // can the user edit pages?\n}\n\n// OpD represents a delta operation (effector)\n// Discriminated union; valid combos: K, set:KV|KC|KF|KM, put:KD|KDB\ntype OpD struct {\n\tK string                 `json:\"k,omitempty\"` // key; \"\"=drop page\n\tV interface{}            `json:\"v,omitempty\"` // value\n\tC *CycBufD               `json:\"c,omitempty\"` // value\n\tF *FixBufD               `json:\"f,omitempty\"` // value\n\tM *MapBufD               `json:\"m,omitempty\"` // value\n\tL *ListBufD              `json:\"l,omitempty\"` // value\n\tD map[string]interface{} `json:\"d,omitempty\"` // card data\n\tB []BufD                 `json:\"b,omitempty\"` // card buffers\n}\n\n// PageD represents the marshaled data for a Page.\ntype PageD struct {\n\tC map[string]CardD `json:\"c\"` // cards\n}\n\n// CardD represents the marshaled data for a Card.\ntype CardD struct {\n\tD map[string]interface{} `json:\"d\"`           // data\n\tB []BufD                 `json:\"b,omitempty\"` // buffers\n}\n\n// BufD represents the marshaled data for a buffer. This is a discriminated union.\ntype BufD struct {\n\tC *CycBufD  `json:\"c,omitempty\"`\n\tF *FixBufD  `json:\"f,omitempty\"`\n\tM *MapBufD  `json:\"m,omitempty\"`\n\tL *ListBufD `json:\"l,omitempty\"`\n}\n\n// MapBufD represents the marshaled data for a MapBuf.\ntype MapBufD struct {\n\tF []string                 `json:\"f\"` // fields\n\tD map[string][]interface{} `json:\"d\"` // tuples\n}\n\n// FixBufD represents the marshaled data for a FixBuf.\ntype FixBufD struct {\n\tF []string        `json:\"f\"` // fields\n\tD [][]interface{} `json:\"d\"` // tuples\n\tN int             `json:\"n\"` // size\n}\n\n// CycBufD represents the marshaled data for a CycBuf.\ntype CycBufD struct {\n\tF []string        `json:\"f\"` // fields\n\tD [][]interface{} `json:\"d\"` // tuples\n\tN int             `json:\"n\"` // size\n\tI int             `json:\"i\"` // index\n}\n\ntype ListBufD struct {\n\tF []string        `json:\"f\"` // fields\n\tD [][]interface{} `json:\"d\"` // tuples\n\tN int             `json:\"n\"` // size\n}\n\n// AppRequest represents a request from an app.\ntype AppRequest struct {\n\tRegisterApp   *RegisterApp   `json:\"register_app,omitempty\"`\n\tUnregisterApp *UnregisterApp `json:\"unregister_app,omitempty\"`\n}\n\n// RegisterApp represents a request to register an app.\ntype RegisterApp struct {\n\tMode      string `json:\"mode\"`\n\tRoute     string `json:\"route\"`\n\tAddress   string `json:\"address\"`\n\tKeyID     string `json:\"key_id\"`\n\tKeySecret string `json:\"key_secret\"`\n}\n\n// UnregisterApp represents a request to unregister an app.\ntype UnregisterApp struct {\n\tRoute string `json:\"route\"`\n}\n"
        },
        {
          "name": "protocol.md",
          "type": "blob",
          "size": 4.25390625,
          "content": "# Protocol\n\n## Wire Protocol\n\nAs of 2021, the messages are JSON-encoded, but this will change to a binary format in a future release.\n\n(TODO: Document protocol).\n\nRefer to [protocol.go](protocol.go).\n\n## App Server Protocol\n\nA Wave app is a HTTP server, hereafter referred to as the \"app server\".\n\nAt run time, messages between the browser and the Wave server are exchanged via web sockets.\nMessages between the Wave server and the app server are exchanged via HTTP requests.\n\n```\n\n                                       HTTP\n  ┌──────────┐           ┌──────────┐ request   ┌──────────┐\n  │          │           │          ├───────────►          │\n  │  Browser │◄─────────►│   Wave   │           │   App    │\n  │          │    Web    │  Server  │           │  Server  │\n  │          │   Socket  │          ◄───────────┤          │\n  └──────────┘           └──────────┘   HTTP    └──────────┘\n                                       request\n\n```\n\n\nRelevant environment variables:\n\n- `WAVE_ADDRESS`: The `protocol://ip:port` of the Wave server as visible from the app server.\n- `WAVE_APP_ADDRESS`: The `protocol://ip:port` of the app server as visible from the Wave server.\n- `WAVE_APP_MODE`: The sync mode of the app, one of `unicast`, `multicast` or `broadcast`.\n- `WAVE_ACCESS_KEY_ID`: The Wave server API access key ID, typically a cryptographically random string.\n- `WAVE_ACCESS_KEY_SECRET`: The Wave server API access key secret, typically a cryptographically random string.\n- `WAVE_APP_ACCESS_KEY_ID`: The app server API access key ID, typically a cryptographically random string.\n- `WAVE_APP_ACCESS_KEY_SECRET`: The app server API access key secret, typically a cryptographically random string.\n\n### Startup\n\nOn app launch, the app registers itself with the Wave server by sending a `POST` request to `$WAVE_ADDRESS` (with `Content-Type: application/json`).\n\n```\n{\n  \"register_app\": {\n    \"mode\": \"$WAVE_APP_MODE\",\n    \"address\": \"$WAVE_APP_ADDRESS\"\n    \"key_id\": \"$WAVE_APP_ACCESS_KEY_ID\",\n    \"key_secret\": \"$WAVE_APP_ACCESS_KEY_SECRET\",\n    \"route\": \"/foo\",\n  }\n}\n```\n\nThe `key_id` and `key_secret` are automatically generated at startup if `$WAVE_APP_ACCESS_KEY_ID` or `$WAVE_APP_ACCESS_KEY_SECRET` are empty.\n\n### Accepting requests\n\nThe Wave server now starts forwarding browser requests from the Wave server's `/foo` to the app server's `/`. Consequently, the app framework requires exactly one HTTP handler, listening to `POST` requests at `/`.\n\nOn receiving a request, the app server:\n1. Verifies if the credentials in the request's basic-authentication header match `$WAVE_APP_ACCESS_KEY_ID` and `$WAVE_APP_ACCESS_KEY_SECRET`.\n2. Captures the headers and body of the HTTP request.\n3. Responds with a plain-text empty-string (200 status code). Note that the Wave server ignores responses.\n\n### Processing requests\n\nThe HTTP request body is UTF-8 encoded JSON.  The body is parsed to get the `args` dictionary. Additionally, if the `args` dictionary contains a empty-string key, it is removed from the `args` dictionary and treated as the `events` dictionary.\n\nThe client and authentication details are sent as headers:\n- `Wave-Client-ID`: Client ID (each browser tab has a unique client ID).\n- `Wave-Subject-ID`: OIDC subject ID (each user has a unique subject ID).\n- `Wave-Username`: OIDC preferred username.\n- `Wave-Access-Token`: OIDC access token.\n- `Wave-Refresh-Token`: OIDC refresh token.\n\nAt this point, a `page` instance is initialized for the app. The location of the page depends on `$WAVE_APP_MODE`:\n- `unicast`: `/client_id` (the client ID, which uniquely identifies the browser tab).\n- `multicast`: `/subject` (the OIDC subject id, which uniquely identifies the user).\n- `broadcast`: `/foo` (the route the app is responding to).\n\nFinally, all the above items (args, events, headers, page) are passed on to the app for further processing.\n\n### Shutdown\n\nOn app termination, the app de-registers itself from the Wave server by sending a `POST` request to `$WAVE_ADDRESS` (with `Content-Type: application/json`).\n\n```\n{\n  \"unregister_app\": {\n    \"route\": \"/foo\"\n  }\n}\n```\n\n"
        },
        {
          "name": "proxy.go",
          "type": "blob",
          "size": 3.755859375,
          "content": "// Copyright 2020 H2O.ai, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage wave\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"strings\"\n\t\"time\"\n)\n\n// Proxy represents a HTTP proxy\ntype Proxy struct {\n\tclient          *http.Client\n\tauth            *Auth\n\tmaxRequestSize  int64\n\tmaxResponseSize int64\n}\n\n// ProxyRequest represents the request to be sent to the upstream server.\ntype ProxyRequest struct {\n\tMethod  string              `json:\"method\"`\n\tURL     string              `json:\"url\"`\n\tHeaders map[string][]string `json:\"headers\"`\n\tBody    string              `json:\"body\"`\n}\n\n// ProxyResponse represents the response received from the upstream server.\ntype ProxyResponse struct {\n\tStatus  string              `json:\"status\"`\n\tCode    int                 `json:\"code\"`\n\tHeaders map[string][]string `json:\"headers\"`\n\tBody    string              `json:\"body\"`\n}\n\n// ProxyResult represents the result returned for a proxy request.\ntype ProxyResult struct {\n\tError  string         `json:\"error\"`\n\tResult *ProxyResponse `json:\"result\"`\n}\n\nfunc newProxy(auth *Auth, maxRequestSize, maxResponseSize int64) *Proxy {\n\treturn &Proxy{\n\t\t&http.Client{\n\t\t\tTimeout: time.Second * 10,\n\t\t},\n\t\tauth,\n\t\tmaxRequestSize,\n\t\tmaxResponseSize,\n\t}\n}\n\nfunc (p *Proxy) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tswitch r.Method {\n\tcase http.MethodPost:\n\t\tif p.auth != nil && !p.auth.allow(r) {\n\t\t\thttp.Error(w, http.StatusText(http.StatusUnauthorized), http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\treq, err := readRequestWithLimit(w, r.Body, p.maxRequestSize)\n\t\tif err != nil {\n\t\t\techo(Log{\"t\": \"read proxy request body\", \"error\": err.Error()})\n\t\t\tif isRequestTooLarge(err) {\n\t\t\t\thttp.Error(w, http.StatusText(http.StatusRequestEntityTooLarge), http.StatusRequestEntityTooLarge)\n\t\t\t\treturn\n\t\t\t}\n\t\t\thttp.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\tres, err := p.forward(req)\n\t\tif err != nil {\n\t\t\thttp.Error(w, fmt.Sprintf(\"%s: %v\", http.StatusText(http.StatusBadRequest), err), http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\t\tw.Header().Set(\"Content-Type\", contentTypeJSON)\n\t\tw.Write(res)\n\tdefault:\n\t\thttp.Error(w, http.StatusText(http.StatusMethodNotAllowed), http.StatusMethodNotAllowed)\n\t}\n}\n\nfunc (p *Proxy) forward(input []byte) ([]byte, error) {\n\tvar pr ProxyRequest\n\tif err := json.Unmarshal(input, &pr); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed unmarshaling proxy request: %v\", err)\n\t}\n\n\tvar result ProxyResult\n\tif res, err := p.do(pr); err != nil {\n\t\tresult.Error = err.Error()\n\t} else {\n\t\tresult.Result = &res\n\t}\n\n\toutput, err := json.Marshal(&result)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed marshaling proxy response: %v\", err)\n\t}\n\treturn output, nil\n}\n\nfunc (p *Proxy) do(pr ProxyRequest) (ProxyResponse, error) {\n\tvar none ProxyResponse\n\n\treq, err := http.NewRequest(pr.Method, pr.URL, strings.NewReader(pr.Body))\n\tif err != nil {\n\t\treturn none, err\n\t}\n\tfor name, values := range pr.Headers {\n\t\tfor _, value := range values {\n\t\t\treq.Header.Add(name, value)\n\t\t}\n\t}\n\n\tresp, err := p.client.Do(req)\n\tif err != nil {\n\t\treturn none, err\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := readWithLimit(resp.Body, p.maxResponseSize)\n\tif err != nil {\n\t\treturn none, err\n\t}\n\n\treturn ProxyResponse{\n\t\tresp.Status,\n\t\tresp.StatusCode,\n\t\tresp.Header,\n\t\tstring(body),\n\t}, nil\n}\n"
        },
        {
          "name": "py",
          "type": "tree",
          "content": null
        },
        {
          "name": "r",
          "type": "tree",
          "content": null
        },
        {
          "name": "restore.go",
          "type": "blob",
          "size": 2.162109375,
          "content": "// Copyright 2020 H2O.ai, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage wave\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"log\"\n\t\"os\"\n\t\"time\"\n)\n\nvar (\n\tlogSep = []byte(\" \")\n)\n\nfunc initSite(site *Site, aofPath string) {\n\tfile, err := os.Open(aofPath)\n\tif err != nil {\n\t\tlog.Fatalln(\"#\", \"failed opening AOF file:\", err)\n\t}\n\tdefer file.Close()\n\n\tstartTime := time.Now()\n\tline, used := 0, 0\n\tscanner := bufio.NewScanner(file)\n\tfor scanner.Scan() { // FIXME not reliable if line length > 65536 chars\n\t\tline++\n\t\tdata := scanner.Bytes()\n\t\ttokens := bytes.SplitN(data, logSep, 4) // \"date time marker entry\"\n\t\tif len(tokens) < 4 {\n\t\t\tlog.Println(\"#\", \"warning: want (date, time, marker, entry); skipped line\", line)\n\t\t\tcontinue\n\t\t}\n\n\t\tmarker, entry := tokens[2], tokens[3]\n\t\tif len(marker) > 0 {\n\t\t\tmark := marker[0]\n\t\t\tif mark == '#' { // comment\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\ttokens = bytes.SplitN(entry, logSep, 2) // \"url data\"\n\t\t\tif len(tokens) < 2 {\n\t\t\t\tlog.Println(\"#\", \"warning: want (url, data); skipped line\", line)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\turl, data := tokens[0], tokens[1]\n\t\t\tswitch mark {\n\t\t\tcase '*': // patch existing page\n\t\t\t\tsite.patch(string(url), data)\n\t\t\t\tused++\n\t\t\tcase '=': // compacted page; overwrite\n\t\t\t\tsite.set(string(url), data)\n\t\t\t\tused++\n\t\t\tdefault:\n\t\t\t\tlog.Println(\"#\", \"warning: bad marker\", marker, \"on line\", line)\n\t\t\t}\n\t\t}\n\t}\n\n\tlog.Printf(\"# init: %d lines read, %d lines used, %s\\n\", line, used, time.Since(startTime))\n\n\tif err := scanner.Err(); err != nil {\n\t\tlog.Fatalln(\"#\", \"failed scanning AOF file:\", err)\n\t}\n}\n\nfunc CompactSite(aofPath string) {\n\tsite := newSite()\n\tinitSite(site, aofPath)\n\tfor url, page := range site.pages {\n\t\tlog.Println(\"=\", url, string(page.marshal()))\n\t}\n}\n"
        },
        {
          "name": "results.bin",
          "type": "blob",
          "size": 170.869140625,
          "content": null
        },
        {
          "name": "server.go",
          "type": "blob",
          "size": 5.931640625,
          "content": "// Copyright 2020 H2O.ai, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage wave\n\nimport (\n\t\"crypto/tls\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nconst logo = `\n┌────────────────┐ H2O Wave \n│  ┐┌┐┐┌─┐┌ ┌┌─┐ │ %s %s\n│  └┘└┘└─└└─┘└── │ © 2021 H2O.ai, Inc.\n└────────────────┘`\n\n// Log represents key-value data for a log message.\ntype Log map[string]string\n\nfunc echo(m Log) {\n\tif j, err := json.Marshal(m); err == nil { // TODO speed up\n\t\tlog.Println(\"#\", string(j))\n\t}\n}\n\nfunc handleWithBaseURL(baseURL string) func(string, http.Handler) {\n\treturn func(pattern string, handler http.Handler) {\n\t\thttp.Handle(baseURL+pattern, handler)\n\t}\n}\n\nfunc resolveURL(path, baseURL string) string {\n\t// TODO: Ugly - add leading slash for compatibility.\n\t// TODO: Strip leading slash in Py/R clients?\n\treturn \"/\" + strings.TrimPrefix(path, baseURL)\n}\n\nfunc printLaunchBar(addr, baseURL string, isTLS bool) {\n\tif strings.HasPrefix(addr, \":\") {\n\t\taddr = \"localhost\" + addr\n\t}\n\tif isTLS {\n\t\taddr = \"https://\" + addr\n\t} else {\n\t\taddr = \"http://\" + addr\n\t}\n\tmessage := \"Running at \" + addr + baseURL\n\tbar := strings.Repeat(\"─\", len(message)+4)\n\tlog.Println(\"# ┌\" + bar + \"┐\")\n\tlog.Println(\"# │  \" + message + \"  │\")\n\tlog.Println(\"# └\" + bar + \"┘\")\n}\n\n// Run runs the HTTP server.\nfunc Run(conf ServerConf) {\n\tfor _, line := range strings.Split(fmt.Sprintf(logo, conf.Version, conf.BuildDate), \"\\n\") {\n\t\tlog.Println(\"#\", line)\n\t}\n\n\tisTLS := conf.CertFile != \"\" && conf.KeyFile != \"\"\n\n\tif conf.SkipCertVerification {\n\t\thttp.DefaultTransport.(*http.Transport).TLSClientConfig = &tls.Config{InsecureSkipVerify: true}\n\t}\n\n\tprintLaunchBar(conf.Listen, conf.BaseURL, isTLS)\n\n\tsite := newSite()\n\tif len(conf.Init) > 0 {\n\t\tinitSite(site, conf.Init)\n\t}\n\n\thandle := handleWithBaseURL(conf.BaseURL)\n\n\tbroker := newBroker(site, conf.Editable, conf.NoStore, conf.NoLog, conf.KeepAppLive, conf.Debug)\n\tgo broker.run()\n\n\tif conf.Debug {\n\t\thandle(\"_d/site\", newDebugHandler(broker))\n\t}\n\n\tvar auth *Auth\n\n\tif conf.Auth != nil {\n\t\tvar err error\n\t\tif auth, err = newAuth(conf.Auth, conf.BaseURL, conf.BaseURL+\"_auth/init\", conf.BaseURL+\"_auth/login\"); err != nil {\n\t\t\tpanic(fmt.Errorf(\"failed connecting to OIDC provider: %v\", err))\n\t\t}\n\t\thandle(\"_auth/init\", newLoginHandler(auth))\n\t\thandle(\"_auth/callback\", newAuthHandler(auth))\n\t\thandle(\"_auth/logout\", newLogoutHandler(auth, broker))\n\t\thandle(\"_auth/refresh\", newRefreshHandler(auth, conf.Keychain))\n\t}\n\n\thandle(\"_s/\", newSocketServer(broker, auth, conf))\n\n\tfileDir := filepath.Join(conf.DataDir, \"f\")\n\thandle(\"_f/\", newFileServer(fileDir, conf.Keychain, auth, conf.BaseURL+\"_f\"))\n\tfor _, dir := range conf.PrivateDirs {\n\t\tprefix, src := splitDirMapping(dir)\n\t\techo(Log{\"t\": \"private_dir\", \"source\": src, \"address\": prefix})\n\t\thandle(prefix, http.StripPrefix(conf.BaseURL+prefix, newDirServer(src, conf.Keychain, auth)))\n\t}\n\tfor _, dir := range conf.PublicDirs {\n\t\tprefix, src := splitDirMapping(dir)\n\t\techo(Log{\"t\": \"public_dir\", \"source\": src, \"address\": prefix})\n\t\thandle(prefix, http.StripPrefix(conf.BaseURL+prefix, http.FileServer(http.Dir(src))))\n\t}\n\n\thandle(\"_c/\", newCache(conf.BaseURL+\"_c/\", conf.Keychain, conf.MaxCacheRequestSize))\n\thandle(\"_m/\", newMultipartServer(conf.BaseURL+\"_m/\", conf.Keychain, auth, conf.MaxRequestSize))\n\n\tif conf.Proxy {\n\t\thandle(\"_p/\", newProxy(auth, conf.MaxProxyRequestSize, conf.MaxProxyResponseSize))\n\t}\n\n\tif conf.IDE {\n\t\tide := http.StripPrefix(\"_ide\", http.FileServer(http.Dir(path.Join(conf.WebDir, \"_ide\"))))\n\t\thandle(\"_ide\", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tif auth != nil && !auth.allow(r) {\n\t\t\t\thttp.Error(w, http.StatusText(http.StatusUnauthorized), http.StatusUnauthorized)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tide.ServeHTTP(w, r)\n\t\t}))\n\t}\n\n\twebServer, err := newWebServer(site, broker, auth, conf.Keychain, conf.MaxRequestSize, conf.BaseURL, conf.WebDir, conf.Header)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\thandle(\"\", webServer)\n\n\techo(Log{\"t\": \"listen\", \"address\": conf.Listen, \"web-dir\": conf.WebDir, \"base-url\": conf.BaseURL})\n\n\tif isTLS {\n\t\tif err := http.ListenAndServeTLS(conf.Listen, conf.CertFile, conf.KeyFile, nil); err != nil {\n\t\t\techo(Log{\"t\": \"listen_tls\", \"error\": err.Error()})\n\t\t}\n\t} else {\n\t\tif err := http.ListenAndServe(conf.Listen, nil); err != nil {\n\t\t\techo(Log{\"t\": \"listen_no_tls\", \"error\": err.Error()})\n\t\t}\n\t}\n}\n\nfunc splitDirMapping(m string) (string, string) {\n\txs := strings.SplitN(m, \"@\", 2)\n\tif len(xs) < 2 {\n\t\tpanic(fmt.Sprintf(\"invalid directory mapping: want \\\"remote@local\\\", got %s\", m))\n\t}\n\n\tif _, err := os.Stat(xs[1]); os.IsNotExist(err) {\n\t\techo(Log{\"t\": \"warn\", \"msg\": fmt.Sprintf(\"directory does not exist: %s\", xs[1])})\n\t}\n\n\t// Windows prepends the drive letter to the path with a leading slash, e.g. \"/foo/\" => \"C:/foo/\".\n\tif xs[0][1] == ':' {\n\t\txs[0] = xs[0][2:]\n\t}\n\n\treturn strings.TrimLeft(xs[0], \"/\"), xs[1]\n}\n\nfunc readRequestWithLimit(w http.ResponseWriter, r io.ReadCloser, n int64) ([]byte, error) {\n\treturn ioutil.ReadAll(http.MaxBytesReader(w, r, n))\n}\n\nfunc isRequestTooLarge(err error) bool {\n\t// HACK: net/http does not export the error\n\t// https://github.com/golang/go/issues/30715\n\t// https://github.com/golang/go/issues/41493\n\treturn err != nil && err.Error() == \"http: request body too large\"\n}\n\nfunc readWithLimit(r io.Reader, n int64) ([]byte, error) {\n\treturn ioutil.ReadAll(io.LimitReader(r, n))\n}\n"
        },
        {
          "name": "setup.ps1",
          "type": "blob",
          "size": 0.9580078125,
          "content": "# Setup UI.\nSet-Location ui\nnpm ci\nnpm run build\nif ($LastExitCode -ne 0) { exit $LastExitCode }\n\nSet-Location ..\n\n# Setup Py tests.\nSet-Location py\npython -m venv venv\n.\\venv\\Scripts\\python -m pip install --upgrade pip\n.\\venv\\Scripts\\python -m pip install --editable h2o_wave\n.\\venv\\Scripts\\pip install httpx urllib3 typing_extensions\necho \"# Generated in hatch_build.py\\n__platform__ = 'linux'\\n__arch__ = 'amd64'\" > h2o_wave/h2o_wave/metadata.py\nif ($LastExitCode -ne 0) { exit $LastExitCode }\n\nSet-Location ..\n\n# Setup VSC.\nSet-Location tools\\vscode-extension\nnpm ci\npython -m venv venv\n.\\venv\\Scripts\\python -m pip install --upgrade pip\n.\\venv\\Scripts\\python -m pip install -r requirements.txt\nnpm run compile\nif ($LastExitCode -ne 0) { exit $LastExitCode }\n\nSet-Location ..\\..\n\n# Build waved.\n$Env:GOEXPERIMENT = 'boringcrypto'\ngo build -ldflags '-X main.Version=DEV -X main.BuildDate=20230317152454' -o waved cmd/wave/main.go\nif ($LastExitCode -ne 0) { exit $LastExitCode }\n"
        },
        {
          "name": "site.go",
          "type": "blob",
          "size": 3.0625,
          "content": "// Copyright 2020 H2O.ai, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage wave\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"sort\"\n\t\"sync\"\n)\n\nconst (\n\tkeySeparator = \" \"\n)\n\n// Site represents the website, and holds a collection of pages.\ntype Site struct {\n\tsync.RWMutex\n\tpages map[string]*Page // url => page\n\tns    *Namespace       // buffer type namespace\n}\n\nfunc newSite() *Site {\n\treturn &Site{pages: make(map[string]*Page), ns: newNamespace()}\n}\n\n// at returns the page at url, else nil\nfunc (site *Site) at(url string) *Page {\n\tsite.RLock()\n\tdefer site.RUnlock()\n\tif p, ok := site.pages[url]; ok {\n\t\treturn p\n\t}\n\treturn nil\n}\n\n// get returns the page at url, else mints a new one.\nfunc (site *Site) get(url string) *Page {\n\tif p := site.at(url); p != nil {\n\t\treturn p\n\t}\n\n\tp := newPage()\n\n\tsite.Lock()\n\tsite.pages[url] = p\n\tsite.Unlock()\n\n\treturn p\n}\n\n// del deletes the page at url.\nfunc (site *Site) del(url string) {\n\tsite.Lock()\n\tdelete(site.pages, url)\n\tsite.Unlock()\n}\n\n// set overwrites a page's content.\nfunc (site *Site) set(url string, data []byte) error {\n\tvar ops OpsD\n\tif err := json.Unmarshal(data, &ops); err != nil {\n\t\treturn fmt.Errorf(\"failed unmarshaling data: %v\", err)\n\t}\n\tif ops.P != nil {\n\t\tsite.pages[url] = loadPage(site.ns, ops.P)\n\t}\n\treturn nil\n}\n\n// patch patches a page's content.\nfunc (site *Site) patch(url string, data []byte) error {\n\tvar ops OpsD\n\tif err := json.Unmarshal(data, &ops); err != nil { // TODO speed up\n\t\treturn fmt.Errorf(\"failed unmarshaling data: %v\", err)\n\t}\n\tsite.exec(url, ops)\n\treturn nil\n}\n\n// exec applies changes to a page's content.\nfunc (site *Site) exec(url string, ops OpsD) {\n\tpage := site.get(url)\n\tpage.Lock()\n\tfor _, op := range ops.D {\n\t\tif len(op.K) > 0 {\n\t\t\tif op.C != nil {\n\t\t\t\tpage.set(op.K, loadCycBuf(site.ns, op.C))\n\t\t\t} else if op.F != nil {\n\t\t\t\tpage.set(op.K, loadFixBuf(site.ns, op.F))\n\t\t\t} else if op.M != nil {\n\t\t\t\tpage.set(op.K, loadMapBuf(site.ns, op.M))\n\t\t\t} else if op.L != nil {\n\t\t\t\tpage.set(op.K, loadListBuf(site.ns, op.L))\n\t\t\t} else if op.D != nil {\n\t\t\t\tpage.cards[op.K] = loadCard(site.ns, CardD{op.D, op.B})\n\t\t\t} else {\n\t\t\t\tpage.set(op.K, op.V)\n\t\t\t}\n\t\t} else { // drop page\n\t\t\tsite.del(url)\n\t\t\tpage.Unlock()\n\t\t\tpage = site.get(url)\n\t\t\tpage.Lock()\n\t\t}\n\t}\n\tpage.cache = nil // will be re-cached on next call to site.get(url)\n\tpage.Unlock()\n}\n\n// urls returns a sorted slice of urls hosted by this site.\nfunc (site *Site) urls() []string {\n\tsite.RLock()\n\tdefer site.RUnlock()\n\n\tpages := site.pages\n\n\turls := make([]string, len(pages))\n\ti := 0\n\tfor url := range pages {\n\t\turls[i] = url\n\t\ti++\n\t}\n\n\tsort.Strings(urls)\n\treturn urls\n}\n"
        },
        {
          "name": "socket.go",
          "type": "blob",
          "size": 3.5576171875,
          "content": "// Copyright 2020 H2O.ai, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage wave\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\n// SocketServer represents a websocket server.\ntype SocketServer struct {\n\tbroker           *Broker\n\tauth             *Auth\n\teditable         bool\n\tbaseURL          string\n\tforwardedHeaders map[string]bool\n\tpingInterval     time.Duration\n\treconnectTimeout time.Duration\n\tupgrader         websocket.Upgrader\n}\n\nfunc newSocketServer(broker *Broker, auth *Auth, conf ServerConf) *SocketServer {\n\tvar checkOrigin func(*http.Request) bool\n\tif len(conf.AllowedOrigins) != 0 {\n\t\tcheckOrigin = func(r *http.Request) bool {\n\t\t\treturn conf.AllowedOrigins[\"*\"] || conf.AllowedOrigins[r.Header.Get(\"Origin\")]\n\t\t}\n\t}\n\tupgrader := websocket.Upgrader{\n\t\tReadBufferSize:  1024, // TODO review\n\t\tWriteBufferSize: 1024, // TODO review\n\t\tCheckOrigin:     checkOrigin,\n\t}\n\treturn &SocketServer{broker, auth, conf.Editable, conf.BaseURL, conf.ForwardedHeaders, conf.PingInterval, conf.ReconnectTimeout, upgrader}\n}\n\nfunc (s *SocketServer) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tconn, err := s.upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\techo(Log{\"t\": \"socket_upgrade\", \"err\": err.Error()})\n\t\treturn\n\t}\n\n\tsession := anonymous\n\tif s.auth != nil {\n\t\tsession = s.auth.identify(r)\n\t\tif session == nil {\n\t\t\t// As per websocket spec, clients are not required to follow HTTP redirects. So we send a redirect message.\n\t\t\tif msg, err := json.Marshal(OpsD{U: s.baseURL + \"_auth/logout\"}); err == nil {\n\t\t\t\tsw, err := conn.NextWriter(websocket.TextMessage)\n\t\t\t\tif err != nil {\n\t\t\t\t\thttp.Error(w, http.StatusText(http.StatusUnauthorized), http.StatusUnauthorized)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tsw.Write(msg)\n\t\t\t\tsw.Close()\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t}\n\n\theader := make(http.Header)\n\tif s.forwardedHeaders != nil {\n\t\tfor k, v := range r.Header {\n\t\t\tif s.forwardedHeaders[\"*\"] || s.forwardedHeaders[strings.ToLower(k)] {\n\t\t\t\theader[k] = v\n\t\t\t}\n\t\t}\n\t}\n\tclientID := r.URL.Query().Get(\"client-id\")\n\tclient := s.broker.getClient(clientID)\n\tif client != nil {\n\t\tclient.lock.Lock()\n\t\t// Close prev connection gracefully.\n\t\tclient.conn.WriteMessage(websocket.CloseMessage, []byte{})\n\t\tclient.conn.Close()\n\t\tclient.conn = conn\n\t\tclient.state = STATE_RECONNECT\n\t\tclient.addr = getRemoteAddr(r)\n\t\tclient.lock.Unlock()\n\t\techo(Log{\"t\": \"client_reconnect\", \"client_id\": client.id, \"addr\": client.addr})\n\t} else {\n\t\tclient = newClient(getRemoteAddr(r), s.auth, session, s.broker, conn, s.editable, s.baseURL, &header, s.pingInterval, s.reconnectTimeout)\n\n\t\thelloMsg, err := json.Marshal(OpsD{I: client.id})\n\t\tif err != nil {\n\t\t\thttp.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\tif !client.send(helloMsg) {\n\t\t\thttp.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t}\n\n\tgo client.flush()\n\tgo client.listen()\n}\n\nfunc getRemoteAddr(r *http.Request) string {\n\tif addr := r.Header.Get(\"X-FORWARDED-FOR\"); addr != \"\" { // forwarded via a proxy?\n\t\treturn addr\n\t}\n\treturn r.RemoteAddr\n}\n"
        },
        {
          "name": "start.sh",
          "type": "blob",
          "size": 0.36328125,
          "content": "make build-server\n\n./waved \\\n    -oidc-client-id wave \\\n    -oidc-client-secret 78a895e1-af9d-46c4-a6b0-116e7644c054 \\\n    -oidc-redirect-url http://localhost:10101/_auth/callback \\\n    -oidc-provider-url http://localhost:8080/auth/realms/master \\\n    -oidc-end-session-url http://localhost:8080/auth/realms/master/protocol/openid-connect/logout \\\n    -web-dir ./ui/build\n"
        },
        {
          "name": "studio",
          "type": "tree",
          "content": null
        },
        {
          "name": "test.ps1",
          "type": "blob",
          "size": 0.7138671875,
          "content": "# TODO: Think about how to run keycloak inside windows runner as it has only linux images.\n\n# Test Py.\nSet-Location py\n.\\venv\\Scripts\\python -m tests\nif ($LastExitCode -ne 0) { exit $LastExitCode }\n$env:H2O_WAVE_BASE_URL= '/foo/'; .\\venv\\Scripts\\python -m tests\nif ($LastExitCode -ne 0) { exit $LastExitCode }\n$env:H2O_WAVE_WAVED_DIR='..'; .\\venv\\Scripts\\python -m tests\nif ($LastExitCode -ne 0) { exit $LastExitCode }\n$env:H2O_WAVE_WAVED_DIR='..'; $env:H2O_WAVE_BASE_URL='/foo/'; .\\venv\\Scripts\\python -m tests\nif ($LastExitCode -ne 0) { exit $LastExitCode }\n\nSet-Location ..\n\n# Test VSC.\nSet-Location tools\\vscode-extension\n.\\venv\\Scripts\\python -m server.tests\nif ($LastExitCode -ne 0) { exit $LastExitCode }\n\nSet-Location ..\\.."
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        },
        {
          "name": "tools",
          "type": "tree",
          "content": null
        },
        {
          "name": "types.go",
          "type": "blob",
          "size": 2.296875,
          "content": "// Copyright 2020 H2O.ai, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage wave\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n)\n\n// Namespace is a cache of all known data types in use.\ntype Namespace struct {\n\tsync.RWMutex\n\ttypes map[string]Typ // \"foo\\nbar\\nbaz\" -> type\n}\n\nfunc newNamespace() *Namespace {\n\treturn &Namespace{types: make(map[string]Typ)}\n}\n\nfunc (ns *Namespace) get(k string) (Typ, bool) {\n\tns.RLock()\n\tdefer ns.RUnlock()\n\tt, ok := ns.types[k]\n\treturn t, ok\n}\n\nfunc (ns *Namespace) make(fields []string) Typ {\n\tif len(fields) == 0 {\n\t\treturn Typ{}\n\t}\n\tk := strings.Join(fields, \"\\n\")\n\tif t, ok := ns.get(k); ok {\n\t\treturn t\n\t}\n\tt := newType(fields)\n\tns.Lock()\n\tns.types[k] = t\n\tns.Unlock()\n\treturn t\n}\n\n// Typ represents a data type.\ntype Typ struct {\n\tf []string       // fields\n\tm map[string]int // offsets\n}\n\nfunc newType(fields []string) Typ {\n\tm := make(map[string]int)\n\tfor i, f := range fields {\n\t\tm[f] = i\n\t}\n\treturn Typ{fields, m}\n}\n\nfunc (t Typ) match(x interface{}) ([]interface{}, bool) {\n\tif x, ok := x.([]interface{}); ok && len(x) == len(t.f) {\n\t\treturn x, true\n\t}\n\treturn nil, false\n}\n\n// Cur represents a type-aware cursor for accessing fields in a tuple.\ntype Cur struct {\n\tt   Typ\n\ttup []interface{}\n}\n\nfunc (c Cur) get(f string) interface{} {\n\tt, tup := c.t, c.tup\n\tif tup != nil {\n\t\tif i, ok := t.m[f]; ok { // string key?\n\t\t\tif i >= 0 && i < len(tup) {\n\t\t\t\treturn tup[i]\n\t\t\t}\n\t\t} else if i, err := strconv.Atoi(f); err == nil { // integer index?\n\t\t\tif i >= 0 && i < len(tup) {\n\t\t\t\treturn tup[i]\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (c Cur) set(f string, v interface{}) {\n\tt, tup := c.t, c.tup\n\tif tup != nil {\n\t\tif i, ok := t.m[f]; ok {\n\t\t\tif i >= 0 && i < len(tup) {\n\t\t\t\ttup[i] = v\n\t\t\t}\n\t\t} else if i, err := strconv.Atoi(f); err == nil {\n\t\t\tif i >= 0 && i < len(tup) {\n\t\t\t\ttup[i] = v\n\t\t\t}\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "ui",
          "type": "tree",
          "content": null
        },
        {
          "name": "university",
          "type": "tree",
          "content": null
        },
        {
          "name": "web_server.go",
          "type": "blob",
          "size": 5.6650390625,
          "content": "// Copyright 2020 H2O.ai, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage wave\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"github.com/h2oai/wave/pkg/keychain\"\n)\n\n// WebServer represents a web server (d'oh).\ntype WebServer struct {\n\tsite           *Site\n\tbroker         *Broker\n\tfs             http.Handler\n\tkeychain       *keychain.Keychain\n\tmaxRequestSize int64\n\tbaseURL        string\n}\n\nconst (\n\tcontentTypeJSON = \"application/json\"\n\tcontentTypeHTML = \"text/html; charset=UTF-8\"\n)\n\nfunc newWebServer(\n\tsite *Site,\n\tbroker *Broker,\n\tauth *Auth,\n\tkeychain *keychain.Keychain,\n\tmaxRequestSize int64,\n\tbaseURL string,\n\twebDir string,\n\theader http.Header,\n) (*WebServer, error) {\n\n\t// read default index.html page from the web root\n\tindexPage, err := ioutil.ReadFile(filepath.Join(webDir, \"index.html\"))\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed reading default index.html page: %v\", err)\n\t}\n\n\tfs := handleStatic([]byte(mungeIndexPage(baseURL, string(indexPage))), http.StripPrefix(baseURL, http.FileServer(http.Dir(webDir))), header)\n\tif auth != nil {\n\t\tfs = auth.wrap(fs)\n\t}\n\treturn &WebServer{site, broker, fs, keychain, maxRequestSize, baseURL}, nil\n}\n\nfunc mungeIndexPage(baseURL, html string) string {\n\t// HACK\n\t// set base URL as a body tag attribute, to be used by the front-end for deducing hash-routing and websocket addresses.\n\thtml = strings.Replace(html, \"<body\", `<body data-base-url=\"`+baseURL+`\"`, 1)\n\t// ./wave-static/a/b/c.d -> /base-url/wave-static/a/b/c.d\n\thtml = strings.ReplaceAll(html, `=\"./wave-static/`, `=\"`+baseURL+\"wave-static/\")\n\treturn html\n}\n\nfunc (s *WebServer) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tswitch r.Method {\n\tcase http.MethodPatch: // writes\n\t\tif !s.keychain.Guard(w, r) {\n\t\t\treturn\n\t\t}\n\t\ts.patch(w, r)\n\tcase http.MethodGet: // reads\n\t\tswitch r.Header.Get(\"Content-Type\") {\n\t\tcase contentTypeJSON: // data\n\t\t\tif !s.keychain.Guard(w, r) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\ts.get(w, r)\n\t\tdefault: // static/public assets\n\t\t\th := s.fs\n\t\t\tif strings.Contains(r.Header.Get(\"Accept-Encoding\"), \"gzip\") {\n\t\t\t\th = serveGzipped(s.fs)\n\t\t\t}\n\t\t\th.ServeHTTP(w, r)\n\t\t}\n\tcase http.MethodPost: // all other APIs\n\t\tif !s.keychain.Guard(w, r) {\n\t\t\treturn\n\t\t}\n\t\ts.post(w, r)\n\tdefault:\n\t\thttp.Error(w, http.StatusText(http.StatusMethodNotAllowed), http.StatusMethodNotAllowed)\n\t}\n}\n\nfunc (s *WebServer) patch(w http.ResponseWriter, r *http.Request) {\n\tdata, err := readRequestWithLimit(w, r.Body, s.maxRequestSize)\n\tif err != nil {\n\t\techo(Log{\"t\": \"read patch request body\", \"error\": err.Error()})\n\t\tif isRequestTooLarge(err) {\n\t\t\thttp.Error(w, http.StatusText(http.StatusRequestEntityTooLarge), http.StatusRequestEntityTooLarge)\n\t\t\treturn\n\t\t}\n\t\thttp.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)\n\t\treturn\n\t}\n\ts.broker.patch(resolveURL(r.URL.Path, s.baseURL), data)\n}\n\nfunc (s *WebServer) get(w http.ResponseWriter, r *http.Request) {\n\turl := resolveURL(r.URL.Path, s.baseURL)\n\tpage := s.site.at(url)\n\tif page == nil {\n\t\techo(Log{\"t\": \"page_not_found\", \"url\": url})\n\t\thttp.Error(w, http.StatusText(http.StatusNotFound), http.StatusNotFound)\n\t\treturn\n\t}\n\n\tdata := page.marshal()\n\tif data == nil {\n\t\techo(Log{\"t\": \"cache_miss\", \"url\": url})\n\t\thttp.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)\n\t\treturn\n\t}\n\tw.Header().Set(\"Content-Type\", contentTypeJSON)\n\tw.Write(data)\n}\n\nfunc (s *WebServer) post(w http.ResponseWriter, r *http.Request) {\n\tswitch r.Header.Get(\"Content-Type\") {\n\tcase contentTypeJSON: // data\n\t\tvar req AppRequest\n\n\t\tb, err := readRequestWithLimit(w, r.Body, s.maxRequestSize)\n\t\tif err != nil {\n\t\t\techo(Log{\"t\": \"read post request body\", \"error\": err.Error()})\n\t\t\tif isRequestTooLarge(err) {\n\t\t\t\thttp.Error(w, http.StatusText(http.StatusRequestEntityTooLarge), http.StatusRequestEntityTooLarge)\n\t\t\t\treturn\n\t\t\t}\n\t\t\thttp.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\tif err := json.Unmarshal(b, &req); err != nil {\n\t\t\techo(Log{\"t\": \"json_unmarshal\", \"error\": err.Error()})\n\t\t\thttp.Error(w, http.StatusText(http.StatusBadRequest), http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\t\tif req.RegisterApp != nil {\n\t\t\tq := req.RegisterApp\n\t\t\ts.broker.addApp(q.Mode, q.Route, q.Address, q.KeyID, q.KeySecret)\n\t\t} else if req.UnregisterApp != nil {\n\t\t\tq := req.UnregisterApp\n\t\t\ts.broker.dropApp(q.Route)\n\t\t}\n\tdefault:\n\t\thttp.Error(w, http.StatusText(http.StatusBadRequest), http.StatusBadRequest)\n\t}\n}\n\nfunc handleStatic(indexPage []byte, fs http.Handler, extraHeader http.Header) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t// if the url has an extension, serve the file\n\t\tif len(path.Ext(r.URL.Path)) > 0 {\n\t\t\tfs.ServeHTTP(w, r)\n\t\t\treturn\n\t\t}\n\n\t\t// url has no extension; assume index.html\n\t\t// bypass file server, write index.html containing embedded base URL.\n\n\t\theader := w.Header()\n\t\theader.Add(\"Content-Type\", contentTypeHTML)\n\t\theader.Add(\"Cache-Control\", \"no-cache, must-revalidate\")\n\t\theader.Add(\"Pragma\", \"no-cache\")\n\n\t\tcopyHeaders(extraHeader, header)\n\n\t\tw.Write(indexPage)\n\t})\n}\n\nfunc copyHeaders(src, dst http.Header) {\n\tfor k, vs := range src {\n\t\tfor _, v := range vs {\n\t\t\tdst.Add(k, v)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "website",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}