{
  "metadata": {
    "timestamp": 1736559622177,
    "page": 267,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjI3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "Netflix/security_monkey",
      "stars": 4351,
      "defaultBranch": "develop",
      "files": [
        {
          "name": ".coveragerc",
          "type": "blob",
          "size": 0.0400390625,
          "content": "[report]\ninclude = security_monkey/*.py\n\n"
        },
        {
          "name": ".dockerignore",
          "type": "blob",
          "size": 0.08984375,
          "content": ".git\nsecmonkey.env\nboto.cfg\n.travis.yml\n#docs\nsupervisor\nconfig-default.py\ngenerate-docs.py\n"
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.7490234375,
          "content": "*.py[cod]\n.*.swp\n\n# C extensions\n*.so\n\n# Packages\n*.egg\n*.egg-info\n.python-eggs\ndist\nbuild\n_build\neggs\nparts\nbin\nvar\nsdist\ndevelop-eggs\n.installed.cfg\nlib64\n__pycache__\n\n# Installer logs\npip-log.txt\n\n# Unit test / coverage reports\n.coverage\n.tox\nnosetests.xml\n\n# Translations\n*.mo\n\n# Mr Developer\n.mr.developer.cfg\n.project\n.pydevproject\n\n# breadcrumbs\n.DS_Store\n\n# I think my vim python-mode started adding these everywhere.\n.ropeproject\n\n*.log\n*.log.*\n\ndart/.pub\ndart/.packages\ndart/web/ico/packages\nsecurity_monkey/static\ndart/lib/util/constants.dart\ndevlog/\nvenv/\nvenv\n.idea/\ndart/.idea\ndart/.packages\ndart/web/ico/packages\nboto.cfg\nsecmonkey.env\n*.crt\n*.key\npostgres-data/\ndocker-compose.override.yml\n.cache/\ndart/pubspec.lock\ncelerybeat-schedule\ncelerybeat.pid\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 3.447265625,
          "content": "# Travis YAML file for Security Monkey.\n\n# Only way to get multiple builds to work without having the \"default\" job working was to\n# duplicate everything :/  See: https://github.com/travis-ci/travis-ci/issues/4681\nmatrix:\n#  allow_failures:\n#  - python: \"3.6\"\n\n    #####################################################\n\n    ##### PYTHON UNIT TEST JOB #####\n    - dist: Bionic\n      sudo: required\n      language: python\n      python: \"3.7\"\n\n      env:\n      - UNIT_TEST_JOB=true\n      - PIP_DOWNLOAD_CACHE=\".pip_download_cache\"\n      - SECURITY_MONKEY_SETTINGS=\"$( pwd )/env-config/config.py\"\n\n      addons:\n        postgresql: \"9.4\"\n\n      before_script:\n      - psql -c \"CREATE DATABASE secmonkey;\" -U postgres\n      - psql -c \"CREATE ROLE securitymonkeyuser LOGIN PASSWORD 'securitymonkeypassword';\" -U postgres\n      - psql -c \"CREATE SCHEMA secmonkey GRANT Usage, Create ON SCHEMA secmonkey TO securitymonkeyuser;\" -U postgres\n      - psql -c \"set timezone TO 'GMT';\" -U postgres\n      - pip install pip --upgrade\n      - pip install setuptools --upgrade\n      - pip install google-compute-engine\n      - pip install oauth2client\n      - pip install google-api-python-client\n      - pip install httplib2\n      - pip install cloudaux\\[gcp\\]\n      - pip install cloudaux\\[openstack\\]\n      - pip install -e .\n      - pip install .\"[tests]\"\n      - pip install coveralls\n      - monkey db upgrade\n      - monkey amazon_accounts\n\n      before_install:\n        - sudo mkdir -p /var/log/security_monkey/\n        - sudo touch /var/log/security_monkey/securitymonkey.log\n        - sudo chown travis /var/log/security_monkey/securitymonkey.log\n\n      install:\n        - sed -i '/WTF_CSRF_ENABLED = True/c\\WTF_CSRF_ENABLED = False' `pwd`/env-config/config.py\n        - pip install bandit\n        - pip install pylint\n        - pip install flake8\n        - pip install coverage==5.0.3\n\n      script:\n        - coverage run -a -m py.test security_monkey/tests/auditors || exit 1\n        - coverage run -a -m py.test security_monkey/tests/watchers || exit 1\n        - coverage run -a -m py.test security_monkey/tests/core || exit 1\n        - coverage run -a -m py.test security_monkey/tests/scheduling || exit 1\n        - coverage run -a -m py.test security_monkey/tests/views || exit 1\n        - coverage run -a -m py.test security_monkey/tests/interface || exit 1\n        - coverage run -a -m py.test security_monkey/tests/utilities || exit 1\n        - bandit -r -ll -ii -x security_monkey/tests .\n        - pylint -E -d E1101,E0611,F0401 --ignore=service.py,datastore.py,datastore_utils.py,watcher.py,test_celery_scheduler.py security_monkey\n        - flake8 . --count --select=E901,E999,F821,F822,F823 --show-source --statistics\n\n      after_success:\n        - coveralls\n        - coverage report\n    #####################################################\n\n    ##### BUILD DOCKER CONTAINER JOB #####\n    - dist: Bionic\n      sudo: required\n\n      env:\n        - BUILD_DOCKER=True\n        - DOCKER_COMPOSE_VERSION=1.18.0\n        - PIP_DOWNLOAD_CACHE=\".pip_download_cache\"\n        - SECURITY_MONKEY_SETTINGS=\"$( pwd )/env-config/config.py\"\n\n      services:\n        - docker\n\n      script:\n        - docker-compose --version\n        - docker-compose build\n    #####################################################\n\n    ##### TEST DART JOB #####\n    - dist: Bionic\n      env: DART_TEST=True\n\n      script: sh env_tests/test_dart.sh\n    #####################################################\n\ncache:\n  directories:\n    - .pip_download_cache\n"
        },
        {
          "name": ".venv",
          "type": "blob",
          "size": 0.0146484375,
          "content": "securitymonkey\n"
        },
        {
          "name": "AUTHORS",
          "type": "blob",
          "size": 0.1513671875,
          "content": "- Patrick Kelley <pkelley@netflix.com>\n- Kevin Glisson <kglisson@netflix.com>\n- Roy Rapoport <rrapoport@netflix.com>\n- Travis McPeak <tmcpeak@netflix.com>\n"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 2.0673828125,
          "content": "# Copyright 2018 Netflix, Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nFROM ubuntu:18.04\nMAINTAINER Netflix Open Source Development <talent@netflix.com>\n\nENV SECURITY_MONKEY_VERSION=v1.1.3 \\\n    SECURITY_MONKEY_SETTINGS=/usr/local/src/security_monkey/env-config/config-docker.py\n\nSHELL [\"/bin/bash\", \"-c\"]\nWORKDIR /usr/local/src/security_monkey\nCOPY requirements.txt /usr/local/src/security_monkey/\n\nRUN echo \"UTC\" > /etc/timezone\\\n\nARG DEBIAN_FRONTEND=noninteractive\nRUN apt-get update && apt-get install -y software-properties-common\nRUN add-apt-repository ppa:deadsnakes/ppa\nRUN apt-get update && apt-get install -y \\\n        python3.7 \\\n        python3-pip\nRUN python3.7 -m pip install pip\nRUN apt-get update && apt-get install -y \\\n        python3-distutils \\\n        python3-setuptools\n\nARG DEBIAN_FRONTEND=noninteractive\nRUN apt-get install --no-install-recommends -y build-essential && \\\n    apt-get install --no-install-recommends -y wget postgresql postgresql-contrib libpq-dev libffi-dev libxml2-dev libxmlsec1-dev && \\\n    apt-get clean -y && \\\n    pip3 install setuptools --upgrade && \\\n    pip3 install pip --upgrade && \\\n    hash -d pip3 && \\\n    pip3 install \"urllib3[secure]\" --upgrade && \\\n    pip3 install google-compute-engine && \\\n    pip3 install cloudaux\\[gcp\\] && \\\n    pip3 install cloudaux\\[openstack\\] && \\\n    pip3 install python3-saml && \\\n    pip3 install -r requirements.txt\n    \nCOPY . /usr/local/src/security_monkey\nRUN pip3 install .\"[onelogin]\" && \\\n    /bin/mkdir -p /var/log/security_monkey/ && \\\n    /usr/bin/touch /var/log/security_monkey/securitymonkey.log\n\nEXPOSE 5000\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 11.0771484375,
          "content": "\n                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"[]\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright 2014 Netflix, Inc.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License."
        },
        {
          "name": "OSSMETADATA",
          "type": "blob",
          "size": 0.01953125,
          "content": "osslifecycle=active\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 3.5439453125,
          "content": "# NOTE: Security Monkey is in maintenance mode and will be end-of-life in 2020.\n\n- For AWS users, please make use of [AWS Config](https://aws.amazon.com/config/).\n- For GCP users, please make use of [Cloud Asset Inventory](https://cloud.google.com/resource-manager/docs/cloud-asset-inventory/overview).\n\nSecurity Monkey\n===============\n\n<img align=\"right\" alt=\"Security Monkey Logo 2017\" src=\"docs/images/Security_Monkey.png\" width=\"50%\">\n\nSecurity Monkey monitors your [AWS and GCP accounts](https://medium.com/@Netflix_Techblog/netflix-security-monkey-on-google-cloud-platform-gcp-f221604c0cc7) for policy changes and alerts on insecure configurations.  Support is available for OpenStack public and private clouds.  Security Monkey can also watch and monitor your GitHub organizations, teams, and repositories.\n\nIt provides a single UI to browse and search through all of your accounts, regions, and cloud services.  The monkey remembers previous states and can show you exactly what changed, and when.\n\nSecurity Monkey can be extended with [custom account types](docs/plugins.md), [custom watchers](docs/development.md#adding-a-watcher), [custom auditors](docs/development.md#adding-an-auditor), and [custom alerters](docs/misc.md#custom-alerters).\n\nIt works on CPython 2.7. It is known to work on Ubuntu Linux and OS X.\n\n[![Gitter chat](https://badges.gitter.im/gitterHQ/gitter.png)](https://gitter.im/Netflix/security_monkey)\n\n| Develop Branch  | Master Branch |\n| ------------- | ------------- |\n| [![Build Status](https://travis-ci.com/Netflix/security_monkey.svg?branch=develop)](https://travis-ci.com/Netflix/security_monkey)  | [![Build Status](https://travis-ci.com/Netflix/security_monkey.svg?branch=master)](https://travis-ci.com/Netflix/security_monkey)  |\n| [![Coverage Status](https://coveralls.io/repos/github/Netflix/security_monkey/badge.svg?branch=develop)](https://coveralls.io/github/Netflix/security_monkey?branch=develop)  | [![Coverage Status](https://coveralls.io/repos/github/Netflix/security_monkey/badge.svg?branch=master)](https://coveralls.io/github/Netflix/security_monkey?branch=master) |\n\n### Special Note:\nNetflix's support for Security Monkey has been reduced for minor bug fixes only. That being said, we are happy to accept and merge pull-requests that fix bugs and add new features as appropriate.\n\n🚨⚠️🥁🎺 PLEASE READ: BREAKING CHANGES FOR 1.0 🎺🥁⚠️🚨\n--------------\nIf you are upgrading to 1.0 for the first time, please review the [Quickstart](docs/quickstart.md) and the [Autostarting](docs/autostarting.md)\ndocuments as there is a new deployment pattern for Security Monkey. Also, new IAM permissions have been added.\n\nProject resources\n-----------------\n\n- [Security Monkey Architecture](docs/architecture.md)\n- [Quickstart](docs/quickstart.md)\n- [User Guide](docs/userguide.md)\n- [Upgrading](docs/update.md)\n- [Changelog](docs/changelog.md)\n- [Source code](https://github.com/netflix/security_monkey)\n- [Issue tracker](https://github.com/netflix/security_monkey/issues)\n- [Gitter.im Chat Room](https://gitter.im/Netflix/security_monkey)\n- [CloudAux](https://github.com/Netflix-Skunkworks/cloudaux)\n- [PolicyUniverse](https://github.com/Netflix-Skunkworks/policyuniverse)\n- [Troubleshooting](docs/troubleshooting.md)\n\nInstance Diagram\n---------------\nThe components that make up Security Monkey are as follows (not AWS specific):\n![diagram](docs/images/sm_instance_diagram.png)\n\n\nAccess Diagram\n------------\nSecurity Monkey accesses accounts to scan via credentials it is provided (\"Role Assumption\" where available).\n![diagram](docs/images/sm_iam_diagram.png)\n"
        },
        {
          "name": "config-default.py",
          "type": "blob",
          "size": 0.6025390625,
          "content": "#     Copyright 2014 Netflix, Inc.\n#\n#     Licensed under the Apache License, Version 2.0 (the \"License\");\n#     you may not use this file except in compliance with the License.\n#     You may obtain a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#     Unless required by applicable law or agreed to in writing, software\n#     distributed under the License is distributed on an \"AS IS\" BASIS,\n#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#     See the License for the specific language governing permissions and\n#     limitations under the License.\n"
        },
        {
          "name": "dart",
          "type": "tree",
          "content": null
        },
        {
          "name": "data",
          "type": "tree",
          "content": null
        },
        {
          "name": "docker-compose.init.yml",
          "type": "blob",
          "size": 0.7314453125,
          "content": "---\n\nversion: '3.2'\nservices:\n  postgres:\n    container_name: secmonkey-db\n    image: postgres:10.1\n\n  init:\n    container_name: init\n    build: .\n    image: secmonkey:latest\n    working_dir: /usr/local/src/security_monkey\n    volumes:\n        - type: bind\n          source: ./data/aws_accounts.json\n          target: /usr/local/src/security_monkey/data/aws_accounts.json\n        - type: bind\n          source: ./docker\n          target: /usr/local/src/security_monkey/docker\n        - type: bind\n          source: ./env-config/config-docker.py\n          target: /usr/local/src/security_monkey/env-config/config-docker.py\n    depends_on:\n      - postgres\n    env_file: secmonkey.env\n    entrypoint: /usr/local/src/security_monkey/docker/api-init.sh\n"
        },
        {
          "name": "docker-compose.shell.yml",
          "type": "blob",
          "size": 0.0986328125,
          "content": "---\n\nversion: '2'\nservices:\n  data:\n    stdin_open: true\n    tty: true\n    entrypoint: [\"/bin/bash\"]\n"
        },
        {
          "name": "docker-compose.yml",
          "type": "blob",
          "size": 2.5361328125,
          "content": "---\n\n###\n#\n# Documentation: http://securitymonkey.readthedocs.io/en/latest/index.html\n#                http://securitymonkey.readthedocs.io/en/latest/docker.html\n#\n###\n\nversion: '2'\nservices:\n  postgres:\n    container_name: secmonkey-db\n    image: postgres:10.1\n    #volumes:\n    #  - ./postgres-data/:/var/lib/postgresql/data\n    environment:\n      - POSTGRES_DB=secmonkey\n\n  redis:\n      container_name: secmonkey-redis\n      image: redis:4\n\n  data:\n    container_name: secmonkey-data\n    build: .\n    image: secmonkey:latest\n    working_dir: /usr/local/src/security_monkey\n    volumes:\n      - ./data/aws_accounts.json:/usr/local/src/security_monkey/data/aws_accounts.json\n      - ./docker:/usr/local/src/security_monkey/docker/\n      - ./env-config/config-docker.py:/usr/local/src/security_monkey/env-config/config-docker.py\n    depends_on:\n      - postgres\n    env_file: secmonkey.env\n\n  api:\n    container_name: secmonkey-api\n    image: secmonkey:latest\n    volumes_from:\n      - data\n    depends_on:\n      - postgres\n    env_file: secmonkey.env\n    entrypoint: [\"/usr/local/src/security_monkey/docker/api-start.sh\"]\n\n  scheduler:\n    container_name: secmonkey-scheduler\n    image: secmonkey:latest\n    volumes_from:\n      - data\n    depends_on:\n      - data\n      - redis\n    volumes:\n      - ./docker/celeryconfig.py:/usr/local/src/security_monkey/security_monkey/celeryconfig.py\n    env_file: secmonkey.env\n    environment:\n      - SECURITY_MONKEY_REDIS_HOST=redis\n    entrypoint: [\"/usr/local/src/security_monkey/docker/scheduler-start.sh\"]\n\n  worker:\n    container_name: secmonkey-worker\n    image: secmonkey:latest\n    volumes_from:\n      - data\n    depends_on:\n      - scheduler\n    volumes:\n      - ./docker/celeryconfig.py:/usr/local/src/security_monkey/security_monkey/celeryconfig.py\n      #- /path/to/creds.file:/usr/local/src/security_monkey/data/creds.file\n    env_file: secmonkey.env\n    environment:\n      - SECURITY_MONKEY_REDIS_HOST=redis\n    entrypoint: [\"/usr/local/src/security_monkey/docker/worker-start.sh\"]\n\n  nginx:\n    container_name: secmonkey-nginx\n    build:\n      context: .\n      dockerfile: ./docker/nginx/Dockerfile\n    image: secmonkey-nginx:latest\n    working_dir: /etc/nginx\n    volumes:\n      - ./docker/nginx/server.crt:/etc/nginx/ssl/server.crt\n      - ./docker/nginx/server.key:/etc/nginx/ssl/server.key\n      - ./docker/nginx/conf.d:/etc/nginx/conf.d/\n      - ./docker/nginx/start-nginx.sh:/usr/local/src/security_monkey/docker/nginx/start-nginx.sh\n    depends_on:\n      - api\n    ports:\n      - 8000:80\n      - 8443:443\n    links:\n      - api:smapi\n"
        },
        {
          "name": "docker",
          "type": "tree",
          "content": null
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "env-config",
          "type": "tree",
          "content": null
        },
        {
          "name": "env_tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "manage.py",
          "type": "blob",
          "size": 32.2763671875,
          "content": "#     Copyright 2014 Netflix, Inc.\n#\n#     Licensed under the Apache License, Version 2.0 (the \"License\");\n#     you may not use this file except in compliance with the License.\n#     You may obtain a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#     Unless required by applicable law or agreed to in writing, software\n#     distributed under the License is distributed on an \"AS IS\" BASIS,\n#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#     See the License for the specific language governing permissions and\n#     limitations under the License.\nfrom datetime import datetime\nimport json\nimport sys\n\nfrom flask_script import Manager, Command, Option, prompt_pass\n\nfrom six import text_type\n\nfrom security_monkey.account_manager import bulk_disable_accounts, bulk_enable_accounts\nfrom security_monkey.common.s3_canonical import get_canonical_ids\nfrom security_monkey.datastore import clear_old_exceptions, store_exception, AccountType, ItemAudit, NetworkWhitelistEntry\n\nfrom security_monkey import app, db, jirasync\nfrom security_monkey.common.route53 import Route53Service\n\nfrom flask_migrate import Migrate, MigrateCommand\n\nfrom security_monkey.task_scheduler.tasks import manual_run_change_reporter, manual_run_change_finder\nfrom security_monkey.task_scheduler.tasks import audit_changes as sm_audit_changes\nfrom security_monkey.backup import backup_config_to_json as sm_backup_config_to_json\nfrom security_monkey.common.utils import find_modules, load_plugins\nfrom security_monkey.datastore import Account\nfrom security_monkey.watcher import watcher_registry\n\nfrom swag_client.backend import SWAGManager\nfrom swag_client.util import parse_swag_config_options\n\ntry:\n    from gunicorn.app.base import Application\n\n    GUNICORN = True\nexcept ImportError:\n    # Gunicorn does not yet support Windows.\n    # See issue #524. https://github.com/benoitc/gunicorn/issues/524\n    # For dev on Windows, make this an optional import.\n    print('Could not import gunicorn, skipping.')\n    GUNICORN = False\n\nmanager = Manager(app)\nmigrate = Migrate(app, db)\nmanager.add_command('db', MigrateCommand)\n\nfind_modules('alerters')\nfind_modules('watchers')\nfind_modules('auditors')\nload_plugins('security_monkey.plugins')\n\n\n@manager.command\ndef drop_db():\n    \"\"\" Drops the database. \"\"\"\n    db.drop_all()\n\n\n@manager.option('-a', '--accounts', dest='accounts', type=text_type, default=u'all')\ndef run_change_reporter(accounts):\n    \"\"\" Runs Reporter \"\"\"\n    try:\n        account_names = _parse_accounts(accounts)\n    except KeyError as e:\n        app.logger.error(\"The passed in account: {} does not exist in Security Monkey's database.\".format(e.message))\n        return -1\n\n    manual_run_change_reporter(account_names)\n\n\n@manager.option('-a', '--accounts', dest='accounts', type=text_type, default=u'all')\n@manager.option('-m', '--monitors', dest='monitors', type=text_type, default=u'all')\ndef find_changes(accounts, monitors):\n    \"\"\" Runs watchers \"\"\"\n    monitor_names = _parse_tech_names(monitors)\n    try:\n        account_names = _parse_accounts(accounts)\n    except KeyError as e:\n        app.logger.error(\"The passed in account: {} does not exist in Security Monkey's database.\".format(e.message))\n        return -1\n\n    manual_run_change_finder(account_names, monitor_names)\n\n\n@manager.option('-a', '--accounts', dest='accounts', type=text_type, default=u'all')\n@manager.option('-m', '--monitors', dest='monitors', type=text_type, default=u'all')\n@manager.option('-r', '--send_report', dest='send_report', type=bool, default=False)\n@manager.option('-s', '--skip_batch', dest='skip_batch', type=bool, default=False)\ndef audit_changes(accounts, monitors, send_report, skip_batch):\n    \"\"\" Runs auditors \"\"\"\n    monitor_names = _parse_tech_names(monitors)\n    try:\n        account_names = _parse_accounts(accounts)\n    except KeyError as e:\n        app.logger.error(\"The passed in account: {} does not exist in Security Monkey's database.\".format(e.message))\n        return -1\n\n    sm_audit_changes(account_names, monitor_names, send_report, skip_batch=skip_batch)\n\n\n@manager.option('-a', '--accounts', dest='accounts', type=text_type, default=u'all')\n@manager.option('-m', '--monitors', dest='monitors', type=text_type, default=u'all')\ndef delete_unjustified_issues(accounts, monitors):\n    \"\"\" Allows us to delete unjustified issues. \"\"\"\n    monitor_names = _parse_tech_names(monitors)\n    try:\n        _parse_accounts(accounts)\n    except KeyError as e:\n        app.logger.error(\"The passed in account: {} does not exist in Security Monkey's database.\".format(e.message))\n        return -1\n\n    issues = ItemAudit.query.filter_by(justified=False).all()\n    for issue in issues:\n        del issue.sub_items[:]\n        db.session.delete(issue)\n    db.session.commit()\n\n\n@manager.option('-o', '--output-file', dest='output_file', type=text_type, default='environment_summary.json')\ndef export_environment_summary(output_file):\n    \"\"\" Save the Auditor.OBJECT_STORE as a JSON file. \"\"\"\n    from security_monkey.auditor import Auditor\n    from collections import defaultdict\n\n    # Build the Environment Summary\n    Auditor._load_object_store()\n\n    # Convert sets to lists so we can serialize with JSON\n    json_safe_object = defaultdict(dict)\n    for tech_name, tech_body in Auditor.OBJECT_STORE.items():\n        for item_name, item_accounts in tech_body.items():\n            json_safe_object[tech_name][item_name] = list(item_accounts)\n\n    # Write the file to disk\n    with open(output_file, 'w') as of:\n        json.dump(json_safe_object, of, indent=2, sort_keys=True)\n\n\n@manager.option('-a', '--accounts', dest='accounts', type=text_type, default=u'all')\n@manager.option('-m', '--monitors', dest='monitors', type=text_type, default=u'all')\n@manager.option('-o', '--outputfolder', dest='outputfolder', type=text_type, default=u'backups')\ndef backup_config_to_json(accounts, monitors, outputfolder):\n    \"\"\" Saves the most current item revisions to a json file. \"\"\"\n    monitor_names = _parse_tech_names(monitors)\n    try:\n        account_names = _parse_accounts(accounts)\n    except KeyError as e:\n        app.logger.error(\"The passed in account: {} does not exist in Security Monkey's database.\".format(e.message))\n        return -1\n\n    sm_backup_config_to_json(account_names, monitor_names, outputfolder)\n\n\n@manager.command\ndef sync_jira():\n    \"\"\" Syncs issues with Jira \"\"\"\n    if jirasync:\n        app.logger.info('Syncing issues with Jira')\n        jirasync.sync_issues()\n    else:\n        app.logger.info('Jira sync not configured. Is SECURITY_MONKEY_JIRA_SYNC set?')\n\n\n@manager.command\ndef clear_expired_exceptions():\n    \"\"\"\n    Clears out the exception logs table of all exception entries that have expired past the TTL.\n    :return:\n    \"\"\"\n    app.logger.info(\"Clearing out exceptions that have an expired TTL...\")\n    clear_old_exceptions()\n    app.logger.info(\"Completed clearing out exceptions that have an expired TTL.\")\n\n\n@manager.command\ndef amazon_accounts():\n    \"\"\" Pre-populates standard AWS owned accounts \"\"\"\n    import json\n    from security_monkey.datastore import Account, AccountType\n\n    data = json.load(open(\"data/aws_accounts.json\", 'r'))\n\n    app.logger.info('Adding / updating Amazon owned accounts')\n    try:\n        account_type_result = AccountType.query.filter(AccountType.name == 'AWS').first()\n        if not account_type_result:\n            account_type_result = AccountType(name='AWS')\n            db.session.add(account_type_result)\n            db.session.commit()\n            db.session.refresh(account_type_result)\n\n        for group, info in data.items():\n            for aws_account in info['accounts']:\n                acct_name = \"{group} ({region})\".format(group=group, region=aws_account['region'])\n                account = Account.query.filter(Account.identifier == aws_account['account_id']).first()\n                if not account:\n                    app.logger.debug('    Adding account {0}'.format(acct_name))\n                    account = Account()\n                else:\n                    app.logger.debug('    Updating account {0}'.format(acct_name))\n\n                account.identifier = aws_account['account_id']\n                account.account_type_id = account_type_result.id\n                account.active = False\n                account.third_party = True\n                account.name = acct_name\n                account.notes = info['url']\n\n                db.session.add(account)\n\n        db.session.commit()\n        app.logger.info('Finished adding Amazon owned accounts')\n    except Exception as e:\n        app.logger.exception(\"An error occured while adding accounts\")\n        store_exception(\"manager-amazon-accounts\", None, e)\n\n\n@manager.command\n@manager.option('-e', '--email', dest='email', type=text_type, required=True)\n@manager.option('-r', '--role', dest='role', type=str, required=True)\ndef create_user(email, role):\n    from flask_security import SQLAlchemyUserDatastore\n    from security_monkey.datastore import User\n    from security_monkey.datastore import Role\n    from flask_security.utils import encrypt_password\n\n    user_datastore = SQLAlchemyUserDatastore(db, User, Role)\n\n    ROLES = ['View', 'Comment', 'Justify', 'Admin']\n    if role not in ROLES:\n        sys.stderr.write('[!] Role must be one of [{0}].\\n'.format(' '.join(ROLES)))\n        sys.exit(1)\n\n    users = User.query.filter(User.email == email)\n\n    if users.count() == 0:\n        password1 = prompt_pass(\"Password\")\n        password2 = prompt_pass(\"Confirm Password\")\n\n        if password1 != password2:\n            sys.stderr.write(\"[!] Passwords do not match\\n\")\n            sys.exit(1)\n\n        user = user_datastore.create_user(email=email,\n                                          password=encrypt_password(password1),\n                                          confirmed_at=datetime.now())\n    else:\n        sys.stdout.write(\"[+] Updating existing user\\n\")\n        user = users.first()\n\n        password1 = prompt_pass(\"Password\")\n        password2 = prompt_pass(\"Confirm Password\")\n\n        if password1 != password2:\n            sys.stderr.write(\"[!] Passwords do not match\\n\")\n            sys.exit(1)\n\n        user.password = encrypt_password(password1)\n\n    user.role = role\n\n    db.session.add(user)\n    db.session.commit()\n\n\n@manager.option('-e', '--email', dest='email', type=text_type, required=True)\n@manager.option('-a', '--active', dest='active', type=bool, required=False, default=False, help='To disable, you must omit this flag.')\ndef toggle_active_user(email, active):\n    \"\"\"Enables/Disables a user.\n\n    To enable a user, provide the \"--active True\" flag value. To disable it, omit the --active flag. Do not use \"--active False\",\n    or it will set the value to True.\n    \"\"\"\n    from security_monkey.datastore import User\n\n    users = User.query.filter(User.email == email)\n\n    if users.count() == 0:\n        sys.stderr.write(\"[!] User is not found.\\n\")\n        sys.exit(1)\n\n    else:\n        sys.stdout.write(\"[+] Setting active toggle for user {} to {}\\n\".format(email, active))\n        user = users.first()\n\n        user.active = active\n\n        db.session.add(user)\n        db.session.commit()\n\n        sys.stdout.write(\"[+] Done!\\n\")\n\n\n# Commented out because this will cause issues with linked issues and justifications.\n# @manager.command\n# @manager.option('-e', '--email', dest='email', type=text_type, required=True)\n# def delete_user(email):\n#     from security_monkey.datastore import User\n#\n#     users = User.query.filter(User.email == email)\n#\n#     if users.count() == 0:\n#         sys.stderr.write(\"[!] User is not found.\\n\")\n#         sys.exit(1)\n#\n#     else:\n#         sys.stdout.write(\"[-] Deleting user {}\\n\".format(email))\n#         user = users.first()\n#\n#         db.session.delete(user)\n#         db.session.commit()\n#\n#         sys.stdout.write(\"[+] Done!\\n\")\n\n\n@manager.option('-a', '--accounts', dest='accounts', type=text_type, default=u'all')\ndef disable_accounts(accounts):\n    \"\"\" Bulk disables one or more accounts \"\"\"\n    try:\n        account_names = _parse_accounts(accounts)\n    except KeyError as e:\n        app.logger.error(\"The passed in account: {} does not exist in Security Monkey's database.\".format(e.message))\n        return -1\n\n    bulk_disable_accounts(account_names)\n\n\n@manager.option('-a', '--accounts', dest='accounts', type=text_type, default=u'all')\ndef enable_accounts(accounts):\n    \"\"\" Bulk enables one or more accounts \"\"\"\n    try:\n        account_names = _parse_accounts(accounts)\n    except KeyError as e:\n        app.logger.error(\"The passed in account: {} does not exist in Security Monkey's database.\".format(e.message))\n        return -1\n\n    bulk_enable_accounts(account_names)\n\n\n@manager.option('-t', '--tech_name', dest='tech_name', type=str, required=True)\n@manager.option('-m', '--method', dest='method', type=str, required=True)\n@manager.option('-a', '--auditor', dest='auditor', type=str, required=True)\n@manager.option('-s', '--score', dest='score', type=int, required=False)\n@manager.option('-b', '--disabled', dest='disabled', type=bool, default=False)\n@manager.option('-p', '--pattern_scores', dest='pattern_scores', type=str, required=False)\ndef add_override_score(tech_name, method, auditor, score, disabled, pattern_scores):\n    \"\"\"\n    Adds an audit disable/override scores\n    :param tech_name: technology index\n    :param method: the neme of the auditor method to override\n    :param auditor: The class name of the auditor containing the check method\n    :param score: The default override score to assign to the check method issue\n    :param disabled: Flag indicating whether the check method should be run\n    :param pattern_scores: A comma separated list of account field values and scores.\n           This can be used to override the default score based on some field in the account\n           that the check method is running against. The format of each value/score is:\n           account_type.account_field.account_value=score\n    \"\"\"\n    from security_monkey.datastore import ItemAuditScore\n    from security_monkey.auditor import auditor_registry\n\n    if tech_name not in auditor_registry:\n        sys.stderr.write('Invalid tech name {}.\\n'.format(tech_name))\n        sys.exit(1)\n\n    valid = False\n    auditor_classes = auditor_registry[tech_name]\n    for auditor_class in auditor_classes:\n        if auditor_class.__name__ == auditor:\n            valid = True\n            break\n    if not valid:\n        sys.stderr.write('Invalid auditor {}.\\n'.format(auditor))\n        sys.exit(1)\n\n    if not getattr(auditor_class, method, None):\n        sys.stderr.write('Invalid method {}.\\n'.format(method))\n        sys.exit(1)\n\n    if score is None and not disabled:\n        sys.stderr.write('Either score (-s) or disabled (-b) required')\n        sys.exit(1)\n\n    if score is None:\n        score = 0\n\n    query = ItemAuditScore.query.filter(ItemAuditScore.technology == tech_name)\n    method_str = \"{method} ({auditor})\".format(method=method, auditor=auditor)\n    query = query.filter(ItemAuditScore.method == method_str)\n    entry = query.first()\n\n    if not entry:\n        entry = ItemAuditScore()\n        entry.technology = tech_name\n        entry.method = method_str\n\n    entry.score = score\n    entry.disabled = disabled\n\n    if pattern_scores is not None:\n        scores = pattern_scores.split(',')\n        for score in scores:\n            left_right = score.split('=')\n            if len(left_right) != 2:\n                sys.stderr.write('pattern_scores (-p) format account_type.account_field.account_value=score\\n')\n                sys.exit(1)\n\n            account_info = left_right[0].split('.')\n            if len(account_info) != 3:\n                sys.stderr.write('pattern_scores (-p) format account_type.account_field.account_value=score\\n')\n                sys.exit(1)\n\n            from security_monkey.account_manager import account_registry\n            if account_info[0] not in account_registry:\n                sys.stderr.write('Invalid account type {}\\n'.format(account_info[0]))\n                sys.exit(1)\n\n            entry.add_or_update_pattern_score(account_info[0], account_info[1], account_info[2], int(left_right[1]))\n\n    db.session.add(entry)\n    db.session.commit()\n    db.session.close()\n\n\n@manager.option('-f', '--file_name', dest='file_name', type=str, required=True)\n@manager.option('-m', '--mappings', dest='field_mappings', type=str, required=False)\ndef add_override_scores(file_name, field_mappings):\n    \"\"\"\n    Refreshes the audit disable/override scores from a csv file. Old scores not in\n     the csv will be removed.\n    :param file_name: path to the csv file\n    :param field_mappings: Comma separated list of mappings of known types to csv file\n     headers. Ex. 'tech=Tech Name,score=default score'\n    \"\"\"\n    from security_monkey.datastore import ItemAuditScore, AccountPatternAuditScore\n    from security_monkey.auditor import auditor_registry\n    import csv\n\n    csvfile = open(file_name, 'r')\n    reader = csv.DictReader(csvfile)\n    errors = []\n\n    mappings = {\n        'tech': 'tech',\n        'auditor': 'auditor',\n        'method': 'method',\n        'disabled': 'disabled',\n        'score': 'score',\n        'patterns': {}\n    }\n\n    if field_mappings:\n        mapping_defs = field_mappings.split(',')\n        for mapping_def in mapping_defs:\n            mapping = mapping_def.split('=')\n            if mapping[0] in mappings:\n                mappings[mapping[0]] = mapping[1]\n            else:\n                patterns = mappings['patterns']\n                patterns[mapping[0]] = mapping[1]\n\n    line_num = 0\n    entries = []\n    for row in reader:\n        line_num = line_num + 1\n        tech_name = row[mappings['tech']]\n        auditor = row[mappings['auditor']]\n        method = row[mappings['method']]\n\n        if not tech_name or not auditor or not method:\n            continue\n\n        score = None\n        str_score = row[mappings['score']].decode('ascii', 'ignore').strip('')\n        if str_score != '':\n            if not str_score.isdigit():\n                errors.append('Score {} line {} is not a positive int.'.format(str_score, line_num))\n                continue\n            score = int(str_score)\n\n        if row[mappings['disabled']].lower() == 'true':\n            disabled = True\n        else:\n            disabled = False\n\n        if score is None and not disabled:\n            continue\n\n        if score is None:\n            score = 0\n\n        if tech_name not in auditor_registry:\n            errors.append('Invalid tech name {} line {}.'.format(tech_name, line_num))\n            continue\n\n        valid = False\n        auditor_classes = auditor_registry[tech_name]\n        for auditor_class in auditor_classes:\n            if auditor_class.__name__ == auditor:\n                valid = True\n                break\n\n        if not valid:\n            errors.append('Invalid auditor {} line {}.'.format(auditor, line_num))\n            continue\n\n        if not getattr(auditor_class, method, None):\n            errors.append('Invalid method {} line {}.'.format(method, line_num))\n            continue\n\n        entry = ItemAuditScore(technology=tech_name, method=method + ' (' + auditor + ')',\n                               score=score, disabled=disabled)\n\n        pattern_mappings = mappings['patterns']\n        for mapping in pattern_mappings:\n            str_pattern_score = row[pattern_mappings[mapping]].decode('ascii', 'ignore').strip()\n            if str_pattern_score != '':\n                if not str_pattern_score.isdigit():\n                    errors.append('Pattern score {} line {} is not a positive int.'.format(str_pattern_score, line_num))\n                    continue\n\n                account_info = mapping.split('.')\n                if len(account_info) != 3:\n                    errors.append('Invalid pattern mapping {}.'.format(mapping))\n                    continue\n\n                from security_monkey.account_manager import account_registry\n                if account_info[0] not in account_registry:\n                    errors.append('Invalid account type {}'.format(account_info[0]))\n                    continue\n\n                db_pattern_score = AccountPatternAuditScore(account_type=account_info[0],\n                                                            account_field=account_info[1],\n                                                            account_pattern=account_info[2],\n                                                            score=int(str_pattern_score))\n\n                entry.account_pattern_scores.append(db_pattern_score)\n\n        entries.append(entry)\n\n    if len(errors) > 0:\n        for error in errors:\n            sys.stderr.write(\"{}\\n\".format(error))\n        sys.exit(1)\n\n    AccountPatternAuditScore.query.delete()\n    ItemAuditScore.query.delete()\n\n    for entry in entries:\n        db.session.add(entry)\n\n    db.session.commit()\n    db.session.close()\n\n\ndef _parse_tech_names(tech_str):\n    if tech_str == 'all':\n        return watcher_registry.keys()\n    else:\n        return tech_str.split(',')\n\n\ndef _parse_accounts(account_str, active=True):\n    \"\"\"Parse the account ID or name. This will raise a KeyError if it can't find it.\"\"\"\n    if account_str == 'all':\n        accounts = Account.query.filter(Account.third_party == False).filter(Account.active == active).all()\n        accounts = [account.name for account in accounts]\n        return accounts\n    else:\n        names_or_ids = account_str.split(',')\n        accounts = Account.query.all()\n        accounts_by_id = {account.identifier: account.name for account in accounts}\n        accounts_by_name = {account.name: account.identifier for account in accounts}\n\n        # Verify that the account name exists (raise a KeyError if it doesn't):\n        names = []\n        for n in names_or_ids:\n            if not accounts_by_id.get(n):\n                _ = accounts_by_name[n]\n\n            names.append(n)\n\n        return names\n\n\n@manager.option('-n', '--name', dest='name', type=text_type, required=True)\ndef delete_account(name):\n    from security_monkey.account_manager import delete_account_by_name\n    delete_account_by_name(name)\n\n\n@manager.option('-t', '--tech_name', dest='tech_name', type=str, required=True)\n@manager.option('-d', '--disabled', dest='disabled', type=bool, default=False)\n# We are locking down the allowed intervals here to 15 minutes, 1 hour, 12 hours, 24\n# hours or one week because too many different intervals could result in too many\n# scheduler threads, impacting performance.\n@manager.option('-i', '--interval', dest='interval', type=int, default=60, choices=[15, 60, 720, 1440, 10080])\ndef add_watcher_config(tech_name, disabled, interval):\n    from security_monkey.datastore import WatcherConfig\n    from security_monkey.watcher import watcher_registry\n\n    if tech_name not in watcher_registry:\n        sys.stderr.write('Invalid tech name {}.\\n'.format(tech_name))\n        sys.exit(1)\n\n    query = WatcherConfig.query.filter(WatcherConfig.index == tech_name)\n    entry = query.first()\n\n    if not entry:\n        entry = WatcherConfig()\n\n    entry.index = tech_name\n    entry.interval = interval\n    entry.active = not disabled\n\n    db.session.add(entry)\n    db.session.commit()\n    db.session.close()\n\n\n@manager.option(\"--override\", dest=\"override\", type=bool, default=True)\ndef fetch_aws_canonical_ids(override):\n    \"\"\"\n    Adds S3 canonical IDs in for all AWS accounts in SM.\n    \"\"\"\n    app.logger.info(\"[ ] Fetching S3 canonical IDs for all AWS accounts being monitored by Security Monkey.\")\n\n    # Get all the active AWS accounts:\n    accounts = Account.query.filter(Account.active == True) \\\n        .join(AccountType).filter(AccountType.name == \"AWS\").all()  # noqa\n\n    get_canonical_ids(accounts, override=override)\n\n    app.logger.info(\"[@] Completed canonical ID fetching.\")\n\n\n@manager.command\ndef clean_stale_issues():\n    \"\"\"\n    Cleans up issues for auditors that have been removed\n    \"\"\"\n    from security_monkey.common.audit_issue_cleanup import clean_stale_issues\n    clean_stale_issues()\n\n\nclass APIServer(Command):\n    def __init__(self, host='127.0.0.1', port=app.config.get('API_PORT'), workers=12):\n        self.address = \"{}:{}\".format(host, port)\n        self.workers = workers\n\n    def get_options(self):\n        return (\n            Option('-b', '--bind',\n                   dest='address',\n                   type=str,\n                   default=self.address),\n            Option('-w', '--workers',\n                   dest='workers',\n                   type=int,\n                   default=self.workers),\n        )\n\n    def __call__(self, app, *args, **kwargs):\n\n        if app.config.get('USE_ROUTE53'):\n            route53 = Route53Service()\n            route53.register(app.config.get('FQDN'), exclusive=True)\n\n        workers = kwargs['workers']\n        address = kwargs['address']\n\n        if not GUNICORN:\n            print('GUNICORN not installed. Try `runserver` to use the Flask debug server instead.')\n        else:\n            class FlaskApplication(Application):\n                def init(self, parser, opts, args):\n                    return {\n                        'bind': address,\n                        'workers': workers,\n                        'timeout': 1800\n                    }\n\n                def load(self):\n                    return app\n\n            FlaskApplication().run()\n\n\n@manager.option('-o', '--owner', type=text_type, required=True,\n                help=\"Owner of the accounts, this is often set to a company name.\")\n@manager.option('-b', '--bucket-name', dest='bucket_name', type=text_type, required=True,\n                help=\"S3 bucket where SWAG data is stored.\")\n@manager.option('-p', '--bucket-prefix', dest='bucket_prefix', type=text_type, default='accounts.json',\n                help=\"Prefix to fetch account data from. Default: accounts.json\")\n@manager.option('-r', '--bucket-region', dest='bucket_region', type=text_type, default='us-east-1',\n                help=\"Region SWAG S3 bucket is located. Default: us-east-1\")\n@manager.option('-t', '--account-type', dest='account_type', default='AWS',\n                help=\"Type of account to sync from SWAG data. Default: AWS\")\n@manager.option('-s', '--spinnaker', dest='spinnaker', default=False, action='store_true',\n                help='Use the spinnaker names as account names.')\ndef sync_swag(owner, bucket_name, bucket_prefix, bucket_region, account_type, spinnaker):\n    \"\"\"Use the SWAG client to sync SWAG accounts to Security Monkey.\"\"\"\n    from security_monkey.account_manager import account_registry\n\n    swag_opts = {\n        'swag.type': 's3',\n        'swag.bucket_name': bucket_name,\n        'swag.data_file': bucket_prefix,\n        'swag.region': bucket_region\n    }\n\n    swag = SWAGManager(**parse_swag_config_options(swag_opts))\n    account_manager = account_registry[account_type]()\n\n    for account in swag.get_all(\"[?provider=='{provider}']\".format(provider=account_type.lower())):\n        services = account.get('services', [])\n        services_by_name = {s['name']: s for s in services}\n\n        # Check if the account is active or not:\n        # With the current SWAG schema, need to do the following:\n        # 1. Check if the 'account_status' field is set to 'ready'.\n        # 2. Loop through all the services for \"security_monkey\" and if the status is \"active\", then the account\n        #    is active.\n        check_active = active = False\n        if account['account_status'] == 'ready':\n            check_active = True\n\n        if check_active:\n            secmonkey_service = services_by_name.get('security_monkey', {})\n            for status in secmonkey_service.get('status', []):\n                if status['region'] == 'all':\n                    active = status.get('enabled', False)\n                    break\n\n        thirdparty = account['owner'] != owner\n        if spinnaker:\n            spinnaker_name = swag.get_service_name('spinnaker', \"[?id=='{id}']\".format(id=account['id']))\n            if not spinnaker_name:\n                name = account['name']\n            else:\n                name = spinnaker_name\n        else:\n            name = account['name']\n\n        notes = account['description']\n        identifier = account['id']\n\n        custom_fields = {}\n        s3_name = swag.get_service_name('s3', \"[?id=='{id}']\".format(id=account['id']))\n        if s3_name:\n            custom_fields['s3_name'] = s3_name\n\n        s3_service = services_by_name.get('s3', {})\n        if s3_service:\n            c_id = s3_service['metadata'].get('canonicalId', None)\n            if c_id:\n                custom_fields['canonical_id'] = c_id\n        role_name = secmonkey_service.get('metadata', {}).get('role_name', None)\n        if role_name is not None:\n            custom_fields['role_name'] = role_name\n\n        account_manager.sync(account_manager.account_type, name, active, thirdparty,\n                             notes, identifier,\n                             custom_fields=custom_fields)\n    db.session.close()\n    app.logger.info('SWAG sync successful.')\n\n\n@manager.option('-b', '--bucket-name', dest='bucket_name', type=text_type, help=\"S3 bucket where network whitelist data is stored.\")\n@manager.option('-i', '--input-filename', dest='input_filename', type=text_type, default='networks.json', help=\"File path or bucket prefix to fetch account data from. Default: networks.json\")\n@manager.option('-a', '--authoritative', dest='authoritative', default=False, action='store_true', help='Remove all networks not named in `input_filename`.')\ndef sync_networks(bucket_name, input_filename, authoritative):\n    \"\"\"Imports a JSON file of networks to the Security Monkey whitelist.\"\"\"\n    if bucket_name:\n        import boto3\n        s3 = boto3.client('s3')\n        response = s3.get_object(\n            Bucket=bucket_name,\n            Key=input_filename,\n        )\n        handle = response['Body']\n    else:\n        handle = open(input_filename)\n    networks = json.load(handle)\n    handle.close()\n    existing = NetworkWhitelistEntry.query.filter(\n        NetworkWhitelistEntry.name.in_(networks)\n    )\n    new = set(networks.keys()) - set(entry.name for entry in existing)\n    for entry in existing:\n        entry.cidr = networks[entry.name]\n        db.session.add(entry)\n    for name in new:\n        app.logger.debug('Adding new network %s', name)\n        entry = NetworkWhitelistEntry(\n            name=name,\n            cidr=networks[name],\n        )\n        db.session.add(entry)\n    if authoritative:\n        old = NetworkWhitelistEntry.query.filter(\n            ~NetworkWhitelistEntry.name.in_(networks)\n        )\n        for entry in old:\n            app.logger.debug('Removing stale network %s', entry.name)\n            db.session.delete(entry)\n    db.session.commit()\n    db.session.close()\n\n\nclass AddAccount(Command):\n    def __init__(self, account_manager, *args, **kwargs):\n        super(AddAccount, self).__init__(*args, **kwargs)\n        self._account_manager = account_manager\n        self.__doc__ = \"Add %s account\" % account_manager.account_type\n\n    def get_options(self):\n        options = [\n            Option('-n', '--name', type=text_type, required=True),\n            Option('--id', dest='identifier', type=text_type, required=True),\n            Option('--thirdparty', action='store_true'),\n            Option('--active', action='store_true'),\n            Option('--notes', type=text_type),\n            Option('--update-existing', action=\"store_true\")\n        ]\n        for cf in self._account_manager.custom_field_configs:\n            options.append(Option('--%s' % cf.name, dest=cf.name, type=str))\n        return options\n\n    def __call__(self, app, *args, **kwargs):\n        name = kwargs.pop('name')\n        active = kwargs.pop('active', False)\n        thirdparty = kwargs.pop('thirdparty', False)\n        notes = kwargs.pop('notes', u'')\n        identifier = kwargs.pop('identifier')\n        update = kwargs.pop('update_existing', False)\n        if update:\n            result = self._account_manager.update(None, self._account_manager.account_type, name, active, thirdparty,\n                                                  notes, identifier,\n                                                  custom_fields=kwargs\n                                                  )\n        else:\n            result = self._account_manager.create(\n                self._account_manager.account_type,\n                name, active, thirdparty, notes, identifier,\n                custom_fields=kwargs)\n        db.session.close()\n\n        if not result:\n            return -1\n\n\ndef main():\n    from security_monkey.account_manager import account_registry\n\n    for name, account_manager in account_registry.items():\n        manager.add_command(\"add_account_%s\" % name.lower(), AddAccount(account_manager()))\n    manager.add_command(\"run_api_server\", APIServer())\n    manager.run()\n\n\nif __name__ == \"__main__\":\n    main()\n"
        },
        {
          "name": "manage_api.py",
          "type": "blob",
          "size": 32.2890625,
          "content": "#     Copyright 2014 Netflix, Inc.\n#\n#     Licensed under the Apache License, Version 2.0 (the \"License\");\n#     you may not use this file except in compliance with the License.\n#     You may obtain a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#     Unless required by applicable law or agreed to in writing, software\n#     distributed under the License is distributed on an \"AS IS\" BASIS,\n#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#     See the License for the specific language governing permissions and\n#     limitations under the License.\nfrom datetime import datetime\nimport json\nimport sys\n\nfrom flask_script import Manager, Command, Option, prompt_pass\n\nfrom six import text_type\n\nfrom security_monkey.account_manager import bulk_disable_accounts, bulk_enable_accounts\nfrom security_monkey.common.s3_canonical import get_canonical_ids\nfrom security_monkey.datastore import clear_old_exceptions, store_exception, AccountType, ItemAudit, NetworkWhitelistEntry\n\nfrom security_monkey import app, db, jirasync\nfrom security_monkey.common.route53 import Route53Service\n\nfrom flask_migrate import Migrate, MigrateCommand\n\nfrom security_monkey.task_scheduler.tasks import manual_run_change_reporter, manual_run_change_finder\nfrom security_monkey.task_scheduler.tasks import audit_changes as sm_audit_changes\nfrom security_monkey.backup import backup_config_to_json as sm_backup_config_to_json\nfrom security_monkey.common.utils import find_modules, load_plugins\nfrom security_monkey.datastore import Account\nfrom security_monkey.watcher import watcher_registry\n\nfrom swag_client.backend import SWAGManager\nfrom swag_client.util import parse_swag_config_options\n\ntry:\n    from gunicorn.app.base import Application\n\n    GUNICORN = True\nexcept ImportError:\n    # Gunicorn does not yet support Windows.\n    # See issue #524. https://github.com/benoitc/gunicorn/issues/524\n    # For dev on Windows, make this an optional import.\n    print('Could not import gunicorn, skipping.')\n    GUNICORN = False\n\nmanager = Manager(app)\nmigrate = Migrate(app, db)\nmanager.add_command('db', MigrateCommand)\n\nfind_modules('alerters')\nfind_modules('watchers')\nfind_modules('auditors')\nload_plugins('security_monkey.plugins')\n\n\n@manager.command\ndef drop_db():\n    \"\"\" Drops the database. \"\"\"\n    db.drop_all()\n\n\n@manager.option('-a', '--accounts', dest='accounts', type=text_type, default='all')\ndef run_change_reporter(accounts):\n    \"\"\" Runs Reporter \"\"\"\n    try:\n        account_names = _parse_accounts(accounts)\n    except KeyError as e:\n        app.logger.error(\"The passed in account: {} does not exist in Security Monkey's database.\".format(e.message))\n        return -1\n\n    manual_run_change_reporter(account_names)\n\n\n@manager.option('-a', '--accounts', dest='accounts', type=text_type, default='all')\n@manager.option('-m', '--monitors', dest='monitors', type=text_type, default='all')\ndef find_changes(accounts, monitors):\n    \"\"\" Runs watchers \"\"\"\n    monitor_names = _parse_tech_names(monitors)\n    try:\n        account_names = _parse_accounts(accounts)\n    except KeyError as e:\n        app.logger.error(\"The passed in account: {} does not exist in Security Monkey's database.\".format(e.message))\n        return -1\n\n    manual_run_change_finder(account_names, monitor_names)\n\n\n@manager.option('-a', '--accounts', dest='accounts', type=text_type, default='all')\n@manager.option('-m', '--monitors', dest='monitors', type=text_type, default='all')\n@manager.option('-r', '--send_report', dest='send_report', type=bool, default=False)\n@manager.option('-s', '--skip_batch', dest='skip_batch', type=bool, default=False)\ndef audit_changes(accounts, monitors, send_report, skip_batch):\n    \"\"\" Runs auditors \"\"\"\n    monitor_names = _parse_tech_names(monitors)\n    try:\n        account_names = _parse_accounts(accounts)\n    except KeyError as e:\n        app.logger.error(\"The passed in account: {} does not exist in Security Monkey's database.\".format(e.message))\n        return -1\n\n    sm_audit_changes(account_names, monitor_names, send_report, skip_batch=skip_batch)\n\n\n@manager.option('-a', '--accounts', dest='accounts', type=text_type, default='all')\n@manager.option('-m', '--monitors', dest='monitors', type=text_type, default='all')\ndef delete_unjustified_issues(accounts, monitors):\n    \"\"\" Allows us to delete unjustified issues. \"\"\"\n    monitor_names = _parse_tech_names(monitors)\n    try:\n        _parse_accounts(accounts)\n    except KeyError as e:\n        app.logger.error(\"The passed in account: {} does not exist in Security Monkey's database.\".format(e.message))\n        return -1\n\n    issues = ItemAudit.query.filter_by(justified=False).all()\n    for issue in issues:\n        del issue.sub_items[:]\n        db.session.delete(issue)\n    db.session.commit()\n\n\n@manager.option('-o', '--output-file', dest='output_file', type=text_type, default='environment_summary.json')\ndef export_environment_summary(output_file):\n    \"\"\" Save the Auditor.OBJECT_STORE as a JSON file. \"\"\"\n    from security_monkey.auditor import Auditor\n    from collections import defaultdict\n\n    # Build the Environment Summary\n    Auditor._load_object_store()\n\n    # Convert sets to lists so we can serialize with JSON\n    json_safe_object = defaultdict(dict)\n    for tech_name, tech_body in list(Auditor.OBJECT_STORE.items()):\n        for item_name, item_accounts in list(tech_body.items()):\n            json_safe_object[tech_name][item_name] = list(item_accounts)\n\n    # Write the file to disk\n    with open(output_file, 'w') as of:\n        json.dump(json_safe_object, of, indent=2, sort_keys=True)\n\n\n@manager.option('-a', '--accounts', dest='accounts', type=text_type, default='all')\n@manager.option('-m', '--monitors', dest='monitors', type=text_type, default='all')\n@manager.option('-o', '--outputfolder', dest='outputfolder', type=text_type, default='backups')\ndef backup_config_to_json(accounts, monitors, outputfolder):\n    \"\"\" Saves the most current item revisions to a json file. \"\"\"\n    monitor_names = _parse_tech_names(monitors)\n    try:\n        account_names = _parse_accounts(accounts)\n    except KeyError as e:\n        app.logger.error(\"The passed in account: {} does not exist in Security Monkey's database.\".format(e.message))\n        return -1\n\n    sm_backup_config_to_json(account_names, monitor_names, outputfolder)\n\n\n@manager.command\ndef sync_jira():\n    \"\"\" Syncs issues with Jira \"\"\"\n    if jirasync:\n        app.logger.info('Syncing issues with Jira')\n        jirasync.sync_issues()\n    else:\n        app.logger.info('Jira sync not configured. Is SECURITY_MONKEY_JIRA_SYNC set?')\n\n\n@manager.command\ndef clear_expired_exceptions():\n    \"\"\"\n    Clears out the exception logs table of all exception entries that have expired past the TTL.\n    :return:\n    \"\"\"\n    app.logger.info(\"Clearing out exceptions that have an expired TTL...\")\n    clear_old_exceptions()\n    app.logger.info(\"Completed clearing out exceptions that have an expired TTL.\")\n\n\n@manager.command\ndef amazon_accounts():\n    \"\"\" Pre-populates standard AWS owned accounts \"\"\"\n    import json\n    from security_monkey.datastore import Account, AccountType\n\n    data = json.load(open(\"data/aws_accounts.json\", 'r'))\n\n    app.logger.info('Adding / updating Amazon owned accounts')\n    try:\n        account_type_result = AccountType.query.filter(AccountType.name == 'AWS').first()\n        if not account_type_result:\n            account_type_result = AccountType(name='AWS')\n            db.session.add(account_type_result)\n            db.session.commit()\n            db.session.refresh(account_type_result)\n\n        for group, info in list(data.items()):\n            for aws_account in info['accounts']:\n                acct_name = \"{group} ({region})\".format(group=group, region=aws_account['region'])\n                account = Account.query.filter(Account.identifier == aws_account['account_id']).first()\n                if not account:\n                    app.logger.debug('    Adding account {0}'.format(acct_name))\n                    account = Account()\n                else:\n                    app.logger.debug('    Updating account {0}'.format(acct_name))\n\n                account.identifier = aws_account['account_id']\n                account.account_type_id = account_type_result.id\n                account.active = False\n                account.third_party = True\n                account.name = acct_name\n                account.notes = info['url']\n\n                db.session.add(account)\n\n        db.session.commit()\n        app.logger.info('Finished adding Amazon owned accounts')\n    except Exception as e:\n        app.logger.exception(\"An error occured while adding accounts\")\n        store_exception(\"manager-amazon-accounts\", None, e)\n\n\n@manager.command\n@manager.option('-e', '--email', dest='email', type=text_type, required=True)\n@manager.option('-r', '--role', dest='role', type=str, required=True)\ndef create_user(email, role):\n    from flask_security import SQLAlchemyUserDatastore\n    from security_monkey.datastore import User\n    from security_monkey.datastore import Role\n    from flask_security.utils import encrypt_password\n\n    user_datastore = SQLAlchemyUserDatastore(db, User, Role)\n\n    ROLES = ['View', 'Comment', 'Justify', 'Admin']\n    if role not in ROLES:\n        sys.stderr.write('[!] Role must be one of [{0}].\\n'.format(' '.join(ROLES)))\n        sys.exit(1)\n\n    users = User.query.filter(User.email == email)\n\n    if users.count() == 0:\n        password1 = prompt_pass(\"Password\")\n        password2 = prompt_pass(\"Confirm Password\")\n\n        if password1 != password2:\n            sys.stderr.write(\"[!] Passwords do not match\\n\")\n            sys.exit(1)\n\n        user = user_datastore.create_user(email=email,\n                                          password=encrypt_password(password1),\n                                          confirmed_at=datetime.now())\n    else:\n        sys.stdout.write(\"[+] Updating existing user\\n\")\n        user = users.first()\n\n        password1 = prompt_pass(\"Password\")\n        password2 = prompt_pass(\"Confirm Password\")\n\n        if password1 != password2:\n            sys.stderr.write(\"[!] Passwords do not match\\n\")\n            sys.exit(1)\n\n        user.password = encrypt_password(password1)\n\n    user.role = role\n\n    db.session.add(user)\n    db.session.commit()\n\n\n@manager.option('-e', '--email', dest='email', type=text_type, required=True)\n@manager.option('-a', '--active', dest='active', type=bool, required=False, default=False, help='To disable, you must omit this flag.')\ndef toggle_active_user(email, active):\n    \"\"\"Enables/Disables a user.\n\n    To enable a user, provide the \"--active True\" flag value. To disable it, omit the --active flag. Do not use \"--active False\",\n    or it will set the value to True.\n    \"\"\"\n    from security_monkey.datastore import User\n\n    users = User.query.filter(User.email == email)\n\n    if users.count() == 0:\n        sys.stderr.write(\"[!] User is not found.\\n\")\n        sys.exit(1)\n\n    else:\n        sys.stdout.write(\"[+] Setting active toggle for user {} to {}\\n\".format(email, active))\n        user = users.first()\n\n        user.active = active\n\n        db.session.add(user)\n        db.session.commit()\n\n        sys.stdout.write(\"[+] Done!\\n\")\n\n\n# Commented out because this will cause issues with linked issues and justifications.\n# @manager.command\n# @manager.option('-e', '--email', dest='email', type=text_type, required=True)\n# def delete_user(email):\n#     from security_monkey.datastore import User\n#\n#     users = User.query.filter(User.email == email)\n#\n#     if users.count() == 0:\n#         sys.stderr.write(\"[!] User is not found.\\n\")\n#         sys.exit(1)\n#\n#     else:\n#         sys.stdout.write(\"[-] Deleting user {}\\n\".format(email))\n#         user = users.first()\n#\n#         db.session.delete(user)\n#         db.session.commit()\n#\n#         sys.stdout.write(\"[+] Done!\\n\")\n\n\n@manager.option('-a', '--accounts', dest='accounts', type=text_type, default='all')\ndef disable_accounts(accounts):\n    \"\"\" Bulk disables one or more accounts \"\"\"\n    try:\n        account_names = _parse_accounts(accounts)\n    except KeyError as e:\n        app.logger.error(\"The passed in account: {} does not exist in Security Monkey's database.\".format(e.message))\n        return -1\n\n    bulk_disable_accounts(account_names)\n\n\n@manager.option('-a', '--accounts', dest='accounts', type=text_type, default='all')\ndef enable_accounts(accounts):\n    \"\"\" Bulk enables one or more accounts \"\"\"\n    try:\n        account_names = _parse_accounts(accounts)\n    except KeyError as e:\n        app.logger.error(\"The passed in account: {} does not exist in Security Monkey's database.\".format(e.message))\n        return -1\n\n    bulk_enable_accounts(account_names)\n\n\n@manager.option('-t', '--tech_name', dest='tech_name', type=str, required=True)\n@manager.option('-m', '--method', dest='method', type=str, required=True)\n@manager.option('-a', '--auditor', dest='auditor', type=str, required=True)\n@manager.option('-s', '--score', dest='score', type=int, required=False)\n@manager.option('-b', '--disabled', dest='disabled', type=bool, default=False)\n@manager.option('-p', '--pattern_scores', dest='pattern_scores', type=str, required=False)\ndef add_override_score(tech_name, method, auditor, score, disabled, pattern_scores):\n    \"\"\"\n    Adds an audit disable/override scores\n    :param tech_name: technology index\n    :param method: the neme of the auditor method to override\n    :param auditor: The class name of the auditor containing the check method\n    :param score: The default override score to assign to the check method issue\n    :param disabled: Flag indicating whether the check method should be run\n    :param pattern_scores: A comma separated list of account field values and scores.\n           This can be used to override the default score based on some field in the account\n           that the check method is running against. The format of each value/score is:\n           account_type.account_field.account_value=score\n    \"\"\"\n    from security_monkey.datastore import ItemAuditScore\n    from security_monkey.auditor import auditor_registry\n\n    if tech_name not in auditor_registry:\n        sys.stderr.write('Invalid tech name {}.\\n'.format(tech_name))\n        sys.exit(1)\n\n    valid = False\n    auditor_classes = auditor_registry[tech_name]\n    for auditor_class in auditor_classes:\n        if auditor_class.__name__ == auditor:\n            valid = True\n            break\n    if not valid:\n        sys.stderr.write('Invalid auditor {}.\\n'.format(auditor))\n        sys.exit(1)\n\n    if not getattr(auditor_class, method, None):\n        sys.stderr.write('Invalid method {}.\\n'.format(method))\n        sys.exit(1)\n\n    if score is None and not disabled:\n        sys.stderr.write('Either score (-s) or disabled (-b) required')\n        sys.exit(1)\n\n    if score is None:\n        score = 0\n\n    query = ItemAuditScore.query.filter(ItemAuditScore.technology == tech_name)\n    method_str = \"{method} ({auditor})\".format(method=method, auditor=auditor)\n    query = query.filter(ItemAuditScore.method == method_str)\n    entry = query.first()\n\n    if not entry:\n        entry = ItemAuditScore()\n        entry.technology = tech_name\n        entry.method = method_str\n\n    entry.score = score\n    entry.disabled = disabled\n\n    if pattern_scores is not None:\n        scores = pattern_scores.split(',')\n        for score in scores:\n            left_right = score.split('=')\n            if len(left_right) != 2:\n                sys.stderr.write('pattern_scores (-p) format account_type.account_field.account_value=score\\n')\n                sys.exit(1)\n\n            account_info = left_right[0].split('.')\n            if len(account_info) != 3:\n                sys.stderr.write('pattern_scores (-p) format account_type.account_field.account_value=score\\n')\n                sys.exit(1)\n\n            from security_monkey.account_manager import account_registry\n            if account_info[0] not in account_registry:\n                sys.stderr.write('Invalid account type {}\\n'.format(account_info[0]))\n                sys.exit(1)\n\n            entry.add_or_update_pattern_score(account_info[0], account_info[1], account_info[2], int(left_right[1]))\n\n    db.session.add(entry)\n    db.session.commit()\n    db.session.close()\n\n\n@manager.option('-f', '--file_name', dest='file_name', type=str, required=True)\n@manager.option('-m', '--mappings', dest='field_mappings', type=str, required=False)\ndef add_override_scores(file_name, field_mappings):\n    \"\"\"\n    Refreshes the audit disable/override scores from a csv file. Old scores not in\n     the csv will be removed.\n    :param file_name: path to the csv file\n    :param field_mappings: Comma separated list of mappings of known types to csv file\n     headers. Ex. 'tech=Tech Name,score=default score'\n    \"\"\"\n    from security_monkey.datastore import ItemAuditScore, AccountPatternAuditScore\n    from security_monkey.auditor import auditor_registry\n    import csv\n\n    csvfile = open(file_name, 'r')\n    reader = csv.DictReader(csvfile)\n    errors = []\n\n    mappings = {\n        'tech': 'tech',\n        'auditor': 'auditor',\n        'method': 'method',\n        'disabled': 'disabled',\n        'score': 'score',\n        'patterns': {}\n    }\n\n    if field_mappings:\n        mapping_defs = field_mappings.split(',')\n        for mapping_def in mapping_defs:\n            mapping = mapping_def.split('=')\n            if mapping[0] in mappings:\n                mappings[mapping[0]] = mapping[1]\n            else:\n                patterns = mappings['patterns']\n                patterns[mapping[0]] = mapping[1]\n\n    line_num = 0\n    entries = []\n    for row in reader:\n        line_num = line_num + 1\n        tech_name = row[mappings['tech']]\n        auditor = row[mappings['auditor']]\n        method = row[mappings['method']]\n\n        if not tech_name or not auditor or not method:\n            continue\n\n        score = None\n        str_score = row[mappings['score']].decode('ascii', 'ignore').strip('')\n        if str_score != '':\n            if not str_score.isdigit():\n                errors.append('Score {} line {} is not a positive int.'.format(str_score, line_num))\n                continue\n            score = int(str_score)\n\n        if row[mappings['disabled']].lower() == 'true':\n            disabled = True\n        else:\n            disabled = False\n\n        if score is None and not disabled:\n            continue\n\n        if score is None:\n            score = 0\n\n        if tech_name not in auditor_registry:\n            errors.append('Invalid tech name {} line {}.'.format(tech_name, line_num))\n            continue\n\n        valid = False\n        auditor_classes = auditor_registry[tech_name]\n        for auditor_class in auditor_classes:\n            if auditor_class.__name__ == auditor:\n                valid = True\n                break\n\n        if not valid:\n            errors.append('Invalid auditor {} line {}.'.format(auditor, line_num))\n            continue\n\n        if not getattr(auditor_class, method, None):\n            errors.append('Invalid method {} line {}.'.format(method, line_num))\n            continue\n\n        entry = ItemAuditScore(technology=tech_name, method=method + ' (' + auditor + ')',\n                               score=score, disabled=disabled)\n\n        pattern_mappings = mappings['patterns']\n        for mapping in pattern_mappings:\n            str_pattern_score = row[pattern_mappings[mapping]].decode('ascii', 'ignore').strip()\n            if str_pattern_score != '':\n                if not str_pattern_score.isdigit():\n                    errors.append('Pattern score {} line {} is not a positive int.'.format(str_pattern_score, line_num))\n                    continue\n\n                account_info = mapping.split('.')\n                if len(account_info) != 3:\n                    errors.append('Invalid pattern mapping {}.'.format(mapping))\n                    continue\n\n                from security_monkey.account_manager import account_registry\n                if account_info[0] not in account_registry:\n                    errors.append('Invalid account type {}'.format(account_info[0]))\n                    continue\n\n                db_pattern_score = AccountPatternAuditScore(account_type=account_info[0],\n                                                            account_field=account_info[1],\n                                                            account_pattern=account_info[2],\n                                                            score=int(str_pattern_score))\n\n                entry.account_pattern_scores.append(db_pattern_score)\n\n        entries.append(entry)\n\n    if len(errors) > 0:\n        for error in errors:\n            sys.stderr.write(\"{}\\n\".format(error))\n        sys.exit(1)\n\n    AccountPatternAuditScore.query.delete()\n    ItemAuditScore.query.delete()\n\n    for entry in entries:\n        db.session.add(entry)\n\n    db.session.commit()\n    db.session.close()\n\n\ndef _parse_tech_names(tech_str):\n    if tech_str == 'all':\n        return list(watcher_registry.keys())\n    else:\n        return tech_str.split(',')\n\n\ndef _parse_accounts(account_str, active=True):\n    \"\"\"Parse the account ID or name. This will raise a KeyError if it can't find it.\"\"\"\n    if account_str == 'all':\n        accounts = Account.query.filter(Account.third_party == False).filter(Account.active == active).all()\n        accounts = [account.name for account in accounts]\n        return accounts\n    else:\n        names_or_ids = account_str.split(',')\n        accounts = Account.query.all()\n        accounts_by_id = {account.identifier: account.name for account in accounts}\n        accounts_by_name = {account.name: account.identifier for account in accounts}\n\n        # Verify that the account name exists (raise a KeyError if it doesn't):\n        names = []\n        for n in names_or_ids:\n            if not accounts_by_id.get(n):\n                _ = accounts_by_name[n]\n\n            names.append(n)\n\n        return names\n\n\n@manager.option('-n', '--name', dest='name', type=text_type, required=True)\ndef delete_account(name):\n    from security_monkey.account_manager import delete_account_by_name\n    delete_account_by_name(name)\n\n\n@manager.option('-t', '--tech_name', dest='tech_name', type=str, required=True)\n@manager.option('-d', '--disabled', dest='disabled', type=bool, default=False)\n# We are locking down the allowed intervals here to 15 minutes, 1 hour, 12 hours, 24\n# hours or one week because too many different intervals could result in too many\n# scheduler threads, impacting performance.\n@manager.option('-i', '--interval', dest='interval', type=int, default=60, choices=[15, 60, 720, 1440, 10080])\ndef add_watcher_config(tech_name, disabled, interval):\n    from security_monkey.datastore import WatcherConfig\n    from security_monkey.watcher import watcher_registry\n\n    if tech_name not in watcher_registry:\n        sys.stderr.write('Invalid tech name {}.\\n'.format(tech_name))\n        sys.exit(1)\n\n    query = WatcherConfig.query.filter(WatcherConfig.index == tech_name)\n    entry = query.first()\n\n    if not entry:\n        entry = WatcherConfig()\n\n    entry.index = tech_name\n    entry.interval = interval\n    entry.active = not disabled\n\n    db.session.add(entry)\n    db.session.commit()\n    db.session.close()\n\n\n@manager.option(\"--override\", dest=\"override\", type=bool, default=True)\ndef fetch_aws_canonical_ids(override):\n    \"\"\"\n    Adds S3 canonical IDs in for all AWS accounts in SM.\n    \"\"\"\n    app.logger.info(\"[ ] Fetching S3 canonical IDs for all AWS accounts being monitored by Security Monkey.\")\n\n    # Get all the active AWS accounts:\n    accounts = Account.query.filter(Account.active == True) \\\n        .join(AccountType).filter(AccountType.name == \"AWS\").all()  # noqa\n\n    get_canonical_ids(accounts, override=override)\n\n    app.logger.info(\"[@] Completed canonical ID fetching.\")\n\n\n@manager.command\ndef clean_stale_issues():\n    \"\"\"\n    Cleans up issues for auditors that have been removed\n    \"\"\"\n    from security_monkey.common.audit_issue_cleanup import clean_stale_issues\n    clean_stale_issues()\n\n\nclass APIServer(Command):\n    def __init__(self, host='127.0.0.1', port=app.config.get('API_PORT'), workers=12):\n        self.address = \"{}:{}\".format(host, port)\n        self.workers = workers\n\n    def get_options(self):\n        return (\n            Option('-b', '--bind',\n                   dest='address',\n                   type=str,\n                   default=self.address),\n            Option('-w', '--workers',\n                   dest='workers',\n                   type=int,\n                   default=self.workers),\n        )\n\n    def handle(self, app, *args, **kwargs):\n\n        if app.config.get('USE_ROUTE53'):\n            route53 = Route53Service()\n            route53.register(app.config.get('FQDN'), exclusive=True)\n\n        workers = kwargs['workers']\n        address = kwargs['address']\n\n        if not GUNICORN:\n            print('GUNICORN not installed. Try `runserver` to use the Flask debug server instead.')\n        else:\n            class FlaskApplication(Application):\n                def init(self, parser, opts, args):\n                    return {\n                        'bind': address,\n                        'workers': workers,\n                        'timeout': 1800\n                    }\n\n                def load(self):\n                    return app\n\n            FlaskApplication().run()\n\n\n@manager.option('-o', '--owner', type=text_type, required=True,\n                help=\"Owner of the accounts, this is often set to a company name.\")\n@manager.option('-b', '--bucket-name', dest='bucket_name', type=text_type, required=True,\n                help=\"S3 bucket where SWAG data is stored.\")\n@manager.option('-p', '--bucket-prefix', dest='bucket_prefix', type=text_type, default='accounts.json',\n                help=\"Prefix to fetch account data from. Default: accounts.json\")\n@manager.option('-r', '--bucket-region', dest='bucket_region', type=text_type, default='us-east-1',\n                help=\"Region SWAG S3 bucket is located. Default: us-east-1\")\n@manager.option('-t', '--account-type', dest='account_type', default='AWS',\n                help=\"Type of account to sync from SWAG data. Default: AWS\")\n@manager.option('-s', '--spinnaker', dest='spinnaker', default=False, action='store_true',\n                help='Use the spinnaker names as account names.')\ndef sync_swag(owner, bucket_name, bucket_prefix, bucket_region, account_type, spinnaker):\n    \"\"\"Use the SWAG client to sync SWAG accounts to Security Monkey.\"\"\"\n    from security_monkey.account_manager import account_registry\n\n    swag_opts = {\n        'swag.type': 's3',\n        'swag.bucket_name': bucket_name,\n        'swag.data_file': bucket_prefix,\n        'swag.region': bucket_region\n    }\n\n    swag = SWAGManager(**parse_swag_config_options(swag_opts))\n    account_manager = account_registry[account_type]()\n\n    for account in swag.get_all(\"[?provider=='{provider}']\".format(provider=account_type.lower())):\n        services = account.get('services', [])\n        services_by_name = {s['name']: s for s in services}\n\n        # Check if the account is active or not:\n        # With the current SWAG schema, need to do the following:\n        # 1. Check if the 'account_status' field is set to 'ready'.\n        # 2. Loop through all the services for \"security_monkey\" and if the status is \"active\", then the account\n        #    is active.\n        check_active = active = False\n        if account['account_status'] == 'ready':\n            check_active = True\n\n        if check_active:\n            secmonkey_service = services_by_name.get('security_monkey', {})\n            for status in secmonkey_service.get('status', []):\n                if status['region'] == 'all':\n                    active = status.get('enabled', False)\n                    break\n\n        thirdparty = account['owner'] != owner\n        if spinnaker:\n            spinnaker_name = swag.get_service_name('spinnaker', \"[?id=='{id}']\".format(id=account['id']))\n            if not spinnaker_name:\n                name = account['name']\n            else:\n                name = spinnaker_name\n        else:\n            name = account['name']\n\n        notes = account['description']\n        identifier = account['id']\n\n        custom_fields = {}\n        s3_name = swag.get_service_name('s3', \"[?id=='{id}']\".format(id=account['id']))\n        if s3_name:\n            custom_fields['s3_name'] = s3_name\n\n        s3_service = services_by_name.get('s3', {})\n        if s3_service:\n            c_id = s3_service['metadata'].get('canonicalId', None)\n            if c_id:\n                custom_fields['canonical_id'] = c_id\n        role_name = secmonkey_service.get('metadata', {}).get('role_name', None)\n        if role_name is not None:\n            custom_fields['role_name'] = role_name\n\n        account_manager.sync(account_manager.account_type, name, active, thirdparty,\n                             notes, identifier,\n                             custom_fields=custom_fields)\n    db.session.close()\n    app.logger.info('SWAG sync successful.')\n\n\n@manager.option('-b', '--bucket-name', dest='bucket_name', type=text_type, help=\"S3 bucket where network whitelist data is stored.\")\n@manager.option('-i', '--input-filename', dest='input_filename', type=text_type, default='networks.json', help=\"File path or bucket prefix to fetch account data from. Default: networks.json\")\n@manager.option('-a', '--authoritative', dest='authoritative', default=False, action='store_true', help='Remove all networks not named in `input_filename`.')\ndef sync_networks(bucket_name, input_filename, authoritative):\n    \"\"\"Imports a JSON file of networks to the Security Monkey whitelist.\"\"\"\n    if bucket_name:\n        import boto3\n        s3 = boto3.client('s3')\n        response = s3.get_object(\n            Bucket=bucket_name,\n            Key=input_filename,\n        )\n        handle = response['Body']\n    else:\n        handle = open(input_filename)\n    networks = json.load(handle)\n    handle.close()\n    existing = NetworkWhitelistEntry.query.filter(\n        NetworkWhitelistEntry.name.in_(networks)\n    )\n    new = set(networks.keys()) - set(entry.name for entry in existing)\n    for entry in existing:\n        entry.cidr = networks[entry.name]\n        db.session.add(entry)\n    for name in new:\n        app.logger.debug('Adding new network %s', name)\n        entry = NetworkWhitelistEntry(\n            name=name,\n            cidr=networks[name],\n        )\n        db.session.add(entry)\n    if authoritative:\n        old = NetworkWhitelistEntry.query.filter(\n            ~NetworkWhitelistEntry.name.in_(networks)\n        )\n        for entry in old:\n            app.logger.debug('Removing stale network %s', entry.name)\n            db.session.delete(entry)\n    db.session.commit()\n    db.session.close()\n\n\nclass AddAccount(Command):\n    def __init__(self, account_manager, *args, **kwargs):\n        super(AddAccount, self).__init__(*args, **kwargs)\n        self._account_manager = account_manager\n        self.__doc__ = \"Add %s account\" % account_manager.account_type\n\n    def get_options(self):\n        options = [\n            Option('-n', '--name', type=text_type, required=True),\n            Option('--id', dest='identifier', type=text_type, required=True),\n            Option('--thirdparty', action='store_true'),\n            Option('--active', action='store_true'),\n            Option('--notes', type=text_type),\n            Option('--update-existing', action=\"store_true\")\n        ]\n        for cf in self._account_manager.custom_field_configs:\n            options.append(Option('--%s' % cf.name, dest=cf.name, type=str))\n        return options\n\n    def handle(self, app, *args, **kwargs):\n        name = kwargs.pop('name')\n        active = kwargs.pop('active', False)\n        thirdparty = kwargs.pop('thirdparty', False)\n        notes = kwargs.pop('notes', '')\n        identifier = kwargs.pop('identifier')\n        update = kwargs.pop('update_existing', False)\n        if update:\n            result = self._account_manager.update(None, self._account_manager.account_type, name, active, thirdparty,\n                                                  notes, identifier,\n                                                  custom_fields=kwargs\n                                                  )\n        else:\n            result = self._account_manager.create(\n                self._account_manager.account_type,\n                name, active, thirdparty, notes, identifier,\n                custom_fields=kwargs)\n        db.session.close()\n\n        if not result:\n            return -1\n\n\ndef main():\n    from security_monkey.account_manager import account_registry\n\n    for name, account_manager in list(account_registry.items()):\n        manager.add_command(\"add_account_%s\" % name.lower(), AddAccount(account_manager()))\n    manager.add_command(\"run_api_server\", APIServer())\n    manager.run()\n\n\nif __name__ == \"__main__\":\n    main()\n"
        },
        {
          "name": "migrations",
          "type": "tree",
          "content": null
        },
        {
          "name": "nginx",
          "type": "tree",
          "content": null
        },
        {
          "name": "requirements.txt",
          "type": "blob",
          "size": 0.8115234375,
          "content": "Flask-CLI==0.4.0\nFlask-BabelEx==0.9.3\nFlask-Login==0.4.1\nFlask-Mail==0.9.1\nFlask-Migrate==2.5.2\nFlask-Principal==0.4.0\nFlask-RESTful==0.3.7\nFlask-Script==2.0.6\nFlask-SQLAlchemy==2.4.1\nFlask-Security==3.0.0\nFlask-WTF==0.14.2\nFlask==1.1.1\nJinja2==2.11.0\nPyJWT==1.7.1\nPyYAML==5.3\nSQLAlchemy==1.3.13\nWerkzeug==0.16.1\nbcrypt==3.1.7\nboto3==1.12.12\nboto==2.49.0\nbotocore<1.16.0,>=1.15.12\ncelery==4.4.0\ncloudaux==1.8.4\ncryptography==2.8\ndeepdiff==5.0.2\ndpath==2.0.1\nflask-marshmallow==0.10.1\ngunicorn==20.0.4\nidna==2.8\nipaddr==2.2.0\nitsdangerous==1.1.0\njira==3.0a2\njoblib==0.14.1\nmarshmallow==2.19.1\nnetaddr==0.7.19\npolicyuniverse==1.3.2.1\npsycopg2-binary==2.8.4\npython-dotenv==0.11.0\npython-openstackclient==4.0.0\npython-cinderclient==7.2.0\npyopenssl==19.1.0\nsix==1.14.0\nswag-client==0.4.7\nvine==1.3.0\nemail-validator==1.1.1\nredis==3.5.3\n"
        },
        {
          "name": "scripts",
          "type": "tree",
          "content": null
        },
        {
          "name": "secmonkey.env",
          "type": "blob",
          "size": 0.1591796875,
          "content": "AWS_ACCESS_KEY_ID=\nAWS_SECRET_ACCESS_KEY=\nSECURITY_MONKEY_POSTGRES_HOST=postgres\nSECURITY_MONKEY_FQDN=127.0.0.1\n# Must be false if HTTP\nSESSION_COOKIE_SECURE=False"
        },
        {
          "name": "security_monkey",
          "type": "tree",
          "content": null
        },
        {
          "name": "setup.py",
          "type": "blob",
          "size": 2.3818359375,
          "content": "#     Copyright 2018 Netflix, Inc.\n#\n#     Licensed under the Apache License, Version 2.0 (the \"License\");\n#     you may not use this file except in compliance with the License.\n#     You may obtain a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#     Unless required by applicable law or agreed to in writing, software\n#     distributed under the License is distributed on an \"AS IS\" BASIS,\n#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#     See the License for the specific language governing permissions and\n#     limitations under the License.\nimport ast\nimport re\n\nfrom setuptools import find_packages, setup\n\nwith open('requirements.txt') as f:\n    INSTALL_REQUIRED = f.read().splitlines()\n\n_version_re = re.compile(r'__version__\\s+=\\s+(.*)')\nwith open('security_monkey/__init__.py', 'rb') as f:\n    SECURITY_MONKEY_VERSION = str(ast.literal_eval(_version_re.search(\n        f.read().decode('utf-8')).group(1)))\n\nsetup(\n    name='security_monkey',\n    version=SECURITY_MONKEY_VERSION,\n    long_description=__doc__,\n    packages=find_packages(exclude=[\"tests\"]),\n    package_data={\n        'security_monkey': [\n            'templates/*.json',\n            'templates/*.html',\n            'templates/security/*.html',\n        ]\n    },\n    include_package_data=True,\n    classifiers=[\n        'Programming Language :: Python :: 3.7',\n    ],\n    data_files=[('env-config', ['env-config/config.py',\n                                'env-config/config-docker.py']),\n                ('data', ['data/aws_accounts.json'])],\n    zip_safe=False,\n    install_requires=INSTALL_REQUIRED,\n    extras_require={\n        #'onelogin': ['python-saml>=2.4.0'],\n        'sentry': ['raven[flask]==6.6.0'],\n        #'googleauth': ['google-auth>=1.6.3'],\n        'tests': [\n            'pytest==3.4.2',\n            'nose==1.3.7',\n            'mixer==6.0.1',\n            'mock==2.0.0',\n            'freezegun>=0.3.7',\n            'testtools==2.3.0',\n            'requests_mock==1.5.2',\n            'oslotest==3.7.0',\n            'moto==1.3.15.dev953',\n            'attrs==19.1.0'  # Fixes issue with pytest according to\n                             # https://stackoverflow.com/questions/58189683/typeerror-attrib-got-an-unexpected-keyword-argument-convert\n        ]\n    },\n    entry_points={\n        'console_scripts': [\n            'monkey = security_monkey.manage:main',\n        ],\n    }\n)\n"
        },
        {
          "name": "supervisor",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}