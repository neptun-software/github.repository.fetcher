{
  "metadata": {
    "timestamp": 1736559517902,
    "page": 105,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjExMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "diafygi/acme-tiny",
      "stars": 4731,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.685546875,
          "content": "# Byte-compiled / optimized / DLL files\n__pycache__/\n*.py[cod]\n\n# C extensions\n*.so\n\n# Distribution / packaging\n.Python\nenv/\nbuild/\ndevelop-eggs/\ndist/\ndownloads/\neggs/\n.eggs/\nlib/\nlib64/\nparts/\nsdist/\nvar/\n*.egg-info/\n.installed.cfg\n*.egg\n\n# PyInstaller\n#  Usually these files are written by a python script from a template\n#  before PyInstaller builds the exe, so as to inject date/other infos into it.\n*.manifest\n*.spec\n\n# Installer logs\npip-log.txt\npip-delete-this-directory.txt\n\n# Unit test / coverage reports\nhtmlcov/\n.tox/\n.coverage\n.coverage.*\n.cache\nnosetests.xml\ncoverage.xml\n*,cover\n\n# Translations\n*.mo\n*.pot\n\n# Django stuff:\n*.log\n\n# Sphinx documentation\ndocs/_build/\n\n# PyBuilder\ntarget/\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.056640625,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2015 Daniel Roesler\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 8.8916015625,
          "content": "# acme-tiny\n\n[![Tests](https://github.com/diafygi/acme-tiny/actions/workflows/full-tests-with-coverage.yml/badge.svg)](https://github.com/diafygi/acme-tiny/actions/workflows/full-tests-with-coverage.yml)\n[![Coverage Status](https://coveralls.io/repos/github/diafygi/acme-tiny/badge.svg?branch=master)](https://coveralls.io/github/diafygi/acme-tiny?branch=master)\n\nThis is a tiny, auditable script that you can throw on your server to issue\nand renew [Let's Encrypt](https://letsencrypt.org/) certificates. Since it has\nto be run on your server and have access to your private Let's Encrypt account\nkey, I tried to make it as tiny as possible (currently less than 200 lines).\nThe only prerequisites are python and openssl.\n\n**PLEASE READ THE SOURCE CODE! YOU MUST TRUST IT WITH YOUR PRIVATE ACCOUNT KEY!**\n\n## Donate\n\nIf this script is useful to you, please donate to the EFF. I don't work there,\nbut they do fantastic work.\n\n[https://eff.org/donate/](https://eff.org/donate/)\n\n## How to use this script\n\nIf you already have a Let's Encrypt issued certificate and just want to renew,\nyou should only have to do Steps 3 and 6.\n\n### Step 1: Create a Let's Encrypt account private key (if you haven't already)\n\nYou must have a public key registered with Let's Encrypt and sign your requests\nwith the corresponding private key. If you don't understand what I just said,\nthis script likely isn't for you! Please use the official Let's Encrypt\n[client](https://github.com/letsencrypt/letsencrypt).\nTo accomplish this you need to initially create a key, that can be used by\nacme-tiny, to register an account for you and sign all following requests.\n\n```\nopenssl genrsa 4096 > account.key\n```\n\n#### Use existing Let's Encrypt key\n\nAlternatively you can convert your key, previously generated by the original\nLet's Encrypt client.\n\nThe private account key from the Let's Encrypt client is saved in the\n[JWK](https://tools.ietf.org/html/rfc7517) format. `acme-tiny` is using the PEM\nkey format. To convert the key, you can use the tool\n[conversion script](https://gist.github.com/JonLundy/f25c99ee0770e19dc595) by JonLundy:\n\n```sh\n# Download the script\nwget -O - \"https://gist.githubusercontent.com/JonLundy/f25c99ee0770e19dc595/raw/6035c1c8938fae85810de6aad1ecf6e2db663e26/conv.py\" > conv.py\n\n# Copy your private key to your working directory\ncp /etc/letsencrypt/accounts/acme-v01.api.letsencrypt.org/directory/<id>/private_key.json private_key.json\n\n# Create a DER encoded private key\nopenssl asn1parse -noout -out private_key.der -genconf <(python2 conv.py private_key.json)\n\n# Convert to PEM\nopenssl rsa -in private_key.der -inform der > account.key\n```\n\n### Step 2: Create a certificate signing request (CSR) for your domains.\n\nThe ACME protocol (what Let's Encrypt uses) requires a CSR file to be submitted\nto it, even for renewals. You can use the same CSR for multiple renewals. NOTE:\nyou can't use your account private key as your domain private key!\n\n```\n# Generate a domain private key (if you haven't already)\nopenssl genrsa 4096 > domain.key\n```\n\n```\n# For a single domain\nopenssl req -new -sha256 -key domain.key -subj \"/CN=yoursite.com\" > domain.csr\n\n# For multiple domains (use this one if you want both www.yoursite.com and yoursite.com)\nopenssl req -new -sha256 -key domain.key -subj \"/\" -addext \"subjectAltName = DNS:yoursite.com, DNS:www.yoursite.com\" > domain.csr\n\n# For multiple domains (same as above but works with openssl < 1.1.1)\nopenssl req -new -sha256 -key domain.key -subj \"/\" -reqexts SAN -config <(cat /etc/ssl/openssl.cnf <(printf \"[SAN]\\nsubjectAltName=DNS:yoursite.com,DNS:www.yoursite.com\")) > domain.csr\n```\n\n### Step 3: Make your website host challenge files\n\nYou must prove you own the domains you want a certificate for, so Let's Encrypt\nrequires you host some files on them. This script will generate and write those\nfiles in the folder you specify, so all you need to do is make sure that this\nfolder is served under the \".well-known/acme-challenge/\" url path. NOTE: Let's\nEncrypt will perform a plain HTTP request to port 80 on your server, so you\nmust serve the challenge files via HTTP (a redirect to HTTPS is fine too).\n\n```\n# Make some challenge folder (modify to suit your needs)\nmkdir -p /var/www/challenges/\n```\n\n```nginx\n# Example for nginx\nserver {\n    listen 80;\n    server_name yoursite.com www.yoursite.com;\n\n    location /.well-known/acme-challenge/ {\n        alias /var/www/challenges/;\n        try_files $uri =404;\n    }\n\n    ...the rest of your config\n}\n```\n\n### Step 4: Get a signed certificate!\n\nNow that you have setup your server and generated all the needed files, run this\nscript on your server with the permissions needed to write to the above folder\nand read your private account key and CSR.\n\n```\n# Run the script on your server\npython acme_tiny.py --account-key ./account.key --csr ./domain.csr --acme-dir /var/www/challenges/ > ./signed_chain.crt\n```\n\n### Step 5: Install the certificate\n\nThe signed https certificate chain that is output by this script can be used along\nwith your private key to run an https server. You need to include them in the\nhttps settings in your web server's configuration. Here's an example on how to\nconfigure an nginx server:\n\n```nginx\nserver {\n    listen 443 ssl;\n    server_name yoursite.com www.yoursite.com;\n\n    ssl_certificate /path/to/signed_chain.crt;\n    ssl_certificate_key /path/to/domain.key;\n    ssl_session_timeout 5m;\n    ssl_protocols TLSv1.2;\n    ssl_ciphers ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384;\n    ssl_session_cache shared:SSL:50m;\n    ssl_dhparam /path/to/server.dhparam;\n    ssl_prefer_server_ciphers on;\n\n    ...the rest of your config\n}\n\nserver {\n    listen 80;\n    server_name yoursite.com www.yoursite.com;\n\n    location /.well-known/acme-challenge/ {\n        alias /var/www/challenges/;\n        try_files $uri =404;\n    }\n\n    ...the rest of your config\n}\n```\n\n### Step 6: Setup an auto-renew cronjob\n\nCongrats! Your website is now using https! Unfortunately, Let's Encrypt\ncertificates only last for 90 days, so you need to renew them often. No worries!\nIt's automated! Just make a bash script and add it to your crontab (see below\nfor example script).\n\nExample of a `renew_cert.sh`:\n```sh\n#!/usr/bin/sh\npython /path/to/acme_tiny.py --account-key /path/to/account.key --csr /path/to/domain.csr --acme-dir /var/www/challenges/ > /path/to/signed_chain.crt.tmp || exit\nmv /path/to/signed_chain.crt.tmp /path/to/signed_chain.crt\nservice nginx reload\n```\n\n```\n# Example line in your crontab (runs once per month)\n0 0 1 * * /path/to/renew_cert.sh 2>> /var/log/acme_tiny.log\n```\n\n**NOTE:** Since Let's Encrypt's ACME v2 release (acme-tiny 4.0.0+), the intermediate\ncertificate is included in the issued certificate download, so you no longer have\nto independently download the intermediate certificate and concatenate it to your\nsigned certificate. If you have an shell script or Makefile using acme-tiny &lt;4.0 (e.g. before\n2018-03-17) with acme-tiny 4.0.0+, then you may be adding the intermediate\ncertificate to your signed_chain.crt twice (which\n[causes issues with at least GnuTLS 3.7.0](https://gitlab.com/gnutls/gnutls/-/issues/1131)\nbesides making the certificate slightly larger than it needs to be). To fix,\nsimply remove the bash code where you're downloading the intermediate and adding\nit to the acme-tiny certificate output.\n\n## Permissions\n\nThe biggest problem you'll likely come across while setting up and running this\nscript is permissions. You want to limit access to your account private key and\nchallenge web folder as much as possible. I'd recommend creating a user\nspecifically for handling this script, the account private key, and the\nchallenge folder. Then add the ability for that user to write to your installed\ncertificate file (e.g. `/path/to/signed_chain.crt`) and reload your webserver. That\nway, the cron script will do its thing, overwrite your old certificate, and\nreload your webserver without having permission to do anything else.\n\n**BE SURE TO:**\n* Backup your account private key (e.g. `account.key`)\n* Don't allow this script to be able to read your domain private key!\n* Don't allow this script to be run as root!\n\n## Staging Environment\n\nLet's Encrypt recommends testing new configurations against their staging servers,\nso when testing out your new setup, you can use\n`--directory-url https://acme-staging-v02.api.letsencrypt.org/directory`\nto issue fake test certificates instead of real ones from Let's Encrypt's production servers.\nSee [https://letsencrypt.org/docs/staging-environment/](https://letsencrypt.org/docs/staging-environment/)\nfor more details.\n\n## Feedback/Contributing\n\nThis project has a very, very limited scope and codebase. I'm happy to receive\nbug reports and pull requests, but please don't add any new features. This\nscript must stay under 200 lines of code to ensure it can be easily audited by\nanyone who wants to run it.\n\nIf you want to add features for your own setup to make things easier for you,\nplease do! It's open source, so feel free to fork it and modify as necessary.\n"
        },
        {
          "name": "acme_tiny.py",
          "type": "blob",
          "size": 11.5224609375,
          "content": "#!/usr/bin/env python3\n# Copyright Daniel Roesler, under MIT license, see LICENSE at github.com/diafygi/acme-tiny\nimport argparse, subprocess, json, os, sys, base64, binascii, time, hashlib, re, copy, textwrap, logging\ntry:\n    from urllib.request import urlopen, Request # Python 3\nexcept ImportError: # pragma: no cover\n    from urllib2 import urlopen, Request # Python 2\n\nDEFAULT_CA = \"https://acme-v02.api.letsencrypt.org\" # DEPRECATED! USE DEFAULT_DIRECTORY_URL INSTEAD\nDEFAULT_DIRECTORY_URL = \"https://acme-v02.api.letsencrypt.org/directory\"\n\nLOGGER = logging.getLogger(__name__)\nLOGGER.addHandler(logging.StreamHandler())\nLOGGER.setLevel(logging.INFO)\n\ndef get_crt(account_key, csr, acme_dir, log=LOGGER, CA=DEFAULT_CA, disable_check=False, directory_url=DEFAULT_DIRECTORY_URL, contact=None, check_port=None):\n    directory, acct_headers, alg, jwk = None, None, None, None # global variables\n\n    # helper functions - base64 encode for jose spec\n    def _b64(b):\n        return base64.urlsafe_b64encode(b).decode('utf8').replace(\"=\", \"\")\n\n    # helper function - run external commands\n    def _cmd(cmd_list, stdin=None, cmd_input=None, err_msg=\"Command Line Error\"):\n        proc = subprocess.Popen(cmd_list, stdin=stdin, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n        out, err = proc.communicate(cmd_input)\n        if proc.returncode != 0:\n            raise IOError(\"{0}\\n{1}\".format(err_msg, err))\n        return out\n\n    # helper function - make request and automatically parse json response\n    def _do_request(url, data=None, err_msg=\"Error\", depth=0):\n        try:\n            resp = urlopen(Request(url, data=data, headers={\"Content-Type\": \"application/jose+json\", \"User-Agent\": \"acme-tiny\"}))\n            resp_data, code, headers = resp.read().decode(\"utf8\"), resp.getcode(), resp.headers\n        except IOError as e:\n            resp_data = e.read().decode(\"utf8\") if hasattr(e, \"read\") else str(e)\n            code, headers = getattr(e, \"code\", None), {}\n        try:\n            resp_data = json.loads(resp_data) # try to parse json results\n        except ValueError:\n            pass # ignore json parsing errors\n        if depth < 100 and code == 400 and resp_data['type'] == \"urn:ietf:params:acme:error:badNonce\":\n            raise IndexError(resp_data) # allow 100 retrys for bad nonces\n        if code not in [200, 201, 204]:\n            raise ValueError(\"{0}:\\nUrl: {1}\\nData: {2}\\nResponse Code: {3}\\nResponse: {4}\".format(err_msg, url, data, code, resp_data))\n        return resp_data, code, headers\n\n    # helper function - make signed requests\n    def _send_signed_request(url, payload, err_msg, depth=0):\n        payload64 = \"\" if payload is None else _b64(json.dumps(payload).encode('utf8'))\n        new_nonce = _do_request(directory['newNonce'])[2]['Replay-Nonce']\n        protected = {\"url\": url, \"alg\": alg, \"nonce\": new_nonce}\n        protected.update({\"jwk\": jwk} if acct_headers is None else {\"kid\": acct_headers['Location']})\n        protected64 = _b64(json.dumps(protected).encode('utf8'))\n        protected_input = \"{0}.{1}\".format(protected64, payload64).encode('utf8')\n        out = _cmd([\"openssl\", \"dgst\", \"-sha256\", \"-sign\", account_key], stdin=subprocess.PIPE, cmd_input=protected_input, err_msg=\"OpenSSL Error\")\n        data = json.dumps({\"protected\": protected64, \"payload\": payload64, \"signature\": _b64(out)})\n        try:\n            return _do_request(url, data=data.encode('utf8'), err_msg=err_msg, depth=depth)\n        except IndexError: # retry bad nonces (they raise IndexError)\n            return _send_signed_request(url, payload, err_msg, depth=(depth + 1))\n\n    # helper function - poll until complete\n    def _poll_until_not(url, pending_statuses, err_msg):\n        result, t0 = None, time.time()\n        while result is None or result['status'] in pending_statuses:\n            assert (time.time() - t0 < 3600), \"Polling timeout\" # 1 hour timeout\n            time.sleep(0 if result is None else 2)\n            result, _, _ = _send_signed_request(url, None, err_msg)\n        return result\n\n    # parse account key to get public key\n    log.info(\"Parsing account key...\")\n    out = _cmd([\"openssl\", \"rsa\", \"-in\", account_key, \"-noout\", \"-text\"], err_msg=\"OpenSSL Error\")\n    pub_pattern = r\"modulus:[\\s]+?00:([a-f0-9\\:\\s]+?)\\npublicExponent: ([0-9]+)\"\n    pub_hex, pub_exp = re.search(pub_pattern, out.decode('utf8'), re.MULTILINE|re.DOTALL).groups()\n    pub_exp = \"{0:x}\".format(int(pub_exp))\n    pub_exp = \"0{0}\".format(pub_exp) if len(pub_exp) % 2 else pub_exp\n    alg, jwk = \"RS256\", {\n        \"e\": _b64(binascii.unhexlify(pub_exp.encode(\"utf-8\"))),\n        \"kty\": \"RSA\",\n        \"n\": _b64(binascii.unhexlify(re.sub(r\"(\\s|:)\", \"\", pub_hex).encode(\"utf-8\"))),\n    }\n    accountkey_json = json.dumps(jwk, sort_keys=True, separators=(',', ':'))\n    thumbprint = _b64(hashlib.sha256(accountkey_json.encode('utf8')).digest())\n\n    # find domains\n    log.info(\"Parsing CSR...\")\n    out = _cmd([\"openssl\", \"req\", \"-in\", csr, \"-noout\", \"-text\"], err_msg=\"Error loading {0}\".format(csr))\n    domains = set([])\n    common_name = re.search(r\"Subject:.*? CN\\s?=\\s?([^\\s,;/]+)\", out.decode('utf8'))\n    if common_name is not None:\n        domains.add(common_name.group(1))\n    subject_alt_names = re.search(r\"X509v3 Subject Alternative Name: (?:critical)?\\n +([^\\n]+)\\n\", out.decode('utf8'), re.MULTILINE|re.DOTALL)\n    if subject_alt_names is not None:\n        for san in subject_alt_names.group(1).split(\", \"):\n            if san.startswith(\"DNS:\"):\n                domains.add(san[4:])\n    log.info(u\"Found domains: {0}\".format(\", \".join(domains)))\n\n    # get the ACME directory of urls\n    log.info(\"Getting directory...\")\n    directory_url = CA + \"/directory\" if CA != DEFAULT_CA else directory_url # backwards compatibility with deprecated CA kwarg\n    directory, _, _ = _do_request(directory_url, err_msg=\"Error getting directory\")\n    log.info(\"Directory found!\")\n\n    # create account, update contact details (if any), and set the global key identifier\n    log.info(\"Registering account...\")\n    reg_payload = {\"termsOfServiceAgreed\": True} if contact is None else {\"termsOfServiceAgreed\": True, \"contact\": contact}\n    account, code, acct_headers = _send_signed_request(directory['newAccount'], reg_payload, \"Error registering\")\n    log.info(\"{0} Account ID: {1}\".format(\"Registered!\" if code == 201 else \"Already registered!\", acct_headers['Location']))\n    if contact is not None:\n        account, _, _ = _send_signed_request(acct_headers['Location'], {\"contact\": contact}, \"Error updating contact details\")\n        log.info(\"Updated contact details:\\n{0}\".format(\"\\n\".join(account['contact'])))\n\n    # create a new order\n    log.info(\"Creating new order...\")\n    order_payload = {\"identifiers\": [{\"type\": \"dns\", \"value\": d} for d in domains]}\n    order, _, order_headers = _send_signed_request(directory['newOrder'], order_payload, \"Error creating new order\")\n    log.info(\"Order created!\")\n\n    # get the authorizations that need to be completed\n    for auth_url in order['authorizations']:\n        authorization, _, _ = _send_signed_request(auth_url, None, \"Error getting challenges\")\n        domain = authorization['identifier']['value']\n\n        # skip if already valid\n        if authorization['status'] == \"valid\":\n            log.info(\"Already verified: {0}, skipping...\".format(domain))\n            continue\n        log.info(\"Verifying {0}...\".format(domain))\n\n        # find the http-01 challenge and write the challenge file\n        challenge = [c for c in authorization['challenges'] if c['type'] == \"http-01\"][0]\n        token = re.sub(r\"[^A-Za-z0-9_\\-]\", \"_\", challenge['token'])\n        keyauthorization = \"{0}.{1}\".format(token, thumbprint)\n        wellknown_path = os.path.join(acme_dir, token)\n        with open(wellknown_path, \"w\") as wellknown_file:\n            wellknown_file.write(keyauthorization)\n\n        # check that the file is in place\n        try:\n            wellknown_url = \"http://{0}{1}/.well-known/acme-challenge/{2}\".format(domain, \"\" if check_port is None else \":{0}\".format(check_port), token)\n            assert (disable_check or _do_request(wellknown_url)[0] == keyauthorization)\n        except (AssertionError, ValueError) as e:\n            raise ValueError(\"Wrote file to {0}, but couldn't download {1}: {2}\".format(wellknown_path, wellknown_url, e))\n\n        # say the challenge is done\n        _send_signed_request(challenge['url'], {}, \"Error submitting challenges: {0}\".format(domain))\n        authorization = _poll_until_not(auth_url, [\"pending\"], \"Error checking challenge status for {0}\".format(domain))\n        if authorization['status'] != \"valid\":\n            raise ValueError(\"Challenge did not pass for {0}: {1}\".format(domain, authorization))\n        os.remove(wellknown_path)\n        log.info(\"{0} verified!\".format(domain))\n\n    # finalize the order with the csr\n    log.info(\"Signing certificate...\")\n    csr_der = _cmd([\"openssl\", \"req\", \"-in\", csr, \"-outform\", \"DER\"], err_msg=\"DER Export Error\")\n    _send_signed_request(order['finalize'], {\"csr\": _b64(csr_der)}, \"Error finalizing order\")\n\n    # poll the order to monitor when it's done\n    order = _poll_until_not(order_headers['Location'], [\"pending\", \"processing\"], \"Error checking order status\")\n    if order['status'] != \"valid\":\n        raise ValueError(\"Order failed: {0}\".format(order))\n\n    # download the certificate\n    certificate_pem, _, _ = _send_signed_request(order['certificate'], None, \"Certificate download failed\")\n    log.info(\"Certificate signed!\")\n    return certificate_pem\n\ndef main(argv=None):\n    parser = argparse.ArgumentParser(\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        description=textwrap.dedent(\"\"\"\\\n            This script automates the process of getting a signed TLS certificate from Let's Encrypt using the ACME protocol.\n            It will need to be run on your server and have access to your private account key, so PLEASE READ THROUGH IT!\n            It's only ~200 lines, so it won't take long.\n\n            Example Usage: python acme_tiny.py --account-key ./account.key --csr ./domain.csr --acme-dir /usr/share/nginx/html/.well-known/acme-challenge/ > signed_chain.crt\n            \"\"\")\n    )\n    parser.add_argument(\"--account-key\", required=True, help=\"path to your Let's Encrypt account private key\")\n    parser.add_argument(\"--csr\", required=True, help=\"path to your certificate signing request\")\n    parser.add_argument(\"--acme-dir\", required=True, help=\"path to the .well-known/acme-challenge/ directory\")\n    parser.add_argument(\"--quiet\", action=\"store_const\", const=logging.ERROR, help=\"suppress output except for errors\")\n    parser.add_argument(\"--disable-check\", default=False, action=\"store_true\", help=\"disable checking if the challenge file is hosted correctly before telling the CA\")\n    parser.add_argument(\"--directory-url\", default=DEFAULT_DIRECTORY_URL, help=\"certificate authority directory url, default is Let's Encrypt\")\n    parser.add_argument(\"--ca\", default=DEFAULT_CA, help=\"DEPRECATED! USE --directory-url INSTEAD!\")\n    parser.add_argument(\"--contact\", metavar=\"CONTACT\", default=None, nargs=\"*\", help=\"Contact details (e.g. mailto:aaa@bbb.com) for your account-key\")\n    parser.add_argument(\"--check-port\", metavar=\"PORT\", default=None, help=\"what port to use when self-checking the challenge file, default is port 80\")\n\n    args = parser.parse_args(argv)\n    LOGGER.setLevel(args.quiet or LOGGER.level)\n    signed_crt = get_crt(args.account_key, args.csr, args.acme_dir, log=LOGGER, CA=args.ca, disable_check=args.disable_check, directory_url=args.directory_url, contact=args.contact, check_port=args.check_port)\n    sys.stdout.write(signed_crt)\n\nif __name__ == \"__main__\": # pragma: no cover\n    main(sys.argv[1:])\n"
        },
        {
          "name": "setup.cfg",
          "type": "blob",
          "size": 0.0224609375,
          "content": "[wheel]\nuniversal=True\n"
        },
        {
          "name": "setup.py",
          "type": "blob",
          "size": 1.138671875,
          "content": "from setuptools import setup\n\nsetup(\n    name=\"acme-tiny\",\n    use_scm_version=True,\n    url=\"https://github.com/diafygi/acme-tiny\",\n    author=\"Daniel Roesler\",\n    author_email=\"diafygi@gmail.com\",\n    description=\"A tiny script to issue and renew TLS certs from Let's Encrypt\",\n    license=\"MIT\",\n    py_modules=['acme_tiny'],\n    entry_points={'console_scripts': [\n        'acme-tiny = acme_tiny:main',\n    ]},\n    setup_requires=['setuptools_scm'],\n    classifiers = [\n        'Development Status :: 5 - Production/Stable',\n        'Intended Audience :: System Administrators',\n        'License :: OSI Approved :: MIT License',\n        'Operating System :: OS Independent',\n        'Programming Language :: Python',\n        'Programming Language :: Python :: 2',\n        'Programming Language :: Python :: 2.7',\n        'Programming Language :: Python :: 3',\n        'Programming Language :: Python :: 3.3',\n        'Programming Language :: Python :: 3.4',\n        'Programming Language :: Python :: 3.5',\n        'Programming Language :: Python :: 3.6',\n        'Programming Language :: Python :: 3.7',\n        'Programming Language :: Python :: 3.8',\n    ]\n)\n"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}