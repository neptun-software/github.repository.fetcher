{
  "metadata": {
    "timestamp": 1736559954515,
    "page": 732,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjc0MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "santinic/pampy",
      "stars": 3513,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".coveralls.yml",
          "type": "blob",
          "size": 0.068359375,
          "content": "service_name: travis-pro\nrepo_token: 57JUvsvYjPKj6CGTU9SywRs7CdnRCOkqS"
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 1.1904296875,
          "content": "# Byte-compiled / optimized / DLL files\n__pycache__/\n*.py[cod]\n*$py.class\n\n# C extensions\n*.so\n\n# Distribution / packaging\n.Python\nbuild/\ndevelop-eggs/\ndist/\ndownloads/\neggs/\n.eggs/\nlib/\nlib64/\nparts/\nsdist/\nvar/\nwheels/\n*.egg-info/\n.installed.cfg\n*.egg\nMANIFEST\n\n# PyInstaller\n#  Usually these files are written by a python script from a template\n#  before PyInstaller builds the exe, so as to inject date/other infos into it.\n*.manifest\n*.spec\n\n# Installer logs\npip-log.txt\npip-delete-this-directory.txt\n\n# Unit test / coverage reports\nhtmlcov/\n.tox/\n.coverage\n.coverage.*\n.cache\nnosetests.xml\ncoverage.xml\n*.cover\n.hypothesis/\n.pytest_cache/\n\n# Translations\n*.mo\n*.pot\n\n# Django stuff:\n*.log\nlocal_settings.py\ndb.sqlite3\n\n# Flask stuff:\ninstance/\n.webassets-cache\n\n# Scrapy stuff:\n.scrapy\n\n# Sphinx documentation\ndocs/_build/\n\n# PyBuilder\ntarget/\n\n# Jupyter Notebook\n.ipynb_checkpoints\n\n# pyenv\n.python-version\n\n# celery beat schedule file\ncelerybeat-schedule\n\n# SageMath parsed files\n*.sage.py\n\n# Environments\n.env\n.venv\nenv/\nvenv/\nENV/\nenv.bak/\nvenv.bak/\n\n# Spyder project settings\n.spyderproject\n.spyproject\n\n# Rope project settings\n.ropeproject\n\n# mkdocs documentation\n/site\n\n# mypy\n.mypy_cache/\n\n.idea/\ndrafts/\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.2880859375,
          "content": "language: python\npython:\n  - \"3.6\"\n  - \"3.7-dev\"\n  - \"nightly\"\ninstall:\n  - \"pip install coverage\"\n  - \"pip install python-coveralls\"\nscript:\n  - \"python -m unittest discover -s tests\"\n  - \"coverage run --omit=*.virtualenvs*,*virtualenv* -m unittest discover tests\"\nafter_success:\n    coveralls\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.046875,
          "content": "MIT License\n\nCopyright (c) 2018 Claudio Santini\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 12.529296875,
          "content": "![Pampy in Star Wars](https://raw.githubusercontent.com/santinic/pampy/master/imgs/pampy.png \"Pampy in Star Wars\")\n\n# Pampy: Pattern Matching for Python\n[![License MIT](https://go-shields.herokuapp.com/license-MIT-blue.png)]()\n[![Travis-CI Status](https://api.travis-ci.org/santinic/pampy.svg?branch=master)](https://travis-ci.org/santinic/pampy)\n[![Coverage Status](https://coveralls.io/repos/github/santinic/pampy/badge.svg?branch=master)](https://coveralls.io/github/santinic/pampy?branch=master)\n[![PyPI version](https://badge.fury.io/py/pampy.svg)](https://badge.fury.io/py/pampy)\n\nPampy is pretty small (150 lines), reasonably fast, and often makes your code more readable\nand hence easier to reason about. [There is also a JavaScript version, called Pampy.js](https://github.com/santinic/pampy.js).\n\n<kbd>\n  <img src=\"https://raw.githubusercontent.com/santinic/pampy/master/imgs/slide1.png\" width=\"700\">\n</kbd>\n\n## You can write many patterns\n\nPatterns are evaluated in the order they appear.\n\n<kbd>\n  <img src=\"https://raw.githubusercontent.com/santinic/pampy/master/imgs/slide2.png\" width=\"700\">\n</kbd>\n\n\n## You can write Fibonacci\nThe operator _ means \"any other case I didn't think of\".\n\n```python\nfrom pampy import match, _\n\ndef fibonacci(n):\n    return match(n,\n        1, 1,\n        2, 1,\n        _, lambda x: fibonacci(x-1) + fibonacci(x-2)\n    )\n```\n\n## You can write a Lisp calculator in 5 lines\n\n```python\nfrom pampy import match, REST, _\n\ndef lisp(exp):\n    return match(exp,\n        int,                lambda x: x,\n        callable,           lambda x: x,\n        (callable, REST),   lambda f, rest: f(*map(lisp, rest)),\n        tuple,              lambda t: list(map(lisp, t)),\n    )\n\nplus = lambda a, b: a + b\nminus = lambda a, b: a - b\nfrom functools import reduce\n\nlisp((plus, 1, 2))                 \t# => 3\nlisp((plus, 1, (minus, 4, 2)))     \t# => 3\nlisp((reduce, plus, (range, 10)))       # => 45\n```\n\n## You can match so many things!\n\n```python\nmatch(x,\n    3,              \"this matches the number 3\",\n\n    int,            \"matches any integer\",\n\n    (str, int),     lambda a, b: \"a tuple (a, b) you can use in a function\",\n\n    [1, 2, _],      \"any list of 3 elements that begins with [1, 2]\",\n\n    {'x': _},       \"any dict with a key 'x' and any value associated\",\n\n    _,              \"anything else\"\n)\n```\n\n## You can match [HEAD, TAIL]\n\n```python\nfrom pampy import match, HEAD, TAIL, _\n\nx = [1, 2, 3]\n\nmatch(x, [1, TAIL],     lambda t: t)            # => [2, 3]\n\nmatch(x, [HEAD, TAIL],  lambda h, t: (h, t))    # => (1, [2, 3])\n\n```\n`TAIL` and `REST` actually mean the same thing.\n\n## You can nest lists and tuples\n\n```python\nfrom pampy import match, _\n\nx = [1, [2, 3], 4]\n\nmatch(x, [1, [_, 3], _], lambda a, b: [1, [a, 3], b])           # => [1, [2, 3], 4]\n```\n\n## You can nest dicts. And you can use _ as key!\n\n```python\n\npet = { 'type': 'dog', 'details': { 'age': 3 } }\n\nmatch(pet, { 'details': { 'age': _ } }, lambda age: age)        # => 3\n\nmatch(pet, { _ : { 'age': _ } },        lambda a, b: (a, b))    # => ('details', 3)\n```\n\nIt feels like putting multiple _ inside dicts shouldn't work. Isn't ordering in dicts not guaranteed ?\nBut it does because\n[in Python 3.7, dict maintains insertion key order by default](https://mail.python.org/pipermail/python-dev/2017-December/151283.html)\n\n## You can match class hierarchies\n\n```python\nclass Pet:          pass\nclass Dog(Pet):     pass\nclass Cat(Pet):     pass\nclass Hamster(Pet): pass\n\ndef what_is(x):\n    return match(x,\n        Dog, \t\t'dog',\n        Cat, \t\t'cat',\n        Pet, \t\t'any other pet',\n          _, \t\t'this is not a pet at all',\n    )\n\nwhat_is(Cat())      # => 'cat'\nwhat_is(Dog())      # => 'dog'\nwhat_is(Hamster())  # => 'any other pet'\nwhat_is(Pet())      # => 'any other pet'\nwhat_is(42)         # => 'this is not a pet at all'\n```\n\n## Using Dataclasses\nPampy supports Python 3.7 dataclasses. You can pass the operator `_` as arguments and it will match those fields.\n\n```python\n@dataclass\nclass Pet:\n    name: str\n    age: int\n\npet = Pet('rover', 7)\n\nmatch(pet, Pet('rover', _), lambda age: age)                    # => 7\nmatch(pet, Pet(_, 7), lambda name: name)                        # => 'rover'\nmatch(pet, Pet(_, _), lambda name, age: (name, age))            # => ('rover', 7)\n```\n\n## Using typing\nPampy supports typing annotations.\n\n```python\n\nclass Pet:          pass\nclass Dog(Pet):     pass\nclass Cat(Pet):     pass\nclass Hamster(Pet): pass\n\ntimestamp = NewType(\"year\", Union[int, float])\n\ndef annotated(a: Tuple[int, float], b: str, c: E) -> timestamp:\n    pass\n\nmatch((1, 2), Tuple[int, int], lambda a, b: (a, b))             # => (1, 2)\nmatch(1, Union[str, int], lambda x: x)                          # => 1\nmatch('a', Union[str, int], lambda x: x)                        # => 'a'\nmatch('a', Optional[str], lambda x: x)                          # => 'a'\nmatch(None, Optional[str], lambda x: x)                         # => None\nmatch(Pet, Type[Pet], lambda x: x)                              # => Pet\nmatch(Cat, Type[Pet], lambda x: x)                              # => Cat\nmatch(Dog, Any, lambda x: x)                                    # => Dog\nmatch(Dog, Type[Any], lambda x: x)                              # => Dog\nmatch(15, timestamp, lambda x: x)                               # => 15\nmatch(10.0, timestamp, lambda x: x)                             # => 10.0\nmatch([1, 2, 3], List[int], lambda x: x)                        # => [1, 2, 3]\nmatch({'a': 1, 'b': 2}, Dict[str, int], lambda x: x)            # => {'a': 1, 'b': 2}\nmatch(annotated, \n    Callable[[Tuple[int, float], str, Pet], timestamp], lambda x: x\n)                                                               # => annotated\n```\nFor iterable generics actual type of value is guessed based on the first element. \n```python\nmatch([1, 2, 3], List[int], lambda x: x)                        # => [1, 2, 3]\nmatch([1, \"b\", \"a\"], List[int], lambda x: x)                    # => [1, \"b\", \"a\"]\nmatch([\"a\", \"b\", \"c\"], List[int], lambda x: x)                  # raises MatchError\nmatch([\"a\", \"b\", \"c\"], List[Union[str, int]], lambda x: x)      # [\"a\", \"b\", \"c\"]\n\nmatch({\"a\": 1, \"b\": 2}, Dict[str, int], lambda x: x)            # {\"a\": 1, \"b\": 2}\nmatch({\"a\": 1, \"b\": \"dog\"}, Dict[str, int], lambda x: x)        # {\"a\": 1, \"b\": \"dog\"}\nmatch({\"a\": 1, 1: 2}, Dict[str, int], lambda x: x)              # {\"a\": 1, 1: 2}\nmatch({2: 1, 1: 2}, Dict[str, int], lambda x: x)                # raises MatchError\nmatch({2: 1, 1: 2}, Dict[Union[str, int], int], lambda x: x)    # {2: 1, 1: 2}\n```\nIterable generics also match with any of their subtypes.\n```python\nmatch([1, 2, 3], Iterable[int], lambda x: x)                     # => [1, 2, 3]\nmatch({1, 2, 3}, Iterable[int], lambda x: x)                     # => {1, 2, 3}\nmatch(range(10), Iterable[int], lambda x: x)                     # => range(10)\n\nmatch([1, 2, 3], List[int], lambda x: x)                         # => [1, 2, 3]\nmatch({1, 2, 3}, List[int], lambda x: x)                         # => raises MatchError\nmatch(range(10), List[int], lambda x: x)                         # => raises MatchError\n\nmatch([1, 2, 3], Set[int], lambda x: x)                          # => raises MatchError\nmatch({1, 2, 3}, Set[int], lambda x: x)                          # => {1, 2, 3}\nmatch(range(10), Set[int], lambda x: x)                          # => raises MatchError\n```\nFor Callable any arg without annotation treated as Any. \n```python\ndef annotated(a: int, b: int) -> float:\n    pass\n    \ndef not_annotated(a, b):\n    pass\n    \ndef partially_annotated(a, b: float):\n    pass\n\nmatch(annotated, Callable[[int, int], float], lambda x: x)     # => annotated\nmatch(not_annotated, Callable[[int, int], float], lambda x: x) # => raises MatchError\nmatch(not_annotated, Callable[[Any, Any], Any], lambda x: x)   # => not_annotated\nmatch(annotated, Callable[[Any, Any], Any], lambda x: x)       # => raises MatchError\nmatch(partially_annotated, \n    Callable[[Any, float], Any], lambda x: x\n)                                                              # => partially_annotated\n```\nTypeVar is not supported.\n\n## All the things you can match\n\nAs Pattern you can use any Python type, any class, or any Python value.\n\nThe operator `_` and built-in types like `int` or `str`, extract variables that are passed to functions.\n\nTypes and Classes are matched via `instanceof(value, pattern)`.\n\n`Iterable` Patterns match recursively through all their elements.  The same goes for dictionaries.\n\n| Pattern Example | What it means | Matched Example |  Arguments Passed to function | NOT Matched Example |\n| --------------- | --------------| --------------- | ----------------------------- | ------------------ |\n| `\"hello\"` |  only the string `\"hello\"` matches | `\"hello\"` | nothing | any other value |\n| `None` | only `None` | `None` | nothing | any other value |\n| `int` | Any integer | `42` | `42` | any other value |\n| `float` | Any float number | `2.35` | `2.35` | any other value |\n| `str` | Any string | `\"hello\"` | `\"hello\"` | any other value |\n| `tuple` | Any tuple | `(1, 2)` | `(1, 2)` | any other value |\n| `list` | Any list | `[1, 2]` | `[1, 2]` | any other value |\n| `MyClass` | Any instance of MyClass. **And any object that extends MyClass.** | `MyClass()` | that instance | any other object |\n| `_` | Any object (even None) |  | that value | |\n| `ANY` | The same as `_` | | that value | |\n| `(int, int)` | A tuple made of any two integers | `(1, 2)` | `1` and `2` | (True, False) |\n| `[1, 2, _]`  | A list that starts with 1, 2 and ends with any value | `[1, 2, 3]` | `3` | `[1, 2, 3, 4]` |\n| `[1, 2, TAIL]` | A list that start with 1, 2 and ends with any sequence | `[1, 2, 3, 4]`| `[3, 4]` | `[1, 7, 7, 7]` |\n| `{'type':'dog', age: _ }` | Any dict with `type: \"dog\"` and with an age | `{\"type\":\"dog\", \"age\": 3}` | `3` | `{\"type\":\"cat\", \"age\":2}` |\n| `{'type':'dog', age: int }` | Any dict with `type: \"dog\"` and with an `int` age | `{\"type\":\"dog\", \"age\": 3}` | `3` | `{\"type\":\"dog\", \"age\":2.3}` |\n| `re.compile('(\\w+)-(\\w+)-cat$')` | Any string that matches that regular expression expr | `\"my-fuffy-cat\"` | `\"my\"` and `\"puffy\"` | `\"fuffy-dog\"` | \n| `Pet(name=_, age=7)` | Any Pet dataclass with `age == 7` | `Pet('rover', 7)` | `['rover']` | `Pet('rover', 8)` |\n| `Any` | The same as `_` | | that value | |\n| `Union[int, float, None]` | Any integer or float number or None | `2.35` | `2.35` | any other value |\n| `Optional[int]` | The same as `Union[int, None]` | `2` | `2` | any other value |\n| `Type[MyClass]` | Any subclass of MyClass. **And any class that extends MyClass.** | `MyClass` | that class | any other object |\n| `Callable[[int], float]` | Any callable with exactly that signature | `def a(q:int) -> float: ...` | that function | `def a(q) -> float: ...` |\n| `Tuple[MyClass, int, float]` | The same as `(MyClass, int, float)` | | | |\n| `Mapping[str, int]` Any subtype of `Mapping` acceptable too | any mapping or subtype of mapping with string keys and integer values | `{'a': 2, 'b': 3}` | that dict | `{'a': 'b', 'b': 'c'}` |\n| `Iterable[int]` Any subtype of `Iterable` acceptable too | any iterable or subtype of iterable with integer values | `range(10)` and `[1, 2, 3]` | that iterable | `['a', 'b', 'v']` |\n\n\n## Using default\n\nBy default `match()` is strict. If no pattern matches, it raises a `MatchError`.\n\nYou can instead provide a fallback value using `default` to be used when nothing matches.\n\n```\n>>> match([1, 2], [1, 2, 3], \"whatever\")\nMatchError: '_' not provided. This case is not handled: [1, 2]\n\n>>> match([1, 2], [1, 2, 3], \"whatever\", default=False)\nFalse\n```\n\n## Using Regular Expressions\nPampy supports Python's Regex. You can pass a compiled regex as pattern, and Pampy is going to run `pattern.search()`, and then pass to the action function the result of `.groups()`.\n\n```python \ndef what_is(pet):\n    return match(pet,\n        re.compile('(\\w+)-(\\w+)-cat$'),     lambda name, my: 'cat '+name,\n        re.compile('(\\w+)-(\\w+)-dog$'),     lambda name, my: 'dog '+name,\n        _,                                  \"something else\"\n    )\n\nwhat_is('fuffy-my-dog')     # => 'dog fuffy'\nwhat_is('puffy-her-dog')    # => 'dog puffy'\nwhat_is('carla-your-cat')   # => 'cat carla'\nwhat_is('roger-my-hamster') # => 'something else'\n```\n\n## Install for Python3\n\nPampy works in Python >= 3.6 [Because dict matching can work only in the latest Pythons](https://mail.python.org/pipermail/python-dev/2017-December/151283.html).\n\nTo install it:\n\n```$ pip install pampy```\n\nor\n```$ pip3 install pampy```\n\n## If you really must use Python2\nPampy is Python3-first, but you can use most of its features in Python2 via [this backport](https://pypi.org/project/backports.pampy/) by Manuel Barkhau:\n\n```pip install backports.pampy```\n\n```python\nfrom backports.pampy import match, HEAD, TAIL, _\n```\n\n"
        },
        {
          "name": "imgs",
          "type": "tree",
          "content": null
        },
        {
          "name": "pampy",
          "type": "tree",
          "content": null
        },
        {
          "name": "setup.py",
          "type": "blob",
          "size": 0.7021484375,
          "content": "import setuptools\n\nfrom pampy import __version__\n\nwith open(\"README.md\", \"r\") as fh:\n    long_description = fh.read()\n\nsetuptools.setup(\n    name=\"pampy\",\n    version=__version__,\n    author=\"Claudio Santini\",\n    author_email=\"hireclaudio@gmail.com\",\n    description=\"The Pattern Matching for Python you always dreamed of\",\n    long_description=long_description,\n    long_description_content_type=\"text/markdown\",\n    url=\"https://github.com/santinic/pampy\",\n    packages=setuptools.find_packages(),\n    platforms='any',\n    classifiers=[\n        \"Programming Language :: Python :: 3\",\n        \"License :: OSI Approved :: MIT License\",\n        \"Operating System :: OS Independent\",\n    ],\n    python_requires='>3.6'\n)\n"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}