{
  "metadata": {
    "timestamp": 1736559492114,
    "page": 66,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjcw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "mzucker/noteshrink",
      "stars": 4814,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0517578125,
          "content": ".DS_Store\n*~\nnogit/*\n*.pyc\nweek*\noutput.pdf\npage*png\n"
        },
        {
          "name": "LICENSE.txt",
          "type": "blob",
          "size": 1.0439453125,
          "content": "MIT License\n\nCopyright (c) 2016, Matt Zucker\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 0.69140625,
          "content": "noteshrink\n==========\n\nConvert scans of handwritten notes to beautiful, compact PDFs -- see full writeup at <https://mzucker.github.io/2016/09/20/noteshrink.html>\n\n## Requirements\n\n - Python 2 or 3\n - NumPy 1.10 or later\n - SciPy\n - ImageMagick\n - Image module from PIL or Pillow\n\n## Usage\n\n```\n./noteshrink.py IMAGE1 [IMAGE2 ...]\n```\n\nBuilding the examples (already in `example_output`):\n\n```\nmake\n```\n\n## Packages\nPackages are available for:\n - [Arch Linux (AUR)](https://aur.archlinux.org/packages/noteshrink/)\n \n## Derived works\n\n*Note:* Projects listed here aren't necessarily tested or endorsed by me -- use with care!\n\n  - [Web-based (Django) front-end](https://github.com/delneg/noteshrinker-django)\n"
        },
        {
          "name": "example_output",
          "type": "tree",
          "content": null
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "makefile",
          "type": "blob",
          "size": 0.8896484375,
          "content": "all: example_output/notesA.pdf \\\n\texample_output/notesB.pdf \\\n\texample_output/tree.pdf \\\n\texample_output/graph-paper-ink-only.pdf\n\n\n\nexample_output/notesA.pdf: examples/notesA1.jpg examples/notesA2.jpg\n\tmkdir -p example_output && \\\n\tcd example_output && \\\n\t../noteshrink.py -O -g -w -s 20 -v 30 -o notesA.pdf ../examples/notesA*.jpg\n\nexample_output/notesB.pdf: examples/notesB1.jpg examples/notesB2.jpg\n\tmkdir -p example_output && \\\n\tcd example_output && \\\n\t../noteshrink.py -O -g -w -s 4.5 -v 30 -o notesB.pdf ../examples/notesB*.jpg\n\nexample_output/tree.pdf: examples/tree.jpg\n\tmkdir -p example_output && \\\n\tcd example_output && \\\n\t../noteshrink.py -O -w -o tree.pdf ../examples/tree.jpg\n\nexample_output/graph-paper-ink-only.pdf: examples/graph-paper-ink-only.jpg\n\tmkdir -p example_output && \\\n\tcd example_output && \\\n\t../noteshrink.py -O -v 5 -o graph-paper-ink-only.pdf ../examples/graph-paper-ink-only.jpg\n"
        },
        {
          "name": "noteshrink.py",
          "type": "blob",
          "size": 16.4951171875,
          "content": "#!/usr/bin/env python\n\n'''Converts sequence of images to compact PDF while removing speckles,\nbleedthrough, etc.\n\n'''\n\n# for some reason pylint complains about members being undefined :(\n# pylint: disable=E1101\n\nfrom __future__ import print_function\n\nimport sys\nimport os\nimport re\nimport subprocess\nimport shlex\n\nfrom argparse import ArgumentParser\n\nimport numpy as np\nfrom PIL import Image\nfrom scipy.cluster.vq import kmeans, vq\n\n######################################################################\n\ndef quantize(image, bits_per_channel=None):\n\n    '''Reduces the number of bits per channel in the given image.'''\n\n    if bits_per_channel is None:\n        bits_per_channel = 6\n\n    assert image.dtype == np.uint8\n\n    shift = 8-bits_per_channel\n    halfbin = (1 << shift) >> 1\n\n    return ((image.astype(int) >> shift) << shift) + halfbin\n\n######################################################################\n\ndef pack_rgb(rgb):\n\n    '''Packs a 24-bit RGB triples into a single integer,\nworks on both arrays and tuples.'''\n\n    orig_shape = None\n\n    if isinstance(rgb, np.ndarray):\n        assert rgb.shape[-1] == 3\n        orig_shape = rgb.shape[:-1]\n    else:\n        assert len(rgb) == 3\n        rgb = np.array(rgb)\n\n    rgb = rgb.astype(int).reshape((-1, 3))\n\n    packed = (rgb[:, 0] << 16 |\n              rgb[:, 1] << 8 |\n              rgb[:, 2])\n\n    if orig_shape is None:\n        return packed\n    else:\n        return packed.reshape(orig_shape)\n\n######################################################################\n\ndef unpack_rgb(packed):\n\n    '''Unpacks a single integer or array of integers into one or more\n24-bit RGB values.\n\n    '''\n\n    orig_shape = None\n\n    if isinstance(packed, np.ndarray):\n        assert packed.dtype == int\n        orig_shape = packed.shape\n        packed = packed.reshape((-1, 1))\n\n    rgb = ((packed >> 16) & 0xff,\n           (packed >> 8) & 0xff,\n           (packed) & 0xff)\n\n    if orig_shape is None:\n        return rgb\n    else:\n        return np.hstack(rgb).reshape(orig_shape + (3,))\n\n######################################################################\n\ndef get_bg_color(image, bits_per_channel=None):\n\n    '''Obtains the background color from an image or array of RGB colors\nby grouping similar colors into bins and finding the most frequent\none.\n\n    '''\n\n    assert image.shape[-1] == 3\n\n    quantized = quantize(image, bits_per_channel).astype(int)\n    packed = pack_rgb(quantized)\n\n    unique, counts = np.unique(packed, return_counts=True)\n\n    packed_mode = unique[counts.argmax()]\n\n    return unpack_rgb(packed_mode)\n\n######################################################################\n\ndef rgb_to_sv(rgb):\n\n    '''Convert an RGB image or array of RGB colors to saturation and\nvalue, returning each one as a separate 32-bit floating point array or\nvalue.\n\n    '''\n\n    if not isinstance(rgb, np.ndarray):\n        rgb = np.array(rgb)\n\n    axis = len(rgb.shape)-1\n    cmax = rgb.max(axis=axis).astype(np.float32)\n    cmin = rgb.min(axis=axis).astype(np.float32)\n    delta = cmax - cmin\n\n    saturation = delta.astype(np.float32) / cmax.astype(np.float32)\n    saturation = np.where(cmax == 0, 0, saturation)\n\n    value = cmax/255.0\n\n    return saturation, value\n\n######################################################################\n\ndef postprocess(output_filename, options):\n\n    '''Runs the postprocessing command on the file provided.'''\n\n    assert options.postprocess_cmd\n\n    base, _ = os.path.splitext(output_filename)\n    post_filename = base + options.postprocess_ext\n\n    cmd = options.postprocess_cmd\n    cmd = cmd.replace('%i', output_filename)\n    cmd = cmd.replace('%o', post_filename)\n    cmd = cmd.replace('%e', options.postprocess_ext)\n\n    subprocess_args = shlex.split(cmd)\n\n    if os.path.exists(post_filename):\n        os.unlink(post_filename)\n\n    if not options.quiet:\n        print('  running \"{}\"...'.format(cmd), end=' ')\n        sys.stdout.flush()\n\n    try:\n        result = subprocess.call(subprocess_args)\n        before = os.stat(output_filename).st_size\n        after = os.stat(post_filename).st_size\n    except OSError:\n        result = -1\n\n    if result == 0:\n\n        if not options.quiet:\n            print('{:.1f}% reduction'.format(\n                100*(1.0-float(after)/before)))\n\n        return post_filename\n\n    else:\n\n        sys.stderr.write('warning: postprocessing failed!\\n')\n        return None\n\n######################################################################\n\ndef percent(string):\n    '''Convert a string (i.e. 85) to a fraction (i.e. .85).'''\n    return float(string)/100.0\n\n######################################################################\n\ndef get_argument_parser():\n\n    '''Parse the command-line arguments for this program.'''\n\n    parser = ArgumentParser(\n        description='convert scanned, hand-written notes to PDF')\n\n    show_default = ' (default %(default)s)'\n\n    parser.add_argument('filenames', metavar='IMAGE', nargs='+',\n                        help='files to convert')\n\n    parser.add_argument('-q', dest='quiet', action='store_true',\n                        default=False,\n                        help='reduce program output')\n\n    parser.add_argument('-b', dest='basename', metavar='BASENAME',\n                        default='page',\n                        help='output PNG filename base' + show_default)\n\n    parser.add_argument('-o', dest='pdfname', metavar='PDF',\n                        default='output.pdf',\n                        help='output PDF filename' + show_default)\n\n    parser.add_argument('-v', dest='value_threshold', metavar='PERCENT',\n                        type=percent, default='25',\n                        help='background value threshold %%'+show_default)\n\n    parser.add_argument('-s', dest='sat_threshold', metavar='PERCENT',\n                        type=percent, default='20',\n                        help='background saturation '\n                        'threshold %%'+show_default)\n\n    parser.add_argument('-n', dest='num_colors', type=int,\n                        default='8',\n                        help='number of output colors '+show_default)\n\n    parser.add_argument('-p', dest='sample_fraction',\n                        metavar='PERCENT',\n                        type=percent, default='5',\n                        help='%% of pixels to sample' + show_default)\n\n    parser.add_argument('-w', dest='white_bg', action='store_true',\n                        default=False, help='make background white')\n\n    parser.add_argument('-g', dest='global_palette',\n                        action='store_true', default=False,\n                        help='use one global palette for all pages')\n\n    parser.add_argument('-S', dest='saturate', action='store_false',\n                        default=True, help='do not saturate colors')\n\n    parser.add_argument('-K', dest='sort_numerically',\n                        action='store_false', default=True,\n                        help='keep filenames ordered as specified; '\n                        'use if you *really* want IMG_10.png to '\n                        'precede IMG_2.png')\n\n    parser.add_argument('-P', dest='postprocess_cmd', default=None,\n                        help='set postprocessing command (see -O, -C, -Q)')\n\n    parser.add_argument('-e', dest='postprocess_ext',\n                        default='_post.png',\n                        help='filename suffix/extension for '\n                        'postprocessing command')\n\n    parser.add_argument('-O', dest='postprocess_cmd',\n                        action='store_const',\n                        const='optipng -silent %i -out %o',\n                        help='same as -P \"%(const)s\"')\n\n    parser.add_argument('-C', dest='postprocess_cmd',\n                        action='store_const',\n                        const='pngcrush -q %i %o',\n                        help='same as -P \"%(const)s\"')\n\n    parser.add_argument('-Q', dest='postprocess_cmd',\n                        action='store_const',\n                        const='pngquant --ext %e %i',\n                        help='same as -P \"%(const)s\"')\n\n    parser.add_argument('-c', dest='pdf_cmd', metavar=\"COMMAND\",\n                        default='convert %i %o',\n                        help='PDF command (default \"%(default)s\")')\n\n    return parser\n\n######################################################################\n\ndef get_filenames(options):\n\n    '''Get the filenames from the command line, optionally sorted by\nnumber, so that IMG_10.png is re-arranged to come after IMG_9.png.\nThis is a nice feature because some scanner programs (like Image\nCapture on Mac OS X) automatically number files without leading zeros,\nand this way you can supply files using a wildcard and still have the\npages ordered correctly.\n\n    '''\n\n    if not options.sort_numerically:\n        return options.filenames\n\n    filenames = []\n\n    for filename in options.filenames:\n        basename = os.path.basename(filename)\n        root, _ = os.path.splitext(basename)\n        matches = re.findall(r'[0-9]+', root)\n        if matches:\n            num = int(matches[-1])\n        else:\n            num = -1\n        filenames.append((num, filename))\n\n    return [fn for (_, fn) in sorted(filenames)]\n\n######################################################################\n\ndef load(input_filename):\n\n    '''Load an image with Pillow and convert it to numpy array. Also\nreturns the image DPI in x and y as a tuple.'''\n\n    try:\n        pil_img = Image.open(input_filename)\n    except IOError:\n        sys.stderr.write('warning: error opening {}\\n'.format(\n            input_filename))\n        return None, None\n\n    if pil_img.mode != 'RGB':\n        pil_img = pil_img.convert('RGB')\n\n    if 'dpi' in pil_img.info:\n        dpi = pil_img.info['dpi']\n    else:\n        dpi = (300, 300)\n\n    img = np.array(pil_img)\n\n    return img, dpi\n\n######################################################################\n\ndef sample_pixels(img, options):\n\n    '''Pick a fixed percentage of pixels in the image, returned in random\norder.'''\n\n    pixels = img.reshape((-1, 3))\n    num_pixels = pixels.shape[0]\n    num_samples = int(num_pixels*options.sample_fraction)\n\n    idx = np.arange(num_pixels)\n    np.random.shuffle(idx)\n\n    return pixels[idx[:num_samples]]\n\n######################################################################\n\ndef get_fg_mask(bg_color, samples, options):\n\n    '''Determine whether each pixel in a set of samples is foreground by\ncomparing it to the background color. A pixel is classified as a\nforeground pixel if either its value or saturation differs from the\nbackground by a threshold.'''\n\n    s_bg, v_bg = rgb_to_sv(bg_color)\n    s_samples, v_samples = rgb_to_sv(samples)\n\n    s_diff = np.abs(s_bg - s_samples)\n    v_diff = np.abs(v_bg - v_samples)\n\n    return ((v_diff >= options.value_threshold) |\n            (s_diff >= options.sat_threshold))\n\n######################################################################\n\ndef get_palette(samples, options, return_mask=False, kmeans_iter=40):\n\n    '''Extract the palette for the set of sampled RGB values. The first\npalette entry is always the background color; the rest are determined\nfrom foreground pixels by running K-means clustering. Returns the\npalette, as well as a mask corresponding to the foreground pixels.\n\n    '''\n\n    if not options.quiet:\n        print('  getting palette...')\n\n    bg_color = get_bg_color(samples, 6)\n\n    fg_mask = get_fg_mask(bg_color, samples, options)\n\n    centers, _ = kmeans(samples[fg_mask].astype(np.float32),\n                        options.num_colors-1,\n                        iter=kmeans_iter)\n\n    palette = np.vstack((bg_color, centers)).astype(np.uint8)\n\n    if not return_mask:\n        return palette\n    else:\n        return palette, fg_mask\n\n######################################################################\n\ndef apply_palette(img, palette, options):\n\n    '''Apply the pallete to the given image. The first step is to set all\nbackground pixels to the background color; then, nearest-neighbor\nmatching is used to map each foreground color to the closest one in\nthe palette.\n\n    '''\n\n    if not options.quiet:\n        print('  applying palette...')\n\n    bg_color = palette[0]\n\n    fg_mask = get_fg_mask(bg_color, img, options)\n\n    orig_shape = img.shape\n\n    pixels = img.reshape((-1, 3))\n    fg_mask = fg_mask.flatten()\n\n    num_pixels = pixels.shape[0]\n\n    labels = np.zeros(num_pixels, dtype=np.uint8)\n\n    labels[fg_mask], _ = vq(pixels[fg_mask], palette)\n\n    return labels.reshape(orig_shape[:-1])\n\n######################################################################\n\ndef save(output_filename, labels, palette, dpi, options):\n\n    '''Save the label/palette pair out as an indexed PNG image.  This\noptionally saturates the pallete by mapping the smallest color\ncomponent to zero and the largest one to 255, and also optionally sets\nthe background color to pure white.\n\n    '''\n\n    if not options.quiet:\n        print('  saving {}...'.format(output_filename))\n\n    if options.saturate:\n        palette = palette.astype(np.float32)\n        pmin = palette.min()\n        pmax = palette.max()\n        palette = 255 * (palette - pmin)/(pmax-pmin)\n        palette = palette.astype(np.uint8)\n\n    if options.white_bg:\n        palette = palette.copy()\n        palette[0] = (255, 255, 255)\n\n    output_img = Image.fromarray(labels, 'P')\n    output_img.putpalette(palette.flatten())\n    output_img.save(output_filename, dpi=dpi)\n\n######################################################################\n\ndef get_global_palette(filenames, options):\n\n    '''Fetch the global palette for a series of input files by merging\ntheir samples together into one large array.\n\n    '''\n\n    input_filenames = []\n\n    all_samples = []\n\n    if not options.quiet:\n        print('building global palette...')\n\n    for input_filename in filenames:\n\n        img, _ = load(input_filename)\n        if img is None:\n            continue\n\n        if not options.quiet:\n            print('  processing {}...'.format(input_filename))\n\n        samples = sample_pixels(img, options)\n        input_filenames.append(input_filename)\n        all_samples.append(samples)\n\n    num_inputs = len(input_filenames)\n\n    all_samples = [s[:int(round(float(s.shape[0])/num_inputs))]\n                   for s in all_samples]\n\n    all_samples = np.vstack(tuple(all_samples))\n\n    global_palette = get_palette(all_samples, options)\n\n    if not options.quiet:\n        print('  done\\n')\n\n    return input_filenames, global_palette\n\n######################################################################\n\ndef emit_pdf(outputs, options):\n\n    '''Runs the PDF conversion command to generate the PDF.'''\n\n    cmd = options.pdf_cmd\n    cmd = cmd.replace('%o', options.pdfname)\n    if len(outputs) > 2:\n        cmd_print = cmd.replace('%i', ' '.join(outputs[:2] + ['...']))\n    else:\n        cmd_print = cmd.replace('%i', ' '.join(outputs))\n    cmd = cmd.replace('%i', ' '.join(outputs))\n\n    if not options.quiet:\n        print('running PDF command \"{}\"...'.format(cmd_print))\n\n    try:\n        result = subprocess.call(shlex.split(cmd))\n    except OSError:\n        result = -1\n\n    if result == 0:\n        if not options.quiet:\n            print('  wrote', options.pdfname)\n    else:\n        sys.stderr.write('warning: PDF command failed\\n')\n\n######################################################################\n\ndef notescan_main(options):\n\n    '''Main function for this program when run as script.'''\n\n    filenames = get_filenames(options)\n\n    outputs = []\n\n    do_global = options.global_palette and len(filenames) > 1\n\n    if do_global:\n        filenames, palette = get_global_palette(filenames, options)\n\n    do_postprocess = bool(options.postprocess_cmd)\n\n    for input_filename in filenames:\n\n        img, dpi = load(input_filename)\n        if img is None:\n            continue\n\n        output_filename = '{}{:04d}.png'.format(\n            options.basename, len(outputs))\n\n        if not options.quiet:\n            print('opened', input_filename)\n\n        if not do_global:\n            samples = sample_pixels(img, options)\n            palette = get_palette(samples, options)\n\n        labels = apply_palette(img, palette, options)\n\n        save(output_filename, labels, palette, dpi, options)\n\n        if do_postprocess:\n            post_filename = postprocess(output_filename, options)\n            if post_filename:\n                output_filename = post_filename\n            else:\n                do_postprocess = False\n\n        outputs.append(output_filename)\n\n        if not options.quiet:\n            print('  done\\n')\n\n    emit_pdf(outputs, options)\n\n######################################################################\n\ndef main():\n    '''Parse args and call notescan_main().'''\n    notescan_main(options=get_argument_parser().parse_args())\n\nif __name__ == '__main__':\n    main()\n"
        },
        {
          "name": "requirements.txt",
          "type": "blob",
          "size": 0.0341796875,
          "content": "noteshrink\nnumpy>=1.10\nscipy\nImage\n"
        },
        {
          "name": "setup.py",
          "type": "blob",
          "size": 0.8037109375,
          "content": "#!/usr/bin/env python\nfrom __future__ import print_function\n\nimport os\nimport sys\nfrom setuptools import setup\n\n\nif sys.argv[-1] == \"publish\":\n    os.system(\"python setup.py sdist upload\")\n    os.system(\"python setup.py bdist_wheel upload\")\n    print(\"You probably want to also tag the version now:\")\n    print(\"  git tag -a VERSION -m 'version VERSION'\")\n    print(\"  git push --tags\")\n    sys.exit()\n\nsetup(\n    name=\"noteshrink\",\n    version=\"0.1.1\",\n    author=\"Matt Zucker\",\n    description=\"Convert scans of handwritten notes to beautiful, compact PDFs\",\n    url=\"https://github.com/mzucker/noteshrink\",\n    py_modules=[\"noteshrink\"],\n    install_requires=[\n        \"numpy>=1.1.0\",\n        \"scipy\",\n        \"pillow\",\n    ],\n    entry_points=\"\"\"\n        [console_scripts]\n        noteshrink=noteshrink:main\n    \"\"\",\n)\n"
        }
      ]
    }
  ]
}