{
  "metadata": {
    "timestamp": 1736559577123,
    "page": 197,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjIwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "spyoungtech/grequests",
      "stars": 4507,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.146484375,
          "content": ".coverage\nMANIFEST\ncoverage.xml\njunit-report.xml\npylint.txt\ntoy.py\nviolations.pyflakes.txt\ncover/\ndocs/_build\ngrequests.egg-info/\n*.py[cx]\n*.swp\nenv/\n"
        },
        {
          "name": "AUTHORS.rst",
          "type": "blob",
          "size": 1.169921875,
          "content": "GRequests is authored by Kenneth Reitz, maintained by Spencer Young and \nvarious contributors:\n\nDevelopment Leads\n`````````````````\n\n- Spencer Phillip Young <spencer.young@spyoung.com>\n- Kenneth Reitz <me@kennethreitz.com>\n\nPatches and Suggestions\n```````````````````````\n\nAdam Tauber <asciimoo@gmail.com>\nAkshat Mahajan <akshatm.bkk@gmail.com>\nAlexander Simeonov <agsimeonov@gmail.com>\nAntonio A <andrade.antonio@gmail.com>\nChris Drackett <chris@drackett.com>\nEugene Eeo <packwolf58@gmail.com>\nFrost Ming <mianghong@gmail.com>\nIan Cordasco <icordasc+github@coglib.com>\nJoe Gordon <jogo@pinterest.com>\nLuke Hutscal <luke@creaturecreative.com>\nMarc Abramowitz <marc@marc-abramowitz.com>\nMathieu Lecarme <mlecarme@bearstech.com>\nMichael Newman <newmaniese@gmail.com>\nMircea Ulinic <mirceaulinic@users.noreply.github.com>\nNate Lawson <nate@root.org>\nNathan Hoad <nathan@getoffmalawn.com>\nRoman Haritonov <reclosedev@gmail.com>\nRyan T. Dean <ryand@netflix.com>\nSpencer Phillip Young <spencer.young@spyoung.com>\nSpencer Young <spencer.young@spyoung.com>\nYuri Prezument <y@yprez.com>\nkoobs <koobs@users.noreply.github.com>\nkracekumar <kracethekingmaker@gmail.com>\nÂ¥îÂ∫ÜÊâç‰∏®ÈùôËßÖ <cqc@cuiqingcai.com>\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.2529296875,
          "content": "Copyright (c) 2012, Kenneth Reitz\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\nRedistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
        },
        {
          "name": "MANIFEST.in",
          "type": "blob",
          "size": 0.0341796875,
          "content": "include LICENSE\ninclude README.rst\n"
        },
        {
          "name": "README.rst",
          "type": "blob",
          "size": 3.982421875,
          "content": "GRequests: Asynchronous Requests\n===============================\n\nGRequests allows you to use Requests with Gevent to make asynchronous HTTP\nRequests easily.\n\n|version| |pyversions|\n\n\n\nInstallation\n------------\n\nInstallation is easy with pip::\n\n    $ pip install grequests\n    ‚ú®üç∞‚ú®\n\n\nUsage\n-----\n\nUsage is simple:\n\n.. code-block:: python\n\n    import grequests\n\n    urls = [\n        'http://www.heroku.com',\n        'http://python-tablib.org',\n        'http://httpbin.org',\n        'http://python-requests.org',\n        'http://fakedomain/',\n        'http://kennethreitz.com'\n    ]\n\nCreate a set of unsent Requests:\n\n.. code-block:: python\n\n    >>> rs = (grequests.get(u) for u in urls)\n\nSend them all at the same time using ``map``:\n\n.. code-block:: python\n\n    >>> grequests.map(rs)\n    [<Response [200]>, <Response [200]>, <Response [200]>, <Response [200]>, None, <Response [200]>]\n\n\nThe HTTP verb methods in ``grequests`` (e.g., ``grequests.get``, ``grequests.post``, etc.) accept all the same keyword arguments as in the ``requests`` library.\n\nError Handling\n^^^^^^^^^^^^^^\n\nTo handle timeouts or any other exception during the connection of\nthe request, you can add an optional exception handler that will be called with the request and\nexception inside the main thread. The value returned by your exception handler will be used in the result list returned by ``map``.\n\n\n.. code-block:: python\n\n    >>> def exception_handler(request, exception):\n    ...    print(\"Request failed\")\n\n    >>> reqs = [\n    ...    grequests.get('http://httpbin.org/delay/1', timeout=0.001),\n    ...    grequests.get('http://fakedomain/'),\n    ...    grequests.get('http://httpbin.org/status/500')]\n    >>> grequests.map(reqs, exception_handler=exception_handler)\n    Request failed\n    Request failed\n    [None, None, <Response [500]>]\n\n\nimap\n^^^^\n\nFor some speed/performance gains, you may also want to use ``imap`` instead of ``map``. ``imap`` returns a generator of responses. Order of these responses does not map to the order of the requests you send out. The API for ``imap`` is equivalent to the API for ``map``. You can also adjust the ``size`` argument to ``map`` or ``imap`` to increase the gevent pool size.\n\n\n.. code-block:: python\n\n    for resp in grequests.imap(reqs, size=10):\n        print(resp)\n\n\nThere is also an enumerated version of ``imap``, ``imap_enumerated`` which yields the index of the request from the original request list and its associated response. However, unlike ``imap``, failed requests and exception handler results that return ``None`` will also be yielded (whereas in ``imap`` they are ignored). Aditionally, the ``requests`` parameter for ``imap_enumerated`` must be a sequence. Like in ``imap``, the order in which requests are sent and received should still be considered arbitrary.\n\n.. code-block:: python\n\n    >>> rs = [grequests.get(f'https://httpbin.org/status/{code}') for code in range(200, 206)]\n    >>> for index, response in grequests.imap_enumerated(rs, size=5):\n    ...     print(index, response)\n    1 <Response [201]>\n    0 <Response [200]>\n    4 <Response [204]>\n    2 <Response [202]>\n    5 <Response [205]>\n    3 <Response [203]>\n\ngevent - when things go wrong\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nBecause ``grequests`` leverages ``gevent`` (which in turn uses monkeypatching for enabling concurrency), you will often need to make sure ``grequests`` is imported before other libraries, especially ``requests``, to avoid problems. See `grequests gevent issues <https://github.com/spyoungtech/grequests/issues?q=is%3Aissue+label%3A%22%3Ahear_no_evil%3A%3Asee_no_evil%3A%3Aspeak_no_evil%3A++gevent%22+>`_ for additional information.\n\n\n.. code-block:: python\n\n    # GOOD\n    import grequests\n    import requests\n    \n    # BAD\n    import requests\n    import grequests\n\n\n\n\n\n\n\n.. |version| image:: https://img.shields.io/pypi/v/grequests.svg?colorB=blue\n    :target: https://pypi.org/project/grequests/\n\n.. |pyversions| image:: https://img.shields.io/pypi/pyversions/grequests.svg?\n    :target: https://pypi.org/project/grequests/\n    \n    \n"
        },
        {
          "name": "grequests.py",
          "type": "blob",
          "size": 7.267578125,
          "content": "# -*- coding: utf-8 -*-\n\n\"\"\"\ngrequests\n~~~~~~~~~\n\nThis module contains an asynchronous replica of ``requests.api``, powered\nby gevent. All API methods return a ``Request`` instance (as opposed to\n``Response``). A list of requests can be sent with ``map()``.\n\"\"\"\nfrom functools import partial\nimport traceback\n\ntry:\n    import gevent\n    from gevent import monkey as curious_george\n    from gevent.pool import Pool\nexcept ImportError:\n    raise RuntimeError('Gevent is required for grequests.')\n\n# Monkey-patch.\ncurious_george.patch_all(thread=False, select=False)\n\nfrom requests import Session\n\n__all__ = (\n    'map', 'imap',\n    'get', 'options', 'head', 'post', 'put', 'patch', 'delete', 'request'\n)\n\n\nclass AsyncRequest(object):\n    \"\"\" Asynchronous request.\n\n    Accept same parameters as ``Session.request`` and some additional:\n\n    :param session: Session which will do request\n    :param callback: Callback called on response.\n                     Same as passing ``hooks={'response': callback}``\n    \"\"\"\n    def __init__(self, method, url, **kwargs):\n        #: Request method\n        self.method = method\n        #: URL to request\n        self.url = url\n        #: Associated ``Session``\n        self.session = kwargs.pop('session', None)\n        if self.session is None:\n            self.session = Session()\n            self._close = True\n        else:\n            self._close = False  # don't close adapters after each request if the user provided the session\n\n        callback = kwargs.pop('callback', None)\n        if callback:\n            kwargs['hooks'] = {'response': callback}\n\n        #: The rest arguments for ``Session.request``\n        self.kwargs = kwargs\n        #: Resulting ``Response``\n        self.response = None\n\n    def send(self, **kwargs):\n        \"\"\"\n        Prepares request based on parameter passed to constructor and optional ``kwargs```.\n        Then sends request and saves response to :attr:`response`\n\n        :returns: ``Response``\n        \"\"\"\n        merged_kwargs = {}\n        merged_kwargs.update(self.kwargs)\n        merged_kwargs.update(kwargs)\n        try:\n            self.response = self.session.request(self.method,\n                                                self.url, **merged_kwargs)\n        except Exception as e:\n            self.exception = e\n            self.traceback = traceback.format_exc()\n        finally:\n            if self._close:\n                # if we provided the session object, make sure we're cleaning up\n                # because there's no sense in keeping it open at this point if it wont be reused\n                self.session.close()\n        return self\n\n\ndef send(r, pool=None, stream=False):\n    \"\"\"Sends the request object using the specified pool. If a pool isn't\n    specified this method blocks. Pools are useful because you can specify size\n    and can hence limit concurrency.\"\"\"\n    if pool is not None:\n        return pool.spawn(r.send, stream=stream)\n\n    return gevent.spawn(r.send, stream=stream)\n\n\n# Shortcuts for creating AsyncRequest with appropriate HTTP method\nget = partial(AsyncRequest, 'GET')\noptions = partial(AsyncRequest, 'OPTIONS')\nhead = partial(AsyncRequest, 'HEAD')\npost = partial(AsyncRequest, 'POST')\nput = partial(AsyncRequest, 'PUT')\npatch = partial(AsyncRequest, 'PATCH')\ndelete = partial(AsyncRequest, 'DELETE')\n\n# synonym\ndef request(method, url, **kwargs):\n    return AsyncRequest(method, url, **kwargs)\n\n\ndef map(requests, stream=False, size=None, exception_handler=None, gtimeout=None):\n    \"\"\"Concurrently converts a list of Requests to Responses.\n\n    :param requests: a collection of Request objects.\n    :param stream: If True, the content will not be downloaded immediately.\n    :param size: Specifies the number of requests to make at a time. If None, no throttling occurs.\n    :param exception_handler: Callback function, called when exception occured. Params: Request, Exception\n    :param gtimeout: Gevent joinall timeout in seconds. (Note: unrelated to requests timeout)\n    \"\"\"\n\n    requests = list(requests)\n\n    pool = Pool(size) if size else None\n    jobs = [send(r, pool, stream=stream) for r in requests]\n    gevent.joinall(jobs, timeout=gtimeout)\n\n    ret = []\n\n    for request in requests:\n        if request.response is not None:\n            ret.append(request.response)\n        elif exception_handler and hasattr(request, 'exception'):\n            ret.append(exception_handler(request, request.exception))\n        elif exception_handler and not hasattr(request, 'exception'):\n            ret.append(exception_handler(request, None))\n        else:\n            ret.append(None)\n\n    return ret\n\n\ndef imap(requests, stream=False, size=2, exception_handler=None):\n    \"\"\"Concurrently converts a generator object of Requests to\n    a generator of Responses.\n\n    :param requests: a generator of Request objects.\n    :param stream: If True, the content will not be downloaded immediately.\n    :param size: Specifies the number of requests to make at a time. default is 2\n    :param exception_handler: Callback function, called when exception occurred. Params: Request, Exception\n    \"\"\"\n\n    pool = Pool(size)\n\n    def send(r):\n        return r.send(stream=stream)\n\n    for request in pool.imap_unordered(send, requests):\n        if request.response is not None:\n            yield request.response\n        elif exception_handler:\n            ex_result = exception_handler(request, request.exception)\n            if ex_result is not None:\n                yield ex_result\n\n    pool.join()\n\n\ndef imap_enumerated(requests, stream=False, size=2, exception_handler=None):\n    \"\"\"\n    Like imap, but yields tuple of original request index and response object\n\n    Unlike imap, failed results and responses from exception handlers that return None are not ignored. Instead, a\n    tuple of (index, None) is yielded. Additionally, the ``requests`` parameter must be a sequence of Request objects\n    (generators or other non-sequence iterables are not allowed)\n\n    The index is merely the original index of the original request in the requests list and does NOT provide any\n    indication of the order in which requests or responses are sent or received. Responses are still in arbitrary order.\n\n    ::\n        >>> rs = [grequests.get(f'https://httpbin.org/status/{i}') for i in range(200, 206)]\n        >>> for index, response in grequests.imap_enumerated(rs, size=5):\n        ...     print(index, response)\n        1 <Response [201]>\n        0 <Response [200]>\n        4 <Response [204]>\n        2 <Response [202]>\n        5 <Response [205]>\n        3 <Response [203]>\n\n\n    :param requests: a sequence of Request objects.\n    :param stream: If True, the content will not be downloaded immediately.\n    :param size: Specifies the number of requests to make at a time. default is 2\n    :param exception_handler: Callback function, called when exception occurred. Params: Request, Exception\n    \"\"\"\n\n    pool = Pool(size)\n\n    def send(r):\n        return r._index, r.send(stream=stream)\n\n    requests = list(requests)\n    for index, req in enumerate(requests):\n        req._index = index\n\n    for index, request in pool.imap_unordered(send, requests):\n        if request.response is not None:\n            yield index, request.response\n        elif exception_handler:\n            ex_result = exception_handler(request, request.exception)\n            yield index, ex_result\n        else:\n            yield index, None\n"
        },
        {
          "name": "requirements.txt",
          "type": "blob",
          "size": 0.0224609375,
          "content": "requests\ngevent\npytest\n"
        },
        {
          "name": "setup.py",
          "type": "blob",
          "size": 1.5283203125,
          "content": "# -*- coding: utf-8 -*-\n\"\"\"\nGRequests allows you to use Requests with Gevent to make asynchronous HTTP\nRequests easily.\n\nUsage\n-----\n\nUsage is simple::\n\n    import grequests\n\n    urls = [\n        'http://www.heroku.com',\n        'http://tablib.org',\n        'http://httpbin.org',\n        'http://python-requests.org',\n        'http://kennethreitz.com'\n    ]\n\nCreate a set of unsent Requests::\n\n    >>> rs = (grequests.get(u) for u in urls)\n\nSend them all at the same time::\n\n    >>> grequests.map(rs)\n    [<Response [200]>, <Response [200]>, <Response [200]>, <Response [200]>, <Response [200]>]\n\n\"\"\"\n\nfrom setuptools import setup\n\nsetup(\n    name='grequests',\n    version='0.7.0',\n    url='https://github.com/spyoungtech/grequests',\n    license='BSD',\n    author='Kenneth Reitz',\n    author_email='me@kennethreitz.com',\n    description='Requests + Gevent',\n    long_description=__doc__,\n    install_requires=[\n        'gevent',\n        'requests'\n    ],\n    tests_require = ['pytest'],\n    py_modules=['grequests'],\n    zip_safe=False,\n    include_package_data=True,\n    platforms='any',\n    classifiers=[\n        'Environment :: Web Environment',\n        'Intended Audience :: Developers',\n        'License :: OSI Approved :: BSD License',\n        'Operating System :: OS Independent',\n        'Programming Language :: Python',\n        'Programming Language :: Python :: 2.7',\n        'Programming Language :: Python :: 3',\n        'Topic :: Internet :: WWW/HTTP :: Dynamic Content',\n        'Topic :: Software Development :: Libraries :: Python Modules'\n    ]\n)\n"
        },
        {
          "name": "tests.py",
          "type": "blob",
          "size": 7.060546875,
          "content": "#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom grequests import get, map, imap\n\n########### Constants ############\nurls = [\n        'http://github.com',\n        'http://www.google.com',\n        'http://www.psf.org'\n        ]\n############# tests ##############\ndef test_get():\n    global urls\n    to_fetch = (get(url) for url in urls)\n    map(to_fetch)\n    for fetched in to_fetch:\n        assert fetched.ok\n\ndef test_imap_with_size():\n    global urls\n    to_fetch = (get(url) for url in urls)\n    imap(to_fetch, size = len(urls) - 1)\n    for fetching in to_fetch:\n        assert fetching.send()\n\nimport os\nimport time\nimport unittest\n\nimport requests\nfrom requests.exceptions import Timeout\nimport grequests\n\nHTTPBIN_URL = os.environ.get('HTTPBIN_URL', 'http://httpbin.org/')\n\ndef httpbin(*suffix):\n    \"\"\"Returns url for HTTPBIN resource.\"\"\"\n    return HTTPBIN_URL + '/'.join(suffix)\n\n\nN = 5\nURLS = [httpbin('get?p=%s' % i) for i in range(N)]\n\n\nclass GrequestsCase(unittest.TestCase):\n\n    def test_map(self):\n        reqs = [grequests.get(url) for url in URLS]\n        resp = grequests.map(reqs, size=N)\n        self.assertEqual([r.url for r in resp], URLS)\n\n    def test_imap(self):\n        reqs = (grequests.get(url) for url in URLS)\n        i = 0\n        for i, r in enumerate(grequests.imap(reqs, size=N)):\n            self.assertTrue(r.url in URLS)\n        self.assertEqual(i, N - 1)\n\n    def test_hooks(self):\n        result = {}\n\n        def hook(r, **kwargs):\n            result[r.url] = True\n            return r\n\n        reqs = [grequests.get(url, hooks={'response': [hook]}) for url in URLS]\n        grequests.map(reqs, size=N)\n        self.assertEqual(sorted(result.keys()), sorted(URLS))\n\n    def test_callback_kwarg(self):\n        result = {'ok': False}\n\n        def callback(r, **kwargs):\n            result['ok'] = True\n            return r\n\n        self.get(URLS[0], callback=callback)\n        self.assertTrue(result['ok'])\n\n    def test_session_and_cookies(self):\n        c1 = {'k1': 'v1'}\n        r = self.get(httpbin('cookies/set'), params=c1).json()\n        self.assertEqual(r['cookies'], c1)\n        s = requests.Session()\n        r = self.get(httpbin('cookies/set'), session=s, params=c1).json()\n        self.assertEqual(dict(s.cookies), c1)\n\n        # ensure all cookies saved\n        c2 = {'k2': 'v2'}\n        c1.update(c2)\n        r = self.get(httpbin('cookies/set'), session=s, params=c2).json()\n        self.assertEqual(dict(s.cookies), c1)\n\n        # ensure new session is created\n        r = self.get(httpbin('cookies')).json()\n        self.assertEqual(r['cookies'], {})\n\n        # cookies as param\n        c3 = {'p1': '42'}\n        r = self.get(httpbin('cookies'), cookies=c3).json()\n        self.assertEqual(r['cookies'], c3)\n\n    def test_calling_request(self):\n        reqs = [grequests.request('POST', httpbin('post'), data={'p': i})\n                for i in range(N)]\n        resp = grequests.map(reqs, size=N)\n        self.assertEqual([int(r.json()['form']['p']) for r in resp], list(range(N)))\n\n    def test_stream_enabled(self):\n        r = grequests.map([grequests.get(httpbin('stream/10'))],\n                          size=2, stream=True)[0]\n        self.assertFalse(r._content_consumed)\n\n    def test_concurrency_with_delayed_url(self):\n        t = time.time()\n        n = 10\n        reqs = [grequests.get(httpbin('delay/1')) for _ in range(n)]\n        grequests.map(reqs, size=n)\n        self.assertLess((time.time() - t), n)\n\n    def test_map_timeout_no_exception_handler(self):\n        \"\"\"\n        compliance with existing 0.2.0 behaviour\n        \"\"\"\n        reqs = [grequests.get(httpbin('delay/1'), timeout=0.001), grequests.get(httpbin('/'))]\n        responses = grequests.map(reqs)\n        self.assertIsNone(responses[0])\n        self.assertTrue(responses[1].ok)\n        self.assertEqual(len(responses), 2)\n\n    def test_map_timeout_exception_handler_no_return(self):\n        \"\"\"\n        ensure default behaviour for a handler that returns None\n        \"\"\"\n        def exception_handler(request, exception):\n            pass\n        reqs = [grequests.get(httpbin('delay/1'), timeout=0.001), grequests.get(httpbin('/'))]\n        responses = grequests.map(reqs, exception_handler=exception_handler)\n        self.assertIsNone(responses[0])\n        self.assertTrue(responses[1].ok)\n        self.assertEqual(len(responses), 2)\n\n    def test_map_timeout_exception_handler_returns_exception(self):\n        \"\"\"\n        ensure returned value from exception handler is stuffed in the map result\n        \"\"\"\n        def exception_handler(request, exception):\n            return exception\n        reqs = [grequests.get(httpbin('delay/1'), timeout=0.001), grequests.get(httpbin('/'))]\n        responses = grequests.map(reqs, exception_handler=exception_handler)\n        self.assertIsInstance(responses[0], Timeout)\n        self.assertTrue(responses[1].ok)\n        self.assertEqual(len(responses), 2)\n\n    def test_imap_timeout_no_exception_handler(self):\n        \"\"\"\n        compliance with existing 0.2.0 behaviour\n        \"\"\"\n        reqs = [grequests.get(httpbin('delay/1'), timeout=0.001)]\n        out = []\n        try:\n            for r in grequests.imap(reqs):\n                out.append(r)\n        except Timeout:\n            pass\n        self.assertEqual(out, [])\n\n    def test_imap_timeout_exception_handler_no_return(self):\n        \"\"\"\n        ensure imap-default behaviour for a handler that returns None\n        \"\"\"\n        def exception_handler(request, exception):\n            pass\n        reqs = [grequests.get(httpbin('delay/1'), timeout=0.001)]\n        out = []\n        for r in grequests.imap(reqs, exception_handler=exception_handler):\n            out.append(r)\n        self.assertEqual(out, [])\n\n\n    def test_imap_timeout_exception_handler_returns_value(self):\n        \"\"\"\n        ensure behaviour for a handler that returns a value\n        \"\"\"\n        def exception_handler(request, exception):\n            return 'a value'\n        reqs = [grequests.get(httpbin('delay/1'), timeout=0.001)]\n        out = []\n        for r in grequests.imap(reqs, exception_handler=exception_handler):\n            out.append(r)\n        self.assertEqual(out, ['a value'])\n\n    def test_map_timeout_exception(self):\n        class ExceptionHandler:\n            def __init__(self):\n                self.counter = 0\n\n            def callback(self, request, exception):\n                 self.counter += 1\n        eh = ExceptionHandler()\n        reqs = [grequests.get(httpbin('delay/1'), timeout=0.001)]\n        list(grequests.map(reqs, exception_handler=eh.callback))\n        self.assertEqual(eh.counter, 1)\n\n    def test_imap_timeout_exception(self):\n        class ExceptionHandler:\n            def __init__(self):\n                self.counter = 0\n\n            def callback(self, request, exception):\n                 self.counter += 1\n        eh = ExceptionHandler()\n        reqs = [grequests.get(httpbin('delay/1'), timeout=0.001)]\n        list(grequests.imap(reqs, exception_handler=eh.callback))\n        self.assertEqual(eh.counter, 1)\n\n    def get(self, url, **kwargs):\n        return grequests.map([grequests.get(url, **kwargs)])[0]\n\n\nif __name__ == '__main__':\n    unittest.main()\n"
        }
      ]
    }
  ]
}