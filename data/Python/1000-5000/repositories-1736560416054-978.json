{
  "metadata": {
    "timestamp": 1736560416054,
    "page": 978,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjk4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "martinarjovsky/WassersteinGAN",
      "stars": 3218,
      "defaultBranch": "master",
      "files": [
        {
          "name": "LICENSE.md",
          "type": "blob",
          "size": 1.537109375,
          "content": "BSD 3-Clause License\n\nCopyright (c) 2017, Martin Arjovsky (NYU), Soumith Chintala (Facebook), Leon Bottou (Facebook)\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above copyright notice,\n  this list of conditions and the following disclaimer in the documentation\n  and/or other materials provided with the distribution.\n\n* Neither the name of the copyright holder nor the names of its\n  contributors may be used to endorse or promote products derived from\n  this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 2.525390625,
          "content": "Wasserstein GAN\n===============\n\nCode accompanying the paper [\"Wasserstein GAN\"](https://arxiv.org/abs/1701.07875)\n\n## A few notes\n\n- The first time running on the LSUN dataset it can take a long time (up to an hour) to create the dataloader. After the first run a small cache file will be created and the process should take a matter of seconds. The cache is a list of indices in the lmdb database (of LSUN)\n- The only addition to the code (that we forgot, and will add, on the paper) are the [lines 163-166 of main.py](https://github.com/martinarjovsky/WassersteinGAN/blob/master/main.py#L163-L166). These lines act only on the first 25 generator iterations or very sporadically (once every 500 generator iterations). In such a case, they set the number of iterations on the critic to 100 instead of the default 5. This helps to start with the critic at optimum even in the first iterations. There shouldn't be a major difference in performance, but it can help, especially when visualizing learning curves (since otherwise you'd see the loss going up until the critic is properly trained). This is also why the first 25 iterations take significantly longer than the rest of the training as well.\n- If your learning curve suddenly takes a big drop take a look at [this](https://github.com/martinarjovsky/WassersteinGAN/issues/2). It's a problem when the critic fails to be close to optimum, and hence its error stops being a good Wasserstein estimate. Known causes are high learning rates and momentum, and anything that helps the critic get back on track is likely to help with the issue.\n\n## Prerequisites\n\n- Computer with Linux or OSX\n- [PyTorch](http://pytorch.org)\n- For training, an NVIDIA GPU is strongly recommended for speed. CPU is supported but training is very slow.\n\nTwo main empirical claims:\n\n### Generator sample quality correlates with discriminator loss\n\n![gensample](imgs/w_combined.png \"sample quality correlates with discriminator loss\")\n\n### Improved model stability\n\n![stability](imgs/compare_dcgan.png \"stability\")\n\n\n## Reproducing LSUN experiments\n\n**With DCGAN:**\n\n```bash\npython main.py --dataset lsun --dataroot [lsun-train-folder] --cuda\n```\n\n**With MLP:**\n\n```bash\npython main.py --mlp_G --ngf 512\n```\n\nGenerated samples will be in the `samples` folder.\n\nIf you plot the value `-Loss_D`, then you can reproduce the curves from the paper. The curves from the paper (as mentioned in the paper) have a median filter applied to them:\n\n```python\nmed_filtered_loss = scipy.signal.medfilt(-Loss_D, dtype='float64'), 101)\n```\n\nMore improved README in the works.\n"
        },
        {
          "name": "generate.py",
          "type": "blob",
          "size": 2.1640625,
          "content": "from __future__ import print_function\nimport argparse\nimport random\nimport torch\nimport torch.nn as nn\nimport torch.nn.parallel\nimport torch.backends.cudnn as cudnn\nimport torch.optim as optim\nimport torch.utils.data\nimport torchvision.datasets as dset\nimport torchvision.transforms as transforms\nimport torchvision.utils as vutils\nfrom torch.autograd import Variable\nimport os\nimport json\n\nimport models.dcgan as dcgan\nimport models.mlp as mlp\n\nif __name__==\"__main__\":\n\n    parser = argparse.ArgumentParser()\n    parser.add_argument('-c', '--config', required=True, type=str, help='path to generator config .json file')\n    parser.add_argument('-w', '--weights', required=True, type=str, help='path to generator weights .pth file')\n    parser.add_argument('-o', '--output_dir', required=True, type=str, help=\"path to to output directory\")\n    parser.add_argument('-n', '--nimages', required=True, type=int, help=\"number of images to generate\", default=1)\n    parser.add_argument('--cuda', action='store_true', help='enables cuda')\n    opt = parser.parse_args()\n\n    with open(opt.config, 'r') as gencfg:\n        generator_config = json.loads(gencfg.read())\n    \n    imageSize = generator_config[\"imageSize\"]\n    nz = generator_config[\"nz\"]\n    nc = generator_config[\"nc\"]\n    ngf = generator_config[\"ngf\"]\n    noBN = generator_config[\"noBN\"]\n    ngpu = generator_config[\"ngpu\"]\n    mlp_G = generator_config[\"mlp_G\"]\n    n_extra_layers = generator_config[\"n_extra_layers\"]\n\n    if noBN:\n        netG = dcgan.DCGAN_G_nobn(imageSize, nz, nc, ngf, ngpu, n_extra_layers)\n    elif mlp_G:\n        netG = mlp.MLP_G(imageSize, nz, nc, ngf, ngpu)\n    else:\n        netG = dcgan.DCGAN_G(imageSize, nz, nc, ngf, ngpu, n_extra_layers)\n\n    # load weights\n    netG.load_state_dict(torch.load(opt.weights))\n\n    # initialize noise\n    fixed_noise = torch.FloatTensor(opt.nimages, nz, 1, 1).normal_(0, 1)\n\n    if opt.cuda:\n        netG.cuda()\n        fixed_noise = fixed_noise.cuda()\n\n    fake = netG(fixed_noise)\n    fake.data = fake.data.mul(0.5).add(0.5)\n\n    for i in range(opt.nimages):\n        vutils.save_image(fake.data[i, ...].reshape((1, nc, imageSize, imageSize)), os.path.join(opt.output_dir, \"generated_%02d.png\"%i))\n"
        },
        {
          "name": "imgs",
          "type": "tree",
          "content": null
        },
        {
          "name": "main.py",
          "type": "blob",
          "size": 10.7890625,
          "content": "from __future__ import print_function\nimport argparse\nimport random\nimport torch\nimport torch.nn as nn\nimport torch.nn.parallel\nimport torch.backends.cudnn as cudnn\nimport torch.optim as optim\nimport torch.utils.data\nimport torchvision.datasets as dset\nimport torchvision.transforms as transforms\nimport torchvision.utils as vutils\nfrom torch.autograd import Variable\nimport os\nimport json\n\nimport models.dcgan as dcgan\nimport models.mlp as mlp\n\nif __name__==\"__main__\":\n\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--dataset', required=True, help='cifar10 | lsun | imagenet | folder | lfw ')\n    parser.add_argument('--dataroot', required=True, help='path to dataset')\n    parser.add_argument('--workers', type=int, help='number of data loading workers', default=2)\n    parser.add_argument('--batchSize', type=int, default=64, help='input batch size')\n    parser.add_argument('--imageSize', type=int, default=64, help='the height / width of the input image to network')\n    parser.add_argument('--nc', type=int, default=3, help='input image channels')\n    parser.add_argument('--nz', type=int, default=100, help='size of the latent z vector')\n    parser.add_argument('--ngf', type=int, default=64)\n    parser.add_argument('--ndf', type=int, default=64)\n    parser.add_argument('--niter', type=int, default=25, help='number of epochs to train for')\n    parser.add_argument('--lrD', type=float, default=0.00005, help='learning rate for Critic, default=0.00005')\n    parser.add_argument('--lrG', type=float, default=0.00005, help='learning rate for Generator, default=0.00005')\n    parser.add_argument('--beta1', type=float, default=0.5, help='beta1 for adam. default=0.5')\n    parser.add_argument('--cuda'  , action='store_true', help='enables cuda')\n    parser.add_argument('--ngpu'  , type=int, default=1, help='number of GPUs to use')\n    parser.add_argument('--netG', default='', help=\"path to netG (to continue training)\")\n    parser.add_argument('--netD', default='', help=\"path to netD (to continue training)\")\n    parser.add_argument('--clamp_lower', type=float, default=-0.01)\n    parser.add_argument('--clamp_upper', type=float, default=0.01)\n    parser.add_argument('--Diters', type=int, default=5, help='number of D iters per each G iter')\n    parser.add_argument('--noBN', action='store_true', help='use batchnorm or not (only for DCGAN)')\n    parser.add_argument('--mlp_G', action='store_true', help='use MLP for G')\n    parser.add_argument('--mlp_D', action='store_true', help='use MLP for D')\n    parser.add_argument('--n_extra_layers', type=int, default=0, help='Number of extra layers on gen and disc')\n    parser.add_argument('--experiment', default=None, help='Where to store samples and models')\n    parser.add_argument('--adam', action='store_true', help='Whether to use adam (default is rmsprop)')\n    opt = parser.parse_args()\n    print(opt)\n\n    if opt.experiment is None:\n        opt.experiment = 'samples'\n    os.system('mkdir {0}'.format(opt.experiment))\n\n    opt.manualSeed = random.randint(1, 10000) # fix seed\n    print(\"Random Seed: \", opt.manualSeed)\n    random.seed(opt.manualSeed)\n    torch.manual_seed(opt.manualSeed)\n\n    cudnn.benchmark = True\n\n    if torch.cuda.is_available() and not opt.cuda:\n        print(\"WARNING: You have a CUDA device, so you should probably run with --cuda\")\n\n    if opt.dataset in ['imagenet', 'folder', 'lfw']:\n        # folder dataset\n        dataset = dset.ImageFolder(root=opt.dataroot,\n                                transform=transforms.Compose([\n                                    transforms.Scale(opt.imageSize),\n                                    transforms.CenterCrop(opt.imageSize),\n                                    transforms.ToTensor(),\n                                    transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5)),\n                                ]))\n    elif opt.dataset == 'lsun':\n        dataset = dset.LSUN(db_path=opt.dataroot, classes=['bedroom_train'],\n                            transform=transforms.Compose([\n                                transforms.Scale(opt.imageSize),\n                                transforms.CenterCrop(opt.imageSize),\n                                transforms.ToTensor(),\n                                transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5)),\n                            ]))\n    elif opt.dataset == 'cifar10':\n        dataset = dset.CIFAR10(root=opt.dataroot, download=True,\n                            transform=transforms.Compose([\n                                transforms.Scale(opt.imageSize),\n                                transforms.ToTensor(),\n                                transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5)),\n                            ])\n        )\n    assert dataset\n    dataloader = torch.utils.data.DataLoader(dataset, batch_size=opt.batchSize,\n                                            shuffle=True, num_workers=int(opt.workers))\n\n    ngpu = int(opt.ngpu)\n    nz = int(opt.nz)\n    ngf = int(opt.ngf)\n    ndf = int(opt.ndf)\n    nc = int(opt.nc)\n    n_extra_layers = int(opt.n_extra_layers)\n\n    # write out generator config to generate images together wth training checkpoints (.pth)\n    generator_config = {\"imageSize\": opt.imageSize, \"nz\": nz, \"nc\": nc, \"ngf\": ngf, \"ngpu\": ngpu, \"n_extra_layers\": n_extra_layers, \"noBN\": opt.noBN, \"mlp_G\": opt.mlp_G}\n    with open(os.path.join(opt.experiment, \"generator_config.json\"), 'w') as gcfg:\n        gcfg.write(json.dumps(generator_config)+\"\\n\")\n\n    # custom weights initialization called on netG and netD\n    def weights_init(m):\n        classname = m.__class__.__name__\n        if classname.find('Conv') != -1:\n            m.weight.data.normal_(0.0, 0.02)\n        elif classname.find('BatchNorm') != -1:\n            m.weight.data.normal_(1.0, 0.02)\n            m.bias.data.fill_(0)\n\n    if opt.noBN:\n        netG = dcgan.DCGAN_G_nobn(opt.imageSize, nz, nc, ngf, ngpu, n_extra_layers)\n    elif opt.mlp_G:\n        netG = mlp.MLP_G(opt.imageSize, nz, nc, ngf, ngpu)\n    else:\n        netG = dcgan.DCGAN_G(opt.imageSize, nz, nc, ngf, ngpu, n_extra_layers)\n\n    # write out generator config to generate images together wth training checkpoints (.pth)\n    generator_config = {\"imageSize\": opt.imageSize, \"nz\": nz, \"nc\": nc, \"ngf\": ngf, \"ngpu\": ngpu, \"n_extra_layers\": n_extra_layers, \"noBN\": opt.noBN, \"mlp_G\": opt.mlp_G}\n    with open(os.path.join(opt.experiment, \"generator_config.json\"), 'w') as gcfg:\n        gcfg.write(json.dumps(generator_config)+\"\\n\")\n\n    netG.apply(weights_init)\n    if opt.netG != '': # load checkpoint if needed\n        netG.load_state_dict(torch.load(opt.netG))\n    print(netG)\n\n    if opt.mlp_D:\n        netD = mlp.MLP_D(opt.imageSize, nz, nc, ndf, ngpu)\n    else:\n        netD = dcgan.DCGAN_D(opt.imageSize, nz, nc, ndf, ngpu, n_extra_layers)\n        netD.apply(weights_init)\n\n    if opt.netD != '':\n        netD.load_state_dict(torch.load(opt.netD))\n    print(netD)\n\n    input = torch.FloatTensor(opt.batchSize, 3, opt.imageSize, opt.imageSize)\n    noise = torch.FloatTensor(opt.batchSize, nz, 1, 1)\n    fixed_noise = torch.FloatTensor(opt.batchSize, nz, 1, 1).normal_(0, 1)\n    one = torch.FloatTensor([1])\n    mone = one * -1\n\n    if opt.cuda:\n        netD.cuda()\n        netG.cuda()\n        input = input.cuda()\n        one, mone = one.cuda(), mone.cuda()\n        noise, fixed_noise = noise.cuda(), fixed_noise.cuda()\n\n    # setup optimizer\n    if opt.adam:\n        optimizerD = optim.Adam(netD.parameters(), lr=opt.lrD, betas=(opt.beta1, 0.999))\n        optimizerG = optim.Adam(netG.parameters(), lr=opt.lrG, betas=(opt.beta1, 0.999))\n    else:\n        optimizerD = optim.RMSprop(netD.parameters(), lr = opt.lrD)\n        optimizerG = optim.RMSprop(netG.parameters(), lr = opt.lrG)\n\n    gen_iterations = 0\n    for epoch in range(opt.niter):\n        data_iter = iter(dataloader)\n        i = 0\n        while i < len(dataloader):\n            ############################\n            # (1) Update D network\n            ###########################\n            for p in netD.parameters(): # reset requires_grad\n                p.requires_grad = True # they are set to False below in netG update\n\n            # train the discriminator Diters times\n            if gen_iterations < 25 or gen_iterations % 500 == 0:\n                Diters = 100\n            else:\n                Diters = opt.Diters\n            j = 0\n            while j < Diters and i < len(dataloader):\n                j += 1\n\n                # clamp parameters to a cube\n                for p in netD.parameters():\n                    p.data.clamp_(opt.clamp_lower, opt.clamp_upper)\n\n                data = data_iter.next()\n                i += 1\n\n                # train with real\n                real_cpu, _ = data\n                netD.zero_grad()\n                batch_size = real_cpu.size(0)\n\n                if opt.cuda:\n                    real_cpu = real_cpu.cuda()\n                input.resize_as_(real_cpu).copy_(real_cpu)\n                inputv = Variable(input)\n\n                errD_real = netD(inputv)\n                errD_real.backward(one)\n\n                # train with fake\n                noise.resize_(opt.batchSize, nz, 1, 1).normal_(0, 1)\n                noisev = Variable(noise, volatile = True) # totally freeze netG\n                fake = Variable(netG(noisev).data)\n                inputv = fake\n                errD_fake = netD(inputv)\n                errD_fake.backward(mone)\n                errD = errD_real - errD_fake\n                optimizerD.step()\n\n            ############################\n            # (2) Update G network\n            ###########################\n            for p in netD.parameters():\n                p.requires_grad = False # to avoid computation\n            netG.zero_grad()\n            # in case our last batch was the tail batch of the dataloader,\n            # make sure we feed a full batch of noise\n            noise.resize_(opt.batchSize, nz, 1, 1).normal_(0, 1)\n            noisev = Variable(noise)\n            fake = netG(noisev)\n            errG = netD(fake)\n            errG.backward(one)\n            optimizerG.step()\n            gen_iterations += 1\n\n            print('[%d/%d][%d/%d][%d] Loss_D: %f Loss_G: %f Loss_D_real: %f Loss_D_fake %f'\n                % (epoch, opt.niter, i, len(dataloader), gen_iterations,\n                errD.data[0], errG.data[0], errD_real.data[0], errD_fake.data[0]))\n            if gen_iterations % 500 == 0:\n                real_cpu = real_cpu.mul(0.5).add(0.5)\n                vutils.save_image(real_cpu, '{0}/real_samples.png'.format(opt.experiment))\n                fake = netG(Variable(fixed_noise, volatile=True))\n                fake.data = fake.data.mul(0.5).add(0.5)\n                vutils.save_image(fake.data, '{0}/fake_samples_{1}.png'.format(opt.experiment, gen_iterations))\n\n        # do checkpointing\n        torch.save(netG.state_dict(), '{0}/netG_epoch_{1}.pth'.format(opt.experiment, epoch))\n        torch.save(netD.state_dict(), '{0}/netD_epoch_{1}.pth'.format(opt.experiment, epoch))\n"
        },
        {
          "name": "models",
          "type": "tree",
          "content": null
        },
        {
          "name": "requirements.txt",
          "type": "blob",
          "size": 0.017578125,
          "content": "torch\ntorchvision\n"
        }
      ]
    }
  ]
}