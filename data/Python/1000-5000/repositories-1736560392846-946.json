{
  "metadata": {
    "timestamp": 1736560392846,
    "page": 946,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjk1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "Oros42/IMSI-catcher",
      "stars": 3255,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".env.dist",
          "type": "blob",
          "size": 0.0634765625,
          "content": "# MySQL Config\nMYSQL_HOST=\nMYSQL_USER=\nMYSQL_PASSWORD=\nMYSQL_DB=\n"
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0224609375,
          "content": ".vscode\nvenv\n.env\ntest*"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 0.77734375,
          "content": "FROM ubuntu:bionic\n\nMAINTAINER Dmitry Abakumov, a.k.a 0MazaHacka0 <killerinshadow2@gmail.com>\n\n# Update container\nRUN apt-get update\n\n# GR-GSM\nRUN export TZ=America/New_York && export DEBIAN_FRONTEND=noninteractive && apt-get install -y  gnuradio gnuradio-dev git cmake autoconf libtool pkg-config g++ gcc make libc6 \\\nlibc6-dev libcppunit-1.14-0 libcppunit-dev swig doxygen liblog4cpp5v5 liblog4cpp5-dev python-scipy \\\ngr-osmosdr libosmocore libosmocore-dev\n\nRUN git clone https://git.osmocom.org/gr-gsm\n\nRUN cd gr-gsm && mkdir build && cd build && cmake .. && make && make install && ldconfig\n\n# IMSI-catcher script\nRUN apt-get install -y python-numpy python-scipy python-scapy\n\nADD . /imsi-catcher/\n\n# Wireshark\nRUN export DEBIAN_FRONTEND=noninteractive && apt-get install -y wireshark tshark\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 6.40234375,
          "content": "CC0 1.0 Universal\n\nStatement of Purpose\n\nThe laws of most jurisdictions throughout the world automatically confer\nexclusive Copyright and Related Rights (defined below) upon the creator and\nsubsequent owner(s) (each and all, an \"owner\") of an original work of\nauthorship and/or a database (each, a \"Work\").\n\nCertain owners wish to permanently relinquish those rights to a Work for the\npurpose of contributing to a commons of creative, cultural and scientific\nworks (\"Commons\") that the public can reliably and without fear of later\nclaims of infringement build upon, modify, incorporate in other works, reuse\nand redistribute as freely as possible in any form whatsoever and for any\npurposes, including without limitation commercial purposes. These owners may\ncontribute to the Commons to promote the ideal of a free culture and the\nfurther production of creative, cultural and scientific works, or to gain\nreputation or greater distribution for their Work in part through the use and\nefforts of others.\n\nFor these and/or other purposes and motivations, and without any expectation\nof additional consideration or compensation, the person associating CC0 with a\nWork (the \"Affirmer\"), to the extent that he or she is an owner of Copyright\nand Related Rights in the Work, voluntarily elects to apply CC0 to the Work\nand publicly distribute the Work under its terms, with knowledge of his or her\nCopyright and Related Rights in the Work and the meaning and intended legal\neffect of CC0 on those rights.\n\n1. Copyright and Related Rights. A Work made available under CC0 may be\nprotected by copyright and related or neighboring rights (\"Copyright and\nRelated Rights\"). Copyright and Related Rights include, but are not limited\nto, the following:\n\n  i. the right to reproduce, adapt, distribute, perform, display, communicate,\n  and translate a Work;\n\n  ii. moral rights retained by the original author(s) and/or performer(s);\n\n  iii. publicity and privacy rights pertaining to a person's image or likeness\n  depicted in a Work;\n\n  iv. rights protecting against unfair competition in regards to a Work,\n  subject to the limitations in paragraph 4(a), below;\n\n  v. rights protecting the extraction, dissemination, use and reuse of data in\n  a Work;\n\n  vi. database rights (such as those arising under Directive 96/9/EC of the\n  European Parliament and of the Council of 11 March 1996 on the legal\n  protection of databases, and under any national implementation thereof,\n  including any amended or successor version of such directive); and\n\n  vii. other similar, equivalent or corresponding rights throughout the world\n  based on applicable law or treaty, and any national implementations thereof.\n\n2. Waiver. To the greatest extent permitted by, but not in contravention of,\napplicable law, Affirmer hereby overtly, fully, permanently, irrevocably and\nunconditionally waives, abandons, and surrenders all of Affirmer's Copyright\nand Related Rights and associated claims and causes of action, whether now\nknown or unknown (including existing as well as future claims and causes of\naction), in the Work (i) in all territories worldwide, (ii) for the maximum\nduration provided by applicable law or treaty (including future time\nextensions), (iii) in any current or future medium and for any number of\ncopies, and (iv) for any purpose whatsoever, including without limitation\ncommercial, advertising or promotional purposes (the \"Waiver\"). Affirmer makes\nthe Waiver for the benefit of each member of the public at large and to the\ndetriment of Affirmer's heirs and successors, fully intending that such Waiver\nshall not be subject to revocation, rescission, cancellation, termination, or\nany other legal or equitable action to disrupt the quiet enjoyment of the Work\nby the public as contemplated by Affirmer's express Statement of Purpose.\n\n3. Public License Fallback. Should any part of the Waiver for any reason be\njudged legally invalid or ineffective under applicable law, then the Waiver\nshall be preserved to the maximum extent permitted taking into account\nAffirmer's express Statement of Purpose. In addition, to the extent the Waiver\nis so judged Affirmer hereby grants to each affected person a royalty-free,\nnon transferable, non sublicensable, non exclusive, irrevocable and\nunconditional license to exercise Affirmer's Copyright and Related Rights in\nthe Work (i) in all territories worldwide, (ii) for the maximum duration\nprovided by applicable law or treaty (including future time extensions), (iii)\nin any current or future medium and for any number of copies, and (iv) for any\npurpose whatsoever, including without limitation commercial, advertising or\npromotional purposes (the \"License\"). The License shall be deemed effective as\nof the date CC0 was applied by Affirmer to the Work. Should any part of the\nLicense for any reason be judged legally invalid or ineffective under\napplicable law, such partial invalidity or ineffectiveness shall not\ninvalidate the remainder of the License, and in such case Affirmer hereby\naffirms that he or she will not (i) exercise any of his or her remaining\nCopyright and Related Rights in the Work or (ii) assert any associated claims\nand causes of action with respect to the Work, in either case contrary to\nAffirmer's express Statement of Purpose.\n\n4. Limitations and Disclaimers.\n\n  a. No trademark or patent rights held by Affirmer are waived, abandoned,\n  surrendered, licensed or otherwise affected by this document.\n\n  b. Affirmer offers the Work as-is and makes no representations or warranties\n  of any kind concerning the Work, express, implied, statutory or otherwise,\n  including without limitation warranties of title, merchantability, fitness\n  for a particular purpose, non infringement, or the absence of latent or\n  other defects, accuracy, or the present or absence of errors, whether or not\n  discoverable, all to the greatest extent permissible under applicable law.\n\n  c. Affirmer disclaims responsibility for clearing rights of other persons\n  that may apply to the Work or any use thereof, including without limitation\n  any person's Copyright and Related Rights in the Work. Further, Affirmer\n  disclaims responsibility for obtaining any necessary consents, permissions\n  or other rights required for any use of the Work.\n\n  d. Affirmer understands and acknowledges that Creative Commons is not a\n  party to this document and has no duty or obligation with respect to this\n  CC0 or use of the Work.\n\nFor more information, please see\n<http://creativecommons.org/publicdomain/zero/1.0/>\n\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 5.8173828125,
          "content": "# IMSI-catcher\n\nThis program shows you IMSI numbers, country, brand and operator of cellphones around you.  \n  \n/!\\ This program was made to understand how GSM network work. Not for bad hacking !  \n  \n\n![screenshot0](capture_simple_IMSI-catcher.png)  \n  \n\n## What you need\n\n1 PC with Gnu/Linux. Tested with :  \n- debian 10  \n- Ubuntu 20.04/LinuxMint 20+  \n- Kali 2020+  \n  \n1 SDR receiver. Tested with :  \n- [USB DVB-T key (RTL2832U)](https://osmocom.org/projects/sdr/wiki/rtl-sdr) with antenna (less than 15$)  \n- [OsmocomBB phone](https://osmocom.org/projects/baseband/wiki/Phones)  \n- [HackRF](https://greatscottgadgets.com/hackrf/)  \n- [BladeRF](https://www.nuand.com/bladerf-2-0-micro/)  \n  \n## Setup\n\n```bash\ngit clone https://github.com/Oros42/IMSI-catcher.git\ncd IMSI-catcher\n```\nor\n```bash\nwget https://github.com/Oros42/IMSI-catcher/archive/master.zip && unzip -q master.zip\ncd IMSI-catcher-master\n```\n  \n```bash\nsudo apt install python3-numpy python3-scipy python3-scapy\n```\nWarning : don't use python 3.9 (ctypes bug)!  \n  \nYou have the choice with 2 types of gr-gsm's install : in your OS or with docker.  \n  \n### Install gr-gsm in your OS (recommended)\n\n```bash\nsudo apt-get install -y \\\n    cmake \\\n    autoconf \\\n    libtool \\\n    pkg-config \\\n    build-essential \\\n    python3-docutils \\\n    libcppunit-dev \\\n    swig \\\n    doxygen \\\n    liblog4cpp5-dev \\\n    gnuradio-dev \\\n    gr-osmosdr \\\n    libosmocore-dev \\\n    liborc-0.4-dev \\\n    swig\n```\n```bash\ngnuradio-config-info -v\n```\nif >= 3.10 (read this [AskUbuntu answer](https://askubuntu.com/a/1436119/) for details):\n```bash\ngit clone -b maint-3.10_with_multiarfcn https://github.com/bkerler/gr-gsm\n```\nelse if >= 3.8:\n```bash\ngit clone -b maint-3.8 https://github.com/velichkov/gr-gsm.git\n```\nelse (3.7):\n```bash\ngit clone https://git.osmocom.org/gr-gsm\n```\n  \n```bash\ncd gr-gsm\nmkdir build\ncd build\ncmake ..\nmake -j 4\nsudo make install\nsudo ldconfig\necho 'export PYTHONPATH=/usr/local/lib/python3/dist-packages/:$PYTHONPATH' >> ~/.bashrc\n```\n\n### Importlib vs Imp\nBeginning with Python 3.1, Imp is replaced by importlib. Imp is deprecated in Python 3.11, with the new requirements met as follows.\n\n```bash\napt install python3-pip\npip install importlib\n```\n\n### Install gr-gsm with Docker\n\n```bash\nsudo xhost +local:docker\ndocker pull atomicpowerman/imsi-catcher\ndocker run -ti --net=host -e DISPLAY=$DISPLAY --privileged -v /dev/bus/usb:/dev/bus/usb  atomicpowerman/imsi-catcher bash\n```\nRun all `grgsm_*` in this docker.   \n  \n\n## Usage\n\nWe use `grgsm_livemon` to decode GSM signals and `simple_IMSI-catcher.py` to find IMSIs.  \n  \n```bash\npython3 simple_IMSI-catcher.py -h\n```\n```\nUsage: simple_IMSI-catcher.py: [options]\n\nOptions:\n  -h, --help            show this help message and exit\n  -a, --alltmsi         Show TMSI who haven't got IMSI (default  : false)\n  -i IFACE, --iface=IFACE\n                        Interface (default : lo)\n  -m IMSI, --imsi=IMSI  IMSI to track (default : None, Example:\n                        123456789101112 or \"123 45 6789101112\")\n  -p PORT, --port=PORT  Port (default : 4729)\n  -s, --sniff           sniff on interface instead of listening on port\n                        (require root/suid access)\n  -w SQLITE, --sqlite=SQLITE\n                        Save observed IMSI values to specified SQLite file\n  -t TXT, --txt=TXT     Save observed IMSI values to specified TXT file\n  -z, --mysql           Save observed IMSI values to specified MYSQL DB (copy\n                        .env.dist to .env and edit it)\n```\n\nOpen 2 terminals.  \n  \nIn terminal 1  \n```bash\nsudo python3 simple_IMSI-catcher.py -s\n```\n  \nIn terminal 2  \n```bash\ngrgsm_livemon\n```\nNow, change the frequency until it display, in terminal, something like that :  \n``` \n15 06 21 00 01 f0 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b\n25 06 21 00 05 f4 f8 68 03 26 23 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b\n49 06 1b 95 cc 02 f8 02 01 9c c8 03 1e 57 a5 01 79 00 00 1c 13 2b 2b\n```\n\n### Wireshark\n\nYou can watch GSM packets with wireshark.  \n```bash\nsudo apt install wireshark\nsudo wireshark -k -Y '!icmp && gsmtap' -i lo\n```\n\n### Find frequencies\n \n```bash\ngrgsm_scanner\n```\n```\nARFCN:  974, Freq:  925.0M, CID:     2, LAC:   1337, MCC: 208, MNC:  20, Pwr: -41\nARFCN:  976, Freq:  925.4M, CID:  4242, LAC:   1007, MCC: 208, MNC:  20, Pwr: -45\n```\nNow, you can set the frequency for `grgsm_livemon` :  \n```bash\ngrgsm_livemon -f 925.4M\n```\n  \nOr, for hackrf, fetch the kalibrate-hackrf tool like this:  \n```bash\nsudo apt-get install automake autoconf libhackrf-dev\ngit clone https://github.com/scateu/kalibrate-hackrf\ncd kalibrate-hackrf/\n./bootstrap\n./configure\nmake\nsudo make install\n```\nRun  \n```bash\nkal -s GSM900\n```\n```\nkal: Scanning for GSM-900 base stations.\nGSM-900:\n\tchan:   14 (937.8MHz + 10.449kHz)\tpower: 3327428.82\n\tchan:   15 (938.0MHz + 4.662kHz)\tpower: 3190712.41\n...\n```\n\n### Log data in mysql\n\nUse `db-example.sql` to create your DB.\n  \n```bash\ncp .env.dist .env\nnano .env\n# set your config\nsudo apt install python-decouple python3-mysqldb\n```\n  \n```bash\nsudo python3 simple_IMSI-catcher.py -s --mysql\n```\n\n### scan-and-livemon (no longer used)\n\nScan frequencies and listen the 1st found :  \nIn terminal 1  \n```bash\npython3 scan-and-livemon\n```\n  \nIn terminal 2  \n```bash\npython3 simple_IMSI-catcher.py\n```\n\n# Links\n\nSetup of Gr-Gsm : https://osmocom.org/projects/gr-gsm/wiki/Installation and https://github.com/velichkov/gr-gsm  \nFrequency : http://www.worldtimezone.com/gsm.html and https://fr.wikipedia.org/wiki/Global_System_for_Mobile_Communications  \nMobile Network Code : https://en.wikipedia.org/wiki/Mobile_Network_Code  \nScapy : http://secdev.org/projects/scapy/doc/usage.html  \nIMSI : https://fr.wikipedia.org/wiki/IMSI  \nRealtek RTL2832U : https://osmocom.org/projects/sdr/wiki/rtl-sdr and http://doc.ubuntu-fr.org/rtl2832u and http://doc.ubuntu-fr.org/rtl-sdr  \n\n# Donate\n\nTo support my work, a tipee would be nice ;-)  \nhttps://liberapay.com/Oros/  \n"
        },
        {
          "name": "capture_simple_IMSI-catcher.png",
          "type": "blob",
          "size": 140.8427734375,
          "content": null
        },
        {
          "name": "db-example.sql",
          "type": "blob",
          "size": 1.5859375,
          "content": "SET SQL_MODE = \"NO_AUTO_VALUE_ON_ZERO\";\nSET time_zone = \"+00:00\";\n\n\n/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;\n/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;\n/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;\n/*!40101 SET NAMES utf8mb4 */;\n\n--\n-- Database: `demo`\n--\n\n-- --------------------------------------------------------\n\n--\n-- Table structure for table `imsi`\n--\n\nCREATE TABLE `imsi` (\n  `id` int(11) NOT NULL,\n  `tmsi1` varchar(100) DEFAULT NULL,\n  `tmsi2` varchar(100) DEFAULT NULL,\n  `imsi` varchar(100) DEFAULT NULL,\n  `stamp` datetime DEFAULT NULL,\n  `deviceid` varchar(100) DEFAULT NULL,\n  `cell_id` varchar(225) DEFAULT NULL,\n  `lac` varchar(225) DEFAULT NULL,\n  `mcc` varchar(10) DEFAULT NULL,\n  `mnc` varchar(10) DEFAULT NULL\n) ENGINE=InnoDB DEFAULT CHARSET=latin1;\n\n--\n-- Dumping data for table `imsi`\n--\n\n--\n-- Ex query: saving data to table `imsi`\n-- \n-- INSERT INTO `imsi` (`id`, `tmsi1`, `tmsi2`, `imsi`, `stamp`, `deviceid`, `cell_id`, `lac`, `mcc`, `mnc`) VALUES\n-- (4, NULL, NULL, '510 10 1552980000', '2020-05-11 15:00:18', 'rtl', '0000', '000', '510', '10');\n\n--\n-- Indexes for dumped tables\n--\n\n--\n-- Indexes for table `imsi`\n--\nALTER TABLE `imsi`\n  ADD PRIMARY KEY (`id`);\n\n--\n-- AUTO_INCREMENT for dumped tables\n--\n\n--\n-- AUTO_INCREMENT for table `imsi`\n--\nALTER TABLE `imsi`\n  MODIFY `id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=9;\n/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;\n/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;\n/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;\n"
        },
        {
          "name": "immediate_assignment_catcher.py",
          "type": "blob",
          "size": 4.2900390625,
          "content": "#!/usr/bin/python\n# -*- coding: utf-8 -*-\n# Author: Oros\n# 2016/10/06\n# License : CC0 1.0 Universal\n\n\"\"\"\nDisplay SDCCH, Subchannel, Timeslot, HoppingChannel, ARFCN\n\"\"\"\nfrom scapy.all import sniff\nfrom optparse import OptionParser\n\ndef find_assignment(x):\n\t\"\"\"\n\n\t0000   00 00 00 00 00 00 00 00 00 00 00 00 08 00 45 00\n\t0010   00 43 b1 be 40 00 40 11 8a e9 7f 00 00 01 7f 00\n\t0020   00 01 b9 11 12 79 00 2f fe 42 02 04 01 00 00 00\n\t0030   e6 00 00 08 d4 7a 02 00 06 00 2d 06 3f 10 0e 03\n\t0040   df 7b a3 71 01 00 ce 01 81 59 d7 2b 2b 2b 2b 2b\n\t0050   2b\n\n\tDedicated mode or TBF\n\t0000   10\n\t\t0001 .... = Dedicated mode or TBF: This message assigns an uplink TBF or is the second message of two in a two-message assignment of an uplink or downlink TBF (1)\n\tPacket Channel Description\n\t0000   0e 03 df\n\t\t0000 1... = Channel Type: 1\n\t\t.... .110 = Timeslot: 6\n\t\t000. .... = Training Sequence: 0\n\t\t.... .0.. = Spare: 0x00\n\t\t.... ..11  1101 1111 = Single channel ARFCN: 991\n\n\n\n\tDedicated mode or TBF\n\t0000   30\n\t\t0011 .... = Dedicated mode or TBF: This message assigns a downlink TBF to the mobile station identified in the IA Rest Octets IE (3)\n\n\n\n\tGSMTAP\t81\t(CCCH) (RR) Immediate Assignment \n\t0000   00 00 00 00 00 00 00 00 00 00 00 00 08 00 45 00\n\t0010   00 43 07 02 40 00 40 11 35 a6 7f 00 00 01 7f 00\n\t0020   00 01 b7 29 12 79 00 2f fe 42 02 04 01 00 00 00\n\t0030   e6 00 00 16 ab ce 02 00 07 00 2d 06 3f 03 41 c0\n\t0040   09 00 03 b1 01 00 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b\n\t0050   2b\n\n\t\n\t0x3e = 0x41\n\t0100 0... = SDCCH/8 + SACCH/C8 or CBCH (SDCCH/8): 8\n\tSubchannel: 0\n\t.... .001 = Timeslot: 1\n\n\t0x3f = 0xc0\n\t110. .... = Training Sequence: 6\n\t...0 .... = Hopping Channel: No\n\t..00 .... = Spare: 0x00\n\n\t0x40 = 0x09\n\tSingle channel ARFCN: 9\n\n\n\t\t\t0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f\n\n\t0000   00 00 00 00 00 00 00 00 00 00 00 00 08 00 45 00\n\t0010   00 43 c8 7f 40 00 40 11 74 28 7f 00 00 01 7f 00\n\t0020   00 01 9c c8 12 79 00 2f fe 42 02 04 01 00 00 00\n\t0030   e4 00 00 09 0a e7 02 00 08 00 2d 06 3f 00 41 03\n\t0040   df 92 f4 2a 01 00 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b\n\t0050   2b\n\n\tDedicated mode or TBF\n\t0000   00\n\t\t0000 .... = Dedicated mode or TBF: This message assigns a dedicated mode resource (0)\n\tChannel Description\n\t0000   41 03 df\n\t\t0100 0... = SDCCH/8 + SACCH/C8 or CBCH (SDCCH/8): 8\n\t\tSubchannel: 0\n\t\t.... .001 = Timeslot: 1\n\t\t000. .... = Training Sequence: 0\n\t\t...0 .... = Hopping Channel: No\n\t\t..00 .... = Spare: 0x00\n\t\tSingle channel ARFCN: 991\n\n\t79\n\t0111 1... = SDCCH/8 + SACCH/C8 or CBCH (SDCCH/8): 15\n\tSubchannel: 7\n\t.... .001 = Timeslot: 1\n\n\n\tARFCN calcul :\n\thttps://en.wikipedia.org/wiki/ARFCN\n\thttp://www.telecomabc.com/a/arfcn.html\n\thttp://niviuk.free.fr/gsm_band.php\n\n\t\"\"\"\n\tp=str(x)\n\tif ord(p[0x36]) != 0x1: # Channel Type != BCCH (0)\n\t\tif ord(p[0x3c]) == 0x3f: # Message Type: Immediate Assignment\n\t\t\tif ord(p[0x3d]) >> 4 == 0: # 0000 .... = Dedicated mode or TBF: This message assigns a dedicated mode resource (0)\n\t\t\t\tsdcch=ord(p[0x3e]) >> 3 # 0100 0... = SDCCH/8 + SACCH/C8 or CBCH (SDCCH/8): 8\n\t\t\t\tsubchannel=ord(p[0x3e])\n\t\t\t\ttimeslot=ord(p[0x3e]) & 0x07 # .... .001 = Timeslot: 1\n\t\t\t\thopping_channel=\"yes\" if (ord(p[0x3f]) >> 4) & 1 == 1 else \"no\" # ...0 .... = Hopping Channel: No\n\t\t\t\tarfcn=(ord(p[0x3f]) & 0x03)*256 + ord(p[0x40]) # .... ..11  1101 1111 = Single channel ARFCN: 991\n\t\t\t\tprint(\"{}\\t; {}\\t\\t; {}\\t\\t; {}\\t\\t\\t; {}\".format(sdcch, subchannel, timeslot, hopping_channel, arfcn))\n\t\t\telse:\n\t\t\t\t# Dedicated mode or TBF: This message assigns an uplink TBF or is the second message of two in a two-message assignment of an uplink or downlink TBF (1)\n\t\t\t\tsdcch=\"-\"\n\t\t\t\tsubchannel=\"-\"\n\t\t\t\ttimeslot=ord(p[0x3e]) & 0x07 # .... .001 = Timeslot: 1\n\t\t\t\thopping_channel=\"-\"\n\t\t\t\tarfcn=(ord(p[0x3f]) & 0x03)*256 + ord(p[0x40]) # .... ..11  1101 1111 = Single channel ARFCN: 991\n\t\t\t\tprint(\"{}\\t; {}\\t\\t; {}\\t\\t; {}\\t\\t\\t; {}\".format(sdcch, subchannel, timeslot, hopping_channel, arfcn))\n\t\t\t\tpass\n\n\t\t\t\nparser = OptionParser(usage=\"%prog: [options]\")\nparser.add_option(\"-i\", \"--iface\", dest=\"iface\", default=\"lo\", help=\"Interface (default : lo)\")\nparser.add_option(\"-p\", \"--port\", dest=\"port\", default=\"4729\", type=\"int\", help=\"Port (default : 4729)\")\n(options, args) = parser.parse_args()\n\nprint(\"SDCCH\\t; Subchannel\\t; Timeslot\\t; HoppingChannel\\t; ARFCN\")\nsniff(iface=options.iface, filter=\"port {} and not icmp and udp\".format(options.port), prn=find_assignment, store=0)"
        },
        {
          "name": "mcc-mnc",
          "type": "tree",
          "content": null
        },
        {
          "name": "scan-and-livemon",
          "type": "blob",
          "size": 3.3623046875,
          "content": "#!/usr/bin/python\n# -*- coding: utf-8 -*-\n#\n# Author: Petter Reinholdtsen\n# Contributor : Oros\n# Lisence: GPL v2 or later at your own choice\n\n\"\"\"\nScript to scan for base stations and start submitt GSM packages on one\nor more the frequencies found using grgsm_livemon_headless to the\nloopback network device\n\nThe idea is to gather GSM packages from as many of the GSM base\nstations and phones in the area as possible, by spreading across as\nmany operators as possible.\n\"\"\"\n\nimport importlib.util\nimport importlib.machinery\nfrom optparse import OptionParser\nimport subprocess\nimport sys\nimport distutils.spawn\n\ndef load_source(modname, filename):\n    loader = importlib.machinery.SourceFileLoader(modname, filename)\n    spec = importlib.util.spec_from_file_location(modname, filename, loader=loader)\n    module = importlib.util.module_from_spec(spec)\n    loader.exec_module(module)\n    return module\n\ndef find_gsm_bases():\n\tgrgsm_scanner_path = distutils.spawn.find_executable(\"grgsm_scanner\")\n\tif grgsm_scanner_path is None:\n\t\tprint(\"Error : Please install gr-gsm\")\n\t\texit(1)\n        \n\tscanner = load_source('scanner', grgsm_scanner_path)\n\tsys.modules['scanner'] = scanner\n\t(options, args) = scanner.argument_parser().parse_args() #FIXME conflic with argument_parser line 93\n\tlist = scanner.do_scan(options.samp_rate, options.band, options.speed,\n\t\toptions.ppm, options.gain, options.args)\n\treturn list\n\ndef select_freqs(serverlist, count = 1):\n\t\"\"\"\n\tSelect the requested number of frequencies, spread across as many base\n\tstation operators (mcc+mnc) as possible, pick the ones with the\n\tstrongest signals.\n\n\tCould consider arfcn, freq, cid, lac, mcc, mnc, ccch_conf, power,\n\tneighbours, cell_arfcns to get as wide spread as possible, but is\n\tonly using mcc, mnc and power at the moment.\n\t\"\"\"\n\n\t# Make shallow copy to avoid modifying the list of the caller when\n\t# removing elements below.\n\tlistcopy = []\n\tfor s in serverlist:\n\t\tlistcopy.append(s)\n\n\tfreqs = []\n\tsorted_list = sorted(listcopy, key=lambda s:(-s.power, s.mcc, s.mnc))\n\n\tfor s in sorted_list:\n\t\tif count > 0:\n\t\t\tfreqs.append(s.freq)\n\t\telse:\n\t\t\tbreak\n\t\tcount = count - 1\n\n\treturn freqs\n\ndef argument_parser():\n\tparser = OptionParser(usage=\"%prog: [options]\")\n\tparser.add_option(\"-n\", \"--numrecv\", dest=\"numrecv\", type=\"int\",\n\t\tdefault=1,\n\t\thelp=\"Set number of livemon processes to start (use one per receiver) [default=%default]\")\n\treturn parser\n\ndef main(options = None):\n\tif options is None:\n\t\t(options, args) = argument_parser().parse_args()\n\n\tprint(\"Locating potential GSM base station frequencies (this can take a few minutes).\")\n\tlist = find_gsm_bases()\n\tprint(\"Found %d frequences\" % len(list))\n\tif len(list) > 0:\n\t\tnumreceivers = options.numrecv\n\t\tfreqs = select_freqs(list, numreceivers)\n\n\t\tprint(\"Listening on the frequencies for %d potential GSM base stations.\" % numreceivers)\n\n\t\t# Make sure a user process can listen on port 4729 by asking\n\t\t# livemon processes to listen on other ports.\n\t\tserverport = 4730\n\t\tprocs = []\n\t\tfor freq in freqs:\n\t\t\tprint(\"Starting livemon for freqency %.0f, server on port %d\" % (freq, serverport))\n\t\t\tproc = subprocess.Popen([\"grgsm_livemon_headless\",\n\t\t\t\t\"--serverport=%d\" % serverport,\n\t\t\t\t\"-f\", str(freq)])\n\t\t\tprocs.append(proc)\n\t\t\tserverport = serverport + 1\n\t\t# Keep the processes in our process group, to make sure they all die when scan-and-livemon is killed\n\t\tfor proc in procs:\n\t\t\tproc.wait()\n\nif __name__ == '__main__':\n\tmain()\n"
        },
        {
          "name": "simple_IMSI-catcher.py",
          "type": "blob",
          "size": 24.064453125,
          "content": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n# Author: Oros\n# Contributors :\n#  purwowd\n#  puyoulu\n#  1kali2kali\n#  petterreinholdtsen\n#  nicoeg\n#  dspinellis\n#  fdl <Frederic.Lehobey@proxience.com>\n#  lapolis\n# 2024-12-19\n# License : CC0 1.0 Universal\n\n\"\"\"\nThis program shows you IMSI numbers of cellphones around you.\n\n\n/! This program was made to understand how GSM network work. Not for bad hacking !\n\"\"\"\n\nimport ctypes\nimport json\nfrom optparse import OptionParser\nimport datetime\nimport io\nimport socket\n\nimsitracker = None\n\n\nclass tracker:\n    imsistate = {}\n    # phones\n    imsis = []  # [IMSI,...]\n    tmsis = {}  # {TMSI:IMSI,...}\n    nb_IMSI = 0  # count the number of IMSI\n\n    mcc = \"\"\n    mnc = \"\"\n    lac = \"\"\n    cell = \"\"\n    country = \"\"\n    brand = \"\"\n    operator = \"\"\n\n    # in minutes\n    purgeTimer = 10  # default 10 min\n\n    show_all_tmsi = False\n    mcc_codes = None\n    sqlite_con = None\n    mysql_con = None\n    mysql_cur = None\n    textfilePath = None\n    output_function = None\n\n    def __init__(self):\n        self.load_mcc_codes()\n        self.track_this_imsi(\"\")\n        self.output_function = self.output\n\n    def set_output_function(self, new_output_function):\n        # New output function need this field :\n        # cpt, tmsi1, tmsi2, imsi, imsicountry, imsibrand, imsioperator, mcc, mnc, lac, cell, timestamp, packet=None\n        self.output_function = new_output_function\n\n    def track_this_imsi(self, imsi_to_track):\n        self.imsi_to_track = imsi_to_track\n        self.imsi_to_track_len = len(imsi_to_track)\n\n    # return something like '0xd9605460'\n    def str_tmsi(self, tmsi):\n        if tmsi != \"\":\n            new_tmsi = \"0x\"\n            for a in tmsi:\n                c = hex(a)\n                if len(c) == 4:\n                    new_tmsi += str(c[2]) + str(c[3])\n                else:\n                    new_tmsi += \"0\" + str(c[2])\n            return new_tmsi\n        else:\n            return \"\"\n\n    def decode_imsi(self, imsi):\n        new_imsi = ''\n        for a in imsi:\n            c = hex(a)\n            if len(c) == 4:\n                new_imsi += str(c[3]) + str(c[2])\n            else:\n                new_imsi += str(c[2]) + \"0\"\n\n        mcc = new_imsi[1:4]\n        mnc = new_imsi[4:6]\n        return new_imsi, mcc, mnc\n\n    # return something like\n    # '208 20 1752XXXXXX', 'France', 'Bouygues', 'Bouygues Telecom'\n    def str_imsi(self, imsi, packet=\"\"):\n        new_imsi, mcc, mnc = self.decode_imsi(imsi)\n        country = \"\"\n        brand = \"\"\n        operator = \"\"\n\n        if mcc in self.mcc_codes:\n            if mnc in self.mcc_codes[mcc]:\n                brand, operator, country, _ = self.mcc_codes[mcc][mnc]\n                new_imsi = f\"{mcc} {mnc} {new_imsi[6:]}\"\n            elif mnc + new_imsi[6:7] in self.mcc_codes[mcc]:\n                mnc += new_imsi[6:7]\n                brand, operator, country, _ = self.mcc_codes[mcc][mnc]\n                new_imsi = f\"{mcc} {mnc} {new_imsi[7:]}\"\n\n        else:\n            country = f\"Unknown MCC {mcc}\"\n            brand = f\"Unknown MNC {mnc}\"\n            operator = f\"Unknown MNC {mnc}\"\n            new_imsi = f\"{mcc} {mnc} {new_imsi[6:]}\"\n\n        try:\n            return new_imsi, country, brand, operator\n        except Exception:\n            # m = \"\"\n            print(\"Error\", packet, new_imsi, country, brand, operator)\n        return \"\", \"\", \"\", \"\"\n\n    def load_mcc_codes(self):\n        # mcc codes form https://en.wikipedia.org/wiki/Mobile_Network_Code\n        with io.open('mcc-mnc/mcc_codes.json', 'r', encoding='utf8') as file:\n            self.mcc_codes = json.load(file)\n\n    def current_cell(self, mcc, mnc, lac, cell):\n        brand = \"\"\n        operator = \"\"\n        country = \"\"\n        if mcc in self.mcc_codes and mnc in self.mcc_codes[mcc]:\n            brand, operator, country, _ = self.mcc_codes[mcc][mnc]\n        else:\n            country = f\"Unknown MCC {mcc}\"\n            brand = f\"Unknown MNC {mnc}\"\n            operator = f\"Unknown MNC {mnc}\"\n        self.mcc = str(mcc)\n        self.mnc = str(mnc)\n        self.lac = str(lac)\n        self.cell = str(cell)\n        self.country = country\n        self.brand = brand\n        self.operator = operator\n\n    def sqlite_file(self, filename):\n        import sqlite3  # Avoid pulling in sqlite3 when not saving\n        print(\"Saving to SQLite database in %s\" % filename)\n        self.sqlite_con = sqlite3.connect(filename)\n        self.sqlite_con.text_factory = str\n        # FIXME Figure out proper SQL type for each attribute\n        self.sqlite_con.execute(\"CREATE TABLE IF NOT EXISTS observations(stamp datetime, tmsi1 text, tmsi2 text, imsi text, imsicountry text, imsibrand text, imsioperator text, mcc integer, mnc integer, lac integer, cell integer);\")\n\n    def text_file(self, filename):\n        txt = open(filename, \"w\")\n        txt.write(\"stamp, tmsi1, tmsi2, imsi, imsicountry, imsibrand, imsioperator, mcc, mnc, lac, cell\\n\")\n        txt.close()\n        self.textfilePath = filename\n\n    def mysql_file(self):\n        import os.path\n        if os.path.isfile('.env'):\n            import MySQLdb as mdb\n            from decouple import config\n            self.mysql_con = mdb.connect(config(\"MYSQL_HOST\"), config(\"MYSQL_USER\"), config(\"MYSQL_PASSWORD\"), config(\"MYSQL_DB\"))\n            self.mysql_cur = self.mysql_con.cursor()\n            # Check MySQL connection\n            if self.mysql_cur:\n                print(\"mysql connection is success :)\")\n            else:\n                print(\"mysql connection is failed!\")\n                exit()\n        else:\n            print(\"create file .env first\")\n            exit()\n\n    def output(self, cpt, tmsi1, tmsi2, imsi, imsicountry, imsibrand, imsioperator, mcc, mnc, lac, cell, now, packet=None):\n        print(f\"{str(cpt):7s} ; {tmsi1:10s} ; {tmsi2:10s} ; {imsi:17s} ; {imsicountry:16s} ; {imsibrand:14s} ; {imsioperator:21s} ; {str(mcc):4s} ; {str(mnc):5s} ; {str(lac):6s} ; {str(cell):6s} ; {now.isoformat():s}\")\n\n    def pfields(self, cpt, tmsi1, tmsi2, imsi, mcc, mnc, lac, cell, packet=None):\n        imsicountry = \"\"\n        imsibrand = \"\"\n        imsioperator = \"\"\n        if imsi:\n            imsi, imsicountry, imsibrand, imsioperator = self.str_imsi(imsi, packet)\n        else:\n            imsi = \"\"\n        now = datetime.datetime.now()\n        self.output_function(cpt, tmsi1, tmsi2, imsi, imsicountry, imsibrand, imsioperator, mcc, mnc, lac, cell, now, packet)\n\n        if self.textfilePath:\n            now = datetime.datetime.now()\n            txt = open(self.textfilePath, \"a\")\n            txt.write(f\"{str(now)}, {tmsi1}, {tmsi2}, {imsi}, {imsicountry}, {imsibrand}, {imsioperator}, {mcc}, {mnc}, {lac}, {cell}\\n\")\n            txt.close()\n\n        if tmsi1 == \"\":\n            tmsi1 = None\n        if tmsi2 == \"\":\n            tmsi2 = None\n\n        if self.sqlite_con:\n            self.sqlite_con.execute(\n               u\"INSERT INTO observations (stamp, tmsi1, tmsi2, imsi, imsicountry, imsibrand, imsioperator, mcc, mnc, lac, cell) \" + \"VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);\",\n               (now, tmsi1, tmsi2, imsi, imsicountry, imsibrand, imsioperator, mcc, mnc, lac, cell)\n            )\n            self.sqlite_con.commit()\n            pass\n\n        if self.mysql_cur:\n            print(\"saving data to db...\")\n            # Example query\n            query = (\"INSERT INTO `imsi` (`tmsi1`, `tmsi2`, `imsi`,`mcc`, `mnc`, `lac`, `cell_id`, `stamp`, `deviceid`) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s)\")\n            arg = (tmsi1, tmsi2, imsi, mcc, mnc, lac, cell, now, \"rtl\")\n            self.mysql_cur.execute(query, arg)\n            self.mysql_con.commit()\n\n    def header(self):\n        print(f\"{'Nb IMSI':7s} ; {'TMSI-1':10s} ; {'TMSI-2':10s} ; {'IMSI':17s} ; {'country':16s} ; {'brand':14s} ; {'operator':21s} ; {'MCC':4s} ; {'MNC':5s} ; {'LAC':6s} ; {'CellId':6s} ; {'Timestamp':s}\")\n\n    def register_imsi(self, arfcn, imsi1=\"\", imsi2=\"\", tmsi1=\"\", tmsi2=\"\", p=\"\"):\n        do_print = False\n        n = ''\n        tmsi1 = self.str_tmsi(tmsi1)\n        tmsi2 = self.str_tmsi(tmsi2)\n        if imsi1:\n            self.imsi_seen(imsi1, arfcn)\n        if imsi2:\n            self.imsi_seen(imsi2, arfcn)\n        if imsi1 and (not self.imsi_to_track or imsi1[:self.imsi_to_track_len] == self.imsi_to_track):\n            if imsi1 not in self.imsis:\n                # new IMSI\n                do_print = True\n                self.imsis.append(imsi1)\n                self.nb_IMSI += 1\n                n = self.nb_IMSI\n            if self.tmsis and tmsi1 and (tmsi1 not in self.tmsis or self.tmsis[tmsi1] != imsi1):\n                # new TMSI to an ISMI\n                do_print = True\n                self.tmsis[tmsi1] = imsi1\n            if self.tmsis and tmsi2 and (tmsi2 not in self.tmsis or self.tmsis[tmsi2] != imsi1):\n                # new TMSI to an ISMI\n                do_print = True\n                self.tmsis[tmsi2] = imsi1\n\n        if imsi2 and (not self.imsi_to_track or imsi2[:self.imsi_to_track_len] == self.imsi_to_track):\n            if imsi2 not in self.imsis:\n                # new IMSI\n                do_print = True\n                self.imsis.append(imsi2)\n                self.nb_IMSI += 1\n                n = self.nb_IMSI\n            if self.tmsis and tmsi1 and (tmsi1 not in self.tmsis or self.tmsis[tmsi1] != imsi2):\n                # new TMSI to an ISMI\n                do_print = True\n                self.tmsis[tmsi1] = imsi2\n            if self.tmsis and tmsi2 and (tmsi2 not in self.tmsis or self.tmsis[tmsi2] != imsi2):\n                # new TMSI to an ISMI\n                do_print = True\n                self.tmsis[tmsi2] = imsi2\n\n                # Unreachable or rarely reached branch? Add unit-test.\n        if not imsi1 and not imsi2 and tmsi1 and tmsi2:\n            if self.tmsis and tmsi2 in self.tmsis:\n                # switch the TMSI\n                do_print = True\n                imsi1 = self.tmsis[tmsi2]\n                self.tmsis[tmsi1] = imsi1\n                del self.tmsis[tmsi2]\n\n        if do_print:\n            if imsi1:\n                self.pfields(str(n), tmsi1, tmsi2, imsi1, str(self.mcc), str(self.mnc), str(self.lac), str(self.cell), p)\n            if imsi2:\n                self.pfields(str(n), tmsi1, tmsi2, imsi2, str(self.mcc), str(self.mnc), str(self.lac), str(self.cell), p)\n\n        if not imsi1 and not imsi2:\n            # Register IMSI as seen if a TMSI believed to\n            # belong to the IMSI is seen.\n            if self.tmsis and tmsi1 and tmsi1 in self.tmsis and \"\" != self.tmsis[tmsi1]:\n                self.imsi_seen(self.tmsis[tmsi1], arfcn)\n            if self.show_all_tmsi:\n                do_print = False\n                if tmsi1 and tmsi1 not in self.tmsis:\n                    do_print = True\n                    self.tmsis[tmsi1] = \"\"\n                if tmsi2 and tmsi2 not in self.tmsis:\n                    do_print = True\n                    self.tmsis[tmsi2] = \"\"\n                if do_print:\n                    self.pfields(str(n), tmsi1, tmsi2, None, str(self.mcc), str(self.mnc), str(self.lac), str(self.cell), p)\n\n    def imsi_seen(self, imsi, arfcn):\n        now = datetime.datetime.utcnow().replace(microsecond=0)\n        imsi, mcc, mnc = self.decode_imsi(imsi)\n        if imsi in self.imsistate:\n            self.imsistate[imsi][\"lastseen\"] = now\n        else:\n            self.imsistate[imsi] = {\n                \"firstseen\": now,\n                \"lastseen\": now,\n                \"imsi\": imsi,\n                \"arfcn\": arfcn,\n            }\n        self.imsi_purge_old()\n\n    def imsi_purge_old(self):\n        now = datetime.datetime.utcnow().replace(microsecond=0)\n        maxage = datetime.timedelta(minutes=self.purgeTimer)\n        limit = now - maxage\n        remove = [imsi for imsi in self.imsistate if limit > self.imsistate[imsi][\"lastseen\"]]\n        for k in remove:\n            del self.imsistate[k]\n        # keys = self.imsistate.keys()\n        # for imsi in keys:\n        #   if limit > self.imsistate[imsi][\"lastseen\"]:\n        #       del self.imsistate[imsi]\n        #       keys = self.imsistate.keys()\n\n\nclass gsmtap_hdr(ctypes.BigEndianStructure):\n    _pack_ = 1\n    # Based on gsmtap_hdr structure in <grgsm/gsmtap.h> from gr-gsm\n    _fields_ = [\n        (\"version\", ctypes.c_ubyte),\n        (\"hdr_len\", ctypes.c_ubyte),\n        (\"type\", ctypes.c_ubyte),\n        (\"timeslot\", ctypes.c_ubyte),\n        (\"arfcn\", ctypes.c_uint16),\n        (\"signal_dbm\", ctypes.c_ubyte),\n        (\"snr_db\", ctypes.c_ubyte),\n        (\"frame_number\", ctypes.c_uint32),\n        (\"sub_type\", ctypes.c_ubyte),\n        (\"antenna_nr\", ctypes.c_ubyte),\n        (\"sub_slot\", ctypes.c_ubyte),\n        (\"res\", ctypes.c_ubyte),\n    ]\n\n    def __repr__(self):\n        return \"%s(version=%d, hdr_len=%d, type=%d, timeslot=%d, arfcn=%d, signal_dbm=%d, snr_db=%d, frame_number=%d, sub_type=%d, antenna_nr=%d, sub_slot=%d, res=%d)\" % (\n            self.__class__, self.version, self.hdr_len, self.type,\n            self.timeslot, self.arfcn, self.signal_dbm, self.snr_db,\n            self.frame_number, self.sub_type, self.antenna_nr, self.sub_slot,\n            self.res,\n        )\n\n\n# return mcc mnc, lac, cell, country, brand, operator\ndef find_cell(gsm, udpdata, t=None):\n    # find_cell() update all following variables\n    global mcc\n    global mnc\n    global lac\n    global cell\n    global country\n    global brand\n    global operator\n\n    \"\"\"\n    Dump of a packet from wireshark\n\n    /! there are an offset of 0x2a\n    0x12 (from the code) + 0x2a (offset) == 0x3c (in documentation's dump)\n\n            0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f\n    0000   00 00 00 00 00 00 00 00 00 00 00 00 08 00 45 00\n    0010   00 43 9a 6b 40 00 40 11 a2 3c 7f 00 00 01 7f 00\n    0020   00 01 ed d1 12 79 00 2f fe 42 02 04 01 00 00 00\n    0030   cc 00 00 07 9b 2c 01 00 00 00 49 06 1b 61 9d 02\n    0040   f8 02 01 9c c8 03 1e 53 a5 07 79 00 00 80 01 40\n    0050   db\n\n    Channel Type: BCCH (1)\n                            6\n    0030                     01\n\n    0x36 - 0x2a = position p[0x0c]\n\n\n    Message Type: System Information Type 3\n                                                c\n    0030                                       1b\n\n    0x3c - 0x2a = position p[0x12]\n\n    Cell CI: 0x619d (24989)\n                                                d  e\n    0030                                          61 9d\n\n    0x3d - 0x2a = position p[0x13]\n    0x3e - 0x2a = position p[0x14]\n\n    Location Area Identification (LAI) - 208/20/412\n    Mobile Country Code (MCC): France (208) 0x02f8\n    Mobile Network Code (MNC): Bouygues Telecom (20) 0xf802\n    Location Area Code (LAC): 0x019c (412)\n            0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f\n    0030                                                02\n    0040   f8 02 01 9c\n    \"\"\"\n    if gsm.sub_type == 0x01:  # Channel Type == BCCH (0)\n        p = bytearray(udpdata)\n        if p[0x12] == 0x1b:  # (0x12 + 0x2a = 0x3c) Message Type: System Information Type 3\n            # FIXME\n            m = hex(p[0x15])\n            if len(m) < 4:\n                mcc = m[2] + '0'\n            else:\n                mcc = m[3] + m[2]\n            mcc += str(p[0x16] & 0x0f)\n\n            # FIXME not works with mnc like 005 or 490\n            m = hex(p[0x17])\n            if len(m) < 4:\n                mnc = m[2] + '0'\n            else:\n                mnc = m[3] + m[2]\n\n            lac = p[0x18] * 256 + p[0x19]\n            cell = p[0x13] * 256 + p[0x14]\n            t.current_cell(mcc, mnc, lac, cell)\n\n\ndef find_imsi(udpdata, t=None):\n    if t is None:\n        t = imsitracker\n\n    # Create object representing gsmtap header in UDP payload\n    gsm = gsmtap_hdr.from_buffer_copy(udpdata)\n\n    if gsm.sub_type == 0x1:  # Channel Type == BCCH (0)\n        # Update global cell info if found in package\n        # FIXME : when you change the frequency, this informations is\n        # not immediately updated.  So you could have wrong values when\n        # printing IMSI :-/\n        find_cell(gsm, udpdata, t=t)\n    else:  # Channel Type != BCCH (0)\n        p = bytearray(udpdata)\n        tmsi1 = \"\"\n        tmsi2 = \"\"\n        imsi1 = \"\"\n        imsi2 = \"\"\n        if p[0x12] == 0x21:  # Message Type: Paging Request Type 1\n            if p[0x14] == 0x08 and (p[0x15] & 0x1) == 0x1:  # Channel 1: TCH/F (Full rate) (2)\n                # Mobile Identity 1 Type: IMSI (1)\n                \"\"\"\n                        0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f\n                0000   00 00 00 00 00 00 00 00 00 00 00 00 08 00 45 00\n                0010   00 43 1c d4 40 00 40 11 1f d4 7f 00 00 01 7f 00\n                0020   00 01 c2 e4 12 79 00 2f fe 42 02 04 01 00 00 00\n                0030   c9 00 00 16 21 26 02 00 07 00 31 06 21 00 08 XX\n                0040   XX XX XX XX XX XX XX 2b 2b 2b 2b 2b 2b 2b 2b 2b\n                0050   2b\n                XX XX XX XX XX XX XX XX = IMSI\n                \"\"\"\n                imsi1 = p[0x15:][:8]\n                # p[0x10] == 0x59 = l2 pseudo length value: 22\n                if p[0x10] == 0x59 and p[0x1E] == 0x08 and (p[0x1F] & 0x1) == 0x1:  # Channel 2: TCH/F (Full rate) (2)\n                    # Mobile Identity 2 Type: IMSI (1)\n                    \"\"\"\n                        0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f\n                0000   00 00 00 00 00 00 00 00 00 00 00 00 08 00 45 00\n                0010   00 43 90 95 40 00 40 11 ac 12 7f 00 00 01 7f 00\n                0020   00 01 b4 1c 12 79 00 2f fe 42 02 04 01 00 00 00\n                0030   c8 00 00 16 51 c6 02 00 08 00 59 06 21 00 08 YY\n                0040   YY YY YY YY YY YY YY 17 08 XX XX XX XX XX XX XX\n                0050   XX\n                YY YY YY YY YY YY YY YY = IMSI 1\n                XX XX XX XX XX XX XX XX = IMSI 2\n                    \"\"\"\n                    imsi2 = p[0x1F:][:8]\n                elif p[0x10] == 0x4d and p[0x1E] == 0x05 and p[0x1F] == 0xf4:  # Channel 2: TCH/F (Full rate) (2)\n                    # Mobile Identity - Mobile Identity 2 - IMSI\n                    \"\"\"\n                        0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f\n                0000   00 00 00 00 00 00 00 00 00 00 00 00 08 00 45 00\n                0010   00 43 f6 92 40 00 40 11 46 15 7f 00 00 01 7f 00\n                0020   00 01 ab c1 12 79 00 2f fe 42 02 04 01 00 00 00\n                0030   d8 00 00 23 3e be 02 00 05 00 4d 06 21 a0 08 YY\n                0040   YY YY YY YY YY YY YY 17 05 f4 XX XX XX XX 2b 2b\n                0050   2b\n                YY YY YY YY YY YY YY YY = IMSI 1\n                XX XX XX XX = TMSI\n                    \"\"\"\n                    tmsi1 = p[0x20:][:4]\n\n                t.register_imsi(gsm.arfcn, imsi1, imsi2, tmsi1, tmsi2, p)\n\n            elif p[0x1B] == 0x08 and (p[0x1C] & 0x1) == 0x1:  # Channel 2: TCH/F (Full rate) (2)\n                # Mobile Identity 2 Type: IMSI (1)\n                \"\"\"\n                        0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f\n                0000   00 00 00 00 00 00 00 00 00 00 00 00 08 00 45 00\n                0010   00 43 57 8e 40 00 40 11 e5 19 7f 00 00 01 7f 00\n                0020   00 01 99 d4 12 79 00 2f fe 42 02 04 01 00 00 00\n                0030   c7 00 00 11 05 99 02 00 03 00 4d 06 21 00 05 f4\n                0040   yy yy yy yy 17 08 XX XX XX XX XX XX XX XX 2b 2b\n                0050   2b\n                yy yy yy yy = TMSI/P-TMSI - Mobile Identity 1\n                XX XX XX XX XX XX XX XX = IMSI\n                \"\"\"\n                tmsi1 = p[0x16:][:4]\n                imsi2 = p[0x1C:][:8]\n                t.register_imsi(gsm.arfcn, imsi1, imsi2, tmsi1, tmsi2, p)\n\n            elif p[0x14] == 0x05 and (p[0x15] & 0x07) == 4:  # Mobile Identity - Mobile Identity 1 - TMSI/P-TMSI\n                \"\"\"\n                        0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f\n                0000   00 00 00 00 00 00 00 00 00 00 00 00 08 00 45 00\n                0010   00 43 b3 f7 40 00 40 11 88 b0 7f 00 00 01 7f 00\n                0020   00 01 ce 50 12 79 00 2f fe 42 02 04 01 00 03 fd\n                0030   d1 00 00 1b 03 5e 05 00 00 00 41 06 21 00 05 f4\n                0040   XX XX XX XX 17 05 f4 YY YY YY YY 2b 2b 2b 2b 2b\n                0050   2b\n                XX XX XX XX = TMSI/P-TMSI - Mobile Identity 1\n                YY YY YY YY = TMSI/P-TMSI - Mobile Identity 2\n                \"\"\"\n                tmsi1 = p[0x16:][:4]\n                if p[0x1B] == 0x05 and (p[0x1C] & 0x07) == 4:  # Mobile Identity - Mobile Identity 2 - TMSI/P-TMSI\n                    tmsi2 = p[0x1D:][:4]\n                else:\n                    tmsi2 = \"\"\n\n                t.register_imsi(gsm.arfcn, imsi1, imsi2, tmsi1, tmsi2, p)\n\n        elif p[0x12] == 0x22:  # Message Type: Paging Request Type 2\n            if p[0x1D] == 0x08 and (p[0x1E] & 0x1) == 0x1:  # Mobile Identity 3 Type: IMSI (1)\n                \"\"\"\n                        0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f\n                0000   00 00 00 00 00 00 00 00 00 00 00 00 08 00 45 00\n                0010   00 43 1c a6 40 00 40 11 20 02 7f 00 00 01 7f 00\n                0020   00 01 c2 e4 12 79 00 2f fe 42 02 04 01 00 00 00\n                0030   c9 00 00 16 20 e3 02 00 04 00 55 06 22 00 yy yy\n                0040   yy yy zz zz zz 4e 17 08 XX XX XX XX XX XX XX XX\n                0050   8b\n                yy yy yy yy = TMSI/P-TMSI - Mobile Identity 1\n                zz zz zz zz = TMSI/P-TMSI - Mobile Identity 2\n                XX XX XX XX XX XX XX XX = IMSI\n                \"\"\"\n                tmsi1 = p[0x14:][:4]\n                tmsi2 = p[0x18:][:4]\n                imsi2 = p[0x1E:][:8]\n                t.register_imsi(gsm.arfcn, imsi1, imsi2, tmsi1, tmsi2, p)\n\n\ndef udpserver(port, prn):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    server_address = ('localhost', port)\n    sock.bind(server_address)\n    while True:\n        udpdata, address = sock.recvfrom(4096)\n        if prn:\n            prn(udpdata)\n\n\ndef find_imsi_from_pkt(p):\n    udpdata = bytes(p[UDP].payload)\n    find_imsi(udpdata)\n\n\nif __name__ == \"__main__\":\n    imsitracker = tracker()\n    parser = OptionParser(usage=\"%prog: [options]\")\n    parser.add_option(\"-a\", \"--alltmsi\", action=\"store_true\", dest=\"show_all_tmsi\", help=\"Show TMSI who haven't got IMSI (default  : false)\")\n    parser.add_option(\"-i\", \"--iface\", dest=\"iface\", default=\"lo\", help=\"Interface (default : lo)\")\n    parser.add_option(\"-m\", \"--imsi\", dest=\"imsi\", default=\"\", type=\"string\", help='IMSI to track (default : None, Example: 123456789101112 or \"123 45 6789101112\")')\n    parser.add_option(\"-p\", \"--port\", dest=\"port\", default=\"4729\", type=\"int\", help=\"Port (default : 4729)\")\n    parser.add_option(\"-s\", \"--sniff\", action=\"store_true\", dest=\"sniff\", help=\"sniff on interface instead of listening on port (require root/suid access)\")\n    parser.add_option(\"-w\", \"--sqlite\", dest=\"sqlite\", default=None, type=\"string\", help=\"Save observed IMSI values to specified SQLite file\")\n    parser.add_option(\"-t\", \"--txt\", dest=\"txt\", default=None, type=\"string\", help=\"Save observed IMSI values to specified TXT file\")\n    parser.add_option(\"-z\", \"--mysql\", action=\"store_true\", dest=\"mysql\", help=\"Save observed IMSI values to specified MYSQL DB (copy .env.dist to .env and edit it)\")\n    (options, args) = parser.parse_args()\n\n    if options.sqlite:\n        imsitracker.sqlite_file(options.sqlite)\n\n    if options.txt:\n        imsitracker.text_file(options.txt)\n\n    if options.mysql:\n        imsitracker.mysql_file()\n\n    imsitracker.show_all_tmsi = options.show_all_tmsi\n    imsi_to_track = \"\"\n    if options.imsi:\n        imsi = \"9\" + options.imsi.replace(\" \", \"\")\n        imsi_to_track_len = len(imsi)\n        if imsi_to_track_len % 2 == 0 and imsi_to_track_len > 0 and imsi_to_track_len < 17:\n            for i in range(0, imsi_to_track_len - 1, 2):\n                imsi_to_track += chr(int(imsi[i + 1]) * 16 + int(imsi[i]))\n            imsi_to_track_len = len(imsi_to_track)\n        else:\n            print(\"Wrong size for the IMSI to track!\")\n            print(\"Valid sizes :\")\n            print(\"123456789101112\")\n            print(\"1234567891011\")\n            print(\"12345678910\")\n            print(\"123456789\")\n            print(\"1234567\")\n            print(\"12345\")\n            print(\"123\")\n            exit(1)\n    imsitracker.track_this_imsi(imsi_to_track)\n    if options.sniff:\n        from scapy.all import sniff, UDP\n        imsitracker.header()\n        sniff(iface=options.iface, filter=f\"port {options.port} and not icmp and udp\", prn=find_imsi_from_pkt, store=0)\n    else:\n        imsitracker.header()\n        udpserver(port=options.port, prn=find_imsi)\n"
        }
      ]
    }
  ]
}