{
  "metadata": {
    "timestamp": 1736560367899,
    "page": 905,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjkxMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "qiwsir/algorithm",
      "stars": 3301,
      "defaultBranch": "master",
      "files": [
        {
          "name": "2d_list.md",
          "type": "blob",
          "size": 3.59375,
          "content": "#问题\n\n定义一个20*5的二维数组，用来存储某班级20位学员的5门课的成绩；这5门课按存储顺序依次为：core C++，coreJava，Servlet，JSP和EJB。\n\n（1）循环给二维数组的每一个元素赋0~100之间的随机整数。\n\n（2）按照列表的方式输出这些学员的每门课程的成绩。\n\n（3）要求编写程序求每个学员的总分，将其保留在另外一个一维数组中。\n\n（4）要求编写程序求所有学员的某门课程的平均分。\n\n#解决（python）\n\n\t#! /usr/bin/env python\n\t#coding:utf-8\n\t\n\tfrom __future__ import division\n\timport random\n\t\n\t\n\tdef score(score_list,course_list,student_num):\n\t    course_num = len(course_list)\n\t    \n\t    every_score = [[score_list[j][i] for j in range(course_num)] for i in range(student_num)]\n\t    \n\t    every_total = [sum(every_score[i]) for i in range(student_num)]\n\t    \n\t    ave_course = [sum(score_list[i])/len(score_list[i]) for i in range(len(score_list))]\n\t    \n\t    return (every_score,every_total,ave_course)\n\t\n\tif __name__==\"__main__\":\n\t    \n\t    course_list = [\"C++\",\"Java\",\"Servlet\",\"JSP\",\"EJB\"]\n\t    student_num = 20\n\t    \n\t    score_list = [[random.randint(0,100) for i in range(student_num)] for j in range(len(course_list))]\n\t    for i in range(len(course_list)):\n\t        print \"score of every one in %s:\"%course_list[i]\n\t        print score_list[i]\n\t\n\t    every_score,every_total,ave_one_course = score(score_list,course_list,student_num)\n\t    print \"\\n\"\n\t    print \"NEXT IS EVERY ONE SCORE IN EVERY COURSE:\"\n\t    for name in course_list:\n\t        print name,\n\t    print \"\\t\"\n\t    print every_score\n\t    print \"\\n\"\n\t    print \"every one all score:\\t\",every_total\n\t    print \"every course of average score:\\t\",ave_one_course\n\n##qiwsir#gmail.com (# to @)\n\n#解法 (racket 5.2.1)\n\n```racket\n#lang racket\n\n(define (2d-list)\n  (let*\n    ([rand-100 (lambda () (random 101))]\n     [nth-picker (lambda (n) (lambda (l) (list-ref l n)))]\n     [average (lambda (number-list) (exact->inexact (/ (apply + number-list) (length number-list))))]\n     [course-list (list \"coreC++\" \"coreJava\" \"Servlet\" \"JSP\" \"EJB\")]\n     [score-list (for/list ([i 20]) (for/list ([j 5]) (rand-100)))]\n     [score-by-course-list (for/list ([i 5]) (list ((nth-picker i) course-list) (map (nth-picker i) score-list)))]\n     [score-by-student-list (for/list ([i 20]) (list-ref score-list i))]\n     [total-by-student-list (for/list ([i 20]) (apply + (list-ref score-list i)))]\n     [average-by-course-list (for/list ([i 5]) (list ((nth-picker i) course-list) (average (map (nth-picker i) score-list))))])\n    (for ([i 5]) \n      (display \"score of every one in \")\n      (displayln (first ((nth-picker i) score-by-course-list)))\n      (displayln (second ((nth-picker i) score-by-course-list))))\n    (displayln \"\")\n    (displayln \"NEXT IS EVERY ONE SCORE IN EVERY COURSE: \")\n    (displayln course-list)\n    (for ([i 10]) \n      (displayln (list-ref score-by-student-list i)))\n    (displayln \"\")\n    (displayln \"every one all score: \")\n    (displayln total-by-student-list)\n    (displayln \"\")\n    (displayln \"every course of average score: \")\n    (displayln average-by-course-list)))\n\n; 调用函数, 正常时应输出类似如下结果\n;score of every one in coreC++\n;(12 58 60 28 78 23 34 83 19 83 78 26 51 94 93 74 53 89 8 23)\n;... ...\n;NEXT IS EVERY ONE SCORE IN EVERY COURSE: \n;(coreC++ coreJava Servlet JSP EJB)\n;(12 49 75 88 68)\n;(58 78 6 88 81)\n;... ...\n;every one all score: \n;(292 311 370 241 289 250 254 258 147 232 271 170 224 248 317 286 246 270 186 212)\n;\n;every course of average score: \n;((coreC++ 53.35) (coreJava 53.9) (Servlet 51.95) (JSP 49.6) (EJB 44.9))\n(2d-list)\n\n```\n"
        },
        {
          "name": "2d_list.py",
          "type": "blob",
          "size": 1.65625,
          "content": "#! /usr/bin/env python\n#coding:utf-8\n\n\"\"\"\n问题\n定义一个20*5的二维数组，用来存储某班级20位学员的5门课的成绩；这5门课按存储顺序依次为：core C++，coreJava，Servlet，JSP和EJB。\n（1）循环给二维数组的每一个元素赋0~100之间的随机整数。\n（2）按照列表的方式输出这些学员的每门课程的成绩。\n（3）要求编写程序求每个学员的总分，将其保留在另外一个一维数组中。\n（4）要求编写程序求所有学员的某门课程的平均分。\n\"\"\"\nfrom __future__ import division\nimport random\n\n\ndef score(score_list,course_list,student_num):\n    course_num = len(course_list)\n    \n    every_score = [[score_list[j][i] for j in range(course_num)] for i in range(student_num)]\n    \n    every_total = [sum(every_score[i]) for i in range(student_num)]\n    \n    ave_course = [sum(score_list[i])/len(score_list[i]) for i in range(len(score_list))]\n    \n    return (every_score,every_total,ave_course)\n\nif __name__==\"__main__\":\n    \n    course_list = [\"C++\",\"Java\",\"Servlet\",\"JSP\",\"EJB\"]\n    student_num = 20\n    \n    score_list = [[random.randint(0,100) for i in range(student_num)] for j in range(len(course_list))]\n    for i in range(len(course_list)):\n        print \"score of every one in %s:\"%course_list[i]\n        print score_list[i]\n\n    every_score,every_total,ave_one_course = score(score_list,course_list,student_num)\n    print \"\\n\"\n    print \"NEXT IS EVERY ONE SCORE IN EVERY COURSE:\"\n    for name in course_list:\n        print name,\n    print \"\\t\"\n    print every_score\n    print \"\\n\"\n    print \"every one all score:\\t\",every_total\n    print \"every course of average score:\\t\",ave_one_course\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 6.7216796875,
          "content": "\n如果要成为一个有一定水平的程序员，算法是必须要会的。算法，让你的程序变得更有灵气。\n\n这里集中了一些算法问题，供看官参考。\n\n也殷切盼望看官能够参与某些算法问题解决的优化。\n\n联系方式：qiwsir (at) gmail.com\n\n官方网站：http://qiwsir.github.io\n\n#目录\n\n- [对一个二维数组的操作](https://github.com/qiwsir/algorithm/blob/master/2d_list.md)，[源码](https://github.com/qiwsir/algorithm/blob/master/2d_list.py)\n- [将数组中的元素依次前移](https://github.com/qiwsir/algorithm/blob/master/ahead_one_step.md)，[源码](https://github.com/qiwsir/algorithm/blob/master/ahead_one_step.py)\n- [求list的平均分并排序](https://github.com/qiwsir/algorithm/blob/master/average_score.md)，[源码](https://github.com/qiwsir/algorithm/blob/master/average_score.py)\n- [用阿拉伯乘法解决大整数相乘问题](https://github.com/qiwsir/algorithm/blob/master/big_int.md)，[源码](https://github.com/qiwsir/algorithm/blob/master/big_int.py)\n- [二分查找的python模块](https://github.com/qiwsir/algorithm/blob/master/bin_search.md)，[源码](https://github.com/qiwsir/algorithm/blob/master/bin_search.py)\n- [二叉树查找之基本思想](https://github.com/qiwsir/algorithm/blob/master/binary_tree.md)，[源码](https://github.com/qiwsir/algorithm/blob/master/binary_tree.py)，[源码2](https://github.com/qiwsir/algorithm/blob/master/binary_tree2.py)\n- [二叉树查找之python模块](https://github.com/qiwsir/algorithm/blob/master/binary_tree_python.md)\n- [二叉树之递归方法遍历](https://github.com/qiwsir/algorithm/blob/master/binary_tree_traversal.md)，[源码](https://github.com/qiwsir/algorithm/blob/master/binary_tree_traversal.py)\n- [兑换硬币问题之贪婪算法解决](https://github.com/qiwsir/algorithm/blob/master/change_coin.md)，[源码(源码中还包含另外一种动态规划兑换硬币方法)](https://github.com/qiwsir/algorithm/blob/master/change_coin.py)\n- [索引查找概述](https://github.com/qiwsir/algorithm/blob/master/index_search.md)\n- [索引查找之Whoosh使用详解](https://github.com/qiwsir/algorithm/blob/master/index_search_whoosh.md)\n- [Whoosh之中文分词全文查找源码](https://github.com/qiwsir/algorithm/blob/master/chinesetokenizer.py)\n- [删除一个字符串中连续一次以上出现的空格](https://github.com/qiwsir/algorithm/blob/master/delete_space.md)，[源码](https://github.com/qiwsir/algorithm/blob/master/delete_space.py)\n- [最短路径问题的Dijkstra算法](https://github.com/qiwsir/algorithm/blob/master/dijkstra_algorithm.md)，[源码](https://github.com/qiwsir/algorithm/blob/master/dijkstra_algorithm.py)\n- [实现根据要求保留小数位数的除法模块](https://github.com/qiwsir/algorithm/blob/master/divide.py)\n- [整数list，将偶数放到前面，奇数放到后面](https://github.com/qiwsir/algorithm/blob/master/even_odd.md)，[源码](https://github.com/qiwsir/algorithm/blob/master/even_odd.py)\n- [斐波那契数列的多种实现方式](https://github.com/qiwsir/algorithm/blob/master/fibonacci.md)，[源码](https://github.com/qiwsir/algorithm/blob/master/fibonacci.py)\n- [折半查询查找list中某元素位置](https://github.com/qiwsir/algorithm/blob/master/half_search.md)，[源码](https://github.com/qiwsir/algorithm/blob/master/half_search.py)\n- [排序之用python堆heapq模块](https://github.com/qiwsir/algorithm/blob/master/heap_sort.py)\n- [排序之归并方法](https://github.com/qiwsir/algorithm/blob/master/merge_sort.md)，[源码](https://github.com/qiwsir/algorithm/blob/master/merge_sort.py)\n- [排序之heapq模块详解](https://github.com/qiwsir/algorithm/blob/master/heapq.md)\n- [排序之python sorted性能分析](https://github.com/qiwsir/algorithm/blob/master/python_sort.md)\n- [排序之快速排序算法](https://github.com/qiwsir/algorithm/blob/master/quick_sort.md)，[源码](https://github.com/qiwsir/algorithm/blob/master/quick_sort.py)\n- [排序算法的比较和选择](https://github.com/qiwsir/algorithm/blob/master/chose_sort_algorithm.md)\n- [按照指定字母顺序排序](https://github.com/qiwsir/algorithm/blob/master/sort_chared.md)，[源码](https://github.com/qiwsir/algorithm/blob/master/sort_chared.py)\n- [将一个整数分拆为若干整数和](https://github.com/qiwsir/algorithm/blob/master/int_divide.md)，[源码](https://github.com/qiwsir/algorithm/blob/master/int_divide.py)，[源码2,对前面问题的深化](https://github.com/qiwsir/algorithm/blob/master/int_divide2.py)\n- [判断一个数是否为素数的多种方法](https://github.com/qiwsir/algorithm/blob/master/is_prime.md)，[源码](https://github.com/qiwsir/algorithm/blob/master/is_prime.py)\n- [将list中的数字组合成最小的整数](https://github.com/qiwsir/algorithm/blob/master/joint_int.md)，[源码](https://github.com/qiwsir/algorithm/blob/master/joint_int.py)，[源码2](https://github.com/qiwsir/algorithm/blob/master/kruskal_algorithm2.py)\n- [无向图最小生成树Kruskal算法](https://github.com/qiwsir/algorithm/blob/master/kruskal_algorithm.md)，[源码](https://github.com/qiwsir/algorithm/blob/master/kruskal_algorithm.py)\n- [无向图最小生成树的Prim算法](https://github.com/qiwsir/algorithm/blob/master/prim_algorithm.md)，[源码](https://github.com/qiwsir/algorithm/blob/master/prim_algorithm.py)\n- [LUA按照指定字符分割字符串](https://github.com/qiwsir/algorithm/blob/master/lua_string_to_table.lua)\n- [查找字符串中出现最多的字符和个数](https://github.com/qiwsir/algorithm/blob/master/most_char_num.md)，[源码](https://github.com/qiwsir/algorithm/blob/master/most_char_num.py)，[源码2](https://github.com/qiwsir/algorithm/blob/master/most_char_num2.py)\n- [list中数字的和、最值、均值](https://github.com/qiwsir/algorithm/blob/master/operate_int_list.md)，[源码](https://github.com/qiwsir/algorithm/blob/master/operate_int_list.py)\n- [寻找完全数](https://github.com/qiwsir/algorithm/blob/master/perfect_number.md)，[源码](https://github.com/qiwsir/algorithm/blob/master/perfect_number.py)\n- [计算余数](https://github.com/qiwsir/algorithm/blob/master/random_list.md)，[源码](https://github.com/qiwsir/algorithm/blob/master/random_list.py)\n- [删除list中的重复元素](https://github.com/qiwsir/algorithm/blob/master/same_element_in_list.md)，[源码](https://github.com/qiwsir/algorithm/blob/master/same_element_in_list.py)\n- [将字符串写成驼峰样式](https://github.com/qiwsir/algorithm/blob/master/string_to_hump.md)，[源码](https://github.com/qiwsir/algorithm/blob/master/string_to_hump.py)\n- [九宫格问题](https://github.com/qiwsir/algorithm/blob/master/sudoku.md)，[源码](https://github.com/qiwsir/algorithm/blob/master/sudoku.py)\n\n##内容还在不断更新增加，请关注算法问题\n"
        },
        {
          "name": "ahead_one_step.md",
          "type": "blob",
          "size": 0.9345703125,
          "content": "#问题\n\n定义一个int型的一维数组，包含10个元素，分别赋值为1~10， 然后将数组中的元素都向前移一个位置，\n\n即，a[0]=a[1],a[1]=a[2],…最后一个元素的值是原来第一个元素的值，然后输出这个数组。\n\n#解决(Python)\n\n\t#!/usr/bin/env python\n\t#coding:utf-8\n\t\n\t\n\tdef ahead_one():\n\t    a = [i for i in range(10)]\n\t    b = a.pop(0)\n\t    a.append(b)\n\t    return a\n\t\n\tif __name__ ==\"__main__\":\n\t    print ahead_one()\n\n#解决(racket 5.2.1)\n\n```racket\n#lang racket\n\n; 定义函数 ahead-one\n; 输入为一个整数列表 int-list，假设其长度为 N\n; 输出为长度相同的整数列表，其第 N 位的元素为 int-list 的第 1 位的元素，\n; 其 1~N-1 位的元素为 int-list 的第 2~N 位的元素\n(define (ahead-one int-list)\n  (append (rest int-list) (list (first int-list))))\n\n; 函数调用，正常运行时应输出 '(2 3 4 5 6 7 8 9 10 1)\n(ahead-one (list 1 2 3 4 5 6 7 8 9 10))\n```\n"
        },
        {
          "name": "ahead_one_step.py",
          "type": "blob",
          "size": 0.44140625,
          "content": "#!/usr/bin/env python\n#coding:utf-8\n\n\"\"\"\n问题：\n\n定义一个int型的一维数组，包含10个元素，分别赋值为1~10， 然后将数组中的元素都向前移一个位置，\n\n即，a[0]=a[1],a[1]=a[2],…最后一个元素的值是原来第一个元素的值，然后输出这个数组。\n\"\"\"\n\ndef ahead_one():\n    a = [i for i in range(1, 11)]\n    b = a.pop(0)\n    a.append(b)\n    return a\n\nif __name__ ==\"__main__\":\n    print ahead_one()\n"
        },
        {
          "name": "average_score.md",
          "type": "blob",
          "size": 0.9375,
          "content": "#问题\n\n定义一个int型的一维数组，包含40个元素，用来存储每个学员的成绩，循环产生40个0~100之间的随机整数，\n(1)将它们存储到一维数组中，然后统计成绩低于平均分的学员的人数，并输出出来。\n(2)将这40个成绩按照从高到低的顺序输出出来。\n\n\n#解决（python）\n\n\t#! /usr/bin python\n\t#coding:utf-8\n\t\n\t\n\tfrom __future__ import division     #实现精确的除法，例如4/3=1.333333\n\timport random\n\t\n\tdef make_score(num):\n\t    score = [random.randint(0,100) for i in range(num)]\n\t    return score\n\t\n\tdef less_average(score):\n\t    num = len(score)\n\t    sum_score = sum(score)\n\t    ave_num = sum_score/num\n\t    less_ave = [i for i in score if i<ave_num]\n\t    return len(less_ave)\n\t\n\tif __name__==\"__main__\":\n\t    score = make_score(40)\n\t    print \"the number of less average is:\",less_average(score)\n\t    print \"the every socre is[from big to small]:\",sorted(score,reverse=True)\n"
        },
        {
          "name": "average_score.py",
          "type": "blob",
          "size": 0.9931640625,
          "content": "#! /usr/bin python\n#coding:utf-8\n\n\"\"\"\n问题：\n定义一个int型的一维数组，包含40个元素，用来存储每个学员的成绩，循环产生40个0~100之间的随机整数，\n(1)将它们存储到一维数组中，然后统计成绩低于平均分的学员的人数，并输出出来。\n(2)将这40个成绩按照从高到低的顺序输出出来。\n\"\"\"\n\n#no need to import division from future just change num to float(num) \nimport random\n\ndef make_score(num):\n    score = [random.randint(0,100) for i in range(num)]\n    return score\n\ndef less_average(score):\n    num = len(score)\n    sum_score = sum(score)\n    ave_num = sum_score/float(num)\n    less_ave = [i for i in score if i<ave_num]\n    return (ave_num,len(less_ave))\n\nif __name__==\"__main__\":\n    score = make_score(40)\n    average_num,less_num = less_average(score)\n    print 'the score of average is:',average_num\n    print \"the number of less average is:\",less_num\n    print \"the every score is[from big to small]:\",sorted(score,reverse=True)\n"
        },
        {
          "name": "big_int.md",
          "type": "blob",
          "size": 4.0546875,
          "content": "#问题\n\n大整数相乘\n\n#思路说明\n\n对于大整数计算，一般都要用某种方法转化，否则会溢出。但是python无此担忧了。\n\nPython支持**“无限精度”的整数，**一般情况下不用考虑整数溢出的问题，而且Python Int类型与任意精度的Long整数类可以无缝转换，超过Int 范围的情况都将转换成Long类型。\n\n例如：\n\n    >>> 2899887676637907866*1788778992788348277389943\n\n    5187258157415700236034169791337062588991638L\n\n注意：前面的“无限精度”是有引号的。事实上也是有限制的，对于32位的机器，其上限是：2^32-1。真的足够大了。\n\n为什么Python能够做到呢？请有兴趣刨根问底的去看Python的有关源码。本文不赘述。\n\n在其它语言中，通常用“分治法”解决大整数相乘问题。\n\n但是，这里提供一个非常有意思的计算两个整数相乘的方法，算是做为大整数相乘的演示。\n\n两个整数相乘：**阿拉伯乘法**。关于这个乘法的详细描述，请看：[http://ualr.edu/lasmoller/medievalmult.html](http://ualr.edu/lasmoller/medievalmult.html)\n\n#解决（Python）\n\n\t#!/usr/bin/env python\n\t#coding:utf-8\n\t\n\t#阿拉伯乘法\n\tdef arabic_multiplication(num1,num2):\n\t    num_lst1 = [int(i) for i in str(num1)]  #将int类型的123，转化为list类型的[1,2,3]，每个元素都是int类型\n\t    num_lst2 = [int(i) for i in str(num2)]\n\t\n\t    #两个list中整数两两相乘\n\t    int_martix = [[i*j for i in num_lst1] for j in num_lst2]\n\t    \n\t    #将上述元素为数字的list转化为元素类型是str，主要是将9-->'09'\n\t    str_martix = [map(convert_to_str,int_martix[i]) for i in range(len(int_martix))]\n\t    \n\t    #将上述各个list中的两位数字分开：['01','29','03']-->[0,2,0],[1,9,3]\n\t    martix = [[int(str_martix[i][j][z]) for j in range(len(str_martix[i]))] for i in range(len(str_martix)) for z in range(2)]\n\t    \n\t    #计算阿拉伯乘法表的左侧开始各项和\n\t    sum_left = summ_left(martix)\n\t\n\t    #计算阿拉伯乘法表的底部开始各项和\n\t    sum_end = summ_end(martix)\n\t\n\t    #将上述两个结果合并后翻转\n\t    sum_left.extend(sum_end)\n\t    sum_left.reverse()\n\t\n\t    #取得各个和的个位的数字（如果进位则加上）\n\t    result = take_digit(sum_left)\n\t    \n\t    #翻转结果并合并为一个结果字符串数值\n\t    result.reverse()\n\t    int_result = \"\".join(result)\n\t    print \"%d*%d=\"%(num1,num2)\n\t    print int_result\n\t\n\t\n\t#将int类型转化为str类型，9-->'09'\n\t\n\tdef convert_to_str(num):\n\t    if num<10:\n\t        return \"0\"+str(num)\n\t    else:\n\t        return str(num)\n\t\n\t\n\t#计算阿拉伯乘法表格左侧开始的各项之和\n\t\n\tdef summ_left(lst):\n\t    summ = []\n\t    x = [i for i in range(len(lst))]\n\t    y = [j for j in range(len(lst[0]))]\n\t    sx = [i for i in x if i%2==0]\n\t    for i in sx:\n\t        s=0\n\t        j=0\n\t        while i>=0 and j<=y[-1]:\n\t            s = s+ lst[i][j]\n\t            if i%2==1:\n\t                j = j+1\n\t            else:\n\t                j = j\n\t            i = i-1\n\t        summ.append(s)\n\t    return summ\n\t\n\t\n\t\n\t#计算阿拉伯乘法表格底部开始的各项之和\n\t\n\tdef summ_end(lst):\n\t    summ=[]\n\t    y = [j for j in range(len(lst[0]))]\n\t    ex = len(lst)-1\n\t    for m in range(len(y)):\n\t        s = 0\n\t        i=ex\n\t        j=m\n\t        while i>=0 and j<=y[-1]:\n\t            s= s+lst[i][j]\n\t            if i%2==1:\n\t                j = j+1\n\t            else:\n\t                j=j\n\t            i = i-1\n\t        summ.append(s)\n\t    \n\t    return summ\n\t\n\t#得到各个元素的个位数，如果是大于10则向下一个进位\n\t\n\tdef take_digit(lst):\n\t    tmp = 0\n\t    digit_list = []\n\t    for m in range(len(lst)):\n\t        lstm = 0\n\t        lstm = lst[m]+tmp\n\t        if lstm<10:\n\t            tmp = 0\n\t            digit_list.append(str(lstm))\n\t        else:\n\t            tmp = lstm/10\n\t            mm = lstm-tmp*10\n\t            digit_list.append(str(mm))\n\t    return digit_list\n\t\n\t\n\tif __name__==\"__main__\":\n\t    arabic_multiplication(469,37)\n\n#联系方法\n- qiwsir#gmail.com\n- https://qiwsir.github.io\n- http://weibo.com/qiwsir\n\n"
        },
        {
          "name": "big_int.py",
          "type": "blob",
          "size": 3.60546875,
          "content": "#!/usr/bin/env python\n#coding:utf-8\n\n\"\"\"\n对于大整数计算，一般都要用某种方法转化，否则会溢出。但是python无此担忧了。\n\nPython支持“无限精度”的整数，一般情况下不用考虑整数溢出的问题，而且Python Int 整数类型与任意精度的Long整数类可以无缝转换，超过Int 范围的情况都将转换成Long类型。\n\n注意：前面的“无限精度”是有引号的。事实上也是有限制的，对于32位的机器，其上限是：2^32-1。真的足够大了。\n\n为什么Python能够做到呢？请有兴趣刨根问底的去看Python的有关源码。本文不赘述。\n\n在其它语言中，通常用“分治法”解决大整数相乘问题。\n\n但是，这里提供一个非常有意思的计算两个整数相乘的方法，算是做为大整数相乘的演示。\n\n两个整数相乘：阿拉伯乘法.详细描述见：http://ualr.edu/lasmoller/medievalmult.html\n\n\"\"\"\n\ndef arabic_multiplication(num1,num2):\n    num_lst1 = [int(i) for i in str(num1)]  #将int类型的123，转化为list类型的[1,2,3]，每个元素都是int类型\n    num_lst2 = [int(i) for i in str(num2)]\n\n    #两个list中整数两两相乘\n    int_martix = [[i*j for i in num_lst1] for j in num_lst2]\n    \n    #将上述元素为数字的list转化为元素类型是str，主要是将9-->'09'\n    str_martix = [map(convert_to_str,int_martix[i]) for i in range(len(int_martix))]\n    \n    #将上述各个list中的两位数字分开：['01','29','03']-->[0,2,0],[1,9,3]\n    martix = [[int(str_martix[i][j][z]) for j in range(len(str_martix[i]))] for i in range(len(str_martix)) for z in range(2)]\n    \n    #计算阿拉伯乘法表的左侧开始各项和\n    sum_left = summ_left(martix)\n\n    #计算阿拉伯乘法表的底部开始各项和\n    sum_end = summ_end(martix)\n\n    #将上述两个结果合并后翻转\n    sum_left.extend(sum_end)\n    sum_left.reverse()\n\n    #取得各个和的个位的数字（如果进位则加上）\n    result = take_digit(sum_left)\n    \n    #翻转结果并合并为一个结果字符串数值\n    result.reverse()\n    int_result = \"\".join(result)\n    print \"%d*%d=\"%(num1,num2)\n    print int_result\n\n\n#将int类型转化为str类型，9-->'09'\n\ndef convert_to_str(num):\n    if num<10:\n        return \"0\"+str(num)\n    else:\n        return str(num)\n\n\n#计算阿拉伯乘法表格左侧开始的各项之和\n\ndef summ_left(lst):\n    summ = []\n    x = [i for i in range(len(lst))]\n    y = [j for j in range(len(lst[0]))]\n    sx = [i for i in x if i%2==0]\n    for i in sx:\n        s=0\n        j=0\n        while i>=0 and j<=y[-1]:\n            s = s+ lst[i][j]\n            if i%2==1:\n                j = j+1\n            else:\n                j = j\n            i = i-1\n        summ.append(s)\n    return summ\n\n\n\n#计算阿拉伯乘法表格底部开始的各项之和\n\ndef summ_end(lst):\n    summ=[]\n    y = [j for j in range(len(lst[0]))]\n    ex = len(lst)-1\n    for m in range(len(y)):\n        s = 0\n        i=ex\n        j=m\n        while i>=0 and j<=y[-1]:\n            s= s+lst[i][j]\n            if i%2==1:\n                j = j+1\n            else:\n                j=j\n            i = i-1\n        summ.append(s)\n    \n    return summ\n\n#得到各个元素的个位数，如果是大于10则向下一个进位\n\ndef take_digit(lst):\n    tmp = 0\n    digit_list = []\n    for m in range(len(lst)):\n        lstm = 0\n        lstm = lst[m]+tmp\n        if lstm<10:\n            tmp = 0\n            digit_list.append(str(lstm))\n        else:\n            tmp = lstm/10\n            mm = lstm-tmp*10\n            digit_list.append(str(mm))\n    return digit_list\n\n\nif __name__==\"__main__\":\n    arabic_multiplication(469,37)\n"
        },
        {
          "name": "bin_search.md",
          "type": "blob",
          "size": 4.041015625,
          "content": "#问题\n\n二分查找\n\nlist.index()无法应对大规模数据的查询，需要用其它方法解决，这里谈的就是二分查找\n\n#思路说明\n\n在查找方面，python中有list.index()的方法。例如：\n\n    >>> a=[2,4,1,9,3]           #list可以是无序，也可以是有序\n    >>> a.index(4)              #找到后返回该值在list中的位置\n    1\n    >>> a.index(5)              #如果没有该值，则报错\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>\n    ValueError: 5 is not in list\n\n这是python中基本的查找方法，虽然简单，但是，如果由于其时间复杂度为O(n)，对于大规模的查询恐怕是不足以胜任的。二分查找就是一种替代方法。\n\n二分查找的对象是：有序数组。这点特别需要注意。要把数组排好序先。怎么排序，可以参看我这里多篇排序问题的文章。\n\n基本步骤：\n\n1. 从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜素过程结束；\n2. 如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。\n3. 如果在某一步骤数组为空，则代表找不到。\n\n这种搜索算法每一次比较都使搜索范围缩小一半。时间复杂度：O(logn)\n\n#解决(Python)\n\n\tdef binarySearch(lst, value,low,high):          #low,high是lst的查找范围\n\t    if high < low:\n\t        return -1\n\t    mid = (low + high)/2\n\t    if lst[mid] > value:\n\t        return binarySearch(lst, value, low, mid-1)\n\t    elif lst[mid] < value:\n\t        return binarySearch(lst, value, mid+1, high)\n\t    else:\n\t        return mid\n\t\n\t#也可以不用递归方法，而采用循环，如下：\n\t \n\tdef bsearch(l, value):\n\t    lo, hi = 0, len(l)-1\n\t    while lo <= hi:\n\t        mid = (lo + hi) / 2\n\t        if l[mid] < value:\n\t            lo = mid + 1\n\t        elif value < l[mid]:\n\t            hi = mid - 1\n\t        else:\n\t            return mid\n\t    return -1\n\t \n\tif __name__ == '__main__':\n\t    l = range(50)\n\t    print binarySearch(l,10,0,49)\n\t    print bsearch(l,10)\n\n对于python，不能忽视其强大的标准库。经查阅，发现标准库中就有一个模块，名为：bisect。其文档中有这样一句话：\n\n>>This module provides support for maintaining a list in sorted order without having to sort the list after each insertion. For long lists of items with expensive comparison operations, this can be an improvement over the more common approach. The module is called bisect because it uses a basic bisection algorithm to do its work. The source code may be most useful as a working example of the algorithm (the boundary conditions are already right!).\n\n当我把这段话输入到百度翻译中，天才的百度翻译给我的结果是：\n\n>>这个模块提供支持，维护list in order for without having to类法术the list After each插入。久lists of items以及昂贵的比较操作，这可以改善over the more common approach年。bisect because it is called the模块基本分割算法用to do its work。源代码可能是最有用的工作example of the算法（the边界条件are already right！）。\n\n这就是百度的水平，只可惜在贵国不能用google。\n\n看官就凭借自己的英语水平理解吧。这段话的关键点是在说明：\n\n- 模块接受排序后的列表。\n- 本模块同样适用于长列表项。因为它就是用二分查找方法实现的，有兴趣可以看其源码（源码是一个很好的二分查找算法的例子，特别是很好地解决了边界条件极端的问题.)\n- 关于bisect模块的更多内容，可以参看[官方文档](https://docs.python.org/2/library/bisect.html)\n\n下面演示这个模块的一个函数\n\t\n\tfrom bisect import *\n\t\n\tdef bisectSearch(lst, x):          \n\t    i = bisect_left(lst, x)         #bisect_left(lst,x)，得到x在已经排序的lst中的位置\n\t    if i != len(lst) and lst[i] == x:\n\t        return i\n\t    raise ValueError\n\t\n\tif __name__==\"__main__\":\n\t    lst = sorted([2,5,3,8])\n\t    print bisectSearch(lst,5)\n"
        },
        {
          "name": "bin_search.py",
          "type": "blob",
          "size": 3.900390625,
          "content": "#!/usr/bin/evn python\n#coding:utf-8\n\"\"\"\n#问题\n\n二分查找\n\nlist.index()无法应对大规模数据的查询，需要用其它方法解决，这里谈的就是二分查找\n\n#思路说明\n\n在查找方面，python中有list.index()的方法。例如：\n\n    >>> a=[2,4,1,9,3]           #list可以是无序，也可以是有序\n    >>> a.index(4)              #找到后返回该值在list中的位置\n    1\n    >>> a.index(5)              #如果没有该值，则报错\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>\n    ValueError: 5 is not in list\n\n这是python中基本的查找方法，虽然简单，但是，如果由于其时间复杂度为O(n)，对于大规模的查询恐怕是不足以胜任的。二分查找就是一种替代方法。\n\n二分查找的对象是：有序数组。这点特别需要注意。要把数组排好序先。怎么排序，可以参看我这里多篇排序问题的文章。\n\n基本步骤：\n\n1. 从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜素过程结束；\n2. 如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。\n3. 如果在某一步骤数组为空，则代表找不到。\n\n这种搜索算法每一次比较都使搜索范围缩小一半。时间复杂度：O(logn)\n\"\"\"\n\ndef binarySearch(lst, value,low,high):          #low,high是lst的查找范围\n    if high < low:\n        return -1\n    mid = (low + high)/2\n    if lst[mid] > value:\n        return binarySearch(lst, value, low, mid-1)\n    elif lst[mid] < value:\n        return binarySearch(lst, value, mid+1, high)\n    else:\n        return mid\n\n#也可以不用递归方法，而采用循环，如下：\n \ndef bsearch(l, value):\n    lo, hi = 0, len(l)-1\n    while lo <= hi:\n        mid = (lo + hi) / 2\n        if l[mid] < value:\n            lo = mid + 1\n        elif value < l[mid]:\n            hi = mid - 1\n        else:\n            return mid\n    return -1\n \n\"\"\"\n对于python，不能忽视其强大的标准库。经查阅，发现标准库中就有一个模块，名为：bisect。其文档中有这样一句话：\n\n>>This module provides support for maintaining a list in sorted order without having to sort the list after each insertion. For long lists of items with expensive comparison operations, this can be an improvement over the more common approach. The module is called bisect because it uses a basic bisection algorithm to do its work. The source code may be most useful as a working example of the algorithm (the boundary conditions are already right!).\n\n当我把这段话输入到百度翻译中，天才的百度翻译给我的结果是：\n\n>>这个模块提供支持，维护list in order for without having to类法术the list After each插入。久lists of items以及昂贵的比较操作，这可以改善over the more common approach年。bisect because it is called the模块基本分割算法用to do its work。源代码可能是最有用的工作example of the算法（the边界条件are already right！）。\n\n这就是百度的水平，只可惜在贵国不能用google。\n\n看官就凭借自己的英语水平理解吧。这段话的关键点是在说明：\n\n- 模块接受排序后的列表。\n\n- 本模块同样适用于长列表项。因为它就是用二分查找方法实现的，有兴趣可以看其源码（源码是一个很好的二分查找算法的例子，特别是很好地解决了边界条件极端的问题.)\n\n-关于本模块，可以查看官方文档：https://docs.python.org/2/library/bisect.html\n\"\"\"\n#下面演示这个模块\n\nfrom bisect import *\n\ndef bisectSearch(lst, x):        \n    i = bisect_left(lst, x)         #bisect_left(lst,x)得到x在已经排序的lst中的位置\n    if i != len(lst) and lst[i] == x:\n        return i\n\nif __name__==\"__main__\":\n    lst = sorted([2,5,3,8])\n    print bisectSearch(lst,5)\n    print bsearch(lst,5)\n"
        },
        {
          "name": "binary_tree.md",
          "type": "blob",
          "size": 10.0419921875,
          "content": "#问题\n\n二叉树查找\n\n#思路说明\n\n二叉树查找是一个面对动态数据比较常用的查找算法。本文根据下面地址文章翻译，并根据本人的理解进行适当修改。\n\n原文地址：http://www.laurentluce.com/posts/binary-search-tree-library-in-python/comment-page-1/\n\n###二叉树查找的定义\n\n定义内容可以参阅Wikipedia:http://en.wikipedia.org/wiki/Binary_tree\n\n这里是中文的：http://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9\n\n摘要其中对二叉树的描述：\n\n>>二叉树查找的性质：\n\n>>1. 若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；\n>>2. 任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；\n>>3. 任意节点的左、右子树也分别为二叉查找树。\n>>4. 没有键值相等的节点（no duplicate nodes）。\n\n>>二叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低。为O(log n)。二叉查找树是基础性数据结构，用于构建更为抽象的数据结构，如集合、multiset、关联数组等。\n\n>>虽然二叉查找树的最坏效率是O(n),但它支持动态查询,且有很多改进版的二叉查找树可以使树高为O(logn),如SBT,AVL,红黑树等.\n\n###用python实现二叉树查找\n\n以下面图示的二叉树为例说明查找算法\n\n![](./pics/binarytree1.png)\n\n**Node 类**\n\n创建一个类，命名为Node，做为二叉树节点结构，其中包括：左枝、右枝、节点数据三个变量。\n\n\tclass Node:\n\t    \"\"\"\n\t    二叉树左右枝\n\t    \"\"\"\n\t    def __init__(self, data):\n\t        \"\"\"\n\t        节点结构\n\t\n\t        \"\"\"\n\t        self.left = None\n\t        self.right = None\n\t        self.data = data\n\n例如创建一个含整数8的节点。因为仅仅创建一个节点，所以左右枝都是None。\n\n    root = Node(8)\n\n这样就得到如下图所示的只有一个节点的树。\n\n![](./pics/binarytree2.png)\n\n**插入方法**\n\n现在已经有了一棵光秃秃的树，要有枝杈和叶子，就必须用插入数据方法，添加新的节点和数据。\n\n    def insert(self, data):\n        \"\"\"\n        插入节点数据\n        \"\"\"\n        if data < self.data:\n            if self.left is None:\n                self.left = Node(data)\n            else:\n                self.left.insert(data)\n        elif data > self.data:\n            if self.right is None:\n                self.right = Node(data)\n            else:\n                self.right.insert(data)\n\n承接前面的操作，可以用下面的方式增加树的枝杈和叶子（左右枝以及节点数据）。\n\n    root.insert(3)\n    root.insert(10)\n    root.insert(1)\n\n当增加了第二个节点数据3,程序会：\n\n- 第一步，root会调用insert()，其参数是data=3\n- 第二步，比较3和8（已有的根节点），3比8小。并且树的左枝还是None，于是就在左边建立一个新的节点。\n\n增加第三个节点数据10,程序会：\n\n- 第一步，跟前面的第一步一样，只不过data=10\n- 第二步，发现10大于8,同时右边是None,于是就把它做为右边新建分支的节点数据。\n\n增加第四个节点数据1,程序会：\n\n- 第一步，同前，data=1\n- 第二步，1小于8,所以要放在树的左枝；\n- 第三步，左枝已经有子节点3,该节点再次调用insert()方法，1小于3,所以1就做为3的子节点，且放在原本就是None的左侧。\n\n如此，就形成了下图的树\n\n![](./pics/binarytree3.png)\n\n继续增加节点数据\n\n    root.insert(6)\n    root.insert(4)\n    root.insert(7)\n    root.insert(14)\n    root.insert(13)\n\n最终形成下图的树\n\n![](./pics/binarytree4.png)\n\n**遍历树**\n\n此方法用于查找树中的某个节点，如果找到了，就返回该节点，否则返回None。为了方便，也返回父节点。\n\n    def lookup(self, data, parent=None):\n        \"\"\"\n        遍历二叉树\n        \"\"\"\n        if data < self.data:\n            if self.left is None:\n                return None, None\n            return self.left.lookup(data, self)\n        elif data > self.data:\n            if self.right is None:\n                return None, None\n            return self.right.lookup(data, self)\n        else:\n            return self, parent\n\n测试一下，找一找数据为6的节点\n\n    node, parent = root.lookup(6)\n\n调用lookup()后，程序会这么干：\n\n1. 调用lookup()，传递参数data=6,默认parent=None\n2. data=6，小于根节点的值8\n3. 指针转到根节点左侧，此时:data=6,parent=8,再次调用lookup()\n4. data=6大于左侧第一层节点数据3\n5. 指针转到3的右侧分支，data=6,parent=3,再次调用lookup()\n6. 节点数据等于6,于是返回这个节点和它的父节点3\n\n**删除方法**\n\n删除节点数据。代码如下：\n\n    def delete(self, data):\n        \"\"\"\n        删除节点\n        \"\"\"\n        node, parent = self.lookup(data)        #已有节点\n        if node is not None:\n            children_count = node.children_count()      #判断子节点数\n            if children_count == 0:\n                # 如果该节点下没有子节点，即可删除\n                if parent.left is node:\n                    parent.left = None\n                else:\n                    parent.right = None\n                del node\n            elif children_count == 1:\n                # 如果有一个子节点，则让子节点上移替换该节点（该节点消失)\n                if node.left:\n                    n = node.left\n                else:\n                    n = node.right\n                if parent:\n                    if parent.left is node:\n                        parent.left = n\n                    else:\n                        parent.right = n\n                del node\n            else:\n                # 如果有两个子节点，则要判断节点下所有叶子\n                parent = node\n                successor = node.right\n                while successor.left:\n                    parent = successor\n                    successor = successor.left\n                node.data = successor.data\n                if parent.left == successor:\n                    parent.left = successor.right\n                else:\n                    parent.right = successor.right\n\n在上述方法中，得到当前节点下的子节点数目后，需要进行三种情况的判断\n\n- 如果没有子节点，直接删除\n- 如果有一个子节点，要将下一个子节点上移到当前节点，即替换之\n- 如果有两个子节点，要对自己点的数据进行判断，并从新安排节点排序\n\n上述方法中用到了统计子节点数目的方法，代码如下：\n\n    def children_count(self):\n        \"\"\"\n        子节点个数\n        \"\"\"\n        cnt = 0\n        if self.left:\n            cnt += 1\n        if self.right:\n            cnt += 1\n        return cnt\n\n例1：删除数据为1的节点，它是3的子节点，1后面没有子节点\n\n    root.delete(1)\n\n![](./pics/binarytree5.png)\n\n例2：删除数据为14的节点，它是10的子节点，它下面有唯一一个子节点13,13替换之。\n\n    root.delete(14)\n\n![](./pics/binarytree6.png)\n\n例3：来个复杂的，删除节点数据为3的节点，它下面有两个节点，而节点6下面又有两个4,7。需要一个临时变量successor，将节点3下面的子节点进行查询，并把小于3下面的第一级子节点6左测节点数据4（该数据一定小于其父节点6）替换当前节点3，维持二叉树结构。如下图：\n    \n    root.delete(3)\n\n![](./pics/binarytree7.png)\n\n**比较两个二叉树**\n\n比较两个二叉树的方法中，只要有一个节点（叶子）与另外一个树的不同，就返回False，也包括缺少对应叶子的情况。\n\n    def compare_trees(self, node):\n        \"\"\"\n        比较两棵树\n        \"\"\"\n        if node is None:\n            return False\n        if self.data != node.data:\n            return False\n        res = True\n        if self.left is None:\n            if node.left:\n                return False\n        else:\n            res = self.left.compare_trees(node.left)\n        if res is False:\n            return False\n        if self.right is None:\n            if node.right:\n                return False\n        else:\n            res = self.right.compare_trees(node.right)\n        return res\n\n例如，比较tree(3,8,10)和tree(3,8,11)\n\n    #root2 是tree(3,8,11)的根\n    #root 是tree(3,8,10)的根\n    root.compare_trees(root2)\n\n执行上面的代码，程序会这么走：\n\n1. root调用compare_trees()方法\n2. root有左侧子节点，调用该节点的compare_trees()\n3. 两个左侧子节点比较，返回true\n4. 按照前面的过程，比较右侧节点，发现不同，则返回False\n\n**打印树**\n\n把二叉树按照一定的顺序打印出来。不需要参数了。做法就是先左后右（左小于右）。\n\n    def print_tree(self):\n        \"\"\"\n        按顺序打印数的内容\n        \"\"\"\n        if self.left:\n            self.left.print_tree()\n        print self.data,\n        if self.right:\n            self.right.print_tree()\n\n操作一下：\n\n    root.print_tree()\n\n输出： 1, 3, 4, 6, 7, 8, 10, 13, 14\n\n**包含所有树元素的生成器**\n\n创建一个包含所有树元素的生成器，有时候是有必要的。考虑到内存问题，没有必要实时生成所有节点数据列表，而是要每次调用此方法时，它返回的下一个节点的值。为此，使用它返回一个对象，并停止在那里，那么该函数将在下一次调用方法时从那里继续通过yield关键字返回值。在这种情况下，要使用堆栈，不能使用递归。\n\n    def tree_data(self):\n        \"\"\"\n        二叉树数据结构\n        \"\"\"\n        stack = []\n        node = self\n        while stack or node: \n            if node:\n                stack.append(node)\n                node = node.left\n            else: \n                node = stack.pop()\n                yield node.data\n                node = node.right\n\n举例，通过循环得到树：\n\n    for data in root.tree_data():\n        print data\n\n![](./pics/binarytree1.png)\n\n程序会按照先左后右边的原子将数据入栈、出栈，顺序取出值，并返回结果\n"
        },
        {
          "name": "binary_tree.py",
          "type": "blob",
          "size": 3.849609375,
          "content": "#! /usr/bin/env python\n#coding:utf-8\n\nclass Node:\n    \"\"\"\n    二叉树左右枝\n    \"\"\"\n    def __init__(self, data):\n        \"\"\"\n        节点结构\n\n        \"\"\"\n        self.left = None\n        self.right = None\n        self.data = data\n\n    def insert(self, data):\n        \"\"\"\n        插入节点数据\n        \"\"\"\n        if data < self.data:\n            if self.left is None:\n                self.left = Node(data)\n            else:\n                self.left.insert(data)\n        elif data > self.data:\n            if self.right is None:\n                self.right = Node(data)\n            else:\n                self.right.insert(data)\n\n    def lookup(self, data, parent=None):\n        \"\"\"\n        遍历二叉树\n        \"\"\"\n        if data < self.data:\n            if self.left is None:\n                return None, None\n            return self.left.lookup(data, self)\n        elif data > self.data:\n            if self.right is None:\n                return None, None\n            return self.right.lookup(data, self)\n        else:\n            return self, parent\n\n    def delete(self, data):\n        \"\"\"\n        删除节点\n        \"\"\"\n        node, parent = self.lookup(data)        #已有节点\n        if node is not None:\n            children_count = node.children_count()      #判断子节点数\n            if children_count == 0:\n                # 如果该节点下没有子节点，即可删除\n                if parent.left is node:\n                    parent.left = None\n                else:\n                    parent.right = None\n                del node\n            elif children_count == 1:\n                # 如果有一个子节点，则让子节点上移替换该节点（该节点消失)\n                if node.left:\n                    n = node.left\n                else:\n                    n = node.right\n                if parent:\n                    if parent.left is node:\n                        parent.left = n\n                    else:\n                        parent.right = n\n                del node\n            else:\n                # 如果有两个子节点，则要判断节点下所有叶子\n                parent = node\n                successor = node.right\n                while successor.left:\n                    parent = successor\n                    successor = successor.left\n                node.data = successor.data\n                if parent.left == successor:\n                    parent.left = successor.right\n                else:\n                    parent.right = successor.right\n\n    def compare_trees(self, node):\n        \"\"\"\n        比较两棵树\n        \"\"\"\n        if node is None:\n            return False\n        if self.data != node.data:\n            return False\n        res = True\n        if self.left is None:\n            if node.left:\n                return False\n        else:\n            res = self.left.compare_trees(node.left)\n        if res is False:\n            return False\n        if self.right is None:\n            if node.right:\n                return False\n        else:\n            res = self.right.compare_trees(node.right)\n        return res\n                \n    def print_tree(self):\n        \"\"\"\n        按顺序打印数的内容\n        \"\"\"\n        if self.left:\n            self.left.print_tree()\n        print self.data,\n        if self.right:\n            self.right.print_tree()\n\n    def tree_data(self):\n        \"\"\"\n        二叉树数据结构\n        \"\"\"\n        stack = []\n        node = self\n        while stack or node: \n            if node:\n                stack.append(node)\n                node = node.left\n            else: \n                node = stack.pop()\n                yield node.data\n                node = node.right\n\n    def children_count(self):\n        \"\"\"\n        子节点个数\n        \"\"\"\n        cnt = 0\n        if self.left:\n            cnt += 1\n        if self.right:\n            cnt += 1\n        return cnt\n\n"
        },
        {
          "name": "binary_tree2.py",
          "type": "blob",
          "size": 3.5048828125,
          "content": "#! /usr/bin/env python\n#coding:utf-8\n\n# The code is from:http://code.activestate.com/recipes/286239-binary-ordered-tree/\n# A binary ordered tree example\n\nclass CNode:\n    left , right, data = None, None, 0\n    \n    def __init__(self, data):\n        # initializes the data members\n        self.left = None\n        self.right = None\n        self.data = data\n\n        \nclass CBOrdTree:\n    def __init__(self):\n        # initializes the root member\n        self.root = None\n        \n    def addNode(self, data):\n        # creates a new node and returns it\n        return CNode(data)\n            \n    def insert(self, root, data):\n        # inserts a new data\n        if root == None:\n            # it there isn't any data\n            # adds it and returns\n            return self.addNode(data)\n        else:\n            # enters into the tree\n            if data <= root.data:\n                # if the data is less than the stored one\n                # goes into the left-sub-tree\n                root.left = self.insert(root.left, data)\n            else:\n                # processes the right-sub-tree\n                root.right = self.insert(root.right, data)\n                return root\n                    \n    def lookup(self, root, target):\n        # looks for a value into the tree\n        if root == None:\n            return 0\n        else:\n            # if it has found it...\n            if target == root.data:\n                return 1\n            else:\n                if target < root.data:\n                    # left side\n                    return self.lookup(root.left, target)\n                else:\n                    # right side\n                    return self.lookup(root.right, target)\n                        \n    def minValue(self, root):\n        # goes down into the left\n        # arm and returns the last value\n        while(root.left != None):\n            root = root.left\n            return root.data\n               \n    def maxDepth(self, root):\n        if root == None:\n            return 0\n        else:\n            # computes the two depths\n            ldepth = self.maxDepth(root.left)\n            rdepth = self.maxDepth(root.right)\n            # returns the appropriate depth\n            return max(ldepth, rdepth) + 1\n               \n    def size(self, root):\n        if root == None:\n            return 0\n        else:\n            return self.size(root.left) + 1 + self.size(root.right)\n            \n    def printTree(self, root):\n        # prints the tree path\n        if root == None:\n            pass\n        else:\n            self.printTree(root.left)\n            print root.data,\n            self.printTree(root.right)\n            \n    def printRevTree(self, root):\n        # prints the tree path in reverse\n        # order\n        if root == None:\n            pass\n        else:\n            self.printRevTree(root.right)\n            print root.data,\n            self.printRevTree(root.left)\n            \nif __name__ == \"__main__\":\n    # create the binary tree\n    BTree = CBOrdTree()\n    # add the root node\n    root = BTree.addNode(0)\n    # ask the user to insert values\n    for i in range(0, 5):\n        data = int(raw_input(\"insert the node value nr %d: \" % i))\n        # insert values\n        BTree.insert(root, data)\n    print\n        \n    BTree.printTree(root)\n    print\n    BTree.printRevTree(root)\n    print\n    data = int(raw_input(\"insert a value to find: \"))\n    if BTree.lookup(root, data):\n        print \"found\"\n    else:\n        print \"not found\"\n\n    print BTree.minValue(root)\n    print BTree.maxDepth(root)\n    print BTree.size(root)\n"
        },
        {
          "name": "binary_tree_python.md",
          "type": "blob",
          "size": 13.1708984375,
          "content": "#问题\n\nPython中的二叉树查找算法模块\n\n#思路说明\n\n二叉树查找算法，在开发实践中，会经常用到。按照惯例，对于这么一个常用的东西，Python一定会提供轮子的。是的，python就是这样，一定会让开发者省心，降低开发者的工作压力。\n\npython中的二叉树模块内容：\n\n- BinaryTree：非平衡二叉树\n- AVLTree：平衡的AVL树\n- RBTree：平衡的红黑树\n\n以上是用python写的，相面的模块是用c写的，并且可以做为Cython的包。\n\n- FastBinaryTree\n- FastAVLTree\n- FastRBTree\n\n**特别需要说明的是：树往往要比python内置的dict类慢一些，但是它中的所有数据都是按照某个关键词进行排序的，故在某些情况下是必须使用的。**\n\n#安装和使用\n\n##安装方法\n\n###安装环境：\n\nubuntu12.04, python 2.7.6\n\n###安装方法\n\n- 下载源码，地址：https://bitbucket.org/mozman/bintrees/src\n- 进入源码目录，看到setup.py文件，在该目录内运行\n    \n    python setup.py install\n\n安装成功，ok!下面就看如何使用了。\n\n###应用\n\nbintrees提供了丰富的API,涵盖了通常的多种应用。下面逐条说明其应用。\n\n- 引用\n\n如果按照一般模块的思路，输入下面的命令引入上述模块\n    \n    >>> import bintrees\n    \n错了，这是错的，出现如下警告：(×××不可用，用×××）\n    \n    Warning: FastBinaryTree not available, using Python version BinaryTree.\n    Warning: FastAVLTree not available, using Python version AVLTree.\n    Warning: FastRBTree not available, using Python version RBTree.\n\n正确的引入方式是：\n     \n    >>> from bintrees import BinaryTree     #只引入了BinartTree\n    >>> from bintrees import *              #三个模块都引入了\n    \n- 实例化\n\n看例子：\n\n    >>> btree = BinaryTree()\n    >>> btree\n    BinaryTree({})\n    >>> type(btree)\n    <class 'bintrees.bintree.BinaryTree'>\n    \n- 逐个增加键值对：.__setitem__(k,v) .复杂度O(log(n))(后续说明中，都会有复杂度标示，为了简单，直接标明：O(log(n)).)\n\n看例子：\n\n    >>> btree.__setitem__(\"Tom\",\"headmaster\")\n    >>> btree\n    BinaryTree({'Tom': 'headmaster'})\n    >>> btree.__setitem__(\"blog\",\"http://blog.csdn.net/qiwsir\")\n    >>> btree\n    BinaryTree({'Tom': 'headmaster', 'blog': 'http://blog.csdn.net/qiwsir'})\n    \n- 批量添加：.update(E)  E是dict/iterable，将E批量更新入btree. O(E*log(n))\n    \n看例子：\n\n    >>> adict = [(2,\"phone\"),(5,\"tea\"),(9,\"scree\"),(7,\"computer\")]\n    >>> btree.update(adict)\n    >>> btree\n    BinaryTree({2: 'phone', 5: 'tea', 7: 'computer', 9: 'scree', 'Tom': 'headmaster', 'blog': 'http://blog.csdn.net/qiwsir'})\n    \n- 查找某个key是否存在：.__contains__(k)  如果含有键k，则返回True,否则返回False. O(log(n))\n    \n看例子：\n\n    >>> btree\n    BinaryTree({2: 'phone', 5: 'tea', 7: 'computer', 9: 'scree', 'Tom': 'headmaster', 'blog': 'http://blog.csdn.net/qiwsir'})\n    >>> btree.__contains__(5)\n    True\n    >>> btree.__contains__(\"blog\")\n    True\n    >>> btree.__contains__(\"qiwsir\")\n    False\n    >>> btree.__contains__(1)\n    False\n    \n- 根据key删除某个key-value：.__delitem__(key), O(log(n))\n    \n看例子：\n\n    >>> btree\n    BinaryTree({2: 'phone', 5: 'tea', 7: 'computer', 9: 'scree', 'Tom': 'headmaster', 'blog': 'http://blog.csdn.net/qiwsir'})\n    >>> btree.__delitem__(5)        #删除key=5的key-value,即：5:'tea' 被删除.\n    >>> btree\n    BinaryTree({2: 'phone', 7: 'computer', 9: 'scree', 'Tom': 'headmaster', 'blog': 'http://blog.csdn.net/qiwsir'})\n\n- 根据key值得到该kye的value：.__getitem__(key)\n\n看例子：\n\n    >>> btree\n    BinaryTree({2: 'phone', 7: 'computer', 9: 'scree', 'Tom': 'headmaster', 'blog': 'http://blog.csdn.net/qiwsir'})\n    >>> btree.__getitem__(\"blog\")\n    'http://blog.csdn.net/qiwsir'\n    >>> btree.__getitem__(7)\n    'computer'\n    >>> btree._getitem__(5)         #在btree中没有key=5，于是报错。\n    Traceback (most recent call last):\n    File \"<stdin>\", line 1, in <module>\n    AttributeError: 'BinaryTree' object has no attribute '_getitem__'\n\n- 迭代器：.__iter__()\n\n看例子：\n\n\t>>> btree        \n\tBinaryTree({2: 'phone', 7: 'computer', 9: 'scree', 'Tom': 'headmaster', 'blog': 'http://blog.csdn.net/qiwsir'})\n\t>>> aiter = btree.__iter__()\n\t>>> aiter\n\t<generator object <genexpr> at 0xb7416dec>\n\t>>> aiter.next()        #注意：next()一个之后，该值从list中删除\n\t2\n\t>>> aiter.next()\n\t7\n\t>>> list(aiter)\n\t[9, 'Tom', 'blog']\n    >>> list(aiter)         #结果是空\n    []\n    >>> bool(aiter)         #but,is True\n    True\n\n- 数的数据长度：.__len__(),返回btree的长度。O(1)\n\n看例子：\n\n    >>> btree\n    BinaryTree({2: 'phone', 7: 'computer', 9: 'scree', 'Tom': 'headmaster', 'blog': 'http://blog.csdn.net/qiwsir'})\n    >>> btree.__len__()\n    5\n\n- 找出key最大的k-v对：.__max__(),按照key排列，返回key最大的键值对。\n\n- 找出key最小的键值对：.__min__()\n\n看例子：\n\n    >>> btree\n    BinaryTree({2: 'phone', 7: 'computer', 9: 'scree'})\n    >>> btree.__max__()\n    (9, 'scree')\n    >>> btree.__min__()\n    (2, 'phone')\n\n- 两棵树的关系运算\n\n看例子：\n\n    >>> other = [(3,'http://blog.csdn.net/qiwsir'),(7,'qiwsir')]\n    >>> bother = BinaryTree()       #再建一个树\n    >>> bother.update(other)        #加入数据\n\n    >>> bother\n    BinaryTree({3: 'http://blog.csdn.net/qiwsir', 7: 'qiwsir'})\n    >>> btree\n    BinaryTree({2: 'phone', 7: 'computer', 9: 'scree'})\n    \n    >>> btree.__and__(bother)       #重叠部分部分\n    BinaryTree({7: 'computer'})\n\n    >>> btree.__or__(bother)        #全部\n    BinaryTree({2: 'phone', 3: 'http://blog.csdn.net/qiwsir', 7: 'computer', 9: 'scree'})\n\n    >>> btree.__sub__(bother)       #btree不与bother重叠的部分\n    BinaryTree({2: 'phone', 9: 'scree'})\n    \n    >>> btree.__xor__(bother)       #两者非重叠部分\n    BinaryTree({2: 'phone', 3: 'http://blog.csdn.net/qiwsir', 9: 'scree'})\n\n- 输出字符串模样，注意仅仅是输出的模样罢了：.__repr__()\n\n看例子：\n\n    >>> btree\n    BinaryTree({2: 'phone', 7: 'computer', 9: 'scree'})\n    >>> btree.__repr__()\n    \"BinaryTree({2: 'phone', 7: 'computer', 9: 'scree'})\"\n\n- 清空树中的所有数据:.clear(),O(log(n))\n\n看例子：\n\n    >>> bother   \n    BinaryTree({3: 'http://blog.csdn.net/qiwsir', 7: 'qiwsir'})\n    >>> bother.clear()\n    >>> bother\n    BinaryTree({})\n    >>> bool(bother)\n    False\n\n- 浅拷贝：.copy(),官方文档上说是浅拷贝，但是我做了操作实现，是下面所示，还不是很理解其“浅”的含义。O(n*log(n))\n\n看例子：\n\n    >>> btree\n    BinaryTree({2: 'phone', 7: 'computer', 9: 'scree'})\n    >>> ctree = btree.copy()\n    >>> ctree\n    BinaryTree({2: 'phone', 7: 'computer', 9: 'scree'})\n\n    >>> btree.__setitem__(\"github\",\"qiwsir\")    #增加btree的数据\n    >>> btree\n    BinaryTree({2: 'phone', 7: 'computer', 9: 'scree', 'github': 'qiwsir'})\n    >>> ctree\n    BinaryTree({2: 'phone', 7: 'computer', 9: 'scree'})     #这是不是在说明属于深拷贝呢？\n    \n    >>> ctree.__delitem__(7)    #删除ctree的一个数据\n    >>> ctree\n    BinaryTree({2: 'phone', 9: 'scree'})\n    >>> btree\n    BinaryTree({2: 'phone', 7: 'computer', 9: 'scree', 'github': 'qiwsir'})\n    \n- 移除树中的一个数据：.discard(key)，这个功能与.__delitem__(key)类似.两者都不反悔值。O(log(n))\n\n看例子：\n\n    >>> ctree\n    BinaryTree({2: 'phone', 9: 'scree'})\n    >>> ctree.discard(2)    #删除后，不返回值，或者返回None\n    >>> ctree\n    BinaryTree({9: 'scree'})\n    >>> ctree.discard(2)    #如果删除的key不存在，也返回None\n    >>> ctree.discard(3)\n    >>> ctree.__delitem__(3) #但是，.__delitem__(key)则不同，如果key不存在，会报错。\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>\n      File \"/usr/local/lib/python2.7/site-packages/bintrees/abctree.py\", line 264, in __delitem__\n      self.remove(key)\n      File \"/usr/local/lib/python2.7/site-packages/bintrees/bintree.py\", line 124, in remove\n      raise KeyError(str(key))\n      KeyError: '3'\n\n- 根据key查找，并返回或返回备用值：.get(key[,d])。如果key在树中存在，则返回value,否则如果有d，则返回d值。O(log(n))\n\n看例子：\n\n    >>> btree\n    BinaryTree({2: 'phone', 7: 'computer', 9: 'scree', 'github': 'qiwsir'})\n    >>> btree.get(2,\"algorithm\")\n    'phone'\n    >>> btree.get(\"python\",\"algorithm\") #没有key='python'的值，返回'algorithm'\n    'algorithm'\n    >>> btree.get(\"python\")     #如果不指定第二个参数，若查不到，则返回None\n    >>> \n\n- 判断树是否为空：is_empty().根据树数据的长度，如果数据长度为0,则为空。O(1)\n\n看例子：\n\n    >>> ctree\n    BinaryTree({9: 'scree'})\n    >>> ctree.clear()   #清空数据\n    >>> ctree\n    BinaryTree({})\n    >>> ctree.is_empty()\n    True\n    >>> btree\n    BinaryTree({2: 'phone', 7: 'computer', 9: 'scree', 'github': 'qiwsir'})\n    >>> btree.is_empty()\n    False\n\n- 根据key、value循环从树中取值：\n\n>>.items([reverse])--按照(key,value)结构取值;\n>>.keys([reverse])--key\n>>.values([reverse])--value. O(n)\n>>.iter_items(s,e[,reverse]--s,e是key的范围，也就是生成在某个范围内的key的迭代器 O(n)\n\n看例子：\n\n    >>> btree\n    BinaryTree({2: 'phone', 7: 'computer', 9: 'scree', 'github': 'qiwsir'})\n    >>> for (k,v) in btree.items():\n    ...     print k,v\n    ... \n    2 phone\n    7 computer\n    9 scree\n    github qiwsir\n    >>> for k in btree.keys():\n    ...     print k\n    ... \n    2\n    7\n    9\n    github\n    >>> for v in btree.values():\n    ...     print v\n    ... \n    phone\n    computer\n    scree\n    qiwsir\n    >>> for (k,v) in btree.items(reverse=True):  #反序\n    ...     print k,v\n    ... \n    github qiwsir\n    9 scree\n    7 computer\n    2 phone\n\n    >>> btree\n    BinaryTree({2: 'phone', 5: None, 7: 'computer', 8: 'eight', 9: 'scree', 'github': 'qiwsir'})\n    >>> for (k,v) in btree.iter_items(6,9):  #要求迭代6<=key<9的键值对数据\n    ...     print k,v\n    ... \n    7 computer\n    8 eight\n    >>> \n\n       \n- 删除数据并返回该值：\n\n>>.pop(key[,d]), 根据key删除树的数据，并返回该value，但是如果没有，并也指定了备选返回的d，则返回d，如果没有d，则报错；\n>>.pop_item(),在树中随机选择(key,value)删除，并返回。\n\n看例子：\n\n    >>> ctree = btree.copy()\n    >>> ctree\n    BinaryTree({2: 'phone', 7: 'computer', 9: 'scree', 'github': 'qiwsir'})\n\n    >>> ctree.pop(2)    #删除key=2的数据，返回其value\n    'phone'\n    >>> ctree.pop(2)    #删除一个不存在的key，报错\n    Traceback (most recent call last):\n        File \"<stdin>\", line 1, in <module>\n        File \"/usr/local/lib/python2.7/site-packages/bintrees/abctree.py\", line 350, in pop\n        value = self.get_value(key)\n        File \"/usr/local/lib/python2.7/site-packages/bintrees/abctree.py\", line 557, in get_value\n        raise KeyError(str(key))\n        KeyError: '2'\n    \n    >>> ctree.pop_item()   #随机返回一个(key,value),并已删除之\n    (7, 'computer')\n    >>> ctree\n    BinaryTree({9: 'scree', 'github': 'qiwsir'})\n    \n    >>> ctree.pop(7,\"sing\")    #如果没有，可以返回指定值\n    'sing'\n\n- 查找数据,并返回value：.set_default(key[,d])，在树的数据中查找key,如果存在，则返回该value。如果不存在，当指定了d,则将该（key,d）添加到树内；当不指定d的时候，添加(key,None). O(log(n))\n\n看例子：\n\n    >>> btree\n    BinaryTree({2: 'phone', 7: 'computer', 9: 'scree', 'github': 'qiwsir'})\n    >>> btree.set_default(7)    #存在则返回\n    'computer'\n    \n    >>> btree.set_default(8,\"eight\")  #不存在，则返回后备指定值，并加入到树\n    'eight'\n    >>> btree\n    BinaryTree({2: 'phone', 7: 'computer', 8: 'eight', 9: 'scree', 'github': 'qiwsir'})\n    \n    >>> btree.set_default(5)    #如果不指定值，则会加入None\n    >>> btree\n    BinaryTree({2: 'phone', 5: None, 7: 'computer', 8: 'eight', 9: 'scree', 'github': 'qiwsir'})\n\n    >>> btree.get(2)        #注意，.get(key)与.set_default(key[,d])的区别\n    'phone'\n    >>> btree.get(3,\"mobile\")   #不存在的 key,返回但不增加到树\n    'mobile'\n    >>> btree\n    BinaryTree({2: 'phone', 7: 'computer', 8: 'eight', 9: 'scree', 'github': 'qiwsir'})\n\n- 根据key删除值\n\n>>.remove(key),删除(key,value)\n>>.remove_items(keys),keys是一个key组成的list,逐个删除树中的对应数据\n\n看例子：\n\n    >>> ctree\n    BinaryTree({2: 'phone', 5: None, 7: 'computer', 8: 'eight', 9: 'scree', 'github': 'qiwsir'})\n    >>> ctree.remove_items([5,6])       #key=6，不存在，报错\n    Traceback (most recent call last):\n        File \"<stdin>\", line 1, in <module>\n        File \"/usr/local/lib/python2.7/site-packages/bintrees/abctree.py\", line 271, in remove_items\n        self.remove(key)\n        File \"/usr/local/lib/python2.7/site-packages/bintrees/bintree.py\", line 124, in remove\n        raise KeyError(str(key))\n        KeyError: '6'\n    \n    >>> ctree\n    BinaryTree({2: 'phone', 7: 'computer', 8: 'eight', 9: 'scree', 'github': 'qiwsir'})\n    >>> ctree.remove_items([2,7,'github'])  #按照 列表中顺序逐个删除\n    >>> ctree\n    BinaryTree({8: 'eight', 9: 'scree'})\n     \n###以上只是入门的基本方法啦，还有更多内容，请移到文章开头的官方网站。\n"
        },
        {
          "name": "binary_tree_traversal.md",
          "type": "blob",
          "size": 2.44140625,
          "content": "#问题\n\n用递归方式遍历二叉树\n\n#思路说明\n\n遍历二叉树的方法有广度优先和深度优先两类，下面阐述的是深度优先。\n\n以下图的二叉树为例：\n\n![](./pics/travesaltree1.png)\n\n先定义三个符号标记：\n\n- 访问结点本身（N）\n- 遍历该结点的左子树（L）\n- 遍历该结点的右子树（R）\n\n有四种方式：\n\n1. 前序遍历(PreorderTraversal,NLR):先访问根结点，然后遍历其左右子树\n2. 中序遍历(InorderTraversal,LNR):先访问左子树，然后访问根节点，再访问右子树\n3. 后序遍历(PostorderTraversal,LRN):先访问左右子树，再访问根结点\n4. 层序遍历(levelorderTraversal):按照从上到下的层顺序访问\n\n上面的数，按照以上四种方式遍历，得到的结果依次是：\n\n1. preorder:    1 2 4 7 5 3 6 8 9\n2. inorder:     7 4 2 5 1 8 6 9 3\n3. postorder:   7 4 5 2 8 9 6 3 1\n4. level-order: 1 2 3 4 5 6 7 8 9\n\n下面用递归的方式，解决此题。\n\n#解决(Python)\n\t\n\t#! /usr/bin/env python\n\t#coding:utf-8\n\t\n\tfrom collections import namedtuple\n\tfrom sys import stdout\n\t \n\tNode = namedtuple('Node', 'data, left, right')\n\ttree = Node(1,\n\t            Node(2,\n\t                 Node(4,\n\t                      Node(7, None, None),\n\t                      None),\n\t                 Node(5, None, None)),\n\t            Node(3,\n\t                 Node(6,\n\t                      Node(8, None, None),\n\t                      Node(9, None, None)),\n\t                 None))\n\t\n\t\n\t#前序（pre-order，NLR）\n\t\n\tdef preorder(node):\n\t    if node is not None:\n\t        print node.data,\n\t        preorder(node.left)\n\t        preorder(node.right)\n\t\n\t\n\t#中序（in-order，LNR）\n\t\n\tdef inorder(node):\n\t    if node is not None:\n\t        inorder(node.left)\n\t        print node.data,\n\t        inorder(node.right)\n\t\n\t\n\t#后序（post-order，LRN）\n\t\n\tdef postorder(node):\n\t    if node is not None:\n\t        postorder(node.left)\n\t        postorder(node.right)\n\t        print node.data,\n\t\n\t\n\t#层序（level-order）\n\t\n\tdef levelorder(node, more=None):\n\t    if node is not None:\n\t        if more is None:\n\t            more = []\n\t        more += [node.left, node.right]\n\t        print node.data,\n\t    if more:    \n\t        levelorder(more[0], more[1:])\n\t\n\tif __name__==\"__main__\"\n\t    print '  preorder: ',\n\t    preorder(tree)\n\t    print '\\t\\n   inorder: ',\n\t    inorder(tree)\n\t    print '\\t\\n postorder: ',\n\t    postorder(tree)\n\t    print '\\t\\nlevelorder: ',\n\t    levelorder(tree)\n\t    print '\\n'\n"
        },
        {
          "name": "binary_tree_traversal.py",
          "type": "blob",
          "size": 1.3916015625,
          "content": "#! /usr/bin/env python\n#coding:utf-8\n\n\"\"\"\n#问题\n用递归方式遍历二叉树\n\"\"\"\n\nfrom collections import namedtuple\nfrom sys import stdout\n \nNode = namedtuple('Node', 'data, left, right')\ntree = Node(1,\n            Node(2,\n                 Node(4,\n                      Node(7, None, None),\n                      None),\n                 Node(5, None, None)),\n            Node(3,\n                 Node(6,\n                      Node(8, None, None),\n                      Node(9, None, None)),\n                 None))\n\n\n#前序（pre-order，NLR）\n\ndef preorder(node):\n    if node is not None:\n        print node.data,\n        preorder(node.left)\n        preorder(node.right)\n\n\n#中序（in-order，LNR）\n\ndef inorder(node):\n    if node is not None:\n        inorder(node.left)\n        print node.data,\n        inorder(node.right)\n\n\n#后序（post-order，LRN）\n\ndef postorder(node):\n    if node is not None:\n        postorder(node.left)\n        postorder(node.right)\n        print node.data,\n\n\n#层序（level-order）\n\ndef levelorder(node, more=None):\n    if node is not None:\n        if more is None:\n            more = []\n        more += [node.left, node.right]\n        print node.data,\n    if more:    \n        levelorder(more[0], more[1:])\n \nprint '  preorder: ',\npreorder(tree)\nprint '\\t\\n   inorder: ',\ninorder(tree)\nprint '\\t\\n postorder: ',\npostorder(tree)\nprint '\\t\\nlevelorder: ',\nlevelorder(tree)\nprint '\\n'\n"
        },
        {
          "name": "change_coin.md",
          "type": "blob",
          "size": 2.634765625,
          "content": "\n#问题：\n\n以人民币的硬币为例，假设硬币数量足够多。要求将一定数额的钱兑换成硬币。要求兑换硬币数量最少。\n\n#思路说明：\n\n这是用贪婪算法的典型应用。在本例中用python来实现，主要思想是将货币金额除以某硬币单位，然后去整数，即为该硬币的个数；余数则做为向下循环计算的货币金额。\n\n这个算法的问题在于，得出来的结果不一定是最有结果。比如，硬币单位是[1,4,6],如果将8兑换成硬币，按照硬币数量最少原则，应该兑换成为两个4（单位）的硬币，但是，按照本算法，得到的结果是一个6单位和两个1单位的硬币。这也是本算法的局限所在。所谓贪婪算法，本质就是只要找出一个结果，不考虑以后会怎么样。\n\n#解决(Python)\n\n\t#!/usr/bin/env python\n\t#coding:utf-8\n\t\n\t\n\tdef change_coin(money):\n\t    coin = [1,2,5,10,20,50,100]     #1分，2分，5分，1角，2角，5角，1元\n\t    coin.sort(reverse=True)\n\t    money = money*100               #以分为单位进行计算\n\t    change = {}\n\t\n\t    for one in coin:\n\t        num_coin = money//one       #除法，取整，得到该单位硬币的个数\n\t        if num_coin>0:\n\t            change[one]=num_coin\n\t        num_remain = money%one      #取余数，得到剩下的钱数\n\t        if num_remain==0:\n\t            break\n\t        else:\n\t            money = num_remain\n\t    return change \n\t\n\tif __name__==\"__main__\":\n\t    money = 3.42\n\t    num_coin = change_coin(money)\n\t    result = [(key,num_coin[key]) for key in sorted(num_coin.keys())]\n\t    print \"You have %s RMB\"%money\n\t    print \"I had to change you:\"\n\t    print \"    Coin    Number\"\n\t    for i in result:\n\t        if i[0]==100:\n\t            print \"Yuan    %d    %d\"%(i[0]/100,i[1])\n\t        elif i[0]<10:\n\t            print \"Fen    %d    %d\"%(i[0],i[1])\n\t        else:\n\t            print \"Jiao    %d    %d\"%(i[0]/10,i[1])\n\t\n\t#执行结果\n\t#You have 3.42 RMB\n\t#I had to change you:\n\t#    Coin    Number\n\t#    Fen    2    1\n\t#    Jiao    2    2\n\t#    Yuan    1    3\n\n#解决2(Python)\n\n以下方法，以动态方式，提供最小的硬币数量。避免了贪婪方法的问题。\n\n\tdef coinChange(centsNeeded, coinValues):\n\t    minCoins = [[0 for j in range(centsNeeded + 1)] for i in range(len(coinValues))]\n\t    minCoins[0] = range(centsNeeded + 1)\n\t    \n\t    for i in range(1,len(coinValues)):\n\t        for j in range(0, centsNeeded + 1):\n\t            if j < coinValues[i]:\n\t                minCoins[i][j] = minCoins[i-1][j]\n\t            else:\n\t                minCoins[i][j] = min(minCoins[i-1][j], 1 + minCoins[i][j-coinValues[i]])\n\t    return minCoins[-1][-1]\n"
        },
        {
          "name": "change_coin.py",
          "type": "blob",
          "size": 2.677734375,
          "content": "#!/usr/bin/env python\n#coding:utf-8\n\n\"\"\"\n问题：\n\n以人民币的硬币为例，假设硬币数量足够多。要求将一定数额的钱兑换成硬币。要求兑换硬币数量最少。\n\n思路说明：\n\n这是用贪婪算法的典型应用。在本例中用python来实现，主要思想是将货币金额除以某硬币单位，然后去整数，即为该硬币的个数；余数则做为向下循环计算的货币金额。\n\n这个算法的问题在于，得出来的结果不一定是最有结果。比如，硬币单位是[1,4,6],如果将8兑换成硬币，按照硬币数量最少原则，应该兑换成为两个4（单位）的硬币，但是，按照本算法，得到的结果是一个6单位和两个1单位的硬币。这也是本算法的局限所在。所谓贪婪算法，本质就是只要找出一个结果，不考虑以后会怎么样。\n\"\"\"\n\ndef change_coin(money):\n    coin = [1,2,5,10,20,50,100]     #1分，2分，5分，1角，2角，5角，1元\n    coin.sort(reverse=True)\n    money = money*100               #以分为单位进行计算\n    change = {}\n\n    for one in coin:\n        num_coin = money//one       #除法，取整，得到该单位硬币的个数\n        if num_coin>0:\n            change[one]=num_coin\n        num_remain = money%one      #取余数，得到剩下的钱数\n        if num_remain==0:\n            break\n        else:\n            money = num_remain\n    return change \n\n#以下方法，以动态方式，提供最小的硬币数量。避免了贪婪方法的问题。\ndef coinChange(centsNeeded, coinValues):\n    minCoins = [[0 for j in range(centsNeeded + 1)] for i in range(len(coinValues))]\n    minCoins[0] = range(centsNeeded + 1)\n    \n    for i in range(1,len(coinValues)):\n        for j in range(0, centsNeeded + 1):\n            if j < coinValues[i]:\n                minCoins[i][j] = minCoins[i-1][j]\n            else:\n                minCoins[i][j] = min(minCoins[i-1][j], 1 + minCoins[i][j-coinValues[i]])\n    return minCoins[-1][-1]\n\nif __name__==\"__main__\":\n    money = 3.42\n    coin = [1,2,5,10,20,50,100]     #1分，2分，5分，1角，2角，5角，1元\n    num_coin = change_coin(money)\n    result = [(key,num_coin[key]) for key in sorted(num_coin.keys())]\n    print \"You have %s RMB\"%money\n    print \"I had to change you:\"\n    print \"    Coin    Number\"\n    for i in result:\n        if i[0]==100:\n            print \"Yuan    %d    %d\"%(i[0]/100,i[1])\n        elif i[0]<10:\n            print \"Fen    %d    %d\"%(i[0],i[1])\n        else:\n            print \"Jiao    %d    %d\"%(i[0]/10,i[1])\n    num2 = coinChange(5,coin)\n    print num2\n#执行结果\n#You have 3.42 RMB\n#I had to change you:\n#    Coin    Number\n#    Fen    2    1\n#    Jiao    2    2\n#    Yuan    1    3\n\n"
        },
        {
          "name": "chinesetokenizer.py",
          "type": "blob",
          "size": 2.3017578125,
          "content": "#! /usr/bin/env python\n#coding:utf-8\n\n#本代码来自网络：http://ashin.sinaapp.com/article/118/\n\nimport jieba\nfrom whoosh.analysis import Tokenizer,Token \nfrom whoosh.compat import text_type\n\nclass ChineseTokenizer(Tokenizer):  \n    def __call__(self, value, positions=False, chars=False, keeporiginal=False, removestops=True, start_pos=0, start_char=0, mode='', **kwargs):  \n        assert isinstance(value, text_type), \"%r is not unicode\" % value  \n        t = Token(positions, chars, removestops=removestops, mode=mode, **kwargs)  \n        seglist=jieba.cut_for_search(value)                       #使用结巴分词库进行分词  \n        for w in seglist:  \n            t.original = t.text = w  \n            t.boost = 1.0  \n            if positions:  \n                t.pos=start_pos+value.find(w)  \n            if chars:  \n                t.startchar=start_char+value.find(w)  \n                t.endchar=start_char+value.find(w)+len(w)  \n            yield t                                               #通过生成器返回每个分词的结果token\n\ndef ChineseAnalyzer():  \n    return ChineseTokenizer()\n\n\"\"\"\n测试脚本：\n\n#!/usr/bin/env python  \n# -*- coding: UTF-8 -*-  \n\nfrom whoosh.index import create_in  \nfrom whoosh.fields import *  \nfrom chinesetokenizer import ChineseAnalyzer\n#from whoosh.analysis import RegexAnalyzer  \n#analyzer = RegexAnalyzer(ur\"([\\u4e00-\\u9fa5])|(\\w+(\\.?\\w+)*)\")\n\nanalyzer = ChineseAnalyzer()\n\nschema = Schema(title=TEXT(stored=True), path=ID(stored=True), content=TEXT(stored=True, analyzer=analyzer))  \nix = create_in(\"schema\", schema)  \nwriter = ix.writer()\n\nwriter.add_document(title=u\"First document\", path=u\"/a\", content=u\"先生说我们都是好学生\")  \nwriter.add_document(title=u\"Second document\", path=u\"/b\", content=u\"我们要树立科学发展观\")\nwriter.commit()\n\nwith ix.searcher() as searcher:\n    results = searcher.find(\"content\", u\"发展\")\n    if 0 != len(results):\n        for hit in results:\n            print hit.highlights(\"content\")\n\n\n运行结果：\n\n\n先<b class=\"match term0\">生</b>说我们都是好<b class=\"match term1\">学</b><b class=\"match term0\">生</b>\n\n先生说我们都是好<b class=\"match term0\">学生</b>\n\n我们要树立科学<b class=\"match term0\">发</b><b class=\"match term1\">展</b>观\n\n我们要树立科学<b class=\"match term0\">发展</b>观\n\n\"\"\"\n"
        },
        {
          "name": "chose_sort_algorithm.md",
          "type": "blob",
          "size": 1.64453125,
          "content": "#排序算法比较和选择\n\n排序算法有不少，当然，一般的语言中都提供某个排序函数，比如Python中，对list进行排序，可以使用sorted（或者list.sort()），关于这方面的使用，在我的github代码库algorithm中有几个举例，有兴趣的看官可以去那里看看（顺便告知，我在Github中的账号是qiwsir，欢迎follow me）。但是，在某些情况下，语言中提供的排序方法或许不适合，必须选择某种排序算法。\n\n这里整理一些排序算法的比较，供看官参考。\n\n##计算复杂度比较\n\n|名称    |平均速度|最坏情况|\n|--------|:-----:|:------:|\n|冒泡排序法|O(n^2)|O(n^2)|\n|快速排序法|O(nlogn)|O(n^2|\n|选择排序|O(n^2)|O(n^2)|\n|堆排序|O(nlogn)|O(nlogn)|\n|插入排序|O(n^2)|O(n^2)|\n|希尔排序|O(n^3/2)|O(n^2)|\n|归并排序|O(nlogn)|O(nlogn)|\n\n##系统资源占用比较\n\n上述各个方法中，除了归并排序，只需要使用1个元素的临时存储单元，用于交换数据。归并排序则需要n个元素的存储单元，用来保存多遍合并操作。\n\n##稳定度比较\n\n冒泡、插入、归并三种方法稳定性较好，其余稍逊。\n\n##如何选择排序法\n\n没有哪一种排序方法是全面胜出的，只有根据具体具体情况选择了。一般下面的原则可以考虑：\n\n- 当数据为正序时，尽可能用冒泡、插入、快速方法\n- 如果n值较小（不超过50，但也要根据硬件状况确定），可以采用插入、选择排序。插入排序对小数量较为适用。\n- 如果n值较大，采用时间O(nlogn)的排序方法较适宜。\n- 如果强调稳定性，则使用归并排序。\n"
        },
        {
          "name": "delete_space.md",
          "type": "blob",
          "size": 0.607421875,
          "content": "#问题\n\n删除一个字符串中连续超过一次的空格。\n\n#解决（Python）\n\n    #! /usr/bin/env python\n    #coding:utf-8\n\n    def del_space(string):\n        split_string = string.split(\" \")    #以空格为分割，生成list，list中如果含有空格，则该空格是连续空格中的后一个\n        string_list = [i for i in split_string if i!=\"\"]    #去掉空格，生成list\n        result_string = \" \".join(string_list)\n        return result_string\n\n    if __name__==\"__main__\":\n        one_str = \"Hello,  I am  Qiwsir.\"\n        string = del_space(one_str)\n        print one_str\n        print string\n"
        },
        {
          "name": "delete_space.py",
          "type": "blob",
          "size": 0.49609375,
          "content": "#! /usr/bin/env python\n#coding:utf-8\n\n#删除一个字符串中连续超过一次的空格。\ndef del_space(string):\n    split_string = string.split(\" \")    #以空格为分割，生成list，list中如果含有空格，则该空格是连续空格中的后一个\n    string_list = [i for i in string if i!=\"\"]\n    result_string = \" \".join(string_list)\n    return result_string\n\nif __name__==\"__main__\":\n    one_str = \"Hello,  I am  Qiwsir.\"\n    string = del_space(one_str)\n    print one_str\n    print string\n"
        },
        {
          "name": "dijkstra_algorithm.md",
          "type": "blob",
          "size": 1.7216796875,
          "content": "#问题\n\n最短路径问题的Dijkstra算法\n\n是由荷兰计算机科学家艾兹赫尔·戴克斯特拉提出。迪科斯彻算法使用了广度优先搜索解决非负权有向图的单源最短路径问题，算法最终得到一个最短路径树。该算法常用于路由算法或者作为其他图算法的一个子模块。\n\n这个算法的python实现途径很多，网上能够发现不少。这里推荐一个我在网上看到的，本来打算自己写，看了这个，决定自己不写了，因为他的已经太好了。\n\n#解决（Python）\n\n\t#!/usr/bin/env python\n\t#coding:utf-8\n\t\n\t# Dijkstra's algorithm for shortest paths\n\t# David Eppstein, UC Irvine, 4 April 2002\n\t# code source:http://www.algolist.com/code/python/Dijkstra%27s_algorithm\n\t\n\tfrom priodict import priorityDictionary\n\t\n\tdef Dijkstra(G,start,end=None):\n\t    D = {}  # dictionary of final distances\n\t    P = {}  # dictionary of predecessors\n\t    Q = priorityDictionary()   # est.dist. of non-final vert.\n\t    Q[start] = 0\n\t                    \n\t    for v in Q:\n\t        D[v] = Q[v]\n\t\n\t        if v == end: break\n\t        \n\t        for w in G[v]:\n\t            vwLength = D[v] + G[v][w]\n\t            if w in D:\n\t                if vwLength < D[w]:\n\t                    raise ValueError, \"Dijkstra: found better path to already-final vertex\"\n\t                    \n\t                elif w not in Q or vwLength < Q[w]:\n\t                    Q[w] = vwLength\n\t                    P[w] = v\n\t                                \n\t        return (D,P)\n\t\n\tdef shortestPath(G,start,end):\n\t    D,P = Dijkstra(G,start,end)\n\t    Path = []\n\t    while 1:\n\t             \n\t        Path.append(end)\n\t        if end == start: break\n\t        end = P[end]\n\t        \n\t    Path.reverse()\n\t    return Path\n\t\n"
        },
        {
          "name": "dijkstra_algorithm.py",
          "type": "blob",
          "size": 1.65625,
          "content": "#!/usr/bin/env python\n#coding:utf-8\n\"\"\"\n最短路径问题的Dijkstra算法\n\n是由荷兰计算机科学家艾兹赫尔·戴克斯特拉提出。迪科斯彻算法使用了广度优先搜索解决非负权有向图的单源最短路径问题，算法最终得到一个最短路径树。该算法常用于路由算法或者作为其他图算法的一个子模块。\n\n这个算法的python实现途径很多，网上能够发现不少。这里推荐一个我在网上看到的，本来打算自己写，看了这个，决定自己不写了，因为他的已经太好了。\n\"\"\"\n\n# Dijkstra's algorithm for shortest paths\n# David Eppstein, UC Irvine, 4 April 2002\n# code source:http://www.algolist.com/code/python/Dijkstra%27s_algorithm\n\nfrom priodict import priorityDictionary\n\ndef Dijkstra(G,start,end=None):\n    D = {}  # dictionary of final distances\n    P = {}  # dictionary of predecessors\n    Q = priorityDictionary()   # est.dist. of non-final vert.\n    Q[start] = 0\n                    \n    for v in Q:\n        D[v] = Q[v]\n\n        if v == end: break\n        \n        for w in G[v]:\n            vwLength = D[v] + G[v][w]\n            if w in D:\n                if vwLength < D[w]:\n                    raise ValueError, \"Dijkstra: found better path to already-final vertex\"\n                    \n                elif w not in Q or vwLength < Q[w]:\n                    Q[w] = vwLength\n                    P[w] = v\n                                \n        return (D,P)\n\ndef shortestPath(G,start,end):\n    D,P = Dijkstra(G,start,end)\n    Path = []\n    while 1:\n             \n        Path.append(end)\n        if end == start: break\n        end = P[end]\n        \n    Path.reverse()\n    return Path\n\n"
        },
        {
          "name": "divide.py",
          "type": "blob",
          "size": 1.9580078125,
          "content": "#! /usr/bin/env python\n#coding:utf-8\n\ndef divide(numerator, denominator, detect_repetition=True, digit_limit=None):\n\n    # 如果是无限小数，必须输入限制的返回小数位数:digit_limit\n    # digit_limit = 5，表示小数位数5位，注意这里的小数位数是截取，不是四舍五入.\n    if not detect_repetition and digit_limit == None:\n        return None\n\n    decimal_found = False\n                                \n    v = numerator // denominator\n    numerator = 10 * (numerator - v * denominator)\n    answer = str(v)\n                                                \n    if numerator == 0:\n        return answer\n                                                              \n    answer += '.'\n    \n    # Maintain a list of all the intermediate numerators\n    # and the length of the output at the point where that\n    # numerator was encountered. If you encounter the same\n    # numerator again, then the decimal repeats itself from\n    # the last index that numerator was encountered at.\n    states = {}\n    \n    while numerator > 0 and (digit_limit == None or digit_limit > 0):\n        \n        if detect_repetition:\n            prev_state = states.get(numerator, None)\n            if prev_state != None:\n                start_repeat_index = prev_state\n                non_repeating = answer[:start_repeat_index]\n                repeating = answer[start_repeat_index:]\n                return non_repeating + '[' + repeating + ']'\n            states[numerator] = len(answer)\n\n        v = numerator // denominator\n        answer += str(v)\n        numerator -= v * denominator\n        numerator *= 10\n        if digit_limit != None:\n            digit_limit -= 1\n            \n            \n    if numerator > 0:\n        return answer + '...'\n    return answer\n\nif __name__==\"__main__\":\n    print \"5divide2\",\n    print divide(5,2)\n    print \"10divide3\",\n    print divide(10,3)\n    print divide(10,3,5)\n    print \"15divide7\"\n    print divide(15,7)\n    print divide(15,7,True,3)\n    \n"
        },
        {
          "name": "even_odd.md",
          "type": "blob",
          "size": 1.7001953125,
          "content": "#问题\n\n一个数组由若干个整数组成，现要求：将偶数放到前面，奇数放到后面，并输出数组。\n\n#解决（python）\n\n    #coding:utf-8\n    is_odd_number = lambda data:(data%2!=0)\n\n    def odd_even_sort(lst):\n        \"\"\"利用list conprehension\"\"\"\n        tmp_list1 = [item for item in lst if is_odd_number(item)]\n        tmp_list2 = [item for item in lst if not is_odd_number(item)]\n\n    test_lst = [7,9,12,5,4,9,8,3,12,89]\n\n    print (odd_even_sort(test_lst))\n\n##本问题由黄老师提供并解决，[他的微博](http://weibo.com/qiyeminglu?from=feed&loc=nickname)\n\n#解决（python)\n\n    def odd(x):return x%2==1    #判断是否为奇数，是则返回true\n    def even(x):return x%2==0   \n\n    if __name__==\"__main__\":\n        test_lst = [7,9,12,5,4,9,8,3,12,89]\n        print filter(even,test_lst)+filter(odd,test_lst)    #利用filter函数\n\n#解决 (racket 5.2.1)\n\n```racket\n#lang racket\n\n; 定义函数 odd-even-separator\n; 输入一个由整数构成的列表\n; 输出一个新的列表, 其元素取自输入的列表\n; 假设输入列表长度为 N, 列表元素中有 k 个偶数, N-k 个奇数\n; 那么输出的列表中, 前 k 个元素就是输入列表中的 k 个偶数\n; 后 N-k 个元素就是输入列表中的 N-k 个奇数.\n(define (odd-even-separator num-array)\n  (let* \n      ([odd-arr (filter odd? arr1)]   ; 取出全部奇数形成新列表\n       [even-arr (filter even? arr1)] ; 取出全部偶数形成新列表\n       [separated-arr \n        (append even-arr odd-arr)])   ; 把两个新列表连接起来\n    (displayln separated-arr)))       ; 打印到标准输出\n\n; 函数调用, 正常运行后, 应该显示 (2 6 4 1 3 5 7 9)\n(odd-even-separator '(1 3 2 6 5 7 9 4))\n\n```\n"
        },
        {
          "name": "even_odd.py",
          "type": "blob",
          "size": 0.5595703125,
          "content": "#! /usr/bin/env python\n#coding:utf-8\n\n'''\n#way1\n\ndef odd_even_sort(lst):\n    \n    is_odd_number = lambda data:(data%2!=0)\n    tmp_list1 = [item for item in lst if is_odd_number(item)]\n    tmp_list2 = [item for item in lst if not is_odd_number(item)]\n    return tmp_list1+tmp_list2\n\n\nif __name__==\"__main__\":\n    test_lst = [7,9,12,5,4,9,8,3,12,89]\n\n    print odd_even_sort(test_lst)\n\n'''\n\n#way2\n\ndef odd(x):return x%2==1    \ndef even(x):return x%2==0   \n\nif __name__==\"__main__\":\n    test_lst = [7,9,12,5,4,9,8,3,12,89]\n    print filter(even,test_lst)+filter(odd,test_lst)\n"
        },
        {
          "name": "fibonacci.md",
          "type": "blob",
          "size": 2.4248046875,
          "content": "#问题\n\n费波那契数列（意大利语：Successione di Fibonacci），又译费波拿契数、斐波那契数列、斐波那契数列、黄金分割数列。\n\n在数学上，费波那契数列是以递归的方法来定义：\n\n    F0 = 0     (n=0)\n    F1 = 1    (n=1)\n    Fn = F[n-1]+ F[n-2](n=>2)\n\n关于Fibonacci的精彩解释，请看下列视频：\n\n[TED-神奇的斐波那契数列](http://swf.ws.126.net/openplayer/v02/-0-2_M9HKRT25D_M9HNA0UNO-vimg1_ws_126_net//image/snapshot_movie/2014/1/6/L/M9HNA8H6L-.swf)\n\n如果要查看文字解释，请看维基百科词条：[斐波那契数列](http://zh.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97)\n\n#思路说明\n\n几乎所有的高级语言都要拿Fibonacci数列为例子，解释递归、循环等概念。这里，我要用Python来演示一下，各种不同的写法，供参考。\n\n#解决（python）\n\n##递归——按照定义直接写\n\n这种方法不是一个好方法，因为它的开销太大，比如计算fib1(100),就需要耐心等待较长一段时间了。所以，这是一种不实用的方法。但是，因为简单，列为第一种。\n\n    def fib1(n):\n        if n==0:\n            return 0\n        elif n==1:\n            return 1\n        else:\n            return fib1(n-1) + fib1(n-2)\n\n##递归，进行初始化\n\nfib1的慢，就是因为每次都要计算前面已经算过的项目.这里将上述算法进行稍微改进。速度快了很多。\n\n    memo = {0:0, 1:1}\n    def fib2(n):\n        if not n in memo:\n            memo[n] = fib2(n-1)+fib2(n-2)\n        return memo[n]\n\n##迭代\n\n    def fib3(n):\n        a, b = 0, 1\n        for i in range(n):\n            a, b = b, a+b\n        return a\n\n#直接理论数学结论\n\n在[维基百科的词条](http://zh.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97) 里面，已经列出了不同形式的Fibonacci数列的数学结果，可以直接将这些结果拿过来，通过程序计算，得到斐波那契数。此类程序，本文略。\n\n#[这种方法来自网络](http://www.cprogramto.com/fibonacci-sequence-python-code/)\n\n    print('!* Fibonacci Sequence python \\n')\n    def Fibonacci_Series():\n        x = input('Enter Series length to print fibonacci sequence')\n\n        d,e=0,1\n        a = []\n        a.append(d)\n        a.append(e)\n        while(x!=2):\n            c = d + e\n            d = e\n            e = c\n            a.append(c)\n            x = x -1\n        print(a)\n"
        },
        {
          "name": "fibonacci.py",
          "type": "blob",
          "size": 1.5107421875,
          "content": "#! /usr/bin/env python\n#coding:utf-8\n\n\"\"\"\nFibonacci数列定义：\n\nF0 = 0     (n=0)\nF1 = 1    (n=1)\nFn = F[n-1]+ F[n-2](n=>2)\n\n\"\"\"\n\n#递归，根据定义直接写\n#这种方法不是一个好方法，因为它的开销太大，比如计算fib1(100),就需要耐心等待较长一段时间了。\n\ndef fib1(n):\n    if n==0:\n        return 0\n    elif n==1:\n        return 1\n    else:\n        return fib1(n-1) + fib1(n-2)\n\n\n#递归，进行初始化\n#fib1的慢，就是因为每次都要计算前面已经算过的项目.这里将上述算法进行稍微改进。\n\nmemo = {0:0, 1:1}\ndef fib2(n):\n    if not n in memo:\n        memo[n] = fib2(n-1)+fib2(n-2)\n    return memo[n]\n\n#迭代\n\ndef fib3(n):\n    a, b = 0, 1\n    for i in range(n):\n        a, b = b, a+b\n    return a\n\n#除了上述方法之外，还可以直接用数学运算的结果\n#推荐参考：http://zh.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97中的结论\n\n#这种方法来自：http://www.cprogramto.com/fibonacci-sequence-python-code/\n\nprint('!* Fibonacci Sequence python \\n')\ndef Fibonacci_Series():\n    x = input('Enter Series length to print fibonacci sequence')\n\n    d,e=0,1\n    a = []\n    a.append(d)\n    a.append(e)\n    while(x!=2):\n        c = d + e\n        d = e\n        e = c\n        a.append(c)\n        x = x -1\n    print(a)\n\n#Output:\n\"\"\"\n!* Fibonacci Sequence python \n\n>>> Fibonacci_Series()\nEnter Series length to print fibonacci sequence10\n[0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n>>>\n\"\"\"\nif __name__==\"__main__\":\n    \n    Fibonacci_Series() \n"
        },
        {
          "name": "half_search.md",
          "type": "blob",
          "size": 1.4189453125,
          "content": "#问题\n\n查找某个值在list中的位置\n\n#解决思路\n\n可以用折半查询的方法解决此问题。\n\n#解决（Python）\n\n\t#! /usr/bin/env python\n\t#coding:utf-8\n\t\n\t#折半查找某个元素在list中的位置\n\t\n\tdef half_search(lst,value,left,right):\n\t    length = len(lst)\n\t    while left<right:\n\t        middle = (right-left)/2\n\t        if lst[middle]>value:\n\t            right = middle-1\n\t        elif lst[middle]<value:\n\t            left = middle+1\n\t        else:\n\t            return middle \n\n\tif __name__==\"__main__\":\n\t    lst=sorted([2,4,5,9])　　　　#折半算法中list要进行排序\n\t    length = len(lst)\n\t    left = 0\n\t    right = length-1\n\t    value =4 \n\t    result = half_search(lst,value,left,right)\n\t    if result:\n\t        print result\n\t    else:\n\t        print \"There is no the value that you want to search.\"\n    \n#再思考\n\n对于上面的折半方法，在python中，可以通过一个函数实现\n\n    lst = sorted([2,4,5,9])　　　　#这里进行排序，主要是为了得到与上面方法一样的结果。事实上，list.index()可以针对任何list操作，不一定非要排序\n    result = lst.index(4)\n\n此外，如果遇到list中有多个相同的元素，应该如何将这些元素的位置都查询出来呢？下面的方法是用python实现。\n\n    def find_value_location(lst,value):\n        result = [i for i in range(len(lst)) if value==lst[i]]    \n        return result\n\n##qiwsir#gmail.com\n"
        },
        {
          "name": "half_search.py",
          "type": "blob",
          "size": 0.9052734375,
          "content": "#! /usr/bin/env python\n#coding:utf-8\n\n#折半查找某个元素在list中的位置\n\ndef half_search(lst,value,left,right):\n    length = len(lst)\n    while left<right:\n        middle = (right-left)/2\n        if lst[middle]>value:\n            right = middle-1\n        elif lst[middle]<value:\n            left = middle+1\n        else:\n            return middle \n\n#如果该元素在list中不止一个，可以用下面方法找出所有位置分布\n\ndef find_value_location(lst,value):\n    result = [i for i in range(len(lst)) if value==lst[i]]    \n    return result\n\n\nif __name__==\"__main__\":\n    lst=sorted([2,4,4,5,9])\n    length = len(lst)\n    left = 0\n    right = length-1\n    value =4 \n    result = half_search(lst,value,left,right)\n    if result:\n        print result\n    else:\n        print \"There is no the value that you want to search.\"\n    lst2=[2,4,5,4,2]\n    result2 = find_value_location(lst2,4)\n    print result2\n"
        },
        {
          "name": "heap_sort.py",
          "type": "blob",
          "size": 0.24609375,
          "content": "#! /usr/bin/evn python\n#coding:utf-8\n\nfrom heapq import *\n\ndef heapsort(iterable):\n    h = []\n    for value in iterable:\n        heappush(h,value)\n    return [heappop(h) for i in range(len(h))]\n\nif __name__==\"__main__\":\n    print heapsort([1,3,5,9,2])\n"
        },
        {
          "name": "heapq.md",
          "type": "blob",
          "size": 4.0908203125,
          "content": "#python中的堆排序peapq模块\n\nheapq模块实现了python中的堆排序，并提供了有关方法。让用Python实现排序算法有了简单快捷的方式。\n\nheapq的官方文档和源码：[8.4.heapq-Heap queue algorithm](https://docs.python.org/2/library/heapq.html)\n\n下面通过举例的方式说明heapq的应用方法\n\n##实现堆排序\n\n    #! /usr/bin/evn python\n    #coding:utf-8\n\n    from heapq import *\n\n    def heapsort(iterable):\n        h = []\n        for value in iterable:\n            heappush(h,value)\n        return [heappop(h) for i in range(len(h))]\n\n    if __name__==\"__main__\":\n        print heapsort([1,3,5,9,2])\n\n###heappush()\n\nheapq.heappush(heap, item):将item压入到堆数组heap中。如果不进行此步操作，后面的heappop()失效\n\n###heappop()\n\nheapq.heappop(heap):从堆数组heap中取出最小的值，并返回。\n\n    >>> h=[]                    #定义一个list\n    >>> from heapq import *     #引入heapq模块\n    >>> h\n    []\n    >>> heappush(h,5)               #向堆中依次增加数值\n    >>> heappush(h,2)\n    >>> heappush(h,3)\n    >>> heappush(h,9)\n    >>> h                           #h的值\n    [2, 5, 3, 9]\n    >>> heappop(h)                  #从h中删除最小的，并返回该值\n    2\n    >>> h\n    [3, 5, 9]\n    >>> h.append(1)                 #注意，如果不是压入堆中，而是通过append追加一个数值\n    >>> h                           #堆的函数并不能操作这个增加的数值，或者说它堆对来讲是不存在的\n    [3, 5, 9, 1]\n    >>> heappop(h)                  #从h中能够找到的最小值是3,而不是1\n    3\n    >>> heappush(h,2)               #这时，不仅将2压入到堆内，而且1也进入了堆。\n    >>> h\n    [1, 2, 9, 5]\n    >>> heappop(h)                  #操作对象已经包含了1\n    1\n\n###heapq.heappushpop(heap, item)\n\n是上述heappush和heappop的合体，同时完成两者的功能.注意：相当于先操作了heappush(heap,item),然后操作heappop(heap)\n\n    >>> h\n    [1, 2, 9, 5]\n    >>> heappop(h)\n    1\n    >>> heappushpop(h,4)            #增加4同时删除最小值2并返回该最小值，与下列操作等同：\n    2                               #heappush(h,4),heappop(h)\n    >>> h\n    [4, 5, 9]\n\n###heapq.heapify(x)\n\nx必须是list，此函数将list变成堆，实时操作。从而能够在任何情况下使用堆的函数。\n\n    >>> a=[3,6,1]\n    >>> heapify(a)                  #将a变成堆之后，可以对其操作\n    >>> heappop(a)\n    1\n    >>> b=[4,2,5]                   #b不是堆，如果对其进行操作，显示结果如下\n    >>> heappop(b)                  #按照顺序，删除第一个数值并返回,不会从中挑选出最小的\n    4\n    >>> heapify(b)                  #变成堆之后，再操作\n    >>> heappop(b)\n    2\n\n###heapq.heapreplace(heap, item)\n\n是heappop(heap)和heappush(heap,item)的联合操作。注意，与heappushpop(heap,item)的区别在于，顺序不同，这里是先进行删除，后压入堆\n\n    >>> a=[]\n    >>> heapreplace(a,3)            #如果list空，则报错\n    Traceback (most recent call last):\n    File \"<stdin>\", line 1, in <module>\n    IndexError: index out of range\n    >>> heappush(a,3)\n    >>> a\n    [3]\n    >>> heapreplace(a,2)            #先执行删除（heappop(a)->3),再执行加入（heappush(a,2))\n    3\n    >>> a\n    [2]\n    >>> heappush(a,5)  \n    >>> heappush(a,9)\n    >>> heappush(a,4)\n    >>> a\n    [2, 4, 9, 5]\n    >>> heapreplace(a,6)            #先从堆a中找出最小值并返回，然后加入6\n    2\n    >>> a\n    [4, 5, 9, 6]\n    >>> heapreplace(a,1)            #1是后来加入的，在1加入之前，a中的最小值是4\n    4\n    >>> a\n    [1, 5, 9, 6]\n\n###heapq.merge(\\*iterables)\n\n举例：\n\n    >>> a=[2,4,6]         \n    >>> b=[1,3,5]\n    >>> c=merge(a,b)\n    >>> list(c)\n    [1, 2, 3, 4, 5, 6]\n\n在[归并排序](https://github.com/qiwsir/algorithm/blob/master/merge_sort.md)中详细演示了本函数的使用方法。\n\n###heapq.nlargest(n, iterable[, key]),heapq.nsmallest(n, iterable[, key])\n\n获取列表中最大、最小的几个值。\n\n    >>> a   \n    [2, 4, 6]\n    >>> nlargest(2,a)\n    [6, 4]\n\n"
        },
        {
          "name": "index_search.md",
          "type": "blob",
          "size": 3.462890625,
          "content": "#问题\n\n索引查找\n\n索引查找的定义，[来源百度百科](http://baike.baidu.com/view/2131886.htm)\n\n>>索引查找是在索引表和主表(即线性表的索引存储结构)上进行的查找。\n>>索引查找的过程是：\n>>- 首先根据给定的索引值K1，在索引表上查找出索引值等于K1的索引项，以确定K1对应的子表在主表中的开始位置和长度，\n>>- 然后再根据给定的关键字K2，在对应的子表中查找出关键字等于K2的元素(结点)。\n\n#思路说明\n\n对于一个list或者dictionary类型的数据，python有专门的内置函数index()进行索引查找，当然，这个查找的过程完全由python自己完成，不需要我们重写。\n\n##list索引：list.index(x)\n\npython的官方解释是：\n\n>>Return the index in the list of the first item whose value is x. It is an error if there is no such item.\n\n翻译：返回list中的第一个值为x的元素索引，如果找不到返回错误。\n\n例如：\n\n    >>> alist = ['I','am','a','human','you','are','a','programmer']\n    >>> alist.index('a')        #注意：alist中有两个\"a\",但是只返回第一个索引值\n    2\n    >>> alist.index('am')\n    1\n    >>> alist.index('he')\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>\n      ValueError: 'he' is not in list\n\n这个索引查找的复杂度是O(n)\n\n对于较小的数据，list.index(x)足矣，但是，如果对象数据量比较大了，这个就有点小马拉大车的感觉了，怎么办？熟悉本博客风格的朋友肯定会想到，绝对不是让我们自己动手写一个索引查找的东西，虽然写一个不是不可以，但是本着“拿来主义”的精神，一定要先查找一下，看看python是否已经为我们做好了轮子？\n\n#Whoosh:全文索引\n\n把[官方文档](https://pythonhosted.org/Whoosh/)的一段话拿过来：\n\n>>Whoosh is a library of classes and functions for indexing text and then searching the index. It allows you to develop custom search engines for your content. For example, if you were creating blogging software, you could use Whoosh to add a search function to allow users to search blog entries.\n\n简单翻译：\n\n>>Whoosh是一个索引文本和搜索的库，允许你为你的内容设置自定义搜索引擎。比如如果创建一个博客，可以用whoosh为它添加一个搜索功能，以便用户来搜索博文。\n\npython就是这么善解人意，就是这么高大上。\n\n这个东西怎么用？\n\n##Whoosh安装\n\n在ubuntu环境下，如果已经有pip或者easy_install，只需要直接运行：\n\n    $ sudo easy_install Whoosh\n\n或者：\n\n    $ sudo pip install Whoosh\n\n即可轻松安装。windows的朋友，是不是用linux的优势在这里体现出来呢？请用。\n\n当然，也可以到[官方下载源码进行安装](https://pypi.python.org/pypi/Whoosh/)\n\n安装之后，输入下面的内容，如果不报错，就说明已经安装成功(一个就可以检验)。\n\n    >>> from whoosh.fields import *\n    >>> from whoosh.index import create_in\n\n##Whoosh应用\n\n在官方文档上，有完整的应用讲述：https://pythonhosted.org/Whoosh/quickstart.html#a-quick-introduction\n\n此外，有几篇文章，是不错的，列在这里备查\n\n- http://blog.sina.com.cn/s/blog_819588bc0101co4b.html\n- http://www.cnblogs.com/chang/archive/2013/01/10/2855321.html\n- http://ashin.sinaapp.com/article/118/\n\n除了上述内容，在其源码存放地点，也有一些问题回答：https://bitbucket.org/mchaput/whoosh/overview\n"
        },
        {
          "name": "index_search_whoosh.md",
          "type": "blob",
          "size": 5.3583984375,
          "content": "#问题\n\nWhoosh是python中解决索引查找的模块，在讨论[索引查找的文章](https://github.com/qiwsir/algorithm/blob/master/index_search.md)已经对有关索引查找进行了阐述，此处详细说明Whoosh模块的应用。\n\n#思路说明\n\n##Whoosh的安装\n\n[这里有详细内容](https://github.com/qiwsir/algorithm/blob/master/index_search.md)\n\n##whoosh的使用步骤\n\nwhoosh在应用上划分三个步骤：\n\n1. 建立索引和模式对象\n2. 写入索引文件\n3. 搜索\n\n下面依次阐述各步骤\n\n##建立索引和模式对象\n\n###建立索引模式\n\n使用Whoosh的第一步就是要建立索引对象。首先要定义索引模式，以字段的形式列在索引中。例如：\n\n    >>> from whoosh.fields import *\n    >>> schema = Schema(title=TEXT, path=ID, content=TEXT)\n\ntitle/path/content就是所谓的字段。每个字段对应索引查找目标文件的一部分信息，上面的例子中就是建立索引的模式：索引内容包括title/path/content。一个字段建立了索引，意味着它能够被搜索；也能够被存储，意味着返回结果。例如上面的例子，可以写成：\n\n    >>> schema = Schema(title=TEXT(stored=True), path=ID(stored=True), content=TEXT)\n\n这里在某些字段后面添加了(stored=True)，意味着将返回该字段的搜索结果。\n\n以上就建立好了索引模式，不需要重复建立索引模式，因为一旦此模式建立，将随索引保存。\n\n在生产过程中，如果你愿意，还可以建立一个类用于建立索引模式。如下例子：\n\n    from whoosh.fields import SchemaClass, TEXT, KEYWORD, ID, STORED\n\n    class MySchema(SchemaClass):\n        path = ID(stored=True)\n        title = TEXT(stored=True)\n        content = TEXT\n        tags = KEYWORD\n\n**索引字段类型**\n\n在上例中，title=TEXT，title是字段名称，后面的TEXT是该字段的类型。这两个分别说明了索引内容和查找对象类型。whoosh有如下字段类型，供建立所以模式使用。\n\n- whoosh.fields.ID:仅能为一个单元值，即不能分割为若干个词，通常用于诸如文件路径，URL，日期，分类。\n- whoosh.fields.STORED:该字段随文件保存，但是不能被索引，也不能被查询。常用于显示文件信息。\n- whoosh.fields.KEYWORD:用空格或者逗号（半角）分割的关键词，可被索引和搜索。为了节省空间，不支持词汇搜索。\n- whoosh.fields.TEXT:文件的文本内容。建立文本的索引并存储，支持词汇搜索。\n- whoosh.fields.NUMERIC:数字类型，保存整数或浮点数。\n- whoosh.fields.BOOLEAN:布尔类值\n- whoosh.fields.DATETIME:时间对象类型\n\n关于[索引字段类型的更多内容，请看这里](https://pythonhosted.org/Whoosh/schema.html).\n\n###建立索引存储目录\n\n索引模式建立之后，还要建立索引存储目录。如下：\n\n    import os.path\n    from whoosh.index import create_in\n    from whoosh.index import open_dir\n\n    if not os.path.exists('index'):     #如果目录index不存在则创建\n        os.mkdir('index') \n    ix = create_in(\"index\",schema)      #按照schema模式建立索引目录\n    ix = open_dir(\"index\")　            #打开该目录一遍存储索引文件\n\n上例中，用create_in创建一个具有前述索引模式的索引存储目录对象，所有的索引将被保存在该目录（index）中。\n\n之后，用open_dir打开这个目录。\n\n第一步到此结束。\n\n把上面的代码整理一下，供参考：\n\n    import os.path\n\n    from whoosh import fields\n    from whoosh import index\n\n    schema = fields.Schema(title=TEXT(stored=True), path=ID(stored=True), content=TEXT)\n    \n    if not os.path.exists(\"index\"):\n        os.mkdir(\"index\")\n\n    ix = index.create_in(\"index\",schema)\n    ix = index.open_dir(\"index\")\n\n##写索引文件\n\n下面开始写入索引内容，过程如下：\n\n    writer = ix.writer()\n    writer.add_document(title=u\"my document\", content=u\"this is my document\", path=u\"/a\", tags=u\"firlst short\", icon=u\"/icons/star.png\")\n    writer.add_document(title=u\"my second document\", content=u\"this is my second document\", path=u\"/b\", tags=u\"second short\", icon=u\"/icons/sheep.png\")\n    writer.commit()\n\n特别注意：\n\n- 字段的值必须是unicode类型\n- 不是每个字段都必须赋值\n\n更多的内容，请参考：[如何索引文件官方文档](https://pythonhosted.org/Whoosh/indexing.html)\n\n##搜索\n\n开始搜索，需要新建立一个对象，如：\n\n    searcher = ix.searcher()\n\n一般来讲，不是这么简单地，建立对象相当于开始搜索，完事之后要关闭，所以在实战中，常常写成：\n\n    withe ix.searcher() as searcher:\n        (do somthing)\n\n或者写成（与上面的等效):\n\n    try:\n        searcher = ix.searcher()\n        (do somthing)\n    finally:\n        searcher.close()\n\n接下来就开始搜索了，以搜索content为例：\n\n    from whoosh.qparser import QueryParser\n    with ix.searcher() as searcher:\n        query = QueryParser(\"content\",ix.schema).parse(\"second\")\n        result = searcher.search(query)\n        results[0]\n\n返回显示：\n\n    {\"title\":u\"my second document\",\"path\":u\"/a\"}\n\n前面已经将上述两个字段设置为stored=True.\n\n##中文分词\n\n中文分词中，结巴分词是不错的。以下两个内容解决中文分析问题：\n\n- [结巴分词](https://github.com/qiwsir/jieba)\n- [whoosh and 结巴分词](https://github.com/qiwsir/algorithm/blob/master/chinesetokenizer.py)\n"
        },
        {
          "name": "int_divide.md",
          "type": "blob",
          "size": 0.4853515625,
          "content": "#问题\n\n将一个整数，分拆为若干整数的和。例如实现：\n4=3+1\n4=2+2\n4=2+1+1\n4=1+1+1+1\n\n#解决(Python)\n\n\t#! /usr/bin/env python\n\t#encoding:utf-8\n\t\n\t\"\"\"\n\t\"\"\"\n\t\n\tdef int_divided(m,r,out_list):\n\t    if(r==0):\n\t        return True \n\t    tm=r\n\t    while tm>0:\n\t        if(tm<=m):\n\t            out.append(tm)\n\t            if(divide(tm,r-tm,out_list)):\n\t                print out\n\t            out.pop()\n\t        tm = tm-1\n\t    return False\n\t\n\t\n\tn=6\n\toutput=[]\n\tint_divided(n-1,n,output)\n"
        },
        {
          "name": "int_divide.py",
          "type": "blob",
          "size": 0.4072265625,
          "content": "#! /usr/bin/env python\n#encoding:utf-8\n\n\"\"\"\n将一个整数，分拆为若干整数的和。例如实现：\n4=3+1\n4=2+2\n4=2+1+1\n4=1+1+1+1\n\"\"\"\n\ndef divide(m,r,out):\n    if(r==0):\n        return True \n    m1=r\n    while m1>0:\n        if(m1<=m):\n            out.append(m1)\n            if(divide(m1,r-m1,out)):\n                print out\n            out.pop()\n        m1-=1\n    return False\n\n\nn=6\nout=[]\ndivide(n-1,n,out)\n"
        },
        {
          "name": "int_divide2.py",
          "type": "blob",
          "size": 0.7919921875,
          "content": "#! /usr/bin/env python\n#encoding:utf-8\n\n\"\"\"\n给你一个小于50的数字 a ，请写出一个算法得到所有可能的数字集合，每个数字集合满足以下条件：\n\n1. 集合中所有数字的和等于a;\n\n2. 集合中的所有数字均大于1；\n\n3. 集合中可以出现重复数字；\n\n例如：\n\n2 -> {2},\n3->{3},\n4->{[4], [2, 2]},\n5->{[5], [3, 2]},\n6->{[6], [4, 2], [3, 3], [2, 2, 2]}\n7->{[7], [5, 2], [4, 3], [3, 2, 2]}\n8->{[8], [6, 2], [5, 3], [4, 4], [4, 2, 2], [3, 3, 2], [2, 2, 2, 2]}\n\"\"\"\n\ndef divide(m,r,out):\n    temp = []\n    out\n    if(r==0):\n        return True \n    m1=r\n    while m1>1:\n        if(m1<=m):\n            out.append(m1)\n            if(divide(m1,r-m1,out)):\n                print temp\n\n            out.pop()\n        m1-=1\n    return False\n\n\nn=6\nout=[]\ndivide(n-1,n,out)\n\n\n"
        },
        {
          "name": "is_prime.md",
          "type": "blob",
          "size": 1.177734375,
          "content": "#问题\n\n判断一个数是否为素数\n\n#思路说明\n\n这个问题有多种解法，以下的解法来自网络整理。供参考使用。\n\n#解决（Python）\n\n\t#! /usr/bin/env python\n\t#coding:utf-8\n\t\n\t\"\"\"\n\t\"\"\"\n\t\n\t#方法一\n\t\n\timport math  \n\t         \n\tdef isPrime1(n):  \n\t    if n <= 1:  \n\t        return False \n\t    for i in range(2, int(math.sqrt(n)) + 1):  \n\t        if n % i == 0:  \n\t            return False\n\t        \n\t    return True\n\t\n\t#方法二\n\t\n\tdef isPrime2(n):\n\t    if n <= 1:\n\t        return False\n\t                  \n\t    i = 2\n\t    while i*i <= n:\n\t        if n % i == 0:\n\t            return False\n\t        i += 1\n\t    return True\n\t\n\t#方法三\n\t\n\tfrom itertools import count\n\t\n\tdef isPrime3(n):\n\t    if n <= 1:\n\t        return False\n\t    for i in count(2):\n\t        if i * i > n:\n\t            return True\n\t        if n % i == 0:\n\t            return Fals\n\t\n\t#方法四\n\t\n\tdef isPrime4(n):\n\t    if n <= 1:\n\t        return False\n\t    if n == 2:\n\t        return True\n\t    if n % 2 == 0:\n\t        return False\n\t    i = 3\n\t    while i * i <= n:\n\t        if n % i == 0:\n\t            return False\n\t        i += 2\n\t    return True\n\t\n\t\n\tif __name__==\"__main__\":\n\t    a=isPrime4(5)\n\t    print a\n"
        },
        {
          "name": "is_prime.py",
          "type": "blob",
          "size": 1,
          "content": "#! /usr/bin/env python\n#coding:utf-8\n\n\"\"\"\n判断一个数是否为素数的几种方法\n\"\"\"\n\n#方法一\n\nimport math  \n         \ndef isPrime1(n):  \n    if n <= 1:  \n        return False \n    for i in range(2, int(math.sqrt(n)) + 1):  \n        if n % i == 0:  \n            return False\n        \n    return True\n\n#方法二\n\ndef isPrime2(n):\n    if n <= 1:\n        return False\n                  \n    i = 2\n    while i*i <= n:\n        if n % i == 0:\n            return False\n        i += 1\n    return True\n\n#方法三\n\nfrom itertools import count\n\ndef isPrime3(n):\n    if n <= 1:\n        return False\n    for i in count(2):\n        if i * i > n:\n            return True\n        if n % i == 0:\n            return Fals\n\n#方法四\n\ndef isPrime4(n):\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    i = 3\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += 2\n    return True\n\n\nif __name__==\"__main__\":\n    a=isPrime4(5)\n    print a\n"
        },
        {
          "name": "joint_int.md",
          "type": "blob",
          "size": 1.1806640625,
          "content": "#问题\n\n把一个int型数组中的数字拼成一个串，这个串代表的数字最小。\n\n＃思路说明\n\n对这个问题的理解：\n\n1. 有一个元素是int类型的list；\n\n2. 将上述list中的每个元素的数字分别取出来，然后将这些数字的顺序进行从新排列，并将其中的最小整数输入，就是题目中要求的最小数字。\n\n如果按照上述理解，在解题中，最应当小心的是数字如果很大，比如list中的某个int元素是：222222222222227777777777776666666666699999999999888888888...很大的整数，就不得不转化为字符串操作了。\n\n所以，在本问题中，基本思路是：\n\n1. 将list中的int元素转换为str；\n2. 将所有数字(str类型）装入到一个list2\n3. 对list2进行排序\n4. 将list2中的数字（str类型）组装成一个数值(str类型)\n\n#解决(Python)\n\n\t#! /user/bin/env python\n\t#coding:utf-8\n\t\n\t\n\tdef joint_int(lst):\n\t    str_list = [str(i) for i in lst]\n\t    str_lonely = [str_list[i][j] for i in range(len(str_list)) for j in range(len(str_list[i]))]\n\t    \n\t    sorted_str = sorted(str_lonely)\n\t    return \"\".join(sorted_str)\n\t\n\tprint joint_int([1230975,4087644567856])\n\n##qiwsir#gmail.com \n"
        },
        {
          "name": "joint_int.py",
          "type": "blob",
          "size": 1.130859375,
          "content": "#! /user/bin/env python\n#coding:utf-8\n\n\"\"\"\n把一个int型数组中的数字拼成一个串，这个串代表的数字最小;\n\n对这个问题的理解：\n\n１、有一个元素是int类型的list；\n\n２、将上述list中的每个元素的数字分别取出来，然后将这些数字的顺序进行从新排列，并将其中的最小整数输入，就是题目中要求的最小数字。\n\n如果按照上述理解，在解题中，最应当小心的是数字如果很大，比如list中的某个int元素是：222222222222227777777777776666666666699999999999888888888...很大的整数，就不得不转化为字符串操作了。\n\n所以，在本问题中，基本思路是：\n\n１、将list中的int元素转换为str；\n２、将所有数字(str类型）装入到一个list2\n３、对list2进行排序\n４、将list2中的数字（str类型）组装成一个数值(str类型)\n\"\"\"\n\ndef joint_int(lst):\n    str_list = [str(i) for i in lst]\n    str_lonely = [str_list[i][j] for i in range(len(str_list)) for j in range(len(str_list[i]))]\n    \n    sorted_str = sorted(str_lonely)\n    return \"\".join(sorted_str)\n\nprint joint_int([1230975,4087644567856])\n\n\n"
        },
        {
          "name": "kruskal_algorithm.md",
          "type": "blob",
          "size": 7.0166015625,
          "content": "#问题\n\n最小生成树的Kruskal算法\n\n描述：有A、B、C、D四个点，每两个点之间的距离（无方向）是(第一个数字是两点之间距离，后面两个字母代表两个点）：(1,'A','B'),(5,'A','C'),(3,'A','D'),(4,'B','C'),(2,'B','D'),(1,'C','D')\n生成边长和最小的树，也就是找出一种连接方法，将各点连接起来，并且各点之间的距离和最小。\n\n#思路说明：\n\nKruskal算法是经典的无向图最小生成树解决方法。此处列举两种python的实现方法。这两种方法均参考网上，并根据所学感受进行了适当改动。\n\n#解决1（Python）\n\n\t#! /usr/bin/env python\n\t#coding:utf-8\n\t\n\t#以全局变量X定义节点集合，即类似{'A':'A','B':'B','C':'C','D':'D'},如果A、B两点联通，则会更改为{'A':'B','B':'B\",...},即任何两点联通之后，两点的值value将相同。\n\t\n\tX = dict()      \n\t\n\t#各点的初始等级均为0,如果被做为连接的的末端，则增加1\n\t\n\tR = dict()\n\t\n\t#设置X R的初始值\n\t\n\tdef make_set(point):\n\t    X[point] = point\n\t    R[point] = 0\n\t\n\t#节点的联通分量\n\t\n\tdef find(point):\n\t    if X[point] != point:\n\t        X[point] = find(X[point])\n\t    return X[point]\n\t\n\t#连接两个分量（节点）\n\t\n\tdef merge(point1,point2):\n\t    r1 = find(point1)\n\t    r2 = find(point2)\n\t    if r1 != r2:\n\t        if R[r1] > R[r2]:\n\t            X[r2] = r1\n\t        else:\n\t            X[r1] = r2\n\t            if R[r1] == R[r2]: R[r2] += 1\n\t\n\t#KRUSKAL算法实现\n\t\n\tdef kruskal(graph):\n\t    for vertice in graph['vertices']:\n\t        make_set(vertice)\n\t\n\t    minu_tree = set()\n\t    \n\t    edges = list(graph['edges'])\n\t    edges.sort()                    #按照边长从小到达排序\n\t    for edge in edges:\n\t        weight, vertice1, vertice2 = edge\n\t        if find(vertice1) != find(vertice2):\n\t            merge(vertice1, vertice2)\n\t            minu_tree.add(edge)\n\t    return minu_tree\n\t\n\t\n\tif __name__==\"__main__\":\n\t\n\t    graph = {\n\t        'vertices': ['A', 'B', 'C', 'D', 'E', 'F'],\n\t        'edges': set([\n\t            (1, 'A', 'B'),\n\t            (5, 'A', 'C'),\n\t            (3, 'A', 'D'),\n\t            (4, 'B', 'C'),\n\t            (2, 'B', 'D'),\n\t            (1, 'C', 'D'),\n\t            ])\n\t        }\n\t\n\t    result = kruskal(graph)\n\t    print result\n\t\n\t\"\"\"\n\t参考:\n\t1.https://github.com/qiwsir/Algorithms-Book--Python/blob/master/5-Greedy-algorithms/kruskal.py\n\t2.《算法基础》(GILLES Brassard,Paul Bratley)\n\t\"\"\"\n\n\n#解决2（Python）\n\n以下代码参考http://www.ics.uci.edu/~eppstein/PADS/的源码\n\n\t#! /usr/bin/env python\n\t#coding:utf-8\n\t\n\timport unittest\n\t\n\tclass UnionFind:\n\t    \"\"\"\n\t    UnionFind的实例：\n\t    Each unionFind instance X maintains a family of disjoint sets of\n\t    hashable objects, supporting the following two methods:\n\t\n\t    - X[item] returns a name for the set containing the given item.\n\t      Each set is named by an arbitrarily-chosen one of its members; as\n\t      long as the set remains unchanged it will keep the same name. If\n\t      the item is not yet part of a set in X, a new singleton set is\n\t      created for it.\n\t\n\t    - X.union(item1, item2, ...) merges the sets containing each item\n\t      into a single larger set.  If any item is not yet part of a set\n\t      in X, it is added to X as one of the members of the merged set.\n\t    \"\"\"\n\t\n\t    def __init__(self):\n\t        \"\"\"Create a new empty union-find structure.\"\"\"\n\t        self.weights = {}\n\t        self.parents = {}\n\t\n\t    def __getitem__(self, object):\n\t        \"\"\"Find and return the name of the set containing the object.\"\"\"\n\t\n\t        # check for previously unknown object\n\t        if object not in self.parents:\n\t            self.parents[object] = object\n\t            self.weights[object] = 1\n\t            return object\n\t\n\t        # find path of objects leading to the root\n\t        path = [object]\n\t        root = self.parents[object]\n\t        while root != path[-1]:\n\t            path.append(root)\n\t            root = self.parents[root]\n\t\n\t        # compress the path and return\n\t        for ancestor in path:\n\t            self.parents[ancestor] = root\n\t        return root\n\t        \n\t    def __iter__(self):\n\t        \"\"\"Iterate through all items ever found or unioned by this structure.\"\"\"\n\t        return iter(self.parents)\n\t\n\t    def union(self, *objects):\n\t        \"\"\"Find the sets containing the objects and merge them all.\"\"\"\n\t        roots = [self[x] for x in objects]\n\t        heaviest = max([(self.weights[r],r) for r in roots])[1]\n\t        for r in roots:\n\t            if r != heaviest:\n\t                self.weights[heaviest] += self.weights[r]\n\t                self.parents[r] = heaviest\n\t\n\t\n\t\"\"\"\n\tVarious simple functions for graph input.\n\t\n\tEach function's input graph G should be represented in such a way that \"for v in G\" loops through the vertices, and \"G[v]\" produces a list of the neighbors of v; for instance, G may be a dictionary mapping each vertex to its neighbor set.\n\t\n\tD. Eppstein, April 2004.\n\t\"\"\"\n\t\n\tdef isUndirected(G):\n\t    \"\"\"Check that G represents a simple undirected graph.\"\"\"\n\t    for v in G:\n\t        if v in G[v]:\n\t            return False\n\t        for w in G[v]:\n\t            if v not in G[w]:\n\t                return False\n\t    return True\n\t\n\t\n\tdef union(*graphs):\n\t    \"\"\"Return a graph having all edges from the argument graphs.\"\"\"\n\t    out = {}\n\t    for G in graphs:\n\t        for v in G:\n\t            out.setdefault(v,set()).update(list(G[v]))\n\t    return out\n\t\n\t\n\t\"\"\"\n\tKruskal's algorithm for minimum spanning trees. D. Eppstein, April 2006.\n\t\"\"\"\n\t\n\tdef MinimumSpanningTree(G):\n\t    \"\"\"\n\t    Return the minimum spanning tree of an undirected graph G.\n\t    G should be represented in such a way that iter(G) lists its\n\t    vertices, iter(G[u]) lists the neighbors of u, G[u][v] gives the\n\t    length of edge u,v, and G[u][v] should always equal G[v][u].\n\t    The tree is returned as a list of edges.\n\t    \"\"\"\n\t    if not isUndirected(G):\n\t        raise ValueError(\"MinimumSpanningTree: input is not undirected\")\n\t    for u in G:\n\t        for v in G[u]:\n\t            if G[u][v] != G[v][u]:\n\t                raise ValueError(\"MinimumSpanningTree: asymmetric weights\")\n\t\n\t    # Kruskal's algorithm: sort edges by weight, and add them one at a time.\n\t    # We use Kruskal's algorithm, first because it is very simple to\n\t    # implement once UnionFind exists, and second, because the only slow\n\t    # part (the sort) is sped up by being built in to Python.\n\t    subtrees = UnionFind()\n\t    tree = []\n\t    for W,u,v in sorted((G[u][v],u,v) for u in G for v in G[u]):\n\t        if subtrees[u] != subtrees[v]:\n\t            tree.append((u,v))\n\t            subtrees.union(u,v)\n\t    return tree        \n\t\n\t\n\t# If run standalone, perform unit tests\n\t\n\tclass MSTTest(unittest.TestCase):\n\t    def testMST(self):\n\t        \"\"\"Check that MinimumSpanningTree returns the correct answer.\"\"\"\n\t        G = {0:{1:11,2:13,3:12},1:{0:11,3:14},2:{0:13,3:10},3:{0:12,1:14,2:10}}\n\t        T = [(2,3),(0,1),(0,3)]\n\t        for e,f in zip(MinimumSpanningTree(G),T):\n\t            self.assertEqual(min(e),min(f))\n\t            self.assertEqual(max(e),max(f))\n\t\n\tif __name__ == \"__main__\":\n\t    unittest.main()   \n"
        },
        {
          "name": "kruskal_algorithm.py",
          "type": "blob",
          "size": 2.1103515625,
          "content": "#! /usr/bin/env python\n#coding:utf-8\n\n\"\"\"\n最小生成树的Kruskal算法\n\n描述：有A、B、C、D四个点，每两个点之间的距离（无方向）是(第一个数字是两点之间距离，后面两个字母代表两个点）：(1,'A','B'),(5,'A','C'),(3,'A','D'),(4,'B','C'),(2,'B','D'),(1,'C','D')\n生成边长和最小的树，也就是找出一种连接方法，将各点连接起来，并且各点之间的距离和最小。\n\n\"\"\"\n\n#以全局变量X定义节点集合，即类似{'A':'A','B':'B','C':'C','D':'D'},如果A、B两点联通，则会更改为{'A':'B','B':'B\",...},即任何两点联通之后，两点的值value将相同。\n\nX = dict()      \n\n#各点的初始等级均为0,如果被做为连接的的末端，则增加1\n\nR = dict()\n\n#设置X R的初始值\n\ndef make_set(point):\n    X[point] = point\n    R[point] = 0\n\n#节点的联通分量\n\ndef find(point):\n    if X[point] != point:\n        X[point] = find(X[point])\n    return X[point]\n\n#连接两个分量（节点）\n\ndef merge(point1,point2):\n    r1 = find(point1)\n    r2 = find(point2)\n    if r1 != r2:\n        if R[r1] > R[r2]:\n            X[r2] = r1\n        else:\n            X[r1] = r2\n            if R[r1] == R[r2]: R[r2] += 1\n\n#KRUSKAL算法实现\n\ndef kruskal(graph):\n    for vertice in graph['vertices']:\n        make_set(vertice)\n\n    minu_tree = set()\n    \n    edges = list(graph['edges'])\n    edges.sort()                    #按照边长从小到达排序\n    for edge in edges:\n        weight, vertice1, vertice2 = edge\n        if find(vertice1) != find(vertice2):\n            merge(vertice1, vertice2)\n            minu_tree.add(edge)\n    return minu_tree\n\n\nif __name__==\"__main__\":\n\n    graph = {\n        'vertices': ['A', 'B', 'C', 'D', 'E', 'F'],\n        'edges': set([\n            (1, 'A', 'B'),\n            (5, 'A', 'C'),\n            (3, 'A', 'D'),\n            (4, 'B', 'C'),\n            (2, 'B', 'D'),\n            (1, 'C', 'D'),\n            ])\n        }\n\n    result = kruskal(graph)\n    print result\n\n\"\"\"\n参考:\n1.https://github.com/qiwsir/Algorithms-Book--Python/blob/master/5-Greedy-algorithms/kruskal.py\n2.《算法基础》(GILLES Brassard,Paul Bratley)\n\"\"\"\n"
        },
        {
          "name": "kruskal_algorithm2.py",
          "type": "blob",
          "size": 4.46484375,
          "content": "#! /usr/bin/env python\n#coding:utf-8\n\"\"\"\n以下代码参考http://www.ics.uci.edu/~eppstein/PADS/的源码\n\"\"\"\n\nclass UnionFind:\n    \"\"\"\n    UnionFind的实例：\n    Each unionFind instance X maintains a family of disjoint sets of\n    hashable objects, supporting the following two methods:\n\n    - X[item] returns a name for the set containing the given item.\n      Each set is named by an arbitrarily-chosen one of its members; as\n      long as the set remains unchanged it will keep the same name. If\n      the item is not yet part of a set in X, a new singleton set is\n      created for it.\n\n    - X.union(item1, item2, ...) merges the sets containing each item\n      into a single larger set.  If any item is not yet part of a set\n      in X, it is added to X as one of the members of the merged set.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Create a new empty union-find structure.\"\"\"\n        self.weights = {}\n        self.parents = {}\n\n    def __getitem__(self, object):\n        \"\"\"Find and return the name of the set containing the object.\"\"\"\n\n        # check for previously unknown object\n        if object not in self.parents:\n            self.parents[object] = object\n            self.weights[object] = 1\n            return object\n\n        # find path of objects leading to the root\n        path = [object]\n        root = self.parents[object]\n        while root != path[-1]:\n            path.append(root)\n            root = self.parents[root]\n\n        # compress the path and return\n        for ancestor in path:\n            self.parents[ancestor] = root\n        return root\n        \n    def __iter__(self):\n        \"\"\"Iterate through all items ever found or unioned by this structure.\"\"\"\n        return iter(self.parents)\n\n    def union(self, *objects):\n        \"\"\"Find the sets containing the objects and merge them all.\"\"\"\n        roots = [self[x] for x in objects]\n        heaviest = max([(self.weights[r],r) for r in roots])[1]\n        for r in roots:\n            if r != heaviest:\n                self.weights[heaviest] += self.weights[r]\n                self.parents[r] = heaviest\n\n\n\"\"\"\n\nVarious simple functions for graph input.\n\nEach function's input graph G should be represented in such a way that \"for v in G\" loops through the vertices, and \"G[v]\" produces a list of the neighbors of v; for instance, G may be a dictionary mapping each vertex to its neighbor set.\n\nD. Eppstein, April 2004.\n\"\"\"\n\ndef isUndirected(G):\n    \"\"\"Check that G represents a simple undirected graph.\"\"\"\n    for v in G:\n        if v in G[v]:\n            return False\n        for w in G[v]:\n            if v not in G[w]:\n                return False\n    return True\n\n\ndef union(*graphs):\n    \"\"\"Return a graph having all edges from the argument graphs.\"\"\"\n    out = {}\n    for G in graphs:\n        for v in G:\n            out.setdefault(v,set()).update(list(G[v]))\n    return out\n\n\n\"\"\"\n\nKruskal's algorithm for minimum spanning trees. D. Eppstein, April 2006.\n\"\"\"\n\nimport unittest\n\ndef MinimumSpanningTree(G):\n    \"\"\"\n    Return the minimum spanning tree of an undirected graph G.\n    G should be represented in such a way that iter(G) lists its\n    vertices, iter(G[u]) lists the neighbors of u, G[u][v] gives the\n    length of edge u,v, and G[u][v] should always equal G[v][u].\n    The tree is returned as a list of edges.\n    \"\"\"\n    if not isUndirected(G):\n        raise ValueError(\"MinimumSpanningTree: input is not undirected\")\n    for u in G:\n        for v in G[u]:\n            if G[u][v] != G[v][u]:\n                raise ValueError(\"MinimumSpanningTree: asymmetric weights\")\n\n    # Kruskal's algorithm: sort edges by weight, and add them one at a time.\n    # We use Kruskal's algorithm, first because it is very simple to\n    # implement once UnionFind exists, and second, because the only slow\n    # part (the sort) is sped up by being built in to Python.\n    subtrees = UnionFind()\n    tree = []\n    for W,u,v in sorted((G[u][v],u,v) for u in G for v in G[u]):\n        if subtrees[u] != subtrees[v]:\n            tree.append((u,v))\n            subtrees.union(u,v)\n    return tree        \n\n\n# If run standalone, perform unit tests\n\nclass MSTTest(unittest.TestCase):\n    def testMST(self):\n        \"\"\"Check that MinimumSpanningTree returns the correct answer.\"\"\"\n        G = {0:{1:11,2:13,3:12},1:{0:11,3:14},2:{0:13,3:10},3:{0:12,1:14,2:10}}\n        T = [(2,3),(0,1),(0,3)]\n        for e,f in zip(MinimumSpanningTree(G),T):\n            self.assertEqual(min(e),min(f))\n            self.assertEqual(max(e),max(f))\n\nif __name__ == \"__main__\":\n    unittest.main()   \n"
        },
        {
          "name": "longest_increasing_sequence.md",
          "type": "blob",
          "size": 0.36328125,
          "content": "# 问题简介\n最长公共上升子序列，longest increasing sequence，简称LCIS\n# 思路\n这个问题要由动态规划来解决，时间复杂度是O(n<sup>2</sup>)，空间复杂度是O(n)，建立dp[n]和track[n]    \n意义：\n----\n* dp[i]：以数据a[i]结尾的最长上升序列长度\n* track[i]：数据a[i]作为最长上升序列末项的前一项索引\n\n\n"
        },
        {
          "name": "longest_increasing_sequence.py",
          "type": "blob",
          "size": 0.7138671875,
          "content": "#!/usr/bin/python\n#coding: utf-8\n\ndef isBiggerCompare(a, b):\n\treturn a > b\n\ndef findLIS(sequence, compare = isBiggerCompare):\n\tn = len(sequence)\n\tdp = [0 for i in range(n)]\n\ttrack = [-1 for i in range(n)]\n\tans = 1\n\tfor i in range(1, n):\n\t\tMAX = 0\n\t\tfor j in range(i):\n\t\t\tif compare(sequence[i], sequence[j]) and MAX < dp[j]:\n\t\t\t\tMAX = dp[j]\n\t\t\t\ttrack[i] = j\n\t\t\t\t# track[i] sequence[i]作为最长上升序列末项的前一项\n\t\tdp[i] = MAX + 1\n\t\t# dp[i] 以sequence[i]结尾的最长上升序列长度\n\t\tif dp[i] > dp[ans]:\n\t\t\tans = i\n\tansList = [sequence[ans]]\n\twhile track[ans] != -1:\n\t\tans = track[ans]\n\t\tansList.insert(0, sequence[ans])\n\treturn ansList\n\nif __name__ == '__main__':\n\ts = [3, 1, 2, 1, 4, 3, 5]\n\tprint findLIS(s)\n"
        },
        {
          "name": "lua_string_to_table.lua",
          "type": "blob",
          "size": 0.3876953125,
          "content": "--在LUA中，没有类似python的str.split()函数，如果要将一个字符串按照指定的符号分割，并存到table中。\n--如将a=\"1,2,3\"转换为{1,2,3}\n\na=\"1,2,3,4,\"    --或者 a=\"1,2,3,4\" 不论最后一个是否有\",\"\nt={}\n\nfor w in string.gmatch(a,\"([^',']+)\") do     --按照“,”分割字符串\n    table.insert(t,w) \nend\n\nfor k,v in ipairs(t) do \n    print(k..\":\"..v) \nend\n"
        },
        {
          "name": "max_sum.md",
          "type": "blob",
          "size": 2.2919921875,
          "content": "#问题\n\n最大连续子数组，求一个有正，有负数的数组(有正和负数，没有全是负数的情况)，连续子数组之最大和。\n要求时间复杂度为O(n)\n\n#解决（Python）\n\n\t#coding:utf-8\n\t\n\tdef max_array(lst):\n\t    this_sum = 0\n\t    max_sum = 0\n\t    for item in lst:\n\t        this_sum += item\n\t        if this_sum > max_sum:\n\t            max_sum = this_sum\n\t        elif this_sum < 0:\n\t            this_sum = 0\n\t    return max_sum\n\n    test_lst = [-2,11,-4,13,-5,-2]\n    print(max_array(test_lst))\n\n##迪艾姆python培训 黄哥所写 咨询:qq:1465376564  \n##迪艾姆python远程视频培训班\n\n# python 解法转译为 racket (racket 5.2.1)\n\n经过推敲, 发现上述 python 的解法已经比较简单. \n在 O(n) 的时间复杂度限制下, 无论是换种解决策略或者进一步优化现有策略, 都没有想出好点子.\n为了保持进度, 仅仅将 python 的解法实现转译为 racket 语言实现.\n\n```racket\n\n(define (max-array number-list)\n  (let*\n    ([this-sum 0]\n     [max-sum 0])\n    (for ([item number-list])\n      (begin \n        (set! this-sum (+ this-sum item))\n        (if (> this-sum max-sum)\n          (set! max-sum this-sum)\n          (if (< this-sum 0)\n            (set! this-sum 0)\n            '()))))\n    max-sum))\n\n; 函数调用, 正常运行后, 将输出一个整数 20.\n(max-array '(-2 11 -4 13 -5 -2))\n\n```\n\n如果不限制 O(n) , 并且刻意消除 set! 这样的赋值操作, \n那么比较直观但浪费时间的解法如下:\n\n```racket\n#lang racket\n\n(define number-list '(-2 11 -4 13 -5 -2))\n\n(define (iterate-by-n a-list n)  ; 用穷举法列出某个列表中, 长度为 n 的所有连续子列表\n  (let*\n    ([len (length a-list)]\n     [last-idx (- len n)])\n    (for/list ([i (+ last-idx 1)])\n      (take \n       (take-right a-list (- len i))\n       n))))\n\n(define (max-array number-list)\n  (let \n    ([list-of-every-length   ; 用穷举法列出所有 \"可能长度\" 的连续子列表\n      (for/list \n        ([i (in-range 1 (+ (length number-list) 1))])\n          (iterate-by-n number-list i))])\n    (apply max   ; 求所有可能的连续子列表分别求和, 求出其中的最大和\n      (map (lambda (l) (apply + l))\n        (apply append list-of-every-length)))))\n\n; 函数调用, 正常运行的情况下, 将输出整数 20\n(max-array number-list)\n```\n"
        },
        {
          "name": "max_sum.py",
          "type": "blob",
          "size": 0.6005859375,
          "content": "#coding:utf-8\n\ndef max_array(lst):\n    \"\"\"面试题：最大连续子数组，求一个有正，有负数的数组(有正和负数，没有全是负数的情况)，\n    连续子数组之最大和。\n    迪艾姆python培训 黄哥所写 咨询:qq:1465376564  \n    迪艾姆python远程视频培训班\n    要求时间复杂度为O(n)\n    \"\"\"\n    this_sum = 0\n    max_sum = 0\n    for item in lst:\n        this_sum += item\n        if this_sum > max_sum:\n            max_sum = this_sum\n        elif this_sum < 0:\n            this_sum = 0\n    return max_sum\n\ntest_lst = [-2,11,-4,13,-5,-2]\nprint(max_array(test_lst))\n"
        },
        {
          "name": "merge_sort.md",
          "type": "blob",
          "size": 4.0791015625,
          "content": "#问题\n\n归并排序\n\n#思路说明\n\n归并操作过程：\n\n1. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列\n2. 设定两个指针，最初位置分别为两个已经排序序列的起始位置\n3. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置\n4. 重复步骤3直到某一指针达到序列尾\n5. 将另一序列剩下的所有元素直接复制到合并序列尾\n\n上述说法是理论表述，下面用一个实际例子说明：\n\n例如一个无序数组[6,2,3,1,7]\n\n首先将这个数组通过递归方式进行分解，直到：[6],[2],[3],[1],[7]\n\n然后开始合并排序，也是用递归的方式进行：\n\n1. 两个两个合并排序，得到：[2,6],[1,3],[7]\n2. 上一步中，其实也是按照本步骤的方式合并的，只不过由于每个list中一个数，不能完全显示过程。下面则可以完全显示过程。\n    \n    初始：\n    a = [2,6]\n    b = [1,3]\n    c = []\n    第1步，顺序从a,b中取出一个数字：2,1\n    比较大小后放入c中，并将该数字从原list中删除，结果是：\n    a = [2,6]\n    b = [3]\n    c = [1]\n    第2步，继续从a,b中按照顺序取出数字，也就是重复上面步骤，这次是：2,3\n    比较大小后放入c中，并将该数字从原list中删除，结果是：\n    a = [6]\n    b = [3]\n    c = [1,2]\n    第3步,再重复前边的步骤,结果是：\n    a = [6]\n    b = []\n    c = [1,2,3]\n    最后一步，将6追加到c中，结果形成了：\n    a = []\n    b = []\n    c = [1,2,3,6]\n\n3. 通过反复应用上面的流程，实现[1,2,3,6]与[7]的合并\n4. 最终得到排序结果[1,2,3,6,7]\n\n本文列举了三种python的实现方法。\n\n#解决(Python)\n\n\t#! /usr/bin/env python\n\t#coding:utf-8\n\t\n\t#方法1：将前面讲述的过程翻译过来了，略先拙笨\n\t\n\tdef merge_sort(seq):\n\t    if len(seq) ==1:\n\t        return seq\n\t    else:\n\t        middle = len(seq)/2\n\t        left = merge_sort(seq[:middle])\n\t        right = merge_sort(seq[middle:])\n\t\n\t        i = 0   #left 计数\n\t        j = 0   #right 计数\n\t        k = 0   #总计数\n\t\n\t        while i < len(left) and j < len(right):\n\t            if left[i] < right [j]:\n\t                seq[k] = left[i]\n\t                i +=1\n\t                k +=1\n\t            else:\n\t                seq[k] = right[j]\n\t                j +=1\n\t                k +=1\n\t        \n\t        remain = left if i<j else right\n\t        r = i if remain ==left else j\n\t\n\t        while r<len(remain):\n\t            seq[k] = remain[r]\n\t            r +=1\n\t            k +=1\n\t\n\t        return seq\n\t\n\t#方法2：在按照顺序取数值方面，应用了list.pop()方法，代码更紧凑简洁\n\t#此方法来[自维基百科：归并操作](http://zh.wikipedia.org/zh/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F)\n\t\n\tdef merge_sort(lst):   #此方法来自维基百科：http://zh.wikipedia.org/zh/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F\n\t    if len(lst) <= 1:\n\t        return lst\n\t                 \n\t    def merge(left, right):\n\t        merged = []\n\t        \n\t        while left and right:\n\t            merged.append(left.pop(0) if left[0] <= right[0] else right.pop(0))\n\t        \n\t        while left:\n\t            merged.append(left.pop(0))\n\t        \n\t        while right:\n\t            merged.append(right.pop(0))\n\t        \n\t        return merged\n\t        \n\t    middle = int(len(lst) / 2) \n\t    left = merge_sort(lst[:middle])\n\t    right = merge_sort(lst[middle:])\n\t    return merge(left, right)\n\t\n\t#方法3：原来在python的模块heapq中就提供了归并排序的方法，只要将分解后的结果导入该方法即可\n\t#强大。\n\t#以下方法来自[resettacode](http://rosettacode.org/wiki/Sorting_algorithms/Merge_sort#Python),并稍作修改\n\t\n\tfrom heapq import merge\n\t \n\tdef merge_sort(seq):\n\t    if len(seq) <= 1:\n\t        return m\n\t    else:              \n\t        middle = len(seq)/2\n\t        left = merge_sort(seq[:middle])\n\t        right = merge_sort(seq[middle:])\n\t        return list(merge(left, right))         #heapq.merge()\n\t\n\tif __name__==\"__main__\":\n\t    seq = [1,3,6,2,4]\n\t    print merge_sort(seq)\n"
        },
        {
          "name": "merge_sort.py",
          "type": "blob",
          "size": 1.8388671875,
          "content": "#! /usr/bin/env python\n#coding:utf-8\n\"\"\"\n#solve 1\n\ndef merge_sort(seq):\n    if len(seq) ==1:\n        return seq\n    else:\n        middle = len(seq)/2\n        left = merge_sort(seq[:middle])\n        right = merge_sort(seq[middle:])\n\n        i = 0   #left 计数\n        j = 0   #right 计数\n        k = 0   #总计数\n\n        while i < len(left) and j < len(right):\n            if left[i] < right [j]:\n                seq[k] = left[i]\n                i +=1\n                k +=1\n            else:\n                seq[k] = right[j]\n                j +=1\n                k +=1\n        \n        remain = left if i<j else right\n        r = i if remain ==left else j\n\n        while r<len(remain):\n            seq[k] = remain[r]\n            r +=1\n            k +=1\n\n        return seq\n\n#solve 2\n\ndef merge_sort(lst):   #此方法来自维基百科：http://zh.wikipedia.org/zh/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F\n    if len(lst) <= 1:\n        return lst\n                 \n    def merge(left, right):\n        merged = []\n        \n        while left and right:\n            merged.append(left.pop(0) if left[0] <= right[0] else right.pop(0))\n        \n        while left:\n            merged.append(left.pop(0))\n        \n        while right:\n            merged.append(right.pop(0))\n        \n        return merged\n        \n    middle = int(len(lst) / 2) \n    left = merge_sort(lst[:middle])\n    right = merge_sort(lst[middle:])\n    return merge(left, right)\n\"\"\"\n#solve 3\n#以下方法来自：http://rosettacode.org/wiki/Sorting_algorithms/Merge_sort#Python\n#稍作修改\n\nfrom heapq import merge\n \ndef merge_sort(seq):\n    if len(seq) <= 1:\n        return seq\n    else:\n        middle = len(seq)/2\n        left = merge_sort(seq[:middle])\n        right = merge_sort(seq[middle:])\n        return list(merge(left,right))\n\nif __name__==\"__main__\":\n    seq = [1,3,6,2,4]\n    print merge_sort(seq)\n"
        },
        {
          "name": "most_char_num.md",
          "type": "blob",
          "size": 3.314453125,
          "content": "#问题：\n\n查找字符串中出现最多的字符和个数？\n\n如 sdsdsddssssssdd -> 字符最多的是s，出现9次\n\n#思路说明\n\n利用python中的collections模块的Counter，[查此函数详细内容](https://docs.python.org/2/library/collections.html).对字符串进行统计。\n\n然后将结果转化为字典类型。\n\n特别注意，在字符串中可能会出现数量并列第一的字符，因此要通过循环找出最大数之后，再通过循环找出最大数对应的字母（键）。\n\n#解答1(python)\n\n    import collections\n\n    def most_character_number(one_string):\n        static_result = collections.Counter(one_string) \n        result = dict(static_result)                            \n        most_number = max([value for value in result.values()])\n        most_character = [key for key,value in result.items() if value==most_number]\n        return (most_number,most_character)\n\n    if __name__ == \"__main__\":\n        (most_num,most_char) = most_character_number(\"yyyyyyddddddkuuuiii\")\n        print (\"The most character is:%s\"%most_num)\n        print (\"The number is:\")\n        for char in most_char:\n            print char\n\n#解答2(python)\n\n    str1 = \"sdsdsddssssssssdd\"\n    \n    def most_character_number(one_string):\n        \"\"\"利用字典key来统计次数\"\"\"\n        str_dict = {}\n        for item in one_string:\n            if item in str_dict:\n                str_dict[item] +=1\n            else:\n                str_dict[item] =1\n\n        \n        str_dict = {str_dict[key]:key for key in str_dict}\n        return (max(str_dict),str_dict[max(str_dict)])\n\n    print (most_character_number(str1))\n\n解答2由黄老师提供，[他的微博](http://weibo.com/qiyeminglu)。\n\n##欢迎接龙，可以按照上面格式继续。\n\n------\n\n#解答3 (racket 5.2.1)\n\n```racket\n#lang racket\n\n; 需要引用 scheme 标准库中的 list 库 (SRFI-1)\n(require srfi/1)\n\n; 定义函数 get-key-by-value\n; 输入一个 Hash 表和一个 a-value (用于反向查找 key 的 value)\n; 输出 value 等于 a-value 的那些 key,\n; 换言之, 此 key 满足条件 (hash-ref key) == a-value.\n(define (get-key-by-value a-hash a-value)\n  (hash-for-each a-hash\n    (lambda (k v)\n      (if (= a-value (hash-ref a-hash k))\n        (printf \"~a: ~a~n\" k v) '()))))\n\n; 定义函数 char-cmp\n; 输入一个 preset-char (预设字符)\n; 返回一个的匿名函数 (其内部包含 preset-char)\n; > 其输入为 char-to-be-compared (待比较的字符)\n; > 当 char-to-be-compared 与 preset-char \n; > 相等时输出 true, 否则输出 false\n(define (char-cmp preset-char)\n  (lambda (char-to-be-compared)\n    (if (char=? preset-char char-to-be-compared) true false)))\n\n; 定义函数 most-character-number\n; 输入一个 a-string 任意字符串\n; 输出 a-string 中出现次数最多的字符, 及其出现次数\n(define (most-character-number a-string)\n  (let*\n    ([all-chars-list (string->list a-string)]\n     [key-chars-list (delete-duplicates all-chars-list)]\n     [result-hash (make-hash)])\n    (for ([key-char key-chars-list])\n      (hash-set! result-hash\n        key-char (count (char-cmp key-char) all-chars-list)))\n      (get-key-by-value \n        result-hash \n        (apply max (hash-values result-hash)))))\n\n; 以下函数调用在正常运行之后, 应该显示\n; f: 3\n; d: 3\n; a: 3\n(most-character-number \"ssfdaa dffda \")\n```\n\n##联系老齐：qiwsir#gmail.com\n"
        },
        {
          "name": "most_char_num.py",
          "type": "blob",
          "size": 0.9189453125,
          "content": "#! /usr/bin/env python\n#coding:utf-8\n\n#问题：\n\n#查找字符串中出现最多的字符和个数？\n\n#如 sdsdsddssssssdd -> 字符最多的是s，出现9次\n\nimport collections\n\ndef most_character_number(one_string):\n    static_result = collections.Counter(one_string)             #统计字母及其数量，返回类似Counter({'a': 3, 'b': 3, 'c': 1})形式结果\n    result = dict(static_result)                                #转化为dict类型\n    most_number = max([value for value in result.values()])     #通过循环，找出dict的值中最大数\n    most_character = [key for key,value in result.items() if value==most_number]    #找出最大数对应的key\n    return (most_number,most_character)\n\nif __name__ == \"__main__\":\n    (most_num,most_char) = most_character_number(\"yyyyyyddddddkuuuiii\")\n    print (\"The most character is:%s\"%most_num)\n    print (\"The number is:\")\n    for char in most_char:\n        print char\n"
        },
        {
          "name": "most_char_num2.py",
          "type": "blob",
          "size": 0.4443359375,
          "content": "#! /usr/bin/env python\n#coding:utf-8\n\nstr1 = \"jjjjjjddddddllooppxx\"\n    \ndef most_character_number(one_string):\n    \"\"\"利用字典key来统计次数\"\"\"\n    str_dict = {}\n    for item in one_string:\n        if item in str_dict:\n            str_dict[item] +=1\n        else:\n            str_dict[item] =1\n        \n    str_dict = {str_dict[key]:key for key in str_dict}\n    return (max(str_dict),str_dict[max(str_dict)])\n\nprint (most_character_number(str1))\n"
        },
        {
          "name": "operate_int_list.md",
          "type": "blob",
          "size": 2.50390625,
          "content": "#问题\n\n定义一个int型的一维数组，包含10个元素，赋一些随机整数\n然后求出所有元素的最大值，最小值，平均值，和值，并输出出来。\n\n#思路说明\n\n本问题是一个普通的对整数数组的操作，在下面的Python解决方法中，主要是尝试了python的一个内置函数reduce。\n\n#解决（Python）\n\n    #! /usr/bin/env python\n    #coding:utf-8\n\n    from __future__ import division     #实现精确的除法，例如4/3=1.333333\n    import random\n\n    def add(x,y):\n        return x+y\n\n    def operate_int_list():\n        int_list = [random.randint(1,100) for i in range(10)]     #在1,100范围内，随机选择10个整数组成一个list\n        max_num = max(int_list)\n        min_num = min(int_list)\n        sum_num = reduce(add,int_list)      #这里使用了reduce函数，也可以使用for循环，如下所示\n        \"\"\"\n        sum_num = 0\n        for i in int_list:\n            sum_num = sum_num+i\n        \"\"\"\n        ave_num = sum_num/len(int_list)\n\n        return (int_list,max_num,min_num,sum_num,ave_num)\n\n    if __name__==\"__main__\":\n        int_list,max_num,min_num,sum_num,ave_num = operate_int_list()\n        print \"the int list is:\",int_list\n        print \"max number is:\",max_num\n        print \"min number is:\",min_num\n        print \"the sum of all int in the list:\",sum_num\n        print \"the average of the sum:\",ave_num\n\n# 解法 (racket 5.2.1)\n\n```racket\n#lang racket\n\n; 定义一个函数 operate-int-list\n; 它接受一个正整数输入 n\n; 它的输出是一个列表\n; 列表的第一项是一个长度为 n 的列表, 此列表的每个元素都是一个 1~100 之间的伪随机数\n; 列表的第二、三、四、五项分别为\n; 所有伪随机数中的最大者\n; 所有伪随机数中的最小者\n; 所有伪随机数的总和\n; 所有伪随机数中平均值，以有理数形式表示\n(define (operate-int-list n)\n  (if (<= n 0)\n      false\n      (let* \n          ([rand1to100 (lambda () (+ 1 (random 100)))]\n           [random-list (for/list ([i n]) (rand1to100))]\n           [max-int (apply max random-list)]\n           [min-int (apply min random-list)]\n           [sum (apply + random-list)]\n           [average (/ (apply + random-list) (length random-list))])\n        (list random-list\n              max-int min-int sum average))))\n\n; 函数调用，当程序运行正常时，运算结果在形式上类似于以下结果，\n; 但每次的结果列表都有一定的随机性\n; '((19 77 15 49 39 84 45 72 75 100) 100 15 575 57½)\n(operate-int-list 10)\n```\n"
        },
        {
          "name": "operate_int_list.py",
          "type": "blob",
          "size": 1.115234375,
          "content": "#! /usr/bin/env python\n#coding:utf-8\n\n\"\"\"\n问题描述：\n\n定义一个int型的一维数组，包含10个元素，赋一些随机整数\n然后求出所有元素的最大值，最小值，平均值，和值，并输出出来。\n\"\"\"\n\nfrom __future__ import division     #实现精确的除法，例如4/3=1.333333\nimport random\n\ndef add(x,y):\n    return x+y\n\ndef operate_int_list():\n    int_list = [random.randint(1,100) for i in range(10)]     #在1,100范围内，随机选择10个整数组成一个list\n    max_num = max(int_list)\n    min_num = min(int_list)\n    sum_num = reduce(add,int_list)      #这里使用了reduce函数，也可以使用for循环，如下所示\n    \"\"\"\n    sum_num = 0\n    for i in int_list:\n        sum_num = sum_num+i\n    \"\"\"\n    ave_num = sum_num/len(int_list)\n\n    return (int_list,max_num,min_num,sum_num,ave_num)\n\nif __name__==\"__main__\":\n    int_list,max_num,min_num,sum_num,ave_num = operate_int_list()\n    print \"the int list is:\",int_list\n    print \"max number is:\",max_num\n    print \"min number is:\",min_num\n    print \"the sum of all int in the list:\",sum_num\n    print \"the average of the sum:\",ave_num\n"
        },
        {
          "name": "perfect_number.md",
          "type": "blob",
          "size": 1.5712890625,
          "content": "#问题\n\n寻找完全数。\n\n#思路说明\n\n所谓完全数，从[维基百科的完全数词条](http://zh.wikipedia.org/wiki/%E5%AE%8C%E5%85%A8%E6%95%B0)中得到：\n\n>完全数，又称完美数或完备数，是一些特殊的自然数：它所有的真因子（即除了自身以外的约数）的和，恰好等于它本身，完全数不可能是楔形数。\n>例如：第一个完全数是6，它有约数1、2、3、6，除去它本身6外，其余3个数相加，1+2+3＝6，恰好等于本身。第二个完全数是28，它有约数1、2、4、7、14、28，除去它本身28外，其余5个数相加，1+2+4+7+14＝28，也恰好等于本身。后面的数是496、8128。\n\n更多完全数内容请看该词条。\n\n所以，要找一个完全数的解决思路是：\n\n1. 找出一个数的所有因数\n2. 验证这些因数的和是否等于这个数，如果等于，就是完全数。\n\n#解决(python)\n\t\n\t#!/usr/bin/env python\n\t#coding:utf-8\n\t\n\t#找出一个数的因数\n\tdef factors(n):\n\t    #return [i for i in range(1,n/2+1) if n%i == 0]\n\t    #如果仅仅是为了得到因数，可以用上面的\n\t    #如果是配合下面完全数，最好使用下面的。因为在下面少循环一次，1肯定是任何整数的因数\n\t    return [i for i in range(2,n/2+1) if n%i == 0]\n\t\n\t#找出某个数n以内的所有完全数，即在[1,n]内(含n)\n\tdef perfect(n):\n\t    #从上面的factors中得到的因数列表中，少1,因此在求因数和的时候，要把1加上。\n\t    return [i for i in range(2,n+1) if (sum(factors(i))+1)==i]\n\t\n\tif __name__==\"__main__\":\n\t    print perfect(30)\n\t\n"
        },
        {
          "name": "perfect_number.py",
          "type": "blob",
          "size": 0.6806640625,
          "content": "#!/usr/bin/env python\n#coding:utf-8\n\n\"\"\"\n找出完全数\n\"\"\"\n\n#找出一个数的因数\ndef factors(n):\n    #return [i for i in range(1,n/2+1) if n%i == 0]\n    #如果仅仅是为了得到因数，可以用上面的\n    #如果是配合下面完全数，最好使用下面的。因为在下面少循环一次，1肯定是任何整数的因数\n    return [i for i in range(2,n/2+1) if n%i == 0]\n\n#找出某个数n以内的所有完全数，即在[1,n]内(含n)\ndef perfect(n):\n    #从上面的factors中得到的因数列表中，少1,因此在求因数和的时候，要把1加上。\n    return [i for i in range(2,n+1) if (sum(factors(i))+1)==i]\n\nif __name__==\"__main__\":\n    print perfect(30)\n\n"
        },
        {
          "name": "pics",
          "type": "tree",
          "content": null
        },
        {
          "name": "prim_algorithm.md",
          "type": "blob",
          "size": 5.080078125,
          "content": "#问题\n\n无向图最小生成树的Prim算法\n\n#思路说明\n\n假设点A,B,C,D,E,F，两点之间有连线的，以及它们的距离分别是：(A-B:7);(A-D:5);(B-C:8);(B-D:9);(B-E:7);(C-E:5);(D-E:15);(D-F:6);(E-F:8);(E-G:9);(F-G:11)\n\n关于Prim算法的计算过程，参与维基百科的词条：[普里姆算法](http://zh.wikipedia.org/wiki/%E6%99%AE%E6%9E%97%E5%A7%86%E7%AE%97%E6%B3%95)\n\n将上述点与点关系以及两点之间距离（边长，有的文献中称之为权重）写成矩阵形式（在list中，每两个点及其之间的距离组成一个tuple)\n\nedges = [ (\"A\", \"B\", 7), \n          (\"A\", \"D\", 5),\n          (\"B\", \"C\", 8), \n          (\"B\", \"D\", 9), \n          (\"B\", \"E\", 7), \n          (\"C\", \"E\", 5),\n          (\"D\", \"E\", 15), \n          (\"D\", \"F\", 6),\n          (\"E\", \"F\", 8), \n          (\"E\", \"G\", 9),\n          (\"F\", \"G\", 11)\n        ]\n\n在下面的解决方法中，要计算出与已经选出的若干个点有相邻关系的点中，相应边长最短的点。这本质上是排序之后取出最小的，因为这种排序是动态的，如果用sorted或者list.sort()之类的方法对list排序，一则速度慢（python中的sort方法对大数据时不是很快),二则代码也长了。幸好python提供了一个非常好用的模块：heapq。这个模块是堆排序方法实现排序，并能够随时取出最小值。简化代码，更重要是提升了速度。\n\n就用这个来解决Prim算法问题了。\n\n#解决（Python）\n\t\n\t#! /usr/bin/env python\n\t#coding:utf-8\n\t\n\tfrom collections import defaultdict\n\tfrom heapq import *\n\t\n\tdef prim( vertexs, edges ):\n\t    adjacent_vertex = defaultdict(list)      \n        \n        \"\"\"\n        注意：defaultdict(list)必须以list做为变量，可以详细阅读：[collections.defaultdict](https://docs.python.org/2/library/collections.html#collections.defaultdict)\n\t    \"\"\"\n\t    for v1,v2,length in edges:\n            adjacent_vertex[v1].append((length, v1, v2))\n            adjacent_vertex[v2].append((length, v2, v1))\n\n        \"\"\"\n\t    经过上述操作，将edges列表中各项归类成以某点为dictionary的key，其value则是其相邻的点以及边长。如下：\n\t\n\t    defaultdict(<type 'list'>, {'A': [(7, 'A', 'B'), (5, 'A', 'D')], \n                                    'C': [(8, 'C', 'B'), (5, 'C', 'E')], \n                                    'B': [(7, 'B', 'A'), (8, 'B', 'C'), (9, 'B', 'D'), (7, 'B', 'E')], \n                                    'E': [(7, 'E', 'B'), (5, 'E', 'C'), (15, 'E', 'D'), (8, 'E', 'F'), (9, 'E', 'G')], \n                                    'D': [(5, 'D', 'A'), (9, 'D', 'B'), (15, 'D', 'E'), (6, 'D', 'F')], \n                                    'G': [(9, 'G', 'E'), (11, 'G', 'F')], \n                                    'F': [(6, 'F', 'D'), (8, 'F', 'E'), (11, 'F', 'G')]})\n\t\n\t    \"\"\"\n\t\n\t    mst = []        #存储最小生成树结果\n\t\n\t    chosed = set(vertexs[0]) \n\t\n\t    \"\"\"\n\t    vertexs是顶点列表，vertexs = list(\"ABCDEFG\")===>vertexs=['A', 'B', 'C', 'D', 'E', 'F', 'G']\n\t    >> chosed=set(vertexs[0])\n\t    >> chosed\n\t    set(['A'])\n\t    也就是，首先选一个点（这个点是可以任意选的），以这个点为起点，找其相邻点，以及最短边长。\n\t\n\t    \"\"\"\n\n        #得到adjacent_vertexs_edges中顶点是'A'（nodes[0]='A')的相邻点list，即adjacent_vertexs['A']=[(7,'A','B'),(5,'A','D')]\n\t\n\t    adjacent_vertexs_edges = adjacent_vertex[vertexs[0]]  \n\t    \n        #将usable_edges加入到堆中，并能够实现用heappop从其中动态取出最小值。关于heapq模块功能，参考python官方文档\n\n\t    heapify(adjacent_vertexs_edges)\n\t\n\t    while adjacent_vertexs_edges:\n            #得到某个定点（做为adjacent_vertexs_edges的键）与相邻点距离（相邻点和边长/距离做为该键的值）最小值，并同时从堆中清除。\n\t        w, v1, v2 = heappop(adjacent_vertexs_edges)     \n\t        if v2 not in chosed:\n\n                #在used中有第一选定的点'A'，上面得到了距离A点最近的点'D',举例是5。将'd'追加到used中\n\t            chosed.add(v2)                          \n\n\t            mst.append((v1,v2,w))          #将v1,v2,w，第一次循环就是('A','D',5) append into mst\n\t            \n                #再找与d相邻的点，如果没有在heap中，则应用heappush压入堆内，以加入排序行列 \n\n                for next_vertex in adjacent_vertex[v2]:                    \n\t                if next_vertex[2] not in chosed:\n\t                    heappush( adjacent_vertexs_edges,next_vertex)\n\t    return mst\n\t\n\t\n\t#test\n\tvertexs = list(\"ABCDEFG\")\n\tedges = [ (\"A\", \"B\", 7), (\"A\", \"D\", 5),\n\t          (\"B\", \"C\", 8), (\"B\", \"D\", 9), \n\t          (\"B\", \"E\", 7), (\"C\", \"E\", 5),\n\t          (\"D\", \"E\", 15), (\"D\", \"F\", 6),\n\t          (\"E\", \"F\", 8), (\"E\", \"G\", 9),\n\t          (\"F\", \"G\", 11)]\n\t\n\tprint \"edges:\",edges\n\tprint \"prim:\", prim( vertexs, edges )\n\n##运行结果\n\nedges: [('A', 'B', 7), ('A', 'D', 5), ('B', 'C', 8), ('B', 'D', 9), ('B', 'E', 7), ('C', 'E', 5), ('D', 'E', 15), ('D', 'F', 6), ('E', 'F', 8), ('E', 'G', 9), ('F', 'G', 11)]\n\nprim: [('A', 'D', 5), ('D', 'F', 6), ('A', 'B', 7), ('B', 'E', 7), ('E', 'C', 5), ('E', 'G', 9)]\n\n\n"
        },
        {
          "name": "prim_algorithm.py",
          "type": "blob",
          "size": 1.1376953125,
          "content": "#! /usr/bin/env python\n#coding:utf-8\n\n\nfrom collections import defaultdict\nfrom heapq import *\n\n\ndef prim( vertexs, edges ):\n    adjacent_vertex = defaultdict(list)\n    for v1,v2,length in edges:\n        adjacent_vertex[v1].append((length, v1, v2))\n        adjacent_vertex[v2].append((length, v2, v1))\n\n    mst = []\n    chosed = set(vertexs[0]) \n\n    adjacent_vertexs_edges = adjacent_vertex[vertexs[0]]  \n    \n    heapify(adjacent_vertexs_edges)\n\n    while adjacent_vertexs_edges:\n        w, v1, v2 = heappop(adjacent_vertexs_edges) \n        if v2 not in chosed:\n            chosed.add(v2)                    \n            mst.append((v1,v2,w))   \n            for next_vertex in adjacent_vertex[v2]:            \n                if next_vertex[2] not in chosed:\n                    heappush( adjacent_vertexs_edges,next_vertex)\n\n    return mst\n\n\n#test\nvertexs = list(\"ABCDEFG\")\nedges = [ (\"A\", \"B\", 7), (\"A\", \"D\", 5),\n          (\"B\", \"C\", 8), (\"B\", \"D\", 9), \n          (\"B\", \"E\", 7), (\"C\", \"E\", 5),\n          (\"D\", \"E\", 15), (\"D\", \"F\", 6),\n          (\"E\", \"F\", 8), (\"E\", \"G\", 9),\n          (\"F\", \"G\", 11)]\n\nprint \"edges:\",edges\nprint \"prim:\", prim( vertexs, edges )\n"
        },
        {
          "name": "python_sort.md",
          "type": "blob",
          "size": 5.9296875,
          "content": "#python的排序详解\n\n排序，在编程中经常遇到的算法，我也在几篇文章中介绍了一些关于排序的算法。有的高级语言内置了一些排序函数。本文讲述Python在这方面的工作。供使用python的程序员们参考，也让没有使用python的朋友了解python。领略一番“生命有限，请用Python”的含义。\n\n##内置函数sorted()/list.sort()的使用\n\n###简单应用\n\npython对list有一个内置函数：sorted(),专门用于排序。举例：\n\n\t>>> a=[5,3,6,1,9,2]\n\t>>> sorted(a)       #a经过sorted之后，得到一个排序结果\n\t[1, 2, 3, 5, 6, 9]  #但是，原有的a并没有受到影响\n\t>>> a\n\t[5, 3, 6, 1, 9, 2]\n\n也可以使用list.sort()来进行上述操作。\n\n    >>> a.sort()\n    >>> a               #注意这里，经过list.sort()之后，原有\n    [1, 2, 3, 5, 6, 9]  #a的顺序已经发生变化，与上述不同之处。\n\n**sorted和list.sort()的区别:**list.sort()只能对list类型进行排序。如下：\n\n    >>> b_dict={1:'e',3:'m',9:'a',5:'e'}\n    >>> b_dict.sort()\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>\n      AttributeError: 'dict' object has no attribute 'sort'\n\n而sorted则不然，看例子：\n\n    >>> b_dict\n    {1: 'e', 3: 'm', 5: 'e', 9: 'a'}\n    >>> sorted(b_dict)\n    [1, 3, 5, 9]\n\nsorted之后，上述对dictinoary中，将key值取出并排序，返回list类型的排序结果。\n\n###按照指定关键词排序\n\n在list.sort()和sorted中，都可以根据指定的key值排序。例如：\n\nsorted的例子：\n\n    >>> qw=\"I am Qiwsir you can read my articles im my blog\".split()\n    >>> qw\n    ['I', 'am', 'Qiwsir', 'you', 'can', 'read', 'my', 'articles', 'im', 'my', 'blog']\n    >>> sorted(qw,key=str.lower)        #按照字母升序排列\n    ['am', 'articles', 'blog', 'can', 'I', 'im', 'my', 'my', 'Qiwsir', 'read', 'you']\n\nlist.sort()的例子：\n    \n    >>> qw  \n    ['I', 'am', 'Qiwsir', 'you', 'can', 'read', 'my', 'articles', 'im', 'my', 'blog']\n    >>> qw.sort(key=str.lower)\n    >>> qw\n    ['am', 'articles', 'blog', 'can', 'I', 'im', 'my', 'my', 'Qiwsir', 'read', 'you']\n\n此外，key还可以接收函数的单一返回值，按照该值排序。例如：\n\n    >>> name_mark_age = [('zhangsan','A',15),('LISI','B',14),('WANGWU','A',16)]\n    >>> sorted(name_mark_age, key = lambda x: x[2])     #根据年龄排序\n    [('LISI', 'B', 14), ('zhangsan', 'A', 15), ('WANGWU', 'A', 16)]\n\n    >>> sorted(name_mark_age, key = lambda x: x[1])     #根据等级排序\n    [('zhangsan', 'A', 15), ('WANGWU', 'A', 16), ('LISI', 'B', 14)]\n    \n    >>> sorted(name_mark_age, key = lambda x: x[0])     #根据姓名排序\n    [('LISI', 'B', 14), ('WANGWU', 'A', 16), ('zhangsan', 'A', 15)]\n\n除了上述方式，python中还提供了一个选择循环选择指定元组值的模块\n\n    >>> from operator import itemgetter    #官方文档：https://docs.python.org/2/library/operator.html#module-operator\n\t>>> name_mark_age.append(('zhaoliu','B',16))\n\t>>> name_mark_age\n\t[('zhangsan', 'A', 15), ('LISI', 'B', 14), ('WANGWU', 'A', 16), ('zhaoliu', 'B', 16)]\n\t\n    >>> sorted(name_mark_age,key=itemgetter(2))     #按照年龄排序\n\t[('LISI', 'B', 14), ('zhangsan', 'A', 15), ('WANGWU', 'A', 16), ('zhaoliu', 'B', 16)]\n\n\t>>> sorted(name_mark_age,key=itemgetter(1,2))   #先按照等级排序，相同等级看年龄\n\t[('zhangsan', 'A', 15), ('WANGWU', 'A', 16), ('LISI', 'B', 14), ('zhaoliu', 'B', 16)]\n\n\n在官方文档上，有这样一个例子，和上面的操作是完全一样的。\n\n    >>> class Student:\n            def __init__(self, name, grade, age):\n                self.name = name\n                self.grade = grade\n                self.age = age\n            \n            def __repr__(self):\n                return repr((self.name, self.grade, self.age))\n            \n    >>> student_objects = [\n            Student('john', 'A', 15),       #注意这里，用class Student来生成列表内的值\n            Student('jane', 'B', 12),       #因此，可以通过student_objects[i].age来访问某个名称的年龄,i=0,则是john的年龄\n            Student('dave', 'B', 10),\n            ]\n            \n    >>> sorted(student_objects, key=lambda student: student.age)\n    [('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]\n\n也可以引用operator模块来实现上述排序\n    \n    >>>from operator import attrgetter\n    >>> sorted(student_objects, key=attrgetter('age'))\n    [('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]\n    >>> sorted(student_objects, key=attrgetter('grade', 'age'))\n    [('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]\n\n**总结：**sorted的能力超强，不仅实现排序，还能按照指定关键词排序。\n\n以上例子都是升序，如果，增加reverse=True。例如：\n\n    >>>from operator import itemgetter \n    >>> name_mark_age\n    [('zhangsan', 'A', 15), ('LISI', 'B', 14), ('WANGWU', 'A', 16), ('zhaoliu', 'B', 16)]\n    >>> sorted(name_mark_age, key=itemgetter(2),reverse=True)\n    [('WANGWU', 'A', 16), ('zhaoliu', 'B', 16), ('zhangsan', 'A', 15), ('LISI', 'B', 14)]\n\n##sorted的算法\n\npython中的sorted算法，网上有人撰文，说比较低级。其实不然，通过阅读官方文档，发现python中的sorted排序，真的是高大上，用的Timsort算法。什么是Timsort，请看 wiki的解释：http://en.wikipedia.org/wiki/Timsort，另外，国内有一个文档，适当翻译：http://blog.csdn.net/yangzhongblog/article/details/8184707，这里截取一个不同排序算法比较的图示，就明白sorted的威力了。\n\n从时间复杂度来看，Timsort是威武的。\n\n![](./pics/timsort1.png)\n\n从空间复杂度来讲，需要的开销在数量大的时候会增大。\n\n![](./pics/timsort2.png)\n\n综上，可以看出，就一般情况，使用sorted足以能够完成排序的要求，并且是稳定的。\n\n当然，python中也有其它一些排序模块，都可以直接拿过来使用。\n\n本文作者在博客和github上都有多种关于python排序方法和模块的文章说明。\n"
        },
        {
          "name": "quick_sort.md",
          "type": "blob",
          "size": 3.79296875,
          "content": "# 问题\n\n快速排序，这是一个经典的算法，本文给出几种python的写法，供参考。\n\n特别是python能用一句话实现快速排序。\n\n# 思路说明\n\n快速排序是C.R.A.Hoare于1962年提出的一种划分交换排序。它采用了一种分治的策略，通常称其为分治法(Divide-and-ConquerMethod)。\n\n（1） 分治法的基本思想\n\n分治法的基本思想是：将原问题分解为若干个规模更小但结构与原问题相似的子问题。递归地解这些子问题，然后将这些子问题的解组合为原问题的解。\n\n（2）快速排序的基本思想\n\n设当前待排序的无序区为R[low..high]，利用分治法可将快速排序的基本思想描述为：\n\n### 分解：\n\n在R[low..high]中任选一个记录作为基准(Pivot)，以此基准将当前无序区划分为左、右两个较小的子区间R[low..pivotpos-1)和R[pivotpos+1..high]，并使左边子区间中所有记录的关键字均小于等于基准记录(不妨记为pivot)的关键字pivot.key，右边的子区间中所有记录的关键字均大于等于pivot.key，而基准记录pivot则位于正确的位置(pivotpos)上，它无须参加后续的排序。\n\n注意：\n\n划分的关键是要求出基准记录所在的位置pivotpos。划分的结果可以简单地表示为(注意pivot=R[pivotpos])：\n\nR[low..pivotpos-1].keys≤R[pivotpos].key≤R[pivotpos+1..high].keys\n\n其中low≤pivotpos≤high。\n\n### 求解：\n\n通过递归调用快速排序对左、右子区间R[low..pivotpos-1]和R[pivotpos+1..high]快速排序。\n\n### 组合：\n\n因为当\"求解\"步骤中的两个递归调用结束时，其左、右两个子区间已有序。对快速排序而言，\"组合\"步骤无须做什么，可看作是空操作。\n\n### 解决(Python)\n\t\n```python\n\t#!/usr/bin/env python\n\t#coding:utf-8\n\t\n\t#方法1\n\t\n\tdef quickSort(arr):\n\t    less = []\n\t    pivotList = []\n\t    more = []\n\t    if len(arr) <= 1:\n\t        return arr\n\t    else:\n\t        pivot = arr[0]      #将第一个值做为基准\n\t        for i in arr:\n\t            if i < pivot:\n\t                less.append(i)\n\t            elif i > pivot:\n\t                more.append(i)\n\t            else:\n\t                pivotList.append(i)\n\t\n\t        less = quickSort(less)      #得到第一轮分组之后，继续将分组进行下去。\n\t        more = quickSort(more)\n\t\n\t        return less + pivotList + more\n\t\n\t# 方法2\n\t# 分为<, >, = 三种情况，如果分为两种情况的话函数调用次数会增加许多，以后几个好像都有相似的问题\n\t# 如果测试1000个100以内的整数，如果分为<, >=两种情况共调用函数1801次，分为<, >, = 三种情况，共调用函数201次\n\tdef qsort(L):\n\t    return (qsort([y for y in L[1:] if y <  L[0]]) + L[:1] + [y for y in L[1:] if y == L[0] + qsort([y for y in L[1:] if y > L[0]])) if len(L) > 1 else L\n\t\n\t#方法3\n\t#基本思想同上，只是写法上又有所变化\n\t\n\tdef qsort(list):\n\t    if not list:\n\t        return []\n\t    else:\n\t        pivot = list[0]\n\t        less = [x for x in list     if x <  pivot]\n\t        more = [x for x in list[1:] if x >= pivot]\n\t        return qsort(less) + [pivot] + qsort(more)\n\t\n\t#方法4\n\t\n\tfrom random import *\n\t\n\tdef qSort(a):\n\t    if len(a) <= 1:\n\t        return a\n\t    else:\n\t        q = choice(a)       #基准的选择不同于前，是从数组中任意选择一个值做为基准\n\t        return qSort([elem for elem in a if elem < q]) + [q] * a.count(q) + qSort([elem for elem in a if elem > q])\n\t\n\t\n\t#方法5\n\t#这个最狠了，一句话搞定快速排序，瞠目结舌吧。\n\t\n\tqs = lambda xs : ( (len(xs) <= 1 and [xs]) or [ qs( [x for x in xs[1:] if x < xs[0]] ) + [xs[0]] + qs( [x for x in xs[1:] if x >= xs[0]] ) ] )[0]\n\t\n\t\n\tif __name__==\"__main__\":\n\t    a = [4, 65, 2, -31, 0, 99, 83, 782, 1]\n\t    print quickSort(a)\n\t    print qSort(a)\n\t\n\t    print qs(a)\n```\n"
        },
        {
          "name": "quick_sort.py",
          "type": "blob",
          "size": 3.30078125,
          "content": "#!/usr/bin/env python\n#coding:utf-8\n\"\"\"\n问题：快速排序\n\n快速排序是C.R.A.Hoare于1962年提出的一种划分交换排序。它采用了一种分治的策略，通常称其为分治法(Divide-and-ConquerMethod)。\n\n（1） 分治法的基本思想\n\n分治法的基本思想是：将原问题分解为若干个规模更小但结构与原问题相似的子问题。递归地解这些子问题，然后将这些子问题的解组合为原问题的解。\n\n（2）快速排序的基本思想\n\n设当前待排序的无序区为R[low..high]，利用分治法可将快速排序的基本思想描述为：\n\n①分解：\n\n在R[low..high]中任选一个记录作为基准(Pivot)，以此基准将当前无序区划分为左、右两个较小的子区间R[low..pivotpos-1)和R[pivotpos+1..high]，并使左边子区间中所有记录的关键字均小于等于基准记录(不妨记为pivot)的关键字pivot.key，右边的子区间中所有记录的关键字均大于等于pivot.key，而基准记录pivot则位于正确的位置(pivotpos)上，它无须参加后续的排序。\n\n注意：\n\n划分的关键是要求出基准记录所在的位置pivotpos。划分的结果可以简单地表示为(注意pivot=R[pivotpos])：\n\nR[low..pivotpos-1].keys≤R[pivotpos].key≤R[pivotpos+1..high].keys\n\n其中low≤pivotpos≤high。\n\n②求解：\n\n通过递归调用快速排序对左、右子区间R[low..pivotpos-1]和R[pivotpos+1..high]快速排序。\n\n③组合：\n\n因为当\"求解\"步骤中的两个递归调用结束时，其左、右两个子区间已有序。对快速排序而言，\"组合\"步骤无须做什么，可看作是空操作。\n\"\"\"\n\n#方法1\n\ndef quickSort(arr):\n    less = []\n    pivotList = []\n    more = []\n    if len(arr) <= 1:\n        return arr\n    else:\n        pivot = arr[0]      #将第一个值做为基准\n        for i in arr:\n            if i < pivot:\n                less.append(i)\n            elif i > pivot:\n                more.append(i)\n            else:\n                pivotList.append(i)\n\n        less = quickSort(less)      #得到第一轮分组之后，继续将分组进行下去。\n        more = quickSort(more)\n\n        return less + pivotList + more\n\n\"\"\"\n#方法2\n#将方法1写的更紧凑，彰显python特点\n\ndef qsort(L):\n    return (qsort([y for y in L[1:] if y <  L[0]]) + L[:1] + qsort([y for y in L[1:] if y >= L[0]])) if len(L) > 1 else L\n\"\"\"\n\n\"\"\"\n#方法3\n#基本思想同上，只是写法上又有所变化\n\ndef qsort(list):\n    if not list:\n        return []\n    else:\n        pivot = list[0]\n        less = [x for x in list[1:] if x <  pivot]\n        more = [x for x in list[1:] if x >= pivot]\n        return qsort(less) + [pivot] + qsort(more)\n\"\"\"\n\n#方法4\nfrom random import *\n\ndef qSort(a):\n    if len(a) <= 1:\n        return a\n    else:\n        q = choice(a)       #基准的选择不同于前，是从数组中任意选择一个值做为基准\n        return qSort([elem for elem in a if elem < q]) + [q] * a.count(q) + qSort([elem for elem in a if elem > q])\n\n\n#方法5\n#这个最狠了，一句话搞定快速排序，瞠目结舌吧。\n\nqs = lambda xs : ( (len(xs) <= 1 and [xs]) or [ qs( [x for x in xs[1:] if x < xs[0]] ) + [xs[0]] + qs( [x for x in xs[1:] if x >= xs[0]] ) ] )[0]\n\nif __name__==\"__main__\":\n    a = [4, 65, 2, -31, 0, 99, 83, 782, 1]\n    print quickSort(a)\n    print qSort(a)\n\n    print qs(a)\n"
        },
        {
          "name": "random_list.md",
          "type": "blob",
          "size": 2.2548828125,
          "content": "#问题\n\n要求定义一个int型数组a,包含100个元素,保存100个随机的4位数。再定义一个int型数组b，包含10个元素。统计a数组中的元素对10求余等于0的个数，保存到b[0]中；对10求余等于1的个数，保存到b[1]中，……依此类推。\n\n#解决（python）\n\n    #!/usr/bin/env python\n    #coding:utf-8\n\n    import random\n    if __name__==\"__main__\":\n        a = [random.randint(1000,9999) for i in range(101)]\n        a_remainder = [i%10 for i in a]\n        b = [a_remainder.count(i) for i in range(10)]\n        print a\n        print a_remainder\n        print b\n\n#解决 (racket 5.2.1)\n\n```racket\n#lang racket\n\n; 定义函数 equal-to-k\n; 它接受一个整数输入 k\n; 它输出一个只返回 true/false 的匿名函数\n; 当 k = 1 时, equal-to-k 的功能可以这样理解\n; (equal-to-k 1) => true\n; (equal-to-k 2) => false\n(define (filter-by-k k) \n  (lambda (n) (if (= k n) true false)))\n\n; 定义函数 random-list-100-remainder-stats\n; 它不接受任何输入\n; 它输出一个整数型列表 b, 其每个元素的定义如下\n; > 给定一个整数型列表 a,包含 100 个元素,保存 100 个随机的 4 位数。\n; > 整数型列表 b，包含 10 个元素。\n; > 统计a列表中的元素对10求余等于0的个数，保存到b[0]中；\n; > 对10求余等于1的个数，保存到b[1]中，……依此类推。\n(define (random-list-100-remainder-stats)\n  (let*\n      ([rand-e4 (lambda () (+ 1000 (random 9000)))]     ; 定义 1000~9999 之间的随机数\"生成器\"\n       [rand-list-100 (for/list ([i 100]) (rand-e4))]   ; 生成长度为 100 的列表, 其中每个元素都是 1000~9999 之间的随机数\n       [get-remainder-by-10 (lambda (n) (modulo n 10))] ; 定义对某整数除以 10 取余数的\"生成器\"\n       [remainder-list-100 (map get-remainder-by-10 rand-list-100)] ; 对前面长为 100 的列表批量除以 10 取余数\n       ; 最后, 对余数做统计, 生成 b 列表\n       [remainder-list-stats (for/list ([k (in-range 0 10)]) (count (filter-by-k k) remainder-list-100))])\n    ; 把生成的 b 列表输出出来\n    remainder-list-stats))\n\n; 函数调用, 正常执行时, 应输出一个整数的列表\n; 此列表的展现形式类似于 '(7 11 13 10 5 11 6 11 12 14)\n(random-list-100-remainder-stats)\n```\n"
        },
        {
          "name": "random_list.py",
          "type": "blob",
          "size": 0.548828125,
          "content": "#!/usr/bin/env python\n#coding:utf-8\n\n\"\"\"\n问题\n要求定义一个int型数组a,包含100个元素,保存100个随机的4位数。再定义一个\nint型数组b，包含10个元素。统计a数组中的元素对10求余等于0的个数，保存\n到b[0]中；对10求余等于1的个数，保存到b[1]中，……依此类推。\n\"\"\"\n\nimport random\nif __name__==\"__main__\":\n    a = [random.randint(1000,9999) for i in range(101)]\n    a_remainder = [i%10 for i in a]\n    b = [a_remainder.count(i) for i in range(10)]\n    print a\n    print a_remainder\n    print b\n\n\n"
        },
        {
          "name": "same_element_in_list.md",
          "type": "blob",
          "size": 1.623046875,
          "content": "#问题\n\n统计一个一维数组中的各个元素的个数，然后删除多出来的重复元素，并输出结果。\n\n例如：[1,2,2,2,3,3,3,3,3]-->[1,2,3]\n\n#解决思路\n\n将重复元素的列表中的重复元素进行统计，并将统计结果放在dictionary中，key为元素，value为该元素的个数\n\n**更新此步方法：**上述步骤的功能，能够通过另外一个方法实现，即collections.Counter()\n\n然后通过for获取key，得到一个新的列表，就是没有重复元素的列表\n\n\n\n#解决（Python）\n\n\t#!/usr/bin/env python\n\t#coding:utf-8\n\t\n\t\n\tdef count_element(one_list):\n\t    element_number = {}\n\t    for e in one_list:\n\t        number = one_list.count(e)      #数出某个元素的个数\n\t        element_number[e] = number     #生成类似：{1:1,2:3,3:5}的结果，key-element,value-元素的个数\n\t    return element_number\n\n    #应用collections.Counter()实现count_element(one_list)函数功能，为了便于调试和说明，在另外一个函数里面使用\n    \n    from collections import Counter\n\n    def count_element2(one_list):\n        return Counter(one_list)\n\n\t\n\tdef no_repeat_element(element_number):      #element_number是count_element(one_list)的返回值\n\t    no_repeat_list = [key for key in element_number]\n\t    return no_repeat_list\n\t\n\tif __name__==\"__main__\":\n\t\n\t    ls = [\"a\",\"a\",\"b\",\"b\",'b','c','c']\n\t    el_num=count_element(ls)\n\t    print el_num\n\t    no_repeat = no_repeat_element(el_num)\n\t    print no_repeat\n\n#解决（python）\n\n无重复元素个数统计，只有新数组输出\n\n    list_a = [1,1,2,2,2,3,3,3,3,3,]\n    list_b = list(set(list_a))\n\n##qiwsir#gmail.com (# to @)\n"
        },
        {
          "name": "same_element_in_list.py",
          "type": "blob",
          "size": 1.4580078125,
          "content": "#!/usr/bin/env python\n#coding:utf-8\n\n\"\"\"\n统计一个一维数组中的各个元素的个数，然后删除多出来的重复元素，并输出结果。\n例如：[1,2,2,2,3,3,3,3,3]-->[1,2,3]\n\"\"\"\n\ndef count_element(one_list):\n    element_number = {}\n    for e in one_list:\n        number = one_list.count(e)      #数出某个元素的个数\n        element_number[e] = number     #生成类似：{1:1,2:3,3:5}的结果，key-element,value-元素的个数\n    return element_number\n\n#函数count_element(one_list)的功能，可以用collections模块中的Counter完成\n\nfrom collections import Counter\n\ndef count_element2(one_list):\n    return Counter(one_list)\n\ndef no_repeat_element(element_number):      #element_number是count_element(one_list)的返回值\n    no_repeat_list = [key for key in element_number]\n    return no_repeat_list\n\n\"\"\"\n另外一种删除重复元素方法\n\nlist_a = [1,1,2,2,2,3,3,3,3,3,]\nlist_b = list(set(list_a))\n\n\"\"\"\n\n\nif __name__==\"__main__\":\n\n    ls = [\"a\",\"a\",\"b\",\"b\",'b','c','c']\n    el_num=count_element(ls)\n    print el_num\n    no_repeat = no_repeat_element(el_num)\n    print no_repeat\n    print \"another way is:\"\n    no_repeat2 = list(set(ls))\n    print no_repeat2\n    print \"-------\"\n    el_num2=count_element2(ls)\n    print el_num2\n    no_repeat = no_repeat_element(el_num)\n    print no_repeat\n\n\"\"\"\nthe result is :\n\n{'a': 2, 'c': 2, 'b': 3}\n['a', 'c', 'b']\nanother way is:\n['a', 'c', 'b']\n-------\nCounter({'b': 3, 'a': 2, 'c': 2})\n['a', 'c', 'b']\n\n\"\"\"\n"
        },
        {
          "name": "sort_chared.md",
          "type": "blob",
          "size": 2.8974609375,
          "content": "#问题\n\n已知字母序列【d, g, e, c, f, b, o, a】，请实现一个函数针对输入的一组字符串 input[] = {\"bed\", \"dog\", \"dear\", \"eye\"}，按照字母顺序排序并打印,结果应为：dear, dog, eye, bed。\n\n#说明\n\n本问题在网上比较常见，但这里尝试用另外一个思路，并且用python来写，与众多用c++的有所不同，且似乎短小了不少。自己感觉比网上参考到的更容易理解。\n\n欢迎指点。\n\n#解决(python)\n    #! /usr/bin/env python\n    #coding:utf-8\n\n    def char_to_number(by_list,char):    #根据排序依据字母顺序，给另外一个字母编号\n        try:\n            return by_list.index(char)\n        except:\n            return 1000\n\n    def sort_by_list(by_list,input_list):  \n\n        result={}\n        for word in input_list:\n            number_list = [char_to_number(by_list,word[i]) for i in range(len(word))]\n            \n            #得到形如：{\"good\":[2,3,3,1],\"book\":[1,3,3,0]}样式的结果\n            result[word] = number_list              \n    \n        #将得到的result生成[(key1,value1),(key2,value2),...]列表，按照value值排序，取出排序结果中的key即v[0]，生产列表。\n        return [v[0] for v in sorted(result.items(),lambda x,y:cmp(x[1],y[1]))]         \n\n    if __name__==\"__main__\":\n        word = [\"bed\",\"dog\",\"dear\",\"eye\"]\n        by_string = ['d','g','e','c','f','b','o','a']\n        print \"the word list is:\"\n        print word\n        print \"\\nwill sorted by:\"\n        print by_string\n        print \"\\nthe result is:\"\n        print sort_by_list(by_string,word)\n    \n# 解法 （racket 5.2.1)\n\n**对语言的掌握还不熟练，所以暂未考虑算法效率**\n\n```racket\n#lang racket\n\n; 定义一个函数 filter-by-1st-char\n; 输入一个字符 a-ch 和一个字符串 a-str\n; 如果 a-ch 与 a-str 的第一个字符相同，\n; 则以列表方式输出 a-str, 否则输出空列表 '() \n(define (filter-by-1st-char a-ch a-str)\n  (if (char=? a-ch (string-ref a-str 0))\n    (list a-word) '()))\n\n; 定义一个函数 sort-words-by-char-list\n; 它接受以字符串形式输入的一个字符序列 char-list, \n; 和以字符串列表形式输入的一个字符串序列 word-list\n; 输出一个列表，其所有列表项即 word-list 中的所有字符串\n; 并且将根据每个字符串的首字母，依照 char-list 所提供的顺序排序\n; 而并非按一般英文词典的 a-z 顺序排序\n(define (sort-words-by-char-list char-list word-list)\n  (let \n    ([sorted-word-list '()]) ; 定义一个空列表用于存储排序后的 word\n    (for ([ch char-list])\n      (for ([wd word-list])\n        (set! sorted-word-list \n          (append sorted-word-list ; 把符合条件的单词放进结果列表\n            (filter-by-1st-char ch wd)))))\n    sorted-word-list))\n\n; 函数调用，正常运行时，应该输出 (dear dog eye bed)\n(displayln\n  (sort-words-by-char-list \"dgecfboa\" '(\"dear\" \"dog\" \"eye\" \"bed\")))\n```\n"
        },
        {
          "name": "sort_chared.py",
          "type": "blob",
          "size": 0.9873046875,
          "content": "#! /usr/bin/env python\n#coding:utf-8\n\ndef char_to_number(by_list,char):    #根据排序依据字母顺序，给另外一个字母编号\n    try:\n        return by_list.index(char)\n    except:\n        return 1000\n\ndef sort_by_list(by_list,input_list):  \n\n    result={}\n    for word in input_list:\n        number_list = [char_to_number(by_list,word[i]) for i in range(len(word))]\n        \n        #得到形如：{\"good\":[2,3,3,1],\"book\":[1,3,3,0]}样式的结果\n        result[word] = number_list\n    \n    #将得到的result生成[(key1,value1),(key2,value2),...]列表，按照value值排序，取出排序结果中的key即v[0]，生产列表。\n    return [v[0] for v in sorted(result.items(),lambda x,y:cmp(x[1],y[1]))]\n\nif __name__==\"__main__\":\n    word = [\"bed\",\"dog\",\"dear\",\"eye\"]\n    by_string = ['d','g','e','c','f','b','o','a']\n    print \"the word list is:\"\n    print word\n    print \"\\nwill sorted by:\"\n    print by_string\n    print \"\\nthe result is:\"\n    print sort_by_list(by_string,word)\n    \n\n \n"
        },
        {
          "name": "string_to_hump.md",
          "type": "blob",
          "size": 1.732421875,
          "content": "#问题\n\n请写一个字符串转成驼峰的方法？\n\n例如：border-bottom-color -> borderBottomColor\n\n#解决\n\n##python解决方法：\n    def convert(one_string,space_character):    #one_string:输入的字符串；space_character:字符串的间隔符，以其做为分隔标志\n\n        string_list = str(one_string).split(space_character)    #将字符串转化为list\n        first = string_list[0].lower()\n        others = string_list[1:] \n\n        others_capital = [word.capitalize() for word in others]      #str.capitalize():将字符串的首字母转化为大写\n\n        others_capital[0:0] = [first]\n\n        hump_string = ''.join(others_capital)     #将list组合成为字符串，中间无连接符。\n\n        return hump_string\n\n    if __name__=='__main__':\n        print \"the string is:ab-cd-ef\"\n        print \"convert to hump:\"\n        print convert(\"ab-cd-ef\",\"-\")\n        \n\n##欢迎补充其它语言的解决方法\n\n###racket解决方法 (racket 5.2.1)\n\n```racket\n#lang racket\n\n; 定义字符串转换函数 train-to-camel\n(define (train-to-camel train-str separator-char)\n  (let\n    [(splited-str (regexp-split separator-char train-str))]      ; 把原始字符串用 '-' 分成多个单独的单词\n    (string-append\n      (first splited-str)\n      (apply\n        string-append\n        (map\n          string-titlecase\n          (rest splited-str))))))\n\n; 调用字符串转换函数 train-to-camel\n(train-to-camel \"this-is-a-var\" \"-\")  ; 正常运行的情况下, 应输出 \"thisIsAVar\"\n\n```\n\n--------------\n\n### Ruby 解决方法\n\n```ruby\nstr.split('-').map{|x| x.capitalize}.join\n```\n\n```ruby\nstr = 'border-bottom-color'\nstr.split('-').map{|x| x.capitalize}.join\n# => \"BorderBottomColor\"\n```\n\n###联系我：老齐 qiwsir#gmail.com (# to @)\n"
        },
        {
          "name": "string_to_hump.py",
          "type": "blob",
          "size": 0.7236328125,
          "content": "#! /usr/bin/env python\n#coding:utf-8\n\ndef convert(one_string,space_character):    #one_string:输入的字符串；space_character:字符串的间隔符，以其做为分隔标志\n\n    string_list = str(one_string).split(space_character)    #将字符串转化为list\n    first = string_list[0].lower()\n    others = string_list[1:] \n\n    others_capital = [word.capitalize() for word in others]      #str.capitalize():将字符串的首字母转化为大写\n\n    others_capital[0:0] = [first]\n\n    hump_string = ''.join(others_capital)     #将list组合成为字符串，中间无连接符。\n\n    return hump_string\n\nif __name__=='__main__':\n    print \"the string is:ab-cd-ef\"\n    print \"convert to hump:\"\n    print convert(\"ab-cd-ef\",\"-\")\n"
        },
        {
          "name": "sudoku.md",
          "type": "blob",
          "size": 1.89453125,
          "content": "#问题\n\n九宫格问题，要求：\n\n- 行列必须为相等的奇数\n- 每行数字之和、每列数字之和、两个对角线数字之和，都相等\n\n#思路说明\n\n按照下面的方式排列\n\n横向为x(从0到n-1)，纵向为y方向（从0到n-1)\n\n1、第一个数放在X方向的中间位置\n\n2、其它数顺次放置各个位置，并依据如下原则：（假设第一个数是a,第二个数是b）\n\n以a为中心的位置关系分别为：\n\n左上|上|右上\n\n左  |a |右\n\n左下|下|右下\n\n（1）b放在a的右上位置。a(x,y)-->b(x+1,y-1)\n\n（2）如果仅有“右”位置超过边界，即x+1>n，则b(1,y-1)\n\n（3）如果仅有“上”位置超过边界，即y-1<0，则b(x+1,n)\n\n（4）如果“右”“上”位置都超过边界，即x+1>n,y-1<o,则b(x,y+1)\n\n（5）如果“右上”已经有值，则b(x,y+1)\n\n#解决(Python)\n\n    #! /usr/bin/env python\n    #coding:utf-8\n\n    #判断输入的九宫格的格数是否为奇数(此处未使用，目的是对所输入的数进行判断)\n    def if_odd(n):\n        if n%2==1:\n            return True\n        else:\n            return False\n\n\t#九宫格填写数的法则\n\tdef sudoku_rule(n,sudoku):\n\t\n\t    tx = n/2\n\t    ty = 0\n\t    for i in range(n*n):\n\t        sudoku[ty][tx] = i+1\n\t        tx = tx+1\n\t        ty = ty-1\n\t        if ty<0 and tx>=n:      #条件（4）\n\t            tx = tx-1\n\t            ty = ty+2\n\t        elif ty<0:              #条件(3)\n\t            ty = n-1\n\t        elif tx>=n:             #条件(2)\n\t            tx = 0\n\t        elif sudoku[ty][tx]!=0: #条件(5)\n\t            tx = tx-1\n\t            ty = ty+2\n\t    return sudoku\n\t\n\tif __name__==\"__main__\":\n\t    n = 5 \n\t    sudoku = [[0 for i in range(n)] for i in range(n)]\n\t    s = sudoku_rule(n,sudoku)\n\t    for line in s:\n\t        print line\n\t        \n*说明：*最后打印的结果和输入的九宫格格数，都可以进一步修改。\n\n##qiwsir#gmail.com (# to @)        \n\n"
        },
        {
          "name": "sudoku.py",
          "type": "blob",
          "size": 1.45703125,
          "content": "#! /usr/bin/env python\n#coding:utf-8\n\n\n#判断输入的九宫格的格数是否为奇数\ndef if_odd(n):\n    if n%2==1:\n        return True\n    else:\n        return False\n\n#九宫格填写数的法则\n\"\"\"\n按照下面的方式排列\n-------------->x(从1到n)\n|\n|\n|y方向（从1到n)\n\n1、第一个数放在X方向的中间位置\n2、其它数顺次放置各个位置，并依据如下原则：（假设第一个数是a,第二个数是b）\n以a为中心的位置关系分别为：\n左上|上|右上\n左  |a |右\n左下|下|右下\n\n（1）b放在a的右上位置。a(x,y)-->b(x+1,y-1)\n（2）如果仅有“右”位置超过边界，即x+1>n，则b(1,y-1)\n（3）如果仅有“上”位置超过边界，即y-1<0，则b(x+1,n)\n（4）如果“右”“上”位置都超过边界，即x+1>n,y-1<o,则b(x,y+1)\n（5）如果“右上”已经有值，则b(x,y+1)\n\"\"\"\ndef sudoku_rule(n,sudoku):\n\n    tx = n/2\n    ty = 0\n    for i in range(n*n):\n        sudoku[ty][tx] = i+1\n        tx = tx+1\n        ty = ty-1\n        if ty<0 and tx>=n:      #条件（4）\n            tx = tx-1\n            ty = ty+2\n        elif ty<0:              #(3)\n            ty = n-1\n        elif tx>=n:             #(2)\n            tx = 0\n        elif sudoku[ty][tx]!=0: #(5)\n            tx = tx-1\n            ty = ty+2\n    return sudoku\n\nif __name__==\"__main__\":\n    n = 5 \n    sudoku = [[0 for i in range(n)] for i in range(n)]\n    s = sudoku_rule(n,sudoku)\n    for line in s:\n        print line\n        \n\n        \n\n"
        }
      ]
    }
  ]
}