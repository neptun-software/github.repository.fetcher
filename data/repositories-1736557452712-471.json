{
  "metadata": {
    "timestamp": 1736557452712,
    "page": 471,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQ5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "ziglang/zig",
      "stars": 36283,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.43,
          "content": "*.zig text eol=lf\n*.zon text eol=lf\n*.txt text eol=lf\nlangref.html.in text eol=lf\nlib/std/compress/testdata/** binary\nlib/std/compress/deflate/testdata/** binary\nlib/std/compress/flate/testdata/** binary\n\nlib/include/** linguist-vendored\nlib/libc/** linguist-vendored\nlib/libcxx/** linguist-vendored\nlib/libcxxabi/** linguist-vendored\nlib/libunwind/** linguist-vendored\nlib/tsan/** linguist-vendored\nlib/compiler/aro/** linguist-vendored\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.5,
          "content": "# This file is for zig-specific build artifacts.\n# If you have OS-specific or editor-specific files to ignore,\n# such as *.swp or .DS_Store, put those in your global\n# ~/.gitignore and put this in your ~/.gitconfig:\n#\n# [core]\n#     excludesfile = ~/.gitignore\n#\n# Cheers!\n# -andrewrk\n\n.zig-cache/\nzig-out/\n/release/\n/debug/\n/build/\n/build-*/\n/docgen_tmp/\n\n# Although this was renamed to .zig-cache, let's leave it here for a few\n# releases to make it less annoying to work with multiple branches.\nzig-cache/\n"
        },
        {
          "name": ".mailmap",
          "type": "blob",
          "size": 3.93,
          "content": "Adam Goertz <adambgoertz@gmail.com>\nAli Chraghi <alichraghi@proton.me> <alichraghi@pm.me>\nAndrea Orru <andrea@orru.io> <andreaorru1991@gmail.com>\nAndrew Kelley <andrew@ziglang.org> <superjoe30@gmail.com>\nBogdan Romanyuk <wrongnull@gmail.com> <65823030+wrongnull@users.noreply.github.com>\nCasey Banner <kcbanner@gmail.com>\nDavid Carlier <devnexen@gmail.com>\nDavid Rubin <daviru007@icloud.com> <87927264+Rexicon226@users.noreply.github.com>\nDominic <4678790+dweiller@users.noreply.github.com>\nDominic <4678790+dweiller@users.noreply.github.com> <4678790+dweiller@users.noreplay.github.com>\nEric Eastwood <madlittlemods@gmail.com> <contact@ericeastwood.com>\nFelix \"xq\" Queißner <xq@random-projects.net>\nFelix \"xq\" Queißner <xq@random-projects.net> <felix@ib-queissner.de>\nFelix \"xq\" Queißner <xq@random-projects.net> <git@masterq32.de>\nFelix \"xq\" Queißner <xq@random-projects.net> <git@mq32.de>\nFelix \"xq\" Queißner <xq@random-projects.net> <git@random-projects.net>\nFrank Denis <124872+jedisct1@users.noreply.github.com> <github@pureftpd.org>\nGarrett Beck <garrettlennoxbeck@gmail.com> <138411610+garrettlennoxbeck@users.noreply.github.com>\nGaëtan S <blaxoujunior@gmail.com>\nHydroH <iodizon@163.com> <ixlesis@gmail.com>\nIgor Anić <igor.anic@gmail.com>\nIntegratedQuantum <jahe788@gmail.com> <43880493+IntegratedQuantum@users.noreply.github.com>\nIsaac Freund <mail@isaacfreund.com> <ifreund@ifreund.xyz>\nIsaac Freund <mail@isaacfreund.com> <isaac.freund@coil.com>\nJacob Young <jacobly0@users.noreply.github.com>\nJan Philipp Hafer <jan.hafer@rwth-aachen.de> <anon_1plus1equals3@mailbox.org>\nJeremy Volkman <jeremy@jvolkman.com> <jeremy@cedarai.com>\nJimmi Holst Christensen <jhc@dismail.de> <jhc@dismail.de>\nJimmi Holst Christensen <jhc@dismail.de> <jhc@liab.dk>\nJimmi Holst Christensen <jhc@dismail.de> <jimmi@ziglang.org>\nJimmi Holst Christensen <jhc@dismail.de> <jimmiholstchristensen@gmail.com>\nJimmi Holst Christensen <jhc@dismail.de> <rainbowhejsil@gmail.com>\nJoachim Schmidt <joachim.schmidt557@outlook.com>\nJonathan Marler <johnnymarler@gmail.com> <jonathan.j.marler@hp.com>\nKrzysztof Wolicki <der.teufel.mail@gmail.com>\nKrzysztof Wolicki <der.teufel.mail@gmail.com> <46651553+der-teufel-programming@users.noreply.github.com>\nLemonBoy <thatlemon@gmail.com> <LemonBoy@users.noreply.github.com>\nLuuk de Gram <luuk@degram.dev> <Luukdegram@users.noreply.github.com>\nMarc Tiehuis <marc@tiehu.is> <marctiehuis@gmail.com>\nMatthew Lugg <mlugg@mlugg.co.uk>\nMeghan Denny <hello@nektro.net>\nMichael Bartnett <michael.bartnett@gmail.com> <michaelbartnett@users.noreply.github.com>\nMotiejus Jakštys <motiejus@jakstys.lt> <motiejus@uber.com>\nNiles Salter <Validark@pm.me>\nNoam Preil <noam@pixelhero.dev> <pleasantatk@gmail.com>\nPaul Berg <paul@plutojl.org>\nPaul Berg <paul@plutojl.org> <9824244+Pangoraw@users.noreply.github.com>\nPaul Berg <paul@plutojl.org> <paul.berg@univ-ubs.fr>\nPavel Verigo <paul.verigo@gmail.com> <58272683+pavelverigo@users.noreply.github.com>\nProkop Randáček <prokop@rdck.dev>\nTobias Simetsreiter <dasimmet@gmail.com>\nTobias Simetsreiter <dasimmet@gmail.com> <tobias.simetsreiter@meliot.de>\nTobias Simetsreiter <dasimmet@gmail.com> <tobias.simetsreiter@wabtec.com>\nTobias Simetsreiter <tobias.simetsreiter@wabtec.com> <dasimmet@gmail.com>\nTom Read Cutting <readcuttingt@gmail.com>\nTom Read Cutting <readcuttingt@gmail.com> <moosichu@users.noreply.github.com>\nTravis Staloch <twostepted@gmail.com>\nTravis Staloch <twostepted@gmail.com> <1562827+travisstaloch@users.noreply.github.com>\nVeikka Tuominen <git@vexu.eu>\nVeikka Tuominen <git@vexu.eu> <15308111+Vexu@users.noreply.github.com>\nWooster <r00ster91@proton.me>\nWooster <r00ster91@proton.me> <wooster0@proton.me>\nantlilja <liljaanton2001@gmail.com> <12533691+antlilja@users.noreply.github.com>\nfebruary cozzocrea <february.cozzocrea@gmail.com> <91439207+f-cozzocrea@users.noreply.github.com>\ngarrisonhh <garrisonhh@pm.me> <71951273+garrisonhh@users.noreply.github.com>\nxEgoist <egoist@egoistic.dev> <101279047+xEgoist@users.noreply.github.com>\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 30.96,
          "content": "cmake_minimum_required(VERSION 3.15)\n\nif(NOT CMAKE_BUILD_TYPE)\n    set(CMAKE_BUILD_TYPE \"Debug\" CACHE STRING\n        \"Choose the type of build, options are: None Debug Release RelWithDebInfo MinSizeRel.\" FORCE)\nendif()\n\nif(NOT CMAKE_INSTALL_PREFIX)\n    set(CMAKE_INSTALL_PREFIX \"${CMAKE_CURRENT_BINARY_DIR}/stage3\" CACHE PATH\n      \"Directory to install zig to\" FORCE)\nendif()\n\n# CMake recognizes the CMAKE_PREFIX_PATH environment variable for some things,\n# and also the CMAKE_PREFIX_PATH cache variable for other things. However, it\n# does not relate these two things, i.e. if the environment variable is set,\n# CMake does not populate the cache variable in a corresponding manner. Some\n# package systems, such as Homebrew, set the environment variable but not the\n# cache variable. Furthermore, the environment variable follows the system path\n# separator, such as ':' on POSIX and ';' on Windows, but the cache variable\n# follows CMake's array behavior, i.e. always ';' for a separator.\nlist(APPEND ZIG_CMAKE_PREFIX_PATH \"${CMAKE_PREFIX_PATH}\")\nif(WIN32)\n  list(APPEND ZIG_CMAKE_PREFIX_PATH $ENV{CMAKE_PREFIX_PATH})\nelse()\n  string(REGEX REPLACE \":\" \";\" ZIG_CMAKE_PREFIX_PATH_STRING \"$ENV{CMAKE_PREFIX_PATH}\")\n  list(APPEND ZIG_CMAKE_PREFIX_PATH \"${ZIG_CMAKE_PREFIX_PATH_STRING}\")\nendif()\n\nlist(PREPEND CMAKE_MODULE_PATH \"${CMAKE_CURRENT_SOURCE_DIR}/cmake\")\n\nproject(zig\n  DESCRIPTION\n    \"Zig is a general-purpose programming language and toolchain for maintaining robust, optimal and reusable software\"\n  HOMEPAGE_URL\n    \"https://ziglang.org\"\n  LANGUAGES\n    C CXX\n)\n\nset(ZIG_VERSION_MAJOR 0)\nset(ZIG_VERSION_MINOR 14)\nset(ZIG_VERSION_PATCH 0)\nset(ZIG_VERSION \"\" CACHE STRING \"Override Zig version string. Default is to find out with git.\")\n\nif(\"${ZIG_VERSION}\" STREQUAL \"\")\n    set(RESOLVED_ZIG_VERSION \"${ZIG_VERSION_MAJOR}.${ZIG_VERSION_MINOR}.${ZIG_VERSION_PATCH}\")\n    find_program(GIT_EXE NAMES git NAMES_PER_DIR)\n    if(GIT_EXE AND EXISTS \"${PROJECT_SOURCE_DIR}/.git\")\n        execute_process(\n            COMMAND ${GIT_EXE} -C \"${PROJECT_SOURCE_DIR}\" describe --match *.*.* --tags --abbrev=9\n            RESULT_VARIABLE EXIT_STATUS\n            OUTPUT_VARIABLE GIT_DESCRIBE\n            OUTPUT_STRIP_TRAILING_WHITESPACE\n            ERROR_QUIET)\n        if(EXIT_STATUS EQUAL \"0\")\n            set_property(DIRECTORY APPEND PROPERTY CMAKE_CONFIGURE_DEPENDS \"${PROJECT_SOURCE_DIR}/.git/HEAD\")\n            if(GIT_DESCRIBE MATCHES \"^v?([0-9]+\\\\.[0-9]+\\\\.[0-9]+)$\")\n                # Tagged release version.\n                set(GIT_TAG ${CMAKE_MATCH_1})\n                if(NOT GIT_TAG VERSION_EQUAL RESOLVED_ZIG_VERSION)\n                    message(SEND_ERROR \"Zig version (${RESOLVED_ZIG_VERSION}) does not match Git tag (${GIT_TAG}).\")\n                endif()\n            elseif(GIT_DESCRIBE MATCHES \"^v?([0-9]+\\\\.[0-9]+\\\\.[0-9]+)-([0-9]+)-g(.+)$\")\n                # Untagged pre-release. The Zig version is updated to include the number of commits\n                # since the last tagged version and the commit hash. The version is formatted in\n                # accordance with the https://semver.org specification.\n                set(GIT_TAG ${CMAKE_MATCH_1})\n                set(GIT_COMMITS_AFTER_TAG ${CMAKE_MATCH_2})\n                set(GIT_COMMIT ${CMAKE_MATCH_3})\n                if(NOT RESOLVED_ZIG_VERSION VERSION_GREATER GIT_TAG)\n                    message(SEND_ERROR \"Zig version (${RESOLVED_ZIG_VERSION}) must be greater than tagged ancestor (${GIT_TAG}).\")\n                endif()\n                set(RESOLVED_ZIG_VERSION \"${RESOLVED_ZIG_VERSION}-dev.${GIT_COMMITS_AFTER_TAG}+${GIT_COMMIT}\")\n            else()\n                message(WARNING \"Failed to parse version from output of `git describe`.\")\n            endif()\n        endif()\n    endif()\nelse()\n    set(RESOLVED_ZIG_VERSION \"${ZIG_VERSION}\")\nendif()\nmessage(STATUS \"Configuring zig version ${RESOLVED_ZIG_VERSION}\")\n\nset(ZIG_NO_LIB off CACHE BOOL\n    \"Disable copying lib/ files to install prefix during the build phase\")\n\nset(ZIG_STATIC off CACHE BOOL \"Attempt to build a static zig executable (not compatible with glibc)\")\nset(ZIG_SHARED_LLVM off CACHE BOOL \"Prefer linking against shared LLVM libraries\")\nset(ZIG_STATIC_LLVM ${ZIG_STATIC} CACHE BOOL \"Prefer linking against static LLVM libraries\")\nset(ZIG_STATIC_ZLIB ${ZIG_STATIC} CACHE BOOL \"Prefer linking against static zlib\")\nset(ZIG_STATIC_ZSTD ${ZIG_STATIC} CACHE BOOL \"Prefer linking against static zstd\")\nset(ZIG_STATIC_CURSES OFF CACHE BOOL \"Enable static linking against curses\")\n\nif (ZIG_SHARED_LLVM AND ZIG_STATIC_LLVM)\n    message(SEND_ERROR \"-DZIG_SHARED_LLVM and -DZIG_STATIC_LLVM cannot both be enabled simultaneously\")\nendif()\n\nset(ZIG_TARGET_TRIPLE \"native\" CACHE STRING \"arch-os-abi to output binaries for\")\nset(ZIG_TARGET_MCPU \"native\" CACHE STRING \"-mcpu parameter to output binaries for\")\nset(ZIG_TARGET_DYNAMIC_LINKER \"\" CACHE STRING\n  \"Override the dynamic linker used by the Zig binary. Default is to auto-detect the dynamic linker.\")\nset(ZIG_SINGLE_THREADED off CACHE BOOL \"limit the zig compiler to use only 1 thread\")\nset(ZIG_AR_WORKAROUND off CACHE BOOL \"append 'ar' subcommand to CMAKE_AR\")\n\nif(\"${ZIG_TARGET_TRIPLE}\" STREQUAL \"native\")\n    set(ZIG_USE_LLVM_CONFIG ON CACHE BOOL \"use llvm-config to find LLVM libraries\")\nelse()\n    set(ZIG_USE_LLVM_CONFIG OFF CACHE BOOL \"use llvm-config to find LLVM libraries\")\nendif()\n\nif(ZIG_AR_WORKAROUND)\n  string(REPLACE \"<CMAKE_AR>\" \"<CMAKE_AR> ar\" CMAKE_C_ARCHIVE_CREATE ${CMAKE_C_ARCHIVE_CREATE})\n  string(REPLACE \"<CMAKE_AR>\" \"<CMAKE_AR> ar\" CMAKE_CXX_ARCHIVE_CREATE ${CMAKE_CXX_ARCHIVE_CREATE})\nendif()\n\n\noption(ZIG_PIE \"Produce a position independent zig executable\" ${CMAKE_POSITION_INDEPENDENT_CODE})\ninclude(CheckPIESupported)\ncheck_pie_supported(\n  OUTPUT_VARIABLE ZIG_PIE_SUPPORTED_BY_CMAKE\n  LANGUAGES C CXX\n)\nif(ZIG_PIE AND NOT CMAKE_CXX_LINK_PIE_SUPPORTED)\n  message(SEND_ERROR \"ZIG_PIE was requested but CMake does not support it for \\\"zigcpp\\\" target: ${ZIG_PIE_SUPPORTED_BY_CMAKE}\")\nendif()\n\n\n# Detect system libcxx name.\nif (\"c++\" IN_LIST CMAKE_CXX_IMPLICIT_LINK_LIBRARIES)\n    set(ZIG_SYSTEM_LIBCXX \"c++\" CACHE STRING \"system libcxx name for build.zig\")\nelse()\n    set(ZIG_SYSTEM_LIBCXX \"stdc++\" CACHE STRING \"system libcxx name for build.zig\")\nendif()\n\nfind_package(llvm 19)\nfind_package(clang 19)\nfind_package(lld 19)\n\nif(ZIG_STATIC_ZLIB)\n    if (MSVC)\n        list(REMOVE_ITEM LLVM_LIBRARIES \"z.lib\")\n    else()\n        list(REMOVE_ITEM LLVM_LIBRARIES \"-lz\")\n    endif()\n\n    find_library(ZLIB NAMES libz.a libzlibstatic.a z zlib libz NAMES_PER_DIR)\n    list(APPEND LLVM_LIBRARIES \"${ZLIB}\")\nendif()\n\nif(ZIG_STATIC_ZSTD)\n    if (MSVC)\n        list(REMOVE_ITEM LLVM_LIBRARIES \"zstd.lib\")\n    else()\n        list(REMOVE_ITEM LLVM_LIBRARIES \"-lzstd\")\n    endif()\n\n    find_library(ZSTD NAMES libzstd.a libzstdstatic.a zstd NAMES_PER_DIR)\n    list(APPEND LLVM_LIBRARIES \"${ZSTD}\")\nendif()\n\nif(ZIG_STATIC_CURSES)\n    list(REMOVE_ITEM LLVM_LIBRARIES \"-lcurses\")\n    find_library(CURSES NAMES libcurses.a libncurses.a NAMES_PER_DIR\n      PATHS\n        /usr/local/opt/ncurses/lib\n        /opt/homebrew/opt/ncurses/lib)\n    list(APPEND LLVM_LIBRARIES \"${CURSES}\")\nendif()\n\nfind_package(Threads)\n\nset(ZIG_CONFIG_H_OUT \"${PROJECT_BINARY_DIR}/config.h\")\nset(ZIG_CONFIG_ZIG_OUT \"${PROJECT_BINARY_DIR}/config.zig\")\n\nset(ZIG_WASM2C_SOURCES\n    stage1/wasm2c.c\n)\n# Sync with \"zig_cpp_sources\" in build.zig\nset(ZIG_CPP_SOURCES\n    # These are planned to stay even when we are self-hosted.\n    src/zig_llvm.cpp\n    src/zig_llvm-ar.cpp\n    src/zig_clang.cpp\n    src/zig_clang_driver.cpp\n    src/zig_clang_cc1_main.cpp\n    src/zig_clang_cc1as_main.cpp\n)\n# Needed because we use cmake, not the zig build system, to build zig2.o.\nset(ZIG_STAGE2_SOURCES\n    \"${ZIG_CONFIG_ZIG_OUT}\"\n    lib/compiler_rt.zig\n    lib/compiler_rt/absv.zig\n    lib/compiler_rt/absvdi2.zig\n    lib/compiler_rt/absvsi2.zig\n    lib/compiler_rt/absvti2.zig\n    lib/compiler_rt/adddf3.zig\n    lib/compiler_rt/addf3.zig\n    lib/compiler_rt/addo.zig\n    lib/compiler_rt/addsf3.zig\n    lib/compiler_rt/addtf3.zig\n    lib/compiler_rt/addxf3.zig\n    lib/compiler_rt/arm.zig\n    lib/compiler_rt/atomics.zig\n    lib/compiler_rt/aulldiv.zig\n    lib/compiler_rt/aullrem.zig\n    lib/compiler_rt/bswap.zig\n    lib/compiler_rt/ceil.zig\n    lib/compiler_rt/clear_cache.zig\n    lib/compiler_rt/cmp.zig\n    lib/compiler_rt/cmpdf2.zig\n    lib/compiler_rt/cmpsf2.zig\n    lib/compiler_rt/cmptf2.zig\n    lib/compiler_rt/cmpxf2.zig\n    lib/compiler_rt/common.zig\n    lib/compiler_rt/comparef.zig\n    lib/compiler_rt/cos.zig\n    lib/compiler_rt/count0bits.zig\n    lib/compiler_rt/divdf3.zig\n    lib/compiler_rt/divsf3.zig\n    lib/compiler_rt/divtf3.zig\n    lib/compiler_rt/divti3.zig\n    lib/compiler_rt/divxf3.zig\n    lib/compiler_rt/emutls.zig\n    lib/compiler_rt/exp.zig\n    lib/compiler_rt/exp2.zig\n    lib/compiler_rt/extenddftf2.zig\n    lib/compiler_rt/extenddfxf2.zig\n    lib/compiler_rt/extendf.zig\n    lib/compiler_rt/extendhfsf2.zig\n    lib/compiler_rt/extendhftf2.zig\n    lib/compiler_rt/extendhfxf2.zig\n    lib/compiler_rt/extendsfdf2.zig\n    lib/compiler_rt/extendsftf2.zig\n    lib/compiler_rt/extendsfxf2.zig\n    lib/compiler_rt/extendxftf2.zig\n    lib/compiler_rt/fabs.zig\n    lib/compiler_rt/fixdfdi.zig\n    lib/compiler_rt/fixdfsi.zig\n    lib/compiler_rt/fixdfti.zig\n    lib/compiler_rt/fixhfdi.zig\n    lib/compiler_rt/fixhfsi.zig\n    lib/compiler_rt/fixhfti.zig\n    lib/compiler_rt/fixsfdi.zig\n    lib/compiler_rt/fixsfsi.zig\n    lib/compiler_rt/fixsfti.zig\n    lib/compiler_rt/fixtfdi.zig\n    lib/compiler_rt/fixtfsi.zig\n    lib/compiler_rt/fixtfti.zig\n    lib/compiler_rt/fixunsdfdi.zig\n    lib/compiler_rt/fixunsdfsi.zig\n    lib/compiler_rt/fixunsdfti.zig\n    lib/compiler_rt/fixunshfdi.zig\n    lib/compiler_rt/fixunshfsi.zig\n    lib/compiler_rt/fixunshfti.zig\n    lib/compiler_rt/fixunssfdi.zig\n    lib/compiler_rt/fixunssfsi.zig\n    lib/compiler_rt/fixunssfti.zig\n    lib/compiler_rt/fixunstfdi.zig\n    lib/compiler_rt/fixunstfsi.zig\n    lib/compiler_rt/fixunstfti.zig\n    lib/compiler_rt/fixunsxfdi.zig\n    lib/compiler_rt/fixunsxfsi.zig\n    lib/compiler_rt/fixunsxfti.zig\n    lib/compiler_rt/fixxfdi.zig\n    lib/compiler_rt/fixxfsi.zig\n    lib/compiler_rt/fixxfti.zig\n    lib/compiler_rt/float_from_int.zig\n    lib/compiler_rt/floatdidf.zig\n    lib/compiler_rt/floatdihf.zig\n    lib/compiler_rt/floatdisf.zig\n    lib/compiler_rt/floatditf.zig\n    lib/compiler_rt/floatdixf.zig\n    lib/compiler_rt/floatsidf.zig\n    lib/compiler_rt/floatsihf.zig\n    lib/compiler_rt/floatsisf.zig\n    lib/compiler_rt/floatsitf.zig\n    lib/compiler_rt/floatsixf.zig\n    lib/compiler_rt/floattidf.zig\n    lib/compiler_rt/floattihf.zig\n    lib/compiler_rt/floattisf.zig\n    lib/compiler_rt/floattitf.zig\n    lib/compiler_rt/floattixf.zig\n    lib/compiler_rt/floatundidf.zig\n    lib/compiler_rt/floatundihf.zig\n    lib/compiler_rt/floatundisf.zig\n    lib/compiler_rt/floatunditf.zig\n    lib/compiler_rt/floatundixf.zig\n    lib/compiler_rt/floatunsidf.zig\n    lib/compiler_rt/floatunsihf.zig\n    lib/compiler_rt/floatunsisf.zig\n    lib/compiler_rt/floatunsitf.zig\n    lib/compiler_rt/floatunsixf.zig\n    lib/compiler_rt/floatuntidf.zig\n    lib/compiler_rt/floatuntihf.zig\n    lib/compiler_rt/floatuntisf.zig\n    lib/compiler_rt/floatuntitf.zig\n    lib/compiler_rt/floatuntixf.zig\n    lib/compiler_rt/floor.zig\n    lib/compiler_rt/fma.zig\n    lib/compiler_rt/fmax.zig\n    lib/compiler_rt/fmin.zig\n    lib/compiler_rt/fmod.zig\n    lib/compiler_rt/gedf2.zig\n    lib/compiler_rt/gesf2.zig\n    lib/compiler_rt/getf2.zig\n    lib/compiler_rt/gexf2.zig\n    lib/compiler_rt/int.zig\n    lib/compiler_rt/int_from_float.zig\n    lib/compiler_rt/log.zig\n    lib/compiler_rt/log10.zig\n    lib/compiler_rt/log2.zig\n    lib/compiler_rt/modti3.zig\n    lib/compiler_rt/mulXi3.zig\n    lib/compiler_rt/muldf3.zig\n    lib/compiler_rt/mulf3.zig\n    lib/compiler_rt/mulo.zig\n    lib/compiler_rt/mulsf3.zig\n    lib/compiler_rt/multf3.zig\n    lib/compiler_rt/mulxf3.zig\n    lib/compiler_rt/negXi2.zig\n    lib/compiler_rt/negdf2.zig\n    lib/compiler_rt/negsf2.zig\n    lib/compiler_rt/negtf2.zig\n    lib/compiler_rt/negv.zig\n    lib/compiler_rt/negxf2.zig\n    lib/compiler_rt/os_version_check.zig\n    lib/compiler_rt/parity.zig\n    lib/compiler_rt/popcount.zig\n    lib/compiler_rt/rem_pio2.zig\n    lib/compiler_rt/rem_pio2_large.zig\n    lib/compiler_rt/rem_pio2f.zig\n    lib/compiler_rt/round.zig\n    lib/compiler_rt/shift.zig\n    lib/compiler_rt/sin.zig\n    lib/compiler_rt/sincos.zig\n    lib/compiler_rt/sqrt.zig\n    lib/compiler_rt/stack_probe.zig\n    lib/compiler_rt/subdf3.zig\n    lib/compiler_rt/subo.zig\n    lib/compiler_rt/subsf3.zig\n    lib/compiler_rt/subtf3.zig\n    lib/compiler_rt/subxf3.zig\n    lib/compiler_rt/tan.zig\n    lib/compiler_rt/trig.zig\n    lib/compiler_rt/trunc.zig\n    lib/compiler_rt/truncdfhf2.zig\n    lib/compiler_rt/truncdfsf2.zig\n    lib/compiler_rt/truncf.zig\n    lib/compiler_rt/truncsfhf2.zig\n    lib/compiler_rt/trunctfdf2.zig\n    lib/compiler_rt/trunctfhf2.zig\n    lib/compiler_rt/trunctfsf2.zig\n    lib/compiler_rt/trunctfxf2.zig\n    lib/compiler_rt/truncxfdf2.zig\n    lib/compiler_rt/truncxfhf2.zig\n    lib/compiler_rt/truncxfsf2.zig\n    lib/compiler_rt/udivmod.zig\n    lib/compiler_rt/udivmodei4.zig\n    lib/compiler_rt/udivmodti4.zig\n    lib/compiler_rt/udivti3.zig\n    lib/compiler_rt/umodti3.zig\n    lib/compiler_rt/unorddf2.zig\n    lib/compiler_rt/unordsf2.zig\n    lib/compiler_rt/unordtf2.zig\n    lib/std/BitStack.zig\n    lib/std/Build.zig\n    lib/std/Build/Cache.zig\n    lib/std/Build/Cache/DepTokenizer.zig\n    lib/std/Progress.zig\n    lib/std/Random.zig\n    lib/std/Target.zig\n    lib/std/Target/Query.zig\n    lib/std/Target/aarch64.zig\n    lib/std/Target/amdgcn.zig\n    lib/std/Target/arm.zig\n    lib/std/Target/avr.zig\n    lib/std/Target/bpf.zig\n    lib/std/Target/hexagon.zig\n    lib/std/Target/loongarch.zig\n    lib/std/Target/mips.zig\n    lib/std/Target/msp430.zig\n    lib/std/Target/nvptx.zig\n    lib/std/Target/powerpc.zig\n    lib/std/Target/riscv.zig\n    lib/std/Target/s390x.zig\n    lib/std/Target/sparc.zig\n    lib/std/Target/wasm.zig\n    lib/std/Target/x86.zig\n    lib/std/Thread.zig\n    lib/std/Thread/Futex.zig\n    lib/std/Thread/Mutex.zig\n    lib/std/Thread/Pool.zig\n    lib/std/Thread/ResetEvent.zig\n    lib/std/Thread/WaitGroup.zig\n    lib/std/array_hash_map.zig\n    lib/std/array_list.zig\n    lib/std/ascii.zig\n    lib/std/atomic.zig\n    lib/std/base64.zig\n    lib/std/buf_map.zig\n    lib/std/builtin.zig\n    lib/std/c.zig\n    lib/std/coff.zig\n    lib/std/crypto.zig\n    lib/std/crypto/blake3.zig\n    lib/std/crypto/siphash.zig\n    lib/std/debug.zig\n    lib/std/dwarf.zig\n    lib/std/dwarf/AT.zig\n    lib/std/dwarf/ATE.zig\n    lib/std/dwarf/FORM.zig\n    lib/std/dwarf/LANG.zig\n    lib/std/dwarf/OP.zig\n    lib/std/dwarf/TAG.zig\n    lib/std/elf.zig\n    lib/std/fifo.zig\n    lib/std/fmt.zig\n    lib/std/fmt/format_float.zig\n    lib/std/fmt/parse_float.zig\n    lib/std/fs.zig\n    lib/std/fs/AtomicFile.zig\n    lib/std/fs/Dir.zig\n    lib/std/fs/File.zig\n    lib/std/fs/get_app_data_dir.zig\n    lib/std/fs/path.zig\n    lib/std/hash.zig\n    lib/std/hash/auto_hash.zig\n    lib/std/hash/wyhash.zig\n    lib/std/hash_map.zig\n    lib/std/heap.zig\n    lib/std/heap/arena_allocator.zig\n    lib/std/io.zig\n    lib/std/io/Reader.zig\n    lib/std/io/Writer.zig\n    lib/std/io/buffered_atomic_file.zig\n    lib/std/io/buffered_writer.zig\n    lib/std/io/change_detection_stream.zig\n    lib/std/io/counting_reader.zig\n    lib/std/io/counting_writer.zig\n    lib/std/io/find_byte_writer.zig\n    lib/std/io/fixed_buffer_stream.zig\n    lib/std/io/limited_reader.zig\n    lib/std/io/seekable_stream.zig\n    lib/std/json.zig\n    lib/std/json/stringify.zig\n    lib/std/leb128.zig\n    lib/std/linked_list.zig\n    lib/std/log.zig\n    lib/std/macho.zig\n    lib/std/math.zig\n    lib/std/math/big.zig\n    lib/std/math/big/int.zig\n    lib/std/math/float.zig\n    lib/std/math/frexp.zig\n    lib/std/math/isinf.zig\n    lib/std/math/isnan.zig\n    lib/std/math/log.zig\n    lib/std/math/log10.zig\n    lib/std/math/log2.zig\n    lib/std/math/signbit.zig\n    lib/std/math/sqrt.zig\n    lib/std/mem.zig\n    lib/std/mem/Allocator.zig\n    lib/std/meta.zig\n    lib/std/meta/trailer_flags.zig\n    lib/std/multi_array_list.zig\n    lib/std/os.zig\n    lib/std/os/linux.zig\n    lib/std/os/linux.zig\n    lib/std/os/linux/IoUring.zig\n    lib/std/os/linux/io_uring_sqe.zig\n    lib/std/os/linux/x86_64.zig\n    lib/std/os/linux/x86_64.zig\n    lib/std/os/windows.zig\n    lib/std/os/windows/ntstatus.zig\n    lib/std/os/windows/win32error.zig\n    lib/std/pdb.zig\n    lib/std/process.zig\n    lib/std/process/Child.zig\n    lib/std/sort.zig\n    lib/std/start.zig\n    lib/std/static_string_map.zig\n    lib/std/std.zig\n    lib/std/time.zig\n    lib/std/treap.zig\n    lib/std/unicode.zig\n    lib/std/zig.zig\n    lib/std/zig/Ast.zig\n    lib/std/zig/AstGen.zig\n    lib/std/zig/AstRlAnnotate.zig\n    lib/std/zig/LibCInstallation.zig\n    lib/std/zig/Parse.zig\n    lib/std/zig/Server.zig\n    lib/std/zig/WindowsSdk.zig\n    lib/std/zig/Zir.zig\n    lib/std/zig/c_builtins.zig\n    lib/std/zig/render.zig\n    lib/std/zig/string_literal.zig\n    lib/std/zig/system.zig\n    lib/std/zig/system/NativePaths.zig\n    lib/std/zig/system/x86.zig\n    lib/std/zig/tokenizer.zig\n    src/Air.zig\n    src/Builtin.zig\n    src/Compilation.zig\n    src/Compilation/Config.zig\n    src/DarwinPosixSpawn.zig\n    src/InternPool.zig\n    src/Liveness.zig\n    src/Liveness/Verify.zig\n    src/Package.zig\n    src/Package/Fetch.zig\n    src/Package/Fetch/git.zig\n    src/Package/Manifest.zig\n    src/Package/Module.zig\n    src/RangeSet.zig\n    src/Sema.zig\n    src/Sema/bitcast.zig\n    src/Sema/comptime_ptr_access.zig\n    src/ThreadSafeQueue.zig\n    src/Type.zig\n    src/Value.zig\n    src/Zcu.zig\n    src/Zcu/PerThread.zig\n    src/arch/aarch64/CodeGen.zig\n    src/arch/aarch64/Emit.zig\n    src/arch/aarch64/Mir.zig\n    src/arch/aarch64/abi.zig\n    src/arch/aarch64/bits.zig\n    src/arch/arm/CodeGen.zig\n    src/arch/arm/Emit.zig\n    src/arch/arm/Mir.zig\n    src/arch/arm/abi.zig\n    src/arch/arm/bits.zig\n    src/arch/riscv64/abi.zig\n    src/arch/riscv64/bits.zig\n    src/arch/riscv64/CodeGen.zig\n    src/arch/riscv64/Emit.zig\n    src/arch/riscv64/encoding.zig\n    src/arch/riscv64/Lower.zig\n    src/arch/riscv64/Mir.zig\n    src/arch/riscv64/mnem.zig\n    src/arch/sparc64/CodeGen.zig\n    src/arch/sparc64/Emit.zig\n    src/arch/sparc64/Mir.zig\n    src/arch/sparc64/abi.zig\n    src/arch/sparc64/bits.zig\n    src/arch/wasm/CodeGen.zig\n    src/arch/wasm/Emit.zig\n    src/arch/wasm/Mir.zig\n    src/arch/wasm/abi.zig\n    src/arch/x86/bits.zig\n    src/arch/x86_64/CodeGen.zig\n    src/arch/x86_64/Disassembler.zig\n    src/arch/x86_64/Emit.zig\n    src/arch/x86_64/Encoding.zig\n    src/arch/x86_64/Lower.zig\n    src/arch/x86_64/Mir.zig\n    src/arch/x86_64/abi.zig\n    src/arch/x86_64/bits.zig\n    src/arch/x86_64/encoder.zig\n    src/arch/x86_64/encodings.zig\n    src/clang.zig\n    src/clang_options.zig\n    src/clang_options_data.zig\n    src/codegen.zig\n    src/codegen/c.zig\n    src/codegen/c/Type.zig\n    src/codegen/llvm.zig\n    src/codegen/llvm/BitcodeReader.zig\n    src/codegen/llvm/Builder.zig\n    src/codegen/llvm/bindings.zig\n    src/codegen/llvm/bitcode_writer.zig\n    src/codegen/llvm/ir.zig\n    src/codegen/spirv.zig\n    src/codegen/spirv/Assembler.zig\n    src/codegen/spirv/Module.zig\n    src/codegen/spirv/Section.zig\n    src/codegen/spirv/spec.zig\n    src/crash_report.zig\n    src/dev.zig\n    src/glibc.zig\n    src/introspect.zig\n    src/libcxx.zig\n    src/libtsan.zig\n    src/libunwind.zig\n    src/link.zig\n    src/link/C.zig\n    src/link/Coff.zig\n    src/link/Dwarf.zig\n    src/link/Elf.zig\n    src/link/Elf/Archive.zig\n    src/link/Elf/Atom.zig\n    src/link/Elf/AtomList.zig\n    src/link/Elf/LinkerDefined.zig\n    src/link/Elf/Merge.zig\n    src/link/Elf/Object.zig\n    src/link/Elf/SharedObject.zig\n    src/link/Elf/Symbol.zig\n    src/link/Elf/Thunk.zig\n    src/link/Elf/ZigObject.zig\n    src/link/Elf/eh_frame.zig\n    src/link/Elf/file.zig\n    src/link/Elf/gc.zig\n    src/link/Elf/relocatable.zig\n    src/link/Elf/relocation.zig\n    src/link/Elf/synthetic_sections.zig\n    src/link/LdScript.zig\n    src/link/MachO.zig\n    src/link/MachO/Archive.zig\n    src/link/MachO/Atom.zig\n    src/link/MachO/CodeSignature.zig\n    src/link/MachO/DebugSymbols.zig\n    src/link/MachO/Dwarf.zig\n    src/link/MachO/Dylib.zig\n    src/link/MachO/InternalObject.zig\n    src/link/MachO/Object.zig\n    src/link/MachO/Relocation.zig\n    src/link/MachO/Symbol.zig\n    src/link/MachO/UnwindInfo.zig\n    src/link/MachO/ZigObject.zig\n    src/link/MachO/dead_strip.zig\n    src/link/MachO/dyld_info/Rebase.zig\n    src/link/MachO/dyld_info/Trie.zig\n    src/link/MachO/dyld_info/bind.zig\n    src/link/MachO/eh_frame.zig\n    src/link/MachO/fat.zig\n    src/link/MachO/file.zig\n    src/link/MachO/hasher.zig\n    src/link/MachO/load_commands.zig\n    src/link/MachO/relocatable.zig\n    src/link/MachO/synthetic.zig\n    src/link/MachO/Thunk.zig\n    src/link/MachO/uuid.zig\n    src/link/NvPtx.zig\n    src/link/Plan9.zig\n    src/link/Plan9/aout.zig\n    src/link/SpirV.zig\n    src/link/SpirV/BinaryModule.zig\n    src/link/SpirV/deduplicate.zig\n    src/link/SpirV/lower_invocation_globals.zig\n    src/link/SpirV/prune_unused.zig\n    src/link/StringTable.zig\n    src/link/Wasm.zig\n    src/link/Wasm/Archive.zig\n    src/link/Wasm/Object.zig\n    src/link/Wasm/Symbol.zig\n    src/link/Wasm/ZigObject.zig\n    src/link/aarch64.zig\n    src/link/riscv.zig\n    src/link/table_section.zig\n    src/link/tapi.zig\n    src/link/tapi/Tokenizer.zig\n    src/link/tapi/parse.zig\n    src/link/tapi/parse/test.zig\n    src/link/tapi/yaml.zig\n    src/link/tapi/yaml/test.zig\n    src/main.zig\n    src/mingw.zig\n    src/musl.zig\n    src/mutable_value.zig\n    src/print_air.zig\n    src/print_env.zig\n    src/print_targets.zig\n    src/print_value.zig\n    src/print_zir.zig\n    src/register_manager.zig\n    src/target.zig\n    src/tracy.zig\n    src/translate_c.zig\n    src/wasi_libc.zig\n)\n\nif(MSVC)\n    set(MSVC_DIA_SDK_DIR \"$ENV{VSINSTALLDIR}DIA SDK\")\n    if(IS_DIRECTORY ${MSVC_DIA_SDK_DIR})\n        set(ZIG_DIA_GUIDS_LIB \"${MSVC_DIA_SDK_DIR}/lib/amd64/diaguids.lib\")\n        string(REGEX REPLACE \"\\\\\\\\\" \"\\\\\\\\\\\\\\\\\" ZIG_DIA_GUIDS_LIB_ESCAPED \"${ZIG_DIA_GUIDS_LIB}\")\n    endif()\nendif()\n\nconfigure_file (\n    stage1/config.h.in\n    \"${ZIG_CONFIG_H_OUT}\"\n)\nconfigure_file (\n    stage1/config.zig.in\n    \"${ZIG_CONFIG_ZIG_OUT}\"\n)\n\n# zigcpp target\n\nset(ZIGCPP_OUTPUT_DIR \"${PROJECT_BINARY_DIR}/zigcpp\")\n\nadd_library(zigcpp STATIC ${ZIG_CPP_SOURCES})\n\n# Sync with minimum C++ standard required to build LLVM\n# and with \"exe_cflags\" in build.zig\ntarget_compile_features(zigcpp PRIVATE cxx_std_17)\nset_target_properties(zigcpp PROPERTIES POSITION_INDEPENDENT_CODE ${ZIG_PIE})\n\nif(NOT MSVC)\n  if(MINGW)\n    target_compile_options(zigcpp PRIVATE -Wno-format)\n  endif()\n  # Sync content below with \"exe_cflags\" in build.zig\n  target_compile_definitions(zigcpp PUBLIC\n    __STDC_CONSTANT_MACROS\n    __STDC_FORMAT_MACROS\n    __STDC_LIMIT_MACROS\n\n    _GNU_SOURCE\n  )\n  target_compile_options(zigcpp PRIVATE\n    -fno-exceptions\n    -fno-rtti\n    -fno-stack-protector\n\n    -fvisibility-inlines-hidden\n\n    -Wno-type-limits\n    -Wno-missing-braces\n    -Wno-comment\n  )\nelse()\ntarget_compile_options(zigcpp PRIVATE /Zc:preprocessor)\nset_property(TARGET zigcpp PROPERTY MSVC_RUNTIME_LIBRARY \"MultiThreaded\")\nendif()\n\ntarget_include_directories(zigcpp PUBLIC\n    ${CLANG_INCLUDE_DIRS}\n    ${LLVM_INCLUDE_DIRS}\n    ${LLD_INCLUDE_DIRS}\n)\ntarget_link_libraries(zigcpp PUBLIC\n    ${CLANG_LIBRARIES}\n    ${LLD_LIBRARIES}\n    ${LLVM_LIBRARIES}\n    ${CMAKE_THREAD_LIBS_INIT}\n)\n\n# Handle multi-config builds and place each into a common lib. The VS generator\n# for example will append a Debug folder by default if not explicitly specified.\nset_target_properties(zigcpp PROPERTIES ARCHIVE_OUTPUT_DIRECTORY ${ZIGCPP_OUTPUT_DIR})\nforeach(CONFIG_TYPE ${CMAKE_CONFIGURATION_TYPES})\n    string(TOUPPER ${CONFIG_TYPE} CONFIG_TYPE)\n    set_target_properties(zigcpp PROPERTIES ARCHIVE_OUTPUT_DIRECTORY_${CONFIG_TYPE} ${ZIGCPP_OUTPUT_DIR})\nendforeach()\n\n# end of zigcpp target\n\ninclude(CheckSymbolExists)\n\nstring(TOLOWER \"${CMAKE_HOST_SYSTEM_NAME}\" ZIG_HOST_TARGET_OS)\nif(ZIG_HOST_TARGET_OS STREQUAL \"darwin\")\n  set(ZIG_HOST_TARGET_OS \"macos\")\nelseif(ZIG_HOST_TARGET_OS STREQUAL \"sunos\")\n  check_symbol_exists(__illumos__ \"\" ZIG_HOST_TARGET_HAS_ILLUMOS_MACRO)\n  if (ZIG_HOST_TARGET_HAS_ILLUMOS_MACRO)\n    set(ZIG_HOST_TARGET_OS \"illumos\")\n  else()\n    set(ZIG_HOST_TARGET_OS \"solaris\")\n  endif()\nendif()\n\nstring(TOLOWER \"${CMAKE_HOST_SYSTEM_PROCESSOR}\" ZIG_HOST_TARGET_ARCH)\nif(ZIG_HOST_TARGET_ARCH MATCHES \"^i[3-9]86$\")\n  if (ZIG_HOST_TARGET_OS MATCHES \"(solaris|illumos)\")\n    set(ZIG_HOST_TARGET_ARCH \"x86_64\")\n  else()\n    set(ZIG_HOST_TARGET_ARCH \"x86\")\n  endif()\nelseif(ZIG_HOST_TARGET_ARCH STREQUAL \"amd64\")\n  set(ZIG_HOST_TARGET_ARCH \"x86_64\")\nelseif(ZIG_HOST_TARGET_ARCH STREQUAL \"arm64\")\n  set(ZIG_HOST_TARGET_ARCH \"aarch64\")\nelseif(ZIG_HOST_TARGET_ARCH STREQUAL \"armv7l\")\n  set(ZIG_HOST_TARGET_ARCH \"arm\")\nelseif(ZIG_HOST_TARGET_ARCH STREQUAL \"armv7b\")\n  set(ZIG_HOST_TARGET_ARCH \"armeb\")\nendif()\nstring(REGEX REPLACE \"^((arm|thumb)(hf?)?)el$\" \"\\\\1\" ZIG_HOST_TARGET_ARCH \"${ZIG_HOST_TARGET_ARCH}\")\nif(ZIG_HOST_TARGET_ARCH MATCHES \"^arm(hf?)?(eb)?$\")\n  check_symbol_exists(__thumb__ \"\" ZIG_HOST_TARGET_DEFAULTS_TO_THUMB)\n  if(ZIG_HOST_TARGET_DEFAULTS_TO_THUMB)\n    string(REGEX REPLACE \"^arm\" \"thumb\" ZIG_HOST_TARGET_ARCH \"${ZIG_HOST_TARGET_ARCH}\")\n  endif()\nendif()\nstring(REGEX REPLACE \"^ppc((64)?(le)?)$\" \"powerpc\\\\1\" ZIG_HOST_TARGET_ARCH \"${ZIG_HOST_TARGET_ARCH}\")\n\nif(MSVC)\n  set(ZIG_HOST_TARGET_ABI \"-msvc\")\nelseif(MINGW)\n  set(ZIG_HOST_TARGET_ABI \"-gnu\")\nelseif(ZIG_HOST_TARGET_ARCH MATCHES \"^(arm|thumb)hf?(eb)?$\")\n  string(REGEX REPLACE \"^(arm|thumb)hf?((eb)?)$\" \"\\\\1\\\\2\" ZIG_HOST_TARGET_ARCH \"${ZIG_HOST_TARGET_ARCH}\")\n  set(ZIG_HOST_TARGET_ABI \"-eabihf\")\nelse()\n  set(ZIG_HOST_TARGET_ABI \"\")\nendif()\n\nset(ZIG_HOST_TARGET_TRIPLE \"${ZIG_HOST_TARGET_ARCH}-${ZIG_HOST_TARGET_OS}${ZIG_HOST_TARGET_ABI}\" CACHE STRING \"Host zig target triple.\")\n\nif(MSVC)\n  set(ZIG_WASM2C_COMPILE_FLAGS \"\")\n  set(ZIG1_COMPILE_FLAGS \"/Os\")\n  set(ZIG2_COMPILE_FLAGS \"/Od\")\n  set(ZIG2_LINK_FLAGS \"/STACK:16777216 /FORCE:MULTIPLE\")\nelse()\n  set(ZIG_WASM2C_COMPILE_FLAGS \"-std=c99 -O2\")\n  set(ZIG1_COMPILE_FLAGS \"-std=c99 -Os\")\n  set(ZIG2_COMPILE_FLAGS \"-std=c99 -O0 -fno-stack-protector\")\n  if(APPLE)\n    set(ZIG2_LINK_FLAGS \"-Wl,-stack_size,0x10000000\")\n  elseif(MINGW)\n    set(ZIG2_LINK_FLAGS \"-Wl,--stack,0x10000000\")\n  # Solaris/illumos ld(1) does not provide a --stack-size option.\n  elseif(CMAKE_HOST_SOLARIS)\n    unset(ZIG2_LINK_FLAGS)\n  else()\n    set(ZIG2_LINK_FLAGS \"-Wl,-z,stack-size=0x10000000\")\n  endif()\nendif()\n\nset(ZIG1_WASM_MODULE \"${PROJECT_SOURCE_DIR}/stage1/zig1.wasm\")\nset(ZIG1_C_SOURCE \"${PROJECT_BINARY_DIR}/zig1.c\")\nset(ZIG2_C_SOURCE \"${PROJECT_BINARY_DIR}/zig2.c\")\nset(ZIG_COMPILER_RT_C_SOURCE \"${PROJECT_BINARY_DIR}/compiler_rt.c\")\n\nadd_executable(zig-wasm2c ${ZIG_WASM2C_SOURCES})\nset_target_properties(zig-wasm2c PROPERTIES COMPILE_FLAGS \"${ZIG_WASM2C_COMPILE_FLAGS}\")\n\nadd_custom_command(\n  OUTPUT \"${ZIG1_C_SOURCE}\"\n  COMMAND zig-wasm2c \"${ZIG1_WASM_MODULE}\" \"${ZIG1_C_SOURCE}\"\n  DEPENDS zig-wasm2c \"${ZIG1_WASM_MODULE}\"\n  COMMENT \"Converting ${ZIG1_WASM_MODULE} to ${ZIG1_C_SOURCE}\"\n  WORKING_DIRECTORY \"${PROJECT_SOURCE_DIR}\"\n)\n\nadd_executable(zig1 ${ZIG1_C_SOURCE} stage1/wasi.c)\nset_target_properties(zig1 PROPERTIES COMPILE_FLAGS ${ZIG1_COMPILE_FLAGS})\n\nif(MSVC)\n  target_link_options(zig1 PRIVATE /STACK:0x10000000)\nelse()\n  target_link_libraries(zig1 LINK_PUBLIC m)\n  if(MINGW)\n    target_link_options(zig1 PRIVATE -Wl,--stack,0x10000000)\n  endif()\nendif()\n\nset(BUILD_ZIG2_ARGS\n  \"${PROJECT_SOURCE_DIR}/lib\"\n  build-exe -ofmt=c -lc -OReleaseSmall\n  --name zig2\n  -femit-bin=\"${ZIG2_C_SOURCE}\"\n  -target \"${ZIG_HOST_TARGET_TRIPLE}\"\n  --dep \"build_options\"\n  --dep \"aro\"\n  \"-Mroot=src/main.zig\"\n  \"-Mbuild_options=${ZIG_CONFIG_ZIG_OUT}\"\n  \"-Maro=lib/compiler/aro/aro.zig\"\n)\n\nadd_custom_command(\n  OUTPUT \"${ZIG2_C_SOURCE}\"\n  COMMAND zig1 ${BUILD_ZIG2_ARGS}\n  DEPENDS zig1 \"${ZIG_STAGE2_SOURCES}\"\n  COMMENT \"Running zig1.wasm to produce ${ZIG2_C_SOURCE}\"\n  WORKING_DIRECTORY \"${PROJECT_SOURCE_DIR}\"\n)\n\nset(BUILD_COMPILER_RT_ARGS\n  \"${PROJECT_SOURCE_DIR}/lib\"\n  build-obj -ofmt=c -OReleaseSmall\n  --name compiler_rt\n  -femit-bin=\"${ZIG_COMPILER_RT_C_SOURCE}\"\n  -target \"${ZIG_HOST_TARGET_TRIPLE}\"\n  \"-Mroot=lib/compiler_rt.zig\"\n)\n\nadd_custom_command(\n  OUTPUT \"${ZIG_COMPILER_RT_C_SOURCE}\"\n  COMMAND zig1 ${BUILD_COMPILER_RT_ARGS}\n  DEPENDS zig1 \"${ZIG_STAGE2_SOURCES}\"\n  COMMENT \"Running zig1.wasm to produce ${ZIG_COMPILER_RT_C_SOURCE}\"\n  WORKING_DIRECTORY \"${PROJECT_SOURCE_DIR}\"\n)\n\nadd_executable(zig2 ${ZIG2_C_SOURCE} ${ZIG_COMPILER_RT_C_SOURCE})\nset_target_properties(zig2 PROPERTIES\n  COMPILE_FLAGS ${ZIG2_COMPILE_FLAGS}\n  LINK_FLAGS \"${ZIG2_LINK_FLAGS}\"\n)\ntarget_include_directories(zig2 PUBLIC stage1)\ntarget_link_libraries(zig2 LINK_PUBLIC zigcpp)\n\nif(MSVC)\n  target_link_libraries(zig2 LINK_PUBLIC ntdll.lib ws2_32.lib)\nelseif(MINGW)\n  target_link_libraries(zig2 LINK_PUBLIC ntdll ws2_32)\nendif()\n\nif(NOT MSVC)\n    target_link_libraries(zig2 LINK_PUBLIC ${LIBXML2})\nendif()\n\nif(ZIG_DIA_GUIDS_LIB)\n    target_link_libraries(zig2 LINK_PUBLIC ${ZIG_DIA_GUIDS_LIB})\nendif()\n\nif(MSVC OR MINGW)\n    target_link_libraries(zig2 LINK_PUBLIC version)\nendif()\n\n\n# \"-Dno-langref\" is hardcoded because stage2 builds lack the `@cImport`\n# feature, which some of the doctests rely on.\n\n# To obtain this document, run `zig build` against stage3 rather than stage2.\n# Note that the `langref` step can be used to isolate this task.\nset(ZIG_BUILD_ARGS\n  --zig-lib-dir \"${PROJECT_SOURCE_DIR}/lib\"\n\n  \"-Dversion-string=${RESOLVED_ZIG_VERSION}\"\n  \"-Dtarget=${ZIG_TARGET_TRIPLE}\"\n  \"-Dcpu=${ZIG_TARGET_MCPU}\"\n\n  -Denable-llvm\n  \"-Dconfig_h=${ZIG_CONFIG_H_OUT}\"\n\n  -Dno-langref\n)\n\noption(ZIG_EXTRA_BUILD_ARGS \"Extra zig build args\")\nif(ZIG_EXTRA_BUILD_ARGS)\n  list(APPEND ZIG_BUILD_ARGS ${ZIG_EXTRA_BUILD_ARGS})\nendif()\n\nif(\"${CMAKE_BUILD_TYPE}\" STREQUAL \"Debug\")\n  list(APPEND ZIG_BUILD_ARGS -Doptimize=Debug)\nelseif(\"${CMAKE_BUILD_TYPE}\" STREQUAL \"RelWithDebInfo\")\n  list(APPEND ZIG_BUILD_ARGS -Doptimize=ReleaseFast)\nelse()\n  list(APPEND ZIG_BUILD_ARGS -Doptimize=ReleaseFast -Dstrip)\nendif()\n\nif(ZIG_STATIC AND NOT MSVC)\n  list(APPEND ZIG_BUILD_ARGS -Duse-zig-libcxx)\nendif()\n\nif(ZIG_NO_LIB)\n  list(APPEND ZIG_BUILD_ARGS -Dno-lib)\nendif()\n\nif(ZIG_SINGLE_THREADED)\n  list(APPEND ZIG_BUILD_ARGS -Dsingle-threaded)\nendif()\n\nif(ZIG_PIE)\n  list(APPEND ZIG_BUILD_ARGS -Dpie)\nendif()\n\nif(NOT \"${ZIG_TARGET_DYNAMIC_LINKER}\" STREQUAL \"\")\n  list(APPEND ZIG_BUILD_ARGS \"-Ddynamic-linker=${ZIG_TARGET_DYNAMIC_LINKER}\")\nendif()\n\nif(MINGW AND \"${ZIG_HOST_TARGET_ARCH}\" STREQUAL \"x86\")\n  list(APPEND ZIG_BUILD_ARGS --maxrss 7000000000)\nendif()\n\n\nadd_custom_target(stage3 ALL\n  DEPENDS \"${PROJECT_BINARY_DIR}/stage3/bin/zig\"\n)\n\nset(ZIG2_WORKING_DIR \"${PROJECT_SOURCE_DIR}\")\n\nadd_custom_command(\n  OUTPUT \"${PROJECT_BINARY_DIR}/stage3/bin/zig\"\n  COMMAND zig2 build --prefix \"${PROJECT_BINARY_DIR}/stage3\" ${ZIG_BUILD_ARGS}\n  COMMENT \"Building stage3\"\n  WORKING_DIRECTORY \"${ZIG2_WORKING_DIR}\"\n)\n\nif(WIN32)\n  set(ZIG_EXECUTABLE \"${PROJECT_BINARY_DIR}/zig2.exe\")\nelse()\n  set(ZIG_EXECUTABLE \"${PROJECT_BINARY_DIR}/zig2\")\nendif()\n\ninstall(CODE \"set(ZIG_EXECUTABLE \\\"${ZIG_EXECUTABLE}\\\")\")\ninstall(CODE \"set(ZIG_BUILD_ARGS \\\"${ZIG_BUILD_ARGS}\\\")\")\ninstall(CODE \"set(ZIG2_WORKING_DIR \\\"${ZIG2_WORKING_DIR}\\\")\")\ninstall(CODE \"set(CMAKE_INSTALL_PREFIX \\\"${CMAKE_INSTALL_PREFIX}\\\")\")\ninstall(SCRIPT cmake/install.cmake)\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.05,
          "content": "The MIT License (Expat)\n\nCopyright (c) Zig contributors\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 5.72,
          "content": "![ZIG](https://ziglang.org/img/zig-logo-dynamic.svg)\n\nA general-purpose programming language and toolchain for maintaining\n**robust**, **optimal**, and **reusable** software.\n\nhttps://ziglang.org/\n\n## Documentation\n\nIf you are looking at this README file in a source tree, please refer to the\n**Release Notes**, **Language Reference**, or **Standard Library\nDocumentation** corresponding to the version of Zig that you are using by\nfollowing the appropriate link on the\n[download page](https://ziglang.org/download).\n\nOtherwise, you're looking at a release of Zig, so you can find the language\nreference at `doc/langref.html`, and the standard library documentation by\nrunning `zig std`, which will open a browser tab.\n\n## Installation\n\n * [download a pre-built binary](https://ziglang.org/download/)\n * [install from a package manager](https://github.com/ziglang/zig/wiki/Install-Zig-from-a-Package-Manager)\n * [bootstrap zig for any target](https://github.com/ziglang/zig-bootstrap)\n\nA Zig installation is composed of two things:\n\n1. The Zig executable\n2. The lib/ directory\n\nAt runtime, the executable searches up the file system for the lib/ directory,\nrelative to itself:\n\n* lib/\n* lib/zig/\n* ../lib/\n* ../lib/zig/\n* (and so on)\n\nIn other words, you can **unpack a release of Zig anywhere**, and then begin\nusing it immediately. There is no need to install it globally, although this\nmechanism supports that use case too (i.e. `/usr/bin/zig` and `/usr/lib/zig/`).\n\n## Building from Source\n\nEnsure you have the required dependencies:\n\n * CMake >= 3.15\n * System C/C++ Toolchain\n * LLVM, Clang, LLD development libraries == 19.x\n\nThen it is the standard CMake build process:\n\n```\nmkdir build\ncd build\ncmake ..\nmake install\n```\n\nFor more options, tips, and troubleshooting, please see the\n[Building Zig From Source](https://github.com/ziglang/zig/wiki/Building-Zig-From-Source)\npage on the wiki.\n\n## Building from Source without LLVM\n\nIn this case, the only system dependency is a C compiler.\n\n```\ncc -o bootstrap bootstrap.c\n./bootstrap\n```\n\nThis produces a `zig2` executable in the current working directory. This is a\n\"stage2\" build of the compiler,\n[without LLVM extensions](https://github.com/ziglang/zig/issues/16270), and is\ntherefore lacking these features:\n- Release mode optimizations\n- [aarch64 machine code backend](https://github.com/ziglang/zig/issues/21172)\n- [@cImport](https://github.com/ziglang/zig/issues/20630)\n- [zig translate-c](https://github.com/ziglang/zig/issues/20875)\n- [Ability to compile assembly files](https://github.com/ziglang/zig/issues/21169)\n- [Some ELF linking features](https://github.com/ziglang/zig/issues/17749)\n- [Most COFF/PE linking features](https://github.com/ziglang/zig/issues/17751)\n- [Some WebAssembly linking features](https://github.com/ziglang/zig/issues/17750)\n- [Ability to create import libs from def files](https://github.com/ziglang/zig/issues/17807)\n- [Ability to create static archives from object files](https://github.com/ziglang/zig/issues/9828)\n- Ability to compile C, C++, Objective-C, and Objective-C++ files\n\nHowever, a compiler built this way does provide a C backend, which may be\nuseful for creating system packages of Zig projects using the system C\ntoolchain. **In this case, LLVM is not needed!**\n\nFurthermore, a compiler built this way provides an LLVM backend that produces\nbitcode files, which may be compiled into object files via a system Clang\npackage. This can be used to produce system packages of Zig applications\nwithout the Zig package dependency on LLVM.\n\n## Contributing\n\n[Donate monthly](https://ziglang.org/zsf/).\n\nZig is Free and Open Source Software. We welcome bug reports and patches from\neveryone. However, keep in mind that Zig governance is BDFN (Benevolent\nDictator For Now) which means that Andrew Kelley has final say on the design\nand implementation of everything.\n\nOne of the best ways you can contribute to Zig is to start using it for an\nopen-source personal project.\n\nThis leads to discovering bugs and helps flesh out use cases, which lead to\nfurther design iterations of Zig. Importantly, each issue found this way comes\nwith real world motivations, making it straightforward to explain the reasoning\nbehind proposals and feature requests.\n\nYou will be taken much more seriously on the issue tracker if you have a\npersonal project that uses Zig.\n\nThe issue label\n[Contributor Friendly](https://github.com/ziglang/zig/issues?q=is%3Aissue+is%3Aopen+label%3A%22contributor+friendly%22)\nexists to help you find issues that are **limited in scope and/or knowledge of\nZig internals.**\n\nPlease note that issues labeled\n[Proposal](https://github.com/ziglang/zig/issues?q=is%3Aissue+is%3Aopen+label%3Aproposal)\nbut do not also have the\n[Accepted](https://github.com/ziglang/zig/issues?q=is%3Aissue+is%3Aopen+label%3Aaccepted)\nlabel are still under consideration, and efforts to implement such a proposal\nhave a high risk of being wasted. If you are interested in a proposal which is\nstill under consideration, please express your interest in the issue tracker,\nproviding extra insights and considerations that others have not yet expressed.\nThe most highly regarded argument in such a discussion is a real world use case.\n\nFor more tips, please see the\n[Contributing](https://github.com/ziglang/zig/wiki/Contributing) page on the\nwiki.\n\n## Community\n\nThe Zig community is decentralized. Anyone is free to start and maintain their\nown space for Zig users to gather. There is no concept of \"official\" or\n\"unofficial\". Each gathering place has its own moderators and rules. Users are\nencouraged to be aware of the social structures of the spaces they inhabit, and\nwork purposefully to facilitate spaces that align with their values.\n\nPlease see the [Community](https://github.com/ziglang/zig/wiki/Community) wiki\npage for a public listing of social spaces.\n"
        },
        {
          "name": "bootstrap.c",
          "type": "blob",
          "size": 5.34,
          "content": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\nstatic const char *get_c_compiler(void) {\n    const char *cc = getenv(\"CC\");\n    return (cc == NULL) ? \"cc\" : cc;\n}\n\nstatic void panic(const char *reason) {\n    fprintf(stderr, \"%s\\n\", reason);\n    abort();\n}\n\n#if defined(__WIN32__)\n#error TODO write the functionality for executing child process into this build script\n#else\n\n#include <unistd.h>\n#include <errno.h>\n#include <sys/wait.h>\n\nstatic void run(char **argv) {\n    pid_t pid = fork();\n    if (pid == -1)\n        panic(\"fork failed\");\n    if (pid == 0) {\n        // child\n        execvp(argv[0], argv);\n        exit(1);\n    }\n\n    // parent\n\n    int status;\n    waitpid(pid, &status, 0);\n\n    if (!WIFEXITED(status))\n        panic(\"child process crashed\");\n\n    if (WEXITSTATUS(status) != 0)\n        panic(\"child process failed\");\n}\n#endif\n\nstatic void print_and_run(const char **argv) {\n    fprintf(stderr, \"%s\", argv[0]);\n    for (const char **arg = argv + 1; *arg; arg += 1) {\n        fprintf(stderr, \" %s\", *arg);\n    }\n    fprintf(stderr, \"\\n\");\n    run((char **)argv);\n}\n\nstatic const char *get_host_os(void) {\n    const char *host_os = getenv(\"ZIG_HOST_TARGET_OS\");\n    if (host_os != NULL) return host_os;\n#if defined(__WIN32__)\n    return \"windows\";\n#elif defined(__APPLE__)\n    return \"macos\";\n#elif defined(__linux__)\n    return \"linux\";\n#elif defined(__FreeBSD__)\n    return \"freebsd\";\n#elif defined(__HAIKU__)\n    return \"haiku\";\n#else\n    panic(\"unknown host os, specify with ZIG_HOST_TARGET_OS\");\n#endif\n}\n\nstatic const char *get_host_arch(void) {\n    const char *host_arch = getenv(\"ZIG_HOST_TARGET_ARCH\");\n    if (host_arch != NULL) return host_arch;\n#if defined(__x86_64__ )\n    return \"x86_64\";\n#elif defined(__aarch64__)\n    return \"aarch64\";\n#else\n    panic(\"unknown host arch, specify with ZIG_HOST_TARGET_ARCH\");\n#endif\n}\n\nstatic const char *get_host_abi(void) {\n    const char *host_abi = getenv(\"ZIG_HOST_TARGET_ABI\");\n    return (host_abi == NULL) ? \"\" : host_abi;\n}\n\nstatic const char *get_host_triple(void) {\n    const char *host_triple = getenv(\"ZIG_HOST_TARGET_TRIPLE\");\n    if (host_triple != NULL) return host_triple;\n    static char global_buffer[100];\n    sprintf(global_buffer, \"%s-%s%s\", get_host_arch(), get_host_os(), get_host_abi());\n    return global_buffer;\n}\n\nint main(int argc, char **argv) {\n    const char *cc = get_c_compiler();\n    const char *host_triple = get_host_triple();\n\n    {\n        const char *child_argv[] = {\n            cc, \"-o\", \"zig-wasm2c\", \"stage1/wasm2c.c\", \"-O2\", \"-std=c99\", NULL,\n        };\n        print_and_run(child_argv);\n    }\n    {\n        const char *child_argv[] = {\n            \"./zig-wasm2c\", \"stage1/zig1.wasm\", \"zig1.c\", NULL,\n        };\n        print_and_run(child_argv);\n    }\n    {\n        const char *child_argv[] = {\n            cc, \"-o\", \"zig1\", \"zig1.c\", \"stage1/wasi.c\", \"-std=c99\", \"-Os\", \"-lm\", NULL,\n        };\n        print_and_run(child_argv);\n    }\n    {\n        FILE *f = fopen(\"config.zig\", \"wb\");\n        if (f == NULL)\n            panic(\"unable to open config.zig for writing\");\n\n        const char *zig_version = \"0.14.0-dev.bootstrap\";\n\n        int written = fprintf(f,\n            \"pub const have_llvm = false;\\n\"\n            \"pub const llvm_has_m68k = false;\\n\"\n            \"pub const llvm_has_csky = false;\\n\"\n            \"pub const llvm_has_arc = false;\\n\"\n            \"pub const llvm_has_xtensa = false;\\n\"\n            \"pub const version: [:0]const u8 = \\\"%s\\\";\\n\"\n            \"pub const semver = @import(\\\"std\\\").SemanticVersion.parse(version) catch unreachable;\\n\"\n            \"pub const enable_debug_extensions = false;\\n\"\n            \"pub const enable_logging = false;\\n\"\n            \"pub const enable_link_snapshots = false;\\n\"\n            \"pub const enable_tracy = false;\\n\"\n            \"pub const value_tracing = false;\\n\"\n            \"pub const skip_non_native = false;\\n\"\n            \"pub const force_gpa = false;\\n\"\n            \"pub const dev = .core;\\n\"\n        , zig_version);\n        if (written < 100)\n            panic(\"unable to write to config.zig file\");\n        if (fclose(f) != 0)\n            panic(\"unable to finish writing to config.zig file\");\n    }\n\n    {\n        const char *child_argv[] = {\n            \"./zig1\", \"lib\", \"build-exe\",\n            \"-ofmt=c\", \"-lc\", \"-OReleaseSmall\",\n            \"--name\", \"zig2\", \"-femit-bin=zig2.c\",\n            \"-target\", host_triple,\n            \"--dep\", \"build_options\",\n            \"--dep\", \"aro\",\n            \"-Mroot=src/main.zig\",\n            \"-Mbuild_options=config.zig\",\n            \"-Maro=lib/compiler/aro/aro.zig\",\n            NULL,\n        };\n        print_and_run(child_argv);\n    }\n\n    {\n        const char *child_argv[] = {\n            \"./zig1\", \"lib\", \"build-obj\",\n            \"-ofmt=c\", \"-OReleaseSmall\",\n            \"--name\", \"compiler_rt\", \"-femit-bin=compiler_rt.c\",\n            \"-target\", host_triple,\n            \"-Mroot=lib/compiler_rt.zig\",\n            NULL,\n        };\n        print_and_run(child_argv);\n    }\n\n    {\n        const char *child_argv[] = {\n            cc, \"-o\", \"zig2\", \"zig2.c\", \"compiler_rt.c\",\n            \"-std=c99\", \"-O2\", \"-fno-stack-protector\",\n            \"-Istage1\",\n#if defined(__APPLE__)\n            \"-Wl,-stack_size,0x10000000\",\n#else\n            \"-Wl,-z,stack-size=0x10000000\",\n#endif\n#if defined(__GNUC__)\n            \"-pthread\",\n#endif\n            NULL,\n        };\n        print_and_run(child_argv);\n    }\n}\n"
        },
        {
          "name": "build.zig",
          "type": "blob",
          "size": 52.1,
          "content": "const std = @import(\"std\");\nconst builtin = std.builtin;\nconst tests = @import(\"test/tests.zig\");\nconst BufMap = std.BufMap;\nconst mem = std.mem;\nconst ArrayList = std.ArrayList;\nconst io = std.io;\nconst fs = std.fs;\nconst InstallDirectoryOptions = std.Build.InstallDirectoryOptions;\nconst assert = std.debug.assert;\nconst DevEnv = @import(\"src/dev.zig\").Env;\n\nconst zig_version: std.SemanticVersion = .{ .major = 0, .minor = 14, .patch = 0 };\nconst stack_size = 46 * 1024 * 1024;\n\npub fn build(b: *std.Build) !void {\n    const only_c = b.option(bool, \"only-c\", \"Translate the Zig compiler to C code, with only the C backend enabled\") orelse false;\n    const target = t: {\n        var default_target: std.Target.Query = .{};\n        default_target.ofmt = b.option(std.Target.ObjectFormat, \"ofmt\", \"Object format to target\") orelse if (only_c) .c else null;\n        break :t b.standardTargetOptions(.{ .default_target = default_target });\n    };\n\n    const optimize = b.standardOptimizeOption(.{});\n\n    const flat = b.option(bool, \"flat\", \"Put files into the installation prefix in a manner suited for upstream distribution rather than a posix file system hierarchy standard\") orelse false;\n    const single_threaded = b.option(bool, \"single-threaded\", \"Build artifacts that run in single threaded mode\");\n    const use_zig_libcxx = b.option(bool, \"use-zig-libcxx\", \"If libc++ is needed, use zig's bundled version, don't try to integrate with the system\") orelse false;\n\n    const test_step = b.step(\"test\", \"Run all the tests\");\n    const skip_install_lib_files = b.option(bool, \"no-lib\", \"skip copying of lib/ files and langref to installation prefix. Useful for development\") orelse false;\n    const skip_install_langref = b.option(bool, \"no-langref\", \"skip copying of langref to the installation prefix\") orelse skip_install_lib_files;\n    const std_docs = b.option(bool, \"std-docs\", \"include standard library autodocs\") orelse false;\n    const no_bin = b.option(bool, \"no-bin\", \"skip emitting compiler binary\") orelse false;\n    const enable_superhtml = b.option(bool, \"enable-superhtml\", \"Check langref output HTML validity\") orelse false;\n\n    const langref_file = generateLangRef(b);\n    const install_langref = b.addInstallFileWithDir(langref_file, .prefix, \"doc/langref.html\");\n    const check_langref = superHtmlCheck(b, langref_file);\n    if (enable_superhtml) install_langref.step.dependOn(check_langref);\n\n    const check_autodocs = superHtmlCheck(b, b.path(\"lib/docs/index.html\"));\n    if (enable_superhtml) {\n        test_step.dependOn(check_langref);\n        test_step.dependOn(check_autodocs);\n    }\n    if (!skip_install_langref) {\n        b.getInstallStep().dependOn(&install_langref.step);\n    }\n\n    const autodoc_test = b.addObject(.{\n        .name = \"std\",\n        .zig_lib_dir = b.path(\"lib\"),\n        .root_module = b.createModule(.{\n            .root_source_file = b.path(\"lib/std/std.zig\"),\n            .target = target,\n            .optimize = .Debug,\n        }),\n    });\n    const install_std_docs = b.addInstallDirectory(.{\n        .source_dir = autodoc_test.getEmittedDocs(),\n        .install_dir = .prefix,\n        .install_subdir = \"doc/std\",\n    });\n    //if (enable_tidy) install_std_docs.step.dependOn(check_autodocs);\n    if (std_docs) {\n        b.getInstallStep().dependOn(&install_std_docs.step);\n    }\n\n    if (flat) {\n        b.installFile(\"LICENSE\", \"LICENSE\");\n        b.installFile(\"README.md\", \"README.md\");\n    }\n\n    const langref_step = b.step(\"langref\", \"Build and install the language reference\");\n    langref_step.dependOn(&install_langref.step);\n\n    const std_docs_step = b.step(\"std-docs\", \"Build and install the standard library documentation\");\n    std_docs_step.dependOn(&install_std_docs.step);\n\n    const docs_step = b.step(\"docs\", \"Build and install documentation\");\n    docs_step.dependOn(langref_step);\n    docs_step.dependOn(std_docs_step);\n\n    const skip_debug = b.option(bool, \"skip-debug\", \"Main test suite skips debug builds\") orelse false;\n    const skip_release = b.option(bool, \"skip-release\", \"Main test suite skips release builds\") orelse false;\n    const skip_release_small = b.option(bool, \"skip-release-small\", \"Main test suite skips release-small builds\") orelse skip_release;\n    const skip_release_fast = b.option(bool, \"skip-release-fast\", \"Main test suite skips release-fast builds\") orelse skip_release;\n    const skip_release_safe = b.option(bool, \"skip-release-safe\", \"Main test suite skips release-safe builds\") orelse skip_release;\n    const skip_non_native = b.option(bool, \"skip-non-native\", \"Main test suite skips non-native builds\") orelse false;\n    const skip_libc = b.option(bool, \"skip-libc\", \"Main test suite skips tests that link libc\") orelse false;\n    const skip_single_threaded = b.option(bool, \"skip-single-threaded\", \"Main test suite skips tests that are single-threaded\") orelse false;\n    const skip_translate_c = b.option(bool, \"skip-translate-c\", \"Main test suite skips translate-c tests\") orelse false;\n    const skip_run_translated_c = b.option(bool, \"skip-run-translated-c\", \"Main test suite skips run-translated-c tests\") orelse false;\n\n    const only_install_lib_files = b.option(bool, \"lib-files-only\", \"Only install library files\") orelse false;\n\n    const static_llvm = b.option(bool, \"static-llvm\", \"Disable integration with system-installed LLVM, Clang, LLD, and libc++\") orelse false;\n    const enable_llvm = b.option(bool, \"enable-llvm\", \"Build self-hosted compiler with LLVM backend enabled\") orelse static_llvm;\n    const llvm_has_m68k = b.option(\n        bool,\n        \"llvm-has-m68k\",\n        \"Whether LLVM has the experimental target m68k enabled\",\n    ) orelse false;\n    const llvm_has_csky = b.option(\n        bool,\n        \"llvm-has-csky\",\n        \"Whether LLVM has the experimental target csky enabled\",\n    ) orelse false;\n    const llvm_has_arc = b.option(\n        bool,\n        \"llvm-has-arc\",\n        \"Whether LLVM has the experimental target arc enabled\",\n    ) orelse false;\n    const llvm_has_xtensa = b.option(\n        bool,\n        \"llvm-has-xtensa\",\n        \"Whether LLVM has the experimental target xtensa enabled\",\n    ) orelse false;\n    const enable_ios_sdk = b.option(bool, \"enable-ios-sdk\", \"Run tests requiring presence of iOS SDK and frameworks\") orelse false;\n    const enable_macos_sdk = b.option(bool, \"enable-macos-sdk\", \"Run tests requiring presence of macOS SDK and frameworks\") orelse enable_ios_sdk;\n    const enable_symlinks_windows = b.option(bool, \"enable-symlinks-windows\", \"Run tests requiring presence of symlinks on Windows\") orelse false;\n    const config_h_path_option = b.option([]const u8, \"config_h\", \"Path to the generated config.h\");\n\n    if (!skip_install_lib_files) {\n        b.installDirectory(.{\n            .source_dir = b.path(\"lib\"),\n            .install_dir = if (flat) .prefix else .lib,\n            .install_subdir = if (flat) \"lib\" else \"zig\",\n            .exclude_extensions = &[_][]const u8{\n                // exclude files from lib/std/compress/testdata\n                \".gz\",\n                \".z.0\",\n                \".z.9\",\n                \".zst.3\",\n                \".zst.19\",\n                \"rfc1951.txt\",\n                \"rfc1952.txt\",\n                \"rfc8478.txt\",\n                // exclude files from lib/std/compress/flate/testdata\n                \".expect\",\n                \".expect-noinput\",\n                \".golden\",\n                \".input\",\n                \"compress-e.txt\",\n                \"compress-gettysburg.txt\",\n                \"compress-pi.txt\",\n                \"rfc1951.txt\",\n                // exclude files from lib/std/compress/lzma/testdata\n                \".lzma\",\n                // exclude files from lib/std/compress/xz/testdata\n                \".xz\",\n                // exclude files from lib/std/tz/\n                \".tzif\",\n                // exclude files from lib/std/tar/testdata\n                \".tar\",\n                // others\n                \"README.md\",\n            },\n            .blank_extensions = &[_][]const u8{\n                \"test.zig\",\n            },\n        });\n    }\n\n    if (only_install_lib_files)\n        return;\n\n    const entitlements = b.option([]const u8, \"entitlements\", \"Path to entitlements file for hot-code swapping without sudo on macOS\");\n    const tracy = b.option([]const u8, \"tracy\", \"Enable Tracy integration. Supply path to Tracy source\");\n    const tracy_callstack = b.option(bool, \"tracy-callstack\", \"Include callstack information with Tracy data. Does nothing if -Dtracy is not provided\") orelse (tracy != null);\n    const tracy_allocation = b.option(bool, \"tracy-allocation\", \"Include allocation information with Tracy data. Does nothing if -Dtracy is not provided\") orelse (tracy != null);\n    const tracy_callstack_depth: u32 = b.option(u32, \"tracy-callstack-depth\", \"Declare callstack depth for Tracy data. Does nothing if -Dtracy_callstack is not provided\") orelse 10;\n    const force_gpa = b.option(bool, \"force-gpa\", \"Force the compiler to use GeneralPurposeAllocator\") orelse false;\n    const link_libc = b.option(bool, \"force-link-libc\", \"Force self-hosted compiler to link libc\") orelse (enable_llvm or only_c);\n    const sanitize_thread = b.option(bool, \"sanitize-thread\", \"Enable thread-sanitization\") orelse false;\n    const strip = b.option(bool, \"strip\", \"Omit debug information\");\n    const valgrind = b.option(bool, \"valgrind\", \"Enable valgrind integration\");\n    const pie = b.option(bool, \"pie\", \"Produce a Position Independent Executable\");\n    const value_tracing = b.option(bool, \"value-tracing\", \"Enable extra state tracking to help troubleshoot bugs in the compiler (using the std.debug.Trace API)\") orelse false;\n\n    const mem_leak_frames: u32 = b.option(u32, \"mem-leak-frames\", \"How many stack frames to print when a memory leak occurs. Tests get 2x this amount.\") orelse blk: {\n        if (strip == true) break :blk @as(u32, 0);\n        if (optimize != .Debug) break :blk 0;\n        break :blk 4;\n    };\n\n    const exe = addCompilerStep(b, .{\n        .optimize = optimize,\n        .target = target,\n        .strip = strip,\n        .valgrind = valgrind,\n        .sanitize_thread = sanitize_thread,\n        .single_threaded = single_threaded,\n    });\n    exe.pie = pie;\n    exe.entitlements = entitlements;\n\n    exe.build_id = b.option(\n        std.zig.BuildId,\n        \"build-id\",\n        \"Request creation of '.note.gnu.build-id' section\",\n    );\n\n    if (no_bin) {\n        b.getInstallStep().dependOn(&exe.step);\n    } else {\n        const install_exe = b.addInstallArtifact(exe, .{\n            .dest_dir = if (flat) .{ .override = .prefix } else .default,\n        });\n        b.getInstallStep().dependOn(&install_exe.step);\n    }\n\n    test_step.dependOn(&exe.step);\n\n    if (target.result.os.tag == .windows and target.result.abi == .gnu) {\n        // LTO is currently broken on mingw, this can be removed when it's fixed.\n        exe.want_lto = false;\n    }\n\n    const use_llvm = b.option(bool, \"use-llvm\", \"Use the llvm backend\");\n    exe.use_llvm = use_llvm;\n    exe.use_lld = use_llvm;\n\n    const exe_options = b.addOptions();\n    exe.root_module.addOptions(\"build_options\", exe_options);\n\n    exe_options.addOption(u32, \"mem_leak_frames\", mem_leak_frames);\n    exe_options.addOption(bool, \"skip_non_native\", skip_non_native);\n    exe_options.addOption(bool, \"have_llvm\", enable_llvm);\n    exe_options.addOption(bool, \"llvm_has_m68k\", llvm_has_m68k);\n    exe_options.addOption(bool, \"llvm_has_csky\", llvm_has_csky);\n    exe_options.addOption(bool, \"llvm_has_arc\", llvm_has_arc);\n    exe_options.addOption(bool, \"llvm_has_xtensa\", llvm_has_xtensa);\n    exe_options.addOption(bool, \"force_gpa\", force_gpa);\n    exe_options.addOption(DevEnv, \"dev\", b.option(DevEnv, \"dev\", \"Build a compiler with a reduced feature set for development of specific features\") orelse if (only_c) .bootstrap else .full);\n\n    if (link_libc) {\n        exe.root_module.link_libc = true;\n    }\n\n    const is_debug = optimize == .Debug;\n    const enable_debug_extensions = b.option(bool, \"debug-extensions\", \"Enable commands and options useful for debugging the compiler\") orelse is_debug;\n    const enable_logging = b.option(bool, \"log\", \"Enable debug logging with --debug-log\") orelse is_debug;\n    const enable_link_snapshots = b.option(bool, \"link-snapshot\", \"Whether to enable linker state snapshots\") orelse false;\n\n    const opt_version_string = b.option([]const u8, \"version-string\", \"Override Zig version string. Default is to find out with git.\");\n    const version_slice = if (opt_version_string) |version| version else v: {\n        if (!std.process.can_spawn) {\n            std.debug.print(\"error: version info cannot be retrieved from git. Zig version must be provided using -Dversion-string\\n\", .{});\n            std.process.exit(1);\n        }\n        const version_string = b.fmt(\"{d}.{d}.{d}\", .{ zig_version.major, zig_version.minor, zig_version.patch });\n\n        var code: u8 = undefined;\n        const git_describe_untrimmed = b.runAllowFail(&[_][]const u8{\n            \"git\",\n            \"-C\",\n            b.build_root.path orelse \".\",\n            \"describe\",\n            \"--match\",\n            \"*.*.*\",\n            \"--tags\",\n            \"--abbrev=9\",\n        }, &code, .Ignore) catch {\n            break :v version_string;\n        };\n        const git_describe = mem.trim(u8, git_describe_untrimmed, \" \\n\\r\");\n\n        switch (mem.count(u8, git_describe, \"-\")) {\n            0 => {\n                // Tagged release version (e.g. 0.10.0).\n                if (!mem.eql(u8, git_describe, version_string)) {\n                    std.debug.print(\"Zig version '{s}' does not match Git tag '{s}'\\n\", .{ version_string, git_describe });\n                    std.process.exit(1);\n                }\n                break :v version_string;\n            },\n            2 => {\n                // Untagged development build (e.g. 0.10.0-dev.2025+ecf0050a9).\n                var it = mem.splitScalar(u8, git_describe, '-');\n                const tagged_ancestor = it.first();\n                const commit_height = it.next().?;\n                const commit_id = it.next().?;\n\n                const ancestor_ver = try std.SemanticVersion.parse(tagged_ancestor);\n                if (zig_version.order(ancestor_ver) != .gt) {\n                    std.debug.print(\"Zig version '{}' must be greater than tagged ancestor '{}'\\n\", .{ zig_version, ancestor_ver });\n                    std.process.exit(1);\n                }\n\n                // Check that the commit hash is prefixed with a 'g' (a Git convention).\n                if (commit_id.len < 1 or commit_id[0] != 'g') {\n                    std.debug.print(\"Unexpected `git describe` output: {s}\\n\", .{git_describe});\n                    break :v version_string;\n                }\n\n                // The version is reformatted in accordance with the https://semver.org specification.\n                break :v b.fmt(\"{s}-dev.{s}+{s}\", .{ version_string, commit_height, commit_id[1..] });\n            },\n            else => {\n                std.debug.print(\"Unexpected `git describe` output: {s}\\n\", .{git_describe});\n                break :v version_string;\n            },\n        }\n    };\n    const version = try b.allocator.dupeZ(u8, version_slice);\n    exe_options.addOption([:0]const u8, \"version\", version);\n\n    if (enable_llvm) {\n        const cmake_cfg = if (static_llvm) null else blk: {\n            if (findConfigH(b, config_h_path_option)) |config_h_path| {\n                const file_contents = fs.cwd().readFileAlloc(b.allocator, config_h_path, max_config_h_bytes) catch unreachable;\n                break :blk parseConfigH(b, file_contents);\n            } else {\n                std.log.warn(\"config.h could not be located automatically. Consider providing it explicitly via \\\"-Dconfig_h\\\"\", .{});\n                break :blk null;\n            }\n        };\n\n        if (cmake_cfg) |cfg| {\n            // Inside this code path, we have to coordinate with system packaged LLVM, Clang, and LLD.\n            // That means we also have to rely on stage1 compiled c++ files. We parse config.h to find\n            // the information passed on to us from cmake.\n            if (cfg.cmake_prefix_path.len > 0) {\n                var it = mem.tokenizeScalar(u8, cfg.cmake_prefix_path, ';');\n                while (it.next()) |path| {\n                    b.addSearchPrefix(path);\n                }\n            }\n\n            try addCmakeCfgOptionsToExe(b, cfg, exe, use_zig_libcxx);\n        } else {\n            // Here we are -Denable-llvm but no cmake integration.\n            try addStaticLlvmOptionsToModule(exe.root_module);\n        }\n        if (target.result.os.tag == .windows) {\n            // LLVM depends on networking as of version 18.\n            exe.root_module.linkSystemLibrary(\"ws2_32\", .{});\n\n            exe.root_module.linkSystemLibrary(\"version\", .{});\n            exe.root_module.linkSystemLibrary(\"uuid\", .{});\n            exe.root_module.linkSystemLibrary(\"ole32\", .{});\n        }\n    }\n\n    const semver = try std.SemanticVersion.parse(version);\n    exe_options.addOption(std.SemanticVersion, \"semver\", semver);\n\n    exe_options.addOption(bool, \"enable_debug_extensions\", enable_debug_extensions);\n    exe_options.addOption(bool, \"enable_logging\", enable_logging);\n    exe_options.addOption(bool, \"enable_link_snapshots\", enable_link_snapshots);\n    exe_options.addOption(bool, \"enable_tracy\", tracy != null);\n    exe_options.addOption(bool, \"enable_tracy_callstack\", tracy_callstack);\n    exe_options.addOption(bool, \"enable_tracy_allocation\", tracy_allocation);\n    exe_options.addOption(u32, \"tracy_callstack_depth\", tracy_callstack_depth);\n    exe_options.addOption(bool, \"value_tracing\", value_tracing);\n    if (tracy) |tracy_path| {\n        const client_cpp = b.pathJoin(\n            &[_][]const u8{ tracy_path, \"public\", \"TracyClient.cpp\" },\n        );\n\n        // On mingw, we need to opt into windows 7+ to get some features required by tracy.\n        const tracy_c_flags: []const []const u8 = if (target.result.os.tag == .windows and target.result.abi == .gnu)\n            &[_][]const u8{ \"-DTRACY_ENABLE=1\", \"-fno-sanitize=undefined\", \"-D_WIN32_WINNT=0x601\" }\n        else\n            &[_][]const u8{ \"-DTRACY_ENABLE=1\", \"-fno-sanitize=undefined\" };\n\n        exe.root_module.addIncludePath(.{ .cwd_relative = tracy_path });\n        exe.root_module.addCSourceFile(.{ .file = .{ .cwd_relative = client_cpp }, .flags = tracy_c_flags });\n        if (!enable_llvm) {\n            exe.root_module.linkSystemLibrary(\"c++\", .{ .use_pkg_config = .no });\n        }\n        exe.root_module.link_libc = true;\n\n        if (target.result.os.tag == .windows) {\n            exe.root_module.linkSystemLibrary(\"dbghelp\", .{});\n            exe.root_module.linkSystemLibrary(\"ws2_32\", .{});\n        }\n    }\n\n    const test_filters = b.option([]const []const u8, \"test-filter\", \"Skip tests that do not match any filter\") orelse &[0][]const u8{};\n    const test_target_filters = b.option([]const []const u8, \"test-target-filter\", \"Skip tests whose target triple do not match any filter\") orelse &[0][]const u8{};\n    const test_slow_targets = b.option(bool, \"test-slow-targets\", \"Enable running module tests for targets that have a slow compiler backend\") orelse false;\n\n    var chosen_opt_modes_buf: [4]builtin.OptimizeMode = undefined;\n    var chosen_mode_index: usize = 0;\n    if (!skip_debug) {\n        chosen_opt_modes_buf[chosen_mode_index] = builtin.OptimizeMode.Debug;\n        chosen_mode_index += 1;\n    }\n    if (!skip_release_safe) {\n        chosen_opt_modes_buf[chosen_mode_index] = builtin.OptimizeMode.ReleaseSafe;\n        chosen_mode_index += 1;\n    }\n    if (!skip_release_fast) {\n        chosen_opt_modes_buf[chosen_mode_index] = builtin.OptimizeMode.ReleaseFast;\n        chosen_mode_index += 1;\n    }\n    if (!skip_release_small) {\n        chosen_opt_modes_buf[chosen_mode_index] = builtin.OptimizeMode.ReleaseSmall;\n        chosen_mode_index += 1;\n    }\n    const optimization_modes = chosen_opt_modes_buf[0..chosen_mode_index];\n\n    const fmt_include_paths = &.{ \"lib\", \"src\", \"test\", \"tools\", \"build.zig\", \"build.zig.zon\" };\n    const fmt_exclude_paths = &.{\"test/cases\"};\n    const do_fmt = b.addFmt(.{\n        .paths = fmt_include_paths,\n        .exclude_paths = fmt_exclude_paths,\n    });\n    b.step(\"fmt\", \"Modify source files in place to have conforming formatting\").dependOn(&do_fmt.step);\n\n    const check_fmt = b.step(\"test-fmt\", \"Check source files having conforming formatting\");\n    check_fmt.dependOn(&b.addFmt(.{\n        .paths = fmt_include_paths,\n        .exclude_paths = fmt_exclude_paths,\n        .check = true,\n    }).step);\n    test_step.dependOn(check_fmt);\n\n    const test_cases_step = b.step(\"test-cases\", \"Run the main compiler test cases\");\n    try tests.addCases(b, test_cases_step, test_filters, test_target_filters, target, .{\n        .skip_translate_c = skip_translate_c,\n        .skip_run_translated_c = skip_run_translated_c,\n    }, .{\n        .enable_llvm = enable_llvm,\n        .llvm_has_m68k = llvm_has_m68k,\n        .llvm_has_csky = llvm_has_csky,\n        .llvm_has_arc = llvm_has_arc,\n        .llvm_has_xtensa = llvm_has_xtensa,\n    });\n    test_step.dependOn(test_cases_step);\n\n    const test_modules_step = b.step(\"test-modules\", \"Run the per-target module tests\");\n    test_step.dependOn(test_modules_step);\n\n    test_modules_step.dependOn(tests.addModuleTests(b, .{\n        .test_filters = test_filters,\n        .test_target_filters = test_target_filters,\n        .test_slow_targets = test_slow_targets,\n        .root_src = \"test/behavior.zig\",\n        .name = \"behavior\",\n        .desc = \"Run the behavior tests\",\n        .optimize_modes = optimization_modes,\n        .include_paths = &.{},\n        .skip_single_threaded = skip_single_threaded,\n        .skip_non_native = skip_non_native,\n        .skip_libc = skip_libc,\n        .max_rss = 1 * 1024 * 1024 * 1024,\n    }));\n\n    test_modules_step.dependOn(tests.addModuleTests(b, .{\n        .test_filters = test_filters,\n        .test_target_filters = test_target_filters,\n        .test_slow_targets = test_slow_targets,\n        .root_src = \"test/c_import.zig\",\n        .name = \"c-import\",\n        .desc = \"Run the @cImport tests\",\n        .optimize_modes = optimization_modes,\n        .include_paths = &.{\"test/c_import\"},\n        .skip_single_threaded = true,\n        .skip_non_native = skip_non_native,\n        .skip_libc = skip_libc,\n    }));\n\n    test_modules_step.dependOn(tests.addModuleTests(b, .{\n        .test_filters = test_filters,\n        .test_target_filters = test_target_filters,\n        .test_slow_targets = test_slow_targets,\n        .root_src = \"lib/compiler_rt.zig\",\n        .name = \"compiler-rt\",\n        .desc = \"Run the compiler_rt tests\",\n        .optimize_modes = optimization_modes,\n        .include_paths = &.{},\n        .skip_single_threaded = true,\n        .skip_non_native = skip_non_native,\n        .skip_libc = true,\n        .no_builtin = true,\n    }));\n\n    test_modules_step.dependOn(tests.addModuleTests(b, .{\n        .test_filters = test_filters,\n        .test_target_filters = test_target_filters,\n        .test_slow_targets = test_slow_targets,\n        .root_src = \"lib/c.zig\",\n        .name = \"universal-libc\",\n        .desc = \"Run the universal libc tests\",\n        .optimize_modes = optimization_modes,\n        .include_paths = &.{},\n        .skip_single_threaded = true,\n        .skip_non_native = skip_non_native,\n        .skip_libc = true,\n        .no_builtin = true,\n    }));\n\n    test_modules_step.dependOn(tests.addModuleTests(b, .{\n        .test_filters = test_filters,\n        .test_target_filters = test_target_filters,\n        .test_slow_targets = test_slow_targets,\n        .root_src = \"lib/std/std.zig\",\n        .name = \"std\",\n        .desc = \"Run the standard library tests\",\n        .optimize_modes = optimization_modes,\n        .include_paths = &.{},\n        .skip_single_threaded = skip_single_threaded,\n        .skip_non_native = skip_non_native,\n        .skip_libc = skip_libc,\n        // I observed a value of 4572626944 on the M2 CI.\n        .max_rss = 5029889638,\n    }));\n\n    const unit_tests_step = b.step(\"test-unit\", \"Run the compiler source unit tests\");\n    test_step.dependOn(unit_tests_step);\n\n    const unit_tests = b.addTest(.{\n        .root_module = b.createModule(.{\n            .root_source_file = b.path(\"src/main.zig\"),\n            .optimize = optimize,\n            .target = target,\n            .link_libc = link_libc,\n            .single_threaded = single_threaded,\n        }),\n        .filters = test_filters,\n        .use_llvm = use_llvm,\n        .use_lld = use_llvm,\n        .zig_lib_dir = b.path(\"lib\"),\n    });\n    unit_tests.root_module.addOptions(\"build_options\", exe_options);\n    unit_tests_step.dependOn(&b.addRunArtifact(unit_tests).step);\n\n    test_step.dependOn(tests.addCompareOutputTests(b, test_filters, optimization_modes));\n    test_step.dependOn(tests.addStandaloneTests(\n        b,\n        optimization_modes,\n        enable_macos_sdk,\n        enable_ios_sdk,\n        enable_symlinks_windows,\n    ));\n    test_step.dependOn(tests.addCAbiTests(b, .{\n        .test_target_filters = test_target_filters,\n        .skip_non_native = skip_non_native,\n        .skip_release = skip_release,\n    }));\n    test_step.dependOn(tests.addLinkTests(b, enable_macos_sdk, enable_ios_sdk, enable_symlinks_windows));\n    test_step.dependOn(tests.addStackTraceTests(b, test_filters, optimization_modes));\n    test_step.dependOn(tests.addCliTests(b));\n    test_step.dependOn(tests.addAssembleAndLinkTests(b, test_filters, optimization_modes));\n    if (tests.addDebuggerTests(b, .{\n        .test_filters = test_filters,\n        .test_target_filters = test_target_filters,\n        .gdb = b.option([]const u8, \"gdb\", \"path to gdb binary\"),\n        .lldb = b.option([]const u8, \"lldb\", \"path to lldb binary\"),\n        .optimize_modes = optimization_modes,\n        .skip_single_threaded = skip_single_threaded,\n        .skip_non_native = skip_non_native,\n        .skip_libc = skip_libc,\n    })) |test_debugger_step| test_step.dependOn(test_debugger_step);\n\n    try addWasiUpdateStep(b, version);\n\n    const update_mingw_step = b.step(\"update-mingw\", \"Update zig's bundled mingw\");\n    const opt_mingw_src_path = b.option([]const u8, \"mingw-src\", \"path to mingw-w64 source directory\");\n    if (opt_mingw_src_path) |mingw_src_path| {\n        const update_mingw_exe = b.addExecutable(.{\n            .name = \"update_mingw\",\n            .root_module = b.createModule(.{\n                .target = b.graph.host,\n                .root_source_file = b.path(\"tools/update_mingw.zig\"),\n            }),\n        });\n        const update_mingw_run = b.addRunArtifact(update_mingw_exe);\n        update_mingw_run.addDirectoryArg(b.path(\"lib\"));\n        update_mingw_run.addDirectoryArg(.{ .cwd_relative = mingw_src_path });\n\n        update_mingw_step.dependOn(&update_mingw_run.step);\n    } else {\n        update_mingw_step.dependOn(&b.addFail(\"The -Dmingw-src=... option is required for this step\").step);\n    }\n\n    const test_incremental_step = b.step(\"test-incremental\", \"Run the incremental compilation test cases\");\n    try tests.addIncrementalTests(b, test_incremental_step);\n    test_step.dependOn(test_incremental_step);\n}\n\nfn addWasiUpdateStep(b: *std.Build, version: [:0]const u8) !void {\n    const semver = try std.SemanticVersion.parse(version);\n\n    var target_query: std.Target.Query = .{\n        .cpu_arch = .wasm32,\n        .os_tag = .wasi,\n    };\n    target_query.cpu_features_add.addFeature(@intFromEnum(std.Target.wasm.Feature.bulk_memory));\n\n    const exe = addCompilerStep(b, .{\n        .optimize = .ReleaseSmall,\n        .target = b.resolveTargetQuery(target_query),\n    });\n\n    const exe_options = b.addOptions();\n    exe.root_module.addOptions(\"build_options\", exe_options);\n\n    exe_options.addOption(u32, \"mem_leak_frames\", 0);\n    exe_options.addOption(bool, \"have_llvm\", false);\n    exe_options.addOption(bool, \"force_gpa\", false);\n    exe_options.addOption([:0]const u8, \"version\", version);\n    exe_options.addOption(std.SemanticVersion, \"semver\", semver);\n    exe_options.addOption(bool, \"enable_debug_extensions\", false);\n    exe_options.addOption(bool, \"enable_logging\", false);\n    exe_options.addOption(bool, \"enable_link_snapshots\", false);\n    exe_options.addOption(bool, \"enable_tracy\", false);\n    exe_options.addOption(bool, \"enable_tracy_callstack\", false);\n    exe_options.addOption(bool, \"enable_tracy_allocation\", false);\n    exe_options.addOption(u32, \"tracy_callstack_depth\", 0);\n    exe_options.addOption(bool, \"value_tracing\", false);\n    exe_options.addOption(DevEnv, \"dev\", .bootstrap);\n\n    const run_opt = b.addSystemCommand(&.{\n        \"wasm-opt\",\n        \"-Oz\",\n        \"--enable-bulk-memory\",\n        \"--enable-sign-ext\",\n    });\n    run_opt.addArtifactArg(exe);\n    run_opt.addArg(\"-o\");\n    run_opt.addFileArg(b.path(\"stage1/zig1.wasm\"));\n\n    const copy_zig_h = b.addUpdateSourceFiles();\n    copy_zig_h.addCopyFileToSource(b.path(\"lib/zig.h\"), \"stage1/zig.h\");\n\n    const update_zig1_step = b.step(\"update-zig1\", \"Update stage1/zig1.wasm\");\n    update_zig1_step.dependOn(&run_opt.step);\n    update_zig1_step.dependOn(&copy_zig_h.step);\n}\n\nconst AddCompilerStepOptions = struct {\n    optimize: std.builtin.OptimizeMode,\n    target: std.Build.ResolvedTarget,\n    strip: ?bool = null,\n    valgrind: ?bool = null,\n    sanitize_thread: ?bool = null,\n    single_threaded: ?bool = null,\n};\n\nfn addCompilerStep(b: *std.Build, options: AddCompilerStepOptions) *std.Build.Step.Compile {\n    const compiler_mod = b.createModule(.{\n        .root_source_file = b.path(\"src/main.zig\"),\n        .target = options.target,\n        .optimize = options.optimize,\n        .strip = options.strip,\n        .sanitize_thread = options.sanitize_thread,\n        .single_threaded = options.single_threaded,\n        .code_model = switch (options.target.result.cpu.arch) {\n            // NB:\n            // For loongarch, LLVM supports only small, medium and large\n            // code model. If we don't explicitly specify the code model,\n            // the default value `small' will be used.\n            //\n            // Since zig binary itself is relatively large, using a `small'\n            // code model will cause\n            //\n            // relocation R_LARCH_B26 out of range\n            //\n            // error when linking a loongarch32/loongarch64 zig binary.\n            //\n            // Here we explicitly set code model to `medium' to avoid this\n            // error.\n            .loongarch32, .loongarch64 => .medium,\n            else => .default,\n        },\n        .valgrind = options.valgrind,\n    });\n\n    const aro_mod = b.createModule(.{\n        .root_source_file = b.path(\"lib/compiler/aro/aro.zig\"),\n    });\n\n    const aro_translate_c_mod = b.createModule(.{\n        .root_source_file = b.path(\"lib/compiler/aro_translate_c.zig\"),\n    });\n\n    aro_translate_c_mod.addImport(\"aro\", aro_mod);\n    compiler_mod.addImport(\"aro\", aro_mod);\n    compiler_mod.addImport(\"aro_translate_c\", aro_translate_c_mod);\n\n    const exe = b.addExecutable(.{\n        .name = \"zig\",\n        .max_rss = 7_800_000_000,\n        .root_module = compiler_mod,\n    });\n    exe.stack_size = stack_size;\n\n    return exe;\n}\n\nconst exe_cflags = [_][]const u8{\n    \"-std=c++17\",\n    \"-D__STDC_CONSTANT_MACROS\",\n    \"-D__STDC_FORMAT_MACROS\",\n    \"-D__STDC_LIMIT_MACROS\",\n    \"-D_GNU_SOURCE\",\n    \"-fno-exceptions\",\n    \"-fno-rtti\",\n    \"-fno-stack-protector\",\n    \"-fvisibility-inlines-hidden\",\n    \"-Wno-type-limits\",\n    \"-Wno-missing-braces\",\n    \"-Wno-comment\",\n};\n\nfn addCmakeCfgOptionsToExe(\n    b: *std.Build,\n    cfg: CMakeConfig,\n    exe: *std.Build.Step.Compile,\n    use_zig_libcxx: bool,\n) !void {\n    const mod = exe.root_module;\n    const target = mod.resolved_target.?.result;\n\n    if (target.isDarwin()) {\n        // useful for package maintainers\n        exe.headerpad_max_install_names = true;\n    }\n\n    mod.addObjectFile(.{ .cwd_relative = b.pathJoin(&.{\n        cfg.cmake_binary_dir,\n        \"zigcpp\",\n        b.fmt(\"{s}{s}{s}\", .{\n            cfg.cmake_static_library_prefix,\n            \"zigcpp\",\n            cfg.cmake_static_library_suffix,\n        }),\n    }) });\n    assert(cfg.lld_include_dir.len != 0);\n    mod.addIncludePath(.{ .cwd_relative = cfg.lld_include_dir });\n    mod.addIncludePath(.{ .cwd_relative = cfg.llvm_include_dir });\n    mod.addLibraryPath(.{ .cwd_relative = cfg.llvm_lib_dir });\n    addCMakeLibraryList(mod, cfg.clang_libraries);\n    addCMakeLibraryList(mod, cfg.lld_libraries);\n    addCMakeLibraryList(mod, cfg.llvm_libraries);\n\n    if (use_zig_libcxx) {\n        mod.link_libcpp = true;\n    } else {\n        // System -lc++ must be used because in this code path we are attempting to link\n        // against system-provided LLVM, Clang, LLD.\n        const need_cpp_includes = true;\n        const static = cfg.llvm_linkage == .static;\n        const lib_suffix = if (static) target.staticLibSuffix()[1..] else target.dynamicLibSuffix()[1..];\n        switch (target.os.tag) {\n            .linux => {\n                // First we try to link against the detected libcxx name. If that doesn't work, we fall\n                // back to -lc++ and cross our fingers.\n                addCxxKnownPath(b, cfg, exe, b.fmt(\"lib{s}.{s}\", .{ cfg.system_libcxx, lib_suffix }), \"\", need_cpp_includes) catch |err| switch (err) {\n                    error.RequiredLibraryNotFound => {\n                        mod.link_libcpp = true;\n                    },\n                    else => |e| return e,\n                };\n                mod.linkSystemLibrary(\"unwind\", .{});\n            },\n            .ios, .macos, .watchos, .tvos, .visionos => {\n                mod.link_libcpp = true;\n            },\n            .windows => {\n                if (target.abi != .msvc) mod.link_libcpp = true;\n            },\n            .freebsd => {\n                if (static) {\n                    try addCxxKnownPath(b, cfg, exe, b.fmt(\"libc++.{s}\", .{lib_suffix}), null, need_cpp_includes);\n                    try addCxxKnownPath(b, cfg, exe, b.fmt(\"libgcc_eh.{s}\", .{lib_suffix}), null, need_cpp_includes);\n                } else {\n                    try addCxxKnownPath(b, cfg, exe, b.fmt(\"libc++.{s}\", .{lib_suffix}), null, need_cpp_includes);\n                }\n            },\n            .openbsd => {\n                try addCxxKnownPath(b, cfg, exe, b.fmt(\"libc++.{s}\", .{lib_suffix}), null, need_cpp_includes);\n                try addCxxKnownPath(b, cfg, exe, b.fmt(\"libc++abi.{s}\", .{lib_suffix}), null, need_cpp_includes);\n            },\n            .netbsd, .dragonfly => {\n                if (static) {\n                    try addCxxKnownPath(b, cfg, exe, b.fmt(\"libstdc++.{s}\", .{lib_suffix}), null, need_cpp_includes);\n                    try addCxxKnownPath(b, cfg, exe, b.fmt(\"libgcc_eh.{s}\", .{lib_suffix}), null, need_cpp_includes);\n                } else {\n                    try addCxxKnownPath(b, cfg, exe, b.fmt(\"libstdc++.{s}\", .{lib_suffix}), null, need_cpp_includes);\n                }\n            },\n            .solaris, .illumos => {\n                try addCxxKnownPath(b, cfg, exe, b.fmt(\"libstdc++.{s}\", .{lib_suffix}), null, need_cpp_includes);\n                try addCxxKnownPath(b, cfg, exe, b.fmt(\"libgcc_eh.{s}\", .{lib_suffix}), null, need_cpp_includes);\n            },\n            .haiku => {\n                try addCxxKnownPath(b, cfg, exe, b.fmt(\"libstdc++.{s}\", .{lib_suffix}), null, need_cpp_includes);\n            },\n            else => {},\n        }\n    }\n\n    if (cfg.dia_guids_lib.len != 0) {\n        mod.addObjectFile(.{ .cwd_relative = cfg.dia_guids_lib });\n    }\n}\n\nfn addStaticLlvmOptionsToModule(mod: *std.Build.Module) !void {\n    // Adds the Zig C++ sources which both stage1 and stage2 need.\n    //\n    // We need this because otherwise zig_clang_cc1_main.cpp ends up pulling\n    // in a dependency on llvm::cfg::Update<llvm::BasicBlock*>::dump() which is\n    // unavailable when LLVM is compiled in Release mode.\n    const zig_cpp_cflags = exe_cflags ++ [_][]const u8{\"-DNDEBUG=1\"};\n    mod.addCSourceFiles(.{\n        .files = &zig_cpp_sources,\n        .flags = &zig_cpp_cflags,\n    });\n\n    for (clang_libs) |lib_name| {\n        mod.linkSystemLibrary(lib_name, .{});\n    }\n\n    for (lld_libs) |lib_name| {\n        mod.linkSystemLibrary(lib_name, .{});\n    }\n\n    for (llvm_libs) |lib_name| {\n        mod.linkSystemLibrary(lib_name, .{});\n    }\n\n    mod.linkSystemLibrary(\"z\", .{});\n    mod.linkSystemLibrary(\"zstd\", .{});\n\n    if (mod.resolved_target.?.result.os.tag != .windows or mod.resolved_target.?.result.abi != .msvc) {\n        // This means we rely on clang-or-zig-built LLVM, Clang, LLD libraries.\n        mod.linkSystemLibrary(\"c++\", .{});\n    }\n\n    if (mod.resolved_target.?.result.os.tag == .windows) {\n        mod.linkSystemLibrary(\"version\", .{});\n        mod.linkSystemLibrary(\"uuid\", .{});\n        mod.linkSystemLibrary(\"ole32\", .{});\n    }\n}\n\nfn addCxxKnownPath(\n    b: *std.Build,\n    ctx: CMakeConfig,\n    exe: *std.Build.Step.Compile,\n    objname: []const u8,\n    errtxt: ?[]const u8,\n    need_cpp_includes: bool,\n) !void {\n    if (!std.process.can_spawn)\n        return error.RequiredLibraryNotFound;\n\n    const path_padded = run: {\n        var args = std.ArrayList([]const u8).init(b.allocator);\n        try args.append(ctx.cxx_compiler);\n        var it = std.mem.tokenizeAny(u8, ctx.cxx_compiler_arg1, &std.ascii.whitespace);\n        while (it.next()) |arg| try args.append(arg);\n        try args.append(b.fmt(\"-print-file-name={s}\", .{objname}));\n        break :run b.run(args.items);\n    };\n    var tokenizer = mem.tokenizeAny(u8, path_padded, \"\\r\\n\");\n    const path_unpadded = tokenizer.next().?;\n    if (mem.eql(u8, path_unpadded, objname)) {\n        if (errtxt) |msg| {\n            std.debug.print(\"{s}\", .{msg});\n        } else {\n            std.debug.print(\"Unable to determine path to {s}\\n\", .{objname});\n        }\n        return error.RequiredLibraryNotFound;\n    }\n    // By default, explicit library paths are not checked for being linker scripts,\n    // but libc++ may very well be one, so force all inputs to be checked when passing\n    // an explicit path to libc++.\n    exe.allow_so_scripts = true;\n    exe.root_module.addObjectFile(.{ .cwd_relative = path_unpadded });\n\n    // TODO a way to integrate with system c++ include files here\n    // c++ -E -Wp,-v -xc++ /dev/null\n    if (need_cpp_includes) {\n        // I used these temporarily for testing something but we obviously need a\n        // more general purpose solution here.\n        //exe.root_module.addIncludePath(\"/nix/store/2lr0fc0ak8rwj0k8n3shcyz1hz63wzma-gcc-11.3.0/include/c++/11.3.0\");\n        //exe.root_module.addIncludePath(\"/nix/store/2lr0fc0ak8rwj0k8n3shcyz1hz63wzma-gcc-11.3.0/include/c++/11.3.0/x86_64-unknown-linux-gnu\");\n    }\n}\n\nfn addCMakeLibraryList(mod: *std.Build.Module, list: []const u8) void {\n    var it = mem.tokenizeScalar(u8, list, ';');\n    while (it.next()) |lib| {\n        if (mem.startsWith(u8, lib, \"-l\")) {\n            mod.linkSystemLibrary(lib[\"-l\".len..], .{});\n        } else if (mod.resolved_target.?.result.os.tag == .windows and\n            mem.endsWith(u8, lib, \".lib\") and !fs.path.isAbsolute(lib))\n        {\n            mod.linkSystemLibrary(lib[0 .. lib.len - \".lib\".len], .{});\n        } else {\n            mod.addObjectFile(.{ .cwd_relative = lib });\n        }\n    }\n}\n\nconst CMakeConfig = struct {\n    llvm_linkage: std.builtin.LinkMode,\n    cmake_binary_dir: []const u8,\n    cmake_prefix_path: []const u8,\n    cmake_static_library_prefix: []const u8,\n    cmake_static_library_suffix: []const u8,\n    cxx_compiler: []const u8,\n    cxx_compiler_arg1: []const u8,\n    lld_include_dir: []const u8,\n    lld_libraries: []const u8,\n    clang_libraries: []const u8,\n    llvm_lib_dir: []const u8,\n    llvm_include_dir: []const u8,\n    llvm_libraries: []const u8,\n    dia_guids_lib: []const u8,\n    system_libcxx: []const u8,\n};\n\nconst max_config_h_bytes = 1 * 1024 * 1024;\n\nfn findConfigH(b: *std.Build, config_h_path_option: ?[]const u8) ?[]const u8 {\n    if (config_h_path_option) |path| {\n        var config_h_or_err = fs.cwd().openFile(path, .{});\n        if (config_h_or_err) |*file| {\n            file.close();\n            return path;\n        } else |_| {\n            std.log.err(\"Could not open provided config.h: \\\"{s}\\\"\", .{path});\n            std.process.exit(1);\n        }\n    }\n\n    var check_dir = fs.path.dirname(b.graph.zig_exe).?;\n    while (true) {\n        var dir = fs.cwd().openDir(check_dir, .{}) catch unreachable;\n        defer dir.close();\n\n        // Check if config.h is present in dir\n        var config_h_or_err = dir.openFile(\"config.h\", .{});\n        if (config_h_or_err) |*file| {\n            file.close();\n            return fs.path.join(\n                b.allocator,\n                &[_][]const u8{ check_dir, \"config.h\" },\n            ) catch unreachable;\n        } else |e| switch (e) {\n            error.FileNotFound => {},\n            else => unreachable,\n        }\n\n        // Check if we reached the source root by looking for .git, and bail if so\n        var git_dir_or_err = dir.openDir(\".git\", .{});\n        if (git_dir_or_err) |*git_dir| {\n            git_dir.close();\n            return null;\n        } else |_| {}\n\n        // Otherwise, continue search in the parent directory\n        const new_check_dir = fs.path.dirname(check_dir);\n        if (new_check_dir == null or mem.eql(u8, new_check_dir.?, check_dir)) {\n            return null;\n        }\n        check_dir = new_check_dir.?;\n    }\n}\n\nfn parseConfigH(b: *std.Build, config_h_text: []const u8) ?CMakeConfig {\n    var ctx: CMakeConfig = .{\n        .llvm_linkage = undefined,\n        .cmake_binary_dir = undefined,\n        .cmake_prefix_path = undefined,\n        .cmake_static_library_prefix = undefined,\n        .cmake_static_library_suffix = undefined,\n        .cxx_compiler = undefined,\n        .cxx_compiler_arg1 = \"\",\n        .lld_include_dir = undefined,\n        .lld_libraries = undefined,\n        .clang_libraries = undefined,\n        .llvm_lib_dir = undefined,\n        .llvm_include_dir = undefined,\n        .llvm_libraries = undefined,\n        .dia_guids_lib = undefined,\n        .system_libcxx = undefined,\n    };\n\n    const mappings = [_]struct { prefix: []const u8, field: []const u8 }{\n        .{\n            .prefix = \"#define ZIG_CMAKE_BINARY_DIR \",\n            .field = \"cmake_binary_dir\",\n        },\n        .{\n            .prefix = \"#define ZIG_CMAKE_PREFIX_PATH \",\n            .field = \"cmake_prefix_path\",\n        },\n        .{\n            .prefix = \"#define ZIG_CMAKE_STATIC_LIBRARY_PREFIX \",\n            .field = \"cmake_static_library_prefix\",\n        },\n        .{\n            .prefix = \"#define ZIG_CMAKE_STATIC_LIBRARY_SUFFIX \",\n            .field = \"cmake_static_library_suffix\",\n        },\n        .{\n            .prefix = \"#define ZIG_CXX_COMPILER \",\n            .field = \"cxx_compiler\",\n        },\n        .{\n            .prefix = \"#define ZIG_CXX_COMPILER_ARG1 \",\n            .field = \"cxx_compiler_arg1\",\n        },\n        .{\n            .prefix = \"#define ZIG_LLD_INCLUDE_PATH \",\n            .field = \"lld_include_dir\",\n        },\n        .{\n            .prefix = \"#define ZIG_LLD_LIBRARIES \",\n            .field = \"lld_libraries\",\n        },\n        .{\n            .prefix = \"#define ZIG_CLANG_LIBRARIES \",\n            .field = \"clang_libraries\",\n        },\n        .{\n            .prefix = \"#define ZIG_LLVM_LIBRARIES \",\n            .field = \"llvm_libraries\",\n        },\n        .{\n            .prefix = \"#define ZIG_DIA_GUIDS_LIB \",\n            .field = \"dia_guids_lib\",\n        },\n        .{\n            .prefix = \"#define ZIG_LLVM_INCLUDE_PATH \",\n            .field = \"llvm_include_dir\",\n        },\n        .{\n            .prefix = \"#define ZIG_LLVM_LIB_PATH \",\n            .field = \"llvm_lib_dir\",\n        },\n        .{\n            .prefix = \"#define ZIG_SYSTEM_LIBCXX\",\n            .field = \"system_libcxx\",\n        },\n        // .prefix = ZIG_LLVM_LINK_MODE parsed manually below\n    };\n\n    var lines_it = mem.tokenizeAny(u8, config_h_text, \"\\r\\n\");\n    while (lines_it.next()) |line| {\n        inline for (mappings) |mapping| {\n            if (mem.startsWith(u8, line, mapping.prefix)) {\n                var it = mem.splitScalar(u8, line, '\"');\n                _ = it.first(); // skip the stuff before the quote\n                const quoted = it.next().?; // the stuff inside the quote\n                const trimmed = mem.trim(u8, quoted, \" \");\n                @field(ctx, mapping.field) = toNativePathSep(b, trimmed);\n            }\n        }\n        if (mem.startsWith(u8, line, \"#define ZIG_LLVM_LINK_MODE \")) {\n            var it = mem.splitScalar(u8, line, '\"');\n            _ = it.next().?; // skip the stuff before the quote\n            const quoted = it.next().?; // the stuff inside the quote\n            ctx.llvm_linkage = if (mem.eql(u8, quoted, \"shared\")) .dynamic else .static;\n        }\n    }\n    return ctx;\n}\n\nfn toNativePathSep(b: *std.Build, s: []const u8) []u8 {\n    const duplicated = b.allocator.dupe(u8, s) catch unreachable;\n    for (duplicated) |*byte| switch (byte.*) {\n        '/' => byte.* = fs.path.sep,\n        else => {},\n    };\n    return duplicated;\n}\n\nconst zig_cpp_sources = [_][]const u8{\n    // These are planned to stay even when we are self-hosted.\n    \"src/zig_llvm.cpp\",\n    \"src/zig_clang.cpp\",\n    \"src/zig_llvm-ar.cpp\",\n    \"src/zig_clang_driver.cpp\",\n    \"src/zig_clang_cc1_main.cpp\",\n    \"src/zig_clang_cc1as_main.cpp\",\n};\n\nconst clang_libs = [_][]const u8{\n    \"clangFrontendTool\",\n    \"clangCodeGen\",\n    \"clangFrontend\",\n    \"clangDriver\",\n    \"clangSerialization\",\n    \"clangSema\",\n    \"clangStaticAnalyzerFrontend\",\n    \"clangStaticAnalyzerCheckers\",\n    \"clangStaticAnalyzerCore\",\n    \"clangAnalysis\",\n    \"clangASTMatchers\",\n    \"clangAST\",\n    \"clangParse\",\n    \"clangSema\",\n    \"clangAPINotes\",\n    \"clangBasic\",\n    \"clangEdit\",\n    \"clangLex\",\n    \"clangARCMigrate\",\n    \"clangRewriteFrontend\",\n    \"clangRewrite\",\n    \"clangCrossTU\",\n    \"clangIndex\",\n    \"clangToolingCore\",\n    \"clangExtractAPI\",\n    \"clangSupport\",\n    \"clangInstallAPI\",\n    \"clangAST\",\n};\nconst lld_libs = [_][]const u8{\n    \"lldMinGW\",\n    \"lldELF\",\n    \"lldCOFF\",\n    \"lldWasm\",\n    \"lldMachO\",\n    \"lldCommon\",\n};\n// This list can be re-generated with `llvm-config --libfiles` and then\n// reformatting using your favorite text editor. Note we do not execute\n// `llvm-config` here because we are cross compiling. Also omit LLVMTableGen\n// from these libs.\nconst llvm_libs = [_][]const u8{\n    \"LLVMWindowsManifest\",\n    \"LLVMXRay\",\n    \"LLVMLibDriver\",\n    \"LLVMDlltoolDriver\",\n    \"LLVMTextAPIBinaryReader\",\n    \"LLVMCoverage\",\n    \"LLVMLineEditor\",\n    \"LLVMSandboxIR\",\n    \"LLVMXCoreDisassembler\",\n    \"LLVMXCoreCodeGen\",\n    \"LLVMXCoreDesc\",\n    \"LLVMXCoreInfo\",\n    \"LLVMX86TargetMCA\",\n    \"LLVMX86Disassembler\",\n    \"LLVMX86AsmParser\",\n    \"LLVMX86CodeGen\",\n    \"LLVMX86Desc\",\n    \"LLVMX86Info\",\n    \"LLVMWebAssemblyDisassembler\",\n    \"LLVMWebAssemblyAsmParser\",\n    \"LLVMWebAssemblyCodeGen\",\n    \"LLVMWebAssemblyUtils\",\n    \"LLVMWebAssemblyDesc\",\n    \"LLVMWebAssemblyInfo\",\n    \"LLVMVEDisassembler\",\n    \"LLVMVEAsmParser\",\n    \"LLVMVECodeGen\",\n    \"LLVMVEDesc\",\n    \"LLVMVEInfo\",\n    \"LLVMSystemZDisassembler\",\n    \"LLVMSystemZAsmParser\",\n    \"LLVMSystemZCodeGen\",\n    \"LLVMSystemZDesc\",\n    \"LLVMSystemZInfo\",\n    \"LLVMSparcDisassembler\",\n    \"LLVMSparcAsmParser\",\n    \"LLVMSparcCodeGen\",\n    \"LLVMSparcDesc\",\n    \"LLVMSparcInfo\",\n    \"LLVMRISCVTargetMCA\",\n    \"LLVMRISCVDisassembler\",\n    \"LLVMRISCVAsmParser\",\n    \"LLVMRISCVCodeGen\",\n    \"LLVMRISCVDesc\",\n    \"LLVMRISCVInfo\",\n    \"LLVMPowerPCDisassembler\",\n    \"LLVMPowerPCAsmParser\",\n    \"LLVMPowerPCCodeGen\",\n    \"LLVMPowerPCDesc\",\n    \"LLVMPowerPCInfo\",\n    \"LLVMNVPTXCodeGen\",\n    \"LLVMNVPTXDesc\",\n    \"LLVMNVPTXInfo\",\n    \"LLVMMSP430Disassembler\",\n    \"LLVMMSP430AsmParser\",\n    \"LLVMMSP430CodeGen\",\n    \"LLVMMSP430Desc\",\n    \"LLVMMSP430Info\",\n    \"LLVMMipsDisassembler\",\n    \"LLVMMipsAsmParser\",\n    \"LLVMMipsCodeGen\",\n    \"LLVMMipsDesc\",\n    \"LLVMMipsInfo\",\n    \"LLVMLoongArchDisassembler\",\n    \"LLVMLoongArchAsmParser\",\n    \"LLVMLoongArchCodeGen\",\n    \"LLVMLoongArchDesc\",\n    \"LLVMLoongArchInfo\",\n    \"LLVMLanaiDisassembler\",\n    \"LLVMLanaiCodeGen\",\n    \"LLVMLanaiAsmParser\",\n    \"LLVMLanaiDesc\",\n    \"LLVMLanaiInfo\",\n    \"LLVMHexagonDisassembler\",\n    \"LLVMHexagonCodeGen\",\n    \"LLVMHexagonAsmParser\",\n    \"LLVMHexagonDesc\",\n    \"LLVMHexagonInfo\",\n    \"LLVMBPFDisassembler\",\n    \"LLVMBPFAsmParser\",\n    \"LLVMBPFCodeGen\",\n    \"LLVMBPFDesc\",\n    \"LLVMBPFInfo\",\n    \"LLVMAVRDisassembler\",\n    \"LLVMAVRAsmParser\",\n    \"LLVMAVRCodeGen\",\n    \"LLVMAVRDesc\",\n    \"LLVMAVRInfo\",\n    \"LLVMARMDisassembler\",\n    \"LLVMARMAsmParser\",\n    \"LLVMARMCodeGen\",\n    \"LLVMARMDesc\",\n    \"LLVMARMUtils\",\n    \"LLVMARMInfo\",\n    \"LLVMAMDGPUTargetMCA\",\n    \"LLVMAMDGPUDisassembler\",\n    \"LLVMAMDGPUAsmParser\",\n    \"LLVMAMDGPUCodeGen\",\n    \"LLVMAMDGPUDesc\",\n    \"LLVMAMDGPUUtils\",\n    \"LLVMAMDGPUInfo\",\n    \"LLVMAArch64Disassembler\",\n    \"LLVMAArch64AsmParser\",\n    \"LLVMAArch64CodeGen\",\n    \"LLVMAArch64Desc\",\n    \"LLVMAArch64Utils\",\n    \"LLVMAArch64Info\",\n    \"LLVMOrcDebugging\",\n    \"LLVMOrcJIT\",\n    \"LLVMWindowsDriver\",\n    \"LLVMMCJIT\",\n    \"LLVMJITLink\",\n    \"LLVMInterpreter\",\n    \"LLVMExecutionEngine\",\n    \"LLVMRuntimeDyld\",\n    \"LLVMOrcTargetProcess\",\n    \"LLVMOrcShared\",\n    \"LLVMDWP\",\n    \"LLVMDebugInfoLogicalView\",\n    \"LLVMDebugInfoGSYM\",\n    \"LLVMOption\",\n    \"LLVMObjectYAML\",\n    \"LLVMObjCopy\",\n    \"LLVMMCA\",\n    \"LLVMMCDisassembler\",\n    \"LLVMLTO\",\n    \"LLVMPasses\",\n    \"LLVMHipStdPar\",\n    \"LLVMCFGuard\",\n    \"LLVMCoroutines\",\n    \"LLVMipo\",\n    \"LLVMVectorize\",\n    \"LLVMLinker\",\n    \"LLVMInstrumentation\",\n    \"LLVMFrontendOpenMP\",\n    \"LLVMFrontendOffloading\",\n    \"LLVMFrontendOpenACC\",\n    \"LLVMFrontendHLSL\",\n    \"LLVMFrontendDriver\",\n    \"LLVMExtensions\",\n    \"LLVMDWARFLinkerParallel\",\n    \"LLVMDWARFLinkerClassic\",\n    \"LLVMDWARFLinker\",\n    \"LLVMCodeGenData\",\n    \"LLVMGlobalISel\",\n    \"LLVMMIRParser\",\n    \"LLVMAsmPrinter\",\n    \"LLVMSelectionDAG\",\n    \"LLVMCodeGen\",\n    \"LLVMTarget\",\n    \"LLVMObjCARCOpts\",\n    \"LLVMCodeGenTypes\",\n    \"LLVMIRPrinter\",\n    \"LLVMInterfaceStub\",\n    \"LLVMFileCheck\",\n    \"LLVMFuzzMutate\",\n    \"LLVMScalarOpts\",\n    \"LLVMInstCombine\",\n    \"LLVMAggressiveInstCombine\",\n    \"LLVMTransformUtils\",\n    \"LLVMBitWriter\",\n    \"LLVMAnalysis\",\n    \"LLVMProfileData\",\n    \"LLVMSymbolize\",\n    \"LLVMDebugInfoBTF\",\n    \"LLVMDebugInfoPDB\",\n    \"LLVMDebugInfoMSF\",\n    \"LLVMDebugInfoDWARF\",\n    \"LLVMObject\",\n    \"LLVMTextAPI\",\n    \"LLVMMCParser\",\n    \"LLVMIRReader\",\n    \"LLVMAsmParser\",\n    \"LLVMMC\",\n    \"LLVMDebugInfoCodeView\",\n    \"LLVMBitReader\",\n    \"LLVMFuzzerCLI\",\n    \"LLVMCore\",\n    \"LLVMRemarks\",\n    \"LLVMBitstreamReader\",\n    \"LLVMBinaryFormat\",\n    \"LLVMTargetParser\",\n    \"LLVMSupport\",\n    \"LLVMDemangle\",\n};\n\nfn generateLangRef(b: *std.Build) std.Build.LazyPath {\n    const doctest_exe = b.addExecutable(.{\n        .name = \"doctest\",\n        .root_module = b.createModule(.{\n            .root_source_file = b.path(\"tools/doctest.zig\"),\n            .target = b.graph.host,\n            .optimize = .Debug,\n        }),\n    });\n\n    var dir = b.build_root.handle.openDir(\"doc/langref\", .{ .iterate = true }) catch |err| {\n        std.debug.panic(\"unable to open '{}doc/langref' directory: {s}\", .{\n            b.build_root, @errorName(err),\n        });\n    };\n    defer dir.close();\n\n    var wf = b.addWriteFiles();\n\n    var it = dir.iterateAssumeFirstIteration();\n    while (it.next() catch @panic(\"failed to read dir\")) |entry| {\n        if (std.mem.startsWith(u8, entry.name, \".\") or entry.kind != .file)\n            continue;\n\n        const out_basename = b.fmt(\"{s}.out\", .{std.fs.path.stem(entry.name)});\n        const cmd = b.addRunArtifact(doctest_exe);\n        cmd.addArgs(&.{\n            \"--zig\",        b.graph.zig_exe,\n            // TODO: enhance doctest to use \"--listen=-\" rather than operating\n            // in a temporary directory\n            \"--cache-root\", b.cache_root.path orelse \".\",\n        });\n        cmd.addArgs(&.{ \"--zig-lib-dir\", b.fmt(\"{}\", .{b.graph.zig_lib_directory}) });\n        cmd.addArgs(&.{\"-i\"});\n        cmd.addFileArg(b.path(b.fmt(\"doc/langref/{s}\", .{entry.name})));\n\n        cmd.addArgs(&.{\"-o\"});\n        _ = wf.addCopyFile(cmd.addOutputFileArg(out_basename), out_basename);\n    }\n\n    const docgen_exe = b.addExecutable(.{\n        .name = \"docgen\",\n        .root_module = b.createModule(.{\n            .root_source_file = b.path(\"tools/docgen.zig\"),\n            .target = b.graph.host,\n            .optimize = .Debug,\n        }),\n    });\n\n    const docgen_cmd = b.addRunArtifact(docgen_exe);\n    docgen_cmd.addArgs(&.{\"--code-dir\"});\n    docgen_cmd.addDirectoryArg(wf.getDirectory());\n\n    docgen_cmd.addFileArg(b.path(\"doc/langref.html.in\"));\n    return docgen_cmd.addOutputFileArg(\"langref.html\");\n}\n\nfn superHtmlCheck(b: *std.Build, html_file: std.Build.LazyPath) *std.Build.Step {\n    const run_superhtml = b.addSystemCommand(&.{\n        \"superhtml\", \"check\",\n    });\n    run_superhtml.addFileArg(html_file);\n    run_superhtml.expectExitCode(0);\n    return &run_superhtml.step;\n}\n"
        },
        {
          "name": "build.zig.zon",
          "type": "blob",
          "size": 0.38,
          "content": "// The Zig compiler is not intended to be consumed as a package.\n// The sole purpose of this manifest file is to test the compiler.\n.{\n    .name = \"zig\",\n    .version = \"0.0.0\",\n    .dependencies = .{\n        .standalone_test_cases = .{\n            .path = \"test/standalone\",\n        },\n        .link_test_cases = .{\n            .path = \"test/link\",\n        },\n    },\n    .paths = .{\"\"},\n}\n"
        },
        {
          "name": "ci",
          "type": "tree",
          "content": null
        },
        {
          "name": "cmake",
          "type": "tree",
          "content": null
        },
        {
          "name": "doc",
          "type": "tree",
          "content": null
        },
        {
          "name": "lib",
          "type": "tree",
          "content": null
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "stage1",
          "type": "tree",
          "content": null
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        },
        {
          "name": "tools",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}