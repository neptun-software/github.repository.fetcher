{
  "metadata": {
    "timestamp": 1736709491329,
    "page": 3,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjEw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "tc39/proposal-optional-chaining",
      "stars": 4943,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.1435546875,
          "content": "root = true\n\n[*]\ncharset = utf-8\nindent_style = space\nindent_size = 2\nend_of_line = lf\ninsert_final_newline = true\ntrim_trailing_whitespace = true\n"
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.02734375,
          "content": "node_modules/\nout/\nout-old/\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.2548828125,
          "content": "sudo: off\n\nlanguage: node_js\n\nnode_js:\n  - \"8\"\n\nscript:\n  - bash ./deploy.sh\n\nenv:\n  global:\n    - ENCRYPTION_LABEL: \"a32d39839cbc\"\n    - GH_USER_NAME: \"littledan\"\n    - GH_USER_EMAIL: \"littledan@igalia.com\"\n    - PRIVATE_KEY_FILE_NAME: \"github_deploy_key.enc\"\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 19.9638671875,
          "content": "# Optional Chaining for JavaScript\n\n## Status\n[ECMAScript proposal](https://github.com/tc39/proposals) at stage 4 of the process.\n\n## Authors\n\n* Claude Pache ([github](https://github.com/claudepache))\n* Gabriel Isenberg ([github](https://github.com/gisenberg), [twitter](https://twitter.com/the_gisenberg))\n* Daniel Rosenwasser ([github](https://github.com/DanielRosenwasser), [twitter](https://twitter.com/drosenwasser))\n* Dustin Savery ([github](https://github.com/dusave), [twitter](https://twitter.com/dustinsavery))\n\n## Overview and motivation\nWhen looking for a property value that's deep in a tree-like structure, one often has to check whether intermediate nodes exist:\n\n```javascript\nvar street = user.address && user.address.street;\n```\n\nAlso, many API return either an object or null/undefined, and one may want to extract a property from the result only when it is not null:\n\n```javascript\nvar fooInput = myForm.querySelector('input[name=foo]')\nvar fooValue = fooInput ? fooInput.value : undefined\n```\n\nThe Optional Chaining Operator allows a developer to handle many of those cases without repeating themselves and/or assigning intermediate results in temporary variables:\n\n```javascript\nvar street = user.address?.street\nvar fooValue = myForm.querySelector('input[name=foo]')?.value\n```\n\nWhen some other value than `undefined` is desired for the missing case, this can usually be handled with the [Nullish coalescing operator](//github.com/tc39/proposal-nullish-coalescing):\n\n```javascript\n// falls back to a default value when response.settings is missing or nullish\n// (response.settings == null) or when response.settings.animationDuration is missing\n// or nullish (response.settings.animationDuration == null)\nconst animationDuration = response.settings?.animationDuration ?? 300;\n\n```\n\nThe call variant of Optional Chaining is useful for dealing with interfaces that have optional methods:\n\n```js\niterator.return?.() // manually close an iterator\n```\nor with methods not universally implemented:\n```js\nif (myForm.checkValidity?.() === false) { // skip the test in older web browsers\n    // form validation fails\n    return;\n}\n```\n\n## Prior Art\nUnless otherwise noted, in the following languages, the syntax consists of a question mark prepending the operator, (`a?.b`, `a?.b()`, `a?[b]` or `a?(b)` when applicable).\n\nThe following languages implement the operator with the same general semantics as this proposal (i.e., 1) guarding against a null base value, and 2) short-circuiting application to the whole chain):\n* C#: [Null-conditional operator](https://msdn.microsoft.com/en-us/library/dn986595.aspx) — null-conditional member access or index, in read access.\n* Swift: [Optional Chaining](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/OptionalChaining.html#//apple_ref/doc/uid/TP40014097-CH21-ID245) — optional property, method, or subscript call, in read and write access.\n* CoffeeScript: [Existential operator](http://coffeescript.org/#existential-operator) — existential operator variant for property accessor, function call, object construction (`new a?()`). Also applies to assignment and deletion.\n\nThe following languages have a similar feature, but do not short-circuit the whole chain when it is longer than one element. This is justified by the fact that, in those languages, methods or properties might be legitimately used on null (e.g., null.toString() == \"null\" in Dart):\n* Kotlin: [Safe calls](https://kotlinlang.org/docs/reference/null-safety.html#safe-calls) — optional property access for read; optional property assignment for write.\n* Dart: [Conditional member access](https://dart.dev/guides/language/language-tour#other-operators) — optional property access.\n* Ruby: [Safe navigation operator](https://ruby-doc.org/core-2.6/doc/syntax/calling_methods_rdoc.html#label-Safe+navigation+operator) — Spelled as: `a&.b`\n\n\nThe following languages have a similar feature. We haven’t checked whether they have significant differences in semantics with this proposal:\n* Groovy: [Safe navigation operator](http://groovy-lang.org/operators.html#_safe_navigation_operator)\n* Angular: [Safe navigation operator](https://v10.angular.io/guide/template-expression-operators#the-safe-navigation-operator----and-null-property-paths) (link to archived documentation for Angular v10)\n\n## Syntax\n\nThe Optional Chaining operator is spelled `?.`. It may appear in three positions:\n```javascript\nobj?.prop       // optional static property access\nobj?.[expr]     // optional dynamic property access\nfunc?.(...args) // optional function or method call\n```\n\n### Notes\n* In order to allow `foo?.3:0` to be parsed as `foo ? .3 : 0` (as required for backward compatibility), a simple lookahead is added at the level of the lexical grammar, so that the sequence of characters `?.` is not interpreted as a single token in that situation (the `?.` token must not be immediately followed by a decimal digit).\n\n## Semantics\n\n### Base case\nIf the operand at the left-hand side of the `?.` operator evaluates to undefined or null, the expression evaluates to undefined. Otherwise the targeted property access, method or function call is triggered normally.\n\nHere are basic examples, each one followed by its desugaring. (The desugaring is not exact in the sense that the LHS should be evaluated only once and that `document.all` should behave as an object.)\n```js\na?.b                          // undefined if `a` is null/undefined, `a.b` otherwise.\na == null ? undefined : a.b\n\na?.[x]                        // undefined if `a` is null/undefined, `a[x]` otherwise.\na == null ? undefined : a[x]\n\na?.b()                        // undefined if `a` is null/undefined\na == null ? undefined : a.b() // throws a TypeError if `a.b` is not a function\n                              // otherwise, evaluates to `a.b()`\n\na?.()                        // undefined if `a` is null/undefined\na == null ? undefined : a()  // throws a TypeError if `a` is neither null/undefined, nor a function\n                             // invokes the function `a` otherwise\n```\n\n### Short-circuiting\n\nIf the expression on the LHS of `?.` evaluates to null/undefined, the RHS is not evaluated. This concept is called *short-circuiting*.\n\n```js\na?.[++x]         // `x` is incremented if and only if `a` is not null/undefined\na == null ? undefined : a[++x]\n```\n\n### Long short-circuiting\n\nIn fact, short-circuiting, when triggered, skips not only the current property access, method or function call, but also the whole chain of property accesses, method or function calls directly following the Optional Chaining operator.\n\n```js\na?.b.c(++x).d  // if `a` is null/undefined, evaluates to undefined. Variable `x` is not incremented.\n               // otherwise, evaluates to `a.b.c(++x).d`.\na == null ? undefined : a.b.c(++x).d\n```\n\nNote that the check for nullity is made on `a` only. If, for example, `a` is not null, but `a.b` is null, a TypeError will be thrown when attempting to access the property `\"c\"` of `a.b`.\n\nThis feature is implemented by, e.g., C# and CoffeeScript; see [Prior Art](https://github.com/tc39/proposal-optional-chaining#prior-art).\n\n### Stacking\n\nLet’s call *Optional Chain* an Optional Chaining operator followed by a chain of property accesses, method or function calls.\n\nAn Optional Chain may be followed by another Optional Chain.\n\n```js\na?.b[3].c?.(x).d\na == null ? undefined : a.b[3].c == null ? undefined : a.b[3].c(x).d\n  // (as always, except that `a` and `a.b[3].c` are evaluated only once)\n```\n\n### Edge case: grouping\n\nParentheses limit the scope of short-circuiting:\n\n```js\n(a?.b).c\n(a == null ? undefined : a.b).c\n```\n\nThat follows from the design choice of specifying the scope of short-circuiting by syntax (like the `&&` operator), rather than propagation of a Completion (like the `break` instruction) or an adhoc Reference (like an [earlier version of this proposal](https://github.com/claudepache/es-optional-chaining)). In general, syntax cannot be arbitrarily split by parentheses: for example, `({x}) = y` is not destructuring assignment, but an attempt to assign a value to an object literal.\n\nNote that, whatever the semantics are, there is no practical reason to use parentheses in that position anyway.\n\n### Optional deletion\n\nBecause the `delete` operator is very liberal in what it accepts, we have that feature for free:\n```js\ndelete a?.b\na == null ? true : delete a.b\n```\nwhere `true` is the usual result of attempting to delete a non-Reference.\n\n<details><summary>Why do we support optional deletion?</summary>\n\n*   **laziness** (this argument is placed first, not because it is the most important, but because it puts the other ones in the right perspective). Laziness (together with impatience and hubris) is one of the most important virtues of the spec writer. That is, all other things being almost equal, take the solution that involves less stuff to be incorporated in the spec.\n\n    Now, it happens that _supporting_ optional deletion requires literally zero effort, while _not supporting_ it (by making the construct an early syntax error) requires some nontrivial effort. (See [PR #73 (comment)](https://github.com/tc39/proposal-optional-chaining/pull/73#issuecomment-442762076) for technical details.)\n\n    Thus, per the laziness principle, the right question is not: “Are there good reasons to support optional deletion?”, but rather: “Are there good reasons to _remove_ support for optional deletion?”\n\n*   **lack of strong reason** for _removing_ support. The supported semantics of optional deletion is the only one that could be expected (provided that the semantics of the delete operator is correctly understood, of course). It is not like it could in some manner confuse the programmer. In fact, the only real reason is: “We didn’t intend to support it.”\n\n*   **consistency of the delete operator**. It is a fact of life that this operator is very liberal in what it accepts, even pretending to succeed when it is given something that does not make sense (e.g., `delete foo()`). The only error conditions (early or not) are in strict mode, when attempting to delete something that is barred from deletion (nonconfigurable property, variable, ...). Supporting optional deletion fits well in that model, while forbidding it does not.\n\n*  **existence of use cases**. Although they are not common, they do exist in practice ([example from Babel](https://github.com/babel/babel/blob/28ae47a174f67a8ae6f4527e0a66e88896814170/packages/babel-helper-builder-react-jsx/src/index.js#L66-L69)).\n</details>\n\n## Not supported\n\nAlthough they could be included for completeness, the following are not supported due to lack of real-world use cases or other compelling reasons; see [Issue # 22](https://github.com/tc39/proposal-optional-chaining/issues/22) and [Issue #54](https://github.com/tc39/proposal-optional-chaining/issues/54) for discussion:\n\n* optional construction: `new a?.()`\n* optional template literal: ``a?.`string` ``\n* constructor or template literals in/after an Optional Chain: `new a?.b()`, ``a?.b`string` ``\n\nThe following is not supported, although it has some use cases; see [Issue #18](//github.com/tc39/proposal-optional-chaining/issues/18) for discussion:\n\n* optional property assignment: `a?.b = c`\n\nThe following are not supported, as it does not make much sense, at least in practice; see [Issue #4 (comment)](https://github.com/tc39/proposal-optional-chaining/issues/4#issuecomment-373446728):\n\n* optional super: `super?.()`, `super?.foo`\n* anything that resembles to property access or function call, but is not: `new?.target`, `import?.('foo')`, etc.\n\nAll the above cases will be forbidden by the grammar or by static semantics so that support might be added later.\n\n## Out of scope\n\nThere has been various interesting ideas for applying the idea of “optional” to other constructs. However, there are not part of this proposal. For example:\n\n* optional spread, see [Issue #55](//github.com/tc39/proposal-optional-chaining/issues/55);\n* optional destructuring, see [Issue #74](//github.com/tc39/proposal-optional-chaining/issues/74).\n\n## Open issues\n\n### Private class fields and methods\n[Issue #28](https://github.com/tc39/proposal-optional-chaining/issues/28): Should optional chains support the upcoming private [class fields](https://github.com/tc39/proposal-class-fields) and [private methods](https://github.com/tc39/proposal-private-methods), as in `a?.#b`, `a?.#b()` or `a?.b.#c`? Quoting [microsoft/TypeScript#30167 (comment)](https://github.com/microsoft/TypeScript/issues/30167#issuecomment-468881537):\n\n> This one isn't baked into the proposal yet, simply because private fields themselves aren't baked yet. So we don't want to hold up this proposal if that one happens to stall out. Once that one has reached Stage 4, we will address it then.\n\n\n## FAQ\n\n\n<dl>\n\n\n<dt><code>obj?.[expr]</code> and <code>func?.(arg)</code> look ugly. Why not use <code>obj?[expr]</code> and <code>func?(arg)</code> as does &lt;language X>?</dt>\n\n<dd>\n\nWe don’t use the `obj?[expr]` and `func?(arg)` syntax, because of the difficulty for the parser to efficiently distinguish those forms from the conditional operator, e.g., `obj?[expr].filter(fun):0` and `func?(x - 2) + 3 :1`.\n\nAlternative syntaxes for those two cases each have their own flaws; and deciding which one looks the least bad is mostly a question of personal taste. Here is how we made our choice:\n\n* pick the best syntax for the `obj?.prop` case, which is expected to occur most often;\n* extend the use of the recognisable `?.` sequence of characters to other cases: `obj?.[expr]`, `func?.(arg)`.\n\nAs for &lt;language X>, it has different syntactical constraints than JavaScript because of &lt;some construct not supported by X or working differently in X>.\n\n</dd>\n\n<dt>Ok, but I really think that &lt;alternative syntax> is better.</dt>\n\n<dd>\n\nVarious alternative syntaxes has been explored and extensively discussed in the past. None of them gained consensus. Search for [issues\nwith label “alternative syntax”](https://github.com/tc39/proposal-optional-chaining/issues?utf8=%E2%9C%93&q=label%3A%22alternative+syntax%22), as well as [issues\nwith label “alternative syntax and semantics”](https://github.com/tc39/proposal-optional-chaining/issues?utf8=%E2%9C%93&q=label%3A%22alternative+syntax+and+semantics%22) for those that had impact on semantics.\n\n</dd>\n\n<dt>Why does <code>(null)?.b</code> evaluate to <code>undefined</code> rather than <code>null</code>?</dt>\n\n<dd>\n\nNeither `a.b` nor `a?.b` is intended to preserve arbitrary information on the base object `a`, but only to give information about the property `\"b\"` of that object. If a property `\"b\"` is absent from `a`, this is reflected by `a.b === undefined` and `a?.b === undefined`.\n\nIn particular, the value `null` is considered to have no properties; therefore, `(null)?.b` is undefined.\n\n</dd>\n\n<dt>Why does <code>foo?.()</code> throw when foo is neither nullish nor callable?</dt>\n\n<dd>\n\nImagine a library which will call a handler function, e.g. `onChange`, just when the user has provided it. If the user provides the number `3` instead of a function, the library will likely want to throw and inform the user of their mistaken usage. This is exactly what the proposed semantics for `onChange?.()` achieve.\n\nMoreover, this ensures that `?.` has a consistent meaning in all cases. Instead of making calls a special case where we check `typeof foo === 'function'`, we simply check `foo == null` across the board.\n\nFinally, remember that optional chaining is [not an error-suppression mechanism](#is-this-error-suppression).\n\n</dd>\n\n<dt>Why do you want long short-circuiting?</dt>\n\n<dd>\n\nSee [Issue #3 (comment)](https://github.com/tc39/proposal-optional-chaining/issues/3#issuecomment-306791812).\n\n</dd>\n\n<dt>In <code>a?.b.c</code>, if <code>a.b</code> is <code>null</code>, then <code>a.b.c</code> will evaluate to <code>undefined</code>, right?</dt>\n\n<dd>\n\nNo. It will throw a TypeError when attempting to fetch the property `\"c\"` of `a.b`.\n\nThe opportunity of short-circuiting happens only at one time, just after having evaluated the LHS of the Optional Chaining operator. If the result of that check is negative, evaluation proceeds normally.\n\nIn other words, the `?.` operator has an effect only at the very moment it is evaluated. It does not change the semantics of subsequent property accesses, method or function calls.\n\n</dd>\n\n<dt>In a deeply nested chain like <code>a?.b?.c</code>, why should I write <code>?.</code> at each level? Should I not be able to write the operator only once for the whole chain?</dt>\n\n<dd>\n\nBy design, we want the developer to be able to mark each place that they expect to be null/undefined, and only those. Indeed, we believe that an unexpected null/undefined value, being a symptom of a probable bug, should be reported as a TypeError rather than swept under the rug.\n\n</dd>\n\n<dt>...but, in the case of a deeply nested chain, we almost always want to test for <code>null</code>/<code>undefined</code> at each level, no?</dt>\n\n<dd>\n\nDeeply nested tree-like structures is not the sole use case of Optional Chaining.\n\nSee also [Usage statistics on optional chaining in CoffeeScript](https://github.com/tc39/proposal-optional-chaining/issues/17) and compare “Total soak operations” with “Total soak operations chained on top of another soak”.\n\n</dd>\n\n<dt id=\"is-this-error-suppression\">The feature looks like an error suppression operator, right?</dt>\n\n<dd>\n\nNo. Optional Chaining just checks whether some value is undefined or null. It does not catch or suppress errors that are thrown by evaluating the surrounding code. For example:\n\n```js\n(function () {\n    \"use strict\"\n    undeclared_var?.b    // ReferenceError: undeclared_var is not defined\n    arguments?.callee    // TypeError: 'callee' may not be accessed in strict mode\n    arguments.callee?.() // TypeError: 'callee' may not be accessed in strict mode\n    true?.()             // TypeError: true is not a function\n})()\n```\n\n</dd>\n\n</dl>\n\n## Specification\nSee: https://tc39.github.io/proposal-optional-chaining/\n\n## Support\n\n* Engines, see: https://github.com/tc39/proposal-optional-chaining/issues/115\n* Tools, see: https://github.com/tc39/proposal-optional-chaining/issues/44\n\n## Committee Discussions\n\n* [June 2019](https://github.com/rwaldron/tc39-notes/blob/7a4af23de5c3aa5ac9f68ec6c40e5677a72a56b1/meetings/2019-06/june-5.md#optional-chaining-for-stage-2)\n* [November 2018](https://github.com/rwaldron/tc39-notes/blob/def2ee0c04bc91612576237314a4f3b1fe2edaef/meetings/2018-11/nov-28.md#update-on-optional-chaining)\n* [March 2018](https://github.com/rwaldron/tc39-notes/blob/def2ee0c04bc91612576237314a4f3b1fe2edaef/meetings/2018-03/mar-22.md#optional-chaining-for-stage-2)\n* [January 2018](https://github.com/rwaldron/tc39-notes/blob/def2ee0c04bc91612576237314a4f3b1fe2edaef/meetings/2018-01/jan-24.md#13iiin-optional-chaining-update)\n* [September 2017](https://github.com/rwaldron/tc39-notes/blob/def2ee0c04bc91612576237314a4f3b1fe2edaef/meetings/2017-09/sept-27.md#12iiib-optional-chaining-operator-for-stage-2)\n* [July 2017](https://github.com/rwaldron/tc39-notes/blob/def2ee0c04bc91612576237314a4f3b1fe2edaef/meetings/2017-07/jul-27.md#13iia-optional-chaining-operator)\n\n## References\n* [TC39 Slide Deck: Null Propagation Operator](https://docs.google.com/presentation/d/11O_wIBBbZgE1bMVRJI8kGnmC6dWCBOwutbN9SWOK0fU/edit?usp=sharing)\n* [es-optional-chaining](https://github.com/claudepache/es-optional-chaining) (@claudepache)\n*  [ecmascript-optionals-proposal](https://github.com/davidyaha/ecmascript-optionals-proposal) (@davidyaha)\n\n## Related issues\n* [Babylon implementation](https://github.com/babel/babylon/issues/328)\n* [estree: Null Propagation Operator](https://github.com/estree/estree/issues/146)\n* [TypeScript: Suggestion: \"safe navigation operator\"](https://github.com/Microsoft/TypeScript/issues/16)\n* [Flow: Syntax for handling nullable variables](https://github.com/facebook/flow/issues/607)\n\n## Prior discussion\n* https://esdiscuss.org/topic/existential-operator-null-propagation-operator\n* https://esdiscuss.org/topic/optional-chaining-aka-existential-operator-null-propagation\n* https://esdiscuss.org/topic/specifying-the-existential-operator-using-abrupt-completion\n\n"
        },
        {
          "name": "ShortCircuitingWithoutNil.md",
          "type": "blob",
          "size": 4.390625,
          "content": "\nWarning\n=======\n\n***This document is now obsolete. See the new spec at https://tc39.github.io/proposal-optional-chaining/***\n\nIntroduction\n============\n\nThis is an attempt to rewrite Optional Chaining without using a transient Nil reference for implementing short-circuiting semantics.\n\nWith this version:\n* “optional construction” as in `new foo?.()` is abandoned;\n* constructions like `new a?.b` or ``a?.b `{c}` `` are not allowed by the grammar;\n* parentheses as in `(a?.b).c` stop short-circuiting.\n\n**Note.** A previous version of this document rewrote MemberExpression and CallExpression productions in order to be consistent with how OptionalChainingExpression is specified below. We removed that part, because:\n\n* the consistency is incomplete, as there are still separate MemberExpression, CoverCallExpressionAndAsyncArrowHead and CallExpression productions for various technical reasons, and that leads to break a chain of property accesses, method calls, etc. in several parts;\n* until otherwise proven, we don’t need to change what works.\n\n\nWhat is important, is to ensure consistency of the observed behaviour (for that, factoring the relevant part of algorithms may help).\n\n\nGrammar\n=======\n\nIn the lexical grammar\n```\n      OptionalChainingOperator ::\n        ? . [lookahead ∉ DecimalDigit]\n```\nThen, adding to the syntax of [Left-Hand-Side Expressions](https://tc39.github.io/ecma262/#sec-left-hand-side-expressions):\n```\nOptionalAccessChain :\n    OptionalChainingOperator [ Expression ]\n    OptionalChainingOperator IdentifierName\n    OptionalChainingOperator Arguments\n    OptionalAccessChain [ Expression ]\n    OptionalAccessChain . IdentifierName\n    OptionalAccessChain Arguments\n```\nExample of OptionalAccessChain:  ``?.a[b].c(d)``\n```\nOptionalChainingExpression :\n    MemberExpression OptionalAccessChain\n    CallExpression OptionalAccessChain\n    OptionalChainingExpression OptionalAccessChain\n```\n\nFinally, the current `LeftHandSideExpression` is replaced with:\n```\nNonOptionalChainingExpression :\n    NewExpression\n    CallExpression\n\nLeftHandSideExpression :\n    NonOptionalChainingExpression\n    OptionalChainingExpression\n```\nThe distinction between `NonOptionalChainingExpression` and `OptionalChainingExpression` is useful if/when we want to spec\noptional assignment. (For optional deletion, nothing is needed, not even touching a jot in the relevant part of the spec.)\n\n\nRuntime semantics\n=================\nShorthand notations\n-------------------\n   * “someNode.SomeOperation(foo, bar)” means “SomeOperation of someNode with arguments foo and bar”;\n   * “someNode.Evaluation()” means “the result of evaluating someNode”.\n\nEvaluation\n----------\n\n```\nOptionalChainingExpression :\n    MemberExpression OptionalAccessChain\n    CallExpression OptionalAccessChain\n    OptionalChainingExpression OptionalAccessChain\n```\n1. Let baseExpression be the first child of this production (i.e., this MemberExpression, CallExpression, or OptionalChainingExpression).\n1. Let ref be ? baseExpression.Evaluation().\n1. Let val be ? GetValue(ref).\n1. If Type(val) is Null or Undefined, then\n    1. Return undefined.\n1. Return ? OptionalAccessChain.ChainEvaluation(ref, val).\n\n\nChainEvaluation(ref, val)\n-----------------------\nThis operation is defined for OptionalAccessChain productions.\n\n```\nOptionalAccessChain :\n    OptionalChainingOperator [ Expression ]\n```\nSee https://tc39.github.io/ecma262/#sec-property-accessors-runtime-semantics-evaluation, omitting the two first steps,\nand replacing baseReference and baseValue with ref and val respectively.\n\n```\nOptionalAccessChain :\n    OptionalAccessChain OptionalChainingOperator [ Expression ]\n```\n\n1. Let firstNode be the first child of this production.\n1. Let ref2 be ? firstNode.ChainEvaluation(ref, val).\n1. Let val2 be ? GetValue(ref2).\n1. Continue as in https://tc39.github.io/ecma262/#sec-property-accessors-runtime-semantics-evaluation, omitting the two first steps,\nand replacing baseReference and baseValue with ref2 and val2 respectively.\n\n```\nOptionalAccessChain :\n    OptionalAccessChain Arguments\n```\n1. Let thisCallAccess be the parse of the production.\n1. Let tailCall be IsInTailPosition(thisCallAccess).\n1. Return ? EvaluateCall2(ref, val, Arguments, tailCall).\n\nHere, EvaluateCall2(ref, func, Arguments, tailCall) is [EvaluateCall(ref, Arguments, tailCall)](https://tc39.github.io/ecma262/#sec-evaluatecall) with first step removed.\n\nOther algorithms are left as exercise to the reader.\n"
        },
        {
          "name": "deploy.sh",
          "type": "blob",
          "size": 0.8505859375,
          "content": "#!/bin/bash\n\nset -ev\n\n# Enable SSH authentication\n\nENCRYPTED_KEY_VAR=\"encrypted_${ENCRYPTION_LABEL}_key\"\nENCRYPTED_IV_VAR=\"encrypted_${ENCRYPTION_LABEL}_iv\"\nENCRYPTED_KEY=${!ENCRYPTED_KEY_VAR}\nENCRYPTED_IV=${!ENCRYPTED_IV_VAR}\n\nif [[ $ENCRYPTED_KEY == \"\" ]]; then\n    echo \"Auto-deploy GitHub key missing; exiting without a build\"\n    exit 0\nfi\n\n$(npm bin)/set-up-ssh --key \"$ENCRYPTED_KEY\" \\\n                      --iv \"$ENCRYPTED_IV\" \\\n                      --path-encrypted-key \"$PRIVATE_KEY_FILE_NAME\"\n\n# Update the content from the `gh-pages` branch\n\n$(npm bin)/update-branch --commands \"mkdir out && ecmarkup spec.html out/index.html\" \\\n                         --commit-message \"Update gh-pages [skip ci]\" \\\n                         --directory \"out\" \\\n                         --distribution-branch \"gh-pages\" \\\n                         --source-branch \"master\"\n\n"
        },
        {
          "name": "github_deploy_key.enc",
          "type": "blob",
          "size": 3.171875,
          "content": null
        },
        {
          "name": "package.json",
          "type": "blob",
          "size": 1.1279296875,
          "content": "{\n  \"private\": true,\n  \"name\": \"proposal-optional-chaining\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Optional chaining proposal for ECMAScript\",\n  \"scripts\": {\n    \"clean\": \"rm -rf out\",\n    \"build\": \"npm run clean && mkdir out && ecmarkup --verbose spec.html out/index.html --css out/ecmarkup.css --js out/ecmarkup.js\",\n    \"watch\": \"npm run clean && mkdir out && ecmarkup --watch --verbose spec.html out/index.html --css out/ecmarkup.css --js out/ecmarkup.js\",\n    \"update-pages\": \"node node_modules/ecmarkup/bin/ecmarkup.js spec.html _index.html --css _ecmarkup.css --js _ecmarkup.js --verbose && git checkout gh-pages && rm -f index.html ecmarkup.css ecmarkup.js && mv _index.html index.html && mv _ecmarkup.css ecmarkup.css && mv _ecmarkup.js ecmarkup.js && git add index.html ecmarkup.js ecmarkup.css && git commit -m \\\"update pages\\\" && git checkout master\"\n  },\n  \"repository\": \"tc39/proposal-optional-chaining\",\n  \"author\": \"Claude Pache\",\n  \"license\": \"CC0\",\n  \"homepage\": \"https://tc39.github.io/proposal-optional-chaining/\",\n  \"dependencies\": {\n    \"ecmarkup\": \"^3.16.0\"\n  },\n  \"devDependencies\": {\n    \"@alrra/travis-scripts\": \"^3.0.0\"\n  }\n}\n"
        },
        {
          "name": "spec.html",
          "type": "blob",
          "size": 29.1845703125,
          "content": "<!DOCTYPE html>\n<meta charset=\"utf-8\">\n<link rel=\"icon\" href=\"favicon.ico\">\n<link href=\"ecmarkup.css\" rel=\"stylesheet\">\n<link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/github.min.css\">\n<script src=\"ecmarkup.js\"></script>\n<style>\nins .hljs.hljs {\n  background-color: inherit;\n}\n</style>\n<script>\n  if (location.hostname.endsWith('.github.io') && location.protocol !== 'https:') {\n    location.protocol = 'https:';\n  }\n</script>\n<pre class=metadata>\n  title: Optional Chaining\n  status: proposal\n  stage: 4\n  location: https://tc39.es/proposal-optional-chaining/\n  copyright: false\n  contributors: Claude Pache, ECMA International\n</pre>\n\n<emu-clause id=\"sec-scope\">\n  <h1>Scope</h1>\n  <p>This is the spec text of the <a href=\"https://github.com/tc39/proposal-optional-chaining/\">Optional Chaining proposal</a> in ECMAScript. </p>\n\n  <p>For the syntax, we use the `?.` token, with a lookahead at the level of the lexical grammar that allows to discriminate between `a?.b` (optional chaining) and `a?.3:0` (conditional operator, whose meaning cannot be changed due to backward compatibility constraints).</p>\n\n  <p>An <a href=\"https://claudepache.github.io/es-optional-chaining/\">early version of this proposal</a> used a Nil reference to express short-circuiting. This one is based on syntax only.</p>\n\n  <p>Normative additions are marked <ins>like this</ins>. In order to avoid distraction, we may omit mere editorial amendments.</p>\n\n  <p>List of significant editorial modifications:</p>\n  <ul>\n    <li><a href=\"#sec-property-accessors\">Property Accessors</a>: Factoring part of the property access operations in the new EvaluateDynamicPropertyAccess and EvaluateStaticPropertyAccess abstract operations.</li>\n  </ul>\n\n  <p>The following features may not be evident at a cursory read:</p>\n  <ul>\n    <li>Optional chaining is forbidden in write contexts such as `a?.b = c`. This is handled by defining properly the IsSimpleAssignmentTarget static semantics rule (<emu-xref href=\"#sec-static-semantics-static-semantics-issimpleassignmenttarget\"></emu-xref>).</li>\n    <li>Optional deletion as in: `delete a ?.b` is supported. There is no change needed in Section <emu-xref href=\"#sec-delete-operator\">The delete Operator</emu-xref>.</li>\n  </ul>\n</emu-clause>\n\n\n<!--\n<emu-clause id=\"sec-ecmascript-language-lexical-grammar\">\n  <h1>ECMAScript Language: Lexical Grammar (<a href=\"https://tc39.github.io/ecma262/#sec-ecmascript-language-lexical-grammar\">11</a>)</h1>\n-->\n\n  <emu-clause id=\"sec-punctuators\">\n    <h1>Punctuators (<a href=\"https://tc39.github.io/ecma262/#sec-punctuators\">11.7</a>)</h1>\n    <h2>Syntax</h2>\n    <emu-grammar>\n      <ins class=\"block\">\n      OptionalChainingPunctuator ::\n        `?.` [lookahead &lt;! DecimalDigit\n      </ins>\n\n      OtherPunctuator :: one of\n        `{` `(` `)` `[` `]`\n        `.` `...` `;` `,`\n        `&lt;` `&gt;` `&lt;=` `&gt;=`\n        `==` `!=` `===` `!==`\n        `+` `-` `*` `%` `**`\n        `++` `--`\n        `&lt;&lt;` `&gt;&gt;` `&gt;&gt;&gt;`\n        `&amp;` `|` `^`\n        `!` `~`\n        `&amp;&amp;` `||`\n        `?` `:`\n        `=` `+=` `-=` `*=` `%=` `**=` `&lt;&lt;=` `&gt;&gt;=` `&gt;&gt;&gt;=` `&amp;=` `|=` `^=`\n        `=&gt;`\n\n      Punctuator ::\n        <ins>OptionalChainingPunctuator</ins>\n        OtherPunctuator\n\n      DivPunctuator ::\n        `/`\n        `/=`\n\n      RightBracePunctuator ::\n        `}`\n    </emu-grammar>\n  </emu-clause>\n<!--\n</emu-clause>\n-->\n\n<!--\n<emu-clause id=\"sec-ecmascript-language-expressions\">\n  <h1>ECMAScript Language: Expressions (<a href=\"https://tc39.github.io/ecma262/#sec-ecmascript-language-expressions\">12</a>)</h1>\n-->\n\n  <emu-clause id=\"sec-left-hand-side-expressions\">\n    <h1>Left-Hand-Side Expressions (<a href=\"https://tc39.github.io/ecma262/#sec-left-hand-side-expressions\">12.3</a>)</h1>\n    <h2>Syntax</h2>\n    <emu-grammar>\n      MemberExpression[Yield, Await] :\n        PrimaryExpression[?Yield, ?Await]\n        MemberExpression[?Yield, ?Await] `[` Expression[+In, ?Yield, ?Await] `]`\n        MemberExpression[?Yield, ?Await] `.` IdentifierName\n        MemberExpression[?Yield, ?Await] TemplateLiteral[?Yield, ?Await, +Tagged]\n        SuperProperty[?Yield, ?Await]\n        MetaProperty\n        `new` MemberExpression[?Yield, ?Await] Arguments[?Yield, ?Await]\n\n      SuperProperty[Yield, Await] :\n        `super` `[` Expression[+In, ?Yield, ?Await] `]`\n        `super` `.` IdentifierName\n\n      MetaProperty :\n        NewTarget\n\n      NewTarget :\n        `new` `.` `target`\n\n      NewExpression[Yield, Await] :\n        MemberExpression[?Yield, ?Await]\n        `new` NewExpression[?Yield, ?Await]\n\n      CallExpression[Yield, Await] :\n        CoverCallExpressionAndAsyncArrowHead[?Yield, ?Await] #callcover\n        SuperCall[?Yield, ?Await]\n        CallExpression[?Yield, ?Await] Arguments[?Yield, ?Await]\n        CallExpression[?Yield, ?Await] `[` Expression[+In, ?Yield, ?Await] `]`\n        CallExpression[?Yield, ?Await] `.` IdentifierName\n        CallExpression[?Yield, ?Await] TemplateLiteral[?Yield, ?Await, +Tagged]\n\n      SuperCall[Yield, Await] :\n        `super` Arguments[?Yield, ?Await]\n\n      Arguments[Yield, Await] :\n        `(` `)`\n        `(` ArgumentList[?Yield, ?Await] `)`\n        `(` ArgumentList[?Yield, ?Await] `,` `)`\n\n      ArgumentList[Yield, Await] :\n        AssignmentExpression[+In, ?Yield, ?Await]\n        `...` AssignmentExpression[+In, ?Yield, ?Await]\n        ArgumentList[?Yield, ?Await] `,` AssignmentExpression[+In, ?Yield, ?Await]\n        ArgumentList[?Yield, ?Await] `,` `...` AssignmentExpression[+In, ?Yield, ?Await]\n\n      <ins class=\"block\">\n      OptionalExpression[Yield, Await] :\n        MemberExpression[?Yield, ?Await] OptionalChain[?Yield, ?Await]\n        CallExpression[?Yield, ?Await] OptionalChain[?Yield, ?Await]\n        OptionalExpression[?Yield, ?Await] OptionalChain[?Yield, ?Await]\n\n      OptionalChain[Yield, Await] :\n        `?.` `[` Expression[+In, ?Yield, ?Await] `]`\n        `?.` IdentifierName\n        `?.` Arguments[?Yield, ?Await]\n        `?.` TemplateLiteral[?Yield, ?Await, +Tagged]\n        OptionalChain[?Yield, ?Await]  `[` Expression[+In, ?Yield, ?Await] `]`\n        OptionalChain[?Yield, ?Await] `.` IdentifierName\n        OptionalChain[?Yield, ?Await] Arguments[?Yield, ?Await]\n        OptionalChain[?Yield, ?Await] TemplateLiteral[?Yield, ?Await, +Tagged]\n      </ins>\n\n      LeftHandSideExpression[Yield, Await] :\n        NewExpression[?Yield, ?Await]\n        CallExpression[?Yield, ?Await]\n        <ins>OptionalExpression[?Yield, ?Await]</ins>\n    </emu-grammar>\n    <h2>Supplemental Syntax</h2>\n    <p>When processing an instance of the production <emu-grammar>CallExpression : CoverCallExpressionAndAsyncArrowHead</emu-grammar> the interpretation of |CoverCallExpressionAndAsyncArrowHead| is refined using the following grammar:</p>\n    <emu-grammar type=\"definition\">\n      CallMemberExpression[Yield, Await] :\n        MemberExpression[?Yield, ?Await] Arguments[?Yield, ?Await]\n    </emu-grammar>\n\n    <emu-clause id=\"sec-static-semantics\">\n      <h1>Static Semantics (<a href=\"https://tc39.github.io/ecma262/#sec-static-semantics\">12.3.1</a>)</h1>\n\n      <ins class=\"block\">\n      <emu-clause id=\"sec-left-hand-side-expressions-static-semantics-early-errors\">\n        <h1>Static Semantics: Early Errors</h1>\n        <emu-grammar>\n          OptionalChain[Yield, Await] :\n            `?.` TemplateLiteral[?Yield, ?Await, +Tagged]\n            OptionalChain[?Yield, ?Await] TemplateLiteral[?Yield, ?Await, +Tagged]\n        </emu-grammar>\n        <ul>\n          <li>\n            It is a Syntax Error if any code matches this production.\n          </li>\n        </ul>\n        <emu-note>\n          <p>This production exists in order to prevent automatic semicolon insertion rules (<emu-xref href=\"#sec-automatic-semicolon-insertion\"></emu-xref>) to be applied to the following code:</p>\n          <pre><code class=\"javascript\">\n            a?.b\n            `c`\n          </code></pre>\n          <p>so that it would be interpreted as two valid statements. The purpose is to maintain consistency with similar code without optional chaining operator:</p>\n          <pre><code class=\"javascript\">\n            a.b\n            `c`\n          </code></pre>\n          <p>which is a valid statement and where automatic semicolon insertion does not apply.</p>\n        </emu-note>\n      </emu-clause>\n      </ins>\n\n      <emu-clause id=\"sec-left-hand-side-expressions-static-semantics-coveredcallexpression\">\n        <h1>Static Semantics: CoveredCallExpression</h1>\n        <emu-grammar>\n          CallExpression : CoverCallExpressionAndAsyncArrowHead\n        </emu-grammar>\n        <emu-alg>\n          1. Return the |CallMemberExpression| that is covered by |CoverCallExpressionAndAsyncArrowHead|.\n        </emu-alg>\n      </emu-clause>\n\n      <emu-clause id=\"sec-static-semantics-static-semantics-contains\">\n        <h1>Static Semantics: Contains</h1>\n        <p>With parameter _symbol_.</p>\n        <emu-see-also-para op=\"Contains\"></emu-see-also-para>\n        <emu-grammar>MemberExpression : MemberExpression `.` IdentifierName</emu-grammar>\n        <emu-alg>\n          1. If |MemberExpression| Contains _symbol_ is *true*, return *true*.\n          1. If _symbol_ is a |ReservedWord|, return *false*.\n          1. If _symbol_ is an |Identifier| and StringValue of _symbol_ is the same value as the StringValue of |IdentifierName|, return *true*.\n          1. Return *false*.\n        </emu-alg>\n        <emu-grammar>SuperProperty : `super` `.` IdentifierName</emu-grammar>\n        <emu-alg>\n          1. If _symbol_ is the |ReservedWord| `super`, return *true*.\n          1. If _symbol_ is a |ReservedWord|, return *false*.\n          1. If _symbol_ is an |Identifier| and StringValue of _symbol_ is the same value as the StringValue of |IdentifierName|, return *true*.\n          1. Return *false*.\n        </emu-alg>\n        <emu-grammar>CallExpression : CallExpression `.` IdentifierName</emu-grammar>\n        <emu-alg>\n          1. If |CallExpression| Contains _symbol_ is *true*, return *true*.\n          1. If _symbol_ is a |ReservedWord|, return *false*.\n          1. If _symbol_ is an |Identifier| and StringValue of _symbol_ is the same value as the StringValue of |IdentifierName|, return *true*.\n          1. Return *false*.\n        </emu-alg>\n        <ins class=\"block\">\n        <emu-grammar>OptionalChain : `?.` IdentifierName</emu-grammar>\n        <emu-alg>\n          1. If _symbol_ is a |ReservedWord|, return *false*.\n          1. If _symbol_ is an |Identifier| and StringValue of _symbol_ is the same value as the StringValue of |IdentifierName|, return *true*.\n          1. Return *false*.\n        </emu-alg>\n        <emu-grammar>OptionalChain : OptionalChain `.` IdentifierName</emu-grammar>\n        <emu-alg>\n          1. If |OptionalChain| Contains _symbol_ is *true*, return *true*.\n          1. If _symbol_ is a |ReservedWord|, return *false*.\n          1. If _symbol_ is an |Identifier| and StringValue of _symbol_ is the same value as the StringValue of |IdentifierName|, return *true*.\n          1. Return *false*.\n        </emu-alg>\n        </ins>\n      </emu-clause>\n\n      <emu-clause id=\"sec-static-semantics-static-semantics-isfunctiondefinition\">\n        <h1>Static Semantics: IsFunctionDefinition</h1>\n        <emu-see-also-para op=\"IsFunctionDefinition\"></emu-see-also-para>\n        <emu-grammar>\n          MemberExpression :\n            MemberExpression `[` Expression `]`\n            MemberExpression `.` IdentifierName\n            MemberExpression TemplateLiteral\n            SuperProperty\n            MetaProperty\n            `new` MemberExpression Arguments\n\n          NewExpression :\n            `new` NewExpression\n\n          LeftHandSideExpression :\n            CallExpression\n            <ins>OptionalExpression</ins>\n        </emu-grammar>\n        <emu-alg>\n          1. Return *false*.\n        </emu-alg>\n      </emu-clause>\n\n      <emu-clause id=\"sec-static-semantics-static-semantics-isdestructuring\">\n        <h1>Static Semantics: IsDestructuring</h1>\n        <emu-see-also-para op=\"IsDestructuring\"></emu-see-also-para>\n        <emu-grammar>MemberExpression : PrimaryExpression</emu-grammar>\n        <emu-alg>\n          1. If |PrimaryExpression| is either an |ObjectLiteral| or an |ArrayLiteral|, return *true*.\n          1. Return *false*.\n        </emu-alg>\n        <emu-grammar>\n          MemberExpression :\n            MemberExpression `[` Expression `]`\n            MemberExpression `.` IdentifierName\n            MemberExpression TemplateLiteral\n            SuperProperty\n            MetaProperty\n            `new` MemberExpression Arguments\n\n          NewExpression :\n            `new` NewExpression\n\n          LeftHandSideExpression :\n            CallExpression\n            <ins>OptionalExpression</ins>\n        </emu-grammar>\n        <emu-alg>\n          1. Return *false*.\n        </emu-alg>\n      </emu-clause>\n\n      <emu-clause id=\"sec-static-semantics-static-semantics-isidentifierref\">\n        <h1>Static Semantics: IsIdentifierRef</h1>\n        <emu-see-also-para op=\"IsIdentifierRef\"></emu-see-also-para>\n        <emu-grammar>\n          MemberExpression :\n            MemberExpression `[` Expression `]`\n            MemberExpression `.` IdentifierName\n            MemberExpression TemplateLiteral\n            SuperProperty\n            MetaProperty\n            `new` MemberExpression Arguments\n\n          NewExpression :\n            `new` NewExpression\n\n          LeftHandSideExpression :\n            CallExpression\n            <ins>OptionalExpression</ins>\n        </emu-grammar>\n        <emu-alg>\n          1. Return *false*.\n        </emu-alg>\n      </emu-clause>\n\n      <emu-clause oldids=\"sec-binary-logical-operators-static-semantics-isvalidsimpleassignmenttarget,sec-semantics-static-semantics-assignmenttargettype\" id=\"sec-binary-logical-operators-static-semantics-issimpleassignmenttarget\">\n        <h1>Static Semantics: IsSimpleAssignmentTarget</h1>\n        <emu-see-also-para op=\"IsSimpleAssignmentTarget\"></emu-see-also-para>\n        <emu-grammar>\n          CallExpression :\n            CallExpression `[` Expression `]`\n            CallExpression `.` IdentifierName\n\n          MemberExpression :\n            MemberExpression `[` Expression `]`\n            MemberExpression `.` IdentifierName\n            SuperProperty\n        </emu-grammar>\n        <emu-alg>\n          1. Return *true*.\n        </emu-alg>\n        <emu-grammar>\n          CallExpression :\n            CoverCallExpressionAndAsyncArrowHead\n            SuperCall\n            CallExpression Arguments\n            CallExpression TemplateLiteral\n\n          NewExpression :\n            `new` NewExpression\n\n          MemberExpression :\n            MemberExpression TemplateLiteral\n            `new` MemberExpression Arguments\n\n          NewTarget :\n            `new` `.` `target`\n\n        <ins class=\"block\">\n        LeftHandSideExpression :\n          OptionalExpression\n        </ins>\n        </emu-grammar>\n        <emu-alg>\n          1. Return *false*.\n        </emu-alg>\n      </emu-clause>\n    </emu-clause>\n\n    <emu-clause id=\"sec-property-accessors\">\n      <h1>Property Accessors (<a href=\"https://tc39.github.io/ecma262/#sec-property-accessors\">12.3.2</a>)</h1>\n      <emu-note>\n        <p>Properties are accessed by name, using either the dot notation:</p>\n        <div class=\"rhs\">\n          |MemberExpression| `.` |IdentifierName|\n          <br>\n          |CallExpression| `.` |IdentifierName|\n        </div>\n        <p>or the bracket notation:</p>\n        <div class=\"rhs\">\n          |MemberExpression| `[` |Expression| `]`\n          <br>\n          |CallExpression| `[` |Expression| `]`\n        </div>\n        <p>The dot notation is explained by the following syntactic conversion:</p>\n        <div class=\"rhs\">\n          |MemberExpression| `.` |IdentifierName|\n        </div>\n        <p>is identical in its behaviour to</p>\n        <div class=\"rhs\">\n          |MemberExpression| `[` &lt;<i>identifier-name-string</i>&gt; `]`\n        </div>\n        <p>and similarly</p>\n        <div class=\"rhs\">\n          |CallExpression| `.` |IdentifierName|\n        </div>\n        <p>is identical in its behaviour to</p>\n        <div class=\"rhs\">\n          |CallExpression| `[` &lt;<i>identifier-name-string</i>&gt; `]`\n        </div>\n        <p>where &lt;<i>identifier-name-string</i>&gt; is the result of evaluating StringValue of |IdentifierName|.</p>\n      </emu-note>\n\n      <emu-clause id=\"sec-property-accessors-runtime-semantics-evaluation\">\n        <h1>Runtime Semantics: Evaluation</h1>\n        <emu-grammar>MemberExpression : MemberExpression `[` Expression `]`</emu-grammar>\n        <emu-alg>\n          1. Let _baseReference_ be the result of evaluating |MemberExpression|.\n          1. Let _baseValue_ be ? GetValue(_baseReference_).\n          1. <del>Let _propertyNameReference_ be the result of evaluating |Expression|.</del>\n          1. <del>Let _propertyNameValue_ be ? GetValue(_propertyNameReference_).</del>\n          1. <del>Let _bv_ be ? RequireObjectCoercible(_baseValue_).</del>\n          1. <del>Let _propertyKey_ be ? ToPropertyKey(_propertyNameValue_).</del>\n          1. If the code matched by this |MemberExpression| is strict mode code, let _strict_ be *true*, else let _strict_ be *false*.\n          1. <del>Return a value of type Reference whose base value component is _bv_, whose referenced name component is _propertyKey_, and whose strict reference flag is _strict_.</del>\n          1. <ins>Return ? EvaluateDynamicPropertyAccess(_baseValue_, |Expression|, _strict_).</ins>\n        </emu-alg>\n        <emu-grammar>MemberExpression : MemberExpression `.` IdentifierName</emu-grammar>\n        <emu-alg>\n          1. Let _baseReference_ be the result of evaluating |MemberExpression|.\n          1. Let _baseValue_ be ? GetValue(_baseReference_).\n          1. <del>Let _bv_ be ? RequireObjectCoercible(_baseValue_).</del>\n          1. <del>Let _propertyNameString_ be StringValue of |IdentifierName|.</del>\n          1. If the code matched by this |MemberExpression| is strict mode code, let _strict_ be *true*, else let _strict_ be *false*.\n          1. <del>1. Return a value of type Reference whose base value component is _bv_, whose referenced name component is _propertyNameString_, and whose strict reference flag is _strict_.</del>\n          1. <ins>Return ? EvaluateStaticPropertyAccess(_baseValue_, |IdentifierName|, _strict_).</ins>\n        </emu-alg>\n        <emu-grammar>CallExpression : CallExpression `[` Expression `]`</emu-grammar>\n        <p><del>Is evaluated in exactly the same manner as <emu-grammar>MemberExpression : MemberExpression `[` Expression `]`</emu-grammar> except that the contained |CallExpression| is evaluated in step 1.</del></p>\n        <emu-alg>\n          1. <ins>Let _baseReference_ be the result of evaluating |CallExpression|.</ins>\n          1. <ins>Let _baseValue_ be ? GetValue(_baseReference_).</ins>\n          1. <ins>If the code matched by this |CallExpression| is strict mode code, let _strict_ be *true*, else let _strict_ be *false*.</ins>\n          1. <ins>Return ? EvaluateDynamicPropertyAccess(_baseValue_, |Expression|, _strict_).</ins>\n        </emu-alg>\n\n        <emu-grammar>CallExpression : CallExpression `.` IdentifierName</emu-grammar>\n        <emu-alg>\n          1. Let _baseReference_ be the result of evaluating |CallExpression|.\n          1. Let _baseValue_ be ? GetValue(_baseReference_).\n          1. If the code matched by this |CallExpression| is strict mode code, let _strict_ be *true*, else let _strict_ be *false*.\n          1. Return ? EvaluateStaticPropertyAccess(_baseValue_, |IdentifierName|, _strict_).\n        </emu-alg>\n      </emu-clause>\n\n      <emu-clause id=\"sec-evaluate-dynamic-property-access\" aoid=\"EvaluateDynamicPropertyAccess\">\n        <h1><ins>Runtime Semantics: EvaluateDynamicPropertyAccess(_baseValue_, _expression_, _strict_ )</ins></h1>\n        <p><ins>The abstract operation EvaluateDynamicPropertyAccess takes as arguments a value _baseValue_, a Parse Node _expression_, and a Boolean argument _strict_. It performs the following steps:</ins></p>\n        <emu-alg>\n          1. <ins>Let _propertyNameReference_ be the result of evaluating _expression_.</ins>\n          1. <ins>Let _propertyNameValue_ be ? GetValue(_propertyNameReference_).</ins>\n          1. <ins>Let _bv_ be ? RequireObjectCoercible(_baseValue_).</ins>\n          1. <ins>Let _propertyKey_ be ? ToPropertyKey(_propertyNameValue_).</ins>\n          1. <ins>Return a value of type Reference whose base value component is _bv_, whose referenced name component is _propertyKey_, and whose strict reference flag is _strict_.</ins>\n      </emu-clause>\n      <emu-clause id=\"sec-evaluate-static-property-access\" aoid=\"EvaluateStaticPropertyAccess\">\n        <h1><ins>Runtime Semantics: EvaluateStaticPropertyAccess(_baseValue_, _identifierName_, _strict_ )</ins></h1>\n        <p><ins>The abstract operation EvaluateStaticPropertyAccess takes as arguments a value _baseValue_, a Parse Node _identifierName_, and a Boolean argument _strict_. It performs the following steps:</ins></p>\n        <emu-alg>\n          1. <ins>Let _bv_ be ? RequireObjectCoercible(_baseValue_).</ins>\n          1. <ins>Let _propertyNameString_ be StringValue of _identifierName_.</ins>\n          1. <ins>Return a value of type Reference whose base value component is _bv_, whose referenced name component is _propertyNameString_, and whose strict reference flag is _strict_.</ins>\n      </emu-clause>\n\n    </emu-clause>\n\n    <emu-clause id=\"sec-function-calls\">\n      <h1>Function Calls (<a href=\"https://tc39.github.io/ecma262/#sec-function-calls\">12.3.4</a>)</h1>\n\n      <emu-clause id=\"sec-function-calls-runtime-semantics-evaluation\">\n        <h1>Runtime Semantics: Evaluation</h1>\n        <emu-grammar>CallExpression : CoverCallExpressionAndAsyncArrowHead</emu-grammar>\n        <emu-alg>\n          1. Let _expr_ be CoveredCallExpression of |CoverCallExpressionAndAsyncArrowHead|.\n          1. Let _memberExpr_ be the |MemberExpression| of _expr_.\n          1. Let _arguments_ be the |Arguments| of _expr_.\n          1. Let _ref_ be the result of evaluating _memberExpr_.\n          1. Let _func_ be ? GetValue(_ref_).\n          1. <del>If Type(_ref_) is Reference and IsPropertyReference(_ref_) is *false* and GetReferencedName(_ref_) is `\"eval\"`, then</del>\n          1. <ins>If Type(_ref_) is Reference, IsPropertyReference(_ref_) is *false*, and GetReferencedName(_ref_) is `\"eval\"`, then</ins>\n            1. If SameValue(_func_, %eval%) is *true*, then\n              1. Let _argList_ be ? ArgumentListEvaluation of _arguments_.\n              1. If _argList_ has no elements, return *undefined*.\n              1. Let _evalText_ be the first element of _argList_.\n              1. If the source code matching this |CallExpression| is strict mode code, let _strictCaller_ be *true*. Otherwise let _strictCaller_ be *false*.\n              1. Let _evalRealm_ be the current Realm Record.\n              1. Perform ? HostEnsureCanCompileStrings(_evalRealm_, _evalRealm_).\n              1. Return ? PerformEval(_evalText_, _evalRealm_, _strictCaller_, *true*).\n          1. Let _thisCall_ be this |CallExpression|.\n          1. Let _tailCall_ be IsInTailPosition(_thisCall_).\n          1. Return ? EvaluateCall(_func_, _ref_, _arguments_, _tailCall_).\n        </emu-alg>\n        <p>A |CallExpression| evaluation that executes step 6.a.vii is a <dfn>direct eval</dfn>.</p>\n        <emu-grammar>CallExpression : CallExpression Arguments</emu-grammar>\n        <emu-alg>\n          1. Let _ref_ be the result of evaluating |CallExpression|.\n          1. Let _func_ be ? GetValue(_ref_).\n          1. Let _thisCall_ be this |CallExpression|.\n          1. Let _tailCall_ be IsInTailPosition(_thisCall_).\n          1. Return ? EvaluateCall(_func_, _ref_, |Arguments|, _tailCall_).\n        </emu-alg>\n      </emu-clause>\n    </emu-clause>\n\n    <ins class=\"block\">\n    <emu-clause id=\"sec-optional-chains\">\n      <h1>Optional Chains</h1>\n      <emu-note>An optional chain is a chain of one or more property accesses and function calls, the first of which begins with the token `?.`.</emu-note>\n      <emu-clause id=\"sec-optional-chaining-evaluation\">\n        <h1>Runtime Semantics: Evaluation</h1>\n        <emu-grammar>\n          OptionalExpression :\n            MemberExpression OptionalChain\n            CallExpression OptionalChain\n            OptionalExpression OptionalChain\n        </emu-grammar>\n        <emu-alg>\n          1. Let _baseExpression_ be the first child of this |OptionalExpression| (i.e., |MemberExpression|, |CallExpression|, or |OptionalExpression|).\n          1. Let _baseReference_ be the result of evaluating _baseExpression_.\n          1. Let _baseValue_ be ? GetValue(_baseReference_).\n          1. If _baseValue_ is *undefined* or *null*, then\n            1. Return *undefined*.\n          1. Let _optionalChain_ be |OptionalChain|.\n          1. Return the result of performing ChainEvaluation of _optionalChain_ with arguments _baseValue_ and _baseReference_.\n        </emu-alg>\n      </emu-clause>\n      <emu-clause id=\"sec-optional-chaining-chain-evaluation\">\n        <h1>Runtime Semantics: ChainEvaluation</h1>\n        <p>With parameters _baseValue_ and _baseReference_.</p>\n        <emu-grammar>OptionalChain : `?.` `[` Expression `]`</emu-grammar>\n        <emu-alg>\n          1. If the code matched by this |OptionalChain| is strict mode code, let _strict_ be *true*, else let _strict_ be *false*.\n          1. Return ? EvaluateDynamicPropertyAccess(_baseValue_, |Expression|, _strict_).\n        </emu-alg>\n        <emu-grammar>OptionalChain : `?.` IdentifierName</emu-grammar>\n        <emu-alg>\n          1. If the code matched by this |OptionalChain| is strict mode code, let _strict_ be *true*, else let _strict_ be *false*.\n          1. Return ? EvaluateStaticPropertyAccess(_baseValue_, |IdentifierName|, _strict_).\n        </emu-alg>\n        <emu-grammar>OptionalChain : `?.` Arguments</emu-grammar>\n        <emu-alg>\n          1. Let _thisChain_ be this |OptionalChain|.\n          1. Let _tailCall_ be IsInTailPosition(_thisChain_).\n          1. Return ? EvaluateCall(_baseValue_, _baseReference_, |Arguments|, _tailCall_).\n        </emu-alg>\n        <emu-grammar>OptionalChain : OptionalChain `[` Expression `]`</emu-grammar>\n        <emu-alg>\n          1. Let _optionalChain_ be |OptionalChain|.\n          1. Let _newReference_ be ? ChainEvaluation of _optionalChain_ with arguments _baseValue_ and _baseReference_.\n          1. Let _newValue_ be ? GetValue(_newReference_).\n          1. If the code matched by this |OptionalChain| is strict mode code, let _strict_ be *true*, else let _strict_ be *false*.\n          1. Return ? EvaluateDynamicPropertyAccess(_newValue_, |Expression|, _strict_).\n        </emu-alg>\n        <emu-grammar>OptionalChain : OptionalChain `.` IdentifierName</emu-grammar>\n        <emu-alg>\n          1. Let _optionalChain_ be |OptionalChain|.\n          1. Let _newReference_ be ? ChainEvaluation of _optionalChain_ with arguments _baseValue_ and _baseReference_.\n          1. Let _newValue_ be ? GetValue(_newReference_).\n          1. If the code matched by this |OptionalChain| is strict mode code, let _strict_ be *true*, else let _strict_ be *false*.\n          1. Return ? EvaluateStaticPropertyAccess(_newValue_, |IdentifierName|, _strict_).\n        </emu-alg>\n        <emu-grammar>OptionalChain : OptionalChain Arguments</emu-grammar>\n        <emu-alg>\n          1. Let _optionalChain_ be |OptionalChain|.\n          1. Let _newReference_ be ? ChainEvaluation of _optionalChain_ with arguments _baseValue_ and _baseReference_.\n          1. Let _newValue_ be ? GetValue(_newReference_).\n          1. Let _thisChain_ be this |OptionalChain|.\n          1. Let _tailCall_ be IsInTailPosition(_thisChain_).\n          1. Return ? EvaluateCall(_newValue_, _newReference_, |Arguments|, _tailCall_).\n        </emu-alg>\n      </emu-clause>\n    </emu-clause>\n    </ins>\n<!--\n</emu-clause>\n-->\n\n<!--\n<emu-clause id=\"sec-ecmascript-language-functions-and-classes\">\n  <h1>ECMAScript Language: Functions and Classes (<a href=\"https://tc39.github.io/ecma262/#sec-ecmascript-language-functions-and-classes\">14</a>)</h1>\n-->\n  <emu-clause id=\"sec-tail-position-calls\">\n    <h1>Tail Position Calls (<a href=\"https://tc39.github.io/ecma262/#sec-tail-position-calls\">14.8</a>)</h1>\n    <emu-clause id=\"sec-static-semantics-hascallintailposition\">\n      <h1>Static Semantics: HasCallInTailPosition (<a href=\"https://tc39.github.io/ecma262/#sec-static-semantics-hascallintailposition\">14.8.2</a>)</h1>\n      <p>With parameter _call_.</p>\n      <emu-clause id=\"sec-expression-rules\">\n        <h1>Expression Rules</h1>\n        <ins class=\"block\">\n        <emu-grammar>\n          OptionalExpression :\n            MemberExpression OptionalChain\n            CallExpression OptionalChain\n            OptionalExpression OptionalChain\n        </emu-grammar>\n        <emu-alg>\n          1. Return HasCallInTailPosition of |OptionalChain| with argument _call_.\n        </emu-alg>\n        <emu-grammar>\n          OptionalChain :\n            `?.` `[` Expression `]`\n            `?.` IdentifierName\n            OptionalChain `[` Expression `]`\n            OptionalChain `.` IdentifierName\n        </emu-grammar>\n        <emu-alg>\n          1. Return *false*.\n        </emu-alg>\n        <emu-grammar>\n          OptionalChain :\n            `?.` Arguments\n            OptionalChain Arguments\n        </emu-grammar>\n        <emu-alg>\n          1. If this |OptionalChain| is _call_, return *true*.\n          1. Return *false*.\n        </emu-alg>\n        </ins>\n      </emu-clause>\n    </emu-clause>\n  </emu-clause>\n<!--\n</emu-clause>\n-->\n"
        }
      ]
    }
  ]
}