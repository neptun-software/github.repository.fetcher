{
  "metadata": {
    "timestamp": 1736709569215,
    "page": 107,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjExMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "go101/go101",
      "stars": 5664,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.1005859375,
          "content": "/go101\n.gcloudignore\n/generated\napp.yaml\n/*.epub\n/*.mobi\n/*.html\n/*.azw*\n/*.pdf\n/*.epub\n/*.docx\n/*.doc\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.1689453125,
          "content": "Copyright (c) Tapir Liu. All rights reserved.\n\nI keep all rights of Chinese and English versions of any distribution forms.\n\nExcept Chinese and English versions, other translation redistributions are\nallowed with the following requirements：\n1. Each the redistribution page should contain an obvious link\n   to the https://go101.org website.\n2. Each the redistribution page should contain an obvious link\n   to the https://www.tapirgames.com website.\n3. Each the redistribution page should contain an obvious link\n   to my twitter account: https://twitter.com/TapirLiu.\n\nHere is a HTML example for the link requirements:\n\n\t<a href=\"https://go101.org\">Go 101</a> is written by\n\t<a href=\"https://twitter.com/TapirLiu\">@TapirLiu</a>.\n\tPlease support this book by playing\n\t<a href=\"https://www.tapirgames.com\">Tapir's games</a>.\n\nThe equivalent markdown format to the above HTML example:\n\n\t[Go 101](https://go101.org) is written by\n\t[@TapirLiu](https://twitter.com/TapirLiu).\n\tPlease support this book by playing\n\t[Tapir's games](https://www.tapirgames.com).\n\nExcept the cases mentioned above, the contents in this book can be quoted\nand used in any non-profit ways without asking and crediting me.\n\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 2.669921875,
          "content": "\n<b>[Go 101](https://go101.org)</b> is a series of books on Go programming.\nCurrently, the following books are avaliable:\n\n* [Go (Fundamentals) 101](https://go101.org/article/101.html), which focuses on Go syntax/semantics (except custom generics related) and all kinds of runtime related things.\n* [Go Generics 101](https://go101.org/generics/101.html), which explains Go custom generics in detail.\n* [Go Optimizations 101](https://go101.org/optimizations/101.html), which provides some code performance optimization tricks, tips, and suggestions.\n* [Go Details & Tips 101](https://go101.org/details-and-tips/101.html), which collects many details and provides several tips in Go programming.\n\nThese books are expected to help gophers gain a deep and thorough understanding of Go\nand be helpful for both beginner and experienced Go programmers.\n\nTo get latest news of Go 101 books, please follow the official twitter account [@zigo_101](https://twitter.com/zigo_101).\n\n### Install, Update, and Read Locally\n\nIf you use Go toolchain v1.16+, then you don't need to clone the project respository:\n\n```shell\n### Install or update.\n\n$ go install go101.org/go101@latest\n\n### Read. (GOBIN path, defaulted as GOPATH/bin, should be set in PATH)\n\n$ go101\nServer started:\n   http://localhost:55555 (non-cached version)\n   http://127.0.0.1:55555 (cached version)\n```\n\nIf you use Go toolchain v1.15-, or you would make some modifications (for contribution, etc.):\n\n```shell\n### Install.\n\n$ git clone https://github.com/go101/go101.git\n\n### Update. Enter the Go 101 project directory (which\n# contains the current `README.md` file), then run\n\n$ git pull\n\n### Read. Enter the Go 101 project directory, then run\n\n$ go run .\nServer started:\n   http://localhost:55555 (non-cached version)\n   http://127.0.0.1:55555 (cached version)\n```\n\nThe start page should be opened in a browser automatically.\nIf it is not opened, please visit http://localhost:55555.\n\nOptions:\n```\n-port=1234\n-theme=light # or dark (default is light)\n```\n\nSome HTML files are generated from their corresponding markdown files.\nIf a markdown file is modified, we can run `go run . -gen`\nto synchronize its corresponding HTML file.\n\n### Contributing\n\nWelcome to improve Go 101 by:\n* Submitting corrections for all kinds of mistakes, such as typos, grammar errors, wording inaccuracies, description flaws, code bugs and broken links.\n* Suggesting interesting Go related contents.\n\nCurrent contributors are listed on [this page](https://go101.org/article/acknowledgements.html).\n\nTranslations are also welcome. Here is a list of the ongoing translation projects:\n* [中文版](https://github.com/golang101/golang101)\n\n### License\n\nPlease read the [LICENSE](LICENSE) for more details.\n"
        },
        {
          "name": "UPDATES.md",
          "type": "blob",
          "size": 0.22265625,
          "content": "The contents of this page has been moved to the [go101.org](https://gfw.go101.org) website.\n\n* [Update Histories of Go 101 Books](https://go101.org/blog/2022-02-22-history.html)\n* [Go 101 blog](https://go101.org/blog/101.html)\n\n"
        },
        {
          "name": "gen.go",
          "type": "blob",
          "size": 5.62890625,
          "content": "package main\n\nimport (\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"time\"\n)\n\nconst GeneratedFolderName = \"generated\"\n\nfunc genStaticFiles(rootURL string) {\n\tlog.SetFlags(log.Lshortfile)\n\n\twd, err := os.Getwd()\n\tif err != nil {\n\t\tlog.Fatalln(\"Can't get current path:\", err)\n\t}\n\n\tfullPath := func(relPath ...string) string {\n\t\treturn filepath.Join(append([]string{wd}, relPath...)...)\n\t}\n\n\t_, err = os.Stat(fullPath(\"web\", \"static\", \"go101\"))\n\tif err != nil {\n\t\tif os.IsNotExist(err) { //errors.Is(err, os.ErrNotExist) {\n\t\t\tlog.Fatal(\"File web/static/go101 not found. Not run in go101 folder?\")\n\t\t}\n\t\tlog.Fatal(err)\n\t}\n\n\t// load from http server\n\tloadFile := func(uri string) []byte {\n\t\tfullURL := rootURL + uri\n\n\t\tres, err := http.Get(fullURL)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Load file %s error: %s\", uri, err)\n\t\t}\n\n\t\tcontent, err := ioutil.ReadAll(res.Body)\n\n\t\tlog.Println(len(content), fullURL)\n\n\t\tres.Body.Close()\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\n\t\treturn content\n\t}\n\n\t// read from OS file system\n\treadFile := func(path string) []byte {\n\t\tdata, err := ioutil.ReadFile(path)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Read file %s error: %s\", path, err)\n\t\t}\n\t\treturn data\n\t}\n\n\treadFolder := func(path string) (filenames, subfolders []string) {\n\t\tfds, err := ioutil.ReadDir(path)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Read folder %s error: %s\", path, err)\n\t\t}\n\t\tsubfolders, filenames = make([]string, 0, len(fds)), make([]string, 0, len(fds))\n\t\tfor _, fd := range fds {\n\t\t\t// ignore links, ...\n\t\t\tif fd.IsDir() {\n\t\t\t\tsubfolders = append(subfolders, filepath.Join(path, fd.Name()))\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfilenames = append(filenames, filepath.Join(path, fd.Name()))\n\t\t}\n\t\treturn\n\t}\n\n\tvar readFolderRecursively func(path string) (filenames []string)\n\treadFolderRecursively = func(path string) (filenames []string) {\n\t\ttype Folder struct {\n\t\t\tPath string\n\t\t\tNext *Folder\n\t\t}\n\n\t\tvar head, tail *Folder\n\t\tregSubfolders := func(folders []string) {\n\t\t\tif len(folders) == 0 {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tstart := 0\n\t\t\tif head == nil {\n\t\t\t\thead = &Folder{\n\t\t\t\t\tPath: folders[0],\n\t\t\t\t}\n\t\t\t\ttail = head\n\t\t\t\tstart = 1\n\t\t\t}\n\t\t\tfor i := start; i < len(folders); i++ {\n\t\t\t\tfldr := &Folder{\n\t\t\t\t\tPath: folders[i],\n\t\t\t\t}\n\t\t\t\ttail.Next = fldr\n\t\t\t\ttail = fldr\n\t\t\t}\n\t\t}\n\n\t\tvar subfolders []string\n\t\tfilenames, subfolders = readFolder(path)\n\t\tregSubfolders(subfolders)\n\n\t\tfor head != nil {\n\t\t\tfiles, subfolders := readFolder(head.Path)\n\t\t\thead = head.Next\n\t\t\tregSubfolders(subfolders)\n\t\t\tfilenames = append(filenames, files...)\n\t\t}\n\t\treturn\n\t}\n\n\t// md -> html\n\tmd2htmls := func(group string) {\n\t\tdir := fullPath(\"pages\", group)\n\t\toutputs, err := runShellCommand(time.Minute/2, dir, \"ebooktool\", \"-md2htmls\")\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"ebooktool failed to execute in directory: %s.\\n%s\", dir, outputs)\n\t\t}\n\t}\n\n\t// tmd -> html\n\ttmd2htmls := func(group string) {\n\t\tdir := fullPath(\"pages\", group)\n\t\tfilenames, _ := readFolder(dir)\n\t\tfor _, filename := range filenames {\n\t\t\tif strings.HasSuffix(filename, \".tmd\") {\n\t\t\t\toutputs, err := runShellCommand(time.Minute/2, dir, \"tmd\", \"render\", filename)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Fatalf(\"tmd failed to execute in directory: %s.\\n%s\", dir, outputs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// collect ...\n\n\tfiles := make(map[string][]byte, 128)\n\n\tfiles[\"index.html\"] = loadFile(\"\")\n\n\t{\n\t\tdir := fullPath(\"web\", \"static\")\n\t\tfilenames := readFolderRecursively(dir)\n\t\tfor _, f := range filenames {\n\t\t\tname, err := filepath.Rel(dir, f)\n\t\t\tif err != nil {\n\t\t\t\tlog.Fatalf(\"filepath.Rel(%s, %s) error: %s\", dir, f, err)\n\t\t\t}\n\t\t\tfiles[\"static/\"+name] = readFile(f)\n\t\t}\n\t}\n\n\tcollectPageGroupFiles := func(group, urlPrefix string, collectRes bool) {\n\t\tif collectRes {\n\t\t\tdir := fullPath(\"pages\", group, \"res\")\n\t\t\tfilenames, _ := readFolder(dir)\n\t\t\tfor _, f := range filenames {\n\t\t\t\tif strings.HasSuffix(f, \".png\") || strings.HasSuffix(f, \".jpg\") {\n\t\t\t\t\tname, err := filepath.Rel(dir, f)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tlog.Fatalf(\"filepath.Rel(%s, %s) error: %s\", dir, f, err)\n\t\t\t\t\t}\n\t\t\t\t\tfiles[urlPrefix+\"res/\"+name] = readFile(f)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmd2htmls(group)\n\t\ttmd2htmls(group)\n\n\t\t{\n\t\t\tdir := fullPath(\"pages\", group)\n\t\t\tfilenames, _ := readFolder(dir)\n\t\t\tfor _, f := range filenames {\n\t\t\t\tif strings.HasSuffix(f, \".html\") {\n\t\t\t\t\tname, err := filepath.Rel(dir, f)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tlog.Fatalf(\"filepath.Rel(%s, %s) error: %s\", dir, f, err)\n\t\t\t\t\t}\n\t\t\t\t\tfiles[urlPrefix+name] = loadFile(urlPrefix + name)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t{\n\t\tinfos, err := ioutil.ReadDir(fullPath(\"pages\"))\n\t\tif err != nil {\n\t\t\tpanic(\"collect page groups error: \" + err.Error())\n\t\t}\n\n\t\tfor _, e := range infos {\n\t\t\tif e.IsDir() {\n\t\t\t\tgroup := e.Name()\n\n\t\t\t\tvar urlPrefix string\n\t\t\t\tif group == \"fundamentals\" {\n\t\t\t\t\t// For history reason, fundamentals pages use \"/article/xxx\" URLs.\n\t\t\t\t\turlPrefix = \"article/\"\n\t\t\t\t} else if group != \"website\" {\n\t\t\t\t\turlPrefix = group + \"/\"\n\t\t\t\t}\n\n\t\t\t\tvar collectRes bool\n\t\t\t\tif _, err := os.Stat(fullPath(\"pages\", group, \"res\")); err == nil {\n\t\t\t\t\tcollectRes = true\n\t\t\t\t}\n\n\t\t\t\tcollectPageGroupFiles(group, urlPrefix, collectRes)\n\t\t\t}\n\t\t}\n\t}\n\n\t// write ...\n\n\terr = os.RemoveAll(fullPath(GeneratedFolderName))\n\tif err != nil {\n\t\tlog.Fatalf(\"Remove folder %s error: %s\", GeneratedFolderName, err)\n\t}\n\n\tfor name, data := range files {\n\t\tfullFilename := fullPath(GeneratedFolderName, name)\n\n\t\tfullFilename = strings.Replace(fullFilename, \"/\", string(filepath.Separator), -1)\n\t\tfullFilename = strings.Replace(fullFilename, \"\\\\\", string(filepath.Separator), -1)\n\n\t\tif err := os.MkdirAll(filepath.Dir(fullFilename), 0700); err != nil {\n\t\t\tlog.Fatalln(\"Mkdir error:\", err)\n\t\t}\n\n\t\tif err := ioutil.WriteFile(fullFilename, data, 0644); err != nil {\n\t\t\tlog.Fatalln(\"Write file error:\", err)\n\t\t}\n\n\t\tlog.Printf(\"Generated %s (size: %d).\", name, len(data))\n\t}\n}\n"
        },
        {
          "name": "go-get.go",
          "type": "blob",
          "size": 3.26171875,
          "content": "package main\n\nimport (\n\t\"bytes\"\n\t\"net/http\"\n\t\"strings\"\n)\n\ntype GoGetInfo struct {\n\tRootPackage,\n\tGoGetSourceRepo, // only supports github now\n\tGoDocWebsite string\n}\n\n// ToDo: retire the SubPackage field.\nvar gogetInfos = map[string]GoGetInfo{\n\t\"tinyrouter\": {\n\t\tRootPackage:     \"go101.org/tinyrouter\",\n\t\tGoGetSourceRepo: \"go101/tinyrouter\",\n\t\tGoDocWebsite:    \"https://pkg.go.dev/\",\n\t},\n\t\"skia\": {\n\t\tRootPackage:     \"go101.org/skia\",\n\t\tGoGetSourceRepo: \"go101/go-skia\",\n\t\tGoDocWebsite:    \"https://pkg.go.dev/\",\n\t},\n\t\"go101\": {\n\t\tRootPackage:     \"go101.org/go101\",\n\t\tGoGetSourceRepo: \"go101/go101\",\n\t},\n\t\"golang101\": {\n\t\tRootPackage:     \"go101.org/golang101\",\n\t\tGoGetSourceRepo: \"golang101/golang101\",\n\t},\n\t\"gold\": {\n\t\tRootPackage:     \"go101.org/gold\",\n\t\tGoGetSourceRepo: \"go101/gold\",\n\t\tGoDocWebsite:    \"https://pkg.go.dev/\",\n\t},\n\t\"golds\": {\n\t\tRootPackage:     \"go101.org/golds\",\n\t\tGoGetSourceRepo: \"go101/golds\",\n\t\tGoDocWebsite:    \"https://pkg.go.dev/\",\n\t},\n\t\"ebooktool\": {\n\t\tRootPackage:     \"go101.org/ebooktool\",\n\t\tGoGetSourceRepo: \"go101/ebooktool\",\n\t\tGoDocWebsite:    \"https://pkg.go.dev/\",\n\t},\n\t\"nstd\": {\n\t\tRootPackage:     \"go101.org/nstd\",\n\t\tGoGetSourceRepo: \"go101/nstd\",\n\t\tGoDocWebsite:    \"https://pkg.go.dev/\",\n\t},\n\t\"gotv\": {\n\t\tRootPackage:     \"go101.org/gotv\",\n\t\tGoGetSourceRepo: \"go101/gotv\",\n\t\tGoDocWebsite:    \"https://pkg.go.dev/\",\n\t},\n\t\"tmd\": {\n\t\tRootPackage:     \"go101.org/tmd\",\n\t\tGoGetSourceRepo: \"go101/tmd\",\n\t\tGoDocWebsite:    \"https://pkg.go.dev/\",\n\t},\n\t\"godev\": {\n\t\tRootPackage:     \"go101.org/godev\",\n\t\tGoGetSourceRepo: \"go101/godev\",\n\t\tGoDocWebsite:    \"https://pkg.go.dev/\",\n\t},\n}\n\nfunc (go101 *Go101) ServeGoGetPages(w http.ResponseWriter, r *http.Request, rootPkg, subPkg string) {\n\tvar version string\n\tif subPkg != \"\" {\n\t\tatIndex := strings.IndexByte(subPkg, '@')\n\t\tif atIndex >= 0 {\n\t\t\tsubPkg = subPkg[:atIndex]\n\t\t\tversion = subPkg[atIndex:]\n\t\t}\n\t} else {\n\t\tatIndex := strings.IndexByte(rootPkg, '@')\n\t\tif atIndex > 0 {\n\t\t\tversion = rootPkg[atIndex:]\n\t\t\trootPkg = rootPkg[:atIndex]\n\t\t}\n\t}\n\n\t// simple handling for pkg.go.dev\n\tif len(version) < 3 || version[1] != 'v' || version[2] < '0' || version[2] > '9' {\n\t\tversion = \"\"\n\t}\n\n\tinfo, exists := gogetInfos[rootPkg]\n\tif !exists {\n\t\tif subPkg == \"\" {\n\t\t\tif rootPkg == \"\" {\n\t\t\t\trootPkg = \"index.html\"\n\t\t\t}\n\t\t\tgo101.serveGroupItem(w, r, \"website\", rootPkg)\n\t\t} else {\n\t\t\thttp.Redirect(w, r, \"/\", http.StatusNotFound)\n\t\t}\n\t\treturn\n\t}\n\n\titem := rootPkg\n\tif subPkg != \"\" {\n\t\titem += \"/\" + subPkg\n\t}\n\n\tpage, isLocal := go101.gogetPages.Get(item, version), go101.IsLocalServer()\n\tif page == nil {\n\t\tinfo.GoGetSourceRepo = \"https://github.com/\" + info.GoGetSourceRepo\n\t\tif info.GoDocWebsite != \"\" {\n\t\t\tinfo.GoDocWebsite += info.RootPackage + \"/\" + subPkg + version\n\t\t} else {\n\t\t\tinfo.GoDocWebsite = info.GoGetSourceRepo\n\t\t\tif subPkg != \"\" {\n\t\t\t\tinfo.GoDocWebsite += \"/tree/master/\" + subPkg\n\t\t\t}\n\t\t}\n\n\t\tvar err error\n\t\tvar buf bytes.Buffer\n\t\tt := retrievePageTemplate(Template_GoGet, !isLocal)\n\t\tif err = t.Execute(&buf, &info); err == nil {\n\t\t\tpage = buf.Bytes()\n\t\t} else {\n\t\t\tpage = []byte(err.Error())\n\t\t}\n\n\t\tif !isLocal {\n\t\t\tgo101.gogetPages.Set(item, version, page)\n\t\t}\n\t}\n\n\tif isLocal {\n\t\tw.Header().Set(\"Cache-Control\", \"no-cache, private, max-age=0\")\n\t} else {\n\t\tw.Header().Set(\"Cache-Control\", \"max-age=50000\") // about 14 hours\n\t}\n\tw.Write(page)\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.064453125,
          "content": "module go101.org/go101\n\ngo 1.16\n\nrequire golang.org/x/sys v0.26.0\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 0.1494140625,
          "content": "golang.org/x/sys v0.26.0 h1:KHjCJyddX0LoSTb3J+vWpupP9p0oznkqVk/IfjymZbo=\ngolang.org/x/sys v0.26.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\n"
        },
        {
          "name": "go101-embed.go",
          "type": "blob",
          "size": 3.15625,
          "content": "//go:build go1.16\n// +build go1.16\n\npackage main\n\nimport (\n\t\"embed\"\n\t//\"errors\"\n\t\"fmt\"\n\t\"html/template\"\n\t\"io/fs\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"time\"\n)\n\n//go:embed web\n//go:embed pages\nvar allFiles embed.FS\n\nvar staticFilesHandler = func() http.Handler {\n\tif wdIsGo101ProjectRoot {\n\t\treturn staticFilesHandler_NonEmbedding\n\t}\n\n\tstaticFiles, err := fs.Sub(allFiles, path.Join(\"web\", \"static\"))\n\tif err != nil {\n\t\tpanic(fmt.Sprintf(\"construct static file system error: %s\", err))\n\t}\n\n\treturn http.FileServer(http.FS(staticFiles))\n}()\n\nfunc collectPageGroups() map[string]*PageGroup {\n\tif wdIsGo101ProjectRoot {\n\t\treturn collectPageGroups_NonEmbedding()\n\t}\n\n\tentries, err := fs.ReadDir(allFiles, \"pages\")\n\tif err != nil {\n\t\tpanic(\"collect page groups (embedding) error: \" + err.Error())\n\t}\n\n\tpageGroups := make(map[string]*PageGroup, len(entries))\n\n\tfor _, e := range entries {\n\t\tif e.IsDir() {\n\t\t\tgroup, handler := e.Name(), dummyHandler\n\t\t\tresFiles, err := fs.Sub(allFiles, path.Join(\"pages\", e.Name(), \"res\"))\n\t\t\tif err == nil {\n\t\t\t\tvar urlGroup string\n\t\t\t\t// For history reason, fundamentals pages uses \"/article/xxx\" URLs.\n\t\t\t\tif group == \"fundamentals\" {\n\t\t\t\t\turlGroup = \"/article\"\n\t\t\t\t} else if group != \"website\" {\n\t\t\t\t\turlGroup = \"/\" + group\n\t\t\t\t}\n\t\t\t\thandler = http.StripPrefix(urlGroup+\"/res/\", http.FileServer(http.FS(resFiles)))\n\t\t\t} else if !os.IsNotExist(err) { // !errors.Is(err, os.ErrNotExist) {\n\t\t\t\tlog.Println(err)\n\t\t\t}\n\n\t\t\tpageGroups[group] = &PageGroup{resHandler: handler}\n\t\t}\n\t}\n\n\treturn pageGroups\n}\n\nfunc loadArticleFile(group, file string) ([]byte, error) {\n\tif wdIsGo101ProjectRoot {\n\t\treturn loadArticleFile_NonEmbedding(group, file)\n\t}\n\n\tcontent, err := allFiles.ReadFile(path.Join(\"pages\", group, file))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn content, nil\n}\n\nfunc parseTemplate(commonPaths []string, files ...string) *template.Template {\n\tif wdIsGo101ProjectRoot {\n\t\treturn parseTemplate_NonEmbedding(commonPaths, files...)\n\t}\n\n\tcp := path.Join(commonPaths...)\n\tts := make([]string, len(files))\n\tfor i, f := range files {\n\t\tts[i] = path.Join(cp, f)\n\t}\n\treturn template.Must(template.ParseFS(allFiles, ts...))\n}\n\nfunc updateGo101() {\n\tif wdIsGo101ProjectRoot {\n\t\tupdateGo101_NonEmbedding()\n\t\treturn\n\t}\n\n\tif _, err := os.Stat(filepath.Join(\".\", \"go101.go\")); err == nil {\n\t\tpullGo101Project(\"\")\n\t\treturn\n\t}\n\tif filepath.Base(os.Args[0]) == \"go101\" {\n\t\tlog.Println(\"go\", \"install\", \"go101.org/go101@latest\")\n\t\toutput, err := runShellCommand(time.Minute/2, \"\", \"go\", \"install\", \"go101.org/go101@latest\")\n\t\tif err != nil {\n\t\t\tlog.Printf(\"error: %s\\n%s\", err, output)\n\t\t} else {\n\t\t\tlog.Printf(\"done.\")\n\t\t}\n\t}\n\n\t// no ideas how to update\n}\n\n//==============================================\n\n//func printFS(title string, s fs.FS) []string {\n//\tprintln(\"==================\", title)\n//\tfiles := make([]string, 0, 256)\n//\tfs.WalkDir(s, \".\", func(path string, d fs.DirEntry, err error) error {\n//\t\tprintln(path)\n//\t\tfiles = append(files, path)\n//\t\treturn nil\n//\t})\n//\treturn files\n//}\n\n//func openFileInFS(s fs.FS, name string) {\n//\tf, err := s.Open(name)\n//\tif err != nil {\n//\t\tprintln(\"open\", name, \"error:\", err.Error())\n//\t\treturn\n//\t}\n//\tf.Close()\n//\tprintln(\"open\", name, \"ok\")\n//}\n"
        },
        {
          "name": "go101-notembed.go",
          "type": "blob",
          "size": 0.517578125,
          "content": "//go:build !go1.16\n// +build !go1.16\n\npackage main\n\nimport \"html/template\"\n\nvar staticFilesHandler = staticFilesHandler_NonEmbedding\n\nfunc collectPageGroups() map[string]*PageGroup {\n\treturn collectPageGroups_NonEmbedding()\n}\n\nfunc loadArticleFile(group, file string) ([]byte, error) {\n\treturn loadArticleFile_NonEmbedding(group, file)\n}\n\nfunc parseTemplate(commonPaths []string, files ...string) *template.Template {\n\treturn parseTemplate_NonEmbedding(commonPaths, files...)\n}\n\nfunc updateGo101() {\n\tupdateGo101_NonEmbedding()\n}\n"
        },
        {
          "name": "go101.go",
          "type": "blob",
          "size": 13.0390625,
          "content": "package main\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t//\"errors\"\n\t\"go/build\"\n\t\"html\"\n\t\"html/template\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype Go101 struct {\n\tstaticHandler http.Handler\n\tisLocalServer bool\n\tpageGroups    map[string]*PageGroup\n\tarticlePages  Cache\n\tgogetPages    Cache\n\tserverMutex   sync.Mutex\n\ttheme         string\n}\n\ntype PageGroup struct {\n\tresHandler   http.Handler\n\tindexContent template.HTML\n}\n\nvar go101 = &Go101{\n\tstaticHandler: http.StripPrefix(\"/static/\", staticFilesHandler),\n\tisLocalServer: false, // may be modified later\n\tpageGroups:    collectPageGroups(),\n}\n\nfunc init() {\n\tfor group, pg := range go101.pageGroups {\n\t\tpg.indexContent = retrieveIndexContent(group)\n\t}\n}\n\nfunc (go101 *Go101) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tvar group, item string\n\tif tokens := strings.SplitN(r.URL.Path[1:], \"/\", 2); len(tokens) == 2 {\n\t\tgroup, item = tokens[0], tokens[1]\n\t} else { // len(tokens) == 1\n\t\titem = tokens[0]\n\t}\n\n\tswitch go101.PreHandle(w, r); group {\n\tdefault:\n\t\tgo101.ServeGoGetPages(w, r, group, item)\n\tcase \"\":\n\t\tgo101.ServeGoGetPages(w, r, item, \"\")\n\tcase \"res\":\n\t\tgo101.serveGroupItem(w, r, \"website\", r.URL.Path[1:])\n\tcase \"static\":\n\t\tw.Header().Set(\"Cache-Control\", \"max-age=31536000\") // one year\n\t\tgo101.staticHandler.ServeHTTP(w, r)\n\tcase \"article\":\n\t\t// for history reason, fundamentals pages use \"article/xxx\" URLs\n\t\tgo101.serveGroupItem(w, r, \"fundamentals\", item)\n\tcase \"optimizations\", \"details-and-tips\", \"quizzes\", \"generics\",\n\t\t\"apps-and-libs\", \"blog\", \"q-and-a\", \"bugs\", \"practices\":\n\t\tgo101.serveGroupItem(w, r, group, item)\n\t}\n}\n\nfunc (go101 *Go101) serveGroupItem(w http.ResponseWriter, r *http.Request, group, item string) {\n\titem = strings.ToLower(item)\n\tif strings.HasPrefix(item, \"res/\") {\n\t\tw.Header().Set(\"Cache-Control\", \"max-age=31536000\") // one year\n\t\tgo101.pageGroups[group].resHandler.ServeHTTP(w, r)\n\t} else if !go101.RedirectArticlePage(w, r, group, item) {\n\t\tgo101.RenderArticlePage(w, r, group, item)\n\t}\n}\n\nfunc (go101 *Go101) PreHandle(w http.ResponseWriter, r *http.Request) {\n\tgo101.serverMutex.Lock()\n\tdefer go101.serverMutex.Unlock()\n\n\tlocalServer := isLocalRequest(r)\n\tif go101.isLocalServer != localServer {\n\t\tgo101.isLocalServer = localServer\n\t\tif go101.isLocalServer {\n\t\t\tunloadPageTemplates()      // loaded in one init function\n\t\t\tgo101.articlePages.Clear() // invalidate article caches\n\t\t\tgo101.gogetPages.Clear()   // invalidate go-gets caches\n\t\t}\n\t}\n}\n\nfunc (go101 *Go101) IsLocalServer() (isLocal bool) {\n\tgo101.serverMutex.Lock()\n\tdefer go101.serverMutex.Unlock()\n\tisLocal = go101.isLocalServer\n\treturn\n}\n\nfunc pullGo101Project(wd string) {\n\t<-time.After(time.Minute / 2)\n\tgitPull(wd)\n\tfor {\n\t\t<-time.After(time.Hour * 24)\n\t\tgitPull(wd)\n\t}\n}\n\n//===================================================\n// pages\n//==================================================\n\ntype Article struct {\n\tContent, Title, Index template.HTML\n\tTitleWithoutTags      string\n\tGroup, Filename       string\n\tFilenameWithoutExt    string\n}\n\nvar schemes = map[bool]string{false: \"http://\", true: \"https://\"}\n\nfunc (go101 *Go101) RenderArticlePage(w http.ResponseWriter, r *http.Request, group, file string) {\n\tpage, isLocal := go101.articlePages.Get(group, file), go101.IsLocalServer()\n\tif page == nil {\n\t\tarticle, err := retrieveArticleContent(group, file)\n\t\tif err == nil {\n\t\t\tarticle.Index = disableArticleLink(go101.pageGroups[group].indexContent, file)\n\t\t\tpageParams := map[string]interface{}{\n\t\t\t\t\"Article\": article,\n\t\t\t\t\"Title\":   article.TitleWithoutTags,\n\t\t\t\t\"Theme\":   go101.theme,\n\t\t\t\t//\"IsLocalServer\": isLocal,\n\t\t\t\t\"GoVersion\": runtime.Version(),\n\t\t\t}\n\t\t\tt := retrievePageTemplate(Template_Article, !isLocal)\n\t\t\tvar buf bytes.Buffer\n\t\t\tif err = t.Execute(&buf, pageParams); err == nil {\n\t\t\t\tpage = buf.Bytes()\n\t\t\t} else {\n\t\t\t\tpage = []byte(err.Error())\n\t\t\t}\n\t\t} else if os.IsNotExist(err) {\n\t\t\tpage = []byte{} // blank page means page not found.\n\t\t}\n\n\t\tif !isLocal {\n\t\t\tgo101.articlePages.Set(group, file, page)\n\t\t}\n\t}\n\n\tif len(page) == 0 { // blank page means page not found.\n\t\tlog.Printf(\"article page %s/%s is not found\", group, file)\n\t\t//w.Header().Set(\"Cache-Control\", \"no-cache, private, max-age=0\")\n\t\thttp.Redirect(w, r, \"/\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\tif isLocal {\n\t\tw.Header().Set(\"Cache-Control\", \"no-cache, private, max-age=0\")\n\t} else {\n\t\tw.Header().Set(\"Cache-Control\", \"max-age=50000\") // about 14 hours\n\t}\n\tw.Write(page)\n}\n\nvar H1, _H1 = []byte(\"<h1\"), []byte(\"</h1>\")\nvar H2, _H2 = []byte(\"<h2\"), []byte(\"</h2>\")\n\nconst MaxTitleLen = 256\n\nvar TagSigns = [2]rune{'<', '>'}\n\nfunc retrieveArticleContent(group, file string) (Article, error) {\n\tarticle := Article{}\n\tcontent, err := loadArticleFile(group, file)\n\tif err != nil {\n\t\treturn article, err\n\t}\n\n\tarticle.Content = template.HTML(content)\n\tarticle.Group = group\n\tarticle.Filename = file\n\tarticle.FilenameWithoutExt = strings.TrimSuffix(file, \".html\")\n\n\t// retrieve titles\n\tsplitTitleContent := func(startTag, endTag []byte) (int, int) {\n\t\tj, i := -1, bytes.Index(content, startTag)\n\t\tif i >= 0 {\n\t\t\ti += len(startTag)\n\t\t\tj = bytes.Index(bytesWithLength(content[i:], MaxTitleLen), endTag)\n\t\t}\n\t\tif j < 0 {\n\t\t\treturn -1, 0\n\t\t}\n\t\treturn i - len(startTag), i + j + len(endTag)\n\t}\n\n\ttitleStart, contentStart := splitTitleContent(H1, _H1)\n\tif titleStart < 0 {\n\t\ttitleStart, contentStart = splitTitleContent(H2, _H2)\n\t}\n\tif titleStart < 0 {\n\t\t//log.Println(\"retrieveTitlesForArticle failed:\", group, file)\n\t} else {\n\t\tarticle.Title = template.HTML(html.UnescapeString(string(article.Content[titleStart:contentStart])))\n\t\tarticle.Content = article.Content[contentStart:]\n\t\tk, s := 0, make([]rune, 0, MaxTitleLen)\n\t\tfor _, r := range article.Title {\n\t\t\tif r == TagSigns[k] {\n\t\t\t\tk = (k + 1) & 1\n\t\t\t} else if k == 0 {\n\t\t\t\ts = append(s, r)\n\t\t\t}\n\t\t}\n\t\tarticle.TitleWithoutTags = string(s)\n\t}\n\n\treturn article, nil\n}\n\nfunc retrieveIndexContent(group string) template.HTML {\n\tpage101, err := retrieveArticleContent(group, \"101.html\")\n\tif err != nil {\n\t\tif os.IsNotExist(err) { // errors.Is(err, os.ErrNotExist) {\n\t\t\treturn \"\"\n\t\t}\n\t\tpanic(err)\n\t}\n\tcontent := []byte(page101.Content)\n\tstart := []byte(\"<!-- index starts (don't remove) -->\")\n\ti := bytes.Index(content, start)\n\tif i < 0 {\n\t\t//panic(\"index not found\")\n\t\t//log.Printf(\"index not found in %s/101/html\", group)\n\t\treturn \"\"\n\t}\n\tcontent = content[i+len(start):]\n\tend := []byte(\"<!-- index ends (don't remove) -->\")\n\ti = bytes.Index(content, end)\n\tif i < 0 {\n\t\t//panic(\"index not found\")\n\t\t//log.Printf(\"index not found in %s/101/html\", group)\n\t\treturn \"\"\n\t}\n\tcontent = content[:i]\n\t//comments := [][]byte{\n\t//\t[]byte(\"<!-- (to remove) for printing\"),\n\t//\t[]byte(\"(to remove) -->\"),\n\t//}\n\t//for _, cmt := range comments {\n\t//\ti = bytes.Index(content, cmt)\n\t//\tif i >= 0 {\n\t//\t\tfilleBytes(content[i:i+len(cmt)], ' ')\n\t//\t}\n\t//}\n\treturn template.HTML(content)\n}\n\nvar (\n\taStart = []byte(`<a `)\n\taEnd   = []byte(`</a>`)\n\taHref  = []byte(`href=\"`)\n\taID    = []byte(`id=\"i-`)\n\t// The lengths of the above two must be equal.\n)\n\nfunc disableArticleLink(htmlContent template.HTML, page string) (r template.HTML) {\n\tcontent := []byte(htmlContent)\n\ti := bytes.Index(content, []byte(page))\n\tif i >= 0 {\n\t\tj := bytes.LastIndex(content[:i], aHref)\n\t\tif j >= 0 {\n\t\t\tk := bytes.LastIndex(content[:j], aStart)\n\t\t\tif k >= 0 {\n\t\t\t\tl := bytes.Index(content[i+len(page):], aEnd)\n\t\t\t\tif l >= 0 {\n\t\t\t\t\tl += i + len(page)\n\t\t\t\t\tcontent[k+1] = 'b'\n\t\t\t\t\tcontent[l+2] = 'b'\n\t\t\t\t\tcopy(content[j:], aID)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn template.HTML(content)\n}\n\n//===================================================\n// templates\n//==================================================\n\ntype PageTemplate uint\n\nconst (\n\tTemplate_Article PageTemplate = iota\n\tTemplate_GoGet\n\tTemplate_Redirect\n\tNumPageTemplates\n)\n\nvar pageTemplates [NumPageTemplates + 1]*template.Template\nvar pageTemplatesMutex sync.Mutex //\nvar pageTemplatesCommonPaths = []string{\"web\", \"templates\"}\n\nfunc init() {\n\tfor i := range pageTemplates {\n\t\tretrievePageTemplate(PageTemplate(i), true)\n\t}\n}\n\nfunc retrievePageTemplate(which PageTemplate, cacheIt bool) *template.Template {\n\tif which > NumPageTemplates {\n\t\twhich = NumPageTemplates\n\t}\n\n\tpageTemplatesMutex.Lock()\n\tt := pageTemplates[which]\n\tpageTemplatesMutex.Unlock()\n\n\tif t == nil {\n\t\tswitch which {\n\t\tcase Template_Article:\n\t\t\tt = parseTemplate(pageTemplatesCommonPaths, \"article\")\n\t\tcase Template_GoGet:\n\t\t\tt = parseTemplate(pageTemplatesCommonPaths, \"go-get\")\n\t\tcase Template_Redirect:\n\t\t\tt = parseTemplate(pageTemplatesCommonPaths, \"redirect\")\n\t\tdefault:\n\t\t\tt = template.New(\"blank\")\n\t\t}\n\n\t\tif cacheIt {\n\t\t\tpageTemplatesMutex.Lock()\n\t\t\tpageTemplates[which] = t\n\t\t\tpageTemplatesMutex.Unlock()\n\t\t}\n\t}\n\treturn t\n}\n\nfunc unloadPageTemplates() {\n\tpageTemplatesMutex.Lock()\n\tdefer pageTemplatesMutex.Unlock()\n\tfor i := range pageTemplates {\n\t\tpageTemplates[i] = nil\n\t}\n}\n\n//===================================================\n// non-embedding functions\n//===================================================\n\nvar dummyHandler http.Handler = http.HandlerFunc(func(http.ResponseWriter, *http.Request) {})\n\nvar staticFilesHandler_NonEmbedding = http.FileServer(http.Dir(filepath.Join(rootPath, \"web\", \"static\")))\n\nfunc collectPageGroups_NonEmbedding() map[string]*PageGroup {\n\tinfos, err := ioutil.ReadDir(filepath.Join(rootPath, \"pages\"))\n\tif err != nil {\n\t\tpanic(\"collect page groups error: \" + err.Error())\n\t}\n\n\tpageGroups := make(map[string]*PageGroup, len(infos))\n\n\tfor _, e := range infos {\n\t\tif e.IsDir() {\n\t\t\tgroup, handler := e.Name(), dummyHandler\n\t\t\tresPath := filepath.Join(rootPath, \"pages\", group, \"res\")\n\t\t\tif _, err := os.Stat(resPath); err == nil {\n\t\t\t\tvar urlPrefix string\n\t\t\t\t// For history reason, fundamentals pages uses \"/article/xxx\" URLs.\n\t\t\t\tif group == \"fundamentals\" {\n\t\t\t\t\turlPrefix = \"/article\"\n\t\t\t\t} else if group != \"website\" {\n\t\t\t\t\turlPrefix = \"/\" + group\n\t\t\t\t}\n\t\t\t\thandler = http.StripPrefix(urlPrefix+\"/res/\", http.FileServer(http.Dir(resPath)))\n\t\t\t} else if !os.IsNotExist(err) { // !errors.Is(err, os.ErrNotExist) {\n\t\t\t\tlog.Println(err)\n\t\t\t}\n\n\t\t\tpageGroups[group] = &PageGroup{resHandler: handler}\n\t\t}\n\t}\n\n\treturn pageGroups\n}\n\nfunc loadArticleFile_NonEmbedding(group, file string) ([]byte, error) {\n\treturn ioutil.ReadFile(filepath.Join(rootPath, \"pages\", group, file))\n}\n\nfunc parseTemplate_NonEmbedding(commonPaths []string, files ...string) *template.Template {\n\tcp := filepath.Join(commonPaths...)\n\tts := make([]string, len(files))\n\tfor i, f := range files {\n\t\tts[i] = filepath.Join(rootPath, cp, f)\n\t}\n\treturn template.Must(template.ParseFiles(ts...))\n}\n\nfunc updateGo101_NonEmbedding() {\n\tpullGo101Project(rootPath)\n}\n\nvar rootPath, wdIsGo101ProjectRoot = findGo101ProjectRoot()\n\nfunc findGo101ProjectRoot() (string, bool) {\n\tif _, err := os.Stat(filepath.Join(\".\", \"go101.go\")); err == nil {\n\t\treturn \".\", true\n\t}\n\n\tfor _, name := range []string{\n\t\t\"gitlab.com/go101/go101\",\n\t\t\"gitlab.com/Go101/go101\",\n\t\t\"github.com/go101/go101\",\n\t\t\"github.com/Go101/go101\",\n\t} {\n\t\tpkg, err := build.Import(name, \"\", build.FindOnly)\n\t\tif err == nil {\n\t\t\treturn pkg.Dir, false\n\t\t}\n\t}\n\n\treturn \".\", false\n}\n\n//===================================================\n// utils\n//===================================================\n\nfunc bytesWithLength(s []byte, n int) []byte {\n\tif n > len(s) {\n\t\tn = len(s)\n\t}\n\treturn s[:n]\n}\n\nfunc filleBytes(s []byte, b byte) {\n\tfor i := range s {\n\t\ts[i] = b\n\t}\n}\n\nfunc openBrowser(url string) error {\n\tvar cmd string\n\tvar args []string\n\tswitch runtime.GOOS {\n\tcase \"windows\":\n\t\tcmd = \"cmd\"\n\t\targs = []string{\"/c\", \"start\"}\n\tcase \"darwin\":\n\t\tcmd = \"open\"\n\tdefault: // \"linux\", \"freebsd\", \"openbsd\", \"netbsd\"\n\t\tcmd = \"xdg-open\"\n\t}\n\treturn exec.Command(cmd, append(args, url)...).Start()\n}\n\nfunc isLocalRequest(r *http.Request) bool {\n\tend := strings.Index(r.Host, \":\")\n\tif end < 0 {\n\t\tend = len(r.Host)\n\t}\n\thostname := r.Host[:end]\n\treturn hostname == \"localhost\" // || hostname == \"127.0.0.1\" // 127.* for local cached version now\n}\n\nfunc runShellCommand(timeout time.Duration, wd string, cmd string, args ...string) ([]byte, error) {\n\tctx, cancel := context.WithTimeout(context.Background(), timeout)\n\tdefer cancel()\n\tcommand := exec.CommandContext(ctx, cmd, args...)\n\tcommand.Dir = wd\n\treturn command.CombinedOutput()\n}\n\nfunc gitPull(wd string) {\n\toutput, err := runShellCommand(time.Minute/2, wd, \"git\", \"pull\")\n\tif err != nil {\n\t\tlog.Println(\"git pull:\", err)\n\t} else {\n\t\tlog.Printf(\"git pull: %s\", output)\n\t}\n}\n\nfunc goGet(pkgPath, wd string) {\n\t_, err := runShellCommand(time.Minute/2, wd, \"go\", \"get\", \"-u\", pkgPath)\n\tif err != nil {\n\t\tlog.Println(\"go get -u \"+pkgPath+\":\", err)\n\t} else {\n\t\tlog.Println(\"go get -u \" + pkgPath + \" succeeded.\")\n\t}\n}\n\n//===================================================\n// cache\n//===================================================\n\ntype Cache struct {\n\tsync.Mutex\n\tpages map[[2]string][]byte\n}\n\nfunc (c *Cache) Get(group, name string) []byte {\n\tc.Lock()\n\tdefer c.Unlock()\n\tpage := c.pages[[2]string{group, name}]\n\treturn page\n}\n\nfunc (c *Cache) Set(group, name string, page []byte) {\n\tc.Lock()\n\tdefer c.Unlock()\n\tif c.pages == nil {\n\t\tc.pages = map[[2]string][]byte{}\n\t}\n\tc.pages[[2]string{group, name}] = page\n}\n\nfunc (c *Cache) Clear() {\n\tc.Lock()\n\tdefer c.Unlock()\n\tc.pages = map[[2]string][]byte{}\n}\n"
        },
        {
          "name": "main.go",
          "type": "blob",
          "size": 2.0361328125,
          "content": "package main\n\nimport (\n\t\"context\"\n\t\"flag\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"net/http\"\n\t\"os\"\n\t\"os/signal\"\n\t\"strings\"\n\t\"syscall\"\n\t\"time\"\n)\n\nvar portFlag = flag.String(\"port\", \"55555\", \"server port\")\nvar genFlag = flag.Bool(\"gen\", false, \"HTML generation mode?\")\nvar themeFlag = flag.String(\"theme\", \"\", \"theme (dark | light)\")\nvar nobFlag = flag.Bool(\"nob\", false, \"not open browswer?\")\n\nvar listenConfig net.ListenConfig\n\nfunc main() {\n\tlog.SetFlags(0)\n\tflag.Parse()\n\n\tport, isAppEngine := *portFlag, false\n\tif prt := os.Getenv(\"PORT\"); prt != \"\" { // appengine std\n\t\tport = prt\n\t\tisAppEngine = true\n\t}\n\taddr, err := net.ResolveTCPAddr(\"tcp\", fmt.Sprintf(\":%v\", port))\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\nRetry:\n\t//l, err := net.ListenTCP(\"tcp\", addr)\n\tl, err := listenConfig.Listen(context.Background(), \"tcp\", addr.String())\n\tif err != nil {\n\t\tif strings.Index(err.Error(), \"bind: address already in use\") >= 0 {\n\t\t\taddr.Port++\n\t\t\tif addr.Port < 65535 {\n\t\t\t\tgoto Retry\n\t\t\t}\n\t\t}\n\t\tlog.Fatal(err)\n\t}\n\tdefer l.Close()\n\n\tgo101.theme = *themeFlag\n\n\tgenMode, rootURL := *genFlag, fmt.Sprintf(\"http://localhost:%v/\", addr.Port)\n\tif !genMode && !isAppEngine {\n\t\tif !*nobFlag {\n\t\t\terr = openBrowser(rootURL)\n\t\t\tif err != nil {\n\t\t\t\tlog.Println(err)\n\t\t\t}\n\t\t}\n\n\t\tgo updateGo101()\n\t}\n\n\thttpServer := &http.Server{\n\t\tHandler:      go101,\n\t\tWriteTimeout: 10 * time.Second,\n\t\tReadTimeout:  5 * time.Second,\n\t}\n\n\trunServer := func() {\n\t\tlog.Println(\"Server started:\")\n\t\tlog.Printf(\"   http://localhost:%v (non-cached version)\\n\", addr.Port)\n\t\tlog.Printf(\"   http://127.0.0.1:%v (cached version)\\n\", addr.Port)\n\t\thttpServer.Serve(l)\n\t}\n\n\tshutdownServer := func() {\n\t\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\t\tdefer cancel()\n\n\t\tif err := httpServer.Shutdown(ctx); err != nil {\n\t\t\tlog.Fatalf(\"Server shutdown error: %s\", err)\n\t\t}\n\t\tlog.Println(\"Server shutdown.\")\n\t}\n\n\tif genMode {\n\t\tgo runServer()\n\t\tgenStaticFiles(rootURL)\n\t\tshutdownServer()\n\t\treturn\n\t}\n\n\tc := make(chan os.Signal, 1)\n\tsignal.Notify(c, syscall.SIGINT, syscall.SIGTERM)\n\n\tgo runServer()\n\t<-c\n\tshutdownServer()\n}\n"
        },
        {
          "name": "net_darwin.go",
          "type": "blob",
          "size": 0.408203125,
          "content": "package main\n\nimport (\n\t\"net\"\n\t\"syscall\"\n\t\"golang.org/x/sys/unix\"\n)\n\nfunc init() {\n\tlistenConfig = net.ListenConfig{\n\t\tControl: func(network, address string, c syscall.RawConn) error {\n\t\t    var opErr error\n\t\t    if err := c.Control(func(fd uintptr) {\n\t\t        opErr = unix.SetsockoptInt(int(fd), unix.SOL_SOCKET, unix.SO_REUSEPORT, 1)\n\t\t    }); err != nil {\n\t\t        return err\n\t\t    }\n\t\t    return opErr\n\t\t},\n\t}\n}\n"
        },
        {
          "name": "net_linux.go",
          "type": "blob",
          "size": 0.408203125,
          "content": "package main\n\nimport (\n\t\"net\"\n\t\"syscall\"\n\t\"golang.org/x/sys/unix\"\n)\n\nfunc init() {\n\tlistenConfig = net.ListenConfig{\n\t\tControl: func(network, address string, c syscall.RawConn) error {\n\t\t    var opErr error\n\t\t    if err := c.Control(func(fd uintptr) {\n\t\t        opErr = unix.SetsockoptInt(int(fd), unix.SOL_SOCKET, unix.SO_REUSEPORT, 1)\n\t\t    }); err != nil {\n\t\t        return err\n\t\t    }\n\t\t    return opErr\n\t\t},\n\t}\n}\n"
        },
        {
          "name": "net_windows.go",
          "type": "blob",
          "size": 0.4306640625,
          "content": "package main\n\nimport (\n\t\"net\"\n\t\"syscall\"\n\t\"golang.org/x/sys/windows\"\n)\n\nfunc init() {\n\tlistenConfig = net.ListenConfig{\n\t\tControl: func(network, address string, c syscall.RawConn) error {\n\t\t    var opErr error\n\t\t    if err := c.Control(func(fd uintptr) {\n\t\t        opErr = windows.SetsockoptInt(windows.Handle(fd), windows.SOL_SOCKET, windows.SO_REUSEADDR, 1)\n\t\t    }); err != nil {\n\t\t        return err\n\t\t    }\n\t\t    return opErr\n\t\t},\n\t}\n}\n"
        },
        {
          "name": "pages",
          "type": "tree",
          "content": null
        },
        {
          "name": "redirects.go",
          "type": "blob",
          "size": 1.9326171875,
          "content": "package main\n\nimport (\n\t\"bytes\"\n\t\"log\"\n\t\"net/http\"\n)\n\nvar redirectPages = map[[2]string][2]string{\n\t{\"fundamentals\", \"go-sdk.html\"}:                   {\"fundamentals\", \"go-toolchain.html\"},\n\t{\"fundamentals\", \"tools.html\"}:                    {\"apps-and-libs\", \"101.html\"},\n\t{\"fundamentals\", \"tool-gold.html\"}:                {\"apps-and-libs\", \"golds.html\"},\n\t{\"fundamentals\", \"tool-golds.html\"}:               {\"apps-and-libs\", \"golds.html\"},\n\t{\"fundamentals\", \"bounds-check-elimination.html\"}: {\"optimizations\", \"5-bce.html\"},\n}\n\nfunc (go101 *Go101) RedirectArticlePage(w http.ResponseWriter, r *http.Request, group, file string) bool {\n\tredirectPage, ok := redirectPages[[2]string{group, file}]\n\tif ok {\n\t\tpage, isLocal := go101.articlePages.Get(group, file), go101.IsLocalServer()\n\t\tif page == nil {\n\t\t\tpageParams := map[string]interface{}{\n\t\t\t\t\"RedirectPage\": \"/\" + redirectPage[0] + \"/\" + redirectPage[1],\n\t\t\t\t//\"IsLocalServer\": isLocal,\n\n\t\t\t\t//\"Value\": func() func(string, ...interface{}) interface{} {\n\t\t\t\t//\tvar kvs = map[string]interface{}{}\n\t\t\t\t//\treturn func(k string, v ...interface{}) interface{} {\n\t\t\t\t//\t\tif len(v) == 0 {\n\t\t\t\t//\t\t\treturn kvs[k]\n\t\t\t\t//\t\t}\n\t\t\t\t//\t\tkvs[k] = v[0]\n\t\t\t\t//\t\treturn \"\"\n\t\t\t\t//\t}\n\t\t\t\t//}(),\n\t\t\t}\n\n\t\t\tt := retrievePageTemplate(Template_Redirect, !isLocal)\n\t\t\tvar buf bytes.Buffer\n\t\t\tif err := t.Execute(&buf, pageParams); err == nil {\n\t\t\t\tpage = buf.Bytes()\n\t\t\t} else {\n\t\t\t\tpage = []byte(err.Error())\n\t\t\t}\n\n\t\t\tif !isLocal {\n\t\t\t\tgo101.articlePages.Set(group, file, page)\n\t\t\t}\n\t\t}\n\n\t\tif len(page) == 0 { // blank page means page not found.\n\t\t\tlog.Printf(\"article page %s/%s is not found\", group, file)\n\t\t\t//w.Header().Set(\"Cache-Control\", \"no-cache, private, max-age=0\")\n\t\t\thttp.Redirect(w, r, \"/article/101.html\", http.StatusNotFound)\n\t\t} else if isLocal {\n\t\t\tw.Header().Set(\"Cache-Control\", \"no-cache, private, max-age=0\")\n\t\t} else {\n\t\t\tw.Header().Set(\"Cache-Control\", \"max-age=50000\") // about 14 hours\n\t\t}\n\t\tw.Write(page)\n\t}\n\n\treturn ok\n}\n"
        },
        {
          "name": "web",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}