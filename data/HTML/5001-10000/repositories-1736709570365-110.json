{
  "metadata": {
    "timestamp": 1736709570365,
    "page": 110,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjEyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "LingDong-/shan-shui-inf",
      "stars": 5539,
      "defaultBranch": "master",
      "files": [
        {
          "name": "CNAME",
          "type": "blob",
          "size": 0.02734375,
          "content": "shan-shui-inf.lingdong.works"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0458984375,
          "content": "MIT License\n\nCopyright (c) 2018 Lingdong Huang\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 0.763671875,
          "content": "# {Shan, Shui}*\nProcedurally-generated vector-format infinitely-scrolling Chinese landscape for the browser.\nGenerate your own on https://lingdong-.github.io/shan-shui-inf/ (or [Alternative link](https://shan-shui-inf.glitch.me)).\n\nSome examples:\n![Screenshot1](/screenshots/screen001.jpg?raw=true \"\")\n![Screenshot2](/screenshots/screen002.jpg?raw=true \"\")\n\n{Shan, Shui}\\* is inspired by [traditional Chinese landscape scrolls](https://en.wikipedia.org/wiki/Shan_shui) (such as [this](https://en.wikipedia.org/wiki/Dwelling_in_the_Fuchun_Mountains) and [this](https://en.wikipedia.org/wiki/Wang_Ximeng)) and uses noises and mathematical functions to model the mountains and trees from scratch. It is written entirely in javascript and outputs Scalable Vector Graphics (SVG) format.\n"
        },
        {
          "name": "index.html",
          "type": "blob",
          "size": 123.5927734375,
          "content": "<script id=\"PRNG\">\n  var Prng = new function() {\n    this.s = 1234;\n    this.p = 999979; //9887//983\n    this.q = 999983; //9967//991\n    this.m = this.p * this.q;\n    this.hash = function(x) {\n      var y = window.btoa(JSON.stringify(x));\n      var z = 0;\n      for (var i = 0; i < y.length; i++) {\n        z += y.charCodeAt(i) * Math.pow(128, i);\n      }\n      return z;\n    };\n    this.seed = function(x) {\n      if (x == undefined) {\n        x = new Date().getTime();\n      }\n      var y = 0;\n      var z = 0;\n      function redo() {\n        y = (Prng.hash(x) + z) % Prng.m;\n        z += 1;\n      }\n      while (y % Prng.p == 0 || y % Prng.q == 0 || y == 0 || y == 1) {\n        redo();\n      }\n      Prng.s = y;\n      console.log([\"int seed\", Prng.s]);\n      for (var i = 0; i < 10; i++) {\n        Prng.next();\n      }\n    };\n    this.next = function() {\n      Prng.s = (Prng.s * Prng.s) % Prng.m;\n      return Prng.s / Prng.m;\n    };\n    this.test = function(f) {\n      var F =\n        f ||\n        function() {\n          return Prng.next();\n        };\n      var t0 = new Date().getTime();\n      var chart = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n      for (var i = 0; i < 10000000; i++) {\n        chart[Math.floor(F() * 10)] += 1;\n      }\n      console.log(chart);\n      console.log(\"finished in \" + (new Date().getTime() - t0));\n      return chart;\n    };\n  }();\n  Math.random = function() {\n    return Prng.next();\n  };\n  Math.seed = function(x) {\n    return Prng.seed(x);\n  };\n</script>\n\n<script>\n  function parseArgs(key2f) {\n    var par = window.location.href.split(\"?\")[1];\n    if (par == undefined) {\n      return;\n    }\n    par = par.split(\"&\");\n    for (var i = 0; i < par.length; i++) {\n      var e = par[i].split(\"=\");\n      try {\n        key2f[e[0]](e[1]);\n      } catch (e) {\n        console.log(e);\n      }\n    }\n  }\n  SEED = \"\" + new Date().getTime();\n  parseArgs({\n    seed: function(x) {\n      SEED = x == \"\" ? SEED : x;\n    },\n  });\n  Math.seed(SEED);\n  console.log(Prng.seed);\n</script>\n\n<script id=\"PerlinNoise\">\n  //https://raw.githubusercontent.com/processing/p5.js/master/src/math/noise.js\n  var Noise = new function() {\n    var PERLIN_YWRAPB = 4;\n    var PERLIN_YWRAP = 1 << PERLIN_YWRAPB;\n    var PERLIN_ZWRAPB = 8;\n    var PERLIN_ZWRAP = 1 << PERLIN_ZWRAPB;\n    var PERLIN_SIZE = 4095;\n    var perlin_octaves = 4;\n    var perlin_amp_falloff = 0.5;\n    var scaled_cosine = function(i) {\n      return 0.5 * (1.0 - Math.cos(i * Math.PI));\n    };\n    var perlin;\n    this.noise = function(x, y, z) {\n      y = y || 0;\n      z = z || 0;\n      if (perlin == null) {\n        perlin = new Array(PERLIN_SIZE + 1);\n        for (var i = 0; i < PERLIN_SIZE + 1; i++) {\n          perlin[i] = Math.random();\n        }\n      }\n      if (x < 0) {\n        x = -x;\n      }\n      if (y < 0) {\n        y = -y;\n      }\n      if (z < 0) {\n        z = -z;\n      }\n      var xi = Math.floor(x),\n        yi = Math.floor(y),\n        zi = Math.floor(z);\n      var xf = x - xi;\n      var yf = y - yi;\n      var zf = z - zi;\n      var rxf, ryf;\n      var r = 0;\n      var ampl = 0.5;\n      var n1, n2, n3;\n      for (var o = 0; o < perlin_octaves; o++) {\n        var of = xi + (yi << PERLIN_YWRAPB) + (zi << PERLIN_ZWRAPB);\n        rxf = scaled_cosine(xf);\n        ryf = scaled_cosine(yf);\n        n1 = perlin[of & PERLIN_SIZE];\n        n1 += rxf * (perlin[(of + 1) & PERLIN_SIZE] - n1);\n        n2 = perlin[(of + PERLIN_YWRAP) & PERLIN_SIZE];\n        n2 += rxf * (perlin[(of + PERLIN_YWRAP + 1) & PERLIN_SIZE] - n2);\n        n1 += ryf * (n2 - n1);\n        of += PERLIN_ZWRAP;\n        n2 = perlin[of & PERLIN_SIZE];\n        n2 += rxf * (perlin[(of + 1) & PERLIN_SIZE] - n2);\n        n3 = perlin[(of + PERLIN_YWRAP) & PERLIN_SIZE];\n        n3 += rxf * (perlin[(of + PERLIN_YWRAP + 1) & PERLIN_SIZE] - n3);\n        n2 += ryf * (n3 - n2);\n        n1 += scaled_cosine(zf) * (n2 - n1);\n        r += n1 * ampl;\n        ampl *= perlin_amp_falloff;\n        xi <<= 1;\n        xf *= 2;\n        yi <<= 1;\n        yf *= 2;\n        zi <<= 1;\n        zf *= 2;\n        if (xf >= 1.0) {\n          xi++;\n          xf--;\n        }\n        if (yf >= 1.0) {\n          yi++;\n          yf--;\n        }\n        if (zf >= 1.0) {\n          zi++;\n          zf--;\n        }\n      }\n      return r;\n    };\n    this.noiseDetail = function(lod, falloff) {\n      if (lod > 0) {\n        perlin_octaves = lod;\n      }\n      if (falloff > 0) {\n        perlin_amp_falloff = falloff;\n      }\n    };\n    this.noiseSeed = function(seed) {\n      var lcg = (function() {\n        var m = 4294967296,\n          a = 1664525,\n          c = 1013904223,\n          seed,\n          z;\n        return {\n          setSeed: function(val) {\n            z = seed = (val == null ? Math.random() * m : val) >>> 0;\n          },\n          getSeed: function() {\n            return seed;\n          },\n          rand: function() {\n            z = (a * z + c) % m;\n            return z / m;\n          },\n        };\n      })();\n      lcg.setSeed(seed);\n      perlin = new Array(PERLIN_SIZE + 1);\n      for (var i = 0; i < PERLIN_SIZE + 1; i++) {\n        perlin[i] = lcg.rand();\n      }\n    };\n  }();\n</script>\n\n<script id=\"PolyTools\">\n  var PolyTools = new function() {\n    this.midPt = function() {\n      var plist =\n        arguments.length == 1 ? arguments[0] : Array.apply(null, arguments);\n      return plist.reduce(\n        function(acc, v) {\n          /*       if (v == undefined || acc == undefined){\n        console.log(\"ERRR\");\n        console.log(plist)\n        return [0,0]\n      } */\n          return [v[0] / plist.length + acc[0], v[1] / plist.length + acc[1]];\n        },\n        [0, 0],\n      );\n    };\n    this.triangulate = function(plist, args) {\n      //return []\n      var args = args != undefined ? args : {};\n      var area = args.area != undefined ? args.area : 100;\n      var convex = args.convex != undefined ? args.convex : false;\n      var optimize = args.optimize != undefined ? args.optimize : true;\n      function lineExpr(pt0, pt1) {\n        var den = pt1[0] - pt0[0];\n        var m = den == 0 ? Infinity : (pt1[1] - pt0[1]) / den;\n        var k = pt0[1] - m * pt0[0];\n        return [m, k];\n      }\n      function intersect(ln0, ln1) {\n        var le0 = lineExpr(...ln0);\n        var le1 = lineExpr(...ln1);\n        var den = le0[0] - le1[0];\n        if (den == 0) {\n          return false;\n        }\n        var x = (le1[1] - le0[1]) / den;\n        var y = le0[0] * x + le0[1];\n        function onSeg(p, ln) {\n          //non-inclusive\n          return (\n            Math.min(ln[0][0], ln[1][0]) <= p[0] &&\n            p[0] <= Math.max(ln[0][0], ln[1][0]) &&\n            Math.min(ln[0][1], ln[1][1]) <= p[1] &&\n            p[1] <= Math.max(ln[0][1], ln[1][1])\n          );\n        }\n        if (onSeg([x, y], ln0) && onSeg([x, y], ln1)) {\n          return [x, y];\n        }\n        return false;\n      }\n      function ptInPoly(pt, plist) {\n        var scount = 0;\n        for (var i = 0; i < plist.length; i++) {\n          var np = plist[i != plist.length - 1 ? i + 1 : 0];\n          var sect = intersect(\n            [plist[i], np],\n            [pt, [pt[0] + 999, pt[1] + 999]],\n          );\n          if (sect != false) {\n            scount++;\n          }\n        }\n        return scount % 2 == 1;\n      }\n      function lnInPoly(ln, plist) {\n        var lnc = [[0, 0], [0, 0]];\n        var ep = 0.01;\n\n        lnc[0][0] = ln[0][0] * (1 - ep) + ln[1][0] * ep;\n        lnc[0][1] = ln[0][1] * (1 - ep) + ln[1][1] * ep;\n        lnc[1][0] = ln[0][0] * ep + ln[1][0] * (1 - ep);\n        lnc[1][1] = ln[0][1] * ep + ln[1][1] * (1 - ep);\n\n        for (var i = 0; i < plist.length; i++) {\n          var pt = plist[i];\n          var np = plist[i != plist.length - 1 ? i + 1 : 0];\n          if (intersect(lnc, [pt, np]) != false) {\n            return false;\n          }\n        }\n        var mid = PolyTools.midPt(ln);\n        if (ptInPoly(mid, plist) == false) {\n          return false;\n        }\n        return true;\n      }\n\n      function sidesOf(plist) {\n        var slist = [];\n        for (var i = 0; i < plist.length; i++) {\n          var pt = plist[i];\n          var np = plist[i != plist.length - 1 ? i + 1 : 0];\n          var s = Math.sqrt(\n            Math.pow(np[0] - pt[0], 2) + Math.pow(np[1] - pt[1], 2),\n          );\n          slist.push(s);\n        }\n        return slist;\n      }\n      function areaOf(plist) {\n        var slist = sidesOf(plist);\n        var a = slist[0],\n          b = slist[1],\n          c = slist[2];\n        var s = (a + b + c) / 2;\n        return Math.sqrt(s * (s - a) * (s - b) * (s - c));\n      }\n      function sliverRatio(plist) {\n        var A = areaOf(plist);\n        var P = sidesOf(plist).reduce(function(m, n) {\n          return m + n;\n        }, 0);\n        return A / P;\n      }\n      function bestEar(plist) {\n        var cuts = [];\n        for (var i = 0; i < plist.length; i++) {\n          var pt = plist[i];\n          var lp = plist[i != 0 ? i - 1 : plist.length - 1];\n          var np = plist[i != plist.length - 1 ? i + 1 : 0];\n          var qlist = plist.slice();\n          qlist.splice(i, 1);\n          if (convex || lnInPoly([lp, np], plist)) {\n            var c = [[lp, pt, np], qlist];\n            if (!optimize) return c;\n            cuts.push(c);\n          }\n        }\n        var best = [plist, []];\n        var bestRatio = 0;\n        for (var i = 0; i < cuts.length; i++) {\n          var r = sliverRatio(cuts[i][0]);\n          if (r >= bestRatio) {\n            best = cuts[i];\n            bestRatio = r;\n          }\n        }\n        return best;\n      }\n      function shatter(plist, a) {\n        if (plist.length == 0) {\n          return [];\n        }\n        if (areaOf(plist) < a) {\n          return [plist];\n        } else {\n          var slist = sidesOf(plist);\n          var ind = slist.reduce(\n            (iMax, x, i, arr) => (x > arr[iMax] ? i : iMax),\n            0,\n          );\n          var nind = (ind + 1) % plist.length;\n          var lind = (ind + 2) % plist.length;\n          try {\n            var mid = PolyTools.midPt([plist[ind], plist[nind]]);\n          } catch (err) {\n            console.log(plist);\n            console.log(err);\n            return [];\n          }\n          return shatter([plist[ind], mid, plist[lind]], a).concat(\n            shatter([plist[lind], plist[nind], mid], a),\n          );\n        }\n      }\n      if (plist.length <= 3) {\n        return shatter(plist, area);\n      } else {\n        var cut = bestEar(plist);\n        return shatter(cut[0], area).concat(\n          PolyTools.triangulate(cut[1], args),\n        );\n      }\n    };\n  }();\n</script>\n\n<script id=\"Util\">\n  function unNan(plist) {\n    if (typeof plist != \"object\" || plist == null) {\n      return plist || 0;\n    } else {\n      return plist.map(unNan);\n    }\n  }\n  //console.log(unNan([[undefined,[NaN,NaN],null],false,1]))\n\n  function distance(p0, p1) {\n    return Math.sqrt(Math.pow(p0[0] - p1[0], 2) + Math.pow(p0[1] - p1[1], 2));\n  }\n\n  function mapval(value, istart, istop, ostart, ostop) {\n    return (\n      ostart + (ostop - ostart) * (((value - istart) * 1.0) / (istop - istart))\n    );\n  }\n  function loopNoise(nslist) {\n    var dif = nslist[nslist.length - 1] - nslist[0];\n    var bds = [100, -100];\n    for (var i = 0; i < nslist.length; i++) {\n      nslist[i] += (dif * (nslist.length - 1 - i)) / (nslist.length - 1);\n      if (nslist[i] < bds[0]) bds[0] = nslist[i];\n      if (nslist[i] > bds[1]) bds[1] = nslist[i];\n    }\n    for (var i = 0; i < nslist.length; i++) {\n      nslist[i] = mapval(nslist[i], bds[0], bds[1], 0, 1);\n    }\n  }\n\n  function randChoice(arr) {\n    return arr[Math.floor(arr.length * Math.random())];\n  }\n\n  function normRand(m, M) {\n    return mapval(Math.random(), 0, 1, m, M);\n  }\n\n  function wtrand(func) {\n    var x = Math.random();\n    var y = Math.random();\n    if (y < func(x)) {\n      return x;\n    } else {\n      return wtrand(func);\n    }\n  }\n\n  function randGaussian() {\n    return (\n      wtrand(function(x) {\n        return Math.pow(Math.E, -24 * Math.pow(x - 0.5, 2));\n      }) *\n        2 -\n      1\n    );\n  }\n\n  function bezmh(P, w) {\n    w = w == undefined ? 1 : w;\n    if (P.length == 2) {\n      P = [P[0], PolyTools.midPt(P[0], P[1]), P[1]];\n    }\n    var plist = [];\n    for (var j = 0; j < P.length - 2; j++) {\n      var p0;\n      var p1;\n      var p2;\n      if (j == 0) {\n        p0 = P[j];\n      } else {\n        p0 = PolyTools.midPt(P[j], P[j + 1]);\n      }\n      p1 = P[j + 1];\n      if (j == P.length - 3) {\n        p2 = P[j + 2];\n      } else {\n        p2 = PolyTools.midPt(P[j + 1], P[j + 2]);\n      }\n      var pl = 20;\n      for (var i = 0; i < pl + (j == P.length - 3); i += 1) {\n        var t = i / pl;\n        var u = Math.pow(1 - t, 2) + 2 * t * (1 - t) * w + t * t;\n        plist.push([\n          (Math.pow(1 - t, 2) * p0[0] +\n            2 * t * (1 - t) * p1[0] * w +\n            t * t * p2[0]) /\n            u,\n          (Math.pow(1 - t, 2) * p0[1] +\n            2 * t * (1 - t) * p1[1] * w +\n            t * t * p2[1]) /\n            u,\n        ]);\n      }\n    }\n    return plist;\n  }\n\n  function poly(plist, args) {\n    var args = args != undefined ? args : {};\n    var xof = args.xof != undefined ? args.xof : 0;\n    var yof = args.yof != undefined ? args.yof : 0;\n    var fil = args.fil != undefined ? args.fil : \"rgba(0,0,0,0)\";\n    var str = args.str != undefined ? args.str : fil;\n    var wid = args.wid != undefined ? args.wid : 0;\n\n    var canv = \"<polyline points='\";\n    for (var i = 0; i < plist.length; i++) {\n      canv +=\n        \" \" +\n        (plist[i][0] + xof).toFixed(1) +\n        \",\" +\n        (plist[i][1] + yof).toFixed(1);\n    }\n    canv +=\n      \"' style='fill:\" +\n      fil +\n      \";stroke:\" +\n      str +\n      \";stroke-width:\" +\n      wid +\n      \"'/>\";\n    return canv;\n  }\n</script>\n\n<script>\n  console.log(\"************************************************\");\n\n  function stroke(ptlist, args) {\n    var args = args != undefined ? args : {};\n    var xof = args.xof != undefined ? args.xof : 0;\n    var yof = args.yof != undefined ? args.yof : 0;\n    var wid = args.wid != undefined ? args.wid : 2;\n    var col = args.col != undefined ? args.col : \"rgba(200,200,200,0.9)\";\n    var noi = args.noi != undefined ? args.noi : 0.5;\n    var out = args.out != undefined ? args.out : 1;\n    var fun =\n      args.fun != undefined\n        ? args.fun\n        : function(x) {\n            return Math.sin(x * Math.PI);\n          };\n\n    if (ptlist.length == 0) {\n      return \"\";\n    }\n    vtxlist0 = [];\n    vtxlist1 = [];\n    vtxlist = [];\n    var n0 = Math.random() * 10;\n    for (var i = 1; i < ptlist.length - 1; i++) {\n      var w = wid * fun(i / ptlist.length);\n      w = w * (1 - noi) + w * noi * Noise.noise(i * 0.5, n0);\n      var a1 = Math.atan2(\n        ptlist[i][1] - ptlist[i - 1][1],\n        ptlist[i][0] - ptlist[i - 1][0],\n      );\n      var a2 = Math.atan2(\n        ptlist[i][1] - ptlist[i + 1][1],\n        ptlist[i][0] - ptlist[i + 1][0],\n      );\n      var a = (a1 + a2) / 2;\n      if (a < a2) {\n        a += Math.PI;\n      }\n      vtxlist0.push([\n        ptlist[i][0] + w * Math.cos(a),\n        ptlist[i][1] + w * Math.sin(a),\n      ]);\n      vtxlist1.push([\n        ptlist[i][0] - w * Math.cos(a),\n        ptlist[i][1] - w * Math.sin(a),\n      ]);\n    }\n\n    vtxlist = [ptlist[0]]\n      .concat(\n        vtxlist0.concat(vtxlist1.concat([ptlist[ptlist.length - 1]]).reverse()),\n      )\n      .concat([ptlist[0]]);\n\n    var canv = poly(\n      vtxlist.map(function(x) {\n        return [x[0] + xof, x[1] + yof];\n      }),\n      { fil: col, str: col, wid: out },\n    );\n    return canv;\n  }\n\n  function blob(x, y, args) {\n    var args = args != undefined ? args : {};\n    var len = args.len != undefined ? args.len : 20;\n    var wid = args.wid != undefined ? args.wid : 5;\n    var ang = args.ang != undefined ? args.ang : 0;\n    var col = args.col != undefined ? args.col : \"rgba(200,200,200,0.9)\";\n    var noi = args.noi != undefined ? args.noi : 0.5;\n    var ret = args.ret != undefined ? args.ret : 0;\n    var fun =\n      args.fun != undefined\n        ? args.fun\n        : function(x) {\n            return x <= 1\n              ? Math.pow(Math.sin(x * Math.PI), 0.5)\n              : -Math.pow(Math.sin((x + 1) * Math.PI), 0.5);\n          };\n\n    var reso = 20.0;\n    var lalist = [];\n    for (var i = 0; i < reso + 1; i++) {\n      var p = (i / reso) * 2;\n      var xo = len / 2 - Math.abs(p - 1) * len;\n      var yo = (fun(p) * wid) / 2;\n      var a = Math.atan2(yo, xo);\n      var l = Math.sqrt(xo * xo + yo * yo);\n      lalist.push([l, a]);\n    }\n    var nslist = [];\n    var n0 = Math.random() * 10;\n    for (var i = 0; i < reso + 1; i++) {\n      nslist.push(Noise.noise(i * 0.05, n0));\n    }\n\n    loopNoise(nslist);\n    var plist = [];\n    for (var i = 0; i < lalist.length; i++) {\n      var ns = nslist[i] * noi + (1 - noi);\n      var nx = x + Math.cos(lalist[i][1] + ang) * lalist[i][0] * ns;\n      var ny = y + Math.sin(lalist[i][1] + ang) * lalist[i][0] * ns;\n      plist.push([nx, ny]);\n    }\n\n    if (ret == 0) {\n      return poly(plist, { fil: col, str: col, wid: 0 });\n    } else {\n      return plist;\n    }\n  }\n\n  function div(plist, reso) {\n    var tl = (plist.length - 1) * reso;\n    var lx = 0;\n    var ly = 0;\n    var rlist = [];\n\n    for (var i = 0; i < tl; i += 1) {\n      var lastp = plist[Math.floor(i / reso)];\n      var nextp = plist[Math.ceil(i / reso)];\n      var p = (i % reso) / reso;\n      var nx = lastp[0] * (1 - p) + nextp[0] * p;\n      var ny = lastp[1] * (1 - p) + nextp[1] * p;\n\n      var ang = Math.atan2(ny - ly, nx - lx);\n\n      rlist.push([nx, ny]);\n      lx = nx;\n      ly = ny;\n    }\n\n    if (plist.length > 0) {\n      rlist.push(plist[plist.length - 1]);\n    }\n    return rlist;\n  }\n\n  var texture = function(ptlist, args) {\n    var args = args != undefined ? args : {};\n    var xof = args.xof != undefined ? args.xof : 0;\n    var yof = args.yof != undefined ? args.yof : 0;\n    var tex = args.tex != undefined ? args.tex : 400;\n    var wid = args.wid != undefined ? args.wid : 1.5;\n    var len = args.len != undefined ? args.len : 0.2;\n    var sha = args.sha != undefined ? args.sha : 0;\n    var ret = args.ret != undefined ? args.ret : 0;\n    var noi =\n      args.noi != undefined\n        ? args.noi\n        : function(x) {\n            return 30 / x;\n          };\n    var col =\n      args.col != undefined\n        ? args.col\n        : function(x) {\n            return \"rgba(100,100,100,\" + (Math.random() * 0.3).toFixed(3) + \")\";\n          };\n    var dis =\n      args.dis != undefined\n        ? args.dis\n        : function() {\n            if (Math.random() > 0.5) {\n              return (1 / 3) * Math.random();\n            } else {\n              return (1 * 2) / 3 + (1 / 3) * Math.random();\n            }\n          };\n    var reso = [ptlist.length, ptlist[0].length];\n    var texlist = [];\n    for (var i = 0; i < tex; i++) {\n      var mid = (dis() * reso[1]) | 0;\n      //mid = (reso[1]/3+reso[1]/3*Math.random())|0\n\n      var hlen = Math.floor(Math.random() * (reso[1] * len));\n\n      var start = mid - hlen;\n      var end = mid + hlen;\n      start = Math.min(Math.max(start, 0), reso[1]);\n      end = Math.min(Math.max(end, 0), reso[1]);\n\n      var layer = (i / tex) * (reso[0] - 1);\n\n      texlist.push([]);\n      for (var j = start; j < end; j++) {\n        var p = layer - Math.floor(layer);\n\n        var x =\n          ptlist[Math.floor(layer)][j][0] * p +\n          ptlist[Math.ceil(layer)][j][0] * (1 - p);\n\n        var y =\n          ptlist[Math.floor(layer)][j][1] * p +\n          ptlist[Math.ceil(layer)][j][1] * (1 - p);\n\n        var ns = [\n          noi(layer + 1) * (Noise.noise(x, j * 0.5) - 0.5),\n          noi(layer + 1) * (Noise.noise(y, j * 0.5) - 0.5),\n        ];\n\n        texlist[texlist.length - 1].push([x + ns[0], y + ns[1]]);\n      }\n    }\n    var canv = \"\";\n    //SHADE\n    if (sha) {\n      for (var j = 0; j < texlist.length; j += 1 + (sha != 0)) {\n        canv += stroke(\n          texlist[j].map(function(x) {\n            return [x[0] + xof, x[1] + yof];\n          }),\n          { col: \"rgba(100,100,100,0.1)\", wid: sha },\n        );\n      }\n    }\n    //TEXTURE\n    for (var j = 0 + sha; j < texlist.length; j += 1 + sha) {\n      canv += stroke(\n        texlist[j].map(function(x) {\n          return [x[0] + xof, x[1] + yof];\n        }),\n        { col: col(j / texlist.length), wid: wid },\n      );\n    }\n    return ret ? texlist : canv;\n  };\n\n  var Tree = new function() {\n    this.tree01 = function(x, y, args) {\n      var args = args != undefined ? args : {};\n      var hei = args.hei != undefined ? args.hei : 50;\n      var wid = args.wid != undefined ? args.wid : 3;\n      var col = args.col != undefined ? args.col : \"rgba(100,100,100,0.5)\";\n      var noi = args.noi != undefined ? args.noi : 0.5;\n\n      reso = 10;\n      var nslist = [];\n      for (var i = 0; i < reso; i++) {\n        nslist.push([Noise.noise(i * 0.5), Noise.noise(i * 0.5, 0.5)]);\n      }\n\n      var leafcol;\n      if (col.includes(\"rgba(\")) {\n        leafcol = col\n          .replace(\"rgba(\", \"\")\n          .replace(\")\", \"\")\n          .split(\",\");\n      } else {\n        leafcol = [\"100\", \"100\", \"100\", \"0.5\"];\n      }\n      var canv = \"\";\n      var line1 = [];\n      var line2 = [];\n      for (var i = 0; i < reso; i++) {\n        var nx = x;\n        var ny = y - (i * hei) / reso;\n        if (i >= reso / 4) {\n          for (var j = 0; j < (reso - i) / 5; j++) {\n            canv += blob(\n              nx + (Math.random() - 0.5) * wid * 1.2 * (reso - i),\n              ny + (Math.random() - 0.5) * wid,\n              {\n                len: Math.random() * 20 * (reso - i) * 0.2 + 10,\n                wid: Math.random() * 6 + 3,\n                ang: ((Math.random() - 0.5) * Math.PI) / 6,\n                col:\n                  \"rgba(\" +\n                  leafcol[0] +\n                  \",\" +\n                  leafcol[1] +\n                  \",\" +\n                  leafcol[2] +\n                  \",\" +\n                  (Math.random() * 0.2 + parseFloat(leafcol[3])).toFixed(1) +\n                  \")\",\n              },\n            );\n          }\n        }\n        line1.push([nx + (nslist[i][0] - 0.5) * wid - wid / 2, ny]);\n        line2.push([nx + (nslist[i][1] - 0.5) * wid + wid / 2, ny]);\n      }\n      canv +=\n        poly(line1, { fil: \"none\", str: col, wid: 1.5 }) +\n        poly(line2, { fil: \"none\", str: col, wid: 1.5 });\n      return canv;\n    };\n    this.tree02 = function(x, y, args) {\n      var args = args != undefined ? args : {};\n      var hei = args.hei != undefined ? args.hei : 16;\n      var wid = args.wid != undefined ? args.wid : 8;\n      var clu = args.clu != undefined ? args.clu : 5;\n      var col = args.col != undefined ? args.col : \"rgba(100,100,100,0.5)\";\n      var noi = args.noi != undefined ? args.noi : 0.5;\n\n      var leafcol;\n      if (col.includes(\"rgba(\")) {\n        leafcol = col\n          .replace(\"rgba(\", \"\")\n          .replace(\")\", \"\")\n          .split(\",\");\n      } else {\n        leafcol = [\"100\", \"100\", \"100\", \"0.5\"];\n      }\n\n      var canv = \"\";\n      for (var i = 0; i < clu; i++) {\n        canv += blob(\n          x + randGaussian() * clu * 4,\n          y + randGaussian() * clu * 4,\n          {\n            ang: Math.PI / 2,\n            col: \"rgba(100,100,100,0.8)\",\n            fun: function(x) {\n              return x <= 1\n                ? Math.pow(Math.sin(x * Math.PI) * x, 0.5)\n                : -Math.pow(Math.sin((x - 2) * Math.PI * (x - 2)), 0.5);\n            },\n            wid: Math.random() * wid * 0.75 + wid * 0.5,\n            len: Math.random() * hei * 0.75 + hei * 0.5,\n            col: col,\n          },\n        );\n      }\n      return canv;\n    };\n    this.tree03 = function(x, y, args) {\n      var args = args != undefined ? args : {};\n      var hei = args.hei != undefined ? args.hei : 50;\n      var wid = args.wid != undefined ? args.wid : 5;\n      var ben =\n        args.ben != undefined\n          ? args.ben\n          : function(x) {\n              return 0;\n            };\n      var col = args.col != undefined ? args.col : \"rgba(100,100,100,0.5)\";\n      var noi = args.noi != undefined ? args.noi : 0.5;\n\n      reso = 10;\n      var nslist = [];\n      for (var i = 0; i < reso; i++) {\n        nslist.push([Noise.noise(i * 0.5), Noise.noise(i * 0.5, 0.5)]);\n      }\n\n      var leafcol;\n      if (col.includes(\"rgba(\")) {\n        leafcol = col\n          .replace(\"rgba(\", \"\")\n          .replace(\")\", \"\")\n          .split(\",\");\n      } else {\n        leafcol = [\"100\", \"100\", \"100\", \"0.5\"];\n      }\n      var canv = \"\";\n      var blobs = \"\";\n      var line1 = [];\n      var line2 = [];\n      for (var i = 0; i < reso; i++) {\n        var nx = x + ben(i / reso) * 100;\n        var ny = y - (i * hei) / reso;\n        if (i >= reso / 5) {\n          for (var j = 0; j < (reso - i) * 2; j++) {\n            var shape = function(x) {\n              return Math.log(50 * x + 1) / 3.95;\n            };\n            var ox = Math.random() * wid * 2 * shape((reso - i) / reso);\n            blobs += blob(\n              nx + ox * randChoice([-1, 1]),\n              ny + (Math.random() - 0.5) * wid * 2,\n              {\n                len: ox * 2,\n                wid: Math.random() * 6 + 3,\n                ang: ((Math.random() - 0.5) * Math.PI) / 6,\n                col:\n                  \"rgba(\" +\n                  leafcol[0] +\n                  \",\" +\n                  leafcol[1] +\n                  \",\" +\n                  leafcol[2] +\n                  \",\" +\n                  (Math.random() * 0.2 + parseFloat(leafcol[3])).toFixed(3) +\n                  \")\",\n              },\n            );\n          }\n        }\n        line1.push([\n          nx + (((nslist[i][0] - 0.5) * wid - wid / 2) * (reso - i)) / reso,\n          ny,\n        ]);\n        line2.push([\n          nx + (((nslist[i][1] - 0.5) * wid + wid / 2) * (reso - i)) / reso,\n          ny,\n        ]);\n      }\n      var lc = line1.concat(line2.reverse());\n      canv += poly(lc, { fil: \"white\", str: col, wid: 1.5 });\n      canv += blobs;\n      return canv;\n    };\n\n    var branch = function(args) {\n      var args = args != undefined ? args : {};\n      var hei = args.hei != undefined ? args.hei : 300;\n      var wid = args.wid != undefined ? args.wid : 6;\n      var ang = args.ang != undefined ? args.ang : 0;\n      var det = args.det != undefined ? args.det : 10;\n      var ben = args.ben != undefined ? args.ben : Math.PI * 0.2;\n\n      var tlist;\n      var nx = 0;\n      var ny = 0;\n      tlist = [[nx, ny]];\n      var a0 = 0;\n      var g = 3;\n      for (var i = 0; i < g; i++) {\n        a0 += (ben / 2 + (Math.random() * ben) / 2) * randChoice([-1, 1]);\n        nx += (Math.cos(a0) * hei) / g;\n        ny -= (Math.sin(a0) * hei) / g;\n        tlist.push([nx, ny]);\n      }\n      var ta = Math.atan2(\n        tlist[tlist.length - 1][1],\n        tlist[tlist.length - 1][0],\n      );\n\n      for (var i = 0; i < tlist.length; i++) {\n        var a = Math.atan2(tlist[i][1], tlist[i][0]);\n        var d = Math.sqrt(\n          tlist[i][0] * tlist[i][0] + tlist[i][1] * tlist[i][1],\n        );\n        tlist[i][0] = d * Math.cos(a - ta + ang);\n        tlist[i][1] = d * Math.sin(a - ta + ang);\n      }\n\n      var trlist1 = [];\n      var trlist2 = [];\n      var span = det;\n      var tl = (tlist.length - 1) * span;\n      var lx = 0;\n      var ly = 0;\n\n      for (var i = 0; i < tl; i += 1) {\n        var lastp = tlist[Math.floor(i / span)];\n        var nextp = tlist[Math.ceil(i / span)];\n        var p = (i % span) / span;\n        var nx = lastp[0] * (1 - p) + nextp[0] * p;\n        var ny = lastp[1] * (1 - p) + nextp[1] * p;\n\n        var ang = Math.atan2(ny - ly, nx - lx);\n        var woff = ((Noise.noise(i * 0.3) - 0.5) * wid * hei) / 80;\n\n        var b = 0;\n        if (p == 0) {\n          b = Math.random() * wid;\n        }\n\n        var nw = wid * (((tl - i) / tl) * 0.5 + 0.5);\n        trlist1.push([\n          nx + Math.cos(ang + Math.PI / 2) * (nw + woff + b),\n          ny + Math.sin(ang + Math.PI / 2) * (nw + woff + b),\n        ]);\n        trlist2.push([\n          nx + Math.cos(ang - Math.PI / 2) * (nw - woff + b),\n          ny + Math.sin(ang - Math.PI / 2) * (nw - woff + b),\n        ]);\n        lx = nx;\n        ly = ny;\n      }\n\n      return [trlist1, trlist2];\n    };\n\n    var twig = function(tx, ty, dep, args) {\n      var args = args != undefined ? args : {};\n      var dir = args.dir != undefined ? args.dir : 1;\n      var sca = args.sca != undefined ? args.sca : 1;\n      var wid = args.wid != undefined ? args.wid : 1;\n      var ang = args.ang != undefined ? args.ang : 0;\n      var lea = args.lea != undefined ? args.lea : [true, 12];\n\n      var canv = \"\";\n      var twlist = [];\n      var tl = 10;\n      var hs = Math.random() * 0.5 + 0.5;\n      var fun1 = function(x) {\n        return Math.pow(x, 0.5);\n      };\n      var fun2 = function(x) {\n        return -1 / Math.pow(i / tl + 1, 5) + 1;\n      };\n\n      var tfun = randChoice([fun2]);\n      var a0 = ((Math.random() * Math.PI) / 6) * dir + ang;\n      for (var i = 0; i < tl; i++) {\n        var mx = dir * tfun(i / tl) * 50 * sca * hs;\n        var my = -i * 5 * sca;\n\n        var a = Math.atan2(my, mx);\n        var d = Math.pow(mx * mx + my * my, 0.5);\n\n        var nx = Math.cos(a + a0) * d;\n        var ny = Math.sin(a + a0) * d;\n\n        twlist.push([nx + tx, ny + ty]);\n        if ((i == ((tl / 3) | 0) || i == (((tl * 2) / 3) | 0)) && dep > 0) {\n          canv += twig(nx + tx, ny + ty, dep - 1, {\n            ang: ang,\n            sca: sca * 0.8,\n            wid: wid,\n            dir: dir * randChoice([-1, 1]),\n            lea: lea,\n          });\n        }\n        if (i == tl - 1 && lea[0] == true) {\n          for (var j = 0; j < 5; j++) {\n            var dj = (j - 2.5) * 5;\n            canv += blob(\n              nx + tx + Math.cos(ang) * dj * wid,\n              ny + ty + (Math.sin(ang) * dj - lea[1] / (dep + 1)) * wid,\n              {\n                wid: (6 + 3 * Math.random()) * wid,\n                len: (15 + 12 * Math.random()) * wid,\n                ang:\n                  ang / 2 + Math.PI / 2 + Math.PI * 0.2 * (Math.random() - 0.5),\n                col: \"rgba(100,100,100,\" + (0.5 + dep * 0.2).toFixed(3) + \")\",\n                fun: function(x) {\n                  return x <= 1\n                    ? Math.pow(Math.sin(x * Math.PI) * x, 0.5)\n                    : -Math.pow(Math.sin((x - 2) * Math.PI * (x - 2)), 0.5);\n                },\n              },\n            );\n          }\n        }\n      }\n      canv += stroke(twlist, {\n        wid: 1,\n        fun: function(x) {\n          return Math.cos((x * Math.PI) / 2);\n        },\n        col: \"rgba(100,100,100,0.5)\",\n      });\n      return canv;\n    };\n\n    var barkify = function(x, y, trlist) {\n      function bark(x, y, wid, ang) {\n        var len = 10 + 10 * Math.random();\n        var noi = 0.5;\n        var fun = function(x) {\n          return x <= 1\n            ? Math.pow(Math.sin(x * Math.PI), 0.5)\n            : -Math.pow(Math.sin((x + 1) * Math.PI), 0.5);\n        };\n        var reso = 20.0;\n        var canv = \"\";\n\n        var lalist = [];\n        for (var i = 0; i < reso + 1; i++) {\n          var p = (i / reso) * 2;\n          var xo = len / 2 - Math.abs(p - 1) * len;\n          var yo = (fun(p) * wid) / 2;\n          var a = Math.atan2(yo, xo);\n          var l = Math.sqrt(xo * xo + yo * yo);\n          lalist.push([l, a]);\n        }\n        var nslist = [];\n        var n0 = Math.random() * 10;\n        for (var i = 0; i < reso + 1; i++) {\n          nslist.push(Noise.noise(i * 0.05, n0));\n        }\n\n        loopNoise(nslist);\n        var brklist = [];\n        for (var i = 0; i < lalist.length; i++) {\n          var ns = nslist[i] * noi + (1 - noi);\n          var nx = x + Math.cos(lalist[i][1] + ang) * lalist[i][0] * ns;\n          var ny = y + Math.sin(lalist[i][1] + ang) * lalist[i][0] * ns;\n          brklist.push([nx, ny]);\n        }\n        var fr = Math.random();\n        canv += stroke(brklist, {\n          wid: 0.8,\n          noi: 0,\n          col: \"rgba(100,100,100,0.4)\",\n          out: 0,\n          fun: function(x) {\n            return Math.sin((x + fr) * Math.PI * 3);\n          },\n        });\n\n        return canv;\n      }\n      var canv = \"\";\n\n      for (var i = 2; i < trlist[0].length - 1; i++) {\n        var a0 = Math.atan2(\n          trlist[0][i][1] - trlist[0][i - 1][1],\n          trlist[0][i][0] - trlist[0][i - 1][0],\n        );\n        var a1 = Math.atan2(\n          trlist[1][i][1] - trlist[1][i - 1][1],\n          trlist[1][i][0] - trlist[1][i - 1][0],\n        );\n        var p = Math.random();\n        var nx = trlist[0][i][0] * (1 - p) + trlist[1][i][0] * p;\n        var ny = trlist[0][i][1] * (1 - p) + trlist[1][i][1] * p;\n        if (Math.random() < 0.2) {\n          canv += blob(nx + x, ny + y, {\n            noi: 1,\n            len: 15,\n            wid: 6 - Math.abs(p - 0.5) * 10,\n            ang: (a0 + a1) / 2,\n            col: \"rgba(100,100,100,0.6)\",\n          });\n        } else {\n          canv += bark(\n            nx + x,\n            ny + y,\n            5 - Math.abs(p - 0.5) * 10,\n            (a0 + a1) / 2,\n          );\n        }\n\n        if (Math.random() < 0.05) {\n          var jl = Math.random() * 2 + 2;\n          var xya = randChoice([\n            [trlist[0][i][0], trlist[0][i][1], a0],\n            [trlist[1][i][0], trlist[1][i][1], a1],\n          ]);\n          for (var j = 0; j < jl; j++) {\n            canv += blob(\n              xya[0] + x + Math.cos(xya[2]) * (j - jl / 2) * 4,\n              xya[1] + y + Math.sin(xya[2]) * (j - jl / 2) * 4,\n              {\n                wid: 4,\n                len: 4 + 6 * Math.random(),\n                ang: a0 + Math.PI / 2,\n                col: \"rgba(100,100,100,0.6)\",\n              },\n            );\n          }\n        }\n      }\n      var trflist = trlist[0].concat(trlist[1].slice().reverse());\n      var rglist = [[]];\n      for (var i = 0; i < trflist.length; i++) {\n        if (Math.random() < 0.5) {\n          rglist.push([]);\n        } else {\n          rglist[rglist.length - 1].push(trflist[i]);\n        }\n      }\n\n      for (var i = 0; i < rglist.length; i++) {\n        rglist[i] = div(rglist[i], 4);\n        for (var j = 0; j < rglist[i].length; j++) {\n          rglist[i][j][0] +=\n            (Noise.noise(i, j * 0.1, 1) - 0.5) * (15 + 5 * randGaussian());\n          rglist[i][j][1] +=\n            (Noise.noise(i, j * 0.1, 2) - 0.5) * (15 + 5 * randGaussian());\n        }\n        canv += stroke(\n          rglist[i].map(function(v) {\n            return [v[0] + x, v[1] + y];\n          }),\n          { wid: 1.5, col: \"rgba(100,100,100,0.7)\", out: 0 },\n        );\n      }\n      return canv;\n    };\n\n    this.tree04 = function(x, y, args) {\n      var args = args != undefined ? args : {};\n      var hei = args.hei != undefined ? args.hei : 300;\n      var wid = args.wid != undefined ? args.wid : 6;\n      var col = args.col != undefined ? args.col : \"rgba(100,100,100,0.5)\";\n      var noi = args.noi != undefined ? args.noi : 0.5;\n\n      var canv = \"\";\n      var txcanv = \"\";\n      var twcanv = \"\";\n\n      var trlist = branch({ hei: hei, wid: wid, ang: -Math.PI / 2 });\n      txcanv += barkify(x, y, trlist);\n      trlist = trlist[0].concat(trlist[1].reverse());\n\n      var trmlist = [];\n\n      for (var i = 0; i < trlist.length; i++) {\n        if (\n          (i >= trlist.length * 0.3 &&\n            i <= trlist.length * 0.7 &&\n            Math.random() < 0.1) ||\n          i == trlist.length / 2 - 1\n        ) {\n          var ba = Math.PI * 0.2 - Math.PI * 1.4 * (i > trlist.length / 2);\n          var brlist = branch({\n            hei: hei * (Math.random() + 1) * 0.3,\n            wid: wid * 0.5,\n            ang: ba,\n          });\n\n          brlist[0].splice(0, 1);\n          brlist[1].splice(0, 1);\n          var foff = function(v) {\n            return [v[0] + trlist[i][0], v[1] + trlist[i][1]];\n          };\n          txcanv += barkify(x, y, [brlist[0].map(foff), brlist[1].map(foff)]);\n\n          for (var j = 0; j < brlist[0].length; j++) {\n            if (Math.random() < 0.2 || j == brlist[0].length - 1) {\n              twcanv += twig(\n                brlist[0][j][0] + trlist[i][0] + x,\n                brlist[0][j][1] + trlist[i][1] + y,\n                1,\n                {\n                  wid: hei / 300,\n                  ang: ba > -Math.PI / 2 ? ba : ba + Math.PI,\n                  sca: (0.5 * hei) / 300,\n                  dir: ba > -Math.PI / 2 ? 1 : -1,\n                },\n              );\n            }\n          }\n          brlist = brlist[0].concat(brlist[1].reverse());\n          trmlist = trmlist.concat(\n            brlist.map(function(v) {\n              return [v[0] + trlist[i][0], v[1] + trlist[i][1]];\n            }),\n          );\n        } else {\n          trmlist.push(trlist[i]);\n        }\n      }\n      canv += poly(trmlist, { xof: x, yof: y, fil: \"white\", str: col, wid: 0 });\n\n      trmlist.splice(0, 1);\n      trmlist.splice(trmlist.length - 1, 1);\n      canv += stroke(\n        trmlist.map(function(v) {\n          return [v[0] + x, v[1] + y];\n        }),\n        {\n          col:\n            \"rgba(100,100,100,\" + (0.4 + Math.random() * 0.1).toFixed(3) + \")\",\n          wid: 2.5,\n          fun: function(x) {\n            return Math.sin(1);\n          },\n          noi: 0.9,\n          out: 0,\n        },\n      );\n\n      canv += txcanv;\n      canv += twcanv;\n      return canv;\n    };\n\n    this.tree05 = function(x, y, args) {\n      var args = args != undefined ? args : {};\n      var hei = args.hei != undefined ? args.hei : 300;\n      var wid = args.wid != undefined ? args.wid : 5;\n      var col = args.col != undefined ? args.col : \"rgba(100,100,100,0.5)\";\n      var noi = args.noi != undefined ? args.noi : 0.5;\n\n      var canv = \"\";\n      var txcanv = \"\";\n      var twcanv = \"\";\n\n      var trlist = branch({ hei: hei, wid: wid, ang: -Math.PI / 2, ben: 0 });\n      txcanv += barkify(x, y, trlist);\n      trlist = trlist[0].concat(trlist[1].reverse());\n\n      var trmlist = [];\n\n      for (var i = 0; i < trlist.length; i++) {\n        var p = Math.abs(i - trlist.length * 0.5) / (trlist.length * 0.5);\n        if (\n          (i >= trlist.length * 0.2 &&\n            i <= trlist.length * 0.8 &&\n            i % 3 == 0 &&\n            Math.random() > p) ||\n          i == trlist.length / 2 - 1\n        ) {\n          var bar = Math.random() * 0.2;\n          var ba =\n            -bar * Math.PI - (1 - bar * 2) * Math.PI * (i > trlist.length / 2);\n          var brlist = branch({\n            hei: hei * (0.3 * p - Math.random() * 0.05),\n            wid: wid * 0.5,\n            ang: ba,\n            ben: 0.5,\n          });\n\n          brlist[0].splice(0, 1);\n          brlist[1].splice(0, 1);\n          var foff = function(v) {\n            return [v[0] + trlist[i][0], v[1] + trlist[i][1]];\n          };\n          //txcanv += barkify(x,y,[brlist[0].map(foff),brlist[1].map(foff)])\n\n          for (var j = 0; j < brlist[0].length; j++) {\n            if (j % 20 == 0 || j == brlist[0].length - 1) {\n              twcanv += twig(\n                brlist[0][j][0] + trlist[i][0] + x,\n                brlist[0][j][1] + trlist[i][1] + y,\n                0,\n                {\n                  wid: hei / 300,\n                  ang: ba > -Math.PI / 2 ? ba : ba + Math.PI,\n                  sca: (0.2 * hei) / 300,\n                  dir: ba > -Math.PI / 2 ? 1 : -1,\n                  lea: [true, 5],\n                },\n              );\n            }\n          }\n          brlist = brlist[0].concat(brlist[1].reverse());\n          trmlist = trmlist.concat(\n            brlist.map(function(v) {\n              return [v[0] + trlist[i][0], v[1] + trlist[i][1]];\n            }),\n          );\n        } else {\n          trmlist.push(trlist[i]);\n        }\n      }\n\n      canv += poly(trmlist, { xof: x, yof: y, fil: \"white\", str: col, wid: 0 });\n\n      trmlist.splice(0, 1);\n      trmlist.splice(trmlist.length - 1, 1);\n      canv += stroke(\n        trmlist.map(function(v) {\n          return [v[0] + x, v[1] + y];\n        }),\n        {\n          col:\n            \"rgba(100,100,100,\" + (0.4 + Math.random() * 0.1).toFixed(3) + \")\",\n          wid: 2.5,\n          fun: function(x) {\n            return Math.sin(1);\n          },\n          noi: 0.9,\n          out: 0,\n        },\n      );\n\n      canv += txcanv;\n      canv += twcanv;\n      return canv;\n    };\n\n    this.tree06 = function(x, y, args) {\n      var args = args != undefined ? args : {};\n      var hei = args.hei != undefined ? args.hei : 100;\n      var wid = args.wid != undefined ? args.wid : 6;\n      var col = args.col != undefined ? args.col : \"rgba(100,100,100,0.5)\";\n      var noi = args.noi != undefined ? args.noi : 0.5;\n\n      var canv = \"\";\n      var txcanv = \"\";\n      var twcanv = \"\";\n\n      function fracTree(xoff, yoff, dep, args) {\n        var args = args != undefined ? args : {};\n        var hei = args.hei != undefined ? args.hei : 300;\n        var wid = args.wid != undefined ? args.wid : 5;\n        var ang = args.ang != undefined ? args.ang : 0;\n        var ben = args.ben != undefined ? args.ben : Math.PI * 0.2;\n\n        var trlist = branch({\n          hei: hei,\n          wid: wid,\n          ang: ang,\n          ben: ben,\n          det: hei / 20,\n        });\n        txcanv += barkify(xoff, yoff, trlist);\n        trlist = trlist[0].concat(trlist[1].reverse());\n\n        var trmlist = [];\n\n        for (var i = 0; i < trlist.length; i++) {\n          var p = Math.abs(i - trlist.length * 0.5) / (trlist.length * 0.5);\n          if (\n            ((Math.random() < 0.025 &&\n              i >= trlist.length * 0.2 &&\n              i <= trlist.length * 0.8) ||\n              i == ((trlist.length / 2) | 0) - 1 ||\n              i == ((trlist.length / 2) | 0) + 1) &&\n            dep > 0\n          ) {\n            var bar = 0.02 + Math.random() * 0.08;\n            var ba =\n              bar * Math.PI - bar * 2 * Math.PI * (i > trlist.length / 2);\n\n            var brlist = fracTree(\n              trlist[i][0] + xoff,\n              trlist[i][1] + yoff,\n              dep - 1,\n              {\n                hei: hei * (0.7 + Math.random() * 0.2),\n                wid: wid * 0.6,\n                ang: ang + ba,\n                ben: 0.55,\n              },\n            );\n\n            for (var j = 0; j < brlist.length; j++) {\n              if (Math.random() < 0.03) {\n                twcanv += twig(\n                  brlist[j][0] + trlist[i][0] + xoff,\n                  brlist[j][1] + trlist[i][1] + yoff,\n                  2,\n                  {\n                    ang: ba * (Math.random() * 0.5 + 0.75),\n                    sca: 0.3,\n                    dir: ba > 0 ? 1 : -1,\n                    lea: [false, 0],\n                  },\n                );\n              }\n            }\n\n            trmlist = trmlist.concat(\n              brlist.map(function(v) {\n                return [v[0] + trlist[i][0], v[1] + trlist[i][1]];\n              }),\n            );\n          } else {\n            trmlist.push(trlist[i]);\n          }\n        }\n        return trmlist;\n      }\n\n      var trmlist = fracTree(x, y, 3, {\n        hei: hei,\n        wid: wid,\n        ang: -Math.PI / 2,\n        ben: 0,\n      });\n\n      canv += poly(trmlist, { xof: x, yof: y, fil: \"white\", str: col, wid: 0 });\n\n      trmlist.splice(0, 1);\n      trmlist.splice(trmlist.length - 1, 1);\n      canv += stroke(\n        trmlist.map(function(v) {\n          return [v[0] + x, v[1] + y];\n        }),\n        {\n          col:\n            \"rgba(100,100,100,\" + (0.4 + Math.random() * 0.1).toFixed(3) + \")\",\n          wid: 2.5,\n          fun: function(x) {\n            return Math.sin(1);\n          },\n          noi: 0.9,\n          out: 0,\n        },\n      );\n\n      canv += txcanv;\n      canv += twcanv;\n      return canv;\n    };\n\n    this.tree07 = function(x, y, args) {\n      var args = args != undefined ? args : {};\n      var hei = args.hei != undefined ? args.hei : 60;\n      var wid = args.wid != undefined ? args.wid : 4;\n      var ben =\n        args.ben != undefined\n          ? args.ben\n          : function(x) {\n              return Math.sqrt(x) * 0.2;\n            };\n      var col = args.col != undefined ? args.col : \"rgba(100,100,100,1)\";\n      var noi = args.noi != undefined ? args.noi : 0.5;\n\n      reso = 10;\n      var nslist = [];\n      for (var i = 0; i < reso; i++) {\n        nslist.push([Noise.noise(i * 0.5), Noise.noise(i * 0.5, 0.5)]);\n      }\n      var leafcol;\n      if (col.includes(\"rgba(\")) {\n        leafcol = col\n          .replace(\"rgba(\", \"\")\n          .replace(\")\", \"\")\n          .split(\",\");\n      } else {\n        leafcol = [\"100\", \"100\", \"100\", \"1\"];\n      }\n      var canv = \"\";\n      var line1 = [];\n      var line2 = [];\n      var T = [];\n      for (var i = 0; i < reso; i++) {\n        var nx = x + ben(i / reso) * 100;\n        var ny = y - (i * hei) / reso;\n        if (i >= reso / 4) {\n          for (var j = 0; j < 1; j++) {\n            var bpl = blob(\n              nx + (Math.random() - 0.5) * wid * 1.2 * (reso - i) * 0.5,\n              ny + (Math.random() - 0.5) * wid * 0.5,\n              {\n                len: Math.random() * 50 + 20,\n                wid: Math.random() * 12 + 12,\n                ang: (-Math.random() * Math.PI) / 6,\n                col:\n                  \"rgba(\" +\n                  leafcol[0] +\n                  \",\" +\n                  leafcol[1] +\n                  \",\" +\n                  leafcol[2] +\n                  \",\" +\n                  parseFloat(leafcol[3]).toFixed(3) +\n                  \")\",\n                fun: function(x) {\n                  return x <= 1\n                    ? 2.75 * x * Math.pow(1 - x, 1 / 1.8)\n                    : 2.75 * (x - 2) * Math.pow(x - 1, 1 / 1.8);\n                },\n                ret: 1,\n              },\n            );\n\n            //canv+=poly(bpl,{fil:col,wid:0})\n            T = T.concat(\n              PolyTools.triangulate(bpl, {\n                area: 50,\n                convex: true,\n                optimize: false,\n              }),\n            );\n          }\n        }\n        line1.push([nx + (nslist[i][0] - 0.5) * wid - wid / 2, ny]);\n        line2.push([nx + (nslist[i][1] - 0.5) * wid + wid / 2, ny]);\n      }\n\n      //canv += poly(line1.concat(line2.reverse()),{fil:col,wid:0})\n      T = PolyTools.triangulate(line1.concat(line2.reverse()), {\n        area: 50,\n        convex: true,\n        optimize: true,\n      }).concat(T);\n\n      for (var k = 0; k < T.length; k++) {\n        var m = PolyTools.midPt(T[k]);\n        var c = (Noise.noise(m[0] * 0.02, m[1] * 0.02) * 200 + 50) | 0;\n        var co = \"rgba(\" + c + \",\" + c + \",\" + c + \",0.8)\";\n        canv += poly(T[k], { fil: co, str: co, wid: 0 });\n      }\n      return canv;\n    };\n\n    this.tree08 = function(x, y, args) {\n      var args = args != undefined ? args : {};\n      var hei = args.hei != undefined ? args.hei : 80;\n      var wid = args.wid != undefined ? args.wid : 1;\n      var col = args.col != undefined ? args.col : \"rgba(100,100,100,0.5)\";\n      var noi = args.noi != undefined ? args.noi : 0.5;\n\n      var canv = \"\";\n      var txcanv = \"\";\n      var twcanv = \"\";\n\n      var ang = normRand(-1, 1) * Math.PI * 0.2;\n\n      var trlist = branch({\n        hei: hei,\n        wid: wid,\n        ang: -Math.PI / 2 + ang,\n        ben: Math.PI * 0.2,\n        det: hei / 20,\n      });\n      //txcanv += barkify(x,y,trlist)\n\n      trlist = trlist[0].concat(trlist[1].reverse());\n\n      function fracTree(xoff, yoff, dep, args) {\n        var args = args != undefined ? args : {};\n        var ang = args.ang != undefined ? args.ang : -Math.PI / 2;\n        var len = args.len != undefined ? args.len : 15;\n        var ben = args.ben != undefined ? args.ben : 0;\n\n        var fun =\n          dep == 0\n            ? function(x) {\n                return Math.cos(0.5 * Math.PI * x);\n              }\n            : function(x) {\n                return 1;\n              };\n        var spt = [xoff, yoff];\n        var ept = [xoff + Math.cos(ang) * len, yoff + Math.sin(ang) * len];\n\n        var trmlist = [[xoff, yoff], [xoff + len, yoff]];\n\n        var bfun = randChoice([\n          function(x) {\n            return Math.sin(x * Math.PI);\n          },\n          function(x) {\n            return -Math.sin(x * Math.PI);\n          },\n        ]);\n\n        trmlist = div(trmlist, 10);\n\n        for (var i = 0; i < trmlist.length; i++) {\n          trmlist[i][1] += bfun(i / trmlist.length) * 2;\n        }\n        for (var i = 0; i < trmlist.length; i++) {\n          var d = distance(trmlist[i], spt);\n          var a = Math.atan2(trmlist[i][1] - spt[1], trmlist[i][0] - spt[0]);\n          trmlist[i][0] = spt[0] + d * Math.cos(a + ang);\n          trmlist[i][1] = spt[1] + d * Math.sin(a + ang);\n        }\n\n        var tcanv = \"\";\n        tcanv += stroke(trmlist, {\n          fun: fun,\n          wid: 0.8,\n          col: \"rgba(100,100,100,0.5)\",\n        });\n        if (dep != 0) {\n          var nben = ben + randChoice([-1, 1]) * Math.PI * 0.001 * dep * dep;\n          if (Math.random() < 0.5) {\n            tcanv += fracTree(ept[0], ept[1], dep - 1, {\n              ang:\n                ang +\n                ben +\n                Math.PI *\n                  randChoice([normRand(-1, 0.5), normRand(0.5, 1)]) *\n                  0.2,\n              len: len * normRand(0.8, 0.9),\n              ben: nben,\n            });\n            tcanv += fracTree(ept[0], ept[1], dep - 1, {\n              ang:\n                ang +\n                ben +\n                Math.PI *\n                  randChoice([normRand(-1, -0.5), normRand(0.5, 1)]) *\n                  0.2,\n              len: len * normRand(0.8, 0.9),\n              ben: nben,\n            });\n          } else {\n            tcanv += fracTree(ept[0], ept[1], dep - 1, {\n              ang: ang + ben,\n              len: len * normRand(0.8, 0.9),\n              ben: nben,\n            });\n          }\n        }\n        return tcanv;\n      }\n\n      for (var i = 0; i < trlist.length; i++) {\n        if (Math.random() < 0.2) {\n          twcanv += fracTree(\n            x + trlist[i][0],\n            y + trlist[i][1],\n            Math.floor(4 * Math.random()),\n            { hei: 20, ang: -Math.PI / 2 - ang * Math.random() },\n          );\n        } else if (i == Math.floor(trlist.length / 2)) {\n          twcanv += fracTree(x + trlist[i][0], y + trlist[i][1], 3, {\n            hei: 25,\n            ang: -Math.PI / 2 + ang,\n          });\n        }\n      }\n\n      canv += poly(trlist, { xof: x, yof: y, fil: \"white\", str: col, wid: 0 });\n\n      canv += stroke(\n        trlist.map(function(v) {\n          return [v[0] + x, v[1] + y];\n        }),\n        {\n          col:\n            \"rgba(100,100,100,\" + (0.6 + Math.random() * 0.1).toFixed(3) + \")\",\n          wid: 2.5,\n          fun: function(x) {\n            return Math.sin(1);\n          },\n          noi: 0.9,\n          out: 0,\n        },\n      );\n\n      canv += txcanv;\n      canv += twcanv;\n      //console.log(canv)\n      return canv;\n    };\n  }();\n\n  var Mount = new function() {\n    var foot = function(ptlist, args) {\n      var args = args != undefined ? args : {};\n      var xof = args.xof != undefined ? args.xof : 0;\n      var yof = args.yof != undefined ? args.yof : 0;\n      var ret = args.ret != undefined ? args.ret : 0;\n\n      var ftlist = [];\n      var span = 10;\n      var ni = 0;\n      for (var i = 0; i < ptlist.length - 2; i += 1) {\n        if (i == ni) {\n          ni = Math.min(ni + randChoice([1, 2]), ptlist.length - 1);\n\n          ftlist.push([]);\n          ftlist.push([]);\n          for (var j = 0; j < Math.min(ptlist[i].length / 8, 10); j++) {\n            ftlist[ftlist.length - 2].push([\n              ptlist[i][j][0] + Noise.noise(j * 0.1, i) * 10,\n              ptlist[i][j][1],\n            ]);\n            ftlist[ftlist.length - 1].push([\n              ptlist[i][ptlist[i].length - 1 - j][0] -\n                Noise.noise(j * 0.1, i) * 10,\n              ptlist[i][ptlist[i].length - 1 - j][1],\n            ]);\n          }\n\n          ftlist[ftlist.length - 2] = ftlist[ftlist.length - 2].reverse();\n          ftlist[ftlist.length - 1] = ftlist[ftlist.length - 1].reverse();\n          for (var j = 0; j < span; j++) {\n            var p = j / span;\n            var x1 = ptlist[i][0][0] * (1 - p) + ptlist[ni][0][0] * p;\n            var y1 = ptlist[i][0][1] * (1 - p) + ptlist[ni][0][1] * p;\n\n            var x2 =\n              ptlist[i][ptlist[i].length - 1][0] * (1 - p) +\n              ptlist[ni][ptlist[i].length - 1][0] * p;\n            var y2 =\n              ptlist[i][ptlist[i].length - 1][1] * (1 - p) +\n              ptlist[ni][ptlist[i].length - 1][1] * p;\n\n            var vib = -1.7 * (p - 1) * Math.pow(p, 1 / 5);\n            y1 += vib * 5 + Noise.noise(xof * 0.05, i) * 5;\n            y2 += vib * 5 + Noise.noise(xof * 0.05, i) * 5;\n\n            ftlist[ftlist.length - 2].push([x1, y1]);\n            ftlist[ftlist.length - 1].push([x2, y2]);\n          }\n        }\n      }\n      var canv = \"\";\n      for (var i = 0; i < ftlist.length; i++) {\n        canv += poly(ftlist[i], {\n          xof: xof,\n          yof: yof,\n          fil: \"white\",\n          str: \"none\",\n        });\n      }\n      for (var j = 0; j < ftlist.length; j++) {\n        canv += stroke(\n          ftlist[j].map(function(x) {\n            return [x[0] + xof, x[1] + yof];\n          }),\n          {\n            col:\n              \"rgba(100,100,100,\" +\n              (0.1 + Math.random() * 0.1).toFixed(3) +\n              \")\",\n            wid: 1,\n          },\n        );\n      }\n      return ret ? ftlist : canv;\n    };\n\n    this.mountain = function(xoff, yoff, seed, args) {\n      var args = args != undefined ? args : {};\n      var hei = args.hei != undefined ? args.hei : 100 + Math.random() * 400;\n      var wid = args.wid != undefined ? args.wid : 400 + Math.random() * 200;\n      var tex = args.tex != undefined ? args.tex : 200;\n      var veg = args.veg != undefined ? args.veg : true;\n      var ret = args.ret != undefined ? args.ret : 0;\n      var col = args.col != undefined ? args.col : undefined;\n\n      seed = seed != undefined ? seed : 0;\n\n      var canv = \"\";\n\n      var ptlist = [];\n      var h = hei;\n      var w = wid;\n      var reso = [10, 50];\n\n      var hoff = 0;\n      for (var j = 0; j < reso[0]; j++) {\n        hoff += (Math.random() * yoff) / 100;\n        ptlist.push([]);\n        for (var i = 0; i < reso[1]; i++) {\n          var x = (i / reso[1] - 0.5) * Math.PI;\n          var y = Math.cos(x);\n          y *= Noise.noise(x + 10, j * 0.15, seed);\n          var p = 1 - j / reso[0];\n          ptlist[ptlist.length - 1].push([\n            (x / Math.PI) * w * p,\n            -y * h * p + hoff,\n          ]);\n        }\n      }\n\n      function vegetate(treeFunc, growthRule, proofRule) {\n        var veglist = [];\n        for (var i = 0; i < ptlist.length; i += 1) {\n          for (var j = 0; j < ptlist[i].length; j += 1) {\n            if (growthRule(i, j)) {\n              veglist.push([ptlist[i][j][0], ptlist[i][j][1]]);\n            }\n          }\n        }\n        for (var i = 0; i < veglist.length; i++) {\n          if (proofRule(veglist, i)) {\n            canv += treeFunc(veglist[i][0], veglist[i][1]);\n          }\n        }\n      }\n      //RIM\n      vegetate(\n        function(x, y) {\n          return Tree.tree02(x + xoff, y + yoff - 5, {\n            col:\n              \"rgba(100,100,100,\" +\n              (Noise.noise(0.01 * x, 0.01 * y) * 0.5 * 0.3 + 0.5).toFixed(3) +\n              \")\",\n            clu: 2,\n          });\n        },\n        function(i, j) {\n          var ns = Noise.noise(j * 0.1, seed);\n          return (\n            i == 0 && ns * ns * ns < 0.1 && Math.abs(ptlist[i][j][1]) / h > 0.2\n          );\n        },\n        function(veglist, i) {\n          return true;\n        },\n      );\n\n      //WHITE BG\n      canv += poly(ptlist[0].concat([[0, reso[0] * 4]]), {\n        xof: xoff,\n        yof: yoff,\n        fil: \"white\",\n        str: \"none\",\n      });\n      //OUTLINE\n      canv += stroke(\n        ptlist[0].map(function(x) {\n          return [x[0] + xoff, x[1] + yoff];\n        }),\n        { col: \"rgba(100,100,100,0.3)\", noi: 1, wid: 3 },\n      );\n\n      canv += foot(ptlist, { xof: xoff, yof: yoff });\n      canv += texture(ptlist, {\n        xof: xoff,\n        yof: yoff,\n        tex: tex,\n        sha: randChoice([0, 0, 0, 0, 5]),\n        col: col,\n      });\n\n      //TOP\n      vegetate(\n        function(x, y) {\n          return Tree.tree02(x + xoff, y + yoff, {\n            col:\n              \"rgba(100,100,100,\" +\n              (Noise.noise(0.01 * x, 0.01 * y) * 0.5 * 0.3 + 0.5).toFixed(3) +\n              \")\",\n          });\n        },\n        function(i, j) {\n          var ns = Noise.noise(i * 0.1, j * 0.1, seed + 2);\n          return ns * ns * ns < 0.1 && Math.abs(ptlist[i][j][1]) / h > 0.5;\n        },\n        function(veglist, i) {\n          return true;\n        },\n      );\n\n      if (veg) {\n        //MIDDLE\n        vegetate(\n          function(x, y) {\n            var ht = ((h + y) / h) * 70;\n            ht = ht * 0.3 + Math.random() * ht * 0.7;\n            return Tree.tree01(x + xoff, y + yoff, {\n              hei: ht,\n              wid: Math.random() * 3 + 1,\n              col:\n                \"rgba(100,100,100,\" +\n                (Noise.noise(0.01 * x, 0.01 * y) * 0.5 * 0.3 + 0.3).toFixed(3) +\n                \")\",\n            });\n          },\n          function(i, j) {\n            var ns = Noise.noise(i * 0.2, j * 0.05, seed);\n            return (\n              j % 2 &&\n              ns * ns * ns * ns < 0.012 &&\n              Math.abs(ptlist[i][j][1]) / h < 0.3\n            );\n          },\n          function(veglist, i) {\n            var counter = 0;\n            for (var j = 0; j < veglist.length; j++) {\n              if (\n                i != j &&\n                Math.pow(veglist[i][0] - veglist[j][0], 2) +\n                  Math.pow(veglist[i][1] - veglist[j][1], 2) <\n                  30 * 30\n              ) {\n                counter++;\n              }\n              if (counter > 2) {\n                return true;\n              }\n            }\n            return false;\n          },\n        );\n\n        //BOTTOM\n        vegetate(\n          function(x, y) {\n            var ht = ((h + y) / h) * 120;\n            ht = ht * 0.5 + Math.random() * ht * 0.5;\n            var bc = Math.random() * 0.1;\n            var bp = 1;\n            return Tree.tree03(x + xoff, y + yoff, {\n              hei: ht,\n              ben: function(x) {\n                return Math.pow(x * bc, bp);\n              },\n              col:\n                \"rgba(100,100,100,\" +\n                (Noise.noise(0.01 * x, 0.01 * y) * 0.5 * 0.3 + 0.3).toFixed(3) +\n                \")\",\n            });\n          },\n          function(i, j) {\n            var ns = Noise.noise(i * 0.2, j * 0.05, seed);\n            return (\n              (j == 0 || j == ptlist[i].length - 1) && ns * ns * ns * ns < 0.012\n            );\n          },\n          function(veglist, i) {\n            return true;\n          },\n        );\n      }\n\n      //BOTT ARCH\n      vegetate(\n        function(x, y) {\n          var tt = randChoice([0, 0, 1, 1, 1, 2]);\n          if (tt == 1) {\n            return Arch.arch02(x + xoff, y + yoff, seed, {\n              wid: normRand(40, 70),\n              sto: randChoice([1, 2, 2, 3]),\n              rot: Math.random(),\n              sty: randChoice([1, 2, 3]),\n            });\n          } else if (tt == 2) {\n            return Arch.arch04(x + xoff, y + yoff, seed, {\n              sto: randChoice([1, 1, 1, 2, 2]),\n            });\n          } else {\n            return \"\";\n          }\n        },\n        function(i, j) {\n          var ns = Noise.noise(i * 0.2, j * 0.05, seed + 10);\n          return (\n            i != 0 &&\n            (j == 1 || j == ptlist[i].length - 2) &&\n            ns * ns * ns * ns < 0.008\n          );\n        },\n        function(veglist, i) {\n          return true;\n        },\n      );\n      //TOP ARCH\n      vegetate(\n        function(x, y) {\n          return Arch.arch03(x + xoff, y + yoff, seed, {\n            sto: randChoice([5, 7]),\n            wid: 40 + Math.random() * 20,\n          });\n        },\n        function(i, j) {\n          return (\n            i == 1 &&\n            Math.abs(j - ptlist[i].length / 2) < 1 &&\n            Math.random() < 0.02\n          );\n        },\n        function(veglist, i) {\n          return true;\n        },\n      );\n\n      //TRANSM\n      vegetate(\n        function(x, y) {\n          return Arch.transmissionTower01(x + xoff, y + yoff, seed);\n        },\n        function(i, j) {\n          var ns = Noise.noise(i * 0.2, j * 0.05, seed + 20 * Math.PI);\n          return (\n            i % 2 == 0 &&\n            (j == 1 || j == ptlist[i].length - 2) &&\n            ns * ns * ns * ns < 0.002\n          );\n        },\n        function(veglist, i) {\n          return true;\n        },\n      );\n\n      //BOTT ROCK\n      vegetate(\n        function(x, y) {\n          return Mount.rock(x + xoff, y + yoff, seed, {\n            wid: 20 + Math.random() * 20,\n            hei: 20 + Math.random() * 20,\n            sha: 2,\n          });\n        },\n        function(i, j) {\n          return (j == 0 || j == ptlist[i].length - 1) && Math.random() < 0.1;\n        },\n        function(veglist, i) {\n          return true;\n        },\n      );\n\n      if (ret == 0) {\n        return canv;\n      } else {\n        return [ptlist];\n      }\n    };\n\n    this.flatMount = function(xoff, yoff, seed, args) {\n      var args = args != undefined ? args : {};\n      var hei = args.hei != undefined ? args.hei : 40 + Math.random() * 400;\n      var wid = args.wid != undefined ? args.wid : 400 + Math.random() * 200;\n      var tex = args.tex != undefined ? args.tex : 80;\n      var cho = args.cho != undefined ? args.cho : 0.5;\n      var ret = args.ret != undefined ? args.ret : 0;\n\n      seed = seed != undefined ? seed : 0;\n\n      var canv = \"\";\n      var ptlist = [];\n      var reso = [5, 50];\n      var hoff = 0;\n      var flat = [];\n      for (var j = 0; j < reso[0]; j++) {\n        hoff += (Math.random() * yoff) / 100;\n        ptlist.push([]);\n        flat.push([]);\n        for (var i = 0; i < reso[1]; i++) {\n          var x = (i / reso[1] - 0.5) * Math.PI;\n          var y = Math.cos(x * 2) + 1;\n          y *= Noise.noise(x + 10, j * 0.1, seed);\n          var p = 1 - (j / reso[0]) * 0.6;\n          var nx = (x / Math.PI) * wid * p;\n          var ny = -y * hei * p + hoff;\n          var h = 100;\n          if (ny < -h * cho + hoff) {\n            ny = -h * cho + hoff;\n            if (flat[flat.length - 1].length % 2 == 0) {\n              flat[flat.length - 1].push([nx, ny]);\n            }\n          } else {\n            if (flat[flat.length - 1].length % 2 == 1) {\n              flat[flat.length - 1].push(\n                ptlist[ptlist.length - 1][ptlist[ptlist.length - 1].length - 1],\n              );\n            }\n          }\n\n          ptlist[ptlist.length - 1].push([nx, ny]);\n        }\n      }\n\n      //WHITE BG\n      canv += poly(ptlist[0].concat([[0, reso[0] * 4]]), {\n        xof: xoff,\n        yof: yoff,\n        fil: \"white\",\n        str: \"none\",\n      });\n      //OUTLINE\n      canv += stroke(\n        ptlist[0].map(function(x) {\n          return [x[0] + xoff, x[1] + yoff];\n        }),\n        { col: \"rgba(100,100,100,0.3)\", noi: 1, wid: 3 },\n      );\n\n      //canv += foot(ptlist,{xof:xoff,yof:yoff})\n      canv += texture(ptlist, {\n        xof: xoff,\n        yof: yoff,\n        tex: tex,\n        wid: 2,\n        dis: function() {\n          if (Math.random() > 0.5) {\n            return 0.1 + 0.4 * Math.random();\n          } else {\n            return 0.9 - 0.4 * Math.random();\n          }\n        },\n      });\n      var grlist1 = [];\n      var grlist2 = [];\n      for (var i = 0; i < flat.length; i += 2) {\n        if (flat[i].length >= 2) {\n          grlist1.push(flat[i][0]);\n          grlist2.push(flat[i][flat[i].length - 1]);\n        }\n      }\n\n      if (grlist1.length == 0) {\n        return canv;\n      }\n      var wb = [grlist1[0][0], grlist2[0][0]];\n      for (var i = 0; i < 3; i++) {\n        var p = 0.8 - i * 0.2;\n\n        grlist1.unshift([wb[0] * p, grlist1[0][1] - 5]);\n        grlist2.unshift([wb[1] * p, grlist2[0][1] - 5]);\n      }\n      wb = [grlist1[grlist1.length - 1][0], grlist2[grlist2.length - 1][0]];\n      for (var i = 0; i < 3; i++) {\n        var p = 0.6 - i * i * 0.1;\n        grlist1.push([wb[0] * p, grlist1[grlist1.length - 1][1] + 1]);\n        grlist2.push([wb[1] * p, grlist2[grlist2.length - 1][1] + 1]);\n      }\n\n      var d = 5;\n      grlist1 = div(grlist1, d);\n      grlist2 = div(grlist2, d);\n\n      var grlist = grlist1.reverse().concat(grlist2.concat([grlist1[0]]));\n      for (var i = 0; i < grlist.length; i++) {\n        var v = (1 - Math.abs((i % d) - d / 2) / (d / 2)) * 0.12;\n        grlist[i][0] *= 1 - v + Noise.noise(grlist[i][1] * 0.5) * v;\n      }\n      /*       for (var i = 0; i < ptlist.length; i++){\n        canv += poly(ptlist[i],{xof:xoff,yof:yoff,str:\"red\",fil:\"none\",wid:2})\n      }\n */\n      canv += poly(grlist, {\n        xof: xoff,\n        yof: yoff,\n        str: \"none\",\n        fil: \"white\",\n        wid: 2,\n      });\n      canv += stroke(grlist.map(x => [x[0] + xoff, x[1] + yoff]), {\n        wid: 3,\n        col: \"rgba(100,100,100,0.2)\",\n      });\n\n      var bound = function(plist) {\n        var xmin;\n        var xmax;\n        var ymin;\n        var ymax;\n        for (var i = 0; i < plist.length; i++) {\n          if (xmin == undefined || plist[i][0] < xmin) {\n            xmin = plist[i][0];\n          }\n          if (xmax == undefined || plist[i][0] > xmax) {\n            xmax = plist[i][0];\n          }\n          if (ymin == undefined || plist[i][1] < ymin) {\n            ymin = plist[i][1];\n          }\n          if (ymax == undefined || plist[i][1] > ymax) {\n            ymax = plist[i][1];\n          }\n        }\n        return { xmin: xmin, xmax: xmax, ymin: ymin, ymax: ymax };\n      };\n\n      canv += this.flatDec(xoff, yoff, bound(grlist));\n\n      return canv;\n    };\n\n    this.flatDec = function(xoff, yoff, grbd) {\n      var canv = \"\";\n\n      var tt = randChoice([0, 0, 1, 2, 3, 4]);\n\n      for (var j = 0; j < Math.random() * 5; j++) {\n        canv += Mount.rock(\n          xoff + normRand(grbd.xmin, grbd.xmax),\n          yoff + (grbd.ymin + grbd.ymax) / 2 + normRand(-10, 10) + 10,\n          Math.random() * 100,\n          {\n            wid: 10 + Math.random() * 20,\n            hei: 10 + Math.random() * 20,\n            sha: 2,\n          },\n        );\n      }\n      for (var j = 0; j < randChoice([0, 0, 1, 2]); j++) {\n        var xr = xoff + normRand(grbd.xmin, grbd.xmax);\n        var yr = yoff + (grbd.ymin + grbd.ymax) / 2 + normRand(-5, 5) + 20;\n        for (var k = 0; k < 2 + Math.random() * 3; k++) {\n          canv += Tree.tree08(\n            xr + Math.min(Math.max(normRand(-30, 30), grbd.xmin), grbd.xmax),\n            yr,\n            { hei: 60 + Math.random() * 40 },\n          );\n        }\n      }\n\n      if (tt == 0) {\n        for (var j = 0; j < Math.random() * 3; j++) {\n          canv += Mount.rock(\n            xoff + normRand(grbd.xmin, grbd.xmax),\n            yoff + (grbd.ymin + grbd.ymax) / 2 + normRand(-5, 5) + 20,\n            Math.random() * 100,\n            {\n              wid: 50 + Math.random() * 20,\n              hei: 40 + Math.random() * 20,\n              sha: 5,\n            },\n          );\n        }\n      }\n      if (tt == 1) {\n        var pmin = Math.random() * 0.5;\n        var pmax = Math.random() * 0.5 + 0.5;\n        var xmin = grbd.xmin * (1 - pmin) + grbd.xmax * pmin;\n        var xmax = grbd.xmin * (1 - pmax) + grbd.xmax * pmax;\n        for (var i = xmin; i < xmax; i += 30) {\n          canv += Tree.tree05(\n            xoff + i + 20 * normRand(-1, 1),\n            yoff + (grbd.ymin + grbd.ymax) / 2 + 20,\n            { hei: 100 + Math.random() * 200 },\n          );\n        }\n        for (var j = 0; j < Math.random() * 4; j++) {\n          canv += Mount.rock(\n            xoff + normRand(grbd.xmin, grbd.xmax),\n            yoff + (grbd.ymin + grbd.ymax) / 2 + normRand(-5, 5) + 20,\n            Math.random() * 100,\n            {\n              wid: 50 + Math.random() * 20,\n              hei: 40 + Math.random() * 20,\n              sha: 5,\n            },\n          );\n        }\n      } else if (tt == 2) {\n        for (var i = 0; i < randChoice([1, 1, 1, 1, 2, 2, 3]); i++) {\n          var xr = normRand(grbd.xmin, grbd.xmax);\n          var yr = (grbd.ymin + grbd.ymax) / 2;\n          canv += Tree.tree04(xoff + xr, yoff + yr + 20, {});\n          for (var j = 0; j < Math.random() * 2; j++) {\n            canv += Mount.rock(\n              xoff +\n                Math.max(\n                  grbd.xmin,\n                  Math.min(grbd.xmax, xr + normRand(-50, 50)),\n                ),\n              yoff + yr + normRand(-5, 5) + 20,\n              j * i * Math.random() * 100,\n              {\n                wid: 50 + Math.random() * 20,\n                hei: 40 + Math.random() * 20,\n                sha: 5,\n              },\n            );\n          }\n        }\n      } else if (tt == 3) {\n        for (var i = 0; i < randChoice([1, 1, 1, 1, 2, 2, 3]); i++) {\n          canv += Tree.tree06(\n            xoff + normRand(grbd.xmin, grbd.xmax),\n            yoff + (grbd.ymin + grbd.ymax) / 2,\n            { hei: 60 + Math.random() * 60 },\n          );\n        }\n      } else if (tt == 4) {\n        var pmin = Math.random() * 0.5;\n        var pmax = Math.random() * 0.5 + 0.5;\n        var xmin = grbd.xmin * (1 - pmin) + grbd.xmax * pmin;\n        var xmax = grbd.xmin * (1 - pmax) + grbd.xmax * pmax;\n        for (var i = xmin; i < xmax; i += 20) {\n          canv += Tree.tree07(\n            xoff + i + 20 * normRand(-1, 1),\n            yoff + (grbd.ymin + grbd.ymax) / 2 + normRand(-1, 1) + 0,\n            { hei: normRand(40, 80) },\n          );\n        }\n      }\n\n      for (var i = 0; i < 50 * Math.random(); i++) {\n        canv += Tree.tree02(\n          xoff + normRand(grbd.xmin, grbd.xmax),\n          yoff + normRand(grbd.ymin, grbd.ymax),\n        );\n      }\n\n      var ts = randChoice([0, 0, 0, 0, 1]);\n      if (ts == 1 && tt != 4) {\n        canv += Arch.arch01(\n          xoff + normRand(grbd.xmin, grbd.xmax),\n          yoff + (grbd.ymin + grbd.ymax) / 2 + 20,\n          Math.random(),\n          {\n            wid: normRand(160, 200),\n            hei: normRand(80, 100),\n            per: Math.random(),\n          },\n        );\n      }\n\n      return canv;\n    };\n\n    this.distMount = function(xoff, yoff, seed, args) {\n      var args = args != undefined ? args : {};\n      var hei = args.hei != undefined ? args.hei : 300;\n      var len = args.len != undefined ? args.len : 2000;\n      var seg = args.seg != undefined ? args.seg : 5;\n\n      seed = seed != undefined ? seed : 0;\n      var canv = \"\";\n      var span = 10;\n\n      var ptlist = [];\n\n      for (var i = 0; i < len / span / seg; i++) {\n        ptlist.push([]);\n        for (var j = 0; j < seg + 1; j++) {\n          var tran = function(k) {\n            return [\n              xoff + k * span,\n              yoff -\n                hei *\n                  Noise.noise(k * 0.05, seed) *\n                  Math.pow(Math.sin((Math.PI * k) / (len / span)), 0.5),\n            ];\n          };\n          ptlist[ptlist.length - 1].push(tran(i * seg + j));\n        }\n        for (var j = 0; j < seg / 2 + 1; j++) {\n          var tran = function(k) {\n            return [\n              xoff + k * span,\n              yoff +\n                24 *\n                  Noise.noise(k * 0.05, 2, seed) *\n                  Math.pow(Math.sin((Math.PI * k) / (len / span)), 1),\n            ];\n          };\n          ptlist[ptlist.length - 1].unshift(tran(i * seg + j * 2));\n        }\n      }\n      for (var i = 0; i < ptlist.length; i++) {\n        var getCol = function(x, y) {\n          var c = (Noise.noise(x * 0.02, y * 0.02, yoff) * 55 + 200) | 0;\n          return \"rgb(\" + c + \",\" + c + \",\" + c + \")\";\n        };\n        canv += poly(ptlist[i], {\n          fil: getCol(...ptlist[i][ptlist[i].length - 1]),\n          str: \"none\",\n          wid: 1,\n        });\n\n        var T = PolyTools.triangulate(ptlist[i], {\n          area: 100,\n          convex: true,\n          optimize: false,\n        });\n        for (var k = 0; k < T.length; k++) {\n          var m = PolyTools.midPt(T[k]);\n          var co = getCol(m[0], m[1]);\n          canv += poly(T[k], { fil: co, str: co, wid: 1 });\n        }\n      }\n      return canv;\n    };\n\n    this.rock = function(xoff, yoff, seed, args) {\n      var args = args != undefined ? args : {};\n      var hei = args.hei != undefined ? args.hei : 80;\n      var wid = args.wid != undefined ? args.wid : 100;\n      var tex = args.tex != undefined ? args.tex : 40;\n      var ret = args.ret != undefined ? args.ret : 0;\n      var sha = args.sha != undefined ? args.sha : 10;\n\n      seed = seed != undefined ? seed : 0;\n\n      var canv = \"\";\n\n      var reso = [10, 50];\n      var ptlist = [];\n\n      for (var i = 0; i < reso[0]; i++) {\n        ptlist.push([]);\n\n        var nslist = [];\n        for (var j = 0; j < reso[1]; j++) {\n          nslist.push(Noise.noise(i, j * 0.2, seed));\n        }\n        loopNoise(nslist);\n\n        for (var j = 0; j < reso[1]; j++) {\n          var a = (j / reso[1]) * Math.PI * 2 - Math.PI / 2;\n          var l =\n            (wid * hei) /\n            Math.sqrt(\n              Math.pow(hei * Math.cos(a), 2) + Math.pow(wid * Math.sin(a), 2),\n            );\n\n          /*           var l = Math.sin(a)>0? Math.pow(Math.sin(a),0.1)*wid\n                             : - Math.pow(Math.sin(a+Math.PI),0.1)*wid */\n          l *= 0.7 + 0.3 * nslist[j];\n\n          var p = 1 - i / reso[0];\n\n          var nx = Math.cos(a) * l * p;\n          var ny = -Math.sin(a) * l * p;\n\n          if (Math.PI < a || a < 0) {\n            ny *= 0.2;\n          }\n\n          ny += hei * (i / reso[0]) * 0.2;\n\n          ptlist[ptlist.length - 1].push([nx, ny]);\n        }\n      }\n\n      //WHITE BG\n      canv += poly(ptlist[0].concat([[0, 0]]), {\n        xof: xoff,\n        yof: yoff,\n        fil: \"white\",\n        str: \"none\",\n      });\n      //OUTLINE\n      canv += stroke(\n        ptlist[0].map(function(x) {\n          return [x[0] + xoff, x[1] + yoff];\n        }),\n        { col: \"rgba(100,100,100,0.3)\", noi: 1, wid: 3 },\n      );\n      canv += texture(ptlist, {\n        xof: xoff,\n        yof: yoff,\n        tex: tex,\n        wid: 3,\n        sha: sha,\n        col: function(x) {\n          return (\n            \"rgba(180,180,180,\" + (0.3 + Math.random() * 0.3).toFixed(3) + \")\"\n          );\n        },\n        dis: function() {\n          if (Math.random() > 0.5) {\n            return 0.15 + 0.15 * Math.random();\n          } else {\n            return 0.85 - 0.15 * Math.random();\n          }\n        },\n      });\n\n      for (var i = 0; i < reso[0]; i++) {\n        //canv += poly(ptlist[i],{xof:xoff,yof:yoff,fil:\"none\",str:\"red\",wid:2})\n      }\n      return canv;\n    };\n  }();\n\n  var Arch = new function() {\n    var flip = function(ptlist, axis) {\n      axis = axis == undefined ? 0 : axis;\n      for (var i = 0; i < ptlist.length; i++) {\n        if (ptlist[i].length > 0) {\n          if (typeof ptlist[i][0] == \"object\") {\n            for (var j = 0; j < ptlist[i].length; j++) {\n              ptlist[i][j][0] = axis - (ptlist[i][j][0] - axis);\n            }\n          } else {\n            ptlist[i][0] = axis - (ptlist[i][0] - axis);\n          }\n        }\n      }\n      return ptlist;\n    };\n\n    var hut = function(xoff, yoff, args) {\n      var args = args != undefined ? args : {};\n      var hei = args.hei != undefined ? args.hei : 40;\n      var wid = args.wid != undefined ? args.wid : 180;\n      var tex = args.tex != undefined ? args.tex : 300;\n\n      var reso = [10, 10];\n      var ptlist = [];\n\n      for (var i = 0; i < reso[0]; i++) {\n        ptlist.push([]);\n        var heir = hei + hei * 0.2 * Math.random();\n        for (var j = 0; j < reso[1]; j++) {\n          var nx =\n            wid * (i / (reso[0] - 1) - 0.5) * Math.pow(j / (reso[1] - 1), 0.7);\n          var ny = heir * (j / (reso[1] - 1));\n          ptlist[ptlist.length - 1].push([nx, ny]);\n        }\n      }\n      var canv = \"\";\n      canv += poly(\n        ptlist[0]\n          .slice(0, -1)\n          .concat(ptlist[ptlist.length - 1].slice(0, -1).reverse()),\n        { xof: xoff, yof: yoff, fil: \"white\", str: \"none\" },\n      );\n      canv += poly(ptlist[0], {\n        xof: xoff,\n        yof: yoff,\n        fil: \"none\",\n        str: \"rgba(100,100,100,0.3)\",\n        wid: 2,\n      });\n      canv += poly(ptlist[ptlist.length - 1], {\n        xof: xoff,\n        yof: yoff,\n        fil: \"none\",\n        str: \"rgba(100,100,100,0.3)\",\n        wid: 2,\n      });\n\n      canv += texture(ptlist, {\n        xof: xoff,\n        yof: yoff,\n        tex: tex,\n        wid: 1,\n        len: 0.25,\n        col: function(x) {\n          return (\n            \"rgba(120,120,120,\" + (0.3 + Math.random() * 0.3).toFixed(3) + \")\"\n          );\n        },\n        dis: function() {\n          return wtrand(a => a * a);\n        },\n        noi: function(x) {\n          return 5;\n        },\n      });\n\n      for (var i = 0; i < reso[0]; i++) {\n        //canv += poly(ptlist[i],{xof:xoff,yof:yoff,fil:\"none\",str:\"red\",wid:2})\n      }\n\n      return canv;\n    };\n\n    var box = function(xoff, yoff, args) {\n      var args = args != undefined ? args : {};\n      var hei = args.hei != undefined ? args.hei : 20;\n      var wid = args.wid != undefined ? args.wid : 120;\n      var rot = args.rot != undefined ? args.rot : 0.7;\n      var per = args.per != undefined ? args.per : 4;\n      var tra = args.tra != undefined ? args.tra : true;\n      var bot = args.bot != undefined ? args.bot : true;\n      var wei = args.wei != undefined ? args.wei : 3;\n      var dec =\n        args.dec != undefined\n          ? args.dec\n          : function(a) {\n              return [];\n            };\n\n      var mid = -wid * 0.5 + wid * rot;\n      var bmid = -wid * 0.5 + wid * (1 - rot);\n      var ptlist = [];\n      ptlist.push(div([[-wid * 0.5, -hei], [-wid * 0.5, 0]], 5));\n      ptlist.push(div([[wid * 0.5, -hei], [wid * 0.5, 0]], 5));\n      if (bot) {\n        ptlist.push(div([[-wid * 0.5, 0], [mid, per]], 5));\n        ptlist.push(div([[wid * 0.5, 0], [mid, per]], 5));\n      }\n      ptlist.push(div([[mid, -hei], [mid, per]], 5));\n      if (tra) {\n        if (bot) {\n          ptlist.push(div([[-wid * 0.5, 0], [bmid, -per]], 5));\n          ptlist.push(div([[wid * 0.5, 0], [bmid, -per]], 5));\n        }\n        ptlist.push(div([[bmid, -hei], [bmid, -per]], 5));\n      }\n\n      var surf = (rot < 0.5) * 2 - 1;\n      ptlist = ptlist.concat(\n        dec({\n          pul: [surf * wid * 0.5, -hei],\n          pur: [mid, -hei + per],\n          pdl: [surf * wid * 0.5, 0],\n          pdr: [mid, per],\n        }),\n      );\n\n      var polist = [\n        [-wid * 0.5, -hei],\n        [wid * 0.5, -hei],\n        [wid * 0.5, 0],\n        [mid, per],\n        [-wid * 0.5, 0],\n      ];\n\n      var canv = \"\";\n      if (!tra) {\n        canv += poly(polist, {\n          xof: xoff,\n          yof: yoff,\n          str: \"none\",\n          fil: \"white\",\n        });\n      }\n\n      for (var i = 0; i < ptlist.length; i++) {\n        canv += stroke(\n          ptlist[i].map(function(x) {\n            return [x[0] + xoff, x[1] + yoff];\n          }),\n          {\n            col: \"rgba(100,100,100,0.4)\",\n            noi: 1,\n            wid: wei,\n            fun: function(x) {\n              return 1;\n            },\n          },\n        );\n      }\n      return canv;\n    };\n\n    var deco = function(style, args) {\n      var args = args != undefined ? args : {};\n      var pul = args.pul != undefined ? args.pul : [0, 0];\n      var pur = args.pur != undefined ? args.pur : [0, 100];\n      var pdl = args.pdl != undefined ? args.pdl : [100, 0];\n      var pdr = args.pdr != undefined ? args.pdr : [100, 100];\n      var hsp = args.hsp != undefined ? args.hsp : [1, 3];\n      var vsp = args.vsp != undefined ? args.vsp : [1, 2];\n\n      var plist = [];\n      var dl = div([pul, pdl], vsp[1]);\n      var dr = div([pur, pdr], vsp[1]);\n      var du = div([pul, pur], hsp[1]);\n      var dd = div([pdl, pdr], hsp[1]);\n\n      if (style == 1) {\n        //-| |-\n        var mlu = du[hsp[0]];\n        var mru = du[du.length - 1 - hsp[0]];\n        var mld = dd[hsp[0]];\n        var mrd = dd[du.length - 1 - hsp[0]];\n\n        for (var i = vsp[0]; i < dl.length - vsp[0]; i += vsp[0]) {\n          var mml = div([mlu, mld], vsp[1])[i];\n          var mmr = div([mru, mrd], vsp[1])[i];\n          var ml = dl[i];\n          var mr = dr[i];\n          plist.push(div([mml, ml], 5));\n          plist.push(div([mmr, mr], 5));\n        }\n        plist.push(div([mlu, mld], 5));\n        plist.push(div([mru, mrd], 5));\n      } else if (style == 2) {\n        //||||\n\n        for (var i = hsp[0]; i < du.length - hsp[0]; i += hsp[0]) {\n          var mu = du[i];\n          var md = dd[i];\n          plist.push(div([mu, md], 5));\n        }\n      } else if (style == 3) {\n        //|##|\n        var mlu = du[hsp[0]];\n        var mru = du[du.length - 1 - hsp[0]];\n        var mld = dd[hsp[0]];\n        var mrd = dd[du.length - 1 - hsp[0]];\n\n        for (var i = vsp[0]; i < dl.length - vsp[0]; i += vsp[0]) {\n          var mml = div([mlu, mld], vsp[1])[i];\n          var mmr = div([mru, mrd], vsp[1])[i];\n          var mmu = div([mlu, mru], vsp[1])[i];\n          var mmd = div([mld, mrd], vsp[1])[i];\n\n          var ml = dl[i];\n          var mr = dr[i];\n          plist.push(div([mml, mmr], 5));\n          plist.push(div([mmu, mmd], 5));\n        }\n        plist.push(div([mlu, mld], 5));\n        plist.push(div([mru, mrd], 5));\n      }\n      return plist;\n    };\n\n    var rail = function(xoff, yoff, seed, args) {\n      var args = args != undefined ? args : {};\n      var hei = args.hei != undefined ? args.hei : 20;\n      var wid = args.wid != undefined ? args.wid : 180;\n      var rot = args.rot != undefined ? args.rot : 0.7;\n      var per = args.per != undefined ? args.per : 4;\n      var seg = args.seg != undefined ? args.seg : 4;\n      var wei = args.wei != undefined ? args.wei : 1;\n      var tra = args.tra != undefined ? args.tra : true;\n      var fro = args.fro != undefined ? args.fro : true;\n\n      seed = seed != undefined ? seed : 0;\n\n      var mid = -wid * 0.5 + wid * rot;\n      var bmid = -wid * 0.5 + wid * (1 - rot);\n      var ptlist = [];\n\n      if (fro) {\n        ptlist.push(div([[-wid * 0.5, 0], [mid, per]], seg));\n        ptlist.push(div([[mid, per], [wid * 0.5, 0]], seg));\n      }\n      if (tra) {\n        ptlist.push(div([[-wid * 0.5, 0], [bmid, -per]], seg));\n        ptlist.push(div([[bmid, -per], [wid * 0.5, 0]], seg));\n      }\n      if (fro) {\n        ptlist.push(div([[-wid * 0.5, -hei], [mid, -hei + per]], seg));\n        ptlist.push(div([[mid, -hei + per], [wid * 0.5, -hei]], seg));\n      }\n      if (tra) {\n        ptlist.push(div([[-wid * 0.5, -hei], [bmid, -hei - per]], seg));\n        ptlist.push(div([[bmid, -hei - per], [wid * 0.5, -hei]], seg));\n      }\n      if (tra) {\n        var open = Math.floor(Math.random() * ptlist.length);\n        ptlist[open] = ptlist[open].slice(0, -1);\n        ptlist[(open + ptlist.length) % ptlist.length] = ptlist[\n          (open + ptlist.length) % ptlist.length\n        ].slice(0, -1);\n      }\n      var canv = \"\";\n\n      for (var i = 0; i < ptlist.length / 2; i++) {\n        for (var j = 0; j < ptlist[i].length; j++) {\n          //ptlist.push(div([ptlist[i][j],ptlist[4+i][j]],2))\n          ptlist[i][j][1] += (Noise.noise(i, j * 0.5, seed) - 0.5) * hei;\n          ptlist[(ptlist.length / 2 + i) % ptlist.length][\n            j % ptlist[(ptlist.length / 2 + i) % ptlist.length].length\n          ][1] += (Noise.noise(i + 0.5, j * 0.5, seed) - 0.5) * hei;\n          var ln = div(\n            [\n              ptlist[i][j],\n              ptlist[(ptlist.length / 2 + i) % ptlist.length][\n                j % ptlist[(ptlist.length / 2 + i) % ptlist.length].length\n              ],\n            ],\n            2,\n          );\n          ln[0][0] += (Math.random() - 0.5) * hei * 0.5;\n          canv += poly(ln, {\n            xof: xoff,\n            yof: yoff,\n            fil: \"none\",\n            str: \"rgba(100,100,100,0.5)\",\n            wid: 2,\n          });\n        }\n      }\n\n      for (var i = 0; i < ptlist.length; i++) {\n        canv += stroke(\n          ptlist[i].map(function(x) {\n            return [x[0] + xoff, x[1] + yoff];\n          }),\n          {\n            col: \"rgba(100,100,100,0.5)\",\n            noi: 0.5,\n            wid: wei,\n            fun: function(x) {\n              return 1;\n            },\n          },\n        );\n      }\n      return canv;\n    };\n\n    var roof = function(xoff, yoff, args) {\n      var args = args != undefined ? args : {};\n      var hei = args.hei != undefined ? args.hei : 20;\n      var wid = args.wid != undefined ? args.wid : 120;\n      var rot = args.rot != undefined ? args.rot : 0.7;\n      var per = args.per != undefined ? args.per : 4;\n      var cor = args.cor != undefined ? args.cor : 5;\n      var wei = args.wei != undefined ? args.wei : 3;\n      var pla = args.pla != undefined ? args.pla : [0, \"\"];\n\n      var opf = function(ptlist) {\n        if (rot < 0.5) {\n          return flip(ptlist);\n        } else {\n          return ptlist;\n        }\n      };\n      var rrot = rot < 0.5 ? 1 - rot : rot;\n\n      var mid = -wid * 0.5 + wid * rrot;\n      var bmid = -wid * 0.5 + wid * (1 - rrot);\n      var quat = (mid + wid * 0.5) * 0.5 - mid;\n\n      var ptlist = [];\n      ptlist.push(\n        div(\n          opf([\n            [-wid * 0.5 + quat, -hei - per / 2],\n            [-wid * 0.5 + quat * 0.5, -hei / 2 - per / 4],\n            [-wid * 0.5 - cor, 0],\n          ]),\n          5,\n        ),\n      );\n      ptlist.push(\n        div(\n          opf([\n            [mid + quat, -hei],\n            [(mid + quat + wid * 0.5) / 2, -hei / 2],\n            [wid * 0.5 + cor, 0],\n          ]),\n          5,\n        ),\n      );\n      ptlist.push(\n        div(\n          opf([\n            [mid + quat, -hei],\n            [mid + quat / 2, -hei / 2 + per / 2],\n            [mid + cor, per],\n          ]),\n          5,\n        ),\n      );\n\n      ptlist.push(div(opf([[-wid * 0.5 - cor, 0], [mid + cor, per]]), 5));\n      ptlist.push(div(opf([[wid * 0.5 + cor, 0], [mid + cor, per]]), 5));\n\n      ptlist.push(\n        div(opf([[-wid * 0.5 + quat, -hei - per / 2], [mid + quat, -hei]]), 5),\n      );\n\n      var canv = \"\";\n\n      var polist = opf([\n        [-wid * 0.5, 0],\n        [-wid * 0.5 + quat, -hei - per / 2],\n        [mid + quat, -hei],\n        [wid * 0.5, 0],\n        [mid, per],\n      ]);\n      canv += poly(polist, { xof: xoff, yof: yoff, str: \"none\", fil: \"white\" });\n\n      for (var i = 0; i < ptlist.length; i++) {\n        canv += stroke(\n          ptlist[i].map(function(x) {\n            return [x[0] + xoff, x[1] + yoff];\n          }),\n          {\n            col: \"rgba(100,100,100,0.4)\",\n            noi: 1,\n            wid: wei,\n            fun: function(x) {\n              return 1;\n            },\n          },\n        );\n      }\n\n      if (pla[0] == 1) {\n        var pp = opf([\n          [mid + quat / 2, -hei / 2 + per / 2],\n          [-wid * 0.5 + quat * 0.5, -hei / 2 - per / 4],\n        ]);\n        if (pp[0][0] > pp[1][0]) {\n          pp = [pp[1], pp[0]];\n        }\n        var mp = PolyTools.midPt(pp);\n        var a = Math.atan2(pp[1][1] - pp[0][1], pp[1][0] - pp[0][0]);\n        var adeg = (a * 180) / Math.PI;\n        canv +=\n          \"<text font-size='\" +\n          hei * 0.6 +\n          \"' font-family='Verdana'\" +\n          \" style='fill:rgba(100,100,100,0.9)'\" +\n          \" text-anchor='middle' transform='translate(\" +\n          (mp[0] + xoff) +\n          \",\" +\n          (mp[1] + yoff) +\n          \") rotate(\" +\n          adeg +\n          \")'>\" +\n          pla[1] +\n          \"</text>\";\n      }\n      return canv;\n    };\n\n    var pagroof = function(xoff, yoff, args) {\n      var args = args != undefined ? args : {};\n      var hei = args.hei != undefined ? args.hei : 20;\n      var wid = args.wid != undefined ? args.wid : 120;\n      var rot = args.rot != undefined ? args.rot : 0.7;\n      var per = args.per != undefined ? args.per : 4;\n      var cor = args.cor != undefined ? args.cor : 10;\n      var sid = args.sid != undefined ? args.sid : 4;\n      var wei = args.wei != undefined ? args.wei : 3;\n\n      var ptlist = [];\n      var polist = [[0, -hei]];\n      var canv = \"\";\n      for (var i = 0; i < sid; i++) {\n        var fx = wid * ((i * 1.0) / (sid - 1) - 0.5);\n        var fy = per * (1 - Math.abs((i * 1.0) / (sid - 1) - 0.5) * 2);\n        var fxx = (wid + cor) * ((i * 1.0) / (sid - 1) - 0.5);\n        if (i > 0) {\n          ptlist.push([ptlist[ptlist.length - 1][2], [fxx, fy]]);\n        }\n        ptlist.push([[0, -hei], [fx * 0.5, (-hei + fy) * 0.5], [fxx, fy]]);\n        polist.push([fxx, fy]);\n      }\n\n      canv += poly(polist, { xof: xoff, yof: yoff, str: \"none\", fil: \"white\" });\n      for (var i = 0; i < ptlist.length; i++) {\n        canv += stroke(\n          div(ptlist[i], 5).map(function(x) {\n            return [x[0] + xoff, x[1] + yoff];\n          }),\n          {\n            col: \"rgba(100,100,100,0.4)\",\n            noi: 1,\n            wid: wei,\n            fun: function(x) {\n              return 1;\n            },\n          },\n        );\n      }\n\n      return canv;\n    };\n\n    this.arch01 = function(xoff, yoff, seed, args) {\n      var args = args != undefined ? args : {};\n      var hei = args.hei != undefined ? args.hei : 70;\n      var wid = args.wid != undefined ? args.wid : 180;\n      var rot = args.rot != undefined ? args.rot : 0.7;\n      var per = args.per != undefined ? args.per : 5;\n\n      seed = seed != undefined ? seed : 0;\n\n      var p = 0.4 + Math.random() * 0.2;\n      var h0 = hei * p;\n      var h1 = hei * (1 - p);\n\n      var canv = \"\";\n      canv += hut(xoff, yoff - hei, { hei: h0, wid: wid });\n      canv += box(xoff, yoff, {\n        hei: h1,\n        wid: (wid * 2) / 3,\n        per: per,\n        bot: false,\n      });\n\n      canv += rail(xoff, yoff, seed, {\n        tra: true,\n        fro: false,\n        hei: 10,\n        wid: wid,\n        per: per * 2,\n        seg: (3 + Math.random() * 3) | 0,\n      });\n\n      var mcnt = randChoice([0, 1, 1, 2]);\n      if (mcnt == 1) {\n        canv += Man.man(xoff + normRand(-wid / 3, wid / 3), yoff, {\n          fli: randChoice([true, false]),\n          sca: 0.42,\n        });\n      } else if (mcnt == 2) {\n        canv += Man.man(xoff + normRand(-wid / 4, -wid / 5), yoff, {\n          fli: false,\n          sca: 0.42,\n        });\n        canv += Man.man(xoff + normRand(wid / 5, wid / 4), yoff, {\n          fli: true,\n          sca: 0.42,\n        });\n      }\n      canv += rail(xoff, yoff, seed, {\n        tra: false,\n        fro: true,\n        hei: 10,\n        wid: wid,\n        per: per * 2,\n        seg: (3 + Math.random() * 3) | 0,\n      });\n\n      return canv;\n    };\n\n    this.arch02 = function(xoff, yoff, seed, args) {\n      var args = args != undefined ? args : {};\n      var hei = args.hei != undefined ? args.hei : 10;\n      var wid = args.wid != undefined ? args.wid : 50;\n      var rot = args.rot != undefined ? args.rot : 0.3;\n      var per = args.per != undefined ? args.per : 5;\n      var sto = args.sto != undefined ? args.sto : 3;\n      var sty = args.sty != undefined ? args.sty : 1;\n      var rai = args.rai != undefined ? args.rai : false;\n\n      seed = seed != undefined ? seed : 0;\n      var canv = \"\";\n\n      var hoff = 0;\n      for (var i = 0; i < sto; i++) {\n        canv += box(xoff, yoff - hoff, {\n          tra: false,\n          hei: hei,\n          wid: wid * Math.pow(0.85, i),\n          rot: rot,\n          wei: 1.5,\n          per: per,\n          dec: function(a) {\n            return deco(\n              sty,\n              Object.assign({}, a, {\n                hsp: [[], [1, 5], [1, 5], [1, 4]][sty],\n                vsp: [[], [1, 2], [1, 2], [1, 3]][sty],\n              }),\n            );\n          },\n        });\n        canv += rai\n          ? rail(xoff, yoff - hoff, i * 0.2, {\n              wid: wid * Math.pow(0.85, i) * 1.1,\n              hei: hei / 2,\n              per: per,\n              rot: rot,\n              wei: 0.5,\n              tra: false,\n            })\n          : [];\n        var pla = undefined;\n        if (sto == 1 && Math.random() < 1 / 3) {\n          pla = [1, \"Pizza Hut\"];\n        }\n        canv += roof(xoff, yoff - hoff - hei, {\n          hei: hei,\n          wid: wid * Math.pow(0.9, i),\n          rot: rot,\n          wei: 1.5,\n          per: per,\n          pla: pla,\n        });\n\n        hoff += hei * 1.5;\n      }\n      return canv;\n    };\n    this.arch03 = function(xoff, yoff, seed, args) {\n      var args = args != undefined ? args : {};\n      var hei = args.hei != undefined ? args.hei : 10;\n      var wid = args.wid != undefined ? args.wid : 50;\n      var rot = args.rot != undefined ? args.rot : 0.7;\n      var per = args.per != undefined ? args.per : 5;\n      var sto = args.sto != undefined ? args.sto : 7;\n\n      seed = seed != undefined ? seed : 0;\n      var canv = \"\";\n\n      var hoff = 0;\n      for (var i = 0; i < sto; i++) {\n        canv += box(xoff, yoff - hoff, {\n          tra: false,\n          hei: hei,\n          wid: wid * Math.pow(0.85, i),\n          rot: rot,\n          wei: 1.5,\n          per: per / 2,\n          dec: function(a) {\n            return deco(1, Object.assign({}, a, { hsp: [1, 4], vsp: [1, 2] }));\n          },\n        });\n        canv += rail(xoff, yoff - hoff, i * 0.2, {\n          seg: 5,\n          wid: wid * Math.pow(0.85, i) * 1.1,\n          hei: hei / 2,\n          per: per / 2,\n          rot: rot,\n          wei: 0.5,\n          tra: false,\n        });\n        canv += pagroof(xoff, yoff - hoff - hei, {\n          hei: hei * 1.5,\n          wid: wid * Math.pow(0.9, i),\n          rot: rot,\n          wei: 1.5,\n          per: per,\n        });\n        hoff += hei * 1.5;\n      }\n      return canv;\n    };\n    this.arch04 = function(xoff, yoff, seed, args) {\n      var args = args != undefined ? args : {};\n      var hei = args.hei != undefined ? args.hei : 15;\n      var wid = args.wid != undefined ? args.wid : 30;\n      var rot = args.rot != undefined ? args.rot : 0.7;\n      var per = args.per != undefined ? args.per : 5;\n      var sto = args.sto != undefined ? args.sto : 2;\n\n      seed = seed != undefined ? seed : 0;\n      var canv = \"\";\n\n      var hoff = 0;\n      for (var i = 0; i < sto; i++) {\n        canv += box(xoff, yoff - hoff, {\n          tra: true,\n          hei: hei,\n          wid: wid * Math.pow(0.85, i),\n          rot: rot,\n          wei: 1.5,\n          per: per / 2,\n          dec: function(a) {\n            return [];\n          },\n        });\n        canv += rail(xoff, yoff - hoff, i * 0.2, {\n          seg: 3,\n          wid: wid * Math.pow(0.85, i) * 1.2,\n          hei: hei / 3,\n          per: per / 2,\n          rot: rot,\n          wei: 0.5,\n          tra: true,\n        });\n        canv += pagroof(xoff, yoff - hoff - hei, {\n          hei: hei * 1,\n          wid: wid * Math.pow(0.9, i),\n          rot: rot,\n          wei: 1.5,\n          per: per,\n        });\n        hoff += hei * 1.2;\n      }\n      return canv;\n    };\n\n    this.boat01 = function(xoff, yoff, seed, args) {\n      var args = args != undefined ? args : {};\n      var len = args.len != undefined ? args.len : 120;\n      var sca = args.sca != undefined ? args.sca : 1;\n      var fli = args.fli != undefined ? args.fli : false;\n      var canv = \"\";\n\n      var dir = fli ? -1 : 1;\n      canv += Man.man(xoff + 20 * sca * dir, yoff, {\n        ite: Man.stick01,\n        hat: Man.hat02,\n        sca: 0.5 * sca,\n        fli: !fli,\n        len: [0, 30, 20, 30, 10, 30, 30, 30, 30],\n      });\n\n      var plist1 = [];\n      var plist2 = [];\n      var fun1 = function(x) {\n        return Math.pow(Math.sin(x * Math.PI), 0.5) * 7 * sca;\n      };\n      var fun2 = function(x) {\n        return Math.pow(Math.sin(x * Math.PI), 0.5) * 10 * sca;\n      };\n      for (var i = 0; i < len * sca; i += 5 * sca) {\n        plist1.push([i * dir, fun1(i / len)]);\n        plist2.push([i * dir, fun2(i / len)]);\n      }\n      var plist = plist1.concat(plist2.reverse());\n      canv += poly(plist, { xof: xoff, yof: yoff, fil: \"white\" });\n      canv += stroke(plist.map(v => [xoff + v[0], yoff + v[1]]), {\n        wid: 1,\n        fun: function(x) {\n          return Math.sin(x * Math.PI * 2);\n        },\n        col: \"rgba(100,100,100,0.4)\",\n      });\n\n      return canv;\n    };\n\n    this.transmissionTower01 = function(xoff, yoff, seed, args) {\n      var args = args != undefined ? args : {};\n      var hei = args.hei != undefined ? args.hei : 100;\n      var wid = args.wid != undefined ? args.wid : 20;\n\n      var canv = \"\";\n      var toGlobal = function(v) {\n        return [v[0] + xoff, v[1] + yoff];\n      };\n\n      var quickstroke = function(pl) {\n        return stroke(div(pl, 5).map(toGlobal), {\n          wid: 1,\n          fun: x => 0.5,\n          col: \"rgba(100,100,100,0.4)\",\n        });\n      };\n\n      var p00 = [-wid * 0.05, -hei];\n      var p01 = [wid * 0.05, -hei];\n\n      var p10 = [-wid * 0.1, -hei * 0.9];\n      var p11 = [wid * 0.1, -hei * 0.9];\n\n      var p20 = [-wid * 0.2, -hei * 0.5];\n      var p21 = [wid * 0.2, -hei * 0.5];\n\n      var p30 = [-wid * 0.5, 0];\n      var p31 = [wid * 0.5, 0];\n\n      var bch = [[0.7, -0.85], [1, -0.675], [0.7, -0.5]];\n\n      for (var i = 0; i < bch.length; i++) {\n        canv += quickstroke([\n          [-bch[i][0] * wid, bch[i][1] * hei],\n          [bch[i][0] * wid, bch[i][1] * hei],\n        ]);\n        canv += quickstroke([\n          [-bch[i][0] * wid, bch[i][1] * hei],\n          [0, (bch[i][1] - 0.05) * hei],\n        ]);\n        canv += quickstroke([\n          [bch[i][0] * wid, bch[i][1] * hei],\n          [0, (bch[i][1] - 0.05) * hei],\n        ]);\n\n        canv += quickstroke([\n          [-bch[i][0] * wid, bch[i][1] * hei],\n          [-bch[i][0] * wid, (bch[i][1] + 0.1) * hei],\n        ]);\n        canv += quickstroke([\n          [bch[i][0] * wid, bch[i][1] * hei],\n          [bch[i][0] * wid, (bch[i][1] + 0.1) * hei],\n        ]);\n      }\n\n      var l10 = div([p00, p10, p20, p30], 5);\n      var l11 = div([p01, p11, p21, p31], 5);\n\n      for (var i = 0; i < l10.length - 1; i++) {\n        canv += quickstroke([l10[i], l11[i + 1]]);\n        canv += quickstroke([l11[i], l10[i + 1]]);\n      }\n\n      canv += quickstroke([p00, p01]);\n      canv += quickstroke([p10, p11]);\n      canv += quickstroke([p20, p21]);\n      canv += quickstroke([p00, p10, p20, p30]);\n      canv += quickstroke([p01, p11, p21, p31]);\n\n      return canv;\n    };\n  }();\n\n  var Man = new function() {\n    var expand = function(ptlist, wfun) {\n      vtxlist0 = [];\n      vtxlist1 = [];\n      vtxlist = [];\n      var n0 = Math.random() * 10;\n      for (var i = 1; i < ptlist.length - 1; i++) {\n        var w = wfun(i / ptlist.length);\n        var a1 = Math.atan2(\n          ptlist[i][1] - ptlist[i - 1][1],\n          ptlist[i][0] - ptlist[i - 1][0],\n        );\n        var a2 = Math.atan2(\n          ptlist[i][1] - ptlist[i + 1][1],\n          ptlist[i][0] - ptlist[i + 1][0],\n        );\n        var a = (a1 + a2) / 2;\n        if (a < a2) {\n          a += Math.PI;\n        }\n        vtxlist0.push([\n          ptlist[i][0] + w * Math.cos(a),\n          ptlist[i][1] + w * Math.sin(a),\n        ]);\n        vtxlist1.push([\n          ptlist[i][0] - w * Math.cos(a),\n          ptlist[i][1] - w * Math.sin(a),\n        ]);\n      }\n      var l = ptlist.length - 1;\n      var a0 =\n        Math.atan2(ptlist[1][1] - ptlist[0][1], ptlist[1][0] - ptlist[0][0]) -\n        Math.PI / 2;\n      var a1 =\n        Math.atan2(\n          ptlist[l][1] - ptlist[l - 1][1],\n          ptlist[l][0] - ptlist[l - 1][0],\n        ) -\n        Math.PI / 2;\n      var w0 = wfun(0);\n      var w1 = wfun(1);\n      vtxlist0.unshift([\n        ptlist[0][0] + w0 * Math.cos(a0),\n        ptlist[0][1] + w0 * Math.sin(a0),\n      ]);\n      vtxlist1.unshift([\n        ptlist[0][0] - w0 * Math.cos(a0),\n        ptlist[0][1] - w0 * Math.sin(a0),\n      ]);\n      vtxlist0.push([\n        ptlist[l][0] + w1 * Math.cos(a1),\n        ptlist[l][1] + w1 * Math.sin(a1),\n      ]);\n      vtxlist1.push([\n        ptlist[l][0] - w1 * Math.cos(a1),\n        ptlist[l][1] - w1 * Math.sin(a1),\n      ]);\n      return [vtxlist0, vtxlist1];\n    };\n\n    var tranpoly = function(p0, p1, ptlist) {\n      var plist = ptlist.map(function(v) {\n        return [-v[0], v[1]];\n      });\n      var ang = Math.atan2(p1[1] - p0[1], p1[0] - p0[0]) - Math.PI / 2;\n      var scl = distance(p0, p1);\n      var qlist = plist.map(function(v) {\n        var d = distance(v, [0, 0]);\n        var a = Math.atan2(v[1], v[0]);\n        return [\n          p0[0] + d * scl * Math.cos(ang + a),\n          p0[1] + d * scl * Math.sin(ang + a),\n        ];\n      });\n      return qlist;\n    };\n    var flipper = function(plist) {\n      return plist.map(function(v) {\n        return [-v[0], v[1]];\n      });\n    };\n\n    this.hat01 = function(p0, p1, args) {\n      var args = args != undefined ? args : {};\n      var fli = args.fli != undefined ? args.fli : false;\n\n      var canv = \"\";\n      var seed = Math.random();\n      var f = fli\n        ? flipper\n        : function(x) {\n            return x;\n          };\n      //var plist = [[-0.5,0.5],[0.5,0.5],[0.5,1],[-0.5,2]]\n      canv += poly(\n        tranpoly(\n          p0,\n          p1,\n          f([\n            [-0.3, 0.5],\n            [0.3, 0.8],\n            [0.2, 1],\n            [0, 1.1],\n            [-0.3, 1.15],\n            [-0.55, 1],\n            [-0.65, 0.5],\n          ]),\n        ),\n        { fil: \"rgba(100,100,100,0.8)\" },\n      );\n\n      var qlist1 = [];\n      for (var i = 0; i < 10; i++) {\n        qlist1.push([\n          -0.3 - Noise.noise(i * 0.2, seed) * i * 0.1,\n          0.5 - i * 0.3,\n        ]);\n      }\n      canv += poly(tranpoly(p0, p1, f(qlist1)), {\n        str: \"rgba(100,100,100,0.8)\",\n        wid: 1,\n      });\n\n      return canv;\n    };\n\n    this.hat02 = function(p0, p1, args) {\n      var args = args != undefined ? args : {};\n      var fli = args.fli != undefined ? args.fli : false;\n\n      var canv = \"\";\n      var seed = Math.random();\n\n      var f = fli\n        ? flipper\n        : function(x) {\n            return x;\n          };\n      // canv += poly(tranpoly(p0,p1,[\n      //   [-0.3,0.6],[-0.15,1.0],[0,1.1],[0.15,1.0],[0.3,0.6]\n      //   ]),{fil:\"white\",str:\"rgba(130,130,130,0.8)\",wid:1})\n      canv += poly(\n        tranpoly(\n          p0,\n          p1,\n          f([\n            [-0.3, 0.5],\n            [-1.1, 0.5],\n            [-1.2, 0.6],\n            [-1.1, 0.7],\n            [-0.3, 0.8],\n            [0.3, 0.8],\n            [1.0, 0.7],\n            [1.3, 0.6],\n            [1.2, 0.5],\n            [0.3, 0.5],\n          ]),\n        ),\n        { fil: \"rgba(100,100,100,0.8)\" },\n      );\n      return canv;\n    };\n\n    this.stick01 = function(p0, p1, args) {\n      var args = args != undefined ? args : {};\n      var fli = args.fli != undefined ? args.fli : false;\n\n      var canv = \"\";\n      var seed = Math.random();\n      var f = fli\n        ? flipper\n        : function(x) {\n            return x;\n          };\n\n      var qlist1 = [];\n      var l = 12;\n      for (var i = 0; i < l; i++) {\n        qlist1.push([\n          -Noise.noise(i * 0.1, seed) * 0.1 * Math.sin((i / l) * Math.PI) * 5,\n          0 + i * 0.3,\n        ]);\n      }\n      canv += poly(tranpoly(p0, p1, f(qlist1)), {\n        str: \"rgba(100,100,100,0.5)\",\n        wid: 1,\n      });\n\n      return canv;\n    };\n\n    //      2\n    //    1/\n    // 7/  | \\_ 6\n    // 8| 0 \\ 5\n    //      /3\n    //     4\n\n    this.man = function(xoff, yoff, args) {\n      var args = args != undefined ? args : {};\n      var sca = args.sca != undefined ? args.sca : 0.5;\n      var hat = args.hat != undefined ? args.hat : Man.hat01;\n      var ite =\n        args.ite != undefined\n          ? args.ite\n          : function() {\n              return \"\";\n            };\n      var fli = args.fli != undefined ? args.fli : true;\n      var ang =\n        args.ang != undefined\n          ? args.ang\n          : [\n              0,\n              -Math.PI / 2,\n              normRand(0, 0),\n              (Math.PI / 4) * Math.random(),\n              ((Math.PI * 3) / 4) * Math.random(),\n              (Math.PI * 3) / 4,\n              -Math.PI / 4,\n              (-Math.PI * 3) / 4 - (Math.PI / 4) * Math.random(),\n              -Math.PI / 4,\n            ];\n      var len =\n        args.len != undefined ? args.len : [0, 30, 20, 30, 30, 30, 30, 30, 30];\n\n      len = len.map(function(v) {\n        return v * sca;\n      });\n      var canv = \"\";\n      var sct = {\n        0: { 1: { 2: {}, 5: { 6: {} }, 7: { 8: {} } }, 3: { 4: {} } },\n      };\n      var toGlobal = function(v) {\n        return [(fli ? -1 : 1) * v[0] + xoff, v[1] + yoff];\n      };\n\n      function gpar(sct, ind) {\n        var keys = Object.keys(sct);\n        for (var i = 0; i < keys.length; i++) {\n          if (keys[i] == ind) {\n            return [ind];\n          } else {\n            var r = gpar(sct[keys[i]], ind);\n            if (r != false) {\n              return [parseFloat(keys[i])].concat(r);\n            }\n          }\n        }\n        return false;\n      }\n      function grot(sct, ind) {\n        var par = gpar(sct, ind);\n        var rot = 0;\n        for (var i = 0; i < par.length; i++) {\n          rot += ang[par[i]];\n        }\n        return rot;\n      }\n      function gpos(sct, ind) {\n        var par = gpar(sct, ind);\n        var pos = [0, 0];\n        for (var i = 0; i < par.length; i++) {\n          var a = grot(sct, par[i]);\n          pos[0] += len[par[i]] * Math.cos(a);\n          pos[1] += len[par[i]] * Math.sin(a);\n        }\n        return pos;\n      }\n\n      var pts = [];\n      for (var i = 0; i < ang.length; i++) {\n        pts.push(gpos(sct, i));\n      }\n      yoff -= pts[4][1];\n\n      for (var i = 1; i < pts.length; i++) {\n        var par = gpar(sct, i);\n        var p0 = gpos(sct, par[par.length - 2]);\n        var s = div([p0, pts[i]], 10);\n        //canv += stroke(s.map(toGlobal))\n      }\n\n      var cloth = function(plist, fun) {\n        var canv = \"\";\n        var tlist = bezmh(plist, 2);\n        var [tlist1, tlist2] = expand(tlist, fun);\n        canv += poly(tlist1.concat(tlist2.reverse()).map(toGlobal), {\n          fil: \"white\",\n        });\n        canv += stroke(tlist1.map(toGlobal), {\n          wid: 1,\n          col: \"rgba(100,100,100,0.5)\",\n        });\n        canv += stroke(tlist2.map(toGlobal), {\n          wid: 1,\n          col: \"rgba(100,100,100,0.6)\",\n        });\n\n        return canv;\n      };\n\n      var fsleeve = function(x) {\n        return (\n          sca *\n          8 *\n          (Math.sin(0.5 * x * Math.PI) * Math.pow(Math.sin(x * Math.PI), 0.1) +\n            (1 - x) * 0.4)\n        );\n      };\n      var fbody = function(x) {\n        return (\n          sca *\n          11 *\n          (Math.sin(0.5 * x * Math.PI) * Math.pow(Math.sin(x * Math.PI), 0.1) +\n            (1 - x) * 0.5)\n        );\n      };\n      var fhead = function(x) {\n        return sca * 7 * Math.pow(0.25 - Math.pow(x - 0.5, 2), 0.3);\n      };\n\n      canv += ite(toGlobal(pts[8]), toGlobal(pts[6]), { fli: fli });\n\n      canv += cloth([pts[1], pts[7], pts[8]], fsleeve);\n      canv += cloth([pts[1], pts[0], pts[3], pts[4]], fbody);\n      canv += cloth([pts[1], pts[5], pts[6]], fsleeve);\n      canv += cloth([pts[1], pts[2]], fhead);\n\n      var hlist = bezmh([pts[1], pts[2]], 2);\n      var [hlist1, hlist2] = expand(hlist, fhead);\n      hlist1.splice(0, Math.floor(hlist1.length * 0.1));\n      hlist2.splice(0, Math.floor(hlist2.length * 0.95));\n      canv += poly(hlist1.concat(hlist2.reverse()).map(toGlobal), {\n        fil: \"rgba(100,100,100,0.6)\",\n      });\n\n      canv += hat(toGlobal(pts[1]), toGlobal(pts[2]), { fli: fli });\n\n      return canv;\n    };\n  }();\n\n  function water(xoff, yoff, seed, args) {\n    var args = args != undefined ? args : {};\n    var hei = args.hei != undefined ? args.hei : 2;\n    var len = args.len != undefined ? args.len : 800;\n    var clu = args.clu != undefined ? args.clu : 10;\n    var canv = \"\";\n\n    var ptlist = [];\n    var yk = 0;\n    for (var i = 0; i < clu; i++) {\n      ptlist.push([]);\n      var xk = (Math.random() - 0.5) * (len / 8);\n      yk += Math.random() * 5;\n      var lk = len / 4 + Math.random() * (len / 4);\n      var reso = 5;\n      for (var j = -lk; j < lk; j += reso) {\n        ptlist[ptlist.length - 1].push([\n          j + xk,\n          Math.sin(j * 0.2) * hei * Noise.noise(j * 0.1) - 20 + yk,\n        ]);\n      }\n    }\n\n    for (var j = 1; j < ptlist.length; j += 1) {\n      canv += stroke(\n        ptlist[j].map(function(x) {\n          return [x[0] + xoff, x[1] + yoff];\n        }),\n        {\n          col:\n            \"rgba(100,100,100,\" + (0.3 + Math.random() * 0.3).toFixed(3) + \")\",\n          wid: 1,\n        },\n      );\n    }\n\n    return canv;\n  }\n\n  function mountplanner(xmin, xmax) {\n    function locmax(x, y, f, r) {\n      var z0 = f(x, y);\n      if (z0 <= 0.3) {\n        return false;\n      }\n      for (var i = x - r; i < x + r; i++) {\n        for (var j = y - r; j < y + r; j++) {\n          if (f(i, j) > z0) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n\n    function chadd(r, mind) {\n      mind = mind == undefined ? 10 : mind;\n      for (var k = 0; k < reg.length; k++) {\n        if (Math.abs(reg[k].x - r.x) < mind) {\n          return false;\n        }\n      }\n      console.log(\"+\");\n      reg.push(r);\n      return true;\n    }\n\n    var reg = [];\n    var samp = 0.03;\n    var ns = function(x, y) {\n      return Math.max(Noise.noise(x * samp) - 0.55, 0) * 2;\n    };\n    var nns = function(x) {\n      return 1 - Noise.noise(x * samp);\n    };\n    var nnns = function(x, y) {\n      return Math.max(Noise.noise(x * samp * 2, 2) - 0.55, 0) * 2;\n    };\n    var yr = function(x) {\n      return Noise.noise(x * 0.01, Math.PI);\n    };\n\n    var xstep = 5;\n    var mwid = 200;\n    for (var i = xmin; i < xmax; i += xstep) {\n      var i1 = Math.floor(i / xstep);\n      MEM.planmtx[i1] = MEM.planmtx[i1] || 0;\n    }\n\n    for (var i = xmin; i < xmax; i += xstep) {\n      for (var j = 0; j < yr(i) * 480; j += 30) {\n        if (locmax(i, j, ns, 2)) {\n          var xof = i + 2 * (Math.random() - 0.5) * 500;\n          var yof = j + 300;\n          var r = { tag: \"mount\", x: xof, y: yof, h: ns(i, j) };\n          var res = chadd(r);\n          if (res) {\n            for (\n              var k = Math.floor((xof - mwid) / xstep);\n              k < (xof + mwid) / xstep;\n              k++\n            ) {\n              MEM.planmtx[k] += 1;\n            }\n          }\n        }\n      }\n      if (Math.abs(i) % 1000 < Math.max(1, xstep - 1)) {\n        var r = {\n          tag: \"distmount\",\n          x: i,\n          y: 280 - Math.random() * 50,\n          h: ns(i, j),\n        };\n        chadd(r);\n      }\n    }\n    console.log([xmin, xmax]);\n    for (var i = xmin; i < xmax; i += xstep) {\n      if (MEM.planmtx[Math.floor(i / xstep)] == 0) {\n        //var r = {tag:\"redcirc\",x:i,y:700}\n        //console.log(i)\n        if (Math.random() < 0.01) {\n          for (var j = 0; j < 4 * Math.random(); j++) {\n            var r = {\n              tag: \"flatmount\",\n              x: i + 2 * (Math.random() - 0.5) * 700,\n              y: 700 - j * 50,\n              h: ns(i, j),\n            };\n            chadd(r);\n          }\n        }\n      } else {\n        // var r = {tag:\"greencirc\",x:i,y:700}\n        // chadd(r)\n      }\n    }\n\n    for (var i = xmin; i < xmax; i += xstep) {\n      if (Math.random() < 0.2) {\n        var r = { tag: \"boat\", x: i, y: 300 + Math.random() * 390 };\n        chadd(r, 400);\n      }\n    }\n\n    return reg;\n  }\n\n  MEM = {\n    canv: \"\",\n    chunks: [],\n    xmin: 0,\n    xmax: 0,\n    cwid: 512,\n    cursx: 0,\n    lasttick: 0,\n    windx: 3000,\n    windy: 800,\n    planmtx: [],\n  };\n\n  function dummyloader(xmin, xmax) {\n    for (var i = xmin; i < xmax; i += 200) {\n      //MEM.chunks.push({tag:\"?\",x:i,y:100,canv:Tree.tree08(i,500,i)})\n      //MEM.chunks.push({tag:\"?\",x:i,y:100,canv:Man.man(i,500)})\n      //MEM.chunks.push({tag:\"?\",x:i,y:100,canv:Arch.arch01(i,500)})\n      //MEM.chunks.push({tag:\"?\",x:i,y:100,canv:Arch.boat01(i,500)})\n      //MEM.chunks.push({tag:\"?\",x:i,y:100,canv:Arch.transmissionTower01(i,500)})\n      MEM.chunks.push({\n        tag: \"?\",\n        x: i,\n        y: 100,\n        canv: Arch.arch02(i, 500, 0, { sto: 1, rot: Math.random() }),\n      });\n    }\n  }\n\n  function chunkloader(xmin, xmax) {\n    var add = function(nch) {\n      if (nch.canv.includes(\"NaN\")) {\n        console.log(\"gotcha:\");\n        console.log(nch.tag);\n        nch.canv = nch.canv.replace(/NaN/g, -1000);\n      }\n      if (MEM.chunks.length == 0) {\n        MEM.chunks.push(nch);\n        return;\n      } else {\n        if (nch.y <= MEM.chunks[0].y) {\n          MEM.chunks.unshift(nch);\n          return;\n        } else if (nch.y >= MEM.chunks[MEM.chunks.length - 1].y) {\n          MEM.chunks.push(nch);\n          return;\n        } else {\n          for (var j = 0; j < MEM.chunks.length - 1; j++) {\n            if (MEM.chunks[j].y <= nch.y && nch.y <= MEM.chunks[j + 1].y) {\n              MEM.chunks.splice(j + 1, 0, nch);\n              return;\n            }\n          }\n        }\n      }\n      console.log(\"EH?WTF!\");\n      console.log(MEM.chunks);\n      console.log(nch);\n    };\n\n    while (xmax > MEM.xmax - MEM.cwid || xmin < MEM.xmin + MEM.cwid) {\n      console.log(\"generating new chunk...\");\n\n      var plan;\n      if (xmax > MEM.xmax - MEM.cwid) {\n        plan = mountplanner(MEM.xmax, MEM.xmax + MEM.cwid);\n        MEM.xmax = MEM.xmax + MEM.cwid;\n      } else {\n        plan = mountplanner(MEM.xmin - MEM.cwid, MEM.xmin);\n        MEM.xmin = MEM.xmin - MEM.cwid;\n      }\n\n      for (var i = 0; i < plan.length; i++) {\n        if (plan[i].tag == \"mount\") {\n          add({\n            tag: plan[i].tag,\n            x: plan[i].x,\n            y: plan[i].y,\n            canv: Mount.mountain(plan[i].x, plan[i].y, i * 2 * Math.random()),\n            //{col:function(x){return \"rgba(100,100,100,\"+(0.5*Math.random()*plan[i].y/MEM.windy)+\")\"}}),\n          });\n          add({\n            tag: plan[i].tag,\n            x: plan[i].x,\n            y: plan[i].y - 10000,\n            canv: water(plan[i].x, plan[i].y, i * 2),\n          });\n        } else if (plan[i].tag == \"flatmount\") {\n          add({\n            tag: plan[i].tag,\n            x: plan[i].x,\n            y: plan[i].y,\n            canv: Mount.flatMount(\n              plan[i].x,\n              plan[i].y,\n              2 * Math.random() * Math.PI,\n              {\n                wid: 600 + Math.random() * 400,\n                hei: 100,\n                cho: 0.5 + Math.random() * 0.2,\n              },\n            ),\n          });\n        } else if (plan[i].tag == \"distmount\") {\n          add({\n            tag: plan[i].tag,\n            x: plan[i].x,\n            y: plan[i].y,\n            canv: Mount.distMount(plan[i].x, plan[i].y, Math.random() * 100, {\n              hei: 150,\n              len: randChoice([500, 1000, 1500]),\n            }),\n          });\n        } else if (plan[i].tag == \"boat\") {\n          add({\n            tag: plan[i].tag,\n            x: plan[i].x,\n            y: plan[i].y,\n            canv: Arch.boat01(plan[i].x, plan[i].y, Math.random(), {\n              sca: plan[i].y / 800,\n              fli: randChoice([true, false]),\n            }),\n          });\n        } else if (plan[i].tag == \"redcirc\") {\n          add({\n            tag: plan[i].tag,\n            x: plan[i].x,\n            y: plan[i].y,\n            canv:\n              \"<circle cx='\" +\n              plan[i].x +\n              \"' cy='\" +\n              plan[i].y +\n              \"' r='20' stroke='black' fill='red' />\",\n          });\n        } else if (plan[i].tag == \"greencirc\") {\n          add({\n            tag: plan[i].tag,\n            x: plan[i].x,\n            y: plan[i].y,\n            canv:\n              \"<circle cx='\" +\n              plan[i].x +\n              \"' cy='\" +\n              plan[i].y +\n              \"' r='20' stroke='black' fill='green' />\",\n          });\n        }\n        // add ({\n        //   x: plan[i].x,\n        //   y: plan[i].y,\n        //   canv:\"<circle cx='\"+plan[i].x+\"' cy='\"+plan[i].y+\"' r='20' stroke='black' fill='red' />\"\n        // })\n      }\n    }\n  }\n\n  function chunkrender(xmin, xmax) {\n    MEM.canv = \"\";\n\n    for (var i = 0; i < MEM.chunks.length; i++) {\n      if (\n        xmin - MEM.cwid < MEM.chunks[i].x &&\n        MEM.chunks[i].x < xmax + MEM.cwid\n      ) {\n        MEM.canv += MEM.chunks[i].canv;\n      }\n    }\n  }\n\n  document.addEventListener(\"mousemove\", onMouseUpdate, false);\n  document.addEventListener(\"mouseenter\", onMouseUpdate, false);\n  mouseX = 0;\n  mouseY = 0;\n  function onMouseUpdate(e) {\n    mouseX = e.pageX;\n    mouseY = e.pageY;\n  }\n\n  function calcViewBox() {\n    var zoom = 1.142;\n    return \"\" + MEM.cursx + \" 0 \" + MEM.windx / zoom + \" \" + MEM.windy / zoom;\n  }\n\n  function viewupdate() {\n    try {\n      document.getElementById(\"SVG\").setAttribute(\"viewBox\", calcViewBox());\n    } catch (e) {\n      console.log(\"not possible\");\n    }\n    //setTimeout(viewupdate,100)\n  }\n\n  function needupdate() {\n    return true;\n    if (MEM.xmin < MEM.cursx && MEM.cursx < MEM.xmax - MEM.windx) {\n      return false;\n    }\n    return true;\n  }\n\n  function update() {\n    //console.log(\"update!\")\n\n    self.chunkloader(MEM.cursx, MEM.cursx + MEM.windx);\n    self.chunkrender(MEM.cursx, MEM.cursx + MEM.windx);\n\n    document.getElementById(\"BG\").innerHTML =\n      \"<svg id='SVG' xmlns='http://www.w3.org/2000/svg' width='\" +\n      MEM.windx +\n      \"' height='\" +\n      MEM.windy +\n      \"' style='mix-blend-mode:multiply;'\" +\n      \"viewBox = '\" +\n      calcViewBox() +\n      \"'\" +\n      \"><g id='G' transform='translate(\" +\n      0 +\n      \",0)'>\" +\n      MEM.canv +\n      //+ \"<circle cx='0' cy='0' r='50' stroke='black' fill='red' />\"\n      \"</g></svg>\";\n\n    //setTimeout(update,1000);\n  }\n</script>\n\n<script id=\"downloader\">\n  function download(filename, text) {\n    var element = document.createElement(\"a\");\n    element.setAttribute(\n      \"href\",\n      \"data:text/plain;charset=utf-8,\" + encodeURIComponent(text),\n    );\n    element.setAttribute(\"download\", filename);\n    element.style.display = \"none\";\n    document.body.appendChild(element);\n    element.click();\n    document.body.removeChild(element);\n  }\n</script>\n\n<script id=\"UI\">\n  function xcroll(v) {\n    MEM.cursx += v;\n    if (needupdate()) {\n      update();\n    } else {\n      viewupdate();\n    }\n  }\n  function autoxcroll(v) {\n    if (document.getElementById(\"AUTO_SCROLL\").checked) {\n      xcroll(v);\n      setTimeout(function() {\n        autoxcroll(v);\n      }, 2000);\n    }\n  }\n  function rstyle(id, b) {\n    var a = b ? 0.1 : 0.0;\n    document\n      .getElementById(id)\n      .setAttribute(\n        \"style\",\n        \"\\\n    width: 32px; \\\n    text-align: center;\\\n    top: 0px;\\\n    color:rgba(0,0,0,0.4);\\\n    display:table;\\\n    cursor: pointer;\\\n    border: 1px solid rgba(0,0,0,0.4);\\\n    background-color:rgba(0,0,0,\" +\n          a +\n          \");\\\n  \" +\n          \"height:\" +\n          MEM.windy +\n          \"px\"\n      );\n    document.getElementById(id + \".t\").setAttribute(\n      \"style\",\n      \"vertical-align:middle; display:table-cell\"\n      //\"position:absolute; top:\"+(MEM.windy/2-20)+\"px; left:\"+(MEM.windx+20)+\"px;\"\n    );\n  }\n  function toggleVisible(id) {\n    var v = document.getElementById(id).style.display == \"none\";\n    document.getElementById(id).style.display = v ? \"block\" : \"none\";\n  }\n  function toggleText(id, a, b) {\n    var v = document.getElementById(id).innerHTML;\n    document.getElementById(id).innerHTML = v == \"\" || v == b ? a : b;\n  }\n  var lastScrollX = 0;\n  var pFrame = 0;\n  function present() {\n    var currScrollX = window.scrollX;\n    var step = 1;\n    document.body.scrollTo(Math.max(0, pFrame - 10), window.scrollY);\n\n    pFrame += step;\n\n    //console.log([lastScrollX,currScrollX]);\n\n    if (pFrame < 20 || Math.abs(lastScrollX - currScrollX) < step * 2) {\n      lastScrollX = currScrollX;\n      setTimeout(present, 1);\n    }\n  }\n  function reloadWSeed(s) {\n    var u = window.location.href.split(\"?\")[0];\n    window.location.href = u + \"?seed=\" + s;\n    //window.location.reload(true)\n  }\n  var btnHoverCol = \"rgba(0,0,0,0.1)\";\n</script>\n\n<body style=\"margin:0\">\n  <div\n    id=\"SETTING\"\n    style=\"\n    position:fixed; \n    z-index:1000; \n    left: 40; \n    top: 3;\n    \"\n  >\n    <div\n      id=\"SET_BTN\"\n      style=\"\n      width:32;\n      height:32;\n      color:rgba(0,0,0,0.4);\n      border: 1px solid rgba(0,0,0,0.4);\n      text-align: center;\n      display: table;\n      cursor: pointer;\n      \"\n      onmouseover=\"document.getElementById('SET_BTN').style.backgroundColor=btnHoverCol\"\n      onmouseout=\"document.getElementById('SET_BTN').style.backgroundColor='rgba(0,0,0,0)'\"\n      onclick=\"toggleVisible('MENU');toggleText('SET_BTN.t','&#x2630;','&#x2715;')\"\n      title=\"Settings\"\n    >\n      <div style=\"display:table-cell; vertical-align: middle;\">\n        <font id=\"SET_BTN.t\" size=\"4px\"> &#x2630; </font>\n      </div>\n      <script>\n        window.addEventListener(\"scroll\", function(e) {\n          document.getElementById(\"SETTING\").style.left = Math.max(\n            4,\n            40 - window.scrollX\n          );\n        });\n      </script>\n    </div>\n    <div style=\"height:4px\"></div>\n    <div\n      id=\"MENU\"\n      style=\"\n      display:none;\n      background-color: rgba(0,0,0,0.1);\n      border: 1px solid rgba(0,0,0,0.4);\n      \"\n    >\n      <table>\n        <tr>\n          <td><pre>SEED</pre></td>\n        </tr>\n        <tr>\n          <td>\n            <input title=\"random seed\" id=\"INP_SEED\" />\n            <button\n              onclick=\"reloadWSeed(document.getElementById('INP_SEED').value)\"\n            >\n              Generate\n            </button>\n          </td>\n        </tr>\n        <tr>\n          <td><pre>VIEW</pre></td>\n        </tr>\n        <tr>\n          <td>\n            <button\n              title=\"view left\"\n              onclick=\"xcroll(-parseFloat(document.getElementById('INC_STEP').value))\"\n            >\n              <\n            </button>\n            <input\n              title=\"increment step\"\n              id=\"INC_STEP\"\n              type=\"number\"\n              value=\"200\"\n              min=\"0\"\n              max=\"10000\"\n              step=\"20\"\n            />\n            <button\n              title=\"view right\"\n              onclick=\"xcroll(parseFloat(document.getElementById('INC_STEP').value))\"\n            >\n              >\n            </button>\n          </td>\n        </tr>\n\n        <tr>\n          <td>\n            <pre><input id = \"AUTO_SCROLL\" type=\"checkbox\" \n            onchange=\"autoxcroll(parseFloat(document.getElementById('INC_STEP').value))\">Auto-scroll</pre>\n          </td>\n\n          <td></td>\n        </tr>\n\n        <tr>\n          <td><pre>SAVE</pre></td>\n        </tr>\n        <tr>\n          <td>\n            <button\n              title=\"WARNING: This may take a while...\"\n              type=\"button\"\n              id=\"dwn-btn\"\n              value=\"Download as SVG\"\n              onclick=\"download(''+(Math.random())+'.svg', document.getElementById('BG').innerHTML);\"\n            >\n              Download as .SVG\n            </button>\n          </td>\n        </tr>\n      </table>\n    </div>\n  </div>\n\n  <div\n    id=\"SOURCE_BTN\"\n    style=\"\n      position:fixed; \n      z-index:1000; \n      left: 77; \n      top: 3;\n      width:32;\n      height:32;\n      color:rgba(0,0,0,0.4);\n      border: 1px solid rgba(0,0,0,0.4);\n      text-align: center;\n      display: table;\n      cursor: pointer;\"\n    onmouseover=\"document.getElementById('SOURCE_BTN').style.backgroundColor=btnHoverCol\"\n    onmouseout=\"document.getElementById('SOURCE_BTN').style.backgroundColor='rgba(0,0,0,0)'\"\n    onclick=\"window.location='https://github.com/LingDong-/shan-shui-inf';\"\n    title=\"Fork me on Github!\"\n  >\n    <div style=\"display:table-cell; vertical-align: middle;\">\n      <font id=\"SET_BTN.t\" size=\"4px\"> &lt;/&gt; </font>\n    </div>\n    <script>\n      window.addEventListener(\"scroll\", function(e) {\n        document.getElementById(\"SOURCE_BTN\").style.left = Math.max(\n          41,\n          77 - window.scrollX\n        );\n      });\n    </script>\n  </div>\n\n  <table style=\"border-bottom: 1px solid rgba(0,0,0,0.1);\">\n    <tr>\n      <td>\n        <div\n          id=\"L\"\n          onmouseover=\"rstyle('L',true)\"\n          onmouseout=\"rstyle('L',false)\"\n          onclick=\"xcroll(-200)\"\n        >\n          <div id=\"L.t\"><font size=\"6px\">&#x3008;</font></div>\n          <script>\n            rstyle(\"L\", false);\n          </script>\n        </div>\n      </td>\n\n      <td>\n        <div id=\"BG\">\n          <script>\n            MEM.lasttick = new Date().getTime();\n            document.getElementById(\"INP_SEED\").value = SEED;\n            document\n              .getElementById(\"BG\")\n              .setAttribute(\"style\", \"width:\" + MEM.windx + \"px\");\n            update();\n            document.body.scrollTo(0, 0);\n            console.log([\"SCROLLX\", window.scrollX]);\n            present();\n            //draw();\n          </script>\n        </div>\n      </td>\n\n      <td>\n        <div\n          id=\"R\"\n          onmouseover=\"rstyle('R',true)\"\n          onmouseout=\"rstyle('R',false)\"\n          onclick=\"xcroll(200)\"\n        >\n          <div id=\"R.t\"><font size=\"6px\">&#x3009;</font></div>\n          <script>\n            rstyle(\"R\", false);\n          </script>\n        </div>\n      </td>\n    </tr>\n  </table>\n</body>\n\n<canvas id=\"bgcanv\" width=\"512\" height=\"512\" hidden> </canvas>\n<script>\n  var canvas = document.getElementById(\"bgcanv\");\n  var ctx = canvas.getContext(\"2d\");\n  var reso = 512;\n\n  for (var i = 0; i < reso / 2 + 1; i++) {\n    for (var j = 0; j < reso / 2 + 1; j++) {\n      var c = 245 + Noise.noise(i * 0.1, j * 0.1) * 10;\n      c -= Math.random() * 20;\n\n      var r = c.toFixed(0);\n      var g = (c * 0.95).toFixed(0);\n      var b = (c * 0.85).toFixed(0);\n      ctx.fillStyle = \"rgb(\" + r + \",\" + g + \",\" + b + \")\";\n      ctx.fillRect(i, j, 1, 1);\n      ctx.fillRect(reso - i, j, 1, 1);\n      ctx.fillRect(i, reso - j, 1, 1);\n      ctx.fillRect(reso - i, reso - j, 1, 1);\n    }\n  }\n  var img = canvas.toDataURL(\"image/png\");\n  document.getElementById(\"BG\").style.backgroundImage = \"url(\" + img + \")\";\n  document.getElementsByTagName(\"body\")[0].style.backgroundImage =\n    \"url(\" + img + \")\";\n</script>\n"
        },
        {
          "name": "screenshots",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}